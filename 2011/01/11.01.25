00:00:09 <lpsmith> romanandreg, well,  I'll give you a hint,  the answer for all the specific questions so far a small finite number.  ;-)
00:00:43 <dibblego> very very small, but greater than 0
00:01:00 <lpsmith> Basically,  ignoring partial values,  there is only one function that has type  forall a.  a -> a
00:01:01 <romanandreg> lol
00:01:47 <lpsmith> The function must work with *every* type,  and because it doesn't know anything about the type,  it can't do anything at all.
00:02:16 * ddarius thinks a good trick for understanding higher rank types is to take a game semantics perspective.
00:04:53 <romanandreg> arrggh
00:05:24 <romanandreg> why createField needs to have a specify type for Nothing, this is so frustrating :-(
00:05:52 <ddarius> romanandreg: Just start writing unsafeCoerce everywhere.  Frustration avoided.
00:06:03 <lpsmith> romanandreg,   don't listen to ddarius!
00:06:30 <ddarius> lpsmith: It works for C programmers.
00:06:37 <lpsmith> romanandreg,   you probably want   data Field a = Field { ... getValue :: Maybe a }
00:06:48 <lpsmith> ddarius, ^_^
00:08:06 <eipi> do anyone know how I can end-up having a "not in scope" compilation error for using "putStrLn"?
00:08:50 <c_wraith> import Prelude ()
00:09:02 <c_wraith> or any explicit import list for Prelude that doesn't include it
00:09:38 <romanandreg> lpsmith: whatever has unsafeXXXX I try to avoid
00:10:09 <c_wraith> romanandreg: unsafeXXX is fine if you actually need it.  But it's rare to need UnsafeCoerce
00:10:10 <romanandreg> lpsmith: That's the thing, I didn't want to specify the type in the Field, because it is any type that implements the JSON typeclass
00:10:27 <dolio> If it's any type, then that's an existential.
00:10:28 <romanandreg> I just want a freaking holder for different types, so that I can have a collection of multiple types together
00:10:37 <romanandreg> that's what I'm using JSON in the first place
00:11:09 <romanandreg> :s/what/why/g
00:13:00 <romanandreg> dolio it should work 
00:13:11 <lpsmith> romanandreg, there is nothing too terribly wrong with your pastie
00:13:12 <romanandreg> but I get all this stupid non-sense errors way over my head
00:13:15 <lpsmith> I'm going to put something up
00:14:25 <romanandreg> => http://pastie.org/1495347
00:15:04 <romanandreg> why is there to types a and a', when they all should be the same JSON a
00:15:07 <romanandreg> :-/
00:15:11 <romanandreg> ?
00:15:22 <eipi> I just checked and see no explicite import for Prelude
00:15:47 <Zao> The prelude is implicitly imported unless you use extensions to prevent it.
00:15:49 <romanandreg> sorry if I'm a bit cranky, is just that is 12:27 am, my gf wants me to go to bed, and I want to solve this issue :-/
00:16:07 <dolio> romanandreg: getValue says it can return a value of any type that the caller wishes.
00:16:11 <lpsmith> romanandreg, http://pastie.org/1495349
00:16:12 <Zao> romanandreg: I'm sure that it's still there tomorrow, while your GF might not be.
00:16:16 <dolio> But it cannot.
00:16:38 <lpsmith> also,  note the (Nothing :: Maybe (some kind of JSON type)
00:16:55 <lpsmith> Basically,  if this were ord,  then GHC turns your record into
00:17:28 <lpsmith> getValue :: forall a.   (a -> a -> Ordering) -> Maybe a
00:17:33 <eipi> yes, so I'm puzzled...the project is trivial, using cabal to compile, configuration goes and then it fails with the "not in scope" for a function I believed should be there implicitly
00:17:34 <lpsmith> a rank-2 type
00:18:04 <lpsmith> Your field contains a dictionary of the methods of the JSON class that you can apply to the type
00:18:19 <lpsmith> Not unlike object-oriented programming
00:21:37 <romanandreg> dolio: isn't that what I want
00:21:40 <romanandreg> dolio: ?
00:21:50 <romanandreg> dolio: how does read achieves that? 
00:23:12 <dibblego> what is the denotational semantics for () ?
00:23:37 <lpsmith> dibblego, I'm not sure what you mean;   the CPO for ()  consists of _|_ and ()
00:23:53 <eipi> :q
00:23:58 <dibblego> I mean how is () notated
00:24:50 <lpsmith> well,  as a type,  () is a complete partial order,  and the CPO contains _|_ and ()
00:25:26 <lpsmith> ezyang has a couple of blog posts on CPO and domain theory
00:25:45 <dolio> What if you're using linear coherence spaces?
00:26:14 <lpsmith> dolio, what's that?
00:26:36 <dolio> It's what Girard uses in Proofs and Types for semantics of System F and T.
00:26:57 <ddarius> dibblego: 1 is probably the most common name, though I doubt there is a "standard" name in that context.
00:27:09 <dolio> It's been too long since I read it to describe them.
00:27:23 <dolio> In addition to the fact that I wasn't that interested in them in the first place.
00:27:58 <dolio> Although developing them led him to develop linear logic, as I recall.
00:35:14 <dolio> Anyhow, they have a 'bottom' too, as I recall, even though F and T are both strongly normalizing.
00:35:45 <dolio> I think the natural numbers have infinitely many extra elements, though.
00:37:41 <dolio> It's not exactly a bottom, though, because it's not an ordering.
00:56:48 <Axman6> so, tirns out switching from Data.Vector.Unboxed to Data.Vector can be a very bad idea indeed
00:57:03 <c_wraith> the boxes might eat your program!
00:57:23 <mjrosenb> your boxes may be invaded by homeless people!
00:57:32 <c_wraith> or, more to the point, they may result in a huge buildup of thunks that devours your RAM
00:57:43 <Axman6> c_wraith: they ate all my RAM instead!
00:57:47 <mjrosenb> that to.
00:57:50 <mjrosenb> *too
01:11:12 <ddarius> Hehner has some weird technical diction.
01:13:31 <mjrosenb> ddarius: this is the place to ask.
01:14:21 * ddarius has no idea what mjrosenb is talking about.
01:14:41 <c_wraith> maybe misread diction as question?
01:15:14 <mjrosenb> yeah... i read hehner as ""
01:28:39 <Baughn> Anyone know if iteratees is likely to work on JHC?
01:30:54 <c_wraith> Baughn: any implementation that doesn't use extensions should do fine
01:32:21 <Baughn> c_wraith: So, not the original iteratee then
01:32:29 <Baughn> "TypeFamilies, FlexibleContexts, FlexibleInstances, Rank2Types, DeriveDataTypeable, ExistentialQuantification
01:32:44 <c_wraith> I have no clue what extensions JHC supports
01:32:58 <c_wraith> But...  TypeFamilies suggests a crazy implementation
01:33:11 <c_wraith> There are a bunch of other packages that probably have simpler implementations
01:33:15 <quicksilver> I think it might support rank2 + existential?
01:33:25 <quicksilver> it definitely doesn't support TF (although that is planned)
01:33:38 <quicksilver> and I'm pretty sure it doesn't support derivedatatypeable
01:33:40 * Baughn should go back to making this build on android. :3
01:33:51 <quicksilver> (which is not likely to be required for core functionality)
01:43:29 <jacobian> Any big fans of type families? 
01:43:39 <jacobian> It looks like a fair bit of complexity - I wonder if it's worth it
01:44:10 <Baughn> Yes. They're lovely. Must have them,
01:44:23 <Baughn> I will do science to them!
01:44:32 * pastorn has stayed clear so far
01:44:57 <quicksilver> they seem to express certain intends quite a lot more naturally than FDs.
01:45:00 <Baughn> jacobian: They're rarely required, but they're handy for making library APIs better
01:45:07 <quicksilver> I've not seen them used in practice enough yet.
01:45:26 <Baughn> For "error message" values of "better"
01:47:12 <dmbarbour> Question: are there any special caveats for atomicModifyIORef inside an mfix?
01:48:10 <dmbarbour> hmmm... guess I'll ask again in the morning.
01:48:28 <pastorn> dmbarbour: why not just use MVars?
01:48:37 <pastorn> or STM + TVar?
01:48:57 <dmbarbour> pastorm: I need to create a thread based on the state of an atomic variable.
01:49:09 <pastorn> dmbarbour: check out STM
01:49:28 <dmbarbour> And I need to set the new state of the atomic variable to the new thread id
01:50:41 <pastorn> dmbarbour: this sounds like a task for STM
01:50:48 <dmbarbour> I've used STM. It wouldn't help solve this, since I can't forkIO inside an STM monad.
01:51:03 <dmbarbour> I need mfix.
01:51:12 <pastorn> dmbarbour: well, just have a TVar Bool that's your fork locking
01:51:34 <dmbarbour> Why would I want fork locking?
01:52:18 <pastorn> atomically (take forkLock) >> (forkIO (f var) >>= atomically . writeTVar var) >> atomically (release forkLock)
01:52:21 <pastorn> or something like that
01:52:55 <quicksilver> if you only ever have single statements wrapped in atomically, then STM is pointless
01:53:03 <quicksilver> you might as well use an MVar or an IORef
01:53:18 <quicksilver> I'm not currently understanding why you need mfix, though.
01:54:09 <pastorn> dmbarbour: you could have an TMVar where you put the function you want to fork with and another thread just listeting to that and forking whenever it finds anything
01:54:12 <dmbarbour> quicksilver: I need to decide, atomically, whether to create a thread based on the current state.
01:54:32 <dmbarbour> And I need to assign the current state to the new thread (if I decide to create it.)
01:55:08 <dmbarbour> pastorn: I had an intermediate thread before. I was getting drifts upwards of 10 milliseconds. Not pretty.
01:55:15 <dmbarbour> At the moment I'm performance tweaking.
01:55:44 <pastorn> oh
01:56:45 <quicksilver> dmbarbour: and what does that have to do with value recursion?
01:56:49 <quicksilver> (which is what mfix is)
01:57:35 <dmbarbour> quicksilver: value recursion comes in assigning the thread ID for the new state.
01:57:41 <Arney> How do you raise something to a power in haskell?
01:58:02 <pastorn> dmbarbour: so effectively you want the new thread to know about its thread id?
01:58:12 <aristid> Arney: is it an integer power or a fractional power?
01:58:15 <aristid> :t (^)
01:58:16 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
01:58:18 <aristid> :t (**)
01:58:19 <lambdabot> forall a. (Floating a) => a -> a -> a
01:58:29 <dmbarbour> pastorn: I want everyone reading the variable to know the thread id. 
01:58:41 <Arney> integer, thanks
01:58:46 <pastorn> dmbarbour: the id of the "controller" of that var?
01:59:29 <pastorn> dmbarbour: humour us, what's the application you're working on?
01:59:43 * hackagebot parsec1 1.0.0.1 - Portable monadic parser combinators  http://hackage.haskell.org/package/parsec1-1.0.0.1 (ChristianMaeder)
01:59:50 <aristid> Arney: (^) then
02:00:12 <dmbarbour> pastorn: not quite. The variable exists to ensure only one 'delay' thread exists, and allows other threads to kill and replace it with a shorter delay.
02:00:27 <dmbarbour> pastorn: I'm developing a runtime for a new paradigm.
02:00:38 <dmbarbour> (reactive demand programming)
02:01:30 <pastorn> ah, i see the performance needs then
02:01:36 <pastorn> what's the usual time cost of forkIO?
02:01:49 <Arney> is it normal in haskell to have to make multiple functions for things that would only require one in other languages?
02:02:11 <quicksilver> Arney: No.
02:02:17 <pastorn> Arney: yes... you make many small functions, then you combine them into bigger ones
02:02:34 <pastorn> quicksilver: i'm thinking java methods here
02:02:35 <dmbarbour> Cost of forkIO isn't bad. But if the design requires rapid context switching or locks, that hurts. I'm actually aiming for a wait-free implementation, except at a specific delay point.
02:03:04 <pastorn> dmbarbour: what are those called... the ROFLSCALE things...
02:03:16 <dmbarbour> pastorn: ROFLSCALE?
02:03:20 <pastorn> http://www.youtube.com/watch?v=majbJoD6fzo
02:03:26 <pastorn> fibres
02:03:26 <Arney> Pastron: http://pastebin.com/BMgwXCGf could that be one function
02:04:09 <Arney> since I need to loop and get the results of the loop, it seems like in haskell, functions are loops
02:04:31 <pastorn> Arney: you should take a look at map
02:04:33 <pastorn> @type map
02:04:34 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
02:04:36 <pastorn> @src map
02:04:36 <lambdabot> map _ []     = []
02:04:36 <lambdabot> map f (x:xs) = f x : map f xs
02:05:01 <Arney> Ill consider it more closely next time, it sounds like a key function
02:05:44 <pastorn> Arney: it is
02:05:49 <dmbarbour> pastorn: lol. 
02:05:57 <sipa> and you can use let bindings and where clauses inside your function
02:06:15 <pastorn> Arney: the ones you'll want to know really good when working with lists are map, filter, foldl, foldr and zipWith
02:06:17 <sipa> to create local definitions
02:06:34 <aristid> pastorn: and concatMap :)
02:06:40 <pastorn> the fold functions are a bit tricky in the beginning, at least i thought so
02:06:52 <pastorn> Arney: ah, yes, concat and concatMap
02:07:00 <pastorn> @src concatMap
02:07:00 <lambdabot> concatMap f = foldr ((++) . f) []
02:07:03 <pastorn> wtf?
02:07:11 <Arney> can haskell use win32 api's to like, send key strokes? then i could make this program do my homework
02:07:12 <aristid> pastorn: foldl seems less important
02:07:12 <pastorn> concatMap f xs = concat (map f xs)
02:07:39 <aristid> concatMap has a nice abbreviation: (=<<), but this is beyond the scope of today's lecture ;)
02:07:41 <pastorn> aristid: just talking familiarity here, not performance chasing or anything
02:07:55 <pastorn> aristid: please be quiet, you'll scare the poor sod away
02:08:03 <aristid> :>
02:08:22 <pastorn> Arney: you can catch keystrokes (in a terminal) with getChar
02:08:41 <pastorn> you'll need to import System.IO first and run 'hSetBuffering stdin NoBuffering'
02:08:41 <Arney> lol, alright that answers my question. Im guessing id need a special library.
02:09:22 <pastorn> Arney: from the command line getChar is fine, but if you want fancier stuff you might neet to mess around a bit
02:09:27 <dmbarbour> So, any answers on whether mfix+atomicModifyIORef is a problem?
02:09:33 <pastorn> (fancier stuff = creating windows etc)
02:11:19 <quicksilver> dmbarbour: it's not inherently a problem.
02:11:31 <quicksilver> dmbarbour: there are the obvious issues with value recursion and evaluation order etc.
02:11:48 <quicksilver> but they're not specific to atomicModifyIORef
02:12:42 <dmbarbour> quicksilver: thanks. In this case, I don't actually use the value from atomicModifyIORef; I only assign it inside the atomic operation, but it is decided based upon the current value inside the state.
02:14:27 <dmbarbour> mfix $ \sf -> atomicModifyIORef r (\s0->(sf,s0)) >> sf is decided from s0 and forkIO
02:14:56 <Arney> OMg, i cant believe what just happened
02:15:18 <Arney> I modified three functions, when I ran the program and tested it, All of them worked.
02:15:48 <Arney> I didn't get error, I didn't have to debug for half an hour, its amazing, its never happened to me before
02:16:05 <jacobian> I kind of wish the partial prelude functions would use Maybe rather than exceptions
02:16:17 <jacobian> e.g. last
02:19:06 <pastorn> dmbarbour: pm :)
02:20:08 <dmbarbour> pastorn: what does 'pm' mean?
02:20:14 <pastorn> private message
02:20:21 <pastorn> shit, you need to get your mirkk on
02:20:38 <dmbarbour> haven't done much IRC since uni.
02:24:02 <aristid> Arney_: how long did you need until it compiled?
02:24:38 <quicksilver> jacobian: there often alternatives. For last, try "listToMaybe . reverse"
02:26:55 <jacobian> thanks qs 
02:27:23 <_mpu> There are no ways to catch these exceptions ?
02:27:47 <_mpu> :t error "hi"
02:27:48 <lambdabot> forall a. a
02:28:09 <ddarius> Not in Haskell 98/2010, no.
02:28:54 <ddarius> But then error should only be used in a "something went wildly wrong" type of scenario.
02:29:41 <jacobian> head lst, doesn't seem like a "something went wildly wrong" scenario though. 
02:30:31 <aristid> jacobian: that's why many people prefer safeHead, which returns Maybe a
02:30:59 <ddarius> Yes, and head shouldn't be used, unless an empty list should "never" occur, at which point something went wildly wrong.
02:31:17 <jacobian> true
02:32:49 <quicksilver> aristid: listToMaybe already exists.
02:32:56 <aristid> quicksilver: bad name
02:33:03 <quicksilver> not particularly.
02:33:21 <quicksilver> jacobian: it does though.
02:33:26 <aristid> i don't like it, there are many ways to make a Maybe from a list.
02:33:45 <quicksilver> jacobian: you use 'head lst' when you know, for absolutely sure, that the list is non-empty.
02:33:50 <jacobian> Sure I know
02:34:05 <quicksilver> jacobian: therefore, if its empty something did indeed go wildly wrong.
02:34:10 <jacobian> I just mean that as a design, it's ugly to have something like "head" in the forefront 
02:34:19 <jacobian> it's more like an unsafe unboxing operation
02:34:33 <jacobian> which requires that you have proved separately that the list is never empty 
02:34:55 <quicksilver> aristid: there is one most natural way to make a maybe from a list; it is the way which is a monoid homomorphism and a monad homomorphism.
02:35:41 <path[l]> there are many problems Ive worked on where I know some list will never be empty. it's only when I try to solve a problem recursively where I tend to end up with empty lists
02:35:42 <aristid> quicksilver: sure, listToMaybe does use the most natural way. but head would still be a better name :)
02:36:03 <aristid> quicksilver: and what is currently head would be, uh, unsafeHead or something like that
02:36:20 <quicksilver> it's not unsafe, though. It's partial.
02:36:23 <quicksilver> that's different.
02:36:32 <quicksilver> plenty of reasonable functions are partial.
02:36:44 <quicksilver> sure, we'd rather work with total ones when we can.
02:37:16 <aristid> quicksilver: those i can think of usually return bottom due to looping, and not due to some error "X"
02:37:43 <jacobian> error is often modeled as bottom
02:39:57 <aristid> quicksilver: but why not compromise and have both safeHead and listToMaybe?
02:41:15 <ddarius> We do have both safeHead and listToMaybe.
02:42:39 <aristid> @index safeHead
02:42:39 <lambdabot> bzzt
02:42:46 <aristid> ddarius: where?
02:42:51 <aristid> @hoogle safeHead
02:42:52 <lambdabot> Data.ByteString.Unsafe unsafeHead :: ByteString -> Word8
02:43:22 <jacobian> It wouldn't be well named as safeHead though
02:44:14 <jacobian> partialHead and head seems more appropriate. 
02:44:58 <quuuux> @hoogle headMay
02:44:58 <lambdabot> No results found
02:45:14 <aristid> jacobian: yes, but we can't pragmatically change head
02:45:27 <ddarius> @hackage safe
02:45:27 <lambdabot> http://hackage.haskell.org/package/safe
02:46:18 <jacobian> aristid: Yeah
02:46:25 <ddarius> I guess he calls it headMay rather than safeHead.
02:46:47 <aristid> interesting
02:49:17 <jacobian> I wonder how often use of something like head leads to bugs. 
02:50:00 <jacobian> presumably you'd always have something like length lst > 0 prior, but then you may as well have it in Maybe. 
02:50:26 <aristid> jacobian: length lst > 0? wtf
02:50:40 <aristid> jacobian: not (null lst), if you need to.
02:50:40 <dibblego> head should not call length
02:50:51 <aristid> length is O(n)
02:50:57 <dibblego> length is itself a partial function
02:51:09 <aristid> dibblego: haha. but yeah.
02:51:26 <aristid> genericLength however is not necessarily partial.
02:51:37 <jacobian> Hahaha
02:51:37 <Baughn> 'genericLength l n' can be O(MIN(length l, n)), too
02:51:41 <jacobian> No, obviously
02:51:51 <jacobian> I'm think of in practical programming situations where you might encounter head
02:52:01 <jacobian> It's likely that you have the length sitting around
02:52:15 <dibblego> really, it isn't
02:52:54 <aristid> Baughn: genericLength l n is invalid
02:52:57 <aristid> :t genericLength
02:52:58 <lambdabot> forall b i. (Num i) => [b] -> i
02:53:10 <aristid> Baughn: well, unless you have a Num instance for functions
02:53:18 <Baughn> aristid: Er, sorry
02:53:26 <Baughn> aristid: I meant 'genericLength l < n'
02:53:29 <aristid> oh!
02:53:39 <aristid> yeah, then you are right, and that's what i meant too
02:53:40 <jacobian> If you are testing that the list is null then you've really no justification for using 'head' instead of listToMaybe in my mind. 
02:54:07 <aristid> jacobian: pattern matching is nice, too.
02:55:33 <jacobian> again - in that situation you'd not call head
02:55:48 <jacobian> It's going to be something where you know incidentally that the list is not null
02:56:48 <Baughn> aristid: It would be nice if we could have lazy numbers that are also *efficient*
02:56:57 <Baughn> Well, more so than unary coding. :P
02:57:09 <ddarius> jacobian: There are plenty of cases where you set up invariants that you expect to hold, e.g. abstract data types.
02:57:42 <aristid> Baughn: for genericLength xs > n, unary coding is plenty efficient :)
02:57:50 <ddarius> Baughn: You can.
02:58:19 <Baughn> ddarius: Yeah, but not quite on the level of Int32.
02:58:29 <ddarius> Baughn: Well, no.
02:58:30 <Baughn> ddarius: It would be nice to have the benefits without the space cost. :P
02:58:34 <sipa> not for infinite lists :)
02:58:38 <aristid> hmm.
02:58:47 <sipa> where genericLength xs > n works perfectly, when using unary integers
03:01:59 * hackagebot HTF 0.7.0.0 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.7.0.0 (StefanWehr)
03:03:12 <quicksilver> > map head (iterate (drop 3) [1..])
03:03:13 <lambdabot>   [1,4,7,10,13,16,19,22,25,28,31,34,37,40,43,46,49,52,55,58,61,64,67,70,73,76...
03:03:32 <quicksilver> jacobian: ^^ an example of where you know the list will never be non-empty.
03:03:58 <ddarius> quicksilver: Or the RLE example.
03:04:08 <aristid> > map (head &&& length) . group . sort $ [1,1,2,4,1]
03:04:10 <lambdabot>   [(1,3),(2,1),(4,1)]
03:04:19 * quicksilver nods
03:04:20 <companion_cube> :t iterate
03:04:21 <lambdabot> forall a. (a -> a) -> a -> [a]
03:04:30 <quicksilver> yes, another good one.
03:06:59 <Veinor> another case might be when you're writing a quick script and the list will be only non-empty if user input was invalid :D
03:07:27 <jonkri> is there some way i can i have my tuple be an instance of Show and Read?
03:08:19 <quicksilver> jonkri: tuples already are instances of show and read
03:08:26 <Veinor> assuming the things they're tuples of are.
03:08:28 <quicksilver> > show ('a',34.5)
03:08:29 <lambdabot>   "('a',34.5)"
03:08:51 <quicksilver> > read "('a',34.5)" :: (Char,Double)
03:08:53 <lambdabot>   ('a',34.5)
03:11:32 <jonkri> oh, i see. what i want is to go from a node@domain/resource jid to (node, domain, resource), where the jid type is (maybe node, domain, maybe resource)
03:11:54 <jonkri> is stringToJID and jidToString the way to go here?
03:12:19 <Veinor> yeah. read and show is usually implemented such that the output of 'show' is valid haskell
03:13:16 <Baughn> Given that you can derive(Read,Show) that's pretty universal
03:13:45 <jonkri> i see
03:14:23 <Baughn> If you want to pretty-print, there's a special class for that which is not called Show.
03:15:16 * Baughn sweatdrops
03:15:27 <Baughn> ..then again, pretty/Doc appear to indeed use Show. -_-
03:20:05 <jonkri> Baughn: what is it called?
03:20:09 * hackagebot SimpleEA 0.1 - Simple evolutionary algorithm framework.  http://hackage.haskell.org/package/SimpleEA-0.1 (ErlendHamberg)
03:20:29 <quicksilver> jonkri: I would simply usig stringToJid and jidToString for now.
03:20:41 <jonkri> cheers
03:20:45 <quicksilver> if it becomes clear, later, that you really wanted a typeclass you will probably want to write your own.
03:20:59 <quicksilver> (if you have several different types which convert as part of a serialisation framework)
03:28:19 <Baughn> jonkri: pretty. I don't know if it's worth using; it's marked experimental.
03:29:58 <accel> what library to include to get graphics required for Haskell School of Expression?
03:30:33 <ivanm> there are various classes for pretty-printing
03:30:38 <ivanm> or are you talking about something specific?
03:30:44 <ivanm> accel: I believe it uses its own
03:30:56 <ivanm> there is a version of it on hackage, but it isn't fully compatible with what the book does
03:34:15 <accel> no one wrote a compability lawyer?
03:38:23 <quicksilver> I think the thing on hackage is intended to be a compatibility layer
03:38:28 <quicksilver> it may not be perfect in every respect
03:38:33 <quicksilver> but I think the intention is to let you run the exampels
03:41:23 <accel> hgl provies it it appears
03:41:44 <ivanm> hmmmm..... what would a compatability lawyer be? :p
03:42:16 <accel> it's hte opposite of a divorce laywer
03:42:19 <accel> it tries to get things done
03:42:23 <Baughn> jonkri: My personal tendency is to use Show for pretty-printing specifically in the case where I don't instance Read. If I wanted read /and/ pretty.. I'd probably need to rewrite everything to add another class. ^^;
03:47:58 <jonkri> i'm trying to use a regular expression like this: <<< let test = ("node@domain" =~ "^(?:([^@]+)(@))?([^/]+)(?:(/)(.+))?$" :: [[String]]) >>>... the regular expression works on http://www.regextester.com/, although groups four and five are "undefined". is the regex library unable to handle undefined matches?
03:48:10 <jonkri> oh, the error i get is : *** Exception: user error (Text.Regex.Posix.String died: (ReturnCode 13,"Invalid preceding regular expression"))
03:49:24 <zygoloid> my view is that Show is for inspection within ghci, and not for end-user-visible program output. from that perspective, Show instances which produce Haskell are very useful, but not essential.
03:50:37 <ToRA> if a cabal file specifies -cpp-options, where do they normally end up in a ghc invocation?  -optl-something or elsewhere?
03:51:43 <dcoutts> ToRA: -optP, because they are cpp options, options used when applying the C pre-preprocessor to Haskell code (not C code)
03:51:51 <ToRA> dcoutts: ta
03:52:15 <dcoutts> if you want C code flags then use cc-options
04:00:29 <accel> what are the types of "do" and "<-" ?
04:01:00 <sipa> do is a language keyword, it introduces a do block
04:01:04 <sipa> :t (<-)
04:01:05 <lambdabot> parse error on input `<-'
04:01:22 <sipa> and <- is notation used within that block
04:01:43 <sipa> do { a <- b; c } is equivalent to a >>= \b -> c
04:02:02 <sipa> :t (>>=)
04:02:03 <dibblego> b >>= \a -> c
04:02:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
04:02:12 <sipa> and that's the type of >>=
04:05:12 <accel> Prelude> :t Monad
04:05:12 <accel> <interactive>:1:0: Not in scope: data constructor `Monad'
04:05:25 <accel> how do I look up info on this Monad typeclass ?
04:05:36 <dibblego> :i Monad
04:05:57 <accel> dibblego: thanks; I hereby grant you one virtual piece of farm, with one virtual cow
04:06:31 <accel> so a monad is nothing more than just any other typeclass (like Show), except it supports functions >>= >> return and fail ?
04:07:09 <dibblego> pretty much
04:07:42 <quicksilver> accel: the only special think about monads is that "do" notation desugars to operators which happen to be monad primitives.
04:07:51 <quicksilver> apart from that they are just another typeclass
04:08:20 <accel> so lines w/o "<-" end up being >>
04:08:25 <accel> and lines with "<-" end up being >>= ?
04:08:49 <dibblego> that's pretty close to good enough for now
04:09:12 <Egbert9e9> are there any thoughts of making haskell compile into jvm?
04:09:19 <Egbert9e9> and use jvm libs?
04:09:22 <dibblego> Egbert9e9, yes we think about it all the time
04:09:22 <quicksilver> Egbert9e9: it's been done twice. Maybe three times.
04:09:32 <Egbert9e9> ya, i saw those
04:09:43 <Egbert9e9> but they seem old and unmaintained
04:09:43 <quicksilver> each effort has bitrotted because nobody appears to care enough to keep them alive
04:09:49 <Egbert9e9> ah
04:09:51 <quicksilver> which suggests it would be pointless doing it again
04:09:58 <dibblego> I've not seen a solution with interoperability with java libraries 
04:09:59 <quicksilver> unless you had reason to believe people care now in a way they didn't before ;)
04:10:21 <Egbert9e9> nah
04:11:07 <quicksilver> dibblego: lambdavm did
04:11:14 <quicksilver> dibblego: http://webcache.googleusercontent.com/search?q=cache:3KqN7vYa6DgJ:wiki.brianweb.net/LambdaVM/FFI+lambdavm+java+libraries&cd=2&hl=en&ct=clnk&gl=uk
04:11:25 <quicksilver> (google cache because his wiki appears to be down)
04:11:49 <dibblego> ah yes, all Java calls are in IO
04:11:57 <dibblego> there is also CAL where all Java calls are not in anything
04:12:10 <dibblego> I think so much about it, that I have dismissed these
04:13:14 <quicksilver> dibblego: FFI calls being in IO is, to some extent, a trivial detail.
04:13:27 <quicksilver> dibblego: unsafePerformIO was part of the FFI addendum for exactly this reason, was it not?
04:13:35 * hackagebot Command 0.0.2 - A replacement for System.Exit and System.Process  http://hackage.haskell.org/package/Command-0.0.2 (TonyMorris)
04:13:46 <quicksilver> and you can simply omit the IO
04:13:49 <sipa> you can declare FFI calls to be pure as well
04:13:51 <quicksilver> right.
04:15:49 <haskelol> sup nigs
04:16:01 <Axman6> yo dawg
04:16:42 <accel> inside a do block
04:16:47 <accel> is ther ean implicit return before every line?
04:16:57 <Axman6> no
04:16:57 <haskelol> yes
04:17:03 <accel> because >> is  m a -> m b -> m b
04:17:16 <accel> but most lines just have type "a" rather than "m a"
04:17:30 <Axman6> m >> f = m >>= \_ -> f
04:17:37 <quicksilver> accel: nope; all lines will have the type "m a"
04:17:46 <haskelol> q p
04:17:48 <haskelol>  w
04:17:50 <quicksilver> the only place with something like an implicit return is the ghci repl
04:17:55 <quicksilver> from some perspectives
04:17:59 --- mode: ChanServ set +o quicksilver
04:18:04 --- mode: quicksilver set +b *!*80f315e0@*.128.243.21.224
04:18:04 --- kick: haskelol was kicked by quicksilver (obvious troll is obvious)
04:18:14 <sipa> accel: you know what return does?
04:18:33 <accel> return :: a -> m a
04:18:38 <accel> what can it do? it wrap it in a monad
04:18:49 <dibblego> > return 7 :: [Int]
04:18:50 <lambdabot>   [7]
04:19:09 <accel> ah, is that how I choose different monads?
04:19:12 <accel> > retur 7 :: Maybe Int
04:19:13 <lambdabot>   Not in scope: `retur'
04:19:18 <accel> > return 7 :: Maybe Int
04:19:19 <lambdabot>   Just 7
04:19:23 <dibblego> usually you're already in one
04:19:23 <accel> > return 7 :: IO Int
04:19:24 <lambdabot>   <IO Int>
04:19:28 <quicksilver> normally there is no need to choose, because the wider context makes it obvious
04:19:34 <accel> as in the do block?
04:19:35 <dibblego> > [1,2,3] >>= \x -> return [x, x + 1]
04:19:36 <lambdabot>   [[1,2],[2,3],[3,4]]
04:19:40 <quicksilver> but if you have an ambigous statement, that is one way to choose.
04:19:41 <Axman6> yay type inference
04:19:47 <dibblego> > do x <- [1,2,3]; return [x, x+1]
04:19:48 <lambdabot>   [[1,2],[2,3],[3,4]]
04:20:05 <accel> whoa, so "::" is not just that's 1 line above a function
04:20:14 <accel> it can be used anywhere to say "expr on left side" has "type on right side" ?
04:20:17 <quicksilver> yes
04:20:23 <quicksilver> you can put it anywhere in an expression
04:20:26 <quicksilver> > (1 :: Int) + 3
04:20:27 <lambdabot>   4
04:20:38 <aristid> it's NOT a cast tho
04:20:44 <aristid> > (1 :: Int) :: Double
04:20:46 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
04:20:46 <lambdabot>         against inferred ty...
04:21:00 <Axman6> > 47.521*2
04:21:01 <lambdabot>   95.042
04:21:11 <burp> :t \(x :: Int) -> x+1
04:21:12 <lambdabot> Int -> Int
04:21:13 <Axman6> > 47.521*2 - 60
04:21:14 <lambdabot>   35.042
04:21:23 <burp> that needs some extension though
04:21:30 <accel> i wonder if haskell parser or perl parser is uglier
04:21:48 <Axman6> > 94.557/47.521
04:21:49 <lambdabot>   1.9897939858167968
04:22:05 <Axman6> accel: perl for sure, though both have been written in haskell
04:22:21 <Axman6> perl's grammar is ambiguous, so it can't be statically parsed
04:23:03 <accel> what does that mean it can't be statically parsed?
04:23:09 <accel> you have to execute a perl program as you parse it?
04:23:29 <quicksilver> accel: yes, in a few pathological cases.
04:24:11 <accel> window 3
04:24:23 <quicksilver> http://www.perlmonks.org/?node_id=663393
04:24:36 <Axman6> the original parl6 impementation, pugs, was written in haskell
04:24:37 <dark> how to print all elements of a list?
04:24:39 <Axman6> perl*
04:24:46 <dibblego> dark, mapM_ print
04:25:05 <dark> can it be done with do { } ?
04:25:10 <dibblego> sure
04:25:18 <dibblego> homework?
04:25:32 <dark> no, was just wondering
04:25:47 <dark> ocaml has List.iter for doing that, but, haskell can't work that way..
04:25:55 <dark> @src mapM_
04:25:56 <lambdabot> mapM_ f as = sequence_ (map f as)
04:26:11 <Axman6> printList [] = return (); printList (x:xs) = do { print x; printList xs}
04:26:29 <dark> @src sequence_
04:26:30 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
04:27:34 <Silvah> :t print . map show
04:27:34 <lambdabot> forall a. (Show a) => [a] -> IO ()
04:27:41 <Silvah> :t mapM_ print
04:27:42 <lambdabot> forall a. (Show a) => [a] -> IO ()
04:27:54 <dark> Axman6, a = b; a = c, in this case, ; is inserted instead of a \n?
04:27:55 <Silvah> er
04:28:04 <Silvah> :t putStr . map show
04:28:05 <lambdabot>     Couldn't match expected type `Char' against inferred type `String'
04:28:05 <lambdabot>     In the first argument of `map', namely `show'
04:28:05 <lambdabot>     In the second argument of `(.)', namely `map show'
04:28:14 <Axman6> dark: yes
04:28:18 <Silvah> :t putStr . unlines . map show
04:28:18 <lambdabot> forall a. (Show a) => [a] -> IO ()
04:28:43 <accel> does the monad laws require
04:28:43 <Silvah> putStr . unlines . map show $ [1, 2, 3, 4, 5, 6]
04:28:44 <dark> I did let fib = 1 : scanl (+) 1 fib at ghci
04:28:45 <accel> that >> be equiv to >>= \_ ->
04:28:50 <accel> if so, why is there a separate >> ?
04:28:51 <Silvah> > putStr . unlines . map show $ [1, 2, 3, 4, 5, 6]
04:28:52 <dark> and typed fib. i expected some stack overflow
04:28:52 <lambdabot>   <IO ()>
04:29:04 <dark> but it keeps showing latter elements of the list o.o
04:29:26 <Axman6> dark: why shouldn't it? it's lazily producing each element
04:29:37 <accel> does the monad laws require that >> be equiv to >>= \_ -> ; if so, why is there a separate >> ?
04:29:39 <Botje> accel: >> can be faster
04:29:41 <dark> is that definition tail recursive?
04:29:53 <Botje> accel: for example, in the reader monad >> can just ignore its left argument
04:29:57 <dark> i would expect it to not to be
04:30:12 <dark> (also mapM_ print fib, keeps showing the elements, without some stack overflow)
04:30:14 <Axman6> dark: i think it is
04:30:27 <dark> @src scanl
04:30:27 <lambdabot> scanl f q ls = q : case ls of
04:30:28 <lambdabot>     []   -> []
04:30:28 <lambdabot>     x:xs -> scanl f (f q x) xs
04:30:47 <Silvah> > let fib = 1 : scanl (+) 1 fib in fib
04:30:48 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
04:30:49 <Axman6> once each element is computed, it is printed, and then garbage collected if needed
04:31:05 <dark> scanl looks tail recursive
04:31:12 <Axman6> > let fib = 1 : scanl (+) 1 fib in fib !! 10000
04:31:13 <lambdabot>   544383731135652813387342609937503801353891845546959670262477158412085828656...
04:31:16 <Axman6> > let fib = 1 : scanl (+) 1 fib in fib !! 100000
04:31:19 <lambdabot>   420269270299515438631900510129391513177391570263223450330471608719833573145...
04:31:22 <Axman6> heh
04:31:29 <dark> btw haskell does this fast o.o
04:31:37 <Axman6> indeed
04:33:24 <dark> Silvah, print . map show doesn't print the same as mapM_ print. maybe this proves that there is more than one way of printing (since they have the same type)
04:33:58 <Axman6> they do different things though
04:34:04 <Axman6> @src print
04:34:04 <lambdabot> print x = putStrLn (show x)
04:34:17 <Axman6> > show . map show $ [1..]
04:34:19 <lambdabot>   "[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\...
04:34:28 <Axman6> > show $ [1..]
04:34:29 <lambdabot>   "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
04:35:19 <Silvah> dark: putStr . unlines . map show
04:35:48 <dark> whenever i type a function at ghci it gives me an error that there is no stance for Show. but could a function actually be a instance of Show? i think that in this case it should just print something similar to :t ..
04:36:05 <dark> uhm. yes
04:36:10 <Axman6> > print
04:36:11 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> GHC.Types.IO ())
04:36:12 <lambdabot>    arising f...
04:36:21 <dark> > \x. x
04:36:22 <lambdabot>   <no location info>: parse error on input `.'
04:36:28 <dark> > \x -> x
04:36:30 <Axman6> ->, not .
04:36:30 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
04:36:30 <lambdabot>    arising from a use of `...
04:36:32 <Axman6> yeh
04:36:40 <Silvah> I just mistook print . map show for that one.
04:36:50 <dark>     No instance for (Show (t -> t)) here
04:37:30 <accel> http://www.haskell.org/haskellwiki/Monad_Laws <-- how do those three laws imply that >> = \_ ->
04:37:43 <Silvah> dark: lambdabot has her own Show instances for functions.
04:37:45 <accel> err, imply that ">>" equals ">>= \ _ ->"
04:37:59 <quicksilver> accel: they don't; that's just a definition, it's not part of the laws.
04:38:05 <Botje> accel: that's the definition of >>.
04:38:16 <Axman6> well, a definition of >>
04:38:16 <Botje> the laws don't have anything to say about it
04:38:16 <quicksilver> accel: the laws relate >>= and return.
04:38:17 <accel> so when I define a monad, I don't define >> ?
04:38:18 <kuffaar> Botje no, it could be different
04:38:32 <kuffaar> accel: You don't need to
04:38:34 <kuffaar> But you can
04:38:35 <Botje> kuffaar: yes, it's a /default/ definition
04:38:37 <quicksilver> accel: you don't have to, no. You can if you have a more efficient definition that >>= \_ ->
04:38:42 --- mode: quicksilver set -o quicksilver
04:39:31 <lpsmith> Couldn't match expected type `network-2.2.1.7:Network.Socket.Internal.Family' against inferred type `Family'
04:39:42 <lpsmith> I'm importing Network.Socket.Internal ^
04:39:58 <lpsmith> (although Network.Socket should work too)
04:40:41 <lpsmith> ahh, broken packages,  n/m
04:41:05 <lpsmith> err
04:41:14 <accel> dumb question: what functions do I need to define then to make a Monad ?
04:41:19 <lpsmith> ok, I understand now
04:41:28 <lpsmith> (>>=) and return
04:41:30 <lpsmith> that's it
04:42:09 <accel> no need to define fail ?
04:42:18 <accel> http://www.haskell.org/haskellwiki/Monad <-- confsues me
04:42:21 <accel> it clearly lists 4 functions
04:42:25 <accel> yet the monad laws only care about 2 of them
04:42:51 <Axman6> @src Monad
04:42:51 <lambdabot> class  Monad m  where
04:42:51 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
04:42:51 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
04:43:01 <sipa> (a >> b) is defined as (a >>= \_ -> b)
04:43:04 <Axman6> hmm, there's more than that
04:43:21 <sipa> hence, all monad laws that apply to >>=, apply to >> as well through that identity
04:43:25 <Axman6> accel: no one likes having fail as part of Monad
04:43:41 <lpsmith> accel,  you can define your own (>>)  if you can make it a little faster,  but strictly speaking,  the compiler will do it for you
04:44:07 <lpsmith> and "fail" shouldn't really be part of the Monad class anyway
04:44:18 <lpsmith> and it also has a perfectly reasonable default definition
04:44:56 <lpsmith> @src sort
04:44:57 <lambdabot> sort = sortBy compare
04:45:01 <lpsmith> @src sortBy
04:45:01 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
04:45:17 <lpsmith> Yeah,  that's definitely not the way sortBy is implemented either ^_^
04:45:18 * Axman6 wonders if a counting monad might be useful, that increments a number each time >>= is used
04:46:07 <dibblego> Axman6, Writer
04:46:08 <quicksilver> Axman6: it would break some of the laws
04:46:18 <quicksilver> Axman6: although it might be interesting despite that.
04:46:35 <lpsmith> quicksilver, only if you allow the monadic computation to access that counter
04:46:53 <lpsmith> Otherwise,  to "break" the law you have to refer to a run function
04:46:55 <Axman6> i think it could be more interesting with a fork construct as well, which gives the maximum depth of two computations in this monad
04:46:57 <lpsmith> which... 
04:46:58 <quicksilver> lpsmith: well, it breaks the law that "return () >> return ()" = "return ()"
04:47:12 <quicksilver> lpsmith: ...depending how you read that = symbol.
04:47:13 <BONUS> counting functor already breaks functor laws
04:47:13 <BONUS> soo
04:47:14 <lambdabot> BONUS: You have 1 new message. '/msg lambdabot @messages' to read it.
04:47:27 <lpsmith> quicksilver, depends on your point of view
04:47:39 <lpsmith> from inside the monad,  there is no difference
04:47:43 <quicksilver> lpsmith: ...depending how you read that = symbol.
04:47:48 <lpsmith> if you don't allow the computation access to the counter
04:47:49 <lpsmith> right
04:47:52 <BONUS> it always kind of bothered me how loosely defined the = symbol is in the monad laws
04:48:06 <BONUS> or rather that it lacks definition
04:48:17 <lpsmith> Now,  if you allow the computation access to the counter,  then you are definitely breaking the monad law!
04:49:36 <lpsmith> I remember a discussion with a prof a few years ago over something similar.   In my case,  I was putting a "yeild" type effect inside >>=
04:49:37 <Silvah> If = in the monad laws is defined as "it'd be nice if it were the same, but it doesn't really have to", then you're not breaking any laws :P
04:50:30 <BONUS> i read the = so that it says that all the constructors have to be the same
04:50:35 <BONUS> in the final values
04:50:49 <Silvah> > Nothing == Nothing
04:50:50 <lambdabot>   True
04:51:37 <Silvah> What's the type of the two Nothings in "Nothing == Nothing"? :>
04:51:48 <Axman6> probably Maybe ()
04:51:58 <jacobian> ;)
04:51:59 <accel> as long as >>= extracts "a" from "m a", how can we break the monad law: return a >>= k  =  k a ?
04:52:03 <Axman6> :t ?Nothing == Nothing
04:52:04 <lambdabot> parse error on input `?'
04:52:08 <Axman6> bah
04:52:20 <Axman6> :t let a = Nothing in a? == Nothing
04:52:21 <lambdabot> parse error on input `=='
04:52:24 <Axman6> :t let a = Nothing in ?a == Nothing
04:52:25 <lambdabot> forall a. (?a::Maybe a, Eq a) => Bool
04:52:31 <Axman6> hmm
04:52:53 <quicksilver> BONUS: I read it as denotational equality.
04:53:13 <kuffaar> :t ?a
04:53:13 <quicksilver> BONUS: this only leaves a problem for IO, where we don't have a denotation; in that case I consider it observational equality.
04:53:14 <lambdabot> forall t. (?a::t) => t
04:53:24 <kuffaar> What does the ? mean?
04:53:33 <quicksilver> and I choose to ignore undefined, as well.
04:53:47 <quicksilver> kuffaar: it's a fairly unpopular extension called implicit parameters
04:53:59 <BONUS> yeah denotational equality seems correct for that =
04:54:17 <parcs> is setting NoBuffering on a handle and hFlushing the handle after every send action the same thing?
04:55:28 <quicksilver> parcs: NoBuffering may actually flush after each character
04:55:39 <quicksilver> parcs: so, hFlushing explicitly after every send may be faster.
04:56:07 <Axman6> if this is important though, you should probably be using bytestrings
04:56:23 <parcs> Axman6: i am
04:56:26 <parcs> quicksilver: interesting
04:57:25 <quicksilver> with bytestrings it probably isn't flushing after each char
04:57:34 <quicksilver> because network-bytestring was written to be efficient.
04:58:06 <parcs> actually, i'm using the high-level Network api and working with handles
04:58:52 <parcs> so what should i use in my case? both NoBuffering and hFlushing seem to work equally well
05:00:26 <quicksilver> use NoBuffering until you identify a performance problem
05:00:30 <quicksilver> because it's simpler for the programmer
05:01:35 <accel> so by the second law of thermo-monads; >>= return = identity ?
05:02:01 <parcs> sounds good, thanks for the advice
05:05:50 <parcs> accel: i believe so
05:07:48 <hpc> :t (>>= return)
05:07:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
05:12:39 <accel> is it possile to rewrite the semantics of do
05:12:44 <accel> w/o rewriing the haskell parser?
05:13:26 <quicksilver> there is a rebindable syntax extension in GHC, accel 
05:13:47 <quicksilver> which lets you substitute your own versions of >> >>= etc which might have entirely different types
05:13:54 <quicksilver> http://www.haskell.org/ghc/docs/6.8.1/html/users_guide/syntax-extns.html#rebindable-syntax
05:15:54 <accel> taht let me change semantics
05:15:55 <accel> but not syntax
05:15:58 <accel> whereas in scheme,
05:16:03 <accel> do would just be a macro
05:16:07 <accel> and I could change hot it was parsed
05:16:15 <quicksilver> you asked about rewriting the semantics :P
05:16:23 <quicksilver> 13:22 < accel> is it possile to rewrite the semantics of do
05:16:28 <accel> my bad
05:16:35 <quicksilver> for macros, you need TH.
05:16:41 <accel> quirksilver 1; accel -1;
05:16:57 <quicksilver> which is not as convenient as lisp macros in a variety of ways.
05:17:00 <zygoloid> accel: some of us consider the syntax of haskell being fixed to be a feature :) what do you want to accomplish?
05:17:24 <accel> I hate the complexity/ugliness of C++ templates
05:17:29 <accel> I hope building DSLs in haskell is more "free"
05:17:46 <quicksilver> you can build an entirely abitrary DSL as a quasiquote
05:17:48 <accel> I like the _semantic_ rigidity of haskell, but the syntax of lisp
05:18:04 <Zao> Madness.
05:18:05 <accel> http://www.liskell.org/
05:18:08 <accel> I think that's what I want
05:18:14 <quicksilver> (quasiquotation is, essentially, an example of TH, albeit one well integrated with the compiler)
05:20:23 <zygoloid> accel: building DSLs in haskell usually works well in practice, even without syntactic extensions
05:21:39 <kuffaar> accel: Is it Scheme-ish?
05:25:09 <accel> liskell is lisp syntax haskell semantics
05:25:37 <kuffaar> I just saw it uses define, which is Scheme'ish, isn't it?
05:26:01 <accel> lisp&scheme are close enough
05:26:07 <accel> for my needs
05:26:24 <kuffaar> Of course it's a Lisp
05:26:33 <jao> accel: there's also lisk: http://chrisdone.com/posts/2010-11-25-lisk-lisp-haskell.html
05:26:37 <kuffaar> I was just saying it's closer to Scheme than to the more popular Common Lisp?
05:26:43 <kuffaar> Or even Clojure
05:27:17 <accel> jao: lisk is cute
05:27:39 <kuffaar> I believe I just discovered an issue with Cabal which the developers did not foresee
05:27:46 * jao nods
05:27:55 <kuffaar> In its version specific paths it does not include architecture
05:28:10 <kuffaar> Whereas on Windows it's common to have binaries for two different architectures
05:28:15 <kuffaar> (IA-32 and AMD64)
05:28:20 <kuffaar> They would collide in this case
05:28:20 <accel> ick liskell is bound to ghc 6.6
05:28:24 <accel> which is knida old
05:28:24 <dcoutts> kuffaar: it's just a default, you can use ${arch} in the paths
05:28:41 <kuffaar> Ah, ok
05:28:46 <dcoutts> kuffaar: we did indeed anticipate some setups might want arch-specific dirs, which is why it's configurable
05:28:50 <boegel> is there a list of usefull Haskell functions that people think should be included in the Prelude?
05:29:02 <boegel> on a wiki page, blog post, whatever?
05:29:03 <dcoutts> kuffaar: perhaps you're saying that these days on windows that dual-arch should be the default.
05:29:11 <kuffaar> Yeah I think so
05:29:13 <dcoutts> kuffaar: which is an interesting point.
05:29:16 <boegel> or does someone have a collection of stuff they use often they want to share?
05:29:32 <dcoutts> kuffaar: does ghc now ship in 32 and 64bit versions on windows?
05:29:32 <kuffaar> I want to build an AMD64 version of the latest ghc on Windows really
05:29:37 <kuffaar> No, 32-bit only
05:29:45 <kuffaar> But I am considering building everything from scratch
05:29:49 <kuffaar> It will be a huge pain
05:29:57 <kuffaar> I'd use the head of cabal then, too
05:30:08 <kuffaar> 1.11 vs. 1.10
05:30:09 <dcoutts> kuffaar: ok, so we'll probably change the default when ghc ships a 64bit version for windows
05:30:22 <kuffaar> dcoutts are they even ever going to do that?
05:30:23 <dcoutts> kuffaar: so you can edit your cabal config file, edit the paths section
05:31:31 <dcoutts> kuffaar: see the install-dirs section of the config file, see where it currently has $compiler, you can make that $compiler-$arch or $compiler/$arch or whatever
05:31:32 <hpc> kuffaar: seeing as how 64-bit is rapidly becoming the default, they have to
05:31:54 <dcoutts> kuffaar: note that -- is a commented out line
05:32:52 * hackagebot histogram-fill 0.4 - Library for histograms creation.  http://hackage.haskell.org/package/histogram-fill-0.4 (AlexeyKhudyakov)
05:33:53 <kuffaar> What backends does ghc currently have?
05:33:57 <kuffaar> LLVM, C--?
05:34:24 <quicksilver> C-- isn't a backend in that sense
05:34:27 <quicksilver> it's the layer before
05:34:39 <quicksilver> backends are llvm, native code, GCC
05:34:42 <kuffaar> Oh, ok
05:34:48 <kuffaar> The current default is... native?
05:34:52 <quicksilver> the GCC backend is deprecated
05:34:56 <kuffaar> And the future default will probably LLVM?
05:34:56 <quicksilver> yes, that's right
05:35:07 <quicksilver> maybe, maybe not.
05:35:09 <kuffaar> Can ghc cross compile?
05:35:13 <quicksilver> no
05:35:15 <hpc> kuffaar: sadly no
05:35:22 <quicksilver> although people are working on it
05:37:33 <kuffaar> Hmm I wonder how you build an AMD64 version on Windows
05:37:41 <kuffaar> I mean, MinGW can cross compile by default, no?
05:37:53 <kuffaar> Because the MinGW binaries are all 32-bit by default
05:40:37 <kuffaar> Oh, I think it can't :[
05:40:40 <kuffaar> http://sourceforge.net/projects/mingw-w64/
05:40:46 <kuffaar> This looks like a cross compiler
05:48:17 <kuffaar> Wait, if there are no AMD64 binaries for Windows
05:48:21 <kuffaar> And ghc can't cross compile
05:48:26 <kuffaar> Then I have a boot strapping problem here
05:48:29 <kuffaar> :|
05:50:24 <kuffaar> http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg12294.html
05:50:27 <rribeiro> Hi folks! Does anyone knows where I can download the code of GRIN - developed by Boquist ?
05:51:18 <quicksilver> kuffaar: well, there is a boot strap procedure but it's a bit of a pain
05:51:25 <kuffaar> I can imagine
05:51:39 <kuffaar> quicksilver apparently the real problem is that there's no 64-bit MinGW yet?
05:51:44 <quicksilver> perhaps.
05:51:51 <quicksilver> I know nothing about windows. Never used it :-/
05:52:04 <kuffaar> This sounds like a job for me though, I love wasting my time on stuff like this
05:52:21 <kuffaar> I don't even need 64-bit binaries, it would make no difference whatsoever
05:52:24 <kuffaar> It's just masturbation
06:03:57 <Botje> lies
06:04:01 <Botje> 64bit has more registers
06:04:09 <Botje> so less memory access!
06:07:03 <int-e> @quote
06:07:04 <lambdabot> jre2 says: berp seems to lack python's awesome feature of not optimizing tail calls
06:07:10 <kuffaar> Botje: I don't do any number crunching
06:07:12 <kuffaar> At all
06:07:28 <kuffaar> I'm mostly DB bottlenecked
06:07:34 <kuffaar> PostgreSQL
06:09:28 <Botje> okay, fair enough :P
06:14:24 <quuuux> @hoogle (a -> b) -> (b -> c) -> a -> c
06:14:25 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
06:14:25 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
06:14:25 <lambdabot> Control.Parallel.Strategies (-|) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
06:14:52 <quuuux> yes, very handy, hoogle, when I'm after a short alias for `flip (.)' :(
06:17:00 <Veinor> @pl flip (.)
06:17:01 <lambdabot> flip (.)
06:17:13 <Veinor> @djinn (a -> b) -> (b -> c) -> (a -> c)
06:17:13 <lambdabot> f a b c = b (a c)
06:17:17 <Veinor> :|
06:21:08 <lunaris> :t (>>>)
06:21:09 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
06:21:18 <lunaris> That'll work for the (->) instance.
06:21:39 <lunaris> :t (>>>) :: (a -> b) -> (b -> c) -> (a -> c)
06:21:40 <lambdabot> forall a b c. (a -> b) -> (b -> c) -> a -> c
06:22:04 <alpounet> > (+1) >>> (*2) $ 4
06:22:05 <lambdabot>   10
06:22:12 <alpounet> > (+1) . (*2) $ 4
06:22:13 <lambdabot>   9
06:22:17 <lunaris> :)
07:02:10 <Silvah> :t (<$>)
07:02:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:02:22 <Silvah> Functor?
07:02:32 <Silvah> @src (<$>)
07:02:32 <lambdabot> f <$> a = fmap f a
07:02:42 <Silvah> Ah.
07:02:59 <lpsmith> Ok,  I'm trying to use hslogger and having a lot of trouble getting it to work
07:03:14 <lpsmith> Of course,  it probably doesn't help that I don't know much about syslog either
07:03:25 <Jafet> There's really only one logical definition for Functor f => (a -> b) -> f a -> f b
07:03:52 <lpsmith> but at the moment,  I believe the difficulty is on hslogger's end
07:18:18 <rribeiro> :t gfoldl
07:18:20 <lambdabot> forall (c :: * -> *) a. (Data a) => (forall d b. (Data d) => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a
07:20:25 <dark> @src gfoldl
07:20:26 <lambdabot> Source not found. Wrong!  You cheating scum!
07:21:38 <Silvah> lol
07:22:07 <ski> iirc, `gfoldl' is a type class method
07:22:31 <dark> @hoogle gfoldl
07:22:32 <lambdabot> Data.Data gfoldl :: Data a => (c (d -> b) -> d -> c b) -> (g -> c g) -> a -> c a
07:22:32 <lambdabot> Data.Generics.Twins gfoldlAccum :: Data d => (a -> c (e -> r) -> e -> (a, c r)) -> (a -> g -> (a, c g)) -> a -> d -> (a, c d)
07:23:00 <dark> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Data.html#v:gfoldl
07:23:20 <ski> @source Data.Data
07:23:21 <lambdabot> Data.Data not available
07:23:25 <ski> mhm
07:23:30 <dark> but not quite the gfoldl that lambdabot's :t was talking about
07:23:39 <dark> i think
07:23:40 <dark> o.o
07:24:04 <dark> or at least the type seems different
07:24:32 <dark> actually the forall seems implicit
07:24:58 * ski thinks the type looks the same
07:25:02 <dark> like if lambdabot at :t wanted to make explicit foralls and hoogle reported implicit ones
07:25:31 <ski> yeah, `hoogle' doesn't show higher-rank types correctly
07:25:39 <ski> @type Control.Monad.ST.runST
07:25:41 <lambdabot> forall a. (forall s. ST s a) -> a
07:25:43 <ski> @hoogle runST
07:25:44 <lambdabot> Control.Monad.ST runST :: ST s a -> a
07:25:44 <lambdabot> Control.Monad.ST.Lazy runST :: ST s a -> a
07:25:44 <lambdabot> Data.Array.ST runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
07:26:24 <dark> but it was the type shown at hackage
07:26:36 <ski> sorry ?
07:26:44 <dark> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Data.html#v:gfoldl
07:26:48 <ski> what does "it" refer to ?
07:26:57 <dark> Data a => (c (d -> b) -> d -> c b) -> (g -> c g) -> a -> c a
07:27:14 <ski> at that link, i see the same type as
07:27:20 <dark> but oh
07:27:21 <ski> @type gfoldl
07:27:23 <lambdabot> forall (c :: * -> *) a. (Data a) => (forall d b. (Data d) => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a
07:27:24 <ski> reports
07:27:34 <dark> no, it has an forall g. .. embedded
07:27:40 <dark> like existential or something
07:27:47 <ski> yeah, both of them has that
07:28:01 <ski> (not existential. *universal* .. it's a `forall')
07:28:52 <dark> i find this confusing, since those counts as existential typing for most haskell tutorials on existential typing
07:29:16 <ski> `forall' *always* means a universal
07:29:26 <ski> consider
07:29:44 <dark> the clever way how haskell avoided an 'exists' keyword even supporting existential types is often cited as something good (at expense of laypeople)
07:30:10 <ski>   data Stack a = forall s. MkStack (s,a -> s -> s,s -> Maybe (a,s))
07:30:27 <ski> consider first
07:30:46 <ski>   data List a = Nil
07:30:46 <ski>               | Cons a (List a)
07:30:59 <ski> the syntax for the constructors here mean
07:31:07 <dark> hm
07:31:45 <ski>   Nil                         :: List a
07:32:12 <ski>   Cons (_ :: a) (_ :: List a) :: List a
07:32:23 <ski> or
07:32:37 <dark> yes
07:32:53 <ski>   x :: a , xs :: List a  |-  Cons x xs :: List a
07:33:12 <ski> i.e. if `x' has type `a', and `xs' has type `List a', then `Cons x xs' has type `List a'
07:33:30 <ski> and we usually say this like
07:33:38 <ski>   Cons :: a -> List a -> List a
07:33:53 <ski> so
07:33:59 <ski>   data Stack a = forall s. MkStack (s,a -> s -> s,s -> Maybe (a,s))
07:34:01 <ski> we get
07:34:25 <ski> forall s.  MkStack (_ :: (s,a -> s -> s,s -> Maybe (a,s)))  :: Stack a
07:35:02 <ski> i.e. for all types `s', if the argument has type `(s,a -> s -> s,s -> Maybe (a,s))', then `MkStack' applied to that argument has type `Stack a'
07:35:05 <ski> i.e.
07:35:16 <ski>   forall s.   MkStack :: (s,a -> s -> s,s -> Maybe (a,s)) -> Stack a
07:35:31 <ski> (for every `s', `MkStack' has this type .. so it's polymorphic)
07:35:32 <ski> so
07:35:40 <ski>   MkStack :: forall s. (s,a -> s -> s,s -> Maybe (a,s)) -> Stack a
07:35:47 <ski> agree ?
07:36:52 <ski> all this is saying that that the data *constructor* `MkStack' is polymorphic in `s'
07:37:01 <ski> of course it is also polymorphic in `a', so
07:37:08 <ski>   MkStack :: forall a s. (s,a -> s -> s,s -> Maybe (a,s)) -> Stack a
07:37:29 * hackagebot DocTest 0.1.1 - Test interactive Haskell examples  http://hackage.haskell.org/package/DocTest-0.1.1 (SimonHengel)
07:38:05 * quuuux wonders if #haskell chatter correlates at all with reddit up/downtime
07:38:27 <ski> so, for any type `a' and any type `s', we can bundle up three things
07:38:32 <ski>   a stack state of type `s'
07:38:42 <ski>   a function to push an element of type `a' onto a stack state of type `s' getting a new stack state of type `s'
07:39:27 <ski>   a function for popping off the top item of type `a' from a stack state of type `s', also getting the rest of the stack state `s'. using `Maybe' to handle the empty stack
07:39:58 <ski> so, for any types `a' and `s', `MkStack' bundles up these things into a `Stack a' .. which does *not* depend on the type `s'
07:41:17 * ski idly wonders what reddit up/downtime might be ..
08:12:38 * hackagebot hslogger 1.1.3 - Versatile logging framework  http://hackage.haskell.org/package/hslogger-1.1.3 (JohnGoerzen)
08:15:05 <edwardk> non-binding straw poll: Data.Functor.Extend or Control.Semicomonad ? =)
08:15:27 <edwardk> (Cosemimonad?)
08:16:26 <edwardk> the Semicomonad name is less well motivated than being able to build Control.Semimonad out of just (>>=) and join
08:17:58 <edwardk> basically class Functor w => Foo w where extend :: (w a -> b) -> w a -> w b; duplicate :: w a -> w (w a)
08:18:27 <edwardk> class Functor m => Bar m where bind :: (a -> m b) -> m a -> m b; join :: m (m a) -> m a
08:19:36 <jmcarthur> where does the name extend come from? why extend and not something like cobind?
08:20:02 <edwardk> jmcarthur: because it gives intuition for the operation. that it extends the w from the left hand side of the -> to the right. 
08:20:16 <copumpkin> jmcarthur: the order is also backwards from bind
08:20:22 <edwardk> jmcarthur: i hate cofoo names, they actively get in the way of people actually building intuition for how they are used
08:20:22 <jmcarthur> the same could sort of be said about bind
08:20:30 <jmcarthur> well, i guess there's that
08:20:47 <jmcarthur> i sort of like being able to guess a type signature from a name, though it's not very important
08:21:08 <copumpkin> guess based on years of category theory indoctrination?
08:21:14 <jmcarthur> copumpkin: :P
08:21:39 <edwardk> yeah, i'd rather have something more intuitive for folks than 'go spend 5 years in academia and them come back to read this type' =)
08:22:19 <jmcarthur> i doubt most haskell programmers truly understand "functor," but they get by with Functor just fine
08:22:52 <jmcarthur> i doubt myself on that too
08:23:05 <jmcarthur> on truly understanding functor, that is :)
08:24:04 <Veinor> i don't really understand what a functor 'is' but i can recognize when something is a functor :)
08:24:48 <jmcarthur> yeah, vague, informal ideas like that ^^
08:26:02 <edwardk> hrmm, anyways. i'm still looking for a nice naming convention for the 'tops' of structures like this.
08:26:30 <edwardk> functor-apply just takes the practical approach right now of naming them after the 'semigroup'-like operation involved.
08:26:49 * jmcarthur mumbles something about "Ontology is Overrated"
08:27:08 <edwardk> Apply gives you <.> :: f (a -> b) -> f a -> f b, Alt gives you <|> :: f a -> f a -> f a, Extend gives you extend, Bind gives you bind, etc.
08:27:29 * jmcarthur peeks at functor-apply
08:27:39 <edwardk> maybe, but a good ontology serves as a nice gentle introduction to a space, and ignoring ontological issues don't make them go away
08:27:53 <edwardk> Extend and Bind aren't in yet
08:28:20 <jmcarthur> so where is functor-abstract? ;)
08:28:41 <edwardk> jmcarthur: as in parametric in the choice of Category?
08:28:57 <edwardk> i haven't moved the 'extras' out of category-extras yet
08:29:06 <jmcarthur> as in (f a -> f b) -> f (a -> b)  -- hoas lambda abstraction
08:29:14 <edwardk> it'll be in functor-extras when its done
08:29:20 <edwardk> ah
08:29:27 <edwardk> cute
08:29:28 <jmcarthur> ties in with functor-apply
08:29:38 <edwardk> actually thats pretty good
08:30:15 <edwardk> problem is i can't come up with a nice infix symbol for it that feels natural =)
08:30:50 <edwardk> < #> or some crap
08:30:50 <jmcarthur> it's a unary function
08:31:08 <jmcarthur> i normally use unicode lambda :)
08:31:23 <edwardk> true
08:31:39 <edwardk> abs or lambda
08:31:43 <jmcarthur> i don't know if there is a category theoretic formulation of it
08:31:47 <edwardk> it does
08:31:48 <jmcarthur> yeah, lam is my other common name for it
08:32:59 <edwardk> i'll add it in
08:33:08 <edwardk> but you'll need to give me instances ;)
08:33:12 <jmcarthur> sweet! now i'll have a go-to package for HOAS
08:33:14 <jmcarthur> ha
08:33:15 <edwardk> for prelude types =P
08:33:18 <edwardk> =)
08:33:23 <jmcarthur> i don't know of any off hand, but i'll think about it
08:33:44 * jmcarthur pulls up the Functor instances list
08:34:35 <edwardk> note: is your Functor.Abstract really a functor though?
08:34:43 <jmcarthur> often it is, not always
08:34:48 <edwardk> because the 'a' occurs in negative position, so i doubt it'll be a functor over hask
08:35:13 <edwardk> my hoas reps usually don't get to be functors
08:35:32 <jmcarthur> edwardk: sometimes i define a DSL to have a way to lift haskell types into it though, which means i have an applicative
08:35:42 <edwardk> *nods*
08:35:44 <jmcarthur> since i already have application, and i can lift functions as well
08:36:37 <jmcarthur> it probably doesn't always make sense to force it to be a functor though
08:36:51 <jmcarthur> e.g. a GPU DSL can't just lift arbitrary functions
08:37:44 <jmcarthur> well, not a deep embedding anyway
08:38:20 <edwardk> i'm somewhat dubious of it, because all instances will be in user code
08:38:48 <edwardk> one nice thing about 'Extend' and 'Apply' is that i have a ton of prelude instances to motivate them
08:38:52 <jmcarthur> yeah
08:39:05 <jmcarthur> i was honestly half joking when i asked about it
08:39:17 <edwardk> and i have to be careful since i'm skirting the edges of obscurity anyways ;)
08:39:19 <edwardk> k
08:39:21 <jmcarthur> i think type-compose has a type class for it, and it also doesn't have any instances in the package
08:39:38 <jmcarthur> *typecompose
08:39:45 <edwardk> going to punt on it, because it doesn't apply for my own packages, since all my HOAS instances fail to provide liftings for haskell types
08:40:04 <jmcarthur> oh, no, it does have several instances, but they aren't prelude types or anything
08:40:53 <jmcarthur> oh, it's also not the same thing, so nevermind
08:41:08 <edwardk> =)
08:41:42 <jmcarthur> interesting... http://hackage.haskell.org/packages/archive/TypeCompose/0.8.0/doc/html/Data-Lambda.html
08:42:47 <edwardk> such a needlessly complicated signature
08:42:53 * jmcarthur shrugs
08:43:02 <jmcarthur> conal has a very exploratory style of programing sometimes
08:43:10 <edwardk> *nods*
08:43:21 <edwardk> it gets good results
08:43:27 <edwardk> plus i can hardly be the one to complain
08:43:32 <jmcarthur> heh
08:43:54 <edwardk> reminds me i need to go strip the dual adjunction class from adjunctions and write a blog post on why they can't exist
08:44:09 <edwardk> (between contravariant functors on hask)
08:46:22 <edwardk> jmcarthur: back to the original question, Semimonad/Semiapplicative/Semicomonad/Semialternative or Bind/Apply/Extend/Alt ?
08:46:31 <bos> dcoutts: ping
08:46:34 <bos> preflex: seen dcoutts 
08:46:35 <preflex>  dcoutts was last seen on #ghc 9 minutes and 23 seconds ago, saying: that's what SPJ suggested after I implemented it for the out-of-line cmm case
08:47:00 <dcoutts> bos: pong
08:47:45 <bos> dcoutts: if i want multiple libraries in a single source tree, do i still need separate cabal files?
08:47:53 <jmcarthur> djinn says there is an instance for this abstraction function for Maybe, but i'm not sure if it's all that awesome
08:48:12 <jmcarthur> edwardk: i think the latter looks more obvious to non-category-theorists
08:48:35 <quicksilver> I think the latter looks more *approachable*
08:48:38 <dcoutts> bos: yes
08:48:41 <quicksilver> I don't actually think it's remotely obvious ;)
08:48:46 * jmcarthur likes quicksilver's wording better
08:49:06 <dcoutts> bos: note that if you want to depend on them, or distribute them then they need to be separate anyway
08:49:09 <quicksilver> "Semimonad/Semiapplicative/Semicomonad/Semialternative" immediately says "this doesn't concern you" to a certain kind of mindset.
08:49:19 <quicksilver> that's either a bug or a feature
08:49:23 <quicksilver> depends who you wanted to appeal to ;)
08:49:25 <bos> dcoutts: ok, thanks
08:49:48 <dcoutts> bos: we're only planning to add private/convenience libs (e.g. usable by exes or the primary lib in a package)
08:49:49 * hackagebot hmatrix-mmap 0.0.2 - Memory map Vector from disk into memory efficiently  http://hackage.haskell.org/package/hmatrix-mmap-0.0.2 (AlanFalloon)
08:50:13 <bos> dcoutts: cool
08:51:16 <dcoutts> bos: point is, the cabal package remains the unit of dependency & distribution.
08:51:41 <jmcarthur> i believe the fact that there is some implemention of lam for Maybe means there are probably also implementations for other types, like [], but since it requires feeding the function argument empty, i'm not sure it looks very useful
08:53:30 <bos> dcoutts: sure
08:54:43 <edwardk> quicksilver: good point
08:55:06 <tg_> jmcarthur: g'day. less trollery around today I hope
08:55:38 <jmcarthur> tg_: :)
08:55:46 <pumpkin> instance Ord k => Semimonad (Map k) where
08:55:56 <edwardk> that one is very pleasing
08:56:12 <tg_> just finished a IT contracting job, got a $200 bonus!
08:56:13 <edwardk> as is the Apply instance
08:56:26 <jmcarthur> nobody ever did implement conal's TMap semantics, did they?
08:56:33 <edwardk> jmcarthur: i have
08:56:38 <hewei> Hi there! Got a question about Alex. Can I use alex with "monad" wrapper to do things like retrieving the source string that matches a particular phrase while parsing in Parsec please? Or should I use something else? 
08:56:45 <jmcarthur> edwardk: is it on hackage?
08:56:57 <edwardk> jmcarthur: my property maps in the graphs library are effectively a 'functionalized' version of the idea
08:57:02 <jmcarthur> ah
08:57:16 <edwardk> jmcarthur: graphs
08:57:24 <edwardk> look at Data.Graph.PropertyMap
08:57:38 <edwardk> its just the create/update/get operations
08:58:12 <jmcarthur> monadic... hmm...
08:58:46 <edwardk> jmcarthur: this is my old comonadic graphs flipped around so that folks can understand them
08:58:50 <jmcarthur> well, i see the semantics in there :)
09:00:50 <edwardk> ah crap Control.Monad added void
09:01:00 <edwardk> i need to rename the one in Data.Void
09:01:03 <jmcarthur> yeah, fails in ghc 7
09:01:20 <jmcarthur> had to look at the github page
09:01:29 <edwardk> 'absurd' or something
09:01:40 <jmcarthur> stinks that you don't even get docs if it fails to build
09:01:42 <edwardk> that is less likely to get taken
09:01:58 <edwardk> better than the old alternative of getting docs but no instances for anything TH based
09:02:11 <jmcarthur> ew
09:02:11 <edwardk> and having haddock lag behind in language features
09:02:18 <jmcarthur> true
09:02:50 <jmcarthur> it *still* doesn't have a way to show exposed implementations of type/data families though :(
09:03:02 <jmcarthur> *instances of them, i mean
09:04:10 <edwardk> yeah
09:04:31 <drhodes> :i (<*)
09:06:06 <edwardk> that is the most picasso-like side-profile for smily-face i've ever seen
09:06:13 <jdavis> What is it that allows me to pattern match on Maybe but not IO? I am not trying to pattern match on IO, but I'd like to know what makes it opaque.
09:06:15 <edwardk> (and it has a huge nose)
09:06:34 <edwardk> jdavis: what would the constructors be?
09:06:39 <kuffaar> Side profile: |
09:06:54 <jdavis> edwardk: IO, I suppose.
09:07:18 <edwardk> jdavis: but then you'd be getting out a pure value, leaking IO actions into a, defeating the purpose of them being IO actions
09:07:22 <jdavis> edwardk: I guess my question is: how do I hide the constructor but not hide the type? Is that right?
09:07:25 <edwardk> in practice, IO actions look like functions
09:07:56 <edwardk> they take State# RealWorld -> (# a, State# RealWorld #)
09:08:23 <jmcarthur> jdavis: you define an export list from the module you're writing, like so:    module Foo (Bar ())  -- exports the Bar type, but hides its implementation
09:08:35 <romanandreg> lpsmith: thanks for the feedback yesterday
09:08:35 <lambdabot> romanandreg: You have 1 new message. '/msg lambdabot @messages' to read it.
09:08:41 <edwardk> when you say module Foo (Bar(..)) where to export the type Bar, you can avoid exporting its constructors by just exporting (Bar)
09:09:05 <lpsmith> romanandreg, you are welcome
09:09:27 <jmcarthur> if luqui were in here he'd probably say something about encapsulation vs. abstraction at this point :)
09:09:30 <romanandreg> lpsmith: and sorry If I didn't say thanks last night,  I was tired/frustrated/wanted to go to bed
09:10:16 <lpsmith> that's ok,  I wasn't the slightest bit offended.    But thanks for the thanks,  I appreciate it!  =)
09:11:58 <jdavis> edwardk, jmcarthur: ok, so the IO type is exported, but the IO constructor is not, because it has something somewhere like "module IO ( IO )" or "module IO ( IO () )" ?
09:12:50 <edwardk> jdavis: correct
09:12:55 * hackagebot void 0.4 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.4 (EdwardKmett)
09:13:12 <edwardk> http://www.cis.upenn.edu/~bcpierce/courses/advprog/resources/base/GHC.IOBase.html provides the actual full export
09:13:18 <edwardk> but you can abuse it to do unsafe things
09:14:06 <edwardk> so you can see there that IO actions are effectively functions
09:15:05 <edwardk> this makes sense because evaluating the same io action multiple times yields multiple potentially different values
09:15:22 <edwardk> 'depending on the state of the realworld'
09:16:08 <newsham> what happened to Anygma? (company doing graphics rendering, haskell related, i think conal was involved)
09:16:17 <newsham> is it defunct?  web page seems to be gone
09:17:06 <jdavis> edwardk: thanks. I understand the dangers of mixing IO and pure code. As a beginner though, I think that IO gets confusing not just because it's mixing IO and monads, but also because IO is the only opaque type a beginner encounters, so it looks special somehow.
09:17:20 <quicksilver> newsham: I'm fairly sure conal mentioned that his contract there was fixed term, and it ran its course.
09:17:30 <quicksilver> newsham: I don't have any news of what happened after he moved on.
09:18:01 <conal> right. i worked with them summer 2008. and i haven't heard anything lately, either.
09:18:18 <edwardk> jdavis: that makes sense
09:18:37 <jmcarthur> yeah it's a shame to see them disappear :(
09:18:47 <conal> yeah :(
09:18:58 * hackagebot graphs 0.3.1 - A simple monadic graph library  http://hackage.haskell.org/package/graphs-0.3.1 (EdwardKmett)
09:19:47 <jdavis> edwardk: ... and then the beginner tends to think that being a monad is what makes it special, which causes more confusion.
09:21:21 <conal> jdavis: and IO more than looks special. it's deeply different from almost all the rest of haskell. lacks denotation.
09:21:58 * hackagebot comonad 0.9.0 - Haskell 98 comonads  http://hackage.haskell.org/package/comonad-0.9.0 (EdwardKmett)
09:22:24 <quicksilver> jdavis: that is a good observation.
09:22:32 <jdavis> conal: can you please elaborate? 
09:23:33 <edwardk> jdavis: the State# RealWorld abstraction leaks
09:23:48 <edwardk> the idea that you're passing around the real world fails to hold when you consider multiple threads
09:23:58 <edwardk> plus you aren't the only one interacting with the world
09:24:00 * hackagebot comonad 0.9.0.1 - Haskell 98 comonads  http://hackage.haskell.org/package/comonad-0.9.0.1 (EdwardKmett)
09:24:25 <conal> jdavis: aside from IO (& STM), the types in Haskell have meanings. and the operations on those types have meanings in terms of the meanings of the types.
09:24:26 <jdavis> edwardk: oh, that makes sense.
09:24:42 <newsham> also RealWorld is kind of large a clunky.  sometimes you have two things that affect different non-conflicting parts of the real world, and it would be nice to know for example that you can freely reorder the two without causing problems
09:24:56 <newsham> but IO just thinks they must be strictly serialized
09:25:14 <conal> jdavis: i discuss in several of the posts on my blog. (http://conal.net/blog ). for instance http://conal.net/blog/posts/notions-of-purity-in-haskell/
09:25:46 <conal> jdavis: also http://conal.net/blog/posts/can-functional-programming-be-liberated-from-the-von-neumann-paradigm/ and http://conal.net/blog/posts/the-c-language-is-purely-functional/
09:26:35 <jdavis> conal: That reminds me of the relational model somewhat. I'll take a look.
09:27:52 <conal> jdavis: john backus's turing award lecture describes the fundamental deep flaws in imperative programming and recommends pure functional programming as an antidote. haskell avoids those deep flaw except for IO, where it incorporates the flaws wholly. because IO has imperative semantics.
09:28:06 <conal> jdavis: http://www.thocp.net/biographies/papers/backus_turingaward_lecture.pdf
09:28:40 <newsham> although http://www.cs.nott.ac.uk/~txa/publ/beast.pdf
09:29:31 <quicksilver> conal: but the benefit of using the type system to segregate the IO are quite considerable.
09:29:34 <conal> newsham: great to see that work - carving out some tiny slices of IO and giving them semantics.
09:29:53 <newsham> *nod*
09:30:04 <conal> quicksilver: definitely!
09:30:30 <quicksilver> conal: and it's quite possible to imagine giving denotations to various interesting fragments of IO, too.
09:30:44 <conal> quicksilver: as in newsham's pointer, iirc
09:30:45 <newsham> imagineering!
09:31:18 <conal> quicksilver: until we really know how to program systems functionally, i'm glad we can still have functional pieces whose semantics are protected from the imperative bits.
09:31:19 <edwardk> nicely they can weaken their claim that they can only compose free monads, because free monads are ideal, and ideal monads also have well define coproducts
09:31:28 <edwardk> er well defined
09:33:53 <conal> in a way, current haskell is a lot like fortran (also from john backus), in that it's functional + imperative. a *better* fortran in many ways, but i'm still holding the vision of pure functional/imperative programming.
09:34:51 <conal> oh shit.
09:34:52 <conal> i
09:34:52 <conal>  me
09:34:52 <conal> ans
09:34:53 <conal> t
09:35:01 <conal> i meant pure functional/denotative programming.
09:35:09 <edwardk> =)
09:35:29 <conal> (that's what i get for thinking about two things at once)
09:36:10 <edwardk> i totally want to @quote that first line ;)
09:37:10 * hackagebot delimited-text 0.2.1 - Parse character delimited textual data  http://hackage.haskell.org/package/delimited-text-0.2.1 (StefanKersten)
09:37:55 <conal> edwardk: please don't. :)
09:37:56 <djahandarie> Is there a name for that equivalence between foralls and exists?
09:38:02 <zygoloid> duality
09:38:03 <conal> in a way, current haskell is a lot like fortran (also from john backus), in that it's functional + imperative. a *better* fortran in many ways, but i'm still holding the vision of pure functional/denotative programming.
09:38:14 <conal> there.
09:38:14 <Jafet> Dataflow languages can be pure and denotational
09:38:17 <djahandarie> Ah, thanks
09:38:17 <edwardk> conal: 's why i merely commented rather than wrote it as @remember =)
09:38:19 <Jafet> djahandarie: syntactic horror
09:38:40 <conal> edwardk: thx. i thought i recognized a tease. :)
09:39:43 <conal> gotta go. later, all.
09:40:09 <beastaugh> djahandarie: logic is full of duality
09:40:43 <beastaugh> djahandarie: possibility and necessity in modal logic, for example, or conjunction and disjunction
09:43:36 <edwardk> instance Ord k => Bind (Map k) where m >>- f = mapMaybeWithKey (\k -> lookup k . f) m
09:44:47 <djahandarie> I was thinking of particularly   (exists n. n) => P(n)  =  (forall n. n => P(n))
09:45:44 <djahandarie> Not sure if this is an example of duality or not
09:46:06 <djahandarie> Wikipedia writes it using negation and I see no negation there
09:48:17 <copumpkin> djahandarie: ?
09:48:26 <copumpkin> djahandarie: forall and exists are adjoint
09:48:30 <copumpkin> curry/uncurry
09:50:10 <djahandarie> Adjoint... functors? *has not heard the term adjoint used outside of that*
09:50:25 <Jafet> coexists a. a
09:50:45 <copumpkin> djahandarie: exists and forall are basically (,) and (->)
09:51:01 <copumpkin> or (,) k and (->) k
09:51:27 <copumpkin> I think there's a forall/exists adjointness explanation in awodey near the end somewhere
09:51:39 <copumpkin> but I can't find the online link to awodey now
09:52:08 <djahandarie> I think I have it at home
09:53:02 <djahandarie> But wait why do we need category theory to explain this? Isn't this just a rule of some sort? I've read it somewhere before
09:53:16 <copumpkin> we don't, but it's nice
09:53:21 <copumpkin> and boils down to uncurry and curry
09:53:52 <djahandarie> So can you rewrite that logic statement in terms of uncurry and curry? Or something?
09:55:10 <beastaugh> copumpkin: in his category theory book?
09:56:02 * beastaugh goes to his bookshelves
09:56:39 <beastaugh> yeah, p.223 onwards (2nd ed.)
09:56:42 <ski> djahandarie : `Not (exists a. f a)' is equivalent to `forall a. Not (f a)' ..
09:56:58 <djahandarie> ski, right, that's what I saw in Wikipedia
09:57:20 <beastaugh> I think he has most of that stuff on his site too, as lecture notes
09:57:48 <ski> copumpkin : rather, `exists' is the left adjoint to a projection, and `forall' is the right adjoint to a projection .. `exists' and `forall' are not adjoint to each other
09:57:57 <copumpkin> djahandarie: yeah, but that's a relation including not
09:58:21 <j-invariant> ski: forall is a functor?
09:58:23 <beastaugh> http://www.andrew.cmu.edu/course/80-413-713/notes/chap09.pdf
09:58:32 <djahandarie> copumpkin, which I don't want
09:58:33 <beastaugh> just search for "Quantifiers as adjoints"
09:58:50 <djahandarie> Ah nice beastaugh 
10:00:36 <djahandarie> Man I wish they would teach this in my class instead of this pseudo-math crap
10:01:27 <beastaugh> well, you could always teach it to yourself
10:01:36 <beastaugh> that's what I'm attempting to do
10:03:04 <copumpkin> same here :)
10:03:30 <j-invariant> djahandarie: what pseudo-math crap
10:03:37 <copumpkin> j-invariant: for a fixed domain it should be?
10:04:37 <geheimdienst> yes yes, the pseudo-math crap doesn't help you one bit writing shorter or simpler code, whereas the quantifiers as adjuncts ... uh ...
10:04:46 <geheimdienst> (scnr)
10:05:06 <Eduard_Munteanu> Awodey's book tends to get hard to follow at times.
10:05:08 <djahandarie> j-invariant, taking an intro to discrete math course and I'm finding it completely lacks any rigour
10:05:45 <j-invariant> if you're lucking, filing the gaps is good revision
10:05:49 <j-invariant> lucky
10:07:38 * Eduard_Munteanu reached the "Categories of groups" part and he finds it quite impenetrable.
10:09:18 <beastaugh> yes, I can't say it's easy going :)
10:10:31 <djahandarie> Heh, actually "the important notion of an adjoint functor occurs in logic as the existential operator" is one of his opening paragraphs
10:11:39 <bos> is there a name for a monoid without a unit?
10:11:43 <copumpkin> semigroup
10:11:46 <j-invariant> semigroup
10:11:55 <copumpkin> edwardk just added one to hackage recently
10:12:02 <bos> Ah
10:12:06 <bos> Thanks
10:12:08 <copumpkin> there's quite a few useful instances
10:12:18 <bos> @hackage semigroup
10:12:18 <lambdabot> http://hackage.haskell.org/package/semigroup
10:12:26 <j-invariant> djahandarie: cause rarely is someone going to say "Theorem 1 = 2. Proof yack yak .. 
10:12:26 <bos> huh
10:12:53 <copumpkin> http://hackage.haskell.org/package/semigroups
10:12:58 <bos> :-)
10:13:23 <copumpkin> bos: he usually uses it along with his Foldable1 and Traversable1 classes
10:14:34 <bos> hmm, now i need to figure out whether i want a monoid or a semigroup in my API
10:14:47 <copumpkin> I think he's going to propose
10:14:59 <copumpkin> semigroup for base and as a superclass of monoid, sometime soon
10:15:20 <copumpkin> it gives rise to lots of nice stuff further up in the hierarchy
10:15:48 <bos> Yeah
10:16:12 <djahandarie> Seems like proposing superclasses is dangerous business these days though
10:16:41 <copumpkin> he's back
10:16:44 <copumpkin> now he can tell you himself
10:16:52 <bos> that would be very nice to have
10:17:17 <edwardk> djahandarie: i've mostly just decided to start using it everywhere.
10:17:31 <edwardk> since herding the cats is a damnably disappointing exercise
10:17:47 <djahandarie> lol
10:18:10 <edwardk> bos: which api?
10:18:51 <bos> edwardk: my riak client
10:19:21 <bos> edwardk: i'm currently using Monoid to help automatically resolve vector clock conflicts, but Semigroup would be tidier and more correct
10:19:26 <edwardk> bos: did you see what is started with 'reactor' yet?
10:19:31 <bos> nope
10:19:35 <bos> no idea what that is
10:19:55 <edwardk> https://github.com/ekmett/reactor/blob/master/Reactor/Observable.hs
10:20:11 <bos> ah
10:20:20 <edwardk> its the /net reactive programming machinery + intel tbb-style task parallel machinery in haskell
10:20:30 <edwardk> i need to upload a more current version since all the scheduler work isn't on github yet
10:20:46 <edwardk> basically workstealable splittable tasks
10:20:56 <edwardk> hidden behind a pure-looking observable monad
10:22:03 <bos> neat
10:22:44 <edwardk> basically most of my parallel code is designed around workstealing in the outside world, and it kind of annoyed me that i can only do that through a best-effort queue with sparks in haskell
10:22:53 <edwardk> so i sat down to build something more robust
10:23:59 <edwardk> Tasks are basically CPS'd IO with a scheduler providing a means to enqueue tasks to be performed. if nothing else it can tack them on the end of the success continuation, but a more intelligent scheduler uses the workstealing deque
10:27:56 <revenantphx> Python's "Construct"...
10:28:01 <revenantphx> is actually really nice >_>
10:28:23 <revenantphx> It has some stuff Data.Binary lacks like meta-thingies
10:28:26 <revenantphx> kinda neat.
10:29:27 <edwardk> who was it that had the little EDSL for graphically laying out packet formats, etc. in a template haskell quasiquoter?
10:30:30 <jmcarthur> edwardk: you talking about Potential?
10:31:44 <jmcarthur> edwardk: it includes a some TH magic for expressing low level structures as diagrams, and there's a blog post demonstrating an interrupt descriptor, IIRC
10:31:53 <jmcarthur> *includes some
10:32:08 <revenantphx> :O
10:32:11 <revenantphx> links please?
10:32:17 <revenantphx> also.. "E" DSL?
10:32:28 <revenantphx> "Extremely" DSL?
10:32:46 <jmcarthur> edwardk: http://potential-lang.org/2010/07/02/quasi-quoting-ascii-art-to-define-data-structures/
10:32:48 <jmcarthur> revenantphx: ^^
10:32:52 <jmcarthur> revenantphx: E = embedded
10:32:58 <revenantphx> Oh I remember this :D
10:33:03 <revenantphx> ASCII ART ^_^
10:33:20 <jmcarthur> yeah, i kind of like it
10:34:09 <revenantphx> how can you actually use what it produces though...?
10:34:15 <bos> @hoogle sha
10:34:15 <lambdabot> Text.Html shape :: String -> HtmlAttr
10:34:15 <lambdabot> Text.XHtml.Frameset shape :: String -> HtmlAttr
10:34:15 <lambdabot> Text.XHtml.Strict shape :: String -> HtmlAttr
10:34:26 <gwern> jmcarthur: is that the Smalltalk stuff for turning internet protocol RFC ASCII art into protocol code?
10:35:11 <jmcarthur> revenantphx: http://intoverflow.wordpress.com/2010/05/21/announcing-potential-x86-64-assembler-as-a-haskell-edsl/
10:35:17 <jmcarthur> gwern: it's haskell
10:35:36 <jmcarthur> gwern: via quasiquotation
10:35:37 <gwern> jmcarthur: ah, but I see it does link to the smalltalk idea
10:35:41 <jmcarthur> yeah
10:35:48 <revenantphx> interesting,
10:36:01 <Eduard_Munteanu> Is that even possible? oO
10:36:14 <jmcarthur> Eduard_Munteanu: considering that it works, yes
10:36:15 <revenantphx> that's one nasty type signature.
10:36:21 <revenantphx> :: (SZ rcx
10:36:21 <revenantphx>       :<= S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S Z))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))),
10:36:22 <revenantphx> ....
10:36:32 <jmcarthur> revenantphx: yeah, it's meant to be inferred, not written :\
10:36:36 <revenantphx> :P
10:36:39 <Eduard_Munteanu> Ah, just reading it, it makes some sense.
10:36:41 <edwardk> revenantphx: yeah
10:37:34 <edwardk> my old assembler monad used to give similar signatures until i replaced a lot of stuff that was using indices with clever abuse of mfix
10:38:05 <edwardk> that let me toss around labels, etc. easily
10:38:38 <asflierl> assembler monad... now that sounds interesting... 
10:38:55 <gwern> I know enough assembler to be interested
10:40:19 <Eduard_Munteanu> House has some sort of monad for direct hw access.
10:40:25 <gwern> (those are some pretty ridiculous types though)
10:42:51 <tolkad> do the types in RULES pragma patterns match exactly, or through type unification?
10:44:13 <tolkad> in other words does {-# RULES "" forall x. id (x :: forall x. Integral a => a) = x #-} match id (1 :: Int)?
10:44:25 <tolkad> or only id (1 :: Integral a => a)
10:44:45 <test423432> Hello guys, I have a small favor to ask. Can somebody tell me how to solve the following problem? (In general) This is from a puzzlebook, but I can't solve it by hand, so I thought maybe I should try haskell. The game is as follows, you get words and you get a number. Like tellme 10, the 10 means that the t + e + l + l + m + e equals to 10. Now the question is, using these words find the value 
10:44:45 <test423432> corresponding those letters
10:45:45 <test423432> I have actually no idea using what approach I should deduce the values, except for brute force ofcourse, but that would result in a large permutation
10:45:48 <tolkad> test423432: that sounds fun
10:45:57 <test423432> it is fun
10:45:57 <edwardk> test423432: each line gives you a linear equation
10:46:05 <tolkad> test423432: yeah just solve by substitution
10:46:14 <test423432> oh...
10:46:16 <edwardk> for instance tellme 10 gives you t + 2 e + 2 l + m = 10
10:46:32 <test423432> OMG
10:46:33 <Jafet> Probably a linear diophantine equation
10:46:51 <test423432> you guys are sick :| seeing math everywhere :P
10:46:52 <edwardk> once you have enough equations to solve for your unknowns its just a linear algebra problem, you can solve it by substitution, or gaussian elimination, etc.
10:47:21 <test423432> Why haven't I realized that before :|
10:47:22 <edwardk> thats because it is everywhere ;)
10:47:24 <byorgey> coding gaussian elimination by hand is a nice exercise
10:47:28 <Eduard_Munteanu> I'm not sure it needs to be diophantine.
10:47:44 <test423432> there is a problem though guys
10:47:48 <byorgey> test423432: what haven't you realized before? that math is everywhere, or that we are sick?
10:48:01 <test423432> no that this could be done with simple lineair equations
10:48:07 <test423432> the letter K is never used
10:48:08 <byorgey> oh, hehe =)
10:48:15 <test423432> but every letter should have 1 t/m 26
10:48:24 <test423432> and none of them are equal to eachother
10:48:27 <tolkad> huh I never tried writing an algorithm to do substitution before...
10:48:29 <test423432> so does this limitation poses a problem?
10:49:10 <tolkad> test423432: that fact complicates things a bit
10:49:20 <Eduard_Munteanu> If that's so, then you can solve it with an underdetermined system.
10:49:36 <test423432> well if I can get the values for each number
10:49:48 <Eduard_Munteanu> It seems harder indeed.
10:49:49 <test423432> than value of K is the value left in the set of 1 t/m 26
10:49:50 <yitz> 1 t/m 26 ?
10:49:54 <test423432> then *
10:50:03 * zygoloid ponders if this is in P
10:50:04 <byorgey> test423432: you can still use linear algebra to generate a set of candidate solutions for each letter, then go through and pick a letter with only one candidate, cross that candidate out from all the other letters, and repeat
10:50:37 <byorgey> well, hmm, you might have to use backtracking
10:50:39 <test423432> PS: letter o is already given; o = 1
10:50:43 <zygoloid> hmm, i suspect the general problem on N letters in NP-complete
10:51:07 <test423432> yeah first thought about this as a NP problem, but then again now you guys give me these tips
10:51:12 <test423432> I doubt it is a NP problem
10:51:25 <zygoloid> test423432: the restriction that all the letters are distinct makes a difference
10:51:33 <test423432> why?
10:52:01 <Yrogirg> Hello! I was thinking about strictness, strict evaluation. Functions of what types can be evaluated strictly?
10:52:06 <Eduard_Munteanu> I think the main point is you'll be given fewer equation than you need to solve the system without those restrictions.
10:52:07 <zygoloid> because you can construct certain logic gates with that restriction. for instance, suppose you start with ab=3 cd=7 ef=11 ...
10:52:19 <edwardk> test423432: you can still perform the operation above, if you can find any solvable subproblem it'll give you some of the letters
10:52:29 <zygoloid> then you know that (a,b) is either (1,2) or (2,1) etc
10:52:33 <Eduard_Munteanu> Such that you don't find a solution that disobeys the restrictions.
10:52:45 <gigabytes> hello
10:52:46 <test423432> I got 21 equations
10:52:55 <yitz> Yrogirg: for any type strict evaluation might crash, because _|_ is a member of every type.
10:52:57 <gigabytes> which is the best way to do linear algebra with Haskell?
10:52:58 <edwardk> test423432: but you may need to use other reasoning methods to find the rest of the letters. that is to say the above technique is sound but not complete with respect to the full problem specification
10:53:04 <Eduard_Munteanu> test423432: and the rank of that matrix?
10:53:12 <edwardk> test423432: guessing 26 letters.
10:53:13 <test423432> rank?
10:53:26 <zygoloid> so treat 'a' as X and 'b' as X. you can then build XOR gates easily, at least.
10:53:37 <Eduard_Munteanu> Is the determinant zero or not?
10:53:37 <test423432> I know a bit of linear algebra, but what is the rank of a matrix?
10:53:42 <test423432> I do not know
10:54:09 <test423432> I've only been given the following list of items advocaat 	108
10:54:09 <test423432> baileys		98
10:54:09 <test423432> bier		63
10:54:14 <test423432> sherry		82
10:54:14 <test423432> tequila		100
10:54:15 <test423432> tia      	63
10:54:15 <Eduard_Munteanu> In other words, can you find a unique solution that solves the problem _without_ the addition restrictions?
10:54:17 <zygoloid> (in fact it looks like you can easily build AND and NOT too, and that's all you need to show it's NP-complete)
10:54:20 <tolkad> I'm going to see if I can write it
10:54:27 <Eduard_Munteanu> *additional
10:54:38 <test423432> this is the list of items that I have
10:54:45 <test423432> the number there shows the sum of the letters
10:54:50 <edwardk> test423432: so you're going to have at least 5 unknowns left when you get done solving the linear system. this means that you'll probably need to do the rest by searching using the exclusivity property
10:54:52 <test423432> each letter has a different number between 1 till 26
10:54:57 <Botje> test423432: anything above two lines should generally go into a pastebin
10:54:58 <copumpkin> zygoloid: lucky we have the new polynomial time 3SAT solver
10:55:06 <kuffaar> <gigabytes> which is the best way to do linear algebra with Haskell?
10:55:10 <edwardk> (assuming none of the equations are redundant)
10:55:11 <kuffaar> What exactly do you want to do?
10:55:15 <test423432> @ Botje Im sorry
10:55:31 <kuffaar> Just evaluate terms given a full set of boolean values?
10:55:34 <zygoloid> copumpkin: *phew* :) too bad it's not as fast as the best non-polytime ones on any practical problem size :)
10:55:37 <Eduard_Munteanu> hmatrix is nice for linear algebra.
10:56:06 <zygoloid> copumpkin: did you ever read the paper? i got lost about halfway through ;(
10:56:29 <gigabytes> kuffaar: I mean.. manipulate matricies, ecc... I'd like to apply some basic numeric algorithms I've learnt recently, but in a functional way
10:56:30 <j-invariant> what's so good about haskell anyway?
10:56:40 <j-invariant> why is it more than just a stepping stone to the next  language
10:56:41 <copumpkin> zygoloid: no, I'll admit that I typically write stuff like that off and don't get my hopes up. I'll wait for the cheers from the CS community and then get excited
10:56:43 <edwardk> test423432: so to solve it, plug in the matrix, use gaussian elimination or what have you, the result will be a system of linear equations with 5 unknowns. then you'll need to search the range for a solution ot the unknowns something slightly smaller than 26^5 isn't a bad search space. and can be coded up fast
10:56:45 <test423432> Okay let me get this one straight, I can "progress" to my solution using lineair algebra, I can try to solve the system but the answers don't have to hold to the restriction?
10:56:50 <gigabytes> the main problem I see is that I don't have constant access to matrices' elements
10:57:05 <test423432> 26^5 isn't big?
10:57:06 <kuffaar> gigabytes: Oh, I am so sorry, I read "boolean algebra" instead of "linera algebra"
10:57:14 <edwardk> > 26 ** 5
10:57:15 <test423432> I'm not sure, can Haskell handle that?
10:57:15 <Yrogirg> yitz: I'meant to ask weather the concept of strict evaluation is applicable for example for Double->Double type. Can I strictly sum [sin, sin , cos, exp, cos (\x -> x^2)] list? The addition is defined as usual (f + g)(x) = f(x) + g(x)
10:57:15 <lambdabot>   1.1881376e7
10:57:17 <Eduard_Munteanu> test423432: you probably don't have enough information to solve the problem in a manner which breaks the restrictions.
10:57:25 <copumpkin> j-invariant: it's whatever you want it to be. It's definitely not perfect, but of the languages out there, it's my favorite to use
10:57:30 <edwardk> its in the millions, not trillions =)
10:57:38 <Eduard_Munteanu> test423432: so you'll only narrow it down using linear algebra
10:57:45 <kuffaar> gigabytes: Well, just pick the right containers for the matrix and define a new type and such? I bet there are already many packages available for this, too
10:57:47 <gigabytes> kuffaar: ahah ok :)
10:57:49 <test423432> okay I'm going to narrow it down
10:57:51 <test423432> you guys rock!
10:57:53 <edwardk> its better than 26 factorial =)
10:57:57 <test423432> that's true
10:58:02 <test423432> that's septillion
10:58:04 <test423432> XD :P
10:58:17 <yitz> Yrogirg: yes. the result will be a function.
10:58:18 <gigabytes> kuffaar: what's the "right container" for the matrix?
10:58:23 <copumpkin> j-invariant: you seem to say you hate haskell or ask what the point of it is, approximately once a day
10:58:23 <gigabytes> an bi-dimensional array?
10:58:24 <test423432> wait problem...
10:58:28 <test423432> I got a problem
10:58:39 <test423432> so my matrix should be 26 in length????
10:58:41 <kuffaar> gigabytes: Yeah Data.Vector or something like that I suppose
10:58:44 <edwardk> 4 * 10^26 is in the octillions ;)
10:58:54 <kuffaar> > let accuracy = 1000 in (sum [1 / x^2 | x <- [1..accuracy]] * 6) ** 0.5
10:58:55 <lambdabot>   3.1406380562059946
10:59:00 <test423432> 26! is septillion according to WolframAlpha
10:59:10 <copumpkin> > product [1..26]
10:59:11 <lambdabot>   403291461126605635584000000
10:59:23 <edwardk> ah, i stand corrected
10:59:24 <test423432> yes that's a septillion!
10:59:24 <medfly> what's thta haskell iphone game in dev 's name
10:59:25 <copumpkin> > length . show . product . enumFromTo 1 $ 26
10:59:26 <lambdabot>   27
10:59:34 <gigabytes> kuffaar: but how are they implemented internally? are they written in some lower level language or are they pure functional implementations?
10:59:35 <copumpkin> > length . show . product . enumFromTo 1 $ 50
10:59:36 <lambdabot>   65
10:59:45 <edwardk> off by 1 error =)
10:59:52 <medfly> which also has a blog
11:00:03 <kuffaar> gigabytes: Hmm I think the containers are provided in a highly compiler specific package
11:00:06 <test423432> but uhm from (0 0 0 0 0 ---> end) is 26 long? :|
11:00:07 <kuffaar> base?
11:00:18 <test423432> that's a huge matrix :(
11:00:19 <kuffaar> gigabytes: That stuff is heavily optimised under the hood, I think
11:00:20 <regularlambda> > irb
11:00:20 <lambdabot>   Not in scope: `irb'
11:00:23 <Eduard_Munteanu> gigabytes: they're not really functional algorithms. For example hmatrix calls out through FFI to GSL, BLAS, LAPACK etc.
11:00:31 <edwardk> smallish matrix, huge search space =)
11:00:41 <gigabytes> Eduard_Munteanu: ok that's what I wanted to know
11:00:56 <gigabytes> but then, to implement something efficent using purely haskell, what should I do?
11:01:09 <kuffaar> gigabytes: Use the right containers
11:01:10 <Fuco> that number problem sounds like excelent problem for CLP and prolog :P
11:01:21 <test423432> I suck in Prolog
11:01:25 <test423432> I prefer Haskell XD :P
11:01:33 <Fuco> well I mean, you can do something similar in haskell
11:01:43 <yitz> > length . takeWhile (> 0) . iterate (`div` 10) . product . enumFromTo 1 $ 26
11:01:43 <gigabytes> kuffaar: yes :P
11:01:44 <lambdabot>   27
11:01:46 <copumpkin> maybe j-invariant has me in ignore
11:01:48 <Eduard_Munteanu> @hoogle hmatrix
11:01:49 <lambdabot> No results found
11:01:56 <yitz> > length . takeWhile (> 0) . iterate (`div` 2) . product . enumFromTo 1 $ 26
11:01:58 <lambdabot>   89
11:02:10 <yitz> > length . takeWhile (> 0) . iterate (`div` 2) . product . enumFromTo 1 $ 50
11:02:10 <kuffaar> gigabytes: Feel free to check out the ghc base source code for implementation details on basic structures like Map etc
11:02:12 <lambdabot>   215
11:02:19 <kuffaar> I have no idea how portable that stuff is
11:02:28 <kuffaar> I suspect it contains ghc specific optimisations?
11:02:28 <regularlambda> test423432: haskell implemented easily
11:02:30 <Eduard_Munteanu> gigabytes: do you want to implement from scratch some algorithms, or use them to solve other problems?
11:02:38 <regularlambda> but hard on RAM
11:02:56 <kuffaar> But the interface is uniform and Haskell 98/Prime/2011 conforming, of course
11:03:12 <gigabytes> Eduard_Munteanu: yes I'm trying to implement from scratch some algorithms just for educational purposes
11:03:37 <gigabytes> for that reason I'm not very happy to use something that use LAPACK under the hood :P
11:03:57 <kuffaar> Is a lot of stuff on HackageDB GHC specific btw?
11:04:10 <Eduard_Munteanu> gigabytes: you can use arrays (STArray, STUArray), but you won't get functional-style code.
11:04:10 <kuffaar> http://hackage.haskell.org/package/base-3.0.3.2
11:04:18 <ski> (test423432 : imo, Prolog is good to know)
11:04:23 <kuffaar> I see that this exports GHC modules
11:04:45 <kuffaar> I've never used any other Haskell compiler than GHC
11:04:51 <gigabytes> Eduard_Munteanu: that's the problem. I mean, is it even possible to implement, for example, matrix multiplication in an efficent way using purely functional techniques?
11:04:56 <kuffaar> Like Hugs and YHC and such
11:05:19 <Eduard_Munteanu> gigabytes: well matrix multiplication for instance is easy, but many algorithms don't have a functional form.
11:05:33 <gigabytes> ok
11:06:03 <gigabytes> but.. theoretically there should be a functional form for everything, right? maybe not an efficent one.
11:06:28 <Eduard_Munteanu> gigabytes: for instance each element of the result in the matrix multiplication is a product of two vectors.
11:06:38 <Eduard_Munteanu> That's rather easily expressible in a functional form.
11:06:55 <Eduard_Munteanu> gigabytes: maybe, maybe not.
11:07:13 <Fuco> test423432: it's quite simple http://prolog.pastebin.com/LvG9QDWh
11:07:35 <gigabytes> Eduard_Munteanu: yes, multiplication sounds easy
11:08:45 <Eduard_Munteanu> What's harder is expressing in-place algorithms in a functional manner, generally.
11:10:11 <gigabytes> Eduard_Munteanu: right
11:11:43 <ski> Clean can do it
11:12:24 <Eduard_Munteanu> Lemme guess... uniqueness typing is the panacea of all Haskell problems?
11:12:48 <j-invariant> linear types means in place algorithms?
11:12:49 <ski> not really :)
11:13:04 <ski> (and linear types /= uniqueness types)
11:14:20 <edwardk> j-invariant: they enable such, among other things
11:14:21 <copumpkin> Eduard_Munteanu: I'd say no
11:14:33 <j-invariant> is it decidable
11:14:34 <edwardk> j-invariant: but uniqueness is a better fit, as ski mentioned
11:14:46 <Eduard_Munteanu> It sounds useful to have fully inferred uniqueness types, even if they're not expressed in code... as in some sort of sharing analysis. If that makes sense :)
11:14:47 <edwardk> uniqueness/linearity?
11:15:28 <edwardk> they are fairly easily inferred conservatively. syntactic linearity is easy to infer
11:15:44 <copumpkin> the strictness analyzer is doing something along those lines
11:15:56 <edwardk> there are some ad hoc extensions to permit what is technically not syntactic linearity, which take them into somewhat queasier territory though
11:15:57 <j-invariant> so what are linear types good for?
11:16:12 <Eduard_Munteanu> So this means stuff like monadically sequenced actions could theoretically be done with in-place updates, without using explicit refs or anything?
11:16:20 <edwardk> j-invariant: they are useful for folks who didn't realize that uniqueness is a more desirable property to track ;)
11:16:31 <j-invariant> aww
11:16:36 <edwardk> take a step back
11:16:40 <c_wraith> In Clean, certain data structures, when used linearly, are implemented via mutation under the hood.
11:16:40 <j-invariant> i thought the theory of linear types was simpler
11:16:45 <Eduard_Munteanu> I presume we rely on GC to clean up leftovers, so it's not quite in place.
11:16:51 <edwardk> the ideas of substructural types are all fairly straightforward
11:17:04 <edwardk> they are removing something from the rules of logic
11:17:14 <edwardk> linear types aren't necessarily about gc
11:17:20 <edwardk> they just happen t nicely apply to that domain
11:17:28 <j-invariant> so do they have other uses
11:17:36 <edwardk> in the case of linearity we restrict two things. 'contraction' and 'weakening'
11:17:45 <Eduard_Munteanu> I think linear types subsume many different concepts, such as uniqueness typing and sized types, right?
11:17:58 <edwardk> weakening is the ability to forget a variable. contraction is the ability to reference it twice.
11:18:17 <edwardk> Eduard_Munteanu: i'm getting to the connection between linearity and uniqueness, its a bit odd
11:18:56 <edwardk> a linear type is a promise to never contract or weaken a variable in the future. its a 'forward facing' temporal modality
11:19:12 <edwardk> a uniqueness type is a promise that you have not contracted or weakened it _yet_
11:19:21 <edwardk> its the dual temporal modality of linearity
11:19:23 <j-invariant> I see
11:19:23 <Eduard_Munteanu> Oh.
11:20:06 <edwardk> you can take an unrestricted type and turn it into a linear one (by copying), but you can take a uniqueness type and turn it into an unrestricted type just by forgetting the fact that its unique
11:20:33 <edwardk> in a calculus with both the conversion from uniqueness to linear can often be a no-op (unless you muck things up with gc restrictions) =)
11:20:44 <edwardk> so tying linearity to gc is hazardous
11:20:56 <Eduard_Munteanu> Isn't taking a uniqueness type into a normal one unsafe?
11:21:26 <Eduard_Munteanu> Or is this just an erasure thing?
11:21:27 <edwardk> no. consider a uniqueness type for a list. you own the only reference to the list. now map over it, you would be well within your power to take the list skeleton and mutate it in place
11:21:36 <gigabytes> edwardk: so If I use those techniques the compiler can implement my algorithm inplace without useless copies?
11:21:39 <edwardk> (asuming that it was strict)
11:21:44 <j-invariant> I like this idea
11:21:46 <edwardk> gigabytes: exactly
11:21:50 <j-invariant> what about curry howard
11:22:04 <j-invariant> does linear/uniqueness  have any meaning in logic
11:22:25 <gigabytes> edwardk: can you link me something to read?
11:22:27 <edwardk> if you add affine and relevant types you can now talk about the fact that a thunk holds a reference to an affine computation to generate its answer
11:22:28 <j-invariant> maybe that would be more about the algorithmic efficiency than anything else?
11:22:33 <copumpkin> http://en.wikipedia.org/wiki/Linear_logic :P
11:23:12 <edwardk> gigabytes: with regards to the uniqueness/linearity connection its just my own ramblings afaik, its never appeared in print.  i was using it as part of my second dissertation
11:23:30 <edwardk> j-invariant: yes, linear logic is well studied
11:23:38 <gigabytes> edwardk: ok :) but the point is: does ghc implement those things?
11:23:41 <edwardk> think of it as the logic of actions that mutate the world
11:23:46 <edwardk> gigabytes: no
11:23:54 <j-invariant> i want to make a linear language
11:23:58 <gigabytes> ok
11:23:59 <j-invariant> but I don't' know assembly
11:23:59 <companion_cube> so we could have the local structures like maps used when folding and so on mutable within the function that folds ?
11:24:04 <j-invariant> might be too hard
11:24:10 <copumpkin> j-invariant: just compile down to something higher-level
11:24:15 <gigabytes> j-invariant: use llvm as the backend, you don't need assembly
11:24:17 <edwardk> j-invariant: go back to baker's linear lisp. it admits a nice operational interpretation and has no garbage
11:24:22 <Eduard_Munteanu> j-invariant: some interpreted Haskell EDSL then?
11:24:35 <edwardk> j-invariant: but there are lots of linear logic programming languages
11:24:52 <copumpkin> lollimon!
11:24:53 <copumpkin> :P
11:24:54 <edwardk> Eduard_Munteanu: oleg has a post describing how to encode linear typed EDSLs in haskell
11:25:10 <Eduard_Munteanu> Ah, nice, I'll have a look some time.
11:25:23 <j-invariant> hmm cool
11:26:27 <ski> <http://www.lix.polytechnique.fr/~dale/lolli/> Lolli: A Linear Logic Programming Language
11:26:40 <awesomeproblem> Hi, are there any video tutrorial that teach u the fundamentals of Haskell
11:26:43 <Eduard_Munteanu> Sized types look like some limited subset of dependent typing.
11:26:49 <ski> (that's a bit like Prolog (or rather lambdaProlog), but using Linear logic)
11:27:16 * ski isn't sure about video tutorials
11:27:20 <ski> @where lyah
11:27:20 <lambdabot> http://www.learnyouahaskell.com/
11:27:40 <awesomeproblem> "video"
11:27:41 <ski> awesomeproblem : ^ that's not a video tutorial .. but maybe you'll like it anyway
11:27:58 <awesomeproblem> anything
11:27:59 <monochrom> it has pictures
11:28:03 <Eduard_Munteanu> Heh.
11:28:03 <awesomeproblem> lol
11:28:08 <ski> pwetty pictures
11:28:13 <Eduard_Munteanu> I think I've seen a video on using Yesod.
11:28:27 <Eduard_Munteanu> IIRC.
11:28:29 <awesomeproblem> so no veideo tutorial
11:28:35 <awesomeproblem> on haskell
11:28:38 <ski> i know SPJ has some videos .. but i'm not sure any of those are at the Haskell tutorial level
11:28:55 <djahandarie> awesomeproblem, there are videos but most of them are aimed at people who already know Haskell
11:29:06 <awesomeproblem> point me to it please
11:29:07 * Eduard_Munteanu imagines a blackboard and some categorical diagrams being drawn by SPJ
11:29:22 <djahandarie> awesomeproblem, you already know Haskell?
11:29:46 <tolkad> why would you want to watch a video tutorial?
11:29:54 <tolkad> People talk agonizingly slow
11:29:56 <awesomeproblem> sort of
11:30:06 <tolkad> you can read a page in the time the finish a paragraph
11:30:10 <monochrom> just point him/her to those channel 9 videos
11:30:10 <tolkad> they finish*
11:30:12 <kuffaar> tolkad because you don't want to learn anything and you just want to have the illusion of learning while you do absolutely nothing
11:30:22 <kuffaar> That is the quintessence of that type of video
11:30:24 <awesomeproblem> ahahah
11:30:28 <awesomeproblem> nice one
11:30:59 <Eduard_Munteanu> Oh, somebody had a monads video on Youtube.
11:31:08 <Eduard_Munteanu> But from a categorical POV.
11:31:12 <monochrom> there is no reason to go judgemental and doubt why would one want a video
11:31:27 <olsner> Eduard_Munteanu: wow, a monad *video* tutorial? :)
11:31:34 <djahandarie> Monads as Videos...
11:31:36 <ski> "Simon Peyton-Jones: Towards a Programming Language Nirvana" <http://channel9.msdn.com/Blogs/Charles/Simon-Peyton-Jones-Towards-a-Programming-Language-Nirvana>
11:31:38 <Eduard_Munteanu> :)
11:31:48 <ski> awesomeproblem : that ^ is one of them ..
11:31:52 <olsner> (what is it, a video of someone eating a burrito?)
11:31:59 <monochrom> there is not even a reason to ask or argue. they want a video? that's their choice. you know of one? good. you don't know of one? shutup.
11:32:03 <kuffaar> SPJ uses Comic Sans MS in his slides
11:32:06 * kuffaar vomits
11:32:13 <Eduard_Munteanu> http://www.youtube.com/watch?v=9fohXBj2UEI
11:32:17 <djahandarie> Yes everyone tells him that and he still does it
11:32:17 <c_wraith> So does Tim Sweeney
11:32:19 <Eduard_Munteanu> I think Cale pasted it here some time ago.
11:32:20 <awesomeproblem> I know allready that one
11:32:23 <awesomeproblem> vhanell 9
11:32:26 <tolkad> monochrom: I'm just asking out of curiosity
11:32:40 <awesomeproblem> and the youtube one also
11:32:50 <tolkad> monochrom: I'm curious how they will respond if I insult them
11:32:52 <awesomeproblem> do they teach u on chanel 9 
11:32:59 <awesomeproblem> the fundamentals
11:33:01 <awesomeproblem> and so on
11:33:37 <monochrom> I only know how I will respond if you insult them. I will ban you if I see you do it again. That's how I will respond.
11:33:50 <awesomeproblem> ?
11:34:26 <hatds> awesomeproblem: http://www.haskell.org/haskellwiki/Video_presentations 
11:34:43 <awesomeproblem> I also know about that too
11:34:52 <awesomeproblem> soory anything other
11:34:56 <tolkad> monochrom: aww I was kidding, I wasn't trying to insult them
11:34:57 * Eduard_Munteanu thinks videos rather tend at the motivational problem
11:34:59 <awesomeproblem> i have dl the geramn
11:35:05 <awesomeproblem> vidoe tutorials
11:35:08 <Eduard_Munteanu> So I guess I get that point.
11:35:11 <tolkad> monochrom: I really was curious why they like video tutorials
11:35:27 <awesomeproblem> but they are at the level of already knowiong haskelll
11:35:29 <tolkad> monochrom: anyway sorry. I realize this is off-topic. back to haskell
11:36:01 <hatds> any SPJ video is pretty awesome to watch honestly
11:36:32 <kuffaar> SPJ is quite the jokester
11:36:45 <Eduard_Munteanu> Oleg should do some videos :P
11:37:01 <kuffaar> @quote SPJ cheerful
11:37:01 <lambdabot> SPJ says: "He used to be a cheerful young man, a productive member of society. Then he learned Haskell."
11:37:50 <systemfault> Then he got a well paid job at Microsoft Researching to work on what he loves the most.
11:37:58 <systemfault> -ing
11:37:59 <kuffaar> Java FBSI apps
11:38:08 <kuffaar> Right?
11:38:16 <systemfault> SPJ wins.
11:42:35 <edwardk> eduard_munteanu: there is at least one video of him floating around
11:43:27 <edwardk> http://video.google.com/videoplay?docid=-7990603720514207956# is pretty much classic oleg
11:43:29 <hellige> he can float?! of course he can...
11:44:04 <olsner> hellige: when oleg floats, he floats in the type system
11:44:06 <edwardk> hellige: he provided the proof that he could float in the type system and then god said, meh, okay.
11:44:22 <hellige> ;)
11:44:51 <test423432> Hello, I tried using matrices to solve my summation word problem
11:44:56 <test423432> but it failed
11:45:11 <edwardk> it just gets you down to 5 linearly dependent equations
11:45:18 <Jafet> oleg `asTypeOf` (undefined::Air)
11:45:19 <test423432> no it does not :(
11:45:26 <Eduard_Munteanu> edwardk: nice, thanks
11:45:35 <edwardk> then it gets you down to slightly more than that =)
11:45:50 <test423432> no it doesn't even get me down XD Maple refuses to cooperate with me :(
11:45:50 <edwardk> but it could only do that if the equations were linearly dependent
11:46:26 <edwardk> sounds more like an encoding problem
11:46:36 <test423432> does someone know how to use uhm... Mathematica?
11:46:41 <test423432> http://pastebin.com/hKZa0YC4 here is the worked out Matrix
11:46:48 <noob123> Hi, quick question -- I am trying to compile the haskell platform from source on linux. I have the haskell stand-alone system downloaded here: http://haskell.org/ghc/download_ghc_6_12_3#distros . I am unsure as to how to correctly use configure; there are two arguments, --with-ghc and --with-ghc-pkg  that I do not know how to specify. Thanks!
11:47:07 <j-invariant> test423432: whats the goal here
11:47:19 <test423432> to reduce the numbers of equations down to a few
11:47:26 <test423432> so I can use bruteforce to solve my problem
11:47:34 <edwardk> j-invariant: unique assignment of the numbers 1 to 26 to the letters, in a way that solves that system of equations
11:47:36 <j-invariant> did you try gaussian elimination
11:47:48 <test423432> Maple refuses
11:47:53 <j-invariant> in haskell
11:48:00 <test423432> and I am not going to try that on a mtrix of 27 long
11:48:11 <j-invariant> ?
11:48:11 <test423432> uhm... in Haskell it seems like an impossible task?
11:48:20 <Saizan> noob123: if ghc is on your $PATH you don't have to provide them, otherwise --with-ghc=path/to/ghc is enough
11:48:24 <j-invariant> it is easy to write gaussian elimination in haskell
11:48:33 <test423432> I can't see how :(
11:48:44 <test423432> http://pastebin.com/hKZa0YC4 you can try gaussian eliminate this matrix
11:48:56 <test423432> it's formatted in proper haskell =)
11:49:12 <monochrom> noob123: no need to specify --with-ghc or --with-ghc-pkg
11:49:14 <Jafet> @hackage hmatrix
11:49:14 <lambdabot> http://hackage.haskell.org/package/hmatrix
11:49:18 <edwardk> test423432: http://luckytoilet.wordpress.com/2010/02/21/solving-systems-of-linear-equations-in-haskell/
11:49:35 <noob123>  Saizan: thanks for the response. I have a folder /ghc-6.12.3 that has a subdir ghc, is that what I should add to my path?
11:49:55 <noob123> monochrom: I am working in a restricted environment, so I had to manually download the ghc binary
11:50:18 <test423432> @edwardk this is sick
11:50:18 <lambdabot> Unknown command, try @list
11:50:24 <test423432> XD
11:50:28 <Saizan> noob123: after you unpacked the ghc tarball, did you run ./configure and make install from it?
11:50:49 <edwardk> what do you expect from a place called 'luckytoilet' ;)
11:51:04 <test423432> problem though I thought to get 25 variables, solved you need 25 equations?
11:51:08 <test423432> I only got 21
11:51:12 <edwardk> correct
11:51:24 <j-invariant> test423432: gaussian elimination doesn't care
11:51:25 <noob123> Saizan: no -- I will go ahead and do that now. for some reason I thought it would work as a standalone binary.
11:51:32 <edwardk> hence why you get a few equations remaining
11:51:48 <noob123> Saizan: however, I downloaded it from here: http://haskell.org/ghc/download_ghc_6_12_3#distros
11:52:04 <noob123> Saizan: where it is described as 'Generic i386 Linux. This is a complete build, including interactive system, profiling libraries and documentation.'
11:52:17 <edwardk> the result will be a series of statements like a = v1 + 6*v2  4*v3 + 5*v4  123*v5, b = ....
11:52:28 <Saizan> noob123: yep, it's a binary distribution, but still needs to be installed to work properly
11:52:48 <test423432> I'll try Mathematica or something first, because my code might be unreliable
11:52:50 <Saizan> noob123: you might want to pass --prefix= to configure if you can't install it system-wide
11:52:53 <edwardk> then you need to solve v1..v5
11:53:14 <edwardk> those will be the trickier, but smaller problem to encode
11:53:22 <edwardk> and its small enough to probably just brute force
11:53:39 <j-invariant> yeah this is becoming a constaint solver system
11:54:00 <test423432> brb I'm gonna try Mathematica, thanks guys... I really admire you guys to be able to do everything in Haskell
11:54:53 <test423432> PS: this is not an assignment ;) it's from a dutch puzzlebook called Bingo!
11:55:03 <test423432> I couldn't solve it by hand so :P
11:55:53 <noob123> Saizan: now I am getting "checking for path to top of build tree... utils/ghc-pwd/ghc-pwd: error while loading shared libraries: libgmp.so.3: cannot open shared object file: No such file or directory" -- googling doesn't seem to provide anything helpful. do you have any tips?
11:56:50 <monochrom> you probably need to install libgmp3-dev from your linux distro
11:57:13 <monochrom> my http://www.vex.net/~trebla/haskell/haskell-platform.xhtml has more
11:57:35 <joe6> are there any other macros from haskell other than template-haskell
12:00:17 <noob123> monochrom: thanks. looks like I'm stuck on the 'GHC' step, haha
12:00:54 <monochrom> you shouldn't be stuck if you have libgmp3-dev like I said and like the page says
12:02:20 <noob123> monochrom: i guess i don't have libgmp3-dev
12:02:37 <Makoryu> http://hpaste.org/43309/dont_know_where_i_got_this <- Anyone recognize this file? It highlights a lot of things differently from the one on vim.org, but has a lot of bugs
12:07:43 <edwardk> test423432: in mathematican you can just use RowReduce[{{3,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,0,0,108},{1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,98},{0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,63}, 
12:07:48 <edwardk> er Mathematica
12:07:49 <hatds> hmm.. ghci won't typecheck my "let f = expression" command, but it has no problem if I do ":t expression"
12:08:07 <edwardk> test423432: that'll get you down to your unknowns
12:08:33 <edwardk> sadly wolframalpha doesn't give you a large enough input buffer =)
12:08:53 <hatds> hpaste of a simple example if anyone can imagine what the problem is:   http://hpaste.org/43310/ghci_refuses_to_typecheck
12:09:50 <hatds> it doesn't want to allow equality constraints in let bindings I think?
12:10:25 <kuffaar> It sounds like SPJ suffers from slight rhotacism
12:10:26 <Saizan> hatds: the NoMR pragma in your file doesn't apply to the prompt
12:10:38 <hatds> ah, really?
12:10:49 <Saizan> hatds: :set -XNoMonomorphismRestriction
12:10:53 <hatds> thanks
12:16:52 <kuffaar> http://www.youtube.com/watch?v=cXY4fSA7DnM#t=3m30s "So here's a little bit about the history of Haskell. It comes from the same family as Lisp and Scheme which means that assignments are discouraged and that you basically do most of the work using functions." <- is it just me or is this "Stanford University" presentation utterly wrong?
12:17:37 <mornfall> kuffaar: How is that utterly wrong?
12:17:59 <mauke> ML and Lisp are not the same family
12:18:11 <mauke> (Common) Lisp doesn't discourage assignments
12:18:19 <Makoryu> kuffaar: Well, it's only *mostly* wrong, and then probably only due to abysmal choice of words
12:18:20 <mauke> Haskell doesn't have assignment
12:18:33 <j-invariant> kuffaar: there is a weird cult of scheme programmers that hate SET!
12:18:33 <kuffaar> First off, Lisp/Scheme makes it sound like Scheme is not a Lisp, then Lisp was never meant to be purely functional and it is extremely common to use function bodies with more than just one statement (i.e. progn style) and there are setq and setf etc. Then Haskell isn't even really related to Lisp, now is it?
12:18:36 <j-invariant> kuffaar: maybe he is one
12:18:41 <kuffaar> j-invariant hehe
12:18:59 <monochrom> scheme is not a lisp
12:19:09 <kuffaar> Why not?
12:19:13 <sipa> its got brackets
12:19:22 <sipa> so it is lisp!
12:19:32 <sipa> *ducks*
12:20:00 <monochrom> scheme macro is too different from lisp macro
12:20:06 <ski> j-invariant : well, there's some Scheme programmers who think `set!' is a mistake .. but are perfectly fine with mutation
12:20:23 <mornfall> How is macros the defining characteristic of lisp? :P
12:20:39 <companion_cube> homoiconicity ? :
12:20:40 <ski> Scheme is a Lisp
12:20:51 <kuffaar> ski: Agreed
12:21:05 <Makoryu> Also, ML's "family" would be that of ISWIM, which was a redesign of Lisp's syntax
12:21:07 <kuffaar> companion_cube: Yeah that's an important point but not the sole defining characteristic of a Lisp, obviously
12:21:16 <mornfall> Anyway, Haskell and LISP aren't directly related, but I think what is meant is that they are both higher-order.
12:21:20 <Makoryu> In fact, the ISWIM author coined the term "off-side rule"
12:21:21 <mornfall> Which is a fairly distinctive feature.
12:21:25 <j-invariant> ski: that is a much more wise stance
12:21:25 <companion_cube> no, but it's an uncommon particularity which is well exploited in lisp macros
12:22:34 <test423432> guys a small problem :|
12:22:45 <monochrom> macro is a defining characteristic of lisp because there is no clear-cut definition so I may as well use mine.
12:22:50 <test423432> Mathematica said it wasn't able to solve it
12:23:27 <mornfall> monochrom: Did the original LISP even have macros?
12:23:27 <monochrom> unless you say Common Lisp is the clear-cut definition, in which case scheme is still not a lisp.
12:23:28 <ski> several Scheme systems provide procedural macro systems (which still are hygienic)
12:23:33 <joe6> "haskell needs first-class types, until then lisp-macros will rule" -- from a lisper.
12:23:43 <monochrom> I don't know. I don't think it's important.
12:23:49 <mornfall> If LISP 1(.5) is not a LISP, I don't know what is. :P
12:24:22 <pastorn> joe6: first class types? as in 'isFloat', 'isInteger' etc?
12:24:28 <ski> monochrom : i assume you mean that `syntax-rules' macros are too different from `defmacro' ones, yes ?
12:24:55 <monochrom> yes
12:25:31 <ski> ok. but the `syntax-case' and explicit renaming macro systems are much more similar to `defmacro' .. but still being hygienic
12:25:48 <companion_cube> pastorn, as in  typeOf :: a -> Type, i suppose
12:25:53 <ski> you write ordinary Scheme code, to manipulate syntax in those
12:26:17 <ski> it's just that the syntax objects are not plain lists of symbols (which is what causes failure of hygiene)
12:26:53 <edwardk> test423432: Mathematica won't solve it. it'll give you back the answer in reduced form
12:26:53 <pastorn> doesn't haskell has that with the typeclass Typeable?
12:27:09 <ski> (companion_cube : hehe, in Agda one can write `typeOf : {A : Set} -> A -> Set' :)
12:27:24 <test423432> OMG :P
12:27:27 <test423432> Mathematica did it :D :P
12:27:31 <companion_cube> maybe, but here we talk about haskell ;)
12:27:36 <edwardk> test423432: RowReduce?
12:27:37 <test423432> edwardk thanks!
12:27:52 <test423432> no I used Solve[{....},{a..z / k}]
12:28:05 <test423432> I got my problem reduced in less than 7 variables
12:28:06 <edwardk> test423432: odd
12:28:09 <test423432> or better
12:28:10 <test423432> 3
12:28:19 <test423432> if I know a b and c I can get everything
12:28:35 <test423432> edwardk: why is that odd?
12:28:55 <edwardk> so it was able to provide the full solution with solve?
12:29:02 <test423432> no, :p
12:29:08 <test423432> it was able to produce equations
12:29:15 <edwardk> ok, now i believe it =)
12:29:18 <test423432> I now only need to know a b and c
12:29:21 <test423432> and I get everything
12:29:30 <edwardk> loop! =)
12:29:31 <test423432> now the big question
12:29:42 <test423432> what time would this take?
12:29:46 <test423432> a combinatorial time right?
12:29:51 <edwardk> 26*25*24
12:29:51 <copton> do match patterns always have to be literals? Or is it possible to bind a match pattern to a value and use this value later in a case expression?
12:29:52 <test423432> 26 nCr 3?
12:30:02 <test423432> well that's pretty big though XD
12:30:07 <edwardk> not really
12:30:12 <edwardk> > 26 ** 3
12:30:13 <lambdabot>   17576.0
12:30:18 <test423432> any smart ways to loop through?
12:30:22 <edwardk> nope
12:30:27 <ski> copton : unfortunately not .. you have to use `==' in a guard
12:30:38 <edwardk> this _is_ the smart way ;)
12:30:53 <lowasser> Do any GHC wizards around here know what'd happen if you created an infinite loop with type synonym families?  Would the compiler fail, or just infinitely loop?
12:30:56 <edwardk> you can terminate earlier the moment you find the solution takes any of your letters out of range, but meh
12:31:03 <copton> ski: thx
12:31:13 <test423432> true
12:31:27 <lowasser> (Rephrase: I appear to have made GHC infinitely loop, and I'm trying to deduce the cause.)
12:31:29 <ski> (copton : would you like to paste your code ?)
12:31:35 <edwardk> lowasser: type family Foo x; type instance Foo Id = Foo Id ?
12:31:45 <test423432> okay next question, would this be possible to solve by hand as these books only feature puzzles that you could do by hand
12:31:45 <lowasser> sure, let's go with that
12:31:53 <lowasser> or even type instance Foo Id = Maybe (Foo Id)
12:31:57 <lowasser> that's nice and infinite
12:32:24 <lowasser> I'm under the impression that normally the "context reduction stack" or something would asplode rather than leaving the compiler in an infinite loop
12:32:33 <edwardk> requires UndecidableInstances, then it silently succeeds
12:32:34 <hatds> lowasser: I think by default the typechecker is conservative. Some language extensions tell ghc to next check for such loops
12:32:44 <hatds> *next=not
12:32:46 <lowasser> hmmkay
12:33:02 <lowasser> ::sigh:: I don't think I can afford to turn off UndecidableInstances
12:33:17 <lowasser> but I'm pretty well convinced that the instances don't, in fact, loop!
12:33:17 <edwardk> you can even use it
12:33:21 <copton> ski: I don't have any code yet. I am thinking how to solve a problem.
12:33:33 <ski> copton : ok
12:33:36 <edwardk> foo :: Foo Int -> Bool; foo = const True  works just fine
12:34:04 <lowasser> hrrrrrm
12:34:07 <edwardk> but trying to _use_ it will blow you up
12:34:10 <ski> (copton : incidentally, in Erlang (and in Prolog and Mercury), you can do this kind of matching against a previously bound value)
12:34:23 <edwardk> bar :: Foo Int; bar = True  for instance, will spin forever trying to unify Bool and Foo Int
12:34:44 <edwardk> the compiler just goes out to lunch and never comes back
12:34:46 <lowasser> so it will spin forever, rather than dying on an overflowing context stack
12:34:48 <lowasser> okay
12:34:54 <edwardk> yeah
12:35:15 <ski> (tail-calling itself ?)
12:35:18 <test423432> could someone show me how to do this in a haskell method like this [ ... | x <-]?
12:35:23 <lowasser> logical conclusion: somewhere in my code is an infinite type, I must hunt it down.
12:35:42 * aavogt has seen the context-reduction-stack overflow generally when undecidable instances try to calculate something too big
12:35:56 <aavogt> but not with type families
12:35:58 <test423432> I got the equations for d till z except k and every letter should be different
12:36:05 <test423432> plus they should be below 26
12:36:15 <lowasser> I don't suppose, by the way, that there's a way to make GHC tell me what it's spinning on =P
12:36:19 <test423432> a b c are the letters I need to loop through
12:36:57 <edwardk> test432432: [ x | a <- alpha, b <- alpha, b /= a, c <- alpha, c /= a, c /= b, Just x <- expand a b c ]
12:37:00 <kuffaar> test423432: You want to redxuce the rows of a matrix in Haskell?
12:37:03 <edwardk> the trick is the 'expand' =)
12:37:03 <kuffaar> *reduce
12:37:08 <test423432> what is expand?
12:37:20 <test423432> @:t expand
12:37:21 <lambdabot> Done.
12:37:26 <edwardk> thats the part you need to write that takes the three candidate variable assignments and returns what you need
12:37:38 <Eduard_Munteanu> lowasser: you can try to use Debug.Trace
12:37:43 <edwardk> expand :: Int -> Int -> Int -> Maybe Solution  for some solution type
12:37:51 <Eduard_Munteanu> :t traceShow
12:37:52 <lambdabot> Not in scope: `traceShow'
12:37:53 <lowasser> hmmkay
12:37:58 <Eduard_Munteanu> @hoogle traceShow
12:37:59 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
12:38:03 <test423432> so the expand is my equation?
12:38:17 <edwardk> Eduard_Munteanu: erm. this is type level
12:38:21 <test423432> but this really bugs me with b /= a, I need to repeat that for like 26 variables :S
12:38:28 <test423432> each!
12:38:31 <lowasser> edwardk: I think it could still maybe work?
12:38:34 <edwardk> test423432: no, i just did that for the 3 you had to guess
12:38:42 <Eduard_Munteanu> Oh, sorry.
12:38:46 <Eduard_Munteanu> GHC, not the program.
12:39:07 <lowasser> heh, it's a Template Haskell thing outputting all this code, but it's designed specifically to avoid this kind of infinite loopitude
12:39:08 <test423432> but those test should also be done on the variables
12:39:16 <test423432> right or am I wrong?
12:39:17 <edwardk> test423432: so one idea is this, you want to build a result, that'll look something like:
12:39:35 <kuffaar> test423432 what is it that you are trying to solve? You posted a matrix earlier
12:41:01 <test423432> kuffaar, I am trying to solve a puzzle, I have the following, I got equations that gets me the answer for each variable depend on a b and c (variables) they assign an int to each letter under the 26, where each letter should be different, so a can never be the same int as b
12:41:01 <edwardk> expand a b c | length (nub (sort (filter (\x -> x >= 1 && x <= 26) solution))) = 26 = Just solution | otherwise = Nothing where solution = [a,b,c, a + 28*b - 12 * c, .] 
12:41:37 <test423432> whow sick
12:41:40 <test423432> what does nub do?
12:41:43 <test423432> @:t nub
12:41:44 <lambdabot> Done.
12:41:49 <kuffaar> :t nub
12:41:50 <lambdabot> forall a. (Eq a) => [a] -> [a]
12:41:50 <edwardk> > nub [1,2,2,2,3]
12:41:51 <lambdabot>   [1,2,3]
12:42:02 <edwardk> > nub [1,2,3,4,5,4]
12:42:03 <lambdabot>   [1,2,3,4,5]
12:42:04 <test423432> wow it removes duplicates
12:42:14 <edwardk> i guess i don't need the sort in there
12:42:44 <test423432> I am trying to understand your code, but I'm a bit slow
12:42:52 <test423432> so first your funtion takes something of my solution
12:42:53 <kuffaar> test423432: So a, b, c in R and the equations are linear?
12:42:54 <edwardk> this version is less efficient than possible, but was a one-liner
12:43:49 <alpounet> edwardk, you probably meant "== 26" in your "expand" code
12:43:53 <test423432> kuffaar, uhm the problem I wanted to solve goes like this: you got like 21 words, with a+b+c+d == 10 or something, you need to assign the values such that every equation is valid
12:44:07 <edwardk> kuffaar: he has a bunch of statements like tellme 10, which means t + e + l + l + m + e = 10, each letter worth some number from 1 .. 26 and each number is used once
12:44:26 <kuffaar> Linear algebra, right?
12:44:30 <test423432> yes
12:44:33 <edwardk> kuffaar: he had 21 linear equations, which he used row reduction to use to reduce the problem size
12:44:33 <test423432> I solved the Matrix
12:44:35 <kuffaar> Just put them intro a matrix and reduce the rows?
12:44:38 <kuffaar> *into
12:44:43 <test423432> already did
12:44:46 <edwardk> then he has to solve the remainder using the remaining uniqueness constraints
12:45:16 <edwardk> alpounet: yeah
12:45:26 <test423432> edwardk: so your code works except I need to put in all the equations right?
12:45:53 <edwardk> test423432: theoretically, and modulo the fact that i wrote = 26 instead of ==26
12:46:00 <test423432> edwardk: I'm gonna slowly study your code XD
12:46:20 <edwardk> and you don't need the 'sort'
12:46:21 <test423432> is there a difference between theory in computer science and practice?
12:46:32 <edwardk> though its asymptotics are dominated by the cost of the nub.
12:46:58 <edwardk> in practice a lot of folks are happy to use NP-complete algorithms that are linear in practice
12:47:08 <edwardk> =)
12:47:17 <kuffaar> What practice??
12:47:18 <edwardk> in theory it might be a bad idea ;)
12:47:23 <test423432> XD
12:47:30 <kuffaar> What's the "practice" in computer science?
12:47:33 <kuffaar> Passing CS exams?
12:47:37 <test423432> programming
12:47:57 <engla> always solve constant-size problems. Then all your algorithms are O(1)
12:48:15 <kuffaar> There's O(1) Quicksort for AMD64
12:48:17 <kuffaar> Hooray.
12:48:46 <mauke> I just use the QSRT instruction
12:49:02 <test423432> edwardk: I'm going to try your code =)
12:50:25 <bos> preflex: seen dons
12:50:25 <preflex>  dons was last seen on #ghc 23 hours, 58 minutes and 13 seconds ago, saying: great.
12:50:34 <test423432> edwardk: except I'm rewriting it so I can understand it myself :P
12:51:07 <edwardk> go for it =)
12:52:22 <alpounet> edwardk, so you're getting undergrads to work on kata
12:52:24 <alpounet> nice :P
12:53:15 <kuffaar> test423432: I'd say that most theoretical CS stuff simply has little to no implications for software development. I'm currently finishing my MSc in CS and I must admit that I haven't gained much that benefits me professionally (other than access to higher paying jobs for seemingly irrational reasons). Nearly all of my relevant practical knowledge was gained outside of academia (mostly IRC and googling stuff)
12:53:36 <kuffaar> So err yeah that's my version of "what's the different between theory and practice"
12:53:43 <kuffaar> I will probably get flamed for 30+ min now, as usual
12:53:55 <pumpkin> depends what kind of "theoretical CS" you work with
12:53:59 <djahandarie> Depends if you consider a discussion flaming
12:54:17 <sinelaw> hi all
12:54:19 <pumpkin> if you define theoretical CS as the stuff that isn't practical, then it's trivially true
12:54:47 <djahandarie> What if you define it as "stuff you learn in graduate-level CS courses"?
12:57:02 <cts> Hi sinelaw!
12:57:16 <sinelaw> 'sup cts?
13:00:13 <jmcarthur> kuffaar: it also depends on what you mean by "software development"
13:00:43 <pumpkin> also depends on what you mean by "mean"
13:01:06 <pumpkin> or even "has"
13:01:19 <ulfdoz> that theoretical stuff has given you a type system for example. Or a language, or the one or other algorithm.
13:01:27 <jmcarthur> kuffaar: if "software development" is send data there, serialize this thing, store that thing, and render a web page, you probably won't benefit so much from understanding how 20 different sort algorithms work
13:02:25 <ulfdoz> lets make this storage transactional, which is definitely a different semantic from simply storing something
13:03:27 <ulfdoz> it provides some guarantee by theoretical foundations and specified circumstances.
13:03:31 <jmcarthur> kuffaar: but if "software development" is develop a domain specific language, verify your code correct, parallelize a complex algorithm, or write antitamper software, "theory" is a lot more practical
13:03:37 <edwardk> alpounet: yes
13:04:04 <edwardk> alpounet: what is the use of acting all professorial if you can't get students to do work for you?
13:04:36 <alpounet> indeed
13:04:50 <alpounet> it seems students are doing all the work out there
13:04:55 <alpounet> we could just take over the world
13:07:34 <aristid> alpounet: which students often do, after graduating or dropping out
13:09:14 <alpounet> when i'll do so, edwardk, i'll force you to write some graphical code to emphasize the connection between continuous fractions and moebius transformations on the upper-half hyperbolic plane
13:09:25 * hackagebot functor-apply 0.9.0 - Strong lax semimonoidal endofunctors (Applicative sans pure)  http://hackage.haskell.org/package/functor-apply-0.9.0 (EdwardKmett)
13:09:29 <edwardk> oh woe is me
13:10:12 <Apocalisp> might there be useful functors with <*> but not pure?
13:10:19 <edwardk> yes
13:10:23 <edwardk> i have a whole library!
13:10:31 <Apocalisp> see, I thought so
13:10:34 <edwardk> every comonadapply
13:10:39 <Apocalisp> join #scalaz
13:10:46 <edwardk> tarmo uustalu called them ComonadZip
13:15:21 <jmcarthur> edwardk: on the use of unsafeIsEvaluated in speculation... does par not already perform that check before sticking something in the spark queue? if not, then why not, and why is it a good idea for spec to do it but not for par to do it?
13:16:13 <jmcarthur> oh i just realized
13:16:41 <jmcarthur> it's because you're not using it to check whether the spark is evaluated. you're checking whether the function argument is evaluated
13:17:14 <Lemon> TacticalGrace, you are Mr. M. T. Chakravarty, correct?
13:17:17 <Eduard_Munteanu> Doesn't 'par' always spark, regardless it's green threads and they're cheap to kill?
13:17:37 <jmcarthur> Eduard_Munteanu: it probably does (but you're wrong that it's a green thread. it's not a thread at all)
13:17:59 <Eduard_Munteanu> Yeah, I'm not sure how it works... I mean it's cheap.
13:18:02 <jmcarthur> Eduard_Munteanu: it's just a job on a work queue, and a thread might come along later and pick up the work
13:18:11 <Eduard_Munteanu> Ah.
13:19:28 * hackagebot download 0.3.1 - High-level file download based on URLs  http://hackage.haskell.org/package/download-0.3.1 (MagnusTherning)
13:20:52 <dmead> ?src enumfrom
13:20:52 <lambdabot> Source not found. You untyped fool!
13:20:57 <dmead> blorp
13:21:04 <dmead> @hoogle enumfrom
13:21:04 <lambdabot> Prelude enumFrom :: Enum a => a -> [a]
13:21:04 <lambdabot> Prelude enumFromThen :: Enum a => a -> a -> [a]
13:21:04 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
13:21:20 <monochrom> it is called fromEnum. it is a class method.
13:21:26 <dmead> thanks
13:21:44 <dmead> the range function?
13:21:47 <Veinor> is installing ghc 7 not painful yet?
13:22:10 <kuffaar> Veinor I use ghc 7 on Windows 7
13:22:14 <kuffaar> It's quite an adventure
13:22:18 <monochrom> I don't think installing ghc 7 was ever painful. I think building libs against ghc 7 is the painful one.
13:22:27 <Veinor> yeah, that's what i meant
13:22:49 <monochrom> heh alright no news yet. supposedly better after next haskell platform.
13:22:50 <mun> hi
13:23:26 <Veinor> i assume so
13:23:35 <mun> just curious, is ALL v. x = v <--> y = v logically inconsistent?
13:24:10 <monochrom> not sure of your operator precedence.
13:25:35 <monochrom> but why don't I just assume? ALL v. ((x = v) <--> (y = v)) has a satisfying model.
13:25:37 <j-invariant> if y = v it could be
13:26:52 <mun> monochrom, your assumed precedence is correct
13:27:00 <edwardk> jmcarthur: yeah, its just the argument. with the heuristic that if a is evaluated then g == a is probably cheap
13:27:10 <edwardk> of course thats a lie if the arguments have lazy structure
13:27:26 <mun> j-invariant, why is y = v makes it inconsistent?
13:28:09 <j-invariant> what
13:28:32 <j-invariant> is v a boolean?>
13:28:40 <mun> j-invariant, no, make it an integer
13:28:58 <j-invariant> that's fine too
13:29:14 <mun> j-invariant, so you're suggesting that it's consistent?
13:29:22 <j-invariant> no the opposite
13:29:29 <j-invariant> if x is not equal to 
13:29:29 <j-invariant> y
13:29:30 * hackagebot download 0.3.1.1 - High-level file download based on URLs  http://hackage.haskell.org/package/download-0.3.1.1 (MagnusTherning)
13:30:19 <mun> j-invariant, but could x be not equal to y since when x = v iff y = v
13:31:36 <j-invariant> mun: exactly, that would be a contracddiont
13:31:44 <monochrom> (ALL v. ((x = v) <--> (y = v))) <-> (x=y). You can prove this.
13:32:48 <monochrom> But then x=y is neither a theorem or a contradiction. There are satisfying models and unsatisfying models.
13:34:46 <monochrom> s/ or / nor /
13:34:56 <mun> then
13:35:15 <mun> i guess ALL v. x = v & y = v is inconsistent?
13:36:18 <monochrom> still has a satisfying model
13:36:19 <mun> monochrom, but if there are unsatisfying models, wouldn't that make it inconsistent?
13:36:38 <monochrom> inconsistent = lacks satisfying model
13:37:51 <mun> monochrom, then what does it mean for a formula to have unsatisfying models? even P --> Q would give rise to unsatisfying models, right?
13:39:20 <monochrom> P->Q has satisfying models (set P to false, set Q to false) and unsatisfying models (set P to true, set Q to false)
13:41:06 <monochrom> an unsatifying model plugs values into identifiers so the whole statement evaluates to false.
13:42:13 <mun> right. so for ALL v. x = v & y = v then an unsatifying model is when x = v+1 and y = v?
13:43:19 <monochrom> you shouldn't do that, taking a local variable outside its scope.
13:43:58 <monochrom> you should say an unsatisfying model is when x=1 and y=0.
13:44:06 <mun> monochrom, okay
13:44:50 <mm_freak_> @src enumFrom
13:44:51 <lambdabot> Source not found. You type like i drive.
13:45:06 <monochrom> not to mention that when giving a model, it's best to be more concrete, like "x=0" instead of "x=unknown"
13:47:40 <monochrom> Here is a satifying model for (ALL v. x = v & y = v). The universe is just {0}. set x to 0, set y to 0. (there is no other choice anyway.) When examining "ALL", there is only one value to test.
13:48:41 <mun> right
13:48:47 <monochrom> But if you insist the universe to be , (ALL v. x = v & y = v) can be disproved.
13:49:01 <monochrom> err, (ALL v. x = v & y = v) can be proved false.
13:50:35 <mun> monochrom, then going back to ALL v. x=v iff y=v you mentioned that (ALL v. x=v iff y=v) iff x = y
13:50:54 <mun> but ALL v. x=v iff y=v can be proved false in Z
13:52:09 <monochrom> there is no proof. even with universe  there are satisfying models. Here is one: set x to 0, set y to 0.
13:52:18 <warrenharris> Is there an easy way to link a haskell program with a debug malloc package? I'm getting a memory corruption crash.
13:52:37 * hackagebot base16-bytestring 0.1.0.0 - Fast base16 (hex) encoding and deconding for ByteStrings  http://hackage.haskell.org/package/base16-bytestring-0.1.0.0 (BryanOSullivan)
13:53:12 <mun> monochrom, but setting x=1 and y=0 makes it false.
13:53:52 <monochrom> that gives you an unsatisfying model. does not proof the statement false.
13:55:24 <monochrom> the casual way to describe this situation is "x=y is sometimes true and sometimes false, it depends"
13:55:38 * hackagebot base64-bytestring 0.1.0.2 - Fast base64 encoding and deconding for ByteStrings  http://hackage.haskell.org/package/base64-bytestring-0.1.0.2 (BryanOSullivan)
13:57:47 <mun> thanks monochrom 
14:03:19 <poincare101> accel: I think ocaml can act like its strict
14:18:09 <azaq23> poincare101: ocaml is strict by default
14:23:12 <Mathnerd314> is it just me, or do arrows not need anything besides arr and id?
14:23:38 <Mathnerd314> *>>>
14:23:43 <hpc> Arrow requires arr and (>>>)
14:23:46 <aristid> Mathnerd314: it's just you.
14:23:47 <hpc> but it also requires Category
14:23:50 <hpc> so id and (.)
14:24:09 <hpc> though that probably falls under aristid's answer
14:24:33 <monochrom> arrows also need some of { first, second, &&&, *** } so you could do more interesting plumbing than just one pipeline.
14:24:52 <aristid> :t first
14:24:53 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
14:24:54 <aristid> :t arr
14:24:55 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
14:25:19 <monochrom> the arrow paper(s) have some nice block diagrams to show you examples
14:25:36 <hpc> the diagrams are copied on the wikibook
14:25:56 <Mathnerd314> @type (>>>)
14:25:57 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
14:26:24 <ketil> Any way to get fragment URLs with Gitit?  I.e. so I can link to http://my.wiki.org/Page#fragment
14:26:44 <gwern> ketil: that doesn't work?
14:27:15 <ivanm> ketil: you mean how to get the fragments?
14:27:55 <pumpkin> ketil: the fragments exist at "runtime"
14:28:01 <azaq23> @type (>>>) `asTypeOf` flip (.)
14:28:03 <lambdabot> forall a a1 b. (a -> a1) -> (a1 -> b) -> a -> b
14:28:03 <pumpkin> you need to catch them with javascript
14:28:43 <gwern> pumpkin: javascript?
14:28:53 * gwern is confused. are we talking about the same pandoc?
14:29:20 <pumpkin> oh I see, he just wants to link to an anchor within the same page
14:29:23 <test423432> edwardk are you there?
14:29:45 <monochrom> view the html code, find anchors...
14:30:34 <gwern> ketil: links to another page look like [foo](Bar#baz). self-links look like [foo](#baz). you figure out the #baz by either knowing pandoc's deterministic and documented scheme for transforming section titles or just looking at where the table of contents points you or the div id in the html
14:31:10 <kuffaar> Haha, somebody in the audience asking SPJ if a, b, c in (a : b : c) can be null, like in Java or C#
14:31:18 <monochrom> hahaha
14:31:33 <kuffaar> Amused me because people were complaining about NPEs for like 2 hours yesterday
14:31:35 <hpc> that question tore a hole in the palm-face continuum
14:31:36 <monochrom> the trillion yen mistaken or something
14:31:57 <kuffaar> No, I mean, it's a legitimate question
14:31:58 <ski> (kuffaar : in a movie ?)
14:31:58 <monochrom> s/mistaken/mistake/
14:32:00 <kuffaar> It's not stupid
14:32:12 <kuffaar> These peoploe don't know Haskell
14:32:20 <monochrom> no, the question is not stupid
14:32:21 <kuffaar> I'm watching the OSCON 2007 talk by SPJ
14:32:24 <hpc> ah, then it's fair
14:33:48 <gwern> monochrom: billion dollar
14:34:04 <monochrom> understand that I'm so cold-blooded I no longer mock people. (I don't even care.) I mock ideas.
14:34:38 <hpc> who's SPJ?
14:34:46 <monochrom> Simon Peyton Jones
14:34:46 <Silvah> Can someone explain me how scan* functions work?
14:34:48 <gwern> '# I call it my billion-dollar mistake. It was the invention of the null reference in 1965.  Tony Hoare
14:34:53 <kuffaar> Simon Peyton Jones, one of the key people behind Haskell
14:35:08 <hpc> Silvah: say you do a fold
14:35:12 <monochrom> a billion dollar is about 0.1 trillian yen.
14:35:21 <kuffaar> Trillian.
14:35:25 <hpc> Silvah: but as you fold, you collect each intermediate value, and put it in a list
14:35:36 <hpc> the value produced by scan* is that list
14:35:43 <kuffaar> ghci used to have ASCII art :o
14:35:48 <kuffaar> Whatever happened to that
14:36:01 <kuffaar> Heh, SPJ uses emacs, eh?
14:36:07 <hpc> the last value of scan* == the value of the equivalent fold
14:36:34 <gwern> kuffaar: people complained about the visual noise. and good riddance
14:36:36 <monochrom> my http://www.vex.net/~trebla/haskell/scanl.xhtml may help you with scan.
14:36:48 <Silvah> > scan (+) 0 $ repeat 1
14:36:48 <lambdabot>   Not in scope: `scan'
14:36:58 <Silvah> > scanr (+) 0 $ repeat 1
14:36:59 <lambdabot>   [*Exception: stack overflow
14:37:27 <monochrom> well I guess only one line helps. (the rest is advanced.) scanl () s0 [x,y,z] = [s0, s0x, (s0x)y, ((s0x)y)z]
14:37:39 <kelvie_> n
14:38:17 <azaq23> > take 10 $ scanl (+) 0 $ repeat 1
14:38:18 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
14:39:37 <Silvah> > take 10 $ scanr (+) 0 $ repeat 1
14:39:38 <lambdabot>   [*Exception: stack overflow
14:39:51 <Silvah> er
14:40:10 <Silvah> > scanr (+) 0 $ replicate 10 1
14:40:11 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0]
14:40:30 <pumpkin> scanr and scanl are backwards from foldr and foldl
14:40:43 <kuffaar> Loading package Veles-0.1 ... linking ... <interactive>: C:\Users\void\AppData\Roaming\cabal\Veles-0.1\ghc-7.0.1\HSVeles-0.1.o: unknown symbol `___stginit_Veleszm0zi1_VelesziSCGI_'
14:40:47 <kuffaar> What's that all about?
14:40:49 <pumpkin> in their behavior at infinity, anyway
14:41:04 <pumpkin> > scanr (:) [] $ repeat 1
14:41:04 <lambdabot>   [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:41:07 <Silvah> So scanl is preferred?
14:41:36 <pumpkin> > scanr (:) [] $ replicate 20 5
14:41:36 <lambdabot>   [[5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5],[5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5...
14:41:46 <pumpkin> > scanr (:) [] $ [1..10]
14:41:47 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[4,5,6,7,8,...
14:42:01 <pumpkin> Silvah: depends what you want, really
14:43:36 <kuffaar> Heh, SPJ explaining partial application and the crowd getting all confused. Poor imperative coders, I feel for them
14:43:58 <Hunner> :D
14:45:44 <gwern> kuffaar: partial application is easy if your syntax mimics imperative syntax
14:46:17 <gwern> 'suppose we write a method which takes 9 arguments. then we can specialize it by hardwiring the first input and writing a new method which takes 8 arguments. this can clean up our code'
14:46:38 * ski wonders what imperative syntax is
14:46:53 <mm_freak_> ski: do return 3
14:47:29 <kuffaar> "unknown symbol `___stginit_Veleszm0zi1_VelesziSCGI_'" <- Veles.SCGI is not exported but it's not used directly by the code I am ghci'ing...
14:47:55 <kuffaar> It imports a module which uses Veles.SCGI though
14:48:02 <kuffaar> Is that a problem with ghci?
14:48:30 <ivanm> probably not with ghci itself
14:48:40 <ivanm> does "ghc-pkg check" bitch?
14:48:48 <ski> preflex: zdec ___stginit_Veleszm0zi1_VelesziSCGI_
14:48:48 <preflex>  ___stginit_Veles-0.1_Veles.SCGI_
14:49:05 <kuffaar> ivanm it does not
14:50:00 * hackagebot base16-bytestring 0.1.1.0 - Fast base16 (hex) encoding and deconding for ByteStrings  http://hackage.haskell.org/package/base16-bytestring-0.1.1.0 (BryanOSullivan)
14:50:27 <kuffaar> This used to work fine as long as I used only one module
14:52:00 <aristid> bos: the bug tracker link in base16-bytestring is wrong, and www.mailrank.com does not work
14:53:24 <bos> aristid: thanks, fixed
14:53:35 <kuffaar> SPJ calls tuples "groupings" instead of tuples, oddball
14:54:01 * hackagebot base16-bytestring 0.1.1.1 - Fast base16 (hex) encoding and deconding for ByteStrings  http://hackage.haskell.org/package/base16-bytestring-0.1.1.1 (BryanOSullivan)
14:54:03 <ivanm> aristid: heh, took me a while to realise why it didn't work
14:55:02 <gwern> ski: I mean that partial application is confusing when combined with pointsfree
14:55:24 <gwern> ski: it's otherwise a common imperative idiom - 'function foo with some default arguments'
14:55:25 <ski> ok
14:55:48 <gwern> it's just when you show someone 'map (+1) x' that it looks mysterious
14:56:22 <ski> > map (map succ) [[0,1,2],[3,4],[5],[]]
14:56:24 <lambdabot>   [[1,2,3],[4,5],[6],[]]
14:56:39 <ski> would that be easier ?
14:56:41 <hpc> > succ .: [[0,1,2],[3,4],[5],[]]
14:56:42 <lambdabot>   [[1,2,3],[4,5],[6],[]]
14:56:52 <mreh> heh, Caleskall
14:56:55 <mreh> cheating
14:56:59 <hpc> :D
14:57:23 <hpc> i haven't used map in so long
14:57:33 <Saizan> kuffaar: is that module from a cabal package? is Veles.SCGI listed in other-modules at least?
14:57:35 <hpc> (as in "map", not fmap or <$>)
14:57:35 <ivanm> preflex: seen edwardk 
14:57:36 <preflex>  edwardk was last seen on #haskell 1 hour, 30 minutes and 28 seconds ago, saying: of course thats a lie if the arguments have lazy structure
14:57:41 <ski> (hehe .. it's strange to see your own operator used in ways you couldn't imagine when inventing it ;)
14:57:44 <kuffaar> Saizan it is not
14:57:47 <mreh> hpc: why not?
14:57:49 <kuffaar> What does other-modules do?
14:57:50 <aristid> mreh: .: is skiskell, not caleskell :)
14:57:53 <kuffaar> I've never heard of it before
14:58:02 <hpc> mreh: because i prefer to use <$>
14:58:05 <ski> aristid : but the above typing of it comes from Caleskell
14:58:11 <ski> @type (.:)
14:58:12 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
14:58:20 * mreh nods
14:58:22 <hpc> it makes it easier to write functions as being applied to the inside of a thing
14:58:34 <ski> aristid : i had `(a -> b) -> (x -> y -> a) -> (x -> y -> b)'
14:58:44 <aristid> ski: i don't know who invented (.:) = fmap.fmap. but i @let'ed it so often that Cale put it in
14:58:45 <Saizan> kuffaar: in the .cabal file for a package, exposed-modules are those that can be imported from other packages, other-modules are the rest of them
14:58:47 <gwern> kuffaar: other-modules is for modules your public modules need, but which arent public
14:59:01 <ivanm> @tell edwardk BiDirectional forgets to take loops into account for degree
14:59:01 <hpc> :t on
14:59:02 <lambdabot> Consider it noted.
14:59:02 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
14:59:03 <kuffaar> It works, cheers
14:59:13 <gwern> kuffaar: so my package provides Foo.Bar and Foo.Baz and I also have a Foo.Quux which they share but is private
14:59:24 <ski> aristid : i think someone just defined `(.:) = (.) . (.)' in lambdabot .. and then used that with the Caleskell definition of `(.)'
14:59:29 <aristid> :t (<<<) . (<<<)
14:59:30 <lambdabot> forall a (cat :: * -> * -> *) b c a1. (Control.Category.Category cat) => cat b c -> (a -> cat a1 b) -> a -> cat a1 c
14:59:32 <kuffaar> dcoutts: When are we getting a parallelised cabal-install? :[
14:59:46 <ivanm> kuffaar: when someone implements parallelised ghc --make
14:59:48 <aristid> ski: (.:) is in lambdabot itself, it's no @let
14:59:55 <mreh> install two packages in two terminals
14:59:56 <ski> (aristid : `(.:) = (.) . (.)' was my original definition of it)
14:59:58 <dcoutts> kuffaar: parallel within a package or parallel for multiple packages ?
14:59:59 <mreh> instant parallel install
15:00:01 <ski> aristid : ok
15:00:04 <kuffaar> Within a package, dcoutts
15:00:05 <ski> @src (.:)
15:00:05 <lambdabot> Source not found.
15:00:11 <dcoutts> kuffaar: a while I'm afraid
15:00:17 <kuffaar> ivanm: Why does that require parallelisation from ghc?
15:00:23 <aristid> copumpkin: copumpkinHimself would work.
15:00:24 <dcoutts> kuffaar: package management bugs are higher priority
15:00:27 <copumpkin> ick
15:00:30 <mreh> cabal is a wrapper for ghc
15:00:31 <monochrom> we will get parallelised cabal-install after I buy a 16-core computer, and not before.
15:00:36 <ivanm> kuffaar: because Cabal just calls ghc --make
15:00:46 * copumpkin just wrote the world's most advanced primop for GHC
15:00:51 <dcoutts> kuffaar: it would not require parallel ghc --make, wed' want to do it properly
15:01:01 <ivanm> dcoutts: oh...
15:01:02 <kuffaar> With gcc you parallelise without the help of gcc
15:01:03 * hackagebot flower 0.7 - Analyze 454 flowgrams (.SFF files)  http://hackage.haskell.org/package/flower-0.7 (KetilMalde)
15:01:05 <kuffaar> So I'm puzzled
15:01:06 <copumpkin> get this
15:01:12 <dcoutts> kuffaar: right, exactly
15:01:12 <copumpkin> it actually tells you how big your Array# is!
15:01:18 * copumpkin jumps up and down
15:01:33 <dcoutts> kuffaar: cabal only calls ghc --make because it's lazy :-) it's not the "Right Way" to do it
15:01:39 <Silvah> wow
15:01:46 <monochrom> hmm how is size-of-Array# an advanced primop?
15:01:56 <copumpkin> monochrom: it took 1000 lines of code!
15:01:56 <ivanm> dcoutts: very simplistically, could you do it by getting the inter-module graph, grouping together loops, then doing some kind of schedule (heap-based?) to pass the next block of modules to build to the next available processor?
15:02:02 * Silvah ain't got no Array#.
15:02:02 <jmcarthur> wtf?
15:02:03 <copumpkin> and it runs in O(-1) time
15:02:15 <monochrom> I wonder why it takes 1000 lines but now I agree
15:02:28 <Silvah> You get the value before you started to evaluate? 
15:02:40 <jmcarthur> O(-1) = O(1) :P
15:02:41 <hpc> Silvah: because he can do it faster by hand, ofc
15:02:42 <copumpkin> Silvah: even before you considered writing the code that would evaluate to needing the value
15:02:46 <monochrom> but wait, 1000 haskell lines or 1000 agda lines? :)
15:02:51 <copumpkin> jmcarthur: nah, constants are assumed to be positive
15:03:08 <Botje> there's a maths joke that goes "let epsilon be negative"
15:03:12 <mreh> haskell and agda fight
15:03:15 <copumpkin> :P
15:03:17 <roconnor> what makes parsec fast?
15:03:24 <copumpkin> no, it's a really simple primop, I admit it
15:03:34 <mreh> roconnor: writing a LL(1) grammar
15:03:35 <Mathnerd314> Botje: have you ever gotten anyone to laugh at it?
15:03:51 <copumpkin> the joke are the people who laugh at it
15:03:56 <Silvah> roconnor: parsec cannot be fast.
15:03:58 <monochrom> usually the O notation breaks down with negative things. just don't do it.
15:04:01 <dcoutts> ivanm: more or less, but more generally you want pre-processors etc too
15:04:04 <roconnor> mreh: I mean, what makes parsec faster than say a recursive decent parser?
15:04:11 <Botje> Mathnerd314: most people I know don't even know what an epsilon looks like :(
15:04:16 <ivanm> dcoutts: *nod*
15:04:16 <j-invariant> "let epsilon < 0"
15:04:19 <dcoutts> ivanm: pretty quickly you realise you need a generic make-like dep framework
15:04:22 <j-invariant> markers see this all the time lol
15:04:27 <dcoutts> ivanm: and that's why we've not done it yet
15:04:30 <ivanm> heh
15:04:36 <Mathnerd314> copumpkin: ah, I see.
15:04:48 <monochrom> an epsilon looks like 
15:05:23 <monochrom> http://www.vex.net/~trebla/homework/epsilon-delta.html has more 's
15:06:39 <copumpkin> monochrom: I like your reverse button
15:06:54 <monochrom> well, that converges the conversation to DNE :)
15:07:00 * copumpkin keeps pressing it
15:07:14 <copumpkin> omg a comex
15:09:02 <copumpkin> damn, my super complicated primops are wrong
15:09:11 <ivanm> awwwwww
15:09:23 <copumpkin> in two different ways!
15:09:26 <monochrom> yeah, that tends to happen to 1000-line code
15:09:34 <copumpkin> I lied 
15:09:37 <copumpkin> it was actually two lines
15:09:45 <copumpkin> one for each primop
15:10:03 <monochrom> so simple it's obviously flawed :)
15:10:09 <copumpkin> I'm tempted to just give in and write this in cmm
15:10:27 <mreh> common pattern, applying a function to each element with its neighbour
15:10:36 <copumpkin> the aztec god
15:10:58 <copumpkin> `ap`tail
15:11:06 <copumpkin> f`ap`tail?
15:11:09 <roconnor> @quote aztec
15:11:10 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
15:11:10 <copumpkin> that sounds kind of rude though
15:11:18 <Silvah> What are actually there primops for?
15:11:27 <mreh> copumpkin: uh?
15:11:36 <copumpkin> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.2.0.0/GHC-Prim.html
15:12:46 <mreh> > liftM2 (zipWith (,)) id (drop 1) $ [1,2,3]
15:12:47 <lambdabot>   [(1,2),(2,3)]
15:12:51 <hpc> :t zip`ap`tail
15:12:52 <lambdabot> forall b. [b] -> [(b, b)]
15:13:05 <hpc> > zip`ap`tail [1..]
15:13:06 <lambdabot>   Couldn't match expected type `[a] -> [b]'
15:13:06 <lambdabot>         against inferred type `[t]'
15:13:07 <mreh> that's good golf
15:13:25 <mreh> don't understand it
15:13:25 <hpc> > zip`ap`tail $ [1..]
15:13:26 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12...
15:13:41 <mreh> is that the Reader monad?
15:13:48 <copumpkin> :t (\f -> zipWith f`ap`tail)
15:13:49 <lambdabot> forall b c. (b -> b -> c) -> [b] -> [c]
15:14:21 <Saizan> mreh: yep
15:14:23 * mreh still doesn't have a firm grasp of applicative
15:14:59 <Twey> Applicative is a lot easier to understand than its function instance
15:15:08 <jmcarthur> f <*> g  =  \x -> (f x) (g x)
15:15:17 <hpc> the function instance is totally wonky
15:15:28 <jmcarthur> it's just S and K
15:15:29 <hpc> the IO instance might be most grokable
15:15:29 <mreh> is it not the same as Reader?
15:15:36 <hpc> er
15:15:37 <hpc> Maybe
15:15:41 <Saizan> it is
15:15:45 <hpc> IO has no useful functions to go with it
15:15:56 <mreh> it *is*?
15:16:09 <jmcarthur> the function instance is the same as the reader instances, yes
15:16:11 <jmcarthur> *instance
15:16:56 <Philippa_> mreh: some Applicatives are a subset of monads - just return, fmap and ap
15:16:58 <kuffaar> Hahahaha, SPJ actually addressed something I brought up as a joke in here once. "What is the UML for Haskell?" and he says "I actually feel guilty about that, but just for a little while, because Haskell types ARE like UML!"
15:17:35 <mreh> I understand some Applicatives, I just never see when to use them
15:17:36 * hpc has a sad at monad's lack of functor and applicative prereqs
15:17:46 <mreh> haven't grokked the meta pattern yet i suppose
15:18:15 <jmcarthur> pretty much just when you want to apply one thing to another, but they are functorfied
15:18:27 <hpc> mreh: it's most awesome with lists of functions
15:18:36 <mreh> play that functor music
15:18:42 <jmcarthur> > [succ, pred, (*7)] <*> [1..3]
15:18:44 <lambdabot>   [2,3,4,0,1,2,7,14,21]
15:18:45 <hpc> i think i have some real world applicative use laying around
15:18:53 <jmcarthur> i have tons
15:19:03 <monochrom> when your thing is a Monad and Applicative: do { x<-m; y<-n; return (f m n) } = f <$> m <*> n. This generalizes to any arity.
15:19:25 <jmcarthur> likewise, liftM* = liftA*
15:20:00 <test423432> okay guys I am hopeless
15:20:06 <monochrom> there is also do { x<-m; s; return (f x) } = f <$> m <* s  which I find useful when using parsec.
15:20:12 <test423432> I couldn't solve that problem
15:20:27 <mreh> zipLists need some syntactic sugar
15:20:37 <monochrom> you can tell that before Applicative came along, I kept writing those verbose do versions.
15:20:37 <Silvah> :t (<*)
15:20:38 <hpc> zipLists have applicative
15:20:38 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
15:21:15 <aristid> monochrom: you COULD have written f `liftM` m << s
15:21:24 <mreh> hpc: I'm just disappointed by all the type-fu
15:21:31 <aristid> :t (<<)
15:21:32 <lambdabot> Not in scope: `<<'
15:21:41 <monochrom> it was before << came along, too.
15:21:42 <Philippa_> mreh: what type-fu?
15:21:44 <aristid> well, with (<<) manually defined at least
15:21:46 <Philippa_> it's no worse than monads
15:21:47 <sipa> @let (<<) = flip (>>)
15:21:48 <lambdabot>  Defined.
15:21:54 <aristid> monochrom: it was the dark ages.
15:22:06 <Silvah> :t (<<)
15:22:07 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m b -> m a -> m b
15:22:07 <Philippa_> or do you mean just having to annotate which Applicative you want when more than one makes sense?
15:22:22 <mreh> Philippa_: just wrapping and un-wrapping
15:22:30 <monochrom> type-fu = logic-fu. logic is trivial, right?
15:22:54 <mreh> it's more of golfing thing really
15:24:11 <hpc> i still don't know what to think of (<<)
15:24:25 <hpc> re: the order of side-effects
15:24:36 <parcs> @hoogle sleep
15:24:36 <lambdabot> No results found
15:25:01 <monochrom> think of x >> ((y >> z) << (k >> m)) >> w
15:25:36 <hpc> monochrom: thinking...thinking... OH GOD KILL ME NOW
15:28:57 <monochrom> eh? <**> is flipped <*>? interesting choice of symbol
15:29:25 * monochrom designs <***> to be flipped <**>
15:29:35 <sipa> :t (<**>)
15:29:36 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
15:30:02 <Philippa_> I guess >*< might make more sense
15:30:08 <copumpkin> monochrom: we should have a way of specifying regular or context-free function names
15:30:17 <sipa> :t (<$>)
15:30:19 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:30:27 <sipa> :t (<*>)
15:30:33 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
15:30:41 <copumpkin> <\*(\*\*)*> : f (a -> b) -> f a -> f b
15:30:59 <ivanm> monochrom: why not have it as >**< for the flipped one? :p
15:31:02 <copumpkin> <*>, <***>, <*****>
15:31:08 <copumpkin> those would all parse as the above
15:31:10 <sipa> haskell definitely needs regexp-defined custom operators
15:31:19 <copumpkin> context-free, even!
15:31:22 <monochrom> you know this will cause revenantphx to >___<
15:31:28 <revenantphx> >_<
15:31:33 <monochrom> see? :)
15:31:35 <copumpkin> >______<
15:31:35 <revenantphx> Wait, what are we talking about?
15:31:40 <copumpkin> that mouth just gets wider and wider
15:31:55 <monochrom> we are talking about <*>, <**>, >*<, >**<
15:31:58 <revenantphx> oh ok.
15:31:59 <revenantphx> And.
15:32:08 <copumpkin> >___< seems like a legit operator
15:32:13 <revenantphx> Lol.
15:32:14 <monochrom> well >*< looks too much like your >_< :)
15:32:30 <revenantphx> @let '>_<' a b = a + b
15:32:30 <lambdabot>   Improper character constant or misplaced '
15:32:38 <revenantphx> @let (>_<) a b = a + b
15:32:38 <lambdabot>   Parse error: )
15:32:40 <hpc> @let (>.<) = const "Oh crap!"
15:32:40 <lambdabot>  Defined.
15:32:41 <revenantphx> boooo
15:32:42 <monochrom> _ is too alphabetical
15:32:51 <revenantphx> > >.<
15:32:52 <lambdabot>   <no location info>: parse error on input `>.<'
15:33:00 <hpc> er, meant to make it binary
15:33:05 <hpc> @forget
15:33:05 <lambdabot> Incorrect arguments to quote
15:33:08 <monochrom> > (>.<) 4
15:33:10 <hpc> @undefine
15:33:10 <lambdabot>   "Oh crap!"
15:33:13 <revenantphx> :)
15:33:15 <Saizan> quick, find a symbol _ in unicode somewhere
15:33:17 <monochrom> just in time!
15:33:27 <Twey> > let (>.<) = const $ const $ text "Oh crap!"
15:33:28 <lambdabot>   not an expression: `let (>.<) = const $ const $ text "Oh crap!"'
15:33:28 <hpc> @let _ (>.<) _ = "Oh crap!"
15:33:29 <lambdabot>   Parse error in pattern: _
15:33:38 <Twey> No brackets in that one :
15:33:41 <hpc> derp
15:33:47 <Twey> @let _ >.< _ = text "Oh crap!"
15:33:48 <lambdabot>  Defined.
15:33:52 <hpc> ninja
15:33:53 <Twey> > (>.<)
15:33:54 <lambdabot>   Overlapping instances for GHC.Show.Show
15:33:54 <lambdabot>                              (t -> ...
15:33:59 <Twey> Whaaat
15:34:03 <hpc> > f >.< x
15:34:04 <lambdabot>   Ambiguous type variable `a' in the constraint:
15:34:04 <lambdabot>    `SimpleReflect.FromExpr a...
15:34:04 <Twey> Oh
15:34:05 <Twey> Right
15:34:07 <dropdrive> Are there any recommended Haskell-related podcasts?  I'm zoning out here at work.
15:34:09 <revenantphx> > 
15:34:11 <lambdabot>   <no location info>: lexical error at character '\STX'
15:34:15 <copumpkin> this is good documentation: http://snapplr.com/zmbe
15:34:16 <revenantphx> That is NOT \STX
15:34:19 <hpc> > 
15:34:20 <lambdabot>   Not in scope: `
15:34:40 <revenantphx> @let  = 0x7777777F
15:34:40 <lambdabot> Plugin `eval' failed with: Enum.toEnum{Word8}: tag (8734) is outside of bounds (0,255)
15:34:47 <revenantphx> ...
15:34:48 <revenantphx> did I break it.
15:34:49 <revenantphx> @let
15:34:49 <monochrom> you have those bolding codes
15:34:50 <lambdabot>  Defined.
15:34:54 <revenantphx> oh , accident
15:34:59 <revenantphx> @forget
15:35:00 <lambdabot> Incorrect arguments to quote
15:35:04 <revenantphx> @let  = 0x7777777F
15:35:05 <lambdabot> Plugin `eval' failed with: Enum.toEnum{Word8}: tag (8734) is outside of bounds (0,255)
15:35:13 <revenantphx> @let inf = 0x7777777F
15:35:14 <lambdabot>  Defined.
15:35:15 <revenantphx> > inf
15:35:17 <lambdabot>   2004318079
15:35:32 <revenantphx> @let  = 0x7777777F
15:35:32 <lambdabot>   Illegal character ''\STX''
15:35:34 <kuffaar> Haha, SPJ just agreed with somebody in the audience: "Haskell does indeed have an equivalent of the null pointer exception - non exhaustive search during pattern matching"
15:35:39 <monochrom> bolding code again
15:35:50 <revenantphx> @let  = 0x7777777F
15:35:51 <lambdabot> Plugin `eval' failed with: Enum.toEnum{Word8}: tag (8734) is outside of bounds (0,255)
15:36:00 <ivanm> kuffaar: where's this?
15:36:12 <monochrom>  is not alphabetical enough
15:36:12 <kuffaar> ivanm: OSCON 2007 part II 7:45
15:36:29 <ivanm> oh, _videos_
15:36:40 <Twey> @let () = 1 / 0
15:36:41 <lambdabot>  Defined.
15:36:48 <Twey> > ()
15:36:50 <revenantphx> @let  x y z = text "Fuck this"
15:36:50 <lambdabot>   Infinity
15:36:51 <lambdabot> Plugin `eval' failed with: Enum.toEnum{Word8}: tag (8752) is outside of bounds (0,255)
15:37:03 <monochrom> > Data.Char.generalCategory ''
15:37:04 <lambdabot>   MathSymbol
15:37:13 <Twey> Why do we convert to Word8?
15:37:25 <revenantphx> oh
15:37:27 <revenantphx> I just noticed
15:37:34 <revenantphx> apprenrly OS X's character pane also has those clasifications
15:37:45 <revenantphx> doubt thye match up though
15:38:00 <revenantphx> > Data.Char.generalCategory ''
15:38:01 <lambdabot>   OtherNumber
15:38:05 <revenantphx> ... 0.o
15:38:06 <monochrom> you are supposed to use  as part of an infix operator
15:38:10 <revenantphx> > 10 + 
15:38:11 <lambdabot>   <no location info>: lexical error at character '\10109'
15:38:12 <copumpkin> revenantphx: that stuff is standardized in the unicode spec
15:38:27 <monochrom> > let x  y = x-y in 5  5
15:38:28 <lambdabot>   0
15:43:14 <aristid> oO infinite as an operator
15:46:11 <monochrom> > let x  y = x+y in 5  5
15:46:12 <lambdabot>   10
15:46:19 <monochrom> the snowman operator too
15:46:37 <monochrom> yesod should define the snoyman operator :)
15:47:03 <joe6> does anyone know how I can show the output of this> tupleReplicate 3 :: Q Exp
15:47:18 <joe6> > i Q Exp
15:47:18 <copumpkin> if I have a computation like y = x + (x >> 7), and have x, what's an efficient way to get x given y?
15:47:18 <lambdabot>   Not in scope: data constructor `Q'Not in scope: data constructor `Exp'
15:47:42 <monochrom> > let xy = x>>y in [1,800][123,4567]
15:47:43 <lambdabot>   [123,4567,123,4567]
15:47:49 <monochrom> the telephone operator
15:48:47 <kuffaar> That's the list monad?
15:48:52 <monochrom> yes
15:49:04 <joe6> i tried this without much luck: (tupleReplicate 3) >>= (return . show)
15:49:30 <joe6> the Q Exp is part of the  Language.Haskell.TH package
15:49:46 <monochrom> can it even be showed?
15:49:51 <Cale> copumpkin: What instance of both Monad and Num is that?
15:49:59 <copumpkin> Cale: it's a C right shift :P
15:50:02 <Cale> oh
15:50:13 <monochrom> damn you C and Haskell
15:50:14 <kuffaar> Haha
15:50:14 <copumpkin> so divide by 128?
15:50:45 <monochrom> ok wait, you have x, and then you want to find x given y? don't you just ignore y?
15:50:49 <joe6> Q Exp = ExpQ
15:50:49 <kuffaar> copumpkin you said you have x
15:50:55 <joe6> > i ExpQ
15:50:55 <lambdabot>   Not in scope: data constructor `ExpQ'
15:50:56 <copumpkin> it's an equation
15:50:57 <kuffaar> Was that a mistake?
15:51:00 <copumpkin> I want to invert it
15:51:07 <copumpkin> using efficient bitwise ops
15:51:12 <kuffaar> copumpkin weren't you trying to say that you don't have x?
15:51:18 <joe6> > :i ExpQ
15:51:19 <lambdabot>   <no location info>: parse error on input `:'
15:51:24 <monochrom> you should delete "and have x"
15:51:25 <joe6> > t ExpQ
15:51:26 <lambdabot>   Not in scope: data constructor `ExpQ'
15:51:35 <copumpkin> kuffaar: well, in one direction I do :P
15:51:37 <Cale> Let's ignore the rounding. y = x + x/128 -> y = (1 + 1/128) x -> y/(1 + 1/128) = x
15:51:46 <ddarius> copumpkin: What makes you think it's invertible?
15:51:53 <copumpkin> ddarius: hope
15:52:08 <copumpkin> I'm trying to remove the cards that have been added to Array#
15:52:34 <monochrom> are there bounds on x, such as "between 0 and 127"?
15:52:38 <copumpkin> nope
15:52:51 <kuffaar> It's not injective is it?
15:52:51 <copumpkin> you basically get one card per 128 elements (although this is just a parameter)
15:52:55 <copumpkin> it isn't
15:52:59 <copumpkin> but I don't care about rounding
15:53:59 <copumpkin> so you get the original size of the array plus n / 128 cards, where n is the number of words in your data
15:54:12 <alimon> hi
15:54:31 <copumpkin> maybe I can petition to change what's stored in the array header somehow :P
15:59:18 <dankna> oh!  we're discussing array efficiency
15:59:21 * dankna pays attention
16:00:52 <dropdrive> Cale: Is this idea dead?  http://www.mail-archive.com/haskell-prime@haskell.org/msg02492.html  Would you recommend that a Haskell beginner adopt this?  How would I go about doing this (write my own prelude?)?  Thanks.  (I wrote this last night but you were gone.)
16:02:25 <Botje> dropdrive: you can @msg people and lambdabot will relay the message
16:02:55 <hpc> cale is alive :P
16:03:27 <dropdrive> Botje: Oh, okay, thanks.  Do I msg lambdabot or write to #haskell?
16:03:40 <Botje> @msg dropdrive hi
16:03:41 <lambdabot> Not enough privileges
16:04:01 <Botje> did it get removed?
16:04:05 <Botje> @tell dropdrive hi
16:04:05 <lambdabot> Consider it noted.
16:04:06 <Cale> dropdrive: I'd like to keep that idea alive myself.
16:04:10 <Botje> ah.
16:05:22 <dropdrive> Cale: Are you using this idea yourself?  Are you using your own Prelude (can you share?)?
16:05:22 <lambdabot> dropdrive: You have 1 new message. '/msg lambdabot @messages' to read it.
16:05:52 <edwardk> dropdrive: with <$> its not really as important any more
16:06:38 <dropdrive> edwardk: Okay, let me go read about it...
16:06:40 <Cale> dropdrive: Not really. It's too inconvenient to use a replacement prelude
16:06:54 <hpc> i prefer having (.) and (<$>) to be separate
16:07:22 <hpc> since (->) produces such difficult instances to grasp
16:09:14 <joe6> can I set the locale from command line
16:09:20 <joe6> for ghci, I mean
16:09:35 <pastorn> @hoogle Locale
16:09:35 <lambdabot> No results found
16:09:40 <pastorn> @hoogle locale
16:09:41 <lambdabot> No results found
16:09:43 <joe6> pastorn: hello
16:09:57 <edwardk> hpc: i tend to use them that way as well
16:10:07 <pastorn> joe6: hi
16:10:13 <hpc> i rarely use fmap anymore
16:10:15 <hpc> and never map
16:10:25 <joe6> i am trying this: ghci -Wall -XTemplateHaskell -v4 tut.hs
16:10:30 <joe6> and I get this error: <stderr>: hPutChar: invalid argument (Invalid or incomplete multibyte or wide character)
16:10:35 <hpc> if i wanted to golf, i would use (.)=(<$>)
16:10:38 <joe6> i think it is the instant-generics module
16:10:52 <pastorn> joe6: you can set character encodings on handles
16:11:02 <pastorn> that looks like you have the wrong encoding set
16:11:07 <joe6> found this on google: One thing to watch out for in the latest versions of GHC (6.12) is the new locale-sensitive text IO. For instance, when using EasyFilter to render Pandoc documents in WordPress, you must make sure you set the LANG environment variable to en_US.UTF-8 (e.g. in /etc/apache2/envvars), or it will typically default to POSIX and thus cause Pandoc to crash whenever it reads a non-ASCII character:
16:11:11 <pastorn> joe6: iirc it's in System.IO
16:11:15 <Twey> hpc: (.)=fmap is shorter
16:11:24 <hpc> Twey: shush
16:11:26 <hpc> :D
16:11:28 <joe6> pastorn: can I do this from the command line?
16:11:29 <Twey> :
16:11:36 <pastorn> joe6: yeah, i think so
16:11:54 <pastorn> joe6: look in System.IO, i'm pretty sure it's there somewhere
16:12:10 <joe6> pastorn: ok, thanks. will do.
16:12:11 <hpc> joe6: oh that's why my website broke when i tried to post unicode
16:16:57 <meth[phone]> hey what's up with http://book.realworldhaskell.org/read/getting-started.html printing it is truncated on the right side
16:18:16 <Botje> maybe it's made for a4 and you're printing it on something smaller?
16:18:21 <Botje> or your printer is adding extra evil margins
16:18:42 <accel> is the author of lisk in this channel?
16:20:26 <meth[phone]> let me try the a4 suggestion
16:20:27 <joe6> hpc: how did you fix it? i am not having much luck even with this> LANG=en-US.UTF-8 ghci -Wall -XTemplateHaskell -v4 tut.hs 
16:20:44 <hpc> joe6: didn't fix it; i used html escapes
16:20:55 <hpc> though i assume setEnv at the top of main would work
16:20:58 <meth[phone]> hm yea that worked
16:20:59 <hpc> :t setEnv
16:20:59 <lambdabot> Not in scope: `setEnv'
16:21:05 <hpc> :t setEnvironment
16:21:06 <lambdabot> Not in scope: `setEnvironment'
16:21:17 <meth[phone]> thanks
16:21:30 <hpc> er
16:22:09 <joe6> i doubt that it gets even to loading main. I think it fails while reading the env.
16:22:32 <hpc> that seems unlikely
16:22:34 * hpc checks
16:23:04 <hpc> env | grep LANG
16:23:06 <hpc> LANG=en_US.UTF-8
16:23:19 <hpc> (that's my default)
16:23:40 <hpc> so yeah, that proposed fix doesn't help
16:24:04 <Makoryu> https://github.com/urso/dotrc/blob/master/vim/syntax/haskell.vim <- Sup, found the origin of that Vim syntax file
16:24:37 <pastorn> Makoryu: there's another one, one that's in the haddock repository
16:24:52 <Makoryu> pastorn: I looked for that earlier and couldn't find it
16:25:03 <pastorn> @where haddock
16:25:03 <lambdabot> http://www.haskell.org/haddock/
16:25:47 <joe6> is there a cabal remove module command?
16:25:58 <pastorn> Makoryu: ah, here: http://code.haskell.org/haddock/
16:26:01 <c_wraith> joe6: nope.
16:26:04 <Makoryu> Thanks pastorn
16:26:12 <pastorn> joe6: no, but theres $ ghc-pkg hide PACKAGE
16:26:21 <joe6> pastorn: ok, thanks.
16:26:31 <pastorn> joe6: but then it'll be missing for all import uses
16:27:11 <pastorn> joe6: if you're just having version difficulties there's an extension that lets you choose exactly which version to import
16:27:22 <Makoryu> pastorn: This doesn't seem to be what I was looking for actually. It's an extension that highlights haddock comments.
16:27:37 <joe6> can I remove the module by deleting its' directory from .cabal/packages/hackage.haskell.org
16:27:57 <pastorn> Makoryu: too bad :(
16:28:09 <dcoutts> joe6: no, that's just the cached .tar.gz
16:28:17 <pastorn> joe6: there's also an entry in ~/.ghc/
16:28:19 <dcoutts> joe6: use ghc-pkg unregister --user pkgname
16:28:19 <pastorn> somewhere
16:28:34 <Makoryu> pastorn: There's a less complete (but also less buggy) syntax file bundled with Vim 7 and up
16:28:48 <pastorn> Makoryu: so? don't you have that?
16:28:53 <Makoryu> I do
16:29:06 <Makoryu> I thought there was a third
16:29:12 <Makoryu> Doesn't particularly matter
16:29:20 <pastorn> what more do you want?
16:29:23 <joe6> dcoutts: that helped, thanks
16:29:31 * ddarius hates when he gets to the end of a paragraph and realizes he didn't actually read or remember any of it.
16:29:37 <joe6> but, unfortunately I get the same locale error on the usb module, which I need.
16:31:28 <Makoryu> pastorn: I'm greedy ;)
16:32:17 <joe6> Glasgow Haskell Compiler, Version 7.0.1.20110109, for Haskell 98, stage 2 booted by GHC version 6.12.3
16:32:31 <joe6> is this expected? can I get the ghc to boot with a later version?
16:32:31 <ddarius> pastorn: He wants it to highlight non-terminating programs in red.
16:32:45 <copumpkin> joe6: it means whoever compiled your ghc was using 6.12.3
16:32:50 <copumpkin> it's irrelevant to you
16:33:01 <joe6> copumpkin: oh, ok. thanks.
16:33:19 <Makoryu> copumpkin: There are three stages, right?
16:33:27 <ddarius> joe6: You can compile 'til fixed point.
16:33:48 <Eduard_Munteanu> What is this, Gentoo? Three stages...
16:34:07 <Makoryu> Eduard_Munteanu: Come at me bro
16:34:12 <Makoryu> Eduard_Munteanu: What are your CFLAGS
16:34:17 <monochrom> there are normally just 2 stages
16:34:18 <j-invariant> I need a brainfuck termination checker --> Maybe Bool
16:34:21 <j-invariant> any ideas?
16:34:24 <Eduard_Munteanu> :)
16:34:35 <ddarius> j-invariant: const (Just True)
16:34:44 <joe6> ddarius: can you please explain? I do not understand what you said
16:34:44 <j-invariant> ddarius: that does not conform
16:34:54 <monochrom> what is Prese?
16:35:02 <monochrom> and damn you camel_case
16:35:11 <j-invariant> it should give  Just True if the program halts,  Just False if the program terminates and Nothing if the program cannot be understood
16:35:13 <Makoryu> j-invariant: Where did you get the idea that a Turning-complete language can have a general purpose termination checker
16:35:31 * monochrom hates capitalizing words that shouldn't be capitalized
16:35:33 <ddarius> j-invariant: Then const Nothing, or const (Just True).
16:36:02 <Mathnerd314> Makoryu: he didn't want a general-purpose one, just one that works
16:36:11 <j-invariant> ddarius: no sthat is just rubbish
16:36:19 <JP_> Hi guys, at school we got Hugs 98, but that thing seem old, what are the diffrence with the "Haskell Platform" I can download from the official web site ?
16:36:51 <accel> the point is monads is to serialize computation right? so why is it that: ">>= :: m a -> (a -> m b) -> m b " in f >>= g , forces g to run after f; but "g f" not force g to run after f? (clearly g needs the result from f, so f has to run first)
16:36:58 <ddarius> No.
16:37:04 <joe6> ddarius: just get the latest version and do the compile again? will that help
16:37:05 <monochrom> if you use the Haskell Platform, you enjoy more libs, more language extensions, and a compiler that generates native code.
16:37:09 <Eduard_Munteanu> JP_: yes, Hugs is old.
16:37:12 <gwern> JP_: hugs 98 is ancient and a unfeaturefull interpreter with very few libraries. the platform and ghc are... the opposite
16:37:29 <monochrom> but hugs98 error messages make more sense to learners.
16:37:36 <ddarius> joe6: It won't make any difference at all except, hopefully, the compiler will be a bit faster.
16:37:37 <gwern> (that would be new, featurefull, compiler, with many libraryes; in case you aren't sure how to negate my description of hugs)
16:37:38 <Eduard_Munteanu> JP_: some say Hugs has better error messages. The platform contains GHC, not Hugs.
16:37:58 <Makoryu> Hugs is actually older than Hs98, isn't it?
16:37:59 <gwern> I dunno, I think ghc messages have gotten a lot better and are competitive
16:38:00 <Eduard_Munteanu> With the latest the only significant part is n+k patterns are disallowed unless enabled explicitly.
16:38:08 <ddarius> monochrom: They are perhaps less intimidating, but they are useless.
16:38:14 <ddarius> Hugs does not have better error messages.
16:38:30 <monochrom> I carefully don't say "better".
16:38:36 <accel> the point is monads is to serialize computation right? so why is it that: ">>= :: m a -> (a -> m b) -> m b " in f >>= g , forces g to run after f; but "g f" not force g to run after f? (clearly g needs the result from f, so f has to run first)
16:38:44 <joe6> ddarius: this is the error message that I am trying to avoid? <stderr>: hPutChar: invalid argument (Invalid or incomplete multibyte or wide character)
16:38:49 <gwern> accel: monads have many points
16:39:00 <ddarius> gwern: And that's not one of them.
16:39:01 <joe6> when I google on the error message, the entries say that it was noticed on 6.12.3
16:39:01 <dolio> The point of monads is to characterize algebras.
16:39:09 <accel> one of the point is monads is to serialize computation right? so why is it that: ">>= :: m a -> (a -> m b) -> m b " in f >>= g , forces g to run after f; but "g f" not force g to run after f? (clearly g needs the result from f, so f has to run first)
16:39:12 <Eduard_Munteanu> JP_: the platform should work fine
16:39:27 <joe6> and I am wondering if it will help getting 7.0.1 and compiling with the latest ghc?
16:39:29 <monochrom> But I agree that (make more sense to learners) can also be (useless).
16:39:46 <JP_> Thx all, ill use the Platform then. Can I install that thing thru apt-get on Ubuntu (yea I'm a noob)
16:40:03 <monochrom> yes you can apt-get
16:40:12 <JP_> good thx again
16:41:14 <j-invariant> Any tips on brainfuck termination checker
16:41:15 <Eduard_Munteanu> joe6: are you using Unicode symbols in your source code?
16:41:17 <j-invariant> ?
16:41:33 <Entroacceptor> j-invariant: it's theoretically impossible
16:41:34 <joe6> not me, but I think the usb module is using it
16:41:41 <j-invariant> wow you guys are not that smart
16:41:45 <j-invariant> I thought #haskell was really clever
16:41:51 <joe6> Eduard_Munteanu: not my source code, but the usb module is doing that.
16:42:05 <monochrom> j-invariant don't challenge the channel.
16:42:15 <Eduard_Munteanu> joe6: you need the {-# LANGUAGE UnicodeSyntax #-} pragma then, or pass -XUnicodeSyntax as a parameter
16:42:16 <joe6> Eduard_Munteanu: and this happens when I do: ghci -Wall -XTemplateHaskell -v4 tut.hs
16:42:19 <ddarius> j-invariant: More the fool you were.
16:42:26 <Entroacceptor> well, you can check if there's any conditional or jump :)
16:42:30 <roconnor> oh, looks like I'm not the only person questioning structural subtyping
16:42:36 <degaus> j-invariant: it's right they're all pretty stupid. dons told me that
16:42:41 <pastorn> joe6: then you should set you output handle (for the file) to unicode specifically
16:43:04 <joe6> Eduard_Munteanu: no luck, it does not even start up.
16:43:14 <geheimdienst> j-invariant: here's a poem on why your "termination checker" can't work: http://www.lel.ed.ac.uk/~gpullum/loopsnoop.html
16:43:22 <joe6> pastorn: it is not in my program. It happens while loading.
16:43:27 <j-invariant> what the hell
16:43:31 <roconnor> oh wait, structural subtying isn't what I thought it was
16:43:37 <ddarius> geheimdienst, Entroacceptor: He's not asking for a complete one.
16:43:38 <Axman6> brainfuck is turing complete isn't it? it can at least be used to write a brainfuck interpreter, which makes the halting problem easily come into effect
16:43:53 <j-invariant> this is nothing to do with the halting problem
16:43:55 <Eduard_Munteanu> Heh, geheimdienst 
16:44:08 <j-invariant> I hate this knee jerk "ZOMEG TURING MACHINE" thing
16:44:18 <Eduard_Munteanu> If I only had a poem for each annoying question asked here...
16:44:29 <monochrom> the question is not annoying
16:44:33 <ddarius> j-invariant: Indeed, there are no Turing machines.  All programs can be shown to halt or not.
16:44:34 <Axman6> j-invariant: then clarify what you mean rather than acting like we're all idiots
16:44:49 <degaus> why should he do that?
16:44:51 <j-invariant> Axman6: umm I already did
16:45:01 <Axman6> uh, no you didn't?
16:45:11 <j-invariant> bye
16:45:11 <degaus> it is pompous to say you are not stupid
16:45:14 <degaus> quite so
16:45:15 <geheimdienst> "termination checker" sounds much like checking if a program halts, to me
16:45:36 <Axman6> me too
16:45:36 <j-invariant> geheimdienst: yeah that's the goal
16:45:40 <Eduard_Munteanu> Isn't there a non Turing-complete Brainfuck variant?
16:45:45 <copumpkin> j-invariant: I'm getting pretty close to just saying fuck it and banning you, fwiw
16:45:47 <monochrom> I agree that there is too much obsession with completeness.
16:45:47 <copumpkin> things like 
16:45:48 <copumpkin> [07:52:08 PM] <j-invariant> wow you guys are not that smart
16:45:48 <copumpkin> [07:52:12 PM] <j-invariant> I thought #haskell was really clever
16:45:56 <degaus> well come on
16:46:01 <Eduard_Munteanu> But IIRC that doesn't handle looping.
16:46:09 <degaus> don't take it at face value
16:46:14 <Eduard_Munteanu> So it probably always terminates.
16:46:40 <degaus> in fact it might be true, we must consider every possibility before we make rash decisions copumpkin 
16:46:49 <copumpkin> degaus: I've been considering it for the past few days
16:46:50 <degaus> are we stupid?
16:46:53 <geheimdienst> j-invariant: checking if a program halts *is* the halting problem. i urge you to read the poem
16:47:01 <j-invariant> this is so patronizing
16:47:09 <revenantphafk> Whoa whoa whoa.
16:47:11 <j-invariant> I just wanted any tips incase someone knew a good method
16:47:17 <revenantphafk> What's going on here.
16:47:29 <revenantphafk> If you guys keep this up, you'll leave me no choice...
16:47:41 <Cale> j-invariant: hmm...
16:47:44 <Axman6> j-invariant: if you think we don;t understand your question, make it more clear for us!
16:47:47 <geheimdienst> j-invariant: the trouble is that there _is_ no method
16:47:49 <Axman6> it's not hard
16:47:52 <j-invariant> geheimdienst: wrong
16:47:54 <copumpkin> geheimdienst: just because you can't decide exactly when something halts doesn't mean you can't say it'll halt every time it will
16:47:58 <copumpkin> just means you can't say it won't every time it won't
16:48:00 <copumpkin> or vice versa
16:48:05 <revenantphafk> j-invariant: You should know challenging #haskell will only lead to pain,
16:48:06 <j-invariant> As I said repeatedly, this is nothing to dowith hatling problem. turing machines, whatever
16:48:07 * Eduard_Munteanu agrees with Cale there
16:48:11 <revenantphafk> unless you have a really strong case.
16:48:30 <Cale> j-invariant: You could try to compile the brainfuck program into a form which uses fixed point operators, and then try to restrict how powerful a fixed point operator you need.
16:48:31 * copumpkin points geheimdienst at the microsoft terminator project
16:48:36 <revenantphafk> For brainfuck I'd think it would be possible.
16:48:42 <copumpkin> geheimdienst: or agda
16:48:51 <Cale> j-invariant: Obviously the best you're going to be able to do is to say "I don't know" most of the time.
16:48:56 * geheimdienst points copumpkin at skynet's terminator projects
16:48:58 <j-invariant> Cale: like a way to denest the fixed points (loops)?
16:49:04 <revenantphafk> the only things in brainfuck that could cause infinite-ness is [ ]
16:49:05 <degaus> I think it just may be the case that #haskell are a bunch of dumbasses. This man j-invariant claimed so. We must encourage free speech and dissenting opinions. That is including and good for any community
16:49:07 <Makoryu> j-invariant: checker xs | '[' `elem` xs = Nothing | otherwise = Just True
16:49:07 <Axman6> j-invariant: how does it not have anything to do with the halting problem? you're asking for a program which can take another program as input, and tell you whether it halts or not. this is the halting problem
16:49:31 <monochrom> geheimdienst: http://research.microsoft.com/en-us/um/cambridge/projects/terminator/papers.htm
16:49:50 <degaus> j-invariant: why is #haskell stupid?
16:49:54 <Eduard_Munteanu> To be fair "halting problem" refers to Turing machines and Turing-complete languages explicitly
16:49:58 <Cale> j-invariant: The hard part is that brainfuck programs are not very structured to begin with, so recovering that structure to be able to prove that the program is really doing something like structural recursion over a natural number is hard.
16:50:04 <revenantphafk> Alright guys, its 8PM EST
16:50:09 <revenantphafk> Given that we're all dumbfucks,
16:50:20 <revenantphafk> it's time to get shitfaced and talk about football.
16:50:23 <degaus> no we must know more
16:50:24 <revenantphafk> Who's with me?
16:50:30 <j-invariant> yes
16:50:34 <ddarius> revenantphafk: My alcohol is with copumpkin.
16:50:42 <Cale> I think that j-invariant is not asking for a total termination checker. Just one that does an okay job of picking out programs which "obviously" terminate.
16:50:44 <Axman6> revenantphafk: as long as it's football, and not come american non-sense
16:50:47 <Cale> and sometimes can't decide
16:50:50 <copumpkin> lol
16:50:59 <Axman6> some*
16:51:05 <copumpkin> ddarius: holding it hostage until I get a nice categorical database library
16:51:10 <ddarius> copumpkin: I vote if you still want to kickban someone, degaus seems to be packed full of lack of content.
16:51:13 <revenantphafk> Cale: I'd think brainfuck would be relatively easy to do so for, as long as ',' isn't involved.
16:51:25 <ddarius> copumpkin: "Library"?
16:51:25 <revenantphafk> In other words, as long as user input is used and it's deterministic, it's all cool.
16:51:30 <revenantphafk> isn't used*
16:51:57 <degaus> I hear Haskell is more popular than C++ these days
16:52:00 <copumpkin> ddarius: well, something like sqlite that I can embed and possibly make a network-facing front-end
16:52:06 <degaus> More used in industry as well
16:52:23 <ddarius> copumpkin: I guess I could start with an in-memory one to take out one layer of complication.
16:52:25 <j-invariant> maybe I should de-compile brainfuck to C and find something someone has already written
16:52:31 <Cale> degaus: Well, it's cooler. I hope it's not as popular. That would mean that we're really failing.
16:52:47 <Cale> degaus: I'm using it exclusively for my job.
16:52:47 <degaus> it must be more popular
16:52:59 <degaus> because dons never talks about anything else
16:53:10 <Cale> That doesn't follow.
16:53:23 <degaus> of course it does
16:53:33 <Eduard_Munteanu> We already failed considering H' only had the guts to remove n+k instead of reworking the Prelude and other parts of the language :P
16:53:38 --- mode: ChanServ set +o monochrom
16:53:50 --- mode: monochrom set +b *!*@gateway/web/freenode/ip.80.212.72.208
16:53:57 <revenantphafk> death to n+k!
16:54:00 --- mode: monochrom set -o monochrom
16:54:05 <revenantphafk> wait what?
16:54:07 <ddarius> revenantphafk: They're dead.
16:54:19 <Cale> I think that even with the obvious trolling, the ban was a bit unnecessary. Oh well.
16:54:28 <geheimdienst> i'm with cale
16:54:31 <revenantphafk> Now I'm left wondering.
16:54:35 <Axman6> me too
16:54:41 <revenantphafk> Have I been in here long enough to get away with trolling?
16:54:48 <monochrom> you're welcome to continue your informative session with degaus in PM
16:54:55 * ddarius doesn't care about "trolling," he cares about noise and lack of content.
16:54:57 <geheimdienst> we did *let* ourselves be trolled to some extent, instead of staying calm
16:55:14 * ddarius 's cool never slipped.
16:55:54 <revenantphafk> http://cl.ly/4CD7
16:55:55 <revenantphafk> noise?
16:56:14 * ddarius uses wavelet noise.
16:56:16 <ddarius> It's easier to control.
16:56:21 <revenantphafk> Hey guys, any physics buffs in here?
16:56:24 <ddarius> (and faster to calculate)
16:56:34 <revenantphafk> Oh ddarius, I just realized.
16:56:38 <revenantphafk> I haven't seen you in a while
16:56:40 <revenantphafk> what's nu?
16:56:43 <revenantphafk> v over lambda :D
16:56:45 * Axman6 takes advantage of physics all the time!
16:56:52 <revenantphafk> *ba dum KISH*
16:57:00 <Eduard_Munteanu> Erm, frequency?
16:57:05 <revenantphafk> yeah.
16:57:07 <revenantphafk> nu is frequency
16:57:31 <Eduard_Munteanu> It's quite common notation.
16:57:55 <monochrom> in fact brainstorming on improving semidecision procedures for the halting problem is infinitely more informative and productive than "does not" "does too" exchanges
16:58:14 <ddarius> monochrom: Except that there are no Turing machines.
16:58:21 <revenantphafk> are too.
16:58:26 <Eduard_Munteanu> are not
16:58:29 <revenantphafk> are too.
16:58:52 <revenantphafk> I keep hoping for a "D2!" response. I'm just not getting it here am I.
16:59:15 <copumpkin> Saizan: you around?
16:59:36 <dark> <j-invariant> Any tips on brainfuck termination checker < the brainfuck spec i know limits the memory to 30k cells
16:59:40 <monochrom> I'm pretty sure when j-invariant said "not about turing machines" he/she didn't mean it. just slipped due to frustration. you people have not been nice either.
16:59:41 <Saizan> copumpkin: yup
16:59:55 <copumpkin> <command line>: cannot satisfy -package Cabal-1.10.0.0: 
16:59:56 <copumpkin>     Cabal-1.10.0.0-ab868743015a1db3c692d5fb2d4abe2d is unusable due to missing or recursive dependencies:
16:59:56 <copumpkin>       process-1.0.1.4-2a42745dbb9dd3c8087608f127411124
16:59:56 <copumpkin> :(
17:00:11 <dark> you can check if the memory usage is cyclic, but you have also to require that it does not do any read from the keyboard (because it would mean infinite memory)
17:00:18 <j-invariant> dark: well you can use 8-bit or infinite yeah
17:00:29 <dark> the naive algorithm would require a lot of memory anyhow o.o
17:00:41 <j-invariant> dark: both are turing machines, some tricks work on the 8-bit case for loops but the program is still too difficult to approah
17:00:47 <Eduard_Munteanu> Nah, that's just a heuristic.
17:01:02 <Saizan> copumpkin: can you pass -package-id Cabal-1.10.0.0-ab868743015a1db3c692d5fb2d4abe2d ?
17:01:03 <copumpkin> Saizan: any ideas? it's a brand new install of GHC with a fresh .cabal and .ghc
17:01:18 <dark> a "turing machine" with bounded memory ceases to be a turing machine, and becomes a simple finite state machine
17:01:19 <Saizan> copumpkin: ah, that's weird
17:01:20 <Axman6> welcome to GHC upgrades :(
17:01:20 <Eduard_Munteanu> It's probably not that uncommon to have loops that never write outside of the alloted space.
17:01:29 <Eduard_Munteanu> s/write/r\/w/
17:01:33 <Saizan> copumpkin: can you paste ghc-pkg list ?
17:01:43 <j-invariant> brainfuck with 8-bit cells is still a turing machine
17:01:56 <copumpkin> Saizan: http://hpaste.org/43314/fuck
17:01:57 <j-invariant> even with an infinite [Bool] tape its still turing complete
17:02:00 <Saizan> copumpkin: and/or the output of ghci -v -package Cabal-1.10.0.0
17:02:09 <dark> with a infinite tape it is turing complete
17:02:11 <mun> in first-order logic, if i want to express that for all x that's greater than 0 and all y greater than x, the gradient at f(x,y) is 0, is this the formulation? ALL x. x > 0 --> (ALL y. y > x --> gradient(f, x, y) = 0), assuming there's a function called gradient here.
17:02:12 <j-invariant> and even if it was subturing a practical algorithm is still difficult to wrie
17:02:24 <mun> do i need 2 implications?
17:02:30 <copumpkin> Saizan: http://hpaste.org/paste/43314/fuck_annotation#p43315
17:02:59 <ddarius> mun: You don't need two.
17:03:03 <Saizan> copumpkin: so you've two process-1.0.1.4 for some reason
17:03:04 <ddarius> mun: But that works.
17:03:11 <mun> ddarius, what would be a better way?
17:03:21 <copumpkin> the context is that I had 7.0.1, then used it to build GHC head, then installed GHC head and used cabal on that for a while, then encountered the same issue. Screwed around for a while, eventually gave up and cleared out my entire GHC install and .cabal and .ghc
17:03:26 <copumpkin> so reinstalled, and got this again
17:03:51 <copumpkin> Saizan: oh, that thing :/
17:03:55 <mun> ddarius, would something like this work? ALL x y. (x > 0 & y > x) --> gradient(f,x,y) = 0?
17:03:57 <ddarius> mun: You could write it as: forall x, y. x > 0 /\ y > x => gradient(f, x, y) = 0
17:04:03 <copumpkin> gah, can't cabal just be smart and ignore duplicate versions? :P
17:04:04 <Eduard_Munteanu> forall x. y. x > 0 && y > x -> grad(f, x, y) = 0
17:04:52 <monochrom> (P -> (Q -> R)) is ((P & Q) -> R).
17:05:09 <dcoutts> copumpkin: this is because the current cabal-install dep resolver does not understand the concept of multiple instances of the same version of a package
17:05:21 <ddarius> monochrom: You also need P -> x.Q(x) <=> x.P -> Q(x)
17:05:21 <mun> ddarius, Eduard_Munteanu: now looking at it, is the antecdent consistent if the domain was integers? 
17:05:22 <Saizan> here it's ghc complaining though :)
17:05:32 <dcoutts> copumpkin: we're currently working on a new resolver which amongst other things will grok that concept
17:05:37 <copumpkin> ah I see :)
17:05:38 <copumpkin> man
17:05:39 <monochrom> (ALL x. B -> (ALL y. C)) is (ALL x. ALL y. B -> C)
17:05:41 <Eduard_Munteanu> monochrom: is that a CH correspondent of uncurry?
17:05:46 <copumpkin> it just _reinstalled_ process-1.0.1.4
17:05:50 <copumpkin> after I unregistered it
17:05:52 <monochrom> I don't know.
17:05:55 <copumpkin> and then failed again, unsurprisingly
17:05:56 <Eduard_Munteanu> *is that also
17:06:00 <Saizan> copumpkin: wb
17:06:00 <monochrom> actually yes
17:06:09 <dark> j-invariant, if you disallow any kind of input from the keyboard, the naive algorithm for checking whether a bf program terminates is: represent each step of execution with a state. store the first state run the program. if any other state equals the first state, the program does not halt. (otherwise, keep trying; if it does not halt, it will surely halt before 2^33 steps)
17:06:10 <ddarius> mun: The transformation is completely independent of the actual propositions.
17:06:10 <dcoutts> copumpkin: see --dry-run -v, it's rebuilding it against a different version of some other dep
17:06:14 <Saizan> copumpkin: use -dry-run -v to see why it tries to
17:06:18 <copumpkin> lol
17:06:22 <copumpkin> @quote stereo
17:06:23 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
17:06:25 <copumpkin> :(
17:06:46 <Saizan> the existence of that containers-0.3.0.0 seems a likely cause
17:06:49 <monochrom> \/
17:06:56 <mun> ddarius, sure. but then do you think ALL x y. (x > 0 & y > x) --> gradient(f,x,y) = 0 is actually consistent?
17:06:58 <ddarius> monochrom: Indeed, and the fact that  P -> x.Q(x) <=> x.P -> Q(x) comes from the cocontinuity of a right adjoint, namely the adjoint defined by curry/uncurry.
17:07:00 <Saizan> ..though process doesn't depend on containers
17:07:03 <ddarius> s/coc/c/
17:07:04 <j-invariant> dark: Ihave a feeling that would have too limited a scope and use too much memory to really be usefu
17:07:07 <j-invariant> ?
17:07:12 <copumpkin> gah, I was just trying to add simple primops to GHC :( http://hpaste.org/paste/43314/fuck_annotation#p43316
17:07:40 <Saizan> ah, it depends on filepath and directory though
17:07:47 <Eduard_Munteanu> Hah, I was marvelling at the possibility of a categorical dual of continuity.
17:08:05 <mun> ALL x y. x > 0 & y > x can't be consistent right (for integers).. say, x = 3, y = 1
17:08:06 <copumpkin> I don't see how this is happening on a brand-new install of GHC :/
17:08:10 <monochrom> which is cocontinuity. coconutility
17:08:13 <ddarius> mun: It is logically equivalent to your first statement.  It's as "consistent" as the first one is.  Beyond that, I don't know what you mean by "consistent" in this context.
17:08:51 <ddarius> Eduard_Munteanu: There is cocontinuity, but right adjoints don't necessarily preserve it.
17:08:52 <dark> j-invariant, yes (and actually, 2^30003 for 30000 cells of 8 bits)
17:08:55 <ddarius> Left adjoint do though.
17:09:01 <Eduard_Munteanu> Oh.
17:09:21 <Saizan> copumpkin: probably you've installed a package that has constrains requiring core packages of older versions, causing your old directory, containers, filepath in the userdb
17:09:30 <ddarius> mun: forall x, y. x > 0 /\ y > x is not the same statement as forall x, y. x > 0 && y > x => gradient(f, x, y) = 0
17:09:48 <copumpkin> Saizan: but I just cleared my userdb and the whole systemwide ghc
17:09:58 <copumpkin> I did cabal update to get a .cabal again
17:10:05 <copumpkin> then cabal install darcs was the first step
17:10:07 <copumpkin> and it led to this
17:10:16 * copumpkin screams
17:10:18 <copumpkin> :P
17:10:18 <Saizan> copumpkin: did you rm -fr ~/.ghc ?
17:10:21 <copumpkin> yeah
17:10:25 <ddarius> mun: Nor do I say what integers have to do with it.  3 and 1 could just as well be reals or naturals.
17:10:36 <Saizan> copumpkin: but ghc-pkg list --user has packages in it
17:10:45 * ddarius ran rm -rf.  Is that okay?
17:11:00 <copumpkin> Saizan: those are all the ones that it installed on the way to installing darcs
17:11:01 <Eduard_Munteanu> Supposedly they're part of a preorder at least.
17:11:04 <copumpkin> before that it had nothing
17:11:08 <dcoutts> copumpkin: the problem is that darcs is asking for an older version of a core package
17:11:15 <Eduard_Munteanu> But that's implied by the use of '>'
17:11:21 <ddarius> Eduard_Munteanu: The notation suggests it, but does not require it.
17:11:22 <copumpkin> dcoutts: oh :(
17:11:24 <dcoutts> copumpkin: which then leads to the situation where cabal barfs
17:11:27 <dolio> Eduard_Munteanu: Continuous functors preserve categorical limits. But limits have duals, colimits, so there's a dual property for preserving those.
17:11:32 <monochrom> it's better to fix the universe as the integers for convenience and not go too general
17:11:33 <mun> ddarius, ok, so if i used the implication, i only assert that gradient(f,x,y) = 0 if x and y exhibit the property expressed in the antecedent. is that the way to think of it?
17:11:40 <Saizan> copumpkin: ok, so s/you installed/you are installing/ in my previous sentence :)
17:11:46 <copumpkin> I see
17:11:51 <ddarius> mun: Yes.
17:11:56 <ddarius> false => true is true.
17:11:57 <copumpkin> so the solution is to fix the darcs .cabal ?
17:12:10 <dcoutts> copumpkin: yes, and use --dry-run to check it looks sensible
17:12:18 <copumpkin> the issue is containers?
17:12:21 <copumpkin> the core package you mentioned
17:12:24 <Eduard_Munteanu> forall p. false -> p   is a true theorem whatever 'p'
17:12:33 <mun> ddarius, well, not quite .. if x and y exhibit the property, but *only if* x and y exhibit the property.
17:12:35 <ddarius> monochrom: How are converging Cauchy sequences too general?
17:12:43 <mun> or is it *if*?
17:12:47 <Saizan> copumpkin: filepath and directory matter more for process
17:12:47 <gienah> comukin: lispy was working on conditional compilation stuff for ghc 7 in the darcs.cabal
17:12:50 <Eduard_Munteanu> mun: it is 'if'
17:12:51 <copumpkin> hm
17:12:56 <mun> ok
17:13:06 <monochrom> just "if".
17:13:19 <monochrom> "only if" is something else.
17:13:19 <Eduard_Munteanu> '->' is implication, so it translates into a 'if ... then ...'
17:13:24 <ddarius> mun: I recommend reading a book or something on first order logic and some basic set theory too to boot.
17:13:28 <Saizan> copumpkin: another solution is to install a process with a bumped version against the old directory and filepath that you've there
17:13:55 <JoeyA> What is the logic analogue of the concept of currying?
17:13:58 <ddarius> @google fym first year mathematics
17:13:59 <lambdabot> http://math.asu.edu/fym/index.html
17:13:59 <lambdabot> Title: First-Year Math | School of Mathematical & Statistical Sciences
17:14:13 <ddarius> JoeyA: The law monochrom (and several others) mentioned above.
17:14:24 <ddarius> JoeyA: Basically just look at the type.
17:14:30 <Eduard_Munteanu> 03:15 < monochrom> (P -> (Q -> R)) is ((P & Q) -> R).
17:14:36 <Eduard_Munteanu> 'is' is an equivalence there
17:15:11 <gienah> copumpkin: lispy was working on conditional compilation stuff for ghc 7 in the darcs.cabal, maybe try the darcs darcs
17:15:22 <copumpkin> gienah: ah, cool
17:15:23 <copumpkin> thanks
17:15:44 <JoeyA> I mean, the axiom that (a  b) -> c  a -> (b -> c)
17:15:49 <JoeyA> What is this axiom called?
17:16:02 <JoeyA> In functional programming, it's currying.
17:16:12 <JoeyA> What's it called in logic?
17:16:13 <dolio> That isn't usually an axiom.
17:16:15 <RichardBarrell> "An exercise left to the reader" :)
17:16:15 <dolio> Is it?
17:16:21 <JoeyA> oh, my bad
17:16:22 <monochrom> My supervisor calls it "portation"
17:16:24 <JoeyA> theorem
17:16:33 <Eduard_Munteanu> :)
17:16:34 <JoeyA> s/axiom/theorem/
17:17:29 <ddarius> monochrom: So does Hehner.
17:17:45 <monochrom> my supervisor = Hehner
17:17:51 <JoeyA> One theorem that didn't occur to me until a few days ago is: a -> b -> c  b -> a -> c .  That's correct, right?
17:17:58 <Eduard_Munteanu> Heh
17:17:58 <JoeyA> (granted, they're different Haskell types)
17:18:11 <ddarius> monochrom: His naming is wildly uncommon.
17:18:23 <monochrom> a -> b -> c  (a & b) -> c  (b & a) -> c  b -> a -> c
17:18:36 <Axman6> Q.E.D yo
17:18:37 <JoeyA> > let implies False False = True; implies False True = True; implies True False = False; implies True True = True
17:18:37 <lambdabot>   not an expression: `let implies False False = True; implies False True = Tr...
17:18:54 <JoeyA> @let implies False False = True; implies False True = True; implies True False = False; implies True True = True
17:18:54 <j-invariant> let implies p q = not p || q
17:18:55 <lambdabot>  Defined.
17:18:57 <monochrom> you could use <= for implies
17:18:57 <ddarius> :t curry . (. swap) . uncurry
17:18:58 <lambdabot> Not in scope: `swap'
17:19:22 <ddarius> @let swap ~(x, y) = (y, x)
17:19:23 <lambdabot>  Defined.
17:19:24 <ddarius> :t curry . (. swap) . uncurry
17:19:25 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
17:19:25 <JoeyA> > [(a, b, a `implies` b) | a <- [False, True], b <- [False, True]]
17:19:26 <lambdabot>   [(False,False,True),(False,True,True),(True,False,False),(True,True,True)]
17:19:46 <monochrom> > [ x ++ " implies " ++ y ++ " is " ++ (x<=y) | x<-[False,True], y<-[False,True] ]
17:19:47 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
17:19:47 <lambdabot>         against inferred ty...
17:19:57 <monochrom> > [ show x ++ " implies " ++ show y ++ " is " ++ (x<=y) | x<-[False,True], y<-[False,True] ]
17:19:58 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
17:19:58 <lambdabot>         against inferred ty...
17:20:03 <monochrom> > [ show x ++ " implies " ++ show y ++ " is " ++ show (x<=y) | x<-[False,True], y<-[False,True] ]
17:20:05 <lambdabot>   ["False implies False is True","False implies True is True","True implies F...
17:20:36 <JoeyA> True implies F...  You got tat right, lambdabot
17:20:37 <monochrom> you can get the rest if you re-do that in PM
17:21:01 <monochrom> well it hasn't finished. True implies False is False.
17:21:21 <Eduard_Munteanu> > drop 2 [ show x ++ " implies " ++ show y ++ " is " ++ show (x<=y) | x<-[False,True], y<-[False,True] ]
17:21:23 <lambdabot>   ["True implies False is False","True implies True is True"]
17:21:42 <JoeyA> So, let me get this straight: <= on Bool is equivalent to implication because of the ordering?
17:21:48 <monochrom> yes
17:21:50 <JoeyA> In Haskell, a <= b means a implies b
17:21:51 <JoeyA> How logical!
17:22:10 <ddarius> JoeyA: Not just Haskell.
17:22:14 <JoeyA> I know.
17:22:27 <j-invariant> The TERMINATOR research project is focused on the development of automatic methods for proving program termination and general liveness properties
17:22:27 <Axman6> i don;t think it does in C though...
17:22:32 <ddarius> JoeyA: Now find yourself the xor function on Bools.
17:22:33 <JoeyA> C, C, wonderful C, the more you C, the more you pee.
17:22:39 <JoeyA> okay, ban me now.
17:22:39 <lispy> copumpkin: the way I did it in darcs.cabal is not optimal
17:22:39 <Philonous> "False implies True is True" That's a rather unfortunate formulation
17:22:51 <copumpkin> I'm just going to settle for installing darcs under 6.12
17:22:57 <Axman6> Philonous: hmm?
17:22:59 <lispy> copumpkin: there is a weirdly name macro that cabal makes that is actually a bit simplier to use
17:23:12 <lispy> copumpkin: hmm...2.5.1 should be on hackage
17:23:19 <lispy> copumpkin: and 2.5.1 should work on ghc 7
17:23:20 <Axman6> copumpkin: might be worth looking into use cabal-dev for this GHC stuff you're working on
17:23:22 <Philonous> Axman6: You could read it as "(False implies True) is True"
17:23:38 <Axman6> Philonous: is it true
17:23:40 <ddarius> Axman6: It isn't necessarily true.  0 < 1 certainly but 0 > -1.
17:23:42 <Philonous> Axman6: Oh wait
17:23:48 <lispy> copumpkin: oh wow.  It's still unreleased.  I submitted patches like last month
17:23:52 <dankna> is it me or is the GHC build process faster than it used to be?  this pleases me, even if it's just my perception.
17:24:06 <ddarius> Philonous: That's how it is supposed to be read.
17:24:19 * copumpkin leaves dankna in a pleased state
17:24:25 <dankna> hahaha
17:24:34 * lispy goes back to work
17:24:39 <ddarius> dankna: It's far, far faster than in the 5.4.3 days.
17:24:43 <dolio> It's definitely faster depending on how far you go back.
17:24:50 <dankna> well, that's good to know
17:24:59 <dankna> I was thinking in terms of going back to about 6.10ish
17:25:13 <dankna> which is probably not so significant then
17:25:23 <dankna> as it was post the great Makefile re-architecting
17:25:54 <Eduard_Munteanu> I remember it took ages on 6.6 or so.
17:25:58 * dankna nods
17:26:02 <Philonous> Axman6: Anyhow, you could also read "True implies (True is True)", but it is still true in all cases. So never mind
17:27:20 <Axman6> :)
17:27:53 <ludflu> are there simple examples of vector arithmetic using the vector-space library? I sort of rolled my own because I couldn't find any I could understand, http://hpaste.org/43317/angle_between I'm looking for suggestions
17:28:33 <dankna> "the angle between two angles" is a futzy concept
17:28:41 <dankna> I've been bitten by misunderstandings with that before
17:28:55 <dankna> for example, what is the angle between +10 degrees and -10 degrees?  340 or 20 or -20?
17:29:08 <ludflu> what its intended is the angle between two vectors, not two angles
17:29:10 <roconnor> ludflu: FWTW, I find converting to angle not all that useful
17:29:23 <dankna> oh okay, that's clear enough then
17:29:30 <roconnor> ludflu: Using the spread is generally all you need
17:29:35 <azaq23> > let x ==> y = not x || y in False ==> True
17:29:36 <lambdabot>   True
17:29:39 * ddarius considers how much of a hassle it is to walk to the Burger King.
17:29:53 <ddarius> copumpkin: Unless you want to go to some restaurant before it snows (again).
17:30:06 <monochrom> http://www.mail-archive.com/haskell-cafe@haskell.org/msg80990.html
17:30:23 <ludflu> roconnor: not familiar with spread. what's that?
17:30:28 <ddarius> @google rational trigonometry
17:30:30 <lambdabot> http://en.wikipedia.org/wiki/Rational_trigonometry
17:30:30 <lambdabot> Title: Rational trigonometry - Wikipedia, the free encyclopedia
17:30:34 <peoro> @src unlines
17:30:34 <lambdabot> unlines = concatMap (++ "\n")
17:30:36 <ddarius> Curse you Wikipedia.
17:30:58 <ddarius> Oh well.  It has Wildberger in the first sentence.
17:31:03 * hackagebot comonad-transformers 0.9.0 - Haskell 98 comonad transformers  http://hackage.haskell.org/package/comonad-transformers-0.9.0 (EdwardKmett)
17:31:06 <roconnor> ludflu: the spread of an angle theta is the square of the sine of the angle.
17:31:25 <ludflu> awesome, thanks
17:31:45 <ddarius> Ah, roconnor is also familiar with Wildberger's work.
17:31:53 * ddarius didn't even notice roconnor's responses.
17:32:34 <roconnor> I also use unit complex numbers to represent angles on some occasions
17:32:37 <ddarius> Wildberger is one of those lovable crazy mathematicians.  Like Zeilberger.
17:32:39 * ddarius notices a trend.
17:32:53 * Eduard_Munteanu thought it was a pun on Zeilberger.
17:32:55 <roconnor> but actual angles are really hard to work with
17:32:55 <ddarius> roconnor: I use rotors to represent angles in almost all equations.
17:33:31 <roconnor> ddarius: isn't that the square root of my complex number?
17:33:32 <pumpkin> aaaaaaarggghhhh
17:33:48 <roconnor> ludflu: are you working in 2-D or higher-D?
17:34:20 <ddarius> roconnor: No.
17:34:42 <ddarius> It -is- your complex number in 2D.
17:34:49 <geheimdienst> pumpkin: here, have this http://www.youtube.com/watch?v=SXpgvsllTgs
17:34:56 <ddarius> roconnor: Er, yes.
17:35:02 <ddarius> I guess it is the square root.
17:35:03 * roconnor wins!
17:35:20 <ddarius> However, you can use the one-sided, non-square root version in 2D.
17:35:53 <roconnor> only because multiplication is commutative
17:35:57 <roconnor> pfft
17:36:01 <roconnor> commutativity
17:36:13 <ddarius> roconnor: I'm certainly no believer in commutativity.
17:36:30 <ddarius> Don't miss Wildberger's ultrafinitist ran- articles.
17:36:45 * ddarius wants to plot SO(3).
17:36:58 <roconnor> judging from ludflu's code he is doing 2-D
17:37:08 <roconnor> @quote ultrafinit
17:37:08 <lambdabot> roconnor says: I have a proof that Ultrafinitism is inconsistent, but the universe is too narrow to contain it.
17:37:12 <ludflu> Iroconnor: I'm just working in two dimensions. the vectors come from lines output by openCV's hough transform
17:37:15 <pumpkin> ddarius: oh, can't make it tonight :/
17:37:55 <ludflu> roconnor: I'm trying to determine if two sets of lines are "approximately" the same line, in which case I will merge them
17:38:15 <ludflu> cosine similarity was suggested as a good metric for comaring
17:38:16 <roconnor> that sounds error prone :)
17:38:52 <ludflu> I think most computer vision is. (although I'd love to hear a better way)
17:40:34 <ddarius> There's surely some GA + CV stuff.
17:41:02 <ludflu> ddarious: ga = genetic algo ?
17:42:44 <ludflu> genetic algo is definitely an approach I did not consider. but now that you mention it, training would be easy since I can generate the image from a vector representation, so the fitness function would be pretty easy
17:42:48 <fotanus> hey... There is a way to filter an list with itens <5 and >3 without use lambda? 
17:43:34 <Axman6> yes, let foo = filter f where f x = x < 5 && x > 3. a lambda is just an anonymous version of that
17:43:49 <ddarius> ludflu: Hell no.  Geometric Algebra.
17:43:49 <roconnor> > filter (liftM2 (&&) (>3) (<5)) [1..10]
17:43:50 <lambdabot>   [4]
17:44:28 * roconnor tries to think of an infix way of saying that
17:44:36 <geheimdienst> > filter (< 5) $ filter (> 3) [1..10]
17:44:37 <lambdabot>   [4]
17:44:39 <ludflu> ddarius: yes, that makes more sense
17:44:55 <djahandarie> > (liftM2 (&&) (>3) (<7)) `filter` [1..10]
17:44:56 <lambdabot>   [4,5,6]
17:45:08 <djahandarie> ... except I typed it wrong
17:45:11 <roconnor> >:(
17:45:42 <fotanus> thank you for all answers. Let me try theses...
17:45:45 <geheimdienst> @pl (liftM2 (&&) (>3) (<5))
17:45:45 <lambdabot> liftM2 (&&) (> 3) (< 5)
17:45:59 <djahandarie> geheimdienst...
17:46:20 <ddarius> > let (-|) = flip ($); (|-) = id in filter ((>3) -| liftM2 (&&) |- (<5)) [1..10]
17:46:22 <lambdabot>   [4]
17:46:22 <roconnor> at your service?
17:46:26 <roconnor> something service.
17:46:38 <Saizan> what is the definition of "fibration" in CT?
17:46:49 <roconnor> Saizan: I dependent type :P
17:46:54 <geheimdienst> yeah, it is pointless already. i hoped it would come up with some (((< 3) .) . (&&) stuff or something
17:46:55 <roconnor> s/I/A
17:46:58 <ddarius> roconnor: No.
17:47:06 <ludflu> roconnor & ddarius: thanks for your suggestions.
17:47:51 <Saizan> i've gathered that something like A -> Set is an instance of it
17:48:04 <roconnor> Saizan: a famility of types dependent on a parameter
17:48:18 <roconnor> ddarius: which is a dependent type.
17:48:19 <roconnor> :D
17:48:39 <Saizan> but if i don't know how fibration generalizes that it's hard to follow the sections where "let's generalize over an arbitrary fibration to cover more esotic constructions"
17:49:03 <ddarius> roconnor: I'm "reading" a paper right now that switches from dependent types to fibrations to generalize.
17:49:26 <gwern> Saizan: oh, it's easy, you just imagine an n-dimensional fibration and then set the n to whatever your generalized fibration is
17:49:38 * ddarius flips through his little black book to find a compact and completely opaque definition.
17:49:44 <roconnor> really,  I thought a fibration was an interpretation of dependent types, which suggests it is a specialization.
17:50:00 <roconnor> ... grantend things have a way in math of being both a generalization and a specialization at the same time.
17:50:40 <ddarius> roconnor: In his thesis, Bart Jacobs defines comprehension categories to deal with dependent types.
17:51:08 <ddarius> Fibrations are just a way of dealing with "contexts" in general.  There's no need for "dependent types" though they are, of course, relevant to dependent types.
17:51:48 <roconnor> ddarius: in these Univalent Foundations talks they interpret dependent types as fibrations.
17:52:04 <mun> is ALL f g x. f x = g x --> f = g same as ALL f g. (ALL x. f x = g x --> f = g)?
17:52:13 <mun> same, as in equivalent
17:52:34 <roconnor> mun: yes
17:52:36 <Saizan> i guess that's a bit like you can interpret lambda calculus as the internal language of a CCC? that doens't mean all CCC are made of computable functions etc..
17:52:37 <monochrom> no
17:52:48 <ddarius> roconnor: Interpreting dependent types as fibrations doesn't make fibrations dependent types.
17:52:51 <monochrom> err, yes.
17:52:54 <roconnor> mun: same way that a -> b -> c is equivalent to a -> (b -> c)
17:53:18 <monochrom> actually there is only one -> there
17:53:23 <ddarius> Bart Jacob's also interprets dependent types as fibrations, as well as STLC, untyped LC, and polymorphic LC, and others.
17:53:42 <mun> thus, equivalent to ALL f g. (ALL x. f x = g x) --> f = g as well
17:53:43 <mun> ?
17:53:47 <roconnor> ddarius: it does if I use the language of Martin Loef type theory to write my math doesn't it?
17:53:48 <monochrom> you're looking at (ALL f g x. P) and (ALL f g. (ALL x. P))
17:54:05 <roconnor> mun: no
17:54:13 <monochrom> but no, not the same as (ALL f g. (ALL x. f x = g x) --> f = g)
17:54:23 <roconnor> mun: same way (a -> b) -> c isn't the same as (a -> b -> c)
17:54:33 <Rotaerk> what is that syntax?
17:54:38 * djahandarie wonders why people aren't just using forall instead of ALL
17:54:41 <ddarius> Ah, here it is.
17:54:50 <Philippa_> roconnor: would something like a potential field be a fibration? (I'm clearly not operating at my most abstract today...)
17:55:13 <monochrom> I should just write "all".
17:55:23 <roconnor> Philippa_: vector bundles are an instance of fibrations.
17:55:58 <mun> roconnor, what's this relationship called between implication and universal quantification?
17:55:59 <roconnor> (says the guy who doesn't "know" what a fibration is)
17:56:41 <roconnor> mun: implication is arguably a special case of universal quantification.
17:56:42 <ddarius> p : E -> B is a fibration if U : E^(->) -> (Id, P) where Uf = (p(dom f), pf, cod f) is a right-adjoint left-inverse.
17:56:55 <Philippa_> roconnor: so, "yes, but a really boring one"?
17:57:19 <Saizan> ddarius: s/P/p/ ?
17:57:21 <mun> roconnor, how come?
17:57:26 <roconnor> Philippa_: I don't know about that.  I like vector bundles.
17:57:27 <ddarius> Saizan: Er, yes.
17:57:53 <roconnor> mun: because both can be interpreted as types that behave like functions.
17:57:57 <djahandarie> What is E^(->) ?
17:58:08 * djahandarie is annoyed about how impossible this stuff is to Google
17:58:30 <Philippa_> roconnor: heh. Yeah, YKWIM though? Just at some point I should figure out what proportion of my intuitions carry through how far - if nothing else, find out how general/abstract my sense of 'internal kinaesthetics' is...
17:58:52 <Saizan> E^(->) is the arrow category of E
17:58:56 <ddarius> djahandarie: The arrow category of E.
17:59:00 <ddarius> Often also written E^2
17:59:04 <Philippa_> (it'd really, really figure if it turns out the answer is "very, and that's why it's not rigged to do newtonian mechanics well")
17:59:06 <djahandarie> Thanks
17:59:08 <ddarius> (Which is actually how I have it in my notes.)
17:59:22 * ddarius should show pumpkin his little black book.
17:59:28 <ddarius> It's completely insane.
17:59:39 <roconnor> Philippa_: I don't really know what a fibration is.  AFAIK it behaves just like a dependent type.
18:00:13 <roconnor> I don't understand ddarius's answer, but it is presumably more "accurate"
18:00:38 <Philippa_> roconnor: yeah, fair enough. And you're already poking a level above the range of abstractions I'm really familiar with myself, I always figure most people here'd be amazed if they knew just how lousy my mathematical knowledge is
18:00:39 <ddarius> roconnor: Personally, I just think of fibrations as ways of handling "contexts."
18:00:42 <Philippa_> (ddarius less so!)
18:00:51 <monochrom> roconnor: I don't like this. The pedagogical order (IMO anyway) should be: learn implication, learn forall, some time later, learn category theory or type theory and see relations. Not: learn category theory or type theory, then learn implication and forall.
18:00:55 <ddarius> Bart Jacob's thesis is pretty clear on this.
18:01:00 <djahandarie> ddarius, wouldn't that just be the functor category of E in this case?
18:01:07 <geheimdienst> Philippa_: not as lousy as mine!
18:01:08 <djahandarie> (The arrow category of E)
18:01:10 * geheimdienst topped her
18:01:11 <ddarius> (Not to be confused with "Bart Jacobs' thesis is pretty clear.")
18:01:16 <geheimdienst> ;)
18:01:18 <roconnor> ddarius: aren't dependent types just a way of handling "contexts"?
18:01:25 <ddarius> roconnor: No.
18:01:34 <roconnor> as in the category of contexts
18:01:38 <ddarius> Dependent types require more refined context handling.  They are not about handling contexts.
18:02:30 <djahandarie> Funct({0 -> 1}, E)
18:02:33 <Rotaerk> I just had a realization about F#; curious if it's also true of haskell
18:02:55 <Rotaerk> an operator is just another kind of identifier.. as such you can use them as parameter names:  let f ((<>>): int -> int -> int) = 5 <>> 6
18:03:10 <monochrom> holds for haskell too
18:03:15 <Rotaerk> ah
18:03:22 <ddarius> > let f (<>>) = 5 <>> 6 in f (-)
18:03:23 <lambdabot>   -1
18:03:25 <roconnor> monochrom: I'd be inclined to teach type theory and then teach implication and forall. ... when I run the CS logic course at my university, that is what will happen.
18:03:56 * ddarius recommends teaching fibrations first so you aren't forced to have pairs in your STLC.
18:03:57 <monochrom> concrete before abstract. special before general.
18:04:38 <dolio> roconnor: A fibration is a functor p : E -> B, where every f : X -> Y in B has a Cartesian lifting. In terms of dependent types, that means that if you have f : I -> J, and a family F(j), there's a family G(i) = { j = f i | F(j) }.
18:04:52 <roconnor> monochrom: CS students are already familiar with functions and sort of familiar with types already.
18:05:07 <monochrom> you're essentially planning to teach category theory at kindergarten, universal algebra at primary and secondary school, rings and fields at undergrad, and finally integers for phd students.
18:05:18 <dolio> F(j) and G(i) being objects of E, and I and J objects of B.
18:05:33 <geheimdienst> monochrom: great way of putting it, kudos
18:05:46 <dolio> Except, more category-y.
18:06:08 <djahandarie> I wonder what the most category-theoretic way to define integers is
18:06:25 * djahandarie imagines a "the evolution of a category theorist" document
18:06:33 <edwardk1> djahandarie: hah
18:06:38 <j-invariant> I don't think "category theorist" is a real thing
18:06:39 <roconnor> dolio: isn't G just equal to (F . f) ?
18:06:40 <dolio> Oh, and the lifting of f is a morphism h : G(i) -> F(j) such that ph = f.
18:07:03 <Saizan> ah, i was wondering why p wasn't mentioned again :)
18:07:19 <djahandarie> Apparently edwardk found that so funny he quit and started working on it immediately
18:07:19 <monochrom> if your students are fluent with first-order logic, there is no need to cover it after type theory. and if your students aren't fluent with first-order logic, you have to fix that first before any exposition on type theory makes sense.
18:07:23 <Philippa_> j-invariant: in the philosophical sense, or just in the sense that eg topologist is?
18:07:51 <roconnor> monochrom: I think that isn't true.  But I have no evidence to back up my claim.
18:08:14 <dolio> roconnor: If you're working with dependent types, and families behave like functions I -> Set, then yes.
18:08:17 <monochrom> any exposition on type theory requires the audience to be logical to begin with.
18:08:31 * ddarius switched his left and rights, and so it is U has a right adjoint right inverse.
18:08:40 <roconnor> dolio: famlies do behave kinda like that in type theory.
18:08:59 <joe6> Prelude System.IO> localeEncoding = ANSI_X3.4-1968
18:09:09 <joe6> does this locale support UTF-8?
18:09:16 <j-invariant> Philippa_: both
18:09:17 <monochrom> and I don't even mean the content of type theory itself such as "what is ->". I mean the meta-logic used in the exposition. "Theorem: For any type T, if T satisfies ... then T satisfies ..."
18:09:20 <dolio> Depends on the type theory.
18:09:20 <ddarius> dolio: The family fibration is but one fibration.
18:09:35 <dolio> Yes, I know.
18:10:25 <dolio> roconnor: The point is to keep this relatively abstract. The definition I gave you is just the sort of thing it's used for when modelling type theory.
18:10:34 <int80_h> I have something bound to type IO Curl, and I need it to be type Curl. How do I go about soing that? Do I use liftIO?
18:10:45 <int80_h> *doing
18:10:47 <Philippa_> j-invariant: the latter's just "practitioner of category theory", which is boring enough and obviously as extant (if not as popular) as something like topologist. I doubt anyone here can be arsed with the philosophical side for now
18:10:58 <ddarius> djahandarie: Coequalize the two obvious functors 1 -> 2 in the category of groupoids.
18:11:03 <roconnor> monochrom: by that logic no one can learn logic.
18:11:37 <Philippa_> roconnor: sure they can, just not all of it. Mustn't try to see all the turtles at once
18:11:56 <Philippa_> (also, y'know, not necessarily all /formally/)
18:12:03 <int80_h> anyone?
18:12:06 <peoro> wow, it's awesome how higher order functions and lambdas can replace RAII
18:12:12 <int80_h> is that a nonsense question I just asked?
18:12:47 <roconnor> I think if I sit down my students with a proof assistant they will learn the rules of logic and at the same time be engaged by the fact that their "proofs" are familiar executable structures.
18:12:48 <dolio> The real definition is that h : S -> T in E is Cartesian if for any g : X -> T in E, and commutative triangle ph . x = pg in B, there is an f : X -> S in E such that pf = x.
18:12:52 <geheimdienst> int80_h: could you do x <- yourCurlThing ?
18:12:52 <djahandarie> int80_h, you can't permanently take something out of IO.
18:13:08 <dolio> But that probably doesn't mean much without staring at diagrams for a while.
18:13:10 <geheimdienst> this only works in functions that themselves have type IO Something
18:13:15 <djahandarie> But if it eventually goes back into IO you can do whatever you want to it
18:13:19 <Philippa_> int80_h: um. I've seen you around long enough I don't expect you to be asking the beginner monad IO question - so just checking, you're not, right?
18:13:31 <djahandarie> Philippa_, yeah I was thinking the same thing...
18:14:03 <djahandarie> Or maybe that was intsomethingelse :P
18:14:07 <int80_h> Philippa_ : erm, I'm afraid I am. Should I go away and try to think instead?
18:14:36 <int80_h> I was thinking I needed a lift function.
18:14:46 <Philippa_> int80_h: do {x <- myIO_Curl; use x; useAgain x; return ...}
18:14:56 <dankna> no, haha, there are no stupid questions ("only inquisitive idiots", he said), absolutely it's fair to ask
18:14:57 <Philippa_> int80_h: but if that doesn't do what you want, yeah, thinking time
18:15:15 <ddarius> dolio: The functor that picks that f given g, called a cleavage, is the right adjoint right inverse.  The fact that pf = x is the right inverse part.
18:15:30 <Philippa_> you can use lift to shorten that some if use and useAgain are pure, yeah
18:15:38 <int80_h> <- worked!
18:15:40 <ddarius> (well part of the right inverse part)
18:15:59 <int80_h> I think I was thinking too much
18:16:09 <geheimdienst> int80_h: glad we could help. everyone has writer's block occasionally :)
18:16:09 <int80_h> <- is right
18:16:20 <monochrom> working with Coq or the like is not exactly "type theory first, fol after".
18:16:32 <djahandarie> int80_h, note that this is just the same as   myIO_Curl >>= (\x -> use x >> return)
18:16:32 <ddarius> roconnor: I recommend looking at the internal logic/language of fibrations in general.
18:16:33 <int80_h> this channel is awesome. I'm doing code for work as we speak
18:16:40 <djahandarie> "return ..." I mean
18:17:24 <int80_h> I was taking my toy code and tidying it up. That's when I started running into type errors. I was tempted to be sloppy and go back to my lazy code that worked but was wrong. Decided to figure out right way instead.
18:17:36 <astroboy> Two questions: 1) Is there a quick way to search for a function in the libraries installed on the system and 2) I can't find the X11 bindings to this: http://tronche.com/gui/x/xlib/utilities/XReadBitmapFile.html or anway a way to load bitmaps.
18:17:59 <roconnor> I don't know enough CT to recognise a right adjoint
18:18:05 <monochrom> Coq is simultaneously both. To students like me who find logic more concrete or familiar and type more abstract or alien, it is a case of "logic first, use it to boot up type"
18:18:05 <dolio> ddarius: The thing I've been reading seems to make effort to show that you don't necessarily need to work with cleavages (for modeling type theory).
18:18:15 <ddarius> dolio: You don't.
18:18:18 <dolio> Since it's more higher-categorically nice.
18:18:33 <roconnor> monochrom: I don't think most CS students are in that position.
18:18:37 <ddarius> dolio: Cleavages always can be constructed, but choosing one is arbitrary.
18:18:42 <byorgey> astroboy: you can use Hoogle to search for functions, although I don't know of a way to search specifically only through libraries installed on your system
18:18:43 <monochrom> And to other students who find type more concrete or familiar than logic, it is a case of "type first, use it to boot up logic"
18:18:54 <ddarius> That's why the definition of fibration merely states that a right adjoint right inverse exists.
18:19:02 <byorgey> astroboy: I don't know anything about the X11 bindings though.
18:19:08 <dolio> Okay. That's what I said, right?
18:19:13 <astroboy> byorgey: but will the local hoogle search in all the libraries?
18:19:19 <ddarius> dolio: I was agreeing with you.
18:19:20 <monochrom> But applying excluded middle and disjunction elimination, it is always "concrete first, abstract later".
18:19:22 <dolio> Okay.
18:19:37 <roconnor> monochrom: I still think it is type theory first and the FOL later, in that though the langauge Coq is both, they will presumably see the type theory interpetation first and won't pick up on the fact that it is logic until later.
18:20:11 <roconnor> monochrom: I agree with concrete first and abstract later.
18:20:17 <ddarius> -Split- cloven fibrations though, is crying "boo hoo hoo, I want a strict 2-category."
18:20:47 <byorgey> astroboy: it might, I've never tried running it locally
18:20:58 <astroboy> byorgey: ok, thanks.
18:21:11 <astroboy> byorgey: because reading foreign code is really a pain right now, and I do that a lot
18:21:17 <ddarius> The indexed category view of fibrations has a particular cleavage baked into it though.
18:21:20 <byorgey> I can imagine.
18:21:30 <Axman6> i don't suppose anyone knows if Jason Dagit is someone who frequents here?
18:21:37 <byorgey> Axman6: yes, lispy 
18:21:39 <ddarius> Axman6: He is.
18:21:44 <Axman6> ah, fantastic!
18:21:55 <geheimdienst> astroboy, i've heard that it's a little involved. you have to build a hoogle index for every library one by one and then somehow combine them ... something like that, iirc
18:21:56 <Axman6> lispy: ping
18:22:41 <byorgey> I apparently have a giant bidirectional map in my head from real names to IRC nicks
18:22:52 <byorgey> I don't know why my brain does this but it does come in handy.
18:22:53 <ddarius> byorgey: As do several people.
18:23:04 <dolio> ddarius: Incidentally, An Introduction to Fibrations, Topos Theory, the Effective Topos and Modest Sets, by Wesley Phoa seems decent so far, if you want something else to recommend to people.
18:23:04 <astroboy> geheimdienst: mhm, so how is it humanly possible to explore, to say, the X11 bindings?
18:23:10 <byorgey> ddarius: oh, I'm sure.
18:23:11 <ivanm> byorgey: you need a tridirectional one to take into account email addresses!
18:23:21 <ddarius> dolio: Phoa is a good name.
18:23:22 <byorgey> woah, let's not get crazy
18:23:26 <dolio> I don't know if it stays easier than Jacobs' thesis or not.
18:23:32 <Axman6> preflex: seen lispy 
18:23:33 <preflex>  lispy was last seen on #haskell 59 minutes ago, saying: * lispy goes back to work
18:23:42 <Axman6> bah!
18:23:43 <ddarius> dolio: Probably...  but Jacobs' book seemed more readable.
18:23:52 * ddarius points at @ask.
18:23:57 <pumpkin> ddarius: little black book?
18:24:02 <dolio> Yeah, but you can't get that for free, can you?
18:24:22 <byorgey> Axman6: it is 6:30 pm in his time zone, perhaps he'll come back if you wait a bit
18:24:32 <ddarius> pumpkin: That's what it's called.  It's a Mead Five Star Fat Lil' Notebook.
18:24:34 <geheimdienst> astroboy, also, a properly configured vim-haskellmode might let you hit a key when the cursor is on a function name, and jump to the file and place where the function is defined
18:24:54 <Axman6> byorgey: i've been working on this problem for a day or two, i can wait a little linger :)
18:24:58 <Axman6> longer*
18:25:01 <ddarius> dolio: The book, no, or at least not legally.  The prospectus is an okay overview though.
18:25:05 <byorgey> ok =)
18:25:08 <astroboy> geheimdienst: emacs has the same, but it doesn't do it for all the functions, but just for the standard library
18:25:11 <geheimdienst> that should help somewhat with reading. also, you are aware of the buttons "contents" and "index" on the haddock pages, right?
18:25:29 <astroboy> geheimdienst: yes I am, but it's still a pain
18:25:37 <astroboy> I'd like to have something that index my local libraries
18:25:43 <ddarius> pumpkin: It's a notebook filled with knowledge about the most eclectic set of things that's been accumulating crap since 2002.
18:26:10 <ddarius> pumpkin: It's also about the size of 200 3x5 cards and so it takes some doing to fit nine years of crap into it.
18:26:10 <geheimdienst> i dunno emacs, but i'm sure someone can help you configure it so that it knows to jump into the sources in ~/.cabal/
18:26:22 <ddarius> (With a decent amount of space still available.)
18:26:26 <ivanm> astroboy: if you're wanting stuff within the same file, you can set that up in emacs
18:26:27 <ddarius> I'll be sad when it is full.
18:26:32 <astroboy> geheimdienst: I already asked, but with no avail
18:26:43 <astroboy> ivanm: how? I've heard that loading into the emacs ghci works
18:26:44 <astroboy> but
18:26:58 <astroboy> the problem is that the emacs ghci doesn't uses the flags in the .cabal file
18:27:04 <astroboy> so it regularly fails to compile
18:27:10 <ddarius> pumpkin: Just the visual effect is impressive.
18:27:34 <ivanm> astroboy: imenu, etc.
18:27:41 <pumpkin> ddarius: ooh, nice
18:27:46 <pumpkin> I'd like to see that
18:27:54 <ivanm> astroboy: _no_ ghci uses the flags in the .cabal file
18:27:58 * Axman6 likes that fundeps lets you write functions likemap' :: (b -> b) -> a -> a
18:27:59 <ivanm> cabal /= ghci
18:28:07 <byorgey> ddarius: this sounds crazy, do you have a link?
18:28:10 <ivanm> Axman6: oh? what's that meant to be?
18:28:13 <astroboy> ivanm: oh you mean functions defined in the current buffer? yeah that's easy eheh
18:28:13 <Axman6> like map'*
18:28:29 <ddarius> byorgey: What would I link to?
18:28:36 <geheimdienst> astroboy, yet another idea: ack is a little nicer than grep to find stuff in code bases. i sometimes do "cabal unpack X11", then do "ack something"
18:28:38 <astroboy> ivanm: Yeah I know, and that's the problem. haskell mode works only with the standard library stuff and the stuff loaded in the ghci process
18:28:38 <ddarius> I could take a picture of a pair of pages just to give an idea.
18:28:41 <byorgey> ddarius: I didn't know if there were scans of it somewhere
18:28:42 <geheimdienst> @google ack grep replacement
18:28:44 <lambdabot> http://betterthangrep.com/
18:28:44 <lambdabot> Title: ack 1.94 -- better than grep, a source code search tool for programmers
18:28:50 <ivanm> astroboy: huh?
18:29:03 <ivanm> haskellmode is used for writing code; what else are you wanting it to do?
18:29:13 <ddarius> byorgey: There's little reason for that, other than backup, as I'm probably the only one who could get much out of it.
18:29:15 <astroboy> ivanm: haskell mode has this nice little thing called inferior-haskell-type
18:29:24 <astroboy> that is exactly what I want
18:29:26 <ivanm> astroboy: oh, that; I don't use it
18:29:29 <byorgey> ddarius: ok, fair enough =)
18:29:29 <astroboy> it also has haskell-hoogle
18:29:31 <Axman6> ivanm: it's a class for newtypes to get inner types for takusen type inference stuff... clase Foo a b | a -> b where pgType :: a -> b; pgMap :: (b -> b) -> a -> a
18:29:32 <peoro> how can haskell close a file when I use a function like readFile? garbage collector or what?
18:29:33 <ivanm> I just use :t, etc. in ghci
18:29:46 <astroboy> ivanm: yeah but most of the times I can't just load a file in ghci
18:29:53 <ivanm> peoro: yeah, kinda
18:30:00 <ivanm> astroboy: why not?
18:30:09 <ivanm> if you need CPP, :set -XCPP
18:30:17 <ivanm> (don't enable it globally; I've had problems with it)
18:30:22 <astroboy> ivanm: because I need the flags in the .cabal
18:30:42 <ivanm> what do the flags do?
18:30:54 <ivanm> (I've never really developed anything with CPP, etc. though)
18:31:02 <astroboy> ivanm: well they enable features that I need to compile :P
18:31:33 <astroboy> but it's mostly other people software, so I don't really care
18:31:57 <astroboy> the point is that it doesn't compile with ghci, i'd have to copy the flags manually
18:32:14 <ivanm> well, yeah, that's kinda the point of using cabal to compile stuff rather than complex ghc invocations
18:32:58 <astroboy> ivanm: yes and in fact I use it. but I'm still looking for a way of having function types/definitions quickly
18:33:03 <astroboy> which is really really hard right now
18:33:10 <ivanm> still not following what you're after
18:33:30 <ivanm> maybe use hoogle or hayoo integration?
18:33:37 <ddarius> Notes for solving exact equations: "Letting v = (M, N) the exactness condition is v = 0 which is equivalent to v =  for some scalar potential ."
18:33:51 <azaq23> @src readFile
18:33:52 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
18:33:58 <astroboy> ivanm: right now I'm browsing the xmobar code.  There is a lot of X11 code and other stuff in it, and I have to browse through haddock each time
18:34:06 <azaq23> @src withFile
18:34:07 <lambdabot> withFile name mode = bracket (openFile name mode) hClose
18:34:15 <astroboy> ivanm: and somethimes the function is not from X11 but from some other lib I don't know
18:34:33 <ivanm> well, hayoo, etc. can help with that
18:34:49 <astroboy> ivanm: no, hoogle doesn't have all that stuff
18:34:57 <ivanm> I said hayoo, not hoogle
18:35:04 <ivanm> and I believe new hoogle does indeed have that stuff
18:35:05 <azaq23> the only option existing is that the GC does the closing once the file is read, just as in python and java, though I wouldn't use that myself and instead use withFile
18:35:06 * ddarius hugs geometric algebra.
18:35:17 <geheimdienst> astroboy, hoogle has much fewer packages than hayoo
18:35:32 <astroboy> ivanm: I've been working all day and hoogle doesn't have them, I'll try hayoo, thanks.
18:35:44 <ivanm> geheimdienst: new hoogle indexes hackage IIRC
18:35:53 <astroboy> ivanm: Your own packages?
18:35:55 <ivanm> or at least that was the plan...
18:36:01 <ivanm> astroboy: hmmm?
18:36:04 <geheimdienst> really? that would be awesome. where is the new hoogle?
18:36:22 <geheimdienst> i tried the regular one just the other day, and it didn't even find stuff in missingh :(
18:36:53 <astroboy> ivanm: ah hackage. the remote hoogle doesn't have most of the stuff anyway
18:37:00 <astroboy> yeah hayoo seems to have more
18:37:27 <geheimdienst> astroboy: in summary, you're right, it's an unfortunate situation. reading haskell is difficult. it's a far cry from, say, reading java in eclipse
18:37:31 <ivanm> geheimdienst: OK, maybe neil hasn't set up the indexing yet
18:37:38 <ivanm> but IIRC it is now technically capable of doing so
18:37:45 <ivanm> geheimdienst: how is reading Haskell difficult?
18:37:51 <Veinor> yeah, hoogle doesn't have stuff like hxt indexed
18:38:01 <ivanm> and does reading java in eclipse really help you find stuff in other libraries?
18:38:06 <geheimdienst> hoogle indexing everything would be a huge step forward
18:38:09 * geheimdienst gets all excited
18:38:50 <andy> quick question: do you prefer:
18:38:58 <Axman6> yes
18:39:04 <Axman6> =)
18:39:10 <andy> data Tag = End | SetBackgroundColor <fields> | ...
18:39:12 <andy> or
18:39:35 <andy> data Tag = End | SetBackgroundColorTag SetBackgroundColor | ...
18:39:37 <Veinor> why doesn't hoogle index all of hackage, anyway?
18:39:38 <geheimdienst> ivanm, well i mean things like: put mouse cursor over function, get nice big tooltip with function's documentation. hit key (was it F3?) to jump to function definition. right-click to get function's call sites. etc.
18:39:43 <astroboy> ivanm: It's difficult, because if you want to make small changes to foreign code the fact that types are not explicit doesn't help. don't get me wrong, I adore haskell, but haskell code is harder to pick up the first time. once you know the library it becomes really easy
18:39:52 <astroboy> geheimdienst: yeah, that too
18:40:00 <ivanm> Veinor: IIRC, old hoogle required you to rebuild the entire index to add/update a library
18:40:20 <byorgey> andy: what's the context? I don't really understand what those mean
18:40:20 <astroboy> but it's alsa haskell in itself, data type definitions, ecc
18:40:22 <Veinor> is 'old hoogle' the same as 'the hoogle with the old web interface design'?
18:40:31 <ivanm> geheimdienst: what, eclipse loads the library up just to get its types, etc.?
18:40:51 <andy> byorgey, i mean binary parsing of SWF files, they are made up of a series of Tag's terminated by and End tag
18:41:11 <andy> byorgey, so basically, is each Tag its own type or a data constructor
18:41:15 <ivanm> hoogle _can_ search all of hackage: http://neilmitchell.blogspot.com/2010/12/new-version-of-hoogle-41.html
18:41:22 <ivanm> you just have to tell it which libraries to search :/
18:41:49 <Veinor> ivanm: oh, neat
18:41:55 <byorgey> andy: I see.  I think I would prefer the first, where tags are data constructors
18:42:00 <ivanm> by default it just searches the platform
18:42:08 <byorgey> andy: the other way just seems like lots of useless duplication.
18:42:18 <geheimdienst> ivanm, uh, yeah sure? it needs to know about the libraries anyhoo, once you hit the "build and run" button
18:42:32 <Veinor> i,i anyhoogle
18:42:33 <andy> byorgey, the only thing that has mean leaning towards separate types are:
18:42:39 <ivanm> geheimdienst: isn't the compiler different from the editor?
18:42:46 <ivanm> (I've never really used eclipse)
18:42:49 <andy> byorgey, conflicting record field names -> field types
18:43:13 <andy> byorgey, and nicer function signatures - getSetBackgroundColor :: Get SetBackgroundColor
18:43:34 <monochrom> "build and coffee and swordplay" button. http://xkcd.com/303/
18:43:45 <andy> byorgey, do either of those seem significant enough?  i am not certain if there are any record field conflicts
18:44:14 <geheimdienst> it's very tightly integrated. the compiler incrementally compiles everything as you type it in. in the editor, you have squiggly underlines for compiler errors. right-clicking an error gives you some options how you could fix it, etc.
18:44:22 <byorgey> andy: those sound like good reasons  I don't feel strongly either way, just pick one and you'll soon find out whether you like it or not =)
18:44:29 <andy> k
18:44:59 <astroboy> geheimdienst: with emacs you have all that more or less for code that uses a Makefile. But not for the cabal stuff....
18:45:00 * geheimdienst must stop. geheimdienst is getting weepy because at work, he's using xcode now, which seems to be not nearly as good as eclipse ...
18:45:10 <andy> currently did with separate types, just aesthetics are bothering mean - DoABCTag DoAbc - though could just have hidden data constructors for each tag type
18:45:26 <andy> BAH ECLIPSE
18:45:32 <andy> 4 gigs and i have no clue what its doing
18:46:02 <andy> (use for java and adobe flex)
18:46:08 <astroboy> geheimdienst: emacs is better than all that eh :P
18:46:27 <astroboy> in fact, emacs is better than anything. even in haskell, it gets close
18:47:11 <astroboy> now
18:47:22 <geheimdienst> i'm a long-time and happy vim user, but i'm thinking of switching to emacs ... i get the impression it has a little better support for everything
18:47:32 <astroboy> does anybody have an idea on how to load a xbm with the X11 haskell libs?
18:47:35 <astroboy> geheimdienst: it does
18:47:43 <geheimdienst> vim's script thing is just weird and stupid
18:48:14 <andy> wish it was escheme instead of elisp..
18:48:39 <astroboy> geheimdienst: I don't remember, I quit vim some years ago, and I wasn't that good at it eheh
18:49:17 <Eduard_Munteanu> The longer you've been hooked on it, the harder is quiting it
18:49:34 <astroboy> Eduard_Munteanu: emacs?
18:51:22 <Eduard_Munteanu> Well, actually I use Vim
18:51:44 <parcs> i only wish vim's syntax highlighting wasn't so horribly slow
18:51:52 <dankna> someday,
18:52:03 <astroboy> Eduard_Munteanu: emacs is so superior that has vim inside it.
18:52:08 <dankna> I will write a text editor that uses Tomita's algorithm to do syntax highlighting
18:52:20 <dankna> it is like swatting a fly with an ICBM, but it will be fast and robust
18:52:41 <astroboy> Eduard_Munteanu: http://www.emacswiki.org/emacs/ViperMode
18:53:21 <astroboy> but right now, I just wished I was able to load an xbm with the X11 libs.
18:54:01 <astroboy> the equivalent XReadBitmapFile is missing, or I'm stupid, or there is another function
18:54:10 <Entroacceptor> what I'd like is different backgrounds for stuff in the same function
18:54:39 <astroboy> Entroacceptor: what do you mean?
18:57:15 <astroboy> ivanm: basically I'd like something like cscope, but for askell.
18:57:19 <astroboy> cscope is great
18:57:24 <ivanm> no idea what cscope is
18:57:26 <ivanm> *shrug*
18:57:48 <pumpkin> @google cscope
18:57:49 <lambdabot> http://cscope.sourceforge.net/
18:57:49 <lambdabot> Title: Cscope Home Page
18:58:18 <astroboy> cscope + emacs = win
18:59:43 <Entroacceptor> astroboy: maybe something like http://ebookblog.altervista.org/wp-content/uploads/2010/04/html-text-editor-syntax-highlighting1.gif
19:00:00 <Entroacceptor> you see that the javascript has a slighty different background to the html
19:00:14 <astroboy> Entroacceptor: you can have that. nxhtml does that for sure
19:00:30 <Entroacceptor> for haskell?
19:00:33 <astroboy> it does exactly that actually, different bgs for html/js/css in the same file
19:00:33 <astroboy> ah
19:00:35 <astroboy> no
19:00:46 <astroboy> Where would you want that for haskell/
19:01:26 <geheimdienst> Entroacceptor: i use the summerfruit color scheme (not just for haskell), and it uses a background color for comments and stuff. you can modify these color schemes, it's not really hard
19:02:00 <Entroacceptor> astroboy: alternating between different colors for different functions
19:02:32 <astroboy> Entroacceptor: I mean just to see that the function has changed? I've never tought of that. You may want to ask on '
19:02:37 <astroboy> sorry, on #emacs
19:04:28 <andy> i know c++ compilers (apparently) inline virtual methods where the implementing type is known
19:04:46 <andy> i imagine type classes in haskell will have similar behaviour
19:04:55 <andy> will data constructs and record fields as well?
19:04:59 <Axman6> they can, if the functions are morked INLINE
19:05:00 <andy> *data constructors
19:05:11 <andy> ok
19:05:18 <Axman6> record accessors should do
19:12:50 <drbean> What corresponds to newline in context-free syntax. I want to cut and paste a instance into ghci.
19:13:09 <ivanm> drbean: you can't create instances in ghci
19:13:37 <ivanm> though I beleive you can do multiline statements in ghci with { line1; line2 }
19:14:42 <Axman6> :{\nfoo\nbar\n:}
19:16:02 <andy> are there any naming conventions for data constructors?  i've seen just hiding it so it doesn't matter, prefixing with Mk, or just using the type name
19:16:20 <andy> assuming its a single data constructor with records
19:16:31 <geheimdienst> prefixing with ICanHas
19:17:03 <andy> those are already taken by my single method type classes
19:17:05 <Axman6> IHazSum Int Bool String
19:17:20 <andy> ICanHazCheese a { cheese :: a -> Cheese }
19:17:24 <Axman6> IHazSumIntBoolString Int Bool String
19:18:56 * ddarius just got mugged and then chased down the perpetrators while calling the cops and got his wallet back.
19:19:13 <jmcarthur> aren't you awesome :P
19:20:18 <ddarius> jmcarthur: Nah, if I were awesome I'd be calling the ambulance to pick up some messed up dudes.
19:20:30 <ddarius> I decided to only be mildly awesome tonight.
19:20:59 <Entroacceptor> ddarius: did you throw arrows at them?
19:21:09 <shachaf> ddarius: Is this a regular occurence in Boston?
19:21:11 <ddarius> Why would I throw arrows.
19:21:17 <jmcarthur> why wouldn't you?
19:21:20 * shachaf reconsiders copumpkin's advice to move there.
19:21:33 <jmcarthur> boston didn't seem so unsafe when i visited
19:21:39 <ddarius> shachaf: It's the first time it's happened to me, but then it's the first time it's happened to me anywhere.
19:21:51 <ddarius> I'm in Somerville, not Boston proper.
19:21:56 <jmcarthur> seemed like most areas had way too many people for that kind of thing to happen often
19:22:01 <jmcarthur> ah
19:22:10 <ddarius> Somerville is definitely more ghetto than many of the other parts of Greater Boston.
19:23:25 * ddarius recommends being more ruthless or in better cardiovascular fitness if one plans on mugging people.
19:23:58 * shachaf actually lives in a city that had the most murders per capita in the US one year in the 1990s.
19:24:11 <shachaf> So Boston would probably be an improvement if anything.
19:24:24 <Axman6> DC?
19:24:35 <ddarius> Good ole DC.
19:24:49 <Axman6> i seem to remember DC having a quite high murder rate...
19:25:00 <shachaf> Axman6: East Palo Alto, actually.
19:25:09 <shachaf> It's not as bad as it once was, I'm told.
19:25:11 <jmcarthur> wow
19:25:24 <jmcarthur> didn't know that about palo alto
19:25:38 <shachaf> jmcarthur: East Palo Alto /= Palo Alto
19:25:46 <jmcarthur> oh
19:25:47 <ddarius> jmcarthur starts reconsidering living anywhere.
19:25:56 <jmcarthur> ?
19:26:18 <shachaf> I'm on the edge of the city anyway.
19:26:32 * hackagebot comonads-fd 0.9.0 - Comonad transformers using functional dependencies.  http://hackage.haskell.org/package/comonads-fd-0.9.0 (EdwardKmett)
19:26:38 <jmcarthur> holy crap. "In 1992, it had the highest homicide rate in the country with 24,322 people, and 42 murders, equaling a rate of 172.7 homicides per 100,000 residents."
19:27:03 <ddarius> We should strive for a murder per capita.
19:27:20 <geheimdienst> 42 looks like a small sample ...?
19:27:32 * hackagebot streams 0.4 - Various Haskell 2010 stream comonads  http://hackage.haskell.org/package/streams-0.4 (EdwardKmett)
19:28:07 <jmcarthur> geheimdienst: the "per 100,000 residents" is definitely a misleading way to state it
19:28:16 <geheimdienst> at that city size, wouldn't even 1 murder bump your hom-per-100k rate by about 4?
19:28:30 <ddarius> geheimdienst: Yes, slightly more than 4.
19:28:37 <jmcarthur> it's still quite high
19:28:55 <jmcarthur> considering that in 2008 it seems to have only been 5 murders
19:29:15 <quuuux> I wouldn't be surprised, either, if city size negatively correlated with murder rate, making that an even more surprising figure
19:29:52 <ddarius> One murder in a town of 200, 500 homiceds per 100,000 residents.
19:29:54 <geheimdienst> quuuux: good point
19:30:07 <ddarius> Wow, "homicides" got butchered there.
19:30:31 <mafs> Yay to my brain for autocorrecting that for me :P
19:30:56 <quuuux> homiced = Hom., Iced. Makes perfect sense
19:31:31 <geheimdienst> homeicide = killing of a house
19:32:13 <parcs> is there a recommended way to derive Binary?
19:32:33 <shachaf> mafs: So much for your aspirations as a proof-reader.
19:33:58 <ivanm> has c.h.o's ssh key changed?
19:34:04 <mafs> shachaf: Hah. I'm actually pretty good at proof-reading. That was an unfortunate thing in middle school when I idly red-inked something a teacher handed out
19:34:10 <ddarius> My knife was quite a bit bigger than their knife.
19:35:28 <ivanm> I can't seem to push to any of my darcs repos there, and ssh'ing directly says there's a different ssh key :s
19:38:20 * ddarius is still hungry though.
19:39:48 * ddarius walks to the ATM.
19:44:57 <Saizan> ivanm: and it asks for a password if you accept..
19:45:23 <ivanm> Saizan: I thought c.h.o didn't use passwords...
19:45:33 * ivanm tries emailing support@community.haskell.org
19:46:17 <Saizan> well, asking for password is the default for when yours is not in authorized_keys
19:47:03 <shachaf> Saizan: Only if the SSH server asks for one.
19:48:47 <ivanm> Saizan: duh, right
19:48:53 <ivanm> but they don't use them there
20:07:06 <joe6> ghc-pkg describe usb: I want to change the content of what shows here. Any thoughts on how I can  do it, please?
20:07:26 <joe6> i noticed the package.cache files are binary.
20:08:54 <ivanm> joe6: what do you mean?
20:09:05 <ivanm> what do you want to change?
20:09:14 <ivanm> (and _why_?)
20:13:43 <Saizan> joe6: see ghc-pkg update
20:17:06 <heis> I'm trying to define a Monad instance for a type synonym: type Parser a = String -> Maybe (a, String)
20:17:25 <heis> Using {-# LANGUAGE TypeSynonymInstances #-}, it tells me:     Type synonym `Parser' should have 1 argument, but has been given 0
20:17:47 <dolio> That isn't what TypeSynonymInstances does.
20:17:55 <heis> Is this possible, or do I have to the full newtype thing and add a constructor to everything?
20:18:07 <dolio> Type synonyms need to be fully applied either way.
20:18:23 <copumpkin> heis: you need a newtype
20:18:27 <copumpkin> with a constructor
20:18:28 <heis> Well, it replaces the error without, which is:Illegal instance declaration for `Monad Parser'
20:18:28 <heis>         (All instance types must be of the form (T t1 ... tn)
20:18:28 <heis>          where T is not a synonym.
20:18:46 <joe6> ivanm: the usb package has some unicode stuff and the ghci with -v4 is failing on that unicode stuff.
20:19:06 <joe6> ivanm: hence, I want to remove the unicode character from ghc-pkg output.
20:19:21 <ivanm> oh? what's ghci's error message?
20:19:25 <joe6> Saizan: thans, will check it out
20:19:30 <dolio> TypeSynonymInstances lets you declare instances for fully-applied synonyms, instead of what the synonym would expand to.
20:19:32 <heis> So what does TypeSynonymInstances do? And what does the error mean?
20:19:37 * azaq23 just regarding my question for anyone who also wanted to know that about QuickCheck, existential types and function types yesterday, this works http://hpaste.org/43318/quickcheck_function_existentia
20:19:42 <joe6> ivanm: <stderr>: hPutChar: invalid argument (Invalid or incomplete multibyte or wide character)
20:19:52 <dolio> So 'instance C String' instead of 'instance C [Char]'.
20:19:56 <Saizan> joe6: might be easier to edit the original .cabal file and reinstall though
20:20:41 <dolio> Or 'instance C (Syn a)' instead of 'instance C (Expanded a a)' or something.
20:20:47 <heis> So can you never define instances for a simple parameterized type synonym?
20:21:03 <joe6> Saizan: i edited the .cabal file. Should I just do "cabal install" in that dir to reinstall?
20:21:04 <dolio> Synonyms are not first class.
20:21:12 <Saizan> joe6: yep
20:21:14 <ivanm> joe6: what's your locale?
20:21:22 <joe6> Saizan: thanks, doing that
20:22:31 <Saizan> heis: only if you could do so without using the type synonym, in essence they don't help working around the lack of type abstraction
20:22:59 <heis> Hmm
20:23:16 <Saizan> so for Parser above you need a newtype
20:23:19 <heis> I'm not sure I totally get it, but thank you.  I'll experiement and meditate on it
20:23:44 <ddarius> dolio: The String instance would still need another extension.
20:23:50 <dolio> Yes.
20:24:13 <heis> I know it works with it.  I just get obsessive about superficial minimalism, and I don't want Parser $ everywhwere
20:24:21 <heis> But if that's how it works, I'll deal
20:24:30 <heis> Thanks
20:25:11 <Saizan> basically if GHC allowed things like Monad Parser then instance resolution would become undecidable
20:32:49 <Axman6> hmm, someone should write an opencl edsl for generating the code using haskell
20:33:00 <Veinor> I wish FilePath-type stuff accepted "-" for stdout
20:33:02 <Axman6> at the moment, you have to write it in a String
20:34:01 <ddarius> Saizan: It could allow higher order pattern matching and even some cases beyond that in a, presumably, not too ad-hoc way.
20:34:19 <ddarius> s/matching/unification/
20:39:27 <n0den1te> For any function, foo :: (T a, Y a) => a -> Z, is it correct to say that T and Y are type constraints on function foo?
20:39:46 <copumpkin> I'd say type constraints on type variable a
20:39:55 <copumpkin> but they're constraints on the type of foo, too
20:41:03 <n0den1te> @hoogle compare
20:41:04 <lambdabot> Prelude compare :: Ord a => a -> a -> Ordering
20:41:04 <lambdabot> Data.Ord compare :: Ord a => a -> a -> Ordering
20:41:04 <lambdabot> Text.ParserCombinators.Parsec.Error messageCompare :: Message -> Message -> Ordering
20:42:11 <n0den1te> copumpkin: thanks. A related question, just for kicks, I define a partially applied function, mycompare extending compare, like: mycompare :: (Ord a, Num a) => a -> Ordering; mycompare = compare 100
20:42:40 <n0den1te> I need to include the Num constraint because I'm using a literal "100" there?
20:43:39 <n0den1te> or am I just wrong in my understanding?
20:43:47 <copumpkin> yep
20:43:59 <copumpkin> the literal 100 carries a num constraint with it
20:44:17 <copumpkin> and so when it goes to unify the types, it piles up the constraints
20:47:31 <n0den1te> danke. 
20:54:09 <n0den1te> I just find it a little unsettling that Num and Ord are different types when logically all numbers are ordered. No?
20:54:35 <n0den1te> I think this will be somewhat different when we do floating types. 
20:54:57 <dolio> No,not all numbers are totally ordered.
20:55:32 <n0den1te> dolio: elaborate, please?
20:55:39 <c_wraith> Complex numbers
20:55:45 <c_wraith> is i < 1 ?
20:56:22 <n0den1te> we have a type Complex for that, right? 
20:56:39 <Axman6> yes, and it is an instance of Num
20:56:40 <shachaf> n0den1te: And those are numbers.
20:56:48 <Axman6> but there's no total ordering
20:56:59 <shachaf> n0den1te: There are numbers that aren't ordered, and there are *definitely* ordered things that aren't numbers.
20:57:02 <Axman6> > 1 :+ 0 <= 0 :+ 1
20:57:03 <lambdabot>   No instance for (GHC.Classes.Ord (Data.Complex.Complex t))
20:57:03 <lambdabot>    arising from ...
20:58:11 <n0den1te> ah. :)
20:58:21 <dolio> Well, you can make up a total ordering. But it's going to be un-ideal.
20:59:06 <n0den1te> dolio: yes, I realise that now. 
21:00:12 <n0den1te> shachaf: I'm curious about ordered things that are not numbers. (Not big on math here, but trying to _get_ things). I got complex nums, but they are numbers too, right?
21:00:28 <shachaf> > compare False True
21:00:29 <lambdabot>   LT
21:01:01 <n0den1te> Bool is ordered? Learn new things everyday, hmmmm :)
21:01:02 <copumpkin> n0den1te: define number :)
21:01:08 <copumpkin> > compare LT GT
21:01:09 <lambdabot>   LT
21:01:16 <copumpkin> Ordering itself is ordered
21:01:33 <copumpkin> > compare "abc" "abd"
21:01:35 <lambdabot>   LT
21:01:44 <shachaf> > compare copumpkin pumpkin
21:01:44 <copumpkin> > compare [0] [-1,2]
21:01:45 <lambdabot>   GT
21:01:46 <lambdabot>   GT
21:01:55 <c_wraith> > (copumkin, pumpkin)
21:01:56 <lambdabot>   Not in scope: `copumkin'Not in scope: `pumpkin'
21:01:59 <n0den1te> that would be lexical ordering. un-numbers. 
21:02:31 <shachaf> n0den1te: Wasn't that the point?
21:02:54 <n0den1te> shachaf: right, yeah. :)
21:03:24 <copumpkin> yay, my primops seem to be working
21:03:25 <azaq23> n0den1te: complex numbers aren't ordered
21:03:36 <shachaf> This has been mentioned.
21:03:51 <Saizan> ddarius: any particular way in mind?
21:07:41 <azaq23> oh yes, ambiguous use of "got" in that sentence
21:08:49 <n0den1te> azaq23: yes, I was referring to things said earlier and was asking about ordered things that aren't numbers. 
21:10:58 * hackagebot attoparsec 0.8.4.0 - Fast combinator parsing for bytestrings  http://hackage.haskell.org/package/attoparsec-0.8.4.0 (BryanOSullivan)
21:16:56 <mbuf> suppose I have a list a = ["a", "b", "c"], and I want to invoke different functions on each of the list, how would I do that?
21:17:45 <mbuf> map helps to apply the same function on each list, but, I would like to invoke different functions based on which index in the list they are located in
21:17:46 <drbean> < zipWith ($) [(+), (-)] [1..3]
21:17:52 <Veinor> > zipWith <$> [(+1), (+2), (+3)] [0,0,0]
21:17:53 <lambdabot>   Couldn't match expected type `t -> f (a -> b -> c)'
21:17:53 <lambdabot>         against inferre...
21:18:00 <Veinor> > zipWith ($) [(+1), (+2), (+3)] [0,0,0]
21:18:01 <lambdabot>   [1,2,3]
21:20:51 <drbean> The fact zipWith works that way is confusing when:
21:21:11 <drbean> < zipWith (+) [0..2] [3..5]
21:23:13 <Cale> > zipWith (+) [0..2] [3..5]
21:23:14 <lambdabot>   [3,5,7]
21:23:22 <Cale> drbean: what's confusing?
21:23:40 <Cale> :t zipWith ($) [(+), (-)] [1..3]
21:23:41 <lambdabot> forall b. (Num b, Enum b) => [b -> b]
21:23:55 <Cale> :t zipWith ($) (zipWith ($) [(+), (-)] [1..3]) [1..3]
21:23:56 <lambdabot> forall b. (Num b, Enum b) => [b]
21:23:59 <Cale> > zipWith ($) (zipWith ($) [(+), (-)] [1..3]) [1..3]
21:24:00 <lambdabot>   [2,0]
21:24:06 <Cale> > zipWith ($) (zipWith ($) [(+), (-), (*)] [1..3]) [1..3]
21:24:07 <lambdabot>   [2,0,9]
21:29:40 <aristid> :t (zipWith ($), (<*>))
21:29:41 <lambdabot> forall b b1 (f :: * -> *) a b2. (Applicative f) => ([b -> b1] -> [b] -> [b1], f (a -> b2) -> f a -> f b2)
21:30:27 <aristid> :t ZipList [(+), (-), (*)] <*> ZipList [1..3] <*> ZipList [1..3]
21:30:28 <lambdabot> forall a. (Num a, Enum a) => ZipList a
21:30:34 <aristid> > getZipList $ ZipList [(+), (-), (*)] <*> ZipList [1..3] <*> ZipList [1..3]
21:30:35 <lambdabot>   [2,0,9]
21:31:58 <aristid> :t liftA3 ($)
21:31:59 <lambdabot> forall b c d (f :: * -> *). (Applicative f) => f (b -> c -> d) -> f b -> f c -> f d
21:33:25 <kuffaar> I just read about Applicative for the first time and I couldn't come up with any practical scenario at all haha
21:33:54 <Axman6> kuffaar: once you see them used they make a lot of sense
21:33:59 <drbean> -- I want a Show instance for the (->) type, to show (+1). But all I can get is "<function>"
21:34:16 <Axman6> > (,,) <$> [1..3] <*> [4..6] <*> [7..9]
21:34:16 <lambdabot>   [(1,4,7),(1,4,8),(1,4,9),(1,5,7),(1,5,8),(1,5,9),(1,6,7),(1,6,8),(1,6,9),(2...
21:34:21 <drbean> I am reading Typeclassopedia, which motivates Applicative well.
21:34:42 <kuffaar> I have seen plenty of examples, I just can't think of any way to use it in my code
21:35:59 <joe6> ivanm: It was en_us till I noticed it and changed it to en_uS.UT/quit
21:37:22 <djahandarie> drbean, it's impossible to write Show for all functions
21:37:43 <djahandarie> (Within the language)
21:37:49 <djahandarie> Because this involves knowing if a function halts or not
21:39:20 <kuffaar> I don't even know of a way to analyse a function like that
21:39:39 <kuffaar> Wouldn't that require some language extension?
21:39:50 <Saizan> it would, or compiler magic
21:40:39 <drbean> I thought it was because of round-tripping of Read from the output of Show.
21:41:05 <Saizan> (i.e. i don't think the haskell report prevents a compiler from providing a primitive that does that)
21:42:18 <Saizan> the Read part would be easier, since the GHC API exposes enough to write an eval function
21:49:06 <kuffaar> Why doesn't Java have a type statement? ;_;
21:49:29 * kuffaar drowns in extremely long generics types
21:49:49 <adu> lol
21:50:07 <adu> type aliases would be nice
21:50:20 <adu> or a preprocessor
21:50:35 <kuffaar> I don't understand why they haven't added anything along those lines
21:51:11 <kuffaar> Do they actually want you to make a new class for every such occasion?
21:51:18 <mbuf> If I have let b = [["a,b,c"],["d,e,f"]] and use ghci> map head b, I get ["a,b,c", "d,e,f"]
21:51:21 <ulfdoz> Oh no, not a preprocessor in style of cpp. Sorry, but there is no more ugly thing.
21:51:41 <ulfdoz> But there is a preprocessor, based on annotations.
21:51:42 <kuffaar> Yeah I can't say I'd have any use for preprocessor
21:51:43 <adu> kuffaar: i think its so that the 32-bit two's complement is uniquely identified by 'int'
21:51:55 <kuffaar> adu: Waaah!
21:52:22 <mbuf> but, if I use a function ping :: [[String]] -> [String], ping = map head, I get ["a", "d", "g"], why?
21:52:25 <kuffaar> > let b = [["a,b,c"],["d,e,f"]] in map head b
21:52:27 <lambdabot>   ["a,b,c","d,e,f"]
21:52:38 <adu> as opposed to in32_t, gint32, myInt32, SInt32, sint32, myInteger32, etc...
21:53:44 <adu> kuffaar: I think OpenCL-C is trying to do the same thing, only differently than C99 did
21:54:26 <kuffaar> mbuf I don't get that
21:55:50 <aristid> :t let b = [["a,b,c"],["d,e,f"]] in b
21:55:51 <lambdabot> [[[Char]]]
21:55:54 <kuffaar> mbuf pastebin your code/ghci session
21:55:56 <aristid> :t (.:)
21:55:57 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
21:55:58 <mbuf> kuffaar: sure
21:56:00 <aristid> :t (.::)
21:56:01 <lambdabot> Not in scope: `.::'
21:56:08 <aristid> :t (.:.)
21:56:09 <lambdabot> Not in scope: `.:.'
21:56:18 <aristid> @let (.:.) = fmap.fmap.fmap
21:56:19 <lambdabot>  Defined.
21:56:30 <aristid> > let b = [["a,b,c"],["d,e,f"]] in toUpper .:. b
21:56:32 <lambdabot>   [["A,B,C"],["D,E,F"]]
21:56:57 <kuffaar> > let {b = [["a,b,c"],["d,e,f"]], ping = map head} in ping b
21:56:58 <lambdabot>   <no location info>: parse error on input `,'
21:57:05 <kuffaar> Oh, fail
21:57:11 <aristid> ; not ,
21:57:31 <kuffaar> > let {b = [["a,b,c"],["d,e,f"]]; ping = map head} in ping b
21:57:32 <lambdabot>   ["a,b,c","d,e,f"]
21:57:32 <kuffaar> Yeah
21:58:20 <kuffaar> mbuf it's specially interesting that you get a "g" because your original list contains no "g" at all.
21:58:52 <mbuf> kuffaar: http://hpaste.org/43319/string__string 
21:59:18 <mbuf> kuffaar: sorry, I added one more list during testing ["g,h,i"]
22:01:54 <kuffaar> Ah, Parsec
22:02:30 <mbuf> kuffaar: is there any other alternative? I referred Using Parsec http://book.realworldhaskell.org/read/using-parsec.html
22:02:42 <kuffaar> Parsec is good, I use it, too
22:02:56 <mbuf> kuffaar: I need to parse CSV, and insert ith element into ith record in database; map helps to apply the same function to all elements
22:03:29 <mbuf> kuffaar: but, I need to read, say 5th element, and insert it into the 5th record as defined in data Record
22:03:33 <kuffaar> Urgh I'm too slow to grasp it all at once, I'll just test the code
22:03:38 <mbuf> kuffaar: sure
22:03:47 <kuffaar> You mix tabs and spaces :'(
22:06:09 <aristid> preflex: seen chrisdone
22:06:10 <preflex>  chrisdone was last seen on #haskell 41 days, 11 hours, 49 minutes and 4 seconds ago, saying: Good evening.
22:06:14 <aristid> preflex: seen chrisdone`
22:06:14 <preflex>  Sorry, I haven't seen chrisdone`
22:07:04 <mbuf> kuffaar: ohh! sorry
22:07:15 <kuffaar> :o?
22:07:34 <mbuf> kuffaar: 'You mix tabs and spaces :'('
22:07:40 <kuffaar> Right
22:10:14 <mbuf> kuffaar: parseCSV gives me [[String]]; is there any way to get String, and then can parse the individual a,b,c and map it to data Record?
22:10:32 <kuffaar> I think you definitely want [[String]]
22:10:51 <kuffaar> Otherwise you wouldn't know where rows end/start
22:11:18 <mbuf> kuffaar: I see
22:11:33 <kuffaar> Hmm the parser fails for me
22:11:52 <kuffaar> "CSV data" (line 3, column 6): unexpected end of input expecting end of line
22:12:06 <kuffaar> Ah it was because of a lack of a terminal \n
22:12:13 <kuffaar> You should consider that case, too, I think
22:12:57 <kuffaar> <mbuf> If I have let b = [["a,b,c"],["d,e,f"]] and use ghci> map head b, I get ["a,b,c", "d,e,f"]
22:13:05 <mbuf> kuffaar: right
22:13:06 <kuffaar> mbuf r has a totally different value
22:13:18 <kuffaar> It's [["a","b","c"],["d","e","f"],["g","h","i"]]
22:13:20 <kuffaar> As it should be
22:13:39 <mbuf> kuffaar: ohh! okay
22:14:06 <kuffaar> mbuf: By the way, you should always specify the full signatures of all top level function definitons
22:14:10 <kuffaar> main :: IO () is missing
22:14:31 <mbuf> kuffaar: thanks for your comments
22:15:09 <kuffaar> csvFile :: Text.Parsec.Prim.ParsecT [Char] u Data.Functor.Identity.Identity [[[Char]]] -- let's see if we can make this prettier
22:15:25 <kuffaar> It's nice to define a central type definition for those which you can reuse to make your code less redundant
22:15:48 <kuffaar> ParsecT String u Identity [[String]]
22:15:52 <kuffaar> Perhaps something like that hm
22:16:56 <kuffaar> It may already have a type definition for that so Identity doesn't need to be imported from Data.Functor hm
22:17:19 <kuffaar> http://www.google.com/search?q=site%3Ahaskell.org+ParsecT+Identity&ie=utf-8&oe=utf-8&aq=t&rls=org.mozilla:en-US:official&client=firefox-a
22:17:24 <kuffaar> type Parsec s u = ParsecT s u Identity
22:17:26 <kuffaar> Perfect :)
22:17:34 <mbuf> kuffaar: will check that; BRB
22:17:53 <kuffaar> That means we can use Parsec String u [[String]] in that case, for example
22:19:17 <kuffaar> Actually you should just import import Text.Parsec
22:22:50 <ivanm> I'm porting graphviz from String to Text; however, does it make senes to leave errors from calling dot, etc. as Strings?
22:23:20 <kuffaar> mbuf alright I messed with your code a bit
22:23:37 <mbuf> kuffaar: let me check out those options
22:23:45 <kuffaar> mbuf http://siyobik.info/pastebin_download.php?id=577
22:24:04 <kuffaar> First off, I replaced the old Parsec import, not sure why you used that one but it's not helpful I think
22:24:40 <kuffaar> Second, I added signatures for all top level functions and I moved the internal csvFile parsers into a where clause (which is not really great for more complicated parsers)
22:24:56 <kuffaar> But it avoids having to specify a top level definition for all of them
22:25:13 <mbuf> kuffaar: I see; oops, I need to install Text.Parsec
22:25:16 <kuffaar> If you don't specify one you will get a warning when you compile stuff with -Wall (which you always should, in my opinion)
22:25:30 <kuffaar> mbuf huh? It doesn't work?
22:25:34 <Axman6> ivanm: depends if there's a lot of text or not, it's probably ok to use strings
22:25:41 <kuffaar> You can't :m +Text.Parsec in ghci?
22:25:44 <ivanm> Axman6: *nod*
22:25:52 <kuffaar> Because all those modules are exported by the same HackageDB package
22:25:55 <kuffaar> "parsec"
22:25:59 <ivanm> I figured for errors then anyone who cares would be printing it right out to stderr anyway
22:25:59 <kuffaar> As far as I know
22:26:26 <kuffaar> mbuf: My ~/.ghci contains this: :set -Wall
22:26:35 <kuffaar> That way I see those verbose warnings all the time
22:26:36 <jdavis> Given an operator name a typeclass, and a specific type, how do I find the function that implements that operator for that typeclass for that type?
22:26:39 * pastorn just killed the bug
22:26:43 <mbuf> kuffaar: iif I do :m +Text.Parsec in ghci, I get Could not find module `Text.Parsec':
22:26:44 <mbuf>  
22:26:46 <kuffaar> When I first opened your file I got like 15 of those
22:26:50 <kuffaar> mbuf that is curious
22:26:56 <kuffaar> mbuf what OS are you on?
22:27:06 <Jafet> @src fmap []
22:27:06 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
22:27:08 <pastorn> preflex: seen joe6
22:27:08 <preflex>  joe6 was last seen on #haskell 51 minutes and 10 seconds ago, saying: ivanm: It was en_us till I noticed it and changed it to en_uS.UT/quit
22:27:15 <kuffaar> @src fmap
22:27:16 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
22:27:23 <mbuf> kuffaar: Fedora
22:27:25 <Jafet> Hey, that's a new insult
22:27:33 <kuffaar> Oh that's from Functor
22:27:34 <ivanm> Jafet: nah, seen it before
22:27:39 <kuffaar> And no default implementation
22:27:46 <Jafet> @src [] fmap
22:27:46 <lambdabot> fmap = map
22:28:00 <kuffaar> mbuf: what does ghc-pkg list | grep -i parsec say?
22:28:17 <mbuf> kuffaar: parsec-2.1.0.1
22:28:27 <kuffaar> Oh that's a very old version hmm
22:28:33 <kuffaar> I presume you use ghc 6
22:28:35 <kuffaar> I use parsec-3.1.0
22:28:39 <kuffaar> With ghc 6
22:28:43 <kuffaar> ghc 7*, sorry
22:28:45 <mbuf> kuffaar: I see; yes ghc 6.12.3
22:28:52 <mbuf> kuffaar: be right back
22:28:59 <kuffaar> Maybe the interface changed radically, let's check the HackageDB exported modules
22:29:01 <ivanm> Axman6: the downside of leaving it as String: I need to keep my hacky pseudo-strict hGetContents around :s
22:29:18 <kuffaar> http://hackage.haskell.org/package/parsec-2.1.0.1 that's the old one
22:29:20 <Jafet> That looks like the latest version of parsec-2
22:29:32 <kuffaar> mbuf the exported modules interface looks radically different yeah
22:30:18 <kuffaar> The latest one works with ghc 6 though
22:30:27 <kuffaar> mbuf I suggest you get that one :o
22:30:36 <kuffaar> http://hackage.haskell.org/package/parsec-3.1.0
22:30:41 <kuffaar> Built on: ghc-6.12, ghc-7.0
22:30:57 <Axman6> ivanm: read in as Text, convert to String?
22:30:58 <kuffaar> cabal install parsec-3.1.0?
22:31:15 <ivanm> Axman6: yeah, could do that
22:31:30 <ivanm> I have to re-do all the IO stuff later on anyway, so I'll leave it as-is for now
22:31:37 <ivanm> this is a real PITA to port :s
22:40:55 <kuffaar> mbuf also, the rest of that code can be greatly simplified :|
22:45:09 <kuffaar> Uhm I am somewhat shocked. Am I terribly mistaken or do both the HDBC stuff and Takusen expect you to _manually type in raw SQL queries_ instead of creating them programmatically like in, say, Ruby sequel?
22:45:26 <kuffaar> That's like the opposite of the mindset of Haskell to me :|
22:45:51 <Axman6> as far as i can tell, yes :(
22:46:00 <Axman6> we need a nice query language DSL
22:46:04 <kuffaar> Yeah >:O
22:46:14 <Axman6> i keep running into problems with takusen because i get the SQL wrong
22:47:00 <stepcut> kuffaar: happstack-state ;)
22:47:02 <kuffaar> Axman6 modern SQL bindings don't actually use plain text SQL queries, do they? I thought they created an internal format programmatically, which is nothing like those plain text queries
22:47:06 <Jafet> You should always feel the pain when using SQL. Pavlovian.
22:47:38 <kuffaar> And I was told that you can create those queries programmatically using special libraries provided by the DBMS
22:47:43 <Jafet> Anyway, using strings for SQL is basically the cross-language equivalent of eval.
22:48:05 <kuffaar> Like libpg and such
22:48:21 <kuffaar> stepcut isn't that quite different from a DBMS?
22:48:35 <Axman6> seems HaskellDB aims to let you do thatr
22:49:15 <stepcut> kuffaar: it is different from a relational DBMS, but it is a DBMS
22:49:23 <kuffaar> http://hackage.haskell.org/package/haskelldb <- hmm it's still based on creating plain text though?
22:49:53 <kuffaar> Well in my case I don't really have to use SQL
22:50:08 <Axman6> hmm, seems you can use haskelldb to just generate your queries
22:50:30 <kuffaar> stepcut: Wasn't that based on keeping everything in memory?
22:50:42 <kuffaar> I am dealing with gigabytes of data here, the server has only 2 GiB of RAM
22:50:44 <stepcut> kuffaar: yes
22:50:56 <stepcut> kuffaar: how many gigabytes ?
22:50:59 <kuffaar> 3
22:51:26 <stepcut> isn't 4GB of ram like $80 these days ?
22:51:29 <kuffaar> That sounds more like a use case for Postgres, no?
22:51:56 <kuffaar> stepcut lol that's not a generic solution, I can't just keep everything in RAM, it will outgrow it over and over again
22:52:03 <kuffaar> And it's a rented server, I can't extend it
22:52:50 <kuffaar> 2.2 GHz Celeron, 2 GiB RAM, 250 GB HDD, 100/100 Mbps for 3 TiB, 10 Mbps after that, $16 per month
22:52:56 <stepcut> kuffaar: well, ultimately switch to sharding so that it is split across multiple machines.
22:53:02 <kuffaar> lol
22:53:27 <kuffaar> There is no point in spending more money in this case, this isn't some high performacne commercial server
22:53:43 <stepcut> yeah, MACID is not really optimized for lost cost hosting. 
22:53:45 <kuffaar> The priorities are to do as much as possible with the existing hardware without paying more at all
22:53:48 <Jafet> swapon -a && ./prog
22:54:25 * hackagebot hsp 0.6.1 - Haskell Server Pages is a library for writing dynamic server-side web pages.  http://hackage.haskell.org/package/hsp-0.6.1 (NiklasBroberg)
22:54:59 <stepcut> sweet! new HSP!
22:55:25 <kuffaar> Jafet: I suspect that using a "fully in-memory" DBMS like that would be outperformed by Postgres when dealing with swapping
22:55:49 <stepcut> kuffaar: yes -- swapping is to be avoided.
22:56:22 <kuffaar> Postgres and such are pretty sophisticated pieces of software, I think
22:56:41 <kuffaar> Coding a DBMS is a science
22:57:34 <kuffaar> So it's nice being able to interface with them
22:58:55 <stepcut> kuffaar: http://highscalability.com/blog/2009/3/16/are-cloud-based-memory-architectures-the-next-big-thing.html
22:58:58 <kuffaar> Axman6 I already forgot, did you use PostgreSQL with that?
22:59:10 <stepcut> kuffaar: http://glinden.blogspot.com/2009/11/put-that-database-in-memory.html
22:59:12 <kuffaar> stepcut I think you have shown that one to me before
22:59:21 <kuffaar> In both #snapframework and #happstack?
22:59:28 <stepcut> kuffaar: the second link perhaps, but not the first one probably
22:59:43 <kuffaar> I know the first one, not the second one
22:59:47 <Axman6> kuffaar: for what? yes we are using postgres though
23:00:00 <stepcut> kuffaar: ah
23:00:05 <kuffaar> Axman6 oh, I meant your DB stuff, yeah
23:00:11 <kuffaar> For Takusen
23:00:28 <Axman6> it's quite difficult to understand
23:00:42 <Axman6> i need to spend a day reading through all the docs... but it's so boring and tedious :(
23:01:27 <kuffaar> Axman6 what I want is to be able to define the tables within Haskell and to create queries in a typesafe way without actually writing any raw SQL at all
23:01:31 <stepcut> kuffaar: happstack 7 will focus a lot on MACID and making it more practical
23:01:57 <stepcut> kuffaar: and will allow to you do everything all type-safe with no raw Strings or SQL at all ;)
23:02:24 <kuffaar> stepcut: But those articles are a totally different world from mine. I deal with non-distributed low performance low cost systems with (relatively) large amounts of data
23:02:47 <kuffaar> Using PostgreSQL/MySQL etc makes far more sense in my situation
23:03:23 <stepcut> kuffaar: probably.
23:03:38 <stepcut> kuffaar: though if you had to pay for your own development time, the 'low cost' part might evaporate
23:04:44 <kuffaar> This is recreational :o no money involved
23:04:47 <kuffaar> Other than the rent
23:04:52 <stepcut> yeah
23:05:27 <stepcut> though, your life is precious -- you shouldn't waste it debugging SQL errors ;)
23:05:35 <quuuux> kuffaar: I have a rather hackish module for type-safe (ish) queries and table construction using template haskell on top of HDBC, but it's inflexible if you need to do anything more than 'select x, y, z from a join y where i = j'
23:05:49 <Axman6> kuffaar: i want exactly the same thing. i'ce had a few idea about how to do it, but nothing good yet
23:06:00 <kuffaar> quuuux is the code online?
23:06:20 <quuuux> kuffaar: not yet, no. It's only like 150 lines of code, though
23:06:25 <kuffaar> Oh, ok
23:06:40 <quuuux> my point is that it's not a huge undertaking to do such a thing
23:06:50 <kuffaar> What previous experience with such systems do you have? I have only used sequel for Ruby
23:07:03 <kuffaar> Which allows the composition of really complex terms, I think
23:07:29 <kuffaar> Arbitrarily nested queries and such
23:07:34 <kuffaar> But it's not safe at all
23:07:40 <kuffaar> Ruby is all dynamic etc
23:07:54 * Axman6 wonders if there's a monad to be had here
23:07:55 <kuffaar> And you can create all kinds of syntax errors easily by aliasing the wrong names
23:08:01 <quuuux> kuffaar: oh, this is nothing so grand. It's a very thin wrapper over the SQL
23:08:08 <Axman6> hmmmmmm
23:08:50 <quuuux> I basically got sick of query returning a list of columns, and how cumbersome it is to inspect it properly
23:08:54 <kuffaar> quuuux yours is based on plain text queries instead of direct DBMS bindings, too, right?
23:09:15 <quuuux> kuffaar: right. Like I said, thin wrapper over HDBC
23:09:24 <kuffaar> I don't know HDBC really
23:09:29 <Axman6> takusen is quite nice for doing queries
23:09:41 <Axman6> but any DML queries are a pain and easy to get wrong
23:09:51 <Axman6> hmmmmmm
23:09:57 <kuffaar> DML = ?
23:10:14 <n0den1te> data manipulation language. 
23:10:14 <Axman6> data manipulation ... language? inserts, deletes etc
23:10:24 <n0den1te> right.
23:10:33 <kuffaar> I don't even know SQL well enough to fully grasp the algebraic complexity etc
23:11:23 <kuffaar> How far you can nest stuff and how stuff from the outside needs to be able to interact with inner queries
23:12:02 <n0den1te> that's best left to the database, I think. Most dbms have optimizations that allow them to optimize inner queries away. 
23:12:02 <Axman6> ffffuuuu i think hackelldb might offer everything i'd like, but the docs are completely lacking examples
23:12:41 <Axman6> http://hackage.haskell.org/packages/archive/haskelldb/2.1.0/doc/html/Database-HaskellDB-Query.html
23:13:08 <kuffaar> sequel simply uses symbols and stuff for those but in Haskell you want a closer static semantic relationship between them
23:13:16 <kuffaar> In Ruby it's very loose there
23:13:56 <Axman6> let me know when you've written something :P
23:14:06 <kuffaar> Axman6 I'm like at a hello world level
23:14:13 <Axman6> yeah i know :(
23:14:57 <n0den1te> I'm at that "hello, world" in haskell. I'd sure like to look over how to write bigger stuff in Haskell. :(
23:15:23 <JoeyA> > putStrLn (reverse "Hello, world")
23:15:24 <lambdabot>   <IO ()>
23:15:26 <ivanm> isn't it great when a QC run finds a bug that's somehow slipped through the cracks for several releases (including those for which you ran those very same QC tests)? :s
23:15:29 <JoeyA> That's bigger :-)
23:15:40 <ivanm> JoeyA: not a program! ;-)
23:15:46 <JoeyA> sigh
23:15:47 <ivanm> you need "main = "!
23:16:00 <n0den1te> and a declaration, main :: IO
23:16:02 <JoeyA> main = putStrLn (reverse "Hello, world")
23:16:05 <n0den1te> :-)
23:16:06 <mauke> n0den1te: optional
23:16:12 <JoeyA> sigh
23:16:19 <n0den1te> mauke: yes, full program? self documenting?
23:16:20 <JoeyA> public static const volatile abstract void main
23:16:21 <kuffaar> mauke: Are you a -Wall hater?
23:16:30 <JoeyA> Am I forgetting anything?
23:16:32 <quuuux> -Wall -Werror 4 lyf, yo
23:16:32 <mauke> kuffaar: no, but it's not as important as in C
23:16:39 <shachaf> ivanm: Sure it's a program.
23:16:39 <kuffaar> quuuux ^5
23:16:49 <shachaf> ivanm: ghci < m.hs
23:17:05 <kuffaar> echo ":set -Wall -Werror" > ~/.ghci
23:17:07 <kuffaar> :)
23:17:07 <ivanm> shachaf: that's cheating!
23:17:16 <sipa> (int argc, char** argv);
23:17:24 <mauke> n0den1te: well, I'd recommend doing "main = interact foo" and learning more about Haskell-the-language
23:17:26 <shachaf> ivanm: What, exactly, is a computer program?
23:17:35 <shachaf> ivanm: If not instructions for a computer on how to do something?
23:17:46 <kuffaar> It's like HTML, but better
23:18:09 <shachaf> kuffaar: >>, please.
23:18:21 <kuffaar> >> for what?
23:18:25 <mauke> echo
23:18:34 <kuffaar> Right
23:18:50 <sipa> itd instructions for a computer, but not necessarily on *how* to do things
23:18:57 <sipa> it's
23:19:52 <n0den1te> mauke: sure, I'm all about it. Currently going over "Gentle intro" and LYAH. :)
23:20:21 <mauke> do you happen to know javascript?
23:20:43 <n0den1te> a wee bit. 
23:21:12 <accel> can a haskell program dynamicaly load anotehr module?
23:21:31 <accel> can a haskell program dynamicaly load anotehr module? like c programs can use dlopen
23:21:32 <mauke> IMHO if you're familiar with its asynchronous APIs (like XMLHttpRequest and setTimeout, sort of), it's easier to understand Haskell's IO
23:21:45 <kuffaar> accel I don't think that is part of the standard but GHC provides facilities to do so
23:21:54 <accel> kuffaar: what should I be reading up on?
23:22:32 <n0den1te> mauke: yes, I'm familiar with XHR and I've used them in some web programming that I did. It's pretty much the case in most of disconnected response models that the web corresponds to. 
23:22:37 <mbuf> kuffaar: back, on http://siyobik.info/pastebin_download.php?id=577, I get Not in scope: 'void' on line 12, 13
23:22:40 <mbuf> *14
23:22:58 <kuffaar> mbuf: Apparently that's not around in ghc 6 yet hmm
23:23:04 <kuffaar> Is void a ghc 7 thing?
23:23:07 <mauke> n0den1te: my take on IO: http://mauke.dyndns.org/stuff/haskell/how-to-io.html
23:23:16 <mbuf> kuffaar: have done cabal install parsec-3.1.0
23:23:26 <mbuf> kuffaar: thanks for your timely help! appreciate it
23:23:31 <kuffaar> mbuf you don't have to use void, it's just a cosmetic thing to eradicate warnings
23:23:45 <accel> or does ocaml's VM vioolate the agreements ?
23:23:50 <accel> kuffaar: what should I be reading up on?
23:23:55 <kuffaar> mbuf: I am not happy at all that you are hard coding entire SQL create table statements into your Haskell code
23:24:13 <kuffaar> accel: I honestly don't know, the Snap Framework implements something like it
23:24:24 <kuffaar> c_wraith and gcollins are involved with that, I think
23:24:24 <mbuf> kuffaar: how else can it be done?
23:24:32 <mauke> lynx? I don't think the CSS effects will work there :-)
23:24:34 <c_wraith> my involvement is minor.
23:24:54 <c_wraith> There was just a feature I wanted, so I made it happen
23:24:57 <kuffaar> mbuf: Right now there is no great alternative to that actually, I intend to tackle that problem at some point
23:24:58 <quuuux> accel: RE dynamic loading, look at Hint on Hackage
23:25:09 <kuffaar> mbuf in the very least you can use map for that large list
23:25:13 <accel> quuuux: the package name is "Hint" ?
23:25:14 <c_wraith> oh.  If you're asking about dynamic loading, that *is* the part I did
23:25:19 <quuuux> accel: Yes
23:25:23 <c_wraith> accel, I think it's hint, all lowercase
23:25:26 <kuffaar> [toSql (recordId record), toSql (accountName record), toSql (split record), toSql (date record), toSql (valueDate record), toSql (cheques record), toSql (financialYear record), toSql (cr record), toSql (payee record), toSql (credit record), toSql (debit record), toSql (amount record), toSql (balance record), toSql (category record), toSql (subCategory record), toSql (budgetaryLines record), toSql (subBudgetaryLines record), toSql (notes record), toS
23:25:26 <kuffaar> ql (voucher record), toSql (reconciliationNumber record), toSql (bankReferences record)]
23:25:31 <kuffaar> That's REALLY redundant.
23:25:38 <Axman6> ya
23:25:51 <accel> c_wraith , quuuux : http://hackage.haskell.org/package/hint ?
23:26:02 <Axman6> kuffaar: what's the type of toSql?
23:26:08 <kuffaar> Axman6 http://hpaste.org/43319/string__string
23:26:13 <c_wraith> yep
23:26:21 <mbuf> kuffaar: http://hpaste.org/43320/for_kuffaar is what I get
23:26:35 <kuffaar> I am also puzzled why you use the String type for dates, IDs, amounts of money, etc
23:26:49 <kuffaar> mbuf yep, as intended
23:26:52 <mbuf> kuffaar: just a test code 
23:27:11 <quuuux> ugh. Socket-level programming, I thought I had conquered you!
23:27:57 <mbuf> kuffaar: actually, I want to get ["a, b, c"], ["d, e, f"], ["g, h, i"], split a, b, c, insert a in the first record, b in the second record and so on
23:28:16 <mbuf> s/record/column
23:28:56 <kuffaar> Missing /
23:29:02 <Jafet> ivanm: clearly you need to release more often, to catch bugs faster
23:30:53 <kuffaar> mbuf right now you can create a connection between those using a list of functions
23:31:13 <kuffaar> But in the general case you cannot use a list like that because the functions won't have the same type
23:31:16 <accel> how is leksah ?
23:31:20 <kuffaar> You would need tuples to do that then hmm
23:31:21 <accel> is it production quality?
23:31:27 <accel> anyone here using leksah for haskell coding?
23:32:00 <kuffaar> http://leksah.org/screenshots.html :o
23:32:03 <kuffaar> Never heard of it before
23:32:14 <kevinburke> just vim
23:32:19 <kuffaar> But I use emacs
23:32:42 <accel> kevinburke: what do you use for indenting ?
23:33:10 <kevinburke> I just got started really, so i just hit the tab key (which converts to spaces)
23:33:11 <Axman6> kuffaar: ping and process are exactly the same
23:33:14 <kevinburke> I'm open to suggestions
23:33:23 <Axman6> in your paste
23:33:29 <kuffaar> Axman6 that's his
23:33:38 <Axman6> whose?
23:33:38 <kuffaar> Axman6 I didn't code that >:O are you mad
23:33:43 <kuffaar> mbuf did
23:33:48 <Axman6> ah ok
23:33:52 <Axman6> mbuf: see above
23:35:08 <mbuf> Axman6 just learning by experimenting, so wrote those for testing
23:35:32 <mbuf> kuffaar, ok gotta go, later; thanks for your help
23:40:10 <n0den1te> :t >>
23:40:11 <lambdabot> parse error on input `>>'
23:40:18 <n0den1te> :t (>>)
23:40:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
23:40:36 <n0den1te> Ah, monads. how art thou? :)
23:40:49 <kuffaar> Let the terror begin
23:41:17 <n0den1te> So said SPJ. He regretted calling them monads. :P
23:41:18 <kuffaar> Haskell: Monadic terrorism
23:41:50 <kuffaar> n0den1te what name does he prefer now?
23:41:53 <kuffaar> Context?
23:43:12 <kuffaar> Axman6 have you ever checked out libpg to see what kinds of low level bindings it supports? I probably need to play around with it in C++ first to see what kind of stuff you can construct there
23:43:27 <Axman6> nope
23:44:55 <n0den1te> kuffaar: Don't know. He simply says, "We should have called them warm fuzzy things"
23:45:01 <n0den1te> :D
23:46:10 <kuffaar> n0den1te haha when did he say that? OSCON?
23:46:14 <edwardk> but then what is a comonad? =)
23:46:28 <edwardk> cowarn and cofuzzy doesn't sound very cuddly
23:46:31 <edwardk> er cowarm
23:46:46 <n0den1te> no idea. I think I got that from going over his slides from his "Haskell retrospective" talk. 
23:47:12 <edwardk> yeah the 'warm fuzzy thing' meme has been around for a very long time
23:48:59 <n0den1te> edwardk: I'm late to the show. :(
23:49:04 * hvr wonders why there's not yet a "F*cking Monads, How Do They Work?" blog-post
23:49:50 <kuffaar> Haha
23:51:20 <n0den1te> mauke: is it really true that monadic IO is unpredictable? :O I wouldn't say so, unless the programmers themselves were unaware where it goes when they coded up the program. :|
23:52:40 <kuffaar> n0den1te I wouldn't try to read too deep into that, it's perfectly predictable if done right, I think whoever said that was just expressing the general pure FP sentiment regarding side effects
23:53:47 <n0den1te> kuffaar: that's what I think. When done right, things would be predictable. I'm reading through mauke's post on haskell IO(unpredictable reference :P)
23:54:20 <mm_freak_> n0den1te: perhaps you confuse monadic IO with lazy IO?
23:54:25 <n0den1te> " IO implies evaluation order. Evaluation order is not only an implementation detail but also unpredictable in
23:54:26 <mm_freak_> because lazy IO is indeed unpredictable
23:54:28 <n0den1te>    the presence of laziness"
23:54:49 <mm_freak_> monadic IO is perfectly predictable
23:55:06 <kuffaar> Lazy IO can lead to unexpected results
23:55:24 <n0den1te> "Let the terror begin..."
23:55:34 <kuffaar> But it really depends on what you are doing
23:56:01 <kuffaar> Cominbing lazy IO and manually closing a handle is not a good idea, for example
23:56:36 * Axman6 finds iteratees quite a nice way to deal with IO in haskell, even if the types are horrible
23:56:42 <kuffaar> You can end up closing it before something is evaluated
23:56:43 <n0den1te> lazy IO is not for those who like control, hmmm. 
23:57:29 <n0den1te> s/like/&1 to be in/
23:57:29 <mm_freak_> Axman6: actually i don't find the types horrible
23:57:40 <mm_freak_> they make a lot of sense, once you've understood the concept
23:57:55 <Axman6> enumeratees are where the problems start
23:58:24 <kuffaar> I think my SCGI server code actually essentially uses lazy IO hmm
23:58:59 <n0den1te> kuffaar: are you sure it's "actually and essentially" ? :P
23:59:17 <kuffaar> No
23:59:29 <n0den1te> so that's lazy IO. 
23:59:58 <n0den1te> :-)
