00:00:34 <ezyang> c_wraith: I'm not sure that's even necessarily true: consider parallelOr 
00:00:34 <lambdabot> ezyang: You have 1 new message. '/msg lambdabot @messages' to read it.
00:00:52 <c_wraith> ezyang, that's true.  Or anything else lub does.
00:01:05 <c_wraith> I suppose that's a sufficient condition, but not a necessary one
00:01:27 * ezyang nods 
00:01:44 <ezyang> If you're using FFI for unsafePerformIO stuff the "pure" assumption mostly works. 
00:02:26 <c_wraith> yeah.  If you're Conal, there are other cases :)
00:03:31 <ezyang> Actually. Does one consider seq a pure function? :-) 
00:04:00 <c_wraith> That's a really tough question.
00:04:14 <ezyang> How about a function that is f (\_ -> 2) = True and f (\x -> case x of _ -> 2) = False :-) 
00:04:15 <c_wraith> At a denotational level, it's pure
00:05:01 <c_wraith> I guess the term "pure" is usually used to refer to the denotational property
00:05:12 <ezyang> Yep. 
00:05:35 <ezyang> actually, I wonder... 
00:05:54 <ezyang> > (\x -> case x of _ -> 2) undefined 
00:05:55 <lambdabot>   2
00:06:00 <ezyang> ah, not strong enough. 
00:06:13 <ezyang> > (\x -> x `pseq` 2) undefined 
00:06:14 <lambdabot>   *Exception: Prelude.undefined
00:06:16 <c_wraith> yeah.  seq would require a typeclass, if it wasn't magical
00:06:17 <ezyang> thar we go. 
00:08:44 <j-invariant> I don't really the point of types: They seem good at first but then they are sort of against you
00:08:56 <ezyang> That's the point! :-) 
00:09:41 <dolio> I don't see the point of tests. First they help you catch bugs, but then they fail all the time.
00:12:58 <PatrickRobotham> Just trust me dammit!
00:13:10 <PatrickRobotham> I know what I'm doing...
00:13:16 <PatrickRobotham> (famous last words)
00:17:35 * hackagebot comonad 0.1.0 - Haskell 98 comonads  http://hackage.haskell.org/package/comonad-0.1.0 (EdwardKmett)
00:20:02 <j-invariant> it's not that I want it to trust bad code I wrote
00:20:19 <j-invariant> it's that there doesn't seem to be any way to write the code at all
00:21:36 * hackagebot comonad-transformers 0.1.0 - Comonad transformers  http://hackage.haskell.org/package/comonad-transformers-0.1.0 (EdwardKmett)
00:26:37 * hackagebot comonads-fd 0.1.0 - Comonad transformers using functional dependencies.  http://hackage.haskell.org/package/comonads-fd-0.1.0 (EdwardKmett)
00:26:43 * edwardk has a lot of work to do =/
00:29:36 * applicative wonders, didn't people say, there's no 'coapplicative to speak of' but ComonadZip has parallel operations.  Or maybe not the right parallel?
00:29:54 <PatrickRobotham> j-invariant: What do you want to do/
00:30:05 <edwardk> comonadzip isn't coapplicative =)
00:30:13 <edwardk> its just 'applicative-ish'
00:30:24 * applicative then considers that these come by superadding to Comonad, instead of preceding
00:30:39 <applicative> what's the decisive difference?
00:30:41 <MrWish> Ok what does the following mean exactly: Note: Num is not a subclass of Ord. That means that what constitutes for a number doesn't really have to adhere to an ordering. So that's why we have to specify both the Num and Ord class constraints when doing addition or subtraction and also comparison.
00:30:59 <MrWish> what is meant by "that what constitutes for a number"?
00:31:00 <j-invariant> PatrickRobotham: I wanted to configure a datatype using another data
00:31:07 <applicative> or will the transcript make this plain, the stuff from above
00:31:09 <edwardk> its good enough to bolt *> and <* like syntax into a comonad, but requires that you can somehow line up two comonads
00:31:21 <edwardk> nah, i didn't say anything about comonadzip before adding it =)
00:31:47 <PatrickRobotham> MrWish: What can implement the Num Typeclass
00:32:02 <PatrickRobotham> and Num isn't a subclass of Ord, complex numbers are numbers, but they're not ordered.
00:32:14 <applicative> oh I was just thinking, it's not like applicative since it presupposes comonad, as an applicative instance might precede, not presuppose a monad one.
00:32:15 <edwardk> applicative: lemme know if you spot any obvious flaws in the package
00:32:20 <edwardk> yeah
00:32:51 <applicative> I will try to figure out what you said about 'lining up two comonads'
00:32:54 <edwardk> there is a 'coapplicative' that could exist, but it'd require coexponentials
00:33:01 <MrWish> hm here I was thinking that ordering actually constituted numbers...
00:33:22 <applicative> whats a coexponential, nothing is occurring to me
00:33:25 <edwardk> w (a -> b) -> w a -> w b — to do that, i need to be able to line up the two input 'w's and generate a third.
00:33:47 <edwardk> a + (b - a) -> a    — read the - as a coexponential
00:33:59 <edwardk> er
00:34:08 <edwardk> a + (b - a) -> b 
00:34:09 <edwardk> =)
00:34:22 <j-invariant> is that a virtual species
00:34:37 <edwardk> it probably could be
00:34:37 <applicative> I see, that's hopeless
00:35:13 <edwardk> they can't exist along side exponentials in full generality
00:35:28 <MrWish> not ordered... you mean like the sqrt of a negative cant be compared in magnitute do a sqrt of a positive? something like that? :/
00:35:36 <applicative>  no, wait, coexponential means solve a + (b-a) -> b for '-'
00:35:40 <edwardk> otherwise you can jump through some hoops and show how there can only exist at most one function of a given type, and thats kind of a boring universe.
00:35:59 <edwardk> a + (b - a) — says that you have either an a, or a (b - a)
00:36:07 <edwardk> and from that co application will give you b
00:36:19 <applicative> but if i just have an a how can i get a b, is the trouble
00:36:36 <edwardk> like i said, they make sense in very different categories than functions
00:36:38 <j-invariant> that's crazy
00:36:45 <j-invariant> how can  Left a  give you a  b?
00:36:48 <applicative> yeah, its not our world
00:36:56 <j-invariant> is it continuations?
00:37:13 <edwardk> consider the partial ordering on the natural numebrs, where you read <= as the -> of the category
00:37:15 <edwardk> 1 <= 2
00:37:26 <edwardk> 1 + (2 − 1) <= 2
00:37:30 <edwardk> holds just fine
00:37:51 <applicative> here '-' is the 'coexponential'
00:38:05 <edwardk> that is 'coapplication' of the coexponent
00:38:09 <j-invariant> I would hvae to spend some time drawing all the diagrams to see that -- makes a good excercise
00:38:21 <edwardk> there are similar constructs to currying, etc. as well
00:38:29 <edwardk> cocurrying, and uncocurrying
00:38:57 <applicative> @type (curry, uncurry)
00:38:58 <lambdabot> forall a b c a1 b1 c1. (((a, b) -> c) -> a -> b -> c, (a1 -> b1 -> c1) -> (a1, b1) -> c1)
00:40:11 <j-invariant> why is exponential ^ rather than / ?
00:40:27 <applicative> because its up
00:40:33 <edwardk> cocurry: (c <= a + b) -> (c - b <= a)
00:40:48 <MrWish> can someone give me a concrete example of where Num being a subclass of Ord would not work? Because I dont get it
00:41:03 <edwardk> mrwish: sure. integers modulo 7.
00:41:44 <edwardk> you can add them, subtract them, multiply them and then take the remainder, etc. but there is no meaningful ordering. the ordering with respect to 0 − 7 satisfies no useful laws
00:41:51 <applicative> @src Ord
00:41:51 <lambdabot> class  (Eq a) => Ord a  where
00:41:52 <lambdabot>     compare      :: a -> a -> Ordering
00:41:52 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
00:41:52 <lambdabot>     max, min         :: a -> a -> a
00:42:10 <MrWish> oh, modulo goes in cycles, right?
00:42:19 <edwardk> yeah
00:42:26 <MrWish> good point :)
00:42:29 <applicative> which is 'max' of the hours of the clock
00:42:30 <edwardk> 0,1,2,3,4,5,6, 0, 1,2,3...
00:42:44 <MrWish> ok finally something I can understand  lol
00:43:10 <edwardk> there are also perfectly good would-be-Num instances you can't Show or that you can't compare for Eq, so Show/Eq there kinda piss off the mathematically inclined
00:43:17 <applicative> I guess there could be a trivial instance
00:43:18 <edwardk> almost as much as the misguided abs/signum crap
00:43:47 <applicative> yet Num presupposed Show and Eq
00:43:51 <aefjt> > 1 == (1 + 1/10^100 :: CReal)
00:43:52 <lambdabot>   True
00:44:00 <applicative> but sensibly not Ord
00:44:26 <applicative> The Num business seems sensible enough for ordinary purposes, but one would like to be able to escape it too
00:44:41 <MrWish> whow, can you give an example of numbers where eq doesnt work?
00:44:52 <edwardk> it fits the universe we're stuck in, where having deep inheritance hierarchies is expensive for implementers
00:45:02 <c_wraith> MrWish, aefjt just gave an example
00:45:26 <edwardk> instance Num b => Num (a -> b) where f + g = \a -> f a + g a; ...
00:45:30 <c_wraith> MrWish, equality of CReal values is non-computable
00:45:51 <edwardk> which goes back to the decidability of the equivalence of functions from the other day ;)
00:45:52 <MrWish> what are CReal values
00:46:03 <aefjt> CReal is the set of all real numbers that can be listed by a computer
00:46:03 <MrWish> oh I remember that lol
00:46:05 <edwardk> CReal's are 'computable real numbers'
00:46:26 <MrWish> what like pi?  or is that irrational
00:46:27 * applicative is not impressed by this illustration, presumably wrongly
00:46:33 <MrWish> my maths is seriously lacking
00:46:37 <MrWish> are*
00:46:39 <edwardk> unlike floating point numbers they'll keep adding precision as needed
00:46:40 <MrWish> so is my grammar
00:46:53 <edwardk> so you can check them to millions of decimal places if you want
00:46:56 <Veinor> pi is a CReal because you can compute the nth digit of pi in finite amounts of time
00:47:15 <c_wraith> pi is computable.  Basically, any number you can describe in finite space is computable
00:47:24 <c_wraith> That's not *quite* true
00:47:28 <c_wraith> But it's close
00:47:31 <applicative> but you can't stip the comparison of two CReals, they wont stop
00:47:35 <Veinor> something like 'sum of f(n) * 2^-n where f(n) is 1 if turing machine T halts given n as input and 0 if it doesn't' isn't computable
00:47:38 <edwardk> but comparing two CReals for honest-to-goodness equality could take forever. you never know when one will zig and be slightly larger than the other. they could be nigh infinitely close for a long time
00:47:56 <c_wraith> The name "computable" is accurate.  the computable reals are the real numbers that can be computed.
00:48:04 <edwardk> (the creal implementation lies and just compares out to a fixed precision, but its not a correct equality)
00:48:18 <j-invariant> how can the real numbers be a unique field
00:48:26 <Veinor> fun fact:
00:48:26 <j-invariant> if the computable reals are also ...
00:48:40 <Veinor> predicates over integers aren't comparable
00:48:45 <Veinor> predicates over (predicates over integers) are
00:48:49 <MrWish> oh ok, so theres like a fraction of the number that is computable, but has a limit in infinity, or something?
00:48:54 <Veinor> where by predicate I mean 'computable predicate'
00:49:09 <applicative> MrWish, doesn't it seem plain that the usual representations of the reals, e.g as decimal expansions, will make equality generally something judged by God only
00:49:16 <edwardk> j-invariant: computable reals aren't a proper completion of the rationals. the reals are closed.
00:49:19 <MrWish> what do you mean by predicates "over integers"
00:49:21 * applicative puts a pious spin on it
00:49:27 <j-invariant> oh they are not closed huh
00:49:30 <Veinor> yeah
00:49:33 <Veinor> computable reals aren't closed
00:49:57 <ian_mi> sure they are
00:49:59 <applicative> how do we characterize closed?  we can interpolate a new level
00:50:03 <applicative> ?
00:50:05 <Veinor> by 'closed' I mean under limits
00:50:10 <j-invariant> you cannot define a bounded sequence of CReals that does not converge in haskell
00:50:19 <MrWish> I dont like to assume the existence of God lol. but I would call it epistemologically transcendent. 
00:50:21 <j-invariant> so you have to look at it from set theory (or something) I guess
00:50:41 <Veinor> http://en.wikipedia.org/wiki/Specker_sequence
00:50:50 <aefjt> "Undecidable under the Church-Turing thesis"
00:50:50 <j-invariant> not bounded not what I mean, cauchy
00:50:50 <Veinor> a sequence of computable reals whose limit is not computable
00:50:54 <ian_mi> any metric space is trivially closed
00:50:59 <ian_mi> you mean complete
00:51:04 <Veinor> yes, that's what I meant
00:51:09 <edwardk> the reals have the supremum property. every set of reals has a supremum, which is also a real number. every set of CReals does not necessarily have a computable supremum within the set.
00:51:26 <j-invariant> Veinor: wow!
00:52:06 <MrWish> ok so what is a supremum
00:52:08 <edwardk> banach-tarski/supremum property/etc tends to be the dividing line between the computable/intuitionistic world and the classical/mathematician world ;)
00:52:18 <edwardk> 'least upper bound'
00:52:21 <Veinor> yeah
00:52:32 <Veinor> smallest x such that x >= all y in S
00:52:56 <aefjt> Ok, here's another difficult Num: indices in a multiplicative group modulo p
00:52:58 <MrWish> oh yeah
00:53:33 <j-invariant> I should make my own language inside haskell
00:53:43 <aefjt> Hm, modulo n, but that's not a group anymore
00:53:47 <j-invariant> then I don't have to worry about types because I just add more when I need them
00:53:48 * aefjt withdraws it
00:53:55 <MrWish> I read that in a book, uhm, principles of biological autonomy by Varela, has anyone ever heard of that? It seems not to be held in very high esteem by "main stream" mathematicians" lol
00:53:57 <edwardk> j-invariant: works for me ;)
00:53:59 <Veinor> hey, you know something weird?
00:54:03 <MrWish> supremums I mean
00:54:08 <MrWish> and ordered sets too
00:54:09 <MrWish> lol
00:54:12 <Veinor> predicates over integers don't have decidable equality, that reduces to the halting problem
00:54:19 <Veinor> but predicates over computable reals do!
00:54:46 <edwardk> anyways you need the supremum property to do an astonishingly wide array of common operations that you perform over the real numbers. things like the intermediate value theorem break down without it
00:55:34 <aefjt> Veinor: erm, Integer is a subset of CReal
00:55:45 <Veinor> aefjt: that doesn't change the truth of my statement :)
00:56:06 <aefjt> What's a predicate?
00:56:15 <ian_mi> or even simpler square roots
00:56:17 <MrWish> are you all university level mathematicians or something lol
00:56:35 <edwardk> mrwish: there are a number of mathematicians in here ;)
00:56:39 <Veinor> aefjt: a (computable) funcction X -> [True, False]
00:57:04 * applicative wonders whether Brouwer's reals had these troubles
00:57:30 <edwardk> i just try really hard to keep from forgetting math ;)
00:57:48 <dolio> Correct me if I'm wrong, but computable functions from the computable reals to {True, False} are either const True or const False, no?
00:57:52 <j-invariant> ]/whois em em
00:58:13 <MrWish> I was consistently one of the worst math students in my class. in high school at least. I feel Ive built up quite a handicap. but I try
00:58:24 <Veinor> dolio: no
00:58:33 <Veinor> 'is the binary digit corresponding to 2^{-1} 1?'
00:58:34 <edwardk> applicative: btw- since you are the only person i know who has downloaded it. any thoughts on the comonad package ? =)
00:58:35 <MrWish> I have only really studied any of this with genuine interest since about a year or so
00:58:41 <Veinor> that's obviously computable
00:58:58 <c_wraith> in fact, that function for any binary digit will work
00:58:58 <aefjt> If you restrict the things that the predicate can say, then it might be decidable
00:59:02 <Veinor> yeah
00:59:05 <j-invariant> dolio: thta sounds like Rices theorem
00:59:14 <aefjt> But they end up not being able to say much.
00:59:19 <dolio> Veinor: I'm not sure that function is computable.
00:59:33 <j-invariant> dolio: but why not have something like 'first bit'?
00:59:37 <j-invariant> that wouldn't be constant
00:59:38 <Veinor> dolio: i think it is
00:59:48 <j-invariant> oh 0.9999999.. thing
00:59:54 <j-invariant> that's why you can never be sure
01:00:01 <aefjt> If you define computability of numbers as digit sequences, then the predicate is computable
01:00:20 <MrWish> Hm, perhaps I should just read an introductory course on set theory and or number theory
01:00:22 <aefjt> But normally it's defined in term of intervals, etc.
01:00:30 <dolio> I'm pretty sure roconnor has mentioned that all computable functions from the computable reals to a discrete domain are constant.
01:00:39 <Veinor> hm
01:00:49 <ian_mi> MrWish: analysis might be more appropriate
01:00:50 <Veinor> well, by 'computable reals', I actually mean 'computable predicates over integers'
01:00:59 <MrWish> what do you mean, analysis of what
01:01:05 <ian_mi> reals
01:01:05 <dolio> Perhaps not in those specific words, but something close.
01:01:06 <aefjt> Indeed. I'm not sure which theory of the reals Veinor is talking about
01:01:10 <j-invariant> MrWish: analysis is what calculus is made of
01:01:14 <Veinor> okay, let's start over!
01:01:22 <Veinor> if S is the set of computable predicates over integers
01:01:22 <MrWish> umm
01:01:32 <Veinor> S doesn't have decidable equality, but computable predicates over S do
01:01:54 <MrWish> you know, I am really challenged to picture anything at all with the statement "analysis is what calculus is made of"
01:02:06 <MrWish> like, I simply dont have the substance to
01:02:10 <ian_mi> MrWish: try Rudin for a good starting point
01:02:19 <MrWish> Rudin is an author?
01:02:25 <j-invariant> MrWish: do you know calculus?
01:02:33 <ian_mi> yes
01:02:51 <dolio> Veinor: Ah, okay. That's less trivial, I think.
01:02:55 <Veinor> yeah
01:03:09 <Veinor> apparently this is because computable predicates over S is a compact space, but S isn't
01:03:10 <MrWish> lol. I have studied some lambda calculus
01:03:14 <MrWish> but
01:03:17 <j-invariant> MrWish: not that type :P
01:03:22 <MrWish> I could hardly define the concept "calculus" itself
01:03:26 <dolio> As everyone knows, 2^(2^N) ~= N.
01:03:55 <j-invariant> I didn't know that..
01:04:10 <Veinor> dolio: wait, what?
01:04:19 <MrWish> yeah that seems off
01:04:24 <Veinor> but 2^X is not the same size as X for any X
01:04:39 <j-invariant> Veinor: in haskell it is always countable!
01:05:12 <MrWish> I just realised I dont know what is meant by the word calculus
01:05:23 <ian_mi> MrWish: analysis of real numbers mostly. Their definition, topology, sequences and series, functions etc...
01:05:29 <dolio> Veinor: http://math.andrej.com/2009/10/12/constructive-gem-double-exponentials/
01:05:42 <j-invariant> MrWish: it's good stuff - physics of motion is based on it
01:05:57 <MrWish> hm, ok... you mean equations with variables?
01:06:32 <ian_mi> that could be anything
01:06:39 <Veinor> dolio: http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/ is where i picked up this idea
01:07:27 <applicative> edwardk, i just started to look it over.  It could very much do with an examples directory, but perhaps that would not be kmettish.  Are you going to import it into something?
01:07:36 <edwardk> hahaha
01:07:57 <edwardk> i'm going to start bolting examples on soon. i was planning on porting some of the essence of dataflow programming over to it
01:08:21 <applicative> Veinor, such an astounding post.  There is a deflationary discussion by Oleg that I thought was unusually ill spirited
01:08:41 <dolio> Anyhow, if you take some anti-classical axioms, 2^N is computably uncountable, but 2^(2^N) is computably isomorphic to N, or something like that.
01:08:48 <MrWish> ok maybe I should sort of sketch where I am coming from, I am studying sociology, and I have taken an interest in systems theory. I have become more and more convinced of the need for formalism in these theories. Some authors have tried to define autonomous systems as elaborate patterns of self-referential relations (the "autopoietic turn" school of systems theory). 
01:08:49 <edwardk> what i wanted to focus on first was getting a correct haskell 98 comonad/comonadzip/cokleisli package together, then a set of H98-friendly transformers, before fleshing out monads-fd 
01:09:30 <edwardk> i love that Escardo post =)
01:09:37 * applicative does a bit of autopoeisis
01:09:41 <MrWish> However it is steeped deeply in continental (european) style philosophy and theory, meaning, it reads more like literature than mathematics... 
01:09:44 <Veinor> applicative: ?
01:09:44 <MrWish> oh you do?
01:09:49 <Veinor> deflationary? how so?
01:09:49 <dolio> And those anti-classical axioms are justified by some toposes. Like topological spaces and continuous functions.
01:09:53 <applicative> it is amazing, i felt the most insane joy for days after reading t
01:09:56 <Veinor> anti-classical?
01:09:57 <applicative> it
01:10:05 <dolio> Or computable sets and computable functions, probably.
01:10:18 <MrWish> you mean you study the theory? or you are talking about cell mitosis? :p
01:10:30 <Veinor> also, what exactly do you mean by 2^N?
01:10:31 <MrWish> applicative what did you read
01:10:31 <edwardk> well, its just a productivity argument. since your predicates have to complete for all inputs even infinite ones they can only inspect a finite portion of them
01:10:41 <edwardk> but its still cute =)
01:10:42 <Veinor> edwardk: yeah pretty much
01:11:02 <Saizan> Veinor: computable functions from N to 2
01:11:05 <applicative> MrWish, the Escardo post above.  It is concentrated happiness.
01:11:08 <dolio> 2^N is the set of constructive functions from N to 2.
01:11:12 <Veinor> ahhh
01:11:18 <Veinor> yeah, I could belive that
01:11:36 <edwardk> i have a scala version here somewhere from showing someone the other day
01:11:51 <Saizan> which classically is already isomorphic to N :)
01:11:55 <dolio> And normally, constructive mathematics just removes axioms from classical mathematics, but you can also add in axioms that would be inconsistent with classical axioms.
01:11:58 <MrWish> escardo post??
01:12:08 <Veinor> MrWish: http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
01:12:26 <edwardk> @hpaste
01:12:27 <lambdabot> Haskell pastebin: http://hpaste.org/
01:12:38 <Zeiris> I'd like to use quickcheck to test a system via an HTTP interface. Ideally, testing both result correctness (need an XML parser) and performance (need either a parser or a re lib for reading results out of httperf or equivalent tool).  Choosing libraries... For the XML parser, I was going to use whatever the snap suite uses. For the httperf-ripper, I'm less sure - are there any parser-combinator libs that elegantly parse streams of incoming data? I'd also
01:12:39 <Zeiris>  like some kind of xpath-based XML builder, but as I'm unsure what that even is my hopes for that library are low.
01:12:39 <dolio> So, "all maps are continuous" is one.
01:12:40 <applicative> Everyone was attacking Escardo for presupposing totality, it sneaks in stuff that makes it trivial etc  
01:12:57 <edwardk> =)
01:13:01 <MrWish> isnt cantor the guy that went nuts trying to describe this cantor space thing lol
01:13:20 <banisterfiend> MrWish: lol
01:13:20 <edwardk> mrwish: an implementation of those ideas is here: http://hpaste.org/42793/infinite_search_finite_time
01:13:41 <edwardk> but i cheat a bit at the end ;)
01:13:55 <applicative> did Brouwer prove 'all functions are continuous' with 'additional axioms"?
01:14:01 <tab> Zeiris: have a look at attoparsec, enumerator and attoparsec enumerator
01:14:06 <Veinor> applicative: totality?
01:14:06 <Zeiris> tab <3
01:14:11 <tab> Zeiris: and more high level, http-enumerator and xml-enumerator
01:14:15 <Veinor> oh, yeah
01:14:24 <Veinor> why the hell is that something to attack him for? it's still fucking amazing
01:14:48 <MrWish> ok Im still just trying to learn haskell, I cant really read your programme... :/
01:14:52 <applicative> Veinor, Escardo only finds zeros if the function is total, which of course all functions are
01:15:08 <MrWish> applicative, you mentioned you did something involving autopoiesis?
01:15:16 <Veinor> ah :P
01:15:17 <applicative> MrWish, I was just being silly
01:15:21 <MrWish> oh
01:15:27 <MrWish> yeah thought so...
01:16:14 <applicative> Of course, he writes his programs in Haskell, so this can seem a limitation sweeping things under the rug
01:19:46 <applicative> here's the gloomy Escardo reception of Oleg K http://conway.rutgers.edu/~ccshan/wiki/blog/posts/StreamPEval/  
01:21:17 <Veinor> hm
01:21:29 <Veinor> i remember he says that this is because computable predicates over Cantor is compact
01:21:31 <Veinor> how do you prove that?
01:23:31 <MrWish> ok everyone reading this article now? Ive decided its over my head lol
01:24:01 <silver> heh
01:26:31 <Zeiris> Has anyone used Etage? Using a biology metaphor to build intuition is kinda neat, though the syntax looks rather verbose.
01:26:47 <edwardk> applicative: oleg's tone can often be pretty hard to read. he has sort of the strongest Asperger-style personality i've ever seen function in the real world. i wouldn't read that as him being overtly negative so much as 'hey look at what i did!'
01:28:18 <edwardk> i do think he kind of misses the point though. of course if you constrain the problem further you can get greater speed
01:28:36 <edwardk> so its not surprising that his more limited implementation is a few times faster ;)
01:29:19 <lars9> in case n of ..., how to say case n < 0, n > 0 etc?
01:29:47 <Saizan> it's just a change of representation though, even if one is not derivable from the other
01:29:54 <Saizan> iiuc
01:29:56 <quicksilver> edwardk: Oleg's tone may be idiosyncratic but his exposition is many times clear than most intelligent people with asperger-style personalities :) 
01:30:14 <quicksilver> edwardk: his communication skills are actually strong - he explains things very well - just strange in tonality.
01:30:36 <edwardk> yeah. his tone is equally odd in person, but he's a great guy
01:30:44 <j-invariant> lars9: _ | n < 0 -> ...
01:31:30 <lars9> j-invariant: thanks, it works
01:33:29 <dolio> Oleg is many times more comprehensible than Bulat.
01:34:00 <Jafet> lars9: or case n `compare` 0 of
01:34:24 <lars9> Jafet: it works too, thanks
01:34:37 * quicksilver likes using compare, because it makes the trichotomy clear.
01:34:43 <edwardk> dolio: touche ;)
01:35:55 <Veinor> my reahm
01:36:11 <lars9> in fact it's a Maybe, so case .. of .. Nothing.. Just x | x > 0 ...
01:36:11 <Veinor> how do you define a metric over 2^(2^N)?
01:36:20 <path[l]> when ever i see edwardk I think of jeffk 
01:37:03 <edwardk> ?
01:37:06 <Veinor> i suppose you could say d(p,q) = sum of 2^-n over all n such that p(n) != q(n)
01:37:10 <Jafet> lars9: ... then ten minutes later, you find yourself writing Core
01:37:39 <path[l]> just the name
01:37:59 <edwardk> i used to just go by harmless, but then i hopped on #haskell, and there was dons, and audreyt, and a whole bunch of firstname last initial types, and i decided to grow up a bit and ditch the pseudonym ;)
01:38:33 <applicative> edwardk, I take your point, I was really expressing the feeling I had reading the Oleg K. 
01:39:00 * hackagebot appar 0.1.3 - A simple applicative parser  http://hackage.haskell.org/package/appar-0.1.3 (KazuYamamoto)
01:39:25 * applicative is discovering that the real Brouwerians are unimpressed by Specker sequences; the results are allegedly out and out classical
01:39:30 <edwardk> *nods* oleg lives in his own little world. its great because they know him there. this is the guy who in 2007 wrote something about how popular delimited continuations were becoming ;)
01:39:59 * applicative cant get enough of delimited continuations.
01:40:00 <dolio> They keep getting more popular.
01:40:00 <path[l]> hehe
01:40:13 <dolio> They let you constructively prove double negation shifts.
01:40:27 * applicative feels so lost with undelimited continuations
01:41:25 <dolio> Speaking of parsers, where's your parser library, edwardk?
01:41:35 <j-invariant> what does "constructively prove double negation shifts" mean?
01:41:38 <path[l]> edwardk:  it was a famous internet joke -> http://www.ist.rit.edu/~jxs/jargon/html/J/Jeff-K-.html
01:42:25 <dolio> It means that it preserves certain properties of constructive logic (the existence and disjunction properties) that fail in classical logic.
01:42:39 <quicksilver> lars9: just for kicks, you could do "case liftM (compare 0) n of Nothing -> ; Just LT -> ; Just EQ ->; Just GT ->; "
01:43:18 <edwardk> fair nuff =)
01:43:32 <j-invariant> do you know an example? One that you can't do without it
01:43:44 <applicative> the codensity monad of category-extras is a kind of continuation monad, but is inexplicable clear.
01:44:10 <Entroacceptor> sometimes I wonder if haskell is too abstract
01:44:25 <j-invariant> too abstract?
01:44:52 <applicative> bits are abstract, but you have to apply them in the end.
01:45:34 * applicative is trying to think of who was applying the codensity business.... Hutton and others somewhere
01:45:35 <dolio> j-invariant: I believe the disjunction property says that if you can prove P \/ Q, you can either prove P or prove Q.
01:45:42 <dolio> Which is false in classical logic.
01:46:54 <dolio> And the existence property is similar, except for existential quantification.
01:48:01 <j-invariant> exists n. P(n) means you can actually compute the value n
01:48:29 <dolio> Something like that. There must exist a particular n for which P(n) is provable.
01:48:33 <j-invariant> and with this.. ~~exists n. P(n)  you can still compute n? So what would be as statement of type 1 which you can't prove but you can prove it type 2
01:50:29 <dolio> Anyhow, the idea is that these properties are essential to constructive proofs carrying the content that makes them constructive.
01:50:52 <dolio> That you've successfully demonstrated some concrete proof.
01:51:16 <j-invariant> # For each real number x, if it is contradictory that x is equal to 0, then there exists y ∈ R such that xy = 1. <-- huh
01:51:24 <dolio> To prove P \/ Q, you must prove P or prove Q.
01:51:29 <j-invariant> this double negation thing lets you use not equal rather than apartness?
01:51:44 <dolio> You don't get certain things of that type for free, like P \/ ~P in classical logic.
01:53:01 <j-invariant> good greif this is th,e lowest quality article I have seen http://en.wikipedia.org/wiki/Markov%27s_principle
01:54:04 * hackagebot dns 0.1.1 - DNS libary in Haskell  http://hackage.haskell.org/package/dns-0.1.1 (KazuYamamoto)
01:54:11 <quicksilver> dolio: doesn't cut elimination for classical logic permit you to show that, given a proof of (P v Q) you must have either a proof of P or a proof of Q? By structural induction over the rules of LJ?
01:54:15 <j-invariant> I just don't see why wyou would want to prove  ~~P -> P
01:54:17 <j-invariant> who cares?
01:54:29 <dolio> Anyhow, the point is, I guess, that delimited continuations let you prove things like '~~ forall x. P(x) -> forall x. ~~P(x)' without upsetting this property.
01:54:44 <j-invariant> butwhat 'P' does thsi come up in practice
01:55:26 <dolio> quicksilver: I can prove Choice \/ ~Choice in ZF. Where's my proof of one or the other?
01:55:33 <lars9> quicksilver: awesome...
01:56:01 <j-invariant> if you know that a turing machine halts, this principle lets you find out when
01:57:05 * hackagebot language-javascript 0.2.1 - Parser for JavaScript  http://hackage.haskell.org/package/language-javascript-0.2.1 (AlanZimmerman)
01:57:17 <quicksilver> dolio: right. Good point. I forgot about P v ~P
01:57:38 <j-invariant> is there an example of a theorem which you need double negation shift to prove
01:58:33 <poucet> moroning
01:58:53 <Saizan> data P v Q where Left :: P -> P v Q; Right :: Q -> P v Q; ExcludedMiddle :: P v ~P -- too many constructors :)
02:01:49 <dolio> I'm not quite as sure how the existence property fails.
02:02:33 <j-invariant> if ~~exists n. P(n) that does not justify the termination of  find p [1..]
02:02:53 <quicksilver> dolio: you can find proofs of the least BLAH ordinal or least BLAH cardinal
02:03:01 <quicksilver> dolio: ...without any hope of constructing it.
02:03:16 <dolio> Yeah, but how does it enter?
02:03:28 <quicksilver> by contradiction
02:03:39 <dolio> So through excluded middle again?
02:03:43 <quicksilver> yeah.
02:03:55 <quicksilver> lots of classical set theory proofs are by contradiction.
02:04:04 <dolio> Yeah.
02:04:20 <quicksilver> in fact, for some cases of BLAH I think you can produce models in which the least BLAH {car,or}dinal varies
02:04:27 <quicksilver> so which one is the least really is independent.
02:05:34 <dolio> Anyhow, even if you don't have theorems that require the classical-ish reasoning (and I don't really know of any off hand), sometimes such reasoning is easier.
02:07:28 <Saizan> don't you need something like that to prove escardo's search from before actually finds the right 2^N if there's one?
02:09:35 <john_r_watson> is there a better way to do:  concat [[(x,y),(y,x)] | x <- [-1,1], y <- [-2,2]]
02:09:38 <john_r_watson> ?
02:10:06 <Jafet> Use bitboards
02:10:19 <john_r_watson> yields [(-2,-1), (-2,1),...]
02:10:38 <john_r_watson> bitboards?
02:11:14 <quicksilver> [ z | x <- [-1,1], y <- [-2,2], z <- [(x,y),(y,x)]]
02:11:22 <quicksilver> saves the concat and is more "in the spirit" of list comps
02:11:26 <quicksilver> it's not really any different tho.
02:11:44 <john_r_watson> perfect, couldn't get passed that mental hurdle
02:11:45 <john_r_watson> thanks
02:15:23 <McManiaC> how do you change the url from which darcs is pulling new patches?
02:15:59 <dolio> darcs pull <url>
02:16:25 <McManiaC> not just once
02:16:37 <dolio> darcs pull --set-default <url>?
02:16:47 <dolio> Something like that.
02:19:06 <banisterfiend> McManiaC: i dont knwo
02:19:16 <banisterfiend> McManiaC: shouldnt you be using git anyway?
02:19:34 <McManiaC> why should I?
02:19:50 <cdsmithus> banisterfiend: darcs is pretty common for Haskell stuff.  And it's really nice
02:19:57 <banisterfiend> cos it's the future
02:20:08 <McManiaC> I would love to, but unfortunately GHC isn't using git…
02:20:08 <cdsmithus> Umm, right.  Sure.
02:21:30 <quicksilver> git is not more the future than CVS was, or SVN was, or darc is.
02:21:33 <banisterfiend> does darcs have lightweight brnches like git?
02:21:40 <quicksilver> it's just another tool. Other tools will come along later.
02:21:49 <quicksilver> I doubt git will be as longlived as CVS was.
02:22:19 <cdsmithus> darcs has 'cp -r' for branches. :)
02:22:24 <banisterfiend> haha
02:22:32 <banisterfiend> a git branch is a pointer assignment
02:22:49 <cdsmithus> Okay.... and?
02:22:59 <banisterfiend> extremely lightweight, it encourages a whole new kind of development
02:23:05 <Saizan> if you darcs get/put somewhere else darcs uses hardlinks, so it's quite cheap
02:23:07 <McManiaC> a darcs patch is a patch
02:23:09 <McManiaC> :>
02:23:21 <Saizan> also, darcs's cherry-picking doesn't force you to branch as much
02:23:41 <Saizan> *means you're not forced to
02:23:49 <qfr> The first VCS I actually used was svn, starting back in 2008 I think. I actually coded without any form of VCS for some 9 years. I switched to git in 2009, I think.
02:24:08 <cdsmithus> banisterfiend: I'm glad you've found a tool you like.  Have fun with it.  I much prefer using darcs for small projects.
02:24:23 * quicksilver much prefers using bzr for small projects.
02:24:30 <quicksilver> plenty of room in the design space for alternative solutions.
02:24:42 <qfr> I'm glad enough when somebody even uses any form of VCS at all, I know lots of programmers who work on bigger projects and don't use any VCS at all, it's pretty baffling.
02:24:43 <McManiaC> I use git because of github ^^
02:25:50 <cdsmithus> I actually hate github.  It seems like the more poppular github becomes, the less people take the time to write a paragraph or two of introduction to their code.
02:26:33 <Entroacceptor> seonded!
02:26:33 <shachaf> cdsmithus: What does that have to do with Github?
02:26:45 <McManiaC> how is that related to github?
02:26:47 <shachaf> You mean as opposed to making a standalone website?
02:27:22 <cdsmithus> It used to be unusual to hear about something interesting, click a link, and being handed just a directory listing.  Now it's pretty much expected.
02:28:11 <shachaf> cdsmithus: I think repositories on Github are generally expected to have a Markdown README file in their root.
02:28:42 <qfr> shachaf I never do that
02:29:23 <cdsmithus> Maybe it's more a matter of presentation.  When the first thing you see is an autogenerated directory listing, it just feels like a shoddy job with poor documentation, never mind how much effort someone's really put into it.
02:29:34 <qfr> Most of my projects are super small personal things anyways, nobody else uses any of my stuff really but when they do I do write some documentation of course. Just not in a README
02:29:34 <McManiaC> github is for coding, I usually write the documentation via haddock
02:29:39 <shachaf> qfr: You just use it for Git hosting without writing anything about the project?
02:29:57 <qfr> shachaf: I briefly explain it in the description field, that's it
02:30:18 * shachaf has various issues with Github but this hasn't been one of them.
02:30:27 <tab> cdsmithus: how is it different than the situation before github ?
02:30:30 <cdsmithus> In particular, it's annoying to get a link to a Haskell project, know that if someone just linked to Hackage you'd get API docs, but instead it's a github link so you read source code.
02:30:37 <shachaf> I don't think the fact that repository hosting exists makes it significantly less likely that people will document their code.
02:30:51 <tab> cdsmithus: lots of small project didn't actually invested any time in communication either
02:33:15 <cdsmithus> It's just an impression.  I certainly seem to spend more time looking through autogenerated directory listings and reading source code when someone's project is hosted on github.  I'm not sure why it happens, or of the statistical validity of the observation.  It's still a pain.
02:33:31 <john_r_watson> Can anyone improve this (code golf): inBounds x = (x >= 1) && (x <= 8))
02:34:38 <john_r_watson> I feel like I should be able to say inBounds = someFnIDontKnow (>=1) (<=8)
02:34:49 <shachaf> @pl \x -> x >= 1 && x <= 8
02:34:50 <lambdabot> liftM2 (&&) (>= 1) (<= 8)
02:35:51 <ski> @hoogle inRange
02:35:52 <lambdabot> Data.Ix inRange :: Ix a => (a, a) -> a -> Bool
02:36:04 <shachaf> Or that. :-)
02:36:08 <john_r_watson> :)
02:36:15 <john_r_watson> many thanks
02:36:21 <john_r_watson> both helpful
02:37:03 <Jafet> http://www.cis.uab.edu/hyatt/boardrep.html
02:37:14 * hackagebot json-tools 0.1.0 - A collection of JSON tools  http://hackage.haskell.org/package/json-tools-0.1.0 (NicolasPouillard)
02:37:48 <Jafet> Can't imagine you golfing very well with arrays in haskell, though
02:38:44 <shachaf> Jafet: Well, inRange doesn't have to be used for arrays.
02:40:07 <Veinor> blah. i want to code somthing, but i have no clue what.
02:41:21 <john_r_watson> Yeah, I'm not writing chess, but playing w/ a silly knights tour (http://learnyouahaskell.com/a-fistful-of-monads#do-notation)
02:41:30 <ski> > (\(x,y) -> [(x,y),(y,x)]) =<< liftM2 (,) [-1,1] [-2,2]
02:41:32 <lambdabot>   [(-1,-2),(-2,-1),(-1,2),(2,-1),(1,-2),(-2,1),(1,2),(2,1)]
02:41:48 <Jafet> Oh. I was going to admire you for golfing such a complex thing
02:41:56 <john_r_watson> :)
02:41:56 <MrWish> john_r_watson lol I just read about that earlier today, doing the same tutorial.
02:43:13 <john_r_watson> Ya I like his tutorials.  Got distracted by Monoids trying to parse Dual/Endo when trying to figure out how implementing foldMap was sufficient for a Foldable instance
02:43:31 <Zeiris> I'm confused by these type errors: http://hpaste.org/paste/42794 (in the annotation) Aren't they both totally generic, and thus compatible?
02:43:47 <Zeiris> Is this some kind of functional dependency thing, needing to show that one will determine the other/
02:44:42 <john_r_watson> @ski: [ z | x <- [-1,1], y <- [-2,2], z <- [(x,y),(y,x)]] 
02:44:43 <lambdabot> Unknown command, try @list
02:44:45 <john_r_watson> @ski vs (\(x,y) -> [(x,y),(y,x)]) =<< liftM2 (,) [-1,1] [-2,2]
02:44:46 <lambdabot> Maybe you meant: ask src wiki
02:44:58 <john_r_watson> @pl (\(x,y) -> [(x,y),(y,x)]) =<< liftM2 (,) [-1,1] [-2,2]
02:44:59 <lambdabot> (line 1, column 42):
02:44:59 <lambdabot> unexpected "["
02:44:59 <lambdabot> expecting variable, "(", operator, "=<<", ">>>", "^>>", "^<<", ">>", ">>=" or end of input
02:45:10 <Zeiris> Though it looks like you can't do functional dependencies in GADTs?
02:45:14 <john_r_watson> @pl ((\(x,y) -> [(x,y),(y,x)]) =<< liftM2 (,) [-1,1] [-2,2])
02:45:14 <lambdabot> (line 1, column 43):
02:45:14 <lambdabot> unexpected "["
02:45:15 <lambdabot> expecting variable, "(", operator, "=<<", ">>>", "^>>", "^<<", ">>", ">>=" or ")"
02:45:15 <Jafet> asski
02:45:38 <john_r_watson> @pl [ z | x <- [-1,1], y <- [-2,2], z <- [(x,y),(y,x)]] 
02:45:39 <lambdabot> (line 1, column 1):
02:45:39 <lambdabot> unexpected "["
02:45:39 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
02:45:51 <Zeiris> PS: I really love HLint being included in hpaste. And the Haskell wiki too. <333 that
02:45:59 <john_r_watson> @pl ([ z | x <- [-1,1], y <- [-2,2], z <- [(x,y),(y,x)]])
02:46:00 <lambdabot> (line 1, column 2):
02:46:00 <lambdabot> unexpected "["
02:46:00 <lambdabot> expecting lambda abstraction or expression
02:47:12 <miron123> Hi guys, i'm sorry but i need someone who can teach me about using DDOS from IRC I can pay via paypal.
02:47:49 --- mode: ChanServ set +o quicksilver
02:47:56 <dolio> Sorry. People in this channel only know things about Eddie Haskell from Leave It to Beaver.
02:47:57 <Jafet> Zeiris: the two type variables named a refer to different types
02:48:00 --- mode: quicksilver set +b *!*miron123@*.pool.ukrtel.net
02:48:00 --- kick: miron123 was kicked by quicksilver (Wrong number. Don't call again.)
02:48:21 <shachaf> dolio: Uh-oh. Do I have to leave?
02:48:23 <Zeiris> Jafet, the two types have no restrictions on 'em though. Why can't they be the same type?
02:48:49 <Jafet> Zeiris: you can tell ghc they're the same type with ScopedTypeVariables, I think
02:53:09 <ski> john_r_watson : s/@ski/ski/
02:54:23 <ski> Zeiris : i have trouble seeing what's the difference between the paste and the annotation
02:55:18 <john_r_watson> ski: yeah... thanks
02:55:30 <john_r_watson> ski: I take it that was showing up publicly
02:55:35 <ski> what were you trying to say/ask ?
02:55:38 <ski> yes
02:55:49 <Zeiris> ski, none, I misunderstood what annotation is. I just added the error at the bottom.
02:55:51 <john_r_watson> ski: oh, just saying the list comprehension was slightly shorter
02:56:28 <john_r_watson> ski: [z | x <- [-1,1], y <- [-2,2], z <- [(x,y),(y,x)]] 
02:56:28 <john_r_watson>           vs
02:56:28 <john_r_watson>            \(x,y) -> [(x,y),(y,x)]) =<< liftM2 (,) [-1,1] [-2,2]
02:56:46 * ski cares more for which would be clearer
02:56:55 <john_r_watson> ski: crap... emacs betrayed me... and I agree
02:57:15 <ski> (and you'll have to judge for yourself, here .. i don't think there's a very clear winner)
02:57:36 <john_r_watson> ski: agreed
02:58:02 <shachaf> ski: Really? The list comprehension seems clearer to me.
02:58:17 <shachaf> Even with the extra variable.
02:58:36 <ski> (Zeiris : btw, it would have been clearer to only annotate with the error then :)
02:58:37 <shachaf> (You could get rid of it by concating explicitly, though, which might be clearer?)
02:59:06 <Zeiris> It's not my fault ski, they keep changing hpaste on me!
02:59:24 <ski> > do x <- [-1,1]; y <- [-2,2]; [(x,y),(y,x)]  -- yet another variant
02:59:25 <lambdabot>   [(-1,-2),(-2,-1),(-1,2),(2,-1),(1,-2),(-2,1),(1,2),(2,1)]
02:59:35 <knobo> where can I find documentation for the function "atomically" (as used in https://github.com/snoyberg/haskellers/blob/master/Haskellers.hs#L495 )
03:00:15 <john_r_watson> ski: hmmm... gets rid of 'z' intermediary
03:00:24 <opqdonut_> > let swp (x,y) = (y,x) in [id,swp] <*> ( (,) <$> [-1,1] <*> [-2,2] )
03:00:25 <lambdabot>   [(-1,-2),(-1,2),(1,-2),(1,2),(-2,-1),(2,-1),(-2,1),(2,1)]
03:00:28 <opqdonut_> applicative style
03:01:01 <ski> shachaf : ideally, i'd like an `forall a b c m. Monad m => (a -> b -> m c) -> (m a -> m b -> m c)' operation, here
03:01:14 <Jafet> > (\x y -> [(x,y),(y,x)]) <$> [1,-1] <*> [2,-2]
03:01:15 <lambdabot>   [[(1,2),(2,1)],[(1,-2),(-2,1)],[(-1,2),(2,-1)],[(-1,-2),(-2,-1)]]
03:01:35 <Jafet> Are we still on the course, or have we stopped for tea?
03:01:37 <john_r_watson> Jafet: nice
03:01:46 * ski looks closer at Zeiris's paste ..
03:02:06 <john_r_watson> I like what I see.  Probably time for tea.  I have to go mentally parse all these now :)
03:02:26 <ski> oh
03:03:10 <Jafet> > let xs = (\x y -> [(x,y),(y,x)]) <$> [1,-1] <*> [2,-2] in (\x y z -> x+y+z) <$> xs <*> xs <*> xs
03:03:11 <lambdabot>   No instance for (GHC.Num.Num [(a, a)])
03:03:11 <lambdabot>    arising from a use of `e_11122' a...
03:03:43 <Jafet> Bah, fmap on (,) doesn't dwiw
03:04:22 <Jafet> > let xs = (\x y -> [[x,y],[y,x]]) <$> [1,-1] <*> [2,-2] in zipWith3 (\x y z -> x+y+z) <$> xs <*> xs <*> xs
03:04:24 <lambdabot>   No instance for (GHC.Num.Num [a])
03:04:24 <lambdabot>    arising from a use of `e_111223' at <i...
03:04:27 <ski> Zeiris : in the `eval (Pop :>>= is) (a:stack) = ...' equation, the type of `Pop' is `Cmd x', for some unknown type `x', which is probably not the same as the type of `a', the only other thing we know about `x' is that `is :: x -> ProgramView Cmd a' (where `a :: a')
03:04:36 <shachaf> Jafet: What do you want it to do?
03:04:57 <john_r_watson> (\(x,y) = (y,x))
03:05:07 <john_r_watson> is that defined anywhere?
03:05:17 <john_r_watson> @pl: (\(x,y) = (y,x))
03:05:18 <lambdabot> (line 1, column 9):
03:05:18 <lambdabot> unexpected "="
03:05:18 <lambdabot> expecting operator, pattern or "->"
03:05:21 <Jafet> fmap f (a, b) = (f a, f b) -- of course, that's only valid for (a,a)
03:05:23 <shachaf> @pl \(x,y) -> (y,x)
03:05:23 <lambdabot> uncurry (flip (,))
03:05:39 <john_r_watson> ah...
03:05:42 <john_r_watson> @pl \(x,y) -> (y,x)
03:05:43 <lambdabot> uncurry (flip (,))
03:05:45 <shachaf> Jafet: That's not fmap on (,).
03:05:46 <john_r_watson> there we go... thanks
03:05:48 <ski> Zeiris : probably similar in the other cases
03:05:55 <Jafet> shachaf: precisely
03:06:09 <Jafet> There isn't a predefined arrow thingy for that either
03:06:56 <ski> (Zeiris : this is assuming `(:>>=) :: forall a x. Cmd x -> (x -> ProgramView Cmd a) -> ProgramView Cmd a' .. i haven't seen `Control.Monad.Operational' before)
03:06:58 <shachaf> > (snd &&& fst) (1,2)
03:06:59 <lambdabot>   (2,1)
03:07:06 <Jafet> Well, there's (f***f), which I hereby dub the london bridge operator
03:07:31 <cpa_> hi there
03:07:53 <cpa_> I have an issue with Network
03:08:28 <cpa_> I have an IP address, given as a Word32 and I want to get the corresponding HostName
03:08:33 <cpa_> how should I do that?
03:08:49 <john_r_watson> shachaf: fancy
03:08:57 <ski> @type let fmap :: forall f. (forall a. a -> f a) -> (forall a0 a1. (a0,a1) -> (f a0,f a1)); fmap f (a0,a1) = (f a0,f a1) in fmap
03:08:58 <lambdabot> forall (f :: * -> *) a0 a1. (forall a. a -> f a) -> (a0, a1) -> (f a0, f a1)
03:09:25 <john_r_watson> shachaf: where's &&& from
03:09:26 <john_r_watson> ?
03:09:38 <shachaf> @index (&&&)
03:09:39 <lambdabot> Control.Arrow
03:09:54 <john_r_watson> shachaf: slick
03:09:55 <quicksilver> cpa: getHostByAddr AF_INET ipaddr, I think
03:10:26 --- mode: quicksilver set -o quicksilver
03:10:47 <ski> @type let fmap :: forall r. (forall a b. r a b => a -> b) -> (forall a0 a1 b0 b1. (r a0 b0,r a1 b1) => (a0,a1) -> (b0,b1)); fmap f (a0,a1) = (f a0,f a1) in fmap
03:10:48 <lambdabot> malformed class assertion
03:11:23 <tim13> when I ask for pointfree \x y -> u (v x y), I get (u .) . v -- is this the usual way to write it?
03:11:38 <Jafet> I think I tried to write that class once
03:11:52 <ski> you can also say `u .: v' if you define `(.:)' appropriatedly
03:11:53 <Jafet> For defining a transparent identity functor
03:11:55 <ski> also
03:11:57 <ski> @wher sec
03:11:58 <lambdabot> Maybe you meant: where where+
03:12:01 <ski> @where sec
03:12:01 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
03:12:06 <ski> tim13 : ^
03:12:19 <ski> Jafet : which class ?
03:12:36 <Jafet> ski: r
03:12:53 <Jafet> Or something similar to it
03:12:53 <ski> the `r' there was to be a locally bound variable
03:13:05 <shachaf> @faq Haskell can do that?
03:13:06 <lambdabot> The answer is: Yes! Haskell can do that.
03:13:07 <tim13> ski > thanks, Brent already told me to read that ... I really have to do it I guess
03:13:24 <ski> i.e., not any specific globally defined class -- rather, in different circumstances, it could be instantiated to different classes
03:13:34 <Jafet> @help type
03:13:35 <lambdabot> type <expr>. Return the type of a value
03:14:17 <Jafet> Bah, I got used to :t
03:14:25 <tim13> what is @where ?
03:14:33 <shachaf> Jafet: :t is an abomination.
03:14:35 <ski> tim13 : the basic idea here is to define `result :: (b0 -> b1) -> ((a -> b0) -> (a -> b1))' and `argument :: (a1 -> a0) -> ((a0 -> b) -> (a1 -> b))'
03:14:42 <silver> tool to remember useful stuff
03:14:46 <silver> @where rwh
03:14:46 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
03:15:02 <shachaf> ?where ?where
03:15:03 <lambdabot> ?where ?where
03:15:05 <tim13> rwh ... I see
03:15:19 <silver> @where haskell
03:15:19 <lambdabot> http://haskell.org
03:16:43 <ski> tim13: and then `(u .) . v' / `u .: v' becomes `result (result u) v' which can be written like `(result . result) u v' meaning "modify the result of the result with `u', in `v'"
03:17:13 <shachaf> And then .:: and so on?
03:17:29 <shachaf> Didn't Oleg or someone write a magical combinator that worked for the right number of arguments?
03:17:32 <ski> if you like :)
03:17:42 <ski> heh, i'd not use that
03:18:06 <ski> (in general, it is ambiguous what "the right number of arguments" is)
03:18:13 <tim13> it will take some time, but I'm going to learn it
03:18:44 <ski> tim13 : anyway, `(.:) = (.) . (.)', `(.::) = (.) . (.) . (.)', &c.
03:18:54 <tim13> lol
03:19:03 <ski> (if you dislike the naming of those, blame me)
03:19:24 <shachaf> ski: I dislike the naming of those. But I admit that it maintains the right number of dots.
03:19:47 <ski> well, that was the main point with it :)
03:19:53 <tim13> are you Conal?
03:19:56 <ski> no
03:20:00 <ski> conal is Conal
03:20:06 <ski> preflex: xseen conal
03:20:07 <preflex>  conal was last seen on freenode/#haskell 2 days, 10 hours, 40 minutes and 28 seconds ago, saying: oh yeah. boot camp.
03:20:21 <shachaf> preflex: help xseen
03:20:21 <preflex>  xseen NICK - report when a user has been seen (on any network)
03:20:23 <tim13> oh, what a strange new world this is ...
03:20:59 <tim13> I ask a question everybody in my usual surroundings couldn't answer in weeks and here I get it in 3 sec
03:21:46 <tim13> do you all use IRC in emacs?
03:22:01 <shachaf> tim13: Of course not.
03:22:04 <quicksilver> few of us do, I suspect.
03:22:07 <quicksilver> maybe we should ;)
03:22:19 <tim13> just tried for the first time and I like it
03:22:51 <tim13> how many people are the core of #haskell?
03:23:51 <quicksilver> 30? 40? I don't know really.
03:24:03 <quicksilver> dons used to have some statistics but I think they broke.
03:24:22 <lars9> @hoogle readint
03:24:23 <lambdabot> Numeric readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
03:24:23 <lambdabot> Data.ByteString.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
03:24:23 <lambdabot> Data.ByteString.Lazy.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
03:24:26 <tim13> I guess most know each other from conferences?
03:24:41 <quicksilver> http://www.cse.unsw.edu.au/~dons/irc/haskell.html
03:25:01 <quicksilver> I've not met anyone here at the moment, although I've met a few who are here occasionally.
03:25:50 <tim13> this statistics page is amazing lol
03:25:59 * shachaf will probably meet conal next month at the Hackathon.
03:26:00 <quicksilver> it's very out of date
03:26:15 <quicksilver> @tell dons did I ever mention your IRC stats script stopped running?
03:26:15 <lambdabot> Consider it noted.
03:26:26 <shachaf> quicksilver: That whole website is very outdated.
03:26:37 * shachaf doubts the logs are up to date.
03:27:01 <tim13> if someone writes such funny (as opposed to useful) tools, it really means the language must be practical
03:27:22 <shachaf> tim13: That stats script isn't written in Haskell.
03:27:32 <tim13> :-(
03:27:50 <shachaf> http://pisg.sourceforge.net/
03:27:59 <arcatan> it's Perl! now that's a practical language.
03:28:02 <tim13> everybody here seems to know everything ... I don't get it
03:28:23 <shachaf> @faq Can Haskell teach you everything?
03:28:24 <lambdabot> The answer is: Yes! Haskell can do that.
03:28:57 <quicksilver> shachaf: for a long time the stats were up to date even thought the website wasn't.
03:29:05 <quicksilver> shachaf: but, eventually, it stopped.
03:29:18 <quicksilver> tim13: the key word is "seems".
03:29:23 <quicksilver> seeming to know everything is easy ;)
03:30:05 <arcatan> i, for one, don't know how to prove the Riemann hypothesis
03:30:22 <tim13> ok that's another story
03:30:45 <burp> maybe it's in the back of your mind, without letting you know
03:31:05 <shachaf> Perhaps tim13 meant "everybody here seems to know everything that anybody here knows".
03:31:19 <shachaf> Perhaps everybody is the same person here.
03:31:27 <tim13> no I didn't mean it this way
03:31:39 <shachaf> @quote stereo
03:31:40 <lambdabot> omnId says: geez, how many metastereo quotes are going to be @remembered?  >_>
03:31:43 * shachaf raises the dead.
03:31:53 <shachaf> (With bad timing, too.)
03:32:10 <tim13> I meant I get not only all questions answered at once - I get even answers for questions I didn't ask
03:32:38 <koala_man> I love how "think" is the most used word
03:34:52 <tim13> I'd like to know what percentage of the good Haskellers work in the industry, not at universities
03:35:09 <Jafet> john_r_watson: knight3 (x,y) (x',y') = abs<$>[x-x',y-y']`elem`concat[[(a,b),(b,a)]|a<-[0,2,4,6],b<-[1,3,5],(a,b)/=(6,5)])
03:35:54 <Jafet> Wait, I broke something
03:36:06 <shachaf> tim13: I don't think that many Haskellers work at universities.
03:36:31 <Jafet> knight3 (x,y) (x',y') = map abs [x-x',y-y']`elem`concat[[[a,b],[b,a]]|a<-[0,2,4,6],b<-[1,3,5],(a,b)/=(6,5)]
03:36:31 <lars9> @hoogle Pattern
03:36:32 <lambdabot> Control.Exception data PatternMatchFail
03:36:32 <lambdabot> Control.Exception PatternMatchFail :: String -> PatternMatchFail
03:36:32 <lambdabot> Control.OldException PatternMatchFail :: String -> Exception
03:38:02 <tim13> oh, that surprises me
03:39:30 <ski> tim13 : i think that's part of the atmosphere of #haskell. you can contribute by answering and helping newbies (and others) with the things you know about, and being friendly in general
03:40:40 <tim13> then how much Haskell do you use at work and in what ways? I guess there aren't many companies with "Haskell Teams"
03:41:22 <Jafet> Do many people here work?
03:42:34 <tim13> Jafet: that would be nice to know
03:42:48 <koala_man> I'm sure there are a lot who at least should be working
03:43:37 <tim13> I can't imagine that very many < 18 year olds have patience to learn Haskell
03:43:53 <Zeiris> Haskell heavily affected my non-Haskell code. My use and understanding of generics/templates in Java/C++ improved, my design of dynamically typed programs/programs in general greatly improved, and the introduction to really high level, parametric data types like Monoids has really improved my system design abilities.
03:44:16 <Zeiris> So even if I don't use any Haskell at work (which I do when I need to hack together a complex utility quickly)... I use the hell out of it daily :p
03:44:41 <quicksilver> tim13: not very many <18 year olds have the patience to learn programming.
03:45:01 <quicksilver> of those that do, I doubt haskell is particularly harder than whatever else they might learn.
03:45:36 <Zeiris> <18 programmers tend to be motivated by concrete results... and Haskell's payoffs take a while to appear.
03:46:03 <tim13> Zeiris: the main effect for me from learning Haskell up to now is that I loose interest in the work I have to do in my job :-( because it bores me
03:46:29 <Zeiris> Yeah, there's that. I catch myself thinking "man, this would be so much easier if I had <feature>".
03:46:38 <__yhvh__> newbie Q: I want to draw two windows at the same time, Graphics.Rendering.Chart, how can I do this?
03:46:40 <Jafet> Haskell is the rightmost elevator in the lobby of the ivory tower.
03:47:04 <tim13> but I still have to walk a long way ...
03:47:09 <Zeiris> Of course, working on Erlang means I don't think so -that- often. I implemented a crude fmap today.
03:47:34 <tim13> but you'd prefer Haskell to Erlang?
03:48:11 <tim13> I'm asking this because I read a blog entry where somebody tried an app first in HAskell and later changed to Erlang
03:48:19 <john_r_watson> Jafet: did that knight3 work for you?
03:48:26 <Zeiris> Sort of. The desire for <foo> goes both ways - Haskell (and all other languages I'm familiar with, really) don't have Erlang's battle-tested libraries and built-in parallel error handling support.
03:48:46 <Zeiris> That would probably be jlouis and his eTorrent/Combinatorrent experiment. :)
03:49:28 <Jafet> john_r_watson: I've proved it correct, not tried it
03:49:37 <nomemory> I have a map with with operators and their associated lambdas: http://hpaste.org/42796/map_of_lambda_functions . How do I retrieve the element from the Map and use the returning functions to calculate two arguments ?
03:49:39 <Zeiris> If someone manages to implement Erlang-style distribution+error handling into Haskell, with a library that's stable and complete enough to be used in production, there'll be no reason to use Erlang.
03:49:44 <Saizan> Zeiris: didn't he do the opposite?:)
03:49:55 <john_r_watson> Jafet: looks good I believe
03:50:00 <Zeiris> I dunno if he actually made a decision :p
03:50:02 <Jafet> john_r_watson: also, it's for an infinite chessboard
03:50:36 <john_r_watson> I do have a question regarding defining "global closures"
03:50:37 <Saizan> i know Combinatorrent came after hid client in erlang, i haven't heard much from him lately though
03:50:57 <john_r_watson> for instance knight3 (x,y) (x',y') = map abs [x-x',y-y'] `elem` moves 
03:50:57 <john_r_watson>   where moves = concat [[[a,b], [b,a]] | a <- [0,2,4,6], b <- [1,3,5], (a,b) /= (6,5)]
03:51:00 <quicksilver> Zeiris: distribution is a bit fiddly; but what is parallel error handling?
03:51:03 <Zeiris> He's fairly active in #erlang and mucks with etorrent regularly. I don't know if that means Erlang won.
03:51:14 <john_r_watson> moves is going to be calculated on every application of knight3 correct?
03:51:52 <Jafet> nomemory: so what you want, in Haskell notation, is (someFunction ops "+") 1 2
03:52:04 <Zeiris> quicksilver, the ability to monitor a process for death from another process. Possibly locally, possibly across transparent distribution.
03:52:08 <john_r_watson> I assume Haskell isn't smart enough to realize it's independent of the parameters and is effectively static
03:52:12 <Jafet> The documentation for Data.Map should tell you what someFunction is really called
03:52:12 <Zeiris> That... Seems to be the core of what makes Erlang awesome.
03:53:10 <Jafet> john_r_watson: since Haskell the language is pure, it doesn't matter either way. GHC would probably make it a CAF
03:53:10 <nomemory> Jafet I want a function that receives a string (the operator) and two floats, and using the ops map, calculate the result based on the operator
03:53:24 <john_r_watson> Jafet: CAF?
03:53:28 <john_r_watson> @hoogle CAF
03:53:29 <lambdabot> No results found
03:53:39 <Jafet> Note that evaluating it only once means that you need memory to store it for future use.
03:53:44 <Jafet> So there is a tradeoff.
03:53:59 <john_r_watson> Jafet: right, I wouldn't mind an explicit trade off
03:54:01 <quicksilver> Zeiris: Hmm. Well, the distribution part is (still) fiddly, but the other part ought to be implementable by wrapping your process in an exception handler which it forwards to listeners, no?
03:54:14 <Jafet> CAF is constant applicative form, or perhaps what you meant by "\"global closures\""
03:54:23 <john_r_watson> i.e. in JavaScript var knights3 = (function() { var list = ...; return function(a,b) { ...});
03:54:34 <quicksilver> Zeiris: I'm interested that this seems to you to be the critical part of erlang
03:54:41 <john_r_watson> Jafet: by that I mean leaving it up to the developer
03:54:53 <Jafet> Actually, that list is probably evaluated each time, because it's not let-bound. But I'm not sure what GHC really does.
03:55:58 <Jafet> You can compile it and read the core to see what really happens
03:56:20 <quicksilver> Jafet: GHC will lift constants out of lambdas sometimes, but I don't know what the exact rules are.
03:56:25 <john_r_watson> Yeah - I may out of curiosity
03:57:05 <john_r_watson> thanks everyone for playing knight golf :)
03:57:09 <Zeiris> quicksilver, yeah, with enough abstraction something like that might do it. I'm not sure how the exception would be typed - probably very weakly, since attempts to type Erlang floundered at the message passing. The reason it seems to be critical, is because as far as I can tell the starting principle of Erlang, the thing that ends up making it useful and giving it its niche and making its libraries do things other languages simply can't... Is the idea tha
03:57:09 <Zeiris> t horrible failure is inevitable, and the best bet for safely handling that failure is doing it from a machine halfway across the world. Since that's the only way to deal with hardware/OS/load failures.
03:58:08 <quicksilver> Jafet: JaffaCake tells me it probably does (lift 'moves' to the top level so it only gets allocated once)
03:58:09 <Zeiris> ... Based on that principle, Erlang builds parallelism+transparent distribution, and detailed error handling across the parallel, possibly distributed boundary, into the very language. And from that, stems a whole ton of other stuff, which eventually gets called Erlang and praised for doing certain things very well.
03:58:50 <quicksilver> Zeiris: *nod*
03:59:49 <lars9> im using parsec, in a do block of a GenParser, i used when (...) $ fail "invalid ...", but i found it just fails that parser, not rising an error
03:59:57 <Zeiris> If you remove the distribution, many of Erlang's nice features with respect to error *recovery* (the parallel error handling allows the implementation of really, really nice error recovery strategies :D) could still be implemented. You just wouldn't be able to deal with big hardware/load errors in a transparent way.
04:00:08 <lars9> how to stop and raise an error in such case?
04:01:28 <Zeiris> The other killer feature (which seems, to my surprise, to be somewhat doable in Haskell) of Erlang is hot code reloading. But this is only useful because the power of error recovery allows systems to run pretty much forever, so without that it isn't worth worrying about.
04:03:34 <Zeiris> (I've wondered about duplicating Erlang in Haskell for quite a while now, since there'd be a TON of benefits. The problem still seems gargantuan due to the amount of real-world testing Erlang has undergone, but I think I'm starting to isolate a 'core' set of features which could be a sufficient start.)
04:05:20 <quicksilver> Zeiris: distribution has been solved for haskell three times, IIRC.
04:05:26 <quicksilver> Zeiris: each one has bit-rotted
04:05:30 <quicksilver> I'm not sure what to conclude from that.
04:05:39 <Zeiris> How/where?/
04:06:05 <quicksilver> (1) Glasgow Distributed Haskell (2) Mobile Haskell (3) some project using YHC + bytecode
04:07:49 <silver> oh and by the way
04:08:14 <tim13> would you write something else instead of wrap .: mplus `on` unwrap?
04:08:21 <silver> I wonder if someone works to get haskell to android
04:10:51 <Zeiris> If I'm right, all that's needed for Hasklang is message passing between "processes" which is 1. untyped/very loosely typed, to support arbitrary exception info 2. transparently distributed. Which is probably a lot simpler to solve than "distributed Haskell" - it's just a message-passing backend with some wrapped functions. An Erlang monad, perhaps, which is 1. assigned a process id when run 2. can send to arbitrary Pids and receive stuff to a message box 
04:10:51 <Zeiris> and 3. can monitor Pids for death.
04:11:48 <quicksilver> Zeiris: the problem is that you want to pass arbitrary haskell values as messages
04:11:58 <quicksilver> Zeiris: and arbitrary haskell values includes functions and IO actions
04:12:04 <quicksilver> ...so basically you're back to passing code.
04:12:15 <Zeiris> Yeah, that and characterizing exceptions in terms detailed enough to be able to programmatically handle them in a useful way... Are difficult.
04:12:15 <ski> tim13 : i would probably define an operation `forall a0 a1 b0 b1. (a1 -> a0) -> (b0 -> b1) -> ((a0 -> a0 -> b0) -> (a1 -> a1 -> b1))'
04:12:23 <quicksilver> if you're prepared to restrict to some class of "Plain Old Data" messages, then it's a much simpler problem.
04:12:37 <quicksilver> but aren't erlang processes mobile, too?
04:12:51 <Zeiris> The values don't need to be arbitrary Haskell - they just need to be enough to describe what crashed. Provide enough crash information to handle the failure.
04:12:56 <quicksilver> moving a process from one host to another is more complex than a plain data message
04:13:32 <ski> tim13 : `forall a0 a1 b0 b1. (a1 -> a0) -> (b0 -> b1) -> ((a0 -> b0) -> (a1 -> b1))' probably already exists in SEC .. otherwise i'd call it `(~>)' or `function' or something similar
04:14:14 <ski> (this latter operation being the mapping function for the difunctor `(->)')
04:14:19 <Zeiris> They are not mobile. They are, ideally, only storing their state inside the parameters of their tail-recursive function, and thus can be moved by sending state to another process which "replaces" them... But I haven't actually seen that used.
04:14:38 <quicksilver> oh, OK.
04:15:09 <Zeiris> You could only really do that with processes that aren't linked to a bunch of others in a supervision tree/being monitored. Since to move it you'd need to update all the links/monitors as to the new location, which pretty much needs built-in language support.
04:15:53 <tim13> ski: oh dear ... thatS too much for me right now
04:16:14 <tim13> have to read sec first
04:16:38 <Zeiris> quicksilver, what's the most detailed error monad out there? Starting with something that gives a ton of information about exceptions and looking at the data type it uses to do so may help.
04:18:32 <Zeiris> Erlang catches all failures in a fairly standard form made up of lists, tuples, "atoms" (arbitrary enums/tags), and numbers. This makes it easy to pattern match on arbitrary exceptions, and add handling as the need arises.
04:20:39 <Zeiris> Which means no custom exception types (:() just something for bad matches (no function/case clause) that identifies which function the match failed in and what input caused the failure.
04:21:40 * ski idly wonders what "arbitrary exception info" means ..
04:22:52 <Zeiris> Info that can come from anywhere in the system, and thus has no type. But can still have useful information that uniquely identifies where and how the exception came about, extracted from it.
04:24:45 <ski> i don't really follow on the "thus", there
04:26:40 <Zeiris> Well, suppose you've got a web server process, and you want to make sure it stays up. So you've got a second process monitoring it for failure, and logging details about the failure + restarting the server if it occurs.
04:29:41 <Zeiris> The server might fail due to hardware failure, or someone killing the process - it can't be trusted to even save logs, do any kind of error handling: all information needed about the failure must be passed on to the supervisor process. Which, given the number of possible failures, is quite a lot of variety.
04:29:42 <ski> what kind of failure are we talking about, here ?
04:30:03 <ski> failed pre-conditions / post-conditions (i.e. algorithm bugs) ?
04:31:16 <Zeiris> Anything that causes it to not work as intended - failed asserts, non-total function hitting bad input, divides by zero, segfaults, power outages, etc.
04:31:38 <Zeiris> All of which can kinda be handled by restarting the thing and hoping it doesn't happen again.
04:41:46 <leino> hi all, Im wondering why haskell cant decide which '*' operator I am referring to in the following code: http://haskell.pastebin.com/3v2z66Ds
04:43:12 <sipa> leino: the Prelude also has a (*) operator
04:43:28 <sipa> you need to either hide that one, or disambiguate
04:43:57 <leino> sipa: I like disambiguate more than hide
04:44:15 <sipa> well, easiest solution is just to give it another name :)
04:45:13 <leino> hehe, but then I wont learn anything
04:46:11 <leino> ok, the prelude * is defined on Num's
04:52:20 <Saizan> the error message shows how to disambiguate
04:53:01 <leino> Saizan: really?
04:53:22 <leino> mine just says what I have pasted at the top in the comment
04:53:41 <Saizan> Prelude.* vs. Main.*
04:53:53 <Saizan> i'm referring to the one in your paste
04:54:02 <quicksilver> Saizan: that's not real syntax AFAIK.
04:54:14 <quicksilver> Main.* and Prelude.* don't work unless you import them qualified explicitly?
04:54:19 <leino> so I can write "f x = 2.0 Prelude.* x"?
04:54:20 <quicksilver> (and you can't import yourself qualified, either)
04:54:38 <Saizan> i think it works anyway
04:54:45 <Saizan> > 2 Prelude.
04:54:45 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
04:54:49 <Saizan> > 2 Prelude.* 4
04:54:50 <lambdabot>   8
04:55:04 <leino> quicksilver: neal stephenson fan? :)
04:55:05 <Jafet> lambdabot hides Prelude
04:55:11 <Jafet> > 1 P.+ 1
04:55:13 <lambdabot>   2
04:55:17 <quicksilver> Saizan: hmm, so it does.
04:55:18 <Saizan> lambdabot doesn't import qualified Prelude
04:55:30 <quicksilver> Saizan: is that correct haskell though?
04:55:52 <Saizan> quicksilver: i haven't read the haskell report on this
04:57:15 <leino> ok I think what I probably want is to make my 'Debuggable' a class
04:57:17 <quicksilver> I think it is correct haskell, and I have always misunderstood.
04:57:20 <quicksilver> interesting.
04:57:59 <Jafet> > Prelude.(+) 1 1
04:58:00 <lambdabot>   Not in scope: data constructor `Prelude'
04:58:35 <quicksilver> > (Prelude.+) 1 1
04:58:36 <lambdabot>   2
04:58:50 <sipa> > 1 `Prelude.+` 1
04:58:52 <lambdabot>   <no location info>: parse error on input `Prelude.+'
04:58:58 <sipa> > 1 `Prelude.(+)` 1
04:59:00 <lambdabot>   <no location info>: parse error on input `.'
04:59:04 <sipa> > 1 `(Prelude.+)` 1
04:59:05 <lambdabot>   <no location info>: parse error on input `('
04:59:12 <sipa> > 1 Prelude.+ 1
04:59:13 <lambdabot>   2
04:59:32 <leino> what if you have a function named Prelude?
04:59:35 <Jafet> `` should accept arbitrary expressions, to save more parens
05:00:13 <sipa> leino: that wouldn't be a problem
05:00:19 <quicksilver> leino: you can't; P is a capital letter.
05:00:25 <sipa> a constructor is a function
05:00:29 <gds> It could be a data const...
05:00:32 <gds> Yeah :)
05:00:35 <quicksilver> if you have a constructor, you have an ambiguity.
05:00:39 <sipa> no
05:00:42 <quicksilver> you have to leave a space around the .
05:00:51 <quicksilver> if you want function composition
05:00:55 <sipa> oh yes
05:01:07 <quicksilver> for capital letters, the module interpretation takes priority.
05:01:17 <gds> Cool.
05:01:26 <quicksilver> "Just.f" is the identifier f in the module Just, "Just . f" is the composition of Just and f
05:03:03 <arnihermann> I'm having troubles installing yst, cannot satisfy -package-id HStringTemplate-0.6.6-1fcd06c6d648ebedf0b317da5fa122e5: HStringTemplate-0.6.6-1fcd06c6d648ebedf0b317da5fa122e5 is unusable due to missing or recursive dependencies: parsec-2.1.0.1-7870980cc2bb152fe7085c791a54d527
05:03:24 <arnihermann> however, hstringtemplate and parsec are both installed
05:03:55 <ivanm> possibly broken versions
05:03:59 <ivanm> arnihermann: "ghc-pkg check"
05:04:08 <Jafet> All these problems will go away once our modules become functors
05:04:08 <arnihermann> no output
05:04:56 <arnihermann> ivanm: got no output from ghc-pkg check
05:05:06 <ivanm> hmmm...
05:05:11 <ivanm> Jafet: in the ML sense?
05:05:26 <Jafet> In the jocular sense, but yes
05:05:36 <arnihermann> is there no way to remove a package with cabal?
05:05:39 <ivanm> arnihermann: ghc-pkg field parsec id
05:05:58 <ivanm> arnihermann: nope; ghc-pkg unregister foo and then manually delete the directory in ~/.cabal
05:09:30 <arnihermann> ivanm: thanks
05:09:34 <ivanm> np
05:19:53 <Saizan> Jafet: that'd magically make ghc produce stable ABIs ?
05:20:27 <Botje> magic or your money back!
05:31:52 <lelf> well, 1> B = term_to_binary(fun(A) -> A+1 end).
05:31:53 <lelf> <<131,112,0,0,2,185,1,213,76,172,89,236,217,232,254,184,
05:31:53 <lelf>   178,23,144,76,140,192,206,0,0,0,2,0,0,...>>
05:31:55 <lelf> 2> F = binary_to_term(B).
05:31:58 <lelf> #Fun<erl_eval.6.13229925>
05:31:59 <lelf> 3> F(3).
05:32:02 <lelf> 4
05:32:05 <lelf>  
05:32:08 <lelf> nice to have :)
05:44:23 <ski> > Debug.QuickCheck.generate 10 (mkStdGen 12345) (liftM (\f -> map f [False,True] :: [Bool]) Debug.QuickCheck.arbitrary)
05:44:25 <lambdabot>   Not in scope: `Debug.QuickCheck.generate'Not in scope: `Debug.QuickCheck.ar...
05:44:32 <quuuux> is there a way to avoid listing everything in the Other-Modules field? I have a library that has a lot of internal modules, but only one externally visible module, and it seems tedious and fragile to maintain a list of all the internal ones in the .cabal file
05:46:10 <quuuux> the obvious short-term solution, of course, is to use a tool to generate such a list, but it feels like Cabal shouldn't need its hand held for this
05:47:24 <ski> dcoutts would probably know
05:47:31 <ski> preflex: xseen dcoutts
05:47:31 <preflex>  dcoutts was last seen on freenode/#haskell 16 hours, 2 minutes and 44 seconds ago, saying: hvr: we'll likely add a cabal install --dependencies-only
05:48:16 <pastorn> where is the function that triggers the GC?
05:48:28 <Saizan> System.Mem.performGC
05:48:29 <pastorn> (using GHC 6.12.3)
05:48:33 <pastorn> Saizan: thanks :D
05:48:50 <pastorn> Saizan: is there a possibility to set a maximum GC time, like in java?
05:49:01 <pastorn> like, how many microseconds it's allowed to live
05:53:51 <quicksilver> pastorn: I don't think so, although you can tune some aspects of GC
06:05:36 <Saizan> there are quite a few +RTS flags for it
06:15:35 <aristid> preflex: seen augustss
06:15:35 <preflex>  augustss was last seen on #haskell 4 days, 17 hours, 27 minutes and 20 seconds ago, saying: True
06:22:28 * edwardk ponders what it is that keeps http://hackage.haskell.org/package/comonad from building on ghc 7
06:23:34 <edwardk> ah off by one error
06:23:45 <dolio> Base 4.3
06:23:50 <edwardk> ya
06:24:02 <edwardk> thats what i get for throwing an upper bound on there without thinking =)
06:25:25 * hackagebot comonad 0.1.1 - Haskell 98 comonads  http://hackage.haskell.org/package/comonad-0.1.1 (EdwardKmett)
06:25:41 <ClaudiusMaximus> byorgey: seems to work! http://hpaste.org/paste/42770/refactor_my_reducer_annotatio#p42801
06:26:05 <ClaudiusMaximus> ddarius: 3 kinds of lambda for 3 different evaluation strategies (applicative order, normal order, lazy)
06:27:25 * hackagebot comonad-transformers 0.1.1 - Haskell 98 comonad transformers  http://hackage.haskell.org/package/comonad-transformers-0.1.1 (EdwardKmett)
06:27:33 <dpratt71> does anyone here have experience with configuring Haskell packages on Windows under Cygwin?
06:27:37 <ClaudiusMaximus> want to add a 4th for parallel evaluation, but not sure how it would work, if at all, or whether a different primitive is needed
06:28:40 <edwardk> with luck that'll work. i need to install 7
06:29:26 * hackagebot comonads-fd 0.1.1 - Comonad transformers using functional dependencies.  http://hackage.haskell.org/package/comonads-fd-0.1.1 (EdwardKmett)
06:29:34 <poucet> I guess there's no generic way to patternmatch with type-families
06:29:46 <dpratt71> specifically, does someone now how running under Cygwin may affect package registration?
06:30:35 <dpratt71> Cygwin seems to maintain it's own environment, so I'm guessing the registration only 'happens' in the Cygwin environment
06:30:49 <pastorn> @pl (\f -> f x y)
06:30:49 <lambdabot> flip ($ x) y
06:37:56 <taotree> Is there a typical simple way to load property/config files?
06:40:07 <opqdonut_> is there a haskell 2010 report anywhere?
06:40:59 <opqdonut_> http://darcs.haskell.org/haskell-prime-report/report/haskell-report-html/ seems to have something, but it doesn't seem very official
06:41:13 <taotree> http://www.haskell.org/onlinereport/haskell2010/
06:43:28 <opqdonut_> oh, thank yuo
06:43:49 <quuuux> is there any way to make GHCi 'unimport' an uninterpreted module totally, so that when it's re-imported any changes to it on disk are reflected?
06:45:35 <pastorn> quuuux: what's wrong with :r ?
06:45:53 <quuuux> pastorn: oh, hang on a second. I think my testing code is broken, let me try again
06:46:49 <quuuux> pastorn: no, same result. I'm trying to re-import a module from a package that's been modified, and :reload doesn't seem to re-load the package
06:47:01 <pastorn> is there a way to idfef on ghci/compiled code?
06:47:19 <pastorn> i have a performGC in my code, but it causes bugs when used in ghci
06:47:40 <pastorn> quuuux: oh, you need to remove your .hi and .o files
06:47:48 <pastorn> quuuux: i'm guessing you compiled
06:48:01 <pastorn> find -name "*.hi" -print0 | xargs -0 rm -vf
06:48:04 <pastorn> find -name "*.o" -print0 | xargs -0 rm -vf
06:48:13 <pastorn> quuuux: ^^^ i use those two lines in my makefile as clean:
06:48:29 <ski> @where report
06:48:29 <lambdabot> http://www.haskell.org/onlinereport/
06:51:12 <markus3> hi! maybe theres an answer for this somewhere, but google didn't tell me.. but the cabal-install package for gentoo is masked right now -- should I just unmask and install it to use it?
06:51:51 <quicksilver> pastorn: -or? ;)
06:53:09 <pastorn> quicksilver: huh?
06:53:30 <quicksilver> pastorn: your two almost identical lines in makefile could be made into one line using -or
06:53:47 <pastorn> oh
06:53:52 <pastorn> hehe, well
06:54:05 <pastorn> my makefile is less than 8 lines, i'll be fine for a while
06:58:38 <roconnor> @hoogle trace
06:58:39 <lambdabot> Debug.Trace trace :: String -> a -> a
06:58:39 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
06:58:39 <lambdabot> module Debug.Trace
06:59:15 <roconnor> @src Debug.Trace.trace
06:59:15 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
07:00:32 <edwardk> roconnor: bah, the comonadic one is nicer ;)
07:00:57 <roconnor> :D
07:01:15 <roconnor> For once in my life I want trace to not put a carriage return in my output
07:01:29 <edwardk> hah
07:02:09 <edwardk> i need a good name for lower . duplicate   or join . lift
07:02:44 <edwardk> t w a -> w (t w a)    and m (t m a) -> t m a — respectively
07:03:25 * roconnor prints a star every time his integration function samples a point
07:03:36 <roconnor> so many samples!
07:03:42 <aristid> loweredDuplicate & liftedJoin?
07:03:59 <edwardk> aristid: when the combinator name is longer than the code its a bad sign ;)
07:04:21 <aristid> edwardk: i'm not sure if i agree
07:04:47 <edwardk> the former basically peels off a copy of a base comonad from a comonad transformer
07:05:04 <edwardk> which enables you to wrap something else in it
07:07:11 <edwardk> roconnor: added a bunch of essence of dataflow stuff last night, which brought in ComonadZip, which gives pleasing applicative-like combinators
07:10:24 <roconnor> :D
07:10:33 <edwardk> hrmm, some kind of loweredExtend looks actually quite useful for cleaning up the stream transformer code
07:10:37 <byorgey> ClaudiusMaximus: great!
07:10:37 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
07:10:58 <byorgey> preflex: seen poucet
07:10:59 <preflex>  poucet was last seen on #haskell 41 minutes and 25 seconds ago, saying: I guess there's no generic way to patternmatch with type-families
07:11:10 <roconnor> In order to integrate x^2 from 0..1 to an accuracy of 0.1 my program samples this function 564580 times. ... that seems a little excessive.
07:11:12 <byorgey> @tell poucet not at all, go right ahead
07:11:12 <lambdabot> Consider it noted.
07:12:29 <aristid> edwardk: maybe duplicateL and joinL?
07:13:07 <edwardk> hrmm, what would be a good name for the non-existent operation taking: t Identity a -> t m a in a monad transformer, or its dual t w a -> t Identity a in a comonad
07:13:17 <edwardk> i've wanted the former for a while
07:13:32 <edwardk> and while its too late to fix MonadTrans, i might be able to make ComonadTrans nicer ;)
07:13:32 <quicksilver> edwardk: it is sometimes called "hoist"
07:13:50 <edwardk> now to find a better name than cohoist
07:13:51 <edwardk>  ;)
07:14:00 <quicksilver> edwardk: http://www.mail-archive.com/haskell-cafe@haskell.org/msg39098.html
07:14:02 <Peaker> What's broken in MonadTrans?
07:14:08 <Peaker> @src MonadTrans
07:14:09 <lambdabot> Source not found.
07:14:21 <edwardk> its just that there are two liftings that are interesting
07:14:45 <edwardk> t Identity a -> t m a —  gives you stuff like State s a -> StateT s m a
07:15:08 <quuuux> hmm. Cabal compiles each module in my program twice when I have both Executable and Library sections in the .cabal file. Is that expected?
07:15:10 <quicksilver> edwardk: (also read yitz's reply to the message I linked)
07:15:35 <dcoutts_> quuuux: yes, though you can make the exe depend on the lib
07:15:36 <Peaker> quuuux, In newer cabal versions, your executable is allowed to depend on the lib
07:15:55 <quuuux> oh, nifty. Willdo, thanks!
07:16:01 <edwardk> yeah though the version i'm leaning towards is the haskell 98 one ;)
07:16:05 <quuuux> how new is new? 1.8?
07:16:24 <dcoutts_> quuuux: the issue is that each exe/lib can use different flags etc for the same module, so it's hard to know when it's safe to re-use a .o file
07:16:28 <edwardk> since i'm targeting a transformers style model where the base 'comonad' is just the comonad transformer of identity
07:16:29 <dcoutts_> quuuux: yep 1.8
07:21:39 * hackagebot clevercss 0.2.4 - A CSS preprocessor  http://hackage.haskell.org/package/clevercss-0.2.4 (GeorgBrandl)
07:23:54 <aristid> edwardk: aren't there comonads that can't be transformers?
07:24:51 <edwardk> probably =)
07:25:07 <edwardk> i've been able to refactor all of my usual comonads so far though
07:25:45 <edwardk> i was able to find a comonad that i think is able to be lowered, but not cohoisted though =/
07:26:45 <edwardk> data DiscontT s w a = DiscontT (w s -> a) (w s) — I can lower it, but since the w s occurs in both positive and negative position I can't cohoist it
07:27:30 <aristid> there's no CoIO, eh? :D
07:27:34 <edwardk> lower (DiscontT f s) = extend f s
07:27:38 <edwardk> nope. and for good reason
07:27:57 <edwardk> every functor in haskell is strong, so you can always move whatever values you want back into it
07:28:03 <quicksilver> It's replaced by the farm comonad, EIEIO.
07:28:21 <edwardk> if we didn't have those pesky environments floating around or had uniqueness types you could have a OI comonad though
07:28:41 * hackagebot json-tools 0.2.0 - A collection of JSON tools  http://hackage.haskell.org/package/json-tools-0.2.0 (NicolasPouillard)
07:31:03 <edwardk> i suppose hoist and cohoist are actually special cases of something that lifts (co)monad homomorphisms into the (co)monad transformer
07:31:07 <aristid> @remember quicksilver It's replaced by the farm comonad, EIEIO.
07:31:08 <lambdabot> I will remember.
07:32:17 <edwardk> what you'd ideally have is hoist :: (MonadTrans t, Monad m, Monad n) => (forall b. m b -> n b) -> t m a -> t n a
07:32:54 <edwardk> and cohoist :: (ComonadTrans t, Comonad m, Comonad n) => (forall b. m b -> n b) -> t m a -> t n a
07:33:12 <edwardk> but now its not haskell 98
07:35:19 <aristid> edwardk: why is haskell 98 so important for you?
07:35:34 <edwardk> because i want the base comonad package to be something that could go in base
07:35:50 <edwardk> comonad-transformers is similarly 98 by way of analogy to comonad-transformers
07:35:54 <edwardk> er to transformers
07:36:02 <edwardk> and comonads-fd lets in fundeps/mptcs
07:36:33 <edwardk> i can build a comonad-extras that offers Density, etc. and a monad-extras to give Codensity, etc.
07:36:36 <aristid> i don't think comonad would ever be included in base. what would be the rationale?
07:37:10 <edwardk> thats kind of what i'm building up. there was chatter on the mailing list about it. so i wanted to build a compelling straightforward comonad library
07:37:26 <edwardk> so that there was a viable, implemented candidate
07:37:26 <Twey> What's wrong with writing to the '10 standard?
07:37:32 <djahandarie> Are you codiscriminating aristid?
07:37:35 <edwardk> twey: nothing, it just doesn't add anything i need
07:37:42 <Twey> Fair enough
07:38:04 <aristid> djahandarie: if i was in less channels, i would occasionally rename myself coaristid or so :D
07:38:40 <djahandarie> I think my nick would become even more unwieldy if I tried
07:39:00 <Twey> It would be the longest nick allowed on Freenode
07:39:37 <Twey> And I would parse it as Codja Handarie
07:40:08 <edwardk> aristid: as for why, i'd like to move Data.Functor.Identity from transformers and the basic Control.Comonad haskell 98 package in because there are lots of things that would use it if they could ;)
07:40:19 <djahandarie> Currently I think most people parse it as DJ Ahandarie, so that could be an improvement. :(
07:40:38 <edwardk> i have 3-4 reimplementations of Comonad in hackage at the point through different libraries
07:40:42 <aristid> djahandarie: no i parse it as djahanderie
07:41:04 <aristid> tschahänderi
07:41:10 * quicksilver parses it as D'jah And Arie
07:46:19 <edwardk> aristid: in any event, if not in base, i'd at least like to have something viable for the platform
07:46:28 <edwardk> and its easier to deal with that sans extensions
07:47:34 <aristid> edwardk: ok, i see more of a case for that
07:48:00 <aristid> isn't mtl 2.0 in the platform, tho? that uses mptcs and fundeps
07:48:45 <markus3> answreing my own question: installing cabal-install on my gentoo I unmasked cabal-install-0.8.0 and then also http-4000.0.8. This worked. And after doing "cabal update" it suggested to "cabal install cabal-install" which also worked. And now everything seems ok to go :)
07:48:45 <edwardk> yes, though the transition there, is that you have the small monad in haskell 98, the transformers package which is also 98, and then mtl/monads-fd which is mptcs and fundeps
07:48:56 <edwardk> so for symmetry i have comonad, and comonad-transformers and comonads-fd
07:49:04 <edwardk> the former 2 are haskell 98
07:49:19 <aristid> i like symmetry, but isn't simplicty also nice? :)
07:49:28 <edwardk> and comonads-fd uses mptcs/fundeps and comonads-tf uses type families
07:49:32 <edwardk> not in this case =)
07:49:40 <edwardk> simplicity is relative
07:49:59 <aristid> i would use comonad, comonad-transformers (which includes what you have in comonads-fd) and no comonads-tf
07:50:04 <edwardk> the 'simple' version locks out compilers that aren't ghc ;)
07:50:46 <aristid> are mptcs+fundeps ghc-only already? i thought those were pretty basic extensions
07:51:07 <edwardk> fair enough, but i lived through the hell that was the fracturing of mtl into transformers/monads-fd i don't want to live through that again
07:51:13 <quicksilver> mptcs seem natural, but fundeps have always been a bit controversial
07:51:22 <quicksilver> I think GHC is the only implementation of fundeps.
07:51:26 <edwardk> there is still a small level of controversy about mptcs/fundeps vs. type families, and i'm choosing to sidestep it
07:51:28 <Saizan> i think only Hugs supports them
07:51:39 <edwardk> because for some reason there is this ouble standard about what is already platformed and what wants to be ;)
07:51:41 <Saizan> (other than ghc)
07:51:42 <quicksilver> JHC's JM has suggested he will implement TFs instead
07:52:13 <aristid> i think both fundeps and tfs are necessary :)
07:52:15 <edwardk> therefore it makes sense to me to factor out the code that depends on them just as a prophylactic to avoid yet another bikeshedding issue from getting in the way
07:52:17 <edwardk> i agree
07:52:28 <aristid> quicksilver: i happily mix both in my code, whichever is more convenient
07:52:34 <edwardk> but like any middle ground you have parties on both sides tearing away at you ;)
07:52:46 <quicksilver> aristid: I despise typeclasses and very rarely use either.
07:53:20 <aristid> quicksilver: the advantage of TFs is that you don't necessarily explode the number of MPTC params
07:53:31 <quicksilver> right.
07:53:45 <aristid> that's at least the reason why i mix them in
07:53:54 <aristid> otherwise, fundeps all the way :D
07:54:04 <edwardk> anyays, by building it this way the end user can choose whether he wants/needs any of those extensions and he'll leave me the hell alone ;)
07:54:26 <aristid> edwardk: fair enough, it's just a lot of different packages :)
07:54:50 <edwardk> comonad is one module, comonad-transformers is big, comonads-fd is bigger still
07:55:09 <edwardk> and comonad-extras is 'crap i could never get into base' ;)
07:55:20 <edwardk> er into the platform
07:55:37 <edwardk> contravariant yoneda lemma, left kan extensions, etc.
07:55:37 <aristid> edwardk: where would you put important comonads that are not transformers?
07:56:00 * quicksilver waits to see interesting library applications of the machinery
07:56:01 <aristid> is the Stream comonad a transformer?
07:56:10 <edwardk> well, so far i haven't got any. for a while i had a 'Stream f a' f-branching stream/cofree comonad in comonad, but its a transformer
07:56:24 <aristid> ah, it is
07:56:41 <edwardk> i build a 'StreamT-done-right' style comonad transformer, so Stream is in Control.Comonad.Trans.Stream and will get re-exported through comonads-fd at Control.Comonad.Stream
07:59:57 <aristid> edwardk: i think people will need a lot of guidance how the whole machinery can be used
08:00:17 <edwardk> yeah. right now i'm focusing on getting it right, and putting together some examples
08:00:40 <edwardk> but it has a nicely defined scope, unlike category-extras
08:00:51 <edwardk> so it is easier to polish
08:01:31 <aristid> haha, category-extras is probably the most well-known unused haskell package
08:02:17 <edwardk> yeah
08:02:44 <edwardk> it has now had 3-4 years to percolate in folks minds, so lets peel off the useful stuff ;)
08:04:31 <aristid> it has 10 direct reverse dependencies, and most of these seem to use the comonad stuff
08:04:34 <notallama> hey guys. i'm looking for a package that lets me render to the screen, and manipulate individual pixels. those are the only features i need. any suggestions? (haskell of FFI would be fine)
08:04:46 <edwardk> yep
08:04:57 <roconnor> aristid: ya I went searching for who defines comonad classes
08:05:07 <roconnor> since I wanted to use a comonad class
08:05:08 <edwardk> this is part of my grand plan to break category-extras into tiny little packages
08:05:18 <edwardk> i already factored out 'categories'
08:05:25 <roconnor> category-extras was the most common reference
08:05:37 <roconnor> but it is a bit heavyweight to just get comonads.
08:05:44 <edwardk> exactly
08:05:51 <edwardk> now you have a one-stop comonad shop =)
08:06:10 <roconnor> yay
08:06:19 <j-invariant> what are comonads for?
08:06:34 <roconnor> j-invariant: for cellular automata
08:06:36 <edwardk> i use them when i want to be able to throw away meta-information
08:07:03 <ClaudiusMaximus> notallama: personally i'd peek/poke bytes into memory and upload it to textures in OpenGL (via GLUT or GTK or SDL, depending what other things i need to do)
08:07:30 <edwardk> e.g. the 'Traced' comonad lets you track a monoid of information about an object (like a list of messages), which you can choose to keep around or not at you see fit.
08:08:51 <notallama> ClaudiusMaximus: cool, thanks.
08:09:29 <roconnor> edwardk: is there some value Traced m m?
08:10:06 <edwardk> roconnor: i was debating about making that 'listen' or some such
08:10:17 <roconnor> hmm
08:10:29 <roconnor> It doesn't appear to extend to TracedT m w m
08:10:36 <ClaudiusMaximus> notallama: other options might be to search hayoo using keywords like "raster" or "bitmap" or "image"
08:10:39 <ClaudiusMaximus> @where hayoo
08:10:40 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
08:10:52 <edwardk> you need a w to embed the identity function
08:11:32 <edwardk> TracedT (id <$ w) — works fine if you have a w lyng around though
08:11:50 <edwardk> that will build a listener for a traced transformer
08:11:54 * roconnor seems to recall listen or pass in the mtl is a bad thing to have in the Writer class
08:12:07 <edwardk> yeah, thats why i don't have them in the class equivalent
08:12:11 <edwardk> same with local
08:12:31 <edwardk> they can be factored into another class, so that you can lift more stuff over cont, etc.
08:14:03 <edwardk> hrmm, well, a 'listen' that works like the existing monadic one is doable
08:15:59 <edwardk> listen = TracedT . fmap (\f m -> (f m, m)) . runTracedT
08:16:27 <edwardk> just requires the functor for w
08:17:09 <roconnor> maybe it was pass that was problematic
08:17:42 <edwardk> yeah
08:18:20 <edwardk> well, listen is TracedT specific not ever ComonadTraced will provide it
08:18:21 <roconnor> so many things wrong with the mtl
08:18:30 <roconnor> I even forgot about the problems with pass
08:18:31 <edwardk> its not bad
08:18:40 <roconnor> it's not bat
08:18:42 <roconnor> *bad
08:18:48 <edwardk> its better than anything that came before and the cures have been worse than the disease in many ways ;)
08:18:51 <roconnor> but not good enough to be put into the Platform
08:18:52 <aristid> neither bad nor nat
08:19:14 <roconnor> not that anything should be put into the Platform
08:19:26 <aristid> -nat+bat
08:19:33 <edwardk> its better to have it than to face the alternative of having to wrestle with a dozen incompatible slightly-better-on-one-axis-but-not-adopted-monad-transformer-libraries
08:19:53 <roconnor> I think it is worse than that alternative
08:20:07 <aristid> and with mtl 2.0, the whole mtl vs monads-fd disaster is mostly resolved
08:20:17 <edwardk> yeah
08:20:24 <edwardk> mtl 2 made me happy
08:20:34 <roconnor> what did the mtl 2 do?
08:20:38 <edwardk> its why iw as finally willing to do this
08:20:40 <Saizan> but now half of hackage will start using monadLib
08:20:43 <roconnor> other than propogate systmatic implementation errors?
08:20:49 <aristid> roconnor: monads-fd now just reexports mtl 2.0
08:20:54 <aristid> => compatibility
08:21:06 <edwardk> now mtl is factored at least into the haskell 98 bits and uses transformers for its data types
08:21:08 <roconnor> what id monads-fd do before?
08:21:19 <roconnor> edwardk: I like transfomers :D
08:21:20 <Saizan> aristid: the other way around, i believe
08:21:24 <edwardk> code that used monads-fd was incompatible with code that used mtl
08:21:25 <roconnor> as far as I know it is all correct
08:21:26 <aristid> Saizan: no :)
08:21:28 <edwardk> now it is not
08:21:55 <edwardk> now if only monads-tf was refactored into another 1@*()# namespace so that you could import both monads-tf and monads-fd at the same time then all would be right with the world
08:22:28 <aristid> and mtl-tf :D
08:22:35 <edwardk> roconnor: exactly, transformers is a nice launching off point for people to wrestle with fds and tfs until their heart's content
08:22:48 <Saizan> aristid: weird
08:23:37 <edwardk> there was a  proposal during the attempt to fix up mtl 2 to rename the modules from monads-tf so that you could for instance if you are supplying a state-like monad in your own library import both monads-tf and monads-fd and export both instances, but it never happened
08:23:52 <edwardk> due to inertia, bikeshedding, and some whinging about asymmetry
08:24:18 <Saizan> roconnor: not really correct: http://hackage.haskell.org/packages/archive/transformers/0.2.2.0/doc/html/Control-Monad-Trans-List.html
08:24:34 <edwardk> yeah
08:24:36 <Saizan> it actually has most of the same bugs as old mtl, for compatibility
08:25:07 <roconnor> well, that is less terrible than the other errors in the mtl
08:25:31 <roconnor> the other errors in the mtl are actual code with incorrect behavour
08:25:45 <Peaker> ListT?
08:25:51 <roconnor> the "List transformer" can simply be not used by anyone.
08:25:51 <aristid> heck, just ignore ListT
08:26:02 <roconnor> and that is a reasonable workaround
08:26:17 <Peaker> there's the list package for that
08:26:18 <copumpkin> class CommutativeMonad (m :: * -> *) -- no where, no methods
08:26:26 <aristid> Peaker: and logict?
08:26:30 <edwardk> that reminds me i need strict and lazy EnvT's
08:26:36 <Peaker> aristid, yeah that too
08:26:39 <Saizan> roconnor: an example?
08:26:45 <roconnor> Saizan: example of what?
08:26:49 <Peaker> copumpkin, I don't understand the difference between CummutativeMonad and Applicative
08:27:11 <Peaker> copumpkin, I guess CMonad can mean: effect commutes, but data dependencies are still allowed
08:27:12 <aristid> copumpkin: its "content" is just the laws (which cannot be expressed in haskell), right?
08:27:17 <edwardk> peaker: Reader is commutative because you can slide ask around anywhere. applicative can still care about the order
08:27:21 <Peaker> (only meaningful if you have data before effect)
08:27:23 <copumpkin> Peaker: yeah
08:27:25 <Saizan> roconnor: of the other errors of mtl, i guess they got duplicated in monads-fd
08:27:43 <roconnor> ya
08:27:53 <copumpkin> then class CommutativeMonoid (m :: *) -- no where, no methods
08:28:02 <roconnor> Saizan: The instancece for StateT cont is wrong
08:28:05 <fysx> quick question, if i have a function that takes a predicate, e.g. any, but my predicate has its result in a monad, is there a way to lift it all to the context of the monad?
08:28:15 <copumpkin> instance CommutativeMonoid m => CommutativeMonad (Writer m)
08:28:16 <copumpkin> :P
08:28:21 <roconnor> Saizan: the existance of pass (and I think listen) as class functions is wrong
08:28:22 <copumpkin> unfortunately, we can't do that
08:28:29 <roconnor> Saizan: and there is a third one ...
08:28:31 <copumpkin> as it overlaps completely with the existing monad :(
08:28:59 <roconnor> s/listen/local
08:29:14 <aristid> roconnor: well, if it bothers you, you can add reduced classes without these methods. no need to dump mtl entirely
08:29:41 <Saizan> fysx: no
08:29:52 <fysx> saizan: thanks...  damn!
08:30:03 <roconnor> aristid: it means that when people write libraies with code that is polymorphic over MonadWriter, I cannot pass my structure to them.
08:30:13 <roconnor> aristid: so yes, we need to dump the mtl entirely
08:30:17 <quicksilver> roconnor: true, but fortunately no one does that ;)
08:30:45 <roconnor> what was the third problem ...
08:30:46 <aristid> roconnor: tell these library writers to use your reduced class instead.
08:30:51 <quicksilver> roconnor: the more practical workaround is to instance where local = error "This method shouldn't be in this class". I bet you'll find it's never called.
08:31:22 <aristid> quicksilver: right, i guess that's what most people do :D
08:31:26 <roconnor> quicksilver: yes that is a pragmatic solution to this fundamental problem
08:31:46 <roconnor> quicksilver: It's great for people who hate types and safety properties
08:31:54 <Saizan> local is pretty nice actually, how do you extend your environment when evaluating the body of a lambda otherwise?:P
08:32:10 <aristid> roconnor: monadLib does this a bit better, but it's very bare-bones and not exactly widely adopted
08:32:16 <roconnor> Saizan: local is great, but I don't think it produced by ReaderT in general
08:32:40 <roconnor> aristid: yes monadLib is my perfered library, though I haven't investigated the field very widely
08:33:18 <roconnor> oh yes, the third problem was the Error constraint on ErrorT
08:33:41 <roconnor> hmm
08:33:45 <roconnor> is that really a problem?
08:34:03 <roconnor> probably
08:34:07 <aristid> no, you can write your own ExceptionT
08:34:22 <roconnor> anyhow I'm not sure about that last one
08:34:45 <Saizan> at least we no longer have it on Either
08:34:53 <roconnor> ya
08:34:58 <aristid> Saizan: that has been changed?
08:35:04 <lars9> when exporting a data data D = A | B | C ..., what does D(..) mean? the (..) part.
08:35:23 <roconnor> lars9: it stands for all the constructors of D
08:35:26 <aristid> lars9: "all constructors and record accessors"
08:35:32 <Saizan> aristid: yep in a recent base
08:35:34 <roconnor> aristid: :O
08:35:39 <roconnor> record accessors too?
08:35:40 <roconnor> neat
08:35:56 <aristid> roconnor: i think so, but i'm only 90% sure :)
08:36:13 <lars9> if D is simply D = A | B | C, then (..) is not needed?
08:36:14 <Twey> I'd be surprised if not
08:36:28 <Peaker> lars9, (..) can always be replaced by an explicit name list
08:36:35 <Peaker> lars9, in this case: D(A, B, C)
08:36:42 <aristid> lars9: if you want to access A, B and C, you do need it, or D(A, B, C)
08:36:57 <lars9> oh, i see
08:36:58 <lars9> thanks
08:36:59 <aristid> A, B and C are constructors
08:37:02 <Twey> lars9: If you don't want access to A, B, and C, then you can just export (D).  If you want A, B, and C as well, you need to export (D(..)) or (D(A, B, C)).
08:37:38 <lars9> Twey: thanks
08:38:45 <aristid> Twey: didn't i say exactly the same? :)
08:39:44 <Twey> Yes, but I was too busy coughing to notice before I sent it >.>
08:42:01 * hackagebot comonad-transformers 0.2.0 - Haskell 98 comonad transformers  http://hackage.haskell.org/package/comonad-transformers-0.2.0 (EdwardKmett)
08:42:32 <kmc> edwardk, shouldn't that package be named "sremrofsnart"?
08:42:41 <edwardk> kmc =P
08:43:04 <roconnor> ideally I think comoand-transformers should be merged with transformers, but maybe that is some time away
08:43:21 <kmc> are there interesting relations between monad transformers and comonad transformers?
08:43:32 <edwardk> sɹǝɯɹoɟsuɐɹʇ
08:43:36 <kmc> is there a categorical description of a monad transformer which won't make my brains melt and run out my ears?
08:43:39 <roconnor> w a -> m a is a kliesli arrow
08:43:52 <roconnor> or does that require them to distribute?
08:44:13 <roconnor> there is something about comonads distributing over monads or vice versa that is important
08:44:19 <edwardk> roconnor: bikleisli arrows require distributive laws
08:44:26 <edwardk> and are almost never fast enough to be desirable ;)
08:44:28 <roconnor> w a -> m b
08:44:43 <roconnor> is that a bikleisli arrow?
08:44:46 <edwardk> yeah
08:45:02 <edwardk> you need a distributive law between w and m for it to work
08:45:23 <roconnor> kmc: I'm not aware of any categorical description of monad transfomrers
08:45:36 <roconnor> kmc: I think the CS people are ahead of the math people here.
08:45:48 <djahandarie> Make one and publish a paper ;)
08:45:50 <j-invariant> roconnor: what about that fplunch post
08:45:52 <roconnor> (if by ahead you mean leaping before looking)
08:46:01 <j-invariant> using adjunctions to build monads
08:46:32 <roconnor> j-invariant: maybe there is one.  I don't know what post you are refering to
08:46:49 <edwardk> j-invariant: its a fairly old approach goes back to mark p jones in 93
08:47:04 <j-invariant> http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=84
08:49:03 <roconnor> j-invariant: that is pretty interesting
08:49:10 <edwardk> there is another class of monad transformer distributive law that jones covered
08:49:35 <edwardk> NMN => MN (or NMN => NM
08:50:46 <daz> hey
08:50:57 <edwardk> splitting the transformers into a pair of adjoint functors actually is pretty close to what i do for right kan extension transformers
08:53:43 <younder> hi all
08:54:09 <younder> just did a full reinstall so go steady no my nerves
08:57:40 <joe6> is there a prettyprint tutorial somewhere? I want to use the "pretty printer" functionality but am having a hard time getting started.
08:58:02 <kmc> you mean Text.PrettyPrint?
08:58:07 <joe6> yes, please
08:58:41 <kmc> hmm i don't know of a tutorial but i have a vague recollection that the library comes from a paper about how to write such a library
08:58:52 <aristid> edwardk: iirc you claim your kan extension transformers offer better performance than standard transformers? does that mean they're also high on your list of stuff that will get its own package?
08:59:09 <joe6> yes, that is what I am finding on google too. I wish there was a tutorial on how to use that library.
08:59:33 <kmc> joe6, are you reading the API docs? where do you get stuck?
08:59:39 <edwardk> aristid: only in the codensity case it seems
09:00:02 <edwardk> codensity monad transformers perform nicely, which covers IO, ST s, STM, and State, and some others
09:00:13 <edwardk> there is a monad-ran package
09:00:23 <edwardk> but it is ran-transformer based rather than codensity-transformer based
09:00:32 <kmc> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/pretty-1.0.1.2/Text-PrettyPrint-HughesPJ.html
09:00:33 <roconnor> I still say that if join isn't added to Monad in this proposal I'm going to punch someone in the face
09:00:35 <luite> does anyone know a package for arithmetic in finite fields or Z/nZ?
09:00:48 <luite> I can't find anything on hackage
09:00:49 <aristid> @unmtl State s a
09:00:50 <lambdabot> s -> (a, s)
09:00:54 <aristid> @unmtl StateT m s a
09:00:55 <lambdabot> m -> s (a, m)
09:00:56 <joe6> yes, I read through the docs but was not able to figure how it fits together in reallife.
09:01:02 <edwardk> i have a scala library of codensity transformers (because i can break parametricity and check if the underlying monad i'm lifting is a codensity monad)
09:01:04 <joe6> :mc: will check the link that you sent
09:01:08 <aristid> @unmtl ReaderT s m a
09:01:09 <lambdabot> s -> m a
09:01:47 <edwardk> state for instance is (forall o. (a -> s -> o) -> s -> o) — which is Codensity ((->)s)
09:02:04 <edwardk> StateT of a codensity monad can also be put in a codensity form
09:02:05 <edwardk> etc.
09:02:08 <joe6> kmc: s/:mc/kmc/
09:02:39 <kmc> joe6, well, there's a bunch of functions that return Doc
09:02:48 <edwardk> CPS'd IO can be put in that same form, (forall o. (a -> State# RealWorld -> o) -> State# RealWorld -> o) — which is Codensity ((->)State# RealWorld)
09:02:50 <kmc> you use those to build a pretty-printable document
09:03:08 <luite> I think the order of the field needs to be encoded in the types somehow, but I'm afraid that it would be tricky to lift a value to a type
09:03:10 <kmc> and then you call "render" to get a string, or "renderStyle" if you want to tweak how it works
09:03:32 <joe6> kmc: ok, thanks.. will try it out.
09:03:57 <kmc> > render $ hsep [text "hello", parens $ text "world"]
09:03:58 <lambdabot>   "hello (world)"
09:04:25 <aristid> edwardk: and it offers performance benefits for all of these?
09:06:00 <edwardk> aristid: in general fmapping over a codensity monad doesn't care at all about the 'f' in Codensity 'f' so no matter how deep the tower of codensity transformers, fmap pays the same price
09:06:44 <zygoloid> presumably you pay more when you come to actually run the thing, though?
09:07:00 <zygoloid> hmm, actually, i guess not!
09:07:04 <edwardk> and codensity transforming code performs 'bind' fusion, so if you have a monad that grows, you've right associated all the binds
09:07:12 <lunaris> @pl \x y -> if x == y then 1 else 0
09:07:12 <lambdabot> flip flip 0 . flip flip 1 . (if' .) . (==)
09:07:24 <joe6> kmc: thanks a lot for your help
09:07:29 <kmc> :)
09:07:33 <zygoloid> hooray for right kan extensions
09:08:43 <edwardk> monad-ran is more of an exercise in showing that there are lots of odd things you can take the right kan extension of and make into a monad. Maybe ~ Yoneda Endo, all sorts of crazy stuff
09:08:44 <EvanR-work> allAreEqual :: Eq a => [a] -> Bool
09:08:48 <EvanR-work> ?
09:08:50 <joe6> kmc: your above code is simple and easy that I could run on the ghci and that was what I was looking for.
09:09:06 <joe6> kmc: i was trying to understand how to import the pretty module and so on..
09:09:30 <j-invariant> what is right kan extensions
09:09:31 <joe6> kmc: was going off on a tangent..
09:09:37 <kmc> i see.  well you can "import Text.PrettyPrint" or "import Text.PrettyPrint.HughesPJ"
09:09:50 <edwardk> j-invariant google comonad.com kan extensions, i have 3 articles explaining ;)
09:09:55 <Saizan> ?type all . zipWith (==) `ap` tail
09:09:56 <lambdabot>     Precedence parsing error
09:09:56 <lambdabot>         cannot mix `.' [infixr 9] and `ap' [infixl 9] in the same infix expression
09:09:57 <j-invariant> cool
09:10:23 <Saizan> ?type all . (zipWith (==) `ap` tail)
09:10:24 <lambdabot>     Couldn't match expected type `a -> Bool'
09:10:24 <lambdabot>            against inferred type `[Bool]'
09:10:24 <lambdabot>     Probable cause: `zipWith' is applied to too many arguments
09:10:28 <copumpkin> I just want to remind people of the amazing beauty that is getZipList . traverse ZipList
09:10:34 <copumpkin> because I'm repetitive that way
09:10:49 <EvanR-work> department of redundancy department
09:10:49 <kmc> :t getZipList . traverse ZipList
09:10:50 <lambdabot> Not in scope: `traverse'
09:10:57 <kmc> :t getZipList . Data.Traversable.traverse ZipList
09:10:58 <lambdabot> forall b (t :: * -> *). (Data.Traversable.Traversable t) => t [b] -> [t b]
09:11:15 <kmc> > (getZipList . Data.Traversable.traverse ZipList) ["abc", "def"]
09:11:17 <lambdabot>   ["ad","be","cf"]
09:11:30 <kmc> > transpose ["abc", "def"]
09:11:32 <lambdabot>   ["ad","be","cf"]
09:11:50 <aristid> :t Data.Traversable.traverse
09:11:51 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
09:12:01 <edwardk> hrmm, now that i have ComonadZip i _can_ implement Cotraversable
09:12:25 <copumpkin> also, conor's magic àla combinator makes traverse easy to define too
09:12:34 <aristid> :t Data.Traversable.traverse ZipList
09:12:35 <lambdabot> forall b (t :: * -> *). (Data.Traversable.Traversable t) => t [b] -> ZipList (t b)
09:13:23 <aristid> :t \x -> Data.Traversable.traverse ZipList (x `asTypeOf` [String])
09:13:24 <lambdabot> Not in scope: data constructor `String'
09:13:34 <aristid> :t \x -> Data.Traversable.traverse ZipList (x `asTypeOf` [""])
09:13:38 <lambdabot> [[Char]] -> ZipList [Char]
09:14:12 * hackagebot bytestring 0.9.1.9 - Fast, packed, strict and lazy byte arrays with a list interface  http://hackage.haskell.org/package/bytestring-0.9.1.9 (DuncanCoutts)
09:15:14 <copumpkin> it's ttuegel, the cabal test guy!
09:15:34 <ttuegel> lol, hi!
09:15:39 <dcoutts_> :-)
09:15:50 <ttuegel> i was always afraid of becoming "that cabal test guy" :)
09:15:54 <dcoutts_> hah hah
09:16:02 <dcoutts_> ttuegel: remind me, where are we with the user guide?
09:16:04 <aristid> ttuegel: and it came true
09:16:10 <dcoutts_> people have been asking about documentation
09:16:11 * copumpkin laughs evilly
09:17:05 <lelf> > transpose ["OH","HAI"]
09:17:06 <lambdabot>   ["OH","HA","I"]
09:17:12 * hackagebot amqp 0.2.7 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.2.7 (HolgerReinhardt)
09:17:17 <lelf> > getZipList . Data.Traversable.traverse ZipList $ ["OH","HAI"]
09:17:19 <lambdabot>   ["OH","HA"]
09:17:27 <ttuegel> dcoutts_: i sent a patch to you and the cabal-devel that fixed the remaining omissions with the user guide
09:18:17 <dcoutts_> ttuegel: oh right ok, great
09:18:35 * dcoutts_ has a patch queue to catch up on
09:18:55 <dcoutts_> but my thesis is done, so I can do things like that now :-)
09:19:15 <ttuegel> dcoutts_: awesome!
09:19:29 <kmc> congrats dcoutts_!
09:19:53 <dcoutts_> ta :-)
09:20:46 <dcoutts_> apparently the first chapter is actually readable, so I'm feeling pleased with myself
09:21:38 <aristid> :t let zipWith' f xs ys = map combine $ transpose [xs, ys] where combine [] = f Nothing Nothing; combine (x:[]) = f (Just x) Nothing; combine (x:y:_) = f (Just x) (Just y) in zipWith'
09:21:39 <lambdabot> forall a b. (Maybe a -> Maybe a -> b) -> [a] -> [a] -> [b]
09:22:11 <aristid> > let zipWith' f xs ys = map combine $ transpose [xs, ys] where combine [] = f Nothing Nothing; combine (x:[]) = f (Just x) Nothing; combine (x:y:_) = f (Just x) (Just y) in zipWith' (,) "OH" "HAI"
09:22:12 <lambdabot>   [(Just 'O',Just 'H'),(Just 'H',Just 'A'),(Just 'I',Nothing)]
09:22:20 <aristid> > let zipWith' f xs ys = map combine $ transpose [xs, ys] where combine [] = f Nothing Nothing; combine (x:[]) = f (Just x) Nothing; combine (x:y:_) = f (Just x) (Just y) in zipWith' (,) "HAI" "OH"
09:22:21 <lambdabot>   [(Just 'H',Just 'O'),(Just 'A',Just 'H'),(Just 'I',Nothing)]
09:22:58 <aristid> > transpose [[]]
09:22:59 <lambdabot>   []
09:23:32 <aristid> :t let zipWith' f xs ys = map combine $ transpose [xs, ys] where combine [] = error "LOL CANNOT HAPPEN"; combine (x:[]) = f x Nothing; combine (x:y:_) = f x (Just y) in zipWith'
09:23:34 <lambdabot> forall a b. (a -> Maybe a -> b) -> [a] -> [a] -> [b]
09:29:45 <joe6> is there a way to pretty print haskell data structures? I know of show and Text.PrettyPrint. Show writes the output as one long line and Prettyprint needs to be setup to the particular structure.
09:30:12 <joe6> Just curious if there is any generic function similar to show with line wrapping and nesting and indentation
09:30:59 <Saizan> you can use haskell-src-exts to parse the result of show and then use its prettyprint for the AST
09:31:22 <Saizan> there's a package tidy-something on hackage that does this, not sure if it still builds
09:31:53 <copumpkin> or Data.Data to play with the structure of the data
09:34:12 <kmc> Saizan, joe6 the package "groom" will do that
09:34:41 <kmc> as does "ipprint"
09:35:21 <joe6> thanks guys, will check out your suggestions.
09:42:38 <quuuux> how often does UndecidableInstances bite people, in practice?
09:43:10 <copumpkin> depends what they do with it :)
09:43:22 <dolio> Not often, I'd say.
09:44:04 <monochrom> depends on what people. 1. general public: all the time, since most of them abuse UndecidableInstances thinking they're doing OOP. 2. experts: never, since they know what to expect.
09:44:54 <quuuux> how about 3. people fiddling with control-monad-exception and adding the flag when the typechecker complains about it? :)
09:45:08 <MBP_> Hello - I have a general question if anyone can answer. I'm trying to figure out if a strict function can return another function which is non-strict and if there's any example from the standard prelude? I was thinking curry, since it is strict (I think) and it could possibly take a non-strict function and return it? Am I right or?
09:45:08 <monochrom> that's general public
09:46:46 <monochrom> f n = if n then (\x -> True) else (\x -> False) -- strict function, returns non-strict function
09:49:16 <MBP_> Thanks monochrom. I'm wondering though if there's any standard function that behaves that way
09:49:21 <ZeroGravitas> Hey!
09:49:37 <calsaverini> hi there
09:50:08 <kmc> MBP_, if f returns g then there's no way for f to care whether g is strict unless f calls g first
09:50:38 <kmc> "id" is strict.  "const True" is lazy.  so "id (const True)" is lazy
09:50:39 <calsaverini> anyone ever had to parse XML with haskell?
09:50:41 <ZeroGravitas> Just a quick question about Cabal on ubuntu. It doesn't seem to be recognizing that I have installed packages. If i install gtk2hs (for example) using 'cabal install gtk2hs-buildtools' the command runs without errors but when I do 'cabal list gtk2hs-buildtools' cabal tells me that it isn't installed. Anyone else had this problem?
09:51:00 <kmc> MBP_, it may seem strange to say that "id" is strict, because it does nothing at all
09:51:17 <calsaverini> I need to extract information from a very simple and small XML file and I'm having trouble understanding how the xml parser work
09:51:23 <kmc> but the definition is simply "f is strict" if and only if "f undefined = undefined"
09:51:25 <monochrom> hey, non-strict, not lazy
09:51:26 * hackagebot comonad-transformers 0.2.1 - Haskell 98 comonad transformers  http://hackage.haskell.org/package/comonad-transformers-0.2.1 (EdwardKmett)
09:51:33 <kmc> yeah monochrom's right
09:51:35 * kmc hangs head in shame
09:51:52 <azaq23> what's meant by strict here, exactly? that the function, when called, has to be evaluated fully to perform it's work (while calling  \_ -> True) would not evaluate it's argument)?
09:51:57 <copumpkin> kmc: how could you!!
09:52:02 <monochrom> it's appalling that this habit is deeply entrenched in the haskell community
09:52:06 <MBP_> Thanks kmc. So from that I take it that my assumption that curry f x y = f(x, y) is a strict function that returns a non-strict one (not always that is)
09:52:09 <copumpkin> kmc: come work with us please!
09:52:19 <copumpkin> (completely unrelated, I know)
09:52:21 <kmc> :D
09:52:22 <aristid> monochrom: what's the difference between non-strict and lazy? oO
09:52:27 <kmc> is it fun copumpkin
09:52:32 <copumpkin> kmc: it's amazing
09:52:32 <tromp_> is const strict?
09:52:34 <kmc> aristid, type error ;)
09:52:40 <monochrom> non-strict: denotational semantics. lazy: operational semantics.
09:52:44 <aristid> kmc: ?
09:52:48 <kmc> aristid, "lazy" is an implementation strategy for implementing "non-strict"
09:53:08 <monochrom> another way to implement non-strict is crazy evaluation
09:53:30 <copumpkin> call-by-whim
09:53:34 <kmc> haha
09:53:39 <Twey> Heh
09:53:42 <sipa> call-by-lunar-phase
09:54:00 <copumpkin> call-by-whim is speculative evaluation, maybe? :o
09:54:03 <Twey> Randomly select from the pool of thunks, evaluate to WHNF, repeat
09:54:03 * copumpkin shrugs
09:54:08 <tromp_> call-by-telephone... great for long distance parameter passing
09:55:29 <aristid> Twey: that should actually work (albeit slowly), no? :)
09:55:52 <quicksilver> just-call-me... Chesney Hawks evaluation.
09:59:23 <copumpkin> gwern: how did this become a wikipedia article? http://en.wikipedia.org/wiki/Comparison_of_VMware_Fusion_and_Parallels_Desktop
09:59:45 <gwern> usually by someone typing in ASCII characters
09:59:58 <copumpkin> oh fair enough
10:00:01 <copumpkin> hadn't thought of that
10:00:15 <djahandarie> lol @ "WARNING: This article was obviously made by the Parallels Desktop staff, so they may attempt to influence you to get Parallels instead of VMware."
10:00:28 <gwern> copumpkin: but it is a legitimate topic - http://en.wikipedia.org/wiki/Category:Software_comparisons
10:00:48 <gwern> now, that WARNING is troubling, but quality is different from notability...
10:00:52 <copumpkin> yeah, but pairwise software comparisons, where it's clearly geared (just look at the color balance) to favor one of them?
10:01:04 <copumpkin> talking about VMs on Mac OS is another issue
10:01:11 <gwern> quality != notability
10:01:13 <copumpkin> but mentioning commercial products pairwise in the title?
10:01:32 <gwern> eg http://en.wikipedia.org/wiki/Comparison_of_Windows_Vista_and_Windows_XP
10:01:40 * gwern linked the category for a reason
10:01:57 <copumpkin> yeah, that seems sketchy too :P but I guess the greater minds have decided
10:01:57 * arcatan invokes blah
10:02:48 <djahandarie> Annoying thing about blah is not everyone is in it :(
10:03:06 <copumpkin> maybe lambdabot needs a @summon-blah function
10:03:12 <copumpkin> @summon-blah gwern
10:03:12 <lambdabot> Unknown command, try @list
10:03:38 <djahandarie> Just requires /sajoin rights on lambdabot, no problemo
10:03:59 <sipa> shouldn't be too hard to get ;)
10:04:35 <lelf> ?s
10:04:35 <lambdabot> Maybe you meant: shootout show slap smack source spell spell-all src . ? @ v
10:05:05 <sipa> @help source
10:05:06 <lambdabot> source <lib>. Lookup the url of fptools libraries
10:05:13 <lelf> ?spell summon
10:08:12 <MrWish> Ok I just learned you can use functions themselves as a typeclass. Does this make it possible to make functions that just keep expanding on the complexity of some function? Like, is it completely recursive?
10:08:29 <copumpkin> functions as a typeclass?
10:10:17 <djahandarie> That sure sounds interesting if it's possible
10:10:25 <kmc> that does not make sense
10:10:26 <kmc> functions are values, type classes are not
10:10:47 <djahandarie> Dictionaries are values!
10:10:56 <copumpkin> maybe he means typeclass implication
10:11:06 <Jafet> Go use dictionaries then!
10:11:07 <kmc> MrWish, can you show us the code?
10:11:12 <mauke> MrWish: do you mean like printf?
10:11:43 <copumpkin> one unclear question: half a dozen hypothetical interpretations
10:12:21 <sipa> i assume he means you can create instances for function types
10:13:27 <copumpkin> interpretations++
10:13:42 <lelf> where's #haskell's telepathist staff?
10:13:52 <copumpkin> interpretations += (you can create instances for the function arrow, not applied to anything)
10:14:12 <MrWish>    applyTwice :: (a -> a) -> a -> a  
10:14:12 <MrWish>    applyTwice f x = f (f x)  
10:14:17 <MrWish> you have this, right
10:14:35 <mauke> ok
10:14:54 <j-invariant> that's a neat function
10:15:15 <MrWish> if a program would use apllytwice on a function twice, that wouldnt  be a problem right
10:15:18 <j-invariant> How many functions (a -> a -> a) -
10:15:24 <j-invariant> How many functions (a -> a -> a) -> a -> a -> a are ther?
10:15:59 <MrWish> uhm I dont know...
10:16:09 <c_wraith> you mean of the non-trivial variety, right?  I can think of... 5, anyway
10:16:22 <c_wraith> I probably missed some
10:16:22 <mauke> j-invariant: ∞
10:16:46 <kmc> there are no type classes there MrWish
10:16:54 <MrWish> oh
10:16:56 <azaq23> > let aT f x = f (f x) in aT (aT id) 10
10:16:56 <lambdabot>   10
10:17:05 <copumpkin> @let thrice f = f . f . f
10:17:06 <lambdabot>  Defined.
10:17:10 <azaq23> you mean this by "using applyTwice on a function twice?"
10:17:17 <kmc> MrWish, you have type variables 'a', but you don't have a type class constraint
10:17:20 <copumpkin> > thrice thrice (+1) 0
10:17:22 <lambdabot>   27
10:17:28 <kmc> if you wrote something like (Eq a) => (a -> a) -> a -> a
10:17:32 <mauke> :t let aT f x = f (f x) in aT aT
10:17:33 <lambdabot> forall t. (t -> t) -> t -> t
10:17:35 <jmcarthur> MrWish: maybe you were calling the type of a function a type class?
10:17:37 <kmc> then you've placed a constraint that 'a' must belong to the Eq type class
10:17:48 <MrWish> jmcarthur yes I think so
10:18:21 <jmcarthur> MrWish: well it's just a type, for the record. :) and yes, it's nice that you can pass functions as values
10:19:38 <jmcarthur> MrWish: to answer what i think your question is... the type system won't let you create infinite types
10:19:39 <kmc> if by "nice" you mean "a core feature of every good general-purpose language of the past 50 years"
10:19:41 <kmc> ;)
10:19:42 <jmcarthur> :t \x -> x x
10:19:43 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
10:19:43 <lambdabot>     Probable cause: `x' is applied to too many arguments
10:19:43 <lambdabot>     In the expression: x x
10:20:03 <roconnor> would it be hard to grep hackage for uses of "join"?
10:20:12 <kmc> but you can write those types explicitly
10:20:35 <jmcarthur> well, you can make newtypes to hide the recursion
10:20:37 <kmc> data InfiniteArgs a b = MkInf (a -> InfiniteArgs a b)
10:20:39 <kmc> yep
10:21:34 <jmcarthur> MrWish: it wouldn't be a problem to use applyTwice on a function twice though. it would just be the same as applyFourTimes
10:21:53 <jmcarthur> :t let applyTwice f = f . f in applyTwice . applyTwice
10:21:54 <lambdabot> forall b. (b -> b) -> b -> b
10:22:17 <jmcarthur> > let applyTwice f = f . f in applyTwice (applyTwice f) x
10:22:19 <lambdabot>   f (f (f (f x)))
10:22:30 <kmc> @src iterate -- MrWish
10:22:31 <lambdabot> Source not found. Take a stress pill and think things over.
10:22:40 <kmc> hmm, it's missing
10:22:42 <jmcarthur> @src iterate
10:22:42 <lambdabot> iterate f x =  x : iterate f (f x)
10:22:46 <jmcarthur> no comments
10:22:49 <kmc> heh
10:22:57 <kmc> > iterate (*2) 1
10:22:58 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
10:23:22 <MrWish> hm
10:23:30 <jmcarthur> > let applyN f n = (!! n) . iterate f in applyN succ 5 100
10:23:31 <lambdabot>   105
10:33:06 <joe6> i am trying to install groom, but getting this error, Can you please help?
10:33:09 <joe6> http://hpaste.org/42805/groom_install
10:34:17 <joe6> http://hpaste.org/paste/42805/groom_install_annotation#p42807
10:34:53 <lispy> joe6: Cabal is being brain dead.  You should have better luck if you install cabal-dev and use that in place of cabal
10:35:13 <lispy> joe6: so: cabal-install cabal-dev
10:36:13 <lispy> joe6: if you don't want to use cabal-dev you can reinstall Cabal-1.10
10:36:26 <joe6> cabal ipprint install gives the below error
10:36:27 <lispy> cabal install --reinstall Cabal-1.10.0.0
10:36:27 <joe6> http://hpaste.org/42808/ipprint_install
10:36:43 <joe6> lispy: thanks, will try it out.
10:36:45 <dcoutts_> joe6: you have multiple versions of Cabal-1.10.0.0 and or pretty-1.0.1.2 installed. This confuses cabal.
10:37:33 <lispy> Yeah, cabal has become very proficient at corrupting package databases :(
10:38:29 <luite> I usually use that as an excuse to nuke my ghc installation and test some release candidate or snapshot :)
10:39:13 <joe6> lispy: how do I use cabal-dev after installation?
10:39:22 <joe6> just cabal-dev install groom?
10:39:33 <joe6> i mean "cabal-dev install groom"?
10:39:36 <lispy> joe6: think of it as a wrapper around cabal, except that it stores package dbs in your pwd
10:39:57 <lispy> joe6: I'd go to somewhere in ~/tmp first, but yeah that should work
10:41:16 <lispy> joe6: If 'cabal-dev install groom' fails, then you can do a 'cabal-dev unpack groom' followed by running, 'cabal-dev install-deps' in the groom source.
10:41:28 <lispy> joe6: from there you can usually figure out what is going wrong pretty easily
10:41:44 <roconnor> is there some way to debug how cabal is calling ghc-pkg update when doing a runhaskell Setup.lhs install --user?
10:41:55 <lispy> roconnor: -v3
10:42:11 <lispy> roconnor: oh, hmm actually, that may not work
10:42:21 <dcoutts_> roconnor: -v2 should be enough
10:42:44 <roconnor> I don't see what is being passed to stdin
10:43:10 <roconnor> all it says is /home/roconnor/.nix-profile/bin/ghc-pkg update - --global --user
10:43:32 <roconnor> before failing with
10:43:41 <roconnor> Setup.lhs: fclabels-0.11.1.1: dependency
10:43:43 <roconnor> "mtl-1.1.0.2-336254fecf8a77054f76cb33671a5177" doesn't exist (use --force to
10:43:44 <roconnor> override)
10:43:55 <dcoutts_> roconnor: if you want to get the registration file, use runghc Setup register --gen-pkg-config
10:44:27 <roconnor> that is the value being passed into ghc-pkg update?
10:44:28 <roconnor> :)
10:44:32 <dcoutts_> yes
10:44:37 <roconnor> excellent
10:46:50 * hackagebot alsa-mixer 0.1 - Bindings to the ALSA simple mixer API.  http://hackage.haskell.org/package/alsa-mixer-0.1 (ThomasTuegel)
10:49:56 <paper_cc> has anyone seen http://http://matt.might.net/articles/parsing-with-derivatives/ ? are there any possibilities to simplify the Haskell implementation? the one referenced there seems to be doing some obscure magic (at least for me)
10:53:25 <paper_cc> ... or at least it is obviously several times longer and more complex than the Scala proof-of-concept implementation.
10:57:01 <maurer_> I'm getting: cabal: No (or multiple) ghc rts package is registered!!
10:57:18 <Cale> paper_cc: I have an implementation of regular expression matching by differentiation...
10:57:20 <maurer_> How might I deal with this?
10:57:46 <dcoutts> maurer_: which one is it then?
10:57:57 <dcoutts> ghc-pkg list rts
10:58:17 <maurer_> dcoutts: As far as I can tell, neither.
10:58:18 <maurer_> maurer@daemon:~/Sources/hbap$ ghc-pkg list rts
10:58:18 <maurer_>    rts-1.0
10:58:37 <maurer_> err, the paths didn't make it through, but it's only listed once
10:58:56 <dcoutts> maurer_: does ghc-pkg check  say anything about rts?
10:59:06 <j-invariant> how hard would it be to implement Knuth-Bendix in haskell?
10:59:28 <Hunner> as easy as the day is long?
10:59:36 <maurer_> dcoutts: Nope. As a note, this only happens when I'm trying to use an hsc file I've written, so it's most likely not an actual cabal error, and is a user error.
10:59:54 <maurer_> http://hpaste.org/42809/ghcpkg <- exact output of commands, unlikely to be of use
10:59:58 <roconnor> dcoutts: if I pass multiple --package-conf parameters to ghc-pkg update, what will it do?
11:00:41 <dcoutts> roconnor: (I think) they are all used to resolve deps, and the last one is used as the target
11:00:47 <Cale> j-invariant: Doesn't sound too hard, but I'm not all that familiar with it.
11:02:20 <paper_cc> Cale: (just being curious) may I have a look at it? though if I get the idea right, derivatives of regexes should be well-defined even in the strict sense, and the idea of the paper is that derivatives of /recursive/ grammars can be computed lazily even if the computation is non-termiating in the strict sense
11:03:51 <Cale> http://hpaste.org/42810/regular
11:04:02 <Cale> My implementation is quite naive.
11:04:28 <Cale> There's also a little NFA implementation there.
11:04:57 * hackagebot json-tools 0.2.1 - A collection of JSON tools  http://hackage.haskell.org/package/json-tools-0.2.1 (NicolasPouillard)
11:06:04 <mux> did I hear NFA?
11:06:14 <mux> https://bitbucket.org/mumux/automata/src/145e95a55c64/Data/Automaton/NFA.hs
11:06:15 <Cale> yeah
11:06:26 <dcoutts> maurer_: could you also paste the original command and error
11:08:10 <paper_cc> Cale: thank you =) *the NFA implementation is for checking I assume?
11:08:26 <aristid> mux: have you considered putting your stuff on hackage?
11:08:50 <mux> aristid: yes, I've been writing to r/haskell about it
11:09:05 <mux> there were a lot less comments than I expected, unfortunately :-)
11:09:23 <Cale> Well, not really. I wrote this code while helping gio123 with a bunch of papers on regular languages, and one of the things I wanted to demontrate is how to determine if one regular language is a sublanguage of another using the NFAs for each.
11:09:28 <aristid> mux: this irc channel might be better. it's pretty easy to upload stuff to hackage
11:09:35 <Cale> demonstrate*
11:09:41 <mux> aristid: I know, I have a few packages there already
11:10:07 <aristid> mux: well, what's the remaining doubt then?
11:11:21 <mux> aristid: basically, I don't want to pollute hackage with packages practically noone ever uses, and on which I dropped the ball because I'm not interested in them anymore
11:11:35 * paper_cc spends quite a bit of time understanding what Cale wanted to demonstrate
11:11:50 <Cale> See containedNFA?
11:11:57 <Cale> and (=<=)
11:12:08 <mux> aristid: also I need to add a TODO/README file explaining the shortcomings etc
11:12:32 <Cale> r =<= s if and only if any word matched by r is also matched by s
11:12:47 <aristid> mux: even unmaintained packages increase haskell's glory :D
11:13:12 <maurer_> dcoutts: Sure
11:13:18 <paper_cc> yep (at least I do understand the question now, so I'll try to understand the implementation too)
11:13:20 <mux> aristid: I would hate to see Hackage become like CPAN - even though I'm not saying I've uploaded bad code there :-)
11:13:53 <burp> CPAN is polluted with bad stuff?
11:14:02 <Cale> paper_cc: Basically, it builds a tree where it runs both NFAs in parallel
11:14:12 <mux> burp: what, does this come to you as a surprise? :)
11:14:18 <akosch> I have an infinite list of primes: how could I get an infinite list of primes whose position in my list is a prime number itself?
11:14:18 <maurer_> dcoutts: http://hpaste.org/42811/original
11:14:24 <mux> Cale: you run NFAs directly?
11:14:26 <Cale> paper_cc: on all possible words (increasing in length as we descend in the tree)
11:14:50 <akosch> like 3, 5, 11, etc...
11:14:51 <Cale> mux: Well, I differentiate them which is the same thing.
11:14:55 <j-invariant> "Note that Buchberger's algorithm for constructing Gröbner bases is very similar to the Knuth-Bendix completion algorithm. " mysterious thing to say
11:15:22 <mux> Cale: does this differentiation has anything in common with the usual NFA determinisation algorithms?
11:15:29 <Cale> and we just prune that tree at any point both NFAs are equal to a pair of NFAs we saw higher up the tree
11:15:40 <c_wraith> akosh: nevermind the primes part.  Start by "I have a list of indices, in increasing order.  I need to extract the elements at those indices from a list"
11:15:52 <maurer_> dcoutts: The file in there is kind of a mess though, quite possible me doing something stupid with hsc is causing this, as this is my first time trying to write Storable instances
11:16:03 <c_wraith> akosh: once you have that part, the rest is easy
11:16:04 <MrWish> I would like to come in here one day and understand what you are talking about
11:16:18 <akosch> c_wraith: yeah, I knew this much :)
11:16:27 <Cale> mux: The derivative of an NFA with respect to some symbol is just the NFA whose initial set of states is modified as if it had already eaten that symbol.
11:16:45 <mux> Cale: yeah, that's exactly like running it then
11:16:48 <Cale> right
11:17:06 <mux> so it's probably not going to be very efficient
11:17:11 <Cale> Well, whatever :)
11:17:21 <mux> not picking on you, just being curious :)
11:17:25 <Cale> It was efficient enough for my purposes at the time
11:17:34 <c_wraith> akosch: That's not a terribly difficult task.  Also, it sounds like homework, so I'm trying not to just give you the answer :)
11:17:34 <burp> akosch: something like… map (primes !!) primes ?
11:17:36 <Cale> Mostly all you're doing is comparing some Data.Set values.
11:17:55 <mux> Cale: yup, pretty much like what I do in the link I pasted above
11:17:56 <c_wraith> burp: that's O(n^2).  You could do it in O(n)
11:18:33 <dcoutts> maurer_: hmm, odd. try a cabal clean and configure again. I'm wondering if configure is silently failing.
11:18:45 <akosch> burp: thx, I was thinking the same thing :)
11:19:10 <akosch> burp: just had to shift the index to 1-based
11:19:55 <mux> bah, I so suck at finding good function names
11:20:00 <dcoutts> maurer_: I don't think it's anything to do with the content of your .hsc file, the failing check is just before the call to hsc2hs
11:20:18 <maurer_> dcoutts: http://hpaste.org/42812/clean_run
11:21:13 <maurer_> dcoutts: OK, I mostly thought that because my other programs using cabal are working fine, and the only real distinguishing characteristic is that I'm using the I'm using the includes and extra-libraries directives in the .cabal file and a hsc file
11:21:32 <j-invariant> I can't find a good description of this algorihthm
11:21:45 <dcoutts> maurer_: right, the check is in the code that constructs the command line args for hsc2hs
11:22:14 <mux> j-invariant: I feel your pain, it's sometimes terribly hard to find a good description of some algorithm, other than by looking at the paper it was originally published in which is sometimes impractical if you're not a math genius :-)
11:22:29 <mux> and even then, you get mostly imperative versions of the algorithms
11:22:46 <mux> it takes some time and lots of refactoring to go from there to a clean functional algorithm
11:23:06 <aristid> runST? :D
11:23:13 <mux> heh, that's cheating :-)
11:23:27 <aristid> i don't think it is :)
11:23:29 <mux> even though I really like the ST monad when you just can't avoid mutation
11:24:21 <aristid> mux: if you have a complex imperative algorithm and need to implement it yesterday, then why not use ST?
11:24:37 <mux> aristid: if I'm really short on time, why not
11:24:53 <mux> but if the algorithm translates fine to a purely functional one, I much prefer going all the way to this
11:24:53 <dcoutts> maurer_: can you post somewhere the dist/setup-config file
11:25:38 <maurer_> http://hpaste.org/paste/42811/setupconfig#p428131;5D
11:25:47 <maurer_> err
11:25:51 <maurer_> dcoutts: http://hpaste.org/paste/42811/setupconfig#p42813
11:25:58 <maurer_> Accidentally got a ;5D on the previous one
11:27:25 <dcoutts> maurer_: can you paste your .cabal file too
11:28:05 <dcoutts> maurer_: I suspect I know what's going on
11:31:12 <paper_cc> Cale: finally got it, thanks. (and btw, MemoTrie looks like what I wanted for memoization in the recursive derivative parser)
11:33:08 <maurer_> dcoutts: Sure.
11:33:19 <nomemory> Hello, what's the "standard" way for splitting strings in Haskell ? (something simple, simple by white space " ")
11:33:30 <dcoutts> :t words
11:33:32 <lambdabot> String -> [String]
11:33:57 <maurer_> http://hpaste.org/paste/42811/cabal_file#p42814
11:34:25 <akosch> how do I make sure, that a list contains only unique elements?
11:34:29 <nomemory> thanks
11:34:37 <dcoutts> maurer_: ok thanks, confirms my diagnosis.
11:34:39 <dcoutts> http://hackage.haskell.org/trac/hackage/ticket/785
11:34:55 <dcoutts> maurer_: as a workaround, add a dependency on the base package
11:35:12 <byorgey> akosch: use 'nub'
11:35:30 <mux> akosch: you could use a Set to begin with, or uniquify it afterwards using map head . group . sort
11:35:30 <joe6> "[ 2 of 21] Compiling Language.Haskell.Exts.Annotated.Syntax" is taking forever. Is that expected?
11:35:36 <maurer_> Ah, so I just throw some dependencies in OK.
11:35:57 <maurer_> Thanks.
11:36:03 <akosch> I don't want to remove duplicates, I just want to know if there are any...
11:36:19 <mux> ah, that's different
11:36:23 <byorgey> does anyone know how to enable profiling with GHC 7?  I'm getting a funny error message, but I don't know what it is telling me to do: http://hpaste.org/42815/trying_to_enable_profiling_wit
11:36:33 <byorgey> akosch: check whether the list is equal to its own nub
11:36:37 <mux> akosch: any ((> 1) . length) . group . sort
11:36:40 <mux> for instance
11:36:51 <djahandarie> byorgey, the normal way worked for me
11:37:02 <akosch> hm, sounds about right: thank you both :)
11:37:06 <byorgey> mux's way works too
11:37:23 <akosch> which one would be faster btw?
11:37:26 <maurer_> akosch: Prefere Mux's way, nlogn vs n^2
11:37:28 <mux> byorgey: I don't know why I insist on not using nub, I think I remember it not being efficient
11:37:34 <maurer_> nub is n^2
11:37:36 <mux> maurer_: ah, that must have been why
11:37:44 <mux> but the length is bad there
11:37:49 <mux> you could be more efficient
11:37:50 <joe6> don't bother, the compilation has moved to the next step
11:37:58 <byorgey> mux: nub is O(n^2) whereas your way is O(n log n).  However, nub works for lists of things with no Ord instance whereas sorting requires Ord
11:38:09 <mux> any (not . null . drop 1) ?
11:38:18 <byorgey> yes, that's better
11:38:20 <mux> yeah, that would be faster.
11:38:24 <djahandarie> And so does Set :(
11:38:37 <mux> I've been telling him about Set
11:38:51 <byorgey> djahandarie: the normal way, i.e. -prof -auto-all, like in my paste?
11:38:52 <maurer_> djahandarie: Well, some kind of comparison is necessary to do tree navigation...
11:39:13 <byorgey> using a Set that did not require Ord would be no better than nub.
11:39:32 <mux> @let hasdups = any (not . null . drop 1) . group . sort
11:39:33 <lambdabot>  Defined.
11:39:36 <djahandarie> byorgey, yes, although I don't remember if I used -auto-all, I may have just manually added cost centres when I was doing it
11:39:40 <djahandarie> Though I doubt that's the problem
11:39:43 <mux> > hasdups [1,2,3,4,1]
11:39:45 <lambdabot>   True
11:39:47 <maurer_> akosch: Oh yeah, if your stuff is ever too slow in general, you probably want to switch out some lists for sets, maps, or in the rare case of frozen data, arrays.
11:39:47 <mux> > hasdups [1,2,3,4]
11:39:49 <lambdabot>   False
11:40:03 <byorgey> djahandarie: yeah, if I remove the -auto-all I still get the same message
11:40:11 <maurer_> akosch: Usually just using the right data structure (or even "close enough") will get you what you need.
11:40:32 <djahandarie> I'd double check right now but it's at home and I'm at work :(
11:40:34 <maurer_> akosch: What are you building anyways?
11:40:39 <byorgey> djahandarie: no worries, thanks
11:41:03 <akosch> maurer_: good advice in general.
11:42:14 <akosch> the problem is, I have integers in the first place and I have to check if their digits form a set
11:42:46 <djahandarie> @check \xs -> (any (not . null . drop 1) . group . sort $ xs) == (nub xs == xs)
11:42:47 <lambdabot>   "Falsifiable, after 0 tests:\n[()]\n"
11:42:56 <djahandarie> @check \xs -> (any (not . null . drop 1) . group . sort $ xs) == (nub xs != xs)
11:42:57 <lambdabot>   Not in scope: `!='
11:42:59 <djahandarie> Gah
11:43:01 <djahandarie> @check \xs -> (any (not . null . drop 1) . group . sort $ xs) == (nub xs /= xs)
11:43:02 <lambdabot>   "OK, passed 500 tests."
11:43:02 <akosch> I'm planning to convert them to a string (List), then use mux's solution
11:43:32 <djahandarie> @check (\xs -> (any (not . null . drop 1) . group . sort $ xs) == (nub xs /= xs)) :: [Int] -> Bool
11:43:33 <lambdabot>   Couldn't match expected type `[GHC.Types.Int] -> GHC.Bool.Bool'
11:43:48 <mreh> @src nub
11:43:48 <lambdabot> nub = nubBy (==)
11:44:59 <djahandarie> @check \xs -> (any (not . null . drop 1) . group . sort $ (xs::[Int])) == (nub xs /= xs)
11:45:01 <lambdabot>   "OK, passed 500 tests."
11:45:04 <mreh> parsec woes, I keep getting unexpected end of input, presumably eof is just another symbol to parsec
11:45:17 <mux> mreh: yes it is
11:45:40 <mreh> can I turn my parsec parser into a generative grammar?
11:46:13 <mreh> or step through it
11:46:23 <copumpkin> no
11:47:06 <mreh> :(
11:47:57 <djahandarie> byorgey, does there happen to be TH involved in that file?
11:48:09 <byorgey> no TH
11:48:13 <ziman> I usually try disabling parsec branches (starting from the top of the grammar) to find out where the parser fails
11:48:26 <byorgey> oh, wait, yes there is
11:48:39 <byorgey> maybe that is why
11:49:00 <djahandarie> I think so
11:49:48 <djahandarie> http://www.haskell.org/ghc/docs/6.12.1/html/users_guide/template-haskell.html#id3029367
11:49:50 <byorgey> I'm not upset that I'm getting an error message, and I'm quite happy to do whatever the message tells me, if only I could figure out what it is!
11:50:01 <byorgey> aha! thanks!
11:50:03 <byorgey> djahandarie++
11:50:04 <Philippa> mreh: the type of bind pretty much prevents that, unfortunately. You could do it for an applicative
11:50:19 <Philippa> (though you might have to provide your own implementation!)
11:51:24 <byorgey> works like a charm
11:51:55 <byorgey> the error message really ought to emphasize that the point is that you need to use -osuf to set the object file suffix to *something other than normal*
11:52:02 <djahandarie> lol
11:52:14 <byorgey> for whatever reason I had not thought of that
11:56:16 <dpratt71> should I be able to install the 'network' package under Windows?
11:56:53 <dpratt71> my first attempt failed with an error that said I needed to use Cygwin or MinGW
11:57:09 <mreh> how are the iphone devs getting on?
11:57:16 <mreh> I wan't a peice of that action
11:58:03 <dpratt71> I tried it under Cygwin and that has failed as well: * Missing header file: HsNet.h
11:58:30 <mreh> dpratt71 how are you installing it?
11:58:39 <mreh> compiling with gcc?
11:58:58 <jmcarthur> what are the most hip topics in parallelism with haskell lately? it's been kind of quiet on that front for the past few months as far as i can tell
11:59:00 <dpratt71> mreh: cabal install network
11:59:21 <djahandarie> Still DPH I think, I haven't really been paying attention though
11:59:34 <jmcarthur> i'm making a talk on parallelism with haskell and don't want to miss anything awesome
11:59:42 <Haskellstudent> Hello
11:59:53 <jmcarthur> a student!
11:59:54 <mreh> dpratt71: shouldn't you already have network installed if you're using cabal
12:00:41 <Haskellstudent> I need to how to use and define toUpper funkcion...
12:00:43 <mreh> what are the other stages of haskellism?
12:00:54 <mreh> sounds like homework
12:00:56 <dpratt71> mreh: not sure, to be honest; it may be a version issue, I suppose; 'snap-server' wants later than I have
12:01:05 <jmcarthur> homework isn't necessary bad to ask about
12:01:22 <mreh> we'll make him work for it
12:01:30 <jmcarthur> mreh: :)
12:01:48 <Haskellstudent> I know its :: Char -> Char
12:02:01 <dpratt71> how do I list installed packages (via cabal)?
12:02:15 <mreh> > toUpper '#'
12:02:16 <lambdabot>   '#'
12:02:22 <mreh> > toUpper '7'
12:02:23 <lambdabot>   '7'
12:02:29 <mreh> hmm, this is going to be tricky
12:02:43 <jmcarthur> yeah, toUpper is a tough one
12:02:50 <dpratt71> yeah, I have network v2.2.1.7
12:03:04 <byorgey> dpratt71: cabal list --installed
12:03:09 <mreh> dpratt71: I haven't used cabal on windows, have you tried searching for the specific problem you've got
12:03:14 <byorgey> dpratt71: also, ghc-pkg list
12:03:32 <mreh> cabal remembers what it's installed?!
12:03:33 <mreh> since when
12:03:54 <dpratt71> is 'network' part of the Haskell Platform?
12:03:59 <Haskellstudent> so then... let toUpper '?' = ' ?'
12:04:30 <mreh> let toUpper = Prelude.toUpper
12:04:35 <djahandarie> lol
12:04:54 <dpratt71> answered my own question: yes
12:04:58 <dpratt71> hmm
12:05:15 <jmcarthur> @src toUpper
12:05:16 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
12:05:24 <djahandarie> Haskellstudent, there is a certain 'range' of characters that you want it to change. The others it should leave along. So first try to find that range
12:05:30 <djahandarie> (I imagine you don't care about unicode here)
12:05:44 <mreh> F
12:05:45 <mreh> Haskellstudent, you have to find out how haskell represents characters
12:05:45 <mreh> > toEnum 'a'
12:05:45 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
12:05:45 <lambdabot>         against inferred type ...
12:05:51 <jmcarthur> > toUpper 'λ'
12:05:52 <lambdabot>   '\923'
12:05:58 <jmcarthur> > 'λ'
12:05:58 <mreh> > toEnum 'a'
12:05:59 <lambdabot>   '\955'
12:05:59 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
12:05:59 <lambdabot>         against inferred type ...
12:06:06 <mreh> > fromEnum 'a'
12:06:06 <lambdabot>   97
12:06:13 <mreh> that might help
12:06:15 <jmcarthur> i guess the real toUpper uppercases unicode
12:06:20 <djahandarie> jmcarthur, yes.
12:06:37 <mreh> > \955
12:06:38 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
12:06:45 <mreh> why can't she write unicode?
12:06:48 <djahandarie> > text "\955"
12:06:50 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
12:07:06 <djahandarie> ...odd
12:07:07 <hotaru2k3> toUpper c = chr (fromIntegral (towupper (fromIntegral (ord c))))
12:07:10 <jmcarthur> > text "λ"
12:07:11 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
12:07:28 <mreh> :t ord
12:07:29 <lambdabot> Char -> Int
12:07:42 <djahandarie> hotaru2k3, that's a pretty convoluted way of still just using built-in functions to do the job for you :P
12:07:43 <jmcarthur> > ord 'a'
12:07:44 <lambdabot>   97
12:07:59 <jmcarthur> @check \c -> fromEnum c == ord c
12:07:59 <lambdabot>   "OK, passed 500 tests."
12:08:31 <hotaru2k3> djahandarie: that's straight from http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Unicode.html
12:08:49 <mreh> I hope this guy didn't take my suggestions seriously
12:08:58 <mreh> if he did he deserves it
12:09:18 <jmcarthur> you're so nice
12:09:22 <dcoutts> mreh: cabal doesn't rembmer what _it_ installed, it only knows what libs are registered
12:09:37 <djahandarie> hotaru2k3, okay. Probably not a satisfactory answer for Haskellstudent though ;)
12:09:39 <mreh> dcoutts: oh okay
12:10:02 <mreh> why doesn't he implement it in TurboPascal first
12:10:18 <monochrom> and even then, it's ghc who registers libs. all cabal does is beg ghc.
12:10:20 <mreh> haskell is hardly the right language to learn about representing data types
12:11:53 <akosch> how could I easily permutate a list (like permutations from Data.List), but without necessarily using every element
12:12:29 <Haskellstudent> I'm using WinGHCi but if want see toUpper definition I type :t toUpper, but that definion is not in scope, so I would like to know how should I set toUpper function
12:12:34 <mreh> akosch: that's a contradiction in terms
12:12:50 <monochrom>  :m + Data.Char
12:13:11 <akosch> mreh: sry, english isn't my native language :(
12:13:14 <roconnor> mreh: he wants [1,2] -> [[],[1],[2],[1,2],[2,1]]
12:13:26 <akosch> roconnor: exactly
12:13:58 <mauke> Haskellstudent: type 'import Data.Char'
12:14:32 <akosch> roconnor: except in the opposite order :)
12:14:32 <Haskellstudent> Thank you!
12:14:53 <Haskellstudent> Have a nice day :-)
12:15:15 <sipa> akosch: you want all unique subsets of all permutations?
12:15:38 <akosch> sipa: yes, I think so
12:15:47 <maurer_> Haskellstudent: In the future, http://haskell.org/hoogle/ <- type the function you want in there.
12:15:47 <joe6> "cabal install base-4.2.0.2" gives me this error "config.status: error: cannot find input file: base.buildinfo.in"
12:15:58 <joe6> any thoughts on how I can fix it.
12:16:06 <dcoutts> joe6: you cannot reinstall base
12:16:09 <monochrom> don't cabal install base-4.2.0.2 or any base
12:17:13 <joe6> oh, ok.
12:17:38 <mreh> all your base are belong to us
12:17:47 <monochrom> god haha
12:17:55 <mreh> official moto of cabal?
12:18:02 <monochrom> of ghc
12:18:13 <dcoutts> mreh: There is no Cabal
12:18:39 <joe6> cabal: cannot configure Extra-1.33. It requires base ==3.*
12:18:39 <joe6> For the dependency on base ==3.* there are these packages: base-3.0.3.1 and
12:18:39 <joe6> base-3.0.3.2. However none of them are available.
12:18:44 <mreh> I don't get it
12:18:49 <joe6> cabal install ipprint gave me the above error
12:18:55 <monochrom> then it's Extra-1.33 being old
12:19:02 <dpratt71> what is the advisability of upgrading packages installed by the platform; no problem?
12:19:10 <dcoutts> joe6: so that package needs base 3, but your version of ghc only has base 4
12:19:29 <monochrom> you're at ghc 7?
12:19:34 <dcoutts> dpratt71: it's technically possible but not necessarily advisable
12:19:39 <joe6> yes.
12:19:41 <joeyh> runVerboseTests $ TestList [TestCase $ assertBool "should fail" True] -- why does HUnit show 1 successful test here?
12:20:08 <joeyh> assertEqual "should fail" 1 2 fails as expected..
12:20:14 <monochrom> deviate from haskell platform version iff you're a shrewd sysadmin type
12:20:16 <mreh> joe6, it's finding those versions of three from it's own cached list of packages from hackage
12:20:16 <mreh> s/three/3.*
12:20:28 <dpratt71> dcoutts: ok; what should I do if I want to use something that requires a more recent version of a package installed by the platform?
12:20:52 <joeyh> oh, wait, this test case is wrong
12:20:53 <joe6> mreh: can I clean up the cache?
12:21:07 <joe6> so, does this mean that I cannot install ipprint?
12:21:22 <monochrom> first read http://www.vex.net/~trebla/haskell/sicp.xhtml so you are no longer naïve about cabal.
12:22:47 <dpratt71> monochrom: was that advice directed to me?
12:22:51 <monochrom> yes
12:22:58 <dpratt71> monochrom: ok, thanks
12:23:21 <dcoutts> monochrom: oh interesting, never seen that
12:23:29 <dcoutts> dpratt71: you can do that, the only issue is that installing other things will try to use the newer package versions too which may not be what you want
12:23:31 <dpratt71> monochrom: oh, I've been hoping to find something like this; reading intently
12:23:58 <dpratt71> dcoutts: I see
12:25:47 <dpratt71> given that I already have a 'network' package installed, what should I assume is the reason why I cannot successfully build a more recent version of that package?
12:26:00 * edwardk waves hello.
12:26:24 <roconnor> hi
12:26:30 <maurer_> dpratt71: What is the error message?
12:26:33 <joeyh> hmm, the actual HUnit problem I'm struggling with seems to be that assertBool doesn't work when I compile my program with ghc. Same code with runghc asserts as expected.
12:26:37 <roconnor> edwardk: ghc-pkg has a bug :/
12:26:40 <monochrom> if everything is in a consistent state, a newer version of network should build and install fine
12:26:44 <edwardk> roconnor: ?
12:26:57 <roconnor> it prevents me from registering packages
12:26:59 <roconnor> and makes me sad
12:27:09 <roconnor> :/
12:27:27 <edwardk> =/
12:27:49 <dpratt71> maurer_: depends on which way I try to do it: if I don't use Cygwin, I'm told I should (or MinGW); if I do use Cygwin, I'm told I'm missing HsNet.h
12:28:49 <dpratt71> by the way, the Haskell Platform installs MinGW, does it not? How do I convince cabal that I have it? Or is the error message misleading in this case?
12:29:05 <Zao> dpratt71: Isn't the problem that you lack msys/cygwin.
12:29:13 <Zao> dpratt71: Or some other sufficiently shell-like place to be.
12:29:15 <joeyh> ok, so ghc -O2 seems to break assertBool with a static bool
12:29:24 <McManiaC> how does GHC desugar rec statements? something with mfix...?
12:29:32 <monochrom> yes mfix
12:29:33 <Zao> dpratt71: If memory serves me right, the network package is ./configure-based, so you need a proper environment like msys.
12:29:41 <Zao> dpratt71: Sadly cabal-install doesn't tell you this.
12:29:46 <Zao> You have to try to build it yourself to find out.
12:29:48 <monochrom> see http://www.haskell.org/haskellwiki/MonadFix
12:30:32 <McManiaC> monochrom: thanks
12:30:41 <Zao> dpratt71: If you want a turn-key solution, download msysgit and put your GHC directories first in the path.
12:31:17 <dpratt71> Zao: Pretty sure I have msysgit
12:31:49 <Zao> dpratt71: Shove some of it into path and try again inside a shell?
12:32:01 <sleepynate> leave it to #haskell to have an inhabitant named Zao :D
12:32:03 <Zao> It needs to run the shell script 'configure'.
12:32:12 <Zao> sleepynate: Eh?
12:32:20 <monochrom> and monochrom
12:32:27 <sleepynate> Liberate Te Ex Infernus ?
12:32:28 <Zao> monochrom: Amazing!
12:32:30 <dpratt71> Zao: actually, less sure of my statement now...
12:32:36 <Zao> sleepynate: Not a fan of the band.
12:32:40 <sleepynate> ahh
12:32:46 <sleepynate> sorry then :)
12:32:55 <Zao> sleepynate: You're not the first, heh.
12:33:04 <sleepynate> yea i was all: wait wut
12:33:30 <dpratt71> ...I have the latest version of Git for the Windows platform, but it doesn't identify as msysgit
12:33:50 <dpratt71> got it from the msysgit site, though
12:33:56 <dpratt71> could there be a difference?
12:34:11 <sleepynate> how are you identifying it?
12:34:17 <Zao> Anything will do as long as it has a sh.exe and sufficient support tools.
12:34:20 <Evious> Can anyone think, off the top of their head, of a library that allows XML to be generated from xpath specifications?
12:34:29 <dpratt71> oh, I think there _is_ a difference
12:34:49 <Zao> dpratt71: (I grabbed the -netinstall a year ago or so)
12:35:21 <dpratt71> Zao: yeah, I see now there's two installs: msysgit is the 'dev' one
12:37:15 <monochrom> not sure xpath is for generating or just querying, but hxt-xpath does xpath
12:37:45 <Evious> It's generally a querying thing, but I'd like to do the reverse somehow. 
12:38:09 <joe6> i am checking out Text.PrettyPrint . When I use nest on a doc with a long line, I am noticing that when the long line is wrapped, it starts from the beginning rather than from the indented location
12:40:52 <akosch> is there a function in prelude to perform Integer division?
12:41:21 <mauke> div
12:41:36 <akosch> mauke: thanks
12:44:55 <Zao> Or quot.
12:46:29 <monochrom> that's probably your terminal wrapping rather than Text.PrettyPrint wrapping. Default Text.PrettyPrint line length is 100
12:47:11 <monochrom> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/pretty-1.0.1.2/Text-PrettyPrint-HughesPJ.html#v:style
12:49:07 * monochrom wishes that more programmers are aware that every layer from UI to hardware has the capability to lie.
12:52:57 <pumpkin> thoughtpolice: yo!
12:53:15 <medfly`> "lie"?
12:53:24 <roconnor> edwardk: what is the rational behind splitting up comonads and comonad-transformers?
12:53:53 <pumpkin> roconnor: to have something that could conceivably be added to  base at some point, I think
12:54:10 <roconnor> ooh
12:54:15 <roconnor> forward thinking!
12:54:19 <pumpkin> there was recent discussion of it in libraries@
12:54:29 <pumpkin> I think that's what sparked all his new work on comonads
12:54:32 <monochrom> yes, lie.
12:54:38 * hackagebot json-tools 0.2.2 - A collection of JSON tools  http://hackage.haskell.org/package/json-tools-0.2.2 (NicolasPouillard)
12:57:26 <edwardk> roconnor: comonad is a small package that is pure haskell 98, and would be a viable base candidate
12:57:45 <edwardk> comonad-transformers is targeting the platform
12:57:57 <roconnor> fair
12:58:00 <pumpkin> the P word
12:58:03 <pumpkin> don't mention that to roconnor!
12:58:10 <aristid> comonads-fd is not targeting the platform?
12:58:21 <aristid> pumpkin: the P word = pumpkin?
12:58:23 * roconnor head 'splods
12:58:29 <roconnor> aristid: platform
12:58:45 <aristid> roconnor: do you hate the platform almost as much as mtl?
12:58:49 <roconnor> aristid: the evil Haskell Platform that aims to stagnate Haskell development
12:58:50 <edwardk> aristid: it is, but the factoring into comonad-transformers an comonads-fd is to avoid dependencies on fundeps/mptcs for those who don't want them, and to allow the transformers themselves to be portably 98
12:59:05 <aristid> edwardk: ack.
12:59:23 <roconnor> aristid: actually the Platoforms evilness is the product of all the evil the the pacages it cotains.
12:59:25 <aristid> roconnor: what we really need is a better cabal :)
12:59:33 <roconnor> aristid: making it much more evil than the mtl
13:00:11 <roconnor> edwardk: interesting choice of parameter order for the various Store functions.
13:00:24 <edwardk> roconnor: oh?
13:00:51 <roconnor> edwardk: I would have put the StoreT parameters first, but I don't really know what is best.
13:01:04 <edwardk> i wantd them to be cokleisli arrows
13:01:47 <roconnor> ya
13:02:01 <edwardk> that way you can extend (put s) — etc. alternative parameter orders are unwieldy =)
13:02:07 <roconnor> oh good point
13:02:11 <monochrom> haskell platform is the best thing since first-aid kits
13:02:26 * roconnor head 'slodes
13:03:07 <monochrom> head explode is the best thing since inexhaustive patterns
13:03:14 <edwardk> the parameter order is always chosen so that the cokleisli arrow comes last when possible
13:03:20 <monochrom> perhaps inexplosive patterns too
13:03:26 <edwardk> that should be consistent across the api
13:03:34 <roconnor> edwardk: does transformers do this too?
13:04:03 <edwardk> its easy to always end in a kleisli arrow ;)
13:04:13 * roconnor noticies taht edwardk is VERY fond of irrefutable parameters
13:04:22 <joe6> monochrom: I tried with "renderStyle (Style PageMode 10 1.5)" to eliminate the effect of lineLength but it has no effect.
13:04:26 <c_wraith> no one likes to be refuted
13:04:29 <edwardk> roconnor: only for symmetry with the Lazy/Strict style of transformers
13:04:35 <edwardk> note that both exist
13:05:14 <edwardk> but EnvT is analogous to WriterT in that it offers strict and lazy forms
13:05:23 <edwardk> similarly discont and store
13:05:54 <dpratt71> so close!...I think
13:05:57 <dpratt71> src\Snap\Internal\Http\Server.hs:754:48: Not in scope: `rspCookies'
13:06:21 <c_wraith> By the way, this relates to an excellent interview question for someone who claims to know haskell.  Ask what the operational difference between Identity monads with the Identity type declared as a newtype or data is. :)
13:06:22 <edwardk> i think you will find my argument to be .. irrefutable. *puts on sunglasses*
13:06:56 <c_wraith> The part I find kind of funny is that the newtype is the one that gives you lazy Identity
13:07:06 * pumpkin kicks edwardk 
13:07:29 <c_wraith> edwardk, did you have another pair of sunglasses on already?
13:07:42 <edwardk> of course.
13:08:37 <edwardk> (the truly pathetic thing is i can do this. i have a pair of glasses that sun darken, but have clip ons, because those help better when its REALLY bright or when driving and the window depolarizes the light)
13:09:02 <roconnor> reverse the polarity!
13:09:28 <edwardk> er polarizes
13:10:26 <roconnor> edwardk: does anyone actually use experiment?
13:10:39 <edwardk> roconnor: no idea. its traditional so i kept it
13:10:52 <roconnor> I wonder what the source of that strange function is
13:10:57 <edwardk> i think it was originally list based and i generalized it somewhere
13:11:00 <edwardk> zednenem
13:11:26 <edwardk> with the shiny new ComonadZip functionality i should be able to build Cotraversable i think
13:11:29 <pumpkin> divad zednemem ?
13:11:38 <pumpkin> zednemem divad maybe
13:11:49 <edwardk> thats the zednenem in question
13:12:35 <joe6> > fullRender PageMode 10 1 (Str "texst" "") "" (hsep [text "hello", parens $ text "world"])
13:12:36 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]
13:12:36 <lambdabot>                             ...
13:13:06 <joe6> how do I get this line to work? error about the parameter (TextDetails -> a ->a)
13:13:24 <joe6> i am just testing to see how fullRender works?
13:13:47 * hackagebot comonad 0.3.0 - Haskell 98 comonads  http://hackage.haskell.org/package/comonad-0.3.0 (EdwardKmett)
13:14:39 <roconnor> wait there is a Functor class in Control.Comonad?
13:14:49 <roconnor> wtf?
13:14:53 <edwardk> its re-exported for symmetry with control.monad
13:14:58 <roconnor> oh whew
13:15:16 <edwardk> (in the process, it bothers to expose the non-haskell 98 member of Functor, (<$)
13:15:43 <edwardk> so it does serve a purpose, because you want that for the pseudo-applicative programming style of ComonadZip
13:16:01 <roconnor> edwardk: I think you might be missing 2 laws for the fmap,extrac,duplicat definition
13:16:03 <edwardk> (and because i destroyed the traditional (.>>) and (<<.) combinators
13:16:15 <edwardk> supply them =)
13:16:23 <roconnor> I have to think what they are
13:16:48 * hackagebot comonad-transformers 0.3 - Haskell 98 comonad transformers  http://hackage.haskell.org/package/comonad-transformers-0.3 (EdwardKmett)
13:16:51 <dpratt71> hmm...I can't find a def. for 'rspCookies' anywhere...just one reference, which causes snap-server compile to fail
13:17:33 <roconnor> edwardk: extract (fmap f x) = f (extract x)
13:18:04 <aristid> edwardk: you're iterating rapidly :)
13:18:19 <roconnor> good the last one is going to be annoying
13:18:21 <roconnor> *god
13:19:10 <edwardk> that one i think follows. extract (fmap f x) = extract (extend (f. extract)) = f . extract
13:19:13 <roconnor> edwardk: fmap f x = fmap (fmap f) (duplicate x)
13:19:28 <roconnor> oh, you think they are redudent
13:19:46 <edwardk> ya
13:20:12 <roconnor> I don't see how this follows
13:20:43 <roconnor> <edwardk> extract (fmap f x) = extract (extend (f. extract)) = f (extract x)
13:20:51 <roconnor> how does your second step follow
13:21:06 <roconnor> edwardk: oh wait
13:21:07 <edwardk> extract . extend f = f
13:21:12 <edwardk> its on the second set of laws
13:21:13 <roconnor> you have three more laws at the bottom
13:21:19 <edwardk> yeah
13:21:27 <roconnor> oh no those are only for if you define both
13:21:48 <roconnor> edwardk: anyhow, extract . extend f = f isn't one of the laws in part I.
13:21:51 <roconnor> so you can't use it
13:22:54 <edwardk> i've reordered things so that the sections are swapped favoring expositon in terms of extend/extract
13:23:09 <roconnor> oh I'm reading the 0.1.1 documentation
13:23:11 <roconnor> has it changed?
13:23:26 <edwardk> those three laws at the bottom hold regardless though, because they are the definitions of the functions ;)
13:23:32 <roconnor> right right
13:23:33 <mreh_> ghci can't see the paths module!
13:23:37 <roconnor> forget about those three laws
13:23:37 <edwardk> "the first two are the defaults...."
13:23:48 <roconnor> let me start from the beginning
13:24:03 <roconnor> suppose I define fmap extract and duplicate
13:24:17 <roconnor> and suppose my satify your three laws given in section I.
13:24:26 <roconnor> then you say that I have a comonad, right?
13:24:30 <monochrom> @quote irrefutable
13:24:31 <lambdabot> edwardk says: i love it when my arguments are irrefutable ;)
13:24:44 <joe6> guys, can anyone please help me? I am just trying to get: 
13:24:46 <joe6>       hello ttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttt
13:24:47 <edwardk> well, those were zednenem's words, but that was the claim
13:24:49 <joe6>                           (world aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa                          aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa)
13:24:54 <roconnor> but no I don't.  because you cannot prove extract . (fmap f) = f . extract
13:24:58 <joe6> sorry, that came out all messed up..
13:25:01 <joe6> sorry about that.
13:25:14 <edwardk> extract = fmap f . duplicate in the absence of anything else
13:25:20 <joe6> hello
13:25:26 <joe6>       world
13:25:39 <joe6>          world line continued here
13:25:40 <roconnor> edwardk: that is the definition of extend
13:25:47 <roconnor> edwardk: I'm not talking about extend at all
13:25:48 <edwardk> er sorry
13:25:49 <joe6> sorry for spamming.
13:25:56 <joe6> I will just put it on hpaste.
13:25:58 <edwardk> small screen dark room. misread
13:26:02 <roconnor> np
13:26:08 <parcs> joe6: put what you want to display in a pastebin
13:26:41 <aavogt> joe6: look at  Text.PrettyPrint
13:26:47 <roconnor> edwardk: my claim is you need to add two more laws to section I: extract . (fmap f) = f . extract and duplicate . fmap f = fmap (fmap f) . duplicate
13:27:01 <edwardk> plausible
13:27:03 <aristid> roconnor: unnecessary parens!
13:27:05 <edwardk> checking =)
13:27:11 <aavogt> if you're trying to align things without having to explicitly pass the length of the previous line
13:27:16 <roconnor> aristid: =)
13:27:18 <aristid> => extract . (fmap f)
13:27:22 <aristid> o-m-g
13:27:25 <edwardk> extract . fmap f = f . extract is the original copointed law, so that i buy
13:27:42 <edwardk> but i haven't checked if the fmap id = id law gets you there yet
13:27:46 <roconnor> edwardk: you can refute my claim by proving these two from your three (+ the 2 functor laws)
13:28:09 <roconnor> granted I should be the one with the burdon so I have to come up with a model satifying your three laws but not my two.
13:28:12 <edwardk> hey i just pasted those in there when someone whinged about the lack of docs, i didn't write the text originally =)
13:28:19 <roconnor> but I'm not going to do that cause I am lazy
13:28:41 <roconnor> edwardk: people are right to complain about the lack of doc :D.
13:28:51 <roconnor> though I'm not sure incorrect docs are better than no docs.
13:29:10 <edwardk> okay, i buy it. i'll add the other two laws
13:29:43 <roconnor> edwardk: these two laws say that extract and duplicate are natural transformations.
13:29:51 <Saizan> @free extract :: F a -> a
13:29:51 <lambdabot> f . extract = extract . $map_F f
13:30:01 <roconnor> exactly
13:30:12 <roconnor> @free duplicate :: W a -> W (W a)
13:30:12 <lambdabot> $map_W ($map_W f) . duplicate = duplicate . $map_W f
13:30:18 <edwardk> hrmm
13:30:25 <edwardk> those are free theorems though
13:30:37 <edwardk> so why state them?
13:30:39 <roconnor> edwardk: free if the fmap is the free map for the functor
13:30:51 <aavogt> @free lunch :: food
13:30:51 <lambdabot> f lunch = lunch
13:31:06 <roconnor> edwardk: but is that always the case?
13:31:09 <edwardk> fmap has to satisfy the two functor laws. so you can assume those as well without any extra stuff
13:31:32 <edwardk> fmap id = id is the law you have for Functor, Comonad is a subclass of Functor.
13:31:40 <joe6> does this make sense? http://hpaste.org/42818/pretty_print
13:31:49 <roconnor> @free fmap :: (a -> b) -> F a -> F b
13:31:49 <lambdabot> g . h = k . f => $map_F g . fmap h = fmap k . $map_F f
13:31:51 <edwardk> and fmap f . fmap g = fmap (f . g) follows from the free theorem and the first law
13:32:09 <roconnor> edwardk: so you never have to prove the second law?
13:32:11 <roconnor> for functors?
13:32:13 <edwardk> correct
13:32:16 <roconnor> so why state it?
13:32:20 <edwardk> fmap id = id is sufficient
13:32:27 <edwardk> because people are dumb ;)
13:32:47 <roconnor> then add the natruality laws for extend and duplicate :D
13:32:54 <edwardk> =P
13:33:05 <roconnor> or delete the second functor law
13:33:09 <roconnor> the choice is yours :D
13:33:15 <edwardk> where do i write the functor law?
13:33:16 <mreh_> dist/build/autogen/:src' is not a module name or a source file
13:33:21 <edwardk> i don't =P
13:33:22 <roconnor> edwardk: oh crap
13:33:26 <revenantphx> Do you guys know if a m68k backend for LLVM exists?
13:33:49 <roconnor> edwardk: is fmap always equal to $map_W ?
13:33:52 <revenantphx> I'm thinking of doing a haskell lisp compiler (to LLVM to m68k), to use for my TI-89 :3
13:34:10 <monochrom> joe6: http://hpaste.org/42819/break_line
13:34:12 <mreh> oh, I put a space between the -i and the path
13:34:15 <edwardk> ?
13:34:29 <roconnor> @free duplicate :: W a -> W (W a)
13:34:29 <lambdabot> $map_W ($map_W f) . duplicate = duplicate . $map_W f
13:34:36 <roconnor> see that $map_W
13:34:39 <kmc> revenantphx, you mean a Lisp compiler written in Haskell?
13:34:40 <edwardk> yeah
13:34:45 <roconnor> is that always equal to fmap?
13:34:54 <edwardk> i don't know how to read those very well =)
13:35:00 <revenantphx> kmc: mm
13:35:05 <kmc> fwiw i bet there already exist Lisp compilers targeting m68k, or portable C
13:35:16 <revenantphx> Oh I'm sure :)
13:35:27 <revenantphx> I know there's a lisp interpreter for TI-89
13:36:30 <roconnor> edwardk: prehaps you are right that my two laws are free
13:36:54 <edwardk> roconnor: they appear to be
13:37:05 * roconnor tries to imagine a single data type constructor F with two different functor instances.
13:37:09 <younder> Thereare 5 laws of algebra
13:37:45 <edwardk> roconnor: Functor is uniquely determined by its laws
13:37:50 <roconnor> really
13:37:52 <edwardk> yes
13:38:00 <edwardk> that is why we have DerivingFunctor
13:38:00 <younder> a two law system of anything would be to inflexible
13:38:03 <roconnor> if I write another fmap with the same laws they will be equal?
13:38:07 <edwardk> yes
13:38:17 <joe6> monochrom: thanks, but in my scenario what I have is that the (text "012345") is in fact (text "very very long line") and when this is getting wrapped and starting from the first column of the next line instead of being nested right by 2 
13:38:18 <roconnor> prove it
13:38:22 <edwardk> you first ;)
13:38:28 <joe6> monochrom: does that make sense?
13:38:36 <edwardk> it should be easy to construct a counter example ;)
13:38:42 <edwardk> go for it
13:38:45 <edwardk> you know you want to
13:38:54 <monochrom> word-break your long line, even character-break your long line, then use sep or cat.
13:38:55 <roconnor> I thought you had Dreiving Functor because there was a unique (or canonical) functor for regular data types.
13:39:16 <roconnor> edwardk: you'd save me a lot of trouble if you prove fmap1 = fmap2
13:39:17 <edwardk> i don't really care about how regular it is, either =P
13:39:23 <monochrom> cat (map char "tttttttt") if necessary
13:39:37 <edwardk> its an older claim than me =P
13:39:49 <joe6> monochrom: I was hoping that the prettyprint library would have something like that, built-in. such as for showing nested paragraphs.
13:40:22 <joe6> basically, printing an indented paragraph..
13:40:30 <edwardk> you can build it up (co)inductively though, the action of every functor can be built up out of its parts
13:40:56 <monochrom> well sep (map sep ["word", "for", "word"]) is built-in for showing nested paragraphs.
13:41:00 <edwardk> and you can't break fmap id = id on any of the parts, so you get pushed to the right definition
13:41:12 <monochrom> err, sep (map text ["word", "for", "word"])
13:41:18 <pastorn> okay... i'm having some trouble... i have something like this, let f = readIORef ref >>= doStuff; let xs = [f]; forever (sequence_ xs)
13:41:41 <pastorn> f never gets "recomputed" (reads the vars again)
13:41:50 <roconnor> maybe I can use the Yondea lemma to prove this
13:41:58 * hackagebot TrieMap 0.7.0 - Automatic type inference of generalized tries.  http://hackage.haskell.org/package/TrieMap-0.7.0 (LouisWasserman)
13:41:59 <joe6> monochrom: ok, gotcha.. 
13:42:19 <joe6> break up the paragraphs into char or text and then use them..
13:43:56 <roconnor> edwardk: why is there no raiseYoneda?
13:44:10 <edwardk> because i got bored and moved on to other things? =)
13:44:37 <edwardk> you want f :~> Yoneda f ?
13:44:46 <edwardk> lift
13:44:51 <roconnor> isn't that the theorem?
13:45:02 <roconnor> Nat (h^A,F) is isomorphic to F(A) ?
13:45:06 <edwardk> yeah
13:45:22 <edwardk> it should be there, but i missed it. i think its in one of the later versions i never released
13:45:29 <younder> I am of coerce entirely wrong. You could define any language on a single line.
13:45:35 <edwardk> in the meantime you can abuse lift to get it if f is a monad
13:45:37 <younder> sorry'
13:45:44 <edwardk> because Yoneda is a MonadTrans
13:45:58 <edwardk> ah
13:46:03 <edwardk> its HPointed
13:46:12 <edwardk> raiseYoneda = hreturn
13:46:47 <edwardk> hreturn :: Functor f => f a -> Yoneda f a — in this case
13:46:59 * hackagebot TrieMap 0.7.1 - Automatic type inference of generalized tries.  http://hackage.haskell.org/package/TrieMap-0.7.1 (LouisWasserman)
13:47:03 <jeffwheeler> Is there any to use network-bytestring? It looks like it's entirely integrated to network? (I ask because it looks like it's been that way for a while.)
13:48:42 <roconnor> edwardk: hreturn and lowerYondea form a pair defining an isomorphism?
13:48:49 <edwardk> yes
13:49:05 <pumpkin> is there a Cofree f a -> Fix f ?
13:49:07 <edwardk> you can use hreturn and hextract if you want
13:49:13 <younder> a  network is a quadruple of triplet decimal numbers and fits exactly into 32 bit in IP4
13:49:17 <pumpkin> seems fairly simple
13:49:25 <edwardk> pumpkin: its in scalaz ;)
13:49:29 <pumpkin> oh okay
13:49:32 <younder> 255.255.255.355
13:49:39 <pumpkin> where? I didn't even know scalaz had a Cofree :P
13:49:41 <younder> 255.255.255.255
13:49:47 <edwardk> Recursion.scala
13:49:57 <pumpkin> is there also a Fix f -> (some way of grabbing as) -> Cofree f a ?
13:50:03 <roconnor> edwardk: and raiseYoneda (fmap f x) = fmap f (raiseYondea x) ?
13:50:05 <edwardk> that was the package with the (positive) (co)recursion machinery
13:50:05 --- mode: ChanServ set +o monochrom
13:50:16 --- mode: monochrom set +q *!*@9.244.251.212.customer.cdi.no
13:50:24 <roconnor> edwardk: (those are two different fmaps)
13:50:54 --- mode: monochrom set -o monochrom
13:50:54 <edwardk> that is parametricity talking again. but you're kind of asuming the hypothesis this direction
13:51:08 <roconnor> hmm
13:51:25 <pumpkin> edwardk: https://github.com/ekmett/scalaz/blob/master/core/src/main/scala/scalaz/Recursion.scala ?
13:51:34 <roconnor> anyhow you are probably right that fmap is uniquely defined
13:51:38 <roconnor> I don't know how to prove it.
13:52:34 <edwardk> a _correct_ Functor instance is uniquely defined at least ;)
13:53:03 <roconnor> if fmap1 id x = x and fmap2 id x = x then fmap1 f x = fmap2 f x
13:53:35 <roconnor> this is the claim I believe
13:54:35 <edwardk> yep
13:55:18 <edwardk> the first step iirc is to prove thet fmapN f . fmapN g = fmap (f . g) from fmap id = id
13:55:20 <edwardk> erm
13:55:34 <telephone> Is there any efficient way of removing a element defined by predicate in a list?
13:55:51 <mauke> is there an inefficient way?
13:56:05 <monochrom> > filter even [3,1,4,1,5,9,2,6,5,3]
13:56:06 <lambdabot>   [4,2,6]
13:56:19 <edwardk> i think the gripe is that the combinators involved will require two traversals in most cases
13:56:25 <joe6> monochrom: the interaction of renderStyle with sep is very interesting.
13:56:28 <c_wraith> mauke: sure.  You could start at the beginning of the list every time you remove something.
13:56:55 <monochrom> there is a doubly-exponential algorithm for filter :)
13:57:00 <edwardk> pumpkin: re cofree from fix i have a blog post on that
13:57:06 <telephone> mauke: well, I did not find any satisfiable function in Data.List...
13:57:12 <mauke> telephone: filter?
13:57:14 <c_wraith> In my experience, you can always make an algorithm worse
13:57:20 <djahandarie> You could try filtering by randomly accessing elements
13:57:22 <joe6> renderStyl seems to go into the depths of the doc and repartition it?
13:57:25 <djahandarie> Worst case O(inf)!!!
13:57:29 <monochrom> In my theory, you can also always make an algorithm worse :)
13:57:30 <joe6> I meant renderStyle.
13:58:08 <roconnor> @free fmap
13:58:09 <lambdabot> Expected variable or '.'
13:58:13 <roconnor> @free map
13:58:14 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
13:58:20 <c_wraith> I wrote a double-exponential sorting algorithm once.  Took 20 minutes to sort an 8-number list.
13:58:39 <roconnor> ahha
13:59:06 <monochrom> I know doubly-exponential algorithms for solving linear equations like x-2 = 0
13:59:21 <yrlnry> What does $map mean in the free theorem?
13:59:21 <telephone> mauke: I wanted something like 'extractBy :: (a -> Bool) -> [a] -> Maybe (a, [a])'
13:59:24 <yrlnry> @free id
13:59:25 <lambdabot> f . id = id . f
13:59:36 <mauke> telephone: what if there's more than one matching element?
13:59:37 <roconnor> edwardk: fmap1 f ($map_F id x) = $map_F f (fmap1 id x)  -- by the free theorem for fmap1
13:59:55 <roconnor> similarly fmap2 f ($map_F id x) = $map_F f (fmap2 id x)
14:00:10 <roconnor> but (fmap1 id x) = x = (fmap2 id x)
14:00:13 <edwardk> happier now? =)
14:00:13 <telephone> mauke: then just pick one, leaving the others in the list
14:00:27 <roconnor> so fmap1 f x = fmap2 f x
14:00:27 <yrlnry> I read the "free theorems" paper more than once, but I was not able to understand what the point was.
14:00:49 <mauke> :t break
14:00:49 <roconnor> @free sortBy
14:00:50 <lambdabot> (forall x. g x = h (f x) . f) => $map f . sortBy g = sortBy h . $map f
14:00:50 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
14:00:58 <yrlnry> @free swap
14:00:59 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `swap'\n\n"
14:01:15 <mauke> @free swap :: (a,b) -> (b,a)
14:01:15 <lambdabot> $map_Pair g f . swap = swap . $map_Pair f g
14:01:18 <roconnor> yrlnry: free theorems are a very usefull tool for program transformation
14:01:24 <telephone> mauke: I can write such function, but I am not sure about the efficienty of removing one element inside. But filter do something similar...
14:01:36 <mauke> telephone: you could use break
14:01:41 <joe6> monochrom: that example of yours was pretty useful. How did you come up with it? have you used renderStyle before? How did you know that it will drill through the doc. I was under the impression that I had to add nesting for each doc before concatenating them.
14:01:50 <c_wraith> telephone: removing one element is O(n), inherently.
14:01:53 <yrlnry> roconnor:  the idea is that since the computer can derive the free theorems automatically, it may also be able to transform the code in some useful fashion also?
14:02:02 <joe6> > putStrLn $ renderStyle (Style PageMode 14 1.5)  (nest 2 (cat (map char "0123456789")))
14:02:03 <lambdabot>   <IO ()>
14:02:05 <elliott> @hoogle String -> Integer -> String
14:02:06 <lambdabot> Text.XHtml.Strict renderHtmlWithLanguage :: HTML html => String -> html -> String
14:02:06 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
14:02:06 <lambdabot> Data.List genericTake :: Integral i => i -> [a] -> [a]
14:02:09 <elliott> Hmph.
14:02:14 <joe6> > renderStyle (Style PageMode 14 1.5)  (nest 2 (cat (map char "0123456789")))
14:02:16 <elliott> What's that generic integer-to-base function?
14:02:16 <lambdabot>   "  0\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9"
14:02:19 <telephone> mauke: maybe my solution was not so bad.
14:02:23 <c_wraith> :t showAtBase
14:02:24 <lambdabot> Not in scope: `showAtBase'
14:02:32 <c_wraith> Blah, it's something like that
14:02:38 <roconnor> yrlnry: possibly, but usually I'm the one transforming my own programs
14:02:49 <c_wraith> @hoogle Integer -> Integer -> String -> String
14:02:49 <mauke> telephone: extractBy f xs = case break f xs of (ps, x : qs) -> Just (x, ps ++ qs); _ -> Nothing
14:02:50 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
14:02:50 <lambdabot> Data.List zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
14:02:50 <lambdabot> Data.List zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
14:03:02 <yrlnry> Wait, are not these free theorems just the universal properties for the functions when you consider them as arrows in the Hask category?
14:03:05 <elliott> @hoogle atBase
14:03:05 <lambdabot> Numeric showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
14:03:11 <elliott> c_wraith: Indeedily.
14:03:17 <c_wraith> ah.  there you go :)
14:03:20 <monochrom> joe6: I came up with it by a bit of guessing what the documentation means and a bit of verifying experiments. the scientific method in short.
14:03:25 <yrlnry> @free (+ 1)
14:03:26 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
14:03:30 <elliott> Hmph.
14:03:32 <elliott> Terrible API.
14:03:41 <elliott> It should be "String -> a -> ShowS".
14:03:47 <c_wraith> It's as low-level as possible
14:04:10 <c_wraith> @hoogle Int -> Char
14:04:10 <elliott> Yeah, for all that high-performance inner-loop integer printing.
14:04:11 <lambdabot> Data.Char chr :: Int -> Char
14:04:11 <lambdabot> Data.Char intToDigit :: Int -> Char
14:04:11 <lambdabot> Data.ByteString.Char8 index :: ByteString -> Int -> Char
14:04:12 <Peaker> @info ShowS
14:04:13 <lambdabot> ShowS
14:04:18 <Peaker> @src ShowS
14:04:19 <lambdabot> type ShowS = String -> String
14:04:23 <roconnor> yrlnry: free theorems only really apply to polymorphic functions
14:04:23 <joe6> monochrom: ok, thanks..
14:04:39 <elliott> Is there anything wrong with "blah s = showIntAtBase (length s) (s!!)"?
14:04:42 <c_wraith> at least you can use intToDigit
14:04:47 --- mode: ChanServ set +o monochrom
14:04:47 <yrlnry> roconnor:  sure, because those are the ones that are natural transformations
14:04:50 <c_wraith> > intToDigit 11
14:04:51 <lambdabot>   'b'
14:04:55 --- mode: monochrom set +b *!*@quark.teteny.elte.hu
14:04:59 <c_wraith> > intToDigit 36
14:05:01 <lambdabot>   *Exception: Char.intToDigit: not a digit 36
14:05:01 --- mode: monochrom set -q *!*@quark.teteny.elte.hu
14:05:05 <roconnor> yrlnry: it is the theorem that state (this polymophic function doesn't look at the values of the polymorphic data)
14:05:10 <roconnor> yrlnry: exactly
14:05:12 --- kick: DevHC was kicked by monochrom (DevHC)
14:05:17 --- mode: monochrom set -o monochrom
14:05:26 <yrlnry> Okay.
14:05:26 <roconnor> yrlnry: the free theorem is the law stating that the polymorphic function is a natural transformation ... more or less
14:06:06 * roconnor normally thinks of a natural transformation as specifically being a function of type forall a. F a -> G a.
14:06:21 <elliott> c_wraith: heh, great, i can't use it then
14:06:29 <elliott> c_wraith: need 26 to 62 as uppercases
14:06:32 <roconnor> @free eta :: forall a, F a -> G a
14:06:32 <lambdabot> Extra stuff at end of line
14:06:37 <roconnor> @free eta :: F a -> G a
14:06:37 <lambdabot> $map_G f . eta = eta . $map_F f
14:06:42 <elliott> @hoogle ShowS -> String
14:06:43 <lambdabot> Data.Generics.Aliases ext1T :: (Data d, Typeable1 t) => (e -> e) -> (t f -> t f) -> d -> d
14:06:53 <c_wraith> elliott, that's just ""
14:07:04 <elliott> c_wraith: oh, indeed.
14:07:15 <c_wraith> Well.  ($ "")
14:07:38 <roconnor> yrlnry: I found the free theorem for sortBy to be quite helpful for reasoning about sortBy
14:07:53 <roconnor> some of these free theorems are quite powerfull
14:07:53 <yrlnry> Okay, thanks.
14:08:00 <roconnor> @free sortBy
14:08:01 <lambdabot> (forall x. g x = h (f x) . f) => $map f . sortBy g = sortBy h . $map f
14:08:15 <roconnor> there are lots of possiblities for g f and h there
14:08:19 <elliott> c_wraith: strange that there's no function for it though
14:08:35 <roconnor> (the precodition more clearly reads g x y = h (f x) (f y)
14:09:41 <yrlnry> @free sort :: [a] -> [a]
14:09:41 <lambdabot> $map f . sort = sort . $map f
14:09:45 <yrlnry> Now what is that ^^ ??
14:09:49 <yrlnry> That is not true.
14:10:04 <yrlnry> What happened there?
14:10:13 <aavogt> sort doesn't have that type
14:10:23 <yrlnry> Okay, so what went wrong?
14:10:28 <j-invariant> :t sort
14:10:29 <lambdabot> forall a. (Ord a) => [a] -> [a]
14:10:30 <c_wraith> You lost the Ord restriction
14:10:52 <monochrom> "meaningful identifier" went wrong
14:11:00 <aavogt> yrlnry: the  map f  is basically id
14:11:06 <monochrom> @free solve_halting_problem :: [a] -> [a]
14:11:07 <lambdabot> $map f . solve_halting_problem = solve_halting_problem . $map f
14:11:19 <yrlnry> Aha.
14:11:22 <yrlnry> Thanks.
14:11:49 <c_wraith> What you should be learning from this is that restrictions give you power. :)
14:12:36 <monochrom> @free does_it_halt :: program -> Bool
14:12:36 <lambdabot> does_it_halt = does_it_halt . f
14:13:01 <yrlnry> @free poo :: (a -> a) -> a
14:13:01 <lambdabot> f . g = h . f => f (poo g) = poo h
14:13:25 <yrlnry> @free poo :: ((a -> b) -> a) -> a
14:13:26 <lambdabot> (forall p q. g . p = q . f             =>              f (h p) = k q) => f (poo h) = poo k
14:13:47 <mreh> freedom is the antithesis of choice
14:14:02 <monochrom> @free does_not_sort :: (Ord a) => [a] -> [a]
14:14:02 <lambdabot> Extra stuff at end of line
14:14:06 <yrlnry> "forall p q. g . p = q . f" would appear to be a very strong condition on g and f.
14:14:07 <monochrom> oh well
14:14:43 <zachk> after i cabal install a program, I am assuming the source code is saved, on a default install of cabal where does this source code get saved? 
14:14:51 <elliott> @free pork :: a -> b
14:14:52 <lambdabot> g . pork = pork . f
14:15:00 <elliott> what a useful theorem.
14:15:05 <monochrom> source code is not saved
14:15:10 <mreh> @free jesus
14:15:11 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `jesus'\n\n"
14:15:14 <aavogt> @free take 5 :: [a] -> [a]
14:15:14 <lambdabot> Extra stuff at end of line
14:15:28 <mreh> i thought you were just typing in random things
14:15:43 <maurer_> zachk: ~/.cabal/packages/hackage.haskell.org/packagename/packageversion/packagename-packageversion.tar.gz
14:15:46 <monochrom> actually, the source code tarball is saved in a "cache". use "cabal unpack" to get it again, and observe that no network traffic is incurred.
14:15:47 <zachk> monochrom oh ok how do i download and save the source then , is there a cabal command to do that and where is it saved too 
14:15:54 <yrlnry> I don't understand this one either:
14:15:59 <yrlnry> @free k :: a -> b -> a
14:15:59 <lambdabot> f . k x = k (f x) . g
14:16:16 <yrlnry> k does have the indicated type, but the theorem seems to be false.
14:16:34 <elliott> what's the best thing for sha-1?
14:16:46 <yrlnry> I should probably just reread the paper.
14:16:51 <edwardk> f . const a = const (f a) . g — note you don't care what the function g is
14:17:00 <byorgey> yrlnry: that theorem seems true to me.
14:17:01 <edwardk> because you're going to ignore that argument
14:17:11 <knobo> I'm playing with yesod, and have defined a new data type (data Facts = Facts { factName :: String }) in a file and I'm trying to use it in a different file. I have done "import Facts" in the top of the file, but i still get "Not in scope 'factName'" 
14:17:24 <edwardk> f (const a b) = const (f a) (g b) — if the pointed form is more readable to you
14:17:36 <byorgey> do you ignore the second argument before or after applying f to the first argument?  it doesn't matter.
14:17:37 <knobo> why do I get "Not in scope ..."`?
14:17:44 <edwardk> f (const a b) = const (f a) b = const (f a) (whatever b)
14:17:56 <elliott> knobo: did you export factName?
14:17:58 <elliott> you have to
14:18:02 <elliott> in the defining module
14:18:10 <knobo> yes
14:18:36 <knobo> module Modulename (... , Facts) where ...
14:18:38 <yrlnry> Okay, I'll think about it more carefully.  Thanks.
14:18:47 <yrlnry> Hi, Brent.  How's life inside the walled garden?
14:18:54 <mauke> knobo: Facts(..)
14:18:54 <byorgey> knobo: putting 'Facts' by itself will only export the type and not any of its constructors or fields
14:19:03 <knobo> aha..
14:19:16 <knobo> how do I export the constructors and fields?
14:19:25 <knobo> I add (..) ?
14:19:27 <knobo> maybe
14:19:31 <byorgey> like mauke said. yes.
14:19:39 <monochrom> module Hello(Facts(..)) where
14:19:40 <knobo> aha.
14:19:40 <byorgey> hi Mark. Life is good.
14:20:01 <monochrom> module Hello where
14:20:11 <zachk> @src break 
14:20:11 <lambdabot> Source not found. stty: unknown mode: doofus
14:20:26 <knobo> it worked :)
14:20:55 <hpc> > const 2 . undefined $ undefined
14:20:57 <lambdabot>   2
14:21:01 <monochrom> actually there are only two reasons for me to explicitly list exports. when I really have something to hide (auxilliary functions). when I want to help haddock.
14:21:01 <hpc> :D
14:24:23 <Peaker> monochrom, don't forget hiding implementation details (e.g: not exporting constructors)
14:24:38 <monochrom> yeah
14:24:44 <Peaker> I guess that's what you meant there, on second read
14:24:56 <Peaker> though "auxiliary functions" seems too specific
14:25:26 <monochrom> it's ok, I omitted many things. You see I really have something to hide.
14:29:03 <nzero> Hi, what's the best way to search for the existence of a fixed string in a Lazy.Char8 ByteString?  ByteString ->  ByteString -> Bool.  isInfixOf is not implemented.
14:29:58 <knobo> what does being imported qualified mean?
14:30:52 <Peaker> nzero, http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#v:isInfixOf
14:31:06 <nzero> knobo: means you will have access to the fns but you'll have to name the module on each use of them http://learnyouahaskell.com/modules
14:31:07 <Peaker> knobo, you get the module name as a qualifier you can use to refer to names
14:31:17 <Peaker> import qualified Data.Map
14:31:23 <Peaker> Data.Map.fromList
14:32:21 <knobo> ok, thanx
14:34:09 <nzero> Peaker: thanks, but in the lazy version, isInfixOf is not implemented. Only isPrefixOf.  http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString-Lazy-Char8.html#v:isPrefixOf
14:34:42 <Peaker> nzero, doing it properly is actually a non-trivial algorithm
14:35:06 <Peaker> nzero, doing it improperly, however, is pretty trivial :)
14:35:39 <kmc> import qualified Data.Map as M
14:35:41 <kmc> M.fromList
14:35:54 <j-invariant> I can't fix this guys code:(
14:36:48 <Peaker> nzero, maybe unpacking to [Word8] and using isInfixOf on those would be ok (not lose much laziness, and same O(), supposedly)
14:37:14 <nzero> Peaker: I have two alternatives I've tried so far - regexps (overkill), and extracting the field and comparing with (==) - possible because the sought string is both fixed and also in a known field in a space-separated log format.
14:38:35 <Peaker> nzero, extracting sounds like the best idea
14:38:39 <Peaker> nzero, also probably cheapest
14:41:34 <j-invariant> This is horrible
14:41:50 <j-invariant> I have like 30 lines of this guys code which is all pure functions and have to change it all to state monad
14:42:37 <monochrom> how to change "f x = y" to state monad: "statef x = return y"
14:43:15 <edwardk> i'm debating if i like the current Stream transformer comonad, its kinda bulky
14:43:19 <ezyang> I mean, there's no point in rewriting code. Just write something that lifts the pure code into the monad you need. 
14:43:32 <ezyang> rewrite if you need to extend functionality 
14:43:39 <nzero> Peaker: I couldn't find equivalent of pack/ unpack for Word8.   String -> Word8 ?  The examples in the docs say you can do split 'a' "aXaXaXa"  but I'm guessing they're just copied from Char8.
14:43:40 <ezyang> but you'd have to edit that code anyway. 
14:44:01 <edwardk> on one hand, this is good because it indicates nontriviality. on the other its bad because it is hard to reason about or use
14:44:19 <Saizan> does transforming map to 
14:44:28 <Peaker> nzero, Well, remember that ByteString is just a string of bytes, it's not text, so it isn't easily a String
14:44:39 <Peaker> nzero, to convert ByteString to String you have to choose which decoding to use
14:44:40 <kafee> why do I get a stack overflow: http://hpaste.org/42821/stack ?
14:44:45 <ezyang> edwardk: Linky? 
14:44:48 <edwardk> Saizan: right now its w (a, StreamT f w a)
14:45:02 <Peaker> nzero, a simple ASCII decoding you could use is Data.ByteString.[Lazy.]Char8.unpack  or you could use UTF8 instead of Char8
14:45:14 <Peaker> nzero, [Char] is actually a list of Unicode code points
14:45:17 <edwardk> ezyang: http://hackage.haskell.org/packages/archive/comonad-transformers/0.2.1/doc/html/Control-Comonad-Trans-Stream.html
14:45:39 <Peaker> @hoogle ByteString -> String
14:45:40 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
14:45:40 <lambdabot> Data.ByteString.Lazy.Char8 unpack :: ByteString -> [Char]
14:45:40 <lambdabot> Prelude show :: Show a => a -> String
14:45:53 <Peaker> nzero, ^^
14:45:59 <edwardk> but you can see that as a sort of partially unrolled Stream (f `o` w) a
14:46:13 <john_r_watson> testing newlines in3 :: KnightPos -> [KnightPos] in3 start = deDupe $ ([start] >>= moveKnight >>= moveKnight) `dd2` moveKnight  
14:46:14 <Saizan> edwardk: your autocorrection is quite zelous :)
14:46:19 <ezyang> kafee: That code is kind of smelly 
14:46:20 <edwardk> i'm thinking it may make more principled sense to just define Stream f a as a non-transformer
14:46:28 <ezyang> Why are you using IORef? 
14:47:20 <john_r_watson> Is there an operator like (-:) x y = y x defined somewhere?
14:47:21 <edwardk> Saizan: not used to typing on a couch, not that i'm very good at avoiding typos when chatting on any day ;)
14:47:23 <Saizan> edwardk: it doesn't seem worse than defining Writer using WriterT
14:47:28 <Botje> john_r_watson: flip
14:47:36 <Botje> flip id, actually
14:47:40 <edwardk> fair enough, i just haven't generalized all the operations to it yet
14:47:42 <john_r_watson> flip id
14:47:48 <john_r_watson> righteo
14:47:53 <john_r_watson> pl flip id
14:47:57 <john_r_watson> @pl flip id
14:47:57 <lambdabot> flip id
14:48:09 <kmc> :t flip id
14:48:11 <lambdabot> forall a b. a -> (a -> b) -> b
14:48:12 <djahandarie> (There aren't any points there in the first place :P)
14:48:26 <kmc> "points" = bound variables
14:48:35 <edwardk> tails is easy, unfoldsW is probably another class
14:48:51 <edwardk> second, i haven't thought through yet if it makes sense to have strict and lazy versions of it because of the pair
14:48:57 <edwardk> Saizan: thoughts?
14:49:01 <j-invariant> is there something like 'find' except just gives a bool?
14:49:16 <mux> :t elem
14:49:18 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
14:49:41 <mux> > 3 `elem` [1..10]
14:49:42 <lambdabot>   True
14:49:55 <j-invariant> thanks
14:49:57 <edwardk> but then a 'Lazy' stream has a fairly different connotation than that implementation would
14:50:28 <john_r_watson> someListOp = sortBy compare
14:51:00 <edwardk> i do wish the transformers bothered to implement Data.Data, Show, Read, etc. where possible
14:51:25 <edwardk> but i can see the flip side of the concern
14:51:40 <nzero> Peaker: thanks very much.  I guess it's going to be cheaper to break the lines into space-delimited fields than to run a conversion on each byte.  (pack "sought") == ((split ' ' bs) !! 6) will only split lazily until it has the 6th I'm hoping.
14:52:11 <john_r_watson> (flip id) [1..10] (sortBy compare)
14:52:12 <parcs> @src sort
14:52:12 <john_r_watson> gotcha
14:52:13 <lambdabot> sort = sortBy compare
14:52:17 <Peaker> nzero, not sure what laziness you expect from split :)
14:52:25 <Peaker> nzero, oh, not going after the 6th? most probably
14:52:41 <Peaker> nzero, if it returns a lazy list, it most likely won't generate more elements than are used in the result list
14:55:20 <john_r_watson> I still think I'd prefer:
14:57:35 <Peaker> john_r_watson, IMO: use ($) and not id when the type is specialized anyway (or do you use fmap in place of map, even on lists?)
14:58:48 <pastorn> @pl (\i -> (+i))
14:58:49 <lambdabot> (+)
14:59:09 <pastorn> @pl f >>= g . (\i -> (+i))
14:59:09 <lambdabot> g . (+) =<< f
14:59:35 * hackagebot pandoc 1.6.0.1 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.6.0.1 (JohnMacFarlane)
15:02:27 * kmc <3 pandoc
15:02:29 <kmc> i'm using it right now
15:02:39 <ikeg> me too
15:04:17 <edwardk> gah, to zip streams i need a general purpose functor zip =/
15:04:39 <edwardk> which means factoring ComonadZip out of Control.Comonad =(
15:04:53 <edwardk> or at least peeling off a Data.Functor.Zip
15:04:59 <ikeg> i wonder if we can look the CHANGES log at hackage
15:05:33 <ikeg> looking for changes between 1.6 and 1.6.1 for pandoc, indeed
15:07:34 <edwardk> the question is should the Functor version not presuppose the Zip-like structure, and just be a Preapplicative
15:09:08 <knobo> is there any good tokyo tyrant lib to haskell?
15:09:29 <edwardk> ideas for a good name for an Applicative sans pure?
15:09:43 <ezyang> Unpointed applicative? 
15:10:00 <edwardk> ezyang: preferably something i can run into a class name
15:10:06 <ezyang> yeah :-) 
15:10:29 <ikeg> knobo: how about the tokyotyrant-haskell at hackage? i have not touched it though... http://hackage.haskell.org/package/tokyotyrant-haskell
15:11:09 <edwardk> options: i can make it just a weaker 'pre-applicative' or i can make it stronger and make it Data.Functor.Zip — but the law i use for ComonadZip is that extract (f <.> x) = extract f (extract x) — so i'd need a way to relate that to just a functor
15:11:35 <edwardk> oh
15:11:37 <edwardk> thats easy
15:11:41 <Peaker> Maybe the names of Functor, Applicative, Monad, could be (to emphasize the programmatic side): Mappable, Sequencable, Joinable
15:12:08 <edwardk> peaker: the 'able' thing is a bit of a disease though, because you lose focus on the laws
15:12:22 <edwardk> and there is the able vs. ible debate for some types ;)
15:12:29 <Peaker> edwardk, So an obscure name is easier to attach laws to? :)
15:12:34 <knobo> ikeg: no, it's not good.
15:12:42 <edwardk> =P
15:13:52 <knobo> It's the second time i give up tokyo cabinet/tyrant :(
15:14:11 <knobo> I tried with lisp once, also.
15:14:26 <zachk> tokyo cabinet?
15:14:28 * ezyang can't think of anything clever 
15:14:31 <john_r_watson> got booted earlier.  but I was trying to suggest that an operator like:
15:14:31 <john_r_watson> (-:) :: a -> (a -> b) -> b
15:14:31 <john_r_watson> a -: f = f a
15:14:34 <john_r_watson> is worthwhile
15:14:43 <john_r_watson> as opposed to flip
15:14:46 <john_r_watson> (flip id)
15:14:48 <john_r_watson> i should say
15:14:59 <john_r_watson> Is this not in Control.Arrows somewhere?
15:15:03 <edwardk> i think i'm going to just go with Data.Functor.Zip with the law that const <$> fa <*> fb = fa and const id <$> fa <*> fb = fb
15:15:13 <edwardk> that way its not a 'pre-applicative'
15:15:25 <edwardk> er <.> instead of <*>
15:15:36 <john_r_watson> :t <.>
15:15:37 <lambdabot> parse error on input `<.>'
15:15:44 <john_r_watson> :t (<.>)
15:15:45 <lambdabot> forall v. (InnerSpace v) => v -> v -> Scalar v
15:15:50 <edwardk> <.> is in my Control.Comonad for ComonadZip
15:16:07 <edwardk> just moving it out so i can use it for Functor, so i can make a Stream comonad zippable
15:16:16 <john_r_watson> [10..1] -: sort
15:16:22 <edwardk> otherwise you can't use streams for dataflow programming, which kinda defeats the purpose =)
15:16:28 <john_r_watson> vs flip id [10..1] sort
15:16:54 <j-invariant> flip id [10..1] sort <--- looks rather backwards!
15:17:09 <edwardk> hah
15:17:11 <john_r_watson> j-invariant: :) yeah not a great example
15:17:23 <john_r_watson> I was playing w/ knights tour for instance
15:17:36 <john_r_watson> and used it like so:
15:17:54 <john_r_watson> [start] >>= moveKnight >>= moveKnight -: deDupe >>= moveKnight -: deDupe
15:18:24 <john_r_watson> rather than
15:18:24 <john_r_watson> deDupe $ (deDupe ([start] >>= moveKnight >>= moveKnight)) >>= moveKnight
15:19:29 <knobo> looks like tokyo cabinet libs are better then tokyo tyrant
15:19:51 <john_r_watson> (and it should be [10,9..1] sorry)
15:22:49 <mreh> can I set a package dependency in ghci?
15:25:35 <dpratt71> so I got snap-server to build (thanks monochrom, Zao, et al), but...
15:26:02 <edwardk> interestingly i just realized that ComonadZip requires that u <. _ = u — duh
15:26:19 <Zao> dpratt71: Yay.
15:26:53 <dpratt71> ...I had to revert to the current-1 commit of Server.h before it would build
15:27:37 <dpratt71> it really does appear to be an error in the most recent Server.hs
15:27:44 <edwardk> er no thats stronger than i want
15:28:02 <dpratt71> but there've been several commits sense :S
15:28:30 <dpratt71> btw, I meant Server.hs the first time, too
15:29:47 <dpratt71> oy! since, not sense!
15:30:50 <McManiaC> http://paste.xinu.at/7VMB/ because one version isn't enough :>
15:41:20 <77CAAKICP> hey
15:41:43 <jmcarthur> edwardk: okay, so you've been working on the comonad package, but you said one or two others too. what were they?
15:42:13 <jmcarthur> i just happened to want some comonad stuff today, so the timing is good :)
15:42:27 <aristid> jmcarthur: comonad-transformers, comonads-fd, comonads-tf
15:43:04 <jmcarthur> ah
15:43:13 <jmcarthur> oh cool, a whole stack of stuff
15:43:32 * alpounet has been flooded by edwardk's package uploads on twitter
15:44:03 <77CAAKICP> can someone tell me some tipps and tricks to improve my code http://hpaste.org/paste/42631/quarto_annotation_annotatio#p42824
15:46:10 <c_wraith> What library has the most efficient/correct UTF-8 -> String conversion these days?
15:48:10 <Cale> 77CAAKICP: You could get some use out of the Maybe monad in readMove'
15:48:54 <Cale> do row <- readRowOrCol mrow; ... f <- readFill mf; return ((row,col),(c,h,s,f))
15:49:01 <poucet> Hm
15:49:01 <lambdabot> poucet: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:49:24 <poucet> Strictness is making my data-structure acess allocate memory :(
15:49:43 <Cale> Also, whenever you have a lot of ++'s, sometimes concat is nicer.
15:49:54 <77CAAKICP> Cale: any good example
15:50:03 <Cale> of what? concat?
15:50:14 <Cale> concat [x,y,z] is the same as x ++ y ++ z
15:51:18 <sudoer_> I'm new here, sorry if this is outside of the noraml decorum but - does anyone know if there's such a thing as a balanced, confluentially persistent tree in Haskell or even in theory? I.E., like a finger tree, but meldable.
15:53:49 <77CAAKICP> Cale: ok
15:54:41 <77CAAKICP> Cale: I mean an example of maybe monads
15:54:41 <zmbmartin> I am working on learning haskell. Are the Channel 9 video lectures on Programming in Haskell good to watch?
15:55:18 <ddarius> zmbmartin: I don't think so, but I'm a notable curmudgeon.
15:55:49 <opqdonut_> sudoer_: meldable?
15:55:53 <hpc> @src concat
15:55:54 <lambdabot> concat = foldr (++) []
15:56:00 <ddarius> preflex: seen copumpkin
15:56:00 <preflex>  copumpkin was last seen on #haskell-blah 43 minutes and 28 seconds ago, saying: cause of the pills or the music?
15:56:16 <copumpkin> greetings!
15:56:17 <sudoer_> That is, like source distributed source control where you can "merge" two versions and get a stable, specific, sensical outcome.
15:56:22 <zmbmartin> ddarius: Is reading learn you a haskell and and real world haskell a better idea
15:56:48 <opqdonut_> sudoer_: oh. haven't bumped into such things, but there are functional red-and-black trees for example
15:56:50 <ddarius> zmbmartin: I can't say anything about LYAH, though a lot of people seem to like it.  RWH is reasonably good if you have prior programming experience.
15:57:02 <ddarius> copumpkin: Want to try that Druid thing again tomorrow around 7PM?
15:57:05 <zmbmartin> ddarius: Thanks
15:57:27 <opqdonut_> sudoer_: (okasaki has an implementatio for example)
15:57:43 <copumpkin> ddarius: sure!
15:57:55 <opqdonut_> other balancing schemes produce nice persistent structures too
15:58:24 <copumpkin> ddarius where is it?
15:58:24 <c_wraith> I feel like RWH is good if you have a basic understanding of haskell's syntax, and have done some toy things, but want to see how to use it for non-toy use.
15:58:36 <sudoer_> Well, I know finger trees do everything I want, but I'm not sure how to merge them.
15:58:43 <c_wraith> But it's not a good way to develop a basic understanding of syntax
15:59:34 <opqdonut_> sudoer_: I'm curious as to what type of meld operation you are after
15:59:34 * poucet hmms
15:59:39 <monochrom> syntax and types of haskell should be very easy to pick up if you are a clean slate.
15:59:56 <ddarius> copumpkin: http://www.druidpub.com/directions.html
15:59:57 <poucet> Anyone very familiar with strictness in datatypes?
16:00:20 <poucet> For some reason, field accessors are allocating memory/
16:00:22 <dcoutts> any OSX users around? care to test this new version of the iconv binding?
16:00:22 <c_wraith> monochrom, well not just syntax.  Things like ($).  Basic functions.  Things that get used without any explanation in the text.
16:00:24 <sudoer_> How do I talk @ someone?
16:00:24 <dcoutts> http://code.haskell.org/~duncan/iconv-0.4.1.0.tar.gz
16:00:42 <mlh> sudoer_:  /msg thatsomeone
16:00:44 <opqdonut_> poucet: you have a thunk in the field, I guess?
16:00:52 <poucet> dcoutts: FYI, I am using brew and it is working great
16:00:56 <mlh> but more than one person is interesting prob
16:00:58 <poucet> opqdonut_: nope, it's a strict value
16:01:18 <dcoutts> poucet: hmm, perhaps you're using the macports version of iconv
16:01:22 <opqdonut_> interesting, do you have a small example at hand?
16:01:26 <poucet> dcoutts: I killed macports :)
16:01:31 <copumpkin> ddarius: great, thanks!
16:01:32 <dcoutts> poucet: this binding should work with the native OSX iconv
16:01:33 <poucet> dcoutts: since that would not let me install ghc-core, now I use brew and it works
16:01:41 <poucet> (needed for pcre_)
16:02:02 <dcoutts> poucet: ok, well some other iconv lib other than the one that comes with the system
16:02:03 <poucet> opqdonut_: unfortunately not a small one
16:02:29 <dcoutts> poucet: I'm guessing brew is another set of packages right?
16:02:34 <poucet> opqdonut_: My guess is that becuase I have two cor-recursive functions, the one that is doing the field accessor does not know that the other function is strict in terms of the sub-part and thus allocates for it
16:02:38 <poucet> dcoutts: correct
16:02:43 <poucet> I believe the fullname is homebrew
16:02:46 <poucet> It was trivial to install
16:03:12 <opqdonut_> poucet: hmm, okay. that's a bit out of my depth
16:03:14 <poucet> I have an email to myself about it with details to put on my blog, exactly because I ran into iconv issues with macports, and I needed some kind of install system for pcre
16:03:19 <opqdonut_> but have you tried turning the field strict?
16:03:24 <poucet> opqdonut_: they are strict
16:03:30 <dcoutts> poucet: well, if you have a moment I'd appreciate knowing if the new version of the iconv binding works for you with your setup
16:03:33 <dcoutts> http://code.haskell.org/~duncan/iconv-0.4.1.0.tar.gz
16:03:40 <poucet> dcoutts: how do I install?
16:03:42 <opqdonut_> poucet: oh, oh my
16:03:51 <dcoutts> poucet: it's a normal cabal package
16:03:55 <poucet> opqdonut_: I have a simplistic example
16:04:04 <opqdonut_> okay, now I understand what you said
16:04:58 <poucet> opqdonut_: foo recurses on bar, and bar recurses on foo with a subfield of the datastructure, both are strict in terms of teh data-structure (it's a tree of sorts), but I guess bar does not know that foo is strict in it so I guess the field accessor is allocating a heapcell from the strict value.  That or it's the fact that since not all my data-constructors have that field accessor, there is extra code with exceptions
16:05:28 <poucet> dcoutts: You aer not testing macports, right, simply this iconv library?  I am using haskell-platform FYI, which is not 7.0
16:05:38 <opqdonut_> yes that makes sense
16:05:50 <opqdonut_> but I've gotta grab some shut-eye, sorry ->
16:06:30 <dcoutts> poucet: right, this binding to the iconv lib.
16:07:06 <dcoutts> poucet: OSX has traditionally been annoying for iconv because the native iconv implementation does not use real C functions, only C macros and the Haskell FFI only allows importing real C functions.
16:07:12 <poucet> dcoutts: how do I check whether it works?
16:07:20 <poucet> dcoutts: configured, built, installed.
16:07:51 <dcoutts> poucet: ah good question, there's an example that comes with the source
16:07:56 <dcoutts> examples dir
16:08:25 <poucet> dcoutts: built and it prints out the help message, that good enough or want me to test specific calls?
16:09:00 <dcoutts> poucet: if you like you can try a conversion, e.g. UTF8 to UTF16 or something like that
16:09:07 <poucet> BTW, when I did sudo runhaskell install, it installed properly in /usr/lib.  HOWEVER when I do sudo cabal install with the haskell platform, it installs <as root> in ~poucet/.cabal
16:09:12 <dcoutts> it works more or less the same way as the system iconv program
16:09:17 <poucet> (e.g. ghc-core)
16:09:27 <poucet> dcoutts: unfortunately I am not familiar with that tool
16:09:31 <dcoutts> poucet: right, cabal install does user installs by default
16:09:39 <poucet> dcoutts: even as sudo?
16:09:41 <dcoutts> poucet: you'd want to do sudo cabal install --global
16:09:45 <poucet> ah!
16:09:47 <poucet> ok =)
16:09:53 <dcoutts> poucet: it does not change behaviour depending on who is running it
16:09:57 <dcoutts> though arguably it should
16:10:00 <poucet> Could it not detect that it is sudo, sinc now I have stuff in my personal homedir with root ownership
16:10:06 <dcoutts> it's not really clear what would be less confusing
16:10:19 <poucet> well installing in ~poucet as root is odd :|
16:10:31 <dcoutts> poucet: yes, it messes stuff up doing sudo without --global
16:10:45 <dcoutts> we should at least detect that case and tell people not to do it
16:10:56 <poucet> dcoutts: do you have a commandline I could run? I've never run iconv before
16:11:19 <jmcarthur> cool, i didn't realize that (<$) had been added to the Functor class!
16:11:57 <dcoutts> ./hsiconf -f utf8 -t utf16 example.hs -o example.utf16
16:12:07 <dcoutts> file example.utf16  should then report it's in utf16
16:12:25 <copumpkin> jmcarthur: and applicative has more stuff now too
16:12:50 <poucet> dcoutts: doesn't seem to work
16:12:51 <poucet> poucet@poucet-macbookpro:~/tmp/iconv-0.4.1.0/examples$ ./hiconv -f utf8 -t utf16 hiconv.hs hiconv.utf16
16:12:54 <poucet> hiconv: user error (Codec.Text.IConv: cannot convert from string encoding "utf8" to string encoding "utf16")
16:12:57 <poucet> poucet@poucet-macbookpro:~/tmp/iconv-0.4.1.0/examples$ ./hiconv -f UTF8 -t UTF16 hiconv.hs hiconv.utf16
16:12:58 <jmcarthur> oh?
16:13:00 * jmcarthur looks
16:13:00 <poucet> hiconv: user error (Codec.Text.IConv: cannot convert from string encoding "UTF8" to string encoding "UTF16")
16:13:10 <jmcarthur> oh sweet
16:13:17 <dcoutts> poucet: perhaps it's "utf-8" and "utf-16"
16:13:33 <dcoutts> poucet: the standard iconv -l  will list the available names
16:14:02 <poucet> dcoutts: works :)
16:14:12 <poucet> Sorry for all the noob Qs
16:14:25 <dcoutts> np, thanks for testing
16:14:44 <poucet> dcoutts: Do you know by any chance why field-accessor would be allocating memory?
16:14:54 <dcoutts> no idea
16:15:11 <dcoutts> I'm not familiar with the code for that package
16:15:23 <roconnor> poucet: field-accessor?
16:15:23 <poucet> Oh no, I mean in haskell in general
16:15:40 <roconnor> what does it mean for a field-accessor to allocate memory?
16:15:43 <poucet> data Foo a = Foo { foo :: !(Foo a) } | Bar a
16:15:48 <poucet> foo allocates memory
16:16:06 <poucet> when I profile my progam (this is obviously not the real code, but hopefully demonstrates the problem)
16:16:41 <ezyang> as in, foo (a :: Foo a) ? 
16:16:51 <roconnor> does foo still allocate memory without the | Bar a ?
16:16:55 <poucet> as in 'foo :: Foo a -> Foo a'
16:17:05 <poucet> roconnor: I can't test that easily with my code unfortunately :(
16:17:23 <poucet> roconnor: especially since I haven't wittled down the test-case yet.  It's part of bigger code that involves two corecursive strict functions
16:17:30 <roconnor> poucet: your ! is probably being ignored as it is recursive
16:17:52 <poucet> roconnor: in my data-decl, or in my functions?
16:17:54 <ezyang> roconnor: Huh? 
16:18:00 <roconnor> in the data declaraion
16:18:05 <poucet> roconnor: nope
16:18:06 <ClaudiusMaximus> poucet: does foo' a = a `seq` foo a  show memory being allocated in foo' or in foo ?
16:18:08 <poucet> I could put the full code online if you like
16:18:09 <roconnor> not that I know much abou these things
16:18:11 <copumpkin> why would it be ignored?
16:18:16 <ezyang> IIRC, you can do ! for recursive definitions to get strict versions of those structures. 
16:18:23 <roconnor> copumpkin: how could it work?
16:18:24 <poucet> yes you can
16:18:30 <poucet> roconnor: my data-structure terminates
16:18:35 <copumpkin> roconnor: it just sticks a seq on the constructor
16:18:48 <copumpkin> meaning Foo a is actually a `seq` Foo a
16:18:51 <roconnor> oh right
16:19:02 <roconnor> it doesn't mean the same as unbox-strict-tuples
16:19:07 <roconnor> sorry
16:19:08 <poucet> I have a toy example but I need to benchmark it to see if it shows the same symptom.  But I think it does.  So I could put that online instead
16:19:09 <copumpkin> oh yeah, not that
16:19:10 <roconnor> heh
16:19:13 <ezyang> haha 
16:19:16 <ezyang> yeah, quite different :-) 
16:19:18 <ClaudiusMaximus> i think it's normal - at least i've noticed that too
16:19:19 <roconnor> unboxing is what I normally use ! for
16:19:24 <copumpkin> you can ask it to unbox non-polymorphic things
16:19:31 <copumpkin> -funbox-strict-fields
16:19:49 <poucet> So thinking about this, since my fields are not packed, I don't think this can be due to the non-strictness of functions, so that hunch was idiotic
16:20:00 <poucet> So my guess is that it's because not all data-constructors have that field-acessor?
16:20:15 <copumpkin> poucet: that seems odd
16:20:28 <poucet> copumpkin: I checked the core, there's some exception logic in foo
16:20:28 <Peaker> by inlining every polymorphic thing to every user, it becomes monomorphic ala templates, and you can unbox everything
16:20:37 <roconnor> so why wouldn't foo allocate a thunk for the result?
16:20:52 <poucet> hmm
16:21:00 <poucet> roconnor: wouldn't the thunk simply be (foo f) then?
16:21:23 <roconnor> I don't know
16:22:01 <poucet> I wish I knew how to read core better :)
16:22:31 <poucet> hum
16:22:53 <joe6> can you define a list with 2 elements?
16:23:01 <joe6> not a tuple?
16:23:18 <poucet> > [1, 2]
16:23:19 <lambdabot>   [1,2]
16:23:29 <ClaudiusMaximus> i think there's some subtlety about shifting the allocation count from the producer to the consumer when strict fields are involved, but i don't understand enough about why or how to avoid the confusion...
16:23:32 <roconnor> data TwoList a = TwoList a a
16:23:32 <joe6> i meant in data definition..
16:23:43 <joe6> roconnor: ok, thanks.
16:23:51 <copumpkin> data Vec n a where Nil :: Vec Z a; Cons :: a -> Vec n a -> Vec (S n) a
16:23:59 <copumpkin> Vec (S (S Z)) a 
16:24:06 <copumpkin> is a list of two elements
16:24:10 <roconnor> TwoList is a Monad
16:24:19 <dpratt71> who's in charge of the snap framework stuff?
16:24:21 <copumpkin> and a comonad
16:24:32 <parcs>  > [1..2]
16:24:34 <poucet> ClaudiusMaximus: my question I guess is: is this because the function is not recursing on itself and so does not know the other function (which is passed in as a variable) is strict and thus have to unstrictify.  Or is it because of the exception handler since not all branches have that field-accessor :)
16:24:40 <roconnor> it is isomorphic to the (Bool ->) monad
16:24:41 <ddarius> Peaker: We should all switch to C++.
16:25:03 <roconnor> copumpkin: is it hte (Bool ->) tracer comonad?
16:25:07 <ddarius> A boring monad.
16:25:16 <poucet> Oh well, since I was alreaddy pattern-matching, I might just as well do away with the field accessors alltogether :)
16:25:31 <roconnor> copumpkin: Bool is a monoid in so many ways!
16:25:32 <copumpkin> roconnor: there's the Monoid m => (m ->) comonad, and there are three monoids on Bool that I can think of
16:25:37 <poucet>  total alloc = 1,399,123,464 bytes  -> total alloc = 1,222,962,696 bytes    \o/  and I started at 5G :)
16:25:57 <ClaudiusMaximus> poucet: i don't think it's either; i think it's just the way things get presented by the profiler
16:26:29 <poucet> ClaudiusMaximus: I was just surprised anything would be allocating at all
16:27:19 <poucet> seems that calling field accessors always incurs allocations 
16:27:21 <poucet> patternmatching ftw
16:28:04 <ClaudiusMaximus> poucet: what's the productivity figure like?  (more useful than total alloc, really)
16:28:19 <poucet> ClaudiusMaximus: what is that?
16:29:03 <ClaudiusMaximus> poucet: ./yourcode +RTS -s
16:29:08 <poucet> yep, cutting another field accessor, this time from the following datastructure: data Octtree a = Octtree { size :: !a, tree :: !Octtree' }  leads to 1,172,631,048 bytes from 1,222,962,696 bytes 
16:29:41 <poucet> ClaudiusMaximus: I am doing that, just not sure which of the out put files that is since I have multiple flags when I profile.
16:29:51 <poucet>   Productivity  92.4% of total user, 91.8% of total elapsed
16:30:30 <poucet> 100MB savings just for going from foo !t = blablaba (size t) (tree t) to   foo t@(Octtree size tree) = blabalbla size tree
16:30:37 <poucet> :|
16:31:03 <poucet> (FYI this is allocation bytes, not heap-size)
16:32:50 <copumpkin> have you tried fclabels?
16:33:04 <ClaudiusMaximus> there's some extension that would allow you to write   foo (Octtree{..}) = blabla size tree   -- would be interesting to see how that compares speed-wise
16:33:16 <poucet> ClaudiusMaximus: interesting
16:33:19 <poucet> copumpkin: what is fclabels?
16:33:20 <copumpkin> RecordWildcards
16:33:25 <copumpkin> it's another lenses package
16:33:36 <roconnor> or data-accessor!
16:33:43 <roconnor> even better than fclabels (I think)
16:33:51 <copumpkin> meh
16:34:03 <copumpkin> roconnor: the parking lot, at midnight
16:34:04 <copumpkin> bring a gun
16:34:05 <roconnor> copumpkin: you know you want to interact with the state monad
16:34:16 <poucet> Alright, I think I have whittled down my allocation count to the minimum, the only thing really allocating now is things actually building new parts of the data-structure and the generator driving the input :)
16:34:28 <poucet> With most of the allocation cost coming from the generator, so that seems like a good point to be @
16:34:45 <copumpkin> roconnor: I'd use it if it weren't for HT's naming convention
16:35:03 <copumpkin> it's superficial
16:35:24 <copumpkin> but an API needs to be pleasant to use, or I won't use it unless it offers something I can't get elsewhere
16:35:49 <roconnor> copumpkin: it does offer something you can't get anywhere else, interaction with the state moand
16:36:15 <poucet> Time for my last algorithmic improvement, and I think I'm done for the night, I'll have a nicely functionig octtree
16:36:43 <copumpkin> seems like you'd want it on MonadState
16:36:58 <roconnor> either way
16:37:09 <roconnor> I don't see why it belongs more in one library than the other
16:37:24 <copumpkin> no, I mean generic over the MonadState class
16:37:28 <copumpkin> rather than specifically on StateT
16:38:15 <poucet> ClaudiusMaximus: btw, I went from 6s runtime to 0.6s runtime just by focusing on getting rid of those allocations (as well SPECIALIZING my function and one improvement in a multi-if-branch-like-case-statement)
16:38:27 <poucet> or did I start at 10.s
16:38:48 <ClaudiusMaximus> nice work
16:38:50 <ClaudiusMaximus> :)
16:38:50 <blackdog> poucet: no true hacker is satisfied with _one_ order-of-magnitude improvement
16:38:52 <blackdog> onward!
16:38:58 <roconnor> copumpkin: http://hackage.haskell.org/packages/archive/data-accessor-monads-fd/0.2.0.2/doc/html/Data-Accessor-Monad-FD-State.html
16:39:18 <poucet> blackdog: trying trying :)
16:39:24 <copumpkin> roconnor: fair enough :)
16:39:58 <roconnor> I guess stuff parameteric over MonadState needs to be split off in order to choose between -fd and -tf
16:40:01 <ClaudiusMaximus> any tips on profiling interactive applications?  just tried on mine, and got some pretty bizarre figures...   Productivity  99.6% of total user, 9.6% of total elapsed
16:41:15 <poucet> ClaudiusMaximus: TBH, I am new at profiling, started y'day.  Not sure what 'Productivity' stands for.  
16:41:37 <poucet> But interactive applications usually suffer from OS-locking
16:41:38 <ClaudiusMaximus> it's time spent doing useful things, like not garbage collecting
16:42:07 <poucet> ClaudiusMaximus: MY guess is that 'total user' means total amount of time spent in user-land?
16:42:40 <poucet> ClaudiusMaximus: Try to buffer IO in userspace more if you're doing something CLI-oriented.  If it is a GUI, then no idea.
16:42:58 <poucet> ditto on buffering for network apps
16:43:02 <ClaudiusMaximus> it's very GUI (animations in Cairo/GTK)
16:43:22 <ClaudiusMaximus> most of the time it's sleeping waiting for the next frame
16:43:23 <poucet> ClaudiusMaximus: you could strace it?
16:43:51 <poucet> Though I doubt that would tell you much
16:44:28 <joe6> i have "type Byte = String". I am wondering if there is a better way of representing a byte?
16:44:39 <poucet> If I understand Productivity correctly, you're basically stuck in syscalls
16:44:47 <joe6> the byte value is a hex representation of the byte
16:44:48 <poucet> joe6: Word8
16:44:53 <poucet> oh
16:44:54 <ddarius> joe6: I'm wondering if there's a worse way.
16:45:17 <shachaf> ddarius: Is that a challenge?
16:45:41 <poucet> shachaf: are you thinking what I am thinking? Unary datastructure using Z and using that to represent the hexadecimal string?
16:46:18 <ClaudiusMaximus> poucet: my process hovers around 10-15% in 'top', while Xorg is at 30% - probably most of the time is shunting pixels from cairo to X
16:46:25 <shachaf> I'm sure you can do worse than that.
16:47:10 * hackagebot threadPool 0.3 - Runs other programs in the manner of a thread pool  http://hackage.haskell.org/package/threadPool-0.3 (BrianJaress)
16:47:29 <poucet> shachaf: Let's hear it :)
16:47:42 <poucet> shachaf: pure haskell only, no IO
16:48:14 <blackdog> shachaf, poucet: it's still computable. maybe you can design a representation based on busy beaver numbers?
16:49:03 <ClaudiusMaximus> byte :: UnaryNatural -> a -> a -> a -> a -> ... -> a ; byte b b00 b01 b02 ... = case b of 0 -> b00; 1 -> b01; 2 -> b02 ; ....
16:49:07 * poucet had to google that one
16:49:35 <poucet> ClaudiusMaximus: while very spammy code wise, I am not sure it would be THAT slow
16:49:54 <poucet> just very large stack frames
16:50:01 <poucet> :D
16:50:26 * ClaudiusMaximus been too deep in untyped lambda calculus lately - still haven't got bytes :)
16:51:23 <ddarius> ClaudiusMaximus: Bah, you use the Scott encoding rather than the Church encoding in your livecoding.  You're getting spoiled on general recursion.
16:51:48 <ClaudiusMaximus> ddarius: yeah, and i have late binding of names, so i can change things while they're running!
16:52:39 <ClaudiusMaximus> eg: infinity = succ infinity ; infinity ; ... some time later ... ; infinity = pred infinity
16:54:12 <ddarius> ClaudiusMaximus: That didn't seem to work out too well for you in one of the videos.
16:54:26 <ddarius> ClaudiusMaximus: Incidentally, did you never define zero in that video intentionally?
16:54:38 <poucet> blackdog: FYI 10s -> 0.28s does that count ?
16:55:00 <ddarius> > logBase 10 (10/0.28)
16:55:01 <lambdabot>   1.5528419686577806
16:55:18 <ddarius> Only 1.5528419686577806 orders of magnitude.
16:55:25 <ClaudiusMaximus> ddarius: well, without danger where would the fun be?
16:55:25 <poucet> :q
16:57:26 <poucet> ddarius: that's cause 92% of the time is spent in the benchmark driving the lib :(
17:00:41 <Cale> > isDenormalized 2.2250738585072011e-308
17:00:43 <lambdabot>   True
17:02:57 <aristid> > isDenormalized 1
17:02:58 <lambdabot>   False
17:03:03 <papermachine> I read that as "isDemoralized"
17:03:11 <aristid> @check isDenormalized
17:03:12 <lambdabot>   "Falsifiable, after 0 tests:\n1.5\n"
17:03:20 <aristid> @check not . isDenormalized
17:03:21 <lambdabot>   "OK, passed 500 tests."
17:03:27 <aristid> @check not . isDenormalized
17:03:28 <lambdabot>   "OK, passed 500 tests."
17:03:31 <aristid> haha
17:04:08 <copumpkin> > isDenormalized (read "2.2250738585072011e-308" :: Float)
17:04:10 <lambdabot>   False
17:04:23 <mauke> > isDenormalized (read "2.2250738585072011e-308" :: Double)
17:04:25 <lambdabot>   True
17:04:42 <dpratt71> oh dear...watching a vid on C9 about Monads and feeling very lost
17:04:49 <copumpkin> > read "2.2250738585072011e-308" :: Float
17:04:50 <lambdabot>   0.0
17:05:00 <kmc> don't worry too much about monads
17:05:00 <copumpkin> > read "2.2250738585072011e-308" :: Double
17:05:01 <lambdabot>   2.225073858507201e-308
17:05:08 <Cale> dpratt71: heh
17:05:09 <kmc> "monad" is the name of a very general API that's used by a lot of unrelated stuff
17:05:24 <dpratt71> kmc: funny thing is I thought I sort of "got them"
17:05:27 <kmc> you can learn those things (lists, IO, Maybe, parsers) concretely
17:05:32 <kmc> before you worry about why they share an API
17:05:40 <Cale> dpratt71: All the videos on C9 which I've seen about monads have made me grit my teeth.
17:05:57 <Cale> dpratt71: Which video are you watching?
17:06:05 <Cale> Brian Beckman?
17:06:46 <dpratt71> it's new: http://goo.gl/0hS1L
17:07:11 <kmc> there's a lot of people asking about monads and trying to explain monads in situations where that's the wrong question
17:08:29 <copumpkin> monads are like that thing that's on the tip of your tongue that you can't remember now. Quit trying and it'll come to you
17:09:17 <ddarius> Monads are like a cut on the roof of your mouth that would go away if you would just stop tonguing it, but you can't.
17:10:27 <dpratt71> where can I 'paste' a pic?
17:10:37 <dobblego> imgur.com
17:11:31 <elliott> is there a function to interpret a ByteString as a base-256 integer?
17:13:04 <dpratt71> thanks dobblego; this illustrates the source of my confusion fairly well: http://imgur.com/dYIEN
17:13:53 <ddarius> Yay, monads and S5 modal logic!
17:14:17 <dpratt71> ddarius: yay?
17:14:30 <edwardk> clearly since comonads are burritos we should teach everyone about comonads first, then they can reason about monads as just comonads in the dual category.
17:15:01 <ddarius> edwardk: You figure out your thing yet?
17:15:23 <edwardk> ddarius: got distracted by all the comonads-fd boilerplate splintering everything out into strict and lazy versions
17:15:34 * ddarius goes to eat mediocre sushi.
17:15:35 <edwardk> there is still room for you to swoop in with some sweet examples ;)
17:15:40 <poucet> Anyone know a better way to express: foldl' (.) (id) 
17:15:54 <edwardk> foldl' (.) id =)
17:16:09 <poucet> :D
17:16:30 <edwardk> you can't ask for something much more terse than what you've got
17:16:39 <poucet> Yeah, but I don't think it does what I want
17:16:43 <poucet> since it first builds a huge function
17:16:50 <edwardk> now, that can be addressed ;)
17:16:58 <elliott> @hoogle showIntAtBase
17:16:58 <lambdabot> Numeric showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
17:17:05 <elliott> No ByteString version
17:17:06 <elliott> ?
17:17:18 <edwardk> poucet: btw- welcome back, what prompted you to start slumming with us haskell folks again, anyways?
17:17:18 <poucet> aha, foldr
17:17:28 <poucet> edwardk: I am trying to make a game in haskell :)
17:17:34 <aristid> :t foldl' (.) id [(1:), (2:), (3:)]
17:17:35 <lambdabot> forall t. (Num t) => [t] -> [t]
17:17:36 <edwardk> ah
17:17:46 <aristid> > foldl' (.) id [(1:), (2:), (3:)] [0]
17:17:48 <lambdabot>   [1,2,3,0]
17:17:54 <aristid> > foldr (.) id [(1:), (2:), (3:)] [0]
17:17:56 <lambdabot>   [1,2,3,0]
17:18:14 <aristid> > foldl' ($) [0] [(1:), (2:), (3:)]
17:18:15 <lambdabot>   Occurs check: cannot construct the infinite type: b = b1 -> b
17:18:33 <aristid> > foldl' (flip ($)) [0] [(1:), (2:), (3:)]
17:18:36 <lambdabot>   [3,2,1,0]
17:19:02 <parcs> > foldr1 (.) [(1:), (2:), (3:)] [0]
17:19:04 <lambdabot>   [1,2,3,0]
17:19:17 <Eduard_Munteanu> Bah, are Coq compile errors always so sucky?
17:19:27 <aristid> poucet: with (.) it seems to work with both foldr and foldl, because foldr and foldl flip the argument order of the parameter function
17:19:32 <Eduard_Munteanu> "Syntax error: '.' expected after [vernac:gallina] (in [vernac_aux])."
17:20:05 <int80_h> http://hpaste.org/42825/stumped_about_where_this_type
17:20:50 <int80_h> hiya, could someone take a look at my type error?
17:20:58 <int80_h> I'd like to talk about it
17:21:24 <sleepynate> quick, who's doing haskell at cambridge?
17:21:28 <sleepynate> (uk, not MA)
17:21:48 <ezyang> me! 
17:22:07 <ezyang> also, more notably, spj and simon marlow 
17:22:08 <int80_h> there's a cambridge in the UK?
17:22:11 * int80_h ducks
17:22:18 <ezyang> ;-) 
17:23:29 <poucet> > logBase 10 (10/3) * logBase 10 (3.08/2.16)
17:23:30 <lambdabot>   8.057402789346119e-2
17:23:38 <sleepynate> i was just giving a friend who got back from cambridge a nuclear boot about going there only to hide in the bushes of cambrdige researchers
17:23:48 <poucet> > logBase 10 (10/0.3) * logBase 10 (3.08/2.16)
17:23:49 <lambdabot>   0.23467099324297447
17:24:05 <poucet> > logBase 10 (10/0.3) + logBase 10 (3.08/2.16)
17:24:06 <lambdabot>   1.6769757106298506
17:24:10 <poucet> Woot, and we have a winner.  at n = 7: 10s -> 0.3s.  Then unfortunatetly resolution broke down.  So with the 0.3s I bumped up n=7 to n=8.  And I got a further improvement from: 3.08s to 2.16s.
17:25:15 <int80_h> everyone is aft!
17:25:42 <poucet> edwardk: That and I missed the community, tbh :)
17:26:13 <poucet> aristid: using (.) means your first building a GINORMOUS function, which means you'll be allocating a lot of memory
17:26:16 <poucet> > 256 ** 3
17:26:17 <lambdabot>   1.6777216e7
17:26:29 <poucet> Of that many individaul function calls (.) to one another
17:27:11 <aristid> poucet: using ($), then?
17:27:16 <poucet> aristid: yep :)
17:27:25 <poucet> and odly enough foldr ($) trumps foldl' (flip ($))
17:27:28 <Eduard_Munteanu> int80_h: could you paste your new urlInitial and urlBase?
17:27:44 <aristid> > foldr ($) [0] [(1:), (2:), (3:)]
17:27:45 <lambdabot>   [1,2,3,0]
17:27:49 <edwardk> hrmm, what would be a good name for ComonadZip w => (a -> b -> c) -> w a -> w b -> c   — liftW2 keeps the 'w' around
17:27:55 <int80_h> Eduard_Munteanu certainly
17:28:16 <poucet> edwardk: so yeah. 2.16s to add all individual 1x1x1 boxes in x, y, z order to a (256, 256, 256) octtree, resulting in a single full cube :)
17:28:20 <edwardk> and i want to be able to do things like plus :: Num a => History a -> History a -> a; plus = foo (+)
17:28:38 <int80_h> Eduard_Munteanu: It's in the first example I believe
17:28:55 <Eduard_Munteanu> int80_h: well are you sure it's the same?
17:29:00 <edwardk> poucet: octree cubes, you're barking up my old territory. do i detect voxels?
17:29:17 <poucet> edwardk: want to make something similar to minecraft, but with a different gameplay
17:29:19 <jmcarthur> or maybe just a minecraft clone
17:29:21 <int80_h> Eduard_Munteanu: good point, I will verify
17:29:21 <jmcarthur> aha!
17:29:54 <ClaudiusMaximus> int80_h: what's the type of curlResp in the broken version?  missed out an argument in its definition perhaps?
17:30:02 <jmcarthur> honestly, i doubt i will ever touch a game that looks like minecraft again. i've had enough ;)
17:30:03 <poucet> What I *DO* wonder about minecraft is hwether it uses octtrees.  The fact that you have a single layer of grass on the top means either your octtree does not store the grass aspect only for top-cubes, or you'll have a X*Y set of single boxes containing grass.
17:30:14 <int80_h> > urlBase :: URLString
17:30:14 <int80_h> > urlBase = "https://172.16.1.18"
17:30:14 <int80_h> > urlInitial = urlBase // "showLogon.do"
17:30:15 <lambdabot>   Not in scope: type constructor or class `URLString'Not in scope: `urlBase'
17:30:15 <lambdabot>   <no location info>: parse error on input `='
17:30:15 <lambdabot>   <no location info>: parse error on input `='
17:30:39 <poucet> jmcarthur: the planned gameplay is 1) multiplayer, 2) no first person aspects.
17:30:50 <jmcarthur> poucet: many people have reverse engineered how minecraft works if you google. maybe on minecraftwiki?
17:30:51 <edwardk> poucet: fair nuff. you read the samuli laine paper on sparse voxel octrees with bounding slabs?
17:31:13 <poucet> jmcarthur: minecraft meets dwarffortress (Albeit simplified), with some sort of RTS in it
17:31:20 <poucet> edwardk: haven't but thanks for the pointer
17:31:29 <jmcarthur> minecraft is already sort of dwarf-fortress-y
17:31:32 <poucet> jmcarthur: you say "clear area X" and your lil workers start doing their things
17:31:42 <jmcarthur> cool, so a bit rts-like
17:31:44 <poucet> yep
17:31:49 <jmcarthur> i like rts
17:32:31 <edwardk> poucet: http://www.youtube.com/watch?v=lpfaFrazOn4 http://code.google.com/p/efficient-sparse-voxel-octrees/ http://www.tml.tkk.fi/~samuli/publications/laine2010i3d_paper.pdf
17:32:31 <int80_h> ClaudiusMaximus: curlResp :: Curl -> [CurlOption] -> URLString -> IO CurlResponse
17:32:37 <poucet> edwardk: got it, thx :)
17:32:43 <poucet> edwardk: not: http://www.tml.tkk.fi/~samuli/publications/laine2010tr1_paper.pdf?
17:32:46 <edwardk> poucet: the key insight is a few pages into the paper
17:33:10 <jmcarthur> i've always kind of wanted an rts where you could kind of make your own custom units using available resources and even program them as you please, giving them various triggers and commands of your own design
17:33:20 <poucet> edwardk: gracias senor
17:33:24 <jmcarthur> but more accessible to non-programmers than your typical level editor or something
17:33:27 <ClaudiusMaximus> int80_h: but you're calling it with curlResp curl url method_GET ; maybe you meant curlResp curl method_GET url ?
17:33:30 <Eduard_Munteanu> int80_h: your first version looks like   Curl -> URLString -> [CurlOption] -> m String 
17:33:32 <jmcarthur> aka "dumbed down"
17:33:34 <edwardk> i joined haskell-blah if you want to chat, but i used to sell voxel modeling systems in the 90s ;)
17:33:47 <dpratt71> oh dear..."Joe knows that if he can't get an A then he can return to the moment he was asked for an A when one shows"
17:33:59 <edwardk> the tech report you found is a better link i think
17:34:02 <Eduard_Munteanu> So it looks like two of the args are flipped
17:34:09 <dpratt71> that's mostly English words, but I'm not sure it's English
17:34:09 <poucet> jmcarthur: The idea would be that each of your lil workesrs would have some basic AI to it.  E.g. "If close to enemy, attack unless low on health."  Might be an idea to let players influence that
17:34:21 * jmcarthur shrugs
17:34:27 <jmcarthur> it's just something that i've occasionally toyed with in my head
17:34:39 <poucet> jmcarthur: same here :)
17:35:09 <poucet> jmcarthur: I personally love simulation worlds and AI, my gf likes rts, and I've been fascinated by df and minecraft, so it felt like a good fit
17:35:34 <dpratt71> jmcarthur: your description reminds me a bit of the nascent Terrarium
17:35:44 <jmcarthur> this may be a -blah topic, come to think of it
17:36:01 <edwardk> http://www.youtube.com/watch?v=7REP_FE0e98 was a video an old friend of mine from the democene era did using brigade and a minecraft level.
17:36:28 <edwardk> brigade = real time bidirectional path tracing
17:36:56 <edwardk> i was puttering around adding metropolis light transport to it, but someone beat me to having a pretty demo
17:37:05 <dpratt71> jmcarthur: it's still around in some form, I guess: http://terrarium2.codeplex.com/
17:37:13 <jmcarthur> ah thanks i was trying to google it
17:37:22 <int80_h> ClaudiusMaximus: I see what the problem is. My version control skills suck hard.
17:37:44 <jmcarthur> dpratt71: ah kind of an artificial life thing with competition
17:37:51 <jmcarthur> i guess my idea is indeed similar to that
17:37:55 <int80_h> thanks for saving me time in figuring out where the discrepency is
17:55:58 <aristid> edwardk: it would be cool if you could make the monoids package compilable again, btw
18:00:55 <monochrom> all the fun happens when I'm away proving theorems!
18:01:23 <copumpkin> what were you proving!?
18:01:58 <dolio> ddarius: This Goguen paper could use some re-typesetting.
18:02:39 <aristid> copumpkin: he was proving that the fun happens
18:03:05 * copumpkin 's head explodes
18:03:42 <monochrom> I'm replicating a lambda calculus and its properties inside a theorem prover, e.g., define a data type for lambda terms, define an interpreter function (runs n steps only), prove that interpret n (\x->x x)(\x->x x) does not give an answer no matter what n is.
18:05:46 <monochrom> slowly I will move towards the halting problem too
18:06:15 <copumpkin> fun
18:06:32 <copumpkin> which prover?
18:06:36 <monochrom> HOL4
18:06:50 <copumpkin> aha
18:16:03 <altious> Prelude Text.Printf> let a = (\x -> Text.Printf.printf "received: %s\n" x) results in error  Ambiguous type variable `t' in the constraint: `PrintfArg t'
18:16:13 <altious> how can i add type signature to anonymous function?
18:17:23 <monochrom> let { a :: String -> String; a = (\x ...) }
18:18:01 <shachaf> Alternatively, use NoMonomorphismRestriction. :-)
18:18:08 <altious> monochrom, thanks
18:18:57 * roconnor wonders where SimonMarlow discusses "discussing [the library submission proposal] at length on IRC over the past couple of days".
18:19:34 <altious> eh. do haskell have void datatype? :)
18:19:55 <dolio> #ghc?
18:19:59 <altious> yes
18:20:27 <roconnor> altious: newtype Void = Void Void
18:21:17 <dolio> Simon Marlow is JaffaCake, no?
18:21:28 <mauke> preflex: seen JaffaCake
18:21:28 <preflex>  JaffaCake was last seen on #ghc 12 hours, 44 minutes and 44 seconds ago, saying: aha, then I should fix that too
18:31:44 <djahandarie> He sometimes goes as JaffaCake1 ;)
18:31:53 <mauke> preflex: seen JaffaCake1
18:31:54 <preflex>  JaffaCake1 was last seen on #ghc 1 day, 10 hours, 22 minutes and 14 seconds ago, saying: oh yes
18:32:07 <dpratt71> decided to read up on S5 (modal logic); if nothing else, it is amusing (to me)
18:32:17 <monochrom> preflex: seen JaffaCake2
18:32:18 <preflex>  JaffaCake2 was last seen on #ghc 1 year, 90 days, 15 hours, 47 minutes and 31 seconds ago, saying: ChilliX: hi
18:32:26 <monochrom> preflex: seen JaffaCake3
18:32:26 <preflex>  Sorry, I haven't seen JaffaCake3
18:32:34 <dpratt71> "if X is necessarily, possibly, necessarily possible, then X is possible"
18:32:46 <geheimdienst> dpratt71: o rly
18:33:06 <dpratt71> geheimdienst: Wikipedia says so
18:33:16 <aristid> preflex: seen JaffaCake_
18:33:16 <preflex>  Sorry, I haven't seen JaffaCake_
18:39:13 <djahandarie> Looks like he has a fan club / stalkers
18:45:00 <Animawish> I need someone to explain arguments to me like I'm a second grader
18:45:25 <tg_> you have to provide the multiplication tables
18:45:57 <azaq23> Animawish: You mean function arguments?
18:46:03 <Animawish> yes
18:46:13 <mauke> as in f(x) = 2*x + 1?
18:46:36 <Animawish> yeah, but more in programm-ey terms
18:46:43 <mauke> same thing
18:46:51 <jmcarthur> Animawish: in haskell, that *is* programm-ey terms
18:47:16 <Animawish> well I was thinking like using a block as an example or something
18:47:27 <aristid> what is a block?
18:47:31 <Animawish> I'm just starting learning programming so I'm at like, square one with any kind of knowledge
18:47:31 <jmcarthur> > let f x = 2*x + 1 in f y
18:47:32 <lambdabot>   2 * y + 1
18:47:53 <jmcarthur> Animawish: if you know what a function is in math you know what it is in haskell
18:47:57 <azaq23> Animawish: Well a function is like a machine that takes something in, does something with it and returns it. The argument to a function is what you put in it. What you're allowed to put into it is determined by the type of the function, which also determines what kind of thing is returned
18:48:15 <aristid> no, a function is like a burrito, because it is a monad.
18:48:24 <jmcarthur> @slap aristid 
18:48:24 * lambdabot decomposes aristid  into several parts using the Banach-Tarski theorem and reassembles them to get two copies of aristid !
18:48:32 <mauke> that backfired
18:48:38 <jmcarthur> :(
18:49:29 <aristid> two aristids = twice the stupid unfunny burrito jokes
18:49:45 <jmcarthur> @quote burrito
18:49:46 <lambdabot> jmcarthur says: web monads are unicorn burritos that have been laying around in the attic for a few years
18:49:59 <mauke> isn't it "lying around"?
18:50:20 <aristid> mauke: are you discriminating against jmcarthur?
18:50:23 <jmcarthur> well... laying has funnier connotations at least ^_^
18:50:38 <mauke> huh?
18:54:51 * kfish lays a unicorn burrito
18:56:49 <monochrom> I'm pretty sure a second grader is not ready to understand functions and arguments. Try an eighth grader instead.
18:56:54 <joe6> i have "Either ParseError [ControlTxn]". I can use case to get out [ControlTxn]. Is there is another way to do that?
18:57:31 <mauke> :t either
18:57:33 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
18:58:20 <aavogt> :t (|||) `asTypeOf` either
18:58:21 <lambdabot> forall b d c. (b -> d) -> (c -> d) -> Either b c -> d
18:58:38 <mauke> :t (|||)
18:58:39 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
18:58:41 <roconnor> edwardk: I see you used the ugly coklesili combinators
18:59:23 <joe6> > rights
18:59:25 <lambdabot>   Overlapping instances for GHC.Show.Show
18:59:25 <lambdabot>                              ([Data...
18:59:32 <joe6> > right
18:59:34 <lambdabot>   Overlapping instances for GHC.Show.Show
18:59:34 <lambdabot>                              (a b c...
19:03:14 <dolio> Huh, haddock includes documentation for re-exported stuff?
19:03:24 <ddarius> edwardk: That real time path tracer could use some point spread functions.
19:07:20 <lars9> @src foldr
19:07:20 <lambdabot> foldr f z []     = z
19:07:20 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
19:09:47 <monochrom> :type right
19:09:54 <monochrom> :t right
19:09:55 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either d b) (Either d c)
19:10:08 <monochrom> that won't do
19:10:33 <monochrom> :t rights
19:10:34 <lambdabot> forall a b. [Either a b] -> [b]
19:10:47 <monochrom> that will work but could just give you the empty list
19:11:46 <ddarius> poucet: (.) is non strict in its second argument so it is better to foldr it than foldl' it.  ($)'s strictness depends strongly on the first argument, which of foldr or foldl' better depends on the list being folded over.
19:12:02 <joe6> monochrom: thanks, got the either to work..
19:12:16 <joe6> mauke: thanks.
19:12:22 <monochrom> yeah, if you already used pattern matching, converting to either is easy and natural
19:14:24 <ddarius> either is easy and natural regardless.
19:14:48 <monochrom> natural and organic
19:19:06 <ddarius> 100% CHONS, except for the Fe, Zn, Na, K, F, Cl, Mn.
19:19:38 <dolio> edwardk: The documentation for discont probably shouldn't refer to context, since the latter is called something else in your library.
19:25:56 <jmcarthur> monochrom: "I'm pretty sure a second grader is not ready to understand functions and arguments. Try an eighth grader instead."  <-- was that serious?
19:26:32 <jmcarthur> hard to tell over the intertubes
19:27:59 <monochrom> that was serious. not trying to tell over the intertubes. trying instead to exploit one's own words, "explain arguments to me like I'm a second grader". request contains internal contradiction.
19:32:26 <jmcarthur> monochrom: i started learning programming when i was in second grade, so i don't think the request sounds that silly
19:33:02 <jmcarthur> it was just basic, so i guess no real functions were involved, but still
19:33:19 <jmcarthur> subroutines at least
19:33:25 <Eduard_Munteanu> That usually reads as "explain things to me so that I don't have to think at all".
19:33:27 <monochrom> you have to grok "variables" first
19:33:42 <jmcarthur> i had no problem with variables
19:34:04 <monochrom> you did not ask for help. you grokked it yourself. there is something about "if you have to ask, you are not ready to know"
19:34:17 <Eduard_Munteanu> Interesting.
19:34:23 <jmcarthur> although it was stateful variables with a nice putting-things-on-a-shelf metaphor
19:34:34 * Eduard_Munteanu always wondered why others had difficulties with pointers.
19:34:40 <monochrom> you were an exception. most 2nd-graders may be unready for variables.
19:34:45 <jmcarthur> :(
19:35:08 <copumpkin> hmm
19:35:10 <monochrom> I probably was not ready for variables in 2nd grade too
19:35:15 <copumpkin> I've had this before but I can't remember how to fix it
19:35:29 <copumpkin> oh
19:35:33 <copumpkin> I think fclabels just needs updating
19:36:00 <monochrom> anyway there is a big difference between "explain as if I'm in 2nd grade" and "explain as if I'm in 8th grade". the latter is so much easier.
19:36:14 <copumpkin> aha, there we go
19:36:17 <Eduard_Munteanu> monochrom: that's not what they mean
19:36:29 <monochrom> I don't care what they mean.
19:36:34 <Eduard_Munteanu> :)
19:37:00 <monochrom> If they mean something else, my being literal will corner them into say what they mean.
19:37:07 <monochrom> s/say/saying/
19:37:18 <jmcarthur> this is reminding me of a programming class i took in high school. most people in the class just whined the whole time
19:37:47 <Eduard_Munteanu> What they do mean is equally non-sensical. "How can I work something out without thinking too much about it?"
19:38:47 <jmcarthur> i think this guy was looking for an analogy, is all
19:39:02 <Eduard_Munteanu> Ah, I'm not familiar with the situation at hand.
19:39:13 <jmcarthur> which isn't nonsensical, but isn't as helpful as it may seem at first
19:39:48 <jmcarthur> "Animawish | I need someone to explain arguments to me like I'm a second grader" ... "Animawish | well I was thinking like using a block as an example or something"
19:40:13 <Eduard_Munteanu> I see.
19:44:13 <tac-tics> Question about "inversion lemmas" in type theory. Do they hinge on the mathematical wording "the smallest set such that....." used in inductive definitions?
19:45:09 <sseefried> Got a question about Cabal. Is this an appropriate place to ask?
19:45:24 <jmcarthur> sseefried: sure
19:46:17 <seafood> Okay, a problem that occurs with cabal with increasing frequency is that I'll have a project which has many dependencies. Indirectly they rely on two different versions of the same package.
19:46:24 <seafood> What do I do in this situation?
19:46:31 <seafood> cabal upgrade often just breaks things.
19:47:50 <Cale> seafood: cabal upgrade shouldn't even do anything (except print a message saying how it's disabled)
19:48:03 <seafood> Cale: Indeed, it does now. 
19:48:11 <seafood> But you can upgrade individual packages.
19:48:20 * jmcarthur just uses install for that
19:48:25 <seafood> And I found that this would cause some recursion into other packages.
19:48:26 <Cale> Unfortunately, it's often not as simple as having the latest version of everything
19:48:30 <Eduard_Munteanu> tac-tics: the "smallest set" part is important, if that's your question
19:48:59 <seafood> Cale: Yeah, I realise. I'm just trying to work out a way to deal with this problem.
19:49:04 <tac-tics> Eduard_Munteanu: thanks. 
19:49:12 <jmcarthur> i wish we could have multiple builds of the same versions of packages each built against different versions of their dependencies. it would get complicated, but it could fix this issue in many cases
19:49:28 <Cale> Which package and which dependencies are giving you problems?
19:49:33 <Cale> QuickCheck?
19:50:03 <seafood> Cale: It's a yesod project. Indirectly it relies on network-2.2.1.7 and network-2.3 because I've decided to use the snap-server package.
19:50:05 <Eduard_Munteanu> tac-tics: a simpler example... consider you give such an inductive definition for natural numbers. If you don't include the "smallest set" thingy, you could well end up with real numbers or anything else which contains N.
19:50:12 <Cale> seafood: hmm
19:50:22 <Eduard_Munteanu> But it's not something specific to inversion lemmas per se.
19:50:33 <Cale> Perhaps an older snap-server would help?
19:50:39 <seafood> Cale: perhaps.
19:51:20 <seafood> Cale: It's not an options since yesod depends on wai-handler-snap which depends on snap-server-3.0 which depends on network-2.3
19:52:16 * Cale wonders if Michael Snoyman is around... :)
19:52:26 <seafood> Does he hang out here?
19:52:34 <Cale> I think I've seen him here.
19:52:50 <Cale> seafood: You might just email him with the error, and see if he can suggest anything.
19:53:13 <seafood> Yeah, sure. But this problem with cabal packages is quite prevalent. 
19:53:51 <Cale> Yeah, if you want to force things to work, you can start editing packages
19:53:58 <seafood> Ouch.
19:54:02 <Cale> Often just modifying the .cabal files is enough to get things to work
19:54:07 <Cale> and isn't that hard to do
19:54:14 <gienah> that is what I do, hack the .cabal file, than fix the breakages :-)
19:54:26 <seafood> It would be nice if you could build against two different package versions.
19:54:30 <Cale> (cabal fetch -> edit .cabal -> cabal install (with no extra parameters from the project directory)
19:54:32 <seafood> Why should this be a problem in principle?
19:56:22 <Cale> seafood: Theoretically it's a problem because incompatible data from different versions of a package might get mixed together. I suspect that in practice it would often not be a problem. People have suggested that cabal differentiate between external and internal dependencies.
19:57:39 <seafood> Cale: I was wondering if you could you elaborate on what you mean by "incompatible data"?
19:58:34 <Cale> Well, say foo-0.1 defines  data Foo = A | B, and foo-0.2 extends it to  data Foo = A | B | C
19:59:18 <seafood> Cale: Okay, I see that. Now if package bar depends on foo-0.1 and package baz depends on foo-0.2 what is the problem?
19:59:24 <monochrom> probably snoyman upgraded to network 2.3 himself before even starting to develop yesod. he would see no problem.
19:59:51 <seafood> monochrom: It's snap-server that depends on network-2.3
20:00:11 <Cale> seafood: and package quux depends on both. Suppose that package bar exposes a function Foo -> Integer, and package baz exposes a function String -> Foo
20:00:13 <monochrom> yesod doesn't mind network 2.3 either
20:00:13 <gienah> I have provided ebuilds of snap and yesod on gentoo, they compile fine with ghc 7.0.1
20:00:24 <Eduard_Munteanu> Maybe make it use an older snap-server version until yesod gets there?
20:00:57 <Cale> seafood: and that function from baz might produce the value C, while the function from bar won't know how to deal with it, even though its type would suggest that it does
20:01:59 <gienah> gentoo overlay has snap 0.3.0.1 and yesod 0.6.7
20:05:19 <seafood> Cale: Ah, of course that makes perfect sense. Thanks.
20:06:09 <seafood> gienah: I'm having trouble compiling a Yesod application, not the Snap and Yesod packages themselves.
20:07:23 <gienah> seafood: I will try compiling a little yesod application with ghc 7.0.1 on gentoo
20:08:50 <seafood> gienah: Yes, but just try this: Don't use the basicHandler. import Network.Wai.Handler.Snap. Make "main main = toWaiApp Echo >>= run 3000"
20:08:51 <joe6> how do I match on an empty tuple in a guard?
20:09:11 <joe6> i tried "function (,) _ = False" but it does not work.
20:09:31 <seafood> joe6: Tuples can't be empty.
20:09:38 <joe6> where function has 2 arguments, the first argument is the tuple.
20:09:55 <joe6> oh, ok. so, the guard is not necessary.
20:10:19 <joe6> seafood: sorry, got it.. thanks.
20:11:15 <Cale> f () _ = False ?
20:11:46 <Cale> () is the empty tuple, but it's of limited use as a function parameter
20:12:18 <c_wraith> > typeOf ()
20:12:20 <lambdabot>   ()
20:12:37 <c_wraith> look, it isn't totally meaningless as a parameter to polymorphic functions!
20:15:41 <joe6> Cale: thanks, I just wanted to make sure that the function is not called with an empty tuple.
20:16:02 <Cale> joe6: Its type should ensure that
20:16:08 <joe6> but, then realised that I might not need that.
20:16:16 <joe6> Cale: gotcha.
20:16:32 <Cale> joe6: If it takes a tuple of one size, it can't take a tuple of any other size, because differently sized tuples are completely separate types.
20:26:56 <danols> anyone interested here is an interesting post about haskell and python
20:28:16 <medfly`> well that was interesting
20:29:23 <danols> medfly`: you read it already ?
20:29:26 <danols> i'm still reading lol
20:29:44 <medfly`> no you didn't even mention a link...
20:30:00 <monochrom> yeah here is an interesting page of mine
20:30:19 <monochrom> I'm still writing it
20:31:15 <danols> monochrom: what's the link ?
20:31:39 <danols> this line hits home with me now Python is my favored language for most of my scripting needs, and as such I am painfully aware of quirks in the language that Haskell would smooth away.
20:31:39 <monochrom> I'm still writing it. So far it's http://
20:31:51 <danols> monochrom: ?
20:31:58 <azaq23> golden
20:33:00 <gienah> seafood: I created the wai-handler-snap ebuild, but I get: parse error (possibly incorrect indentation) trying to compile the yesod snap hello example
20:33:44 <gienah> seafood: this is on the |] that terminates the template haskell routes stuff
20:34:07 <seafood> gienah: weird.
20:36:15 <roconnor> ddarius: In Jaynes's text book he doesn't appear to prove that the gaussian has maximum entropy for distributions of a given mean and variance.
20:49:50 <jmcarthur> danols: i'm not sure if you realized... you never pasted a link to the post you are talking about
20:51:48 <joe6> is there a better way of writing this:
20:51:50 <joe6> check ((_,expected):ys) (actual:xs) = if (expected == actual) then (check ys xs) else False
20:52:56 <medfly`> :t all
20:52:57 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
20:54:34 <joe6> it is recursive procedure. it needs to walk down both lists, comparing each element in-turn.
20:54:55 <medfly`> :t zipWith
20:54:56 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
20:55:16 <joe6> medfly`: that could work. thanks.
20:55:21 <medfly`> ^^
21:01:30 <Cale> :t and
21:01:31 <lambdabot> [Bool] -> Bool
21:01:38 <Cale> ^^ also might be handy
21:01:46 * hackagebot dns 0.1.2 - DNS libary in Haskell  http://hackage.haskell.org/package/dns-0.1.2 (KazuYamamoto)
21:02:53 <edwardk> i finally realized that comonadzip doesn't require anything magical about the resulting 'pre-applicative' its just a strong lax symmetric semimonoidal functor that preserves extraction
21:03:48 * hackagebot rpf 0.2.3 - Receiver Policy Framework  http://hackage.haskell.org/package/rpf-0.2.3 (KazuYamamoto)
21:03:57 <edwardk> ever have one of those lightbulb moments where you know there isn't anyone listening who will find that it was a lightbulb moment even remotely interesting? =)
21:04:51 <luite> if a lightbulb falls in the forest... :p
21:05:30 <luite> I don't know what a lax semimonoidal functor is, so I'd have to look that up first before being able to find it interesting
21:05:32 <edwardk> so with that ComonadZip is basically just Applicative - pure + extract + extend
21:06:04 <edwardk> at which point i really hate the 'Zip' name since there is no 'Zipping' in the semantics. so i think for symmetry with the arrow names, it becomes FunctorApply and ComonadApply
21:06:12 <dobblego> edwardk, yes, I know what you mean :)
21:06:28 <edwardk> class Functor f => FunctorApply f where (<.>) :: f (a -> b) -> f a -> f b
21:07:08 <edwardk> class (Comonad w, FunctorApply w) => ComonadApply w — gives you that extract (f <.> a) = extract f (extract a)
21:07:22 <edwardk> and from there all the dataflow machinery can work
21:08:50 <edwardk> dobblego: nicely scalaz's Apply is just that sand laws =P
21:08:52 <edwardk> er sans
21:09:02 <kfish> edwardk, how is <.> related to <*> ?
21:09:05 <dobblego> woot!
21:09:09 <edwardk> dobblego: (well, its also missing the functor part)
21:09:18 <edwardk> kfish, no presumption of the existence of pure.
21:09:25 <kfish> ok
21:09:25 <dobblego> edwardk, I mostly regret that
21:09:30 <jmcarthur> edwardk: i was just wondering... ArrowApply is enough to turn an Arrow into a Monad. what's necessary to turn an Arrow into a Comonad?
21:09:54 <dobblego> edwardk, but one part of me sympathises with Oleg's argument recently on haskell-prime
21:10:28 <jmcarthur> i'm personally in favor of adding the constraint
21:10:30 <edwardk> jmcarthur: you have a slightly harder time of it because of the polarity of things.
21:11:01 <jmcarthur> i think that if it does indeed turn out to be a hassle then we should come up with some language features to help
21:11:14 <jmcarthur> and there are several proposals already
21:11:15 <roconnor> dobblego: link
21:11:20 <edwardk> i mean even a cokleisli arrow 'is a monad', but its kind of uninteresting ;)
21:12:02 <edwardk> though to be fair, to get the cokleisli arrow, its of a comonad with zipping
21:12:12 <edwardk> aka one that is also a strong lax symmetric semi-monoidal functor
21:12:26 <jmcarthur> oh i didn't realize cokleisli had an arrowapply instance
21:12:32 <edwardk> mine does
21:12:36 <edwardk> but it presupposes ComonadZip
21:12:46 <jmcarthur> not according to haddock
21:12:52 <edwardk> thats old =)
21:13:02 <jmcarthur> ah
21:13:16 <edwardk> also are you looking in category-extras or comonad?
21:13:28 <jmcarthur> comonad
21:13:35 <dobblego> roconnor, http://www.haskell.org/pipermail/haskell-prime/2011-January/003312.html
21:13:50 <edwardk> http://hackage.haskell.org/packages/archive/base/4.3.1.0/doc/html/Control-Arrow.html#t:ArrowApply
21:13:55 <roconnor> thanks.  I was talking with my supervisor about that discussion today.  I haven't read it
21:14:23 <edwardk> i would like to argue that for once, oleg is on the wrong side of the argument ;)
21:14:47 <jmcarthur> heh, yeah, it's not often that i feel i could argue with oleg
21:15:08 <roconnor> not that I've read the thread yet, but it is true that it would be better to change the language to make local instances.
21:15:10 <edwardk> he is trying to save 2 !@#*() lines of code, in exchange for doubling the amount of code everyone else has to write
21:15:18 <edwardk> its wrong from a raw asymptotic perspective
21:15:23 <roconnor> but if we cannot change the language we should make superclass constraints
21:15:36 <edwardk> there are more consumers of a monads than monad instances. ;)
21:15:52 <edwardk> local instances are a terrible idea
21:15:58 <roconnor> why
21:15:59 <edwardk> they cost you confluence
21:16:03 <roconnor> how so?
21:16:19 <edwardk> right now the correctness of typeclass dispatch relies on the fact that instances are infectious
21:16:27 <edwardk> (and even that is slightly inadequate)
21:16:44 <edwardk> ever wonder why you can't pick and choose the instances you get when you import a module?
21:16:46 <roconnor> why would local instances prevent the infectiousness
21:17:04 <roconnor> maybe local instancess is the wrong word for what I"m thinking of
21:17:08 <roconnor> class instances
21:17:08 <jmcarthur> is there a reason that type classes can't just provide defaults for superclasses like they can for their own methods?
21:17:22 <roconnor> class Monad m where
21:17:25 <roconnor> ...
21:17:31 <roconnor>    instance Functor m where
21:17:36 <edwardk> because you'd be able to make up an instance for Ord for Int, and I could make up an instance of Ord for Int, but nothing prevents me from leaking over to you a Set that i built presupposing MY order, and you taking it apart with your order.
21:17:37 <roconnor>      fmap = liftM
21:17:54 <edwardk> and having it blow up in your face
21:18:07 <jmcarthur> maybe even leaving out the "instance Functor m where" part if it stands a chance of being unambiguous anyway
21:18:07 <roconnor> edwardk: that can already happen
21:18:28 <edwardk> ony in the presence of orphan instances
21:18:36 <edwardk> or extensions
21:18:54 <roconnor> maybe I should clairfy the propsoal I was considering today
21:19:45 <jmcarthur> roconnor: your proposal sounds like mine, if i'm understanding you right. in fact i thought your little example there was in reference to what i just said
21:20:02 <phao> what is the problem with this line? "data Just a = a"
21:20:10 <jmcarthur> phao: you need a constructor
21:20:12 <dobblego> phao, you need a constructor name
21:20:18 <phao> what is that?
21:20:24 <jmcarthur> data Just a = Something a
21:20:28 <dobblego> data Just a = ConstructorName a
21:20:36 <roconnor> @src liftM
21:20:36 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
21:20:37 <jmcarthur> then you use Something to create values of type Just 
21:20:39 <jmcarthur> a
21:20:40 <joe6> why can't I do : and . zipWith when zipWith is returning is a [Bool]?
21:20:46 <joe6> > and . zipWith
21:20:47 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
21:20:47 <lambdabot>         against inferred typ...
21:20:54 <jmcarthur> :t zipWith
21:20:55 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
21:21:01 <jmcarthur> :t and
21:21:01 <mauke> joe6: because zipWith doesn't return [Bool]
21:21:02 <lambdabot> [Bool] -> Bool
21:21:03 <edwardk> class Monad m => Functor m where fmap f m = >>= (return . f) — really Doaitse ?! http://www.haskell.org/pipermail/haskell-prime/2011-January/003326.html
21:21:11 <mauke> joe6: it returns [a] -> [b] -> [c]
21:21:11 <roconnor> http://hpaste.org/42827/class_instances
21:21:18 <jmcarthur> joe6: zipWith returns [a] -> [b] -> [c]
21:21:46 <joe6> it takes a function that returns c, in my case c = Bool
21:21:53 <edwardk> he made a similar amateur mistake in uuparsinglib for a while, its like he's forgotten how type class dispatch works
21:22:04 <roconnor> class instances would be overridable when making instances of the parent class
21:22:28 <edwardk> thats fine, you'd need to have them be non-orphans to make it sound to reason about them, etc.
21:22:42 <edwardk> it may play havoc with the feedback loop that is template haskell as well
21:22:46 <azaq23> joe6: google currying
21:22:49 <edwardk> so its probably a big flippin deal to implement
21:22:53 <roconnor> without class instances you need to write n instaces of functor.
21:23:17 <roconnor> with class instances you only need to write 1 instance of functor (plus a sprinking of others if you need to override the default implementation).
21:23:20 <jmcarthur> roconnor: okay that's different from my idea
21:23:24 <jmcarthur> roconnor: http://hpaste.org/42828/superclass_defaults
21:23:35 <joe6> >  and . zipWith (\x y -> 1 == y)
21:23:36 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
21:23:37 <lambdabot>         against inferred typ...
21:23:48 <edwardk> yes, I've often said that haskell's interface-only code-reuse between classes means that it pessimizes for support of deep correct hierarchies in favor of shallow hierarchies where you get the most bang for your buck out of each level
21:23:51 <mauke> joe6: zipWith still doesn't return a list
21:23:56 <mauke> joe6: it returns a function
21:24:01 <roconnor> jmcarthur: our ideas might be equivalent
21:24:25 <jmcarthur> roconnor: i'm confused about your lack of a Functor constraint
21:24:45 <edwardk> it has been good in one sense in that has helped folks focus on a few good abstractions, but it means that you common have all of these knock-on concerns (like the fact that Semigroup doesn't exist and can't be fixed retroactively)
21:25:00 <joe6> mauke: so I need sequence or something to execute that function?
21:25:08 <mauke> joe6: huh?
21:25:39 <joe6> mauke: I think I am missing something. I probably need to look at it with a fresh mind..
21:25:40 <roconnor> jmcarthur: well I write functor inside the class body.  No need to put it outside.  The functor constraint would still be infered from a (Monad m) constraint so your class constrains in signatures will remain short.
21:25:57 <mauke> joe6: (f . g) x = f (g x)
21:26:16 <mauke> joe6: (and . zipWith bla) x = and (zipWith bla x)
21:26:25 <mauke> joe6: that second line is malformed because you need zipWith bla x y
21:26:32 <azaq23> > let x = [1 .. 3]; y = [5 .. 7]; z = zipWith (<) x y in and z
21:26:33 <lambdabot>   True
21:26:43 <jmcarthur> roconnor: i see the idea, but i think it feels hackish
21:26:51 <roconnor> jmcarthur: how so
21:26:59 <roconnor> it seems natural to me.
21:27:02 <azaq23> however:
21:27:04 <azaq23> :t zipWith (<)
21:27:05 <lambdabot> forall a. (Ord a) => [a] -> [a] -> [Bool]
21:27:14 <azaq23> :t zipWith (<) [1 .. 3]
21:27:15 <lambdabot> forall a. (Ord a, Num a, Enum a) => [a] -> [Bool]
21:27:27 <roconnor> jmcarthur: though it took me 10 minutes to get comfortable with it
21:27:51 <jmcarthur> roconnor: whereas my idea kind of gives you a sense of "minimal completeness" for both Functor and Monad while still being clear about the constraints, yours seems to have two different kinds of Functors. how does it know that your Functor matches base's Functor and not somebody elses?
21:27:53 <azaq23> zipWith (<) x y == (((zipWith (<)) x) y)
21:27:54 <jmcarthur> *else's
21:28:14 <roconnor> jmcarthur: no there is only one kind of functor
21:28:21 <azaq23> so and . zipWith == \x -> and (zipWith x), which is wrong
21:28:31 <roconnor> jmcarthur: the class instance isn't a class declaration.  It is an instance declaration.
21:28:32 <jmcarthur> oh it's an instance, i read it wrong
21:28:51 <joe6> azaq23: thanks.
21:29:25 <jmcarthur> roconnor: okay, i suppose they would be equivalent, although i still much prefer my version...
21:29:37 <roconnor> jmcarthur: there appear to be two different use cases of super classes.
21:30:04 <roconnor> jmcarthur: the first one, and most natural one is that when you use a super class you are extending the signature of the class with new methods.
21:31:07 <roconnor> but in the second use of class constrants, the Functor constraint on Monad or the Eq constraint on Ord, the signature of the subclass is stand-alone, and the relationship is that the "super class" is definable from the "sub class"
21:31:33 <roconnor> so here we give a different notation to the second use case.
21:31:55 <jmcarthur> roconnor: the second seems to be merely a subset of the first
21:32:53 <edwardk> factoring out functorapply gave me a usable notion of traversable for comonadzip. — its basically traversable, but over FunctorApply instead of Applicative. which makes me sad because it'll never happen
21:32:57 <edwardk> because its yet another layer
21:32:58 <jmcarthur> roconnor: e.g. Monad could have been defined with return and join instead of return and (>>=), and then the addition of fmap would have been new functionality (necessary to be a monad, in this case)
21:33:07 <edwardk> =(
21:33:13 <roconnor> jmcarthur: you can see the second case as a kind of special case of the first one.
21:33:19 <jmcarthur> right
21:33:32 <Apocalisp> edwardk: yo!
21:33:33 <roconnor> jmcarthur: which is why I don't oppose your idea
21:33:37 <edwardk> heya apocalisp
21:33:48 <Apocalisp> doing alright?
21:33:53 <roconnor> jmcarthur: there might be some advantages to taking note of the special properies of this second use case.
21:33:54 <jmcarthur> it's Apocalisp!
21:34:03 <edwardk> yeah, my head stopped hurting around noon
21:34:26 <Apocalisp> sheesh, I didn't think my talk was THAT bad
21:35:18 <edwardk> hahaha
21:35:34 <edwardk> nah. just woke up with sinus crud
21:36:16 <roconnor> edwardk: you are right, oleg's post doesn't make sense.
21:36:37 <edwardk> roconnor: its like everyone wrapped around and became newbies again ;)
21:36:44 <dobblego> no it isn't, it makes sense
21:36:50 <roconnor> he says ther are two choices, define bind by itself or defined bind in terms of fmap
21:37:01 <roconnor> but there is the third and most obvious choice
21:37:10 <roconnor> define fmap in terms of bind!!
21:37:25 <edwardk> dobblego: its off on the substantive claim that the amount of code it requires is burdensome, and on the implementation claim that a monad wouldn't serve as a witness for a functor claim
21:37:30 <roconnor> instance Functor m => Functor (Iteratee el m) where fmap = liftM
21:37:32 <edwardk> yes
21:37:41 <roconnor> how could he have missed that?!
21:37:49 <roconnor> has he been doing too much Ocaml?
21:37:53 <edwardk> possibly
21:38:13 <roconnor> at some sense in the responses
21:38:36 <roconnor> Oh good
21:38:44 <roconnor> the instance constraint wasn't needed either
21:38:53 <roconnor> god, the wrongness of his post
21:39:07 <jmcarthur> yeah he must have just come from the bar or something
21:40:08 <roconnor> oh I see
21:40:21 <edwardk> roconnor: yeah but the responses i saw ended with doaitse making a similar mistake
21:40:25 <roconnor> oleg wants to write his own functor instance to relax the monad constraint to functor
21:40:34 <roconnor> but conor is right
21:40:38 <roconnor> you can't have your cake and eat it too
21:40:43 <edwardk> yeah
21:40:53 <edwardk> if you want the lighter functor, write it
21:40:54 <jmcarthur> if oleg wants that then he has to write his own instance anyway
21:41:15 <jmcarthur> so the additional constraint on monad imposes nothing new
21:45:13 <roconnor> yep yep
21:45:31 <roconnor> edwardk, jmcarthur: shall we just write our own haskell report together?
21:45:44 <jmcarthur> screw that, make a better language than haskell
21:45:50 <roconnor> :O
21:45:51 <roconnor> how?
21:45:56 <edwardk> roconnor: i've just been doing that in scala ;)
21:46:08 <roconnor> edwardk: doing what?
21:46:11 <jmcarthur> but haskell missed you, edwardk 
21:46:18 <edwardk> roconnor: writing a better haskell prelude ;)
21:46:57 <edwardk> when your first definition is for liskov substitution and your second is leibnizian equality, before you move on to hom-sets you know you're on an interesting track
21:47:36 <roconnor> huh?
21:47:51 <roconnor> jmcarthur: http://www.haskell.org/pipermail/haskell-prime/2011-January/003314.html
21:47:57 <roconnor> thisis the proposal I was thinking of
21:48:41 <roconnor> not sure what I think about this hiding thing though :/
21:49:06 <edwardk> roconnor: https://github.com/ekmett/magpie/blob/master/src/main/scala/magpie/subtype.scala
21:49:13 <roconnor> I guess it might be needed to solve this orphan instances issue
21:49:17 <jmcarthur> honestly, i'm just sick of the bikeshedding over all these ideas. i'd be happy if any of them were accepted
21:49:20 <roconnor> maybe that is what edwardk was on about
21:49:29 <edwardk> yeah
21:50:12 <cdsmithus> Bikeshedding over which ideas, specifically?
21:50:23 <edwardk> what annoys me about my current 'simple' comonad library is that i want streams to be able to be used in cokleisli arrows with arrowloop, but that requires 'comonadzip' and a 'functorapply' that is weaker than applicative lying around
21:50:40 <edwardk> cdsmithus: Functor as a superclass of Monad, etc.
21:50:53 <roconnor> cdsmithus: how best to automatically derive "super" class instances
21:51:09 <edwardk> and then the superclass instance stuff that is starting to reach a head
21:51:23 <jmcarthur> functorapply = applicative without pure?
21:51:38 <edwardk> personally the reason why i stopped writing so much haskell is because of the lack of superclass instance generation.
21:51:41 <edwardk> jmcarthur: yeah
21:51:56 <cdsmithus> Ah, right.  Yeah, fixing Functor and Monad would be good, for sure.  But I also tend to think it's a good thing if the prelude is resistant to change.
21:51:57 <edwardk> jmcarthur: sans pure its enough to do traverse, etc.
21:52:20 <edwardk> jmcarthur: and more importantly for me, its how all the dataflow comonadic stuff works
21:52:40 <jmcarthur> it would also be a natural target for HOAS
21:52:49 <edwardk> 'comonadzip' is basically a FunctorApply with an extra constraint that extract (f <*> a) = extract f (extract a)
21:53:44 <edwardk> so i've gone and renamed ComonadZip to ComonadApply for symmetry
21:53:48 <roconnor> oh crap
21:53:56 <roconnor> Remember the example
21:53:58 <roconnor> Monad implies Functor (fmap = Control.Monad.liftM)
21:53:59 <roconnor> Traversable implies Functor (fmap = Data.Traversable.fmapDefault)
21:54:01 <roconnor> e.g. [] and Maybe are instances of all these classes.
21:54:06 <roconnor> *sigh*
21:54:13 <roconnor> no wonder these things are not implemented 
21:54:20 <edwardk> ?
21:54:27 <edwardk> yes
21:54:50 <edwardk> you have to manually disambiguate or make the ones that get generated 'soft' in the sense that they get overridden by any explicit ones
21:55:03 <jmcarthur> type classes are cool, but sometimes you just want to turn off their viral nature...
21:55:04 <edwardk> but it is a hard problem
21:55:20 <edwardk> and you can't if you can turn off their viral nature you then can't rely on confluence
21:55:37 <edwardk> which is why they are SO much nicer to work with than scala's !*@(# implicits
21:56:17 <jmcarthur> from afar scala's implicits look alright. what sucks about them?
21:56:34 <jmcarthur> oh you just said
21:57:33 <jmcarthur> although i'm not entirely sure i understand what you mean "you can't rely on confluence"
21:57:44 <edwardk> ljmcarthur: you have two Set[Int]'s .. now combine them
21:58:21 <edwardk> in haskell you can hedge merge, etc. because both were built with the same ordering.
21:58:32 <edwardk> in scala you have to take one and insert it elementwise into the other
21:58:45 <jmcarthur> oh, i see
21:59:04 <edwardk> asymptotic explosion due to lack of confluence of instance resolution
21:59:44 <edwardk> you have imperative tools to kind of get that performance back, and lots of libraries just plug their ears and whistle loudly pretending it can never happen
21:59:46 <jmcarthur> well, i was always curious about scala's implicits, but you've convinced me about them very quickly
21:59:53 <edwardk> but its a major factor of correctness for me in scala
22:00:17 <edwardk> plus there are other limitations with implicit conversions not chaining, etc.
22:00:35 <dobblego> edwardk, do you mean that the Ordering for Int is not necessarily "the" implicit one?
22:00:41 <edwardk> dobblego: yes
22:00:49 <dobblego> yes, annoying as well as the chaining problem
22:01:30 <edwardk> dobblego: its my go-to example for why implicits and instances are two different solutions to slightly different but sometimes overlapping problem domains ;)
22:01:55 <dobblego> edwardk, I would throw in both of your complaints
22:02:36 <edwardk> okay, a separate Data.Functor.Apply or just roll it all into Control.Comonad ? =)
22:03:26 <jmcarthur> it's bikeshedding. do whatever
22:04:27 <jmcarthur> i have a leaning but it makes no difference
22:05:09 <edwardk> i was leaning towards separation, but its making a lot of tedium, and i have LOTS of tedium elsewhere
22:05:15 <dobblego> earlier versions of scalaz would put them together, today I do not know, but then, I am sympathetic to oleg's argument, where you appear not
22:05:48 <kfish> just put all the basic algebraic typeclass definitions into one module and be done with it
22:06:08 <edwardk> rolling it all together.
22:06:11 <edwardk> easier to read the haddock
22:06:17 <edwardk> and easier to use
22:06:38 <dobblego> oh wait, haskell, sorry
22:07:18 <edwardk> yeah
22:07:32 <edwardk> got your channels mixed up with the scalaz chatter?
22:07:33 <edwardk> =)
22:07:44 <dobblego> it's all the same to me!
22:08:11 <dobblego> how did Runar's talk go?
22:10:01 <edwardk> it went well, i need to cleanup and post the video
22:10:19 <dobblego> woot!
22:19:19 <azaq23> @check (\x -> case exp (x * (0 :+ 1)) of { real :+ imag -> (abs (cos x) - abs real) < 0.005 && (abs (sin x) - abs imag) < 0.005; _ -> undefined })
22:19:20 <lambdabot>   Occurs check: cannot construct the infinite type:
22:19:20 <lambdabot>    t = Data.Complex.Compl...
22:19:48 <azaq23> what's wrong with that? the usage of sin x and cos x seems to be the problem
22:20:09 * hackagebot relit 0.1.2 - Literal for regular expression  http://hackage.haskell.org/package/relit-0.1.2 (KazuYamamoto)
22:21:23 <azaq23> oh wait, (*) has type Num t => t -> t -> t, so t = Complex due to 0 :+ 1, so x is complex, so sin x is complex
22:21:54 <jmcarthur> you got it half way through my reply
22:23:05 <azaq23> still thanks though
22:44:41 <joe6> quick question: is there a function that can read the contents of 2 files in a zipped manner as: function file1 file2 => [(file1line1,file2line1)..(file1linex,file2linex)]
22:45:22 <joe6> i have more than 2 files, actually 5 files.
22:45:50 <Cale> joe6: you could use readFile on all of them which will read them lazily
22:46:00 <Cale> (readFile is somewhat magical)
22:46:11 <joe6> oh, really. will check it out.
22:46:11 <Cale> and then apply lines and zip them together
22:46:56 <joe6> Cale: could do that. but was thinking that there might something smarter..
22:47:36 <joe6> > zipWithM readFile
22:47:37 <lambdabot>   Couldn't match expected type `b -> m c'
22:47:37 <lambdabot>         against inferred type `GHC....
22:49:01 <joe6> > liftM (readFile)
22:49:02 <nanothief> joe6: something like this could work: liftM (transpose . fmap lines) $ mapM readFile ["/etc/rc.local", "/etc/bash.bashrc"]
22:49:02 <lambdabot>   Overlapping instances for GHC.Show.Show
22:49:03 <lambdabot>                              (m GHC...
22:49:21 <joe6> nanothief: thanks, will try it out.
22:50:45 <azaq23> joe6 readFile reads the file lazily, so strings will, though they do not appear so, only be read as needed from disk, so this isn't any less smart performance wise - of course, lazy IO can introduce bugs due to this behaviour
22:51:17 <azaq23> in case you meant that by smart
22:52:18 <aefjt> How do you set the continuation prompt in ghci?
22:55:32 <edwardk> roconnor: around?
22:55:46 <pastorn> what's the functor complement?
22:56:01 <edwardk> pastorn: as in dual of a functor? its functor
22:56:15 <pastorn> i have something like X a = (a -> X)
22:56:22 <edwardk> thats a contravariant functor
22:56:26 <edwardk> differentbeast =)
22:56:31 <pastorn> is there a typeclass?
22:56:38 <pastorn> which i can istantiate?
22:56:47 <edwardk> several. one in category extras, i think conal has one
22:56:50 <edwardk> but its not in the prelude
22:57:04 <pastorn> and not in Control.sumthin or Data.sumthin?
22:57:14 <edwardk> its not in base anywhere
22:57:19 <pastorn> isn't there something called CoFunctor?
22:57:20 <edwardk> there was a request on the mailing list
22:57:36 <edwardk> CoFunctor is misnamed, but its out there in typecompose or some such
22:57:51 <edwardk> its a 'contravariant' functor, cofunctor is a bad colloquialism
22:58:28 <pastorn> instance ContravariantFunctor X where -- ehm... annoyingly long name
22:58:50 <dobblego> class Contrafunctor f where contramap :: (b -> a) -> f a -> f b
22:58:57 <edwardk> a 'co'functor would dualize the arrows. taking the mapping provided by fmap: (a -> b) |-> (f a -> f b)    and giving you one (b -> a) |-> (f b -> f a) — but that modulo alpha substitution is where you started
22:59:13 <pastorn> wikipedia says "Contravariant functors are also occasionally called cofunctors."
22:59:16 <edwardk> yeah
22:59:17 <pastorn> so it must be true
22:59:24 <edwardk> but that was written by someone with the same sloppy thinking ;)
22:59:35 <pastorn> haha
22:59:47 <dobblego> Contravariant functors are also inappropriately called cofunctors.
22:59:52 <edwardk> its a bad habit, because it drives people to think that comonads should be "cofunctors"
23:00:16 <edwardk> further exacerbating folks lack of understanding of them =)
23:00:53 <edwardk> hypothesis: newtype WrappedApply f a = WrapApply { unwrapApply :: Either (f a) a } — is a comonad.
23:01:02 <edwardk> (given a comonad for f)
23:01:10 <banisterfiend> edwardk: do you think that ruby is a kind of haskell, but with a more robust soul (and further from the ivory towers of academia)
23:01:27 <edwardk> ruby makes me very sad ;)
23:01:39 <dobblego> ruby makes me very sad :(
23:01:48 <vegai> no, ruby is not a kind of haskell at all
23:02:01 <banisterfiend> dobblego: well we all know about your reddit debacle, so of course you're in a state of sadness and desperation
23:02:02 <pastorn> it's still pretty exhausting to write instances for this...
23:02:11 <dobblego> banisterfiend, debacle?
23:02:28 <banisterfiend> dobblego: if you're the same guy as dibblego
23:02:34 <dobblego> yes, I am
23:02:46 <banisterfiend> well you were all over reddit about a year ago iirc
23:03:08 <edwardk> i'd completely forgotten about that
23:03:11 <dobblego> how does this lead you to your conclusion?
23:03:27 <edwardk> but i think its largely irrelevant to the fact that ruby makes people sad ;)
23:03:29 <banisterfiend> nothing, i was just being edgy
23:03:29 <banisterfiend> hehe
23:03:44 <dobblego> it was a tactical manouvre in face of extreme idiocy that paid off very well :)
23:04:41 <banisterfiend> anyway bbl, getting drunk
23:04:46 <dobblego> it's all before the medical health board in a formal complaint today
23:04:51 <dobblego> later
23:15:26 * hackagebot crypto-api 0.3.1 - A generic interface for cryptographic operations  http://hackage.haskell.org/package/crypto-api-0.3.1 (ThomasDuBuisson)
23:25:29 * hackagebot TrieMap 0.7.2 - Automatic type inference of generalized tries.  http://hackage.haskell.org/package/TrieMap-0.7.2 (LouisWasserman)
23:25:45 <nanothief> What is the best way to serialize existential types? In the paste http://hpaste.org/42830/serializing_existential_types I want to serialize a list of existential types, however I can't think of a way to do this without modifying MainModule everytime a new MyClass instance is written 
23:29:16 <lispy_> nanothief: look at the reflection package on hackage
23:30:15 <nanothief> lispy_: checking it out now
23:35:10 <edwardk> https://github.com/ekmett/comonad/blob/master/Control/Comonad.hs is coming along. i now have FunctorApply and ComonadApply factored out
23:35:30 <edwardk> i have a couple of articles that use reflection as well
23:36:36 <nanothief> edwardk: they would be nice, the pdf file that the reflection package links to is a bit dense
23:37:13 <edwardk> plus the api for reflection bears little resemblance to the paper's
23:37:27 <edwardk> http://comonad.com/reader/2009/clearer-reflection/
23:38:42 <edwardk> nanothief: a more complicated usecase is in http://comonad.com/reader/2009/incremental-folds/ but i don't know if its in the current or the old api off hand
23:46:16 <nanothief> edwardk: I really don't understand what is happening in those two examples (my category theory knowledge isn't very good). What is the purpose of reify and reflect?
23:46:56 <edwardk> reify turns a value into a type. reflect lets you pull it back out. 
23:47:25 <edwardk> safety is provided by parametricity and the rank2 type, like how runST provides safety
23:47:47 <edwardk> (reify (+) reflect) 1 2   — is kinda boring but works
23:48:17 <edwardk> it does so by observing the fact that you can encode natural numbers as a type
23:48:36 <edwardk> and then you can make a type class that will convert from a type level natural number back to a term level natural number
23:49:59 <edwardk> so you could write something like reifyNat :: Nat -> (forall s. ReifiesNat s => Tagged s a) -> a
23:50:23 <edwardk> and provide a class ReifiesNat n where reflectNat :: Tagged n Nat
23:50:41 <edwardk> reifyNat 12 reflectNat  — would give you back 12
23:51:04 <edwardk> but would have to encode it in the interim in a type, maybe a data Zero; and data Succ n — with instances
23:51:07 <edwardk> so far so good?
23:51:32 <edwardk> instance ReifiesNat Zero where reifyNat = Tagged 0
23:51:45 <edwardk> instance ReifiesNat n => ReifiestNat (Succ n) where reifyNat = …
23:51:46 <nanothief> heh I think my understanding of haskell is a bit too low for this, only just started using rank n types
23:52:38 <edwardk> the main trick is that it takes a term, and comes up with a way to encode it into a type, that has a class instance which you can use to reflect the type back into the term you encoded
23:52:44 <edwardk> the encoding is a horrible hack
23:53:09 <nanothief> oh I see, you turn 3 into a type (eg Succ (Succ (Succ Zero))), then you can get the number back
23:53:50 <edwardk> it uses the ability to encode numbers as types, and the ability to encode lists of numbers as types, so therefore you can encode anything you can declare 'Storable' as a type.
23:53:59 <edwardk> and since StablePtrs are storable, you can encode anything
23:55:05 <edwardk> that is how it is able to reify (+) into a type such that (s `Reifies (Int -> Int -> Int))
23:55:26 <edwardk> and then you can use 'reflect' to get a Tagged s (Int -> Int -> Int) - upon demand
23:55:34 <edwardk> where Tagged is Applicative.
23:55:35 <edwardk> so
23:55:57 <edwardk> reify (+) (reflect <$> pure 12 <*> pure 23)
23:56:20 <edwardk> (Tagged is just the identity monad with a phantom type parameter to help you keep your 's's straight)
23:56:32 <nanothief> that is starting to make sense
23:57:30 <edwardk> i use it to enable me to make class instances that depend on vaues that happen to be in scope
23:57:46 <nanothief> I just can't see how to apply that to the topic of serialization
23:57:49 <edwardk> e.g. you can't make a Monoid with any old function you have lying around
23:57:52 <edwardk> i have no idea
23:57:57 <edwardk> that was lispy's comment ;)
23:58:11 <edwardk> i was just explaining the library =)
23:58:25 <nanothief> ha oh right
23:58:47 <edwardk> i think he was thinkingsomething about your need to serialize existentials
23:59:04 <edwardk> and that if you needed to make a serializable instance out of functions you have handy
23:59:09 <nanothief> I think my problem was I was looking at the library with as being similar to java's and rubys reflection libraries
23:59:20 <edwardk> but the problem is you don't know the type you are getting back
23:59:28 <edwardk> when you deserailize the binary
23:59:37 <nanothief> exactly
