00:00:07 <pumpkin> and then you use myTriple instead of requiring the values to be parameters to the typeclass
00:00:14 <dcoutts> maurer_: try .0.4 or .0.6
00:00:18 <pumpkin> assuming they're fixed :)
00:00:19 <j-invariant> category of algebras of course
00:00:21 <pumpkin> which they probably aren't
00:00:37 <colah> The beauty of it is that you can use orthoganal functions and it to approximate a  function, just like you can create a vector from an orthoganal basis. See Fourier Series.
00:02:08 <maurer_> dcoutts: OK.
00:02:10 <pumpkin> anyway, I'm going to sleep
00:02:29 <pumpkin> if that triple of values is dynamic, you'll have to do what j-invariant says and use implicit configurations, or rethink your approach
00:02:30 <dcoutts> maurer_: you'll also need to put the lib and exe in separate source dirs
00:02:39 <maurer_> dcoutts: Already done.
00:02:51 <j-invariant> colah: think a bout modular arithmetic, you can't make a typeclass   class Mod m where ...   instance Mod 4 where .. etc.
00:03:07 <j-invariant> colah: same thing here, you can't hhave  instance L2 (0,inf,3) whatever
00:04:00 <colah> Sadly.
00:04:26 <j-invariant> you can do:
00:04:26 <colah> I can't really find anything on implicit configurations. There's a bunch of broken links. Can you point me in the right direction?
00:04:37 <j-invariant> data Zero_Inf_Three
00:04:45 <j-invariant> and then instance L2 Zero_Inf_Three where ...
00:04:47 <j-invariant> but that sucks
00:04:51 <pumpkin> (that's what I was talking about before)
00:05:11 <j-invariant> www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf
00:05:14 <profmakx> *grml* bootstrapping ghc is and stays a pain
00:05:36 <colah> Thanks.
00:05:43 <banisterfiend> profmakx: what does grml mean, is that a kind of markup language
00:05:54 <j-invariant> colah: ^ this is what I am using to do polynomials quotiented by an irreducible (for algebraic number rings)
00:06:16 <j-invariant> colah: same thing as modular arithmetic, L2, etc.. all the same problem
00:06:20 <profmakx> banisterfiend its just an expression of frustration, just like *lol* is an expression of you know what
00:06:34 <profmakx> (grml also is some linux-distribution)
00:06:47 <colah> And here I was in awe of your knowledge of random obscure peices of haskell. :)
00:06:59 <maurer_> dcoutts: the build now runs, but I get a linker error
00:07:11 <maurer_> (don't get one if the two directories are merged)
00:07:15 <j-invariant> llol
00:08:11 <j-invariant> Given a Monad T we can find functors to/from the category of T algebras.. with FG = T. Do these F and G have any use?
00:08:27 <j-invariant> maybe some algorthms are easy to define in the alg. category?
00:08:28 <banisterfiend> profmakx: imo a lol has to really be earned, i despise ppl who just say 'lol' at almost every opportunity
00:08:52 <j-invariant> just wonder if the connection with adjunctions has had some application in Haskell?
00:10:06 <profmakx> banisterfiend, in a way, my grumpiness is earned ;)
00:10:20 <profmakx> and i don't lol as a general rule
00:10:52 <banisterfiend> how do i compare a specific file from two different branches (in git) ?
00:11:01 <j-invariant> banisterfiend: wrsong channel
00:11:13 <ion> “lol is not punctuation”
00:11:55 <maurer_> dcoutts: Disregard that, fixed.
00:12:29 <profmakx> anyway.  i see why bootstrapping isnt fixed, but i would love to understand enough of this pile of source to be able to do it
00:14:20 <etpace> it seem No instance for (Typeable7 ((,,,,,,,,) Purpose OrderPlace)) <- can anyone shed some light on this error?
00:16:36 * hackagebot hsx 0.9.0 - HSX (Haskell Source with XML) allows literal XML syntax to be used in Haskell source code.  http://hackage.haskell.org/package/hsx-0.9.0 (NiklasBroberg)
00:20:37 * hackagebot hsp 0.6.0 - Haskell Server Pages is a library for writing dynamic server-side web pages.  http://hackage.haskell.org/package/hsp-0.6.0 (NiklasBroberg)
00:27:16 <j-invariant> the way they do monads in catsters doesn't (seem) to have any "map" involved]
00:27:21 <j-invariant> e.g. it's just concat instead of concatMap
00:27:25 <j-invariant> what's going on with that?
00:29:13 <thor875> hey guys, newbie question here: how does one do dynamic dispatch in haskell (i.e. in C++, when I call through a base-class pointer, and get derived class method invoked because of vtable indirection).... how does one do this kind of thing in Haskell?  Thanks!
00:29:34 <j-invariant> thor875: typeclasses do static dispatch
00:29:41 <j-invariant> dynamic dispatch which happens at compile time
00:30:27 <thor875> j-invariant: okay, so if I want dynamic dispatch that happens at run time, can one do that?
00:30:35 <augur> hmm
00:30:38 <j-invariant> no use typeclasses
00:30:50 <augur> im liking these functions like maybe, either, and cond/bool
00:30:52 <augur> hmm hmm!
00:31:01 <vegai> they're quite crunchy
00:31:10 <thor875> do typeclasses do runtime dynamic dispatch then?
00:31:22 <j-invariant> thor875: they do dispatch at compile time
00:31:29 <vegai> thor875: I suppose the answer might be that you don't need dynamic dispatch in Haskell
00:31:41 <augur> list z _ [] = z   ;   list _ f xs = f xs
00:31:49 <vegai> I feel it'd be easier to answer this however if you had a concrete example of what you want
00:31:54 <j-invariant> augur: why not foldr?
00:32:05 <thor875> vegai: (my head is spinning :-) what does one do instead?
00:32:06 <augur> maybeHead = list Nothing (return . head)
00:32:30 <j-invariant> thor875: do it at compile time instead of run time
00:32:58 <augur> maybeTail = list Nothing (return . tail)
00:33:37 <augur> which leads to the obvious simplification:   maybeize f = list Nothing (return . f)
00:33:45 <augur> at least, for list functions
00:34:01 <augur> @pl \f -> list Nothing (return . f)
00:34:01 <lambdabot> list Nothing . (return .)
00:34:15 <augur> well that was simple
00:34:51 <thor875> vegai: concrete example, good question: I can't think of a good one right now (that's short enough for chat). But it isn't always possible to know at compile time the deterministic order of program evaluation. So if you wanted to dispatch dynamically at runtime through a base class pointer and a vtable, is there any similar (or replacement) mechanism to do so?
00:35:21 <j-invariant> this isn't C++ we don't have pointers or vtables
00:36:09 <thor875> j-invariant: I know that, I'm asking how you acheive comparable functionality in Haskell (how does one get dynamic dispatch of a polymorphic function at runtime)?
00:36:17 <ksf_> wtf. 10% speedup from adding an inline annotation to "foo = castPtr"
00:36:23 <Saizan> thor875: you can always just pass a function, or a collection of functions to be called
00:38:04 <thor875> Saizan: yes, okay. Of course.  Is there no sense of "an interface" pointer, that specifies a a pointer to a vector of functions...
00:38:32 <augur> thor875: you just pass the things themselves
00:38:37 <Saizan> thor875: you can define a datatype whose fields are functions with certain types
00:38:37 <augur> references dont exist
00:39:02 <Saizan> thor875: then you just pass a value of that type
00:40:03 <thor875> Saizan: okay that makes alot of sense. Do datatypes let you specify a type signature for their fields?
00:40:14 <Saizan> thor875: sure
00:40:46 <thor875> Saizan: very cool. is the keyword "datatype" what I should investigate to learn more?
00:42:25 <thor875> (or is that the same as "data" ?)
00:46:11 <Saizan> thor875: they are defined with the data keyword, and are called Algebraic Data Types, ADT, in general, but in particular you probably want to look at record types
00:46:12 <Saizan> often you don't even need one, since the whole "interface" is a single function
00:46:39 <j-invariant> thor875: object oriented programming you mean?
00:46:54 <thor875> anyways, thanks alot guys!
00:46:54 <thor875> Saizan: many thanks. I'll check out ADT and record types.
00:47:29 <thor875> j-invariant: yes, I'm coming from a C++ background
00:48:59 <j-invariant> thor875: you would build an object oriented language inside haskell from scratch - then use that
00:59:06 <triyo> Is there a better way to do this: ... (any (\(BoardMove tm _) -> tm == Nothing) mylist) ... I pattern match in my code all over the place just to extract the first first or second field of BoardMove data type.
01:00:03 <Veinor> write a function to do it?
01:00:30 <shachaf> triyo: Use isNothing instead of (== Nothing).
01:00:59 <norm2782> data BoardMove = BoardMove { f1 :: Maybe Something, f2 :: Maybe SomethingElse  }
01:01:12 <triyo> shachaf: what is the difference between the == an isNothing?
01:01:15 <shachaf> triyo: And use some function f tm _ = tm; then you can say (any (isNothing . f) myList)
01:01:20 <shachaf> triyo: One has an Eq constraint.
01:01:54 <shachaf> (I mean "f (BoardMove tm _) ...", of course.)
01:02:04 <triyo> shachaf: oh I see now, thanks
01:03:15 <shachaf> triyo: Alternatively, use record syntax, as norm2782 suggested.
01:03:36 <shachaf> Then you get f for free, and possibly more clarity.
01:03:55 <triyo> right, I see record syntax as a better option
01:04:04 <triyo> as you say you get the f for free
01:11:49 <tolkad> I have a function which returns some value from some type of an infinite set of types. I'm not sure how to express this in haskell code
01:12:22 <triyo> made the changes and things are looking much better now. Also composing the isNothing with f is much nicer. Thanks all for being very helpful here. :)
01:13:06 <tolkad> I was thinking about using RankNTypes, but then if someone writes class instances for all of the types in this set, that class wont be in my returned class list
01:23:02 <Nullus> hey everyone
01:24:33 <Nullus> Im having a little problem here with the real world haskell csv parser, the thing is my csv input file has some characters like "ã" and when I do the parsing the output string seems to save them under a code
01:24:45 <Nullus> and doesnt display properly
01:25:10 <Nullus> anyone who could provide some help?
01:28:21 <ksf_> oooooh the C version bit-packs the nucleotides
01:29:25 <systemfault> ksf_: Hey, what's happening with the fasta one?
01:29:36 <ksf_> I'm not working on fasta
01:31:18 <Saizan> Nullus: are you using print and/or show on String's ? that adds the escapes, you want a direct putStrLn instead
01:31:37 <Nullus> Right r -> mapM_ print r
01:31:53 <ksf_> ...but when I do that I can't have my keys be indices into the source data
01:31:59 <ksf_> won't work alignment-wise
01:32:07 <Nullus> I'll try with PutStrLn
01:34:42 <ksf_> ...but I only need a max of 34 bits for the keys, so it's even better, they easily fit unboxed into a bucket.
01:37:57 <ksf_> :t concatMap
01:37:58 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
01:39:16 <banisterfiend> :t concatSelect
01:39:17 <lambdabot> Not in scope: `concatSelect'
01:39:26 <banisterfiend> :t Y-Combinator
01:39:27 <lambdabot> Not in scope: data constructor `Y'
01:39:27 <lambdabot> Not in scope: data constructor `Combinator'
01:53:01 <untwisted> I'm trying to use a package that defines type NickName = ByteString, and another data structure that has an IO NickName field. I'm unsure how to produce the IO NickName from a ByteString
01:54:05 <shachaf> untwisted: return :: ByteString -> IO NickName
01:54:59 <Veinor> untwisted: type NickName = ByteString means that NickName and ByteString are the same thing, like String and [Char]
01:55:45 <triyo> I have a type synonym ... type MySyn = [MyType] and need to define a show instance for MySyn. I know there is language extension for this. Other options I guess are to turn the synonym into a newtype or a data type.
01:56:21 <shachaf> triyo: There's an extension that lets you say "instance Show MySyn", but that's exactly equivalent to saying "instance Show [MyType]".
01:56:28 <shachaf> It doesn't get a "different" Show instance.
01:57:01 <untwisted> Veinor: Yah, I get that much, I...  I don't really know what I'm missing about it.  I think I need to read more :-/
01:57:52 <triyo> Hmm I guess I made a poor choice when selecting between synonym or newtype as now it will effect quite a bit of existing code
01:58:45 <triyo> It just that the synonym for list seemed to be the simplest solution instead of needing to wrap/unwrap all the time.
01:59:05 <shachaf> triyo: If you want it to behave differently from a #define, it should be a newtype.
02:00:05 <triyo> I see
02:17:52 <quuuux> http://pastebin.com/6FBpYTHf - ghci can't find the relevant instance, but building with cabal can? I've looked in the libraries' source code, and it's definitely there
02:18:01 <ksf_> are boolean dph arrays packed?
02:18:27 <ksf_> it'd actually be cool to have arbitrarily-sized words
02:19:40 <quuuux> trying :m Control.Monad.Exception at the ghci prompt doesn't seem to find it, either, because then :l TestHs.hs fails
02:20:27 <ksf_> quuuux, use -v and have a look at the packages loaded.
02:20:34 <ksf_> most likely they're defaulting to different stuff.
02:21:22 <Jafet> How many years until haskell can map a real genome?
02:21:37 <ksf_> oh and don't use base 3.
02:21:43 <ksf_> did you mean base >= 4?
02:21:55 <ksf_> base > 3 also includes base == 3.0.1
02:22:14 <quuuux> oh, heh. That was just trying to make the warning go away
02:22:44 <banisterfiend> anyone here recommend tryhaskell ?
02:22:56 <ksf_> whatever you do, use base4 for new code.
02:23:23 <ksf_> banisterfiend, I recommend learn you a haskell and installing the haskell platform locally.
02:23:31 <quuuux> yeah, the actual code has a proper version for base :)
02:23:34 <ksf_> but for starters, tryhaskell is not half bad.
02:25:07 <HugoDaniel> http://axisofeval.blogspot.com/2011/01/why-lisp-is-big-hack-and-haskell-is.html
02:25:09 <HugoDaniel> :)
02:25:12 <quuuux> http://pastebin.com/RL9HPr0X - ghci -v output. I don't see anything particularly suspicious, but I'm not sure what I'm looking at
02:26:12 <qfr> HugoDaniel that's been posted in here like 8 times in the past two days
02:26:26 <ksf_> ghci is using base 4
02:26:40 <HugoDaniel> :D
02:26:43 <ksf_> ...and the newest mtl.
02:26:43 <HugoDaniel> sorry qfr
02:26:48 <HugoDaniel> i just found about it now
02:27:25 <ksf_> but no cme
02:28:00 <quuuux> oh. Hmm. When I specify the -exact- versions in the cabal file, I get the same error. Okay, that's something to go on, thanks!
02:28:22 <ksf_> you don't import Control.Monad.Exception.MTL
02:28:35 <ksf_> http://hackage.haskell.org/packages/archive/control-monad-exception-mtl/0.8.0.3/doc/html/Control-Monad-Exception-MTL.html
02:28:40 <alpounet> i have a -> s -> (b, s) functions
02:28:45 <ksf_> which will have the right instances
02:28:48 <alpounet> is there something for it ?
02:28:54 <alpounet> it's almost State but not exactly
02:29:29 <ksf_> that's state
02:29:33 <quuuux> ksf_: different module. exceptions-mtl is just a thin wrapper, wrapping (MonadError SomeException) conveniently
02:30:04 <quuuux> aha. exceptions-mtl requires mtl == 1.1.*. The module's patchy anyway, so I'll just take it wholesale
02:30:42 <ksf_> ouch. it's nameclashing.
02:30:56 <alpounet> ksf_, hum, sorry, the return type is IO (b, s)
02:31:09 <ksf_> wait that's a completely different package.
02:31:29 <quuuux> ksf_: yeah. I don't have control-monad-exception installed, even
02:31:46 <quuuux> if I did, ghci would spit out an error about resolving the import
02:31:48 <ksf_> according to the haddock, it defines MonadTrans ExceptionT
02:32:24 <quuuux> ksf_: I think it's just a version conflict with mtl, which I'm going to resolve by just using a patched version of the package included wholesale
02:32:30 <j-invariant> Does anyone know where I can see an xaempl of Monad used as an algebraic thoery
02:35:19 <codolio> Probably Categories for the Working Mathematician.
02:35:43 <j-invariant> is that a dgood book?
02:36:12 <codolio> It's famous.
02:38:07 <dolio> The short of it goes like....
02:38:07 <gienah> Steven_M: you could add an enty to /etc/hosts for code.haskell.org instead
02:38:20 <gienah> sorry, wrong channel :-/
02:38:55 <shapr> Wasn't there a web-based auto-eval-style Haskell front end?
02:38:58 <shapr> I've forgotten the name...
02:39:04 <ivanm> tryhaskell.org ?
02:39:08 <quuuux> what's the difference between mtl 2 and mtl 1? Is it all internal stuff?
02:39:11 <dolio> For a monad (T, eta, mu), you consider T-algebras (A, a : TA -> A), where a satisfies some equations with eta and mu.
02:39:20 <ivanm> quuuux: less constructors, etc.
02:39:23 <shapr> ivanm: Nah, I mean something that evals and outputs images and more...
02:39:34 <j-invariant> dolio: yeah
02:39:36 <j-invariant> dolio: 
02:39:38 <ivanm> shapr: oh, there was a couple of mathematica-style front ends to haskell IIRC
02:39:43 <ivanm> but not web-based AFAIK
02:39:50 <quuuux> ivanm: oh, worth porting to?
02:39:53 <ivanm> shapr: try looking in HCAR? :/
02:39:54 <ivanm> quuuux: yes
02:39:58 <shapr> I saw something, but can't remember....
02:40:11 <j-invariant> dolio: I have the definition but I was looking for applycations
02:40:15 <dolio> a . eta = id, a . mu = a . Ta
02:40:15 <shapr> oh, I think it might have been an application where code in a window could produce images, etc
02:40:16 <ivanm> quuuux: the changes probably won't be that much anyway
02:40:24 <qfr> I hate that the tryhaskell thing doesn't permit pasting
02:40:25 <ivanm> and if you can, just use transformers rather than mtl itself
02:40:29 <Jafet> shapr: benmachine's stepeval?
02:40:35 <ivanm> shapr: yeah, that's what I was talking about
02:40:47 <j-invariant> it's funny how the "monad laws" are actually the laws about algebras
02:41:12 <shapr> j-invariant: yup, it's a convention that just makes life saner.
02:42:08 <shapr> Jafet: that's cool, but not what I was trying to find
02:42:18 <shapr> I think this was put out by a Yale or Nottingham researcher.
02:42:28 <dolio> j-invariant: Well, if you just want examples, take, say, monoids. There's the free monoid monad, which in Haskell is called []. And monoids are in correspondence with algebras of that monad.
02:42:31 <shapr> It was for visualizing program evaluation, but it did so far more interactively.
02:42:50 <dolio> j-invariant: The same is true for all algebraic structures. Groups and the free group monad, etc.
02:45:11 <j-invariant> oh yeah
02:45:14 <j-invariant> so it can't define fields
02:45:20 * ksf_ wants a bit-wise implication operator
02:45:22 <dolio> Probably not.
02:45:45 <derg> can people post their personal webpages?
02:46:20 <j-invariant> I wodner what it's used for in real mathematics
02:46:31 <ivanm> derg: where?
02:46:40 <derg> here
02:46:42 <j-invariant> I think the Moggi paper is too advanced for me to read rightnow
02:47:14 <ivanm> derg: what for?
02:47:32 <ivanm> you can certainly paste a link here, but people are unlikely to look if it isn't related
02:47:48 <twb> Remind me, how do you ask the bot for all functions matching a type signature?
02:47:55 <ivanm> twb: @hoogle
02:48:01 <ivanm> or use the actual hoogle web page
02:48:09 <ivanm> or hayoo for searching all of hackage
02:48:11 <twb> @hoogle (a->b->b) -> [a] -> (b->b)
02:48:12 <lambdabot> Prelude foldr :: (a -> b -> b) -> b -> [a] -> b
02:48:12 <lambdabot> Data.List foldr :: (a -> b -> b) -> b -> [a] -> b
02:48:12 <lambdabot> Prelude scanr :: (a -> b -> b) -> b -> [a] -> [b]
02:48:13 <derg> ivanm: im interested in what people are doing and also i need to redesign my page
02:48:19 <twb> Aha, I WAS right.
02:48:34 <ivanm> derg: well, #haskell-blah might be more relevant if you want general web-page advice
02:48:41 <dolio> j-invariant: I'm not an expert on this stuff, but one thing I don't really get about the monads-and-algebra stuff is how you go from, say, a bunch of equations and generators to the relevant monad, without figuring out the category of algebraic structures as an intermediate.
02:48:42 <ivanm> rather than haskell-related help/advice
02:48:53 <twb> I wanted a function for .bashrc that I *thought* was foldr, but wasn't sure
02:49:11 <dolio> So it doesn't seem useful for, like, defining the relevant category.
02:49:23 <Xilon> foldr for bashrc?
02:49:29 <twb> Xilon: yeah.
02:49:39 <twb> Xilon: to go with my existing map()
02:49:45 <Xilon> didn't know bash had foldr
02:49:48 <dolio> There's an alternate technique for algebra in category theory, too. Lawvere theories.
02:49:51 <twb> Xilon: I'm going to write one
02:50:01 <j-invariant> dolio: oh yeah that's a good point: When I saw the monad for the theory of categories they use Grph.. no explanation why!
02:50:10 <twb> Where b is stdio
02:50:21 <dolio> Which I think is closer to the generators and equations style of algebra.
02:50:32 * shapr hugs twb
02:50:36 <derg> ivanm: o ok, im good with web design id just like to see how haskell types make their homepages
02:50:54 <derg> ivanm; and see what projects their up too
02:50:54 <ivanm> *shrug* all different ways from what I've seen
02:51:20 <j-invariant> The Category Theoretic Understanding of Universal Algebra: Lawvere Theories and Monads  <-- sounds interesting
02:51:21 <qfr> Heh, I'm going to start webdev in Haskell soon, but still finishing another Ruby project prior to that to generate the data required for the Haskell project
02:51:48 <shapr> twb: I want to see the results of your foldr
02:52:23 <dolio> j-invariant: Lawvere theories are a little more restrictive than monads, too, in ways I can't really explain. For every Lawvere theory there's a monad, but not vice versa.
02:52:35 <qfr> I know somebody who went through all the trouble to learn some category theory and ULC etc to understand Haskell better but he told me he was rather disappointed, he thought it didn't give him any insight really and it had no implications for his coding pracices
02:52:35 <dolio> Although there's generalized Lawvere theories that rectify that.
02:52:39 <qfr> practices*, too
02:53:16 <dolio> I think it's something like, Lawvere theories only cover algebraic theories with operations of finite arity or something.
02:53:33 <tolkad> How are existentially quantified types represented in memory?
02:53:49 <derg> any puredata users in here?
02:54:07 <shapr> derg: Are you looking for functional reactive programming?
02:54:49 <tolkad> How are existentially quantified types represented in memory in ghc?
02:55:00 <dolio> Like, the theory of continuations with call/cc is a monad, but there's no Lawvere theory for it.
02:55:18 <dolio> I think that's an example.
02:55:54 <derg> shapr: yes
02:56:04 <quicksilver> tolkad: if there is no class context then the representation is the same as the unquantified type
02:56:21 <quicksilver> tolkad: if there is a class context then it's something like a pair of a dictionary and the value itself
02:56:41 <dolio> Not the same, I think. There's extra boxing.
02:57:10 <dolio> It'd be like wrapping in 'data BId a = Bid a'.
02:57:19 <j-invariant> dolio: geez I might just stick with monads then!
02:57:51 <dolio> j-invariant: Lawvere theories probably have some nicer properties in return for the loss of generality.
02:58:34 <ksf_> anyone got a brilliant idea on how to get the bits marked 1 in "0000011000000110000001100000011000000110000001100000011000000110" to be consecutive?
02:58:43 <twb> shapr: if I disappear in a minute, it's because I forkbombed myself by screwing up the zeroth case.
02:59:06 <dolio> Something about combining two theories, for instance.
02:59:26 <quicksilver> dolio: well, only the layer of boxing inherent in the existential type being created.
02:59:33 <ksf_> log?
03:00:16 <quicksilver> dolio: my point is that the representation of "data ExFn = forall a . ExFn (a -> String)" and "data ConcFun = ConcFun (Int -> String)" are the same
03:00:28 <dolio> Yeah.
03:00:37 <quicksilver> dolio: the existentiality of the 'a' in the first class doesn't change the representation at all.
03:00:41 <quicksilver> s/class/case/
03:00:56 <twb> uhoh
03:01:20 <shapr> twb: forkbombed?
03:01:29 <twb> Nope, recovered
03:01:31 <ddarius> dolio: I recommend Goguen et al's "Initial algebra semantics and continuous algebras" which I just (re?)read the early part of.  See if you can spot the (free) monad.
03:01:39 <twb> Good thing I set up those ulimits
03:02:17 <ddarius> Also, Lawvere theories are pretty paltry mostly due to simplicity and the fact that it was enough to cover a good chunk of abstract algebra (and much more.)
03:02:30 <ddarius> The generalization of Lawvere theories is the theory of sketches.
03:03:05 <j-invariant> they talk about sketches in th Barr and Wells book
03:06:16 <ddarius> Right now I'm trying to decide if I want to use a Lawvere theoretic or a monadic approach to introducing many-sorted algebras for semantics.
03:07:13 <qfr> ddarius what are yuo working on there?
03:07:21 <qfr> a DSL in Haskell?
03:07:29 <qfr> Some CAS? A library?
03:15:10 <Nullus> ok guys anyone knows how could I remove the spaces in the beginning of a cell Im building a csv parser btw
03:15:11 <Nullus> csvFile = endBy line eol line = sepBy cell (char ',') cell = quotedCell <|> many (noneOf ",\n\r")
03:15:56 <quicksilver> cell = many (char ' ') *> {- what you had before for cell -}
03:16:13 <Botje> many space >> 
03:16:29 <Botje> or the applicative stuff
03:16:35 <Nullus> Ill give it a try
03:16:38 <Nullus> ty guys
03:20:56 <tolkad> infinite storage! http://codepad.org/d8fYzazb
03:21:35 <tolkad> I can store any Integer using constant memory
03:21:42 <tolkad> with existential quantification
03:23:20 <tolkad> this will revolutionize computer science
03:24:14 <ivanm> tolkad: constant infinite memory? :p
03:25:06 <tolkad> ivanm: no, constant memory. I'm using existentially quantified newtypes so they don't take memory
03:25:14 <dolio> You weren't paying attention.
03:25:20 <dolio> Dictionaries cost memory.
03:26:40 <tolkad> dolio: newtypes don't take memory?
03:26:41 <dolio> Even the boxes cost memory.
03:26:42 <twb> shapr: http://paste.debian.net/103725/
03:26:50 <tolkad> dolio: not newtype boxes
03:26:59 <dolio> You're not using newtypes.
03:27:00 <twb> shapr: not ideal, but I *think* it's correct.
03:27:24 <tolkad> dolio: yes I am. my only "data" are N and P and they don't have arguments
03:27:28 <dolio> Oh, you are. That won't compile.
03:27:40 <tolkad> why not?
03:27:52 <dolio> Because you cannot use existential quantification with newtypes.
03:28:36 <shapr> The National Haskell Speed Holiday must be July 1st, Unboxing Day (opposite Boxing Day).
03:28:56 <Igloo> Speed?
03:29:29 <twb> shapr: e.g. to find all five-letter words that contain the letters m, a, i and l:
03:29:30 <twb> shapr: egrep -xi '[[:alpha:]]{5}' /usr/share/dict/words | foldr grep -- m a i l
03:29:38 <tolkad> darn it, lets see if I can fix this
03:31:12 <dolio> Anyhow, the dictionaries are going to be less space efficient than integers.
03:32:22 <shapr> twb: nifty!
03:32:52 <shapr> twb: What's map() ?
03:32:57 <twb> It's nice to know about HOFs so that when I actually want one, I can recognize the symptoms :-P
03:33:07 <ksf_> what's two bits called?
03:33:10 <ksf_> four bits are a nibble.
03:33:19 <j-invariant> a nib
03:33:21 <twb> shapr: http://paste.debian.net/103726/, which I'm sure I've posted before
03:33:28 <j-invariant> or a twit
03:33:48 <twb> ksf_: shaveandahaircut
03:35:51 <twb> ksf_: I think a qubit has four classical values (0, 1, both, neither)...
03:36:34 <shapr> and the fifth value wtf
03:37:39 <twb> It might be allowed to be any partial probability between the two -- like bayesian algebra.  Wikipedia says it's a "superposition of the two", but I'm too sleepy and stupid to grok it.
03:38:45 <quicksilver> qubits are more than just probabilities though
03:38:51 <quicksilver> because they're not independent of each other
03:39:14 <quicksilver> they're a probability distribution across all the qubits in the same sytsem
03:39:38 <twb> I just like it because it's a homophone of cubit
03:41:05 <ksf_> I'm talking about two bits, not quantum mechanics.
03:41:09 <ksf_> two bits as in four values.
03:41:44 <twb> ksf_: yes, but whatever name you pick should be an inside joke
03:42:37 * quicksilver votes for cubit then
03:43:48 <twb> quicksilver: I was also considering dubit or tetrabbit, depending on whether you're counting the number of bits or the number of states
03:44:11 <quicksilver> doublit
03:44:41 <twb> Or "dit", because "bit" uses b (the second letter of the alphabet).
03:44:58 <shapr> o hai gbacon 
03:45:10 * twb looks for a book on numerology
03:45:13 <gbacon> shapr: yo
03:45:23 <gbacon> shapr: when's the meetup?
03:45:37 <ksf_> so...I'm going to pack the alphabet 'acgt' into two bits, reduing the size to 1/4th, and then add three shifted versions of those to have sane alignment when moving the scan window character by character.
03:45:47 <gbacon> shapr: Jake's supposed to give a talk here on 1/28 about multicore parallelism through purity
03:45:56 <quicksilver> "The term "semi-nibble" (or occasionally "quartyr") is used to refer to a 2-bit collection, or half a nibble"
03:45:59 <gbacon> shapr: you should come check it out
03:46:14 <ksf_> something tells me I should unpack the keys uncompressed, first.
03:46:38 <shapr> gbacon: Oh awesome, will he be talking about STM etc?
03:46:59 <quicksilver> "2 bits: crumb, quad, quarter, tayste, tydbit, semi-nibble."
03:47:15 <gbacon> shapr: I don't recall his abstract mentioning it specifically
03:47:38 <twb> My gramma calls less than a bite "a sensation"
03:48:04 <shapr> gbacon: Where's the presentation? dB?
03:48:56 <gbacon> shapr: yep, here at dB from 11:30 to 12:30 on January 28
03:50:41 <tolkad> I tested it this time! it works! infinite memory: http://codepad.org/EJ3T2Ltp
03:50:58 <tolkad> loseless compression of arbitrary data
03:51:03 <tolkad> lossless*
03:51:59 <shapr> gbacon: That's one of my off days, I'll try to show up and see jmcarthur's talk.
03:52:14 <gbacon> shapr: good call; see you then
03:52:19 <tolkad> dolio: I told you I could do it
03:52:36 <gbacon> shapr: it's open to the public, so bring a friend or two
03:53:03 <tolkad> you should note it has TypeFamilies enabled
03:53:10 <tolkad> you should always enable TypeFamilies
03:53:25 <tolkad> it makes the codes run faster
03:58:20 <tolkad> I can't believe I'm the first person to think of this
03:58:37 <tolkad> now we can store any amount of data in a constant amount of memory
03:58:58 <tolkad> We could use this for data compression!
03:59:50 <twb> tolkad: unix has that, it's called /dev/null
04:12:54 <Jafet> Many unix programs often store your valuable data that way
04:13:47 <tolkad> really? thanks I'm going to move my backups there
04:14:59 <twb> tolkad: it's Θ(1) time
04:19:12 <qfr> http://qthaskell.berlios.de/
04:19:15 * qfr sighs
04:19:22 <qfr> Why does it say Theta tau?
04:19:29 <qfr> Is that supposed to say Qt? :/
04:19:34 <opqdonut_> oh my
04:19:37 <opqdonut_> :/
04:20:48 <qfr> The closest you could get is probably by using the old Greek Qoppa but that guy probably just switched to the Greek key mapping and hit Q on his keyboard and it spat out a theta.
04:20:56 <qfr> Ϙτ
04:21:10 <qfr> http://en.wikipedia.org/wiki/Qoppa
04:21:28 <Xilon> Or you could use "Qt"
04:21:46 <qfr> Xilon: Yeah.
04:22:00 <merijn> Xilon: Lies!
04:31:46 * hackagebot usb 0.6.0.7 - Communicate with USB devices  http://hackage.haskell.org/package/usb-0.6.0.7 (BasVanDijk)
04:49:46 <Renze> Good afternoon!
04:53:40 <Renze> I want to import WashNGo and it looks like as if ghci is looking for modules only the current directory and his sub directory's, instead of looking of installed cabal packages. Is this a possible error?
04:53:55 <Renze> I just reinstalled WashNGo to be sure, btw.
04:56:37 <Renze> I think I found the problem. I also installed ByteString 0.9.1.7 because WashNGo uses it and he complained about that and now -v says things like this:
04:57:09 <Renze> package zlib-0.5.2.0-7acfb4dd7cb77e3a4b5beb3b9b160b08 is unusable due to missing  or recursive dependencies:   bytestring-0.9.1.7-51e73e133c8063bf2babc5e12c785cf7
04:58:11 <Renze> Well, that's one step further, Google, here I come! :)
05:10:07 <msieradzki> http://hpaste.org/42743/vector how do I make common class for Vector2,Vector3 and Vector4 parametric over type of number in it?
05:10:56 * hackagebot happy-meta 0.2 - Quasi-quoter for Happy parsers  http://hackage.haskell.org/package/happy-meta-0.2 (JonasDuregard)
05:12:54 <nostrand> msieradzki: you could use an array, list or something
05:12:57 * hackagebot alex-meta 0.2 - Quasi-quoter for Alex lexers  http://hackage.haskell.org/package/alex-meta-0.2 (JonasDuregard)
05:13:05 <msieradzki> no I want tuple-like type
05:13:14 <msieradzki> it also has to be Vector2/3/4 from Data.Tensor
05:13:19 <nostrand> ok, then i don't know
05:13:39 <msieradzki> multi param type class seems to compile, checking if it does what I wanted
05:13:57 <msieradzki> ok, it doesn't :)
05:15:00 <msieradzki> inference gets lost
05:15:59 <msieradzki> with fun deps it kind of does what I wanted
05:16:47 <msieradzki> http://hpaste.org/paste/42743/vector_annotation#p42744
05:17:15 <msieradzki> isn't it a bit too much type machinery for simple constant-sized vectors with +/-/*?
05:17:37 <quicksilver> your fundep prevents you making an instance for Vectorable Vector3 Double
05:17:40 <quicksilver> is that what you wanted?
05:17:46 <msieradzki> ok, that's stupid
05:18:15 <quicksilver> I don't understand what you're trying to do.
05:18:43 <quicksilver> why not class Vector v where (<+>) :: v -> v -> v
05:18:45 <quicksilver> (for example) ?
05:18:46 <msieradzki> that instance is wrong - what I want to achieve is <+> and other ops that work on Vector2
05:19:04 <msieradzki> Vector2 Float, Vector2 Double, Vector3 Float, ...
05:19:27 <quicksilver> yes, you could then instance Num a => Vector (Vector2 a)
05:19:30 <quicksilver> and also Vector3.
05:20:00 <quicksilver> oh, because of *> and scalars.
05:20:18 <msieradzki> yes
05:20:27 <quicksilver> then try : class Vectorable (v :: *) (k :: *) | v -> k
05:20:36 <quicksilver> (*>) :: v -> k -> k
05:20:37 <quicksilver> (etc)
05:20:48 <quicksilver> erm v -> k -> v I mean
05:21:24 <cheater99> hi
05:21:37 <msieradzki> but then I get class Vector that needs instance per (vector-type, float-type) tuple :)
05:21:50 <cheater99> i want to have a function f :: a -> a which is id for all typeclasses, except for Num a, in which case f x = 2 x
05:21:58 <cheater99> how do i do this?
05:21:59 <quicksilver> msieradzki: no you don't
05:22:10 <cheater99> somehow put a typeclass in guards? is that possible?
05:22:16 <quicksilver> msieradzki: instance Num a => Vectorable (Vector2 a) a
05:22:37 <quicksilver> cheater99: you can't do that.
05:22:55 <quicksilver> cheater99: f :: a -> a must be universally polymorphic over all a.
05:23:07 <cheater99> what does "universally polymorphic" mean?
05:23:23 <quicksilver> it means it must use the same implementation for all types a.
05:23:42 <quicksilver> it can't do different things for different types - there is no "type-case"
05:23:44 <cheater99> can i not overload in haskell?
05:24:18 <quicksilver> You can overload in haskell.
05:24:22 <Xilon> cheater99: You can use a type class, although that would make it recursive in a sense :P
05:24:33 <cheater99> how?
05:24:39 <cheater99> quicksilver: also, how?
05:24:45 <quicksilver> how what?
05:24:49 <quicksilver> how can you overload in haskell?
05:25:03 <quicksilver> class Foo a where foo :: a -> Int {- foo is overloaded -}
05:25:13 <quicksilver> typeclasses are type-checked overloading.
05:27:13 <merijn> I think he just wants: "class Foo a where foo :: a -> a" with default implementation "foo = id" and then for "foo = (2*)" for Num a. Should be possible, but quite tedious...
05:28:04 <merijn> Unless there is a quick way to define a lot of datatypes to be instances of Foo...
05:28:46 <quicksilver> Certainly there is. You're using a computer, computers are designed to automate repetitive tasks ;)
05:29:06 <quicksilver> (but you have to pre-process or use TH; and there is no authoritative "list" of all Num types to start from)
05:29:12 <merijn> I don't suppose you can case on the type of an expression?
05:30:38 <cheater99> yes merijn, that is exactly what i want
05:31:03 <merijn> Pretty sure you can do neat stuff like that in Coq/Agda, but not sure about Haskell :p
05:31:11 <Renze> How can I see the installed modules? ghc-pkg list gives the packages, but I need to know certain names of the modules of the packages
05:31:15 <hpc> i seriously doubt it is possible in Haskell
05:31:26 <cheater99> what if i just want to have a special case for Int a?
05:31:29 <aavogt> cheater99: http://www.haskell.org/haskellwiki/GHC/AdvancedOverlap
05:31:40 <cheater99> that should be simpler, right?
05:31:53 <merijn> cheater99: How big is the number of types you want to call the function on?
05:32:03 <j-invariant> ;3;3
05:32:42 <cheater99> all types
05:32:57 <Xilon> cheater99: Yes, merijn already gave you 80% of the code
05:33:28 <quicksilver> overlapping instances are broken by design, of course.
05:34:02 <cheater99> Xilon: correction: he said something that you recognize as a vague hint on how to construct the code with your amount of experience. i'm not very good with haskell myself.
05:34:17 <merijn> cheater99: Do you understand typeclasses?
05:34:23 <merijn> If not, read up on those first
05:34:27 <cheater99> merijn: somewhat
05:34:38 <cheater99> merijn: i'm still in the learning process i guess
05:34:55 <merijn> @where lyah
05:34:56 <lambdabot> http://www.learnyouahaskell.com/
05:35:08 <cheater99> yeah, i'm reading that
05:35:33 <cheater99> i'm far past typeclasses but i don't have a fully confident grasp of them yet :p
05:35:37 <aavogt> quicksilver: you can't avoid overlapping instances even with a preprocessor (doing "class Foo a where foo :: a -> a" with default implementation "foo = id" and then for "foo = (2*)" for Num a." ), right?
05:35:38 <merijn> cheater99: Check out typeclasses (chapter 3), once you understand how to write your own my hints should start making sense. So read that first, then come back if its still unclear
05:36:00 <cheater99> i've read that already
05:36:02 <quicksilver> cheater99: the short answer is "you can't do anything like that, and as you understand typeclasses more you'll understand why not"
05:36:08 <Xilon> cheater99: Neither am I but I know about type classes and default implementations...
05:36:22 <cheater99> Xilon: you're not helping
05:36:24 <ksf_> argh damn little-endianess.
05:36:27 <quicksilver> cheater99: the longer answer is "there are ways to do things a bit like that, but they all have shortcomings and fall short of what you originally asked for, but might be good enough in particular cases"
05:36:33 <merijn> cheater99: So first read it again and see if it makes more sense now :p
05:36:36 <Xilon> cheater99: All you'd need to add is an instance of Int, and you already have the implementation for it
05:36:39 <cheater99> merijn: ok
05:36:42 <ksf_> it'd be only half as bad if there'd be big-endian loads, too.
05:36:53 <aavogt> quicksilver: you're aware of this http://www.haskell.org/haskellwiki/GHC/AdvancedOverlap ?
05:37:03 * hackagebot alex-meta 0.2.0.1 - Quasi-quoter for Alex lexers  http://hackage.haskell.org/package/alex-meta-0.2.0.1 (JonasDuregard)
05:37:05 * hackagebot happy-meta 0.2.0.1 - Quasi-quoter for Happy parsers  http://hackage.haskell.org/package/happy-meta-0.2.0.1 (JonasDuregard)
05:37:06 <quicksilver> aavogt: you don't need an overlap if you explicitly make an instance for all types you're interested in (Num or otherwise)
05:37:14 <quicksilver> aavogt: certainly I am. Overlapping instances are broken (by design).
05:37:25 <merijn> aavogt: Sure you can avoid overlapping instances, you "just" need to enumerate all types by hand before compiling :>
05:37:50 <quicksilver> overlapping instances are an experiment which will (IMO) never become haskell, because they break the theoretical underpinnings of type classes.
05:38:21 <aavogt> well doing things that way lets you express one instance for "types in Num", and another for the rest
05:38:21 <merijn> quicksilver: If you code does not use at least 3 features which break the language it is not worth writing :D
05:38:43 <cheater99> ok, i've just gone through all of it, and none of the syntax has helped me any further
05:38:50 <dolio> If we ever get closed classes, they'll probably be overlapable.
05:39:15 <cheater99> merijn: are you saying it's possible to have a function f x which is id for all types of a except for int when it's f x = 2*x?
05:39:52 <quicksilver> dolio: closed classes would no longer be typeclasses in the haskell sense, IMO. Not to say they might not be useful/interesting.
05:40:11 <Xilon> cheater99: Yes
05:40:16 <cheater99> how do i do that?
05:40:19 <merijn> cheater99: A typeclass declares a number of functions with a certain type signature. For example "==" is declared in the Eq typeclass and is defined as "(==) :: a -> a -> Bool"
05:40:34 <aavogt> quicksilver: if you don't export the classes, (the actual method definitions; that is    module M (C,c) where class C a where c_ :: a; c = c_) is it still possible for somebody to break the fragile overlappage?
05:40:42 <Xilon> cheater99: http://learnyouahaskell.com/making-our-own-types-and-typeclasses#typeclasses-102 that should explain how to define it. "Typeclasses 101" explains what they are though.
05:41:00 <cheater99> ok, i have only read chapter 4
05:41:04 <dolio> quicksilver: They're a bit against the underlying point of type classes. Closed type families make somewhat more sense, and it's conceivable that they'd go together.
05:41:05 <merijn> cheater99: Now I can define something to be an instance of Eq by saying "type X is an instance of Eq and this is the actual function "==" for this data type"
05:41:07 <cheater99> erm, 3 (4 too, but it's unrelated)
05:41:25 <cheater99> chapter 3 introduces typeclasses, i thought this is what merijn was asking about
05:41:27 <j-invariant> MEGA = unsafePeformIO . unsafeCoerce
05:41:34 <j-invariant> I've the best haskell program
05:41:53 <dolio> Although, I don't know how tied together the type class and type family code is.
05:41:53 <aavogt> looks redundant j-invariant
05:42:23 <Xilon> cheater99: Sure, that's the what and you should read it before reading chapter 8 (the how).
05:42:34 <cheater99> ok
05:42:48 <cheater99> i have noticed that for example "read" seems to have multiple implementations
05:42:59 <merijn> cheater99: Now typeclasses allow you to specify a default implementation of the functions in the typeclass. Now you were asking for a typeclass containing one function of type "a -> a". The default you want is obvious "id", so you specify that as default and you're done. For Int's you wanted "f x = 2*x" which is also easy "(2*)". The problem is now that you'd need to manually make all the types you want part of the new typeclass you made
05:43:25 <quicksilver> dolio: of course, having types exist as values (and be comparable) would let you do all kinds of type-case hackery at the value level, and it's quite possible that haskell will move in that direction.
05:43:36 <cheater99> merijn: oh
05:43:47 <j-invariant> quicksilver: would that break parametricity?
05:43:49 <quicksilver> dolio: however, such type-case hacks would be a disadvantage of such progress, in my opinion ;)
05:43:53 <cheater99> merijn: can't i just say "all types are part of this typeclass" ?
05:44:00 <quicksilver> j-invariant: type-case would, yes.
05:44:15 <quicksilver> j-invariant: whether types-as-values breaks parametricity is more subtle, I think.
05:44:19 <j-invariant> would you have to have all data types defined?
05:44:35 <quicksilver> j-invariant: it depends on what type you give 'typeof' and various other things, I think.
05:44:54 <sipa> couldn't you do something with existential types + typeable?
05:45:08 <hpc> that's what i would use
05:45:29 <hpc> i probably don't know enough about the issue to make good choices on these matters though
05:47:01 <Xilon> cheater99: That's over my head. I don't think even ghc is able to know about all types (since your code could be a library used in some app that defines other types)
05:47:12 <quicksilver> sipa: you can't use typeable to tell you if something is a member of Num, though
05:47:28 <quicksilver> sipa: you'd need something "like" typeable to record type class membership too
05:47:30 <merijn> cheater99: http://hpaste.org/42745/typeclass_example
05:47:36 <sipa> quicksilver: true
05:47:43 <quicksilver> ...all that having been said, "Yes", something like Typeable would work.
05:48:12 <merijn> cheater99: No, you can't (right now) say "all types are part of this typeclass". That's the problem
05:48:19 <Xilon> merijn: hah, I didn't know you can "group" instances like that!
05:48:43 <merijn> Xilon: How do you mean?
05:48:52 <cheater99> haskell has at any time a finite amount of typeclasses, right?
05:49:01 <sipa> yes
05:49:01 <Renze> How can I see the installed modules? ghc-pkg list gives the packages, but I need to know certain names of the modules of the packages.
05:49:12 <Xilon> merijn: Defining two instances at once (String and Int)
05:49:15 <sipa> but the number of types they apply to can be infinite :)
05:49:25 <merijn> Xilon: It's just two separate declarations
05:49:38 <merijn> String doesn't need a "where" clause
05:49:50 <Xilon> Ahh, thought it was defining foo = (2*) for both... just the formatting :P
05:49:52 <merijn> Because foo is already defined for String (its "id")
05:50:03 <quicksilver> merijn: you can say "all types are part of this typeclass"
05:50:15 <quicksilver> merijn: you are just restricted to rather boring instance bodies, in that case.
05:50:22 <quicksilver> instance Foo a where ....
05:50:28 <quicksilver> (makes all types 'a' an instance of Foo)
05:50:41 <quicksilver> requires -XFlexibleInstances, but that's a non-controversial extension.
05:50:48 <merijn> quicksilver: Yeah, but then you can't redeclare it for a specific type, no?
05:50:52 <quicksilver> right.
05:51:03 <quicksilver> without overlapping instances, as already discussed.
05:51:06 <merijn> Which kinda defeats the purpose :p
05:52:51 <Renze> Is Distribution standard in ghci?
05:53:18 <Bynbo7> ghcI?
05:53:26 <Renze> ghc I meant
05:57:03 <mux> Quick poll: with or without trailing dots in the 'Synopsis' line of a .cabal file?
06:04:45 <quuuux> @unpl (.) . (.) $ return
06:04:46 <lambdabot> (\ b c f -> return (b c f))
06:04:59 <cheater99> sipa: thanks
06:04:59 <quuuux> the Blinky combinator continues to astound me
06:06:05 <cheater99> blinky combinator?
06:06:30 <cheater99> mux: can you give an example for both?
06:06:50 <mux> hackage is full of examples
06:06:56 <cheater99> ok
06:07:04 <mux> http://hackage.haskell.org/packages/archive/pkg-list.html
06:07:27 <Renze>     bytestring-0.9.1.7-75016763ffc2bd29aa246771e4e8f1bd is shadowed by package b ytestring-0.9.1.7-51e73e133c8063bf2babc5e12c785cf7 how is this possible?
06:08:36 <knobo> Question to: https://github.com/snoyberg/haskellers/blob/master/Haskellers.hs#L484 , what does the $ sign mean in that line? is it a bug/typo?  
06:09:16 <quicksilver> knobo: TH
06:09:18 <quuuux> Renze: two different binary packages
06:09:34 <Renze> How can I get rid of one of them, quuuux?
06:09:41 <knobo> quicksilver: what does i mean?
06:09:50 <quicksilver> knobo: it runs some code at compile time
06:10:01 <quicksilver> knobo: in this case, something to do with hamlet templates
06:10:11 <quuuux> Renze: I'm not sure if there's a -precise- way to do it, but I ran in to a similar problem earlier. I took the nuclear option of removing the offending packages completely and rebuilding
06:10:28 <knobo> quicksilver: where can I learn more about that?
06:10:39 <Bynbo7> @google template haskell
06:10:40 <lambdabot> http://en.wikipedia.org/wiki/Template_Haskell
06:10:40 <lambdabot> Title: Template Haskell - Wikipedia, the free encyclopedia
06:10:41 <Renze> well, removing a package is not really possible via cabal, is it?
06:10:52 <Renze> So I guess I should remove it via ghc-pkg?
06:10:54 <Bynbo7> Renze: you remove it via ghc-pkg
06:12:53 <Renze> and after that, just install it again via cabal?
06:48:20 <dpratt71> how do I direct something to preflex? can't remember
06:48:51 <Zao> ,seen dpratt71 
06:48:55 <Zao> Hrm, no.
06:49:18 <dpratt71> preflex: @seen dons
06:49:18 <preflex>  dons was last seen on #haskell 2 days, 11 hours, 23 minutes and 39 seconds ago, saying: and ghc will pick the right number (on most platforms)
06:49:35 <dpratt71> well, I guess that should have been obvious
06:57:54 <quuuux> is there a sane way of breaking up cycles of typeclasses that mutually depend on each other? I have typeclasses called Event, Room, Reference and GameObject in my MUD code that mention each other and they're making this one file huge
06:59:16 <JuanDaugherty> MUD?
06:59:44 <quuuux> Multi User Dungeon. I'm perverse and writing one in Haskell :)
07:00:04 <JuanDaugherty> thought so
07:01:10 <JuanDaugherty> yello khisanth, are you the xchat Khisanth ?
07:01:26 <Khisanth> yes
07:01:36 <JuanDaugherty> ah
07:02:09 <Khisanth> just forgot to change nicks before reconnecting :)
07:04:11 <taotree> In the following, is there some way to remove the requirement of the type annotation?
07:04:11 <taotree> prices1 = (zip [1.0..100.0] (scanl (+) 100.0 $ moves)) :: [(Double,Double)]
07:04:11 <taotree>     where moves = randomRs (-1.0, 1.0) $ mkStdGen 0
07:06:52 <ski> i don't see why there would be any requirement for a type ascription in the first place ..
07:06:58 <ski> @type let prices1 = (zip [1.0..100.0] (scanl (+) 100.0 moves)) where moves = randomRs (-1.0, 1.0) (mkStdGen 0) in prices1
07:07:00 <lambdabot> forall t b. (Enum t, Fractional t, Random b, Fractional b) => [(t, b)]
07:07:22 <ski> oh right, DMR i suppose
07:07:27 <taotree> DMR?
07:08:04 <taotree> I'm using the Chart package--generating random numbers for plotting. It gives error if I don't specify the double,double
07:08:10 <ski> the Dreaded Monomorphism Restriction
07:08:22 <taotree> yes, that's the error :)
07:08:39 <ski> what is the error you get ?
07:09:24 <taotree> error: http://pastebin.com/icLx22qy
07:12:05 <ski> ok, so try adding
07:12:08 <ski>   {-# LANGUAGE NoMonomorphismRestriction #-}
07:12:14 <ski> to the top of your file
07:12:35 <taotree> ok. Thanks.
07:13:23 <LeCamarade> I have the latest Cabal, but with 7.0, I get the following when I run cabal install network: cabal: failed to parse output of 'ghc-pkg dump'
07:13:35 <LeCamarade> I had a GHC 6.10 before.
07:13:41 <LeCamarade> Qhat fe do?
07:13:51 <ski> if that doesn't help, then i think you need some ascription to resolve the ambiguity (or else a `default' declaration .. but i'd try to avoid that)
07:19:47 <pastorn> ok, so if i use ForkIO, is that a new thread?
07:19:58 <opqdonut_> a new OS thread, yes
07:20:08 <pastorn> because SDL says that i have to do lots of stuff from the same thread
07:20:15 <pastorn> and i want to wait on multiple
07:20:44 <pastorn> i was thinking having two chan which both blocks on some event, then unify those into one chan
07:20:59 <pastorn> but both of the event pollers needs to be executed by the same thread
07:21:07 <pastorn> am i screwed here?
07:21:16 <LeCamarade> I have the latest Cabal, but with 7.0, I get the following when I run cabal install network: cabal: failed to parse output of 'ghc-pkg dump'
07:21:18 <LeCamarade> I had a GHC 6.10 before.
07:21:23 <LeCamarade> What fe do?
07:21:50 <pastorn> LeCamarade: you need to get cabal-install from the darcs repository
07:22:12 <pastorn> i installed ghc7 this weekend, basically i did this:
07:22:42 <burp> easy way is probably to remove ~/.ghc ;)
07:22:51 <pastorn> 1) install ghc7, 2) rm -rf ~/.cabal ~/.ghc 3) darcs get wherevercabalis 4) sh bootstrap.sh
07:22:59 <burp> or just the package cache
07:23:55 <pastorn> But is there some way to wait on multiple, but using only one thread?
07:24:01 <Saizan> no need to rm .cabal or .ghc
07:24:01 <pastorn> (without polling)
07:24:21 <pastorn> Saizan: what about the old compilers object files etc.?
07:24:34 <pastorn> or however imports are handled...
07:24:45 * hackagebot sphinx 0.4.0 - Haskell bindings to the Sphinx full-text searching deamon.  http://hackage.haskell.org/package/sphinx-0.4.0 (GregWeber)
07:24:58 <Saizan> LeCamarade: which version of cabal does cabal --version show?
07:25:15 <Saizan> pastorn: they don't interfere
07:25:33 <LeCamarade> Ah!
07:25:34 <LeCamarade> cabal-install version 0.6.2
07:25:34 <LeCamarade> using version 1.6.0.3 of the Cabal library 
07:25:47 <LeCamarade> Saizan: Hmm. Interesting!
07:26:15 <pastorn> Saizan: but probably it's better to remove the old stuff, save disk space etc
07:26:15 <Saizan> LeCamarade: maybe you've two cabal executables around
07:26:46 <pastorn> Saizan: my ~/.cabal/lib is 148 MB
07:26:48 <LeCamarade> But where would the other one have gone to?
07:27:03 <quicksilver> pastorn: don't try to use only one thread; use many threads but send all the IO actions to be excuted in the SDL thread to that thread.
07:27:07 <LeCamarade> I even did cabal install cabal-install after building one from the site.
07:27:18 <LeCamarade> (Or shouldn't I have?)
07:27:23 <quicksilver> pastorn: one design is for the SDL thread to just be reading on a Chan(IO ()) of things to run.
07:27:40 <Saizan> LeCamarade: $HOME/.cabal/bin probably
07:27:48 <Saizan> LeCamarade: the installation log would tell you
07:28:31 <pastorn> quicksilver: yes, i've thought of that but i still have trouble
07:28:39 <pastorn> quicksilver: so basically i have this:
07:28:53 <pastorn> forever (SDL.waitEventBlocking >>= writeChan evChan)
07:29:12 <pastorn> as the last line in my initialization code
07:29:52 <pastorn> i don't see how i can get immediate execution on anything going onto a Chan (IO ()) and still poll without doing polling
07:30:07 <pastorn> (polling as in the non-busy-waiting kind)
07:30:12 <LeCamarade> Nope, even that one is 0.6.2. Lemme re-install the big guy.
07:32:39 <Saizan> make sure you are installing the right version
07:33:23 <pastorn> quicksilver: any ideas?
07:34:39 <quicksilver> pastorn: you have to use the SDL idle callback, I believe.
07:35:04 <quicksilver> and possibly an MVar to signal if your channel is non-empty
07:35:30 <pastorn> awww... i was hoping to do that without using any provided callback systems
07:37:51 <quicksilver> pastorn: I don't think there is a workaround for the fact that your main loop is 'controlled' by SDL
07:37:52 <LeCamarade> Saizan: I have re-install cabal 1.8, and still it does not show up. :-(
07:38:34 <Saizan> LeCamarade: you also have to compile cabal-install against it
07:39:25 <arkrost> Hi! for example I have foo :: IO (String -> String). how I can use foo?
07:40:19 <Zao> arkrost: Either by binding it with <- in a do block to get a String -> String, or by slipping it into a sequence of >>= and friends.
07:40:30 <koala_man> do { lulz <- foo "bar"; putStrLn lulz; } 
07:40:40 <Zao> koala_man: Not really.
07:40:49 <Zao> koala_man: It's IO (String -> String), not String -> IO String.
07:41:05 <koala_man> eek.
07:41:25 <Zao> do { f <- foo; print (f "lol" "wtf") }
07:41:25 <pastorn> quicksilver: how can i +
07:41:46 <pastorn> ehm.. scratch that... i don't use any sdl main loop stuff
07:41:52 <pastorn> and sdl doesn't have any callbacks to be set
07:43:39 <pastorn> quicksilver: hmm.. i think i have a workaround, tell me what you think:
07:45:43 <pastorn> forever (pollEvent >>= writeToChan eventChan >> isEmptyChan ioChan >>= \ready -> when ready (readChan ioChan) >> threadDelay (secondsToMicro (1/60)))
07:46:42 <pastorn> pollEvent being a non-blocking event poller
07:53:39 * djahandarie usually switches to do notation by the point where you have multiple >>= and >> with lambdas
07:54:11 <Polarina> Why doesn't the STM monad have an Applicative instance?
07:55:02 <pastorn> And why isn't stm in base?
08:00:50 <augur> any interesting new type systems worth looking at?
08:01:25 <medfly`> lol
08:01:50 <Hilbert> Hey I get getting the error Prelude. (!!): index too large
08:02:24 <nostrand> Hilbert: !! starts with 0, could be that
08:03:26 <qfr> Should I dump git and move to darcs to really Live The Haskell?
08:03:49 <Hilbert> I don't understand why it gives that message after I try and run a compiled program
08:04:52 <sleepynate> qfr: when darcs becomes as fast as git, sure :)
08:05:10 <Saizan> Hilbert: it's a runtime expcetion, it gets thrown where your index is larger than the length of the list
08:05:19 <sleepynate> qfr: i actually prefer the "niceness" of darcs, but one must admit it's behind on features and speed.
08:06:21 <Silvah> sleepynate: last time I checked, git was horribly slow (at least on Windows), so... is darcs really even slower?!
08:06:51 <Hilbert> Salzan: When I run the code in ghci in ghci I don't get the error, but when I compile it I get the error
08:07:02 <Cale> Hilbert: Let's take a look at your program
08:07:10 <Cale> paste it on hpaste.org or something :)
08:09:46 <Phantom_Hoover> Who's the guy who wrote Learn You a Haskell?
08:10:41 <byorgey> Phantom_Hoover: BONUS 
08:11:17 <Hilbert> Cale: http://pastebin.com/2GVtQZCg
08:11:39 <Phantom_Hoover> BONUS, I was very disappointed that the name of the "Zippers" chapter in Learn You A Haskell wasn't based on "The Good, the Bad and the Ugly".
08:12:00 <younder> zip
08:12:19 <BONUS> haha
08:12:20 <lambdabot> BONUS: You have 2 new messages. '/msg lambdabot @messages' to read them.
08:12:26 <BONUS> The Good, the Bad and the Zipper?
08:13:01 <Cale> Hilbert: okay, so I get the error in ghci
08:13:07 <younder> Haskel the zipper
08:13:19 <Phantom_Hoover> BONUS, dunno.
08:13:24 <Phantom_Hoover> The Zipper with no name?
08:13:30 <Hilbert> Cale : In ghci comment out the main and remove the -- before the blah function
08:14:12 <Cale> Exactly the same behaviour
08:15:00 <Hilbert> Cale: Oh, can you see where I am going wrong?
08:15:10 <byorgey> Hilbert: the filter is going to go on checking successive values of x forever, but the facs list is finite
08:15:25 <byorgey> so eventually it is going to use a value of x which is too big
08:16:37 <Cale> Well, the problem is that you're demanding arbitrarily large indices of a finite list
08:16:50 <Cale> [1..] is unbounded, but take size $ scanl ... is finite
08:17:19 <Phantom_Hoover> How does one request that lambdabot join another channel?
08:17:19 <Cale> as is the array, so even if you make the list infinite, you'll immediately be bit by an array index out of range error
08:17:25 <Cale> Phantom_Hoover: Ask me
08:17:45 <Phantom_Hoover> Cake, can we have lambdabot in #esoteric?
08:17:52 <Silvah> Cale*
08:18:17 <Silvah> Pretty amusing typo, though :D
08:18:26 <Hilbert> Cale: Is it possible to avoid those errors but still get the program to do what I want it to do
08:19:11 <quuuux> haskell.org/bz/thdoc.htm and haskell.org/bz/th3.htm are dead links. Those things were like the best cheat-sheet for TH
08:20:56 <Cale> Phantom_Hoover: sure
08:21:04 <Cale> Hilbert: Yeah, I think so :)
08:21:20 <Cale> Hilbert: Just need to be checking that the index is low enough to look up in your memo table
08:21:25 <augur> byorgey: i still say inverse "species" are possible
08:21:28 <quuuux> oh, archive.org to the rescue!
08:22:02 <augur> :P
08:22:04 <Hilbert> Cale: Where can I add that check?
08:22:05 <Cale> Hilbert: Or else you'll need to be careful never to demand too large an index.
08:22:09 <Phantom_Hoover> Cale, (oops, that's an l) thanks.
08:23:18 <Cale> lambdabot: @join #esoteric
08:23:31 <sleepynate> Silvah: I can't speak for its alacrity or otherwise on windows, but from my experience on large codebases, darcs is exponentially slower.
08:23:37 <Cale> Phantom_Hoover: btw, do you want to make it autojoin that channel?
08:23:47 <Cale> Hilbert: Well, for fac it's easy enough.
08:23:53 <Phantom_Hoover> Cale, it'd be appreciated.
08:25:00 <Cale> Hilbert: fac x | x < size = facs !! x   | otherwise = product [1..x]  -- (or whatever)
08:25:09 <Phantom_Hoover> Cale, i.e. yes.
08:25:15 <Cale> Phantom_Hoover: done :)
08:25:23 <shachaf> Wait, why is lambdabot in #esoteric? Is that some sort of subtle insult?
08:25:27 <Phantom_Hoover> Cale, yaaaaaay!
08:25:35 <djahandarie> lol
08:25:36 <Cale> This reminds me, I need to add TupleSections for copumpkin
08:25:37 * Phantom_Hoover kisses Cale's boots.
08:26:46 <quicksilver> Cale: copumpkin is another bot you control? I never knew.
08:26:51 <Cale> heh
08:26:53 <quicksilver> he's so realistic sometimes.
08:27:04 <Cale> haha
08:27:23 <Cale> He just asked me to add -XTupleSections to the flags
08:28:14 <Hilbert> Cale: Thanks the purpose of facs is the generate a list of the values of the factorial function in asceding order though
08:28:38 <Cale> Hilbert: right
08:28:49 <Cale> Hilbert: You could also just make that an infinite list, if you don't mind the memory
08:29:56 <Hilbert> Cale: The purpose of the program is to find the values of n for which a certain prediciate holds
08:31:31 <burp> Cale: can you put lambdabot also in #teamunix while you're just on it?
08:31:34 <Cale> Hilbert: I recognise they're the partition numbers :)
08:31:41 <Cale> burp: sure
08:31:46 <burp> thanks
08:31:53 <Cale> lambdabot: @join #teamunix
08:32:26 <burp> > 1+1
08:32:27 <lambdabot>   mueval-core: Prelude.read: no parse
08:32:36 <burp> broken?
08:32:36 <pastorn> BONUS: Zip 'Em High
08:32:50 <mm_freak> @undef
08:32:51 <Hilbert> Cale: Indeed there are, I am using Euler's pentagonal number theorem which gives rise to a useful recurence relation. I don't see why my program doesn't return a list though 
08:32:57 <mm_freak> > 1+1
08:32:58 <lambdabot>   mueval-core: Prelude.read: no parse
08:33:45 <quicksilver> > 2+2
08:33:46 <lambdabot>   mueval-core: Prelude.read: no parse
08:33:52 <Cale> hmm
08:33:55 <quicksilver> > "4"
08:33:56 <lambdabot>   mueval-core: Prelude.read: no parse
08:34:05 <quicksilver> @quote Cale
08:34:06 <lambdabot> Cale says: What we need are monad tutorial transformers. // So that we can compose the features of monad tutorials
08:34:10 <Cale> yeah, definitely something went wrong when I rebuilt lambdabot just now
08:34:31 <djahandarie> Seems to be a mueval problem rather than lambdabot
08:34:43 <quuuux> we can rebuild him; we have the technology
08:34:46 <Cale> yeah, I wonder if mueval doesn't understand -XTupleSections
08:35:00 <elliott> Cale: Can we get Caleskell back?
08:35:00 <elliott> I miss (.)'s type.
08:35:12 <Phantom_Hoover> Caleskell?
08:35:18 <Cale> Did (.) ever change back?
08:35:18 <elliott> Phantom_Hoover: Caleskell!
08:35:20 <elliott> The best language!
08:35:25 <elliott> Cale: Oh, perhaps not. Maybe map did?
08:35:32 <djahandarie> Nothing chanaged back afaik
08:35:38 <Cale> > 1
08:35:38 <lambdabot>   mueval-core: Prelude.read: no parse
08:35:40 <djahandarie> map was never different
08:35:40 <Cale> hmm
08:35:41 <augur> :t (.)
08:35:44 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:35:51 <romildo> @pl \a b -> f a
08:35:52 <lambdabot> const . f
08:36:06 <Cale> okay, this is weird :)
08:36:15 <augur> Cale: you're weird!
08:36:18 <djahandarie> Cale, does mueval work on the command line?
08:36:23 <Cale> yes
08:36:28 <Phantom_Hoover> : is a command character too?
08:36:28 <djahandarie> That is weird
08:36:29 <djahandarie> lol
08:36:50 <djahandarie> Was it working on command line before removing XTupleSections?
08:37:02 <pumpkin> quicksilver: invalid command.
08:37:44 <Cale> oh, perhaps it's a problem with L.hs in the face of TupleSections?
08:37:54 <Cale> yeah
08:37:55 <Cale> hmm
08:38:41 <Cale> ghc bug maybe?
08:39:16 <Cale> > 1
08:39:16 <lambdabot>   mueval-core: Prelude.read: no parse
08:39:22 <Cale> @undefine
08:39:24 <Cale> > 1
08:39:25 <lambdabot>   mueval-core: Prelude.read: no parse
08:39:26 <Cale> hmm
08:39:54 <Cale> yeah, okay, whatever TupleSections
08:40:14 <Cale> I'll just remove it.
08:42:33 <lelf> > "hi"
08:42:43 <lambdabot>   "hi"
08:43:07 <quicksilver> > (1,) 2
08:43:14 <lambdabot>   Illegal tuple section: use -XTupleSections
08:43:23 <quicksilver> Cale: could you enable tuple sections in lamdabot please?
08:43:26 * quicksilver ducks
08:43:51 <Cale> quicksilver: lol
08:44:00 <Silvah> > 1 + 1
08:44:03 <Cale> It was making L.hs fail to parse
08:44:06 <lambdabot>   2
08:44:07 <Cale> and I have no idea why
08:44:24 <burp> it doesn't join all channels at once?
08:44:47 <Cale> burp: It tries to
08:44:56 <Cale> burp: The channel join list is like 100 channels
08:45:01 <burp> oh ok
08:45:05 <shachaf> Cale: What was the updated L.hs?
08:45:18 <Cale> shachaf: I didn't change L.hs
08:45:20 <flamingspinach> lambdabot is in 100 channels!?
08:45:23 <Phantom_Hoover> Cale, which 100 channels?
08:45:30 <shachaf> Cale: Oh, just a flag?
08:45:32 <shachaf> Strange.
08:46:30 <Cale> shachaf: Yeah, just TupleSections
08:47:08 <Cale> aaanyway
08:48:07 <Cale> Hilbert: let's see if we can do something to make your program work better :)
08:48:09 <lelf> maybe it just breaks one of those 60+ imports in L.hs? :)
08:48:31 <shachaf> > (1،) 2 -- Magic!
08:48:33 <lambdabot>   (1,2)
08:48:53 <Cale> shachaf: uhhh... I have no idea why that would work now
08:49:02 <byorgey> haha
08:49:04 <shachaf> Cale: It doesn't.
08:49:09 <Cale> oh, I see
08:49:11 <Cale> hehe
08:49:18 <lelf> > (،،3) 1 2
08:49:19 <Cale> weird comma :)
08:49:19 <lambdabot>   Not in scope: `
08:49:51 <shachaf> @let (،،) z = \x y -> (x,y,z)
08:49:52 <lambdabot>  Defined.
08:49:57 <zygoloid> > (1،2،3)
08:49:59 <lambdabot>   ((1,2),3)
08:50:07 <shachaf> > (،،3) 1 2
08:50:09 <lambdabot>   (3,2,1)
08:50:14 <shachaf> ...Ahem.
08:51:18 <Cale> heh
08:51:21 <shachaf> > let (،،) x z y = (x,y,z) in (،،3) 1 2
08:51:22 <lambdabot>   (1,2,3)
08:51:23 <Hilbert> Cale: I modified it a bit and now it works, but do you know how to make it more  efficent?
08:51:28 <shachaf> There you go.
08:51:53 <lelf> nope
08:52:05 <lelf> > let (،،) x z y = (x,y,z) in (،2،) 1 3
08:52:06 <lambdabot>   <no location info>: parse error on input `)'
08:52:06 <Cale> Hilbert: I would probably start by defining it using nothing but functions, and then make it more efficient using something like the data-memocombinators package.
08:52:41 <Cale> (to memoise parts of the domain of those functions using an array, for instance, with the arrayRange combinator)
08:52:47 <shachaf> lelf: If you're using 3-tuples, you deserve what you get.
08:54:44 <Hilbert> Cale:  I am not familar with that package
08:55:09 <Cale> http://hackage.haskell.org/package/data-memocombinators
08:55:09 * hackagebot fault-tree 0.0.0 - A fault tree analysis library.  http://hackage.haskell.org/package/fault-tree-0.0.0 (TomHawkins)
08:55:17 <Cale> http://hackage.haskell.org/packages/archive/data-memocombinators/0.4.0/doc/html/Data-MemoCombinators.html
08:58:38 <Hilbert> Cale: Thanks but that looks a bit complicated
08:59:48 <Cale> Hilbert: It's usually pretty simple to use. The implementation of data-memocombinators is subtle, but you don't have to worry about it too much.
09:00:30 <Cale> Hilbert: Basically, if you have a function f :: Integer -> Integer, say, then you define g = arrayRange (0,1000) f
09:01:06 <Cale> and automagically g is a version of f which uses an array to memoise the results of f for values 0 through 1000
09:02:25 <Hilbert> Cale: Neat, does arrayRange use much space?
09:02:37 <Cale> It uses exactly as much space as you'd expect :)
09:02:54 <Cale> (the space for the array of values)
09:03:11 <Cale> Note that it'll be a boxed array, and the values will still only be computed if needed.
09:04:02 <Cale> If you're memoising a recursive function, you may want to be careful to use mutual recursion between the memoised and "unmemoised" version of the function.
09:04:24 <Cale> (of course, this will cause the "unmemoised" version to become somewhat memoised itself)
09:04:35 <Hilbert> Cale: I know very little about memorisation
09:04:35 <Hilbert> ]
09:05:51 <Cale> To see what I mean by that, just look at the fib example at the top of the Data.MemoCombinators documentation
09:06:00 <Cale> fib = Memo.integral fib'
09:06:22 <Cale> and then fib' is defined recursively not in terms of fib', but in terms of fib
09:06:34 <Cale> which means that it'll use the memoised results when it can
09:08:01 <Hilbert> Cale: Would that factorial function be more efficent than the facs list I had?
09:08:26 <Cale> Well, the facs list is great, but using !! is not
09:08:52 <Cale> Note that xs !! n takes O(n) steps to reduce.
09:09:02 <cdsmithus> Suppose in parsec that I want to accept all characters until one of a given set of (multi-character) strings occurs.  Is there an easy way to do this?
09:09:13 * hackagebot polyparse 1.4.1 - A variety of alternative parser combinator libraries.  http://hackage.haskell.org/package/polyparse-1.4.1 (MalcolmWallace)
09:09:31 <Hilbert> Cale: Oh lists have linear random access
09:09:35 * djahandarie likes "automagically"
09:09:36 <Cale> Right.
09:09:46 <Saizan> cdsmithus: manyTill, i think
09:09:57 <cdsmithus> Saizan: Thanks, I'll take a look
09:10:07 <foo_> I notice that I keep writing "foldl (flip Set.insert) set list" all over the place. A long time ago I wrote something like "addListToSet set list" and I could of course define that. However is there a more abstract way of doing this? Something along the lines of class Foldable?
09:10:17 <Cale> Hilbert: They're great when you're accessing the elements in a sequential way though.
09:10:57 <Hilbert> Cale: I am in my program, but I don't think I take advantage of that 
09:11:03 <Hilbert> *There are no i AM
09:11:05 <Cale> foo_: Use fromList and union?
09:11:18 <Cale> Hilbert: right
09:11:52 <svdberg> hi
09:12:24 <Cale> Hilbert: So modulo the issue of how to work with the partitions side of things (which I'd have to be finished my first coffee of the day to really think about :), you might be able to get good use out of the infinite list of factorials here
09:12:40 <Cale> svdberg: hi
09:13:44 <svdberg> hi im doing a programming beauty contest and I'm not an Haskell programmer
09:13:50 <svdberg> I came to this: git://gist.github.com/765047.git
09:13:53 <svdberg> t
09:14:09 <Hilbert> Cale: I am using !! to accessing elements of the factorial list is there a better way
09:14:16 <svdberg> the loadAddressBook stil doesnt work, I have someproblems with getting rid of the IO monad there
09:14:17 <djahandarie> svdberg, HTML link?
09:14:21 <Cale> svdberg: I don't know how to open that URL
09:14:23 <svdberg> sec
09:14:32 <svdberg> https://gist.github.com/765047
09:14:41 <Cale> (presumably using git, but I'll feign ignorance ;)
09:14:53 <svdberg> you guys can probably make it much more beautiful :)
09:15:14 <svdberg> was an about an hour work (shame shame)
09:15:34 <Cale> svdberg: (\x -> not (isContact con x)) --->  (not . isContact con)
09:15:37 <djahandarie> svdberg, well, spelling address correctly would probably be a good first step ;)
09:15:51 <Cale> svdberg: (\x -> isContact con x)  -->  (isContact con)
09:16:15 <Cale> also, hmm
09:16:27 <Cale> isContact is just (==), so why not just use (==)?
09:16:54 <Cale> If you were ever to change the representation of the Contact type, you could just implement the Eq class anyway
09:17:07 <djahandarie> loadAddressBook = fmap (map createContact . fromCSV) (parseCSVFromFile path)
09:17:10 <Zao> The type on loadAddressBook seems a bit off.
09:17:36 <djahandarie> Yeah, should be -> IO AddressBook
09:17:57 <svdberg> djahandarie: lol
09:18:02 <Cale> svdberg: This is a subtle point, but try to prefer types of the form A -> B -> B usually over types of the form B -> A -> B
09:18:14 <Zao> djahandarie: For a moment there, I thought he did shenanigans in the list monad with unsafe IO.
09:18:15 * djahandarie agress with Cale 
09:18:27 <Cale> svdberg: The reason for this is that usually partially applying to get a B -> B thing is more useful
09:18:33 <svdberg> Zao: I was fighting around with the IO stuff
09:18:39 <Cale> (because B -> B things all compose with each other)
09:18:43 <svdberg> ahhh
09:18:52 <svdberg> It was kinda funny to do it
09:19:02 <svdberg> Im used to doing Clojure the last year
09:19:10 <djahandarie> svdberg, you need IO *somewhere* in your program, you just need to put it in the right place for things to look nice usually :)
09:19:10 <svdberg> so it's kind of a big switch
09:19:27 <Cale> Then  addContact :: Contact -> AddressBook -> AddressBook; addContact = (:)
09:19:28 <svdberg> djahandarie: how do I prevent the IO monad from going all over my program
09:19:52 <Cale> svdberg: By only using it in places where you're really doing I/O
09:19:55 <djahandarie> svdberg, by only putting it on the "outer layer", and everything in the inner layer being compositions of pure functions
09:20:19 <Cale> svdberg: Are you familiar with model/view/controller (it's okay if you're not :)
09:20:24 <Cale> ?
09:20:28 <djahandarie> main = evilIOValue >>= compose . some . pure . stuff . here . yeay
09:20:28 <svdberg> Cale: yes
09:20:58 <svdberg> so in do notation its: d <- evilIOAction
09:21:01 <svdberg> and then?
09:21:03 <Cale> svdberg: Think of (perhaps just part of) the view and controller as being in IO, and the model being pure.
09:21:45 <Cale> do x <- getInputFromUser; let y = pureFunction x; doSomeOutput y
09:22:08 <Cale> (that's really oversimplified and schematic, but you should get the idea :)
09:22:16 <djahandarie> Cale, so you mean the the view and model are in IO, while the controller is pure? :P
09:22:23 * djahandarie doesn't think this analogy really works
09:22:28 <Cale> djahandarie: what?
09:22:36 <Cale> djahandarie: No, the view and controller are in IO
09:22:40 <Cale> djahandarie: the model is pure
09:22:47 <djahandarie> Wouldn't "getInputFromUser" be the model there?
09:22:53 <Cale> The model is a declarative specification of how to go from inputs to outputs
09:22:56 <Cale> no
09:23:00 <Cale> pureFunction would be the model
09:23:09 <djahandarie> You are using some other usage of the word model than I am
09:23:20 <djahandarie> I'm used to the model being the database interaction layer
09:23:42 <djahandarie> And the controller being the glue between the model and the view
09:23:59 <svdberg> ok thanks for the help
09:27:25 <Cale> I think of the controller as accepting input from various sources and getting that data to the model, the model abstractly specifies how that input translates into various output effects, and the view's job is to render the output from the model and provide any necessary feedback to the controller
09:28:10 <Cale> Maybe that's just not how people think of it anymore...
09:28:14 <romildo> @pl \(a,b) -> a ++ "=" ++ b
09:28:14 <lambdabot> uncurry ((. ('=' :)) . (++))
09:28:47 <djahandarie> I see. I think it has changed for most popular web frameworks these days
09:28:52 <djahandarie> I kind of like your definition better though :P
09:30:42 <Cale> It's possible that the model is just a database, and we can decide what to output for every possible input request just by looking in a database.
09:31:32 <quicksilver> I would say that in a webapp context model = (database + business logic)
09:31:42 <Cale> But updates to the database should probably technically be handled by the controller.
09:31:45 <quicksilver> but often the business logic is limited, or misplaced into the controller.
09:32:10 <Cale> Well, hmm
09:32:36 <Cale> It'll be part of the feedback. The model will decide how to update the data of course.
09:32:59 <Cale> and then the view will get the output from the model and decide what to do with it, so yeah, it'd probably do the update
09:33:55 <Cale> MVC is a bit weird. The IO/non-IO distinction is easier :)
09:35:49 <quicksilver> I think the important concept about MVC is that the V and the C are bother replaceable
09:36:02 <Cale> I suppose *technically* you shouldn't even really be reading from an external changing database inside the model itself -- the controller should handle the reading and pass the results as an input to the model.
09:36:18 <quicksilver> you can replace the V by changing your presentation (e.g. switching from a GTK app to HTML pages)
09:36:51 <Cale> quicksilver: The V and C are rarely independently replaceable though
09:36:55 <quicksilver> agreed
09:36:57 <Cale> (independently of each other)
09:37:10 <quicksilver> but they should be replaceable from the M
09:37:15 <Cale> yeah
09:37:19 <quicksilver> so it's a mistake if you've allowed M-logic to sneak into the C
09:37:21 <quicksilver> (or the V)
09:37:26 <quicksilver> but of course, both mistakes happen.
09:37:59 <quicksilver> I don't actually think it's a very conceptually clear thing (MVC).
09:38:13 <quicksilver> but the basic principle of separating data layer from presentation layer is a good one.
09:40:02 <quuuux> argh. Why does instanceD take [Q Dec], but [d|...|] produces Q [Dec]?
09:53:29 * hackagebot sphinx 0.4.0.1 - Haskell bindings to the Sphinx full-text searching deamon.  http://hackage.haskell.org/package/sphinx-0.4.0.1 (GregWeber)
09:53:29 <quuuux> important lessons learned today: 6 parameters to a typeclass is definitely not too many!
10:21:40 <roconnor> @djin (x -> y -> z) -> (a -> x) -> (a -> y) -> (a ->  z)
10:21:40 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
10:21:46 <roconnor> @djinn (x -> y -> z) -> (a -> x) -> (a -> y) -> (a ->  z)
10:21:47 <lambdabot> f a b c d = a (b d) (c d)
10:21:55 <roconnor> @. pl djinn (x -> y -> z) -> (a -> x) -> (a -> y) -> (a ->  z)
10:21:55 <lambdabot> f = liftM2
10:22:11 <roconnor> yes I know this.
10:22:17 <roconnor> I want it in BCKW form
10:23:22 <pumpkin> lol
10:23:39 <roconnor> is (pure mempty, liftM2 mappend) a monoid?
10:24:14 <roconnor> I guess not
10:24:42 <roconnor> but maybe it is for a communative monad?
10:24:52 <roconnor> like the reader monad?
10:24:52 <pumpkin> :t pure mempty
10:24:53 <lambdabot> forall a (f :: * -> *). (Monoid a, Applicative f) => f a
10:25:34 <pumpkin> you know what is a monoid that doesn't have monoid instances in the standard library?
10:25:41 <pumpkin> I've been meaning to write them
10:25:50 <applicative> roconnor http://hackage.haskell.org/packages/archive/data-aviary/0.2.3/doc/html/src/Data-Aviary-BirdsInter.html phoenix, maybe
10:26:00 <pumpkin> Data.Bits.((.&.), (.|.), and xor)
10:26:27 <pumpkin> applicative: are you the author of that?
10:27:19 <jkr> Probably silly question: why would I ever use the Reader monad instead of a Data.Map, or a function that can read a Data.Map from a cfg file. I've been playing around with Reader, and I understand its use, but I'm still a bit confused as to its use case.
10:27:26 <jkr> Is it mainly to save a parameter in the function definition?
10:27:37 <roconnor> applicative: thanks.  Maybe I'm okay with starlings
10:27:40 <applicative> no way, hah.  phoenix = bluebird (bluebird starling) bluebird
10:27:45 <applicative> starling is S 
10:28:17 <roconnor> jkr: arrays and maps have finite domains.
10:28:25 <quuuux> jkr: getting rid of the parameter can make the code cleaner :) Most of the power in the Reader monad comes out of using it in transformers, though
10:28:27 <applicative> bluebird = starling (kestrel starling) kestrel  kestral is K
10:28:37 <j-invariant>     O HAI, I'M ROGER PENROSE. I'M BASICALLY A MATHEMATICAL SUPER GENIUS SO WHATEVER I SAY GOES. I DON'T NEED SILLY THINGS LIKE EVIDENCE TO SUPPORT MY CLAIMS, BECAUSE WHATEVER I SAY IS SIMPLY FACT. NOW ALLOW ME TO SPEND 500 PAGES BEING ARROGANT AND CALLING AN ENTIRE FIELD WORTHLESS AND WRONG.
10:28:42 <j-invariant> oops :(((
10:28:44 <j-invariant> wrong channel
10:28:50 <pumpkin> lol
10:28:57 <pumpkin> what channel was that intended for?
10:29:02 <j-invariant> esoteric
10:29:02 <dolio> Spot on.
10:29:11 <j-invariant> I copy this off reddit
10:29:12 <quuuux> lolmathematicians: new meme?
10:29:13 <applicative> j-invariant, what is he saying now? It can't be as bad as Hawkings cretinous new book
10:29:18 <roconnor> which field is worthless and wrong?
10:29:29 <jkr> roconnor, quuuux: thanks much.
10:29:31 <j-invariant> applicative: something about human brain being better than turing machines because of godels incompletness
10:29:52 <applicative> ah, a familiar favorite, associated with the name of Lucas
10:30:07 <applicative> the trouble with making fun of it, are the signs that Goedel went for some form of it
10:30:28 <j-invariant> roconnor: not sure, I didn't write ti
10:30:42 * hackagebot cryptocipher 0.2.1 - Symmetrical Block and Stream Ciphers  http://hackage.haskell.org/package/cryptocipher-0.2.1 (VincentHanquez)
10:30:45 <roconnor> j-invariant: I'm tempted to buy him a copy of Inexhaustibiltity: A Non-Exhaustive Treatment by Torkel Franzen.
10:30:55 <applicative> ha, j-invariant, I see, I thought it was the more familiar case.
10:32:05 <roconnor> applicative: I find goedel's work some of the best argument against hard-core platonism and pro-constructivism, but he was definitely a hard-core platonist and pro-classicalist.
10:32:10 <applicative> oh, i'm confused.  You do have the UPPER CASE sentiment
10:32:51 * applicative meant j-invariant
10:33:16 <c_wraith> Yeah, Penrose has asserted the brain is not a turing machine for a while now.  Which is distinctly confusing.  I've never seen *anything* to suggest the human brain is capable of something turing machines aren't.
10:33:27 <applicative> roconnor isn't the kind of thought j-invariant was attacking compatible with, say Brouwerianism.  
10:33:34 <roconnor> c_wraith: have you read his recent books?
10:33:54 <c_wraith> roconnor, No.  I've tried to avoid his writing actually.
10:34:09 <applicative> c_wraith, what about Love?
10:34:11 <dolio> But... quantum magic!
10:34:23 <sw_lasse> Hi, I am new to Haskelll, and I am sitting with a school exercise where the following question is asked: Consider the simple Haskell expression f x. How is this expression evaluated? - I am not sure what to answer here and I would like to learn what is actually going on. I have read something about lazy evaluation, but I dont know if that should come in handy here?
10:34:31 <roconnor> applicative: which line of thought?
10:34:32 <c_wraith> applicative, prove to me that a turing machine isn't capable of love. :)
10:34:51 <dolio> (Don't worry about the fact that quantum computers aren't stronger from a decidability perspective than Turing machines.)
10:35:07 <applicative> the "Goedel has shown no turing machine can match The Mind" line of thought.  
10:35:26 <applicative> roconnor ^^^ this is consistent with e.g. Brouwerism.
10:35:33 <c_wraith> I believe the brain probably is doing some quantum magic.  But yeah, quantum computing isn't more powerful than a turing machine.
10:35:36 <sw_lasse> I have read the the first 4-5 chapters in the online guide written by BONUS, but i might have missed something :)
10:35:41 <sleepynate> sw_lasse: http://www.haskell.org/haskellwiki/Haskell/Lazy_evaluation
10:35:52 <roconnor> oh ya.  That might be consistent with Browerism, but the negation is probably aslo consistent with Browerism.
10:35:59 <roconnor> greanted I'm not a Browerist
10:36:02 <Hilbert> Why doesn't sudo apt-get ghc      work on ubuntu
10:36:03 <roconnor> *granted
10:36:08 <roconnor> I'm a Bishopist!
10:36:31 <sleepynate> Hilbert: because you probably want to "install" ghc
10:36:38 <MrWish> hey
10:36:48 <MrWish> I cant see anyone in the list except for zygoloid
10:36:54 <j-invariant> c_wraith: I they have found quantum mechanical effects in photosynthesis
10:37:02 <Hilbert> sleepnate I meant  sudo apt-get install ghc  It doesn't work
10:37:21 <applicative> roconnor, isn't it consistent with Bishopism?   Isn't Bishop's arithmetic uncompletable, though we can see this etc. etc.  I don't know much about it.
10:37:30 <MrWish> Hey I have a question about using WinGHCi, does anyone use that program here
10:37:44 <quuuux> sw_lasse: that's a pretty deep question. Is that the exact wording?
10:37:56 <Hilbert> sleepnate : It is working now, forgot to put enter install
10:38:01 <sleepynate> :)
10:38:27 <sw_lasse> Thank sleepynate. If the answer concerns lazy eval., would this be the right way to think of it? f obviously has to be evaluated, but f does not nessecarily use x, hence x might not be evaluated at all. So in any case, f will be evaluated first, then x - but x is not nessecarily evaluated.
10:38:29 <MrWish> can anyone hear me
10:38:31 <applicative> MrWish, maybe you should just ask it? Or are you sure it's specific to WinGhci
10:38:39 <roconnor> applicative: yes.  I think the issue is orthogonal to constructism/classicalism and also orhtogonal to platonism/formalism
10:39:33 <sw_lasse> Exact wording:
10:39:33 <sw_lasse> Consider the simple Haskell expression f x. How is this expression evaluated?
10:39:35 <sleepynate> sw_lasse: open up ghci and enter "f x"
10:39:35 <sw_lasse> a) It makes no difference in Haskell, so the implementation may decide.
10:39:37 <sw_lasse> b) Both f and x are always evaluated.
10:39:39 <sw_lasse> c) First x is evaluated, then later f is perhaps evaluated.
10:39:41 <sw_lasse> d) First f is evaluated, then later x is perhaps evaluated.
10:39:43 <sw_lasse> quuuux, ^^
10:39:51 <MrWish> ok its kjinda stupid really... Im doing this haskell tutorial and the part  about type declaration needs me to use this code:
10:39:57 <MrWish>    1. removeNonUppercase :: [Char] -> [Char]  
10:40:04 <Saizan> sw_lasse: your reasoning is correct
10:40:15 <MrWish> well without the 1.
10:40:21 <MrWish> and then the function is defined
10:40:43 <MrWish> how do I execute a code longer than 2 lines lol... when I press enter it runs the code right...
10:41:06 <quuuux> sw_lasse: ah, okay, that's something to work with. If you're not sure about these sorts of simple cases, an expression like 'error "Hi!"' can take any type, and will stop execution as soon as it's evaluated, giving you an idea of what's going on if you test a bit
10:41:26 <dolio> MrWish: In GHCi?
10:41:35 <MrWish> in WinGHCi yes
10:41:52 <dolio> You can write :{ to begin multi-line code.
10:41:56 <dolio> And :} closes it.
10:42:00 <MrWish> oh
10:42:00 <applicative> roconnor, therefore I conclude, maybe Goedel's and Lucas' and Penroses' arguments are good, irrespective of you larger 'philosophy': the brain outdoes all 'Turing machines'
10:42:08 <sleepynate> quuuux: i say sw_lasse should enter "f x" in ghci and see which errors first when they're both undefined ;)
10:42:32 <MrWish> well how do I declare types for a function in WinGHCi
10:42:56 <j-invariant> applicative: oh I have not heard of Lucas
10:43:06 <dolio> > let f :: [Int] -> [Int] ; f = reverse in f [1..10]
10:43:07 <applicative> MrWish:  let foo :: Int -> Int ; foo x = x + 1
10:43:08 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
10:43:26 <MrWish> ohh
10:43:43 <MrWish> you can use semicolumn to separate lines?? D:
10:44:06 <sw_lasse> sleepynate: I see, neat trick :) But the first undefined variable is "x" - to me, that seems as if x is evaluated first?
10:44:26 <quuuux> hmm. Is there any downside to being overly conservative with what modules get .hs-boot files in trying to break up big, complex and interlinked module into smaller ones?
10:44:46 <quuuux> that is, will my compilation times suddenly expontentially explode if I'm not careful?
10:45:39 <applicative> j-invariant, he is supposed to have originated all such arguments. http://en.wikipedia.org/wiki/John_Lucas_(philosopher)
10:45:44 <sleepynate> sw_lasse: interesting... mine looks like this: http://hpaste.org/42747/undefined
10:46:11 <Polarina> Is it possible to have lambdabot join another channel?
10:46:12 <applicative> j-invariant, he was inter alia the teacher of Hoare, who interested him in programming. see http://research.microsoft.com/en-us/people/thoare/ first line
10:46:34 <sw_lasse> sleepynate, by order from the professor we are running Winhugs - I think we will give GHCI a try now :D thanks for your help ;)
10:46:38 <c_wraith> Polarina, yeah.  But you need permissions on the bot that I think only Cale has.
10:46:48 <sleepynate> sw_lasse: condolences
10:47:33 <j-invariant> applicative: btw 
10:47:35 <j-invariant> http://www.1729.com/consciousness/math-journal.html
10:47:45 <taotree> Using ghci, I'm getting runtime error: "Prelude.(!!): negative index"  Is there some way to get it to tell me where in the source that's happening?
10:47:53 <taotree> sorry, that should be using ghc
10:48:54 <sw_lasse> Well, thanks for helping me out quuuux , Saizan and sleepynate - it is really nice to join a channel where people are glad to help :)
10:49:24 <sleepynate> \o/
10:49:56 <applicative> j-invariant, I dont follow this site.  For one thing, termination and non-termination are not to the point.  Goedel's theorems don't need that sort of recursion.  
10:53:06 * lispy unsubscribes from -Cafe -- too much email
10:53:16 <lispy> does anyone else feel like that list is too high volume?
10:53:31 <applicative> lispy, it is not as high as it used to be.  
10:53:33 <gwern> not really. mute works well
10:53:34 <roconnor> lispy: I sort by author and select appropriately
10:53:35 <sleepynate> lispy: do what i do, get a digest then stop reading it after 2 days
10:53:39 <lispy> Is there any logical way to split it?  haskell-things-lispy-wants-to-read haskell-the-rest-of-cafe
10:53:52 <c_wraith> No.  But I'm happy to mark a thread read without actually reading any of it
10:53:56 <edwardk> lispy: sounds good to me ;)
10:54:00 <roconnor> lispy: split it by author
10:54:04 <gwern> lispy: write a SVM classifier and train it on your past 10 years of email!
10:54:08 * applicative takes that back it
10:54:16 <applicative> isn't so clear
10:54:24 <sleepynate> whoa whoa, way better idea
10:54:31 <gwern> it'd be an excuse to write all sorts of haskell programs - from a pop downloader to email parser to SVM to GUI...
10:54:32 <sleepynate> lispy: man up.
10:54:40 <roconnor> j-invariant: that journal is briliant
10:54:55 <roconnor> j-invariant: it really nails the issue
10:55:01 <j-invariant> yeah :)
10:55:23 * gwern isn't sure whether I am joking or not about the SVM. make an awful good blog post to see what an SVM says, anyway
10:56:20 <Hilbert> What flags do I give to ensure a haskell program do not crash untill all swap space has been used up
10:56:39 <gwern> Hilbert: just give it an awful lot of memory?
10:57:03 <Hilbert> I only have 4gb which is not I have a very large swap partions though
10:57:05 <djahandarie> And then it'll only die when the OOM killer eats it
10:57:12 <Hilbert> *not enough
10:57:16 <podlec> hello
10:57:28 <djahandarie> I totally disabled my swap anyways, I like the behavior of the OOM killer more
10:57:46 <gwern> so I guess something silly like +RTS -K99999999999999999999999 -RTS?
10:57:51 <djahandarie> When I go into swap everything just dies for good usually, because my HDD are terrible
10:59:42 <applicative> roconnor, funny, trying to find Goedel's view of the matter, I just came across a Brouwerian Lucasite/Penrosite http://philmat.oxfordjournals.org/content/3/1/86.full.pdf  
11:00:31 <lispy> gwern: mute doesn't do anything for my gmail because I already autoarchive all the messages from -Cafe.  But, having 50 unread threads after 2-3 days still bugs me.  I just can't keep up.
11:00:50 <gwern> lispy: so toss in a filter to mark-read all mutes
11:00:53 <gwern> that's what I did
11:03:49 <applicative> roconnor, j-invariant, if the problem is so simple, how about e.g. this line from Goedel himself, quoted in that paper and hundreds of others "the human mind (even within the realm of pure mathematics) infinitely surpasses the powers of any finite machine, or else there exist absolutely unsolvable Diophantine problems of the type specified [above]"
11:04:09 <benmachine> hmm
11:04:27 <roconnor> applicative: Oh yes, Goedel believe the human mind was more powerful than a Turing machine
11:04:34 <roconnor> but Goedel was crazy!
11:04:40 <Ke> !!
11:04:50 <elliott> hey what
11:04:56 <elliott> how did the conversation spill from #esoteric to here
11:04:58 <elliott> i blame j-invariant
11:05:17 <roconnor> elliott: bingo
11:05:25 <elliott> sneaky!
11:06:08 <augur> elliott!
11:06:34 <benmachine> so, I announced a thing on the haskell@ mailing list, and someone responded to a question CCing -cafe, so I responded the same way, but -cafe rejected my mail because I'm not on that list anymore :(
11:06:45 <benmachine> so my question looks like it is still unanswered!
11:07:08 <gwern> hm, I think Goedel is one of the only valid ad hominems in logic - 'godel said x' 'yes but godel also thought invisible enemies were poisoning his food and starved himself to death'
11:07:43 <benmachine> is there any way I can post to -cafe without deluging my inbox >_>
11:08:02 <benmachine> I guess I could just ignore all the other postings but I don't know if I have the willpower for that
11:08:13 <benmachine> trouble with -cafe is it's too interesting and I need to get stuff done
11:09:52 <j-invariant> applicative: diophantine equations are very interesting actually
11:10:40 <roconnor> programming without laziness is impossible!!1!
11:10:45 <roconnor> arg!!
11:11:06 <applicative> roconnor, j-invariant, yes, but Goedel has a complicated argument in the Gibbs  lecture, I have no idea if it's any good of course. 
11:11:08 <roconnor> I don't want to CPS transform everything.
11:11:46 <lispy> benmachine: you can subscribe and then disable mail delivery
11:12:09 <lispy> benmachine: That's what I do when I want to be able to send mail from work email and personal email on the same list
11:12:39 <benmachine> lispy: ah, sounds clever
11:12:42 <j-invariant> applicative: I will like to read it because I don't have a clue what Godel is saying there
11:12:54 <benmachine> can I then re-send my original email with the same message-id or something
11:13:03 * benmachine vague memories of a way to do this without making duplicates everywhere
11:14:31 <j-invariant> applicative: do you have a link? I don't know what lecture this is
11:24:40 <fryguybob> j-invariant: http://www.ams.org/meetings/lectures/meet-gibbs-lect number 24 I would guess.
11:24:51 <j-invariant> cool, thanks a lot
11:25:43 <lispy> applicative: I ended up going with hevea, BTW
11:25:46 <j-invariant> doesn't seem to be any download for it on google 
11:25:52 <applicative> j-invariant, sorry I got lost... I can't find a separate pdf of the gibbs lecture, here's the books.google version of the Collected Works volume http://preview.tinyurl.com/2dgpu9w
11:26:11 <lispy> applicative: I really need a tool that understands the vast majority of tex/latex
11:26:34 <applicative> lispy, not too surprising; the more I looked into it, the more it was seeming like it was going to be a nightmare. 
11:27:50 <lispy> applicative: work in progress, http://codersbase.com:3000/root-ids.html
11:28:13 <applicative> j-invariant, of course, I was only meaning that supercilious rejections of lucasism seem just as bad as lucasism to me.  
11:28:19 <lispy> applicative: hevea's output validates, but my post processing ruined that and I need to work on the css, and fix the javascript bugs.
11:28:31 * fryguybob might be at the Gibbs lecture this year...
11:29:31 * applicative hopes fryguybob won't have to listen to a moronic blowhard like that Goedel dude....
11:29:33 <j-invariant> applicative: well I am interested in what Godel has to say but I cannot access it
11:31:19 <roconnor> applicative: what is the Gibbs lecture?
11:31:38 <mauke> stayin' alive
11:32:53 <roconnor> applicative: oh I see your answer now
11:36:10 <j-invariant> btw
11:36:50 <j-invariant> when one says "but there is a diophantine equation that is undecidable" they have omitted that it is undecidable relative to some axiomatic theory
11:37:21 <j-invariant> forgetting that can make things very confusing
11:38:16 <j-invariant> I wonder if the Gibbs lecture in on that theme..
11:39:27 <applicative> j-invariant, you can't see http://books.google.com/books?id=gDzbuUwma5MC&pg=PA290&dq=godel++gibbs&hl=en&ei=oXMjTYT1EYH78AbvzdjFDQ&sa=X&oi=book_result&ct=result&resnum=5&ved=0CDgQ6AEwBA#v=onepage&q=godel%20%20gibbs&f=false 
11:39:41 <applicative> sorry, this is off topic anyway, I should go. 
11:40:00 <j-invariant> applicative: I think google shows things relative to your location or whatever - for me this does not show pages of the book
11:40:25 <roconnor> j-invariant: I was about to say, just because a diophantine equation might be undecided by any axiom system a human mind could coneive of (and believe to be consistent) doesn't mean that the diophanite equation isn't true or false.
11:40:48 <j-invariant> roconnor: exactly - I forgot that for a long time and was very confused by it :)
11:41:33 <roconnor> ... I'm not sure why Goedel would write that.
11:41:41 <roconnor> maybe I'm misunderstanding him.
11:46:19 <flamingspinach> what did Goedel write?
11:46:32 <roconnor> j-invariant: have you read http://xorshammer.com/2009/03/23/what-happens-when-you-iterate-godels-theorem/
11:48:29 <j-invariant> roconnor:  no
11:48:42 <roconnor> j-invariant: you should
11:53:27 <monochrom> who needs a blog to find out that Gödel incompleteness sticks around when you try to iterate it? If blahblah is undecidable under X, you can trivially extend to X' and make blahblah decidable, and then X' has some other undecidable things. That is all.
11:53:39 <roconnor> heh.  Function () -> a make a reasonable substitue for IO a in Ocaml.
11:54:17 <roconnor> if I make that () -> ((),a) it even looks like GHC's implementation of IO a.
11:54:48 <roconnor> monochrom: are you being serious?
11:55:24 <monochrom> yes
11:56:31 <roconnor> monochrom: you can do that extension omega number of times, and collect all them together in one axiom system.
11:57:06 <roconnor> and then start extending that until repeatedly until you've made an extension omega*2 times
11:57:22 <roconnor> and you can repeat that again until you've extended it omega*3 times
11:57:34 <Cale> It always confuses me when logicians start speaking of something as being true without reference to which system it's true in.
11:57:40 <roconnor> and repeat this process untill you'v extended it omega^2 times
11:57:52 <roconnor> and so forth for various orndinals
11:57:57 <roconnor> ... except it isn't this easy
11:58:15 <j-invariant> Cale: isn't it normally ZFC, like all mathematics
11:58:16 <roconnor> because you need to encode the ordinals somehow using an ordinal notation
11:58:20 <Cale> "Once we believe that everything PA proves is true..." -- I mean, I guess he means "is true in ZFC"
11:58:25 <dmhouse> Cale: unless it's a tautology!
11:58:39 <Cale> but when there are so many formal systems being thrown around, it'd be nice to be specific
11:58:42 <roconnor> monochrom: and the kicker is: the extension you get depends on the specific ordinal notation you chose to represent the ordinal!
11:59:07 <triyo> I have putStr call that doesn't seem to show when running the main from an executable. It was fine if I run main from ghci,
11:59:17 <roconnor> Cale: he means true in the sense of Tarski.
11:59:20 <flamingspinach> Cale: what? I think he just means "true", no?
11:59:21 <Cale> Sorry "is true in ZFC under the standard interpretation"
11:59:23 <monochrom> something about the 2nd incompleteness theorem says that such an extension still has undecidable things. it doesn't matter how much hard work you did to obtain the extension. it only matter that it can do arithmetic.
11:59:28 <Cale> flamingspinach: What does true mean?
11:59:29 <flamingspinach> i.e. realist true
11:59:50 <Cale> How do I decide if some statement from PA is true in this sense?
11:59:50 <flamingspinach> well, some say that there is some objective reality and that axiomatic systems approximate it :)
11:59:52 <triyo> Here is the code https://gist.github.com/765280 ... line 86
11:59:55 <Cale> blah
11:59:56 <flamingspinach> you don't, you just believe it
11:59:57 <flamingspinach> which is what he's saying
12:00:01 <Cale> terribly confusing
12:00:09 <roconnor> Cale: there isn't a decision procedure, just a definition.
12:00:13 <monochrom> "realist true" is for physics not mathematics
12:00:19 <flamingspinach> he's saying that if you "believe" PA, then what other systems do you need to "believe" in order to make yourself avoid cognitive dissonance
12:00:23 <dmhouse> Cale: any more context?
12:00:33 <flamingspinach> s/saying that/asking
12:01:06 <roconnor> Cale: the Tarski gives an inductive definition of truth for formulas.
12:01:16 <flamingspinach> "the Tarski" lol
12:01:23 <roconnor> :E
12:01:49 <dmhouse> roconnor: surely not without a system in which to interpret those formulas
12:02:07 <monochrom> logician's "true" is usually "holds in every interpretation". and then you have to define what interpretation you use for which logic.
12:02:30 <roconnor> dmhouse: well you need already a system to define what a formula is.  He just uses that one that is already there.
12:02:31 <Cale> monochrom: Except that it can't be that here.
12:02:32 <dmhouse> monochrom: but there's also "true in system X"
12:02:41 <monochrom> and then you find out that interpretations are formal systems too
12:02:44 <flamingspinach> Cale: that blogger says that if you accept PA then you should accept PA + Consistent(PA), yes?
12:03:07 <Cale> flamingspinach: yeah
12:03:40 <flamingspinach> I'm trying to think why that would be so, other than that if you accept PA but not PA + Consistent(PA) then you must be an idiot (i.e. philosophical reasons)
12:03:52 <Cale> I find the argument a bit circuitous.
12:04:00 <monochrom> well "I accept ____" uses a much richer modal logic than PA itself.
12:04:01 <dmhouse> Cale: link?
12:04:19 <fryguybob> triyo: Do you need a flush in there?
12:04:32 <flamingspinach> dmhouse: if you're looking for the blog post we're talking about, http://xorshammer.com/2009/03/23/what-happens-when-you-iterate-godels-theorem/
12:04:47 <flamingspinach> ... also, lol at the domain name
12:04:49 <triyo> ffryguybob: just a flush I guess would do it.
12:04:52 <dmhouse> roconnor: okay, but many systems share syntax, so it's possible to speak of formulae true in one system but not in another
12:05:16 <roconnor> monochrom: "holds in all models" is *NOT* the definition of truth.
12:05:34 <monochrom> what is?
12:05:35 <roconnor> it is the definiton of (semantic) validity.
12:05:35 <dmhouse> E.g. exists v. forall x. x in v is true in NF and other set theories with a universal set but false in ZF
12:06:21 <roconnor> monochrom: you want me to give Tarski's definiton of truth for arithmetic statements?
12:06:35 <monochrom> yes please
12:08:50 <roconnor> forall n:Nat phi(n) is true if for every constructor normal form of a natural number term t, phi(t) is true.
12:09:03 <triyo> fryguybob: does it make sense that it would work fine in ghci and not from an executable?
12:09:03 <roconnor> Exists n:Nat phi(n) is true if there is some constructor normal form of a natural number term t, phi(t) is true.
12:09:57 <dmhouse> roconnor: how does it compare to the concept of being true in every model?
12:09:58 <fryguybob> triyo: Someone else would know better, but I think it would.  If you change to a putStrLn then I would expect them to be the same.  Flushing at the end of the line.
12:10:04 <dmhouse> Which is definitely used to mean "true" quite often
12:10:06 <roconnor> phi /\ psi is true if phi is true and psi is true; phi \/ psi is true if phi is true or psi is true; "not phi" is true if phi is not true.
12:10:26 <j-invariant> roconnor: it would take me weeks to work through the proofs of this post :S
12:10:55 <Cale> "for every constructor normal form of a natural number term t, phi(t) is true" -- in which system now, if not PA itself?
12:10:57 <triyo> it seems that the getLine evaluates before putStr, which is not what I want
12:11:14 <roconnor> dmhouse: It should be equal to the model definition of truth for a particular term model.
12:11:23 <fryguybob> triyo: It isn't evaluated before, but the buffer doesn't get flushed out before.
12:11:27 <mauke> triyo: I don't know what your question is, but it's buffering
12:11:29 <Cale> triyo: I think the default buffering mode is LineBuffering
12:11:30 <roconnor> Cale: whatever system you use to define what a formula is.
12:11:46 <Cale> roconnor: okay
12:12:12 <Cale> So it's still relative truth
12:12:17 <triyo> hmm, same problem as this post I guess: http://www.haskell.org/pipermail/haskell/2006-September/018430.html
12:12:34 <monochrom> I agree that this definition is used in some texts on incompleteness. This doesn't contradict that other logicians use "true" for semantic validity in other texts.
12:13:49 <roconnor> monochrom: where on earth do logicians use "true" to mean semantic validity?
12:14:05 <monochrom> I asked someone about "such-and-such is true but unprovable in such-and-such" and the explanation was " 'true' means holds in every model"
12:14:07 <Cale> So it's really the same thing as true under model-theoretic interpretation, isn't it?
12:14:14 <roconnor> monochrom: they were wrong.
12:14:29 <roconnor> Cale: for a specific model
12:14:33 <Cale> "true" means "true under the standard interpretation which we're not bothering to mention"
12:14:38 <j-invariant> roconnor: also I don't understand what it's trying to say (without having worked out all the details)
12:14:47 <roconnor> Cale: the model is a term model
12:15:01 <Cale> hmm, okay
12:15:10 <roconnor> Cale: the universe is the subset of terms for natural numbers in constructor normal form.
12:15:24 <roconnor> the operations for multipcation and addition are the usual ones for such terms.
12:15:59 <triyo> Ok so ... hFlush stdout ... worked
12:16:21 <Cale> triyo: If you have to do a lot of that, you may prefer to hSetBuffering stdout NoBuffering
12:16:31 <roconnor> In regards to your comment about relative truth, I'm trying to think it is possible for one person to think a given arithemetic statement is true and another to think that a given statement is false if they are working in different meta-systems.
12:16:42 <roconnor> Cale: I'm not sure if it is possible or not.
12:16:48 <mauke> Cale: ew
12:16:50 <Cale> I think it probably is possible.
12:16:57 <roconnor> certainly some can think it is true and others don't know.
12:16:57 <mauke> enjoy your thousands of write() calls
12:17:03 <triyo> weird that the ghci is inconsistent with the compiler in relation to flushing
12:17:07 <j-invariant> Cale: but can't they just compute?
12:17:35 <Cale> j-invariant: When it comes to universal statements, that's a lot of computing :P
12:17:40 <j-invariant> haha
12:17:42 <Cale> and even then...
12:17:46 <roconnor> Cale: I mean, you could work with PA + ~Con(PA) as your meta system.
12:17:55 <roconnor> but you would know your own system isn't sound.
12:18:50 <Cale> But doesn't it have a model?
12:18:56 * roconnor isn't sure if that is a meta-meta argument.
12:19:27 <ClaudiusMaximus> in my lambda calculus interpreter i have 3 kinds of lambda corresponding to applicative order (\x!foo), normal order (\x?foo), and lazy (\x.foo) reduction strategies; i can implement  seq = \x ! \y . y  ; i now want to implement parallel reduction somehow...
12:19:31 <roconnor> If PA has a model then PA + ~Con(PA) has a model
12:19:45 <sproingie> roconnor: if i argue that it is, then is that a meta-meta-meta argument?
12:20:07 <Cale> roconnor: So it's sound in that sense...
12:20:08 <ClaudiusMaximus> ...would it be possible as a 4th kind of lambda, or would it be saner as a different primitive
12:20:28 <roconnor> Cale: having a model isn't the definition of soundness.
12:20:43 <roconnor> you are as bad as monochrom :D
12:21:19 <Cale> A system is sound if it proves only statements which are valid under interpretation, no?
12:21:20 <roconnor> having a model is the defintion of (semantic) consistency.
12:21:30 <roconnor> A ssytem is sound if it proves only true statements.
12:21:54 <Cale> okay, using the previous definition of true, right?
12:21:59 <roconnor> yes
12:22:23 <dmhouse> You mean Tarski's?
12:22:46 <Cale> Okay, so if my meta-system is also PA + ~Con(PA), then how does PA + ~Con(PA) prove something untrue?
12:22:46 <roconnor> yes
12:24:33 <roconnor> PA + ~Con(PA) proves ~Con(PA)
12:24:54 <Cale> which is an axiom of our outer system
12:25:05 <roconnor> but Con(PA) is true in your meta system (otherwise your meta system wouldn't have a model).
12:25:12 <Cale> what?
12:25:13 <roconnor> at least I think that is how the argument would go.
12:25:21 <roconnor> let me see if I can spell it out in detail.
12:25:23 <Cale> It can't be
12:25:35 <Cale> Unless our outer system directly contradicts itself
12:25:36 <dmhouse> If it is true then it trivially proves false
12:26:30 <dmhouse> By "it" I mean Con(PA). So I mean: if PA + ~Con(PA) |- Con(PA) then PA + ~Con(PA) |- false
12:26:31 <roconnor> well, the outer system does indirectly contradict itself.
12:26:52 <Cale> dmhouse spelled it out nicely there :)
12:27:19 <roconnor> dmhouse: I didn't say PA + ~Con(PA) proves Con(PA).  
12:27:57 <dmhouse> roconnor: so, what, we have PA + ~Con(PA) |= Con(PA), but not the same thing with |-?
12:28:00 <dmhouse> It's true but unprovable?
12:28:29 <roconnor> dmhouse: hmm, good point
12:28:33 <roconnor> let me try again
12:29:23 <dmhouse> To be honest I don't know very much about systems that aren't first-order. In my only course on logic I've taken I had a theorem that "all" systems are complete :)
12:31:02 <dmhouse> (That is, M |= x iff M |- x. x is true in every model of M iff there is a proof in M of x)
12:31:43 <qfr> <dmhouse> It's true but unprovable?
12:31:53 <qfr> How would you know it's true?
12:32:16 <roconnor> ~Con(PA) is defined as forall p:Proof.  "PA |- p".  So it's interpretaion according to tarski's definiton in the meta theory forall p:Proof. "PA |- p" is true  And that would entail that "PA + ~Con(PA) |-  False".
12:32:21 <roconnor> I see
12:33:02 <dmhouse> qfr: by "x is true in M" I mean M |= x, which means the interpretation of x holds in every model of M
12:33:50 <roconnor> Cale: PA + ~Con(PA)  proves "~Con(PA)".  If that "~Con(PA)" is false then the it is unsound.  If it is true, then PA + ~Con(PA) proves "False", which definitely unsound.
12:34:27 <roconnor> Cale: So in either case there is some formula that PA + ~Con(PA) that is false.
12:34:30 <roconnor> I dont' know which one.
12:34:54 <roconnor> (that was the tricky bit, the fact that there are two cases and I don't know which one it is)
12:35:09 <dmhouse> Hmm
12:35:30 <dmhouse> roconnor: 'If [~Con(PA)] is true, then PA + ~Con(PA) proves "False", which definitely unsound.' -- why?
12:36:10 <monochrom> http://plato.stanford.edu/entries/tarski-truth/#195DefOff answers roconnor's question, which logician on earth uses "true" to mean semantic validity? answer: tarski again.
12:36:11 <roconnor> dmhouse: if ~Con(PA) is true then PA proves false.  That is the definition of what it means for ~Con(PA) to be true.
12:36:23 <dmhouse> Oh of course
12:37:23 <Cale> roconnor: Okay, so does that actually mean that there won't be a model of PA + ~Con(PA) even in itself?
12:38:22 <dmhouse> roconnor: now earlier you said "If PA has a model then PA + ~Con(PA) has a model" -- you've just shown PA + ~Con(PA) has no model, so PA has no model? Why is the statement in quotes true?
12:38:27 <monochrom> Even Tarski himself gave several different definitions. There is no "the Tarski definition". There may be "the Tarski definition number 2" or something.
12:38:39 <roconnor> IF there is a model of PA, then there is a model of PA + ~Con(PA).  I *think* that PA + ~Con(PA) should have models in itself, but they won't be the "standard" model in inself.  I'm not sure about this though.
12:38:48 <dmhouse> monochrom: well one could have become known as "the Tarski" definition
12:39:30 <roconnor> monochrom: I don't see your "Valid in all models" definition on that page.
12:41:03 <roconnor> dmhouse: I didn't show that PA + ~Con(PA) has no model.  I showed that PA + ~Con(PA) isn't sound.
12:41:14 <monochrom> The page is a long-winded never-getting-to-the-point thing. I cite it for its Stanford authority only. Look for "The right way to think of the model-theoretic definition is that we have sentences whose truth value varies according to the situation where they are used." and the whole paragraph. Morever...
12:41:48 <monochrom> its previous paragraph "By the late 1940s it had become clear that a direct model-theoretic truth definition was needed. ... See the entry on classical logic for an exposition."
12:41:50 <roconnor> dmhouse: PA +~Con(PA) might prove false things, but it doesn't prove false.
12:42:02 <roconnor> *doesn't necessarily prove false
12:42:20 <roconnor> *must prove false things
12:42:29 <roconnor> maybe I should start that again
12:42:43 <roconnor> dmhouse: PA +~Con(PA) must prove false things, but it doesn't necessarily prove false.
12:43:16 <monochrom> And the entry on classical logic is another long journey, but it contains eventually "A formula θ is logically true, or valid, if M,s ⊨ θ, for every interpretation M and assignment s."
12:43:17 <dmhouse> False meaning what exactly? Exists a model in which their interpretations are false?
12:43:44 <roconnor> monochrom: I accept there is at notition of "true in a model"
12:44:28 <foo_> Is there a way to tell GHC to ignore constraints? Eg: I have a "Debug.Trace.trace (show x) $ ..." and it's complaining that x isn't an instance of Show by default. I know that. I don't care... I'm just debugging. I'll remove the Debug.Trace stuff when I'm shipping. Is there a way to ask it to just believe me for now? (like a pragma)
12:44:47 <roconnor> dmhouse: False in the tarskian sense.  False in the standard model which is the model made up of terms of natural numbers in constructor normal form.
12:44:55 <foo_> Otherwise I have to change a billion type signatures in my code.
12:45:01 <Cale> foo_: It needs that constraint in order for the show function to be able to work
12:45:04 <j-invariant> roconnor: what is that blog post saying?
12:45:13 <Cale> foo_: hmm
12:45:39 <foo_> The point is that I'm testing stuff with Chars which are showable. 
12:46:00 <dmhouse> foo_: I think you want an internal representation printer. (I don't know if one exists in GHC.)
12:46:04 <Cale> foo_: You could unsafeCoerce it to Char ;)
12:46:06 <roconnor> j-invariant: It's saying that if you beleive PA is true then you beleive Pi^1_1-CA is true.
12:46:24 <foo_> That's an idea. I'll try that. Thanks Cale.
12:47:00 <roconnor> j-invariant: note that this is going further than someone who believes that PA is consistent.
12:47:28 <roconnor> by "belive PA is true" I meant "believe PA is sound"
12:47:31 <j-invariant> I see
12:48:15 <Cale> I don't see why this should be stated in terms of belief
12:48:23 <Cale> That sounds oddly untechnical.
12:48:52 <monochrom> at a higher-level, logicians deal with more logics and theories than just PA, so they can't possibly eternally stick with "∀x.p(x) is true iff plug in all normal forms into x". You can easily have a logic+theory with no normal form.
12:49:25 <roconnor> Cale: PA is sound implies that Pi^1_1-CA is sound.
12:49:28 <roconnor> better?
12:49:35 <Cale> I guess so :)
12:49:56 <Cale> Well, certainly better
12:50:00 <dmhouse> Soundness is: "provable => true". Consistency is "does not prove _|_", i.e. "provable => not the statement _|_" -- this is right, yeah?
12:50:05 <monochrom> Yeah if you bring in "believe" you bring in a modal meta-logic.
12:50:05 <roconnor> you are right, the result is techinal, but the topic is philsophic consequences.
12:50:27 <Cale> I guess I like to keep my philosophical beliefs to a minimum
12:50:35 <j-invariant> hah
12:50:40 <dmhouse> "true" is "interpretation holds in every model"
12:50:42 <roconnor> dmhouse: sounds reasonable
12:50:46 <roconnor> dmhouse: no no no
12:50:51 <monochrom> there is something about "keeping philosophy honest"
12:50:54 <Cale> Doing mathematics is great, believing in it seems silly :)
12:50:57 <roconnor> i swear, you people are going to make me go mad!
12:51:05 <roconnor> :D
12:51:22 <monochrom> and it is something about computing or formalism keeps philosophy honest.
12:51:41 <roconnor> "true" means holds in the standard model where the standard model is the model consisting of terms of natural numbers in constructor normal form.
12:52:08 <Cale> and the external system is... something :)
12:52:28 <roconnor> Cale: it is whatever you use to define what a formula is.
12:52:43 <Cale> Right, but that should be different all the time ;)
12:52:52 <roconnor> you tell me what a formula is, I will tell you what the extrnal system is :D.
12:53:15 <monochrom> well first-order logic doesn't even talk about numbers or normal forms. there is no standard model. truth for first-order logic can't be using "standard model"
12:53:48 <dmhouse> roconnor: if I'd only studied first-order systems, would my statement be unreasonable?
12:54:01 <dmhouse> On top of propositional logic
12:54:36 <foo_> Cale: thanks it worked.
12:54:40 <roconnor> there is no notion of truth in first order logic.  There is a notion of logical validity.  And these will be true in every model, and in particular true in a standard model (if you have a notion of a standar model).
12:55:12 <roconnor> dmhouse: which statement?
12:55:28 <dmhouse> roconnor: Soundness is: "provable => true". Consistency is "does not prove _|_", i.e. "provable => not the statement _|_"
12:55:59 <monochrom> well the Stanford encyclopedia states "A formula θ is logically true if" for first-order logic.
12:56:19 <roconnor> I'm not sure what you might or might not have studied has any bearing on whether or not that statement is reasonable or not. :D
12:56:20 <dmhouse> So soundness: if S |- t then S |= t; consistency: not S |- _|_
12:56:30 <roconnor> monochrom: interesting
12:57:01 <dmhouse> And consistency actually implies "if S |= t then S |- t"
12:57:45 <monochrom> The whole meta-fact that Tarski has a 1933 definition and a different 1956 definition should have alerted you.
12:57:46 <roconnor> dmhouse: more plie T |- t then M |= t where T is the theory in question and M is the standard model.
12:57:50 <roconnor> *more like
12:58:32 <roconnor> monochrom: I wouldn't surprise me if the term "Tarski's definition of Truth" has different meaning in Logic and Philosophy.
12:58:36 <roconnor> *It
12:58:38 <dmhouse> Okay, well in my course in first-order systems the above is exactly what I learnt.
12:59:07 <roconnor> dmhouse: That is fair. Soundness can have a more general meaning
12:59:29 <dmhouse> roconnor: when you have more than propositional logic underneath your systems, you mean?
12:59:31 <roconnor> in general soundness is a connection between syntax and semantics 
12:59:56 <roconnor> but when talking about arithmetic, soundness is specifically refering to Tarskian-truth semantics.
13:00:26 <roconnor> dmhouse: even beyond that.  We can talk about what it means for a type system to be sound for example.
13:00:41 <dmhouse> Okay.
13:01:56 <dmhouse> roconnor: different topic. Don't happen to know much about interpretability, do you?
13:02:19 <roconnor> in what sense?
13:02:29 * dmhouse is currently writing his 4th year dissertation on ZFC vs AFA and his superviser suggested he might look at the bi-interprability of those theories
13:02:49 <roconnor> what is AFA?
13:03:07 <dmhouse> The Forti-Honsell antifoundation axiom; a replacement for the axiom of foundation
13:03:08 <monochrom> there is of course also http://en.wikipedia.org/wiki/Truth#Truth_in_logic "A logical truth (also called an analytic truth or a necessary truth) is a statement which is true in all possible worlds[42] or under all possible interpretations" but I doubt you'll accept wikipedia as adequate
13:03:24 <dmhouse> Allows sets such as Omega = {Omega}
13:03:33 <dmhouse> I'm looking for some references on the topic
13:03:43 <roconnor> about biinterpretability or about AFA?
13:04:04 <roconnor> monochrom: I accept your (previous) definition of "logical truth".
13:04:24 <monochrom> ok good enough. my careful wording was "usually" anyway
13:04:24 <dmhouse> I was actually specifically looking for references on the bi-interpretability of ZFC^- + AFA and ZFC (where ZFC^- is ZFC without foundation), but I guess you won't know any given that you just asked me what AFA was :)
13:04:38 <dmhouse> References on interpretability in general might also be useful
13:04:45 <dmhouse> I have Lindstroem's Aspects of Incompleteness
13:04:59 <dmhouse> And someone recommended just reading Albert Visser's papers until I get it :)
13:05:03 <roconnor> monochrom: but note that "logical truth" is about all models of all intepretations of the language.  As opposed to all models satifying a set of axioms.
13:05:34 <roconnor> dmhouse: ya, I won't be of any help.
13:06:07 <monochrom> yes I agree
13:06:15 <roconnor> I'm not really an logician.  I'm an applied logician, aka a computer scientist :D
13:06:24 <dmhouse> roconnor: all right. Was worth a punt, thanks for the lecture on logic anyway :)
13:06:38 <roconnor> np
13:07:17 <roconnor> dmhouse: it was helpful for me too.  It is worth going over that PA + ~Con(PA) isn't sound since the proof is a little tricky.
13:07:29 <roconnor> and I need to remember it to rail against Cale.
13:07:50 <dmhouse> roconnor: I'm still not quite sure why "PA has a model" => "PA + ~Con(PA) has a model" is true
13:08:14 <roconnor> dmhouse: that is a combination of the model consistency theorem and goedel's second incompleteness theorem.
13:08:14 <dmhouse> Oh wait
13:09:05 <dmhouse> PA has a model => PA consistent => not (PA |- Con(PA))
13:09:27 <Daz_> Hey
13:10:10 <roconnor> dmhouse: more importantly PA consistent => not (PA |- ~Con(PA))
13:10:26 <roconnor> er
13:10:30 <roconnor> sorry you were right before
13:10:46 <roconnor> PA consistent => not (PA |- Con(PA)) => not (PA |- ~ ~Con(PA))
13:11:06 <roconnor> => not (PA U {~Con(PA)} |- False)
13:11:07 <dmhouse> => not (PA + ~Con(PA) |- _|_)
13:11:12 <roconnor> yes
13:11:16 <dmhouse> So it has a model. I see.
13:12:15 * roconnor frowns a bit at the classical reasoning
13:12:26 <roconnor> well we are talking about PA after all
13:12:29 <roconnor> so I guess it is fine
13:13:25 <djahandarie> Any good resources on learning logic so I can follow this conversation? :P
13:14:22 <roconnor> djahandarie: my logic textbook wasn't very good.
13:14:37 <dmhouse> djahandarie: http://tartarus.org/gareth/maths/notes/ii/Logic_and_Set_Theory.pdf are the lecture notes from the course I took
13:14:37 <roconnor> so I don't recommend it :(
13:14:40 <Ke> understanding esoteric #haskell conversations may or may not be useful
13:15:15 <xplat> someone once asked me what kind of programming language ZFC would be under the curry-howard correspondence
13:15:20 <dmhouse> It recommends Johnstone's "Notes on Logic and Set Theory", but if the textbook is anything like Johnstone's lecturing I wouldn't heartily recommend it... it's probably okay but a little hard to read
13:15:35 <djahandarie> Ke, I can understand most of them, might as well continue adding to my arsenal of esoteric knowleding :P
13:15:51 <monochrom> djahandarie: you may like to consider http://www.cs.toronto.edu/~sacook/csc438h/ from my school. scroll down for lecture notes
13:15:53 <Daz_> thanks for the link dmhouse
13:16:03 <Denis> Haskell :: Reddit
13:16:05 <djahandarie> And yeah, thanks dmhouse 
13:16:07 <Denis> Let's talk about haskell.
13:16:19 <djahandarie> And monochrom
13:16:44 <Daz_> and monochrome
13:17:29 <Denis>  Computer Science 438H/2404H -- Fall 2008 
13:17:50 <xplat> it seems like it would just be a typical dependently-typed programming language with a few weird library functions
13:18:23 <pumpkin> xplat?
13:18:39 <xplat> you rang?
13:19:10 <pumpkin> what would be?
13:19:40 <xplat> <-- 16:14 < xplat> someone once asked me what kind of programming language ZFC would be under the curry-howard correspondence
13:21:16 <xplat> well, i guess it's a little different than a typical dependently-typed language, more like ATS
13:22:20 <xplat> because the dependent types are dependent on sets, not proof terms.  and due to that you don't exactly have regular type polymorphism either...
13:23:30 * hackagebot maccatcher 1.0.1 - Obtain the host MAC address on *NIX and Windows.  http://hackage.haskell.org/package/maccatcher-1.0.1 (JasonDusek)
13:23:43 <xplat> it's actually a bit more interesting than i thought when he asked me
13:30:50 <Phyx-> Hi
13:31:47 <djahandarie> o/
13:31:49 <Phyx-> hmm.. How would you guys go about explaining a typesystem to a non-computer scientist so that they understand what it is and it's benefits? and a Dependently typed one?
13:32:22 <djahandarie> I don't think the idea of a 'type' is something particularly restricted to computers
13:32:35 <djahandarie> In fact we often try to model things in real life with types, so they shouldn't be hard to explain :P
13:32:47 <xplat> hm, what kind of non-computer-scientist?
13:32:53 <djahandarie> NB: Have not tryed to do so myself
13:33:10 <Phyx-> xplat: mostly physics, life sciences, philosophy etc
13:33:13 <Phyx-> majors
13:33:26 <Phyx-> last thing i wrote was deemed too difficult to understand
13:33:29 <djahandarie> Ah, multiple people?
13:33:33 <Phyx-> yeah
13:33:50 <djahandarie> Whenever I teach I make sure I can use the socratic method
13:33:58 <xplat> ah.  well, for physics majors i would relate it to units and dimensional analysis
13:34:00 <djahandarie> So I tend to avoid teaching a lot of people
13:34:08 <monochrom> "it checks that you don't use + on a number and a piece of text. you should use + on numbers only"
13:34:21 <Phyx-> my basic description was "a type system provides a means of determining the absence of certain kind of programming errors at compile time" a bit loose but
13:34:30 <foo_> Don't confuse apples and oranges!
13:34:36 <xplat> life sciences doesn't help much with types at all, biology does not recognize types :)
13:34:41 <monochrom> "this is a basic example. there are more advanced checks catching more subtle mistakes"
13:34:57 <Phyx-> monochrom: yeah, i gave that example too, and as for a dependent type systems I gave an example of matrix multiplication
13:35:29 <monochrom> give more examples and less description
13:35:32 <drhodes> in biology there are cells walls that only allow sodium to pass, so there is a filter aspect to it.
13:35:40 <Phyx-> monochrom: that's a good one!
13:35:46 <xplat> philosophy i would explain in as hard to understand way as possible so as to sound profound :P  well, not really.
13:35:57 <fryguybob> If you are explaining to chefs I've heard that burrito's can be used as a metaphor.
13:36:12 <Phyx-> drhodes: yeah, but I'm really not sure people of which fields are going to read it, so I want to keep it as general as possible 
13:36:24 <monochrom> even for a greedy corporation, "we make $1B yearly and our partners make $1B yearly each too" is more attractive than "our company is about synergy"
13:36:26 <Phyx-> fryguybob: how do you relatea  burrito to a type system?
13:36:41 <roconnor> dmhouse, Cale: I just realized in the case where the meta-logic is PA + ~Con(PA), the argument is eaiser.  In this meta system we can prove that PA |- False, hence PA + ~Con(PA) |- False, hence not only is PA + ~Con(PA) unsound, it isn't even consistent.
13:36:42 <djahandarie> "Well a burrito is a monad..."
13:37:19 <roconnor> Cale: this answer's your earlier question.  PA + ~Con(PA) proves that PA + ~Con(PA) has no models.
13:37:19 <Phyx-> xplat: I failed philosophy... my teache said and i quote "your answer was textbook, so although correct you did not make up enough bullshit to accompany it"
13:37:46 <xplat> roconnor: that only proves that PA + ~Con(PA) is inconsistent on the meta level, not on the object level
13:37:58 <Phyx-> I like monochrom's idea... I'll add pictures!
13:38:32 <roconnor> xplat: no, it proves the oposite.  PA + ~Con(PA) is inconsisent at the object level, not necessarily at the meta level.
13:38:38 <Phyx-> i'm also supposed to explain what a compiler back-end is
13:38:44 <roconnor> xplat: unless we have different notions of meta and object levels
13:38:46 <Phyx-> I suppose another picture would do..
13:39:20 <monochrom> on compiler back-end, the real question is why bother having one in the first place.
13:39:43 <xplat> roconnor: no, you have it backwards.  Con(PA) expressed in the language of PA is only about the consistency of PA when interpreted at the meta level, at the object level it is just a statement about 'numbers'
13:39:49 <Phyx-> monochrom: hm?
13:40:15 <monochrom> it is easily seen even by laypersons that there is a need to translate source code to machine code. the real question is whether to do it in one go or do it in several stages.
13:40:39 <monochrom> the decision was several stages. the rationale was more modular and more reuse.
13:40:57 <Phyx-> and experimentation
13:41:19 <roconnor> xplat: PA + ~Con(PA) proves "PA + ~Con(PA) |- False"
13:41:23 <roconnor> yes?
13:41:23 <monochrom> so you prefer to translate source code to intermediate code to machine code. the latter stage can be shared.
13:42:46 <Phyx-> hmm, I can definitely use that, what your saying makes me think a bit more highlevel about what i'm explaining
13:42:48 <roconnor> PA + ~Con(PA) proves ~Con(PA)  --- by axiom
13:42:50 <monochrom> and then even without sharing, splitting the job into two smaller jobs helps preserve sanity, as everyone agrees.
13:42:56 <Phyx-> I think In my head too many of this was "obvious"
13:43:13 <roconnor> PA + ~Con(PA) proves ~~(PA |- False)  --- by definition of Con(PA)
13:43:21 <xplat> roconnor: no, PA + ~Con(PA) proves "there exists an object in the system PA + ~Con(PA) that looks like a goedel encoding of 'PA |- False'"
13:43:28 <monochrom> same reason why lexer and cfg-parser are separate. it's easier as two small jobs.
13:43:38 <roconnor> PA + ~Con(PA) proves (PA |- False)  --- by double negation rule
13:43:54 <roconnor> PA + ~Con(PA) proves (PA + ~Con(PA) |- False)  --- by weaking
13:43:59 <roconnor> QED
13:44:11 <xplat> roconnor: that only says anything about actual proofs when you use meta-level reasoning to tie it together
13:44:25 <roconnor> xplat: I agree with that
13:44:42 <xplat> it helps when thinking about these things to make to goedel-encoding steps explicit
13:45:11 <roconnor> xplat: I would replace "looks like" with "is"
13:45:11 <Phyx-> monochrom: And I think I should avoid using CS terminology... use everyday words instead
13:45:25 <roconnor> PA + ~Con(PA) proves "there exists an object in the system PA + ~Con(PA) that is goedel encoding of 'PA |- False'"
13:45:46 <roconnor> er
13:45:48 <monochrom> sometimes you must use CS words like "machine code". but they're easily defined.
13:45:54 <roconnor> I think what you said isn't what I"m trying to say
13:46:07 <roconnor> oh maybe it is
13:46:19 <monochrom> compute the minimum transitive closure of special words you need. define them and use them.
13:46:44 <monochrom> change "define" to "loosely define, or just exemplify" if it helps
13:46:46 <roconnor> PA + ~Con(PA) proves "there exists an object that is goedel encoding of 'PA + ~Con(PA) |- False'"
13:46:52 <roconnor> xplat: how is that?
13:46:53 <xplat> roconnor: the reason for 'looks like' is that 'is' assumes that the object is in the image of goedel encodings of actual proofs
13:47:36 <xplat> xplat: the very fact that this might not be the case is the only thing that prevents us from immediately concluding that PA really is inconsistent
13:47:44 <xplat> er, roconnor:
13:48:36 <monochrom> ♥ Gödel
13:48:46 <Phyx-> monochrom: thanks! that should all help alot. I'll go get started on it now
13:48:48 <Mitar> is there any set data type (with log n ismember operation) which works on only Eq based types and does not require Ord?
13:49:14 <xplat> Mitar: not for arbitrary base types
13:49:15 <quuuux> Mitar: not possible, I think
13:49:28 <Mitar> what about MVars?
13:49:42 <xplat> there are ones that trivially satisfy that for finite types, of course
13:49:47 <roconnor> xplat: the object is in the image of goedel encondings of actual ``proofs'' ... the problem is that ``proofs'' in PA + ~Con(PA) are not what we would call proofs.
13:49:51 <Mitar> i think eq is aready defined based on reerence
13:51:19 <roconnor> xplat: anyhow I think we are arguing in agreement
13:51:39 <c_wraith> I agree more than either of you.
13:51:56 <xplat> roconnor: i guess that depends on whether you draw the line at numbers/''numbers'' or proofs/''proofs''.  lately i tend to keep the concept of proof invariant since here we tend to use a concept of a real-world proof vs 'numbers' as an undefined term
13:52:58 <xplat> i do let the denotation of 'proof' wobble about when i consider ultrafinitism, though
13:53:21 <roconnor> @quote ultrafinitism
13:53:22 <lambdabot> <roconnor> says: I have a proof that Ultrafinitism is inconsistent, but the universe is too narrow to contain it.
13:53:40 * hackagebot gps 0.5.4 - For manipulating GPS coordinates and trails.  http://hackage.haskell.org/package/gps-0.5.4 (ThomasDuBuisson)
13:56:41 * hackagebot control-event 1.2.1.0 - Event scheduling system.  http://hackage.haskell.org/package/control-event-1.2.1.0 (ThomasDuBuisson)
13:57:35 <monochrom> that is not quite right. I will rectify it.
13:57:47 <monochrom> @forget <roconnor> says: I have a proof that Ultrafinitism is inconsistent, but the universe is too narrow to contain it.
13:57:48 <lambdabot> No match.
13:57:57 <monochrom> @forget <roconnor> I have a proof that Ultrafinitism is inconsistent, but the universe is too narrow to contain it.
13:57:58 <lambdabot> Done.
13:58:09 <monochrom> @remember roconnor I have a proof that Ultrafinitism is inconsistent, but the universe is too narrow to contain it.
13:58:10 <lambdabot> Done.
13:58:26 <foo_> Mitar: if you can define a hash operation on it, then all you need is Eq for log n isMember.
13:58:28 <monochrom> now this will distort the haskell weekly news, but oh well
13:58:51 <monochrom> oh damn, if I used pm, it would not distort the haskell weekly news!
13:59:03 <djahandarie> Damn!
13:59:07 <Mitar> is there a way to get internal reference address?
13:59:14 <xplat> foo_: 'if you can define a hash operation on it' is a constraint stronger than Eq ...
13:59:54 <foo_> xplat: True, but Mitar asked about Ord.
14:00:01 <Mitar> true ;-)
14:00:05 <Mitar> so, I have MVars ;-)
14:00:26 <Mitar> and I like how Eq is defined on MVars (it seems by reference and not by content)
14:00:51 <xplat> okay, yes the correct statement is 'better-than-O(n) set types all need constraints other than Eq but Ord is not the only possibility for what that constraint is'
14:01:23 <Mitar> i thought of adding a random number to MVars
14:01:28 <Mitar> like (Int, MVar)
14:01:34 <Mitar> and order by that random number
14:01:59 <xplat> you also have destructuring tries, hash tries, hash tables ...
14:02:46 * hackagebot monadcryptorandom 0.2 - A monad for using CryptoRandomGen  http://hackage.haskell.org/package/monadcryptorandom-0.2 (ThomasDuBuisson)
14:03:16 <xplat> Mitar: what do you need a set of MVar for btw?
14:04:17 <quuuux> what's the best way to get several monad transformer libraries to play nicely with each others' instances? I currently have a file of just instance declarations telling each library about the others
14:04:22 <xplat> it seems like a slightly odd requirement
14:05:11 <Mitar> xplat: to know if lock already exists
14:05:20 <xplat> quuuux: i think the best way is probably to update to mtl 2.0 ... unless you're using one of the exotics
14:05:37 <Heffalump> quuuux: pick one, find the authors of the other ones, shoot them and then go delete their ones from hackage
14:06:22 <monochrom> add a time machine too
14:06:24 <quuuux> xplat: mtl 2.0 does things like, say, lifting MonadRandom appropriately through MonadAdvSTM automagically?
14:07:15 <quuuux> the issue is that I have a squillion `instance MonadXyz m => AbcT m a where...' declarations
14:07:37 <xplat> quuuux: er, no ... i think i mistook what your issue was
14:08:19 <xplat> Mitar: moar context
14:08:44 <quuuux> monochrom: luckily enough, TimeMachineT happens to be in my transformer stack!
14:09:10 <monochrom> TerminatorT
14:09:20 <xplat> but is it TimeMachineT IO or TimeMachineT ST?
14:10:18 <xplat> only TimeMachineT IO can cause an externally-visible change to history
14:11:04 <xplat> the only way anyone can tell you used TimeMachineT ST is to note that you computed a PSPACE-complete function in P time
14:11:58 <xplat> well, or attach a debugger, but that's cheating
14:12:07 <roconnor> xplat: does the 2nd incompleteness theorem say that if T|-~Con(T) then T is inconsistent?
14:13:12 <xplat> roconnor: no, that if T |- Con(T) on the object level then T is inconsistent on the meta level
14:13:13 <roconnor> maybe this is where omega-consistency comes in
14:13:55 <roconnor> the 2nd incompletness theorem probably only says that if T|-~Con(T) then T is not omega-consistent.
14:14:01 <mreh> is someone/something reposting hackage packages to github?
14:15:11 <lispy> mreh: that would be really weird
14:15:14 <xplat> say, has anybody ever tried to extend postgres using haskell?
14:15:21 <lispy> mreh: why do you think that's happening?
14:15:54 <mreh> lispy: something of mine is up on github, and it's not registered to my email
14:16:03 <mreh> the email i use for everything
14:17:30 <Mitar> xplat, ok, so i want to have a set of chans (or mvars) which already have consumers, so that if I want to attach another one to one already in there i can duplicate chan before i add another consumer to it
14:17:35 <xplat> maybe someone just wanted to fork it?
14:17:53 * hackagebot crypto-api 0.3 - A generic interface for cryptographic operations  http://hackage.haskell.org/package/crypto-api-0.3 (ThomasDuBuisson)
14:18:42 <roconnor> yes, T|-~Con(T) only implies the lack of omega-consistency of T.
14:18:43 <xplat> Mitar: can't you just use a handle other than the MVar for these channels and then you can create new MVars at attach time?
14:18:53 * hackagebot DRBG 0.1.2 - A deterministic random bit generator (aka RNG, PRNG) implementing DRBGs from NIST SP 800-90  http://hackage.haskell.org/package/DRBG-0.1.2 (ThomasDuBuisson)
14:19:23 <xplat> roconnor: oh, that one.  hm, yeah.
14:19:34 <bos> Yep.
14:19:41 <bos> Oops, wrong window.
14:19:51 <xplat> i admit i'm a little weak on omega-consistency
14:20:04 <roconnor> it's a little silly
14:20:08 <Mitar> let's say that I use official Chans directly
14:20:22 <Mitar> how would you make a set of all chans which are already used
14:20:28 <roconnor> Rosser's theorem mean talk of omega-consisteny isn't important for the first incompleteness
14:20:32 <xplat> official Chans are not designed to be multiply-consumed, afaik
14:20:46 <roconnor> and people don't often think about what T |- ~Con(T) would mean.
14:21:06 <Mitar> of course they are
14:21:12 <Mitar> they have duplicate function for that
14:21:47 <xplat> Mitar: that's what i mean
14:21:51 <roconnor> I guess the trick is that Goedel proved that Con(T) and G(T) are equivalent for his goedel sentence G(T), but this equivalence doesn't apply to the goedel-rosser sentence GR(T)
14:23:20 <xplat> Mitar: why not just duplicate in any case?
14:23:27 <Mitar> memory leak?
14:23:37 <Mitar> so first time i should not duplicate
14:23:43 <Mitar> (so if only one consumer is there)
14:23:46 <Mitar> otherwise I should
14:23:55 <xplat> why would that leak memory if the second dup doesn't?
14:24:10 <Mitar> becuse there is one chan without a consumer
14:24:19 <Mitar> if i like the first time already
14:24:33 <Mitar> so data is just getting pilled up in the chan
14:25:25 <xplat> oh, ha.  good point.
14:26:46 <xplat> it's not like you can get an MVar out of the chan anyway, though, even if you could get anything out of the MVar, so that's a dead end
14:28:32 <xplat> so i guess you are using observers that subscribe to the channels somehow, maybe you want to manage this through the handle you use to subscribe
14:28:53 <Mitar> no, Chan Eq is based on MVar eq
14:29:01 <Mitar> this is why i was asking about MVars
14:29:32 <xplat> Chan Eq may be based on MVar eq, but you can't get at any of the other methods of the MVar
14:29:46 <xplat> or any functions on it
14:29:55 <xplat> just Eq
14:30:08 <Mitar> yes
14:30:13 <xplat> and we've established that is not enough
14:30:25 <Mitar> yes, i would need like internal reference numbers of MVars
14:30:37 <Mitar> and use them for ORd
14:30:40 <Mitar> and then I would be able to derive also Ord for Chan
14:30:42 <xplat> yes, and to get them you would need an MVar, which you can't get
14:30:53 <Mitar> no problem, I can extend Chan locally
14:30:56 <Mitar> with my own version
14:31:07 <Mitar> the problem is that MVar does not support Ord
14:31:49 <xplat> you need to do one of two things
14:31:55 <xplat> 1) don't use Chan
14:32:29 <xplat> 2) come up with some way to distinguish Chans with at least one consumer from ones with no consumers other than keeping a set of them
14:32:58 <Mitar> yes, my idea was to add a random number to Chan
14:33:07 <Mitar> so to have like (Int, Chan) pair
14:33:13 <Mitar> and order them by Int
14:34:17 <xplat> wouldn't just a sequence number or something suffice?  that single-threads the allocation of channels but that might not be a problem depending on how much of your runtime is channel allocation
14:34:22 <monochrom> I stole Chan code and modified it to support broadcast to n listeners, n>=0. When n=0, there is no leak, this is why I stole and modified.
14:34:51 <xplat> monochrom: did you put this on hackage or anything?
14:34:54 <monochrom> no
14:35:06 <Mitar> ;-(
14:35:12 <monochrom> but probably someone else did the same and put it on hackage
14:39:51 <xplat> Mitar: if you were keeping a set, how would you determine which Chans to put in it?
14:43:39 <nooodl> http://codepad.org/IUKbk46U uncommenting the type signature on line 6 makes this work again. how come?
14:44:11 <nooodl> specifically it's the (Eq a) that needs to be there
14:44:12 <roconnor> nooodl: likely the monomorphism restriction
14:44:22 <nooodl> yeah, that's the error ghci is giving
14:44:26 <nooodl> *ghc
14:44:37 <roconnor> nooodl: you can also eta expand your definition instead of giving a type signature
14:44:48 <aavogt> or -XNoMonomorphismRestriction
14:44:51 <roconnor> or that
14:45:01 <roconnor> better as a pragma at the top though
14:45:10 <aavogt> which can be set like  {-# LANGUAGE NoMonomorphismRestriction #-}
14:45:29 <kyagrd> Is there a general trick of having a parser that read in special comments? Which is needed when making tools like haddock.
14:45:36 <roconnor> anyhow, the monomorphism restirction was a big mistake
14:45:42 <nooodl> i'm going to regret asking, but what's the monomorphism restriction
14:46:00 <kyagrd> @google monomorphism resitriction
14:46:11 <aavogt> @botsnack
14:46:12 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
14:46:12 <lambdabot> Title: Monomorphism restriction - HaskellWiki
14:46:13 <lambdabot> :)
14:46:21 <roconnor> nooodl: when you give top level definitions with no arguments, the monomorphism restriction kicks in to try to give the term a *NON* polymorphic type.
14:46:51 <kyagrd> f = id . id
14:46:55 <kyagrd> you can't write this
14:47:05 <roconnor> nooodl: this is because it is woried you are thinking that you are defining a constant, but if it makes it polymorphic, it won't be constant anymore.
14:47:25 <nooodl> that *is* evil
14:47:26 <kyagrd> In Haskell 98 you have to write instead f x = id $ id x
14:47:38 <kyagrd> Otherwise give a type annotation
14:47:40 <aavogt> kyagrd: you can if you don't mind  f  taking a monomorphic type like   Int -> Int  (if that's the only type you use it at)
14:48:04 <Mitar> xplat: first time i add a consumer to a chan, i add chan to a set, next time i want to add a consumer, chan is aready in there so i duplicate it
14:48:26 <kyagrd> aavogt: Oh your right. but usually people wirting point free style intend to write polymorpihic functions
14:48:37 <xplat> Mitar: how do you know the chan has got a consumer?
14:49:39 <aristid> @let getRandomNumber = 4
14:49:40 <lambdabot>  Defined.
14:49:40 <roconnor> nooodl: for example, if you write "seven = 3 + 4" and you don't have the monomorphism restriction, then that additon operation will have make a dynamic dispatch call every time you use "seven"
14:49:53 <aristid> > getRandomNumber -- look ma, pure code
14:49:55 <lambdabot>   4
14:50:03 <hpc> :t id . id
14:50:04 <lambdabot> forall a. a -> a
14:50:10 <aristid> :t id . id . id
14:50:12 <lambdabot> forall a. a -> a
14:50:24 <roconnor> nooodl: actually, that is probably not true, The optimizer will probably catch it in most cases anyways.  But that was the worry.
14:50:27 <aavogt> @quote monochromism
14:50:28 <lambdabot> No quotes match. My pet ferret can type better than you!
14:50:47 <xplat> roconnor: can't that be inlined away if you use it at a monomorphic type further up the stack?
14:51:13 <roconnor> xplat: if you support cross module inlining, sure.
14:51:47 <xplat> if you don't support cross-module inlining at least of Prelude you're in trouble
14:51:57 <kyagrd> dosen't ghc partially evaluates dictionars if it can?
14:52:08 <MrWish> what is cross-module inlining
14:52:10 <kyagrd> I mean dectionary
14:52:12 <roconnor> I don't know which Haskell compilers support cross module inlining, and when the got that support.
14:52:14 <kyagrd> urrgg typos
14:52:26 <kyagrd> dictionary
14:52:47 <invarius1> what's a nice bluetooth mini keyboard? 
14:52:49 <roconnor> MrWish: it means that code defined in one module can be inlined in another module.  It is a bit tricky if you do separate compilation.
14:53:09 <MrWish> I dont know anything about that yet
14:53:13 <MrWish> anyways,
14:53:17 <monochrom> don't worry about it
14:53:41 <MrWish> can someone explain how I declare the types of a function in WinGHCi  again
14:53:49 <MrWish> I did this:
14:53:57 <monochrom> f :: Int -> Bool
14:54:06 <MrWish> Prelude> removeNonUppercase :: [Char] -> [Char]; removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]
14:54:08 <edwardk> hrmm. trying to come up with a more satisfying ContextT and ComonadTrans
14:54:13 <monochrom> not at the prompt
14:54:27 <kyagrd> MrWish: ghci is not python
14:54:45 <MrWish> uhm, ok so where do I write it
14:54:45 <monochrom> if you insist to do it at the prompt, let { removeNonUppercase :: [Char] -> [Char]; removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']] }
14:55:13 <kyagrd> or you can use asTypeOf trick
14:55:20 <monochrom> put it in a file and load it in winghci
14:55:20 <MrWish> yeah ok I just dont know these basic interface things yet, thats the problem...
14:55:44 <MrWish> oh right
14:56:25 <dmhouse> roconnor: is xorshammer.com you?
14:56:26 <monochrom> knowing how to do it at the prompt requires knowing a lot of haskell first, unless you just memorize the recipe.
14:56:32 <MrWish> so I can put Prelude> removeNonUppercase :: [Char] -> [Char]; removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']] in a source file and then load it and then when I work with the function it will know what types it has to use... right?
14:56:41 <monochrom> yes
14:56:45 <edwardk> the contextT i have right now is to the left kan extension what contT is to the right kan extension, but i don't have pretty laws relating get and put like i do for stateT
14:56:46 <roconnor> dmhouse: no
14:57:13 <dmhouse> roconnor: okay. I just realised I worked with the guy who write it.
14:57:24 <MrWish> ok and python lets you do all of this in the uhm, yeah... whats it called the thing Im working in
14:57:24 <roconnor> dmhouse: I took the book that was mentioned in that blog post from my library.
14:57:26 <xplat> i wish i understood kan extensions
14:57:31 <roconnor> I have it on my desk now
14:57:34 <monochrom> "repl loop"
14:57:47 <roconnor> xplat: if you did you would understand everything
14:57:59 <edwardk> so i started trying to take apart and adjoin the definition for state to get an analogous definition for contextT
14:58:13 <Mitar> xplat: i have a wrapper function which adds a consumer to a chan ;-)
14:58:30 <monochrom> damn, "repl loop" is redundant
14:58:41 <edwardk> which takes s -> m (s, a) — and derives something like (s, w (s -> a))  — instead of the current (w s, w s -> a)
14:58:51 <monochrom> nothing in principle forbids a repl for haskell. it is just not done yet.
14:59:05 <MrWish> Prelude> {removeNonUppercase :: [Char] -> [Char] ; removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]} this doesnt work either :/
14:59:18 <monochrom> you forgot "let"
14:59:18 <xplat> Mitar: then just use a different function for each Chan and have it remember an IORef
14:59:21 <edwardk> both paths give the same definition when w = Identity
14:59:28 <roconnor> edwardk: what are the primitive operations for context?
14:59:29 <kyagrd> Speaking of dictionary and overloading, there was a old paper MPJ and SPJ wrote about optimizing dictionary for overloading by partially evaluation.  I don't know how that is currently implemented but I believe GHC does something wheb concrete types are kwown
14:59:35 <MrWish> ahhh ok
14:59:46 <kyagrd> http://web.cecs.pdx.edu/~mpj/pubs/pepm94.html here it is
14:59:55 <MrWish> "let" goes in the second line right?
15:00:12 <monochrom> let { removeNonUppercase :: [Char] -> [Char]; removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']] }
15:00:13 <kyagrd> oh not SPJ, MPJ only
15:00:13 <edwardk> but the latter has a chance of having get :: w a -> s and put:: s -> w a -> a be able to be merged together to get an identity arrow
15:00:24 <MrWish> oh
15:00:25 <MrWish> whow ok
15:00:25 <kyagrd> it might have been in hugs :)
15:00:31 <MrWish> thanks for clearing that up for me
15:00:32 <edwardk> getC :: w a -> s      and modifyC :: (s -> s) -> w a -> a — are what i offer now
15:00:44 <nooodl> @pl \x -> (x:x:)
15:00:44 <lambdabot> ap (:) (:)
15:00:47 <nooodl> what's ap.
15:00:59 <kyagrd> but hugs was not a compiler at all 
15:01:08 <edwardk> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Comonad-Context.html
15:01:14 <hpc> :t ap (:) (:)
15:01:15 <lambdabot>     Couldn't match expected type `[a]'
15:01:16 <lambdabot>            against inferred type `[a] -> [a]'
15:01:16 <lambdabot>     In the second argument of `ap', namely `(:)'
15:01:46 <xplat> Mitar: or that might run into sync problems, but that general principle.
15:01:51 <nooodl> :t ap
15:01:52 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:02:00 <edwardk> copumpkin is frantically trying to prove comonad laws in agda for the alternative definition above as we type ;)
15:02:08 <hpc> ap = (<*>) for all sane monads
15:02:15 <hpc> or most, at least
15:02:21 <hpc> depending on your idea of "sane"
15:02:25 <pumpkin> aiiiieeeee
15:02:39 <edwardk> see, frantic ;)
15:02:48 <roconnor> edwardk: how do you write (s -> s) -> w a -> w a using those operations?
15:03:22 <monochrom> 5 minutes of proving a theorem calculationally can be saved by 5 hours of proving it in agda
15:03:27 <pumpkin> :D
15:03:33 <roconnor> edwardk: FWIW, I've taken to calling this the Store comonad.
15:03:54 <edwardk> roconnor: *nods*, i have yet to abandon the conventional terminology ;)
15:04:05 <edwardk> as inconvenient as it may be
15:05:14 <roconnor> I guess you can write something like (modifyC . (. duplicate))
15:05:37 <edwardk> anyways i don't have nice laws that relate the existing modifyC and getC in fact, it should be fairly obvious that modifyC (const (extract …)) will change all members of the w s to be the same value
15:06:08 <roconnor> doesn't typecheck for me
15:06:12 <edwardk> otoh, the modifed transformer would only have one 's' so that would be okay.
15:06:15 <roconnor> modifyC (const (extract …)) doesn't typecheck for me
15:07:16 <roconnor> law 1: modifyC (const (getC x)) (duplicate x) = x
15:08:00 <roconnor> law 2: getC (modifyC (const z) (duplicate x)) = z
15:08:03 <edwardk> modifyC :: (s -> s) -> w a -> a — getC :: w a -> s   — law x = modifyC (const (getC x)) = extract — or something like that
15:08:25 <edwardk> hrmm
15:09:36 <roconnor> law 3: modifyC (const z2) (duplicate (modifyC (const z1) (duplicate x))) = modifyC (const z2) (duplicate x)
15:09:42 <roconnor> those are your 3 laws
15:10:07 <roconnor> ... this would be a lot easier if you defined foo z x = modifyC (const z) (duplicate x)
15:10:11 <JoshTriplett> Anyone know of a Haskell SMTP library that can do SSL?  Trying to figure out if I can ship mail off to a smarthost directly, or if I have to install ssmtp.
15:10:24 <JoshTriplett> I found several that claim to do SMTP AUTH, but they don't seem to do SSL.
15:10:28 <edwardk> trying to drop the duplicate and just relate to extract
15:10:29 <edwardk> one sec
15:11:07 <hpc> JoshTriplett: there's an SSL library, which you can combine with any protocol
15:11:18 <JoshTriplett> hpc: That's a theory, yeah... :)
15:11:36 <JoshTriplett> hpc: Assuming that the SMTP library can talk to it.
15:12:02 <hpc> assuming you can pass a Handle to the SMTP function calls, that should be all you need
15:12:39 <edwardk> extract x = modifyC (const (getC x)) x
15:12:52 <edwardk> would be the desirable property the current ContextT lacks
15:13:24 <roconnor> indeed
15:13:47 <roconnor> what is the current ContextT?
15:13:58 <edwardk> (w s -> a, w s)
15:14:35 <edwardk> it is the left kan extension of a constant functor, as ContT is the right kan extension of a constant functor
15:15:00 <edwardk> so my current ContextT is more related to ContT than it is to StateT
15:15:46 <edwardk> whereas the quantification would prevent access to the continuation in Cont, it'd prevent access to the current context in Context
15:16:52 <roconnor> oh you are right, that law doesn't look satified
15:16:55 <edwardk> forall r. (a -> r) -> r — beyond Codensity/Yoneda Identity    and exists s. (s -> a, s) — being Density/CoYoneda Identity
15:17:45 <edwardk> i started writing a 'comonad', 'comonad-transformers', 'comonads-tf' and 'comonads-fd' stack, and wanted a more canonical set of examples with laws, etc.
15:25:49 <iago> hi all, suppose I'm implementing a toy functional language and I have a term data type parametrized by "phase". I use phase as a index for various type/data families, for example, Idn phase gives the "id" type used in that phase. My phases are Prs, Rnm and Tc (Parsing, Renaming and Typechecking... yep, similar to GHC design). I have some initial phases and finally a Tc phase. I make use of phase to restrict some data constructors to appear onl
15:25:49 <iago> y in Tc phase, but I would like to do the "inverse", i.e., restrict some constructors to appear only in previous phases
15:25:59 <iago> I would like to ask for the preferred idiom to do that
15:26:52 <iago> I was thinking in just use another type family mapping phase to another datatype indicating "previous to typecheck" or "post to typecheck"
15:27:23 <iago> or in the use of type classes
15:27:50 <latros> why doesn't something like this compile?:
15:27:54 <latros> f 1 = id
15:27:57 <latros> f x y = x+y
15:28:12 <monochrom> f 1 y = y
15:28:18 <latros> yes, that would work too
15:28:24 <latros> but this version doesn't compile
15:28:26 <latros> why not
15:28:39 <monochrom> because the haskell 98 report says so
15:28:43 <latros> ....wat
15:28:48 <Zao> latros: Because you need the same arity.
15:28:51 <roconnor> latros: your attempt at pattern matching multiple variables is confusing
15:28:57 <Zao> latros: The report is the specification for the language.
15:29:02 <latros> I know that
15:29:07 <latros> but I don't understand why it specifies that
15:29:18 <Zao> Because it's generally tricky to pattern match otherwise?
15:29:22 <monochrom> I don't know either. Talk to the committee who decided on this.
15:29:24 <latros> a function defined such that f 1 = id takes 2 args
15:29:32 <latros> a function defined such that f x y = x+y takes 2 args
15:29:37 <roconnor> latros: if you look at the report, when you pattern match on multiple variables it is transformed into one large case statement rather than nested case statements.
15:29:55 <iago> latros, simplicity (maybe)
15:30:08 <latros> why is that better than the alternative?
15:30:10 <latros> efficiency?
15:30:24 <roconnor> this actually causes some pecular behaviour with regrads to how seq and multiparameter functions behave.
15:30:29 <iago> I don't think efficiency was in the mind of Haskell designers
15:30:52 <roconnor> latros: why is one big case statement better than nested case statements?
15:30:57 <latros> yeah
15:31:35 <roconnor> latros: because with one big case statement the compiler is free to match on different parameters first other than the order that they occur.  This extra flexibility can produce faster pattern matches.
15:31:46 <latros> so efficiency
15:31:54 <roconnor> well, I'm making up this reason
15:32:12 <roconnor> I wasn't invited to the Haskell comittee ... grrr
15:32:21 <latros> my example is of course naive, but it seems like an annoyingly inflexible rule
15:32:41 <latros> it's not like the type system is bothered by it, or something, it's just syntax
15:33:01 <gwern> nested case statements don't desugar into one?
15:33:05 <monochrom> need a #haskell-whine channel
15:33:26 <Zao> Maybe -in-depth knows why?
15:33:43 <roconnor> gwern: How could they?
15:34:12 <gwern> roconnor: it doesn't seem too difficult to me
15:34:44 <roconnor> I guess they can
15:35:17 <gwern> wow. that was like a perfect example of Aumannian agreement
15:35:30 <roconnor> gwern: but renesting case statement would change the retarded haskell semantics.  Not that I would care myself.
15:35:51 <gwern> gwern 'I believe X' roconnor: 'I believe Y' gwern: 'I believe X' roconnor: 'I believe X'
15:35:56 <edwardk> modify f ws = put (f (get ws)) ws
15:36:04 <sproingie> gwern: duck season!
15:36:34 <gwern> roconnor: renesting? what semantics?
15:37:00 <edwardk> at least given a definition for ContextT that has a single context
15:37:01 <roconnor> > case undefined of 7 -> case 6 of 6 -> 6
15:37:02 <lambdabot>   *Exception: Prelude.undefined
15:37:33 <roconnor> oh wait, this doesn't work
15:37:35 <roconnor> hmm
15:37:38 <monochrom> > case undefined of ~7 -> case 6 of ~6 -> 6  {- hehe! -}
15:37:40 <edwardk> i guess the current context is more of an adjoint cont
15:37:40 <lambdabot>   6
15:38:20 <kyagrd> lazy pattern matching can be evil
15:38:29 <edwardk> it can also be awesome ;)
15:38:42 <monochrom> irrefutably so
15:38:54 <edwardk> i love it when my arguments are irrefutable ;)
15:39:03 <monochrom> haha
15:39:22 <monochrom> @remember edwardk i love it when my arguments are irrefutable ;)
15:39:22 <lambdabot> Good to know.
15:40:15 <monochrom> sometimes I think of irrefutable patterns as irrefusable patterns, as in "an offer you can't refuse"
15:40:36 <bos> @hoogle MonadZero
15:40:36 <lambdabot> No results found
15:42:04 <edwardk> x = put (get x) x — is a much simpler law
15:42:32 <roconnor> yes, defining put makes the laws eaiser
15:42:46 <roconnor> y = get (put y x)
15:42:51 <edwardk> yeah
15:42:53 <nkpart> Is there a way I can pull the package properties from hackage in a json/yaml/something format? The properties I mean are these: http://hackage.haskell.org/package/kit (specifically, version list and upload date)
15:43:00 <roconnor> put y2 (put y1 x) = put y2 x
15:43:07 <roconnor> those are the three laws
15:43:23 <edwardk> that i buy
15:43:37 <edwardk> now to get a comonad transformer to satisfy them =)
15:43:38 <roconnor> edwardk: then you will really buy this:
15:46:32 * edwardk arches an eyebrow
15:48:30 <monochrom> his brain has crashed. the halting problem predicted this. :)
15:48:41 <edwardk> haha
15:50:02 <roconnor> edwardk: type Ref a b = (r -> Store b a);  let get ref x = let (_,b) = ref x in b; let set ref x y = let (f,_) = ref x in (f,_)
15:50:10 <monochrom> I whine about the miserable state of haskell highlighting on the haskell wiki. <hask> is used pervasively and the new highlighter is seriously broken.
15:50:29 <roconnor> then (get ref) and (set ref) statifies those three laws exactly when ref is a coalgebra for a comonad.
15:50:39 <roconnor> *satisfies
15:50:48 <edwardk> hrmm
15:51:16 <roconnor> *coalgebra for the Store comonad
15:51:25 <edwardk> r ?
15:51:38 <monochrom> I have an example at http://www.haskell.org/haskellwiki/MigratingWikiContent . It's pretty bad.
15:51:44 <roconnor> Just clairifying the comonad in question.
15:51:44 <edwardk> type Ref a b doesn't typecheck for my brain
15:51:51 <roconnor> ah opps
15:51:54 <roconnor> I was ediitng that line
15:51:57 <edwardk> np
15:52:02 <roconnor> Ref a b = a -> Store b a
15:52:04 <roconnor> or if you will
15:52:13 <roconnor> Ref a b = Coalgebra (Store b) a
15:52:31 <roconnor> of if you will
15:52:39 <roconnor> Lens a b = Coalgebra (Store b) a
15:53:22 <roconnor> oh I have a blog post
15:53:26 <roconnor> I should have just pointed to that
15:53:27 <edwardk> oh i see it
15:53:36 <roconnor> http://r6research.livejournal.com/23705.html
15:53:52 <roconnor> ah, but I was calling it the Selection comonad back then
15:54:03 <edwardk> a -> (s -> a, s) — is the lens with the common function prefix factored
15:54:16 <roconnor> yes
15:54:26 <edwardk> cute
15:56:44 <edwardk> now i see why you headed towards selection/store for names
15:57:27 <freedrull> im having trouble installing filemanipcompat... System/FilePath/FindCompat.hs:175:20: Not in scope: data constructor `State'
15:57:29 <edwardk> and why you had laws handy ;)
15:59:53 <edwardk> so now, lets look at what the lenses generalize to under the context transformer
16:00:15 <edwardk> a -> (m (s -> a), s) — is a little asymmetric
16:14:08 <xplat> what the Context comonad is is really the same thing as a zipper for a function-as-container.  just a container with a distinguished position.  if i knew what kind of algebraic gadget a (co)monad transformer actually is i could probably tell you this right away ...
16:14:47 <sshc> Is there a standard Haskell function that compares the bytes in memory referenced by two pointers for a given length?
16:15:08 <sshc> If I remember correctly, an equivalent to memcpy is what I'm looking fory
16:15:10 <sshc> or memcmp
16:15:12 <xplat> foreign import memcmp
16:15:32 <sshc> Ah, yes, memcp
16:15:49 <xplat> or if you have the memory as a bytestring there's probably something already for that
16:16:15 <sshc> xplat: Yes, it is
16:16:17 <c_wraith> well, getting a substring of a bytestring is zero-copy, so you can just compare substrings if you have them as bytestrings.
16:16:42 <sshc> c_wraith: But is (take n, drop n) efficient?
16:16:47 <sshc> c_wraith: Does it make copies?
16:16:57 <c_wraith> neither of those should make copies of a strict bytestring
16:17:00 <sshc> c_wraith: That is what you mean by getting substrings, yes?
16:17:13 <sshc> Okay, thanks
16:18:33 <edwardk> need a good name for CocontT — one that doesn't involve jokes about the ntT comonad or coconuts ;)
16:18:48 <monochrom> coconut
16:18:55 <c_wraith> what? how can it not be a joke about coconuts?
16:18:59 <monochrom> oops I read too little!
16:19:00 <edwardk> =)
16:19:30 <Phyx-> maybe a joke with a spider? :P
16:19:33 <Phyx-> or a butterfly!
16:20:10 <sshc> I suggest "CoconuT"
16:20:11 <edwardk> preferably something folks 'd be willing to type on a regular basis =)
16:21:14 <xplat> LeftKanT
16:21:18 <Phyx-> just drop a T and use CoconT?
16:21:22 <edwardk> i have those =)
16:21:32 <edwardk> (left kan extension transformers, that is)
16:21:59 <edwardk> besides LeftKan is usually Lan, LanT might work, but its non transformer version wouldn't be a Lan
16:22:19 <edwardk> and ConstLanT is kinda silly
16:22:34 <Cale> edwardk: What does the definition of CocontT look like?
16:22:48 <edwardk> (w s -> a, w s)
16:23:06 <Cale> hmmmm
16:23:20 <Phyx-> wow.. that right there just told me nothing..
16:23:26 * Phyx- bows head in shame
16:23:28 <edwardk> its currently and incorrectly ContextT in category-extras
16:23:43 <pumpkin> it is, however, proven to be a Comonad
16:23:46 <pumpkin> <_<
16:23:53 <edwardk> yeah, that one is easy =)
16:23:55 <xplat> isn't that just Context `O` w or something?
16:24:16 <edwardk> just like how ContT is a really boring variation on Cont
16:24:36 <xplat> or i guess just O Context
16:24:42 <monochrom> implication-elimination-pair
16:24:47 <edwardk> Cont is a right kan extension of a constant functor, Cocont is a left kan extension of a constant functor.
16:25:42 <monochrom> CommunismT
16:25:44 <xplat> yes, its name is O Context, even though that doesn't end in T
16:26:13 <xplat> i guess that doesn't give you the right instances though
16:26:27 <edwardk> yeah
16:27:31 <edwardk> CocontT s Identity and the ContextT s Identity i was describing above look like the same thing when applied to Identity
16:27:54 <edwardk> (w s, w s -> a) and (s, w (s -> a)) — are the same when w = Identity
16:28:08 <quuuux> SubtextT?
16:28:12 <edwardk> (assuming ContextT is actually a comonad
16:28:16 <edwardk> quuuux: heh
16:28:35 <azaq231> be sure to be conscious of the class declarations when implementing CommunismT
16:28:58 <edwardk> azaq231: yeah class distinctions are something to avoid
16:34:51 <mightybyte> Anyone know if it's possible to get rid of this rigid type variable error?  https://gist.github.com/765719
16:36:47 <monochrom> don't you love pastebins that assumes that everyone has a 21" screen
16:37:12 <edwardk> yeah, clearly they should get with the times and assume folks have a 25 or 30" screen at least ;)
16:38:03 <Phyx-> most haskell programmers i've met have a tiny tiny screen
16:38:11 <mightybyte> How does my paste assume a 21" screen?
16:38:23 <monochrom> not your paste. the pastebin
16:38:25 <Bynbo7> works fine on my 15" screen :\
16:38:37 <joeb_> anybody tried to build lambdabot recently?
16:38:43 <edwardk> the lack of scrollbars, etc?
16:38:48 <joeb_> I'm having a heck of a time
16:38:52 <Philippa> what counts as tiny?
16:38:58 <Phyx-> it has scrollbars here..
16:38:59 <Eduard_Munteanu> I think the tiny fonts.
16:39:07 <parcs> is anyone here familiar with Yesod? if so, can someone show me a working example of using Text.Hamlet.hamletFile? i seem to be using it wrong, and the corresponding documentation is lacking and/or outdated
16:39:08 <mightybyte> It works fine on my 13" screen. :)
16:39:11 <nooodl> > let coprime = ((==1) . gcd) in (coprime 24 35)
16:39:12 <lambdabot>   Couldn't match expected type `t1 -> t'
16:39:12 <lambdabot>         against inferred type `GHC.B...
16:39:17 <Philippa> (I'm on a 13.3" screen here, with a 3.7"er to the left of me and a 32"er in front - though that one's the same resolution as the 13.3")
16:39:32 <monochrom> it has a horizontal scrollbar but inaccessible unless you scroll down first
16:39:45 <parcs> > let coprime = ((==1) .: gcd) in (coprime 24 35)
16:39:47 <lambdabot>   True
16:39:52 <nooodl> :t (.:)
16:39:53 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
16:40:00 <nooodl> hmm!
16:40:08 <mightybyte> monochrom: No horizontal scroll bar for me in Chrome.
16:40:10 <djahandarie> :t (Prelude..) (Prelude..) (Prelude..)
16:40:12 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
16:40:32 <Phyx-> mightybyte: anywho, what determines v? it's neither in the class definition nor the function signature. you could add a dependent type a -> v if that makes sense for what you're trying
16:41:03 <monochrom> the real culprit is wasting space on the right to host "mighytbyte (owner)" "mightybyte 4 minutes ago", which cuts out horizontal space for the actual content
16:41:07 <nooodl> no results for .: on hoogle :S
16:41:09 <c_wraith> mightybyte, I think the problem is that the v in the formlet declaration is free, meaning haskell infers that it should be chosen by the caller, which means you can't return something of that type.
16:41:17 <joeb_> anyone familiar with building lambdabot?
16:41:22 <parcs> nooodl: f (.:) g = \a b -> f (g a b)
16:41:49 <c_wraith> mightybyte, unless that type v is somehow determined by the other types, in which case a fundep like Phyx- suggests would help
16:41:52 <mightybyte> c_wraith: Yeah, that's what I was thinking.  Is there a way around that?
16:42:32 <nooodl> oh, two-argument (.)?
16:42:33 <Eduard_Munteanu> joeb_: stating the specific issue might help more.
16:42:35 <Phyx-> nooodl: i think it's fmap fmap fmap
16:42:39 <mightybyte> Phyx-: v isn't dependent on a.
16:42:45 <parcs> nooodl: essentially
16:42:46 <mm_freak> is there a good introduction on how extensible exceptions work?
16:42:49 <mightybyte> I guess i can add it to the type class.
16:43:00 <mm_freak> i'm trying to reproduce them to implement semi-OOP
16:43:06 <joeb_> i tried building lambdabot under ghc 6.12 (which it doesnt) then 6.10 but still no go
16:43:23 <Eduard_Munteanu> joeb_: details?
16:44:02 <joeb_> complains that it couldnt find `System.Posix.Signals' in unix-2.4.1.0
16:44:21 <joeb_> i found a thread that sort of addressed this, but didn't see it resolved; getting link
16:44:49 <joeb_> http://web.archiveorange.com/archive/v/nDNOvQMXUGwfkyy0ITet
16:44:52 <mightybyte> Ahh, perfect.  Adding v to the type class makes it work.
16:45:06 <c_wraith> ie, making it multi-parameter?
16:45:14 <mightybyte> Yeah
16:45:54 <Phyx-> there goes your haskell98 compatibility :P
16:46:06 * mightybyte sobs
16:46:20 <Eduard_Munteanu> joeb_: I don't have a clue, but did you try cabal-installing an older version of lambdabot rather than the most recent?
16:46:26 <monochrom> "TypeSynonymInstances" already breaks it
16:46:49 <joeb_> no, i had assumed the most recent would be most likely to be compatible
16:47:29 <Phyx-> oh great... my antivirus deleted a zip file without asking me
16:48:16 <monochrom> how do you know your antivirus is antivirus?
16:48:21 <roconnor> edwardk: the getC and setC together need to be a Lens (StoreT s w a) s, which kinda makes my head spin.
16:48:33 <monochrom> imo norton antivirus is the lamest virus
16:48:47 <Phyx-> monochrom: i use the one from microsoft
16:48:49 <joeb_> Eduard_Munteanu: trying lb-4.1
16:48:58 <Phyx-> doesn't slow my pc to a crawl like norton
16:49:02 <monochrom> ok that's worse than lamest :)
16:49:07 <edwardk> heya roconnor
16:49:13 <Phyx-> monochrom: why?
16:49:27 <Eduard_Munteanu> Meh, Windows people :P
16:49:27 <edwardk> wrestling with the other Context-like comonad, CocontT (which is what i had been calling ContextT)
16:49:42 <monochrom> I don't trust microsoft on competence on this
16:49:56 <Phyx-> Eduard_Munteanu: I'm a windows person and proud of it!
16:50:08 <edwardk> roconnor: what i'm checking for right now is if something like callCV: (CocontT s w (CocontT s w a -> b) -> b) -> b
16:50:14 <Phyx-> monochrom: you have issues
16:50:20 <edwardk> can exist
16:50:28 <monochrom> generally any group other than the kernel group is as incompetent as any company. the kernel group is great.
16:51:04 <Phyx-> oh that's awesome... "Sorry, We know you want it, but 64-bit systems are currently not supported. That's life"
16:51:14 <roconnor> edwardk: ask djinn
16:51:38 <edwardk> roconnor: currently sitting over copumpkin's shoulder while he asks agda ;)
16:51:48 <edwardk> @djinn-env
16:51:49 <lambdabot> data () = ()
16:51:49 <lambdabot> data Either a b = Left a | Right b
16:51:49 <lambdabot> data Maybe a = Nothing | Just a
16:51:49 <lambdabot> data Bool = False | True
16:51:49 <lambdabot> data Void
16:51:51 <lambdabot> type Not x = x -> Void
16:51:53 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
16:51:55 <lambdabot> class Eq a where (==) :: a -> a -> Bool
16:52:04 <roconnor> what no comonad?
16:52:08 <etpace> .
16:52:17 <Phyx-> i hate error messages that try to be funny
16:52:18 <edwardk> i guess lets start easy
16:52:19 <dolio> There's no reason for Monad to be in there.
16:52:22 <Phyx-> atleast lambdabot just insults you
16:52:26 <etpace> it seem No instance for (Typeable7 ((,,,,,,,,) Purpose OrderPlace)) <- can anyone shed some light on this error?
16:52:50 <edwardk> @djinn-add data Cocont s a = Cocont (s -> a) s
16:52:56 <Phyx-> Typeable7? wasn't even aware that existed
16:52:57 <Phyx-> lol
16:53:15 <edwardk> @djinn Cocont s a -> a
16:53:15 <lambdabot> f a =
16:53:15 <lambdabot>     case a of
16:53:16 <lambdabot>     Cocont b c -> b c
16:53:45 <sproingie> you put the lime in the Cocont
16:53:47 <edwardk> @djinn (Cocont s a -> b) -> Cocont s a -> Cocont s b
16:53:47 <lambdabot> f a b =
16:53:47 <lambdabot>     case b of
16:53:47 <lambdabot>     Cocont c d -> Cocont (\ e -> a (Cocont (\ _ -> c d) e)) d
16:54:13 <edwardk> @djinn (Cocont s (Cocont s a -> b) -> b) -> b
16:54:13 <lambdabot> -- f cannot be realized.
16:54:17 * Eduard_Munteanu thinks 'Nt' would suffice there :P
16:54:20 <edwardk> hrmm
16:54:26 <edwardk> yeah =)
16:54:30 <etpace> Phyx-: Data.Typeable
16:54:48 <Phyx-> etpace?
16:54:52 <etpace> I think it might be that i'm trying to make a 9-tuple Typeable and it's not in the default implementation, anyone have ideas what needs to be done
16:54:55 <etpace> that's where typeable comes from
16:55:02 <roconnor> @type callCC
16:55:02 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
16:55:18 <roconnor> edwardk: are you sure that type is right?
16:55:42 <Phyx-> etpace: yes, I know what it is, I just never knew it came with a Typeable7
16:55:56 <edwardk> roconnor: nope
16:55:59 <roconnor> edwardk: I don't like how your a's and b's are sorted
16:56:00 <Phyx-> etpace: look at the code of Typeable7 and add two more?
16:56:01 <etpace> ah, misread the 7 as a ? !
16:56:06 <Eduard_Munteanu> Ah this reminds me... is (* -> *) -> * inhabited / allowed in Haskell?
16:56:11 <roconnor> @djinn (Cocont s (Cocont s b -> a) -> b) -> b
16:56:11 <lambdabot> -- f cannot be realized.
16:56:17 <edwardk> i just flopped the kleisli arrows for cokleisli ones
16:56:22 <pumpkin> Eduard_Munteanu: it's allowed, but only * has values
16:56:24 <edwardk> did i miss a Cocont?
16:56:34 <edwardk> i did
16:56:35 <Phyx-> it kinds seems like the stdlibs pick arbitrary limits of what to support sometimes
16:56:35 <c_wraith> Eduard_Munteanu, isn't that Mu?
16:56:46 <Eduard_Munteanu> Hmm... lemme think...
16:56:47 <mm_freak> ok, reading the source code helped…  man, this implementation is really ugly
16:56:50 <roconnor> edwardk: why does Cocont have a parameter?
16:57:06 <edwardk> why does Cont have a parameter?
16:57:12 <roconnor> oh right
16:57:17 <roconnor> Cont has a parameter
16:57:18 <roconnor> heh
16:57:25 <roconnor> it's so ignorable :P
16:57:25 <edwardk> =)
16:57:27 <mm_freak> what's Cocont?
16:57:45 <edwardk> @djinn-env
16:57:45 <lambdabot> data () = ()
16:57:46 <lambdabot> data Either a b = Left a | Right b
16:57:46 <lambdabot> data Maybe a = Nothing | Just a
16:57:46 <lambdabot> data Bool = False | True
16:57:46 <lambdabot> data Void
16:57:47 <lambdabot> type Not x = x -> Void
16:57:48 <roconnor> edwardk: Also, isn't Cocont a monad instead of a comonad?
16:57:50 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
16:57:51 <lambdabot> class Eq a where (==) :: a -> a -> Bool
16:57:53 <edwardk> shouldn't be.
16:57:53 <lambdabot> data Cocont s a = Cocont (s -> a) s
16:57:54 <Eduard_Munteanu> Wouldn't Mu be (* -> *) -> (* -> *)? It takes a functor and makes a functor.
16:58:00 <mm_freak> (a <- m r) <- m r?
16:58:03 <Eduard_Munteanu> :k Mu
16:58:04 <lambdabot> (* -> *) -> *
16:58:04 <mm_freak> obviously not
16:58:09 <Eduard_Munteanu> Erm, not.
16:58:09 <edwardk> its a left kan extension of a constant functor
16:58:10 <alpounet> Eduard_Munteanu, you have this : data Foo p = Foo (p Int)
16:58:22 <roconnor> edwardk: I thought it was you who said it was due to some contravarience of some functor
16:58:45 <Eduard_Munteanu> I see.
16:58:49 <edwardk> er the Density comonad of a constant functor
16:58:52 <c_wraith> On the other hand, Mu is very general.  There can be many more-specific things with kind (* -> *) -> *.
16:59:00 <monochrom> well it answers the original question! kind (*->*)->* now has a winner
16:59:02 <edwardk> not sure
16:59:05 <banisterfiend> Eduard_Munteanu: oh hey how areyou
16:59:07 <mm_freak> is Cocont useful?
16:59:26 <alpounet> Eduard_Munteanu, (* -> *) -> * just means "give me a parametrized type and i'll give you a type"
16:59:40 <edwardk> mm_freak: working on that. =) its what i was calling the state-in-context-comonad-transformer, before i realized i was pissing all over the useful state-in-context comonad laws
16:59:43 <roconnor> edwardk: something like the dual of the Cont monad is the cont comonad in the opposite category making it the monad (a -> r) -> r in the non-opposite category, which is the Cont monad again.
16:59:46 <edwardk> so now i'm looking for more laws
16:59:57 <Eduard_Munteanu> alpounet: ah, I was thinking in terms of "give me a type operator and I'll give you a type"
17:00:07 <Bynbo7> @djinn Monad m => m a -> (a -> m b) -> m b
17:00:07 <lambdabot> f = (>>=)
17:00:10 <alpounet> well Eduard_Munteanu 
17:00:17 <edwardk> roconnor: not sure, that sounds like my argument against cofunctor
17:00:19 <alpounet> depends on what you mean by type operator
17:00:27 <alpounet> * -> * really just is a -> b at the type level
17:00:45 <Bynbo7> @djinn Monad m => (b -> m c) -> (a -> m b) -> a -> m c
17:00:45 <lambdabot> -- f cannot be realized.
17:01:04 <mm_freak> edwardk: do you see any obvious uses?  because i'm a CPS addict =)
17:01:04 <Bynbo7> eh?
17:01:11 <Bynbo7> :t (>=>)
17:01:12 <Eduard_Munteanu> alpounet: Like some type   f m :: *   where m :: * -> * 
17:01:12 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
17:01:17 <mm_freak> maybe the dual to CPS is also useful
17:01:32 <edwardk> mm_freak: not sure yet. did you go through the right kan extension transformers i wrote?
17:01:32 <Eduard_Munteanu> Yeah.
17:02:00 <alpounet> Eduard_Munteanu, hm, you meant "f :: * -> *" right ?
17:02:41 <Eduard_Munteanu> alpounet: um, no. f looks like it must be (* -> *) -> * there
17:02:45 <mm_freak> edwardk: yes i did and decided i wouldn't use them, but rather write an own library of transformers =)
17:02:48 <alpounet> ooooooh
17:02:54 <alpounet> i misundertood how you meant it
17:02:58 <alpounet> then yes
17:03:10 <mm_freak> edwardk: your library was my inspiration to write contstuff
17:03:17 <alpounet> my 'f' is "apply to Int"
17:03:22 <Bynbo7> @djinn (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
17:03:22 <lambdabot> -- f cannot be realized.
17:03:24 <alpounet> (in my above example)
17:03:33 <Eduard_Munteanu> Ah.
17:03:34 <Bynbo7> you're a liar lambdabot!
17:04:06 <Eduard_Munteanu> :k ReaderT
17:04:07 <lambdabot> * -> (* -> *) -> * -> *
17:04:15 <edwardk> mm_freak: right now i'm just wrestling with the separation of CocontT and ContextT to see what that means ;)
17:04:16 <dolio> Djinn's handling of type classes doesn't support things like Monad appropriately.
17:04:21 <Bynbo7> :t (?f >=> ?g >=> ?h) ?x
17:04:22 <lambdabot> forall a (m :: * -> *) b b1 c. (?f::a -> m b, ?g::b -> m b1, ?h::b1 -> m c, Monad m, ?x::a) => m c
17:04:27 <Eduard_Munteanu> :k MaybeT
17:04:28 <lambdabot> Not in scope: type constructor or class `MaybeT'
17:04:40 <alpounet> :t ContT
17:04:40 <lambdabot> forall a (m :: * -> *) r. ((a -> m r) -> m r) -> ContT r m a
17:04:50 <alpounet> :k ContT
17:04:51 <lambdabot> * -> (* -> *) -> * -> *
17:04:55 <alpounet> :)
17:05:03 <dolio> It just prepends the method types, so you were requesting...
17:05:22 <dolio> (a -> m a) -> (m a -> (a -> m b) -> m b) -> (a -> m b) -> (b -> m c) -> a -> m c
17:05:44 <dolio> With the a and b in the monad operations fixed to the later a and b.
17:05:51 <Eduard_Munteanu> I remember having a discussion here why there are no # -> *, or * -> # kinds.
17:06:13 <dolio> @kind State#
17:06:14 <lambdabot> Not in scope: type constructor or class `State#'
17:06:37 <dolio> @kind GHC.Prim.State#
17:06:39 <lambdabot> * -> #
17:06:56 <Eduard_Munteanu> Ah, I suppose that's an adhoc construct and you can't write custom functors like that?
17:07:11 <edwardk> @djinn Cocont s (Cocont s (Cocont s a -> b) -> a -> a
17:07:11 <lambdabot> Cannot parse command
17:07:21 <edwardk> @djinn Cocont s (Cocont s (Cocont s a -> b) -> a) -> a
17:07:22 <lambdabot> -- f cannot be realized.
17:08:45 <edwardk> @djinn Cocont s (Cocont s (Cocont s a -> a) -> a) -> a
17:08:45 <lambdabot> f a =
17:08:45 <lambdabot>     case a of
17:08:46 <lambdabot>     Cocont b c -> b c (Cocont (\ d e ->
17:08:46 <lambdabot>                                case e of
17:08:46 <lambdabot>                                Cocont f _ -> f d) c)
17:08:53 <edwardk> hrmm
17:09:06 <edwardk> now to find where the b goes
17:10:34 <dolio> Why are we calling state-in-context cocont?
17:11:55 <alpounet> edwardk, meh, it doesn't seem to go anywhere
17:12:12 <Eduard_Munteanu> Damn, I really have to take a look at Coq some time.
17:12:24 <dolio> That's what she said!
17:12:26 <edwardk> dolio: because i separated the state-in-context transformer from the co-cont transformer
17:12:34 <pumpkin> @djinn Cocont s (Cocont s (Cocont s a -> a) -> b) -> b
17:12:34 <lambdabot> f a =
17:12:34 <lambdabot>     case a of
17:12:34 <lambdabot>     Cocont b c -> b c (Cocont (\ d e ->
17:12:34 <lambdabot>                                case e of
17:12:34 <lambdabot>                                Cocont f _ -> f d) c)
17:12:39 <Eduard_Munteanu> Heh.
17:12:41 <edwardk> because the current category-extras contextT doesn't satisfy the laws
17:12:58 <edwardk> (the laws that'd make getC/putC make sense)
17:13:33 <alpounet> pumpkin, the code doesn't change heh
17:13:34 <dolio> Is there some way in which cocont is dual to cont?
17:13:40 <alpounet> (from the case with a's only)
17:13:50 <dolio> Because state-in-context arises from the same adjunction as state, not cont.
17:13:59 <edwardk> cont is the right kan extension of a constant functor, cocont is the left kan extension of a constant functor
17:14:08 <dolio> Ah.
17:14:12 <edwardk> when the functor is identity cocont and context coincide
17:14:48 <edwardk> I'm exploring CocontT s w a = (w s -> a, w s)   vs  ContextT s w a = (w (s -> a), s) 
17:15:11 <edwardk> he latter behaves more nicely for get and put, the former, is more kan-extensiony
17:15:35 <edwardk> for want of a better name i started using cocont a couple of hours ago
17:15:39 <edwardk> er wont
17:17:22 <dolio> Is CocontT related to density?
17:17:27 <edwardk> yes
17:17:32 <dolio> Existentially quantifying over s?
17:18:15 <edwardk> its Density (Const (f s)) a
17:18:20 <dolio> I suppose I can't complain too much, then.
17:18:37 <edwardk> vs. Codensity (Const (f s)) a for ContT
17:18:43 <dolio> Right.
17:19:00 <gwern> hm. CPUs often have lookup tables for trig functions right?
17:19:01 <edwardk> i came on earlier asking for better names than CocontT ;)
17:19:14 <edwardk> tryng to steer folks away from NtT and Coconut
17:19:21 <dolio> Heh.
17:19:36 <Zao> Concoct
17:19:37 <roconnor> edwardk: found it:  http://www.rhinocerus.net/forum/lang-haskell/294851-what-would-continuation-comonad-look-like-just-being-curios-p.html#post1429476
17:20:19 <roconnor> edwardk: the continuation monad is the adjoint of F x = x -> o and G x = x -> o
17:20:37 <roconnor> so together you get cont x = (x -> o) -> o
17:20:46 <Eduard_Munteanu> You might want to preserve the second 'c' capitalized though... like CoContT
17:20:51 <roconnor> so cocont will be those functiors with the order filled around
17:20:55 <edwardk> yes, every monad can be built out of an adjunction, but the choice of adjunction isn't unique
17:21:11 <roconnor> edwardk: what is the adjunction you are trying to use?
17:21:12 <edwardk> and isn't necessarily an adjunction on endofunctors over Hask
17:22:19 <edwardk> i was honestly starting from the left kan extension of a constant functor, there is a relationship between adjunctions and kan extensions. i blogged about it a while back.
17:22:39 <edwardk> the fact that CocontT is a comonad is trivial to prove, its a density comonad.
17:22:45 <etpace> could anyone elaborate on the error: http://hpaste.org/42752/hskl i've pretty much just copy and pasted and adjusted the same format of Typeable6/7
17:23:09 <edwardk> whether it deserves 'cocont' as a name is another matter =)
17:24:36 <edwardk> http://comonad.com/reader/2008/kan-extensions-ii/ talked about the connections between kan extensions and adjunctions
17:26:16 <roconnor> edwardk: what is the definition of Cocont in terms of Lan?
17:26:30 <edwardk> mm_freak: anyways i don't anticipate any cps-like performance increases. i gave a counter argument at one point as to why the codensity was more useful for density
17:26:59 <edwardk> Lan (Const (w s)) (Const (w s)) a = Density (Const (w s)) a
17:27:29 <Eduard_Munteanu> edwardk: do you blog about use-cases of some less well-known stuff from category-extras?
17:27:34 <Eduard_Munteanu> *also blog
17:27:48 <edwardk> with newtype ConstT f s a = ConstT (f s) — its Density (ConstT f s) a
17:28:31 <Eduard_Munteanu> I could certainly add some more abstractions to my bag of tricks.
17:28:42 <edwardk> ConstT f s is clearly of kind * -> *, so Density (ConstT f s) is a comonad
17:29:08 <edwardk> Eduard_Munteanu: part of why i'm doing this is to go through and fix up some of those dark corners ;)
17:29:49 <mm_freak> edwardk: IIRC codensity can improve performance asymptotically in some cases
17:30:14 <edwardk> mm_freak: yes, but that is because monads are about substitution and grow. comonads are about redecoration and remain the same shape
17:30:19 <mm_freak> edwardk: but i'm doing CPS for the CPS effects, not for performance, although the higher performance is an additional bonus, which i'm glad to take =)
17:30:36 <edwardk> mm_freak so the argument that enables codensity to improve your asymptotics doesn't work for a density comonad.
17:30:47 <mm_freak> edwardk: so far i couldn't find any use for comonads
17:30:59 <pastorn> I'm having some trouble with compiling GL + SDL code
17:31:00 <mm_freak> maybe that's because of missing syntactic sugar
17:31:07 <edwardk> i have lots of uses for them, but they don't resemble the uses of monads ;)
17:31:11 <pastorn> if i optimize more than -O0 i get artifacts
17:31:31 <mm_freak> edwardk: perhaps i just didn't understand them yet as much as i understand monads =)
17:32:16 <EvanR> pastorn: eh?
17:32:18 <edwardk> simultaneous-play-games, automata, image blurring, type-safe annotated-ropes, type-safe annotated graphs, etc.
17:32:49 <roconnor> edwardk: tell me about simultaneous-play-games
17:32:57 <pastorn> EvanR: have you ever had problems like that?
17:32:59 <roconnor> oh wait
17:33:03 <edwardk> name supplies, memoizing-computations-in-context
17:33:04 <roconnor> I guess I see that
17:33:07 <mm_freak> edwardk: are there examples?
17:33:29 <edwardk> mm_freak: i never did get around to capturing these in something convenient for others ;)
17:33:40 <EvanR> pastorn: what kind of artifacts?
17:33:47 <mm_freak> edwardk: it doesn't have to be convenient, it just needs to work =)
17:33:52 <pastorn> EvanR: dumpin screens...
17:34:34 <edwardk> there are also some nice examples of comonadic 'segments' for FRP, though you need to tweak conal's examples slightly
17:34:43 <mm_freak> edwardk: not even actual example code, but comonad definitions would suffice
17:34:51 <mm_freak> usually i can work out their meanings by looking at them
17:34:55 <edwardk> category-extras gives quite a few comonads
17:35:22 <mm_freak> yeah, but their names are scary and resemble their math structure rather than their purpose
17:35:37 <edwardk> cofree comonads are useful for generalizing streams. i use the cofree comonad in my automatic differentiation library to return all of the higher order derivatives of a function in a nicely pre-zipped container
17:36:43 <edwardk> http://hackage.haskell.org/packages/archive/ad/0.45.0/doc/html/Numeric-AD-Mode-Sparse.html#v:grads
17:37:17 <edwardk> that returns a comonadic 'f-branching stream' aka cofree comonad, which can be decomposed into a Tensors to access layer by layer if you don't care about the zippage
17:38:50 <pastorn> http://users.mkeyd.net/~alexander/gl-sdl-O0.png
17:38:52 <pastorn> http://users.mkeyd.net/~alexander/gl-sdl-O1.png
17:38:54 <pastorn> http://users.mkeyd.net/~alexander/gl-sdl-O2.png
17:38:56 <pastorn> http://users.mkeyd.net/~alexander/gl-sdl-O3.png
17:39:07 <pastorn> O2 and O3 seems identical, O0 is "as it should be"
17:39:23 <edwardk> that lets you ask for something like grads (\[x,y] -> x * cos y + exp x) [1,2] and get all the nth derivatives in one tidy little bundle
17:39:28 <roconnor> mm_freak: 
17:39:29 <pastorn> (which is also obtained with runhaskell and ghci> main)
17:39:32 <roconnor> The comonad laws:
17:39:33 <roconnor> Kleisli composition forms
17:39:35 <roconnor> a category. 
17:39:48 <edwardk> roconnor: i think you broke haiku meter ;)
17:40:34 <dolio> That's 5 7 5, isn't it?
17:40:41 <roconnor> I tried to keep the sylable count the same
17:40:41 <edwardk> oh yeah it is
17:40:50 <edwardk> the usually one is 'monad axioms' i forgot
17:40:51 <roconnor> Monad axioms:
17:40:52 <roconnor> Kleisli composition forms
17:40:54 <roconnor> a category. 
17:40:55 <EvanR> roconnor: nice
17:40:57 <EvanR> i mean
17:40:59 <EvanR> pastorn: nice
17:41:37 <EvanR> pastorn: optimizations broke something?
17:41:39 <pastorn> EvanR: yes, extremely
17:41:43 <edwardk> ok, heading home
17:41:45 <edwardk> bbiab
17:42:01 <pastorn> i'm thinking of doing a Makefile and have a list of which optimization flags to use, then find the ones breaking my shit
17:42:01 <EvanR> must be in haskell
17:42:12 <EvanR> are you doing any pointer stuff
17:42:15 <EvanR> or bits and bytes
17:42:17 <pastorn> EvanR: yes
17:42:31 <EvanR> are you using any fishy types like Int
17:42:34 <pastorn> though i didn't write that code myself
17:42:43 <pastorn> EvanR: yes, have i been naughty?
17:42:45 <EvanR> i dont know all the effectives of O1
17:42:49 <mm_freak> hmm
17:42:51 <EvanR> effects
17:43:01 <pastorn> EvanR: note that O1 and O2/O3 differs :D
17:43:05 <mm_freak> i wish there were some usage examples for category-extras
17:43:13 <EvanR> i see that
17:43:16 <mm_freak> in the haddock docs i mean
17:43:21 <pastorn> (this in on an ATI HD 3870 in ubunt with an ATI binary blob driver)
17:43:31 <EvanR> its likely not the driver
17:43:57 <EvanR> pastorn: if this were C i would say painstakingly print out the result of your pixel pushing operations until you find where the difference is
17:44:07 <EvanR> i guess theres a way in haskell to do it
17:44:12 <pastorn> mapM?
17:44:17 <EvanR> debug.trace
17:44:54 <roconnor> @quote oasis
17:44:54 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
17:45:09 <pastorn> EvanR: i don't get it, what should i do, do you say?
17:45:27 <pastorn> should i dump the pixeldata to files and compare?
17:45:43 <Eduard_Munteanu> @hoogle trace
17:45:44 <lambdabot> Debug.Trace trace :: String -> a -> a
17:45:44 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
17:45:44 <lambdabot> module Debug.Trace
17:45:57 <EvanR> pastorn: verify that each of your operations works
17:46:16 <EvanR> displaying intermediate pixel data should work, assuming you can display correctly
17:46:24 <pastorn> ehm... how do i do that? some cool GL.getOpenGLError?
17:46:43 <FauxFaux> OpenGL doesn't have errors.
17:46:49 <EvanR> opengl does have errors
17:46:52 <latros> lol...
17:46:54 <pastorn> oh, maybe that code i saw was just glut
17:46:57 <Eduard_Munteanu> Bah, debugging ("impure") Haskell code sucks.
17:46:58 <latros> opengl doesn't have errors
17:47:07 <latros> er
17:47:10 <latros> lol @ that concept
17:47:18 <pastorn> FauxFaux, EvanR, latros: OKAY! I GET IT!
17:47:23 <EvanR> http://www.opengl.org/sdk/docs/man/xhtml/glGetError.xml
17:47:31 <EvanR> but i wasnt saying to use that
17:47:34 <pastorn> ;)
17:47:37 <FauxFaux> Good luck with that returning anything ever.
17:47:42 <EvanR> true
17:47:52 <EvanR> it shouldnt happen
17:47:59 <EvanR> doesnt mean it doesnt have errors
17:48:49 <EvanR> pastorn: you didnt write your graphics code?
17:49:14 <pastorn> EvanR: no, i'm working on this with a friend... i've been messing with SDL and threading, as you know ;)
17:49:22 <EvanR> recipe for disaster
17:49:42 <pastorn> EvanR: so i've noticed
17:50:04 <EvanR> tell your friend to verify his graphics code independently, perhaps with test cases, with and without optimizataions
17:53:30 <pastorn> i still don't get what you mean by "verify"
17:54:54 <pastorn> but earlier he tald me that he got a cool graphics bug because he used GLUnsignedChar and not GLByte, or something similarly cool
17:55:25 <EvanR> yes, verification
17:55:29 <EvanR> make sure it works (tm)
17:57:00 <roconnor> @hoogle traverse
17:57:00 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
17:57:00 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
17:57:27 <pastorn> hmmm... could make a giant colour palette
17:57:42 <cgray> hi, I've got a file (not my own) that will compile with ghc that I would like to load into ghci, but it's not working.  Is that a normal thing?
17:57:56 <ManateeAuthor> Hi, all. :)
17:58:09 <c_wraith> ManateeAuthor, you're not a lazy cat anymore? :)
17:58:23 <ManateeAuthor> c_wraith: Hehe. :)
17:59:12 <pastorn> anyone who can help me a little with automake?
17:59:27 <c_wraith> cgray, that's not a normal thing, but it's not exactly strange either.  Can you put the error message you're getting into a pastebin somewhere?
17:59:42 <cgray> c_wraith: sure, just a sec
18:00:34 <mm_freak> edwardk: this is my main problem with category-extras:  to understand a tiny bit of it, you need to understand almost half of the library
18:00:44 <mm_freak> i have very little CT experience
18:01:21 <edwardk> mm_freak: thats why i'm starting to break it up a bit
18:01:56 <roconnor> edwardk: I want you to break out a H98 chunk
18:01:59 <aavogt> edwardk: are you creating anything as bad as Monad/Applicative/Functor-situation?
18:02:03 <cgray> c_wraith: http://haskell.pastebin.com/7h2rZ1jx (hopefully that's enough info, let me know if it's not)
18:02:20 <roconnor> edwardk: we need a proper H98 compatable comonad module
18:02:29 <edwardk> roconnor: thats what prompted this
18:02:32 <aavogt> H10?
18:02:45 <edwardk> i put together a comonad package, and started building comonad-transformers for symmetry
18:03:10 <edwardk> i wanted a standardizable comonad package (minimalist, h98, no copointed even)
18:03:10 <c_wraith> cgray, ok...  That particular error should happen in both ghci and ghc, or neither.  Unless for some reason, they're loading different libraries.
18:03:31 <roconnor> edwardk: what are the odds I can get you to name it Store?
18:03:32 <edwardk> and a comonad-transformers, comonads-tf and comonads-fd, but for the latter 3 i needed consistent laws i could rely upon
18:03:33 <cgray> c_wraith: that makes sense.  
18:03:52 <edwardk> better than 0, less than 1 ;)
18:04:13 <roconnor> edwardk: if I get my paper published will you call it Store?
18:04:17 <c_wraith> cgray, I've gotta run though, so I can't help you track down.  Good luck with that. :)
18:04:28 <roconnor> come on, Store/State duality.  It's perfect
18:04:38 <cgray> c_wraith: np, thanks for the halp :)
18:04:39 <roconnor> you know you want to
18:04:46 <edwardk> right now i'm more concerned with internal consistency ;)
18:04:59 <edwardk> the hard one to bring myself to keep namewise is Cocont
18:05:01 <roconnor> :D
18:05:10 <mm_freak> edwardk: i think once you know the library well it's good to define things in terms of other things where possible, but for a beginner this is really tiring
18:05:29 <mm_freak> i've tried very often to understand and use category-extras, but i gave up each time
18:05:34 <edwardk> mm_freak: my goal right now is to peel apart category-extras into easy stuff and hard stuff, this sadly requires a LOT of packages ;)
18:05:43 <mm_freak> including my current attempt to understand Cofree
18:06:00 <edwardk> yeah cofree is an example of something made way too complicated by being general
18:06:19 <edwardk> its easier as data Cofree f a = Cofree a (f (Cofree f a))
18:06:35 <edwardk> or even  data Stream f a = a :> f (Stream f a)
18:07:09 <edwardk> (it'll probably become Stream in comonad-transformers
18:07:26 <mm_freak> edwardk: now that makes MUCH more sense
18:08:03 <edwardk> the other definition allows it to work better with the various bicata, etc. combinators in Conrol.Recursion
18:08:19 <mm_freak> and by parameterizing 'f' this is a generic stream type, which can also represent trees, graphs, etc. and not just lists, right?
18:08:29 <edwardk> because you can use it as a bifunctor fixed point of a PComonad
18:08:29 <edwardk> but that is rarely useful =)
18:08:29 <edwardk> yeah
18:08:42 <mm_freak> interesting
18:08:54 <edwardk> the combinators futu and histo are designed to work with (Co)free comonads, though they are ALSO generalized inc ategory extras
18:09:02 <banisterfiend> edwardk: what's a bifunctor
18:09:05 <edwardk> to work over (co)density (co)monads of (co)free (co)monads ;)
18:09:34 <edwardk> banisterfiend: class Bifunctor p where bimap :: (a -> b) -> (c -> d) -> p a c -> p b d
18:09:49 <mm_freak> i'm not questioning the usefulness of this genericity, but it's painful to get into it =)
18:09:51 <edwardk> instance Bifunctor (,); instance Bifunctor Either; etc.
18:10:11 <edwardk> mm_freak: yeah. like i said, i want to redo things so the easy definitions come first ;)
18:10:13 <banisterfiend> edwardk: sounds complicated
18:10:36 <edwardk> banisterfiend: nah, think of mapping over the first and second element of a tuple or a sum
18:11:01 <edwardk> instance Bifunctor Either where bimap f g (Left a) = Left (f a); bimap f g (Right b) = Right (g b)
18:11:03 <mm_freak> banisterfiend: Bifunctor is like Functor, but for two element types, if you think in containers
18:11:13 <edwardk> instance Bifunctor (,) where bimap f g (a, b) = (f a, g b)
18:11:26 <Eduard_Munteanu> I'm not sure how genuinely interested banisterfiend is in this stuff...
18:11:38 <Eduard_Munteanu> But I'll let you have fun if you wish. :)
18:11:47 <geheimdienst> > fmap succ (3,5)
18:11:47 * edwardk tends to give folks the benefit of the doubt ;)
18:11:48 <lambdabot>   (3,6)
18:11:49 <mm_freak> Bifunctor is one of the easy parts of category-extras =)
18:12:10 <geheimdienst> > bimap succ pred (3,5)
18:12:11 <lambdabot>   Not in scope: `bimap'
18:12:22 <edwardk> now, what i'd like to do is see if the callCV definition above is actually useful
18:12:41 <latros> > import Control.Bifunctor
18:12:43 <lambdabot>   <no location info>: parse error on input `import'
18:12:44 <edwardk> bifunctors as used in category-extras unfortunately conflict with the common arrow names for first and second 
18:12:47 <latros> ...
18:12:50 <roconnor> edwardk: want to know something else cool about Lenses?
18:12:51 <latros> lambdabot can't import :(
18:12:55 <Eduard_Munteanu> lambdabot doesn't know about category-extras
18:13:15 <edwardk> and the definition style i used there while permitting more uses of first and second, runs afoul of requiring more boilerplate to instantiate one
18:13:18 <Eduard_Munteanu> @vixen You should learn some CT, you know...
18:13:19 <lambdabot> yeah, i know
18:13:33 <edwardk> roconnor: i do, but i'm at by T-stop. i'll have to find out when i get home ;)
18:13:43 <edwardk> er at my
18:13:45 <roconnor> ok
18:13:47 <geheimdienst> but theoretically, «bimap succ pred (3,5)» would kinda give (4,4), right?
18:13:57 <edwardk> geheimdienst: yeah
18:14:00 <mm_freak> i think just like you can understand functors and monads without understanding CT, you can also understand category-extras without understanding CT
18:14:17 <Eduard_Munteanu> geheimdienst: I don't think it can do anything else
18:15:35 <Eduard_Munteanu> Well yeah, but you'll reinvent some CT along the way, maybe in laymen terms, but still.
18:15:49 <Eduard_Munteanu> Like, Yoneda.
18:15:51 <mm_freak> class Bimonad m where return1 :: a -> m a b; return2 :: b -> m a b; bibind :: m a b -> (a -> m c d) -> (b -> m c d) -> m c d
18:15:54 <mm_freak> does that make sense?
18:16:32 <hpc> > let bimap = (***) in bimap succ pred (3, 5)
18:16:34 <lambdabot>   (4,4)
18:17:03 <copumpkin> mm_freak: got mcdonalds on your mind?
18:17:09 <etpace> where can I download the sources for all of the stdlibs?
18:17:13 <mm_freak> copumpkin: =P
18:17:20 <mm_freak> etpace: hackage
18:17:28 <mm_freak> etpace: look for the 'base' library
18:17:31 <etpace> cheers
18:17:33 <Eduard_Munteanu> mm_freak: bibind there looks strange
18:17:34 <mm_freak> it's in "unclassified"
18:17:53 <etpace> i'm trying t ofind out how the instance of (,,) is defined for Typeable3, but i can't see it in Data.Typeable
18:17:57 <mm_freak> Eduard_Munteanu: the terms are made up, but the class itself might be useful
18:18:11 <geheimdienst> etpace, to just have a look at them, you can use the "Source" links in the top right corner of documentation pages
18:18:11 <mm_freak> etpace: you don't need to download the sources for that
18:18:24 <etpace> the instances are not in Data.Typeable
18:18:28 <etpace> or atleast i cannot find it
18:18:34 <gienah> beginner question: what does the first . in this do?
18:18:34 <mm_freak> etpace: just open the package page on hackage…  every module documentation has a 'Source' link
18:18:36 <gienah> @pl (\x acc -> 2 ( acc + x))
18:18:37 <lambdabot> (2 .) . (+)
18:18:38 <Eduard_Munteanu> Nah, I mean bibind could have kinda arbitrary behavior.
18:18:46 <geheimdienst> hpc: neat, btw
18:18:53 <hpc> geheimdienst: it's just arrows
18:19:17 <gienah> that was surprising, I thought it would print (. (2 *)) . (+)
18:19:45 <hpc> gienah: because 2(x) is not 2 * x
18:19:50 <geheimdienst> ... Arrows to me are a thoroughly incomprehensible part of haskell ... i know &&& and that's it
18:19:51 <gienah> @pl (\x acc -> 2 * ( acc + x))
18:19:51 <lambdabot> ((2 *) .) . (+)
18:19:52 <mm_freak> gienah: \x y -> f (g x y) = \x -> f . g x = \x -> (f .) (g x) = (f .) . g
18:20:04 <hpc> > 2 3 4 5
18:20:05 <lambdabot>   2
18:20:09 <geheimdienst> now i know *** as well, which is a knowledge increase of 100%
18:20:12 <latros> lolwut
18:20:12 <hpc> > foldr 1 [2..]
18:20:13 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [t])
18:20:14 <lambdabot>    arising from a use ...
18:20:18 <hpc> > foldr id 1 [2..]
18:20:19 <lambdabot>   No instance for (GHC.Enum.Enum (b -> b))
18:20:19 <lambdabot>    arising from a use of `e_112' a...
18:20:23 <latros> 2 3 4 5 -> 2, wut
18:20:38 <mm_freak> gienah: it's just a consequence of making a binary function composition point-free
18:20:47 <hpc> instance Num b => Num (a -> b) where fromIntegral = const . fromIntegral
18:20:50 <geheimdienst> latros, it's a quirk of lambdabot
18:20:51 <hpc> etc
18:20:58 <etpace> http://hackage.haskell.org/packages/archive/base/4.3.0.0/doc/html/src/Data-Typeable.html <- i'm expanding this to support 9-ary type constructors which is fine - but i need to find out how to make a 9-ple an instance of Typeable9, does anyone know?
18:21:00 <mm_freak> gienah: as a side note, maximum point-freeness isn't always good
18:21:20 <gienah> @pl (\x acc -> 2 * acc + x)
18:21:20 <lambdabot> (. (2 *)) . (+)
18:21:25 <mm_freak> Eduard_Munteanu: if you assign some laws to this, then maybe not
18:21:30 <hpc> maximum point-freeness gives us shit like SK calculus
18:21:47 <hpc> which is cool, if you are a psychotic mathematician
18:21:48 <mm_freak> Eduard_Munteanu: also that's true for normal (>>=) as well…  a type often can have many interpretations
18:21:49 <gienah> that's it, I mean the first . in (. (2 *)) . (+) sorry for asking the wrong question earlier
18:22:44 <mm_freak> hpc: SK calculus isn't that bad, once you understand that pure and <*> are generalizations of K and S, respectively
18:22:58 <hpc> mm_freak: yeah, i caught that quite quickly
18:23:18 <mm_freak> sometimes i prefer SK notation, because it makes clear what you mean
18:23:28 <azaq231> Is there a unction in the standard library with the behaviour x `function` y = x >>= (\z -> y >> return z)?
18:23:36 <mm_freak> > pure zip <*> inits <*> tails $ "abcde"
18:23:37 <lambdabot>   [("","abcde"),("a","bcde"),("ab","cde"),("abc","de"),("abcd","e"),("abcde",...
18:24:10 <mm_freak> azaq231: (<*)
18:24:23 <mm_freak> it's in Control.Applicative
18:24:31 <mm_freak> > Just 2 <* Just 3
18:24:32 <lambdabot>   Just 2
18:25:06 <hpc> (<*) is one of the easiest to forget functions
18:25:11 <roconnor> > Just 2 *> Just 3
18:25:12 <lambdabot>   Just 3
18:25:16 <etpace> :ty (<*)
18:25:17 <geheimdienst> > Just 2 <*> Just 3
18:25:18 <lambdabot>   Just 2
18:25:22 <etpace> :t (<*)
18:25:23 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
18:25:24 <geheimdienst> ha ha ha
18:25:30 <mm_freak> hpc: not if you write many parsers =)
18:25:40 * roconnor usually uses <* or *> with the Constant monoid applicative functor where they are the same.
18:26:32 <mm_freak> char '(' *> skipSpace *> someToken <* skipSpace <* char ')'
18:26:47 <hpc> oh that's scary
18:26:53 <roconnor> nice
18:27:02 <mm_freak> what's scary about that?
18:27:06 <latros> what's char?
18:27:13 <roconnor> @hoogle char
18:27:13 <lambdabot> Text.Parsec.Char char :: Stream s m Char => Char -> ParsecT s u m Char
18:27:13 <lambdabot> Text.ParserCombinators.ReadP char :: Char -> ReadP Char
18:27:13 <lambdabot> Text.PrettyPrint.HughesPJ char :: Char -> Doc
18:27:14 <azaq231> that's actually what I wanted that for
18:27:16 <hpc> the way it "crunches" the line towards the middle
18:27:16 <mm_freak> latros: a specific character parser
18:27:16 <azaq231> thanks
18:27:29 <roconnor> char :: Stream s m Char => Char -> ParsecT s u m Char
18:27:31 <geheimdienst> > map (++) $ map (take 2) $ words "constant monoid applicative functor"
18:27:33 <lambdabot>   Overlapping instances for GHC.Show.Show
18:27:33 <lambdabot>                              ([GHC....
18:27:41 <mm_freak> azaq231: if you're using parsec, there is a function for that specific use case, i think it's called 'between'
18:27:47 <edwardk> roconnor: now, you were saying? =)
18:27:50 <geheimdienst> > concat $ map (take 2) $ words "constant monoid applicative functor"
18:27:52 <lambdabot>   "comoapfu"
18:28:01 <hpc> :t between
18:28:02 <lambdabot> Not in scope: `between'
18:28:07 <hpc> @hoogle between
18:28:08 <lambdabot> Text.Parsec.Combinator between :: Stream s m t => ParsecT s u m open -> ParsecT s u m close -> ParsecT s u m a -> ParsecT s u m a
18:28:08 <lambdabot> Text.ParserCombinators.ReadP between :: ReadP open -> ReadP close -> ReadP a -> ReadP a
18:28:08 <lambdabot> Text.ParserCombinators.Parsec.Combinator between :: Stream s m t => ParsecT s u m open -> ParsecT s u m close -> ParsecT s u m a -> ParsecT s u m a
18:28:35 <mm_freak> hpc: those combinators are very useful with applicative style parsers
18:28:37 <hpc> ooh, that looks like a fun function
18:28:45 <hpc> especially if you curry out the last argument
18:28:45 <hpc> yeah
18:28:57 <edwardk> hrmm, so any good examples of callCC that i can try to adapt to callCV?
18:29:39 <roconnor> edwardk: Lens record field = forall f : Functor. (field -> f field) -> (record -> f record)
18:29:46 <roconnor> edwardk: and ...
18:30:25 <edwardk> roconnor: i have that one in my scala lenses =)
18:31:06 <roconnor> edwardk: the get and set laws hold exactly when that object is a monoidal natural transformation from (/\ f -> Algebra field f) to (/\ f -> Algebra record f)
18:31:09 <mm_freak> Eduard_Munteanu: you can implement goto using callCC
18:31:11 <mm_freak> uhm
18:31:12 <mm_freak> that was @ edwardk
18:31:48 <mm_freak> edwardk: http://hackage.haskell.org/packages/archive/contstuff/1.2.0/doc/html/src/Control-ContStuff-Classes.html#Label
18:31:57 <edwardk> roconnor: thats the comonad coalgebra stuff in other words, no?
18:32:04 <edwardk> https://github.com/scalaz/scalaz/blob/master/core/src/main/scala/scalaz/Lens.scala
18:32:21 <roconnor> edwardk: I don't know.  You tell me.  Wait did I already write this in my blog?
18:32:27 <edwardk> i think
18:32:30 <edwardk> at least the laws
18:32:46 <roconnor> no nothing about monoidal natural transformations
18:32:53 <roconnor> edwardk: anyhow, you tell me
18:33:08 <mm_freak> what is callCV anyway?
18:33:10 <roconnor> what is the relationship between monoidal natural transformations and coalgebras of comonads?
18:33:16 <edwardk> mm_freak: something i made up an hour ago ;)
18:33:46 <azaq231> yes, between is indeed helpful - also, the function I described (for monads) is liftM2 const, and (<*) is defined as liftA2 const, pretty nice
18:34:02 <edwardk> @djinn Cocont s (Cocont s (Cocont s a -> a) -> b) -> b
18:34:02 <lambdabot> f a =
18:34:02 <lambdabot>     case a of
18:34:03 <lambdabot>     Cocont b c -> b c (Cocont (\ d e ->
18:34:03 <lambdabot>                                case e of
18:34:03 <lambdabot>                                Cocont f _ -> f d) c)
18:34:04 <edwardk> that
18:34:18 <mm_freak> @src (<*)
18:34:19 <lambdabot> (<*) = liftA2 const
18:34:23 <edwardk> not sure why the a's and b's don't like up exactly with the ones from callCC yet though
18:34:49 <edwardk> since i derived it by analogy, not exactly rigorous reasoning ;)
18:34:56 <roconnor> edwardk: I can read Cocont as Store?
18:35:34 <edwardk> if it makes you feel better
18:35:40 <edwardk> though the transformer and the store transformer differ
18:35:51 <edwardk> =)
18:36:05 <hpc> roconnor: you can read it as Coconut too
18:36:35 <edwardk> newtype CocontT s w a = Cocont (w s -> a) (w s) — newtype ContextT s w a = ContextT (w (s -> a)) s
18:36:48 <edwardk> is what i'm currently using
18:37:21 <edwardk> the latter is designed to satisfy your store laws, the former is designed to behave like a density comonad
18:37:26 <mikeg> @versio
18:37:26 <lambdabot> lambdabot 4.2.2.1
18:37:27 <lambdabot> darcs get http://code.haskell.org/lambdabot
18:37:34 <roconnor> edwardk: as for as I know this represenation of lenses as monoidal natural transformations of functors from functors to types has nothing to do the the coalgebra of the store comonad definition.
18:37:44 <edwardk> hrmm
18:37:52 <mikeg> does lambdabot have a command to get the compiler version?
18:37:56 <edwardk> i'll need to chew on that one for a bit
18:38:09 <roconnor> nothing to do other than the fact that they are absolutely the same thing.
18:38:34 <edwardk> the fact that they prove exactky the same thing says there is some kind of deeper relationship there ;)
18:38:41 <roconnor> *functors from functors to algebras
18:40:13 <roconnor> I guess the category of algebras is monoidal.
18:44:31 <deech> Hi all, could I get some help understanding the navigation primitives in Huet's zipper? (http://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/huet-zipper.pdf)
18:46:39 <geheimdienst> suppose i'm working on ungodly new xmonad modules, and suppose i'd like to glue a ReaderT onto the X monad. X already is a Reader. how could i distinguish between ask-provided-by-X and ask-provided-by-my-ReaderT?
18:46:40 <roconnor> deech: have you seen the wikibook?
18:46:44 <roconnor> I find it pretty clear
18:47:12 <deech> roconnor: You mean the once with Theseus and the Labyrinth?
18:47:17 <roconnor> geheimdienst: I think calling lift on ask might work?
18:47:20 <hpc> geheimdienst: count the number of "lift"
18:47:23 <roconnor> deech: that sounds right
18:48:31 <geheimdienst> ok, so «ask» would be asking my ReaderT and «lift ask» would be asking X?
18:48:40 <hpc> yes
18:48:54 <geheimdienst> sounds very good. thanks guys.
18:48:56 <roconnor> geheimdienst: you might want to name these two functions :D
18:49:11 <hpc> well, "ask" already has a name :P
18:49:12 <deech> roconnor: I have looked at that, but Huet's primitives seem quite different. 
18:49:21 <geheimdienst> askmoar
18:49:35 <hpc> inquire
18:49:37 <geheimdienst> x <- icanhas
18:49:42 <geheimdienst> x <- icanmoarhas
18:49:58 <deech> And, yes, the wikibook is quite clear. I was just trying to wrap my head around the paper.
18:50:03 <hpc> icanhas >>= ohai
18:50:28 <hpc> lotsofoneses = yoDawg (1:)
18:51:04 <geheimdienst> yo dawg, i herd u like cons cells, so we put a cons cell in ya cons cell
18:51:29 <monochrom> so you can pattern-match while you pattern-match
18:51:32 <roconnor> deech: ah sorry to abandon you but I need to go.
18:51:36 <pastorn> @type repeat
18:51:37 <lambdabot> forall a. a -> [a]
18:51:40 <hpc> > fix ("yo dawg, i heard you like "++)
18:51:42 <lambdabot>   "yo dawg, i heard you like yo dawg, i heard you like yo dawg, i heard you l...
18:51:57 <pastorn> @type iterate
18:51:58 <lambdabot> forall a. (a -> a) -> a -> [a]
18:52:02 <hpc> :t join . repeat
18:52:03 <lambdabot> forall a. [a] -> [a]
18:53:08 <deech> roconnor: Thanks I appreciate the help.
19:01:48 <Kaidelong> hpc you are my hero
19:02:31 <geheimdienst> he's gone
19:02:44 <geheimdienst> off to save some damsel in distress, i presume
19:02:53 <monochrom> when a hero is gone, that's when people recognize the hero
19:03:02 <Kaidelong> also "fix . (++)" is actually a pretty elegant definition of repeat
19:03:35 <monochrom> @type fix . (++)
19:03:36 <lambdabot> forall a. (Monoid a) => a -> a
19:03:40 <monochrom> @type repeat
19:03:42 <lambdabot> forall a. a -> [a]
19:03:51 <monochrom> @type cycle
19:03:52 <lambdabot> forall a. [a] -> [a]
19:03:59 <geheimdienst> > fix . (++) "lolcats"
19:04:01 <lambdabot>   Couldn't match expected type `a -> a'
19:04:01 <lambdabot>         against inferred type `[GHC.T...
19:04:03 <monochrom> cycle is closer to fix . (++)
19:04:09 <geheimdienst> > repeat "lolcats"
19:04:10 <lambdabot>   ["lolcats","lolcats","lolcats","lolcats","lolcats","lolcats","lolcats","lol...
19:04:27 <djahandarie> @type (cycle, fix . (Prelude.++))
19:04:29 <lambdabot> forall a a1. ([a] -> [a], [a1] -> [a1])
19:04:39 <monochrom> > (fix . (++)) "lolcats"
19:04:41 <Kaidelong> > fix . (++) $ "lolcats"
19:04:41 <lambdabot>   "lolcatslolcatslolcatslolcatslolcatslolcatslolcatslolcatslolcatslolcatslolc...
19:04:43 <lambdabot>   "lolcatslolcatslolcatslolcatslolcatslolcatslolcatslolcatslolcatslolcatslolc...
19:04:54 <Kaidelong> oh, yes, you're right
19:04:58 <Kaidelong> that's what he did, cycle
19:05:00 <Kaidelong> not repeat
19:05:02 <Kaidelong> herp
19:05:48 <Kaidelong> @ty fix . (:)
19:05:49 <lambdabot> forall a. a -> [a]
19:06:01 <monochrom> yeah that's repeat :)
19:06:05 <shachaf> > fix (const cycle) $ "abc"
19:06:06 <lambdabot>   "abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcab...
19:06:54 <djahandarie> fix const fusion for eliminating intermediate recursion!
19:07:01 * djahandarie makes millions
19:10:27 <parcs> > fix . (++) $ Nothing
19:10:31 <lambdabot>   mueval-core: Time limit exceeded
19:12:20 <shachaf> @ty (++)
19:12:21 <lambdabot> forall m. (Monoid m) => m -> m -> m
19:12:43 <shachaf> Naturally.
19:13:14 <parcs> > fix . (++) $ Product 0
19:13:18 <lambdabot>   mueval-core: Time limit exceeded
19:14:05 <parcs> i am disappoint, ghc 
19:14:15 <azaq231> > fix (const "something")
19:14:16 <lambdabot>   "something"
19:15:13 <shachaf> Cale: Is lambdabot going to get "infixl $"?
19:15:28 <djahandarie> lol
19:15:50 <djahandarie> That could possibly be more confusing than all the other things in lambdabot
19:18:10 <shachaf> djahandarie: Well, it's the next logical step.
19:18:56 <parcs> > fix . (++) $ All False
19:18:58 <lambdabot>   All {getAll = False}
19:19:01 <parcs> yay
19:19:48 <shachaf> lambdabot should generalize cycle.
19:20:09 <aavogt> @ty foldr
19:20:10 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
19:20:16 <aavogt> @ty Data.Foldable.foldr
19:20:16 <lambdabot> forall a b (t :: * -> *). (Data.Foldable.Foldable t) => (a -> b -> b) -> b -> t a -> b
19:20:34 <aavogt> and also that  sequence vs.  sequenceA stuff
19:20:34 <djahandarie> Not everything has Foldable instances
19:21:28 <mauke> :t fix . mplus . return
19:21:30 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => a -> m a
19:21:57 <aavogt> djahandarie: there are more types in Foldable than just []
19:27:24 <mm_freak> what does the 'S' in SK calculus stand for?
19:29:07 <mauke> SK calculus
19:29:19 <mauke> it's a recursive acronym
19:30:03 <copumpkin> such a terrible hack that the colon for type annotations in agda is just a function
19:30:34 <edwardk> hah
19:31:01 <edwardk> 'starling'
19:31:34 <mm_freak> mauke: i see
19:31:53 <edwardk> http://www.angelfire.com/tx4/cus/combinator/birds.html
19:31:56 <Boxo> it stands for \xyz.xz(yz)
19:31:59 <mm_freak> i read the K as "const", how would i read the S?  i always read it as "apply"
19:32:14 <edwardk> k = kestrel
19:32:15 <copumpkin> konst
19:32:26 <edwardk> s = startling. i = identity/idiot
19:32:28 <copumpkin> du holde kunst
19:32:29 <edwardk> er starling
19:32:35 <mauke> superfly
19:32:42 <mm_freak> kunst lol
19:32:53 <copumpkin> in wieviel grauen Stunden
19:34:27 <mauke> Das Salz verzehrt den Leib des Mohren.
19:36:41 <Boxo> Why are people obsessed with SK when even one-combinator bases exist?
19:36:58 <edwardk> because SK is more usable than the latter ;)
19:37:17 <mm_freak> Boxo: because i'm implementing functors in another language
19:37:25 <copumpkin> and haskell is more usable than SK!
19:37:26 <mm_freak> and applicative functors resemble SK calculus
19:37:31 <Boxo> Usable!?
19:37:33 <edwardk> and because its more closely analogous to the useful way to define a lambda calculus in terms of a cartesian closed category
19:38:01 <edwardk> (just add families of s and k morphisms, and stir)
19:38:53 <mauke> delambdification in terms of S/K is simple enough
19:39:23 <edwardk> copumpkin: boxo doesn't seem to think so ;)
19:39:41 <Boxo> There's Xa=S(\abc.a), where K=XX, S=X(XX)
19:40:06 <Boxo> If it's clear in terms of SK, it's gotta be clear in terms of X too
19:40:16 <edwardk> boxo: sure and there is iota, etc.
19:40:21 <Boxo> Xa=aS(\abc.a) ***
19:40:38 <mauke> Boxo: [citation needed]
19:40:56 <mm_freak> Boxo: that definition is not self-contained
19:41:21 <Boxo> Xa=a(\abc.ac(bc))(\abc.a) 
19:41:24 <Boxo> now it is
19:41:29 <Boxo> @google one-combinator basis
19:41:31 <lambdabot> http://people.cs.uu.nl/jeroen/article/combinat/index.html
19:41:31 <lambdabot> Title: One-combinator basis for lambda-terms
19:41:39 <mm_freak> and now it's scary ;)
19:42:11 <mauke> @pl \a -> (\a b c -> a c (b c)) (
19:42:11 <lambdabot> (line 1, column 30):
19:42:11 <lambdabot> unexpected end of input
19:42:11 <lambdabot> expecting lambda abstraction, expression or ")"
19:42:17 <Boxo> Okay, S and K combined are shorter than X
19:42:22 <mauke> @pl \a -> (\a b c -> a c (b c)) (\a b c -> a)
19:42:22 <lambdabot> const (join ap)
19:42:25 <edwardk> S and K have the benefit that they don't require lambdas in their definition
19:42:48 <Boxo> Why not go to three combinators and beyond, then? But we do, with I, heh
19:42:51 <edwardk> so they yield a nice general _combinator_ basis rather than being defined in terms of some extra-logical lambdas
19:42:54 <mm_freak> > let x = const (join ap) in x x 3
19:42:55 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
19:43:03 <djahandarie> lol
19:43:06 <mauke> @pl \a -> a (\a b c -> a c (b c)) (\a b c -> a)
19:43:07 <lambdabot> flip ($ const (join ap)) (const const)
19:43:26 <edwardk> boxo: i have no objection to using a large combinator basis ;)
19:43:39 <edwardk> in fact thats basically what i compiled down to
19:43:43 <edwardk> er compile
19:43:50 <mm_freak> let x a = a (\a b c -> a c (b c)) (\a b c -> a) in x x 3
19:43:54 <mm_freak> > let x a = a (\a b c -> a c (b c)) (\a b c -> a) in x x 3
19:43:55 <lambdabot>   Occurs check: cannot construct the infinite type:
19:43:55 <lambdabot>    t = t3 -> t1 -> t -> t2
19:44:21 <mm_freak> apparently one-combinator base doesn't work for typed lambda calculus
19:45:00 <Boxo> that would be a legit reason... I wonder if all of them don't work
19:45:01 <dabblego> how do I set the TextEncoding on a Handle (given that the constructor is not exported)?
19:45:12 <mm_freak> Boxo: SK works
19:45:19 <edwardk> boxo: i should hope not unless you want to sneak Y in ;)
19:45:22 <mm_freak> obviously, because otherwise we wouldn't have Applicative
19:45:58 <Boxo> I mean all one-combinator bases
19:46:05 <mm_freak> ah
19:46:27 <dabblego> hSetEncoding
19:46:39 <mm_freak> i don't know why one would want to use a single combinator calculus anyway
19:47:48 <Boxo> Why would you want to use any combinator basis? I guess there are reasons besided that it's cool, I don't know them yet though
19:48:29 <mm_freak> well, SK is quite expressive
19:48:39 <mm_freak> you don't use the pure calculus, but the concept
19:49:09 <mm_freak> :t (+) <$> sin <*> cos
19:49:10 <lambdabot> forall a. (Floating a) => a -> a
19:49:26 <Boxo> well the mechanical unlambdification doesn't result in anything expressive
19:49:44 <mm_freak> that's k (+) `s` sin `s` cos
19:52:07 <Boxo> > let x = 0.5 in ((+) <$> sin <*> cos) x == sin x + cos x
19:52:08 <lambdabot>   True
19:52:37 <mauke> > ((+) <$> sin <*> cos) x
19:52:39 <lambdabot>   sin x + cos x
19:52:43 <mauke> BAM
19:52:59 <jmcarthur> > liftA2 (+) sin cos x
19:53:00 <lambdabot>   sin x + cos x
19:53:04 <mauke> > deriv ((+) <$> sin <*> cos) x
19:53:06 <lambdabot>   1 * cos x + 1 * negate (sin x)
19:53:07 <Boxo> > ((^^++^^) <$> gege <*> qqq) fg
19:53:08 <lambdabot>   Not in scope: `^^++^^'Not in scope: `gege'Not in scope: `qqq'Not in scope: ...
19:53:45 <jmcarthur> > (sin + cos) x
19:53:46 <lambdabot>   sin x + cos x
19:53:51 <Boxo> > sin
19:53:52 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
19:53:52 <lambdabot>    arising from a use of `...
19:53:58 <Boxo> > sin x
19:53:58 <lambdabot>   sin x
19:54:10 <Boxo> :t sin x
19:54:11 <lambdabot> Expr
19:54:18 <Boxo> :t sin
19:54:19 <lambdabot> forall a. (Floating a) => a -> a
19:54:36 <jmcarthur> > sin + cos $ x  -- i love the Num instance for functions
19:54:37 <lambdabot>   sin x + cos x
19:54:45 <jmcarthur> > sin + cos $ 1  -- i love the Num instance for functions
19:54:46 <lambdabot>   1.3817732906760363
19:54:59 <Boxo> > sin (x :: Double)
19:55:00 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
19:55:00 <lambdabot>         against inferred ty...
19:55:08 <Boxo> > sin (x :: Expr)
19:55:09 <lambdabot>   sin x
19:55:15 <Boxo> > sin (x :: Float)
19:55:16 <lambdabot>   Couldn't match expected type `GHC.Types.Float'
19:55:16 <lambdabot>         against inferred typ...
19:55:17 <mauke> why so sin?
19:55:22 <mauke> :t x
19:55:23 <lambdabot> Expr
19:55:51 <Boxo> it's x! what right does it have to be an Expr. shees
19:55:56 <Boxo> :t a
19:55:56 <lambdabot> Expr
19:56:00 <Boxo> :t xx
19:56:01 <lambdabot> Not in scope: `xx'
19:56:25 <jmcarthur> > [a..z]
19:56:26 <lambdabot>   *Exception: not a number
19:56:27 <jmcarthur> aw
19:56:34 <Boxo> > flip x
19:56:35 <lambdabot>   Couldn't match expected type `f (a -> b)'
19:56:35 <lambdabot>         against inferred type `Si...
19:56:47 <mauke> :t f
19:56:49 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
19:57:32 <mauke> > flip f x y
19:57:34 <lambdabot>   Ambiguous type variable `b' in the constraints:
19:57:34 <lambdabot>    `SimpleReflect.FromExpr ...
19:57:46 <mauke> > flip f x y `asTypeOf` x
19:57:48 <lambdabot>   f y x
19:58:27 <Boxo> > join (+) x
19:58:29 <lambdabot>   x + x
19:59:16 <Boxo> > f . g
19:59:17 <lambdabot>   No instance for (GHC.Show.Show (f b))
19:59:17 <lambdabot>    arising from a use of `M9131518993...
19:59:25 <Boxo> > (f . g) x
19:59:26 <lambdabot>   Ambiguous type variable `a' in the constraints:
19:59:26 <lambdabot>    `GHC.Show.Show a'
19:59:26 <lambdabot>      a...
20:00:10 <mauke> > (\f g -> head [f, g] . head [g, f]) f g x
20:00:13 <lambdabot>   f (g x)
20:01:31 <Boxo> > let x = [f,g] in (f.g) x
20:01:32 <lambdabot>   Ambiguous type variable `a' in the constraints:
20:01:33 <lambdabot>    `GHC.Show.Show a'
20:01:33 <lambdabot>      a...
20:01:40 <Boxo> > let qqqwq = [f,g] in (f.g) x
20:01:41 <lambdabot>   Ambiguous type variable `a' in the constraints:
20:01:41 <lambdabot>    `GHC.Show.Show a'
20:01:41 <lambdabot>      a...
20:02:56 <Boxo> > [f,g] `seq` (f.g) x
20:02:57 <lambdabot>   Ambiguous type variable `a' in the constraint:
20:02:57 <lambdabot>    `SimpleReflect.FromExpr a...
20:03:46 <variable> Boxo, for your information - I'm NOT ambiguous 
20:03:55 <mauke> > ((f :: Expr -> Expr) . g) x
20:03:57 <lambdabot>   f (g x)
20:05:21 * copumpkin binds variable 
20:05:30 * jmcarthur binds copumpkin
20:05:46 <copumpkin> don't be silly
20:05:49 <copumpkin> you can only bind variables
20:05:54 <jmcarthur> omg i didn't realize somebody actually had variable as a nick
20:06:11 <Boxo> > ap (const ap) const $ (f :: Expr -> Expr) g x
20:06:12 <lambdabot>   Couldn't match expected type `t -> a -> b'
20:06:12 <lambdabot>         against inferred type `S...
20:06:13 <variable> jmcarthur, I make it easy to tab complete :-}
20:06:26 <Boxo> > const a b
20:06:27 <lambdabot>   a
20:06:29 <jmcarthur> copumpkin: not true. you can bind actions
20:06:48 * djahandarie slaps Boxo with a zygohistomorphic prepromorphism 
20:06:48 <zygohistomorphic> zygohistomorphic prepromorphism 
20:06:49 <zygohistomorphic> yay
20:07:00 <prepromorphism> yay
20:07:00 <zygohistomorphic> this reminds me of the corny fusion dance from dragonball
20:07:04 <prepromorphism> lol
20:07:09 <prepromorphism> fuuuuuuuuuuuu.....
20:07:16 <prepromorphism> sion!
20:07:17 * zygohistomorphic does some awkward dance
20:07:20 <prepromorphism> HAH!
20:07:28 <djahandarie> ZYGO - HISTO - MORPHIC - PRE - PRO - MORPHISM - HA!!!!!!!
20:07:55 * zygohistomorphic prepromorphisms
20:08:19 <Kaidelong> window 1
20:08:22 <Kaidelong> whoops
20:08:40 <djahandarie> I tend to use /win :)
20:08:57 <jmcarthur> meta-1
20:08:59 <djahandarie> Actually I use Alt+1 if is under 20 :P
20:09:53 <Kaidelong> now I can feel like I'm using emacs thanks to djanhandarie
20:10:24 <jmcarthur> ... your irc client isn't in emacs?
20:10:29 <djahandarie> I also tend to dja-[tab]. In case I ever feel like talking to myself ;)
20:10:43 <djahandarie> jmcarthur, yi hasn't replicated that part of emacs yet
20:10:46 <Kaidelong> it should really be in manatee, shouldn't it?
20:10:47 <jmcarthur> jmcarthur: i do that sometimes as well
20:11:36 <djahandarie> Let's end this conversation on that note so we can make jmcarthur look like a crazy person
20:12:03 <jmcarthur> jmcarthur: i'm not crazy!
20:14:18 <shachaf> jmcarthur: So preceding your messages with "jmcarthur: " is a universally-accepted sign of craziness?
20:14:33 <zygohistomorphic> zygohistomorphic: yeah
20:15:33 <djahandarie> shachaf, you just dug yourself in a hole there!
20:15:48 <shachaf> jmcarthur: Don't worry, I'm perfectly sane.
20:15:49 <jmcarthur> for some reason i keep imagining "zygohistomorphic" being said like in daft punk's Technologic
20:15:54 <shachaf> jmcarthur: ...Uh-oh.
20:16:07 <zygohistomorphic> zygohistomorphic: I'm a robot
20:16:28 * djahandarie would not know what to say if he walked in the channel during this conversation
20:16:49 <zygohistomorphic> zygohistomorphic: nor would I, if I were witnessing my conversation with myself
20:16:50 * jmcarthur would say "637 people and *this* is what you're talking about?"
20:16:51 <c_wraith> "hey guys, what's going on in this channel?" sounds appropriate to me
20:17:26 <Veinor> jmcarthur: zygo histo mono cata prepro... etc
20:17:33 <jmcarthur> oh sorry this is just what happens when nobody mentions haskell in a while
20:17:50 <Kaidelong> you just did. Also hi Veinor.
20:18:09 <Veinor> http://i.imgur.com/kQW0t.jpg
20:18:37 * Kaidelong thinks it is *probably* possible to see that somehow without starting X
20:18:53 <shachaf> Kaidelong: Sure, fbdev.
20:18:56 <shachaf> Or aalib.
20:19:04 <shachaf> Though I'm not sure how well that would work with text.
20:19:06 <Kaidelong> aalib
20:19:14 * Boxo unsafePerformIO
20:19:22 <Kaidelong> is there a Haskell binding to aalib?
20:19:40 * shachaf doubts it.
20:20:00 <shachaf> @hackage haha
20:20:00 <lambdabot> http://hackage.haskell.org/package/haha
20:20:01 <Kaidelong> but how would I do ascii art in my haskell programs without it
20:20:05 <Kaidelong> oh there we go
20:21:26 <geheimdienst> Kaidelong: it is a cat, looking mightily unhappy, inside a shower. a dude is visible showering the cat, who is scrabbling at the glass door. a caption says "trapd in io monad, plz halp".
20:21:38 * geheimdienst feels satisfied
20:22:12 <Kaidelong> Ah good, I have seen that one
20:22:24 <Kaidelong> now I can rest peacefully
20:22:26 <Kaidelong> thank you
20:23:37 * geheimdienst looks forward to the day when all conversations in #haskell are: "lambdacat #37. -- haha, lambdacat #942 -- omg lol, you're right. lambdacat #622 -- that's what i was thinking ..."
20:24:30 <Boxo> is there a lambdacat archive?
20:24:31 <Kaidelong> well that'd mean that Haskell has succeeded
20:24:35 <Kaidelong> Boxo: Yes!
20:24:40 <geheimdienst> @where cats
20:24:40 <lambdabot> http://tinyurl.com/lambdacats
20:24:41 <Kaidelong> someone mirrored them
20:24:49 <Boxo> sweet
20:25:14 <shachaf> It is a cat, sliding on a recently-waxed floor. There is a warning sign nearby, and it is clearly unable to stop its motion. A caption reads "I haz halting problem, plz halp".
20:25:30 <djahandarie> Eugenio Moggi says 2-categorys are better than 1. lol
20:26:20 <applicative> Kaidelong, there are things like http://hackage.haskell.org/package/AC-PPM  http://hackage.haskell.org/package/pgm-0.1.1 that would get you close
20:26:52 <geheimdienst> shachaf: http://www.gifbin.com/983417
20:27:58 <shachaf> geheimdienst: Ah, there you go.
20:28:46 <shachaf> geheimdienst: That animation is better played backwards, by the way.
20:29:47 <geheimdienst> how do you make it play backwards?
20:30:09 <shachaf> geheimdienst: I have a bookmarklet for it.
20:30:35 <shachaf> But I think there's also a website that'll do it?
20:31:13 * applicative is thinking, this aalib is just about my speed.
20:35:44 * geheimdienst surprisingly succeeds in reversing the gif using http://www302.blibs.com/editor/ 
20:36:10 <geheimdienst> however, i can't save it to imageshack now
20:59:28 <zygohistomorphic> edwardk: passed another law :)
21:00:39 * geheimdienst passed gas
21:00:49 <zygohistomorphic> good to know
21:01:02 <geheimdienst> well _you_ started it
21:01:36 <j-invariant> im torn bewteen notations
21:01:45 <j-invariant> I can't decide if fgh or h . g . f is better
21:02:02 <j-invariant> when you start considering f(x) it throws a spanner in the works
21:05:11 <Cale> and, just as an aside, if you identify values with maps from a one-element set which send that element to x, you can write f(x) as f . x
21:06:04 <Cale> and the fact that (f . g)(x) = f(g(x)) becomes a special case of the associativity of composition :)
21:08:38 <j-invariant> Cale: :D
21:09:06 <Boxo> and you can write (f . g)(x) as xfg. Nice
21:11:34 <Boxo> no
21:11:36 <Boxo> xgf
21:13:51 <zygohistomorphic> just one hole left, and I'll be done!
21:21:08 <cdsmithus> Hmm, why does Data.Text.Encoding have encodeASCII, but not decodeASCII.  That's weird.
21:21:19 <cdsmithus> Or, other way around
21:21:31 <Veinor> just wrote some code for fermat primality testing. first using System.Random then Control.Monad.Random
21:23:21 <j-invariant> When you have a monad m it is possible to turn that into to two functions GF = m
21:23:27 <j-invariant> the adjunction
21:23:38 <j-invariant> I was wondering if that has any application in haskell programming?
21:23:56 <j-invariant> for exampfle maybe there is an algorithm whch is easy to write G . x . F but very hard to write otherwise?
21:24:09 <lars9> what's this ~ in: fmap f ~(BitTrie x l r) = BitTrie (f x) (fmap f l) (fmap f r) ?
21:24:17 <Veinor> lars9: lazy pattern
21:24:39 <lars9> Veinor: thanks
21:24:41 <cdsmithus> j-invariant: I've seen people poke at it just to see what happens, but not familiar with actual programming implications.  If there are, I'd be interested, too.
21:25:07 <Zeiris> Are there any comonad usage examples out there, with actual code? (Other than sigfpe's cellular automaton.)
21:25:31 <lars9> when is lazy pattern needed?
21:25:32 <Zeiris> I'm thinking about board games like Settlers of Catan and whatnot in Haskell. It seems like they're comonads, except I don't really get the comonad laws :E
21:26:06 <PardoSandia> Tired of niggggers?  Sick of their monkeyshines?  Then join Chimpout Forum!  We welcome anybody who isn't a fecal negroid beast! That is right!  WE ARE NOT WHITE SUPREMACISTS; rather we are Negro Inferiorists!  If you hate niggers and aren't a nigger, you can join!  http://www.chimpout.com/forum
21:26:20 --- mode: ChanServ set +o Cale
21:26:25 --- mode: Cale set +b *!*@174-125-77-19.dyn.centurytel.net
21:26:25 --- kick: PardoSandia was kicked by Cale (PardoSandia)
21:26:28 <cdsmithus> j-invariant: For example, http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=84 is a blog post about it.
21:26:30 --- mode: Cale set -o Cale
21:27:47 <j-invariant> "we can choose any adjunction giving rise to it and use adjoint composition to obtain a monad" -- clever!!
21:28:32 <Cale> One of the canonical adjunctions giving rise to a monad is the one which goes via the Kleisli category, and of course, we have a fair amount of love for Kleisli composition.
21:28:42 <Cale> :t (<=<)
21:28:43 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
21:29:37 <Veinor> :t (.)
21:29:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:29:38 <Cale> The other one would be the category of algebras for the monad which is unfortunately a little more difficult to discuss directly in terms of Haskell.
21:29:45 <Veinor> dammit caleskell
21:29:53 <Cale> hehe
21:30:10 <Cale> The normal type is (.) :: (b -> c) -> (a -> b) -> (a -> c)
21:30:11 <aavogt> lars9: it saves typing sometimes
21:30:15 <Veinor> also, sometimes i wish (.) was in the opposite direction
21:30:33 <Veinor> because then i could read f . g as 'first f, then g'
21:30:46 <j-invariant> is the kleisei category the coalgebra?
21:31:28 <aavogt> > let ls = [Just a, Nothing] in ([ x | Just x <- ls], [ x | ~ (Just x) <- ls])
21:31:28 <lambdabot>   ([a],[a,*Exception: <interactive>:3:52-74: Irrefutable pattern failed for p...
21:32:01 <lars9> aavogt, Veinor: for example, why is it needed in source of http://hackage.haskell.org/packages/archive/data-inttrie/0.0.3/doc/html/Data-IntTrie.html ?
21:32:11 <aavogt> > let ls = [Just a, Nothing] in [ x' | x <- ls, let Just x' = x]
21:32:12 <lambdabot>   [a,*Exception: <interactive>:3:50-60: Irrefutable pattern failed for patter...
21:32:17 <Eduard_Munteanu> :t (>>>)
21:32:18 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
21:32:56 <Eduard_Munteanu> For a flipped '.' variant ^
21:32:58 <aavogt> lars9: the author could have written    fmap f ~(BitTrie x l r) = BitTrie (f x) (fmap f l) (fmap f r)
21:33:29 <Veinor> lars9: iirc, lazy patterns are used when doing infinite recursive data structures
21:33:36 <Veinor> iirc
21:33:38 * azaq23 is still mystified by "real" racism as exemplified above
21:33:52 <aavogt> lars9: the author could have written    fmap f bitrie = BitTrie (f x) (fmap f l) (fmap f r) where BitTrie x l r = bitrie 
21:34:49 <aavogt> the idea is that        fmap (const 1) undefined == BitTrie 1 ...
21:35:03 <aavogt> though this would seem to violate the laws on Functor
21:35:41 <lars9> aavogt: oh, that makes sense now
21:38:03 <aavogt> lars9: basically different contexts of pattern matching do different things with how the types are generalized, how and where the match will fail
21:38:14 <aavogt> but often the difference doesn't matter
21:38:28 <copumpkin> edwardk: found a typo in the comonad laws on category-extras
21:38:35 <Veinor> a co-typo!
21:42:08 --- mode: ChanServ set +o copumpkin
21:42:17 --- mode: copumpkin set +b *PardoSandia*!*@*
21:42:24 --- mode: copumpkin set -o copumpkin
21:42:25 <monochrom> spaghetti alfredo cotypo
21:44:16 * hackagebot xorshift 1 - Haskell implementation of the xorshift random generator.  http://hackage.haskell.org/package/xorshift-1 (RobertClausecker)
21:44:57 * Eduard_Munteanu queues stuff from http://mathoverflow.net/questions/23032/what-is-the-intuitive-meaning-of-star-and-box-in-a-pure-type-system
21:45:09 <Eduard_Munteanu> ... and has to go ...
21:45:10 <Eduard_Munteanu> o/
21:45:21 <bsmntbombdood> I know that \r -> (const . x) (f r) r == \r -> x (f r), but how would you prove it?
21:46:26 <j-invariant> (const . x) (f r) r = (const x) (f r) r = x r ?
21:46:55 <Veinor> (const . x) (f r) r = const (x (f r)) r = x (f r)
21:47:14 <bsmntbombdood> j-invariant: that's wrong
21:47:15 <bsmntbombdood> Veinor: why?
21:47:32 <Veinor> bsmntbombdood: because (f . g) x = f (g x)
21:47:34 <bsmntbombdood> oh, that's the definition of .
21:48:19 <bsmntbombdood> cool
21:48:25 <younder> composition..
21:49:36 <Veinor> @pl \r -> (const . x) (f r) r
21:49:36 <lambdabot> x . f
21:49:54 * shapr grumbles
21:49:56 <Veinor> @pl (const . x) (f r)
21:49:56 <lambdabot> const (x (f r))
21:50:07 <shapr> Ok, what's the dependency fix again? I'm trying to cabal install lambdabot so I can do some bugfixes
21:50:08 <Veinor> :P
21:50:45 <younder> Why the const? Is that  that a given in functional code?
21:51:16 <Veinor> the const is because (f . g) x = f (g (x))
21:51:23 * shapr blinks
21:51:53 <younder> Which still looks the same to me..
21:51:57 <bsmntbombdood> younder: it's return in the function monad
21:52:05 <younder> ahh
21:52:11 <wagle> anyone use/try eclipse for haskell?  (eclipsefp?)  how is it?
22:01:51 <bsmntbombdood> so i've never really written real proofs before
22:01:53 <bsmntbombdood> http://hpaste.org/42754/proof
22:01:58 <bsmntbombdood> does that look reasonable?
22:03:47 <azaq23> return x y = x?
22:03:55 <azaq23> oh, const
22:04:34 <j-invariant> bsmntbombdood: no because at the last line you have an =
22:05:04 <j-invariant> it should be  Definition of .: then f . g
22:05:49 <Kaidelong> @ty join (+)
22:05:50 <lambdabot> forall a. (Num a) => a -> a
22:05:58 <Kaidelong> > join (+) 5
22:05:59 <lambdabot>   10
22:06:23 <bsmntbombdood> Kaidelong: weird huh?
22:06:24 <Kaidelong> ...?
22:06:56 <Cale> bsmntbombdood: The proof is right, but j-invariant makes a good point about consistency of style :)
22:07:03 <Kaidelong> > (+) >>= flip
22:07:04 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
22:07:33 <Kaidelong> @ty join (:)
22:07:34 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
22:07:34 <lambdabot>       Expected type: a -> a -> a1
22:07:34 <lambdabot>       Inferred type: a -> [a] -> [a]
22:08:03 <copumpkin> \x -> (map (const (extract x)) x == x)
22:08:06 <copumpkin> true?
22:08:07 <Kaidelong> r -> (r -> a) I suppose
22:08:07 <Kaidelong> as opposed to r -> (s -> a)
22:08:07 <Kaidelong> so the two have to match?
22:08:20 <Kaidelong> oh of course, that makes perfect sense
22:08:35 <Kaidelong> (s ->) would be itself a monad, just a different monad
22:08:46 <Kaidelong> maybe
22:10:06 <Kaidelong> > (^2) >>= (+) $ 3
22:10:07 <lambdabot>   12
22:11:21 <j-invariant> about this: http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=84
22:11:36 <j-invariant> why are the different monad transformers found using different operations on the adjunction?
22:11:43 <j-invariant> I woud expect it to be uniform
22:13:05 <bsmntbombdood> @type flip >>= (+)
22:13:06 <lambdabot> forall a b. (Num b) => (a -> a -> b) -> a -> a -> b
22:13:13 <bsmntbombdood> how does that work?
22:13:31 <bsmntbombdood> flip >>= (+) = \r -> (+) (flip r) r
22:13:35 <bsmntbombdood> that shouldn't type
22:13:39 <j-invariant> :t flip
22:13:41 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
22:13:59 <bsmntbombdood> @src flip
22:13:59 <lambdabot> flip f x y = f y x
22:14:35 <shapr> @type (=<<) (+)
22:14:37 <lambdabot> forall a. (Num a) => (a -> a) -> a -> a
22:14:50 <bsmntbombdood> @type (\f x y -> f y x)
22:14:51 <lambdabot> forall t t1 t2. (t1 -> t -> t2) -> t -> t1 -> t2
22:15:11 <Kaidelong> lambdabot is probably lying about the implementation of flip it is using
22:16:06 <Kaidelong> @ty ap
22:16:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
22:16:29 <Kaidelong> @ty fmap ($)
22:16:29 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> f (a -> b)
22:17:02 <guest2425> hello hello
22:17:07 <Kaidelong> @ty fmap . ($)
22:17:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:17:11 <guest2425> some one here?
22:17:17 <Kaidelong> yes
22:17:23 <bsmntbombdood> i don't get it
22:17:35 <Kaidelong> @ty fmap . flip ($)
22:17:35 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
22:17:45 <Kaidelong> oh that's closer
22:17:55 <guest2425> bsmntbombdood: whats up?
22:18:16 <guest2425> Cale: Are you here?
22:18:18 <guest2425> hello
22:18:33 <Kaidelong> > flip (fmap . flip ($))
22:18:35 <lambdabot>   Overlapping instances for GHC.Show.Show (f (a -> b) -> a -> f b)
22:18:35 <lambdabot>    arising...
22:19:01 <j-invariant> bsmntbombdood: don't get what?
22:19:18 <Kaidelong> > (flip (fmap . flip ($))) (-) 5 10
22:19:20 <lambdabot>   5
22:19:24 <guest2425> j-invariant: Same question
22:19:40 <Kaidelong> so you can replace that flip with (\f x y -> f y x)
22:19:46 <guest2425> yes
22:20:04 <guest2425> Kaidelong: same thing no?
22:20:11 <Kaidelong> :t flip
22:20:12 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
22:20:53 <Kaidelong> @ty let flip' = (\f x y -> f y x) in (flip (fmap . flip ($)))
22:20:54 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
22:21:01 <Kaidelong> err
22:21:07 <Kaidelong> @ty let flip' = (\f x y -> f y x) in (flip' (fmap . flip' ($)))
22:21:08 <lambdabot> forall (f :: * -> *) t b. (Functor f) => f (t -> b) -> t -> f b
22:21:13 <Kaidelong> there we go
22:22:54 <j-invariant> "Monads first arose explicitly in Homological algebra
22:23:02 <j-invariant> What's that? Or is it just too abstract to explain
22:23:04 <Kaidelong> > (flip . flip) [(+),(-)] 10 5
22:23:05 <lambdabot>   Couldn't match expected type `a -> a1 -> b'
22:23:05 <lambdabot>         against inferred type `...
22:23:28 <Kaidelong> > flip [(+5),(-5)] 10
22:23:30 <lambdabot>   [15,-5]
22:24:41 <Kaidelong> oh I see what I did wrong now
22:26:12 <copumpkin> > fmap (const (snd (1,5))) (1,5)
22:26:13 <lambdabot>   (1,5)
22:27:57 <Kaidelong> > fmap (const "Obfuscation") (1,5)
22:27:58 <lambdabot>   (1,"Obfuscation")
22:30:41 <copumpkin> can anyone give me another law of copointed than extract (map f x) == f (extract x)
22:30:51 <copumpkin> ideally a "linearly independent" one :P
22:31:56 <copumpkin> oh
22:32:01 <copumpkin> maybe I don't need one
22:33:34 <j-invariant> I thought that IO is something to do with Old Macdonald, and mutable states are countries where you can stop everyone from talking, right?
22:41:52 <edwardk> copumpkin: not really =)
22:41:58 <copumpkin> ?
22:42:10 <j-invariant> "What's less obvious, though, is that one can always recover C from Mod(C,Set) together with its forgetful functor to the category of sets" <--- Yoneda?
22:42:22 <djahandarie> > fix . const . (++"uscation") . fix . const $ "Obf"
22:42:24 <lambdabot>   "Obfuscation"
22:42:51 <copumpkin> edwardk: not really what? :)
22:42:59 <edwardk> copumpkin: as in i don't think there are any.
22:43:05 <djahandarie> I like this identity
22:43:12 <copumpkin>  fmap f    == extend (f . duplicate)
22:43:18 <copumpkin> the types don't even work there
22:43:19 <edwardk> 'can anyone give another law of copointed than extract (map f x) = f (extract x)
22:43:28 <copumpkin> oh I see
22:43:35 <edwardk> is that the busted one in category-extras?
22:43:35 <copumpkin>  fmap f    == extend (f . extract)
22:43:37 <copumpkin> yeah
22:43:44 <copumpkin> yeah, I don't need another copointed law :)
22:43:52 <djahandarie> Yeah, category-extras comonad laws are borked IIRC
22:43:56 <edwardk> i knew there was one. i'll go path it in comonad
22:44:03 <edwardk> er patch
22:44:11 <djahandarie> edwardk, so when are you rewriting c-e? ;)
22:44:15 <copumpkin> anyway, I'm one small hole away from a comonad
22:44:24 <Kaidelong> shouldn't the comonad laws be analogous to the monad laws?
22:44:39 <edwardk> i think i cut and pasted them from zednenem's original when someone complained about my lack of docs, i may have mangled them in transit
22:44:39 <Kaidelong> also from a comonad or from a haskell comonad?
22:44:44 <Kaidelong> aren't the real ones a bit more flexible?
22:44:45 <edwardk> kaide: they are
22:46:14 <edwardk> extend extract = id, extract . extend f = f, extend f . extend f = extend (f . extend g) — are the two unit laws and associativity
22:47:41 <copumpkin> ugh I feel like shit
22:47:46 <copumpkin> edwardk: anyway, I'm 90% it's a comonad
22:48:15 <edwardk> copumpkin: good because i'm proceeding as if it is. your bayesian proof is good enough for me ;)
22:48:42 <edwardk> now, find me some compelling examples of callCV ;)
22:48:46 <copumpkin> lol
22:48:47 <edwardk> (and a better name) =)
22:49:00 <copumpkin> no, I must defeat this proof! but first I'm gonna go throw up or something :P
22:49:05 <edwardk> we varied the 'a's and 'b's but didn't explore the state s.
22:49:08 <djahandarie> :(
22:49:12 <copumpkin> maybe I'll go to sleep
22:49:15 <edwardk> bah
22:49:20 <Kaidelong> I was about to suggest that to you
22:49:25 <edwardk> stay up. solve my problem. present me with results in the morning ;)
22:49:29 <Kaidelong> although in terms of "copumpkin: init 6"
22:49:29 <copumpkin> lol
22:49:31 <j-invariant> what are you proving copumpkin 
22:49:47 <copumpkin> j-invariant: that edwardk's comonad is indeed a comonad
22:49:50 <edwardk> that (w (s -> a), s) forms a comonad for any comonad w.
22:50:00 <j-invariant> just prove its a monad in the opposite category
22:50:12 <copumpkin> not really any easier, I wouldn't think
22:50:14 <edwardk> j-invariant: same difference
22:50:25 <edwardk> j-invariant: he was just slogging through the agda proof
22:50:35 <edwardk> lots of fiddly bits
22:50:36 <copumpkin> slog it is
22:50:54 <j-invariant> category theory in agda?
22:51:07 <copumpkin> well, there is a whole library of it
22:51:12 <copumpkin> but I just defined the bits I needed for this proof
22:51:18 * applicative is reinstalling agda just now. a chamber of horrors
22:51:19 <edwardk> well, he used it first to check that the old ContextT was a comonad, which was easy
22:51:45 <edwardk> but this one satisfies more laws and is more desirable for modeling state-in-context
22:51:53 * applicative has been defeated by libiconv as usual.
22:51:57 <qfr> You use Haskell/Agda to prove statements in category theory?
22:52:03 <edwardk> whereas the old one seems to provide nice properties that are dual to cont
22:52:08 <edwardk> qfr: doesn't everyone?
22:52:17 * djahandarie suspects not
22:52:23 <qfr> I use Haskell to program HTML
22:52:26 <applicative> qfr, its all we ever do, to parapharse james dean
22:52:32 <j-invariant> hehe
22:52:34 <applicative> parapharse?
22:52:43 <qfr> Paraphrase?
22:53:03 <edwardk> qfr: well, you can prove statements in category theory… about html, then ;)
22:53:05 <applicative> thank you qfr, even if no one else understands me, you understand me
22:54:09 <applicative> you need dependent types to express category theory, right.  there was an excellent illustration about Hom A B from one of those category-hut blog people
22:54:27 <edwardk> depends on how much you want to express
22:54:36 <edwardk> there was a nice old paper, one sec.
22:54:41 <j-invariant> functor Ff : FA -> FB
22:55:16 <edwardk> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.4193 iirc
22:55:20 <j-invariant> to say that F = G, you have to say FX = GX and Ff = "Gf" <-- can't typecheck Gf though unless you use the first equality
22:56:07 <applicative> http://golem.ph.utexas.edu/category/2010/03/in_praise_of_dependent_types.html  I found him irritating, but the remark on Hom sets was excellent apart from the rest.
22:57:11 <lispy> applicative: re: libiconv, are you on the mac?
22:57:23 <lispy> applicative: I do, sudo port deactivate libiconv
22:57:24 <applicative> lispy, yes, it's a neverending torment
22:57:45 <lispy> applicative: then things that want it can get it, but it's not "active" so you can build/link haskell stuff without it
22:57:47 <applicative> lispy, i have more than just two libiconvs
22:57:56 <copumpkin> I'm on a mac too and have never had any trouble with agda
22:57:56 <applicative> i see
22:58:12 <applicative> copumpkin, at the moment it's the haskeline dependency
22:58:25 <applicative> i haven't had trouble before either
22:58:29 <lispy> applicative: I basically just use the port activate/deactivate command to manage when it's visible.
22:58:31 <copumpkin> did you install the platform .pkg or compile it yourself?
22:58:40 <copumpkin> I just use the .pkg
22:58:40 <applicative> agda wants to be built --global it seems
22:58:45 <copumpkin> screw macports and everything
22:58:57 <j-invariant> applicative: http://hackage.haskell.org/package/uAgda-1.0.0.1
22:59:04 <copumpkin> that's different
22:59:07 <applicative> i renounce macports and all its works, and all its empty promise
22:59:11 <j-invariant> ti'ts BETTER :P
22:59:20 <copumpkin> j-invariant: lol
22:59:22 <applicative> i have uAgda, no problem there
22:59:25 <copumpkin> it's different :)
22:59:29 <lispy> macports is like a shortcut that comes back to bite you.
22:59:33 <j-invariant> I am failing at uAgda
22:59:39 <j-invariant> its' really hard
22:59:39 <copumpkin> j-invariant: how come?
23:00:09 <applicative> it doesn't matter, the current agda still works.  i just wanted to build with a pile of additional patches
23:00:21 <MrWish> what are types that do not belong to eq and why?
23:00:30 <lispy> My only gripe with Agda is that it's currently changing so fast that 1-2 months after documentation comes out, it is obsolete and full of compile errors.  in other words, it's unusable.
23:00:32 <copumpkin> MrWish: pretty much any function
23:00:37 <applicative> MrWish, function types dont usually belong
23:00:37 <j-invariant> copumpkin:             ((P₁ : ∗¹) →
23:00:38 <j-invariant>              (P₁ : ∗¹) →
23:00:39 <j-invariant> oops
23:00:42 <applicative> like copumpkin said
23:00:46 <edwardk> need a good antonym for continuation
23:00:55 <copumpkin> edwardk: stop! :P
23:00:57 <j-invariant> copumpkin: it uses P_1 twice.. I think they are different varibles though
23:00:57 <lispy> MrWish: Is that a homework question?
23:01:01 <j-invariant> so I can't read the outputs :/
23:01:03 <edwardk> cocont prompts too many coconut jokes
23:01:07 <copumpkin> j-invariant: oh weird
23:01:10 <j-invariant> but I don't know it its a bug or what
23:01:12 <applicative> what about Stream a = Cons a (Stream a) -- infinite lists.  
23:01:23 <copumpkin> CReal has a sketchy Eq instance
23:01:27 <copumpkin> and probably shouldn't have one at all
23:01:41 <lispy> Eq a => IO a, would be a weird instance
23:02:04 <edwardk> Mr Wish. (a -> b)
23:02:14 * applicative 's actions are all discrete, comparable, equal and unequal.
23:02:26 <applicative> edwardk, how many functions have type a -> b
23:02:52 <lispy> applicative: unsafeCoerce :)
23:02:56 <applicative> i feel i could manage sameness and different for them
23:03:10 <edwardk> depends, on if you are willing to allow error to count as different terms ;) and how you are dealing with unification ;)
23:03:11 * applicative has never used unsafeCoerce.
23:03:31 <lispy> applicative: it literally has the type, a -> b
23:04:01 <applicative> lispy yes.  that's how I know it's not real
23:04:14 <j-invariant> does anyone know where to find "Maria Cristina Pedicchio, Algebraic Theories"?
23:04:18 <djahandarie> contop
23:04:22 <j-invariant> supposedly there are TeX files for it online...
23:04:35 <j-invariant> says John Baez
23:04:48 <rajeshsr> hi all
23:05:05 <lispy> edwardk: cessation
23:05:28 <edwardk> lispy: yeah, i keep running through the thesaurus. =)
23:06:28 <lispy> edwardk: You should call it an EnterpriseWorkerBeanStopStrategyFactorBusProducer
23:06:31 <rajeshsr> why isn't it possible to implement foldr with foldl? I can have a combining function like this: foo fun val x = fun (val `f` x)
23:06:38 <edwardk> lispy: DiscontT, HaltT, StopT, TermT, BreakT, RetractT, etc.
23:06:52 <lispy> edwardk: CessationT
23:07:06 <edwardk> lispy: but since i don't really know what callCV _means_ yet i have trouble naming it
23:07:13 <rajeshsr> Well, of course the termination isn't guaranteed on inifinite list as foldr would have when possible!
23:07:21 <lispy> edwardk: StopT is kind of cute because I read it as "stopt" as in "stopped"
23:07:36 <rajeshsr> So, setting aside lazy evaluation, aren't they equally expressive?
23:08:05 <edwardk> CutoffT or CutT, etc.
23:08:13 <rajeshsr> anyone?
23:08:23 <lispy> :t foldr flip
23:08:24 <lambdabot> forall (f :: * -> *) b. (Functor f) => f b -> [f (f b -> b)] -> f b
23:08:25 <lispy> :t foldl
23:08:25 <edwardk> rajeshr: name vs. value are, but need is better ;)
23:08:26 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
23:08:49 <lispy> foldr flip :: (a -> c) -> [a -> (a -> c) -> c] -> a -> c
23:08:51 <edwardk> as for foldl in terms of foldr its because of productivity
23:09:48 <edwardk> if I can come up with a nice callCC like interpretation for callCV you might get AbortT
23:10:49 <lispy> edwardk: ProChoiceT?
23:11:19 <edwardk> hah
23:11:25 <rajeshsr> edwardk, Whay you meant by name vs value?
23:11:30 <rajeshsr> I didn't get that!
23:12:09 <edwardk> i meant that more programs terminate under call-by-need than call-by-name or call-by-value
23:12:27 <rajeshsr> edwardk, ha, ok!
23:12:37 <copumpkin> ugh
23:12:41 <rajeshsr> So, for languages like scheme they are functionally equivalent, right?
23:12:50 <copumpkin> remind me not to get a domino's sandwich again
23:13:22 <lispy> copumpkin: Yeah, that sounds like going to Subway for a Pizza
23:13:45 <copumpkin> hey, I have dominos about 3 minutes from my apartment
23:13:52 <copumpkin> it was simple :P
23:14:11 <lispy> copumpkin: I have a highway 3 minutes from my apartment, but I don't eat roadkill :P
23:14:24 <azaq23> > let myFoldr f def xs = (let k l r = l . (r `f`) in (foldl k id xs) def) in myFoldr ((:) . (* 2)) [] [1 .. 10]
23:14:25 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
23:14:41 <copumpkin> lispy: lol, I had no idea it would be this disagreeable
23:14:48 <copumpkin> it tasted fine, but my tummy did not like it
23:14:52 <lispy> copumpkin: :(
23:15:04 <copumpkin> but the good news is that there's definitely none of it left in me :P
23:15:16 <lispy> copumpkin: TMI :)
23:15:20 <copumpkin> mmm
23:15:52 <copumpkin> unfortunately that meant throwing it all up
23:16:36 <azaq23> > let myFoldl f def xs = (let k l r = r . (`f` l) in (foldr k id xs) def) in myFoldl (flip (:)) [] [1 .. 10]
23:16:38 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
23:19:10 <aefjt> How can I pair up two lists [a0,a1,a2..] and [b0,b1,b2..] as [ (a0,b0), (a0,b1), (a1,b0), (a0,b2), (a1,b1), (a2,b0) ..] ?
23:19:18 <edwardk> i just finished watching Primer. sounds like a good time to start playing with continuations.
23:19:25 <Veinor> aefjt: in that specific order?
23:19:37 <Veinor> or in any order?
23:19:56 <aefjt> Well, liftM2 (,) doesn't work for infinite lists.
23:19:59 <Veinor> ahh
23:20:17 <aefjt> I'm trying to think of a neat way to express that pairing, but can't
23:20:28 <Veinor> I don't know, but I think that's the strategy that Control.Monad.Omega uses
23:20:34 <j-invariant> aefjt:zip
23:20:49 <j-invariant> aefjt: no I misunderstood it
23:20:55 <copumpkin> use Omega
23:22:08 <aefjt> @hackage Omega
23:22:08 <lambdabot> http://hackage.haskell.org/package/Omega
23:22:14 <Veinor> http://hackage.haskell.org/packages/archive/control-monad-omega/0.3/doc/html/Control-Monad-Omega.html
23:22:16 <Veinor> this Omega, not that Omega
23:22:43 <aefjt> Oh, ok
23:22:44 <aefjt> Thanks
23:23:30 <MrWish> hello
23:24:32 <winxordie> MrWish: hi!
23:30:02 <MrWish> winxordie can I ask you a question
23:30:33 <winxordie> MrWish: You don't need to ask to ask questions, just go ahead and ask 'em.
23:31:00 <MrWish> somehow I feel like people only start givign answers when I ask to ask :/
23:31:02 <MrWish> anyways
23:31:24 <MrWish> what are the types that do not belong to eq, and why
23:32:28 <copumpkin> MrWish: we answered before
23:32:32 <edwardk> @pl \f -> g (f s)
23:32:33 <lambdabot> g . ($ s)
23:32:51 <copumpkin> you're welcome to ask homework questions but at least pay attention to people's answers to them before repeating :P
23:33:07 <MrWish> hm I missed it
23:33:13 <winxordie> MrWish: I think you could figure it out from http://en.wikibooks.org/wiki/Haskell/Class_declarations#Standard_Classes :P
23:33:36 <edwardk> mrwish: scrollback/the logs on tunes.org are your friend, there was about a screenful of responses
23:33:37 <copumpkin> MrWish: function types and similar things
23:33:45 <copumpkin> MrWish: infinite streams, computable reals
23:35:06 <MrWish> the thing I am wondering is, I think, couldnt = work on all types in principle because a function either shares some extension with another function or doesnt?
23:35:14 <MrWish> I mean == of course
23:36:03 <MrWish> like at the very least some function could share extension with some function because theyre the same function, and if this isnt the case  it would return false?
23:36:17 <edwardk> mrwish: decidability is an issue, how do you compare every possible argument to a function?
23:36:36 <applicative> aefjt, maybe you wants one of the plans for enumerating rationals? -- see e.g. http://www.comlab.ox.ac.uk/jeremy.gibbons/publications/index.html#rationals maybe?
23:36:51 <edwardk> the case you describe is what scheme does, but it has problems. it means that otherwise sound optimizations the compiler might make then break your function equality
23:37:20 <edwardk> if you rely on that for correctness of your program, now otherwise unobservable optimizations can break your program
23:37:45 <MrWish> humm... is this the kind of thing I have to have a very firm grasp of lambda calculus for to understand :p
23:37:51 <edwardk> lambda lifting, eta-substitution, etc all become disallowed optimizations because \x -> f x is no longer the same as f
23:38:03 <MrWish> oh dear lol
23:38:05 * applicative notices that Gibbons and Bird implement the enumeration from "Proofs from the Book"
23:38:30 <copumpkin> and of course, you could implement reduction rules in your equality function on ASTs
23:38:37 <edwardk> scheme standardized exactly what you asked for, but it costs you a LOT of optimization opportunities ;)
23:38:39 <copumpkin> but then you'd have an interpreter that might not terminate :)
23:40:03 <MrWish> hm yeah ok. I think I need to study lambda calculus more thoroughly for all that. right?
23:40:15 <younder> Haskell's type system does suffer from the halting problem as does ML's
23:40:27 <j-invariant> ?
23:40:36 <edwardk> mrwish: the easiest example is the \x -> f x != f under that scheme
23:41:02 <MrWish> uhm but in what case would that happen
23:41:03 <aefjt> applicative: nope
23:41:04 <MrWish> exactly
23:41:14 <edwardk> younder: only with extensions turned on (or in the funny case of some y combinator inlining)
23:41:20 <winxordie> younder: That's an interesting way of saying that haskell's type system isn't Turing-complete.
23:41:20 <younder> It is in practice not a problem. People don't usually create elaborate enough types for infinate recursion to occur.
23:41:55 <j-invariant> younder: Hindly Milner inference is decidable
23:42:27 <MrWish> I mean I always thought \x -> f x = x , why where or when would that stop being the case, suddenly...
23:43:31 <edwardk> mrwish the answer provided by the function \x -> f x    is the same as the ANSWER given by f, but if you compared \x -> f x   and f for equality you'd fail under the heuristic you specified
23:43:45 <edwardk> they'd be different functions even though they matched pointwise on every answer they gave
23:44:42 <edwardk> and the answer isn't a strictly conservative thing, because other optimizations can make you get two functions that are equal even though they aren't syntactically equal or defined at the same code point, and you want THOSE to work in the interest of efficiency as well
23:46:01 <MrWish> uhm I still dont grasp why exactly the comparison would fail if you didnt restrict == to a specific typeclass
23:47:01 <edwardk> you can't test the function pointwise, and your heuristic was to check to see if the two functions 'were the same function' (say by checking a closure or something)
23:47:02 <applicative> aejft, isn't pairUp an example of such a  function http://hpaste.org/42755/enumerate_rationals_etc
23:48:27 <MrWish> uhm..
23:48:48 <MrWish> why not..
23:49:28 <edwardk> define such a decision procedure. it'll turn out to be undecidable. ;)
23:49:57 <MrWish> can you give a concrete example? Its just really abstract to me at this point
23:50:16 <MrWish> I mean I dont know why it would be undecideable, at all.
23:51:09 <edwardk> (\x -> Just x) and Just  are different syntactically. they'd not necessarily evaluate out to the same shaped closure unless the compiler got lucky doing optimizations that the 'compare lambdas for equality by checking to see if they point to the same closure' rule disallows in the first place.
23:51:36 <edwardk> otherwise you're stuck checking if two functions agree on all possible inputs, and that is undecidable in general
23:52:37 <aefjt> applicative: well yeah, but for rationals you have to nub
23:52:37 <MrWish> what does Just do exactly?? 
23:52:46 <edwardk> > Just 12
23:52:47 <lambdabot>   Just 12
23:52:54 <edwardk> > (\x -> Just x) 12
23:52:56 <lambdabot>   Just 12
23:53:02 <aefjt> "Just is just Just"
23:53:22 <MrWish> btw someone posted a link to a source reference for an article titled "Enumerating the Rationals". that wasnt related to my problem was it? :/
23:54:04 <edwardk> (\x -> if … the collatz conjecture holds then true else false)     vs (\x -> true)   is going to be hard to check for pointwise equality ;)
23:54:15 <edwardk> yes
23:54:17 <copumpkin> Cale had a really elegant golfed enumerator of the rationals
23:54:40 <applicative> aefjt, yes, that's the point of the article.  They begin with the 'naive' enumeration of Cantor, in which there are repetitions.  That, I thought, had the structure you wanted.
23:54:41 <j-invariant> edwardk: can you write that as a haskeljl fucntion? :P
23:55:04 <edwardk> j-invariant: sure, just exhaustively test the naturals ;)
23:55:50 <applicative> MrWish, no it was my perhaps pointless attempt to address aefjt's problem.
23:55:50 <edwardk> i leave it to you to test for termination though ;)
23:56:03 <copumpkin> and if you have infinite time, that isn't enough
23:56:09 <copumpkin> because in haskell you need infinite + 1 time!
23:56:13 <MrWish> uhm, I dont understand your examples.
23:56:35 <MrWish> I dont understand what the Just function does and I dont understand the next example at all
23:56:45 <edwardk> google collatz conjecture
23:56:53 <MrWish> ok
23:57:00 <applicative> aejft, but this pairUp I derive from their simple un-nubbed enumeration of rationals (pairs of naturals) seems pretty lame.  
23:57:01 <j-invariant> does anyone know why the collatz conjecture is so hard?
23:57:31 <copumpkin> I had a proof of it in agda, but it didn't fit into my memory
23:57:33 <applicative> j-invariant, which part of mathematics has tons of proofs of things like that?
23:57:37 <copumpkin> so I got rid of it
23:57:47 <edwardk> yeah, i had that problem with 2 + 2 ;)
23:58:09 <copumpkin> I actually wrote addition on the rationals a while back
23:58:18 <copumpkin> and normalizing even a small addition of rationals took a few seconds
23:58:23 <copumpkin> probably a lot better now that we have irrelevance
23:59:38 <edwardk> copumpkin: do you still have that agda duplicate for ContextT
