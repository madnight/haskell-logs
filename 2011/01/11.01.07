00:00:00 <edwardk> one sec. lemme see if i have some slides by gershom bazerman on how to handle this kind of scenario lying around
00:02:45 <silbo_> hey  guys
00:03:18 <silbo_> any tips or trick to improve my code ? http://hpaste.org/paste/42631/quarto_annotation_annotatio#p42824
00:09:20 <lispy_> silbo_: I see a few "low level" syntatic things
00:09:37 <lispy_> silbo_: for example, readFill, you don't need the case
00:09:50 <silbo_> lispy: tell me more plx
00:10:06 <lispy_> readFill 'F' = Just Filled
00:10:18 <lispy_> ...
00:10:22 <lispy_> readFill _ = Nothing
00:10:46 <silbo_> ok xD
00:10:49 <Maxdamantus> How do you usually select between multiple Handles?
00:11:08 <silbo_> lispy_: is anything else ok ?
00:11:18 <silbo_> lispy_: I need good critics here
00:11:26 <edwardk> nanothief: http://www.mail-archive.com/haskell-cafe@haskell.org/msg77408.html
00:11:33 <edwardk> though, beware its a bit scary
00:11:36 <silbo_> lispy_: so don't be shy
00:11:44 <lispy_> silbo_: type doesn't really make a new type.  It just makes a synonym.  So, for Config, you probably want a record type
00:12:32 <lispy_> silbo_: all of your get* functions could be accessors as part of a record
00:13:08 <silbo_> lispy_: how is that done?
00:14:03 <lispy_> silbo_: search this page for "Record syntax" http://learnyouahaskell.com/making-our-own-types-and-typeclasses
00:14:31 <lispy_> silbo_: you might also like this: http://www.scribd.com/doc/6520470/Haskel-Cheat-Sheet
00:15:33 <lispy_> silbo_: I think most of the pages here have good tips: http://www.haskell.org/haskellwiki/Category:Syntax
00:16:07 <silbo_> lispy_: thx
00:16:45 <silbo_> lispy_: this record works only with datas ?
00:17:03 <lispy_> silbo_: yes, but you want to use fewer tuples and more data
00:17:31 <lispy_> tuples are anonymous data types.  Great in a pinch, but ideally you make a new data type with the right structure
00:18:11 <lispy_> silbo_: This article looks good: http://www.mail-archive.com/haskell-cafe@haskell.org/msg81982.html
00:19:14 * lispy_ goes to bed
00:19:43 <nanothief> edwardk: thanks for that (you're right about the scary part though :P)
00:20:40 <silbo_> lispy_: ok thx, i will check it
00:22:39 * hackagebot blaze-builder 0.2.1.4 - Efficient buffered output.  http://hackage.haskell.org/package/blaze-builder-0.2.1.4 (SimonMeier)
00:27:41 * hackagebot language-javascript 0.2.2 - Parser for JavaScript  http://hackage.haskell.org/package/language-javascript-0.2.2 (AlanZimmerman)
00:28:41 * hackagebot curry-frontend 0.2.10 - Compile the functional logic language Curry to several intermediate formats  http://hackage.haskell.org/package/curry-frontend-0.2.10 (BerndBrassel)
00:35:43 * hackagebot comonad 0.4.0 - Haskell 98 comonads  http://hackage.haskell.org/package/comonad-0.4.0 (EdwardKmett)
00:36:43 * hackagebot comonad-transformers 0.4 - Haskell 98 comonad transformers  http://hackage.haskell.org/package/comonad-transformers-0.4 (EdwardKmett)
00:39:23 <guest2425> Hello
00:39:27 <silbo_> hello
00:39:30 <silbo_> gtg
00:39:37 <guest2425> I have a question
00:39:46 <guest2425> ??
00:39:57 <guest2425> :t head
00:39:58 <lambdabot> forall a. [a] -> a
00:40:05 <guest2425> :t tail
00:40:06 <lambdabot> forall a. [a] -> [a]
00:40:13 <banisterfiend``> :t fst
00:40:14 <lambdabot> forall a b. (a, b) -> a
00:40:20 <guest2425> :t hello
00:40:20 <lambdabot> Not in scope: `hello'
00:40:26 <banisterfiend``> :t guest2425 is gay
00:40:27 <lambdabot> Not in scope: `guest2425'
00:40:27 <lambdabot> Not in scope: `is'
00:40:27 <lambdabot> Not in scope: `gay'
00:40:33 <guest2425> :t hahaha
00:40:34 <lambdabot> Not in scope: `hahaha'
00:40:44 <guest2425> banisterfiend``: why?
00:41:01 <banisterfiend``> guest2425: don't ask me, ask a geneticist. Though in summary: you prefer men.
00:41:30 <guest2425> banisterfiend``: girl you are crazy
00:41:36 <guest2425> I have a question do
00:41:41 <edwardk> banisterfiend``: wtf?
00:41:47 <guest2425> there is a c++ channel??
00:41:49 <edwardk> guest2425: shoot
00:42:07 <edwardk> ##c++
00:42:12 <guest2425> oh ok
00:42:14 <guest2425> thanks 
00:42:45 * hackagebot comonad-transformers 0.4.1 - Haskell 98 comonad transformers  http://hackage.haskell.org/package/comonad-transformers-0.4.1 (EdwardKmett)
00:42:51 <guest2425> edwardk: whats wrong with banisterfiend``???????
00:43:00 <edwardk> no idea
00:43:08 <guest2425> me too
00:43:17 <guest2425> talking nonsense
00:44:46 * hackagebot comonads-fd 0.4 - Comonad transformers using functional dependencies.  http://hackage.haskell.org/package/comonads-fd-0.4 (EdwardKmett)
00:52:04 <guest2425> edwardk: hello
00:52:10 <edwardk> heya
00:52:13 <ivanm> edwardk: finally got around to doing it? :p
00:52:19 <edwardk> ivanm: its coming along
00:52:33 <guest2425> edwardk: I am get this message in ##C++ channel == Cannot send to channel: ##c++
00:52:34 <guest2425> ?
00:52:52 <edwardk> using the webchat?
00:53:00 <guest2425> yes 
00:53:04 <Maxdamantus> Maybe it's a registered-only channel and you're not registered.
00:53:16 <edwardk> a lot of channels block folks using webchat from talking due to spammers
00:53:18 <guest2425> I can login
00:53:27 <guest2425> but i get this == Cannot send to channel: ##c++
00:53:31 <edwardk> #haskell even does it from time to time
00:53:32 <edwardk> yes
00:53:37 <edwardk> you can see, but not speak.
00:53:45 <guest2425> i know
00:53:50 <guest2425> funny
00:54:25 <edwardk> you can msg someone who is an op over there and see if they can lift the limitation on non-registered voices, or get someont there to ask for you, or you can sign in through another means (like pidgin/adium) or you can get a cloak
00:54:25 <guest2425> maybe try another day
00:54:45 <edwardk> i picked up a cloak for just this reason
00:54:48 * hackagebot hjsmin 0.0.8 - Haskell implementation of a javascript minifier  http://hackage.haskell.org/package/hjsmin-0.0.8 (AlanZimmerman)
00:55:00 <guest2425> how is an op
00:55:01 <guest2425> ?
00:55:08 <guest2425> how i can tell?
00:55:24 <guest2425> nobody sees me
00:55:30 <guest2425> I am invisible
00:55:32 <guest2425> kakakak
00:55:42 <edwardk> i don't know that anyone is opped on the channel at the moment. you can ask chanserv who is registered as the operators for the channel though
00:56:03 <guest2425> ok thank you
00:56:05 <guest2425> much
00:57:31 <guest2425> bye
00:57:37 <edwardk> later
01:18:49 <lars9> how to design a type for finite state automata's state? i dont want it to be an alias of a Int because that makes merging of several FSAs complicated
01:26:57 <gienah> lars9: these 2 links describe how to code dfa's in haskell, maybe that might give some hints: http://vorlon.case.edu/~lps/software/automata/
01:27:02 <gienah> http://www3.di.uminho.pt/~jas/Research/HaLeX/HaLeX.html
01:27:59 <lars9> gienah: let me see, thanks
01:29:29 <gienah> lars9: and this paper for the first link: http://vorlon.case.edu/~lps/papers/functional-libraries.ps.gz
01:34:11 <lars9> got it, thanks, it seems they use Int or Char for state, then when merging several FSAs, we need to rename those states
01:59:25 <Saizan> lars9: you need the cross product of the states?
01:59:39 <Saizan> *cartesian
02:05:29 <qfr> Saizan lol I had the same mixup a few days ago
02:19:18 <knobo> What is the problem with monads that arrows try to solve?
02:19:28 <knobo> (or is that the wrong question?)
02:21:22 <quicksilver> I'm not sure that the intention of arrows was particularly to solve a problem with monads
02:21:50 <quicksilver> but the difference is that they don't have something like >>=, which means they can do more statically
02:22:11 <quicksilver> like the self-optimising arrow parsers which build parse tables up front
02:22:16 <quicksilver> (well, first-token tables at least)
02:27:16 <robinhoode> @def polyvariant
02:27:17 <lambdabot> Maybe you meant: bf do let
02:27:49 <robinhoode> Dammit.. Someone write a plugin to give definitions of obscure mathematical terminology.
02:29:12 * hackagebot json-tools 0.2.3 - A collection of JSON tools  http://hackage.haskell.org/package/json-tools-0.2.3 (NicolasPouillard)
02:29:52 <Jafet> I thought @google did that
02:30:08 <robinhoode> @google polyvariant
02:30:10 <lambdabot> http://www.ncbi.nlm.nih.gov/pubmed/9435322
02:30:10 <lambdabot> Title: Polyvariant mutant cystic fibrosis transmembrane c... [J Clin Invest. 1998] - Pu ...
02:30:18 <robinhoode> Hmm...
02:30:27 <Jafet> ...most of the time.
02:30:34 <hotaru2k3> @google define:polyvariant
02:30:35 <lambdabot> No Result Found.
02:31:13 * robinhoode feels @def should give back references from #haskell sanctioned literature.
02:32:20 <robinhoode> Like, @def natural transformation should quote me stuff from Mac Lane's book or something
02:32:41 <robinhoode> I dunno.. Seems appropriate to me
02:32:46 <quicksilver> wiktionary says polyvariant = multivariant
02:32:51 <Jafet> Implement it, then
02:33:45 <robinhoode> Experience has taught me that software is not the kind of thing in the universe where "if you build it, they will come"
02:35:14 <robinhoode> quicksilver, Yeah, but what does it mean in the context of CS?
02:35:29 <robinhoode> ..and in particular, type theory
02:37:15 * hackagebot json-tools 0.2.4 - A collection of JSON tools  http://hackage.haskell.org/package/json-tools-0.2.4 (NicolasPouillard)
02:39:05 <rrc7cz> has anyone tried setting up HDBC-Postgres on a Windows machine?
02:43:10 <quicksilver> robinhoode: it might mean mixed co and contra variant polymorphism?
02:43:59 <robinhoode> quicksilver, Maybe.. I kinda stopped searching..
02:44:28 <quicksilver> it's also used as an abbreviation for ocaml's polymorphic variants
02:45:15 <qfr> rrc7cz I will do that soon
02:46:35 <rrc7cz> qfr: running "cabal install hdbc-postgresql" fails with "setup.exe: pgconfig is required but it could not be found."  I've found some talk about pgconfig bin being part of libpq-dev on nix systems, but I can't figure out what's actually going on and/or missing
02:46:59 <qfr> rrc7cz I am familiar with that one from gem install pg issues
02:47:01 <qfr> In Ruby
02:47:25 <qfr> rrc7cz pgconfig comes with PG afaik
02:47:31 <qfr> It's in bin\pgconfig.exe
02:47:46 <qfr> You just add it to your path, for example
02:47:49 <qfr> Then it might work
02:48:11 <rrc7cz> qfr: I'll give it a shot, thanks!
02:49:04 <rrc7cz> qfr: one possible bump: it looks like on Windows at least, with v9, it's called pg_config
02:49:15 <qfr> o
02:49:30 <qfr> mklink it
02:51:09 <rrc7cz> qfr: no need, somehow the setup.exe bin that HDBC-postgres uses found it now
02:51:18 <qfr> ;o
02:51:19 <rrc7cz> qfr: so just adding /bin to the path as you suggested fixed it
02:51:28 <rrc7cz> awesome, thank you
02:51:31 <qfr> nice
02:56:55 <haskellElephant> @pl (\n -> n^n)
02:56:55 <lambdabot> join (^)
02:59:23 <Jafet> @pl \x -> fromIntegral x ^^ fromIntegral x
02:59:23 <lambdabot> liftM2 (^^) fromIntegral fromIntegral
02:59:29 <qfr> Oh, does it perform some function matching/simplifications?
02:59:34 <qfr> That's nice
02:59:47 <dolio> pl eliminates points
02:59:59 <qfr> What's a point?
03:00:18 <ivanm> qfr: variables
03:00:20 <dolio> Explicitly bound variables.
03:00:23 <ivanm> (simplistically speaking)
03:00:30 <ivanm> @google haskell pointfree
03:00:31 <lambdabot> http://stackoverflow.com/questions/2464406/point-free-in-haskell
03:00:31 <lambdabot> Title: pointfree - Point-free in Haskell - Stack Overflow
03:00:36 <ivanm> not what I was after...
03:00:39 <ivanm> @where pointfree
03:00:40 <lambdabot> I know nothing about pointfree.
03:00:43 <ivanm> @where pointless
03:00:44 <lambdabot> I know nothing about pointless.
03:00:46 <ivanm> @where points
03:00:46 <lambdabot> I know nothing about points.
03:00:48 <ivanm> @where point
03:00:48 <lambdabot> I know nothing about point.
03:00:50 <Jafet> It can also remove your coursework points
03:00:56 <ivanm> geez you're useless lambdabot :p
03:01:01 <qfr> Does point have anything to do with function composition?
03:01:02 <ivanm> Jafet: heh
03:01:06 <ivanm> qfr: no
03:01:16 <ivanm> except that function composition can help make it pointfree
03:01:21 <ivanm> @google haskell wiki pointfree
03:01:23 <lambdabot> http://haskell.org/haskellwiki/Haskell/Pointfree
03:01:24 <lambdabot> Title: Pointfree - HaskellWiki
03:01:28 <ivanm> qfr: ^^
03:02:03 <gienah> @pl (\x acc -> 2 * acc + x)
03:02:04 <lambdabot> (. (2 *)) . (+)
03:02:19 <Jafet> @where+ pointless http://haskell.org/haskellwiki/Haskell/Pointfree
03:02:20 <lambdabot> Done.
03:02:24 <Jafet> @where+ pointfree http://haskell.org/haskellwiki/Haskell/Pointfree
03:02:25 <lambdabot> Nice!
03:06:29 <qfr> Ah, right
03:06:34 <qfr> Yeah I've come across that before
03:07:01 <qfr> Avoiding the pattern f x = g x basically
03:07:08 <quicksilver> terminology comes from topology, AFAIK
03:07:11 <qfr> Where g is obviously more complex
03:07:26 <quicksilver> where it's more elegant to give an elementary definition in higher terms than one mentioning individual points
03:07:45 <quicksilver> similarly vector spaces and trying to state theorems / proofs without picking a basis.
03:22:09 <pacak> In the project i am working at now i have to use several libraries. One of those imports monads from mtl, the other one imports something from monads-tf. In my code i use only impots monads-tf and still i am getting this: http://dpaste.com/295143/
03:22:49 <ivanm> pacak: yeah, not much you can do about that :/
03:23:14 <zygoloid> sounds like a job for package-qualified imports
03:23:24 <ivanm> zygoloid: nah, looks like an implicit import problem
03:23:32 <ivanm> does mtl-2 still have that Either instance there?
03:23:37 <pacak> zygoloid: 
03:23:40 <pacak> import "mtl" Control.Monad.Error
03:23:42 <pacak> ?
03:23:43 <pacak> and so on?
03:23:51 <zygoloid> ivanm: ah yeah, reading comprehension failure
03:24:13 <zygoloid> the Monad Either instance is in base now, isn't it?
03:26:36 <pacak> Fortunatly the library, that wants mtl can be easily replaced with ~50 lines of my own code and everything starts to work again, but it does not feels right.
03:28:06 <pacak> Also those libraries wants to use different types for strings: ByteString, ByteString.Lazy and Text. They can't be replaced, but data from one library must be used in other one.
03:29:02 <zygoloid> converting between those is easier, but you need to be aware of encoding issues when going Text <-> ByteString[.Lazy]
03:29:50 <pacak> zygoloid: utf8 is the only encoding here.
03:30:46 <pacak> zygoloid: But it is a lot of useless transformations. Amounts of data are 10-500 bytes, but there are lots of them.
04:32:27 <parcs> pacak: what is this notation: import "mtl" Control.Monad.Error
04:33:22 <pacak> parcs: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Packages/PackageImportsProposal?redirectedfrom=PackageImports
04:34:01 <pacak> parcs: Or somewhere near
04:34:38 <parcs> neat, i've been looking for something like that
04:38:46 <pacak> parcs: Yes, but it does not helps in my case :)
04:52:51 <EvanR> can i use existentials like this
04:53:05 <EvanR> type Foo = forall a. (JSON a) => a
04:54:28 <augur> is that an existential
04:54:31 <augur> i dont think it is..
04:54:38 <cncl> it's not
04:54:49 <augur> also, i think the forall a part is done as a type parameter
04:54:57 <lunaris> It's a Rank-2 type isn't it?
04:55:03 <EvanR> im looking at this
04:55:05 <cncl> no
04:55:09 <EvanR> http://www.haskell.org/haskellwiki/Existential_type
04:55:16 <cncl> i mean it uses the syntax
04:55:19 <cncl> but it doesn't say anything new
04:55:22 <cncl> unless i am mistaken
04:55:24 <EvanR> which says data Obj = forall a. (Show a) => Obj a
04:55:43 <cncl> that's not the same as what you said
04:55:45 <augur> hmm
04:55:48 <EvanR> i know
04:55:52 <EvanR> it reduces wrappers
04:56:00 <EvanR> not allowed i guess
04:56:05 <cncl> hm
04:56:08 <cncl> does it work if you use it?
04:56:12 <cncl> i would guess that ghc gets angry
04:56:28 <augur> isnt what EvanR wrote the same as   data Foo a = (JSON a) => a
04:56:28 <augur> ?
04:56:31 <lunaris> Works for me with RankNTypes and LiberalTypeSynonyms
04:56:34 <cncl> no
04:56:39 <lunaris> Something like:
04:56:40 <augur> ok
04:56:45 <lunaris> type Foo = forall a. Num a => a
04:56:46 <cncl> wow i didn't know about LiberalTypeSynonyms
04:56:52 <cncl> lunaris for the win
04:56:58 <lunaris> let f = undefined :: Foo -> Int
04:56:59 <augur> oh no, it cant be that could it
04:57:04 <lunaris> Something like that?
04:57:21 <lunaris> Works for me in 6.12.3
04:57:33 <augur> hm ok, so why is Obj there not the same as   data (Show a) => Obj a = Obj a
04:57:37 <augur> or something like that
04:57:41 <roconnor> jmcarthur: I'm starting to like your proposal: http://www.haskell.org/pipermail/haskell-prime/2011-January/003334.html
04:57:44 <augur> not that i expect that to be valid, but
04:58:03 <lunaris> Well, one's a type synonym and one's a new data type?
04:58:14 <lunaris> I.e. type Foo = ... doesn't actually introduce anything new.
04:58:17 <augur> hm no i guess i can see why..
04:58:24 <augur> hm.
04:58:43 <EvanR> it doesnt work for me
04:59:15 <EvanR> lunaris: it avoids using forall a. (Show a) => everywhere you use Foo
04:59:19 <augur> so from what i see, this existential type thing is sort of like interfaces, at least in that in Java interfaces you can do things like List<SomeInterface>
04:59:38 <augur> which would be multi-classed but would only be classes implementing SomeInterface
04:59:52 <EvanR> i dont think java has much to do with it
04:59:53 <cncl> one way to think about existential quantification is that the only information is saves are the class methods
05:00:03 <dolio> roconnor: That appears to be a proposal by Ken Shan.
05:00:07 <augur> EvanR: no, it doesnt, but im just bringing it back to something we were talking about a few days ago
05:00:09 <cncl> because nothing else can be recovered from the context of a type signature containing one
05:00:12 <lunaris> EvanR: I'm having a play now.
05:00:19 <augur> could you do with this, say...   [forall a. (Show a) => a]
05:00:19 <augur> ?
05:00:27 <EvanR> you dont need to use classes with existentials
05:00:28 <lunaris> You'd need a wrapper type.
05:00:29 <roconnor> jmcarthur: in gernal since a subclass is an extension of a class signature, we should just be able to define all the methods of the superclass instance at the same time.  So if Functor => Applicative => Monad, then one should should be able to write Instance Monad where (... give all the methods forall of Functor, Applicative, Monad ...) and get instances for Monad and all its superclasses at once
05:00:38 <lunaris> EvanR: I can get it to work.
05:00:40 <EvanR> augur: normally yes
05:00:45 <lunaris> Something like:
05:00:48 <lunaris> f :: Foo -> Integer
05:00:51 <lunaris> f x = fromInteger x
05:00:53 <roconnor> dolio: yes but it is similar to the proposcal that jmcarthur was advocating 8 hours ago.
05:00:53 <EvanR> augur: er i mean, normally youd need a wrapper
05:00:56 <augur> EvanR: and would it allow you to have the list ["a", 1]?
05:01:01 <augur> oh ok. so you need the wrapper.
05:01:09 <EvanR> right
05:01:11 <lunaris> Of course, to call f, you need to give it a value of type a, *forall* Num a.
05:01:14 <roconnor> dolio: maybe calling it jmcarthur's proposal was a little confusing
05:01:19 <lunaris> The only way to do this of course is to use the methods from Num.
05:01:35 <dolio> Oh, that sort of proposal. Yes, I'd like that ability.
05:01:36 <lunaris> Which at the point of call have their types fixed to some specific instance.
05:01:43 <EvanR> augur: and if so, you could do [show "a", show 1] instead. however, JSON would add more type safety than String
05:01:50 <roconnor> jmcarthur: at this point in time it becomes natural to give default instances of superclass methods in subclasses
05:02:14 <lunaris> succ crossTalk :P
05:02:21 <augur> EvanR: assuming i want the strings; but i think the point is more to have a way of doing semi-duck-typing
05:02:26 <EvanR> no
05:02:28 <EvanR> i want strings
05:02:35 <dolio> That was part of the superclass instances proposal that Conor was implementing in SHE, I think. But I'm not sure if he's done that piece yet.
05:02:38 <augur> EvanR: i know you do :p
05:02:46 <augur> EvanR: im talking about what _i_ want! :p
05:02:56 <dolio> It does do default superclass instances now, though.
05:03:26 <augur> hmm..   is such a thing possible:   type Duck c = forall a. (c a) => Duck a
05:03:27 <augur> ?
05:03:29 <EvanR> augur: personally i think classes for oop are overkill, you could instead make an existentially quantified record with functions in them that use the missing type
05:03:38 <augur> er, wlel, i suppose that'd be a data, not a type, but
05:04:14 <augur> that is to say, a parameter for a type class?
05:04:24 <EvanR> ... no
05:04:30 <augur> shame!
05:04:45 <augur> it would certainly make such a thing easier
05:04:45 <cncl> you don't even need to use existentials for that :)
05:04:48 <augur> [Duck Show]
05:04:49 <dolio> roconnor: Oh, it does: http://personal.cis.strath.ac.uk/~conor/pub/she/superclass.html
05:04:54 <cncl> just a record with functions in it
05:04:59 <EvanR> data Duck a = Duck {state :: a, quack :: a -> IO a}
05:05:13 <EvanR> existential just lets you remove the left a
05:05:20 <EvanR> er
05:05:21 <roconnor> dolio: what Chung-chien Shan is proposing seems to be different from what Conor was proposing
05:05:21 <EvanR> IO ()
05:05:22 <cncl> don't forget a Duck a -> Duck a one too
05:05:28 <cncl> or something like that, haha
05:05:41 <EvanR> {mutate :: a -> Duck a}
05:06:04 <EvanR> you can also do this with a function
05:06:10 <dolio> roconnor: In the third code snippet you can see him defining a superclass method in a subclass instance.
05:06:44 <dolio> The difference between that and the ccshan proposal is that the latter requires you to document which superclass methods you're defining.
05:06:45 <roconnor> dolio: it is possible conor's proposal is isomorphic
05:07:25 <EvanR> cncl: all of this is sillyness, ill just use the wrapper
05:07:33 <augur> chung-chieh shan! :D
05:07:39 <augur> shan as awesome.
05:07:43 <augur> so is chris barker
05:27:02 <quicksilver> dolio: the reason you didn't know he'd done that is he only just did it.
05:27:10 <quicksilver> dolio: in response to the discussion on libraries@, I think
05:27:19 <roconnor> does anyone happen to have a copy of "Elementary information Theory" by Douglas Jones 1979?
05:29:16 <dolio> quicksilver: He'd talked about doing it a few days back. Both parts.
05:29:35 <quicksilver> dolio: *nod*. Well, "only just" being the last few days.
05:29:41 * quicksilver thinks conor should IRC.
05:29:48 <dolio> He does.
05:29:53 <dolio> Just not here.
05:30:03 <quicksilver> consider my thought amended appropriately.
05:30:10 <dolio> He's pigworker.
05:30:40 <dolio> In #epigram and #agda at least.
05:31:49 <dolio> Anyhow, he did superclass defaults in 0.2.
05:31:57 <dolio> Now there's 0.3, and I don't know what changed.
05:41:48 <aristid> @hoogle hoist
05:41:49 <lambdabot> No results found
05:43:05 <quicksilver> aristid: http://www.mail-archive.com/haskell-cafe@haskell.org/msg39098.html http://hackage.haskell.org/packages/archive/comonad-transformers/0.2.0/doc/html/Control-Comonad-Hoist-Class.html
05:45:35 <aristid> quicksilver: the mailing list post is what i was looking at before doing @hoogle. i was hoping that somebody had put monadic hoist in a package. it's nice to see comonadic hoist, but that's not what i was looking for
05:46:13 <quicksilver> aristid: some people were discussing it yesterday
05:46:29 <aristid> quicksilver: yeah, that's where my browser tab came from
05:46:31 <quicksilver> really it belongs in transformers or your-replacement-of-choice
06:12:55 * hackagebot json-tools 0.3.0 - A collection of JSON tools  http://hackage.haskell.org/package/json-tools-0.3.0 (NicolasPouillard)
06:19:27 <rrc7cz> I found this: http://hpaste.org/42518/crpytobuildfail?pid=42518&lang_42518=d  which is the same problem I'm facing now while trying to "cabal install UUID" Any idea what it could be?
06:33:04 <MrWish544> hi there
06:33:15 <humasect> hello
06:35:02 * hackagebot xorshift 2 - Haskell implementation of the xorshift random generator.  http://hackage.haskell.org/package/xorshift-2 (RobertClausecker)
06:35:04 * hackagebot json-tools 0.3.1 - A collection of JSON tools  http://hackage.haskell.org/package/json-tools-0.3.1 (NicolasPouillard)
06:46:56 <dpratt71> what's the name of that thing where you can draw a symbol and it will try to match it with a LaTeX symbol?
06:47:14 <Saizan> detexify
06:47:24 <dpratt71> Saizan: thanks!
06:52:21 <alpounet> anybody here has any experience with multiple users and twidge ?
06:53:23 <dpratt71> sorry for being vague, but someone was mentioning how they identify a math symbol with detexify and then go...somewhere else (Wolphram Alpha?) to find out what it means. Anyone have a clue what I'm talking about?
06:54:48 <rrc7cz> is there any example of how to handle a long living resource? For example, I'd like to open a DB connection and prepare some statements. Method invocations should use these resources. How do you manage them? How do you open and close them? Here's the problem: https://gist.github.com/769538  right now I can only open/close on a local basis but it's inefficient
07:04:20 <Saizan> dpratt71: wolframalpha.com ?
07:05:22 <dpratt71> Saizan: looked at that, but if that's it, I don't know how to use it (for the purpose I described)
07:06:01 <dpratt71> by the way, is it just me, or does the 'logs' web page not display the list of logs
07:09:28 <augur> copumpkin!
07:09:34 <copumpkin> greetings!
07:09:40 <augur> ping!
07:09:52 <copumpkin> !gnop
07:10:10 <augur> :X
07:10:48 <augur> copumpkin: did i ask you about zipper-ish let definitions?
07:10:54 <yrlnry> dpratt71:  I see the list of logs/
07:11:07 <copumpkin> augur: nope, but I need to run to work
07:11:12 <copumpkin> so maybe a bit later :)
07:11:21 <augur> copumpkin: well when you get to work will you be on irc? :P
07:11:23 <yrlnry> dpratt71:  http://tunes.org/~nef/logs/haskell/11.01.07 ‚Üê today's log
07:11:31 <copumpkin> augur: usually
07:11:38 <copumpkin> may not be paying much attention though :)
07:11:39 <augur> copumpkin: awesome <3
07:11:59 <augur> attention is not necessary!
07:12:03 <yrlnry> Hmm, my ‚Üê does not appear properly in the log file. 
07:12:39 <yrlnry> No, it's fine, it's just a browser issue.
07:12:41 <augur> copumpkin: you should also reserve the "copumpking" username for when you're at work
07:12:50 <augur> .. "copumpkin"**
07:13:23 <dpratt71> yrlnry: thanks; on Chrome the page appears to be loading very slowly; on IE 9, not at all
07:14:50 <copumpkin> :P
07:14:53 <yrlnry> dpratt71:  It works quickly from here.
07:15:05 <augur> copumpkin: cause you'd be a corporate pumpkin!
07:17:29 <quuuux> @pl \ a -> f a . g
07:17:29 <lambdabot> (. g) . f
07:18:35 <augur> haskell's ability to do this (. g) sort of thing is such a cheat
07:19:01 <quicksilver> it's not necessary.
07:19:12 <quicksilver> it's just shorthand for (flip (.) g)
07:19:19 <augur> quuuux: i know, but thats why its a cheat
07:19:41 <augur> cause it makes it look so clean
07:19:54 <augur> want to somehow pull the (.) to the front while leave the a at the end?
07:20:19 <augur> easy! (. g) is a function, so f a . g == (. g) (f a)!
07:20:29 <augur> so cheatful
07:20:45 <Jafet> @unpl (.g).f
07:20:45 <lambdabot> (\ d i -> f d (g i))
07:20:56 <yrlnry> @unpl (.)
07:20:57 <lambdabot> (\ a b c -> a (b c))
07:20:57 <Jafet> Fudgy
07:21:09 <yrlnry> @unpl id
07:21:09 <lambdabot> (\ a -> a)
07:21:43 <augur> Jafet: fudgy?
07:21:53 <Jafet> f d g i
07:21:57 <augur> o ok
07:24:46 <quuuux> @hoogle Integer -> Integer -> Integer -> Bool
07:24:47 <lambdabot> Text.Regex.Base.RegexLike makeRegexOpts :: RegexMaker regex compOpt execOpt source => compOpt -> execOpt -> source -> regex
07:24:47 <lambdabot> Text.Regex.Base.RegexLike makeRegexOptsM :: (RegexMaker regex compOpt execOpt source, Monad m) => compOpt -> execOpt -> source -> m regex
07:24:47 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
07:26:06 <alpounet> is there somewhere a function to escape special shell chars ?
07:26:42 <Renze> Is anyone over here with some Hack experience? (Web library)
07:26:51 <alpounet> oh
07:26:55 <alpounet> there's shell-escape
07:32:54 <lars9> how to define new type in GHCi?
07:33:03 <sipa> define it in a file
07:33:05 <sipa> and load the file
07:33:26 <lars9> can not use type F = Int?
07:35:01 <aavogt> there may be some fancy .ghci that lets you do that defining and loading with a single command
07:35:41 <aavogt> @where goa
07:35:41 <lambdabot> http://haskell.org/haskellwiki/GHC/GHCi#GHCi_on_Acid
07:36:50 <aavogt> lambdabot: but it might not be that GHCi on Acid though
07:38:08 <lars9> ahh... needs more config
07:38:15 <lars9> save time to load file now
07:38:30 <lars9> *flip words
07:40:12 <dpratt71> Does anyone know a resource where I can learn more of what is meant by such things as (A ‚ä¢ A) and (¬¨A,A ‚ä¢ ‚ãÑ) ?
07:40:27 <dpratt71> oh, shoot
07:40:28 <dpratt71> brb
07:41:13 <FauxFaux> dpratt71: http://en.wikipedia.org/wiki/Table_of_mathematical_symbols ¬¨_¬¨
07:41:33 <FauxFaux> That is entails, which isn't exactly common outside of prolog.
07:44:17 <Saizan> sure, except for almost all the descriptions of formal systems :)
07:47:27 <Saizan> dpratt71: usually it's used to separate a list of assumptions on the left (often called a context) from a conclusion you can derive from them on the right
07:48:28 <Saizan> the specific syntax and meaning of the assumptions and conclusion (which are not standard terms though) tends to vary
07:49:15 <Saizan> yours seem to have just formulas in propositional logic
07:54:34 <lars9> @hoogle State
07:54:34 <lambdabot> module Control.Monad.State
07:54:34 <lambdabot> Test.HUnit.Base data State
07:54:35 <lambdabot> Test.HUnit.Base State :: Path -> Counts -> State
07:56:56 <dpratt71> FauxFaux, Saizan: thanks
07:58:21 <dpratt71> Saizan: I believe (but am by no means certain) that what was being expressed was that there was a transformation from (A ‚ä¢ A) to (¬¨A,A ‚ä¢ ‚ãÑ)
07:58:50 <dpratt71> when the A moves across the turnstile, it gets decorated with ¨
08:00:02 <kafee> ok I 've refactored my smelly program from yesterday, and still gets a stack overflow: http://hpaste.org/42841/stack . It that because of chuncks of + ?
08:01:22 <Jafet> kafee: perhaps. Are you compiling with optimization?
08:01:54 <kafee> no
08:02:26 <Jafet> GHC's optimizer strictifies arithmetic nearly always
08:02:41 <Jafet> Alternatively, you can use $! or seq.
08:03:17 <Peaker> > length (replicateM 5 "abc")
08:03:18 <lambdabot>   243
08:03:28 <Peaker> > length (replicateM 26 "abc")
08:03:30 <kafee> Jafet: how could I use $! on a (d+1) b c ? I tried on the other sum, but got a overflow too
08:03:32 <lambdabot>   mueval-core: Time limit exceeded
08:03:39 <Peaker> > length (replicateM 5 ['a'..'z'])
08:03:43 <lambdabot>   11881376
08:03:56 <Peaker> kafee, Your replicateM of 26 against 'a'..'z' is a bit on the insane side :)
08:04:19 <Peaker> kafee, Trying every possible password of every length up to 26? :)
08:04:40 <kafee> its a naive way to get all strings
08:04:45 <mauke> > 26^26
08:04:46 <kafee> using 'a' ..'z'
08:04:46 <lambdabot>   6156119580207157310796674288400203776
08:05:01 <Jafet> kafee: use seq for the entire expression.
08:05:19 <Jafet> sum also has a space leak by default
08:05:20 <kafee> Peaker: no
08:05:21 <Peaker> > sum $ map (26^) [1..26]
08:05:23 <lambdabot>   6402364363415443603228541259936211926
08:05:30 <Jafet> Or, ignore all that and apply -O
08:05:43 <kafee> trying project euler, but no ideas for better algorithm
08:05:59 <mauke> which problem?
08:06:02 <Peaker> kafee, btw: HLint has nice hints for you
08:06:08 <kafee> humm
08:06:13 <Peaker> kafee, link to Euler problem?
08:06:14 <kafee> 158
08:06:35 <mauke> http://projecteuler.net/index.php?section=problems&id=158
08:06:36 <kafee> http://projecteuler.net/index.php?section=problems&id=158
08:06:48 <Peaker> kafee, Taking just 3 letters is replicateM 3 ['a'..'z']
08:06:59 <Peaker> > 26^3
08:07:00 <lambdabot>   17576
08:07:13 <Peaker> significantly smaller than 6402364363415443603228541259936211926 :)
08:07:14 <mauke> Peaker: did you even read that?
08:07:20 <Peaker> only the beginning :)
08:07:29 <aristid> > replicateM 3 ['a'..'z']
08:07:30 <lambdabot>   ["aaa","aab","aac","aad","aae","aaf","aag","aah","aai","aaj","aak","aal","a...
08:07:50 <aristid> > length $ replicateM 3 ['a'..'z']
08:07:51 <lambdabot>   17576
08:07:56 <aristid> > 26 ^ 3
08:07:58 <lambdabot>   17576
08:08:07 <j-invariant> > 99^99^99
08:08:09 <kafee> Peaker: i saw
08:08:19 <lambdabot>   *E
08:08:29 <ion> *E?
08:08:35 <Jafet> Exceptional exception
08:08:36 <Peaker> mauke, now I did :)
08:08:56 <kafee> but the problem requires only the different substrings
08:09:04 <aristid> lambdabot not build :(
08:09:21 <Peaker> kafee, Well, you should prune those strings that have more than one lex-after character early.. ideally you could compute it without actually generating the strings 
08:11:27 <kafee> Peaker: I 'll think about it
08:12:24 <bartavelle> the letters are different btw
08:12:28 <Jafet> Each such string must consist of two descending runs.
08:13:25 <Peaker> Jafet, not only that, but the latter run's (!!1) must be smaller than the last of the first run 
08:13:58 <Peaker> you could say it's one descending run with one stray high inserted somewhere in the middle
08:14:22 <Jafet> Huh
08:15:01 <Peaker> if your two descending runs are: edcba and fedcb  that doesn't work
08:15:33 <bartavelle> letters should be different
08:16:18 <Jafet> Peaker: did you even read that?
08:16:45 <Peaker> oops, "neighbor to the left" makes it significant easier :)
08:21:01 <augur> copumpkin: are you at work yet :|
08:21:11 <copumpkin> I am indeed
08:21:31 * hackagebot polyparse 1.5 - A variety of alternative parser combinator libraries.  http://hackage.haskell.org/package/polyparse-1.5 (MalcolmWallace)
08:23:24 <j-invariant> did anyone read the three posts http://comonad.com/reader/2008/kan-extensions/
08:28:25 <joe6> is there a higher order function that can do: fn :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]
08:28:52 <Peaker> @type zipWith
08:28:55 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
08:28:57 <joe6> something like map but on 5 lists
08:28:58 <Peaker> you want zipWithN?
08:29:07 <joe6> > zipWith5
08:29:09 <lambdabot>   Overlapping instances for GHC.Show.Show
08:29:09 <lambdabot>                              ((a ->...
08:29:13 <Peaker> @type zipWith5
08:29:14 <lambdabot> forall a b c d e f. (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]
08:29:19 <joe6> thanks a lot.
08:29:24 <Peaker> @hoogle (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]
08:29:25 <lambdabot> Data.List zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]
08:29:25 <lambdabot> Control.Monad liftM5 :: Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
08:29:28 <Peaker> you could ask Hoogle :)
08:29:41 <Peaker> also, you can use the ZipList Applicative for generalized this
08:39:30 <exDM69> @hoogle zipWithN
08:39:31 <lambdabot> No results found
08:40:09 <exDM69> oh yeah, zipWithN would be quite difficult to type
08:41:59 <alpounet> exDM69, http://paczesiowa.blogspot.com/2010/03/generalized-zipwithn.html
08:42:26 <exDM69> alpounet: ah, neat
08:42:37 <exDM69> does it use some of the newer language extensions?
08:42:40 <j-invariant> it seems like a lot of thins people want to do in haskell are nod straight foward
08:43:26 <alpounet> exDM69, depends on your definition of "newer" :p
08:44:16 <quicksilver> well there are good reasons that variable arity functions in haskell will always be a hack
08:44:24 <tswett> How easy would it be to make GHC support types like "exists a. a"?
08:44:46 <exDM69> alpounet: post haskell-98. apparently that uses a ton of extensions
08:44:54 <alpounet> yeah
08:44:55 <alpounet> it does
08:45:29 <exDM69> quicksilver: I can see the reasons why, but do you know of any work related to variable arity functions and good type inference?
08:45:29 <aavogt> some of those extensions existed even before 1998
08:45:43 <exDM69> but they just didn't make it to the standard
08:46:13 <lars9> @hoogle auto
08:46:14 <lambdabot> No results found
08:47:10 <quicksilver> exDM69: well it's not the type inference that worries me, it's the fact that all functions in haskell are arity one
08:47:31 <quicksilver> exDM69: and we encode higher arities by functions which return functions.
08:47:43 <quicksilver> so, for example, the 'arity' of "id :: a -> a" is not always 1.
08:48:04 <quicksilver> which makes polymorphic varargs tricky - how do you know when to stop?
08:48:44 <tac-tics> @type id :: (Int -> Int) -> Int ->Int
08:48:44 <aavogt> from the expected type
08:48:45 <lambdabot> (Int -> Int) -> Int -> Int
08:49:14 <aavogt> :t printf "" a b c d e :: Int -> String
08:49:15 <lambdabot>     No instance for (PrintfArg Expr)
08:49:15 <lambdabot>       arising from a use of `printf' at <interactive>:1:0-18
08:49:15 <lambdabot>     Possible fix: add an instance declaration for (PrintfArg Expr)
08:49:48 <quicksilver> aavogt: yes, I do know the some of the answers that various tricks in practice use
08:49:50 <lars9> for Set s, is there easier way to do: fromList $ concatMap f (toList s), in which f::a->[a]?
08:49:58 <quicksilver> but they're all a bit unsatisfying
08:50:00 <aavogt> it's the same thing in my opinion as zipWith1 zipWith2 ...
08:50:17 <exDM69> haskell printf still boggles my mind
08:50:38 <exDM69> I've never had the time to sit down and figure out how it works
08:50:50 <aavogt> it works with class
08:51:51 <exDM69> that far I can figure out pretty easily
08:53:21 <Cale> The result type of printf is typeclass polymorphic, and one of the instances for that result type allows it to be a function type for taking another parameter.
08:54:05 <Cale> There's a bit of cleverness I suppose in how those parameters are collected up and applied by the String and IO () instances.
08:54:43 <quicksilver> zipWithN is similar 'saved' because the result definitely has [] type, not (->) type.
08:55:03 <lunaris> http://okmij.org/ftp/Haskell/polyvariadic.html is always a good reference.
08:55:06 <quicksilver> but for a more general varargs you're stuck, if (->) might be the type of the final return value.
08:56:06 <lunaris> exDM69: Regarding how printf works, it's similar to induction.
08:56:45 <lunaris> exDM69: You know how to add 1 to things (for example data Nat = Zero | Succ Nat), so you can use that add any number to things.
08:57:03 <lunaris> exDM69: Similarly, writing printf for a single Char or String argument is trivial
08:58:12 <lunaris> exDM69: So you can write a printf for a (Char -> b) or (String -> b) type, in a similar manner (or thereabouts)
08:58:30 <lunaris> exDM69: By accumulating the parameters in a [String] or similar.
08:58:49 <lunaris> exDM69: You can be arbitralily complex in practice, but the principle remains the same.
08:59:41 <exDM69> lunaris: thanks for the description
09:00:14 <lunaris> exDM69: Not sure I helped, it takes a bit more time to go into detail
09:00:23 <lunaris> exDM69: I'm unfortunately just on the way out :P
09:00:52 * lunaris shuffles away
09:00:57 <adulteratedjedi> Are there any Speech Recignition Libraries for haskell?
09:01:18 <adulteratedjedi> recognition even
09:01:49 <kafee> what the extension OveloadedStrings does?
09:02:08 <Zao> kafee: It lets you use string literals for types other than String.
09:02:16 <monochrom> "hello" :: ByteString
09:02:20 <Zao> So you could match a bytestring against "omg" for example.
09:02:23 <Zao> Or construct from.
09:02:41 <Zao> The "strings" in OverloadedStrings is about literals.
09:05:38 <exDM69> lunaris: yeah, truly understanding how it works requires you to sit down and figure out how it works. You gave a good cursory introduction, though
09:14:28 <lars9> when defining data F a = ..., how to restrict a to be Eq ?
09:14:43 <j-invariant> lars9: Eq a goes on the functions
09:14:55 <tswett> I think you write "data Eq a => F a = ..." or something like that.
09:15:09 <tswett> Or maybe it does somewhere else.  I know you can restrict the type itself.
09:15:30 <copumpkin> ick
09:15:34 <lars9> j-invariant: restriction on functions works
09:15:40 <copumpkin> don't put restrictions on data, 
09:15:47 <copumpkin> put it on constructors (GADT-wise) or on functions using it
09:15:58 <copumpkin> create :: Eq a => F a
09:16:05 <copumpkin> moo :: F a -> F a
09:16:16 <copumpkin> (that would have a GADT that carries the Eq with it)
09:16:20 <lars9> copumpkin: yeah, doing this way
09:18:40 <quicksilver> anecdotally you often don't want the restriction on the type, even when you think you do
09:18:55 <quicksilver> it stops you, for example, making the type into a Functor or an Applicative instance.
09:19:00 <portnov> @package setters
09:19:01 <lambdabot> http://hackage.haskell.org/package/setters
09:19:41 <aristid> quicksilver: isn't that an indication that it would not be a valid Functor anyways?
09:21:47 <lars9> quicksilver: yeah, i see...
09:24:17 <quicksilver> aristid: not necessarily.
09:24:42 <quicksilver> aristid: consider a game board which holds game pieces, and your idea is their interface is described by a class GamePiece gp =>
09:24:54 <quicksilver> aristid: so you make that restriction on the gameboard constructor.
09:25:28 <quicksilver> aristid: this turns out to be annoying when writing an AI routine later, because you want to use the same "shape" (game boards) to store local move scores, or partially evaluated fitness functions
09:25:33 <quicksilver> (instead of pieces)
09:25:54 <quicksilver> or probability functions over pieces or....
09:25:55 <aristid> quicksilver: sounds like you don't want the constraint at all, in that case
09:26:01 <quicksilver> right, you don't ;)
09:26:05 <quicksilver> but you thought you did, up front.
09:26:10 <quicksilver> or, my mythical protagonist did :)
09:26:38 <aristid> i can empathise with your mythical protagonist tho
09:26:51 * hackagebot interleave 1.0 - Combinators for supporting interleaving of different behaviours  http://hackage.haskell.org/package/interleave-1.0 (NeilBrown)
09:27:24 <quicksilver> aristid: I'm only make a soft point based on experience - that often, when people think they wanted constraints on data structures, it later became clear that was a mistake.
09:27:38 <quicksilver> There are certainly cases when bundling dictionaries into constructors is a useful feature, I don't deny it.
09:28:25 <aristid> quicksilver: i would not put constraints into types, unless somebody in #haskell told me i should :)
09:31:42 <Cale> aristid: You should put arbitrary constraints on all your types. <trollface>
09:32:06 <quicksilver> OMG! Cale trolling? I never thought I'd see the day.
09:32:42 <monochrom> define "arbitrary" mathematically
09:33:14 <quicksilver> "chosen by fair dice roll"
09:33:15 <aristid> Cale: ok.
09:33:42 <tac-tics> Monochrome arbitrary = "let"
09:33:49 <aristid> Cale: i will put Monoid constraints on all types.
09:34:00 <tac-tics> "Let x be a number." X is now arbitrary
09:34:30 <aristid> > let arbitraryNumber in arbitraryNumber
09:34:32 <lambdabot>   <no location info>: parse error on input `in'
09:34:46 <aristid> tac-tics: haskell does not support arbitrariness, it seems
09:35:44 <tac-tics> Aristid, arbitary in haskell is lambda
09:35:47 <ion> > (\x -> x) :: Integer -> Integer
09:35:48 <lambdabot>   Overlapping instances for GHC.Show.Show
09:35:48 <lambdabot>                              (GHC.I...
09:35:52 <ion> Now x is an arbitrary integer. :-)
09:36:04 <tac-tics> Exactly, ion
09:36:21 <tac-tics> Arbitrary is any unbound premise
09:36:25 <monochrom> it's funny people go out of their way to type my name manually and do the extra work of pressing an extra shift and an extra e
09:36:36 <aristid> monochrome: yeah, funny
09:36:52 <tac-tics> Type-wise, a->a, a is now arbitary
09:37:30 <monochrom> blessed are those who do more work and get it more wrong
09:38:02 <monochrom> for they build systems so complicated there are no obvious errors
09:38:34 <tac-tics> A non obvious error is a
09:38:35 <tac-tics> Oops
09:38:51 <tac-tics> The existence of non obvious errors is a metaerror
09:40:03 <quicksilver> hoare++
09:40:43 <burp> "Cannot decode byte '\xfc': Data.Text.Encoding.decodeUtf8: Invalid UTF-8 stream" ‚Üê does anyone know what "kind" of exception that is? SomeException like?
09:41:04 <ion> If you‚Äôre a fast typer, it may be more convenient to type a nick instead of using completion. By typing it, you‚Äôre sure to get it right in constant time without giving it any extra brain cycles. By using tab completion, you have to check if the completion got the right nick and then perhaps correct the completion, which uses more brain cycles and may cause the time to input the right nick to grow by a large amount. :-)
09:41:21 <ion> I tend just to type nicks.
09:41:59 <burp> never mind, got it
09:42:08 <burp> usual Control.Exception
09:53:27 <scientist_> Hi, does anybody know some good pointers for comparing Haskell and Mathematica? 
09:54:06 <burp> uh, huh
09:54:08 <monochrom> I'm pretty sure we just saw a counterexample to "By typing it, you‚Äôre sure to get it right", so nevermind constant time and without any extra brain cycles.
09:54:09 <quicksilver> ion: also, checking the completion was correct breaks the pipeline.
09:54:47 <nostrand> scientist_: i think it's hard to find a general comparison between those two. But Mathematica is more of a program than a language
09:55:14 <aristid> it is evil that IO can catch some kinds of bottom.
09:55:20 <monochrom> Haskell is a programming language. Mathematica is a computer algebra system. End of comparison.
09:55:25 <scientist_> I know it stems from Lisp, but is has significant functional programming styles
09:56:02 <sproingie> mathematica doesn't stem from lisp.  maxima does.
09:56:54 <scientist_> Well, there's the symbolic expression (Sexpr). Mathematica doesn't call it like that.
09:58:19 <akosch> i've been trying to solve this problem: http://akosch.rewq.org/sprimes.html
09:58:31 <akosch> but I'm not sure how to verify my code
09:58:55 <Jafet> monochrome: no, no, it's your name that's wrong
09:59:01 <sproingie> i suppose mathematica has distant roots in macsyma.  but you don't really write programs in mathematica any more than you do multivariate calculus in haskell
09:59:09 <sproingie> you could do either, you just don't really want to
09:59:13 <Jafet> Who are you to dissent, lonestar?
09:59:20 <monochrom> heh, today's xkcd "how to write good code": http://xkcd.com/844/
10:00:30 <sproingie> for some reason, none made me chuckle as much as the "Serious Putty" strip
10:00:41 <sproingie> too bad the tooltip was extra lame
10:00:50 <monochrom> I agree with Jafet. monochrome's name is wrong. He should rename himself to monochrom.
10:01:30 <scientist_> I found this article, http://zufaellige-reflektion.blogspot.com/2011/01/haskell-eiger-for-mathematica.html , it shows a few differences, but is that all?
10:01:49 <Jafet> All this talk about right and wrong... it's like the world suddenly collapsed into shades of one hue
10:02:09 <monochrom> well, you know monochrome. :)
10:03:52 <Cale> scientist_: I haven't read the article, but Mathematica and Haskell are pretty different as languages.
10:04:25 <Jafet> akosch: compute it again and see if the answers match?
10:04:41 <sproingie> certainly anything mathematica can compute, haskell can, and vice versa, that's turing completeness for you
10:04:48 <roconnor> monochrom: are your sure Haskell isn't a CAS?
10:04:49 <roconnor> > deriv (x^2 + x^3 - 5)
10:04:49 <roconnor> > deriv (\x ->x^2 + x^3 - 5) x
10:04:49 <roconnor> lambdabot: hello?
10:04:50 <roconnor> apparently haskell isn't a CAS.
10:04:51 <roconnor> :(
10:05:03 <sproingie> but mathematica has powerful math libraries haskell doesn't
10:05:20 <sproingie> and haskell has syntax that doesn't make your eyeballs bleed
10:05:27 <aristid> > (\x -> x * x) a
10:05:28 <akosch> Jafet: hm, strange approach :)
10:05:35 <aristid> @botsnack
10:05:42 <scientist_> As I understand, besides lazy evaluation, Monads, and a compiler, what is other hallmarks of Haskell compared to other FP
10:05:47 <aristid> lambdabot is online but dead :(
10:05:48 <Jafet> akosch: well, the general idea is to compute it again with a different method.
10:05:51 <sproingie> (i joke, actually i kind of like mathematica's syntax)
10:05:57 <Cale> hmm
10:06:00 <lambdabot> :)
10:06:00 <lambdabot>   Couldn't match expected type `Data.Number.Dif.Dif a
10:06:01 <lambdabot>                        ...
10:06:01 <lambdabot>   a * a
10:06:01 <lambdabot>   1 * x + x * 1 + ((1 * x + x * 1) * x + x * x * 1)
10:06:02 <akosch> Jafet: I thought so
10:06:07 <Cale> ahaha
10:06:17 <akosch> Jafet: maybe i'll write it in C or something
10:06:45 <Jafet> akosch: for example, factorize the numbers instead of generating them.
10:06:47 <aristid> Cale: which is the latest compiler that lambdabot actually compiles on, btw?
10:06:49 <sproingie> scientist_: haskell is "pure", i.e. it admits no side effects in functions, ever
10:07:03 <sproingie> scientist_: that's not unique to all languages, but it does stand out
10:07:11 <Cale> aristid: The Glorious Glasgow Haskell Compilation System, version 6.12.3
10:07:23 <roconnor> typeclasses + laziness = Haskell?
10:07:24 <Cale> aristid: I haven't tried compiling it on anything later.
10:07:29 <aristid> Cale: ok, why does the hackage package not work then?
10:07:35 <aristid> i have 6.12
10:07:39 <sproingie> imho, purity + laziness = haskell
10:07:42 <Cale> aristid: I'm not using the hackage package.
10:07:48 <Jafet> unsafePerformIO (putStrLn "ORLY (o-o)") `seq` ()
10:08:01 <Cale> (and I don't maintain that, even though someone was "kind" enough to write my name into the .cabal file)
10:08:30 <scientist_> Does Haskell have support for linear algebra numerics, like numpy for python?
10:08:31 <aristid> Cale: yeah, it does list you as the maintainer
10:08:32 <Jafet> @quote Haskell.is
10:08:33 <lambdabot> Berengal says: Haskell is made of sugar and spice and everything nice, plus the mysterious compound X
10:09:45 <nostrand> scientist_: there are libraries for that
10:10:58 <ClaudiusMaximus> @hackage hmatrix
10:10:59 <lambdabot> http://hackage.haskell.org/package/hmatrix
10:11:24 <Cale> aristid: try   darcs get code.haskell.org/lambdabot
10:11:45 <Cale> aristid: It can be somewhat tricky to get it running properly.
10:12:16 <scientist_> thx, I'll look into the library matter!
10:13:57 <aristid> Cale: i just wanted GOA :)
10:14:41 <Jafet> Has anyone used ghci on acid on acid?
10:14:42 <Cale> scientist_: btw, the use of monads as an abstraction isn't quite a language thing (there's a little syntax sugar for them but it's not such a big deal), but more a library thing.
10:15:51 <Cale> scientist_: The language feature which allows concepts like monad, applicative functor, arrow, etc. to be convenient ways to abstract over similarities between libraries is typeclasses (and more specifically constructor classes)
10:16:14 <sproingie> the platform should totally ship with GOA
10:17:52 <djahandarie> Cale, you don't consider IO part of the language but rather a library?
10:19:20 <aristid> sproingie: it can't, because GOA depends on lambdabot :)
10:20:52 <scientist_> I understand that the type system in haskell is quite powerful, but when you compile libraries isn't all this type specification gone then? How do libraries then benefit from all the software abstraction via parametrized types?
10:21:31 <sproingie> scientist_: haskell uses .hi files that retain the type information
10:22:16 <Jafet> djahandarie: such an ugly untyped library
10:22:18 <sproingie> ghc does anyway
10:22:29 <sproingie> haskell itself doesn't say anything about the compilation model
10:23:20 <Jafet> ghc removes nearly all of the type specification in the compiled code.
10:25:34 <Cale> djahandarie: The fact that IO is a monad is not all that crucial.
10:26:47 <copumpkin> has anyone played with this weird stuff? http://hpaste.org/42842/funky_families
10:26:59 <copumpkin> are they ever usable?
10:27:36 <Cale> wow, that's an interesting blend :)
10:27:55 <Cale> I don't think I'd even thought to try that :)
10:28:07 <sproingie> i think those run in MonadEIEIO
10:28:08 <copumpkin> they seem almost impossible to do anything useful with
10:28:10 <aristid> copumpkin: looks like in this case, GADTs would suffice
10:28:30 <aristid> copumpkin: but maybe this way you can build a kind of OPEN GADT?
10:28:42 <copumpkin> I build open GADTs all the time with data families
10:28:46 <aristid> sproingie: EIEIO is comonadic.
10:28:52 <aristid> @quote EIEIO
10:28:52 <lambdabot> quicksilver says: It's replaced by the farm comonad, EIEIO.
10:28:53 <copumpkin> but I mean that the GADT is refining the input
10:29:00 <copumpkin> which is weird
10:29:09 <copumpkin> it's a type function whose output refines its input
10:29:33 <copumpkin> which feels very weird
10:29:44 <copumpkin> and seems almost useless
10:29:50 <copumpkin> but I was wondering if anyone had done any work on them
10:32:23 <copumpkin> it seems like you'd almost have to pair them with a typeclass to do anything useful with them
10:33:53 <Saizan> isn't that the case for data families in general?
10:34:13 <djahandarie> Cale, it wouldn't be if those functions were exposed through something other than the Monad interface
10:34:29 <copumpkin> Saizan: I guess
10:34:46 <Cale> djahandarie: Right -- or some set of equivalents.
10:34:56 <djahandarie> But you can only access them through the Monad instance and I think that actually overblows Monad and is the cause of a lot of misunderstandings that Monads are special
10:35:25 <Cale> djahandarie: You just need some appropriate ways to glue IO actions together, and it so happens that the IO library in Haskell uses the Monad interface.
10:35:42 <roconnor> @src IO (>>=)
10:35:42 <lambdabot> m >>= k     = bindIO m k
10:35:48 <roconnor> @src IO (return)
10:35:48 <lambdabot> Source not found. I feel much better now.
10:35:56 <djahandarie> roconnor, except you don't get those without importing GHC.* stuff
10:36:06 <djahandarie> GHC.IOBase? I think
10:36:07 <roconnor> meh
10:38:17 <copumpkin> why not Ord k => Monad (Map k) ?
10:39:26 <copumpkin> oh, no pure
10:39:39 <djahandarie> Unpointed Monad
10:39:58 <copumpkin> I just want edwardk's magic unpointed applicative, really
10:40:06 <aristid> djahandarie: only join and bind, no return and fmap?
10:40:14 <roconnor> why not Ord k => MOnad (Set k) ?
10:40:17 <copumpkin> having a liftMap2 (a -> b -> c) -> Map k a -> Map k b -> Map k c seems legit
10:40:24 <copumpkin> roconnor: because that has the wrong kind
10:40:26 <aristid> roconnor: same problem?
10:40:33 <roconnor> @kind Set
10:40:34 <lambdabot> Not in scope: type constructor or class `Set'
10:40:39 <roconnor> @kind Data.Set.Set
10:40:40 <lambdabot> * -> *
10:40:40 <copumpkin> no, there is a return for Set
10:40:51 <roconnor> ah
10:40:53 <roconnor> duh
10:40:55 <aristid> but the return has a constraint
10:41:01 <copumpkin> yeah, that's a different issue
10:41:07 <copumpkin> for a Map instance you could express the constraint on the keys
10:41:27 <copumpkin> (Monoid k, Ord k) => Monad (Map k) could work
10:41:33 <copumpkin> but that might not be very interesting
10:41:39 <aristid> copumpkin: lol, i just wanted to propose a Monoid constraint
10:42:14 <roconnor> E -> Maybe a
10:42:32 <copumpkin> I mostly want a relational join on Map
10:42:37 <roconnor> @unmtl ReaderT E Maybe a
10:42:37 <lambdabot> E -> Maybe a
10:42:41 <copumpkin> which you could get easily with liftMap2
10:42:55 <copumpkin> liftMap2 (,) :: Ord k => Map k a -> Map k b -> Map k (a, b)
10:44:00 <poop_toucher> quick question: when you do foldl (+) [1..10^8], does the stack overflow happen because all the thunks get put on the stack or because evaluating those thunks is done in a recursive manner and you get a stack full of stack frames?
10:45:18 <poop_toucher> anyone know?
10:45:22 * roconnor wants to know the answer to that too
10:45:43 <c_wraith> When it's evaluating the thunk, it encounters another one.  It creates a new stack frame to evaluate the next one.  and so on.
10:46:07 <poop_toucher> ah. but the thunks themselves are on the heap?
10:46:25 <c_wraith> evaluating a thunk in the STG-machine abstract is very similar to a function call in a more standard model
10:46:33 <c_wraith> yes, the thunks themselves are on the heap
10:46:58 <poop_toucher> ah, cool. i gotta read up on some papers about the STG machine
10:51:59 <c_wraith> GHC doesn't use a pure STG model anymore.  But it's still a good read for a basic idea how you can efficiently implement a pure lazy functional language.
10:54:58 <xplat> man, deforestation/fold fusion has got to be one of the best things to come out of the FP community
10:55:27 <xplat> when the day comes that haskell is mainstream and i never have to fuse two loops by hand again i will be a happy man
10:55:41 <c_wraith> I still want supercompilation.
10:55:58 <CuriousJohny> Hi guys. I have a function which takes Int and returns monad... now, is there a way to rund that function in loop somehow? I know that there are no explicit loops provided by the haskell itself, and I usually can do with folding, but I do not know how in this monad case
10:56:09 <copumpkin> Int -> Monad?
10:56:16 <c_wraith> make it -Oreallyslow.  I don't care.  I just want to be able to have the compiler do that kind of optimization for me.
10:56:45 <c_wraith> CuriousJohny: what kind of loop?  A fold, a map, something else?
10:56:49 <CuriousJohny> :: Int -> Net () (where Net is the monad from Roll your own IRC bot tutorial :))
10:56:50 <copumpkin> I want a -Oprogressiveoptimization (where ctrl-c will make it output my binary at the current optimization level, and otherwise it'll keep running as long as it wants)
10:57:32 <c_wraith> Ah.  with that type, you probably want mapM or forM
10:57:39 <c_wraith> :t mapM
10:57:40 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
10:57:49 <c_wraith> or, well
10:57:52 <c_wraith> :t mapM_
10:57:53 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
10:58:19 <CuriousJohny> ah, taht looks cryptic, I'm not really into that monad stuff yet I guess :D
10:58:32 <xplat> CuriousJohny: there are various foldish functions in Control.Monad that you might want to look at
10:58:39 <c_wraith> well, I assume you want to run the function on a bunch of values in a list?
10:58:55 <cdsmithus> CuriousJohny: That just says you give it an action to do to each thing in the list, and it does them
10:59:21 <CuriousJohny> I see
11:00:06 <xplat> they usually have names similar to the non-monadic functions but with M or M_ at the end.  the M_ ones are designed for when you want to throw away the result and only care about the 'effect'
11:00:07 <c_wraith> replace a with Int, m with Net, and b with ().  So mapM_ :: (Int -> Net ()) -> [Int] -> Net ()
11:00:07 <cdsmithus> The difference is mapM gives you back a list of the results of the actions.  mapM_ just does the actions but throws away the results
11:00:12 <roconnor> Is Data.Map traversable?
11:00:12 <CuriousJohny> Hmm, would it be also posible, to leave the type Int -> Net () and put the loop inside the function? 
11:00:21 <copumpkin> roconnor: yes
11:00:38 * roconnor tries to find the instance
11:00:50 <copumpkin> roconnor: http://snapplr.com/74bg
11:00:51 <c_wraith> I think it's listed in Data.Map
11:01:02 <CuriousJohny> oh, so the resulting type of the mapM is also Net () nice
11:01:05 <monochrom> I am not sure what is meant by running Int->Net() inside a loop
11:01:22 <c_wraith> CuriousJohny: well, that's the result of mapM_
11:01:25 <cdsmithus> CuriousJohny: The result of mapM_ is Net ()
11:01:27 <c_wraith> The underbar is important :)
11:02:26 <cdsmithus> CuriousJohny: This is probably heresy, but if you're thinking of for loops, forM and forM_ from the Control.Monad module might be more natural for you.  They are the exact same thing, except they take their arguments in the other order.
11:02:33 <c_wraith> The result of mapM would be Net [()] ...  And [()] is nearly useless.  The only extra information you can get out of it over () is the length of the list.
11:02:50 <CuriousJohny> ok, thanks guys, I will read the corresponding docs :)
11:02:57 <xplat> you know, 'the bottomless pit' would be a good name for a blog dedicated to total functional programming
11:02:59 * roconnor tries to figure out how to define traverse for Ocaml's Map.
11:04:10 <CuriousJohny> nice to see that replacing map with mapM_ solved the problem :)
11:04:22 <CuriousJohny> you are the gem folks :)
11:05:10 <roconnor> @type mapM
11:05:10 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
11:05:14 <roconnor> @type forM
11:05:15 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
11:05:49 <roconnor> mapM produces Kliesli arrows.
11:05:59 <roconnor> although I guess techicallys so does forM :D
11:06:33 <xplat> ... it does?
11:06:56 <xplat> ... for which monad?
11:13:24 * hackagebot threadPool 0.3.1 - Runs other programs in the manner of a thread pool  http://hackage.haskell.org/package/threadPool-0.3.1 (BrianJaress)
11:19:09 * copumpkin just wrote a Data.Map-alike where the value types can depend on the keys
11:19:35 <monochrom> dependent map?! scary
11:19:40 <copumpkin> yeah, in haskell!
11:19:55 <monochrom> how could it be possible!
11:20:23 <monochrom> actually I just mean what does the API look like
11:22:59 <lispy> +1 to NoDataTypeContexts
11:23:11 <elliott> Can one set the "default" file buffering?
11:23:16 <elliott> i.e. like hSetBuffering, but applied by default
11:24:25 <copumpkin> monochrom: http://hpaste.org/42843/indexed_maps
11:24:43 <copumpkin> it's unsafe behind the scenes, but has a safe interface
11:24:52 <elliott> hmm, and why does hSetBuffering also seem to disable my _terminal's_ buffering?
11:25:30 <elliott> copumpkin: one more LANGUAGE pragma than necessary :D
11:28:13 <xplat> dependent map sounds very similar to an extensible record
11:28:28 <elliott> copumpkin: you can use that to do OO can't you? :D
11:28:36 <elliott> copumpkin: by using the dependency to get "self"?
11:28:44 <elliott> is there a way to disable a handle's buffering without it, e.g., disabling my terminal's line buffering?
11:29:07 <monochrom> no
11:29:35 <elliott> monochrom: er. really?
11:29:40 <monochrom> really
11:29:47 <elliott> monochrom: I just want reads to do the equivalent of read(fd, &c, 1) in C.
11:29:53 <elliott> That is, reads of a single character.
11:30:05 <elliott> (And reads of a larger size to behave in the same way, i.e. read(fd, buf, N).)
11:31:11 <monochrom> getChar
11:31:36 <elliott> monochrom: Sure. but for hGetContents?
11:31:43 <elliott> Won't a normal hGetContents on e.g. /dev/random be line-buffered?
11:31:44 <monochrom> hGetChar
11:31:56 <elliott> I'd rather not use *getChar directly.
11:32:03 <Blkt> good evening everyone
11:32:23 <mambo> hi,me  trying to install snap via 'cabal install snap' and getting following error on building prerquisite: src/Hint/InterpreterT.hs:164:29: Not in scope: `finally'
11:32:28 <copumpkin> elliott: two more than necessary actually
11:32:55 <monochrom> before you impeach haskell or ghc, let's recall unix & c behaviour, to see that ghc doesn't really behave any differently.
11:33:10 <mambo> maybe somebody have idea about where to look in this situation on ubuntu
11:33:38 <c_wraith> mambo: that's odd.  That's a compile error inside the Hint library.
11:33:38 <elliott> monochrom: No need to impeach -- I just tested it and hGetContents without any hSetBuffering actually does the Right Thing here. :-)
11:33:52 <c_wraith> mambo: what version of hint is it trying to install?
11:33:55 <monochrom> If you open /dev/random, default buffering is block-buffered, not line-buffered. This is unix & c behaviour. You will find that ghc does the same.
11:34:09 <elliott> monochrom: Default buffering where?
11:34:14 <mambo> Preprocessing library hint-0.3.3.1...
11:34:18 <elliott> monochrom: It is not Unix behavour; C stdio behaviour, certainly, but that is not Unix.
11:34:30 <elliott> That is, in fact, pure C; it is available on non-Unix, and it does not match default Unix behaviour when on Unix.
11:34:34 <monochrom> default buffering policy is hardcoded into OS and C libs.
11:34:38 <elliott> Unix IO -- read and write -- is unbuffered.
11:34:45 <elliott> That is, read(2) and write(2).
11:34:53 <c_wraith> mambo: that's the right version.  Not sure what's up.  It builds just fine everywhere I've tried
11:34:53 <elliott> However the terminals themselves are still of course line-buffered.
11:35:43 <mambo> c_wraith: yep, i'm also out of ideas :(
11:36:01 <xplat> elliott: actually on most unices file io is block-buffered through the block cache, and your terminal will be line-buffered, at least if getty set it up that way
11:36:23 <elliott> xplat: Well, yes, file IO is certainly block-buffered by default.
11:36:29 <monochrom> fine, change "open" to "fopen".
11:36:29 <elliott> xplat: But the actual "API" isn't.
11:36:46 <elliott> xplat: As in, read(fd, &c, 1) *will* put something in c as soon as fd has something to give.
11:36:52 <elliott> It's just that most fds will hold back.
11:36:55 <elliott> monochrom: I don't like stdio :)
11:37:58 <xplat> you just don't see the artifacts of block-buffering at the os level the way you do at the c level normally because all handles and files share the buffer for the same block on the same block device.  although if you have the same disk visible as two different block devices all bets are off!
11:38:10 <mambo> today it looks like my computer risen against me
11:39:25 <xplat> elliott: you could say the same about fread.  it will put something in c as soon as the FILE * has something to give, but the FILE * will probably hold back
11:39:36 <elliott> xplat: Incorrect.
11:39:39 <elliott> xplat: stdio has its own buffering.
11:39:47 <elliott> dunno if that's _mandated_ but it certainly does in all Unixes I know of
11:39:58 <xplat> elliot: that's why i said the FILE *, not the fd
11:41:03 <monochrom> I'm interested in how much read(0, &c, 1) blocks.
11:41:06 <xplat> stdio doesn't deal in fds, any more than the Unix API deals in struct inode or whatever
11:41:40 <xplat> it just has a small escape hatch in the form of fileno and fdopen
11:43:36 <monochrom> if 0 is to a tty, read(0, &c, 1) blocks until newline. you can argue over who did it.
11:44:06 <monochrom> similarly for stdin and getc
11:44:25 <monochrom> similarly for ghc's getChar
11:44:40 <elliott> :-)
11:44:53 <elliott> Is there any point using openBinaryFile when exclusively targeting Unix?
11:46:01 <xplat> well, you might run across some weird almost-unix that you could otherwise run on, and it is a nice bit of documentation ...
11:46:46 <monochrom> you never really know that you exclusively target unix.
11:46:59 <elliott> I really, really do actually.
11:47:03 <elliott> No‚Äî *really* :)
11:47:31 <elliott> Just asking if it would conceivably do anything on any Unix implementation of Haskell ever.
11:47:37 <xplat> as in, this program will be run on unix for a batch job this week, and then you will melt the disk it ran off with thermit
11:47:57 <xplat> you've already set the timer!
11:48:02 <elliott> xplat: Pretty much, yep.
11:48:31 <monochrom> Suppose X and Y do exactly the same thing in context C, for the same cost and price. But X only works for C, Y works for C and quite a bit outside C. Is there a point using X?
11:48:39 <xplat> i wonder if it will do something relative to charset encodings
11:49:13 <xplat> monochrom: the price isn't actually quite zero here
11:50:02 <xplat> (price difference, rather)
11:50:38 <monochrom> how do openBinaryFile and openFile have different prices?
11:51:15 <monochrom> more precisely, how do openBinaryFile and openFile have different prices on Unix?
11:52:14 <monochrom> oh I see, UTF-8 vs latin1
11:52:35 <monochrom> well that is not different price. that is do different things.
11:53:41 * hackagebot functor-apply 0.5.0 - Strong lax semimonoidal endofunctors (Applicative sans pure)  http://hackage.haskell.org/package/functor-apply-0.5.0 (EdwardKmett)
11:54:10 <monochrom> well then openFile and openBinaryFile do different things even on Unix, so the original question "what is the point of openBinaryFile on unix" is ignorant and moot.
11:54:31 <roconnor> what's the difference between a semimonoid and a semigroup?
11:54:41 * hackagebot comonad 0.5.0 - Haskell 98 comonads  http://hackage.haskell.org/package/comonad-0.5.0 (EdwardKmett)
11:55:15 <xplat> i guess in a context where both were used a semigroup would have cancellation and a semimonoid would not?
11:55:41 * hackagebot comonad-transformers 0.5.0 - Haskell 98 comonad transformers  http://hackage.haskell.org/package/comonad-transformers-0.5.0 (EdwardKmett)
11:55:51 <roconnor> xplat: unfortunately cancelation doesn't make sense without a unit
11:56:39 <monochrom> anyway unix & C read(fd, &c, 1) behaves pretty much like hGetChar or even hGetBuf if you're that depraved.
11:56:40 <xplat> however it's a little unusual to say 'semimonoid' so i would suggest finding a local source of definitions if there is one
11:56:41 * hackagebot comonads-fd 0.5.0 - Comonad transformers using functional dependencies.  http://hackage.haskell.org/package/comonads-fd-0.5.0 (EdwardKmett)
11:56:55 <xplat> monochrom: actually, cancellation does make sense without a unit
11:57:09 <monochrom> delete "monochrom"
11:57:14 <xplat> er, roconnor:
11:57:22 <roconnor> oh
11:57:25 <roconnor> intresting
11:57:43 <roconnor> then the comon definition of semigroup is stupid
11:57:58 <copumpkin> it really is
11:58:04 <copumpkin> or the name of it, rather
11:58:28 <monochrom> there is also System.Posix.IO.fdRead and fdReadBuf if you are really corrupted
11:59:19 <xplat> well, 'semimonoid' == 'monoid without a unit' is a pretty strange construction
11:59:34 <j-invariant> semigroup?
11:59:40 <xplat> i usually think of a monoid as sort of a 3/4-group
11:59:46 <copumpkin> why? something can be associative without a unit
11:59:58 <j-invariant> never heard of a semimonoid
12:00:10 <copumpkin> j-invariant: I'm saying the name semigroup is dumb, and it should be semimonoid
12:00:17 <xplat> copumpkin: it's the fact that 'monoid' refers to the unit in the very word
12:00:23 * edwardk waves hello.
12:00:23 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
12:00:27 <j-invariant> hi
12:00:29 <roconnor> j-invariant: [14:53] * hackagebot functor-apply 0.5.0 - Strong lax semimonoidal endofunctors (Applicative sans pure)  http://hackage.haskell.org/package/functor-apply-0.5.0 (EdwardKmett)
12:00:54 <j-invariant> I finished reading the Kan extension posts
12:01:01 <edwardk> j-invariant: yay! =)
12:01:08 <xplat> if i needed a more compact term than 'semigroup with cancellation' badly i would call it a 'cancelloid'
12:01:25 <edwardk> semimonoidal isn't my name ;)
12:01:25 <monochrom> pumpkinoid
12:01:29 <copumpkin> assoid is something with an associative binop and nothing else
12:01:43 <edwardk> when you assumoid you make an...
12:01:46 <monochrom> assoid gives many wrong ideas :)
12:01:54 <copumpkin> assteroid
12:02:13 * monochrom is a smart-assoid
12:02:15 <aristid> monochrome: yeah, assoid sounds like it's not the nicest -oid
12:02:15 <j-invariant> trying to follow the co- parts is kind of like being in a mirror world where  every move you make is backwards
12:02:32 <roconnor> the whole oid ending of monoid is bad, because we can't call a category a monoidoid.
12:02:38 <j-invariant> I don't know if I hav efully recovered :P
12:02:44 <edwardk> j-invariant: thats why i wanted to get a nice library out there so folks could get used to playing in the mirror =)
12:02:50 <aristid> roconnor: why not?
12:03:02 <roconnor> aristid: because it sounds retarded :)
12:03:16 <aristid> it's a roconnoroid
12:03:18 <monochrom> androidoid
12:03:31 <xplat> we could always call a monoid a category2oid
12:03:39 <xplat> er, that was supposed to be red
12:03:45 <monochrom> androidoid means a chinese no-name clone of android :)
12:03:51 <aristid> xplat: it's blue, and i tried clicking on it
12:03:51 <edwardk> anywyas as you can see i factored out FunctorApply from comonad, it was getting crowded in there, and then copumpkin came to me with a need for a FunctorApply for Map
12:03:59 <monochrom> hahahaha
12:04:10 <Cale> xplat: Except that usually -oid goes in the direction of being more category-like.
12:04:28 <Cale> xplat: Particularly in the case of groupoid.
12:04:38 <xplat> Cale: yeah, i wanted it red to indicate that you owe an 'oid'
12:04:41 * edwardk tries to come up with a use for a categoroid ;)
12:04:46 <Cale> heh
12:04:48 <copumpkin> let's have a vectorspacoid
12:04:56 <monochrom> 02hahaha
12:06:00 <monochrom> I have a friend with irc nick smiloid
12:06:02 <edwardk> hrmm, in light of the functor => monad thing, what are the odds of convincing folks of the merit of Semigroup => Monoid ? its not a big change, and it lets a lot more stuff including crap in the prelude be implemented correctly
12:06:20 <xplat> maybe monoid = categorydio?  category(oid)^-1?  categoryarcoid?
12:06:26 <roconnor> edwardk: like what?
12:06:28 <edwardk> (e.g. the Maybe monoid instance could be fixed
12:06:31 <aristid> edwardk: what operations does Semigroup have?
12:06:36 <copumpkin> roconnor: Min and Max being fold1s
12:06:53 <edwardk> monoid for maybe lifts a semigroup, but since there is no semigroup class, it lifts another monoid that is supposed to just not bother implementing mempty
12:06:55 <copumpkin> Data.Set intersection
12:07:03 <edwardk> aristid: mappend
12:07:12 <xplat> hm, monad and comonad are common all the way up to FunctorApply?  neat.
12:07:21 <edwardk> xplat: not quite
12:07:23 <aristid> edwardk: and that would fix the Maybe instance how?
12:07:38 <roconnor> edwardk: there is a monoid for Maybe in the prelude?
12:07:39 <edwardk> xplat: Functor => FunctorApply => Applicative => Monad   but Comonad => ComonadApply
12:07:47 <edwardk> and FunctorApply => ComonadApply
12:07:51 <copumpkin> roconnor: Monoid m => Monoid (Maybe m) in Data.Monoid iirc
12:07:52 <edwardk> roconnor: yes
12:08:17 <edwardk> aristid: because it could weaken it to only what it requires. 
12:08:25 <roconnor> edwardk: there isn't even a Monoid calls in Haskell 2010 AFAIK
12:08:44 <aristid> edwardk: huh?
12:08:45 <xplat> edwardk: oh.  is there anything like a FunctorCoApply and MonadCoApply then?
12:08:46 <copumpkin> I've wanted Min and Max and an Intersect instance on Data.Set for a while
12:09:05 <edwardk> sorry then, if not in the prelude, then its in base, which is good because it doesn't require a language change just a library one ;)
12:09:26 <edwardk> xplay: no, coapplication is boring for technical reasons
12:09:46 <roconnor> wow, that instance Monoid a => Monoid (Maybe a) is a really stupid instance
12:09:53 <edwardk> roconnor: exactly =)
12:09:54 <roconnor> how about we just fix that by removing it
12:10:10 <edwardk> plus i now have a bunch of FunctorApply instances that require Monoids but only REALLY need a Semigroup
12:10:20 <copumpkin> or just have instance Semigroup a => Monoid (Maybe a)
12:10:24 <copumpkin> :) :) :)
12:10:26 <edwardk> (similarly, traverse only needs FunctorApply, not Applicative)
12:10:31 <edwardk> yeah
12:10:52 <edwardk> (which is sufficient to allow me to traverse with some comonads)
12:11:00 <roconnor> I understand what you guys are asking, but I really don't think Haskell class mechinism scales well enough to handle a refined heirarchy.
12:11:10 <copumpkin> roconnor: then everyone should use SHE!
12:11:18 <copumpkin> *her
12:11:20 <edwardk> roconnor: sure. but we put enough pressure on it, and folks will improve it =P
12:11:22 <aristid> edwardk: well, if it was up to me, i'd do instance Monoid (Maybe a), coinciding with the MonadPlus instance for Maybe.
12:11:41 <edwardk> aristid: yeah, the problem there is its a semantics change which won't break compiling code
12:11:59 <edwardk> aristid: so at this point your options are removing it or refining it
12:12:06 <aristid> edwardk: yes :/
12:12:18 <roconnor> I'm not sure SHE scales well enough either.  (Not that I have much experience) but Isaac Dupree's example makes it appear that SHE doesn't scale.
12:12:27 <opqdonut_> link?
12:12:30 <aristid> roconnor: IT'S NOT WEB SCALE
12:12:33 <roconnor> http://www.haskell.org/pipermail/haskell-prime/2011-January/003324.html
12:13:01 <monochrom> "that's what SHE said"
12:13:04 <xplat> is there a better google term for SHE than SHE?
12:13:13 <copumpkin> strathclyde haskell enhancement
12:13:23 <edwardk> all natural strathclyde haskell enhancement
12:13:40 <roconnor> edwardk: the reason that Monoid is getting a make over is that all it's superclasses are well used
12:13:51 <xplat> copumpkin: thanks
12:13:54 <edwardk> yes
12:13:55 <roconnor> edwardk: I think the first step of your quest is to implement a Semigroup class
12:14:00 <roconnor> edwardk: and then make it well used
12:14:06 <roconnor> and then make it a super class.
12:14:18 <edwardk> sadly i can't because i can't inject it a a superclass anywhere
12:14:34 <copumpkin> this is why haskell sucks 
12:14:36 <edwardk> all of the cases where i'd be able to refine to it are screwed
12:14:36 <j-invariant> what I don't get ishow can someoen think "semigroup.. an associative binary operation" and make a THEORY out of that
12:14:46 <j-invariant> I can't think of a singple nontrivial thing to say about semigroup
12:15:02 <copumpkin> j-invariant: I can fold it over non-empty ordered structures
12:15:15 <roconnor> j-invariant: it is the algebra of the non-empty list monad.
12:15:28 <xplat> j-invariant: you could go all combinatorist and count the finite ones
12:15:31 <roconnor> which is why copumpkin can fold over it
12:15:43 <copumpkin> roconnor: nuh uh, I can fold over it cause I'm just cool like that
12:15:50 <edwardk> instance Semigroup m => FunctorApply ((,)m) where (a,b) <.> (c,d) = (a <> c, b d)
12:16:17 <edwardk> but that instance only works if semigroup is really a superclass of monoid
12:16:37 <roconnor> that being said, non-empty lists are kinda a crappy structure
12:16:39 <edwardk> so the chicken is stillborn ;)
12:16:44 <copumpkin> roconnor: why!?
12:16:57 <roconnor> copumpkin: they aren't inductive.
12:17:28 <edwardk> sure they are, your base case is just off by one from where you want it to be
12:17:33 <copumpkin> data Moo a = End a | Cons a (Moo a)
12:17:42 <roconnor> oh right
12:17:45 <roconnor> copumpkin: good one
12:17:57 <copumpkin> I'm good with names
12:18:06 <Saizan> the induction principle sucks though
12:18:07 <roconnor> though data Moo b a = End b | Const a (Moo b a) is better
12:18:08 <luite> hmm, I've been running into this problem where I have a pure function that's too expensive to recompute every time. say I have a functions prime :: Integer -> Integer, that computes the i-th prime. is there some (somewhat) accepted general way to avoid having to recompute the numbers every time?
12:18:37 <copumpkin> luite: memocombinators!
12:18:40 <edwardk> Saizan: sure, but then you can make comonads out of them, and rainbows and puppies emerge
12:19:02 <edwardk> the first time that happened, i was quite shocked. but then i learned to sit back and enjoy it
12:19:20 <Saizan> can you sell the puppies?
12:19:22 <roconnor> edwardk: well if we were talking about coalgebras, then the fact that they are comonads would be relevent :D
12:19:27 <arcatan> suddenly i realize that the pattern i invited a while back is enumerator
12:20:06 <groovebox> I ran pointfree on some function and got  liftM2 ap ((++) .) (=<<)  but this doesn't even compile ... anyway, I wonder if an advanced Haskeller can read this
12:20:33 * arcatan goes on to write You Could Have Invented Zygohistomorphic Prepromorphism
12:20:49 <Saizan> groovebox: it probably needs Control.Monad.Instances
12:20:55 <roconnor> copumpkin: what is the definition of concat for your Moo?
12:20:56 <luite> copumpkin: nah that has some rather severe limitations. you cannot just "get some prime" anywhere outside the memoized function. and it isn't possible to tune the memory usage in any way, for example by specifying how long to keep the sieve around
12:21:05 <Saizan> ?type liftM2 ap ((++) .) (=<<)
12:21:05 <lambdabot>     Occurs check: cannot construct the infinite type: a = m a
12:21:06 <lambdabot>       Expected type: a -> m b
12:21:06 <lambdabot>       Inferred type: m a -> m b
12:21:23 <Saizan> ah, no, it's just wrong :)
12:21:40 <groovebox> ?type \f a -> f a ++ concatMap f a
12:21:41 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
12:21:41 <lambdabot>       Expected type: [a]
12:21:41 <lambdabot>       Inferred type: a
12:21:53 <groovebox> oh, now the source doesn't compile as well
12:22:38 <copumpkin> roconnor: concat (End a) (End b) = Cons a (End b); concat (Cons a b) c = Cons a (concat b c); concat (End a) (Cons b c) = Cons a (Cons b c)
12:23:15 <groovebox> so pointfree doesn't recognize every error in the input?
12:23:25 <xplat> copumpkin: you can combine the first and last pattern, can't you?
12:23:34 <roconnor> concat (End a) x = Cons a x; concat (Cons a b) c = Cons a (concat b c)
12:23:37 <copumpkin> xplat: yeah
12:23:57 <copumpkin> which makes it just a nice fold over the first parameter
12:24:06 <copumpkin> where the fold isn't list's fold
12:24:07 <copumpkin> but is uglier
12:24:09 <edwardk> roconnor: so what monad coalgebra stuff for state makes sense? =)
12:24:21 <edwardk> er algebra
12:24:30 <roconnor> I don't know
12:24:35 <copumpkin> foldMoo :: (a -> b -> b) -> (a -> b) -> Moo a -> b
12:24:36 <roconnor> what are the algebras of the state monad?
12:24:51 <roconnor> State s a -> a
12:24:57 <copumpkin> concat a b = foldMoo Cons (flip Cons b)
12:25:07 <luite> copumpkin: for example when experimenting in ghci, a "pure" (interface, but with impure implementation) primes function is much more practical than a "memocombinated" one. and I also want to reify prime numbers by their index, which would probably also be tricky if you had to rely on memocombinators
12:25:10 <roconnor> copumpkin: it is nicer than I was guessing
12:25:48 <xplat> s -> (s,a) -> a?  looks like a shorter short exact sequence ...
12:25:58 <roconnor> copumpkin: I'm sold
12:26:12 <copumpkin> roconnor: it's just Cofree Maybe, and as edwardk said, thence come the puppies and unicorns
12:26:16 <copumpkin> BONUS would be proud
12:26:21 <edwardk> xplat: (s -> (s, a)) -> a
12:26:27 <roconnor> copumpkin: Cofree things are monads?
12:26:28 <edwardk> its very Cont'ish
12:26:40 <copumpkin> roconnor: nope?
12:26:44 <edwardk> except it could re-run the computation multiple times
12:26:45 <copumpkin> well, some of them are
12:26:52 <roconnor> copumpkin: sure, like this one
12:27:06 <xplat> edwardk: oh, silly me
12:27:16 <copumpkin> I guess this is a monad too
12:27:19 <copumpkin> the Moonad
12:27:31 <Saizan> groovebox: it'll only catch syntax errors, not type ones
12:27:42 <j-invariant> Cofree?
12:27:43 <roconnor> copumpkin: I'm intrested in Moo being a monad because semigroups are the algerbras of this monad.
12:27:53 <copumpkin> roconnor: ah okay, yeah
12:28:02 <copumpkin> I'd forgotten how we'd arrived here
12:28:05 <edwardk> there is a nu x. (a * f x) ‚Äî monad as long as there is a functorplus (functorapply?) for f
12:28:12 <roconnor> so if non-empty lists are reasonable structures, then I guess semigroups are too.
12:28:27 <edwardk> neil ghani refers to it using some horrible name iirc
12:28:35 <edwardk> as does fokkinga
12:28:51 <copumpkin> roconnor: welcome to The Church of the Semigroup. Your ring is on its way
12:29:20 <xplat> so some of the algebras could be: \f -> fst.([some church numeral] f) [some initial state]
12:29:26 <roconnor> edwardk: before you add a semigroup class, you need to make a copumpkin's non-empty list data type 
12:29:40 <edwardk> its Stream in comonad-transformers ;)
12:29:45 <xplat> and also \f -> fst.(fix f)
12:29:46 <roconnor> copumpkin: putting the focus at the *end* of the list was a neat trick.
12:29:52 <edwardk> its just not traversable, etc. because the 'transformers' ones aren't
12:30:10 <edwardk> which is an argument that is starting to wear thin with me. i think i'm going to give in and add all the Data/Traversable/etc. crap too
12:30:52 <edwardk> (mostly because i want to be able to remove the Comonad class from 'ad' and make it use my shiny new one
12:31:08 <edwardk> and to make the Stream returned by grads into the one from comonad-transformers
12:31:24 <edwardk> that way the ad package isn't in the business of defining comonads
12:31:38 <edwardk> its just dealing with streams, and dumbing them down into tensors as needed
12:31:45 <copumpkin> with any luck base will be in the business of defining comonads
12:31:49 <edwardk> =)
12:32:28 <roconnor> edwardk: I'm disappointed your definition of Stream isn't Stream a = a :> Stream a
12:32:35 <edwardk> i may need to factor Control.Comonad out a little further, to make Control.Comonad.Apply part of functor-apply
12:32:36 <edwardk> me too
12:32:42 <edwardk> though i prefer
12:32:48 <edwardk> Stream f a = a :> f (Stream f a)
12:33:10 <roconnor> maybe I could get used to that
12:33:14 <edwardk> the transformer was because it was in the transformers package
12:33:15 <xplat> maybe your stream should be called Basin
12:33:43 <edwardk> but its scary enough that i may just rename it to cofree and make the 'obvious' (if less general) Stream to lure people in
12:33:45 <xplat> it's locally a stream but may branch or terminate
12:33:52 <edwardk> the problem is type operators if the package is trying to be haskell 98
12:34:04 <roconnor> edwardk: can we define (|>) :: a -> Stream Identity a -> Stream Identity a ?
12:34:14 <edwardk> (those _really_ need to become part of the language)
12:34:21 <edwardk> that i could be talked into
12:34:40 <roconnor> Does alternative use that symbol anywhere?
12:34:42 <edwardk> though i'm thinking about adding a Seq data type
12:34:47 <roconnor> does anyone use that symbol anywhere?
12:34:50 <xplat> type operators aren't part of haskell98?  i plum forgot ...
12:34:52 * roconnor hayoo
12:34:54 <edwardk> in the spirit of the original category-extras
12:34:58 <edwardk> as a function from Nat -> a
12:35:20 <roconnor> nothing in Hayoo
12:35:35 <roconnor> the closest in |>> in grapefruit
12:35:39 <roconnor> *is
12:35:49 <roconnor> Graphics.UI.Grapefruit.Comp.	|>>	:: Circuit era i tmp -> uiComp item uiBackend era tmp o -> uiComp item uiBackend era i o
12:35:49 <edwardk> <| and |> are in Data.Sequence iirc
12:36:04 <edwardk> and i think i use them in monoids
12:36:13 <roconnor> hayoo is stupid
12:36:25 <roconnor> okay
12:36:39 <roconnor> edwardk: how about define (<|) :: a -> Stream Identity a -> Stream Identity a ?
12:36:51 <roconnor> since that has about the same meaning as it does in Data.Sequence
12:37:19 <roconnor> I prefer that direction too
12:37:27 <xplat> having the same meaning doesn't stop it from interfering unfortunately :(
12:37:50 <edwardk> sweet. type operators are only required if i want infix types
12:37:54 <edwardk> thanks copumpkin =)
12:38:00 * copumpkin grins
12:38:00 <edwardk> so we can make the stream that way
12:38:30 <edwardk> what i usually do is data Stream f a = a :< f (Stream f a) ‚Äî for the visual fan out
12:38:56 <spvensko_> hi, hopefully this isn't a stupid question, but i've discussed Haskell in here previously and was told about its speed over languages like Python, is it also true, however, that the syntax is (potentially) easier to read?
12:39:01 <edwardk> so we could make some sort of infinite  stream with Foo a = a :> Foo a ‚Äî without conflict
12:39:19 <edwardk> but Stream and StreamT are taken. ideas?
12:40:01 <edwardk> i was going to add History to have the dataflow types somewhere
12:40:05 <edwardk> its in my examples folder
12:40:27 <edwardk> data History a = History a :> a | First a
12:40:31 <edwardk> is what i currently use
12:41:07 <edwardk> and is a copy from essence of data flow programming of uustalu's code
12:41:43 <sproingie> spvensko_: readability of syntax is a matter of taste.  haskell code tends to be a whole lot more terse, which some find more readable
12:41:46 <xplat> spvensko_: for almost any language other than python i would say yes ... python is a tricky case, because not only does it have nice syntax, it has nice syntax in a similar way as haskell.  haskell's syntax is more regular, but also more complex, than python's, so it's somewhat a wash.
12:42:09 <spvensko_> ty sproingie and xplat 
12:42:17 <edwardk> roconnor: so i guess the trick would be to define a few forms of causal streams, one of which looks like what you want ;)
12:42:44 <spvensko_> i've heard the term "elegant" used to describe haskell code, plus i enjoy the idea of more terse code, even if it is harder to digest
12:42:47 <sproingie> i think it's hard to find syntax more readable than python.  i'd say haskell's is more expressive, which is something different
12:43:23 <edwardk> roconnor: if i want to be consistent with EODFP, that stream sounds like an anticausal stream of some sort. checking their types
12:45:31 <xplat> edwardk: you could also imitate bytestreams and have Control.Comonad.Stream.{Single,Branching}.{Causal,Anticausal}.Stream :)
12:45:52 <sshc> How should I check for errors when deserializing a value using the `binary' library?
12:46:04 <xplat> (actually that would probably be better under Data.Stream, insofar as it could be better anywhere)
12:53:37 <tonkman> Is there any comprehensive tutorial or a book about hopengl
12:55:26 <siloxid> tonkman: there's the source code
12:55:32 <alej> they did the red book in opengl
12:55:36 <alej> pretty helpful
12:58:05 <sshc> "NOTE: the impredicative-polymorphism feature is deprecated in GHC 6.12, and will be removed or replaced in GHC 6.14."
12:58:24 <sshc> What should I use instead of ImpredicativePolymorphism?
12:58:37 <sshc> ImpredativeTypes.
13:00:01 <Cale> sshc: Were you using it already?
13:00:58 <edwardk> xplat: ack
13:01:03 <edwardk> not terrible
13:01:58 <sshc> Cale: No, I'm writing new code
13:02:22 <tac-tics> Can someone remind me how to encode an existential type exists a. B in systemF 
13:02:57 <kamaji> Is it possible to create new types while a program is running?
13:03:01 <sshc> Cale: I want to define a list of functions that return a value of a polymorphic type
13:03:01 <tac-tics> It's like (forall a. a -> B) -> B or something....
13:03:17 <kamaji> i'm just thinking it would be cool to open an SQL database, and create tuples representing rows in tables
13:04:28 <tac-tics> Kamaji: in haskell or in theory?
13:04:31 <kamaji> in haskell
13:04:59 <edwardk> right now i'm thinking Stream f a becomes the simple a :< f (Stream f a)  ‚Äî and History a becomes Now a | a :> History a    while Segment becomes Segment t a = Segment (t -> a) t ‚Äî with semantics roughly corresponding to those of the segment comonad from conal's post (sans mempty)
13:05:03 <tac-tics> That, I dojnt know
13:05:19 <copumpkin> kamaji: not really, although they can be existentially quantified at some point
13:05:23 <copumpkin> and you can ensure internal consistency
13:05:33 <sshc> [DCale: A close example is "[forall a. (Read a) => String -> Either String a]", which is defined by "[readFooly, readBarly]"; the significant part is that each element is a top-level function
13:05:41 <kamaji> copumpkin: What does "existentially quantified" mean?
13:05:42 <sshc> Cale: A close example is "[forall a. (Read a) => String -> Either String a]", which is defined by "[readFooly, readBarly]"; the significant part is that each element is a top-level function
13:06:08 <Cale> sshc: You could probably just invent a wrapper datatype for that purpose.
13:06:33 <copumpkin> kamaji: the actual type is unknown, but it has an identity that you can make sure is consistent across calls
13:06:36 <edwardk> then Segment f t1 <.> Segment g t2 = Segment (\t -> (f t) (g t)) (min t1 t2)  ‚Äî can be comonadzippable, and defines operations that intersect and combine segments, while the monoid can append segments
13:06:43 <edwardk> er s/monoid/semigroup
13:07:19 <edwardk> and comonadic frp is reborn ;)
13:07:55 <kamaji> copumpkin: I'm kinda lost, I'm going to finish this tutorial... thanks though :P
13:09:12 <tromp_> :t any
13:09:12 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
13:09:21 <sshc> Cale: A wrapper for an individual function?
13:10:17 <sshc> Cale: Can you give an example?
13:12:34 <Cale> sshc: data Readerer = R (forall a. (Read a) => String -> Either String a)
13:12:56 <xplat> kamaji: basically the idea is, you can't create new types at runtime, but you can create a program where an infinite number of types are there from compile time so you always have all the types you need
13:13:52 <xplat> kamaji: there are several 'extensible record' packages on hackage that illustrate the technique
13:14:33 <sshc> Thanks
13:14:45 <kamaji> xplat: ah, ok. Cheers
13:16:44 <sshc> Cale: What extension is needed?
13:17:23 <elliott> @hoogle ByteString -> ByteString
13:17:23 <lambdabot> Data.ByteString copy :: ByteString -> ByteString
13:17:24 <lambdabot> Data.ByteString init :: ByteString -> ByteString
13:17:24 <lambdabot> Data.ByteString reverse :: ByteString -> ByteString
13:17:25 <elliott> erm
13:17:26 <elliott> @hoogle ByteString -> [ByteString]
13:17:27 <lambdabot> Data.ByteString group :: ByteString -> [ByteString]
13:17:27 <lambdabot> Data.ByteString inits :: ByteString -> [ByteString]
13:17:27 <lambdabot> Data.ByteString tails :: ByteString -> [ByteString]
13:17:29 <azaq23> kamaji: haskell types have adopted the notion of universal and existential quantification from logic. The first one is used all the time, If you have a function f :: t -> Something, t is a universally quantified variable. The dual is existential quant., in which you say that "there exists some t so this and this is true"
13:17:32 <elliott> darn, no lines/unlines
13:18:07 <djahandarie> elliott, there are
13:18:19 <djahandarie> elliott, just use ByteString.Char8
13:18:57 <elliott> djahandarie: ah
13:19:50 <djahandarie> I sometimes wonder when I would ever use the Word8 interface
13:20:00 <djahandarie> (If I had the choice.)
13:20:10 <sshc> Cale: With PolymorphicComponents, that seems to work with newtype as well
13:38:18 <xplat> i like the word8 interface.  i want an encoding-aware interface usually when i deal with chars, except the rare occasion that i'm sure it's ascii-only.
13:39:31 <djahandarie> True. Should really be using text anyways
13:39:45 <xplat> i mean, the whole thing was pretty awkward at first, but once i realized that the reason there were no conversion functions was that the fact that certain types were the same was exposed it got a lot more convenient.
13:44:20 <copumpkin> I would support removing Char8 from ByteString altogether (or at least deprecating it)
13:44:26 <copumpkin> the Char8 version, that is
13:44:47 <arcatan> dunno, seems like often end up using the Char8 version
13:46:46 <arcatan> occurs because some libraries use String where ByteString would suffice
13:50:30 <lispy> copumpkin: is Data.Text really ready to take over?
13:50:39 <lispy> copumpkin: as I understand it, it uses a weird USC-2 encoding :(
13:50:58 <lispy> a la Java
13:51:37 <c_wraith> It's UTF-16
13:51:43 <c_wraith> honestly, Text is fine.
13:51:57 <xplat> UTF-16 is okay
13:52:01 <c_wraith> The standard libraries could use a good anti-string scrubbing.
13:52:18 <xplat> it's UTF-16 then treated as UCS-2 and reencoded in UTF-8 that is nasty
13:53:23 <djahandarie> c_wraith, you think so? [Char] is a really convenient type to work with
13:53:39 <xplat> convenient, but wrong
13:53:53 <c_wraith> [Char] is almost never convenient.
13:54:00 <earthy> why is it wrong?
13:54:15 <xplat> c_wraith: convenient in that you can use list folds etc on it
13:54:33 <djahandarie> c_wraith, eh? I've found it to be a generally nice-to-work-with representation of Strings, as long as you aren't looking for performance
13:54:35 <c_wraith> xplat: Text and ByteString both have fold operations defined on them.
13:54:42 <xplat> earthy: wrong in that haskell is still a language for programming computers
13:54:57 <copumpkin> c_wraith: convenient in that I can pattern match on it
13:55:01 <c_wraith> Though foldr on Bytestring is *still* too strict.
13:55:08 <djahandarie> But they can't be Foldables or Functors or Monads
13:55:12 <c_wraith> You can pattern-match on text with -XOverloadedStrings
13:55:13 <djahandarie> Since Bytestring is *
13:55:14 <earthy> xplat: sorry, but that sounds like bull
13:55:18 <copumpkin> c_wraith: really??
13:55:22 <c_wraith> yes
13:55:27 <copumpkin> o.O
13:55:35 <xplat> c_wraith: but there's no widely-used abstraction over both of them so lists will always have more functions
13:55:52 <djahandarie> It just doesn't feel like ByteString is the "right" representation for a String
13:55:56 <c_wraith> Yes.  But most list functions don't really make sense for Strings.
13:55:58 <djahandarie> It doesn't give you anything automatically
13:56:04 <c_wraith> djahandarie: that's why we're talking about text
13:56:11 <earthy> ByteString is nowhere near the "right" representation for strings
13:56:11 <djahandarie> Yes, text also
13:56:31 <c_wraith> Have you looked at the libs for text?  It gives a ton of common text operations
13:56:36 <earthy> ByteString is an efficient method of dealing with strings of bytes
13:56:40 <xplat> earthy: when you make a haskell compiler that can optimize [Char] into something like bytestrings by itself be sure to let me know
13:56:43 <djahandarie> c_wraith, but they aren't generalized
13:56:44 <earthy> which occurs a *lot*
13:56:57 <copumpkin> c_wraith: my impression of overloaded strings was that it provided a fromString method
13:56:58 <djahandarie> c_wraith, they are common patterns but that isn't shown at all
13:57:01 <djahandarie> So it feels wrong to me
13:57:01 <copumpkin> c_wraith: and that's it
13:57:02 <cdsmithus> You can pattern match for equality with OverloadedStrings.  But not on the shape of the text.
13:57:03 <roconnor> edwardk: [Context] -> a is a Tracer!
13:57:19 <earthy> xplat: why would I not use Data.Text when I'm concerned about speed, and allow String when I'm trying to explain things to students?
13:57:24 <copumpkin> c_wraith: meaning that overloadedstrings gives you string literals and nothing else
13:58:06 <copumpkin> what you can do is use ViewPatterns and then do f (uncons -> (x, xs)) = 
13:58:22 <copumpkin> well
13:58:25 <copumpkin> -> Just (x, xs))
13:58:36 <cdsmithus> copumpkin: or (f (T.uncons -> Just (x,xs)))
13:59:21 <cdsmithus> which is a lot uglier than f (x:xs).  Sure, the speed is worth it... but String is a perfectly correct, and easier to use, type.
13:59:34 <copumpkin> or just (toString -> x:xs) :)
13:59:46 <copumpkin> and toString -> [] for the empty case
14:00:13 <copumpkin> I mean unpack
14:00:26 <ezyang> String is mostly correct :^) 
14:01:00 <earthy> String is a *lot* better than  char*, for one. :)
14:01:14 <cdsmithus> earthy: But that's a pretty low bar. :)
14:01:29 <earthy> cdsmithus: true, true
14:01:55 <cdsmithus> ezyang: How is String incorrect?  (I trust you, I'm sure there's some bizarre corner of Unicode.  Just curious)
14:02:12 <cdsmithus> earthy: String is also more correct that java.lang.String, which is a somewhat higher bar
14:02:19 <earthy> but, then again, in Java as well as in C# as well as in Haskell there is no preferred string representation that is right for every application
14:02:46 <earthy> which makes sense really, as strings, when you look at them real close, are nowhere near trivial at all
14:02:55 <ezyang> cdsmithus: Bryan O'Sullivan has written extensively on the topic. 
14:04:24 <ezyang> But the one example I know off the top of my head is toLower 
14:04:41 <ezyang> which can only operate character to character, whereas Unicode specifies that multiple characters may be mapped by a lower-casing operation. 
14:04:42 <c_wraith> though, toLower on text is also wrong.  you need the one from text-icu to get it right
14:04:58 <ezyang> haha 
14:05:05 <c_wraith> That latter part is the unicode consortium's fault, though
14:11:34 <Palmik^school> Hmm... is it somehow possible to do something like this pseudo code is attempting to do? http://codepad.org/P3j045oD
14:12:49 <c_wraith> Palmik^school: yes.  There's a typo in that.  But there's also a standard library function called forever
14:12:49 <ezyang> If you fix your typos that should owrk. 
14:13:17 <Palmik^school> yeah, better call it "pseudo" :D
14:13:44 <Palmik^school> ok, thanks, will try that... I just was not sure where I could combine >> with do like that
14:14:53 <c_wraith> yeah.  do can be used after infix operators.
14:15:57 <Saizan> ?type \x y -> x >> forever $ do y
14:15:58 <lambdabot> forall a (m :: * -> *) a1 b. (Monad m) => (m a1 -> a) -> m a1 -> m b
14:16:17 <ezyang> do is just syntax sugar 
14:16:35 <Saizan> that gets parsed as (x >> forever) $ do y
14:16:52 <Saizan> probably not what you want
14:17:29 <Palmik^school> hmm... and what about the -> and <-?
14:17:42 <ezyang> -> is not used in do-notation 
14:17:45 <ezyang> <- corresponds to bind 
14:17:54 <ezyang> x <- m === m >>= \x -> 
14:18:34 <Palmik^school> hmm
14:19:30 <Palmik^school> do seems to be a keyword according to hoogl
14:19:31 <Palmik^school> e
14:19:50 <c_wraith> do is a keyword.
14:19:56 <c_wraith> That's why it has special syntax rules
14:20:38 <Palmik^school> ok, thanks :)
14:34:12 <Heffalump> what does Build-depends: ghc in a cabal file mean?
14:34:22 <copumpkin> ghc as a library I think
14:35:41 <Heffalump> why would QuickCheck conditionally depend on that?
14:37:41 <copumpkin> not a clue :)
14:37:45 <sproingie> way of saying it won't build on other compilers i'm guessing
14:38:26 <Saizan> no
14:38:43 <elliott> :-( takeBaseName doesn't behave like the basename(1) utility
14:39:11 <elliott> takeBaseName "///" = "" but it is defined to be "/" in POSIX; this also means that takeBaseName "<slashes>" and takeBaseName ("" or ".") are indistinguishable
14:40:34 <Palmik^school> hmm... why does (>>) expect a -> a1 in the first argument O.o
14:40:53 <azaq23> @type (>>)
14:40:54 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
14:40:57 <c_wraith> Palmik^school: Parse error
14:40:59 <Cale> Palmik^school: function monad?
14:41:46 <azaq23> @type (>>) :: (Bool -> a) -> (Bool -> b) -> (Bool -> b)
14:41:47 <lambdabot> forall a b. (Bool -> a) -> (Bool -> b) -> Bool -> b
14:41:50 <Palmik^school> well... I have the code for the pseudocode I mentioned earlier (http://codepad.org/P3j045oD) it works if the "doOnce" is id
14:42:24 <Palmik^school> but does not work id the doOnce is :: String -> MyMonad () and I pass it as (doOnce someString) >> ...
14:42:46 <Palmik^school> to be more specific...
14:43:41 <Palmik^school> http://codepad.org/IkTbR55g
14:45:16 <Palmik^school> it works without the ((joinChannel botChan) >>)
14:45:24 <Saizan> you can't use $ there
14:46:23 <Palmik^school> hmm, now it's just a parse error :)
14:46:25 <Saizan> ... >> forever (do ...) will work
14:46:49 <Palmik^school> you are right
14:46:50 <Palmik^school> thanks
14:48:38 <rumbold> i want to write out an image. the function i want to use for that expects a Ptr Word8. i dont know how to make something that fits that. im a total haskell noob. i googled around a bit, getting somewhat frustrated here. :|
14:49:29 <sipa> :t alloca
14:49:31 <lambdabot> Not in scope: `alloca'
14:51:03 <monochrom> where does your image come from?
14:52:10 <rumbold> im trying to make one myself. not quite sure how :( i used a list of string before, outputted to the console
14:52:42 <kafee> I'm stuck. Do you guys have any points on euler 158?
14:53:22 <sleepynate> aside from the "use C" troll?
14:53:26 <sleepynate> no.
14:53:28 <Zao> Use C++.
14:53:36 <sleepynate> hey! there it is
14:53:59 <Zao> You guys will _not_ trick me into solving PE problems again.
14:54:03 <Zao> Last time it took weeks to get out.
14:54:14 <sleepynate> but 212
14:54:19 <sleepynate> 212 goddamnit!
14:54:23 <kafee> could use c++, only, so aside
14:55:14 <Heffalump> kafee: the maximum must surely come when n=26, right?
14:56:17 <kafee> i want to use the beauty of haskell
14:56:41 <int80_h> ypu have come to the right place
14:56:51 <megajosh2> I'd appreciate the grand divine majesty of Haskell more if I could get object code to load dynamically
14:57:12 <megajosh2> Which brings me to ask, is there some specific way you need to compile modules besides using --make when you want them to be loadable by hs-plugins?
14:57:20 <megajosh2> I constantly get unresolved symbols
14:57:41 <blackdog> poucet: so close:)
14:57:42 <kafee> I'm pretty sure there's a neat trick I'm not seeing
14:57:46 <kafee> like a chess move to solve a chess problem
14:57:55 <blackdog> one more by-three reduction...
14:57:56 <megajosh2> To what?
15:00:56 <Heffalump> kafee: my naive first view of the problem is that (a) you just have to manage it for n=26 and (b) a sequence satisfies their property if it is the concatenation of two non-increasing sequences of characters where the join is increasing. I think that can be counted with dynamic programming quite easily.
15:01:19 <monochrom> You may try Foreign.Marshal.Array.newArray :: Storable a => [a] -> IO (Ptr a). If you don't understand that type, just know that in your case it's [Word8] -> IO (Ptr Word8). So prepare your image in a [Word8], then use that. Then you get a Ptr Word8 and you can give it to the writer. Don't forget to call Foreign.Marshal.Alloc.free afterwards.
15:01:39 <dabblego> does catMaybes generalise e.g. (Copointed f, Traversable t) => t (f a) -> t a ?
15:02:58 <c_wraith> wait, copointed is "you might be able to extract a value from this"?
15:03:08 <c_wraith> I thought copointed was "you can put a value into this"
15:03:19 <dabblego> Copointed is f a -> a
15:03:21 <ezyang> I thought that's pionted? 
15:03:22 <c_wraith> oh, right.
15:03:23 <dabblego> obviously this is not enough
15:03:32 <dabblego> and Maybe is not Copointed
15:03:40 <c_wraith> yeah.  Maybe isn't copointed.
15:03:42 <rumbold> can you simple pass an array when a ptr is expected? ive seen code that seems to do that, but i dont know what the type would have to look like for that to work
15:03:50 <monochrom> no
15:04:05 <mauke> wait, is this #C?
15:04:07 <aristid> (Foldable f, Traversable t) => t (f a) -> t a might work
15:04:28 <dabblego> ah yeah good one
15:04:55 <kafee> ok
15:05:44 <rumbold> http://stackoverflow.com/questions/995716/pass-pointer-to-an-array-in-haskell-to-a-c-function it seems to work in this code. etime expects a ptr double and he simply passes "array 2", if i understand that right
15:05:45 <monochrom> well, I guess Data.Array.Storable is a special kind of array for that.
15:07:54 <monochrom> you really believe in meaningful identifiers religiously, don't you?
15:07:55 <Heffalump> is there an easy way to tell what packages came with GHC, if the package database has since had lots of other stuff dumped in it?
15:08:13 <dabblego> I don't think Foldable is enough
15:08:17 <rumbold> its not my code. just googling around
15:08:41 * hackagebot comonad 0.6.0 - Haskell 98 comonads  http://hackage.haskell.org/package/comonad-0.6.0 (EdwardKmett)
15:08:43 * hackagebot functor-apply 0.6.0 - Strong lax semimonoidal endofunctors (Applicative sans pure)  http://hackage.haskell.org/package/functor-apply-0.6.0 (EdwardKmett)
15:09:02 <copumpkin> dabblego: Maybe isn't Copointed
15:09:03 <monochrom> I am referring to your seeing the word "array" and deducing that it really means array.
15:09:16 <ezyang> Heffalump: as in, the system-wide database? Unfortunately not. 
15:09:27 <copumpkin> oh
15:09:32 <copumpkin> I missed everyone else telling you that
15:09:36 * copumpkin hides
15:09:40 <rumbold> hm. i thought he was creating an array there
15:09:45 <dabblego> copumpkin, right, I'm looking for the right one though :)
15:10:14 <copumpkin> t can't be traversable
15:10:20 <copumpkin> traversable won't let you change the shape
15:10:28 <dabblego> copumpkin, right, I'm looking for the right one though :)
15:10:32 <monochrom> In any case the use of mallocArray is in the same vein as my Foreign.Marshal.Array.newArray above. If only you care to see what modules are imported for it.
15:10:37 <copumpkin> I know, was just objecting to aristid's proposal :)
15:10:42 * hackagebot comonad-transformers 0.6.0 - Haskell 98 comonad transformers  http://hackage.haskell.org/package/comonad-transformers-0.6.0 (EdwardKmett)
15:10:48 <dabblego> copumpkin, yeah, cheers
15:11:03 <et2> haskellers, quick question from a super beginner --- with the reverse function, how would i use it on a list of strings without actually reversing each individual string.......in other words i want reverse "a man a plan" to return "plan a man a"
15:11:22 <copumpkin> > unwords . reverse . words $ "a man a plan"
15:11:23 <dabblego> et2, you want to look at these functions: words, unwords, map
15:11:25 <lambdabot>   "plan a man a"
15:11:35 <copumpkin> whoops
15:11:56 <copumpkin> @let withWords f = unwords . f . words
15:11:56 <mauke> et2: that's not a list of strings
15:11:57 <lambdabot>  Defined.
15:12:13 <et2> ahh thank you haskellers for the very quick response
15:12:43 * hackagebot comonads-fd 0.6.0 - Comonad transformers using functional dependencies.  http://hackage.haskell.org/package/comonads-fd-0.6.0 (EdwardKmett)
15:12:45 <dabblego> @type withWords
15:12:46 <lambdabot> ([String] -> [String]) -> String -> String
15:12:47 <et2> yes mauke, i understand it's not a list of strings, but ghci wasn't liking ["a" "man" "plan" "panama"]
15:12:58 <mauke> et2: because you forgot the commas
15:13:00 <sproingie> use commas
15:13:33 <djahandarie> TV uses onLines, perLine, onWords, perWord, I think
15:13:56 <dabblego> TV?
15:14:03 <et2> ahhh, wow i feel a little stupid. sorry, still trying to get a grasp on this interesting language
15:14:07 <et2> thank you all for your help
15:14:10 <djahandarie> Tangible Value, a library that conal made
15:14:29 <mauke> Tangerine Veal
15:14:31 <conal> @wiki TV
15:14:31 <lambdabot> http://www.haskell.org/haskellwiki/TV
15:14:31 <djahandarie> I'd look up the docs, but Hackage still barely loads from my home connection
15:14:36 <dabblego> et2, read composition right to left, "given a value, unwords that value, reverse that, then words that"
15:16:07 <conal> hrmf. that wiki page has some trashed markup.
15:16:23 <et2> dabblego, looking at the docs, this makes sense. thank you
15:16:31 <djahandarie> I don't remember where I saw these functions
15:16:38 <conal> code lines crammed together.
15:16:46 <monochrom> because of <hask>. see my example at http://www.haskell.org/haskellwiki/MigratingWikiContent
15:17:31 <monochrom> why is internet connection still so flaky in the 21st century?
15:18:03 <monochrom> supposedly we should even get reliable fast torrents from the moon now
15:18:37 <djahandarie> Hackage is the *only* site on the internet I have this sort of trouble connecting to
15:18:40 <djahandarie> I have no clue why
15:20:58 <sleepynate> probably written in some crappy programming language no one ever heard of
15:21:31 <monochrom> that is an oxymoron. crappy languages are famous.
15:22:02 <sleepynate> :D
15:22:12 <sleepynate> i wanna go hooooome so i can happstack
15:22:38 <aristid> monochrom: like haskell
15:22:46 <lelf> Server: Apache/2.2.9 (Debian) mod_python/3.3.1 Python/2.5.2
15:22:50 <lelf> like that
15:23:00 <sleepynate> ziiiiiing!
15:25:47 <megajosh2> Has anybody successfully gotten code to load with hs-plugins? I /always/ get unresolved symbols and I'm not sure what I'm doing wrong
15:30:49 <mreh> haskell famous?
15:31:30 <monochrom> famous enough to get a spot on reddit
15:31:31 <mreh> haskell is some meme invented by python programmers as far as teh internet is concerned
15:31:49 <mauke> preflex: mtfnpy
15:34:08 <mreh> how can I set a package restriction in ghci?
15:34:13 <mreh> apart from hiding it
15:34:24 <monochrom> -hide-package
15:34:39 <monochrom> :set -hide-package base :)
15:34:51 <mreh> hang on, you can use the same flags in ghc
15:34:59 <mreh> I keep forgetting that
15:35:07 <mreh> apart from ones relating to compilation of course
15:40:30 <Cale> megajosh2: Consider trying hint
15:41:46 <Cale> hmm, the plugins package on hackage has been updated in the last year though...
15:43:18 <rumbold> hmm, i got it to compile with newArray, only now i get a segfault :(
15:43:26 <josh___> hey, guy! I'm just trying haskell for the first time!
15:43:38 <Cale> Hello!
15:43:41 <dabblego> hi josh___ how's it going?
15:43:46 <mreh> \0/
15:43:56 <josh___> dabblego: Pretty awesome! 
15:43:58 <Cale> rumbold: Using what type of MArray?
15:43:58 <monochrom> seems to be fashionable to try haskell for the first time. maybe I should do that too.
15:44:11 <blackdog> monochrom: like a thunk, evaluated for the very first time
15:44:19 <mreh> I'll fetch the deneuraliser
15:44:23 <Cale> The very last time as well
15:44:23 <dabblego> josh___, great, let us know if you have questions
15:44:27 <monochrom> not MArray. Foreign.Marshal.Array.newArray :: (Storable a) => [a] -> Ptr a
15:44:38 <rumbold> i dunno what MArray is. i got a Ptr Word8 and i pass it to a function thats supposed to write them as a png
15:44:51 <Cale> monochrom: Ah, I see
15:44:52 <blackdog> Cale: call me by name, not by need
15:45:43 <Cale> Call any vegetable, call it by need?
15:46:23 <aristid> blackdog is meat, not vegetable
15:46:52 <monochrom> how dare you consider blackdog food
15:46:56 <rumbold> http://hpaste.org/42850/a_bit_of_my_terrible_code <- here is some of my code
15:47:18 <Cale> rumbold: Configure your text editor to convert tabs to spaces
15:47:21 <gwern> blackdog is our Menchi - emergency food supply
15:47:37 <gwern> a pity since we invested the time to toilet train him with bullets
15:48:59 <monochrom> (10, 50)? (50, 10)?
15:49:27 <rumbold> the docu says its rows, colums, not width, height. i tried the other way around too
15:50:05 <rumbold> render' gives back a list of four word 8s. writeImageFromPointer takes raw RGBA data
15:51:51 <rumbold> i even get a segfault if i do (1,1)
15:51:59 * hackagebot semigroups 0.1.0 - Haskell 98 semigroups  http://hackage.haskell.org/package/semigroups-0.1.0 (EdwardKmett)
15:52:07 <edwardk> roconnor: challenge accepted ;)
15:52:23 <blackdog> ... you people scare the hell out of me :)
15:54:54 <monochrom> you haven't even heard what I say about newbies. "I love newbies. I eat them for breakfast."
15:56:54 <ezyang> Why doesn't stream version work for sum, again? 
15:57:14 <monochrom> do you need ilInit before writeImageFromPtr?
15:57:20 <monochrom> http://hackage.haskell.org/packages/archive/Codec-Image-DevIL/0.2.3/doc/html/Codec-Image-DevIL.html
15:58:00 <ezyang> monochrom: Probably FFI nastiness 
16:06:36 <rumbold> oh crap! i took it out at some point because you cant use the library with ghci... thanks, it works now
16:06:48 <rumbold> √Æ @monochrom
16:10:49 <xplat> haskell a meme invented by python programmers?  lies!  haskell is a tool invented by Larry Wall so people could start golfing perl6 programs before perl6 existed!
16:20:12 <ezyang> Haskell makes it so easy to stop paying attention to performance :-/ 
16:22:17 <Eduard_Munteanu> Yeah, that's certainly a problem.
16:22:57 <rumbold> "Couldn't match expected type `Float' against inferred type `Int' In the first argument of `render'', namely `(x :: Float)'" <- does that make any sense?
16:23:30 <Eduard_Munteanu> rumbold: if you think 'x :: Float' is a cast, you're wrong.
16:23:43 <rumbold> ah
16:24:28 <Eduard_Munteanu> rumbold: it merely specifies the type of x, but if x already has a specific (monomorphic) type it won't work.
16:24:38 <Eduard_Munteanu> > 3 :: Float
16:24:40 <lambdabot>   3.0
16:24:50 <Eduard_Munteanu> > (3 :: Int) :: Float
16:24:51 <lambdabot>   Couldn't match expected type `GHC.Types.Float'
16:24:51 <lambdabot>         against inferred typ...
16:25:09 <Eduard_Munteanu> > fromIntegral (3 :: Int)   :: Float
16:25:11 <lambdabot>   3.0
16:26:18 <rumbold> thanks
16:35:22 <Cale> hmm, back when I was first learning unix/sh programming I remember a tutorial which discussed composability of unix commands and building pipelines by way of writing a single-command spellchecker -- anyone happen to know what this might have been?
16:36:09 <blackdog> Cale: programming pearls?
16:36:32 <blackdog> the Bentley book
16:37:42 <Cale> mm, I think I might have found it: Opening the software toolbox
16:39:15 * ezyang idly wonders if a CPS transform would enable efficient optimization of a stream fused concat 
16:40:23 * hackagebot functor-apply 0.7.0 - Strong lax semimonoidal endofunctors (Applicative sans pure)  http://hackage.haskell.org/package/functor-apply-0.7.0 (EdwardKmett)
16:41:07 <ezyang> probably not 
16:41:24 * hackagebot comonad-transformers 0.6.1 - Haskell 98 comonad transformers  http://hackage.haskell.org/package/comonad-transformers-0.6.1 (EdwardKmett)
16:42:06 <aristid> edwardk: seriously, man. "strong lax semimonoidal endofunctors" is the best way to scare people
16:43:26 <edwardk> 'applicative sans pure' ;)
16:43:52 <aristid> yeah that actually made sense to me
16:43:54 <ezyang> We should call them Slax 
16:43:59 <edwardk> ahaha
16:44:23 <xplat> i don't know, i find 'strong lax semimonoidal endofunctors' kind of sexy
16:45:31 <edwardk> right now i'm trying to find what useful things i can say about the structures that permit traversal by a FunctorApply or folding by a Semigroup. i get a nice little Traversable1/Foldable1 class out of them
16:46:18 <edwardk> not sure yet if that is a 'semigroup-extras' or if it winds up in functor-apply
16:47:31 <dabblego> edwardk, I have a Semigroup package on hackage
16:47:43 <edwardk> dabblego: =/
16:47:50 <joyfulgirl> Hey, folks. I'm playing with Text.Feed.Import right now. In particular, I'm looking at (parseFeedFromFile :: FilePath -> IO Feed)
16:47:51 <edwardk> i just put another up
16:47:53 <edwardk> ick
16:48:04 <dabblego> I put that one up because someone put a useless one up
16:48:26 <edwardk> mine has a few more operations ;)
16:48:26 <dabblego> which consisted of the type-class and nothing else
16:48:41 <joyfulgirl> Unfortunately, I'm still a bit new at this. Where should I look for a way to to get at the resulting Feed minus the IO
16:48:45 <joyfulgirl> ?
16:48:58 <dabblego> joyfulgirl, you can't, this is very important
16:49:16 <edwardk> but mostly i grabbed the (<>) name so that i could make a case to introduce it above Monoid as part of a number of small proposals i want to drop on libraries
16:49:17 <dabblego> joyfulgirl, however, there are functions that allow you to access the Feed, without being rid of the IO
16:49:19 <ezyang> you can do so inside the context of a function which is bound 
16:49:25 <joyfulgirl> dabblego: Yeah?
16:50:10 <edwardk> (since there was already consensus on making <> exported by Monoid, and a nod towards eventually phasing out the mappend name. if you're goingthat far its not a big stretch to go to semigroups)
16:50:12 <xplat> essentially, instead of changing your function to take the IO off the output, you change the next function to have an IO on the input
16:50:24 <Eduard_Munteanu> foo <- parseFeedFromFile bar; doSomethingWithFeed foo
16:50:36 <edwardk> dabblego i wish i would have seen yours before uploading another though
16:50:43 <dabblego> joyfulgirl, one such example is liftM, which takes a function Feed -> x and a (IO Feed) then returns a (IO x)
16:50:48 <edwardk> because i have a feeling i could have had you make the changes directly to yours ;)
16:50:50 <joyfulgirl> xplat: Aha, makes since
16:51:06 <xplat> and you can do that without changing anything inside either of the functions, you just use another function to combine them
16:51:46 <xplat> that function is called (>>=), but it has the easier-to-pronounce nickname 'bind'
16:52:18 <Eduard_Munteanu> :t (>>=)
16:52:18 <joyfulgirl> dabblego: aha, excellent! Looking at the docs for it now. Thanks
16:52:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
16:52:45 <joyfulgirl> xplat: Cool, I'll check that out, too. thanks (-:
16:57:32 <joyfulgirl> dabblego: Great, liftM does exactly what I need. Thanks (-:
16:57:49 <dabblego> joyfulgirl, no worries :)
16:58:25 <joyfulgirl> I've been reading through Realworld Haskell, but haven't gotten to monads as of yet
16:58:52 <dabblego> you're already there!
16:59:02 <joyfulgirl> So it would seem (-:
17:05:37 <lars9> @hoogle range
17:05:38 <lambdabot> Data.Ix range :: Ix a => (a, a) -> [a]
17:05:38 <lambdabot> Language.Haskell.TH data Range
17:05:38 <lambdabot> Language.Haskell.TH.Syntax data Range
17:06:43 <sbahra> > range (1, 10)
17:06:44 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
17:08:27 <dabblego> edwardk, where is your version on hackage?
17:08:42 <edwardk> semigroups
17:08:48 <sbahra> Hey edwardk :]
17:08:51 <edwardk> heya samy
17:09:10 <sbahra> Good news today. I get to spend 50% of my time doing R&D at work. The blue sky kind too.
17:09:21 <sbahra> Psyched.
17:09:34 <edwardk> (semigroups, comonad) => functor-apply => comonad-transformers => comonads-fd ‚Äî at the moment.
17:10:39 <edwardk> functor-apply is picking up Traversable1 and Foldable1, where Foldable1 provides safer semigroup reductions (and the traverse1_ equivalents for FunctorApply, and Traversable1 provides the rest
17:10:45 <edwardk> sweet
17:11:10 <sbahra> You can bet down the road I'm going to propose Haskell support for the MTA. :-P
17:11:21 <lars9> i want a type of 1D range, like (0<x<1 || 10<x), suports intersect, union, in, reverse etc
17:11:29 <lars9> does it exist?
17:12:14 <rumbold> damn, i fail at figuring out how to cast a float to an int. :| this cant be that hard
17:12:33 <ezyang> @hoogle Float -> Int 
17:12:34 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
17:12:34 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
17:12:34 <lambdabot> Prelude exponent :: RealFloat a => a -> Int
17:12:47 <ezyang> lol 
17:13:03 <azaq23> @type toInteger
17:13:05 <lambdabot> forall a. (Integral a) => a -> Integer
17:13:09 <lars9> >round 1.1
17:13:19 <azaq23> okay, not toInteger
17:13:19 <lars9> > round 1.9
17:13:20 <lambdabot>   2
17:13:35 <lars9> > ceiling 1.1
17:13:36 <lambdabot>   2
17:13:50 <ezyang> :t round 
17:13:51 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
17:14:16 <lars9> so, no such Range class exists?
17:14:31 <rumbold> > floor 254.99
17:14:32 <lambdabot>   254
17:15:03 <azaq23> lars9: Between 0 and 1 (so float) or > 10?
17:17:33 <lars9> azaq23: yeah
17:17:59 <xplat> lars9: might be called Interval or somesuch
17:18:00 <lars9> dont want to use function, can not Show, Eq, etc
17:18:11 <lars9> @hoogle interval
17:18:11 <lambdabot> No results found
17:18:54 <azaq23> lars9: That seems quite exotic, but you can create your own algebraic datatype and instantiate the class Enum, like data T = ZeroToOne Float | Greater10 Float
17:18:57 <azaq23> @src Enum
17:18:58 <lambdabot> class  Enum a   where
17:18:58 <lambdabot>     succ                     :: a -> a
17:18:58 <lambdabot>     pred                     :: a -> a
17:18:58 <lambdabot>     toEnum                   :: Int -> a
17:18:58 <lambdabot>     fromEnum                 :: a -> Int
17:19:00 <lambdabot> [3 @more lines]
17:19:02 <azaq23> @more
17:19:03 <lambdabot>     enumFrom                 :: a -> [a]
17:19:04 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
17:19:06 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
17:19:20 <lispy> yay, spambdabot! :)
17:19:48 <azaq23> though Ix seems related to Enum, I don't know about the relations of these classes
17:20:22 <lars9> azaq23: oh no, 0,1,10 are just examples, i want two intervals can join, union etc
17:21:56 <xplat> waiting for my browser to respawn so i can search
17:23:51 <azaq23> lars9: Try searching hackage, first thing I found is this http://hackage.haskell.org/package/intervals-0.1.3
17:24:50 <lars9> azaq23: seems quite possible, but this pkg has not doc at all...
17:26:19 <EliasAmaral> (I understand the Haskell IO model as a data structure with the description of all IO operations. The IO will get fired in the same order regardless of your evaluation strategy (unless there is some strictness-induced non-termination somewhere). I think that if you tweak the evaluation order, the sole things you can observe from the behavior of a Haskell program is a) performance issues, resource usage, .. and b) non-termination.)
17:26:23 <EliasAmaral> is this incorrect?
17:27:33 <Cale> EliasAmaral: that's roughly correct, yes. There are some magical lazy IO things where that view somewhat breaks down (but you're not intended to use lazy IO in such a way that it would matter)
17:27:44 <azaq23> lars9: I took a quick look at the source, I think it's pretty easy to get the general idea.
17:28:12 <lars9> azaq23: i'm looking into it too, thanks:)
17:28:33 <lars9> EliasAmaral: fired exactly in the order of evaluation...
17:29:38 <lars9> you can think IO as a State monad, type IO = State RealWorld
17:31:03 <lars9> the only diff from other states is that you can(should) never escape from a realworld
17:31:28 <Eduard_Munteanu> Actually it's a bit more like ST, with IO stuff added on and no runST :)
17:34:21 <EliasAmaral> lars9, what?
17:36:46 <EliasAmaral> lars9, I didn't understood what you meant, some syntactical error in my English?
17:37:07 <EliasAmaral> I think that even if b is evaluated before a, it is still possible that a get exec before b (like: main = seq b (do { c <- a; d <- b }) -- not sure if this is proper haskell)
17:37:49 <mm_freak_> lars9: this model is widely considered as broken
17:38:16 <mm_freak_> the easiest way to understand IO is not to understand it, but just use it
17:38:22 <mm_freak_> because after all it's just a DSL
17:38:31 <EliasAmaral> mm_freak_, you are confusing me
17:39:00 <mm_freak_> EliasAmaral: a value of type 'IO a' is a computation, which eventually yields a result of type 'a'
17:39:06 <mm_freak_> and that's about it
17:39:37 <mm_freak_> you can combine these computations by using monadic/functor combinators like (>>=)
17:39:41 <mm_freak_> or do-notation for that matter
17:41:42 * hackagebot functor-apply 0.7.1 - Strong lax semimonoidal endofunctors (Applicative sans pure)  http://hackage.haskell.org/package/functor-apply-0.7.1 (EdwardKmett)
17:41:47 * edwardk looks up at the mention of his interval library
17:41:52 <edwardk> its a bit out of date
17:41:58 <EliasAmaral> the actual discussion was about the relationship of laziness and purity at caml-list (I can't find archives for jan 2011). someone pointed out that pattern matching in haskell can yield side effects. is that true?
17:42:14 <azaq23> EliasAmaral: b does not exist outside of the "do" expression. And even if, "seq x y" would not execute the IO action, but evaluate the expression x, yielding just a value of type IO t.
17:42:25 <EliasAmaral> "Pattern-matching can force the evaluation of something that when evaluated has an effect."; but I think that haskell has no such expressions
17:42:27 <mm_freak_> EliasAmaral: no, but pattern matching can force evaluation
17:42:39 <mm_freak_> case x of Just y -> ‚Ä¶
17:42:48 <azaq23> EliasAmaral: No, I am wrong about b not existing outside of do, misread that.
17:42:52 <mm_freak_> in this case this will evaluate 'x' enough to tell whether it's a 'Just'
17:43:01 <shachaf> EliasAmaral: There's unsafePerformIO, but we don't talk about it. Other than that, evaluation will never cause a side effect.
17:43:08 <EliasAmaral> azaq23, what about let b = .. in seq b (do { .. <- b; ..}); nonetheless i see that seq a b does not do any IO action, but just evaluates a
17:43:15 <EliasAmaral> oh. hmm.
17:43:20 <edwardk> lars9: the intervals library started as a part of a larger effort to handle taylor models, but sadly glibc is busted in annoying ways and hmpfr is busted in others
17:43:23 <ezyang> EliasAmaral: Do you consider nontermination a side effect? ;-) 
17:43:26 <mm_freak_> EliasAmaral: this /can/ lead to side-effects, if you do lazy IO
17:43:33 <mm_freak_> like hGetContents
17:43:44 <shachaf> Lazy IO is evil, though.
17:43:53 <Eduard_Munteanu> Why is it evil?
17:43:53 <mm_freak_> case fileContents of 'a':_ ->
17:43:59 <edwardk> lars9: (that said, i wanted proper rounding on the interval arithmetic at first)
17:44:02 <shachaf> For the reason just mentioned. :-)
17:44:06 <mm_freak_> this will read enough from the file to tell whether the first character is an 'a'
17:44:13 <lars9> edwardk: oh, so it seems it has some potential users, consider adding some doc? :)
17:44:14 <ezyang> lazy IO is totally unsafePerformIO 8) 
17:44:14 <mm_freak_> which is a side effect, a result of lazy IO
17:44:15 <Eduard_Munteanu> Well for many applications lazy IO is very natural and quite not evil.
17:44:17 <edwardk> so if you don't care about full correctness that the interval contains the answer, then intervals should be sufficient
17:44:41 <mm_freak_> Eduard_Munteanu: it's not necessarily evil, but there are better ways to express I/O elegantly
17:44:57 <EliasAmaral> ezyang, oh. my "opinion" is that non-termination means the program is ill-defined, and the runtime may choose to do anything it wishes (such as crashing with stack overflow, running forever, etc). but programming is not a matter of opinion, and, hm, i may not be entitled to an opinion if I don't know the specs of haskell also...
17:45:01 <edwardk> hrmm it also appears to be failing to generate haddock because of one stupid comment. i should fix that
17:45:11 <mm_freak_> lazy IO suffices for simple command line tools, where predictability in code is not that important
17:46:01 <edwardk> lars9: the goal was to be able to use it with the 'ad' package to build taylor models
17:46:06 <Eduard_Munteanu> mm_freak_: I mean, for example, I wouldn't use iteratees for processing some stream. For instance, going once over each byte.
17:46:11 <lars9> if we think type of IO = State Realworld, then IO can be though as pure in haskell.
17:46:22 <mm_freak_> Eduard_Munteanu: i would, but that's because i like the concept
17:46:24 <Eduard_Munteanu> For that stuff, lazy bytestrings make a lot of sense.
17:46:30 <edwardk> lars9: but iirc it tries to set the rounding mode, and the default libm flips out and gives crap answers if you do
17:46:45 <edwardk> i may have stripped that at the end though
17:46:57 <ezyang> IIRC, iteratees work perfectly fine for going once over each byte. 
17:47:00 <mm_freak_> Eduard_Munteanu: whether you choose lazy IO or iteratees in this case is really a matter of taste
17:47:07 <edwardk> going to head home, bbiab
17:47:10 <mm_freak_> but when writing a scalable server, you shouldn't use lazy IO
17:47:24 <lars9> edwardk: i'll check if it works for me
17:47:26 <EliasAmaral> shachaf, may I quote you at the mailing list? the "but we don't talk about it" bit was remarkable, because yeah, I don't see nobody talking about it. (maybe people are ashamed?)
17:47:54 <mm_freak_> lars9: IO is pure in any case
17:48:00 <mm_freak_> lars9: unless you use unsafePerformIO
17:48:07 <mm_freak_> don't confuse evaluation with execution
17:48:19 <lars9> mm_freak_: that's what i meant, 'if' dont escape
17:48:20 <mm_freak_> execution is never pure, while evaluation (in haskell) is always pure
17:49:33 <lars9> EliasAmaral: IO in haskell IS pure
17:49:54 <EliasAmaral> isn't unsafePerformIO *not pure*?
17:49:56 <Eduard_Munteanu> It does make me wonder whether OI is salvageable.
17:50:03 <EliasAmaral> I'm being confused serially
17:50:05 <mm_freak_> EliasAmaral: exactly
17:50:08 <lars9> EliasAmaral: unsafePerformIO is 'unsafe' as it's said to be
17:50:15 <mm_freak_> it's not that IO is pure in haskell, but evaluation is pure
17:50:35 <mm_freak_> unsafePerformIO breaks the border between evaluation and execution, introducing impurity to evaluation
17:50:35 <EliasAmaral> but it is not about safeness, but about purity - is the evaluation of unsafePerformIO *impure*?
17:51:00 <mm_freak_> it is about safety, too, because haskell code generally /assumes/ evaluation to be pure
17:51:05 <EliasAmaral> (I understand that an forall a b. a -> b cast which is not bottom is certainly _unsafe_, but not necessarily pure)
17:51:19 <EliasAmaral> oh
17:51:24 <EliasAmaral> not necessarily impure
17:51:37 <mm_freak_> example:  using unsafe functions you can write a function of type 'a -> b', which actually yields a value
17:51:47 <mm_freak_> in pure haskell such a function is not possible
17:51:54 <Eduard_Munteanu> As far as the lambda calculus involved is concerned... it's not impure.
17:52:10 <lars9> evaluation of unsafePerformIO is pure, but the evaluation itself is practically no-sense, in reality you can not drop a realworld
17:52:45 <mm_freak_> well, in that case you need to ask, what's "pure"?
17:52:50 <mm_freak_> i think pure = referentially transparent
17:52:55 <EliasAmaral> lars9, it _is_ pure? so evaluating it will not force some IO?
17:52:57 <mm_freak_> which renders evaluation of unsafePerformIO /not/ pure
17:53:14 <john_r_watson> k, I'm playing w/ Hughes example from his paper on arrows: http://www.cse.chalmers.se/~rjmh/afp-arrows.pdf
17:53:22 <mm_freak_> EliasAmaral: sure it will:  print (unsafePerformIO $ readFile "blah.txt")
17:53:49 <john_r_watson> on page 9 he has: runSF (arr id &&& delay 0) [1..5]
17:53:50 <EliasAmaral> pure == the result depends only on the parameters, and the result is just what is returned; i.e. it is referentially transparent
17:53:54 <mm_freak_> anyway, unsafePerformIO is seldomly needed in real code
17:54:00 <Eduard_Munteanu> It's more clear if you consider that evaluating a certain term twice gives different results. That's where "impure" comes from.
17:54:07 <john_r_watson> yielding [(1,0), (2,1),...]
17:54:08 <lars9> mm_freak_: if you implement unsafePerformIO with a time traval machine, it is referentially transparent
17:54:26 <john_r_watson> but when I try: runSF (arr id &&& arr tail) [1..5]
17:54:29 <john_r_watson> it's game over.
17:54:42 <mm_freak_> lars9: if you implement unsafePerformIO as 'undefined', then it's pure, too
17:54:49 <john_r_watson>     No instance for (Num [a])
17:54:49 <john_r_watson>       arising from the literal `4' at <interactive>:1:35
17:54:50 <john_r_watson>     Possible fix: add an instance declaration for (Num [a])
17:54:50 <john_r_watson>     In the expression: 4
17:54:52 <john_r_watson>     In the second argument of `runSF', namely `[1, 2, 3, 4]'
17:54:56 <john_r_watson>     In the expression: runSF (arr id &&& arr tail) [1, 2, 3, 4]
17:54:58 <mm_freak_> we need to talk about its actual implementation, not some fictional one
17:54:59 <john_r_watson>  
17:55:06 <mm_freak_> otherwise the whole discussion is pointless
17:55:08 <Eduard_Munteanu> :t arr
17:55:09 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
17:55:20 <john_r_watson> but the following works fine: liftM2 zip id tail [1,2,3,4]
17:55:42 <mm_freak_> john_r_watson: you're expressing two different things here
17:55:46 <lars9> or can we say, current implementation of unsafePerformIO is not flawless, due to current human technology?
17:55:51 <mm_freak_> john_r_watson: one is the function arrow, the other is the list monad
17:56:11 <EliasAmaral> lars9, if I evaluate some unsafePerformIO twice, will it do the action twice?
17:56:14 <mm_freak_> john_r_watson: notably the arrow thing, when done properly, will yield /one/ result
17:56:17 <john_r_watson> mm_freak_: liftM2 zip id tail should be the function ((->) r) monad no?
17:56:17 <shachaf> EliasAmaral: Yes.
17:56:26 <mm_freak_> john_r_watson: no
17:56:30 <mm_freak_> john_r_watson: yes
17:56:30 <shachaf> EliasAmaral: unsafePerformIO is not referentially transparent.
17:56:32 <mm_freak_> sorry
17:56:47 <john_r_watson> mm_freak_: no prob
17:56:52 <EliasAmaral> but I still enjoyed lars9's quote :)
17:57:02 <mm_freak_> > (arr id &&& arr tail) [1..5]
17:57:03 <lambdabot>   ([1,2,3,4,5],[2,3,4,5])
17:57:14 <mm_freak_> the liftM2 version will return something different
17:57:19 <john_r_watson> that's differnt though
17:57:26 <EliasAmaral> or, this message, saved as a quote for posterity
17:57:29 <mm_freak_> > liftM2 zip id tail [1..5]
17:57:30 <lambdabot>   [(1,2),(2,3),(3,4),(4,5)]
17:57:33 <john_r_watson> runSF is running "stream functions"
17:57:45 <john_r_watson> runSF (arr id &&& arr tail) [1..5]
17:57:55 <john_r_watson> newtype SF a b = SF { runSF :: [a] -> [b] }
17:57:58 <mm_freak_> yeah, but i'm not sure you want arrows at all, because i'm not sure what you want to do
17:58:17 <john_r_watson> I *really* want to know why delay 0 works rather than tail
17:58:41 <mm_freak_> honestly i never used arrows seriously
17:59:06 <john_r_watson> instance Arrow SF where
17:59:06 <john_r_watson>      arr    = SF . map
17:59:06 <john_r_watson>      first  = (*** SF id)
17:59:06 <john_r_watson>      second = (SF id ***)
17:59:09 <Eduard_Munteanu> :t delay
17:59:09 <john_r_watson>      -- SF ([f] -> [g]) -> SF ([f] -> [h]) -> SF ([f] -> [(g,h)])
17:59:10 <lambdabot> forall b (a :: * -> * -> *). (ArrowCircuit a) => b -> a b b
17:59:12 <john_r_watson>      (SF f) &&& (SF g) = SF $ f &&& g >>> uncurry zip
17:59:15 <john_r_watson>  
17:59:22 <john_r_watson> uh oh
17:59:25 <EliasAmaral> is unsafePerformIO part of some haskell standard? if it _is not_, then one can claim that haskell itself is pure, but some implementations violate this purity
17:59:27 <john_r_watson> i had no idea delay was already defined
17:59:29 <lars9> EliasAmaral: anyway, correct implementation of unsafePerformIO requires time travel machine, so ppl rarely use it before the machine is invented
17:59:30 <john_r_watson> he did: delay x = SF (x:)
18:00:04 <mm_freak_> lars9: what is the "correct" implementation?
18:00:20 <john_r_watson> alternate definitions:
18:00:20 <john_r_watson>   (SF f) &&& (SF g) = SF $ f &&& g >>> uncurry zip
18:00:21 <john_r_watson>   (SF f) &&& (SF g) = SF $ liftM2 zip f g
18:00:21 <john_r_watson>  
18:00:24 <c_wraith> lars9: I don't see why not.  Once you invent it, you can travel back in time with its implementation.
18:00:32 <shachaf> There is no correct implementation of unsafePerformIO.
18:00:37 <lars9> get same answer when evaled twice
18:00:38 <shachaf> unsafePerformIO doesn't exist.
18:00:45 <shachaf> We have always been at war with Eurasia.
18:01:13 <xplat> lars9: how would you know what time to go back to and eval it?
18:01:43 <xplat> plus it probably wouldn't do what you want in that case
18:01:56 <shachaf> But, seriously, IO actions are just actions that you build up. Evaluation never executes them.
18:02:28 <xplat> if getChar always returned 'a' (the 'a' you entered when you first sat at your keyboard on july 11, 2011), it would be pure but not very useful
18:02:41 <john_r_watson> ah... I'm starting to see what's going on
18:02:42 <john_r_watson> *LearnArrows Control.Arrow> :t runSF (arr id &&& arr tail)
18:02:42 <john_r_watson> runSF (arr id &&& arr tail) :: [[a]] -> [([a], [a])]
18:02:42 <john_r_watson> *LearnArrows Control.Arrow> :t runSF (arr id &&& delay 0)
18:02:45 <john_r_watson> runSF (arr id &&& delay 0) :: (Num a) => [a] -> [(a, a)]
18:02:56 <dibblego> who is saying my favourite Char is not very useful!?
18:04:03 <john_r_watson> I think (arr id) is probably not being seen as the right type (f -> g) rather than ([f] -> [g])
18:04:07 <lars9> xplat: when evaling unsafePerformIO, you record the time, do things, then evaluation is done, you travel back
18:04:43 <Eduard_Munteanu> Where? In 'a' in IO a -> a surely there's no place for that.
18:04:54 <azaq23> there is a self referential paradox in there somewhere, I know it
18:05:04 <azaq23> and a yo dawg
18:05:12 <Eduard_Munteanu> And a grandpa?
18:05:58 <xplat> not when i get through with him
18:06:23 <lars9> Eduard_Munteanu: 'a' is just a evaluation result, like tomorrow's weather:)
18:06:42 <mm_freak_> lars9: you can implement that without a time machine
18:07:02 <Eduard_Munteanu> Heck, I'm not convinced time travel is consistent, let alone something like unsafePerformIO :P
18:07:21 <EliasAmaral> Eduard_Munteanu, lol
18:08:10 <xplat> time travel seems to be *kind of* consistent in a quantum world, but that's all i'm about to say
18:08:22 <john_r_watson> my bad everyone
18:08:24 <EliasAmaral> I think the problem is, you might have two things to read, but a function that receives x as input must always return some y. so read_something () can't return two different things you typed
18:08:26 <john_r_watson> runSF (arr id &&& SF tail) [1..4] === [(1,2),(2,3),(3,4)]
18:08:43 <john_r_watson> tail already operates on lists... and I was doing (arr tail)
18:09:20 <EliasAmaral> what one could have is: the IO read receives a sequencing token that specifies the world, and returns what it reads plus a new token. if you call it again for the same token, it must return what it previously returned
18:09:25 <john_r_watson> > liftM2 zip id tail [1..4]
18:09:26 <lambdabot>   [(1,2),(2,3),(3,4)]
18:09:46 <lars9> EliasAmaral: unsafePerformIO is probably too scifi for humanbeing, but haskell itself IS pure in anyway.
18:09:57 <EliasAmaral> (but this has some nasty gc issue: you can't free what was read unless you also free this token)
18:10:16 <EliasAmaral> lars9, so haskell + unsafePerformIO *is* pure? now I'm completely confused
18:10:54 <xplat> as in, you can assign a clear meaning to what the result of time travel would be in the context of quantum reality, but theoretical-physics models of time machines have a marked tendency to self-destruct with probability 1 while you're building them
18:11:04 <lars9> language is pure, implementation varies
18:11:11 <EliasAmaral> my understanding is: if exists an expression whose evaluation forces a side-effect, then the language is not pure at all. if you remove all such expressions, the language is pure
18:11:36 <EliasAmaral> oh. so haskell 98 (or some other standard) does not define that unsafePerformIO does some kind of impure thing?
18:11:50 <Eduard_Munteanu> What if it does?
18:12:05 <c_wraith> haskell 98 doesn't define unsafePerformIO at all.  unsafePerformIO came out of the FFI addendum
18:12:09 <Eduard_Munteanu> unsafePerformIO is convenient for a number of things.
18:12:20 <EliasAmaral> oooh. right c_wraith
18:12:51 * hackagebot ad 0.46.0 - Automatic Differentiation  http://hackage.haskell.org/package/ad-0.46.0 (EdwardKmett)
18:12:55 <xplat> FFI is part of haskell2010 tho
18:13:39 <Eduard_Munteanu> Debug.Trace wouldn't be possible without unsafePerformIO, or some other language hack that allowed reconstucting it.
18:13:43 <Eduard_Munteanu> *reconstructing
18:15:52 * hackagebot ad 0.46.1 - Automatic Differentiation  http://hackage.haskell.org/package/ad-0.46.1 (EdwardKmett)
18:16:29 <EliasAmaral> Eduard_Munteanu, so tracing the program execution can be done in the program itself? I would imagine it would require a IO a -> IO a function that couldn't be implement in haskell (so one would have to implement it in a lower-level fashion)
18:16:46 <Eduard_Munteanu> :t trace
18:16:48 <lambdabot> Not in scope: `trace'
18:17:01 <Eduard_Munteanu> trace :: (Show a) => a -> b -> b   IIRC
18:17:14 <EliasAmaral> I think it can't be done in C too. Or C++. Or OCaml..
18:17:38 <Eduard_Munteanu> It works like 'seq' except it uses unsafePerformIO to print out something without actually being in the IO monad.
18:17:39 <EliasAmaral> oh it receives any value? so what it does? it prints something when (if) this value is evaluated?
18:17:47 <EliasAmaral> oh
18:17:53 <c_wraith> Eduard_Munteanu: that's traceShow.  trace is String -> a -> a
18:17:57 <EliasAmaral> hm got it
18:18:00 <Eduard_Munteanu> Ah.
18:18:16 <EliasAmaral> ooh, yes, this is definitely impure
18:18:22 <c_wraith> absolutely impure.
18:18:25 <c_wraith> But sometimes handy
18:18:28 <Eduard_Munteanu> But useful in certain scenarios.
18:18:45 <EliasAmaral> but anyway, this is the "debug with printf" style i'm currently stuck (because i'm such of a bad programmer and all)
18:18:54 <c_wraith> But you shouldn't expect to be able to use it to do all you're IO for you :)
18:19:04 <monochrom> ghci has a debugger too
18:19:26 <EliasAmaral> I was wondering if I could adapt myself. I guess Haskell will have to adapt for a while
18:19:51 <monochrom> but most importantly, decompose problem properly, build small functions, easy to see each one correct, easy to test each one. process trumps language.
18:20:01 <Eduard_Munteanu> Haskell debugging is certainly more difficult, even with what ghci has. Compare to gdb for instance.
18:20:14 <c_wraith> err, *your* IO
18:20:39 <lars9> EliasAmaral: IO a -> IO b?
18:20:50 <monochrom> then again haskell encourages that excellent process
18:21:07 <lars9> :t fmap (map words . lines) getContent
18:21:08 <lambdabot> Not in scope: `getContent'
18:21:22 <lars9> :t fmap words getLine
18:21:23 <lambdabot> IO [String]
18:21:24 <EliasAmaral> lars9, I said IO a -> IO a because it would be just like id, but printing what happens
18:21:37 <lars9> EliasAmaral: oh isee
18:21:58 <Eduard_Munteanu> :t liftM
18:22:00 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
18:22:06 <monochrom> So I wouldn't say debugging haskell is hard. gdb-style-debugging haskell is hard, sure. gdb-style-debugging means: what the hell, just doodle code then figure out what it even means.
18:22:12 <EliasAmaral> could also be String -> IO a -> IO a that just prints String and then runs IO a. but this is implementable in haskell
18:22:17 <lars9> trace's type has no IO though, but it uses an unsafePerformIO
18:22:24 <lars9> @src trace 
18:22:25 <lambdabot> Source not found. Maybe if you used more than just two fingers...
18:23:00 <lars9> http://haskell.org/ghc/docs/7.0.1/html/libraries/base-4.3.0.0/src/Debug-Trace.html#trace
18:23:11 <monochrom> debugging in haskell means each function is small and easy to test and easy to compose.
18:23:32 <lars9> trace string expr = unsafePerformIO $ do {putTraceMsg string; return expr;}
18:24:09 <Eduard_Munteanu> I could've used gdb-like 'watch'-es the other day.
18:24:16 <Eduard_Munteanu> On refs.
18:24:46 <bsmntbombdood> http://hpaste.org/42852/ugly
18:24:47 <monochrom> see? write something to the refs first, then ask gdb what you're writing
18:24:56 <bsmntbombdood> i know there's a better way to write that
18:26:34 <EliasAmaral> my problem usually is that I can't understand the program I just wrote, and having poor patience (or sometimes never finding relevant documentation) I need to see it working. so I learned to program in the debug-with-printf style. (there is also the test-your-function-at-the-repl, but it becomes hard when the result of the expression is not a member of Show)
18:27:33 <lars9> bsmntbombdood: what are Plus and expand?
18:28:27 <bsmntbombdood> lars9, expand :: Regex -> [String]
18:29:40 <EliasAmaral> actually, a simple question: is there a way to automatically build a Show instance for the type data A = A | B?
18:29:40 <lars9> so the result is like: [strs, strs++strs, strs++strs++strs...]?
18:30:05 <monochrom> data A = A | B deriving Show
18:30:13 <EliasAmaral> oh @.@
18:30:31 <bsmntbombdood> lars9, yeah (expand a) >>= (\strs -> what you said)
18:30:43 <EliasAmaral> nice, thank you @.@
18:31:05 <bsmntbombdood> except that >>= won't work, it's interleave . map instead of concat . map
18:32:00 <lars9> > 
18:32:01 <lambdabot>   not an expression: `'
18:32:09 <lars9> > take 10 $ iterate ("a"++) "a"
18:32:11 <lambdabot>   ["a","aa","aaa","aaaa","aaaaa","aaaaaa","aaaaaaa","aaaaaaaa","aaaaaaaaa","a...
18:32:18 <EliasAmaral> can I derive both Show and Read? deriving Read, Show is not working
18:32:24 <mauke> > iterate ('a' :) []
18:32:25 <lambdabot>   ["","a","aa","aaa","aaaa","aaaaa","aaaaaa","aaaaaaa","aaaaaaaa","aaaaaaaaa"...
18:32:28 <Eduard_Munteanu> EliasAmaral: you need parens
18:32:32 <lars9> bsmntbombdood: does it work?
18:32:35 <bsmntbombdood> no
18:32:38 <mauke> EliasAmaral: deriving (Read, Show, Eq, Ord)
18:32:38 <Eduard_Munteanu> Like deriving (Show, Read, Ord)
18:33:09 <Eduard_Munteanu> But it only works for a handful of classes.
18:33:12 <EliasAmaral> astonishing @_@
18:33:21 <bsmntbombdood> expand (parseRegex "(a|b)+")) => ["a", "b", "aa", "ab", "ba", "bb", "aaa",...]
18:33:25 <EliasAmaral> how can I specify a "deriving" for my own class?
18:33:30 <Eduard_Munteanu> (Except in newtypes when using GeneralizedNewtypeDeriving)
18:33:35 <Eduard_Munteanu> No.
18:33:38 <Eduard_Munteanu> ^
18:33:48 <EliasAmaral> I would expect something like template haskell
18:34:18 <Eduard_Munteanu> That might be doable. Also, there are extensions for some other typeclasses IIRC.
18:34:39 <EliasAmaral> ghc-specific extensions?
18:34:55 <mauke> Typeable
18:35:14 <Eduard_Munteanu> Yeah, as in non-standard. But some other compilers might implement them though.
18:35:22 <EliasAmaral> this is such a neat feature, could be in haskell 2012
18:35:23 <c_wraith> Data, Typeable, Functor all can be derived with GHC extensions.
18:35:55 <shachaf> Functor can be derived?
18:36:04 <c_wraith> in GHC 6.12+
18:36:38 <Eduard_Munteanu> Also in newtypes you can derive from *any* class with GeneralizedNewtypeDeriving.
18:36:58 <c_wraith> Functor is completely mechanical, after all.  There's only one correct implementation for anything with the correct kind.
18:37:18 <Eduard_Munteanu> Yeah, one that obeys functor laws.
18:37:26 <monochrom> newtype NT = NT NT deriving Show
18:37:30 <EliasAmaral> there is only one correct fmap for each type?
18:37:38 <monochrom> wait, that will work :)
18:38:06 <c_wraith> monochrom: yes.  You can even create one, with fix NT
18:38:25 <c_wraith> But it's bottom :)
18:38:53 <monochrom> newtype NT = NT NT deriving Exception
18:38:54 <lars9> > let l = "ab" in iterate (l>>) l
18:38:55 <lambdabot>   ["ab","abab","abababab","abababababababab","abababababababababababababababa...
18:38:56 <Eduard_Munteanu> Hm, does show deconstruct that lazily and output NT (NT (NT ....
18:38:57 <Eduard_Munteanu> ?
18:39:06 <lars9> bsmntbombdood: does it work?
18:39:28 <aavogt> @hackage derive EliasAmaral
18:39:28 <lambdabot> http://hackage.haskell.org/package/derive EliasAmaral
18:39:41 <c_wraith> Eduard_Munteanu: it's a newtype.  It can't be deconstructed lazily.  fix NT is bottom
18:39:47 <bsmntbombdood> lars9, no
18:39:49 <EliasAmaral> I see that if you define a type, you can look its structure, and you can write map just looking at it. for type T a, you just have to substitute all a's for f a whenever you find it. so this will be the sole correct implementation?
18:39:58 <Eduard_Munteanu> c_wraith: ah, so show won't work at all on it
18:40:06 <c_wraith> Eduard_Munteanu: correct
18:40:23 <EliasAmaral> "The tool requires GHC, but the generated code is portable to all compilers." , hm o.o
18:40:27 <c_wraith> well, actually, I'm not sure about it.
18:40:40 <c_wraith> Depends on the implementation of Show it derives
18:40:50 <EliasAmaral> what it means by 'generated code'? it will actually compile to a new .hs with all instances?
18:40:51 <c_wraith> If it outputs "NT " before examining its argument
18:40:55 <aavogt> EliasAmaral: it lets you specify the code generation as template haskell too
18:41:06 * edwardk waves hello
18:41:13 <EliasAmaral> uhm
18:41:15 <Eduard_Munteanu> o/
18:41:16 <EliasAmaral> hello edwardk
18:41:16 <aavogt> but it can also generate actual code separately
18:41:16 <c_wraith> Then the instance of show doesn't care that you passed it bottom
18:41:27 <c_wraith> edwardk: see you've been at work on ad
18:41:40 <edwardk> c_wraith: yeah, ported it to use the comonad package
18:41:57 <edwardk> it had previously had its own notion of a comonad for the streams returned by grads
18:42:16 <EliasAmaral> > let f undefined = 1 in (f undefined, f 5)
18:42:17 <lambdabot>   (1,1)
18:42:24 <EliasAmaral> why f 5 = 1?
18:42:40 <EliasAmaral> can't f distinguish between undefined and something else?
18:42:46 <monochrom> because of alpha equivalence
18:42:46 <c_wraith> you're assigning the name undefined to its argument
18:42:47 <edwardk> 'undefined' there is a variable name
18:43:00 <monochrom> "f undefined = 1" = "f x = 1"
18:43:04 <EliasAmaral> oh
18:43:14 <lars9> > let l = ["a", "b"] in iterate ((++) <$> l <*>) l
18:43:16 <lambdabot>   [["a","b"],["aa","ab","ba","bb"],["aaa","aab","aba","abb","baa","bab","bba"...
18:43:18 <edwardk> and no, you can't distinguish between undefined and something else
18:43:25 <EliasAmaral> oh, undefined is not a keyword, it is a value defined somewhere
18:43:29 <edwardk> trying to use undefined it blows up
18:43:33 <monochrom> the religion of meaningful identifiers is really damaging. people read too much into things.
18:43:40 <edwardk> undefined = error "undefined" basically ;)
18:43:57 <EliasAmaral> i supposed it was an special constructor, but even True and False isn't in haskell (they are uppercase; it seems no constructor in haskell is lowercase)
18:43:57 <conal> or undefined = undefined
18:44:15 <lars9> bsmntbombdood: this one is what you want?
18:44:17 <edwardk> well, it blows up with a nicer error than than =)
18:44:18 <conal> though edwardk's is more accurate w.r.t. error messages.
18:44:18 <edwardk> > undefined
18:44:20 <lambdabot>   *Exception: Prelude.undefined
18:44:23 <conal> yeah
18:44:38 <EliasAmaral> so I can't write a function that distinguish undefined and something else?
18:44:54 <edwardk> EliasAmaral: in spirit, that statement is true
18:45:08 <EliasAmaral> so _any_ undefined that pops up will halt the program? @.@ (can I catch this exception at least?)
18:45:12 <edwardk> (in practice there are some horrible runtime things to get at exceptions, but they have VERY few guarantees)
18:45:21 <Eduard_Munteanu> That would rather imply Haskell was total.
18:45:35 <conal> EliasAmaral: (== undefined) is undecidable
18:45:37 <edwardk> EliasAmaral: just don't try to use undefined values ;)
18:45:40 <Eduard_Munteanu> If 'undefined' wasn't a degenerate value.
18:45:41 <monochrom> some unsafePerformIO trick plus exception catching lets you detect some bottoms, but still not all.
18:46:06 <edwardk> eliasamaral: think of undefined as while (true) ;  ‚Äî you can't spot those in imperative code either ;)
18:46:10 <c_wraith> You can't catch an infinite loop, after all
18:46:24 <monochrom> except on April 1st
18:46:38 <c_wraith> well, of course
18:46:38 <EliasAmaral> conal, oh, I supposed that some "undefined" things were "special" (like undefined = error ".."), and others (like non-termination) were of "oh we have a turing problem" kind
18:46:41 <edwardk> here, you can get the compiler to realize it is spinning ts wheels some times
18:47:02 <EliasAmaral> so one could == for the "common" undefineds, but this maybe seems too ill
18:47:08 <c_wraith> > let xs = tail xs in xs
18:47:11 <edwardk> EliasAmaral: if you want to handle errors, work in the Maybe or Either monad, and handle the error with catch in the latter case
18:47:12 <lambdabot>   mueval-core: Time limit exceeded
18:47:21 <conal> EliasAmaral: yep. though denotationally all of these values are equal.
18:47:26 <c_wraith> Err.  In compiled code, that would lead to dumping <<loop>>
18:47:36 <c_wraith> ...  in the single-threaded runtime
18:47:43 <Eduard_Munteanu> conal: btw, is there a good intro online to denotational semantics?
18:47:51 <EliasAmaral> so exceptions / non-local control mechanisms aren't actually used in haskell?
18:47:56 <conal> Eduard_Munteanu: don't know.  sry. :(
18:48:10 <Eduard_Munteanu> But I thought they were your favorite thing... :P
18:48:18 <EliasAmaral> when I see some exceptions in haskell, i would think they are actually used in code. but I never saw any "try .." in haskell code
18:48:21 <conal> Eduard_Munteanu: it is my favorite thing.
18:48:28 <monochrom> conal learned it offline, not online
18:48:36 <Eduard_Munteanu> Makes sense.
18:48:38 <c_wraith> Eduard_Munteanu: the wikibooks page on denotational semantics is actually decent
18:48:49 <edwardk> EliasAmaral: the general behavior of exceptions is to fail fast and hard in almost all haskell code
18:49:11 <Eduard_Munteanu> I'll have a look, thanks.
18:49:14 <c_wraith> http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
18:49:20 <edwardk> lazy evaluation generally doesn't do what you want with respect to _when_ said exceptions occur.
18:49:54 <edwardk> you can have IO actions through exceptions and usually do something meaningful, but trying to throw them in pure code and DO anything about it is a trickier proposition than most folks have stomach for
18:49:57 <monochrom> we use exceptions when in IO. makes sense there.
18:50:10 <edwardk> er s/through/throw
18:50:37 <edwardk> in practice. you're usually in IO or you're able to lift yourself into a monad to handle the errors you want to handle
18:50:47 <EliasAmaral> so haskell code is supposed to be exceptionless, and define all exceptional behavior explictly (like, tagging the value with a constructor that also lets you handle exceptional cases; or maybe using some structure to separate "non-exceptional" code from errors?)
18:51:36 <c_wraith> EliasAmaral: In pure code, you tend to use error to indicate programmer errors, and Maybe or Either to handle expected error conditions
18:52:12 <Eduard_Munteanu> 'Maybe' is nice when you have a chain of computations that can fail.
18:53:17 <edwardk> EliasAmaral: in general, yeah
18:53:37 <EliasAmaral> when I do code like this, I tend to pattern match whenever I want the value. this clutters the code a lot
18:54:03 <edwardk> EliasAmaral: you can move into a monad, like Either, and use combinators to hide the error cases from you
18:54:23 <c_wraith> You're about to invent Monads by yourself :)
18:54:39 <EliasAmaral> uhm. I also see that combinators can help me avoid passing state as a parameter for all my "functional" functions
18:54:40 <c_wraith> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
18:54:53 <edwardk> yep
18:54:56 <Eduard_Munteanu> Or you can use the MaybeT transformer.
18:54:57 <EliasAmaral> since I don't know how to use those things, my "functional" code is just a mess
18:55:15 <edwardk> and then you can combine them with monad transformers to get one function that has both of those things
18:55:37 <edwardk> and you can set up a consistent way that you want to do that over a large body of code, think of a monad as factoring out those concerns
18:55:42 <EliasAmaral> monad transformers - things at Control.Monad that normal people can't understand?
18:55:52 <aristid> @hoogle foldrM
18:55:52 <lambdabot> Data.Foldable foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
18:55:54 <monochrom> haha
18:56:16 <EvanR> dont use transformers
18:56:19 <c_wraith> EliasAmaral: actually, I understood monad transformers before I really understood monads.  They're simpler, in some ways.
18:56:39 <EvanR> they eat babies
18:56:55 <Eduard_Munteanu> My gripe with transformers is they still don't eliminate the need to 'lift' functions.
18:56:59 <edwardk> each monad transformer corresponds to a kind of simple code refactoring you would tend to do with your code
18:57:18 <EvanR> Eduard_Munteanu: sometimes they do, but only because of a giant system of moving parts ;)
18:57:24 <EvanR> MonadIO
18:57:28 <EvanR> for instance
18:57:29 <c_wraith> Eduard_Munteanu: actually, they introduce the need to lift functions :)
18:57:46 <c_wraith> err,  actually, I guess the lift values
18:57:49 <c_wraith> *they
18:58:09 <Eduard_Munteanu> I mean, RWS vs ReaderT + WriterT + StateT + Identity.
18:58:29 <EliasAmaral> I once decided: my program will be all-functional. except for a very small part that does io. (It was an ocaml program). It was very ugly. my biggest problem was how to pass state. So almost all my functions really received state as first parameter and returned state * actual_value. Since the state each function could touch was slightly different, the program was a mess
18:58:49 <EliasAmaral> in the end I got nowhere and replaced this with a global mutable variable. end of story
18:58:52 <dabblego> EliasAmaral, this is called "the state monad"
18:58:58 <edwardk> EliasAmaral: yes, but if you refactor it into the state monad, that goes away
18:59:07 <dabblego> EliasAmaral, you can handle all that without explicitly passing the state around 
18:59:08 <EliasAmaral> oh, this is very interesting
18:59:20 <monochrom> you could do it in ocaml too
18:59:22 <edwardk> a state monad looks like s -> (a, s) (plus some newtype noise and combinators for putting them togehter)
18:59:37 <edwardk> thats 'taking some state, and returning the value and the new state'
19:00:02 <edwardk> for that monad return a = State (\s -> (a, s)
19:00:15 <edwardk> just ignores the state and passes it through unchanged. and >>= threads the state
19:00:16 <monochrom> see http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm
19:00:28 <EliasAmaral> seeing
19:00:41 <Eduard_Munteanu> ... is believing.
19:00:46 <monochrom> though it's kind of speaking in old haskell
19:00:56 <EliasAmaral> I want to implement a program that does this: reads a polynomial like 2x+1, simplify, and pretty-print. This does not require state. but I want to do something like defining x = 1. and then 2x+1 is really 3. this requires state
19:01:21 <EliasAmaral> edwardk, @.@ hm
19:01:41 <Eduard_Munteanu> EliasAmaral: not really.
19:02:07 <EvanR> EliasAmaral: yeah, dont use imperative programming to write that
19:02:12 <EliasAmaral> i mean. it might not require state in the interpreter
19:02:23 <EliasAmaral> but it is observable state for the user of the program
19:02:30 <EvanR> you want to evaluate an expression given some environment of variable bindings
19:02:39 <edwardk> you can define a parser that returns an abstract syntax tree, and then an interpreter that can evaluate the AST given some state (like a mapping of names to values)
19:02:39 <EvanR> the i/o part is something else
19:02:43 <EliasAmaral> I can use implicit state passing it as parameter; or I can use a state monad
19:03:09 <EvanR> if evaluation cant change the environment, then State is inappropriate
19:03:13 <EliasAmaral> EvanR, yeah, that is my strategy at my head: receiving the env as parameter. But I also described how this strategy failed badly
19:03:19 <edwardk> eval :: Expr -> State Env Int
19:03:30 <edwardk> gives you the equivalent of eval :: Expr -> Env -> (Int, Env)
19:03:33 <Eduard_Munteanu> 'Reader' is better for just passing environment.
19:03:37 <EvanR> its a language where evaluating expressions causes side effects :(
19:03:47 <edwardk> Eduard_Munteanu: true, i was modeling a language with mutation
19:04:06 <EliasAmaral> hmm. I'm unsure if there will really be a expression that can change environment. I think I might say there is two kind of things you can write: expressions, and statements, the latter can change state
19:04:57 <EliasAmaral> but I also like the "every fragment you can type at the interpreter is an expression and has a value"
19:05:16 <edwardk> then you may want eval :: Expr -> Reader Env Int ‚Äî which is equivalent to eval :: Expr -> Env -> Int
19:05:21 <EliasAmaral> (from scheme)
19:05:28 <edwardk> but then portions of the evaluator that don't care about the environment can just ignore it
19:06:07 <EliasAmaral> wait, Expr -> Reader Env Int does not receive Env as parameter, but somehow is equivalent as receiving it?
19:06:24 <edwardk> Reader Env Int ‚Äî looks like newtype Reader e a = Reader (e -> a)
19:06:24 <EliasAmaral> it returns something that will need and Env to return an Int?
19:07:58 <EliasAmaral> edwardk, newtype Reader e a = Reader (e -> a)? Reader is * -> * -> * or * -> *?
19:08:13 <EliasAmaral> :k Reader
19:08:14 <lambdabot> * -> * -> *
19:08:16 <dmwit> yes, and * -> * -> *
19:08:28 <edwardk> reader as a monad is pretty straightforward: return a = Reader (\_ -> a)    Reader r >>= f = Reader (\e -> f (r e) e)
19:08:38 <edwardk> * -> * -> *
19:08:51 <EliasAmaral> edwardk, you mean (Reader a) is a monad?
19:08:54 <edwardk> reader takes two type arguments, the type of the 'environment' and the type of the result
19:08:57 <edwardk> yes
19:09:21 <edwardk> (in fact ((->) a) is the same monad, but that is a little more brain bending
19:09:26 <EliasAmaral> return a will ignore the environment?
19:09:30 <edwardk> yep
19:09:46 <edwardk> and >>= will thread the environment through to both
19:10:25 <edwardk> and then you can use 'ask' which is Reader id  ‚Äî to just ask for the environment
19:10:31 <EliasAmaral> ((->) a)? I know what I lack, a good haskell book..
19:10:50 <edwardk> (->) a can be read as the type of functions, partially applied.
19:10:51 <EliasAmaral> not real world, but maybe darkness underworld
19:11:08 <edwardk> (a -> ) ‚Äî f you could write a type-level 'section' of the arrow type
19:11:25 <edwardk> (->) Int Bool = Int -> Bool
19:11:43 <EliasAmaral> yes, I kind of understood this when I followed some haskell exercises that asked me to build functor and monad instances
19:12:39 <edwardk> so in Control.Monad.Instances IIRC there is an instance that looks like instance Monad ((->) e) where return a e = a; f >>= r = \e -> f (r e) e
19:13:00 <edwardk> er i probably got that backwards on >>=
19:13:06 <EliasAmaral> or no, I haven't understood, but ((->) a) I see like an analogy to \x -> x -> a, that is, ((->) a) b is b -> a
19:13:10 <edwardk> r >>= f = \e -> f (r e) e
19:13:18 <edwardk> wrong side
19:13:35 <edwardk> (+) 1 2 = (1 + 2)
19:13:47 <edwardk> what youre thinking of would be (-> a)
19:13:54 <edwardk> (->) makes it prefix
19:13:58 <EliasAmaral> oh
19:14:12 <EliasAmaral> so ((->) a) b is a -> b
19:14:22 <edwardk> (and technically you can't 'section' an arrow so (a ->) and (-> a) aren't legal syntax but (a -> b) and ((->) a b) are
19:14:24 <EliasAmaral> :k (-> a)
19:14:25 <lambdabot> parse error on input `a'
19:14:26 <edwardk> yep
19:14:36 <edwardk> :k (->)
19:14:37 <lambdabot> ?? -> ? -> *
19:14:46 <edwardk> :k ((->) a)
19:14:48 <lambdabot> Not in scope: type variable `a'
19:14:53 <EliasAmaral> oh, so how to reverse a higher kind type?
19:14:57 <edwardk> :k ((->) Int)
19:14:58 <lambdabot> ? -> *
19:15:24 <edwardk> type Flip f a b = f b a ‚Äî but you can't partially apply Flip
19:15:27 <Eduard_Munteanu> BTW, what's the thing with '?' and '??' ?
19:15:29 <edwardk> that is important
19:15:45 <EliasAmaral> Eduard_Munteanu, maybe something to do with strictness?
19:15:48 <edwardk> those are to allowed unboxed values or tuples in certain locations even with the usual arrows
19:16:03 * azaq23 thinks the function monad's (>>=) and why that's the implementation of Reader is imho easier to understand if you consider to applications, x >>= y >>= z == z (y (x r) r) r
19:16:10 <EliasAmaral> edwardk, won't (Flip A) work?
19:16:14 <edwardk> -> is a little big magical. the ?? says you're allowed to pass it unboxed types
19:16:42 <edwardk> EliasAmaral: nope. you're not allowed to partially apply type aliases. you can partially apply _data_ and _newtype_s though
19:16:44 <Eduard_Munteanu> So '??' can be instantiated to either '#' or '*'?
19:16:51 <EliasAmaral> azaq23, where you got this r?
19:17:07 <edwardk> Eduard_Munteanu: yeah and ? allows unboxed tuples as well
19:17:16 <azaq23> EliasMaral: sorry, would have to be \r -> x (y (z r) r) r)
19:17:18 <Eduard_Munteanu> Ah, thanks.
19:17:39 <azaq23> EliasAmaral since the last type is m b == (a -> b)
19:18:08 <EliasAmaral> azaq23, oh, this definition was for ((->) a) monad?
19:18:11 <azaq23> EliasAmaral named it r since that's whats used in the implementation source file
19:18:15 <edwardk> EliasAmaral: that is the tiny bit of subtyping at the kind level =)
19:18:15 <azaq23> @src (->) (>>=)
19:18:16 <lambdabot> f >>= k = \ r -> k (f r) r
19:18:22 <edwardk> er eduard
19:18:36 <Maxdamantus> @pl \(a,b) -> (a, f b)
19:18:36 <lambdabot> second f
19:18:46 <azaq23> EliasAmaral yes
19:19:15 <Eduard_Munteanu> It does make me wonder how much typeclasses subsume subtyping mechanisms.
19:19:34 <edwardk> Eduard_Munteanu: different but slightly overlapping problem domains
19:19:41 <Eduard_Munteanu> (I don't think too much since that would make Haskell a CoC language, right?)
19:19:43 <EliasAmaral> edwardk, I'm confused on why this restriction on Flip applies. doesn't this prevent some code to be written?
19:19:58 <edwardk> EliasAmaral: yes, but it is important because otherwise typeclasses couldn't exist
19:20:13 <EliasAmaral> why?
19:20:50 <edwardk> if i have instance Monad (Flip Either a) and instance Monad (Either a) ‚Äî and Flip was a type level function like that, which applies?
19:21:37 <edwardk> you can make a data type or newtype out of Flip and it then has some 'residue', but Flip (->) a b = b -> a
19:21:49 <edwardk> if you just define it as a type alias
19:22:40 <edwardk> scala has 'impliciits' that permit those kinds of crazy type level functions, but as a result, they can't infer them all the time, and they provide no confluence guarantees
19:22:47 * EliasAmaral confused.
19:23:07 <edwardk> say you have instance Num Int lying around, like we do
19:23:11 <edwardk> if you define type Nat = Int
19:23:13 <EliasAmaral> I think Either a would override, but I haven't understood the issue fully
19:23:17 <EliasAmaral> hm
19:23:34 <edwardk> then you can use +, etc. on your Nats, because they are really just Ints, with a convenient alias given to you so you can write out the other name instead
19:23:45 <Eduard_Munteanu> Type synonyms aren't anything else than preprocessing, right?
19:23:55 <edwardk> if you said newtype Nat = Nat Int ‚Äî you're making a wrapper, now you can't just use the addition for Int's you have to define every operation yourself
19:23:57 <edwardk> correct
19:24:15 <Eduard_Munteanu> E.g. they could very well be implemented in something CPP-like.
19:24:54 <edwardk> data types actually manifest themselves in the form of a thunk, functions do, types and newtypes have no runtime manifestation
19:25:06 <EliasAmaral> btw, I saw some #ifdefs and such in haskell code. it seemed crazy. (Like CPP checks for hugs or ghc or ..)
19:25:19 <edwardk> newtypes require you to use fake constructors/destructors to put them on and take them off, but those are cues to the system that the types are changing
19:25:31 <edwardk> but types don't even require that
19:27:16 <edwardk> data Nat = Nat Int ‚Äî defines a 'box' around an int, newtype Nat = Nat Int ‚Äî has the same runtime performance profile as a Int, the newtype is syntactic noise to help the compiler figure out what typeclass instances to supply, and type Nat is purely sugar for you, and lets you use the Int it wraps directly as an Int without having to do any work
19:27:56 <azaq23> EliasAmaral You can compile / run with -XCPP / {-# LANGUAGE CPP #-}, getting c preprocessor functionality
19:27:57 <edwardk> newtype Flip f a b = Flip (f a b) ‚Äî would let you define a new Monad for Flip Either a
19:28:08 <EliasAmaral> .
19:28:13 <EliasAmaral> ops
19:28:36 <Eduard_Munteanu> edwardk: does that work?
19:28:42 <edwardk> you'll get the hang of it
19:28:47 <edwardk> Edu_: the newtype?
19:28:48 <edwardk> sure
19:28:49 <Eduard_Munteanu> Yes.
19:28:54 <edwardk> er
19:29:00 <edwardk> newtype Flip f a b = Flip (f b a)
19:29:04 <edwardk> is probably more flippy =)
19:29:28 <Eduard_Munteanu> Yeah, I didn't mean that, I was concerned there was some restriction on newtype.
19:29:33 <edwardk> you'd have to take the resulting value and remove the Flip constructor at the end
19:29:37 <EliasAmaral> azaq23, I don't see the need for c processor. I would expect something like template haskell (but I never used it). or maybe TH is too complex
19:29:38 * azaq23 notes you can also do type T t = t, using T as some sort of marking wrapper for any real type T - though you can't use class constraints
19:29:58 <edwardk> but no, newtype is just constrained to contain one value of kind *
19:30:08 <edwardk> f b a compiles
19:30:19 <Eduard_Munteanu> Ah, makes sense.
19:30:31 <edwardk> (actually i'm not sure about the * restriction off hand)
19:30:54 <Eduard_Munteanu> So you can give it how many params you want and of any kind, but it must contain a single '*' and only that.
19:30:57 <edwardk> yeah
19:30:58 <azaq23> EliasAmaral: GHC uses cpp pretty extensively to check for different compiler implementations, like #ifdef __HUGS__
19:31:17 <edwardk> you can even use universal quantiification in a newtype
19:31:23 <EliasAmaral> I saw this at the "source" link at haddock
19:31:31 <edwardk> newtype Codensity f a = Codensity (forall r. (a -> r) -> r)
19:31:36 <Eduard_Munteanu> edwardk: not existentials though, I remember trying.
19:31:48 <edwardk> er newtype Codensity f a = Codensity (forall r. (a -> f r) -> f r)
19:31:52 <edwardk> yeah
19:32:04 <edwardk> existentials require a thunk in ghc at present
19:32:09 <EliasAmaral> azaq23, does GHC runs the entire CPP? like a ## b
19:32:16 <edwardk> technically the world could probably be extended to remove that requirement
19:32:24 <Eduard_Munteanu> EliasAmaral: it really runs gcc's CPP.
19:32:42 <edwardk> EliasAmaral: iirc it has its own, because of minor syntactic differences
19:32:49 <edwardk> involving haskell string literals
19:33:01 <Eduard_Munteanu> Oh, my bad then.
19:33:06 <edwardk> and the ability to have ''s in variable nams
19:33:57 <edwardk> there is some minor hullabaloo every couple of years when folks realize that the cpp implementation is gpl'd or something, and then it dies down
19:34:21 <edwardk> EliasAmaral: but it can handle that case
19:34:27 <EliasAmaral> i see lots of people talking badly about c macro facilities. (mostly in comparison to lisp. but i think I can see why some lisp macro system isn't suitable)
19:34:52 <edwardk> EliasAmaral: we also have 'template haskell' which provides a more principled way to do code generation
19:34:57 <Eduard_Munteanu> CPP saved me from lots of situations when writing C code.
19:35:20 <edwardk> in fact, its been hijacked to do some incredibly cool things.
19:35:47 <Eduard_Munteanu> Yeah, I came to appreciate the magic you can do with CPP.
19:35:56 <edwardk> EliasAmaral: http://www.haskell.org/haskellwiki/Jmacro is an example of what you can do with template haskell
19:36:24 <edwardk> everything between the [$jmacro|  and the |] in the examples there is parsed and converted into haskell code at compile time
19:36:36 <EliasAmaral> maybe the criticism is more related to #define's needing extra parenthesis, or { }, or evaluating something twice, etc; all those things wouldn't apply for #ifdef use
19:36:56 <edwardk> well, the biggest problem with c macros is the lack of hygiene
19:37:11 <edwardk> i can live with everything else.
19:37:22 <ivanm> edwardk: why, don't they keep themselves clean? :p
19:37:23 <edwardk> i only really use them when i want to abuse that lack of hygiene
19:38:32 <sbahra> EliasAmaral: http://uebb.cs.tu-berlin.de/harpy/
19:38:56 <azaq23> #define f(x) do { x; x } while(0); f(++i) <-- opps
19:39:58 <azaq23> okay that's actually right my bad but since you can paste anything into that things can break in interesting ways
19:40:16 <EliasAmaral> so template haskell can do things. why GHC prefers CPP? (my guess: it is simpler. if yes, shame on TH)
19:40:44 <sbahra> TH can do much more than CPP.
19:41:08 <c_wraith> there are a couple things you can't do with TH.  Mostly involving conditional code, based on the compiler in use, or compile-time flags
19:41:11 <EliasAmaral> yes, but if it can do simpler things equally well, the resulting code could be nicer. or not
19:41:55 <edwardk> EliasAmaral: CPP is used as a preprocess to guard because all compilers that aren't GHC can't handle template haskell
19:42:13 <edwardk> so parts of the prelude/base that are shared by other compilers check for GHC that way
19:42:50 <edwardk> template haskell is hard for a compiler implementor to get right
19:43:15 <EliasAmaral> isn't TH a pre-processor that transforms a TH program into an equivalent haskell program?
19:43:23 <dolio> CPP may well be easier if all you want is to paste things into your file with holes filled in.
19:43:25 <c_wraith> TH also can't do conditional imports.  That's a weakness
19:43:39 <edwardk> EliasAmaral: no. because the quasiquoted fragments are typechecked
19:43:53 <edwardk> EliasAmaral: so template haskell expansion and typechecking are interleaved
19:44:05 <edwardk> kind of like hygienic macro expansion in the scheme world
19:44:22 <edwardk> c_wraith: very true
19:44:45 <mgsloan> join #xmonad
19:44:51 <mgsloan> erp
19:44:57 <EliasAmaral> so GHC itself proves that when your domain is too messy, it might as well be better to use an untyped language to escape the nightmares you could reasonably have in the following nights (for months)
19:45:03 <edwardk> also since TH is in a library and GHC proceeds somewhat apace, there are occasional gaps in the coverage of TH. for instance for a while it was missing data families, etc.
19:45:27 <Gilberto> Hello.
19:45:37 <c_wraith> Generally, I use TH when I (a) need to, and (b) can.  CPP is for the things TH can't cover, for whatever reason.
19:45:42 <EliasAmaral> let's rewrite everything into sh
19:45:56 <edwardk> EliasAmaral: TH is sort of an exercise in exploring what a typed preprocessor would look like. its kind of a pain in the ass to use, but its nice in that you can typecheck that what you are writing makes sense.
19:46:40 <azaq23> Gilberto hi
19:46:45 <edwardk> and parts of TH are finding very powerful uses, like the quasiquotation machinery is being used for 'deep' domain specific languages.
19:47:19 <edwardk> (like the jmacro stuff i linked to)
19:47:49 <edwardk> i even tend to prototype compilers by writing them first as template haskell quasiquoters that compile the expression to haskell
19:48:25 <edwardk> since for the most part i use TH to hook into parsing and to reify the data types into expressions
19:48:47 <megajosh2> Does anybody know of a regex replacement algorithm that uses Bytestrings?
19:48:53 <EliasAmaral> uhm. @.@
19:49:02 <megajosh2> I tried to adapt the one in regex-compat but I don't know what I'm doing enough
19:49:05 <mauke> the existing algorithms work just fine on bytestrings
19:49:15 <gwern> http://www.google.com/search?num=100&q=bytestring%20regex
19:49:15 <megajosh2> It uses String instead of ByteString
19:49:21 <mauke> finite automata, etc
19:49:24 <megajosh2> I didn't want to do a bunch of unpacking and repacking
19:50:43 <EliasAmaral> megajosh2, can't you use attoparsec?
19:51:40 <megajosh2> Never heard of it
19:51:46 <EliasAmaral> you said that and I remembered this lua thing http://www.inf.puc-rio.br/~roberto/lpeg/lpeg.html that was pushed as a regex-replacing library, but more powerful. now I know a bit of haskell, this library looks like a parser combinator library
19:51:50 <megajosh2> I'll take a look
19:52:32 <EliasAmaral> (you build parsers using an expression, like, a + b is the parser that matches a or b)
19:54:51 <EliasAmaral> megajosh2, it's like parsec, but on bytestrings, and people say it's faster too. it can parse a lot of languages that regexes can't hope to parse. (disclosure: i never made those things to work, all too complex for me .-.)
19:55:32 <EliasAmaral> (but I remember I struggled a lot to make sed work too)
19:56:17 <megajosh2> I'll have to convert regular expressions to this parser; hopefully it won't be too hard
19:57:00 <lars9> @hoogle when
19:57:01 <EliasAmaral> what do you need to do? substitution, returning the n-th () group?
19:57:01 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
19:57:05 <lars9> @hoogle unless
19:57:05 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
19:57:37 <megajosh2> Well, I can show an example of some of the expressions I need to adapt
19:58:40 <megajosh2> "/&(b|i|s|u|sub|sup|code|ul|ol|li|p|bcode)\t/" to "<\\1>" is a simpler one
19:58:49 <megajosh2> Then they get more complicated like this
19:59:08 <megajosh2> "/&a\t(.*)\t(.*)\t(.*)&\\/a\t/U" to "<a href=\"\\1\" title=\"\\2\">\\3</a>"
19:59:12 <megajosh2> These are PCRE compatible
19:59:22 * hackagebot data-reify 0.6 - Reify a recursive data structure into an explicit graph.  http://hackage.haskell.org/package/data-reify-0.6 (AndyGill)
19:59:31 <megajosh2> It's from some old PHP code
19:59:57 <EliasAmaral> a parser in a parser combinator library is a value t; you then get a function that receives a bytestring, your parser, and return the data structure your parser built (it could be some arbitrary thing; a list if your parser is actually a lexer; a tree; or, in your case, a new bytestring)
20:00:23 <tolkad> When you derive Enum, what is the starting index?
20:00:33 <megajosh2> Hmmm
20:00:33 <mauke> TIAS?
20:00:52 <tolkad> nevermind I'll just go test it
20:01:26 <tolkad> oh, 0, good
20:01:31 <edwardk> yay andy! ad can compile again =)
20:02:59 <EliasAmaral> last semester I had an illuminating class called 'computer theory' where I had to translate regular expressions to regular grammars and vice-versa (also to automatons, those things..). I forgot the exact algorithm but those things are fascinating. *_*)
20:07:46 <EliasAmaral> megajosh2, I'm not sure if all features of PCRE has 1:1 correspondence to something already defined at attoparsec. maybe you would need to implement by yourself a lot of things. so if you aren't comfortable with parser combinators it won't be very productive..
20:08:32 <EliasAmaral> but I find complex regexes hard to tweak, they are a mini-language inside a string that you usually can't structure in a way that one can make sense..
20:12:45 <azaq231> EliasAmaral just because I instantly thought of it after your sentence, this article about ways to implement regexs was pretty popular some time ago http://swtch.com/~rsc/regexp/regexp1.html
20:13:57 <EliasAmaral> 'some time ago'?
20:15:01 <EliasAmaral> the Thompson NFA handles a 100-character string in under 200 microseconds, while Perl would require over 1015 years. 
20:15:05 <EliasAmaral> is this still true?
20:15:12 <EliasAmaral> (that is 10^15 years)
20:15:52 <EliasAmaral> i'm not sure why you say 'some time ago'. so perl fixed that?
20:16:01 <EliasAmaral> or this thompson ultra-fast thing got dated?
20:16:25 <megajosh2> That doesn't make any sense at all
20:16:43 <EliasAmaral> what?
20:17:08 <megajosh2> A single match that grabs 100 characters taking eons
20:17:28 <EliasAmaral> yeah, i have saw those pathological cases
20:17:35 <EliasAmaral> The regular expression implementations used by today's popular tools are significantly slower than the ones used in many of those thirty-year-old Unix tools. <- btw, I remember that _a lot_ of algorithms I learned (and soon forgot :) on that class was _incredible slow_
20:17:41 <azaq231> EliasAmaral: I just meant literally that the article was popular some time ago (on reddit) and I saw it back then, that wasn't a comment about the state of perl or so
20:18:30 <EliasAmaral> oh
20:19:24 <edwardk> EliasAmaral: the perl guys got around to optimizing some of the obvious cases that thompson was a win
20:19:33 <EliasAmaral> (in fact a lot of transformations were done simply to wipe out non-termination from some a brute force algorithm, and it made the grammars much larger..)
20:20:05 <EliasAmaral> edwardk, so they weren't convinced by the thompson approach at all? and just fixed their old code a little..
20:20:37 <edwardk> EliasAmaral: the thompson stuff can do very few of the extensions that the perl guys use
20:20:49 <edwardk> its better asymptotics for a smaller class of expressions
20:20:57 <edwardk> when it applies, its great
20:22:21 <EliasAmaral> oh, the thompson stuff applies only to regular grammars?
20:22:30 <edwardk> yeah
20:22:44 <xplat> it works because it assumes the grammar is regular
20:23:01 <edwardk> plus there are some differences in the choice of match in some cases (which is arguably more correct, but a change that breaks some usecases)
20:23:02 <EliasAmaral> i think i have saw the bad performance of embedding \1
20:23:43 <edwardk> my parallel regex code is all pretty much stock thompson and has no hope of every supporting PCRE style regexes
20:23:50 <EliasAmaral> (but regular expressions with \1 aren't really regular)
20:23:56 <edwardk> exactly
20:24:05 <xplat> also, if you allow intersections (and lookahead counts as intersections) or complements (negative lookahead counts as complementation) a DFA can be double exponential in the size of a regex, so even constructing it as you go might not be good enough to fit it in memory
20:24:06 <edwardk> since you can use them to recognize primes ;)
20:24:55 <EliasAmaral> edwardk, now that's a feat o.o
20:24:55 <edwardk> xplat: you can work around that in some cases (especially in parsers) if your language is a VPL.
20:24:56 <xplat> yeah, backreferences are actually the most potentially-expensive regex extension other than embedded code
20:25:27 <edwardk> EliasAmaral: /^1?$|^(11+?)\1+$/
20:26:19 <EliasAmaral> "Perl (and the other languages) could not now remove backreference support, of course, but they could employ much faster algorithms when presented with regular expressions that don't have backreferences, like the ones considered above. This article is about those faster algorithms." <- so maybe what perl did was to use a better algorithm if the language is regular
20:26:23 <xplat> with backreferences recognition is already NP-complete iirc
20:27:53 <xplat> it's interesting, i ran into that exact same article maybe a week ago, even though it's old
20:27:54 <edwardk> is there an efficient work-stealing deque lying around on hackage somewhere?
20:30:34 <Eduard_Munteanu> BTW, what should I use for regexes in Haskell these days?
20:32:27 <monochrom> I use what's in haskell platform.
20:34:19 <Eduard_Munteanu> Ah, so regex-{base,posix,...} should be good enough.
20:35:03 <Eduard_Munteanu> I'm considering using it to extract some info from HTML pages, a parser might be too much.
20:36:46 <EliasAmaral> Eduard_Munteanu, don't do that. html isn't regular. (I speak for experience. I used to parse google ill-formated html with sed..)
20:40:15 <EliasAmaral> I did this: "tokenized" it substituting < for a bunch of newlines, and then matched against something like "^a href=..". I then saw that at nokogiri.org front page, there is such parser in literally 3 lines of code (or 6 if you count warmup, or 26 for all 3 different ways to do it plus comments)
20:40:47 <EliasAmaral> I don't know the haskell way for doing that, but a real parser can't be considered too much..
20:44:40 <tolkad> if you use an extension using a LANGUAGE pragma should you also put it in your .cabal?
20:50:54 <ivanm> tolkad: theoretically, yes
20:51:26 <ivanm> what dcoutts, etc. are hoping for IIRC is that the LANGUAGE pragma up the top is utilised by ghc, etc. and the cabal listing is to be able to search for who uses that extension, which extensions you use, etc.
20:52:03 <Eduard_Munteanu> EliasAmaral: well this is just a single website, which probably has some code that generates the HTML.
20:52:09 <aavogt> it's redundant though
20:52:19 <Eduard_Munteanu> So I guess it's regular unless somebody explicitly changes stuff there.
20:52:36 <Philippa_> ivanm: not to mention check whether your compiler's compatible with the package without trying to compile?
20:52:43 <ivanm> Philippa_: right
20:52:54 <aavogt> and if you put it in your .cabal, ghc will compile with those flags added, so maybe the ones in the actual file will become out of date
20:52:57 <ivanm> aavogt: one is for actual compilation; the other is for metadata
20:53:00 <ivanm> (ideally)
20:53:12 <aavogt> ivanm: there are separate entries?
20:53:32 <ivanm> aavogt: the LANGUAGE pragmas vs the listing in the .cabal file
20:53:52 <ivanm> I'm going off a recollection of a discussion I had with dcoutts (at least I _think_ it was him...)
20:53:58 <tolkad> ivanm: it seems like if you put it in the .cabal it enables it everywhere
20:54:17 <ivanm> tolkad: right, which in some cases can be bad (i.e. you don't want an extension enabled on a particular module)
20:54:28 <ivanm> but cabal is currently very dumb wrt calling ghc
20:54:30 <tolkad> ivanm: like UndecidableInstances
20:54:35 <ivanm> yeah
20:54:50 <aavogt> ivanm: if you want a listing of which extensions are in use, that's easy enough to grab if the file parses with haskell-src-exts
20:54:55 <EliasAmaral> Eduard_Munteanu, by regular I meant in the computer science sense. you can't match nested <'s and >'s with regexes; you can't parse nested comments with regexes; etc. so, your regex parser will be very weak, and won't actually recognize html, but a subset that resembles it (even though backtracking regexes aren't really regular, I think you can't parse HTML with them too)
20:55:03 <ivanm> aavogt: not all do
20:55:11 <ivanm> but yes, ideally something like that would be automated
20:55:58 <Eduard_Munteanu> EliasAmaral: yeah, I know. I only intend to extract data in some tags. I do have some assumptions, like "that thing only appears once in the whole file".
20:56:05 <tolkad> ivanm: why wouldn't they parse? use of CPP?
20:56:16 <EliasAmaral> also, writing regexes for parsing html is very complicated, even in the simplest cases. some DOM-aware library (like that nokogiri for ruby), most html algorithms are actually simpler
20:56:20 <ivanm> tolkad: that, and hsx is stricter than ghc
20:56:26 <EliasAmaral> hmm. even that, regex seems error-prone. ._.
20:56:37 <ivanm> also things like fixity/associativity of non-standard operators can cause parsing problems
20:57:23 <Eduard_Munteanu> EliasAmaral: it's something like "get what's between <p class="foo"> and the next </p>". Really simple stuff, really :)
20:58:16 <Eduard_Munteanu> I already came up with a non-regex version, but it's kinda spagetti.
20:58:22 <tolkad> I saw the generics-deriving package and thought it looked cool but it seems too hard to use and has terrible documentation besides the paper
20:58:24 <EliasAmaral> Eduard_Munteanu, I mean, I still employ shell scripts for parsing some htmls I generated (with shell scripts also). but I replace them with ruby equivalents whenever I need to change them, or touch them at all. (just because nokogiri is so cool)
20:58:39 <EliasAmaral> Eduard_Munteanu, what you used?
20:58:50 <xplat> i would use tagsoup for that
20:58:53 <EliasAmaral> (I think that javascript libraries are also cool for parsing html)
20:58:57 <Eduard_Munteanu> EliasAmaral: stuff like stripPrefix
20:59:00 <Eduard_Munteanu> :t stripPrefix
20:59:01 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Maybe [a]
20:59:18 <xplat> maybe as a lexer if it really is as simple as you say
20:59:21 <tolkad> maybe if I knew template haskell it would be easier but that's still on my todo list
20:59:22 <Eduard_Munteanu> I also made up something to trim whitespace, and that's it. :)
20:59:47 <xplat> but you won't be caught out as easily if someone unexpectedly throws in entities or <b> or something
20:59:49 <EliasAmaral> ohh. so you are substituting one gory string-manipulating automaton for a gory regex-based parser
20:59:58 <Eduard_Munteanu> Yep.
21:00:03 <EliasAmaral> isn't there a *dom* haskell library?
21:00:09 <Eduard_Munteanu> I would use a real parser, if it was simple enough.
21:00:19 <EliasAmaral> dom makes this "get p with class X" really _simpler_
21:00:22 <EvanR> regex sucks
21:00:31 <Eduard_Munteanu> I'd welcome suggestions :)
21:00:40 <Eduard_Munteanu> EliasAmaral: nice.
21:00:43 <EvanR> does anyone know the nick of the guy who wrote direct-fastcgi
21:00:43 <EliasAmaral> even if you add some whitespace in the middle of that <p class="foo" that will make you cry for weeks
21:00:58 <EvanR> regex and html dont mix
21:00:58 <tolkad> please never ever try to parse xml with regex
21:01:21 <tolkad> unless this is a one-time script
21:01:23 <EvanR> you need a proper parser
21:01:26 <Eduard_Munteanu> Guys, I'm not parsing HTML with regexes. I'm merely extracting some text from a HTML file ;)
21:01:29 <xplat> actually for most of my html parsing needs i use xpath extended with one custom function 'of' that recognizes classes in the context node
21:01:46 <xplat> so i'd write '//p[of("foo")]'
21:01:58 <EliasAmaral> Eduard_Munteanu, do you know that css way for selecting html? like p.b for selecting <p class="b">. you can use it with dom-aware parsers, like this ruby thing: doc.css('h3.r a.l').each do |link|
21:02:12 <xplat> not quite as simple as the css equivalent for that, but as easy as dom and much more flexible than css
21:02:32 <EliasAmaral> there is also xpath, a mini-language for specifying paths inside xml/html: doc.xpath('//h3/a[@class="l"]').each do |link| , but xpath is ugly
21:02:34 <Eduard_Munteanu> Well, I'm really not into Ruby. :/
21:02:56 <EliasAmaral> oh, this is not a ruby thing. i'm _sure_ there is a haskell library that can do css selection in a one-liner
21:03:06 * Eduard_Munteanu thinks about googling xpath/html and haskell
21:03:21 <ivanm> @google xpath haskell
21:03:23 <lambdabot> http://www.haskell.org/haskellwiki/HXT
21:03:23 <lambdabot> Title: HXT - HaskellWiki
21:03:26 <ivanm> ;-)
21:03:36 <ivanm> I think the xpath stuff has been split off into a sub-library now though
21:03:56 <Eduard_Munteanu> Yup, taking a look at it...
21:04:03 <xplat> HXT is sort of a swiss army knife of HTML/XML stuff but the arrows make it hard to get used to
21:05:08 <xplat> still better than DOM, though, DOM is just a mess.  5 levels, not one of which was thought out for 5 minutes before being implemented and then specified (in that order)
21:06:11 <xplat> and stateful all over
21:06:17 <Eduard_Munteanu> Hm, HXT seems okay, I hope it has some HTML support though.
21:06:24 <EliasAmaral> doesn't xpath uses dom? oh, so I must have said some gibberish or two
21:06:43 <xplat> it's pretty easy to feed HTML into HXT through tagsoup
21:07:54 <xplat> xpath uses the xpath data model, which in xpath 1.0 is pretty simple.  (easier to be simple when you just specify a dataset and not an API, though)
21:08:17 <EliasAmaral> the //h3/a means the h3 might be deep inside the doc, but a is directly below it. /h3/a means h3 is at top-level, //h3//a that h3 is somewhere, and a is somewhere inside it, etc. so i think your xpath expr would be //p[@class="foo"]. (I think xpath is more powerful than css selection. but p.foo looks cleaner..)
21:08:34 <xplat> a lot of the actual xpath implementations work over dom trees, though
21:09:17 <Eduard_Munteanu> Thanks, there seems to be some support for xpath.
21:09:42 <xplat> i highly suggest making an 'of' function like mine, if you can figure out how to add functions to HXT's xpath, it's proved to be incredibly helpful
21:10:08 <EliasAmaral> of?
21:10:47 <xplat> 'of("foo")' basically splits the context node's 'class' attribute on whitespace and then sees if "foo" is one of those words
21:10:55 <xplat> returns boolean
21:11:50 <EliasAmaral> but isn't xpath supposed to do this splitting?
21:11:55 <xplat> you would then do //p[of("foo")] and it would even find a <p class="foo hilite"></p> just like the css equivalent would
21:12:12 <EliasAmaral> ooh..
21:12:28 <EliasAmaral> xpath looks a bit like sed
21:12:36 <Eduard_Munteanu> Heh, it does.
21:12:40 <EliasAmaral> oh, this arrow thing. i must learn it someday. still inaccessible to me though
21:12:46 <xplat> only in that they both use a lot of slashes, but yeah
21:13:17 <Eduard_Munteanu> This looks useful... getXPath :: String -> XmlFilter
21:14:26 <EliasAmaral> haskell has this thing: before you use some library, you need to study its types
21:15:22 <xplat> one other xpath function i would like to have would be one that would parse a 'style' property and return a css attribute you asked for...
21:15:23 <Eduard_Munteanu> I suppose it would look like getXPath "//p[@class=\"foo\"]" >>> somethingthatdoesoutput
21:15:53 <Eduard_Munteanu> I have to take a closer look at HXT's monad (if it is one).
21:16:34 <EliasAmaral> type XmlFilter = XmlTree -> [XmlTree]
21:16:41 <xplat> because some people use style like they're writing freaking XFOs and others put significant one-off things in them like a background-image url ...
21:17:23 <xplat> HXT is based on arrows, not monads
21:18:12 <xplat> you might want to enable arrow syntax when using it, if you're doing anything complex
21:18:49 <EliasAmaral> tey say a -> [b] is a filter, "not a pure function"
21:18:53 <xplat> threading values through pairs gets annoying way faster than threading them through lambdas
21:19:02 <EliasAmaral> because they are calling -> the arrow constructor, right?
21:19:16 <EliasAmaral> but now i'm terrible confused
21:19:25 <Eduard_Munteanu> :t runX
21:19:25 <EliasAmaral> isn't -> an, errm, arrow?
21:19:27 <lambdabot> Not in scope: `runX'
21:19:51 <Eduard_Munteanu> It is.
21:19:53 <xplat> EliasAmaral: you're thinking of the other kind of arrow
21:20:07 <EliasAmaral> :t System.Environment.runX
21:20:08 <lambdabot> Not in scope: `System.Environment.runX'
21:20:14 <xplat> this is arrow as in Control.Arrow
21:20:47 <Eduard_Munteanu> But '->' is an arrow in that sense, it even is a Control.Category arrow.
21:20:57 <Eduard_Munteanu> :t (>>>)
21:20:58 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
21:21:09 <Eduard_Munteanu> :t flip (.)
21:21:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
21:21:29 <xplat> well, yeah, but if you're working in a different Freyd category you don't want to confuse it with your current arrow
21:21:36 <Eduard_Munteanu> Grr.
21:22:58 <EliasAmaral> xplat, but.. if you write a -> [b], isn't this a _function_, even importing Control.Arrow?
21:23:23 <Eduard_Munteanu> Well "arrow" doesn't simply mean "->"
21:24:02 <Eduard_Munteanu> In CT it is a kind of category.
21:24:10 <xplat> EliasAmaral: yes, actually it is, but when reading that documentation, you're supposed to kind of pretend it isn't, just like when you use the State monad.  you'll understand when you have more experience with things like the latter.
21:24:46 <EliasAmaral> if you write the type a -> b in your code, it will be a function, always
21:25:16 <EliasAmaral> so in type XmlFilter = XmlTree -> [XmlTree], XmlFilter is a, ahnm, function
21:25:30 <EliasAmaral> I mean, it is a type for functions of type XmlTree -> [XmlTree]
21:25:39 <xplat> haskell is really one of the most aggressively single-paradigm languages out there, but it is so good at idsls that it can be mistaken for multiparadigm
21:25:57 <xplat> the documentation for HXT wants you to think in one of those idsls
21:26:01 <emes> can you do an "in-place" sort of an input list, in the sense of the output replacing the input list in memory as it's built? (not bubblesort)
21:26:06 <Eduard_Munteanu> Actually '>>>' == flip (.) for many purposes.
21:26:28 <tolkad> xplat: it's flexible enough that you can embed any paradigm you want
21:26:30 <Eduard_Munteanu> emes: yes, in monadic code.
21:26:50 <EliasAmaral> but since Control.Arrow defines an instance for (->), you can use Control.Arrow functions on that type XmlFilter. Right?
21:26:55 <Eduard_Munteanu> emes: though probably not on lists.
21:27:00 <emes> Eduard_Munteanu: how would that work?
21:27:26 <xplat> Eduard_Munteanu: you could do one on lists too with STRefs or IORefs, but it'd be an exercise in futility
21:27:27 <Eduard_Munteanu> emes: are you familiar with arrays, or more specifically STArrays?
21:28:05 <Eduard_Munteanu> :t runSTArray
21:28:06 <lambdabot> Not in scope: `runSTArray'
21:28:22 <Eduard_Munteanu> @hoogle runSTArray
21:28:22 <lambdabot> Data.Array.ST runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
21:28:35 <xplat> tolkad: that's just why it isn't really multiparadigm at all :)  you always embed.
21:28:39 <emes> Eduard_Munteanu: my question is more of a functional programming question than a haskell question
21:29:09 <EliasAmaral> emes, i think this kind of code can be generated if you use linear types
21:29:37 <xplat> linear types is a really exotic sort of functional programming
21:29:38 <Eduard_Munteanu> emes: if you're asking whether you can do in-place updates in a pure functional language, then yes, but you need either some degree of strictness or some primitives like IO/ST arrays.
21:29:40 <EliasAmaral> that is, if you typing system prevents you for using a given value twice, you can discard it after the first use; if the use is solely to update it, you can update in place
21:30:57 <xplat> the more usual functional answer to this problem is you transform your list into a search tree then back into a list and if you need to reuse some of the old memory during the process, well, you pull things off the list from the head so the GC can get the memory back to you as soon as possible
21:31:04 <EliasAmaral> I once argued somewhere that haskell has such types. but i just heard it somewhere. (i am such kind of fool). someone said it has no linear types
21:31:25 <Eduard_Munteanu> It doesn't.
21:31:40 <emes> hmm
21:31:47 <EliasAmaral> i meant in some kind of extension
21:31:50 <bsmntbombdood> [1,2] => [[], [1], [2], [1,2], [2,1]]
21:31:53 <bsmntbombdood> what's that function?
21:32:02 <xplat> EliasAmaral: there's sort of a GHC extension for sort of linear types, but i've never found it even slightly tempting
21:32:20 <xplat> it's extremely limited
21:32:33 <Eduard_Munteanu> Really?
21:33:18 <xplat> Eduard_Munteanu: i've seen it once or twice in some dusty appendix of the GHC manual, gathering mold next to the implicit parameters
21:33:31 <Eduard_Munteanu> bsmntbombdood: some sort of powerset that takes ordering into account?
21:33:50 <bsmntbombdood> nevermind, it's concatMap permutations . subsequences
21:34:05 <Eduard_Munteanu> xplat: I was quite surprised by the SQL-like comprehensions, I stumbled upon those in the manual oO
21:34:40 <Eduard_Munteanu> :t permutations
21:34:41 <lambdabot> forall a. [a] -> [[a]]
21:34:42 <EliasAmaral> functional programming kind of dislikes in-place updates. (this is like saying that nature dislikes vacuum - when it is really our half-baked theories that dislikes it). but then, concurrent programming also dislikes in-place updates. so I hope nobody talks too much about in-place functional programming. let's just hope for those 1024-cores computer get under $100 soon
21:35:31 <emes> EliasAmaral: concurrent functional programming dislikes in-place updates :P
21:35:32 <Eduard_Munteanu> We kinda need a reality check here with these claims...
21:35:36 <EliasAmaral> there is no other way for FP go mainstream :(
21:35:41 <xplat> nature doesn't abhor a vacuum, unless the vacuum is underneath something heavy :)
21:36:03 <azaq231> > let f xs @ (_ : ys) = f ys ++ permutations xs; f [] = [] in f [1, 2]
21:36:05 <lambdabot>   [[2],[1,2],[2,1]]
21:36:18 <azaq231> something like that
21:36:20 <EliasAmaral> emes, did you ever wrote some locking code? i have some trauma about it. (but then i am just a student)
21:36:24 <xplat> people don't normally think of air as something heavy, so it's easy for us to get confused, is all
21:36:43 <EliasAmaral> also, even if you have super-programmers, in-place updates has a worse nemesis: cache issues
21:37:04 <Eduard_Munteanu> They're still an issue even if you don't do updates.
21:37:07 <dibblego> FP is already mainstream
21:37:31 <emes> EliasAmaral: locking code is the wrong way to do concurrent programming
21:37:39 <Eduard_Munteanu> But if you ignore performance you might as well ignore caching :)
21:37:56 <tolkad> if you put another module in a modules export list and you want to use it within the module, do you still need to import it?
21:38:21 <Eduard_Munteanu> emes: lock-free algos aren't easier to write either.
21:38:50 <xplat> they are if you use STM ...
21:39:19 <xplat> (wait-free, though, there's no easy fix for that ...)
21:39:26 <Eduard_Munteanu> xplat: isn't that lock free only by virtue of atomic ops? (Those atomic ops are the very things that implement locking, mind :) )
21:39:42 <Eduard_Munteanu> And they're not cheap.
21:39:44 <tolkad> EliasAmaral: haskell has in-place updates, it just requires you to make them explicit
21:39:53 <tolkad> EliasAmaral: IORef/MVar
21:40:33 <tolkad> EliasAmaral: or Ptr if you want to be more low-level
21:40:44 <EliasAmaral> emes, ^ that's your in-place haskell
21:41:01 <Eduard_Munteanu> FFI and write the in-place stuff in C? :)
21:41:07 <xplat> Eduard_Munteanu: STM is abstract enough to be implemented in multiple ways.  and anyway, you still need those atomic ops for locking, and you have to replace all your postgrads every several weeks when their brains melt
21:41:53 <xplat> and if you're actually paying for coders, then you're really hosed
21:42:37 <tolkad> by the way, why does ghc make all data types require a word of space when doing so is entirely unnecessary?
21:42:37 <Eduard_Munteanu> xplat: indeed, but locking a structure is usually cheaper than doing IO to it atomically, simply because the lock is smaller.
21:42:38 <EliasAmaral> emes, I think that if your code is locking free, you uhmmm have to use functional data structures (by functional i mean http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504 ). but I'm errm, not sure
21:43:24 <tolkad> emes: What's the correct way?
21:43:30 <EliasAmaral> but actually. one still needs those atomic operations like CAS, right?
21:43:40 <emes> tolkad: well depends on what you're doing
21:44:18 <EliasAmaral> I think that if you have some way of sending values through a channel you don't need those fancy atomic operations
21:44:29 <Eduard_Munteanu> EliasAmaral: if you don't share data that's updated then there's no concern.
21:45:13 <Eduard_Munteanu> But yeah, at some level there is going to be some sort of atomic op, but maybe not in your code.
21:45:13 <EliasAmaral> but with functional data structures (like haskell's list) there is no update. after you build the list, it stays the same forever. it can change only when there is no references
21:45:55 <xplat> Eduard_Munteanu: but when you gain the most in reduced straight-through overhead with a locking scheme you lose the most in concurrency.  that's why database implementors come up with btrees update algorithms where you lock by page and you only need 2 locks at a time...
21:46:11 <emes> so it's easy to parallelize map-reduce type operations, how do functional languages parallelize operations that need communication between threads?
21:46:44 <Eduard_Munteanu> MVar/TVar
21:47:25 <EliasAmaral> emes, the approach I see at concurrent ml (and some nice ocaml library based on that) is a channel of values. i think in haskell it would be simply a list, since lists are lazy. it's like a.. pipe
21:47:40 <xplat> emes: or message queues, or skeletons more complex than the map-reduce one, or ...
21:48:20 <Eduard_Munteanu> I don't think it's much different than in imperative languages.
21:48:23 <EliasAmaral> so i heard that sh is some nice concurrent language, because of this | operator it has
21:48:47 <xplat> hey, don't knock it
21:49:25 <xplat> make -j4 plus a vanilla compiler has beaten the pants off many a fancy-ass parallel compiler
21:51:24 <xplat> in fact you don't even see many fancy-ass parallel compilers these days for just that reason
21:51:37 <emes> because of make -j4?
21:51:44 <Eduard_Munteanu> Yep.
21:52:16 <Eduard_Munteanu> And probably because the number of cores isn't high enough to be worth paralellizing beyond the modularity that programmers put in.
21:53:53 <emes> maybe parallel linking would be helpful
21:54:17 <EliasAmaral> xplat, about the vacuum thing: at century 19, it was thought it didn't existed at all, because it was filled with ether. later it was found to be false. later, background radiation was discovered, something that would "fill" all vacuum
21:54:25 <Eduard_Munteanu> Yeah, though linking is more IO-bound I think.
21:54:50 <Eduard_Munteanu> It might make sense in case of whole-program optimizations or such stuff.
21:56:24 <tolkad> will this work? http://codepad.org/KU66Y2gd
21:56:40 <tolkad> it was my idea of an alternative to using a chan
21:57:22 <xplat> EliasAmaral: you could say there's no such thing as a vacuum because there's background radiation, or you could say there's practically nothing but vacuum because ordinary (non-degenerate) matter is so sparse
21:58:01 <Eduard_Munteanu> An alternative to all this is using 'par' to take care of everything.
21:58:48 <Eduard_Munteanu> I think there's hardly any matter in the universe.
21:58:50 <EliasAmaral> "most of that region of space is empty" is far from "all of that region is empty"
21:58:51 <xplat> or you could say that there's nothing but vacuum because any stretch of matter constitutes an exotic vacuum with its own spectrum of elementary excitations...
21:59:03 <xplat> like, photons have a mass in glass
21:59:55 <tolkad> or you could say there's nothing but yourself because you are a solipsist
22:00:27 <Eduard_Munteanu> :)
22:00:31 <xplat> and then you could punch me in the face, because i would only get mad at myself for having such a masochistic imagination
22:03:13 <tolkad> if you put another module in a modules export list and you want to use it within the module, do you still need to import it?
22:03:36 <xplat> i think actually for most working physicists the dividing line between 'exotic vacuum' and 'material' is whether it breaks the lorentz symmetry of the (large) dimensions, if it does it's a material, if it doesn't it's a vacuum ...
22:03:55 <EliasAmaral> Eduard_Munteanu, you said concurrency without in-place update still has cache issues. but,if a thread receives a pointer for a region of memory allocated by other thread, it can safely assume the it can cache the data there and it will be valid until the thread doesn't need it anymore, because it can be freed only after all threads doesn't need it anymore (but maybe no current processors does that)
22:04:26 <EliasAmaral> i have a gap between the high-level concurrency ideas and the low-level way of getting things done
22:05:51 <xplat> EliasAmaral: there are probably processors that do that, but they are probably the exotic supercomputer processors whose markets are being eaten into by beowulf clusters of xboxes
22:05:59 <Eduard_Munteanu> EliasAmaral: ah, I was referring to cache-locality.
22:06:21 <EliasAmaral> oh, i see
22:08:05 <xplat> i don't *think* anything in the ia32/64 family, or any of its increasingly beleaguered competitors, has deployed such a nuanced approach to cache line invalidation, though i could be wrong
22:09:02 <Quadrescence> mm_freak_: did you write an IO monad in C#?
22:09:18 <EliasAmaral> xplat, i'm reading about lorentz symmetry. i was thinking in studying some physics to understand more about this symmetry things. but physics is hard :(
22:09:34 <Eduard_Munteanu> Someday we will have explicit cache management, and beyond that, explicit microops scheduling.
22:09:45 <xplat> in particular, i think the cache levels that benefit from memory protection bits to indicate such contentions are shared not only between cores but between chips
22:09:54 <xplat> er, such intentions
22:10:09 <ddarius> EliasAmaral: Learn Geometric Algebra and physics will be easy.
22:10:19 <EliasAmaral> geometric algebra?
22:10:27 <Eduard_Munteanu> I'm interested in NISC cpus, btw.
22:10:33 <ddarius> @google "geometric algebra"
22:10:33 <xplat> Eduard_Munteanu: we had explicit microops scheduling.  it was called itanium.
22:10:34 <lambdabot> http://en.wikipedia.org/wiki/Geometric_algebra
22:10:34 <lambdabot> Title: Geometric algebra - Wikipedia, the free encyclopedia
22:10:46 <ddarius> Hmm.  Not quite what I wanted, but the references should be fine.
22:10:54 <Eduard_Munteanu> xplat: yeah, but I still think it's far from NISC.
22:11:09 <xplat> (or more to the point, Itanic)
22:11:15 <Eduard_Munteanu> Heh.
22:11:24 <Eduard_Munteanu> Itanium wasn't that bad I think
22:11:25 <EliasAmaral> (fact is, i am awkward with maxwell equations and other "simple" stuff. i have saw some lagrangian physics, hamiltonian stuff, and it scares me)
22:11:52 <ddarius> EliasAmaral: In Geometric Algebra Maxwell's equation(s) is ‚àáF = J.
22:12:16 <Eduard_Munteanu> At least compared to the mess x86-64 is. Well, a backwards-compatible mess, but still.
22:12:39 * Eduard_Munteanu thinks proprietary software has a lot to do with that
22:13:03 <ddarius> EliasAmaral: Also, if you think physicists understand Maxwell's equations, you are in for a big surprise.
22:13:12 <EliasAmaral> never really understand much of calculus. actually the sole class i understand _any_ calculus at all was some signals and systems. fourier analysis and all, the professor was someone with electrical engineering so i could understand him
22:13:16 <copumpkin> geometric algebra, that sounds familiar ;)
22:13:36 <xplat> lagrangian and hamiltonian physics were created originally as an overarching framework for understanding the various 'classical' physical theories, and they were later adapted to QM (path integral and canonical quantization, resp) and GR (lagrangian density and hamiltonian constraint)
22:13:44 * copumpkin is reading about it right now
22:13:47 <Eduard_Munteanu> EliasAmaral: that's mechanics, for Maxwell's equations you don't really need that stuff. Just your regular vector calculus.
22:14:12 <ddarius> Eduard_Munteanu: The Fourier transform is useful for differential equations in general.
22:14:28 <EliasAmaral> ddarius, it strikes me that this guy took faraday work and just saw this something. @.@ i used to think i'm intelligent :)
22:15:27 <ddarius> copumpkin: A good, motivating introduction to some, but definitely not all, of Jaynes' work is the paper "Clearing up mysteries."
22:15:27 <xplat> to understand modern physics you definitely need to get a grip on calculus, either before or during
22:15:32 <EliasAmaral> Eduard_Munteanu, oh, what i wanted to understand is not really maxwell but uhm. but be comfortable with all those things. plus understanding about symmetries (noether stuff) is a plus
22:15:42 <ddarius> xplat: To understand any physics, you need a grip on calculus.
22:15:44 <Eduard_Munteanu> Yeah, Fourier and Laplace are kinda must-know-stuff, not for Maxwell's but for other things.
22:15:51 <EliasAmaral> but it is really about being comfortable lots of calculus
22:16:09 <ddarius> Unless by "modern physics" you meant "mathematical physics" (= physics since Newton)
22:16:09 <copumpkin> ddarius: thanks
22:16:13 <xplat> ddarius: nah, you should be fine up to about kepler
22:16:21 <copumpkin> gonna go home (still at office) and then sleep :P
22:16:33 <copumpkin> will read tomorrow! (and maybe make bread :P)
22:16:39 <Eduard_Munteanu> What, there were other physics before him? Like... homeopathic physics? :P
22:16:45 <ddarius> copumpkin: The bread takes two days.
22:16:46 <EliasAmaral> computer science students, here, doesn't learn fourier. doesn't ever hear about that. at all. o.o (i'm from computer engineering and i can't graduate without laplace)
22:17:03 <copumpkin> okay, well maybe start making bread then :)
22:17:09 <xplat> also, you can understand some newtonian physics qualitatively with intuition, although definitely far from all
22:17:17 <ddarius> Eduard_Munteanu: Galileo deserves significant mention, but, yeah, it basically started with Newton.
22:18:10 <xplat> past the classical era, though, you need to use the math as your conceptual as well as calculational framework
22:18:31 <EliasAmaral> so while i lack lots of calculus, i must look at those H(s) for lots of time (but if I write down as an integral things get messy. u.u)
22:18:33 <Eduard_Munteanu> Also, much of the math we know today is 19th-20th century math. They basically rewrote everything then.
22:18:57 <Eduard_Munteanu> Even if the ideas weren't new, formal methods were applied quite recently.
22:19:14 <ddarius> Eduard_Munteanu: That's true, but modern methods are significantly better than what preceded.
22:19:15 <tg_> I could chirp in and say it (wherein we talk about the exponential growth of physics knowledge) might have started with Lorentz/Noether/Einstein
22:19:24 <Eduard_Munteanu> Indeed.
22:19:34 <tg_> and Hilbert, I guess
22:20:02 <Eduard_Munteanu> Hilbert at least for his math contributions.
22:20:19 <ddarius> Though, some things got mangled.  Much of what was done in earlier calculus/mathematical physics significantly relied on the intuition of "infinitesimal" elements.  That wasn't able to be made rigourous in the popular frameworks of the formalization days and so was discarded.
22:20:33 <tg_> well, if I remember correctly, Hilbert solved some key components of GR for Einstein, but I guess that doesn't have anything to do with SR.
22:20:49 <ddarius> But it is still excellent intuition and can be made rigourous in "non-standard" approaches.
22:20:51 <Eduard_Munteanu> ddarius: are you making a reference to non-standard analysis there?
22:20:56 <Eduard_Munteanu> Ah.
22:20:57 <ddarius> Eduard_Munteanu: Yes and no.
22:21:12 <xplat> well, the 'non-standard' approaches are consistent but they aren't all that intuitive
22:21:17 <ddarius> Eduard_Munteanu: I don't much like non-standard analysis.  I find synthetic differential geometry much prettier.
22:21:34 <xplat> especially the main approach bearing that name (Robinson's)
22:21:35 <Eduard_Munteanu> Yeah, though it's interesting as an "what-if".
22:21:41 <EliasAmaral> ddarius, i once read some feynmann lecture. he was describing the amplitude of something happening at quantum mechanics - the probability being the amplitude squared; and if you have two possibilities (a logical 'or') you sum - the amplitudes, not the probabilities. and if you have an 'and' you multiply.. the amplitude. in the other chapter he mentioned in a footnote that amplitudes were plain old complex numbers. o.o'
22:22:03 <xplat> if you think epsilon and delta and limits are hard to get across to high school students, try teaching them some model theory ...
22:22:05 <ddarius> Much of the work Sophus Lie did was "prototyped" first with "infinitesimal" elements and then made rigourous later.
22:22:21 <EliasAmaral> i think i understood why he says you don't need waves for explaining "wavelike" phenomena of light (interference, diffraction, etc). without barely any math
22:22:41 <Eduard_Munteanu> xplat: some well-founded set theory would've been great in high school.
22:22:46 <ddarius> xplat: Again, I don't much care for non-standard analysis and also it's not necessary to teach that.
22:23:18 <ddarius> That said.  The foundations of synthetic differential geometry are probably even more fear inducing.
22:23:49 <shachaf> ddarius: Do you suggest teaching with epsilon-delta limits and so on?
22:23:52 <ddarius> But it's not really necessary to go into the foundations and it's quite possible to make a reasonable system that straight-forward to use.
22:23:55 <Eduard_Munteanu> Also I'm glad we get to study some abstract algebra in the 12th grade here.
22:24:00 <xplat> Eduard_Munteanu: yeah, but you wouldn't have got far enough to be able to use a non-standard model as a *stepping stone* to calculus, is all i'm saying
22:24:19 <ddarius> shachaf: I don't understand why you asked me that question.
22:24:55 <Eduard_Munteanu> shachaf: we *do* get to study those epsilon-delta definitions here, in highschool.
22:25:13 * ddarius suggests so non-well-founded set theory.
22:25:14 <shachaf> ddarius: Your response to xplat.
22:25:17 <ddarius> s/so/some.
22:25:47 <ddarius> shachaf: I'm the one that first brought up SDG and non-standard analysis.  Why would I be the one suggesting to teach the standard techniques?
22:25:51 <xplat> honestly, if i could think of a good way to motivate it i'd skip over all the formal foundations of real analysis and go straight to commutators and derivations ...
22:25:52 <Eduard_Munteanu> I meant set theory beyond very basic stuff. Some foundations on ZF would've been good.
22:26:07 <tg_> xplat: physics, is.
22:26:14 <shachaf> ddarius: You were just saying how you don't much care for it and that it's not necessary to teach.
22:26:16 <EliasAmaral> Eduard_Munteanu, high school? where? (in our curriculum at brazil there _is_ epsilon-delta calculus, and derivatives, at high school. but my school haven't touched that because university exams didn't required it)
22:26:33 <lars9> @hoogle  (a->b) -> (c->d) -> (a, c) -> (b, d)
22:26:33 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
22:26:38 <ddarius> shachaf: I don't much care for -non-standard analysis-.  I like SDG.
22:26:50 <Eduard_Munteanu> EliasAmaral: Romania. But yeah, we kinda skimmed quickly over those too.
22:26:52 <shachaf> Ah.
22:26:55 * shachaf should read further back.
22:27:00 <lars9> no such arrow? (a->b) -> (c->d) -> (a, c) -> (b, d)
22:27:21 <ddarius> :t (***)
22:27:22 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
22:27:51 <shachaf> Eduard_Munteanu: My high school skipped any semblance of rigor whatsoever. Epsilon-delta limits weren't even mentioned.
22:27:57 <xplat> lars9: yeah, (***) is what you want
22:28:03 <EliasAmaral> (i know of one university here, ITA, that requires calculus at its entry exam. but its questions induces fear even on simpler subjects)
22:29:20 <lars9> > (+1) *** (++"a") $ (0, "")
22:29:22 <lambdabot>   (1,"a")
22:29:26 <lars9> xplat: thanks
22:29:32 <xplat> really most of calculus is just infinite-dimensional linear algebra anyway
22:29:56 <ddarius> xplat: Hence the usefulness of Fourier transforms.
22:29:59 <Eduard_Munteanu> Hm?
22:30:28 <ddarius> However, infinite-dimensional linear algebra isn't the same as finite dimension linear algebra.
22:30:28 <Eduard_Munteanu> There is some connection.
22:31:04 <xplat> ddarius: yeah, anything infinite tends to get a little trickier
22:32:07 <ddarius> At any rate, anyone interested in physics, either applied or theoretical, should definitely learn geometric algebra which is definitely something a high schooler could pick up.
22:32:26 <xplat> the most obvious thing being a linear transformation can have a nullspace and still map into the whole space, like the derivative does in a taylor basis
22:32:35 <EliasAmaral> "infinite-dimensional linear algebra" seems like a characteristic term at this channel (in that i don't grasp even what it refers :)
22:32:37 <Eduard_Munteanu> ddarius: what exactly do you mean by geometric algebra?
22:32:53 <EliasAmaral> ddarius, really? wikipedia is doing a good job to intimidate me
22:33:00 <EliasAmaral> http://en.wikipedia.org/wiki/Geometric_algebra
22:33:09 <xplat> but there are lots of less obvious and trickier ones too, starting with convergence ...
22:33:22 <Eduard_Munteanu> Oh, that, yes.
22:33:30 <shachaf> EliasAmaral: It's not particularly Haskell-related. This should be in #-blah, really. :-)
22:34:03 <Eduard_Munteanu> Actually the inner/outer products and all that stuff has some roots in abstract algebra, they even use the same symbols for meets and joins.
22:34:08 <EliasAmaral> it is haskell-related in that i am constantly confused about the concept
22:34:40 <Eduard_Munteanu> And it's certainly useful when formalizing some vector calculus.
22:35:42 <xplat> Geometric algebra seems like it's a little intimidating even compared to the tensor route, but the first time you run into a spinor you'll have to learn it anyway, soo...
22:36:12 <EliasAmaral> outer product o.o
22:36:21 <EliasAmaral> tensor is also something i have to learn
22:36:25 <xplat> maybe i just haven't run into a good presentation of GA yet
22:36:38 <EliasAmaral> shachaf, also i think that anything with "algebra" in its name feels related to haskell
22:36:49 <Eduard_Munteanu> How come tensors are less intimidating?
22:37:00 <ddarius> EliasAmaral: The Wikipedia page is hardly an introduction.
22:37:04 <azaq231> EliasAmaral: Since it sounded like you didn't know what it was, regarding that feynman lecture, he was likely talking about the schroedinger equation. the probability for some electron to be in a specific position is described by a wave Psi(x, t), whereas the probability is |Psi(x, t)|^2
22:37:21 <azaq231> in the atom, that is
22:37:42 <xplat> Eduard_Munteanu: i found it easier to visualize what a tangent bundle, or even a cotangent bundle, is
22:37:59 <shachaf> EliasAmaral: Were you talking about _QED_?
22:38:10 <EliasAmaral> shachaf, yes :~~
22:38:24 <xplat> plus i learned tensors with all the greek indices, so even when i was in doubt about the meaning it was usually still obvious what to do, so to speak
22:38:29 <ddarius> EliasAmaral: Look at http://www.science.uva.nl/ga/tutorials/index.html and other things on that page for a more friendly and more CS oriented introduction.
22:38:29 <EliasAmaral> the lectures (in video) are also nice, but too much little jokes to entertain the public .-.
22:38:31 <xplat> tab a, slot b
22:39:08 <ddarius> It's quite easy to make things that can easily be calculated and are completely opaque in tensor algebra.
22:39:11 <Eduard_Munteanu> Gah, am I the only one who values books more than talk? :)
22:39:22 <ddarius> The problem with tensor algebra is that it is too unstructured.
22:39:29 <shachaf> Eduard_Munteanu: Feynman, as I recall, rather disliked writing.
22:40:04 <EliasAmaral> azaq231, yeah. it is exactly that. but he didn't any math to talk about that. (it also had to skip some complexities. but he didn't left out the actual weird phenomenas and how to explain them. like the "electron traveling backward at time == positron going forward at time. he employs his diagrams to make up the lack of math)
22:40:59 <xplat> i wish the math were more accessible to the public back when i learned physics
22:41:02 <EliasAmaral> ddarius, you mean the interactive tutorials? (Are they, programs?)
22:41:04 <Eduard_Munteanu> Was he a good lecturer at least?
22:41:12 <EliasAmaral> ddarius, you mean the interactive tutorials? (Are they, programs?)
22:41:24 <tg_> well, that may be true for Feynman (because his original motivation was just QED), but in modern physics it can take several (20+) pages to describe something which you could describe with 1 QCD feynman diagram
22:41:26 <xplat> if i had today's internet and could follow the math as well as the diagrams i'd have avoided a LOT of confusion
22:41:36 <ddarius> EliasAmaral: I linked you to a specific set of papers.  There are also interactive tutorials, but I would recommend going through the papers I linked you to first or in parallel.
22:41:48 <ddarius> The interactive ones use GAIGEN which is like a CAS for GA.
22:42:15 <EliasAmaral> "paper tutorials"?
22:42:38 <Eduard_Munteanu> No tutorials, just lemmas, theorems, proofs :P
22:42:49 <ddarius> EliasAmaral: Bah, frames. http://www.science.uva.nl/ga/publications/CGnA.html
22:43:03 <Eduard_Munteanu> (Why is that so scary?)
22:43:36 <lars9> in haddock, how to doc types? data A = ...
22:43:48 <lars9> also start with -- | ?
22:43:48 <dibblego> -- | This is A,
22:43:56 <lars9> dibblego: thanks
22:44:14 <EliasAmaral> Eduard_Munteanu, I don't like his kind of teaching at my personal experiences. like, doing little jokes. but i could understand him. the way i try to teach is completely annoying for almost anyone, like giving definitions and sticking to them, etc. so the teachers i like people say they are awful, completely crazy, etc
22:44:15 <ddarius> One of the nice things about geometric algebra is that it is a rather comprehensive (and well matched) language for physics, so you don't need to learn a bunch of different conflicting and limited languages like spinor calculus.
22:44:21 <dibblego> lars9, http://www.haskell.org/haddock/doc/html/markup.html
22:44:40 <EliasAmaral> the book felt like he trimmed down the lecture to just the important parts, and left out all the empathy-gathering talk
22:45:32 * shachaf didn't know there were videos.
22:45:33 <Eduard_Munteanu> IMHO if all you do is give speeches, you should quit teaching and just stick to research.
22:45:56 <EliasAmaral> the teaching style i like feel like the "structure and interpretation of computer programs" book. actually, the book also has videos. they are amazing.
22:46:09 <lars9> how to doc foldl' then? 'foldl'' ?
22:46:09 <Eduard_Munteanu> It's university, not some place where you pitch your stuff.
22:46:21 <tg_> just to clarify, the "feynman lectures" are about 100 or so in number (usually 1 hour long each) and are accompanyed with handbooks
22:46:26 <lars9> i mean how to refer the name with '
22:46:43 <tg_> the feynman "lectures" that microsoft hosted are a small subset and/or unrelated
22:46:56 <Eduard_Munteanu> EliasAmaral: I kinda liked how TAPL was structured, if you know it.
22:47:18 <Eduard_Munteanu> It even has a dependency graph of the chapters.
22:48:09 <EliasAmaral> http://www.youtube.com/watch?v=5VMu14mBXAs <- i actually enjoy this kinds of things, and overall feynmann style is very good / http://vega.org.uk/video/subseries/8
22:48:44 <EliasAmaral> Types and Programming Languages? will put in a todo list
22:48:53 <Eduard_Munteanu> Yes.
22:49:04 <lars9> dibblego: hi do you know how to refer foldl' in haddock?
22:49:25 <Eduard_Munteanu> (On the other hand I had more gripes about Awodey's book on CT.)
22:49:25 <ddarius> Eduard_Munteanu: A lot of books have dependency graphs of the chapters.
22:49:54 <Eduard_Munteanu> ddarius: maybe. But most don't. Textbooks even less.
22:50:03 <dibblego> lars9, http://www.haskell.org/haddock/doc/html/ch03s08.html#id566119
22:50:28 <Eduard_Munteanu> Heck most school books I've seen don't even have an index.
22:50:37 <shachaf> Most books are topologically sorted. :-)
22:50:38 <ddarius> Eduard_Munteanu: Most textbooks are usually meant to be sequential.  Certainly few if any novels feature a dependency graph.
22:50:41 <shachaf> Or try to be.
22:51:20 <EliasAmaral> ddarius, nice pdfs. thanks =)
22:51:42 <lars9> dibblego: thanks:)
22:54:20 <EliasAmaral> both that feynmann qed lecture and the sicp lecture contains some nice analogies i'm so fond of. sicp says computer science isn't about computers more than astronomy is about telescopes, or geometry about surveying instruments. he thens went talking that the ancient Egyptians thought that geometry was about surveying instruments because they had no higher understanding of what they were doing
22:59:38 <Eduard_Munteanu> ddarius: sadly, IMO the quality of my university written materials is so much lower than the quality of the books I had during highschool.
23:00:01 <Eduard_Munteanu> Only one or two decent textbooks so far.
23:03:17 <Eduard_Munteanu> And somehow I think this isn't a local problem.
23:06:54 <EliasAmaral> i was to write which nice analogy qed had, but i didn't knew how to write it in a few words. it was related on how ancient people predicted eclipses by counting days, and tried to explain why the eclipse occurred by analyzing the properties of this number itself (which says nothing about the physical phenomena)
23:08:17 <Eduard_Munteanu> Anyway... we've been learning what's supposedly part of higher education out of 5-6 pages of lecture notes / week, while highschool books had nice diagrams, expanded explanations etc. in hundreds of pages. It's really disappointing to call this teaching.
23:09:10 <EliasAmaral> you say the high school books are better because they had nice diagrams, etc?
23:09:38 <Eduard_Munteanu> No, they're better because they don't cram in stuff.
23:10:25 <EliasAmaral> i sometimes am between a book with 'modern' presentation and a 'old' book. sometimes the 'modern' thing (lots of colors, fancy images, boxes with curiosities, nice diagrams..) just cover up the simple fact that the book author can't write
23:10:50 <Eduard_Munteanu> Well no, I wasn't referring to that.
23:10:54 <EliasAmaral> it's easier to say if the book is good by the author prose itself, than looking at the diagrams
23:10:58 <EliasAmaral> oh uhm
23:12:33 <Eduard_Munteanu> Put it another way... I stopped attending lectures when I found out the benefit of doing so was quickly approaching zero wrt just getting them from other students. Or better, reading ebooks that teachers supplied.
23:12:40 <ddarius> Most university classes have multiple textbooks associated with them.
23:12:56 <Eduard_Munteanu> It's simply because no matter how much effort you put it's all a lump of crap when you get down to study it seriously.
23:13:30 <EliasAmaral> Eduard_Munteanu, well, here, i bought all the books in the first semester (except the book on ocaml, because there were none to buy in portuguese), but i then regretted. university books are no cheap. so i borrowed the textbooks in later semesters, and now i mostly have lecture notes, yes..
23:13:42 <ddarius> Don't let school get in the way of your education.
23:14:09 <Eduard_Munteanu> Well here it's the lecture that matters and the rest is usually a joke of a bibliography and usually no syllabus.
23:14:12 <EliasAmaral> ddarius, that's also my line of thinking. i had a professor on calculus that almost killed my interest on the subject
23:14:30 <Eduard_Munteanu> I don't let it. I do enjoy studying stuff on my own.
23:14:48 <Eduard_Munteanu> (but then, I get to pick, so that's why I'm here :D)
23:16:01 <Eduard_Munteanu> EliasAmaral: I agree, that's an issue. If you pay (directly or not) for your education, you should get quality materials. Not just the option to pick between cheap lecture notes and expensive but good books.
23:16:28 <Eduard_Munteanu> (and here education isn't that expensive, but I can't really tell how US people get by)
23:16:39 <EliasAmaral> i had a professor on transport phenomena (like heat, fluid dynamics, o.o) that was unbelievably awful. also one at logic & discrete mathematics that were really really mad. i studied those two subjects elsewhere and wow. they are really interesting o.O
23:17:15 <Eduard_Munteanu> Yeah, it's bad when school gets to be a turnoff.
23:18:08 * ddarius has mostly avoided school, though not entirely intentionally.
23:18:10 <EliasAmaral> oh. here the university is 100% free. and for any kind of compulsory fee students unrest, it's a political issue very deep here. really, even the restaurant is almost free (half to 1/4 of the price of anywhere else)
23:19:31 <Eduard_Munteanu> EliasAmaral: where's that? Most of the university education here is state-sponsored and free. And private universities have even cheaper tuition fees, but unfortunately most have the reputation of being diploma mills.
23:19:57 <EliasAmaral> brazil. and, yes, state-sponsored. "private university" here is almost synonymous of "full of crap"
23:20:19 <ivanm> we only have one private uni; very popular with foreign students
23:20:30 <ivanm> otherwise people attend it because it has 3 sem/year, so you finish faster
23:20:35 <Eduard_Munteanu> Well, that's fully expected in some cases.
23:20:46 <copumpkin> ivanm: wow, 18-month years!
23:20:52 <copumpkin> things are quite different down under
23:20:52 <EliasAmaral> most of them have astonishing low quality, with few exceptions (like PUC, home of lua programming language)
23:21:00 <EliasAmaral> ivan, where's that?
23:21:14 <Eduard_Munteanu> I totally understand why diploma mills exist, at least in countries where the state employs a large number of people and cares only about credentials rather than competence.
23:21:19 <ivanm> copumpkin: no, you just don't really get any holidays
23:21:27 <Eduard_Munteanu> EliasAmaral: oh nice.
23:21:34 <ivanm> EliasAmaral: Australia
23:22:21 * Eduard_Munteanu thought ivanm was Russian by his name :)
23:22:32 <ivanm> @slap Eduard_Munteanu 
23:22:33 <lambdabot> go slap Eduard_Munteanu  yourself
23:22:36 <ivanm> grrr...
23:22:42 <ivanm> I'm 3/4 Ukrainian and 1/4 Serbian
23:22:43 <EliasAmaral> oh, me too, lol
23:22:48 <EliasAmaral> ahh :)
23:22:49 <ivanm> if anything, my name is Serbian
23:22:51 <Eduard_Munteanu> Oh, I get the point :)
23:22:54 <ivanm> (due to the surname)
23:22:55 <EliasAmaral> lol
23:23:14 <Eduard_Munteanu> Ah, "Ivan" is common in the Eastern Europe.
23:23:14 * ddarius thought ivanm was some purple pixels.
23:23:29 <ivanm> Eduard_Munteanu: yes, not just Russia ;-)
23:23:31 <shachaf> ddarius: Why did you end up avoiding school?
23:23:32 <ivanm> ddarius: :/
23:24:13 <Eduard_Munteanu> "Elias" sounds Jewish to me, though.
23:24:14 <ddarius> shachaf: Mostly because I didn't have the money, then later on/now I mostly don't need it.
23:24:17 <EliasAmaral> i have a professor named ivan. people call them "ivan the terrible"
23:24:23 <Eduard_Munteanu> Heh.
23:24:50 <ivan> >:(
23:24:52 <EliasAmaral> Eduard_Munteanu, it is elijah in portuguese o.o
23:25:03 <Eduard_Munteanu> In fact I'm puzzled why first names are so universal.
23:25:26 <ddarius> Eduard_Munteanu: Because you have a narrow view of the world perhaps.
23:25:43 <EliasAmaral> cultural domination? the most common name at portugal is derived from muhammad
23:25:48 <Eduard_Munteanu> Hm, maybe.
23:26:00 <ivanm> well, "Ivan" is the Slavic equivalent of "John"
23:27:55 <Eduard_Munteanu> Though similarly, I've seen Asians taking up western names.
23:28:20 <copumpkin> in western countries
23:28:28 <Eduard_Munteanu> Hm yeah.
23:28:40 <EliasAmaral> in fact there is two derivations of muhammad in portuguese: maom√©, which we apply for people actually called muhammad (mostly people that speaks arabic or lives in a place under islam influence) and manoel (for the portugal name, which isfrom the early arab occupation; but also present at brazil). in fact we have manuela, a feminine actually more common than manoel, and i think muhammad has no feminine version
23:29:12 <EliasAmaral> (more common than manoel in brazil. or at least it seems)
23:29:36 <ivanm> Eduard_Munteanu: those from malaysia, etc. tend to do so from western influence AFAICT
23:29:55 <EliasAmaral> it became a portuguese name that has little to do with its origins, people picked up because they find it beautiful, and they find it beautiful because they hear about them and like it
23:30:18 <EliasAmaral> i think the more people hear about something, more people will find it beautiful
23:30:20 <Eduard_Munteanu> To think about it, at least here few names are region-specific
23:31:18 <ddarius> Eduard_Munteanu: That's probably a form of sampling bias.
23:31:20 <EliasAmaral> there is a kind of feedback cycle: people start naming their sons manoel, and other people see it and think they should name theirs too
23:32:16 * shachaf has never understood why people name their children names that other people have named their children.
23:32:37 <shachaf> Given the opportunity to name something, I'd think that as rare a name as possible would be preferable.
23:32:41 <Eduard_Munteanu> We also had a phenomenon here: people used to pick western-sounding names for their offspring because they taught it was "cool" to do so.
23:32:49 <ddarius> shachaf: Indeed.  We should identify each child with a UUID.
23:32:54 <Eduard_Munteanu> Heh :))
23:33:09 <shachaf> My first name seems to work pretty well as an identifier. :-)
23:33:16 <shachaf> (Though unfortunately it's not unique.)
23:33:22 <Eduard_Munteanu> Eduard stands for Edward, so I guess I could fit into that category.
23:34:54 <EliasAmaral> shachaf, is it shachaf? @.@
23:35:01 <shachaf> Yes.
23:35:04 <Eduard_Munteanu> Heh.
23:35:06 <EliasAmaral> Shachaf Ben-Kiki, is this korean?
23:35:07 <ddarius> EliasAmaral: You can do a /whois 
23:35:11 <EliasAmaral> i did
23:35:15 <shachaf> EliasAmaral: Hebrew.
23:35:21 <EliasAmaral> oh :)
23:35:28 <Eduard_Munteanu> Ben is definitely hebrew.
23:35:39 <EliasAmaral> i thought about ban ki moon
23:36:40 <ddarius> As an alternative to UUIDs, we can name people with their complete maternal lineage, albeit people who give multiple children the same name thwart this.
23:37:03 <Eduard_Munteanu> Isn't that a bit like the Spanish do?
23:37:18 <ddarius> I do think the Spanish do something like that.
23:37:36 <c_wraith> All of George Foremen's children are named George.  Even the girls.  I wonder why his wife agreed to that.
23:37:52 <Eduard_Munteanu> That borders on insanity a bit...
23:38:37 <ddarius> This page is interesting by the way: http://en.wikipedia.org/wiki/List_of_most_popular_given_names
23:39:01 <EliasAmaral> shachaf, reading silmarillion i see a lot of nice names that i haven't saw other people using. sometimes i think "wow that's a nice name to name a child". but sometimes I think that an exotic name could make other children react badly. (this is silly. plus a child has to learn how to build self-esteem and confidence. etc)
23:39:44 <EliasAmaral> here children are mean to any kind of exotic trait, something that can get you unique generally embarass you
23:39:52 <maurer_> Is there a way to get something like a reference to a top level object that can survive network transmission to the same program?
23:40:05 <shachaf> EliasAmaral: Well, that's certainly not something to encourage by giving your children identical names to everybody else.
23:40:23 <ddarius> copumpkin: The game was called Limbo.
23:40:29 <EliasAmaral> but my mom named me elias because of the biblical figure. (but she actually does not like religion)
23:40:38 <maurer_> i.e. I have two copies of the same program running on different machines, and I have a function at top level on machine A, and I want to send a message to machine B that says "call this function please"
23:40:55 <copumpkin> ddarius: thank you! that's what I was looking for, I think
23:41:14 <maurer_> I am attempting to avoid enumerating the functions so that a user can use this as a quick constructor wrapper around something.
23:42:19 <ddarius> maurer_: Not for that purpose in GHC (or any other current Haskell implementations.)
23:42:37 <EliasAmaral> maurer_, do you mean marshalling?
23:42:53 <Eduard_Munteanu> Not sure about Haskell stuff, but there's CORBA and RPC that did this before.
23:43:14 <EliasAmaral> oh, yes, RPC
23:43:39 <Eduard_Munteanu> Also something like MPI might help if this is a clustering application.
23:43:44 <maurer_> EliasAmaral: Marshalling closures is known difficult.
23:44:01 <EliasAmaral> can't someone do this with marshalling + rpc? (but there is the problem of solving function identity. maybe you need some magic at compile time, and both peers having the same compiler..)
23:44:03 <maurer_> I'm trying to reference a function that already exists on the remote machine.
23:44:26 <ddarius> Eduard_Munteanu: That will still require effectively "enumerating" the remote functions.
23:45:22 <maurer_> My hope was something more along the lines of a way to instruct the binary to do the equivalent of a symbol lookup on a dynamic library, on itself, and bring that into existence as a closure
23:45:56 <maurer_> But I suppose stuff like that doesn't exist.
23:46:14 <EliasAmaral> maurer_, can't you write a function that receives a string and call the appropriate code? you can make a macro that reads the source code and build such cases if they are too much
23:47:04 <maurer_> EliasAmaral: Yes, I could, and this is likely what I will do, but I was hoping to avoid that.
23:47:27 <Eduard_Munteanu> Mmm... maybe this helps? http://www.haskell.org/ghc/docs/6.10.3/html/libraries/unix/System-Posix-DynamicLinker.html
23:47:54 <Eduard_Munteanu> (That's what I'd do to get some reflection capabilities in C code)
23:48:04 <edwardk> bikeshedding: namespace for an imperative-as-all-hell workstealing deque implementation?
23:48:08 <maurer_> Unfortunately my hope is to reflect on haskell code :P
23:48:13 <Eduard_Munteanu> dlopen(), lookup the symbol by name, get an address, call.
23:48:41 * Eduard_Munteanu is not sure how/if Haskell mangles top-level symbol names.
23:49:00 <ddarius> edwardk: In what language?
23:49:05 <edwardk> haskell
23:49:15 <edwardk> one sec i'll hpaste
23:49:24 <ddarius> Eduard_Munteanu: The top level symbol may not even exist.
23:49:24 <maurer_> Eduard_Munteanu: Do you have a good way of translating a pointer into an object?
23:49:38 <ddarius> edwardk: Data.Deque.WorkStealing.IO
23:49:40 <maurer_> Eduard_Munteanu: I didn't think unsafeCoerce could do that.
23:50:07 <edwardk> http://hpaste.org/42854/a_circular_workstealing_deque
23:50:08 <Eduard_Munteanu> I was thinking about calling the function. Isn't that what you want to do?
23:50:26 <maurer_> Eduard_Munteanu: In the end, but it's a haskell function I'd like to call
23:50:41 <maurer_> So the goal is to get a haskell object that is the function.
23:51:13 <Eduard_Munteanu> Well you can call Haskell from C and you can call C from Haskell.
23:51:39 <Eduard_Munteanu> But if ddarius says that, I'm not sure.
23:51:46 <ddarius> edwardk: Is this the dynamic circular work-stealing deque subject to patent number 7346753?
23:51:46 <edwardk> well, i suppose any workstealing deque would be in IO ;)
23:51:50 <edwardk> probably
23:52:14 <edwardk> i wanted a deque i could use for profiling purposes
23:53:16 <edwardk> this has the benefit of being the easiest WS deque implementation i know how to build quickly ;)
23:53:24 <edwardk> and has fewer moving parts than most
23:53:38 <edwardk> though its not safely portable to non-intel platforms
23:53:57 <copumpkin> edwardk: damn, ddarius and I could've witnessed the magic being performed, had we only stopped by your place
23:54:00 <edwardk> since it relies heavily on write order consistency
23:54:04 <edwardk> hah
23:54:15 <edwardk> this is where the magic happens baby ;)
23:54:20 <copumpkin> lol
23:54:23 <ddarius> edwardk: Are you using one space indentation?
23:54:51 <maurer_> I guess I'll just go for the "enumerating functions" approach.
23:54:52 <edwardk> 2, but i went to 1 space for indenting thens and else's under if's and missed a few
23:57:08 <ddarius> maurer_: You could use TH and write your entire program in a giant TH splice and quasiquotation and have it do the enumeration for you.
23:57:58 <EliasAmaral> Work-stealing is a popular technique for implementing load balancing, where each parallel thread maintains its own work set of items and occasionally steals items from the sets of other threads.
23:58:10 <EliasAmaral> is this the same work stealing?
23:58:14 <edwardk> EliasAmaral: yeah
23:58:15 <maurer_> ddarius: Very much not worth it. I'm fine with the enumeration myself, it was mostly from a point of view of "X would be nice, I should see if there's a way to do it in case others want to use it"
23:58:32 <ddarius> maurer_: It was a bit of a joke.
23:58:41 <ddarius> EliasAmaral: Uses more quotation marks.
23:58:47 <ddarius> -s
23:58:58 <EliasAmaral> ddarius, what?
23:59:00 <edwardk> EliasAmaral: basically i started porting some of my more traditional task-parallelism code to haskell to see how it looks
23:59:01 <maurer_> I now have another stupid question--is it possible to do a parameterized type where certain constructors are only valid for certain properties of the target type?
23:59:12 <edwardk> and i needed a scheduler ;)
23:59:34 <maurer_> i.e. Foo a = Construct1 a, Foo [a] = Construct2 a
23:59:43 <maurer_> Where Foo is the new type I'm trying to declare
