00:00:22 <Lycurgus> a relatively large portion of whom frequent this channel I think
00:00:26 <CrazyMug> Lycurgus: Do you mean that it has a kind of ubiquity?
00:00:38 <Lycurgus> no
00:00:53 <kuffaar> CrazyMug: Python 3 is radically backward incompatible, yes
00:01:07 <kuffaar> There's a lot of resistance to adopt it
00:01:24 <Lycurgus> I mean that it has a lang trynna to reinvent everything in itself aspect like java
00:01:29 <pastorn> kuffaar: but isn't the incompabilities fixing bad design choices?
00:01:36 <pastorn> (to start with)
00:01:44 <kuffaar> CrazyMug just look at how minor the differences between GHC 7 and GHC 6 are, yet nearly everybody uses 6 in here and recommends the use of 6
00:01:51 <kuffaar> pastorn yes
00:02:04 <kuffaar> I have no problem with backward incompatibility honestly, I like radical changes
00:02:08 <kuffaar> If they are for the better
00:02:17 <kuffaar> A recent change in Ruby rendered nearly all of my code invalid
00:02:18 <kuffaar> lol
00:02:34 <Saizan> Lycurgus: it's just that papers that use ocaml get so ugly that noone can read them :)
00:02:39 <pastorn> kuffaar: what was changed?
00:02:59 <Lycurgus> Saizan, i c :)
00:04:02 <CrazyMug> The person who introduced me to Haskell is a pretty major dude, and he said that Epigram was way over his head (but I'm sure some people here will claim it's easy).
00:04:17 <Saizan> i recommend 6 not because of language changes btw, (since those are controlled by flags anyway), but because most package's descriptions are not yet updated to work with the new versions of the core libs
00:04:43 <kuffaar> pastorn: The behaviour of require changed, it would no longer include "." in the paths for that by default, I think
00:04:49 <kuffaar> So you are now supposed to use require_relative for that
00:04:55 <kuffaar> Which is a really long name though :[
00:05:06 <joe6> Does this not violate the monadic behaviour: :t (const 1 "junk") = (const 1 "junk") :: Monad m => m Exp
00:05:09 <joe6> (const 1 "junk") >>= pprint :: [Char]
00:05:17 <pastorn> Saizan: the major stopping point is that the cabal-install version on hackage isn't compatible with ghc7
00:05:20 <joe6> where m Exp is turned to a pure [Char]?
00:05:23 <Lycurgus> an incompatibility like that was not smart move but very consistent for the haskell culture
00:05:35 <copumpkin> joe6: I have no idea what you just asked
00:05:37 <Lycurgus> *a smart move
00:05:39 <joe6> don't you need a liftM or <- for that?
00:06:09 <kuffaar> Saizan: If nobody makes the jump then there is little to no pressure to do anything about that
00:06:14 <joe6> copumpkin: when we have an expression that returns (m x), we use <- to remove the m?
00:06:23 <pastorn> @type liftM const
00:06:24 <lambdabot> forall a1 b (m :: * -> *). (Monad m) => m a1 -> m (b -> a1)
00:06:30 <pastorn> @type liftM2 const
00:06:31 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m a1
00:06:35 <Saizan> kuffaar: the jump will be made when we have an haskell platform release for ghc 7
00:06:43 <joe6> pastorn: but the m still persists?
00:06:47 <Lycurgus> prolly got an arrogance within arrogance thing with ghc
00:06:50 <kuffaar> Saizan: Why isn't there one yet?
00:06:55 <pastorn> joe6: well, liftM gives you that m
00:06:56 <copumpkin> joe6: you never take anything out of the m
00:07:01 <copumpkin> joe6: you put things into it
00:07:02 <joe6> pastorn: to get rid of the m, we use <-
00:07:10 <pastorn> joe6: yes
00:07:15 <copumpkin> joe6: that isn't getting rid of it
00:07:32 <copumpkin> it's putting the thing you wanted to feed the sans-m thing into, into the m
00:07:36 <CrazyMug> So is there any forum out there where people discuss all sorts of advanced computer science topics that I might not have any reason to learn right now, but once you start you get intrigued?
00:07:52 <pastorn> CrazyMug: lambdatheultimate
00:07:56 <CrazyMug> If there is not, I was thinking of starting one.
00:08:00 <CrazyMug> Ah, ok.
00:08:15 <pastorn> but it's mostly language related
00:08:21 <joe6> copumpkin: can you please explain? "sans-m thing into, into the m", the <- does the sans m thing, correct?
00:08:24 <kuffaar> I wish they would finally fix the bootstrapping process in GHC so you can make an AMD64 GHC 7 for Windows :/
00:08:33 <joe6> in this scenario, is pprint doing that?
00:08:44 <copumpkin> joe6: well, that's what I mean by having no clue what you were talking about
00:08:45 <alpounet> joe6, yes but that's only local to a do-block
00:08:55 <kuffaar> Cabal also needs parallel compilation badly
00:08:59 <alpounet> you can't extract a monadic value
00:09:04 <alpounet> and just return it
00:09:07 <copumpkin> the expressions you wrote made no sense to me, and I'm not doing that "being deliberately obtuse on IRC because you made a tiny typo"
00:09:15 <alpounet> that's the point of using a monad for IO
00:09:30 <kuffaar> It's quite baffling that there is no parallel compilation yet, it seems like such a basic thing, that's one of the first things I would implement in any building system.
00:09:39 <joe6> *Test Language.Haskell.TH> :t (const 1 "junk") >>= pprint
00:09:46 <kuffaar> Cabal must have been around for a long time now
00:09:49 <joe6> (const 1 "junk") >>= pprint :: [Char]
00:09:56 <CrazyMug> See I have this idea for a place where people just talk about all sorts of things, some languages and related theory, some computer vision stuff, a lot of math, all sorts of different areas.
00:10:04 <Lycurgus> about 4 years iirc
00:10:14 <joe6> copumpkin: there is no typo. pprint is converting the m Exp to [Char]
00:10:51 <copumpkin> oh, you have some weird instance in scope from your Test
00:10:54 <joe6> alpounet: yes, that is what I thought and this expression made me question that.
00:11:00 <CrazyMug> You can pretty much always find a forum for a specific topic, but I've been spending time at a hackerspace for the last year or so and it's been fascinating learning a little bit of all these things.
00:11:04 <Saizan> ?type Language.Haskell.TH.pprint
00:11:05 <lambdabot> forall a. (Language.Haskell.TH.Ppr.Ppr a) => a -> String
00:11:12 <CrazyMug> So I'd want a forum like that, only about CS.
00:11:16 <copumpkin> you have to have some weird Num instance for that to work
00:11:30 <copumpkin> you have Num [a] or something?
00:12:13 <alpounet> joe6, the monad here seems to be the list one
00:12:15 <copumpkin> joe6: that works because [] is a Monad
00:12:30 <joe6> copumpkin: gotcha: it is not my code, i am trying to understand it. I doubt that there is something in Test. I think it is from the Template haskell tutorial
00:12:30 <copumpkin> but the fact that you're using 1 and const threw me off
00:12:40 <copumpkin> no, TH doesn't have a Num [a] instance :P
00:12:58 <copumpkin> not sure where else the instance is coming from
00:13:01 <copumpkin> since you only have two modules loaded
00:13:08 <joe6> copumpkin: const is something that I created, a test function.
00:13:20 <copumpkin> oh, it's not the standard const?
00:13:24 <copumpkin> then all bets are off :P
00:13:34 <joe6> this is the tutorial that I am using: http://web.archive.org/web/20080822110747/haskell.org/bz/th3.htm
00:13:59 <joe6> copumpkin: it is not the standard const
00:14:05 <copumpkin> aha
00:14:16 <joe6> the tutorial calls it cnst and I called it const
00:14:33 <Saizan> joe6: :t const ?
00:15:08 <joe6> alpounet: i think I understand what you are saying. There is still a monad, but instead of IO monad or something it is the list monad?
00:15:38 <Saizan> yep
00:16:00 <Saizan> it can only be the list monad because pprint returns a list
00:16:09 <joe6> alpounet: in that scenario: why do we need the <- for strings, it is already a list monad.
00:16:33 <joe6> and how can we go from String to Char, isn't that pollution?
00:17:00 <joe6> Saizan: (const 1 "junk") :: Monad m => m Exp
00:17:33 <Saizan> yeah, so you are using it with the type [Exp]
00:17:54 <alpounet> joe6, when you write : a <- mylist
00:17:59 <alpounet> it picks an element from the list
00:18:04 <joe6> Saizan: I did not get what you meant: (const 1 "junk") >>= pprint :: [Char]
00:18:11 <joe6> > t pprint
00:18:13 <lambdabot>   Not in scope: `pprint'
00:18:18 <alpounet> (and will repeat it with all elements)
00:18:24 <joe6> pprint :: Ppr a => a -> String
00:18:33 <Saizan> String = [Char]
00:18:44 <Saizan> ?type (>>=)
00:18:45 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
00:18:45 <joe6> yes, i know.
00:19:02 <joe6> where is the m in [Char] ? the list monad?
00:19:14 <Saizan> m = []
00:19:24 <Saizan> [Char] = [] Char
00:19:37 <alpounet> > let foo l = do { x <- l; return [x, x+1, x+2] } in foo [1..10]
00:19:38 <Saizan> list has some syntactic sugar
00:19:38 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10],[9,10,11]...
00:19:48 <joe6> alpounet: haha, so <- are not just restricted to do, they can be used anywhere.
00:20:12 <alpounet> joe6, they are not restricted to IO, if that's what you are asking
00:21:18 <alpounet> they of course behave differently depending on the monad you're in
00:21:38 <joe6> Saizan: then something like fst should not be possible, correct? fst [1..10] = 1 :: [Int] -> Int
00:21:55 <joe6> there is no monad in the Int return>
00:22:58 <joe6> > fst [1..10]
00:22:59 <lambdabot>   Couldn't match expected type `(a, b)' against inferred type `[a1]'
00:23:04 <Saizan> > head [1..10]
00:23:05 <lambdabot>   1
00:23:08 <joe6> > head [1..10]
00:23:09 <lambdabot>   1
00:23:14 <joe6> sorry, head, I meant.
00:23:26 <Saizan> joe6: the fact that M is a monad doesn't prevent you to write a function M a -> a
00:23:43 <Saizan> it's just not part of the monad interface
00:23:54 <Saizan> so for every particular monad it might or might not be possible
00:24:02 <joe6> Saizan: That was what I was missing. I was under the impression that M a -> a, is only possible with <-
00:24:15 <accel> hackage needs some changes; where if "cabal install blah" doesn't compile, then the latest blah should not be accepted
00:24:38 <accel> it's frustrating having cabal install failures all over the place
00:24:50 <alpounet> accel, what about missing C libraries then?
00:24:50 <joe6> Saizan: I thought that the whole point about purity is that once polluted, it stays polluted. I think I got the basics wrong.
00:24:55 <alpounet> sometimes the failure is due to the user
00:24:58 <alpounet> but not often, i admit it
00:25:03 <Saizan> joe6: not all monads are IO
00:25:28 <joe6> Saizan: Is that purity thing restricted to the IO monad?
00:25:35 <Saizan> joe6: yeah
00:25:52 <joe6> Saizan: Oh, ok. That was what I was missing.
00:26:23 <accel> Configuring gtksourceview2-0.12.2...
00:26:24 <accel> setup: The pkg-config package gtksourceview-2.0 version >=2.0.2 is required
00:26:24 <accel> but it could not be found.
00:26:26 <joe6> Saizan: I guess purity is specific to IO and monad is a totally different beast, a small part of which is an IO monad.
00:26:26 <accel> how do I fix that?
00:26:37 <Saizan> accel: install the C lib
00:27:13 <Saizan> joe6: well, "impurity" is specific to IO, but yeah that's the concept
00:27:39 <joe6> Saizan: So, IO a -> a, is not possible, except with the <-
00:27:54 <Saizan> joe6: <- doesn't really do anything like IO a -> a
00:27:57 <joe6> Saizan: sorry for the reptition.
00:28:15 <joe6> Saizan: why do you say that?
00:28:27 <Saizan> joe6: "do x <- m1; m2;" is syntactic sugar for "m1 >>= \x -> m2"
00:28:39 <accel> Saizan: that fixed it; thanks
00:28:52 <joe6> Saizan: That is awesome. Did not know that.
00:29:26 <joe6> Saizan: This whole do notation actually abstracts the concepts.
00:29:28 <accel> what bad thing would happen if in addition to >>= (m a) -> (a -> m b) -> (m b); there was also a function "evil :: (m a) -> a" ? what could you do with "evil" that would fuck up monads?
00:29:30 <Saizan> joe6: so it's not so much extracting anything out of m1, it's just accepting a callback "\x -> m2" and making sure it'll get called with the result of m1
00:31:16 <joe6> Saizan: Thanks a lot. That was very helpful. Thanks for being patient and helping me understand this concept.
00:31:31 <Saizan> accel: that'd destroy referential transparency if used with (GHC's implementation of) IO, be a partial function, or simply not make sense at all 
00:31:38 <Saizan> joe6: np :)
00:31:59 <joe6> Saizan: is there any good paper that can explain the concepts in these terms: "it's just accepting a callback "\x -> m2" "?
00:32:14 <Saizan> accel: depending on the monad, i mean
00:32:28 <accel> Saizan: in theory, I understand something bad happens; in practice, can you show me a piece of code?
00:32:41 <accel> i.e. I see all these pieces of code online about how monads work / how they're implemented
00:32:58 <accel> but I fail to see a distinction of: "if you don't use a monad, then someone could do XYZ; and all hell breaks lose"
00:33:13 <joe6> Saizan: in accel's illustration, should it not be "evil :: (IO a) -> a" ?
00:33:28 <joe6> and that there is nothnig wrong with m a -> a
00:33:58 <accel> firefox
00:34:16 <Saizan> joe6: http://www.haskell.org/haskellwiki/Monads_as_computation <- this doesn't use those words, but it still illustrates the concepts
00:34:53 <joe6> Saizan: Thanks a lot. These days, I am starting to think of monads as Type constructors. Is that a bad way of looking at it?
00:34:53 <Saizan> joe6: wadler's "essence of functional programming" is a good read too
00:35:18 <joe6> Saizan: I tried the wadler's paper, but I got lost in the mathematical notation.
00:35:34 <Saizan> joe6: monads are type constructors which support a certain interface
00:36:10 <joe6> interface == functionality == functions??
00:36:18 <Saizan> yeah
00:36:44 <Saizan> joe6: do you know what a type class is?
00:36:54 <joe6> Saizan: yes, I think I do.
00:37:10 <joe6> a typeclass basically encapsulates certain functions
00:37:16 <Saizan> yeah
00:37:42 <Saizan> and there's a Monad typeclass, and type constructors that are instances of Monad are called monads :)
00:38:06 <accel> so if you had evil :: IO a -> a
00:38:08 <Saizan> do notation is just syntactic sugar for uses of the methods of Monad
00:38:08 <accel> what do you break?
00:38:20 <joe6> yes, and as I recall, anything belonging to the monad typeclass has to support >>= and a few such functions.
00:38:29 <Saizan> yep
00:39:22 <joe6> What I did not get was as everyone talks about IO and monad in the same breath, I associated purity with no m a -> a, instead of being IO a -> a
00:39:58 <Saizan> accel: you can make functions whose result isn't completely determined by their inputs
00:40:10 <pikhq> The whole pure/impure thing actually has hardly anything to do with monads.
00:40:33 <Saizan> joe6: there are quite a few bad monad tutorials out there
00:40:37 <dolio> It has nothing to do with monads, except that monads are a pure way to handle IO.
00:40:38 <pikhq> It merely *happens* to be the case that IO forms a monad, and that it's useful to use it as such.
00:40:42 <alpounet> Saizan, without any constraint on 'a' in accel's example ?
00:40:53 <alpounet> (without undefined too, ofc)
00:41:03 <joe6> pikhq: yes, you are so correct. I just understood it now.
00:41:03 <dolio> And by monads, I mean using a DSL for IO, which is a monad.
00:41:15 <accel> Saizan: example ?
00:41:34 <accel> Saizan: I don't doubt you; I just want to see an example and go "ah, that's how it would happen"
00:41:35 <mornfall> alpounet: With IO a -> a, he means, I guess.
00:41:51 <mornfall> Like, unsafePerformIO. Or evil, as accel named it. :)
00:41:58 <Saizan> accel: f x = x ++ evil getLine
00:42:05 <alpounet> yeah yeah mornfall 
00:42:39 <alpounet> but then you'd get stoned to death by #haskell
00:43:16 <accel> Saizan: so , I can then call 'f "Hello"' and 'f "Hello"' , and get back different resutls if getLine is called twice?
00:43:17 <mornfall> alpounet: Probably not, considering how it's part of the language, and some popular libraries have impure functions with pure types in them.
00:43:18 <pastorn> i don't understand why people rage on unsafePerofrmIO
00:43:23 <Saizan> well, we'd just leave you trying to reason about the side-effects wrt laziness
00:43:34 <pastorn> it's great when you might need performance & whatnot
00:43:38 <alpounet> mornfall, that's mostly when dealing with FFI code right ?
00:43:43 <Saizan> accel: yep
00:43:50 <accel> how does one use manatee?
00:43:54 <accel> i just installed it, and all I get is this search box
00:43:57 <mornfall> alpounet: Not only. Sadly.
00:44:22 <alpounet> then, it _should_ be when dealing with FFI code mostly, right? :P
00:44:37 <Saizan> it's completely fine to use unsafePerformIO once you're sure you're still exposing a referential transparent interface
00:44:40 <mornfall> alpounet: Well, it should, yes. :)
00:44:54 <Saizan> *tially
00:44:59 <mornfall> alpounet: If you have some FFI which is in fact pure, you need magic (unsafePerformIO) to tell the system.
00:45:06 <accel> wtf is leksah-server doing in the background?
00:45:18 <mornfall> Magic. :D
00:45:30 <alpounet> mornfall, like when creating a copy of a ByteString in the C code
00:45:37 <jutaro> accel: It interfaces to ghc-api
00:45:52 <mornfall> alpounet: Hm?
00:46:02 <jutaro> accel: it provides the meta data for leksah
00:46:09 <accel> jutaro: it's doing all types of weird wgets in the background
00:46:15 <accel> getting lots of 494's
00:46:15 <mornfall> alpounet: That is a very unfortunate example. :P
00:46:20 <accel> Checking interface blahblahblah .....
00:46:38 <alpounet> how so?
00:46:45 <accel> --2011-01-29 00:59:25--  http://www.leksah.org/metadata-0.8/gtk-0.11.2.lkshm
00:46:45 <accel> Resolving www.leksah.org... 87.230.23.84
00:46:45 <accel> Connecting to www.leksah.org|87.230.23.84|:80... connected.
00:46:45 <accel> HTTP request sent, awaiting response... 404 Not Found
00:46:46 <mornfall> alpounet: Well, that should definitely not be pure.
00:46:46 <accel> 2011-01-29 00:59:26 ERROR 404: Not Found.
00:46:52 <accel> wtf is all that with leksah-server ?
00:47:01 <mornfall> alpounet: Considering how two copies of a bytestring are indistinguishable in pure code.
00:47:04 <jutaro> accel: when you installed a new package, it first tries to download prebuild metadata, cause this is quicker
00:47:14 <mornfall> alpounet: You call copy for the side effect.
00:47:17 <pastorn> joe6: stop being so bad at mirkking
00:47:39 <jutaro> you can change it in the config if you don't like this
00:47:39 <joe6> pastorn: what is mirkking?
00:47:45 <pastorn> lolz
00:47:47 <mornfall> alpounet: (Copy behaves, as far as pure code is concerned, as id.)
00:48:09 <mornfall> (And having an FFI binding to id would be silly at best.)
00:48:24 <alpounet> mornfall, hm, i haven't been very clear sorry. I meant, for example, when doing something on a bytestring (like BS.take) and returning a new one
00:48:26 <pastorn> joe6: using IRC
00:48:42 <Saizan> mornfall: so par shouldn't be pure either?
00:49:08 <mornfall> :t par
00:49:09 <lambdabot> forall a b. a -> b -> b
00:49:15 <mornfall> :t const
00:49:17 <lambdabot> forall a b. a -> b -> a
00:49:17 <jutaro> accel: check preferences/metdata/..
00:49:22 <mornfall> Well, almost. :P
00:49:27 <joe6> pastorn: yes, on irssi.
00:49:35 <mornfall> Saizan: par has no side effects either... it's just a hint.
00:50:11 <Saizan> copy :: ByteString -> ByteString would have no side effects either, from that POV
00:50:32 <mornfall> Saizan: Well, copy is not a hint though, so it's completely useless. :)
00:50:34 <Saizan> yet both would be used only for the side-effects
00:50:45 <joe6> pastorn: but, I am a very novice user of irssi. so, I am not sure if there is something that I do not know.
00:50:46 <Saizan> i don't see why.
00:50:50 <mornfall> Saizan: You can't extract useful work out of copy.
00:50:57 <Saizan> sure you do
00:50:58 <pastorn> joe6: i sent you private messages
00:51:00 <mornfall> How?
00:51:22 <joe6> pastorn: sorry, I do not know how to check private messages. let me do the query pastorn and see if i see any.
00:51:29 <accel> jutaro: the UI is definitely interesting
00:51:48 <mornfall> Well, for fixing memory leaks maybe.
00:51:54 <pastorn> joe6: probably Alt + nbr for the query session to switch
00:51:59 <Saizan> let x = B.take 5 largeBS; y = copy x; .... use only y ... <- then largeBS can be GC'ed, while if you kept using x it couldn't because it references the same memory
00:52:11 <jutaro> accel: Unfortunately it has some bugs, that needs to be fixed
00:52:37 <mornfall> Saizan: Yeah, that's because pure programs aren't pure, anyway. :P
00:53:44 <mornfall> Computations take memory and that's a side effect, and you can't fix it.
00:55:01 <mornfall> (That's maybe why it's so hard to write good programs in Haskell...)
00:55:20 <Saizan> nah, it's hard to write _bad_ programs in haskell
00:55:30 <mornfall> Saizan: Oh?
00:55:42 <mornfall> I use a couple and they are all pretty bad.
00:55:44 <Saizan> that's why it's harder to write programs in it, most of them are bad :P
00:56:18 <mornfall> Yeah, but they were easy to write, since they are, well, written. :P
00:56:39 <mornfall> Sort of, anyway.
00:56:51 <mornfall> Wasn't easy to write the primary virtue of functional?
00:57:05 <Saizan> easy to reason about
00:57:24 <mornfall> It's easier to write correct programs in Haskell, as long as you have infinite and infinitely fast memory. ;)
00:57:32 <accel> jutaro: is there a way to get an interactive ghci inside of leksah?
00:57:49 <mornfall> Saizan: Reason about correctness, ignoring memory issues.
00:58:02 <mornfall> Reasoning about memory behaviour of Haskell programs seems far from easy to me.
00:58:57 <Saizan> yeah, primarily about correctness, memory behaviour is not as hard as they make it sound though
00:59:10 <mornfall> Saizan: Well, I have tried and it seemed pretty darn hard.
01:00:57 <Saizan> you've to write your code with a minimum of consideration of the operational semantics, otherwise you get a mess
01:01:15 <mornfall> Saizan: Meaning what?
01:01:29 <mornfall> Ignore how the machine works?
01:01:37 <mornfall> That's what I did to get massive leaks. :)
01:02:15 <Saizan> you need the consideration
01:02:32 <mornfall> Well, you need a lot of it.
01:02:36 <mornfall> That's the problem.
01:03:16 <mornfall> Haskell makes it really hard to force a complex value.
01:03:21 <Saizan> no, you don't even need to use the real evaluation strategy, coarse approximations work very well most of the time
01:04:21 <mornfall> (When you have to pattern-match on a length of something just to garbage-collect memory, something is definitely wrong.)
01:04:42 <Saizan> getting to the point where you've a complex value that you need to force all at once is probably a sign you haven't paid the right attention in the construction of said value
01:05:29 <mornfall> Saizan: I don't need to force it all at once. I just need to keep it from growing infinitely.
01:05:42 * aristid is proud to have written his first Template Haskell (and i hope that it even is a good choice to use it)
01:05:46 <mornfall> (This is a tree in a state monad in a lengthy computation.)
01:06:26 <Saizan> that's the standard case of an accumulator, which you should force as you go, after each transformation
01:06:36 <mornfall> Saizan: Right. And forcing it is... hard.
01:06:57 <Saizan> that's not my experience
01:07:01 <mornfall> In fact, I simply don't know how to force it.
01:07:16 <mornfall> I spent several days working on the problem.
01:07:28 <mornfall> With the result being that I made the manipulation functions stricter by adding hacks.
01:07:40 <mornfall> (Since the simple things like seq, deepseq etc. produced no results...)
01:08:13 <mornfall> Which sucks hugely, but I don't have a fix.
01:08:22 <Saizan> (you're doing something wrong then)
01:08:30 <mornfall> Sure I'm doing something wrong.
01:08:53 <mornfall> The question is what, and it's worth a lot.
01:09:35 <Saizan> there's a difference between things that are hard to learn, and things that are hard even if you know how to do them
01:10:00 <mornfall> Well, if something is so hard to learn that you never do, it doesn't make a difference anyway.
01:10:08 <Saizan> it's surely not so easy to get used to lazy evaluation at first
01:10:42 <Saizan> fortunately that's not the case :)
01:10:56 <mornfall> Well, I have been doing Haskell for a while, and I can write fast programs in it, with good memory behaviour. But for some kinds of programs... tough luck.
01:11:30 <mornfall> I can get the behaviour I want, in the end (at least most of the time), but not by the means I want.
01:11:47 <Saizan> do you understand why?
01:11:52 <mornfall> Hell no. :)
01:12:02 <mornfall> And I haven't found anyone who'd be able / care to explain.
01:12:41 <Saizan> you should investigate by trying to do some evaluation
01:13:38 <mornfall> Investigate what? Why the normal forcing doesn't work? Well, I *know* the structure is not evaluated. I don't know how to make it evaluate.
01:14:06 <mornfall> I can spend some time with trace, sure, but that'll only tell me what is and what isn't evaluated, not why.
01:14:14 <Saizan> not trace.
01:14:21 <mornfall> But?
01:14:30 <augur> conditional prolog matches are interesting
01:14:45 <Saizan> i meant unfolding the evaluation by hand, reducing expressions 
01:14:51 <augur> p :- q -> r.
01:14:56 <augur> tres interessante
01:15:18 <mornfall> @src seq
01:15:18 <lambdabot> Source not found. My brain just exploded
01:15:25 <mornfall> Can't do. :)
01:15:46 <gienah> I find bang patterns easier to understand than seq
01:15:55 <mornfall> Yeah, probably understanding how NFData works etc. would help.
01:16:00 <mornfall> (Well, how it doesn't work, I mean.)
01:17:21 <Saizan> seq is quite simple, seq x y reduces to y only when x is of the form (C ..) where C is a data constructor or a \x -> 
01:17:45 <mornfall> Saizan: Right, and deepseq does seq chaining on all constructor fields.
01:17:52 <mornfall> It still doesn't work.
01:18:11 <Saizan> mornfall: do you expect "seq x x" to be useful?
01:18:29 <mornfall> I expect deepseq x x to be.
01:18:39 <Saizan> ?type deepseq
01:18:40 <lambdabot> Not in scope: `deepseq'
01:18:44 <joe6> Saizan: I am noticing that -ddump-tc helps by removing a lot of the abstractions.
01:18:45 <Saizan> ?hoogle deepseq
01:18:45 <lambdabot> No results found
01:18:53 <mornfall> Control.DeepSeq or something like that, anyway
01:18:55 <mornfall> NFData
01:19:08 <Saizan> ?type Control.DeepSeq.deepseq
01:19:09 <lambdabot> forall a b. (Control.DeepSeq.NFData a) => a -> b -> b
01:19:21 <Saizan> mornfall: ah, ok, i thought it was a type error
01:19:37 <mornfall> Why?
01:19:46 <Saizan> ?type rnf
01:19:47 <lambdabot> Not in scope: `rnf'
01:19:52 <mornfall> rnf is :: ... -> ()
01:19:57 <Saizan> yeah
01:20:07 <Saizan> i was confusing it with that
01:20:22 <mornfall> deepseq is probably something like rnf foo `seq` foo
01:20:48 <Saizan> deepseq x y = rnf x `seq` y
01:20:48 <mornfall> I mean bar.
01:20:50 <mornfall> Whatever. :)
01:21:00 <mornfall> Right.
01:21:20 <Saizan> anyhow, "deepseq x x" could be useful in some cases, but it's highly suspect
01:21:54 <Saizan> in particular if you don't also add enough strictness to force the result of that to at least WHNF, it still does nothing.
01:22:29 <mornfall> So all you can do to force something is to count it and pattern match on the count, anyway?
01:22:42 <Saizan> no
01:22:59 <mornfall> Well, the only thing that I found worked reliably. :P
01:23:06 <Saizan> the point is that you've to tie the deepseq to something that gets definitely evaluated, like something you pattern match on.
01:23:30 <Saizan> e.g. pattern matching on the () of rnf
01:24:26 <mornfall> Can I have force :: a -> a; force x = case rnf x of () -> x? Or that's not going to work either?
01:24:42 <Saizan> that's not going to work either.
01:24:55 <mornfall> Cool. Why? :)
01:24:57 <Saizan> i.e. that's just deepseq x x
01:25:13 <mornfall> Well, is it?
01:25:19 <mornfall> deepseq doesn't pattern match...
01:25:32 <mornfall> Ok, I see.
01:25:40 <mornfall> Unless you look at x, the pattern match never happens.
01:25:49 <Saizan> exactly.
01:26:20 <Saizan> forcing is always about chaining
01:26:42 <mornfall> But I still don't understand my original problem, since I *do* look at x, all the time. Any modification of the tree needs to traverse it first.
01:26:57 <mornfall> So with the above force after each modification, it shouldn't leak.
01:29:11 <mornfall> (There's ultimately an IO source and an IO sink, and the tree definitely grows out of all bounds... but it's been a while, so maybe doing it again I'd be more successful.)
01:29:50 <mornfall> (Even though the number and size of elements in the tree is bound by a constant.)
01:30:18 <Saizan> having g x = deepseq x x; if you've a loop that goes .. modify f; modify (\x -> deepseq x x); then your state just gets an huge thunk of g (f (g (f (g (f ...)) 
01:30:59 <Saizan> only if you look at the tree to decide what to do next it'd will get demanded 
01:31:22 <Saizan> within the loop, i mean
01:33:00 <Saizan> ?src foldl'
01:33:00 <lambdabot> foldl' f a []     = a
01:33:00 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
01:33:57 <mornfall> Well, the modify does get evaluated periodically. Just not all the way.
01:34:15 <mornfall> I'll really need to revisit that code, but that needs time. :|
01:34:36 <mornfall> And I'm reluctant to touch it, given how much time it took to get it working in reasonable space.
01:35:39 <Saizan> seq is asking the evaluation to look at a' before it can proceed with the recursion, if it was "foldl' f a (x:xs) = foldl' f (seq a (f a x)) xs" it'd be useless
01:35:46 <mornfall> I think my main problem anyway is that inserting into Data.Map is not fully evaluated even if you query the map. Or something like that.
01:36:54 <Saizan> the tree and the keys are evaluated, the value isn't, but you can make sure to evaluate the value before you insert it
01:37:56 <mornfall> I ended up with items = countmap items' `seq` items'
01:38:05 <joe6> i am trying to do this: Q [Dec] -> ExpQ, Hoogle says that LetE :: [Dec] -> Exp -> Exp. But, I cannot get something like :t letE (deriveAll 'Test "PFTest") (runQ [| |]) to work.
01:38:10 <joe6> any suggestions, please?
01:39:43 <joe6> (deriveAll 'Test "PFTest") :: Q [Dec]
01:40:04 <aristid> joe6: letE (deriveAll 'Test "PFTest") =<< [| |]
01:40:28 <Saizan> ?type Language.Haskell.Syntax.letE
01:40:28 <joe6> aristid: cool, thanks. will check up on the =<< operator
01:40:29 <lambdabot> Not in scope: `Language.Haskell.Syntax.letE'
01:40:30 <mornfall> Saizan: Which would make me think that deepseq items' items' would work just as well. I *might* have failed to try that though.
01:41:03 <aristid> joe6: you're using template haskell without knowing (=<<)? i think you should learn haskell without TH at first :)
01:41:17 <Saizan> mornfall: it's still a sign something is wrong with how you build that map
01:41:44 <joe6> i have been learning haskell, but I feel that unless I encounter something that I do not know I am not learning.
01:41:44 <aristid> joe6: actually it's letE :: [DecQ] -> ExpQ -> ExpQ
01:41:57 <aristid> joe6: so you just need letE (deriveAll 'Test "PFTest") [| xyz |]
01:42:00 <mornfall> Saizan: Yeah. But I guess it'll take couple more years of practice before I figure out what.
01:42:06 <joe6> joe6: ok, cool. thanks.
01:42:27 <joe6> aristid: ok, thanks a lot
01:43:15 <joe6> aristid: it is not working. I tried that: Couldn't match expected type `[DecQ]' with actual type `Q [Dec]'
01:43:15 <Saizan> mornfall: it takes much less, but you need to run some evaluations in your head or by hand first
01:43:44 <mornfall> Saizan: Well, that works for simple cases. I know how the evaluation proceeds.
01:43:48 <mornfall> At least in theory. :)
01:44:01 <joe6> i think I should some operator that does m a -> m b, and use [Dec] -> Exp
01:44:19 <aristid> :t sequence
01:44:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
01:44:20 <Saizan> do slightly more complex cases, do those that have a supripising memory behaviour for you.
01:44:29 <joe6> aristid: ok, thanks.
01:44:42 <aristid> joe6: sequence goes the other way round, so it does not help there.
01:45:41 <Saizan> i'd just go with do xs <- deriveAll ...; e <- [| .. |]; return $ LetE xs e
01:45:44 <joe6> aristid: oh, ok
01:45:54 <aristid> Saizan: with LetE instead of letE?
01:46:07 <Saizan> yeah, like i wrote
01:46:11 <aristid> is Q an Applicative?
01:46:25 <aristid> LetE <$> deriveAll ... <*> [| ... |]
01:46:59 <aristid> no, it's not :/
01:47:01 * aristid sad
01:48:50 <ziman> can you not make it Applicative yourself?
01:49:14 <aristid> ziman: yeah, but that would be an Orphan Instance
01:50:12 <Saizan> @hackage orphanage
01:50:12 <lambdabot> http://hackage.haskell.org/package/orphanage
01:50:39 <Saizan> someone will, at some point
02:02:41 <joe6> Saizan: does this make sense to you? http://hpaste.org/43409/joe
02:03:15 <joe6> Saizan: all I am trying to do is see what is created. I can do it with a simple runQ and it seems to have a similar type to the deriveAll do.
02:04:18 <joe6> Saizan: sorry, if it is a very basic question.
02:05:53 <Saizan> joe6: the problem there is that you are trying to mix the Q and the IO monads
02:06:25 <Saizan> joe6: you can't do that directly, but you can use runQ to convert a value in the Q monad to one in IO
02:06:45 <joe6> Saizan: but, this works: :t runQ [| 1 |]  >>= print
02:06:56 <joe6> but, the above is from m Exp to IO
02:07:09 <joe6> where m =  Language.Haskell.TH.Syntax.Quasi
02:07:22 <joe6> so, I assumed tha Q = Language.Haskell.TH.Syntax.Quasi
02:07:38 <joe6> so, my assumption is wrong? Q /] Language.Haskell.TH.Syntax.Quasi
02:07:50 <joe6> so, my assumption is wrong? Q /= Language.Haskell.TH.Syntax.Quasi
02:08:28 <Saizan> joe6: Quasi is a typeclass
02:08:29 <joe6> Saizan: there is an unQ.
02:08:37 <joe6> I think I can take it from here.
02:08:41 <joe6> Sorry about the bother.
02:08:49 <Saizan> IO is an instance of Quasi
02:11:51 <augur> Saizan: any interesting new research or papers or such that you've read recently?
02:13:18 <Saizan> i've seen some videos about new foundations for mathematics and then tried to learn about fibrations from a book about categorical logic, interesting for you?:)
02:16:17 <augur> maybe!
02:16:22 <augur> categorical logic being?
02:17:07 <Saizan> phrasing logic/type theory with category theory, afaiu
02:17:15 <augur> hm
02:17:17 <Saizan> connecting it with topology
02:17:20 <augur> phrasing logic?
02:18:20 <Saizan> yeah, defining the formal system of a logic 
02:18:43 <Saizan> http://video.ias.edu/univalent <- the video
02:19:18 <augur> video! \o/
02:19:39 <Saizan> http://www.lfcs.inf.ed.ac.uk/reports/92/ECS-LFCS-92-208/ <- book
02:19:46 * hackagebot digestive-functors-blaze 0.0.2.2 - Snap backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-blaze-0.0.2.2 (JasperVanDerJeugt)
02:20:26 <augur> saizan, would it be fair to say that there's a striking similarity between continuation-based backtracking and lazy list generation of the same data?
02:21:46 <Saizan> well, the list monad is all about backtrackin, with depth first search, so yes
02:21:50 <augur> cause i noticed a similarity after poking around with implementing a backtracking parser that used thunk continuations to encode the alternative not chosen
02:22:09 <augur> and then i realized that the thunk continuations looked an awful like thunk-based lazy lists
02:22:23 <joe6> i have the dreaded "Template Haskell error: Can't do `reify' in the IO monad": http://hpaste.org/43410/joe
02:22:32 <joe6> any thoughts on how I can work through it, please?
02:23:50 <Saizan> putStrLn $(.... >>= lift . show)
02:25:10 <joe6> Saizan: thanks.
02:25:18 <augur> Saizan: what do you do
02:25:32 <augur> ive probably asked you this a million times but i dont have an offboard brain yet so
02:25:47 <Saizan> i'm a CS student
02:26:01 <augur> whereabouts?
02:26:16 <Saizan> Florence, Italy
02:26:41 <augur> !
02:27:21 <aristid> ?
02:28:40 <ion> ‽
02:28:48 <augur> Saizan: my school sells some brand of frozen food called firenze at its food courts.
02:28:52 <augur> ive yet to try any. >.>
02:28:55 <aristid> lol.
02:29:04 <Saizan> interesting.
02:29:58 <augur> its almost certainly utterly unrelated to florence.
02:30:15 <augur> oh but ponte vecchio is in florence!
02:30:18 <augur> ffuuu
02:30:49 <Saizan> maybe this should go to -blah if it continues :)
02:31:06 <Saizan> but yeah, it is
02:33:49 * hackagebot attoparsec-text 0.8.2.1 - Fast combinator parsing for texts  http://hackage.haskell.org/package/attoparsec-text-0.8.2.1 (FelipeLessa)
02:35:32 <kuffaar> What container do I want to use when I continuously add stuff at the end, remove stuff in the beginning and I need to read the first and the last element all the time?
02:35:52 <kuffaar> Was Seq suited for that?
02:36:14 <dibblego> yes or DList
02:43:22 <dolio> No, he doesn't want DList.
02:54:48 <Bynbo7> TacticalGrace: you about?
02:55:14 <HugoDaniel> what haskell testing package do you guys recommend ?
02:55:20 <HugoDaniel> i see a lot of them on hackage :(
02:55:23 <Bynbo7> quickcheck
02:55:29 <HugoDaniel> yeah, and unit tests ?
02:55:46 <Bynbo7> eh, no idea. hunit?
02:57:20 <HugoDaniel> meh
02:57:33 <dibblego> I use test-framework
02:58:02 <dibblego> HTF looks interesting
03:00:33 <HugoDaniel> indeed
03:00:34 <HugoDaniel> coolness
03:00:39 <HugoDaniel> thanks you very nice
03:04:10 <TacticalGrace> Bynbo7: hey
03:04:20 <Bynbo7> o/
03:04:34 <Bynbo7> I was wondering if you'd had any luck with the llvm bindings on OS X
03:04:57 <TacticalGrace> they used to work, but it's a while that I tried to compile them
03:05:14 <TacticalGrace> (in the meantime both LLVM and the bindings had new versions)
03:05:20 <Bynbo7> they half work for me, i can generate bitcode files, but i can't jit compile things :(
03:06:15 <TacticalGrace> what happens?
03:06:32 <Bynbo7> one sec
03:07:51 <Bynbo7> it prints user error (Interpreter has not been linked in.)
03:08:36 <TacticalGrace> haven't seem that before
03:08:49 <Bynbo7> I've found a few references to other people having the dame proble, but no solutions for the haskell bindings (in C++ you need to initialise the runtime system or something, i can't remember exactly what)
03:08:54 <TacticalGrace> are you using the dylib or .a?
03:09:20 <Bynbo7> not sure. it's what ever homebrew installed
03:09:47 <Bynbo7> seem that /usr/local/Cellar/llvm/2.8/lib/ has mostly .a files
03:09:57 <TacticalGrace> I always comiled llvm manually and passed the configure optoion to generate shared libs
03:10:14 <TacticalGrace> I think there was only one dylib
03:10:15 <Bynbo7> ah, that could certainly be the problem. I'll see what i can do. 
03:11:28 <Axman6_> TacticalGrace: I'm hoing that i can do something like accelerate as a project this semester at ANU. I've written to the head of the CS department about it, but o reply so far
03:11:44 <Axman6_> my choices for courses are extremely limited this semester :(
03:12:10 <TacticalGrace> you already did all the interesting ones?
03:12:29 <Axman6_> all the interesting ones/ones i need to finish my degree are next seemster
03:12:32 <Axman6_> semester*
03:12:44 <Axman6_> there's about 8 courses i want to do next semester -_-
03:13:25 <TacticalGrace> oh
03:13:29 <TacticalGrace> that sucks
03:13:34 <Axman6_> had to drop computer graphics to be able to do some management course that's a prereq for a course i need for my degree (another management thing)
03:14:29 <Axman6_> so, I'm only doing parallel systems, and hopefully this 'topics in computer science course' where i think you basically get to make up your own project, though i;m not sure
03:14:53 <TacticalGrace> we have something like that
03:14:59 <TacticalGrace> it's called special project
03:15:23 <TacticalGrace> you basically only need to find a superviser for a research project of your own making
03:15:48 <TacticalGrace> (and it's only available to students with above average WAM)
03:15:58 <Axman6_> WAM?
03:20:28 <TacticalGrace> wam = grade average
03:21:04 <TacticalGrace> Axman6_: in any case, I hope you get approval
03:21:17 <Axman6_> cheers :)
03:21:32 <Axman6_> kinds wishing I'd gone to UNSW at the moment :\
03:27:49 <kuffaar> How do you use infix functions with qualified imports again?
03:28:10 <kuffaar> I got Data.Sequence in DS, not sure how to use |>
03:28:57 <edwardk> Foo.+
03:29:03 * hackagebot streams 0.5.1 - Various Haskell 2010 stream comonads  http://hackage.haskell.org/package/streams-0.5.1 (EdwardKmett)
03:29:03 <edwardk> Data.Sequence.|>
03:29:13 <kuffaar> Thanks
03:29:16 <edwardk> a Data.Sequence.|> b
03:29:21 <edwardk> kinda hideous =)
03:29:24 <kuffaar> :p
03:29:27 <kuffaar> DS.|>
03:29:33 <kuffaar> But there are so many clashes otherwise
03:29:36 <kuffaar> length etc
03:29:47 <edwardk> i usually use two import lines
03:30:13 <kuffaar> Why two?
03:30:18 <edwardk> import qualified Data.Sequence as Seq; import Data.Sequence ((<|),(|>), ViewL(..), ViewR(..), Seq)
03:30:30 <kuffaar> Heh
03:30:44 <edwardk> that gets me the operator and the names i need, but lets me qualify the rest
03:30:55 <edwardk> then everything is either an operator or prefixed by Seq
03:31:12 <edwardk> most of my libraries are designed to be imported this way when they have a lot of prelude conflicting names
03:33:16 * edwardk happily just spotted a nice way to split comonadic supplies
03:33:38 <edwardk> now i can extract an infinite skew binary stream of supplies from a supply
03:34:20 <edwardk> yay for the power of math =)
03:35:15 <edwardk> i also had completely missed the fact that supplies are Applicative
03:37:05 * hackagebot streams 0.5.1.1 - Various Haskell 2010 stream comonads  http://hackage.haskell.org/package/streams-0.5.1.1 (EdwardKmett)
03:39:38 <kuffaar> Heh, I discovered a Haddock bug, I thinkj: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:**
03:39:51 <kuffaar> Invalid HTML anchors!
03:42:28 <edwardk> interesting
03:43:09 <pastorn> edwardk: reading the description of the streams package
03:43:18 <pastorn> i just think to myself "general abstract nonsense"
03:43:24 <edwardk> pastorn: hahaha
03:43:26 <pastorn> but that's just me not understanding it fully yet
03:43:36 <pastorn> "provides a coinductive anti-causal stream"
03:43:37 <edwardk> pastorn: basically 'non-empty lists' on steroids
03:43:40 <pastorn> yes, this is obvious
03:44:01 <pastorn> edwardk: you don't actually expect people to use this library?
03:44:15 <edwardk> data.stream.supply is useful actually
03:44:23 <edwardk> data.stream.infinite is also quite useful
03:44:39 <pastorn> what changed to 0.5.1?
03:44:42 <edwardk> the Future's are good for data flow programming, but they are primitives.
03:44:45 <pastorn> (docs aren't generated yet)
03:44:58 <edwardk> 0.5.1 added Data.Stream.Supply
03:45:04 <edwardk> 0.5.1.1 was doc fixes
03:45:34 <edwardk> Data.Stream.Supply uses mutation behind the scenes to provide a splittable supply of unique values as a comonad
03:45:51 <edwardk> its basically iavor's value-supply package with a comonadic bow on top
03:46:04 <edwardk> and with the missing Applicative instance, etc.
03:46:22 <pastorn> so are you "doing it rite"(TM)?
03:46:44 <edwardk> the causal/anti-causal stuff will make more sense when i provide some comonadic dataflow programming examples
03:47:08 <edwardk> well, it was in category-extras, and i've been slowly moving its contents out into other packages
03:47:44 <edwardk> streams was the right package to contain it because i wanted to fix the type of 'split' to have it return an infinite stream rather than a list that just happened to be infinite
03:48:14 <edwardk> and because i spotted the fact that i could generate a skew infinite stream off of a comonadic value supply with logarithmic time indexing.
03:48:14 <pastorn> edwardk: how does one get started with using any of this stuff?
03:48:29 <edwardk> pastorn: look at the comonad package
03:48:41 <edwardk> pastorn: the semigroups package is also quite accessible
03:48:48 <dolio> Look at all 90 of edwardk's packages.
03:49:01 <edwardk> from there, distributive, and then comonad-transformers
03:49:08 <pastorn> duplicate :: w a -> w (w a)
03:49:12 <pastorn> anti-join :D
03:49:13 <edwardk> er functor-apply then comonad-transformers
03:49:18 <edwardk> pastorn: exactly!
03:49:35 <edwardk> for [] that is 'tails'
03:49:36 <pastorn> and anti-bind! extend :: (w a -> b) -> w a -> w b
03:49:45 <edwardk> yep =)
03:50:06 <pastorn> well, anti-bind mixed with return :)
03:50:19 <edwardk> actually anti-bind
03:50:23 <edwardk> :t (=<<)
03:50:24 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
03:50:51 <edwardk> as opposed to Extend w => (w a -> b) -> (w a -> w b)
03:51:07 <pastorn> edwardk: well, 'extend' adds the type container thingy 'w' when it's done
03:51:20 <pastorn> which it wouldn't have to do, if just function application was used
03:51:30 <edwardk> (=<<) takes a Kleisli arrow, and gives you back one from m a -> m b, extend takes a 'coKleisli' arrow and gives you back one from w a -> w b
03:51:44 <pastorn> my head spins now
03:51:50 <edwardk> think of monads as containers you have to fight to get out of and comonads as ones you have to fight to keep wrapped around you ;)
03:52:23 <Feuerbach> edwardk: and what are skew streams?
03:52:26 <edwardk> with a comonad you usually have it on the left hand side of the ->, with a monad its on the right
03:52:44 <pastorn> edwardk: haha, so what's the quivalent of "<-" for comonads?
03:52:56 <edwardk> feuerbach: they are built using skew binary arithmetic. they provide potentially infinite length, but logarithmic time access
03:53:15 <edwardk> pastorn: sadly, there is no codo sugar ;)
03:53:38 <Twey> Hehe
03:53:55 <edwardk> fib = 1 `fby` 1 `fby` codo (h:< t:< _) <- fib; h + t — could be fun ;)
03:54:21 <pastorn> wait wait wait
03:54:25 <pastorn> i remember now
03:54:43 <edwardk> just desugar do into (>>=), then use (=>>) instead
03:54:51 <pastorn> to make monad you *either* do return/bind *OR* you could do return/join/fmap
03:54:53 <pastorn> right?
03:54:56 <edwardk> yeah
03:55:09 <edwardk> to make a comonad, you use extract/extend or extract/duplicate/fmap =)
03:55:20 <pastorn> ah
03:55:29 <pastorn> is this written down in the typeclassopedia?
03:55:35 <edwardk> no idea
03:55:56 <edwardk> i'm in the process of invalidating the whole typeclassopedia though, because i'm adding and removing layers with functor-apply ;)
03:56:05 <edwardk> Pointed is gone from the equation, but Apply is inserted in
03:56:24 <edwardk> http://hackage.haskell.org/package/functor-apply might give a better picture
03:56:38 <pastorn> edwardk: i must say that i dislike endless structures, like your Stream type
03:56:55 <Saizan> poor Pointed
03:56:57 <edwardk> thats fine, they admit some operations that finite forms of them do not
03:57:21 <pastorn> but maybe streams aren't as bad as some things i've seen
03:57:21 <edwardk> for instance there is a monad on _infinite_ streams that differs from the ones you can construct on some finite streams
03:57:22 <pastorn> like Mu
03:57:31 <pastorn> which just makes me want to punch something
03:57:43 <edwardk> Data.Stream.Branching is Mu with an extra 'a' on every node
03:57:52 <edwardk> data Stream f a = a :< f (Stream f a)
03:57:57 <aristid> edwardk: and it differs from ZipList's Applicative (when using only infinite ZipLists)?
03:58:01 <edwardk> newtype Mu f = Mu (f (Mu f))
03:58:09 <pastorn> edwardk: yeah, the 'foreach' >>= implementation differs, right? or is it mplus?
03:58:26 <pastorn> edwardk: stop that
03:58:38 <edwardk> aristid: data Stream a = a :> Stream a — has an Applicative that is exactly that of ZipList, but it _also_ has a monad. =)
03:58:38 <dolio> That's Stream?
03:58:46 <dolio> Looks like Cofree to me.
03:58:54 <edwardk> dolio: it is
03:59:17 <aristid> edwardk: i forget, why doesn't ZipList itself have a Monad? hmmm
03:59:31 <edwardk> aristid: no monad for ZipList is consistent with the Applicative
03:59:40 <edwardk> the one for infinite streams actually 'diagonalizes'
04:00:00 <edwardk> for ziplists the fragments returned by the monad could have different lengths, preventing that
04:00:09 <aristid> join is the operation to look at?
04:00:10 <dolio> Taking the diagonal only works for rectangles.
04:00:31 <aristid> dolio: edwardk's rectangles are infinitely wide
04:00:36 <edwardk> dolio: its also commonly called the f-branching stream comonad, and that causes fewer people to have their head explode
04:00:36 <dolio> Right.
04:00:48 <edwardk> aristid: but the ones generated by ziplist are jagged
04:00:50 <dolio> edwardk: Pansies.
04:01:05 <aristid> edwardk: ah, too bad.
04:01:15 <edwardk> dolio: i'm packaging up a free monads package next
04:01:25 <dolio> At least call it f-branching cotrees.
04:01:35 <pastorn> edwardk: have to go now, but i'll interrogate you more about streams later :)
04:01:44 <edwardk> pastorn: feel free =)
04:03:11 * hackagebot functor-apply 0.10.0.3 - Applicative sans pure, Monad sans return, Alternative sans empty  http://hackage.haskell.org/package/functor-apply-0.10.0.3 (EdwardKmett)
04:04:15 <edwardk> added Plus to the diagram
04:04:59 <edwardk> dolio: did you see i packaged up the recursion schemes from category extras again?
04:05:20 <edwardk> that was the seed that got my whole category-theory addiction started ;)
04:05:46 <dolio> Heh.
04:06:19 <dolio> Now people can get their postpromorphic-apo-metamorphisms without all the excess baggage.
04:06:24 <edwardk> yeah
04:06:35 <edwardk> plus now they are easier to program with because they are based on proper comonad transformers
04:06:45 <edwardk> so you can take your f-w-algebras and decompose them properly ;)
04:06:53 <edwardk> things like distZygoT have changed signatures
04:07:08 <edwardk> this means that zygohistomorphic prepromorphisms aren't what they used to be!
04:07:26 <edwardk> (the semimutual recursion lost access to the comonad, but this is a good thing)
04:08:11 <edwardk> because this means it uses the environment comonad transformer, rather than the "i-think-its-a-transformer-like-thing" messy coreaderT that was in category-extras
04:09:16 <edwardk> hrmm
04:09:19 <edwardk> build failure
04:09:20 <edwardk> odd
04:09:41 <edwardk> i can't see the difference in tyhe types in this error log: http://hackage.haskell.org/packages/archive/recursion-schemes/0.1/logs/failure/ghc-7.0
04:10:49 <dolio> Where are w(1) and t(1) coming from?
04:11:05 <edwardk> probably because of the type pretty printer
04:11:23 <dolio> They might actually be different, though.-
04:11:26 <dolio> Who knows?
04:11:31 <edwardk> odd
04:11:42 <dolio> They're not quantified like b and c at least.
04:11:47 <edwardk> it compiles fine on 6.12
04:12:18 <edwardk> can someone with 7.0.x give it a shot?
04:12:36 <Axman6_> what do you need done?
04:12:52 <dolio> Looks like your instances for Fix have problems, too.
04:12:57 <edwardk> trying to figure out what changed in the typechecking between 6.12 and 7.0.x of recursion-schemes
04:13:06 <edwardk> yeah, something changed in the way the dispatch works on that too
04:13:29 <edwardk> that i can fix. it was just being clever
04:13:39 <Saizan> eta-expansion will probably fix the earlier ones
04:13:55 <edwardk> blech
04:15:20 <edwardk> looks like something changed with partially applied functions with type family arguments
04:15:40 <dolio> I guess the unquantified variables must be for unification, so I can't see what's wrong, either.
04:16:31 <edwardk> rather annoyed that i have to eta-expand all my beautiful definitions
04:18:32 <Saizan> i think it's the interaction with higher-rank polymorphism
04:18:49 <Saizan> might be a bug though
04:19:08 <edwardk> it should be fine here though, because i'm just doing partial application
04:19:30 <edwardk> looks like the compiler got more aggressive in trying to ground out the types
04:20:09 <edwardk> ok, packaged up what i think is the right fixes
04:20:14 * hackagebot recursion-schemes 0.1.1 - Generalized bananas, lenses and barbed wire  http://hackage.haskell.org/package/recursion-schemes-0.1.1 (EdwardKmett)
04:20:26 <edwardk> can someone with 7.0.x give that a shot?
04:21:22 <Axman6_> sure
04:21:30 <edwardk> much obliged
04:21:41 * Axman6_ waits for cabal to update...
04:22:33 <edwardk> i eta expanded, and added the redundant instance body requirements
04:22:50 <Axman6_> bloody hell ghc-7 is slow
04:23:09 <Axman6_> Data/Stream/Infinite/Skew.hs:64:7:
04:23:09 <Axman6_>     Warning: Ignoring unusable UNPACK pragma on the
04:23:10 <Axman6_>              first argument of `Bin'
04:23:13 <edwardk> i even threw in mendler style iteration and mendler-style course of value iteration as a bonus
04:23:16 <Axman6_> probably should remove that
04:23:23 <edwardk> hrmm
04:23:48 <Axman6_> can't unpack things which have multiple constructors 
04:23:49 <edwardk> oh yeah
04:23:57 <edwardk> that was a holdover
04:23:59 <edwardk> from when it was an Int
04:24:01 <Axman6_> making it strict is fine though
04:24:05 <Axman6_> ah
04:24:27 <Axman6_> edwardk: it installs fine :)
04:24:27 <edwardk> when i made it infinite, it was kinda silly to limit the binary trees inside to Ints ;)
04:24:31 <edwardk> sweet
04:24:36 <edwardk> i'll bump streams with that
04:25:03 * Axman6_ is about to upload a new cabal package
04:25:14 <Axman6_> well update anyway
04:26:11 <edwardk> wassat?
04:26:16 * hackagebot streams 0.5.1.2 - Various Haskell 2010 stream comonads  http://hackage.haskell.org/package/streams-0.5.1.2 (EdwardKmett)
04:26:20 <Axman6_> you'll see in a sec :P
04:27:13 <edwardk> i was pleased when i realized i could extract a Data.Stream.Infinite.Skew from a comonadic supply in a nice way
04:27:50 <edwardk> that way you can have random access to an infinite number of supplies from one supply
04:28:16 * hackagebot array-utils 0.3 - Primitive functions for updating many elements in mutable arrays at once  http://hackage.haskell.org/package/array-utils-0.3 (AlexMason)
04:28:20 <Axman6_> pow!
04:28:32 <edwardk> Axman6: ah, saw your post about that
04:28:45 <edwardk> 'd you see my monadic-arrays package?
04:29:03 <Axman6_> not yet
04:29:40 <edwardk> gives access to arrays direcly in monad transformers, even unboxed arrays
04:29:46 <Axman6_> ah right, transformers stuff for mutable arrays. nice work :)
04:30:18 <edwardk> MonadUArray has a somewhat scary context though
04:30:22 <Axman6_> hmm. i wonder whether my code should be using that interface
04:30:39 <edwardk> but i needed it for my graph library
04:30:49 <Axman6_> actually, would my code just work with that? it only cares that there's a MArray instance defined
04:30:53 <edwardk> that way i can store my color property map unboxed 
04:31:01 <edwardk> then you're fine
04:31:05 <Axman6_> holy... ha, yes, that is a horrible context :P
04:31:30 <Axman6_> i don't suppose you'd fine my package usefor for your work? i need peole to test it
04:31:34 <Axman6_> people8
04:31:38 <edwardk> not directly
04:32:00 <edwardk> i skimmed the post looking for applications
04:32:30 <edwardk> is there a package for taking derivatives of functors with template haskell yet?
04:32:49 * Axman6_ goes to grab some food
04:33:11 <edwardk> i just want a type family D (f :: * -> *) :: * -> * — and some TH for deriving it's members
04:45:16 <edwardk> hrmm
04:45:25 <edwardk> getting ready to port bifunctor out of category-extras.
04:45:49 <edwardk> debating about retaining the PFunctor/QFunctor structure or just taking the 80% solution of defining Bifunctor directly
04:46:20 <edwardk> pros: the former admits the use of 'first' and 'second' in more contexts.
04:46:28 <edwardk> the latter requires less work to define an instance
04:46:55 <edwardk> haskell can be damn annoying with deep class hierarchies
04:49:00 <accel> edwardk: what's the problem?
04:49:14 <edwardk> accel: with bifunctor?
04:49:25 <accel> with deep class hierarchies
04:49:40 <dolio> The problem is that Haskell wasn't made for modeling category theory.
04:49:46 <edwardk> as you go deeper and deeper you get more laws, which often would supply default definitions for more of your superclasses
04:49:47 <dolio> But edwardk can't take the hint.
04:49:51 <edwardk> dolio: =)
04:50:05 <edwardk> dolio: it doesn't do a very good job with abstract algebra either ;)
04:50:08 <accel> dolio: haskell can't model category theory?
04:50:22 <edwardk> otoh, the type system is much more consistent than scala, so when it blows up its _my_ fault at least ;)
04:50:24 <dolio> Not well.
04:54:57 <dolio> If only Agda would use a reasonable amount of resources for that sort of thing.
04:55:11 <edwardk> yeah
04:55:21 <dolio> Though it's progressing in other ways.
04:55:32 <dolio> It's got --without-K now.
04:55:35 <edwardk> agda is so much fun to hack around in for CT stuff, but it just dies when you go to do anything nontrivial
04:55:43 <dolio> So it can jump on the homotopy bandwagon.
05:10:31 <parcs> heh, for some reason ghc doesn't like liftIO . print. it doesn't print anything and makes the application use 100% of my poor cpu
05:12:55 <Heffalump> parcs: what monad are you lifting into?
05:14:20 <parcs> Heffalump: a StateT
05:14:45 <parcs> well, a StateT ByteString IO
05:15:18 <parcs> let me rephrase: ghc doesn't like the definition printL :: liftIO . print, but if i inline this expression its ok
05:15:27 <parcs> =*
05:16:19 <Heffalump> do you have a small test case showing that difference?
05:16:24 <Heffalump> Seems like a clear bug if that's the only change.
05:16:48 <parcs> no, but i'll create one
05:18:34 <hpc> :t liftIO . print
05:18:34 <lambdabot>     Ambiguous occurrence `liftIO'
05:18:35 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
05:18:35 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
05:20:39 <aristid> hahaha.
05:21:00 <aristid> :t Control.Monad.Error.liftIO . print
05:21:01 <lambdabot> forall (m :: * -> *) a. (Control.Monad.Error.MonadIO m, Show a) => a -> m ()
05:22:39 <hpc> does printL have a type signature?
05:23:19 <Twey> Everything has a type signature
05:23:21 <Twey> What's printL?
05:23:38 <Heffalump> Twey: parcs' definition above
05:23:42 <hpc> ^
05:23:46 <Twey> Oh, right
05:23:59 <parcs> hpc: yeah
05:23:59 <Twey> It was further above than I expected it to be
05:24:08 <parcs> printL :: (Show a, MonadIO m) => a -> m ()
05:24:20 <hpc> huh
05:27:18 <parcs> oh, duh
05:27:24 <parcs> printL = liftIO . printL
05:27:28 <parcs> sorry >_>
05:28:13 * Kaidelong thinks "(f a -> f b) -> f (a -> b)" might be a logical thing by which to implement programming by contract
05:28:13 <parcs> unfortunately ghc can't detect infinite loops
05:28:22 <Axman6_> :t let printL = Control.Monad.Error.liftIO . printL in printL
05:28:24 <lambdabot> forall (f :: * -> *) a. (Functor f) => f (IO a)
05:28:44 <hpc> ouch
05:28:47 <quaestor> if I got a function that takes some variable x, and this function is used by another function, which is used by another function and so on, but the other functions don't use that parameter x in some way, they only carry it through to the bottom-level function, and I have several of those... should I use state monad or something like that?
05:29:08 <Kaidelong> parcs: try ACL2
05:29:31 <Kaidelong> turing complete languages have trouble with that generally
05:29:32 <Axman6_> quaestor: got an example?
05:31:27 <Kaidelong> f a :: conditions value of type A must satisfy
05:31:49 <Kaidelong> f (a -> b) :: preconditions and postconditions of function a -> b
05:31:58 <Kaidelong> and then you can waive those conditions
05:32:03 <Kaidelong> so it'd be copointed
05:32:10 <Kaidelong> (but not pointed)
05:33:02 <Kaidelong> so you can't just take *any* a and make it an f a
05:33:08 <Kaidelong> because the a might not meet the conditions
05:33:21 <quaestor> Axman6_: say I have the function "fft xs m mM sigma", but the fft itself only needs xs (the input), m and mM, but sigma is a value that are needed for low-level computations only in the last recursion step of the fft, in a function "badMult m mM sig"
05:33:45 <kuffaar> Oh, System.Time has been superceded?
05:34:10 <Axman6_> quaestor: that could be a good use for the state monad, though it may also slow own your code, benchmark it if you need to :)
05:34:35 <quaestor> Axman6_: and I surely would like m and mM to be "global" as well, I need them everywhere throughout the algorithm
05:34:53 <kuffaar> http://hackage.haskell.org/package/time ah
05:35:18 <quaestor> Axman6_: ok, then I'll finally have to deal with monads ;)
05:35:26 <astroboy> Does anybody know how to load images with the X11 bindings? and with images I mean xbm/xpm
05:35:52 <aristid> kuffaar: yes, it's Data.Time now
05:36:01 <Axman6_> quaestor: actually, the reader monad would be better here. if you make a record with those elements in it, you can do things like: do foo; x <- asks m; y <- asks mN ... to pull out those values
05:36:51 <quaestor> Axman6_: ok, thanks, I'll look into that
05:37:59 <kuffaar> ClockTime is now UTCTime?
05:38:30 <Axman6_> quaestor: i can give you a hand if you'd like, in the nest little while
05:38:36 <Axman6_> going to sleep soon
05:57:32 <Axman6_> @remember bernardh Refactoring: spend a week to get where you were
05:57:33 <lambdabot> It is stored.
06:00:38 * hackagebot bifunctors 0.1 - Haskell 98 bifunctors  http://hackage.haskell.org/package/bifunctors-0.1 (EdwardKmett)
06:01:18 <edwardk> bifunctors, bifoldables and bitraversables
06:02:02 <zygoloid> what about the bitreversables? :)
06:02:08 <edwardk> =)
06:02:13 <edwardk> separate package ;)
06:02:45 <Heffalump> you're breaking up category-extras?
06:02:57 <kuffaar> http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Sequence.html#t:ViewL <- hmm I don't get how you retrieve the left most element of a Seq
06:02:59 <edwardk> yeah
06:03:20 <Heffalump> excellent :-)
06:03:24 <edwardk> i've been at it for a while now. these are targeted to be more portable, with the more esoteric stuff in tiny silos off to the side
06:03:53 <edwardk> kuffar: you use viewl, then case on that
06:04:13 <Heffalump> I vaguely recall someone saying rmonad should use something from in there, but I didn't want to take such a huge depedendency. I can't remember what it was though :-/
06:04:16 <edwardk> case viewl xs of EmptyL -> …; x :< xs -> ...
06:05:42 <edwardk> so far i have factored out the comonad transformers, void, contravariant functors, refactored the applicative precursors that were in there, and peeled off recursion schemes and bifunctors, plus packaged up separately a bunch of comonadic streams
06:06:06 <edwardk> and then updated my other packages to use the smaller fragments
06:06:39 <edwardk> the goal is to keep as much of it haskell 98 as possible
06:07:10 <edwardk> oh, and i factored out adjunctions
06:07:25 <kuffaar> <edwardk> case viewl xs of EmptyL -> …; x :< xs -> ...
06:07:28 <edwardk> though that package is decidedly not 98 =)
06:07:30 <kuffaar> Ahh thanks
06:07:55 <kuffaar> I was trying to pattern match on ViewL itself at first :|
06:08:02 <edwardk> ah
06:08:09 <edwardk> pattern guards help there
06:08:19 <edwardk> foo (viewl -> EmptyL) = ...
06:09:37 <edwardk> i need to add bifunctor versions of the semigroup traversables, etc.
06:10:13 <kuffaar> DiffTime no longer has record functions? Hm
06:10:44 <kuffaar> Nothing DiffTime -> Integer on Hoogle, odd
06:17:05 <Kaidelong> refactoring is about being able to move forward
06:22:09 <kuffaar> How do you convert a NominalDiffTime to a Double?
06:22:48 <kuffaar> http://hackage.haskell.org/packages/archive/time/1.2.0.3/doc/html/Data-Time-Clock.html#t:NominalDiffTime
06:28:23 <doserj> realToFrac?
06:28:46 <Veinor> realToFrac will work
06:29:03 <Veinor> someone should write a program that will tell you how to convert between two types given their typeclass instances
06:29:16 <kuffaar> Ah thanks
06:29:37 <mietek> What's the GHC switch to stop generating .hi and .o files?
06:30:01 <Twey> Hehe, sounds like Dijkstra…
06:33:43 <Heffalump> Veinor: you could do it with Djinn
06:33:54 <Veinor> @djinn (Real a) => a -> Double
06:33:55 <lambdabot> Error: Undefined type Double
06:33:58 <nyuszika7h> Hi! :)
06:34:22 <Heffalump> Veinor: not directly, with some desugaring
06:34:26 <Heffalump> @info Real
06:34:26 <lambdabot> Real
06:35:04 <byorgey> hi nyuszika7h 
06:35:17 <Heffalump> actually, perhaps you couldn't because of the concrete types
06:35:26 <Veinor> yeah, but i think it'd be easier to just build a graph and do dfs or something
06:35:32 <Veinor> er, bfs
06:37:00 <Bynbo7> > 0/0
06:37:01 <lambdabot>   NaN
06:37:06 <Veinor> where the nodes are typeclasses/concrete types
06:37:07 <Bynbo7> > 0/0
06:37:08 <lambdabot>   NaN
06:37:18 <Bynbo7> > (0/0)/1 -- sorry for the dup
06:37:19 <lambdabot>   NaN
06:38:20 <Heffalump> I'm not sure there's an obvious strategy, unless you only consider functions of type x -> y
06:42:38 <nyuszika7h> > reverse(reverse "Hello, world!")
06:42:39 <lambdabot>   "Hello, world!"
06:42:51 <nyuszika7h> @lambdabot botsnack
06:42:52 <lambdabot> Unknown command, try @list
06:42:58 <nyuszika7h> botsnack
06:43:03 <nyuszika7h> @botsnack
06:43:03 <lambdabot> :)
06:45:11 <kuffaar> How do you show a double with limited precision? Formatting strings are disgusting and I want to control the precision programmatically anyways.
06:46:03 <Twey> :t showFFloat
06:46:04 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
06:46:21 <Twey> > showFFloat 3 (1 / 6) ""
06:46:22 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe GHC.Types.Int))
06:46:23 <lambdabot>    arising f...
06:46:29 <Twey> > showFFloat (Just 3) (1 / 6) ""
06:46:30 <lambdabot>   "0.167"
06:46:36 <Twey> kuffaar: ^
06:47:18 <kuffaar> Thanks
06:47:32 <kuffaar> That is bizarre, why does it take a Maybe?
06:47:35 <kuffaar> NaN?
06:47:38 <Twey> I think Nothing just does it to the greatest available precision
06:47:44 <Twey> > showFFloat Nothing (1 / 6) ""
06:47:45 <lambdabot>   "0.16666666666666666"
06:47:48 <kuffaar> Ahh
06:48:02 <Twey> It's a (slightly clunky) way of passing an optional argument
06:48:53 <kuffaar> How do optional arguments/default argument values work in Haskell anyways? With partial application and all
06:49:17 <Bynbo7> default values?
06:49:22 <Twey> kuffaar: They don't, really
06:49:36 <Twey> You can pass a map or a list of options
06:49:50 <kuffaar> Bynbo7: In languages like C++, Ruby, Python you can specify default values for unspecified arguments
06:50:00 <Bynbo7> yeah, we don't have that
06:50:06 <Bynbo7> it doesn't make much sens in haskell
06:50:31 <aavogt> > printf "%.2f" pi :: String
06:50:33 <lambdabot>   "3.14"
06:50:39 <kuffaar> Ewwww
06:50:44 <Twey> data FuncFlag = Foo | Bar | Baz String; func :: [FuncFlag] -> SomeSortOfResult
06:51:33 <Veinor> :t printf
06:51:34 <lambdabot> forall r. (PrintfType r) => String -> r
06:51:36 <Veinor> :D
06:51:46 <Veinor> @instances PrintfType
06:51:46 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
06:51:52 <Veinor> @instances-importing Text.Printf PrintfType
06:51:53 <lambdabot> (a -> r), IO a, [c]
06:51:54 <aavogt> kuffaar: http://okmij.org/ftp/Haskell/polyvariadic.html
06:52:03 <Twey> Yeah, there are ways
06:52:29 <Veinor> i still hate that IO a instance of PrintfType :/
06:52:37 <aavogt> it's not explicitly built in as a language feature, so people don't use it
06:53:29 <Kaidelong> actually default arguments don't make much sense even in languages that do have them
06:53:51 <aavogt> Kaidelong: why not?
06:54:07 <Twey> Veinor: I like that :þ
06:54:41 <Bynbo7> Veinor: why do you hate it?it makes it very useful
06:54:51 * Bynbo7 usesprintf all the time
06:54:57 <Kaidelong> aavogt: how do you know if you're calling an overload (int foo = 5, object baz, subtype bar) or overload (object baz, object bar) etc
06:55:16 <Veinor> well, i don't like that it basically combines what C calls sprintf and printf into one function
06:55:37 <Twey> Veinor: Why?
06:55:45 <Kaidelong> Bynbo7: I don't like variadic functions because it is hard to tell what they do from the type
06:56:03 <Kaidelong> existential types like a list of any show is probably a better idea
06:56:10 <Kaidelong> or any formattable
06:56:11 <Kaidelong> or something
06:56:20 <Bynbo7> eh
06:56:26 <Bynbo7> makes it more ugly to use
06:56:39 <Veinor> Kaidelong: it still makes sense for stuff like foo(bar, opt=True, opt2=True)
06:56:48 <Kaidelong> Bynbo7: "syntax" vs "semantics"
06:57:04 <Kaidelong> Veinor: why not just be explicit then and say "fooWithDefaults" or something
06:57:59 * Kaidelong avoids gratutous overloading where he can
06:58:20 <Kaidelong> Random.Next is an ugly example of overloading gone bad in .NET
06:58:23 <ddarius> The better way to handle "default" arguments or "keyword" arguments is to split your functions into a composable set preferably over a good model.
06:58:49 <aavogt> Kaidelong: can the issue of default arguments be separated from the overloading issues?
06:59:01 <ddarius> Rather than circle radius location color, just have unitCircle, translate, setColor, scale.
06:59:19 <Kaidelong> aavogt: I don't think so, unless you explicitly ask for the default argument in the syntax somehow, like with _ 
06:59:23 <aavogt> part of it means having a decent records
06:59:51 * hackagebot functor-apply 0.10.1 - Haskell 98: Applicative sans pure, Monad sans return, Alternative sans empty  http://hackage.haskell.org/package/functor-apply-0.10.1 (EdwardKmett)
07:00:03 <Kaidelong> if you don't allow other kinds of overloading, at leat
07:00:13 <Kaidelong> otherwise you're left with the ambiguity "what is the type of _"
07:00:34 <Twey> ddarius: Good advice
07:00:45 <edwardk> if i really need default arguments. i use data-default, then create an 'options' data type for my function, and call it with foo def { whatever = … } 
07:01:20 <Veinor> Kaidelong: there's an implicit withDefaults at the end of every name of every function with optional arguments? :D
07:01:37 <Kaidelong> Veinor: it will often make sense in practice
07:01:51 <Twey> Though, ‘circle 3 (4, 5) (66, 66, 66)’ is a lot easier to type than setColor (66, 66, 66) . translate (4, 5) . scale 3 $ unitCircle
07:02:06 <Twey> I suppose you can always have helper functions
07:02:10 <ddarius> Twey: Exactly.
07:02:26 <edwardk> plus the latter composes
07:02:34 <Twey> Yeah
07:02:46 <zygoloid> out of context i can tell exactly what the latter does
07:02:54 <Kaidelong> Veinor: if for example you default to picking any 32 bit integer with "Next()" why not say so?
07:03:03 <Kaidelong> "Random.anyInt()" or something
07:03:07 <Veinor> Kaidelong: that's just bad documentation
07:03:11 <Bynbo7> zygoloid: o/ I don't suppose you've used the haskell llvm bindings?
07:03:12 <Veinor> er, bad naming
07:03:15 <ddarius> Twey: It also easier to define unitCircle, and unitSquare rather than have to repeat all the scaling, translating, coloring logic, and if you add a new aspect, say scaling different axes, you don't have to change the primitives.
07:03:32 <Twey> Ah, that's true
07:03:36 <Kaidelong> Veinor: by the time you start overloading a name the name is probably not descriptive enough anyway
07:03:52 * hackagebot json2 0.3.1 - This library provides support for JSON.  http://hackage.haskell.org/package/json2-0.3.1 (YuriyIskra)
07:03:54 * hackagebot yesod-auth-oauth 0.2 - OAuth wrapper for yesod-auth  http://hackage.haskell.org/package/yesod-auth-oauth-0.2 (HiromiIshii)
07:03:56 <Veinor> well, if you consider typeclass functions as overloaded functions...
07:04:16 <Twey> What on Earth do you mean? (>>=) is a perfectly descriptive name!
07:04:55 <kuffaar> Source\Main.hs: openBinaryFile: permission denied (Permission denied)
07:04:57 <kuffaar> Odd.
07:05:10 <Veinor> do you have permissions on that file?
07:05:19 * Twey chalks up another reason significant spacing would be good: so we can use <bind> as an operator
07:05:44 <Kaidelong> Veinor: overloading in typeclasses is quite a saner kind of overloading
07:06:26 <Kaidelong> for those kinds of overload
07:06:27 <byorgey> kuffaar: what are you getting that error from?
07:06:42 <Kaidelong> there is a unique polymorphic function that can be specialized to any of the overloads
07:06:55 <Kaidelong> the same doesn't hold for overloading names in something like Java
07:07:00 <kuffaar> byorgey: cabal
07:07:14 <kuffaar> byorgey: I just kept on running it and after 2 times more it worked again
07:07:22 <Twey> Haha
07:07:23 <byorgey> that's very strange
07:07:33 <kuffaar> I frequently get random errors with cabal on Windows 7
07:07:35 <kuffaar> Segfaults
07:08:35 <zygoloid> Bynbo7: i had a poke at them but got sidetracked :o
07:09:10 <Bynbo7> zygoloid: ah fair enough.i was wondering if you'd be able to help me get JIT compilation working with it, but i geuss not :)
07:10:58 <zygoloid> sorry, i've never gone anywhere near the JIT :(
07:15:56 <Bynbo7> i was trying to reproduce Lennart's various examples on his blog, but i keep getting errors 'user error (Interpreter has not been linked in.)'
07:16:34 <Bynbo7> hmm, maybe i should build with shared library support...
07:20:29 <maurer_> Bynobo7: Did you remember to do initializeNativeTarget first?
07:21:24 <Bynbo7> bah! i did see that's how you fix it when using C++, and i had a quick look for it, but i missed it. thanks!
07:24:13 * Bynbo7 adds maurer_  to the list of people he owes a beer/scotch/drink of choice to
07:25:24 <maurer_> Bynbo7: Warning though, if you're trying to build a compiler using LLVM, the haskell LLVM bindings are :(
07:25:38 <maurer_> As they require you to know the type of every function you will be compiling at the compile time of your compiler
07:25:40 <maurer_> Which is absurd
07:25:59 <Bynbo7> i think that may be ok for what I'd be using it for
07:26:05 <maurer_> Those bindings are mostly intended for JITing random stuff for acceleration
07:26:05 <maurer_> OK
07:26:25 <akamaus> how best to calculate xor of two Bools?
07:26:41 <Saizan> i think that's not necessarily the case with careful use of existentials
07:26:58 <maurer_> Saizan: You can generate the functions then, but you can't make calls
07:27:18 <maurer_> i.e. if I want to have main call f, the existential type has dropped information that the LLVM bindings need.
07:27:57 <Veinor> ... huh, there's no xor :: Bool -> Bool -> Bool
07:28:19 <maurer_> Yeah, there is xor :: (Bits a) -> a -> a -> a though
07:28:30 <dafis> Veinor:  xor = (/=)
07:28:34 <maurer_> err, => for the first one
07:28:44 <maurer_> dafis is correct.
07:28:47 <Veinor> dafis: :O
07:28:49 <Veinor> i didn't even think of that
07:28:56 <Saizan> maurer_: you can keep it around as a typeclass context or a gadt, usually, but i'm not so familiar with these bindings
07:29:19 <Saizan> i've only see augustss' posts
07:29:23 <Saizan> *seen
07:30:03 <maurer_> Saizan: The problem is they made "call" a variadic function
07:30:15 <maurer_> So if you can't pass it the exact type, it will fail to typecheck
07:30:48 <pokoko222> yo haskellers i am so happy i am about to start abstract algebra course soon
07:30:52 <maurer_> I may have made a mistake, but I think I searched pretty exhaustively and ended up figuring out that it would require something as powerful as dependent types
07:31:00 <Saizan> variadic in haskell means there's some typeclass magic involved, so you can pack the necessary dictionary inside the existential
07:31:45 <maurer_> Well, yes, but I looked at how their typeclass magic works, it's essentially 
07:34:12 <centrinia> pokoko222, what does that abstract algebra course cover?
07:34:18 <maurer_> http://hpaste.org/43414/llvm_code
07:34:28 <maurer_> Basically it just unrolls a function type
07:35:11 <Bynbo7> maurer_: sorry, i missed everything after the thing about needing to know every type at runtime
07:35:33 <maurer_> Bynbo7: That's fine, I was mostly talking to Saizan
07:35:41 <Bynbo7> righto
07:35:41 <pokoko222> centrinia actually it is called algebraic structures, it covers rings, algebras, stuff like that i dont know more 
07:36:11 <pokoko222> i remember how frustrating it was learning abstract algebra on my own to understand haskell's monads and all that crazy stuff
07:36:22 <Saizan> maurer_: i guessed so
07:36:25 <pokoko222> from theoretical point of view practically they were not a shard
07:36:30 <Kaidelong> you do not need to understand monads to use them
07:36:34 <Omie_> Hi people ! My Haskell age is 15 mins and I am kinda stuck on step 9 on tryhaskell.org
07:36:39 <Kaidelong> that said they are trivially simple (in haskell)
07:36:46 <Kaidelong> just abstract
07:36:47 <pokoko222> Kaidelong yah i just said that :)
07:37:48 <maurer_> Saizan: Is there something I could read that would show an example of defeating that with existentials? I really can't see how you might do that.
07:37:50 <Saizan> Omie_: we don't exactly know what step 9 is
07:38:07 <Omie_> I tried all the commands there again and again, they are correct but its not going to step 10. 
07:38:27 <jmcarthur> Omie_: what is step 9?
07:38:48 <jmcarthur> Omie_: this channel is not specifically for tryhaskell, for the record
07:39:15 <jmcarthur> so that's why we wouldn't just know :)
07:39:17 <Kaidelong> Omie_: do the "let villain..." thing
07:39:23 <Kaidelong> and it'll advance to the next step
07:39:24 <Omie_> Saizan_  its about using variables. last command to try is ' let villian = (28,"chris") in fst villian '
07:39:39 <Omie_> i did that ~5-6 times
07:39:55 <Kaidelong> just type step10 then
07:39:58 <Saizan> tried with villan ?
07:40:06 <Omie_> yup
07:40:13 <Kaidelong> Omie: the name of the villain is "chirs"
07:40:37 <maurer_> I just tested it, the command's working fine.
07:40:40 <Omie_> oh okay. I did not know I can jump directly. step10 did the trick. Thanks for your time :)
07:40:49 <joaopizani> Omie_: just "let villa­in = (28, "chri­s") in fst villa­in" did it for me
07:40:56 <Bynbo7> Omie_: stick around, ask questions
07:41:02 <jmcarthur> Omie_: by the way, i just tried it and it worked for me. i typed it litterally as was shown
07:41:06 <Kaidelong> let villain = (28,"chirs") in fst villain
07:41:08 <Kaidelong> did it for me
07:41:10 <jmcarthur> *literally
07:41:13 <jmcarthur> ha
07:41:26 <roconnor> > let villa­in = (28,"­chirs") in fst villa­in
07:41:27 <lambdabot>   <no location info>: lexical error at character '\173'
07:41:33 <Omie_> sure :) I'll be around.. got quite fed up of C# so thought to jump in :)
07:41:39 <roconnor> :(
07:41:51 <Twey> What's up with the crazy encoding, people?
07:41:56 <Kaidelong> Omie
07:41:58 <centrinia> > let villain = (28,"chris") in fst villain
07:41:59 <lambdabot>   28
07:42:12 <centrinia> > let villain = (28,"chris") in snd villain
07:42:13 <lambdabot>   "chris"
07:42:16 <Kaidelong> if you have a .NET background
07:42:24 <Kaidelong> you might want to check out "Real World Functional Programming"
07:42:26 <Kaidelong> good book
07:42:46 <Bynbo7> that's not one of jon harrop's books is it?
07:43:11 <roconnor> "\173"
07:43:15 <Saizan> maurer_: augsutss' has some posts about keeping type information as a gadt, though i'm not so sure what exactly you want to be able to do, compile some function with (statically) unknown type and yet call it from main with arguments of a statically fixed type?
07:43:16 <roconnor> > "\173"
07:43:17 <lambdabot>   "\173"
07:43:19 <Kaidelong> Bynbo7: Tomas Petricek
07:43:26 <roconnor> > text "\173"
07:43:27 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
07:43:30 <Bynbo7> Kaidelong: then that's ok then :)
07:43:40 <roconnor> @type text
07:43:41 <lambdabot> String -> Doc
07:44:00 <centrinia> > ord '\173'
07:44:00 <Omie_> is there any free ebook ? I am not as .NETty per say. I do c/c++/vb.net/c#/php etc..
07:44:01 <lambdabot>   173
07:44:04 <emph> Hi there. When in ghci I load the System.Directory module. After that I try to call getTemporaryDirectory which returns an error on loading package unix 2.3.2.0. Anyone know what the problem is?
07:44:11 <centrinia> > chr 173
07:44:12 <lambdabot>   '\173'
07:44:18 <Bynbo7> Omie_: there's free haskell ebooks :)
07:44:20 <Bynbo7> @where lyah
07:44:20 <lambdabot> http://www.learnyouahaskell.com/
07:44:28 <Bynbo7> Omie_: you should start with lyah
07:45:32 <Bynbo7> try haskell's not quite there yet from what i can tell
07:45:35 <gwern> @where rwh
07:45:36 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
07:45:38 <Omie_> okay. Googling. Thanks. For now I'll finish with tryhaskell.org first
07:45:52 <Bynbo7> no need to google, i just gave you the link :P
07:45:54 <Bynbo7> @where lyah
07:45:54 <lambdabot> http://www.learnyouahaskell.com/
07:46:10 <Omie_> yeah right :-P :)
07:46:50 * Kaidelong remembers that picking up Haskell was easier the second time he tried, already having done FP in a more familiar environment
07:47:06 <Kaidelong> less new things to learn all at once
07:47:25 <nika> hey! I need s mall help with haskell. I need to make from a string with small digits and string with big ones. in:"asdf" out:"ASDF" http://codepad.org/klS74RsO I have done it but haskell shows me an error  toUpper' "fffd" "FFFD*** Exception: pip.hs:5:0-43: Non-exhaustive patterns in function toUpper'
07:48:04 <sepp2k> nika: You don't handle the case where the string is empty.
07:48:07 * hackagebot parsec 3.1.1 - Monadic parser combinators  http://hackage.haskell.org/package/parsec-3.1.1 (AntoineLatter)
07:48:19 <fryguybob> nika: toUpper' ""
07:48:35 <Saizan> maurer_: if so that requires a runtime type check, and Data.Typeable should work for that
07:48:36 <Kaidelong> better:
07:48:41 <Kaidelong> toUpper' = map toUpper
07:48:52 <Kaidelong> > map toUpper "nika"
07:48:54 <lambdabot>   "NIKA"
07:49:09 <Kaidelong> @ty map toUpper
07:49:10 <lambdabot> [Char] -> [Char]
07:49:42 <nika> fryguybob: yeah, I know this. but I domnt know how to define that in a code. like isUpper' [] = [] will not work as it is a list 
07:50:21 <Kaidelong> fryguybob: it will work!
07:50:24 <sepp2k> nika: Sure it will work.
07:50:25 <Kaidelong> > [] :: String
07:50:26 <lambdabot>   ""
07:50:31 <Kaidelong> err
07:50:33 <Kaidelong> nika I mean
07:50:46 <Kaidelong> @ty "foo"
07:50:47 <lambdabot> [Char]
07:50:52 <Bynbo7> nika: strings are lists
07:51:05 <Bynbo7> > ['a','b','c'] == "abc"
07:51:06 <lambdabot>   True
07:51:17 <sepp2k> nika: Also your isLower function doesn't do what its name suggests, so you should probably rename it.
07:51:34 <nika> fryguybob: oh... it works.. m.. it is strange... two minutes ago it didnt work
07:51:48 <fryguybob> > let toUpper' [] = []; toUpper' (x:xs) = toUpper x : toUpper' xs in toUpper' "abc"
07:51:49 <lambdabot>   "ABC"
07:51:54 <Kaidelong> nika: anyway why not just use map and save yourself the trouble =)
07:52:03 <fryguybob> > let toUpper' "" = ""; toUpper' (x:xs) = toUpper x : toUpper' xs in toUpper' "abc"
07:52:04 <lambdabot>   "ABC"
07:52:05 <nika> sepp2k: yeah. I know this%) but it is just for me
07:52:12 <Kaidelong> higher order functions is one of the big appeals to functional programming
07:52:16 <centrinia> nika, what is isUpper' '[' ?
07:52:18 <Kaidelong> especially in haskell
07:52:43 <sepp2k> nika: Also since your isLower' function does the same as the built-in toUpper function, why not use that?
07:52:58 <Kaidelong> > ord '[' > ord 'Z'
07:52:59 <lambdabot>   True
07:53:05 <fryguybob> @src map
07:53:05 <lambdabot> map _ []     = []
07:53:06 <lambdabot> map f (x:xs) = f x : map f xs
07:53:24 <Kaidelong> > chr (ord '[' - ord 'a' + ord 'A')
07:53:25 <lambdabot>   ';'
07:53:42 <Kaidelong> > toUpper '['
07:53:44 <lambdabot>   '['
07:54:09 <Kaidelong> sepp2k: they are different in fact, wee
07:54:19 <Kaidelong> > map (
07:54:20 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:54:37 <nika> Kaidelong: can I somehow avoid '[' being transefered into ;
07:54:46 <sepp2k> Kaidelong: But not intentionally as far as I can tell.
07:55:17 <Kaidelong> > map (\x -> if ord x > ord 'Z' then chr (ord x - ord 'a' + ord 'A') else x) "Different Trains (Steve Reich) [12:31]"
07:55:18 <lambdabot>   "DIFFERENT TRAINS (STEVE REICH) ;12:31="
07:56:07 <Kaidelong> nika: I imagine you could test >='a' and <='z'
07:56:12 <nika> sepp2k: could the line isUpper' [] =[] not work because first I imported Data.Char in the main interpreter
07:56:19 <centrinia> nika, make sure that ord 'a' <= ord x && ord x <= ord 'z' before you lower its case.
07:56:19 <Kaidelong> and only capitalize those
07:57:54 <Kaidelong> @src toUpper
07:57:55 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
07:58:34 <tibbe> What would a mutable tree look like? data MTree s a = Nil | Bin (STRef s a) (STRef (MTree s a)) (STRef (MTree s a))?
07:59:41 <Kaidelong> tibbe: Before you go off on this adventure, you are aware that immutable trees are very efficient, right, since they only copy spines?
07:59:52 <Omie_> Hi again ! about to sudo apt-get install ghc. I hope its a good choice than windows[particularly for haskell]. Fine with Ubuntu nah ?
07:59:56 <tibbe> Kaidelong: yes
08:00:03 <Kaidelong> okay
08:00:55 <Kaidelong> tibbe: That does not look wrong to me
08:00:57 <Bynbo7> tibbe: according to a talk by JaffaCake, IORef (Tree a) is extremely efficient as a concurrent data structure, using atomic
08:01:03 <nika> okay. thanks you all
08:01:04 <Bynbo7> atomicModifyIORef*
08:01:15 <Saizan> edwardk: sounds like you won't need the eta-expansion in 7.0.2 http://hackage.haskell.org/trac/ghc/ticket/4917#comment:2
08:01:28 <tibbe> Bynbo7: this is a simplification of my problem, I have 32 element arrays at each node that I want to avoid copying
08:01:28 <Bynbo7> tibbe: of course, i think most of its development is done on linux
08:01:47 <parcs> "Could not deduce (Functor m) from the context (Binary a, MonadIO m)"
08:01:51 <Bynbo7> yeah, i thought it might be that
08:01:52 <parcs> *grumble* 
08:02:57 <tibbe> I'm trying to figure out if I should mutate every part of the tree or only some parts
08:03:45 <Kaidelong> tibbe: if you are doing this to give a structure to a bunch of mutable arrays that you want to avoid copying, you could just use an immutable tree of pointers to mutable arrays, couldn't you?
08:04:06 <tibbe> Kaidelong: yes, that's probably what I'll end up doing
08:04:08 <Kaidelong> the overhead from the tree itself should be neglible and the arrays will never be copied
08:04:46 <fryguybob> Omie_: I can't speak to Ubuntu but I use Haskell Platform on Windows and it works fine for me.
08:04:55 * ddarius is actually pretty happy with his shave today.
08:05:07 <Kaidelong> fryguybob: Haskell on windows has... issues
08:05:08 <joaopizani> rename GlaucoNeves GlaucoNevesFacebook
08:05:12 <emph> what does can't load .so/.DLL for: dl (dlopen(libdl.dylib, 9): image not found mean? get this error with an example in rwh. 
08:05:17 <Bynbo7> ddarius: only cut off half an ear? =)
08:05:27 <Kaidelong> IE console buffering bug and getting wx or gtk bindings working is a complete nightmare
08:06:15 <Kaidelong> well, perhaps not anymore
08:06:39 * Kaidelong often is behind the times so he should be careful saying stuff like that
08:06:50 <ddarius> Bynbo7: Luckily, after cutting off half an ear the next time is only a quarter, then an eighth, etc.  So I can continue this ad infinitum until the molecular nature of matter starts botching things.
08:07:19 <Bynbo7> hooray!
08:09:47 <Saizan> emph: that you don't have libdl installed, i'd say
08:10:20 <Saizan> (does ghci still have problems with linker scripts?)
08:10:28 <emph> Can't find any libdl for os x
08:12:20 <Omie_> weeee ! ghc -o hello hello.hs \m/ Getting busy now... but I'll be around. Thanks for the help everyone :)
08:13:10 <Bynbo7> Omie_: good luck!
08:13:12 * hackagebot xml-enumerator 0.1.0.1 - Pure-Haskell utilities for dealing with XML with the enumerator package.  http://hackage.haskell.org/package/xml-enumerator-0.1.0.1 (MichaelSnoyman)
08:20:25 <andres_> hello
08:20:54 <andres_> anybody knows something about dependent types?
08:22:16 <roconnor> andres_: yes
08:25:17 <andres_> hello roconnor
08:25:45 <andres_> whats is the main difference between a normal type and a dependent type?
08:26:16 <azaq23> dependent types can depent on terms, which are themselves typed
08:26:40 <azaq23> classic example a vector in the vector space R^n, where n is a natural
08:26:49 <roconnor> what azaq23 said
08:28:49 <andres_> thank you azaq23
08:29:04 <andres_> thank you roconnor
08:32:59 <andres_> azaq23 it is something like types of types?
08:35:08 <parcs> @hoogle MonadFail
08:35:09 <lambdabot> No results found
08:36:45 <bjrn> Where does the "d" come from in the type signature of Control.Arrow.first? first :: (Arrow a) => a b c -> a (b, d) (c, d)
08:36:50 <azaq23> You mean kinds? Well, standard type constructors have a "function kind" type - Maybe has * -> *, meaning it takes a type of kind * and produces a type of kind *
08:37:44 <azaq23> A dependent type is like a type constructor which also takes normal types - vector_space_r_of :: Int -> *
08:38:04 <Cale> bjrn: Might help to think of it in the case of a = (->), where the type reduces to (b -> c) -> ((b,d) -> (c,d))
08:38:28 <azaq23> *also takes normal terms
08:38:50 <bjrn> Cale: Thanks, I will think about that for a while.
08:40:02 <Cale> bjrn: You should think of an arrow computation of type a b c as a box with an input wire of type b, and an output wire of type c
08:40:59 <Cale> first turns such a box into a box with a pair of inputs of types (b,d) and a pair of outputs of type (c,d), basically by wiring the d input directly to the output.
08:48:35 <parcs> what is the most pragmatic way of effectively redefining fail for the IO monad?
08:51:28 <Cale> parcs: avoiding having to do that?
08:51:56 <Cale> parcs: Why do you want to redefine fail? I mostly just try to pretend that it doesn't exist.
08:53:04 <parcs> Cale: during client-server communication, i want an unexpected packet, i.e one isn't pattern-matched for, to throw an UnexpectedPacket exception or something
08:53:42 <Cale> Oh, then just catch and re-throw the exception which is produced.
08:53:52 <shenshei_> hello, there is a way to get a .hs file from a .lhs ?
08:53:52 <monochrom> case packet of Expected_0 -> ... Expected_1 -> ... _ -> throw
08:54:05 <parcs> monochrom: that gets repetitive
08:54:12 <Cale> Or else handle the unexpected case and use throw, yeah.
08:54:41 <parcs> Cale: oh, i didn't know fail threw an exception
08:55:51 <dafis> shenshei_:  yes, there's an option for ghc, I forgot what, and cabal has an unlit too
08:56:14 <ddarius> parcs: What did you think it did?
08:56:21 <ddarius> @src IO fail
08:56:21 <lambdabot> fail s  = failIO s
08:56:27 <ddarius> Very useful lambdabot.
08:56:35 <Cale> haha
08:56:59 <monochrom> haskell 98 doesn't say fail is catchable, that's why.
08:57:04 <Cale> It could call error instead, which would be different from a Haskell 98 point of view.
08:57:11 <ddarius> monochrom: Doesn't it use ioError?
08:58:07 <monochrom> oh oops, haskell 98 says IO fail is ioError, so it's catchable.
08:58:45 <ddarius> See the bottom of http://haskell.org/onlinereport/io-13.html
09:00:35 <shenshei_> dafis: I search the option but I don't find it 
09:00:45 <parcs> ddarius: i thought it just unconditionally halted the program
09:01:11 <dafis> shenshei_:  I don't find it either, maybe it's been removed or I misremembered
09:01:19 <parcs> fail sounds very serious
09:02:56 <monochrom> > fail "curiosity kills the cat" `mplus` ["satisfaction brings it back!"]
09:02:57 <lambdabot>   ["satisfaction brings it back!"]
09:03:38 <fryguybob> shenshei_:  -E perhaps?
09:05:40 <dafis> shenshei_:  yes, more or less -E produces a .hspp file, which is almost a valid .hs file
09:07:05 <dafis> shenshei_:  you get something like {-# LINE 1 "Lit.lhs" #-}
09:07:05 <dafis> #line 1 "Lit.lhs" at the top
09:07:44 <duairc> Does anybody use wai? How do you get the body of a request using wai?
09:24:30 <imnotanerd> meh... clojure ^_^
09:32:24 <andres_> anyone knows if haskell has his own special types?
09:32:54 <aristid> andres_: special types for what?
09:36:50 <andres_> like a primitive types
09:37:20 <Eduard_Munteanu> Yeah, kind of... the unboxed primitive types.
09:37:33 <Eduard_Munteanu> like Int#
09:37:39 <Eduard_Munteanu> :t 5#
09:37:40 <lambdabot> GHC.Prim.Int#
09:38:28 <Eduard_Munteanu> Erm, well, that rather answers the question for GHC, not Haskell, but still.
09:38:44 <Eduard_Munteanu> For Haskell, the report defines a few standard types.
09:39:12 <Eduard_Munteanu> They're primitive in the sense you can't define them in terms of other constructs.
09:55:01 <retroj> hi.  How can I get local time, formatted similarly to what is returned by Data.Time.Clock.getCurrentTime?
09:57:56 <SirFrancisDrake> retroj: man date? Get it from where?
09:58:56 <monochrom> look for things in Data.Time.Format
09:59:16 <retroj> i think i found what i was looking for, Data.Time.LocalTime
09:59:21 <Twey> retroj: Data.Time.LocalTime.getZonedTime
09:59:29 <retroj> thank you
10:00:12 <Twey> Then Data.Time.Format.formatTime
10:00:46 <ryant50001> has anyone else gotten these problems with :history?
10:00:48 <ryant50001> Exception: compiler/main/InteractiveEval.hs:(182,14)-(186,47): Irrefutable pattern failed for pattern Data.Maybe.Just decl
10:01:11 <monochrom> which version?
10:01:18 <ryant50001> ghci-7.0.1
10:01:27 <ryant50001> got the same thing in 6.12.1 as well
10:02:03 <retroj> aha, i'm seeing how it fits together, thanks!
10:15:06 <ddarius> ryant50001: Check the trac and if it's not there, put it there.
10:16:49 <retroj> it has not yet ceased to amaze me when i write a bit of haskell and it works perfectly the first time.  thanks all!
10:17:59 <peoro> hello
10:19:57 <peoro> what's the difference between a function declared globally in the package, and a function declared with `let' ?
10:20:05 <peoro> only the scope where it's defined?
10:21:23 <Twey> peoro: A name bound with ‘let’ is available only in the expression following the ‘in’ keyword
10:21:38 <Twey> Or in the do-block from that line down, using the let ‘do’ sugar
10:22:17 <peoro> ok, thus the only difference is the scope where it's defined...
10:22:51 <peoro> I'm wondering because in some examples I find on the Internet they often use global functions where I'd use one defined with `let'
10:23:14 <peoro> for example `main = toTry `catch` handler', and then they define `toTry' and `handler' as global function
10:23:33 <ryant50001> that seems like a good time for a 'let' or 'where'
10:25:00 <Scriptor> hi everyone, just wanted to make sure of something
10:25:33 <Scriptor> for list comprehensions, if you're going through multiple lists it goes through every combination of the two lists' elements, right?
10:26:42 <c_wraith> > [ (x, y) | x <- [1,3,5], y <- [2,4,6] ]
10:26:44 <lambdabot>   [(1,2),(1,4),(1,6),(3,2),(3,4),(3,6),(5,2),(5,4),(5,6)]
10:26:48 <jmcarthur> Scriptor: yes when your bindings are separated by commas
10:26:57 <copumpkin> not necessarily every combination :)
10:27:19 <copumpkin> > [ (x, y) | x <- [1,3,5], y <- [2..] ]
10:27:20 <lambdabot>   [(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12),(1,13...
10:27:24 <jmcarthur> Scriptor: there's also another syntex like [(x, y) | x <- [1,3,5] | y <- [2,4,6]]. that would be more like a zip
10:27:41 <copumpkin> if you want every combination in that case, you should use something like omega
10:27:43 <jmcarthur> Scriptor: also, what copumpkin said, and there's also guards which prevent every combination from appearing your result, too
10:28:07 <jmcarthur> > [ (x, y) | x <- [1,3,5], y <- [2,4,6], x < y ]
10:28:09 <lambdabot>   [(1,2),(1,4),(1,6),(3,4),(3,6),(5,6)]
10:28:26 <Scriptor> right, that's what I thought
10:28:29 <jmcarthur> > [ (x, y) | x <- [1,4,5] | y <- [2,4,6], x < y ]
10:28:30 <lambdabot>   []
10:28:36 <copumpkin> > (liftA2 (=<<) zip (tail . tails)) [1..6]
10:28:38 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(1,3),(2,4),(3,5),(4,6),(1,4),(2,5),(3,6),(1...
10:28:39 <Scriptor> just making sense of the code from http://codewords.wordpress.com/2011/01/28/a-beautiful-but-slow-solution-to-project-euler-problem-9/
10:28:47 <jmcarthur> i've never used guards with the parallel list comps...
10:29:07 <jmcarthur> Scriptor: i don't find slow solutions to be so beautiful, for the record ^_^
10:29:17 <Scriptor> I know :)
10:29:27 <copumpkin> there's a more beautiful solution to that that's fast, too
10:29:54 <jmcarthur> i think the blog author finds it beautiful only because it mimicks familiar math notation
10:30:21 <Scriptor> yep, it's a nice example of lazyness as well
10:30:23 <Eduard_Munteanu> Probably in the sense the naive Haskell qsort is beautiful.
10:30:24 <jmcarthur> it would be nice if we could use list comprehensions with omega
10:30:29 <Scriptor> but it's still just brute forcing it
10:30:37 <copumpkin> jmcarthur: monad comprehensions, soon
10:30:44 <jmcarthur> copumpkin: i know ^_^
10:31:08 <Eduard_Munteanu> What's omega?
10:31:16 <jmcarthur> Eduard_Munteanu: actually the naive Haskell qsort is not that bad, IMO. it's not quite as fast as an in-place version, but i don't care so much about that
10:31:18 <Eduard_Munteanu> I presume it isn't the fixpoint combinator.
10:31:25 <jmcarthur> the concatenation is a bit annoying i guess
10:31:38 <Eduard_Munteanu> jmcarthur: still, the pivot choice is bad usually.
10:31:40 <copumpkin> http://hackage.haskell.org/package/control-monad-omega
10:31:44 <jmcarthur> Eduard_Munteanu: you can think of it as prolog in the form of a haskell dsl :)
10:32:11 <Eduard_Munteanu> Hm looks interesting...
10:32:14 <jmcarthur> Eduard_Munteanu: an array version could find a better pivot and have essentially the same high-level definition
10:32:33 <jmcarthur> *find a better pivot in a reasonable amount of time
10:33:08 <jmcarthur> for example, the typical NDP qsort just uses the first value as a pivot, but it could find a better one without much extra effort, and it's still pretty elegant, IMO
10:33:17 <jmcarthur> *very* elegant when you consider the parallelism :)
10:33:32 <Eduard_Munteanu> Yeah, or it could just pick one randomly.
10:33:40 <jmcarthur> yup
10:33:47 <jmcarthur> yay for constant time indexing
10:33:50 <dafis> jmcarthur:  would picking the median of three values in the middle have a reasonable chance to get a good enough pivot?
10:34:08 <jmcarthur> dafis: it's not uncommon to pick the median of the first, last, and middle values
10:34:13 <jmcarthur> as a simple heuristic
10:34:56 <dafis> jmcarthur:  any theoretical reasons for including first and last?
10:35:15 <aristid> you can clearly see both the join and fmap components: Omega m >>= f = Omega $ diagonal $ map (runOmega . f) m
10:35:17 <dafis> i.e. is that better than picking three at random?
10:35:38 <copumpkin> aristid: which is why join would be way cleaner here
10:35:45 <copumpkin> since he clearly wrote join first :P
10:35:50 <jmcarthur> dafis: more like real-world reasons. often you get a partially sorted list, etc.
10:36:07 <mafs> Any ideas why Haskell Platform 2010.2.0.0's GHC-6.12.3-i386 package won't install on OS X 10.6.6? Installer opens and gets all the way to the Installation Type step, but the Install button is disabled :/
10:36:19 <aristid> copumpkin: yeah.
10:36:27 <copumpkin> mafs: it's a bug
10:36:28 <jmcarthur> dafis: where the partial sort is often kind of strange :)
10:36:32 <copumpkin> click on the "Computer"
10:36:42 <copumpkin> someone should email the maintainer
10:36:50 <jmcarthur> i can't really come up with a concrete scenario that would make sense in isolation though
10:37:03 <jmcarthur> well, not without much explanation, at least
10:37:30 <dafis> jmcarthur:  so, basically, it seems reasonable and has worked well in practice?
10:37:52 <aristid> copumpkin: but does Omega abide by the monad laws?
10:37:57 <copumpkin> no
10:38:02 <copumpkin> unless you view the list as a set
10:38:11 <copumpkin> or a multiset I guess
10:38:12 * dafis throws Omega into jail
10:38:48 <mafs> copumpkin: the "computer" in the description text for that step?
10:39:32 <copumpkin> the thing where it gives you the option to install for one user (not there) or the whole computer
10:39:38 <copumpkin> click on the only option in that box
10:39:54 <copumpkin> it looks selected, but isn't
10:40:56 * copumpkin eats some coconut
10:41:09 <jacobian> ;)
10:41:17 <jacobian> is a coconut just a nut? 
10:41:19 <mafs> copumpkin: http://208.122.1.207/share/ghc.png is all I see.
10:41:31 <copumpkin> oh, that's fucked up
10:41:42 <copumpkin> mine usually has a greyed-out button further down
10:42:49 <mafs> Damn. Guess it doesn't want me to be an OS X Haskeller :(
10:43:31 <copumpkin> sry, not cool enough
10:43:37 <Twey> Heh
10:46:05 <aristid> there's a Glorious missing in the title
10:46:18 <Twey> So there is
10:51:13 <peoro> hum... where can I find a good tutorial/documentation about how to use regular expression?
10:54:57 <copumpkin> peoro: all over the internet :P
10:55:04 <copumpkin> it even has its own *overflow
10:55:31 <peoro> copumpkin, no, I meant... the haskell regex package, Text.Regex
10:55:32 <ddarius> That's ridiculous.
10:55:42 <copumpkin> oh, not sure
10:55:54 <Saizan> use regex-compat to get a sane interface
10:56:02 <copumpkin> oh wait, it doesn't have its own *overfow
10:56:06 <copumpkin> I was confuzzled
11:07:26 <taotree> Question regarding code on http://pastebin.com/JWvq6sch
11:08:09 <copumpkin> taotree: you're assuming existential quantification when it's universal
11:08:26 <copumpkin> ds :: [(a -> b, b -> c)]
11:08:33 <copumpkin> that means ds :: forall a b c. [(a -> b, b -> c)]
11:08:41 <copumpkin> meaning it needs to work for all types a, b, and c
11:09:08 <copumpkin> you're providing a ds that works on only specific types a, b, and c
11:10:34 <taotree> so right hand of the ds =, the types are too specific, whereas the type of ds requires all types to be handled
11:11:21 <SirFrancisDrake> when does one want to use Control.Arrow in practice? Or does ever? 
11:11:46 <c_wraith> In practice?  when I want &&& or ***
11:11:53 <c_wraith> I guess I've also used it for left and right
11:12:07 <dafis> first and second?
11:12:09 <c_wraith> and occasionally first and second
11:12:26 <c_wraith> But..  I've never used non-function arrows
11:12:40 <SirFrancisDrake> that's the question :)
11:13:13 <c_wraith> though second is the same as fmap.
11:13:20 <azaq23> Maybe something using Kleisli in case it is thought to be more "clear", or more in line with other "arrow like" types, but I just pulled this completely out of the hat
11:14:02 <taotree> copumpkin, is there a way to declare existential quantification?
11:14:11 <copumpkin> no
11:14:24 <dafis> {-# LANGUAGE ExistentialQuantification #-}
11:14:44 <dafis> but you can't use that for []
11:14:52 <dafis> only for your own types
11:15:43 <taotree> but I could create my own type... like a tree structure or something that would give me a "collection" that could do that perhaps?
11:16:31 <dafis> taotree:  haven't looked at what you try, so: maybe
11:17:06 <c_wraith> :t fmap `asTypeOf` second
11:17:07 <lambdabot> forall a b d. (a -> b) -> (d, a) -> (d, b)
11:17:57 <dafis> :t first `asTypeOf` second
11:17:59 <lambdabot> forall (a :: * -> * -> *) b. (Arrow a) => a b b -> a (b, b) (b, b)
11:18:53 <c_wraith> :t first `asTypeOf` fmap
11:18:54 <lambdabot> forall b. (b -> b) -> (b, b) -> (b, b)
11:19:46 <c_wraith> heh.  the resulting types are less useful when the two functions don't actually do the same thing when operating on the type in question.
11:20:15 <dafis> but nice opportunities for obfuscation
11:21:30 <azaq23> taotree: Describe what you're trying to do, there is likely a better solution than putting those functions in existentially quantified wrappers into a list.
11:21:43 <azaq23> Which likely wouldn't help you anyways
11:21:53 <taotree> sure, but I'm learning, which is always good.
11:22:03 <taotree> ok... The idea was to build a collection of functions that could be composed
11:22:13 <taotree> return type of one matches the input type of the other
11:22:49 <aavogt> taotree: there was a GADT-based package on hackage for that
11:23:26 <aavogt> http://hackage.haskell.org/package/thrist
11:24:09 <taotree> aavogt, thanks, that looks very interesting
11:26:39 <alej> I'm having a question about how to keep multiple object definitions modular for a game. I could either have a data type with different type constructors for each different game type, or a single data type with a data field that is Dynamic, and then functions that can query that Dynamic type.
11:27:01 <alej> so one case might be something lik http://pastebin.com/fKCDCKc6, the Dynamic alternative would be http://pastebin.com/jNDqVmFL
11:29:30 <jmcarthur> alej: another alternative would be for all your related game entities to share a common structure with some of the fields being functions. that would enable you to give each object different functionality
11:29:50 <BMeph> alej: How does keeping separate object definitions confined to the same type "keep them modular"?
11:30:31 <jmcarthur> alej: so, say some entities move differently from others. you could have a field for the movement function
11:30:33 <alej> jmcarthur: well some of the types might need a lot of different fields which dont make sense for all types to have
11:30:38 <alej> jmcarthur: sure, and i plan on doing that
11:30:45 <jmcarthur> alej: and in that case you could use some sort of composition
11:30:46 <alej> but say it were a space game
11:31:00 <alej> there would be a spaceship type with lots of different information that other ships would want to observe
11:31:06 <alej> health, armor, ship class, etc
11:31:12 <jmcarthur> alej: so you could have some records for some types of functionality, and other records for others. then you could compose the two to get another kind of entity that has the combined functionality
11:31:40 <alej> BMeph: it feels like the module will get cluttered witha ll of the datatypes required for the game
11:32:30 <azaq23> taotree: In that case existentially quantification could actually work. Of course, you couldn't use the complete list for anything, only a specific tuple in it. And since functions don't have interesting instances, you couldn't do much with that as well
11:33:59 <alej> BMeph: in other words, i kind of want a module that specifies an interface, and then modules for each of the different object types i might want to add, so that it is easy to add new types
11:34:16 <alej> though that's more of an idea from OO programming and I want to map it into something haskelly
11:34:51 <alej> jmcarthur: so then I end up with a single module that contains all the datatypes i need. i guess that's not bad per se, but something about it feels wrong
11:35:01 <jmcarthur> alej: another design would be for all your entities to just have some abstract identity, and then you could index into various data structures to find out what properties your entities have. so you could have a partial collection mapping identities to health stats, another to rendering information, etc. so for your example, instead of having particular ships observe other ships, you could just have a 
11:35:03 <jmcarthur> function the operates on your large collections at once without regard for dispatching on the type of each entity
11:35:46 <jmcarthur> i guess my "example" wasn't really an example
11:35:59 <jmcarthur> alej: i didn't say anything about modules
11:36:13 <ddarius> Nor did BMeph.
11:36:19 <alej> jmcarthur: i'm just trying to imagine how i would go about implementing it
11:37:55 <jmcarthur> alej: i personally wouldn't make any particular object to represent each entity in the game. i'd personally rather go for collections of similarly-typed data across all entities
11:38:26 <jmcarthur> and if some entities don't have some of that data, they just don't get a record in the corresponding collection
11:38:56 <jmcarthur> each of these collections can be in different modules. they don't have to be aware of each other
11:38:58 <BMeph> I'm just wondering what kind of "haskelly" things a "module" and "interface" as supposed to be. I can think of a few solutions, but I'm not sure what the problem is.
11:39:52 <BMeph> er, what kind of things they ARE supposed to be.
11:40:11 <jmcarthur> alej: i'm kind of with BMeph. it sounds like you're trying to map typical OO approaches to haskell, which isn't always the best way to go
11:40:34 <alej> jmcarthur, BMeph: I agree that it isn't the right way to go, i just dont know what a good design is
11:40:37 <jmcarthur> but, for the record, my first proposal is perfectly OO. my second is not all that OO, however
11:41:00 <ddarius> jmcarthur: It's relational (using that term somewhat loosely.)
11:41:00 <jmcarthur> in fact, OO suffers from the same design issues that you are bringing up here, despite not having a reputation for it
11:41:05 <jmcarthur> ddarius: indeed
11:41:53 <alej> BMeph: essentially I'm evaluating designs by thinking - how much work is it to introduce a different kind of entity to this system
11:41:56 <jmcarthur> a lot of MMO backends actually use SQL for this, in fact
11:42:15 <jmcarthur> alej: my suggesting is to do away with the idea of "different kinds of entities"
11:42:16 <alej> so you have a collection of health, say, and then query that store with an object's id
11:42:19 <jmcarthur> *suggestion
11:42:33 <jmcarthur> sure, although it can be a little more coarse grained if you want
11:42:42 <alej> sure
11:42:43 <BMeph> alej: One of the "problems" with Haskell, is that what you want to do strongly affects the ways to do it. A lot of the time with OO languages, you can just "throw code at the wall and see what sticks". In Haskell, though, you can (and should) do things differently depending on what it is you want.
11:42:48 <jmcarthur> and the queries would actually be very unusual
11:42:59 <jmcarthur> generally you'd just have functions that work on entire collections at a time
11:43:08 <jmcarthur> (it's more parallel, in that sense)
11:43:28 <ddarius> BMeph: I don't think that property holds for OO languages.
11:43:33 <jmcarthur> nor do i
11:43:37 <ddarius> Or any languages for that matter.
11:43:57 <alej> jmcarthur: what do you mean entire collections at a time? I'm not sure if that's what i was thinking or not
11:45:14 <jmcarthur> alej: i mean that you would rarely, if ever, write code to operate "from the point of view" of a particular entity. you don't iterate over each entity ID and then do all the actions for that entity at once. instead you iterate over each action in the game and update all the entities at once for each action
11:45:38 <jmcarthur> alej: so it's just transformations on your collections rather than transformations on your entities
11:45:55 <jmcarthur> alej: and in some sense your entities are updated in lock-step
11:46:15 <alej> well say it was just a simulation of things moving around, like a flock simulation
11:46:32 <alej> i still dont see how you aren't iterating per entity
11:46:44 <jmcarthur> that's too simple
11:46:51 <jmcarthur> in that case, they are the same thing
11:47:20 <jmcarthur> let's say that you have a flock simulation, but you also need to track health stats and kill them off if they collide too much or something
11:47:34 <jmcarthur> so you would take your collection of positions and update them
11:48:00 <jmcarthur> then you would take the position data and collect the collisions
11:48:06 <alej> oh ok
11:48:08 <jmcarthur> then you would use that data with all the health data
11:48:13 <alej> yeah that seems natural to me
11:48:16 <jmcarthur> to update the health stats
11:48:22 <alej> rather than for each entity: move, collide, health
11:48:25 <jmcarthur> exactly
11:48:27 <alej> it's move all, collide all, health all
11:48:40 <jmcarthur> ^^
11:48:44 <alej> sure that seems natural
11:48:53 <alej> i like the idea of adding stores of properties or whatever
11:49:01 <jmcarthur> and the nice thing about it is that if some things can't move then you don't have those things in the move-all loop
11:49:11 <alej> and then an entity is a collection of functions and properties, and those functions know which properties they need to look at
11:49:16 <jmcarthur> no
11:49:25 <alej> well an abstract collection
11:49:29 <alej> not an actual type holding it
11:49:33 <jmcarthur> okay, yes
11:49:35 <alej> but there's a function for it
11:49:48 <jmcarthur> you can think of it as a "vectorized" game engine
11:49:56 <Runar> edwardk: Do you have your Observable/Observer actor refactoring somewhere?
11:50:03 <ddarius> Now all you need to do is compile it to a GPU.
11:50:08 <jmcarthur> hence why parallelism comes to mind :)
11:50:43 <alej> the final thing i need to think about is interactions, but i think it would be easy for some functions to emit actions that can be applied afterwards
11:51:06 <jmcarthur> alej: consider the "collide all" step :)
11:51:15 <jmcarthur> that's essentially how you do the interactions
11:52:05 <alej> i mean in the case that during the step function, an AI might decide to do something, like fire at another object, which would affect that object's health
11:52:19 <jmcarthur> alej: those decisions would also be made all at once
11:53:08 <jmcarthur> alej: there would be a point in your update function like "okay, i've moved everything, now i need to decide which things are firing at other objects, and after that i will decide how health is affected by both the moves *and* the attacks"
11:53:09 <alej> right, i just mean the actual updating of the collections
11:53:27 <jmcarthur> unless of course you want things that collide to not be able to fire right before they die or something
11:53:35 <jmcarthur> could be sidestepps by having them fire before moving
11:53:39 <jmcarthur> *sidestepps
11:53:41 <jmcarthur> grr
11:53:43 <BMeph> Observe, Orient, Decide, Act. It's a very popular system. :)
11:53:43 <jmcarthur> **sidestepped
11:54:03 <alej> yeah i just mean the mechanical part of actually when to do the update of the structure
11:54:14 <ddarius> Made by an Air Force guy.
11:54:20 <ddarius> The "OODA loop"
11:54:33 * BMeph knew ddarius would recognize it.
11:54:36 <ddarius> alej: Time-stamp all input.
11:55:40 <beastaugh> ddarius, BMeph: Robert Coram's biography of Boyd, if you haven't read it, is very good
11:55:44 <ddarius> (Unless your system is already turn-based.)
11:55:46 <beastaugh> (sorry, that's a bit off-topic)
11:56:44 <alej> hm I guess my question goes to how I would best update the collections
11:57:08 <alej> I guess I could thread the information through with the state monad
11:57:44 <jmcarthur> i'd do it without a monad at first. you might not actually need it
11:58:07 <jmcarthur> after all, it may be the case that you don't actually need to "return" anything but the new collection
11:58:16 <alej> that's true
11:58:18 <jmcarthur> in which case it's just a simple transformation
11:58:45 <ddarius> jmcarthur: I would actively architect towards such a situation.
11:59:01 <alej> no that's right, each move function would just need to look up the old position, and then it would figure out the new position
11:59:08 <jmcarthur> ddarius: :)
11:59:12 <alej> and then you could cons up the list of positions'
11:59:14 <alej> or map
11:59:59 <jmcarthur> alej: lookup is to be avoided if possible. better to just map over the whole collection
12:00:10 <rokoteko> so only because you can have monads you need to also have functors to be able to map over monadic functions?
12:00:21 <ddarius> alej: To reiterate what jmcarthur said earlier, think SQL.
12:00:51 <jmcarthur> alej: the whole idea here is that you don't actually *care* about the entity ID most of the time. the ID is used almost exclusively for "joins"
12:01:05 <ddarius> (or preferably something nicer than SQL)
12:01:07 <jmcarthur> joins would be the only time you should care about looking things up
12:01:20 <alej> eh i dont do any sql, so i'm not sure what you mean by joins
12:01:26 <ddarius> Oi.
12:01:33 <alej> =/
12:01:37 <jmcarthur> alej: i mean when you want to associate the data from two disparate collections
12:01:38 <ddarius> Then learn relational and logic languages.
12:01:39 <alej> not a noob, i swear, just a noob at this :(
12:02:14 <alej> jmcarthur: oh ok - well thats what i thought i needed, since i would want a collection of positions that can be observed, and a collection of functions that update the positions
12:02:42 <jmcarthur> alej: so you might have [(0, 'a'), (1, 'b'), (2, 'c')] and [(0, "foo"), (2, "bar")]. one kind of join would give you  [(0, 'a', "foo"), (1, 'b', "bar")]
12:02:53 <jmcarthur> ah you don't need a collection of functions, necessarily
12:03:11 <rokoteko> I think that would only make IO more difficult for an average programmer.
12:03:27 <alej> jmcarthur: no?
12:03:32 <jmcarthur> rokoteko: i'm not sure what you're getting at
12:05:12 <jmcarthur> alej: i'm not saying that's a *bad* idea, but normally you'll only have a couple kinds of movement anyway, so you could just have a couple different collections of positions (or, equivalently, a collection of positions and a collection of movement types that you could then join to get the same thing) and then you would just apply your two movement functions over two different collections or somesuch
12:05:20 <jmcarthur> not that that's necessarily better
12:05:26 <jmcarthur> it all depends on the nature of your data
12:05:51 <rokoteko> jmcarthur: I mean it's just more confusing terminology.
12:06:10 <alej> ddarius: I understand/know the ideas i think, just dont always know the names for things
12:06:15 <jmcarthur> alej: again, it might be good to envision that you are working with a vector machine or some sort, so you want to try always doing exactly the same thing to lots of objects at the same time
12:06:52 <jmcarthur> rokoteko: unfamiliar terminology is a terrible reason to write something off, IMO
12:06:56 <ddarius> alej: If you've never used SQL then you probably have a massive hole in your knowledge.
12:07:41 <alej> ive used it only sparingly, but i also dont claim to be a web app or BI expert
12:07:50 <jmcarthur> funnily enough, i don't think i've ever thought of SQL as working with a vector machine
12:08:10 <jmcarthur> maybe that demonstrates a weakness
12:08:22 <jmcarthur> (about me, that is)
12:08:29 <alej> ddarius: dunno, could be a massive hole, but i think you make it sound more serious than it actually is
12:08:38 <franka> I have a massive hole in my knowledge.
12:08:41 * roconnor finds first class IO in Haskell makes using calbacks less confusing
12:09:29 <jmcarthur> this is making me want to get back into game dev yet again
12:09:56 <alej> jmcarthur: it's always been tempting, but it's so easy to get bogged down and never actually get anywhere
12:10:40 <jmcarthur> alej: i don't know that i'd call it a "massive hole" so much as a sign that you may not be as mentally flexible about some problems as you could be
12:10:42 <ddarius> alej: It depends, but if the terminology of "joins" isn't familiar to you then you are probably missing a whole bunch of database theory.  And writing off databases/DB theory, as "just for web apps and BI" is a big mistake.
12:10:47 <beastaugh> does anyone know how I can make text bold in Haddock markup?
12:11:07 <franka> I understand "join" as relational composition.
12:11:16 <alej> ddarius: that's true, but i thought you meant "use SQL" in a different way
12:11:24 <alej> but i agree with what you said
12:11:43 <ddarius> Not using SQL is just indicative.
12:11:51 <aavogt> beastaugh: /is this bold?/
12:11:55 <ddarius> I actually know quite a bit about DB theory before I wrote any significant amount of SQL.
12:12:10 <ddarius> s/know/knew/
12:12:11 <dafis> aavogt:  no, italics, iirc
12:12:23 <alej> that's not surprising. out of curiosity, what context do you write most of your SQL in
12:12:27 <jmcarthur> > [(i, a, b) | (i, a) <- [(0, 'a'), (1, 'b'), (2, 'c')], (i', b) <- [(0, "foo"), (2, "bar")], i == i']  -- simple, inefficient join
12:12:28 <lambdabot>   [(0,'a',"foo"),(2,'c',"bar")]
12:12:44 <franka> Is it the context of love?
12:12:57 <jmcarthur> don't ask me what kind of join that is though. i forget all the names
12:13:21 <beastaugh> aavogt: /is emphasis but mangles SGML entities like &#968;/
12:13:48 <aaaaaaaaa_> Hi.What means "heavy casting" in haskell type system
12:13:50 <aavogt> jmcarthur: if you can't order your keys can you be more efficient?
12:14:06 <ddarius> alej: My context is indeed "web apps and BI" for my job, but I've certainly considered if for MMO games as jmcarthur mentioned and physics simulations (though I'd probably use something different from SQL in the latter.)
12:14:08 <jmcarthur> aavogt: the inefficiency is in the data structure i chose, to be exact
12:14:31 <alej> ddarius: i'm not trying to trivialize anything, those just struct me as venues where I would expect a lot of database interaction
12:14:39 <alej> *struck, too much c
12:14:56 <ddarius> alej: They are, and they are certainly major consumers and drivers of database technology.
12:15:20 <alej> alrighty then
12:15:21 <jmcarthur> alej: it's enlightening to think of a complex simulation like a game as a database, though. there really is a *ton* of various types of data. it kind of just makes sense :)
12:15:41 <alej> jmcarthur: yeah, it does definitely make a lot of sense. i like it
12:15:42 <ddarius> But databases are 50 years old and deal with rather non-trivial problems and have been applied to just about any problem you can think of.
12:16:03 <alej> i'm also not done learning :D
12:16:07 <aaaaaaaaa_> What means "heavy casting" in haskell type system
12:16:36 <ddarius> aaaaaaaaa_: It doesn't mean anything.  I've never heard the term "heavy casting."
12:16:37 <jmcarthur> aaaaaaaaa_: i've never heard of that
12:17:09 <aavogt> maybe something was mistranslated
12:17:53 <aaaaaaaaa_> So what is "heavy casting"
12:18:06 <aaaaaaaaa_> from programing perspective
12:18:28 <aavogt> @type unsafeCoerce
12:18:29 <lambdabot> Not in scope: `unsafeCoerce'
12:18:51 <jmcarthur> aaaaaaaaa_: no idea, like we said, we haven't heard the term before
12:18:53 <aavogt> @hoogle x -> y
12:18:54 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
12:18:54 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
12:18:54 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
12:19:12 <Olathe> @hoogle unsafeCoerce
12:19:12 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
12:19:15 <aaaaaaaaa_> ok. gonna google around and let u know
12:19:20 <aaaaaaaaa_> thanks. :)
12:19:33 * ddarius has never heard of the term "heavy casting" in any context whatsoever.
12:19:37 <jmcarthur> there are only a couple kinds of casting i know of in haskell. unsafeCoerce and Typeable
12:19:37 <dafis> aaaaaaaaa_:  I've only ever heard that expression meaning "using lots of casting" in C/Java &c
12:19:45 <jmcarthur> the latter allowing type safe casts
12:19:59 <Olathe> Heavy casting sounds like casting a lot of times per second or something.
12:20:07 <alej> hehe
12:20:20 <BMeph> OOM! Too much heavy casting. ;þ
12:20:27 <aaaaaaaaa_> xD
12:20:27 <jmcarthur> oom?
12:20:34 <jmcarthur> object-oriented madness?
12:20:34 <Olathe> Out of memory?
12:20:47 <Olathe> *got hit in stomach*?
12:20:52 <shachaf> Sounds to me like casting a heavy metal.
12:20:54 <BMeph> Out of mana! Y'know, because of all that casting... ;)
12:20:59 <jmcarthur> lol
12:21:04 <aaaaaaaaa_> lol
12:21:09 <Olathe> Haha
12:21:34 <jmcarthur> so does that mean somebody that writes a lot of casts is a code wizard?
12:21:53 <Saizan> and that he has a lot of lands
12:22:01 <systemfault> sure! and they program in C
12:22:07 <systemfault> lulz
12:22:15 <alej> jmcarthur: i think so. and if you create a lot of threads youre a sorceror
12:22:31 <alej> which is of course a misspelling of sorcerer
12:23:25 <BMeph> alej: I thought is was "sourceror", or is that just coding FOSS? ;þ
12:23:34 <Olathe> And if you have a lot of memory leaks, you're a sorcerer's apprentice?
12:23:36 <BMeph> thought IT was... :\
12:23:48 <ben> sourcery is a fantasy book
12:24:20 <aaaaaaaaa_> Casting is:
12:24:22 <aaaaaaaaa_> Casting means you change the representation of a variable by changing its type to a different one
12:24:48 <jmcarthur> aaaaaaaaa_: we knew what casting was, just not "heavy casting"
12:24:55 <aaaaaaaaa_> :)
12:25:08 <jmcarthur> and wait... casting doesn't always mean changing the representation
12:25:23 <jmcarthur> maybe in some languages it does, but not in general
12:25:29 <chowder> I'm having some trouble using guards within a do block. I keep getting a parse error from ghci so I'm guessing that I did something stupid but despite my best attempts I am unable to see what I've done wrong.  I've pasted it here. http://hpaste.org/43418/a_shoddy_attempt_at_haskell
12:25:38 <BMeph> jmcarthur: Definitely not in C. :\
12:25:54 <jmcarthur> BMeph: except for implicit casts
12:26:01 <jmcarthur> or some other kinds of casts
12:26:05 <jmcarthur> numerical ones, i guess i mean
12:26:08 <dafis> chowder:  I get a 502 on that
12:26:33 <BMeph> "Bad Gateway". :(
12:26:33 <jmcarthur> aw, hpaste died
12:26:39 <chowder> dafis: darn. I'll repaste it elsewhere. 
12:26:40 <jmcarthur> you killed it, chowder!
12:26:45 <chowder> ;_;
12:26:51 <jmcarthur> there there
12:26:52 <BMeph> You Bastard! þ
12:27:07 <dafis> Kenny Hpaste? funny name
12:27:23 <SirFrancisDrake> without State monad, how would the game cycle look like? Doesn't recursively passing modified collections take increasing amounts of memory?
12:27:26 <BMeph> dafis: Funny kid.
12:27:37 <ddarius> SirFrancisDrake: No.
12:27:47 <shachaf> SirFrancisDrake: The State monad isn't magic. It does exactly what you'd do without it.
12:27:51 <ddarius> SirFrancisDrake: That's all the State monad does anyway.
12:28:50 <SirFrancisDrake> hmm. So how do I pass large data structures to some infinitely iterating function, while not keeping all the results in stack?
12:28:56 <jonkri> what should i import in order to get NoBuffering? http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#t:BufferMode
12:29:01 <roconnor> SirFrancisDrake: due to the large amount of sharing that generally happens when states update, each state update typically only requires log(n) memory, and typically the previous log(n) memory is immediately garbage collected.
12:29:58 <jmcarthur> SirFrancisDrake: there is no stack in the traditional C sense
12:30:00 <SirFrancisDrake> roconnor: hm, that makes sense, thanks. Could you suggest any further reading on the matter?
12:30:04 <dafis> jonkri:  System.IO
12:30:06 <chowder> dafis: http://pastebin.com/JMiZLRfk <--repasted my shoddy attempt at programming in Haskell
12:30:39 <roconnor> SirFrancisDrake: in GHC function calls don't push things onto the stack. Only case analysis pushes the stack.
12:31:11 <jonkri> dafis: what if i only wanted NoBuffering (and BufferMode)?
12:31:12 <jmcarthur> SirFrancisDrake: i'm tempted to say the STG paper may be the most appropriate, but you may not be quite ready for that (it's a low level explanation of how the GHC runtime worked at the time it was written, although things have changed a little)
12:31:20 <jmcarthur> @where stg
12:31:20 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
12:31:57 <BMeph> chowder: THat's an impressive program fragment. I think I almost don't have an idea of what you want! ;þ
12:31:58 <cole> when attempting: "cabal install wx --verbose=3" I get "/usr/bin/ld: cannot find -lstdc++" What's a possible solution?
12:31:59 <SirFrancisDrake> I'll certainly give it a try, thanks.
12:32:11 <dafis> jonkri:  import System.IO (BuferMode, NoBuffering) ?
12:32:28 <cole> Notably, I found libstdc++ in /usr/bin
12:32:42 <cole> "usr/lib rather"*
12:32:52 <chowder> BMeph: yea, I left out a lot of the other code.
12:33:20 <jmcarthur> chowder: guard syntax like that only works for pattern matching (either the lhs of = or in a case expression)
12:33:21 <dcoutts> cole: install a C++ compiler
12:33:27 <roconnor> SirFrancisDrake: understanding the memory use under lazy evaluation isn't always easy.  But eventually you get used to the idoms.  I typically imagine what a graph reduction machine would do even though that isn't exactly what GHC is doing.
12:33:43 <roconnor> SirFrancisDrake: Actually I'm so used to the idoms now that I find it hard to program in ocaml.
12:33:44 <dcoutts> cole: e.g. use your distro package manager to install GNU g++
12:33:57 <dafis> chowder:  `length number' is an Int, that can't appear as a statement in a do-block; I suspect you want something like:
12:34:20 <roconnor> SirFrancisDrake: from my point of view, limiting memory use in a strict langauge is difficult. :D
12:34:24 <cole> Oh, :)
12:34:44 <dafis> let answer | length number == 0 = "I need a number" | otherwise = "something horrible"
12:34:49 <dafis> putStrLn answer
12:34:51 <roconnor> Those fuction calls are always evaluating their arugments before continuing, even if I don't need them evaluated immediately. :/
12:35:18 <jonkri> dafis: i tried that, got an error saying NoBuffering were not exported by System.IO. wrong ghc version perhaps
12:35:21 <SirFrancisDrake> roconnor: hmm. 
12:35:34 <dafis> chowder:  but another thing: don't use `length list == 0', use `null list'
12:35:35 <chowder> dafis: would I need to use "let" within the "do"?
12:35:40 <jonkri> no, guess not since importing System.IO worked
12:35:44 <azaq23> http://paste.pocoo.org/show/328862/ This code hangs in my ghci session on ghci --version The Glorious Glasgow Haskell Compilation System, version 6.12.1
12:36:02 <dafis> jonkri:  which version?
12:36:13 <BMeph> jonkri:  try this -> import System.IO (BuferMode, BuferMode(NoBuffering))
12:36:40 <SirFrancisDrake> @where stg
12:36:41 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
12:36:59 <azaq23> oh I'm dumb ain't I
12:37:02 <azaq23> > let c = c in c
12:37:07 <lambdabot>   mueval-core: Time limit exceeded
12:37:07 <SirFrancisDrake> it isn't there.
12:37:10 <azaq23> yep.
12:37:47 * BMeph declines to comment
12:38:22 <dafis> azaq23:  of course, it's an infinite loop
12:38:39 <chowder> dafis: I see. Thanks . I've grown tired of Java at the uni so when I finish a programming assignment I like to translate it into Haskell
12:39:07 <dafis> chowder:  you need let in do-blocks if you want to define expressions you want to reference later
12:39:11 <azaq23> dafis: Yes, I had the weird idea that let in do blocks does actually work different, but I just remembered that it's converted to let ... in do ...
12:40:07 <SirFrancisDrake> most unfortunately, Peyton Jones' STG paper is missing. Does it explain the term idom?
12:40:20 <azaq23> and ghci is pretty much a big do block, I read.
12:41:11 <dafis> azaq23:  yes, with a few extra toppings
12:41:34 <SirFrancisDrake> azaq23, what exactly are you trying to do?
12:42:04 <azaq23> SirFrancisDrake: Just wanted to toy around a little with c.
12:42:18 <azaq23> c = sqrt(1/(electric constant * magnetic constant)) and such
12:43:06 <azaq23> And let c = brought defaulting into action
12:43:06 <SirFrancisDrake> why would you want to state that it is equal to itself?
12:43:37 <azaq23> As said, I thought let semantics in do blocks works a little different, though I really don't know why
12:43:54 <azaq23> so defaulting kicked in and log c failed since c was treated as an Int
12:43:57 <Twey> The semantics are exactly the same
12:44:04 <azaq23> I noticed already :)
12:44:05 <Twey> The syntax has some sugar
12:44:18 <dafis> azaq23:  either give type signatures or disable MR to fend off defaulting
12:44:19 <Twey> Okay
12:44:59 <jonkri> BMeph: that worked :)
12:45:04 <jonkri> cheers guys
12:51:05 <jonkri> HASKELL <3... it just works, i love it :)
12:51:42 <Zao> "what... this shouldn't typecheck!"
12:51:57 <dafis> Zao:  what?
12:53:41 <Zao> dafis: Something that I commonly think when coding Haskell.
12:54:08 <dafis> Zao:  most people think "this should typecheck, why doesn't it?"
12:54:20 <dafis> until they find their error
12:54:47 <dafis> or, seldomly, a typechecking bug in ghc
12:55:02 <aavogt> maybe there are some instances there you didn't know about
12:56:34 <azaq23> > - 2 "ds" "ff" "dfs" "344" (Just True)
12:56:36 <lambdabot>   -2
12:56:40 <azaq23> like that
12:57:42 <ddarius> > - 2 "ds" "ff" "dfs" "344" (Just True) :: (Int, Double, Complex Double)
12:57:43 <lambdabot>   (-2,-2.0,(-2.0) :+ (-0.0))
12:57:45 <azaq23> some weird instances in the hackage package vector-space allow one to do this
12:58:13 <azaq23> iirc
13:02:32 <aristid> > -2 :: (Int, Double, Complex Double)
13:02:33 <lambdabot>   (-2,-2.0,(-2.0) :+ (-0.0))
13:03:14 <aristid> > -2.0 :: (Int, Double, Complex Double)
13:03:15 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
13:03:15 <lambdabot>    arising from the lit...
13:04:04 <dafis> > negate abs 6
13:04:05 <lambdabot>   -6
13:04:45 <aristid> > negate abs (-6)
13:04:46 <lambdabot>   -6
13:04:49 <aristid> yay.
13:04:56 <aristid> :t negate abs
13:04:57 <lambdabot> forall a. (Num a) => a -> a
13:05:00 <aristid> :t negate . abs
13:05:01 <lambdabot> forall a. (Num a) => a -> a
13:05:34 <aristid> those instances really are evil :)
13:14:38 <cole> does wx not work in ghci?
13:15:44 <aristid> cole: i think there are bindings.
13:15:58 <cole> When I do ghc -package wx Main.hs, it compiles and runs correctly, but when I type ghci -package wx, I get an error indicating that wxcore cannot be installed because libstd can't be found or something.
13:16:37 <cole> It's okay, just slightly inconvenient.
13:21:33 <cole> gnu-make is pretty standard for c99 programs on linux. What's the standard make program from haskell? CMake, something else? Is there one?
13:21:47 <aristid> cole: ghc --make
13:22:00 <aristid> or cabal build
13:25:41 <azaq23> there is hmake
13:26:01 <azaq23> though I don't know much about its uses
13:26:54 <aristid> i usually use cabal build
13:27:34 <dafis> yup, cabal when it's more than a small thing, those with ghc --make
13:36:22 <Veinor> i don't know if i want to install ghc 6 or 7 on this machine
13:36:46 <dafis> why not?
13:36:49 <edwardk> apocalisp: there is a version of it in the ekmett/scalaz branch, you may need to roll it back a patch or two to get something consistent
13:37:20 <dafis> Veinor: both?
13:38:14 <mm_freak> is there an easy method to speed up compilation for development?
13:38:23 <mm_freak> turning off optimization didn't help
13:38:37 <edwardk> cole: cabal is used for almost everything these days, because ghc —make is hard to use when more than one package can supply something
13:39:01 <edwardk> mm_freak: lots of smaller packages?
13:39:01 <maurer_> mm_freak: -fasm
13:39:26 <dafis> maurer_: that's the default already
13:39:27 <mm_freak> edwardk: i don't think i can split this up reasonably
13:39:51 <kuffaar> "ghc —make " <- haha.
13:40:15 <dafis> kuffaar: what's so funny?
13:40:29 <SirFrancisDrake> did you just evaluate haha?
13:40:32 <mm_freak> dafis: probably the usage of a real m-dash instead of --
13:40:33 <kuffaar> dafis: Uhm his client converts sequences of ASCII to UTF-8, rendering it invalid for programming use
13:40:34 <SirFrancisDrake> *haha.
13:40:40 <maurer_> dafis: I thought -fvia-C was.Did we switch?
13:40:50 <mm_freak> kuffaar: it's not your client
13:40:56 <copumpkin> maurer_: it's never been the default
13:40:58 <copumpkin> on most platforms
13:41:03 <kuffaar> mm_freak: I said it's his client
13:41:03 <dafis> maurer_: I think the switch was with 6.8
13:41:12 <mm_freak> kuffaar: oh, i read "this"
13:41:19 <copumpkin> maurer_: on unregistered/uncommon platforms it's the only way to compile
13:41:55 <maurer_> copumpkin: I knew it was the only option on weird things, but I thought we had been at the "we have a native codegen, but it makes slower code than C, so we don't use it by default" state for some period of time.
13:42:18 <monochrom> that period of time stopped long ago for x86
13:42:25 <copumpkin> nah, the native codegen is better at some things, but via-C is better for tight loops and stuff
13:42:29 <maurer_> OK, sorry I didn't keep up.
13:42:37 <copumpkin> but it's been -fasm by default for as long as I've been around
13:42:38 <monochrom> err, I mean x86 linux and x86 windows.
13:42:40 <copumpkin> which isn't that long, I guess
13:42:40 * maurer_ is curious how the LLVM backend is doing.
13:42:53 <mm_freak> copumpkin: when i started with haskell, -fvia-C was the default
13:42:55 <ddarius> copumpkin: Yeah, -fvia-C has been the default for the vast majority of GHC's life.
13:42:56 <dafis> copumpkin: although the native codegen got better with 7
13:43:04 <mm_freak> GHC 6.4 oder 6.6. or something, i don't remember
13:43:17 <dafis> s/although/but/
13:43:20 <copumpkin> ddarius: fair enough
13:43:28 <monochrom> people need to update their own states.
13:43:39 <ddarius> The NCG didn't even exist (for x86/x86-64) until a few(?) years ago.
13:43:48 * copumpkin creates a new, updated copy of himself, and garbage collects the earlier version
13:44:05 <mm_freak> copumpkin: or use a uniqueness type
13:44:13 <dafis> ddarius: few >= 6
13:44:14 <monochrom> at this rate you can bet 10 years later there are still people in #haskell who go "I thought ghc could not talk to llvm"
13:44:31 <ddarius> dafis: I'm wondering if it's more like 1 or 2.
13:44:41 <ddarius> I don't recall exactly when it was made.
13:44:47 <ddarius> Quite a while after I got here.
13:44:55 <mm_freak> monochrom: that's a good sign, because GHC does the good stuff transparently
13:45:10 <dafis> ddarius: I could use -fasm with 6.2
13:45:44 * hackagebot system-uuid 1.4.0 - Bindings to system UUID functions.  http://hackage.haskell.org/package/system-uuid-1.4.0 (JasonDusek)
13:45:58 <maurer_> I remember -fasm used to be an option people used during dev b/c the NCG was faster than invoking gcc, which is how this all came up
13:46:01 <monochrom> no, I think outdated people dying of old age is an even better sign.
13:46:31 <dafis> monochrom: I'm inclined to take that remark personally
13:46:33 <ddarius> monochrom: You can be young and out-dated.
13:48:09 * ddarius hasn't made bread in a while.
13:48:12 * ddarius should make some dough.
13:49:14 * kuffaar is curious when GHC bootstrapping will work again so you can actually port it to new platforms (i.e. AMD64 on Windows)
13:49:33 <kuffaar> It's quite baffling that there is no mainstream way of achieving parallel compilation yet.
13:50:02 <monochrom> yes ddarius, people tend to write-protect their minds at 20, and I would rather them disappear at 30 than hanging around spewing superseded information for 70 years until they're 90. however, 70 years is still better than infinity.
13:50:49 <copumpkin> kuffaar: is it really?
13:51:09 <kuffaar> copumpkin yes, this is usually the first thing I implement when I write a build system
13:51:25 <kuffaar> It's supported by pretty much everything else I deal with
13:51:36 <copumpkin> oh well
13:52:56 <kuffaar> Nowadays it's like intentionally limiting your compilation speed to 12.5% :(
13:52:59 <SirFrancisDrake> what is the motivation behind uncurry function? If there is to it, apart from arrow stuff
13:53:27 <SirFrancisDrake> > uncurry (+) (1, 2)
13:53:28 <lambdabot>   3
13:53:36 <ddarius> SirFrancisDrake: It's not motivated by arrows at all.
13:53:42 <ddarius> It's also fundamental.
13:54:02 <dafis> SirFrancisDrake: uncurry function . functionReturningPair
13:54:04 <SirFrancisDrake> ddarius: when is it used?
13:54:04 <maurer_> kuffar: While it's unfortunate that cabal and --make don't support it, you can always use a Makefile with ghc -c to achieve parallel compilation
13:54:23 <maurer_> kuffaar: I have used this on some of my longer-to-compile projects during dev cycle
13:54:36 <ddarius> SirFrancisDrake: Whenever someone wants to do what the type of uncurry says it does, which is fairly rarely.
13:54:44 <copumpkin> kuffaar: the point is that it isn't intentional. These projects were started several years ago and have design issues (global variables and such) that prevent nice concurrency. It's certainly possible, but it'll take more than someone saying "it's the first thing I do" to make it happen. Read up on cabal and GHC, write patches, and make it happen ;)
13:55:30 <copumpkin> there are tons of other concerns that have higher priority to the devs working on the projects right now
13:55:43 <kuffaar> dcoutts told me they don't really care about that at the moment
13:55:46 <copumpkin> and there are very few people who actively contribute to cabal(-install) or GHC
13:55:46 <kuffaar> Yeah
13:56:08 <SirFrancisDrake> ddarius: yeah right. Thanks.
13:56:08 <copumpkin> but the beauty of open source is that improvements come from those who do care :)
13:56:15 <copumpkin> you clearly care!
13:56:18 <SirFrancisDrake> dafis: hm. thanks
13:56:27 <copumpkin> I would certainly appreciate it, although I don't care enough to make it happen myself
13:57:31 <monochrom> My friend told me about a 50-year-old colleague who would use absolutely no abstraction, not even procedural abstraction. He duplicated code like 50 times so as to vary literals, as opposed to call the same procedure 50 times with varying parameters. This led me to finally see the beauty of death. If everyone lived forever, such write-protected programmers would rule the programming world.
13:57:36 <kuffaar> I'd probably rather rewrite it from scratch with a very limited set of features :|
13:57:57 <kuffaar> monochrom hahaha
13:58:05 <maurer_> monochrom: Sounds like your friend's colleague was an idiot, who happened to be 50 years old.
13:58:22 <ddarius> maurer_: "Procedural abstraction is expensive."
13:58:46 <dafis> ddarius: ??? where does that come from
13:59:24 <ddarius> @google debunking the "expensive procedure call" myth
13:59:25 <lambdabot> http://dspace.mit.edu/handle/1721.1/5753
13:59:25 <lambdabot> Title: DSpace@MIT : Debunking the 'Expensive Procedure Call' Myth, or, Procedure Call I ...
14:01:37 <maurer_> ddarius: My point is that I've seen behavior like this from 18 year olds. Age is not the root cause of people doing things wrong.
14:02:15 <dafis> maurer_: True, but it's more frequent in oldtimers like me
14:02:26 <copumpkin> when I make a procedure call in my language implementation, I stash a copy of the entire accessible program memory (heap and stack) to disk just in case something goes wrong
14:02:30 <maurer_> Heh. I'm 22 and I already worry about getting old :P
14:02:38 <dafis> to stick with the ways learnt in younger days
14:03:03 <dafis> maurer_: when I was 22 I worried about girls :)
14:03:13 <dafis> and music
14:03:19 <maurer_> dafis: I have a girlfriend, that situation is stable for me.
14:04:11 <dafis> maurer_: when I was 22, having a girlfriend didn't stop anyone from worrying about girls
14:04:13 <ddarius> maurer_: And my point and monochrom's point is the -motivation- behind each.  An 18 year old doing because they are inexperienced is different from a 50 year old doing because it was a "good idea" thirty years earlier.
14:04:34 <maurer_> Ah.
14:04:35 <ddarius> copumpkin: You should provide first-class state and continuations then.
14:04:41 <SirFrancisDrake> maurer_, do you worry about getting bald?
14:05:02 <maurer_> SirFrancisDrake: Not particularly. I really only worry about the effects on my mind :P
14:05:08 <ddarius> dafis: Hah.
14:05:23 <dafis> ddarius: Hah what?
14:06:05 <ddarius> dafis: To your last comment.
14:06:13 <SirFrancisDrake> maurer_, I've been led to think that a learning mind doesn't deteriorate. Do you think it does?
14:06:21 <dafis> well, Aids wasn't invented yet
14:06:24 <kuffaar> SirFrancisDrake of course it does
14:06:42 <ddarius> dafis: In this new and strange Web 2.0 world, I guess people worry more about what random internet strangers think about their tweets rather than about girls.
14:07:18 <SirFrancisDrake> kuffaar: like, with same speed?
14:07:34 <maurer_> SirFrancisDrake: At the very least, as you learn things, if you aren't careful your worldview can get stuck in a local minimum.
14:08:00 <kuffaar> SirFrancisDrake: Hint: In the end you die
14:08:02 <SirFrancisDrake> maurer_: what do you mean?
14:08:05 <dafis> ddarius: Well, the times always deteriorate. I didn't belive my father when I was young, now I know he was right.
14:08:47 <SirFrancisDrake> kuffaar: yeah, in case any of you missed that one in med school. Some people remain quite bright until the very end. Some don't.
14:09:00 <kuffaar> dafis: What? The human quality of life has been empirically improving for a long time
14:09:10 <benmachine> sup dudes
14:09:20 <dafis> kuffaar: Lies, all lies!
14:09:25 <maurer_> SirFrancisDrake: It is possible to hold a view on something, which while if modified in any small way will not improve, is non-optimal.
14:09:35 <byorgey> @ask edwardk what is the most canonical package from which to get the Pointed class these days?  Is it still category-extras, or is it in a smaller package somewhere?
14:09:36 <lambdabot> Consider it noted.
14:09:56 <parcs> why would ghc complain about the lack of an instance for (MonadIO (InputT IO)) even though the package http://hackage.haskell.org/packages/archive/haskeline/0.6.3.2/doc/html/System-Console-Haskeline.html#g:1 defines one?
14:10:00 <maurer_> SirFrancisDrake: As over time more evidence is gathered, the propensity to deviate from what is currently known decreases, and prevents you from leaving these states.
14:10:12 <maurer_> SirFrancisDrake: Think about it as the low temperature phase of a simulated annealing.
14:10:34 <dafis> parcs: maybe an mtl vs. transformers inconsistency
14:10:56 <SirFrancisDrake> maurer_: I see your point. And I'm kinda glad Peyton Jones learnt all that cool functional stuff in his youth :)
14:11:49 <dafis> parcs: are you using mtl? If so, mtl-1 or mtl-2?
14:12:17 <copumpkin> byorgey: edwardk has decided that Pointed is the world's least useful class ever, but the other half of applicative is wonderful
14:12:30 <copumpkin> well, at least I have, and I'm pretty sure he thinks the same thing
14:12:45 <copumpkin> :P
14:14:08 <copumpkin> Cale: is @free broken?
14:14:17 * copumpkin lies down
14:14:34 <fryguybob> @pl \x y -> [x,y]
14:14:35 <dibblego> I thought it was second, after Arrow
14:14:35 <lambdabot> (. return) . (:)
14:15:04 <benmachine> :t liftA2 (++) pure pure
14:15:05 <lambdabot> forall a (f :: * -> *). (Monoid (f a), Applicative f) => a -> f a
14:15:06 <copumpkin> dibblego: at least Arrow has some slightly nontrivial axioms (in fact, too many)
14:15:06 <ddarius> copumpkin: Tell edwardk to make a torsor package.
14:15:09 <benmachine> hmmmmm
14:15:23 <copumpkin> @tell edwardk to make a torsor package
14:15:23 <lambdabot> Consider it noted.
14:15:38 <byorgey> copumpkin: it IS useful pedagogically, though.  I am revising the Typeclassopedia.
14:15:57 <benmachine> byorgey: is it really? how so?
14:16:02 <SirFrancisDrake> how do I complain to bot that his link to STG is broken?
14:16:04 <dibblego> you could also say that edwardk is revising it too
14:16:10 <parcs> dafis: i'm not sure; i'm not using cabal to handle dependencies
14:16:22 <byorgey> it's useful to separate out the different bits of functionality that show up in Applicative and Monad
14:16:24 <dafis> parcs: ghc-pkg list mtl
14:16:45 <Twey> copumpkin: Pointed is at least useful to unify all the point methods from the dozens of other classes that use them :þ
14:16:45 <parcs> dafis: there exist 1.1.0.2 and 2.0.1.0
14:16:46 <copumpkin> byorgey: I kind of like splitting it up the other way
14:16:57 <copumpkin> Twey: well...
14:17:05 <byorgey> copumpkin: what other way?
14:17:08 <benmachine> Twey: which classes use them?
14:17:19 <ddarius> byorgey: Having Applicative add pure rather that (<*>).
14:17:21 <dafis> parcs: specify -package mtl-2.0.1.0 on the command line and see what it says
14:17:43 <copumpkin> byorgey: what edwardk has been doing recently with functor-apply. Take the Monad progression as Functor (fmap) => Apply (<*>, which he called <.>) => Applicative (pure) => Monad (join)
14:18:00 <Twey> benmachine: Applicative, Monad, uh, uh, uh…
14:18:01 <benmachine> copumpkin: intriguing
14:18:07 <benmachine> Twey: :P
14:18:08 <byorgey> oh, interesting
14:18:08 <copumpkin> which has the advantage is that there are actual instances of Apply that aren't Applicatives
14:18:09 <Feuerbach> dibblego: he's "invalidating" it (in his own words)
14:18:14 <copumpkin> and useful ones, at that
14:18:16 <benmachine> copumpkin: e.g.?
14:18:29 <copumpkin> Ord k => Apply (Map k) is my pet one
14:18:33 <benmachine> ah
14:18:33 <parcs> dafis: the error persists
14:18:40 <benmachine> hmm
14:18:47 <dafis> parcs: paste?
14:18:47 <copumpkin> @hackage functor-apply
14:18:47 <lambdabot> http://hackage.haskell.org/package/functor-apply
14:18:49 <benmachine> maps have a sort of theoretical pure, do they not
14:19:04 <copumpkin> benmachine: yeah, but unless you use TMaps, you don't actually get it
14:19:07 <parcs> okay, one moment
14:19:10 <benmachine> TMaps?
14:19:13 <byorgey> copumpkin: I see, neat
14:19:14 <copumpkin> total maps
14:19:16 <copumpkin> with a default value
14:19:16 <benmachine> oh
14:19:24 <aristid> copumpkin: but what about a diamond hierarchy with a class with just fmap and pure, but no Apply?
14:19:33 <benmachine> I was just thinking of something like, Either a (Map k a) with Left x => all keys go to x
14:19:34 <dafis> parcs: or perhaps you have an older haskeline which used mtl-1?
14:19:36 <copumpkin> we've been exploring what it means to take certain operations in isolation
14:19:51 <benmachine> (or is that a TMap)
14:19:59 <benmachine> all keys go to Just x I guess
14:20:19 <byorgey> benmachine: that's not quite the same thing
14:20:42 <byorgey> as soon as you want some non-default values you have to give up the totality
14:20:48 <copumpkin> byorgey: furthermore, it corresponds nicely to semigroups, along with Foldable1 and Traversable1
14:20:55 <benmachine> byorgey: it's more or less TMap k (Maybe a) though, isn't it?
14:20:57 <byorgey> More like (a, Map k a)
14:21:14 <parcs> dafis: http://paste.pocoo.org/show/328913/
14:21:23 <parcs> i am using the latest version of haskeline
14:21:53 * benmachine finds himself defining isCase, isLet, isLambda for HSE expressions
14:21:56 * benmachine sighs
14:21:59 <parcs> ah, should've pasted the error. it's "No instance for (MonadIO (InputT IO)) arising from the use of liftIO"
14:21:59 <copumpkin> benmachine: http://snapplr.com/fv9y
14:22:10 <ddarius> benmachine: Why?
14:22:14 <benmachine> copumpkin: oh, neat
14:22:55 <benmachine> ddarius: I'm doing a thing to automatically parenthise expressions, and e.g. if a case, let, or lambda is on the LHS of an infix application, it's always parenthised
14:23:07 <benmachine> er, *on the left
14:23:19 <benmachine> ddarius: it's kind of clumsy to explicitly match all the time
14:23:43 <dafis> parcs: try import Control.Monad.IO.Class
14:24:03 * benmachine wonders what to name case/lambda/let that all share the "as far right as possible" property
14:24:07 <ddarius> benmachine: Don't you just want a function precedence :: Expr -> Int or some such?
14:24:24 * ddarius dislikes booleans.
14:24:40 <parcs> dafis: i've just reinstalled haskeline and all seems to work well
14:24:41 <benmachine> ddarius: perhaps. it would be a bit more complicated than that since having a lambda on the right of an operator is okay
14:24:52 <parcs> dafis: thanks for your help :)
14:24:59 <benmachine> but you might be right
14:25:01 <dafis> parcs: not for that
14:25:03 <ddarius> benmachine: Same for a case and a let, no?
14:25:14 <benmachine> ddarius: yeah, omitted for brevity :P
14:25:22 * benmachine can't be bothered typing all those words
14:25:33 <benmachine> point is, there's asymmetry
14:25:46 <benmachine> but maybe you're right and I can just assign a fixity to any expression
14:25:48 <ddarius> So the left hand side requires different precedence than the right.
14:26:04 <benmachine> I suppose so
14:26:32 <ddarius> That's what you do to handle 1+2+3.  
14:27:01 <Philippa> benmachine: how about "needs bracketing" or some variant, with an implicit "when a subexpression"?
14:27:09 * benmachine tries to work out if his algorithm is even correct, let alone elegant
14:27:20 <Philippa> or "left-bracketing" or...
14:27:43 <benmachine> Philippa: that's more or less equivalent to just giving that thing minimum (or maximum possibly) precedence, no?
14:27:46 <mietek> Is Data.Graph odd, or is it just me?
14:28:04 <ddarius> > odd (length "Data.Graph")
14:28:05 <lambdabot>   False
14:28:08 <ddarius> Just you.
14:28:17 <Philippa> benmachine: which is the property those things have in the grammar, yes
14:28:27 <benmachine> hmm
14:28:35 <benmachine> okay
14:29:01 <Philippa> oh, possibly "containsExpression"
14:29:06 <Philippa> or "endsInExpression"
14:29:09 <benmachine> heh
14:29:24 <Philippa> the point being they contain a separate /sub/expression which needs disambiguating from the outer one
14:29:29 <joe6> Saizan: this tutorial is really good: http://www.haskell.org/haskellwiki/Monads_as_computation, Thanks a lot for passing it along.
14:29:42 <Philippa> they're like brackets that don't actually bracket
14:31:10 <ddarius> copumpkin: Any particular time you want to head out, and any particular place, or the one I suggested before, or wherever?
14:31:11 <luite> lie brackets? ;p
14:31:47 * ddarius usually uses the commutator product written with  rather than Lie brackets.
14:32:15 <copumpkin> ddarius: I have a splitting headache right now which I've taken a pill for and am hoping will go away. If not, I may just stay in. What time do you normally eat, anyway?
14:32:55 <ddarius> copumpkin: I don't have any consistent time.
14:53:42 <mm_freak> what if i need only Comonad functionality…  is there any simpler interface than category-extras?
14:54:25 <ddarius> Yes.
14:55:24 * ddarius doesn't know where mm_freak has been the past few weeks while still being logged into IRC.
14:56:11 <alpounet> @hackage comonad
14:56:11 <lambdabot> http://hackage.haskell.org/package/comonad
14:56:32 <alpounet> there's also comonad-transformers
14:56:33 <alpounet> etc
15:00:17 <ddarius> That's weird.  My seventh fret natural harmonics are strangely weak.  Fifth fret ones are ringing out well though.
15:04:07 <byorgey> ddarius: probably a bug in GHC.
15:13:45 <edwardk> byorgey: heya
15:13:45 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:14:02 <edwardk> byorgey: i've actually been actively working to eliminate pointed from my universe.
15:14:39 <edwardk> byorgey: i've found that it doesn't really add anything because _any_ choice of a -> f a, will satisfy the only law you could state about Pointed, which is a free theorem
15:15:32 <edwardk> byorgey: but if you put class Functor f => Apply f where (<.>) :: f (a -> b) -> f a -> f b — then you can talk about static arrow composition being associative, and the class adds value, because you can use it to traverse any container that provides a base case for you
15:16:29 <edwardk> @tell byorgey look at the functor-apply package for the skeleton of what would probably be the typeclassopedia of the future
15:16:29 <lambdabot> Consider it noted.
15:17:15 * hackagebot highlighting-kate 0.2.9 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.2.9 (JohnMacFarlane)
15:18:54 <joe6> i know that I cannot do reify in the IO monad and I can do something like this to print it out: putStrLn ($((=<<) (stringE . groom) (reify ''Test)) )
15:19:08 <joe6> What i am wondering is on why I cannot do reify in the IO monad?
15:19:39 <benmachine> joe6: my guess is that reify neds to be run during typechecking/compilation, while IO actions are run at runtime
15:19:52 <joe6> is this just a current limitation or is there something groundbreaking theoretically or practically that is preventing it?
15:20:03 <ddarius> benmachine: The way they set that aspect up is really horrible.
15:20:06 <edwardk> @free dot :: (n -> c) -> (a -> b) -> a -> c
15:20:06 <lambdabot> g . p = q . f => k . f1 = f2 . h => g . dot p f1 = dot q f2 . h
15:20:13 <burp> @hoogle wsdl
15:20:14 <lambdabot> No results found
15:20:14 <benmachine> ddarius: that aspect = TH? :P
15:20:20 <ddarius> benmachine: No.
15:20:39 <edwardk> er
15:20:50 <edwardk> @free dot :: (b -> c) -> (a -> b) -> a -> c
15:20:51 <lambdabot> g . k = p . f => f . q = f1 . h => g . dot k q = dot p f1 . h
15:20:56 * ddarius needs to add fingerings for some passages of Classical Gas.
15:20:56 <byorgey> edwardk: awesome, thanks
15:20:57 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
15:21:07 <byorgey> edwardk: indeed, the reason I ask is that I am revising the typeclassopedia
15:21:10 <joe6> benmachine: What about the [| |] construct? it goes through the parser and all the stages, doesn't it?
15:21:29 <edwardk> byorgey: i was actually going to ping you about doing just that, since i was thinking about writing an article on the topic of why pointed should die ;)
15:22:04 <byorgey> edwardk: would you be interested in helping revise it?
15:22:05 <edwardk> byorgey: we're flipping the class hierarchy in scalaz over to this model as well. since it gives some really nice properties for talking about containers.
15:22:08 <edwardk> sure
15:22:19 <byorgey> edwardk: a separate screed against pointed would probably be useful too
15:22:33 <benmachine> joe6: hmm. I can't obviously see why there's that difference, but there are a lot of non-obvious things that go on in TH :P
15:22:36 <joe6> benmachine: is that the same reason that we cannot use data or type on ghci prompt?
15:22:51 <edwardk> well, dave menendez gave a short one on the mailing list when the Functor => Pointed => Applicative => Monad topic came up
15:22:51 <azaq23> to learn more @free and free theorems that paper "Theorems for free!" is recommended?
15:23:06 <benmachine> joe6: I suspect the two are unrelated; not being able to use data or type at the ghci prompt is probably just a user interface thing, I think
15:23:08 <byorgey> edwardk: cool.  once code.haskell.org is back up I'll point you at the repository
15:23:19 <dibblego> I submit my approval of edwardk's haste toward Pointed
15:23:22 <byorgey> oh, did he? I must have missed that
15:23:32 <edwardk> I also have Alt/Pure providing functor semigroups and monoids
15:23:41 <benmachine> joe6: but I'm going to stop commenting because I'm already being quite vague on this
15:23:41 <byorgey> yes, I saw that, loks neat
15:23:46 <byorgey> *looks
15:24:08 <edwardk> those are there because the majority of MonadPlus's laws are more guidelines
15:24:15 <benmachine> :P
15:24:33 <edwardk> so really it comes down to the fact that as long as Alt allows fmap to distribute, nothing else applies ;)
15:24:45 <joe6> benmachine: i am noticing that there are a  few instances, where the answer has been that "it is because of TH".. Could it be that as time passes, TH will be brought more in-line with the general haskell principles.
15:25:05 <edwardk> (since there is no empty to have the empty <!> a = a law
15:25:39 <benmachine> joe6: I would hope so! I think TH is still regarded as quite experimental
15:26:32 <benmachine> joe6: e.g. there are potentially major future design decisions being discussed here: http://hackage.haskell.org/trac/ghc/blog/Template%20Haskell%20Proposal
15:26:47 <edwardk> byorgey: what i've been looking to put together once i have it more fleshed out is a bit of a field guide of all of these crazy packages i've been building lately
15:27:08 <edwardk> establishing what forms the haskell 98 core, etc.
15:27:36 <byorgey> that sounds great.
15:28:02 <edwardk> i've _almost_ finished gutting and reframing category-extras as separate packages
15:28:07 <byorgey> a sequel to the typeclassopedia, as it were?
15:28:15 <byorgey> excellet
15:28:31 <joe6> benmachine: thanks for that link. will check it out.
15:28:32 <edwardk> i have maybe a 12-20 modules left over to split into foo-extras packages
15:28:44 <edwardk> out of 110 or so, thats quite a bit down =)
15:28:51 <byorgey> indeed =)
15:29:22 <edwardk> is there any way to easily acquire author statistics off of hackage? i'm morbidly curious
15:29:33 <benmachine> joe6: I don't think the exact content is that relevant to your question, but it illustrates that the TH design could still undergo significant change
15:29:52 * ddarius would just be happy with being able to click on a package author/uploader and see all package authored/uploaded by them.
15:29:57 <edwardk> yeah
15:30:03 <byorgey> edwardk: currently, not that I know of
15:30:15 <benmachine> when do we get hackage 2 :(
15:30:42 <ddarius> edwardk: What are the 12-20 remaining?
15:31:04 <joe6> benmachine: makes sense.
15:32:32 <edwardk> hrmm, the 00-index.tar.gz doesn't contain the uploaded-by information
15:32:47 <edwardk> ddarius: higher order functors, indexed (co)monads, lemme check the rest
15:33:00 <mm_freak> alpounet: thanks
15:34:13 <ddarius> edwardk: By higher order functors do you mean the ExpFunctor class or a functors between higher kinds?
15:34:32 <edwardk> pointed, pointed functor composition, the 'categorical' functors, monads, etc. elgot algebras, the pointer comonad, (co)ideal (co)monads, i don't have a free monad package yet. bikleisli arrows and the monad/comona distributive laws, plus the more principled distributive law based monads
15:34:39 <edwardk> functors between higher kinds
15:34:50 <edwardk> ExpFunctor is also unported, but kinda boring
15:35:59 <edwardk> then some fiddly bits like cones, and spans, and lambek's lemma (which should probably go into the recursion-schemes package now that i think about it)
15:36:23 <ddarius> Does anyone ever really want to use Lambek's lemma directly?
15:36:23 <edwardk> technically i use it in the definition of Mu and Nu
15:37:03 <ddarius> It's wonderful as a theorem; as a program, not so much.
15:37:12 <edwardk> recursion-schemes defines 3 fixed points, the standard one, and then the (forall a. (f a -> a) -> a) - and the existential Nu :: (a -> f a) -> a -> Nu f
15:37:37 <edwardk> i use it to define 'out'  Mu
15:37:44 <edwardk> er 'out' for Mu
15:37:46 <dolio> ddarius: People who want to use Church encoding for everything apparently do.
15:37:56 <ddarius> dolio: Indeed.
15:38:11 <ddarius> But the saner majority use Scott encoding.
15:38:22 <edwardk> http://hackage.haskell.org/packages/archive/recursion-schemes/0.1.1/doc/html/src/Data-Functor-Foldable.html#Mu see instance Foldable (Mu f)
15:39:08 <edwardk> and its dual is used to provide the Unfoldable instance for (Nu f)
15:41:14 <dolio> There are even efforts to design a type theory without inductive types, but with the facilities to write strong inductive eliminators for the System F encodings.
15:41:31 <dolio> Which would be a cool theoretical result, but terrible for actual use.
15:47:04 <ddarius> What we need to do is trick logicians into finding logics/proof theories like the ones Atsushi Ohori covers interesting so they start proving theorems in them and meta-theorems about them.
15:51:55 <edwardk> gah, can't derive Data/Typeable for data families =(
15:56:47 <mm_freak> > let myTails = (=>> id) in myTails "abcde"
15:56:49 <lambdabot>   Not in scope: `=>>'
15:56:55 <mm_freak> :t extend
15:56:56 <lambdabot> Not in scope: `extend'
15:57:24 <edwardk> extend does exactly that using the comonad package
15:57:32 <edwardk> (acts as tails on [])
15:57:47 <edwardk> er duplicate acts as tails
15:57:50 <mm_freak> you mean duplicate
15:58:01 <edwardk> extend f = fmap f . duplicate — so its fmap f . tails
15:58:09 <edwardk> yeah
15:59:35 <mm_freak> yeah, figured…  i'm trying to find out, where that's useful
15:59:53 <mm_freak> ah, applying a function to tails
15:59:56 <edwardk> it gives you access to the entire tail of the list when computing the answer you want to give for a given position in the list
15:59:57 <edwardk> yeah
16:00:33 <joe6> fundamental question: 'template haskell' makes sense in a dynamic language. But, for a statically compiled program, why not just write a program that can add the code that you want into the current program file?
16:00:40 <mm_freak> if we set extract = head, that's not a proper comonad, right?
16:00:53 <Heffalump> joe6: that's what template haskell does
16:00:55 <copumpkin> mm_freak: it can fail
16:00:59 <mm_freak> joe6: because that's inconvenient
16:01:01 <edwardk> correct
16:01:02 <Heffalump> joe6: just built into the compiler
16:01:04 <Twey> joe6: But in a relatively nice and type-safe way
16:01:10 <mm_freak> i see
16:01:13 <edwardk> hence why i have an Extend superclass of comonad that provides duplicate and extract
16:01:26 <edwardk> there is an instance of Extend for [] but not an instance of Comonad
16:01:27 * hackagebot bbdb 0.2 - Ability to read, write, and examine BBDB files  http://hackage.haskell.org/package/bbdb-0.2 (HenryLaxen)
16:01:38 <edwardk> if you want the comonad use the streams package and grab Data.Stream.NonEmpty
16:01:42 <edwardk> which provides
16:01:50 <edwardk> data NonEmpty a = a :| [a] — which _is_ a comonad
16:02:07 <mm_freak> edwardk: yeah, i'm trying to generalize a type class i've recently added to contstuff…  your comonad library might become a dependency of contstuff
16:02:17 <edwardk> go for it
16:02:29 <edwardk> eyeball functor-apply too, lots of goodies there
16:02:53 <edwardk> that's designed to be basically the generic pool of missing semigroup-like classes that are haskell 98
16:02:55 <ddarius> joe6: Why does Lisp have macros?
16:03:31 <mm_freak> what i'm trying is to generalize this:  class LiftFunctor t where type InnerFunctor t :: * -> *; liftF :: Monad m => m (InnerFunctor t a) -> t m a
16:03:34 <joe6> ddarius: isn't that because lisp is an interpreter?
16:03:36 <edwardk> because you can't sneeze in lisp without needing to use a macro ;)
16:03:37 <ddarius> edwardk: So where's my generic torsor class?
16:03:45 <edwardk> ddarius: whats the api?
16:03:49 <mm_freak> i might get along without the type family
16:04:14 <edwardk> ddarius: i was playing around with expressing one of my function stream classes in terms of a torsor actually because the position information is closed over
16:04:31 <ddarius> edwardk: A torsor is a G-set with a "difference/division" operator that produces Gs.
16:04:41 <edwardk> sure
16:04:46 <joe6> Heffalump: But, there are so many limitations to TH that it seems harder to be building it into the compiler?
16:04:52 <kevinburke> why doesn't 
16:04:53 <ddarius> class Group g => Torsor s where divide :: s -> s -> g
16:04:54 <kevinburke> let r = 5
16:04:56 <kevinburke> sqrt r
16:04:57 <kevinburke> work/
16:05:05 <kevinburke> :s/\//?/
16:05:16 <joe6> mm_freak why do you say that? it could be called just like any other run-time library?
16:05:23 <ddarius> Well, I guess it would have a GSet superclass (which would require g to be a Group.)
16:05:26 <mm_freak> liftF :: (Extend w, Monad m) => m (f a) -> t m a
16:05:27 <edwardk> class Group g => Torsor g s | s -> g where … ?
16:05:51 <joe6> Twey: but the "relatively nice and type-safe way" will be ensured when the second program is parsed? isn't it?
16:05:59 <copumpkin> edwardk: did you get the topos code?
16:06:04 <mm_freak> joe6: the TH approach lets you write programs using something like an AST very nicely
16:06:06 <edwardk> copumpkin: haven't looked
16:06:14 <ddarius> class GSet g s where act :: g -> s -> s
16:06:20 <edwardk> mm_freak: typo?
16:06:22 <ddarius> + Group g =>
16:06:37 <mm_freak> joe6: and you don't have any compile time deps…  just use -XTemplateHaskell
16:06:47 <ddarius> GSet should, actually, probably not be a class.
16:06:58 <joe6> mm_freak: but there are quite a few limitations to TH, as it currently stands.
16:07:00 <mm_freak> edwardk: yes, f ~ w, sorry
16:07:03 <edwardk> ddarius: but that makes it ugly to require
16:07:15 <edwardk> where did t come from?
16:07:29 <Eduard_Munteanu> How about M4 instead of TH or CPP?
16:07:32 * Eduard_Munteanu *ducks*
16:07:37 <kevinburke> solved it
16:08:07 <copumpkin> Eduard_Munteanu: I just use sed scripts
16:08:14 <edwardk> ddarius: i think like vector space, etc. it'll just have to suck it up and be a class if you want it ;)
16:08:27 <joe6> Eduard_Munteanu: haha!! in a statically compiled system, why not?
16:08:31 <edwardk> ddarius: but since its an MPTC its outside of the scope of my current explorations ;)
16:09:17 <edwardk> ddarius: i've wanted torsors for some affine space/geometry code though, so i'll probably revisit them
16:09:42 <ddarius> edwardk: I always use the Point/Vector torsor (split) in graphics/physics code.
16:09:44 <mm_freak> but it doesn't really fit the pattern =/
16:09:55 <edwardk> yeah
16:10:02 <ddarius> Everything is so much prettier and more sensible that way.
16:11:15 <edwardk> it usually breaks down for me because i wind up encoding so much stuff in plucker coordinates, so i work with homogeneous coordinates everywhere, but for those few places i can work affine, its nice.
16:18:44 <edwardk> eduard_munteanu: i used to run a whole website with forums and everything off of a dialect of m4 ;)
16:19:03 <edwardk> i've since recovered my sanity
16:19:26 <Eduard_Munteanu> Heh, ouch.
16:19:30 * hackagebot recursion-schemes 0.2 - Generalized bananas, lenses and barbed wire  http://hackage.haskell.org/package/recursion-schemes-0.2 (EdwardKmett)
16:19:32 <edwardk> well, some of it.
16:19:41 <edwardk> (my sanity that is)
16:20:14 <aristid> edwardk: i think you just replaced it with a different kind of insanity :)
16:20:42 <edwardk> its at least productive if not well-founded
16:21:54 <edwardk> hrmm, i need to add elgot (co)algebras to recursion-schemes, those don't require anything else out of category-extras
16:22:16 <mm_freak> is there some CT model for a function of type 'm (f a) -> t m a', where m is a monad and t is a monad transformer?
16:22:42 <edwardk> mm_freak: like m (Maybe a) -> MaybeT m a ?
16:22:51 <mm_freak> edwardk: yeah, exactly
16:23:07 <edwardk> yes, i haven't got it encoded though because it requires an MPTC in general
16:23:22 <mm_freak> edwardk: i found that a TF is enough
16:23:32 <edwardk> look at Control.Comonad.Hoist.Class for something similar
16:23:34 <edwardk> yes
16:23:38 <mm_freak> but in general you need an MPTC, yes
16:23:54 <edwardk> even type family keeps it out of my core class list and in some -extras package
16:24:13 <mm_freak> Hoist?
16:24:36 <edwardk> cohoisting lets me lower a comonad transformer to the base form.    t w a -> t Identity a
16:24:52 <edwardk> hoisting lets me take a monad into its monad transformer t Identity a -> t m a
16:24:56 <mm_freak> ah, found it
16:25:22 <edwardk> but that works with any monad homomorphism between m and n, given a monad homomorphism from m -> n you can make one from t m -> t n
16:26:06 <aristid> :t runMaybeT
16:26:08 <lambdabot> Not in scope: `runMaybeT'
16:26:08 <edwardk> but as for the typeclass you want its only the monad transformers that trivially wrap something, like Maybe and ErrorT and the broken-ass ListT that it applies to
16:26:12 <aristid> NOOO
16:26:23 <aristid> @hoogle runMaybeT
16:26:24 <lambdabot> No results found
16:26:34 <aristid> huh? it does exist, no?
16:26:49 <edwardk> (those also turn out to be the monad transformers which are not bind transformers) =(
16:26:55 <edwardk> yes it exists
16:27:04 <edwardk> its in transformers 0.2.2.0 at least
16:28:10 <dibblego> edwardk: do you have a GeneralizedCategory class somewhere?
16:29:36 <edwardk> not in haskell
16:29:49 <dibblego> I'm just trying to recall it, any language will do :)
16:29:49 <edwardk> and my scala one is busted by the broken compiler
16:29:54 <dibblego> oh that's right
16:30:15 <aristid> edwardk: clearly you need to work on EdwardLang
16:30:21 <edwardk> actually it works, but its borderline. since things liek bifunctors encoded with it break the compiler
16:30:30 <edwardk> aristid: i have one, its called kata.
16:30:45 <aristid> edwardk: how's progress on kata=
16:30:46 <aristid> ?
16:30:54 <edwardk> aristid: i tinker with it when my other obsessions are at low ebb.
16:31:20 <cole> Who's ever attempted to compare two fourteen element tuples and gotten a compilation error?
16:31:26 <edwardk> i have a consistent model for it, and i even have some folks who want to work on it =)
16:32:20 <aristid> edwardk: on github at least i think haskell is actually more popular than scala, so maybe you should write the compiler in haskell instead :P
16:32:52 <edwardk> aristid: it started in haskell, i moved a toy project for it to scala just to play around with scala's parsing machinery, etc.
16:32:56 <edwardk> i'm rather neutral
16:33:22 <aristid> just saw ekmett/kata on github and it said "in scala"
16:33:28 <edwardk> its easier to justify toying with at the office if its something we might want to use there ;)
16:33:41 <edwardk> the main compiler project i had for it was in haskell
16:34:00 <mm_freak> edwardk: i think, such a straightforward solution wouldn't work
16:34:11 <aristid> edwardk: is that one on github too?
16:34:13 <mm_freak> i'm generalizing MaybeT, EitherT and ChoiceT (lists)
16:34:18 <edwardk> aristid: not at present
16:34:35 <edwardk> mm_freak: yes. the operation you want is not quite the one i specified
16:34:37 <aristid> mm_freak: with CPS?
16:35:17 <edwardk> mm_freak: hoisting witnesses only the lifting of isomorphisms, what you want is one that describes the structure of wrapping a functor in a monad.
16:36:09 <SirFrancisDrake> how do I parse something like "everything from here to string str" with Parsec? I need an analogue of noneOf for strings
16:37:35 <aristid> i was recently philosophising about the use case for an "@unmtl'd" Monad class. i.e. directly on IO (Maybe a) instead of MaybeT IO a, allowing you to skip some boilerplate. not sure if it really makes sense
16:39:24 <Feuerbach> SirFrancisDrake: see manyTill
16:39:41 <SirFrancisDrake> Feuerbach: thanks!
16:39:55 <edwardk> aristid: meh
16:40:14 <aristid> edwardk: what? :P
16:40:35 <edwardk> pretty sure it doesn't strip overhead =)
16:40:37 * hackagebot recursion-schemes 0.2.1 - Generalized bananas, lenses and barbed wire  http://hackage.haskell.org/package/recursion-schemes-0.2.1 (EdwardKmett)
16:42:48 <edwardk> i didn't mean that to sound nearly as negative as perhaps it did
16:43:37 * hackagebot categories 0.55.0 - categories from category-extras  http://hackage.haskell.org/package/categories-0.55.0 (EdwardKmett)
16:45:32 <ClaudiusMaximus> wheeee my code works: http://claudiusmaximus.goto10.org/g/mandelbrot/gmndl_1-2_3_1-7_1-3_50/ (i typed in an "angled internal address" in the bottom text entry field, then adjusted the zoom level for subsequent images)
16:46:38 * hackagebot pandoc-types 1.8 - Types for representing a structured document  http://hackage.haskell.org/package/pandoc-types-1.8 (JohnMacFarlane)
16:46:41 <ClaudiusMaximus> need to somehow make a progress bar, as it can take a while (30 seconds for larget inputs) to convert address to coordinates, but that could be tricky as that code is pure at the moment...
16:50:10 <ddarius> ClaudiusMaximus: Just use unsafePerformIO
16:50:31 <augur> Saizan: you awake?
16:51:00 <ion> @hoogle Testable prop => [prop] -> IO a
16:51:01 <lambdabot> Foreign.C.Error throwErrno :: String -> IO a
16:51:01 <lambdabot> Network.Socket.Internal throwSocketError :: String -> IO a
16:51:01 <lambdabot> Test.QuickCheck quickCheck :: Testable a => a -> IO ()
16:51:22 <ion> What’s the preferred way to test a number of QuickCheck properties in one run?
16:52:20 <dibblego> ion: mapM_ ?
16:53:41 <ion> The naïve ‘mapM_ quickCheck [prop_a, prop_b, …]’ continues with the following properties even if one fails, and implementing something fold-ish based on the result of each check seems like something the library might as well provide. So i’m wondering if i’m just being blind. :-)
16:53:43 <parcs> @hoogle Map k a -> Int
16:53:44 <lambdabot> Data.Map size :: Map k a -> Int
16:53:44 <lambdabot> Data.Map findIndex :: Ord k => k -> Map k a -> Int
16:53:44 <lambdabot> Data.Graph.Inductive.Graph noNodes :: Graph gr => gr a b -> Int
16:53:46 <kevinburke> i have a tuple of a string and an int
16:53:50 <kevinburke> sorry a list of tuples
16:53:52 <aavogt> mapM_ won't put all the results together at the end
16:54:05 <kevinburke> so like [("a", 5), ("b", 6)]
16:54:10 <kevinburke> how can I sort on the ints?
16:54:16 <dibblego> ion: I use test-framework to do it more robustly
16:54:23 <aavogt> @type sortBy (comparing snd)
16:54:24 <lambdabot> forall a b. (Ord b) => [(a, b)] -> [(a, b)]
16:54:32 <ion> dibblego: Ah, thanks, i’ll look at test-framework.
16:54:43 <dibblego> ion: I also have HTF bookmarked for investigation
16:55:36 <SirFrancisDrake> http://hpaste.org/43424/parsing_nothing trying to parse some comments from Livejournal. main outputs []; it doesn't throw an error, but doesn't print any *s either.
16:55:45 <SirFrancisDrake> am I missing something stupid?
16:55:45 <kevinburke> aavogt: so it would be sortBy snd list ?
16:56:17 <aavogt> kevinburke: no
16:56:34 <aavogt> @type sortBy
16:56:36 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
16:56:50 <aavogt> this doesn't take something with a type like  snd,  so you need the comparing there too
16:57:19 <kevinburke> ok
16:57:21 <kevinburke> thansk
16:57:43 <augur> whats the logic package for haskell?
16:57:52 <edwardk> augur: there are many
16:58:01 <augur> what are the logic packages for haskell?
16:58:02 <augur> :P
16:59:37 <aristid> @hackage logict
16:59:37 <lambdabot> http://hackage.haskell.org/package/logict
16:59:46 <edwardk> don't look at me, i'm just the peanut gallery, its not like i use this language
17:00:27 <aristid> edwardk: what?
17:00:30 <augur> oh, logict
17:00:37 <augur> it hurt my brain trying to understand that :(
17:00:43 <augur> maybe ill give it a second go
17:01:41 * hackagebot recursion-schemes 0.2.2 - Generalized bananas, lenses and barbed wire  http://hackage.haskell.org/package/recursion-schemes-0.2.2 (EdwardKmett)
17:01:51 <edwardk> now with prepro and postpromorphisms
17:02:05 <aristid> what about zygo?
17:02:05 <edwardk> i guess that means i have all the machinery for the infamous zygohistomorphic prepromorphism
17:02:11 <edwardk> had those for a while
17:04:07 <Eduard_Munteanu> Wasn't that already done and based on category-extras or something?
17:04:13 <Eduard_Munteanu> I mean the infamous thingy.
17:04:19 <edwardk> yes
17:04:25 <SirFrancisDrake> parsing, anyone?..
17:04:30 <ddarius> Eduard_Munteanu: Edward wrote category-extras and now he is breaking it apart.
17:04:31 <edwardk> i'm gutting category-extras and divvying it up into separate packages
17:04:38 <Eduard_Munteanu> Ah, I see.
17:04:45 <edwardk> i'm up to recursion-schemes
17:04:56 <edwardk> so now the joke start ;)
17:05:07 <dolio> Does it have envelopes, though?
17:05:16 <mm_freak> aristid: i think, that has nothing to do with CPS
17:05:26 <edwardk> i should add gzygoHistoPrepro as well ;)
17:06:22 * ddarius goes on to write a wildly popular Haskell package that crucially relies on gzygoHistoPrepro so that it can never be removed.
17:06:47 <edwardk> sweet =)
17:07:42 <ClaudiusMaximus> SirFrancisDrake: just a guess - maybe your html doesn't end with a '\n', perhaps try replacing 'endBy' with 'sepBy' ?
17:07:43 <edwardk> nicely the definition is simpler for zygoHistoPrepro than the old junky version on the wiki ;)
17:08:01 <ddarius> Bah.
17:08:20 * ddarius should just finish reading "Fibrational Induction Rules for Initial Algebras" so he can close the evince instance.
17:08:55 <dolio> Seriously. Even I finished that one.
17:09:04 <dolio> Although I don't really remember anything about it.
17:10:10 <SirFrancisDrake> ClaudiusMaximus: thanks. I'll try that
17:11:22 <SirFrancisDrake> ClaudiusMaximus: yeah, worked like charm, thanks a lot.
17:11:38 <alpounet> "fibrational" ?
17:12:15 <mgsloan> goood goood good good fibrations
17:12:16 <alpounet> oh, fibers in maths, ok
17:12:23 <mm_freak> edwardk: it seems like any monad transformer can be an instance of LiftFunctor…  that's quite useful
17:12:50 <ddarius> dolio: I just got distracted by other things and kind of want to finish with the distractions.
17:13:01 <dolio> I know how that goes.
17:13:37 <edwardk> zygoHistoPrepro :: (Unfoldable t, Foldable t) => (Base t b -> b) -> (forall c. Base t c -> Base t c) -> (Base t (EnvT b (Stream (Base t)) a) -> a) -> t -> a
17:13:44 <edwardk> much nicer
17:13:53 <mm_freak> but it seems to be a nontrivial class, i.e. you need to provide actual implementations
17:14:28 <ddarius> dolio: Not terribly related to the paper, but I've recently wanted to do an introduction to fibrations via their internal language.
17:14:55 <edwardk> mm_freak: if you think about it, they all have to transform functors and applicatives
17:15:10 <edwardk> well functors, but they may need to rely on the structure of the monad to work
17:17:10 <mm_freak> yeah
17:17:36 <mm_freak> but for every pair of Monad and MonadT there seems to be a reasonable instance, so i wonder whether one can derive it somehow
17:19:12 <edwardk> man i can't believe http://www.haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms has had a type error in it for years and nobody commented ;)
17:19:47 <Eduard_Munteanu> Nobody dared!
17:19:47 * hackagebot recursion-schemes 0.3.0 - Generalized bananas, lenses and barbed wire  http://hackage.haskell.org/package/recursion-schemes-0.3.0 (EdwardKmett)
17:20:04 <edwardk> mm_freak: i was actually kicking around adding a Data.Functor.Trans which i use as a superclass of ComonadTrans and as a spiritual superclass of MonadTrans for that same reason
17:21:20 <mm_freak> c.h.o still down?
17:21:26 <kevinburke> can someone help me with the following problem?
17:21:27 <kevinburke> http://pastie.org/1510449
17:21:35 <kevinburke> i have a list of tuples and i'm trying to print the first
17:21:45 <edwardk> the main thing i need to add now are bifunctor recursion schemes, which largely obviate the need for prepro and postpro
17:21:47 * hackagebot recursion-schemes 0.3.0.1 - Generalized bananas, lenses and barbed wire  http://hackage.haskell.org/package/recursion-schemes-0.3.0.1 (EdwardKmett)
17:22:17 <kevinburke> of each tuple on a new line
17:22:20 <djahandarie> edwardk, do you submit something to hackage every commit? :P
17:22:46 <edwardk> djahandarie: nah. i try only to push those minor minor version changes when there is a typo in the docs
17:23:12 <edwardk> the usual rule of thumb is x.y is a release with a breaking api change x.y.z adds content and x.y.z.w is a typo correction of some sort
17:23:20 <copumpkin> zygoHistoPrepro f = gprepro (distZygoT f distHisto)
17:23:21 <copumpkin> that's nice
17:23:25 <edwardk> yeah
17:23:34 <edwardk> much less scary now
17:24:22 <kevinburke> why does putstrln expect a char, instead of a String?
17:24:27 <ddarius> edwardk: This was the last/only version I saw: http://www.haskell.org/haskellwiki/index.php?title=Zygohistomorphic_prepromorphisms&oldid=21238
17:24:34 <copumpkin> kevinburke: it doesn't
17:24:35 <ddarius> kevinburke: It doesn't.
17:24:41 <dibblego> kevinburke: putStrLn takes a [Char] not a Char
17:24:58 <kevinburke> can you explain the error message i'm getting on my code then? http://pastie.org/1510449
17:25:00 <edwardk> the type there is missing the coreader transformer around the cofree comonad
17:25:15 <arbitrarylogic> kevinburke: you're feeding a list of strings to putstrln?
17:25:48 * hackagebot contstuff 1.2.4 - Fast, easy to use CPS-based monad transformers  http://hackage.haskell.org/package/contstuff-1.2.4 (ErtugrulSoeylemez)
17:26:04 <kevinburke> i guess so - that's not right then
17:26:21 <dibblego> kevinburke: try print instead of putStrLn
17:27:05 <kevinburke> ok
17:27:41 <dibblego> this may not be what you want in the end, but it might help you find it
17:27:51 <edwardk> mm_freak: you need to start expanding contstuff to cover the comonad-to-monad cps transformers ;)
17:28:12 * ddarius doesn't mention that print will nearly always "work" though is rarely what is desired.
17:28:54 <dibblego> kevinburke: see what ddarius said
17:29:12 <kevinburke> Ok
17:29:16 <Eduard_Munteanu> Yeah, you'll get extra quotes on Strings because it 'show's them.
17:32:38 <edwardk> hrmm, i'm really down to the dregs of whats left in category-extras
17:32:58 <ddarius> edwardk: You can just leave stuff there.
17:33:24 <edwardk> well, i was looking to boil it down to a package that uses whats in the other packages
17:33:59 <kevinburke> i tried "map putStrLn [list comprehension]" but that returns a list
17:34:07 <dibblego> mapM_
17:34:22 <dibblego> again, you'll have the same problem
17:35:00 * ddarius wishes C# didn't follow the other C-style languages with the void stupidity.
17:36:35 <kevinburke> ah
17:36:36 <kevinburke> sequence_ [putStrLn a | (a,b) <- sortedList] 
17:36:44 <kevinburke> thanks for the help!
17:37:00 <mm_freak> edwardk: yeah, at some point i'll do that
17:37:03 <mm_freak> =)
17:37:14 * ddarius won't say that that list comprehension is the same as a map and sequence_ . map is the definition of mapM_.
17:37:24 <mm_freak> but i don't feel comfortable enough using comonads that i could do that right now
17:37:59 <edwardk> mm_freak: hence why you should build intuition using this framework that is comfortable for you ;)
17:38:10 <mm_freak> true =)
17:38:33 <edwardk> hrmm, is there a package providing a zipper on traversables which just uses continuation capture to move left and right?
17:38:35 <mm_freak> but i think contstuff already needs a book to explain
17:39:28 <mm_freak> btw, i have an idea how i can get rid of 'r' without giving up CPS effects
17:39:56 <kevinburke> ddarius: I don't follow what you said
17:40:22 <edwardk> e.g. if you don't want to stitch it together again you can obviously use Foldable.toList to extract a list, and then zipper on that, but it'd be nice to be able to use traverse to make sure that when you're done with the zipper you can have the edited structure
17:40:39 <edwardk> mm_freak: i'm pretty sure thats impossible, but i'd love to be proved wrong
17:41:09 <edwardk> mm_freak: universal quantification over the r gives you Codensity, which 'gets rid of it' in some sense.
17:41:21 <edwardk> mm_freak: but it costs you
17:41:27 <edwardk> you lose callCC
17:42:35 <mm_freak> edwardk: well, the 'r' is usually some inhabitated type
17:42:48 <dmanoltha> :wondering if haskell will get faster.
17:43:24 <edwardk> mm_freak: not always, double negation uses void for 'r'
17:43:45 <edwardk> dmanoltha: its not all that slow to begin with
17:44:52 <edwardk> for consistency i'm so tempted to rename 'comonad' to 'comonads' =/
17:45:04 <ddarius> edwardk: The real answer is that "Haskell" is getting exponentially slower at exactly the opposite rate of Moore's law and so will always be at the current speed.
17:45:23 <edwardk> ddarius: i can live with that, its not like i actually run code once it typechecks ;)
17:45:32 <ddarius> edwardk: This isn't Agda.
17:45:44 <edwardk> true nuff, we have type inference! ;)
17:45:57 <ddarius> edwardk: Exactly!
17:46:22 <fryguybob> kevinburke: mapM_ putStrLn . sortBy (comparing getDistanceFromOrigin)
17:50:33 <SirFrancisDrake> how do I hide <|> from Control.Applicative while importing it?
17:50:45 <Zao> import Foo hiding (Bar)
17:51:01 <SirFrancisDrake> yeah, doesn't work with (<|>) for some reason
17:51:06 <accel> yo yo yo; why is there no database written in haskell?
17:51:12 <Zao> SirFrancisDrake: Throw more parens at it?
17:51:17 <ddarius> The name is (<|>)
17:51:36 <edwardk> import Control.Applicative hiding ((<|>))
17:51:39 <SirFrancisDrake> ddarius: right, thanks *facepalm*
17:51:46 <ddarius> accel: Why are there no databases written in PHP?  Also, are you sure there are no databases written in Haskell?
17:51:54 <SirFrancisDrake> edwardk: yeah, thanks
17:52:14 <accel> ddarius: because php sucks; haskell is teh cool; so someone should ahve written a db in haskell; instead of just providing c bindings yo
17:53:46 <sproingie> i'm sure we can soon look forward to a nosql database written entirely in php
17:54:48 <mm_freak> edwardk: what do you mean with double negation?
17:55:20 <mm_freak> edwardk: name it comonadstuff =P
17:56:33 <edwardk> mm_freak: Not a is the same as saying a -> False — where False is uninhabited if you view logical propositions as types, and the existence of terms with that type as a proof of that proposition.
17:56:46 <ddarius> Good ole von Neumann.
17:56:58 <edwardk> then double negation is Not (Not a). a -> (Not (Not a)) — is easy. its just return for Cont False
17:57:24 <edwardk> but you can't do double negation elimination. a -> Not (Not a) — doesn't work in intuitionistic logic/Haskell
17:57:24 <copumpkin> it's also just flip id
17:57:32 <edwardk> but Not a -> Not (Not (Not a)) — does work
17:57:37 <copumpkin> you have that backwards
17:57:42 <edwardk> er
17:57:43 <edwardk> sorry
17:57:54 <edwardk> Not (Not a) -> a doesn't work in intuitionistic logic/Haskell
17:57:57 <mm_freak> ah, ok
17:58:12 <edwardk> not Not (Not (Not a)) -> Not a does
17:58:16 <edwardk> er but
17:58:46 <ddarius> flip id being the unit of the adjunction that gives rise to the Cont monad.
17:58:50 <edwardk> sproingie: i want copumpkin to write one entirely in agda using spivak's material ;)
17:58:58 <edwardk> exactly
17:58:59 <copumpkin> lol
17:59:14 <edwardk> and amusingly also the counit of that adjunction
18:00:45 <Eduard_Munteanu> I think I liked type Not a = forall b. a -> b  more
18:00:57 * ddarius finds it rather surprising that texts on cartesian closed categories or symmetric monoidally closed categories fail to mention that (-> A) is a (parameterized) right adjoint.
18:01:29 <ddarius> Eduard_Munteanu: forall b. a -> b ~ a -> forall b. b = a -> False.
18:01:32 <dolio> That's isomorphic to a -> (forall b. b)
18:01:42 <dolio> And forall b. b is isomorphic to False.
18:02:09 <Eduard_Munteanu> Yeah, though it's really obvious that way through the principle of explosion.
18:02:27 <accel> dolio: how so?
18:02:39 <Eduard_Munteanu> Also I'm not sure what 'False' is there.
18:02:50 <Eduard_Munteanu> Is it Void?
18:03:04 <ddarius> It can be, or it can just be forall a. a
18:03:05 <Eduard_Munteanu> data Void
18:03:13 <Eduard_Munteanu> Ah.
18:03:20 <tg_> can anyone here suggest what Zariski density is, means?
18:03:29 <tg_> recent paper: http://imrn.oxfordjournals.org/content/2010/19/3649.abstract
18:03:58 <ddarius> tg_: It's density in the Zariski topology which commonly arises from algebraic geometry constructions.
18:04:15 <ddarius> Using an explicit Void type, you'd have one function void :: Void -> a which is your principle of explosion.
18:04:36 <kevinburke> in ghci, if my .hs file has a main method and I type
18:04:41 <kevinburke> :l myfile.hs
18:04:55 <kevinburke> I can't access the other functions inside the file
18:05:23 <kevinburke> how can I add them to the scope?
18:05:39 <Eduard_Munteanu> ddarius: yeah, it expands to my 'Not' there if I replace 'a' with a fresh variable.
18:06:59 <edwardk> Eduard_Munteanu: i use the newtype Void = Void Void definition because its fully haskell 98 mainly
18:07:25 <dolio> The advantage of Void is that it doesn't require impredicativity.
18:07:37 <dolio> Although it requires a built-in type or data instead.
18:07:42 <Eduard_Munteanu> Hrm, nice.
18:09:37 <tg_> does this imply that if I were doing group theory work in haskell, I would need to represent something that way?
18:09:48 <tg_> ie, with the explicit void
18:09:54 <ddarius> http://books.google.com/books?id=m5bSoD9XsfoC&pg=PA7&lpg=PA7&dq=von+neumann+onion&source=bl&ots=dDG-WwtSAO&sig=jM0CYfRniGT1X7S0A6oB1OZwVfQ&hl=en&ei=dMdETfiqLIjpgAeH97yzAQ&sa=X&oi=book_result&ct=result&resnum=2&ved=0CCEQ6AEwAQ#v=onepage&q=von%20neumann%20onion&f=false
18:10:17 <tg_> which part?
18:10:20 <dolio> von+neumann+onion?
18:10:59 <Eduard_Munteanu> Heh.
18:11:14 <tg_> yeah, surprisingly I saw that same thing in the "Word Treasury of Physics, Astronomy, and Mathematics"
18:11:26 <ddarius> tg_: Yeah, that's where I first saw it many years ago.
18:11:32 <ddarius> I want to find the paper though.
18:11:48 <tg_> He's one of the most remarkable minds that I know of, having at least surveyed most of the physics idols
18:13:43 <tg_> ddarius: see my PM? or was that your response?
18:14:07 <SirFrancisDrake> could you recommend a simple http library? I need just to get some html pages from the web.
18:14:32 <accel> wget
18:14:47 <kevinburke> i tried :l fadetoblack
18:14:49 <kevinburke> which works fine
18:14:57 <kevinburke> but :l *fadetoblack doesn't work - do you know why
18:15:04 <kevinburke> immediately one after the other
18:15:10 <tg_> accel: I suspect s/.*/., in Haskell/
18:15:19 <kevinburke> do i need to write "module fadetoblack" or something in my code?
18:17:02 <kevinburke> <command line>:
18:17:02 <kevinburke>     Could not find module `*fadetoblack':
18:17:03 <kevinburke>       Use -v to see a list of the files searched for.
18:17:08 <Eduard_Munteanu> Hah, neo-Castilian.
18:17:13 <kevinburke> the -v flag doesn't work either
18:17:48 <kevinburke> Could not find module `--v':
18:21:39 <kevinburke> if searching google got me the answers, i would, unfortunately these steps don't work for me, for example, http://stackoverflow.com/questions/2950185/ghci-not-loading-function-from-file
18:24:37 <joe6> kevinburke: are you doing this in ghci?
18:24:42 <kevinburke> Yes
18:24:55 <kevinburke> version 6.8
18:25:01 <joe6> and fadetoblack is your haskell source file?
18:25:09 <joe6> no suffix?
18:25:31 <kevinburke> yes
18:25:36 <kevinburke> i'm in the correct directory
18:25:47 <copumpkin> I wouldn't mind Integral being a superclass of Bits
18:25:55 <joe6> what does the error say?
18:26:10 * copumpkin shudders: http://snapplr.com/4pz4
18:26:16 <joe6> or do you not see an error? why do you think that it is not loading?
18:26:18 <copumpkin> (I just "wrote" that)
18:26:42 <kfr> copumpkin nice, you are good at making Haskell look like C
18:27:10 <kfr> Why the nested where btw?
18:27:55 <edwardk> copumpkin: is that your bit tree thingy?
18:28:06 <copumpkin> edwardk: one of the building blocks
18:28:07 <kevinburke> Prelude> :l *fadetoblack
18:28:08 <kevinburke> <command line>:
18:28:08 <kevinburke>     Could not find module `*fadetoblack':
18:28:08 <kevinburke>       Use -v to see a list of the files searched for.
18:28:08 <kevinburke> Failed, modules loaded: none.
18:28:22 <kevinburke> Prelude> :l fadetoblack
18:28:22 <kevinburke> [1 of 1] Compiling Main             ( fadetoblack.hs, interpreted )
18:28:23 <kevinburke> Ok, modules loaded: Main.
18:28:23 <kevinburke> *Main> 
18:28:26 <copumpkin> kfr: good question :P
18:28:36 <geheimdienst> copumpkin: i see the error, it's obvious, you need to put a 17 between the 31 and the 27
18:28:37 <copumpkin> kfr: I copied and pasted the Word32 version into a where block 
18:28:38 <kfr> kevinburke why are you flooding the channel?
18:28:41 <joe6> what is *fadetoblack?
18:28:44 <edwardk> kevinburke: please paste to hpaste if you must
18:28:48 <kevinburke> the name of my file
18:28:49 <kevinburke> okay
18:28:52 <kevinburke> sorry
18:29:02 <copumpkin> geheimdienst: I was hoping there was no error :P
18:29:16 <joe6> i thought  it was just fadetoblack?
18:29:22 <edwardk> copumpkin: is that your bit order?
18:29:37 <copumpkin> nah, it's just a helper function I wanted
18:29:38 <joe6> kevinburke: anyway, it says that it was loaded.
18:29:45 <edwardk> kk
18:29:47 <joe6> why do you think it is not loaded?
18:29:48 <copumpkin> it's basically computing the position of the least significant bit
18:29:53 <kevinburke> i'm trying to do this: http://stackoverflow.com/questions/2950185/ghci-not-loading-function-from-file
18:29:53 <copumpkin> I'd appreciate a better name
18:29:59 <kfr> copumpkin btw, isn't it "zeroes"? :p
18:30:08 <kevinburke> and load the functions in the file other than the main function
18:30:17 <geheimdienst> zereoes
18:30:18 <copumpkin> kfr: another excellent point
18:30:32 <kfr> Oh apparently zeros is accepted in American English
18:30:40 <joe6> kevinburke: post the fadeblack file too to hpaste.org
18:30:44 <kevinburke> it says put a star in front of the name and haskell will load all the files
18:30:45 <kevinburke> sure
18:30:47 * kfr always writes BE when coding with "initialise" and "colour" etc
18:30:49 <copumpkin> I'd prefer a better name that doesn't vary with locale
18:31:01 <mafs> "lsbPos"
18:31:05 <kfr> People always give me crap for that :[
18:31:09 <geheimdienst> "lsb"
18:31:09 <copumpkin> mafs: ick
18:31:29 <kfr> copumpkin when all else fails you can start using lojban in your names in Haskell code, to be a real nerd.
18:31:29 <mafs> copumpkin: You didn't specify it had to be pretty, did you?
18:31:33 <kevinburke> http://hpaste.org/43425/fadetoblack
18:31:37 <copumpkin> lsb isn't so bad
18:31:46 <kfr> Least significant bit?
18:31:50 <edwardk> ah, its the bit hack version
18:31:54 <copumpkin> yeah
18:31:59 <edwardk> multiply/lookup
18:32:07 <geheimdienst> "rightmost1" <- hehe
18:32:08 <copumpkin> on numbers of arbitrary size
18:32:14 <copumpkin> so the helper function is the bithack version
18:32:24 <edwardk> i'm surprised you didn't use unsafeIndex's ;)
18:32:35 <copumpkin> oh good idea!
18:32:43 <mafs> geheimdienst: "rightmostnumberone" ;)
18:32:59 <geheimdienst> tehRightestOne
18:33:50 <joe6> kevinburke: *Main> :t convertHexToInt
18:33:50 <joe6> convertHexToInt :: String -> Int
18:33:55 <copumpkin> right1? :P
18:33:59 <copumpkin> ugh, I hate naming
18:34:23 <kevinburke> I get a not in scope error
18:34:31 <joe6> i just did the :l fadetoblack. nope
18:34:31 <kevinburke> i'm running 6.8.2 on a linux
18:34:44 <edwardk> for anyone interested in the genesis of the hack copumpkin is using: the original paper http://supertech.csail.mit.edu/papers/debruijn.pdf
18:35:07 <joe6> kevinburke: i am on GHCi, version 7.0.1.20110121: 
18:35:13 <copumpkin> oh it had a bug in it too
18:35:15 * copumpkin fixes
18:35:21 <kevinburke> hm
18:35:29 <kevinburke> and it works correctly for you?
18:36:05 <joe6> kevinburke: it loads and gives the type definition. It just seems too basic to not work on 6.8.2. but, I do not know much about it.
18:37:18 <kevinburke> ok
18:37:27 <kevinburke> if i run "ghc --make fadetoblack.hs"
18:37:35 <kevinburke> and then try to load fadetoblack or fadetoblack.hs
18:37:38 <kevinburke> it won't find the other function
18:37:47 <kevinburke> but if i remove the .hi, .o and executable
18:38:02 <kevinburke> and then run :l fadetoblack.hs, it works
18:38:40 <joe6> i did this:  :l fadetoblack.hs
18:39:18 <kevinburke> Ok
18:39:39 <kevinburke> Its working for me now because I removed the .o and .hi files - I'm not sure why that fixes the problem, but it works :-)
18:43:26 <ddarius> kevinburke: Why don't you try reading the GHCi user guide (for the version you're using) next time, or now. 
18:44:53 <joe6> i am trying to check out the source of Eq.hs and the file just has "import GHC.Base". Do you know where I can see the code on how the Eq typeclass implemented?
18:45:17 <joe6> I meant, "is implemented"?
18:46:06 <ddarius> joe6: There's nothing to see.  The class is just a declaration.  A few instances for base types may be in their, but they too will be pretty unsatisfying and useless.
18:46:19 <ddarius> @src Eq
18:46:19 <lambdabot> class  Eq a  where
18:46:19 <lambdabot>     (==), (/=)   :: a -> a -> Bool
18:46:31 <joe6> ddarius: ok, thanks.
18:46:34 <ddarius> Hmm.  There should be another (two) lines.
18:47:04 <copumpkin> edwardk: lol, my "mask tree" magically turned into an iteratee without me noticing, although its semantics are slightly different
18:47:13 <ddarius> x == y = not (x /= y); x /= y = not (x == y)
18:47:49 <kevinburke> ddarius: thanks, I had looked at this page http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html
18:47:56 <kevinburke> but didn't find the answer
18:49:07 <ddarius> kevinburke: It still explains why deleting the .o and .hi files works.
18:49:56 <edwardk> copumpkin: =)
18:53:08 <kevinburke> sorry, ive reread that 3 times now and still can't find the relevant section, i'm new to haskell
18:57:09 * ddarius watches some fantastic guitar playing to make himself happy.
18:59:58 <dark> i want to know something: can parsec get a (infinite) list of parsers and give me a parser that outputs a list, where each element is the output of each designated parser?
19:01:10 <SirFrancisDrake> dark, you mean, does parsec support axiom of choice?
19:01:49 <dark> I would use it as a non-deterministic choice, yes
19:01:55 <ddarius> Works every time.
19:02:09 * SirFrancisDrake envious
19:02:47 <ddarius> Actually... choice over an infinite list may well work giving the first successful parse.
19:03:37 <edwardk> hrmm, i just slapped together a little comonadic zipper into any semigroup-traversable container, now to build the monadic version
19:04:00 <edwardk> @hpaste
19:04:00 <lambdabot> Haskell pastebin: http://hpaste.org/
19:04:01 <ddarius> edwardk: Always nice to work with super abstract things.  The code just writes itself.
19:04:08 <dark> I have a dynamic list of keywords / identifiers / etc and the grammar is sensitive to each one (it sounds messy, and it actually is). I can either rebuild the parser at every change (I don't want to have a mutable reference), or simply return all possible parsing trees, and choose later
19:04:47 <edwardk> i rather like this one. you can have a vector of Ints, walk around in it, then get back the resulting vector
19:04:48 <ddarius> Parsec doesn't return multiple results.
19:04:48 <dark> I was thinking in putting some kind of mark to differentiate between each form statically
19:05:29 <edwardk> http://hpaste.org/43426/a_zipper_for_traversables — i bypassed the continuation capturing version in favor of materializing the contents
19:05:45 <dark> ddarius, but can't I pass a list of parsers, each one outputing b, and it would return a parser that outputs [b]?
19:05:59 <edwardk> so its a list zipper that just happens to know how to fill its contents back into some traversable container
19:06:02 <ddarius> dark: Not something that would work on an infinite list.
19:06:25 <ddarius> dark: Some other parsing libraries may work, but most won't.
19:06:47 <edwardk> its correctness is predicated on the fact that you don't change the list size
19:07:02 <dark> ddarius, if I walk into a lazy list to get something at middle of it, will it trigger evaluation of each intermediate element?
19:07:19 <ddarius> No.
19:07:34 <edwardk> once i add a Traversable1 instance you can take zippers of zippers
19:07:37 <pedro3005> can I override standard functions in haskell?
19:08:00 <edwardk> pedro3005: you can hide the prelude functions, and you can make up your own versions
19:08:10 <pedro3005> edwardk, how do I hide?
19:08:14 <dark> uhm. I would hope it to "return" all parser trees, and when I chose what I want, it would evaluate just this one. (I actually don't need an _infinite_ list, it would just be more general)
19:08:22 <edwardk> pedro3005: import Prelude hiding (scanr)
19:08:41 <pedro3005> edwardk, can I do that from ghci?
19:08:51 <copumpkin> yeah, as of quite recently, I think
19:08:56 <edwardk> pedro3005: i've never done so
19:09:04 <ddarius> dark: Again, Parsec doesn't return multiple results.  It is not intended for globally ambiguous grammars.
19:10:25 <ddarius> At best you could embed your action within Parsec so that it's backtracking will reexecute your code and then you just keep failing.
19:11:27 <dark> something I didn't know was there is such a thing as globally or locally ambiguities on grammars
19:12:13 * hackagebot vcd 0.2.1 - Reading and writing VCD files.  http://hackage.haskell.org/package/vcd-0.2.1 (TomHawkins)
19:12:33 <copumpkin> @oeis 0,1,1,3,1,5,3,7,1,9,5,11,3,13,7,15,1,17,9,19,5,21,11,23,3,25,13,27
19:12:35 <lambdabot>  a(n) = numerator of c(n) = if n=1 then 0 else if n < 3*2^[Log2(n)-1] then (c...
19:12:35 <lambdabot>  [0,0,1,0,1,1,2,0,1,1,3,1,3,2,3,0,1,1,3,1,5,3,7,1,5,3,7,2,5,3,4,0,1,1,3,1,5,3...
19:12:40 <dark> but google isn't helping much
19:12:49 <copumpkin> hah, I devised a sequence oeis doesn't know about
19:13:26 <dark> o.o''
19:13:35 <dark> @oeis 0,1
19:13:38 <lambdabot>  Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
19:13:38 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
19:13:48 <dark> hah
19:13:59 <Bynbo7> @oesis 0,1,2,3,4,5
19:14:00 <lambdabot>  Digital sum (i.e. sum of digits) of n.
19:14:01 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9,10,2,3,4,5,6,7,8,9,10,11,3,4,5,6,7,8,...
19:14:16 <Bynbo7> o.O
19:14:35 <copumpkin> can anyone figure out how my sequence works?
19:15:07 <ryant50001> is there any disadvantage to using lazy bindings for product types like tuples and such?
19:15:13 <dark> copumpkin, maybe if you give more terms it will figure out better o.o
19:15:15 <ddarius> ryant50001: Yes.
19:15:27 <dark> because all its responses seems technically correct
19:15:28 <ryant50001> ddarius: what sort of disadvantage?
19:15:32 <pedro3005> edwardk, it won't let me hide (+) ! :p
19:15:51 <Bynbo7> pedro3005: just use .+
19:15:52 <copumpkin> dark: the sequence it spat back at me, in response to my query, wasn't the sequence I gave it
19:16:10 <dark> oh.
19:16:15 <pedro3005> Bynbo7, how so?
19:16:26 <dark> it could check this and say it failed, then..
19:16:38 <Bynbo7> instead of defining +, define .+ ...
19:17:21 <pedro3005> now it doesn't let me pattern match with .+
19:17:31 <ddarius> ryant50001: To start, it would be inconsistent with the other cases.  It also has different semantics and which you want depends on what you are doing.  Most importantly, it can have a significant impact on performance, particularly memory performance.
19:17:39 <ddarius> (for better or worse)
19:19:12 <ryant50001> ddarius: ah, yeah, i know the semantics are different (_|_ versus (_|_, _|_), and all that); i'll have to figure out the performance at some point, as that's very important to me
19:21:13 * ddarius doesn't think he's ever seen Antoine Dufour use a flat pick.  This will be interesting.
19:39:04 <copumpkin> Cale: around?
19:40:19 <copumpkin> anyone remember what calculus book Cale is always recommending?
19:40:41 <ddarius> Probably the same one everyone recommends.
19:40:48 <copumpkin> which is that?
19:40:59 <ddarius> Calculus on Manifolds by Michael Spivak.
19:41:47 <copumpkin> that's the one I think
19:42:05 <fryguybob> > map (\n -> (lcm n 16) `div` 16) [0..27]
19:42:06 <lambdabot>   [0,1,1,3,1,5,3,7,1,9,5,11,3,13,7,15,1,17,9,19,5,21,11,23,3,25,13,27]
19:42:08 <Zao> #haskell_201012.log:04:53 < Cale> http://cale.yi.org/share/Michael%20Spivak%20-%20Calculus.pdf
19:42:15 <Zao> He sure seems to like spamming the link in my logs :D
19:44:24 <fryguybob> copumpkin: http://oeis.org/A106617
19:45:21 <copumpkin> fryguybob: that isn't it either
19:46:30 <ddarius> Calculus is the easier going but less deep one.
19:47:00 <edwardk> @hpaste
19:47:00 <lambdabot> Haskell pastebin: http://hpaste.org/
19:47:43 <edwardk> http://hpaste.org/43427/zipping_traversables_monadical
19:48:06 <edwardk> that turned out rather nice actually, easy to see the separation of concerns unlike the pure comonadic version
19:48:40 <edwardk> runStateTZipper lets you take a traversable apart, then rezip it with new contents.
19:49:14 <edwardk> if we had an indexed monad, then this would work slightly more nicely, because then you could use the comonad to change out the type of the contents
19:49:36 <kniu> I was just looking at http://cdsmith.wordpress.com/2011/01/24/my-dream-ghci-session-take-2/
19:49:59 <kniu> And it gave me an idea that I think might have been explored before.
19:50:09 <kniu> What if we design a language around debugging?
19:51:40 <Bynbo7> edwardk: i do hope you're planning on writing some tutorials on how to use all these packages, and why we'd want to
19:52:13 <ddarius> Bynbo7: You are making some wild assumptions there.
19:53:34 <gwern> Bynbo7: the packages need no tutorials. they will reveal themselves to the elect
19:53:46 <Omie^> Hi everyone !
19:53:52 <gwern> GREETINGS FELLOW HUMAN
19:54:00 <Omie^> I need some help with [char] and String
19:54:04 <ddarius> gwern: What if Omie^ is not a human?
19:54:15 <gwern> ddarius: that's a chance I'm willing to take
19:54:26 <gwern> Omie^: [Char] == String, next question please
19:54:34 <Bynbo7> Omie^: why, they are exactly the same!
19:54:38 <Bynbo7> @src String
19:54:39 <lambdabot> type String = [Char]
19:54:41 <ddarius> gwern: Omie^ hadn't asked a question.
19:54:59 <Omie^> give me a min, I'll clarify my question
19:55:16 <gwern> ddarius: of course he asked a question. how could he clarify his question if he hadn't asked one?
19:55:35 <mafs> Yes, give the (wo)man a minute, people. No need to pounce on the opportunity to answer the non-question ;)
19:55:48 <ddarius> gwern: You can have a question without asking it and thus presumably clarify it while never asking it.
19:56:16 * ddarius is currently trying to clarify some text he's never written.
19:56:52 <gwern> can one have a question without it being asked? asking would seem to be inherent to the concept of a question. if you don't ask it, it's simply an absence of knowledge you've noticed
19:56:57 <Omie^> This article is a reason I turned to Haskell. http://www.catonmat.net/blog/simple-haskell-tcp-server I spent ~4 hours last night on basics and then tried to do little modifications to this tcp server program
19:57:25 <Omie^> there is one function as echoCommand :: Handle -> [String] -> IO ()
19:57:46 <Omie^> first thing I was trying to do is only echo a welcome text to user who is connected
19:58:12 <Omie^> so I changed (handle, _, _) <- accept sock to (handle, hostName, port) <- accept sock
19:58:25 <geheimdienst> Welcome to Radio #Haskell.™ We Rapidly Answer Questions You Didn't Ask, Then Launch A Debate On Question Epistemology.™
19:58:47 <Omie^> and tried to send hostname and port to echoCommand using putStrLn and ++
19:58:54 <Bynbo7> Omie^: that handle is only connected to one user, you should have no need for the hostname and port they connected from
19:59:23 <Bynbo7> you need to look at the types is hostName and port. they aren't strings
19:59:50 <gwern> geheimdienst: all in majestic stereo
20:00:31 <Bynbo7> haskell doesn't do automatic type conversions. you need to use something like show: hPutStrLn ("Hello visitor from " ++ show hostName ++ ":" ++ show port ++ " you said: " ++ <thing to echo>
20:00:40 <Omie^> http://hackage.haskell.org/packages/archive/network/latest/doc/html/Network.html#t:HostName hostname is string I guess
20:01:19 <Bynbo7> yes, hostname is a string
20:01:27 <Bynbo7> so the show i used above is unnecessary
20:02:21 <Omie^> but it doest quite work. I wrote a new function welcomeUser :: Handle -> [Char] -> IO () only to greet user and it works well. Only change I made is used [Char] instead of String
20:02:49 <Omie^> and this is the real cause of confusion
20:02:56 <gwern> and as I already said, [Char] = String
20:02:57 <Bynbo7> Omie^: change [Char] to String
20:03:03 <Bynbo7> they are exactly the same thing
20:03:09 <Bynbo7> a string is a list of characters
20:03:24 <mafs> Omie^: Above you say [String] in the type signature; so here [Char] should actually be [[Char]], or simply [String]
20:03:30 <gwern> (that you mentioned them in the same breath is a classic sign of error, and why I answered an unasked question)
20:04:02 <Bynbo7> ah, nice catch mafs 
20:04:12 <Omie^> okay. I will try again with it. be back in few mins
20:05:05 <mafs> Bynbo7: Thanks. I figured that'd be Omie^'s problem when he first mentioned the type signature and it relating to String/Char confusion, but figured I'd wait for there to be a question
20:06:09 * Bynbo7 is getting kicked out of his tokyo apartment tomorroe :(
20:06:12 <Bynbo7> w*
20:06:34 <gwern> Bynbo7: don't worry, I hear it's not so bad being homeless in tokyo. cute self-righteous ladies bring you free food and lecture you
20:06:46 <Bynbo7> heh
20:07:21 <Bynbo7> luckily I'll be staying in a nice hotel until we've finalised the new place I'll be staying at
20:07:42 <djahandarie> Bynbo7, how long are you even there for?!
20:07:48 <djahandarie> I feels like you've been there for ages :P
20:07:59 <Bynbo7> only another two weeks or so
20:09:28 <djahandarie> axman-san no nihongo wa yokushimashitaka
20:09:52 <Bynbo7> sounds familiar, nfi what you said though :P
20:09:58 <Omie^> back
20:10:08 <djahandarie> Haha, asked if your Japanese has gotten better
20:10:37 <Bynbo7> nope :P
20:10:44 <Omie^> I missed a very small thing. it needs [String] but i was sending just hostName. when I used [hostName] it compiled fine. I am on right track ?
20:11:00 <Omie^> but it doesnt echo any message on server or client
20:11:06 <poutine> dibblego, Is freenode that much better for you? do people blow you here for overpaying for an education that is not used in practice?
20:11:21 <gwern> trollbot.org, eh?
20:11:23 <dibblego> poutine: please refrain
20:11:34 <poutine> I am not a bot
20:11:35 <Bynbo7> @where ops
20:11:35 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
20:11:43 <gwern> poutine: they do, yeah. we're all gay niggers here
20:11:56 <gwern> can't afford lube, so blowjobs it is
20:11:56 <Bynbo7> fucken monkeys
20:12:01 --- mode: ChanServ set +o copumpkin
20:12:03 <Bynbo7> amigoinrite?
20:12:05 <poutine> I was having a conversation with dibblego on DALnet before he emo quit stating how dalnet was a cesspool
20:12:15 <gwern> poutine: I'd say you've proven his point
20:12:19 <Bynbo7> DELnet is a cesspool
20:12:24 --- mode: copumpkin set +b *!~poutine@you.can.trust.this.trollbot.org
20:12:24 --- kick: poutine was kicked by copumpkin (no thanks)
20:13:05 <dibblego> thanks
20:13:17 <Bynbo7> that nick looks familiar
20:13:47 <copumpkin> mmm
20:13:50 <copumpkin> yummy
20:13:56 --- mode: copumpkin set -o copumpkin
20:19:53 <Scriptor> heh, poutine is an age-old troll on IRC
20:20:57 <Omie^> i figured it out :)
20:22:16 <Omie^> I have another question. I've been searching for practice program questions and landed on this page. http://boards.straightdope.com/sdmb/showthread.php?t=545396 a comment there is 'On the other, unless you're running X11 you'll probably not have any use for it.'
20:22:46 <Omie^> I am running haskell on ubuntu installed on virtual machine. I dont think i have X11 support
20:23:04 <glguy> that doesn't sound right
20:23:26 <glguy> There was a news story about trying to move away from it eventually
20:23:31 <glguy> but I can't imagine that that happened already
20:23:52 <gwern> Omie^: well, if you don't have any windows to manage, hard to see what good a window manager does you
20:23:53 <ddarius> glguy: Not that it matters anyway if you look at the context that statement is taken from.
20:24:34 <ddarius> Omie^ seems to be really bad at googling.
20:24:54 <gwern> ddarius: yeah, but what's the polite way to tell him that?
20:25:13 <ddarius> gwern: You save time and brain cells by not trying to solve such problems.
20:26:11 <Omie^> lol ! its fine if you are not polite at times. I'm well familiar with IRC and internet I am at your position in C# channels. I am just new to haskell :-P
20:27:01 <geheimdienst> Omie^: imho using xmonad is not for the faint of heart :) especially if you're used to another operating system. i'd recommend to not start with xmonad rightaway. have you worked through a tutorial yet?
20:27:05 <geheimdienst> @where lyah
20:27:05 <lambdabot> http://www.learnyouahaskell.com/
20:27:20 * ddarius is pretty familiar with C# though he certainly doesn't frequent C# IRC channels.
20:27:42 * ddarius <3 xmonad.
20:27:54 <djahandarie> I use xmonad and float all of my windows.
20:27:57 * ddarius first used ion3 on Windows.
20:28:09 <ddarius> djahandarie: Floating windows is a sin.
20:28:23 <djahandarie> Then call me a sinner!
20:28:29 <Omie^> geheimdienst: I am not starting with xmondad. I only landed on that page because it topped in google results. I went through the page and found that comment was kinda.. odd so asked
20:28:36 <ddarius> djahandarie: I already judged you earlier for floating a window.
20:28:53 <Omie^> sorry its xmonad
20:29:05 <djahandarie> I know, I'm just trying to provoke you again
20:29:28 <ddarius> djahandarie: You can only burn for eternity once.  No need to condemn you twice.
20:30:06 <kfr> Take it to #theism! This is a channel of science!
20:30:22 <homekevin> Science! It works, bitches!
20:30:31 <homekevin> Sorry, it had to be said.
20:30:34 <codemac> what's the story on code.haskell.org? I remember seeing something about all the community sites being down?
20:30:38 <Omie^> I'm done with last night's problem and tryaskell.org. Reading book side by side. but I'd like to jump to code for what I've learned so far. any list of programs to practice ?
20:30:59 * ddarius rarely uses even tabbing.  Too close to the edge.
20:31:05 <Omie^> [ perhaps I need to sleep more, making many typos :-S Sorry for that ]
20:31:47 <ddarius> If God wanted you to see more than one application at a time on a screen He wouldn't have made them look like tiny, cramped, unreadable messes.
20:31:47 <homekevin> Good question Omie^. I'd like some practice problems too. They don't need to be Haskell-specific necessarily.
20:32:02 <homekevin> I bet there's a list of problems out there on the web somewhere.
20:32:13 <ddarius> @google haskell exercises
20:32:15 <lambdabot> http://www.haskell.org/haskellwiki/99_Haskell_exercises
20:32:15 <lambdabot> Title: H-99: Ninety-Nine Haskell Problems - HaskellWiki
20:32:17 <ddarius> Like that one.
20:32:23 <ddarius> Or the many, many others.
20:33:46 <Bynbo7> codemac: it got hacked, so they're moving to a new server
20:34:18 <Omie^> bookmarked 99-haskell. Should have used word 'exercise' instead of 'problems'. Thanks :-)
20:34:47 <Omie^> will come back with more problems when I'll run into [ I am being lazy :-D ]
20:34:48 <Bynbo7> Omie^: i would highly recommend lyah before trying to go much further
20:34:50 <Bynbo7> @where lyah
20:34:50 <lambdabot> http://www.learnyouahaskell.com/
20:35:54 <Omie^> yeap ! I'm on pattern matching page of lyah
20:36:01 <dibblego> homekevin: https://bitbucket.org/dibblego/haskell-course/
20:36:41 --- mode: ChanServ set +o copumpkin
20:36:46 --- mode: copumpkin set +b *!*@*troll*
20:36:51 --- mode: copumpkin set -o copumpkin
20:37:29 <ddarius> What about "patrolling" ?
20:37:56 <copumpkin> sucks for them
20:38:19 <copumpkin> wow, jhc is actually usable now
20:38:22 <copumpkin> since it has the GC turned on
20:38:44 <ddarius> Just write your code not to allocate.
20:38:53 <copumpkin> oh yeah
20:40:01 <Bynbo7> so, this is a surprise. since moving to 64 bit ghc for OS X, I've actually had lessproblems with the upgrade than any other ghc upgrade :o
20:40:08 <Bynbo7> i can even install ghc-core for once!
20:40:21 <ddarius> It must be that 64-bit goodness.
20:40:46 <ion> ddarius: And controller! And outrolling!
20:41:00 <copumpkin> Bynbo7: all those extra bits give you more space to do cool things!
20:41:27 <Bynbo7> i'm just surprised that more things have been able to compile than with the 32 bit version :o
20:42:55 <ddarius> copumpkin: That is completely true.
20:43:18 <copumpkin> you also get some more registers to do cool things in!
20:43:25 <copumpkin> but everyone knows that 64 is better than 32
20:43:39 <copumpkin> I liked it when consoles would boast about how many bits they had
20:44:02 <monochrom> "nintendo 64"
20:44:34 <Bynbo7> no one even remembers the nintendo 32!
20:44:47 <geheimdienst> nintendo 2000
20:47:58 * ddarius has the kanji for yoku on the same page he has his compact definition of fibrations.
20:49:28 <copumpkin> well, that's good
20:49:35 <ddarius> No one ever uses the letters in the Greek alphabet that look like their Latin equivalents.
20:49:51 <copumpkin> except for the ambiguous ones like rho
20:49:51 <djahandarie> Kanji? You speak Japanese?
20:49:53 <copumpkin> or nu
20:51:03 <monochrom> ΛΑΜΒΔΑ
20:51:34 <ddarius> いいえ。
20:51:47 <djahandarie> -_-
20:52:00 <djahandarie> Then why are you responding in Japanese? :P
21:01:21 <codemac> How do you guys generally go about understanding the code layout/design of a haskell code base? I'm having trouble.. but could it just be a lack of familiarity with Haskell?
21:01:31 <codemac> Also, is there something similar to cscope, but for haskell?
21:01:40 * hackagebot xml-enumerator 0.1.0.2 - Pure-Haskell utilities for dealing with XML with the enumerator package.  http://hackage.haskell.org/package/xml-enumerator-0.1.0.2 (MichaelSnoyman)
21:04:52 <gwern> codemac: bottom-up or top-down are the ways to go
21:05:57 <gwern> @quote
21:05:58 <lambdabot> meenuh says:  oh yes please. i am in dire need of boobs.
21:06:25 <geheimdienst> @quote
21:06:26 <homekevin> I can relate
21:06:26 <lambdabot> dylan says: pugs, darcs, and lambdabot: gateway drugs to haskell.
21:08:02 <kfr> What is pugs?
21:08:27 <ManateeLazyCat> @google pugs
21:08:28 <Bynbo7> the original perl6 implementation
21:08:28 <lambdabot> http://www.pugs.com/
21:08:28 <lambdabot> Title: PugsCom: You are using an invalid IP
21:08:35 <Bynbo7> heh
21:09:15 <homekevin> Why does perl6 lead to haskell?
21:09:30 <kfr> It does not
21:09:33 <ManateeLazyCat> homekevin: Because pugs author use it.
21:09:36 <geheimdienst> pugs is written in haskell
21:09:37 <Bynbo7> because pugs was written in haskell
21:11:14 <ddarius> The concept of a digital sundial is simultaneously cool and quixotic.
21:11:33 <Bynbo7> very cool
21:13:47 <ddarius> Actually a digital sundial may have uses.
21:22:19 <CrazyMug> Being?
21:25:16 <SHiNKiROU> @help
21:25:16 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:25:32 <SHiNKiROU> @pl (sum.filter(>=a).takeWhile(<=b))primes
21:25:32 <lambdabot> sum (filter (>= a) (takeWhile (<= b) primes))
21:25:50 * BMeph wants a glow-in-the-dark sundial; now THAT'S quixotic!
21:25:58 <djahandarie> How well does Data.Sequence perform non-asymptotically?
21:25:59 <SHiNKiROU> @pl (\x y ->(sum.filter(>=a).takeWhile(<=b))primes)
21:25:59 <lambdabot> const (const (sum (filter (>= a) (takeWhile (<= b) primes))))
21:26:17 <SHiNKiROU> @pl (\a b->(sum.filter(>=a).takeWhile(<=b))primes)
21:26:17 <lambdabot> flip flip primes . ((sum .) .) . (. (takeWhile . flip (<=))) . (.) . filter . flip (>=)
21:26:21 <djahandarie> SHiNKiROU, you can /msg lambdabot any commands you want by the way
21:26:28 <SHiNKiROU> ok
21:27:11 <SHiNKiROU> it didn't work
21:27:40 <djahandarie> /msg lambdabot @pl \x -> x
21:27:46 <djahandarie> Should pop up in a new window
21:30:56 <ddarius> djahandarie: It depends on what you are comparing it to.  For example, if all you want to do is prepend and append quickly, then it is probably rather slow for that compared to some simpler structures.
21:31:07 <ddarius> If you use the full flexibility then it should be reasonably efficient.
22:01:22 <joe6> list
22:01:36 <joe6> > list
22:01:37 <lambdabot>   Not in scope: `list'
22:04:52 <JETkoten> hi all
22:04:58 <Bynbo7> 'lo
22:05:12 <JETkoten> Bynbo7: how's it going?
22:05:45 <Bynbo7> not bad
22:06:02 <JETkoten> great
22:06:12 <JETkoten> how's your Haskell use lately?
22:06:54 <Bynbo7> well, my job at the moment is writing haskell, so pretty good?
22:07:42 <JETkoten> ahh? that's nice
22:07:50 <kfr> Using heavily, eh?
22:07:52 <JETkoten> i'm just getting started with Haskell
22:08:15 <kfr> Any problems with digestion? Shivers? Insomnia?
22:08:40 <JETkoten> kfr: that's only for withdrawal, not everyday use :)
22:08:47 <kfr> Do you spend a lot of money on H?
22:09:02 <kfr> I hope you don't reuse needles
22:09:20 <kfr> Local Curry Centers give out free ones, look it up on Google
22:09:37 <JETkoten> i do have a couple of questions about haskell-mode on emacs, does anyone here use it?
22:09:41 <kfr> I do
22:11:00 <JETkoten> ok, well i'm wondering if there's a way that when i do C-c C-l to load the code that i have in a haskell-mode buffer and it sends it to ghci... can i get it to somehow put the cursor focus right into the lower (interpreter) split window?
22:11:23 <JETkoten> every time i start typing to interact with the code i loaded, i end up typing in the code instead of the interpreter
22:11:31 <kfr> Well, you can obviously code that yourself
22:11:37 <JETkoten> i'd like it to just jump the cursor focus down once i've loaded something...
22:11:49 <JETkoten> except that i don't know any elisp! :)
22:12:00 <kfr> Personally I never use any interpreter with emacs other than the elisp one that is
22:12:11 <kfr> Oh snap
22:12:20 <kfr> elisp is the only reason I even started messing around with emacs
22:12:36 <kfr> Customising other editors was too tedious
22:12:40 <JETkoten> i see, what do you code Haskell in then?
22:12:45 <kfr> emacs
22:13:10 <JETkoten> ok, maybe my terminology is off a little... isn't ghci an interpreter in this case?
22:13:12 <kfr> Start out with C-h k and then C-c C-l
22:13:13 <kfr> Yes
22:13:15 <JETkoten> or you just don't use it?
22:13:16 <kfr> I don't use ghci with emacs
22:13:19 <JETkoten> it = ghci
22:13:20 <JETkoten> ahh ok
22:13:27 <kfr> I use ghci in csrss
22:13:29 <Bynbo7> you can use ghci in a normal terminal...
22:13:41 <kfr> (I'm on Windows)
22:13:55 <JETkoten> y, i tried that at first but when i found haskell-mode i just found it to be useful to load the code right in as i edit
22:15:41 <JETkoten> my other question relates to ghci too, but might be unique to emacs... is there a way to clear the screen while running ghci in emacs? in my system terminal i can just do C-l, but that key combination is bound to something else in emacs... and i'd like to clear the gci screen but don't know how...
22:16:17 <JETkoten> i'll have to look into how to modify the cursor thing with elisp.
22:31:12 <drbean> Thought hoogle was unable to handle 'ß', but it was just choosing to truncate the explanation of toUpper at that point.
22:35:25 <drbean> I make my own decisions, downloading a package from hackage.haskell.org?
22:36:01 <Bynbo7> ?
22:37:02 <drbean> I download it myself with wget, curl, a web browser or something?
22:37:23 <Bynbo7> use cabal-install :\
22:37:28 <Bynbo7> that;s what it's there for
22:37:36 <Bynbo7> did you install the platform?
22:38:05 <drbean> I used the Fedora haskell packages.
22:38:26 <Bynbo7> ok, do you have the cabal program
22:39:03 <Bynbo7> even better, can you run `cabal install <package>`
22:44:47 <[mth]> Does anyone know of a single latex symbol to represent >>=?
22:45:28 <Bynbo7> is there's a 'much greater than or equal to' operator? :P
22:45:48 <geheimdienst> ≥
22:45:55 <geheimdienst> good enough
22:46:04 <geheimdienst> or » ?
22:46:32 <[mth]> I am just trying to save some space when referencing bind.
22:47:14 <[mth]> geheimdienst,  is a good start thanks.
22:48:21 <geheimdienst> sorry, didn't that come through ...? i typed "greater than or equal" http://en.wikipedia.org/wiki/Inequality_(mathematics)
22:48:46 <geheimdienst> the second was a guillemet http://en.wikipedia.org/wiki/Guillemet
22:49:49 <Bynbo7> [mth]: http://www.artofproblemsolving.com/Wiki/index.php/LaTeX:Symbols
22:50:50 <Bynbo7> also, http://detexify.kirelabs.org/classify.html is super useful
22:51:18 <Bynbo7> happens to also use haskell i believe :)
22:51:32 <drbean> geheimdienst: They came thru here.
22:51:42 <[mth]> Bynbo7, thanks had been trying detexify without much luck.
22:51:43 <Bynbo7> \gg= might do it
22:52:01 <[mth]> geheimdienst, Bynbo7, thanks, I think I will go with \gg=
22:52:14 <Bynbo7> not a single symbol, but oh well
22:55:23 <Bynbo7> [mth]: could also use \curlyeqsucc
22:55:41 <ddarius> Simply use (=<<) and notate (f =<<) as f^*.
22:55:51 <Bynbo7> http://detexify.kirelabs.org/symbols.html
23:00:28 * ddarius is an idiot.  -Of course- the way to get the dependency in the comprehension category is to use of -substitution- functor of the projection the comprehension category gives.
23:01:19 <edwardk> ddarius: clearly. derp ;)
23:02:29 <ddarius> I had understood this before and I was wondering why it wasn't making sense this time.
23:05:47 <edwardk> my monadic traversavle zipper is kinda boring, since its state passing around a list zipper, with a contract that i don't change its length so i can repackage it in the original traversable
23:06:24 <edwardk> go to flip it around and see if i can get a nice store comonad with the same model
23:08:06 <ddarius> Bart Jacobs' thesis is elegant and dense as fuck.
23:08:31 <edwardk> whats the topic?
23:08:47 <ddarius> edwardk: Categorical Type Theory is the title.
23:09:43 <edwardk> light reading. bookmarked ;)
23:09:52 <ddarius> Basically it's about using fibrations to model contextual dependency and how to model common type theoretic features in this fibrational setting.
23:10:48 <djahandarie> That guy sure has a lot of papers
23:10:56 <ddarius> Andrew Pitts "Categorical Logic" lectures should be quite a bit more readable but covers much less ground and provides less of a framework.
23:11:43 <ddarius> It's probably a good thing to read before Jacobs' thesis insofar as if you don't understand the ideas in Pitts' lecture notes, you haven't a chance in hell of understanding Jacobs' thesis.
23:12:06 <edwardk> also noted
23:12:22 <dolio> Also, Wesley Phoa.
23:12:33 <edwardk> i note bart jacobs has a 750 page book on the topic =/
23:13:09 <dolio> If you're looking to spend money.
23:13:18 <ddarius> edwardk: Going by the prospectus (which may not be indicative) the book seems like it is a much more readable version of the thesis (with also logic as well as type theory.)
23:13:34 <edwardk> i'm decidedly neutral on the topic of spending money here
23:13:38 <ddarius> The prospectus makes a decent overview/introduction to the area in general.
23:15:04 <ddarius> edwardk: In a nutshell, Jacobs' is describing the internal language of (a very broad class, if not all) fibrations.
23:18:24 <ddarius> I'd like to make an article that is the reverse of Jacobs' thesis (and also much less technical) that goes from an understanding of type theory and basic category theory to an understanding of fibrations rather than the other way around.
23:20:27 <dolio> Phoa's book claims to be targeted at computer scientists, but it still seems pretty good.
23:20:58 <edwardk> ddarius: sounds good. i'd probably buy a copy ;)
23:21:54 <xpika> > fromConstr (toConstr (False))  :: Bool
23:21:55 <lambdabot>   False
23:22:12 <xpika> > fromConstr (toConstr (Nothing))  :: Maybe Int
23:22:13 <lambdabot>   Ambiguous type variable `a' in the constraint:
23:22:13 <lambdabot>    `Data.Data.Data a'
23:22:13 <lambdabot>      a...
23:22:31 <xpika> can anyone help me out ?
23:22:49 <ddarius> :t fromConstr . toConstr
23:22:50 <lambdabot> forall a a1. (Data a, Data a1) => a1 -> a
23:23:02 <ddarius> :t fromConstr . toConstr $ Nothing
23:23:04 <lambdabot>     Ambiguous type variable `a' in the constraint:
23:23:04 <lambdabot>       `Data a' arising from a use of `toConstr' at <interactive>:1:13-20
23:23:04 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
23:23:12 <dolio> > fromConstr (toConstr (Nothing :: Maybe Int)) :: Maybe Int
23:23:14 <lambdabot>   Nothing
23:23:16 <edwardk> > fromConstr (toConstr (Nothing :: Maybe Int)) :: Maybe Int
23:23:17 <lambdabot>   Nothing
23:23:21 <edwardk> beat me to it
23:23:26 <dolio> @yow!
23:23:27 <lambdabot> Couldn't find fortune file
23:23:32 <ddarius> > fromConstr (toConstr (Nothing :: Maybe Char)) :: Maybe Int
23:23:33 <lambdabot>   Nothing
23:24:13 <xpika> thankyou!
23:24:22 <ion> @quote
23:24:23 <lambdabot> lighthazard says: LOOK the bitch said she WANTED it okay?  It's not rape if she WANTS it.  I don't care what the fucking jury said.
23:24:28 <joe6> can I pattern against a function or does it have to be in a case statement?
23:25:11 <ion> joe6: What do you mean by “against a function”?
23:25:12 <joe6> sorry, I meant pattern-match
23:25:36 <joe6> test (x) = "corrcet" ; where x is a function returning an Int
23:25:46 <dolio> Who added that quote?
23:25:52 <joe6> the syntax is not correct, I just wanted to get my idea across.
23:26:00 <mornfall> joe6: How would that work? :)
23:26:13 <ion> The (x) in there is a pattern match. (Although the parentheses are redundant.)
23:26:24 <Bynbo7> dolio: might be worth having lambdabot remember that sort of thing...
23:26:35 <mornfall> joe6: I mean, it's a parameter like this, meaning that it'll take any function. But you can't pattern on the function any more than that.
23:26:40 <ddarius> dolio: You can attempt to grep the logs, but that won't help if it was added in another channel or in a private message.
23:26:48 <mornfall> (Of a given type, of course.)
23:26:50 <joe6> ion: please ignore the syntax, I want to pattern-match the parameter against the return value of a function x.
23:27:35 <ddarius> joe6: You can use view patterns or just use a case.  View patterns are a fairly recent extension and probably not terribly compelling here.
23:28:30 <ddarius> joe6: "Pattern matching on the result of a function" is rather different than "pattern matching on the function itself."
23:28:37 <joe6> thanks, will check on view patterns.
23:28:56 * ski sometimes would like to pattern-match on functions ..
23:28:57 <joe6> ddarius: "Pattern matching on the result of a function", i meant "Pattern matching on the result of another function"
23:29:04 <mornfall> Right. You can't usefully match on a function. You need to apply it to get a value first.
23:29:28 <ski> mornfall : well ..
23:29:35 <mornfall> ski: In Haskell. :)
23:30:23 <mornfall> (Even if you come up with syntax for it, it'll be undecidable anyway, so that may as well fall out of the "useful" category...)
23:31:05 <ski> mornfall : i think possibly matching on patterns like `\x -> (f x,g x)' could make sense in haskell
23:31:33 <ski> though i suppose this would be nicer with "lazy" pairs
23:32:01 <mornfall> Well, if you rule out recursion, maybe... but it's still hard to implement I guess.
23:32:36 <ddarius> mornfall: Higher order pattern unification and matching are decidable, but they do use input terms in typed, strongly normalizing languages (usually the STLC.)
23:32:37 <ski> mornfall : then there's another category of function matches like in `(\y -> z) . (\x -> y) = \x -> z'
23:33:10 <joe6> is there any reason why the haskell internal data structures do not use records?
23:33:12 <dolio> h (\x -> (f x, g x)) = ...  ==> h k = let f = fst . k ; g = snd . k in ...?
23:33:16 <ski> (possibly that should be `(\?y -> z) . (\?x -> ?y) = \?x -> z' instead)
23:33:25 <joe6> just curious on knowing they would have taken that decision.
23:33:35 <ski> dolio : yes
23:33:39 <mornfall> ddarius: Strongly normalizing languages aren't Turing-complete.
23:33:53 <ddarius> mornfall: I'm well aware of this.
23:34:07 <mornfall> So it's a bit apples-oranges kind of deal. :)
23:34:37 <ddarius> mornfall: General higher order unification is not decidable (or deterministic) regardless of whether the input is in a strongly normalizing language.
23:35:10 <mornfall> Life'd be too boring if everything was decidable.
23:35:14 <mornfall> :)
23:35:43 * ski (probably) wasn't suggesting full higher-order matching .. just a quite restricted form of it
23:35:43 <mornfall> (It does kind of make you wonder if undecidability is built into universe somehow...)
23:36:13 <ddarius> mornfall: Your computer is a finite state machine.
23:36:32 <mornfall> ddarius: I'm well aware of that. ;)
23:37:47 <ddarius> Whether the universe has undecidability "built-in" which it wouldn't if it was finite and quantized isn't really relevant, since exploring the state-space of even your cell phone would take longer than the universe has left.
23:38:43 <mornfall> I was more thinking in terms of math, not of specific things. (But yes, I find it hard to imagine that in a different universe, math could work differently. Sounds definitely crazy.)
23:38:45 <ddarius> mornfall: However, one of the main thrusts of Wolfram's book is that Turing completeness happens extremely easily (ignoring resource limitation.)
23:39:07 <mornfall> And so does undecidability, yes.
23:40:06 <joe6> can you please take a look at this: http://hpaste.org/43429/joe
23:40:08 <ski> (mornfall : haven't you heard ? every category is a different mathematical universe :P )
23:40:38 <ddarius> Another kind of pattern matching against functions (at least superficially) is the kind of patterns that occur in the dynamic pattern calculus.
23:41:02 <joe6> ddarius: "dynamic pattern calculus" is this in haskell?
23:41:07 <ddarius> ski: Embedded into the same physical universe.
23:41:10 <mornfall> ski: Is it? :)
23:42:05 * ski wants to know where to go and see mathematical universes displayed (a museum ?)
23:42:06 <joe6> ddarius: can you please check line 44 of the http://hpaste.org/43429/joe
23:42:16 <ddarius> joe6: No.
23:42:30 <joe6> i am trying to get a case to match against different values.
23:42:52 <joe6> where ''Test is a function returning the name of Test
23:43:07 <mornfall> That's TH. Ick. :)
23:43:17 <joe6> or, may be i could use guards.
23:43:19 <mornfall> I don't know nearly enough about TH.
23:43:33 <joe6> it is just another function. ignore the TH portion.
23:44:03 <mornfall> '' is too magic for me...
23:44:12 <mornfall> So I don't know what you are trying to match on.
23:44:12 <ddarius> mornfall: All there is to TH is splicing, quoting, and now quasiquoting.  Other than that, it's just code.
23:44:16 <joe6> ddarius: yes, I should be using guards.. sorry to bother you.
23:44:34 <mornfall> ddarius: Yeah, but '' is definitely something TH-ish.
23:44:54 <mornfall> And I definitely don't know how it works and what is the type of ''Foo.
23:44:59 <ddarius> mornfall: True, and it would fall under quoting.  It merely gets the name of a type/class.
23:45:08 <ddarius> :t ''Maybe
23:45:09 <lambdabot>     lexical error in string/character literal at character '\''
23:45:17 <mornfall> (And whether it is something you can put into a pattern.)
23:45:45 <mornfall> ddarius: Is it a "constant" kind of thing?
23:46:03 <ddarius> Unless they've changed it at some point, I'm pretty sure it is not something you can put in a pattern.
23:46:13 <ddarius> I'm pretty sure the type of ''Maybe, say, is Name.
23:46:29 <mornfall> joe6: There goes your answer. :)
23:46:32 <ddarius> :k Language.Haskell.TH.Name
23:46:33 <lambdabot> *
23:54:24 <ddarius> Maybe I should get familiar with the QQ stuff so I can implement higher order matching in Haskell with not atrocious syntax.
