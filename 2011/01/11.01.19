00:11:05 <wagle> i seem to have successfully ripped everything off the wall and rebuilt it all from scratch
00:11:49 <pastorn> haha
00:12:11 <pastorn> well, i have to admit i know very little about the platform
00:13:54 <lars9> is there an offline doc?
00:14:14 <lars9> i usually use online doc like http://www.haskell.org/ghc/docs/6.12.2/html/libraries/array-0.3.0.0/Data-Array-IArray.html
00:14:35 <lars9> but i need to go offline programming for a few hours
00:15:09 <pastorn> lars9: if you use cabal you have the install packages tarballs in ~/.cabal/*sumthin*
00:15:21 <pastorn> you can extract that and mess with haddock, or just look in the sourc files
00:15:39 <pastorn> lars9: you could also install the program 'hoogle' which can help you out a bit
00:16:25 <lars9> pastorn: i use hoogle, but isn't it online?
00:16:26 <wagle> do you do anything besides put ~/.cabal/bin in your PATH?  like how does it know where to find ~/.cabal/lib?
00:16:36 <pastorn> lars9: $ cabal install hoogle
00:16:42 <lars9> i install everything using arch's yaourt.
00:16:57 <lars9> pastorn: yeah i have cli version of hoogle
00:17:01 <pastorn> wagle: no clue... i think that's some ghc config thingy
00:17:18 <pastorn> lars9: i don't think that requires you to be online
00:17:19 <lars9> maybe this works, downloading: http://www.haskell.org/ghc/docs/6.12.2/libraries.html.tar.bz2
00:18:28 <pastorn> lars9: whoa! where did you find that?
00:19:04 <lars9> here: http://www.haskell.org/ghc/docs/6.12.2/
00:19:15 <lars9> just removed last parts of a doc's url.
00:20:46 <lars9> pastorn: yeah it works. unziped.
00:22:04 <hvr> shouldn't "instance Applicative ((,) a)" be defined in Control.Applicative?
00:23:52 <ski> eek !
00:24:00 <ski> hvr : `instance Monoid w => Applicative ((,) w)', but yes, it ought to be, imo
00:24:02 <hvr> ski: for some reason my ghc-7 install doesn't list it in ghci when asking via ':info Applicative'
00:24:28 <Spockz> Is there some way to see how many people downloaded your package from Hackage?
00:24:29 <hvr> I've only import Control.Applicative
00:24:29 <ski> hm
00:24:30 <ski> isn't it `Data.Applicative' ?
00:25:12 <hvr> ski: not really... http://hackage.haskell.org/packages/archive/base/4.3.0.0/doc/html/Control-Applicative.html
00:25:36 <hvr> ah...
00:25:37 <ski> hm, no, i was confusing it with `Data.Traversable' (which is in `Data')
00:25:47 <hvr> I had to import 'Data.Monoid' as well
00:25:56 <hvr> now it's there... :)
00:26:15 <ski> @instances-importing Control.Applicative Applicative
00:26:16 <lambdabot> ((,) a), ((->) a), Const m, ContT r m, Either e, ErrorT e m, IO, Maybe, ReaderT r m, StateT s m, WrappedArrow a b, WrappedMonad m, WriterT w m, ZipList, []
00:29:54 <hvr> it's always confusing to me, I have to import 'Control.Monad.Instances', before I can work with the (,)-applicative
00:49:39 <adimit> ##java
00:49:55 <dobblego> The End.
00:50:11 <Axman6> This is not the channel you are looking for o/~
00:50:57 <horms> hi Axman6 
00:52:59 <adimit> oi. It seems I mistyped. stupid weechat. Sorry.
00:55:12 <Axman6> o/ horms 
00:58:21 <bsmntbombdood> is there a builtin::[a] -> (a,a) like \[x, y] -> (x, y)?
00:59:00 <dobblego> bsmntbombdood, such a function is not guaranteed to succeed
00:59:22 <bsmntbombdood> dobblego, i know
00:59:27 <dobblego> ok
00:59:33 <dobblego> I don't think one is built it
01:00:42 <dobblego> is lambdabot's rc file format documented? specifically, to pass a server password?
01:01:32 <ketil> Silly cabal problem: I have a library and an executable.  Adding the library to build-depends for the exectuable fails with a dependency cycle, not adding it causes the build to fail (since it depends on the library).  Help?
01:01:38 <bsmntbombdood> i actually want uncurryList f = \(x:y:_) -> f x y
01:03:01 <Veinor> @pl \(x:y:_) -> x y
01:03:02 <lambdabot> ap ((`ap` tail) . (. head) . (const .) . head) tail
01:03:06 <Veinor> there you go!
01:03:57 <arcatan> @pl \f (x:y:_) -> f x y
01:03:58 <lambdabot> (`ap` tail) . (. head) . flip flip tail . (ap .) . flip flip head . (((.) . (const .)) .)
01:04:07 <arcatan> elegant!
01:04:56 <Veinor> :t flip flip
01:04:57 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
01:05:00 <Veinor> caleskell!
01:05:04 <Veinor> :t flip
01:05:05 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
01:05:34 <Veinor> so wait, flip is <*> ?
01:05:44 <Veinor> er, wait, no
01:05:45 <dobblego> no
01:06:36 <dobblego> @type \f a -> fmap ($a) f
01:06:36 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
01:07:36 <Veinor> @pl \f a -> fmap ($ a) f
01:07:36 <lambdabot> flip (fmap . flip id)
01:18:40 <bsmntbombdood> hrm
01:19:06 <bsmntbombdood> liftM2 (=<<) (uncurryList outputError) (uncurryList checkUrl) should = on (liftM2 (=<<)) uncurryList outputError checkUrl, but the second doesn't type
01:20:38 <Axman6> :t (liftM2 (=<<))
01:20:39 <lambdabot> forall a (m :: * -> *) b (m1 :: * -> *). (Monad m, Monad m1) => m1 (a -> m b) -> m1 (m a) -> m1 (m b)
01:20:57 <Axman6> :t on
01:20:59 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
01:21:09 <Axman6> :t on (liftM2 (=<<))
01:21:11 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
01:21:11 <lambdabot>       Expected type: m (a -> a -> b)
01:21:11 <lambdabot>       Inferred type: m (a -> a)
01:21:21 <Axman6> no dice
01:22:25 <bsmntbombdood> but the first DOES type
01:24:01 <bsmntbombdood> how can you say f x y z but not f x?
01:27:05 <quicksilver> bsmntbombdood: "on" works on a binary function whose parameter types match.
01:27:28 <quicksilver> bsmntbombdood: liftM2 (=<<) is not such.
01:28:09 <quicksilver> bsmntbombdood: although your example appears to follow the syntactic pattern of 'on', the trick is that you're using "uncurryList" at two different types.
01:28:28 <quicksilver> bsmntbombdood: plain haskell doesn't support this kind of higher-rank polymorphism.
01:28:45 <bsmntbombdood> oh, i see
02:21:37 <rocksteady> hi
02:23:19 <theom3ga> hi 
02:23:23 <theom3ga> I have a question
02:23:32 <Zao> theom3ga: We tend to have answers.
02:23:39 <theom3ga> Zao, I hope so
02:23:46 <theom3ga> why isn't it possible to create new unary operators in Haskell?
02:24:15 <ski> the language wasn't designed to be able to do that
02:24:54 <theom3ga> ski, yep, but I guess there was a reason that led to that design decision
02:26:08 <ski> > let infix 0 !; (!) 0 = 1; (!) n = n * (n - 1 !) in (5 !)
02:26:09 <lambdabot>   120
02:26:54 <ski> i assume they thought that infix operators would be most useful, and they didn't want to bother with prefix and postfix ones
02:27:03 <ski> i don't really know, though
02:27:56 <ski> (certainly it would have been doable to have prefix and postfix as well .. Prolog does, e.g.)
02:29:46 <rocksteady> got a very basic question. got this function: http://pastebin.com/3cmpNrjp How should a main function look like, calculating f with values (e.g. 5 4 3 2 1) and printing the result? dont got this working :/ "main = print(show f(5 4 3 2 1))" doenst work for me
02:31:19 <ski>   main = print (show (f 5 4 3 2 1))
02:31:29 <ski> you got your brackets wrong
02:31:44 <rocksteady> thx a lot
02:31:52 <ski> function calls are not `f(x y z)' but `f x y z'
02:32:04 <ski> brackets are just used for grouping
02:32:07 <rocksteady> okay. i see
02:32:22 <theom3ga> what does operator ## do?
02:32:27 <ski> and actually `print (show ...)' is really strange
02:32:46 <ski> probably you either wanted `print ...' or `putStrLn (show ...)' (they do the same
02:32:51 <ski> @src print
02:32:51 <lambdabot> print x = putStrLn (show x)
02:33:03 <ski> @hoogle ##
02:33:03 <lambdabot> No results found
02:33:19 <theom3ga> ok, I've been scammed then
02:33:19 <ski> theom3ga : no idea. presumable some library-specific thing
02:33:21 <rocksteady> oh okay :P
02:33:39 <ski> (`hoogle' doesn't index all of hackage, btw)
02:36:28 <jonkri> how can i stop a running program in ghci/haskell-mode?
02:39:45 <ski> > let polynomial coefficients x = foldr (\coefficient result -> coefficient + x * result) 0 coefficients in polynomial [2,3,4,5] 1  -- rocksteady
02:39:46 <lambdabot>   14
02:40:02 <ski> > let polynomial coefficients x = foldr (\coefficient result -> coefficient + x * result) 0 coefficients in polynomial [d,c,b,a] x
02:40:03 <lambdabot>   d + x * (c + x * (b + x * (a + x * 0)))
02:40:23 <rocksteady> very great :)
02:41:01 <ski> if you really prefer having the list of coefficients the other way, you can use `foldl' (and flip the order of `coefficient' and `result')
02:41:18 <_pa_> Hmm, what was the name of that search tool for Haskell that lets me find where a given function or symbol is defined?
02:41:39 <ski> @hoogle sequenceA
02:41:39 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
02:41:40 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
02:41:40 <rocksteady> okay
02:41:45 <ski> @index sequenceA
02:41:45 <lambdabot> bzzt
02:41:49 <ski> @index mapM
02:41:50 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
02:42:01 <ski> _pa_ : any of those ? `Hayoo' ?
02:42:01 <_pa_> AH, hoogle. Thanks guys!
02:42:04 <_pa_> (and girls?)
02:42:13 <ski> haskellers :)
02:42:16 <_pa_> Haha
02:42:39 <_pa_> HMm. Have I dreamt about the >== function?
02:42:47 <ski> @hoogle >==
02:42:48 <lambdabot> No results found
02:42:49 <ski> @hoogle >>=
02:42:50 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
02:42:50 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
02:42:50 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
02:42:53 <ski> @hoogle+
02:42:58 <_pa_> Ahhh. Rats! =)
02:43:11 <ski> <ski> (`hoogle' doesn't index all of hackage, btw)
02:43:17 <ManateeLazyCat> hello login from android 
02:43:34 <ski> meow, ManateeLazyCat
02:43:58 <ManateeLazyCat> ski: hi
02:44:55 <ManateeLazyCat> looks not bad
02:45:27 <ManateeLazyCat> not support Nick highlight 
02:46:25 <DeadPanda> I hadn't realised quite how easy it is to parse with Parsec, but I've got one problem; the token stream I'm parsing contains the occasional token I really don't care about, is there any way to just "throw away" input until I reach a token I care about?  I think it's a pretty basic problem, but I just don't get it...
02:48:22 <Zao> DeadPanda: The latest Monad Reader talked about interleaved streams. There might be something of use in that paper.
02:48:28 <rocksteady> ski: may you explain your function from above step by step? I dont get it :/
02:48:38 <DeadPanda> Zao, thanks, is that open access?
02:48:43 <Zao> http://themonadreader.wordpress.com/2011/01/09/issue-17/
02:48:48 <DeadPanda> Zao, ah, cheers
02:49:06 <ski> rocksteady : have you seen `foldr' or `foldl' before ?
02:49:24 <rocksteady> yes. i looked up and understood what foldr does
02:49:28 <ski> ok
02:49:34 <ski> so
02:49:45 <ski>      polynomial [d,c,b,a] x
02:50:01 <ski>   =  foldr (\coefficient result -> coefficient + x * result) 0 [d,c,b,a]
02:50:14 <ski>   =  d + x * foldr (\coefficient result -> coefficient + x * result) 0 [c,b,a]
02:50:26 <ski>   =  d + x * (c + x * foldr (\coefficient result -> coefficient + x * result) 0 [b,a])
02:50:35 <ski>   =  d + x * (c + x * (b + x * foldr (\coefficient result -> coefficient + x * result) 0 [a]))
02:50:37 <rocksteady> ah alrite
02:50:43 <ski>   =  d + x * (c + x * (b + x * (a + x * foldr (\coefficient result -> coefficient + x * result) 0 [])))
02:50:51 <ski>   =  d + x * (c + x * (b + x * (a + x * 0)))
02:51:05 <ski> which is arithmetically equivalent to
02:51:34 <ski>   =  d + x * c + x^2 * b + x^3 * a
02:52:06 <rocksteady> okay thanks
02:54:17 <anonimus> any1 here?:)
02:56:21 <gienah> anonimus: can sometimes be quite around this time
02:58:08 <quicksilver> well there's a whole page full of discussion in the last 10 minutes
02:58:11 <quicksilver> not *that* quiet.
02:58:34 <gienah> :-)
03:06:25 <_pa_> I'm not understanding this: Occurs check: cannot construct the infinite type: a = Map a a1
03:06:46 <quicksilver> it means you made a mistake
03:06:50 <_pa_> Hah yes
03:06:54 <quicksilver> and accidentally confused a key with the whole map
03:07:52 <_pa_> Ah, yes. I can see that now
03:08:37 <_pa_> I need to get my head around all these new error messages
03:08:54 <DeadPanda> Zao, thanks for the link, but it looks like I can achieve what I need with a combination of parser permutations and an additional token type for "unparsed" tokens (which I'll discard later)
03:12:22 <_pa_> Hmm, I swear I saw a function over Data.Map that made it have a default value
03:12:36 <mux> :t lookupWithDefault
03:12:37 <lambdabot> Not in scope: `lookupWithDefault'
03:12:40 <mux> mm
03:12:45 <_pa_> I want to do adjust though
03:13:08 <mux> :t adjust
03:13:09 <lambdabot> Not in scope: `adjust'
03:13:14 <mux> :t Data.Map.adjust
03:13:15 <lambdabot> forall a k. (Ord k) => (a -> a) -> k -> M.Map k a -> M.Map k a
03:13:44 <mux> adjust won't let you do this it seems, you want something more generic; maybe alter
03:13:53 <mux> (though often there are less generic functions you could use)
03:14:02 <mux> what exactly do you want to do?
03:14:57 <mux> insert some value if it's not already there, or modify it if it is there?
03:15:03 <mux> insertWith comes in handy in those cases
03:15:17 <Axman6> dolio: you about?
03:19:05 <Tica> hi all
03:19:15 <Axman6> 'lo
03:19:58 <Tica> im newbie in haskell but ,,,what editor do u think is best,,, on windows os?
03:20:29 <Axman6> notepad++? i'm not sure what people use on windows. do you have a favourite editor?
03:20:53 <kenny```> I like ultraedit
03:21:26 <kenny```> with additional haskell.uew file with syntax highlighting
03:21:52 <Tica> k i'll try it
03:28:24 <Veinor> emacs for windows :D
03:29:10 <Jafet> Using two bloated operating systems at the same time is just asking for it.
03:29:21 <Veinor> eight megs and constantly swapping!
03:32:15 <Tica> hmm i think notepad++ is better:D
03:33:28 <DeadPanda> Komodo isn't so bad, but I prefer emacs on windows for the better indentation
03:53:31 <mm_freak> Tica: i use emacs on all systems, at least for haskell hacking
03:53:43 <mm_freak> it has a very mature haskell mode
04:13:19 <rocksteady> ski: u wrote this function for me: http://pastebin.com/iyHwvrQn
04:13:25 <rocksteady> i know what line 4 does
04:13:36 <rocksteady> but how do the vars in line 3 get assigned?
04:13:48 <rocksteady> and whats calculated in line 5?
04:14:49 <Axman6> rocksteady: line 3 defines a new function inside f
04:14:58 <rocksteady> oh
04:15:09 <Axman6> line 5 calls that function on its arguments
04:15:26 <rocksteady> sounds logical
04:15:40 <rocksteady> the missing brackets are confusing me in haskell
04:16:25 <Axman6> what missing brackets?
04:16:59 <sipa> the lack of redundant brackets you mean?
04:17:07 <rocksteady> i usually call a funkction like f(x, y)
04:17:24 <Axman6> but those brackets are indeed redundant
04:17:29 <rocksteady> and when i read "polynomial coefficients " i thought 3 vars got declared
04:17:33 <Axman6> and not having them makes the functions much more useful
04:17:54 <sipa> you can still write f(x) (y) if you really want to :D
04:17:59 <sipa> instead of f x y
04:18:21 <Axman6> but people will hate you ;)
04:18:25 <rocksteady> makes it hard for me to differentiate a function from a variable intuitively
04:18:54 <Axman6> well, you can rthink of 'variables' as functions with no arguments
04:19:50 <sipa> variables store (or represent) values
04:19:58 <sipa> a value can either be a constant or a function 
04:20:11 <rocksteady> thi reduced this function ( http://pastebin.com/iyHwvrQn ) like this: http://pastebin.com/ixqsWBAN
04:20:16 <rocksteady> its similar, isnt it?
04:20:35 <rocksteady> *equivalent
04:20:38 <Axman6> yup
04:20:43 <rocksteady> nice
04:20:52 <Axman6> well, from first looking at it it is
04:24:08 <rocksteady> thank you all for the support. c u
04:33:53 <_pa_> mux: sorry. Went for lunch. I want to +1 
04:34:07 <_pa_> (oops - premature enter) the value under a given key
04:35:04 <Veinor> _pa_: adjust (1+) value yourMap
04:36:08 <_pa_> Haha I'm not being very good at explaining =)
04:36:16 <_pa_> I want to +1 if the key is there, insert 1 if not
04:36:29 <Veinor> ahh
04:36:32 <mux> _pa_: as I said, in this case, insertWith is probably what you want
04:36:41 <_pa_> mux: yeah, going to look at that
04:36:41 <Veinor> also, when did hoogle grow web2.0?
04:36:43 <_pa_> Thanks folks!
04:36:44 <mux> :t Data.Map.insertWith
04:36:45 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
04:36:54 <mux> insertWith (+) key 1 map
04:37:17 <mux> and it's cute
04:37:18 <_pa_> What a brilliant function
04:38:08 <_pa_> NIce, works!
04:38:22 <_pa_> This is so much more fun than fixing the layout of my flippin web form
04:40:59 <quicksilver> yeah, insertWith is awesome.
04:41:03 <quicksilver> intersectionWith, too.
04:41:14 <parcs> is there any way to have ghci compute an expression but not print it out?
04:41:30 <_pa_> let xxx = ... ?
04:41:38 <DrSyzygy> parcs: expr `seq` ()
04:41:44 <parcs> DrSyzygy: yeah, i just thought of that
04:41:46 <parcs> thanks
04:43:00 <Axman6> _pa_: that doesn't compute it
04:43:36 <parcs> hmm, seq doesn't seem to be doing anything here
04:44:06 <mux> seq only forces its first parameter to WHNF, this may not be enough depending on what you do there
04:44:09 <Axman6> parcs: what type is the expression?
04:44:17 <parcs> [[Int]]
04:44:25 <Axman6> yeah, that won't force anything useful
04:44:26 <mux> indeed
04:44:30 <mux> you need a deepseq
04:44:33 <Axman6> you need something like deepseq
04:44:44 <parcs> @hoogle deepseq
04:44:44 <lambdabot> No results found
04:44:54 <mux> there's a deepseq package on hackage
04:45:13 <Axman6> or, you can use a collegue's favourite method: length (show x) `seq` () :P
04:45:31 <Axman6> mux: i believe it's not part of the parallel strategies package
04:45:59 <mux> Axman6: hmm? I haven't said it was part of it, I talked about a standalone deepseq package
04:45:59 <parcs> there we go :) thanks
04:46:11 <Axman6> uh, now, not not
04:46:22 <retco> I'm looking for an essay or something of sorts along the lines of "Functional Programming - Why?"
04:46:27 <mux> http://hackage.haskell.org/package/deepseq
04:46:48 <Veinor> Axman6: ha, length . show as deepSeq
04:46:52 <Veinor> i like that.
04:47:06 <Axman6> this was to avoid spaceleaks
04:47:29 <Axman6> but, we finally found out today that the spaceleak problem was with the iteratee package, hooray!
04:47:31 <Jafet> That does sounds a lot more practical than (NFData a) =>
04:47:51 <Maxdamantus> Hmm.. How do people (do they?) usually manage a sort of set of IORefs?
04:48:01 <Maxdamantus> (or something similar to IORefs)
04:48:04 <Axman6> i never understood where the name NFData came from. 
04:48:46 <mux> normal form data, I guess
04:49:02 <Axman6> ah, that makes sense
04:49:46 <Jafet> Is it possible to make a typeclass alias?
04:50:21 <Jafet> There's always (A ...) => B ..., I suppose
04:50:33 <mux> there was a typeclass alias proposal
04:50:46 <_pa_> Hmm, I have a huge [(String, Integer)] in IO. Is there now way for me to peek a little at it without evaluating all of it?
04:50:56 <_pa_> take 10 and head both seem to evaluate it
04:51:37 <Maxdamantus> "it"
04:51:42 <_pa_> Er, nm. I think I get what's going on here. It hasn't actually done anything.
04:51:58 <_pa_> What I've done is that I've counted the word frequency in a rather large text file
04:52:01 <Jafet> They don't even have to evaluate the list elements.
04:52:01 <Maxdamantus> It shouldn't evaluate the members in the list.
04:52:16 <DrSyzygy> _pa_: You can't get a peek on that without traversing your entire file.
04:52:17 <mux> that has happened to me many times -- like, "damnit, I have a space leak" -- "Oh, actually, my code is buggy and was entering an infinite loop."
04:52:30 <_pa_> DrSyzygy: right. That's what I realized
04:52:40 <Axman6> _pa_: using a list for that doesn't seem like a good idea to me
04:52:45 <Jafet> mux: as long as it leaks space slower than hard drives get bigger
04:52:51 <mux> heh
04:52:52 <Maxdamantus> > tail [undefined, "foo"]
04:52:53 <lambdabot>   ["foo"]
04:52:53 <_pa_> I've read about Haskell almost daily for a long time but only just started playing with it for real
04:53:10 <_pa_> Axman6: It's a Data.Map which i have toList:ed
04:53:27 <_pa_> I only did that because I didn't think much and thought that I could take 10 
04:53:43 <Axman6> the map is likely what's taking up all the space. also why are you using Integer instead of Int or In64?
04:53:50 <_pa_> Got owned by the non-strict nature
04:54:09 <_pa_> I didn't say that it should be Integer
04:54:16 <_pa_> That's what was inferred 
04:54:42 <Axman6> well, i'd make it either Int or Int64 if you're on a 32 bit system
04:54:51 <_pa_> I'm on a 64bit Mac
04:54:58 <Axman6> do you have 64 bit GHC?
04:55:20 <_pa_> Tell me how to find out and I'll tell you =)
04:55:33 <_pa_> http://hpaste.org/43143/counting_word_frequencies
04:55:35 <Zao> file `which ghc` ?
04:55:44 <Axman6> Zao: it's a script
04:55:55 <Zao> Axman6: Meh.
04:56:06 <Zao> Axman6: Thought only silly things like runghc and friends were scripts.
04:57:05 <Axman6> there is a flag to ghc, i just can't remember it
04:57:08 <Jafet> Axman6: that's almost certainly not the source of his space leaks
04:57:24 <Axman6> ah, ghc --info
04:57:31 <Axman6> maybe...
04:57:51 <_pa_> Nope, that does not mention anything about bittage
04:58:37 <Axman6> how did you install ghc?
04:58:48 <_pa_> A DMG I think
04:58:51 <_pa_> Was a while ago now
04:59:24 <Axman6> the haskell platform?
04:59:27 <_pa_> yes
04:59:31 <Axman6> then it'll be 32 bit
04:59:47 <Axman6> Jafet: i doubt that's where it is too, but it can't hurt :)
05:00:13 <Jafet> Well, there's nothing wrong at this point with using Integer.
05:00:23 <_pa_> How would I tell it to use Int instead?
05:00:24 <Jafet> Except possibly the silly library functions that take only Int
05:02:13 <quicksilver> > maxBound :: Int
05:02:14 <lambdabot>   9223372036854775807
05:02:21 <quicksilver> ^^ that's probably the simplest way to check if you're 32 or 64 bit
05:02:29 <quicksilver> (lambdabot is 64 bit, as you can see)
05:02:44 <Axman6> > maxBound :: Int32
05:02:44 <_pa_> 32 bits it is =)
05:02:45 <lambdabot>   2147483647
05:03:27 <mornfall> quicksilver: Meaning that Int is the C pointer size, not the C int size?
05:05:11 <_pa_> Hah, evaluating this is burning one of my cores now
05:05:17 <quicksilver> mornfall: technically it's decided on a port by port basis.
05:05:29 <quicksilver> mornfall: but yes, in practice, it is the C pointer size.
05:05:47 <mornfall> I see.
05:05:49 <_pa_> Is there a function that can time other calls?
05:05:59 <quicksilver> mornfall: because the GHC implementation of parametricity means every value is stored in the same space as a pointer, so you might as well use all that space for your Int
05:06:23 <Axman6> _pa_: how would that be pure?
05:06:36 <mornfall> quicksilver: That's also true of enumerations and stuff?
05:06:43 <_pa_> Axman6: IO isn't pure
05:06:44 <quicksilver> yes.
05:06:47 <quicksilver> everything is word sized.
05:06:53 <_pa_> Axman6: it could return the result in an IO or whatnot
05:06:53 <mornfall> That's a bit of an ugh.
05:06:58 <quicksilver> pros and cons.
05:07:11 <quicksilver> parametric compilation is nice.
05:07:11 <mornfall> Of course.
05:07:18 <mornfall> It's a bit surprising though.
05:07:21 <quicksilver> and the GC not having to understand complex data formats is nice.
05:07:21 <ben> > logBase 2 $ fromIntegral (fromIntegral (maxBound :: Int) * 2 :: Integer)
05:07:23 <lambdabot>   64.0
05:07:30 <ben> ¯\(o_O)/¯
05:08:03 <quicksilver> also, word-aligned access is much faster on most hardware.
05:08:13 <quicksilver> so, memory compactness is the "only" downside.
05:08:54 <mornfall> quicksilver: And the associated cache waste, which is more of a problem than plain RAM consumption.
05:09:02 <quicksilver> well, that's true.
05:09:08 <quicksilver> but cache is cheap, right?
05:09:13 <mornfall> Not really.
05:09:38 <Jafet> If it was, they'd ship more of it.
05:09:50 <quicksilver> the CPU cache on my machine is larger than the disk space taken by the entire OS on my old computer.
05:10:23 <quicksilver> Jafet: they do ship more of it.
05:10:25 <mornfall> quicksilver: L2.
05:10:30 <mornfall> quicksilver: There's also L1.
05:10:37 <quicksilver> Jafet: and disable half or 3/4 of it 
05:10:49 <quicksilver> Jafet: because it's cheaper to do that than fab two different configurations.
05:10:57 <quicksilver> from which, I deduce, it must be cheap :)
05:11:09 <quicksilver> (if they can get away with shipping 2x/4x as much as they actually use)
05:11:14 <Jafet> Eh, which chips do that?
05:11:25 <quicksilver> what they used to call celerons, I believe.
05:11:35 <mornfall> quicksilver: Given how much die it takes, it's probably economic to do it that way (disabling parts) since you can control defects a lot better.
05:11:44 <Jafet> Also, it makes more sense if you take binning into account, like what they do a lot with GPU chips
05:11:52 <quicksilver> true, there is that.
05:12:26 <quicksilver> but I think it was more to do with marketing and market positioning than it was about defect control.
05:12:38 <quicksilver> I bet a large proportion of celerons had perfectly working cache areas disabled.
05:13:29 <mornfall> It would also be interesting to know how much of the actual heat output of the CPU comes from cache.
05:13:38 <quicksilver> hmm good point.
05:13:45 <quicksilver> I seem to remember reading, quite a lot of it does.
05:16:48 <mornfall> http://igoro.com/archive/gallery-of-processor-cache-effects/ -- especially the second graph shows why you want your data to be compact if possible...
05:18:16 <quicksilver> well, in a way.
05:18:20 <mornfall> Fitting your working set into L2 can make a *lot* of difference.
05:18:37 <quicksilver> alternatively, you can argue that it means you don't need to care about data compactness at all, as long as it fits in L2.
05:18:46 <quicksilver> so, not "as compact as possible""
05:19:02 <mornfall> Well, assuming the traditional theory where you scale to the input.
05:19:42 <mornfall> If you take n booleans and use a single bit for each, you can go "fast" for input sizes 64 times bigger than with using a word per boolean.
05:25:20 <quicksilver> mornfall: sure, that makes sense.
05:25:32 <quicksilver> mornfall: plenty of real world problems have fixed size input, though.
05:25:49 <quicksilver> mornfall: but if you're designing a library which, typicaly, will have inherently variable sized input, then yes.
05:25:58 <quicksilver> optimising a library is quite different from optimising an app.
05:26:06 <mornfall> Depending on the app, though.
05:26:29 <mornfall> I can't think of an app that I'd write recently which would work with fixed (size) inputs.
05:27:22 <mornfall> Version control and model checking probably aren't very typical apps, though.
05:29:21 <Jafet> What's a typical app?
05:29:26 <mornfall> I wish I knew. :)
05:29:33 <mornfall> A game, maybe.
05:29:48 <Jafet> Badum tish
05:29:50 <mornfall> But even then, level data come as a variable size input.
05:30:09 <Jafet> The complexity remains constant, though
05:30:23 <mornfall> Complexity of what?
05:31:01 <Jafet> They're just more and more redundant polyhedral approximations.
05:31:34 <mornfall> Whatever. :)
05:39:57 <lars9> in case..of.. expression, how to match multi patterns? such as case x of{Just 1 or Just 2 -> ...}
05:41:07 <DevHC> is there a difference between the following definitions?
05:41:10 <DevHC> uncurry f p = f (fst a) (fst b)
05:41:13 <DevHC> uncurry f ~(a,b) = f a b
05:41:26 <DevHC> and this one?
05:41:28 <DevHC> uncurry f (a,b) = f a b
05:41:36 <Jafet> lars9: Just x | x == 1 || x == 2
05:42:48 <Jafet> DevHC: well, the first one looks wrong; the second and third have different strictness
05:43:03 <DevHC> @src uncurry
05:43:04 <lambdabot> uncurry f p = f (fst p) (snd p)
05:43:05 <DevHC> WRONG!
05:43:21 <lars9> Jafet: thanks
05:43:56 <DevHC> so amend the first to uncurry f p = f (fst p) (snd p)
05:43:57 <Jafet> That one is equivalent to your second one.
05:43:59 <balor> Is there a command line tool for dumping the textual contents of a macid db?
05:44:36 <Jafet> Patterns in function parameters are strict by default -- they evaluate the arguments to match.
05:45:20 <DevHC> uncurry f = (\(a,b) -> f a b)
05:45:26 <DevHC> ^that one would be also strict?
05:45:51 <DevHC> uncurry f = (\~(a,b) -> f a b)
05:45:53 <Jafet> That is equally strict.
05:46:01 <DevHC> ^and that one wouldn't?
05:46:05 <Jafet> And that is equally non-strict.
05:46:32 <azaq23> > let f ~(x : xs) = xs in f [undefined, 1, 2, 3]
05:46:33 <lambdabot>   [1,2,3]
05:46:45 <azaq23> > let f (x : xs) = xs in f [undefined, 1, 2, 3]
05:46:46 <lambdabot>   [1,2,3]
05:47:43 <Bynbo7> it's only strict to WHNF
05:47:54 <DevHC> WHNF == ?
05:47:57 <Bynbo7> well, until it can tell whether the pattern has been matched
05:48:01 <Bynbo7> weak head normal form
05:48:10 <Bynbo7> basically "what constructor is that"
05:48:12 <Bynbo7> i think
05:48:21 <DevHC> as almost all other functions...
05:49:32 <Bynbo7> > let f (1:xs) = xs in f [undefined, 2, 3]
05:49:33 <lambdabot>   *Exception: Prelude.undefined
05:49:35 <DevHC> > let { strictCurry f (a,b) = f a b ; f = const 42 } in uncurry f undefined
05:49:36 <lambdabot>   42
05:49:38 <Bynbo7> > let f ~(1:xs) = xs in f [undefined, 2, 3]
05:49:39 <lambdabot>   *Exception: Prelude.undefined
05:50:30 <Bynbo7> DevHC: the definition of strictCurry isn't used at all there
05:50:34 <DevHC> > let { strictUncurry f (a,b) = f a b ; f = const 42 } in strictUncurry f undefined
05:50:35 <lambdabot>   *Exception: Prelude.undefined
05:50:39 <DevHC> now is is!
05:50:41 <Bynbo7> heh
05:50:42 <DevHC> it is*
05:51:58 <azaq23> > let { nonStrictUncurry f ~(a,b) = f a b ; f = const 42 } in nonStrictUncurry f undefined
05:51:59 <lambdabot>   42
05:52:04 <azaq23> interesting
05:52:36 <parcs> > let f (~1:xs) = xs in f [undefined, 7, 10]
05:52:38 <lambdabot>   [7,10]
05:53:19 <DevHC> how is seq defined?
05:53:19 <Bynbo7> that's what i was after
05:53:24 <Bynbo7> magic
05:53:56 <DevHC> @src seq
05:53:56 <lambdabot> Source not found. Do you think like you type?
05:54:15 <azaq23> it's a implementation primitive
05:54:36 <DevHC> i've heard it's formally defined as: seq a b = b
05:54:38 <Jafet> > let f ~1 = 1; f n = 0 in (f 1, f 2)
05:54:38 <lambdabot>   (1,1)
05:54:56 <parcs> seq is a primitive
05:55:00 <DevHC> which means?
05:55:18 <Bynbo7> which means you can't define it in haskell
05:55:20 <Jafet> seq a b = b is a valid implementation of seq in the pure subset of haskell.
05:55:44 <DevHC> so is it defined to be implementation-definable?
05:55:44 <quicksilver> that's a strange choice of words, jafet.
05:55:54 <Jafet> Okay, in the purely theoretical subset of haskell
05:56:10 <quicksilver> DevHC: No. Its semantics are clear, it just can't be written in haskell.
05:56:11 <azaq23> it's not expressable in the language itself since it relies on impure, non IO semantics, so the haskell standard says that it exists and thats it, the implementation has to provide it.
05:56:16 <quicksilver> it's not implementation defined.
05:56:32 <quicksilver> I don't understand where this idea that seq is impure is coming from.
05:56:50 <DevHC> my point is:
05:56:55 <quicksilver> seq a b = "_|_ if a is _|_, otherwise b"
05:57:07 <quicksilver> that's perfectly referentially transparent and pure.
05:57:11 <jonkri> any idea why this program blocks at "contents <-..."? it should get a reply from the xmpp server... http://paste.pocoo.org/show/323240/
05:57:19 <quicksilver> it's just not something you can implement in haskell.
05:57:32 <quicksilver> jonkri: yes. Never use hGetContents on a socket.
05:57:43 <quicksilver> better, is never ever use hGetContents on anything.
05:57:54 <Bynbo7> hGetContents doesn't really finish until it sees an EOF i believe
05:57:54 <DevHC> i've heard that it's formally definable as seq a b = b. perhaps Hugs or so defines it like that, but GHC defineds it as try-to-evaluate a and return b
05:57:54 <Jafet> quicksilver: ah, forgot that
05:58:10 <DevHC> so if that's true, then it's a difference between semantics of seq
05:58:14 <quicksilver> DevHC: No. It is not definable as seq a b = b.
05:58:24 <quicksilver> seq a b = "_|_ if a is _|_, otherwise b"
05:58:31 <DevHC> ok, is that stardard?
05:58:34 <quicksilver> yes.
05:58:38 <DevHC> -r+n
05:58:43 <Bynbo7> it's standard according to the standard!
05:58:47 <DevHC> [what's with the typing failures this morning? ... :o]
05:59:17 <DevHC> so supposingly hugs is non-standard?
05:59:36 <DevHC> > 1/0
05:59:37 <lambdabot>   Infinity
05:59:40 <quicksilver> DevHC: as far as I know, hugs has a correct implementaiton of seq.
05:59:49 <quicksilver> DevHC: do you have a reason to believe its implementation of seq is broken?
06:00:05 <quicksilver> I should say that, as far as I can remember I've never used hugs. But if seq didn't work that would be quite a problem.
06:00:22 <DevHC> yes as someone told me taht seq is formally definable as seq a b = b
06:00:26 <DevHC> but now i gather that was wrong
06:00:32 <DevHC> furthermore i have never tested hugs
06:00:42 <jonkri> quicksilver: it doesn't say anything in the api about blocking, does it? http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString
06:00:46 <mux> that's correct denotationally, but not operationally, as far as I can see
06:00:52 <DevHC> or any other compiler other than ghci (or lambdabot) for that matter
06:01:28 <Bynbo7> jonkri: it's waiting for all the input to to be available
06:01:36 <jonkri> aha ok
06:01:57 <ray> it's not correct at all otherwise seq would be flip const and there would be no point to it
06:02:07 <Bynbo7> which, being a socket, could mean it's waiting for a long time (possibly 5 minutes when the sockets times out :P)
06:02:10 <DevHC> well basically i can write seq for a lot of types (for which i have constructors):
06:02:13 <DevHC> seq [] b = b
06:02:33 <DevHC> seq (x:xs) b = b
06:02:49 <_pa_> Er.. lambabot thinks that 1/0 is Infinity?
06:02:57 <DevHC> voila, strict in its first argument, matches the constructor, returns b at all times.
06:03:04 <quicksilver> DevHC: yes, that's correct.
06:03:07 <DevHC> > 1 / 0 :: Integer
06:03:08 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Type.Integer)
06:03:09 <parcs> _pa_: ghc does
06:03:09 <lambdabot>    arising f...
06:03:18 <_pa_> parcs: right
06:03:20 <DevHC> > 1 `div` 0
06:03:21 <lambdabot>   *Exception: divide by zero
06:03:28 <quicksilver> DevHC: you can't write it for functions though.
06:03:34 <_pa_> Infinity is wrong. 
06:03:38 <ray> if you have bang patterns you can write seq but then you are begging the question
06:03:40 <_pa_> +/- Infinity possibly
06:03:43 <quicksilver> _pa_: Infinity is IEEE floating point.
06:03:51 * hackagebot hslogger 1.1.1 - Versatile logging framework  http://hackage.haskell.org/package/hslogger-1.1.1 (JohnGoerzen)
06:04:06 <_pa_> I see
06:04:08 <Bynbo7> > (-1)/0
06:04:09 <lambdabot>   -Infinity
06:04:14 <Jafet> :t 1/0
06:04:15 <lambdabot> forall t. (Fractional t) => t
06:04:22 <DevHC> in fact i can write deepSeq in a similar fashion
06:04:23 <ray> what you are witnessing is haskell's type system being awesome and finding the type where 1/0 works
06:04:27 <Jafet> > 1/0 :: Ratio
06:04:28 <lambdabot>   Expecting an ordinary type, but found a type of kind * -> *
06:04:34 <Jafet> > 1/0 :: Rational
06:04:34 <lambdabot>   *Exception: Ratio.%: zero denominator
06:04:43 <quicksilver> ray: no, not really.
06:04:50 <quicksilver> ray: what you're witness is defaulting to Double.
06:05:00 <quicksilver> which is a pretty simple-minded hack to reduce the number of type annotations.
06:05:01 <ray> oh that's too bad
06:05:36 <quicksilver> DevHC: right; and deepseq is defined by a typeclass and is written in *precisely* that fashion.
06:05:46 <quicksilver> DevHC: (i.e. with cases for each type)
06:05:51 <_pa_> -1/0 -> -Infinity is just retarded =)
06:06:00 <quicksilver> not really.
06:06:06 <_pa_> What about 1/-0 ?
06:06:09 <quicksilver> it's a consistent system of arithmetic.
06:06:09 <Jafet> You don't have to use Double at all, if you don't want to.
06:06:14 <Bynbo7> > 1/(-0)
06:06:15 <lambdabot>   -Infinity
06:06:23 <Jafet> Or, more likely, don't know how to.
06:06:24 <_pa_> There's no -0 
06:06:28 <_pa_> Nor +0
06:06:30 <ray> it is not really one of the more annoying things about floats
06:06:32 <Bynbo7> there is in IEEE
06:06:33 <quicksilver> _pa_: again, there is in IEEE floating point.
06:06:41 <_pa_> Sure
06:06:42 <DevHC> so the theory behind "seq a b = b" is to leave haskell pure by making seq a simple "compiler hint" (the programmer may spray the code with seq at critical points), which doesn't influence outcome semantics, but may influence performance. but unfortunately that's not the case?
06:06:46 <ray> the annoying things are binary rounding errors
06:06:50 <_pa_> And in Haskell if you will
06:06:56 <_pa_> But not in math
06:07:01 <Bynbo7> what's with all these people who've never seen how IEE754 works before?
06:07:05 <ray> yeah but it does actually screw up the semantics if you do that
06:07:06 <Jafet> DevHC: it does influence semantics, as stated above.
06:07:06 <quicksilver> _pa_: of course it exists in math.
06:07:13 <_pa_> -Infinity exists in math
06:07:20 <_pa_> but division by zero has an undefined result
06:07:33 <quicksilver> _pa_: R u {-0,-Inf,+Inf} is a perfectly respectable piece of mathematics
06:07:37 <ray> you can define it if you want
06:07:41 <quicksilver> it has some useful properties you can reason about
06:07:45 <DevHC> infitesimal also exist in math :P
06:07:46 <quicksilver> like being closed under division.
06:07:59 <quicksilver> it's not a very widely used standard system, true.
06:08:06 <Jafet> Well, IEEE floating point is not a nice algebraic structure by any measure
06:08:16 <_pa_> What is -0 supposed to mean though? 0 but approached "from left to right" ? =)
06:08:18 <ray> if you add a single point to the reals it becomes compact
06:08:28 <Bynbo7> we use Double because the hardware has excellent support for it
06:08:31 <azaq23> @google extended real line
06:08:36 <lambdabot> http://en.wikipedia.org/wiki/Extended_real_number_line
06:08:37 <lambdabot> Title: Extended real number line - Wikipedia, the free encyclopedia
06:08:44 <ray> FPUs are what, 80s technology?
06:08:55 <quicksilver> _pa_: well, it's there to keep the system consistent.
06:09:03 <melba> computers are what, 60s technology?
06:09:03 <quicksilver> it makes certain algebraic identities hold.
06:09:10 <Jafet> _pa_: http://dlc.sun.com/pdf/800-7895/800-7895.pdf
06:09:17 <ray> if you only add one point at infinity you shouldn't need -0
06:09:18 <quicksilver> it's not a generally, widely, used mathematical concept but it does have its reasons for existing.
06:09:19 <Jafet> I suggest reading it.
06:09:35 <quicksilver> ray: right. but then you don't get to distinguish +Inf and -Inf, so you lose total ordering.
06:09:43 <quicksilver> ray: (a circle is not totally ordered)
06:09:48 <_pa_> Jafet: I think you missunderstand my point. I know that floating point arithmetics on computers is full of weird things that we all must know about
06:09:58 <Jafet> That's the projective real numbers.
06:10:08 <ray> true, a circle is not totally ordered
06:10:08 <quicksilver> the R u {-0,-Inf,+Inf} construction is motivated by closing under division and keeping total ordering.
06:10:20 <Bynbo7> Jafet: damn, i wish i had that yesterday when _AB_ was here whinging about this:
06:10:27 <quicksilver> there might be more motivations lurking in IEEE, but that's the general idea.
06:10:29 <Bynbo7> > [1.0,1.1..2.0]
06:10:30 <lambdabot>   [1.0,1.1,1.2000000000000002,1.3000000000000003,1.4000000000000004,1.5000000...
06:10:40 <Jafet> _pa_: you don't have to know a thing about them, if you won't be using them.
06:10:43 <_pa_> Bynbo7: I am well aware of this
06:10:50 <_pa_> Jafet: sure
06:10:53 <Bynbo7> oh, you're the same person?
06:11:00 <Jafet> So don't use them, and be happy.
06:11:06 <_pa_> Bynbo7: Hm? Same as?
06:12:13 <Bynbo7> AB_ yesterday, i guess not
06:12:18 <_pa_> No
06:12:23 <ray> ieeeeeee also adds NaNs
06:12:23 <_pa_> But regarding the extended real line
06:12:26 <mux> ok
06:12:32 <Bynbo7> excellent, I can like you again :P
06:12:32 <mux> woops, sorry.
06:12:35 <_pa_> What you end up with then is that N/0 is +/- Infinity
06:12:57 <lars9> @src permunate
06:12:57 <lambdabot> Source not found. Maybe if you used more than just two fingers...
06:12:59 <_pa_> 0 can't have sign and N can have either sign. 0 is still 0
06:13:04 <ray> and n/-0 is -/+ infinity
06:13:06 <lars9> @src permutate
06:13:07 <lambdabot> Source not found. Just what do you think you're doing Dave?
06:13:10 <_pa_> ray: sure
06:13:14 <lars9> @src permutations
06:13:14 <lambdabot> Source not found. Are you on drugs?
06:13:18 <_pa_> ray: although I'm not buying -0
06:13:28 <ray> it's not for sale
06:13:33 <_pa_> Haha
06:13:38 <_pa_> How much would you sell it for otherwise? =)
06:13:59 <Bynbo7> > -0 :: Double
06:14:00 <lambdabot>   -0.0
06:14:09 <Jafet> Some integer encodings have -0, too.
06:14:09 <Bynbo7> > (-0 :: Double) == 0
06:14:10 <lambdabot>   True
06:14:34 <ray> yeah if you just use a sin bit
06:14:36 <ray> sign bit
06:14:42 <_pa_> http://en.wikipedia.org/wiki/Division_by_zero
06:14:47 * sipa likes sin bits
06:14:56 <ray> two's complement gives you back the extra one element in your range
06:15:07 <_pa_> I know that wikipedia hardly constitutes the dog's bollocks when it comes to reliability
06:15:14 <Jafet> At the expense of breaking abs.
06:15:18 <_pa_> But that entry says: "Also, the fraction 1/0 is left undefined in the extended real line,"
06:15:47 <Bynbo7> sure, but this is IEE754, not the lala land of maths :)
06:15:50 <Jafet> That just means they extended the real line differently.
06:16:14 <_pa_> Jafet: would you like to point out where -0 is? 
06:16:21 <_pa_> Jafet: on the line that is
06:16:36 <Bynbo7> exactly the same place 0 is
06:16:38 <_pa_> What do I substract from 0 to reach -0 ?
06:16:47 <Bynbo7> 0
06:16:48 <ray> wikipedia didn't have -0 so they couldn't decide whether 1/0 was +inf or -inf
06:17:03 <ray> ieeeeeeeee does
06:17:08 <quicksilver> I'm not really sure the point of these questions, _pa_ ?
06:17:29 <ray> and there are some things still left undefined which ieeeeee defines as NaN
06:17:29 <_pa_> I just pointed out that 1/0 being listed as Infinity is ... weird
06:17:34 <quicksilver> the system is mathematically plausible, it has some advantages (it closes one operation and completes some theorems)
06:17:40 <quicksilver> there are lots of other similar systesm
06:17:40 <_pa_> It's weird that IEEE defines it
06:17:44 <quicksilver> with other tradeoffs.
06:17:45 <ray> > Infinity / Infinity
06:17:47 <lambdabot>   Not in scope: data constructor `Infinity'Not in scope: data constructor `In...
06:17:55 <ray> oops Infinity isn't real i forgot
06:17:57 <parcs> > (1/0)/(1/0)
06:17:59 <lambdabot>   NaN
06:18:00 <quicksilver> if you want to search for the IEEE motivation, I don't think anyone in this room was on that committee.
06:18:10 <Jafet> _pa_: in other words, you are saying that IEEE is weird. That's a household fact, and not worth discussing here.
06:18:20 <_pa_> quicksilver: I am not holding anyone in here responsible for anything
06:18:21 <Bynbo7> quicksilver: heh, unlike a lot of other commitees
06:18:26 <Jafet> Well, IEEE floating point. But IEEE is also weird
06:18:28 <_pa_> Jafet: haha =)
06:18:30 <Bynbo7> tt*
06:20:40 <Jafet> I would like Infinity to be an actual constructor of Double
06:20:44 <Jafet> And NaN, too
06:22:19 <Bynbo7> > read "Infinity" :: Double
06:22:20 <lambdabot>   Infinity
06:22:21 <Jafet> Hm well, then it couldn't be a constructor for Float
06:22:23 <quicksilver> Jafet: the reason it's not, is that the haskell standard permits implementations of Double which do not have Infinity.
06:22:30 <Bynbo7> > read "NaN" :: Double
06:22:31 <lambdabot>   NaN
06:22:31 <quicksilver> Jafet: I agree that's a bit sucky.
06:22:43 <Bynbo7> > read "NaN" :: Float
06:22:44 <lambdabot>   NaN
06:22:58 <Jafet> Or LongDouble
06:23:08 <mm_freak> perhaps somewhat offtopic, but i found that changing your editor's color scheme from time to time makes you more productive
06:23:20 <Bynbo7> yeah?
06:23:51 <Jafet> Where you are me, or you?
06:23:51 <mm_freak> i just switched from a black background scheme in emacs to the default white background scheme, and it feels fresh, so coding is more fun
06:24:04 <mm_freak> Jafet: me (at least)
06:24:18 <Jafet> And we are all together
06:27:36 <Jafet> Would Richard Hamming change his editor every seven years, then
06:33:08 <jonkri> quicksilver: "ByteStream.hGet handle 1" seems to block too
06:35:27 <jonkri> ah, getSome!
06:35:51 <mm_freak> > change editor from vim to emacs
06:35:53 <lambdabot>   "you are now well productive"
06:36:11 <mm_freak> > change editor from emacs to other
06:36:13 <lambdabot>   "you are now well productive"
06:36:19 <mm_freak> uhm
06:36:38 <mm_freak> ok, screw it
06:36:40 <mm_freak> @undef
06:44:08 <edwardk> @tell sbahra pong
06:44:08 <lambdabot> Consider it noted.
06:50:58 <brbr> hello
06:51:17 <brbr> where can I learn about how the haskell runtime manages memory ?
06:51:47 <edwardk> brbr: well, the rts commentary on haskell.org is a pretty good start, but how much detail are you looking for?
06:52:59 <brbr> edwardk: I want to understand how haskell determines what is dynamically allocated when a program runs
06:53:02 <edwardk> hrmm. i appear to have forgotten to include something like diff = Endo . (<>) — in my semigroups package, to let me manipulate difference lists of a semigroup as a monoid.
06:53:43 <quicksilver> brbr: memory is allocated for data constructors, and for closures.
06:53:46 <Bynbo7> edwardk: darn it, i hate it when i do that!
06:53:58 <quicksilver> both of those are garbage collected when no longer needed.
06:53:59 <brbr> edwardk: info about the haskell runtime gc... and why and when something is gc'd
06:54:11 <edwardk> brbr: well, in this sense you're going to need to focus on one particular haskell implementation, since the details vary wildly. i'd say ghc is a pretty good example of the state of the art.
06:55:01 <edwardk> Bynbo7: its actually a very useful monoid =) makes writing my semigroup foldables, etc. a lot easier. find the base case and then work as normal.
06:55:01 <mm_freak> brbr: i think trying real code examples is better than studying documentation in this case
06:55:03 <brbr> edwardk: anything written (besides code) on how memory is allocated for closures (that's what I'm most interested in)
06:55:11 <edwardk> yes one sec
06:55:30 <mm_freak> brbr: create a test program, which includes the cases you are interested in and run it through the profiler
06:55:44 <edwardk> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts
06:56:04 <edwardk> ^— that is terribly technical and written for an inside audience but covers everything you could need to know
06:56:20 <brbr> edwardk: awesome. thanks
06:57:08 <quicksilver> brbr: SPJ's book / papers on the spineless tagless G-machine talk about closure allocation in, as I recall, quite some detail.
06:57:33 <quicksilver> brbr: some of the details are no longer accurate for modern GHC but the book still has a good integrated picture and discusses some of the choices.
06:58:19 <quicksilver> book : http://research.microsoft.com/en-us/um/people/simonpj/papers/pj-lester-book/ ; paper linked at top of : http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/StgSynType
06:59:57 <brbr> has anybody done any work with haskell regarding region-based mm?
07:00:07 <quicksilver> yes.
07:00:22 <quicksilver> JHC used to use exlusively region-based but no longer does.
07:00:39 <brbr> why?
07:00:41 <brbr> references?
07:00:51 <brbr> references, plz :)
07:01:03 <cgomez> hello haskellers
07:01:07 <Bynbo7> google is full of references brbr ;)
07:01:24 <Bynbo7> g'day haskeller cgomez 
07:01:48 <quicksilver> brbr: well, oleg's paper is a start and might provide its own references to follow : http://lambda-the-ultimate.org/node/2926
07:01:57 <edwardk> brbr: yes
07:02:08 <edwardk> brbr: in general it fails fairly miserably
07:02:31 <edwardk> brbr: the lifetime of lazy closures doesn't play very nicely with the expectations of a region based memory manager
07:03:13 <edwardk> brbr: you'll have to google for mailing list posts by john meacham regarding region based memory allocation in JHC.
07:03:42 <quicksilver> yeah, john meacham doesn't write papers. As far as I know.
07:05:23 <edwardk> brbr: you may also want to find the 15 year region retrospective paper by mads tofte which goes into where regions fall short
07:05:49 <edwardk> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.64.160
07:05:54 <cgomez> I've got this error "Perhaps you haven't installed the profiling libraries for package `wx-0.12.1.6'?". What can I do?
07:06:23 <Bynbo7> cabal install wx -p
07:06:43 <Bynbo7> or better yet, set your cabal config to install profiling libraries by default
07:07:02 <edwardk> that really just needs to become the default =/
07:07:17 <cgomez> thanks Bynbo7
07:07:24 <Bynbo7> edwardk: aye :\
07:08:06 * hackagebot semigroups 0.3.4 - Haskell 98 semigroups  http://hackage.haskell.org/package/semigroups-0.3.4 (EdwardKmett)
07:12:30 <edwardk> ok, 'diff' added
07:12:58 <edwardk> i was all set to make a new newtype and everything, but since its just Endo, meh
07:14:52 <rocksteady> is there a way to make this code more compact? http://pastebin.com/5bvMUhWs
07:16:02 <djahandarie> A newtype with the same instances does seem pretty useless, though I imagine it's useful when you're just trying to differentiate between data (Int and Cash, etc)
07:16:05 <Bynbo7> looks pretty compact to me
07:16:13 <rocksteady> okay
07:16:21 <Bynbo7> rocksteady: you could replace otherwise with True if you wanted...
07:16:24 <Bynbo7> but, that's ugly
07:16:30 <rocksteady> okay
07:16:36 <Bynbo7> especially since otherwise is defines a True ;)
07:16:42 <rocksteady> ah ^^
07:16:48 <quicksilver> personally I'd make it less compact
07:16:56 <quicksilver> by adding a few spaces to line up the = signs ;)
07:17:08 <djahandarie> I don't line up = signs usually
07:17:18 <djahandarie> Mainly because I hate dealing with that later
07:17:29 <quicksilver> your editor should do that for you.
07:18:51 <Bynbo7> hey, i never knew textmate sould do that, how handeh :)
07:18:58 <djahandarie> C-x M-c M-line-up-equal-signs ?
07:22:44 <frustrated> 02Hello everybody
07:22:56 <j-invariant> hi
07:23:22 <frustrated> 02do you know if there is a function that translates a string into ascii?
07:23:29 <j-invariant> yes  map ord
07:23:48 <frustrated> 02tnx, i'll try that one, brb
07:24:27 <Zao> frustrated: You seem to be sending text in odd colour.
07:24:47 <byorgey> I didn't even know you could do that.
07:24:48 <frustrated> 02isn't that allowed?:P
07:24:55 <Zao> frustrated: It's very hard to read.
07:25:01 <Zao> And/or jarring.
07:25:12 <frustrated> sorry
07:25:40 <Zao> frustrated: It helps if your questions can be properly read in the first place, that's all :)
07:25:58 <IanCal> I'm interested in using SBV to prove implementations of functions match some reference (like here: http://hackage.haskell.org/packages/archive/sbv/0.9.7/doc/html/src/Data-SBV-Examples-BitPrecise-BitTricks.html#fastMinCorrect). I've got these examples working but wondered if theres a way of testing functions that use Int32 instead of SInt32
07:26:04 <Zao> Note that it's not completely "into ascii", as a Char can hold any unicode codepoint, not just the ones in 0-127.
07:26:08 <kuffaar> I have no idea what "string into ASCII" is even supposed to mean
07:26:15 <frustrated> Yes indeed, because i have a white background it didn't bother me, that why
07:26:33 <j-invariant> kuffaar: ASCII is an encoding
07:26:49 <Zao> ord gives you an integer that corresponds to the codepoint ordinal of the character.
07:27:02 <frustrated> It doesn't has to, wat I want is to translate something like "haskell" into something like 112412354
07:27:15 <Zao> ASCII codepoints 0-127 are unicode codepoints 0-127.
07:27:20 <frustrated> what*
07:27:27 <Zao> latin-1 codepoints 0-255 are unicode codepoints 0-255.
07:27:39 <byorgey> > map ord "haskell"
07:27:40 <lambdabot>   [104,97,115,107,101,108,108]
07:27:53 <Zao> frustrated: You've got to specify more closer what you mean by "into ASCII", and "ASCII".
07:27:56 <byorgey> > concat . map show . map ord $ "haskell"
07:27:58 <lambdabot>   "10497115107101108108"
07:28:31 <frustrated> byorgey is it possible to translate that back into "haskell?:P
07:28:42 <byorgey> not very easily =)
07:28:45 <kuffaar> byorgey hahaha
07:29:00 <kuffaar> byorgey why the $ ?
07:29:05 <j-invariant> frustrated: have you tried what I said?
07:29:25 <frustrated> j-invariant yes, but i'm getting a list of ASCII code
07:29:26 <byorgey> kuffaar: as opposed to what?
07:29:29 <djahandarie> > concatMap (show . ord) "Haskell"
07:29:31 <j-invariant> "but"?
07:29:31 <lambdabot>   "7297115107101108108"
07:29:35 <byorgey> > (concat . map show . map ord) "haskell"
07:29:37 <lambdabot>   "10497115107101108108"
07:29:53 <frustrated> i want something like this: "7297115107101108108"
07:30:04 <byorgey> kuffaar: if is the same as what I just typed, but avoids the parentheses
07:30:10 <j-invariant> what for?
07:30:16 <frustrated> and i also want to translate it back into a string
07:30:26 <frustrated> I have to store it in an simple stack machine
07:30:37 <frustrated> and simple stack machine only knows integer values
07:30:46 <djahandarie> frustrated, how do you know whether it is 72 97 or 7 29 7?
07:30:54 <byorgey> hmm, maybe you want:
07:30:59 <j-invariant> frustrated: how is a list of ascii codes not integer values?
07:31:11 <Zao> map ord over the string, and push each element onto your stack.
07:31:24 <Zao> Preferably with a sentinel or length so you know how long it is.
07:31:26 <frustrated> j-invariant it is integers values, but i want an integer value:P
07:31:33 <byorgey> > foldl' (\n r -> 256*n + r) 0 . map ord $ "haskell"
07:31:35 <lambdabot>   29380545928850540
07:31:40 <Zao> How large are your stack integers?
07:31:47 <j-invariant> frustrated: that's not ASCII
07:31:57 <Bynbo7> > maxBound :: Char
07:31:59 <lambdabot>   '\1114111'
07:31:59 <Zao> After all, don't forget that Char can hold codepoints way outside 0-127.
07:32:07 <Bynbo7> > ord (maxBound :: Char)
07:32:09 <lambdabot>   1114111
07:32:13 <Bynbo7> duh -_-
07:32:36 <byorgey> > '\101'
07:32:37 <lambdabot>   'e'
07:32:52 <frustrated> concat . map ord $ "haskell"
07:33:09 <frustrated> how dit you do that Bynbo7?
07:33:23 <Bynbo7> > foldl' (\x r -> 1114111*n + ord r) '\0' "Haslell" 
07:33:24 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
07:33:24 <lambdabot>         against inferred ...
07:33:31 <Bynbo7> > foldl' (\n r -> 1114111*n + ord r) '\0' "Haslell" 
07:33:32 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
07:33:32 <lambdabot>         against inferred type ...
07:33:40 <Bynbo7> :t foldl
07:33:41 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
07:33:51 <Bynbo7> > foldl' (\n r -> 1114111*n + ord r) 0 "Haslell" 
07:33:52 <lambdabot>   6966095972166205523
07:36:10 <byorgey> > map toEnum . unfoldr (\n -> if n == 0 then Nothing else Just (n `mod` 1114111, n `div` 1114111)) $ 6966095972166205523 :: String
07:36:12 <lambdabot>   "\804834\125487\41637\ENQ"
07:36:18 <Bynbo7> > unfoldl (\x -> case divMod x 1114111 of (n,x') | n == 0 = Nothing; otherwise = Just (ord $ fromIntegral x',n)) 6966095972166205523
07:36:19 <lambdabot>   <no location info>: parse error on input `='
07:36:21 <byorgey> hrm
07:36:30 <Bynbo7> > unfoldl (\x -> case divMod x 1114111 of (n,x') | n == 0 = Nothing | otherwise = Just (ord $ fromIntegral x',n)) 6966095972166205523
07:36:32 <lambdabot>   <no location info>: parse error on input `='
07:36:44 <Bynbo7> > unfoldl (\x -> case divMod x 1114111 of (n,x') | n == 0 -> Nothing | otherwise -> Just (ord $ fromIntegral x',n)) 6966095972166205523
07:36:45 <lambdabot>   Not in scope: `unfoldl'
07:36:57 <Bynbo7> > unfoldr (\x -> case divMod x 1114111 of (n,x') | n == 0 -> Nothing | otherwise -> Just (ord $ fromIntegral x',n)) 6966095972166205523
07:36:58 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
07:36:58 <lambdabot>    arising from a use of `GHC....
07:37:02 <Bynbo7> -_-
07:37:09 <Bynbo7> > unfoldr (\x -> case divMod x 1114111 of (n,x') | n == 0 -> Nothing | otherwise -> Just (chr $ fromIntegral x',n)) 6966095972166205523
07:37:10 <lambdabot>   "\804834\125487\41637"
07:37:17 <Bynbo7> yeah, not at all right, haha
07:37:26 <byorgey> you got the same thing I did =)
07:37:35 <Bynbo7> > foldl' (\n r -> 1114111*n + fromIntegral (ord r)) 0 "Haslell" 
07:37:36 <lambdabot>   137690442212046453005221572080798990419
07:37:43 <byorgey> hahaha, whoops
07:37:48 <Bynbo7> > unfoldr (\x -> case divMod x 1114111 of (n,x') | n == 0 -> Nothing | otherwise -> Just (chr $ fromIntegral x',n)) 137690442212046453005221572080798990419
07:37:49 <lambdabot>   "llelsa"
07:37:54 <byorgey> > map toEnum . unfoldr (\n -> if n == 0 then Nothing else Just (n `mod` 1114111, n `div` 1114111)) $ 137690442212046453005221572080798990419 :: String
07:37:56 <lambdabot>   "\804834\125487\41637\ENQ"
07:38:01 <Bynbo7> that's... close?
07:38:12 <byorgey> yes, it's backwards and you're missing the H
07:38:20 <Bynbo7> yeah
07:38:33 <Bynbo7> > foldl' (\n r -> 1114111*n + fromIntegral (ord r)) 0 "Haskell" 
07:38:35 <lambdabot>   137690442212046453003838689243952840788
07:38:58 <Bynbo7> > unfoldr (\x -> case divMod x 1114111 of (n,x') | n == 0 -> Nothing | otherwise -> Just (chr $ fromIntegral x',n)) 137690442212046453003838689243952840788
07:39:00 <lambdabot>   "lleksa"
07:39:01 <byorgey> Bynbo7: you're missing the H because if divMod gives you 0 you return Nothing, but x' in that case will be the final letter
07:39:06 <Bynbo7> yeah
07:39:13 <Bynbo7> not sure how to get around that easily
07:39:48 <byorgey> > map toEnum . unfoldr (\n -> if n == 0 then Nothing else Just (n `mod` 1114111, n `div` 1114111)) $ (137690442212046453005221572080798990419 :: Integer) :: String
07:39:50 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
07:39:50 <lambdabot>         against inferred type ...
07:40:43 <byorgey> > map (chr . fromIntegral) . unfoldr (\n -> if n == 0 then Nothing else Just (n `mod` 1114111, n `div` 1114111)) $ 137690442212046453005221572080798990419
07:40:45 <lambdabot>   "llelsaH"
07:41:06 <byorgey> > reverse . map (chr . fromIntegral) . unfoldr (\n -> if n == 0 then Nothing else Just (n `mod` 1114111, n `div` 1114111)) $ 137690442212046453003838689243952840788
07:41:08 <lambdabot>   "Haskell"
07:41:10 <byorgey> =D
07:41:11 <Bynbo7> i wonder how efficient that representation is
07:41:15 <Bynbo7> hoorah!
07:41:17 <byorgey> not very
07:41:27 <Bynbo7> well, more efficient that String :P
07:41:30 <Bynbo7> than*
07:41:58 <Bynbo7> i think it's possible it uses less than two bytes per character
07:42:06 <Bynbo7> > 256^2
07:42:08 <lambdabot>   65536
07:42:14 <Bynbo7> maybe less than three
07:42:17 <Bynbo7> > 256^3
07:42:18 <lambdabot>   16777216
07:42:27 <Bynbo7> > 256^3 > 1114111
07:42:28 <lambdabot>   True
07:43:51 <byorgey> > reverse . map (chr . fromIntegral) . unfoldr (\n -> snd &&& fst (n `divMod` 1114111) <$ guard (n /= 0)) $ 137690442212046453003838689243952840788
07:43:53 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe (a, a1)'
07:43:53 <lambdabot>         against inf...
07:44:04 <byorgey> > reverse . map (chr . fromIntegral) . unfoldr (\n -> (snd &&& fst) (n `divMod` 1114111) <$ guard (n /= 0)) $ 137690442212046453003838689243952840788
07:44:06 <lambdabot>   "Haskell"
07:44:31 <lunaris> Couldn't resist: here's a hacked up "reverse ord", as requested by frustrated ages ago. Sorry if this has already happened; I've just been hacking.
07:44:34 <lunaris> Bbiab.
07:44:34 <lunaris> 
07:44:38 <lunaris> http://pastebin.com/NgSTwkr7
07:44:41 <lunaris> (Btw)
07:45:57 <Bynbo7> isn't that unfoldr basically map?
07:46:08 <Bynbo7> or not
08:04:00 <dpratt71> the subject of Clean came up again yesterday, and it got me wondering about its oft-mentioned feature of "uniqueness typing". Is that as relevant as it once was? It seems that Haskell models IO just fine without such a construct.
08:05:58 <j-invariant> dpratt71: it is subsumed
08:07:31 <dpratt71> j-invariant: I'm not sure I know what you mean (in fact I'm quite sure I don't)
08:08:07 <j-invariant> monads are better
08:08:44 <dpratt71> j-invariant: yes, that was my impression
08:09:05 <Bynbo7> from what i've seen of uniquiness types, they seems to be an explicit way of doing exactly what the IO monad currently does in GHC (or pretends to)
08:09:37 <Bynbo7> dpratt71: was this perhaps brought on by the array performance post on reddit?
08:09:56 <dpratt71> Bynbo7: not sure; I didn't catch that post
08:10:12 <dpratt71> my impression is that in Haskell you almost need the Monad, but you want the Monad regardless
08:10:14 <Bynbo7> http://www.reddit.com/r/programming/comments/f3woa/a_low_level_performance_comparison_of_simple/
08:11:03 <quicksilver> dpratt71: in principle uniqueness types give you a framework in which you can program as if your data is pure immutable, but actually use mutation behind the scenes if the value is only used once.
08:11:20 <Bynbo7> if you look at the clean example on there, you'll notice that the code actually looks quite a lot like the low level IO and ST code you see in GHC
08:11:23 <quicksilver> in practice, I don't think the clean compiler actually does that optimisation anyway.
08:11:35 <quicksilver> so basically they just use it to regulate IO side-effects.
08:11:48 <dpratt71> quicksilver: interesting
08:12:15 <EvanR-work> if were causing side effects for the purpose of causing side effects, id like the code to reflect that
08:12:19 <lars9> foldM is really hard to understand ... my understanding only lasts 5 minutes
08:12:57 <Bynbo7> i didn't understand foldM until i was told to use it, and it turned out to be pretty intuitive
08:13:01 <Bynbo7> :t foldM
08:13:02 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
08:13:25 <mightybyte> I've strange memory behavior with ghci.  I run a function that consumes a lot of memory.  It finishes, I evaluate part of the return value, that finishes and prints the value.  Then while it's just sitting at a ghci prompt, ghci crashes with an out of memory error.
08:13:31 <roconnor> given a least fixed point of a Functor F, we have A ~ F (A).  What is the usual names for the two directions of the isormophism?  fold and unfold?
08:13:31 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
08:13:32 <EvanR-work> uniqueness as an optimization of pure code is cool
08:13:33 <lars9> > foldM (:) [] [1..10]
08:13:34 <lambdabot>   No instances for (GHC.Num.Num [[a]], GHC.Enum.Enum [[a]])
08:13:35 <lambdabot>    arising from a...
08:13:53 <mightybyte> Any idea why it crashes without anything happening?
08:14:14 <Bynbo7> heh
08:14:56 <EvanR-work> mightybyte: the gc maybe?
08:15:04 <EvanR-work> didnt have enough memory 
08:15:24 <mightybyte> You mean it used more memory in the process of trying to reclaim memory?
08:15:25 <Saizan> roconnor: fold could refer to the catamorphism, i've seen in and out
08:15:54 <roconnor> Saizan: ya, I thought fold would be the catamorphism
08:15:56 <roconnor> in and out is good
08:16:46 <lars9> Bynbo7: how to use foldM to do permutation?
08:17:44 <xarch> what's a dialgebra?
08:17:46 <Bynbo7> lars9: the way i've used foldM was with an IO function, that tool a maybe filepath, a list of filepaths and returned a maybe filepath (there were log files that each consequtive call needed the previous call's log, except possibly the first)
08:18:04 <djahandarie> foldM (:) is not that intereseting
08:18:54 <Bynbo7> :t foldM (:)
08:18:56 <lambdabot> forall a. a -> [[a]] -> [a]
08:19:07 <lars9> > foldM (:) (\a b->[a,b]) 0 [1..3]
08:19:08 <lambdabot>   Couldn't match expected type `[t1] -> t'
08:19:08 <lambdabot>         against inferred type `[t2...
08:19:19 <Bynbo7> > foldM (:) 'a' $ words "Hello foo bar"
08:19:20 <lambdabot>   "abarfbarobarobarHbarfbarobarobarebarfbarobarobarlbarfbarobarobarlbarfbarob...
08:19:29 <Bynbo7> o.O
08:19:32 <lars9> > foldM (\a b->[a,b]) 0 [1..3]
08:19:33 <lambdabot>   [0,3,2,3,1,3,2,3]
08:19:38 <Bynbo7> > foldM (:) 'a' $ words "x y z"
08:19:39 <lambdabot>   "azyzxzyz"
08:20:34 <djahandarie> > foldM (:) '0' $ words "123 abc DEF"
08:20:36 <lambdabot>   "0DEFaDEFbDEFcDEF1DEFaDEFbDEFcDEF2DEFaDEFbDEFcDEF3DEFaDEFbDEFcDEF"
08:21:54 <Bynbo7> > foldM (:) 10 $ [[1],[2],[3]]
08:21:55 <lambdabot>   [10,3,2,3,1,3,2,3]
08:22:00 <Aristid-andro> :t  foldM
08:22:01 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
08:23:22 <Bynbo7> > foldM (:) 10 $ [[1,2,3]]
08:23:23 <lambdabot>   [10,1,2,3]
08:23:29 <djahandarie> It is just nesting
08:23:30 <Bynbo7> > foldM (:) 10 $ [[1,2,3],[4,5,6]]
08:23:31 <lambdabot>   [10,4,5,6,1,4,5,6,2,4,5,6,3,4,5,6]
08:27:25 <lars9> > foldM (\la lb -> map (\b->la ++ [b]) lb) [] [[1..2], [3..4], [5..6]]
08:27:27 <lambdabot>   [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
08:27:43 <lars9> easier way to do such permutation?
08:28:30 <lars9> @pl foldM (\la lb -> map (\b->la ++ [b]) lb)
08:28:30 <lambdabot> foldM (map . (. return) . (++))
08:29:02 <lars9> @pl map (\b->la ++ [b])
08:29:02 <lambdabot> map ((la ++) . return)
08:38:07 <Maxdamantus> How might one manage instances of users and channel user-lists in an IRC client .. would you make the user-list for each channel some IORef array/list/set so each user has an IORef so that you can update information (nick/host changes) without going through every channel they're on?
08:38:52 <Maxdamantus> list/array seems silly, and IORef isn't an instance of Ord so can't use a Set.
08:40:43 <Maxdamantus> Could use a set I guess if you stored each as a tuple of an integer that's unique for each user and the IORef or something, but that seems pretty nasty.
08:40:54 <Maxdamantus> (and you'd have an ever-incrementing counter)
08:41:18 <edwardk> most folks would probably use a boring structure like a Set of users, and manipulate it functionally rather than fiddle with IORefs
08:42:03 <edwardk> you're not going to die performance wise juggling a set of a few hundred strings with average length < 9 ;)
08:42:06 <Maxdamantus> But then that means as one person changes their nick, you need to go through and change each set that he might be in?
08:42:08 <Bynbo7> or an IORef with a Set in it
08:42:15 <Bynbo7> and use atomicModifyIORef
08:42:33 <Maxdamantus> (I'd ask the same thing to Bynbo7's response)
08:42:49 <Bynbo7> i'm not sure what you have multiple sets for
08:43:03 <Maxdamantus> Because there can be more than one channel.
08:43:47 <edwardk> Maxdamantus: you can only typically be logged into around 20 channels, this doesn't seem particularly daunting ;)
08:43:47 <Bynbo7> why not keep the list of channels in the set or something?
08:44:02 <Maxdamantus> If you're in two channels that I'm on and you change your nick, the server sends one NICK response to me.
08:44:19 <Bynbo7> edwardk: i've seen people who've been in 70+ channels, god knows why
08:44:54 <edwardk> bynbo7: well, there is lambdabot, but by default i think they cap you here on freenode at 20. other networks usually lack that cap
08:45:02 <Maxdamantus> edwardk: but the IORef would be useful elsewhere too.
08:45:20 <edwardk> yes, but you then now have to think imperatively about EVERYTHING that has a very high cost.
08:45:37 <Maxdamantus> edwardk: eg, then the system doesn't need some special interface for a PM that's not directly attached to a structure by the IRC system.
08:45:57 <Maxdamantus> er, query rather.
08:46:15 <Maxdamantus> ie, if someone's talking in a query and they change their nick.
08:46:27 <MHD0> I just found a misspelling in HOpenGL
08:47:02 <edwardk> typically I'd live inside StateT IO of some sort and manipulate as much of my state purely as possible. if that is that i maintain two structures, one for the channel users lists and one for the channels a user is in, and ensure that thec ombinators i'm working with maintain consistency, that strikes me as a small price to pay for not having to deal with the semantics of IOrefs everywhere
08:48:30 <ksf> ...those two lists are merely mutually recursive.
08:48:32 <Bynbo7> IORefs have some interesting semantics for concurrency if you use atomicModifyIORef
08:48:52 <ksf> no they don't, we don't have proper compare and swap.
08:48:56 <edwardk> you can avoid the IORef machinery just by just tracking in your state a supply of fresh integers, and then for each nick assign it an integer id, and update the data structure associated with the ID
08:49:03 <ksf> wait no.
08:49:15 <Bynbo7> sure we do
08:49:19 <ksf> I'm just grumpy because there's no cas on any kind of unboxed values.
08:49:23 <edwardk> ksf: you want to avoid the mutual recusion where possible
08:49:23 <Maxdamantus> edwardk: how do you assign the id?
08:49:51 <rocksteady> is it possible to look up the source code of built-in functions? want to see how logBase works internally.
08:50:00 <ksf> ...having that recursion calls for a label-based approach, yes.
08:50:01 <Maxdamantus> Does it involve trying to do your own garbage collection?
08:50:39 <edwardk> maxdamantus: work in something like StateT IRC IO — where data IRC = IRC { freshNick :: Int, nicks :: IntMap Nick, channels: Map String Channel } — or some such 
08:50:50 * Maxdamantus looks up StateT.
08:51:09 <sipa> basically IO combined with a State monad
08:51:47 <ksf> if the Int overflows, just let it overflow. looking up whether an int is already taken is cheap enough.
08:51:54 <edwardk> then allocate a nick with nick name = do i <- gets freshNick; modify $ \s -> s { freshNick = i + 1 }; return (Nick i name)
08:52:19 <ksf> ...in short, don't do what edwardk just said.
08:52:19 <edwardk> (and you probably need to inject it into the nick map
08:52:19 <djahandarie> Map Integer might be safer :)
08:52:38 <ksf> you don't need more than 2^64 keys.
08:52:39 <monochrom> atomicallyDetonate
08:52:53 <ksf> before you exhaust that you're out of memory somewhere else.
08:53:00 <edwardk> ksf: if you are worried about being online long enough to have an int overflow you have a much more optimistic view of the uptime of an IRC bot than I do ;)
08:53:20 <ksf> well, my pids actually do overflow.
08:53:32 <ksf> I think they're 16 bits, though.
08:53:35 <edwardk> yeah
08:53:50 <ksf> propably better cache-miss wise.
08:54:31 <ksf> otoh, you could hopscotch-hash the thing.
08:55:02 <edwardk> besides since haskell is an LP64 programming model, just running on a 64 bit machine gives you 64 bit ints by default. so overflow is seriously a non-issue ;)
08:55:42 <Maxdamantus> It sounds very C-ish .. but maybe IO is.
08:55:43 <edwardk> er ILP64
08:56:38 <Maxdamantus> I quite like the idea I had before .. but the only problem afaics is IORef's lack of Ord.
08:57:00 <Maxdamantus> Is there something similar to an IORef which is an instance of Ord?
08:57:17 <edwardk> nick name = do i <- gets freshNick; modify $ \s -> s { freshNick = i + 1, nicks = insert i name }; return (Nick i) — is probably better
08:57:44 <edwardk> maxdamantus: deliberately not
08:57:55 <Maxdamantus> Deliberately?
08:58:16 <edwardk> yeah
08:58:27 <ksf> ...speaking of hashes, I wanted to pwn that k-nucleotide benchmark.
08:58:33 <MHD0> I am having some problems with freeglut and HOpenGL, it doesn't really want to register freeglut, that is it won't allow me to use freeglut functions.
08:58:35 <djahandarie> Diliberately?
08:58:57 <edwardk> Because the ordering wouldn't be consistent across multiple runtimes, this is why Unique isn't an instance of Ord either.
08:59:07 <Maxdamantus> But why does that matter?
08:59:10 <djahandarie> I thought they just didn't want the performance change by storing the allocation ID in the IORef
08:59:22 <Maxdamantus> The environment provided by IO is going to differ every runtime.
08:59:29 <Maxdamantus> (is likely to)
08:59:55 <edwardk> not my argument, but it comes down to the fact that things like Unique's are often allocated via unsafePerformIO's
09:00:04 <Maxdamantus> Should `cat foo` always have the same result?
09:00:09 <edwardk> so the meaning of programs with them could change drastically from runtime to runtime
09:01:45 <jmcarthur> it's even worse than that
09:01:58 <edwardk> (this why things like the TypeReps aren't Ord'ed
09:02:13 <jmcarthur> pointer equality on IORefs would be inconsistent even in a single run of the program
09:02:19 <jmcarthur> due to the copy collector
09:02:30 <jmcarthur> err
09:02:34 <Maxdamantus> It could keep its own integer counter.
09:02:37 <edwardk> yeah well, with IORefs you can't check with pointer equality, so you'd have to allocate a tag for each
09:02:39 <jmcarthur> comparison, not equality
09:02:45 <Maxdamantus> (which would be influenced by the GC)
09:02:46 <edwardk> but then everyone pays for this feature that you want =)
09:02:58 <jmcarthur> edwardk: Eq is actually pointer equality, but it's atomic with respect to the GC i think
09:03:07 <jmcarthur> but Ord would be inconsistent
09:03:21 <edwardk> jmcarthur: *nods*
09:03:23 <jmcarthur> Maxdamantus: yeah that could slow things down
09:03:42 <jmcarthur> Maxdamantus: just wrap IORef with your own data type that has an identity, is probably your best bet
09:03:46 <edwardk> thats what i was trying to say but muddled things by using the word equality in there
09:03:48 <Maxdamantus> Which is why if it did exist it'd be a different type.
09:04:13 <djahandarie> preflex, seen FunctorSaad
09:04:13 <preflex>  Sorry, I haven't seen FunctorSaad
09:04:16 <jmcarthur> i once considered making a library for this. there may already be one by now
09:04:17 <djahandarie> preflex, seen FunctorSalad
09:04:17 <preflex>  FunctorSalad was last seen on #haskell-blah 27 days, 23 hours, 12 minutes and 48 seconds ago, saying: is it silly to use someone's full academic title for each reply? should I just start with "Hello,"? 
09:04:34 <djahandarie> Another one lost to the void... :(
09:04:45 <edwardk> Maxdamantus: also where do you get the supply of integers for that? a global supply is a bottleneck. a local supply leads to odd consistency issues where you sometimes get new id's always > than old id's except when running multithreaded, etc.
09:04:50 <Maxdamantus> I think you could almost implement it in Haskell .. except it has ksf's thing where you need to limit the paired integer, or else have it go off to infinity.
09:04:53 <jmcarthur> preflex: seen mmorrow
09:04:54 <preflex>  mmorrow was last seen on #ghc 1 year, 1 day, 14 hours, 13 minutes and 22 seconds ago, saying: * mmorrow is rtfm'ing
09:05:05 <jmcarthur> over a year now
09:05:06 <Maxdamantus> (rather than just limit, decide on some limit)
09:05:09 * Maxdamantus hates deciding limits.
09:05:39 <jmcarthur> Maxdamantus: just use Int. you won't be able to create more IORefs than Ints anyway
09:05:44 <edwardk> jmcarthur: wow, he's been gone a long time
09:05:45 <jmcarthur> or Word
09:05:51 <Maxdamantus> edwardk: you could say that the ordinality exists only for sake of sets, etc.
09:06:46 <Maxdamantus> edwardk: and tell users of it not to expect any particular order of them, but only that a > b is always true.
09:06:50 <edwardk> maxdamantus: yes, but you can see how the usage constraints have become narrower and narrower and the costs are fairly high, so by default, if you need it, roll your own
09:06:56 <Maxdamantus> er, if a > b is true, then it's always true.
09:07:02 <Maxdamantus> (well, obviously)
09:07:11 <jmcarthur> there really should be a hackage package, at least
09:07:20 <jmcarthur> i might have to make one someday
09:07:39 <edwardk> in practice i usually get by with Unique's when i need to do something like that
09:07:39 <jmcarthur> Maxdamantus: yeah that's reasonable. IORefs do, after all, originate from an IO action
09:07:53 <Maxdamantus> http://www.mail-archive.com/haskell-cafe@haskell.org/msg04593.html hmm
09:08:58 <jmcarthur> i was a little surprised when i read SPJ say that
09:09:06 <jmcarthur> i think maybe he didn't think it through
09:09:31 <jmcarthur> because IORefs are used in tight loops quite often
09:09:32 <edwardk> http://www.mail-archive.com/haskell-cafe@haskell.org/msg04615.html
09:09:45 <Maxdamantus> jmcarthur: well he does mention the performance thing.
09:09:46 <Philippa> yeah, but you don't have to place the ord part where it hurts them
09:09:46 <sshc> How should I enable the extensions that 2010 adds with GHC 7?
09:09:56 <jmcarthur> edwardk: ha! i even worded it the same
09:09:58 <Maxdamantus> jmcarthur: I think what he means is the concept is fine. It would just break performance.
09:10:02 <Philippa> it's only painful if you newref a lot in the loop
09:10:11 <Maxdamantus> nvm, didn't read the last paragraph.
09:10:24 <Philippa> or, to be fair, if you're tight enough on cache
09:10:25 <jmcarthur> Philippa: well... okay i guess you're right
09:10:32 <jmcarthur> but cache is a big deal too
09:10:53 <Philippa> how big's an IORef's heap object at the moment, anyway?
09:11:01 <jmcarthur> i wouldn't even be using IORefs in a tight loop unless i was looking for tight control over resources anyway
09:11:12 <cgomez> I reinstall all libraries I am using with the profiling option
09:11:18 <jmcarthur> probably bigger than it could be
09:11:30 <edwardk> yeah
09:11:46 <edwardk> the few IORefs that leak into my code tend to be in fairly performance-centric parts
09:11:54 <jmcarthur> i wonder if we could save some indirections by having a primitive, strict version of IORef
09:12:12 <jmcarthur> with some type family magic for unpacking or something?
09:12:15 <Philippa> an unboxed one, you mean?
09:12:19 <edwardk> for unboxed iorefs?
09:12:20 <jmcarthur> *unboxing
09:12:24 <jmcarthur> yes
09:12:24 <edwardk> aren't those Ptr's?
09:12:30 <tac-tics> Performance?? At the cost of purity????
09:12:32 <jmcarthur> Ptr requires Storable
09:12:33 <tac-tics> Blasphemy!
09:12:39 <jmcarthur> not quite the same as unboxed
09:13:17 <edwardk> i have atomic integers in reactor which i use to avoid ioref overhead
09:13:24 <jmcarthur> i'm not sure if Storable and comparable in performance to unboxed values
09:13:31 <jmcarthur> s/and/is/
09:13:37 <edwardk> https://github.com/ekmett/reactor/blob/master/Reactor/Atomic.hs
09:13:40 <Philippa> worst case we'll just end up with ordered refs as a separate type, of course
09:14:12 <edwardk> jmcarthur: well to have the ioref, ultimately you need to write the unboxed value into memory somewhere
09:14:17 <edwardk> that is what Storable _does_
09:14:31 <jmcarthur> edwardk: sure, but for some types the serialization is quite involved
09:14:31 <edwardk> unboxing just lets it live on the stack, or in data structures unboxed.
09:15:03 <jmcarthur> eh, i haven't tried benchmarking unboxed vs. storable before, so..
09:15:12 <edwardk> well, again they are different things
09:15:27 <jmcarthur> well, they apply to different types sometimes
09:15:37 <jmcarthur> and yes i see how they are different in practice too
09:15:52 <jmcarthur> but there are unboxed arrays. seems to imply there could be unboxed references
09:18:01 <edwardk> hrmm. given a mutablebytearray# can i extract a Ptr to it by pinning it somehow?
09:20:06 <edwardk> ah byteArrayContents#
09:20:23 <edwardk> but it only works with a pinned array
09:20:52 <Maxdamantus> Ah, someone mentioned some "unique" somewhere before I think .. Data.Unique looks like it might work.
09:20:54 <edwardk> safer to use a Ptr, because then I can let the GC move it
09:21:17 <edwardk> maxdamantus: note the lack of Ord, though you can use the hash and then dump them into a list inside of that
09:21:32 <Maxdamantus> (if the channel's user-list was some `Set (Unique, IORef User)
09:21:34 <Maxdamantus> `
09:21:50 <edwardk> oh wait
09:21:51 <edwardk> those are Ord
09:21:54 <Maxdamantus> Ord Unique
09:21:55 <edwardk> the StableNames are not
09:22:06 <edwardk> thats why i was confused. i used to use both in the same package
09:22:34 <edwardk> http://hackage.haskell.org/package/stable-maps-0.0.1 is stuck dealing with the map of lists because i index by stablenames. i stand corrected.
09:23:19 <Maxdamantus> I'd guess Unique's ordinal properties have similar semantics to if IORef was Ord as according to that SPJ link and what was discussed here.
09:23:33 <rocksteady> how to match a list containing exactly two elements by pattern?
09:23:37 <jonkri> planet@community.haskell.org seems to bounce e-mails, "connect to community.haskell.org[72.249.126.23]: Connection timed out". anyone here who can fix that?
09:23:40 <edwardk> note that Unique is fairly expensive because its bumping a TVar behind the scenes, so its a global synchronization bottleneck. this is usually not a concern in haskell, but goes back to my earlier point =)
09:23:51 <Maxdamantus> (ie, you can't predict that a newer one is greater than an older one)
09:23:55 <jmcarthur> rocksteady: [a,b]  or  (a:b:[])
09:23:59 <edwardk> yeah
09:23:59 <rocksteady> thx
09:24:51 <edwardk> also note that Unique can cause your program to blow up if you try to use them with unsafeIOtoSTM
09:25:01 <edwardk> because it internally abuses atomically
09:25:04 * Maxdamantus will avoid that for a while.
09:25:21 <edwardk> (they need a newUniqueAtomic) or some such
09:25:23 <jmcarthur> why doesn't it just use IORef and atomicModifyIORef?
09:25:45 <edwardk> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-Unique.html
09:25:52 <edwardk> jmcarthur: decent question
09:25:58 <Maxdamantus> At least not in the first thing I write (excluding one-liners in ghci) other than some 5-line game of life and brainfuck implementations.
09:26:04 <EvanCarroll> Amazon $20.00 gift certificate for $10.00: https://livingsocial.com/deals/21336?ref=personalized-link-box-4214915&rpi=4214915
09:26:14 <jmcarthur> ah "scheduling issues" of some sort
09:26:17 <EvanCarroll> Brings LYAH down to $16.00 for a hard copy
09:26:24 <edwardk> jmcarthur: i'd drop in a libraries request, but i haven't cared enough, though this has bitten me before.
09:26:27 <Maxdamantus> (actually the BF thing wasn't that great .. I leaked arrays somewhere)
09:26:39 * jmcarthur looks up the bug they reference in the comments
09:26:49 <Maxdamantus> (Lost King would be using about 300MB by the time it gets to the first prompt)
09:27:07 <jmcarthur> looks fixed
09:27:08 <jmcarthur> http://hackage.haskell.org/trac/ghc/ticket/3838
09:27:08 <edwardk> i think i just need to put in for them to add a newUniqueSTM
09:27:42 * hackagebot asn1-data 0.4.2 - ASN1 data reader and writer in RAW, BER, DER and CER forms  http://hackage.haskell.org/package/asn1-data-0.4.2 (VincentHanquez)
09:28:09 <sshc> How should I enable the extensions that 2010 adds with GHC 7?
09:28:37 <sshc> GHC 7 builds with the '98 standard by default, right?
09:29:09 <edwardk> sshc: I think there is a {-# LANGUAGE Haskell2010 #-} but i've never used it
09:29:22 <jmcarthur> sshc: i think ghc 7 builds with 2010 by default, actually
09:29:26 <edwardk> i usually turn them on piecemeal
09:30:11 <edwardk> jmcarthur: oh, i have a new version of the speculation package pending with the code to abuse numSparks and interrogate numCapabilities to avoid sparking when there is only one
09:30:32 <edwardk> (and to avoid sparking stm actions when there are more sparks outstanding than capabilities to run them)
09:31:11 <edwardk> but i don't have ghc 7 installed to test it with yet
09:31:16 <jmcarthur> oh, is that actually faster? to check manually rather than allow the runtime to do it on your behalf?
09:31:51 <edwardk> yes, because in my case the spark provides no benefit if i don't get to execute it on a spare core.
09:31:55 <sshc> jmcarthur: How would I configure GHC to explicitely build with either standard, and how should I change a cabal project file to specify that the 2010 standard is required?
09:32:10 <edwardk> the STM case degraded poorly under load before
09:32:20 <jmcarthur> sshc: i would just enable each feature individually, personally
09:32:24 <edwardk> the normal case evaluated fine because the spark just never got executed
09:32:36 <edwardk> but it still had to check if g == a as overhead
09:32:40 <dcoutts_> sshc: as of Cabal-1.10, one can specify the language
09:32:41 <jmcarthur> edwardk: oh, i see
09:32:59 <jmcarthur> yeah, that equality check could be an issue
09:33:05 <sshc> dcoutts_: Ah.  How would it be specified?
09:33:14 <jmcarthur> edwardk: this changes spec's strictness properties, right?
09:33:29 <dcoutts_> sshc: there's a default-language and other-languages field
09:33:52 <jmcarthur> at least when you only have one capability or a full spark queue already
09:33:56 <dcoutts_> sshc: default-language is what applies when not specified in a LANGUAGE pragma in the source
09:34:00 <sshc> dcoutts_: Hmm, I don't see it in http://www.haskell.org/cabal/release/cabal-latest/doc/users-guide/authors.html#pkg-descr
09:34:11 <edwardk> because i may avoid forcing g or a?
09:34:15 <edwardk> yeah
09:34:26 <dcoutts_> sshc: yep, the release is not up there yet
09:34:35 <Maxdamantus> "Hashes a Unique into an Int. Two Uniques may hash to the same value, although in practice this is unlikely. The Int returned makes a good hash key. "
09:34:37 <edwardk> well the full spark queue is only a factor for specSTM
09:34:38 <Maxdamantus> Hmm..
09:34:41 <jmcarthur> ah
09:34:54 <Maxdamantus> Is it possible to make some bijective Int hash?
09:34:54 <dcoutts_> sshc: but I'm working on doing a proper release
09:34:58 <Maxdamantus> (one suitable as a hash)
09:35:02 <edwardk> because it is forced to evaluate 'a' in the background thread instead of 'g' 
09:35:18 <sshc> dcoutts_: I see, thanks.
09:35:28 <jmcarthur> edwardk: i'm a little hesitant about strictness properties changing depending on the number of capabilities
09:35:29 <edwardk> spec evaluates in a manner than if the spark never executes the only overhead is the a == g check. specSTM's overhead is double work
09:36:07 <edwardk> a guess of bottom is going to provide rather undefined behavior to begin with
09:36:14 <tac-tics> Isn't the definition of a hash a non-injective function?
09:36:15 <Maxdamantus> Well, injective really.. I guess they're the same when you're talking about sets of the same size.
09:36:21 <edwardk> i can include that in the API specification
09:36:38 <edwardk> that any guess must be non-bottom. and i can make the f a call into an f $! a
09:36:55 <edwardk> the latter i should definitely do
09:37:08 <jmcarthur> that
09:37:15 <jmcarthur> *that's what i was getting at
09:37:20 <jmcarthur> the latter
09:37:30 <edwardk> fair nuff
09:37:37 * Maxdamantus sleeps.
09:37:40 <dcoutts_> jmcarthur: strictly speaking, par does not change strictness
09:37:51 <jmcarthur> dcoutts_: i'm not talking about par though
09:38:15 <jmcarthur> dcoutts_: edwardk is choosing whether or not to evaluate something based on numSparks
09:38:24 <edwardk> dcoutts: i do horrible things inside of spec including checking to see if a thunk is evaluated and how many capabilities are present.
09:38:27 <jmcarthur> dcoutts_: and formerly it was just always forced
09:38:34 <dcoutts_> ah ok, yes that's a bit evil
09:38:43 <edwardk> dcoutts: in specSTM i even now change behavior based on numCapabilities compared to numSparks
09:38:57 <sshc> I've written "default-language: Haskell2010" in the cabal file, but the project is still configured to link with haskell98
09:39:12 <edwardk> jmcarthur: not always, recall spec actually checked of 'a' was forced.
09:39:21 <edwardk> jmcarthur: so it already had undefined strictness properties
09:39:22 <dcoutts_> sshc: mm, that's an interesting combination to pick :-)
09:39:31 <dcoutts_> sshc: do you really want to do that?
09:39:48 <jmcarthur> edwardk: that still sounds like it was strict in 'a'
09:39:49 <edwardk> and it still has the fact that some times it doesn't have to do the comparison between a and g, so sometimes it'll only force and other times it'll force everything needed to answer '=='
09:39:59 <jmcarthur> ah
09:40:10 <jmcarthur> difference between whnf and nf
09:40:16 <jmcarthur> or whatever form is needed for (==)
09:40:23 <edwardk> yeah somewhere between
09:40:46 <jmcarthur> hmm
09:40:46 <dcoutts_> sshc: I presume that's because you're specifying build-depends: haskell98 right?
09:40:58 <jmcarthur> weird. hard to specify precisely
09:41:02 <edwardk> yeah
09:41:07 <edwardk> useful, but awkward =)
09:41:25 <edwardk> spec' avoids the thunk check and has easier to specify semantics
09:42:25 <jmcarthur> well, it's at least fair to say that spec is strict in 'a'
09:42:30 <ksf> http://hpaste.org/43147/knucleotide
09:42:43 <jmcarthur> at least as long as you do f $! a along with these other changes
09:43:00 <jmcarthur> even with the thunk check
09:43:18 <edwardk> yeah
09:43:24 <edwardk> i'm more than happy to do the latter
09:43:33 <ksf> right now, the two candidates for more performance that I see are a) not using 64 but 32/16 bit keys where possible, and b) using more packed buffers to make the accesses aligned.
09:44:19 <jmcarthur> ksf: i don't know why i ever wonder why C and Haskell have similar code sizes for most shootout benchmarks ;)
09:44:43 <ksf> ...the code's quite dirty, right now.
09:44:57 <ksf> sometimes I wonder why it's not segfaulting.
09:45:37 <cmeiklejohn> hi there
09:45:45 <Philippa> jmcarthur: I suspect part of it's that the benchmarks are /just/ too small to start recouping a little code size while maintaining the speed
09:46:24 <jmcarthur> Philippa: that's probably part of it, but i was just quipping about the low-levelness of the code
09:46:41 <ksf> well, I can tell you why it's so low-level.
09:46:47 <ksf> haskell doesn't know structs.
09:46:55 <jmcarthur> structs are in the spec?
09:46:57 <cmeiklejohn> i've tried finding a but for this, but I haven't come across anything yet.  build failure of hexpat 0.19.5 with ghc 6.12.1 -- Text/XML/Expat/Format.hs:197:4: Ambiguous occurrence `concatMap'
09:47:02 <ksf> I can't have unboxed mixed-type arrays.
09:47:04 <cmeiklejohn> anyone know of anything to try here?
09:47:48 <ksf> even worse, there seems to be no primitive compare and swap anywhere, which could hurt multi-core performance quite dramatically.
09:48:23 <Philippa> ksf: yeah, the lack of a struct equivalent's nasty :-(
09:48:24 <ksf> then there's a lot of bit-fiddling.
09:49:02 <ksf> when you look at lookup and insert, which are the heart of the hash, it's not so low-level.
09:49:07 <Saizan> go HList-like over the storable-vector package?
09:50:21 <ksf> hmmm I'm not sure I can use storablevector.
09:50:22 <Philippa> Saizan: possibly, want to write the lib?
09:50:25 <ksf> anyway, that's what I'm doing.
09:50:58 <edwardk> jmcarthur: folding speculation-transformers into speculation for 1.1
09:51:56 <ksf> in any case, I'm missing some raw performance.
09:52:02 <ksf> the whole thing should be faster.
09:52:12 <jmcarthur> edwardk: decided avoiding a dependency wasn't worth a whole new package after all?
09:52:46 <ksf> +RTS -p isn't showing useable numbers anymore, I'm down to benchmarking alignment artifacts, there.
09:52:49 * hackagebot speculation 1.1.0.0 - A framework for safe, programmable, speculative parallelism  http://hackage.haskell.org/package/speculation-1.1.0.0 (EdwardKmett)
09:52:55 <ksf> ...and it's still waaaay slower than C.
09:53:19 <Saizan> Philippa: maybe if i had a use for it :)
09:53:36 <edwardk> jmcarthur: that and transformers doesn't have any namespace conflicts like the mtl does
09:53:46 <rocksteady> i am trying to get something working in haskell. but it wont. i've written the code in PHP to show you what i want to do (in haskell with pattern matching and recursion): http://pastebin.com/XTYFHwZD anyone can help me?
09:54:38 <Philippa> for those who know: how well does GHC specialise away a single monad or applicative transformer on top of identity these days, and what prodding is it likely to need to do it?
09:54:44 <ksf> does the llvm backend use sse etc.?
09:55:49 <jmcarthur> > find (\x -> 2^x >= 32) [1..]
09:55:50 <lambdabot>   Just 5
09:55:50 * hackagebot speculation-transformers 0.1.2 - Merged into 'speculation'. Use that instead.  http://hackage.haskell.org/package/speculation-transformers-0.1.2 (EdwardKmett)
09:56:29 <rocksteady> jmcarthur: sry my fault. i am not allowed to use built in functions
09:56:30 <edwardk> tempted to reorganize the namespace for that mess to just make Data.Speculation.*
09:56:43 <jmcarthur> rocksteady: you're going to have a hard time not using any built in functions
09:56:53 <jmcarthur> rocksteady: integer operations are built in, for example
09:57:03 <edwardk> would make the module list more seemly
09:57:38 <jmcarthur> ksf: i don't think so
09:57:42 <rocksteady> jmcarthur: i am only able to use relational operators, + and *
09:57:57 <rocksteady> thats says the task :/
09:58:09 <jmcarthur> rocksteady: you could just look at the source for find and enumFrom to expand my code
09:58:21 <rocksteady> okay
09:58:28 <jmcarthur> rocksteady: or at least to learn from it to see how you could do it yourself
09:58:36 <rocksteady> alrite
09:58:56 <fryguybob> > let f p c t | t < p = f p (c+1) (2*t) | otherwise = c in f 32 1 2
09:58:57 <lambdabot>   5
09:58:59 <Philippa> crap, I need a polymorphic map :-( Is there a decent one on hackage, or do I get to have lots and lots of fun?
09:59:16 <jmcarthur> Philippa: what do you mean by polymorphic map?
09:59:21 <Philippa> (I need one that'll let me 'allocate' fresh keys sensibly, don't need to be able to supply my own keys)
09:59:27 <rocksteady> fryguybob: thats awesome
09:59:35 <jmcarthur> ah, you need a key supply, essentially?
09:59:39 <Philippa> jmcarthur: one you could use as the implementation for ST
09:59:44 <jmcarthur> ah
09:59:55 <jmcarthur> oh, so you need a heterogeneous map?
09:59:58 <Philippa> yeah
10:00:00 <jmcarthur> ew
10:00:02 <jmcarthur> :)
10:00:03 <Philippa> and I know what I'm doing
10:00:08 <edwardk> philippa: i have a stable-map
10:00:12 <jmcarthur> i don't know of any
10:00:23 <Philippa> eh, it's sensible enough: I'm using the keys to 'cut' loops for analysis purposes
10:00:28 <Philippa> edwardk: tell me more?
10:00:31 <edwardk> http://hackage.haskell.org/package/stable-maps-0.0.1
10:01:04 <Philippa> edwardk: cool, that ought to do. It's not like I have massive performance concerns :-)
10:01:04 <ksf> -optlo-enable-unsafe-fp-math -optlo-enable-no-infs-fp-math  -optlo-enable-no-nans-fp-math    is helping a bit
10:01:06 <edwardk> its a map indexed by stablenames so the values are of the form f a, for whatever the key type a i
10:01:12 <edwardk> er key type a is
10:01:16 <tolkad> Is there any way to enable -Werror just for my own package?
10:01:35 <tolkad> because almost everything in hackage compiles with errors and I don't really care
10:02:03 <Philippa> jmcarthur: the polymorphism's all 'controlled' by a GADT, I'm not doing anything I couldn't make work sensibly in a dependently-typed language with minimal pain compared to that of writing the basic map structure itself
10:02:10 <edwardk> {-# OPTIONS_GHC -Werror #-} ?
10:02:14 <jmcarthur> i see
10:02:27 <edwardk> or for the whole package you can bake it into the cabal file
10:02:30 <jmcarthur> i wish things like this were generally cleaner
10:02:36 <maurer_> Is there a way to say to use an IntMap if our Int is 64 bits, and Map Word64 otherwise?
10:02:48 <edwardk> maurer: #ifdef ;)
10:02:54 <tolkad> edwardk: oh, I'll try putting it into the cabal file
10:02:54 <maurer_> edwardk :(
10:02:56 <maurer_> OK
10:03:20 <Philippa> edwardk: arguably I should just go straight to the StableNames at that point, of course :-) Or just write the library in Scheme instead or something
10:04:37 <Philippa> jmcarthur: I'm writing a parsing Applicative, only I've got to the point where really I need a monad that generates the applicative that I can use to mark out the recursion in the grammar. Ultimately there's no alternative to an Id -> Parser result map
10:05:02 <edwardk> philippa: ah, i have a library for that somewhere one sec.
10:05:17 <edwardk> (juggling two things, may take more than a sec)
10:05:44 <Philippa> edwardk: np. So much for developing independently from you :p (though I was always going to jack your approach to incremental parsing in some form anyway)
10:07:38 <jmcarthur> just yesterday i was thinking it would be neat to have an annotated (in the sense of fingertree) AST so that you can incrementally change it and get the new results without having to reevaluate the whole thing like a function application. to do it polymorphically, type-safely, and efficiently would be pretty tough though, i think
10:08:29 <Philippa> jmcarthur: which is why edwardk's the guy to've actually done it
10:08:43 <jmcarthur> heh
10:09:06 <edwardk> jmcarthur: did you see my article on incremental folds? it was for just that
10:09:56 <jmcarthur> edwardk: the approach would even directly work for a GADT?
10:10:45 <edwardk> jmcarthur: it works for me by rotating the fixed point slightly
10:11:09 <edwardk> Philippa: hrmm, i thought http://comonad.com/haskell/parsimony/dist/doc/html/parsimony/ was a newer version than the version i have up there. i'll have to dig around for something fresher
10:11:22 <edwardk> that was sort of my first draft
10:12:18 <Philippa> edwardk: given that I'm going for VPLs, if I use it, how much am I going to have left to do? :p
10:12:37 <edwardk> http://comonad.com/haskell/parsimony/dist/doc/html/parsimony/Text-Parsimony-Prim.html might be useful to you. the next version added the Path machinery to rederive sharing information from the Applicative
10:12:37 <aristid> what's the name for bidirectional functions?
10:12:46 <edwardk> aristid: isomorphisms?
10:13:05 <aristid> and if it's not a complete isomorphism?
10:13:17 <edwardk> aristid: embedding/projection pairs are also common
10:13:26 <codolio> Boomerang?
10:13:50 <edwardk> codolio: the lens terminology used by boomerang is a bit overloaded
10:13:52 <aristid> if (a -> b, b -> a) is an isomorphism, what about (a -> [b], b -> [a])
10:13:58 <codolio> Yeah.
10:14:18 <aristid> @hackage boomerang
10:14:19 <lambdabot> http://hackage.haskell.org/package/boomerang
10:14:28 <aristid> not existy
10:14:33 <aristid> what is "boomerang"?
10:14:58 <codolio> I think boomerang calls a 'lens' a pair (a -> b, b -> a).
10:15:17 <aristid> codolio: that's an isomorphism :)
10:15:24 <codolio> No it isn't.
10:15:27 <aristid> not?
10:15:42 <codolio> It's only an isomorphism if they're inverses of each other on both sides.
10:15:50 <aristid> and they don't enforce that?
10:15:57 <codolio> Who?
10:16:03 <aristid> boomerang
10:16:06 <codolio> No.
10:16:25 <codolio> At least, I expect not.
10:16:29 <Philippa> not only don't they, it's not intended to be
10:16:53 <Philippa> for example, you don't want to rule out a lens that partly reformats
10:16:56 <tolkad> fix = \f -> (\x -> unsafeCoerce f (unsafeCoerce x x)) (\x -> unsafeCoerce  f (unsafeCoerce x x)) 
10:17:01 <tolkad> how portable is that?
10:17:12 <codolio> Not portable, and it doesn't work.
10:17:25 <kuffaar> Haha is that supposed to be the Y combinator?
10:17:25 <tolkad> something like it works for me
10:17:27 <edwardk> tolkad: not very, unsafeCoerce isn't portable across implementations
10:17:32 <geheimdienst> tolkad, ceiling cat is unhappy with you
10:17:36 <tolkad> kuffaar: yes
10:17:48 <codolio> It will most likely make the optimizer loop.
10:17:56 * hackagebot speculation 1.2.0.0 - A framework for safe, programmable, speculative parallelism  http://hackage.haskell.org/package/speculation-1.2.0.0 (EdwardKmett)
10:18:07 <mm_freak> tolkad: what's wrong with the usual 'fix'?
10:18:40 <tolkad> mm_freak: I like writing my haskell as lambda calculus, it's just a preference
10:18:46 <jmcarthur> ...
10:19:06 <edwardk> reorganized the module hierarchy
10:19:10 <kuffaar> I like not writing Haskell
10:19:14 <jmcarthur> aw
10:19:19 <tolkad> yup, it works codolio 
10:19:21 <tolkad> just tested it
10:19:30 <tolkad> import Unsafe.Coerce
10:19:30 <tolkad> y = \f -> (\x -> unsafeCoerce f (unsafeCoerce x x)) (\x -> unsafeCoerce  f (unsafeCoerce x x))
10:19:31 <tolkad> main = print (take 100 (y (0:)) :: [Int])
10:19:44 <aristid> what i don't like about the word lens is that the record accessor libraries use it in a rather different way
10:19:52 <codolio> I know it works. It also will randomly cause your code not to complete compiling depending on the optimization levels.
10:20:01 <edwardk> aristid: yeah that and the notion of lenses is fairly fluid
10:20:01 <codolio> So in that sense, it doesn't work.
10:20:12 <codolio> And there's no reason to write code that way.
10:20:15 <tolkad> codolio: no I tried -O2 and it still worked
10:20:28 <edwardk> for instance the bidirectional lenses used by his later work are very different than the embedding/projection pairs used by boomerang
10:21:02 <mm_freak> tolkad: haskell /is/ lambda calculus, but a typed one
10:21:11 <tolkad> codolio: whatever the compiler is doing, any good combiler will do some sanity checking during optimization that should prevent it from running forever
10:21:15 <alip> is there link describing the major changes between ghc-6.1 and ghc-7.0?
10:21:16 <tolkad> compiler*
10:21:30 <mm_freak> the combinator you're trying to implement is the Y combinator from /untyped/ lambda calculus, which obviously won't work in haskell
10:21:41 <edwardk> tolkad: actually there is an explicit bug when dealing with Y-combinator issues
10:21:56 <codolio> tolkad: The GHC optimizer is specifically designed with the premise that people won't write code like that, because the types rule out any easy way of writing down that combinator.
10:21:59 <edwardk> tolkad: which was classified as a wontfix because it slows everything else down
10:22:13 <mm_freak> tolkad: note that typed lambda calculus alone can't even express the Y combinator…  in other words, it's a language extension
10:22:14 <codolio> And because it's silly to go out of your way to break that assumption.
10:22:56 <mm_freak> so haskell is actually a superset of a typed lambda calculus
10:22:57 <edwardk> http://r6.ca/blog/20060919T084800Z.html
10:23:22 <edwardk> that blows up (or used to) even with types =)
10:23:27 <tolkad> codolio: ghc wont compile many things, for example this perfectly good standard haskell: http://pastebin.com/QTnTSw7P
10:23:35 <_mpu> using a specially crafted type one can add a fixpoint combinator in Haskell à la Y.
10:23:53 <_mpu> that always surprised me ...
10:24:12 <jmcarthur> _mpu: it's only because types have their own fix as well
10:24:31 <_mpu> that still surprises me
10:24:36 <jmcarthur> you're just using one fix in place of another
10:24:43 <_mpu> mmh
10:24:45 <tolkad> wait something happened to my state monad
10:24:55 <mm_freak> tolkad: from a first glance it looks like it has to complain about infinite types
10:25:08 <mm_freak> but i haven't run it
10:25:26 <mm_freak> anyway, it always seems to me that you want to write some different language in haskell
10:25:41 <aristid> edwardk: do you know if somebody has used "lenses" similar to (a -> [b], [b] -> a) yet?
10:25:50 <jmcarthur> tolkad: i bet if it doesn't compile then you're not actually writing "perfectly good standard haskell"
10:25:59 <edwardk> aristid: not me =)
10:26:09 <tolkad> oh it's StateT now
10:26:15 <edwardk> that looks a bit like an embedding projection pair between a and [b] though
10:26:19 <tolkad> mm_freak: actually it's a ghc bug
10:26:32 <aristid> tolkad: mtl 2.0 uses State = StateT Identity
10:26:52 <aristid> edwardk: sorry, wrong type. i mean (a -> [b], b -> [a])
10:27:03 <mm_freak> tolkad: try to give your functions types
10:27:08 <mm_freak> type signatures that is
10:27:26 <aristid> edwardk: it's like an embedding projection pair, but with kleisli arrows, i guess (i fear i'm using the words all wrong here)
10:28:39 <mm_freak> tolkad: as a side note, there is also mfix from Control.Monad.Fix
10:28:41 <mm_freak> :t mfix
10:28:42 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
10:29:35 <aristid> :t let (a, b) >>> (c, d) = (a >=> b, c <=< d) in (>>>)
10:29:36 <lambdabot> forall a (m :: * -> *) b c b1 (m1 :: * -> *) c1 a1. (Monad m1, Monad m) => (a -> m b, b -> m c) -> (b1 -> m1 c1, a1 -> m1 b1) -> (a -> m c, a1 -> m1 c1)
10:29:41 <tolkad> lol it compiles with a NOINLINE annotation on f
10:29:48 <tolkad> I think that's proof it's a ghc bug
10:30:03 <codolio> tolkad: That's the exact same problem I warned about with your silly unsafeCoerce code.
10:30:07 <tolkad> compiles: http://pastebin.com/v5ggHDZS
10:30:31 <tolkad> codolio: I'm saying this happens even with valid haskell so there's no sense complaining about me doing it with invalid haskell
10:30:39 <tolkad> codolio: it could happen at any time
10:30:41 <codolio> Yes there is.
10:30:48 <codolio> Neither one of those examples is sensible code.
10:31:16 <codolio> There's no reason to write either.
10:31:57 <edwardk> aristid; all the words in that sentence were correct =)
10:32:00 * hackagebot speculation 1.2.0.1 - A framework for safe, programmable, speculative parallelism  http://hackage.haskell.org/package/speculation-1.2.0.1 (EdwardKmett)
10:32:10 <edwardk> they were even strung together correctly =P
10:32:19 <aristid> edwardk: yay \o/
10:32:39 <jmcarthur> you're argument seems to boil down to "There is a demonstrable bug with code that I believe to be not buggy, therefore any issues with crappy code are irrelevant"
10:32:49 <jmcarthur> doesn't make much sense to me
10:33:19 <edwardk> can someone with ghc-7 see if speculation 1.2.0.1 builds for them?
10:33:23 <tolkad> ok what about this: the more inlining ghc does the faster your code is likely to run
10:33:33 <jmcarthur> not necessarily true
10:33:34 <tolkad> so with an infinite amount of inlining your code will run infinitely fast
10:33:41 <jmcarthur> definitely not true
10:33:44 <edwardk> tolkad: not in the presence of cache effects
10:34:22 <tolkad> edwardk: but if we use say an emulator without a cache, then may statement is correct?
10:34:25 <gwern> tolkad: huh? how could code run infinitely fast? where's the computation being done?
10:34:26 <jmcarthur> no
10:34:28 <_mpu> which is quite frequent in a lazy language
10:34:30 <_mpu> ...
10:34:44 <edwardk> doesn't work then because you need to be able to dereference an infinite amount of memory, which takes log (infinite) time ;)
10:34:47 <gwern> tolkad: and how do you do the computation in advance when input is dynamicly specified
10:34:52 <jmcarthur> tolkad: you would need the bandwidth from the hard drive to the cpu to be as fast as the cpu can execute the instructions
10:35:00 <tolkad> gwern: idk, ghc is just good like that
10:35:04 <gwern> o.0
10:35:15 <gwern> cargo cult programming. learn some cs young padawan
10:35:30 <tolkad> I'm kidding :P
10:35:36 * gwern hopes you were
10:35:48 * jmcarthur believes tolkad
10:35:48 <edwardk> gwern: clearly he has an infinite amount of memory so, he can just store all the possible answers for all possible questions
10:35:52 <jmcarthur> he does this all the time
10:36:11 <jmcarthur> edwardk: lookup tables are slow too though :P
10:36:12 <edwardk> i don't envy him his preprocessing time though =)
10:36:15 <gwern> edwardk: so it takes him an infinite amount of time to compile a program? not much of a time saving
10:36:26 <Philippa> gwern: nononono, he compiles lazily
10:36:35 <edwardk> gwern: and thus the young disciple discovered strictness ;)
10:36:40 <geheimdienst> gwern, i guess that answers the question of where the computation is being done
10:36:41 <jmcarthur> Philippa: that's a perfect description of completely lazy evaluation :)
10:36:57 <gwern> geheimdienst: I suppose so...
10:37:07 <jmcarthur> and it also perfectly explains the space-related issues with it
10:37:27 <codolio> edwardk: Ambiguous occurrence testHook
10:37:54 <mm_freak> tolkad: i see the bug now
10:37:55 * geheimdienst invents ahead-of-time computation, a drastic improvement of ahead-of-time compilation
10:38:07 <gwern> oh, are there any quickcheck experts around? I have some lambdabot code I'd like updated from qc 1 to qc 2 but I have no idea what the missing functions went in qc 2
10:38:36 <mm_freak> tolkad: but what's your point?  and what does that have to do with your broken Y combinator?
10:38:44 <edwardk> codolio: crap. time to gut the cabal file, its fairly old
10:38:46 <codolio> edwardk: Oh wait, that was 1.0.0.0.0.0
10:38:57 <codolio> Let me cabal update.
10:39:01 <edwardk> k
10:39:16 <dafis> edwardk: but I got the same error with 1.2.0.1
10:39:19 <codolio> I frequently forget to do that for some reason.
10:39:22 <edwardk> =/
10:39:27 <tolkad> mm_freak: I was saying that even valid haskell doesn't compile sometimes so it's not so bad that my invalid haskell wouldn't compile
10:39:32 <gwern> hm. c.h.o up?
10:39:43 <codolio> Yeah. Same. There's one imported from Distribution.Simple.
10:39:46 <edwardk> now to figure out what changed in cabal in the last year or so to break the testbook
10:39:48 <edwardk> er testHook
10:39:59 <geheimdienst> gwern, doesn't respond for me
10:40:07 <edwardk> guessing it was the cabal test support being added
10:40:15 <mm_freak> tolkad: well, i've never had that problem…  i think that's one of the compiler bugs you need to coerce to happen ;)
10:40:36 <codolio> I guess you can probably just hide the Distribution.Simple one?
10:41:00 <edwardk> i have an explicit list of things i'm importing, is it a member of UserHooks(..) ?
10:41:44 <dafis> edwardk: yup
10:41:45 <mm_freak> when i use -fvia-C, can i somehow output the generated C code to a file/directory?
10:41:46 <edwardk> appears to be
10:42:02 <dcoutts_> edwardk: let me know what you find. The API should not have changed so much that it breaks packages that define the runTests hook.
10:42:07 <copumpkin> mm_freak: there's an option to keep intermediate files
10:42:14 <copumpkin> one of them is the .hc files I think, but I can't remember the option
10:42:27 <edwardk> dcoutts: my  testHook was  named testHook =)
10:42:38 <copumpkin> mm_freak: I'd recommend against looking at the files though. Your eyeballs may bleed
10:42:47 <mm_freak> copumpkin: is this code self-contained and able to compile with only GCC?
10:43:00 <copumpkin> not really, no
10:43:06 <mm_freak> hmm, ok
10:43:14 <dcoutts_> edwardk: ohh, you mean you have a function in your Setup.hs called testHook
10:43:16 <edwardk> i had a 'runTests = testHook' line in my cabal file. i just need to rename it
10:43:17 <edwardk> yeah
10:43:26 <dafis> mm_freak: jhc gives you standalone C iirc
10:43:26 <dcoutts_> right, that'll break, sorry
10:43:29 <copumpkin> mm_freak: JHC produces prettier c
10:43:31 <edwardk> no problem
10:43:42 <mm_freak> dafis: interesting, thanks
10:43:43 <dcoutts_> edwardk: which package is that?
10:43:50 <mm_freak> copumpkin: it doesn't have to be pretty…  just compilable
10:44:02 * dcoutts_ is currently surveying Setup.hs files that break with new Cabal lib version...
10:44:02 <copumpkin> well, GHC also has some constants in it that are platform-dependent
10:44:23 <copumpkin> it does use gcc in the end to compile the c files
10:44:26 <copumpkin> but it may pass odd options to it
10:44:34 <mm_freak> i see
10:44:59 <dafis> dcoutts_: speculation breaks with ambiguous occurrence of testHook
10:45:34 <edwardk> ok, renamed it to myTestHooks or something
10:45:38 <edwardk> or runMyTests
10:46:01 <dafis> edwardk: already uploaded?
10:46:03 * hackagebot speculation 1.2.0.2 - A framework for safe, programmable, speculative parallelism  http://hackage.haskell.org/package/speculation-1.2.0.2 (EdwardKmett)
10:46:05 <edwardk> yeah
10:46:06 <dcoutts_> dafis: ah yes, that's on my list
10:46:38 <edwardk> with luck this patch should fix it
10:47:13 <dafis> edwardk: the Setup has compiled, now let's wait for the lib
10:47:18 <edwardk> =)
10:47:37 <dafis> edwardk: Registering speculation-1.2.0.2... :D
10:47:46 <edwardk> all good?
10:47:50 <dafis> edwardk: with 7.0.1
10:47:54 <edwardk> sweet
10:48:02 <edwardk> that includes all the shiny new numSparks support
10:48:10 <dafis> kewl
10:49:40 * Philippa has just had an extremely filthy idea
10:49:53 <Philippa> which goes: I don't need the map, I can stick the value in the 'key'
10:50:15 <hpc> Philippa: oh god, why
10:50:17 <Philippa> (Int, Parser ...)
10:50:53 <Philippa> hpc: because all I need is knowing the number's there and can be compared for equality, I don't /actually/ need a finite structure so long as I know when to stop paying attention
10:51:16 <Philippa> edwardk: how badly does that set off your vomit reflex? :p
10:51:30 <hpc> Philippa: ah, i see
10:51:35 * ksf decides to give up.
10:51:46 <ksf> there's just no real point without access to sse
10:51:47 <copumpkin> Philippa: I saw him run away from his computer in disgust
10:52:03 <copumpkin> (he's normally across from me)
10:52:44 * ksf wonders how far a llvm monad would take things
10:53:20 <edwardk> philippa: at that point its just a Set =)
10:53:59 <edwardk> ksf: i had started one then lennart came out with one and i figured there was no point in even trying to keep up ;)
10:54:47 <Philippa> edwardk: well, the point is I no longer have a central structure for now (and by the time I need one, I can erase the results which'll give me a monotype, too)
10:55:28 <ksf> well, the main thing would be to integrate it with the rest of ghc
10:55:30 <Philippa> ...hmm, I guess if I do that I have to do all my grammar transformations in slightly more awkward manner, but yeah
10:55:41 <edwardk> fair nuff
10:56:08 <xarch> hm, what is a dialgebra?
10:56:30 <Philippa> having 'evidence' for the grammar transformations probably isn't a bad thing anyway, there's always going to be a sufficiently interested user/debugger who'll want to know WTF's happening
10:56:51 <codolio> It's a carrier A together with an action FA -> GA for functors F and G.
10:56:52 <edwardk> dcoutts: it was speculation, but i think that got answered along the way, missed your question
10:57:26 <xarch> hm ok
10:57:34 <dcoutts_> edwardk: I'll cross you off the list of people to ping about broken Setup.hs then :-)
10:57:54 <edwardk> sweet
10:57:55 <xarch> but the definition in category-extras is written as you say, with a note saying this definition is wrong
10:58:04 <roconnor> codolio: so a dialgebra is a cross between a coalgebra and an algebra?
10:58:07 <edwardk> at least with regards to that one. i probably copied the idiom into other packages
10:58:14 <codolio> roconnor: That's the idea.
10:58:29 <codolio> Unless I'm messing up the terminology.
10:58:32 <edwardk> roconnor: yes, though as i note in category-extras the definition i gave was wrong (wrong enough to prevent it from being useful
10:59:52 <xarch> so what should it be?
10:59:54 <edwardk> http://web.engr.oregonstate.edu/~erwig/papers/RandomAccessADT_REPORT.pdf includes a correct definition IIRC
11:00:03 <edwardk> xarch: not typeable in haskell afaict
11:00:21 <xarch> hm ok
11:00:47 <xarch> oh, really?
11:01:02 <edwardk> yeah
11:01:12 <xarch> because i have read some parts and didn't find more than a definition of bialgebras in terms of dialgebras
11:01:15 <joe6> hello: I have a big record structure and I want to compare each field of 2 such records. I am reading up on SYB. I came across a paper which shows that uniplate is more flexible than SYB. All I want to do is compare the fields in each record and if they are different, print the different values in the field. Some thing similar to the getDiff of the Data.Algorithm.Diff module.
11:01:19 <xarch> well, I didn't finish it
11:01:21 * ksf wonders if the ghc devs are going to drop cmm some time in the future.
11:01:28 <xarch> but I looked at the pages.
11:01:38 <joe6> has anyone used uniplate and SYB.
11:01:53 <ksf> llvm is as good or even better an ir as it, and it has the advantage of having an independent backend.
11:01:54 <joe6> any guidance is greatly appreciated.
11:02:05 <xarch> hm, I'll read it more carefully then.
11:02:24 <dreixel> joe6: uniplate is not more flexible than syb.
11:02:26 <edwardk> one sec. getting the original paper
11:02:55 <edwardk> dreixel: but it can perform better because it can omit traversal of parts that obviously don't contain a type
11:03:08 <dreixel> oh yes, it can be faster.
11:03:36 <olsner> ksf: doesn't "cmm" in ghc contain a bunch of haskell/ghc-specific features though? at least I got the impression that llvm is lower level than cmm
11:03:36 <aristid> ksf: does everything that works with GHC 7 also work with -fllvm?
11:03:45 <edwardk> http://doc.utwente.nl/66251/1/db-utwente-404F4540.pdf provides the correct dialgebra definition
11:03:58 <joe6> dreixel: which is better for a beginner? i am reading up on the first paper of SYB and given a few hours i feel confident that I can use it for my purpose.
11:04:40 <dreixel> joe6: from what you said, I'm pretty sure syb can handle it
11:04:52 <dreixel> I'm not sure how uniplate deals with records, though.
11:04:56 <edwardk> joe6: i use both. i provide data instances for everything, for others, but i find uniplate is more fun to use
11:05:32 <joe6> dreixel: should i stick with syb or is there a better library for beginners? I read about LIGD and it seemed easy enough to use too.
11:05:49 <joe6> edwardk: I could not find good uniplate documentation. Do you know of any?
11:05:57 <codolio> edwardk: What's the problem? That existentials are weak, more or less?
11:05:57 <djahandarie> aristid, if you mean everything in GHC 7 sans the ASM backend, I'm fairly certain
11:06:23 <jmcarthur> edwardk: okay, it does indeed seem to have been a pretty trivial change to get incremental folds to work with recursive GADTs. thanks for the tip!
11:06:24 <djahandarie> Oh wait, I missed some context here
11:10:53 <edwardk> codolio: with the category-extras dialgebra definition? i don't recall. i only recall that it is flawed. when you go to use it for some of the erwig examples it falls short, but i don't recall why
11:10:54 <edwardk> joe6: not off hand. i transitioned to it from bjorn bringert's "compos" so it was a fairly natural shift for me
11:10:56 <edwardk> jmcarthur: np.
11:10:59 <edwardk> jmcarthur: i usually just use it with completely differing data types. statements built out of expressions, etc. just using a common annotation type.
11:11:23 <jmcarthur> ah
11:11:36 <codolio> edwardk: I meant with typing it in Haskell in general.
11:11:45 <codolio> (A, a : FA -> GA) is a sigma.
11:11:57 <codolio> You could get close in Haskell with an existential, except that the first component can't be projected out except in a limited scope.
11:15:17 <dreixel> joe6: don't go for LIGD
11:15:21 <dreixel> you can try instant-generics: http://hackage.haskell.org/package/instant-generics
11:15:23 <edwardk> codolio: that very likely was the issue. i just honestly haven't looked at it in a couple of years
11:15:26 <roconnor> edwardk: Have I shown you multiplate?
11:15:30 <edwardk> if you didn't i managed to find it on my own
11:15:31 <roconnor> good enough
11:15:42 <codolio> I mean, that limitation does ruin the general use of a dialgebra, I expect.
11:16:11 <joe6> ok, thanks guys. will search for the uniplate paper also check out the instant-generics module.
11:16:15 <codolio> Heh.
11:16:26 <tg_> anyone here comfortable with group theory? Or H^3? Or what an affine seive is?
11:17:47 <edwardk> dolio: i just recall working through a couple of dialgebra examples for things like sets, etc. where i really needed more context, which sounds pretty much like what you are alluding to
11:28:07 <DrSyzygy> > (| ["plan","tan"] ++ ["gent","king"] |)
11:28:08 <lambdabot>   <no location info>: parse error on input `|'
11:28:13 <DrSyzygy> Doh.
11:28:46 <roconnor> joe6: actually I suspect that Uniplate may not be very good for doing what you want to do.  For example I don't know of any way to write a generic equality function using Uniplate.
11:29:13 <roconnor> joe6: and the function you want to write is not so disimilar to trying to write a generic equality function.
11:30:07 <malware_> e only
11:34:15 * hackagebot hexpat 0.19.6 - XML parser/formatter based on expat  http://hackage.haskell.org/package/hexpat-0.19.6 (StephenBlackheath)
11:43:15 <andy> i know of the BitGet monad, but is there anything along the lines of:
11:43:21 <augur> whats the complexity of haskell's type system?
11:43:24 <andy> runBitGet :: BitGet a -> Get a
11:44:22 <jmcarthur> the... complexity of it?
11:44:38 <andy> i.e. for when deserializing in the Get monad, but with parts that require more bit stuff
11:45:17 <augur> like, what computational complexity is type resolution in haskell
11:45:22 <andy> (and with the assumption that BitGet consumes from and to byte boundaries)
11:46:11 <jmcarthur> augur: ah. i've heard that it's exponential, but i'm not sure exactly over the number what
11:46:14 <kosmikus> augur: exponential in the worst case, but it rarely happens in practice
11:46:23 <augur> denk je
11:46:28 <jmcarthur> *the number of what
11:47:16 <augur> does that include parametric polymorphism, etc etc? it must, surely
11:47:19 <c_wraith> :t let unfold p g b = if p b then [] else let (a, b') = g b in a : unfold p g b' in unfold
11:47:21 <lambdabot> forall t a. (t -> Bool) -> (t -> (a, t)) -> t -> [a]
11:47:34 <c_wraith> :t unfoldr
11:47:35 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
11:48:02 <c_wraith> ...  I really much prefer the former formulation.  Why did the latter formulation make it into the prelude?
11:49:58 <Saizan> it's the one you get if you specialize a generic anamorphism to lists
11:50:09 <c_wraith> > let unfold p g b = if p b then [] else let (a, b') = g b in a : unfold p g b' in unfold (==1) (id &&& \x -> if even x then x `div` 2 else 3 * x + 1) 13
11:50:10 <lambdabot>   [13,40,20,10,5,16,8,4,2]
11:50:36 <c_wraith> Oh, hmm.  I really want a slightly different formulation
11:51:00 <c_wraith> I want one where the termination condition can include its output.
11:51:34 <mkscrg> Beginner question: for lists, is repeated access to one end cheaper than to the other end?
11:51:47 <c_wraith> But that probably makes it not an anamorphism
11:52:01 <c_wraith> mkscrg: yes, it's an immutable singly-linked list.  access to the front end is much cheaper
11:52:53 <Saizan> c_wraith: (t -> Maybe [a]) instead of (t -> Bool) ?
11:53:18 <c_wraith> yeah, that'd be the requirement.  And that makes it no longer a generic anamorphism, I suspect
11:53:37 <Saizan> it's an apomorphism
11:53:56 <mkscrg> c_wraith: Ah, as I expected. Thanks.
11:54:17 <c_wraith> I suppose..  (t -> Maybe (f a)) for the generic f
11:55:00 <joe6> roconnor: just saw your message. What do you recommend? stick with SYB. I tried the instant-generics documentation. All they have is one paper describing their implementation. No manual or usage help other than the hackage docs.
11:55:20 <joe6> roconnor: any guidance is greatly appreciated.
11:55:25 <roconnor> joe6: I don't know what to recommend :(
11:55:34 <Saizan> the usual formulation goes something like apo :: Functor f => (a -> Either (Nu f) (f a)) -> a -> Nu f
11:56:04 <c_wraith> Ok, I've figured out Mu, but I don't know Nu. :)
11:56:16 <c_wraith> Ah.  And Either does make more sense, there
11:56:19 <Saizan> in haskell they are the same :)
11:56:22 <joe6> roconnor: with SYB, I get the feeling that with sufficient muck-about it can do the job.
11:56:31 <roconnor> I expect that is true
11:56:41 <edwardk> technically an apomorphism can be implemented as an anamorphism that just happens to keep consuming the Nu f as needed
11:56:45 <joe6> roconnor: instant-generics seems to have its own boilerplate code.
11:57:15 <edwardk> but thats higher overhead than the nice definition
11:57:53 <joe6> roconnor: i just started reading the uniplate manual. I will finish that and then decide between uniplate or syb.
11:58:07 <edwardk> the main thing in favor of SYB is that in all but the most pathological cases all the boilerplate can be generated by the compiler
11:58:12 <joe6> dreixel: would you concur?
11:58:30 <dreixel> joe6: sounds good to me.
11:58:40 <c_wraith> edwardk: Monad transformers are pathological cases?
11:58:47 <edwardk> c_wraith: yes
11:58:53 <c_wraith> news to me. :)
11:59:03 <edwardk> i have data instances for those, i need to submit a library proposal for them
11:59:25 <c_wraith> Hmm.  The typeable instances gave me enough trouble.  Thanks again for helping me sort those out. :)
11:59:54 <edwardk> c_wraith: the comonad-transformers are all Typeable or Data-ified as appropriate
12:01:52 <mm_freak> kuffaar: i just happened to have to write a concurrent logger for a project i'm coding…  you might be interested in how i would write a real logger
12:02:00 <mm_freak> http://hpaste.org/43149/concurrent_logger_thread_2
12:02:21 <kuffaar> I'm currently trying to grasp Parsec but I don't even manage to get my stuff to compile
12:02:27 <kuffaar> Alright, I'll save it for future reference
12:03:12 <kuffaar> Oh, so you used a monad after all?
12:03:34 <kuffaar> Hmm
12:03:41 <mm_freak> only an internal monad
12:03:45 <kuffaar> At least in LoggerT
12:04:04 <mm_freak> to the logger user only an abstract 'Logger' value is exposed
12:04:08 <kuffaar> What is the | all about, in the comments?
12:04:15 <mm_freak> haddock comments
12:04:23 <mm_freak> online documentation is auto-generated from those comments
12:05:39 <kuffaar> Right, I've seen that
12:08:09 <kuffaar> testParser :: GenParser Char st Char; testParser = anyChar -- works
12:08:20 <kuffaar> testParser :: GenParser Char st String; testParser = many . anyChar -- error
12:09:00 <Saizan> remove the .
12:09:06 <jmcarthur> :t many
12:09:06 <kuffaar> Oh, fail
12:09:08 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
12:19:42 <mm_freak> http://hpaste.org/43150/static_guarantee_failed
12:19:50 <mm_freak> is there a way to solve this problem?
12:20:29 <mm_freak> through concurrency the scoped variable is printed after its scope has ended
12:22:25 <edwardk> mm_freak: the general contract on withFoo's tend to be that you aren't allowed to capture the foo for later use
12:22:39 <edwardk> mm_freak: you are violating the contract =)
12:23:47 <edwardk> universal quantification isn't sufficient to save you from yourself
12:24:33 <j-invariant> its not even clear whatt the code is trying to do, would be better to just describe it
12:25:44 <Philippa> j-invariant: passes a resource to another thread, before passing outside the resource's intended scope and deallocating it
12:26:15 <edwardk> hrmm i think i may rewrite ersatz to sit on top of yices-painless
12:26:28 <edwardk> Yices.Painless.Base is rather nice
12:26:56 <edwardk> at least for my purposes
12:27:52 <exDM69> vsync aka. swapInterval does not work in GLFW, I wonder if this is a Haskell wrapper issue or a GLFW issue
12:29:14 <mm_freak> edwardk: do you know a way to guarantee statically that this cannot be done?
12:29:33 <mm_freak> i think it cannot be guaranteed
12:29:55 <edwardk> mm_freak: write it in agda ;)
12:30:24 <edwardk> mm_freak: variable capture is not an easily observed thing in haskell.
12:30:40 <edwardk> mm_freak; oleg has a cute encoding, but its not usable in the large IMHO.
12:31:02 <mm_freak> edwardk: how does agda solve the problem?  not having concurrency support doesn't count =)
12:31:13 <edwardk> http://okmij.org/ftp/tagless-final/course/course.html#linear
12:31:30 <TomMD> Does not having correctness support count?  I can think of a couple languages you could use...
12:31:33 <edwardk> you build an appropriate universe ;)
12:32:16 <mm_freak> TomMD: PHP?
12:33:02 <Saizan> your approach would work with a more specific monad
12:33:35 <Saizan> well, and without a Show instance :)
12:33:41 <j-invariant> Why is PHP used?
12:33:51 <edwardk> j-invariant: inertia
12:34:00 <j-invariant> I hate intertia!!!
12:34:27 <mm_freak> Saizan: MonadIO is about as specific as i can get without requiring m ~ IO
12:34:46 <Philippa> j-invariant: inertia plus the fact it doubles as a template language
12:35:07 <Philippa> or to put it another way, inertia plus the fact it was a lightweight solution for the time
12:35:18 <edwardk> mm_freak: i think saizan is indicating you could attach something like an HList to the monad's type. then withFoo would extend the HList
12:35:26 <edwardk> so in any other context you wouldn't be able to use the term
12:35:48 <kuffaar> :t Data.ByteString.Lazy.pack
12:35:49 <lambdabot> [Word8] -> BSLC.ByteString
12:35:49 <mm_freak> edwardk: how does that solve the concurrency problem?
12:35:58 <kuffaar> Hmm why Word8?
12:36:02 <kuffaar> http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString-Char8.html#v:pack
12:36:03 <Philippa> because the other thread's the wrong type
12:36:07 <edwardk> because this is your monad, not IO.
12:36:09 <kuffaar> I want the String -> ByteString version
12:36:32 <edwardk> you can lift an IO action, but you can't fiddle with your fancy references in another IO monad
12:37:01 <edwardk> the Show is part of what kills you
12:37:06 <Saizan> it's the usual encoding of regions, oleg has a paper on it somewhere, the catch is that you must then manipulate the Scoped s a only through actions in that monad
12:37:33 <jmcarthur> there's a nice package on hackage for that
12:37:36 <jmcarthur> monadic regions
12:38:27 <dafis> kuffaar: then use the .Char8.pack
12:38:45 <edwardk> i do rather wish bas didn't unicodefuscate all of his code though =/
12:38:57 <kuffaar> Alright, that one worked
12:39:01 <kuffaar> It's all very puzzling though
12:39:18 <koala_man> when a .prof file sys %alloc, is that heap or stack? 
12:39:35 <edwardk> heap
12:39:38 <dafis> kuffaar: be aware that that only handles Chars < '\256' properly, it truncates all others
12:40:00 <koala_man> how do I find where all my stack space goes? 
12:40:07 <tibbe> @seen ezyang
12:40:07 <preflex>  ezyang was last seen on #haskell 18 hours, 58 minutes and 59 seconds ago, saying: edd_: Ah, that's a good find. Thanks! 
12:40:07 <lambdabot> Unknown command, try @list
12:40:40 <mm_freak> edwardk: if i can lift IO actions, how can i prevent one from lifting forkIO actions?
12:40:51 <kuffaar> dafis yeah I'm just generating test input to figure out why my Parsec cdoe isn't compiling so I'm gradually modifying a smaller working version to identify all the problems - ultimately I'm running it on like 60 MiB of HTML read from files so I'm using ByteString instead of String
12:41:12 <mm_freak> edwardk: or rather…  how can i prevent one from lifting forkIO actions, which use the variable?
12:41:20 <edwardk> mm_freak: you can't. the idea was that you'd prevent access to 'using' the reference in any meaningful capacity in a monad that wasn't yours. then the IO action is harmless. just don't provide Show.
12:41:33 <tibbe> @tell ezyang My HAMT is now 37% faster than my IntMap-based HashMap
12:41:33 <lambdabot> Consider it noted.
12:42:03 <Saizan> mm_freak: liftIO . forkIO is still IO a -> m ThreadId; so the forked action is not going to be in the right monad
12:42:51 <edwardk> provide myShowsPrec :: Int -> Scoped s a -> MyMonad s ShowS instead
12:44:43 <mm_freak> edwardk: i see
12:44:55 <mm_freak> i'll try that out
12:46:00 <aristid> tibbe: what's a HAMT?
12:46:15 <tibbe> aristid: hash mapped array trie
12:48:36 <jmcarthur> tibbe: ooh nice
12:49:30 <tibbe> jmcarthur: (and my HashMap is about 100% faster than Data.Map)
12:49:50 <jmcarthur> tibbe: for what key type?
12:50:06 <tibbe> jmcarthur: any really: Int, String, ByteString for example
12:50:45 <jmcarthur> i could see Data.Map being faster for large keys that are likely to have a lot of variation near their heads
12:51:20 <edwardk> tibbe: nice =)
12:51:46 <edwardk> tibbe: hackaged yet?
12:51:52 <jmcarthur> but that's nice that it seems to hold at least for whatever sort of data you're testing with :)
12:51:55 <tibbe> jmcarthur: it's not actually
12:52:15 <tibbe> jmcarthur: in theory tries are faster for strings but every single one I've seen benchmarked has been much slower
12:52:22 <tibbe> edwardk: no, still a work in progress
12:52:26 <edwardk> data.map with large keys is kind of a pathologically bad case
12:52:36 <kuffaar> Hmm what does the signature of a ByteString Parsec parser look like? GenParser Blah.Word8 st Blah.ByteString?
12:52:43 <jmcarthur> edwardk: i mean where the comparisons could finish without evaluating the entire key
12:52:51 <tibbe> jmcarthur: right, if you look at other languages they typically use hashing-based structures exclusively
12:53:00 <jmcarthur> tibbe: yeah, we have pretty bad tries aside from IntMap :(
12:53:01 <kuffaar> Does the first argument have to be the "singular" of the last one?
12:53:13 <tibbe> jmcarthur: comparing a 32-bit int is still faster
12:53:24 <tibbe> jmcarthur: you will need to compare the whole key at least once
12:53:27 <jmcarthur> hash tables also treats your cache a bit better
12:53:35 <edwardk> jmcarthur: fair nuff, but as you get deep in the tree you wind up comparing whole keys over and over
12:53:36 <jmcarthur> tibbe: ah you're right
12:53:39 <tibbe> jmcarthur: yes, by HAMT also takes less memory
12:53:55 <tibbe> back to hacking
12:54:06 <jmcarthur> edwardk: i could almost certainly come up with cases where Data.Map is worse. i can't promise that it would be a realistic workload, though
12:54:09 <jmcarthur> *is better
12:54:47 <jmcarthur> edwardk: it depends on how dense the keys are whether you end up comparing similar keys over and over
12:54:58 <edwardk> tibbe: is your hash map based on an int trie?
12:55:12 <tibbe> edwardk: a hash array mapped trie (see bagwell's paper)
12:55:18 <tibbe> edwardk: stolen via clojure
12:55:19 <edwardk> ah k
12:55:25 <tibbe> which has a persistent implementation
12:55:32 <edwardk> *nods*
12:55:33 <jmcarthur> yeah that's pretty awesome
12:55:50 <edwardk> i missed your HAMT comment above
12:56:03 <jmcarthur> tibbe: how does it compare to a plain IntMap for Int keys?
12:57:20 <jmcarthur> obligatory: eat it, harrop
12:57:38 <edwardk> hey sometimes the energy this community puts into hating harrop goes to productive use ;)
12:57:45 <jmcarthur> lol, took long enough
12:57:55 <jmcarthur> well, we fixed out hash tables before, too, i guess
12:57:58 <jmcarthur> *our
12:58:25 <medfly`> hash tables?
12:58:39 <tibbe> jmcarthur: faster than IntMap for Int keys
12:58:56 <jmcarthur> tibbe: awesome!
12:59:18 <tibbe> now I managed to screw something up in the code
12:59:19 <tibbe> argh!
12:59:20 <mm_freak> edwardk: http://hpaste.org/paste/43150/static_guarantee#p43152
12:59:22 <mm_freak> something like that?
13:00:02 <edwardk> working better for you?
13:00:51 <mm_freak> edwardk: at least i see no obvious way to get around the scope
13:00:57 <edwardk> *nods*
13:01:05 <edwardk> thats the machinery used by runST
13:01:15 <mm_freak> true
13:03:09 <mm_freak> so a custom monad is the only way to have such a static guarantee?
13:03:26 <mm_freak> (without entirely disallowing IO)
13:03:51 <jmcarthur> mm_freak: http://hackage.haskell.org/package/regions
13:04:06 <c_wraith> Isn't that effectively custom monads?
13:04:20 <jmcarthur> mm_freak: it still requires you to define a set of "blessed" computations on it, yes
13:05:01 <jmcarthur> but this particular interface also allows you to do cool nested scope stuff
13:06:19 <mm_freak> jmcarthur: regions don't solve the problem as it seems…  they correspond to the first solution i pasted
13:06:42 <kuffaar> Are you supposed to import Data.ByteString.Lazy.Internal to pack a Lazy bytestring?
13:06:52 <koala_man> how do you determine where stack space goes? is there a guide or something? google is strangely unhelpful
13:07:12 <kuffaar> No wait, there's Data.ByteString.Lazy.pack
13:07:19 <kuffaar> Wow, this is really confusing, there are so many ByteStrings
13:07:30 <aristid> no, just 2
13:07:45 <mm_freak> kuffaar: there are just many interfaces to the same two ByteString types
13:08:01 <kuffaar> Data.ByteString.ByteString, Data.ByteString.Lazy.ByteString, Data.ByteString.Lazy.Internal.ByteString, Data.ByteString.Strict.ByteString, Data.ByteString.Strict.Internal.ByteString
13:08:05 <kuffaar> Ok hm
13:08:24 <aristid> huh? Data.ByteString.Strict.Internal.ByteString? really?
13:08:43 <kuffaar> Perhaps not :|
13:08:51 <kuffaar> Is the non lazy one the strict one?
13:08:57 <kuffaar> And the strict one has no explicit name?
13:09:00 <ivanm> kuffaar: yes
13:09:03 <kuffaar> I see
13:09:18 <ivanm> aristid: yeah, they're defined in Internal modules, which are still exported for some reason :/
13:10:26 <aristid> ivanm: they are exported?
13:10:52 <ivanm> s/exported/exposed in the .cabal file/
13:10:52 <aristid> ivanm: but i meant that i wondered why there would be Data.ByteString.Strict.Internal.ByteString if there are just 2 ByteString types
13:11:05 <ivanm> aristid: oh, missed that
13:11:18 <ivanm> for some reason, all the hackage docs for bytestring fail to load :/
13:11:35 <aristid> there is no Data.ByteString.Strict
13:11:35 <c_wraith> ivanm: the internal modules are exported so that if you have some use case for doing low-level hacking of the internals, you can.
13:11:44 <aristid> so i wonder what kuffaar is talking about
13:11:57 <aristid> http://hackage.haskell.org/package/bytestring
13:12:09 <Saizan> mm_freak: your first solution wasn't quite regions, it was just half of what you need to actually encode a region
13:12:10 <ivanm> c_wraith: yeah, but generally modules called "Internal" _aren't_ exported
13:15:34 <edwardk> aristid: the Date.Bytestring.Strict.Internal module provides stuff that may be required by advanced users of the library but isn't part of the public API
13:15:40 <edwardk> ivanm: sadly
13:16:19 <edwardk> aristid: Data.Bytestring is the 'Strict' one.
13:16:20 <aristid> edwardk: there is neither Data.Bytestring.Strict nor Date.Bytestring.Strict.Internal in the bytestring package, according to the docs
13:16:42 <aristid> edwardk: yes, i know that Data.Bytestring itself is strict, but kuffaar said that these modules would exist
13:17:44 <edwardk> where is the reference to Data.ByteString.Strict.* coming from? i missed the initial comment
13:18:11 <kuffaar> Just confusion on my part, it doesn't exist
13:18:16 <edwardk> okay =)
13:18:45 <edwardk> the Data.Bytestring.ByteString and Data.ByteString.Internal.ByteString are the same types, the latter just exports the constructor
13:19:01 <edwardk> providing access to it for those in need
13:19:21 <mm_freak> Saizan: and as far as i see my second solution does more than a region, because taken to its conclusion it would abstract away all IO stuff
13:19:27 <tolkad> wtf how did my haskell code fail with a "Segmentation Fault"
13:19:35 <tolkad> I'm not using any unsafe functions
13:19:57 <edwardk> tolkad: clearly it was taking umbrage over your earlier fixpoint shenanigans
13:20:15 <tolkad> -_- it's probably in some stupid hackage lib
13:20:24 <tolkad> because I did not use any unsafe functions myself
13:20:54 <mm_freak> tolkad: did you use some Foreign.* function?
13:21:04 <tolkad> mm_freak: nope
13:21:23 <tolkad> mm_freak: it's all standard haskell, no unsafe functions
13:21:37 <mm_freak> then it's probably really a library
13:21:40 <tolkad> no, wait it's not standard haskell
13:21:43 <tolkad> I used derive typeable
13:22:10 <mm_freak> Typeable shouldn't be unsafe
13:22:41 <tolkad> unless you use package qualified imports
13:23:13 <edwardk> using code that relies on Typeable can be unsafe if any of the Typeable instances you depend on are broken though
13:24:21 <tolkad> people should start prefixing their Typeable instances which package names if they want them to be compatible with package qualified imports
13:24:29 <tolkad> instead of just module names
13:24:49 <edwardk> tolkad: thats a somewhat disturbing thought
13:25:01 <tolkad> edwardk: what is?
13:25:12 <edwardk> and package qualified imports are generally a bad idea ;)
13:25:20 <edwardk> but point taken
13:25:52 <edwardk> the problem with such a prefix is it blows up gshow, etc.
13:27:42 <tolkad> it appears to be the HTTP library which is segfaulting
13:28:48 <kuffaar> I'm getting Segmentation faults with cabal all the time
13:28:56 <c_wraith> is it using a C binding?  both the curl and openssl bindings are very suspect, in my experience
13:29:06 <kuffaar> The usual comment from #haskell is "time to stop using Windows"
13:29:51 <mm_freak> (openssl itself is very suspect…  it's such an ugly API…)
13:29:54 <tolkad> c_wraith: idk, I'm calling the simpleHTTP function. I thought it was supposed to be simple
13:29:59 <aristid> kuffaar: no, never would anybody say that directly :)
13:30:08 <kuffaar> aristid: They have, repeatedly
13:30:27 * Twey would
13:30:34 <Twey> >.>
13:30:47 <tolkad> kuffaar: have you thought of switching to a real OS like hurd?
13:30:57 <kuffaar> Don't you mean L4?
13:31:00 <tolkad> GNU hurd is the only way you can be free
13:31:33 <kuffaar> L4 is vastly superior to Hurd
13:31:44 <kuffaar> Even the Hurd people acknowledged this and worked on a hack on top of L4
13:31:51 <kuffaar> Now known as hurd-l4
13:32:07 <arcatan> tolkad: note that there isn't complicatedHTTP...
13:32:32 <aristid> kuffaar: or you could keep using windows, but install a linux VM for haskell :)
13:32:52 <kuffaar> Already have a Linux VM running non stop
13:32:57 <kuffaar> Mostly for whois
13:33:34 <aristid> kuffaar: no, i mean locally, on your own computer.
13:33:38 <kuffaar> Yes
13:33:42 <kuffaar> <kuffaar> Already have a Linux VM running non stop
13:33:49 <aristid> i thought you mean a VPS
13:33:53 <kuffaar> o_O
13:34:04 <kuffaar> My servers, the router and my notebook are all Arch
13:34:15 <tolkad> Arch hurd?
13:34:21 <kuffaar> Arch Linux
13:34:28 <tolkad> Arch hurd is better
13:34:31 <melba>  Arch Windows
13:35:11 <Adamant> Arch Windows? you're toast, buddy.
13:35:13 <Adamant> :P
13:35:24 <aristid> kuffaar: but somehow you use haskell on the only windows computer that you have? :D
13:35:50 <kuffaar> Sure, my desktop is still Windows, for games and recording music
13:36:25 <tolkad> ok so simpleHTTP is segfaulting no matter how I use it
13:36:33 <tolkad> any ideas?
13:36:36 <lispy> kuffaar: actually, I do linux VMs on top of linux for my haskell stuff
13:36:45 <lispy> although, now that I use cabal-dev I may do that less frequently
13:37:07 <lispy> tolkad: can you run it inside gdb and find the crash point?
13:37:22 <edwardk> tolkad: i still maintain that it is the ghost of ghc past come to get you for your fix point combinator sins
13:37:53 <lispy> We will write anonymous functions for you!  You'll be in our bindings!
13:38:10 <c_wraith> tolkad: run your program from inside gdb, and when it segfaults, ask for a backtrace
13:38:12 <tolkad> sFQT_info?
13:38:40 <tolkad> #0  0x00000001001dd2a9 in sFQT_info ()
13:38:40 <tolkad> #1  0x0000000000000000 in ?? ()
13:38:41 <lispy> tolkad: That's probably info about a closure?  I'm not really sure.  Can you get more context?  Maybe put your output on a pastebin?
13:38:54 <tolkad> my output is "Segmentation Fault"
13:39:06 <lispy> I mean the gdb output
13:39:07 <tolkad> my code is:
13:39:08 <tolkad> simpleHTTP (getRequest "http://hackage.haskell.org/")
13:39:29 <lispy> You could put a breakpoint on sFQT_info() and run it again
13:39:58 <lispy> You might be able to get a better stack trace
13:40:04 <tolkad> http://pastebin.com/MSTGv9pG
13:40:07 <lispy> Heffalump: Do you have any ideas?
13:40:12 <tolkad> lispy: ok I'll try that
13:40:32 <aristid> is there a blog post on deploying haskell programs on servers?
13:40:44 <aristid> or an article
13:41:42 <tolkad> uh I'm not very good at gdb but it wont continue
13:41:44 <kuffaar> http://siyobik.info/pastebin_download.php?id=569 Couldn't match expected type `[Char]'
13:41:44 <kuffaar>  with actual type `ParsecT s u m [Char]'
13:41:44 <kuffaar>  <- trying to get Parsec working with ByteString, does anybody see what I am doing wrong? I've seen other ByteString examples on Google (there are only like 20 hits?) which used Parser String function signatures hmm
13:41:58 <tolkad> each time I type "c" it just brings me back to sFQT_info
13:42:19 <tolkad> perhaps that indicates a recursive call
13:42:40 <tolkad> uh something new
13:42:55 <tolkad> http://pastebin.com/hv99NCuy
13:43:05 <tolkad> that's a crazy address
13:43:31 <dafis> kuffaar: remove the 'return' in testParser
13:43:42 <kuffaar> Hmm
13:43:46 <tolkad> any ideas? I assume this is a problem with HTTP and not my setup
13:43:46 <dafis> kuffaar: and the 'do' is superfluous
13:44:01 <kuffaar> dafis well I'm going to add further statements soon and that will require >>
13:44:26 <kuffaar> Cheers, it works though
13:45:16 <kuffaar> Ah, but the types already match hm
13:45:19 <Heffalump> HTTP is pure Haskell, and doesn't use unsafePerformIO
13:45:25 <kuffaar> So no need for monadic injection
13:45:28 <Heffalump> so it's unlikely to be HTTP itself at fault
13:45:55 <kuffaar> Heffalump: Do you know of anything in Cabal or cabal-install that could segfault?
13:46:01 <Heffalump> no
13:46:39 <lispy> Heffalump: oh, this is not the sigbjorne bindings?
13:46:58 <Heffalump> it's not a libcurl binding, if that's what you mean
13:47:13 <lispy> Yes, I supposed that is what I meant
13:47:27 <lispy> I couldn't recall the underlying lib, but yes you're right it's curl
13:47:46 <lispy> Very weird segfault then
13:47:58 <lispy> tolkad: what version of GHC did you say you're using?
13:49:17 <kuffaar> Does cabal use forking btw?
13:49:21 <tolkad> 7.0.1
13:49:24 <tolkad> and I found something new
13:49:31 <tolkad> it only crashes if I also import Network
13:49:37 <tolkad> even if I do: import Network ()
13:50:00 <tolkad> using network 2.3, HTTP 4000.1.1
13:50:20 <tolkad> no wait nevermind
13:50:29 <tolkad> that's strange, why didn't it crash that time
13:50:32 <tolkad> maybe I just didn't notice
13:50:46 <tolkad> I'll try switching up ghc options
13:50:48 <Heffalump> so do you have a repeatable crash? Does it crash on other machines?
13:51:07 <tolkad> only have one machine
13:51:38 <tolkad> I'll try to isolate it to a seperate cabal package
13:53:31 <dafis> tolkad: works here, GHC 7.0.1, network 2.3, HTTP 4000.1.1
13:54:53 <dmajnem2> I have installed the haskell platform and I was wondering where 'cabal-install' was hidden
13:55:12 <kuffaar> dmajnem2 what OS are you on?
13:55:16 <dmajnem2> do I have to install it separate?
13:55:18 <dmajnem2> Mac OS
13:55:25 <kuffaar> It's called cabal btw
13:55:29 <kuffaar> The binary is called cabal
13:55:40 <dmajnem2> sure
13:55:49 <tolkad> ok, isolated it to a pacakge
13:55:55 <dmajnem2> I still don't have it though :P
13:56:17 <kuffaar> dmajnem2: Use mlocate/slocate? :D
13:56:24 <kuffaar> I don't know anything about Mac OS there
13:56:28 <kuffaar> For HP
13:56:50 <dafis> dmajnem2: is ~/.cabal/bin in your PATH?
13:57:09 <dmajnem2> dafis: yes, but I don't have a .cabal
13:57:34 <kuffaar> dmajnem2 if you have a working ghc you can easily compile it manually though
13:57:38 <dmajnem2> ok
13:57:58 <kuffaar> http://hackage.haskell.org/package/cabal-install
13:58:05 <kuffaar> http://hackage.haskell.org/packages/archive/cabal-install/0.8.2/cabal-install-0.8.2.tar.gz
13:58:09 <dmajnem2> yeah, I was doing that in parallel with being on IRC here
13:58:32 <dmajnem2> was wondering if I was just really confused, guess it really does not come in the HP
13:58:45 <kuffaar> I'm not sure honestly
13:58:58 <kuffaar> I'm using ghc 7 on Windows with terribly hacked packages etc
13:59:19 <tolkad> here's all my code: http://pastebin.com/AUUCzSyd
13:59:30 <kuffaar> Had to build a lot of stuff manually with patches etc
13:59:44 <tolkad> crashes with a segmentation fault when built and run using the command "cabal install"
14:00:03 <tolkad> Mac OS 10.6.6
14:00:48 <tolkad> any ideas how I can fix the problem?
14:01:36 <tolkad> or ways I can figure out what the problem is?
14:02:18 <tolkad> it's like my ghc build is sick : ( I'm very sad
14:02:28 <Heffalump> tolkad: but the crash is repeatable on your machine?
14:02:34 <tolkad> Heffalump: yeah
14:02:45 <Heffalump> perhaps try to inline the source of the packages your code uses and then cut the repro case down further
14:02:53 <dafis> tolkad: Works fine here. Linux, though.
14:02:55 <kuffaar> How do you find out where a segfault occured? It doesn't print it by default
14:02:57 <joe6> is there a way of adding this to the file: ghci -Wall  -XDeriveDataTypeable 
14:03:00 <Egbert9e9> so many monad tutorials
14:03:08 <kuffaar> Also, how do I use dynamic linking for binaries on Windows?
14:03:08 <joe6> especially the -XDeriveDataTypeable
14:03:12 <kuffaar> Egbert9e9 for good reason :p
14:03:21 <tolkad> joe6: {-# LANGUAGE DeriveDataTypeable #-}
14:03:22 <joe6> i am not sure if I could add it to the language pragma
14:03:38 <tolkad> joe6: for the -Wall you should probably put it in your .cabal file
14:04:01 <joe6> tolkad: ok, thanks
14:04:05 <tolkad> joe6: if you aren't using cabal, then you can use {-# OPTIONS_GHC -Wall #-}
14:04:11 <dafis> joe6: or {-# OPTIONS_GHC -Wall #-}
14:04:29 <Egbert9e9> kuffaar, i'm reading and reading and reading
14:04:46 <j-invariant> is haskell fun
14:04:46 <kuffaar> Egbert9e9 yeah I just stopped reading and started coding
14:04:49 <kuffaar> j-invariant no
14:05:13 <tolkad> ok, I didn't need the network dependency to make it crash
14:05:16 <Egbert9e9> kuffaar, so that's how you get what they are?
14:05:24 <tolkad> I'll try downloading HTTP source next and isolate it
14:05:52 <joe6> tolkad: dafis: thanks.
14:05:57 <Heffalump> tolkad: also, try to find someone with the same environment as you
14:06:05 <Heffalump> and/or make a fresh GHC install and see if that works
14:06:09 <kuffaar> Egbert9e9: I'm not sure, I still don't have a grasp on the subject, I tried to write some locked console output with ReaderT recently but I didn't understand how to use it really after I had written the module in the library for it
14:06:37 <Egbert9e9> magically works?
14:06:40 <kuffaar> And in the end the pople in here simply told me not to use a monad for stuff like that and to simply pass around "state stuff" in some other object in an argument]
14:06:59 <kuffaar> And to keep its monadic signature to a simple IO a
14:07:08 <kuffaar> Instead of LockedConsole IO a etc
14:08:41 <kuffaar> And now I actually managed to compile it and it works
14:08:47 <kuffaar> But it doesn't seem taht elegant
14:08:47 <HugoDaniel> how do i create an empty div with blaze html ? im doing it like H.div $ H.string ""
14:08:52 <HugoDaniel> is there a better way to do this ?
14:08:56 <tolkad> it's crashing in Network.openStream
14:09:15 <kuffaar> tolkad can you strace it to see what call is causing the problem perhaps?
14:09:24 <kuffaar> Maybe it's tied to a syscall
14:09:35 <kuffaar> Well, I guess it would be 'open' then
14:10:21 <HugoDaniel> i need a hand with blaze-html
14:11:39 <tolkad> oh wait one sec that's actually part of HTTP not network
14:13:02 <kuffaar> I've briefly checked out blaze-html but I don't know the answer to that 
14:14:20 <Heffalump> tolkad: also, see if you can find out if some version of network or HTTP introduced the crash
14:14:29 <hpc> HugoDaniel: H.string "<div></div>"?
14:14:43 <hpc> (I don't know if it escapes '<' and '>')
14:15:37 <kuffaar> Hmm I'd expect it to
14:16:00 <tolkad> uh it's crashing on "getHostAddr"
14:16:26 <kuffaar> tolkad in the syscall?
14:16:45 <hpc> the other way would be to write emptyDiv = H.div $ H.string ""
14:17:06 <kuffaar> gethostbyaddr with an invalid pointer?
14:17:28 <kuffaar> Wait, I have no idea what syscalls that uses
14:17:30 <kuffaar> If any at all
14:17:34 <kuffaar> ltrace might deliver though
14:17:40 <tolkad> kuffaar: oh wait that function is defined locally
14:20:35 <HugoDaniel> hpc, my approach seems better :)
14:20:53 <HugoDaniel> im sure there must be a way for blazehtml to recognize an empty div properly
14:21:25 <gwern> if we're discussing html, what's with the weird-ass linebreaks that the xhtml package inserts?
14:21:50 <gwern> pandoc uses it, and I get pages with html that looks like '<a href="./About.html" >Site</a >
14:21:56 <gwern> er, with 2 newlines in there
14:22:10 <gwern> '<a href="./About.html"
14:22:14 <gwern>   >Site</a
14:22:17 <gwern>   >
14:22:29 <tolkad> ok, here is where it's failing: http://hackage.haskell.org/packages/archive/network/2.3/doc/html/src/Network-BSD.html#getHostByName
14:22:35 <tolkad> somewhere in this function
14:23:06 <tolkad> I'm not sure what to do now
14:25:40 <lopex> @version
14:25:41 <lambdabot> lambdabot 4.2.2.1
14:25:41 <lambdabot> darcs get http://code.haskell.org/lambdabot
14:25:53 <ddarius> gwern: That's actually pretty common.
14:26:11 <ddarius> Well, a style similar to that is.
14:26:11 <gwern> ddarius: yes, but it's ugly and unreadable as sin, and I don't know any good reason for it
14:26:25 <gwern> nor has anyone told me one when I've complained about it before
14:27:37 <ddarius> It's to avoid having extraneous whitespace in the inner text.
14:28:13 <tolkad> so it's crashing in the c function gethostbyname I guess
14:28:19 <tolkad> I don't know why though : (
14:28:45 <gwern> ddarius: in the what?
14:29:19 <tolkad> or maybe in Network.BSD after calling gethostbyname within the getHostByName haskell function
14:29:45 <tolkad> I kind of want to use HTTP though, so how do I prevent it from crashing?
14:29:51 <Saizan> is it really a segfault or merely an exception?
14:30:29 <tolkad> it's a segfault
14:30:36 <tolkad> it prints out "Segmentation Fault"
14:30:49 <ddarius> <div>\n\t<foo />\n\t\<bar />\n</div> has a bunch of tabs and newlines in addition to foo and bar.
14:31:17 <gwern> ddarius: so how does putting more newlines inside the tags help?
14:31:25 <tolkad> Saizan: here's the gdb output: http://pastebin.com/hv99NCuy
14:31:33 <ddarius> Because inside the tag it isn't part of the inner text.
14:31:58 <ddarius> <div\n\t> <=> <div>,  <div>\n\t <=/=> <div>
14:32:07 <EvanR-work> > error "segmentation fault"
14:32:08 <lambdabot>   *Exception: segmentation fault
14:32:48 <tolkad> no it doesn't look like that
14:32:54 <tolkad> it just says "Segmentation Fault" all by itself
14:32:58 <tolkad> and exits
14:33:13 <tolkad> besides, the gdb output says it's a real crash
14:33:25 <tolkad> Reason: KERN_INVALID_ADDRESS at address: 0xfffffffffffffff8
14:33:30 <tolkad> whatever that means
14:34:00 <dafis> tolkad: Might be a 64-bit issue. IIRC, GHC can only build 32-bit binaries on Mac and all used c-libs have to be built with +universal
14:34:20 <ksf> hmmm I could generate different codepaths for those different key lengths, they're unpacked, after all.
14:34:44 <tolkad> dafis: how do I fix that so I can use HTTP?
14:35:04 <dafis> tolkad: dunno, have to ask somebody who knows Mac
14:35:04 <lopex> what version of base does lambdabot run here ?
14:35:39 <ddarius> gwern: So the options are to put the whitespace inside the tag or to output it all on one-line, modulo any whitespace explicitly in the content.
14:35:45 <dafis> tolkad: and it could be something entirely different
14:36:15 <dafis> tolkad: maybe ask on glasgow-haskell-users?
14:36:24 <dafis> or the cafe?
14:37:30 <gwern> ddarius: but to use my href example, there is no whitespace inside the content! it's just a link.
14:38:32 <lopex> anyone familiar with lambdabot setup ?
14:38:37 <ddarius> gwern: If you mean that that could be output reasonably on one line, then I agree.  I'm pretty sure xhtml's pretty printer doesn't pay attention to what the actual elements are.
14:38:43 <gwern> phooey
14:38:48 <gwern> lopex: I suppose I am
14:39:00 <gienah> lopex: I provide ebuilds for lambdabot and ghci on acid on gentoo
14:39:21 <lopex> gwern: I just installed it on solaris and any >/@run results in Terminated
14:39:31 <gwern> solaris? I didn't know modern ghcs ran on it
14:39:52 <gwern> lopex: you do have mueval installed yes?
14:39:52 <lopex> gwern: got a binary package from haskell.org
14:40:03 <lopex> gwern: oh let me check
14:40:16 <gwern> lopex: first thing I'd try, does standalone mueval work
14:40:26 <gwern> eg 'mueval -e '1+1''
14:40:57 <gienah> lopex: I provided spec files on solaris earlier, but my solaris box is broken so I can't maintain them anymore :-/
14:41:25 <gwern> lopex: these days @run merely shells out to mueval. so any problem is almost surely on the mueval end
14:41:46 <lopex> gwern: yeah, most likely then, looking..
14:44:07 <gienah> lopex: an idea to get it workking is you could update my spec files for solaris: http://pkgbuild.sourceforge.net/spec-files-extra/ based on the stuff that I provided for gentoo: http://code.haskell.org/gentoo/gentoo-haskell/ 
14:46:59 <lopex> gienah: oh
14:47:14 <lopex> gwern: well, gone a bit further
14:47:25 <lopex> unrecognized option `--timelimit='
14:47:35 <gwern> lopex: what version of mueval?
14:47:42 <aristid> Yesod should be a record type, not a type class.
14:47:48 <gwern> lopex: also, what is generating that error?
14:47:52 <aristid> (random declaration of the minute)
14:48:01 <lopex> gwern: not sure yet
14:48:13 <gwern> ...you don't know whether you are running it in the shell or not?
14:48:19 <ivanm> aristid: why?
14:48:42 <lopex>  Latest version available: 0.8.1
14:48:55 <lopex> that one is installed
14:49:16 <aristid> ivanm: because (1) it requires a hack to work (approot needs a parameter), (2) records would suffice, (3) records can be generated at runtime
14:49:36 <gwern> dunno where timelimit is coming from. lambdabot calls it as
14:49:37 <gwern>             let args = ["-E", "-XBangPatterns", "-XNoMonomorphismRestriction", "-XViewPatterns", "--no-imports", "-l", load, "--expression=" ++ src, "+RTS", "-N2", "-RTS"]
14:49:43 <ivanm> aristid: so, why not inform michael snoyman of your revelation if it bothers you that much? :p
14:49:48 <gwern> no --timelimit in there
14:50:14 <aristid> ivanm: heh, i guess i should. snoyman should also be on irc, so he can hear my declarations more easily!
14:50:14 <ivanm> > length [1..]
14:50:18 <lambdabot>   mueval-core: Time limit exceeded
14:50:42 <ivanm> gwern: ^^ looks like there's _some_ kind of time limit there though...
14:51:01 <gwern> ivanm: yeah, but that's internal
14:51:07 <gwern> default time limit
14:51:19 <gwern>                            , timeLimit = 5
14:51:46 <gwern> and besides, the option is '--time-limit', not '--timelimit'
14:52:20 <gienah> on gentoo mueval -e '1+1' fails with: Ambiguous module name `Control.Monad.Cont':   it was found in multiple packages: mtl-2.0.1.0 monads-tf-0.1.0.0
14:52:46 <gwern> gienah: not my fault! you're not supposed to have both installed AFAIK
14:53:11 <gwern> poor mueval/hint can hardly be blamed if you confuse things by having multiple definitions of a module
14:53:53 <c_wraith> You can have both installed
14:54:02 <c_wraith> You just should have at least one hidden in the compile environment
14:54:11 <c_wraith> which cabal does automatically, but other cases don't
14:54:13 <lopex> gwern: this -e expr is silent
14:54:18 <gienah> gwern: I'm a Haskell newbie, I just try to package the stuff, try to patch it to make it work
14:54:24 <gwern> lopex: ?
14:54:32 <lopex> gwern: no output
14:54:41 <gwern> odd
14:54:50 <lopex> mueval -e "1+1"
14:54:53 <lopex> and silent
14:55:02 <gwern> does it exit successfully?
14:55:19 <aristid> ivanm: snoyman got mail ;)
14:56:32 <aristid> gwern: having both mtl and monads-tf installed is not a problem usually, because you can tell ghc which packages to use. mueval of course does not have such an option
14:56:53 <lopex> gwern: oh 127
14:56:56 <gwern> aristid: well, I'd have to do some careful looking at the hint api to see whether I can even do that
14:56:59 <lopex> will try truss
14:57:06 <gwern> aristid: and rather than do that I'd just remove it from the imports
14:57:50 <aristid> gwern: that means no monad transformers :/
14:58:01 <gwern> as if you are always testing them out in lambdabot?
14:58:08 <aristid> of course.
14:58:12 <aristid> :t runStateT
14:58:13 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
14:58:31 <lopex> gwern: does it shell out to anything else ?
14:58:44 <gwern> lopex: it shells out to itself in a sense
14:58:51 <gwern> 2 processes
14:59:02 <c_wraith> gwern: I did some related stuff in the dynamic loading code for snap.
14:59:21 <c_wraith> I convinced the author of hint to add a call for my purposes.
14:59:54 <tolkad> lol I inlined all of network-2.3 into my package
15:00:03 <tolkad> now I can edit its code to find the bug
15:00:21 <lopex> gwern: oh better, Could not find module `ShowQ':
15:00:48 <gwern> yeah, need that one available
15:01:49 * gwern has dinner now
15:02:18 <Saizan> anyone has a link to an Habit implementation?
15:05:29 <HaudRex> There was a trick to select all pairs (x,y) from a list except (x, x), using concatMap and tails.
15:05:39 <HaudRex> What was it?
15:06:36 <Saizan> > let xs = [1..5] in [(x,y) | (x:ys) <- tails xs; y <- ys ] 
15:06:37 <lambdabot>   <no location info>: parse error on input `;'
15:06:44 <Saizan> > let xs = [1..5] in [(x,y) | (x:ys) <- tails xs, y <- ys ] 
15:06:45 <lambdabot>   [(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)]
15:07:36 <Saizan> that also gives you only one of (x,y) and (y,x)
15:09:38 <lopex> gwern: ok, now mueval itself works and seems to support --timelimit, but lambdabot seems to complain still
15:09:50 <lopex> is it still linked against the old one ?
15:11:20 <Guest49973> hello, why does the following compile? I would think that the comparision (==5) couldn't be applied to the array elements (which are also lists): take5­s = filte­r (==5)­ in map take5­s [[1,5­],[5],[1,1­]]
15:12:29 <stepcut> Guest49973: because you are mapping the filter function over the list of lists
15:13:20 <stepcut> Guest49973: filter (== 5) only works over a list, but when you do, map (filter (== 5)), you are apply the filter (== 5), to each of the sub-lists in the list. 
15:13:52 <stepcut> map takes5s [[1,5], [5], [1,1]] ===> [takes5s [1,5], takes5s [5], takes5s [1,1]]
15:14:42 <Guest49973> stepcut: thank you. It's somewhat unexpected for a beginner like me. Is this called deep recursion?
15:15:45 <tolkad> ok, the error is NOT in gethostbyname
15:15:45 <stepcut> Guest49973: I don't think it is generally called anything...
15:15:57 <tolkad> it's when network-2.3 calls peek
15:16:15 <tolkad> gethostbyname returns something
15:16:26 <tolkad> network-2.3 calls peek on it
15:16:28 <Guest49973> stepcut: ok sorry I was an idiot, I get it now
15:16:29 <tolkad> everything crashes
15:16:50 <stepcut> Guest49973: i think 'deep recursion' might actually be technically correct -- but people just don't usually bother to call it anything :)
15:17:26 <tolkad> it's calling peek on 0x0000000100c01100
15:17:30 <tolkad> whatever that is
15:17:35 <tolkad> then it crashes
15:17:55 <stepcut> Guest49973: no worries -- it is mind bending until you finally get it 
15:18:04 <tolkad> how do I make it stop crashing?
15:20:00 <tolkad> how do I make the peek work so I can use simpleHTTP?
15:20:08 <tolkad> btw this isn't simple at ALL
15:23:34 <gwern> lopex: as I said, lambdabot doesn't link, it shells out
15:24:06 <lopex> gwern: no the problem seems to be the timelimit option
15:24:19 <gwern> and as I said, I don't know where it's coming from
15:24:21 <lopex> gwern: mueval reports it uses --time-limit
15:24:31 <gwern> darcs lambdabot certainly isn't calling it
15:24:46 <lopex> but then it spits it doesnt know --timelimit
15:24:50 <lopex> (without the dash)
15:24:52 <lopex> strange
15:25:04 <HaudRex> liftM2 (=<<) zip (tail .tails)
15:25:05 <gwern> just grepped the source. no timelimit to be found
15:25:35 <gwern> Gracenotes: so how goes the social hackage? I was thinking of updating my summer of code page with post-mortems for last year...
15:25:42 <tolkad> ok, so I know exactly what is happening now. simpleHTTP is eventually calling Network.BSD.getHostByName which puts the hostname into a C string, and then calls the C function gethostbyname on it. gethostbyname returns the pointer 0x0000000100c01100 which Network.BSD.getHostByName tries to call peek on which triggers the Segmentation fault
15:25:43 <sohum> @hoogle (Fractional t) => t -> Int
15:25:44 <lambdabot> Data.Generics.Schemes gdepth :: GenericQ Int
15:25:44 <lambdabot> Data.Generics.Schemes glength :: GenericQ Int
15:25:44 <lambdabot> Data.Generics.Schemes gnodecount :: GenericQ Int
15:25:52 <sohum> @hoogle (Num t) => t -> Int
15:25:53 <lambdabot> Prelude abs :: Num a => a -> a
15:25:53 <lambdabot> Prelude negate :: Num a => a -> a
15:25:53 <lambdabot> Prelude signum :: Num a => a -> a
15:26:17 <Saizan> tolkad: you have found a bug in network, check its bugtracker, maybe it's a known one and there's a workaround, otherwise report it
15:27:41 <Gracenotes> gwern: chipping away at codebase in last few weeks. probably need cron job for mirroring.
15:28:05 <tolkad> Saizan: I'd rather not go into all the bug reporting stuff. I just want to make simpleHTTP work
15:28:05 <gwern> interesting. the quickcheck darcs repo seems to be incomplete
15:28:13 <gwern> tolkad: you traitor!
15:28:38 <gwern> you are breaking the solemn social contract, you scum
15:28:45 <tolkad> what social contract
15:28:48 <Saizan> tolkad: it's very unlikely that anyone here can come up with a workaround to something like that
15:29:02 <gwern> tolkad: that between a FLOSS user and the FLOSS community!
15:29:03 <Guest49973> stepcut: this tryhaskell.org site is very helpful to get started. Every programming language should have something like this.
15:29:55 <tolkad> hmm I guess I'm supposed to email somebody or other
15:30:30 <djahandarie> lispy, hackage has somehow magically fixed it self and no longer lags for me!!! Yeay!!!
15:30:31 <tolkad> I like submitting tickets though because then I can make them "blocking" and "criticaL"
15:31:08 <tolkad> Saizan: do I report the bug by emailing the maintainer?
15:32:02 <tolkad> I don't want to do this wrong and have the haskell community turn on me like rabid dogs
15:32:30 <Saizan> tolkad: http://trac.haskell.org/network/
15:33:38 <Saizan> after you register/login there should be a "new ticket" link
15:33:49 <tolkad_> So I make the "priority" "blocker"?
15:33:50 <preflex>  tolkad_: you have 1 new message. '/msg preflex messages' to read it.
15:34:14 <tolkad_> 0_0
15:34:48 <tolkad> it's a message from myself, from a year ago
15:34:53 <tolkad> the message is "what"
15:35:17 <tolkad> hmm, I guess "critical" is a better priority
15:35:22 <tolkad> I don't want them to get angry at me
15:35:34 <Kaidelong> what about:
15:35:37 <gwern> I have forgotten. what is an orphan instance?
15:35:39 <Kaidelong> mplus = on mplus
15:35:43 <Kaidelong> mzero = const mzero
15:35:49 <Saizan> tolkad: i think the maintainer is supposed to set the priority
15:35:49 <lopex> gwern: popen binary ["-E", "--timelimit=" ...
15:35:59 <lopex> gwern: in 4.2.2.1 source package
15:35:59 <Kaidelong> for instance (MonadZero r) => MonadZero (gamma -> r)
15:36:09 <Kaidelong> this would be useful to me if there are no problems with it
15:36:11 <gwern> lopex: the what? you're supposed to be using darcs
15:36:17 <Kaidelong> err, MonadPlus I mean
15:36:22 <stepcut> Guest49973: and a useful community like #haskell :)
15:36:30 <lopex> gwern: so no cabal ?
15:36:34 <gwern> ?
15:36:47 <Kaidelong> @ty on mzero
15:36:48 <lambdabot> forall b c a. (MonadPlus ((->) b)) => (a -> b) -> a -> a -> c
15:37:14 <Kaidelong> oh
15:37:20 <Kaidelong> well that's definitely wrong
15:37:24 <gwern> :t pairLength xss@(xs:_) = (length xss, xs)
15:37:25 <lambdabot> parse error on input `='
15:37:38 <gwern> :t let x xss@(xs:_) = (length xss, xs)
15:37:40 <lambdabot> <no location info>:
15:37:40 <lambdabot>     not an expression: `let x xss@(xs:_) = (length xss, xs)'
15:37:43 <Kaidelong> @ty (`on` mzero)
15:37:44 <lambdabot> forall b c a. (MonadPlus ((->) a)) => (b -> b -> c) -> a -> a -> c
15:37:53 <Kaidelong> @ty (`on` mplus)
15:37:55 <lambdabot> forall c (m :: * -> *) a. (MonadPlus m) => ((m a -> m a) -> (m a -> m a) -> c) -> m a -> m a -> c
15:38:20 <Saizan> Kaidelong: you can't quite declare that, becuase it'd be MonadPlus m => MonadPlus (\a -> gamma -> m a) where, but we don't have type level lambdas (the "\a ->")
15:38:51 <Saizan> Kaidelong: it works for Monoid, and i believe there's already an instance like that
15:39:36 <tolkad> Saizan: it let me set the priority so I put critical
15:39:56 <tolkad> maybe I should have assigned it to some people...
15:40:05 <Saizan> definitely not.
15:40:05 <tolkad> I wonder if I can edit it to assign it to everyone
15:40:36 <kuffaar> What's the Parsec equivalent of /abc(.+?)def/? You can't start out with string "abc" because then it wouldn't match sdfasfabcXXXXXXXdef whereas with RE it would match. I bet monochrom knows this
15:41:00 <Saizan> it gets assigned only when they want to signal that that particular person is working on it
15:41:13 <tolkad> kuffaar: put many anyChar too?
15:41:27 <tolkad> kuffaar: to tell it it can skip stuff
15:41:28 <Kaidelong> Oh totally wrong
15:41:54 <kuffaar> tolkad: Huh? many anyChar would just match everything right away, no?
15:42:05 <Saizan> Kaidelong: yeah, i think you want liftM2 rather than on
15:42:19 <kuffaar> And then it would fail because my string "abc" is not found after that since it's already at the end of the ByteString buffer
15:42:37 <gwern> shock! no quickcheck instance for Ordering
15:42:41 <Kaidelong> Saizan: yes I do
15:43:28 <Kaidelong> the type for that looks right but you say that I can't make an instance like that?
15:44:12 <Saizan> Kaidelong: if you try you'll see that you can't write what it would be an instance for
15:45:22 <kuffaar> tolkad: manyTill anyChar (try (string "-->"))
15:45:23 <kuffaar> Ohh
15:45:32 <kuffaar> I think I should be using something like that
15:45:50 <tolkad> kuffaar: oh, I was coming up with something long and crazy nevermind
15:45:58 <kuffaar> Haha
15:46:13 <kuffaar> I just found that one in the Haddock description
15:46:19 <kuffaar> It must be an extremely common pattern
15:46:23 <kuffaar> http://hackage.haskell.org/packages/archive/parsec/latest/doc/html/Text-Parsec-Combinator.html#v:manyTill
15:46:32 <Kaidelong> Saizan: I see. What about using typecompose?
15:46:34 <tolkad> nobody responded to my ticket yet
15:46:45 <tolkad> should I email everyone on the network dev team?
15:46:49 <kuffaar> tolkad it's probably going to take days
15:46:52 <tolkad> to make sure they know about it
15:46:53 <kuffaar> tolkad yes, do it
15:46:55 <adu> oo that's new to me
15:47:05 <Kaidelong> gtg
15:47:06 <Saizan> no, you shouldn't.
15:47:22 <tolkad> maybe I can find the maintainers phone number then
15:47:28 <Saizan> Kaidelong: then you could, but it won't be as nice
15:47:34 <kuffaar> tolkad: I started out with Haskell ago like two weeks ago and I've mailed like 7 package maintainers already
15:47:35 <kuffaar> It just works
15:47:47 <tolkad> he has a domain. I'll try his whois
15:47:55 <kuffaar> Good move
15:47:59 <tolkad> no, it's a proxy
15:48:02 <kuffaar> Snap
15:48:14 <kuffaar>  I love stalking people though, it's a hobby of mine
15:48:19 <copumpkin> o.O
15:48:22 <tolkad> I'm not stalking anyone
15:48:30 <tolkad> I just wanted to call him about the bug in network so he could fix it
15:48:34 <copumpkin> Saizan: did you see HaudRex's pairs?
15:49:03 <Saizan> copumpkin: no?
15:49:06 <HaudRex> iftA2 (=<<) zip (tail . tails)
15:49:23 <HaudRex> there's a character missing
15:49:32 <gwern> I'd be seriously creeped out if someone called me over a bug
15:49:58 <Saizan> > liftA2 (=<<) zip (tail . tails) [1..5]
15:50:00 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(1,3),(2,4),(3,5),(1,4),(2,5),(1,5)]
15:50:18 <gwern> ah, the aztec god of consecutive numbers
15:50:25 <gwern> @quote aztec
15:50:25 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
15:50:33 <Saizan> not quite
15:50:45 <adu> :t ap
15:50:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:50:51 <Saizan> weird order but cool :)
15:50:57 <gwern> after 4 undefineds, I have made ShowQ.hs compile with QC 2
15:51:05 <gwern> Mission Accomplished!
15:51:21 <adu> :t zip`ap`tail
15:51:22 <lambdabot> forall b. [b] -> [(b, b)]
15:52:12 <tolkad> gwern: would it be better to visit them in person?
15:52:27 <gwern> tolkad: depends on your aim. if you want to freak them out, it'd be much better
15:52:27 <adu> gwern: lol I would prefer an email
15:52:29 <Philippa> nah, you're supposed to teleport them to you
15:52:47 <gwern> tolkad: if you're going to go that far, might as well make a SPJ mask and learn to unicycle
15:52:51 <tolkad> gwern: no I just want to seem friendly
15:53:11 <adu> Philippa: I would certainly be inclined to fix it if I was working for someone with teleportation technology
15:53:25 <kuffaar> @quote SPJ cheerful
15:53:25 <lambdabot> SPJ says: "He used to be a cheerful young man, a productive member of society. Then he learned Haskell."
15:53:28 <gwern> <heavy breathing tGhrough flesh-colored mask>'JOHN I HAVE A BUG REPORT FOR YOU'</heavy breathing through flesh-colored mask>
15:53:28 <Philippa> adu: well, there's always the implicit threat it poses, yeah
15:53:44 <Philippa> gwern: don't forget to gift them with RPS involving themselves too
15:53:48 <adu> Philippa: threat? oo didn't think of that
15:54:03 <adu> Philippa: they could teleport my brain to Mars... 
15:54:12 <adu> Philippa: not sure what I think about that
15:54:35 <Philippa> yeah, if I discovered a way to do plausible teleportation of non-trivial amounts of mass I'd probably conveniently forget it
15:54:39 <djahandarie> palmje, oh hey, you're in here too
15:54:57 <palmje> yeah
15:55:05 <Philippa> well, unless there're major bounds on end-points, which there would be on anything even mildly plausible
15:55:07 <palmje> usually hang around here
15:55:28 <lispy> djahandarie: great!
15:55:34 <adu> Philippa: like a teleport booth or something?
15:55:57 <djahandarie> lispy, maybe it decided to like me because I started uploading packages to it :P
15:56:06 <Philippa> adu: double-ended, yeah
15:56:19 <tolkad> I was just kidding about the stalking
15:56:35 <lispy> djahandarie:  that must be it :)
15:56:43 <adu> SPLIT-U 5000 - the most advanced disintegrator/reintegrator on the planet!
15:58:17 <sproingie> adu: what about the Illidium Q36 Explosive Space Modulator?
15:59:38 <tolkad> I have found a workaround. it never calls getAddressByName if I use an IP address in the first place
16:00:04 <adu> sproingie: Q36 sounds better
16:00:49 <kuffaar> Are there no shared Haskell libraries for Windows?
16:01:21 <lispy> kuffaar: the status of that changes more than I can keep up on it :)
16:01:31 <lopex> gwern: doh stupid me, I just got a crash course on solaris, there's not even darcs there, will look for a package or will try to compile it
16:01:37 <lispy> kuffaar: I know at some point I built a dll on windows from Haskell code, but it may be broken of late
16:01:51 <kuffaar> i.e. one 1.8 MiB DLL used by 10 Haskell applications which are all < 100 KiB instead of 10 * 1.8 MiB statically linked ones?
16:01:53 <lopex> gwern: anyways, managed to run the lambdabot the dirty way for now, thank you!
16:01:55 <kuffaar> lispy hmm
16:02:00 <gwern> lopex: unfortunately lambdabot and its deps are in bad enough shape that I darest not update the hackage version
16:02:04 <gwern> which did run at some point
16:02:15 <kuffaar> I mean I have no massive need for it right now but I think it would be a good idea to support this by default
16:02:17 <lispy> lopex: darcs doesn't have a solaris buildbot, but I'm pretty sure it should compile cleanly on solaris.  If not hop over to #darcs and let us know.
16:02:23 <kuffaar> Yet I saw no DLL in the ghc 7 directories for this
16:02:36 <gwern> gaah why is it so hard to update from QC 1 to QC 2
16:03:03 <lopex> lispy: cool, though I'm still excited I got the whole thing running till this point on solaris
16:03:10 <lispy> kuffaar: ah, what you want is different than what I did in the past.  I actually built a DLL that I could link into a 3rd party program.
16:03:50 <kuffaar> I just mean like a ghc7.dll which is then used by tons of programs
16:04:07 <kuffaar> And when new versions of ghc come out you could just update that one, for example
16:04:28 <lispy> kuffaar: yeah, it makes sense.  I think there are some solvable technical hurdles that no one is looking at.  Perhaps you could figure it out and get that into the next GHC?
16:04:48 <kuffaar> lispy I saw some people on Stackoverflow who actually produced 6 KiB binaries with ghc on Linux
16:04:57 <kuffaar> As opposed to the usual 2-3 MiB
16:05:00 <kuffaar> Using shared linking
16:05:21 <stepcut> I have produced 30MB binaries before ;)
16:05:23 <kuffaar> lispy I started with Haskell two weeks ago, I have nowhere near the required knowledge to hack the ghc source
16:05:28 <stepcut> they seemed to work just fine :)
16:05:54 <kuffaar> http://hackage.haskell.org/trac/ghc/wiki/SharedLibraries/PlatformSupport?redirectedfrom=DynamicLinking
16:06:12 <lopex> gwern: yeah there were missing arrows, logict, parallel, strategies, numbers
16:06:15 <c_wraith> a 30MB binary is easy if you link in the GHC api
16:06:20 <kuffaar> "Support for -fPIC in the mangler is buggy on PowerPC and nonexistent on x86. Due to the strange way that dynamic linking is implemented, it will be very hard to generate position-dependent code that correctly links to (Haskell code in) dynamic libraries without the NCG. "
16:06:21 <gwern> lopex: quite a bit
16:06:25 <kuffaar> :/
16:08:30 <gwern> not for the first time I wonder if maybe it'd be better to permanently retire lambdabot in favor of preflex
16:14:12 <kuffaar> http://siyobik.info/pastebin_download.php?id=569 <- Error: "test" (line 1, column 59):  unexpected end of input, expecting "edit_domain_id=". What am I doing wrong in my Parsec code? Essentially I want /edit_domain_id=.+?>(.+?)</
16:14:21 <lopex> gwern, gienah: one last question, should I have any other packages installed from source repos ?
16:14:53 <gwern> dunno
16:14:55 <copumpkin> Cale: what's the fancy way you used to generate all rationals a while back?
16:15:18 <kuffaar> copumpkin: List comprehension with cantor? :p
16:15:20 <kuffaar> Cantor*
16:15:27 <copumpkin> nope
16:16:52 <Cale> It was based on a Stern Brocot tree, I think, one sec, I'll see if I can dig up that code :)
16:16:53 <gwern> haha. I have no effing idea whether these changes will actually work
16:18:36 <gwern> and because it's QC and IO and lists, just compilign doesn't tell me much
16:18:52 <Cale> @let posRationals = 1 : (posRationals >>= \x -> [1+x, 1/(1+x)])
16:18:54 <lambdabot>  Defined.
16:19:00 <copumpkin> yay, thanks
16:19:03 <Cale> @let pyth r = (x,y,z) where m = numerator r; n = denominator r; [x,y,z] = sort [2*m*n, m^2 - n^2, m^2 + n^2]
16:19:05 <lambdabot>  Defined.
16:19:10 <Cale> > map (pyth . (+1)) posRationals
16:19:12 <lambdabot>   [(3,4,5),(6,8,10),(5,12,13),(8,15,17),(7,24,25),(20,21,29),(16,30,34),(10,2...
16:19:20 <copumpkin> :)
16:19:38 <copumpkin> > fix ((1 :) . >=> \x -> [1+x, 1/(1+x)])
16:19:39 <lambdabot>   <no location info>: parse error on input `>=>'
16:19:43 <copumpkin> > fix ((1 :) >=> \x -> [1+x, 1/(1+x)])
16:19:44 <lambdabot>   [2.0,0.5,3.0,0.3333333333333333,1.5,0.6666666666666666,4.0,0.25,1.333333333...
16:19:55 <copumpkin> > fix ((0%1 :) >=> \x -> [1+x, 1/(1+x)])
16:19:55 <lambdabot>   [1 % 1,1 % 1,2 % 1,1 % 2,2 % 1,1 % 2,3 % 1,1 % 3,3 % 2,2 % 3,3 % 1,1 % 3,3 ...
16:20:02 <copumpkin> ick
16:20:14 <Cale> > fix ((1%1 :) >=> \x -> [1+x, 1/(1+x)])
16:20:18 <lambdabot>   [2 % 1,1 % 2,3 % 1,1 % 3,3 % 2,2 % 3,4 % 1,1 % 4,4 % 3,3 % 4,5 % 2,2 % 5,5 ...
16:20:30 <copumpkin> that's more like it
16:20:41 <Cale> > posRationals :: [Rational]
16:20:44 <lambdabot>   [1 % 1,2 % 1,1 % 2,3 % 1,1 % 3,3 % 2,2 % 3,4 % 1,1 % 4,4 % 3,3 % 4,5 % 2,2 ...
16:21:00 <djahandarie> Golfing the positive rationals? :P
16:21:13 <copumpkin> djahandarie: you coming tomorrow?
16:21:46 <djahandarie> I can't :( Afternoon classes the day of and Morning classes the day after
16:21:54 <djahandarie> Would need to skip one and be really tired the next day
16:22:35 <copumpkin> pff
16:31:04 <dafis> kuffaar: Your problem is that your testParser parses up to the '<', but there's still input left. Then it goes into the second round, consumes the remaining input (because there's no "edit_domain_id") and fails upon reaching the end.
16:31:44 <kuffaar> dafis: Oh so it needs to successfully consume *everything*?
16:31:55 <kuffaar> I thought it would return the matched stuff up to that point
16:31:59 <kuffaar> Instead of failing
16:32:17 <gwern> well. my show changes actually seem to work in mueval
16:32:27 <dafis> kuffaar: No, you can stop early, but a 'many p' must fail without consuming to stop early
16:32:28 <gwern> I must be doing something wrong like linking against an older version of show
16:32:46 <kuffaar> dafis: How would you translate the RE /edit_domain_id=.+?>(.+?)</ to Parsec then?
16:33:24 <gwern> my little changes can't be this right!
16:34:48 <dafis> kuffaar: you can wrap your stuff in a try, so it will leave the input after  the '<', or you can use manyTill anyChar (try (void $ string "foo") <|> eof) to consume the remaining input
16:37:24 * sohum is a total idiot
16:37:28 <sohum> seq is not >>! seq is not >>! seq is not >>!
16:37:31 <sohum> I need to get that like tattooed into my brain
16:38:27 <kuffaar> *Main> test
16:38:28 <kuffaar> Result: ["uk.to"]
16:38:30 <kuffaar> Thanks, dafis
16:38:32 <dafis> kuffaar: http://hpaste.org/43153/parse_works should do what you want
16:38:53 <kuffaar> dafis why the () btw?
16:38:58 <kuffaar> Haha that is pretty much what I did
16:39:04 <kuffaar> I just added the try up there, yeah
16:39:13 <kuffaar> Although you can use many . try $ do, I think?
16:39:46 <dafis> kuffaar: yes, you can do that too. Which () ?
16:39:55 <kuffaar> void $ manyTill anyChar $ (try $ string "edit_domain_id=")
16:40:17 <kuffaar> http://siyobik.info/pastebin_download.php?id=569 I use that now
16:40:32 <kuffaar> I usually try to use . instead of $ when possible
16:40:39 <kuffaar> And $ instead of () when possible
16:40:49 <kuffaar> It makes me feel smarter
16:40:53 <dafis> kuffaar: Oh, had some other stuff in there and forgot to delete the parentheses
16:40:58 <kuffaar> Right
16:44:20 <gwern> wow, this is great. because SimpleReflect defines [a..z] as top-level values, EVERY SINGLE VARIABLE GIVES A SHADOW WARNING
16:44:43 * gwern goes around renaming a to aa, b to bb, etc
16:46:32 <kuffaar> gwern those are terrible names anyways
16:46:38 <kuffaar> So, you had it coming!
16:46:51 * kuffaar almost never uses single letter variable names in any programming language, not even Haskell
16:46:58 <kuffaar> Except for really dense and short lambdas.
16:47:03 <kuffaar> I like my \x.
16:48:14 <gwern> I didn't write this code ಥ⌣ಥ
16:49:38 <kuffaar> Aw :/
16:56:17 <gwern> still can't believe my blind changes worked
16:58:09 * gwern frowns at IOSpec for breaking my lambdaot build
17:01:49 <Philippa> kuffaar: they also make sense as your code gets sufficiently abstract that you can't say anything about a value other than its type and its structural properties
17:03:39 <kuffaar> Philippa well, yeah, but usually people already use single letter argument names even when it's not type variables
17:03:54 <kuffaar> ParserT u m s a
17:03:56 <kuffaar> ??????????
17:04:23 <dolio> Those are all variables except ParserT
17:04:30 <dafis> ParserT userState monad stream valuetype
17:04:33 <dafis> ugh
17:06:43 <Philippa> kuffaar: I didn't say type variables :-) Though I agree Parsec could use longer default variable names
17:07:25 <Philippa> but if you're writing map, what's the point of using longer variables than (x:xs) for the head and tail of the list in the recursive case?
17:07:47 <gwern> aauuugh when did Control.Monad.State stop providing the data constructor State
17:08:00 <dafis> gwern: with mtl-2.*
17:08:01 <gwern> just when I thought I was done, they came and pulled me back in again
17:08:06 <dolio> State is now StateT Identity
17:08:26 <dafis> gwern: use state, unless you pattern match
17:08:43 <dafis> inwhich case you're hosed
17:08:49 <gwern> looks like it does
17:08:51 <gwern> inEnv (State f) = State $ λs → (fst $ f s, s)
17:09:08 <dafis> commiserations
17:09:14 <gwern> auugh
17:09:35 <dafis> gwern: depend on mtl-1?
17:09:42 <Saizan> use runState instead.
17:10:42 <gwern> Saizan: but runState looks like a function, can't use those in pattern matches
17:10:56 <Saizan> exactly
17:11:16 <Saizan> inEnv f = State $ \s -> (fst $ runState f s, s)
17:11:31 <Saizan> s/State/state/
17:11:39 <dafis> Saizan: I think the point is that gwern doesn't want to rewrite the entire lambdabot
17:12:11 * gwern was about to say, your version didn't work any better
17:12:29 <Saizan> if you're ok with s/State/state/ using a projection instead of pattern matching doesn't seem much more work
17:12:29 <bsmntbombdood> can i get a code critique?
17:12:36 <bsmntbombdood> http://hpaste.org/43154/301_redirect_checker
17:12:57 <bsmntbombdood> it takes a csv list of src_url,dest_url from stdin and verifies that src redirects to dest
17:13:17 <stepcut> happstack-ircbot + happstack-plugins + happstack-state would make for a nice basis for a lambdabot rewrite ;)
17:13:41 <gwern> stepcut: you've said that before
17:13:54 <stepcut> gwern: it's still true!
17:14:09 <gwern> yes, but at some point one wants to thwap you and say 'so write it already'
17:14:16 <gwern> gasp! lambdabot compiled!
17:14:32 <stepcut> gwern: I am working on the happstack-ircbot, happstack-plugins, and happstack-state part -- just need some more contributors ;)
17:14:47 <Saizan> i wasn't aware of -ircbot and -plugins
17:15:04 <dafis> bsmntbombdood: "Just (last $ init parts, last $ init $ init parts)" not good, case reverse parts of { (_:p:pp:_) -> Just (p,pp) }
17:15:04 <stepcut> Saizan: http://happstack.blogspot.com/2010/10/recompile-your-haskell-based-templates.html
17:15:07 <Philippa> gwern: view patterns?
17:15:11 <bsmntbombdood> i think interestingParts and uncurryList are the ugliest parts
17:15:13 <gwern> Philippa: dunno what those are
17:15:27 <Philippa> gwern: patterns that shove the value through a function first
17:15:29 <stepcut> Saizan: happstack-ircbot is actually not released yet -- though could be. It came from the ircbot that is part of the happstack.com web server
17:15:44 <bsmntbombdood> dafis, ah, nice
17:15:51 <Philippa> you'd have to rewrite all the pattern matches for now, but that'd be the extent of the changes
17:16:15 <stepcut> Saizan: there is one little thing I wanted to change before releasing it, but first I need to get the next happstack release out
17:16:38 <Saizan> stepcut: take your time :)
17:16:51 <stepcut> Saizan: no.. I really need to get the next happstack release out now..
17:17:29 <Saizan> then hurry up.
17:17:56 * hackagebot show 0.4 - 'Show' instances for Lambdabot  http://hackage.haskell.org/package/show-0.4 (GwernBranwen)
17:17:58 <stepcut> Saizan: I'm working on it :p I need to launch a site using happstack first.. hopefully tomorrow
17:18:17 <bsmntbombdood> dafis: i still think the case is ugly, it seems like it should be a one-liner
17:18:22 <gwern> phew! ok, anyone want to give it a gander with a cabal update && cabal install lambdabot?
17:18:57 <stepcut> Saizan: though it would also help if GHC 7.0.2 was released :(
17:19:56 * hackagebot lambdabot 4.2.3.0 - Lambdabot is a development tool and advanced IRC bot  http://hackage.haskell.org/package/lambdabot-4.2.3.0 (GwernBranwen)
17:21:48 <dafis> bsmntbombdood: return (reverse $ splitOn "\r\n\r\n" output) >>= \(_:p:pp:_) -> return (p,pp)
17:22:01 <dobblego> gwern, will do when I get a chance, for sure
17:22:06 <dafis> bsmntbombdood: one line, but not a pretty one
17:22:23 <gwern> dobblego: what how long could it take you to run that command?
17:22:27 <bsmntbombdood> aaah, fail in Maybe is Nothing?
17:22:39 <dobblego> gwern, do you just want to know if it installs?
17:22:46 <dafis> bsmntbombdood: yep
17:22:56 <gwern> dobblego: basically
17:23:15 <dafis> gwern: cabal: cannot configure show-0.4. It requires base <4
17:23:22 <gwern> dafis: what ghc?
17:23:28 <dafis> gwern: 7.0.1
17:23:37 <gwern> ah, ok. I don't expect it to work on ghc 7
17:23:44 <gwern> that would probably be a ton more work...
17:23:50 <gwern> 6.12 would be fine for now
17:24:34 <dafis> gwern: 6.12.3 is underway
17:24:52 <kuffaar> dafis have you tried relaxing the version constraint?
17:24:57 <kuffaar> Or does it fail for sure?
17:25:10 <kuffaar> I got a lot of old packages working with stuff like that
17:25:17 <kuffaar> Although sometimes they required patching
17:26:42 <dobblego> gwern, http://paste.pocoo.org/show/323635/
17:26:47 <dafis> kuffaar: I just wanted to check whether it builds with cabal for gwern, perhaps I'll try to relax the constraints later
17:26:48 <dobblego> 6.12.1
17:27:10 <gwern> dobblego: looks like you're missing the C devleopment library package for readline
17:27:33 <dobblego> gwern, do you happen to know which that is?
17:27:45 <kuffaar> libreadline-dev something probably
17:27:50 <gwern> dobblego: usually looks like readline-dev on debian-alike; you can look at the deps on libghc6-readline or whatever
17:33:02 <dafis> gwern: lambdabot-utils gives warnings about Control.OldException, so that will have to change for 7
17:33:10 <gwern> dafis: as does lambdabot proper
17:33:12 <dobblego> http://paste.pocoo.org/show/323640/
17:34:01 <dafis> gwern: and I got the same build error as dobblego got before
17:34:13 <lopex> lambdabot setup again ?
17:34:31 <gwern> dobblego: odd. I had that problem with an older iospec but it worked with darcs and current hackage iospec, apparently
17:40:27 <dafis> gwern: after adding TypeOperators in IOSpec, that installed, then building show failed with http://hpaste.org/43155/show04_build_error
17:40:53 <gwern> oh ffs
17:41:01 <gwern> ok, what quickcheck
17:41:47 <dafis> QuickCheck-2.1.1.1
17:41:49 <gwern> I thought I could get away without specifying which qc 2, but obviously not
17:42:00 <gwern> ok, I have 2.4.0.1 here
17:42:05 <gwern> guess I'll depend on >2.4
17:42:21 <c_wraith> please don't.  please just don't even depend on quickcheck.
17:42:42 <gwern> c_wraith: it has to.
17:43:21 <bsmntbombdood> any other comments about my code?
17:43:22 <gwern> the whole point of ShowQ is to run stuff with smallcheck or quickcheck
17:45:02 * hackagebot show 0.4.1 - 'Show' instances for Lambdabot  http://hackage.haskell.org/package/show-0.4.1 (GwernBranwen)
17:45:07 <gwern> ok, clamped the version ^
17:45:09 <gwern> try again
17:48:06 <dafis> gwern: with qc-2.4.0.1, show-0.4 built, now it's building the bot
17:48:13 <gwern> progress
17:48:39 <dafis> gwern: Plugin/Pl/Transform.hs:75:12: Not in scope: `state'
17:48:39 <dafis> cabal: Error: some packages failed to install:
17:48:39 <dafis> lambdabot-4.2.3.0 failed during the building phase. The exception was:
17:48:39 <dafis> ExitFailure 1
17:48:51 <gwern> hrm. mtl again
17:49:02 <gwern> it was building against mtl-1?
17:49:13 <gwern> stupid error on my part. should've specified
17:49:31 <dafis> gwern: yes, I have mtl-1.1.0.2 with 6.12.3
17:51:04 * hackagebot lambdabot 4.2.3.1 - Lambdabot is a development tool and advanced IRC bot  http://hackage.haskell.org/package/lambdabot-4.2.3.1 (GwernBranwen)
17:51:19 <gwern> if disk space weren't so cheap I'd feel guilty about all these uploads
17:53:17 <geheimdienst> think of all the trees that died!
17:53:42 <geheimdienst> er, wait ... think of all the magnets that were harvested?
17:54:15 <dafis> gwern: cabal: cannot configure logict-0.4. It requires mtl >=1.0.1 && <1.2
17:54:15 <dafis> For the dependency on mtl >=1.0.1 && <1.2 there are these packages:
17:54:15 <dafis> mtl-1.1.0.0, mtl-1.1.0.1, mtl-1.1.0.2, mtl-1.1.1.0 and mtl-1.1.1.1. However
17:54:15 <dafis> none of them are available.
17:55:06 <gwern> so use logict-0.4.2
17:55:57 <dafis> gwern: yes, but that means you have to restrict the logict version
17:56:08 <gwern> cabal should pick the latest by default...
17:57:13 <dafis> gwern: but what if people have an older version already installed? (I had)
17:57:42 <dcoutts_> cabal picks installed versions within range, or the latest available version otherwise
17:57:45 <dcoutts_> by default
17:58:04 <gwern> dcoutts_: so what am I supposed to do here?
17:58:56 <dcoutts_> gwern: sorry, I've not been following the detail, what's the issue exactly?
17:58:58 <dafis> gwern: let lambdabot depend on logict >= 0.4.2
17:59:17 <gwern> dcoutts_: lambdabot needs mtl>2. only version of logict that allows that is 0.4.2
17:59:31 <gwern> but aside from the dep, lambdabot uses any logict
17:59:40 <gwern> (guess it hasn't changed very much over the years)
17:59:56 <dcoutts_> gwern: ok, and cabal is not smart enough to pick the right version of logict?
18:00:01 <gwern> dcoutts_: apparently?
18:00:52 <dcoutts_> sigh, yes, it's not using the info available
18:01:05 * dcoutts_ thinks he knows how to change the dep resolver to solve it
18:01:08 <dafis> dcoutts_: if there's already an older logict installed, it tries to use that because there's no range given
18:01:09 <dcoutts_> but that's for another day
18:01:34 <dcoutts_> dafis: right, though if it applied the constraints it's got, it could eliminate 0.4.1
18:01:41 <dcoutts_> but that's not what the algorithm does currently
18:02:12 <dcoutts_> gwern: so yes, you can blame cabal for that one and the workaround is to add the logict >= 0.4.2 constraint
18:02:20 <gwern> hah
18:02:26 * gwern will quote you on that
18:02:36 <dafis> gwern: building the bot, currently [17 of 79] Compiling Plugin.Quote.Text
18:04:07 * hackagebot lambdabot 4.2.3.2 - Lambdabot is a development tool and advanced IRC bot  http://hackage.haskell.org/package/lambdabot-4.2.3.2 (GwernBranwen)
18:06:14 <gienah> gwern: thanks for working on lambdabot!
18:06:21 <gwern>  bleh
18:06:37 <gwern> I can't even remember why I started with mueval and lambdabot
18:06:58 <gienah> because they are cool :-)
18:07:12 <geheimdienst> @vixen are you cool?
18:07:14 <lambdabot> yup, i'm cool :)
18:07:19 <geheimdienst> see?
18:07:57 <gwern> vixen is a notorious liar
18:08:09 <gwern> @vixen is it true you lie to me a lot?
18:08:10 <lambdabot> yeah, it is
18:08:17 <geheimdienst> @vixen are you a liar?
18:08:18 <lambdabot> i truely am
18:08:21 <Philippa> @vixen is it true you never lie to gwern?
18:08:21 <lambdabot> yeah, it is
18:08:26 <gwern> see?
18:08:29 <gwern> a proven liar
18:08:58 <geheimdienst> gwern, but if she says "yeah" when asked "do you lie to me", and that statement was a lie?
18:09:02 <dafis> gwern: built and installed, seems to work
18:09:24 <gwern> dafis: great
18:09:31 <gwern> geheimdienst: then it's still true
18:09:43 <gwern> because she contradicted herself
18:10:05 <geheimdienst> ... suppose she made an honest mistake?
18:10:34 * gienah is working on packaging lambdabot for gentoo
18:11:40 <gwern> really, what's the point of packaging lambdabot these days
18:11:44 <dafis> gwern: I think the TypeOperators thing in IOSpec should be taken care of, though
18:11:49 <gwern> all the useful tools are standalone - hlint, hoogle, mueval
18:14:21 <gienah> @vixen I like pointless, pointfree, running lambdabot in ghci on acid, what do you like?
18:14:21 <lambdabot> sure, i definitely don't hate
18:23:26 <gwern> gienah: @pl is all that lambdbaot does for you?
18:23:41 <gwern> fine, I'll split it out as a standalone package and then officially deprecate lambdabot :)
18:24:17 <gwern> my long weary labors, finally over!
18:24:44 <copumpkin> gwern: what do you have against lambdabot?
18:24:52 <gwern> copumpkin: it's old crufty code
18:24:56 <copumpkin> oh, fair enough
18:25:05 <Bynbo7> we need a lambdabot'!
18:25:08 <roconnor> heh, after reading the first page of ewd1036, I feel like Dijkstra is about to talk about monads. :)
18:25:10 <tolkad> I found more info about the network bug
18:25:15 <Bynbo7> @vixen we're replacing you
18:25:15 <lambdabot>  key
18:25:18 <tolkad> it's calling peekArray0 nullPtr b
18:25:21 <Bynbo7> she agrees!
18:25:26 <copumpkin> can you put djinn, free, un(pl), un(do) in?
18:25:37 <tolkad> where b is the result of peeking off a byte
18:26:02 <tolkad> 4 bytes actually
18:26:03 <tolkad> wait
18:26:14 <tolkad> that's the problem maybe? its not peeking off enough bytes
18:26:34 <tolkad> because on 64 bit an address is 8 bytes
18:26:37 <tolkad> hmm
18:27:14 <copumpkin> preflex: seen chrisdone
18:27:14 <preflex>  chrisdone was last seen on #haskell 35 days, 8 hours, 5 minutes and 39 seconds ago, saying: Good evening.
18:27:17 <tolkad> oh, that's an offset not a number
18:27:22 <copumpkin> @ask chrisdone what happened to your IRC log search engine btw?
18:27:23 <lambdabot> Consider it noted.
18:27:54 <gwern> shoot, I just realized I haven't seen any hawiki changes in rss in yonks
18:28:03 <gwern> how much vandalism have I missed?
18:29:28 <roconnor> gwern: very intresting experience in prediction markets?  Why did you leave intrade? --> #haskell-blah
18:29:41 <gwern> roconnor: ?
18:29:54 <tolkad> where is #peek defined?
18:30:42 <roconnor> gwern: with regards to http://www.gwern.net/Prediction%20markets.html
18:31:03 <gwern> roconnor: http://www.gwern.net/Prediction%20markets.html#cashing-out links to http://lesswrong.com/r/discussion/lw/3l2/2011_intrade_fee_changes_or_intrade_considered_no/
18:31:17 <gwern> guess the link was too subtle and I should inline that
18:31:21 <dafis> tolkad: peek is a member of Foreign.Storable.Storable
18:31:52 <tolkad> dafis: it's #peek, not just peek
18:32:14 <liyang> tolkad: #peek is defined as the CPP macro hsc_peek
18:32:21 <roconnor> gwern: hmm your hyperlinks are invisible to me
18:32:29 <gienah> gwern: I guess yes I mainly use @pl @pointful : compukin knows more than me so this might be a more complete list: djinn, free, un(pl), un(do)
18:32:45 <gwern> roconnor: really? they should be underlined
18:32:46 <liyang> tolkad: in $(locate template-hsc.h)
18:33:08 <gwern> gienah: djinn is standalone already, dunno about free/pl/undo
18:33:17 <Apocalisp> @hoogle (a -> b) -> (a -> f b -> b) -> f a -> f b
18:33:18 <djahandarie> pl is standalone also
18:33:18 <lambdabot> No results found
18:33:32 <roconnor> gwern: nope, ... granted I've disabled underlining of links in my preferences, since being blue was adequate for me (I have a colour LCD!).
18:33:32 <djahandarie> free... is from a paper but I don't know if there is a standalone lib for that
18:33:41 <tolkad> OMG
18:33:46 <tolkad> I found the problem!
18:33:49 <dafis> tolkad: where does #peek occur, I can only see it in a comment line
18:33:52 <tolkad> I know why network isn't working
18:34:00 <dafis> why?
18:34:31 <tolkad> in Network.BSD it uses #peek. in the generated haskell file that turns into code like this: ((\hsc_ptr -> peekByteOff hsc_ptr 4)) p
18:34:40 <tolkad> but it's assuming 32 bit offsets for some reason
18:34:49 <tolkad> if I change them to 64 bit offsets, it works
18:34:53 <gwern> roconnor: oh. well... I don't really know what I should do if you disabled it. I don't want to force colored links. is there some css magic I should use?
18:35:17 <tolkad> I don't know why though. shouldn't #peek know I am compiling as 64 bit
18:36:27 <tolkad> dafis: do you know how to fix this?
18:36:39 <Apocalisp> what's this recursion pattern called? (a -> b) -> (a -> Maybe b -> b) -> [a] -> [b]
18:36:58 <dafis> tolkad: off the top of my head: no, sorry
18:37:11 <gwern> Apocalisp: looks like a map combined with one of the Data.Maybe functions
18:37:51 <gwern> @hoogle (a -> b) -> (a -> Maybe b -> b)
18:37:52 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
18:37:52 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
18:37:52 <lambdabot> Data.Generics.Aliases mkQ :: (Typeable a, Typeable b) => r -> (b -> r) -> a -> r
18:38:13 <gwern> and then map it over the list [a]
18:38:17 <Apocalisp> gwern: It's like a map where each element is combined with a fold of the tail
18:39:11 <gwern> Apocalisp: that's pretty weird and if my map . maybe isn't what you want, the type sig is not enough
18:39:18 <roconnor> gwern: well, if I were you, if you are going to set the colour of links to black, you should also explicitly set it to underline.
18:39:32 <roconnor> gwern: so if I were you I'd add text-decoration: underline to your CSS for a.
18:40:30 <gwern> I'll give it a try, as soon as hakyll reinstalls...
18:40:55 <gwern> ...and pandoc
18:41:28 <gwern> oh, a fiction edition of The Monad.Reader
18:41:59 <tolkad> ok hsc_peek uses pointer arithmetic on the null pointer to determine offset
18:43:16 <tolkad> but how would template_hsc be compiled as 32 bit instead of 64 bit if ghc is compiling as 64 bit...
18:46:03 <c_wraith> tolkad: hsc's macros are all just C macros that you can look up in the build directory of the project.  Maybe one of the hsc macros is assuming 32-bit somewhere?
18:46:36 <Saizan> are you sure you've a 64-bit ghc on OSX 10.6? i thought they didn't manage to build one yet
18:47:12 <tolkad> uh how would I test if a binary is 64 bit?
18:47:24 <tolkad> I know the code works if I change the offsets to 64 bits
18:47:28 <Eridius> run `file` on it?
18:47:52 <tolkad> 64-bit
18:48:07 <copumpkin> file `which ghc`
18:48:22 <Eridius> copumpkin: that will say "POSIX shell script"
18:48:23 <Eridius> :P
18:48:34 <copumpkin> fine :)
18:48:39 <tolkad> I'll figure it out
18:49:05 <Saizan> http://obvioushints.blogspot.com/2009/09/running-haskell-ghc-on-snow-leopard.html <- you used to need to do this, not sure if it's still valid for ghc 7
18:49:11 <Eridius> `file /Library/Frameworks/GHC.framework/Versions/612/usr/lib/ghc-$VERSION/ghc` where $VERSION is the version of ghc
18:49:30 <gwern> oh, there's a san francisco hackathon coming up
18:49:56 <gwern> maybe I should go
18:51:06 <Eridius> `file /Library/Frameworks/GHC.framework/Versions/612/usr/lib/ghc-$(ghc --version | sed -E -e 's/.+ //')/ghc`
18:51:20 <tolkad> copumpkin: 64-bit
18:51:48 <tolkad> took me a while to realize it defined $executablename twice in that shell script
18:53:00 <tolkad> Saizan: ok I'll try that
18:54:41 <copumpkin> I don't think it's necessary anymore
18:55:39 <c_wraith> Saizan: that hasn't been necessary since 6.10.  6.12 included those hacks in the distribution
18:57:26 <Apocalisp> @type let myFold f g [] = []; myFold f g xs = zipWith g xs (tails (map f xs)) in myFold
18:57:27 <lambdabot> forall a a1 c. (a -> a1) -> (a -> [a1] -> c) -> [a] -> [c]
18:57:34 <gwern> ouch! the hackathaon is 39 miles from my sister's SF apartment
18:58:48 <tolkad> so uh how do I fix this? was this an oversight in which parts of ghc need to run as 64 bit?
18:59:05 <tolkad> is there any way I can force template_hsc to compile as 64 bit?
19:00:49 <copumpkin> tolkad: you'll probably have better luck in #ghc when GMT tends to be awake
19:01:43 <tolkad> it's like 3am there I guess
19:01:51 <dafis> yup
19:02:28 <tolkad> until then I can hack up my network code
19:02:36 <Scriptor> don't tell me the whole ghc team has healthy sleep schedules :p
19:02:37 <tolkad> I closed the network ticket
19:02:59 <Apocalisp> > myFold (\x -> if x then 1 else 0) (\x y -> if x then (sum y) else 0) [True,False,True,True,True,True,False,False,True]
19:03:01 <lambdabot>   [6,0,5,4,3,2,0,0,1]
19:04:55 <djahandarie> Sleep?
19:05:12 <dafis> djahandarie: man sleep
19:05:25 <djahandarie> fix sleep
19:05:41 <geheimdienst> > fix sleep
19:05:42 <lambdabot>   Not in scope: `sleep'
19:06:33 <gwern> doncha know GHC HAQ is composed of family men
19:07:37 <Philippa> gwern: they all lost to Guile?
19:08:15 <dolio> They couldn't defeat Sheng Long, either.
19:08:30 <gwern> sad to say I don't understand the references there
19:09:18 <Philippa> gwern: Street Fighter. One of Guile's SF2 win quotes was "Go home and be a family man"
19:09:49 * geheimdienst is not a family man, but if he was, he would cunningly set his sleep schedule so that when he's awake, no one else is. only way to get anything done.
19:10:00 <gwern> oh. that makes sense
19:10:58 <Saizan> geheimdienst: and then browse through lolcats anyway?:)
19:11:10 <kuffaar> geheimdienst haha
19:11:19 <geheimdienst> Saizan: yes, as i said, "get things done"
19:11:27 <gwern> easier said than done
19:11:34 <kuffaar> Hahaha
19:11:48 <warrenharris> anyone know if there is a way to direct cabal to statically link with a library (I'd like to do this for libdb-5.1.a -- native methods for the BerkeleyDB package)
19:12:55 <kuffaar> No idea
19:13:12 <kuffaar> warrenharris have you checked out packages on HackageDB which might do something like that?
19:13:23 <kuffaar> Although I don't know why you would even want static linkage over dynamic one
19:13:47 <warrenharris> so I can give the executable to someone without them having to install macports, etc
19:15:08 <kuffaar> warrenharris if all else fails you can try to do it without cabal
19:15:59 <kuffaar> <kuffaar> warrenharris if all else fails you can try to do it without cabal
19:16:10 <gwern> warrenharris_: I think you just look up the static linking options and stick them in ghc-options:
19:16:17 <kuffaar> warrenharris: I just googled some mailings lists, you might have to pass the raw stuff in ghc-options
19:16:30 <kuffaar> -optl-static
19:16:45 <warrenharris_> hmm... I tried that, but got some weird error
19:17:06 <warrenharris_> ... /Developer/usr/bin/ld_classic: can't locate file for: -lcrt0.o
19:17:12 <tolkad> yay, I hacked up my own version of network and got it working.
19:22:28 <warrenharris> kuffaar: looks like it is unsupported: http://stackoverflow.com/questions/844819/how-to-static-link-on-os-x
19:22:58 <kuffaar> Sucks
19:23:24 <gwern> roconnor: ok, try gwern.net now, remembering to force reload
19:23:27 <warrenharris> thanks for your help anyway :-)
19:23:47 <geheimdienst> warrenharris: an alternative might be to make an .app bundle. you can stick additional libraries in there afaik
19:23:50 <roconnor> gwern: that is better for me
19:24:17 <gwern> hopefully now you'll see all the crucial links I lovingly add to my pages :)
19:24:39 <warrenharris> geheimdienst: is there a way to do that with cabal?
19:24:44 <roconnor> gwern: thanks
19:25:32 <Axman6> i don't suppose anyone here works with/on takusen do they?
19:25:53 * stepcut is happstack-state all the way
19:26:41 <kuffaar> Axman6 I do!
19:26:50 <Axman6> oh really!
19:26:51 <kuffaar> I am going to use it for PostgreSQL access in my web dev framework
19:26:54 <geheimdienst> warrenharris: i doubt it. you'd have to make a directory something.app with a few subdirectories. iirc the binary goes in something.app/Contents/MacOS/bin/ or similar
19:27:05 <Axman6> heh, that's basically what we're using it for :)
19:27:14 <warrenharris> found this: http://hackage.haskell.org/packages/archive/cabal-macosx/0.1.1/doc/html/Distribution-MacOSX.html
19:27:42 <Axman6> kuffaar: i've been thinking that there needs to be a much nicer type safe framework for defining tables
19:27:44 <kuffaar> Axman6 so have you discovered some terrible bugs or why are you asking about it?
19:27:44 <geheimdienst> oh! yeah that might help, actually
19:27:57 * digitteknohippie needs to refind his motivation for learning more haskell, and help overcoming his impatience.
19:28:00 <kuffaar> Tbh usually I just define them in .sql files which I \i in psql.
19:28:01 <tolkad> is it possible to use the unix package on unix but not use it on windows?
19:28:04 <gwern> man, where the heck does the xhtml repo live? nothing listed in metadata on hackage, nothing on c.h.o
19:28:24 <kuffaar> tolkad you mean in a cabal file? Yes, check out the unix-compat.cabal for switches like that
19:28:30 <Axman6> at the moment we have our own Table type, which defines the types of the columns, but there's no way to check whether a query is typesafe or not
19:29:00 <kuffaar> I just installed Takusen so far, I haven't even used it yet, I have no idea how it works
19:29:03 <gwern> xhtml isn't on github either
19:29:04 <gwern> hm
19:29:31 <Axman6> i'm thinking that it could possibly be done using data families
19:29:35 <kuffaar> I started with Haskell only two weeks ago and I just managed top set up a concurrent SCGI server so far
19:29:41 <tolkad> xhtml is a standard, not a project
19:29:50 <tolkad> so it wouldn't make sense for it to be on github
19:29:53 <kuffaar> And I haven't even implemented the SCGI query parsing yet
19:30:01 <tolkad> it makes much more sense for it to be on the w3c website
19:30:03 <Axman6> tolkad: i think he means the haskell package
19:30:06 <kuffaar> And today I grasped Parsec, I think, for some HTML parsery
19:30:08 <kuffaar> Yeah
19:30:10 <kuffaar> He did
19:32:42 <tolkad> at some point it was at
19:32:43 <tolkad> http://www.cs.chalmers.se/~bringert/darcs/haskell-xhtml/
19:32:46 <tolkad> maybe it still is
19:32:53 <tolkad> I'm not exactly sure how darcs works
19:33:02 <tolkad> I get redirected if I try to load that in my web browser
19:33:17 <tolkad> try to get that url with darcs though
19:33:34 <gwern> no, it's bad even with darcs
19:33:35 <tolkad> gwern: that help?
19:33:37 <tolkad> oh
19:33:38 <gwern> darcs is regular http
19:33:43 <gwern> so redirection like that kills it
19:34:19 <tolkad> well it used to be there
19:34:30 <tolkad> maybe he removed all his repos and it doesn't have a home anymore
19:34:57 <Zao> gwern: My httpd had mod_speling active site-wide in the past. Great fun when darcs relies on getting 404s.
19:35:13 <gwern> Zao: mod what?>
19:35:25 <Zao> gwern: speling. It autocorrects mistyped URLs.
19:35:27 <Axman6> speling, fixes typos in urls
19:35:30 <Zao> Spelling intended :D
19:35:36 <gwern> ...huh
19:35:46 <tolkad> Zao: couldn't they send a 404 and a landing page?
19:36:09 <tolkad> Zao: or was it just badly written
19:36:51 <tolkad> Zao: oh I guess mod spelling doesn't offer them suggestions, it redirects?
19:36:51 <Zao> tolkad: It's a proper canonical Apache module. I'm sure that there's knobs to tune the behaviour but the default is a redirect or transparent serving or something.
19:37:07 <Zao> tolkad: I believe it has a disambiguation page, actually.
19:37:24 <tolkad> I see how that might have niche usecases but it definitely shouldn't be implemented sitewide
19:38:04 <Zao> http://www8.cs.umu.se/kurser/5DV123 <- index of pages; http://www8.cs.umu.se/kurser/5DV9001/ <- redirect
19:38:27 <Zao> If anyone happens upon it site-wide, 'CheckSpelling off' in .htaccess disables it.
19:38:59 <kuffaar> Axman6 that sounds like a good ida
19:39:01 <kuffaar> idea*
19:39:23 <Zao> tolkad: Said httpd configuration also rather violently sends headers forcing latin-1 encoding too :D
19:39:30 <Zao> Hysterical raisins, I guess.
19:39:38 <Axman6> kuffaar: god help me if I have yp end up writing it though :P
19:39:59 <Axman6> up*
19:40:09 <Axman6> uh, to even
19:40:13 <Axman6> >_<
19:40:26 <kuffaar> Is it that difficult?
19:40:38 <kuffaar> It's probably beyond my current skill level haha
19:40:54 <tolkad> Zao: unless you are writing a site for really really stupid users, like maybe the hotmail homepage or something, you should send a 404 and if you want to, a list of suggested alternatives.
19:41:29 <Axman6> kuffaar: heh, i'd say it probably is too
19:41:43 <kuffaar> You mean it is for you?
19:41:50 <kuffaar> Too difficult?
19:42:01 <Axman6> possibly
19:42:05 <tolkad> Zao: sorry, didn't mean to direct that at you
19:42:10 <Axman6> i haven't thought about it enough to be able to tell
19:44:15 <kuffaar> http://www.cse.chalmers.se/alumni/bringert/publ/haskelldb/haskelldb-db-2005.pdf
19:44:19 <kuffaar> urgh, going to sleep
19:51:13 <Kaidelong> does anyone know a typeclass for things with "fromMaybe" like functions?
19:51:44 <Kaidelong> @ty fromMaybe
19:51:46 <lambdabot> forall a. a -> Maybe a -> a
19:52:11 <Kaidelong> Partial does not seem to be it
19:52:21 <mm_freak_> Kaidelong: for functions like 'maybe' and 'foldr' there is the Foldable type class
19:52:25 <lpsmith> Kaidelong, well,  maybe and either are basically disjunctions on an algebraic type
19:52:38 <lpsmith> @ty either
19:52:39 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
19:52:56 <lpsmith> @ty maybe
19:52:57 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:53:01 <lpsmith> @src Maybe
19:53:01 <lambdabot> data Maybe a = Nothing | Just a
19:53:04 <lpsmith> @src Either
19:53:04 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
19:53:11 <tolkad> I started running into more segfaults -_- is there any way to force ghc to compile as 32 bit?
19:53:15 <gwern> Kaidelong: ah, the old m a -> a question eh?
19:53:21 <Kaidelong> lpsmith: I'm thinking of this specifically in the context of safely merging partial values
19:53:29 <gwern> I think the last time I asked that I was told it was something like the Pointed typeclass
19:53:31 <tolkad> I tried the thing someone said in here but it makes ghc say:  suffix or operands invalid for `push'
19:53:38 <Kaidelong> gwern: a -> m a -> a isn't quite as powerful as m a -> a
19:53:40 <Kaidelong> although
19:53:40 <lpsmith> Kaidelong, Data.Monoid?
19:53:44 <Kaidelong> you could use undefined
19:53:50 <Kaidelong> as the first argument
19:53:50 <Axman6> Kaidelong: i believe those are either comonads or copointeds ... or something
19:53:57 <Axman6> this is not my area :P
19:54:06 <geheimdienst> copoimpkins
19:54:09 <lpsmith> tolkad, what version of GHC,  and does your application use any libraries that depend on C code?
19:54:17 * Kaidelong thinks what he is doing has more in common with a monad than a comonad...
19:54:35 <Kaidelong> oh wait
19:54:37 <Kaidelong> no
19:54:39 <Kaidelong> maybe not
19:54:43 <Kaidelong> comonads can join just fine
19:54:59 <Kaidelong> maybe I want something like a ComonadPlus
19:55:27 <BMeph> It's an algebra you want.
19:55:31 <djahandarie> The can't join, they can cojoin
19:55:38 <djahandarie> aka duplicate
19:55:45 <djahandarie> w a -> w (w a)
19:55:56 <Kaidelong> djanhandarie: extract
19:56:01 <tolkad> lpsmith: ghc 7.0.1, and yes, network
19:56:20 <Axman6> tolkad: are you using the 64 bit ghc?
19:56:20 <tolkad> lpsmith: which was failing to build because of hsc stuff generating 4-byte offsets
19:56:22 <Kaidelong> (w a -> a) -> (w (w a) -> w a)
19:56:24 <tolkad> Axman6: ye
19:56:26 <Kaidelong> by specialization
19:56:29 <tolkad> yes*
19:56:30 <Axman6> on OS X?
19:56:32 <djahandarie> And yeah, an f a -> a is just an algebra
19:56:40 <tolkad> yes, I downloaded it from the ghc website
19:56:54 <Axman6> if so, you should remember that it isn't an official build, and likely does have lots of these bugs
19:57:12 <tolkad> Axman6: well the bug prevents me from any code relying on hsc stuff
19:57:18 <tolkad> from using*
19:57:21 <lpsmith> yeah,  I started playing with GHC 7.0.1,  but I decided to stick with 6.12.3 for the time being
19:57:40 <tolkad> I'd like to just force ghc to compile as 32 bit until it's fixed
19:57:41 <Kaidelong> the two methods I am using are "alternative :: a -> p a -> a" and "undef :: p a"
19:57:54 <lpsmith> ghc 7 is exciting,  but probably a little too new
19:58:13 <Kaidelong> I'm also trying to figure out how to make it a monoid
19:58:13 <Kaidelong> perhaps something like
19:58:18 <Kaidelong> mplus `on` alternative undefined 
19:58:34 <Kaidelong> oh no
19:58:37 <dobblego> Copointed a =>
19:58:40 <Kaidelong> mplus `on` alternative mzero
19:58:56 <BMeph> GHC 7 is deliberately "too new"; it's only out, so that package devs can get their packages ready for it.
19:58:59 <gwern> lpsmith: didn't work for me the other day - wound up with conflicting `directory` and other such brokenness
19:59:23 <gwern> so I removed ghc 7 and went back to 6.12. this is one dev that won't be updating packages for 7 any time soon
19:59:26 <tolkad> will GHC-7.0.1-i386.pkg work on snow leopard?
19:59:47 <Axman6> yes
20:00:03 <Axman6> you know OS X runs 32 and 64 bit binaries completely natively right?
20:00:20 <tolkad> yeah but the website says that file is for 10.5
20:00:30 <Axman6> not much changed in 10.6
20:00:52 <Axman6> well, not much that would affect this, and Apple are fairly good at backwards compatibility in my experience
20:01:12 <gwern> compared to what? Windows?
20:01:25 <djahandarie> http://romvf.wordpress.com/2011/01/19/open-letter/ Polynomial Time 3-SAT?
20:01:30 <lpsmith> tolkad, though I'm a little suprised you've been having so much difficulty with segfaults using network,  because it's such an important package I would expect it to be a bit more robust
20:02:06 <lpsmith> (though I just discovered a segfault problem in HDBC-postgresql is a much worse problem than when I first discovered it a while ago.)
20:02:26 <gwern> djahandarie: so, want to make a bet that said proof will be accepted and p=np?
20:02:40 <djahandarie> No I'll leave it to scott
20:02:49 <gwern> drat
20:02:56 <joe6> guys: any thoughts on this code, please? http://codepad.org/2RG67cgd
20:02:59 <Kaidelong> djahandarie: that would surprise me very much.
20:03:09 <Kaidelong> could be a repeat of the whole cold fusion thing
20:03:14 <gwern> djahandarie: I'll give you 100:1 odds! that'd be a nice return on investment
20:03:17 <joe6> i am trying to use gzipWithQ, my first attempt at SYB
20:03:23 <tolkad> lpsmith: it's hsc itself that's broken
20:03:31 <djahandarie> He does have code though...
20:03:36 <Axman6> lpsmith: he's using an unofficial compiler that almost certainly hasn't been tested properly for these things
20:03:43 <int80_h> anyone here use haskell platform with mingw?
20:03:47 <lpsmith> oh
20:03:49 <tolkad> lpsmith: the #peek calls in BSD.hsc are being translated to code using 4-byte offsets
20:03:56 <Kaidelong> oh, well the paper is free
20:03:59 <Kaidelong> let me look at it
20:04:05 <lpsmith> OS X.  Axman6, fair enough :)
20:04:23 <tolkad> lpsmith: so it's not a problem with network at all, it's hsc
20:04:26 <lpsmith> tolkad, yeah that'd be a problem
20:05:06 * lpsmith hasn't used OS X in a few years
20:05:18 <Apocalisp> @type let recurse g [] = []; recurse g (x:xs) = g x (recurse g xs) : (recurse g xs) -- What is this recursion pattern?
20:05:19 <lambdabot> <no location info>:
20:05:20 <lambdabot>     not an expression: `let recurse g [] = []; recurse g (x:xs) = g x (recurse g xs) : (recurse g xs)'
20:05:29 <lpsmith> Ubuntu on a laptop works pretty well these days,  and non-apple hardware is a great deal cheaper
20:05:29 <int80_h> I'm trying to figure out how to give mingw the right PATH for gcc so cabal can start working
20:05:30 <Apocalisp> @type let recurse g [] = []; recurse g (x:xs) = g x (recurse g xs) : (recurse g xs) in recurse
20:05:31 <lambdabot> forall t a. (t -> [a] -> a) -> [t] -> [a]
20:05:46 <Axman6> Apocalisp: lookjs a little like scanr
20:05:52 <Apocalisp> @src scanr
20:05:52 <lambdabot> scanr _ q0 []     =  [q0]
20:05:52 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
20:05:52 <lambdabot>     where qs@(q:_) = scanr f q0 xs
20:05:59 <Axman6> :t scanr
20:06:01 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
20:06:19 <Apocalisp> like scanr only moreso
20:06:25 <BMeph> :t scanr1
20:06:26 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
20:06:30 <Axman6> more scannery
20:06:54 <BMeph> Coen Scannery? ;þ
20:07:35 <Axman6> Apocalisp: it also looks like it would have horrible performance :P
20:08:04 <Axman6> @let let recurse g [] = []; recurse g (x:xs) = g x (recurse g xs) : (recurse g xs)
20:08:04 <lambdabot>   Parse error: ;
20:08:12 <Axman6> @let recurse g [] = []; recurse g (x:xs) = g x (recurse g xs) : (recurse g xs)
20:08:14 <lambdabot>  Defined.
20:08:17 <BMeph> Apocalisp: I'm tempted to say "apomorphism", but I'm not sure.
20:08:17 <Axman6> :t recurse
20:08:19 <lambdabot> forall t a. (t -> [a] -> a) -> [t] -> [a]
20:08:36 <Axman6> > recurse (\x l -> x + sum l) [1..3]
20:08:38 <lambdabot>   [9,5,3]
20:08:41 <Axman6> > recurse (\x l -> x + sum l) [1..10]
20:08:44 <lambdabot>   [4609,2305,1153,577,289,145,73,37,19,10]
20:09:02 <Axman6> @undef
20:09:34 <Axman6> @let recurse g [] = []; recurse g (x:xs) = let res =  recurse g xs in g x res : res
20:09:35 <lambdabot>  Defined.
20:09:38 <Axman6> > recurse (\x l -> x + sum l) [1..10]
20:09:40 <lambdabot>   [4609,2305,1153,577,289,145,73,37,19,10]
20:09:59 <Axman6> > recurse const [1..10]
20:10:01 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
20:10:33 <Axman6> > recurse (const sum) [1..10]
20:10:35 <lambdabot>   [0,0,0,0,0,0,0,0,0,0]
20:10:39 <Axman6> heh
20:17:32 <joe6> where is the Data.Data module defined?
20:18:10 <joe6> I am trying to look through the SYB - code and this particular  module is not in the syb tar package
20:18:59 <Axman6> it's possible it comes with ghc
20:19:01 <helgikrs_> http://hackage.haskell.org/packages/archive/base/4.3.0.0/doc/html/Data-Data.html
20:19:04 <helgikrs_> this?
20:19:07 <sproingie> isn't syb all old and busted like?
20:20:21 <Saizan> it has competitors, but it also has the nice advantage of compiler support
20:21:30 <joe6> helgikrs: thanks
20:21:54 <joe6> sproingie: maybe, but it seems to have the best documentation and the most varied features.
20:22:28 <Axman6> anyone used the derive package before?
20:22:56 <Axman6> i'd like to be able to derive simple binary instances for things using it
20:23:12 <Axman6> actually, they're just newtypes, so i could add it to the c macro i'm using...
20:23:48 <dolio> If they're newtypes, can't you use newtype deriving?
20:24:23 <Axman6> hmm, maybe? don't i need to use something like derive to be able to derive Binary though?
20:24:55 <dolio> For general types, yes.
20:25:08 <Axman6> i'll give it a shot
20:25:27 <Saizan> $(derive makeBinary ''YourType)
20:25:29 <Axman6> does the newtype deriving just let you derive any class the wrapped type has?
20:25:34 <Saizan> yes
20:25:46 <Axman6> perfect then :)
20:44:38 <lpsmith> Do I have to compile my own ghc to get a debugging runtime?   Should I have a debugging runtime if I want to diagnose a problem with a C binding?
20:45:07 <lpsmith> http://hackage.haskell.org/trac/ghc/wiki/Debugging/CompiledCode?redirectedfrom=DebuggingGhcCrashes
20:55:35 <lpsmith> n/m,  I figured it out
20:55:45 <lpsmith> I needed binutils-dev installed,  which I didn't
21:02:02 <joe6> i am noticing that gzipWithQ does not loop over subtypes. Is that expected behaviour? If it is, then I can hunt down what I am doing wrong
21:02:25 <joe6> I meant subtypes which are ADT's themselves.
21:02:49 <joe6> let Test = Test { ta :: Int , tb :: Int , tc :: Test }
21:03:12 <joe6> it does not loop into the fields of tc.Test
21:03:33 <joe6> I might have screwed up by giving a recursive definition
21:04:02 <joe6> data Test1 = Test1 {tta :: Int } ; data Test = Test { ta :: Int , tb :: Int , tc :: Test1 }
21:07:05 <mm_freak_> why can't i create a Supply purely in category-extras?
21:08:22 <dolio> Supply uses IO for performance, I think.
21:09:16 <mm_freak_> i see
21:13:52 <mm_freak_> in GHCi is there an easy way to spell out a type alias completely, i.e. removing all aliases?
21:15:34 <mm_freak_> trying to understand what a Stream is gives me headache
21:18:13 <aavogt> mm_freak_: besides following :info ?
21:18:41 <lpsmith> hmm,  the more I read HDBC's source code,  the less like it
21:18:47 <joe6> i am at my wit's end: can someone please help?
21:18:49 <joe6> check p q = case (tyconModule . dataTypeName . dataTypeOf $  p) of
21:18:49 <joe6>    ) where                                                          |   "Main" -> and (gzipWithQ check p q)
21:18:52 <joe6>                                                                     |   _ -> (geq p q)
21:19:22 <lpsmith> It was bothering me that  "preparing" a statement using a disconnected connection wasn't causing  a segfault,  as HDBC does
21:19:48 <mm_freak_> aavogt: :info doesn't spell it out completely
21:19:56 <joe6> http://codepad.org/x2JCgDSr
21:20:08 <mm_freak_> but i think by now i've at least found out how to construct a Stream
21:20:27 <lpsmith> so it's not clear to me that I'm actually compiling a query on the other end when I 
21:20:30 <mm_freak_> category-extras is really a mind fuck, if you have little to no CT experience
21:20:34 <joe6> should I be asking this question in some other irc? i am not getting much response here? or is it because it is too late?
21:20:53 <lpsmith> err, I don't think it actually gets compiled on the database when I prep a statement,  from my limited code reading so far
21:25:04 <mm_freak_> joe6: please understand that there is no obligation for anyone to give support…  sometimes nobody has time, sometimes nobody is interested…  you're almost guaranteed to get a response, when you ask a CT-related question though
21:28:55 <Axman6> mm_freak_: heh
21:29:49 <mm_freak_> you can also get lambdabot quite busy by asking a "how can i …" question for a very simple problem =)
21:30:45 <sproingie> lambdabot: how can i …?
21:30:52 <quuuux> @faq Can Haskell solve 3SAT in polynomial time?
21:30:52 <lambdabot> The answer is: Yes! Haskell can do that.
21:30:58 <joe6> and . gzipWithQ (\_ _ -> True) w $ w = True;  and . gzipWithQ (\x y -> geq x y ) w $ w = gives a compilation error
21:31:05 <joe6> does that make sense.
21:31:11 <quuuux> that's it, guys. P = NP, lambdabot says so
21:31:23 <sproingie> @faq can haskell solve the halting problem?
21:31:24 <lambdabot> The answer is: Yes! Haskell can do that.
21:32:15 <joe6> mm_freak_: i understand that there is no obligation to help and I am thinking that the main reason could be that there are not many active now or that people are interested. I am just wondering if there are avenues to get some help on the generics stuff.
21:32:31 <monochrom> haskell can solve every individual instance of 3SAT in polynomial time...
21:32:37 <joe6> i meant "people are not interested"
21:33:16 <perimosocordiae> quick question: can I pattern-match on types?
21:33:23 <monochrom> no
21:33:35 <Axman6> sounds like you want a class
21:33:40 <Axman6> though maybe not
21:33:55 <joe6> perimosocordiae: i am not sure about patternmatch but you could do somethings on types. check out the SYB module or uniplate
21:34:15 <perimosocordiae> basically, what I'm trying to do is dispatch to different functions given what type of parameter is supplied
21:34:22 <mm_freak_> joe6: i think generics are just not widely used
21:34:28 <quuuux> perimosocordiae: look into Data.Typeable and Data.Dynamic
21:34:35 <Axman6> uh...
21:34:39 <perimosocordiae> quuuux: thanks, will do
21:34:41 <Axman6> i do not think that is good advice
21:34:53 <Axman6> perimosocordiae: i believe you want a type class
21:35:05 <Axman6> > show (1::Int)
21:35:06 <lambdabot>   "1"
21:35:10 <Axman6> > show (1::Double)
21:35:11 <lambdabot>   "1.0"
21:35:20 <Axman6> > show (1::Complex Double)
21:35:20 <perimosocordiae> ahh, yeah, you're right
21:35:21 <lambdabot>   "1.0 :+ 0.0"
21:35:31 <joe6> mm_freak_: that is the feeling that I am getting. Do you know of any other irc where I might get an answer to my generics stuff. I know that there is more than one haskell irc around.
21:35:31 <perimosocordiae> that's exactly what I want
21:35:53 <Axman6> perimosocordiae: it's almost certainly what you want, unless you're doing something wrong =)
21:36:15 <perimosocordiae> Axman6: I've learned to never rule out that possibility
21:36:17 <mm_freak_> joe6: dunno, i know only this one, and if you don't get an answer here, it's unlikely you get it elsewhere…  i think, your best bet is the -cafe mailing list
21:36:30 <Axman6> perimosocordiae: good :)
21:36:35 <Axman6> :32
21:36:37 <Axman6> whoops
21:36:40 <joe6> mm_freak_: ok, thanks a lot. will check out the mailing list.
21:36:53 <joe6> isn't there another irc where the haskell developers hang out?
21:37:25 <quuuux> Axman6: it -may- be legitimate. I had an option between creating a typeclass with about 50 methods or using Data.Dynamic to facilitate some multiple dispatch in my MUD server
21:37:59 <Axman6> MUD?
21:37:59 <mm_freak_> joe6: there are some topic-specific haskell channels here, mostly implementation-/distribution-specific…  there may be other channels on other networks, too
21:38:24 <mm_freak_> joe6: but i'm pretty sure this is the largest haskell channel, likely by orders of magnitude
21:38:43 <geheimdienst> joe6: you are pretty much in the right place for haskell. if you can't get an answer, check back in a couple of hours. (right now, europe is asleep.) writing an email to the appropriate list is also worthwhile
21:38:56 <quuuux> Axman6: Anachronisms, essentially :)
21:39:34 <joe6> geheimdienst: thanks. I will post after some time.
21:39:42 <joe6> Sorry for the bother and the troll
21:40:30 <Axman6> you understand this is an extremely active channel, with usually over 600 members right?
21:40:31 <mm_freak_> soon the sun starts to force evaluation of europe
21:40:50 <Axman6> we're a distributed help engine!
21:40:57 * Heffalump was forced by an alarm clock :-(
21:42:08 <geheimdienst> joe6: don't worry about that :) i know, it's frustrating when nobody knows an answer to your question. often, patience helps on irc
21:43:33 <Kaidelong> Copointed is not what I'm looking for (but possibly related)
21:43:58 <Kaidelong> what I am looking for does imply copointed, though
21:44:26 <mm_freak_> often when having a very practical problem, try to spice it up with some CT…  that doubles the size and enthusiasm of your audience =)
21:44:47 <Kaidelong> a -> (p a) -> a, and a p a such that when input into that method, it becomes id
21:45:48 <Kaidelong> and then the monoid operation (p a) -> (p a) -> (p a) for which the aforemention p a is the zero
21:46:51 <Kaidelong> although perhaps that isn't so important
21:46:51 <Kaidelong> (Pointed p, Monoid p a) would imply this, I think
21:46:52 <Kaidelong> err, you'd need Copointed as well
21:47:45 <Kaidelong> oh wait, Copointed is exactly what I'm trying to avoid needing
21:47:55 <Kaidelong> (although you can get its behavior)
21:48:37 <Axman6> you know, there's a kind of nice feeling that ceoms from knowing you can change the types of something completely, and fix it by just following the compile errors
21:48:38 <Kaidelong> and I'm wrong, Pointed+Monoid+Copointed would not imply that
21:49:09 <Kaidelong> Axman6: this has generally been my experience yes. The problem is when you don't understand what the errors mean, particularly with calling library code.
21:49:10 <mm_freak_> Kaidelong: maybe changing the type signature would make it a bit clearer
21:49:19 <mm_freak_> p a -> a -> a
21:49:37 <Axman6> Kaidelong: luckily it's all code i'm looking after, so i can do what i want
21:50:01 <mm_freak_> where p is the reader monad with environment 'a' you would get (a -> a) -> (a -> a)
21:50:07 <Kaidelong> mm_freak_: I was thinking of making it look like fromMaybe since I realized that fromMaybe is very much like the behavior I'm looking for
21:50:22 <Kaidelong> although p a -> a -> a would make more sense infix
21:50:41 <mm_freak_> it also shows the correspondence more clearly
21:50:59 <Kaidelong> ah it does
21:51:07 <joe6> in this type definition what does "GenericQ (GenericQ r)" mean? gzipWithQ :: (Data a1, Data a) => GenericQ (GenericQ r) -> a -> a1 -> [r]
21:51:12 <mm_freak_> p a -> a -> a, in case of (a ->) you get (a -> a) -> (a -> a)
21:51:24 <mm_freak_> and 'id' would be a candidate for what you want
21:51:24 <Arney> http://mibpaste.com/JNJVWP why doesnt is upper work???
21:51:46 <mm_freak_> and purely by intuition i'd say that it's the only such candidate
21:52:03 <mauke> Arney: isUpper only takes one argument
21:52:04 <Kaidelong> mm_freak_: what about fromMaybe
21:52:22 <Axman6> Arney: can you please use a good pastebin? that's very hard to read properly
21:52:25 <Kaidelong> mm_freak_: also what would be the single p a for functions? const undefined?
21:52:30 <Arney> mauke im trying to give it the head of cs
21:52:44 <mauke> Arney: you're calling it with two arguments, head and cs
21:52:57 <Axman6> Arney: you're giving isUpper the function head, and it's expecting a Char
21:53:08 <mm_freak_> Kaidelong: i think you first need to generalize fromMaybe properly
21:53:16 <Axman6> isUpper head cs === ((isUpper head) cs)
21:53:30 <mm_freak_> Kaidelong: otherwise you have many different notions of what you might want
21:53:31 <Axman6> you need isUpper (head cs)
21:53:40 <Axman6> though this is very bad style, and will not work properly
21:53:48 <Axman6> it will error at the end of the list
21:54:06 <mm_freak_> Kaidelong: what about Data.Foldable?  doesn't it do what you want?
21:54:07 <Axman6> actually, it's not really recursive, so it doesn't matter
21:54:14 <Kaidelong> let me look
21:54:32 <mm_freak_> Kaidelong: it has a generalized foldr, which for [] is foldr and for Maybe is 'maybe'
21:54:45 <mm_freak_> :t Data.Foldable.foldr 
21:54:47 <lambdabot> forall a b (t :: * -> *). (Data.Foldable.Foldable t) => (a -> b -> b) -> b -> t a -> b
21:55:53 <mm_freak_> > Data.Foldable.foldr const 0 (Just 3)
21:55:54 <lambdabot>   3
21:55:59 <mm_freak_> > Data.Foldable.foldr const 0 Nothing
21:56:01 <lambdabot>   0
21:56:20 <Kaidelong> mm_freak_: let me just post what I have so far
21:57:51 <mm_freak_> in fact, fromMaybe = foldr const
21:59:10 <Maxdamantus> > Data.Foldable.foldr const 0 (Just Nothing)
21:59:11 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
21:59:11 <lambdabot>    arising from a use of...
21:59:51 <aristid> :t mapM_ . uncurry
21:59:52 <lambdabot> forall (m :: * -> *) b a b1. (Monad m) => (a -> b1 -> m b) -> [(a, b1)] -> m ()
22:00:03 <Arney> Axman6: http://pastebin.com/Xj37K62g you predicted the error, now why is there an error?
22:01:10 <Arney> Not in scope: `isUpper'
22:01:16 <mauke> import Data.Char
22:02:05 <Arney> got it
22:02:07 <Arney> thanks
22:04:36 <Kaidelong> http://codepad.org/gSZWEt3h
22:05:26 <Kaidelong> well
22:05:31 <Kaidelong> the default method would not be used
22:05:35 <Kaidelong> it is just to illustrate the idea
22:05:54 <Kaidelong> the whole notion here is not to use the real bottom but a fake substitute (this is part of a preconditioned IO thing I'm making)
22:08:53 <Kaidelong> I was trying to think what values I'd be adding preconditions to and came up with this
22:10:44 <Kaidelong> the idea is to eventually get something where you can subtract value from an "a -> p b" to make it "less defined"
22:13:01 <Kaidelong> Maybe is an instance of this (and what I used in my prototype)
22:25:07 * hackagebot RBTree 0.0.2 - Pure haskell Red-Black-Tree implemetation  http://hackage.haskell.org/package/RBTree-0.0.2 (XingboWu)
22:34:20 <Arney> head' what does that little thingy at the end of head mean?
22:37:16 <Axman6> Arney: read that as headprime, it's like in maths where you might often have f, f', f'' etc
22:37:48 <Axman6> it doesn't mean anything, it's something you can add anywhere in names of things in haskell
22:37:53 <Arney> so it deosnt mean anything special... thanks, I thought It meant that the function usees recursion
22:38:12 <Axman6> there'd be a hell of a lot of foo' prime fuinctions then ;)
22:38:29 <Axman6> uh, -prime
22:42:18 <dobblego> hlint chokes on my (#) identifier
22:43:24 <Axman6> # is special i believe, you might want to choose something else
22:43:34 <dobblego> I did :)
22:51:03 <copumpkin> @djinn Either (Not a) (Not b) -> Not (a, b)
22:51:04 <lambdabot> f a =
22:51:04 <lambdabot>     case a of
22:51:04 <lambdabot>     Left b -> \ (c, _) -> b c
22:51:04 <lambdabot>     Right d -> \ (_, e) -> d e
22:52:24 <dreixel> joe6: I don't know if you got the help you wanted, but the easiest might be to ask on the generics mailing list: http://www.haskell.org/mailman/listinfo/generics
22:52:26 <copumpkin> omg an edwardk
22:52:53 <dreixel> at least I'm better at replying to emails than at seeing questions here
22:53:06 <edwardk> omg, a copumpkin!
22:53:16 <dreixel> and if you write to generics with questions about SYB i'm sure to answer them
22:54:11 <edwardk> preflex: xseen ivanm
22:54:11 <preflex>  ivanm was last seen on freenode/#haskell-blah 8 hours, 2 minutes and 13 seconds ago, saying: *comics
22:54:50 <edwardk> copumpkin: this 'monadic graph library' seems to show promise.
22:55:15 <edwardk> copumpkin: after i left i refactored it a bit, instead of everything being in '(->) g' i just made 'g' the monad.
22:55:21 <quicksilver> Axman6: # isn't special in haskell. It's special in the presence of a GHC extension.
22:55:24 <quicksilver> AFAIK.
22:55:37 <edwardk> that lets me talk about huge offline graphs, etc.
22:55:51 <Axman6> yeah, i meant in GHC, and i wasn't sure how special it was without MagicHash
22:56:10 <edwardk> and it meant i could apply monad transformers to my graphs =)
22:56:21 <quicksilver> it should be a perfectly valid binary operator unless magichash is on
22:56:39 <edwardk> so when working with propertymaps, etc. i could just stuff them in a StateT without affecting the Vertex/Edge types
22:57:00 <quicksilver> and even if magichash is on, as long as you're careful with whitespace - that just makes it dual use, and permits some freakish syntax like (# 3 #)
22:57:08 <edwardk> Axman6: without magichash its just an operator symbol
22:57:45 <copumpkin> edwardk: cool
22:58:00 <copumpkin> edwardk: man, I want it!
22:58:07 <copumpkin> well, right now I don't really need it for my slides
22:58:17 <edwardk> copumpkin: this lets vacuum graphs be a special case of my own
22:58:32 <edwardk> copumpkin: so you'l be able to depth first search, etc. over them
23:00:57 <joe6> dreixel: i did not get any help. Can you please check out: http://codepad.org/MqX2UTU6
23:01:17 <edwardk> Is there a MonadST floating around in some not-so-terrible library?
23:01:19 <joe6> dreixel: if you have any answers, it will be of much help to me.
23:01:50 <copumpkin> edwardk: awesome
23:01:51 <quicksilver> edwardk: you mean for liftST?
23:01:56 <edwardk> quicksilver: yeah
23:01:57 <joe6> dreixel: will see how I can post to that mailing list. 
23:02:01 <mm_freak_> sometimes monads on subcategories of Hask would be useful
23:02:09 <copumpkin> edwardk: there's a primitive monad you can use in the primitive package
23:02:11 <edwardk> class MonadST s m | m -> s where liftST :: ST s a -> m a
23:02:13 <copumpkin> lets you abstract over which of them
23:02:32 <edwardk> copumpkin: yeah i'm familiar with it, but iirc there were a few annoying issues with the exports of that package
23:02:32 <quicksilver> edwardk: yes, in at least two places, probably more
23:02:44 <edwardk> quicksilver: have package names?
23:02:46 <quicksilver> stateful-mtl and funsat
23:02:48 <quicksilver> for starters
23:02:57 <dreixel> joe6: ok, you have many questions there
23:03:00 <edwardk> i'll go check out stateful-mtl
23:03:08 <dreixel> many things are beginner's things
23:03:27 <dreixel> which is fine, but you might have some trouble with syb, as it's not very simple
23:03:33 <dreixel> and I'm afraid this holds for all generic programming libraries
23:04:22 <edwardk> stateful-mtl looks pretty solid for my purposes.
23:04:37 <edwardk> i'm already using type families
23:05:15 <edwardk> dependencies are larger than i'd like but thats the nature of packages that come later to hackage
23:05:46 <edwardk> ugh, i just realized they include the mtl =(
23:05:51 <medfly`> isn't lots of dependencies a positive thing
23:06:06 <dreixel> joe6: I'll reply in comments to your code
23:06:30 <edwardk> medfly: it means that it depends on a lot of things, not that a lot of things depend on it
23:06:44 <edwardk> medfly: the former means that every one of those things has to be in working order
23:06:59 <medfly> I was thinking like how ppl encourage code reuse
23:07:04 <edwardk> medfly: and that any diamond dependency issues between those packages break me
23:07:31 <edwardk> e.g. if i depend on mtl through it, and someone else depends on one of those alternate mtl's that popped up a couple of years ago, then i'm done
23:07:55 <edwardk> so in general it pays to be surgical with your dependencies
23:08:28 <edwardk> it did remind me that i need to provide a comonad for vector though
23:09:50 <edwardk> hrmm, the current stateful-mtl doesn't seem to _need_ mtl anywhere, just transformers, so i can probably get him to peel back the dependency list further
23:10:58 <edwardk> ah it the odd transitive dependency on MaybeT
23:12:56 <joe6> dreixel: sorry, that i have so many questions. 
23:13:13 <joe6> dreixel: thanks a lot for trying to answer my questions.
23:13:24 <edwardk> i'm somewhat saddened to have to pass up an otherwise perfectly usable package for something stupid like that
23:13:36 <joe6> I found an alternative to compare strings using gshow.
23:13:51 <joe6> i doubt that it is a good way of doing this, but it seems to work.
23:15:01 <joe6> dreixel: please ignore the constructor names and the used of Test a lot. http://codepad.org/BEQUlaHE
23:15:29 <joe6> dreixel: I am trying to learn the behaviour of the functionality before putting it into my original code.
23:16:32 <edwardk> well, i don't feel bad reimplementing it, there are apparently no reverse dependencies on stateful-mtl and its lacking upper bounds for any of its dependencies
23:16:43 * copumpkin declares his slides done
23:16:48 <copumpkin> until tomorrow at least
23:16:50 <edwardk> yay!
23:22:52 <joe6> dreixel: I think codepad might want you to login to comment. Please be mindful of that. I do not want you to lose what you have written/typed up as comments.
23:24:43 <mafs> Is there an easy way to find compatible (type-checking wise) lower version bounds for build dependencies?
23:24:58 <mafs> Or is it typical to just say it has to be less than some maximum
23:27:14 <dreixel> joe6: http://codepad.org/1W07zD46
23:27:23 <joe6> dreixel: thanks a lot.
23:27:53 <Axman6> joe6: to avoid problems like logging in, please use hpaste for haskell code ;)
23:29:14 <Axman6> git diff
23:29:19 <Axman6> whoops
23:30:27 <joe6> dreixel: quick question: when I used gzipWithQ does it traverse the fields of a sub-type?
23:30:29 <edwardk> hrmm. why is Control.Monad.Trans a member of mtl rather than a member of transformers?
23:30:48 <joe6> dreixel: I do not see that happening. but, wanted to quickly check.
23:30:56 <edwardk> ah Control.Monad.Trans.Class is
23:30:59 <Axman6> what is qzipWithQ?
23:31:32 <joe6> gzipWithQ :: (Data a1, Data a) => GenericQ (GenericQ r) -> a -> a1 -> [r]
23:31:57 <joe6> not qzipwithQ, but gzipWithQ
23:32:13 <joe6> > gzipWithQ
23:32:13 <lambdabot>   Overlapping instances for GHC.Show.Show
23:32:14 <lambdabot>                              (Data....
23:32:20 <joe6> > :t gzipWithQ
23:32:20 <lambdabot>   <no location info>: parse error on input `:'
23:32:35 <Axman6> i've never heard of it before, so i doubt lambdabot has it...
23:33:01 <joe6> Axman6: are you lambdabot? i thought it was a daemon..
23:33:19 <Axman6> huh?
23:33:31 <Axman6> :t gzipWithQ
23:33:32 <lambdabot> forall r a a1. (Data a, Data a1) => GenericQ (GenericQ r) -> a -> a1 -> [r]
23:33:35 <Axman6> :o
23:33:44 <Axman6> maybe it has heard of it
23:34:46 <Arney> whats the syntax for haskell And Or, google is messing up
23:34:56 <Axman6> &&, ||
23:35:06 <Axman6> and it's not syntax, they're regular functions
23:35:12 <Axman6> @src (&&)
23:35:12 <lambdabot> True  && x = x
23:35:12 <lambdabot> False && _ = False
23:35:14 <Axman6> @src (||)
23:35:15 <lambdabot> True  || _ =  True
23:35:15 <lambdabot> False || x =  x
23:35:19 <Arney> awesome, finally something consistent
23:35:25 * hackagebot hamtmap 0.3 - A purely functional and persistent hash map  http://hackage.haskell.org/package/hamtmap-0.3 (KevinWuWon)
23:35:26 <joe6> dreixel: does this make sense to you? http://hpaste.org/43158/joe
23:35:54 <edwardk> this seems to be the week for haskell hashed array mapped tries
23:36:25 * hackagebot monad-st 0.1 - Provides a MonadST class  http://hackage.haskell.org/package/monad-st-0.1 (EdwardKmett)
23:39:03 * Axman6 wonders what Hamt is supposed to mean
23:39:29 <edwardk> axman6: hash array mapped tries or some such its a clojure thing
23:39:39 <Axman6> ah, righto
23:39:42 <Axman6> win 21
23:40:06 <dreixel> joe6: the error makes sense
23:40:31 <dreixel> because you are assuming the two type variables are the same, but the compiler doesn't know that
23:40:40 <joe6> dreixel: does gzipWithQ traverse the fields of a sub-record?
23:40:54 <joe6> dreixel: oh, ok.
23:41:34 <joe6> dreixel: Is there some way of telling the compiler that they are the same type?
23:41:44 <dreixel> joe6: no, gzipWithQ is not recursive, you have to do the recursion yourself
23:42:16 <joe6> dreixel: ok, thanks. can I use the isAlgType for that?
23:42:22 <dreixel> joe6: yeah, you can cast, like in my example, but it's not very elegant.
23:42:30 <eroomde> Hi everyone. I've had a few limited dealing with Haskell in the last couple of weeks, and particularly enjoyed the tutorial based around simulated annealing by Conrad Barski. I do some research on bayesian signal processing and often run into dynamic range problems, where I have probabilities in time-series data that go between 1 and 1 x 10^-500. How is haskell at handingling very high dynamic range floats?
23:42:44 <dreixel> joe6: no, call gzipWithQ with the function you're defining, like geq does
23:43:07 <eroomde> also I need to work on asking more concise questions :)
23:43:57 <joe6> ok, will check it out.
23:45:15 <joe6> dreixel: in the checkstr function, can I figure out the current field name is?
23:45:17 <Arney> http://pastebin.com/VQvJb2Vx In other languages I would use a for loop... I need to know what the original string was, Ideas? its supposed to capitalize the first char only.
23:45:24 <joe6> at the level of p or q
23:45:52 <dolio> eroomde: I'm not aware of any floating point numbers available for Haskell aside from IEEE float and double.
23:46:07 <joe6> there is the constrFields, which gives the fields of the record.
23:46:31 <dolio> If those don't suit your needs, you probably have to look elsewhere.
23:46:43 <eroomde> dolio: ok thanks - I wonder about these ease of defining your own? Or might it be better left to C (where I would feel more comfortable doing it)
23:46:48 <joe6> but, while traversing the record, is there a way of knowing the field name that is currently in action. I do not much about extQ yet.
23:46:59 <joe6> so, please excuse my question if extQ does that.
23:47:08 <dolio> eroomde: People have talked about wrapping the GMP floating point stuff, but no one's done it yet.
23:47:53 <dreixel> joe6: I think you have to use constrFields and constrIndex
23:47:55 <dolio> I don't think defining your own would be particularly easy, but I don't know much about floating point implementation.
23:48:01 <joe6> dreixel: the typeOf is pretty useful. Where did you find it? 
23:48:13 <dreixel> joe6: it's from the Typeable class
23:48:30 <dreixel> joe6: also, you can use hoogle to find things: http://haskell.org/hoogle/
23:48:38 <joe6> dreixel: ok, I have been focussing on the Data class. will check out the typeable class.
23:48:46 <joe6> dreixel: thanks a lot.
23:49:24 <Arney> how can I do a for loop in haskell?
23:49:51 <Axman6> you cvan't, that would involve mutation
23:49:56 <Axman6> can't*
23:50:05 <Axman6> Arney: where are you learning haskell?
23:50:10 <Arney> I need to capitalize the first char, and lowecase the rest in a string.
23:50:13 <joe6> dreixel: quick question: do you know if cast can work with bytestrings?
23:50:14 <kfish> > for [1..10] print
23:50:15 <lambdabot>   Not in scope: `for'
23:50:29 <dreixel> joe6: yes, it should.
23:50:56 <joe6> with strings, there is gshow which works with that. But, with ByteStrings, I am getting an ugly error, hence wanted to check.
23:50:56 <Arney> Syracuse University... I skipped the class that we learned haskell in, now im in a more advanced course and we are using it again.
23:50:59 <dreixel> it should work with everything that has a Typeable instance.
23:51:11 <fabjan> Arney: all right, but there are no loops
23:51:14 <joe6> dreixel: ok, thanks.
23:53:13 <Axman6> Arney: well then it's time for you to learn haskell, go here:
23:53:16 <Axman6> @where lyah
23:53:17 <lambdabot> http://www.learnyouahaskell.com/
23:54:16 <Arney> thats one of the sites the teacher pointed to, love the site
23:54:44 <Arney> ill have to read it over the weekend in order to have any chance of passing this class
23:54:47 <edwardk> is there a package with something like class Options t where options :: t  — for specifying arguments to functions with defaulting?
23:55:33 <edwardk> i realize there is data-default, but the meaning is a bit different than i'd want
23:56:11 <edwardk> guess its not so bad though
23:58:36 <Axman6> > print 1
23:58:38 <lambdabot>   <IO ()>
23:58:43 <Arney> is there any way to use a recursive function to capitalize a string without using global vars, I feel like my teacher is playing a joke on me.
23:58:57 <edwardk> arney: yes
23:58:59 <Axman6> uh, of course there is
23:58:59 <dobblego> Arney, yes
23:59:10 <Axman6> we never use 'global vars' in haskell
23:59:18 <dobblego> Arney, perhaps you could try writing that function
23:59:27 <Arney> with comprehension its easy... I cant do it with recursion...
23:59:40 <dobblego> how have you done it with a comprehension?
23:59:41 <Arney> doubblego, that always leads me to for loops lol
23:59:42 <Axman6> of course you can
23:59:49 <dobblego> no loops :)
