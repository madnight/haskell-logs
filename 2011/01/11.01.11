00:10:17 <User917> hi
00:32:59 <Axman6> How does one go about getting the equlivant to $0 in Haskell?
00:33:25 <joe6_> guys, anyone know about this: GHCi runtime linker: fatal error: I found a duplicate definition for symbol fps_minimum
00:33:42 <aefjt> Axman6: ...by being a student?
00:34:17 <Axman6> heh, touche
00:34:28 <aefjt> There's no portable way to do The Right Thing, and that's ghc/base's excuse to not do it, I think
00:36:32 <aefjt> I believe the bug thread for that issue contains some workaround
00:38:09 <aefjt> http://hackage.haskell.org/trac/ghc/ticket/3199 calls out to the C runtime, of course
00:45:05 <lars9> @hoogle minby
00:45:05 <lambdabot> No results found
00:45:11 <lars9> @hoogle minimumby
00:45:12 <lambdabot> Data.Foldable minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
00:45:12 <lambdabot> Data.List minimumBy :: (a -> a -> Ordering) -> [a] -> a
00:48:04 <Axman6> aefjt: hmm, fair enough, thanks for that
01:48:17 <Veinor> guys
01:48:19 <Veinor> arrows are cool as hell
01:51:34 <Botje> can we finally make coffee with them? :)
01:51:44 <hvr> Veinor: why? :)
01:55:13 <Veinor> hvr: oh, i'm just playing around with HXT, and it's neat how i can use *** and &&& and suchlike
02:02:21 <Veinor> @pl \(n,l) -> [(Label . StrLabel) l]
02:02:22 <lambdabot> return . Label . StrLabel . snd
02:02:51 <hvr> for some reason, I do only use the subset of Arrows that works on simple pair-tuples
02:03:02 <hvr> just as means to write in point-free style
02:04:42 <hvr> stuff that wouldn't require the Arrow typeclasses 
02:05:26 <Jafet> @instances Arrow
02:05:27 <lambdabot> (->), Kleisli m
02:14:55 * hackagebot curry-base 0.2.8 - Functions for manipulating Curry programs  http://hackage.haskell.org/package/curry-base-0.2.8 (BerndBrassel)
02:15:55 * hackagebot curry-frontend 0.2.11 - Compile the functional logic language Curry to several intermediate formats  http://hackage.haskell.org/package/curry-frontend-0.2.11 (BerndBrassel)
02:16:53 <Veinor> hm. i'm not liking fgl.
02:36:24 <lars9> how to make Int in newtype T = T [(Int, Int)] strict? [(!Int, !Int)] can not compile
02:41:21 <shachaf> lars9: It's a newtype. You can't make it strict because it's just a type.
02:42:21 <lars9> shachaf: where else should I make T strict on evaluating those two Ints?
02:43:08 <quicksilver> lars9: data StrictPair = SP !Int !Int
02:43:17 <quicksilver> newtype T = T [SP]
02:43:23 <quicksilver> it still won't be strict in the list part
02:43:36 <quicksilver> but the pairs of ints will be strict once evaluated at all
02:45:03 <lars9> quicksilver: thanks, i will need to change a lot of code for changing definition of T, what else can i do?
02:45:14 <quicksilver> nothing.
02:45:24 <quicksilver> if you want to change the type you have to change the type.
02:45:40 <quicksilver> at least the compiler will tell you if you've missed anything.
02:46:22 <lars9> quicksilver: i see, thanks
02:48:24 <quicksilver> lars9: you could, alternatively, strictify the algorithms instead of the type
02:48:32 <quicksilver> but, admittedly, strictifying the type often feels neater
02:48:37 <quicksilver> (and may even save a little memory)
03:04:07 <Jafet> data StrictList a = StrictCons !a !(StrictList a) | StrictNil
03:54:57 <Renze> How can I define finally :: m a -> m b -> m b? Control.Exception defines it as finally :: IO a -> IO b -> IO b
03:55:27 <j-invariant> what does it do?
03:55:37 <BONUS> :t liftM const
03:55:38 <j-invariant> :t (>>)
03:55:38 <lambdabot> forall a1 b (m :: * -> *). (Monad m) => m a1 -> m (b -> a1)
03:55:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
03:55:42 <Veinor> @djinn m a -> m b -> m b
03:55:43 <lambdabot> f _ a = a
03:55:47 <Veinor> ... oh, right
03:55:49 <BONUS> :t liftM2 const
03:55:50 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m a1
03:55:51 <Veinor> i meant hoogle
03:55:51 <Renze> sorry, I was wrong :P
03:56:05 <j-invariant> isn't finally doing something weird with exceptions?
03:56:08 <j-invariant> that is IO specific
03:56:11 <Renze> I meant finally :: IO a -> IO b -> IO a
03:56:30 <BONUS> oh
03:56:32 <BONUS> :t flip finally
03:56:33 <lambdabot> Not in scope: `finally'
03:56:41 <j-invariant> eg. (<<) has that type, but it does not coincide with finally
03:56:42 <Renze> No, you're getting me wrong ;)
03:56:49 <BONUS> :o
03:57:02 <Renze> I want finally :: m a -> m b -> m a instead of finally :: IO a -> IO b -> IO a
03:57:13 <j-invariant> Renze: do you understnad the above remark..
03:57:15 <Veinor> j-invariant: yeah, finally is not equivalent to (>>)
03:57:25 <j-invariant> you could make class MonadFinally m where finally :: m a -> m b -> m a
03:57:27 <Renze> But, I think i've got a solution, because it should always run in IO (thanks to j-invariant)
03:57:37 <Veinor> but there's no way to generalize the IO-specific parts
03:57:39 <j-invariant> which does something different on IO than any other monad
03:58:34 <Renze> Yes, the problem is different from what I thought...
03:59:32 <Renze> Wait a second, we're trying to figure it out by ourselves
04:00:59 <Renze> Problem solved :) thanks!
04:18:08 <lars9> hi, how to write this function for minimumBy, for (a,b), compare a in normal order, then compare b in reversed order
04:20:05 <BONUS> lars9: im not sure i follow
04:20:35 <BONUS> compare a with what? 
04:20:42 <lars9> two pairs
04:20:59 * Quex01 np: Warfare 88 - Nigger I'm Gonna Fuck You Up [00:24]
04:21:14 <BONUS> lars9: can you provide a concrete example?
04:22:07 <lars9> (a,b) > (c,d) == a > c || a==c && b < d
04:22:08 <luite> > minimumBy (\(x1,y1) (x2,y2) -> compare x1 x2 `mappend` compare y2 y1) [(1,2),(1,3),(1,1)]
04:22:10 <lambdabot>   (1,3)
04:22:12 <luite> like this?
04:22:28 <j-invariant> :t compare <$> flip compare
04:22:30 <lambdabot> forall a. (Ord a) => a -> (a -> Ordering) -> Ordering
04:22:38 <j-invariant> :t compare <*> flip compare
04:22:39 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> Ordering
04:22:39 <lambdabot>     Probable cause: `flip' is applied to too few arguments
04:22:39 <lambdabot>     In the second argument of `(<*>)', namely `flip compare'
04:22:40 <luite> now to write it shorter :)
04:22:48 <BONUS> yeah what luite said then
04:23:11 <j-invariant> :t curry compare
04:23:13 <lambdabot> forall a b. (Ord a, Ord b) => a -> b -> (a, b) -> Ordering
04:23:17 <j-invariant> :t ucurry compare
04:23:18 <lambdabot> Not in scope: `ucurry'
04:24:00 <BONUS> :t (compare `on` fst) `mappend` (flip compare `on` snd)
04:24:01 <lambdabot> forall a b. (Ord a, Ord b) => (a, b) -> (a, b) -> Ordering
04:24:54 <j-invariant> haha
04:25:03 <j-invariant> @hoogle mappend
04:25:04 <lambdabot> Data.Monoid mappend :: Monoid a => a -> a -> a
04:25:05 <BONUS> minimumBy ((compare `on` fst) `mappend` (flip compare `on` snd)) [(1,2),(1,3),(1,1)]
04:25:08 <BONUS> > minimumBy ((compare `on` fst) `mappend` (flip compare `on` snd)) [(1,2),(1,3),(1,1)]
04:25:10 <lars9> hah, i used a cheap way: comparing (id *** (0-)), since its number
04:25:10 <j-invariant> is there another way to write mapend
04:25:11 <lambdabot>   (1,3)
04:25:35 <Bynbo7> ?
04:26:01 <kamatsu> is there a simple algorithm that, given two overlapping type terms for an hindley-milner style type system, determines which one is more general?
04:26:19 <luite> lars9: comparing (second negate)
04:26:21 <j-invariant> kamatsu: yes
04:26:23 <BONUS> j-invariant: <> would be a cool name for mappend, but i don't know if they plan on adding that
04:26:27 <luite> lars9: looks slightly better imho
04:26:41 <kamatsu> j-invariant: anything i can look at?
04:27:00 <j-invariant> kamatsu: well do you know about instantiation and unification?
04:27:03 <luite> but not using negation at all is still better
04:27:04 <kamatsu> yes
04:27:22 <kamatsu> i have this feeling that i'm missing something obvious
04:27:40 <j-invariant> kamatsu: the definition of A (strictly) more general than B is just that A can be instantiated to B, but B cannot be instantiated to A
04:28:28 <kamatsu> what about a scenario like: (a -> Int) (Bool -> b)
04:28:53 <j-invariant> the yare both more general than the other: But neither is strictly more general
04:29:34 <j-invariant> no that's wrong I lied
04:29:44 <j-invariant> I forgot about rigidity
04:30:11 <j-invariant> they are just incomparable, the relation is a partial order
04:30:35 <kamatsu> right
04:32:21 <kamatsu> so, the way I try to check if one type can be instantiated to another at the moment falls over in that case
04:32:34 <kamatsu> basically if I perform unification, I get a substitution
04:32:48 <kamatsu> and so if I apply a substitution to one, and get the other, I assume that that one is the more general one.
04:33:05 <kamatsu> hm, if i apply a substitution to A and get B i assume A is more general than B.
04:33:06 <j-invariant> it is not exactly unification, because of rigidity
04:33:40 <kamatsu> right
04:33:44 * kamatsu pulls out TAPL again
04:34:26 <j-invariant> For example: if we wanted to ask whether or not a -> Int  >=  c -> d.. it would not be right to unify (which would give {a=c,d=Int}
04:35:33 <kamatsu> right
04:35:37 <j-invariant> you can only instantiate variables of the more general term (in question). Which is {a}
04:36:01 <j-invariant> so the comparison of Int and d shows that it isn't
04:37:06 <j-invariant> if your terms are A,B then A >= B when there is a substitution sigma(A) = B.
04:37:21 <j-invariant> and of course A > B when A >= B and A /= B
04:38:11 <kamatsu> right
04:38:27 <j-invariant> this is matching vs unification
04:39:16 <j-invariant> A /= B <-- meaning syntactic equality, not unifiable
04:40:21 <kamatsu> ok,right
04:40:30 <kamatsu> use ~ for unification if it makes things easier
04:42:41 <romildo> Hi.
04:44:22 <kamatsu> j-invariant: so, the problem I'm having then is how to determine if there exists a substitution sigma(A) = B
04:44:45 <kamatsu> presumably that existence proof comes by construction, so what is an algorithm for determining such substitution?
04:46:25 <romildo> I want to install cabal on my windows 7 system. I have installed ghc-7.0.1. The cabal setup program is saying that the following dependencies are missing: base >=4 && <3 && >=1 && <5, filepath >=1 && <1.2. What can I do about this? "ghc-pkg list" says that I have base-4.3.0.0 and filepath-1.2.0.0.
04:46:53 <j-invariant> kamatsu: unification finds sigma(A) = sigma(B), and you could just use that sigma. Alternatively you can modify the unification algorithm to never instantiate a variable on B
04:48:34 <quicksilver> romildo: I don't think there is a version of cabal-install for GHC 7 yet.
04:49:14 <kamatsu> so just unify A B, and filter out any substitutions of variables that don't occur in A?
04:49:23 <kamatsu> sounds easy enough
04:49:47 <j-invariant> kamatsu: in that cse you have to be careful about orienting the substitution equations correctly
04:50:07 <j-invariant> e.g. A->B = X->X must give {A=X,B=X}, not {A=X,X=B}
04:50:22 <kamatsu> oh, right
04:50:35 <kamatsu> so, perhaps it would be easier to write a one-sided unification algorithm
04:50:39 <j-invariant> that's why sometimes it's nicer to have both unify and match as seperate algorithms
04:54:31 <ivanm> preflex: seen dcoutts 
04:54:31 <preflex>  dcoutts was last seen on #ghc 2 hours, 26 minutes and 2 seconds ago, saying: ready to hand in tomorrow...
04:55:55 <kamatsu> j-invariant: great, thanks for your help :)
04:56:20 <j-invariant> good luck :D
04:56:27 <Boxo> I have another basic type theory question
04:56:33 <Boxo> They say that haskell uses "Hindley-Milner" and that HM is supports a subset of System F. But haskell has type constructors and System F doesn't. What's up?
04:57:46 <qfr> Noooo, severe MinGW bug which prevents me from building OpenSSL so I can use it with Haskell with cabal install openid which depends libeay/libssl :(
04:57:56 <qfr> depends on*
04:58:23 <qfr> The hmac package on HackageDB was already broken for ghc7 because of -Werror, that I can fix
04:58:43 <qfr> But this one I don't know how because it looks like MinGW 4.5.0., which is used by ghc7, has a severe bug
04:59:04 <kamatsu> Boxo: Haskell doesn't use Hindley Milner
04:59:06 <ivanm> when using OverloadedStrings, should you really replace its usage with explicitly packed values before releasing?
04:59:18 <kamatsu> Boxo: Haskell uses System F omega
04:59:25 <ivanm> or is it OK to keep using that extension in released code/production?
05:00:56 <Boxo> kamatsu: that's what I thought
05:00:58 <Boxo> @google "haskell uses hindley-milner"
05:00:59 <lambdabot> http://stackoverflow.com/questions/1252915/scala-how-to-define-generic-function-parameters
05:00:59 <lambdabot> Title: Scala: How to define "generic" function parameters? - Stack Overflow
05:01:20 <kamatsu> Haskell is said to use hindley milner because that's what alot of uninformed people think when they see a type inferred language.
05:01:21 <j-invariant> Boxo: hindly-milner is a method of type inference
05:01:30 <j-invariant> Boxo: whereas System F, F_omega etc are type systems
05:01:33 <Boxo> I know
05:01:35 <kamatsu> j-invariant: it's also ambiguously a subset of System F.
05:02:03 <j-invariant> Haskell uses modification of HM called HM(X), maybe even a generalized version of HM(X)
05:02:05 <ivanm> kamatsu: so is it valid to say that Haskell uses an HM-esque type system?
05:02:14 <kamatsu> ivanm: yes
05:02:18 <Boxo> So haskell uses some other type inference algorithm that works for System F omage
05:02:30 <kamatsu> yes, but it's not complete inference
05:02:33 <j-invariant> haskell suppports type classes
05:02:38 <kamatsu> there are cases in Haskell where types cannot be inferred.
05:03:38 <Boxo> Oh yeah type classes are not in System F omega.
05:03:59 <j-invariant> and polymorphic recursion: Which is one reason it's not complete as kamatsu said
05:03:59 <kamatsu> true that
05:04:13 <Boxo> Okay. I was just confused about the hindley-milner thing, and legitimately it seems
05:04:23 <j-invariant> Boxo: well it's just an approximation
05:04:32 <j-invariant> Boxo: but technically HM is just the start
05:04:37 <kamatsu> approximation, bah, they're just flat out wrong.
05:04:46 <kamatsu> similar, but very different as well
05:30:06 <romildo> I want to install cabal on windows 7. But when running the command "Setup install" in the command prompt, I am getting the message "Setup: permission denied". The user has administrator privilegies. What am I missing?
05:30:44 <Zao> romildo: Do it in an administrator command prompt?
05:30:51 <Zao> Or build it with --user?
05:31:31 <romildo> Zao, how do I get an administrator prompt?
05:32:46 <quicksilver> As an aside, I recommend the haskell platform for windows
05:33:01 <quicksilver> get started with GHC + some useful libs including cabal-install.
05:34:52 <Zao> romildo: Rightclick the command prompt entry in the start menu and Run As Administrator.
05:34:55 <romildo> I have found how to run a command prompt as admistrator on windows.
05:35:02 <Zao> romildo: Possibly while holding shift.
05:35:11 <romildo> Zao, yes, thanks.
05:35:12 <Zao> I'd recommend the HP though, too.
05:36:56 <romildo> I am developing an application on Gentoo Linux using ghc-7.0.1. Now I want to build the appliation on Windows. The problem is that the haskell platform was not updated recently. So I will have to install the needed packages myself.
05:37:12 <Zao> Then carry on :)
05:38:44 <romildo> That is what I am doing. As I am not familiar with haskell on windows, I may need some help, as I am already getting here.
05:40:21 <dcoutts_> romildo: I'd stick to the HP unless you really need something in ghc 7
05:40:25 <dcoutts_> romildo: on windows I mean
05:41:41 <dcoutts_> romildo: some windows systems are configured with a policy that all executables called Setup should be run with elevated privileges
05:42:09 <dcoutts_> romildo: in the case of Haskell Setup.hs, that's not necessary if one is doing a per-user install
05:43:21 <dcoutts_> romildo: as a check, can you try renaming Setup.exe to some other name and see if it still complains about permissions
05:43:54 * dcoutts_ thought that ghc embedded an xml manifest to turn off this silly name-based behaviour
05:46:15 <kamatsu> j-invariant: i now realise why you called this one sided unification matching..
05:46:29 <kamatsu> j-invariant: it seems like exactly the same algorithm as pattern matching
05:46:38 <romildo> dcoutts, I am intending installing system wide. Renaming Setup.exe to mysetup.exe still does not work in this case: mysetup: C:\Program Files (x86)\Haskell\doc\Cabal-1.10.0.0: permission denied.
05:47:15 <dcoutts_> romildo: ahh ok, so it's saying that while it runs, not immediately before starting
05:47:35 <dcoutts_> romildo: so in that case it's simply that you do not have permission to install to  C:\Program Files (x86)\Haskell\
05:47:37 <romildo> dcoutts, but launching the command prompt as administrator works.
05:47:41 <dcoutts_> right
05:47:47 <dcoutts_> then you have appropriate permissions
05:48:44 <dcoutts_> romildo: so the error message is ok then is it? It does actually list the directory where the permission problem is?
05:49:13 <dcoutts_> if it just said "Setup: permission denied" then that's obviously not so helpful! :-)
05:49:21 <romildo> dcoutts, yes, it is ok.
05:50:03 <Zao> dcoutts_: (one can use Process Monitor to more closely determine the cause of such things, it's kind of like strace or truss)
05:50:43 <dcoutts_> Zao: though hopefully cabal produces comprehensible error messages and we don't need to make users use such debugging tools
05:50:57 <dcoutts_> bad error messages are a bug! :-)
05:50:59 <Zao> Naturally.
05:51:09 <Zao> Just mentioning it as a useful general purpose tool.
05:51:10 <romildo> dcoutts, firstly I was running Setup.exe in a normal command prompt, which, I have just learned, dow not grant administrator privilegies.
05:51:30 <romildo> s/dow/does/
05:51:49 <dcoutts_> Zao: ta, I've never used process monitor, is it freely available? It might be useful to me in tracking these things down on windows.
05:51:57 <Zao> dcoutts_: Yes.
05:52:03 <dcoutts_> great
05:52:09 <Zao> http://technet.microsoft.com/en-us/sysinternals/bb896645
05:52:29 <Zao> It's an product by sysinternals, who nowadays are absorbed by Microsoft.
05:52:44 <Zao> There's also Process Explorer (taskman replacement) and lots of other useful utilities, all free.
05:55:37 <dcoutts_> nice
05:57:55 * hackagebot storable-endian 0.2.4 - Storable instances with endianness  http://hackage.haskell.org/package/storable-endian-0.2.4 (EugeneKirpichov)
06:06:04 <poucet> Hi
06:06:37 <poucet> Does anyone know an operator (divide by 2) that is valid for both floating point as well as data.Bits numbers (Since there youy can shift)
06:10:43 <philed>   /join #ocaml
06:11:10 <poucet> philed: advertising or typo?
06:11:29 <philed> poucet: lol. Or embarrassing admission that I use ocaml?
06:11:39 <poucet> philed: Everyone has flaws ;)
06:12:03 <poucet> I used to use #ocaml a long time as well, before I fully switched to o'caml for a variety of reasons
06:12:14 <philed> o'caml?
06:12:15 <poucet> s/a long time/a long time ago
06:12:22 <poucet> philed: that's the proper writing for it
06:12:24 <poucet> ocaml stands for objective caml
06:12:27 <poucet> hence o'caml
06:12:37 <poucet> whoops
06:12:41 <poucet> before I switched to haskell, of course
06:12:41 <poucet> ...
06:12:59 <philed> Ah right. I thought you meant that "o'caml" was another chatroom or something.
06:13:05 <poucet> No, that was a mental typo.
06:13:12 <philed> I do interactive theorem proving, so Ocaml it is.
06:13:27 <poucet> aha :)
06:14:24 <poucet> Monsquaz: I have no idea what your IM meant.
06:14:50 <poucet> "ignoring uninvited direct message" especially since I never IMd you.
06:15:02 <philed> I got one as well. Bot?
06:15:46 <poucet> philed: maybe a bot with a bug? :)
06:16:02 <j-invariant> what about a version of IRC for people that can't read?
06:16:16 <poucet> j-invariant: could be, still buggy tho
06:17:36 <poucet> Does anyone know a typeclass that implements the (/2) method accross floating point and integral types?
06:18:00 <Jafet> j-invariant: you're in it.
06:18:45 <j-invariant> poucet: I was just brining it up unrelated to anything
06:40:37 <zong_sharo> how do i a haskell cb in c?
06:40:48 <j-invariant> wat
06:40:59 <zong_sharo> i need to wrap haskell function in FunPtr somehow imo
06:41:36 <astor> how do I do a hayoo query for all hackage packages that do not have a build failure with GHC 7?
06:41:47 <zong_sharo> i need to feed a c library with a haskell callback
06:43:13 <lunaris> zong_sharo: http://www.haskell.org/haskellwiki/Calling_Haskell_from_C might help
06:43:29 <lunaris> zong_sharo: If you wish to call C from Haskell, then libffi (and its Haskell bindings) are excellent.
06:54:09 * hackagebot PermuteEffects 0.1 - Permutations of effectful computations  http://hackage.haskell.org/package/PermuteEffects-0.1 (MartijnVanSteenbergen)
06:56:40 <roconnor_> dcoutts: is there some way to pass --ghc-pkg-options=--force to runhaskell Setup.hs install?
06:57:30 <andy_> is there a comparison of algorithms written in pure haskell and those written in the ST monad, in terms of cpu and memory usage?
06:58:40 <luite> hmm, that would really depend on the algorithm... general comparisons aren't really useful
06:59:33 <j-invariant> yes there are some algorithms which would be faster and smoe where it wouldn't matter much
07:00:33 <dcoutts> roconnor_: no but you can generate the package reg file and call ghc-pkg yourself
07:00:33 <astor> andy_: I've seen a comparison of the performance of ST vs other synchronization primitives.  I guess you can infer performance for various algorithms based on that.
07:00:54 <dcoutts> roconnor_: which for distro script is the method I would recommend. Puts you in full control.
07:01:34 <philo> strange question :can any fold be decompose in reduce . map ?
07:01:43 <roconnor_> dcoutts: ok
07:02:46 <djahandarie> philo, reduce?
07:02:52 <dcoutts_> philo: and what is reduce exactly?
07:03:01 * djahandarie suspects mapReduce again
07:03:41 <philo> example : square_sum = foldl (\x y-> x + y^2) list1 = fold + $ map (\x-> x^2) list1
07:03:41 <dcoutts_> is it reduction with an associative operator?
07:03:48 <qfr> http://hackage.haskell.org/packages/archive/nano-hmac/0.2.0/logs/failure/ghc-7.0 <- is -fvia-C necessary at all? I removed it and now it builds in ghc 7 although I am not sure if it will work flawlessly
07:04:17 <andy_> astor, thank you
07:04:41 <dcoutts_> philo: does the operator have to be associative?
07:04:47 * ski didn't know `ST' had synchonization primitives ..
07:05:27 <astor> ski: I don't think it does, no
07:05:27 <philo> wich one the orginal onefrom the foldl ? ((\x y-> x + y^2) in this case)
07:05:45 <qfr> Oh, -fvia-C is merely an optimisation flag?
07:05:48 <ski> astor : .. so why "other", then ?
07:06:45 <astor> ski: please ignore "other".
07:07:05 <philo> or maybe aa better question can a compiler do the transformation i did automagicly ?
07:07:59 <ski> astor : ok (i still don't really see why one'd want to compare `ST' with synchronization primitives ..)
07:08:00 <aristid> @index showHex
07:08:01 <lambdabot> Numeric
07:10:40 <djahandarie> philo, the compiler wants to reduce the amount of times it needs to pass over the list
07:10:50 <astor> ski: you can solve a given problem using transactions, locks, message passing etc.  With various performance and complexity tradeoffs.  Those are interesting to compare.  I can't find a link to what I read on this though.
07:11:23 <djahandarie> philo, if you are using the lists in Prelude, look up "short cut fusion" to see the rules it uses to avoid multiple passes (and intermediate data structures)
07:11:26 <philo> djahandarie: isnt the second form more "parralell" ?
07:12:34 <djahandarie> philo, no, I don't think so
07:12:41 <ski> astor : i understand that .. i just don't see how any of those could instead be replaced by `ST'
07:13:12 <astor> ski: ok
07:13:24 <copumpkin> maybe he wants STM?
07:13:31 <ski> hm .. could be
07:13:47 <djahandarie> Morning copumpkin
07:13:54 <copumpkin> morning!
07:14:01 <philo> at least the squaring can be done indepandtly for each element in the second fom, no ?
07:14:03 <philo> form
07:14:07 <ski> comorning pumpkin
07:14:25 <djahandarie> philo, it's be pointless to do that since each square operation is very cheap and it'd be more expensive to have the overhead of doing it in parallel
07:15:31 <philo> djahandarie:  yea in this case ,but it was just an example
07:16:08 <djahandarie> philo, with Data Parallel Haskell you have a foldP (which requires an associative function) and can do the fold in parallel
07:16:16 <djahandarie> But that is no where near the standard libraries
07:16:24 <philo> the question i am if wheter any foldl have a "parralel component",and whether there are some compiler trick to detect that
07:17:11 <djahandarie> copumpkin, I think I'm done with the Newtype thing
07:17:18 <copumpkin> cool
07:17:21 <copumpkin> yeah, I saw that
07:17:46 <djahandarie> My attempt of explaining the various functions while half asleep. :P
07:17:50 <copumpkin> :)
07:18:46 <djahandarie> I want to provide instances for other packages like mtl, but I feel like this would start getting messy if I create whole new packages just to provide instances for another package
07:20:57 <ski>   RULES  [|foldr (\acc x -> $(f [|acc|] (g [|x|]))) $(z) $(xs)|] = [|foldr (\acc y -> $(f [|acc|] [|y|])) $(z) (map (\x -> $(g [|x|])) $(xs))|]
07:21:08 <ski> (mayhaps something along those lines ..)
07:21:18 <astor> ski: yes I was confusing ST and STM.
07:21:28 <ski> astor : ok
07:22:53 <qfr> Hmm I have a problem with building stuff which depends on OpenSSL on Windows, using cabal. Some MinGW setups use the names libeay32.a and libssl32.a instead of libcrypto.a and libssl.a - how do I set up my cabal file so the Extra-Libraries can use either of those pairs?
07:23:19 <qfr> I basically need to check for the existence of libraries, I think
07:23:31 <qfr> Before passing them to Extra-Libraries
07:24:00 <qfr> if os(mingw32)
07:24:01 <qfr>  does not suffice
07:26:13 <j-invariant> I have [[String]] which represents a graph like  [["a","b","c"],["b","c"]] represents a->b,a->c,b->c
07:26:25 <j-invariant> is there any way to graph it?
07:26:45 <j-invariant> I could convert to dot
07:28:18 <tab> qfr: do you really require openssl ?
07:28:45 <lucasicf> where do immutable data structures stay in memory? stack or heap?
07:28:50 <qfr> tab: I am actually trying to fix the HsOpenSSL cabal file if that's what you mean
07:29:24 <tab> qfr: no, i was suggesting there's alternative to openssl (and hsopenssl) altogether
07:29:36 <qfr> tab: Oh :O I wasn't aware of one
07:29:39 <qfr> What would you suggest?
07:29:47 <qfr> And for what reason?
07:29:58 <qfr> Other than the OpenSSL site sucking hard and pestering people to donate?
07:30:04 <tab> qfr: well it depends on the requirements, but there's tls on hackage
07:30:16 <qfr> Fully native?
07:30:20 <qfr> No C dependencies?
07:30:33 <tab> qfr: there's some C, but no C dependencies
07:30:46 <qfr> I mean I am just using a package which depends on HsOpenHaskell atm, so I'm not dealing with TLS directly
07:30:53 <qfr> But I'll keep that in mind when I do in future
07:31:01 <qfr> I am just using the openid package
07:31:12 <tab> oh right
07:31:13 <qfr> Because I have written some TLS code in Ruby before
07:31:45 <tab> openid is through https right ?
07:31:49 <qfr> Yeah
07:32:08 <tab> hm, I'ld look in http-enumerator then
07:32:23 <qfr> Why? :O
07:32:28 <tab> i think michael did a openid package on top of it already
07:32:32 <qfr> Oh
07:32:40 <qfr> I didn't see any other openid packages on HackageDB
07:32:47 <qfr> Do you happen to know its name?
07:33:08 <qfr> http://www.google.com/search?num=100&hl=en&safe=off&client=firefox-a&hs=qO1&rls=org.mozilla%3Aen-US%3Aofficial&q=site%3Ahackage.haskell.org+openid&aq=f&aqi=&aql=&oq=&gs_rfai= oh
07:33:32 <qfr> authenticate?
07:33:36 <tab> qfr: yes seems like this one
07:33:51 <quicksilver> lucasicf: heap.
07:33:59 <quicksilver> lucasicf: all data in heap.
07:34:00 <qfr> lol it has Facebook specific code :(( I disapprove
07:34:13 <qfr> tab: http://hackage.haskell.org/packages/archive/authenticate/0.7.2.3/logs/failure/ghc-7.0
07:34:15 <qfr> I use ghc 7
07:34:27 <lucasicf> thanks quicksilver
07:34:27 <qfr> http://hackage.haskell.org/package/http-enumerator-0.2.1.5 says it builds on ghc 7 though
07:34:28 <qfr> Odd?
07:35:01 <qfr> tab: The openid package looks more sophisticated to me, at a first glance
07:35:23 <luite> looks like 0.2.1.5 fixed the build failure in 0.2.1.4 and lower
07:36:25 <andy_> does anyone know the progress of:
07:36:26 <andy_> http://hackage.haskell.org/trac/ghc/ticket/4102
07:36:36 <andy_> "Bit manipulation built-ins"
07:36:58 <tab> qfr: but authenticate can be used with native TLS through http-enumerator
07:38:20 <opqdonut> andy_: I use bits-extras
07:38:25 <andy_> ok
07:39:26 <opqdonut> but it's far from perfect
07:39:54 <andy_> is a pure haskell implementation more efficient?
07:40:14 <andy_> for something so simple, i would think an ffi call would introduce more overhead than the actual computation cost
07:41:08 <qfr> Yes, it would
07:42:04 <opqdonut> oh?
07:42:12 <opqdonut> I'd better measure that, then
07:42:53 <quicksilver> unsafe FFI doesn't have much of an overhead
07:43:06 <quicksilver> as long as you know the calls are re-entrant and don't call back to haskell
07:43:18 <quicksilver> it's just a jump
07:43:26 <andy_> ok
07:43:46 <andy_> is the rdtsc package useful for measuring such computations?
07:43:47 <quicksilver> (on the other hand, a proper PrimOps implementation would actually be just an opcode, which is naturally faster than jumping to a subroutine, FFI or otherwise)
07:43:51 <andy_> timing doesn't seem much of an option
07:44:02 <andy_> and i'm not particularly familiar with other profiling options
07:45:18 <ski> (quicksilver : hm, they have to be reentrant even if you don't call back ?)
07:45:36 <quicksilver> ski: they might get called from two threads at the same time
07:45:56 <ski> hm .. oh, OS threads, then ?
07:45:58 <quicksilver> ski: perhaps I should have said 'threadsafe' but the two terms are often used interchangably.
07:46:11 * ski was only thinking about green threads
07:46:45 <quicksilver> right, it only matters with 'real' threads.
07:46:55 * ski nods
07:47:24 <andy_> opqdonut, brian kernighans way seems to be quickest
07:47:44 <andy_> opqdonut, at least for pop count, see http://www-graphics.stanford.edu/~seander/bithacks.html#CountBitsSetNaive and scroll down a little
07:48:18 <andy_> opqdonut, http://hpaste.org/42959/pop_count
07:48:27 <opqdonut> andy_: thanks for the pointer
07:51:46 <quicksilver> Just had a very weird conversation with that Monsquaz.
07:52:05 <quicksilver> I notice philed and poucet complained of unsolicited IMs from him earlier, and I just got one.
07:52:16 <quicksilver> He denied sending it, then denied being in #haskell, then signed off.
07:52:35 <andy_> i had received an unsolicited message as well
07:52:46 <andy_> though it was not long
07:53:10 <quicksilver> yeah, I only replied to say "hi?" - mostly I was curious if he was a bot, or what.
07:53:23 <quicksilver> I suspect he has an unknown script or virus on his machine.
08:01:58 * ski ponders how to define addition on ordinals ..
08:03:45 <quicksilver> ski: addition on ordinals has a standard meaning, no?
08:04:05 <quicksilver> ski: a + b is the order type of a u b with all of a < all of b
08:04:15 <ski> yeah .. but to define it, i have to simultaneously prove that addition is monotone
08:04:18 <aristid> i get this error from cabal build:
08:04:20 <aristid> <command line>: cannot satisfy -package-id directory-1.0.1.0-7c502e983ab945fa1bc7428734ee2a44: 
08:04:20 <aristid>     directory-1.0.1.0-7c502e983ab945fa1bc7428734ee2a44 is shadowed by package directory-1.0.1.0-10fc46e61b67ff4a83f3e553454d003c
08:04:20 <aristid>     (use -v for more information)
08:04:32 <aristid> does this mean my cabal is fucked up? :/
08:04:41 <yrlnry> quicksilver:  that happened to me too with Monsquaz.
08:04:49 <djahandarie> Same
08:04:55 <aristid> preflex: seen Monsquaz
08:04:56 <preflex>  Sorry, I haven't seen Monsquaz
08:05:09 <quicksilver> yrlnry: did you attempt to have a conversation with him?
08:05:14 <dcoutts_> aristid: sort of, cabal currently does not cope well with multiple instances of the same package version
08:05:28 <dcoutts_> aristid: the workaround is to eliminate the duplicates
08:05:42 <philo> i receive one too....
08:05:44 <quicksilver> ski: do you? my definition doesn't seem to assuming + is monotone, it's not even recursive?
08:05:45 <ski> i'm using a definition of ordinals with zero, succ and supremum (the latter) of type `(ns : Nat -> Ordinal) -> Monotone ns -> Ordinal'
08:05:51 <aristid> dcoutts_: how? the version number is the same oO
08:06:02 <yrlnry> quicksilver:  yes, it went just as you said. 
08:06:06 <dcoutts_> aristid: one is in the user package db, one in the global (probably)
08:06:09 <quicksilver> yrlnry: very odd indeed.
08:06:51 <yrlnry> quicksilver:  http://hpaste.org/42960/monsquaz
08:06:57 <aristid> dcoutts_: yes, ghc-pkg list says that
08:07:50 <dcoutts_> aristid: really we need a new cabal dep solver, one that can cope with there being multiple package instances with the same name and version
08:08:17 <quicksilver> yrlnry: weird.
08:08:57 <yrlnry> quicksilver:  Yes, I assumed it was some unknown third party forging messages.  But I no longer think that.
08:08:59 <aristid> dcoutts_: yeah. but for now i need a workaround :)
08:09:08 <ski> quicksilver : i think an alternative formulation is to only have supremum, but with type `(P : Natural -> Prop) -> (ns : (n : Nat) * P n -> Ordinal) -> Monotone ns -> Ordinal' .. but i haven't tried that
08:09:23 <dcoutts_> aristid: yep, well the solution for now is just to eliminate all duplicates
08:09:35 <dcoutts_> aristid: multiple versions is ok, multiple instances of the same version is not
08:10:06 <aristid> dcoutts_: but i don't know how to do that
08:10:23 <dcoutts_> aristid: oh, just ghc-pkg unregister --user pkgid
08:10:23 <ski> quicksilver : were you considering a definition based on transfinite induction ?
08:11:35 <quicksilver> ski: no, I don't think so. The ordinals are defined as equivalences class of order-types of sets.
08:11:47 <aristid> dcoutts_: ok, thanks, i also needed --force
08:11:59 <ski> yeah, but order-types refer to well-ordering
08:12:08 <ski> which is closely related to transfinite induction
08:12:09 <dcoutts_> aristid: right, it'll let you know which packages are now broken
08:12:22 <dcoutts_> aristid: cabal ignores broken packages, so it's easy to reinstall them
08:12:46 <dcoutts_> aristid: to make sure you don't get back into the same situation, use cabal install --dry-run to see what will be installed
08:12:51 <quicksilver> ski: ok, yes
08:13:48 <aristid> dcoutts_: what scares me is that there seem to be "base" packages in the broken list: readline-1.0.1.0 lambdabot-utils-4.2.1 haskell98-1.0.1.1 process-1.0.1.2 
08:13:51 <quicksilver> ski: if you define them purely as the closure under succ and lim you don't get very far.
08:14:19 <quicksilver> you don't get the construct the big ones
08:14:38 <dcoutts_> aristid: so long as those are in the user package db, not global that's fine
08:14:46 <dcoutts_> aristid: get rid of them
08:14:57 <dcoutts_> aristid: if it's the global package db then it's a problem
08:16:59 <ski> quicksilver : yeah, i'm aware
08:17:40 <aristid> dcoutts_: ok, thanks, i removed those broken packages and now i can compile my own stuff again
08:17:57 * ski finds <http://www.dcs.ed.ac.uk/home/pgh/ordinals.html> in addition to <http://www.dcs.ed.ac.uk/home/pgh/wwwwww.html> to stare at ..
08:18:11 <dcoutts_> aristid: if ghc-pkg check says everything is ok then you're ok
08:18:46 <aristid> dcoutts_: no, it says that some packages have missing dependencies
08:19:15 <aristid> i guess i'll see if that's down to outdated versions of stuff
08:19:18 <dcoutts_> aristid: well as long as they're not important ones it's ok, cabal will just ignore them and re-install them if necessary
08:21:09 <blitzkrieg> hi there
08:24:35 <aristid> dcoutts_: so i just tried to update Cabal, and it tried to install directory 1.0.1.0 again
08:24:48 <aristid> despite the fact that it already is on the system
08:24:49 <aristid> wtf
08:25:07 <dcoutts_> aristid: see --dry-run -v, it explains
08:25:17 <EvanR-work> if i find myself wanting to put data of different types that support a common interface into a single container, am i a) thinking too much oop, do something else b) need to use existentials or c) dont use a single container
08:26:03 <ski> (b) is one possible choice
08:26:26 <ski> (a) or (c) might be applicable in some cases
08:26:47 <dcoutts_> aristid: it's presumably because cabal is picking a newer installed version of one of the deps of directory, so directory needs to be rebuilt to make things consistent. But probably you should just use the older version so that directory does not need to be rebuilt.
08:26:51 <ski> also, often/sometimes instead of using existentials, closures suffice
08:27:13 <ski> (but not for "serious" use of existentials)
08:27:40 <aristid> dcoutts_: http://codepad.org/twEhKSJJ - that's pretty overwhelming
08:28:01 <dcoutts_> In order, the following would be installed:
08:28:02 <dcoutts_> directory-1.0.1.0 (reinstall) changes: unix-2.4.0.0 -> 2.4.1.0
08:28:02 <dcoutts_> process-1.0.1.2 (reinstall) changes: unix-2.4.0.0 -> 2.4.1.0
08:28:02 <dcoutts_> Cabal-1.10.0.0 (new version)
08:28:08 <dcoutts_> aristid: that's the important bit
08:28:12 <aristid> why the reinstall?!
08:28:19 <dcoutts_> see what I mean about the newer version of unix?
08:28:20 <EvanR-work> ski: yeah im getting insane trying to do it with a closure
08:28:21 <aristid> oh, because unix changed
08:28:22 <ski> EvanR-work : e.g. if you want to say `exists x. (x,x -> Foo -> Bar,x -> Baz)' you can of course instead say `(Foo -> Bar,Baz)'
08:28:25 <aristid> but why did unix change?
08:28:32 <EvanR-work> wrappers upon wrappers
08:28:35 <EvanR-work> boilerplate
08:28:42 <dcoutts_> aristid: you installed it for some reason, perhaps indirectly
08:28:50 <dcoutts_> aristid: e.g. if you did cabal upgrade
08:28:55 <EvanR-work> ski: im leaning toward a)
08:29:10 <aristid> dcoutts_: hmm maybe i did cabal install unix without thinking a long while ago
08:29:17 <ski> EvanR-work : it's hard to tell, without knowing what you're trying to do ..
08:29:30 <aristid> dcoutts_: so i should unregister the new version of unix, too?
08:29:33 <dcoutts_> aristid: and cabal's default policy is to use the latest version of each package
08:29:51 <dcoutts_> aristid: that would be the simplest thing to do
08:30:05 <aristid> dcoutts_: maybe it should protect packages shipped with GHC a little harder?
08:30:13 <aristid> like refusing to do cabal install unix
08:30:17 <dcoutts_> aristid: yep, we're thinking about that
08:30:22 <EvanR-work> ski: i have five different games, each has a json request/response interface and is addressed by a number
08:30:45 <EvanR-work> to use 5 containers, i need a 6th to figure out which one a particular number goes to
08:31:08 <dcoutts_> aristid: there's no problem with installing a newer version, but perhaps we could make the default policy to continue using the older version unless asked explicitly otherwise
08:32:07 <aristid> dcoutts_: i am observing problems with installing a newer versions, so "no problem" seems inaccurate
08:32:17 <EvanR-work> and probably 5 of a lot of other things
08:32:24 <EvanR-work> superficially the same
08:32:30 <dcoutts_> aristid: oh but that's only because we're using the newer version :-)
08:32:47 <aristid> installing and not using it makes a lot of sense :P
08:33:04 <ski> i'm not really sure what you mean by "to use 5 containers, i need a 6th to figure out which one a particular number goes to"
08:34:55 <EvanR-work> nevermind that, what kind of game can be part of the request
08:35:32 <EvanR-work> so send the request to an instance of the game with the specified id
08:36:06 <aristid> dcoutts_: lol, now i managed to break Cabal, it seems.
08:36:59 * ski isn't really getting a clear picture of this ..
08:37:11 <ski> (maybe you have some code attempt ?)
08:37:31 <aristid> dcoutts_: is removing .cabal and .ghc an accepted method to get a clean slate?
08:37:39 <EvanR-work> no i only have the individual games
08:38:08 <ski> how do the interfaces to them differ ?
08:38:24 <dcoutts_> aristid: technically, only removing ~/.ghc is required to wipe all per-user registered packages
08:38:29 <EvanR-work> they dont differ because the request is in json form
08:38:49 <aristid> dcoutts_: .cabal contains some binaries and i think they would be broken
08:38:51 <EvanR-work> internally they are totally different
08:39:09 <dcoutts_> aristid: no, they're statically linked
08:39:23 <ski> can't you just use a map/array/whatever, to look up the appropiate interface, given the index number, then ?
08:39:41 <aristid> dcoutts_: ah, true. well, i moved them to a backup directory anyways.
08:41:12 <EvanR-work> ski: youre right. but im wrong. besides the user-facing interface theres the server interface. thats not json, because thats a hassle. lets say that interface is a record with methods that act on a state of type a
08:41:22 <EvanR-work> thats the same for all games
08:41:26 <EvanR-work> a is not
08:41:51 <ski> ok
08:42:02 <ski> how does this record type look like ?
08:43:14 <EvanR-work> f :: a -> a, g :: Int, h :: a -> (Int,a), etc
08:43:23 <ski> specifically, do you have any field in the record where `a' occurs in the result type, or inside some other type constructor (apart from tuples and similar) ?
08:43:31 <ski> ok, yes you do
08:43:43 <ski> you have `a' in result of `f', and in result of `h'
08:44:02 <ski> so, the simplest is probably an existential, then
08:44:50 <ski> hm, btw, where does the initial `a' come from ?
08:45:09 <EvanR-work> initial state of a particular kind of game, or from a deserialize
08:45:43 <ski> i suppose another way is to do `data Foo = MkF { f :: Foo, g :: Int, h :: (Int,Foo)}'
08:46:05 <ski> that includes the initial state in `Foo', though
08:46:06 <EvanR-work> thats what im doing now, and Foo is made specifically to make my life easier for game Foo
08:46:37 <quicksilver> I'm not sure it matters much
08:46:41 <ski> (so then you can't extract `g' before having created the initial `a' .. which you *can* with the existential record above)
08:46:54 <EvanR-work> so maybe i should go ahead and make Bar and Baz and see if they are actually common parts
08:47:03 <quicksilver> data Game a = MkGame { state :: a, f :: a -> a, h :: a -> (Int,a) }
08:47:12 <quicksilver> versus ski's version of Foo
08:47:31 <EvanR-work> yeah Game a, but i cant put two kinds of a in the same Map Int (Game a)
08:47:54 <ski> you can do `Map Int (exists a. Game a)'
08:48:00 <EvanR-work> really?
08:48:19 <ski> (though probably you rather want something similar to `Map Int (exists a. (IO a,Game a))')
08:48:27 <EvanR-work> IO?
08:48:29 <ski> EvanR-work : in spirit, but not in body
08:48:38 <ski> you have to create a new type
08:48:52 <ski>   data SomeGame = forall a. WrapGame (Game a)
08:48:52 <EvanR-work> ah. skiskell ;)
08:49:03 <ski> and then use `Map Int SomeGame'
08:49:13 <EvanR-work> ok yeah ive seen that one
08:49:20 <EvanR-work> thats b) above ;)
08:49:25 <ski> well, with `Map Int (exists a. Game a)', you can't even hope to create the initial state
08:49:33 <ski> the `IO a' was to create the initial state
08:49:51 <ski> but maybe you don't want to put that creation into the map ?
08:49:59 <EvanR-work> i dont understand
08:50:13 <quicksilver> I think he has other ways to create games
08:50:22 <quicksilver> and by the time it goes in the map it is already a valid state
08:50:25 <quicksilver> I'm only guessing though ;)
08:50:33 <EvanR-work> i cant have X -> Game Y, and put Game Y into the map?
08:50:38 <ski> EvanR-work : hrm, actually
08:50:48 <ski> i misread quicksilver's `Game'
08:50:57 <ski> it includes `state :: a' .. that's what i missed
08:51:13 <ski> i thought it was just the record type you were describing first
08:51:39 <ski> so, if `Game a' includes a current (e.g. initial, in the map) state, then you can ignore what i said about `IO a'
08:52:23 <EvanR-work> i guess i dont have this fleshed out yet
08:52:34 <EvanR-work> i will hammer at it tonight and see if anything pops out
08:52:44 <EvanR-work> its taking me so long though ;)
08:54:16 <EvanR-work> is hackpage only for libraries, or also for programs?
08:54:20 <EvanR-work> hackage
08:54:50 <poucet> Does anyone know a function which does the equivalent of \x -> x/2 which works for both Integral and Fractional Num's?
08:54:51 <copumpkin> programs too
08:55:01 <qfr> Hm I thought it was libs only
08:55:11 <qfr> But I'll take copumpkin's word for it
08:55:13 <copumpkin> happy is up there
08:55:16 <copumpkin> cabal-install too
08:55:17 * ski wonders what laws poucet's function is supposed to obey
08:55:18 <quicksilver> poucet: there isn't one.
08:55:26 <qfr> Good point, cabal-install  I do know
08:56:16 <poucet> quicksilver: so I would need a typeclass: Class Halvable a where { half :: a -> a}; instance (Fractional a) => Halvable a where {half x = x/2}; instance (Integral a) => Halvable a where {half x = x `div` 2}  ?
08:56:27 <quicksilver> those instances don't work.
08:56:38 <poucet> -XUndecideableInstances ?
08:56:48 <quicksilver> instance selection is not guided by context.
08:57:01 <quicksilver> none of the extensions makes context guide them, either.
08:57:07 <poucet> Hmm
08:57:15 <jmcarthur> poucet: you have two instances of Halvable for "everything"
08:57:20 <poucet> jmcarthur: in theory
08:57:25 <jmcarthur> poucet: in practice
08:57:58 <quicksilver> you would have to write the instances out for each concrete type
08:58:08 <quicksilver> (possibly automated using TH or preprocessing)
08:58:10 <poucet> doh
08:58:21 <poucet> ideally, of course I would use shiftL 1
08:58:25 <poucet> erm shiftR?
08:59:23 <jmcarthur> depending on the type, shifts aren't necessary faster (or, of course, necessarily possible)
08:59:43 <jmcarthur> and some architectures have fast division by 2 anyway (perhaps by using the same machinery as a simple bitshift)
09:00:07 <jmcarthur> integer division by 2, that is
09:01:09 <poucet> Alright
09:06:00 <aristid> i bet that GHC can optimise (`div` 2)
09:06:52 <quicksilver> I'm fairly sure it doesn't, actually.
09:07:08 <quicksilver> the GCC backend might do, in some cases, and the LLVM backend might also.
09:07:22 <quicksilver> but GHC itself has not that much 'numerical optimisation'
09:07:59 <EvanR-work> is haskell generally bad for numerical computing
09:08:19 <EvanR-work> like high performance solving
09:08:41 <Ke> you can use haskell to generate high performance code like OpenCL
09:08:41 <EvanR-work> oh, data parallel...
09:08:45 <quicksilver> naive haskell doesn't perform very well there.
09:08:58 <quicksilver> however, haskell bindings to C libraries do well for certain tasks
09:09:06 <quicksilver> DPH or OpenCL may do well for other tasks.
09:11:26 <jmcarthur> aristid: i actually meant that some *architectures* do it. i bet x86 does it dynamically, for example
09:11:36 <tolkad> How safe is it to catch an exception with unsafePerformIO?
09:11:45 <jmcarthur> tolkad: not safe
09:11:51 <tolkad> what about just a UserError?
09:12:02 <tolkad> wait ErrorCall is it?
09:12:13 <tolkad> whatever it is when you type (error "xxx")
09:12:23 <jmcarthur> tolkad: it's still not safe (it breaks semantics), but maybe if you are the one that introduced the error in the first place
09:12:30 <jmcarthur> tolkad: let me guess... binary package?
09:12:41 <tolkad> jmcarthur: a similar one
09:13:07 <jmcarthur> tolkad: well, there's always the spoon package (which is pretty much exactly for the scenario you're describing)
09:13:33 <jmcarthur> tolkad: there are cases where you may want to use it, but i just want to be clear that i'm *not* saying it's always safe to use
09:13:45 <jmcarthur> that said, have fun using spoon :)
09:14:06 <copumpkin> there is no spoon
09:14:20 <tolkad> so what's the effective difference between spoon and teaspoon?
09:14:33 <copumpkin> teaspoon reduces to WHNF
09:14:35 <jmcarthur> tolkad: teaspoon evaluates to WHNF
09:14:41 <joe6> hello, I need some advice: I have [Bool] [a] [b] [c], I have a function that takes fn False a b c. Is there a better way to filter out the True's from [Bool] [a] [b] [c] without using zipWith4 where fn True _ _ _ = []
09:14:57 <EvanR-work> unsafePerformIO to *throw* an exception?
09:15:04 <copumpkin> tolkad: teaspoon (1:undefined) => Just (1:undefined)
09:15:06 <tolkad> no, catch
09:15:13 <EvanR-work> userError to throw an exception?
09:15:13 <copumpkin> spoon (1:undefined) => Nothing
09:15:14 <sipa> what's a [Bool] [a] [b [c] ?
09:15:28 <jmcarthur> sipa: i think that's a context
09:15:49 <jmcarthur> each thing is distinct, but the lists i think are intended to be interpreted as being in parallel with each other
09:15:49 <joe6> just 4 different lists
09:15:57 <joe6> yes
09:15:58 <jmcarthur> joe6: why avoid zipWith4?
09:16:15 <EvanR-work> tolkad: trying to catch an IO error occuring in pure code with pure code?
09:16:23 <copumpkin> joe6: maybe ParallelListComprehensions would make it look slightly prettier
09:16:36 <joe6> jmcarthur: not to avoid zipWith4, but just curious if there is a better way of doing both zipWith4 and filter as a higher order.
09:17:08 <joe6> jmcarthur: i can use zipWith4 and the function called with just ignore the True values.
09:17:24 <tolkad> EvanR-work: no, trying to catch an ErrorCall error
09:17:31 <joe6> but am wondering if there is a smarter way of doing the same.
09:17:36 <copumpkin> tolkad: spoon does it right!
09:17:47 <tolkad> Cool, thanks
09:17:53 <EvanR-work> man theres too many kinds of errors :(
09:18:03 <jmcarthur> joe6: the zipWith version sounds smart enough to me
09:18:04 <tolkad> EvanR-work: stay away from Java
09:18:07 <ShaneHudson> Does anyone here use Haskell-mode for Vim?
09:18:11 <quuuux> joe6: trueIndices = map snd $ filter fst $ zip listOfBools [0..], but having to mess around with list indices directly is uglier than the zipWith4 solution
09:18:18 * ski . o O ( "Error : unknown error code" )
09:18:21 <joe6> jmcarthur: ok, thanks.
09:18:24 <EvanR-work> tolkad: as far as i know, java only has one. Exception
09:18:41 <joe6> quuuux: ok, thanks.
09:18:50 <tolkad> EvanR-work: haskell only has one too, SomeException
09:19:06 <ski> @hoogle throw
09:19:07 <lambdabot> Control.Exception throw :: Exception e => e -> a
09:19:07 <lambdabot> Control.OldException throw :: Exception e => e -> a
09:19:07 <lambdabot> Control.Exception.Base throw :: Exception e => e -> a
09:19:19 <ski> `throw' accepts anything in the class `Exception'
09:19:19 <EvanR-work> but theres issues with whether it can throw or catch from IO or non IO..
09:19:29 <ski> (not just `SomeException')
09:19:48 <jmcarthur> EvanR-work: you can only catch from IO if you don't use unsafePerformIO
09:19:55 <tolkad> Java's throw accepts any subclass of Exception
09:20:04 <jmcarthur> EvanR-work: and "throwing" an exception in pure code is semantically just _|_
09:20:17 <sipa> any subclass of Throwable even, i think
09:20:41 <jmcarthur> maybe stick a comma after "IO" in what i said
09:21:09 <ski> jmcarthur : `catch (unsafePerformIO (return (..some IO action..))) (\e -> ...)' ?
09:21:18 <EvanR-work> jmcarthur: so whats spoon
09:21:40 <quuuux> @hoogle ((a, b, c) -> d) -> a -> b -> c -> d
09:21:41 <lambdabot> No results found
09:21:45 <quicksilver> EvanR-work: spoon is a wrapped up library for the unsafePerformIO solution.
09:21:58 <tolkad> EvanR-work: http://hackage.haskell.org/packages/archive/spoon/0.3/doc/html/src/Control-Spoon.html
09:22:01 <quicksilver> it is, essentially, something you use with broken liibraries which don't support the interface you wanted.
09:22:09 <EvanR-work> shouldnt pure code do something else if its supposed to be a recoverable error
09:22:11 <tolkad> EvanR-work: very little code, easiest for you to just read it probably
09:22:12 <EvanR-work> like Either
09:22:16 <quicksilver> yes, it should.
09:22:39 <quicksilver> spoon shouldn't be necessary, but it does give you a quick hack for using other people's pure code which doesn't sensibly report failure.
09:23:08 <EvanR-work> ok
09:23:22 <quicksilver> to use spoon is to acknowledge that you disagree with the library author about their API choices :)
09:23:34 <EvanR-work> so ideally we use exceptions in IO, and not in non IO
09:23:47 <EvanR-work> unless its error, which doesnt 'count' ?
09:24:08 <quicksilver> throwing exceptions in pure code is not intrinsically bad
09:24:13 <quicksilver> but trying to recover from such is.
09:24:14 <quicksilver> basically.
09:24:24 <EvanR-work> so only use fatal errors in pure code ;)
09:24:25 <ski> @type (. (,,)) . (.) . (.)  -- quuuux ?
09:24:26 <lambdabot> forall a b c b1. ((a, b, c) -> b1) -> a -> b -> c -> b1
09:24:50 <quuuux> ski: I was hoping there was a convenient uncurry3 function somewhere :)
09:24:51 <jmcarthur> :t catch (unsafePerformIO (return undefined)) (\e -> undefined)
09:24:52 <lambdabot> Not in scope: `unsafePerformIO'
09:24:59 <jmcarthur> bah
09:25:55 <jmcarthur> ski: i'm confused about what you're getting at with that code
09:25:57 <ski> @type catch (System.IO.Unsafe.unsafePerformIO (return undefined)) (\e -> undefined)
09:25:59 <lambdabot> forall a. IO a
09:26:15 <tolkad> > System.IO.Unsafe.unsafePerformIO (print "")
09:26:16 <lambdabot>   Not in scope: `System.IO.Unsafe.unsafePerformIO'
09:26:22 <ski> jmcarthur : my point is just that `unsafePerfomIO . return = id'
09:26:33 <jmcarthur> yes...?
09:26:52 <jmcarthur> ski: oh, maybe you didn't see where i said i should have put a comma after IO?
09:27:10 <ski> so you *can* `catch' in `IO' and "use" `unsafePerformIO' at the same time
09:27:27 <jmcarthur> ski: yeah, that's not what i meant. inserting a comma into what i said:
09:27:46 <jmcarthur> "you can only catch from IO, if you don't use unsafePerformIO"
09:28:00 <tolkad> Why do haskell data types have to use a full word of space?
09:28:02 <jmcarthur> "you can only catch from IO [, unless you are using] unsafePerformIO"
09:28:03 <ski> ah -- that explains it :)
09:29:28 <tolkad> I mean if I have  data T = A {-# UNPACK #-} !Bool | B {-# UNPACK #-} !Bool  I'm pretty sure that should require only a byte of memory
09:30:03 <sipa> it stil needs to store whether it's A or B, right?
09:30:40 <copumpkin> tolkad: bit packing has a bit of overhead too, depending on what you're doing with it
09:30:41 <tolkad> yes, there are 4 possibilities: A True, A False, B True, B False
09:30:49 <EvanR-work> why does almost everything that starts with "i'm pretty sure that..." end up being false xD
09:31:04 <copumpkin> tolkad: but anyway, yeah, it could do that
09:31:17 <j-invariant> EvanR-work: Descartes said: When my thinking is completely transparent I am incapable or error
09:31:30 <copumpkin> it could start by just allowing you to unpack data with more than one constructor (like Bool)
09:31:32 <EvanR-work> j-invariant: you mean, of error
09:31:42 <tolkad> EvanR-work: Since I used the word "require", my statement was technically correct
09:33:19 <tolkad> What about just Bool, does that also use a full word of space?
09:33:22 <EvanR-work> i'm pretty sure it wasnt ;)
09:34:48 <tolkad> oh, I guess the reason haskell datatypes do that is because they are all pointers
09:35:05 <quicksilver> tolkad: no, that's not the reason.
09:35:18 <quicksilver> (the pointer is not the payload)
09:35:50 <tolkad> quicksilver: then why?
09:36:04 <quicksilver> it simplifies various things, but it's not a hard requirement.
09:37:08 <tolkad> it is rather silly that memory usage doubles if you switch to 64 bit
09:37:32 <quicksilver> GHC doesn't want to manage half-words in the heap, I guess
09:37:38 <quicksilver> so everything is word-aligned.
09:37:53 <quicksilver> non-word-aligned access may be slower or even an address error on some hardware
09:38:17 <quicksilver> but you definitely can imagine solutions which, for example, reserve a specific playground for 1-byte objects and pack them all in there.
09:38:30 <quicksilver> there are trade-offs all over.
09:38:57 <tolkad> quicksilver: C doesn't have any problem with non-word aligned access
09:39:12 <sipa> that doesn't depend on the language
09:39:21 <quicksilver> tolkad: yes, I'm discussing code generation here.
09:39:38 <quicksilver> the C compiler is smart enough to generate code which accesses data in the appropriate way for the hardware
09:39:52 <quicksilver> certainly a legal way and, hopefully, also the fastest way.
09:40:06 * hackagebot Unixutils 1.35 - A crude interface between Haskell and Unix-like operating systems  http://hackage.haskell.org/package/Unixutils-1.35 (JeremyShaw)
09:40:09 <quicksilver> but it's still true (even in C) that non-word-aligned access might be slower.
09:40:11 <copumpkin> unfortunately that may involve loading adjacent words and shifting to get what you need
09:41:58 <quicksilver> tolkad: I'm pretty sure C word-aligns "struct {}"
09:42:04 <ray> c implementations tend to align stuff
09:42:15 <quicksilver> and similarly C++ word-aligns "class {}"
09:42:31 <sipa> it aligns every field to its own alignment requirement, and optionally more to improve performance :)
09:42:32 <quicksilver> (I'm abusing language, of course by "C" I mean "typical C compilers")
09:42:44 <quicksilver> sipa: I meant the struct itself, not the fields
09:42:57 <quicksilver> I know the fields are subject to complex rules and ugly pragmas.
09:43:18 <sipa> if the struct has an element which requires N-byte alignment, the struct itself should be aligned to a multiple of NN
09:43:32 <ray> usually when people talk about struct alignment it's some weird legal argument about the fields
09:43:36 <quicksilver> I suspect that malloc() never returns a non-word-aligned pointer, either?
09:44:10 <quicksilver> but again, you can use custom allocators for you sub-word-size objects if you want to.
09:44:11 <_mpu> quicksilver: it never returns a non-word-aligned pointer
09:44:21 * edwardk waves hello.
09:44:29 <quicksilver> (and you may find yourself paying a cost for dereferencing them)
09:44:33 <ray> edward wk
09:44:35 <j-invariant> hi
09:44:37 * sipa particles hello.
09:45:15 <EvanR-work> smaller memory, less speed, ftw!
09:45:27 <EvanR-work> save the whales
09:45:49 <quicksilver> so, the classic K&R copy loop "while (*p++ = *q++);" is painfully slow if naively compiled.
09:46:04 <quicksilver> although I daresay GCC rewrites that to something which copies word-at-a-time
09:46:29 <tolkad> iff you had a program that could arbitrarily increase its speed by increasing memory usage, how much memory should you use?
09:46:35 <tolkad> if*
09:46:40 <quicksilver> all the memory I had :)
09:46:45 <quicksilver> (if I wanted the program to run fast)
09:46:48 <quicksilver> but no more!
09:46:50 <sipa> i have this nifty thing called a kernel
09:46:56 <portnov> hi all
09:47:04 <EvanR-work> if you had a program that could arbitrarily use less memory by going slower, how slower would you make it go ;)
09:47:13 <sipa> it fills my physical memory with all kinds of data that comes from slower memory
09:47:22 <sipa> as long as there is room :p
09:47:24 <ray> all the memory and all the virtual memory until the page faults started making it slower than they made it faster
09:47:46 <portnov> Q: FFI calls lock all haskell threads. Can this be worked around? Or maybe it's fixed in newer versions of ghc?
09:47:58 <EvanR-work> they dont, right
09:48:12 <EvanR-work> theres dedicated ffi os threads
09:48:32 <portnov> hm
09:48:41 <jmcarthur> might require -threaded for that
09:48:58 <tolkad> sipa: well let's say this data is also persistent between runs. it would be inefficient to have the kernel store it in non-volatile memory in addition to your own program storing it there
09:50:13 <sipa> it needs to be copied to main memory anyway first
09:50:22 <tolkad> portnov: http://hackage.haskell.org/packages/archive/base/4.3.1.0/doc/html/Control-Concurrent.html#v:forkOS
09:50:40 <sipa> so why not just leave it there until there is something more appropriate to put there instead?
09:51:31 <EvanR-work> sipa: security! privacy! digital rights management!
09:51:32 <tolkad> portnov: quarantine FFI calls to bound threads. You could even implement a queueing system so that you could call them from other code
09:52:23 <jmcarthur> packing more than one thing into a word can be more efficient in some cases due to cache effects, but i doubt most ADTs would benefit
09:52:58 <jmcarthur> there's usually more benefit when it's something like an array that you're iterating over
09:53:23 <jmcarthur> an unboxed array, of course
09:53:51 <tolkad> portnov: just figure out exactly which calls can be run in sequence with eachother and reserve a bound thread with a queue of function calls for each set
09:54:45 <Saizan> portnov: just -threaded will already prevent the lock of all haskell threads
09:54:50 <jmcarthur> tolkad: overkill. i'm pretty sure the ghc runtime can automatically put FFI calls into their own threads
09:55:25 <tolkad> jmcarthur: but if you do it yourself you can fine-tune it to be perfect
09:56:20 <tolkad> jmcarthur: waiting too long to optimize is the root of all evil
09:56:42 <sipa> but premature optimization may be even as bad
09:56:59 <tolkad> You can never optimize too much
09:57:19 <tolkad> CPU time costs more than programmers
09:57:25 <Saizan> putting FFI calls in bound threads makes sense only if they use some thread local state
09:57:35 <Saizan> otherwise you're just adding an useless bottleneck
09:57:36 <ray> premature optimization is the root of all something, hang on while i page in what that something is
09:58:25 <Saizan> (getting worse performance due to contention)
09:58:29 <tolkad> I'm kidding, listen to them
09:59:17 <EvanR-work> optimize early and often (tm)
10:00:14 <zygoloid> @remember Knuth We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%.
10:00:14 <lambdabot> Done.
10:00:50 <jmcarthur> i actually prefer to optimize early and often, but i'm not so sure that manually writing out this bound thread idea is even going to help much if at all
10:01:00 <ray> premature reading of knuth is the root of all quibbling about the efficiency of trivial algorithms
10:01:18 <sipa> lol
10:01:20 <jmcarthur> ray: at least that was the whole quote
10:01:38 <ray> yes
10:01:54 <zygoloid> well, that was the whole paragraph. the preceding paragraph is relevant too
10:02:41 <jmcarthur> zygoloid: sure, but "Premature optimization is the root of all evil," or, worse, "Optimization is the root of all evil." ... those just completely change the meaning
10:02:53 <zygoloid> @remember Knuth The conventional wisdom shared by many of today's software engineers call for ignoring efficiency in the small; but I believe this is simply an overreaction to the abuses they see being practiced by pennywise-and-pound-foolish programmers, who can't debug or maintain their "optimized" programs.
10:02:54 <lambdabot> Done.
10:03:19 <jmcarthur> i wish that was quoted more ^^
10:03:21 <zygoloid> jmcarthur: certainly, agreed :)
10:04:37 <EvanR-work> yeah also programmers cant write code correctly the first time, and they keep making spelling errors. find people who dont have these properties and we will have way easier times writing compilers and anything else
10:04:55 <EvanR-work> in addition to not being able to maintain heavily optimized code
10:05:18 <tolkad> Is it possible to set RTS options at compile time?
10:05:50 <jmcarthur> EvanR-work: i think the idea behind the quote is that there *are* people wise enough to manage to optimize as they go without completely killing correctness or maintainability
10:06:12 <hvr> is there a way to let 'cabal sdist' keep the executable-bit for extra-source-files (if they have it)
10:06:13 <jmcarthur> tolkad: i believe you have to write a simple C wrapper to call your main function to do that
10:06:51 <jmcarthur> tolkad: there may be a way to do it in ghc 7 without all that hassle though. i seem to recall there being something...
10:07:29 <tolkad> GHC7!?!?!?!? THAT'S WHAT I HAVE!!!
10:07:44 <tolkad> 
10:08:04 <jmcarthur> wtf
10:08:34 <zygoloid> must be a cat on the keyboard or something
10:08:50 <tolkad> jmcarthur: I just got excited at the coincidence that you mention the same version of GHC that I had
10:08:54 <djahandarie> Pretty smart cat to be able to enter an interrobang
10:09:05 <jmcarthur> not much of a coincidence when you're in #haskell...
10:09:17 <ray> half of #haskell are cats
10:09:23 * jmcarthur is a cat
10:09:25 <zygoloid> jmcarthur: #haskell!?!?!?!?!? THAT'S WHERE I AM!!!
10:09:38 <djahandarie> lol
10:09:42 <jmcarthur> OMG ME TOO!!!
10:09:55 <zygoloid> 
10:10:57 <dcoutts_> hvr: yes, I've received a patch to fix that, it'll be in the dev version soon
10:11:50 <hvr> dcoutts_: great... I had some .sh scripts which lost their x-bits :)
10:18:26 <aristid> which crypto packages are most fashionable? :)
10:18:39 <aristid> currently i use Crypto, but i get the feeling that is not the package du jour
10:19:22 <copumpkin> Louis Vuitton has a new package
10:19:31 <copumpkin> @hackage lv
10:19:31 <lambdabot> http://hackage.haskell.org/package/lv
10:19:36 <aristid> copumpkin: does it support HMAC?
10:20:06 <aristid> my hackage is broken, it does not show the louis vuitton package!
10:23:25 <diPython> hey, does anyone know how can I create an heterogenous list of functions?! I tried HList, but it's not suited since I need to create instances of Apply and since the elements are functions it sucks. I tried GADTs but still no success. does anyone tried this before?!
10:25:01 <monochrom> I am not sure what a heterogenous list of functions is good for.
10:25:32 <tolkad> what exactly is a heterogenous list of functions?
10:26:21 <philo> wouldnt that be a list of function of diferent types ?
10:26:22 <monochrom> perhaps like [sin, not, id, show, read]
10:26:41 <philo> monochrom:  can haskell typesystem allow that ?
10:26:45 <monochrom> no
10:26:53 <mrd> wow that was a fast move
10:26:54 <jmcarthur> well, it sort of can...
10:27:07 <philo> how so ?
10:27:19 <philo> with type classes ?
10:27:22 <andy_> ADT
10:27:28 <jmcarthur> HList is an ugly way, but it works
10:27:35 <diPython> i've created my own parser library, and i need to have a list of different semantics functions to allow sharing of parsers
10:27:37 <jmcarthur> or you could wrap everything as an existential type
10:28:00 <mrd> diPython: sounds like you want a type class
10:28:01 <tolkad> diPython: use existential quantification along with a wrapper data type for functions and a class that does whatever you need to be able to do with these functions
10:28:03 <jmcarthur> each has limitations
10:28:06 <andy_> data F = (forall a. ID (a -> a))?
10:28:35 <jmcarthur> HList is essentially just tuples with some slightly handier functions to manipulate them
10:28:39 <diPython> yep
10:28:59 <diPython> but HList is not suited for this i think, because i need to create instances of Apply, to be able to use hMap
10:29:26 <jmcarthur> and the existential typing approach requires you to "forget" all your types and rely solely on type classes or dictionaries included with the value in order to do anything with the values
10:29:31 <tolkad> diPython: data SomeFunction forall a. FunctionClass a => SomeFunction a; class FunctionClass a where { whateverIWantToDoWithTheseFunctions :: a ->  }  
10:30:00 <monochrom> I have created my own parser library too, but I haven't needed a heterogenous list of semantics functions. Perhaps you're abusing lists (a common disease of python and perl) when you should use a record.
10:30:20 <monochrom> (and a common disease of lisp and scheme)
10:30:36 <diPython> perhaps
10:31:22 <diPython> i only need this list to allow sharing
10:31:38 <tolkad> sharing?
10:31:44 <mrd> why is the parser doing semantics of the language?
10:31:59 <diPython> like : s = fsem <$> q <|> gsem <$> q 
10:32:08 <diPython> i only compute q once
10:32:26 <jmcarthur> but what does that have to do with lists?
10:32:51 <monochrom> then fsem and gsem have the same type
10:32:52 <diPython> well i need to store fsem and gsem on some structure
10:33:00 <diPython> monochrom yes
10:33:03 <jmcarthur> why a list and not an ADT?
10:33:19 <monochrom> so screw heterogenous list
10:34:00 <diPython> monochrom no, since s = fsem <$> q <|> gsem <$> q <*> r
10:34:08 <diPython> now fsem and gsem have different types
10:34:14 <tolkad> I'm completely lost
10:34:25 <monochrom> eh? you're changing it to add <*> r?
10:34:47 <tolkad> I haven't had to use Applicative though
10:34:52 <monochrom> I forgot the operator precedences. please add parentheses completely.
10:35:35 <parcs> if i want to work inside a monad that contains a writable context and a separate read-only context, should i use a "ReaderT r (Writer w) a", "WriterT w (Reader r) a", a "State (r, w) a" or something else?
10:35:54 <diPython> s = ((:[]) <$> q) <|> ((\a b -> a:b:[]) <$> q <*> Sym 'b')
10:35:56 <zygoloid> monochrom: liftA1 fsem q <|> liftA2 gsem q r
10:35:57 <diPython> q = Sym 'a'
10:36:13 <diPython> as a dummy example
10:36:18 <tolkad> parcs: state is overkill
10:36:45 <parcs> tolkad: i think so too
10:36:45 <diPython> jmarthur what does ADT stands for?
10:36:53 <parcs> but it looks nicest as a type signature
10:37:05 <jmcarthur> algebraic data type
10:37:15 <jmcarthur> defined using the data keyword
10:37:22 <monochrom> do { x<-q; return (fsem x) <|> (gsem x <$> r) }
10:37:27 <j-invariant> what does "algebraic" data type mean
10:37:28 <diPython> ah
10:37:33 <monochrom> still no list.
10:37:35 <j-invariant> an algebraic number is the INVERSE of a polynoimal
10:37:39 <tolkad> parcs: meh just write a type synonymn and a few helper functions to automatically lift stuff for you
10:37:41 <j-invariant> the algebraic type is not the inverse
10:37:50 <monochrom> also q is "executed" only once. maximal sharing.
10:38:20 <diPython> anyway how do i put different functions in a ADT?
10:38:44 <monochrom> data X = F0 (Int -> Int) | F1 (Bool -> ()).
10:38:57 <diPython> yes, that's good when u know the types
10:39:05 <diPython> but i don't know the types of the semantic functions
10:39:20 <zygoloid> j-invariant: an algebraic number is one which is a solution of some polynomial expression. an algebraic data type is sorta the same
10:39:25 <jmcarthur> then how do you use them, diPython?
10:39:46 <diPython> i don't know they statically 
10:39:49 <j-invariant> zygoloid: oh yes I see now
10:39:51 <j-invariant> cool
10:40:01 <jmcarthur> diPython: so you mean client code passes them in?
10:40:08 <diPython> yes
10:40:13 <monochrom> there is no need to put fsem,gsem per se in a list. consider [(fsem <$>), (\q -> gsem <$> q <*> r)]. not heterogenous.
10:40:17 <jmcarthur> i would say that client code should be responsible for sharing then
10:40:23 <tolkad> data TEither a b c where { TLeft :: c ~ a => a -> TEither a b a; TRight :: c ~ b => b -> TEither a b b }
10:40:29 <tolkad> would that work?
10:40:45 <tolkad> sorry it just looked kind of cool
10:40:47 <diPython> jmcarthur but the purpose is to do left factorization for free
10:41:04 <diPython> you can always left factorize your grammar 
10:41:43 <jmcarthur> i really need to learn my parsing theory. i think i understand what that means, but i don't know what's involved
10:42:29 <diPython> i have a grammar S -> P | P Q, P -> 'a', Q -> 'b'
10:42:54 <monochrom> of course you could also use the list [return . fsem, (\x -> gsem x <$> r)]
10:45:11 <monochrom> anyway if you're looking at "haha q <|> funfun xx q <|> wheewhee q yy" and want to capture the commonality by a list, it's pretty obvious that [haha, funfun, wheewhee] is not it, even if allowed. The obvious commonality is [haha, funfun xx, \q -> wheewhee q yy]
10:45:34 <monochrom> similarly if <$> <*> are involved.
10:47:15 <diPython> by "haha q" you mean "haha <$> q"?
10:47:27 <monochrom> no.
10:47:42 <monochrom> but perhaps haha = (haha' <$>)
10:48:09 <monochrom> you know that it's possible, don't you?
10:48:26 <diPython> y
10:49:02 <joe6> in prettyPrint renderStyle, does anyone know what ribbonsPerLine mean? (The manual says that it is the ratio of ribbon length to line length)
10:49:19 <joe6> just curious on what ribbon length is?
10:49:42 <monochrom> who knows, perhaps funfun = \a b -> hsem <$> b <*> b <*> a, so funfun xx q is something really strange.
10:50:48 <diPython> monochrom, the thing is that i want the user to write parsers in the same way
10:51:42 <diPython> monochrom explain me smth
10:51:45 <diPython> if i have
10:51:54 <diPython> data SemList :: * -> * where
10:51:54 <diPython> 	SingleSem :: (b -> a) -> SemList b
10:51:56 <diPython> 	ListSem   :: (b -> a) -> SemList c  -> SemList b 
10:52:34 <byorgey> joe6: I have wondered the same thing.  After some experimentation I concluded that it's basically the width of the text on a given line
10:52:39 <diPython> ssMap :: SemList (Char,b) -> Char -> SemList b
10:52:39 <diPython> ssMap (SingleSem f) char = SingleSem (\r -> f (char,r))
10:52:39 <diPython> ssMap (ListSem f rest) char = let rest' = ssMap rest char
10:52:40 <monochrom> that seems to be existential, isn't it?
10:52:40 <diPython> in ListSem (\r -> f (char,r)) rest'
10:52:52 <diPython> this doesn't work
10:53:09 <diPython> what i don't understand is that i thought c is a free type variable
10:53:09 <byorgey> joe6: the idea being that as the code flows down the page it resembles a "ribbon" of a certain width which winds back and forth as the indentation level increases and decreases
10:53:36 <diPython> but i get: Couldn't match expected type `(Char, b)' against inferred type `c'
10:53:36 <diPython> `c' is a rigid type variable bound by
10:53:37 <diPython> the constructor `ListSem'
10:53:42 <byorgey> joe6: and the idea is that you don't want the text always extending all the way to the right margin no matter what the indentation, since that looks bad
10:54:23 <byorgey> joe6: but this only makes sense for pretty-printing code, actually
10:54:24 <diPython> i thought that was the "power" of gadts
10:54:56 <byorgey> so if you are pretty-printing something else you may want to set the ratio to 1, so that it won't put things onto the next line until it actually reaches the page width
10:56:02 <lowasser1> Does anyone know, off the top of their head, what the effect of a {-# SPECIALIZE #-} pragma in a class declaration is?
10:56:24 <lowasser1> I mean, I'd assume that either it does nothing or it adds an entry to the dictionary for the class
10:56:39 <byorgey> diPython:   ListSem :: (b -> a) -> SemList c -> SemList b  means that a SemList of *some* type c is contained but you don't know what type
10:57:11 <byorgey> diPython: in particular it certainly will not match with anything you want
10:57:19 <diPython> ok, but so why can't I instantiated to whatever i want?
10:57:36 <diPython> it's a free type variable
10:57:49 <byorgey> you get to instantiate it to whatever you want when you put a SemList *into* the ListSem constructor
10:58:16 <lowasser1> but when you decompose the ListSem constructor, it doesn't know what the type variable was when you instantiated it
10:58:21 <byorgey> but when you pattern-match on ListSem you will get a SemList of *some particular* type, at that point you don't get to decide what type you want it to be.
10:58:26 <byorgey> right
10:58:32 <lowasser1> lol <--- jumped in
10:58:49 <monochrom> the "a" in "b -> a" is also lost.
10:59:13 <benmachine> how easy is it to install more than one major version of GHC? can I tell the install system to not clobber my existing binaries?
10:59:42 <lowasser1> benmachine: it's more than a little tricky
10:59:51 <jmcarthur> benmachine: just install with a different prefix
10:59:57 <jmcarthur> lowasser1: huh? it's easy
10:59:58 <lowasser1> I had some trouble keeping packages consistent
10:59:59 <lowasser1> meh
11:00:09 <jmcarthur> it organizes packages separately
11:00:15 <lowasser1> hmmk
11:00:16 <benmachine> jmcarthur: I could do, but I've already got one in /usr/bin and /usr/local/bin
11:00:22 <benmachine> running out >_>
11:00:24 <jmcarthur> you just have a different version of each package for each version of ghc
11:00:35 <qfr> What does {-# LANGUAGE TypeFamilies, QuasiQuotes #-} at the beginning of a file do?
11:00:44 <jmcarthur> benmachine: i also have an installation of GHC HEAD in my home directory ;)
11:00:52 <diPython> i see
11:00:54 <qfr> Is that some hint for ghci or something?
11:01:08 <benmachine> jmcarthur: do you have any idea if installations are relocatable after the fact?
11:01:09 <zygoloid> qfr: no, it's a pragma which tells GHC to turn on some language options
11:01:18 <monochrom> this is why I am unconvinced of heterogenous lists and various existential tricks to mimick them. it only begs the question: how are you going to use the elements, uniformly? are you going to downcast?
11:01:22 <jmcarthur> benmachine: i have no idea, but that is something i would also like to know
11:01:31 <zygoloid> qfr: it's very much like running GHC with -XTypeFamilies -XQuasiQuotes
11:01:36 <byorgey> benmachine: probably not easily.
11:01:39 <qfr> zygoloid ah I see
11:01:44 <benmachine> byorgey: aw, why not
11:01:48 <byorgey> benmachine: I use stow for this purpose, and it works well
11:01:59 <lowasser1> heterogeneous lists seem kind of useless, certainly without some context on the existential quantifier
11:02:08 <benmachine> byorgey: I see
11:02:15 <qfr> zygoloid Yesod used this in an example, it seems kinda intrusive
11:02:23 <qfr> In http://docs.yesodweb.com/book/basics/
11:02:33 <byorgey> benmachine: but you have to install using stow in the first place, I think it would be hard to move an existing installation to be under stow
11:02:35 <qfr> I presume you can set this up globally using cabal?
11:02:42 <qfr> Globally for a project I mean
11:02:46 <zygoloid> qfr: you can put language settings in your .cabal file, yes.
11:02:48 <diPython> i'm going to use the elements uniformally yes
11:02:58 <diPython> uniformly
11:03:22 <benmachine> byorgey: is it surprising if my distro doesn't have a stow package?
11:03:22 <monochrom> no, the comma is for emphasis. the question is: how are you going to use the elements uniformly?
11:03:28 <lowasser1> lol yeah
11:03:33 <lowasser1> I do not think that word means what you think it means
11:03:45 <lowasser1> (uniformly)
11:03:55 <benmachine> oh it's in aur, never mind
11:04:04 <qfr> Is it common for Haskell libraries to depend on such pragmas? I am not sure I like this
11:04:09 <qfr> I don't even know what these do
11:04:12 <lowasser1> lol
11:04:20 <lowasser1> it's just there to turn on template haskell syntax
11:04:33 <diPython> i'm going to get that element (function) and create another function out of it
11:04:41 <lowasser1> and type families, which are an advanced type system thing that apparently that program needs
11:05:06 <djahandarie> Type families are pretty simple conceptually
11:05:08 <diPython> like [f,g] -> [(\x -> f x), (\x -> g x)]
11:05:11 <djahandarie> A lot of syntax for them though
11:05:18 <djahandarie> A lot of which does the same thing in different places
11:05:21 <lowasser1> turning options like that on with pragmas is generally considered polite, so you don't have to compile every module with all the options
11:05:55 <lowasser1> (type families are a recent enough development in type systems -- and nearly unique to Haskell, to the best of my knowledge -- that they fit my definition of "advanced")
11:06:10 <noknok> Hi there! Does anybody have an idea what the "nub" abbreviation stands for in the List.nub function that eliminates multiple elements from a list?
11:06:34 <lowasser1> dipython: okay, I suppose that'd work
11:06:44 <lowasser1> if you're using heterogeneous lists for both the input and the output there
11:06:45 <benmachine> noknok: http://en.wiktionary.org/wiki/nub meaning #1 would be my guess
11:07:26 <c_wraith> noknok: as I understand it, it's from french
11:07:32 <lowasser1> (not that I think you'd get much use out of the output of that heterogeneous list function, though)
11:07:44 <lowasser1> like, you have a heterogeneous list
11:07:51 <lowasser1> sure you can do things to make new heterogeneous lists from that
11:08:01 <diPython> that's what i need
11:08:26 <lowasser1> but then you realistically can't actually do anything with it after that
11:08:33 <monochrom> /dev/null is the greatest heterogenous list of all
11:08:38 <lowasser1> lol
11:08:42 <diPython> yes i can
11:08:51 <lowasser1> convince me
11:08:51 <noknok> benmachine, c_wraith: Thank you! I didn't think that "nub" actually is a word..
11:09:18 <benmachine> noknok: it's not a common one :)
11:09:20 <lowasser1> 'cause once you have an existential type in there, it's really hard to do anything with it
11:10:45 <noknok> benmachine: Yeah. Thank's again.
11:11:12 <benmachine> ho hum, the GHC binary package uses binary utilities that are linked against a different major version of libgmp than mine
11:11:16 <benmachine> so I can't use it
11:11:22 <benmachine> er, the GHC binary distribution
11:11:24 <benmachine> not the binary package
11:11:28 <diPython> if i have a list of functions, i can basically get a list of results of applying that functions right?
11:11:42 <lowasser1> with a heterogeneous list? I doubt it
11:12:01 <lowasser1> I mean
11:12:18 <monochrom> you make it sound so easy. if you have this list of functions [sin, not], what can you apply those functions to?
11:12:23 <lowasser1> yeah
11:12:28 <lowasser1> lol thanks monochrom
11:12:47 <diPython> [1,True]
11:12:58 <diPython> and get [sin 1, not True]
11:13:01 <lowasser1> but you won't be able to prove with the type system that those types match up
11:13:06 <lowasser1> with heterogeneous lists
11:13:17 <lowasser1> and your code won't compile
11:13:25 <tolkad> will -with-rtsopts "-B" work for commercial software?
11:13:59 <benmachine> tolkad: why wouldn't it?
11:14:07 <benmachine> apart from being really annoying >_>
11:14:08 <lowasser1> with heterogeneous lists, all the compiler knows is that there's some type there
11:14:17 <lowasser1> no idea what type
11:14:18 <monochrom> if all you plan to do is to pair up [sin,not] with [1,True], why don't you have [sin 1, not True] to begin with?
11:14:24 <lowasser1> yep
11:14:48 <lowasser1> the proper conclusion to draw from this is "I should be using the actual structures I mean"
11:14:57 <tolkad> benmachine: just wanted to make sure I'm using haskell best practices
11:15:22 <benmachine> tolkad: I don't know that the -B rts options would usually be described as a best practice
11:15:27 <lowasser1> not "I should figure out some hellacious workaround to eliminate a tiny bit of work, never mind that it won't typecheck"
11:15:49 <lowasser1> (if you're really keen on reducing the amount of redundant code, look into generics and SYB)
11:16:03 <diPython> because i don't know if i will get 1,2,..., which is the result of a parser
11:16:20 <benmachine> tolkad: it has some niche use in debugging
11:16:20 <lowasser1> then you have a data type that includes all of the various possibilities
11:16:33 <lowasser1> or a GADT, that's fine too
11:16:52 <monochrom> the real value of [sin,not] is to apply all functions to the same parameter, i.e., map ($ x) [sin,not]. As you have illustrated with your fsem<$>q <|> gsem<$>q<*r> example. You want to use the same q for both. That is the only reason to put both in the same list.
11:17:50 <monochrom> If all you have is fsem<$>a <|> gsem<$>b<*>r, no commonality whatsoever, you may as well write [fsem<$>a, gsem<$>b<*>r] already.
11:18:06 <diPython> yes, i'm doing that
11:18:06 <xarch> anyway [sin, not] doesn't typecheck
11:18:15 <diPython> i'm using unsafeCoerce
11:18:19 <lowasser1> oh god
11:18:20 <lowasser1> don't do it
11:18:22 <diPython> lol
11:18:24 <diPython> it works
11:18:36 <lowasser1> it's like killing babies
11:18:37 <lowasser1> and kittens
11:18:48 <lowasser1> it's the wrong way to do it
11:18:51 <lowasser1> no matter what you're doing
11:18:51 <diPython> actually i'm using StablePointers to do equality on parsers
11:18:55 <qfr> Do any of you have any opinion on Snap vs. Yesod vs. Happstack? Originally I wanted to write my own framework but I thought I should give some of the big Haskell frameworks a try anyways
11:19:07 <lowasser1> AUGHHHHHHHHH ::runs to his room and shuts the door::
11:19:09 <qfr> Oh and Twey mentioned one called Horse which I haven't come across yet
11:19:12 <diPython> lol
11:19:15 <diPython> hahaha
11:19:19 <lowasser1> seriously
11:19:22 <xarch> I prefer Snap, personally
11:19:31 <c_wraith> Horse is kind of an experiment in using arrows for web site design.
11:19:34 <qfr> I find Snap using that XML templating language a bit icky, I find the whole redundant HTML derived markup rather annoying to type, too
11:19:35 <xarch> that's because I don't like QQ and all that stuff
11:19:40 <c_wraith> It's terrifying to mortals.  Oh, and slow.
11:19:41 <lowasser1> I can't imagine any circumstances under which I'd use unsafeCoerce or stablepointers, even if someone paid me $100
11:19:55 <qfr> xarch: QQ? The big Chinese IM?
11:19:55 <arcatan> qfr: Snap, and apparently Happstack, pretty much give you just a HTTP server
11:19:56 <lowasser1> if you're having to do that, you're not thinking about the problem correctly
11:19:56 <mightybyte> qfr: You don't have to use our templating engine to use Snap.
11:19:59 <monochrom> I can, but not for mere parsing.
11:20:03 <aristid> lowasser1: what if he paid $1000?
11:20:04 <arcatan> qfr: Yesod is more of a batteries-included solution
11:20:04 <xarch> qfr: quasiquoting
11:20:07 <cdsmithus> qfr: If it's specifically xml you're concerned about, I've spent the last week making Heist work with HTML, and it should be out soon
11:20:08 <monochrom> not even for a very general parser lib.
11:20:26 <diPython> how would do equality on parsers then?
11:20:35 <qfr> xarch: The pragma stuff turned me off a bit in the examples but I don't really know what it does anyways
11:20:36 <benmachine> agda compiles to haskell with unsafeCoerces basically everywhere
11:20:40 * arcatan never used Heist with Snap
11:20:40 <diPython> parsers or general functions
11:20:42 <benmachine> it's pretty funny/scary/emotionally scarring
11:20:50 <lowasser1> I mean, sure, compilers are allowed to use unsafeCoerce on the backend
11:20:52 <benmachine> slightly ironic too I guess
11:20:56 <lowasser1> but never when you're programming
11:21:01 <lowasser1> depends on the parser structure
11:21:06 <arcatan> benmachine: well, Agda supposedly knows what it is doing
11:21:15 <diPython> of course i can do defunctionalization 
11:21:16 <benmachine> arcatan: you'd hope so :P
11:21:21 <qfr> cdsmithus: No, I meant HTML inspired markup in general, to me XML is a derivative of that, I just find it terribly redundant
11:21:22 <lowasser1> I'm not entirely convinced that parsers *should* support equality
11:21:24 <lowasser1> ever
11:21:28 <xarch> yeah, agda code is checked so I guess there's no problem
11:21:36 <diPython> then how would do sharing?
11:21:41 <stepcut> arcatan: a lot of that is the way things are presented. yesod, happstack, etc, are fairly modular. But yesod is presented as a single way of doing things, whereas other frameworks make it more obvious that you can mix and match modules
11:21:49 <qfr> <a>b</a> features a two times for no good reason, it's redundant
11:21:54 <cdsmithus> qfr: So you don't want Heist then.  Snap works with any templating system, though.
11:21:55 <lowasser1> several options:
11:21:56 <lowasser1> don't
11:22:01 <lowasser1> a) don't
11:22:10 <lowasser1> b) recognize when sharing is necessary at an earlier stage
11:22:12 <xarch> qfr: blaze-html ?
11:22:16 <lowasser1> like, if you're writing a parser generator
11:22:16 <qfr> cdsmithus: It doesn't bother me that much though
11:22:31 <qfr> And the Yesod approach with Hamlet seemed odd to me at first
11:22:32 <lowasser1> then recognize generators that are equivalent and do that first, then build the parsers
11:22:47 <qfr> I expected to have to bind data to strings
11:23:05 <monochrom> My idea of sharing is not "create new parser anyway, then compare with old parser, oh they're equal, now GC the new one and reuse the old one".
11:23:07 <qfr> So the association between Haskell x and "x" for evaluation in the template is established
11:23:13 <lowasser1> yeah
11:23:14 <cdsmithus> qfr: There are a LOT of choices with different syntax for building HTML: blaze-html, HSP, Hamlet, etc.
11:23:14 <lowasser1> seriously
11:23:14 <qfr> Without using some eval like feature
11:24:02 <monochrom> My idea of sharing is things are already maximumly shared by construction. There is nothing to compare and regret during runtime.
11:24:02 <lowasser1> I mean, I'd need more context, but I find it hard to believe that you couldn't either a) get by without sharing, or b) recognize parsers that could be shared before actually building them
11:24:22 <lowasser1> I can't imagine a context in which one of those options wouldn't be perfectly adequate
11:24:32 * hackagebot authenticate 0.8.0 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.8.0 (MichaelSnoyman)
11:24:33 <diPython> so you're basically saying do left factorization by hand in a grammar with N non-terminals, and then compare with the previous grammar and check if they are equivalent
11:24:34 * hackagebot http-enumerator 0.3.0 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.3.0 (MichaelSnoyman)
11:24:36 * hackagebot wai 0.3.0 - Web Application Interface.  http://hackage.haskell.org/package/wai-0.3.0 (MichaelSnoyman)
11:24:38 * hackagebot wai-extra 0.3.0 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.3.0 (MichaelSnoyman)
11:24:40 * hackagebot wai-handler-fastcgi 0.3.0 - Wai handler to fastcgi  http://hackage.haskell.org/package/wai-handler-fastcgi-0.3.0 (MichaelSnoyman)
11:24:46 <monochrom> IOW I do parsing equality during specification time.
11:24:53 <monochrom> s/parsing/parser/
11:25:06 <lowasser1> diPython: you're not going to get two equal parsers in that context anyway!
11:25:17 <lowasser1> certainly not as far as even stable pointers are concerned
11:25:31 <qfr> Heist easily deals with template changes at runtime, right?
11:25:33 <diPython> why not?
11:25:39 <qfr> As opposed to the non-debug version of Hamlet
11:25:42 * hackagebot wai-handler-scgi 0.3.0 - Wai handler to SCGI  http://hackage.haskell.org/package/wai-handler-scgi-0.3.0 (MichaelSnoyman)
11:25:44 * hackagebot wai-test 0.0.0 - Unit test framework (built on HUnit) for WAI applications.  http://hackage.haskell.org/package/wai-test-0.0.0 (MichaelSnoyman)
11:25:50 <mightybyte> qfr: yes
11:26:08 <lowasser1> that's like expecting
11:26:41 <lowasser1> \ x -> 1 + x and \ y -> 1 + y to go to the same place
11:26:49 <lowasser1> it's Just Not The Way Things Work
11:27:15 <diPython> no
11:27:35 <diPython> p is a parser 
11:27:41 <diPython> i have p <|> p
11:27:43 <lowasser1> and how is p stored?
11:27:50 <lowasser1> what is your parser data type
11:27:53 <diPython> p is a function
11:27:57 <lowasser1> exactly
11:28:10 <lowasser1> ...although come to think of it
11:28:15 <lowasser1> why would you ever encounter p <|> p ?
11:28:39 <diPython> you can encounter fsem <$> p <|> gsem <$> p
11:28:51 <diPython> imagine that p parsers 1 millions of entries on an xml
11:28:59 <lowasser1> mkay
11:29:00 <diPython> are u going to do that twice
11:29:01 <diPython> ?
11:29:12 <lowasser1> no, I'm going to figure out how to do (fsem <+> gsem) p
11:29:15 <Cale> Doing equality testing on parsers is hard in general, unless they happen to parse regular languages.
11:29:17 <lowasser1> for some <+>
11:29:40 <lowasser1> if p is a parser, it's probably a monad
11:29:43 <j-invariant> Cale: I read that context free grammar have undecidable equality
11:29:46 <lowasser1> in which case
11:29:59 <lowasser1> do {x <- p; return (f x <|> g x)}
11:30:12 <lowasser1> will do just fine, without all this stuff
11:30:20 <zygoloid> diPython: ($) <$> (pure fsem <|> pure gsem) <*> p
11:30:22 <Cale> j-invariant: right.
11:30:27 <lowasser1> that works!
11:30:30 <benmachine> fsem <$> p <|> gsem <$> p = fsem <$> p surely
11:30:38 <opqdonut> anyone have any pointers for testing typeclasses? i'd like to run a certain (quickcheck) test suite for each instance of a class
11:30:42 <lowasser1> I mean, I have no idea what fsem and gsem mean
11:30:43 <zygoloid> benmachine: not if your parser collects all possible answers
11:30:50 <benmachine> zygoloid: oh, true
11:30:53 <monochrom> this is not parsec.
11:30:56 <opqdonut> doesn't need to be automatic, as long as it's brief
11:31:03 <lowasser1> lol, granted, not parsec
11:31:04 <opqdonut> the per-instance code is brief, that is
11:31:07 <aristid> where are the IsString instances for ByteString located again? oO GHC complains
11:31:11 <Cale> http://en.wikipedia.org/wiki/Context-free_language#Decidability_properties
11:31:14 <diPython> i know that it works, but the point is to do it internally
11:31:16 <lowasser1> but parsers in Haskell seem unavoidably monadic
11:31:30 <Cale> lowasser1: It is avoidable ;)
11:31:35 <lowasser1> lol
11:31:38 <diPython> parsers don't have necessarily to be monadic
11:31:38 <lowasser1> applicative, then?
11:31:59 <diPython> actually i've almost learn applicative parsers
11:32:05 <aristid> bytestring is guilty of orphan instances!
11:32:12 <lowasser1> anyway, the point is that you should figure out how to do (fsem <+> gsem) p
11:32:16 <lowasser1> and do that instead
11:32:45 <zygoloid> lowasser1: composable parsers have to be applicative at least, almost by definition.
11:32:48 <diPython> of course i can create combinatros for that
11:32:49 <lowasser1> yeah
11:32:52 <lowasser1> then do it!
11:33:01 <diPython> the point is not to do it
11:33:22 <lowasser1> so let me see if I understand
11:33:28 <lowasser1> you want to take a grammar
11:33:40 <lowasser1> at runtime
11:33:41 <diPython> i want to do grammar transformations internally
11:33:48 <lowasser1> yes.
11:33:50 <lowasser1> at runtime.
11:33:52 <lowasser1> correct?
11:33:54 <gwern> any thoughts on how to convert a ProcessHandle to a ProcessID? want the parent process to be able to shell out to 'kill'
11:33:54 <diPython> y
11:34:04 <lowasser1> okay
11:34:12 <lowasser1> so you're reading a grammar at runtime
11:34:27 <gwern> funnily enough a google search turns up a 2008 #haskell log where adu asks how to do IO ProcessHandle -> IO ProcessID, but he didn't mention his solution if any
11:34:50 <lowasser1> so what you need to do is realize before you actually build the parser p that you're going to be using it in two places, and optimize accordingly, and *then* build the parser
11:34:57 <lowasser1> what I'd do is
11:35:02 <lowasser1> so you parse the instructions for the grammar
11:35:05 <gwern> System.Posix.Process doesn't offer any help; I probably could do something awful like have the child get its own ProcessID and print that to stdout
11:35:07 <lowasser1> into some representation of a grammar
11:35:12 <lowasser1> then you're trying to compile that to a parser
11:35:13 <monochrom> terminateProcess :: ProcessHandle -> IO ()
11:35:22 <gwern> monochrom: no, I'm already using that in mueval
11:35:26 <diPython> actually i read a parser 
11:35:26 <gwern> apparently isn't enough
11:35:33 <lowasser1> ...you can't read a Haskell function
11:35:45 <lowasser1> wait, I think I get it 
11:35:45 <lowasser1> you
11:35:51 <lowasser1> you're reading some representation of a parser
11:36:17 <lowasser1> the point is, you do all of the optimization on the representation
11:36:27 <lowasser1> and then, and only then, you turn it into a Haskell function
11:36:43 <diPython> yes, smth like that
11:37:05 <diPython> i get a "parser" represented with only 4 combinators (Sym, <*>, <|>, <$>)
11:37:07 <lowasser1> the point being that you recognize the sharing and do that sharing thing before Haskell functions get involved at all
11:37:14 <zygoloid> gwern: System.Process.Internals.withProcessHandle
11:37:37 <gwern> o.0 .Internals.?
11:37:39 <lowasser1> I mean, sure, so the parser that you read in only uses 4 combinators
11:37:58 <zygoloid> gwern: well, it's an exported module, so presumably it's OK? ;-)
11:38:19 <lowasser1> so you have a datatype ParsedParser, or something, the raw parser, and that has only 4 combinators
11:38:26 <diPython> yep a GADT
11:38:38 <gwern> zygoloid: also, what good is that?
11:38:42 <lowasser1> so what you do now is create a datatype OptimizedParser, which might have more combinators, that let you do things like sharing
11:38:57 <lowasser1> and then you have a function optimize :: ParsedParser -> OptimizedParser
11:39:08 <diPython> i do that while parsing
11:39:13 <lowasser1> and then you have a second function buildParser :: OptimizedParser -> ActualParserFunction
11:39:17 <diPython> so i have an iteratee kind of thing
11:39:25 <lowasser1> but the point is that OptimizedParser has more combinators
11:39:32 <zygoloid> gwern: withProcessHandle $ \x -> case x of OpenHandle pid -> ...; ClosedHandle _ -> ...
11:39:33 <diPython> no
11:39:33 <lowasser1> and you figure out that p is being shared when you're in OptimizedParser
11:39:47 <lowasser1> I'm saying that this is what you *need* to do, not what you are doing ;)
11:39:53 <diPython> LOL
11:39:55 <diPython> ok
11:40:08 <lowasser1> this is the Haskell way to do this =P
11:40:11 <monochrom> data ProcessHandle__ = OpenHandle PHANDLE | ClosedHandle ExitCode; newtype ProcessHandle = ProcessHandle (MVar ProcessHandle__); type PHANDLE = CPid or type PHANDLE = Word32
11:40:16 <lowasser1> you have a new OptimizedParser data type
11:40:23 <lowasser1> and your optimize function recognizes that p is being shared
11:40:39 <diPython> and how it does that?
11:40:56 <lowasser1> ParsedParser should have an Eq instance, since it's just a basic abstract data type, not a function
11:41:05 <monochrom> oh, right, that's System.Process.Internals
11:41:18 <lowasser1> or, depending on the format that you're reading in
11:41:24 <lowasser1> if p is actually referred to by the name "p"
11:41:31 <lowasser1> then you just test string equality on the names of the sub-parsers
11:41:55 <diPython> i could do that easily since i defunctionalized my parsers
11:42:08 <lowasser1> I'm not sure what you mean by that
11:42:22 <lowasser1> but if your parsers have names, they should still have names in ParsedParser
11:42:28 <lowasser1> so you might have, say
11:42:46 <lowasser1> a Map String ParsedParser
11:42:50 <diPython> don't forget about the semantic functions
11:43:02 <diPython> what u're saying is basically
11:43:32 <diPython> i get (Sym 'a' <|> Sym 'a') for instance and my optimized parser is Sym 'a' 
11:43:45 <lowasser1> yes
11:43:48 <lowasser1> and the reason you know that is
11:43:57 <lowasser1> so you're reading in this parser
11:44:00 <lowasser1> we have p1 = Sym 'a'
11:44:03 <lowasser1> and p2 = Sym 'a'
11:44:10 <lowasser1> and we're trying to optimize (p1 <|> p2)
11:44:18 <lowasser1> but p1 and p2 are still in a form where we can compare them for equality
11:45:05 <lowasser1> because we have, like
11:45:13 <diPython> yeah giving it a little bit of thought semantic functions wouldn't be a problem because we have a combinator for sharing 
11:45:35 <lowasser1> so ParsedParser, you said, is a GADT
11:45:39 <diPython> like fsem <$> p <|> gsem <$> p = (fsem + gsem) <$> p
11:45:57 <lowasser1> that would be a much simpler way of doing it ;)
11:46:55 <lowasser1> I'm not yet convinced ParsedParser has to be a GADT, and if it is it makes the Eq instance a little more complicated
11:47:23 <lowasser1> but the point is, you don't try to test Haskell functions for equality, you test for equality when it's still data that has constructors and everything
11:47:59 <lowasser1> result: your compiler typechecks, and it's that much more likely to be bug-free
11:48:01 <c_wraith> My data with constructors hold functions inside :)
11:48:13 <diPython> my compiler already typechecks :P
11:48:16 <lowasser1> =P I mean recursively ;)
11:48:20 <diPython> lol
11:48:20 <lowasser1> with unsafeCoerce?
11:48:24 <diPython> yep
11:48:25 <lowasser1> you're just begging for a segfault
11:48:31 <lowasser1> doesn't count
11:48:31 <diPython> indeed
11:48:42 <diPython> or probably not
11:49:17 <lowasser1> anyway.
11:49:22 <lowasser1> that's how you'd do it properly in haskell
11:49:31 <lowasser1> without killing kittens
11:49:44 <lowasser1> or burning villages
11:50:24 <diPython> i think u're right
11:50:26 <monochrom> not just in haskell. it's the proper way even in C.
11:50:31 <lowasser1> lol
11:50:40 <lowasser1> but the reason you do it in Haskell is because Haskell will really make you stick to it
11:50:55 <lowasser1> and we already know C programmers kill kittens
11:51:24 <diPython> ok
11:51:27 <diPython> i'll do it then
11:51:29 <lowasser1> (and the other reason you do it in Haskell is because the type system is powerful enough to let you express complex ideas like GADTs)
11:52:01 <diPython> thanks
11:52:19 <monochrom> the SUIF people and the LLVM people use C and C++. they still don't go, "we have access to the generated machine code, let's gen machine code and do common-subexpression elimination there". they eliminate common subexpressions long before one single byte of machine code comes out.
11:52:57 <lowasser1> yep
11:53:08 <djahandarie> GADTs are complex now too??
11:53:12 <lowasser1> =P
11:53:22 <lowasser1> I'm using the definition of complex as "something only Haskell has"
11:53:26 <gwern> > show (100 :: Word32)
11:53:27 <lambdabot>   "100"
11:53:28 <djahandarie> I don't know why
11:53:34 <j-invariant> is itt known what GADTs can do?
11:53:41 <lowasser1> GADTs are awesome
11:53:42 <djahandarie> I define complex as "complicated"
11:53:56 <j-invariant> what can GADTs do?
11:54:03 <j-invariant> I have a question: What is the theory of GADT
11:54:09 <lowasser1> but frankly, most languages' type systems aren't even advanced enough to express the full range of Haskell abstract data types, even without GADTs, type families, or whatever
11:54:12 <monochrom> is GADT real? if so, then it's also complex.
11:54:19 <gwern> hm. if a PID is a CPid, and a CPid is a Word32 or Word64, then presumably it looks like a normal process id when I call show on it, and so shelling out to 'kill' should accept `show pid` as its argument
11:54:50 <lowasser1> I mean, I don't know of any other language that has higher kinds off the top of my head
11:54:55 <monochrom> it is also an Enum and an Integral. there are many ways to get the number it stands for.
11:55:01 <lowasser1> I think C++ might have some perversion of that, but idk
11:55:06 <djahandarie> j-invariant, like I said, nearly all of GADTs can be expressed in H98, and all of them with H98 and rank-2 types
11:55:11 <lowasser1> that's true
11:55:12 <monochrom> then again it is also Show and all you need is Show.
11:55:17 <copumpkin> djahandarie: really?
11:55:20 <j-invariant> nearly all? :)
11:55:23 <copumpkin> j-invariant: what's the translation?
11:55:25 <j-invariant> I wan to know about those which can't
11:55:26 <gwern> monochrom: are any of the other ways better for turning it into a string suitable for the shell?
11:55:28 <lowasser1> lololololol
11:55:32 <j-invariant> lol
11:55:32 <lowasser1> there isn't a translation
11:55:34 <lowasser1> it's usually just
11:55:35 <olsner> lowasser1: C++ probably only has perverted kinds
11:55:39 <lowasser1> "the programmer wasn't thinking hard enough"
11:55:48 <copumpkin> djahandarie: I can express all of them with ~ and existentials
11:55:52 <copumpkin> but that's different
11:56:13 <lowasser1> lol, not h98 much
11:56:21 <monochrom> System.Posix.Signals.signalProcess
11:57:37 --- mode: ChanServ set +o copumpkin
11:57:43 --- mode: copumpkin set +b *!~Zse@c83-254-66-66.bredband.comhem.se
11:57:43 --- kick: Soonus was kicked by copumpkin (Your behavior is not conducive to the desired environment.)
11:58:15 --- mode: copumpkin set -o copumpkin
11:58:45 <xarch> hum, why was he kicked?
11:59:04 <djahandarie> j-invariant, the GADTs that don't translate are when there is a type paremeter inside a GADT term that doesn't appear outside of the term
11:59:12 <qfr> What's a .hsc file vs. a .hs file btw?
11:59:12 <copumpkin> PMed me with seemingly automated messages (it happened earlier from a nick with a similar host pattern and realname), and told me to fuck off when I called him out
11:59:22 <j-invariant>  What are the GADTs for
11:59:34 <copumpkin> j-invariant: maintaining invariants in types in fancy ways
11:59:42 <copumpkin> djahandarie: what's the translation?
11:59:47 <j-invariant> what are their semantics
11:59:59 <monochrom> what was your "called him out"? you sure you didn't provoke hostile speech?
12:00:01 <copumpkin> djahandarie: the main issue is pattern matching brining type refinement into context, which I don't think is possible
12:00:18 <djahandarie> monochrom, he's been spamming literally everyone in the channel
12:00:26 <copumpkin> monochrom: I asked him why he'd PMed me with exactly the same stuff earlier, and he told me to fuck off
12:00:30 <j-invariant> The simple lambda calculus corresponds to intuition logic
12:00:44 <j-invariant> or something?
12:00:50 <monochrom> alright then you did the right thing
12:01:11 <xarch> oh ok, he did that to me too
12:01:20 <j-invariant> same
12:01:31 <xarch> well, he did it saying I sent him a PM so I started worrying :/
12:01:40 <xarch> (because I didn't)
12:01:47 <copumpkin> if people PM suspiciously you from #haskell, just let someone know
12:01:57 <copumpkin> no point in letting them PM-spam everyone in the channel
12:02:11 <lowasser1> lol thanks for that
12:02:13 <lowasser1> me too
12:02:29 <xarch> ok
12:02:35 <monochrom> GADT is explained at http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt
12:02:58 <copumpkin> j-invariant: you know inductive families from agda?
12:03:03 <copumpkin> j-invariant: it's that, minus the dependent types
12:03:14 <monochrom> /msg #haskell hi there how are you? :)
12:03:19 <copumpkin> :P
12:03:19 <j-invariant> it's between intuitionistic logic and the martin lof type theory
12:03:24 <j-invariant> but what exactly is it?
12:03:39 <djahandarie> copumpkin, by making the GADT into a typeclass, then a newtype and an instance for the newtype for every function, I think
12:03:41 <copumpkin> j-invariant: an ADT that allows you to refine type indexes per constructor
12:03:50 <djahandarie> I'm thinking that deep pattern matching may not work though
12:03:51 <j-invariant> no I mean what theory is it
12:03:52 <copumpkin> djahandarie: that won't give you pattern matching
12:04:11 <j-invariant> can you prove theorems with it that you can't prove without it
12:04:16 <copumpkin> j-invariant: a witness to a relation is the best I can come up with
12:04:28 <j-invariant> it's LJ with equality?
12:04:29 <copumpkin> no, it can be translated to an existential and an equality, even in dependent land
12:04:54 <copumpkin> LJ?
12:05:01 <j-invariant> simple intuitionist logic
12:05:40 <copumpkin> I don't think it really adds to expressive power at all, but makes programming a lot more convenient
12:05:54 <j-invariant> can it realnly be true
12:05:59 <j-invariant> hard to beleive
12:06:12 <copumpkin> (assuming we could do what we wanted with existentials and equality in haskell, which we can't, if we don't have GADTs turned on anyway)
12:06:49 <kelvie_> There's so many JSON libraries... (and many other libraries); how does one find out which one is the best/fastest/most well maintained?
12:06:57 <kelvie_> s/There's/There are/
12:07:00 <monochrom> ask here
12:07:15 <monochrom> or ask mailing lists
12:07:19 <kelvie_> Anyone know what's a simple to use JSON library? :P
12:07:53 <kelvie_> I just need to parse, modify, and write a couple of JSON fiels
12:07:55 <kelvie_> files *
12:08:02 <parcs> i think it's best to experiment, or simply look at the documentation of each library
12:08:10 <burp> kelvie: guess some of the enumerator versions, if you are comfortable with that
12:08:12 <vahokif> hi
12:08:28 <arcatan> they all suck :((
12:08:30 * arcatan goes away
12:08:55 <kelvie_> Hmm
12:08:56 <vahokif> is there a prelude function that does \v f -> f v?
12:09:09 <ion> @pl \v f -> f v
12:09:10 <lambdabot> flip id
12:09:18 <burp> otherwise just try all of them,  hsjson, json-b, etc.
12:09:24 <monochrom> or flip ($)
12:09:28 <kelvie_> Yeah.. there's so many..
12:09:44 <burp> look at their api and use what you feel comfortable with
12:09:55 <burp> and if you like the name of the autor ;)
12:10:08 <shachaf> vahokif: If you already know v, you can use ($ v).
12:10:12 <monochrom> keep asking until someone who actually uses JSON answers
12:10:45 <kelvie_> Haha
12:11:44 <vahokif> thanks
12:11:47 <joe6> byorgey: thanks
12:11:54 <sbrtgr> kelvie_: if in doubt look at their implementation and take the one that's least cryptic.
12:12:02 <vahokif> my examiner would probably kill me for it though
12:12:52 <EvanR-work> i use json
12:13:30 <lowasser1> so, here's an awkward question
12:13:36 <lowasser1> so Applicative instances have Duals
12:13:58 <lowasser1> and Alternative instances have a different kind of Dual, the monoid dual
12:14:02 <lowasser1> and same with MonadPlus
12:14:15 <lowasser1> and what's up with that? =P
12:14:29 <lowasser1> alternatively: what about Monad?
12:14:31 <lowasser1> hrrrm
12:14:44 <lowasser1> I think I need to have a more well-posed question first
12:15:00 <lowasser1> aha! got it! thanks, #haskell!
12:15:08 <monochrom> you're welcome!
12:15:45 <monochrom> #haskell is the greatest heterogenous list since /dev/null
12:15:59 <arcatan> i use json, too. it has a JSON typeclass, it can automatically handle types with Data and there's a quasiquoter library for it (text-json-qq)
12:16:54 <lowasser1> lololololol
12:20:10 <aristid> lowasser1: "lololololol"?
12:20:16 <lowasser1> at monochrom
12:20:19 <lowasser1> delayed reaction lol
12:20:46 <arcatan> lolwasser1
12:24:45 * hackagebot mueval 0.8.1 - Safely evaluate Haskell expressions  http://hackage.haskell.org/package/mueval-0.8.1 (GwernBranwen)
12:27:04 <gwern> Cale: I tossed in a new signalProcess call to mueval's watchdog and uploaded a bumped version; perhaps it will fix the lambdabot problem
12:27:11 <gwern> lispy: I tossed in a new signalProcess call to mueval's watchdog and uploaded a bumped version; perhaps it will fix the lambdabot problem
12:30:26 <monochrom> \/
12:32:33 <thartman> I'm trying to install darcs on an oldish centos (or fc or something, not sure how to tell difference) box. Pretty unfamiliar with redhat style installs, always use ubuntu. I successfully installed ghc 6.12, but was unable to install haskell platform or bootstrap cabal
12:34:21 <thartman> when I run configure I get "It cannot compile a simple program (see config.log for the details).", and suggests installing libgmp. I did yum install libgmp-devel but didn't make any difference. anybody know about installing haskell platform (or just darcs) on redhat style servers?
12:35:39 <Botje> thartman: have you tried ldconfig?
12:35:44 <thartman> nope
12:36:00 <Botje> after installing new libs or messing around with libs, it doesn't hurt to run that
12:36:26 <thartman> like ldconfig pathtosofile.so ?
12:37:00 <Botje> nah, just ldconfig
12:37:38 <thartman> ldconfig: command not found
12:38:08 <thartman> oh, found it
12:38:09 <Botje> you probably have to run it as root
12:41:18 <thartman> but still fails after ldconfig
12:43:16 <EvanR-work> Stack space overflow: current size 10000000 bytes.
12:43:17 <EvanR-work> Use `+RTS -Ksize -RTS' to increase it.
12:43:17 <EvanR-work> L(
12:43:17 <EvanR-work> :(
12:43:20 <burp> recursion fail :p
12:44:00 <EvanR-work> how do i find out at least where?
12:44:40 <tactics40> Sounds like it happened at the top of the stack
12:45:00 <EvanR-work> what does that mean
12:45:25 <Botje> thartman: can you figure out the exact error?
12:45:35 <Botje> usually it's in some log file or something
12:46:52 <tolkad> When should you use Data.Array vs Data.IntMap?
12:47:45 <thartman> pretty cryptic config.log. after ghc conftest.hs /tmp/ghc32598_0/ghc32598_0.s:27:0: Error: suffix or operands invalid for `push'
12:50:00 <EvanR-work> i already fixed this
12:50:14 <EvanR-work> i was reading a large file and decoding it with String. when i made it ByteString it fixed
12:50:25 <EvanR-work> and forgot to pull that change to my other repos
12:50:29 <EvanR-work> *stupid*
12:50:31 <jmcarthur> tolkad: depends on the performance characteristics and usage patterns you need, really
12:51:22 <jmcarthur> tolkad: and as long as you understand the performance characteristics and interfaces i think it's pretty clear when you want one or the other, although I'd say Data.IntMap makes a nice default if you just can't decide
12:53:36 <qfr> What's the proper way to remove a local package?
12:53:45 <tolkad> How much storage do they each use per element and what are the lookup/insert/delete growth rates of each?
12:54:02 <tolkad> storage overhead*
12:54:34 <monochrom> to remove a package: http://www.vex.net/~trebla/haskell/sicp.xhtml#remove
12:54:37 <jmcarthur> tolkad: for arrays, storage depends on the type of array you're using
12:54:39 <tolkad> well I have the growth rate for IntMap
12:54:42 <mauke> insert/delete is easy, those don't exist on arrays
12:54:59 <tolkad> mauke: what about //?
12:55:01 <jmcarthur> tolkad: array don't really grow or shrink
12:55:10 <jmcarthur> tolkad: that just changes existing elements
12:55:13 <mauke> tolkad: is that update?
12:55:20 <monochrom> yes
12:55:49 <jmcarthur> tolkad: for pure arrays that would involve copying the whole thing, but the result will be the same size as the original
12:56:14 <qfr> monochrom: Hmm I don't have a .cabal/lib even
12:56:21 <Botje> thartman: huh. that looks very weird :(
12:56:22 <jmcarthur> tolkad: if you are holding onto lots of old versions then IntArray might use less space overall anyway, since they can share stuff
12:56:26 <jmcarthur> err
12:56:28 <jmcarthur> IntMap
12:56:58 <tolkad> so updating an Array element is O(n)?
12:57:06 <monochrom> if "ghc-pkg unregister" succeeds, that is sufficient. you don't have to delete files, unless you are desperate for disk space
12:57:11 <jmcarthur> tolkad: for pure arrays, yes
12:57:18 <jmcarthur> tolkad: for mutable arrays it's O(1) of course
12:57:25 <tolkad> and updating an IntMap is O(log n)?
12:57:41 <qfr> monochrom  oh alright
12:57:56 <tolkad> oh wait
12:57:59 <jmcarthur> tolkad: for IntMap it's *technically* O(log n), but since Int is bounded it's effectively O(1)
12:58:01 <monochrom> ".cabal/lib" is for unix
12:58:54 <mauke> O(log k)
12:58:56 <tolkad> jmcarthur: yeah I hate that whole semantics issue with patricia tries
12:59:01 <jmcarthur> mauke: you mean O(k)
12:59:23 <mauke> where k = 2^p, hah!
12:59:28 <jmcarthur> tolkad: semantics issue?
13:00:19 <tolkad> jmcarthur: whether you call it O(log n) or O(1)
13:00:41 <jmcarthur> it's not an issue with IntMap. it's just that people like to argue
13:01:02 <EvanR-work> dejavu protip: dont read a N megabyte text file with String and do n^2 list operations on it
13:01:12 <monochrom> haha
13:01:42 <monochrom> but I so want to do n^3 parsing on the file!
13:01:56 <jmcarthur> tolkad: think of it this way. lookup in a trie is always O(k) (k = length of key), and in the case of IntMap, k is a constant
13:02:12 <monochrom> but wait, since the file is at most 16TB that's O(1).
13:02:13 <jmcarthur> so i think it's pretty unambiguous there
13:02:31 <EvanR-work> "thats a pretty big 1" *laugh track*
13:02:41 <tolkad> jmcarthur: patricia tries are just non-balanced binary trees with an arbitrary depth limit
13:02:49 <tolkad> right?
13:02:50 <monochrom> just trying to have fun merging two threads
13:02:52 <copumpkin> binary?
13:03:07 <jmcarthur> tolkad: they are tries, not binary trees
13:03:07 <EvanR-work> MERGE CONFLICT
13:03:34 <tolkad> jmcarthur: but strings are made of bits anyway
13:03:40 <lispy> gwern: cool, you should let Cale know.
13:03:44 <jmcarthur> tolkad: in a trie, each branch distinguishes the next bit of information in the key
13:04:02 <monochrom> all of you should argue concrete clock cycles
13:04:06 <gwern> lispy: I did
13:04:12 <lispy> thanks!
13:04:31 <gwern> monochrom: I wonder if Knuth ever thinks to himself, MIX and MMIX weren't reall worth it
13:04:33 <tolkad> jmcarthur: and since there are two branches, it is a binary tree
13:04:42 <jmcarthur> tolkad: in a binary tree, the entire key may have to be compared at each branch
13:04:59 <jmcarthur> tolkad: it's not a binary sort tree though, which is what people usually mean
13:05:07 <monochrom> how is MMIX coming along? if he's procrastinating it, that's a strong sign of feeling not-worth-it.
13:05:37 <jmcarthur> tolkad: also, patricia trees aren't strictly binary trees anyway, iirc. i think they do something much fancier
13:05:53 <tolkad> jmcarthur: oh, I'm a CS student so I just knew that a binary tree is defined as a tree which only has two branches when it splits
13:06:07 <jmcarthur> tolkad: well that's technically correct
13:06:21 <jmcarthur> i was reading more into what you said than was literally said ;)
13:06:52 <copumpkin> it's not binary
13:07:07 <copumpkin> it can be binary if your alphabet is binary
13:07:20 <tolkad> ah, that makes sense
13:07:54 <jmcarthur> copumpkin: a naive trie over ints *would* be binary though, if your alphabet was the bits in the ints
13:08:19 <copumpkin> sure
13:08:38 <jmcarthur> i think that's what tolkad was thinking
13:08:50 <tolkad> copumpkin: but whatever-ary your tree is doesn't make a difference in asymptotic growth rate
13:10:28 <tolkad> I think it's cheating to set bounds on your input then say your algorithm runs in O(1)
13:10:51 <tolkad> arbitrary bounds*
13:10:52 <copumpkin> you mean like saying memory accesses are O(1)?
13:11:06 <tolkad> copumpkin: yes
13:11:10 <tolkad> well, kind of
13:11:29 <tolkad> actually yes
13:11:34 <monochrom> so-called O(1) RAM is a 10000000-ary tree. screw asymptotic growth rate. argue in concrete clock cycles.
13:11:39 <j-invariant> jij
13:11:48 <Veinor> hm, hxt's readDocument method seems to be... slow
13:12:20 <tolkad> and that would actually matter if you were running an algorithm in parallel. you better not think memory access is O(1)
13:12:36 <tolkad> (across a network of computers that is)
13:12:45 <tolkad> especially if the network changes in size
13:17:32 <tolkad> thanks btw, I think I understand arrays vs IntMap pretty well now. I use IntMap if I need to update frequently and don't need to hold onto old versions
13:17:59 <copumpkin> *do
13:18:22 <tolkad> copumpkin: I mean vs. immutable arrays
13:18:49 <copumpkin> I mean that if you need to hold onto old versions, IntMap shares most of the unchanged parts, so holding onto old versions of the data is way cheaper with them
13:18:52 <copumpkin> memory-wise
13:19:21 <jmcarthur> tolkad: i don't think it's cheating at all. O(k) lookup for a constant k *is* O(1) by definition
13:19:58 <copumpkin> people need to declare their variables in their asymptotics
13:20:00 <jmcarthur> tolkad: it's cheating if you claim that O(1) is always faster than O(k) or O(log n)
13:20:06 <copumpkin> if we want them to depend on memory size, we declare that
13:20:07 <tolkad> jmcarthur: ok you're right. everything is O(1). let's stop optimizing, everything that halts runs in finite time
13:20:21 <jmcarthur> tolkad: who said anything about everything being O(1)?
13:20:32 <copumpkin> it's just about stating who you depend on :P
13:20:45 <copumpkin> but for comparisons both asymptotics need to depend on the same set of variables
13:20:50 <copumpkin> or the comparison is meaningless
13:20:50 <jmcarthur> tolkad: i'm talking about k, not about halting
13:20:55 <jmcarthur> tolkad: and i've stated what k is
13:21:17 <tolkad> jmcarthur: well anything running on a physical computer has bounds on input parameters, so everything that runs on a physical computer is O(1)
13:21:29 <copumpkin> meh
13:21:40 <qfr> Do any of you know of that ominous patch which is supposed to make hint work with ghc 7? :(( I'm running into more and more compatibility problems here while I'm just setting up the dependencies and I'm still only at a hello world stage in Haskell
13:21:50 <monochrom> asymptotic analysis is already cheating.
13:21:53 <qfr> (trying to set up Snap right now)
13:22:22 <monochrom> wait, does snap need hint?
13:22:25 <tolkad> monochrom: not if you have unbounded input sets
13:22:34 <qfr> monochrom: So they said in #snapframework
13:22:45 <qfr> Two or three people told me it doesn't build with ghc 7 right now
13:23:18 <mightybyte> monochrom: The project called snap needs hint.  snap-core and snap-server don't.
13:24:04 <jmcarthur> tolkad: i'm not even saying k is bounded. i'm saying k is *constant*
13:24:15 <jmcarthur> tolkad: you are comparing apples and oranges
13:24:30 <tolkad> jmcarthur: how can you be so sure word size wont suddenly change?
13:24:38 <jmcarthur> tolkad: on a given machine> i'm pretty sure
13:24:43 <jmcarthur> *machine?
13:25:11 <monochrom> I admire what the numerical analysts do. They have a modified scheme of asymptotic analysis. It is more honest and realistic.
13:25:33 <jmcarthur> tolkad: on 32 bit architectures IntMap lookup is O(32) = O(1). on 64 bit architectures IntMap lookup is O(64) = O(1)
13:25:44 <tolkad> well your algorithm isn't being run on a single machine, in general your algorithm runs in O(log (word size))
13:25:51 <jmcarthur> tolkad: now, you could say that IntMap is O(w) for w = word size
13:25:58 <monochrom> When I handed in numerical analysis homework to answer "O(n^2)" they marked me wrong. The correct answer was "O(3 n^2 / 2) multiplications".
13:26:07 <tolkad> oh wait, not log word size
13:26:09 <jmcarthur> tolkad: no, it's O(w), not O(log w)
13:26:11 <jmcarthur> yeah
13:26:12 <tolkad> yeah my bad
13:26:32 <jmcarthur> tolkad: but usually you talk about an algorithm for a specific machine or virtual machine
13:26:36 <ddarius> monochrom: Exactly.
13:26:40 <ddarius> That's what I always say.
13:26:45 <dolio> monochrom: How do they decide what gets included?
13:26:47 <sipa> monochrom: you should teach them about the difference between big-O notation and asymptotic equivalence :)
13:26:52 <monochrom> Note two things. They insisted on exposing the leading coefficient. They insisted on being specific about counting multiplication (or whatever you think is relevant) instead of being vague.
13:27:20 <monochrom> Yeah  would be more precise than O
13:27:39 <sipa> indeed
13:28:49 <sipa> monochrom: even O(exp(x)) would be technically correct here :)
13:28:53 <tolkad> ugh they have too many of those. do you ever need anything besides big O, theta, and omega?
13:28:58 <qfr> src\Hint\GHC.hs:43:23:
13:28:59 <qfr>     Module `DynFlags' does not export `supportedLanguages'
13:29:03 <qfr> Yeah hint doesn't work hmm
13:29:04 <tolkad> big omega*
13:29:25 <monochrom> O, ,  are sufficient, yes.
13:29:28 <luite> tolkad: ~ and o
13:29:38 <ddarius> O(BB(x))
13:30:03 <joe6> i am using 2 modules (parsec and prettyprint) and both of them have "char". I want to use "char" of both the modules and I tried "import qualified Text.PrettyPrint as PP". If I do this, I have to qualify all prettyprint functions with PP. Is there a way to use  a prefix only for the Text.PrettyPrint.Char function?
13:30:09 <djahandarie> O(BB_2(x))
13:30:14 <tolkad> luite: and small omega
13:30:14 <j-invariant> is BB well defined?
13:30:46 <tolkad> luite: haven't had to use little o/little omega yet, maybe this year I will
13:31:02 <ddarius> joe6: You can import a module multiple times with different qualifications and different sets of functions.
13:31:04 <tolkad> for ~ can't you just use =?
13:31:15 <luite> tolkad: isn't that the same as little o flipped? I'm not sure about tat
13:31:46 <dolio> j-invariant: I think it's been computed for small state set sizes.
13:32:08 <joe6> ddarius: gotcha. I did this: import Text.PrettyPrint hiding (char)
13:32:08 <joe6> import qualified Text.PrettyPrint (char)
13:32:40 <luite> tolkad: ah I looked it up, it's slightly different indeed, the order of the quantifiers
13:32:44 <joe6> so whenever I use the Text.PrettyPrint.char, I use the full prefix and name for char.
13:32:50 <joe6> ddarius: does that sound good?
13:33:14 <ddarius> That will work.
13:33:25 <tolkad> I think we just used = instead of ~ for asymptotic equality
13:33:42 <luite> no wait, it's the same... hmm
13:33:48 <tolkad> ~ was for equivalence relations I think
13:34:22 <luite> hmm, i meant f(n) ~ g(n) <=> lim n -> \infty  f(n)/g(n) = 1
13:34:22 <ddarius> Asymptotic equality is an equivalence relation and (obviously) not (extensional) equality.
13:34:28 <monochrom> We all acknowledge that counting concrete clock cycles is damn hard and even being able to get it to "3n^2/2 + 151n/45 + max(n,23) multiplications" is too much work. But the leading coefficient and being explicit on "the most expensive op here" are just a little extra work with much benefit.
13:34:42 <luite> abusing = for that doesn't look right :)
13:35:09 <monochrom> (compared with just "(n^2) unspecified steps"
13:35:35 <tolkad> monochrom: with a large enough input size it doesn't matter
13:35:42 <tolkad> monochrom: that's what they told us in class
13:35:59 <ddarius> The "O(n) what?" is important regardless and also quells ridiculous arguments about how expensive addition is.
13:36:04 <luite> monochrom: what do the numerical analysts mean by f(x) = O(g(x)) then? is it f(x) = g(x) + c? or f(x) ~ g(x)?
13:36:11 <monochrom> How to decide what details to include: within your theorem-proving budget, get as close to reality as you can.
13:36:53 <ddarius> monochrom: There's a difference between making a more precise statement and making a well-defined one.
13:37:31 <tolkad> ddarius: the cost of addition depends on the representation of numbers
13:38:18 <nomemory> hello, is there a function that is the equivalent of:        fct a b = take b (repeat a)                   ?
13:38:33 <luite> replicate b a
13:38:46 <nomemory> thanks luite 
13:38:47 <ddarius> tolkad: Which is irrelevant if you just state "Algorithm X uses N additions," but isn't irrelevant if you say "Algorithm X uses N amorphous steps."
13:39:40 <kreed> Hello. I have some question. Where are you use Haskell?
13:39:52 <ddarius> kreed: Usually at my home.
13:40:03 <monochrom> on my computer
13:40:11 <tolkad> ddarius: in the latter case, each step must run in constant time
13:40:29 <kreed> pidors
13:40:55 <ddarius> tolkad: Not usually.  Maybe that's the intent, but it's not verifiable and often not true.
13:41:16 <tolkad> ddarius: no that's how I learned it in class! Each step must take constant time!
13:41:33 <ddarius> tolkad: Perhaps you should look up the word "intent."
13:41:38 <luite> tolkad: there is no single way to do it
13:42:21 <mm_freak> is there a way to have a colored 'diff' with darcs?
13:42:35 <tolkad> ddarius: what some person intends to do is not relevant to the definition of asymptotic growth rate
13:42:47 <mm_freak> the normal output is hard to read, if you have some complicated changes in many files
13:43:33 <luite> tolkad: it is, it can for example be the number of steps in a regular turing machine, or the number of steps in a "fictional" turing machine equipped with constant time/space real number arithmetic
13:43:55 <ddarius> tolkad: The statement wasn't what someone intends to "do," it was what someone intends "asymptotic growth rate" or rather "step" to mean.
13:45:05 <tolkad> but each asymptotic growth rate notation has a precise mathematical definition in terms of the actual growth rate function
13:45:06 <luite> tolkad: as long as you remember what you're proving the results are equally valid. the first type is sometimes much harder to do (for example for linear programming, where the first case still is an open problem)
13:45:07 <ddarius> tolkad: And it doesn't change the fact that most of the things that are taken as "steps" are either not constant time or viewing them as constant time would render the entire algorithm constant time.
13:45:13 <monochrom> I am not sure whether "that's how I learned it in class! Each step must take constant time!" is declaration or sarcasm.
13:45:37 <monochrom> well, so much for "intent"!
13:46:42 <tolkad> monochrom: I was attempting to further the discussion whilst being humorous
13:47:51 <tolkad> or, rather, be homorous whilst furthering the discussion
13:47:53 <qfr> http://siyobik.info/index.php?module=pastebin&id=557 <- I applied the patch to hint I found on Google, trying to compile it from source now but runhaskell Setup.lhs configure fails with stuff like "needs MonadCatchIO-mtl >=0.2" while ghc-pkg list says MonadCatchIO-mtl-0.3.0.1 as you can see. What is this all about? Why does it say I need packages which are already installed and available in even more recent versions?
13:49:25 <qfr> The objective is to make hint 0.3.3.1 work with ghc 7 btw
13:49:33 <qfr> On Windows, for an added challenge!
13:52:15 <j-invariant> how do you hold a book open
13:52:32 <monochrom> depends on thickness
13:53:00 <ddarius> I don't.  I just have my servant hold it open for me.
13:54:13 <olsner> j-invariant: they usually stay open by themselves until you press the little X in the upper right corner
13:54:22 <monochrom> haha
13:54:36 <ddarius> olsner: Usually, but not always.  Also, I don't have a little X in the upper right corner.
13:54:45 <monochrom> it's in the upper left corner in ubuntu and mac
13:55:00 <_mpu> it can be nowhere
13:55:09 <ddarius> I use Ubuntu but there is no X at all.
13:55:29 <_mpu> here comes the proof :)
13:55:31 <olsner> I guess you have to start the X server to get the X:es
13:55:40 <ddarius> X is running.
13:56:04 <monochrom> I'm sure an alternative window manager is being allured to.
13:56:19 <j-invariant> YMonad
13:56:40 <_mpu> if you don't have a mouse, there's no point in having this little X.
13:56:54 <ddarius> _mpu: And yet often it remains.
13:57:07 <_mpu> :(
13:57:11 <ddarius> And, I actually don't have a mouse.
13:57:15 <j-invariant> do you seriously use a computer the whole time without a mouse?
13:57:20 <j-invariant> or track pad or whatever
13:57:34 <_mpu> sure !
13:57:39 <monochrom> I seriously use an iPod Touch without a mouse.
13:57:45 <tolkad> unless your playing a game/browsing the web why would you need to?
13:57:48 <tolkad> you're*
13:58:08 <j-invariant> I wish I could do that
13:58:10 * hackagebot PermuteEffects 0.1.1 - Permutations of effectful computations  http://hackage.haskell.org/package/PermuteEffects-0.1.1 (MartijnVanSteenbergen)
13:58:21 <_mpu> just unplug it
14:00:48 <bos> i wonder why UTCTime lacks a Show instance
14:01:18 <copumpkin> ZipList lacks one too
14:01:22 <qfr> I see, my building problem is less interesting than "how do you hold a book open" :(
14:01:22 <copumpkin> I think people just forget to put them on
14:01:47 <monochrom> eh? UTCTime has a Show instance. I use it in my program.
14:02:04 <ddarius> > ZipList []
14:02:05 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList a))
14:02:05 <lambdabot>    arising ...
14:02:11 <monochrom> I even have data Job = Job UTCTime [String] deriving (Read,Show)
14:02:18 <c_wraith> bos: I think it's in a different module, for some reason
14:02:28 <monochrom> just import all of Data.Time
14:02:48 <bos> c_wraith: yeah, it's an orphan instance in Data.Time.LocalTime
14:02:52 <bos> that's bizarre
14:03:21 <monochrom> perhaps because you need code from LocalTime to implement Show,Read
14:03:33 <monochrom> wait, nevermind
14:03:57 <bos> monochrom: no, you're right
14:04:08 <bos> the Show instance uses utcToZonedTime
14:04:45 <monochrom> interesting, convert to ZonedTime but use the UTC zone? haha
14:05:17 <monochrom> I would rather use mutually recursive modules for this
14:06:24 <mtnviewmark> oh - the joys of textual date/time representation....
14:06:57 <qfr> cabal did "Segmentation fault/access violation in generated code" twice in the past 10 min :(
14:07:04 <ddarius> "We also measure the normal force between the magnets after they had been switched off and it was zero to within the precision of apparatus.  Holding the cubes in our hands and pushing them together, we can observe no tendency for the modules to hold together when the magnets are off."
14:10:31 <mtnviewmark> See, now if those magnets had type signatures... I bet the compiler would have been able to prove that they wouldn't hold together!
14:18:59 <nomemory> I've implemented 4 solutions for the same problem (Problem 14 from 99 Haskell Problems): http://hpaste.org/42962/problem14 . From a performance point of view, what's the best implementation ?
14:19:10 <nomemory> "best"
14:19:18 * hackagebot nptools 0.4.0 - A collection of random tools  http://hackage.haskell.org/package/nptools-0.4.0 (NicolasPouillard)
14:20:26 <ddarius> nomemory: You can just measure it.
14:21:19 <nomemory> ddarius, How ?
14:21:37 <nomemory> give a large input and measure time ?
14:22:34 <ddarius> That's one possibility.
14:26:03 <jmcarthur> nomemory: i suspect that the first two will be equally fast, the third will be the slowest, and the fourth will be somewhere in between
14:26:28 <jmcarthur> nomemory: but measuring is the best way to be sure :)
14:27:59 <nomemory> jmcarthur, I will . 
14:28:07 <nomemory> thanks 
14:28:08 <jmcarthur> make sure to use optimizations
14:29:21 * hackagebot nptools 0.4.1 - A collection of random tools  http://hackage.haskell.org/package/nptools-0.4.1 (NicolasPouillard)
14:42:48 <qfr> What is the difference between lhs and hs?
14:43:02 <qfr> And hsc, too?
14:43:23 <qfr> I've noticed that hsc files appear to contain C preprocessor instructions
14:43:25 <Peaker> qfr, lhs is "literate haskell" vs hs which is just "haskell"
14:43:35 <Peaker> qfr, "literate haskell" reverses the comment/non-comment convention
14:43:45 <Peaker> qfr, everything's a comment unless explicitly specified it is code
14:43:47 <qfr> Ah, I see
14:44:04 <qfr> And hsc is just files which are subject to #preprocessor macro stuff?
14:44:06 <Peaker> qfr, (since "literate programming" is the idea that code should be more document than executable)
14:44:33 <Peaker> qfr, I think "hsc" is just a special language that a specific tool: hsc2hs can convert to Haskell
14:44:44 <qfr> Alright
14:44:46 <Peaker> I think normal hs files can be preprocessed, not just hsc, though hsc usually are
14:45:01 <Peaker> hsc2hs lets you interface with C types a bit more easily
14:45:53 <qfr> I am trying to make hint 0.3.3.1 work with ghc 7. Somebody told me there's already a patch for it and I googled and found some stuff in a pastebin and applied it, trying to compile it from source now but runhaskell Setup.lhs configure fails with stuff like "needs MonadCatchIO-mtl >=0.2" while ghc-pkg list says MonadCatchIO-mtl-0.3.0.1 as you can see. What is this all about? Why does it say I need packages which are already installed and available in even more 
14:45:53 <qfr> recent versions? Output at: http://siyobik.info/index.php?module=pastebin&id=557 
14:48:28 <Peaker> qfr, you can use "-v" with cabal-install to get an idea of why it does things
14:49:07 <Peaker> oh, you used Setup.hs
14:49:35 <Peaker> qfr, I think the default for "setup.hs configure" is --global
14:49:35 <qfr> It demands: MonadCatchIO-mtl >=0.2, MonadCatchIO-mtl-0.3.0.1 is installed, ghc-mtl >=1.0.1.0 && <1.1.0.0, vs. ghc-mtl-1.0.1.0, ghc-paths -any vs. ghc-paths-0.1.0.8, haskell-src -any vs. haskell-src, mtl -any vs. mtl-1.1.1.0 and mtl-2.0.1.0, utf8-string -any vs. utf8-string-0.3.6
14:49:41 <Peaker> qfr, so only the global package listing is used
14:49:46 <qfr> Oh.
14:50:06 <Peaker> qfr, try passing --user to "configure" there explicitly
14:50:19 <qfr> Victory!
14:50:31 <joe6> is there a function that can do: ["00","01","02","03","04","05","06","07","08",
14:50:38 <joe6> ignore please.
14:50:45 <qfr> Yes, there is
14:50:48 <joe6> i am still putting together my questien.
14:50:50 <qfr> Even better, more than just one!
14:51:16 <Peaker> qfr, awesome
14:51:43 <joe6> is there a function that can do: ["00","01","02","03","04","05","06","07","08","09"] ==> ["00","01","02","03"," ","04","05","06","07","  ","08","09"]
14:51:59 <joe6> notice the space after "03" and the double space after "07"
14:52:07 <j-invariant> joe6: no
14:53:11 <Peaker> Let's start with:
14:53:12 <Peaker> > map (('0':) . show) [0..9]
14:53:12 <qfr> Of course there is
14:53:16 <lambdabot>   mueval-core: Time limit exceeded
14:53:21 <ion> > let f ["00","01","02","03","04","05","06","07","08","09"] = ["00","01","02","03"," ","04","05","06","07","  ","08","09"] in f ["00","01","02","03","04","05","06","07","08","09"]
14:53:22 <lambdabot>   ["00","01","02","03"," ","04","05","06","07","  ","08","09"]
14:53:34 <qfr> ion: Hahaha you beat me to it. Curses!
14:53:37 <Peaker> > map (('0':) . show) [0..9]
14:53:40 <lambdabot>   ["00","01","02","03","04","05","06","07","08","09"]
14:53:48 <qfr> ion: Actually I would have used f x = ....
14:54:10 <Peaker> @let chunks n = map (take n) . takeWhile (not . null) . iterate (drop n)
14:54:11 <lambdabot>  Defined.
14:54:21 <joe6> > (\(x,y) -> x++["  "]++y) . splitAt 8 .  (\(x,y) -> x++[" "]++y) $ splitAt 4  ["00","01","02","03","04","05","06","07","08","09"]
14:54:23 <lambdabot>   ["00","01","02","03"," ","04","05","06","  ","07","08","09"]
14:55:37 <joe6> > chunks 4  ["00","01","02","03","04","05","06","07","08","09"]
14:55:39 <lambdabot>   [["00","01","02","03"],["04","05","06","07"],["08","09"]]
14:55:53 <Peaker> @type snoc
14:55:54 <lambdabot> Not in scope: `snoc'
14:56:04 <Peaker> @let snoc xs x = xs ++ [x]
14:56:06 <lambdabot>  Defined.
14:56:20 <Peaker> > concat $ zipWith snoc (chunks 4 $ map (('0':) . show) [0..9]) (iterate (' ':) "")
14:56:22 <lambdabot>   ["00","01","02","03","","04","05","06","07"," ","08","09","  "]
14:56:27 <Peaker> oops
15:06:01 <joe6> Peaker: it took me a while to understand the chunks function. it is pretty cool. thanks.
15:08:06 <Peaker> joe6, no problem, I think it emphasizes coolness of "pipeline style" functions
15:08:25 <sipa> :t chunks
15:08:26 <lambdabot> forall a. Int -> [a] -> [[a]]
15:13:27 <aristid> @index chunks
15:13:28 <lambdabot> bzzt
15:13:32 <aristid> LIAR
15:13:44 <aristid> oh, Peaker defined it.
15:13:50 <joe6> how do I used lamdba function on a list of lists? such as: (\(a:b:c:d) -> a ++ " " ++ b ++ "  " ++ "c" ++ " " ++ d) $ chunks 4 ["00","01","02","03","04","05","06","07","08","09","10","11","12","13","14","15"]
15:14:23 <joe6> > chunks 4 ["00","01","02","03","04","05","06","07","08","09","10","11","12","13","14","15"]
15:14:25 <lambdabot>   [["00","01","02","03"],["04","05","06","07"],["08","09","10","11"],["12","1...
15:14:28 <aristid> @let iterateUntil p = takeWhile (not . p) . iterate
15:14:29 <lambdabot>  <local>:5:39:
15:14:29 <lambdabot>      Couldn't match expected type `[a]'
15:14:29 <lambdabot>             against in...
15:14:48 <aristid> :t iterate
15:14:49 <lambdabot> forall a. (a -> a) -> a -> [a]
15:14:53 <mauke> .:
15:15:22 <aristid> @let iterateUntil p = takeWhile (not . p) .: iterate
15:15:23 <lambdabot>  Defined.
15:15:28 <aristid> :t iterateUntil
15:15:30 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> [a]
15:16:08 <aristid> @let chunks' n = map (take n) . iterateUntil null (drop n)
15:16:09 <lambdabot>  Defined.
15:16:16 <aristid> :t chunks'
15:16:16 <mm_freak> > concat . zipWith (++) (iterate (' ':) " ") . chunks 4 . take 10 $ replicateM 2 ['0'..'9']
15:16:17 <lambdabot> forall a. Int -> [a] -> [[a]]
15:16:17 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
15:16:17 <lambdabot>         against inferred type...
15:16:21 <Peaker> > let (..) = (.:) in 1
15:16:23 <lambdabot>   <no location info>: parse error on input `..'
15:16:28 <mm_freak> > concat . zipWith (++) (iterate (' ':) " ") . chunks 4 . take 10 . map read $ replicateM 2 ['0'..'9']
15:16:29 <Peaker> ah, that's why it has that poor name
15:16:30 <lambdabot>   " *Exception: Prelude.read: no parse
15:16:59 <Peaker> mm_freak, why "read" there?
15:17:10 <mm_freak> Peaker: true
15:17:22 <mm_freak> i'm tired
15:17:47 <mm_freak> > concat . zipWith (++) (map (:[]) $ iterate (' ':) " ") . chunks 4 . take 10 $ replicateM 2 ['0'..'9']
15:17:49 <lambdabot>   [" ","00","01","02","03","  ","04","05","06","07","   ","08","09"]
15:18:03 <mm_freak> somewhat
15:18:15 <joe6> mm_freak: I want "07","  ","08"
15:18:31 <mm_freak> > tail . concat . zipWith (++) (map (:[]) $ iterate (' ':) "") . chunks 4 . take 10 $ replicateM 2 ['0'..'9']
15:18:33 <lambdabot>   ["00","01","02","03"," ","04","05","06","07","  ","08","09"]
15:18:54 <joe6> one space between 03 and 04 and 2 spaces between 07 and 08 and again 1 space between 11 and 12
15:19:08 <mm_freak> ah, ok
15:19:37 <joe6> 00 01 02 03   04 05 06 07     08 09 10 11   12 13 14 15
15:19:42 <mm_freak> > tail . concat . zipWith (++) (cycle [[" "], ["  "]]) . chunks 4 $ replicateM 2 ['0'..'9']
15:19:44 <lambdabot>   ["00","01","02","03","  ","04","05","06","07"," ","08","09","10","11","  ",...
15:19:57 <joe6> I am trying to display 16 bytes and wanted to do it in that manner.
15:20:00 <mm_freak> > tail . concat . zipWith (flip (++)) (cycle [[" "], ["  "]]) . chunks 4 $ replicateM 2 ['0'..'9']
15:20:01 <lambdabot>   ["01","02","03"," ","04","05","06","07","  ","08","09","10","11"," ","12","...
15:20:02 <joe6> as it might be easy to the eye.
15:20:08 <mm_freak> there you go
15:20:16 <mm_freak> uhm
15:20:18 <joe6> mm_freak: awesome. thanks.
15:20:22 <mm_freak> > concat . zipWith (flip (++)) (cycle [[" "], ["  "]]) . chunks 4 $ replicateM 2 ['0'..'9']
15:20:23 <lambdabot>   ["00","01","02","03"," ","04","05","06","07","  ","08","09","10","11"," ","...
15:20:24 <Peaker> that's not right
15:20:29 <Peaker> mm_freak, switch around your cycle cause of the "tail"
15:20:37 <Peaker> mm_freak, instead of flipping the (++)
15:21:26 <joe6> or what do you feel about calling splitAt with 3 different parameters and using that (a,b,c,d) in a lambda expression.
15:22:05 * edwardk waves hello.
15:22:13 <edwardk> i have a comonad, but i don't quite know what it means =)
15:22:27 <mm_freak> Peaker: i prefer to remove the tail
15:22:42 <joe6> > (\(x,y) -> x++[" "]++y) . splitAt 4 . (\(x,y) -> x++["  "]++y) . splitAt 8 .  (\(x,y) -> x++[" "]++y) . splitAt 12  $ ["00","01","02","03","04","05","06","07","08","09","10","11","12","13","14","15"]
15:22:43 <lambdabot>   ["00","01","02","03"," ","04","05","06","07","  ","08","09","10","11"," ","...
15:24:35 <Peaker> joe6, you could factor out the \(x,y)->..  part and then that part plus the splitAt part
15:24:45 <joe6> i wish I could get into something like: (\(a,b,c,d) -> a ++ " " ++ b ++ "  " ++ c ++" "++d) . (split into 4) $ ["00","01","02","03","04","05","06","07","08","09","10","11","12","13","14","15"]
15:25:42 <joe6> so, any thoughts on the function that can do: ["00","01","02","03","04","05","06","07","08","09","10","11","12","13","14","15"] => [("00","01","02","03"),("04","05","06","07"),("08","09","10","11"),("12","13","14","15")]
15:26:08 <joe6> it just needs to be for exactly 16 bytes, so do not have to worry about shorter or longer lists.
15:26:24 <edwardk> i have a comonad for (->)e which is based on using a monoid on e to glue them together on duplicate, and to extract values
15:26:39 <Peaker> > let space s (x,y) = x ++ [s] ++ y ; spaceSplit s n = space s . splitAt n  in   spaceSplit " " 4 . spaceSplit "  " 8 . spaceSplit " " 12 $ take 10 (replicateM 2 ['0'..'9'])
15:26:41 <lambdabot>   ["00","01","02","03"," ","04","05","06","07","  ","08","09"," "]
15:26:49 <Peaker> > let space s (x,y) = x ++ [s] ++ y ; spaceSplit s n = space s . splitAt n  in   spaceSplit " " 4 . spaceSplit "  " 8 . spaceSplit " " 12 $ take 15 (replicateM 2 ['0'..'9'])
15:26:52 <lambdabot>   ["00","01","02","03"," ","04","05","06","07","  ","08","09","10","11"," ","...
15:26:55 <edwardk> that is all well and good, and lets me build 'traced' values in some sense, its the 'cowriter' comonad
15:27:25 <edwardk> but you can replace the function with a 'total' map, (Map k a, a) -- where the last a is used as a default value for where the key is undefined
15:27:30 <mm_freak> > map (\[a,b,c,d] -> (a,b,c,d)] . chunks 4 $ replicateM 2 ['0'..'9']
15:27:31 <lambdabot>   <no location info>: parse error on input `]'
15:27:40 <mm_freak> > map (\[a,b,c,d] -> (a,b,c,d)) . chunks 4 $ replicateM 2 ['0'..'9']
15:27:42 <lambdabot>   [("00","01","02","03"),("04","05","06","07"),("08","09","10","11"),("12","1...
15:27:58 <edwardk> and combine keys using the monoid. now its kind of like a trie. in the sense that duplication provides partial keys
15:28:04 <joe6> mm_freak: brilliant, thanks.
15:29:20 <qfr> mm_freak: And what if he wants to use 5 instead of 4 in the future? :P
15:31:51 <mm_freak> qfr: then he shouldn't use tuples at all ;)
15:32:38 <qfr> mm_freak: True :p
15:38:02 <edwardk> sweet. we have a job listing up on functionaljobs =)
15:38:13 <edwardk> come, work with me!
15:38:26 <edwardk> though, i suppose its probably easier to apply through me ;)
15:38:35 <Philippa> heh. What, where etc?
15:38:52 <Philippa> (not that it'd be at all sensible for me to apply for all the usual reasons)
15:39:24 <edwardk> CapitalIQ/ClariFi, mostly writing scala and working on a functional language being used in financial reporting
15:39:30 <edwardk> where = boston
15:39:57 <edwardk> though, looking at the whieboards, there is more haskell on them than scala. that may be my influence though
15:40:10 <Bynbo7> excellent
15:41:06 <Bynbo7> edwardk: i'd definitely be interested in the future, not sure how my girlfriend would feel though =)
15:41:21 <Bynbo7> she just blew a large portion of her savings visiting me here in japan
15:41:35 <edwardk> bynbo7: fair enough. ping me when/if it makes sense.
15:41:43 <edwardk> where is she?
15:41:45 <Bynbo7> will do
15:41:49 <Bynbo7> Australia
15:42:22 <monochrom> australia to boston is a longer flight
15:42:29 <Bynbo7> yeah
15:43:00 <edwardk> yeah, hard to get much farther apart =/
15:43:15 <beastaugh> is anyone still working on a Haskell neural networks library?
15:43:24 <beastaugh> HNN seems to have been abandoned
15:43:28 <edwardk> beastaugh: there is HNN, but its kinda dead
15:43:30 <edwardk> yeah
15:44:10 <edwardk> they were active at the beginning of summer, but then alp's computer died, and tomberek got distracted with the underlying graph machinery and trying to fix up fgl with ivanm
15:44:36 <beastaugh> I suppose that's always a danger with rewrites :)
15:46:46 <edwardk> hrmm, finite random access streams kinda suck. the infinite ones are cool though
15:56:47 <sleepynate> hmm... pet project. snap or happstack?
15:57:09 <Heffalump> snap has all the buzz these days
15:57:14 <Bynbo7> snap imo
15:57:28 <sleepynate> orly
15:57:38 <qfr> sleepynate: I spent 11 hours on making those work with ghc 7 today
15:57:41 <qfr> It was a huge pain
15:57:49 <sleepynate> this would be my first haskell web experience
15:58:06 <c_wraith> It's significantly less painful on GHC 6.12
15:58:14 <sleepynate> which is what we'd be on
15:58:27 <sleepynate> 6.*
15:58:39 <qfr> ghc 7 AND Windows, for an additional challenge!
15:58:48 <sleepynate> qfr: yuckers
15:58:59 <parcs> sleepynate: your own :)
15:59:49 <sleepynate> parcs: in due time, sensei, in due time
16:01:36 <joe6> can I use Text.PrettyPrint to get a tabular layout by laying all rows of column1 and then the rows of column 2 and so on.?
16:01:58 <qfr> sleepynate: I had an enormous battle with Hackage today, trying to make my dependencies (snap, Takusen, wai, yaml, openid, etc, also tried happstack) work with ghc 7 on Windows with MinGW/MSYS/etc. Ended up mailing four package maintainers, writing and submitting a source patch for one dependency and applying an inofficial patch to compile hint with ghc 7 just to make snap work :'(. It's pretty ridiculous considering I'm not even past the hello world stage in 
16:01:58 <qfr> Haskell.
16:03:01 <sleepynate> qfr: yea, i'm not moving to 7 until i stop hearing about issues :)
16:03:19 <qfr> Oh, and I fought with yesod, too.
16:04:03 <mm_freak> i agree with sleepynate 
16:04:20 <mm_freak> i'll wait with GHC 7, until it's in the official arch repos
16:04:48 <sleepynate> mm_freak: bingo ;)
16:05:07 <mm_freak> even though i can't wait to get LLVM
16:05:07 <mm_freak> =)
16:06:58 <cdsmithus> mm_freak: the LLVM back end is nice; but unless you're making heavy use of vector, it probably won't be a world-changing thing.  Hopefully, most Haskell programmers won't notice when it's finally switched on as the default.
16:07:29 <Evious> Lots of tweakable optimizations! Eeeeee!
16:08:19 <mm_freak> cdsmithus: i'm working a lot with bytestrings and sometimes direct memory access  i hoped LLVM would make a major difference there
16:08:57 <cdsmithus> I'm just suggesting it's not worth the pain of trying to build the world against GHC 7 before the HP is released.
16:10:28 <mm_freak> yeah, and i just can't wait =)
16:10:33 <mm_freak> but i will
16:28:10 <lerg> I'm trying to do a function foo :: (Int->Int)->(Int->Int), such that f is the parameter, then the result is: f 0 + f 1 + ... + f n.   I did,   foo f = foldr (+) (map f [1..n])    but have some problem with the parameter of the result function (in this case 'n'). What I have to change? 
16:28:52 <mauke> foo f n =
16:29:07 <mauke> less mindbendingly: foo f = \n -> ...
16:29:18 <mtnviewmark> foo f n = sum $ map f [1..n]
16:29:40 <lerg> I try that, but gives: *** Does not match : (Int -> Int) -> Int -> Int
16:29:52 <mauke> what's the actual message?
16:30:06 <Saizan> foldr needs 3 arguments, i.e. a base case too
16:30:25 <mtnviewmark> let sumUpToN f n = sum $ map f [1..n] in sumUpToN (\x -> x * x) 4
16:30:31 <mtnviewmark> >let sumUpToN f n = sum $ map f [1..n] in sumUpToN (\x -> x * x) 4
16:30:31 <Pseudonym> lerg, a "bug" is a different in opinion of what a program means.
16:30:42 <Pseudonym> You think it means one thing, the computer thinks it means something else.
16:30:48 <mtnviewmark> > let sumUpToN f n = sum $ map f [1..n] in sumUpToN (\x -> x * x) 4
16:30:48 <lambdabot>   30
16:31:08 <Pseudonym> That's why it says "I got this, but I expected it to match this".
16:31:09 <mauke> > let foo f n = foldl' (\z x -> z + f x) 0 [1 .. n] in foo (join (*)) 4
16:31:10 <lambdabot>   30
16:31:20 <Pseudonym> They're both important pieces of information for understanding those type error messages.
16:31:58 <parcs> @check liftM2 (==) (join (*)) (^2)
16:31:59 <lambdabot>   "OK, passed 500 tests."
16:32:03 <lerg> I'm sorry.. i mixed with other function. :$ im sorry for this
16:32:13 <Pseudonym> Don't apologise, it's cool.
16:32:18 <mauke> :t (. ?f) . (+)
16:32:19 <lambdabot> forall b (f :: * -> *). (?f::f b, Functor f, Num b) => b -> f b
16:32:21 <mtnviewmark> lerg: I think the first problem in your code is that foldr needs a "seed" value, put 0 between the (+) and the (map...)
16:32:21 <monochrom> you did nothing wrong to us
16:32:56 <sabin> hi
16:33:01 <Bynbo7> 'lo
16:33:09 <mtnviewmark> oooo didn't know lambdabot could @check.... sweet
16:33:38 <monochrom> @check \x -> x == ()
16:33:39 <lambdabot>   "OK, passed 500 tests."
16:33:47 <mauke> :t (Prelude.. ?f) . (+)
16:33:48 <lambdabot> forall c a. (?f::a -> c, Num c) => c -> a -> c
16:33:51 <copumpkin> @check ap (==) reverse
16:33:52 <lambdabot>   "OK, passed 500 tests."
16:34:07 <Bynbo7> :(
16:34:09 <mauke> @check ap (==) sort
16:34:10 <lambdabot>   "OK, passed 500 tests."
16:34:24 <Evious> #commands
16:34:29 <Evious> @commands
16:34:30 <lambdabot> Unknown command, try @list
16:34:32 <Evious> @list
16:34:32 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
16:34:34 <mtnviewmark> uhm.... that seems broken, yes?
16:34:35 <Pseudonym> :t ap (==) sort
16:34:36 <lambdabot> forall a. (Ord a) => [a] -> Bool
16:34:39 <mtnviewmark> :t ap (==) sort
16:34:40 <lambdabot> forall a. (Ord a) => [a] -> Bool
16:34:41 <mauke> mtnviewmark: no, why? :-)
16:34:55 <monochrom> > sort [(),(),()] == [(),(),()]
16:34:56 <lambdabot>   True
16:35:00 <copumpkin> mtnviewmark: gotta love defaulting
16:35:00 <monochrom> do you agree?
16:35:10 <Pseudonym> @free apEqSort :: (a -> a -> Comparison) -> [a] -> Bool
16:35:10 <lambdabot> (forall x. g x = h (f x) . f) => apEqSort g = apEqSort h . $map f
16:35:17 <mtnviewmark> what is ap (==) sort checking?   that a list equals the sort of that list?
16:35:22 <mauke> yes
16:35:33 <parcs> @check ap (==) sort :: [Int] -> Bool
16:35:35 <lambdabot>   Couldn't match expected type `[GHC.Types.Int] -> GHC.Bool.Bool'
16:35:44 <mtnviewmark> but, sort [4,3,1] /= [4,3,1]
16:35:53 <mauke> mtnviewmark: true but irrelevant
16:35:54 <copumpkin> mtnviewmark: why would it pick Int?
16:36:01 <copumpkin> mtnviewmark: it's gotta pick something, and it picks something
16:36:05 <copumpkin> mtnviewmark: it picks () :P
16:36:07 <mtnviewmark> oy
16:36:11 * hackagebot ght 0.3.1 - Trivial routines for inspecting git repositories  http://hackage.haskell.org/package/ght-0.3.1 (ConradParker)
16:36:28 <mtnviewmark> @check ap (==) (sort :: [Int]->[Int])
16:36:28 <lambdabot>   "Falsifiable, after 3 tests:\n[1,0]\n"
16:36:34 <mtnviewmark> there
16:37:02 <monochrom> so it is not broken, and you proved it.
16:37:15 <aristid> @check ap (==) (sort)
16:37:16 <lambdabot>   "OK, passed 500 tests."
16:37:26 <mtnviewmark> indeed - what was broken was my not including () in the set of possible, and likely candidates for quick-check
16:38:04 <mtnviewmark> I submit that perhaps that () isn't useful for checks based on Eq matching...
16:38:30 <mauke> @check (< 5)
16:38:31 <lambdabot>   "Falsifiable, after 24 tests:\n8\n"
16:38:37 <mauke> @check (< 15)
16:38:38 <lambdabot>   "Falsifiable, after 60 tests:\n15\n"
16:38:39 <hpc> i submit that () isn't a useful default instance anywhere
16:38:47 <parcs> @check ap (==) (+0)
16:38:48 <lambdabot>   "OK, passed 500 tests."
16:38:58 <monochrom> there is no useful default
16:39:27 <jix> can GHC generate a warning on () defaulting?
16:39:32 <aristid> @check (< 1000)
16:39:33 <lambdabot>   "OK, passed 500 tests."
16:39:36 <aristid> haha
16:39:42 <monochrom> hahaha
16:39:58 <jix> @check (/= 42)
16:40:00 <lambdabot>   "OK, passed 500 tests."
16:40:18 <aristid> @check (/= 0)
16:40:19 <lambdabot>   "Falsifiable, after 0 tests:\n0\n"
16:40:21 <aristid> @check (/= 0)
16:40:22 <lambdabot>   "Falsifiable, after 0 tests:\n0\n"
16:40:27 <aristid> oO
16:40:53 <monochrom> it probably is SmallCheck, which favours "small" examples
16:41:00 <c_wraith> @check ap (==) reverse
16:41:01 <lambdabot>   "OK, passed 500 tests."
16:41:18 <mauke> @check liftA2 (||) even odd
16:41:19 <lambdabot>   "OK, passed 500 tests."
16:41:35 <lerg> I find the notation foo :: (Int->Int)->(Int->Int) not very usefull, because the parameter of the result function is also a parameter... its pretty strange, I'd prefer foo :: (Int->Int)->Int->Int. There's some important/valuable reason to use the first notation?
16:41:57 <monochrom> No
16:42:01 <c_wraith> lerg: nope.  It just makes the binding order explicit
16:42:14 <copumpkin> I like the first option if I'm making  the symmetry clear
16:42:17 <copumpkin> or whatever
16:42:32 <copumpkin> something like
16:42:32 <monochrom> @type id
16:42:33 <lambdabot> forall a. a -> a
16:42:45 <copumpkin> (a -> b) -> f a -> f b is clearer as (a -> b) -> (f a -> f b) in my opinion
16:43:06 <monochrom> you may also find "a->a" pretty strange, "the result is also a parameter" and all that.
16:43:23 <c_wraith> I'd write the type of (.) as :: (b -> c) -> (a -> b) -> (a -> c)
16:43:31 <copumpkin> same
16:43:32 <aristid> copumpkin: but less symmetric
16:43:40 <copumpkin> ?
16:43:45 <monochrom> and similarly Int->Int may be strange for the same reason
16:43:51 <monochrom> @type negate
16:43:52 <lambdabot> forall a. (Num a) => a -> a
16:43:53 <lerg> Using bracks for me seems more like an element per se... so using foo :: (Int->Int)->(Int->Int) doesn't seems much natural to have;  foo f n = ... 
16:44:02 <lerg> brackets
16:44:16 <parcs> parantheses?
16:44:23 <mauke> no, parentheses
16:44:24 <lerg> Yes.. sorry for my english :P
16:44:29 <mauke> brackets is fine
16:44:38 <monochrom> not to me
16:44:44 <aristid> .
16:44:53 <parcs> brackets isn't fine
16:44:57 <parcs> they are two different things
16:45:10 <mauke> round brackets, square brackets, curly brackets (a.k.a. flower brackets)
16:45:21 <monochrom> my full sentence: using brackets or parentheses or whatever does not seem more like an element per se to me.
16:45:49 <monochrom> and foo :: (Int->Int)->(Int->Int) seems natural to me in suitable contexts.
16:46:18 <lerg> But suggest that the first parameter could be seen as to parameters also, instead of a function
16:46:32 <revenantphx> damn you haskell >_>
16:46:41 <lerg> two
16:46:52 <revenantphx> I have trouble writing python now since I keep thinking "aaaaah, I want this to be X type"
16:46:55 <tolkad> I have a question about Ix, will it fail if you try to use it with something larger than an Int?
16:47:03 <mauke> lerg: I disagree
16:47:06 <revenantphx> I'm suffering from robust type system withdrawel
16:47:07 <revenantphx> .
16:47:10 <tolkad> like potentially Int64?
16:47:16 <tolkad> even though there is an instance
16:47:49 <lerg> maybe:  foo a b n   seems to be ok for  foo :: (Int->Int)->(Int->Int) ... its the same logic of 'splitting' the last (Int->Int) and use the first Int as a parameter
16:48:45 <Bynbo7> tolkad: well, if you're on a 32 bit system, then you won't be able to access enough of the array for it to matter, and if you're on a 64 bit system, Int = Int64
16:48:55 <Bynbo7> and time to go to work
16:49:19 <monochrom> you can keep arguing and rationalizing your misinterpretation, so as to avoid correcting it.
16:50:11 <lerg> I'm not trying to argue. Its only that I saw a new thing and extrapolate the same idea leading to a counter intuitive result.
16:50:21 <Pseudonym> lerg: a - b - c means (a - b) - c, not a - (b - c)
16:50:42 <Pseudonym> Similarly, A -> B -> C means A -> (B -> C), not (A -> B) -> C
16:51:03 <tolkad> lerg: think of it in terms of lambda calculus
16:51:03 <Pseudonym> You're right that whether or not it makes sense to put in parentheses is entirely one of which makes things more clear.
16:51:48 <lerg> Ok, thanks for the explanations :)
16:51:54 <tolkad> lerg: if you don't know lambda calculus, then go learn it. it's really simple and essential to understanding functional programming
16:52:08 <parcs> is it really?
16:52:23 <hpc> parcs: name an FP language that lacks lambdas
16:52:25 <hpc> :P
16:53:27 <Pseudonym> hpc: Miranda.
16:53:45 <mauke> hpc: SKI
16:53:55 <hpc> mauke: touche
16:54:25 <hpc> didn't know about miranda though
16:54:49 <hpc> though SKI is technically a subset of lambda calculus
16:55:18 <tolkad> hpc: it's a different language that just happens to correlate with a subset of lambda calculus
16:55:44 <hpc> i reject your reality and substitute my own!
16:55:46 <qfr> What's up with the use of pipes in Haskell comments, btw?
16:55:56 <qfr> I frequently see {-| and -- | and stuff like that
16:56:04 <qfr> Although inconsistently
16:56:12 <hpc> qfr: to annoy you, i would guess
16:56:18 <hpc> as i have never encountered this, myself
16:56:27 <qfr> Ah, it's Haddock
16:56:30 <hpc> (it would annoy me too, if i saw it in real code)
16:56:34 <hpc> oh, nvm then
16:56:35 <tolkad> qfr: they tell the compiler that the comment is extra commenty
16:56:46 <Evious> Haddock is like the greatest thing ever.
16:56:52 <Evious> Should be part of the language, tbh.
16:56:56 <hpc> just don't use --||, or the universe explodes
16:57:21 <tolkad> if there is one thing haskell does not have enough of, it is language features
16:57:29 <elliott> is there a guide to setting up haskell-mode with literate haskell latex?
16:57:31 <elliott> multiple major mode etc.
16:57:32 <hpc> tolkad: lol
16:57:38 <Evious> {-# LANGUAGE Haddock #-}
16:58:13 <believa> In a Setup.hs file, will the function set for the preInst UserHook be the first thing to "fire" when you do a 'cabal install'? I'm finding preConf fires for me when I do a 'cabal configure', but preInst won't.
16:58:15 <hpc> haskell has language extensions in every orifice one can fit
16:58:47 <revenantphx> {-# LANGUAGE Dildo #-}
16:59:10 * hpc facepalms
16:59:32 <monochrom> {-# LANGUAGE Python #-}
16:59:32 <elliott> {-# LANGUAGE AdvancedLanguageExtensionSpecificationLanguage #-}
16:59:49 <elliott> usesExtensions (superAdvancedExtensionSpecificationLanguage ==2.0 with (extraFunctions)) in
16:59:51 <Saizan> believa: preInst is before what corresponds to Setup install, which is not the same as cabal install
16:59:52 <hpc> {-# LANGUAGE YoDawg #-}
16:59:54 <elliott> \extensions
16:59:58 <revenantphx> We need a meta-language (or dialect of Template Haskell) to template extensions
17:00:05 <revenantphx> >_>
17:00:06 <Evious> I actually do kinda score my Haskell code based on how many extensions it has at the top. The longer the list gets, the smarter and more accomplished I feel.
17:00:08 <Saizan> believa: so after configure and build
17:00:10 <elliott> {\use{MegaAdvancedE.S.L.}\with @+2.9,5 weighting
17:00:12 <elliott> \start@}
17:00:20 <hpc> revenantphx: and then write TH in it!
17:00:23 <elliott> ^ it's like "use strict; use warnings"
17:00:33 <hpc> and add another recursive dependency to GHC!
17:00:56 <revenantphx> GHC is more likely to cause a black whole than the LHC...
17:00:58 <monochrom> "{-|" and "-- |" are not inconsistent. read the detailed lexer rules. you will find "--|" is not comment, so you're forced to "-- |".
17:01:04 <revenantphx> With all these extensions it will soon reach critical mass.
17:01:14 <revenantphx> hole*
17:01:18 <monochrom> ignorant people have a lot of opinions.
17:01:23 <revenantphx> Of course this black hole will quickly be plugged.
17:01:27 <revenantphx> By a language extension.
17:01:39 <hpc> revenantphx: or when it sucks up america
17:01:49 <hpc> all that nasty mass will make it spew the universe back out again
17:01:58 <revenantphx> {-# LANGUAGE GrainBelt, OrangeCounty #-}
17:02:00 <revenantphx> *shivers*
17:02:02 <aristid> > let (--|) = "Monochrome" in (--|)
17:02:04 <lambdabot>   "Monochrome"
17:02:16 <elliott> oh man
17:02:17 <elliott> best operator name ever
17:02:25 <revenantphx> let (^,_,^) = "Master Wei says..." in (^,_,^)
17:02:26 <hpc> @let (--|) = fix -- fix
17:02:28 <lambdabot>  Defined.
17:02:30 <elliott> > let f --| g = g . f in 2 --| succ --| succ
17:02:31 <lambdabot>   No instance for (GHC.Num.Num (f a))
17:02:31 <lambdabot>    arising from a use of `e_12' at <int...
17:02:33 <Evious> Are there any languages that define a comment operator?
17:02:35 <elliott> oh
17:02:36 <revenantphx> > let (^,_,^) = "Master Wei says..." in (^,_,^)
17:02:38 <lambdabot>   <no location info>: parse error on input `,'
17:02:41 <revenantphx> damn commas
17:02:42 <elliott> > let f --| g = g . f in (succ --| succ) 2
17:02:44 <lambdabot>   4
17:02:51 <aristid> Evious: forth
17:02:51 <revenantphx> > let (^_^) = "Hello world" in (^_^)
17:02:52 <lambdabot>   <no location info>: parse error on input `)'
17:03:56 <hpc> > let o.o = 0.0 in x.x
17:03:57 <lambdabot>   Conflicting definitions for `o'
17:03:57 <lambdabot>  Bound at: <interactive>:1:4
17:03:57 <lambdabot>            <in...
17:04:16 <believa> Saizan: not sure I understand.  I have Build-type set to 'Custom' in my .cabal file which will trigger the Setup.hs when I invoke any cabal command? Can I use a hook so that when I invoke 'cabal install' I can do extra things before the normal cabal install stuff happens?
17:04:51 <believa> Saizan: What's the difference between Setup install and cabal install?
17:05:36 <succ-quuux> @let (>.<) = ("foo" ++)
17:05:37 <lambdabot>  Defined.
17:05:48 <succ-quuux> @let (<.<) = "bar"
17:05:49 <lambdabot>  Defined.
17:05:54 <Saizan> believa: "cabal install" is more like "Setup configure && Setup build && Setup install" except that it also tries to find and build the missing dependencies on hackage even before calling Setup configure
17:05:58 <revenantphx> > cake
17:06:00 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
17:06:06 <succ-quuux> > let (>.>) = (>.<) (<.<) in (>.>)
17:06:08 <lambdabot>   "foobar"
17:06:12 <revenantphx> what was the trick with cake?
17:06:23 <revenantphx> > nub cake
17:06:25 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
17:06:31 <revenantphx> > map nub cake
17:06:33 <lambdabot>   ["One 18.25oucpakghltmix","One caprdoutfsig.","Thre slafoucpvgtbi.","Four l...
17:06:43 <sipa> > transpose cake
17:06:44 <hpc> > map head cake
17:06:46 <lambdabot>   ["OOTFOTOTDFFFFFPFCOAUFANTOATTOOTOOTASCIICAT","nnhonhnwoiiiiiuianlniniwnnww...
17:06:46 <lambdabot>   "OOTFOTOTDFFFFFPFCOAUFANTOATTOOTOOTASCIICAT"
17:06:53 <revenantphx> there we go, ascii cat.
17:06:57 <hpc> TOOTOOT ASCIICAT
17:07:00 <revenantphx> :)
17:07:15 <believa> Saizan: ok. But cabal install should eventually do Setup install which should trigger a preInst UserHook?
17:07:23 <revenantphx> `map nub cake` translates the recipe to russian.
17:07:27 <Saizan> believa: yes
17:08:01 <aristid> > transpose cake !! 1
17:08:03 <lambdabot>   "nnhonhnwoiiiiiuianlniniwnnwwnnhnnwdlonnrnh"
17:08:05 <int80_h> I'm looking for a function like tail, but has type [a] -> a. Any hints?
17:08:14 <aristid> > transpose cake !! 2
17:08:16 <lambdabot>   "eeruereonssssslsnepsbdnee ooeereeojarjjada"
17:08:20 <hpc> > last . transpose $ cake
17:08:22 <lambdabot>   "."
17:08:23 <aristid> > map last cake
17:08:25 <mauke> int80_h: head
17:08:25 <lambdabot>   "........:................'................"
17:08:41 <aristid> hpc: IT'S A SECRET MESSAGE
17:08:41 <nzero> Hi, I want to embed a simple http server in a long-running haskell app.  What'd be a good choice of http server library?  I don't need 99% of say happstack.
17:08:43 <int80_h> mauke: yeah but I want to work the other end.
17:08:56 <aristid> nzero: snap?
17:08:57 <mauke> int80_h: last
17:09:02 <int80_h> ah!
17:09:06 <int80_h> mauke: thanks
17:09:16 <nzero> (preferring maturity over feature set)
17:09:20 <qfr> Why does ghc even require a -threaded flag?
17:09:24 <aristid> > map nub cake
17:09:26 <lambdabot>   ["One 18.25oucpakghltmix","One caprdoutfsig.","Thre slafoucpvgtbi.","Four l...
17:09:34 <qfr> Is enabling concurrency a huge deal in Haskell?
17:09:40 <revenantphx> @let russian_cake = map nub cake
17:09:42 <lambdabot>  Defined.
17:09:44 <Saizan> qfr: the non-threaded runtime can be faster for some programs
17:09:46 <monochrom> yes
17:10:00 <revenantphx> It will *end the universe as we know it* qfr
17:10:10 <monochrom> and start a better one
17:10:16 <aristid> or worse one
17:10:24 <aristid> or equally good one
17:10:28 <nzero> aristid ta
17:10:38 <aristid> or one whose quality cannot be compared with the previous one
17:10:59 <quuuux> No instance for (Eq Universe)
17:11:19 <aristid> quuuux: might be an orphan instance
17:11:20 <qfr> nzero: snap is 5 times the size of happstack
17:11:20 <Saizan> my universes are a total order, thanks.
17:11:35 <qfr> It's definitely not what you want if happstack has too much for you already
17:11:40 <cdsmithus> qfr: huh?
17:12:05 <revenantphx> size =/= features
17:12:07 <gwern> I didn't realize snap was so big
17:12:24 <qfr> snap is the biggest HTTP serving related project in Haskell afaik?
17:12:25 <gwern> they must be coding like dogs if they're already 5x the LOC of happstack
17:12:37 <revenantphx> seriously.
17:12:47 <revenantphx> Their rate of production is a monotonic function.
17:12:48 <Axman6> i thought snap was rather small
17:12:57 <cwraith> Much of Snap's size isn't actually code.
17:13:05 <nzero> qfr: thanks.  I'm hoping that one of these has some rock solid core that I can use without importing the kitchen sink.
17:13:31 <qfr> nzero: You could just build something on top of wai, I think, that would be very barebone
17:13:44 <qfr> Although that might have been SCGI/FCGI only
17:13:52 <Saizan> http://hackage.haskell.org/package/mohws
17:13:53 <qfr> I can't even remember if it did HTTP on its own
17:13:58 <qfr> No, I think it didn't
17:14:11 <Saizan> http://hackage.haskell.org/package/hyena
17:14:24 <Saizan> (can't guarantee on stability)
17:14:59 <qfr> c_wraith oh
17:15:05 <nzero> ta.  I'll see what the minimum footprint of happstack is.
17:15:14 <qfr> Memory footprint?
17:15:40 <dibblego> is it typical to use DList in the w of Writer w a? if not, then what?
17:15:41 <nzero> yeah mem.  and the space it takes up in my head to work with it...
17:15:48 <qfr> Haha
17:16:13 <nzero> (haskell newbie)
17:16:22 <copumpkin> dibblego: yeah, or a Seq
17:16:23 <mauke> dibblego: I think I've done that
17:16:30 <dibblego> ok thanks
17:16:41 <hpc> @hoogle DList
17:16:42 <lambdabot> Text.Html dlist :: Html -> Html
17:16:42 <lambdabot> Text.XHtml.Frameset dlist :: Html -> Html
17:16:42 <lambdabot> Text.XHtml.Strict dlist :: Html -> Html
17:16:49 <Saizan> Endo [a]
17:16:57 <qfr> nzero: Why even use Haskell if you are so concerned with memory usage? :p
17:17:00 <hpc> Endo?
17:17:13 <Saizan> newtype Endo a = Endo (a -> a)
17:17:23 <hpc> ah
17:17:39 <dibblego> newtype DList a = DList (a -> a) -- type DList a = Endo a
17:18:02 <qfr> nzero: The hello world in snap is at 8.4 MiB of mostly unshared stuff on windows btw
17:18:08 <qfr> It's pretty slim
17:18:11 <djahandarie>  > ala DList foldMap -- coming soon
17:18:28 <Saizan> newtype DList a = DList ([a] -> [a]) -- type DList a = Endo [a], -- actually
17:18:33 <dibblego> djahandarie, can't wait :)
17:18:42 <dibblego> Saizan, sorry, thanks
17:19:08 <qfr> With something similar in Common Lisp I was at over 40 MiB already :p
17:19:16 <djahandarie> dibblego, it's done actually, just need to write the .cabal
17:19:21 <nzero> qfr thank you
17:19:27 <dibblego> djahandarie, let me know if you need any help
17:19:35 <djahandarie> Will happen at night probably, that seems to be when most of my Haskell hacking happens
17:20:56 <hpc> shouldn't HTTP be simple enough that you can roll your own?
17:21:52 <hpc> plus, you can implement specifically what you want, and not worry about having to implement RFC822 or whatever
17:22:03 <dibblego> djahandarie, what is the signature for ala (do you have a source repo?)
17:22:05 <Pseudonym> It's simple enough that it can be written in a modest amount of C on 1989-era machines.
17:22:09 <nzero> hpc: Yep, that's a possibility, of course.  But I'd be adding a lot of bugs.
17:22:23 <djahandarie> dibblego, http://althack.org/Data-Newtype.hs http://althack.org/Newtype.hs
17:22:24 <Pseudonym> At least HTTP/0.9 can.
17:22:27 <djahandarie> Oops
17:22:31 <djahandarie> dibblego, http://althack.org/Data-Newtype.html http://althack.org/Newtype.hs
17:22:40 <qfr> hpc: I wrote a programmatic HTTP server interface in C++ with IOCP/epoll/kqueue async IO, gzip/deflate compression and such once, I think it was already at like 70 KiB
17:22:55 <hpc> it's hard to write HTTP parsing with bugs
17:22:57 <qfr> And that was with boost::asio
17:23:08 <hpc> i am fairly sure one could even write a regex to parse it
17:23:20 <dibblego> djahandarie, thanks
17:23:22 <qfr> Chunking, compression, connection keep alive stuff
17:23:28 <qfr> There's a lot you can mess up
17:23:33 <hpc> ah
17:23:39 <djahandarie> dibblego, let me know if my explanations are confusing so I can make them better
17:23:40 <hpc> didn't know how much of it you needed
17:23:46 <dibblego> djahandarie, will do
17:23:54 <qfr> But a hello world is fairly short
17:23:58 <hpc> what are you writing, out of curiosity?
17:24:15 <qfr> Do you mean nzero or me now?
17:24:32 <hpc> oh, you aren't nzero
17:24:37 <qfr> Indeed
17:24:46 <hpc> then my advice might still apply :P
17:24:55 <elliott> so what's the nearest substitute to cabal uninstall
17:24:57 <nzero> It's a learning project.  A Long-running log-processor that I figure would serve basic stats via http.  (in the same way as haproxy, nginx, etc, do)
17:25:10 <Saizan> elliott: ghc-pkg unregister
17:25:14 <hpc> oh that's trivial stuff
17:25:17 <monochrom> ghc-pkg unregister is the nearest substitute to cabal uninstall
17:25:19 <nzero> Yes, i could go to a db and separate the too.
17:25:27 <Axman6> djahandarie: needs moar examples in the haddocks
17:25:30 <nzero> the two, rather.  
17:26:00 <dibblego> djahandarie, actually those explanations are exceptional, though I went into it with an existing intuition for how it is done
17:26:02 <monochrom> see also http://www.vex.net/~trebla/haskell/sicp.xhtml#remove
17:26:23 <elliott> monochrom: when i read "sicp" i was not expecting that
17:26:28 <elliott> Structure and Interpretation of Cabal Packages
17:26:52 <monochrom> there is clearly no structure or interpretation
17:27:07 <djahandarie> dibblego, okay, yeay :)
17:27:12 <Axman6> djahandarie: things like ala only made sense to me when i saw examples of its use. if you just stick in the ala {Sum,Prod} foldMap [1..10] and Endo examples it would be more clear
17:27:17 <hpc> :t ala
17:27:19 <lambdabot> Not in scope: `ala'
17:27:25 <nzero> hpc: yep trivial stuff.
17:27:40 <djahandarie> Axman6, they are there aren't they?
17:27:48 <dibblego> djahandarie, examples of non-foldMap usage might be helpful
17:28:12 <djahandarie> dibblego, most of the instances are for Monoid-related things
17:28:14 <Axman6> oh my bad, they are there. i thought they'd be in the docs for ala, not the package
17:28:21 <hpc> nzero: are you going to be running the script as a CGI, or as the server itself?
17:28:27 <dibblego> djahandarie, yeah I bet
17:28:48 <qfr> hpc: Isn't CGI really uncommon nowadays? :p
17:28:50 <nzero> hpc: the log-processor will be the server, I reckon.  
17:28:57 <qfr> In comparison to reverse proxying/SCGI etc
17:28:58 <hpc> qfr: lol
17:29:00 <djahandarie> Could try to do something funky with the ArrowMonad one
17:29:00 <qfr> And FastCGI
17:29:21 <hpc> qfr: ah, well i meant CGI as in anything called by a real http server
17:29:35 <djahandarie> Or explain what ala Cont traverse does
17:29:38 <cdsmithus> qfr: No.  It's certainly not trendy, but I'd guess CGI and PHP comprise the great majority of dynamic code.
17:29:43 <dibblego> djahandarie, don't you have it on github or something?
17:29:57 <djahandarie> No :P Probably should have put it on there
17:30:01 <qfr> Hmm
17:30:05 <dibblego> yeah, sure makes life easier
17:30:05 <cdsmithus> Not that I'm advocating more people do it. :)
17:30:18 * monochrom coins "*CGI" to refer to all of them
17:30:25 <hpc> also, afaik it's common to run through mod_perl or mod_php
17:30:29 <djahandarie> Usually I make local darcs repos but I neglected to do so for some odd reason this time
17:30:36 <qfr> \S*CGI
17:30:56 <monochrom> but I guess people have already coined "web 2.0" for the same things.
17:30:59 <qfr> mod_php is the most common one yeah
17:32:22 <hpc> at my work, we mostly use mod_perl to cover up the half a second of compilation
17:32:41 <hpc> since it reuses the same compilation for multiple visits
17:33:49 <qfr> hpc you do webdev in Perl?
17:33:53 <hpc> for work
17:33:53 <nzero> Saizan: thanks
17:34:00 <hpc> for fun, i web dev in haskell
17:34:02 <hpc> among other things
17:34:03 <qfr> Do you use any popular framework such as Catalyst?
17:34:10 <hpc> nah, it's in-house
17:34:13 <qfr> Ok
17:34:19 <hpc> and pretty nice, when it isn't fat as hell
17:34:58 <monochrom> your web is so fat, its circumference/diameter = 4?
17:35:55 * edwardk waves hello.
17:35:58 <monochrom> http://spikedmath.com/083.html
17:37:30 <aristid> choosing which library to use for generating hmac codes is hard :/
17:37:57 <edwardk> preflex: xseen copumpkin
17:37:57 <preflex>  copumpkin was last seen on freenode/##logic 8 minutes and 7 seconds ago, saying: meaning you want both not x and x
17:38:10 <copumpkin> edwardk: wassup
17:38:14 <aristid> preflex: seen copumpkin
17:38:14 <preflex>  copumpkin was last seen on #haskell 4 seconds ago, saying: edwardk: wassup
17:38:21 <aristid> preflex: xseen mmorrow
17:38:22 <preflex>  mmorrow was last seen on freenode/#ghc 358 days, 22 hours, 41 minutes and 14 seconds ago, saying: * mmorrow is rtfm'ing
17:38:31 <mikeg> Is there a document that explains instance-importing behaviour? I have a module, A with a data type "Response" and an instance of it for "Serialize" and "JSON". Then I have a module B, with a class "Encodable" with base-classes of Serialize and JSON. But, I only get an Encodable instance for Response if I hand-write "instance Encodable Response" in B.hs
17:38:33 <c_wraith> almost a year :(
17:39:03 <edwardk> clearly, copumpkin is a device for turning cotheorems into ffee.
17:39:18 <dankna> no no
17:39:22 <dankna> you got it backwards
17:39:25 <copumpkin> lol
17:39:25 <dankna> ffee into cotheorems
17:39:34 <c_wraith> mikeg: Instances are in-scope if the module containing them is imported anywhere in your program.
17:39:40 <edwardk> nah, you have to reverse the arrows =)
17:39:42 <Saizan> monochrom: btw, with ghc-pkg unregister -f you don't have to unregister the transitive dependency closure first
17:39:46 <dankna> heh okay :)
17:39:58 <hpc> mikeg: without an instance declaration somewhere, you can't say something belongs to a class
17:40:18 <edwardk> it also explains why unlike any mathematician i've ever met, i can't get him to accept coffee ;)
17:40:19 <hpc> since the only instance you mention is in B.hs...
17:40:40 <monochrom> what? -f stands for "-f FILE" "--package-conf=FILE"
17:41:04 <copumpkin> :P
17:41:09 * copumpkin eats more cheese
17:41:15 <mikeg> Ah, hpc, since the methods I have in Encodable only reference functions in Serialize/JSON, I was thinking the instances wouldn't need to be hand-defined
17:41:15 <copumpkin> I'll take cheese over coffee any day
17:41:16 <Saizan> monochrom: yeah, sorry, --force
17:41:32 <monochrom> well --force causes more trouble, not less
17:41:59 <hpc> mikeg: it can't infer that from just the class declaration
17:42:06 <dolio> copumpkin: Is your last name Costanza?
17:42:17 <hpc> and if one can make an empty instance, why not just write the functions outright?
17:42:23 <qfr> > let accuracy = 1000 in ((sum $ take accuracy $ map (\x -> 1 / x^2) [1..]) * 6) ** 0.5
17:42:23 <aristid> dolio: no.
17:42:24 <lambdabot>   3.1406380562059946
17:42:24 <hpc> you can have multiple class constraints in a type
17:42:31 <qfr> re: <monochrom> your web is so fat, its circumference/diameter = 4?
17:42:35 <qfr> :/
17:42:44 <dolio> aristid: I know.
17:42:47 <qfr> Flexing my hello world muscles
17:43:15 <aristid> dolio: ok, then i must have mistaken a joke for a sincere question.
17:43:36 <qfr> Can you make that even shorter btw?
17:43:37 <edwardk> I wodner how one would attempt to rhyme a costanza
17:43:52 <mikeg> hpc: i don't understand what you mean. here's more or less what I'm using: http://hpaste.org/42963/encodablejson
17:44:06 <Saizan> monochrom: how so? all the packages that depend on the unregistered one gets correctly detected as broken and so ignored
17:44:11 <dolio> @google "I was stripped to the waist, eating a block of cheese the size of a car battery!"
17:44:13 <lambdabot> http://www.theconglomerate.org/weblogs/archives/000909i_was_eating_a_block_of_cheese_the_size_of_a_car_battery.html
17:44:13 <lambdabot> Title: Conglomerate: "I was ... eating a block of cheese the size of a car battery"
17:44:22 <Saizan> s/gets/get/
17:44:26 <copumpkin> mmm
17:44:33 <copumpkin> I want to eat a block of cheese the size of a car battery
17:44:39 <copumpkin> but only if it's good cheese
17:45:09 <monochrom> so as to confuse the user?
17:46:16 <hpc> http://hpaste.org/paste/42963/better_way#p42964
17:46:19 <hpc> mikeg: ^
17:46:43 <Saizan> ghc-pkg list would show them in brackets, iirc
17:46:45 <monochrom> user wantonly goes "ghc-pkg unregister --force base" and then "I haven't touched array, why is it saying Data.Array not found?"?
17:47:24 <mikeg> Mhmm yeah that makes more sense. Originally I wanted to be able to have support for different JSON packages, so I (think) a class was needed then?
17:47:38 <Saizan> well, ok, i wouldn't suggest --force by default, but as a cheaper alternative than unregistering all the deps by hand
17:48:14 <hpc> the only way you would need a class for that
17:48:24 <hpc> is if you needed to change the definition of encode
17:48:55 <hpc> which would be rather silly, since it would be better to just write better instances of the base classes
17:50:15 <monochrom> it is a more cavalier alternative in addition to being cheaper
17:51:14 <mikeg> What do you mean by "better instances"? If I wanted to support, say json and AttoJSON, I would need a different function to convert either type to a string.
17:52:17 <edwardk> the problem there is that Format is a fixed sized thing
17:52:52 <edwardk> no user of the library can add more members to the type
17:53:15 <qfr> Is it possible to make sum $ take n $ map f [1..] any shorter?
17:53:58 <centrinia> You can implement sum . map f as a single fold.
17:54:02 <Saizan> sum $ map f [1..n]
17:54:18 <mikeg> I'm not writing a library. I'm trying to make it easy if I want to use a different JSON package.. I like that I can have derive easily build Text.JSON instances, but if I wanted to use a bytestring? only for a specific type?
17:55:13 <mikeg> Anyways, thanks for the help :) back to work
17:55:35 <nzero> qfr: happstack hello world 6 Mb (2Mb shared) (linux), fyi.  The wai example doesn't work (no such package warp in cabal), which is off-putting.
17:55:39 <edwardk> well, you could make that an MPTC
17:56:14 <qfr> nzero what instructions did you rely on for wai?
17:56:40 <qfr> <Saizan> sum $ map f [1..n]
17:56:40 <nzero> qfr: https://github.com/snoyberg/wai/blob/master/README.md
17:56:41 <qfr> Haha
17:56:44 <qfr> I so didn't think of that
17:56:45 <edwardk> but ultimately you'll run into the 'expression problem'
17:56:59 <qfr> <centrinia> You can implement sum . map f as a single fold.
17:57:01 <qfr> Oh, truwe
17:57:56 <qfr> nzero: import Network.Wai.Handler.Warp (run)
17:57:57 <qfr>  hmm
17:58:30 <qfr> http://hackage.haskell.org/package/wai-0.3.0 nowhere to be seen in wai
17:58:42 <qfr> Oh I didn't know snoyberg wrote wai, too
18:01:34 <nzero> qfr: hmm blog post yesterday: http://docs.yesodweb.com/blog/announcing-wai-0-3/    grep for warp
18:01:38 <qfr> Network.Wai.Handler.DevelServer (run)
18:01:39 <qfr> There is that
18:01:47 <qfr> In wai-devel
18:01:55 <nzero> too new.
18:02:03 <qfr> Oh, hehe
18:02:26 <nzero> no, sorry, I mean it looks like his example hello world is for code that's not fully committed yet.
18:03:58 <ezyang> NoMonoLocalBinds is disabled by GADTs in 7, correct? Maybe a warning should be emitted if they're both around. 
18:06:22 <nzero> qfr: happstack looks fast enough for my purposes, anyway :)  https://gist.github.com/775557
18:06:57 <qfr> Snap reminds me a lot of Ruby on Rails and such, Happstack seemed more bare bone, heh
18:07:13 <qfr> I was immediately scared off by Rails, Django and Catalyst and such
18:07:28 <roconnor> dcoutts: why does cabal install have a --ghc-pkg-options= but runhaskell setup.hs install doesn't?
18:07:35 <qfr> Because they force a certain directory structure and such on you right away but I guess I should give it a try at least once
18:07:45 <qfr> Because it looks like they put a lot of work into this
18:07:52 <qfr> And I liked the Heist Splice stuff
18:07:57 <cdsmithus> qfr: I don't think that's right at all.  And Snap doesn't force a directory structure on anyone.  What made you think so?
18:08:13 <qfr> cdsmithus: I'm sure you can customise it :p
18:08:42 <cdsmithus> qfr: snap init creates a subdirectory called src, and one called resources.... is that what you mean?
18:08:51 <qfr> Stuff like that, yeah
18:09:25 <qfr> For example, in my framework I didn't have logs anywhere close to the static/source directory so I didn't even have to create a .gitignore for that stuff
18:10:35 <quuuux> oh, joy, a 9-module import cycle, involving template haskell for fun and profit
18:10:44 <qfr> Or a huge amount of stuff to read right in the beginning just for the hello world, stretched out over 7+ files I would have wanted to write from scratch really
18:11:16 <ManateeLazyCat> Hmm, failed again.
18:11:17 <cdsmithus> qfr: I think you might be assuming Snap's default project structure is more built-in than it is.  I *always* change it.
18:11:22 <ezyang> "Wheel of Haskell" 
18:11:24 <qfr> cdsmithus: Right
18:13:06 <gwern> ezyang: there are no beginnings or ends to the circular list; but a cons cell arose in Amador...
18:13:48 <edwardk> gwern: =)
18:14:02 <gwern> *thunked in Amador...
18:14:13 <edwardk> gwern: sounds like a bumper sticker
18:14:33 <gwern> edwardk: no no it's a parody of the famous WoT opening lines :(
18:14:39 <edwardk> yes
18:14:44 <ezyang> @remember gwern there are no beginnings or ends to the circular list; but a cons cell thunked in Amador... 
18:14:45 <lambdabot> It is forever etched in my memory.
18:14:46 <edwardk> time = Wheel time
18:15:24 <gwern> time is not a cube?
18:15:46 <quuuux> you have been educated stupid and imperative!
18:16:03 <ezyang> We actually tell our 6.184 students some variant of that :-) 
18:16:19 <edwardk> clearly Wheel t :: Cube
18:17:14 <gwern> variable updates are a lie!
18:17:26 <edwardk> variables don't.
18:23:21 <ezyang> oh, it looks like GHC 7 is sensitive to the order you pass GADTs and NoMonoLocalBinds. That's... unfortunate. 
18:24:07 <ezyang> I can probably even guess why this happens :^) 
18:27:26 <shachaf> ezyang: To the order? Why?
18:28:19 <ezyang> Because -XGADTs desugars to -XGADTs -XMonoLocalBinds, so if it's after NoMonoLocalBinds, MonoLocalBinds gets turned "back on" 
18:28:20 <dolio> Pass?
18:28:27 <dolio> Oh.
18:43:52 <nzero> What's a good haskell approach to maintaining a running top 10 list in a (let's say infinite) stream of values?   Is there a limited-length sorted list, or should I be making  take n $ sort ls work harder for me?
18:45:46 <Axman6> i'd use take 10 . insert, where insert would be the usual implementation of insert for insertion sort
18:46:11 <Fuco> any idea on a simple algorithm faster then long multiplication for multiplying long integers?
18:46:28 <Cale> Fuco: Karatsuba multiplication
18:46:47 <FauxFaux> There's an entire wikipedia article on multiplication algorithms.
18:46:51 <Cale> http://en.wikipedia.org/wiki/Karatsuba_algorithm
18:47:02 <ezyang> Axman6: That won't terminate on an infinite list? 
18:47:51 <Axman6> the list won't be infinite, it'll always be at most 11 elements long
18:48:04 <Axman6> so, it will run in O(1) time ;)
18:48:15 <FauxFaux> Remove the minimum element if the length >10?
18:48:18 <maurer_> nzero: You need to define "maintaining" better. A single variable will remain constant, so you can't have a pure function that outputs this list.
18:48:24 <Cale> Fuco: Of course, if you're talking about Haskell Integer values, just use the built-in multiplications, it's not bad.
18:48:40 <Cale> -s
18:48:41 <ezyang> oh, sliding window. show. 
18:48:43 <ezyang> *sure 
18:48:44 <Fuco> yea, I just want to know how it's done
18:48:59 <Fuco> we're trying to optimise a C homework a bit :P
18:49:01 <Axman6> if it were badm it would have been replaced in gmp
18:49:05 <Axman6> ,*
18:49:08 <ezyang> Fuco: We uses GMP for arbitrary precision. You could check that out. 
18:49:17 <Fuco> after we've fixed 740mb memory leak :D
18:49:25 <ezyang> There's also a simple implementation that doesn't use gmp. 
18:49:35 <ezyang> but the margin is too large to contain it 
18:49:58 <centrinia> Fuco, Karatsuba's method just splits the integers into two (roughly equal sized) pieces and multiplies them with three multiplications.
18:50:13 <aristid> so crypto-api+cryptohash do not have an annoying QuickCheck dependency and seem well-maintained, but who made up that mess of an API
18:50:43 <nzero> Thanks all.  Axman6's insert sort seems like the right thing.  maurer_  A haskell process will tail a log file, and maintain the top 10 slowest requests (say) and give those out periodically, or on request (say by serving http).
18:51:00 <aristid> runPut $ put (hmac (MayKey key) data :: SHA512) -- this is how you do an HMAC SHA512
18:51:50 * hackagebot TrieMap 1.5.0 - Automatic type inference of generalized tries with Template Haskell.  http://hackage.haskell.org/package/TrieMap-1.5.0 (LouisWasserman)
18:52:01 <aristid> why not just hmac sha512 key data or so?
18:52:40 <centrinia> Is there any need for a parallel multiprecision integer library for Haskell?
18:52:55 <Axman6> centrinia: or course
18:52:57 <Axman6> of*
18:53:38 <qfr> There's a need for parallel compilation in cabal :'(
18:53:45 <Axman6> and ghc
18:54:01 <qfr> Is it something that ghc needs to concern itself with?
18:54:04 <aristid> the SHA package on the other hand has a nice API and no QuickCheck dependency but warns that it has poor performance. nano-hmac has an openssl dependency and seems unmaintained
18:54:48 <maurer_> qfr: Yes, given ghc --make.
18:55:00 <aristid> HsOpenSSL requires you to initialize openssl in main, and identifies hashes by strings, so you can't be sure which hashes are there
18:55:16 <Axman6> maurer_: which is the default in ghc7
18:55:56 <maurer_> I'm actually completely unsure as to why it's considered hard to do, but I'm also not familiar with ghc internals.
18:56:11 <aristid> so, probably Crypto is still the best. despite the QuickCheck dependency
18:56:29 <ezyang> aristid: You could ask the Crypto maintainers to drop the QuickCheck dep 
18:56:34 <ezyang> they should have a test binary package anyway. 
18:57:06 <qfr> When I hit C-c in ghci it prints C:\Windows\system32> and then Prelude> repeatedly, while I am unable to type anything properly and when I finally hit enter it says ghc.exe: panic! (the 'impossible' happened) (GHC version 7.0.1 for i386-unknown-mingw32): thread blocked indefinitely in an MVar operation
18:57:26 <qfr> I also had repeated segfaults in cabal today when trying to set up happstack :/
18:57:28 <aristid> hmm, Crypto also uses lists. i wonder if that might be a performance problem.
18:57:32 <aristid> ezyang: yeah i should mail them
18:57:49 <qfr> Is this a known issue or should I report it?
18:58:33 <ezyang> What version are you running? 
19:01:27 <aristid> mail to Crypto people sent. i guess nothing will happen tho :P
19:01:38 <ezyang> aw, you're too pessimistic 
19:02:24 <ezyang> Baller. I keep forgetting to only do builds in the build directory. Time to make a new source checkout :-/ 
19:02:42 <aristid> ezyang: the HMAC API in Crypto is far from optimal, too.
19:03:04 <aristid> you could write a script to remove intermediate files
19:03:35 <aristid> find -name '*.hi' -exec rm {} +
19:03:39 <aristid> or something like that
19:03:40 <ezyang> Maybe I should bug the Galwegians I know into release the one-true-crypto-library. 
19:03:45 <ezyang> This is GHC :-) 
19:04:03 <aristid> ezyang: they have an internal one-true-crypto lib?
19:05:10 <ezyang> "Yet to be written." 
19:05:35 <ezyang> but I'm sure the Cryptol team has most of the pieces. 
19:06:47 <aristid> hmac and a few hashes would suffice already :)
19:13:46 <quuuux> story of my day: git commit -m "make stuff more complicated and break everything" :(
19:14:02 <ezyang> "at least you were using a vcs" 
19:14:22 <aristid> quuuux: you should include the preceding git add command(s)
19:14:42 <quuuux> aristid: by 'everything' I mean -everything-
19:14:49 <ddarius> Isn't that every patch?  I recommend not going beyond an empty source file.
19:15:11 <aristid> quuuux: so git add .
19:15:50 <aristid> or git rm -r .?
19:17:56 <quuuux> aristid: the latter may have been a better option, considering the abominations contained within
19:18:30 <aristid> quuuux: main = main would be nice, too
19:29:03 * hackagebot MaybeT-monads-tf 0.2 - MaybeT monad transformer compatible with monads-tf instead of mtl  http://hackage.haskell.org/package/MaybeT-monads-tf-0.2 (BenMillwood)
19:41:50 <joe6> @hoogle [[a]] -> [a]
19:41:50 <lambdabot> Prelude concat :: [[a]] -> [a]
19:41:51 <lambdabot> Data.List concat :: [[a]] -> [a]
19:41:51 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
19:45:58 <mm_freak> @djinn [[a]] -> [a]
19:45:59 <lambdabot> Error: Undefined type []
19:46:17 <jkoshy> @hoogle replicateM
19:46:18 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
19:46:18 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
19:46:27 <mm_freak> @djinn Monad m => m (m a) -> m a
19:46:27 <lambdabot> -- f cannot be realized.
19:46:37 <ManateeLazyCat> mm_freak: Hi. :)
19:46:42 <mm_freak> you're wrong, lambdabot ;)
19:46:47 <mm_freak> ManateeLazyCat: hey there =)
19:46:57 <ManateeLazyCat> :)
19:47:13 <mm_freak> ManateeLazyCat: i've put some of my project repos onto code.haskell.org
19:47:27 <mm_freak> you're welcome to join, if you want to make improvements
19:48:04 <ManateeLazyCat> mm_freak: I use patch-tag.com , c.h.o break my heart. :)
19:48:13 <ManateeLazyCat> mm_freak: I'm not sure c.h.o stable enough.
19:48:40 <mm_freak> well, it's darcs, so i don't really depend on c.h.o
19:48:55 <mm_freak> what i like about it is that it's very easy to use, because of SSH access
19:49:44 <ManateeLazyCat> mm_freak: I'm working on session manager and IDE, i perhaps won't contribution fastirc in near future. :)
19:50:19 <mm_freak> ManateeLazyCat: fastirc is on c.h.o for a long time now  but my local repos has changed significantly since
19:50:26 <mm_freak> but i'm not done yet
19:50:36 <ManateeLazyCat> But sure, i will write some code if i have time.
19:50:45 <ManateeLazyCat> mm_freak: I need spend some time on Android.
19:51:16 <ManateeLazyCat> mm_freak: your dnscache looks useful, i will find some time merge it in my browser. :)
19:51:23 <mm_freak> for me it's mainly work, which prevents me from hacking much haskell
19:51:50 <mm_freak> yeah  i also found the massdns utility useful sometimes =)
19:51:54 <mm_freak> it comes with dnscache
19:52:36 <ManateeLazyCat> mm_freak: I'm looking for some people join Manatee team, do you interested it ?
19:53:00 <mm_freak> ManateeLazyCat: yes, definitely, but i'm looking forward to finish my own projects first
19:53:25 <ManateeLazyCat> mm_freak: Have you try it? ;p
19:53:49 <ManateeLazyCat> mm_freak: Now it can dynamic update itself in runtime, like elisp for Emacs.
19:53:51 <mm_freak> i've just hat a quick glance at the wiki page =)
19:54:30 <ManateeLazyCat> mm_freak: I'm working on session manager, that's mean, it can restore layout and all status before you exit it.
19:55:02 <mm_freak> what's the status of manatee under windows?
19:55:04 <ManateeLazyCat> mm_freak: After that, i will research how to build a generic IDE framework
19:55:25 <ManateeLazyCat> mm_freak: It's perhaps easy to build on Windows since it use GTK+ code.
19:55:43 <mm_freak> in the foreseeable future i will have to write GUI apps, which need to work under windows
19:55:55 <mm_freak> and i would hate to have to resort to C# =)
19:56:20 <ManateeLazyCat> mm_freak: And DBus
19:56:20 <ManateeLazyCat> mm_freak: But i haven't so much time on Windows, now i just want perfect it's detail.
19:56:20 <ManateeLazyCat> But any patch are welcome. :)
19:56:26 <mm_freak> the last time i tried to build some GUI libraries under windows, i failed miserably
19:56:41 <ManateeLazyCat> gtk2hs is enough. :)
19:56:51 <ManateeLazyCat> But you know, i just like Unix system. :)
19:56:59 <mm_freak> that included gtk2hs ;)
19:57:12 <ManateeLazyCat> Don't use MFC, it's crap. :)
19:57:29 <mm_freak> me too, but i need to do this for work
19:58:10 <ManateeLazyCat> mm_freak: Lucky me, i don't need work for Windows. :)
19:58:23 <dolio> Didn't WFC replace that?
19:58:36 <ManateeLazyCat> mm_freak: I'm work for Android system, and play Manatee after work. :)
19:58:43 <mm_freak> lucky me i can choose my programming language myself at work  only the web stuff needs to be done in PHP, unfortunately
19:59:04 <dolio> Although that acronym sounds like a wrestling/fighting league.
19:59:46 <kfish> hey ManateeLazyCat, does manatee work in xmonad yet?
19:59:54 <mm_freak> world fisting competition?
19:59:56 <ManateeLazyCat> kfish: NO.
20:00:04 <kfish> oh noes!
20:00:13 <ManateeLazyCat> kfish: I haven't time research XMonad code.
20:00:33 <ManateeLazyCat> kfish: XMonad is bad support on floating window.
20:00:55 <kfish> hmm, i have no problems with floating windows in xmonad
20:01:11 <kfish> mplayer, gimp, firefox popups etc.
20:01:20 <kfish> all work fine
20:01:43 <ManateeLazyCat> kfish: Manatee's popup window is special, it's popup, but not *focus* on popup window.
20:02:06 <ManateeLazyCat> kfish: I just want popup window for *display*, but don't want focus.
20:02:23 <kfish> but from X's pov it's just a matter of setting a resource on the window or something isn't it?
20:02:26 <ManateeLazyCat> kfish: And XMonad forcely Manatee focus on popup window, i think that's the problem.
20:02:28 <Axman6> is it a status message, like that say growl on OS X does?
20:02:49 <Axman6> uh, like what*
20:03:37 <ManateeLazyCat> kfish: Yes, perhaps special XMonad config can work,  but i really really haven't time on XMonad, please let me know if any XMOnad hacker know how to do. 
20:04:37 * kfish cabal install manatee
20:04:50 <mm_freak> g'night
20:04:50 <ManateeLazyCat> kfish: And perhaps i missing some properties on Manatee popup window.
20:04:58 <ManateeLazyCat> mm_freak: Good dream. :)
20:05:33 <ManateeLazyCat> kfish: Follow the step i wrote at : http://hackage.haskell.org/package/manatee
20:05:46 <kfish> ManateeLazyCat, i have this in my xmonad.hs:
20:05:49 <kfish> myManageHook = composeAll
20:05:49 <kfish>     [ className =? "Gimp"      --> doFloat
20:05:49 <kfish>     , className =? "Vncviewer" --> doFloat
20:05:49 <kfish>     ]
20:06:01 <kfish> do you set a WM_CLASS for manatee windows?
20:06:23 <ManateeLazyCat> What's the mean WM_CLASS?
20:06:28 <ManateeLazyCat> No
20:06:45 * kfish X knowledge rusty
20:06:53 <kfish> window manager hint for application class, iirc
20:07:56 <ManateeLazyCat> kfish: Can you post your XMonad config?
20:08:43 * ManateeLazyCat cabal install xmonad
20:09:32 * ManateeLazyCat Lunch
20:09:44 * djahandarie cabal install lunch
20:09:46 * djahandarie ???
20:10:31 <ManateeLazyCat> Haha
20:11:18 <ManateeLazyCat> I have test Manatee on KDE, Gnome, XFCE, works well, except XMonad.
20:11:51 <Axman6> it should work best on Xmonad imo
20:12:13 <ManateeLazyCat> Axman6: Well, Manatee don't need WM help, in principle.
20:12:15 <kfish> ManateeLazyCat, xmonad.hs sent to your gmail
20:12:22 <ManateeLazyCat> kfish: Ok, thanks.
20:12:41 <ManateeLazyCat> kfish: I will try your xmonad.hs 
20:13:38 <kfish> if anything doesn't work just comment it out  ;-)
20:14:15 <Axman6> ManateeLazyCat: sure, but manatee can't replace every other app on the system, so it would be nice if you could use it along with other apps, inside xmonad, so get nice tiling everywhere
20:14:20 <ManateeLazyCat> kfish: Ok, thanks. :)
20:14:52 <ManateeLazyCat> Axman6: Yeap, that's true. :)
20:15:13 <ManateeLazyCat> Axman6: I also want to support XMonad, just too busy. :)
20:15:34 <brweber2> can anyone help with this error?  I've installed haskell 7.0.1 debian binary.  When I run ghci it can't find libgmp.so (I have /usr/lib/libgmp.so.3 but no /usr/lib/libgmp.so)
20:15:38 <brweber2> Loading package integer-gmp ... <command line>: can't load .so/.DLL for: gmp (libgmp.so: cannot open shared object file: No such file or directory)
20:15:51 <brweber2> I don't have permission to create soft links in /usr/lib
20:15:58 <brweber2> any ideas?
20:16:52 <ManateeLazyCat> kfish: Switch XMonad for try, thanks. :)
20:17:19 <djahandarie> lol ERC...
20:17:35 <kfish> brweber2, ask root to run ldconfig?
20:18:02 <brweber2> kfish no root and no sudo :(
20:18:19 <aristid> brweber2: try LD_LIBRARY_PATH
20:20:25 <brweber2> aristid it is not set in my env or are you suggesting setting it explicitly? 
20:20:42 <aristid> brweber2: yes, set it in your env
20:21:06 <brweber2> aristid brilliant!  Many thanks.
20:21:28 <aristid> does it work now?
20:21:42 <john_r_watson> does laziness/(ghc smartness) cause
20:21:42 <john_r_watson> map (3+) $ map (2+) $ map (1+) [1..10]
20:21:42 <john_r_watson> to perform like:
20:21:45 <john_r_watson> ((3+) . (2+) . (1+)) [1..10]
20:21:48 <john_r_watson> ?
20:21:59 <Axman6> yes, there's a RULE that implements that
20:21:59 <john_r_watson> map ((3+) . (2+) . (1+)) [1..10]
20:22:01 <mauke> that would be deforestation/fusion
20:22:20 <john_r_watson> sweetness - thanks
20:22:39 <Axman6> RULE .. forall f g xs. map f (map g xs) = map (f.g) xs or something similar
20:23:02 <john_r_watson> is this GHC or Haskell?
20:23:08 <Axman6> GHC
20:23:12 <john_r_watson> gothca
20:23:24 <mauke> did you mean: gothica
20:23:35 <brweber2> aristid Yes, that did the trick.  Thanks.
20:23:45 <john_r_watson> mauke: :) gotcha
20:24:31 <aristid> brweber2: you owe me gratefulness for life! lol
20:24:53 <john_r_watson> Has anyone read Hughe's paper on using Arrows? afp-arrows.pdf: 
20:24:53 <john_r_watson> http://www.cse.chalmers.se/~rjmh/afp-arrows.pdf 
20:25:20 <john_r_watson> *Hughes'*
20:25:52 <brweber2> aristid you certainly saved me several hours of frustration :) I'll look for several small green martians that can be eternally grateful...
20:26:08 <BMeph> john_r_watson: Yes, someone has done it, I'm sure.... ;)
20:26:20 <john_r_watson> BMeph: well I'm having trouble running a particular example from there
20:27:26 <BMeph> john_r_watson: I believe you.
20:29:51 <john_r_watson> BMeph: well my dilemma is I'd rather not paste all his code leading up to the example.  It's essentially creating an instance of ArrowChoice for "stream functions" of type ([f] -> [g]), and implementing a mapA function (like map for Arrows as you'd guess)
20:39:12 <Axman6> ManateeLazyCat: any luck with Xmonad?
20:39:53 <ManateeLazyCat> Axman6: No, still can't work.
20:40:35 <ManateeLazyCat> kfish: I have try `manateeHook = composeAll [className =? "manatee" --> doFloat]", can't work
20:40:45 <ManateeLazyCat> kfish: And make problem become worse.
20:41:04 <ManateeLazyCat> kfish: Manatee can works well, except when you press "Alt + f" in it.
20:41:39 <ManateeLazyCat> kfish: Press "Alt + f" will popup new *search* window to *display*. Then XMonad focus input on *search* window, and not *main* window.
20:42:00 <ManateeLazyCat> kfish: My design is popup *search* window and still focus user's input on *main* window.
20:42:32 <ManateeLazyCat> kfish: So i need some XMOnad config that can display popup *search* window but not *focus* it.
20:42:42 <ManateeLazyCat> Then Manatee should be work in XMOnad.
20:43:17 <kfish> right
20:43:43 <kfish> i was just playing with it, and it seems that (using xmonad) i need to always click on the manatee status bar for input to go to manatee
20:44:25 <kfish> hmm, .... last time i had a similar problem, i think i just wrote the app to accept input in any window
20:44:26 <ManateeLazyCat> kfish: You can type something in "stratup page" to open tab, and press Alt + f in new tab will popup wndow.
20:45:06 <ManateeLazyCat> kfish: If you want input in Manatee after Alt + f, you need do "windows W.focusDown" first.
20:45:11 <ddarius> You can use xprop to tell you what WM_CLASS etc are being assigned to the various windows of manatee.
20:45:40 <ManateeLazyCat> kfish: Some like, i press Alt + F, and then press "C-q n" (windows W.focusDown) to focus main window.
20:46:50 * ManateeLazyCat Reading xprop manual...
20:50:56 <ManateeLazyCat> ddarius: So you mean, i use xprop with WM_CLASS to assigned popup window with Manatee's main window? 
20:52:40 <ddarius> ManateeLazyCat: You should be able to set WM_CLASS with some GTK function.  I was just suggesting using xprop to investigate which properties are associated with each window.  For example, WM_CLASS and WM_STATE and such.
20:52:53 <jmcarthur> :t maybe empty pure
20:52:54 <lambdabot>     Ambiguous occurrence `empty'
20:52:55 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
20:52:55 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:55:0-22
20:53:02 <jmcarthur> :t maybe Control.Applicative.empty pure
20:53:03 <lambdabot> forall (f :: * -> *) a. (Alternative f) => Maybe a -> f a
20:53:20 <jmcarthur> why is that of all things not in base somewhere :\
20:53:37 <jmcarthur> not a big deal to write myself of course. i just would have expected to see that
20:53:55 <ddarius> jmcarthur: The monad equivalent isn't either.
20:54:06 <Axman6> hmm, how does having Applicative.empty function make sense?
20:54:16 <ddarius> Axman6: Alternative.
20:54:18 <jmcarthur> aw. i was going to look for that next
20:54:31 <Axman6> ah, right
20:55:39 <ManateeLazyCat>  xprop | grep WM_CLASS got : WM_CLASS(STRING) = "manatee", "Manatee"
20:56:07 <ddarius> ManateeLazyCat: You can click on multiple windows, but I imagine all your windows are going to have the manatee class.
20:56:49 <ManateeLazyCat> ddarius: Yes, `main` and `popup` window is same: WM_CLASS(STRING) = "manatee", "Manatee"
20:57:23 <copumpkin> how can I get a FunPtr from a function (that I'm FFI binding to, for a FinalizerPtr)?
20:57:24 * djahandarie recalls WM_TRANSIENT_somethingoranother
20:57:59 <pastorn> copumpkin: IORef (IO ()) ?
20:58:17 <mauke> preflex: ? ffi
20:58:18 <preflex>  http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi.html
20:58:25 * hackagebot network-enumerator 0.1 - Enumerators for network sockets  http://hackage.haskell.org/package/network-enumerator-0.1 (JohnMillikin)
20:58:27 <ddarius> ManateeLazyCat: There are other properties that may be relevant such as WM_HINTS.
20:58:34 <copumpkin> type FinalizerPtr a = FunPtr (Ptr a -> IO ())
20:58:37 <copumpkin> I need one of those
20:58:52 <copumpkin> I have a Ptr a -> IO ()
20:59:17 <ddarius> copumpkin: foreign import dynamic?
20:59:22 <pastorn> copumpkin: check the sources of something that uses callbacks, like GLUT
20:59:56 <ddarius> Though that seems odd for this particular use.
20:59:56 <mauke> copumpkin: foreign import wrapper
20:59:59 <copumpkin> yeah
21:00:10 <ddarius> mauke: That's the one.
21:00:39 * ddarius returns to knitting.
21:00:51 <pastorn> ddarius: knitting what?
21:02:05 <copumpkin> ddarius, mauke: thanks
21:02:16 <kfish> ManateeLazyCat, http://standards.freedesktop.org/wm-spec/wm-spec-latest.html#id2541720
21:03:06 <ManateeLazyCat> kfish: Thanks, looking...
21:07:17 <ManateeLazyCat> kfish: I think some solution like this: set manatee popup window with new class name "manatee-popup", then make XMonad always ignore focus window that WM_CLASS match "manatee-popup"
21:07:29 * ManateeLazyCat Lunch in 10 minutes.
21:09:23 <kfish> ManateeLazyCat, perhaps, but it may be easier for you to just accept input in any window :)
21:10:17 <ManateeLazyCat> kfish: Good idea, i need think about it. :)
21:20:25 <jmcarthur> what is with haskellers and knitting?
21:20:53 <djahandarie> I don't know but it's kind of weird
21:21:09 <djahandarie> Not the knitting, but how many people do it
21:22:39 * ManateeLazyCat Session manager failed again, perhaps direction is wrong....
21:28:47 <ddarius> djahandarie: Knitting and crochet have actually been rather popular in the last ten to twenty years.  What's more intriguing is the kind of people you find that do it.  More people than you'd expect, including many people you wouldn't expect, do one or the other or both.
21:29:19 <Philippa> enough so that I have a dating site profile that states I don't knit
21:30:59 <sbrtgr> to pass the time, lispers have arguments, schemers smoke the weed, and haskellers knit (from today's observations)
21:34:24 <kfish> knit knots?
21:34:45 * kfish not <$> knit knots
21:35:50 <Philippa> yarn is the new unicycle?
21:36:42 <djahandarie> Haskell is now also an introduction into knot theory... damn mathematicians/knitters!
21:36:52 <ddarius> Philippa: No.
21:37:24 * Axman6 proposes a new haskell web framework: Knitting on Unicycles
21:37:32 <BMeph> Yarnicycle! ;
21:37:40 <Axman6> haha
21:37:55 <ManateeLazyCat> kfish: Good news, Manatee works perfect in XMOnad, don't need change XMonad config.
21:38:09 <kfish> ManateeLazyCat, great!
21:38:22 * ManateeLazyCat pasted "three lines fix XMonad problem." at http://paste2.org/get/1188131
21:38:23 <kfish> how did you do it?
21:38:31 <ManateeLazyCat> kfish: I use your idea. :)
21:38:53 <kfish> yay!
21:38:57 <kfish> that was fast!
21:39:24 <ManateeLazyCat> kfish: When popup window accept input, don't do anything, propagate event to main window.
21:39:44 <ManateeLazyCat> kfish: Just three lines fix problem : http://paste2.org/get/1188131
21:40:04 <ManateeLazyCat> kfish: This solution, don't need any change of XMonad.
21:40:32 <djahandarie> anythingWindow `on` keyPressEvent . tryEvent . fmap (lift . widgetPropagateEvent frame) $ serializedEvent
21:40:35 <djahandarie> One line!
21:41:06 <ManateeLazyCat> djahandarie: Hehe, i perfect to clean code, easy to understand, no more tips. :)
21:41:14 <ManateeLazyCat> s/perfect/prefer to write
21:41:36 <ManateeLazyCat> kfish: Thanks for your great idea, i haven't that idea before. :)
21:41:50 <ManateeLazyCat> s/haven't/haven't think
21:41:57 <ManateeLazyCat> daemon input helper
21:42:20 <ManateeLazyCat> s/daemon/damn lol
21:42:41 <kfish> ManateeLazyCat, glad to hear it worked, i hope more people can use manatee :)
21:42:42 <cdsmithus> Is there a package anywhere with 'instance Convertible Text SqlValue' and 'instance Convertible SqlValue Text'?  (SqlValue is from HDBC)
21:42:58 <ManateeLazyCat> kfish: I will release new version soon. :)
21:43:10 <ManateeLazyCat> kfish: Thanks again! :)
21:43:46 <ManateeLazyCat> Haha, drop Gnome now, use fastest XMOnad as my primary environment. :)
21:44:25 <ManateeLazyCat> kfish: I will write your name in my Acknowledge, can you give me some information ?
21:46:39 <kfish> heh, i didn't write anything :)
21:47:18 <ManateeLazyCat> kfish: But you give me inspiration. :)
21:48:39 <ManateeLazyCat> Very very good, Manatee integrated with XMOnad, fastest environment for test Manatee.
21:49:22 <ManateeLazyCat> kfish: Conrad Parker is okay?
21:49:31 <kfish> ManateeLazyCat, sure, that's me
21:49:39 <ManateeLazyCat> kfish: Thanks. :)
21:51:58 <ManateeLazyCat> I feeling Manatee's speed in XMonad, much much faster than Gnome or any other DE
21:59:55 <ManateeLazyCat> juhp: I just build a patch make Manatee can works in XMOnad. :)
22:00:03 <copumpkin> if a foreign function expects a pointer to a c struct (without providing convenience methods for building one) as a parameter
22:00:11 <juhp> ManateeLazyCat: awesome!
22:00:22 <copumpkin> should I be using alloca and poking it into the temporary buffer and passing it in (assuming it doesn't get retained)
22:00:26 <copumpkin> or is there a nicer way to deal with that?
22:00:29 <ManateeLazyCat> juhp: Inspire from kfish's idea. :)
22:01:24 <mauke> copumpkin: you should use a tool like c2hs or hsc2hs to define a Storable instance
22:02:14 <copumpkin> mauke: hmm, good idea
22:02:22 <copumpkin> mauke: which of those two is more pleasant to use?
22:02:49 <mauke> probably c2hs but I've only used hsc2hs
22:05:01 <joyfulgirl> So here of late, if I try to recompile xmonad (0.9.2) or load my config into ghci, I get module-not-found errors for both xmonad-contrib modules and even XMonad itself
22:06:00 <joyfulgirl> Unfortunately, I'm not quite sure when exactly this started. Related info: I'm on Arch, and my current ghc is 6.12.3, and ghc-pkg check doesn't report any errors
22:06:02 <joyfulgirl> Thoughs?
22:06:38 <joyfulgirl> Or thoughts, rather?
22:06:58 <kfish> joyfulgirl, what does 'ghc-pkg check' report?
22:07:05 <joyfulgirl> kfish: Nothing at all
22:07:20 <kfish> oh yeah you said that already, sorry
22:07:29 <joyfulgirl> s'cool
22:08:45 <kfish> is everything running from cabal or from arch?
22:08:54 <joyfulgirl> From arch packages
22:09:18 <djahandarie> ghc-pkg describe xmonad should tell you the exposed modules
22:11:21 <joyfulgirl> djahandarie: All seem to be present and accounted for \-:
22:11:32 <djahandarie> It could be some weird inconsitency between user and global. Try adding --user 
22:13:23 <joyfulgirl> djahandarie: Hrm, with --user it can't find the package. Interesting
22:13:32 <djahandarie> That is what should happen
22:14:06 <djahandarie> If it was in --user and --global that could be a problem though
22:14:33 <joyfulgirl> ah
22:17:02 <djahandarie> joyfulgirl, try ghci -iDIR  where the dir is what is listed in ghc-pkg describe xmonad
22:21:02 <joyfulgirl> No joy, I'm afraid
22:24:38 <djahandarie> joyfulgirl, pretty weird. Something is either lying somewhere, or ghc is unable to load a file or something and isn't erroring
22:25:04 <joyfulgirl> I suppose so \-:
22:25:07 <djahandarie> Maybe someone with more experience with arch/ghc-pkg could help
22:25:44 <joyfulgirl> Yeah...I asked in #archlinux as well, but no luck yet. Thanks for your help, though (-:
22:26:11 <djahandarie> Yep
22:28:10 <joyfulgirl> Well, this is interesting. It seems to be searching for Run.{l,}hs, but I've only Run.hi
22:32:15 <ManateeLazyCat> Most improve in new version Manatee : works in XMonad! Enjoy! :)
22:33:01 * hackagebot manatee-core 0.0.8 - The core of Manatee.  http://hackage.haskell.org/package/manatee-core-0.0.8 (AndyStewart)
22:33:03 * hackagebot manatee-anything 0.0.8 - Multithread interactive input/search framework for Manatee  http://hackage.haskell.org/package/manatee-anything-0.0.8 (AndyStewart)
22:33:05 * hackagebot manatee-browser 0.0.8 - Browser extension for Manatee.  http://hackage.haskell.org/package/manatee-browser-0.0.8 (AndyStewart)
22:33:07 * hackagebot manatee-editor 0.0.8 - Editor extension for Manatee.  http://hackage.haskell.org/package/manatee-editor-0.0.8 (AndyStewart)
22:33:09 * hackagebot manatee-filemanager 0.0.8 - File manager extension for Manatee.  http://hackage.haskell.org/package/manatee-filemanager-0.0.8 (AndyStewart)
22:33:09 <ManateeLazyCat> Other little improve, include : fix immortal render process problem, improve message/status update handle (move to local)
22:33:18 <ManateeLazyCat> Sorry, all. :)
22:33:52 <Axman6> why do they all need to be updated? i thought those changes would only affect one package
22:34:02 <ManateeLazyCat> I plan to release new version after "session manager" finish, but i think it's better release it now since Manatee can works in XMOnad.
22:34:11 * hackagebot manatee-pdfviewer 0.0.8 - PDF viewer extension for Manatee.  http://hackage.haskell.org/package/manatee-pdfviewer-0.0.8 (AndyStewart)
22:34:12 <ManateeLazyCat> Axman6: DBus protocol change.
22:34:13 * hackagebot manatee-mplayer 0.0.8 - Mplayer client extension for Manatee.  http://hackage.haskell.org/package/manatee-mplayer-0.0.8 (AndyStewart)
22:34:15 * hackagebot manatee-ircclient 0.0.8 - IRC client extension for Manatee.  http://hackage.haskell.org/package/manatee-ircclient-0.0.8 (AndyStewart)
22:34:17 * hackagebot manatee-processmanager 0.0.8 - Process manager extension for Manatee.  http://hackage.haskell.org/package/manatee-processmanager-0.0.8 (AndyStewart)
22:34:19 * hackagebot manatee-imageviewer 0.0.8 - Image viewer extension for Manatee.  http://hackage.haskell.org/package/manatee-imageviewer-0.0.8 (AndyStewart)
22:35:21 * hackagebot manatee-reader 0.0.8 - Feed reader extension for Manatee.  http://hackage.haskell.org/package/manatee-reader-0.0.8 (AndyStewart)
22:35:23 * hackagebot manatee-curl 0.0.8 - Download Manager extension for Manatee.  http://hackage.haskell.org/package/manatee-curl-0.0.8 (AndyStewart)
22:35:25 * hackagebot manatee-terminal 0.0.8 - Terminal Emulator extension for Manatee.  http://hackage.haskell.org/package/manatee-terminal-0.0.8 (AndyStewart)
22:35:27 * hackagebot manatee-template 0.0.8 - Template code to create Manatee application.  http://hackage.haskell.org/package/manatee-template-0.0.8 (AndyStewart)
22:35:29 * hackagebot manatee 0.1.8 - The Haskell/Gtk+ Integrated Live Environment  http://hackage.haskell.org/package/manatee-0.1.8 (AndyStewart)
22:35:47 <ManateeLazyCat> Axman6: Now core communications protocol still in developing, if extension package older than core package, perhaps break though they're not depend each other.
22:36:17 <Axman6> :\ fair enough
22:36:57 <ManateeLazyCat> Axman6: This situation will change once manatee-core stable enough. 
22:37:08 <Axman6> ok
22:37:12 <djahandarie> In reality hackagebot should group these things
22:37:13 <ManateeLazyCat> Then manatee-core won't touch, just write application code 
22:38:33 <ddarius> djahandarie: The source is somewhere.
22:39:19 <djahandarie> That is most likely true.
22:40:07 <ManateeLazyCat> Current is manatee-0.1.8, 0.1.9 will add "session manager", 0.2.0 will add "IDE framework" (first support Haskell)
22:40:30 <ManateeLazyCat> 0.2.1 support Mail-Client
23:16:59 <McManiaC> I'm getting alot of those "illegal ! at.. use BangPatterns" error messages when trying to install stuff of hackage with the latest ghc (from darcs) - did they change anything there or is my build broken?
23:18:37 <McManiaC> and what about those "Function .. has one call pattern, but the limit is 0" messages? never saw them before :)
23:21:54 <ManateeLazyCat> Why "python /home/andy/localproxy-2.0.0/proxy.py &" add in ~/.xinitrc can't work? Any tips?
23:26:43 <mlh> ManateeLazyCat: ~/.xsession-errors might have a clue
23:28:39 <ManateeLazyCat> mlh: Thanks.
