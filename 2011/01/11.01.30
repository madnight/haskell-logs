00:21:03 <Veinor> i think i'm going to try to get ghc and ghc7 on the same system
00:21:09 <Veinor> and use ghc7 when i can, ghc6 when i have to
00:22:42 <Saizan> that should be quite straightforward, at least on linux, thanks to the versioned executable names
00:23:08 <Veinor> yeah, that shouldn't be too difficult; it's cabal that i'm worried about.
00:23:20 <Saizan> it has a -w flag
00:23:33 <Veinor> which does?
00:23:51 <Saizan> cabal install -w ghc-7.0.1 will use ghc-7.0.1
00:24:03 <Veinor> ah
00:24:28 <Veinor> and i assume it keeps that separate from the ghc6 install?
00:24:56 <Saizan> yep, both metadata and lib files live in versioned directories
00:25:01 <Veinor> awesome.
00:25:39 <Saizan> (documentation doesn't by default, iirc, you can change that in ~/.cabal/config if you want)
00:26:29 <Veinor> bleh, i hate stuff that compiles against base 3
00:26:47 <Veinor> it fills my cabal install with warnings that aren't actually important
00:27:15 <Heffalump> they will be important..
00:27:55 <Veinor> well, some of them, like psqueue, don't actually depend on base 3, they just depend on base
00:28:52 <ivanm> with graphviz, I currently go through two stages when parsing Dot code: pre-processing to get rid of comments, etc. and then the actual parsing
00:29:11 <ivanm> however, I found out the other day that the pre-processing takes twice as long as the actual parsing and around 4 times the memory :s
00:29:28 * djahandarie was just reading ivanm's blog post about this
00:29:31 <Veinor> :S
00:29:41 <ivanm> djahandarie: that's weird, because I haven't blogged about that... :p
00:29:57 <djahandarie> Not that exact issue :P
00:30:03 <ivanm> heh
00:30:16 <ivanm> not sure if it's possible to merge some of the preprocessing into the actual parsing; it will probably screw up too much of the logic :s
00:31:30 <ion> ivanm: He’s using the wayforwardmachine at archive.org.
00:31:38 <ivanm> lol
00:32:10 <ivanm> I was thinking of blogging about it, but since planet is down I wasn't sure if I would actually receive many (hopefully helpful) responses about it :/
00:33:52 <Saizan> i'd rather make the preprocessing faster in isolation than merge it with the parsing
00:34:21 <ivanm> Saizan: already tried that; can't seem to work out anyway of doing it
00:34:38 <ivanm> (unless I try scrapping the whole "pre-process using parsing" approach)
00:35:20 <ivanm> here's the code (well, a slightly out of date one but anyway): http://hackage.haskell.org/packages/archive/graphviz/2999.11.0.0/doc/html/src/Data-GraphViz-PreProcessing.html
00:35:47 <ivanm> I actually found this out because my current Text-based branch uses more memory than the old String-based code and thus the RTS ran out of stack space on one sample :/
00:37:00 <Rotaerk> there a standard name for a function that drops a particular component of a tuple? don't see anything with the signature (a,b,c) -> (b,c) in hoogle
00:37:06 <ivanm> Rotaerk: no
00:37:22 <ivanm> there isn't really any functions for dealing with tuples with more than two elements
00:37:34 <Rotaerk> k
00:37:35 <ivanm> with the exception of [un]zip
00:37:45 <ivanm> and they're specialised for each size
00:37:55 <ivanm> Rotaerk: it may be possible to use TH to do something like that though
00:39:17 <Saizan> if you got a stack overflow that sounds like a bug
00:40:26 <accel> window 4
00:40:38 <ivanm> huh, actually, the large difference appears to be mainly only for Text, not the old String one...
00:41:52 <ivanm> Saizan: here's the space profiling for the old String version: http://ompldr.org/vNzdudw
00:42:07 <ivanm> the Text-based one has a much more noticeable peak for the first bit
00:42:24 <ivanm> quite possible that there's a space leak or something (I hadn't actually compared them before :/)
00:43:05 <Saizan> are you using strict Text?
00:43:40 <ivanm> no, lazy
00:43:57 <ivanm> does strict text make sense for parsing purposes?
00:44:21 <Bynbo7> you're parsing the Text?
00:44:28 <Bynbo7> if so, I'd say no
00:44:50 <ivanm> yeah, what I figured
00:45:14 <Saizan> you're doing a lot of concat, so strict text would be bad
00:45:45 <Bynbo7> i'd recommend looking at something like blaze-builder
00:45:55 <ivanm> I'll hpaste the Text version of that file up (since c.h.o is down, stopping me from darcs pushing)
00:46:00 <ivanm> Bynbo7: for _parsing_?
00:46:06 <Bynbo7> it takes care of chunking things into nice sized chunks when creating bytestrings
00:46:16 <Veinor> Saizan: so can i just download ghc7, compile, and then set up aliases for ghc6/ghc7 and such?
00:46:17 <Bynbo7> well... what are you concatting?
00:46:37 <ivanm> http://hpaste.org/43431/preprocessing_for_graphviz
00:48:16 <Bynbo7> if you're building Text, then you should use Builder
00:48:18 <Saizan> Veinor: i'd use a binary package rather than compiling ghc7 myself, but yeah (i don't actually bother setting aliases, but it makes sense)
00:48:42 <Veinor> yeah.
00:48:48 <ivanm> Bynbo7: hmmm, maybe...
00:48:58 <ivanm> didn't think about parsing Builder values
00:49:00 <Veinor> and then make it easier to say cabal install -w ghc-7.0.1
00:49:34 <Saizan> ivanm: you paste Text and produce a Builder
00:49:56 <ivanm> "paste"?
00:50:00 <Saizan> *parse
00:50:09 <ivanm> but yeah, I've used Data.Text.Lazy.Builder before (or whatever the module is called)
00:50:32 <Saizan> lots of singleton chunks could really kill memory-wise
00:50:39 <Bynbo7> yeah
00:50:59 <Bynbo7> hmm, it would be nice if there was a BuilderT or something
00:51:00 <Veinor> okay, for some reason installing oeis takes massive amounts of ram
00:51:09 <Veinor> so i'm going to let that run overnight
00:51:18 <Bynbo7> so that it could incrementally create the Text balue
00:51:19 <Bynbo7> v*
00:51:28 <Saizan> ?
00:51:52 <Saizan> so, something other than WriterT Builder ?
00:51:59 * ivanm suddenly realises that when he switches to a State-based parser for the main graphviz stuff, there  may be problems with re-using those parsing combinators for pre-processing... :/
00:55:39 <RyanRN> Veinor: I personally like to use aliases that tweak my PATH.  Then I can just do "switch_ghc7" followed by "cabal install XX"
00:56:15 <Veinor> that makes sense too
00:56:18 <Veinor> http://s3.amazonaws.com/data.tumblr.com/tumblr_lftw3o0QK11qee68zo1_1280.png?AWSAccessKeyId=0RYTHV9YYQ4W5Q3HQMG2&Expires=1296464968&Signature=rWxAXS00BOOe0BHJprxSou4vgns%3D
00:56:35 <RyanRN> I have a cabal question for people.  Does anyone know how to get cabal to link a static foreign library (.a file)?  GHC will handle it fine when passed on the command line…. 
00:57:26 <Saizan> yeah, ld sucks if you don't have enough memory, expecially with ghc-produced code
00:57:34 <Saizan> gold is quite better if it works for you
00:57:36 <Bynbo7> --ghc-flags="-i... -l...?"?
00:57:54 <Veinor> my question is, why the hell does oeis require so much ram to link
00:57:59 <RyanRN> Sadly I often find myself randomly trying things with cabal to try to achieve a non-standard behavior….
00:58:20 <RyanRN> Bynbo7: So you would try to get the effect via the GHC-Options: entry in the .cabal file?
00:58:23 <Saizan> extra-libraries: iirc
00:59:06 <Saizan> mh, maybe not necessarily statically if it finds a .so too, though
00:59:07 <RyanRN> Saizan: it's not a globally installed libXYZ.so file… it's a .a file that is built by the cabal package (I'm wrapping a C lib that needs its own makefile because it builds assembly code, etc).
00:59:46 <RyanRN> I tried extra-libraries, plus adding the "lib" prefix, plus extra-lib-dirs… but it didn't seem to work for the .a file
01:00:03 <Saizan> try looking at the zlib package
01:00:16 <Saizan> on windows it builds the C zlib from sources
01:00:51 <RyanRN> Ok, thanks, looking now
01:01:20 <RyanRN> interesting… it has a conditional and either uses the systems libz.so on non-windows systems
01:01:30 <RyanRN> or it builds it directly with "c-sources"
01:01:42 <RyanRN> So it doesn't invoke a non-cabal makefile.
01:02:10 <RyanRN> Yes, I wish I could use the "easy" solution of just telling cabal the names of the .c and .s files and having it work.  
01:02:19 <RyanRN> But I haven't got it building like that yet.
01:02:19 <Saizan> there's also ld-options:
01:02:56 <RyanRN> Where do those appear anyway?   I do cabal build —verbose… and the  final GHC command line it executes doesn't seem to mention them!
01:04:15 <Saizan> maybe when it builds the .a for the lib? not sure if it calls ld though, maybe just ar..
01:06:00 <RyanRN> Does it use ld-options when building a library?
01:10:26 <Saizan> check the -v (or -v2..3) log
01:10:52 <RyanRN> If I directly include the foo.a in GHC-Options for both the executable and the library then it builds ok...
01:11:27 <RyanRN> But I wanted to link it with the library so that the end user wouldn't have to know about it — I don't want them to have to link it explicitly!
01:13:15 <RyanRN> But thanks Saizan, BynBo7 for listing the mechanisms you know of… I'll keep hacking
01:13:54 <Saizan> is your executable depending on the lib, or not?
01:14:11 <Saizan> (that works only in Cabal 1.8.0.2+)
01:15:06 <RyanRN> Yep it is… in this case the executable is in the same package and just tests/benchmarks the librkary… I need to explicitly test the other scenario of a separate package that depends on the library
01:15:25 <RyanRN> I'm running 1.8.0.6
01:16:33 <RyanRN> The key seems to be that cabal *does* call "/usr/bin/ld" to link the library (HS_.o file)
01:16:38 <RyanRN> BUT it doesn't respect ld-options
01:19:03 <Saizan> i mean, does it list the lib in build-depends: ?
01:20:40 <RyanRN> ah, good point, I think I forgot that
01:21:00 <RyanRN> hmm… how would it name it there?
01:21:12 <edwardk> i need a good name for a category like thing that only provides the associative law
01:21:28 <RyanRN> But nevertheless, I seem to have a separate problem before I get to that point.  I think along the lines of this thread:
01:21:56 <RyanRN> http://www.haskell.org/pipermail/cabal-devel/2007-April/000507.html
01:23:05 <Saizan> you use the name of the package
01:23:57 <RyanRN> ok, it just seemed a bit circular since the executable is also part of the same named package ;-)
01:24:10 <RyanRN> But I guess it implicitly means the "library portion of package X"
01:24:27 <Bynbo7> edwardk: ... monid?
01:24:55 <edwardk> Bynbo7: i have more than one object
01:25:03 <ivanm> edwardk: you do? :o
01:25:04 <ivanm> :p
01:25:09 <Bynbo7> actually, monod, monoid had an identity i, and an associative operator o... so monoid - i = monod :P
01:25:27 <edwardk> *groan*
01:25:31 <Bynbo7> =D
01:25:42 <Bynbo7> i think that's my second CT joke ever
01:26:04 <dolio> The identity of a monoid is usually denoted 'e', though.
01:26:14 <Bynbo7> shhh
01:26:30 <Bynbo7> i don't study CT
01:26:44 <dolio> That isn't category theory.
01:27:07 <Bynbo7> ok, I'm not big into maths then
01:27:11 <edwardk> i' m tempted to just call it a categoroid and forget about it
01:27:16 <edwardk> but i think that name has been taken
01:28:44 <edwardk> aha semigroupoid =)
01:28:46 <edwardk> found it
01:28:54 <edwardk> http://en.wikipedia.org/wiki/Semigroupoid
01:29:01 <Bynbo7> obviously
01:29:12 <dolio> That isn't a groupoid without identities?
01:29:17 <edwardk> now i can have a unitless ancestor to Control.Category
01:29:19 <ivanm> @hoogle (Monoid m) => [m] => m
01:29:19 <lambdabot> Parse error:
01:29:20 <lambdabot>   --count=20 "(Monoid m) => [m] => m"
01:29:20 <lambdabot>                                ^
01:29:24 <edwardk> semigroup = monoid without identity
01:29:24 <ivanm> @hoogle (Monoid m) => [m] -> m
01:29:24 <lambdabot> Data.Monoid mconcat :: Monoid a => [a] -> a
01:29:25 <lambdabot> Prelude head :: [a] -> a
01:29:25 <lambdabot> Prelude last :: [a] -> a
01:29:35 <edwardk> semigroupoid = small category without identity arrows
01:30:37 <edwardk> now i just need an operator for it
01:31:08 <dolio> I guess semigroup is the real bad name, then.
01:32:10 <dolio> Monoid is a bad name, too, of course, following that scheme.
01:32:17 <edwardk> i need an operator that looks like . those are in short supply
01:32:59 <edwardk> .. is syntax only punctuation i have left is ?
01:33:10 <edwardk> which is a strange composition operator
01:33:13 <Saizan> °
01:33:21 <edwardk> not willing to turn to unicode
01:34:00 <ion> ∘ ≠ °
01:34:28 <Veinor> edwardk: `o` ? (conflicts with haxml though)
01:34:33 <ion> · •
01:34:40 <Bynbo7> <^^^^^>
01:34:45 <edwardk> veinor: not really worried about haxml. different user base ;)
01:34:54 <edwardk> `o` works for me
01:35:05 <edwardk> plus i doubt they'll be using Data.Semigroupoid ;)
01:35:09 <ivanm> looks like that surrealist screaming painting... :p
01:35:31 <edwardk> ion: that looks like a depiction of a planet with a small moon
01:35:50 <Veinor> haxml calls it 'the irish combinator' iirc
01:36:32 <ion> ·•⚫●⬤
01:38:24 <edwardk> sweet, now i have semigroupoids for kleisli and cokleisli arrows. thanks =)
01:40:14 <edwardk> and more i can fiddle with them when setting up an indexed bind instance for indexed writer, etc.
01:40:29 <ion> > let (·) = (+); (•) = (-); (⚫) = (*); (●) = (/); (⬤) = (**) in 4⬤5●6⚫7•8·9
01:40:30 <lambdabot>   1195.6666666666665
01:41:23 <edwardk> veinor: that worked nicely
01:41:52 <edwardk> Veinor: surprised i didn't think of it. i use it for instances of my composition class at the type level all the time
01:44:25 <edwardk> is there a static arrow category lying around some place convenient?
01:44:29 <edwardk> f (a -> b) ?
01:54:13 <edwardk> @pl \a b c -> (a c) (b c)
01:54:13 <lambdabot> ap
01:54:19 <edwardk> er duh
02:28:13 <DevHC> what's a good, short haskell tutorial?
02:28:33 <ivanm> methinks thsoe two terms are contradictory
02:28:55 <Veinor> @where lyah
02:28:55 <lambdabot> http://www.learnyouahaskell.com/
02:29:06 <Tomsik> What's a good, short book on woodcrafting?
02:29:07 <DevHC> oh no D:
02:30:03 <DevHC> does lyah give a migrane to a coding professional who doesn't know haskell?
02:30:18 <ivanm> DevHC: it does if you prefer a more serious tutorial
02:30:32 <ivanm> it's rather "eclectic" to put it nicely
02:31:49 <ivanm> a bit old, but I still like craft of functional programming
02:31:59 <ivanm> (e.g. it still uses Float rather than Double)
02:32:12 <ivanm> Programming in Haskell is a newer one
02:32:38 <FauxFaux> DevHC: The whole point of haskell is to give a migrane to imperative programmers. ¬_¬
02:33:03 <Veinor> 'wait, there's no for or while loops?'
02:33:14 <ivanm> Saizan, Bynbo7: finally tried out using Builder rather than Text: if anything it results in _more_ RAM usage :s
02:33:15 <aristid> :t forM_
02:33:17 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
02:33:24 <Veinor> haha
02:33:42 <Veinor> :t forM
02:33:43 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
02:33:57 <silver> :t mapM
02:33:59 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
02:34:21 <silver> :t (flip mapM)
02:34:23 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
02:35:06 <hcube> hi!
02:35:11 <Veinor> o/
02:36:43 <hcube> i'm on osx snow leopard and try to use Network package, but it segfaults (quits with bus error message) on connectTo action. i've tried with ghc 6.12.3 and with ghc 7 too
02:36:56 <hcube> any idea?
02:39:14 <Bynbo7> how did you install everything?
02:39:35 <DevHC> ya know, a tutorial is not about teaching all of haskell
02:39:47 <DevHC> i see a tutorial's goal to raise the interest of the reader
02:40:23 <ivanm> DevHC: wtf?
02:40:28 <ivanm> a tutorial is meant to _teach_
02:40:40 <DevHC> and delve into the basics to prepare the reader for a complete book-or-whatever
02:41:38 <DevHC> like, if lyah teaches advanced concepts of monads, it's doubtfully a tutorial
02:41:39 <Saizan> hcube: known bug, it has to do with 64 vs. 32 bit and hsc2hs
02:42:08 <ivanm> DevHC: no, that is part of it _being_ a tutorial
02:42:43 <Saizan> hcube: maybe the network build shipped with the haskell platform would work
02:43:46 <Bynbo7> DevHC: then it's not a tutorial. take it for what it is, a teaching resource
02:44:01 <hcube> Saizan: can i built working network manualy?
02:44:09 <hcube> build
02:45:47 <aristid> what is type strictness in TH?
02:47:47 <Saizan> hcube: kfr managed to, iirc
02:48:15 <kfr> Huh? In GHC 7?
02:48:22 <Saizan> hcube: http://hackage.haskell.org/trac/ghc/ticket/4852 <- this is the bug
02:48:34 <Saizan> kfr: ah, so you're not kazu-yamamoto?
02:49:13 <kfr> Saizan: No, I am Ngume Obojo
02:50:30 <Saizan> i saw the ticket opened just after you had problems with network, so i drawed the connection, sorry :)
02:50:35 <ivanm> Saizan, Bynbo7: actually I managed to get it down to being almost instant!
02:50:52 <ivanm> (by making part of it smarter)
02:51:12 <Saizan> smarter++
02:51:21 <hcube> Saizan: thanks, just checking the link
02:52:08 <ivanm> the fix ended up being: consume as many characters as you can that don't start problems
02:52:25 * hackagebot functor-apply 0.10.3 - Haskell 98: Applicative sans pure, Monad sans return, Alternative sans empty  http://hackage.haskell.org/package/functor-apply-0.10.3 (EdwardKmett)
02:53:32 <shachaf> edwardk: Somehow I can always guess that it's you after reading a few words of hackagebot's message.
02:53:46 <ivanm> shachaf: heh
02:53:49 <edwardk> hah
02:54:25 <edwardk> someone has to fight the good fight in favor of abstraction! ;)
02:57:38 <ivanm> wow... I got a stack space overflow from darcs! :o
02:58:27 * hackagebot functor-apply 0.10.4 - Haskell 98: Applicative sans pure, Monad sans return, Alternative sans empty  http://hackage.haskell.org/package/functor-apply-0.10.4 (EdwardKmett)
02:58:38 <edwardk> was missing a semigroupoid instance
02:59:26 <edwardk> now i can go back to playing with indexed monads
03:00:54 <ivanm> lol, I think I confused hp2ps by passing too many arguments to my program :p
03:04:28 <Heffalump> ivanm: what were you doing?
03:05:10 <Heffalump> (with darcs)
03:09:50 <aristid> template haskell code can become pretty ugly quickly
03:13:51 <aristid> ok, now i know what Strict means. it's the same as the bang.
03:14:10 <ivanm> Heffalump: trying to use darcsum in emacs
03:19:32 * hackagebot functor-apply 0.10.5 - Haskell 98: Applicative sans pure, Monad sans return, Alternative sans empty  http://hackage.haskell.org/package/functor-apply-0.10.5 (EdwardKmett)
03:19:52 <Lycurgus> has the "theory of patches" advanced much in the last 4 years or so?
03:20:09 <edwardk> Lycurgus: a bit, lispy had a thesis on the topic
03:20:19 <Lycurgus> (or rather its implementation in darcs)
03:20:39 <edwardk> Lycurgus: but then he was absorbed into galois, i'm not sure much theoretical exploration has been done since, mostly pragmatics
03:20:42 <Lycurgus> funny people can get the underlying simplicity in this
03:21:23 <ivanm> @hoogle evaluate
03:21:24 <lambdabot> Control.Exception evaluate :: a -> IO a
03:21:24 <lambdabot> Control.OldException evaluate :: a -> IO a
03:21:24 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
03:21:27 <Lycurgus> which is that the total value of such a thing and in vcs generally is in merge and the capabilities provided for that, which are generally nil
03:22:16 <edwardk> i've stolen patch theory, but only used it in completely different contexts (commuting opcodes in an optimizer)
03:22:32 <Lycurgus> by nil I mean no better than what you can and will have to do manually with diff
03:22:43 <edwardk> its quite useful there, because you can avoid all the exponential cases just by giving up ;)
03:22:52 <Lycurgus> lol
03:23:13 <Lycurgus> that's a classic haskell perspective
03:23:30 <edwardk> giving up?
03:24:13 <Lycurgus> well giving up on practical end doing in favor of theoreticality
03:24:29 <Heffalump> Lycurgus: Judah Jacobson wrote some stuff about it
03:24:41 <Heffalump> Lycurgus: and Igloo has been trying to prove some patch theory correct in Coq
03:24:49 <edwardk> well, actually i gave up on the theoretical end in favor of practicality. it worked quite well, and was only an optimization ;)
03:24:52 <alpounet> see the Camp project
03:25:19 <edwardk> i'm curious to see if igloo's project works out. i haven't really heard anything out of it in a while
03:26:19 <Philippa> edwardk: heh. Besides, I'm guessing all haskell did was let you express the giving up part better?
03:26:45 <edwardk> philippa: heh, well, it _was_ in c++ at the time. so there was great incentive to give up and do other things ;)
03:28:18 <edwardk> @tell mm_freak just took a look at cont-stuff, most of it doesn't care about the 'r' at all. why not close over it with universal quantification? then your signatures clean up and you've reinvented monad-ran! ;)
03:28:18 <lambdabot> Consider it noted.
03:29:47 <dfkjjkfd> k
03:34:00 <edwardk> hrmm. i just found a paper that describes the approach i'm using with prelude-extras and syb-extras. http://flint.cs.yale.edu/trifonov/papers/sqcc.pdf  not that its all that exciting
03:34:01 * kfr just discovered his first use case for the n + k pattern match
03:34:11 <kfr> Too bat it has been removed :'(
03:34:14 <kfr> bad*
03:37:08 <Philippa> kfr: pattern guard?
03:37:27 <kfr> Philippa: What do you mean?
03:37:35 <kfr> I thought the n + k has been removed in GHC 7
03:38:00 <Philippa> yes, it has. But you can do something like m | n <- m - k
03:38:00 <kfr> > let x + 1 = 43 in x
03:38:02 <lambdabot>   x
03:38:14 <Philippa> oh, not GHC 7 AFAIK
03:38:20 <Philippa> one of the standards, yeah
03:38:44 <kfr> <interactive>:1:19: Not in scope: `x'
03:38:48 <kfr> GHC 7 ^
03:38:52 <Philippa> fair enough
03:39:05 <Philippa> but yeah, pattern guards should do the trick anyway. I may've goofed the syntax above
03:49:00 <aristid> :t flip const
03:49:02 <lambdabot> forall b a. a -> b -> b
03:49:22 <aristid> @hoogle a -> b -> b
03:49:23 <lambdabot> Prelude seq :: a -> b -> b
03:49:23 <lambdabot> Control.Parallel par :: a -> b -> b
03:49:23 <lambdabot> Control.Parallel pseq :: a -> b -> b
03:49:37 <benmachine> view patterns can do it too
03:49:45 <benmachine> n+k that is
03:49:48 <aristid> hah. i want seq but without ANY effect :D
03:50:02 <benmachine> @hoogle r0
03:50:02 <lambdabot> Control.Parallel.Strategies r0 :: Strategy a
03:50:05 <aristid> seems like flip const is the best name
03:50:12 <benmachine> const id
03:50:16 <benmachine> is also good
03:50:24 <aristid> benmachine: slightly more confusing to me
03:50:25 <benmachine> it's kind of cute how they're the same
03:50:46 <benmachine> aristid: yeah, I guess for me I just read 'const id' as a single word as it were
03:50:50 <edwardk> const id is what i wind up using everywhere
03:50:52 <benmachine> and basically remember it means flip const P
03:50:53 <benmachine> :P
03:51:07 <edwardk> const id <$> a <*> b — etc
03:51:15 <aristid> thank you, template haskell: 4 files changed, 65 insertions(+), 137 deletions(-)
03:51:36 <edwardk> tempted to rename functor-apply to semigroupoids
03:51:46 <edwardk> its got less and less to do with functor application
03:51:48 <benmachine> aristid: what did it do this time?
03:51:51 <aristid> :t liftA2 (const id)
03:51:52 <lambdabot> forall a a1 (f :: * -> *). (Applicative f) => f a1 -> f a -> f a
03:52:19 <aristid> benmachine: well, i have a huge enumeration for error codes with slightly different haskell names than their XML strings
03:52:35 <aristid> only worry: haddock will get mighty confused
03:53:34 <aristid> http://docs.amazonwebservices.com/AmazonSimpleDB/latest/DeveloperGuide/index.html?APIError.html
03:54:13 <aristid> because it looks ugly, i automatically transform stuff like InvalidHTTPAuthHeader to InvalidHttpAuthHeader
03:56:50 <benmachine> it looks ugly?
03:56:53 * benmachine prefers the former :P
03:57:24 <benmachine> oh, it's inconsistent, how irritating
03:58:36 <aristid> benmachine: you know i'd rather write 76 lines (srsly, haskell line counts are never impressive!) of template haskell + helpers than live with this inconsistency
03:58:58 <flamingspinach> that's not an inconsistency
03:59:04 <flamingspinach> oh
03:59:07 <flamingspinach> sorry, ignore me
04:01:03 <aristid> if this was java i could boast of having written 400 lines of code for this
04:01:07 <aristid> sadly, haskell is more concise
04:01:09 <benmachine> heheh
04:01:12 <benmachine> it's a hard life :(
04:01:45 <merijn> Wouldn't wanna write haskell when I get paid by line count ;)
04:02:54 * benmachine starts putting newlines after every language construct
04:03:05 * benmachine starts using explicit layout and putting each brace on its own line
04:03:05 <Twey> merijn: Just double-space every line :þ
04:03:30 <merijn> Twey: Even then you get 15 times the line count with C++ or Java :p
04:03:33 <Twey> Start a new line for each operator :þ
04:03:50 <merijn> Although I suppose I should just go for ASM if I want to get paid by line of code :p
04:06:44 * hackagebot functor-apply 0.11 - This package has been subsumed by semigroupoids  http://hackage.haskell.org/package/functor-apply-0.11 (EdwardKmett)
04:07:04 <aristid> edwardk: you're out-uploading snoyman.
04:07:09 <edwardk> hah
04:07:25 <edwardk> i have about 8-9 dependant packages to push now ;)
04:09:01 <Bynbo7> you guys should have an upload-off!
04:10:45 * hackagebot comonad 1.0 - Haskell 98 comonads  http://hackage.haskell.org/package/comonad-1.0 (EdwardKmett)
04:11:04 <aristid> > map (chr . (+1) . ord) "Bynbo7"
04:11:06 <lambdabot>   "Czocp8"
04:11:11 <aristid> > map (chr . (-1) . ord) "Bynbo7"
04:11:13 <lambdabot>   "*Exception: Prelude.chr: bad argument: (-1)
04:11:19 <aristid> > map (chr . (subtract 1) . ord) "Bynbo7"
04:11:20 <alpounet> substract heh
04:11:21 <lambdabot>   "Axman6"
04:11:32 <Bynbo7> > map pred "Bynbo7"
04:11:33 <lambdabot>   "Axman6"
04:11:40 <aristid> Bynbo7: Czocp8 would make you sound like a Czech
04:11:44 <Bynbo7> 'cmon aristid, get with it!
04:11:56 <Bynbo7> Zoc-pate
04:11:57 <aristid> get with what?
04:12:03 * aristid confused
04:12:12 <benmachine> get with the Enum class?
04:12:15 <benmachine> maybe?
04:12:20 <Bynbo7> using pred instead of ord, chr, subtract
04:12:32 <merijn> :t pred
04:12:33 <lambdabot> forall a. (Enum a) => a -> a
04:12:35 <merijn> :t succ
04:12:36 <lambdabot> forall a. (Enum a) => a -> a
04:12:45 <Veinor> > map succ "Veinor"
04:12:45 * hackagebot semigroupoids 1.0.0 - Haskell 98: Semigroupoids: Categories sans id, Applicative sans pure, Monad sans return, Alternative sans empty  http://hackage.haskell.org/package/semigroupoids-1.0.0 (EdwardKmett)
04:12:45 <lambdabot>   "Wfjops"
04:12:50 <Veinor> > map pred "Veinor"
04:12:51 <lambdabot>   "Udhmnq"
04:12:58 <Veinor> Wfjops sounds polish
04:13:03 <Twey> Heh
04:13:11 <benmachine> Udhmnq sounds like an aztec god or something
04:13:16 <merijn> > map succ "merijn"
04:13:17 <Ke> > map succ "HAL"
04:13:17 <lambdabot>   "nfsjko"
04:13:18 <lambdabot>   "IBM"
04:13:23 <Twey> benmachine: Sounds Orcish to me
04:13:26 <Veinor> Ke: gasp
04:13:28 <merijn> > map pred "merijn"
04:13:29 <lambdabot>   "ldqhim"
04:13:37 <aristid> > map succ "aristid"
04:13:38 <lambdabot>   "bsjtuje"
04:13:39 <Twey> Ke: Haha!
04:13:43 <Twey> Ke: Was that intentional?
04:13:46 <Ke> yes
04:13:47 <benmachine> > map succ "Twey"
04:13:48 <lambdabot>   "Uxfz"
04:13:49 <Twey> Nice
04:13:51 <merijn> Twey: You didn't know that one?
04:13:53 <Twey> Nope
04:13:59 <Twey> I never realised
04:14:01 <alpounet> map succ/pred is a scandinavian name generator or what?
04:14:09 <merijn> alpounet: :p
04:14:11 <alpounet> well, scandinavian and aztec
04:14:12 <Veinor> i never realized that Bynbo7 was Axman6 until just now, so
04:14:17 <Twey> Heh
04:14:29 <bsjtuje> @remember alpounet map succ/pred is a scandinavian name generator or what? ... well, scandinavian and aztec
04:14:29 <lambdabot> Done.
04:14:41 <Bynbo7akaAxman6> to avoid ambiguity
04:14:45 <Veinor> haha
04:14:57 <bsjtuje> > map pred "Bynbo7akaAxman6"
04:14:58 <lambdabot>   "Axman6`j`@wl`m5"
04:15:08 <Twey> > on (&&&) map succ pred "Twey"
04:15:09 <lambdabot>   ("Uxfz","Svdx")
04:15:10 <Bynbo7akaAxman6> bsjtuje: that's my perl name :P
04:15:16 <Veinor> > map succ "Bynbo7akaAxman6"
04:15:17 <lambdabot>   "Czocp8blbBynbo7"
04:15:18 <bsjtuje> Bynbo7akaAxman6: hahaha
04:15:20 <Twey> I like ‘Svdx’ marginally better :þ
04:15:21 <merijn> :t on
04:15:22 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
04:15:31 <Veinor> @src on
04:15:31 <lambdabot> (*) `on` f = \x y -> f x * f y
04:15:51 <Veinor> @unpl on (&&&) map succ pred
04:15:51 <lambdabot> on (&&&) map succ pred
04:15:54 <Bynbo7akaAxman6> there was a large computer company in an episode of the west wing
04:16:00 <Bynbo7akaAxman6> they were called JCN
04:16:02 <merijn> Really? "forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c"? Let's not be overly generic >.>
04:16:04 <Veinor> haha
04:16:06 <Twey> Heh
04:16:06 <Bynbo7akaAxman6> > map pred "JCN"
04:16:07 <lambdabot>   "IBM"
04:16:08 <alpounet> > iterate (map succ) "alpounet"
04:16:10 <Bynbo7akaAxman6> :O
04:16:10 <lambdabot>   ["alpounet","bmqpvofu","cnrqwpgv","dosrxqhw","eptsyrix","fqutzsjy","grvu{tk...
04:16:22 <bsjtuje> merijn: on is not overly generic
04:16:22 <Veinor> eptsyrix sounds like an archaeopteryx relative
04:16:30 <Twey> Yeah, what bsjtuje said
04:16:31 <merijn> :t (&&&)
04:16:32 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
04:16:41 <bsjtuje> alpounet: now with a filter for phonetically plausible names :)
04:16:53 <Veinor> so... what's an example of an intuitive arrow that's not (->)
04:16:55 <Veinor> ?
04:17:06 <Twey> Veinor: Haha
04:17:09 <Twey> Good question
04:17:19 <Veinor> (or a b c = b -> [c])
04:17:19 <merijn> Veinor: The ones shot by longbows? :p
04:17:19 <alpounet> Veinor, http://www.haskell.org/haskellwiki/Arrow_tutorial#Kleisli_Arrows
04:17:29 <alpounet> depends on your definition of intuitive :P
04:17:35 <Twey> Yeah, very much so :þ
04:17:38 <Veinor> true.
04:17:50 <benmachine> I think kleisli arrows are sort of what monads are all about
04:18:06 <alpounet> indeed
04:18:12 <alpounet> if you have a good grasp of monads it sure makes sense
04:18:16 <benmachine> :t (id <=<)
04:18:17 <lambdabot> forall (m :: * -> *) c a. (Monad m) => (a -> m (m c)) -> a -> m c
04:18:21 <benmachine> er whoops
04:18:26 <edwardk> exactly, now remove return and you understand my semigroupoids package ;)
04:18:28 <Wooga> is the only difference between forM and mapM is just order of arguments?
04:18:32 <benmachine> :t (id >=>)
04:18:32 <lambdabot> forall (m :: * -> *) b c. (Monad m) => (b -> m c) -> m b -> m c
04:18:35 <benmachine> there we go
04:18:36 <edwardk> wooga: exactly
04:18:44 <Wooga> edwardk: so why do we have both of them?
04:18:45 <bsjtuje> Wooga: yes, that's how it's defined.
04:18:49 <bsjtuje> Wooga: for convenience.
04:18:56 <Wooga> k, thanks for answering
04:19:03 <edwardk> wooga: because forM [1…12] $ do …. is often a lot nicer than mapM
04:19:04 <benmachine> Wooga: sometimes you have a small function and a big list, so it's easier to put the function first
04:19:05 <alpounet> you could just use flip mapM instead of forM, of course
04:19:11 <benmachine> Wooga: sometimes you have a small list and a big function
04:19:14 <Bynbo7akaAxman6> Wooga: so you can write: forM xs $ \x -> do\n x\ny\nz
04:19:29 <alpounet> but the code is more easily readable and understandable if you directly have "forM"
04:19:34 <edwardk> because mapM (do … ) [1..12] if the do block is long you'd forget what you were mapping over
04:19:35 <Bynbo7akaAxman6> benmachine: there's a mataphore in there, I'm sure
04:19:44 <edwardk> plus you have the annoying parens there
04:19:44 <alpounet> haha
04:19:45 <benmachine> Bynbo7akaAxman6: a matador?
04:20:05 <benmachine> ok yes
04:20:05 <Bynbo7akaAxman6> a matador too probably
04:20:06 <benmachine> maybe
04:20:11 <benmachine> :P
04:20:17 <turiya> can I do an unsafePerformIO on an action which takes a vector (Data.Packed.Vector) as an argument and outputs its mean?
04:20:25 <edwardk> mapM works best syntactically when the function you are mapping is short. forM when the 'container' description is short
04:20:34 <Twey> turiya: Sounds like you might want ST instead
04:20:55 <Twey> turiya: An otherwise pure, imperative algorithm, right?
04:21:02 <merijn> So, is there a more gentle arrow tutorial then http://www.haskell.org/haskellwiki/Arrow_tutorial ?
04:21:07 <alpounet> turiya, why not writing a function that computes the mean, and then output it where appropriate?
04:21:12 <alpounet> merijn, the one in wikibooks
04:21:18 <turiya> Twey: I am not sure how do identify purity..
04:21:25 <alpounet> http://en.wikibooks.org/wiki/Haskell/Understanding_arrows
04:21:26 <Bynbo7akaAxman6> turiya: if you perform no external actions, ST is exactly what you want
04:21:34 <kfr> Is there a convention in Haskell regarding Either and error output? Should I put it into Right or Left? I think Parsec used Left for it, I'd prefer Right.
04:21:37 <alpounet> (it actually starts here: http://en.wikibooks.org/wiki/Haskell/Arrows)
04:21:42 <merijn> turiya: Simple, are you using unsafe* or IO? Then it is not pure :p
04:21:44 <aisamu> hello!
04:22:01 <Bynbo7akaAxman6> kfr: the standard is that Left is the error
04:22:03 <merijn> kfr: I believe the convention is Left
04:22:07 <benmachine> kfr: Left ~ Wrong :P
04:22:14 <Bynbo7akaAxman6> kfr: this makes the Either e monad work nicely
04:22:17 <merijn> sinistra and all that
04:22:20 <Twey> turiya: ST gives you imperative sequencing and updates, without anything impure like reading/writing files or devices
04:22:33 <turiya> reading data from a ForeignPtr is pure?
04:22:34 <benmachine> kfr: consider which one you want 'fmap' to modify, for e.g.
04:22:40 <Twey> So an ST action must be executed in order, but it can present a pure interface
04:22:41 <benmachine> kfr: lots of people just make their own types, as well
04:22:46 <kfr> Oh, right
04:22:48 * hackagebot comonad-transformers 1.0.0 - Haskell 98 comonad transformers  http://hackage.haskell.org/package/comonad-transformers-1.0.0 (EdwardKmett)
04:23:12 <Twey> turiya: Nope, probably not — something might change the ForeignPtr
04:23:33 <Twey> turiya: Why are you reading a ForeignPtr in a function to calculate the mean of a vector?
04:23:56 <turiya> a vector is represented as a ForeignPtr internally
04:24:14 <Twey> Oh, well, if it's internal and guaranteed read-only then you're fine
04:24:30 <benmachine> edwardk: just a thought, iirc most of the applicative laws use pure, how do you legislate for a pureless functorapply?
04:24:48 * hackagebot comonads-fd 1.0.0 - Comonad transformers using functional dependencies.  http://hackage.haskell.org/package/comonads-fd-1.0.0 (EdwardKmett)
04:24:55 <turiya> yes, i believe so. nothing might modify the original vector..
04:24:57 <merijn> :t (-<)
04:24:58 <lambdabot> Not in scope: `-<'
04:25:19 <merijn> What's "-<" do in: plusOne = proc a -> returnA -< (a+1)?
04:25:22 <benmachine> merijn: arrow syntax
04:25:32 <benmachine> don't ask me to explain it because I don't get it :P
04:25:36 <Twey> +1
04:25:43 <burp> "cabal update \n Downloading the latest package list from hackage.haskell.org \n cabal: does not exist" -- wtf?
04:25:52 <Twey> I get arrows, more or less, but I've never got the syntax sugar :þ
04:25:54 <Bynbo7akaAxman6> ha
04:26:00 <edwardk> benmachine: the law is that <.> is associative.ic
04:26:02 <burp> is cabal working for anyone of you?
04:26:07 <edwardk> wow that got eaten
04:26:08 <Kaidelong> http://www.haskell.org/arrows/syntax.html
04:26:21 <Kaidelong> @where arrows
04:26:22 <lambdabot> http://www.haskell.org/arrows/
04:26:26 <Kaidelong> good
04:26:40 <Twey> burp: WFM
04:26:45 <burp> ok
04:26:58 <Bynbo7akaAxman6> @wh
04:26:58 <lambdabot> Maybe you meant: what where where+ wn
04:27:12 <benmachine> burp: what exactly isn't working?
04:27:13 <edwardk> The law provided by Apply is that static arrow composition is associative. this semigroup is basically the same as saying that kleisli composition is associative or that cokleisli composition is associative
04:27:15 <Bynbo7akaAxman6> @where+ arrows your quiver
04:27:15 <lambdabot> Done.
04:27:19 <Bynbo7akaAxman6> @where arrows
04:27:19 <lambdabot> your quiver
04:27:21 <burp> benmachine: cabal update / cabal install
04:27:22 <Bynbo7akaAxman6> oops
04:27:23 <Twey> >.>
04:27:33 <benmachine> burp: oh, I just successfully cabal updated
04:27:34 <merijn> Ok, by the looks of it I should just postpone Arrows until I have the spare time to fry and unfry my brain :p
04:27:35 <burp> "attoparsec-text-0.8.2.1 failed while downloading the package. The exception was: connect: does not exist (Connection refused)"
04:27:36 <Bynbo7akaAxman6> @where+ arrows http://www.haskell.org/arrows/
04:27:37 <lambdabot> I will never forget.
04:27:39 <Bynbo7akaAxman6> @where arrows
04:27:39 <lambdabot> http://www.haskell.org/arrows/
04:27:44 <burp> benmachine: then it's something really strange here :/
04:27:46 <Bynbo7akaAxman6> it's all good, don't panic!
04:27:53 <edwardk> i used to have a ComonadApply class that provided the additional guarantee that extract (f <.> a) = (extract f) (extract a)
04:27:53 <benmachine> burp: are you using a proxy or anything?
04:28:11 <burp> benmachine: oh!
04:28:21 <burp> I changed some proxy configuration yesterday, got it, thanks ;)
04:28:24 <Twey> Kaidelong: Yeah, I've read that before
04:28:30 <Twey> It didn't help :þ
04:28:35 <Twey> I'm sure I'll get it some day
04:28:36 <edwardk> (and that it was a symmetric semimonoidal comonad) but i've instead adopted the convention that i don't make a comonad on something with an apply instance where i can't guarantee those properties
04:28:49 <benmachine> I just haven't ever felt like I needed it really
04:29:05 <benmachine> or seen someone else use it and gone I wish I could do that
04:29:55 <Bynbo7akaAxman6> edwardk: extract is anti-return right?
04:29:59 <edwardk> yeah
04:30:32 <edwardk> you can view the comonadapply law as symmetric to those of the applicative pure laws
04:30:40 <Bynbo7akaAxman6> so... f :: w (a -> b) and a :: f a, so... (f <.> a) :: b
04:30:43 <Bynbo7akaAxman6> yeah?
04:30:44 <edwardk> many comonads admit an Apply instance.
04:31:15 <edwardk> no, <.> is just like <*>
04:31:35 <edwardk> f :: w (a -> b), a :: w a   f <.> a :: w b
04:31:42 <accel> is there an haskell obscufacator? i.e. i ahve haskell code; I produce a binary; but I want to make it very very hard for anyone to try to reverse engineer it. (I ask this since it seems laziness implies keeping code around and computing on demand)
04:31:43 <Bynbo7akaAxman6> huh
04:32:00 <edwardk> the applicative is responsible for zipping together the two comonad shapes
04:32:02 <Twey> accel: That's not what laziness really means…
04:32:04 <Bynbo7akaAxman6> accel: that implication is incorrect
04:32:55 <benmachine> so I wrote a thing that does this:
04:32:56 <benmachine> ghci> dataToExp (Just ())
04:32:56 <benmachine> App (Con (UnQual (Ident "Just"))) (Con (Special UnitCon))
04:32:59 <edwardk> given any comonad you could define a trivial apply instance that would be broken, by just extracting one or the other comonads, and mapping it over the other
04:33:05 <benmachine> it's cute but I can't work out what it's *for*
04:33:32 <edwardk> the type signature would line up but the utility would be lost
04:33:40 <bsjtuje> benmachine: you wrote a cute thing that you can't know what it's for?
04:34:07 <Bynbo7akaAxman6> edwardk: ah, i missed the first extract in your law, so i was confused :)
04:34:15 <benmachine> bsjtuje: I haven't really worked out if it has any use
04:34:19 <edwardk> =)
04:34:30 <merijn> accel: It's impossible
04:34:37 <Bynbo7akaAxman6> benmachine: use it to compile haskell expressions into haskell!
04:34:44 <bsjtuje>  > runQ [| Just () |]
04:34:44 <bsjtuje> AppE (ConE Data.Maybe.Just) (ConE GHC.Unit.())
04:34:47 <merijn> accel: If a computer can understand and execute it, so can a human
04:34:49 <parcs> accel: ghc doesn't keep source code around in its binary. just try running strings on it
04:34:49 <benmachine> bsjtuje: wat
04:35:01 <bsjtuje> benmachine: template haskell
04:35:05 <accel> merijn , parcs : sure; but one can make the job of reverse engineering hard
04:35:11 <benmachine> bsjtuje: oh, I meant, Bynbo7akaAxman6: wat
04:35:15 <kfr> I have a [(String, String)] I want to insert into a Map String String. What's a convenient/clean way to have an error condition occur when a key already exists? I presume insertWith can be used for that. The first method that came to mind was combining insertWith with an undefined handler which causes an exception to be thrown which I... no, wait, that's a terrible idea. Exceptions can't be caught in pure functions.
04:35:37 <benmachine> kfr: ooh, I did this recently
04:35:38 <merijn> accel: Haskell binaries will most likely already be hard to reverse engineer since they don't follow usual C/C++ code constructions
04:35:40 <parcs> accel: i bet it already is very difficult
04:35:52 <benmachine> kfr: I think I used Data.Traversable.sequence
04:35:59 <benmachine> sequenceA
04:35:59 <kfr> :o
04:36:07 <benmachine> :t Data.Traversable.sequenceA
04:36:08 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
04:36:14 <Bynbo7akaAxman6> accel: ghc uses a very strange calling convention as well, which doesn't help
04:36:23 <merijn> C/C++ code is imperative so the translation to ASM is pretty straightforward (and therefore,  so is the reverse). Haskell produces far less "typical" code I'm willing to bed
04:36:32 <merijn> s/bed/bet
04:36:47 <benmachine> kfr: i.e. Map k (Maybe a) -> Maybe (Map k a)
04:36:51 * hackagebot streams 0.6.0 - Various Haskell 2010 stream comonads  http://hackage.haskell.org/package/streams-0.6.0 (EdwardKmett)
04:37:05 <Kaidelong> merijn: In a sense, haskell is compiled more than one, I think, would be a good way to put it
04:37:08 <Kaidelong> once*
04:37:15 <Bynbo7akaAxman6> edwardk: you're winning the upload-off!
04:37:17 <merijn> Kaidelong: So is C/C++
04:37:24 <Kaidelong> that's true
04:37:30 <Bynbo7akaAxman6> snoyman ain't got nuffin on eddy-K!
04:37:47 <edwardk> Bynbo7akaAxman6: i changed some things way down in the dependency tree ;)
04:37:53 <Bynbo7akaAxman6> heh
04:37:53 <merijn> accel: Why do you need the code to be hard to reverse engineer?
04:37:54 <benmachine> :t \m1 m2 -> Data.Traversable.sequence . Map.unionWith (\_ _ -> Nothing) (fmap Just m1) $ fmap Just m2
04:37:55 <lambdabot> Couldn't find qualified module.
04:37:59 <benmachine> oh right
04:38:00 <edwardk> so i'm stuck fixing a dozen packages or so
04:38:05 <benmachine> :t \m1 m2 -> Data.Traversable.sequence . M.unionWith (\_ _ -> Nothing) (fmap Just m1) $ fmap Just m2
04:38:06 <lambdabot> forall a k. (Ord k) => M.Map k a -> M.Map k a -> Maybe (M.Map k a)
04:38:33 <DevHC> accel: http://portal.acm.org/citation.cfm?doid=1536414.1536440
04:38:51 * hackagebot ad 1.0.0 - Automatic Differentiation  http://hackage.haskell.org/package/ad-1.0.0 (EdwardKmett)
04:39:21 <Maxdamantus> See how well you can modify -C
04:39:34 <ircclienttest> Hi?
04:39:40 <merijn> DevHC: Wow, that's fascinating
04:39:51 <accel> merijn: selling mac apps
04:39:51 <ircclienttest> Can you read this message?
04:40:07 <Bynbo7akaAxman6> ircclienttest: no
04:40:16 <ircclienttest> Yessss
04:40:17 <accel> DevHC: that looks kinda slow in practice
04:40:25 <DevHC> :P
04:40:26 <Bynbo7akaAxman6> can't read that either
04:40:28 <benmachine> 12:47:45 <@malc> unrelatedly, I am a bit concerned by the green line on 
04:40:28 <benmachine> http://www.srcf.ucam.org/srcf-admin/munin/srcf.ucam.org/pip.srcf.ucam.org/netstat.html
04:40:31 <benmachine> what
04:40:34 <benmachine> 12:48:02 <@malc> what is making a linearly-increasing number of outgoing TCP  connections?
04:40:37 <benmachine> agh
04:40:40 <benmachine> mispaste :(
04:40:46 <benmachine> ok let me try that again
04:40:51 <benmachine>  -!- ircclienttest [~Python-IR@80-121-39-190.adsl.highway.telekom.at]
04:40:52 <ircclienttest> I am developing an irc client and wanted to see if it works....
04:40:56 <benmachine> ~Python?
04:41:01 <merijn> accel: Seriously, I wouldn't worry about people reverse engineering the code in a consumer app
04:41:04 <benmachine> aw he went before I could make fun of him :(
04:41:11 <benmachine> *they went before I could make fun of them
04:41:36 <edwardk> benmachine: whats that about malc?
04:41:43 <merijn> accel: The people who truly want to will be able to succeed anyway and I will guarantee clueless people won't be able to follow compiled Haskell
04:41:46 <benmachine> edwardk: nothing <_<
04:42:11 <benmachine> edwardk: why do you ask :P
04:42:11 <DevHC> accel: http://www.freepatentsonline.com/7296163.html
04:42:21 * benmachine read that as freepantsonline.com
04:42:23 <edwardk> just an old friend is all
04:42:28 * benmachine not sure whether to be disappointed
04:42:50 <edwardk> was trying to derive context =)
04:42:52 * hackagebot recursion-schemes 0.4.0 - Generalized bananas, lenses and barbed wire  http://hackage.haskell.org/package/recursion-schemes-0.4.0 (EdwardKmett)
04:43:00 * DevHC waits for accel's comment on performance issues
04:43:09 <benmachine> edwardk: the context was me mispasting; I wonder whether there's more than one malc, though?
04:43:47 <Bynbo7akaAxman6> accel: just compile with the llvm backend, ad full optimisations. that'll obfuscate it something awful
04:43:52 <Bynbo7akaAxman6> then strip it, just to be sure
04:43:53 <edwardk> generally angry russian, good with low level systems details, likes video codecs and hacking on old games?
04:44:08 <benmachine> edwardk: nope.
04:44:10 <benmachine> :P
04:44:24 <benmachine> cambridge (uk) postgrad
04:44:28 <edwardk> fair nuff
04:44:40 <benmachine> aw
04:44:42 <edwardk> i thought the cloak was his, hence my confusion
04:44:43 * benmachine was excited for a moment
04:45:16 <edwardk> the one i was thinking of is an old demoscene buddy
04:46:16 <edwardk> trying to figure out if its worth packaging up this zipper code
04:46:26 <DevHC> benmachine: what if i told u, that in a few months u will be able to program tremulous' game logic in haskell?
04:46:57 <benmachine> DevHC: that's nice
04:47:04 <benmachine> DevHC: I'll believe it when I see it :P
04:47:12 <edwardk> DevHC: i'd say you'd make shapr very happy
04:47:24 <DevHC> ok, it's gonna be my bsc thesis
04:47:31 <benmachine> what's shapr's connection?
04:47:43 <edwardk> he plays a lot of tremulous
04:47:45 <DevHC> @info shapr
04:47:46 <lambdabot> shapr
04:47:52 <benmachine> oh, how about that
04:48:02 <DevHC> > shapr
04:48:03 <lambdabot>   Not in scope: `shapr'
04:48:08 <DevHC> @where shapr
04:48:08 <benmachine> @get-shapr
04:48:09 <lambdabot> shapr!!
04:48:09 <ivanm> preflex: seen shapr
04:48:09 <preflex>  shapr was last seen on #haskell 1 day, 7 hours, 27 minutes and 13 seconds ago, saying: howdy sm, how's code?
04:48:09 <edwardk> @shapr
04:48:10 <lambdabot> I'd rather not;  looks rather dangerous.
04:48:17 <Twey> Haha
04:48:20 <DevHC> ROFL
04:48:20 <ivanm> DevHC: do you have any idea what you're doing?
04:48:32 <DevHC> yes: i'm trolling lambdabot
04:48:38 <Twey> shapr plays Trem?
04:48:45 <benmachine> does Twey? :P
04:48:56 <edwardk> twey: he did when he was up here in boston. not sure if he has time these days
04:48:57 <benmachine> ok in fairness I don't really
04:48:58 <benmachine> but still
04:48:59 <Twey> I used to
04:49:06 <Twey> benmachine: We met there, you silly bear
04:49:15 <benmachine> Twey: I know, hence the :P
04:49:18 <Twey> Oh, okay :þ
04:49:33 <benmachine> Twey: I was subtly alluding to the irony of you being interested in someone else playing a game that you didn't really
04:49:44 <benmachine> it was very subtle and witty and now it's ruined :(
04:49:49 * benmachine cries
04:50:02 <Twey> benmachine: Well, I think my machine might be happier with it now, so I might play a bit again
04:50:10 <Twey> OTOH, I might use my time for something productive ;)
04:50:21 <edwardk> hrmm. i wonder if there is a nice speculation comonad using the discont trick
04:50:38 <benmachine> Twey: heheh
04:51:17 <Twey> I did spend a little while last year trying to develop a scripting protocol for it, so scripting could be done with external executables in languages other than C and Quake script
04:51:25 <benmachine> oh
04:51:32 <benmachine> someone did a lua interface I think
04:52:07 <Twey> Yeah, Lakitu made Lua scripting, I think
04:52:45 <benmachine> I was thinking of f0rqu3
04:52:58 <merijn> Twey: Productivity is overrated :p
04:53:07 <Twey> Oh, maybe
04:53:08 <Twey> merijn: Heh
04:53:41 <merijn> Every time I try to be productive I end up playing video games >.>
04:54:36 <Entroacceptor> no, Twey, come and play trem with me :)
04:54:39 <merijn> I should just switch majors to AI and prepare for the next StarCraft AI challenge :p
04:54:52 <Twey> Haha
04:55:46 <merijn> (to be fair, some of the SC AI challenge contenders were really insanely impressive works of programming and AI)
04:56:19 <Twey> Yes, but you'd be doing it in *Haskell*!  How could you lose?!
04:56:48 <edwardk> by doing it in haskell. ;)
04:57:38 <merijn> Meh, the Google AI contest winner snubbed his nose and the millions of C/C++/Java entries by writing the entire thing in Lisp :p
04:58:19 <edwardk> *shrugs* good algorithm + tools you are familiar with
04:58:25 <kfr> merijn that stuff inspired an idea of mine, developing in RTS which offers manual regular play but also programmatic facilities for AI vs. AI competitions. You could turn it into a sport with videos etc. Haha.
04:58:42 <kfr> How do I make (\_ _ -> Nothing) shorter?
04:58:57 <benmachine> how much shorter? :P
04:59:05 <edwardk> (\_ _ -> empty) =
04:59:08 <benmachine> :P
04:59:09 <edwardk> er =)
04:59:24 <merijn> kfr: Let me know when you finish that. I've been looking for games which promote AI competition to play with :p
04:59:29 <edwardk> you can drop a couple of spaces too
04:59:34 <benmachine> (pure.pure$mzero)
04:59:40 <benmachine> hmm I think that's longer
04:59:51 <edwardk> (\_ _->empty) — is the best i have
05:00:21 <kfr> merijn: I'll probably never finish it :|
05:00:47 <merijn> Programming games is *HARD*
05:00:49 <edwardk> z _ _=empty         — then use z ;)you can shave a couple of characters that way
05:00:57 <accel> kfr: how does your ai work in starcraft 1 ?
05:01:13 <kfr> accel: I don't have one :o
05:01:27 <merijn> I can do OS code, low level ASM,functional programming, but I'll be damned if I could succesfully finish a game :p
05:02:01 <accel> merijn: start with tic tac toe
05:02:07 <accel> merijn: if you can do that, move up to tetris
05:02:14 <accel> merijn: after that, implement duke nukem forever 2
05:02:20 <alpounet> haha
05:02:24 <edwardk> ooh you could import Data.Functor.Plus from semigroupoids then use zero instead of empty. ;)
05:02:35 <benmachine> move up to tetris with a realistic physics engine
05:02:36 <edwardk> or Data.Default and use def
05:03:01 <merijn> I suffer from over designing/hyperrealism syndrome ruining any chance of me ever finishing writing a game :p
05:03:16 <alpounet> merijn, even a tic tac toe?
05:03:18 <alpounet> :P
05:03:23 <merijn> (Until we get to computers powerful enough to simulate every single atom in a shooter :p)
05:03:33 <accel> alpounet: have you tried simulating people draw x's and o's?
05:03:38 <merijn> alpounet: Any non-boring game :p
05:03:51 <accel> alpounet: you need to model the type of apper, the type of pencil lead, and this doesn't take into account fountain pens, or worse, paint brushes
05:04:08 <alpounet> haha
05:05:11 <kfr> merijn: In 3D games 90%+ of the work is the artwork :|
05:05:35 <benmachine> write games about charismatic multicoloured spheres
05:05:45 <merijn> :D
05:06:03 <alpounet> merijn, have you seen http://raincat.bysusanlin.com/ ? :P
05:06:03 <kfr> I'm no good at modelling/skinning/animating, although I have done all of them at one point or the other
05:06:06 <accel> even worse than static artwork: animations
05:06:28 <kfr> I have three artist IRC mates, two of them 2D, one 3D
05:06:37 <kfr> But I doubt I could get them interested in this
05:06:43 <Twey> Haha
05:06:52 <kfr> Although one of them develops games privately for fun
05:07:15 <Twey> That was a peculiar thing to read: ‘I have three … mates, two of them 2D, one 3D’
05:07:21 <benmachine> I accidentally ran raincat the other day by mistyping firefox (how that even worked I don't know) and suddenly found that it worked again
05:07:26 <Veinor> Twey: haha
05:07:28 <benmachine> (it never used to work)
05:07:34 <benmachine> anyway it was like, awwww
05:07:51 <benmachine> couldn't work out the last level though
05:08:12 <alpounet> heh
05:08:57 <Twey> Haha, the testimonials
05:09:05 <Twey> ‘Watching the cat walk is so soothing’
05:09:22 <Twey> ‘He's so cute!  Look at him go… go, Raincat, go!’
05:09:51 <benmachine> the animations are what make that game I think
05:11:51 <Bynbo7akaAxman6> > reverse . take 20 . reverse . map head $ cake
05:11:53 <lambdabot>   "NTOATTOOTOOTASCIICAT"
05:12:03 <Bynbo7akaAxman6> damn, counting fail
05:12:07 <Bynbo7akaAxman6> > reverse . take 16 . reverse . map head $ cake
05:12:09 <lambdabot>   "TTOOTOOTASCIICAT"
05:12:14 <Bynbo7akaAxman6> > reverse . take 15 . reverse . map head $ cake
05:12:16 <lambdabot>   "TOOTOOTASCIICAT"
05:12:59 <dafis> > cake
05:13:01 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
05:13:08 <Veinor> > length cake
05:13:10 <lambdabot>   42
05:13:25 <dafis> > map head cake
05:13:27 <lambdabot>   "OOTFOTOTDFFFFFPFCOAUFANTOATTOOTOOTASCIICAT"
05:13:27 <kfr> map (\x -> Just x) pairs -- can this be made any shorter?
05:13:46 <Twey> kfr: map Just pairs
05:13:47 <benmachine> :t Just
05:13:48 <lambdabot> forall a. a -> Maybe a
05:13:55 <kfr> Oh, silly
05:13:59 * hackagebot xml-enumerator 0.1.1 - Pure-Haskell utilities for dealing with XML with the enumerator package.  http://hackage.haskell.org/package/xml-enumerator-0.1.1 (MichaelSnoyman)
05:15:06 <Veinor> :t Just . pairs
05:15:07 <lambdabot> forall a. [a] -> Maybe [(a, a)]
05:15:15 <Veinor> whoops.
05:15:19 <benmachine> :t pairs
05:15:20 <lambdabot> forall a. [a] -> [(a, a)]
05:15:23 <benmachine> huh
05:15:28 <benmachine> erm
05:15:30 <Bynbo7akaAxman6> > pairs  [1..10]
05:15:31 <benmachine> what is that for :P
05:15:32 <lambdabot>   [(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,3),(2,4),(2,5),(...
05:15:34 <benmachine> ohh
05:15:35 <benmachine> those pairs
05:15:40 <Bynbo7akaAxman6> :o
05:15:47 * benmachine thought it was just map (join (,))
05:15:50 <kfr> Oh, pairs is already in Prelude? Snap
05:16:02 <benmachine> kfr: nope
05:16:05 <Bynbo7akaAxman6> i don't believe it is
05:16:06 <edwardk> kfr: i think it was an earlier golf session
05:16:39 <Bynbo7akaAxman6> > ler ps = join (liftM2 (,)) in ps
05:16:40 <lambdabot>   <no location info>: parse error on input `='
05:16:46 <Bynbo7akaAxman6> > let ps = join (liftM2 (,)) in ps
05:16:47 <lambdabot>   Overlapping instances for GHC.Show.Show (m a2 -> m (a2, a2))
05:16:47 <lambdabot>    arising fro...
05:16:56 <Bynbo7akaAxman6> :t let ps = join (liftM2 (,)) in ps
05:16:57 <lambdabot> forall (m :: * -> *) a2. (Monad m) => m a2 -> m (a2, a2)
05:17:32 <Cin> Is there a Haskell utility for watching for when a file changes? Other than checking the last modified date on an interval...
05:17:38 <bsjtuje> where does chrisdone work?
05:18:15 <ivanm> aristid: a company in Italy IIRC
05:18:26 <Saizan> Cin: hinotify, on linux
05:18:26 <ivanm> Cin: don't think so
05:18:35 <ivanm> oh, forgot about hinotify
05:19:02 <Bynbo7akaAxman6> > let ps = join (liftM2 (,)) in ps [1,2,3]
05:19:03 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
05:19:14 <aristid> ivanm: ah, thanks.
05:19:17 <Cin> Saizan: Thanks! Just what I was looking for. I didn't expect it to exist. :-)
05:19:17 <Bynbo7akaAxman6> > let ps = join (liftM2 (,)) in ps (Right 1)
05:19:18 <lambdabot>   Overlapping instances for GHC.Base.Monad (Data.Either.Either a)
05:19:18 <lambdabot>    arising ...
05:22:05 <alpounet> hum?
05:22:53 <merijn> Cin: You could always use the FFI to use whatever platform specific functionality there is
05:25:08 <kfr> Hmm can you even make map (\x -> [x]) pairs shorter?
05:25:17 <Cin> map return
05:25:22 <benmachine> map (:[])
05:25:36 <kfr> Ahhh nice one
05:26:19 <Cin> also map pure
05:26:28 <Cin> > map pure [1..5]
05:26:29 <lambdabot>   No instance for (GHC.Show.Show (f a))
05:26:30 <lambdabot>    arising from a use of `M1303893208...
05:26:31 <Bynbo7akaAxman6> map monkey!
05:27:11 <benmachine> > map pure [1 .. 5] :: [[Integer]]
05:27:12 <lambdabot>   [[1],[2],[3],[4],[5]]
05:29:12 <kfr> Haha, Hoogle is so great
05:29:15 <kfr> Ord a => [a] -> a
05:29:21 <kfr> Got me exactly what I wanted
05:29:34 <aristid> @hoogle Ord a => [a] -> a
05:29:34 <lambdabot> Prelude maximum :: Ord a => [a] -> a
05:29:34 <lambdabot> Prelude minimum :: Ord a => [a] -> a
05:29:35 <lambdabot> Data.List maximum :: Ord a => [a] -> a
05:29:38 <kfr> I have yet to come across any other language which has anything like this
05:29:43 <aristid> kfr: minimum? maximum?
05:29:48 <kfr> The latter :p
05:29:51 <benmachine> beware of the empty list!
05:29:59 <kfr> NEVER
05:30:03 <kfr> I love runtime exceptions.
05:30:11 <McManiaC> yeh
05:30:11 <merijn> I <3 Hoogle :>
05:30:12 <benmachine> :t maybeToList . sort
05:30:12 <lambdabot>     Couldn't match expected type `Maybe a' against inferred type `[a1]'
05:30:12 <lambdabot>       Expected type: [a1] -> Maybe a
05:30:14 <McManiaC> without them it's no fun
05:30:18 <benmachine> er
05:30:23 <benmachine> :t listToMaybe . sort
05:30:24 <lambdabot> forall a. (Ord a) => [a] -> Maybe a
05:30:36 <merijn> :t listToMaybe
05:30:36 <lambdabot> forall a. [a] -> Maybe a
05:30:37 <benmachine> apparently has good running time
05:30:51 <Bynbo7akaAxman6> i wish that there was some way to specify that functions might throw exceptions in their type
05:31:06 <benmachine> Bynbo7akaAxman6: I wish you could have a type of total functions
05:31:08 <benmachine> slash values
05:31:13 <benmachine> in general
05:31:16 <Bynbo7akaAxman6> yeah
05:31:28 <benmachine> and then unsafePerformNonTerminating ofc >_>
05:31:29 <Bynbo7akaAxman6> would be nice to know your code will handle everything nicely
05:31:39 <merijn> Bynbo7akaAxman6: That's impossible :p
05:31:48 <benmachine> merijn: it's impossible *in general*
05:32:02 <benmachine> there are lots of programs you can prove will terminate
05:32:18 <benmachine> there is just no general algorithm that works for everything
05:32:32 <Bynbo7akaAxman6> i'm not sure what i want has anything to do with non-termination
05:32:51 <merijn> It is impossible to know your code will handle everything nicely until we finally solve whether quantum mechanics or string theory are right and have formally verified hardware :>
05:33:25 <McManiaC> merijn: bohemian mechanics :>
05:33:27 <benmachine> merijn: well, hmm. I'd argue that if a stray electron flips a bit then it's not the fault of your code
05:33:33 <merijn> benmachine: Whether a program will handle everything nicely is very different from whether its terminating ofc
05:33:55 <merijn> benmachine: True, but it does mean you haven't proven it'll always work nicely :p
05:34:21 <benmachine> merijn: yes you have, if you accept that programs have semantics independent of hardware
05:34:51 <merijn> You have just proven it'll "probably will work nicely with probability 1 minus epsilon", epsilon being the chance of random fatal hardware malfunction :>
05:35:01 <benmachine> nope
05:35:15 <benmachine> you've proven "it would definitely work, if only we could build any computer that could run it"
05:35:23 <benmachine> "as it is we'll just have to approximate how it works"
05:35:36 <opqdonut> correctness of execution == correctness of program + correctness of hardware
05:35:38 <merijn> benmachine: If you separate the program semantics from hardware, then yes
05:36:16 <benmachine> merijn: I do!
05:36:46 <merijn> I think I should finally skip ahead in my "to read" queue and read "Probabilistic Logics and the Synthesis of Reliable Organisms from Unreliable Components" before I keep arguing this point :>
05:37:07 <opqdonut> :)
05:37:10 <kfr> Can you make length x > 0 any shorter?
05:37:13 <merijn> Because Von Neumann claims it is possible to create reliable components out of unreliable ones, so in that case it should be possible
05:37:17 <kfr> not $ null x hmm
05:37:19 <opqdonut> kfr: not . null
05:37:48 <opqdonut> of course, if you're relying on the side effect that length evaluates the whole list
05:37:48 <merijn> "(>0) . length" but that is probably longer then "not . null"
05:37:51 <opqdonut> then no
05:38:13 <merijn> opqdonut: How could you rely on side effects of that?
05:38:45 <opqdonut> well it's operationally different
05:39:17 <opqdonut> your program having reasonable performance might depend on forcing the spine of the list at that point
05:39:27 <opqdonut> but probably not in kfr's case :)
05:41:41 <aristid> opqdonut: _most_ of the time, not . null is probably better :)
05:42:40 <dafis> opqdonut: what aristid said
05:43:42 <benmachine> :t foldr (const . const True) False
05:43:43 <lambdabot> forall a. [a] -> Bool
05:44:03 <opqdonut> of course, I wasn't contesting that :)
05:44:24 <opqdonut> I merely said that not . null is not (operationally) equivalent to length xs > 0 :)
05:45:49 <benmachine> this is true
05:48:14 <doserj> it's not even semantically equivalent
05:48:35 <dafis> opqdonut: in particular since length xs > 0 may not terminate in more cases than not . null
05:49:08 <Bynbo7akaAxman6> > let xs = xs ++ [head xs] in xs
05:49:12 <lambdabot>   mueval-core: Time limit exceeded
05:49:28 <Bynbo7akaAxman6> > let xs = [head xs] in xs
05:49:32 <lambdabot>   mueval-core: Time limit exceeded
05:50:14 <Bynbo7akaAxman6> heh, i like that one, feels kinda schrodinger-ish
05:51:29 <Veinor> :t fix (\x -> [head x])
05:51:30 <lambdabot> forall t. [t]
05:51:33 <Veinor> ha
05:53:56 <opqdonut> doserj, dafis: good point
05:54:10 * hackagebot qd 0.4 - double-double and quad-double number type via libqd  http://hackage.haskell.org/package/qd-0.4 (ClaudeHeilandAllen)
05:58:49 <dafis> opqdonut: My policy is to never use length unless I really want to know it. If I need to force the spine of a list, there are other ways and it's better to be obvious about it.
05:59:49 <opqdonut> sure
06:00:21 <opqdonut> hmmh, my fingertree seems way slower than an imperative red-black-tree
06:00:59 <dafis> opqdonut: way slower as in four times, or way slower as in orders of magnitude?
06:01:03 <Olathe> > if length [1..] == 0 then 1 else 1
06:01:07 <lambdabot>   mueval-core: Time limit exceeded
06:01:52 <opqdonut> dafis: 5min vs 5sec
06:01:58 <Bynbo7akaAxman6> heh
06:01:59 <Bynbo7akaAxman6> ouch
06:02:27 <dafis> opqdonut: too much laziness? too little?
06:02:29 <opqdonut> shouldn't "measure a-piece-of-a-finger-tree" be cheap?
06:03:01 <opqdonut> dafis: building the structure should be strict enough
06:03:07 <opqdonut> I'm only benchmarking queries
06:03:16 <opqdonut> but I guess I'll have to verify that
06:14:59 <benmachine> :t join (foldr seq)
06:15:00 <lambdabot> forall a. [a] -> [a]
06:15:25 <benmachine> hmm no that isn't what I want
06:18:46 <Kaidelong> :t parMap rwhnf id
06:18:47 <lambdabot> forall a. [a] -> [a]
06:18:55 <Kaidelong> perhaps that is what you want benmachine?
06:19:21 <Kaidelong> > parMap rwhnf id [4,5,2,undefined,5]
06:19:23 <lambdabot>   [4,5,2,*Exception: Prelude.undefined
06:19:34 <Kaidelong> errm
06:19:41 <Kaidelong> > head (parMap rwhnf id [4,5,2,undefined,5])
06:19:43 <lambdabot>   4
06:19:48 <Kaidelong> okay then it isn't!
06:19:50 <Kaidelong> I am surprised
06:20:01 <merijn> Any clues why this throws a bunch of errors in ghci? "[(x,y) | x <- [1..1024], y <- [1..1024], x*y < 1024 && (x*y) rem 32 == 0 && x rem 32 == 0]"
06:20:04 <merijn> oh, duh
06:20:09 <merijn> No quotes around rem >.>
06:20:26 <Kaidelong> > head (parMap rnf id [4,5,2,undefined,5])
06:20:27 <lambdabot>   Not in scope: `rnf'
06:21:10 <Kakarott> Greetings. I want a random number: "let i = Rand.getStdRandom ( Rand.randomR ( 1 , len))" gives me a "IO Int" and "i <- Rand.getStdRandom ( Rand.randomR ( 1 , len))" gives an "IO b". How do I get an Int ??
06:21:38 <Kaidelong> > head $ parList rwhnf [1,2,4,undefined]
06:21:40 <lambdabot>   Couldn't match expected type `[a]'
06:21:40 <lambdabot>         against inferred type `Control.P...
06:22:24 <Bynbo7akaAxman6> Kaidelong: you can either pass a seed value to mkStdGen or use IO
06:22:27 <Kaidelong> > head $ using (parList rwhnf) [1,2,4,undefined]
06:22:29 <lambdabot>   Couldn't match expected type `Control.Parallel.Strategies.Strategy
06:22:29 <lambdabot>         ...
06:22:34 <Bynbo7akaAxman6> > random (mkStdGen 7) :: Int
06:22:35 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
06:22:35 <lambdabot>         against inferred type ...
06:22:39 <Bynbo7akaAxman6> :t random
06:22:40 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
06:22:40 * Kaidelong completely forgot about this library
06:22:45 <Kakarott> > :i i = Rand.getStdRandom ( Rand.randomR ( 1 , 10))
06:22:46 <lambdabot>   <no location info>: parse error on input `:'
06:22:52 <Bynbo7akaAxman6> > fst $ random (mkStdGen 7) :: Int
06:22:52 <lambdabot>   5400045519604638010
06:22:57 <Kaidelong> Bynbo7akaAxman6: are you sure you meant to highlight me?
06:22:58 <Bynbo7akaAxman6> > fst $ random (mkStdGen 8) :: Int
06:22:59 <lambdabot>   -399898935113516200
06:23:06 <Bynbo7akaAxman6> sorry, means Kakarott 
06:23:10 <Bynbo7akaAxman6> meant*
06:23:17 <Yrogirg> Hello! Do you have to know machine codes to write a compiler? Or having already working compiler is enough?
06:23:23 <Cin> Hint sure likes to freeze without messages a lot.
06:23:27 * Kaidelong recommends MonadRandom instead
06:23:39 <Kakarott> fst ?
06:23:48 <Bynbo7akaAxman6> :t fst
06:23:48 <lambdabot> forall a b. (a, b) -> a
06:23:53 <ion> yrogirg: Probably better use llvm.
06:24:08 <Kaidelong> Kakarott: random numbers without MonadRandom wrapping it means you pass the generator state in a tuple
06:24:28 <Kaidelong> the fst extracts the first element of a binary tuple, which is what you want in this case
06:24:44 <merijn> Yrogirg: Depends what you are compiling to
06:24:47 <Kaidelong> @ty random
06:24:48 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
06:25:13 <Kaidelong> @ty evalRand --monadrandom
06:25:14 <lambdabot> forall g a. (RandomGen g) => Rand g a -> g -> a
06:25:23 <merijn> Yrogirg: You need to know the language you are compiling to, so if you want to compiler to machine code, then you need to know it. However you could also compile to (for example) C, in which case you need to know C
06:25:34 <Kakarott> haskell is so much not my language :(
06:25:42 <merijn> Kakarott: How so?
06:25:48 <Kaidelong> Kakarott: What is your background at this point?
06:26:01 <merijn> Also, what are you using to learn Haskell?
06:26:03 <Yrogirg> merijn: compiling to a machine code. Thank you.
06:26:07 <Kaidelong> getting rid of side effects is good
06:26:11 <Kakarott> Have it in a course at university
06:26:16 <merijn> Yrogirg: You might wanna check out LLVM
06:26:55 <Kakarott> tomorrow is oral exam
06:27:06 <Kakarott> and need to do my project a little better
06:27:19 <merijn> Kakarott: The main problem with Haskell is that if you've only seen one type of programming before (usually C/Java/C#/C++ etc) then you think that's the only way to do it. It took me months and several attempts to untrain my bad habits of other languages before I understood haskell
06:27:47 <Kakarott> I don't have month :D
06:28:17 <Cin> An oral exam in programming?
06:28:47 <Kaidelong> > head $ [1,2,4,undefined] `using` parList rwhnf
06:28:47 <ion> cin: Why not?
06:28:48 <lambdabot>   Precedence parsing error
06:28:48 <lambdabot>      cannot mix `GHC.Base.$' [infixr 0] and `Contr...
06:28:57 <Kaidelong> > head $ ([1,2,4,undefined] `using` parList rwhnf)
06:28:59 <lambdabot>   1
06:29:00 <fryguybob> Kakarott: If you have a function who's result is random it is non-deterministic and needs to be noted as such by its type in Haskell.
06:29:04 <Kaidelong> bah
06:29:18 <Kakarott> on a different line of my code i have "_in <- getLine"  and I get a String out of the IO String so why not the same with IO Int ... *confused*
06:29:40 <Cin> > Control.Monad.Random.evalRand (do a <- getRandomR (1,6); b <- getRandomR (1,6); return (a,b)) (mkStdGen 100)
06:29:41 <lambdabot>   (6,3)
06:29:48 <fryguybob> Kakarott: You can but that <- notation is "inside" IO.
06:29:49 <Kakarott> Cin: Yes. Oral exam.
06:30:16 <Cin> > mkStdGen 100 `evalRand` (do a <- getRandomRs (1,6); b <- getRandomR (1,6); return (a,b))
06:30:17 <lambdabot>   Couldn't match expected type `Control.Monad.Random.Rand g a'
06:30:18 <lambdabot>         agains...
06:30:28 <Cin> > flip evalRand (mkStdGen 100) (do a <- getRandomRs (1,6); b <- getRandomR (1,6); return (a,b))
06:30:30 <lambdabot>   ([6,1,5,3,3,5,5,1,4,5,2,4,6,2,4,5,1,2,3,2,1,2,2,5,6,3,4,6,1,1,6,1,3,4,1,2,4...
06:30:49 <mangibu> does anyone know why projects.hashell.org is down?
06:30:53 <Twey> Kakarott: do notation is a bit confusing like that
06:31:02 <Kakarott> but getLine gives IO String
06:31:10 <Twey> Kakarott: You're not really ‘getting it out’ of the monad as you are pushing everything that follows *into* the monad
06:31:16 <Feuerbach> mangibu: they're migrating to a new server
06:31:17 <Cin> mangibu: Because the hosting is a complete mess, it has been down for a long time, and has been going up and down for a long time.
06:31:58 <Bynbo7akaAxman6> Cin: the server got hacked, so they're moving everything to a better place
06:31:58 <fryguybob> @undo do l <- getLine; return (l ++ " is what you said.")
06:31:59 <lambdabot> getLine >>= \ l -> return (l ++ " is what you said.")
06:32:28 <Kaidelong> Kakarott: if it helps, your ultimate goal in haskell is to build a program that can be run, and an "IO String" is a simple program that you can build up on using things like liftM, >>= and the like
06:32:35 <Cin> Bynbo7akaAxman6: Well, more precisely, have been moving to a better place for a long time.
06:32:54 <Kakarott> The problem is not "me". I mean i get the IO Int. But my next line wants an Int and not an IO Int: let i = fst (Rand.getStdRandom ( Rand.randomR ( 1 , len))) ;; let j = (!!) fol (i - 1)
06:32:56 <Bynbo7akaAxman6> well no, c.h.o only started moving when it got hacked, a few days ago
06:33:01 <Kakarott> My program was working
06:33:15 <Bynbo7akaAxman6> haskell.org moved a while ago
06:33:17 <Cin> Everything was supposed to move but they said oh let's leave projects.*
06:33:21 <Kakarott> I try to get an MonteCarlo-Bot inside
06:33:28 <Kaidelong> @ty (>>=) --Kakarott
06:33:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
06:33:34 <Kakarott> and he needs some random
06:33:47 <Kaidelong> @ty liftM --also for Kakarott
06:33:48 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
06:34:01 <Kakarott>  Kaidelong: Just confuses me :D
06:34:06 <Kaidelong> so if you have a function that needs an Int
06:34:10 <Kaidelong> but you have an IO int
06:34:15 <Kaidelong> you can use "liftM"
06:34:50 <hpc> (also known as fmap :D)
06:35:37 <aristid> (and as <$>)
06:35:42 <aristid> (and in some circles a .)
06:36:09 <ben> I am beginning to suspect that the haskell standard library is, like, four functions total re-exported over and over
06:36:25 <fryguybob> > fmap (+1) [1..]
06:36:26 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
06:36:43 <Kaidelong> > evalRand (mkStdGen 8) $ liftM (take <*> repeat) getRandom
06:36:45 <lambdabot>   Couldn't match expected type `Control.Monad.Random.Rand a a1'
06:36:45 <lambdabot>         again...
06:36:55 <dafis> ben: no, 7
06:37:05 <Kaidelong> > evalRand (mkStdGen 8) $ liftM (take <*> repeat) (getRandomR (1,4))
06:37:07 <lambdabot>   Couldn't match expected type `Control.Monad.Random.Rand a a1'
06:37:07 <lambdabot>         again...
06:37:30 <Kaidelong> @ty getRandomR
06:37:31 <lambdabot> forall a (m :: * -> *). (MonadRandom m, Random a) => (a, a) -> m a
06:37:34 <aristid> :t take <*> repeat
06:37:36 <lambdabot> Int -> [Int]
06:37:45 <aristid> :t flip take =<< repeat
06:37:46 <lambdabot> Int -> [Int]
06:37:48 <Twey> ben: Heheheh, not too far off
06:37:49 <aristid> \o/
06:38:03 <Kaidelong> > (take <*> repeat) 5
06:38:04 <lambdabot>   [5,5,5,5,5]
06:38:08 <Twey> ben: More like it *would* be four functions, if they'd gotten the typeclasses right
06:38:08 <ion> > let f = liftM4 (,,,) (r 10) (r 20) (r 30) (r 40); r max = state $ randomR (0, max :: Integer) in evalState f (mkStdGen 0)
06:38:09 <lambdabot>   (0,2,30,33)
06:38:11 <mangibu> Does anyone know where I can download the haskell-mode for vim? I would like to try it out.
06:38:56 <Kaidelong> > getRandomR (1,4) >>= (return . (take <*> repeat))
06:38:57 <lambdabot>   No instance for (GHC.Show.Show (m [GHC.Types.Int]))
06:38:58 <lambdabot>    arising from a use o...
06:39:25 <Kaidelong> > evalRand (mkStdGen 8)  (getRandomR (1,4) >>= (return . (take <*> repeat)))
06:39:27 <lambdabot>   Couldn't match expected type `Control.Monad.Random.Rand g a'
06:39:27 <lambdabot>         agains...
06:39:43 <Kaidelong> oh so I've just forgotten how to use evalRand
06:39:48 <Cin> Twey: From a committee that came up with "let's change map :: Functor f => (a -> b) -> f a -> f b) to (a -> b) -> [a] -> [b]" and "lets get rid of monad comprehensions", I'm not surprised the Prelude is lacking in overloading.
06:39:51 <Kaidelong> @ty evalRand
06:39:52 <lambdabot> forall g a. (RandomGen g) => Rand g a -> g -> a
06:40:03 <fryguybob> Kakarott: If you have a function that takes an Int (that is Int -> Foo) and you have an IO Int and you want an IO Foo, then fmap (or liftM) does that for you.
06:40:05 <Kaidelong> > flip evalRand (mkStdGen 8)  (getRandomR (1,4) >>= (return . (take <*> repeat)))
06:40:07 <lambdabot>   [4,4,4,4]
06:40:11 <Kaidelong> finally
06:40:22 <Twey> Cin: Truly
06:40:54 <Cin> Hmm. Peculiar behaviour when using Hint with threads.
06:42:05 <Cin> It blocks on the `interpret` function. Used by itself in IO it works, but in conjunction with other running threads, not so.
06:42:59 <aristid> :t return . (take <*> repeat)
06:43:00 <lambdabot> forall (m :: * -> *). (Monad m) => Int -> m [Int]
06:43:09 <aristid> :t (return . take) <*> repeat
06:43:10 <lambdabot> forall a. Int -> [a] -> [a]
06:43:54 <aristid> > flip evalRand (mkStdGen 8)  (take <*> repeat <$> getRandomR (1,4))
06:43:56 <lambdabot>   [4,4,4,4]
06:44:05 <aristid> Kaidelong: :)
06:44:34 <Kakarott> Now some code: http://pastebin.com/vH30ssxK
06:44:37 <aristid> we definitely need an infix version of flip (<$>)
06:44:51 <aristid> @where hpaste
06:44:52 <lambdabot> http://hpaste.org/
06:44:57 <Kakarott> Line 137 138 is a problem
06:44:59 <Kaidelong> aristid: <$> is not guaranteed though
06:44:59 <aristid> Kakarott: hpaste is better than pastebin
06:45:05 <Kaidelong> aristid: I recommend .>
06:45:06 <aristid> Kaidelong: `liftM` is.
06:45:16 <Kaidelong> fpipe already defines .>
06:45:21 <Kaidelong> but in terms of .
06:45:21 <aristid> ok
06:45:29 <aristid> in terms of .? bummer
06:45:29 <Kaidelong> but you could just redefine . as fmap and be done with it
06:45:31 <hpc> :t (.>)
06:45:32 <lambdabot> Not in scope: `.>'
06:45:43 <Kaidelong> lambdabot does not have fpipe loaded I don't think
06:45:53 <Kaidelong> fpipe defines a flipped . and $, basically
06:46:01 <Kaidelong> .> and $> respectively
06:46:03 <Kakarott> http://hpaste.org/43433/io_int
06:46:25 <Kaidelong> (corresponding to F# >> and |>)
06:46:46 <Twey> Also a flipped (>>)
06:46:47 <Kakarott> Line 137 & 138
06:46:54 <Twey> You'd think there would be a << to match =<<, but noo
06:47:07 <Saizan> <*
06:47:21 * hackagebot nanoparsec 0.1.1 - An implementation of attoparsec-like parser around list-like  http://hackage.haskell.org/package/nanoparsec-0.1.1 (MaciejPiechotka)
06:48:45 <Twey> :t (<*)
06:48:46 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
06:49:05 <Twey> Ooh, of course
06:50:00 <fryguybob> Kakarott: You need to either make a source of random numbers a parameter to eva or make eva return a result in IO or another appropriate monad.
06:50:06 <Cin> There's a (<$) in Prelude's class definition of Functor now and no one's saying a word about it.
06:50:19 <Veinor> man i sure do love the numeric prelude :|
06:50:21 <Kakarott> Thats no problem
06:50:27 <Kakarott> (forgot to change)
06:50:32 <Cin> It just crept in while no one was looking, took its coat off and sat down, pretending it had been here all this time.
06:50:51 <Kaidelong> @ty (<$)
06:50:52 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
06:51:15 <Veinor> @src (<$)
06:51:16 <lambdabot> (<$) = (<$>) . const
06:51:17 <Kaidelong> Kakarott: what is the type error you get if you uncomment eva?
06:51:53 <Kakarott> aaaaaaaaaaaaahhh
06:52:06 <dafis> interesting error, never had that
06:52:17 <Kakarott> thought it was only line 137 138 which where causing problems
06:52:26 <Kakarott> *turning crazy*
06:52:31 <Kakarott> Thank you
06:52:32 <Kakarott> :)
06:52:37 <Kaidelong> Kakarott: for that matter, why are you using do there?
06:52:53 <Kaidelong> if you're returning an Int there is no need for do
06:53:02 <Kaidelong> just use the "let... in..." syntax
06:53:16 <Kakarott> trying to get my idea in and after that reducing code until no do is needed
06:53:34 <Kakarott> me is pure beginner
06:55:37 <dafis> Kakarott: incidentally, the 'do' mustn't be in eva, it's only possible to use do in Monads
06:56:22 <Kakarott> it is possible here or just "works"
06:57:02 <Twey> > do { let { x = 5 }; x }
06:57:03 <lambdabot>   5
06:57:08 <Twey> dafis: ^ look ma, no monads 
06:57:09 <Bynbo7akaAxman6> :O
06:57:19 <Bynbo7akaAxman6> :t do { let { x = 5 }; x }
06:57:20 <lambdabot> forall t. (Num t) => t
06:57:29 <Bynbo7akaAxman6> :t do { let { x = 5 }; x; x }
06:57:30 <lambdabot> forall (m :: * -> *) a b. (Num (m a), Num (m b), Monad m) => m b
06:57:36 <Twey> It's pretty much straight lexical translation
06:57:40 <dafis> Twey: IO in REPL ?
06:57:41 <Bynbo7akaAxman6> ah yes
06:57:49 <Twey> So long as you don't do anything that will translate to a >>= or >>, you don't need a monad
06:58:11 <Twey> dafis: Beg pardon?
06:59:04 <dafis> Twey: thought it might be that it's like in ghci
06:59:11 <Twey> Ah, no
06:59:18 <Olathe> @undo  do { let { x = 5 }; x; x }
06:59:18 <lambdabot> let { x = 5} in x >> x
06:59:43 <Olathe> @undo  do { let { x = 5 }; x }
06:59:44 <lambdabot> let { x = 5} in x
06:59:55 <Twey> > do 5
06:59:56 <lambdabot>   5
06:59:58 <Twey> \o/
07:00:42 <ion> @undo do let x = 5; let y = 6; (x, y) {- Does undo format this in a pretty way? -}
07:00:42 <lambdabot>  Parse error at "let" (column 15)
07:01:02 <ion> Ah, { } are needed there.
07:01:07 <Twey> Yeah
07:01:17 <Olathe> @undo do { let x = 5; let y = 6; (x, y) }
07:01:17 <lambdabot>  Parse error at "let" (column 17)
07:01:23 <Twey> Not there
07:01:26 <Twey> @undo do let {x = 5}; let {y = 6}; (x, y)
07:01:26 <lambdabot> let { x = 5} in let { y = 6} in (x, y)
07:01:30 <Olathe> Ahh :)
07:01:38 <Olathe> The joys of syntax no one uses :)
07:01:46 <Twey> Heh
07:02:21 <Kaidelong> Kakarott: http://hpaste.org/paste/43433/io_int__annotation#p43435
07:02:23 <ion> Oh noes, it’s not intelligent enough to merge the let statements. I want my money back.
07:02:25 <Twey> It's pretty simple if you think about it.  If you don't include the braces, it starts trying to parse a new pattern.
07:02:32 <ion> yeah
07:02:56 <Twey> ion: Hm, I'm not sure that's always permissible
07:02:57 <dafis> Twey: urg = do { let { x = 5 }; x }
07:02:59 <dafis> ERROR "./Foo.hs":7 - Unresolved top-level overloading
07:02:59 <dafis> *** Binding             : urg
07:02:59 <dafis> *** Outstanding context : (Monad b, Num (b c))
07:03:03 <dafis> says hugs
07:03:18 <Twey> dafis: I never said hugs did it the same way :þ
07:03:38 <dafis> I guess it's a GHC-ism
07:03:51 <dafis> so, not Haskell (98/2010)
07:06:01 <Kakarott> @Kaidelong:
07:06:01 <lambdabot> Unknown command, try @list
07:06:02 <Kakarott> Couldn't match expected type `(a, b)'
07:06:02 <Kakarott>            against inferred type `IO Int'
07:06:02 <Kakarott>     In the first argument of `fst', namely
07:06:02 <Kakarott>         `(Rand.getStdRandom (Rand.randomR (1, len)))'
07:06:14 <mangibu> I'm using ERC Version 5.3 with GNU Emacs 23.1.1 (i486-pc-linux-gnu, GTK+ Version 2.20.0, multi-tty) of 2010-03-29.
07:06:35 <Kaidelong> @ty Rand.getStdRandom
07:06:36 <lambdabot> Couldn't find qualified module.
07:06:41 <Kaidelong> @ty getStdRandom
07:06:43 <lambdabot> forall a. (StdGen -> (a, StdGen)) -> IO a
07:07:13 <Kaidelong> @hoogle StdGen -> (a, StdGen)
07:07:14 <lambdabot> Control.Monad.State.Lazy runState :: State s a -> s -> (a, s)
07:07:14 <lambdabot> Control.Monad.State.Strict runState :: State s a -> s -> (a, s)
07:07:14 <lambdabot> System.Random random :: (Random a, RandomGen g) => g -> (a, g)
07:07:56 <Kaidelong> Kakarott: I see what your issue is then. Make a parameter to your function, a new first parameter
07:08:16 <Kaidelong> that parameter will be a StdGen
07:08:29 <Kaidelong> use "random thatParameter" instead of "getStdRandom"
07:08:50 <Kaidelong> and then pass your starting state in
07:09:07 <Kaidelong> of course this would all have been much nicer with MonadRandom...
07:09:41 <Kaidelong> basically the reason why you're getting an IO Int instead of an Int is because you're using the world as a hidden parameter there
07:10:21 <Kaidelong> getStdRandom inserts the world as a hidden parameter and ends up producing an IO a instead of just an a
07:10:30 <Kakarott> Yes
07:10:33 <Kaidelong> random does NOT add a hidden parameter, so it can make you an a
07:10:46 <Kakarott> But then how is that random ?
07:11:05 <Kaidelong> Kakarott: you can generate the parameter you'll pass eva randomly
07:11:11 <Kakarott> As i learned random needs something from "the World"
07:11:13 <dafis> Kakarott: same as with IO, the generator gets seeded on startup
07:12:08 <Kaidelong> Kakarott: that said, you are right, nothing is truly random outside of IO. Whch is why you will end up in IO at some point. Fine to do that in main, at the last minute
07:12:16 <Bynbo7akaAxman6> Kakarott: you can only get something from the world with IO
07:12:56 <Kaidelong> for now, just give eva an extra starting parameter that is the seed state of the random number generator
07:13:04 <Kaidelong> you might find that propagating through your code
07:13:11 <Kaidelong> (which is where MonadRandom is nice)
07:13:14 <Kaidelong> @where MonadRandom
07:13:15 <lambdabot> I know nothing about monadrandom.
07:13:52 <Kaidelong> http://hackage.haskell.org/packages/archive/MonadRandom/0.1.3/doc/html/Control-Monad-Random.html
07:13:58 <dafis> @hoogle Rand
07:13:59 <lambdabot> Test.QuickCheck rand :: Gen StdGen
07:13:59 <lambdabot> module System.Random
07:13:59 <lambdabot> System.Random class Random a
07:14:00 <Kaidelong> now how do I make lambdabot remember that?
07:14:52 <Kaidelong> well there is probably a better resource on it somewhere anyway
07:15:19 <gwern> Kaidelong: write a plugin to hayoo which knows about hackage packages?
07:16:47 * Kaidelong anyway, would really advise people to stay away from System.Random and use Control.Monad.Random instead, for most purposes
07:16:59 <Kaidelong> it is just so much easier to work with the latter
07:17:39 * Bynbo7akaAxman6 would recommend System.Random.Mersenne if you need speed
07:19:01 * ion would recommend ‘random = 4’ if you need even more speed.
07:19:22 <Kaidelong> chosen by fair dice roll
07:19:33 <Kakarott> ^^
07:20:49 * Kaidelong hmms, you could probably make a MonadRandom instance that works with System.Random.Mersenne if you wanted to
07:21:32 <Kaidelong> oh
07:21:35 <Kaidelong> no, no you can't
07:22:15 <Kaidelong> why does everything from MTRandom end up in IO? FFI? Shouldn't you unsafePerformIO out of it?
07:22:31 <Kaidelong> or is it truly nondeterministic
07:22:53 <Kaidelong> from the haskell POV
07:23:04 <luite> there's a slower version
07:23:56 <luite> but the original IO one uses an optimized implementation with a global state, optimized for simd instructions
07:23:57 <Bynbo7akaAxman6> Kaidelong: it uses some global state
07:24:12 <Kaidelong> yeah, I just figured that out!
07:24:14 <Kaidelong> shame too!
07:24:20 <Kaidelong> but I guess it helps to keep it on the CPU
07:24:26 <andres_> hi anybody knows like a short explanation about kind´s?
07:25:08 <Kaidelong> http://learnyouahaskell.com/making-our-own-types-and-typeclasses#kinds-and-some-type-foo
07:26:52 <luite> but if you're serious about random numbers, you might want to avoid MonadRandom and other code that relies on splittable rngs
07:27:34 <dankna> luite: why is that exactly?
07:27:47 <dankna> does the fact that it's splittable reduce the quality of the output?
07:28:20 <hpc> dankna: it's deterministic, would be the problem i think
07:28:36 <luite> dankna: well, not necessarily, but it's not been proven (or tested) that it doesn't
07:28:36 <Kaidelong> hpc: that's not a bad thing
07:28:48 <dankna> hpc: hm
07:28:55 <Kaidelong> I think the problem here is speed, though?
07:28:55 <dankna> luite: that's certainly fair
07:30:20 <Kaidelong> hpc: if you have a process that uses pseudo-randomness, and it is deterministic, you can make it testable. Also, pseudo-random numbers can at times be more fair than nondeterministic sources unless you're using something very reliable like nuclear decay
07:31:07 <dankna> well, you could always make it testable by saving the entire random-number stream and feeding that in in the test
07:31:26 <dankna> in the style of unit tests, where you're supposed to stub in all the interactions with other parts of the program not currently being tested
07:31:59 <Kakarott> @hoogle Int -> Double
07:31:59 <lambdabot> Prelude toEnum :: Enum a => Int -> a
07:31:59 <lambdabot> Prelude encodeFloat :: RealFloat a => Integer -> Int -> a
07:31:59 <lambdabot> Prelude scaleFloat :: RealFloat a => Int -> a -> a
07:32:13 <Kaidelong> @hoogle (Num a) => Int -> a
07:32:14 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
07:32:14 <lambdabot> Prelude abs :: Num a => a -> a
07:32:14 <lambdabot> Prelude negate :: Num a => a -> a
07:32:25 <Kaidelong> > fromIntegral 5 :: Double
07:32:26 <lambdabot>   5.0
07:32:33 <dankna> I remember reading once that what'shisname, the author of Doom, made the game's testing thing by doing something similar but with timestamps, thereby making the behavior deterministic
07:32:37 <Kakarott> nice, thx
07:32:51 <dankna> was an eye-opener for me at the time
07:33:36 * Kaidelong imagines that with things like games or such being impure with regard to randomness might really be a good thing for efficiency and an important thing
07:33:54 <Kaidelong> and you're going to be living in IO anyway
07:34:00 <dankna> well, games need to pay very careful attention to their randomness
07:34:04 <dankna> Doom famously didn't use any
07:34:04 <Kaidelong> since those applications tend to be interactive ones
07:34:13 <dankna> that was how its multiplayer mode was able to work without a server
07:34:29 <dankna> today we have more sophisticated techniques, but it worked at the time
07:34:40 <dankna> but yes, you're going to be living in IO
07:34:59 <Kaidelong> oooh right multiplayer games
07:35:07 * Kaidelong was not thinking of those at all
07:35:11 <dankna> hehe
07:35:24 <dankna> yeah, the enemy movements and everything were completely deterministic
07:35:40 <dankna> so each peer instance of the game came up with exactly the same movements
07:36:22 <dankna> obviously you could also achieve that effect by using a predictable PRNG with a seed that you synchronized in advance
07:36:44 <Zao> http://www.gamasutra.com/view/feature/3094/1500_archers_on_a_288_network_.php
07:36:52 <Kaidelong> dankna: barring desynchronization. But I suppose you can fix that with lag.
07:37:09 <dankna> oh neat, thanks Zao
07:37:38 <dankna> Kaidelong: well, I glossed over that.  what I believe Doom does when desynch happens is, it rewinds time to the point of the desynch and then plays everything forward again.
07:37:50 <dankna> you could do the same with a PRNG, although saving/restoring the state would have to be efficient.
07:37:54 <Zao> http://drilian.com/2009/05/30/networking-is-hard-part-2/
07:38:26 <aisamu> is 737KB (apple Kbytes, heh) ok for a compiled "main = putStrLn "Hello, World!"" or am I doing something wrong?
07:38:53 <dankna> aisamu: that seems big, but dunno
07:39:02 <dankna> I've never really paid attention to the size of my Haskell binaries
07:39:09 <Zao> dankna: Sounds like a reasonable size.
07:39:15 <Zao> Assuming that the RTS is statically linked.
07:39:20 <Bynbo7akaAxman6> or you could just leave before hetting an answer...
07:39:28 <dankna> heh oops
07:39:34 <Bynbo7akaAxman6> g*
07:39:42 <Zao> -rwxr-xr-x  1 zao  zao   561K Jan 30 16:53 foo
07:39:44 <dankna> yeah, okay, static RTS makes sense then
07:39:55 <dankna> not sure what he meant by Apple kilobytes, either
07:40:08 <dankna> is that like a Baker's dozen or something?
07:40:12 <Zao> dankna: OS X counts in thousands.
07:40:14 <dankna> !
07:40:16 <Zao> dankna: For great confusion.
07:40:23 <Bynbo7akaAxman6> dankna: apple uses 10^3 for a KB
07:40:24 <dankna> not with ls surely, only in the Finder?
07:40:32 <Zao> dankna: Heaven knows.
07:40:33 <Bynbo7akaAxman6> not sure if ls changed
07:40:37 <dankna> ah
07:40:43 <dankna> well, wow, I did not know that.  I am disappointed in them.
07:40:58 <Kaidelong> ah KiB vs KB
07:40:59 <Bynbo7akaAxman6> they changed with 10.6
07:41:11 <dankna> weird
07:41:34 <Bynbo7akaAxman6> seems ls uses 2^10
07:41:36 <Kaidelong> metric system does not make much sense for discrete values anyway
07:41:46 <Bynbo7akaAxman6> finder says a file is 33.9MB, ls says 32
07:42:26 <Zao> Bynbo7akaAxman6: Odd, I get different sizes on a linux box and a OSX box with ls -lah.
07:42:36 <Zao> 22K on OSX, 23K on Linux, for a 22648 file.
07:42:43 <Bynbo7akaAxman6> hmm
07:42:50 <dankna> oh that's cluster size
07:42:59 <dankna> not cluster, you know what I mean
07:43:01 <ion> Relevant-ish: https://wiki.ubuntu.com/UnitsPolicy
07:43:14 <geheimdienst> zao, probably has to do with the cluster size ... istr du -cb will help
07:43:35 <Zao> geheimdienst: They have the same size in bytes, why should -h change anything?
07:43:42 <Zao> Unless of course they have different rounding rules.
07:43:46 <dankna> the Age of Empires article was interesting, thanks to whoever linked it
07:43:53 <geheimdienst> yeah
07:44:33 <Kaidelong> Zao I believe is to thank for it
07:44:35 <Kaidelong> I liked it too
07:44:40 <dankna> :D
07:44:52 <hpc> ooh, that article
07:44:54 * hpc reads
07:45:23 <aisamu> @Bynbo7akaAxman6 I didn't leave because i wanted!! Blame crappy italian Fastweb, hahahaha
07:45:24 <lambdabot> Unknown command, try @list
07:45:38 <Bynbo7akaAxman6> aisamu: heh
07:45:57 <gwern> preflex: seen chrisdone
07:45:57 <preflex>  chrisdone was last seen on #haskell 1 day, 22 hours, 50 minutes and 4 seconds ago, saying: * chrisdone wrote an ircd recently so this is fresh in his mind
07:46:01 <Bynbo7akaAxman6> aisamu: haskell binaries are usually quite large, they're statically linked by default, and they all include the RTS
07:46:20 <gwern> @tell chrisdone 'Impure code is the evil genius who devises the master plan, tells the henchmen what to do, and keeps them in separate living quarters.' <-- that's the pure code innitit?
07:46:21 <lambdabot> Consider it noted.
07:46:53 <aisamu> @Bynbo7akaAxman6 ah, thanks!
07:46:53 <lambdabot> Unknown command, try @list
07:47:15 <Bynbo7akaAxman6> aisamu: foo: is preferred over @foo on IRC
07:47:17 <dankna> ERROR this is not twitter, @ means something different here
07:47:26 <Bynbo7akaAxman6> @vixen
07:47:26 <lambdabot> where can I a see a picture of you?? URL??
07:47:32 <aisamu> and oh, ls -lh says 719K, while finder says 737 KB on disk (735.944 bytes)
07:47:37 <dankna> hm
07:47:52 <Bynbo7akaAxman6> aisamu: .. decimal bytes? :o
07:48:31 <gwern> @eval 1+1
07:48:33 <Kaidelong> gwern: "imperative code" perhaps
07:48:37 <aisamu> Bynbo7akaAxman6: Thanks! Got spoiled by twitter and fb autocompletion that only triggers after an '@'
07:48:39 <dankna> some countries reverse the . and , in numeric notation
07:48:42 <gwern> axis of eval
07:48:44 <Kaidelong> but you could make that "pure" in the haskell sense
07:48:48 <dankna> clearly Italy is one of them
07:49:00 <Kaidelong> dankna: "1 000 000,000"
07:49:02 <Bynbo7akaAxman6> dankna: aaahhh, right :)
07:49:06 * geheimdienst thinks 1000 instead of 1024 is a good idea
07:49:26 <aisamu> Bynbo7akaAxman6:  hehehehe, go figure
07:49:29 <Bynbo7akaAxman6> gwern: well, it's technically correct, so it's probably a good idea
07:49:44 * Kaidelong thinks the Ki Mi .. etc convention is a good idea since the metric system does not make sense here anyway: what's a millibit or a centibit?
07:49:48 <dankna> I am pleased they are doing something consistent, but I wish that the consistent thing they had done was to change the column headers to say KiB, MiB etc
07:50:17 <Bynbo7akaAxman6> Kaidelong: they can make sense when talking about compression schemes
07:50:30 <Bynbo7akaAxman6> 4 centibits ber bit encoded
07:50:33 <dankna> nanobit is my new favorite word
07:50:41 <dankna> actually, nanobyte
07:50:42 <Kaidelong> Bynbo7akaAxman6: why not just use a ratio
07:51:09 <dankna> no, information theory really does deal in fractional bits, read Claude Shannon if you're interested
07:51:33 <aisamu> dankna: oh, sorry! i actually knew it, but as it seems that "muscle memory" really exists =)
07:51:37 <dankna> hehe
07:51:47 <ben> Kaidelong: a centibit per second is when my wireless is really shitty
07:51:50 <dankna> no worries, aisamu
07:51:50 <Kaidelong> dankna: that does not perclude using ratios
07:52:02 <Kaidelong> ben: that makes sense to me actually
07:52:09 <dankna> Kaidelong: well, okay.  I have no opinion on which makes more sense, not being an expert in the area.
07:52:10 <Kaidelong> since time is continuous
07:52:50 <Kaidelong> dankna: since the metric system perscribes fixed deliminations, I tend to think of it as most useful as having these logarithmic frames of reference for genuinely continuous things
07:53:10 <geheimdienst> i don't see what milli and centi have to do with the question of why we're still using the off-beat factor of 1024
07:53:21 <dankna> Kaidelong: yeah, that's true
07:53:42 <Kaidelong> although the enumerations you deal with in information theory are so big maybe it makes sense to think of them as "virtually continuous"
07:53:43 <aisamu> thanks for the answers! (you guys really never let a newbie down =)
07:53:48 <dankna> we try haha
07:54:50 * Kaidelong thinks the observation that "bits per second" is continuous even if bits aren't is an interesting one
07:55:01 <dankna> it is
07:55:24 <dankna> is the rule, then, that the measurement is continuous if any quantity going into it is?  I guess so.
07:56:04 <dafis> dankna: depends on the combining function
07:56:29 <dafis> if the combining function is discretely valued, ...
07:58:09 <dankna> hm, point.
07:58:26 <dafis> though, I can't think of a useful example
07:59:00 * Kaidelong forgot if the rational numbers were continuous or not
07:59:04 <Kaidelong> I think they are
07:59:11 <Kaidelong> because there is always an in-between value
07:59:15 <Kaidelong> between any two points
07:59:29 <Kaidelong> but I don't remember if that was what continuous meant
07:59:37 <dankna> neither do I, sorry
07:59:39 * hackagebot citeproc-hs 0.3.1 - A Citation Style Language implementation in Haskell  http://hackage.haskell.org/package/citeproc-hs-0.3.1 (AndreaRossato)
07:59:47 <Bynbo7akaAxman6> how can they be continuous if there's gaps like pi?
08:00:02 <benmachine> continuous is usually used to describe functions
08:00:07 <Bynbo7akaAxman6> this is a genuine question...
08:00:13 <dafis> Kaidelong: the rationals aren't continuous
08:00:20 <hpc> Bynbo7akaAxman6: a function can be continuous if it has gaps
08:00:27 <hpc> er
08:00:34 <hpc> no im dumb
08:00:41 <hpc> it can be differentiable
08:00:42 <benmachine> you can have a continuous function from rationals to rationals
08:01:07 <benmachine> hpc: pretty sure you can't be differentiable at a discontinuity
08:01:14 * Kaidelong believed there was a technical way to describe a space of vectors as being continuous or discrete
08:01:19 <Kaidelong> err
08:01:22 <Kaidelong> discontinuous
08:01:29 <dafis> not in the classic sense of differentiability
08:01:42 <benmachine> Kaidelong: there might be but I haven't heard of it
08:01:45 <dankna> hmm
08:01:47 <benmachine> there are lots of things I haven't heard of though
08:01:48 <dankna> so I've got a problem
08:01:50 <hpc> oh yes, i remember now
08:01:55 <hpc> benmachine: you are right
08:02:10 * Kaidelong will just remember what dafis said
08:02:16 <dankna> I'm writing a small scripting language
08:02:17 <hpc> a function is continuous if it has a limit at each point in the domain
08:02:28 <hpc> or something like that
08:02:33 <dankna> it has only expressions, no statements, but it does have some "StatementLikeExpression"s such as if/else blocks.
08:02:36 <dafis> I'd say, for topological spaces, continuous = locally homoeomorphic to an R^n would be a useful, although uncanonical definition
08:02:45 <hpc> so "y = x except for when x = 3" is still continuous
08:02:46 <alpounet> if its limit, whatever way you go to that point, is its value at that point
08:02:58 <benmachine> continuous function loosely to me means "bits that started near each other end up near each other"
08:03:00 <hpc> because lim x → 3 (y) = 3
08:03:23 <dafis> hpc: a function is continuous iff the preimage of every open set is open
08:03:34 <benmachine> hpc: a function isn't continuous where it isn't defined, that doesn't make sense
08:03:36 <dankna> I want the presence/absence of semicolons between things in this language to be intuitive.  I'd be more specific but I'm not sure exactly what I mean by that.
08:03:43 <benmachine> functions may be continuous in some places but not in others
08:03:47 <Kaidelong> limit of f(x) - f(y) is 0 as (x-y) approaches 0?
08:04:16 <dankna> oh!  I think I just figured out where my grammar conflicts are coming from.  good.
08:04:21 <benmachine> yeah, one definition of continuity at x is f(y) -> f(x) as y -> x
08:05:41 <hpc> so what was i defining?
08:05:44 <hpc> differentiable?
08:05:46 <Kaidelong> proving that a function is continuous seems intractible/undecidable in general
08:06:03 <Kaidelong> if I am thinking of this correctly
08:06:38 <benmachine> Kaidelong: in general, perhaps
08:07:17 <dafis> like the halting problem, there's no general algorithm, but in each particular case, you may be able to decide it
08:07:20 <Kaidelong> I suppose it'd end up boiling down to
08:07:40 <benmachine> it's not very hard to prove the identity is continuous :P
08:07:44 <Kaidelong> "you cannot prove properties about things which are not finitely defined in any way"
08:08:28 <benmachine> Kaidelong: see also http://math.andrej.com/2006/03/27/sometimes-all-functions-are-continuous/
08:09:58 <Renze> Good evening :)
08:10:35 <Renze> Where can I find some (extra) information about { ... }? Because I can't Google on it (Google ignores symbols these days)...
08:10:43 <merijn> @hoogle Int -> [a] -> [a]
08:10:44 <lambdabot> Prelude drop :: Int -> [a] -> [a]
08:10:44 <lambdabot> Prelude take :: Int -> [a] -> [a]
08:10:50 <Zao> Renze: In what context?
08:11:04 <Renze> datatypes mainly
08:11:17 <Zao> "records"
08:11:26 <merijn> :t \x -> take x . cycle
08:11:27 <lambdabot> forall a. Int -> [a] -> [a]
08:11:40 <benmachine> http://haskell.org/haskellwiki/Keywords#.7B.2C_.7D this is actually surprisingly unhelpful
08:11:43 <dafis> Renze: also "named field syntax"
08:11:46 <merijn> @pl \x -> take x . cycle
08:11:46 <lambdabot> (. cycle) . take
08:11:47 <benmachine> but would normally be the place to go
08:13:01 <Renze> Thanks both, dafis and benmachine!
08:13:06 <Renze> Will find my way now :)
08:17:33 <merijn> @hoogle Int -> [a] -> [[a]]
08:17:33 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
08:17:33 <lambdabot> Prelude drop :: Int -> [a] -> [a]
08:17:51 <deech> Hi all, has anyone here looked into ATS (http://www.cs.bu.edu/~hwxi/ATS/ATS.html) ? It does quite well on Alioth (http://shootout.alioth.debian.org/u32/ats.php)
08:18:12 <dolio> I've looked a little. Not done anything with it.
08:18:15 <merijn> Is there a convenient prelude function which splits a list into lists of length N?
08:18:15 <Bynbo7akaAxman6> i think ATS is just a more typesafe C (which included embedded C)
08:18:24 <Bynbo7akaAxman6> merijn: no
08:18:54 <dafis> merijn: look at the split package
08:19:02 <dafis> splitEvery or so
08:19:44 <merijn> Meh, I'll throw together something quick and dirty
08:20:10 <gwern> Djikstra would not approve
08:20:11 <dolio> ATS probably has a nicer type system than GHC Haskell.
08:20:23 <dolio> Except for type classes.
08:20:43 <Bynbo7akaAxman6> merijn: unfoldr is very useful for that
08:20:43 <merijn> gwern: I'm not even writing a program, just using GHCi as a calculator on steroids to figure out/verify how to allocate CUDA memory :p
08:21:13 <Silvah> Does anyone know how "Dijkstra" is pronounced?
08:21:22 <merijn> Yes
08:21:43 <gwern> Silvah: [ˈdɛɪkstra] 
08:21:51 <dankna> Presumably Dijkstra knows.
08:22:05 <Silvah> dankna: I doubt he knows.
08:22:11 <merijn> dankna: He's dead, so its up for debate whether a dead person can know anything
08:22:13 <dafis> not anymore
08:22:14 <dankna> oh, haha
08:22:37 <dafis> although, perhaps it was about Atze Dijkstra?
08:22:48 <merijn> I have no clue whether gwern's notation is correct but it probably is :p
08:23:10 <Bynbo7akaAxman6> Silvah: I've always heard it said as dike-stra
08:23:13 <merijn> Dijk sounds sorta like "dike" although not entirely (coincidentally both are the same)
08:23:28 <dafis> if I remember IPA more or less correctly, that's pretty much correct
08:23:33 <merijn> Bynbo7akaAxman6: Yes, because Americans are heathens which slaughter Dutch pronunciation
08:23:39 <opqdonut> hmm, nice, 1000% profiling overhead
08:23:49 <merijn> same word, even
08:23:51 <dafis> opqdonut: wow
08:23:52 <Bynbo7akaAxman6> merijn: thank god I'm not american!
08:23:56 <aristid> Bynbo7akaAxman6: why not just revert to Axman6?
08:24:16 <Bynbo7akaAxman6> my work machine is logged in as Axman6 
08:24:59 <dafis> opqdonut: but did it reveal anything?
08:25:02 <monochrom> this is why I don't profile
08:25:13 <opqdonut> dafis: no :)
08:25:18 <dafis> :(
08:25:27 <gwern> I don't profile because it's illegal and immoral
08:25:40 <dafis> and it makes you fat?
08:25:40 <opqdonut> I implemented a simpler annotated tree structure
08:25:46 * gwern judges programs by the content of their character
08:26:06 <Silvah> dafis: it eats your cat.
08:26:21 <dafis> Silvah: didn't know that song
08:26:22 * geheimdienst judges programs by the content of their Char
08:26:26 <opqdonut> but it's way slower than fingertree
08:26:32 <benmachine> I can never remember the order of the d, s, and g in dijkstra's first name
08:26:40 <dafis> Edsger
08:26:54 <benmachine> is that pronounced as awkwardly as it looks
08:26:57 <benmachine> <_<
08:27:08 <geheimdienst> somewhat like edgar ...
08:27:18 <benmachine> but plural?
08:27:32 <gwern> opqdonut: if finger trees weren't fast, they'd be a pretty sucky tree. who wants a tree that is both complex and slow?
08:27:49 <merijn> benmachine: For anyone who isn't Dutch or German, probably yes :p
08:28:02 <merijn> :t append
08:28:03 <lambdabot> Not in scope: `append'
08:28:17 <gwern> @hoogle append
08:28:18 <lambdabot> Data.ByteString append :: ByteString -> ByteString -> ByteString
08:28:18 <lambdabot> Data.ByteString.Char8 append :: ByteString -> ByteString -> ByteString
08:28:18 <lambdabot> Data.ByteString.Lazy append :: ByteString -> ByteString -> ByteString
08:28:23 <dafis> merijn: the 'g', would it be pronounced 'g' here or 'kh'?
08:28:25 <Bynbo7> hmmmmm, what does ATS's implementation being GPLv3 mean for programs written using ATS?
08:28:36 <opqdonut> gwern: indeed. my problem is that my fingertree-based structure is orders of magnitude slower than an imperative red-black-tree-based one
08:28:44 <gwern> Bynbo7: nothing unless ATS comes with an eval or something, and then maybe still nothing
08:28:45 <opqdonut> gwern: and this is for _read-only_ operations
08:29:03 <gwern> Bynbo7: no more than intel's proprietary cc means they pwn ur codes
08:29:13 <merijn> dafis: As 'g', depending how your pronounce g :p
08:29:17 <Bynbo7> what about it's GC being used in the program?
08:29:22 <Silvah> merijn: I'm German yet I think it is awkward :P
08:29:38 <gwern> opqdonut: well, that's not terribly surprising. your paying prices for being purely functional rather than destructive
08:29:42 <opqdonut> Bynbo7: productivity has been high but I'll recheck
08:29:51 <dafis> merijn: 'g' as in 'good' or 'g' as in Groningen (the first one)
08:29:51 <opqdonut> gwern: _read-only_ operations
08:30:13 <opqdonut> I'm discounting construction
08:30:15 <gwern> opqdonut: the inefficiencies are still baked in... I take it this is your own fingertree implementation
08:30:17 <Bynbo7> opqdonut: heh, i wasn't actually talking about your problem, though it's a good question to ask :P
08:30:24 <opqdonut> :D
08:30:33 <gwern> opqdonut: how does the fingertree package compare/
08:30:36 <opqdonut> gwern: no, the fingertree package
08:31:16 <opqdonut> but I don't use catenation so I figured I'd check whether a fingerless fingertree would be faster
08:31:21 <Bynbo7> what is the complexity of the neive implementation of fibonacci? is it 2^n or fib(n)?
08:31:28 <dafis> fib(n)
08:31:49 <Bynbo7> i guess it's technically also O(2^n)
08:31:50 <benmachine> fib(n) is about golden ratio^n isn't it?
08:31:54 <opqdonut> yes
08:32:15 <dafis> divided by sqrt 5
08:32:18 <Olathe> Bynbo7: It's fib(n)
08:33:30 <monochrom> be careful that Θ(k^n) ≠ Θ(c^n) when k≠c. However, 1.616^n is still O(2^n) because 1.616^n<=2^n
08:34:28 <monochrom> This is why you should prefer Θ to O.
08:35:24 <dafis> > (1 + sqrt 5) / 2
08:35:25 <lambdabot>   1.618033988749895
08:35:32 <Tomsik> omega(n) is way more pleasant
08:35:36 <monochrom> oops, 1.618 :)
08:35:47 * hackagebot parseargs 0.1.3.1 - Command-line argument parsing library for Haskell programs  http://hackage.haskell.org/package/parseargs-0.1.3.1 (BartonMassey)
08:35:51 <Tomsik> There's  so few lower bounds that we can show
08:35:53 <aavogt> > exp 1 - 1
08:35:54 <lambdabot>   1.718281828459045
08:37:02 <merijn> What am I doing wrong? http://hpaste.org/43437/foo
08:37:43 <dafis> merijn: foo n x [] is missing
08:38:01 <aavogt>  ++ is associative, as far as I know
08:38:09 <dafis> so it takes the second branch and errors on last
08:38:18 <benmachine> ++ is associative yes
08:38:22 <merijn> dafis: oh, duh. And take l-1 is also probably wrong
08:38:30 <aavogt> so it's better to leave out the parens, since associating-right is quicker
08:38:46 <dafis> merijn: use init ?
08:38:47 <benmachine> merijn: it's the same as 'init'
08:38:54 <Olathe> merijn: http://codepad.org/e82arYXG
08:38:58 <benmachine> merijn: but if you're using both init and tail you might want splitAt
08:39:14 <Olathe> merijn: h is a list, t is an element, h ++ t doesn't work.
08:39:14 <Bynbo7> wow, ATS is crazy
08:39:20 <centrinia> Why are you mixing types?
08:39:34 <benmachine> Bynbo7: the good kind or the bad kind?
08:39:40 <Bynbo7> I'm not sure
08:39:47 <centrinia> h ++ (t ++ [x]) has a different type from (h++t)++[[x]] regardless of what h,t, and x are. :p
08:39:57 <Bynbo7> thought the implementation of fibonacci is scary
08:40:10 <dafis> Bynbo7: in how far?
08:40:28 <Bynbo7> http://www.ats-lang.org/#simple_ats_programs
08:40:36 <dafis> gracias
08:41:20 <merijn> I think I fixed it: http://hpaste.org/paste/43437/foo_annotation#p43438
08:41:22 <dolio> A fair amount of ATS type stuff you can do in GHC, it's just a lot less fun.
08:41:49 <Bynbo7> dafis: ... less fun than the fib example in the link above?
08:42:41 <dafis> Bynbo7: the one you just posted or an earlier?
08:42:45 <Bynbo7> quicksort in ATS: http://www.ats-lang.org/EXAMPLE/MISC/quicksort_list_dats.html
08:42:51 <Bynbo7> the one i just posted
08:42:59 <Bynbo7> i meant to say that to dolio 
08:43:02 <benmachine> Bynbo7: the syntax looks terribly noisy
08:43:12 <Bynbo7> benmachine: my thoughts exactly
08:43:20 * dafis agrees
08:43:36 <benmachine> although possibly the highlighting doesn't help
08:43:42 <benmachine> it sort of draws attention to the punctuation
08:43:49 <benmachine> rather than the actual identifiers
08:43:52 <dolio> Bynbo7: You can even do that quicksort in Haskell, I think.
08:44:02 <benmachine> there's a quicksort in the typesystem on the wiki :P
08:44:13 <Bynbo7> i mean, it's kinda cool that the types guarantee the function will terminate and will be a sorted permutation of the input list... but... god that's a lot of code
08:44:22 <aristid> val () = srand48_with_time ()
08:44:27 <Olathe> merijn: I'd recommend if null (drop (n - 1) t) instead of using length.
08:44:38 <aristid> 4 redundant tokens
08:44:40 <Bynbo7> suerly that would be an easier thing to do with merge sort anyway
08:44:41 <aristid> 1 significant
08:44:43 <dolio> In fact, I think that file shows how undesirable ATS is compared to a real dependently typed language.
08:44:49 <aristid> pretty bad redundancy ratio
08:44:55 <merijn> Olathe: Meh, it's throwaway code as long as it works its fine
08:45:01 <Olathe> merijn: Ahh, OK :)
08:45:14 <Veinor> that's horrible syntax
08:45:27 <benmachine> dolio: "real"? did you have any in mind?
08:45:37 <merijn> Olathe: Need to verify my memory allocation scheme doesn't malfunction horribly and to lazy to check manually :p
08:45:42 <dolio> Agda, Coq, Epigram, Cayenne, ...
08:45:49 <Olathe> merijn: Ahh, I see.
08:45:50 * hackagebot parseargs 0.1.3.2 - Command-line argument parsing library for Haskell programs  http://hackage.haskell.org/package/parseargs-0.1.3.2 (BartonMassey)
08:46:09 <benmachine> agda gets proven inconsistent every now and then :P
08:46:33 <benmachine> but admittedly I only complain about agda because I'm not clever enough to be any good at it
08:46:59 <Cin> ATS looks like someone put a picture of hell into an image->ASCII translator.
08:47:32 <dafis> I thought of the bastard child of OCaml and Malbolge
08:48:33 <dolio> Well, the thing is, in Agda, verified quicksort (or whatever) has a type like List Nat -> (xs : List Nat, Sorted xs).
08:49:16 <benmachine> not sure how you'd do the permutation thing
08:49:47 <dolio> In ATS, it looks like (exists (xs : StaticList Nat). DynamicList xs) -> (exists (ys : StaticList Nat). (Sorted ys, DynamicList ys)).
08:50:13 <dolio> Which implies a lot of duplication.
08:50:50 <dolio> You have static/type-level lists, and dynamic/value-level lists indexed by the static lists, and wrap the latter in existentials to get your actual values.
08:51:07 <dolio> And you do that every time you want types to depend on values. Same as with GADTs in Haskell.
08:51:18 <dolio> Instead of just having types depend on values.
08:52:45 <conal> I'm puzzled about a warning message from GHC, claiming non-exhaustive patterns in a GADT-based def. http://hpaste.org/43439/gadts_and_pattern_coverage . any ideas?
08:53:36 <pastorn> conal: preparing blog post #2? :)
08:53:48 <conal> pastorn: exactly.
08:53:52 * Bynbo7 is looking forward to it
08:53:56 <conal> :)
08:54:13 <conal> i was going to raise this question in the post itself, but i'd rather eliminate the distraction.
08:54:17 <Bynbo7> though, i must say, i usually get lost reading your posts :(
08:54:22 <dolio> In fact, that quicksort file does something even stranger...
08:54:26 <dafis> conal: that looks familiar, I think there's a bug on trac about that
08:54:26 <Bynbo7> but, I'm not a very mathematical person i guess
08:54:45 <benmachine> conal: it didn't typecheck for me
08:54:45 <dafis> conal: give me a few minutes to look
08:54:47 <conal> oops. that first question in my paste is missing a couple of words. meant to read "How do the last two cases even type-check?"
08:54:59 <conal> benmachine: wow. what ghc version?
08:55:05 <dolio> It has dynamic lists like 'List A l', where A is the type of dynamic values stored in the list, and l is a static list of integers.
08:55:06 <benmachine> conal: 7.0.1 I think
08:55:11 <benmachine> yeah
08:55:16 <conal> benmachine: and what do you get if you comment out those two last cases?
08:55:33 <Cin> hopefully nothing otherwise we can't compile it at all :D
08:55:41 <benmachine> conal: eep, non-exhaustive pattern warnings :P
08:55:45 <Cin> =O
08:55:48 <conal> benmachine: uh oh.
08:56:08 <dolio> So it might not even prove that the actual values in the list are sorted. Just that the corresponding type-level integers are sorted, which may or may not correspond to the dynamic values in any way.
08:56:10 <pastorn> conal: why not just _ `applyV` _ = error "impossible case"
08:56:12 <benmachine> conal: using wildcard patterns
08:56:15 <pastorn> and it shuts up :)
08:56:18 <benmachine> conal: it doesn't warn and it does compile
08:56:43 <conal> pastorn: because i want to clarify what those cases are and ideally remove them (since they're statically impossible).
08:57:23 <Bynbo7> _ `applyV` _ = error "GHC is too stupid to know this is impossible... oops, i guess not"
08:57:30 <benmachine> conal: http://hpaste.org/paste/43439/gadts_and_pattern_coverage_err#p43440
08:57:47 <benmachine> conal: that's with the two additional patterns uncommented
08:58:02 <merijn> Easiest way to check whether all values in a list are unique?
08:58:05 <pastorn> conal: oh, i'm seeing what you're doing now :)
08:58:22 <benmachine> merijn: easiest, or fastest? :P
08:58:27 <merijn> benmachine: Easiest
08:58:31 <Bynbo7> merijn: well, there's xs == nub xs
08:58:35 <benmachine> xs == nub xs is not bad
08:58:48 <merijn> :t nub
08:58:49 <lambdabot> forall a. (Eq a) => [a] -> [a]
08:58:52 <Bynbo7> :t ap (==) nub
08:58:53 <lambdabot> forall a. (Eq a) => [a] -> Bool
08:58:53 <conal> benmachine: thanks very much. sounds like a ghc bug in 6.12.3 and a different one in 7.0.1 .
08:59:01 <Eduard_Munteanu> It simply removes duplicates.
08:59:04 <Bynbo7> > ap (==) sub [1..10]
08:59:05 <lambdabot>   Not in scope: `sub'
08:59:08 <Bynbo7> > ap (==) nub [1..10]
08:59:09 <lambdabot>   True
08:59:13 <rwbarton> conal: in ghc 7, if you comment out the last two cases, you still get the incomplete pattern match warning :/
08:59:16 <Bynbo7> > ap (==) nub [1,2,3,1]
08:59:17 <lambdabot>   False
08:59:24 <Silvah> :t nub
08:59:25 <lambdabot> forall a. (Eq a) => [a] -> [a]
08:59:26 <Eduard_Munteanu> > nub [1,2,3,1]
08:59:26 <lambdabot>   [1,2,3]
08:59:33 <merijn> Bynbo7: Oh, that's convenient :)
08:59:41 <dafis> conal: http://hackage.haskell.org/trac/ghc/ticket/3927 perhaps?
08:59:41 <CindyLinz> Is there a monad transformer for Binary.Put.PutM ?
08:59:43 <rwbarton> so it seems like the exhaustiveness checker is not fully up to date with the typechecker (which has often been the case)
08:59:49 <aristid> Bynbo7: ap (==) nub could probably be implemented a lot more efficiently? :)
08:59:58 <Bynbo7> yes
08:59:59 <dolio> conal: Someone brought this up a few months back. As I recall, SPJ had some reason why those two cases aren't exhaustive, but I don't remember it being very convincing.
08:59:59 <Bynbo7> heh
09:00:07 <Olathe> > let allSame [] = True; allSame (x:xs) = all (== x) xs in allSame [1, 1, 1]
09:00:08 <lambdabot>   True
09:00:27 <rwbarton> Clearly at least the text of the warning is wrong for ghc 7
09:00:41 <DevHC> can i rename a data constructor?
09:00:48 <conal> dafis: thx for the trac pointer. reading.
09:00:53 <DevHC> specifically, i want to rename Left and Right to This and That, respectively
09:00:57 <pastorn> DevHC: as long as it's not a library import one
09:00:58 <Bynbo7> unjust = Just
09:00:58 <Twey> Haha
09:01:13 <DevHC> :<
09:01:26 <pastorn> DevHC: not really... you could always do a mapping; fromEither :: Eihter a b -> MyThingy a b
09:01:48 <pastorn> DevHC: what's wrong with Either?
09:02:07 <DevHC> i like This and That better than Left and Right
09:02:11 <DevHC> it sounds better
09:02:18 * Bynbo7 prefers Fail and Win
09:02:27 <Olathe> > let allSame xs = xs == drop 1 xs in allSame [1, 1, 1]
09:02:28 <DevHC> why wasn't it named Direction?
09:02:28 <lambdabot>   False
09:02:38 <Olathe> > let allSame xs = init xs == drop 1 xs in allSame [1, 1, 1]
09:02:39 <lambdabot>   True
09:02:44 <Olathe> Hmm...
09:03:00 <Bynbo7> > init []
09:03:01 <lambdabot>   *Exception: Prelude.init: empty list
09:03:13 <benmachine> > let allSame xs = and $ zipWith (==) xs (drop 1 xs) in allSame [1,1,1,1,1]
09:03:14 <lambdabot>   True
09:03:21 <benmachine> hmm
09:03:35 * Bynbo7 likes that
09:03:36 <dafis> > let allSame xs = and $ zipWith (==) xs (tail xs) in allSame []
09:03:37 <lambdabot>   True
09:03:41 <dafis> > let allSame xs = and $ zipWith (==) xs (tail xs) in allSame [1,1,1]
09:03:41 <Olathe> > let allSame xs = all id $ zipWith (==) xs (drop 1 xs) in map allSame [[], [1, 1, 1]]
09:03:42 <lambdabot>   True
09:03:43 <lambdabot>   [True,True]
09:03:59 <Olathe> I still like the first one, though.
09:04:05 <aristid> :t and . (zipWith (==) <*> tail)
09:04:06 <lambdabot> forall a. (Eq a) => [a] -> Bool
09:04:15 <Olathe> > let allSame [] = True; allSame (x:xs) = all (== x) xs in map allSame [[], [1, 2], [1, 1, 1]]
09:04:16 <lambdabot>   [True,False,True]
09:04:19 <aristid> :t and <$> zipWith (==) <*> tail
09:04:20 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `Bool'
09:04:21 <lambdabot>     In the first argument of `(<$>)', namely `and'
09:04:21 <lambdabot>     In the first argument of `(<*>)', namely `and <$> zipWith (==)'
09:04:24 <aristid> damn.
09:04:31 <benmachine> > zipWith (==) <*> tail $ []
09:04:31 <lambdabot>   []
09:04:32 <benmachine> neat
09:04:50 <aristid> benmachine: <*> is great fun :)
09:04:51 <benmachine> > zipWith (==) =<< tail $ []
09:04:52 <lambdabot>   *Exception: Prelude.tail: empty list
09:05:09 <aristid> weird.
09:05:11 <benmachine> aristid: oh, I know; the neat bit was how zipWith was lazy enough that the tail [] wasn't an error
09:05:29 <benmachine> > f =<< g $ x -- by way of explanation
09:05:29 <lambdabot>   Ambiguous occurrence `f'
09:05:30 <lambdabot>  It could refer to either `L.f', defined at <local...
09:05:30 <aristid> imma confused
09:05:32 <benmachine> awk
09:05:32 <dolio> conal: That's the ticket I was thinking of. I guess matching on GADTs just introduces equality constraints, and GHC doesn't mind if it has both (a ~ T) and (a ~ U) for T and U not equal, at least in 6.x.
09:05:34 <Olathe> It's lazy, efficient, and easy to tell what it does.
09:05:38 <benmachine> :t L.f
09:05:39 <lambdabot> forall a (m :: * -> *). (Floating a, MonadRandom m, Random a) => a -> m a
09:05:42 <benmachine> o_O
09:05:42 <aristid> @undef
09:05:43 <Olathe> > let allSame [] = True; allSame (x:xs) = all (== x) xs in map allSame [[], [1, 2], [1, 1, 1], [1..]]
09:05:45 <lambdabot>   [True,False,True,False]
09:05:48 <aristid> :t L.f
09:05:49 <lambdabot> Not in scope: `L.f'
09:05:51 <benmachine> > f =<< g $ x
09:05:52 <lambdabot>   Ambiguous type variable `a' in the constraints:
09:05:53 <lambdabot>    `GHC.Show.Show a'
09:05:53 <lambdabot>      a...
09:05:55 <benmachine> ffff
09:05:59 <benmachine> > f =<< g $ x :: Expr
09:06:00 <lambdabot>   Ambiguous type variable `a' in the constraints:
09:06:00 <lambdabot>    `SimpleReflect.FromExpr ...
09:06:03 <aristid> HAHAHAHA
09:06:05 <benmachine> damn it.
09:06:16 <BMeph> > let allSame xs = and $ zipWith (==) xs (drop 1 xs) in allSame [2,1,1,1,1]
09:06:17 <lambdabot>   False
09:06:19 <conal> dolio: thx. subtler than i'd realized.
09:07:15 <benmachine> anyway, f =<< g $ x = f (g x) x
09:07:44 <Olathe> > f x
09:07:46 <lambdabot>   Ambiguous type variable `a' in the constraints:
09:07:46 <lambdabot>    `GHC.Show.Show a'
09:07:46 <lambdabot>      a...
09:07:48 <Olathe> Lies
09:07:54 <benmachine> > expr $ f x
09:07:55 <lambdabot>   f x
09:08:16 <Olathe> > expr $ (f =<< g) x
09:08:17 <lambdabot>   Ambiguous type variable `a' in the constraints:
09:08:17 <lambdabot>    `SimpleReflect.FromExpr ...
09:08:20 <Olathe> Bah.
09:08:28 <benmachine> bah indeed
09:08:39 <Olathe> > expr $ (f =<< g) (x :: Expr)
09:08:41 <lambdabot>   Ambiguous type variable `a' in the constraints:
09:08:41 <lambdabot>    `SimpleReflect.FromExpr ...
09:08:43 <dolio> conal: It's definitely not what I'd expect based on similar features in other languages.
09:08:44 <benmachine> > expr $ (f =<< expr . g) x
09:08:46 <lambdabot>   f (g x) x
09:08:53 <Olathe> O-o
09:09:05 * benmachine wonders if one could fix that with defaulting
09:09:10 <benmachine> insofar as defaulting ever fixes anything
09:09:17 <conal> benmachine: would someone with ghc 7 please try one more experiment for me? replace the last two cases with "_ `apply` _ = undefined" to see what happens.
09:09:31 <benmachine> conal: oh, I already tried that, and it compiled and didn't warn
09:09:35 <benmachine> iirc
09:09:44 <copumpkin> oh, you testing the GADT pattern matching behavior of GHC 7?
09:09:54 * copumpkin just woke up
09:09:54 <conal> benmachine: thanks. i guess that's what i'll do for now. grumble.
09:10:09 <Eduard_Munteanu> What exactly does SPJ hint to there when he says "Technically dead GADT case alternatives are not ill-typed. (Just look at any GADT paper.)" ?
09:10:10 <conal> copumpkin: yeah. and i see that you know about this topic (http://hackage.haskell.org/trac/ghc/ticket/3927 )
09:10:35 <copumpkin> conal: a bit :) which part don't you like?
09:10:57 <Eduard_Munteanu> Since these are constructors and type equalities, shouldn't static checking be completely possible?
09:11:27 <copumpkin> Eduard_Munteanu: Well, I think the issue is how the additional refinement is introduced
09:11:29 <Heffalump> Eduard_Munteanu: isn't it just a statement of policy?
09:11:39 <copumpkin> :t (a ~ Int, a ~ Bool) => a -> a
09:11:40 <lambdabot> parse error on input `=>'
09:11:43 <conal> copumpkin: that ghc doesn't realize the first two clauses are complete.
09:11:49 <copumpkin> :k (a ~ Int, a ~ Bool) => a -> a
09:11:49 <Heffalump> GHC could in theory make any unreachable pattern match be an error, but it doesn't
09:11:50 <lambdabot> *
09:12:07 <copumpkin> Heffalump: it does
09:12:09 <Eduard_Munteanu> Hrm.
09:12:11 <copumpkin> oh, not any
09:12:14 <copumpkin> just GADT-related ones right now
09:12:18 <merijn> Heffalump: There is a -W flag for that I think
09:12:29 <merijn> Oh wait, no I misread
09:12:29 <conal> copumpkin: so i have to add code that cannot be called, in order to keep -Wall and still compile warnings-cleanly
09:12:52 <copumpkin> conal: oh? what's the code?
09:12:56 <Bynbo7> nice to see we're not alone: http://lwn.net/Articles/423732/
09:13:06 <conal> copumpkin: http://hpaste.org/43439/gadts_and_pattern_coverage
09:13:24 * benmachine half-expected Bynbo7's link to contain conclusive proof of the existence of aliens
09:13:27 <copumpkin> oh, GHC 7 specifically fixes that
09:13:28 <copumpkin> conal
09:13:37 <Bynbo7> benmachine: ha
09:13:51 <copumpkin> conal: oh, and they typecheck by the thing I just :k'd typechecking
09:13:59 <Heffalump> oh, I see the issue
09:14:11 <copumpkin> which I didn't think they should do, but the new typechecker agrees with me
09:14:15 <copumpkin> so I'm glad
09:14:27 <conal> copumpkin: benmachine says ghc7 rejects the last two cases but warns of non-exhaustive cases w/o the last two.
09:14:35 <conal> copumpkin: i don't yet have ghc7
09:14:46 <copumpkin> hmm, not in my tests, but I haven't tried your code specifically
09:14:54 <copumpkin> let me try
09:15:57 <copumpkin> oh, hmm, you're right
09:17:01 <copumpkin> conal: maybe add to the ticket?
09:25:20 <shenshei> hello, someone know how to get the line error in parsing with happy ?
09:25:49 <katja> Hey! I am preparing for my exam in Haskell. and I have found a good exercise, but I am not sure if I did it right. I need to make data Figur an Instance for the Class Eq. The figures are similar when they can be superimposed on each other.that is my solution http://codepad.org/oC81ql0d 
09:26:39 <benmachine> katja: that is syntactically correct, but it says that any rectangle is equal to any other
09:26:52 <benmachine> and any square to any square
09:27:01 <benmachine> regardless of what the associated Floats are
09:27:37 <katja> benmachine: yeah... is it wrong?
09:27:37 <dafis> katja: and the last two branches can be succinctly written as _ == _ = False
09:28:03 <conal> phew. raining here. satellite internet connection in & out.
09:28:06 <dafis> katja: usually, you'd want rectangles of different sizes to be nonequal
09:28:14 <reacocard> it also says squares and rectangles can never be equal, but if you're only going by superimposing then wouldnt Rectangle 5 5 be equal to Square 5 ?
09:29:45 <benmachine> katja: according to your instance, Rectangle 1 2 and Rectangle 3 4 are equal, but they're not superimposable
09:30:32 <katja> benmachine: yeah, I dont know how to define that they must be superimposable
09:31:36 <benmachine> katja: do you know the mathematical conditions for shapes to be superimposable?
09:31:41 <dafis> katja: (Rectangle a b) == (Rectangle c d) = a == c && b == d
09:31:57 <benmachine> dafis: this is homework you're not supposed to just give the answer :P
09:32:03 <dafis> sorry
09:32:04 <benmachine> well, sort of homework
09:32:38 <katja> benmachine:m. actually no, but I am looking for it
09:33:11 <benmachine> katja: it's always difficult to write correct functions when you don't understand what they should do, let alone if they do it :)
09:33:57 <katja> benmachine: yep. I know. I am just studying in Germany but German is not my native language. and I thought I git it right
09:34:21 <katja> benmachine: so the objects are superimposable when they can cover eatch other
09:34:41 <katja> benmachine: so, the sides of the objects must be the same
09:35:13 <benmachine> katja: ok, so you need to get the side lengths so you can compare them
09:37:08 * hackagebot wai-app-static 0.0.1 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-0.0.1 (MichaelSnoyman)
09:38:35 <katja> benmachine: http://codepad.org/EpM7u7ER this way?
09:41:13 <benmachine> katja: close, but there are a few problems still
09:41:22 <benmachine> katja: first of all, don't use tabs to indent, use spaces instead
09:41:35 <benmachine> katja: secondly, you can't repeat a variable name in a pattern, so Rectangle a a is not valid
09:42:06 <benmachine> so you need Rectangle a b == Square c -- or something like that
09:42:06 <hpc> you can write Rectangle a b | a == b = ...
09:42:18 <benmachine> hpc: I don't think guards are appropriate here
09:42:24 <benmachine> given that the type of the RHS is Bool anyway
09:42:38 <hpc> ah
09:42:51 <katja> benmachine: yep. ok
09:43:24 <katja> benmachine: Rectangle a c  == Square b      = a==b && b==c
09:44:08 <benmachine> katja: sounds good to me
09:45:28 <katja> benmachine: and that is all??
09:45:54 <benmachine> katja: if you've also fixed the one with Rectangle b b, yes
09:46:01 <benmachine> I think so anyway
09:46:06 <benmachine> oh
09:46:12 <benmachine> actually
09:46:28 <benmachine> is Rectangle 1 2 equal to Rectangle 2 1?
09:47:35 <katja> benmachine: m... well I dont think so. I mean then can cover eatch other only in one position
09:48:06 <katja> benmachine: in my exercise is written then as well when you rotate them
09:48:14 <benmachine> oh ok
09:49:08 <Cin> If I load an object with hsplugins and the types used in the host program and the module loaded have changed, do Bad Things happen?
09:51:58 <katja> benmachine: i have one small qeustion more. I need as well to compare the objects under consederation of their surfaces. and I have written already thefuktion surface. but how should I write that all down? Rectangle a b  == Rectangle x y = surface (Rectangle a b)==surface(Rectange x y) will thus way be approriate?
09:52:45 <benmachine> katja: that will work but there are shorter ways to write it, do you want to do the same thing with Squares and so forth?
09:53:11 <benmachine> katja: if you do the same thing regardless of what kind of shape it is you don't necessarily need to pattern match
09:53:19 <benmachine> katja: you can just say x == y = surface x == surface y
09:54:03 <katja> benmachine:I have to make data Figur an instance for the Class Ord
09:57:24 <jetkoten> hi all
10:00:13 * hackagebot hatt 0.1 - A truth table generator for classical propositional logic.  http://hackage.haskell.org/package/hatt-0.1 (BenedictEastaugh)
10:04:50 <conal> New blog post for your amusement: http://conal.net/blog/posts/fixing-lists/ 
10:05:12 <SirFrancisDrake> goal: to turn a string with some <br />'s into a string without them. Solution: parse cells between brs and cons them together.
10:05:13 <SirFrancisDrake> http://hpaste.org/43443/reads_only_one_cell
10:05:33 <SirFrancisDrake> but it parses only the first one. Any ideas why?
10:06:14 * hackagebot hS3 0.5.4 - Interface to Amazon's Simple Storage Service (S3)  http://hackage.haskell.org/package/hS3-0.5.4 (GregHeartsfield)
10:10:46 <duckinator> hi
10:15:20 <roconnor> Vec n is a monad
10:15:28 <copumpkin> yep
10:15:45 <benmachine> is it the zippy monad?
10:15:57 * benmachine is not using precise terminology here
10:15:58 <copumpkin> you can also easily define a traversable instance for it
10:16:05 <roconnor> benmachine: more or less
10:16:16 <copumpkin> join takes the diagonal
10:16:20 <aristid> benmachine: see the thunder outside your house?
10:16:34 <aristid> benmachine: it's the anger of the monad terminology gods.
10:16:39 <benmachine> :(
10:16:43 <SirFrancisDrake> aristid: burning unbelievers to a crisp?
10:16:44 * benmachine hides under a comonad
10:16:52 <aristid> SirFrancisDrake: yeah.
10:16:56 <benmachine> copumpkin: right, that's the one
10:17:05 * roconnor extracts benmachine
10:17:12 <benmachine> damn it.
10:17:24 * benmachine chose his defence poorly
10:17:42 <aristid> benmachine: maybe you can hide in a Functor?
10:18:05 <benmachine> aristid: sounds dangerous
10:18:11 <benmachine> people might const me out of existence
10:18:37 <roconnor> Const is a pretty great Functor
10:18:39 * aristid fmap (const ()) benmachine
10:18:50 * benmachine is suddenly hungry
10:19:25 <benmachine> (units are not very nutritious
10:19:27 <benmachine> )
10:20:40 <katja> benmachine:could you please take a look here. so, I made the figur the instance for class Ord , so where surface plays the most important role and the the surfaces are the same, then the perimeter http://codepad.org/igQnRrcj
10:21:26 <benmachine> katja: are you required to have Rectangle and Square be separate constructors?
10:22:01 <SirFrancisDrake> wrong indentation?
10:22:11 <benmachine> the indentation is wrong, yes, you've used tabs again :P
10:22:11 <katja> benmachine:that is not said. but I am given     data Figur = Rectangle Float Float | Square Float
10:22:24 <benmachine> katja: ah, ok
10:22:27 <katja> i dont know how to use not tabs%))
10:22:35 <benmachine> katja: just use spaces?
10:22:38 <benmachine> anyway
10:22:44 <katja> I use space
10:22:45 <benmachine> you've got a few problems here
10:22:47 <benmachine> oh ok
10:22:53 <benmachine> use a non-crazy editor
10:22:54 <benmachine> but
10:22:56 <SirFrancisDrake> set tabstop=4
10:22:57 <benmachine> that's a different issue
10:22:59 <katja> haha
10:23:12 <benmachine> the problems with your code, apart from indentation, are
10:23:21 <benmachine> firstly, /= and == are not methods of Ord
10:23:32 <benmachine> so they can't be defined here, you have to define them in the Eq class
10:23:50 <benmachine> secondly, all your equations for each function must be together
10:24:01 <benmachine> you've defined some equations for < and then some for > and then one for < again
10:24:15 <monochrom> SirFrancisDrake: in (manyTill anyChar (try (string "<br />") <|> (try (string "\n")))), the "<br />" or "\n" in the input stream is also consumed. you should use freeFromBrs = many cell
10:24:27 <benmachine> you need all your equations for < to be next to each other
10:24:51 <katja> benmachine: why?
10:25:17 <benmachine> katja: because otherwise people have to read your whole file to make sure they have seen everything before they know how your function works
10:25:25 <katja> benmachine: ok.. but how can I define that the surfaces are equel in this task?
10:25:35 <benmachine> katja: it's much simpler for the compiler and for anyone who has to read your code if you put all that stuff together
10:25:36 <katja> benmachine: oh. ok. I thought that is a mistake
10:25:59 <benmachine> katja: well, for those reasons, haskell requires that you put them together, and it won't work otherwise
10:26:02 <benmachine> anyway
10:26:18 <benmachine> defining stuff as equal, you do that with the Eq instance that you already wrote
10:26:34 <benmachine> in order to define an Ord instance you have to already have an Eq instance
10:26:37 <monochrom> you may still separate type signature from function definition by 1000 lines if you like :)
10:26:43 <benmachine> heh
10:26:49 <benmachine> yes :(
10:26:53 <benmachine> hmm I gotta go
10:27:20 <monochrom> SirFrancisDrake: in (manyTill anyChar (try (string "<br />") <|> (try (string "\n")))), the "<br />" or "\n" in the input stream is also consumed. you should use freeFromBrs = many cell
10:27:33 <SirFrancisDrake> monochrom: uh, thanks. Does manyTill steal those separating characters?
10:27:50 <benmachine> katja: you'll have to get someone else to help you, sorry, I've got to go eat
10:27:51 <SirFrancisDrake> monochrom: I was just typing that when my browser crashed >.<
10:27:57 <katja> benmachine: no. that was another task. now I have to make data Figur to instance for class Ord and and it is written when the surfaces are the same, should be used perimeter
10:28:12 <katja> benmachine: ok. thank you very much%)
10:29:12 <SirFrancisDrake> monochrom: works fine. Many thanks.
10:30:06 <monochrom> can't say manyTill steals them. when you write (manyTill anyChar (string "xxx")), well, (string "xxx") is obliged to consume xxx.
10:31:52 <SirFrancisDrake> but when I say (manyTill anyChar (try (string "xxx")), it isn't, right?
10:32:20 <monochrom> it still is. when p is successful, try p = p
10:32:43 <katja> could someone help me with my exam preparation? I need to make data Figur to a class Ord, where surfaces play the first role, and when surfaces are equel then the perimiter should be sompared.http://codepad.org/IKWCPr33 that is my solution. but as I was told there is now == and /= in Ord class but how should I define then that the surfaces are equel?
10:34:19 <gwern> katja: why can't you derive Eq for your Figure type? Square Float has a trivial eq
10:34:26 <monochrom> (try p) doesn't always backtrack. it backtracks only when p fails
10:35:04 <gwern> and there's an obvious Eq for Rectangle too, so I would epect ghc to be able to derive Eq
10:36:08 <katja> gwern: what do you mean by derivate Eq&
10:36:22 <SirFrancisDrake> gwern: it seems to me that (Rectangle 1 2) == (Rectangle 2 1) is expected to be true, and ghci would derive it to be otherwise.
10:36:52 <gwern> SirFrancisDrake: they have equal area, yes, and given appropriate translations and rotations are the same. but I wouldn't expect them to be equal
10:37:25 <gwern> SirFrancisDrake: if I tell you bob is 7 feet high and 2 feet wide but robert is 2 feet high and 7 feet wide, would you infer that bob is robert?
10:37:46 * monochrom has a cunning plan
10:37:47 <SirFrancisDrake> gwern: you suggest making a congruent typeclass with (.==)?
10:38:22 <SirFrancisDrake> gwern: using Eq for that seems more natural to me, given the task.
10:38:43 <gwern> SirFrancisDrake: well, I'd use some other typeclass 'CanBeTransformedInto' or something like that
10:39:08 <gwern> SirFrancisDrake: since what functions do we admit? are we allowed to dilate as we search for equality?
10:43:35 <SirFrancisDrake> gwern: we just re-define equality in a way we want it to be. That makes our language more suited to our data, which sounds not that bad.
10:44:29 <gwern> SirFrancisDrake: of course you can redefine equality as you wish. or you could newtype it and define an Eq for that. but you haven't made the case that the obvious Eq definition, the one GHC would generate, is bad
10:45:31 <{aaron}> anybody know if there is a pack/unpack library for haskell?
10:45:44 <gwern> {aaron}: read/show? Data.bBnary?
10:45:46 <gwern> *Binary
10:45:49 <gwern> cereal?
10:45:51 <aavogt> @hackage zlib
10:45:51 <lambdabot> http://hackage.haskell.org/package/zlib
10:45:51 <monochrom> what does pack/unpack libary mean?
10:45:54 <gwern> did you even look at hackage first?
10:46:33 <aristid> gwern: blind @hackage is more fun
10:47:06 <aavogt> @unpackage random
10:47:07 <lambdabot> Unknown command, try @list
10:47:21 <monochrom> @hackage halting-solver
10:47:21 <lambdabot> http://hackage.haskell.org/package/halting-solver
10:47:53 <SirFrancisDrake> gwern: it doesn't have to be bad, it just doesn't fit current needs. For which, as I gather, we would like two figures to be considered equal if their areas are eqal.
10:48:21 <gwern> SirFrancisDrake: I don't remember katja saying area was the only consideration
10:48:37 <{aaron}> Data.Binary seems to be for serializing/deserializing haskell values...i'm looking for something more generic, like the perl/python/ruby binary pack/unpack (with type formats)...does Data.Binary do this?
10:49:07 * monochrom contemplates a lib and a blog post "undecidable problems made easy with automatic theorem provers: a haskell edsl for z3" :)
10:49:51 <aristid> i wonder if snoyman likes getting mail on minor problems with his packages :D
10:50:17 <gwern> aristid: secretly, it gratifies his ego
10:50:31 <monochrom> Data.Binary doesn't write out or read in type information
10:51:13 <alej> jmcarthur: you around?
10:51:13 <aristid> gwern: very good, then.
10:52:44 * monochrom for one doesn't know any python jargon. "python's pack/unpack" doesn't mean anything to him.
10:53:03 <SirFrancisDrake> gwern: okay, I yield. Eq could compare areas, but that's not that good.
10:53:32 <jmcarthur> alej: hey what's up?
10:53:47 <alej> jmcarthur: i was thinking about our conversation from yesterday - do you remember?
10:53:53 <jmcarthur> yes?
10:53:57 <aristid> monochrom: i wonder if python's pack/unpack is similar to perl's
10:54:00 * monochrom contemplates going to #python to ask "does python have something like haskell's alex?"
10:54:19 <alej> suppose that joins are necessary for some game functions, are there structures in haskell for which those will be reasonable efficient?
10:54:24 <monochrom> well I don't know of perl jargons. and I don't know of ruby jargons either.
10:54:47 <jmcarthur> monochrom: this can generate python http://www.antlr.org/
10:55:16 <jmcarthur> alej: it depends on the kind of join and the data. really, it's not hard to find appropriate data structures in general
10:55:21 <{aaron}> i think this answers my question, thx: http://www.haskell.org/haskellwiki/DealingWithBinaryData
10:55:23 <{aaron}> :)
10:55:45 <jmcarthur> monochrom: i'm not very familiar with it though. it may not work like alex
10:55:54 <jmcarthur> actually, i was thinking happy
10:55:59 <aristid> monochrom: i'd rather ask about "parsec/attoparsec"
10:56:01 <alej> jmcarthur: so I would be tempted to start with Data.Map, but was mostly wondering if that would be obviously bad
10:56:03 <jmcarthur> so i answered the wrong question
10:56:36 <monochrom> the point is one community doesn't know another community's jargon
10:56:45 <gwern> {aaron}: but data.binary is limited to values. can't serialize functions
10:57:00 <jmcarthur> alej: IntMap might be more appropriate since presumably your game ids would be Ints. Data.Map would also be fine as a start though. you can always change it later. it doesn't really matter until you know better what kinds of operations you need to be efficient
10:57:16 <alej> that's true
10:57:26 <jmcarthur> monochrom: http://pyparsing.wikispaces.com/
10:57:49 <alej> yeah i suppose i'm going to abstract that away anyway, so it ought to be easy to change
10:57:58 <gwern> alej: there are a few union-finds in haskell if those're the operations you need
10:58:03 <jmcarthur> alej: tibbe has a persistent hash table thingy on the way, too. it supposedly has good performance
10:58:04 <{aaron}> gwern, no worries, i'm parsing some binary data. guaranteed there are no serialized haskell functions in there... ;)
10:58:06 <monochrom> I could replace "alex" by "leksah", "yi", "spoon", "syb".
10:59:01 <jmcarthur> alej: well, another thing is that you might end up deciding that one collection type is better for one of your collections and another is better for a different one
10:59:07 <alej> sure
11:00:03 <Kakarott> @hoogle [a] -> (a -> m b) -> m [b]
11:00:03 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
11:00:03 <jmcarthur> like if there are some attributes that all entities have and you have some static or bounded number of entities, even a simple array might be appropriate for some things
11:00:03 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
11:00:03 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
11:00:30 <alej> though i mostly anticipate needing to get several attributes that only some entities will have. at least, i anticipate that being the tricky and potentially least efficient part
11:00:45 <alej> and it won't make sense to store those all together in one collection
11:01:25 <jmcarthur> you can also use some targetted denormalization to speed things up, once everything is working
11:01:50 <alej> yeah well i guess these are a lot of abstract what-ifs, since i dont even have a working version yet
11:01:55 <jmcarthur> exactly
11:02:17 <alej> i feel like i have a decent understanding of the requirements, but I haven't programmed a system quite like this before
11:02:25 <Kakarott> @hoogle [a] -> (a -> m b) -> [b]
11:02:26 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
11:02:26 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
11:02:26 <lambdabot> Data.List concatMap :: (a -> [b]) -> [a] -> [b]
11:02:29 <alej> so might as well write a version and be ready to throw it away
11:02:37 <jmcarthur> prototyping is the best way to learn
11:02:41 <alej> yep
11:02:58 <alej> ive already written one or two versions of the graphics part
11:03:04 <alej> and it's still…not that great, but it works fine
11:03:07 <jmcarthur> i wonder if there is a library lurking in there
11:03:31 <jmcarthur> for joins and such across many different kinds of containers
11:04:14 <jmcarthur> maybe some handy ways to have a denormalized representation with semantics that make it look normalized, even
11:04:35 <jmcarthur> but that's getting researchy. just make it work :)
11:04:37 <alej> haha
11:04:46 <alej> maybe i'll sneak it in while i'm at work
11:04:54 <alej> though it's hard to make haskell look like C
11:05:03 <aavogt> explicit layout helps
11:05:03 <tibbe> jmcarthur: it does have good performance :)
11:05:28 <tibbe> jmcarthur: about 4x faster than Map for lookups
11:05:38 <tibbe> jmcarthur: I hope I get inserts as fast as IntMap
11:06:06 <tibbe> dcoutts: you there?
11:06:18 <dcoutts> @yarr!
11:06:19 <lambdabot> Yeh scurvy dog...
11:06:20 <tibbe> dcoutts: which of the test patches do you think will make it in to 1.10?
11:06:27 <tibbe> dcoutts: it would be nice if the deps fix went in
11:06:39 <dcoutts> tibbe: which one is that?
11:06:41 <tibbe> dcoutts: so libraries with tests don't end up depending on e.g. test-framework
11:06:49 <tibbe> dcoutts: let me find the ticket
11:06:58 <jmcarthur> tibbe: yeah i just ran the benchmark suite. lookups look nice! inserts are unfortunate so far, but i hear there's still some more progress to be made
11:07:23 <tibbe> jmcarthur: yes, I'm waiting for some primops to get into GHC. copumpkin is on it.
11:07:48 <jmcarthur> tibbe: are deletions currently similar to insertions? that's not in the benchmark suite right now
11:07:49 <tibbe> jmcarthur: I'm also working on faster bulk creation (using mutation internally) to make the common use case of building the map in one go faster
11:07:57 <jmcarthur> awesome
11:08:09 <tibbe> jmcarthur: I haven't looked at that yet. Presumably as the operations are nearly indentical
11:08:41 <jmcarthur> well cool. i gotta go for now. keep up the awesome work, tibbe. good luck, alej.
11:08:49 <alej> thanks for your help
11:08:55 <tibbe> jmcarthur: thanks
11:09:50 <Kakarott> @where liftM
11:09:50 <lambdabot> I know nothing about liftm.
11:10:07 <Kakarott> @i liftM
11:10:07 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
11:10:14 <SirFrancisDrake> Control.Monad
11:10:14 <Botje> it's in Control.Monad
11:10:21 <Kakarott> thanks
11:10:22 <aristid> @index liftM
11:10:23 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
11:10:36 <aristid> it's also in Control.Monad.Reader... :)
11:10:53 <SirFrancisDrake> how did it get there? o_0
11:12:11 <monochrom> perhaps re-import and re-export
11:12:15 <dafis> re-exporting Control.Monad?
11:12:30 <dcoutts> tibbe: find it?
11:12:35 <tibbe> dcoutts: not yet
11:12:59 <dcoutts> tibbe: gotta do something about trac, we're loosing track! :-(
11:13:07 <tibbe> dcoutts: looks like there's no ticket
11:13:27 <tibbe> dcoutts: I'll send Thomas an email and CC you. It's an important fix if people actually use the test support
11:13:29 <dcoutts> tibbe: I didn't see any recent patch by email
11:13:39 <dcoutts> tibbe: ta
11:21:41 <Kakarott> @hoogle (a -> r) -> m [a] -> m r
11:21:41 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
11:21:41 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
11:21:41 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
11:23:05 <copumpkin> :t fmap concatMap
11:23:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> [b]) -> f ([a] -> [b])
11:23:10 <copumpkin> whoops
11:24:09 <tibbe> dcoutts: http://hackage.haskell.org/trac/hackage/ticket/797
11:24:13 <tibbe> dcoutts: email sent
11:24:18 <dcoutts> ta
11:25:20 <dcoutts> tibbe: oh is this just cabal-install, or is it runghc Setup configure too?
11:25:25 <aristid> :t fmap (=<<)
11:25:26 <lambdabot> forall a (m :: * -> *) b (f :: * -> *). (Monad m, Functor f) => f (a -> m b) -> f (m a -> m b)
11:25:29 <tibbe> dcoutts: let me check
11:25:36 <aristid> :t liftM (=<<)
11:25:37 <lambdabot> forall a (m :: * -> *) b (m1 :: * -> *). (Monad m, Monad m1) => m1 (a -> m b) -> m1 (m a -> m b)
11:25:59 <aristid> :t liftM (=<<) :: Monad m => m (a -> m b) -> m (m a -> m b)
11:26:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> m b) -> m (m a -> m b)
11:26:19 <aristid> :t join .: liftM (=<<)
11:26:21 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
11:26:21 <lambdabot>     Probable cause: `=<<' is applied to too few arguments
11:26:21 <lambdabot>     In the first argument of `liftM', namely `(=<<)'
11:26:36 <aristid> :t join .:. liftM (=<<)
11:26:37 <lambdabot> Not in scope: `.:.'
11:26:43 <aristid> @let (.:.) = fmap.fmap.fmap
11:26:45 <lambdabot>  Defined.
11:26:46 <aristid> :t join .:. liftM (=<<)
11:26:47 <lambdabot> forall (m :: * -> *) a a1 (f1 :: * -> *). (Monad m, Monad f1, Functor f1) => f1 (a1 -> m (m a)) -> f1 (m a1 -> m a)
11:26:54 <tibbe> dcoutts: ./Setup configure looks fine, so I guess this is only cabal-install
11:27:02 <copumpkin> oh, that function can't be written meaningfully
11:27:16 <dcoutts> tibbe: ok, should be easy then, and should not hold up Cabal-1.10 release
11:27:27 <aristid> lambdabot 1 : aristid 0 :(
11:27:39 <copumpkin> with Monoid r => (a -> r) -> m [a] -> m r you could do it
11:28:16 <tibbe> dcoutts: should I remove the Cabal-1.10 milestone then?
11:28:19 <copumpkin> :t \f -> fmap (Data.Foldable.foldMap f)
11:28:20 <lambdabot> forall a m (t :: * -> *) (f :: * -> *). (Data.Foldable.Foldable t, Monoid m, Functor f) => (a -> m) -> f (t a) -> f m
11:28:24 <dcoutts> tibbe: no that's fine
11:28:25 <copumpkin> fmap . Data.Foldable.foldMap
11:28:46 <tibbe> dcoutts: how much word do you have left on Cabal-1.10 now?
11:30:27 <dcoutts> tibbe: I think we're done really
11:30:39 <tibbe> dcoutts: sweet!
11:30:39 <dcoutts> tibbe: I'm just updating the user guide a bit
11:31:00 <dcoutts> tibbe: we'll need later releases in the 1.10 series, e.g. the hpc patches and many other things
11:31:22 <dcoutts> tibbe: we need a release now for ghc-7.0.2
11:31:29 <tibbe> dcoutts: ok
11:31:50 <tibbe> I'm eagerly awaiting a cabal-install that uses 1.10
11:32:01 <davekong> I used cabal to install a newer version of a module but now appear to have both versions instead of just the newer one, is this how cabal is supposed to work? How do I use the newer module in programs?
11:32:11 <tibbe> dcoutts: I can't really use the test support before that as it makes it hard for users
11:32:43 <dcoutts> tibbe: right, btw, I fixed the QA check for test-suite sections, so it only requires cabal-version: >= 1.8
11:32:58 <tibbe> dcoutts: sweet
11:33:07 <tibbe> dcoutts: that was a hackage change?
11:33:23 <dcoutts> tibbe: Cabal lib change that is used by the hackage scripts
11:33:33 <dcoutts> tibbe: so will need a recompile of those, once it's released
11:34:14 <tibbe> dcoutts: ok
11:38:35 * hackagebot network-bytestring 0.1.3.3 - Fast, memory-efficient, low-level networking  http://hackage.haskell.org/package/network-bytestring-0.1.3.3 (JohanTibell)
11:45:03 <dahankzter> 7.0.2??
11:45:24 <dahankzter> bah im on 6.12.3
11:45:35 <dahankzter> on archlinux, how weird is that
11:46:25 <davekong> dahankzter: you should follow along with the arch-haskell mailing list :)
11:46:30 <aristid> preflex: seen dons
11:46:30 <preflex>  dons was last seen on #haskell 1 day, 16 hours, 19 minutes and 57 seconds ago, saying: * dons -> boarding a plane. 
11:55:30 <davekong> How do I install something so that other modules can see it?
11:56:16 <SirFrancisDrake> is there a haskell analogue of wget? A light http library, maybe
11:56:33 <aristid> SirFrancisDrake: there are a couple of http libraries
11:57:40 <SirFrancisDrake> aristid: thanks. 
12:13:51 <hpc> wait, i am a patch now, dcoutts?
12:13:56 <hpc> :D
12:14:03 <dcoutts> heh
12:25:04 <shenshei> hello, someone know a tool for haskell project analysis ?
12:25:46 <dafis> shenshei: what sort of project analysis?
12:25:56 <sm> SourceGraph
12:28:10 <shenshei> yep: like SourceGraph
12:28:35 <shenshei> but who can parse everything compilable with ghc
12:30:17 <kleinucopia> is anyone here familiar with hs-twitter?
12:32:00 <Kakarott> I have a do in eva (line 129) : http://hpaste.org/43449/eva_without_do ; can somebody pls help me get it away ?
12:32:24 <alex404> What's the best way to manage a list of parametric datatypes where the parameters might be list? (Is there a sensible way?)
12:32:32 <alex404> *might be different
12:32:53 <alex404> err, that wasn't phrased well
12:33:22 <alex404> Looking for: heterogenous lists, determined up to class
12:33:25 <dafis> getRan _board >>= caseKiOf _board _depth
12:33:31 <dafis> Kakarott: ^^
12:34:15 <Kakarott> dafis: jeah ?
12:34:17 <dafis> alex404: like foo :: [exists a. Show a => a]?
12:34:32 <dafis> Kakarott: gets rid of the do
12:34:33 <Kakarott> i try
12:34:34 <aristid> :t app
12:34:35 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
12:34:52 <aristid> :t app `asTypeOf` uncurry id
12:34:53 <lambdabot> forall b c. (b -> c, b) -> c
12:35:05 <alex404> Hmm...
12:35:08 <alex404> Yes that might be the ticket
12:35:17 <alex404> I just don't fully understand :)
12:35:28 <Kakarott> dafis: Jeeeaaahhhhaaaa  Thank you :D
12:36:15 <alex404> dafis: Is it really that simple?
12:36:31 <alex404> dafis: That allows me any list of showable things?
12:36:35 <dafis> no
12:36:40 <dafis> alex404: you can define an existential type data Showable = forall a. Show a => S a, but then you can't use anything except Show methods on it
12:37:01 <dafis> with {-# LANGUAGE ExistentialQuantification #-}
12:37:05 <alex404> But if I have a class which encapsulates all methods I might want to run
12:37:14 <alex404> Then I'm good to go?
12:37:34 <dafis> Yes, but there may be better options
12:37:44 <dafis> depends on what you want to do
12:38:28 <alex404> Hmm... not sure how to describe what I'm doing :)
12:38:37 <alex404> I'm building a general neural network library
12:38:50 <alex404> I want to be able to have lists of neural networks
12:38:53 <alex404> Regardless of particulars
12:39:10 <alex404> So that I can have hybrid architectures
12:39:56 <alex404> What are some of the other solutions?
12:40:05 <dafis> Sounds as if a class and an existential type might be reasonable
12:40:30 <ddarius> alex404: You can just use a record type likely.
12:40:36 <otzi> hello. I'm reading this http://www.haskell.org/haskellwiki/Quasiquotation but it seems like ghc syntax has changed since they wrote it. [expr|1 + 3 + 5|] is invalid syntax, it seems like you need a $ before expr. Is that true or am I doing something wrong?
12:40:42 <dafis> you could make a parameterisedtype and have the methods you'd put in the class as members
12:40:49 <alex404> dafis: It looks like the right solution
12:41:02 <aristid> otzi: it's the other way around, i think. your GHC is too old for the wiki :)
12:41:17 <alex404> ddarius: What's the LD on that?
12:41:22 <sm> lol.. http://chrisdone.com/posts/2011-01-30-hulk-haskell-irc-server.html explains pure/impure well
12:41:24 <dafis> otzi: which ghc version have you?
12:41:32 <otzi> 6.12
12:41:48 <dafis> otzi: yup, the wiki is for the 7 syntax
12:41:51 <alex404> alex404: I'll likely be dealing only with a handful of different types, fwiw
12:42:01 <otzi> oh, I see :P
12:42:11 <sm> (typos aside)
12:42:14 <otzi> is ghc 7 compatible with the old syntax as well?
12:42:22 <dafis> I think so
12:58:05 <jfischoff> How do I demangle the type class names after profiling?
12:58:21 <jfischoff> I would like to know what function arbitrary_aEOJ actually is
12:58:40 <jfischoff> any ideas?
12:59:17 <cathper> Is there a reason why Data.List.intersect doesn't sort its input first?
12:59:30 <gwern> cathper: performance? nlogn is painful
12:59:38 <gwern> and if you want sorted, easy enough to sort yourself
12:59:39 <dafis> :t Data.List.intersect
12:59:41 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
12:59:49 <dafis> cathper: the type
13:00:13 <dafis> gwern: without sorting, it's quadratic
13:00:17 <cathper> gwern: You mean n^2 is faster?
13:00:23 <cathper> dafis: I see.
13:00:35 <gwern> @src intersect
13:00:35 <lambdabot> intersect = intersectBy (==)
13:00:39 <gwern> @src intersectBy
13:00:39 <lambdabot> intersectBy eq xs ys = [x | x <- xs, any (eq x) ys]
13:00:42 <cathper> There is Data.List.Ordered.isect ...
13:00:48 <aavogt> > (100 * log 100) `compare` (100 * 100)
13:00:49 <lambdabot>   LT
13:01:24 <aristid> > "aavogt" `compare` "aristid"
13:01:25 <dafis> > (10000*100*log 100) `compare` (1.23*100*100)
13:01:26 <lambdabot>   LT
13:01:26 <lambdabot>   GT
13:02:15 <gwern> not sure that's what I expected, but ok
13:02:26 * gwern has no explanation for why intersect doesn't do any sorting
13:02:34 <dafis> gwern: type
13:02:45 <dafis> how do you sort Eq?
13:02:54 <gwern> dafis: ah right. same issue with nub
13:02:58 <aavogt> gwern: maybe you'd want the result to have the same order as the one of the originals
13:03:00 <dafis> exactly
13:03:37 <gwern> (stability always struck me as overrated. I have yet to actually need it)
13:03:44 <aavogt> > "aristid" `intersect` "aavogt"
13:03:45 <lambdabot>   "at"
13:03:46 <rribeiro> @src transpose
13:03:47 <lambdabot> transpose []             = []
13:03:47 <lambdabot> transpose ([]   : xss)   = transpose xss
13:03:47 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
13:04:17 <aristid> > "aristid" `union` "aavogt"
13:04:18 <lambdabot>   "aristidvog"
13:04:41 <djahandarie> > "aristid" `union` "djahandarie"
13:04:42 <SirFrancisDrake> > "aavogt" `union` "aristid"
13:04:42 <lambdabot>   "aristidjhne"
13:04:43 <lambdabot>   "aavogtrisd"
13:05:18 <cathper> "aristid" `Data.List.Ordered.isect` "aavogt"
13:05:22 <cathper> > "aristid" `Data.List.Ordered.isect` "aavogt"
13:05:23 <dafis> > "dafis" `union` "djahandarie"
13:05:23 <lambdabot>   Not in scope: `Data.List.Ordered.isect'
13:05:24 <lambdabot>   "dafisjhnre"
13:05:37 <cathper> :-(
13:05:55 <cathper> Should be "a".
13:06:04 <dafis> > flip union "dafis" "djahandarie"
13:06:05 <aristid> > "djahandarie" `union? "djahanderie"
13:06:06 <lambdabot>   "djahandariefs"
13:06:06 <lambdabot>   <no location info>: parse error on input `?'
13:06:11 <aristid> > "djahandarie" `union` "djahanderie"
13:06:12 <lambdabot>   "djahandarie"
13:06:13 --- mode: ChanServ set +o monochrom
13:06:31 --- mode: monochrom set -b *!*@*troll*
13:06:37 --- mode: monochrom set -o monochrom
13:07:21 <aavogt> gwern: if intersect didn't have that kind of 'stability' people would get a lot less fun out of the above
13:07:37 <gwern> dubious fun
13:08:01 <dafis> gwern: nobody gets hurt
13:08:24 <gwern> dafis: one could say as much of porn
13:08:28 <gwern> and that's funner
13:08:44 <cathper> aavogt: One could sort (and keep track of changes), intersect and "desort" in a meaningfull manner.
13:08:51 <dafis> gwern: true, but are there any objections to porn?
13:09:09 <aavogt> cathper: I'm not sure that makes sense for duplicate items
13:09:13 <gwern> dafis: so I hear
13:09:43 <dafis> odd
13:09:59 <cathper> aavogt: Well, you can just mimic the way intersect works now, I guess.
13:11:36 <dafis> cathper: be aware of keeping multiple elements of the first, if you want to mimick
13:13:27 <cathper> dafis: Right.
13:15:10 <cathper> So, we could make a version of intersect that is faster for Ord than for Eq.
13:15:48 <dafis> cathper: yes
13:16:12 <dafis> make a Set of the second and filter (`member set) first
13:16:19 <dafis> `member`
13:17:10 <dafis> but it'll probably be slower on short lists
13:17:23 <cathper> For sure.
13:17:25 <mzero> or better: sort them both, and then run through the lists
13:17:47 <cathper> But for short lists the time is ~0 anyway.
13:18:04 <dafis> mzero: if you want to keep the order of the first list, that doesn't work
13:18:11 <mzero> true 'nuf
13:19:33 <deech> Similar to Okasaki's Functional Data Structures does anyone know of a book on lazy algorithms? 
13:20:16 * gwern doesn't
13:20:25 * dafis neither
13:20:37 <dafis> unfortunately, would be interesting
13:21:06 <deech> What about this guy? (http://www.amazon.com/Pearls-Functional-Algorithm-Design-Richard/dp/0521513383)
13:21:34 <dafis> excellent reputation, if I'm not confusing him
13:21:40 <cathper> There are some adaptive algorithms that is even faster in practice.
13:21:42 <cathper> Demaine, E.D., López-Ortiz, A., Munro, J.I.: Experiments on adaptive set intersections for text retrieval systems. In: Buchsbaum, A.L., Snoeyink, J. (eds.) ALENEX2001. LNCS, vol. 2153, pp. 91–104. Springer, Heidelberg (2001)
13:21:47 <dafis> it's Richard Bird innit?
13:21:58 <deech> yup, it's a new book. 
13:22:17 <gwern> deech: I would expect bird to be focused more on proof than new or interesting laziness
13:23:21 <deech> A quick glance at the reviews and the table of contents does not mention laziness at all. Maybe its in there. 
13:24:08 <deech> I feel Haskell's laziness working against me because I dont' know how to leverage it beyond infinite lists and the like.
13:24:48 <Ke> the compiler can optimize away the laziness often
13:25:05 <cathper> And does, in my experience.
13:26:07 <cathper> Forcing strictness actually made some of my stuff a tiny bit slower.
13:26:16 <deech> Yeah, but a study of Okasaki's book opened my eyes to the value of laziness in, for example, his constant time persistent queue. I would never have come up with that and I want to know more.
13:26:37 <dafis> cathper: it's very delicate to find where to force
13:27:02 <cathper> dafis: That's what I've experienced.
13:27:43 <deech> I was stunned by Okasaki's use of a "scheduler", and when I finally understood it I realized I know nothing.
13:28:06 <dafis> pshh Socrates knew that 2500 years ago
13:28:27 <gwern> Martin - 'I've filled my head with crap!'
13:28:33 <deech> Socrates knew about schedulers? 
13:28:36 <cathper> "Everything is calculated anyway, so add strictness." is way too naïve, but I started there :-)
13:29:29 <dafis> cathper: for the beginning, try the other orute, let the compiler figure it out and see where it's too slow
13:29:52 <cathper> dafis: Right. And rethink your algorithms.
13:29:56 <dafis> deech: Socrates knew a) everything, b) that he knew nothing
13:30:08 <dafis> cathper: that above all
13:30:16 <cathper> The latter made a ~10000x speedup :-)
13:30:19 <deech> indeed :)
13:30:40 <dafis> cathper: but that's rare, I'm usually happy with 2*
13:30:59 <dafis> or 5% sometimes
13:32:05 <cathper> dafis: Right. My first shot was to implement everything as quickly as possible and in as few lines as possible (to make as few errors as possible). After that I started thinking ...
13:32:53 <dafis> cathper: Good strategy. Fewer opportunities to screw up simple code, then you have something to check against.
13:33:02 <deech> cathper: Haskell is awesome for that. When I try that in a dynamic language, which everyone says is good for rapid prototyping, I fall all over myself. Haskell code works the first time.
13:33:50 <cathper> In reality it's pretty hard to know where to put your effort in optimizing before you crank up your profiling tools.
13:34:06 <cathper> dafis: Sure.
13:34:32 <cathper> deech: Indeed. I just avoided other languages :-)
13:34:37 <dafis> cathper: experience helps finding a lot of spots even without profiling
13:35:06 <dafis> cathper: and sometimes profiling completely changes the behaviour of your programme
13:35:28 <deech> cathper: Career-wise, how have you managed that? I still curse at Java during the day.
13:35:32 <cathper> dafis: Right. But if your problems are hard to predict, the algorithms might be slow, but ~no time can still be spend there.
13:36:08 <Guest73023> hello, I was just reading LYAH and I was wondering about something, there is an example that recursively calls main to loop back to the beginning of the program, is there the possibility to bloat or overflow the stack by doing something like that?
13:36:23 <cathper> deech: So far, pretty easy. I'm a PhD student in mathematics.
13:36:25 <Twey> Guest73023: That's absolutely fine
13:36:47 <Twey> Guest73023: You won't overflow the stack so long as it's tail-recursive
13:36:52 <monochrom> main = do { blahblah ... ; main } at the end does not blow anything
13:36:59 <mauke> Twey: that seems wrong
13:37:10 <dafis> Guest73023: you *can* overflow the stack by doing 'something like that', but usually you don't
13:37:12 <deech> Guest73023: Unless it never terminates.
13:37:14 <Twey> Mm, not sure
13:37:30 <Guest73023> I'm thinking of something like a game or something like that
13:37:42 <Guest73023> where you loop back every frame
13:37:43 <deech> cathper: I envy you.
13:37:56 <mauke> I don't think that uses the stack so it should be fine
13:38:12 <monochrom> looping back does not blow stack
13:38:17 <dafis> cathper: what are you specialisng in?
13:38:19 <Twey> If you have ‘foo = do ns <- foo; return $ 1 : ns’ surely it will eventually get too big and explode
13:38:23 <cathper> deech: I know. I feel happy :-)
13:38:30 <mux> if I have a safe vector type with type-level numbers to encode the length, it's impossbile to type a filter function on them with Haskell, right?
13:38:30 <Twey> Maybe not the stack
13:38:47 * monochrom waits for the third equivalent question
13:39:00 <cathper> dafis: I've done some network coding and something on bounding the number of zeros of given multiplicity of multivariate polynomials.
13:39:01 <dafis> mux: right, you don't know the length of the filtered vector before
13:39:06 <mauke> > let foo = do ns <- foo; return $ 1 : ns in foo
13:39:07 <lambdabot>   No instance for (GHC.Show.Show (m [t]))
13:39:07 <lambdabot>    arising from a use of `M27642468...
13:39:16 <mauke> > let foo = do ns <- foo; return $ 1 : ns in foo :: Maybe [Int]
13:39:17 <Twey> mauke: In IO
13:39:20 <lambdabot>   mueval-core: Time limit exceeded
13:40:15 <Twey> Prelude> let foo = do ns <- foo; return $ 1 : ns in foo :: IO [Int]
13:40:15 <Twey> *** Exception: stack overflow
13:40:29 <monochrom> well, just asking twice is an improvement. usually people ask three times.
13:41:05 * hackagebot zip-archive 0.1.1.7 - Library for creating and modifying zip archives.  http://hackage.haskell.org/package/zip-archive-0.1.1.7 (JohnMacFarlane)
13:41:33 * ddarius highly recommends not completely ignoring laziness/eagerness when writing code while thinking, "I'll just profile it later."
13:42:12 * dafis agrees, but it's okay while beginning with Haskell
13:42:31 <ddarius> Certainly you don't need to tune it to the best possible code, but it's much easier to get the big things as you're writing than to wait until you have a bunch of code and non-local interactions.
13:42:55 <ddarius> The logic would be similar to "I'll write code as fast as possible and debug it later."
13:43:35 <homekevin> Wait, is there another way to write code?
13:43:48 <dafis> ddarius: Quite, but you have to gather some experience with what laziness does where before you can think about it
13:44:10 <monochrom> experience or education
13:44:16 <ddarius> dafis: A beginner is going to be unable to use the output of a profiler, so it's okay for beginners as long as they are only doing exercises and toys.
13:45:38 <Tomsik> newtype WrappedMonad m a
13:45:41 <Tomsik> What's that?
13:45:49 <Tomsik> from applicative
13:46:15 <dafis> Tomsik: a wrapper to be able to define your own instances
13:47:58 <Tomsik> @djinn (a -> m b) -> (m a -> m b)
13:47:58 <lambdabot> -- f cannot be realized.
13:48:09 <Tomsik> @djinn Monad m => (a -> m b) -> (m a -> m b)
13:48:10 <lambdabot> f a b = bind b a
13:48:23 <Tomsik> damn
13:49:03 <Tomsik> who the heck thought something as ugly as =<< or >>= is okay
13:49:07 * mux is amazed at how simple it is to define the Add and Mul type functions on type-level numbers using type families, allowing to type and write the append and concat functions on safe lists
13:49:33 <mux> I said 'type' four times in that sentence, damn you Haskell
13:50:06 <Tomsik> damn you and your type system, Haskell
13:50:40 <Tomsik> Oops
13:50:41 <Tomsik> Sorry
13:50:47 <Tomsik> Didn't mean to netplit you
13:50:56 <cathper> :-D
13:51:02 <dafis> Tomsik: bad boy
13:51:08 <mux> however it's really really nice to see that for your Add and Mul type functions, you need to recurse in exactly the same "order" as you do in the functions
13:52:17 <mux> that is, if 'append' works by pattern matching on the first list, the type function 'Add' for the result type of Vec (Add m n) a needs to be defined on pattern matching the left type
13:53:39 <Tomsik> It's pretty sad that we don't have numeric type literals
13:53:43 <Tomsik> at least IMO
13:53:49 <Tomsik> There's probably a reason for that?
13:54:12 <Tomsik> VecN 4 instead of VecN Four or something
13:54:21 <maurer_> Tomsik: Look up dependent types
13:54:35 <mauke> VecN D4
13:54:40 <ddarius> maurer_: Dependent types aren't necessary for numeric type literals.
13:54:43 <Tomsik> yeah, but you need a typedef
13:54:49 <ddarius> :k 1
13:54:50 <lambdabot> *
13:54:51 <Tomsik> I mean like, just write a darn number
13:54:55 <ddarius> :k 0
13:54:55 <maurer_> ddarius: Well, to do anything useful with them...
13:54:55 <lambdabot> Only unit numeric type pattern is valid
13:55:05 <ddarius> maurer_: Is unnecessary.
13:55:19 <maurer_> ddarius: I suppose it would still be nice as a shorthand.
13:55:20 <ddarius> maurer_: Nothing stops the type level from having it's own computation language.
13:55:42 <dafis> Types parameterised over numbers would be quite nice sometimes
13:56:45 <maurer_> ddarius: Can you point me at an example?
13:57:30 <ddarius> λω or System Fω has an arbitrary typed lambda calculus at the type level.
13:58:02 <mux> http://hpaste.org/43453/safe_vectors_finite_lists_wi
13:58:08 <ddarius> maurer_: There's no trouble having a kind of naturals and type constructors like Matrix :: Nat -> Nat -> *
13:58:21 <mux> I started from the Vec datatype in the last post from Conal and added a few things
13:58:49 <ddarius> maurer_: All dependent types add is the ability for the type level to depend on value level terms.
13:59:19 <ddarius> In fact SHE basically does exactly this.
13:59:33 <maurer_> ddarius: In that case why don't we have this capability?
13:59:53 <b0fh_ua> Hello! I have some problem with the code at http://pastebin.com/h6DuvJY8. For some reason when uncommenting the line 16 parser fails, however in input there are a lot of zero bytes I want to skip
13:59:58 <b0fh_ua> what may cause the problem there?
14:00:04 <b0fh_ua> I'm using attoparsec
14:00:08 <ddarius> maurer_: SHE is a preprocessor that provides it, but basically it wasn't added and it certainly makes the type level more complicated.
14:00:37 <maurer_> ddarius: Also, I'm a little unclear, would this allow functions of the type cons :: List a n -> List a (n + 1) ?
14:00:50 <maurer_> err, cons :: a -> List a n -> List a (n + 1)
14:00:52 <dafis> b0fh_ua: perhaps you need to give a type
14:00:56 <maurer_> Where n is a Nat
14:01:11 <b0fh_ua> dafis: sorry?
14:01:18 <maurer_> Or is this just a massive aliasing system?
14:01:18 <nejucomo> What does "| m -> e" mean in this:  class http://hackage.haskell.org/packages/archive/base/4.3.1.0/doc/html/Control-Monad.html#t:Monad m => MonadError e m | m -> e where ...
14:01:26 <ddarius> maurer_: Sure, but it wouldn't allow something like toVec :: (l :: [a]) -> List a (length l)
14:01:31 <mux> maurer_: a -> Vec n a -> Vec (S n) a is not good enough for you?
14:01:41 <dafis> skipWhile (== (0x00 :: Word8))
14:01:57 <ddarius> @where SHE
14:01:57 <lambdabot> http://personal.cis.strath.ac.uk/~conor/pub/she/
14:02:02 <ceii_> nejucomo: this is a functional dependency
14:02:11 <dafis> nejucomo: it's a functional dependency, m determines e uniquely
14:02:18 <ceii_> means the type m determines the type e
14:02:30 <beastaugh> does anyone know how I can print UTF-8 characters to the terminal in Windows?
14:02:31 <b0fh_ua> dafis: nope, this doesn't work
14:02:32 <Tomsik> nejucomo: something like "e can be determined from m, so no need for it in the type"
14:02:45 <b0fh_ua> skipWhile expects function Word8->Boolean
14:03:28 <dafis> b0fh_ua: okay, then the type is already determined
14:03:42 <nejucomo> How is e determined from m?  Does this mean "For any m there can be only one instance of MonadError e m?"
14:03:51 <ceii_> yep
14:03:53 <dafis> nejucomo: that
14:04:21 <ceii_> and the type checker will take advantage of that to infer e when m is known
14:04:36 <nejucomo> huh.  But there may be different instances varying over e, right?
14:04:51 <ceii_> no, you can only provide one
14:05:16 <b0fh_ua> dafis: that doesn't make sense for me, I beleive that skipWhile should either skip something, but not fail
14:05:32 <b0fh_ua> but if I change condition - nothing really changes
14:05:46 <b0fh_ua> even if I add "try" in front of AP.skipWhile
14:06:20 <dafis> b0fh_ua: doesn't make sense to me either, perhaps it's all zeros and you'd get an unexpected end of input, but otherwise ...
14:06:26 <nejucomo> ceii_: That seems odd.  Does that mean "For any given monad instance, there is only a single MonadError type for that instance." ?
14:06:48 <ceii_> precisely that
14:06:51 <nejucomo> Am I prevented from having two different types of error for Maybe, for example?
14:07:01 <b0fh_ua> nope, I printed the content and it shows that there're some other input available
14:07:15 * hackagebot preprocessor-tools 0.1.2 - A framework for extending Haskell's syntax via quick-and-dirty preprocessors  http://hackage.haskell.org/package/preprocessor-tools-0.1.2 (JesseTov)
14:07:32 <ceii_> if you have an "instance MonadError () Maybe" 
14:07:37 <dafis> b0fh_ua: what type does read4Bytes produce?
14:07:47 <ceii_> then you can4t write a second "instance MonadError String Maybe"
14:08:06 <nejucomo> Ah, I see, but I could have those instances in different type scopes, right?
14:08:26 <dafis> nejucomo: ultimately, they're all in Main's scope
14:08:33 <ceii_> type scopes?
14:08:41 <nejucomo> Modules, perhaps?
14:08:52 <monochrom> modules do not hide away instances
14:08:53 <dafis> nejucomo: not enough
14:08:55 <ceii_> projects, maybe
14:09:06 <dafis> projects is possible
14:09:13 <nejucomo> modules do not hide instances even when they have an explicit export list?
14:09:20 <monochrom> right
14:09:28 <nejucomo> woah.  Good to know.
14:09:30 <ceii_> yes, you always export and import all instances
14:09:37 <dafis> nejucomo: no, import an instance and it's visible everywhere above
14:10:20 <b0fh_ua> dafis: Parser Word32
14:10:23 <nejucomo> huh.  Would changing that be a plausible language extension?
14:10:39 <ceii_> there has been talk about that, I think
14:10:40 <dafis> b0fh_ua: just saw that, I thought it was from AP
14:10:45 <nejucomo> For example, what if I want to have a different Show syntax in a specific module?
14:11:36 <ceii_> the question is: what happens when you pass a showable value to that module and it prints it?
14:11:45 <ceii_> does it use your instance or its own?
14:12:03 <dafis> b0fh_ua: I can make no sense of that behaviour
14:12:39 <nejucomo> "its own"?  I must not understand the semantics of type classes.
14:12:57 <b0fh_ua> dafis: yeah
14:13:07 <ceii_> what I mean is, suppose you have a module M that has a Show instance for Int
14:13:09 <b0fh_ua> looks like I have to rewrite everything w/o this parser
14:13:22 <b0fh_ua> just using plain old ByteString stuff )
14:13:29 <ceii_> then in another module N I import some functions from M, but not its instances
14:13:32 <nejucomo> I can imagine different implementations.  In one, there is a table (scoped either globally or per module) that maps types to instance functions for that type.
14:13:41 <alex404> What is the easiest way to implement some kind of inheritance? i.e. I have a class, and I want to define another class which tacks on another couple methods?
14:13:43 <ceii_> and I define another Show instance for Int
14:14:01 <ceii_> and I use some functions from M that do stuff to Ints by showing them
14:14:18 <ceii_> which instance should they use?
14:14:33 <sipa> nejucomo: there are dictionaries
14:14:38 <sipa> corresponding to instances
14:14:47 <nejucomo> ceii_: I see.  I had imagined instance selection is defined by "static scope" so at the point where "show x" is called, there is a statically defined table of { type -> instance_methods }.
14:14:50 <sipa> that are passed around as implicit arguments to functions
14:15:01 <ceii_> that's one option alright
14:15:18 <ceii_> but there's another one, and it's not really clear which is better
14:15:20 <sipa> ceii_: you cannot hide instances
14:15:32 <sipa> if you import a module, you import all its instances
14:15:32 <nejucomo> sipa: Right, we are discussing language variations.
14:15:37 <ceii_> sipa: we're talking about an extension to permit that
14:15:37 <sipa> apologies
14:15:43 <sipa> i wasn't following
14:15:48 <sipa> but it's dangerous i think
14:16:06 <ceii_> it somehow scares me too
14:16:07 <sipa> having different modules thing differently about the instance definitions of a given type
14:16:27 <ceii_> I guews it could cause surprises
14:16:30 <nejucomo> Am I correct to think that whether or not instance methods are passed around with instance values or whether they are looked up in a table doesn't alter their semantics?
14:16:31 <ceii_> guess*
14:16:46 <ceii_> nejucomo: yes
14:16:51 <nejucomo> How could it cause surprises?
14:17:12 <ceii_> it's an implementation matter, though looking them up in a table would require runtime type tags
14:17:17 <nejucomo> The importer of a module which uses "private instances" will never know or care if that is the case.
14:17:50 <nejucomo> Anyway, this discussion has helped me understand existing type classes a bit.
14:17:59 <ddarius> nejucomo: If I make a Set in one module using one Ord instance and then pass it to a function defined in another module with its own Ord instance which then manipulates it, what Ord instance should be used?
14:18:36 <nejucomo> So you are talking about three modules there:  Outer, Inner, and Set.
14:18:55 <nejucomo> All Set functions use the Ord imported in the Set module.
14:19:12 <ddarius> Set doesn't import an Ord instance (necessarily.)
14:19:16 <Kakarott> how can I force a program written in haskell to use multicore system ?
14:19:30 <nejucomo> Yes, I'm starting to see problems.  :-)
14:20:17 <nejucomo> So I'm looking into using mtl instead of writing similar stuff from scratch (which I used to do).
14:20:58 <nejucomo> Previously I would define "type Result t = Either MyError t".  But if I use MonadError what would m be?
14:21:16 <nejucomo> Is there a "degenerate Monad"?
14:21:36 <nejucomo> data M t = M t; instance Monad M where … ?
14:21:50 <ceii_> yes, it's the identity monad
14:22:04 <ceii_> should be a Control.Monad.Identity module I think
14:22:15 <nejucomo> Ah, thanks.
14:26:52 <dafis> alex404: class as in "class Eq a where"? class (Parent a) => Child a where
14:28:03 <alex404> dafis: Yah, I know that much. My thinking is just in a knot that I can't sort out...
14:28:16 <alex404> dafis: I'm just going to sleep on it. Cheers.
14:28:18 <dafis> so, perhaps we can help
14:28:24 <dafis> or sleep
14:28:24 <alex404> Well...
14:28:59 <alex404> Okay I have one class with some methods
14:29:12 <alex404> And I have another class, which can be built out of a member of the first class via a function
14:29:15 <alex404> like buildFoo
14:29:29 <alex404> with some extra junk
14:29:51 <Kakarott> good night
14:29:57 <alex404> Would the type signature look something like class (Foo a) => Bar b a where
14:30:10 <alex404> or what
14:30:12 <ceii_> alex404: yes
14:30:28 <dafis> alex404: perhaps with a functional dependency
14:30:38 <alex404> And if I have a functional dependency already...
14:30:44 <dafis> alex404: or type families
14:30:58 <alex404> Type families I don't know abuot
14:31:09 <andres_> hello could someone tell me an example kind's (types of types)?
14:31:18 <sipa> *
14:31:20 <alex404> Right now I have (Class Foo a b | a -> b)
14:31:20 <sipa> * -> *
14:31:22 <dafis> alex404: learn about them some time, it's not urgent, though
14:31:29 <alex404> *nod*
14:31:50 <alex404> And I want I guess (Class (Foo a b) => Bar c a b
14:31:56 <dafis> alex404: okay, is that b related to Bar?
14:31:57 <ceii_> andres: actual types have kind *. Maybe has kind "* -> *", because it takes a type and creates a type (like Maybe String)
14:32:07 <alex404> It doesn't show up in the methods
14:32:39 <alex404> Since it's a fundep it's kind of redundant to include it in the type signature of Bar
14:33:10 <andres_> ceii: so a kind could be something like " :: Int -> [Int] -> Int" ?
14:33:12 <alex404> All Bar actually does is tack on a couple more accessors wholy unrelated to Foo
14:33:19 <dafis> alex404: try class (Foo a b) => Bar c a where
14:33:28 <ceii_> no, that's a type
14:33:46 <alex404> dafis: Give me a sec...
14:33:48 <ceii_> but Int -> [Int] -> Int has kind *
14:34:43 <alex404> dafis: With what you just gave me, haskell said I didn't apply Foo to enough type arguments
14:35:22 <andres_> ceii: I don't understand
14:35:28 <dafis> alex404: you wrote (Foo a b) and I wrote (Foo a b)
14:35:45 <ddarius> :k (->)
14:35:46 <lambdabot> ?? -> ? -> *
14:35:48 <ddarius> :k (->) Int
14:35:49 <lambdabot> ? -> *
14:35:53 <ddarius> :k (->) Int Int
14:35:54 <lambdabot> *
14:36:02 <alex404> dafis: Here's what I've got right now: http://hpaste.org/43454/class_problem
14:37:24 <dafis> alex404: you never use the sn in SubNetwork
14:39:20 <andres_> so what is the use of the kind?
14:39:45 <dafis> alex404: and that gives "SubNetworkProperties not applied to enough type arguments"?
14:40:03 <ceii_> to make sure type constructors are applied in the right way
14:40:08 <alex404> dafis: einen moment
14:40:27 <ceii_> for example, "Maybe Maybe" can't be made sens of as a type
14:40:51 <ceii_> and indeed, Maybe has kind * -> *, so it need something of kind * as its parameter
14:41:41 <sipa>  correct
14:42:15 <aristid> the kind of f with valid f f would be infinite, right?
14:42:24 <ceii_> yes
14:42:52 <ceii_> you'd need a kind k such that k = k -> *
14:42:55 <alex404> dafis: What I showed you, yah that gives me that error
14:43:44 <andres_> so how could I create a kind?
14:43:46 <dafis> alex404: Hmm, I don't see why. What's the intended relation between s and sn?
14:44:02 <ceii_> andres_: you don't manipulate kinds in Haskell
14:44:15 <ceii_> they're only used to reason about types
14:44:21 <alex404> dafis: Well, they're effectively the same. One is SubNetwork properties, and then the other is SubNetwork with a couple vectors tacked on
14:44:59 <cole> What's a better way to do: "nextNode (Node _ (Rect x y w h)) = (Node "" (Rect (x + w + 2) y w h))"
14:45:07 <aristid> ceii_: not k = * -> k?
14:45:19 <dafis> alex404: would class (SubNetworkProperties s p) => SubNetwork s where describe what you're trying to do?
14:45:20 <alex404> dafis: Eventually I want a 'buildSubNetwork' function which takes a couple vectors, the SubNetworkProperties, and generates the appropriate SubNetwork.
14:46:02 <ceii_> aristid: no, you want to apply f to itself, so it has to take it's own kind as first parameter
14:46:18 <alex404> dafis: But if I include s in the SubNetwork class, then it is always a member of the subnetwork class. I want to be able to manage them distinctly.
14:47:16 <alex404> dafis: As I understand your definition, then I won't be able to define an s which is a SubNetworkProperties but not a SubNetwork
14:48:16 <dafis> alex404: you can, it's the other way round, you can't define a SubNetwork which isn't a SubNetworkProperties (for some Properties type)
14:49:33 <alex404> dafis: Processing...
14:49:41 <dafis> alex404: the notation is backwards in a sense, "class A a => B a" means that (A a) is a necessary precondition for an instance of B
14:50:00 <dafis> alex404: read "=>" as "requires" here
14:50:31 <dafis> class (Eq a) => Ord a where
14:50:38 <ddarius> dafis: "is required by"
14:50:48 <alex404> dafis: I understand that much... I can read an implication sign... but if a is a member of B, then a is always a member of A
14:50:51 <dafis> to have an instance of Ord, you first must have one of Eq
14:51:04 <ddarius> alex404: No, it doesn't read as an implication in class constraints.
14:51:06 <dafis> ddarius: yes, thanks
14:51:09 <ddarius> alex404: It reads backwards.
14:51:23 <alex404> oh
14:51:27 <alex404> hmm
14:51:29 <andres_> ceii_: could you give me an essier example for understandinig kinds?
14:51:57 <sipa> it reads "is a requirement for"
14:52:14 <edwardk> preflex: xseen roconnor
14:52:14 <preflex>  roconnor was last seen on freenode/#haskell 4 hours, 33 minutes and 45 seconds ago, saying: Const is a pretty great Functor
14:52:20 <sipa> (but not a sufficiant one)
14:52:22 * roconnor here
14:52:26 <edwardk> yo
14:52:30 <roconnor> yo
14:52:41 <edwardk> debating about building a memoized store, at least memoizing the current answer
14:53:19 <roconnor> that sounds plausibly useful
14:53:25 <alex404> dafis: Can you possibly give me an example of how I might instance the classes?
14:53:27 <edwardk> data MemoStoreT s w a = MemoStoreT (w (s -> a)) s (w a) — where the latter is the result of mapping ($s) over the w (s -> a)
14:53:30 <roconnor> I'm not sure I'd make it default
14:53:40 <edwardk> not planning on making it default
14:54:07 <edwardk> just chewing on it. unlike State we know the current value of s, so we can exploit this if the same store object is used multiple times
14:54:33 <roconnor> indeed
14:54:52 <dafis> alex404: instance SubNetworkProperties Int Int where {- whatever -}; instance SubNetwork Int where {- something else -}
14:55:34 <edwardk> roconnor: i also give you another challenge. is there a useful analogue to the speculation combinators in Discont? =)
14:56:28 <alex404> dafis: Okay, I think I got it. Thanks a lot for your help.
14:56:39 <dafis> welcome
14:57:03 <roconnor> I know nothing about Discont
14:57:15 <parcs> does anyone know ghc 7 successfully working under wine 1.3?
14:57:55 <edwardk> data Discont s w a = Discont (w s -> a) (w s) — is the old ContextT from category-extras
14:58:27 <edwardk> left kan extension of Const whereas Cont is the right kan extension of Const
14:59:06 <edwardk> er of 'ConstT f a b = ConstT (f a)' technically
14:59:39 <edwardk> its the bad version that doesn't admit the get/put laws, but does seem to admit a version of callCC 
15:00:31 <alex404> dafis: When i throw this at ghc: 'class (SubNetworkProperties s p) => SubNetwork s where' it chokes saying 'Not in scope: Type variable p'
15:02:01 <aristid> alex404: the p has to be on both sides of the =>
15:02:08 <dafis> alex404: Hmm, I'd have thought the FunDep would take care of that
15:02:20 <aristid> dafis: nope, only type families can
15:02:35 <alex404> So maybe I should look into type families?
15:02:44 <dafis> alex404: seems so
15:02:55 <alex404> Cheers
15:03:23 <dafis> alex404: class SubNetworkProperties s where { type Properties; mmethods }
15:03:28 <augur> conal: why so sad
15:03:39 <conal> augur: ??
15:03:48 <dafis> class (SubNetworkProperties s) => SubNetwork s where ...
15:03:50 <augur> i checked you blog; there's :< faces everywhere!
15:03:54 <aristid> conal: don't be sad
15:04:03 <augur> turn that frown :<
15:04:05 <augur> UPSIDE DOWN :>
15:04:10 <conal> uh oh. where, for instance?
15:04:17 <conal> and in which browser?
15:04:21 <augur> lol
15:04:25 <conal> or browsers?
15:04:26 <augur> fixing lists dude
15:04:29 <augur> your :< operator
15:04:41 <aristid> lol
15:04:42 <conal> oh!
15:04:45 <augur> :P
15:04:46 <edwardk> roconnor: also looking at adding an indexed store comonad somewhere
15:04:47 <conal> hah
15:04:54 <stepkut> augur: no, :< upside down is still :<
15:04:59 <edwardk> roconnor: i have it drawn up, but i haven't packaged the indexed (co)monads yet
15:05:04 <augur> stepkut: no no thats >:
15:05:09 <aristid> stepkut: it's a vertical palindrome
15:05:13 <aristid> like TOYOTA
15:05:19 <augur> obviously your sense of direction is messed up
15:05:23 <aristid> except that one has to be written vertically
15:05:27 <augur> aristid: whats a vertical palindrome XD
15:05:46 <dafis> H
15:05:50 <djahandarie> conal, you may find this interesting: http://www.cas.mcmaster.ca/~bendermm/research.html
15:06:19 <augur> djahandarie: thats not a palindrome, thats a symmetry
15:06:22 <andres_> someone could give like the clearest example of a kind and the of it?
15:06:37 <CaScAdE^PC> good evening folks
15:06:39 <djahandarie> A denotational and operational semantics for imperative reasoning
15:06:53 <djahandarie> Also term rewriting
15:06:58 <augur> djahandarie: isnt that what hoare logic is?
15:07:06 <augur> oh, not rewriting tho
15:07:11 <conal> djahandarie: ah. thanks. have you looked at it? does it address concurrency at all?
15:07:45 <augur> conal: i just read a paper on rewriting logic
15:07:55 <augur> that claims to do that
15:08:13 <augur> syntax, semantics, term rewriting, and concurrency
15:08:55 <djahandarie> conal, hm, I don't think it does directly
15:09:34 <djahandarie> All it has is cells (memory locations), assignment, sequence, intension (procedure formation), and extension (procedure invocation)
15:10:02 <companion_cube> such systems usually deal with non determinism rather than concurrency, aren't thye ?
15:10:49 <alex404> dafis: Is there a bottom to the rabbit hole that is haskell?
15:11:11 <dafis> alex404: there's a bottom in every type ;)
15:11:18 <mafs> alex404: sort of. unfortunately, it loops back around to the entrance
15:11:42 <alex404> Those are both reassuring. I think ;)
15:12:16 <djahandarie> augur, I think the difference is that Hoare logic is consideribly more complicated and has more "ad-hoc" rules
15:12:39 <augur> hm
15:12:39 <djahandarie> (Compared to say, lambda calc)
15:13:26 <dafis> alex404: it might take some time to feel at home, but it's very comfortable
15:15:34 <alex404> dafis: I already like it here. If I were willing to compromise on the exact form of my code, than I'd likely move through some things faster. But then I wouldn't learn as much :)
15:16:40 <franz_> hi djahandarie and or moshee
15:16:49 <moshee> hi franz_
15:16:52 <CaScAdE^PC> is the haskel scheduler deterministic?
15:17:07 <ddarius> CaScAdE^PC: No.
15:17:13 <CaScAdE^PC> ddarius: damn :-)
15:17:15 <ddarius> (Well, GHC's isn't.)
15:17:46 <hpc> arguably, it shouldn't be
15:17:48 <djahandarie> Would a deterministic scheduler be useful?
15:17:54 <ddarius> preflex: seen copumpkin 
15:17:54 <preflex>  copumpkin was last seen on #ghc 3 hours, 27 minutes and 33 seconds ago, saying: buon appetito :P
15:18:05 <ddarius> djahandarie: For debugging it would be.
15:18:09 <hpc> it would enable such nasty things as writing behavior to target the bugs in the scheduler
15:18:15 <copumpkin> ddarius: yo!
15:18:22 <edwardk> when debugging a pessimistic interleaving scheduler is really useful too
15:18:29 <CaScAdE^PC> djahandarie: for my current task in my lecure: yes :-) and for a lot of other stuff as well ^^
15:18:50 <gwern> @dice 1d100
15:18:50 <lambdabot> 1d100 => 55
15:18:58 <gwern> @dice 1d200
15:18:58 <lambdabot> 1d200 => 93
15:19:40 <CaScAdE^PC> i have to show that some kind of buffer (in STM context) we have is not always preserving the fifo-behaviour... so a deterministic scheduler would make it easier
15:19:48 <ddarius> copumpkin: Whether, when, where?
15:19:53 <franz_> @dice 1d1
15:19:53 <lambdabot> 1d1 => 1
15:19:57 <franz_> awesome
15:20:07 <franz_> @dice -1
15:20:08 <lambdabot> unexpected "-": expecting number
15:20:10 <franz_> :(
15:20:17 <copumpkin> ddarius: sure, whenever you feel hungry, that place you suggested last time? remind me where that was?
15:20:28 <ddarius> copumpkin: 75 Chestnut is the name and location.
15:21:15 <ddarius> @dice 9223372036854775807d2
15:21:16 <lambdabot> 9223372036854775807d2 => 13835058056092216918
15:21:44 <hpc> @dice ∞
15:21:45 <lambdabot> unexpected "\226": expecting number
15:21:48 <hpc> :(
15:22:39 <SirFrancisDrake> @dice 3d6
15:22:39 <lambdabot> 3d6 => 15
15:23:47 <aristid> :t \f g -> either (Left . f) (Right . g)
15:23:48 <lambdabot> forall a b a1 b1. (a1 -> a) -> (b1 -> b) -> Either a1 b1 -> Either a b
15:23:58 <aristid> @hoogle (a1 -> a) -> (b1 -> b) -> Either a1 b1 -> Either a b
15:23:58 <lambdabot> No results found
15:25:01 <SirFrancisDrake> it's something like (+++)
15:25:21 <SirFrancisDrake> :t Control.Arrow.(+++)
15:25:22 <lambdabot> Couldn't find qualified module.
15:25:49 <hpc> :t (Control.Arrow.+++)
15:25:50 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
15:25:54 <SirFrancisDrake> looks like I failed the roll
15:27:54 <aristid> :t (Control.Arrow.|||)
15:27:55 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
15:28:14 <aristid> @instances ArrowChoice
15:28:15 <lambdabot> (->), Kleisli m
15:28:42 <hpc> @src (->) loop
15:28:43 <lambdabot> Source not found. You type like i drive.
15:28:47 <hpc> :(
15:30:28 <aristid> thanks, SirFrancisDrake and hpc. exactly what i was looking for.
15:30:40 <SirFrancisDrake> aristid: np
15:40:44 * hackagebot comonad-transformers 1.0.1 - Haskell 98 comonad transformers  http://hackage.haskell.org/package/comonad-transformers-1.0.1 (EdwardKmett)
15:43:14 <SirFrancisDrake> is there a reserve copy of Peyton Jones' article on STG or any other article on graph reduction in haskell? @stg that bot refers to isn't there.
15:45:43 <dafis> @where stg
15:45:44 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
15:48:13 <SirFrancisDrake> ...so?
15:48:53 <ddarius> @google site:citeseerx.ist.psu.edu peyton jones stg
15:48:54 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
15:49:23 <SirFrancisDrake> cool. Thanks, ddarius
15:56:32 <Cin> @hoogle Maybe a -> (a -> m ()) -> m ()
15:56:33 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
15:56:33 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
15:56:33 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
16:00:45 <dafis> Cin: flip maybe ?
16:00:51 <dafis> :t flip maybe
16:00:52 <lambdabot> forall b a. (a -> b) -> b -> Maybe a -> b
16:01:05 <Cin> I don't want to have to write (return ())
16:02:19 <dafis> Cin: once, in the function definition?
16:03:24 <dafis> onJust mb f = maybe (return ()) f mb
16:03:25 <Cin> dafis: If I wanted to define my own function I wouldn't be searching hoogle. I'd write it in one line.
16:03:49 <dafis> Cin: would be faster ;)
16:09:42 <kamaji> Hi haskell, how can I map read to a list of strings?
16:10:11 <monochrom> > map read ["123", "3", "2e4"] :: [Double]
16:10:13 <lambdabot>   [123.0,3.0,20000.0]
16:10:18 <kamaji> oh balls, [] around the type
16:10:24 <kamaji> haha, thanks monochrom 
16:19:38 <gwern> odd. has teh haskell wiki lost checkuser capability?
16:21:25 <gwern> oh well. if they come back, I can just delete and block the new account as well
16:25:07 <gwern> @dice 1d3
16:25:07 <lambdabot> 1d3 => 2
16:25:27 <dankna> :t lift
16:25:27 <lambdabot>     Ambiguous occurrence `lift'
16:25:27 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
16:25:28 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
16:25:35 <dankna> :t Control.Monad.Logic.lift
16:25:36 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Control.Monad.Logic.MonadTrans t, Monad m) => m a -> t m a
16:25:46 <benmachine> :t Language.Haskell.TH.lift
16:25:47 <lambdabot> Not in scope: `Language.Haskell.TH.lift'
16:25:50 <benmachine> oh
16:29:52 <kamaji> How could I square all the numbers in a list?
16:30:05 <kamaji> map (*) [1,2,3] doesn't work
16:30:12 <kamaji> do I have to use a lambda?
16:30:55 <SirFrancisDrake> :t square
16:30:56 <lambdabot> Not in scope: `square'
16:31:03 <SirFrancisDrake> kamaji: yes
16:31:25 <kamaji> thanks~
16:31:50 <Cale> kamaji: (\x -> x*x) would work as the parameter to map, or if you want to be sneaky, you can import Control.Monad and use  map (join (*))
16:32:18 <dafis> or simply map (^2)
16:32:24 <Cale> Oh, indeed, yes :)
16:32:42 <kevinburke> hey, is there a way to pattern match using regexes? like
16:32:49 <dafis> :t join (zipWith (*))
16:32:51 <lambdabot> forall a. (Num a) => [a] -> [a]
16:32:59 <kevinburke> parseS "[A-Za-z]" tokens
16:32:59 <dafis> or that ;)
16:33:22 <SirFrancisDrake> > zipWith (*) [1, 2, 3]
16:33:23 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
16:33:23 <lambdabot>    arising from a use ...
16:33:28 <benmachine> kevinburke: there are several regex libraries for haskell
16:33:32 <benmachine> I can't remember which ones are good
16:33:37 <dafis> > join (zipWith (*)) [1,2,3]
16:33:38 <lambdabot>   [1,4,9]
16:33:45 <SirFrancisDrake> right
16:33:52 <benmachine> (if any; I tend to prefer parser combinators instead)
16:34:41 <benmachine> kevinburke: http://hackage.haskell.org/package/ on this page you will find a variety of unhelpfully described libraries with 'regex' in the name
16:35:45 <Rotaerk> hmm wonder how easy it is to replicate F#'s MailboxProcessor in haskell
16:35:59 <kamaji> Cale, dafis: cheers. I didn't realise ^ wasn't XOR :D
16:36:06 <kevinburke> ok, i'm looking at text.regex - if you stuck the regex in the function argument, it wouldn't pass through type checking would it?
16:36:12 <gwern> XOR is /=
16:36:26 <benmachine> kevinburke: er, which function
16:36:36 <dafis> or Data.Bits.xor
16:36:55 <kevinburke> if I had parseS "if" tokens = some parsing
16:37:01 <kevinburke> and then parseS regex tokens
16:37:06 <kevinburke> the regex isn't a String
16:37:19 <dafis> kevinburke: no, you can't do that
16:37:45 <dafis> write a parser, that's easier and more flexible
16:37:50 <benmachine> kevinburke: you can turn strings into regexes though
16:38:26 <dafis> benmachine: I think he wants to pattern match on regexen
16:38:58 <kevinburke> maybe i should just be clear - i'm trying to pattern match for "if", "do", etc
16:39:22 <kevinburke> but there could be a variable name, and it wolud be good to have the variable name in a separate pattern match than the fall through case
16:39:29 <dafis> case input of { [a-z]+ -> option1; [1-9][A-Z] -> option2 }
16:39:42 <dafis> not possible
16:40:25 <kevinburke> Ok i'll refactor it. Thanks for the help
16:40:26 <dafis> kevinburke: case input of { "if" -> one; "do" -> two; _ -> three } ?
16:41:07 <kevinburke> right now i have parseS "if" tokens, parseS "do" tokens, parseS "{" tokens, parseS _ = error
16:41:14 <benmachine> kevinburke: you can use guards
16:41:43 <kevinburke> ill so parseS _ = if _ == '[a-zA-Z]*' then (parse variable name) else error
16:41:46 <benmachine> parseS name tokens | all isAlpha name = dostuff
16:43:57 <Rotaerk> I'm curious how this could be done in haskell using the same conceptual model, or if the architecture would have to change dramatically...
16:44:24 <Rotaerk> the way this game is currently structured in F#, there's this workflow that transforms a battle from state to state, indirectly based on the commands given to the combatants by some "command posts".  this workflow communicates with the command posts via asyncronous MailboxProcessors, to which it posts "incident report" messages, indicating when an event occurs to transform the state of the battle.  it also posts "command requests",
16:44:24 <Rotaerk>  which the commandpost replies to eventually.
16:44:50 <Rotaerk> the command posts can handle these messages by, say, rendering to a screen and requesting input from the user, based on which it sends the reply to the command request
16:45:10 <Rotaerk> or if it's an AI driven command post, then it just determines the next commands programmatically
16:45:24 <Rotaerk> or it could send out these incident reports and command requests over the network, where a client handles them
16:45:27 <gwern> sounds like that game monad thing
16:45:42 <Rotaerk> so these different command posts are asyncronous to the battle-progression workflow
16:46:18 <Rotaerk> hmm
16:49:02 <Rotaerk> I guess this just reduces to whether erlang-style message passing is viable in haskell
16:49:04 <gwern> let you plug in an AI, terminal commands, GUI commands, etc
16:49:26 <Rotaerk> which is what MailboxProcessor does
16:51:02 <Rotaerk> gwern, sounds a bit more specific than what I'm looking for, but it's worth looking into for ideas
16:52:37 <Locke1689> Does anyone know how to turn the semantics of readHex ( (Integal a) => ReadS a) into a read function ( (Read a) => String -> a)? I know I could "copy" the read code from Prelude, but I figure there must be some combinator I'm missing
16:54:44 <BMeph> Locke1689: Step 1: Learn what 'ReadS a' translates into.
16:55:17 <Locke1689> BMeph: That I do know
16:55:26 <Locke1689> and I know I could do something like
16:55:35 <Locke1689> fst . head . readHex
16:55:50 <Locke1689> But read incorporates some nice error checking etc
16:56:42 <kfr> It's baffling that there is no readMaybe
16:56:46 <kfr> Just read and reads
16:57:16 <Locke1689> I would prefer to substitute the readHex function instead of reads in read, if that makes sense?
16:57:47 <Locke1689> This all sounds like an awful tongue twister
16:58:01 <dpratt71> is there some clever and concise way of doing something like this: [(+1),(*2),(+2)] ?? 2 (yielding [3,4,4])?
16:58:26 <dafis> dpratt71: map ($ 2)
16:58:58 <dpratt71> dafis: cool; I'll give that a go, thanks
16:59:20 <monochrom> ReadS is a type synonym. that means it can be expanded."ReadS a" expands to String -> [(a, String)]
16:59:53 <monochrom> you can use readHex instead of reads. similar types.
17:00:01 <Locke1689> monochrom: Sure, but
17:00:08 <Locke1689> hold on ill hpaste the prelude code
17:00:22 <kfr> https://github.com/epicvrvs/Knyaz/blob/master/Source/Knyaz/String.hs <- that's one of the first things I wrote when I started with Haskell
17:00:32 <gwern> there's always Network.CGI.Protocol maybeRead Read a => String -> Maybe a
17:00:49 <monochrom> > case reads "123" of [(n, "")] -> n+0; _ -> 555
17:00:50 <lambdabot>   123
17:00:58 <monochrom> > case readHex "123" of [(n, "")] -> n+0; _ -> 555
17:00:59 <lambdabot>   291
17:01:36 <dafis> case readHex "123 " of [(n,"")] -> n+0; _ -> 555
17:01:42 <Locke1689> ok so
17:01:44 <Locke1689> http://hpaste.org/43455/prelude_read
17:01:49 <dafis> > case readHex "123 " of [(n,"")] -> n+0; _ -> 555
17:01:50 <lambdabot>   555
17:01:56 <Locke1689> notice how it uses reads s?
17:02:12 <monochrom> yes
17:02:35 <Locke1689> What I'd like is to be able to pass any (String -> ReadS a)
17:02:41 <Locke1689> hmm
17:02:44 <Locke1689> i guess i can't can i
17:02:58 <Locke1689> or rather
17:03:00 <monochrom> just steal that code and modify
17:03:08 <Locke1689> ok
17:03:17 <Locke1689> Cool
17:03:35 <Locke1689> that's exactly what I was going to do, just wanted to make sure there wasn't a more idiomatic way of doing it
17:11:59 <conal> New blog post: http://conal.net/blog/posts/doing-more-with-length-typed-vectors/
17:18:38 <roconnor> conal: what is the magic pragma line needed to compile this?
17:19:10 <conal> roconnor: none, afaik
17:19:16 <conal> roconnor: are you getting an error?
17:19:21 <roconnor> I haven't tried
17:19:27 <roconnor> I assume I need some sort of GADT flag
17:20:43 <conal> roconnor: yeah. i added a code repository to make it easy. https://github.com/conal/numbers-vectors-trees/
17:22:06 * hackagebot pandoc 1.8 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.8 (JohnMacFarlane)
17:24:23 <jmcarthur> conal: nice
17:24:50 <conal> :)
17:27:55 <elliott> Is there a simple recursive way to phrase "\xs ys -> concat (sequence [xs,ys])"?
17:28:04 <dankna> so I'm trying to define something along these lines
17:28:06 <elliott> > concat (sequence [[1,2,3], [4,5,6]])
17:28:06 <lambdabot>   [1,4,1,5,1,6,2,4,2,5,2,6,3,4,3,5,3,6]
17:28:09 <dankna> data Image color alpha = Image { redChannel :: UArray Word8, greenChannel :: UArray Word8, blueChannel :: UArray Word8, alphaChannel :: UArray alpha }
17:28:09 <roconnor> @hoogle Foldable
17:28:10 <lambdabot> module Data.Foldable
17:28:10 <lambdabot> Data.Foldable class Foldable t
17:28:24 <dankna> except I want color to have arbitrarily many components of arbitrary precision
17:28:29 <dankna> rather than exactly three components of size Word8
17:28:44 <dankna> am I on a fool's quest for unnecessary generality, or is there a way to express this?
17:29:08 <conal> elliott: there's a lovely way to write functions of the form \ a b c ... -> [a,b,...] . that'd get you started.
17:29:10 <Saizan> you're not using color anywhere..
17:29:22 <dankna> Saizan: I know, because I'm not sure how to go about breaking it up, heh
17:29:26 <conal> elliott: oh. not what you're asking.
17:29:31 <dankna> color would be something like (Word8, Word8, Word8)
17:29:36 <elliott> conal: :)
17:29:41 <dankna> or (Word16, Word16, Word16, Word16) - note the different number of items
17:30:04 <sshc> Hi, I'm trying to set a Haskell action (which is not top-level) to be called when a ForeignPtr is finalized, but it expects a FunPtr.  How can I expose / convert this IO () action to a FunPtr :: Ptr a -> IO () (which ignores the pointer and performs the action)?
17:30:18 <dankna> basically I want the image to be agnostic to both what colorspace it's working in (rgb, cmyk, others) and to what numeric type it's storing components in
17:30:18 <Saizan> and you'd use that info to replace the red/green/blueChannel fields?
17:30:22 <dankna> yes
17:30:49 <dankna> this is mostly a learning exercise for me, if that changes the answer
17:31:35 <dankna> I need some sort of type-level function that goes from an n-tuple of component types to an n-tuple of UArrays of component types.
17:32:05 <dankna> and then I need the corresponding plain functions to actually access the channels
17:32:09 <Saizan> you could have a gadt like data Channels color where Nil :: Channels (); Cons :: Uarray c -> Channels cs -> Channels (c,cs)
17:32:21 <jmcarthur> conal: "A fun & strange thing about Nat n is that it can have at most one inhabitant for any type n."  <-- this is called a singleton type in the literature around Tim Sheard's Omega language, btw
17:32:22 <dankna> hmmm right
17:32:47 <conal> jmcarthur: thx.
17:33:05 <Saizan> then color would be (Word8,(Word8,(Word8,())))
17:33:11 <joe6> reify :: Name -> Q Info; i need Info, and the function I need this info has a type signature of VarStrictType -> Exp
17:33:12 <dankna> which is fine, if a little ugly
17:33:15 <jmcarthur> conal: which, btw, you may find interesting. one somewhat relevant paper to read might be "GADTs + Extensible Kinds = Dependent Programming"
17:33:16 <joe6> Any suggestions, please?
17:33:26 <dankna> I can always predefine synonyms for all the common cases
17:33:41 <conal> jmcarthur: cool. it's been a long time since i looked at Omega, and never deeply.
17:33:48 <Saizan> dankna: using an infix type constructor (e.g. :::) instead of (,) helps for ugly :)
17:34:02 <joe6> i need something that can convert Q Info -> Info, outside the bind operator
17:34:06 <jmcarthur> conal: i like the idea of omega, although i haven't actually tried programming with it
17:34:17 <joe6> or, something like Q a -> a
17:34:17 <jmcarthur> i like that you can have the power of dependent types while preserving phase distinction
17:34:24 <Saizan> joe6: there's none
17:34:36 <dankna> Saizan: indeed it would!  uhhh ... so I can just use any string of punctuation as a type constructor and it'll be infix?  I had no idea you could do that!
17:34:52 <Saizan> dankna: it has to start with :
17:34:55 <joe6> Saizan: ok, thanks.
17:34:56 <dankna> ah okay
17:36:16 <conal> i'm having fun with pandoc+gitit and plugins, plus a bit of emacs support. helps a lot with these blog posts.
17:37:13 <dropdrive> Hi, are the project euler problems a recommended start for beginners?  Or is there a better set of stepping stones?
17:37:14 <jmcarthur> conal: another interesting way to reify the length of a Vec at the value level might be to use implicit parameters to pass a Nat n to where it is needed. i don't think that approach would work with these type class instances you're defining though
17:37:25 <joe6> is there something like concatMapM?
17:37:37 <kfr> dropdrive: I wouldn't waste any time on those at all
17:37:50 <jmcarthur> and it would also have pretty similar type signatures to what you're using already
17:37:59 <conal> jmcarthur: maybe tricky/ugly when the length changes (polymorphic recursion)
17:38:04 <Saizan> joe6: \f -> liftM concat . mapM f
17:38:11 <elliott> reify a length?
17:38:19 <conal> speaking of which: hurray for polymorphic recursion!
17:38:24 <elliott> conal: when I did this, I added a toNat to the IsNat typeclass. perhaps you could use that
17:38:32 <elliott> well, possibly.
17:38:51 <joe6> Saizan: ok, thanks.
17:39:10 <kfr> dropdrive just code what you actually want to code and ask people in here if you don't know how to go about it
17:39:10 <dropdrive> kfr: Do you have a recommended set of exercises?
17:39:15 <elliott> conal: vecLen :: Vector n a -> Integer; vecLen _ = toNat (undefined :: n)
17:39:21 <elliott> conal: i think you need like one extension to be able to write that.
17:39:28 <dropdrive> kfr: Okay...I don't really have a target in mind though!
17:39:29 <elliott> scoped type parameters or something
17:39:38 <conal> elliott: have you seen http://conal.net/blog/posts/doing-more-with-length-typed-vectors/ ? sounds like we're on the same wavelength.
17:39:50 <elliott> conal: i said that while reading you post after tabbing back to this conversation
17:39:51 <elliott> haha
17:39:52 <kfr> dropdrive why do you want to learn a programming language if you have nothing you actually want to code? :o
17:39:58 <conal> :)
17:40:03 <jetkoten> hi #haskell
17:40:03 <elliott> kfr: programming is fun. well, sometimes.
17:40:23 <jmcarthur> i enjoy programming for its own sake, much of the time
17:40:28 <jetkoten> can anyone help me with what is likely the easiest question you've ever heard, but i'm really stuck on? :)
17:40:38 <conal> elliott: i see your suggestion is a little different. the same pieces are there in a different arrangement.
17:40:40 <elliott> conal: btw I would rename BNat to Fin.
17:40:42 <Saizan> conal: "To get this second instance to type-check, we'll have to add the constraint IsNat n to the (:<) constructor in Vec. Then define pure = pureN for Vec." <- 1) you have an IsNat n context in your definition of (:<), 2) it doesn't seem relevant here, i think pureN would just typecheck as written
17:40:48 <elliott> at least that's what I usually see it called in the Agda/Coq world.
17:41:11 * hackagebot ghc-mod 0.5.3 - Happy Haskell programming on Emacs  http://hackage.haskell.org/package/ghc-mod-0.5.3 (KazuYamamoto)
17:41:14 <elliott> because (Fin n) encompasses every finite type
17:41:16 <conal> elliott: oh, thanks. will check out Fin
17:41:38 <augustss> conal, elliott: have you created a second account here to have someone to talk to :)
17:41:43 <Saizan> joe6: feel free to ask
17:41:49 <elliott> augustss: DON'T GIVE AWAY THE SECRET!
17:41:52 <conal> augustss: yeah. i get lonely. 
17:42:06 <dropdrive> kfr: For my own edification?
17:42:42 <elliott> conal: your Vec will fall down when you try and make them out of user input, because haskell doesn't have dependent types :)
17:42:59 <elliott> conal: since you can't write "[a] -> Maybe (Vec n a)" afaik
17:43:01 <jetkoten> anyone know why this won't compile?
17:43:03 <jetkoten> module Main where
17:43:03 <jetkoten>  
17:43:03 <jetkoten> main =
17:43:06 <jetkoten>      do (sum [3,6..1000]) + (sum [5,10..1000])
17:43:15 <elliott> conal: well actually you can. but you have to specify what length you want at compile time.
17:43:16 <conal> elliott: there's toBNat.
17:43:18 <elliott> which obviously doesn't work out
17:43:26 <conal> elliott: ah, right.
17:43:32 <dafis> jetkoten: main needs to have type IO something
17:43:33 <jetkoten> ghci asks me to add an instance declaration for (Enum (IO t)), but i don't know what it means
17:43:41 <augustss> elliott: are you sure you can't write that function?
17:43:45 <elliott> jetkoten: you need a "print" in there
17:43:50 <elliott> you're trying to use a number as an IO action
17:43:58 <elliott> augustss: I backtracked!
17:44:01 <elliott> you just can't use it in a useful way
17:44:03 <jetkoten> dafis: thanks
17:44:07 <elliott> because you have to decide its type and thus its length at type-time
17:44:08 <conal> dafis: which is a bummer, since it means that one cannot write purely functional/denotative haskell programs.
17:44:16 <dafis> jetkoten: main = print (sum [3, 6 .. 1000]) + (sum [5, 10 .. 1000])
17:44:17 <augustss> elliott: no, I mean, even with a dynamically given number.
17:44:26 <elliott> what really, conal doesn't like the iO monad? I never guessed ;)
17:44:30 <elliott> augustss: really?
17:44:37 <jetkoten> elliott: can you elaborate... sorry, i'm totally new to Haskell
17:44:45 <jetkoten> elliott: ahhh dafis showed me
17:44:48 <jetkoten> dafis: thanks
17:44:53 <dafis> conal: wouldn't you want some form of output from your programme?
17:44:53 <elliott> jetkoten: try replacing the "do" there with "print". a "main" program consists of a list of IO actions.
17:45:00 <elliott> you just have a number there, which isn't an action.
17:45:01 <augustss> elliott: I've not done it, but it might work with some existentials
17:45:09 <elliott> but you can do "print ((sum [3,6..1000]) + (sum [5,10..1000]))".
17:45:10 <jetkoten> the odd thing is, when i change the function name to anything that isn't "main" it works... how come?
17:45:11 <elliott> and that's an action
17:45:14 <conal> dafis: indeed. but doesn't have to be explicit. see ghci.
17:45:24 <elliott> jetkoten: "main" has to have a specific type -- an IO action
17:45:31 <elliott> jetkoten: other functions you define can have any valid type
17:45:38 <conal> dafis: also http://conal.net/blog/posts/tangible-functional-programming-a-modern-marriage-of-usability-and-composability/
17:45:47 <elliott> augustss: well I have to try it now.
17:45:55 <elliott> augustss: if I end up adding IncoherentTypes I blame you.
17:45:58 <elliott> *Instances
17:45:59 <Saizan> of course it works with existentials, it's just a weird version of take then
17:46:16 <augustss> elliott: if you end up using that, I don't think it's a solution. :)
17:46:22 <jetkoten> elliott: thanks, and for a type? what kind of type would i need here... that's where i do main :: something, yes?
17:46:34 <elliott> augustss: don't be silly, every sufficiently advanced haskell program includes at least three ridiculous language extensions
17:46:42 <elliott> jetkoten: GHC can figure out the type for you itself in this case :)
17:46:50 <elliott> jetkoten: main's type should almost always be "main :: IO ()"
17:46:55 <elliott> technically it can be IO a for any a but IGNORE THIS LINE
17:46:59 <augustss> elliott: ridiculous, yes.  crazy, no.
17:47:08 <conal> dafis: the trick of TFP is not to let the display/output aspect interfere with semantic simplicity and composability.
17:47:14 <elliott> augustss: I'm still waiting for -XDependentTypes.
17:47:18 <jetkoten> elliott: so if i had to not rely on GHC it'd be IO() here too? ok
17:47:31 <augustss> elliott: they are getting closer every day
17:47:38 <elliott> augustss: NOT CLOSE ENOUGH!
17:47:40 <elliott> jetkoten: yeah :)
17:47:45 <elliott> jetkoten: "IO ()", try and keep the space
17:48:09 <elliott> augustss: while we're at it, I wish for a nicer numeric typeclass hierarchy
17:48:11 <elliott> and a pony
17:48:20 <dafis> conal: Yes, nevertheless, ultimately you need some I/O, so what's wrong with making it explicit in main's type?
17:48:38 <augustss> elliott: agreed.  so make one and convince everyone to switch
17:48:39 <jetkoten> elliott: great, thanks a lot for your help in working this out
17:48:41 <roconnor> does SHE have dependent types?
17:48:48 <elliott> jetkoten: no problem :)
17:49:00 <elliott> roconnor: no, but she does a good job of faking it.
17:49:07 <elliott> until it all blows up.
17:49:08 <jetkoten> dafis: thanks again too
17:49:12 * hackagebot hothasktags 0.2.0 - Generates ctags for Haskell, incorporating import lists and qualified imports  http://hackage.haskell.org/package/hothasktags-0.2.0 (LukePalmer)
17:49:19 <dafis> not for that, jetkoten
17:49:26 <augustss> roconnor: SHE is as close as you can get without having real dependent types, I'd say.
17:49:41 <conal> dafis: i meant my remark literally. wasn't saying there was something wrong. just that the restriction main's type and the requirement that every "program" have a main prevents one from writing purely functional/denotational programs in haskell.
17:50:18 <kevinburke> hey, i just tried running "sudo cabal install regex-pcre" on mac and got a bunch of errors
17:50:24 <conal> dafis: so that haskell *programs* compose in the same way that Unix programs do: imperatively.
17:50:32 <kevinburke> Wrap.hsc:143:18: error: pcre.h: No such file or directory
17:51:03 <dafis> kevinburke: looks like you need the pcre library (C or whatever it's written in)
17:51:33 <elliott> <augustss> roconnor: SHE is as close as you can get without having real dependent types, I'd say.
17:51:39 <elliott> augustss: not true, we could have proper kinds
17:51:41 <elliott> datakinds that is
17:51:43 <dafis> kevinburke: $ locate libpcre
17:51:52 <elliott> she's type-language is essentially typeless, which it does not have to be
17:52:11 <augustss> elliott: no, it's not.
17:52:18 <elliott> augustss: sure it is. {Foo} turns into *
17:52:51 <Saizan> it uses classes for "kind-checking" iirc
17:53:00 <augustss> Yes, turns into.  But then you could say that Haskell is untyped because it turns into untyped machine code.
17:53:26 <Saizan> kevinburke: btw, do not use sudo
17:53:36 <kevinburke> Saizan: why not?
17:53:53 <Saizan> there's no need to, you can run it as a normal user
17:54:09 <elliott> augustss: we've got to FlexibleContexts!
17:54:31 <Saizan> if you want to install globally you've to use --global --root-cmd=sudo
17:56:40 <elliott> *Main> listVec [1,2,3] :: Maybe (Vec (S (S (S Z))) Integer)
17:56:41 <elliott> Just 1 :< 2 :< 3 :< Nil
17:56:46 <elliott> augustss: it works if i specify the type signature but otherwise no.
17:57:00 <elliott> *Main> listVec [(),(),()]
17:57:00 <elliott> <interactive>:1:0:
17:57:00 <elliott>     Ambiguous type variable `n' in the constraint:
17:57:00 <elliott>       `IsNat n' arising from a use of `listVec' at <interactive>:1:0-17
17:57:00 <elliott>     Probable fix: add a type signature that fixes these type variable(s)
17:57:02 <augustss> elliott: that's typical
17:57:08 <elliott> augustss: but that's exactly what I said would happen!
17:57:12 <elliott> you have to fix the length at compile time
17:57:32 <elliott> :t interlevave
17:57:33 <lambdabot> Not in scope: `interlevave'
17:57:34 <elliott> :t interleave
17:57:35 <lambdabot> forall (m :: * -> *) a. (MonadLogic m) => m a -> m a -> m a
17:57:36 <elliott> caleskell!
17:57:51 <jetkoten> it still doesn't work actually... hmmm.
17:58:00 <jetkoten> error is:
17:58:01 <jetkoten> euler1.hs, interpreted )
17:58:01 <jetkoten>  
17:58:01 <jetkoten> /Users/laptop/h/euler1.hs:4:39:
17:58:05 <jetkoten>     No instance for (Enum (IO ()))
17:58:08 <jetkoten>       arising from the arithmetic sequence `5, 10 .. 1000'
17:58:11 <jetkoten>                    at /Users/laptop/h/euler1.hs:4:39-53
17:58:14 <jetkoten>     Possible fix: add an instance declaration for (Enum (IO ()))
17:58:15 <jetkoten>     In the first argument of `sum', namely `[5, 10 .. 1000]'
17:58:18 <jetkoten>     In the second argument of `(+)', namely `(sum [5, 10 .. 1000])'
17:58:21 <jetkoten>     In the expression:
17:58:24 <jetkoten>           print (sum [3, 6 .. 1000]) + (sum [5, 10 .. 1000])
17:58:28 <elliott> don't paste the whole thing
17:58:28 <jetkoten>  
17:58:31 <jetkoten> /Users/laptop/h/euler1.hs:4:40:
17:58:32 <augustss> elliott: you can't have exactly the type you first mentioned, the n has to be existentially quantified
17:58:33 <Axman6> please don't paste to the channel!
17:58:34 <elliott> jetkoten: you need an extra pair of parentheses
17:58:34 <jetkoten>     No instance for (Num (IO ()))
17:58:37 <jetkoten>       arising from the literal `5' at /Users/laptop/h/euler1.hs:4:40
17:58:39 <elliott> oh dear god.
17:58:40 <jetkoten>     Possible fix: add an instance declaration for (Num (IO ()))
17:58:44 <jetkoten>     In the expression: 5
17:58:44 <elliott> augustss: well, right
17:58:45 <jetkoten>     In the first argument of `sum', namely `[5, 10 .. 1000]'
17:58:48 <jetkoten>     In the second argument of `(+)', namely `(sum [5, 10 .. 1000])'
17:58:48 <dafis> jetkoten: forgot parentheses or ($), print $ (sum ...)
17:58:51 <jetkoten> Failed, modules loaded: none.
17:58:53 <Axman6> augustss!
17:58:54 <jetkoten> same as before
17:59:01 <jetkoten> sorry
17:59:05 <jetkoten> which parts are relevant?
17:59:08 <jetkoten> very sorry all
17:59:18 <dafis> jetkoten: forgot parentheses or ($), print $ (sum ...)
17:59:19 <Axman6> jetkoten: please use a pastie website if you need to paste more than three lines
17:59:25 <jmcarthur> elliott: i'm not sure it must be fixed at compile time. it seems that existential quantification could come to our rescue here
17:59:30 <augustss> Axman6?
17:59:36 <jetkoten> Axman6: ahhh, will do next time, sorry
17:59:45 <jetkoten> Axman6: i didn't know not to
17:59:48 <elliott> jmcarthur: yeah i'm trying now
17:59:51 <Axman6> augustss: i was looking for you the other day when i was having problems with the llvm bindings
18:00:07 <jmcarthur> elliott: it would just require using continuations in order to be able to manipulate the result
18:00:17 <dafis> jetkoten: btw, that won't give the correct answer
18:00:21 <elliott> jmcarthur: how _convenient_!
18:00:33 <augustss> Axman6: yeah, they need some work
18:00:42 <jetkoten> dafis: for project euler q1 you mean?
18:00:47 <dafis> yes
18:00:47 <Axman6> but, someone else helped me. it would be be helpful if your llvm posts mentioned the initializeNativeTarget function :)
18:01:04 <Saizan> jmcarthur: or use a wrapper, data List a = forall n. IsNat n => List (Vec n a)
18:01:20 <elliott> Saizan: at this point there's no reason at all to use Vec!
18:01:35 <jetkoten> dafis: back to the drawing board i guess... i got this idea from reading learn you a haskell... when he introduced this list function i thought i might be able to use it for p.e. q1, oh well :)
18:01:36 <elliott> jmcarthur: I'm having trouble implementing listVec with that existential type
18:01:40 <jmcarthur> elliott: not necessarily. it would still constrain the library
18:01:48 <elliott> jmcarthur: or do you mean implement listVec normally, but then use the existential type when calling it?
18:02:19 <jmcarthur> elliott: well actually you could just use higher rank continuations and avoid any sort of existentials
18:02:20 <dafis> jetkoten: you need to read the problem statement again, carefully, you have one oversight, you can do it nicely with list comprehensions
18:02:34 <dafis> jetkoten: but first, fix the compile error
18:02:56 <dafis> print (sum [3, 6 .. 1000] + sum [5, 10 .. 1000])
18:03:08 <Axman6> augustss: i'm looking at using them for a course at university to implement accelerated array computations using it :)
18:03:10 <jmcarthur> elliott: listVec :: [a] -> (forall n. Vec n a -> b) -> b
18:03:22 <augustss> Axman6: cool
18:03:26 <elliott> jmcarthur: well sure. but i'm wondering how you thought the existential should be done
18:03:28 <jetkoten> dafis: will do
18:03:35 <Axman6> i seem to have got the go ahead today, which is awesome :D
18:03:51 <Saizan> elliott: i think the most useful type would be Nat n -> [a] -> Maybe (Vec n a), then you can produce a exists n. Nat n from whatever Int, open it, and know your Vec matches that Nat
18:03:53 <jetkoten> dafis: i had just started look at list comprehensions when i thought to myself, i can do it without them... however, i'll check them out
18:03:57 <jmcarthur> elliott: what Saizan said
18:04:12 <elliott> Saizan: *IsNat n =>?
18:04:29 <elliott> Saizan: or is Nat n the type containing only the natural n?
18:04:37 <dafis> jetkoten: you can also do it nicely with your thing, there's just a bit missing
18:04:46 <Saizan> elliott: the latter, but they are equivalent as arguments anyway
18:05:20 <elliott> this is the point where i'd give up and use agda :P
18:05:36 <jmcarthur> elliott: you'll have the same issues in agda, afaik
18:05:50 <jmcarthur> maybe wearing different clothes
18:05:52 <Saizan> in agda you won't need the convertion
18:05:58 <Saizan> *conversion
18:06:10 <Saizan> and existentials are nicer
18:07:01 <jmcarthur> Saizan: wait, what would you do in agda if you have a list and a function expecting a Vec?
18:07:16 <jmcarthur> surely you would need a conversion, no?
18:07:59 <Saizan> i meant between the various naturals floating around here :)
18:08:04 <jmcarthur> ah
18:08:37 <jetkoten> dafis: i fixed the compile error, i found the oversight, and now i'm going to look at refactoring to list comprehensions.
18:08:55 <elliott> Saizan: listVec :: Nat n -> [a] -> Maybe (Vec n a) is a real pain to implement
18:09:02 <elliott>     Could not deduce (ListVec n)
18:09:02 <elliott>       from the context (S n ~ S n1, IsNat n1)
18:09:02 <elliott>       arising from a use of `listVec'
18:09:07 <elliott> maybe I'll just shove it into IsNat
18:09:11 <dafis> jetkoten: don't, fix the misunderstanding of the problem statement
18:09:24 <Saizan> i think that's just because (:<) has an IsNat constraint
18:09:29 <elliott> Saizan: yeah
18:09:36 <elliott> i'll just add a type class constraint
18:09:53 <Saizan> i don't think that constraint is very useful, btw
18:10:01 <elliott>     Warning: -XImpredicativeTypes is deprecated: impredicative polymorphism will be simplified or removed in GHC 6.14
18:10:03 <joe6> @hoogle (a -> m b) -> [a] -> [m b]
18:10:04 <jmcarthur> the IsNat constraint in Vec shouldn't be necessary if you are planning to consistently use a singleton type with it
18:10:04 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
18:10:04 <lambdabot> Data.List concatMap :: (a -> [b]) -> [a] -> [b]
18:10:04 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
18:10:06 <elliott> LOL
18:10:11 <elliott> i wonder when ghc 6.14 is coming out!
18:10:26 <Axman6> never?
18:10:32 <dafis> elliott: never
18:10:39 <elliott> :D
18:10:40 <jmcarthur> woosh?
18:10:43 <dafis> it's been renamed ghc-7.0
18:10:44 <Saizan> jmcarthur: you can even write length :: Vec n a -> Nat n
18:10:53 <elliott> it's a joke
18:10:56 <jmcarthur> Saizan: yup
18:10:58 <elliott> listVec' :: [a] -> Vec (forall n. n) a
18:11:01 <Axman6> jmcarthur: woosh indeed, missed the context :P
18:11:02 <elliott> hmm, but what do i pass as the Nat n?
18:11:03 <elliott> undefined?
18:11:04 <jetkoten> dafis: y, if you're talking about *less than 1000*? i just found that. i was off by 1000 because i was unintentionally including that with the multiples of 5.
18:11:09 <elliott> oh wait
18:11:14 <jmcarthur> elliott: that's not right ;)
18:11:17 <elliott> toNat (length xs) :)
18:11:19 <dafis> elliott: didn't see the error message you pasted :D
18:11:20 <elliott> jmcarthur: isn't it?
18:11:24 <Saizan> Vec (forall n. n) a makes no sense
18:11:37 <adnap> i've been learning about C lately, and there is quite a contrast between #c and #haskell.
18:11:40 <jmcarthur> elliott: take a list and give a Vec of any length i could possibly want?
18:11:42 <elliott> of course it doesn't, but i've been steadily confusing myself
18:11:48 <elliott> jmcarthur: yes! that's the magic of christmas!
18:11:49 <dafis> jetkoten: unless the problem changed, there's another thing
18:11:54 <elliott> it's -> forall n. Vec n a isn't it
18:11:58 <adnap> i've been insulted at least a few times by asking innocent questions.
18:12:01 <jmcarthur> still not going to work
18:12:27 <jmcarthur> elliott: if you are going for an existential then you will need a wrapper
18:12:27 <dafis> adnap: miss that here?
18:12:32 <adnap> also, people don't seem to care about anwering the question as directly as possible.
18:12:35 <elliott> jmcarthur: hm right.
18:12:38 <jmcarthur> elliott: there's really no use though i think
18:12:41 <adnap> they'd rather jerk me around.
18:12:57 <adnap> yes, i feel so grateful to have #haskell now.
18:13:02 <jetkoten> dafis: probably hasn't changed... so, i'll look at it more closely. when i did the sample question for less than 10 it did work... but i'll gladly check again, i do want to get it right.
18:13:06 <elliott> we're pretty much the best people ever.
18:13:09 <adnap> yes
18:13:10 <jmcarthur> elliott: maybe you want:  listVec :: [a] -> (forall n. Vec n a -> b) -> b
18:13:19 <elliott> now let's get back to work on what we do every day, curing cancer
18:13:23 <jmcarthur> (the continuation pattern i mentioned earlier)
18:13:34 <elliott> jmcarthur: maybe I do! or maybe I'd rather go down this crazy path first before trying the sane thing :)
18:13:35 <dafis> jetkoten: your oversight doesn't manifest for a limit of 10
18:13:40 <adnap> at least people in here know how to be nice and not flip out when someone says something "stupid"
18:14:02 <jmcarthur> adnap: well, there's ignorance and there's stupidity. :)
18:14:38 <elliott>     Inferred type is less polymorphic than expected
18:14:38 <elliott>       Quantified type variable `n' is mentioned in the environment:
18:14:39 <elliott> oh dear god
18:14:42 <jetkoten> dafis: well, thanks for pointing it out. i looked again and the ? hasn't changed since 2001.
18:16:16 <dafis> jetkoten: so, read the problem statement, look what you claculate and find the difference
18:16:34 <dafis> calculate
18:16:39 <elliott> newtype List a = List (forall n. Vec n a)
18:16:44 <elliott> that *is* the right existential wrapper, yes?
18:17:13 <Saizan> no.
18:17:15 <dafis> elliott: I'd rather expect forall n. List (Vec n a)
18:17:20 <elliott> oh yeah.
18:17:28 <elliott> i swear i can do this stuff when i'm not tired.
18:18:07 <glguy> Does the Haskell platform on windows provide cabal-install?
18:18:53 <jetkoten> dafis: i think i might have it now. i'm counting all numbers that are multiples of both 3 and 5 twice, and there aren't any of those until 15, and hence the reason it wouldn't manifest under 10? if it's not that then i'm stumped! :) (and i'm grateful for you not just saying it's ________ because i'm both learning, and having fun figuring this out!)
18:19:05 <dafis> jetkoten: bingo!
18:19:28 <jetkoten> dafis: allright. working on it... :)
18:20:01 <dafis> jetkoten: so, what are the numbers that are multiples of both?
18:20:14 <Saizan> glguy: iirc, yes
18:20:55 <parcs> does anyone have ghc successfully running under wine?
18:21:36 <dafis> parcs: out of curiosity, why would one do that?
18:22:57 <parcs> dafis: to build win32 binaries without leaving one's preferred development environment :)
18:23:25 <dafis> parcs: not an enjoyable reason, but a good one
18:23:54 <parcs> yeah :/
18:24:29 <jetkoten> dafis: still trying to wrap my head around that
18:25:26 <dafis> jetkoten: do you know the fundamental theorem of arithmetics?
18:25:48 <jetkoten> dafis: i likely learned it long ago and forgot. :)
18:26:03 <dafis> jetkoten: unique prime factorisation
18:26:39 <glguy> Where does the haskell platform on windows put "cabal.exe"?
18:27:29 <jetkoten> dafis: well, i have some idea in my head that it would just be themselves and their product, but that seems too simple... because something like 30 would be a multiple of both 3 and 5... so i'm still working on it i think.
18:27:56 <dafis> jetkoten: so, 15, 30, beginning to see a pattern?
18:29:42 <jetkoten> dafis: i might be slow here :) but the gears are turning...
18:31:12 <Veinor> huh, someone wrote a monad burrito analogy that actually makes sense
18:32:14 <dafis> Veinor: how that?
18:32:31 <jetkoten> dafis: well, it's certainly not very elegant, but maybe this:
18:32:32 <jetkoten> print (((sum [3, 6 .. 999]) + (sum [5, 10 .. 999])) - (sum [15, 30 .. 999])
18:32:47 <jetkoten> dafis: plus one more ) on the end :)
18:33:03 <dafis> jetkoten: that's pretty elegant, in fact; and welcome to the http://en.wikipedia.org/wiki/Inclusion_exclusion_principle
18:33:20 <dafis> you'll need that for a few problems
18:34:11 <jetkoten> dafis: ahhh, i did take discrete mathematics way back when too... so this looks somewhat familiar. i guess "use it or lose it" really is true!
18:34:55 <dafis> jetkoten: but if you've known it before, it returns relatively easily
18:34:56 <Veinor> dafis: well, a burrito is like a functor
18:35:10 <dafis> Veinor: Aha
18:35:17 <Veinor> a beef burrito is the burrito type constructor applied to the type beef
18:35:19 <jetkoten> dafis: i am grateful for your help and encouragement along the way too, i thought it would be quite some time until i tackled any of the p.e. questions, but seeing that list function early tonight in LYAH, it just clicked. thanks again.
18:35:24 <Veinor> and fmap is just doing stuff to the burrito filling
18:35:37 <dafis> jetkoten: you're welcome
18:35:44 <Veinor> and join is just taking a double-wrapped burrito and unwrapping the inner one
18:35:58 <Veinor> (then dumping its contents into the outer burrito)
18:36:44 <dafis> Veinor: it would probably help if I actually had ever seen a burrito, I just know they're something to eat
18:37:12 <jetkoten> dafis: y, union and interscetion... the names are coming back to me now... and Venn diagrams... :)
18:37:33 <dafis> jetkoten: great
18:41:20 <jetkoten> dafis: ok, i'm going to sign off. good night.
18:41:28 <dafis> good night too
18:45:18 <shachaf> Veinor: I don't think that's a good analogy.
18:45:44 <shachaf> Veinor: It's the typical "monads as containers". But getChar :: IO Char doesn't "contain" a Char.
18:46:26 <gwern> of course it does. we even have a function to extract the Char from IO Char
18:46:46 <dafis> gwern: does it start with 'u'?
18:47:05 <gwern> dafis: erm... there are ways which *don't* start with u?
18:47:13 <dafis> Fie!
18:47:17 <shachaf> gwern: There's one which starts with '>'.
18:47:47 <shachaf> @let gwern = unsafePerformIO
18:47:49 <lambdabot>  Defined.
18:48:08 <dafis> > gwern (return 5)
18:48:09 <lambdabot>   Not in scope: `gwern'
18:48:28 <Veinor> dafis: a burrito is basically very thin bread surrounding a filling, usually meat with beans, rice, lettuce, tomatoes, salsa, etc.
18:48:34 <shapr> The way I see it, if you figure out three or four of the analogies, you'll start to really understand monads.
18:48:45 <gwern> pfft. as if you could get something to run with unsafePerformIO in mueval
18:48:47 <shachaf> @quote chocolate.robots
18:48:48 <lambdabot> Duqicnk says: a monad is like a train that runs backwards in time, which is made of tiny chocolate robots
18:49:04 <shachaf> @quote what.you.need
18:49:05 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
18:49:07 <shapr> Though the reality is that the definition is sufficient to define monads, it's the conventions for using monads that require analogies.
18:49:07 <dafis> Veinor: sounds as if it might taste good
18:49:14 <Veinor> very.
18:50:09 <gwern> quite a big pandoc release. I hadn't realized we made so many changes
18:50:26 <shachaf> @remember dons Think of a monad as a spacesuit full of nuclear waste in the ocean next to a container of apples. Now, you can't put oranges in the space suite or the nuclear waste falls in the ocean, *but* the apples are carried around anyway, and you just take what you need.
18:50:26 <lambdabot> Good to know.
18:50:52 <shachaf> All those analogies just annoy me.
18:51:42 <gwern> monads are like monad analogies. the author puts in his understanding which is rendered inaccessible to other people who may be purer and virgin haskellers...
18:52:32 <dankna> I liked the one that went "... >>= applies the analogy to an example, and return adds another layer of indirection."
18:52:56 <shapr> dankna: ooh, I like that one!
18:53:01 <dankna> haha, not original to me
18:53:04 <dankna> but yes
18:53:40 <Veinor> dankna: haha
18:54:25 <shapr> hej jjohnsson
18:55:28 <gwern> http://improbable.com/projects/hair/hair-club002.html
18:55:36 <jjohnsson_> hej shapr!
18:55:53 <gwern> “Luxuriant hair is always pleasing, possibly because it shows not only current health but a record of health in the years before." --Steven Pinker
18:56:30 <Axman6> ha
19:06:14 <adnap> argh
19:06:24 <glguy> Is there a quick fix to get stuff using Network.Socket.ByteString.Lazy.sendAll working under Windows?
19:06:34 <dafis> adnap: elaborate?
19:06:51 <adnap> person in #c came back and is insulting me again.  i just ignored him, but it's really hurtful.  i'm a very sensitive person.
19:07:20 * Axman6 gives adnap a hug
19:07:24 <adnap> he said "The trick is to sound like an intelligent person", long after i had a discussion with some other folks in the channel about what subtracting pointers means.
19:07:27 <Veinor> glguy: withSocketsDo doesn't fix it?
19:07:36 <glguy> the function simply doesn't exist on windows :)
19:07:46 <Axman6> heh
19:07:51 <Veinor> ah :D
19:08:15 <dafis> adnap: I know not what to say
19:09:14 <adnap> he said "maybe you should pretend harder."  i said, "i'm not pretending to be anything", and he said "maybe that's the problem". :/
19:10:30 <monochrom> should not argue with him. continue your way, knowing that your way hurts him and that's why he protests. :)
19:11:03 <adnap> thanks
19:12:14 <monochrom> only thing worthwhile to tell him is "I'll continue my way, whatever you think of it. if you don't like it, tough!"
19:12:55 <adnap> i've always had this sort of problem though, ever since i was little.  i ask a lot of questions, and sometimes i'm not satisfied with the answers.  i always clarify why though.  despite this, some people seem to get really made when you don't immediately accept something they tell you.
19:13:03 <adnap> *mad
19:14:37 <elliott> quick! what's a function (f :: [a] -> [a] -> [a]) such that length (f xs ys) == length xs ** length ys? and if you respond "\xs ys -> replicate (length xs ** length ys) (head xs)" i'll kill you :)
19:14:53 * monochrom reads it slowly
19:16:00 <elliott> that's not quick, monochrom!
19:16:40 <adnap> sometimes it's because they give a shallow answer, that doesn't really tell you anything.  if i were to ask, "why do objects fall to the ground when you let go of them in the air?", someone might say, "gravity".  i shouldn't be satisfied if i don't know what gravity is, and they shouldn't get super mad when i ask.
19:16:45 <Cale> elliott: produce the list of all functions from xs to ys and enumerate their codomains in the order of xs?
19:16:53 <Cale> er, ranges rather
19:17:00 <elliott> Cale: er. yikes.
19:17:14 <elliott> Cale: is that even vaguely feasible? :p
19:17:19 <Cale> err, no, that can't be right
19:17:34 <vjp> q
19:17:39 <vjp> quit
19:17:41 <elliott> vjp: try /
19:17:43 <accel> does haskell often any reflection powers? i.e. to be able to tke a variant and get a list of all the types that go in the variant; or to take a record, and get a list of all it's members ?
19:18:03 <Cale> For that length, it would be much more natural to have a function [a] -> [b] -> [a -> b]
19:18:22 <Cale> probably need Eq on a for that really
19:18:32 <elliott> Cale: yeah, but the flat thing is important here
19:18:41 <vjp> thanks elliott, i'm new to this
19:18:51 <elliott> vjp: np :p
19:18:52 <elliott> (/quit)
19:19:04 <elliott> Cale: (mapM . const) does it, but it adds another level of nesting
19:19:07 <Cale> elliott: for each element of xs, iterate over the elements of ys
19:19:26 <Cale> er... hmm
19:19:29 <elliott> Cale: erm isn't that what you'd do for length xs * length ys
19:19:33 <Cale> yes
19:19:33 <elliott> which i already have
19:19:36 <elliott> liftM2 (++)
19:19:41 <monochrom> I am one of those who get mad for askers not accepting my answers. Q: "is it true 2+2=4?" A: "yes" Q:"I'm asking because I'm buying a $2 thing and another $2 thing online and I only want to pay $3"  That gets me mad. Wishful denial of my factual answer.
19:19:49 <elliott> :t liftM2 (++)
19:19:49 <lambdabot> forall a1 (m :: * -> *). (Monoid a1, Monad m) => m a1 -> m a1 -> m a1
19:19:59 <elliott> > liftM2 (++) [[1,2,3],[4,5,6]] [[9,8,7],[6,5,4]]
19:20:00 <lambdabot>   [[1,2,3,9,8,7],[1,2,3,6,5,4],[4,5,6,9,8,7],[4,5,6,6,5,4]]
19:20:07 <elliott> Cale: (accordingly it is OK if it only works on [[a]]s)
19:20:12 <elliott> or even [[[[[[a]]]]]]]]]]]]]]]]s
19:20:18 <elliott> as long as the two inputs and the output have the same type
19:20:26 <adnap> this makes me feel better: http://bytes.com/topic/c/answers/222627-c-irc-channels
19:20:38 <Cale> There are length xs ^ length ys elements in the set of functions from the elements of ys to the elements of xs, so you want some way to identify each of those functions with an element of the type a
19:20:47 <monochrom> However I don't insult, I just chastise. And I don't bother if the exchange occurred long ago.
19:20:48 <elliott> adnap: ##c on freenode is one of the worst channels ever imo :p
19:20:49 <elliott> well on freenode.
19:20:53 <Cale> hmm
19:21:03 <adnap> at least someone else recognizes him as a jerk
19:21:34 <adnap> elliott: i've spent most of my time in #haskell since joining irc.
19:21:36 <kamatsu> adnap: who's a jerk? 
19:21:40 <elliott> adnap: is poppavic still in ##c?
19:21:50 <elliott> he was FUN
19:21:59 <adnap> Zhivago
19:22:03 <kamatsu> fun in a 'dwarf fortress' kind of way, no doubt
19:22:42 <elliott> kamatsu: fun in a http://www.rhisa.com/sites/default/files/poppavic_wisdom.html way
19:23:04 <elliott> more like "fun in a 'Mark V Shaney' kind of way"
19:23:18 <adnap> i guess i just wasn't prepared for #c.  i was #haskell, but about C.
19:23:28 <adnap> *i was expecting
19:24:18 <elliott> you see, in #haskell, we're all too busy bemusedly staring at our type errors to be rude.
19:24:26 <elliott> C users don't have that problem.
19:24:30 <dafis> adnap: don't expect anything like Haskell elsewhere, we're odd
19:24:49 <systemfault> ##C is the asshole of the internet.
19:25:02 <systemfault> Really, it's that bad.
19:25:04 * dafis thought that was goatse
19:25:29 <systemfault> dafis: Probably that if you zoom the on goatse picture, you'll see ##C
19:25:30 <adnap> that's unfortunate
19:25:50 <kfr> I thought it was /b/
19:25:53 <adnap> anyhow, i'm waiting for a copy of "the c programming language", so i should be set once that arrives
19:25:56 <elliott> dafis: that's not true, you just have to find people equally or more odd
19:26:22 <dafis> elliott: but they're rare, so don't expect them
19:26:27 <CrazyMug> Somebody is learning C?
19:26:31 <adnap> yeah, me
19:26:36 <adnap> i'm taking an OS class
19:26:51 <systemfault> Good people on ##C are as rare as women on freenode.
19:26:55 <dafis> CrazyMug: why not, it's a nice language, apart from a couple of atrocities
19:26:59 <kfr> You don't know C and you're already in a Haskell channel? :o
19:27:00 <elliott> dafis: if i mention #esoteric again, in the future people will look back at #haskell logs, and think it was some place of great importance, what with the frequency it turns up in here. so I won't!
19:27:02 <elliott> oops
19:27:02 <CrazyMug> You will likely learn about the basics of a compiler no matter what you write.
19:27:53 <adnap> i've used C++ for a couple of years, so i have something to work with.  however, there is a lot i'm missing i've discovered.
19:28:35 <CrazyMug> This is due to the fact that the sort of bugs to which it leaves you vulnerable will expose you to how the compiler and runtime work, as well as memory management.
19:28:52 <kamatsu> Aside from Haskell C is my other main language
19:29:02 <kamatsu> and Agda for the opposite extreme.
19:29:04 <CrazyMug> I'm not knocking it; it's simple and easy to port to new hardware, and I've even told people that it's OK to go ahead and try to learn it first.
19:29:15 <adnap> for instance, i was unsure how to do a proper subtraction of the addresses of two pointers.
19:29:15 <kamatsu> CrazyMug: my uni teaches it first.
19:29:27 <kamatsu> er, a - b?
19:29:30 <adnap> this is what i was talking about in #c.
19:29:55 <adnap> i wasn't sure what the type of a - b was.
19:30:08 <adnap> people told me ptrdiff_t
19:30:18 <CrazyMug> kamatsu: we would have one semester of Pascal first, which I could not figure out because you would never use it again, and you could probably just learn the very basic things about C (without rolling your own data structures, for instance) and learn the same concepts without "shooting yourself in the foot".
19:30:26 <CrazyMug> But we would have C second, right after that.
19:30:38 <adnap> i asked if this was a typedef, and someone said "no".
19:30:50 <kamatsu> wait, i thought c's (-) :: a -> a -> a
19:30:58 <adnap> i then made an example, and said my compiler didn't know what ptrdiff_t was.
19:31:07 <Axman6> kamatsu: you don't count js as one of your main languages?
19:31:10 <adnap> they said to include stddef.h, and so of course i had more questions.
19:31:20 <kamatsu> Axman6: I know it very well, but "main" refers to things I actually WANT to use
19:31:39 <Axman6> heh, excellent response =)
19:31:46 <kamatsu> I also use Scala if I have to use JVM
19:31:56 <kamatsu> it's kind of nice, but it's also basically Martin Odersky's brain-dump
19:32:16 <adnap> apparently, the type of a - b is implementation-specific, but many people in #c insisted it was of type ptrdiff_t.
19:32:31 <kamatsu> i'd never heard of such a thing
19:32:42 <dafis> adnap: ptrdiff_t is a macro, defined to be whatever type is used on the machine
19:32:54 <kamatsu> anyway, if you need C help you could always ask on #haskell-blah
19:32:59 <kamatsu> i think enough haskellers know C
19:33:02 <adnap> okay
19:33:36 <adnap> dafis: what do you mean by "whatever type"?  what's an example?
19:34:10 <kamatsu> so, different implementations might have different types for a - b
19:34:15 <adnap> yes
19:34:19 <kamatsu> but ptrdiff_t is #define'd to be whatever that type is
19:34:52 <adnap> ah
19:35:12 <adnap> how can i determine that type for myself?
19:35:20 <kamatsu> hm, grep header files
19:35:26 <adnap> for my particular implementation, that is.
19:36:18 <shachaf> adnap: It's in stddef.h, I think.
19:36:22 <adnap> so, stddef is not included with all implementations, right?
19:36:31 <adnap> only ones that comform to the standards
19:36:35 <adnap> *standard
19:36:47 <adnap> whatever standard defines ptrdiff_t
19:36:54 <shachaf> adnap: An implementation that doesn't conform to standards can do whatever it wants.
19:37:11 <adnap> shachaf: right
19:37:34 <adnap> so, does each implementation provide their own stddef?
19:37:44 <adnap> at least those comforming to the standard
19:37:57 <adnap> with the type used for that particular implementation
19:38:09 <kamatsu> on my GCC:
19:38:11 <kamatsu> #define __PTRDIFF_TYPE__ long int
19:38:11 <kamatsu> #endif
19:38:11 <kamatsu> typedef __PTRDIFF_TYPE__ ptrdiff_t;
19:38:28 <adnap> ah
19:38:30 <kamatsu> it's in stddef.h
19:38:47 <adnap> yeah
19:39:03 <adnap> thanks
19:39:05 <shachaf> kamatsu: Although stddef.h is hidden away.
19:39:08 <adnap> i found that out
19:39:31 <kamatsu> shachaf: in gcc distribution? not exactly "Hidden away"
19:39:35 <adnap> the people in #c told me ptrdiff_t was in stddef.h
19:39:50 <shachaf> kamatsu: Mine is in /usr/lib/gcc/x86_64-linux-gnu/4.4/include/
19:39:59 <shachaf> I typically look for .h files in /usr/include/
19:40:11 <adnap> so, could there be different versions of stddef.h depending on the implementation?
19:40:27 <shachaf> adnap: Well, on a 32-bit system it's probably be a 32-bit integer.
19:40:48 <adnap> does comforming to a standard mean providing things like stddef.h, etc?
19:40:55 <adnap> which have the corresponding types
19:40:59 <dafis> adnap: yes, but most agree on using long int, which tends to be the pointer size
19:41:02 <shachaf> adnap: Read the standard. :-)
19:41:09 <adnap> yeah, i need to.
19:41:42 <shachaf> adnap: <http://flash-gordon.me.uk/ansi.c.txt>, section 4.1.5.
19:41:47 <adnap> i need to be clear about what's C and what's the C standard.
19:41:58 <adnap> and where they overlap
19:42:21 <kamatsu> there's a few versions of the C standard
19:42:25 <shachaf> adnap: What do you mean by "C"?
19:42:28 <kamatsu> i love c99 but msvc doesn't support it.
19:43:16 <adnap> shachaf: oh my god
19:43:25 <shachaf> stddef.h is scary.
19:43:38 <dafis> all system headers are
19:43:41 <shachaf> (By the way, #-blah might be better for this.)
19:43:56 <adnap> shachaf: i think i was under a false assumption
19:44:10 <shachaf> dafis: I haven't seen many with 8 #endifs in a row.
19:44:16 <adnap> there is no "core C" or anything, huh?
19:44:26 <dafis> shachaf: true, stddef is special
19:44:32 <kamatsu> there is, defined by the standard
19:44:36 <kamatsu> but it's too minimal to get anything done
19:44:43 <shachaf> adnap: Not any that isn't defined by the standard.
19:45:01 <kamatsu> so you typically need to rely on C + POSIX + whatever else..
19:45:10 <kamatsu> or C + Win32 if you hate your life
19:45:16 <adnap> so, why are certain things the job of headers?  why aren't certain types built in?
19:45:36 <kamatsu> the type system in C is arbitrary and tacked on
19:45:47 <shachaf> adnap: Why would they be? What if you don't want them?
19:45:53 <adnap> like, ptrdiff_t
19:46:02 <kamatsu> why would you make that built in?
19:46:20 <shachaf> adnap: There's the C language, and the C standard library, and they're both defined by ANSI C.
19:46:24 <adnap> well, if operators and pointers are built in...
19:46:38 <adnap> and i can express a - b
19:46:47 <adnap> why shouldn't the type of that be defined without a header?
19:46:59 <kamatsu> C is designed to work on alot of memory models. I think the idea was that it would give compiler writers flexibility to choose how to define it
19:47:20 <adnap> that's so weird
19:47:26 <kamatsu> also if the compiler writers want to make it built in they can
19:47:33 <kamatsu> just make a built in _ptrdiff_t
19:47:36 <adnap> yeah
19:47:39 <shachaf> kamatsu: Not if they want to be standard-compliant.
19:47:41 <kamatsu> and then typedef _ptrdiff_t ptrdiff_t
19:47:49 <shachaf> well, yes.
19:47:53 <kamatsu> shachaf: standard only dictates that it's in stddef.h
19:48:11 <adnap> for some reason, i thought there was a "core C", and then standards came later and tacked on a bunch of stuff
19:48:22 <kamatsu> well,there's K&R C
19:48:27 <kamatsu> if you're referring to that
19:48:33 <shachaf> adnap: Well, "core C" has to be defined somewhere, right? :-)
19:48:53 <kamatsu> K&R C, then C89 then C99
19:48:55 <shachaf> Mmm, K&R C. int main(argc, argv) int argc; char **argv { ... }
19:49:07 <dafis> gah, go away
19:49:12 <adnap> shachaf: yes.  i just assumed that any definition of "core C" wouldn't include headers with types in them!
19:49:13 * shachaf missed a semicolon
19:49:18 <monochrom> haha
19:49:35 <shachaf> adnap: The Haskell report includes both the language and the Prelude (e.g. Maybe).
19:49:43 <adnap> shachaf: that idea is really bizarre to me.
19:49:58 <dafis> adnap: why?
19:50:12 <kamatsu> all language standards do it
19:50:15 <monochrom> standard C also includes lib
19:50:30 <adnap> well, you can express things that aren't defined
19:50:36 <adnap> unless you have the header
19:50:42 <adnap> that's what's weird
19:50:52 <adnap> i feel like it's not self contained
19:50:58 <shachaf> adnap: Headers are part of the language.
19:51:02 <kamatsu> no, what you're expressing is a implementation-specific thing:
19:51:11 <kamatsu> x - y in GCC is long int
19:51:17 <gwern> no standard is self-contained. they don't bother to define English, for example
19:51:22 <kamatsu> the typedef is only if you want to specify that it's a ptrdiff
19:51:30 <sepp2k> Is (+(-48)).fromEnum the golfiest way to write digitToInt or is there something shorter?
19:51:35 <adnap> yeah, it makes more sense if you think of the headers as being a part of the language
19:51:39 <adnap> i didn't initially
19:51:40 <kamatsu> and you want to write cross-platform code that doesn't depend on a - b being long int
19:51:48 <shachaf> sepp2k: There's ord.
19:51:53 <adnap> kamatsu: right
19:52:07 <adnap> there's a certain flexibility you need to have
19:52:40 <monochrom> @type Data.Char.digitToInt
19:52:41 <lambdabot> Char -> Int
19:52:41 <sepp2k> shachaf: Yes, but I'd have to import Data.Char to use it, so it wouldn't be shorter.
19:53:04 <dafis> that also rules out ord
19:53:45 <adnap> is there any notion of haskell without Prelude?
19:53:54 <kamatsu> sure
19:54:03 <shachaf> {-# LANGUAGE NoImplicitPrelude #-}
19:54:09 <dafis> adnap: {-# LANGUAGE NoImplicitPrelude #-}
19:54:11 <adnap> now i'm kind of curious to see what that defines
19:54:19 <kamatsu> it just doesn't have any predefined functions or types
19:54:24 <kamatsu> except primitive types and primops
19:54:43 <adnap> can you express anything that cannot be defined without Prelude?
19:54:44 <shachaf> You wouldn't be able to do any IO. Though I suppose that's true of core C without any libraries too.
19:55:01 <adnap> or without something like Prelude
19:55:08 <kamatsu> shachaf: you still have FFI ;)
19:55:12 <adnap> like our a - b thing
19:55:31 <shachaf> kamatsu: Real Haskell doesn't have FFI.
19:55:38 <kamatsu> yes it does
19:55:38 <adnap> basically, is haskell without Prelude "self-contained"?
19:55:41 <kamatsu> it's in haskell 2010
19:56:14 <kamatsu> well, it's turing complete except it can't talk to the outside world
19:56:21 <adnap> right
19:56:42 <shachaf> kamatsu: Real Haskell is pure.
19:56:48 <kamatsu> yes
19:56:56 <kamatsu> as can, theoretically, the FFI :)
19:56:59 <adnap> but is there anything like subtracting two pointers, where things are undefined before something like Prelude defines them?
19:57:07 <shachaf> kamatsu: Bu then you still can't do IO. :-)
19:57:19 <kamatsu> shachaf: sure you can, if you have purely functional hardware
19:57:44 <shachaf> adnap: C programmers don't worry about the standards that much. :-)
19:57:44 <kamatsu> adnap: do notation?
19:58:07 <adnap> ah, there are no monads
19:58:17 <adnap> so do isn't useful
19:58:19 <kamatsu> do notation depends on a monad class, or at least >>= and return
19:58:22 <adnap> do notation
19:58:31 <kamatsu> it would give you funny errors if they weren't defined
19:58:36 <shachaf> kamatsu: But can't you define your own class called Monad?
19:58:40 <kamatsu> but if you define them yourself (which you can), do notation would work
19:58:59 <adnap> but the class Monad is undefined, right?
19:58:59 <kamatsu> you can, but currently we have a core language feature that depends on something from the prelude
19:59:08 <kamatsu> yeah, but you can define it
19:59:13 <adnap> and do will then work?
19:59:19 <adnap> i should try some of this
19:59:20 <kamatsu> yes
19:59:25 <adnap> interesting
19:59:29 <kamatsu> just as you can typedef long int ptrdiff_t and it will work
20:00:13 <adnap> well
20:00:30 <adnap> the compiler doesn't have to explicitly recognize ptrdiff_t right?
20:00:39 <kamatsu> no
20:01:05 <adnap> but you said do notation will work once you have implemented a type that's a member of some Monad class
20:01:09 <kamatsu> no
20:01:14 <adnap> oh
20:01:16 <kamatsu> do notation will work once you've defined >>= and return
20:01:19 <adnap> oh
20:01:22 <kamatsu> they don't need a monad class
20:01:32 <adnap> okay, i misunderstood
20:01:47 <adnap> that's cool!
20:01:56 <adnap> so i can go make return and >>= do something crazy
20:02:06 <adnap> and in turn, make do notation do something crazy
20:02:20 <shachaf> E.g. work on Sets, I think.
20:02:35 <shachaf> kamatsu: What about Integer literals?
20:02:41 <kamatsu> Integer is built in
20:02:48 <shachaf> But is fromInteger built in?
20:02:56 <kamatsu> i'm not sure where the line is drawn
20:03:17 <kamatsu> but from memory I think GHC defines special primitive versions of integer operations in GHC.Prim..
20:03:26 <kamatsu> they are always there
20:03:34 <kamatsu> and the prelude defines all the Integer and Num class and stuff.
20:04:02 <kamatsu> but if you take out the prelude, you're in implementation-specific territory, firmly.
20:04:20 <kamatsu> removing Haskell Prelude from Haskell means you're not using Standard Haskell anymore.
20:04:37 <Axman6> hmm, anyone know much about having lists where all elements are of a certain class?
20:04:38 <adnap> man, i'm learning!  and at a rate about 1000 times faster than in #c. XD
20:04:53 <Axman6> i'm not sure hwo to define my record element type for it
20:04:53 <kamatsu> Axman6: er, heterogenous elements? 
20:05:09 <Axman6> kamatsu: yeah, but restricted to a class, i've seen it done, just not sure how
20:05:16 <kamatsu> use an existential
20:05:19 <shachaf> Axman6: Existential types?
20:05:20 <Axman6> ie, what the syntax is
20:05:29 <Axman6> sure... but what does it look like?
20:05:34 <kamatsu> data Box = forall a. (Show a) => Box a
20:05:37 <shachaf> data T = forall a. (C a) => T a
20:05:37 <kamatsu> from memory.
20:05:50 <Axman6> ah, i need the existential out the front, that makes selse
20:05:55 <kamatsu> then just run Box on every element before you add it and you get a list of [Box]
20:05:57 <shachaf> Axman6: It does?
20:06:00 <kamatsu> Axman6: actually it's a universal
20:06:00 <accel> does haskell have an 'interpret' mode rather than a compile + run ?
20:06:19 <kamatsu> the existential is nested inside and becomes an existential by way of the constructor.
20:06:19 <shachaf> accel: Depends on what you mean by "interpret".
20:06:23 <dafis>  accel ghci
20:06:27 <shachaf> There's runghc if you just want a program to run a .hs file.
20:06:34 <accel> shachaf: ah; nice; thanks
20:06:36 <shachaf> But it does actually compile and run the file.
20:06:41 <accel> dafis: ghci doesn't interpret the same langauge as ghc compiles does it?
20:06:50 <kamatsu> accel: not quite
20:06:54 <adnap> what features does Haskell 2010 standardize?  i've heard about "type families" and GADT and so on...
20:06:58 <kamatsu> better off with runghc/runhaskell
20:07:00 <shachaf> Axman6: Of course, if the type class that you want is Show, this is completely useless. :-)
20:07:02 <kamatsu> adnap: not part of Haskell 2010
20:07:13 <Axman6> sure, but it's not Show :)
20:07:15 <adnap> kamatsu: yeah, i didn't think so
20:07:17 <kamatsu> adnap: GHC extensions. Haskell 2010 was a conservative upgrade from Haskell 98
20:07:35 <Axman6> what extensions do i need to be able to use this existential qualification?
20:07:38 <kamatsu> it includes FFI, removes n+k patterns, and adds view patterns i think
20:07:54 <adnap> kamatsu: i see.
20:07:57 <dafis> ExistentialQuantification
20:07:59 <kamatsu> Axman6: *quantification, and {-# LANGUAGE ExistentialQuantification #-}
20:08:14 <kamatsu> you can also do it with GADTs
20:08:21 <kamatsu> which is  a more general approach that makes me happier
20:08:24 <adnap> i wonder if there will be a new standard soon that incorporates things like GADT
20:08:26 <shachaf> Why is it called ExistentialQuantification?
20:08:33 <adnap> i don't know much about these extensions though
20:08:36 <kamatsu> shachaf: because that's what it allows
20:08:44 <adnap> maybe they're looking for the cleanest way to do certain things
20:08:49 <kamatsu> how much do you know about first-order logic?
20:08:50 <shachaf> kamatsu: It's universal quantification, though. :-)
20:08:52 <kamatsu> adnap: spot on
20:08:57 <kamatsu> shachaf: actually, it's existential
20:09:04 <kamatsu> i know it's deceptive
20:09:12 <kamatsu> your constructor:
20:09:15 <kamatsu> forall a. Box a
20:09:17 <shachaf> kamatsu: It works out to be.
20:09:21 <kamatsu> is of type:
20:09:22 * shachaf wants an exists keyword, though.
20:09:24 <adnap> kamatsu: do you think it will be another 10 years before we get another standard? XD
20:09:29 <kamatsu> forall a. -> Box a.
20:09:36 <kamatsu> adnap: no, we're doing small incremental upgrades each year now
20:09:42 <adnap> kamatsu: oh!
20:09:44 <kamatsu> *forall a. a -> Box a
20:10:20 <adnap> kamatsu: i want haskell to get even more awesome, but i'm also afraid of it getting bloated.  i hope it stays clean!
20:10:37 <shachaf> adnap: Clean is a different language.
20:10:40 <adnap> lol
20:10:44 * hackagebot comonad-transformers 1.1.0 - Haskell 98 comonad transformers  http://hackage.haskell.org/package/comonad-transformers-1.1.0 (EdwardKmett)
20:11:20 <adnap> what if instead of python, haskell was all the rage, and everybody started asking for different features for "hackability"
20:11:34 <Minty> hi people
20:11:56 <mafs> adnap: they'd write something to bring that 'feature' forth and post it to hackage, I'd hope
20:11:57 <adnap> hello
20:12:19 <kamatsu> adnap: python is all the rage?
20:12:22 <kamatsu> adnap: oh no
20:12:27 <adnap> mafs: yeah, i guess with haskell, a lot of things can be made without changing the standard
20:12:28 <edwardk> adnap: i wouldn't worry too much. haskell's problem is that folks aren't standardizing enough change, not the opposite ;)
20:12:28 <Axman6> do they have minties anywhere other than Australia?
20:12:33 <adnap> kamatsu: lol, i thought so
20:12:45 * hackagebot comonad-transformers 1.2.0 - Haskell 98 comonad transformers  http://hackage.haskell.org/package/comonad-transformers-1.2.0 (EdwardKmett)
20:13:17 <adnap> i haven't learned python, but many people seem to love it.  i don't like that it doesn't have strong typing.
20:13:27 <kamatsu> it's also basically a crappy language
20:13:31 <kamatsu> (sorry to any python fans)
20:13:33 <edwardk> in12 years we've managed to ditch n+k patterns and some really badly thought out restrictions on class instances for data types
20:13:37 <dafis> edwardk: how come you upload two versions of comonad-transformers to hackage in less tim than it takes to compile?
20:13:38 <Rotaerk> adnap, as i understand it, it has strong typing, just not static
20:13:41 <shachaf> Haskell isn't bloated *enough*. They should bring back n+k patterns.
20:13:45 <mafs> kamatsu: that's not fair. each language has its use.
20:13:49 <Rotaerk> (which is also a bad thing)
20:13:52 <adnap> Rotaerk: sorry, that's what i meant.
20:13:54 <mafs> kamatsu: even VB! torture.
20:13:55 <shachaf> Also n*k patterns, including for k=0.
20:14:09 <kamatsu> mafs: clearly you've never used Promela.
20:14:09 <Rotaerk> mafs, and how is that an argument for it not being crappy
20:14:19 <edwardk> shachaf: n+k patterns are busted in the sense that they can't use the syntax in scope and are a horrible special case
20:14:20 <adnap> maybe it was xkcd, talking about how god wrote the universe in python or something
20:14:25 * Axman6 prints a new t-shirt: "I died a little inside when they killed n+k"
20:14:38 <edwardk> you can't even hide them with NoImplicitPrelude
20:14:39 <kamatsu> mafs: Promela's only use is to motivate people to write a language that is the complete opposite of Promela.
20:15:02 <shachaf> edwardk: I was not being *completely* serious.
20:15:27 <edwardk> axman6: sweet. now print the flip side for us star-bellied sneeches that says 'I danced a little jig when they killed n+k"
20:15:29 <mafs> Rotaerk: I was reading crappy to be closely tied to useless, I suppose. I still can't say the crappy claim is fair--it's a fantastic imperative language for a number of uses (but I'll avoid language wars)
20:15:37 <edwardk> axman6: and you can make a fortune ;)
20:15:42 <Axman6> :)
20:15:56 * Axman6 doesn't actually care about n+k patterns
20:16:04 <Axman6> pretty sure i've only used them once
20:16:05 <adnap> is an n+k pattern where you pattern match on the expression n+k?
20:16:11 <Axman6> yes
20:16:11 <adnap> i've never heard of it
20:16:15 <adnap> okay
20:16:20 <kamatsu> mafs: the main thing that gets me about python is: It's has no interesting features. It has crap all concurrency. Crap all support for FP, and a pretentious douchebag for a creator.
20:16:22 <Rotaerk> mafs, to me, imperative, mutability, dynamic typing, automatically imply "crappy"
20:16:35 <shachaf> What about k+k' patterns?
20:16:36 <kamatsu> not to mention Rotaerk's points
20:16:37 <adnap> yeah, it seems like a way to make things way more confusing
20:16:41 <edwardk> adnap: yes, but it also does some magic checking to ensure that you don't match against a negative n.
20:16:49 <Axman6> > let fib 0 = 0; fib 1 = 1; fib (n+2) = fib (n+1) + fib n in fib 10
20:16:50 <lambdabot>   <no location info>: Parse error in pattern
20:16:52 * shachaf wishes you could match on a constant known at compile time.
20:16:54 <Axman6> :(
20:17:04 <adnap> shachaf: lol
20:17:11 <edwardk> shachaf: in scala thats `k` ;)
20:17:13 <dolio> > f (2 + 2) = 0 in f 4
20:17:14 <lambdabot>   <no location info>: parse error on input `='
20:17:22 <dolio> > let f (2 + 2) = 0 in f 4
20:17:23 <lambdabot>   <no location info>: Parse error in pattern
20:17:30 <Axman6> bah! this existential qualifications thing isn;t working :(
20:17:34 <Rotaerk> mafs, so if it makes you feel any better, python isn't alone in its crappiness
20:17:37 <edwardk> \x `x` -> … compares the first argument with the second
20:17:40 <adnap> what is scala like?
20:17:41 <kamatsu> Axman6: pastebin your code, i'll fix it
20:17:46 <edwardk> adnap: ad hoc
20:17:51 <kamatsu> adnap: Martin Odersky is a smart man with many ideas
20:17:52 <shachaf> Axman6: It's quantification.
20:18:00 <kamatsu> all of his ideas, good and bad, end up in Scala.
20:18:03 <Axman6> oh, sorry :)
20:18:08 <gwern> kamatsu: larry wall always struck me as more pretentious
20:18:14 <edwardk> adnap: scala is an interesting mix of, as kamatsu says, good and bad ideas.
20:18:15 <shachaf> I guess you can use view patterns to match on constants, actually.
20:18:18 <kamatsu> gwern: true, both of them made crappy languages
20:18:27 <edwardk> i really like larry =)
20:18:28 * Axman6 wonders how you copy from vim when you've enables the mouse for selection...
20:18:35 <kamatsu> Perl 6 is interesting just because it really takes the "special case" approach to PL design
20:18:35 <shachaf> Axman6: "+y
20:18:44 <adnap> i read about this java programmer who was saying how scala was the next big thing
20:18:47 <mafs> Rotaerk: That helps a little ;) I can see some of your points. I was going to combat them with "It's easy to read" or "a nice starter language," but that's sure to meet criticism
20:18:56 <kamatsu> adnap: it's very convenient language
20:19:05 <kamatsu> adnap: if you find yourself wishing Scala had a feature, it usually does
20:19:06 <gwern> perl 6 is interesting because there may be interesting new ideas in it, but we'll never know
20:19:17 <adnap> i would like to learn perl
20:19:20 <edwardk> adnap: its better than java, but its not as good as it could be. i'll say this out of the ocaml/f#/etc. ml school of languages its by far the best
20:19:29 <Axman6> cheers shachaf :)
20:19:30 <adnap> i have heard that perl is the language that "has everything"
20:19:39 <edwardk> kamatsu: correct handling of higher kinded existentials? =)
20:19:44 <adnap> the "ultimate hacker language"
20:19:53 <edwardk> kamatsu: its in the language spec, but not in the compiler ;)
20:19:55 <Axman6> http://hpaste.org/43456/extistential_quantification
20:20:25 <edwardk> does PGTypeable a b  have a fundep from a -> b?
20:20:33 <kamatsu> Axman6: error message?
20:20:50 <kamatsu> adnap: don't learn it and save yourself braindeath
20:21:16 <kamatsu> adnap: Perl 5 is a horrible mashup of a programming language where every feature interacts subtly with every other feature usually leading to disaster
20:21:23 <Axman6> well it's more about my use of it. when i try to have say a Maybe a and a String (both of which should match that class constraint" it complains about them not being the same typer
20:21:27 <Axman6> -r
20:21:36 <edwardk> i programmed perl for 10 years. i think i came out of it okay. i'm still in recovery though. i occasionally get twitches
20:21:51 <kamatsu> Axman6: how are you trying to put these into a list?
20:22:03 <Axman6> just a static list
20:22:05 <adnap> kamatsu: yeah, i was sort of expecting that though :)
20:22:09 <kamatsu> Axman6: please post code.
20:22:13 <mafs> I feel like I should defend it since I frequent the St. Louis Perl Mongers
20:22:20 <mafs> but I don't actually write any Perl, so I'll hold off
20:22:21 <Rotaerk> let's start a sympathy fund for edwardk 
20:22:30 <kamatsu> i have a terrible perl anecdote
20:22:31 <Axman6> so [("foo",Just a), ("bar","Baz")]
20:22:37 <edwardk> Axman6: you won't be able to do anything with the 'a's that you have other than use methods from PGTypeable and PGType 
20:22:50 <shachaf> Axman6: How do you expect that to work?
20:22:51 <kamatsu> I was writing perl and I was interating through a hash using the "each" function.
20:22:57 <kamatsu> *iterating
20:23:07 <Axman6> edwardk: that's all i'm after
20:23:08 <edwardk> axman: you'd need a wrapper for those lists
20:23:21 <Axman6> yeah?
20:23:26 <kamatsu> the problem was, i would break out of the loop half way
20:23:34 <adnap> is haskell a suitable replacement for perl?  doesn't perl do a lot of convenient "dirty" things?
20:23:44 <kamatsu> and it was in a larger loop which meant each time it reentered the loop for perl, it would continue where it left off
20:23:56 <kamatsu> so i needed to reset the iterator somehow, fair enough
20:24:02 <edwardk> data PGTuple = forall a b. (PGTypeable a b, PGType b) => PGTuple String a
20:24:05 <dolio> Does convenient need to be dirty?
20:24:15 <Axman6> edwardk: perfect, thanks
20:24:16 <edwardk> then you can make insVals :: [PGTuple]
20:24:17 <kamatsu> turns out the way to reset the iterator was calling the values() function which gives you all the values in the hash. It has the side effect of resetting the iterator. WTF?
20:24:18 <Axman6> i'll give that a show
20:24:22 <Axman6> shot even
20:24:31 <adnap> dolio: no, but sometimes it takes time to perfect things that are convenient and not dirty
20:24:35 <mauke> kamatsu: keys() is more common
20:24:46 <edwardk> you can remove the existential on the INSERT as well, then
20:24:57 <kamatsu> mauke: but why does a getter have a side effect like resetting the iterator?
20:25:00 <kamatsu> seems horrid
20:25:12 <mauke> because it iterates over the hash
20:25:36 <adnap> dolio: and i had the impression that perl was happy to have convenient, but dirty things
20:25:45 <edwardk> mostly coz the iterators being tied to the containers works right for 90% of the usage scenarios. perl is full of 90% hacks
20:26:15 <mauke> the real problem is that there is such a thing as "the iterator"
20:27:00 <Axman6> hmm, i wonder if this stuff would be useful to have in Takusen
20:27:07 <shachaf> If you fix all of Perl's "real problems" what you end up with isn't Perl anymore. :-)
20:27:20 <kamatsu> Axman6: learning Haskell's type extensions is really a worthwhile pursuit
20:27:35 <kamatsu> but it's worth learning some type theory first, to get a better grounding
20:27:52 <kamatsu> I found it much easier to grasp that way, anyway
20:27:56 <Axman6> i've used a few, but it's not really my area
20:29:21 <kevinburke> i there a way to search for word boundaries using text.regex.posix?
20:30:24 <dafis> kevinburke: I think I rememeber there were such
20:30:36 <dafis> read the haddocks
20:43:56 * hackagebot comonad-transformers 1.2.1 - Haskell 98 comonad transformers  http://hackage.haskell.org/package/comonad-transformers-1.2.1 (EdwardKmett)
21:02:42 <edwardk> liftCallCV :: (w (w (w a -> a) -> b) -> b) -> EnvT e w (EnvT e w (EnvT e w a -> a) -> b) -> b *head-asplode*
21:07:47 <edwardk> ah, its coz its backwards
21:08:19 <joe6> i am doing map (operation) [a] and I want to change to map (operation) [(a,b)]. I want to make operation work on a tuple. I could use a lambda to break the tuple, work on it and then build it again.
21:08:31 <joe6> just curious, if there was a smarter way of doing this.
21:12:08 <joe6> (><) seems to be a good option. 
21:12:15 <joe6> > (><)
21:12:17 <lambdabot>   Not in scope: `><'
21:13:05 <mauke> > map (first (+ 2)) [(1, 'a'), (2, 'b')]
21:13:07 <lambdabot>   [(3,'a'),(4,'b')]
21:14:23 <djahandarie> >< is used by some other packages
21:14:29 <djahandarie> @hoogle (><)
21:14:29 <lambdabot> Data.Sequence (><) :: Seq a -> Seq a -> Seq a
21:14:30 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
21:20:20 <joe6> mauke: thanks
21:35:08 * hackagebot comonad-transformers 1.3.0 - Haskell 98 comonad transformers  http://hackage.haskell.org/package/comonad-transformers-1.3.0 (EdwardKmett)
21:35:10 * hackagebot comonads-fd 1.3.0 - Comonad transformers using functional dependencies  http://hackage.haskell.org/package/comonads-fd-1.3.0 (EdwardKmett)
21:36:26 <copumpkin> @remember Apocalisp a unit of clarity is a clarinet
21:36:27 <lambdabot> I will remember.
21:36:42 <ddarius> copumpkin: Where'd that come up?
21:36:49 <copumpkin> in #scala
21:36:53 <edwardk> =)
21:37:09 * hackagebot recursion-schemes 0.4.0.1 - Generalized bananas, lenses and barbed wire  http://hackage.haskell.org/package/recursion-schemes-0.4.0.1 (EdwardKmett)
21:37:11 <copumpkin> #scala's the place to be these days!
21:37:45 <Apocalisp> It's where all the cool kids hang out
21:37:46 * ddarius usually avoids the places that are the place to be.
21:38:38 <edwardk> what'll you do when haskell becomes popular? =)
21:38:47 <ddarius> edwardk: I've been wondering about that.
21:38:49 <edwardk> all the cool cats hang out in here
21:38:55 <stepkut> edwardk: #agda of course!
21:39:04 <shachaf> Haskell is already popular.
21:39:04 <stepkut> edwardk: or #epigram maybe
21:39:38 <shachaf> stepkut: Why s/c/k/ in your nick?
21:39:40 <copumpkin> #kata is klearly the kool place to kongregate
21:39:47 <edwardk> ddarius: any obvious semigroupoids i missed i http://hackage.haskell.org/package/semigroupoids-1.0.0 ?
21:41:28 <edwardk> needed them to describe the extend and bind of indexed (co)monads
21:41:43 <Wooga> hello, can i use read "+" to produce a function (+) ?
21:41:56 <shachaf> Wooga: Not unless you implement it.
21:42:03 <Wooga> thanks
21:43:08 <shachaf> Wooga: If you do implement it, though, you don't actually need the read call.
21:43:14 <shachaf> E.g. http://www.samuelhughes.com/isstring/index.html
21:44:53 <taotree> Is there a straightforward way to compose functions at runtime where the function types are known at compile time, but I want to compose them in any way at runtime based on user input (obviously, inputs and output types have to match correctly)?
21:46:04 <copumpkin> can you give a more concrete example?
21:48:11 <stepkut> shachaf: multiple computers -- I could set up an irc proxy, but I haven't
21:49:04 <taotree> f12 :: T1 -> T2; f23 :: T2 -> T3; f24 :: T2 -> T4;   These are compiled. At runtime, the user chooses something corresponding to f12 and f24. I then want to compose f12 . f24 and run some value through it.
21:49:43 <copumpkin> is the set of things to be composed fixed?
21:50:05 <taotree> The set of things to be composed is known at compile time.
21:50:29 <taotree> that can be composed... chosen by user, is known at compile time
21:51:32 <copumpkin> gimme a few
21:52:12 * hackagebot ixdopp 0.1.1 - A preprocessor for expanding "ixdo" notation for indexed monads  http://hackage.haskell.org/package/ixdopp-0.1.1 (JesseTov)
21:55:15 <edwardk> interesting. indexed do preprocessing would be handy
21:56:47 <edwardk> i might actually try using that
21:56:54 <stepkut> yeah
21:57:10 <edwardk> i just started putting together a package of indexed (co)monads
21:57:25 <stepkut> nice
21:57:25 <edwardk> out of the remaining carcass of category-extras
21:57:29 <stepkut> heh
21:58:00 <edwardk> indexed store, state, writer, traced, cont, and discont
21:59:47 <edwardk> those are all adjunction based. i wonder if it makes sense to build the notion of an indexed adjunction, then build them out of that
22:00:28 <edwardk> er, i stand corrected writer/traced aren't.
22:01:21 <ddarius> edwardk: What you need is fibred adjunctions.
22:01:49 <edwardk> hrmm
22:02:06 <edwardk> a -> g i (f i a)
22:02:56 <joe6> stringE :: String -> ExpQ -- I am trying to change String -> Exp, I cannot see any function in hoogle that can do this.
22:02:58 <edwardk> (f i a -> b) ~ (a -> g i b) — makes them obvious, its a family of adjunctions
22:03:12 <edwardk> now trying to parse that in the sense you mean
22:03:18 <joe6> Any thoughts on how I can transform ExpQ to Exp?
22:04:22 * ddarius doesn't actually know if fibred adjunctions would be helpful at all here, though it's not inconceivable.
22:05:16 <greap> What is an idiomatic way to do breadth-first list-comprehensions?
22:05:25 <edwardk> sadly, the writer monad/cowriter comonad aren't given rise to by this construction so its less useful
22:05:42 <edwardk> it does explain the bind of the indexed state monad quite nicely though
22:05:56 <copumpkin> taotree: hmm, it's tricky
22:06:06 <copumpkin> taotree: I'm going to sleep now, but will look more at some point
22:06:14 <edwardk> g i (f j (g j (f k a))) -> g i (f k a)
22:06:19 <taotree> copumpkin, ok. thanks
22:06:36 <taotree> copumpkin, I had heard it would require dynamic types, but was wondering...
22:06:46 <edwardk> for g = (->), f = (,)
22:07:05 <Saizan> joe6: there should be a StringE
22:07:06 <copumpkin> if you're willing to write out lots of cases, it's easy to do it without dynamic types, but it'd be nice to do more
22:08:09 <edwardk> taotree: you can build a big GADT and write an interpreter for it, but its going to be a fair bit of work.
22:08:36 <taotree> ah... I see. and I kind of sort of lied to try to simplify the initial question. Ultimately, the functions are likely arrows, and might want to be able to load new things using a plugin mechanism
22:08:47 <Axman6> kamatsu: are you still about?
22:08:52 <Axman6> and/or edwardk 
22:09:09 <Axman6> actually, maybe i can figure this out myself
22:09:13 <ousado> dynamic types? as in at runtime?
22:09:22 * ddarius recommends that course to Axman6.
22:09:24 <edwardk> Axman6: ?
22:09:25 <taotree> edwardk, hmm... I'll give some thought to that
22:09:54 <Axman6> i was going to ask about the existential quantification stuff i was talking about earlier, i think i should be able to figure it out though
22:10:08 <ddarius> F^ = Σ_{Fπ_E} ∘ K_1 ∘ F ∘ { }
22:10:19 <edwardk> my brain exploded trying to lift callCV into other comonad transformers. i'm currently cleaning up the mess and less than useful in the interim
22:10:55 <copumpkin> taotree: that's what I've been doing 
22:11:02 <taotree> edwardk, What I think I have is a DAG of arrows, so... building a tree and a propagator framework kind of thing...
22:11:03 <copumpkin> but defining what's compatible should be automatic
22:11:36 <taotree> copumpkin, "what you've been doing"?
22:11:46 <copumpkin> well, when I said gimme a few minutes
22:11:51 <copumpkin> I've been tinkering with how to approach it :P
22:11:53 <edwardk> taotree: i usually just build that sort of thing as an embedded domain specific language and then let users write their programs in it
22:12:14 <edwardk> less work than dealing with all the parsing nonsense in an external dsl
22:12:16 <joe6> Saizan: cannot seem to find StringE or atleast a TupleE
22:12:34 <taotree> edwardk, and that would work fine with plugins, too
22:13:02 <edwardk> yep
22:13:32 <taotree> Thank you, that's enough for me to bang my head against a wall for a little while to see what jars loose :)
22:13:33 <edwardk> taotree x-monad does this with their config file. its written in haskell
22:13:42 <joe6> Saizan: i think there is LitE, I will see how I can use it.
22:13:49 <taotree> great, I'll take a look at that as an example then
22:13:54 <Saizan> joe6: yeah, LitE . StringL
22:13:59 <edwardk> there is even a hackage package for providing this sort of recompilation model
22:14:03 <edwardk> i forget its name though
22:14:08 <Saizan> joe6: and there's TupE
22:14:19 <edwardk> found it
22:14:19 <edwardk> http://hackage.haskell.org/package/dyre-0.6.2
22:14:29 <edwardk> er http://hackage.haskell.org/package/dyre-0.8.5
22:14:54 <joe6> Saizan: yes just did that LitE .StringL. Thanks and Sorry for the bother. I was searching for TupleE
22:15:39 <edwardk> it didn't work for me when i tried it because i needed some crazy resstrictions on my package list, but it might fit your needs
22:15:57 <taotree> edwardk, copumpkin, thanks!
22:17:36 <kevinburke> hey i'm trying to create a data.Int32 object
22:17:40 <kevinburke> from the docs: For coercing between any two integer types, use Prelude.fromIntegral, which is specialized for all the common cases so should be fast enough. Coercing word types (see Data.Word) to and from integer types preserves representation, not sign.
22:17:59 <kevinburke> so in ghci i tried let a = fromIntegral 5 but a was still an integer
22:18:22 <edwardk> let a = fromIntegral 5 :: Int32 
22:18:46 <edwardk> if you don't have a type constraint there, defaulting will kick in and give you an Int, unless you use it in a context that forces it to be an Int32
22:18:52 <kevinburke> edwardk: thanks!
22:19:22 <ddarius> The default default for Integral types is Integer.
22:19:32 <ddarius> :t fromIntegral
22:19:33 <lambdabot> forall a b. (Integral a, Num b) => a -> b
22:20:11 <edwardk> sorry s/Int\>/Integral/g ;)
22:20:20 <edwardk> er Integer
22:27:58 <ddarius> I think the default default might have been Int in Hugs for a bit.
22:28:41 * ddarius is amazed at how thoroughly and quietly Hugs has faded away.
22:29:39 <edwardk> i don't even have it installed anymore
22:30:13 <Axman6> bleh, this type stuff is not fun :(
22:30:33 <ddarius> I haven't had it installed for a very long time, but it's extremely rare for someone to mention it nowadays.
22:30:47 <ddarius> Axman6: I recommend Forth as an antidote.
22:31:07 <Axman6> i remember liking the little bit of forth i did in high school
22:31:22 <Adamant> hey hey, my my, Hugs and Forth will never die
22:32:13 <ddarius> Forth is in no threat of dying.
22:32:18 <ddarius> Hugs is already dead.
22:32:30 <ddarius> (So I guess it is also in no threat of dying.)
22:32:56 <shapr> Hugs is the only option I've seen for embedded systems
22:33:28 <edwardk> heya shapr
22:33:45 <edwardk> someone was talking about adding support for scripting tremulous in haskell the other day. thought of you
22:34:38 <shapr> I'm in favor, yah
22:35:04 <ddarius> shapr: That's a good point.  For running a Haskell implementation on your phone, Hugs and maybe NHC may be your only options.
22:35:05 <shapr> Those these days I'd be more interested in a compiler targeting msp430 or atmel
22:35:18 <shapr> er, "Though these days"
22:36:44 <Adamant> shapr: atmel32?
22:36:53 <Adamant> AVR would be pretty hard
22:37:22 <ddarius> shapr: Just write a Haskell implementation in Virgil.
22:37:25 <kevinburke> hey, do you have any tips for keeping lines under 80 characters? can you just insert a newline in the middle of a statement?
22:37:50 <kevinburke> for example this hunit test - "testassign" ~: (SAssign ("i" :: Lval) (EConstI (fromIntegral 5 :: Int32))) ~=? (parse $ tokenize "i = 5 ;")
22:37:58 <shapr> Adamant: Whatever is in the Arduino
22:38:11 <Adamant> AVR
22:38:15 <Adamant> that would be very tought
22:38:18 <Saizan> are there good criteria that say which additions to a confluent rewriting system maintain confluency?
22:38:21 <shapr> ddarius: What's Virgil?
22:38:59 <Adamant> they're RISCy but garbage collection imposes some real burdens on a chip that small
22:39:23 <Saizan> kevinburke: yeah, you just need to indent
22:39:33 <ddarius> @google Virgil programming language
22:39:34 <lambdabot> http://compilers.cs.ucla.edu/virgil/
22:39:34 <lambdabot> Title: The Virgil Programming Language
22:41:15 <ddarius> http://compilers.cs.ucla.edu/virgil/apps/
22:44:28 <joe6> need some help, guys. I have Q [(Exp,String)] that i am trying to convert to Q Exp. I can get it to Q [(Exp,Exp)] and I can use ListE to convert Q [Exp] to Q Exp, but am not sure how to get (Exp,Exp) to Exp.
22:45:02 <joe6> from String to Exp, LitE . StringL :: String -> Exp
22:45:07 <Axman6> aren't you guite new to haskell?
22:45:23 <joe6> but am not sure how to get (Exp,Exp) to Exp
22:45:37 <joe6> TupE seem to not work.
22:45:39 <Axman6> quite*
22:45:48 <joe6> > TupE
22:45:50 <lambdabot>   Not in scope: data constructor `TupE'
22:45:57 <Saizan> joe6: TupE takes a list
22:46:26 <Saizan> so you've to \(x,y) -> TupE [x,y]
22:46:53 <joe6> Saizan: oh, that was simple. I feel like an idiot. Thanks a lot.
22:46:59 <Axman6> heh
22:47:42 * ddarius is quite far from sure that joe6 is doing what he wants to do.
22:48:18 <joe6> Axman6: I doubt TH is rocket-science.
22:48:30 * shapr lights the fuse
22:48:35 <Axman6> sure, but it's generally not something people new to haskell get into
22:49:08 <shapr> I'm a fan of practicing above my level.
22:49:32 * ddarius is a fan of discarding the notion of "levels."
22:49:52 <joe6> Axman6: i have been trying haskell for some time now. But, I guess I want to take it to the next level. It is time to use Haskell, full-time now.
22:50:03 <shapr> ddarius: Not a big fan of D&D, eh?
22:50:11 <joe6> what is D&D?
22:50:52 <ddarius> shapr: Nope.
22:51:16 <joe6> Axman6: and I want to learn it well, than going to some other language.
22:51:28 <ddarius> shapr: In fact, I much prefer games that are skill-based.
22:51:43 <shapr> joe6: It's an early role-playing game designed by Gary Gygax and sold to Wizards of the Coast
22:51:51 <ddarius> (or to be clear, purely skill-based)
22:51:54 <Axman6> joe6: sure, but TH isn't asll that commonly used really
22:52:35 <shapr> I wish TH were more popular... it can do all sorts of nifty things!
22:52:48 <Axman6> it has its uses, but it's certainly not an essential skill to be a skilled haskell programmer
22:53:04 <c_wraith> shapr: It was sold to TSR.  WotC bought them many years later.
22:53:05 <Axman6> shapr: write some tutorials on how to use it and why it's helpful then@
22:53:06 <joe6> Axman6: what are the alternatives? generics seems harder than TH. Though, syb is easier but is not that flexible.
22:53:06 <Axman6> !*
22:53:11 <shapr> c_wraith: point
22:53:21 <Axman6> what do you need generics for?
22:53:23 <shapr> Axman6: I wrote the VERY FIRST tutorial for Template Haskell!
22:53:31 <Axman6> write moar!
22:53:33 <Axman6> :P
22:53:58 <joe6> this is an awesome tutorial: http://web.archive.org/web/20080822110747/haskell.org/bz/th3.htm
22:54:00 <ddarius> TH is underused, but TH is also rarely the answer.
22:54:30 <Axman6> fuck yes! figured out how to get this bloody crazy type stuff working!
22:54:38 <joe6> ddarius: why do you say that? There is quite some boilerplate code to using records.
22:55:11 <ddarius> Axman6: Congrats.
22:55:22 <Axman6> in the vim haskell mode, is there any way to ask it for the type of a function?
22:55:53 <joe6> In my situation, I want to diff some records and I want to show only the fields which are different.
22:55:54 <Axman6> because, i know what this function does, i just have no idea what its type should be 
22:56:07 <joe6> and I do not want to take the easier way of writing out each field compare.
22:57:50 <edwardk> axman: i usually use ghci for that
22:58:14 <edwardk> or load up implicitparams and set a subexpression = ?foo
22:58:14 <Axman6> yeah. loading this file into ghci will be a lot of pain. we have a fairly complex build system
22:58:38 <edwardk> then the unification error message gives me the signature
22:59:11 <joe6> c_wraith: who is TSR?
22:59:43 <c_wraith> joe6: http://en.wikipedia.org/wiki/TSR,_Inc.
23:00:03 <Axman6> edwardk: better idea, just give ti a type that's wrong, and haver ghc tell me :P
23:00:49 <ddarius> c_wraith: Terminate and Stay Resident (though perhaps a bit anachronistic...) would have been a better name.
23:02:18 <Saizan> Axman6: turn on the warning about missing toplevel signatures
23:02:30 <joe6> TH == Lisp macros, and I better learn it, else I will be thinking about lisp macros every time I start programming in haskell.
23:03:19 <ddarius> Okay.  So Tsuru is nowhere near Shinjuku.
23:03:25 <ddarius> Close to Roppongi though.
23:04:05 <Axman6> very
23:04:17 <Axman6> about... 5 minutes walk?
23:04:38 <copumpkin> roppongi is the place to hook up with dudes, from what I hear
23:04:42 <copumpkin> in case you're into that
23:04:56 <ddarius> copumpkin: Roppongi is simultaneously seedy and high-end.
23:05:01 <copumpkin> yep
23:05:12 <Axman6> well done copumpkin, you've made the whole office laugh
23:05:22 <copumpkin> oh why thank you :)
23:05:37 <copumpkin> let's just say that I know a dude who hooked up with a dude in roppongi
23:08:27 <copumpkin> well, I successfully killed the conversation in here
23:08:29 <copumpkin> mission accomplished
23:09:15 <copumpkin> yukkuri yu!yu!yu! just posted to the mailing list
23:09:19 <Wooga> update of gedit haskel layout indenation mode: ftp://neverb.net/soft/mine/gedit_haskell_mode/haskell_indentation-latest.tar.gz
23:09:25 <copumpkin> :)
23:09:37 <copumpkin> Wooga: are you yukkuri yu!yu!yu!?
23:09:40 <Wooga> copumpkin: yes
23:09:55 <copumpkin> good name!
23:09:58 <Wooga> thank you
23:10:05 <Wooga> %)
23:10:47 <levifikri> Hi, I'm running Haskell on Windows. Trying to install CUDA package http://hackage.haskell.org/package/cuda. But failed when running .configure script: "checking for cuda.h... no"
23:11:41 <levifikri> I'm using MingW32 and have already installing cuda libraries (cuda.h file exists).
23:12:29 <levifikri> I guest the configure script couldn't locate the file. Anyone could help?
23:12:32 <Saizan> try --extra-include-dirs= to point cabal to it, might also need --extra-lib-dirs= 
23:12:41 <Axman6> hmm, is there a way to tell ghci to look in a certain dir for libraries? using -i for each library this file uses will be more than a little unfun
23:14:46 <levifikri> $ cabal install cuda-0.3.2 -p --extra-include-dirs="C:\Program Files\NVIDIA GPU
23:14:46 <levifikri>  Computing Toolkit\CUDA\v3.2\include" --extra-lib-dirs="C:\Program Files\NVIDIA
23:14:46 <levifikri>  GPU Computing Toolkit\CUDA\v3.2\include"
23:14:53 <levifikri> trying that, but still doesn't work
23:15:57 <levifikri> checking for cuda.h... no
23:15:57 <levifikri> configure: error: could not find CUDA headers
23:15:58 <levifikri> cabal.exe: Error: some packages failed to install:
23:15:58 <levifikri> cuda-0.3.2 failed during the configure step. The exception was:
23:15:58 <levifikri> ExitFailure 1
23:16:27 <Axman6> you may need to use \\ instead of \
23:16:36 <Axman6> and possible '\ \ instead of spaces
23:16:42 <Axman6> '\ '*
23:19:51 <Axman6> possibly*
23:20:57 <levifikri> Axman6 it still doesn't work. Perhaps need to modify the configure script?
23:21:18 <Axman6> no idea, i try to stay away from windows where possible
23:22:00 <levifikri> I also want to. It just happen that my CUDA driver doesn't support Linux :(
23:22:19 <joe6> hell, any thoughts on this, please? http://hpaste.org/43458/joe
23:22:20 <Axman6> aren't there drivers for CUDA on linux?
23:22:41 <joe6> it will list all fields and constructors of record including any sub records
23:23:26 <levifikri> my laptop uses Optimus technology. It runs two graphic card: Intel and GeForce. Unfortunately it only supports windows 7.
23:23:47 <Axman6> ouch
23:25:54 <kfr> Does somebody know the etymology behind the lambda? Did he just pick it at random or does it stand for a word?
23:26:42 <pacak> kfr: http://en.wikipedia.org/wiki/Lambda_calculus ?
23:27:22 <kfr> pacak: Yes, that one
23:27:50 <kfr> pacak: The article did not have any etymological explanation as far as I remember
23:27:55 <kfr> So where did Church get it from?
23:28:43 <Saizan> it was kind of a typography accident
23:28:57 <Saizan> church used ^ over the variable name, initially
23:29:02 <Saizan> or so i've read.
23:30:03 <kfr> Hahaha
23:30:10 <kfr> That is weak :/
23:30:49 <diegoviola> i build desktop/web apps, servers, web services, networking apps, etc, how can haskell help me there?
23:31:11 <Axman6> there are some extremely fast haskell web servers
23:31:12 <kfr> diegoviola: It can't, it's an impractical esoteric language
23:31:14 <edwardk> yeah it was ^ over the name to match russell and whitehead, then it moved to a caret next to the name because the typesetter couldn't do that, and then the typesetter changed it to a lambda, because he thought it looked better.
23:31:20 <ddarius> The possibly apocryphal story is that Church used a hat, then a typographer couldn't render that so wrote ^x, and then a later typographer thought that that was supposed to represent a lambda.
23:31:28 <edwardk> yeah
23:31:29 <kfr> edwardk: Hahaha that is hilarious
23:31:38 <Axman6> ddarius: haskell is also a fanstastic language to write network servers in
23:31:38 <kfr> Alright cheers
23:31:45 <kfr> I should add that to the article really
23:31:52 <ddarius> Axman6: Try again.
23:32:02 <Axman6> uh, diegoviola, not ddarius 
23:32:18 <kfr> http://akivaleffert.com/papers/hat-calculus.pdf
23:32:21 <kfr> Hat calculus :D
23:33:15 <MasseR> If I try to install software that depends on process 1.0.1.4, I get the following error "I found a duplicate definition for symbol runInteractiveProcess". How should I fix this?
23:33:16 <diegoviola> hm ok
23:34:13 <edwardk> kfr: hahahaha
23:34:34 <kfr> Haskell is based on hat calculus
23:34:43 <Axman6> diegoviola: http://haskell.org/haskellwiki/Simple_Servers http://catonmat.net/blog/simple-haskell-tcp-server
23:34:44 <kfr> There must be a ton of puns hidden in there..
23:34:57 <Axman6> hatskell!
23:35:37 <edwardk> i like the sheet of paper with the proof of consistency of ZFC in the torn off margin
23:35:48 <kfr> diegoviola I was just kidding, I am actually currently coding an SCGI server for a web dev framework in Haskell
23:35:54 <Axman6> edwardk: did you write it? :)
23:36:20 <edwardk> it needed a rather interesting comonad transformer, but yes.
23:36:24 <diegoviola> kfr: nice
23:36:29 <diegoviola> Axman6: interesting
23:37:11 <diegoviola> I've been writing Perl/PHP/Ruby, I'm new to functional programming, what are the advantages?
23:37:42 <Axman6> what aren't the advantages!
23:37:43 <Axman6> :P
23:37:52 <diegoviola> I've been writing Ruby apps for the past 3 years
23:37:55 <Axman6> diegoviola: speed for one
23:38:13 * kfr came from Ruby when he started doing Haskell
23:38:14 <Axman6> ruby is dog slow, haskell can be up there with C, sometimes faster
23:38:19 <joe6> diegoviola: for one thing, easy to understand
23:38:39 <joe6> diegoviola: easy to read
23:39:05 <Axman6> heh, says you, lots of beginners would strongly disagree
23:39:09 <systemfault> I've always seen haskell as being a lot slower than C unless you make the haskell code C-ish
23:39:20 <kfr> systemfault it generally is, yes
23:39:26 <diegoviola> thanks
23:39:34 <Axman6> systemfault: depends what you're doing
23:39:38 <kfr> http://shootout.alioth.debian.org/u64q/which-programming-languages-are-fastest.php
23:39:51 <diegoviola> is haskell something i have to compile or is it interpreted?
23:40:02 <kfr> diegoviola you can do either
23:40:09 <Axman6> both
23:40:19 <Axman6> we've got a repl and a very good compiler
23:40:28 <Axman6> actually, they're the same thing =)
23:40:29 <kfr> (strictly speaking any interpretation ultimately involves compilation, no matter what language really)
23:40:52 <diegoviola> nice
23:40:59 <Saizan> (..and vice versa?)
23:41:13 <kfr> But nowadays many people use "compile" synonymously with "converting source code to natively executable machine code in a binary of its own"
23:42:02 <ddarius> diegoviola: Did you take a dart board with programming languages on it and throw a dart at it and thus arrive at Haskell?  Presumably there is some reason you are looking at Haskell rather than Erlang, say.
23:42:39 <kfr> Web dev is much bigger in the Erlang community
23:43:41 <kfr> Whereas the Haskell community is full of closet mathematicians who much prefer abstract discourse over actually programming
23:44:05 * Axman6 isn't one of them
23:44:06 * ddarius sees nothing "closet" about them.
23:44:14 <kfr> diegoviola: Haskell is statically compiled so you will have greater compile time correctness and not as many runtime errors at least
23:44:17 <kfr> Err
23:44:19 <kfr> STATICALLY TYPED*
23:44:23 <Axman6> aye, they're very flamboyantly mathematical!
23:44:34 <Axman6> hmm, i don't think i spelt that correctly
23:45:18 <diegoviola> kfr: interesting
23:46:23 <Axman6> diegoviola: you know how in ruby, you never really know what something is? you don't get that in haskell
23:46:50 <kfr> And it has a sophisticated type system with type inference so you usually don't need to specify the types of values explicitly while still having static types
23:47:00 <kfr> Which is very convenient
23:47:20 <systemfault> static typing without type inferance is often too verbose..
23:47:23 <systemfault> See C++...
23:47:30 <kfr> As for the actual functional programming... I'm not sure I can make a case for that
23:50:25 <Axman6> diegoviola: if you're interested, check out the LYAH tutorial, very similar in style to _why's guide to ruby
23:50:32 <Axman6> but.. better :)
23:50:38 <Axman6> less cats though
23:50:39 <diegoviola> thanks :)
23:50:43 <diegoviola> will do
23:50:48 <Axman6> @where lyah
23:50:49 <lambdabot> http://www.learnyouahaskell.com/
23:50:55 <Axman6> that one^^^^^^^^^6
23:51:11 <kfr> 6666
23:51:13 <Axman6> > 1^6
23:51:15 <lambdabot>   1
23:51:23 <Axman6> > 1^60000
23:51:25 <lambdabot>   1
23:54:43 <nejucomo> I get confused by "type currying" and classes, especially now that I'm attempting to use mtl.
23:56:32 <nejucomo> Suppose I have concrete types called State and Exception, and I want to expression state transformations and exceptions.
23:56:44 <nejucomo> I want to define: type MyResult t = ???
23:57:11 <diegoviola>    1. ghci> [x*2 | x <- [1..10]]  
23:57:12 <diegoviola>    2. [2,4,6,8,10,12,14,16,18,20]  
23:57:13 <nejucomo> Is it: type MyResult t = MonadState State (Error Exception t)
23:57:21 <diegoviola> very cool that
23:59:41 <c_wraith> diegoviola: that's just a list comprehension.  many languages have those.  More interesting:  map (*2).  Even more interesting:  fmap (*2)
23:59:57 <Cale> nejucomo: Is MonadState a type constructor?
