00:00:17 <BMeph> At least that one's solvable by replacing the Prelude, which almost everyone wants to already, for many reasons.
00:00:45 <ddarius> Unfortunately, everyone wants to replace it with their own pet vision.
00:01:17 <dolio> Not me.
00:01:22 <dolio> I want to replace it with Cale's pet version.
00:01:27 <min> At least restructure the class hierarchy so that it's, well, correct.
00:02:34 <Kaidelong> I would be happy just to see the prelude rely on things like Functor, Foldable, etc
00:03:18 <ddarius> Thanks for illustrating my point.
00:03:59 <Kaidelong> the real solution would be to get rid of the prelude entirely
00:04:19 <Kaidelong> and just import the stuff you need explicitly
00:04:24 <brbrooks> 03:00 <BMeph> ddarius: Followed by the "Familiarity with if-then-else in other languages leads people to mess up the layout for its use, to the point that a change was prompted in Haskell's syntax to accomodate the error."
00:04:52 <Eduard_Munteanu> Yeah, there's a lot of overlapping with functionality expanded on in other modules.
00:05:20 <Eduard_Munteanu> Like Data.List, System.IO
00:05:29 <Kaidelong> also fully qualified and sensible names for things might be nice
00:05:42 <Kaidelong> but I suppose legacy will stop that
00:06:40 <Kaidelong> you could use the typeclass system to get around a lot of that with overloading though, so I don't see why it should be a bad habit to keep specialized things with fully qualified names and class overloads as your short names IE map, +, etc
00:25:40 <Axman6> edwardk: thanks for the comment on my blog :)
00:28:46 * hackagebot sbv 0.9.8 - Symbolic Bit Vectors: Prove bit-precise program properties using SMT solvers.  http://hackage.haskell.org/package/sbv-0.9.8 (LeventErkok)
01:00:50 <monokrome> 21:29 <@Archwyrm> Brendan_: "Why not" is a dangerous attitude of bloat and feature creep.
01:00:54 <monokrome> Truest of stories ever told!
01:00:56 <lars9> how to design an infinite tree in which any integer i is stored as (i, f i) ? for memoisation
01:01:05 <monokrome> Ack. Wrong channel. Sorry.
01:05:34 <BMeph> lars9: 1) Make an infinite tree, filled with i 2) Transform the i to (i, f i) at each spot
01:05:49 <BMeph> 3) ??? 4) PROFIT! ;þ
01:06:17 <lars9> BMeph: how to make an infinite tree?
01:25:54 <BMeph> lars9: Make a tree, then "make" it not be finite. Simple! ;þ
01:27:02 * hackagebot hoogle 4.2 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2 (NeilMitchell)
01:29:59 <BMeph> lars9: Here, I'll start you off: "data LarsTree a = LarsBranch a (LarsTree a) (LarsTree a")
01:54:18 <zzing> @src when
01:54:18 <lambdabot> when p s = if p then s else return ()
01:54:44 <dolio> @src unless
01:54:45 <lambdabot> unless p s = if p then return () else s
01:55:44 <zzing> I am using GLFW and some how it feels 'dirty', like I should be using C or something :p
02:04:41 <Maxdamantus> :t when
02:04:42 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
02:13:38 <zzing> Now all we need is a while and a for :p
02:13:54 <mauke> :t forM_
02:13:54 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
02:14:37 * zzing feels dirty
02:19:15 <aristid> @hackage monad-loops
02:19:16 <lambdabot> http://hackage.haskell.org/package/monad-loops
02:20:42 <jkramer> Ahoy
02:21:46 <jkramer> Can anyone tell me if I did something wrong here or if the module is just broken? http://paste.pocoo.org/show/325289/
02:22:03 <jkramer> The program simply exits and there's no background process
02:22:59 <mauke> what's System.Daemon?
02:23:43 <jkramer> It's the module the provides detachDaemon, which claims to fork the process into background
02:23:57 <jkramer> http://hackage.haskell.org/packages/archive/MissingH/latest/doc/html/System-Daemon.html
02:29:42 <mauke> well, the code is definitely broken
02:29:46 <mauke> I don't see why it exits, though
02:30:47 <jkramer> This works, so I guess it's really just the other module: http://paste.pocoo.org/show/325293/
02:31:10 <mauke> yeah, detachDaemon is bad code
02:32:26 <zzing> Is there any way to tell cabal that .m files are for gcc? I need them for a module I am mucking with
02:39:46 <zzing> hmm, it appears that ghc-options is global when i need it to be local only for a few files (specifically use the option -x c)
02:55:19 <jkramer> Is there a way to catch the exception raised by "error"?
02:55:54 <ion> @hoogle catch
02:55:54 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
02:55:55 <lambdabot> Control.Exception catch :: Exception e => IO a -> (e -> IO a) -> IO a
02:55:55 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
02:56:24 <jkramer> That's all IO related, but error seems to have a weird type that can be anything
02:58:06 <mauke> yes
02:58:17 <mauke> @src error
02:58:18 <lambdabot> error s = throw (ErrorCall s)
02:59:36 <Cale> jkramer: Basically, you should try to avoid having to catch any error thrown by error
03:00:12 <jkramer> So what's the preferred method to do someMap ! "test" safely?
03:00:21 <jkramer> Check for existance first?
03:00:25 <mauke> no, use lookup
03:00:30 <Cale> jkramer: Because it's really awkward to do it properly, and not really originally intended to be possible. Think of calls to error like a slightly more user friendly form of nontermination.
03:00:31 <Twey> Use Maybe
03:00:48 <Cale> jkramer: Use lookup instead, unless you are *sure* the key is in the map
03:00:51 <jkramer> Maybe, good one :D
03:00:52 <jkramer> Thanks
03:00:59 <Twey> Yeah, lookup gives you a Maybe value
03:01:13 <jkramer> I'm pretty sure, but I want to be *really* sure :)
03:01:17 <Twey> Then just fmap stuff into it until you can give a sane default or something
03:01:28 <jkramer> Ok, thanks
03:01:57 <alpounet> error should be used to give information about why the program cannot go any further and why it stops
03:02:35 * Twey thinks the Maybe version should have received the nice operator instead.
03:03:02 <zzing> If ghc-options: -x c would apply to all files being built under the target, and {- OPTIONS_GHC -x c -} isn't read in the file itself, is there any other way to get ghc to compile an m file as if it were a c file? (i.e. I assume pass it on to gcc)
03:06:24 <gienah> zzing: maybe try something like: ghc -optc -std=gnu99 --make -o output a.hs b.hs c.c d.c
03:06:57 <zzing> gienah: This is in a cabal file, and it is an m file
03:07:24 <gienah> zzing: so ghc calls gcc for you with the -optc stuff. hmm, I don't know what an m file is ?
03:07:36 <zzing> m is objective C
03:07:42 <zzing> I just need it to treat it like it would a C file
03:07:46 <zzing> gcc knows how to deal with it
03:08:26 <gienah> hmm, well anyway since you want to do this with cabal, then I guess with the cabal hooks stuff
03:08:39 <zzing> I don't think -optc will work because right now it doesn't know that an m file would be treated like a c file
03:08:57 <zzing> gienah: too bad I can't figure out anything with the cabal hook stuff
03:09:22 <gienah> zzing: there is a page of crazy examples of cabal hook stuff, digging it up ...
03:10:12 <gienah> http://www.moonloop.net/haskell/docs/cbs-custom.html
03:13:03 <zzing> has potential
03:13:05 <zzing> Thank you for the list
03:13:32 <gienah> zzing: this might also give some hints: http://hackage.haskell.org/trac/hackage/ticket/188
03:24:02 <zzing> gienah: A solution seems to have presented itself. I rename the m files to c files and then add the C option that it is an objective c file. Normal C files will compile just fine as objective c.
03:26:21 <lars9> could anyone check if the "~" in line 11 is neccessary? it's a memoisation via infinite lazy Trie
03:31:08 <mauke> preflex: remember <Botje> 'Please leave a continuation after the beep and I will call it as soon as possible'
03:31:27 <mauke> lars9: ECONTEXT
03:31:46 <Botje> mauke: the remember db is per-channel, then?
03:31:47 <lpsmith> heh,  nice one
03:31:50 <mauke> Botje: no
03:31:59 <lars9> mauke: what's that?
03:32:00 <alpounet> nice quote indeed
03:55:14 <mauke> @unmtl StateT h [] a
03:55:14 <lambdabot> h -> [(a, h)]
04:20:45 <kenjin2201> I remember when I used haskell last year, my emacs automatically completed guard "|".  Now I lost it. I want my haskell-mode to be more comfortable. Can anyone help me?
04:51:19 <Egbert9e9> how do i find out what's a core package?
04:51:32 <Egbert9e9> cabal warns me against upgrading core packages
04:52:01 <Axman6> well, base is a core package, so you don't want to upgrade that
04:52:07 <dcoutts_> Egbert9e9: or turn it around, only upgrade the things you specifically want to upgrade
04:52:18 <dcoutts_> which is easy: cabal install blah blah blah
04:52:46 <Egbert9e9> so all the things i've already installed i want to upgrade
04:52:48 <Egbert9e9> cool
04:52:51 <Egbert9e9> alright
04:53:15 <Egbert9e9> wow, that's a long list
04:53:23 <Egbert9e9> ~57 packages
05:09:21 * hackagebot testrunner 0.9.1 - Easy unit test driver framework  http://hackage.haskell.org/package/testrunner-0.9.1 (ReinierLamers)
05:33:28 * hackagebot language-javascript 0.4.0 - Parser for JavaScript  http://hackage.haskell.org/package/language-javascript-0.4.0 (AlanZimmerman)
05:48:40 <kuffaar> type TestReader = ReaderT TestRecord; readerTest :: TestReader IO (); runReaderT readerTest record -- I don't really get how this runReaderT works since its signature is runReaderT :: r -> m a so I would expect it to take only one argument, not two
05:48:55 <kuffaar> However, (runReaderT readerTest) record appears to work just the same so I suppose it works in a different way
05:49:08 <Axman6> :t runReaderT
05:49:10 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
05:49:21 <kuffaar> Huh
05:49:32 <Axman6> it's a record function
05:49:39 <Axman6> so, the name is somewhat overloaded
05:49:58 <kuffaar> I just looked at http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-Reader.html hmm
05:50:20 <kuffaar> *Main> :t runReaderT
05:50:20 <kuffaar> runReaderT :: ReaderT r m a -> r -> m a
05:50:22 <kuffaar> Hmm indeed
05:50:24 <kuffaar> That is confusing
05:50:36 <Axman6> the element inside the ReaderT is called runReaderT, to access that element in a ReaderT, you use the function that also gets defined that has the type ReaderT r m a -> r -> m a
05:50:47 <kuffaar> Oh now I get it
05:50:51 <kuffaar> Of course
05:51:33 <Axman6> if you define a record: data Foo = Bar { baz :: Int, blah :: String } then that also defines functions baz :: Foo -> Int, and blah :: Foo -> String
05:53:02 <kuffaar> If I want the Reader to be at the bottom of the monad stack I, I can't use a ReaderT?
05:53:17 <kuffaar> I'd use the non-T Reader monad?
05:53:48 <Axman6> depends
05:54:08 <kuffaar> ReaderT r m a has an m in there hm
05:54:21 <kuffaar> For the next monad in the stack
05:54:22 <Axman6> you can have something like WriterT [] (ReaderT r IO a) i think
05:54:40 <kuffaar> Well that's with m = IO
05:54:44 <kuffaar> What if I don't have any IO?
05:54:49 <kuffaar> What if there's no next monad?
05:55:11 <Axman6> then just sue Reader
05:55:13 <Axman6> use8
05:55:15 <kuffaar> Right
05:55:21 <Axman6> what are you, Amazon? :P
05:56:05 <kuffaar> I don't follow
05:56:17 <Axman6> suing readers. don't sorry
05:57:17 <n0den1te> >> len :: [a] -> Int# -> Int
05:57:27 <n0den1te> what's the Int# there? an intermediate something?
05:57:35 <Axman6> an unboxed Int
05:57:38 <Axman6> @srrc Int
05:57:38 <lambdabot> data Int = I# Int#
05:57:59 <n0den1te> I was looking over GHC.List#len. I didn't follow that at all. 
05:58:01 <n0den1te> :(
05:58:31 <Axman6> an Int is like a pointer to a C int, an Int# is like an actual C int
05:58:48 <Axman6> (well an Int is a pointer to either a C int, or a thunk that can produce one)
05:58:56 <n0den1te> Sure, why not just write len :: [a] -> Int ?
06:00:02 <n0den1te> @src length
06:00:02 <lambdabot> Source not found.
06:00:16 <luite> > maxBound :: Int
06:00:18 <lambdabot>   9223372036854775807
06:00:34 <Axman6> n0den1te: better performance
06:00:35 <luite> in general on 64 bit x86 platforms, a C int is 32 bit
06:01:02 <Axman6> ok, a size_t then? long perhaps?
06:01:10 <Axman6> either way, it's not important
06:01:37 <n0den1te> > maxBound :: Integer
06:01:38 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
06:01:38 <lambdabot>    arising from...
06:01:46 <n0den1te> :D
06:02:02 <Axman6> n0den1te: basically, that Int# will only exist in a register
06:02:48 <n0den1te> Axman6: ah, Int# (caching, so we are back to intermediate thingies. :P)
06:04:29 <Axman6> ?
06:04:58 <n0den1te> Axman6: I don't fully understand why that would be better performant. I guess I'll come back to it after reading some more haskell. :)
06:05:24 <n0den1te> I'll just take your word that it's better in terms of performance, for now. 
06:05:58 <Axman6> well, if it were stored in memory, then each time you added one to it, the CPU would have to fetch the value from memory, store it in a register, add to the register, and then store it again in another place in memory, for each element of the list
06:06:33 <Axman6> if ity's stored in a register, then for each element in the list, the CPU just has to increment the value in that register, which takes a single clock cycle basically
06:06:44 <Axman6> going to memory can be hundreds of clock cycles
06:07:45 <n0den1te> Axman6: Ah, now that makes sense. Technically, registers are outside haskell data structures, isn't it? I mean, haskell being "pure", it shouldn't actually mutate values, right?
06:08:06 <merijn> They're an implementation detail
06:08:13 <Axman6> if the compiler can see that it's ok tyo mutate values, then sure, it can
06:09:11 <n0den1te> Axman6: Danke!
06:10:49 <merijn> n0den1te: Basically, Haskell can't mutate values, but the compiler is only dealing with Haskell half the time, the other time it is dealing with the language you're compiling too (which can potentially allow mutation). The compiler only guarantees that it will LOOK like variables can't be mutated. It can do whatever it pleases in the target language as long as it follows the semantics defined by Haskell
06:14:34 <n0den1te> merijn: I was about to ask a related question(envy, mindreader :) registers and mutation -> they are dependent on architectures. More detail! Haskell, I love you more and more. 
06:14:37 * hackagebot language-javascript 0.4.1 - Parser for JavaScript  http://hackage.haskell.org/package/language-javascript-0.4.1 (AlanZimmerman)
06:18:09 <merijn> n0den1te: The interesting thing is that because Haskell is immutable the compiler can make all sorts of simplifying assumptions. Take C/Java for example "function1(); function2();" can't be turned into "function2(); function1();" for example, because maybe they both change the same global variables and then the program meaning would change
06:18:35 <merijn> n0den1te: Since the compiler KNOWS function1 and function2 can never change any global variable it is free to order them any way it wants
06:18:53 <merijn> (in Haskell, I mean)
06:19:50 <n0den1te> merijn: I also loved the laziness in Haskell. For instance, when I define variables with let using composed functions and later actually call them, the functions aren't actually evaluated until the moment. Hard to beat it! :)
06:20:53 <Axman6> this is only possible due to purity
06:21:02 <Axman6> and the above example merijn gave
06:21:23 <n0den1te> Axman6: *nod* *nod*
06:21:45 <aristid> merijn: doesn't haskell also have to check for unsafePerformIO? :)
06:21:46 <merijn> n0den1te: Other interesting of using let/where is that if you have a really expensive function and you need the result multiple times it will only be called once
06:21:51 <aristid> -haskell+GHC
06:21:58 <merijn> aristid: It doesn't, which is why it is unsafe
06:22:02 <sipa> aristid: if you use unsafe*, you're on your own
06:22:15 <aristid> merijn: well, OK, so you REALLY should avoid unsafe*
06:22:26 <merijn> aristid: unsafe* means "I know what I'm doing and I promise you (the compiler) that this will never break"
06:22:27 <sipa> sometimes you need to disable certain optimizations if you use unsafe*
06:22:42 <merijn> aristid: Hence why they are called unsafe :p
06:23:16 <aristid> merijn: it would seem so
06:24:13 <n0den1te> merijn: Interesting point. I was reading about let/where sometime back. will get back to it later tonight. I'm currently working through Hudak's book(Gentle intro to haskell) after some cursory reading of LYAH. 
06:24:37 <merijn> Gentle Intro to Haskell? Good luck :>
06:25:10 <n0den1te> merijn: Not difficult, actually. I was struggling with scala last year. So, reading haskell is easier now. :)
06:25:26 <n0den1te> merijn: I attribute that to Scala. :>
06:26:07 <merijn> I stand behind the observation of someone in #python: "<Brend> Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something."
06:26:30 <quuuux> is http://pastebin.com/SccMDSYY a fundamental show-stopper to that way of getting around TH's stage restriction?
06:26:44 <merijn> Personally I think the combination of LYAH and Real World Haskell is really good
06:27:10 <merijn> @where RWH
06:27:10 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
06:27:17 <n0den1te> merijn: RWH is on my to-read list. :)
06:27:24 <aristid> they should write a sequel for RWH
06:27:33 <aristid> RWH 2: Now with Applicatives
06:27:36 <Kaidelong> complex world haskell?
06:27:45 <quuuux> or, is there some way to postpone GHC's name-in-scope checker until after declaration splices have been spliced in?
06:27:45 <Kaidelong> or perhaps surreal
06:27:57 <merijn> n0den1te: I think LYAH gives an excellent background in the basics and RWH contains good examples of doing some real world stuff
06:28:30 <Kaidelong> lyah was interesting for me in tying Haskell nicely to algebra
06:28:41 <Kaidelong> which was not as obvious in what I did of RWH
06:29:06 <etarasov> is there any way to use C #defines in haskell code?
06:29:13 <n0den1te> merijn: yes, I worked upto chapter 6 or something. Don't remember, sometime back. I really wanted to look at more texts and do some exercises. Caltech's lab exercises. 
06:29:15 <Kaidelong> let
06:29:17 <Eduard_Munteanu> etarasov: yes
06:29:25 <Kaidelong> or well, just giving something a name
06:29:25 <Eduard_Munteanu> etarasov: see the CPP extension
06:29:37 <etarasov> Eduard_Munteanu: thanks
06:29:45 <merijn> I'm considering writing a "Learn You A Type Theory For Great Good" to treat type theory in a LYAH style once I get done with my current programming practical :p
06:30:37 <n0den1te> merijn: I think you should look at apocalisp's series of type theory tutorials for inspiration. They are mostly in Scala, but you should be good with Haskell too. :)
06:31:55 <n0den1te> merijn: http://apocalisp.wordpress.com/2010/06/08/type-level-programming-in-scala/
06:32:49 <asmund> I get "Parse error in pattern" from tihs line: buildTree a:b:xs [] = buildTree xs (combine a b):[]
06:33:04 <asmund> but what's wrong with that?
06:33:06 <kuffaar> Shouldn't that be (a : b : xs)?
06:33:11 <mauke> asmund: the buildTree a part
06:33:15 <mauke> you can't have function calls in patterns
06:33:21 <n0den1te> merijn: They are a series of articles focussed on type theory wrt Scala. 
06:33:40 <etarasov> Eduard_Munteanu: could you please tell where can I find it's documentation?
06:36:30 <merijn> n0den1te: That's rather specific though, I'm more talking about type theory in general, which I've been reading up on, but the intermediate level writing is absent
06:36:55 <merijn> There's plenty of complete idiot's guide to type theory and plenty of research papers, but almost nothing in between
06:37:03 <quuuux> oh, hmm. I could just move every interesting declaration into the splice, but that's ugly because the declarations then need to be indented
06:38:29 <Eduard_Munteanu> etarasov: you just need -XCPP or {-# LANGUAGE CPP #-} pragma, then you use it just like the C preprocessor
06:38:52 <n0den1te> merijn: I see. I'd be interested in reading what you come up with. 
06:38:58 <Eduard_Munteanu> merijn: TAPL?
06:39:14 <Eduard_Munteanu> etarasov: you could look it up in the GHC docs
06:39:23 <merijn> Eduard_Munteanu: Yeah, that's been on my to read list for a while, but I think by now I'm mostly beyond that
06:39:35 <Kaidelong> hmm, interesting, using the C preprocessor on Haskell code? What would you do with this exactly?
06:39:41 <merijn> Also, I'm a cheap socialist student so I think we should have free writing ;)
06:39:51 <Eduard_Munteanu> Yeah, agreed.
06:40:11 <merijn> Kaidelong: Foreign Function interface + C constants declared as defines?
06:40:13 <quuuux> what would be nice is a way to define a 'module and a half' in one file, where the 'half module' has definitions for splice time in the 'full module'. If that makes any sense
06:40:31 <Kaidelong> FFI huh?
06:40:44 <Kaidelong> oh
06:41:00 <Kaidelong> I suppose you'd want to be able to work with the C preprocessor to work with C code, naturally...
06:41:03 <Eduard_Munteanu> Kaidelong: GHC itself and base libs already use CPP a lot
06:41:16 <etarasov> yea, it's awesome c library with big amount of defines
06:41:17 <aristid> :t getArgs
06:41:18 <lambdabot> Not in scope: `getArgs'
06:41:23 <aristid> @hoogle getArgs
06:41:24 <lambdabot> System.Environment getArgs :: IO [String]
06:41:32 <Kaidelong> hmm, but in theory, just declaring something in Haskell is similar to a C define, right?
06:41:48 <Eduard_Munteanu> Mm, no.
06:42:04 <Eduard_Munteanu> C defines are totally expanded and erased.
06:42:37 <Eduard_Munteanu> They're mere substitutions.
06:42:39 <Kaidelong> Well you could do that in haskell so long as it is pure, right? You just may not want to, particularly with polymoprhic values...
06:43:05 <Eduard_Munteanu> Yeah, but I mean Haskell is way stronger than that.
06:43:24 <aristid> Eduard_Munteanu: when i'm struggling to understand an expression, substituting expressions for their definitions usually works pretty well
06:43:29 <Kaidelong> I guess recursive definitions would be an example where you can't do it
06:43:47 <Kaidelong> since they might never actually terminate (but still have a sensible value)
06:43:50 <lars9> how to read () ?
06:43:57 <quuuux> Kaidelong: laziness should save you there, right?
06:43:59 <Kaidelong> lars9: "unit"
06:44:08 <Kaidelong> quuuux: strictness actually
06:44:14 <Kaidelong> or rather the lack of it
06:44:15 <lars9> thanks, how to read f :: a->b  ?
06:44:27 <Kaidelong> lars9: "f is a function from a to b"
06:44:54 <Kaidelong> @ty const undefined
06:44:55 <lambdabot> forall a b. b -> a
06:45:15 <Kaidelong> that shouldn't be inhabit
06:45:16 <Kaidelong> ed
06:45:21 <Kaidelong> go undefined
06:48:41 * Kaidelong wonders on terminology; is laziness just "call-by-need" or do people mean it to imply that things are non-strict by default as well?
06:49:26 <mauke> Kaidelong: what's the difference?
06:49:47 <Eduard_Munteanu> I think Kaidelong means speculative evaluation might be allowed.
06:50:02 <Eduard_Munteanu> Which isn't "by need".
06:50:04 <Kaidelong> mauke: one is a strategy for evaluating things and the other is semantics that changes what things *mean*
06:50:41 <Kaidelong> if you write "const" in ML it actually means something different from the haskell const
06:51:05 <Kaidelong> (although it means the same thing where they are both defined)
06:52:24 <augustss> Kaidelong: lazy evaluation is call-by-need, but some people use lazy to mean non-strict
06:52:57 <Kaidelong> that is what I suspected was going on
06:53:35 <quuuux> appropriately, some people are non-strict with the definition of 'lazy'
06:53:44 <mauke> some people are lazy
06:53:47 <augustss> The Haskell report is careful to use non-strict, and not lazy.
06:54:04 <Kaidelong> and the puns start to flow
06:54:37 <kuffaar> If I were lazy, I'd go back to Ruby
06:55:28 <augustss> I thought Ruby used sloppy evaluation.
06:56:02 <quuuux> evaluate the term, except when it misses and evaluates the next one instead?
06:56:36 <augustss> evaluate the term, if it's something like what we want then use it
07:01:47 <kuffaar> type PrintFunction = String -> LockedConsole m () <- how do I enforce MonadIO m in this type?
07:02:29 <kuffaar> Urgh, m missing there anyways
07:03:11 <kuffaar> I have plenty of MonadIO m => String -> LockedConsole m () signature functions
07:03:17 <kuffaar> And I want to make a central type for those
07:03:25 <kuffaar> but I'm not sure what that type looks like
07:03:37 <mauke> not possible
07:03:46 <kuffaar> :[ ok
07:05:19 <kuffaar> mauke so I have no choice but to specify the full signature for all of those?
07:05:32 <kuffaar> Just because of the MonadIO m part?
07:05:59 <mauke> type T m = String -> LockedConsole m ()
07:06:00 <quuuux> kuffaar: type PrintFunction m = (etc)
07:06:12 <mauke> f :: (MonadIO m) => T m
07:06:19 <kuffaar> I see
07:06:52 <kuffaar> Is it not centralise the type variable signature somehow?
07:07:19 <quuuux> kuffaar: if you find that all your functions look like that, it might be worth re-evaluating the LockedConsole type to see if you can hide it with GADTs or existentials or similar
07:08:28 <sipa> type T m = MonadIO m => String -> LockedConsole m ()
07:09:17 <kuffaar> Oh, that works?
07:09:24 <kuffaar> That would solve it
07:09:40 <sipa> seems to work here - maybe it requires certain extensions
07:10:22 <kuffaar> Illegal polymorphic or qualified type:
07:10:22 <kuffaar>   MonadIO m => String -> LockedConsole m ()
07:10:22 <kuffaar> Perhaps you intended to use -XRankNTypes or -XRank2Types
07:10:47 <sipa> hmm, that way it becomes a rank-2 type
07:10:54 <sipa> ok, maybe you don't want that
07:11:23 <kuffaar> Then I'd have to use that extension in everything that uses this module?
07:12:09 <aristid> not necessarily
07:13:52 <j-invariant> in haskell I am using (x,y) to represent the gaussian integer x + iy
07:14:19 <kuffaar> Doesn't Haskell already come with a rich set of modules for Complex arithmetic?
07:14:22 <j-invariant> I have basic things like add multiply but can you do GCD on it?
07:14:37 <kuffaar> Oh, integers
07:14:39 <kuffaar> x, y in Z?
07:14:43 <j-invariant> yeah
07:14:53 <kuffaar> Sure you can GCD that
07:15:12 <j-invariant> how would I wrote that? 
07:16:24 <kuffaar> gcd :: (Int, Int) -> Int; gcd (x, y) = if y = 0 then x else gcd y $ mod x y
07:16:27 <kuffaar> Or something like that
07:17:12 <kuffaar> Or wait, do you mean the gcd of two complex numbers?
07:17:12 <j-invariant> is that recursive or are they different gcd functions?
07:17:15 <j-invariant> yeah
07:17:17 <kuffaar> That's recursive
07:17:33 <sipa> j-invariant: how would you write it for normal integers?
07:17:36 <aristid> kuffaar: it's also pointlessly uncurried :)
07:17:37 <j-invariant> yeah it would be  gcd :: (Int, Int) -> (Int, Int) -> Int
07:17:49 <kuffaar> aristid: What do you mean?
07:17:58 <aristid> kuffaar: gcd :: (Int, Int) -> Int
07:18:10 <j-invariant> sipa: just repeating subtraction until one side is zero
07:18:12 <kuffaar> aristid: What about it?
07:18:33 <aristid> kuffaar: why not gc :: Int -> Int -> Int, if you want to implement only integer gcd
07:19:00 <kuffaar> aristid: Because he wanted it for pairs of Gaussian integers
07:19:07 <kuffaar> But I misunderstood anyways
07:19:57 <j-invariant> http://crazyproject.wordpress.com/2010/10/23/compute-greatest-common-divisors-in-the-gaussian-integers/
07:20:08 <j-invariant> I found this but its a bit complicated
07:20:12 <j-invariant> maybe that's just how it goes
07:20:15 <aristid> j-invariant: what a crazy project.
07:21:20 <j-invariant> We used the following procedure to compute the division algorithm in \mathbb{Z}[i]. Given \alpha = a+bi and \beta = c+di, with \beta \neq 0, let p be an integer closest to \dfrac{ac+bd}{c^2 + d^2} and let q be an integer closest to \dfrac{bc-ad}{c^2+d^2}. Then \alpha = Q\beta + R, where Q = p+qi and R = \alpha - Q\beta. (This is what computers are for.)
07:21:56 <j-invariant> an integer closest to?this is weird
07:22:06 <kuffaar> Sounds heuristic haha
07:23:03 <lars9> @src foldl
07:23:04 <lambdabot> foldl f z []     = z
07:23:04 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
07:23:08 <lars9> @src foldr
07:23:08 <lambdabot> foldr f z []     = z
07:23:09 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:25:07 <j-invariant> "The quotients qk are generally found by rounding the real and complex parts of the exact ratio (such as the complex number α/β) to the nearest integers"
07:25:27 <j-invariant> so I could just write "floor" or "ceiling" and it will work? seems doubtful
07:26:54 <c1de0x> how do i overload an arithmetic operator (e.g. +) without instancing Num?
07:27:12 <j-invariant> you cant
07:27:17 <c1de0x> i need to have  a -> a -> Instruction, not a -> a -> a
07:27:27 <etarasov> > let 1 + 1 = 3 in 1+1
07:27:28 <lambdabot>   3
07:27:45 <merijn> c1de0x: Why does it have to be +?
07:27:57 <Cale> c1de0x: Then you have two options: shadow the Prelude definition (perhaps import the Prelude qualified), or just use another operator symbol
07:27:59 <merijn> Why not just define your own function?
07:28:01 <c1de0x> merijn: because. i'm modeling a language.
07:28:08 <Cale> try ^+^
07:28:12 <Cale> or something :)
07:28:19 <c1de0x> Cale: that's painful to have to type.
07:28:41 <c1de0x> isn't python smart enough to resolve the ambiguity based on the way the resulting type is used?
07:28:44 <merijn> You could shadow the Prelude as Cale says, but then normal + won't work anymore
07:28:58 <c1de0x> that sux.
07:29:04 <c1de0x> i guess i can juts do +++
07:29:42 <merijn> You could also use `plus` I suppose
07:30:16 <c1de0x> yeah but it feels ugly :(
07:31:13 <j-invariant> does anyone have this algorith
07:31:26 <j-invariant> in  alibary?
07:32:19 <Eduard_Munteanu> j-invariant: can't you do it like you'd do it on paper? Just amplify that fraction by the conjugate of the denominator.
07:32:57 <j-invariant> it says here it's not flexible enough to support the Gaussian integers
07:33:17 <j-invariant> http://blog.sigfpe.com/2006/01/eleven-reasons-to-use-haskell-as.html
07:36:57 * hackagebot hlint 1.8.5 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.5 (NeilMitchell)
07:38:08 <blueonyx> j-invariant: i just implemented gcd for gaussian integers in Singular and i can tell, you need to round (not ceil or floor), since there are numbers which get you into an endless recursion otherwise
07:38:35 <j-invariant> blueonyx: wow cool!
07:38:58 * hackagebot language-javascript 0.4.2 - Parser for JavaScript  http://hackage.haskell.org/package/language-javascript-0.4.2 (AlanZimmerman)
07:39:41 <j-invariant> blueonyx: and if it's 0.5 you can just pick either one?
07:40:57 <blueonyx> yea the gcd in the gaussian integers is non-deterministic in this case
07:41:12 <j-invariant> hmm
07:41:18 <j-invariant> hats weird!
07:42:48 <blueonyx> but gcd(85,1+13i) returns -7-6i here :/
07:43:46 <j-invariant> is that wrong?
07:44:08 <j-invariant> > (1:+13)/((-7):+(-6))
07:44:09 <lambdabot>   (-1.0) :+ (-1.0)
07:44:09 <blueonyx> your link says 6-7i
07:44:12 <j-invariant> oh
07:44:19 <j-invariant> I think your code is right and the blog post is wrong
07:44:27 <j-invariant> or maybe both answers are okay
07:44:43 <j-invariant> its just signs so probably doesnt mater
07:45:05 <blueonyx> no real and imaginäry parts are also swapped
07:45:17 <blueonyx> *imaginary
07:45:19 <mauke> heh
07:45:58 <blueonyx> > (1:+13)/(6:+(-7))
07:45:59 <lambdabot>   (-1.0) :+ 1.0
07:46:40 <blueonyx> > (47:+13)/(53:+56)
07:46:41 <lambdabot>   0.5414634146341464 :+ (-0.32682926829268294)
07:46:53 <j-invariant> could a number have different GCDs?
07:47:03 <blueonyx> yea
07:47:14 <blueonyx> > (47:+13)/(2:+(-5))
07:47:15 <lambdabot>   1.0 :+ 9.0
07:47:36 <blueonyx> no wait
07:47:57 <blueonyx> > (53:+56)/(2:+(-5))
07:47:58 <lambdabot>   (-6.0) :+ 13.0
07:48:17 <blueonyx> so \mathsf{gcd}(47-13i,53-56i) = 1 is wrong
07:48:22 <j-invariant> really
07:48:25 <blueonyx> oh minus
07:49:46 <blueonyx> > (53:+(-56))/(2:+5)
07:49:47 <lambdabot>   (-6.0) :+ (-13.0)
07:49:59 <blueonyx> > (47:+(-13))/(2:+5)
07:50:00 <lambdabot>   1.0 :+ (-9.0)
07:50:57 <blueonyx> j-invariant: is this your blog?
07:51:11 <j-invariant> no I just found that searching
07:52:27 <blueonyx> but may algorithm also chooses "an integer closest to ..", why do i get different results :/
07:52:37 <j-invariant> are both results the same norm?
07:52:41 <j-invariant> and both common divisor?
07:52:49 <j-invariant> maybe the rounding at 0.5 goes different ways
07:53:01 <blueonyx> hm
07:54:08 <blueonyx> j-invariant: do you know what N in N(47-13i) = 2378 means?
07:54:38 <silver> >47^2 + 13^2
07:54:50 <blueonyx> ah Norm okay
07:56:18 <j-invariant> blueonyx: I would imgae a GCD has the same norm
07:56:21 <j-invariant> larget possible norm
07:56:43 <j-invariant> I guess gcd(a,b) = c implies gcd(N(a),N(b)) = N(c)?
08:00:01 <blueonyx> i dont know, but apparantly someone is wrong on the internet }:->
08:00:19 <aristid> no way.
08:02:49 <merijn> What is the proper name for the opposite of truncating division? (i.e. division which always rounds up)
08:03:12 <blueonyx> floor?
08:03:16 <blueonyx> eh ceil
08:03:30 <blueonyx> no division?
08:03:56 <merijn> I guess I could go with "ceil_div"
08:04:32 <j-invariant> blueonyx: "GCD is only determined up to a multiplication by a unit"
08:04:36 <ddarius> @google daan leijin div mod
08:04:37 <lambdabot> http://answers.yahoo.com/question/index?qid=20080504170849AA771nz
08:04:37 <lambdabot> Title: In Pascal, what do mod- and div-arithmetic do? - Yahoo! Answers
08:04:42 <ddarius> Curses
08:04:57 <ddarius> j-invariant: Obviously.
08:05:10 <aristid> @google daan leijin
08:05:12 <lambdabot> http://www.myspace.com/537409488
08:05:12 <lambdabot> Title: Lei Jin (Lei) on Myspace
08:05:17 <aristid> HAHAHA
08:05:24 <j-invariant> lol
08:06:08 <ddarius> @google daan leijen div mod filetype:pdf
08:06:10 <lambdabot> http://research.microsoft.com/en-us/um/people/daan/download/papers/divmodnote.pdf
08:06:10 <lambdabot> Title: Division and Modulus for Computer Scientists
08:06:12 <blueonyx> but 2+5i > 1 is it?
08:06:40 <aristid> > 2 :+ 5
08:06:41 <lambdabot>   2.0 :+ 5.0
08:06:44 <aristid> > 2 :+ 5 > 1
08:06:45 <lambdabot>   No instance for (GHC.Classes.Ord (Data.Complex.Complex t))
08:06:45 <lambdabot>    arising from ...
08:06:48 <j-invariant> > (2 :+ 5)*(2 :+ (-5))
08:06:49 <lambdabot>   29.0 :+ 0.0
08:06:54 <j-invariant> it has norm 29
08:07:00 <aristid> blueonyx: (>) is not defined for complex numbers
08:07:28 <j-invariant> gcd(a,b) = g then a = ga', b = gb' so N(a)=N(g)N(a') and N(b)=N(g)N(b')
08:07:49 <j-invariant> the question is are N(a') and N(g') relatively prime
08:08:14 <j-invariant> because if you have the norm then you can just generate all the gaussian integers using pythagorean triples
08:08:25 <j-invariant> that's a classic haskel list compreshension
08:08:46 <j-invariant> on the other hand it wont work if N(a') and N(b') have a common factor
08:09:52 <blueonyx> > 2^2 + 5^2 > 1
08:09:52 <lambdabot>   True
08:10:16 <blueonyx> j-invariant: sorry, i dont follow
08:11:06 <blueonyx> but its okay
08:14:46 <kuffaar> What do I do to use a particular ask/asks when I'm in a stack of multiple Reader(T) monads? Just specify the type with ::?
08:15:24 <kuffaar> Although it's probably nicer to make dedicated functions for that which operate on that particular monad
08:15:48 <kuffaar> I suppose I just need to lift that stuff then sometimes when it's a monad which is not on top of the stack?
08:16:30 <etarasov> kuffaar: right, lift can ask reader not in top of monads stack
08:20:10 <augustss> kuffaar: yes, you need to lift.  I've seen some tricks to automate the lifting, but just doing it manually is a good start.
08:22:05 <nomeata> I need a mapWithKeyM f. Is there something better than (T.mapM id . M.mapWithKey f), where T is Data.Traversable?
08:22:06 <lambdabot> nomeata: You have 1 new message. '/msg lambdabot @messages' to read it.
08:22:52 <ddarius> T.sequence
08:26:13 <j-invariant>     Couldn't match expected type `(t, t)' against inferred type `[b]'
08:26:13 <j-invariant>     In a stmt of a 'do' expression: (q, r) <- gaussDivision a b
08:26:16 <j-invariant> why does it do that
08:26:25 <j-invariant> wait I see what it means
08:27:19 <nomeata> ddarius: hmm, right. But looks like there is no “native” mapWithKeyM. 
08:28:40 <j-invariant> > gcd 1 7
08:28:41 <lambdabot>   1
08:30:42 <blueonyx> :t gcd
08:30:43 <lambdabot> forall a. (Integral a) => a -> a -> a
08:30:58 <blueonyx> :t 3:+3
08:30:59 <lambdabot> forall t. (RealFloat t) => Complex t
08:31:03 <kuffaar> When you extend an existing stack of monads you append your new monad on the right, right?
08:31:15 <kuffaar> ReaderT ExistingStuff (ReaderT MyNewOne)
08:32:48 <Eduard_Munteanu> kuffaar: innermost monad needs most lifting
08:33:13 <kuffaar> So... you want to pick their order based on which one you use the most?
08:33:15 <Eduard_Munteanu> It also depends on the monad's semantics
08:34:07 <Eduard_Munteanu> Like choosing to apply WriterT to ST instead of the other way around.
08:34:19 <Eduard_Munteanu> Yeah.
08:36:02 <jmcarthur> well, you can't apply ST to Writer
08:36:15 <Eduard_Munteanu> Though, more accurately, it also depends on how you get stuff out of it. Like when you "run"/"eval" something, the outermost layer is peeled off first.
08:36:28 <Eduard_Munteanu> jmcarthur: yeah, I hinted to STT
08:36:37 <jmcarthur> huh? STT?
08:36:45 <jmcarthur> can such a thing exist?
08:36:56 <Eduard_Munteanu> I've seen an STT around, it's safe only for some monads.
08:37:04 <jmcarthur> oh
08:37:11 <jmcarthur> sounds bad then ^_^
08:37:47 <Eduard_Munteanu> http://hackage.haskell.org/packages/archive/STMonadTrans/0.2/doc/html/Control-Monad-ST-Trans.html
08:38:20 <Eduard_Munteanu> I'm not sure why exactly though.
08:40:11 <jmcarthur> well, i for one won't be touching STT :)
08:41:46 <Eduard_Munteanu> Any idea why it could be unsafe? Or why do people think it's unfeasible to have an ST transformer?
08:43:33 <Eduard_Munteanu> I could interpret 'STT (WriterT Identity [a]) a' as something that runs a bunch of in-place computations and logs their results.
08:44:45 <ddarius> Conceptually there's no problem with STT, as you can view ST as a State monad with a map of references.  The only difficulty implementing a pure ST that way (ignoring the performance difference) is the type of the map of references.
08:46:16 <ddarius> However, in this view, many uses of a putative STT would need to duplicate the state, which is not an easy thing to do for actual references.
08:46:24 <Philippa> "performance" includes memory in this case, yeah
08:47:06 <Philippa> to handle the interesting cases you'd need to build a pretty funky system capable of holding and GCing across the equivalent of multiple histories
08:47:36 <Eduard_Munteanu> Hm, so why doesn't this happen with the normal, non-transformer ST?
08:47:48 <Philippa> because it's at the bottom of the stack: nothing can branch histories
08:48:07 <Philippa> (cf why there'll never be an IOT)
08:48:35 <Eduard_Munteanu> Are you concerned about the specific case of stacking multiple STTs each with matched phantom state types?
08:48:39 <Philippa> FWIW, I don't think it's impossible. I just think it's hard work and really likely to want a choice of implementation strategies
08:48:42 <Philippa> no
08:48:46 <ddarius> Eduard_Munteanu: No.
08:48:49 <ddarius> Consider STT []
08:49:00 <Eduard_Munteanu> Yes...
08:49:09 <Philippa> or for extra fun, STT LogicT ErrorT []
08:49:35 <Philippa> (in some regards it's no nastier, but it stops you special-casing the [])
08:49:37 <ddarius> Philippa: It's doable, probably even in Haskell, but it would probably defeat the point of using a low-level STT.
08:49:56 <ddarius> In a language with first-class state, it would be straightforward.
08:50:08 <Eduard_Munteanu> Well, if you lift into the inner stuff, then what can possibly go wrong? There's no way to do ST stuff when you lift.
08:50:23 <Philippa> it copies heaps about though
08:50:30 <Philippa> it's not that it won't work, it's that GCing it's a nightmare
08:50:47 <Philippa> you can't even keep a simple 'version' number, because 'versions' aren't a linear property
08:50:53 <ddarius> Eduard_Munteanu: StateT s [] a is s -> [(a,s)], so in this view, each of those s's in the return type are different heap states.
08:51:34 <Philippa> that too, if you have a sloppy version of [] that allows communication between 'universes'
08:51:38 <Eduard_Munteanu> Oh.
08:52:24 <Philippa> (so, a concurrency monad instead, say)
08:52:27 <ddarius> So if you did, runSTT (do x <- lift [1,2,3]; ...), you'd need three, independent copies of all the mutable variables, i.e. all the STRefs and STArrays.
08:55:15 <Eduard_Munteanu> Damn, sorry it's probably me, but I don't see why :/. State or the refs itself can't be accessed from the inner monad.
08:55:54 <Eduard_Munteanu> Unless it's something like STT s (STT s (...))
08:57:18 <Philippa> Eduard_Munteanu: you can't do ref lookups, but you can copy heaps
08:57:47 <Philippa> the 'inner' monad isn't inner, it's outer
08:58:06 <ddarius> Eduard_Munteanu: If I do, do ref <- newSTRef 0; x <- lift [True, False]; if x then modifySTRef succ ref else modifySTRef succ ref; ...) ref should be 1 after each option, not 1 after the first and 2 after the second.
08:59:29 <ddarius> So ref needs to be split into two independent variables at the second statement.
09:01:51 <Eduard_Munteanu> Ah, thanks, it makes a bit more sense now.
09:04:39 <Eduard_Munteanu> Philippa: yes, I mean 'inner' as it (the type) is written, I know it's unwrapped the other way around.
09:06:16 <Eduard_Munteanu> ddarius: does this ever happen without explicitly writing an STT-like construct? I presume it should.
09:06:37 <ddarius> I don't understand your question.
09:07:38 <Eduard_Munteanu> ddarius: I mean, does the implied 'bad behavior' happen in normal ST code if you try hard enough, without actually doing something STT-ish? Or is it something in STT that specifically allows 'bad behavior'?
09:08:23 <ddarius> There's nothing that corresponds to lift [True, False] in ST.
09:08:45 <kuffaar> Is it common to use Identity when you are creating a stack of monad transformers?
09:08:53 <kuffaar> In the inner most one?
09:09:15 * kuffaar was just looking at type Pass1 a = WriterT [Msg] (StateT Int (StateT [Line] (StateT [Address] Identity))) a
09:09:19 <kuffaar> http://stackoverflow.com/questions/2082927/haskell-monad-transformer-stack-and-type-signatures
09:09:30 <Eduard_Munteanu> I see.
09:09:39 <kuffaar> That a seems superfluous though
09:09:46 <Taejo> kuffaar: yes, it is common
09:09:47 * ddarius doesn't get people explicitly stacking reader over reader or state over state.
09:10:07 <Eduard_Munteanu> kuffaar: that's how non-transformer variants are defined in transformer libs.
09:10:07 <kuffaar> ddarius what's the problem?
09:10:09 <ddarius> kuffaar: A lot of monad libraries simply define State as StateT Identity.
09:10:14 <ddarius> kuffaar: What's the point?
09:10:15 <Philippa> Eduard_Munteanu: ST doesn't allow you to branch heaps, STT must, simple as
09:10:34 <Taejo> kuffaar: because the innermost thing must be a monad, so you have to either do that or have State and StateT, Reader and ReaderT, etc.
09:11:07 <Eduard_Munteanu> Philippa: yeah, I just realized branching meant exactly what happens when you lift into something like the list monad.
09:11:17 <kuffaar> ddarius: Well in my case I have a ReaderT monad which is responsible for synchronised console IO and it's part of a library so I intend to extend the type signature now to add another ReaderT without modifying the code in the library
09:11:49 <Eduard_Munteanu> So there's no type-level trick like ST's rank-2 to prevent that?
09:12:07 <kuffaar> ST = ?
09:12:30 <Eduard_Munteanu> kuffaar: IO without IO :)
09:12:33 <ddarius> kuffaar: I added the "explicitly" for a reason, that said, you should newtype wrap single conceptual monad implemented as stacked transformers and then you won't have to deal with all this "how many times do I lift" stupidity.
09:12:46 <Eduard_Munteanu> Basically you get a store of references you can access and modify.
09:12:46 <c_wraith> kuffaar: State Threads.  It's not the greatest name for what it does
09:12:53 <ddarius> Eduard_Munteanu: Preventing that would mean preventing the point of STT.
09:13:02 <Philippa> kuffaar: ST gives you a mutable heap with references into it. It's different from STate.
09:13:37 <Eduard_Munteanu> ddarius: I'm thinking more of proving uniqueness, clearly it's safe to lift into Maybe.
09:14:30 <ddarius> Eduard_Munteanu: Supporting something like "catch" for STT Maybe would have similar problems.
09:15:28 <ddarius> Basically, the semantics of "keep the state no matter what" is s -> (m a, s), but that's just ST (m a)
09:16:49 <camilleTow> nice to see i am not alone here
09:16:57 <ddarius> Note that Writer, for example, isn't a problem because s -> (w, (a, s)) is isomorphic to s -> ((w, a), s)
09:17:06 <Eduard_Munteanu> I guess an experiment I could do to get deeper into this is write a mockup ST in terms of State, then write an STT and see what issues pop up.
09:18:16 <Philippa> camilleTow: far from it, so?
09:18:32 <hpc> haha STT
09:18:51 <Eduard_Munteanu> hpc: there is one
09:18:58 <camilleTow> just exploring for the first time
09:19:05 <Eduard_Munteanu> http://hackage.haskell.org/packages/archive/STMonadTrans/0.2/doc/html/Control-Monad-ST-Trans.html
09:19:06 <ddarius> (But also not, therefore, that STT Writer gives you no more power than ST Writer
09:19:23 <ddarius> )
09:21:09 <c_wraith> Yeah, it's more like STT Cont that's potentially troublesome
09:21:22 <Philippa> well, it's more like STT Cont covers everything...
09:21:45 <Philippa> but yeah, the State-like transformers are notably boring
09:21:45 <ddarius> c_wraith: Most monads will cause problems.
09:21:55 <Philippa> they're just one of the most frequent use cases
09:22:08 <ddarius> The safest rule is STT s m a is safe only when it is equivalent to STT s (m a)
09:22:22 <ddarius> ST in the latter case.
09:22:49 * Eduard_Munteanu wished 'S' in RWST stood for ST, not State
09:23:08 <Eduard_Munteanu> That would've been ok, right?
09:23:35 <ddarius> Eduard_Munteanu: In RWS it would have been, yes.  Not in RWST.
09:23:47 <Eduard_Munteanu> Erm, yeah.
09:23:57 <Twey> Heh, RWST: R, W, and ST
09:24:06 <Philippa> and you can have it just by building the RW ST stack and writing a few wrappers. So do it?
09:24:14 <Eduard_Munteanu> That looked more useful when I investigated it :)
09:24:28 <poincare101> Hi everyone. I was just looking around haskell, can you guys mention some projects that use it?
09:24:31 * ddarius has never used RWS or RWST.
09:24:45 <Eduard_Munteanu> Well isn't the whole point of RWST to alleviate the need of lifting?
09:24:52 <Eduard_Munteanu> *RWS
09:24:57 <ddarius> I doubt that.
09:25:15 <Philippa> I've never used RWS either
09:25:28 <Eduard_Munteanu> Monad transformers are okay, but lifting is getting on my nerves.
09:25:32 <Twey> poincare101: Darcs, XMonad, anything on Hackage, various companies
09:25:33 <Philippa> Eduard_Munteanu: it's only alleviated by writing some instances anyway, so who cares?
09:25:43 <Philippa> it's a smallish, constant space loss
09:25:54 <Eduard_Munteanu> Yeah.
09:25:58 <Philippa> if you're lifting at all your use sites, you're doing it wrong
09:26:17 <poincare101> Twey: various companies?
09:26:42 <Eduard_Munteanu> Yeah. I noticed Writer is really useful with ST to write productive, recursive functions living in ST.
09:26:51 <ddarius> @where industry
09:26:51 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_industry
09:26:58 <Eduard_Munteanu> (productive as in producers)
09:27:11 <hpc> :k ST
09:27:11 <lambdabot> * -> * -> *
09:27:54 <Twey> poincare101: http://cufp.org/
09:28:17 <ddarius> "I noticed there is a great synergy between Write and ST to write productive, iterative processes embedded in an ST tier."
09:28:39 <Eduard_Munteanu> Sounds like business / management / etc. talk :)
09:29:11 <Philippa> WriterT gives you an easy way to structure lazy ST stuff that spits out a monoid that can be eaten piece by piece, yes
09:29:48 * hpc should write a parser-substitutor using ST
09:30:06 * hpc 's website could use some perly string manipulation
09:30:14 <kuffaar> I think I just got my first transformer stack working: http://siyobik.info/pastebin_download.php?id=574 Did I do anything awkward/clumsy in that code? The dependency is from my general purpose library, for synchronised console output: https://github.com/epicvrvs/Knyaz/blob/master/Source/Knyaz/Console.hs
09:30:52 <Eduard_Munteanu> BTW, does ST actually use compiler primitives, or it's just strictness analysis / annotations to work out in-place updates?
09:31:40 <ddarius> Eduard_Munteanu: It's magic.
09:31:47 <ddarius> In fact, it's the same magic as IO in GHC.
09:31:51 <kuffaar> I was a bit confused at first though, because you need to unwrap the stack of transformers inside out when you enter the environment, I tried it the wrong direction first
09:32:22 <kuffaar> withLockedConsole $ runReaderT printStuff record
09:32:22 <kuffaar>  -- wrong
09:32:28 <Eduard_Munteanu> ddarius: so magic such that a State-based implementation couldn't be as efficient?
09:33:02 <Eduard_Munteanu> (well, excepting stuff such as arrays, which I understand must be magic)
09:33:07 <ddarius> You could do Clean-style stuff, but naively, no, the State-based version would not be able to be as efficient.
09:33:34 <Eduard_Munteanu> Is that the stuff with uniqueness types?
09:33:52 <merijn> Clean has uniqueness types, yeah
09:34:02 <andy__> is this possible in haskell:
09:34:03 <andy__> http://hpaste.org/43249/signextend
09:34:19 <andy__> (or can it be made to work out)
09:34:34 <merijn> At Nijmegen they made a Clean* and Haskell* compiler which allows you to combine Haskell with Clean and Clean with Haskell (respectively) so you can have uniqueness types in Haskell
09:34:43 <camilleTow> how easy is this stuff to learn in comparison with other like languages? and how useful in comparison?
09:34:44 <jacobian> http://www.infoq.com/presentations/Thinking-Parallel-Programming
09:34:45 <jacobian> amazing
09:35:20 <byorgey> camilleTow: it's both more difficult and more useful.
09:35:23 <Eduard_Munteanu> Last time I asked I got mixed opinions on whether uniqueness types would add anything to Haskell.
09:35:38 <byorgey> camilleTow: of course pretty much everyone in this channel would tell you that the usefulness outweighs the difficulty.
09:35:38 <Eduard_Munteanu> Though my intuition tells they could add annotation for strictness analysis.
09:35:47 <ddarius> They would certainly add something to Haskell.
09:35:53 <ddarius> They have little to do with strictness analysis.
09:36:09 * Eduard_Munteanu thought they could help it.
09:36:35 <Eduard_Munteanu> As in all unique values can safely be strict.
09:36:42 <byorgey> andy__: what do you mean, is it possible? does that code you pasted not work?
09:36:51 <andy__> it does not compile
09:37:03 <andy__> the idea is that the Bits a => SignExtend a instance is the default one chosen
09:37:24 <andy__> bitSize (undefined :: Integer) results in an error
09:37:27 <andy__> so trying to avoid it
09:37:36 <byorgey> andy__: oh, I see.  just turn in OverlappingInstances
09:37:44 <byorgey> turn *on
09:37:44 <kuffaar> camilleTow: I'd say it's extremely difficult to get into it and as for usefulness, well, you can use it for pretty much anything. It takes quite some time to get started, I think. It provides static typing and fairly sandboxed execution so entire classes of sources of bugs are eradicated and runtime errors are far less prevalent than in dynamically typed languages.
09:37:46 <andy__> i have both that and undecidable instances on
09:37:54 <pedro3005> how do I get the biggest element of a list?
09:37:55 <andy__> i will post the compiler message
09:37:58 <Eduard_Munteanu> Unless I'm lumping up strictness with inplaciness too much.
09:38:16 <quuuux> pedro3005: foldr max?
09:38:19 <camilleTow> thankas
09:38:31 <ddarius> Eduard_Munteanu: What does strictness have to do with "in-placeness"?
09:38:42 <byorgey> pedro3005: maximum
09:38:43 <andy__> http://hpaste.org/paste/43249/signextend_annotation#p43250
09:38:43 <Twey> kuffaar: It's not that difficult, especially if you come to it with few preconceptions.  I hear dibblego taught Haskell to his eight-year-old child(ren?) quite successfully.
09:39:16 <andy__> the message to me sounds like it will always choose the Bit a instance if i enable incoherent instances
09:39:20 <pedro3005> byorgey, thank you
09:39:25 <andy__> *Bits a
09:39:49 <andy__> i will test
09:39:52 <byorgey> andy__: I think you just need to add some type annotations
09:40:02 <byorgey> andy__: it doesn't know what type you want the (fromIntegral w) to be
09:40:09 <andy__> ok
09:40:16 <byorgey> so doing (fromIntegral w :: Integer) ought to work
09:40:16 <byorgey> or (fr
09:40:24 <byorgey> or (fromIntegral w :: Int)
09:40:36 <Eduard_Munteanu> ddarius: I was under the impression that strictness enables (in at least some cases) in-place updates as an optimizations.
09:40:42 <Philippa> Haskell's a great way to teach the basics of computation to kids. It's not such a great way to get stuff moving about on screen
09:40:49 <Eduard_Munteanu> *optimization
09:40:51 <andy__> byorgey, unfortunately, the library function has type Bits a => Int -> BitGet a
09:40:58 <kuffaar> Java has static typing and pretty much sandboxed execution, too, so those arguments apply there, too, basically. Both are very portable. In the language shootouts by Alioth Java 6 slightly ranked above ghc. I've had many problems with the memory consumption of Java programs though. Haven't really had the chance to examine this point with Haskell yet but I think in the case of Java it was some peculiarity of the Oracle VM in combination with the Swin
09:40:58 <kuffaar> g stuff I was using.
09:41:16 <byorgey> andy__: hmm? which library function?
09:41:17 <kuffaar> http://shootout.alioth.debian.org/u64q/which-programming-languages-are-fastest.php
09:41:18 <andy__> byorgey, i ran into this problem with bitSize as well - got around it by passing the result of a fromIntegral call to bitSize as opposed to undefined :: a
09:41:29 <andy__> byorgey, i will paste that code as well
09:41:34 <ddarius> Eduard_Munteanu: Why would strictness be relevant?
09:41:53 <Philippa> kuffaar: equating Haskell's typing to Java really doesn't hold up well, to the point where it'll tend to make people here think you're trolling
09:42:06 <Vizard_> hi
09:42:13 <byorgey> hi Vizard_ 
09:42:20 <kuffaar> Philippa: I've never made any such claim. Both are typed statically, though.
09:42:36 <merijn> kuffaar: Yes, but that is pretty much where all similarity ends :)
09:42:37 <andy__> http://hpaste.org/43251/bitget
09:42:46 <mauke> java's type system has holes big enough to drive an ArrayStoreException through
09:42:49 <hpc> to be fair, haskell typeclasses and java interfaces are damned near isomorphic
09:42:57 <andy__> the inline's are probably redundant in many of the cases
09:43:05 <mauke> hpc: I disagree
09:43:11 <Vizard_> i've a question about binary trees, are its values sorted from the root to the leafs ?
09:43:12 <merijn> hpc: Oh, don't say that here. You'll be crucified like I was last time here...
09:43:15 <merijn> And....too late
09:43:20 <Philippa> hpc: H98/2010 ones, maaaaybe. MPTCs? Not so much
09:43:22 <Taejo> hpc: perhaps H98 typeclasses
09:43:24 <Vizard_> or can it be also unsorted
09:43:35 <andy__> byorgey, line 56 is the particular function
09:43:37 <hpc> Taejo: that's what i meant; haven't dealt with 2010 much
09:43:43 <ddarius> Philippa: I wouldn't even say Haskell 1.0 type classes are "isomorphic" to Java interfaces.
09:43:45 <Eduard_Munteanu> ddarius: hm, I guess you're right, I don't know where that came from. I think it's sharing that matters: if it's not shared, it can be updated.
09:43:48 <camilleTow> i like what i am experiencing on the try haskell website
09:43:54 <ddarius> Eduard_Munteanu: Exactly.
09:44:05 <Philippa> camilleTow: cool
09:44:23 <mauke> hpc: how would you write Eq in Java?
09:44:31 <byorgey> andy__: ok, just a minute, let me try it out myself
09:44:32 <ddarius> Eduard_Munteanu: What you may be thinking of is that, in GHC, strictness enables unboxing which enables (some) values to be stored in registers and updated "in-place" that way, but this has little to do with, e.g., arrays.
09:44:47 <andy__> byorgey, ok, thanks for the help
09:44:56 <hpc> mauke: interface Eq<T> { public bool eq(T a, T b);}
09:45:08 <byorgey> Vizard_: it depends.  Binary trees in and of themselvves can have values in any order
09:45:16 <mauke> oh, that must be new
09:45:26 <byorgey> Vizard_: sometimes you have binary *search* trees where the values are sorted from left to right
09:45:36 <merijn> mauke: Java generics aren't really new anymore
09:45:41 <byorgey> Vizard_: or you could have a binary heap where the values are sorted from top to bottom or bottom to top
09:45:43 <mauke> they are to me!
09:45:57 <merijn> mauke: Then you should be glad you haven't done Java in that long :D
09:46:01 <Eduard_Munteanu> I see.
09:46:02 <hpc> generics were the bee's knees when i did java
09:46:08 <mauke> hpc: and how do you implement it for class Foo { int x; }?
09:46:12 <Vizard_> ah ok great ty
09:46:24 <Twey> Generics hadn't been invented when I did Java
09:46:29 * Twey escaped
09:46:51 <hpc> class Foo implements Eq<Foo> { eq (Foo a, Foo b) { return a.x == b.x;}; int x;}
09:46:57 <hpc> mauke: ^
09:46:58 <Eduard_Munteanu> ddarius: is there anything like "sharing analysis" there?
09:47:04 <portnov> @hoogle whileM
09:47:04 <lambdabot> No results found
09:47:05 <merijn> I have to do parallel programming in Java atm. After this course I'll hopefully never have to do Java again :p
09:47:21 <byorgey> andy__: ok, I think all you need to do is add a SignExtend a constraint to getBits
09:47:28 <andy__> ok
09:47:34 * hpc hates his java skill
09:47:39 <byorgey> andy__: the problem is that without that constraint, ghc has to pick a single instance once for all
09:47:53 <byorgey> andy__: but what you really want is for the instance to be chosen depending on what a is
09:47:54 <andy__> if SignExtend does not escape the module, will it be visible to users?
09:48:02 <andy__> yes
09:48:08 <Eduard_Munteanu> I think it's a bit like analysing the lifetime of objects in other compiler/language-related stuff.
09:48:09 <ddarius> Eduard_Munteanu: Yes, that's what uniqueness typing is.
09:48:21 <ddarius> Eduard_Munteanu: Alias analysis is more explicitly an example.
09:48:24 <byorgey> andy__: users will see that the type of getBits includes a SignExtend constraint
09:48:40 <byorgey> andy__: but if you don't export it they won't be able to make their own instances
09:48:43 <Eduard_Munteanu> So Haskell does no sort of analysis to optimize by in-place updates?
09:48:48 <andy__> byorgey, perfect - thanks
09:49:29 <kuffaar> The biggest statically typed languages which generally avoid raw memory manipulation (a major source of nasty bugs): 1. Java 2. C# 3. Objective C 4. Haskell? To me, static typing combined with fairly sandboxed execution form an important group of languages which generally provide a greater degree of correctness by default. Now, C# is somewhat portable but you can pretty much forget about using most of the .NET library because it's no longer being de
09:49:29 <kuffaar> veloped by Novell, Winforms are broken and can crash the X server on Linux, WPF they won't even touch, etc. I mean it's possible to write portable C# stuff with mono but you basically have to avoid the most sophisticated stuff available for it (which rather annoys me). Hmm and as for Objective C... I don't even know. Largely limited to Apple systems, no?
09:49:39 <Philippa> Eduard_Munteanu: GHC used to, certainly - it's one of the older recognised optimisations
09:49:53 <Eduard_Munteanu> I kinda know about aliasing analysis from C, but I presume in this context it's a bit different wrt what it can do.
09:49:54 <ddarius> Eduard_Munteanu: As merijn mentioned earlier, the Clean folk have generalized the front-end of Clean to accept Haskell (and apparently added uniqueness types to Haskell while they were at it), and Clean does this.
09:50:06 <Philippa> kuffaar: why are you dumping this stuff in chan?
09:50:25 <andy__> byorgey, a last minor thing - can you think of a way that UndeciableInstances is not required?
09:50:43 <Eduard_Munteanu> Ah so you kinda need annotations in the form of uniqueness types.
09:50:48 <andy__> byorgey, i tried adding Bits a to the context of class SignExtend a, though that didn't seem to help
09:50:57 <Philippa> Eduard_Munteanu: they help, yes, otherwise all you have is a conservative inference pass
09:51:03 <kuffaar> Philippa: I was commenting on the whole Java conundrum that popped up, would you rather have me split it up over 8-12 lines so it's less coherent?
09:51:24 <Philippa> kuffaar: I would rather you'd written less outright, and not kept introducing yet more languages, for one
09:51:28 <Eduard_Munteanu> Though I can't help making an analogy of lifetime analysis done in compilers, like use-def chains.
09:51:48 <andy__> byorgey, and a last thing - imagine there will be a virtual lookup, unless all of getBits is inlined - then is it similar to a c++ template instantiation?
09:51:53 <Eduard_Munteanu> Like "if we don't need it further, we can use it to store another value".
09:51:54 <andy__> *i imagine
09:53:15 <ddarius> Eduard_Munteanu: Yes, you can do such things.
09:53:17 <kuffaar> I was just outlining my line of thoughts with regards to choosing a programming language when correctness/safety of the code written matters and to me it pretty much boils down to Java and Haskell out of the top 20 languages, I think.
09:53:35 <ddarius> The main issue with doing such things implicitly is that it is a rather crucial optimization if you are relying on it, and it is rather fragile.
09:54:01 <ddarius> Eduard_Munteanu: Clean does uniqueness inference.
09:54:10 <Eduard_Munteanu> Nice.
09:54:43 <Philippa> ddarius: GHC does a basic analysis for update avoidance, even
09:54:56 <Eduard_Munteanu> Wouldn't it help a lot with monadic, sequenced operations? Or is that trivial already?
09:54:58 <kuffaar> How low level is Ada, by the way? Does it have raw memory manipulation, arrays which can be accessed without boundary checks etc?
09:55:28 <kuffaar> I know next to nothing about the language but I think it's actually still being used in some environments where correctness/security are a major concern?
09:55:39 <kuffaar> Didn't the US flight traffic control stuff use that?
09:56:14 <Philippa> kuffaar: I question your particular definition of 'low level'. It at least forces array accesses to be in bounds, but I believe generally avoids bounds checks. I doubt it does C-style raw memory manipulation, but this is more about typing than about the level of operations supported
09:56:55 <ddarius> Ada has "safe" and "unsafe" packages.
09:57:06 <Philippa> d'oh, yes, of course
09:57:52 <Philippa> Ada's generally fairly low-level in at least the perlis sense but also substantially safer than C, anyway
09:58:11 <Philippa> it's /the/ B&D language
09:58:18 <kuffaar> B&D?
09:58:38 <jacobian> bondage and discipline?
09:58:38 <Philippa> Bondage & Discipline
09:58:41 <jacobian> hah
09:58:58 <Philippa> (it's not /intended/ to deal in S&M, but views on that vary)
09:59:37 <byorgey> andy__: I don't know of a way to get around UndecidableInstances.  But UndecidableInstances is not really that bad.
09:59:52 <andy__> byorgey, ok, thanks for all the help
09:59:55 <Mathnerd314> Philippa: so if Ada is B&D, then what is Haskell?
10:00:04 <Eduard_Munteanu> S&M?
10:00:27 <Philippa> Mathnerd314: much better at negotiation :-)
10:00:34 <byorgey> andy__: as for the other question, type classes work by passing around a dictionary with the method implementations
10:00:49 <spetrea> I can't seem to find a good reason to motivate me to learn Haskell
10:00:57 <andy__> ok
10:00:58 <byorgey> so it's not really similar to a c++ template instantiation, as far as I understand
10:01:11 <spetrea> I know Perl,C/C++,Python,Javascript
10:01:12 <byorgey> andy__: otherwise I'm not sure exactly how to answer the question
10:01:12 <Philippa> (for those who've not been around long enough, I wrote an article for the Monad.Reader that ran with that gag from a "kink is fun" POV while discussing ways to make your code safer)
10:01:24 <spetrea> I need a good motivator for Haskel
10:01:26 <spetrea> *Haskell
10:01:29 <kuffaar> spetrea: What kind of code do you usually write?
10:01:37 <Philippa> (but then, Mathnerd314's poked around the blog it's now residing on and probably knows that)
10:01:47 <andy__> byorgey, that is clear enough - was more of a hypothetical - i do not believe getBits is a good candidate for inlining
10:02:02 <spetrea> kuffaar: well, all kinds, math code, code that does some statistics, GUI code, network code, web stuff
10:02:03 <kenjin2201> is there a function that finds the position an element in a list?  Or should I write it?
10:02:04 <Eduard_Munteanu> spetrea: well most of those languages are really similar, if you're looking for something different,
10:02:06 <spetrea> kuffaar: also gamedev
10:02:13 <byorgey> kenjin2201: findIndex
10:02:13 <mauke> @hoogle [a] -> a -> Int
10:02:13 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
10:02:13 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
10:02:14 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
10:02:14 <Eduard_Munteanu> *something more different, look at Haskell
10:02:27 <kenjin2201> byorgey : Thank you
10:02:36 <mauke> :t findIndex
10:02:37 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
10:02:43 <byorgey> kenjin2201: look at elemIndex also, it's a specialized version of findIndex
10:02:44 <spetrea> can I get something from Haskell, something really special ?
10:02:55 <Philippa> compared to that list? Definitely
10:03:03 <Philippa> an entire new way of thinking about code, if not several
10:03:10 <mauke> spetrea: at least a powerful type system
10:03:22 <Saizan> andy__: GHC tries to inline/specialize away the dictionary passing though
10:03:40 <kenjin2201> byorgey: Thank you again
10:03:48 <Eduard_Munteanu> Yeah. I tend to think dynamic typing is a really bad idea, though I could be wrong
10:04:10 <andy__> Saizan, ok - i think i prefer it that way over having to choose  (and choose wrong)
10:04:27 <spetrea> Eduard_Munteanu: does Haskell have dynamic typing ?
10:04:31 <Eduard_Munteanu> No.
10:04:35 <mauke> in some sense, yes
10:04:43 <portnov> @hoogle ifM
10:04:44 <lambdabot> System.Directory createDirectoryIfMissing :: Bool -> FilePath -> IO ()
10:04:44 <lambdabot> Network.HTTP.Headers HdrIfMatch :: HeaderName
10:04:44 <lambdabot> Network.HTTP.Headers HdrIfModifiedSince :: HeaderName
10:04:59 <Eduard_Munteanu> Well, what do you mean, types reified via data?
10:05:01 <Philippa> spetrea: you can bundle values up into 'dynamic' values and have to do an explicit cast - that can fail, safely - to use them at a specific type again
10:05:02 <Mathnerd314> mauke: wouldn't Data.Dynamic be dynamic typing?
10:05:08 <mauke> exactly
10:05:24 <Eduard_Munteanu> Is it truly dynamic typing? I guess not.
10:05:27 <Philippa> spetrea: there's a few other odds and ends, like you can get type representations for some types and pass those around. Most of the time you don't need to do these things though
10:06:10 <kuffaar> spetrea: Hmm when you write larger amounts of code in Perl and Python you will frequently end up with runtime errors because they are typed dynamically and there's only so much you can check for at compile time in such languages. Especially when you write services in dynamically typed languages this can become very annoying. If you were working with a statically typed language many of these errors would already be detected at compile time and wouldn
10:06:10 <kuffaar> 't require as many unit tests.
10:06:47 <portnov> @hoogle (Monad m) => m Bool -> a -> a -> a
10:06:47 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
10:06:48 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
10:06:48 <lambdabot> Network.BufferType buf_snoc :: BufferOp a -> a -> Word8 -> a
10:06:57 <Eduard_Munteanu> Dynamic typing is like ultrafinitist proofs :P
10:07:05 <andy__> not really an answer to spetrea's question - but having the expectations explicit in the types is always handy
10:07:13 <portnov> @hoogle (Monad m) => m Bool -> m a -> m a -> m a
10:07:13 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
10:07:13 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
10:07:13 <lambdabot> Control.OldException bracket_ :: IO a -> IO b -> IO c -> IO c
10:08:52 <kuffaar> spetrea: Now C and C++ are both typed statically but they are very low level languages and it's easy to mess up an index in some array, it's easy to accidentally pass around a pointer to an object which has already been deallocated, etc. You also perform nasty casts on pointers... all of these are sources of extremely difficult to track down bugs, especially in code which deals with threads.
10:09:15 <teki> If I want to show a Double with leading zeros instead of mantissa/exponent, where would I look to do this?
10:09:42 <mauke> printf, but see Numeric
10:09:42 <hpc> printf
10:09:45 <monochrom> the module Numeric, look for showFFloat
10:09:53 <teki> thanks all
10:10:28 <brbrooks> do any firms use haskell for HFT?
10:10:52 <finnomenon> brbrooks: http://tsurucapital.com/en/
10:10:53 <c_wraith> yes, several.
10:11:00 <finnomenon> is the only one I know of
10:11:03 <Eduard_Munteanu> Admittedly stock Haskell arrays don't provide static guarantees either.
10:11:03 <monochrom> > showFFloat Nothing 1e-10 ""
10:11:05 <lambdabot>   "0.0000000001"
10:11:14 <c_wraith> tsuru is one of the few that's highly public about their use of haskell
10:11:24 <teki> monochrom: yep, just got it
10:11:42 <teki> i didn't want to wade into overriding show for double, since it seems like that is a very bad idea
10:11:54 <Philippa> Eduard_Munteanu: they provide more than Java arrays do!
10:11:57 <kuffaar> spetrea: Haskell generally provides a greater degree of compile time correctness and safer execution because you usually do not deal with memory at such a low level unless you are dealing with the foreign function interface to interact with C libraries and such. As others have already pointed out, it has a very sophisticated type system unlike any of the languages you have mentioned and it can open your eyes to a whole new world of programming - esp
10:11:57 <kuffaar> ecially when you are new to pure functional programming (not all of Haskell is pure, in order to do anything interesting you will have to deal with code which has side effects).
10:11:59 <Eduard_Munteanu> Java has some, though. I've seen array bounds checking elimination coming up often
10:12:00 <ski> teki : indeed ..
10:12:15 <Eduard_Munteanu> Oh.
10:12:49 <Philippa> Eduard_Munteanu: Last I saw it doesn't provide that as a compile-time guarantee though, so statically you're still at risk of exception
10:13:26 <n0den1te> Java can throw runtime exceptions. ArrayStoreException is one of them. 
10:13:53 <Eduard_Munteanu> Ah, so it's possible to eliminate bounds checking but still throw exceptions at runtime?
10:13:58 <n0den1te> that happens when trying to access elements in an array where there are no values. >.<
10:14:09 <Philippa> Eduard_Munteanu: it's the VM that does that elimination, at runtime
10:14:18 <Philippa> the VM knows more about what's going on
10:14:23 <mauke> n0den1te: what?
10:14:31 <Eduard_Munteanu> Philippa: hrm, so it only works with JITed code.
10:14:37 <n0den1te> Eduard_Munteanu: what Philippa said. you can't throw runtime exceptions. VM does it. 
10:14:41 <Eduard_Munteanu> Makes sense.
10:14:43 <n0den1te> mauke: ?
10:15:03 <mauke> n0den1te: that's not what ArrayStoreException is
10:15:26 <mreh> I'm still having difficulty with cabal 1.8 creating multiple executables
10:15:40 <mreh> i.e. it won't do it
10:15:52 <Saizan> mreh: how does the cabal file look?
10:15:56 <Eduard_Munteanu> I find it intriguing how much proving stuff is going into GCC and the Linux kernel lately.
10:16:03 <kuffaar> spetrea: With your current knowledge of programming languages it will be quite brutal to learn though. I think you need to have a strong interest in expanding your horizons with regards to programming languages if you want to survive the first weeks with Haskell. I think you should also spend some time on at least one Lisp, just to see more of the world and learn a new concept or two. Common Lisp, Scheme and Clojure are the biggest ones.
10:16:13 <Eduard_Munteanu> Like lockdep, static checks for userspace copies etc.
10:16:16 <mreh> anyone know of a package that has two or more exes
10:16:23 <mreh> Saizan: I'll paste it
10:16:23 <n0den1te> mauke: ouch. crossed fuse. :/
10:16:25 <gwern> mreh: pandoc
10:16:59 <mauke> kuffaar: I disagree with the lisp thing on principle alone
10:17:05 <Eduard_Munteanu> (lockdep has been there for quite some time though)
10:17:12 <mauke> common lisp killed my parents
10:17:20 <j-invariant> @goggle "church of the least fixed point"
10:17:21 <lambdabot> http://www.springerlink.com/index/N4T2V573M58G2755.pdf
10:17:21 <lambdabot> Title: SpringerLink - International Journal of Parallel Programming, Volume 15, Number  ...
10:17:29 <Eduard_Munteanu> Heh, really?
10:17:31 <Twey> Nothing new in Lisps, if you know Haskell (and TH)
10:17:37 <Silvah> Lisp is impure evil.
10:17:38 <mreh> http://hpaste.org/43253/lji_cabal_file
10:17:47 <Eduard_Munteanu> Sounds like a paper title Wadler would use :)
10:17:57 <systemfault> mauke: They died of an overdose of parentheses?
10:18:05 <ski> Scheme is mostly nice
10:18:10 <mauke> I was severely underwhelmed by common lisp
10:18:11 <Philippa> Twey: nearly nothing. It's worth having experienced an image-based, highly dynamic system at least once, but you can go to Smalltalk for that too for example
10:18:13 <kuffaar> mauke: You think that knowing Lisp is harmful?
10:18:23 <ddarius> Twey: Sure there is.
10:18:28 <kuffaar> mauke: What languages did you know when you first dealt with CL?
10:18:33 <mauke> kuffaar: I don't see how learning CL is useful
10:18:37 <Twey> Philippa: Fair
10:18:40 <Philippa> kuffaar: it can be. You get people thinking 'closure' is a relevant concept in Haskell, for example
10:18:42 * ddarius likes Scheme as well.
10:18:43 <ski> Twey : hygienic macros
10:18:51 <mauke> kuffaar: BASIC, Pascal, C, C++, bash, Perl, possibly OCaml
10:18:56 <n0den1te> Philippa: Are you Socrates' wife? ;)
10:18:57 <Philippa> or confusing data constructors with atoms, or...
10:19:12 <Twey> ski: TH doesn't have hygienic macros?
10:19:14 <ddarius> Philippa, Twey: There is also things like MOP and such.
10:19:20 <Philippa> n0den1te: I hope not, I'm not particularly into guys however big the age gap :-)
10:19:24 <kuffaar> mauke: Hmm at that stage Lisp should still be interesting, no?
10:19:31 <Philippa> ddarius: yeah, CLOS or a close relative is worth having met
10:19:37 <mreh> Saizan: http://hpaste.org/43253/lji_cabal_file
10:19:39 <mauke> kuffaar: no. most of it felt like perl done badly
10:19:45 <kuffaar> Perl?! O_O
10:19:48 <mauke> yes
10:19:54 <ddarius> mauke: Hah.
10:19:54 <Silvah> oO
10:19:55 <Twey> I guess CLOS and the MOP are interesting.  Not sure they're something you couldn't understand after Haskell, though, especially if you followed all the ‘OO in Haskell’ research.
10:19:56 <mauke> Perl is a Lisp
10:20:04 <Silvah> Really?
10:20:04 <ski> Twey : i don't recall seeing it when i last looked at it (instead using some `gensym'-like thing)
10:20:16 <Twey> Hmm
10:20:19 <jacobian> perl is lisp minus all the things that make lisp cool 
10:20:22 <companion_cube> perl is a lisp ???
10:20:22 <mauke> case in point, perl has a "gensym"
10:20:23 <n0den1te> Philippa: :-)
10:20:23 <mreh> can perl ever be right?
10:20:31 <Saizan> mreh: nothing obviously wrong there
10:20:31 <ddarius> Twey: CLOS isn't really that interesting and isn't really that OO, I'm more referring to the (runtime) metaprogramming aspects.
10:20:33 <kuffaar> Silvah: There is no formal definition of what constitues a "Lisp" so people randomly throw that statement around about all kinds of dynamically typed languages
10:20:44 <companion_cube> but perl's approch to syntax is exactly opposite to lisp one
10:20:54 <mauke> jacobian: so the only thing that makes lisp cool is ))))))))))) and macros?
10:20:55 <companion_cube> i.e. ad-hoc syntax everywhere vs no syntax
10:21:02 <companion_cube> macros are cool
10:21:11 <kuffaar> Although typing in Perl is uh different
10:21:11 <mauke> companion_cube: yes, but not cool enough
10:21:15 <jacobian> mauke: Macros are probably the most interesting thing about lisp
10:21:17 <mreh> Saizan: uhuh, I done a cabal check and everything!
10:21:19 <ddarius> Perl is not any language minus something.
10:21:29 <jacobian> Having a convenient method of introspection and facilities for manipulating it. 
10:21:32 <Philippa> companion_cube: no such thing as no syntax
10:21:33 <ddarius> Most people argue that every other language is Perl minus something.  Usually bad somethings.
10:21:46 <Philippa> like the kitchen sink
10:21:47 <Saizan> mreh: check if pandoc and/or haxml produce the multiple exes for you
10:21:48 <n0den1te> I don't know if I like perl, but my fingers love it! Weird. :|
10:21:52 <Philippa> or a primed landmine
10:21:57 <companion_cube> Philippa, ok, let us say "minimal syntax"
10:21:59 <kuffaar> I have no idea why people freak out about parentheses all the time, it seems like such a minor thing once you have actually written a bit of Lisp in an editor which automatically manages the indentation for you to make the structure of the code clear
10:22:00 <mauke> ddarius: I'd argue that those people don't know Perl
10:22:10 <Twey> ddarius: Not that OO?  Want to expand on that?
10:22:16 <jacobian> common lisp syntax is actually fairly arcane
10:22:20 <mauke> kuffaar: if I wanted to use indentation to make the structure clear, I'd use Haskell
10:22:36 <ddarius> jacobian: Indeed. Both at the lexical and at the grammatical level.
10:22:36 <jacobian> #:confused 
10:22:44 <Philippa> minimal syntax is unary or binary encoded goedel numbering or similar
10:22:46 <gwern> mauke: just hack the reader macro and do that
10:22:52 <mauke> gwern: :-)
10:22:54 <Philippa> it's not a useful idea per se
10:22:58 <jacobian> haha
10:22:59 <gwern> HACK THE READER MONAD
10:23:01 <mauke> gwern: I actually wrote something like $ in lisp
10:23:08 <spetrea> anyone here implemented naive bayes , I've some questions about the efficiency 
10:23:12 <hpc> mauke: same here!
10:23:12 <mauke> it makes for terrible code
10:23:26 <mreh> spectrea: yes, wrong channel, but yes go on
10:23:26 <Philippa> someone's built a flat combinator calculus btw - one where you never need parens for anything
10:23:30 <n0den1te> kuffaar: It's not about parens that people are freaked out about. I have heard many sayd that lisp is a pleasure to work with in emacs. I can't vouch for it since I don't use emacs. 
10:23:32 <mreh> it interest me
10:23:32 <ddarius> Twey: It's basically just a huge event piping mechanism.
10:23:39 <jacobian> I wrote in lisp for quite a long time, and enjoyed it.  I'm not a fan of CLOS though
10:23:47 <mauke> http://mauke.dyndns.org/stuff/lisp/add-x.lisp
10:23:47 <ddarius> @google floy joy
10:23:48 <lambdabot> http://en.wikipedia.org/wiki/Floy_Joy
10:23:48 <lambdabot> Title: Floy Joy - Wikipedia, the free encyclopedia
10:23:49 <hpc> sub apply { my ($func, @args) = @_; sub {$func->(@args);};}
10:23:53 * Silvah is afraid of lisp.
10:23:57 <hpc> mauke: ^ for callbacks
10:23:57 <n0den1te> kuffaar: I'm guessing it's more a case of bad/weak tools and IDEs. 
10:23:59 <kuffaar> n0den1te: Yeah, I started using emacs when I started doing as bit of Common Lisp and it's very comfortable really
10:24:05 <Eduard_Munteanu> Are you guys talking about reinventing Brainfuck?
10:24:06 <mauke> hpc: uh, what?
10:24:18 * ddarius doesn't see why Silvah would be, unless Silvah saw Lisp kill mauke's parents.
10:24:20 <hpc> mauke: oh, read "lisp" as "perl"
10:24:24 <hpc> <.<
10:24:25 <Silvah> Brainfuck is a lisp.
10:24:25 <hpc> >.>
10:24:30 <aristid> Eduard_Munteanu: brainfuck has parentheses (which happen to be loops)
10:24:43 <mreh> common lisp isn't a lisp
10:24:49 <n0den1te> Brainfcuk? +++)))----- Uh, what?
10:24:51 <n0den1te> :P
10:24:52 <mauke> hpc: too many ; for my taste
10:25:02 * ddarius was apparently quite right to be surprised at a wikipedia page for floy.
10:25:13 <hpc> @_; is going to always be a smiley too me
10:25:14 <lambdabot> Maybe you meant: . ? @ bf do ft id pl rc v wn
10:25:20 <hpc> no matter how much perl i write
10:25:20 <mauke> hpc: http://blogs.perl.org/users/mauke/2010/05/no-semicolon-after-return-values.html
10:25:20 <n0den1te> You guys must be reinventing whitespace, not brainfuck. :D
10:25:38 <kuffaar> hpc: [shiner][sad mouth][crying eye]?
10:26:17 <Silvah> Yeah, whitespace, whenever, C++ and all the other esoteric languages are lisps, aren't they?
10:26:18 <hpc> kuffaar: more like a strange wink
10:26:33 <n0den1te> hpc: that's a drooling guy. Dunno, that's what pops up when I type it. :)
10:26:37 <hpc> mauke: nifty
10:26:37 <companion_cube> unlambda \o/
10:26:37 <mreh> Saizan: yeah, HaXml installs annoyingly
10:26:46 <poincare101> what's lambdabot written in?
10:26:50 <poincare101> lambdabot: source
10:26:53 <mreh> well, i'll check the cabal file
10:27:03 <hpc> poincare101: lambdabot is written in ASCII
10:27:08 <n0den1te> lambdabot: lambdabot hey!
10:27:12 <hpc> possibly UTF-8
10:27:17 * hpc unhelps
10:27:20 <poincare101> hpc: lol. what language?
10:27:20 <Eduard_Munteanu> @vixen say hi to n0den1te 
10:27:21 <lambdabot> hello there
10:27:27 <mreh> @src lambdabot
10:27:27 <lambdabot> Source not found. Maybe you made a typo?
10:27:32 <merijn> poincare101: In all seriousness it is obviously written in Haskell
10:27:33 <hpc> poincare101: see the channel name ;)
10:27:35 <companion_cube> is there any esoteric language designed around concurrency ? (for instance based on pi-calculus)
10:27:49 <poincare101> merijn: you never know. the ##c's bot is written in Perl :P
10:27:56 <n0den1te> lambdabot's a vixen???!??
10:27:57 <ddarius> There's Pict, but it's not an esoteric language.
10:27:57 <Eduard_Munteanu> Hah
10:28:04 <Twey> @vixen Are you a vixen?
10:28:05 <lambdabot> i'm a vixen through and through :)
10:28:12 <Eduard_Munteanu> @vixen Tell n0den1te you're a bad girl!
10:28:13 <lambdabot> i'm bad in a good way?
10:28:16 <n0den1te> @vixen what's a vixen? 
10:28:16 <lambdabot> all women have a little vixen in them... just some more than others
10:28:22 <ddarius> poincare101: Indeed. geordi in the C++ channel is written in Haskell.
10:28:26 <Silvah> hah
10:28:30 <kuffaar> poincare101: Yeah, he was scared of accidentally implement remote exploits in the bot
10:28:31 <Twey> Heheh
10:28:38 <n0den1te> @vixen good bad vixen, huh?
10:28:38 <lambdabot> am i not making sense?
10:28:49 <kuffaar> implementing* rather
10:28:51 <n0den1te> funny lambdas! 
10:28:58 <hpc> also, the perl 6 prototype interpreter was made in haskell
10:29:07 <kuffaar> hpc haha wtf.
10:29:07 <Eduard_Munteanu> LOL
10:29:08 <n0den1te> yeah, pugs. 
10:29:10 <mauke> the other bot here is also written in haskell
10:29:13 <kuffaar> Never heard of that before
10:29:15 <hpc> my guess, because not even perl can parse itself anymore
10:29:15 <mreh> prototype?
10:29:19 <kuffaar> preflex?
10:29:20 <mreh> i bet it worked great
10:29:23 <Silvah> Why not in Scheme?
10:29:29 <n0den1te> @google pugs
10:29:30 <lambdabot> http://www.pugs.com/
10:29:31 <lambdabot> Title: PugsCom: You are using an invalid IP
10:29:38 <n0den1te> @google pugscode
10:29:39 <lambdabot> http://www.pugscode.org/
10:29:39 <lambdabot> Title: Pugs - pugscode
10:29:40 <mauke> kuffaar: yes
10:29:46 <n0den1te> kuffaar: ^^
10:29:48 <hpc> mreh: perl 6 is standardized by the prototype interpreter, then subsequent interpreters made from the standard
10:30:01 <hpc> because how else could you make something like perl!
10:30:34 <kuffaar> "Haskell's static typing can make it easier for program bugs to be detected at compile time. Haskell code is also often thought to be concise. "
10:30:40 <kuffaar> http://en.wikipedia.org/wiki/Pugs#Development_model
10:31:11 <ski> @version
10:31:12 <lambdabot> lambdabot 4.2.2.1
10:31:12 <lambdabot> darcs get http://code.haskell.org/lambdabot
10:31:19 <mauke> preflex: version
10:31:19 <preflex>  7.616
10:31:28 <mauke> CLEARLY SUPERIOR
10:31:47 <n0den1te> kuffaar: yes, audreyt was responsible for much of pugs. Sadly, pugs is not actively developed anymore. However, maintenance releases are done with every ghc release. 
10:32:07 <parcs> how would i initiate a terminal-based password prompt? that is, a prompt that either hides all inputted passwords or replaces them with asterisks. (i have no idea how to do this even outside of haskell)
10:32:14 <Silvah> mauke: lol
10:32:21 <parcs> s/passwords/input
10:32:26 <mauke> preflex: help version
10:32:27 <preflex>  version - print a random number
10:32:35 <Philippa> parcs: depends on the OS
10:32:37 <n0den1te> mauke: lol
10:32:42 <parcs> Philippa: a unix-based OS
10:32:46 <Philippa> parcs: or other platform you're writing on top of
10:32:48 <aristid> !cal 7.616/2
10:32:52 <Silvah> preflex: version
10:32:52 <preflex>  6.532
10:32:53 <Philippa> 'k, I'll let the POSIX crowd take the rest :-)
10:32:59 <aristid> > 7.616/2
10:33:00 <lambdabot>   3.808
10:33:06 <Eduard_Munteanu> parcs: generally you can turn off terminal echoing
10:33:21 <Philippa> (but the main thing you need if you can't find a pre-canned func is one that'll read a character without printing anything)
10:33:21 <Eduard_Munteanu> And do your own echoing.
10:33:24 <Saizan> ?hoogle hSetEcho
10:33:24 <lambdabot> System.IO hSetEcho :: Handle -> Bool -> IO ()
10:33:34 <parcs> ah, thanks
10:33:50 <Saizan> (maybe? never used it)
10:34:06 * Silvah wonders whether it really works on Windows.
10:34:26 <parcs> yeah, i just tried it in ghci. that is indeed what i want
10:34:29 <Eduard_Munteanu> GHC might abstract the bits behind it
10:34:52 * ski would probably try to make `echo :: IO a -> IO a' and `noEcho :: IO a -> IO a' that behaved similarly as `block' and `unblock' wrt atomicity
10:34:55 <hpc> parcs: there's more to it if you want to do a password prompt; you might also want to flush stdin
10:35:21 <mauke> hpc: wat
10:35:24 <hpc> so if someone say, pastes many lines
10:35:35 <hpc> the extra lines don't become password input
10:35:51 <Silvah> I know it might, but it's the first time I see such function in a standard library, there has to be a fly in the ointment.
10:35:51 <hpc> i think that's how to stop that problem
10:35:59 <Ilum> Where could I find the source code for the Data.List module?
10:36:00 <augustss> > approxRational 12.55 0.1
10:36:01 <lambdabot>   25 % 2
10:36:11 <mauke> Ilum: internet
10:36:15 <ski> @source Data.List
10:36:15 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
10:36:26 <Eduard_Munteanu> @google data list hackage
10:36:27 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
10:36:27 <lambdabot> Title: HackageDB: packages by category
10:36:35 <Silvah> > approxRational 6.9 2.0
10:36:35 <lambdabot>   5 % 1
10:36:41 <augustss> > approxRational 12.56 0.1
10:36:42 <lambdabot>   25 % 2
10:36:46 <Eduard_Munteanu> Erm, not that, but that's what I generally do.
10:37:03 <ski> > approxRational 0 0
10:37:04 <augustss> > approxRational 12.55 0.05
10:37:04 <lambdabot>   0 % 1
10:37:05 <lambdabot>   25 % 2
10:37:25 <augustss> > approxRational 12.65 0.05
10:37:26 <lambdabot>   38 % 3
10:39:18 <j-invariant> > gcd 4 0
10:39:19 <lambdabot>   4
10:39:36 <Silvah> > gcd 0 0
10:39:37 <lambdabot>   *Exception: Prelude.gcd: gcd 0 0 is undefined
10:39:58 <Silvah> :(
10:40:38 <augustss> Yeah :(
10:41:08 <Silvah> Exceptions are evil.
10:41:54 <augustss> Specially since there's a reasonable value that could be returned for gcd 0 0
10:43:03 <Silvah> At least I was told so; why they're evil, anyway? Is it because they can be raised anyware, but handled only in the dreaded IO monad?
10:43:14 <Silvah> anywhere*
10:43:53 <monochrom> "exception is evil" is evil
10:44:50 <augustss> Non-local control flow is difficult to understand and reason about.
10:45:56 <ddarius> Error good, catch evil.
10:46:19 <mreh> what about MonadError?
10:46:34 <augustss> Furthermore, exception handling uses the dynamic call stack rather than static scoping, so it's impossible to statically predict where an exception will be caught.
10:46:44 <merijn> Silvah: No, because exceptions are pretty much goto's
10:47:01 <ion> Tail recursion is pretty much goto. :-P
10:47:02 <mreh> I've got build depends in each of my executable definitions
10:47:06 <mreh> is that right?
10:47:08 <merijn> i.e. one piece of code basically goto's to the exception handler, making it hard t keep track of what's happening
10:47:17 <j-invariant> a GOTO is a GOTO is a GOTO is a GOTO
10:47:27 <Silvah> Functions are also pretty much goto.
10:47:34 <augustss> merijn: it's goto, but you don't know where you are jumping.
10:47:57 <merijn> augustss: That was exactly what I was trying to say :p
10:48:07 <ion> > fix ("a GOTO is "++)
10:48:10 <lambdabot>   "a GOTO is a GOTO is a GOTO is a GOTO is a GOTO is a GOTO is a GOTO is a GO...
10:48:11 <ddarius> j-invariant: is a wombat
10:48:13 <companion_cube> :D
10:48:17 <monochrom> you may as well say you do not know where the pure function returns to.
10:48:18 <companion_cube> :t fix
10:48:19 <lambdabot> forall a. (a -> a) -> a
10:48:43 <Silvah> But this is really what exceptions are about.
10:48:51 <merijn> I wonder if thre's an "A monad is like a goto" tutorial
10:48:53 <j-invariant> says the platypus
10:48:57 <merijn> Silvah: Hence why they are evil
10:49:01 <ion> merijn: Hehe
10:49:37 <merijn> I avoid exceptions even in languages that normally use them a lot (Hi Java!)
10:49:46 <Silvah> merijn: so why they're not evil in most imperative languages?
10:49:51 <kuffaar> merijn good luck with that :p
10:49:54 <merijn> Silvah: They are
10:50:08 <kuffaar> Stop saying evil all the time, you lot start sounding like Christian fundies on the telly!
10:50:09 <merijn> I avoid exceptions in Java/C++/Python whenever possible
10:50:27 <ion> Saying evil so much is evil?
10:50:28 <j-invariant> kuffaar++
10:50:28 <kuffaar> merijn: I bet you love the InterruptedException :)
10:50:36 <merijn> I'm a lambda calculus fundamentalist. All non-believers shall burn in righteous fire!
10:50:40 <mreh> SecondComingException
10:50:46 <Silvah> kuffaar: is "ungood" less evil?
10:50:48 <kenny```> merijn: why would you do that?
10:50:53 <j-invariant> @goggle Churth of the LAnmbda Claulculs
10:50:53 <ion> doubleplus ungood
10:50:54 <lambdabot> No Result Found.
10:50:59 <merijn> There is no god but the lambda calculus and Church is its prophet :>
10:51:10 <Rotaerk> I'm not sure pure-lambda-calculus-based environment is ideal for programming
10:51:13 <kuffaar> Haskell shahada?
10:51:21 <n0den1te> merijn: I think you'd love  IllegalStateException.  Just saying'
10:51:23 <j-invariant> Rotaerk: its turing complete what more do you want
10:51:30 <mreh> is it?
10:51:33 <merijn> kenny```: Avoid exceptions, you mean?
10:51:39 <kenny```> indeed
10:51:46 <jacobian> The problem I have is that you're lifting your computation to a new domain but it's hard to see. 
10:52:00 <jacobian> The reason I think they are used is because it doesn't require going through and changing a lot of code. 
10:52:06 <merijn> kenny```: Because they obscure control flow and make my code harder to understand
10:52:13 <Rotaerk> C is a very simple language, but C++ (ignoring how utterly overcomplicated its syntax is) is more usable because it introduces higher level language features that would otherwise have to be implemented manually in C
10:52:15 <jacobian> What's needed I think is a way to deal with both of those simultaneously. 
10:52:29 <n0den1te> merijn: avoid exceptions? Avoid as in avoid writing try..catch blocks or avoid exception throwing behaviour entirely?
10:52:35 <mreh> Rotaerk: are you aware of the blub paradox?
10:52:42 <merijn> n0den1te: Both
10:52:51 <jacobian> Allow the lifting of a function into a new codomain which doesn't end up breaking a lot of the callers. - Hence write in a monadic style. 
10:52:59 <Silvah> Rotaerk: C is not esoteric, C++ is.
10:53:03 <Rotaerk> I'm not particularly experienced with FP, but I imagine there are higher level constructs which might be ideally supported as a language feature rather than reinvented in a low level system that only supports lambda calculus
10:53:03 <mauke> Rotaerk: I will kill you to death
10:53:09 <merijn> mreh: Aren't most people in #haskell above the blub line? :p
10:53:23 <mauke> merijn: no such thing
10:53:28 <Rotaerk> mreh, no
10:53:29 <mreh> merijn: no, it's relative to you
10:53:37 <Rotaerk> Silvah, not sure what you mean by "esoteric"
10:53:49 <mreh> I look at Coq and think "?$&*"£!"
10:53:50 <n0den1te> merijn: whenever I code in java, I find myself writing try..catch blocks like I'm paranoid about incoming data. Bleh, I don't even know where I'd get that NPE. NPEs, damn NPEs, of all things! :/
10:54:08 <Rotaerk> mauke, doesn't mean I'm a fan of either C or C++, it was just an analogy
10:54:11 <ski> Silvah : `gcd 0 0' should be `0', of course ..
10:54:22 <Silvah> Rotaerk: esoteric as in brainfuck or unlambda.
10:54:23 <j-invariant> ski: 0|0 ?
10:54:28 <merijn> mreh: With Coq I just think ugly syntax. I've reached the point where I'm starting to grok Agda. Epigram is still a mystery to me :p
10:54:34 <ski> j-invariant : yes
10:54:46 <Rotaerk> Silvah, still not clear on what you're trying to say about it; esoteric makes me think "rarely used"
10:54:51 <mauke> Rotaerk: I'd rather write in Common Lisp than C++
10:54:54 <Rotaerk> which is of course not the case with C++
10:54:56 <ski> j-invariant : `forall d,n. d | n <=> exists k. k*d = n'
10:54:59 <jacobian> Coq and agda are awesmoe
10:55:00 <Rotaerk> mauke, me too
10:55:08 <mauke> C is ok, though
10:55:13 <Rotaerk> I couldn't use C
10:55:16 <ddarius> n0den1te: You can blame Tony.
10:55:19 <Rotaerk> even less than C++
10:55:26 <mreh> Rotaerk: the blub programmer looks down at C and says, it doesn't even have <blub-feature>, but when he looks up the scale he just sees weird language
10:55:29 <mreh> s
10:55:33 <ski> (j-invariant : and "greatest" in "greatest common divisor" obviously refers to the divisibility ordering ..)
10:55:39 <merijn> Rotaerk: The goal is to be able to extend the language from within the language, you say "it would be more convenient to support them as language features" but what if you could implement the language features in the language? I mean, that's essentially what Lisp does. Most of it is already written in Lisp
10:55:55 <merijn> mreh: I kinda like C actually :>
10:56:01 <j-invariant> ski: how is 0 greatest??
10:56:06 <n0den1te> merijn: avoiding exception throwing behaviour is actually nice. But you're dealing with data and other people's code. Both unknown variables at runtime. :/
10:56:15 <mreh> C is great, in certain circumstances
10:56:16 <monochrom> 0 is the greatest number ever
10:56:21 <merijn> I just wish it had sane namespacing and had global variables default to static
10:56:26 <ski> j-invariant : so `forall a,b,d. d | gcd(a,b) <=> d | a /\ d | b' is the characterizing property of `gcd'
10:56:40 <merijn> n0den1te: You can always return an error instead of throw an exception
10:56:41 <ski> j-invariant : `forall a. a | 0', hence `0' is greatest
10:56:58 <n0den1te> ddarius: Tony Stark? :P
10:56:59 <Silvah> > all (< 0) [1..]
10:57:00 <lambdabot>   False
10:57:01 <j-invariant> ski: 2|0?
10:57:15 <ski> j-invariant : yes, since there exists a `k' such that `k * 2 = 0'
10:57:24 <jacobian> > all (> 0) [1..]
10:57:25 <Rotaerk> merijn, that does seem ideal; though I wonder if there isn't anything that might be less cumbersome with a built-in extra feature
10:57:28 <lambdabot>   mueval-core: Time limit exceeded
10:57:41 <n0den1te> merijn: Sure, but returning error for internal data issues or crappy code by others is not an option. 
10:57:59 <merijn> n0den1te: Why not?
10:58:06 <mreh> 6|0
10:58:10 <n0den1te> merijn: returning error codes/messages for user problems is fine, though. 
10:58:12 <Silvah> :t (<3)
10:58:13 <lambdabot> forall a. (Num a, Ord a) => a -> Bool
10:58:16 <mreh> raised eyebrow
10:58:32 <merijn> Rotaerk: That just means you need better support for implementing/modifying syntax at runtime
10:59:00 <Rotaerk> at runtime?
10:59:25 <n0den1te> merijn: Oh, and if I return errors all the time, most of other devs would only wind up poring over stacktraces all day. :P
10:59:44 <n0den1te> (way too many to count)
10:59:53 <ddarius> n0den1te: There is only one Tony, that can unambiguously referred to as "Tony" in computer science.
10:59:58 <merijn> Rotaerk: Eh, not at runtime. (Although, why not!)
11:00:03 <Rotaerk> :P
11:00:05 <spetrea> kuffaar: code that has side effects ? I thought the whole idea of Haskell was to not have side effects ?
11:00:07 <ski> @let infixl 7 `mod_`; n `mod_` 0 = n; n `mod_` d = n `mod` d
11:00:08 <ski> @let d `divides` n = n `mod_` d == 0
11:00:09 <lambdabot>  Defined.
11:00:10 <lambdabot>  Defined.
11:00:17 <monochrom> is that Sir Tony?
11:00:28 <ski> > > 4 `divides` 0
11:00:29 <lambdabot>   <no location info>: parse error on input `>'
11:00:30 <ski> > 4 `divides` 0
11:00:32 <lambdabot>   True
11:00:32 <ddarius> monochrom: Na klar!
11:00:33 <ski> > 0 `divides` 0
11:00:35 <lambdabot>   True
11:00:47 <monochrom> what is Na klar?
11:01:19 <revenantphx> So... is you have some type A and some type B with the set of all of their possible values being 'a' and 'b' respectively,
11:01:35 <revenantphx> then the set of all possible values for a tuple (A,B), the product of 'a' and 'b'?
11:01:51 <revenantphx> Sounds right to me?...
11:02:04 <monochrom> not so simple in a non-strict language
11:02:12 <ski> (j-invariant : iirc, you know some CT ? .. then you should be able to recognize the characterizing property of `gcd' above as an adjunction / galois connection)
11:02:26 <revenantphx> Well I was thinking in a strict language, where each type has only so many states.
11:02:27 <monochrom> oh actually not as hard to describe as strict languages
11:02:46 <revenantphx> say A is a bool, and B is a ternary bool type thing.
11:02:47 <monochrom> product of 'a' and 'b', then add a new bottom.
11:02:57 <revenantphx> (true, false) X (a, b, c)
11:03:00 <revenantphx> new bottom?
11:03:23 <ddarius> Products are products in a lazy language.
11:03:26 <n0den1te> ddarius: lol, you can tell me. I ended up looking at "Tony the computer guy" Facebook page. 
11:03:43 <ddarius> @google "Sir Tony" computer science
11:03:45 <lambdabot> http://www.simple-talk.com/opinion/geek-of-the-week/sir-tony-hoare-geek-of-the-week/
11:04:04 <kuffaar> <spetrea> kuffaar: code that has side effects ? I thought the whole idea of Haskell was to not have side effects ?
11:04:05 <ski> > let domain :: (Bounded a,Enum a) => [a]; domain = [minBound .. maxBound] in liftM2 (,) domain domain :: [(Bool,Ordering)]
11:04:06 <monochrom> the type ((),()) has values ⊥ of ((),()), (⊥ of (), ⊥ of ()), (⊥ of (), ()), ((), ⊥ of ()), ((),())
11:04:06 <lambdabot>   [(False,LT),(False,EQ),(False,GT),(True,LT),(True,EQ),(True,GT)]
11:04:07 <n0den1te> ddarius: that's what I thought initially. but didn't get the reference to NPEs. :)
11:04:35 <kuffaar> spetrea: Well, you try to keep your functions pure but ultimately you will have to perform some IO to do something interesting
11:04:47 <glguy> Anyone know a quick way to read Java encoded Doubles and Floats off a network socket?
11:05:26 <kuffaar> You can do a lot of stuff in pure functions but anything that deals with console IO, file IO, network IO etc will require the IO monad to be present at the bottom of the stack of monads in the signature of the function
11:06:31 <ddarius> @google tony hoare billion dollar mistake
11:06:34 <lambdabot> http://qconlondon.com/london-2009/presentation/Null+References:+The+Billion+Dollar+Mistake
11:06:34 <lambdabot> Title: Speakers -> Null References: The Billion Dollar Mistake
11:07:12 <olsner> glguy: binary might do that... I'm just guessing, but I'd expect java to use a common big-endian format for floats, probably IEEE-754
11:07:27 <glguy> olsner Data.Binary uses a custom encoding
11:08:17 <n0den1te> ddarius: ah, that's new to me. Next time, I'll invoke Hoare for NPE rants. ;)
11:09:25 <ddarius> To lift some weight off of Tony's shoulders, plenty of people could have fixed this (and did) in the intervening 45 years.  Though I have to say, "if Tony did it, it must be a good idea" is a compelling argument.
11:09:27 <olsner> glguy: http://hackage.haskell.org/package/data-binary-ieee754 then? :)
11:09:59 <glguy> olsner: That looks quite promising!
11:10:00 <glguy> thank you
11:12:36 <j-invariant> does anyone have GCD algorihtm for gaussian integers in haskell
11:13:03 <ddarius> @google missing spectral basis
11:13:04 <lambdabot> http://www.garretstar.com/secciones/publications/docs/monthly336-346.pdf
11:13:04 <lambdabot> Title: The Missing Spectral Basis in Algebra and Number Theory
11:13:50 <n0den1te> ddarius: talking of fixing NPEs, these guys did something with Java in JRebel. http://dow.ngra.de/2009/02/01/correcting-the-billion-dollar-mistake/
11:14:19 <ddarius> n0den1te: My solution to fixing NPEs in Java is not to use Java.
11:14:32 <kuffaar> NPE = ?
11:14:41 <n0den1te> NullPointerException
11:14:43 <ulfdoz> NullPointerException.
11:15:13 <n0den1te> ddarius: lol, right. :)
11:15:48 <kuffaar> Having a system like that in Haskell would be rather problematic, and you'd have to account for the null pointer case anyways
11:16:03 <kuffaar> It's basically like wrapping every single type in a Maybe
11:16:24 <kuffaar> And the null would correspond to a Nothing, the absence of a meaningful value? :p
11:16:37 <ulfdoz> kuffaar: No, it is worse. ;) The type of null is not constrained.
11:17:59 <olsner> hmm, isn't undefined pretty much a null value that exists for every type?
11:18:12 <ulfdoz> however, catching NPE seems rather pointless. Either the function accepts null or not. If it does not, then an illegal argument was passed and an NPE is quite ok, to indicate the fail.
11:18:23 <ddarius> Jevgeni is incorrect that this "exactly captures the semantics of the Maybe type" unless you can say something like @Optional @Optional
11:18:32 <ski> olsner : except you can't check for it (in "pure" code, at least)
11:19:21 <ddarius> olsner: People don't pass undefined to mean "optional" or "nothing" because there would be no way for the function to check that and do something different in that case.
11:19:39 <olsner> ski: right, forgot about that part :/
11:20:03 * ski is reminded of `NULL's in SQL ..
11:20:34 <n0den1te> ulfdoz: people don't walk around with a marker board saying "I'm null!". Again, just like people, they just carelessly walk into live pits! Now, talk about NPEs. :)
11:21:15 <ulfdoz> n0den1te: It is a bug, it should be fixed, not worked around.
11:21:44 <ddarius> n0den1te: In C# there are "value types" declared using struct that can't be null.
11:22:09 <ddarius> ulfdoz: Indeed.
11:22:17 <ddarius> Variables also shouldn't be mutable by default.
11:22:29 <ddarius> That would fix many OOP inheritance examples.
11:22:48 <n0den1te> ulfdoz: allowing nulls to be matched with no type is a bug in java, yes. Catching them and passing over them is another bigger evil, especially when you're handling live data. 
11:22:51 <ulfdoz> I indeed use finally very extensively.
11:22:57 <ulfdoz> s/finally/final/
11:23:15 <n0den1te> ddarius: I don't do C#. So I don't know. 
11:23:15 <ulfdoz> finally is another thing to doubt about. Handy, but sometimes ill.
11:23:32 <ddarius> n0den1te: C# is Java, only way, way better.
11:23:37 <hpc> ulfdoz: it's homeopathy for the exception flu?
11:23:40 <n0den1te> ddarius: so I have heard. 
11:24:11 <n0den1te> hpc: lol.
11:24:42 <merijn> ddarius: s/way, way better./slightly less bad./
11:24:44 <hpc> (i don't see the value of "finally" but i don't hack around exceptions much; they confuse me)
11:24:53 <n0den1te> ulfdoz: finally is very useful, actually and it's easy to abuse it too. :/
11:24:55 <ddarius> merijn: No, it's significantly better.
11:25:03 <ulfdoz> hpc: "yes". On the other hand, there are imho sane usecases, e.g. unlocking. However, it is a damn bad idea, to eventually throw an exception from a finally block. ;)
11:25:07 <ddarius> merijn: It's still way, way worse than Haskell say.
11:25:10 <merijn> Everything still needs to be inside a class :<
11:25:18 <n0den1te> ddarius,merijn: playing with words, hmmm.... 
11:25:28 <ddarius> merijn: With extension methods you can lessen that.
11:25:36 <ddarius> Though, I really hate extension method abuse.
11:25:48 <hpc> yay undefined behavior
11:26:26 <ddarius> merijn: You can also just do, Func<int, string> f = i => i.toString(); 
11:27:09 <n0den1te> ulfdoz: for instance, finally is very useful when you're coding to a resource handler. For example, handling database connection pools and you don't want them exhausted at any point of time. YOu could insert a finally block to do connectionPool.close();. I have often used it in the form of a loan pattern. 
11:27:54 <n0den1te> ulfdoz: but littering every one of your try..catch blocks with finally is... just... bad
11:28:38 <n0den1te> merijn: meri jaan? ;)
11:28:48 <merijn> And that means?
11:29:32 <n0den1te> merijn: my life or my love in Hindi, spoken in India. 
11:30:09 <merijn> Learn something new every day...
11:30:39 <n0den1te> :-)
11:30:56 <ulfdoz> n0den1te: I tend to do that the other way round. I often have methods like connectionPool.release(Connection). The point with that is, that you cannot handle the SQLException in a sane way from the finally block, but the connection pool tends to be able to do that and suppress the actual exception with a proper handling.
11:30:56 * ddarius use to learn something new every day, then he decided to designate a day of the week and do all his novel learning then.
11:31:59 <djahandarie> Hmm that sounds like a good idea
11:32:10 <n0den1te> ulfdoz: dear God, we're sinking into a deep, black hole with exceptions. :/
11:32:33 <n0den1te> ulfdoz: I don't know if you're more paranoid than I am or the other way around. 
11:33:31 <ulfdoz> n0den1te: A good API is harder to abuse, than to use correctly.
11:34:05 <n0den1te> ulfdoz: *nod*
11:34:07 * ddarius would recommend rewording that as "A good API encourages correct use."
11:34:47 <ddarius> Or "makes correct use easier than incorrect use."
11:37:09 <n0den1te> ddarius: that reminds me of asInstanceOf[] in Scala. 
11:37:41 <n0den1te> casting types is actively discouraged in Scala and it was deliberately made more messy to code that anyway. =)
11:38:00 <ulfdoz> ddarius: Would be nice, if it would be that easy. Unfortunately, colleagues sometimes cannot be encouraged.
11:39:02 <ddarius> ulfdoz: I find liberal application of a bat to be quite effective at encouraging any desired behavior.
11:39:35 <ulfdoz> ddarius: hmkay, that is a valid rewording, of what I'm doing in my libs.
11:41:12 <ulfdoz> I had a case, where someone passed a tcp-socket for an udp-socket. uh, that broke stuff heavily, because suddenly read() did not return full datagrams.
11:41:29 <j-invariant> I cant write the algorithm in haskell its making me sick
11:41:32 <n0den1te> what? don't they read docs?
11:41:43 <n0den1te> ulfdoz: ^^
11:41:47 <ddarius> Why is a TCP socket the same type as a UDP socket?
11:41:49 <ulfdoz> n0den1te: No, they didn't.
11:42:02 <n0den1te> ulfdoz: sad, very sad. :(
11:42:21 <ulfdoz> ddarius: My fault, I declared it that way, but the class was named UDPMessageParser.
11:42:47 <ddarius> The U is clearly "Universal"
11:43:09 <ulfdoz> i than took the bad and did sed -ie 's/Channel/UdpChanne/g' UDPMessageParser.java.
11:43:15 <ulfdoz> s/bad/bat/
11:43:43 <listdata> could someone tell me what I'm doing wrong? (case expression doesn't work, but using guards does work) http://hpaste.org/43254/case_expression_vs_guards
11:44:50 <j-invariant> haskell makes me want to sthrow up
11:45:21 <c_wraith> listdata: You can't pattern-match against expressions..  Only constructors
11:46:26 <listdata> c_wraith: hmm, ok..
11:46:38 <c_wraith> :t find
11:46:39 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
11:46:44 <c_wraith> :t index
11:46:46 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Int
11:46:49 <copumpkin> j-invariant: sthrow?
11:46:55 <quuuux> :t elemIndex
11:46:56 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
11:47:02 <c_wraith> yes, that's the one I wanted
11:47:05 <ddarius> copumpkin: How have the operas been so far?
11:47:14 <copumpkin> ddarius: I'm all done with them, and they were amazing
11:47:17 <listdata> c_wraith: ahhhh, ok I think I get what you're saying
11:47:24 <n0den1te> ulfdoz: java programmers diving into coding without keeping any javadocs open for reference are stereotypical of a mad bull charging into the arena. But hey, that's what they do! :)
11:47:24 <copumpkin> very unconventional productions, some of them :)
11:47:37 <ddarius> copumpkin: They were in Italian, no?
11:47:42 <copumpkin> yep
11:47:46 <listdata> c_wraith: yeah I had a hunch that it had something to do with the elemIndex function
11:47:55 <listdata> c_wraith: thanks c_wraith!!
11:48:10 <ulfdoz> n0den1te: Coding Guidline says "Every non-private member must be documented."
11:48:11 <copumpkin> ddarius: oh, how should I get the booze to you?
11:48:51 <ulfdoz> n0den1te: That is verified with checkstyle, once a day, and the documentation is not that bad in all cases, but sometimes, the greatest waste of time is, to write it.
11:49:16 * copumpkin is enabling ddarius's alcoholism, for anyone listening in and wondering
11:49:33 <ski> j-invariant : euclidean algorithm ?
11:49:34 <n0den1te> ulfdoz: why not just write docs, side by side? We all do Junit test cases to fail first. Why not javadocs too?
11:50:23 <ddarius> n0den1te: Writing docs first is an often recommended practice.
11:50:24 <n0den1te> s/We all/Most of us/
11:50:35 <ddarius> s/Most of us/None of us/
11:50:57 <n0den1te> /us/&1 java programmers/
11:51:26 <c_wraith> I often write docs to figure out what the hell I'm thinking.
11:51:27 <ulfdoz> n0den1te: Writing docs first, does not work for me. I usually get unsatisfying results. I start designing interfaces, documenting a concept, implementing the concept and than documenting the details (null-args, exceptions, usage pattern, guarantees etc. pp.)
11:51:45 <j-invariant> ski: I have got it now
11:52:18 <ddarius> copumpkin: Well, I have no food or drink in my apartment currently, so we could find a new and exciting restaurant near where you live and drink alcohol before or, more likely, after.
11:52:27 <j-invariant> here is http://hpaste.org/43255/gaussian_gcd_algorithm code for anyone who likes to calculate GCD in Gaussian integers
11:53:24 * ddarius personally wouldn't recommend putting too much effort into writing documentation beforehand or even during.  Some effort, but not a whole lot.
11:53:36 <n0den1te> ulfdoz: yes, that's true here too. When I don't have a particularly good idea about how the code should be written or any error scenarios, then I'd just code them through with a running commentary or notes in a separate notepad. Finally, do a dump of them into the javadocs. Ta da!
11:54:55 <ddarius> Actually attempting to implement something (or prove something) clarifies your understanding significantly and leads to better documentation (and also is less likely to be out of date/incorrect.)
11:55:48 <ski> j-invariant : hm, i would at least have defined a new type `Gaussian' ..
11:55:56 <n0den1te> ddarius: That's correct. That's why I have a sort of a running commentary going in a separate editor window so I don't have to type them all out when i'm done coding. 
11:56:22 <n0den1te> <just paste and snip>
11:56:24 <j-invariant> ski: that would be an improvement
11:56:45 * ski wonders whether `instance RealFloat n => Num (Complex n)' was really needed ..
11:57:08 <j-invariant> ski,
11:57:08 <ulfdoz> ddarius: The average programmer is unable to prove his code or read such a proof. I do not think, that this is a deficiency of the average programmer, as he usually is able to understand without a proof.
11:57:29 <j-invariant> Haskell comes with a library of functions called the 'standard prelude'. Unfortunately, whoever designed it knew just enough mathematics to be dangerous and made a complete hash of it. Instead of using a well known hierarchy of algebraic structures such as group->ring->field they defined all kinds of bizarre structures starting with something like a ring with a norm or valuation. 
11:57:35 <j-invariant> And while the library supports complex numbers it's not flexible enough to support the Gaussian integers (probably a consequence of forcing rings to have a norm). All things that could have been implemented correctly in a few seconds if a mathematician had been consulted early on
11:57:55 <ddarius> ulfdoz: I didn't say that they should.  Though, even attempting a proof will significantly clarify aspects of the code and problem.
11:58:19 <ddarius> j-invariant: The issue is the type of (:+) which is silly.
11:58:48 <ulfdoz> damex: true, but 99% of the code usually remain unproved. On the one or other function, of course a proof can be helpful.
11:58:50 <j-invariant> my algorithm for GCD works in Z[i]
11:59:11 <damex> ulfdoz: missed?:)
11:59:19 <copumpkin> j-invariant: I agree, but with NoDatatypeContexts, the complex issue goes away
11:59:34 <copumpkin> well, some of it, anyway
11:59:45 <n0den1te> ddarius: if you consider proof should be a part of an average programmer toolkit, then many would be out of jobs. 
11:59:48 <ddarius> copumpkin: There's an extension that removes -existing- data type contexts?
11:59:48 <ulfdoz> damex: unproven tab-completion. Seems buggy. ;)
12:00:11 <copumpkin> ddarius: well, 2011 remoevs data type contexts, so presumably that requires any existing in the standard libraries (basically just on Complex) to go too
12:00:15 <ddarius> Where are people getting the idea that I'm saying every programmer -should- be proving all of their code correct.
12:01:42 <j-invariant> ddarius: it's not fractal
12:01:48 <j-invariant> oops
12:03:09 <n0den1te> ddarius: ouch, when you spoke about implementation as clarificaiton, I somehow got the impression of proof as code. 
12:03:32 * n0den1te should just shut up and go read more haskell... 
12:08:16 <ymasory> what is meant by "first order programming language"?
12:10:24 <augustss> functions cannot be used as data, e.g., passed as arguments and returned
12:10:37 <ymasory> augustss: thanks
12:10:40 <ski> ymasory : probably one in which one can't pass functions/methods/predicates/words/whatever as parameters or return as result
12:11:37 <j-invariant> I am glad I have a code which appears to work but I don't know it works in all cases
12:12:09 <ddarius> j-invariant: Prove it correct.
12:12:20 <j-invariant> well that's not possible in my case
12:14:15 <Tomsik_> How it's not
12:14:33 <Tomsik_> are you basing your code on some unproven conjecture?
12:15:16 <copumpkin> yay: http://personal.cis.strath.ac.uk/~conor/pub/OAAO/LitOrn.pdf
12:15:23 * ddarius makes sure the correctness of all his middleware code relies on the Riemann Hypothesis being true.
12:15:32 <j-invariant> lol
12:15:54 <ddarius> copumpkin: Yeah, I opened that up the other day.
12:16:05 <ddarius> I haven't read almost any of it yet though.
12:16:08 <copumpkin> ddarius: this might be a newer version than the one you saw
12:16:16 <copumpkin> cause I think he announced the final version yesterday on twitter
12:16:23 <copumpkin> but there was an earlier draft floating around that I read
12:16:28 <copumpkin> (and quite enjoyed)
12:16:36 <ddarius> It is newer.
12:16:50 <ddarius> Good thing I didn't read the old one then.
12:17:11 <copumpkin> "But I am being deliberately obtuse. Let us rather be acute."
12:17:29 <copumpkin> I'm pretty sure any blind review process will deanonmize conor with no effort
12:18:21 <merijn> copumpkin: Yes, "I have no clue what this is about, but it is type theory so it must be Conor" >.>
12:18:38 <copumpkin> merijn: basically, it's about the relationship (among others) between Nat, List, and Vec
12:18:44 <copumpkin> and how they're very intimately related
12:19:14 <copumpkin> list is a nat that carries something extra around, and vec is a list that carries its underlying nat in its type
12:19:38 <copumpkin> so ideally one would want to write something like + on nat, and magically get ++ on list and vec
12:19:48 <Tomsik_> Why is there no (<<)
12:19:58 <merijn> I'm still stuck on his phd thesis
12:21:49 <Mathnerd314> copumpkin: maybe running it back and forth through an automatic translator would work?
12:22:05 <ddarius> Tomsik_: Because that would probably be pretty confusing.
12:22:22 <Tomsik_> there's (=<<) and (>>=) and (<=<) and (>=>)
12:22:33 <ddarius> Tomsik_: Which make sense.
12:22:35 <Tomsik_> I can't see where (<<) is adding any more confusion
12:23:03 <ddarius> putStrLn "Hello" << getLine
12:23:08 <Tomsik_> I like to think of (=<<) as monadic function application
12:23:20 <Tomsik_> f =<< x
12:23:31 <Tomsik_> and if you chain these, << is natural
12:23:31 <ddarius> Indeed, and expanding (<<) into (=<<) would result in something unpleasant looking.
12:24:01 <Peaker> Tomsik_, The main reason to have (=<<) is to have data-flow in the same order as (.).  (<<) has no data flow, so why have it?
12:24:18 <ski> > const "ab" =<< "cd"
12:24:19 <lambdabot>   "abab"
12:24:33 <Tomsik_> return () << f =<< x
12:24:35 <aristid> if (=<<) is like ($), (<=<) is like (.)
12:24:35 <mauke> Tomsik_: I want << to be <* but apparently everyone else disagrees
12:24:44 <Tomsik_> instead of
12:24:53 <Peaker> Tomsik_, So you can just use <$
12:24:56 * ski . o O ( `done = return ()' )
12:24:57 <Tomsik_> (f =<< x) >> return ()
12:24:58 <copumpkin> aristid: so << would be like const ?
12:25:00 <Peaker> @type (<$)
12:25:02 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
12:25:17 <Peaker> Tomsik_, () <$ f =<< x
12:25:30 <aristid> copumpkin: i think so
12:25:31 <Tomsik_> Where does this come from?
12:25:36 <Peaker> @index <$
12:25:36 <lambdabot> bzzt
12:25:40 <Peaker> @index (<$)
12:25:40 <aristid> copumpkin: but not 100% sure
12:25:40 <lambdabot> bzzt
12:25:43 <Tomsik_> applicative?
12:25:44 <Peaker> Control.Applicative I think
12:25:47 <ddarius> @hoogle (<$)
12:25:48 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
12:25:48 <lambdabot> Text.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
12:25:49 <lambdabot> Text.ParserCombinators.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
12:25:54 <ddarius>  @hoogle is a better @index
12:26:14 <n0den1te> @vixen Y U NO @index?
12:26:14 <lambdabot> i'll hafta plead the fifth on that one.
12:26:51 * ddarius doesn't think anyone uses the permutation parsers...
12:27:22 <merijn> We had a talk about those at the Dutch FP day, not sure I quite understood, though :p
12:28:56 <Mathnerd314> copumpkin: after ~20 times from various languages to/from English I got "However, this is deliberately difficult."
12:29:46 <copumpkin> http://www.translationparty.com/#8615028
12:29:47 <copumpkin> :(
12:30:01 <ddarius> There are quite a few colorful research paper writers associated with the Haskell commurity.
12:31:19 <ddarius> That survived reasonably well.
12:32:49 <Mathnerd314> copumpkin: then take that, put it through one of their alpha-stage pairs, and see where it goes
12:33:05 <sshc> How should I determine whether a file exists by its FilePath?
12:33:14 <c_wraith> @hoogle exist
12:33:14 <lambdabot> System.IO.Error alreadyExistsErrorType :: IOErrorType
12:33:14 <lambdabot> System.Directory doesDirectoryExist :: FilePath -> IO Bool
12:33:15 <lambdabot> System.Directory doesFileExist :: FilePath -> IO Bool
12:33:16 <ddarius> @hoogle fileexists
12:33:16 <lambdabot> No results found
12:33:28 <c_wraith> looks like doesFileExist is probably what you want
12:33:33 * ddarius had intended to get doesFileExist
12:33:37 <ddarius> Too much 's'
12:33:43 <aristid> sshc: why do you want to test it?
12:33:52 <Mathnerd314> copumpkin: but it seems like that site forces Japanese
12:33:58 <gwern> sshc: really now. obviously a function that does what you want is of the type 'FilePath -> IO Bool', so why didn't you ask hoogle yourself?
12:34:33 <aristid> beware of race conditions
12:34:40 <aristid> the file may cease to exist any moment
12:34:51 <aristid> so normally testing for existence is not a particularly safe thing
12:35:05 <n0den1te> lol @ http://www.translationparty.com/#8615026
12:36:39 <sshc> c_wraith: Thanks
12:36:39 <sshc> gwer	I had an IRC client open but not a browser; asking IRC seemed more convenient
12:36:58 <monochrom>  @hoogle is irc actually
12:36:59 <c_wraith> @hoogle FilePath -> IO Bool
12:36:59 <lambdabot> System.Directory doesDirectoryExist :: FilePath -> IO Bool
12:36:59 <lambdabot> System.Directory doesFileExist :: FilePath -> IO Bool
12:37:00 <lambdabot> System.Console.Editline.Readline readHistory :: FilePath -> IO Bool
12:37:00 <aristid> sshc: @hoogle works in IRC, too.
12:37:22 <aristid> sshc: but please do tell why you need to test for existence. i want to protect you from race conditions
12:37:38 <monochrom> then again I am not against asking
12:37:43 <ubunturocks> hi friends
12:38:18 <gwern> aristid: well, what is he supposed to do, shell out to mktemp?
12:38:52 <augustss> doesFileExist is fundamentally broken
12:38:56 <aristid> gwern: it depends. some people get the crazy idea that they should check for existence before opening a file for reading. in that case, just open the file and check for errors.
12:38:58 <augustss> it should not exist
12:39:04 <ddarius> open file, handle exception
12:39:10 <augustss> yep
12:39:27 <ddarius> doesFileExist FilePath -> IO (Maybe Handle)
12:39:30 <ddarius> + ::
12:39:50 <aristid> i think linux is introducing file descriptors for unopened files
12:39:54 <aristid> that would help
12:40:07 <EnglishGent> hi monochrom, augustss :)
12:40:09 * ddarius crusades against Bools.
12:40:23 * aristid crusades against race conditions
12:40:30 <augustss> you need a lot of file descriptors to cover all unopened file ;)
12:40:33 <Mathnerd314> aristid: how about just scrapping the filesystem altogether? :p 
12:40:36 <djahandarie> I seem to have this common pattern:   between (string "(") (string ")") (manyTill anyChar (try $ string ")"))
12:40:40 <aristid> Mathnerd314: if you can.
12:40:43 <djahandarie> Is there any combinator that already does that?
12:40:47 <djahandarie> Or something like that
12:40:55 <ddarius> Mathnerd314: That doesn't get rid of handles, though you could turn them into "pointers."
12:41:15 * hackagebot hjsmin 0.0.11 - Haskell implementation of a javascript minifier  http://hackage.haskell.org/package/hjsmin-0.0.11 (AlanZimmerman)
12:41:53 <c_wraith> try $ string ")"  seems like an unnecessary use of try.  parsec is LL(1) anyway.
12:42:10 <djahandarie> I thought you needed it there?
12:42:45 <ddarius> You certainly don't need it for a single character string.
12:42:46 <c_wraith> a single-character match doesn't require try, I'm pretty sure.
12:42:49 <ddarius> Also there's char.
12:42:50 <djahandarie> Oh, right
12:43:22 <djahandarie> I would need it in the case I'm doing something more generic like (| |) or whatever
12:43:26 <c_wraith> yes
12:43:49 <djahandarie> But my main concern is that the end token is being repeated twice
12:44:12 <c_wraith> well.  once in terms of "don't match this", and the other in terms of "match this"
12:44:24 <djahandarie> Right
12:56:23 <kuffaar> Given a function f and a list of argumetns l = [a, b], how do I call f a b?
12:56:44 <ddarius> kuffaar: How do you think you do?
12:56:46 <mauke> let [a, b] = l in f a b
12:57:26 <kuffaar> The number of arguments in l is unknown
12:57:35 <mauke> what's the type of f?
12:57:38 <c_wraith> then this sounds not-well-typed
12:57:48 <kuffaar> Very well :[
12:57:54 <Fuco> sounds like fold
12:58:18 <Fuco> [a,b,c...] and (op) = a (op) b (op) c (op)...
12:58:20 <Fuco> if that's what you want
12:59:02 <kuffaar> Oh it's actually a tuple even, not a list, but whatever
12:59:15 <mauke> then the number of elements is known
12:59:15 <quuuux> :t uncurry
12:59:16 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
12:59:33 <c_wraith> :t uncurry3
12:59:35 <lambdabot> Not in scope: `uncurry3'
12:59:37 <c_wraith> drat
13:00:33 <kuffaar> I was just wondering if I could shorten a = b c d; e = f c d using something other than blah x = x c d and then using blah b and blah f
13:00:35 <quuuux> uncurry3 is one of those awkward functions you wish you had occasionally and so end up writing it, but is just too tiny to bother with a library for
13:01:41 <kuffaar> Actually uncurry might just be it
13:01:44 <c_wraith> one time I wanted uncurry4
13:01:48 <c_wraith> I'm not sure why
13:01:59 <quuuux> database queries?
13:02:01 <c_wraith> I think in retrospect, I just wanted liftM4
13:02:07 <c_wraith> which actually exists
13:02:16 <mauke> just use `ap`
13:02:19 <kuffaar> :t ap
13:02:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:02:26 <kuffaar> :t liftM
13:02:27 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
13:03:11 <c_wraith> @pl \f a b c d -> liftM f `ap` a `ap` b `ap` c `ap` d
13:03:11 <lambdabot> (((((ap .) . ap) .) . ap) .) . ap . fmap
13:03:22 <c_wraith> pl apparently doesn't know of liftM4
13:03:43 <quuuux> that's odd. It managed to turn something equivalent into liftM2 the other day for me
13:03:45 <c_wraith> @pl \f a b -> liftM f `ap` a `ap` b 
13:03:46 <lambdabot> (ap .) . ap . fmap
13:03:51 <mauke> @pl \f a b c d -> return f `ap` a `ap` b `ap` c `ap` d
13:03:52 <lambdabot> ((((ap .) . ap) .) .) . liftM2
13:03:53 <quuuux> perhaps 4 is just a sufficiently large number
13:03:59 <mauke> it does know liftM2
13:04:01 <c_wraith> oh, right, it is return
13:04:03 <c_wraith> I fail
13:04:09 <c_wraith> @pl \f a b -> return f `ap` a `ap` b 
13:04:09 <lambdabot> liftM2
13:04:15 <aavogt> @pl \g f x y -> g (f x) (f y)
13:04:15 <lambdabot> join . ((flip . ((.) .)) .) . (.)
13:05:13 <aavogt> @ty (\g f x y -> g (f x) (f y), \g f x y -> liftM2 g x y f)
13:05:14 <lambdabot> forall t t1 t2 t3 a1 a2 r. (Monad ((->) t3)) => ((t1 -> t1 -> t2) -> (t -> t1) -> t -> t -> t2, (a1 -> a2 -> r) -> t3 -> (t3 -> a1) -> (t3 -> a2) -> r)
13:05:57 <aavogt> oh, that's on
13:06:08 <mauke> http://mauke.dyndns.org/tmp/flow.png says that's g (x f) (y f)
13:06:37 <wires> Hi, I have  a question,  say you have a method of unknown footprint, except the last one (i.e. "type of the return value")     g: u0 -> u1 -> u2 -> a     and then you have a second function    f: a->b   can you do something similar to (.)  as in (f . g) :: u0 -> u1 -> ... -> b ??
13:07:16 <wires> so change the type of the return value regardless of the footprint / nr of input arguments?
13:07:17 <mauke> I don't know any solution because "the last one" is ambiguous in general
13:07:57 <wires> hmm. yes
13:08:31 <aavogt> @type printf
13:08:32 <lambdabot> forall r. (PrintfType r) => String -> r
13:09:37 <wires> mauke: thanks
13:12:20 <mikeg> > ($ (4,5)) <$> uncurry <$> [(+), subtract]
13:12:21 <lambdabot>   [9,1]
13:12:29 <BMeph> wires: FP's answer to Chuck Norris, i.e. "oleg" wrote about this exact thing. Hold on a bit, and I can even give you a reference. :)
13:13:03 <mauke> does it include shift/reduce conflicts?
13:14:16 <BMeph> mauke: Don't think so. It does include the "usual suspects" of type-level hackery, but I sometimes think oleg only does that to let himself know he's working in Haskell instead of Scheme. ;)
13:17:05 <tolkad> What's the performance of an immutable array lookup by index VS tuple lookup by index with a case expression?
13:17:20 <tolkad> or will they compile to about the same thing?
13:20:17 <wires> BMeph: lol :)
13:20:23 <BMeph> wires: Got it. It is a complex issue, but it is solvable.
13:20:24 <BMeph> @google polyvariadic composition
13:20:28 <lambdabot> http://okmij.org/ftp/Haskell/polyvariadic.html
13:20:28 <lambdabot> Title: Polyvariadic functions and keyword arguments
13:20:30 <wires> BMeph: but thanks, i'd love to get that reference. I somehow have the idea that it should be possible...
13:20:39 <BMeph> wires: Check this ^^ out.
13:20:49 <wires> BMeph: thanks!!
13:20:49 <mikeg> what do you mean by "tuple lookup... case expression"? let (a,b,c) = x in case i of { 0 -> a; 1 -> b; 2 -> c }; ?
13:22:14 <wires> This article describes a combinator mcomp that does the farthest composition of functions:
13:22:14 <wires>      f:: a1->a2-> .... ->cp
13:22:14 <wires>      g:: cp->d
13:22:16 <wires>      f `mcomp` g:: a1->a2-> .... ->d
13:22:16 <wires> We resolve the ambiguity in the above definition by assuming that cp is not a functional type.
13:22:27 <wires> BMeph: excellent...  thanks
13:22:39 * hackagebot hslogger 1.1.2 - Versatile logging framework  http://hackage.haskell.org/package/hslogger-1.1.2 (JohnGoerzen)
13:23:18 <rmitt_> Someone's asking me to join his startup "informally," i.e., to do work for him and trust him to compensate me fairly in case of success.  He says he prefers working that way because the fizzling-out of his previous two startups was due to arguments over profit sharing, valuation of work, etc.  Any thoughts about this?
13:24:04 <BMeph> wires: Just to be clear, "http://okmij.org/ftp/Haskell/polyvar-comp.lhs" is where the meat is, specifically, the 'mcomp' function.
13:24:06 <elliott> Loading package charsetdetect-1.0 ... can't load .so/.DLL for: stdc++ (libstdc++.so: cannot open shared object file: No such file or directory)
13:24:07 <elliott> Hmm.
13:24:13 <elliott> That doesn't look good.
13:24:13 <edwardk> rmitt: 'screw that' ;)
13:24:25 <elliott> I do have libstdc++.so.6.
13:24:27 <ddarius> rmitt_: If you trust and/or can afford the opportunity cost (and, of course, are interested), do it.
13:24:38 <ddarius> s/trust/trust him/
13:25:05 <rmitt_> (...and btw, there's a small chance I could inject Haskell into parts of the job description)
13:25:10 <edwardk> you can think of ddarius with little angel wings standing over one shoulder and me with little devil horns standing over the other
13:25:17 <wires> BMeph: looking at it now.. thanks, very neat...
13:25:31 <rmitt_> argh
13:25:41 <rmitt_> I'd hoped this would be a no-brainer to those with more experience.
13:25:57 <edwardk> personally, i've been burned by too many of these little 'we don't have money right now, but we'll pay you when we get huge!'
13:25:59 <ddarius> My experience is that most people are not malicious, but there is a good chance that he won't -be able to- pay you.
13:26:04 <edwardk> style of projects
13:26:22 <ddarius> So you'd better not be relying on this to get by.
13:26:47 <BMeph> rmitt_: As an even more confusing third opinion, I'd keep in mind that if he doesn't have a contract on you for compensation, he can't have a contract on you to keep your work... ;)
13:26:52 <rmitt_> ddarius: of course I'm not relying on it.  I'm just wondering if things are ever done this way....if I'm being had.
13:26:55 <edwardk> now, if you want to do it and are okay with never getting paid (which is probably going to be the result in 85% of these scenarios) go do it
13:27:13 <rmitt_> BMeph: you're referring to ownership of intellectual property, etc?
13:27:19 <edwardk> rmitt: i've seen this approach pay out successfully once or twice, but I've seen it pulled dozens of times
13:27:21 <ddarius> rmitt_: I would say that if you are even considering the option of "being had," then you don't have enough trust in this person to do this.
13:27:48 <edwardk> rmitt: its particularly common in the games industry among would-be indie developers
13:28:00 <rmitt_> ddarius: You read me perceptively.
13:28:17 <edwardk> i'm with ddarius on that last point
13:28:26 * BMeph agrees.
13:28:46 <edwardk> rmitt: my usual answer is to come back with a fixed rate and be available for consulting
13:29:05 <edwardk> rmitt: that way if they _need_ you they can get access to you, but they won't have you fetching pizza
13:29:21 * edwardk does a lot of consulting.
13:30:04 <rmitt_> edwardk: he can't pay me up front; instead, he's offering to commit in writing to a percentage.
13:30:08 <BMeph> rmitt_: (Re: IP) Yes. Specifically, the right to re-use your coding free and clear.
13:31:27 <rmitt_> edwardk: I assume your consulting work does not involve functional programming?
13:31:44 <ddarius> His non-consulting work involves FP and category theory.
13:31:49 <edwardk> rmitt_: getting stuff in writing is better than not, but i'll say this, a percentage is a very fuzzy thing, net or gross? after all, you can claim a ton of expenses on net that makes that number as small as you want
13:31:55 <rmitt_> rmitt: I smell a fib :-)
13:31:58 <edwardk> rmitt: actually more often than not it does.
13:32:25 <edwardk> to both comments
13:33:29 <edwardk> (in fact, there is a whole field of 'hollywood accounting' devoted to doing just that)
13:34:51 <ddarius> "The hookers and blow were for team morale."
13:35:05 <edwardk> hahahaha
13:36:17 * ddarius is made happy by Nautilus.  A rare experience.
13:36:24 <rmitt_> reminds me of ferguson's "Inside Job."
13:38:43 <elliott> Loading package charsetdetect-1.0 ... linking ... <interactive>: /home/elliott/.cabal/lib/charsetdetect-1.0/ghc-6.12.3/HScharsetdetect-1.0.o: unknown symbol `__dso_handle'
13:38:47 <elliott> Uhh...
13:46:54 <parcs> is there a technical justification as to why there is no Binary instance of Text?
13:47:00 <Ilum> I'm attemping to import functions from a c library, but when I attempt to compile the haskell source I get "parse error on input 'import'". It's complaining about "foreign import ccall "sin" c_sin :: CDouble -> CDouble" What's wrong with my syntax?
13:50:27 <mauke> Ilum: {-# LANGUAGE ForeignFunctionInterface #-}
13:50:46 <ddarius> parcs: Yes.
13:50:59 <ddarius> Well, yes and no.
13:52:46 <horse_kicker_> I have f::String->String, i need a g::[String]->[String]->f->f that "adds" the input strings to f. Is that possible?
13:53:35 <horse_kicker_> If needed we can wrap that function in data Env = Env (String -> String), and pass around Env
13:54:20 <ddarius> You can just pass around String -> String directly.  Env doesn't provide anything (other than an extra bottom.)
13:54:32 * BMeph wags his head swiftly from side to side, making a "wubba-wubba" sound...
13:54:55 <horse_kicker_> How do i write g?
13:56:48 <Botje> horse_kicker_: if the input String is a member of those [String], return the corresponding entry
13:56:53 <Botje> horse_kicker_: otherwise consult f
13:57:02 <ddarius> copumpkin: Would you be interested in trying this place if you haven't been there before? http://www.75chestnut.com/main.htm
13:57:24 <copumpkin> ddarius: sure :) can't make it tonight though, but maybe later this week sometime?
13:58:09 <ddarius> copumpkin: I guess that gives me more time to do homework.
13:59:24 <horse_kicker_> Botje : f is constructed using g. For looking up, i just do f "key" and I should get the "value". I am not sure what you mean by a input string in g.
14:00:11 <Botje> horse_kicker_: g keys values = \str -> if (str `elem` keys) then {- return the matching value -} else f str
14:00:43 <Botje> and somewhere at the bottom you have an f that returns an error no matter what the input
14:02:40 <Botje> so g either knows the answer or it delegates to f
14:02:59 <horse_kicker_> Botje : Thanks. I'll try it out.
14:03:27 <Botje> you could do smarter stuff like using lookup etc, but that's the gist of it.
14:19:58 * hackagebot follower 0.0.1 - Follow Tweets anonymously  http://hackage.haskell.org/package/follower-0.0.1 (EmreBasar)
14:24:36 <horse_kicker_> Botje : the g you wrote is like g :: [String]->[String]->f 
14:24:58 <elliott> hmm, say one has a ByteString containing UTF-8 text -- how should one convert this to a Haskell String?
14:25:15 <elliott> converting it to UTF-32 and then using Data.ByteString.Lazy.Char8's unpack seems to work except it has some sort of identifier at the start
14:26:14 <horse_kicker_> Botje : I need g to take an existing f and "append" to it. So, it need to be like [String] -> [String] -> f -> f
14:35:24 <elliott> hmm, in Data.Text.Encoding, which is likely to be the most efficient? I can choose the relevant encoding.
14:35:27 <elliott> utf-8, some utf-32 variant?
14:38:32 <mikeg> I'd expect (Data.Text.unpack . Data.Text.Encoding.decodeUtf8) would be pretty fast
14:39:38 <copumpkin> if you're lucky they'll fuse and not even make an intermediate Text
14:42:06 <c_wraith> I hate that fusion still feels like luck.
14:43:11 <ddarius> c_wraith: I mostly don't worry about fusion.  It's usually not that big a deal.
14:43:44 <helmut> hi. I am trying to employ "fromEnum (minBound :: a)" in an expression with (Enum a, Bounded a) and get some type deduction error from minBound. could someone give me a pointer what is wrong?
14:43:49 <Philippa> c_wraith: having big enough a grab-bag of known "this is sufficient for fusion" properties would help, yeah
14:46:18 <c_wraith> helmut: unless you have the ScopedTypeVariables extension on, the ":: a" in that expression does nothing like what you want.
14:46:29 <companion_cube> :kind StateT
14:46:44 <companion_cube> oh, there is not this command in lambdabot :/
14:46:58 <c_wraith> @kind StateT
14:47:00 <lambdabot> * -> (* -> *) -> * -> *
14:47:04 <ddarius> Philippa: Usually it, more or less, works out to a "good producers, good consumers" list a la shortcut fusion.
14:47:24 <helmut> c_wraith: ohh. ok. I need to find a different way to express this
14:48:07 <copumpkin> now we just need fusion types!
14:48:24 <copumpkin> where the type of terms expresses whether they're good producers/consumers or not
14:49:01 <geheimdienst> f :: Int -> YesSantaIveBeenAGoodConsumer Int
14:49:07 * Saizan wonders if directed partial evaluation a la Idris wouldn't be a better approach than RULES
14:50:21 <ddarius> Saizan: Seeing as RULES are a completely ad-hoc, unsound mechanism, probably.
14:50:37 <ddarius> (Of course, being unsound they can be rather powerful.)
14:50:53 <tolkad> I want to use logical shift but haskell doesn't seem to support it for signed types
14:51:04 <tolkad> will there be any overhead if I use fromIntegral?
14:51:19 * ddarius doesn't know what "logical shift" is.
14:51:25 <ddarius> Perhaps "bitwise shift" is what is meant.
14:51:25 <kuffaar> Do any of you know any experienced programmers who actually learned Haskell as their first language? It seems that most people who actually bother to learn it and end up writing a lot of code in Haskell usually already have a lot of experience with like at least 5-10 other programming ilanguages
14:51:28 <copumpkin> tolkad: it does
14:51:37 <copumpkin> I thought
14:52:05 <tolkad> ddarius: yes I mean bitwise shift, I.E. no special consideration towards the sign bit
14:52:11 <ddarius> There is an instance of Bits for all standard (and semi-standard) integral types.
14:52:27 <copumpkin> oh I guess you're right
14:52:28 <tolkad> "Shift the first argument right by the specified number of bits (which must be non-negative). Right shifts perform sign extension on signed number types; i.e. they fill the top bits with 1 if the x is negative and with 0 otherwise. "
14:52:40 <ddarius> tolkad: Well, then yes, if you want an unsigned shift for a signed number, you will have to convert to and from.
14:52:47 <ddarius> Or implement it elsewise.
14:53:15 <tolkad> ddarius: this is a single asm instruction. if I implement it myself it wont be anywhere near as fast
14:53:32 <ddarius> tolkad: It will be a single asm instruction if you convert, I'm fairly certain.
14:53:58 <tolkad> ddarius: I thought fromIntegral converts to an Integer first and then to the second type
14:54:13 <ddarius> tolkad: Conceptually.
14:54:17 <tolkad> ah
14:54:24 <tolkad> thanks
14:54:36 <tg_> :t fromIntegral
14:54:38 <lambdabot> forall a b. (Integral a, Num b) => a -> b
14:54:46 <tolkad> :t toInteger
14:54:47 <lambdabot> forall a. (Integral a) => a -> Integer
14:54:49 <tolkad> :t fromInteger
14:54:50 <lambdabot> forall a. (Num a) => Integer -> a
14:55:11 <tolkad> :t (fromInteger . toInteger)
14:55:12 <lambdabot> forall a a1. (Num a, Integral a1) => a1 -> a
14:55:53 <ion> > fromIntegral . Data.Bits.shiftR $ (fromIntegral (-42 :: Data.Int.Int32) :: Data.Word.Word32) 1 :: Data.Int.Int32
14:55:54 <lambdabot>   Couldn't match expected type `t -> a'
14:55:55 <lambdabot>         against inferred type `GHC.Wo...
14:56:16 <ion> whoops
14:56:23 <ion> > fromIntegral $ Data.Bits.shiftR (fromIntegral (-42 :: Data.Int.Int32) :: Data.Word.Word32) 1 :: Data.Int.Int32
14:56:24 <lambdabot>   2147483627
14:56:29 <tg_> and there you are
14:56:44 <tg_> now ask him if he can do that atomically
14:57:29 <tolkad> :t fix fromIntegral
14:57:30 <lambdabot> forall a. (Integral a) => a
14:58:05 <copumpkin> tolkad: that looks useful
14:58:34 <copumpkin> tg_: just unsafeCoerce it
14:59:08 <gwern> @quote unsafeCoerce
14:59:09 <lambdabot> danharaj says: unsafeCoerce should be renamed to badPun
14:59:21 <gwern> @quote unsafeCoerce
14:59:21 <lambdabot> int-e says: What, unsafeCoerce# is kind-preserving? how boring :/
14:59:23 <ddarius> copumpkin: unsafeCoerce may actually be detrimental to performance in that case.
14:59:38 <elliott> also, sanity
15:00:20 <tolkad> yeah, the only thing unsafeCoerce is really good for is defining the y combinator in haskell using lambda terms
15:00:20 <ion> Is lambdabot’s quote database browseable online?
15:04:07 <tg_> ion: some of them are
15:04:09 <tg_> it's in the source code
15:04:40 <ddarius> Hmm.  The government might have finally gotten around to paying me for my unused leave...
15:05:26 <roconnor> anyone recall that game written in F# that had a blog entry about stateless world transitions?
15:05:35 <roconnor> if that makes sense
15:05:39 <ddarius> @google F# stateless world transitions
15:05:40 <lambdabot> http://stackoverflow.com/questions/844536/advantages-of-stateless-programming
15:05:40 <lambdabot> Title: state - Advantages of stateless programming? - Stack Overflow
15:05:46 <ddarius> Probably not that.
15:05:57 * ddarius should have thrown in "game."
15:06:34 <wires> Can one easily "pretty print" arbitrary values (from ghci)?
15:06:36 <horse_kicker_> tolkad : it is possible to emulate a list of tuples using only functions in Haskell....I finally wraped my head around it.
15:07:25 <roconnor> found it: http://www.reddit.com/r/haskell/comments/ehnfh/today_i_created_death_fp_in_game_development_not/
15:07:43 <tolkad> horse_kicker_: Neat. good luck learning the rest of haskell
15:08:50 <ion> @pl \n -> n :: Foo
15:08:51 <lambdabot> (:: Foo)
15:09:08 <ion> It would be cool if that actually worked. Syntactic sugar for a type-restricted id. :-)
15:09:32 <ion> (Or perhaps it does in a newer ghc than 6.12.1.)
15:09:41 <ddarius> It doesn't.
15:09:48 <ddarius>  @pl just doesn't understand ::
15:09:52 <ion> aye
15:09:56 <ddarius> @pl [x | x <- xs]
15:09:57 <lambdabot> [x | x <- xs]
15:10:05 <ddarius> @pl \x -> [x | x <- xs]
15:10:05 <lambdabot> return . (<- xs) . join (|)
15:10:20 <elliott> @pl (\n -> n) :: Foo -> Foo
15:10:20 <lambdabot> (line 1, column 18):
15:10:20 <lambdabot> unexpected ">" or "-"
15:10:20 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
15:10:30 <elliott> <lambdabot> return . (<- xs) . join (|)
15:10:33 <elliott> that should work :-D
15:10:42 <copumpkin> man, I want point-free list comprehensions like what @pl spat out
15:10:45 <elliott> hahahaha
15:10:46 <ion> elliott: hehe
15:10:49 <parcs> @hoogle IO a -> IO (Maybe a)
15:10:50 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
15:10:50 <lambdabot> Control.Applicative optional :: Alternative f => f a -> f (Maybe a)
15:10:50 <lambdabot> Prelude Just :: a -> Maybe a
15:11:01 <elliott> return . (::Int) . (<- xs) . join (|)
15:11:07 <elliott> that's id for [Int] -> [Int]
15:11:14 <ddarius> :t Control.Exception.try
15:11:15 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> IO (Either e a)
15:11:17 <elliott> written with point-free list comprehensions and point-free id casting
15:11:22 <parcs> ddarius: thanks
15:12:15 <ddarius> copumpkin: You want to discard hygiene and lexical scoping?
15:12:23 <poincare101> how do I make lamdabot eval something?
15:12:34 <poincare101> lambdabot: help
15:12:45 <geheimdienst> > reverse "lolcat"
15:12:45 <lambdabot>   "taclol"
15:12:46 <copumpkin> ddarius: but it'd be point-free!!1!
15:13:02 * ddarius wonders how much thought that '1' took.
15:13:29 <elliott> Ooh, ooh, Caleskell should reject non-point-free programs.
15:13:32 <elliott> Basically yell whenever it sees \.
15:13:34 <poincare101> > [(a,b,c) | a<-(1..10), b <- (1..10), c <- (1..10), a*a + b*b = c*c]
15:13:35 <lambdabot>   <no location info>: parse error on input `..'
15:13:37 <elliott> Or |.
15:13:56 <poincare101> [(a,b,c) | a<-(1..10), b <- [1..10], c <- [1..10], a*a + b*b = c*c]
15:14:10 <poincare101> > (a,b,c) | a<-(1..10), b <- [1..10], c <- [1..10], a*a + b*b = c*c]
15:14:12 <lambdabot>   <no location info>: parse error on input `|'
15:14:30 <geheimdienst> poincare101: you can also open a separate window to send private messages to lambdabot
15:15:28 <elliott> Dear god: "Maybe Bool".
15:15:34 <elliott> My faith in this API is rapidly waning.
15:15:41 <elliott> (Actually it waned when I realised it broke the language's semantics.)
15:15:49 <aristid> which API do you refer to?
15:15:54 <Twey> Maybe Bool: the Haskell equivalent to True/False/FileNotFound
15:16:44 <aristid> :t (>>= guard)
15:16:45 <lambdabot> forall (m :: * -> *). (MonadPlus m) => m Bool -> m ()
15:17:02 <aristid> :t (>>= guard) :: Maybe Bool -> Maybe ()
15:17:03 <lambdabot> Maybe Bool -> Maybe ()
15:17:13 <elliott> aristid: text-icu
15:17:21 <elliott> Language-breaking: "Character set converter type. Note: this structure is not thread safe. It is not safe to use value of this type simultaneously from multiple threads."
15:17:32 <elliott> (There are pure functions operating on Converters, even though you can only create them in IO, so this is pretty much evil.)
15:17:42 <elliott> OK, so it's a binding, but euugh.
15:17:48 <Twey> Ick
15:18:13 <elliott> Not to mention that it advertises character set detection but appears to have none.
15:20:02 <aristid> @hackage text-icu
15:20:02 <lambdabot> http://hackage.haskell.org/package/text-icu
15:20:30 <aristid> elliott: you could write a nastygram to bos
15:20:38 <elliott> aristid: tempting
15:20:44 <Twey> I don't think it's bos' fault
15:20:54 <Twey> Blame the library
15:21:44 <ion> This should be a quote. :-D (It’s a thedailywtf reference if someone didn’t notice.) < Twey> Maybe Bool: the Haskell equivalent to True/False/FileNotFound
15:21:45 <elliott> Twey: I'd have just stuck all the functions in IO :-P
15:21:54 <elliott> @remember Twey Maybe Bool: the Haskell equivalent to True/False/FileNotFound
15:21:54 <lambdabot> Done.
15:21:55 <elliott> @quote Twey
15:21:55 <lambdabot> Twey says: Friendly error messages are a myth ☺
15:21:58 <elliott> @quote Maybe Bool
15:21:58 <lambdabot> No quotes for this person. This mission is too important for me to allow you to jeopardize it.
15:22:02 <elliott> @quote Twey
15:22:02 <lambdabot> Twey says: Maybe Bool: the Haskell equivalent to True/False/FileNotFound
15:22:13 <aristid> @quote Maybe.Bool
15:22:13 <lambdabot> Twey says: Maybe Bool: the Haskell equivalent to True/False/FileNotFound
15:22:22 * Twey wonders if λb still has the tuple tipple one
15:22:25 <elliott> aristid: expert lambdabot!
15:22:26 <Twey> @quote tuple.tipple
15:22:27 <lambdabot> Twey says: Tuple tipple — alcohol made from fermented pairs
15:22:34 <aristid> elliott: *bows*
15:22:36 <Twey> Yay.  I like that one.
15:22:45 <monochrom> interesting
15:22:48 <Twey> Puns are the lowest form of humour.  In English.
15:23:08 <Twey> Or was that the bun?
15:23:08 <elliott> The two things I hate most about Haskell are n+k patterns and integrating libraries that use different versions of ByteStrings.
15:23:23 <elliott> Thankfully n+k patterns no longer exist. :p
15:23:28 <aristid> elliott: trying to get a quote in? :P
15:23:29 <Twey> One down…
15:23:43 <elliott> aristid: WIT GENERATOR AT MAXIMUM
15:23:53 <Twey> I'm unoriginal: I dislike the record system.
15:23:58 <elliott> But I am actually trying to achieve the latter right now, and I'm pretty much crying.
15:24:04 <elliott> Twey: Boring.
15:24:09 <elliott> Twey: Can't you at least wish the module system was more like ML's?
15:24:23 <Twey> I don't really know ML all that well
15:24:39 <elliott> Twey: It's that language which is inferior to Haskell in every way except for actually having a module system that isn't a joke.
15:24:54 <poincare101> I was just learning haskell when a thought struck me, wouldn't imperative languages always be faster than functional ones? Because, if you do say i++ in C, in Haskell you have to create a whole new variable/constant for i++ (say k), and for arrays, they wouldn't be mutable so they can never be O(1) can they?
15:24:56 <Twey> Heh.
15:25:13 <Twey> poincare101: If you have a really stupid compiler, then yes.
15:25:15 <elliott> poincare101: GHC is smart, it can transform functional code into mutating imperative code in a lot of cases.
15:25:24 <poincare101> elliott: ah.
15:25:31 <elliott> (Note: GHC does not yet have strong AI. :P)
15:25:38 <Twey> poincare101: Thankfully, GHC is Smart Enough in most cases.
15:25:45 <poincare101> Ocaml's compiler must be really smart then
15:25:46 <elliott> poincare101: Also there are CPUs that work on graph reduction rather than sequential execution, but you're unlikely to use them in the next decade :P
15:25:53 <poincare101> its speeds are comparable to C and stuff like that
15:26:02 <elliott> OCaml's compiler is actually quite dumb, it's just that the language lets it compile to asm fairly directly without any extra checks.
15:26:04 <Twey> poincare101: So are Haskell's
15:26:11 <elliott> OCaml itself has mutation and side-effects and whatnot.
15:26:17 <elliott> The compiler doesn't actually do much optimisation.
15:26:35 <poincare101> also, what's the benefit of writing code in a purely functional language aside from theorem proving?
15:27:00 <Liskni_si> it's fun
15:27:08 <CaScAdE^Laptop> hi folks
15:27:55 <monochrom> I cannot detach theorem proving from programming.
15:28:38 <poincare101> I understand that, but, when you're writing code (I mostly write code for heavily math-y stuff), what benefit does a functional language provide?
15:28:48 <j-invariant> poincare101: sory but what has theorem proving got to do with purely functional language?
15:29:05 <geheimdienst> poincare101: i like haskell because it finally has a type system that doesn't get in the way (like in java, for instance). it's hard to get something to compile, but once it does, it rarely has many bugs anymore
15:29:52 <geheimdienst> which is better than getting something to compile quickly and then debugging until the  universe will end
15:29:59 <Twey> Also, it's more concise and helps with the DRY principle.
15:30:03 <monochrom> a functional language lets me use functions. higher-order functions. they help me organize and refactor.
15:30:17 <geheimdienst> twey, good point
15:30:24 <Cale> poincare101: Do you ever write functions or procedures which are similar, but there's a bit of actual code in the middle of them which is different in each case?
15:30:50 <poincare101> Cale: yeah
15:30:58 <Cale> In fact, if you're doing imperative programming, there's a lot of that all over the place with loops
15:31:12 <j-invariant> poincare101: just wondering if you ared that somewhere or where you heard it
15:31:15 <Cale> In a non-functional language, you can't abstract that code out and make it a parameter
15:31:36 <Cale> In a functional language, that's exactly what first class functions are for :)
15:31:38 <poincare101> Cale: I see. so, it speeds up programming large projects..
15:31:45 <CaScAdE^Laptop> can anyone help me out getting started with that "algebraic data" stuff?
15:31:47 <Cale> and prevents bugs from repeated code
15:32:07 <Cale> and makes common patterns more obvious, because we can give them names and put them in a library
15:32:27 <Cale> CaScAdE^Laptop: Just ask questions :)
15:32:31 <poincare101> I would stop programming in every other language except haskell if it was faster than Java, which really irks me, because Java is running on a VM...
15:32:44 <Cale> GHC can easily be faster than Java
15:32:49 <j-invariant> poincare101
15:32:55 <monochrom> there is no need to give up other languages
15:33:03 <CaScAdE^Laptop> Cale: ok, i'll try... :)
15:34:08 <CaScAdE^Laptop> http://car.pastebin.com/ZbpS36hc <-- i would like to get the create method to take an mvar of a type and return a TB of that type...
15:35:01 <monochrom> there is not much algebraic data there...
15:35:05 <CaScAdE^Laptop> and i know it might be really stupid but i just started with haskell (for university-lecture) and do not get the point
15:35:08 <poincare101> j-invariant: yeah?
15:35:22 <elliott> Only two things in the universe are certain: Death, and two of the libraries you've decided to use taking different types of ByteString.
15:35:27 <elliott> (am i doing well here?)
15:35:40 <monochrom> createThreadBuffer mv = ThreadBuffer mv
15:35:40 <elliott> (gotta be close to quotation now)
15:35:43 <j-invariant> poincare101: I asked you a question
15:35:54 <j-invariant> just curious what youar answer would be
15:36:15 <geheimdienst> @remember elliott Only two things in the universe are certain: Death, and two of the libraries you've decided to use taking different types of ByteString.
15:36:15 <lambdabot> Okay.
15:36:24 <elliott> I WIN
15:37:08 <CaScAdE^Laptop> monochrom: thanks.. that works... i doubt it is what i need for now but i will try to get further :)
15:37:36 <elliott> poincare101: writing programs in purely functional languages is both easier and less error-prone, and the resulting programs are both shorter, more readable, and more maintainable.
15:37:39 <elliott> that's my incredibly biased opinion :)
15:37:42 <regularlambda> leksah
15:37:50 <regularlambda> giving error in mac
15:37:55 <regularlambda> continuously
15:38:08 <regularlambda> which ide i can use?
15:38:39 <elliott> which is more efficient, lazy -> strict bytestring, or strict -> lazy bytestring?
15:38:44 <elliott> I'd imagine strict -> lazy but I'm not sure
15:39:06 <monochrom> eclipse or your favourite editor
15:39:23 <monochrom> also perhaps the leksah errors can be fixed but I don't know how
15:40:27 <Saizan> strict -> lazy is O(1)
15:40:55 <revenantphx> Anyone have any tips regarding generating stuff like perlin noise in Haskell?
15:41:04 <revenantphx> Or any shortcuts that might be relevant for terrain generation and such fun stuff?
15:41:13 <elliott> Saizan: right. since the lazy function evaluates the whole string (afaik) I'll use strict then, and convert to lazy
15:43:06 <alpounet> revenantphx, you might be interested in http://www.haskell.org/pipermail/haskell-cafe/2007-July/029681.html
15:43:10 <poincare101> j-invariant: about the theorem proving thing, since functional languages are largely based on mathematics you can do logic with them very easily
15:43:17 <revenantphx> alpounet: wonderful, thanks.
15:43:18 <alpounet> (the topic, not that particular message)
15:43:21 <revenantphx> ah! infinite!
15:43:22 <j-invariant> poincare101: thanks
15:43:22 <revenantphx> perfect :)
15:45:51 <alpounet> revenantphx, this doesn't give an actual solution / piece of code for your problem but it gives some pointers that are probably worth investigating
15:45:56 <revenantphx> No not at all :\
15:46:02 <revenantphx> Well I was already considering perlin/simplex noise.
15:46:17 <revenantphx> I just need to pretty much generate a quantized 3d terrain of infinite size
15:46:41 <revenantphx> such that I can generate a new "chunk" of the terrain at any time and have it smoothly fit.
15:46:49 <alpounet> revenantphx, if you manage to factor out some reusable code, that could be a great library idea
15:47:09 <revenantphx> that is, the Y at a specific Z and X should depend only on the Z, X and seed.
15:47:17 <alpounet> yeah
15:47:20 <alpounet> a sort of iterative approach
15:47:25 <Philippa> poincare101: it's a lot more useful to do logic in a language that doesn't permit the proof of anything: becauseISaidSo x = becauseISaidSo x
15:47:29 <elliott> <poincare101> j-invariant: about the theorem proving thing, since functional languages are largely based on mathematics you can do logic with them very easily
15:47:37 <elliott> poincare101: that doesn't follow at all
15:47:48 <elliott> the "based on mathematics" thing is ... a myth or a misconception, I can't decide which
15:48:07 <monochrom> depends on whose "mathematics" you mean
15:48:07 <elliott> maybe it's because mathematicians sometimes like purely functional languages more than others? I have no idea.
15:48:23 <alpounet> hey, revenantphx http://hpaste.org/42766/simplex_perlin_noise
15:48:25 <Philippa> elliott: you mean it has nothing to do with eg programs in foundational mathematics and logic?...
15:48:25 <elliott> Or because some theorem provers are based on the dependently-typed lambda calculus? Well, Haskell isn't.
15:48:38 <Philippa> no, but haskell still corresponds to a logic
15:48:41 <elliott> Philippa: Well, sure, but calling Haskell "more mathematical" just seems weird to me.
15:48:42 <Philippa> just not a very useful one
15:48:44 <revenantphx> alpounet: eep.
15:48:46 <elliott> Yeah, Haskell corresponds to an inconsistent logic. :p
15:48:48 <revenantphx> thats very... large.
15:48:55 <elliott> So thinking about it in that way is ... rather pointless.
15:48:56 <Philippa> OTOH, it does have a consistent subset
15:49:00 <alpounet> revenantphx, see also http://litherum.blogspot.com/2010/02/memory-leaks-in-my-2-d-perlin-noise.html
15:49:07 <elliott> Sure, but how many people write _proofs_ in Haskell?
15:49:10 <ion> Is there some magic that closes the file handle upon reaching EOF when using readFile, or is the file handle just left lingering? http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/System-IO.html#readFile
15:49:12 <elliott> That involves a lot of type-level data.
15:49:13 <Philippa> just not one you want to code in without at least allowing yourself a bunch of functions ahead of time
15:49:16 <j-invariant> I want a proof that my haskell program is correct
15:49:18 <elliott> And is just, er, painful and pointless.
15:49:24 <elliott> j-invariant: write it in Coq then export it :P
15:49:24 <j-invariant> because the code I write tends to be wrong :(
15:49:33 <Philippa> elliott: not necessarily. A lot of people reason on various levels based on the free theorems from their types, for example
15:49:51 <elliott> Philippa: Oh, sure, but that seems to me more like "it is easier to reason about Haskell programs mathematically".
15:49:52 <monochrom> ion: some magic closes the handle upon reaching EOF
15:49:56 <elliott> Which is NOT the same as "Haskell is mathematical!".
15:50:06 <augustss> j-invariant: there are many levels of correctness
15:50:13 <elliott>     Ambiguous occurrence `head'
15:50:13 <elliott>     It could refer to either `Prelude.head', imported from Prelude
15:50:13 <elliott>                           or `T.head', imported from Data.Text at /home/elliott/Code/herobrine/logview.hs:5:0-20
15:50:16 <j-invariant> augustss: and I don't have any of them X)
15:50:17 <elliott> What's all that about.
15:50:20 <elliott> I imported it qualified for a reason.
15:50:24 <Philippa> elliott: it is mathematical, to the point of being 'low-level' on a mathematical foundation even. It's just that it's not the same maths that most people think of when they hear the word
15:50:40 <ion> monochrom: Cool. I take it the garbage collector notices nothing refers to it anymore?
15:50:41 <elliott> Philippa: C is mathematical - it has semantics, semantics that are formal!
15:50:47 <elliott> And you can reason about C code! Even prove things about it!
15:50:51 <ion> monochrom: and closes it based on that?
15:50:52 <Philippa> elliott: there's a formal semantics for the whole of C? Show me!
15:51:05 <elliott> Philippa: http://compcert.inria.fr/ ... OK, not all :P
15:51:08 <Philippa> (Haskell actually /doesn't/ have one, but the informal semantics are at least equational)
15:51:15 <elliott> Philippa: It obviously has semantics, just nobody's written them down yet *shot*
15:51:22 <monochrom> the garbage collector also closes it. but waiting for garbage collection is too long.
15:51:24 <elliott> Philippa: First, take a finite state machine. ...
15:51:26 <j-invariant> who nees formal semantics when you can just make it up as you go?
15:51:31 <Philippa> elliott: well yes, the shortest version goes "invoke nasal demons"
15:51:41 <elliott> Philippa: With a finite state machine!
15:51:59 <Philippa> elliott: read Stross's Laundry series. In his 'verse, it's probably possible
15:52:15 <Philippa> in fact, I'm mildly surprised that I've not caught him make a nasal demons reference in the books yet
15:52:56 <elliott> Seriously though. Why is GHC telling me that "head" is ambiguous when the other head is import qualifi- ohh.
15:52:59 <elliott> "import Data.Text as T"
15:53:03 <elliott> Why on earth is this valid syntax.
15:53:12 <monochrom> haskell is based on Dana Scott's mathematics but not Erdös's mathematics
15:53:33 <davidL> there is a formal semantics of C: http://fsl.cs.uiuc.edu/index.php/A_Formal_Semantics_of_C_with_Applications
15:53:51 <andrewsw> carrben: see it works...
15:53:59 <elliott> davidL: What does it say about type punning? *0xf = &x;? :P
15:54:13 <c_wraith> elliott: it's annoying, isn't it?
15:54:13 <elliott> That's cool though!
15:54:14 <monochrom> term rewriting is my favourite kind of semantics :)
15:54:19 <carrben> andrewsw: does!
15:54:20 <ion> monochrom: What i‘m curious about is whether arbitrary Haskell code could use the same mechanism for resource deallocation.
15:54:20 <elliott> c_wraith: Yeah ...
15:54:22 <davidL> elliott: you can run it yourself. it's executable.
15:55:22 <horse_kicker_> How do i typecast data types at runtime?
15:57:00 <monochrom> cannot be done
15:57:23 <c_wraith> horse_kicker_: what are you trying to actually do?
15:57:54 <j-invariant> as far I am seeing haskell doesn't wan 100% correct codes
15:58:05 <j-invariant> just write something roughly good and then run a million tests on it
15:58:09 <Philippa> j-invariant: you know where Coq and AGDA are if you want them
15:58:15 <Philippa> or you can do it out by hand
15:58:22 <j-invariant> how is it doen by hand?
15:58:34 <Philippa> lots of equational reasoning at the base
15:58:47 <Philippa> you know what beta reduction is, you know how to handle a case analysis, go from there
15:59:00 <horse_kicker_> c_wraith : I just wrote a bunch of functions that operate on a custom data type. Say data Blah1. Now I realized, I need to add something more to it, so I created data Blah2 = Blah1 | New_Stuff. Now, I can't use any of my old functions. 
15:59:03 <monochrom> ion: something in the Foreign.ForeignPtr module let's you attach finalizers i.e. routines that are run by GC.
15:59:17 <ion> monochrom: Thanks, i’ll look into that.
15:59:19 <Philippa> the 'dynamic' parts of haskell's semantics are really bloody simple if you're only working up to functional spec with no operational or resource concerns
15:59:46 <Philippa> there's just case, beta reduction, binding and a lot of desugaring
16:00:19 <horse_kicker_> c_wraith : I of course come from the OOPS world. 
16:00:23 <j-invariant> Philippa: on the other hand most haskell programs use unsafePerformIO and similar
16:00:29 <c_wraith> horse_kicker_: well, it sounds like those two types *aren't* the same.   Of course you can't use the same functions on them.
16:00:41 <j-invariant> which ruins most of the equations
16:00:55 <revenantphx> Is it possible to call Haskell functions from python?
16:01:03 <revenantphx> via some FFI magic?
16:01:48 <Philippa> j-invariant: most don't use them directly, and you can reason on the assumption that the libs work first
16:02:12 <Philippa> if nothing else: if you've got that far then you know it's not your fault if it breaks
16:02:26 <Philippa> it's certainly possible to do plenty without unsafePerformIO if you have that concern
16:02:28 <c_wraith> revenantphx: You can create C bindings for the haskell code, then python bindings for those C bindings.
16:02:38 <revenantphx> Yeah I was thinking something like that.
16:02:43 <revenantphx> How do you make the C bindings easily?
16:02:52 <revenantphx> ah
16:02:52 <revenantphx> http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
16:02:54 <revenantphx> I'll read this.
16:02:55 <c_wraith> I don't know anything about making C bindings for haskell code, though.  I've only ever gone the other way
16:03:04 <c_wraith> Heh.  That sounds like a good place to start
16:03:36 <horse_kicker_> c_wraith : They aren't the same. I added the New_Stuff for a very specific purpose, but most of the occurrences of data is of type Blah1. What is the alternative for type casting?
16:04:25 <c_wraith> horse_kicker_: generally, unwrapping and re-wrapping.  Often, you create a higher-order function to do the process for you
16:05:23 <roconnor> catagory theory kinda looks like homotopy
16:05:29 <ddarius> roconnor: It should.
16:05:36 <roconnor> why should it?
16:06:36 <CaScAdE^Laptop> ok... i've got the next quesion: http://car.pastebin.com/yUfenZmq <-- why is the type infinit "a = MVar (MVar a)" in line 13?
16:06:37 <j-invariant> homotopy invented category theory
16:06:50 <roconnor> j-invariant: ah
16:07:05 <c_wraith> CaScAdE^Laptop: You've just declared that a contains itself.  That's infinite.
16:07:06 <roconnor> so arrows are generalizations of homotopy paths?
16:07:25 <ddarius> roconnor: It arose in algebraic topology to deal with homotopy and homology.  Also, you can view the points in a manifold as forming a category, specifically a groupoid, with paths as arrows, but you'll want to weaken that repeatedly giving an ω-groupoid. 
16:07:37 <CaScAdE^Laptop> c_wraith: isn't a the type of the threadbuffer?
16:07:43 <c_wraith> CaScAdE^Laptop: In particular, you're not unwrapping the mvar before you try to write to it.
16:08:01 <c_wraith> CaScAdE^Laptop: It's inside a Threadbuffer
16:08:23 <roconnor> ddarius: yes.  That ties in nicely to this talk about interepeting Martin-Loef type theory as Homotopy.
16:08:32 <c_wraith> CaScAdE^Laptop: Oh, whoops,  I was misreading that.  Let me start over, correct this time. :)
16:08:42 <CaScAdE^Laptop> c_wraith: so the (ThreadBuffer mv) does not _unwrap_ it so that i can access it with mv?
16:08:52 <kuffaar> Haha, CaScAdE^Laptop, amazing, I actually thought I was looking at C++ code there for a second
16:08:57 <kuffaar> From your use of { ; }
16:09:08 <poincare101> I was wondering why it is easier to write parsers in functional languages (for example, pugs for perl 6), are there any good tutorials? I would also like a tutorial that doesn't use a parser generator, instead shows you how to write one.
16:09:11 <roconnor> It is facinating that intensional equality, which originally seems like a deficency of Martin-Loef type thoery, turns out to be exactly what is needed for the Homotopy interpretation.
16:09:17 <CaScAdE^Laptop> kuffaar: I am just getting started with haskell, sorry :)
16:09:36 <kuffaar> CaScAdE^Laptop you don't need to use {} or ; at all
16:09:49 <c_wraith> CaScAdE^Laptop: The actual problem is that element you're trying to put in the mvar is not the right type
16:09:51 <gwern> roconnor: oh, of course. how obvious, really
16:10:15 <CaScAdE^Laptop> kuffaar: but i like them, they are so neat :-) ok.. for real: too many languages in the past few months...
16:10:30 <roconnor> gwern: apparently all that time I wasted dealing with intestional equality wasn't a waste :D
16:10:43 <c_wraith> CaScAdE^Laptop: ah.  you have the argument order in tryPutMVar backwards.
16:10:50 <gwern> roconnor: I was being sarcastic, I really have no idea what you are talking about
16:10:57 <c_wraith> CaScAdE^Laptop: And that's...  resulting in a less-useful error message than it could
16:11:10 <CaScAdE^Laptop> c_wraith: d'oh... tanks...
16:11:19 <c_wraith> CaScAdE^Laptop: because it's trying to figure out how you could be right, and deciding "ah, if this is an infinite type, you did the right thing!"
16:11:33 <c_wraith> CaScAdE^Laptop: However, it then decides that using an infinite type is an error. :)
16:12:24 * gwern finally figures out error in SICP function. how very silly of me
16:12:40 <CaScAdE^Laptop> c_wraith: hehe... i will definitly hit my prof with that today since he always nags on all other languages and now i can nag back :)
16:13:14 <ddarius> roconnor: Also, you may want to work out, starting from Ob : Cat -> Set, what π ⊣ D ⊣ Ob ⊣ I are.
16:13:20 <ddarius> If you haven't done it before.
16:13:51 <gwern> (sometimes in #haskell I feel like a bag-of-blood human surrounded by 1000 year old vampires)
16:13:52 <c_wraith> CaScAdE^Laptop: well.  It was an error.  It just wasn't reporting it the best way possible. :)
16:14:10 <ddarius> gwern: ?
16:14:22 <gwern> ddarius: well, you know. vampires get more powerful the older they are
16:14:40 <CaScAdE^Laptop> c_wraith: yes, sure, but he is so very super proud of haskell and now i can at least say that i like the error reporting of other languages more :)
16:14:46 <roconnor> ddarius: I don't know how to read  π ⊣ D ⊣ Ob ⊣ I 
16:14:58 <copumpkin> tolkad: there is a primop for logical shift on Int#
16:15:04 <_jb> oh, good. newsham is alive.
16:15:06 <copumpkin> tolkad: just came across it by chance now
16:15:31 <CaScAdE^Laptop> c_wraith: till now i even liked erlang more... 
16:15:46 <ddarius> roconnor: Given Ob, the set of objects functor, what is its right adjoint, I, left adjoint, D, and what is D's left adjoint π.
16:15:57 <tolkad> copumpkin: oh. too bad it's not in the API
16:16:41 <roconnor> ddarius: given that I don't know too much about adjoint functors, that would be a good exercise :)
16:16:47 <roconnor> that would give me practice
16:17:10 <ddarius> roconnor: It's an exercise in the first chapter of TTT I think or somewhere.  I'm definitely stealing it.
16:17:40 <roconnor> ddarius: does this exercise have anything to do with homotopy?
16:17:56 <ddarius> roconnor: A little bit, yes.  π is named π for a reason.
16:18:02 <roconnor> :)
16:20:08 <tolkad> Is there any way to set the default type to use for a parametric data type argument?
16:20:35 <aavogt> tolkad: have you looked at HList?
16:20:38 <tolkad> hmm, maybe somehow by abusing OverlappingInstances
16:20:48 <aavogt> I don't understand what you mean by default though
16:20:54 <gwern> @quote HList
16:20:54 <lambdabot> gwern says: if hlist is the answer, I don't want to know the question
16:21:15 <tolkad> aavogt: kind of like the way you can set the default integral type to use
16:21:28 <aavogt> tolkad: you can also add a Num constraint, then in your file have     default Foo
16:22:08 <tolkad> aavogt: ooh, good idea. so dummy Num types combined with type classes involving fundeps on those dummy types
16:22:13 <roconnor> BTW, what are the algebras of the state monad?
16:22:26 <aavogt> tolkad: I don't think that works
16:22:41 <aavogt> tolkad: the defaulting happens after instance selection as far as I can tell
16:23:56 <tolkad> oh too bad that would have been great
16:24:18 <aavogt> tolkad: what you can do is have your actual types be in Num though they have nothing to do with it
16:24:26 <tolkad> wtf is this stuff? http://hackage.haskell.org/packages/archive/HList/0.2.3/doc/html/Data-HList-FakePrelude.html
16:24:44 <tolkad> OOP in haskell? 0_o
16:25:01 <hpc> http://files.sharenator.com/wtf_is_this_shit_Very_Disturbing_Childrens_Book-s400x297-59009-580.jpg
16:25:43 <gwern> tolkad: it's more likely than you think
16:26:02 <ddarius> http://utilitybidder.co.uk/
16:26:28 <tolkad> well... it would make my code more enterprise-ready
16:26:44 <hpc> tolkad: but would it make it webscale?
16:26:44 <gwern> ddarius: 'If you are another web developer that has been paid to change this then make sure you get paid up front.
16:26:46 <gwern> ?
16:26:47 <hpc> i think not
16:26:48 <aavogt> people already do OOP stuff though
16:27:00 <monochrom> only Kirk and Picard are enterprise-ready
16:27:12 <ddarius> Damn straight.
16:27:59 <CaScAdE^Laptop> c_wraith: thanks again... I think now the example is working... spent two hours reading before i thought there has to be a haskell channel ^^
16:28:08 <hpc> monochrom++
16:28:15 <monochrom> hehe
16:30:07 <dibblego> hey edwardk are you there?
16:30:19 <CaScAdE^Laptop> looking at the code and remembering how much code it was in java i think haskell has it pros :)
16:30:37 <c_wraith> CaScAdE^Laptop: you're welcome.  This is a good place to ask any questions related to haskell.  If you want to keep up learning, keep asking stuff here. :)
16:31:35 <CaScAdE^Laptop> c_wraith: since it is only 01:39 here i think i will try the next task now and will get back to the offer
16:50:02 <CaScAdE^Laptop> ok... the next one: how can i have the whole variable and its members in one function?
16:50:32 <CaScAdE^Laptop> like i need the whole ThreadBuffer and a member if it
16:50:42 <ezyang> Hey guys, I was thinking about Matlab and Haskell and it occurred to me that there might be a kind of extension to applicative functors which covers matrix "slicing" 
16:50:42 <copumpkin> hm
16:50:51 <copumpkin> I have no idea what you're asking, but I'm going to guess the answer is @
16:50:57 <monochrom> f x@(ThreadBuffer y) = ... now you can use both x and y ...
16:51:16 <ezyang> Essentially, I can lift [a] -> [b] to [[a]] -> [[b]] in two ways: doing it row-wise or column-wise 
16:51:25 <CaScAdE^Laptop> monochrom: thanks
16:51:51 <aavogt> ezyang: or diagonal-wise or random-wise
16:51:53 <ezyang> Applicative functors force you to do it by row (assuming I have a list of rows) in order to satisfy the applicative laws, I think. 
16:52:05 * sm reads http://gbracha.blogspot.com/2011/01/maybe-monads-might-not-matter.html
16:52:05 <ezyang> aavogt: Heh. 
16:52:15 <copumpkin> sm: it just annoyed me
16:52:33 <aavogt> well that article is Just not right
16:52:39 <monochrom> maybe blogs might not matter
16:52:42 <ivanm> preflex: seen edwardk 
16:52:42 <preflex>  edwardk was last seen on #haskell 3 hours, 17 minutes and 43 seconds ago, saying: hahahaha
16:53:32 <ezyang> But then you get exponentially more liftings from [a] -> [[[a]]] and [[a]] -> [[[a]]] 
16:53:38 <ezyang> (well, more like binomially more) 
16:54:08 <ezyang> But the structure is kind of too vague for me to figure out right now... 
16:54:14 <tolkad> I was looking at the advanced state monad. it seems to be a mess because it has so many different features to the same data type. they should have used complex type-system madness to allow you to specify which features you want
16:54:34 <aavogt> tolkad: what does it do to be advanced?
16:54:36 <Peaker> tolkad, what features do you mean?
16:55:17 <monochrom> perhaps that's why it's called "advanced". too many features.
16:55:40 <tolkad> http://hackage.haskell.org/package/stm-io-hooks-0.7.1
16:56:25 <tolkad> http://hackage.haskell.org/packages/archive/stm-io-hooks/0.7.1/doc/html/src/Control-Monad-AdvSTM-Def.html#AdvSTM
16:57:27 <tolkad> Peaker: for example, readTVarAsync and onCommit are seperate features
16:57:33 <ezyang> I guess if there are no other examples of applicative functors having this structure it's not a very generic structure. 
16:57:43 <Peaker> tolkad, that's not the state monad, you mean STM?
16:57:48 <tolkad> the debug mode could by worked into the type of the monad
16:57:54 <Peaker> tolkad, "Software Transactional Memory"?
16:57:58 <tolkad> Peaker: whoops I meant advanced stm
16:58:07 <tolkad> Peaker: I thought stm, said state
16:58:39 <Peaker> tolkad, haven't used STM much, not sure if there's not enough granularity in the types
16:59:02 <geheimdienst> sm, good post, thanks
16:59:15 <tolkad> Peaker: each combination could be implemented seperately with a set of type classes that would allow you to say what features your functions need
16:59:43 <sm> sure thing
17:00:07 <monochrom> romantic conquest?! people really run out of analogies.
17:00:09 <sm> I'm waiting for some clarifying replies
17:00:23 <tolkad> f :: (MonadSTM m, MonadSTMWithThoseCommitHookThings m) => a -> m a
17:00:32 <sm> I don't yet grok why actors can be equivalent to monads
17:01:08 <monochrom> "MonadSTM is like romantic conquest. every time a transaction finishes successfully, you want to tell the whole world about it."
17:01:16 <Philippa> sm: there's a weird relationship where each (instance of a) monad is like an inverted actor and vice versa
17:01:33 <ezyang> What does he even mean by 'actor'? 
17:01:45 <sm> Philippa: quite interesting, thanks
17:02:19 <Philippa> in particular, contrast actors with what happens if you yank out a computation's 'state' while it's running (or start a second computation using that state at a later date)
17:02:29 <sm> ezyang: the asynchronous computing model described by carl hewitt
17:02:35 <tolkad> ezyang: someone who acts in theatre or moving pictures
17:03:03 <ezyang> oh hey, he's an MIT'er 
17:03:46 <ddarius> monochrom: Yeah, that one was really retarded.
17:04:02 <CaScAdE^Laptop> i don't get the error messages... i think that is the point why our prof told us we might hand in stuff that does not compile :)
17:04:02 <tolkad> Philippa: so what would be the type of the "yank" function?
17:04:41 <tolkad> CaScAdE^Laptop: you should abuse that to hand in ridiculous stuff
17:04:56 <monochrom> if you get type error messages, don't try to find out what "expected" "inferred" means. just focus on that fact that there is a conflict.
17:05:00 <CaScAdE^Laptop> tolkad: I will... but I am still curious for myself :)
17:05:31 <ezyang> ...is it ok if I think of actors as message passing? 
17:05:52 <geheimdienst> btw, "inferred" is the word for the type that ghc actually found in your code
17:06:09 <monochrom> "expected type Int, inferred type Char" simply means the thing is required to be Int from one perspective, is required to be Char from another perspective, contradiction.
17:06:24 <CaScAdE^Laptop> tolkad: first thought of handing in assembler code... or brainfuck... 
17:06:38 <Philippa> expected is what it got before it looked inside that AST node, inferred's what it had when it got back out
17:07:00 <Philippa> (modulo constraint resolution!)
17:07:52 <monochrom> In principle you could also do the type analysis yourself and find out the same contradiction, if you make no mistakes.
17:08:47 <sm> could we say: a monadic do block is sort of equivalent to an interaction over time with an actor ?
17:09:10 <Philippa> sm: definitely
17:09:12 <monochrom> "sort of" invites an unfalsifiable "yes"
17:09:44 <Philippa> the "actor" is an abstract machine executing monadic code, the do block is stringing together some code, the run function or similar sets it rolling
17:09:58 <CaScAdE^Laptop> ok, i get the point... but how to create that data-stuff anyways? i was trying http://car.pastebin.com/DW4p5LsT but that seems to be heavily wrong
17:09:59 * geheimdienst writes a blog post that explains actors with a metaphor everyone can understand. "an actor is much like a monad ..."
17:10:07 <copumpkin> lol
17:10:33 <monochrom> so many MVar's...
17:11:01 <monochrom> oh haha. return (ThreadBuffer mv counter current). that is all.
17:11:37 <CaScAdE^Laptop> monochrom: the lecture is about distributed and concurrent programming, so MVars come in handy for everything... and so i am abusing them :)
17:12:09 <monochrom> the deep type error is due to (((return ThreadBuffer) mv) counter) current  and you can see it is going to be a type error.
17:12:11 <Philippa> geheimdienst: there's a reason or two for the idea I'm talking about, FWIW - not least that it becomes more useful when you're talking about a system built out of components running in different monads
17:12:23 <ddarius> MVars aren't particularly handy for distributed programming (at least, not beyond their handiness for concurrent programming.)
17:12:50 <tolkad> CaScAdE^Laptop: one = sum (map (1/) (map (2^) [1..100]))
17:13:15 <tolkad> CaScAdE^Laptop: it's psuedocode right?
17:13:42 <tolkad> CaScAdE^Laptop: ooh, use infinite types
17:13:53 <monochrom> createThreadBuffer::MVar a -> IO (ThreadBuffer a)
17:13:55 <tolkad> write the y combinator in lambda calculus
17:14:37 <CaScAdE^Laptop> ahh the damn IO stuff... 
17:15:00 <monochrom> well you use newMVar and you write "do"...
17:15:01 <geheimdienst> Philippa: okay, thanks for the explanation :) i've just downloaded the hewitt paper
17:16:43 <Philippa> geheimdienst: it's especially useful because it leaves you able to talk OO-like system architecture in terms that an OO practitioner can get their head round /without/ stopping you from exploiting various abilities or forcing you to just write OO in haskell
17:21:48 <CaScAdE^Laptop> currently i still have three errors dealing with expected IO <sometype> and inferred <sometype>
17:21:58 <monochrom> show updated code
17:22:23 <CaScAdE^Laptop> http://car.pastebin.com/8k8LzAtR
17:22:33 <monochrom> and don't forget return (ThreadBuffer mv counter current)
17:22:45 <CaScAdE^Laptop> that part works
17:22:49 <CaScAdE^Laptop> the later ones not
17:23:27 <monochrom> writeThreadBuffer:: ThreadBuffer a -> a -> IO()
17:23:28 <CaScAdE^Laptop> although i blindly added IO to the signature part but does not know how to add it to the method declartion itself
17:23:53 <monochrom> similarly readThreadBuffer::ThreadBuffer a -> IO a
17:24:17 <monochrom> cnt <- readMVar current
17:25:04 <monochrom> similarly cnt <- takeMVar counter
17:27:31 <CaScAdE^Laptop> ok... now it compiles...
17:27:36 <CaScAdE^Laptop> going to test it :)
17:31:01 <CaScAdE^Laptop> ok... the waiting threads do not suspend... thats not so nice...
17:31:27 <CaScAdE^Laptop> but that is more an question to the basic idea, not to the haskell code :)
17:32:12 <CaScAdE^Laptop> thanks for your help folks, i really appreciate it...
17:32:18 <gwern> offhand, does anyone know what the ghci option is that suppresses printing out that annoying 'forall x.' stuff when it prints an inferred type?
17:32:19 <monochrom> you're welcome
17:32:49 <CaScAdE^Laptop> but my girlfriend just walked in and told me i have to come to bed :)
17:32:58 <locks> don't
17:33:05 <locks> she'll win
17:33:17 <locks> DON'T GIVE IN
17:33:17 <aavogt> gwern: -fno-print-explicit-foralls ?
17:33:30 <aavogt> gwern: :set has tab completion
17:33:59 <CaScAdE^Laptop> locks: she has to be at school in 4 hours... i will try the haskell stuff again then :)
17:34:15 <locks> haha :P
17:34:18 <CaScAdE^Laptop> good night 
17:34:28 <locks> night o/
17:34:47 <gwern> aavogt: hm, not sure that worked
17:35:05 <aavogt> gwern: it might have to do with some extensions you've enabled
17:35:17 <elliott> What should I use to parse lazy bytestrings? Parsec 3?
17:35:26 <monochrom> yeah
17:35:34 <elliott> Hrm...
17:35:44 <elliott> Or maybe I can use strict bytestrings and get the Attoparsec love.
17:35:50 <monochrom> too
17:35:58 <elliott> Yeah, I think I can.
17:36:06 <augur> ELLIOTT! O_O
17:36:14 <monochrom> I just mean to say parsec 2 doesn't know bytestrings
17:36:23 <elliott> Are you going to go "ELLIOTT!" every time I say anything in here, augur? :P
17:36:25 <elliott> monochrom: right
17:36:29 <augur> elliott: its possible.
17:36:36 <copumpkin> augur!!!!!!!!!
17:36:42 <augur> copumpkin!
17:36:44 * augur hugs copumpkin
17:37:06 <augur> anyone have a good suggestions for constraint satisfaction as a theoretical issue and as a practical issue?
17:37:14 <augur> reading suggestions, i mean
17:38:47 <ddarius> augur: The stuff behind Oz.
17:39:00 <augur> ddarius: ?
17:39:10 <ddarius> @google mozart/oz
17:39:12 <lambdabot> http://www.mozart-oz.org/
17:39:12 <lambdabot> Title: The Mozart Programming System
17:39:12 <tg_> http://en.wikipedia.org/wiki/Oz_(programming_language)
17:39:53 <xxerxes> ddarius: FATHER
17:39:53 <ddarius> http://www.mozart-oz.org/papers/#constraints
17:40:05 <augur> ill check it out :D
17:41:25 <ddarius> Hmm, the links go nowhere for me, but you can google the titles.  Christian Schulte and Gert Smolka are two good authors in that area.
17:47:23 <dibblego> is there an agreed iteratee interface yet?
17:53:47 <Peaker> dibblego, enumerators is hot now?
17:53:58 <Peaker> I'd guess enumerators is where the trends are pointing
17:54:07 <dibblego> Peaker, I guess
18:08:58 <copumpkin> gah, adding a primop to GHC seems to force it to pretty much rebuild everything
18:12:31 <elliott> When do we get OverloadedChars so we can use '\n' for (10::Word8)? :)
18:13:59 <tolkad> elliott: why not just use Ord?
18:14:05 <tolkad> err ord
18:14:13 <elliott> tolkad: ugly! :)
18:14:17 <elliott> tolkad: also because
18:14:18 <elliott> :t ord
18:14:19 <lambdabot> Char -> Int
18:14:23 <elliott> :t (ord :: Char -> Word8)
18:14:24 <lambdabot>     Couldn't match expected type `Word8' against inferred type `Int'
18:14:24 <lambdabot>     In the expression: (ord :: Char -> Word8)
18:14:32 <elliott> :t (fromIntegral . ord :: Char -> Word8)
18:14:33 <lambdabot> Char -> Word8
18:14:39 <elliott> tolkad: don't wanna go around writing "fromIntegral (ord '\n')"!
18:15:11 <tolkad> elliott: just write an Integral instance for Char and use it instead of Word8 then
18:15:20 * BMeph likes "wOrd = fromIntegral . ord"...
18:15:30 <elliott> tolkad: heh
18:15:36 <elliott> tolkad: no, because e.g. attoparsec is word8 only
18:15:40 <elliott> as well as so many bytestring things
18:15:44 <elliott> because that's... what a Char8 bytestring is
18:15:50 <tolkad> elliottrewrite them
18:16:10 <elliott> tolkad: rewrite attoparsec and every bytestring library ever?
18:16:15 <elliott> what are you smoking? :)
18:16:15 <tolkad> elliott: ghc shouldn't be changed to accomadate available libraries
18:16:30 <elliott> tolkad: then what's overloadedstrings
18:16:30 <tolkad> accomodate*
18:16:36 <elliott> oh yeah, something to make writing ByteStrings (and Texts) easier
18:16:52 <elliott> tolkad: ooh, or, wait, what's the entire language ... something to make things easier...
18:17:10 <yip> i'm using HUnit. is it ok style to do something like: do (Right _) <- foo; return ()
18:17:16 <yip> to make sure that foo returns a Right value?
18:17:17 <tolkad> elliott: I do think the language should include an Integral instance for Char
18:17:36 <yip> or should i explicitly use the HUnit assert checks and not rely on pattern match failure?
18:17:49 <tolkad> hmm, actually maybe that's a terrible idea nevermind
18:17:49 <elliott> tolkad: agreed there... but still, OverloadedStrings and not OverloadedChars is a bit of a weird imbalance
18:18:49 <astroboy> is it possible to unmask ~x86 just for a category, or just for an overlay?
18:18:56 <Philonous> tolkad: Adding chars might even be sensible. But multiplying them?
18:19:41 <yip> subtracting chars is very sensible
18:20:15 <tolkad> yip: you could do: « err x = mapException ((PatternMatchFail _) -> ErrorCall  ("Unit test failed: " ++ x)) » « err "foo" $ do (Right _) <- foo; return () »
18:20:23 <tolkad> Philonous: yeah
18:20:34 <tolkad> Philonous: perhaps a Floating instance too
18:20:39 <ManateeLazyCat> Hi all. :)
18:20:57 <c_wraith> what was the name for things where subtracting them makes sense, but the type of the result is not the same as the type of the two subtraction operands?
18:21:02 <astroboy> sorry, wrong channel...
18:21:07 <astroboy> join #gentoo
18:21:14 <astroboy> ahhhhh I need some sleep lol
18:21:14 <tolkad> ok
18:22:58 <ddarius> copumpkin: That shouldn't be surprising.
18:23:13 <yip> tolkad: that looks pretty complicated :|
18:24:18 <copumpkin> ddarius: it isn't, really, but annoying :/
18:25:03 <tolkad> yip: you only have to define the err function once. then you can use it to catch your pattern match fails
18:25:21 <tolkad> yip: and give them meaningful error messages
18:26:45 <elliott> <Philonous> tolkad: Adding chars might even be sensible. But multiplying them?
18:27:06 <elliott> Philonous: clearly '>' * '\3' == '⋙'
18:27:14 <yip> tolkad: interesting... but HUnit already seems to do this and gives me a useful error message mentioning the pattern match failure and the location in the source file
18:28:04 <geheimdienst> > '\3'
18:28:05 <lambdabot>   '\ETX'
18:28:33 <geheimdienst> 'd' * -1 == 'p'
18:28:36 <elliott> yip: then it's probably a supported feature and you should just do it :P
18:28:40 <elliott> geheimdienst: absolutely
18:28:45 <elliott> > '\-1'
18:28:46 <lambdabot>   <no location info>:
18:28:46 <lambdabot>      lexical error in string/character literal at chara...
18:28:48 <elliott> > chr (-1)
18:28:49 <lambdabot>   *Exception: Prelude.chr: bad argument: (-1)
18:28:54 <elliott> oh, wait
18:28:55 <poincare101> are there any haskell IDEs? (I come from java)
18:28:58 <tolkad> yip: oh nevermind then
18:28:59 <elliott> what's the maximum unicode codepoint?
18:29:01 <geheimdienst> oh yeah, let's have complex Chars
18:29:07 <geheimdienst> > maxBound :: Char
18:29:09 <lambdabot>   '\1114111'
18:29:09 <elliott> poincare101: there's a few, but most people use Emacs... well that's my perception.
18:29:14 <elliott> poincare101: Leksah seems to be quite popular.
18:29:25 <elliott> geheimdienst: 'd' * '\1114111' == 'p' then
18:29:37 <tolkad> poincare101: I've heard Emacs is terrible. use vim
18:29:55 <tolkad> poincare101: you probably don't even have enough RAM to run Emacs. it's massive
18:30:10 <elliott> tolkad: loltroll
18:30:22 <elliott> any java programmer has enough ram to run 8192 instances of Emacs
18:30:23 <elliott> :D
18:30:34 <poincare101> Java sucks.
18:30:51 <JoeyA> Emacs has snake.  
18:31:02 <poincare101> what's snake?
18:31:06 <JoeyA> A game
18:31:44 <JoeyA> Someone go write Snake in Haskell so poincare101 can play it.
18:31:55 <JoeyA> (sorry, I'm giving in to the peer pressure to troll)
18:32:01 * elliott M-x tetris
18:34:05 <Philippa_> elliott: not true - Eight Megs And Constantly Swapping, most java programmers aren't on 64GB yet :-)
18:34:17 <elliott> Philippa_: you haven't seen the latest Eclipse release
18:34:34 <elliott> man, i can't run 8192 emacsen without swapping...that's just weird, i feel like computers are magical these days
18:34:35 <Philippa_> elliott: I don't have to. Consumer mobos still aren't good for 64GB though
18:34:40 <elliott> and 8192 is such a small power of two
18:34:58 <JoeyA> Computers are getting faster and faster every day, so who cares about performance.
18:34:59 <elliott> Philippa_: Pedantic arguments about jokes based on other jokes!
18:35:12 <JoeyA> I woke up this morning, and suddenly my computer has 4 cores.  I still don't know how it happened.
18:35:18 <elliott> JoeyA: I forget whose law it is but it's certainly someone's, that software is getting slower faster than hardware is getting faster.
18:35:24 <elliott> :-D
18:35:28 <c_wraith> you were visited by the core fairy
18:35:30 <ddarius> JoeyA: Data production rates are getting faster even faster.
18:35:31 <elliott> "Hey, another ten gigabytes of RAM?!"
18:35:38 <elliott> "SWEET! Thanks, Moore!"
18:37:50 <JoeyA> I wish they made 1GB floppy disks, if only for the nostalgia factor.
18:38:03 <parcs> @pl (($ x) . ($ y))
18:38:04 <lambdabot> flip ($ y) x
18:38:32 <JoeyA> On the other hand, people will have to hear "Don't Copy That Floppy" again.
18:38:52 <kuffaar> Hahaha
18:39:51 <elliott> JoeyA: Well they did make Don't Copy That 2.
18:40:02 <JoeyA> 2. ?
18:40:06 <elliott> Yes.
18:40:07 <elliott> A sequel.
18:40:10 <JoeyA> Oh
18:40:18 <elliott> With the same guy.
18:40:34 <elliott> It's ... uh ... oh, just watch it: http://www.youtube.com/watch?v=hUCyvw4w_yk
18:42:06 <tolkad> @pl (\x -> x x x x x x x x x x x x)
18:42:06 <lambdabot> join (join (join (join (join (join (join (join (join (join (join id))))))))))
18:42:29 <tolkad> oh that's useful
18:45:42 <jmcarthur> one of the more interesting uses of @pl i've seen, i think
18:45:47 <jmcarthur> s/uses/results/
18:45:59 <Philippa_> ddarius: I expect data production to mostly tail off for most purposes once lifelogging's commonplace, FWIW
18:46:10 <jmcarthur> would that even type check?
18:46:13 <jmcarthur> :t join id
18:46:14 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
18:46:14 <lambdabot>     Probable cause: `id' is applied to too few arguments
18:46:14 <lambdabot>     In the first argument of `join', namely `id'
18:46:27 <jmcarthur> :t (\x -> x x x x x x x x x x x x)
18:46:28 <lambdabot>     Occurs check: cannot construct the infinite type:
18:46:29 <lambdabot>       t = t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> t -> t1
18:46:29 <lambdabot>     Probable cause: `x' is applied to too many arguments
18:46:37 <parcs> @pl \a b -> f a (g b)
18:46:38 <lambdabot> (. g) . f
18:46:47 <JoeyA> @pl luke (\x -> ((the dark side)) (of the force) x x)
18:46:47 <lambdabot> luke (join (the dark side (of the force)))
18:47:18 <elliott> :D
18:47:30 <ddarius> Philippa_: Unfortunately the real bad producers are things like the LHC and imaging satellites.
18:47:37 <tolkad> @pl version
18:47:37 <lambdabot> (line 1, column 1):
18:47:37 <lambdabot> unexpected "\SOH"
18:47:37 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
18:47:48 <elliott> Lifelogging...heh
18:48:18 <tolkad> lol Quassel appears to respond to CTCP in the middle of messages. I think that goes against the specification
18:48:36 <elliott> tolkad: no actually
18:48:40 <elliott> that's part of the specification
18:48:42 <elliott> just nobody implements it
18:48:43 <tolkad> really? huh
18:48:46 <elliott> the more you know :P
18:48:54 <c_wraith> :t join id
18:48:55 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
18:48:56 <lambdabot>     Probable cause: `id' is applied to too few arguments
18:48:56 <lambdabot>     In the first argument of `join', namely `id'
18:49:02 <elliott> can anyone get @pl to spit out something starting with !, ` or ^? thx
18:49:04 <elliott> (>_>)
18:49:41 <c_wraith> Oh.  I see I'm a bit late on the join id thing.
18:49:47 <c_wraith> Yeah, that looked pretty wrong.
18:50:30 <tolkad> @pl (`x` 5)
18:50:30 <ddarius> elliott: That very unlikely.
18:50:30 <lambdabot> (`x` 5)
18:50:35 <tolkad> @pl `x` 5
18:50:35 <lambdabot> (line 1, column 1):
18:50:36 <lambdabot> unexpected "`"
18:50:36 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
18:50:56 <elliott> ddarius: Look, it doesn't have a space in it, so as far as I'm concerned it's a high-priority target for botlooping! :P
18:51:28 <tolkad> elliott: I got a loop between scalabot and lambdabot once
18:51:50 <tolkad> elliott: scalabot ignores lambdabot now though : (
18:51:51 <elliott> Scalabot? Ha, I'm going for EgoBot, HackEgo and fungot :P (in #esoteric)
18:51:59 <elliott> are there even any other bots in here?
18:52:08 <elliott> tolkad: yeah bot ignores are tough :(
18:52:09 <ddarius> Yes, several.
18:52:19 <elliott> such channel traditions are dying out :(
18:53:20 <djahandarie> Why doesn't lambdabot just sanitize everything it privmsgs?
18:53:29 <elliott> djahandarie: ENEMY OF FUN
18:53:33 <ddarius> I thought that that was added at one point.
18:53:36 <elliott> sheesh.
18:54:55 <djahandarie> elliott, or maybe the bringer of productivity :)
18:55:03 <john_r_watson> why does this work:
18:55:04 <elliott> djahandarie: Productivity? With lambdabot?
18:55:05 <tolkad> elliott: some output of lambdabot wordwraps
18:55:08 <elliott> I cannot imagine such an event.
18:55:10 <elliott> tolkad: oooh
18:55:16 <djahandarie> elliott, exactly.
18:55:38 <john_r_watson>  
18:55:38 <john_r_watson> answer = (0==) . (foldl step 0)
18:55:38 <john_r_watson>   where step (-1) c  = (-1)
18:55:39 <john_r_watson>         step n   '(' = (n+1)
18:55:43 <john_r_watson>         step n   ')' = (n-1)
18:55:44 <c_wraith> @quote product
18:55:44 <lambdabot> mauke says: product `liftM` liftM read `liftM` liftM return `liftM` take 5 $ "1234567"
18:55:46 <john_r_watson>         step n    _ =   n
18:55:50 <john_r_watson> and not this:
18:55:52 <djahandarie> john_r_watson, don't paste stuff
18:55:53 <john_r_watson> answer = (0==) . (foldr step 0)
18:55:56 <john_r_watson>   where step c (-1)  = (-1)
18:55:57 <ddarius> djahandarie: If that were the case, you'd be attack freenode's ircd.
18:55:59 <john_r_watson>         step '('   n = (n+1)
18:55:59 <john_r_watson>         step ')'   n = (n-1)
18:56:01 <djahandarie> -_-
18:56:02 <tolkad> elliott: abuse that for multiline exponential botloops
18:56:02 <john_r_watson>         step _    n =   n
18:56:06 <john_r_watson>  
18:56:09 --- mode: ChanServ set +o copumpkin
18:56:17 <djahandarie> john_r_watson, http://hpaste.org
18:56:18 <elliott> ooh i love flodding
18:56:19 <elliott> it's the funnest
18:56:26 --- mode: copumpkin set -o copumpkin
18:56:30 <copumpkin> trust me to notice just when it's too late
18:56:35 <elliott> > product `liftM` liftM read `liftM` liftM return `liftM` take 5 $ "1234567"
18:56:35 <lambdabot>   120
18:56:47 <elliott> copumpkin: i guess that's why they call you copumpkin!
18:56:56 <JoeyA> I wish I could use the function composition operator in English.
18:57:00 <JoeyA> the style of the music of "Sacrificial Dance"
18:57:05 <tolkad> copumpkin: no revenge kick?
18:57:10 <JoeyA> the (style . music) of "Sacrificial Dance"
18:57:25 <copumpkin> tolkad: we don't really do that here :P
18:57:27 <elliott> tolkad: nah, if they did that they'd have to call him cocopumpkin!
18:57:46 <elliott> meanwhile, in which Gilad Bracha argues that actors are better than monads: http://gbracha.blogspot.com/2011/01/maybe-monads-might-not-matter.html
18:57:50 <elliott> :troll:
18:58:07 <elliott> ""The most important practical contribution of monads in programming is, I believe, the fact that they provide a mechanism to interface pure functional programming to the impure dysfunctional world." <-- HASKELL RAGE
18:58:13 <BMeph> JoeyA: You mean "the music style of Sacrificial Dance"? ;þ
18:58:14 <copumpkin> elliott: you should write a blog post about how exponentiation is better than ascii, as you suggested
18:58:27 <copumpkin> elliott: you on twitter btw?
18:58:38 <elliott> copumpkin: yes well you see ascii can't represent characters not in the latin alphabet, while exponentiation can produce big numbers very quickly
18:58:39 <elliott> which is useful
18:58:42 <elliott> copumpkin: no, i'm not
18:58:52 <elliott> well i think i have like two accounts but i don't use them ever
18:58:55 <copumpkin> oh
18:59:01 * ddarius doesn't see why anyone would be on twitter.
18:59:06 <elliott> i'm too cool, i use irc as twitter
18:59:14 <copumpkin> ddarius: it's how I found out about pigworker's paper!
18:59:18 <elliott> just look at the #esoteric logs or something, you can even retweet them if you want!
18:59:22 <yip> @quote
18:59:23 <lambdabot> Entropy says: I agree; we need to remove Emacs' ridiculous dependency on a kernel being present
18:59:32 * copumpkin just added a primop to GHC
18:59:35 <copumpkin> I wonder if it works
18:59:46 <djahandarie> copumpkin, for what?
18:59:51 <ddarius> copumpkin: Authors need to put up RSS feeds for their publication page.
19:00:01 <elliott> djahandarie: making nonsensical analogies, like a duck trapped in water
19:00:06 <copumpkin> a fast memcpy for unpinned things
19:00:14 <elliott> or that
19:00:15 * ddarius really wishes David Hestenes had such a setup so I would know about his now rare publications.
19:00:15 <djahandarie> elliott, something makes me doubt a primop is required for that.
19:00:32 <elliott> djahandarie: Well, you'd think, but it's kinda like you're all out of anchovies, and the doorbell is ringing.
19:01:02 <copumpkin> and while poking around in the primops, I found the most horrifying thing!
19:01:07 <copumpkin> you'll never believe it
19:01:14 <elliott> C code????
19:01:17 <elliott> OH DEAR GOD
19:01:19 <copumpkin> I found this:
19:01:20 <elliott> *C-- i guess
19:01:20 <copumpkin> atomicModifyMutVar# :: MutVar# s a -> (a -> b) -> State# s -> (#State# s, c#)
19:01:27 <copumpkin> now, what's horrifying
19:01:29 <elliott> funny! i just saw that after loading up your twitter!
19:01:33 <elliott> yes, it treats the b as a pair!
19:01:35 <copumpkin> is that the b is actually an (a, b)
19:01:38 <copumpkin> c
19:01:40 <elliott> *(a, c)
19:01:40 <elliott> lol
19:01:41 <copumpkin> yep :P
19:01:43 <elliott> (1,(1,(1,(1,...
19:01:47 <elliott> fix (1,)
19:01:48 <copumpkin> shush
19:01:55 <elliott> are tuple sections included in caleskell?
19:01:57 <elliott> > (1,) 2
19:01:58 <lambdabot>   Illegal tuple section: use -XTupleSections
19:02:01 <elliott> Cale: BUG REPORT
19:02:04 <copumpkin> I asked him to turn it on
19:02:11 <copumpkin> but he said it broke something else
19:02:23 <copumpkin> anyway, does that not make your skin crawl?
19:02:23 <elliott> this is why Caleskell will never be usable for Real Enterprise Programming
19:02:40 <elliott> copumpkin: it has a # in it, my skin prepares for crawling
19:02:45 <elliott> and counteracts the effects
19:02:53 <copumpkin> well, # aren't typically that evil
19:03:22 <elliott> copumpkin: also "ModifyMutVar"
19:03:25 <tolkad> > (# 5, 2 #)
19:03:26 <lambdabot>   Illegal binding of unboxed tuple e_152 :: (# t_a3hH, t_a3hJ #)
19:03:37 <elliott> > (# f, g #)
19:03:38 <tolkad> nice error message
19:03:38 <lambdabot>   Illegal binding of unboxed tuple e_1 :: (# a, a #)
19:03:43 <elliott> > fst# (# f, g #)
19:03:44 <lambdabot>   Not in scope: `fst#'
19:03:46 <copumpkin> > case (# 5 , 2 #) of (# x, y #) -> x
19:03:47 <lambdabot>   5
19:03:48 <Maxdamantus> > fix (,) 1
19:03:49 <lambdabot>   Occurs check: cannot construct the infinite type: a = b -> (a, b)
19:04:01 <copumpkin> no idea why lambdabot has unboxed tuples turned on
19:04:01 <elliott> > case (# x, y #) of (# foo, bar #) -> (f foo, g bar)
19:04:02 <lambdabot>   Ambiguous type variable `t' in the constraints:
19:04:02 <lambdabot>    `GHC.Show.Show t'
19:04:02 <lambdabot>      a...
19:04:08 <elliott> > case (# x, y #) of (# foo, bar #) -> (f foo, g bar) :: (Expr,Expr)
19:04:09 <lambdabot>   (f x,g y)
19:04:14 <elliott> copumpkin: FOR HIGH-PERFORMANCE PROGRAMMING
19:04:17 <copumpkin> oh okay
19:04:23 <elliott> HIGH-PERFORMANCE, UNBOXED, SYMBOLIC PROGRAMMING
19:04:37 <tolkad> but is it webscale
19:04:55 <elliott> yes.
19:06:16 * copumpkin shudders, writing his primop test code in ghci
19:06:21 <elliott> copumpkin: :D
19:06:26 <copumpkin> using the IO data constructor
19:06:48 <copumpkin> mmm
19:06:54 <elliott> I'd like to announce the GCC project: the Glasgow Caleskell Compiler.
19:07:08 <elliott> Update: GNU have accepted the Glasgow Caleskell compiler as part of the GNU operating system!
19:07:11 <elliott> The site is now located at http://gcc.gnu.org/.
19:07:48 <elliott> i think everyone's asleep
19:08:07 <copumpkin> boo, I got me a bus error
19:08:09 <tg_> but... but... who is running the internets?
19:08:15 <copumpkin> I probably broke something
19:08:32 <Maxdamantus> It's on autopilot.
19:08:59 <elliott> dammit attoparsec, why do you ask for more input! I'm using parseTest! There is no more input!
19:09:00 * BMeph waits for Cucurbitārum Deus Irae...
19:09:05 <elliott> Blasted piece of software!
19:09:32 <copumpkin> lol
19:09:53 <geheimdienst> BMeph: cucumber what?
19:10:48 <BMeph> geheimdienst: "pumpkin", not cucumber. Cucurbita is the genus of pumpkins.
19:11:00 <elliott> yay now it fails instead, o happy day
19:11:06 <monochrom> pumpkin god of wrath?
19:11:14 * BMeph nods
19:11:29 <copumpkin> dies is day though
19:11:38 <elliott> copumpkin isn't very wrath-like imo
19:11:39 <monochrom> yes but he wrote deus
19:11:43 <elliott> * ManateeLazyCat (~user@222.86.102.167) has left #haskell ("ERC Version 5.3 (IRC client for Emacs)")
19:11:43 <geheimdienst> cucupumpkirum deus irae
19:11:44 <copumpkin> he wrote dies before
19:11:46 <elliott> isn't that the Manatee guy? :-)
19:11:52 <elliott> using Emacs :-D
19:11:57 <monochrom> alright
19:11:58 * copumpkin likes that other 5th-declension word
19:12:00 <copumpkin> res
19:12:08 <elliott> in pumpkinas res
19:12:16 <copumpkin> origin of my favorite word in computer science
19:12:19 <copumpkin> "reification"
19:12:24 * BMeph hopes not to see the Cucurbitārum Dei Ira...
19:12:27 <copumpkin> literally, thingification
19:12:54 <geheimdienst> elliott: in medias pumpkin?
19:13:05 <elliott> yes.
19:13:08 <BMeph> Or "more literally", ting-making. ;)
19:13:09 <elliott> in the middle of the pumpkin?
19:13:19 <elliott> ifification
19:13:27 <geheimdienst> looks iffy
19:13:29 <copumpkin> I think most people get the meaning of -fication 
19:13:36 <elliott> copumpkin: so clearly defication is the opposite of reification?
19:13:47 <copumpkin> defecation? :P
19:13:48 <BMeph> In cucurbitas veritas.
19:13:49 <teki> was Control.Parallel.Strategies updated between 6.10.3 and 6.12.3?
19:13:49 <teki> in the specs (http://www.haskell.org/ghc/docs/6.10.3/html/libraries/parallel/Control-Parallel-Strategies.html#1)
19:13:49 <teki> it seems that a Strategy is a type a -> (), but when I run :info Strategy in GHCi, I get that Strategy is a -> Eval a (where Eval a cannot be ())
19:13:53 <elliott> copumpkin: yeah
19:14:00 <copumpkin> BMeph: indeed!
19:14:09 <elliott> reificate >>= process >>= defecate
19:14:18 <elliott> the "digestion pipeline"
19:15:07 <monochrom> I think there is a special thing to do to tell attoparsec your input ends
19:15:18 <BMeph> teki: Strategy is known by many names... ;)
19:15:39 <elliott> monochrom: P.manyTill pLine P.endOfInput did it
19:15:46 <teki> BMeph: that's great, but it doesn't explain why rnf is a strategy in the specs and not a strategy in GHCi
19:16:00 <dibblego> @hoogle fix
19:16:01 <lambdabot> Data.Function fix :: (a -> a) -> a
19:16:01 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
19:16:01 <lambdabot> module Control.Monad.Fix
19:16:03 <yip> how can i export from a module a constructor without exporting the type itself?
19:16:18 <Axman6> that doesn't make any sense
19:16:19 <elliott> sweet another bug!!!!!
19:16:20 <monochrom> I think cannot be done.
19:16:26 <elliott> yip: erm no :P
19:16:30 <elliott> consider "foo = Cons ..."
19:16:33 <elliott> you can't give foo a type signature
19:16:34 <elliott> which is just weird.
19:16:46 <elliott> hmm
19:16:48 <elliott> well actually
19:16:49 <elliott> can you do this:
19:17:01 <elliott> module Blah (mkFoo) where data Foo = Foo; mkFoo = Foo
19:17:01 <elliott> ?
19:17:03 <BMeph> teki: Short answer: "A Wizard Did It" ;þ
19:17:09 <teki> BMeph: for example, why does parMap rnf (^2) [1..10] fail with a type error?  according to the current specs it should work...
19:17:26 <Axman6> hmm, is it possible to export only specific constructors?
19:17:32 <elliott> Axman6: yes.
19:17:33 <monochrom> yes
19:17:47 <yip> i think it makes sense, and i need to do this :/
19:17:57 <monochrom> module X(T(C)) where data T = C | D
19:18:32 <BMeph> monochrom: "X(T(C))"...I see what you did there!
19:18:52 <dibblego> yip, perhaps you should say why you think you need to do this (it really doesn't make sense)
19:18:53 <Axman6> PARTAY!
19:18:57 <monochrom> at least it's not W(T(F)) or T(L(A))
19:19:11 <edwardk> ivanm: here
19:19:11 <copumpkin> whoops, I forgot to return
19:19:12 <monochrom> what is XTC?
19:19:15 <copumpkin> that's probably why it's crashing
19:20:05 <teki> @type rnf
19:20:07 <lambdabot> Not in scope: `rnf'
19:20:21 <teki> @type Control.Parallel.Strategies.rnf
19:20:22 <lambdabot> Not in scope: `Control.Parallel.Strategies.rnf'
19:21:05 <yip> dibblego: i've managed :)
19:22:16 <yip> elliott: i actually can! but i prefer using the constructor explicitly
19:22:42 <elliott> yip: that's ... just evil, why would you ever want to do that
19:23:03 <elliott> yip: seriously, I would run a public campaign of hatred against anyone who exported a value without exporting its type :)
19:23:09 <copumpkin> woohoo, isn't crashing anymore
19:23:16 <copumpkin> now, is it actually doing anything
19:23:29 <yip> elliott: i am also exporting the type, just in another line, and ghc gives a warning about redundancy
19:23:34 <elliott> ah.
19:23:41 <elliott> yip: why not just do Type(Cons), ...
19:23:44 <elliott> like you're supposed to
19:23:45 <teki> @BMeph: alright so let's say i want to evaluate map (^2) [1..10] in parallel using parMap and strategy rnf
19:23:46 <lambdabot> Unknown command, try @list
19:23:57 <teki> BMeph: alright so let's say i want to evaluate map (^2) [1..10] in parallel using parMap and strategy rnf
19:24:08 <yip> elliott: i am using the preprocessor to conditionally export the constructor only for tests
19:24:13 <teki> BMeph: do you know what would be the correct syntax?
19:24:17 <copumpkin> omg yes it worked
19:24:18 <elliott> yip: yikes
19:24:27 <yip> ?
19:25:11 <monochrom> use #ifdef X Type(Cons) #else Type #endif
19:25:25 <yip> monochrom: yeah, that's what i'm doing. but it's ugly :(
19:25:34 <yip> (duplicated code)
19:25:51 <monochrom> warnings are meant to be ignored
19:25:57 <yip> heh
19:27:18 <teki> BMeph: never mind, as it turns out I was looking at http://www.haskell.org/ghc/docs/6.10.3/html/libraries/parallel/Control-Parallel-Strategies.html#1
19:27:18 <teki> BMeph: instead of http://hackage.haskell.org/packages/archive/parallel/2.2.0.1/doc/html/Control-Parallel-Strategies.html
19:27:18 <teki> BMeph: where it helpfully points out that rnf is no longer a strategy
19:27:25 <teki> BMeph: thanks for the help though
19:29:30 <Saizan> yip: you could have only (Cons) in the #ifdef, maybe
19:30:26 <kuffaar> Hmm I just realised a problem with my server code which uses forkIO. Now, in the past I used to pass around a print functio between all those functions which was partially applied to some stuff which would ensure synchronised console output so multiple threads would be able to print simultaneously without ruining the console output. Today I rewrote that using a ReaderT which I find far more elegant and less redundant. Now I noticed that forkIO :: IO
19:30:26 <kuffaar>  () -> IO ThreadId won't take my processClient :: ConnectionInformation -> DB.ByteString -> Maybe SCGIRequestLength -> LockedConsole IO () (where LockedConsole is a ReaderT blah blah). What should I do?
19:31:27 <yip> Saizan: that works :) but it is ugly
19:32:01 <kuffaar> How do I get my ReaderT stuff into the forkIO'ed function?
19:32:16 <kuffaar> In the past its signature used to be -> IO () so it worked fine
19:32:30 <kuffaar> LockedConsole IO () no longer matches the expected forkIO argument now hmm
19:32:40 <kuffaar> Since it takes an IO action would any further monads
19:34:04 <dibblego> @type \j -> let f a b = fix (j b) a in f
19:34:05 <lambdabot> forall t t1 t2. (t1 -> (t -> t2) -> t -> t2) -> t -> t1 -> t2
19:35:19 <dibblego> is there an unfix function somewhere to remove fix?
19:36:08 <kuffaar> How is that supposed to work? :o
19:36:22 <dibblego> make an explicit recursive call
19:36:25 <kuffaar> Wouldn't that require the function to be pure and injective?
19:36:59 <Saizan> kuffaar: see runReaderT
19:37:29 <djahandarie> You can newtype Fix f = Fix { unfix :: f (Fix f) } ;)
19:37:55 <kuffaar> Saizan ahh you can put the forkIO action in there?
19:38:07 <Saizan> kuffaar: no?
19:38:21 <Saizan> kuffaar: do r <- ask; forkIO $ runReaderT (processClient ...) r
19:38:35 <Saizan> + a liftIO
19:38:45 <Saizan> kuffaar: do r <- ask; liftIO $ forkIO $ runReaderT (processClient ...) r
19:39:59 <kuffaar> Hmm that requires me to mess with the underlying monadic implementation though
19:40:33 <Saizan> yep
19:40:45 <Saizan> you could abstract over that with a typeclass if you want
19:40:57 <Saizan> i think there's a package about that on hackage already
19:41:00 <monochrom> if it is your own monad, you should add a fork function to it.
19:41:06 <kuffaar> monochrom yeah it is
19:41:13 <kuffaar> monochrom is that even a common pattern?
19:41:51 <kuffaar> The thing is, after I got this working I wanted to add another ReaderT to the stack of monads hm
19:41:55 <monochrom> the package is monad-peel. but you don't need its full generality now. just roll your own fork
19:42:12 <kuffaar> On top of the current one
19:42:25 <kuffaar> For the server context
19:42:38 <copumpkin> I think this primop could be quite useful for vector
19:43:03 <Axman6> which primop?
19:43:11 <copumpkin> my new copyArray# primop
19:43:14 <copumpkin> and the upcoming ByteArray# version
19:45:31 <azaq23> If I have a series of functions which are QuickCheck tests (Testable (a -> b)) but which have a different arity, can I put them in a list and do mapM_ test [...]? How would the list need to be typed? Something like [...] :: Testable t => ...?
19:45:56 <kuffaar> @hoogle runReaderT
19:45:57 <lambdabot> Control.Monad.Reader runReaderT :: ReaderT r m a -> r -> m a
19:46:04 <kuffaar> There are two of them on hoogle for me
19:46:09 <kuffaar> One from mtl, one from transformers
19:46:16 <kuffaar> The mtl one is runReaderT :: ReaderT r a -> r -> m a
19:46:22 <kuffaar> Which looks quite different from that one
19:46:31 <kuffaar> m isn't part of the ReaderT signature there
19:46:36 <kuffaar> Odd
19:46:56 <copumpkin> Axman6: I'm trying to figure out how to run my benchmark on it from within my GHC build tree
19:46:59 <copumpkin> without installing the damn thing
19:47:02 <kuffaar> Are transformers and mtl totally different implementations or does mtl just import it?
19:47:10 <edwardk>  kuffar: the current mtl just re-exports the runReaderT from transformers
19:47:11 <copumpkin> but unsurprisingly it won't see my system criterion
19:47:19 <copumpkin> and installing criterion and all its dependencies for this version is a pain
19:47:22 <edwardk> kuffar: are you confusing runReader for runReaderT ?
19:47:27 <kuffaar> edwardk why do their signatures differ then?
19:47:33 <Axman6> copumpkin: :(
19:47:35 <kuffaar> edwardk: http://www.haskell.org/hoogle/?hoogle=runReaderT
19:47:47 <kuffaar> It's kuffaar btw, why do you bother trying to spell out my nick fully? Tabbing seems much easier
19:47:50 <Axman6> copumpkin: what's the primitive useful for? i can thinnk og one situation
19:48:03 <copumpkin> Axman6: anywhere you need to copy arrays :P
19:48:05 <edwardk> kufaar: that is the type of the member
19:48:12 <copumpkin> lol
19:48:33 <edwardk> kuffar :: newtype ReaderT e m a = ReaderT { runReaderT :: e -> m a }
19:48:43 <Axman6> didn't even think of that!
19:48:45 <copumpkin> Axman6: using memcpy is way faster than writing your own loop, for large copies
19:48:47 <monochrom> I think the typo is deliberate
19:48:56 <edwardk> kuffar: see how if you just look at the right hand side you don't see the ReaderT?
19:49:12 <Axman6> copumpkin: indeed, and that's what you've added? if so, thanks :)
19:49:13 <edwardk> but if you look t the signature of runReaderT its actuall runReaderT :: ReaderT e m a -> e -> m a
19:49:29 <edwardk> kuffaar: hoogle got confused.
19:49:48 <Saizan> edwardk: yeah, but where "ReaderT r a" without the 'm"
19:49:52 <kuffaar> Yay, I got a highlight
19:50:13 <monochrom> kkuufar: whee
19:50:17 <edwardk> saizan: hoogle got _really_ confused there ;)
19:50:36 <kuffaar> monochrom: I hate you :'(
19:50:42 <monochrom> hehe
19:51:53 <copumpkin> kkuufar: what's wrong?
19:52:37 <elliott> kuffaar
19:53:29 <kuffaar> How offensive
19:54:06 <shachaf> kuffaar says: Welcome to #haskell where your questions are answered in majestic stereo!
19:55:06 <kuffaar> I decided not to test my Haskell code anymore, if it compiles - it works.
19:55:21 <Axman6> that's the spirit
19:55:32 <shachaf> kuffaar: If it compiles, why would you ever run it?
19:55:35 <azaq23> test :: Testable t => t -> IO (), but I can't simply do [testOne, testTwo], where testOne :: Int -> Int -> Bool and testTwo :: Int -> Bool, for obvious reasons, though something should of course work with Testable t => t
19:55:37 <kuffaar> Hahaha
19:56:00 <copumpkin> why can't memset_pattern be standard?
19:56:47 <shachaf> copumpkin: Too easy.
19:56:57 <copumpkin> I figured :(
19:57:07 <shachaf> copumpkin: Anyway, this is #haskell.
19:57:10 <shachaf> Memory is a lie.
19:57:13 <copumpkin> oh
19:57:20 <copumpkin> I've been working with it in Haskell though
19:57:24 <copumpkin> or GHC haskell, anyway
19:58:02 <Axman6> YOU'RE BREAKING THE ILLUSION!
19:59:37 <kuffaar> Hmm can you make do { a <- liftIO $ b; c <- liftIO $ c } -- any shorter?
19:59:55 <kuffaar> I was jsut wondering if you could summarise those liftIOs in any way
20:00:21 <kuffaar> Woops, there's more after the c <- part obviously
20:00:32 <kuffaar> Premature } in that example
20:00:34 <c_wraith> (a, b) <- liftIO $ liftM2 (,) b c
20:00:43 <kuffaar> Hah!
20:01:08 <kuffaar> Ok that's nearly longer in this case and makes it more difficult to read h
20:01:10 <kuffaar> hmm*
20:01:20 <Axman6> as if it does
20:01:28 <kuffaar> As if it does what?
20:01:34 <Axman6> you need to learn more haskell if you thbink that's difficult :P
20:01:36 <kuffaar> Oh, makes it more difficult to read
20:01:51 <copumpkin> http://snapplr.com/zmsn
20:01:54 <kuffaar> But they are rather unrelated things
20:02:00 <kuffaar> One is a socket API call
20:02:02 <shachaf> kuffaar: If your Haskell doesn't look like APL, it's too easy.
20:02:08 <kuffaar> The other one does something networking unrealted
20:02:11 <kuffaar> shachaf haha
20:02:51 <kuffaar> I actually want to develop an esoteric language full of Unicode stuff
20:04:23 <kuffaar> With a self-hosting compiler which can target PE/ELF and IA-32/AMD64!
20:04:36 <kuffaar> Might be a bit excessive for a joke but whatever, might learn a thing or two.
20:04:40 <copumpkin> why would you want to actually emit code yourself?
20:04:41 <copumpkin> ick
20:04:51 <kuffaar> it's a good exercise!
20:04:58 <copumpkin> once, I guess
20:05:01 <kuffaar> Yeah
20:05:04 <tolkad> it would be cool to have a learning compiler
20:05:04 <copumpkin> I wouldn't do such an icky arch even then
20:05:09 <Axman6> copumpkin: lthat paste is awesome :)
20:05:09 <shachaf> kuffaar: You should write a VM and emit code for that instead.
20:05:23 <kuffaar> shachaf: But the VM has to be self hosting in that language!
20:05:27 <kuffaar> Otherwise it's boring.
20:05:48 <kuffaar> And with that requirement, a VM wouldn't help
20:05:59 <copumpkin> Axman6: well, tibbe wanted a fast array copy for his new library, so I've been criterion'ing various options, including the obvious loopy option, and a couple of unrolled versions (he needs 32 elements in his array, so I can actually unroll it all the way)
20:06:03 <copumpkin> and then the primop
20:06:44 <Axman6> surerly memcpy has to be the fastest, each OS usually has a highly optimised one
20:07:07 <copumpkin> well, for 32 (128 or 256 bytes) elements it might not be a big win, but in general I definitely think it would be
20:07:19 <copumpkin> the function call has some overhead and you need to have few elements to pay it back
20:07:31 <Axman6> yeah, for large arrays, it would be extremely useful
20:07:45 <copumpkin> the fully unrolled version I have here is over twice as fast as the naive loopy one
20:07:52 <copumpkin> as measured by criterion
20:07:54 <tolkad> kuffaar: Do you want to become a history of computation archeologist, analyzing the bytecode of ancient compilers to discover their compilation hosting history?
20:08:00 <ddarius> The Cola stuff, related to Croquet, sounds like they have an awesome tool at just the right level of abstraction for code generation, but the code doesn't seem to be available anywhere.
20:08:01 <Axman6> maybe just use an unrolled version for less than X bytes, and memcpy for more?
20:08:11 <kuffaar> tolkad: Not really, why?
20:08:15 <Axman6> copumpkin: which backend?
20:08:25 <tolkad> kuffaar: just curious
20:08:32 <copumpkin> Axman6: that's memcpy is doing, sort of, but I can't statically decide in GHC
20:08:43 <copumpkin> Axman6: just the regular native code backend, haven't tried llvm
20:08:49 <kuffaar> tolkad: I just find bootstrapping a compiler to make it self-hosting sexually arousing.
20:09:07 <kuffaar> I want to try my hands at a serious language at some piont. It would just generate LLVM assembly then.
20:09:13 <Axman6> LLVM would be worth testing against too, since most people using this sort of stuff will likely be using it
20:09:22 <copumpkin> Axman6: true, I'll give that a go
20:09:30 <kuffaar> Why isn't LLVM used by default btw? In ghc that is
20:09:31 <Axman6> :)
20:09:35 <copumpkin> ghc: could not execute: opt
20:09:38 <copumpkin> maybe not
20:09:48 <locks> ooc is self-hosting, I think
20:09:48 <Axman6> hmm, i ran into that once...
20:09:49 <ddarius> Also, third time straight shaving went okay, but still no cigar.
20:10:04 <Axman6> kuffaar: it's a very new backend, needs proper testing
20:10:10 <kuffaar> Oh, ok
20:10:12 <monochrom> (why would you want cigar out of shaving)
20:10:14 <djahandarie> You're trying to straight shave while smoking a cigar?
20:10:23 <Axman6> and GHC will need some changes to be able to produce code that llvm can optimise well
20:10:23 <copumpkin> ddarius is hardcore like that
20:11:00 <kuffaar> djahandarie: Yes, so he can cauterise any cuts that might result.
20:11:25 <djahandarie> lol -_-
20:11:31 <djahandarie> That does sound pretty hardcore
20:11:37 <lpsmith> is it possible to catch all exceptions?
20:12:20 <kuffaar> catch blah $ \_ -> putStrLn "It's just like Java!"
20:12:49 <Axman6> lpsmith: if you mark the type of the exception as SomeException, then it will catch all exceptions
20:13:00 <kuffaar> Damn, I should have made that "I can't believe it's no Java!"
20:13:01 <lpsmith> ahh, thanks Axman6 
20:13:17 <Axman6> catch blah (\e -> print (e :: SomeException)>> doStuff)
20:13:51 <kuffaar> Oh? Does it use a less specific version by default?
20:13:59 <kuffaar> So not everything is caught?
20:14:10 <kuffaar> I am not sure what it usually infers to for that lambda
20:14:15 <Axman6> it will probably complain about the type in yours
20:14:33 <Axman6> because it doesn't know what type the function is taking in
20:15:43 <jdh31> so, I hear you guys like haskell
20:16:06 <lpsmith> Nah, I hate it.  I'm just a masochist that way
20:16:15 <jdh31> yeah it sucks
20:16:25 <Axman6> jdh31: yeah, it's way faster than OCaml and f#
20:16:33 <ddarius> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.90.6264  Perfect level of abstraction.
20:16:48 <azaq231> Okay, I can construct a list with an existential data T = forall t. Testable t => T t, but I don't think I can get this to work with test
20:16:51 <jdh31> no! f# is a terminal object in the poset category of language speed
20:17:32 <kuffaar> <insert rude remark involving a co-algebra>
20:17:36 * ddarius doesn't think jdh says things like "terminal object in the poset category of language speed"
20:17:43 <jdh31> damn
20:17:44 * Axman6 doesn't either
20:17:47 <kuffaar> Who is jdh?
20:17:56 <kuffaar> A bigger nut than SPJ?
20:17:56 <Axman6> some OCaml/F3 tool
20:18:00 <kuffaar> Oh, ok
20:18:00 <Axman6> F3*
20:18:05 <kuffaar> F#*
20:18:06 <jdh31> Axman6: fail
20:18:06 <Axman6> F#* >_<
20:18:12 <kuffaar> FThrarp
20:18:14 <lpsmith> Jon Harrop,  an Ocaml/F# troll
20:19:00 <kuffaar> http://shootout.alioth.debian.org/u64q/which-programming-languages-are-fastest.php is he angered by this?
20:19:04 <lpsmith> loves static typing, tail recursion,  and hating on Lisp, Haskell, Mathematica, and Erlang
20:19:21 <kuffaar> Why Haskell? Doesn't it fit the description?
20:19:21 <copumpkin> scheme, too
20:19:25 <Axman6> he hates on mathematica?
20:19:27 <copumpkin> although I guess lisp is a superset?
20:19:35 <dibblego> and Scala
20:19:36 <lpsmith> well, sometimes.  Maybe not
20:20:08 <Axman6> kuffaar: he runs a company consulting on the use of OCaml and F#, and has written a few books
20:20:09 <lpsmith> Lisp and Haskell seem to get the brunt of his at times bizarre views
20:20:18 <Axman6> so he's got a vested interest to slag off other languages
20:20:23 <roconnor> ddarius: ping
20:20:27 <kuffaar> I see
20:20:39 <ddarius> copumpkin: Scheme preceded CL which is probably the best representative of the "Lisp" family.
20:20:51 <Axman6> i'm sire he's a smart guy, and knows his shit, but he's just such a complete tool about it
20:21:18 <lpsmith> he can be strangely dishonest at times,  when he thinks it'll help him manipulate somebody
20:21:19 <jdh30> copumpkin, ;)
20:21:20 <roconnor> ddarius: nevermind
20:21:29 <lpsmith> I mean, at times I'm not even sure he believes what he says
20:21:32 <ddarius> roconnor: Glad to have helped.
20:21:50 <lpsmith> but for the most part,  I think he believes his own kool-aid
20:22:24 <copumpkin> it should be drinking one's own flavor aid
20:22:42 <copumpkin> I wonder how kool-aid came to be the phrase
20:22:50 <lpsmith> Jonestown?
20:23:01 <copumpkin> well yeah, but they used flavor aid there
20:23:37 <ddarius> copumpkin: For the same reason we say Band-Aid, Xerox machine, and Intellisense.
20:23:52 <lpsmith> I guess it was flavor aid
20:23:58 <copumpkin> don't forget Hoover, in england!
20:24:03 <lpsmith> at least if wikipedia is to be trusted
20:24:19 <copumpkin> wikipedia is always to be trusted
20:25:04 <Pseudonym> Yes, how else would we know that the Battle of Trafalgar occured in the year ##ERIC IS A MORON?
20:25:45 <copumpkin> now we know the truth about dibblego's identity
20:26:05 <Pseudonym> And age?
20:26:10 <dibblego> yeah lazy evaluation is for chumps!
20:26:59 <copumpkin> gotta love watching GHC's build spending 5 minutes telling me that forall x. compilation of x is NOT required
20:27:26 <ddarius> copumpkin: It's probably all those print statements slowing it down.
20:27:29 * hackagebot sbv 0.9.9 - Symbolic Bit Vectors: Prove bit-precise program properties using SMT solvers.  http://hackage.haskell.org/package/sbv-0.9.9 (LeventErkok)
20:27:36 <copumpkin> ddarius: probably :/
20:27:38 <kuffaar> When will we finally get a multi threaded cabal? Preferrably one that doesn't segfault randomly on Windows at that.
20:27:51 <copumpkin> and the fact that the compilation command-line is 8 lines long on a wide terminal
20:28:03 <copumpkin> kuffaar: when you submit the patch!
20:28:05 <copumpkin> :D
20:28:26 <kuffaar> But I don't even know Haskell!
20:28:31 <ddarius> copumpkin: Ah, that is the problem.  You are probably getting terminal thrashing.
20:33:00 * copumpkin wonders if GHC builds are bad for his SSD
20:33:21 * ddarius thinks he'll do some midnight Guitarrespielen.
20:33:54 <ddarius> SSD folk spend too much time worrying that using their SSD might be bad for it.
20:33:58 <copumpkin> :P
20:34:01 <copumpkin> true
20:34:05 * copumpkin stops worrying
20:35:03 <Axman6> if it slows down, buy another and clone them!
20:35:17 <copumpkin> Axman6: almost done building my .pkg!
20:35:24 <copumpkin> soon I will be able to test if this was worthwhile!
20:35:37 <tolkad> why does ghc explicitly inline or not inline functions? for maximum efficiency shouldn't it completely transform your whole program into a intermediary language and then recursively apply optimizations?
20:36:07 <copumpkin> tolkad: inlining everything blows cache by making your code too large
20:36:14 <copumpkin> it's a trade-off
20:36:31 <copumpkin> also, it's easier to do what you're saying when you don't do per-module compilation
20:36:55 <Axman6> so you often explicitly inline small functions that can get specialised when inlined, and don't inline things that can't
20:36:57 <pastorn> ugh... 200 lines of haskell to replicate getLine with some fance moving of the cursor in the text
20:37:09 <pastorn> *fancy
20:38:01 <ddarius> Also GHC does transform your whole program into an (several actually) intermediate language adn recursively apply optimizations.
20:38:06 <monochrom> just use gtk2hs
20:38:21 <ddarius> Except for the backend stuff we now have something better than recursive application of optimizations.
20:38:36 <tolkad> copumpkin: it should automatically break my code up into chunks to avoid cache misses
20:38:57 <Axman6> tolkad: sounds like you should be writing GHC, go for it :)
20:39:16 <tolkad> Axman6: I'd just rather have perfect optimization so I wouldn't have to worry about performance myself
20:39:45 <tolkad> it's more efficient to add an optimization to the compiler than to use it to optimize your own code
20:39:57 <tolkad> because then everyone benefits from it
20:40:17 <Axman6> you sound like this is an easy thing to do, and also not what is currently happening
20:41:48 <ddarius> Axman6: tolkad has a tendency to suggest that compiler implementors are stupid for not doing things which are impossible, infeasible, or have dramatic practical ramifications.
20:42:19 <Axman6> yeah, i'd picked that up
20:42:25 <tolkad> I just don't want to have to worry about how I divide my codes into modules and functions
20:42:37 <copumpkin> tolkad: check
20:42:38 <tolkad> so I was thinking it would be great if the compiler completely ignored that
20:42:39 <copumpkin> @hackage pony
20:42:39 <lambdabot> http://hackage.haskell.org/package/pony
20:42:41 <Axman6> tolkad: if it's so easy to do these things, why haven't you done it yet?
20:42:45 <monochrom> pay me to write your code. then you will worry nothing.
20:42:56 <tolkad> Axman6: I don't know how to write compilers
20:43:06 <Axman6> so what makes you think it's easy then?
20:43:09 <tolkad> no I like writing code, I just wish I didn't have to optimize
20:43:22 <ddarius> monochrom: More simply, he could just not worry about it.
20:43:25 <Axman6> also, breaking code into modules isn't that important for compilation, it's important for humans
20:43:38 <monochrom> well I want to get some money out of it, naturally :)
20:44:36 <tolkad> Axman6: well is there any way to tell ghc to compile all my modules together?
20:44:44 <ddarius> "It's immoral to let a sucker keep his money"
20:44:45 <tolkad> so it can perform cross-module optimizations
20:44:46 <monochrom> and yes, mac lovers could also choose either paying me for porting ghc to 64-bit, or not worrying about it.
20:44:48 <copumpkin> just s/g/j/
20:44:53 <Axman6> tolkad: no compiler will ever be able to do asd good a job of optimising your code as you can, because they can;t work out everything that you know about it
20:45:31 <Axman6> monochrom: i'd pay you some amount if it would get it done
20:45:32 <ddarius> Hal Daume III made a tool that would take a bunch of modules and make one giant module a long, long time ago.
20:45:37 <tolkad> Axman6: what if you had a learning compiler?
20:45:47 <copumpkin> what if we had strong AI
20:45:52 <copumpkin> or a pony
20:45:53 <john_r_watson> can anyone explain why answer pattern matching works and answer' does not in the following? http://hpaste.org/43267/confusing_pattern_matching
20:45:59 <monochrom> what if the human programmer is very dumb
20:45:59 <adu> copumpkin: lol
20:46:04 <djahandarie> I can supply the pony
20:46:04 <Axman6> tolkad: they somewhat exist, there's profile based optimisation in gcc i believe
20:46:13 <adu> I can supply the strong AI
20:46:14 <tolkad> Axman6: that applied abstract metaphores from elsewhere in its experiences to creatively generate optimizations
20:46:22 <ddarius> It's not a matter of "learning" or being better or even strong AI.  A correct compiler can't do certain things that you can do because you have information the compiler doesn't have (namely what you want to accomplish.)
20:46:22 <copumpkin> djahandarie: can you give me an elephant? my girlfriend would really like one but they're hard to procure and maintain
20:46:26 <tolkad> metaphors*
20:46:37 <john_r_watson> (answer' "((") will yield 2 before the (0==) test
20:46:50 <Axman6> ddarius: that doesn't matter apparently!
20:46:54 <tolkad> ddarius: a smart enough compiler should be able to figure that out
20:46:55 <djahandarie> copumpkin, I think there is some woman in Africa that does that
20:47:01 <djahandarie> I saw a news story on it!
20:47:02 <adu> tolkad: what are you smoking? and can I have some?
20:47:04 <copumpkin> djahandarie: oh nice, can you give me her contact info?
20:47:12 <john_r_watson> but (answer' "(()") pattern matches against _ (-1) on the ')'
20:47:13 <copumpkin> he's probably on k2 spice
20:47:15 <copumpkin> the legal weed
20:47:18 <tolkad> ddarius: it just simulates the universe until it finds me, then checks what I want
20:47:49 <monochrom> I think foldl and foldr are doing fundamentally different things?
20:48:07 <ddarius> monochrom: Well foldl can be written in terms of foldr...
20:48:14 <monochrom> that's misleading
20:48:22 <tolkad> foldr reverses the list first?
20:48:34 <ddarius> But yes, Barry Jay has a couple of cute papers in terms of (co)limits of a simple case of diagrams that are often overlooked.
20:48:55 <john_r_watson> monochrom: I'll look at the foldr sol'n again, but I thought it was valid
20:49:12 <tolkad> ddarius: try using foldl in terms of foldr on an infinite list
20:49:44 <ddarius> tolkad: The definition of foldl in terms of foldr is observationally equal to foldl defined directly.
20:50:11 <john_r_watson> ah... I see - I am indeed an idiot
20:50:21 <john_r_watson> it starts out @ (-1) on the right
20:50:26 <john_r_watson> w/ "(()"
20:50:32 <john_r_watson> after hitting the first ')'
20:50:45 <ddarius> Barry Jay actually organized a comprehensive list of his publications!
20:50:52 <john_r_watson> need to reverse the math
20:51:09 <lpsmith> Hmm...
20:51:21 <lpsmith> Haskell doesn't have thread-local IORefs,  does it?
20:51:26 <ddarius> monochrom: http://www-staff.it.uts.edu.au/~cbj/Publications/Abstracts/fixpoints+loops.html and http://www-staff.it.uts.edu.au/~cbj/Publications/Abstracts/tailrecursion.html
20:51:42 <Axman6> lpsmith: sure it does, if you don't share them :P
20:51:50 <lpsmith> I mean :)
20:51:54 <ddarius> lpsmith: For Haskell threads, it's unnecessary to have anything special for that.
20:52:01 <ddarius> For TLS, no.
20:52:04 <lpsmith> A thread-local IORef I don't have to name
20:52:11 <tolkad> @let foldl_ = foldr . flip
20:52:14 <lambdabot>  Defined.
20:52:20 <tolkad> > foldl [1..10]
20:52:21 <lambdabot>   Couldn't match expected type `a -> b -> a'
20:52:21 <lambdabot>         against inferred type `[...
20:52:25 <lpsmith> basically,  a thread variable,  global to the thread
20:52:34 <monochrom> just use IORef if you keep it thread-local
20:52:38 <tolkad> > foldl (+) 0 [1..10]
20:52:39 <lambdabot>   55
20:52:43 <tolkad> > foldl (+) 0 [1..]
20:52:47 <lambdabot>   mueval-core: Time limit exceeded
20:53:00 <lpsmith> I want something more like ETS tables for Haskell :-P
20:53:07 <tolkad> > foldl (:) 0 [1..]
20:53:09 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
20:53:31 <tolkad> > foldl (flip (:)) 0 [1..]
20:53:32 <lambdabot>   No instance for (GHC.Num.Num [b])
20:53:32 <lambdabot>    arising from a use of `e_101' at <inte...
20:55:00 <tolkad> > foldl (:) [] [1..]
20:55:01 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
20:55:02 <tolkad> whoops
20:55:29 <ddarius> lpsmith: If you really want you can make fork :: TLS s a -> IO ThreadId where you have setTLS :: s -> TLS s () and getTLS :: TLS s a and TLS is just a wrapper around ReaderT (IORef s) IO a.
20:55:32 <tolkad> > foldl (flip (:)) [] [1..]
20:55:36 <lambdabot>   mueval-core: Time limit exceeded
20:55:45 <ddarius> I don't see how this is clearer or better than just closing over an IORef.
20:55:48 <tolkad> wait I thought that would work
20:55:58 <tolkad> ddarius: sorry I misunderstood the semantics of foldl
20:56:04 <copumpkin> Axman6: win!
20:56:08 <Axman6> yeah?
20:56:12 <lpsmith> ddarius, yeah, I know,  I'm not sure I like that idea though :-/
20:56:33 <lpsmith> Also GHC wont GC a thread if you retain a threadID to it.  That does suck
20:56:35 <copumpkin> Axman6: http://pastie.org/1491803
20:56:52 <copumpkin> @tell tibbe win! http://pastie.org/1491803
20:56:52 <lambdabot> Consider it noted.
20:57:22 <ddarius> lpsmith: So don't retain ThreadIds.
20:57:27 <Axman6> copumpkin: epic win!
20:57:30 <copumpkin> weird that the unroll16 is so slow though
20:57:38 <Axman6> copumpkin: what are the sizes of the arrays being moved?
20:57:43 <copumpkin> 32 elements
20:57:44 <Axman6> yeah, that is odd
20:57:46 <ddarius> copumpkin: Is airpumpkin2 your BackTrack box?
20:57:59 <copumpkin> nope, just my macbook air
20:58:21 <copumpkin> unroll16 used to be somewhere between loop and unroll32 on my previous GHC
20:58:22 <Axman6> copumpkin: does ghc do a lot of array copies? i guess it must with Array
20:58:32 <lpsmith> ddarius, I don't see how that would be at all possible for what I'm currently toying with.
20:58:35 <copumpkin> I doubt it, but tibbe's new code does
20:58:47 <copumpkin> 32-element arrays :)
20:58:53 <copumpkin> and vector does
20:59:00 <copumpkin> well, things like dolio's magic combinator for vector
20:59:21 <dolio> I don't recall writing a combinator called magic.
20:59:28 <copumpkin> it is magic!
20:59:33 <copumpkin> can't remember what you'd called it though
20:59:38 <monochrom> haha
21:00:40 <dolio> What did it do?
21:01:10 <copumpkin> it takes an array, makes a mutable copy of it, then freezes that
21:01:15 <copumpkin> *vector
21:01:17 <dolio> Oh.
21:01:35 <copumpkin> however, vector is currently using slow loopy things for array copies
21:01:38 <dolio> I think it was called apply. But I got rid of it because vector added a function that did the same thing.
21:01:41 <copumpkin> so this primop might help with that
21:01:43 <copumpkin> yeah
21:02:10 <copumpkin> not that I really see most people with a clue copying arrays very much in their code
21:03:29 <dolio> Anyhow, the real magic is in vector, which has facilities for avoiding freezing things as much as possible.
21:03:35 <copumpkin> yeah
21:04:23 <copumpkin> @tell tibbe my tests are up here: http://pastie.org/1491813 but I tried building on the git GHC mirror and that didn't work, so I moved back to darcs, so I don't have the new repo up on github or anything
21:04:23 <lambdabot> Consider it noted.
21:04:24 <dolio> So if you apply several operations that would copy an immutable array into a mutable one, and then freeze the mutable array, they'll all be done on a single mutable array.
21:08:57 <copumpkin> yeah
21:09:07 <copumpkin> I think I suggested that to you back on uvector, via a fusion rule
21:09:12 <copumpkin> but I imagine vector does it more magically :P
21:09:43 <dolio> Well, it has a whole framework for that sort of thing.
21:09:51 <dolio> Instead of my making it happen for one single function.
21:09:51 <copumpkin> yeah, that New stuff
21:14:28 <copumpkin> Axman6: for a larger array (16M elements), it's 94ms vs. 24ms
21:15:09 <Axman6> :D
21:15:53 <Axman6> well, you should get this in GHC asup bro!
21:16:04 <copumpkin> gotta wait for people to wake up :)
21:16:16 <copumpkin> well, I don't have to
21:18:30 <tolkad> hmm maybe I should try to understand ghc source
21:18:54 <tolkad> it's kind of complicated I gave up last time I tried
21:18:57 <copumpkin> the guide is pretty good
21:19:05 <copumpkin> but yeah, it's huge
21:19:09 * ddarius takes small steps toward Classical Gas.
21:20:23 <ddarius> Read about ornaments or a practical theory of programming.
21:20:28 <ddarius> (?)
21:20:39 <ddarius> (or more practically, go to sleep.)
21:21:02 <copumpkin> ornaments!
21:21:41 <copumpkin> I'm gonna go buy some milk
21:21:42 <copumpkin> mmm
21:23:02 * ddarius can barely drink milk anymore.
21:23:10 <ddarius> Which is fine because I never really liked it.
21:27:15 <ddarius> "Fibrational Induction Rules for Initial Algebras"  A good, fear-inducing title.
21:31:34 <tolkad> will a thunk with a dummy parameter be evaluated each time it is called or only once?
21:31:56 <Axman6> like foo x () = x*x?
21:31:57 <tolkad> like bitSize from Data.Bits
21:32:12 <Axman6> that should get inlined
21:33:27 <tolkad> what if it's recursive? instance Data.Bits (a, a) where { bitSize (a, b) = (bitSize a, bitSize b) }
21:33:32 <tolkad> whoops
21:33:39 <tolkad> what if it's recursive? instance Data.Bits (a, a) where { bitSize (a, b) = bitSize a + bitSize b }
21:34:16 <Axman6> hopefully that'll get inlined so.
21:34:23 <Axman6> tgoo*
21:34:25 <Axman6> too*
21:34:30 <Axman6> >____<
21:35:05 <Saizan> that's not really recursive, btw
21:42:21 <ddarius> "Frustratingly, Agda rejects this definition as less than obviously terminating."
21:46:02 <geheimdienst> "... in the next 168 pages, we sketch a simple proof that shows that it is, in fact, obviously terminating."
21:46:09 <geheimdienst> like, totally obvious
21:49:01 <Axman6> copumpkin: this stuff you've added, i don't suppose you've tried adding it to the Array code yet? i'd be interested to see if Arrays get faster when creating new arrays using it
21:49:18 <copumpkin> it wouldn't help you make new arrays
21:49:20 <copumpkin> but nope
21:49:23 <copumpkin> it's still just a primop
21:50:05 <Axman6> sure it would, the functions that modify multiple elements in the array copy the array, then mutate and freeze the new array
21:51:57 <ddarius> s/new/fresh/
21:53:04 <ddarius> Another two weeks to procrastinate on homework.
21:53:24 <copumpkin> Axman6: oh, fair enough, but does anyone really use those functions? I hope not :P
21:53:58 <Axman6> well, it would be nice if they were fast
21:54:01 * ddarius replaces them with update a i e = a\\[(i,e)]
21:54:14 * ddarius isn't even sure if (\\) or (//) is the operator...
21:54:25 <Axman6> well, i believe \\ is one of the functions i'm talking about
21:54:51 <Axman6> copumpkin: have you seen the MArray stuff i've been working on?
21:55:02 <copumpkin> yep :) those look useful
21:55:08 <Axman6> hoorah :)
21:55:15 <Axman6> glad someone thinks so
21:55:45 * ddarius finds it mildly odd that multiple people, seemingly independently, will suddenly start working on the same problem.
21:55:57 <Axman6> heh, indeed
21:56:04 <Axman6> well, similar problems
21:56:21 <copumpkin> well, I got to it through tibbe needing it for a new, flatter IntMap
21:56:48 * ddarius wonders if ornamenting is an adjunction.
21:56:54 <tg_> ddarius: I find it very odd
21:56:57 <Axman6> i was sparked to write my array update functions because of that article on bad performance of arrays in haskell
21:56:59 * ddarius should probably read the "manly" version.
21:57:18 <ddarius> Axman6: Which one?  There have been several.
21:57:26 <ddarius> Manuel had a good one years ago.
21:57:31 <Axman6> http://www.lix.polytechnique.fr/~kaustuv/expo/incr_uarray/
21:57:53 <ddarius> Ed has also been fiddling with some MArray stuff for some reason.
21:58:18 <Axman6> i think he made MArrays work for things that implement MonadIO
21:59:14 <Axman6> copumpkin: it's interesting that vector performs so poorly for that benchmark
21:59:35 <ddarius> Axman6: Yes, but why?
22:00:06 <Axman6> i'm not sure, i wish he'd shared the code for that, it's quite possible he's doing something that doesn't fuse well for vector
22:01:19 <ddarius> "Our instantiation for hyperfunctions underscores the value of working in the general fibrational setting since this data type cannot be interpreted as a set."
22:01:30 <ddarius> No one will take you seriously if you don't support hyperfunctions!
22:01:52 <Axman6> ddarius: that's how we're still avoiding success
22:02:11 <ddarius> Haskell does support hyperfunctions though.
22:02:25 <Axman6> we're screwed then
22:02:29 <geheimdienst> also superduperfunctions?
22:02:45 <ddarius> Don't get crazy now, geheimdienst.
22:02:59 <Saizan> how do they look like in haskell?
22:03:26 <codolio> newtype Hyper a b = H (Hyper b a -> b)
22:04:04 <heatsink> Those are terminating?  Interesting.
22:04:14 <copumpkin> I dare you to write an interesting one
22:04:17 <ddarius> heatsink: Why wouldn't be?
22:04:29 <ddarius> copumpkin: There was a paper with practical applications.
22:04:35 <copumpkin> ddarius: oh?
22:05:06 <copumpkin> I've seen roconnor use a similar trick for a "real" y combinator in haskell
22:05:16 <copumpkin> but GHC's inliner isn't a big fan of it
22:06:11 <copumpkin> instance Category Hyper where ...
22:06:43 <ddarius> @google Zip Fusion with Hyperfunctions
22:06:45 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.36.4961
22:06:49 <heatsink> ddarius: Just that one of Coq's restrictions on inductive data types disallows types that are recusive like that.
22:06:57 <copumpkin> thank you!
22:07:04 <copumpkin> heatsink: I'd hope so!
22:07:07 <ddarius> heatsink: As the sentence I quoted above states, it's not a set.
22:10:15 <heatsink> Sorry, I wasn't really reading.
22:11:34 <copumpkin> "general fibrational setting" is like a null byte for me
22:11:57 <ddarius> copumpkin: Did you catch the paper name from above when you were getting milk?
22:12:00 <RayNbow`TU> copumpkin: what is this Evolutive Theming System you recently tweeted about?
22:12:27 <copumpkin> ddarius: oh nope
22:12:39 <copumpkin> I see now
22:12:57 <ddarius> copumpkin: It's the "categorical semantics" for the ornaments paper.
22:13:52 <copumpkin> I see
22:13:59 <copumpkin> looks rather scary :P
22:14:05 <Saizan> what does [C,D] mean as a category?
22:14:11 <ddarius> And it looks like they solve the problem of the "direct" approach which uses too much power and thus requires much of the relevant categories and functors by using fibrations to have second-class parameterization which is much less stringent in its requirements.
22:14:21 <ddarius> Saizan: Usually the functor category.
22:14:29 <ddarius> I.e. Cat(C, D)
22:18:45 <Saizan> ddarius: ah, thanks, it fits
22:20:18 <dibblego> http://paste.pocoo.org/show/325842/ can a Monad be defined for this or am I dreaming?
22:25:18 <copumpkin> not without that Maybe
22:25:29 <dibblego> even then?
22:25:38 <ddarius> id -> Fid, Ff . Fg -> F(f . g), let F be 1 -> Cat, therefore forall f. Ff = T for some T : C -> C, and we have Id -> T and T^2 -> T.  Naturally, we want Ff = id . Ff -> Fid . Ff -> F(id . f) = Ff and symmetrically and the two ways of doing Ff . Fg . Fh -> F(f . g . h) to be the same.
22:25:50 <copumpkin> dibblego: not sure, but at least you can write return :)
22:25:55 <dibblego> heh
22:26:11 <ddarius> If we use op-lax functors, we have Fid -> id and F(f . g) -> Ff . Fg and we get comonads.
22:26:35 <copumpkin> dibblego: I tried something similar a while back and ran into trouble already with Applicative with getting two arguments to <*> that had a Just for the leftovers
22:26:43 <copumpkin> but maybe I just didn't think hard enough
22:26:52 <dibblego> copumpkin, I think I have it wrong anyway
22:29:46 <ddarius> s/forall f/forall f \/= id/
22:34:42 <mbuf> can anyone help me with solving this error? http://hpaste.org/43270/podcast_example 
22:38:03 <copumpkin> mbuf: maybe outdenting line 27 a bit to the level of the run
22:38:57 <ddarius> Actually ignore that sed.
22:39:07 <ddarius> Lax functors are subtle.
22:40:24 <mbuf> copumpkin: ahh! thanks
22:57:02 <luqui> dibblego, yeah that's a free monad.
22:57:02 <lambdabot> luqui: You have 1 new message. '/msg lambdabot @messages' to read it.
22:57:39 <Axman6> heh, that'll be my message =)
22:58:17 <luqui> Axman6, heh.  not sure, don't know my way around haskell-src-exts that well
22:58:26 <luqui> it'd have to pay attention to #line directives, no?
22:58:56 <Axman6> i don't believe so. once CPP has been run, everything left should be pure haskell
23:00:06 <luqui> but it's okay to jump to the expanded line number?  lines of things shift around after cpp
23:00:14 <copumpkin> luqui: really? that Done i o is breaking it
23:00:26 <Axman6> yes, because each CPP macro always only produces one line
23:00:47 <luqui> copumpkin, o is the last arg right?  fmap f (Done i o) = Done i (f o), no?
23:01:02 <copumpkin> luqui: functor-wise it's fine, but write pure/return
23:01:13 <Axman6> so in our case, it would jump to the line where the macro is
23:01:14 <luqui> Axman6, ah that's a very specific situation
23:01:15 <copumpkin> you need a Monoid on i
23:01:25 <Axman6> what od you mean?
23:01:26 <copumpkin> or some notion of an empty element
23:01:36 <luqui> copumpkin, oh right! 
23:01:43 <Axman6> luqui: all CPP macros only produce one line
23:02:03 <Axman6> i tried quite hard to make it produce multiple lines and it wouldn't :)
23:02:04 <Saizan> "Done i o >>= f = f o" is also less than ideal
23:02:04 <copumpkin> with Maybe there it's basically a free monad
23:02:17 <luqui> Axman6, oh... hm, didn't know that. 
23:02:36 <luqui> yeah monoid i is the natural constraint
23:02:41 <Axman6> neither did I until i rtan into it :)
23:02:41 <luqui> imo
23:03:13 <luqui> Axman6, well i'm very busy with school atm.  i might have time next weekend.   until then, patches welcome :-)
23:03:57 <Axman6> does haskell-src-exts have any way of finding language extensions?
23:04:06 <luqui> yeah i believe it does
23:04:15 <luqui> although it was a little tricky iirc
23:04:17 <Axman6> i'm also quite busy with work, but if I have time, i'll see what I can do
23:04:36 <luqui> stupid real life! :-)
23:04:49 <Axman6> luckily it's real life that's making me need this stuff :)
23:05:02 <luqui> oh nice, so you can even get paid to do this? :-)
23:05:22 <Axman6> yup
23:05:31 <Axman6> and an apartment in tokyo :D
23:05:45 <luqui> cool.
23:06:07 <luqui> glad to know hothasktags is getting used.  kinda sad that my most used modules are my dirty little hacks and not the ones i'm proud of :-P
23:06:16 <Axman6> heh
23:06:23 <geheimdienst> Axman6: does this involve scarlett johansson?
23:06:37 <Axman6> can't remember why we switched to it from hasktags
23:06:45 <geheimdienst> i seem to recall bill murray was in a similar situation like you, and hit it big
23:07:42 <luqui> in our trade, it would be lost in translation... from COBOL to Java
23:10:13 <luqui> Axman6, because you use qualified imports?  ;-)
23:10:37 <geheimdienst> bill and scarlett, two java refuges in a strange world of all cobol ...
23:19:51 <Axman6> luqui: well, yes, we do that, but i think there was another reason too
23:59:39 <geheimdienst> so, a lambda can't have a where block?
