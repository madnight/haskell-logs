00:00:07 <adnap> yeah
00:00:39 <adnap> i see what you were going for
00:02:30 <ddarius> Also, you'd need to calculate the center, my list comprehension would generate quarters.
00:03:37 <adnap> i like browsing hpaste
00:03:44 <adnap> this is scary as hell: http://hpaste.org/43363/stack_overflow
00:04:09 <kfr> adnap haha wtf :/
00:04:12 <adnap> i just thought of a new game we can play in #haskell
00:04:23 <adnap> find the coolest, scariest, etc. things on hpaste
00:04:55 <adnap> lotsa people doing parsec on here
00:06:08 <dark> i was going to say that translating into an unidiomatic haskell would be trivial, but for doing something elegant i would first need to understand it :P
00:06:44 <kfr> adnap I thought about writing a browser game where you are given a series of small problems to solve in an in-browser ghci session. You are then rated based on how long it took you to solve the problem and how "long" your code is. (shorter is better)
00:06:45 <dark> that list comprehension seems very beautiful @.@
00:07:05 <kfr> x is the same length as blah then though so you aren't encouraged to use single letter names only
00:07:19 <adnap> lol http://hpaste.org/43248/story_of_chicken
00:07:56 <dark> kfr, long in the grammar sense (numbers of tokens) not in string sense?
00:08:04 <adnap> kfr: there is a learning-oriented website that lets you do a sort of in-browser ghci session
00:08:11 <wagle> anyone using scion with a current cabal and ghc?
00:08:15 <adnap> kfr: my friend showed it to me once, but i don't remember what it was called
00:08:18 <kfr> dark: Something like that
00:08:21 <kfr> adnap: tryhaskell.com
00:08:24 <adnap> oh
00:08:29 <adnap> yeah, that was it
00:08:39 <kfr> @where tryhaskell
00:08:39 <lambdabot> http://tryhaskell.org/
00:08:43 <kfr> I was wrong ^
00:08:49 <adnap> i haven't had much success getting my friends to learn haskell though
00:09:01 <kfr> Wait, obviously this wouldn't use ghci
00:09:07 <kfr> It would actually use ghc with a compile button
00:09:24 <kfr> So you can write regular non-ghci top level definitions etc
00:09:45 <dark> kfr, doesn't ghci have some kind of :load for including from source files?
00:10:05 <kfr> Yeah but what does it matter?
00:10:12 <dark> every time you typed a expression, it could save in a 'file' then load from ghci
00:10:13 <adnap> kfr: would the problems be random each time?
00:10:15 <kfr> I don't want to keep ghci's running
00:10:17 * ddarius was watching the curb disappear, but now it's gone.
00:10:21 <dark> hm
00:10:23 <kfr> adnap yeah it needs to be randomised somehow
00:10:33 <kfr> It's probably not easy to come up with randomised problems which do not suck
00:10:35 <adnap> otherwise, i could just prepare all the solutions the second time around
00:10:41 <adnap> and paste them in really quickly
00:11:02 <kfr> Yeah
00:11:07 <adnap> it should have new problems every month
00:11:09 <kfr> adnap you can probably do that anyways haha
00:11:14 <kfr> Harsh, so demanding :[
00:11:15 <dark> the problem themselves could be generated from problem templates
00:11:27 <kfr> It's just supposed to be a quick e-peen thing
00:11:37 <adnap> hmmm
00:11:38 <kfr> So IRCers can flame each other over their scores
00:11:59 <kfr> They'd have an account on the site where people can browse their performance in detail
00:12:04 <dark> it's easy to bloat features, and so hard to design
00:12:04 <kfr> To make fun of them
00:12:08 <adnap> how about a daily problem
00:12:11 <adnap> you get once chance
00:12:18 <adnap> each day to solve a new problem
00:12:21 <adnap> and it's ranked
00:12:21 <kfr> :/
00:12:32 <kfr> Haha, like with a season?
00:12:36 <adnap> a season?
00:12:37 <kfr> And a ladder
00:12:41 <adnap> oh
00:12:45 <adnap> i see what you mean
00:12:46 <kfr> adnap: You know, seasons in a league :p
00:12:50 <adnap> yeah, that would be cool
00:12:54 <kfr> League of Lambda Overlords
00:12:56 <listdata> is anyone else having trouble from code.haskell.org or is it just me? darcs just failed trying to get the xmonad repo... =(
00:13:01 <dark> for example you could measure how long an 'average' programmer would solve a specific template, and give each one a template of adequate level
00:13:03 <wagle> oic..  the dreaded undocumented installation flags
00:13:11 <adnap> it would be like project euler, but a bit easier, and with a new problem every day
00:13:26 <adnap> and with the time and code length things you suggested
00:13:40 <Saizan> listdata: it got taken down after it got attacked yesterday
00:13:50 <adnap> i had another idea
00:14:03 <listdata> Saizan: woah, that sucks
00:14:04 <adnap> you could secretly make all the programs interrelate in some way
00:14:09 <adnap> but nobody knows
00:14:13 <adnap> and then you spring it on them
00:14:30 <adnap> if they've done all the problems for the week, they can piece them together like a puzzle
00:14:32 <kfr> Interrelate how?
00:14:36 <kfr> Haha o_o
00:14:40 <adnap> their pieces of a larger problem
00:14:45 <adnap> *they're
00:14:47 <listdata> Saizan: I was trying to get my new shiny xmonad extension working... gahhh
00:15:30 <Saizan> listdata: you'll have to wait a few days..
00:15:37 <adnap> and you try not to make it obvious that the bite-sized problems are part of a bigger problem.
00:16:04 <kfr> You could force people to develop monads with messed up semantics
00:16:10 <adnap> i think it would be cool if haskell has demoscene competitions.  we could work to improve our graphics libraries.
00:16:12 <kfr> And they have to provide it as a module
00:16:16 <adnap> *had
00:16:31 <kfr> Which is then imported by a piece of code which is used to check the validity of their semantics somehow
00:16:48 <adnap> kfr: you could have some stuff that was subjective too.  i think some creative problems would be cool too.
00:17:03 <ddarius> Oh my god
00:17:08 <kfr> adnap I've seen one such game which even determined the complexity of the algorithms you implemented
00:17:08 <adnap> :O
00:17:12 <kfr> But just heuristically
00:17:30 <adnap> d-d-d-d-d-d-d-daaaaarius
00:17:41 <adnap> is the scaaaaariest
00:17:50 <kfr> That was from a game which was developed commercially to evaluate programmers heh
00:17:54 <cads> kfr, that would be cool
00:18:04 <adnap> of the meeeeeerriest
00:18:25 <kfr> But making all of the stuff number crunching problems would be boring
00:18:47 <kfr> lol I could add problems where you are forced to translate programs from other programming languages to Haskell
00:18:52 <adnap> and the waaaaarriest
00:19:05 <kfr> And then the code checks if they solve random data as expected
00:19:05 <adnap> of men and women
00:19:20 <adnap> i am such a good singer
00:19:46 <adnap> kfr: i like that idea
00:20:21 <kfr> :O
00:20:22 <adnap> they need a code golf programming languages shootout
00:20:37 <adnap> i bet there is one
00:20:46 <kfr> Haha yes I got this idea from vi golf, too
00:20:47 <opqdonut> APL will win
00:21:01 <kfr> lol you could make esoteric language programming shootouts
00:21:04 <adnap> is that somethin somethin proving language?
00:21:07 <kfr> Yeah, APL in the browser!
00:21:11 <kfr> No
00:21:14 <adnap> what is it?
00:21:17 <kfr> APL is not like Coq and such
00:21:27 <opqdonut> look it up
00:21:47 <ion> adnap: You’re welcome. http://hpaste.org/paste/43366/a_faithful_implementation#p43369
00:21:48 <kfr> It's an old bizarre language which required special keyboards to be programmed because it was full of bizarre symbols ;D
00:22:20 <kfr> http://en.wikipedia.org/wiki/APL_%28programming_language%29
00:22:25 <ddarius> APL stands for "A Programming Language"
00:22:25 <adnap> yeah, i'm looking at that
00:22:34 <adnap> some of the examples are unreadable
00:22:50 <kfr> (~R∊R∘.×R)/R←1↓⍳R
00:22:56 <ddarius> adnap: It's actually surprisingly readable once you get the notation into your head.
00:23:20 <ddarius> But it's really easy to forget and requires "knowing" the dynamic "type" of things.
00:23:24 <adnap> ddarius: is it expressive enough to solve lots of problems?
00:23:26 <ddarius> To parse at all.
00:23:32 <ddarius> adnap: Sure.
00:23:39 <adnap> ddarius: in a concise way?
00:23:53 <ddarius> Yes.
00:24:11 <adnap> ha ha ha
00:24:37 <adnap> someone just put my imperative program in haskell
00:24:39 <adnap> lol
00:25:24 <kfr> http://en.wikipedia.org/wiki/APL_syntax_and_symbols look, it has monadic operators.
00:25:54 <dolio> Not the same monad. It's a trap!
00:26:07 <adnap> i'm going to be a monad next halloween guys
00:26:10 <adnap> lol
00:26:11 <ddarius> The main problem with J (the more modern and ASCIIified version of APL) besides quite a lot of insanity in the libraries, is that the parsing algorithm is simple except that it has steps like "if f is a monad parse like this, if it is a dyad parse like that" but whether f is a monad or a dyad is only known at run-time and is not necessarily constant even then.
00:26:26 <adnap> people will want to "bind" with me for sure
00:26:50 <dolio> So it's like perl.
00:26:51 <ion> I really enjoyed implementing a C ‘for’ loop in Haskell.
00:26:53 <kfr> I'll be your co-monad
00:27:35 <adnap> seriuosly though, how might you pull of such an abstract costume?
00:27:53 <adnap> i need to see pictures online of people dressed up as abstract math concepts
00:28:10 <kfr> Do you want to see my Y combinator?
00:29:05 <adnap> that sounds impressive
00:29:23 <adnap> okay, i'm going to bed
00:29:29 <adnap> nighty night
00:29:37 <ddarius> The other big problem with J/APL is that user-defined functions are never going to look as natural as the built-in ones.
00:30:05 <dolio> J functions are alphabetic, right?
00:30:35 <ddarius> User-defined ones are, I believe (more or less.)
00:32:57 <ion> kfr: Well?
00:33:16 <kfr> What?
00:33:24 <ion> to103935 < kfr> Do you want to see my Y combinator?
00:33:43 <kfr> ↑
00:33:46 <kfr> There, happy?
00:34:54 <kfr> > let ↑ = take in 10`↑`[1..]
00:34:55 <lambdabot>   <no location info>: parse error on input `
00:34:58 <kfr> :[
00:35:19 <kfr> > let (↑) = take in 10 ↑ [1..]
00:35:20 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
00:35:22 <kfr> Hahaha
00:35:24 <kfr> Glorious
00:45:44 <hvr> :t in
00:45:45 <lambdabot> parse error on input `in'
00:46:48 <dolio> The n-category cafe's math formatting changes almost every time I refresh.
00:53:16 <Baughn> Hm. We.. that is, GHC has an ARM port already?
00:53:32 <Baughn> ..
00:53:50 <Baughn> ...still need cross-compiling. I'm not going to try running it on my phone.
00:54:02 <dolio> That reminds me, I wonder if the webkit mathml support is now in my browser...
00:57:14 <dolio> That's a no.
00:58:17 <Eduard_Munteanu> Hmm, now that you brought it up I googled "mathml test". It works here in Firefox 3.6.13, but it looks sucky compared to TeX :)
01:00:12 <dolio> Well, that isn't surprising. Firefox has pretty decent math support, I think.
01:00:12 <Eduard_Munteanu> dolio: what is it you're using? Chrome?
01:00:12 <dolio> I used to have to read n-category cafe in firefox for that reason. But they switched to some javascript-based re-renderer at some point.
01:00:12 <dolio> rekonq
01:00:12 <Eduard_Munteanu> Baughn: you could use a VM and compile inside it.
01:00:25 <Eduard_Munteanu> Ah, some Konqueror spinoff
01:00:55 <dolio> Something like that. It's way slimmed down and less configurable, but uses webkit by default.
01:01:09 <Baughn> Eduard_Munteanu: Running an ARM emulator on my desktop would end up being as slow as compiling on the phone in the first place
01:02:42 <Eduard_Munteanu> Yeah, though it may afford some flexibility, e.g. in memory constraints.
01:03:28 <yitz> Eduard_Munteanu: safari is also a konqueror spinoff
01:04:19 <Eduard_Munteanu> dolio: I kinda liked Konqueror, for example I found it rather tough to set up search engines (with keywords) manually in Firefox. But I can't really part Vimperator.
01:04:38 <Eduard_Munteanu> yitz: rather a KHTML spinoff (i.e. WebKit), right?
01:04:42 <shachaf> Eduard_Munteanu: Really? Did Firefox change their keyword system?
01:04:54 <shachaf> Eduard_Munteanu: It used to be just making a bookmark with a %s in the URL and adding a keyword.
01:04:55 <dolio> Yes, webkit is ultimately a khtml fork.
01:05:25 <dolio> And yeah, I miss being able to type 'foo:whatever' to search for whatever on something I've programmed in when I use another browser.
01:05:50 <Eduard_Munteanu> shachaf: yeah, it's a bit non-obvious. Konqueror has (had?) a simple configuration menu where you could add those. And the Firefox people seem to be advocating getting addons for additional search engines.
01:06:29 * shachaf uses Chrom(e|ium) almost exclusively nowadays.
01:06:43 <dolio> Anyhow webkit got mathml support in the development version back in August, so I'm just waiting for the day when I can view all those non-existent math web pages.
01:07:30 <Eduard_Munteanu> dolio: so they don't have any fallback-on-rendered-images mechanism or something?
01:07:51 <Eduard_Munteanu> Those pages, I mean.
01:07:53 <shachaf> dolio: Hasn't anyone written a JavaScript MathML renderer userscript/bookmarklet of some sort?
01:08:15 <dolio> I've seen more and more web sites switching to some javascript-based renderer like the n-category cafe uses.
01:08:28 <dolio> Which makes it superfluous, I guess.
01:08:40 <dolio> Aside from the even poorer results.
01:09:03 <shachaf> dolio: JavaScript is an evil language and any effort to eliminate a bit of it from documents where not necessary isn't superfluous.
01:09:09 <Eduard_Munteanu> I'm personally waiting for Firefox 4 for HTML5 video stuff.
01:09:33 <Eduard_Munteanu> gnash is horrible and I don't really trust flash.
01:13:10 <ClaudiusMaximus> what's a sane way to fork a pure computation into the background and display something in my gtk gui to let me know that it hasn't just crashed, then update the gui when the results are ready?
01:14:12 <quicksilver> forkIO and put it in an MVar or Chan when complete.
01:14:38 <ClaudiusMaximus> right, so how do i avoid putting an expensive-to-compute thunk into said MVar or Chan?
01:15:41 <ClaudiusMaximus> (either that or have to actually think how to improve my algorithm...)
01:15:46 <Eduard_Munteanu> seq in that thread?
01:16:20 <quicksilver> putMVar mv $! computation
01:16:23 <ClaudiusMaximus> will have a go, it is a relatively simple result type.. Maybe (Rational, Rational)
01:16:29 <quicksilver> if WHNF is enough to force enough of the computation.
01:16:42 <ClaudiusMaximus> i could make a strict datatype for that
01:17:03 <quicksilver> no need, really, just force it with seq or strict patterns
01:17:57 <quicksilver> (case result of Just (p,q) -> p `seq` q `seq` ()) `seq` putMVar mv result
01:17:59 <quicksilver> something like that.
01:18:30 <ClaudiusMaximus> mm, well i'll have a go - but really i shouldn't be generating 2^d-3 rationals in 0..1 only to discard most of them for not being between two other rationals...
01:20:36 <augustss_> There are rational numbers that are not between two other rational numbers? :)
01:21:10 <Toxaris> @type \x y -> (floor ((x/y^2)*10^6)/10^6)
01:21:11 <lambdabot> forall a b. (RealFrac a, Integral b, Fractional b) => a -> a -> b
01:21:11 <sipa> no
01:21:21 <dolio> 1/0 and -1/0, of course.
01:21:28 <sipa> those aren't rational numbers
01:21:44 <Eduard_Munteanu> Surrationals make sense?
01:21:55 <ClaudiusMaximus> well, i have 2 rational numbers, and a denominator, and i want all the rationals that can be expressed as a fraction with that denominator, that lie between the given two rationals
01:22:06 <ClaudiusMaximus> probably it's really simple, but i can't think it through..
01:22:38 <sipa> you have a/b and c/d, and you want all n such that a/b < n/e < c/d
01:22:39 <sipa> ?
01:22:51 <sipa> and you have e
01:22:56 <ClaudiusMaximus> yeah
01:23:34 <ClaudiusMaximus> moreover 0 < a/b < c/d < 1
01:23:35 <dafis> ClaudiusMaximus:  ceiling (a/b*n) <= e <= floor (n*c/d)
01:24:01 <dafis> now insert a few fromInteger
01:24:26 <Eduard_Munteanu> You can also compare rationals without doing the actual division.
01:24:48 <dafis> ClaudiusMaximus:  and be aware that I confused e and n
01:25:12 <ClaudiusMaximus> Eduard_Munteanu: right, that's what i'm doing - filter itWorks [huge list of rationals]
01:25:32 <ClaudiusMaximus> dafis: right, i think i just need to scribble a bit
01:26:09 <ClaudiusMaximus> sipa: thanks for the clarity
01:27:14 <Eduard_Munteanu> Yeah, given a/b and c/d, you can compare them by comparing a*d and b*c.
01:27:53 <Eduard_Munteanu> It's like dividing them and seeing if you get something > 1 or not.
01:30:13 <ClaudiusMaximus> > let ab = 45 % 71 ; cd = 46 % 71 ; e = 147 in [ ceiling (ab * e) .. floor (cd * e) ]
01:30:15 <lambdabot>   [94,95]
01:30:26 <ClaudiusMaximus> woop
01:38:00 <jay> hi
01:38:04 <jay> anyone here
01:38:25 <Guest63966> hi
01:38:30 <Guest63966> hello
01:38:46 <Guest63966> any one know programming
01:38:47 <Guest63966> >
01:38:50 <Guest63966> ???????????????/
01:39:01 <sipa> on a channel about a programming language?
01:39:03 <sipa> doubtful
01:39:26 <sipa> :)
01:39:31 <Guest63966> any one loves solving puzzles
01:39:32 <Guest63966> ?
01:40:49 * ddarius just realized that his muggers stole his yen.  Which, on the one hand, is kind of annoying since it was 2000 yen and I'd had it in my wallet for over a year, but, on the other hand, is kind of entertaining when I consider their reaction.
01:48:07 <alios> what is ghc going to tell me with: "Could not deduce (m ~ IO)" ? http://pastebin.com/jQnEAqJU 
01:50:20 <sipa> can you show the code?
01:52:52 <Saizan> that you're trying to use something of type IO Foo where something of type m Foo is expected
01:53:07 <Saizan> so it seems you lack a liftIO
01:53:24 <Saizan> ~ is type equality
01:53:31 <alios> ah ok... got it thnx!
01:54:05 <alios> ~ equality on type level... nice ... think i've seen it on some rocket science type level programming code ;)
01:54:58 <gienah> @karma Saizan
01:54:59 <lambdabot> Saizan has a karma of 15
01:55:18 <Entroacceptor> what?
01:55:21 <Entroacceptor> @karma eno 
01:55:22 <lambdabot> eno has a karma of 0
01:55:28 <Entroacceptor> @karma Entroacceptor 
01:55:29 <lambdabot> You have a karma of 1
01:55:33 <Entroacceptor> oooh
01:55:42 <dafis> @karma lambdabot
01:55:42 <lambdabot> lambdabot has a karma of 2
01:55:46 <Entroacceptor> what is it, and where does it come from?
01:56:00 <quicksilver> Entroacceptor++ # asking questions
01:56:01 <dafis> lambdabot++
01:56:04 <dafis> @karma lambdabot
01:56:04 <lambdabot> lambdabot has a karma of 3
01:56:06 <quicksilver> @karma Entroacceptor 
01:56:06 <lambdabot> Entroacceptor has a karma of 2
01:56:09 <quicksilver> like that.
01:56:42 <dafis> @karma quicksilver
01:56:43 <lambdabot> quicksilver has a karma of 23
01:56:54 <dafis> wow
01:57:12 <dafis> @karma dafis
01:57:13 <lambdabot> You have a karma of 2
01:57:17 <dafis> so-so
01:58:28 <gienah> Saizan++
01:59:23 <alios> whoot ...
01:59:33 <alios> @karma alios
01:59:33 <lambdabot> You have a karma of 0
01:59:40 <gienah> @karma++ Saizan
01:59:40 <lambdabot> Saizan's karma raised to 17.
01:59:57 <alios> ahh got the idea ;)
02:00:58 <alios> @Saizan++
02:00:58 <lambdabot> Unknown command, try @list
02:01:16 <alios> @karma++ Saizan
02:01:17 <lambdabot> Saizan's karma raised to 18.
02:03:08 <Saizan> so much karma :O
02:05:42 <alios> :)
02:31:22 <jonkri> looking at the "I/O with Handles" section at [ http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html ], what other than "hGet handle 1" can i use to iteratively read the whole stream? (hGetSome is not exported in my distribution (ghc on fedora 14))
02:37:55 <yitz> hGetContents?
02:41:11 <yitz> hGetSome is exported. perhaps you need to cabal install bytestring to get a later version, if that's what you need.
02:41:37 <yitz> jonkri: ^
02:42:45 <dcoutts> yitz, jonkri: or hGetNonBlocking + hWaitForInput
02:56:22 <jonkri> is the stream i receive over a tcp connection word8 lists that i can use with http://hackage.haskell.org/package/utf8-string?
02:56:43 <jonkri> i know it is utf-8 encoded
02:56:59 <jonkri> nevermind, i should just try it out
03:03:22 <dafis> jonkri:  utf8-string just provides encoding and decoding functions for ByteStrings
03:03:40 <dafis> so, yes you can
03:06:08 <jonkri> as i receive the characters on a byte per byte level, i'm considering using http://hackage.haskell.org/packages/archive/utf8-string/0.3.6/doc/html/Data-String-UTF8.html#v:uncons to make sure that i'm not decoding any characters that are not complete utf-8 characters. however, i can't seem to figure out how to construct a UTF8 variable... http://hackage.haskell.org/packages/archive/utf8-string/0.3.6/doc/html/Data-String-UTF8.html#t:UTF8
03:06:41 <jonkri> (i want to create a UTF8 variable for testing)
03:13:03 <quuuux> http://pastebin.com/ZPb4bdUH - that's surely not the most elegant way to do this, right?
03:14:37 <b52> what is a good list implementation which can handle large amounts of data in a fast way?
03:15:10 <Twey> b52: What sort of data?
03:15:20 <b52> strings
03:15:40 <Twey> ByteStrings sound like a good idea
03:16:08 <Taejo> or Text
03:16:15 <Twey> Yeah
03:16:23 <Taejo> depending on whether it's text strings or strings of bytes
03:17:06 <b52> well, but i need a list of bytestrings, dont iß
03:17:38 <quuuux> b52: the goodness of an implementation depends on what you'll be doing with it
03:17:42 <Eduard_Munteanu> Well that depends on your access patterns.
03:18:07 <quuuux> b52: if you generate and consume the strings linearly and lazily, you'd be hard-pressed to beat the standard linked list
03:18:09 <b52> quuuux: a lot appending, reading from the end and removing from the end
03:18:44 <Taejo> a rope might work well
03:18:47 <Eduard_Munteanu> On the "list" of bytestrings?
03:18:53 <b52> yes
03:19:04 <Eduard_Munteanu> You could use a Seq for efficient access to both ends.
03:19:27 <quuuux> b52: if you really only need one end, just use a linked list and store it in reverse order?
03:19:28 <Eduard_Munteanu> from Data.Sequence.
03:19:39 <Eduard_Munteanu> Yeah, or that.
03:19:59 <Taejo> a Rope has the same asymptotics as a Seq, afaik, but optimized for strings
03:20:24 <b52> Taejo: where do i find it?
03:20:37 <Taejo> b52: in the "rope" package on hackage
03:25:25 * quuuux has turned 6 lines of case-examining into... 6 lines of case examining. With more variables and function applications, yay
03:27:44 <quuuux> @djinn (a, b) -> c -> (a, b, c)
03:27:44 <lambdabot> f (a, b) c = (a, b, c)
03:28:04 <quuuux> @pl \ (a, b) c -> (a, b, c)
03:28:04 <lambdabot> uncurry (,,)
03:28:11 <quuuux> aha, that's the magic incantation
03:28:15 <jonkri> how can i make a variable of type "UTF8Bytes [Word8] Int" as defined in [ http://hackage.haskell.org/packages/archive/utf8-string/0.3.6/doc/html/Data-String-UTF8.html#t:UTF8Bytes ]... something like this: let utf8Bytes = ([155, 124, 64, 12, 155] 5) :: UTF8Bytes [Word8] Int
03:33:05 <Eduard_Munteanu> jonkri: UTF8Bytes is a typeclass, not a type
03:33:29 <Eduard_Munteanu> [Word8] Int is an instance of that.
03:34:49 <Eduard_Munteanu> jonkri: so something like toString [155, 124, 64] will do
03:35:00 <Eduard_Munteanu> *will work
03:35:44 <Eduard_Munteanu> Erm, probably with fromRep
03:43:01 <mun> if a logic is simply typed, does that mean a type variable 'a can't be instantiated to say, 'b => 'c?
03:45:07 <Eduard_Munteanu> mun: do you mean simply-typed lambda calculus?
03:45:15 <mun> Eduard_Munteanu, yes
03:45:19 <Eduard_Munteanu> mun: it doesn't have polymorphism if that's what you're asking.
03:45:25 <Eduard_Munteanu> So all types are concrete.
03:45:50 <mun> Eduard_Munteanu, thanks
03:51:12 <thecod> mun: though it is possible for a curry style term to have several types...
03:51:43 <mun> thecod, what do you mean?
03:52:37 <thecod> \x -> x has type 'a => 'a, but also ('b => 'c) => ('b => 'c)
03:53:15 <thecod> so in general there is not a big difference in expressivity between simply typed LC and a calculus with let polymorphism
03:53:42 <thecod> system F jumps a huge level though...
03:53:55 <thecod> (maybe I'm getting too technical)
03:53:55 <zygoloid> \o/ recursion
03:54:22 <thecod> zygloid : putting aside recursion for now of course
03:56:23 <quicksilver> thecod: depending on terminology, \x -> x is not strictly speaking a term of STLC
03:56:33 <quicksilver> STLC terms have types on the lambdas
03:56:35 <quicksilver> \ (x : t) -> x
03:56:46 <quicksilver> and then it has a single type t - > t
03:57:10 <thecod> quicksilver: I was referring to the "curry style calculus"
03:57:31 <thecod> as opposed to the (better behaved) "church style calculus"
03:58:05 <thecod> though every well-typed term in one can be translated to a well-typed term in the other
03:58:48 <zygoloid> is there a natural 'maximal' system between STLC and System F which is still total?
03:59:26 <jonkri> thanks people
04:00:13 <thecod> zygoloid: What do you mean by "maximal" and what do you mean by "total"?
04:01:26 <Eduard_Munteanu> zygoloid: System F *is* total
04:01:34 <Eduard_Munteanu> In fact all of them are.
04:02:12 <zygoloid> Eduard_Munteanu: System F is turing-complete, isn't it?
04:02:24 <Eduard_Munteanu> Fix and unrestricted recursion is independent of the actual flavour of the type system.
04:02:24 <Philippa_> nope
04:02:26 <thecod> zygoloid: no...
04:02:40 <zygoloid> huh.
04:02:44 <companion_cube> can't you write fix on the type level ?
04:03:10 <thecod> System F has the amusing property that only (and all) provably total (in 2nd order arithmetic) functions can be defined
04:03:22 <thecod> you can't write any functions on the type level
04:03:33 <Eduard_Munteanu> Do you mean fixed-points of datatypes. Maybe, but you can't recurse them at value level anyway.
04:03:49 <Eduard_Munteanu> s/datatypes\./datatypes?/
04:04:39 <mun> thecod, but in terms of expressivity, should there be any difference at all between simply typed LC and a calculus with let polymorphism?
04:04:44 <companion_cube> i'd mean a type constructor similar to fix, but of kind (* -> *) -> *
04:04:53 <companion_cube> or maybe i'm just too confused ::
04:04:55 <companion_cube> :/
04:05:01 <Eduard_Munteanu> Like Mu?
04:05:23 <Eduard_Munteanu> Well, consider a list defined like that. How would you actually recurse over it?
04:05:32 <thecod> mun: I don't believe there is: just inline all the lets, and you have a (curry style) simply typed lambda term
04:06:08 <Eduard_Munteanu> The list may be defined isorecursively, but not having any recursion primitive makes the language total.
04:06:09 <thecod> companion_cube: there is no kind (*->*)->* in system F
04:06:10 <mun> thecod, what do you mean by inlining all the lets (sorry for my lack of knowledge with the terminology)?
04:06:38 <Eduard_Munteanu> In fact types don't really matter since they're erased anyway.
04:06:53 <thecod> mun: no problem: replace let x = t in u by u[x |-> t] is inlining of lets
04:06:55 <companion_cube> i thought there was sort of an untyped lambda calculus at the level of types (with type abstraction and application) in system F
04:07:22 <zygoloid> so what extensions to System F do you need in order to desugar Haskell to it?
04:07:32 <Eduard_Munteanu> System F omega is the one with kinds, IIRC the terminology
04:07:40 <thecod> zygloid: system F_omega
04:08:03 <zygoloid> ah. then that's what i originally wanted to ask about, and it seems like the answer is System F :)
04:08:16 <thecod> this system is more powerful, but you can't do things like List X = X + List X
04:08:43 <mun> thecod, i see. i believe [ x |-> t] denotes a substitution?
04:08:52 <thecod> yes
04:09:01 <mun> thanks
04:09:03 <thecod> (avoiding variable captures)
04:09:07 <thecod> http://www.cis.upenn.edu/~bcpierce/tapl/index.html
04:09:15 <thecod> pierce explains all this much better than I do
04:09:45 <thecod> my main point is that STLC is about as powerful as let-polymorphism
04:10:38 <rks> STLC ?
04:10:48 <Eduard_Munteanu> Simply-typed lambda calculus
04:10:59 <rks> Oh, thanks
04:11:08 <thecod> Hope i'm not being too technical on this channel
04:11:47 <rks> thecod: and hmm, what's your definition of "powerful" ?
04:13:43 <thecod> rks: the expressivity of the language, i.e. what functions can we define?
04:14:07 <rks> that's what I thought
04:14:17 <thecod> It's a bit of a tricky question, because i don't even have integers in STLC
04:14:29 <dolio> Are we assuming that lets are interpreted by inlining the definition everywhere?
04:14:29 <rks> let's admit you have them :p
04:14:44 <rks> dolio: I think we do
04:14:53 <Eduard_Munteanu> You can have integers in STLC.
04:14:58 <thecod> dolio: how else would you interpret them? :)
04:15:02 <companion_cube> STLC without fix is not turing complete, right ?
04:15:11 <Eduard_Munteanu> Yeah.
04:15:14 <thecod> companion_cube: far from it
04:15:22 <dolio> let x = e in e' ==> (\x -> e') e
04:15:24 <thecod> you can't even define exponential
04:15:36 <companion_cube> so, types are bad :D
04:15:41 <dolio> But that won't work.
04:15:52 <companion_cube> let's get rid of it, and code in untyped LC !
04:16:02 <thecod> dolio: you can take that too, but then let-polymorphism doesn't work for typechecking
04:16:07 <rks> companion_cube: \o/
04:16:13 <Eduard_Munteanu> dolio: the assumption is you're doing it smart, like replacing variable name with fresh ones etc.
04:16:33 <Eduard_Munteanu> *names
04:17:15 <astroboy> How can I make parsec fail?
04:17:15 <companion_cube> let-polymorphism works in ocaml, for instance, no ?
04:17:23 <Eduard_Munteanu> companion_cube: untyped is still not Turing-complete without fix
04:17:30 <dolio> Eduard_Munteanu: My point was, you need genuine polymorphism if you want to desugar lets (with polymorphism) into lambda abstractions. Simple types won't do.
04:17:43 <companion_cube> Eduard_Munteanu, you can write fix in untyped LC
04:18:26 <Eduard_Munteanu> Yeah.
04:19:08 <companion_cube> so it's turing complete, right ? :)
04:19:26 <dolio> Yes.
04:19:29 <Eduard_Munteanu> Yeah.
04:19:54 <Eduard_Munteanu> I wanted to say you can't make self-referential definitions.
04:21:11 <thecod> Eduard_Munteanu: \ f -> (\x -> f (x x)) (\x -> f (x x))
04:21:13 <thecod> gah
04:21:19 <thecod> took me forever to remember
04:21:37 <Eduard_Munteanu> Omega?
04:21:47 <thecod> much more usefull
04:22:05 <companion_cube> omega is useless
04:22:09 <thecod> apply it to (\x -> x) and you get omega
04:22:42 <companion_cube> i think the good fix is  \f. (\x. f (\y. x x y)) (\x. f (\y. x x))
04:22:57 <sipa> @pl r s m = f s (g m)
04:22:58 <thecod> apply it to \ f x -> if x==0 then 1 else x * f (x-1) then you get fact!
04:22:58 <dolio> Pfff. The good fix.
04:22:58 <lambdabot> r = (. g) . f
04:23:07 <Eduard_Munteanu> Erm, I think it was the Y.
04:23:51 <thecod> companion_cube: that one was given by Turing I believe
04:23:56 <thecod> it behaves a bit better
04:24:10 <companion_cube> the one i gave is in pierce's book :)
04:24:11 <Eduard_Munteanu> Anyway, the choice between Y and Z is given by the semantics (strict/non-strict).
04:24:21 <companion_cube> but anyway, both work
04:24:23 <Eduard_Munteanu> But I'm not sure if omega is useful in any instance.
04:24:28 <dolio> That's the one all those eager evaluators use.
04:24:54 <thecod> Eduard_Munteanu: i'ts the minimal example of a non terminating function
04:25:17 <thecod> it's useful to show that some system is not consistent...
04:25:29 <companion_cube> and to prove non behavioral equivalence
04:25:46 <companion_cube> \_ -> omega is in fact more useful in strict languages
04:25:54 <Eduard_Munteanu> Y only works in lazy languages IIRC.
04:26:12 <thecod> It's the "calculatory Rosser paradox"
04:27:02 <Eduard_Munteanu> thecod: but does omega even yield a correct term in any language?
04:27:12 <thecod> many
04:27:46 <astroboy> I mean I can make parsec fail with "fail", but I have to provide an error message
04:27:51 <Eduard_Munteanu> Though I remember someone saying here even the Y combinator is not expressible in Haskell.
04:27:55 <astroboy> can't I just make it fail?
04:28:12 <Eduard_Munteanu> astroboy: fail' = fail "" ?
04:28:41 <Eduard_Munteanu> As in it's untypeable.
04:28:55 <thecod> Eduard_Munteanu: Not as such, but you can just define Y f = f (Y f)
04:28:56 <dolio> You can wrap it up in some bad types.
04:29:08 <astroboy> Eduard_Munteanu: oh right... mhm it's not expecting anything so I have to provide the error
04:34:54 <thecod> newtype Z = Z (Z -> Z)
04:34:58 <thecod> omega = \(Z x) -> x (Z x)
04:35:24 <thecod> no wait that's delta
04:35:47 <dolio> I thought it was little omega.
04:36:02 <ketil> http://lwn.net/Articles/423732/#Comments - I think there are some lessons for us there, re Hackage vs distribution packages.
04:36:14 <ketil> (oh, skip the #Comments bit - or scroll up)
04:36:19 <thecod> little omega would be delta (Z delta)
04:36:31 <dolio> I thought that was big omega.
04:36:45 <thecod> hmmm
04:36:50 <dolio> It doesn't really matter.
04:36:53 <thecod> i guess it depends on the ref
04:37:01 <dolio> Anyhow, you can do something more fun than that.
04:37:56 <thecod> ?
04:38:21 <thecod> hehe
04:38:27 <dolio> newtype Evil a = Roll { rock :: Evil a -> a } ; fix f = let yum x = f (rock x x) in yum (Roll yum)
04:38:45 <dolio> If I got that right.
04:39:02 <thecod> looks about right
04:39:40 <ivanm> ketil: I don't think our situation is anywhere near that bad
04:39:43 <dolio> However, GHC's inliner is prone to going into loops when you do that.
04:40:11 <thecod> if you can write omega though there is usually a way to write fix anyhow
04:40:26 <ivanm> I know that flameeyes bitches about the ruby situation in gentoo as well, and most of the problems seem to be stupidity by whoever wrote gems and that too many ruby developers think it's OK to tell people to get it off github rather than actually release something
04:40:33 <thecod> dolio: when is the inliner started anyways?
04:40:52 <dolio> Eh?
04:41:10 <quuuux> ivanm: does ruby suffer from anything similar to the 'butterfly effect' outlined in one of those blog posts?
04:41:24 <ketil> ivanm: No, sorry, I didn't mean to imply it is.  
04:41:39 <ivanm> ketil: I didn't mean to imply that you implied that ;-)
04:41:40 <ketil> But I think we could be headed in that direction.
04:41:55 <ivanm> quuuux: you mean about versioning, etc. and how to deal with it?
04:42:06 <ketil> ivanm: in that case, forgive for implying you implying that I did imply it.
04:42:08 <ivanm> I don't think that was ever a major concern from any of the bitches^W blog posts that I read
04:42:14 <ivanm> ketil: heh
04:42:16 <dolio> Incidentally, the idea was, Evil lets you write fix :: (a -> a) -> a. Instead of (Z -> Z) -> Z.
04:42:24 <quuuux> ivanm: I mean breaking the system silently by installing entirely new packages
04:42:36 <ivanm> huh?
04:42:38 <Ke> haskell still has abysmal practices like compiler specific package database
04:42:44 <thecod> dolio: ah yes nicer that what i had
04:42:54 <ivanm> oh, you mean "network is upgraded and so everything that depended upon it is broken"?
04:43:02 <ivanm> Ke: yeah :s
04:43:12 <quuuux> ivanm: right, and how that can happen silently if you're not careful
04:43:13 <ivanm> of course, part of the reason is that various compilers don't mix too well
04:43:23 <ivanm> quuuux: I use gentoo, so that isn't a problem for me ;-)
04:43:28 <ivanm> it happens with _everything_
04:43:32 <ketil> quuuux, from my brief browsing of the Ruby stuff, it seems the problem is that ruby devs like to bundle all their dependencies and dump them into /usr, while debian devs want to manage each dependency as a separate, shared entity.  And keep the filthy hands of users out of /usr.
04:44:02 <dolio> thecod: Anyhow, the inliner is part of optimization during compilation.
04:44:07 <ivanm> ketil: yeah, as limited as Cabal is, dcoutts et. al. have for the most part been much more sensible about it
04:44:31 <ivanm> the only major concern I've heard about haskell stuff wrt /usr, etc. is that the pkg-db should be in /var, not /usr/lib
04:44:44 <ketil> Along with slack adherence to any versioning on the ruby devs (no PVP), this makes things difficult.
04:44:52 <dolio> It assumes that you can't write code that inlines to itself without resorting to explicit self-reference.
04:45:06 <Eduard_Munteanu> It'd be a really bad idea to ask *users* to cabal install packages in order to use a Haskell app.
04:45:08 <dolio> Because types rule that out, unless you play tricks like Evil or Z.
04:45:08 <thecod> dolio: always? I mean, at what level of optimisation is inlining performed?
04:45:29 <ivanm> Eduard_Munteanu: you mean system-wide?
04:45:31 <thecod> What about recursive functions?
04:45:33 <dolio> Well, probably -O and above.
04:45:40 <ketil> ivan, I think we need more standardization on package versions like the Platform, and more PVP on central packages (whatever they are).
04:45:50 <Eduard_Munteanu> ivanm: yeah.
04:46:01 <ketil> And separation of packages into tiers based on maintenance level and importance.
04:46:13 <ketil> I guess these are fairly non-controversial thoughts :-)
04:46:21 <Eduard_Munteanu> I mean, if you make non-distro specific packages, you should probably provide either source or a statically linked app.
04:46:39 <Eduard_Munteanu> But for distro-specific packages, cabal install is a bad idea.
04:47:16 <dolio> it knows about recursive functions like 'f x = ... f e ...', but it assumes that's the only way of introducing recursion that it needs to worry about.
04:47:20 <quuuux> having several separate package managers on a single system makes me squirm anyway
04:47:22 <ketil> BTW - I was looking for a bug tracker, but ran across John Goerzen's comments (also on LWN) where he laments (being a package maintainer) having to manage conversation between user and upstream developer.
04:47:47 <ketil> Maybe I should just get my stuff packaged in a distro, and simply use their BTS as the official one?
04:47:48 <dolio> So if you manage to write (\x -> x x) (\x -> x x) it will happily inline forever.
04:47:49 <ketil> :-)
04:47:53 <dafis> Question: how should I call a function that computes the (integer) fourth root of a nonnegative integer? And how a function that tests whether an integer is a fourth power? Any better ideas than integerFourthRoot and isFourthPower?
04:47:57 <Eduard_Munteanu> Uhm, that's part of the job?
04:48:28 <thecod> dolio: ah ok, that's nice to know if i ever encode U- into haskell :)
04:48:34 <thecod> anyways
04:48:37 <thecod> have to get back to work
04:48:46 <thecod> thanks for the talk
04:49:05 <quuuux> I'd much rather fob off everything package-management related to dpkg, and just use cabal for the actual installation step. There are technical issues with both dpkg and haskell's package system that get in the way, though
04:49:16 <ketil> Eduard_Munteanu, going in-between?  Yes, but I know it is still frustrating.  I hate it when somebody calls me to tell me to call somebody and tell them...etc.  But yes, in general users don't even know which package is the problem.
04:51:01 <quicksilver> quuuux: cabal is more of a build tool than a package management system.
04:51:09 <quicksilver> quuuux: the tension definitely exists, though.
04:51:23 <Eduard_Munteanu> Yeah, it's rather the analogoue of autotools.
04:51:30 <quuuux> quicksilver: by 'cabal' I mean both cabal and cabal-install, of course :)
04:51:31 <Eduard_Munteanu> *analogue
04:51:40 <quicksilver> quuuux: the way the debian + perl people make it easy to fetch + debianise CPAN packages is quite good.
04:51:56 <quicksilver> as long as the CPAN package is "reasonably" well behaved you get a .deb out of it automatically
04:52:12 <quicksilver> something like that for cabal-install would be nice, and the cabal guys agree it would be nice.
04:52:24 <yitz> dafis: those names aren't bad. you don't need to say integer if those are the only one you consider. or you can say int.
04:52:37 <quuuux> quicksilver: one thing I like about cabal is that you don't need to go and make a whole new chroot for a local installation of packages, which you do with dpkg
04:52:57 <yitz> dafis: you could shorten them by saying things like root4 but it's less clear.
04:53:22 <quicksilver> quuuux: yeah, dpkg is really at odds with the whole notion of local packages. That just wasn't part of its initial planned scope.
04:53:32 <quicksilver> quuuux: although plenty of people wish that wasn't so.
04:53:41 <Eduard_Munteanu> I kinda agree, most package managers don't do local package management, I think that's a bad thing.
04:54:20 <Eduard_Munteanu> It kinda goes against the philosophy of unix, i.e. multi-user environment
04:54:34 <ivanm> ketil: yes to more PVP, and as for a bug tracker... so far I just use email :p
04:54:44 <dafis> yitz:  any integral type; root4 is ugly I'd hate that; Now the hardest question: for general powers, the function taking two args integerKthRoot, isKthPower ? And in which order should they take the arguments?
04:54:49 <Eduard_Munteanu> I think GoboLinux has something like that though.
04:54:59 <ivanm> quuuux: if you want to, I wrote a blog post a while back about how cabal-install isn't a package manager
04:55:16 <ivanm> Eduard_Munteanu: also to an extent nixos
04:55:19 <yitz> dafis: you're on your own :)
04:55:26 <ivanm> there's stow for local package management
04:55:33 <ivanm> or use gentoo prefix ;-)
04:55:51 <quuuux> nixos looked really interesting, but it never had enough momentum :/
04:55:52 <Eduard_Munteanu> ivanm: hm, I never tried, does Gentoo allow you to do that as a normal user?
04:56:02 <ivanm> yes
04:56:05 <Eduard_Munteanu> Even so, it's probably not what you want.
04:56:18 <ivanm> I've heard of people having gentoo prefix on fedora machines
04:56:19 <Eduard_Munteanu> Since it doesn't combine global packages with local ones when calculating deps.
04:56:31 <ivanm> oh, did you mean installing packages within gentoo locally? then no
04:57:13 <Eduard_Munteanu> ivanm: let's say I'm already doing ./configure --prefix=~/local && make install. I could use the package manager itself doing that for me.
04:57:28 <ivanm> hmmm...
04:57:29 <Eduard_Munteanu> As a regular user.
04:57:33 <ivanm> yeah, I think stow can do that
04:58:08 * Eduard_Munteanu looks at stow
04:58:12 <ivanm> in terms of a similar concept (but globally): paludis (for gentoo and exherbo) allows you to do that to install packages _globally_ for which there isn't an ebuild/exhere but keep your manually-built packages under the control of your package manager
04:59:48 <Eduard_Munteanu> Hrm, 'stow' doesn't seem to do any dependency tracking.
05:00:34 <quuuux> hey, there's a gap in the market here. Let's write an awesome package manager in Haskell that can do local installs properly :)
05:01:15 <Silvah> :t (\\)
05:01:16 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
05:01:30 <Silvah> > [1, 2, 3] \\ [1, 2, 3]
05:01:31 <lambdabot>   []
05:01:40 <Silvah> > [1, 2, 3] \\ [1]
05:01:41 <lambdabot>   [2,3]
05:01:57 <dafis> > [1,2,3,1,2,3] \\ [1,2,3]
05:01:58 <lambdabot>   [1,2,3]
05:02:22 <Dan__> Hi I'm relatively new to writing in Haskell and was wondering if I could get help with something I'm working on?
05:02:34 <dafis> probably
05:02:44 <zenzike> Dan__: feel free to ask :-)
05:03:47 <Dan__> I'm trying to  create a sudoku solver but I can't seem to get off the ground with it. I've wirtten a function to create a row in the sudoku board, but I can't seem to find a way to create an nxn board using the rows
05:04:08 <dafis> Dan__:  list of lists?
05:04:21 <dafis> (or array)
05:04:34 <ivanm> Dan__: _another_ sudoku solver?
05:04:44 <dafis> Note: list of lists /= array
05:04:45 <ivanm> Dan__: better idea: read bird's/hutton's sudoku solver
05:05:40 <Dan__> I'll give that solver a search
05:05:42 <Dan__> thanks
05:16:41 <o^_^o> > runState (put 3) 4
05:16:43 <lambdabot>   ((),3)
05:17:05 <o^_^o> runState :: State s a -> s -> (a,s)
05:19:01 <burp> > runState (return 3) 4
05:19:03 <lambdabot>   (3,4)
05:19:16 <o^_^o> in the above computation, (put 3)  gives State 3 (), which is fed to runState (State 3 ()) 4, shouldn't I get ((), 4) as result ?
05:19:30 <o^_^o> or rather I don't get it
05:19:43 <dafis> o^_^o:  4 is the state at the start
05:19:49 <dafis> then ou put 3
05:19:54 <dafis> you*
05:19:58 <o^_^o> ah
05:20:20 <dafis> > runState (undefined >> put 3) 7
05:20:21 <lambdabot>   ((),3)
05:21:43 <dafis> o^_^o:  a value of type (State s a) is basically a function of type (s -> (a,s)); what you provide to runState is the argument of that function
05:24:17 <o^_^o> dafis, I am still thinking about what you said...
05:24:35 <dafis> o^_^o:  if you have any questions, ...
05:25:17 <o^_^o> dafis, so runState :: (a -> (a,s)) -> s -> (a,s)
05:26:07 <dafis> o^_^o:  not quite, basically means "wrapped in a newtype wrapper" here, runState unwraps it
05:26:37 <o^_^o> I have this 'feeling' that put 3 is evaluated first and returns a computation, which is State 3 () and then runState has State 3 () and 4 as arguments.
05:26:41 <o^_^o> is this wrong ?
05:27:12 <o^_^o> runState::(put 3) -> 4 -> ((),3)
05:27:28 <o^_^o> runState::State 3 () -> 4 -> ((),3)
05:27:37 <dafis> o^_^o:  "put 3" is (State \_ -> ((), 3)) [except State is now a type synonym]
05:27:58 <burp> put is not return
05:28:06 <dafis> so, runstate (put 3) is (\_ -> ((), 3))
05:28:17 <mm_freak_> o^_^o: look at the definition of 'State'
05:28:26 <mm_freak_> @src State
05:28:27 <lambdabot> Source not found. Wrong!  You cheating scum!
05:28:40 <mm_freak_> newtype State s a = State (s -> (a,s))
05:28:56 <o^_^o> mm_freak_, ah...
05:29:02 <o^_^o> dafis, yeah now I get it
05:29:03 <mm_freak_> > runState (State $ \s -> (5, s)) 15
05:29:04 <lambdabot>   Not in scope: data constructor `State'
05:29:10 <mm_freak_> > runState (S $ \s -> (5, s)) 15
05:29:11 <lambdabot>   Not in scope: data constructor `S'
05:29:21 <mm_freak_> what's the constructor called in lambdabot?
05:29:31 <o^_^o> dafis, tutorial says  put :: s -> State s ()
05:29:41 <dafis> mm_freak_:  State s is now StateT s Identity
05:30:03 <dafis> > runState (state $ \s -> (5,s)) 15
05:30:04 <lambdabot>   (5,15)
05:30:34 <mm_freak_> ah, ok
05:30:36 <Palmik_> Hi, what is the reason for keeping old length and such when there already are their generic counterparts? Could it break some existing code and if so, what kind of code?
05:30:54 <dafis> > runIdentity $ runStateT (StateT $ \s -> return (5,s)) $ 15
05:30:54 <o^_^o> dafis, I am kinda getting it
05:30:55 <lambdabot>   (5,15)
05:31:03 <mm_freak_> > runState (StateT $ \s -> return (5, s)) 15
05:31:04 <lambdabot>   (5,15)
05:31:07 <mm_freak_> there we go
05:31:15 <dafis> Palmik_:  efficiency
05:31:45 <mm_freak_> o^_^o: to understand State best, implement it yourself
05:31:47 <quuuux> Palmik_: don't quote me on this, but IIRC it's efficiency. Int is an easy to optimise type, but fromIntegral can turn it into something slow
05:31:48 <dafis> Palmik_:  working on Int can be *much* faster than on a generic Integral type
05:31:52 <mm_freak_> o^_^o: start with Reader and then implement State
05:31:57 <o^_^o> mm_freak_, ok
05:32:03 <mm_freak_> Reader is simpler:  newtype Reader e a = Reader (e -> a)
05:32:16 <mm_freak_> it's almost like State, but the state is not modifyable
05:33:14 <Palmik_> I guess you are right, it's in the comments "It is, however, less efficient than 'length'."
05:33:33 <o^_^o> mm_freak_, ok
05:34:36 <dafis> Palmik_:  that's because with Int, you can make length a strict left fold, with a generic type it must be a lazy right fold
05:35:54 <mm_freak_> dafis: huh?
05:36:12 <mm_freak_> why a lazy right fold?
05:36:13 <dafis> mm_freak_:  data Peano = Zero | Succ Peano
05:36:27 <mm_freak_> that's one edge case
05:36:50 <mm_freak_> also nobody represents lazy numbers like this
05:36:50 <dafis> mm_freak_:  yes, but as a lazy language, Haskell feels obliged to cater for it
05:37:35 <dafis> mm_freak_:  indeed, there are more efficient versions of lazy Peano numbers on hackage
05:37:44 <mm_freak_> data LazyNum = LazyBit Bool LazyNum | Stop
05:37:47 <mm_freak_> that's my variant
05:38:30 <mm_freak_> or in fact mostly:  data OneBit s; data ZeroBit s; data Stop
05:38:31 <mm_freak_> =)
05:38:40 <dafis> mm_freak_:  how do you do a maximally lazy if length xs > 3 with that?
05:39:08 <dafis> little-endian?
05:39:53 <dafis> no, doesn't work either, I think
05:44:22 <mm_freak_> dafis: well, obviously that representation can't be big endian
05:44:50 <Ke> so anyone going to fix code.haske..org
05:44:59 <mm_freak_> Ke: what's wrong with it?
05:45:20 <mm_freak_> ok, i see
05:45:26 <Ke> the same old
05:45:42 <lespaul> hi! I'm new in this world called functional programming,  could anybody recommend me some book to learn please?
05:45:51 <dafis> mm_freak_:  but you don't know whether the length of the list is even before you've reached the end, so those numbers can't be particularly lazy for that task
05:46:05 <lespaul> I have a teacher who told me Haskell is great and I should learn something about it
05:46:11 <dafis> @where LYAH
05:46:12 <lambdabot> http://www.learnyouahaskell.com/
05:46:21 <dafis> @where RWH
05:46:21 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
05:46:36 <dafis> lespaul:  for starting, LYAH
05:46:53 <lespaul> LYAH?
05:47:06 <lespaul> mmm ok I'll search it, thank you very much
05:47:09 <rribeiro> lespaul, programming in haskell by Graham Hutton is a good book too
05:47:09 <dafis> Learn You A Haskell
05:47:11 <sipa> lespaul: learn you a haskell
05:47:15 <sipa> see links above
05:47:16 <lespaul> ok ok
05:47:31 <mm_freak_> dafis: why not?
05:48:00 <mm_freak_> even (LazyBit b _) = not b
05:48:13 <dafis> mm_freak_:  because you have to flip the bits on your way, or do I miss something obvious?
05:48:41 <mm_freak_> dafis: see above
05:48:53 <dafis> mm_freak_:  but no bit is determined before the end is reached
05:49:22 <mm_freak_> dafis: sure it is…  this type is isomorphic to [Bool]
05:49:41 <mm_freak_> with little endian first
05:49:57 <mm_freak_> [False, True] is 10, not 01
05:51:14 <dafis> mm_freak_:  yes, but to calculate the length of a list, do you keep the state or how do you do it?
05:52:11 <mm_freak_> dafis: you count as usual
05:53:42 <mm_freak_> once you iterated the list you can check the LSB and the other bits stay unevaluated
05:54:03 <mm_freak_> that reduces the cost to constant bit flipping
05:54:11 <dafis> mm_freak_:  yeah, "once you iterated the list"
05:54:38 <mm_freak_> dafis: you can't tell anything about the length of the list without completely evaluating it
05:54:46 <mm_freak_> peano numbers don't help here
05:54:48 <dafis> mm_freak_:  what does that type give for length (undefined:undefined)?
05:55:15 <mm_freak_> ok, good point
05:55:16 <augustss> mm_freak_: what do you mean you can't tell anything about the length?
05:55:20 <dafis> mm_freak_:  with lazy Peano numbers, I can say length xs > 3 as soon as I encounter the fourth element
05:55:35 <augustss> mm_freak_: you can know the length>2 by evaluating 3 cons cells
05:56:38 <mm_freak_> yeah, i get your point, although i think you can do the same with LazyNum, as long as you ask for powers of 2
05:57:29 <augustss> What's LazyNum?
05:57:43 <dafis> isomorphic to [BVool]
05:57:47 <dafis> isomorphic to [Bool]
05:57:55 <dafis> fat-fingers grr
05:58:02 <augustss> representing numbers in binary?
05:58:06 <dafis> yep
05:59:01 <augustss> possibly you could get by with that representation, yeah
05:59:32 <dafis> I think for arithmetic, it's better than Peanos
05:59:52 <dafis> it's worse in other respects
06:00:56 <augustss> oh, for arithmetic it's much better
06:01:20 <augustss> if you can get the same kind if laziness, i don't know
06:05:19 <mm_freak_> not the same, but you can get a fair amount of laziness
06:06:21 <mm_freak_> for example, i'm sure you can't ask, whether a list has length 6, if the sixth cons tail is undefined
06:07:06 <dafis> mm_freak_:  you can ask, but you'll get _|_
06:10:43 <EdH> Hi all :)
06:10:53 <dafis> Hi
06:12:19 * hackagebot SVG2Q 0.3 - Code generation tool for Quartz code from a SVG.  http://hackage.haskell.org/package/SVG2Q-0.3 (JanGreve)
06:12:32 <EdH> I have a question - I'm trying to get a program to output a string to the terminal representing its current state at a point in my code - however, the method returns a value of a different type. How do I go about printing and returning values in the same method?
06:13:10 <quuuux> EdH: What's the return type you want?
06:13:17 <sipa> EdH: you mean want to look at Debug.Trace
06:13:17 <EdH> [Int]
06:13:21 <sipa> *may
06:13:28 <sipa> it's tricky though
06:13:38 <quuuux> EdH: No can do. You need to return IO [Int] if you want that behaviour
06:13:51 <EdH> it's returning [Int] already, I'm trying to get it to print out the list before returning it
06:13:53 <EdH> oh okay
06:14:04 <sipa> EdH: you can do that, but it's not very clean
06:14:09 <quuuux> EdH: if it's only debugging, use Debug.Trace
06:14:14 <dafis> very unclean
06:14:40 <quuuux> EdH: if it's integral to the code, then you'll need to move it inside the IO monad
06:14:42 <Botje> EdH: Debug.Trace is the way to go, yes
06:20:07 <EdH> I'm building a sudoku solver as part of my uni course. I'm using methods returning Bool and [Int] (representing the grid) to find all the available values for a cell, set the cell if there's only one available value, or guess from the list if not. Thing is, I need to also be able to see the actual grid at the end of it. I'll pop the code on hpaste if anyone wants to facepalm :P
06:20:14 <hape01> hi, can I do something like   x <- [1,2,3]   on ghci console? currently I am getting errors like "couldnt match expected type [t] against inferred type IO t
06:20:38 <Botje> hape01: GHCi uses the IO monad
06:20:58 <hape01> Botje, yes that means everything is an action?
06:21:01 <Botje> yes
06:21:10 <hape01> but plain "1" is not an action
06:21:19 <Botje> no, it's pure code
06:21:22 <hape01> ah
06:21:38 <Botje> maybe that's a bit backwards.
06:21:45 <quuuux> hape01: you can do `let x = [1, 2, 3]' if you're just trying to define a variable
06:21:45 <Botje> GHCi will execute any pure code you fling at it
06:21:53 <Botje> and additionally execute IO actions 
06:21:56 <hape01>  Botah
06:22:01 <hape01> yes
06:22:02 <lyndon_> How do I get the commandline quickcheck binary?
06:22:11 <Botje> EdH: you could just return a string
06:22:24 <quuuux> hape01: if you really are trying to use other monads than IO at the GHCi prompt, then listen to Botje :)
06:22:42 <EdH> would I be able to return that alongside whatever else I need to return as well though?
06:22:50 <Botje> EdH: if you return a tuple.
06:22:59 <EdH> oh, true
06:23:05 <Botje> EdH: or you could be crafty and return Maybe [Int]
06:23:11 <Botje> where Nothing is your False case now
06:23:24 <Botje> and Just [Int] is a success annotated with your board
06:23:35 <EdH> I'll come right out and say I have absolutely no idea what that means
06:23:38 <EdH> research time!
06:23:54 <Botje> :info Maybe
06:24:17 <quuuux> @hackage safe
06:24:17 <lambdabot> http://hackage.haskell.org/package/safe
06:24:46 <hape01> main = do; x <- [1,2,3]; return ()    what is wrong with that?
06:24:55 <hape01> main::IO ()
06:25:25 <sipa> hape01: [1,2,3] is not an IO action
06:25:31 <quuuux> hape01: do you understand how do-notation desugars? That translates to main = [1, 2, 3] >>= \ x -> return ()
06:25:55 <hape01> i am learning and it is difficult but I try to understand
06:25:57 <quuuux> :t (>>=)
06:25:58 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
06:27:00 <quuuux> okay, what that means is that you're passing `[Integer]' (a list of integers) on the left-hand-side of >>=. That means that, in the type signature there, `m' is the list monad, not IO
06:27:24 <quuuux> but main's type signature demands that m is the IO monad, hence the problem
06:27:48 <hape01> quuuux: thanks for explaining
06:29:34 <quuuux> @botsnack
06:29:34 <lambdabot> :)
06:34:13 <quuuux> @pl \ (xs, y) -> zip xs $ repeat y
06:34:14 <lambdabot> uncurry ((. repeat) . zip)
06:35:19 <augustss> @quote
06:35:19 <lambdabot> ihope says: Oops, I forgot that Djinn doesn't do GADT's.
06:39:53 <augustss> @quote
06:39:53 <lambdabot> wilx says: I mean, besides the murders, it all looks so nice.
06:41:58 <hape01> quuuux: hours later now I think to unterstand.    <-   is to link the result of an IO action  to a variable   in an do-block
06:42:44 <augustss> hape01: Kind of, the rhs of <- has to have the same monadic type as the whole do expression
06:42:55 <quuuux> hape01: sort of. If you're in the IO monad, that's precisely it. <- can -also- work in any monad, and there's such a thing as a list monad
06:43:02 <hape01> :-)
06:43:37 <hape01> augustss, quuuux: in which context I could do  an   x<-[1,2,3]     ?
06:43:53 <quuuux> hape01: when you're in the list monad. Example:
06:44:04 <augustss> > do x<[1,2,3]; y <- [3,4]; return (x*y)
06:44:05 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
06:44:05 <lambdabot>         against inferred ...
06:44:06 <mm_freak_> > do x <- [1,2,3]; y <- [4,5,6]; return (x+y)
06:44:07 <lambdabot>   [5,6,7,6,7,8,7,8,9]
06:44:16 <hape01> perfect :-) i am happy now
06:44:18 <quuuux> see? I ask for examples and two arrive
06:44:33 <mm_freak_> lol
06:44:36 <quuuux> #haskell is an interpreter for englis
06:44:38 <quuuux> er, english
06:44:41 <augustss> Except one had a typo
06:44:50 <quuuux> slightly buggy interpreter
06:45:06 <hape01> yes
06:45:16 <sipa> a bit non-deterministic
06:45:24 <mm_freak_> no, the interpreter works perfectly
06:45:36 <mm_freak_> it's just that the response was buggy
06:45:39 <augustss> Any flaws is to make sure you pay attention
06:49:12 <quuuux> does anyone know if a no-op like `readTVar tv >>= writeTVar tv' will make threads waiting for tv to be touched wake up?
06:50:18 <augustss> quuuux: probably
06:51:08 <quicksilver> I'm fairly sure it will.
06:51:17 <quicksilver> but why would you want that to happen?
06:51:23 <quicksilver> if they retried before, they will again ;)
06:52:03 <quuuux> quicksilver: tv :: TVar [TVar a]
06:52:28 <quuuux> quicksilver: oh, wait. Yeah, you're right
06:53:46 <Rotaerk> how easy is debugging haskell code?  I've found that debugging F# code isn't particularly convenient.  if you have a function defined as a long chain of compositions, and it's not working correctly, I have to modify the function such that it's no longer composition, and let-bind the intermediate values just to inspect them
06:58:37 <quicksilver> Rotaerk: if I have a long chain of functions which isn't working correctly, I try it in ghci it example input data
06:58:50 <quicksilver> and run the functions in the chain in whatever permutations I want
06:59:04 <fryguybob> @tell edwardk Yices Painless version: http://hpaste.org/paste/43351/the_dutch_drinking_problem__y#p43377
06:59:04 <lambdabot> Consider it noted.
06:59:21 <quuuux> Rotaerk: GHCi has a pretty good step-through debugger, too
07:00:02 <Rotaerk> hmm cool
07:00:30 <quuuux> Rotaerk: there are also hacks like Debug.Trace for stuffing the moral equivalent of print statements in
07:00:45 <Rotaerk> ah
07:06:03 <parcs> during the linking phase of an application that imports direct-sqlite, i get this error: Server.hs: /home/patrick/.cabal/lib/direct-sqlite-1.0/ghc-6.12.3/HSdirect-sqlite-1.0.o: unknown symbol `sqlite3_column_blob'
07:06:17 <parcs> does anyone know what's up with that?
07:14:58 <quuuux> Text.Regex errors must be among the least penetrable I've ever seen :/
07:21:25 <int-e> parcs: a missing  extra-libraries: sqlite3  in the direct-sqlite would be my guess. (you can work around that by providing an option  -optl-lsqlite2  when linking.)
07:39:36 * edwardk waves hello.
07:39:36 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
07:40:28 <edwardk> @tell fryguybob great!
07:40:28 <lambdabot> Consider it noted.
07:40:38 <fryguybob> :D
07:40:38 <lambdabot> fryguybob: You have 1 new message. '/msg lambdabot @messages' to read it.
07:41:00 <aristid> yet another advantage of haskell compared to many other languages: much less fear of making sophisticated data structures (like trees)
07:41:20 <edwardk> hrmm. none of my comonad transformers actually require the extract of the comonad, they all happen to be Extend transformers, but there are monad transformers that are not bind transformers (mostly due to the existence of crappy semantics for monad plus)
07:42:29 <edwardk> debating about removing my ComonadTrans class and just using the ExtendTrans class until I can find an actual _comonad_ transformer
07:42:33 <aristid> it seems like many C programmers avoid data structures other than (1) fixed-size arrays, (2) linked lists :D
07:43:11 <edwardk> aristid: there is a certain form of abstraction blindness caused by staring at the metal that closely
07:43:12 <jmcarthur> aristid: and aside from kernel programmers i haven't seen many use linked lists, either
07:43:32 <aristid> jmcarthur: my colleagues are embedded C guys
07:43:42 <jmcarthur> ah, i guess that would do it
07:43:43 <aristid> so kernel programmers is quite accurate
07:44:00 <edwardk> jmcarthur: that i'll rather disagree with, most c programs i've seen over the years have had some form of linked list in them except when they are working in embedded systems
07:44:20 <aristid> edwardk: haha, you're saying the opposite :D
07:44:41 * hackagebot Tablify 0.8.1 - Tool to render CSV into tables of various formats  http://hackage.haskell.org/package/Tablify-0.8.1 (DanielLyons)
07:44:56 <edwardk> aristid: nah, i'm agreeing that linked lists are within their grasp  ;)
07:45:27 <aristid> edwardk: your point about abstraction blindness is probably true, but i think it's also the case that getting trees right in C is hard, because there are so many subtle ways to get your pointer stuff wrong
07:45:38 <edwardk> yeah
07:45:38 <Palmik_> Hi guys, I have this kind of data type, it represents expression of some language http://codepad.org/3efkD5d8 now, FunctionCall should also be an expression, but I'm struggling to find a way to store a function declarations (essentialy an Expr where you can substitute some Number leaf nodes)... any ideas?
07:48:41 <Botje> Palmik_: you should take care to substitute your operators from your data
07:48:45 <Botje> uh
07:48:47 <Botje> *separate
07:49:57 <Botje> data Val = Num Int | Function String [String] Expr
07:50:39 <Maxdamantus> Is a function declaration an expression?
07:50:45 <Palmik_> Botje, hmm... but (a + b) where a and b are expressions should also be an expression... or perhaps I misunderstood you
07:50:46 <Palmik_> Maxdamantus, no
07:50:50 <Palmik_> but function call is
07:51:05 <Botje> Palmik_: how is that incompatible with what i said?
07:51:28 <edwardk> hrmm, i think what i've figured ut is that while bind transformer implies monad transformer, comonad transformer implies extend transformer
07:51:38 <Maxdamantus> Oh, there's a FunctionCall already there.
07:51:53 <edwardk> so there should be extend transformers that are not comonad transformers. if i had to guess something like Maybe (w a)
07:52:29 <Palmik_> Maxdamantus, yeah, it is (just for ilustration), but I'm not sure how to store the function declarations in some sort of State :)
07:52:56 <Maxdamantus> Palmik_: declarations? definitions?
07:52:58 <Palmik_> Botje, the I do not get what you mean by "separate your operators from your data" What data?
07:53:04 <Palmik_> Maxdamantus, definitions, sorry
07:53:17 <Botje> Palmik_: you will have a function eval :: Expr -> Val, right?
07:53:36 <Botje> because Expr -> Expr is a bit weird
07:54:10 <Maxdamantus> It would appear to depend greatly on the language.
07:54:32 <Maxdamantus> Do functions have parameters?
07:55:09 <Palmik_> This is how I imagined it http://codepad.org/7f6dX9Gq
07:56:04 <Maxdamantus> Can functions exist within functions?
07:56:19 <Botje> Palmik_: why not add a Variable to your Expr?
07:56:45 <Botje> then you can put the body of your function in an Expr
07:56:50 <Palmik_> Maxdamantus, yes they have... the callFunction would then substitute the parameters from function with the expressions from the given list and transform it into Expr
07:57:26 <Palmik_> you should be able to call functio a from function b and also be able to do recursive calls
07:58:11 <Maxdamantus> Palmik_: so store a function as a list of parameter names or something, and an Expr, and add some `Variable String` constructor.
07:58:41 <Maxdamantus> Assuming parameters are like bound variables.
08:04:24 <Palmik_> "Adding" (not directly because Parameter itself is not an expression) Parameter String constructor to Expr would make it quite easy... now that I think of it, it's probably what Botje suggested
08:04:46 * hackagebot roman-numerals 0.5.0 - Parsing and pretty printing of Roman numerals  http://hackage.haskell.org/package/roman-numerals-0.5.0 (RoelVanDijk)
08:04:46 <Botje> Palmik_: doesn't have to be in Expr.
08:05:07 <Botje> Palmik_: it can stay in a separate datatype, as long as your eval has access to your dictionary of functions
08:08:13 <Maxdamantus> Palmik_: that just sounds like it'll complicate things.
08:08:26 <Maxdamantus> Palmik_: are you trying to model something similar to lambda calculus?
08:08:37 <Palmik_> Botje, but say you have the "Function String [String] Expr" constructor and Parameter is not part of Expr, where is the function's definition stored then?
08:08:54 <sipa> :t fmap
08:08:56 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:08:59 <sipa> :t mapM
08:09:01 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
08:09:35 <Botje> oh, I thought you meant to use Parameter as a function definition
08:09:37 <Botje> carry on :)
08:10:11 <Palmik_> Maxdamantus, probably yes, in simplified manner I guess :)
08:10:39 <Maxdamantus> It seems complicated making function definitions and having them string-indexed.
08:11:53 <Palmik_> what would you use as an identifier then?
08:11:54 <ClaudiusMaximus> in my gui i need a text entry field to enter values like "(S 1 (1 % 2) (S 2 (2 % 3) (P 5)))", which in the paper i'm referencing are typeset similar to LaTeX-y "1_{1/2} -> 2_{2/3} -> 5" : neither format is particularly friendly to input, any suggestions for a simpler syntax?
08:12:12 <Maxdamantus> The identifier would just be a variable name.
08:12:33 <Maxdamantus> and the function in a function call would be a value (represented by an Expr)
08:13:24 <Botje> ClaudiusMaximus: 1 (1 % 2) -> S (2 % 3) -> 5 seems somewhat palatable
08:13:40 <Maxdamantus> Function [String] Expr
08:13:59 <Maxdamantus> Hmm.. /me thinks.
08:15:08 <Maxdamantus> Should work, afaict
08:15:42 <EdH> Okay, the sudoku solver is all built and works fine for any sized input. Thanks so much for all your help :)
08:15:42 <Palmik_> how would the Expr look like then? How would you know, what to substitute?
08:16:01 <Maxdamantus> Palmik_: because you've got the parameter list there.
08:16:29 <ClaudiusMaximus> Botje: hm.  maybe i should also mention that i'd like to be able to omit the fraction and have it default to 1/2, or omit the natural and have it default to the denominator of the previous fraction multiplied by the previous natural...
08:16:58 <ClaudiusMaximus> > read "1%0" :: Rational
08:16:58 <Palmik_> Maxdamantus, so the [String] would countain the identifiers of the parameters?
08:16:59 <lambdabot>   *Exception: Ratio.%: zero denominator
08:17:40 <ClaudiusMaximus> ...that's a current cause of explosions in my code without a proper validating parser :'(
08:17:41 <Maxdamantus> Palmik_: the substitution will traverse the expression tree, substitutions for operators/etc are simple, but for function expressions, you'll make sure to shadow the substituted's parameters.
08:17:47 <Palmik_> Maxdamantus, but then you would still need something like Parameter String in Expr to mark where the parameter is
08:18:22 <Palmik_> *where it is in the function body
08:18:34 <Maxdamantus> Palmik_: why not Variable String?
08:19:03 <Maxdamantus> Application will substitute variables with another expression.
08:20:34 <Palmik_> Sounds nice, but the what is the Variable (or whatever you want to call it) arises in non FunctionCall tree?
08:20:43 <Palmik_> *what if the
08:21:23 <Botje> then you throw an error
08:21:43 <Maxdamantus> Yes, or you'll eventually potentially end up with an invalid substition.
08:21:47 <Palmik_> also a solution :)
08:21:48 <Maxdamantus> Which would be the programmer's fault.
08:22:04 <Maxdamantus> Error checking probably wouldn't be difficult.
08:22:17 <Palmik_> yeah, it should be fine :)
08:22:21 <Palmik_> ok, thanks a lot guys for this brainstorm :)
08:22:30 <Maxdamantus> (otherwise you might end up with some Variable at the end and you'll know the code was bad)
08:24:00 <ClaudiusMaximus> Botje: so perhaps,   1 (1/2) -> 2 (2/3) -> 5  or  1 -> 2 (2/3) -> 5  or  1 (1/2) -> (2/3) -> 5  or even 1 -> (2/3) -> 5  could all be allowed and refer to the same value...  might get confusing?
08:24:26 <Botje>  i don't know
08:24:28 <Botje> how smart are your users :)
08:24:53 <edwardk> botje: infinitely. i don't have any ;)
08:25:10 <ClaudiusMaximus> well, there's me, and there's hm, dunno... last time someone tried to install it they filled their multi-GB gentoo /var compiling ghc or something...
08:25:24 <Botje> edwardk: so all your applications are empty frames with 'imagine the application doing its thing here' on it?
08:25:39 <edwardk> nah, lots of code, not many users ;)
08:25:51 <ClaudiusMaximus> i use some of it!
08:26:05 <edwardk> crap. you just collapsed the intelligence wave function!
08:26:17 <ClaudiusMaximus> oops
08:27:22 <Twey> Hahaha
08:30:20 <burp> pah, wavefunctions don't collapse
08:30:38 <edwardk> fair enough, you just happen to become part of them
08:41:49 <Henno> Bit new to haskell, anyone know how to check whether an element in a list is stored in another? for example checking to see if the ints [1..n] are all in another list
08:42:20 <quicksilver> :t all
08:42:21 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
08:42:42 <quicksilver> > all (`elem` [5,4,3,2,1]) [1..3]
08:42:44 <lambdabot>   True
08:43:51 <Henno> thanks
08:44:29 <Philonous> How do I find the alignment constraint of a C datatype when writing a Storable instance for it?
08:45:04 <aristid> > null ([1 .. 3] \\ [5,4,3,2,1])
08:45:05 <lambdabot>   True
08:45:33 <quicksilver> aristid: is that asymptotically better?
08:45:40 <aristid> quicksilver: not sure.
08:45:52 <aristid> it's just a variant that came to mind
08:46:03 <quicksilver> @src (\\)
08:46:03 <lambdabot> (\\) = foldl (flip delete)
08:46:11 <quicksilver> probably not
08:46:13 <quuuux> I don't think (\\) can do any better than O(n^2), so no
08:46:18 <quicksilver> looks O(mn) as well
08:46:38 <ClaudiusMaximus> > null (cycle [1..3] \\ [5,4,3,2,1]) -- gives different results for duplicates, too 
08:46:39 <quuuux> Data.Set is the way to go if asymptotics matter, I guess
08:46:40 <lambdabot>   False
08:46:49 <aristid> :t intersectBy (/=)
08:46:50 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
08:47:05 <aristid> > intersectBy (/=) [1 .. 3] [5,4,3,2,1]
08:47:06 <lambdabot>   [1,2,3]
08:47:11 <quicksilver> mine is slightly faster if all the elements (of 1..n) occur close to the head of the (presumably longer) first list.
08:47:12 <j-invariant> If pi is the RATIO of a circle's circumference to its diameter, why is pi irrational?
08:47:18 <aristid> > intersectBy (==) [1 .. 3] [5,4,3,2,1]
08:47:19 <lambdabot>   [1,2,3]
08:47:21 <aristid> lol.
08:47:45 <quicksilver> aristid: therefore (==) = (/=) ?
08:47:49 <aristid> j-invariant: because it's not a ratio of integers.
08:47:51 <aristid> quicksilver: qed
08:48:15 <aristid> quicksilver: next step: deriving 1 = 3 and life = death
08:49:28 <quuuux> aristid: to prove life = death, it's sufficient to prove that black = white and then try to use a zebra crossing
08:49:50 <aristid> quuuux: the famous zebra proof technique.
08:55:47 <Maxdamantus> *Main> eval (BinOp Apply (Function "n" (BinOp Multiply (Variable "n") (Variable "n"))) (Number 4)) = 16.0
08:56:16 <Maxdamantus> Mmm .. extremely simple.
08:56:17 <aristid> Maxdamantus: why BinOp Apply and not just Apply?
08:57:20 <Maxdamantus> aristid: because application is a binary operation.
08:57:34 <Maxdamantus> aristid: otherwise the sub function would be more complicated.
08:57:56 <Maxdamantus> sub p r o@(Variable n) = if n == p then r else o; sub p r (BinOp o le re) = BinOp o (sub p r le) (sub p r re); sub p r o@(Function n e) = if n == p then o else Function n (sub p r e); sub _ _ o = o
08:58:29 <aristid> Maxdamantus: ah, i see.
08:58:48 <aristid> Maxdamantus: it allows you to exploit its structure in sub.
08:58:53 <Maxdamantus> Yep.
09:00:19 <Maxdamantus> http://codepad.org/ZpnFbp9J
09:10:04 * hackagebot wai 0.3.1 - Web Application Interface.  http://hackage.haskell.org/package/wai-0.3.1 (MichaelSnoyman)
09:11:04 * hackagebot wai-app-static 0.0.0 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-0.0.0 (MichaelSnoyman)
09:12:06 * hackagebot warp 0.3.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-0.3.1 (MichaelSnoyman)
09:12:08 * hackagebot warp-static 0.0.0 - Static file server based on Warp and wai-app-static  http://hackage.haskell.org/package/warp-static-0.0.0 (MichaelSnoyman)
09:14:53 <j-invariant> Maxdamantus: your language is weird
09:15:27 <j-invariant> eval (Function "x" (Variable "x")) is a double
09:15:56 <aristid> j-invariant: it errors out
09:16:17 <j-invariant> and you can't apply functions to functions
09:17:43 <aristid> Maxdamantus: you should adapt your language to be based on point-free combinators
09:17:43 <j-invariant> oh you cant
09:17:46 <j-invariant> can*
09:17:56 <aristid> Maxdamantus: String variables are uncool
09:24:05 <copumpkin> preflex: seen yav
09:24:05 <preflex>  yav was last seen on #ghc 58 days, 20 hours, 4 minutes and 28 seconds ago, saying: aha, will do. thanks for your help!
09:26:08 <Cin> preflex: be poppavic
09:26:09 <preflex>  I enjoy a lot of people, nicks and thinks. I've more issues and problems family and home. So, you can miss a person and their i/o and still move along: what was the I/O?
09:26:40 <Cin> Words of wisdom from a zen master.
09:33:46 <gwern> @quote zen
09:33:47 <lambdabot> Wild_Cat says: [on #python] (I mean, if you believe the #haskell denizens, half the financial world uses Haskell)
09:41:16 * hackagebot hlint 1.8.6 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.6 (NeilMitchell)
09:47:15 <Guest20364> as
09:50:23 <byorgey> hi Guest20364 
09:50:41 <Guest20364> sup
09:50:47 <byorgey> Guest20364: trying Haskell?
09:51:09 <Guest20364> yep, never did functional prog
09:52:30 <byorgey> Guest20364: cool, if you have any questions feel free to ask
09:52:34 <spvensko> hi, i'm a self-taught pythoner that has been attempting to learn haskell for its various advantages, i'm currently in the process of designing a program that will involve training and applying the viterbi algorithm to a dataset, is this a suitable application for learning haskell with or am i asking for a world of pain?
09:52:48 <spvensko> also, i'm on chapter 6 of learn you a haskell if that gives any indication of my haskell experience
09:53:23 <j-invariant> no haskell cant do algorithms
09:53:31 <copumpkin> I'd start on something a bit simpler, but it's definitely possible
09:53:43 <copumpkin> @slap j-invariant 
09:53:43 * lambdabot loves j-invariant , so no slapping
09:53:47 <copumpkin> :(
09:54:06 <sproingie> @slap lambdabot
09:54:06 * lambdabot karate-chops lambdabot into two equally sized halves
09:54:20 <sproingie> i told you to not take the axiom of choice
09:54:45 <spvensko> j-invariant, are you being sarcastic?
09:54:54 <j-invariant> no
09:55:20 * hackagebot functor-apply 0.10.0 - Applicative sans pure, Monad sans return, Alternative sans empty  http://hackage.haskell.org/package/functor-apply-0.10.0 (EdwardKmett)
09:55:22 <spvensko> there is already an HMM module but i'd like to try to implement something on my own just for the learning experience
09:55:28 <copumpkin> spvensko: pay no attention to j-invariant 
09:56:16 <sproingie> it might be a bit of a tall order as a first haskell program but if you can break it into manageable chunks you should be fine
09:56:20 * hackagebot comonad-transformers 0.10.0 - Haskell 98 comonad transformers  http://hackage.haskell.org/package/comonad-transformers-0.10.0 (EdwardKmett)
09:56:34 <Guest20364> any good haskell books??
09:56:37 <sproingie> LYAH
09:56:41 <andy_> real world haskell
09:56:45 <byorgey> @where lyah
09:56:45 <lambdabot> http://www.learnyouahaskell.com/
09:56:48 <byorgey> @where rwh
09:56:48 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
09:57:07 <sproingie> i recommend lyah and rwh in that order
09:57:22 * hackagebot adjunctions 0.5.0 - Adjunctions  http://hackage.haskell.org/package/adjunctions-0.5.0 (EdwardKmett)
09:57:37 <fryguybob> byorgey: I'm failing at your puzzle :D, any hints?
09:57:47 <j-invariant> what puzzle?
09:58:09 <byorgey> fryguybob: I don't yet understand it well enough to give hints that don't just give answers away
09:58:19 <byorgey> fryguybob: note also that I don't completely know the answers
09:58:19 <fryguybob> hehe
09:59:02 <byorgey> j-invariant: http://byorgey.wordpress.com/2011/01/26/counting-linear-lambda-terms/
09:59:18 <byorgey> I posted it just before realizing that Planet Haskell is down  =(
10:00:56 <j-invariant> how many ways to prove a statement
10:02:24 <DevHC> oh shit, LYAH images suck
10:02:44 <DevHC> this may be only my opinion, but i think it makes haskell look childish
10:02:56 <j-invariant> DevHC: deal with it
10:03:22 <gwern> DevHC: that's the style of Why_
10:03:23 <conal> DevHC: haskell *is* childish. as in imaginative and delighting in exploration.
10:03:25 <DevHC> i mean cmon, we're einsteins, not some other lame ppl: http://i.imgur.com/pG3q7.jpg
10:03:31 <sproingie> haskell community is also fond of lolcats
10:03:46 <sproingie> i r serious cat this r serious language
10:03:50 <DevHC> what do lolcats have to do with baby images?
10:04:02 <sproingie> here's your money back
10:04:06 <j-invariant> "we're einsteins" hahaha
10:04:11 <j-invariant> yea me too LOL
10:04:25 <DevHC> sup, einstein
10:05:04 <byorgey> conal: hear hear!
10:05:06 <DevHC> http://s3.amazonaws.com/files.posterous.com/bt1/RpN489KBGPGWsHE33nBPIRymqIDdQ32EPDch6GtVRRd1GvGku4lY1O6covsF/1gF1j.jpg.scaled.1000.jpg?AWSAccessKeyId=1C9REJR1EMRZ83Q7QRG2&Expires=1296152498&Signature=6fUFLPJAT11DR2mxnA7i2gI8Fqo%3D
10:05:13 <DevHC> ^fact? :P
10:05:19 <conal> byorgey: :)
10:05:29 <j-invariant> You are using a silly image to complain about the silly images?
10:05:37 <j-invariant> nice try GOdel
10:06:05 <aristid> Gödel <- umlauts are awesome
10:06:17 <DevHC> that's not silly, that's epic
10:06:37 <gwern> hm, why do we see Lisp fans as Charles Darwin?
10:06:37 <DevHC> and at LYAH the images r also not silly, but rather lame
10:06:49 <gwern> one man's lame is another man's silly
10:06:57 <j-invariant> gwern: that's not charles darwin that's Mr Old
10:07:01 <conal> is another man's picasso
10:07:01 <gwern> who?
10:07:07 <j-invariant> Some old guy
10:07:09 <DevHC> lisp was the first "beautiful" language?
10:07:18 <gwern> j-invariant: he looks like Charles Darwin to me
10:07:22 <quuuux> no, that was Plankalkuul
10:07:30 <quuuux> nothing since has come close to its beauty
10:07:38 <j-invariant> gwern: in this context its just an old gu;y
10:07:45 * sipa prefers Whitespace
10:07:45 <gwern> hm.
10:07:54 <sproingie> i think it's supposed to be "respected elder guy"
10:08:27 <conal> DevHC: could be. algol was pretty sweet also.
10:08:38 <j-invariant> didnt lisp come before algol
10:08:57 <conal> j-invariant: probably. both late 50s iirc
10:08:59 <j-invariant> no lisp caem first
10:09:01 <aristid> quuuux: Plankalkül?
10:09:15 <quuuux> aristid: yeah, that!
10:09:26 <aristid> quuuux: it contains an umlaut, so it must be good!
10:09:40 <sproingie> P1 max3 (V0[:8.0],V1[:8.0],V2[:8.0]) => R0[:8.0]
10:09:43 <sproingie> so pretty
10:10:04 <quuuux> Haskell would have so many more users if we renamed it Häskëll
10:10:19 <sproingie> Hasküll
10:10:35 <Cin> The Ruby as seen by C fans is the one that made me laugh.
10:10:54 <inetic> hi, I've created a wrapper monad over the Data.Binary.Put, now I'm trying to write some large data with it but it hogs all my memory and the program crashes, now I have no clue why, I can see using ghc's memory profiler which functions takes all the mem, but I don't know why. what would you recommend I should try? Im stuck
10:11:02 <aristid> quuuux: cerainly.
10:11:05 <Cin> @quote ruby
10:11:05 <lambdabot> ddarius says: Someone made a completely non-idiomatic library/redefinings to make the code look more like ruby because, I'm assuming, they suffer from brain damage.
10:11:08 <aristid> *certainly
10:12:12 <DevHC> ok so does anyone know how to interpret these images in detail?
10:12:39 <DevHC> like what does that fat fancy guy mean?
10:13:32 <c_wraith> DevHC: it means "programming isn't srsbsns, lighten up, enjoy yourself."
10:13:55 <Cin> Gotta give it credit for including Office Space.
10:14:26 <Cin> Yyyeeah. I'm gonna have to ask you to... go ahead and code in Java, on Saturday.
10:15:27 <mm_freak_> inetic: what kind of monad?
10:15:47 <DevHC> ok what's up with the d00d holding a banana or something?
10:16:17 <DevHC> and wtf is up with that rat/lolcat/hamster/<insert_animal_here>?
10:16:22 <quuuux> DevHC: the man is a monad, the banana is the value contained within
10:16:27 <sproingie> lighten up frances
10:16:55 <DevHC> r u trolling me?
10:16:58 <sproingie> i thought bananas were folds
10:17:03 <ekidd> Good afternoon! What happened to code.haskell.org?
10:17:10 <j-invariant> byorgey: geez I can't think of any type with 3 linear inhabitants
10:17:17 <Cin> Inexplicably down. Again.
10:17:29 <sproingie> or are they maps?
10:17:45 <aristid> j-invariant: use your imagination!
10:18:11 <c_wraith> sproingie: bananas are catamorphisms.  which on lists, are folds
10:18:33 <quuuux> we should produce a category-theoretic interpretation of BONUS's pictures
10:18:47 <j-invariant> I don't have a good one aristid 
10:18:54 <j-invariant> I could find n!
10:18:57 <j-invariant> but 3 is not n!
10:19:10 <aristid> j-invariant: but 3 is n! + 1
10:19:12 <j-invariant> prime numbers are difficult
10:19:23 <j-invariant> aristid: iirc there's no way to just add one
10:19:26 <c_wraith> actually, I guess a catamorphism is specifically foldr, on a list?  Is that true, or am I imagining constraints that don't exist?
10:19:30 <j-invariant> well, maybe there is I will try and find it
10:19:58 <edwardk> c_wraith: and folds are comonads!
10:20:04 <ekidd> I'm trying to build Darcs, but can't find a working repository.
10:20:22 <aristid> edwardk: what? :)
10:20:33 <c_wraith> ekidd: that server is down, unfortunately.  Probably will be a couple more days
10:20:43 <edwardk> aristid: comonad.com/haskell/Origami.hs
10:20:55 <inetic> mm_freak_, it's kind of a StateT transformer, it goes something like this: data WriterM a = WriterM { write :: Integer -> (a, P.Put, Integer, Integer) }, it threads current offset and knows how many bytes it writes
10:20:59 <c_wraith> ekidd: You could get the latest hackage version, though
10:21:04 <c_wraith> @hackage darcs
10:21:04 <lambdabot> http://hackage.haskell.org/package/darcs
10:21:13 <ekidd> c_wraith: Is that newer than 0.9.1?
10:21:26 <jmcarthur> .join #ghc
10:21:29 <jmcarthur> oops
10:21:33 <c_wraith> the current darcs version is 2.5
10:21:45 <c_wraith> err, the current darcs version on hackage is 2.5
10:22:01 <mm_freak_> inetic: i thought Put is a monad
10:22:44 <ekidd> c_wraith: Oh, sorry, I'm looking for xmonad, which is hosted on code.haskell.org.
10:23:02 <ekidd> Not Darcs. I'm not community clearly today.
10:23:05 <c_wraith> ekidd: ah, that version number makes more sense.  yes, code.haskell.org is down
10:23:30 <inetic> mm_freak_, Im just a beginner in haskell, but I think PutM is a monad and Put = PutM (), (it always ignores the thingy)
10:23:33 <c_wraith> ekidd: http://hackage.haskell.org/package/xmonad 0.9.2
10:23:39 <aristid> edwardk: Moore looks a bit like a stream :)
10:24:01 <edwardk> aristid: exactly =)
10:24:29 <ekidd> c_wraith: Ah, many thanks! Now let's see if I can get xmonad to stop crashing apps on my second monitor. :-)
10:24:51 <mm_freak_> inetic: i see…  i have no experience with 'binary', but your problem might be related to your own monad
10:24:52 <c_wraith> ekidd: there's also an #xmonad channel for issues specifically with it
10:25:33 <ekidd> Yeah, but's it's dead right now, and I figured that somebody here would know about code.haskell.org. Many thanks!
10:27:08 <c_wraith> yeah, code.haskell.org is probably going to be down a couple more days.  It's being transferred to new hardware.
10:28:46 <j-invariant> can haskell do actors?
10:29:58 <earthy> yes
10:30:15 <earthy> don't know if there's a lib though
10:30:49 <inetic> mm_freak_, I have no doubt about it :-), may I ask you if you would have a quick look at the implementation of the monad? maybe there is something obvious that I'm missing
10:31:42 <edwardk> j-invariant: yes
10:31:53 <mm_freak_> inetic: right now i'm a little bit busy, but just hpaste the code…  usually someone will look at it =)
10:32:00 <edwardk> j-invariant: there is CHP, and I have a library that offers them kind of by accident
10:32:22 <ekidd> Ah, xmonad 0.9.2 is still badly broken on my system.
10:32:27 <ekidd> That's too bad.
10:32:33 <inetic> mm_freak_, no problem, thanks
10:45:27 <inetic> any good soul would please have a look:  http://hpaste.org/43380/wrapper_around_the_databinary  :-)
10:52:54 <roconnor> edwardk: Is the pointwise sum of two comonads a comonad?
10:54:34 <freiksenet> is there a rcurry command in haskell? I know I can flip and curry, but is there a rcurry that doesn't flip?
10:54:51 <edwardk> roconnor: yes
10:55:02 <edwardk> roconnor: monads always have products, comonads always have coproducts
10:55:25 <edwardk> and ideal monads have coproducts, coideal comonads have products
10:55:43 <edwardk> but the latter constructions are ugly
10:55:48 <roconnor> edwardk: have you ever considered a "fixed point" of comonad transfromers?
10:56:07 <edwardk> roconnor: yeah, you can play with moore machines that way iirc
10:56:22 <roconnor> My cartesian store comonad is the solution to CartesianStore = StoreT CartesianStore + Identity
10:56:44 <edwardk> that looks right to me
10:57:01 <roconnor> this game can be done with any comonad transformer
10:57:19 <edwardk> its a comonad made out of the higher kinded free monad
10:57:29 * roconnor mind boggles
10:58:40 <edwardk> i have a transformer that yields Either (f a) a — MaybeApply in Data.Functor.Apply which is a Comonad for f a Comonad, but i haven't packaged the rest of the higher kinded scary stuff
10:59:28 <edwardk> there shoud be a similar monad transformer fixed point for m a = (a, t m a)
10:59:35 <roconnor> yes
10:59:47 <roconnor> my CartesianStore is an applicative functor
10:59:50 <edwardk> which is based on the higher kinded cofree comonad
11:00:01 <roconnor> I'm now trying to figure out if this holds for any comonad transformer
11:00:23 <edwardk> fair nuff
11:00:31 <edwardk> it should
11:00:37 <roconnor> actually is it a monad?
11:00:55 <edwardk> the fixed point one?
11:00:58 <roconnor> ya
11:01:02 <roconnor> the cartesian store
11:01:15 <edwardk> that one i don't know, you'd need to check the consistency
11:01:36 <edwardk> it seems plausible
11:01:57 <roconnor> an  member of the cartesian store is an element of StoreT^n Identity for some n
11:02:17 <edwardk> *nods*
11:02:25 <edwardk> or its an exotic term
11:02:28 <roconnor> so a cartesianStore of a cartesian store is a element of StoreT^n Identity (StoreT^m Identity) a
11:02:47 <roconnor> it seems you might be able to join them to get Store^(n+m) Identity a
11:03:30 * roconnor didn't bracket that properly
11:03:52 <edwardk> my mental error correcting parser succeeded in correcting it ;)
11:04:32 <roconnor> this probably doesn't work
11:04:38 <ddarius> StoreT^n . StoreT^m is canonically isomorphic to StoreT^(n+m)
11:13:18 <roconnor> f <*> (Left x) = Left (liftTrans (f <*>) x)
11:13:38 <roconnor> f <*> (Right x) = fmap ($x) f
11:14:23 <roconnor> edwardk: do you have liftTrans in some other package?
11:14:37 <pheaver> to use cabal-install with ghc-7.0.1, can i build cabal-install-0.8.* with ghc-7.0.1, or do i need to built it with a previous version of ghc?  i ask because cabal-install-0.8.* required Cabal-1.8.*, which cannot be built on ghc-7.0.1...
11:18:39 <roconnor> liftTrans :: (forall a. w a -> v a) -> StoreT w a -> StoreT v a
11:18:40 <roconnor> liftTrans eta (StoreT v b) = StoreT (eta v) b
11:18:55 <roconnor> Presumably that is correct
11:26:17 <roconnor> oh this doesn't type check
11:26:48 <roconnor> (f<*>) doesn't have type forall a. w a -> v a
11:31:14 <roconnor> edwardk: what, comonad-transformers depends on syb-extra!?
11:31:17 <roconnor> that is so lame
11:32:04 <roconnor> oh syb is part of base
11:32:10 <roconnor> that is so lame
11:32:20 <ddarius> Data Typeable
11:32:39 <roconnor> that doesn't sound portable
11:33:05 <roconnor> comonad-transformers is supposed to be Haskell 98
11:33:26 <roconnor> Data Typeable doesn't sound like Haskell 98
11:34:22 <ddarius> Well Data isn't Haskell 98.  Typeable is.
11:34:36 <burp> any ideas for a one-line word wrapping function, that splits a string after x chars - but doesn't split within words? wordWrap :: String -> [String]
11:34:44 <roconnor> syb-extras depends on Data
11:34:57 <roconnor> edwardk: you've gone too far!
11:35:28 <burp> I can only come up with an ugly manual recursive thing
11:35:29 <Olathe> burp: Split on spaces, join until the line is as long as it can get.
11:35:55 <roconnor> edwardk: version 0.5.0 was nice
11:37:10 <aristid> @src lookup
11:37:11 <lambdabot> lookup _key []          =  Nothing
11:37:11 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
11:37:11 <lambdabot>                         | otherwise = lookup key xys
11:44:52 <j-invariant> Is haskell about creating programs?
11:45:02 <j-invariant> or solvign programming problems?
11:45:21 <roconnor> one implies the other I think
11:45:35 <c_wraith> Some of each.  Haskell was designed to be an effective base for many types of language research, but also to allow for creation of efficient programs.
11:45:56 <ddarius> burp: If you don't care about the whitespace otherwise, you should be able to do it with words and a suitable foldr.
11:46:29 <burp> ah yes, a fold
11:46:48 <ddarius> If you do care about the whitespace you can abuse groupBy
11:47:06 <ddarius> You still have to have a policy about individual words that are greater than the cut-off.
11:50:35 <ddarius> :t groupBy
11:50:36 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
11:51:33 <ddarius> @hoogle equaling
11:51:33 <lambdabot> No results found
11:51:37 <ddarius> @hoogle equals
11:51:37 <lambdabot> Text.PrettyPrint.HughesPJ equals :: Doc
11:51:37 <lambdabot> Language.Haskell.TH.PprLib equals :: Doc
11:51:37 <lambdabot> Language.Haskell.Lexer Equals :: Token
11:52:01 <ddarius> > groupBy ((==) `on` isSpace) "foo   bar re sath"
11:52:02 <lambdabot>   ["foo","   ","bar"," ","re"," ","sath"]
11:53:07 <aristid> @let groupOn = groupBy . on (==)
11:53:08 <lambdabot>  Defined.
11:53:26 <aristid> > groupOn isSpace "foo   bar re sath"
11:53:28 <lambdabot>   ["foo","   ","bar"," ","re"," ","sath"]
11:54:13 <aristid> now let's hope Groupon.com does not sue us for trademark infringement
11:54:19 <roconnor> It it in general possible to write (w a -> v b) -> t w a -> t v b  for comonads w, v and a comonad transformer t?
11:54:24 <roconnor> probably not I'd guess
12:04:35 <burp> @let split' str acc | str == "" = acc | acc == [] = split' rest [word] | otherwise = if (length $ head acc) > 50 then split' rest $ word:acc else split' rest $ (head acc ++ " " ++ word):(tail acc) where word = takeWhile (/= ' ') str; rest = drop 1. dropWhile (/= ' ') $ str
12:04:36 <lambdabot>  Defined.
12:04:45 <burp> > split' "Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet." []
12:04:47 <lambdabot>   ["ipsum dolor sit amet.","clita kasd gubergren, no sea takimata sanctus est...
12:04:47 <burp> full uglyness :D
12:09:32 <burp> but it works with just Prelude :P
12:09:40 <parcs> @hoogle >=>
12:09:41 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
12:14:53 <edwardk> roconnor: was afk
12:14:54 <edwardk> back
12:15:04 <roconnor> How can I stick Haskell code in an ICFP paper with two columns?
12:15:07 <edwardk> the dependency on syb-extras is something i'm debating about. syb is in base
12:15:21 <edwardk> and i like having Data instances.
12:15:23 <roconnor> I can barely fit my code into regular page width
12:15:34 <roconnor> edwardk: it isn't haskell 98
12:15:50 <roconnor> and presumably that implies it isn't portable
12:15:54 <edwardk> yes, but the dependency should be optional based on the presence of extras.
12:15:57 <roconnor> and syb is evil :D
12:15:57 <edwardk> er syb
12:16:00 <mercury^_> roconnor: listings should not be affected by the columns.
12:16:08 <edwardk> i may have screwed that up. i'll go check
12:16:12 <edwardk> but it was guarded by CPP everywhere
12:16:19 <roconnor> oh
12:16:24 <roconnor> I was just browsing the haddock
12:16:35 <roconnor> edwardk: in that case it is less bad
12:16:40 <roconnor> mercury^_: how so?
12:16:55 <edwardk> if impl(ghc) build-depends: syb-extras >= 0.1 && <= 0.3; extensions: DeriveDataTypeable
12:17:03 <mercury^_> roconnor: if necessary put them into a float.
12:17:07 <edwardk> otherwise its guarded by CPP
12:17:17 <roconnor> mercury^_: oh I see
12:17:20 <roconnor> good
12:17:24 <roconnor> right, it is a figure
12:17:28 <roconnor> smart
12:17:32 <edwardk> prelude-extras is required though, which just provides higher kinded Eq, Ord, etc.
12:17:52 <roconnor> edwardk: StoreT seems to be special in that (w a -> v b) can be lifted to (StoreT w a -> StoreT v b)
12:18:00 <edwardk> Eq2 gives you (==##) :: Eq a, Eq b => f a b -> f a b -> f a b — etc
12:18:13 <roconnor> is prelude-extras H98?
12:18:19 <edwardk> yes
12:18:54 <edwardk> it provides Text.Show.Extras Text.Read.Extras and Prelude.Extras, all of those are sound haskell 98. on ghc it provides ghc-style Read extensions though
12:19:14 <roconnor> as long as it is portable, I am happy
12:19:21 <edwardk> *nods*
12:19:33 <edwardk> the new version noted that all comonad transformers are actually 'extend' transformers
12:19:43 <edwardk> which is nice because more things can be extended than are comonads
12:20:03 <roconnor> (w a -> v b) -> StoreT w a -> StoreT v b -- should this function be provided?
12:20:13 <roconnor> what are the laws of extend?
12:20:15 <edwardk> debating
12:20:28 <roconnor> or is that function provided?
12:20:30 <edwardk> extend provides that cokleisli composition is associative
12:20:48 <aristid> edwardk: the extend transformers make comonads from extends?
12:21:12 <edwardk> aristid: technically neither MonadTrans nor ComonadTrans actually tell you that the result is a (co)monad ;)
12:21:14 <edwardk> they can't ;)
12:21:39 <edwardk> class MonadTrans t m a where lift :: Monad m => m a -> t m a — doesn't say the result (t m) is a Monad.
12:21:54 <edwardk> er
12:21:59 <edwardk> class MonadTrans t where
12:22:00 <aristid> edwardk: but for your actual existing transformers, they all create comonads?
12:22:11 <edwardk> aristid: if the argument is a comonad they do
12:22:24 <edwardk> if its just an Extend (like Maybe, or []) they just make an Extend instance
12:22:56 <edwardk> so you can apply comonad transformers to primitive (non-comonadic but extendable) data types
12:23:04 <aristid> edwardk: so they really are comonad transformers in this way
12:23:08 <edwardk> yes
12:23:42 <edwardk> now cohoisting turns out to be more interesting, because you can have things that cohoist into an extend, even though you are cohoisting a comonad, etc. but at this point its just silly
12:24:25 <edwardk> my working example of such is data MaybeT w a = MaybeT { runMaybeT :: Maybe (w a) } — which is clearly not a comonad
12:24:31 <edwardk> er newtype
12:24:45 <aristid> data would work too
12:24:57 <edwardk> sure, but its pointlessly dropping an extra bottom in
12:25:03 <roconnor> edwardk: have you defined this higher-kinded free monad comonad transformer constuction?
12:25:19 <edwardk> roconnor: i was debating about where to put them
12:25:28 <edwardk> Control.Comonad.Trans.Trans.Free? =)
12:26:02 <roconnor> I have no idea
12:26:09 <roconnor> what would you name it?
12:26:41 <roconnor> FreeT?
12:27:30 <edwardk> dangerous because FreeT is the monad transformer in trans terminology
12:27:49 <roconnor> Do you have a name for EitherF f g a = LeftF (f a) | RightF (g a) ?
12:28:04 <edwardk> i was adding Data.Functor.Sum as we speak
12:28:36 <roconnor> edwardk: what names do you use for it and it's constructor?
12:28:47 <roconnor> I might as well use the same names you do in my paper.
12:28:54 <edwardk> newtype Sum f g a = Sum { getSum :: Either (f a) (g a) } — avoids making up more names, and makes it cheaper to unwrap/rewrap and abuse either.
12:29:07 <roconnor> ah 
12:29:13 <edwardk> normally i call it something like :+: but that requires TypeOperators
12:29:36 <roconnor> hmm
12:29:48 <roconnor> It might be worth using :+: in my paper
12:30:19 <roconnor> edwardk: don't you think that use of Sum would be confused with the existing use of Sum?
12:30:22 <roconnor> @hoogle Sum
12:30:22 <lambdabot> Data.Monoid newtype Sum a
12:30:22 <lambdabot> Data.Monoid Sum :: a -> Sum a
12:30:23 <lambdabot> Prelude sum :: Num a => [a] -> a
12:30:26 <edwardk> oh yeah
12:30:27 <edwardk> hrmm
12:30:37 <edwardk> i guess i can just call it Coproduct
12:30:43 <edwardk> to go with Data.Functor.Product
12:30:44 <roconnor> :(
12:31:00 <roconnor> do you think Product is confusing with the existing use of Product?
12:31:04 <roconnor> @hoogle Product
12:31:04 <lambdabot> Data.Monoid newtype Product a
12:31:04 <lambdabot> Data.Monoid Product :: a -> Product a
12:31:04 <lambdabot> Prelude product :: Num a => [a] -> a
12:31:14 <edwardk> fair enough, since Product exists, I'll stick to Sum
12:31:15 <edwardk> =)
12:31:26 <edwardk> i'm not going to try to change transformers in this regard
12:31:27 <roconnor> they are in different modules
12:31:33 <roconnor> so it isn't soo bad
12:31:36 <edwardk> hence why i'm not so worried
12:31:46 <roconnor> transformers already defines product?
12:31:50 <edwardk> plus i depend on Data.Semigroup which provides alternate conflicting definitions of First and Last
12:31:52 <edwardk> yes
12:31:56 <roconnor> :O
12:31:59 <edwardk> that is where the Product type i'm using comes from
12:32:17 <edwardk> and it looks like its picking up the monad instance
12:32:20 <roconnor> strange
12:32:28 <roconnor> there is no monad instance for Product in transformers
12:32:30 <edwardk> i posted about it to libraries@
12:32:34 <edwardk> it's being fixed
12:32:39 <roconnor> oh ok
12:32:50 <roconnor> I'll use Sum then
12:32:52 <edwardk> i actually needed it for my graphs library
12:34:20 <roconnor> edwardk: Product or Sum?
12:34:27 <edwardk> Sum
12:34:31 <roconnor> @hoogle Either
12:34:31 <edwardk> er Product sorry
12:34:31 <lambdabot> module Data.Either
12:34:31 <lambdabot> Prelude data Either a b
12:34:31 <lambdabot> Data.Either data Either a b
12:34:38 <roconnor> @type either
12:34:39 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
12:34:47 <edwardk> i have left :: f a -> Sum f g a
12:34:55 <edwardk> and eitherT :: (f a -> b) -> g a -> b) -> Sum f g a -> b
12:34:58 <Palmik_> Maxdamantus, Botje... now I sat down and laid out the following structure http://codepad.org/IUwouPX6 what do you think? I am still not sure whether I should hardcode the operators, brackets and such (because that way I could easily control the precendeces (the set of operators will be fixed and functions have also fixed precedence))
12:35:48 <edwardk> but i don't like the latter name
12:35:53 <Botje> Palmik_: precedence should be handled by the parser
12:36:25 <Botje> because precedence changes the shape of your ast
12:37:43 <Palmik_> Hmm, I guess you are right, since the Expr data type does not seem to be ambiguious
12:37:47 * roconnor notices the pattern (fmap f (duplicate x)) comes up quite a bit. :D
12:38:38 <edwardk> roconnor: those should probably be extends =)
12:38:48 <roconnor> indeed :D
12:38:53 <burp> I want to generalize my splitting/word wrapping function also to bytestrings, is there a general structure available for it?
12:39:01 <burp> monoid is not enough
12:39:04 <edwardk> roconnor: point me, i'll shoot
12:39:09 <roconnor> duplicate (Sum (Left x)) = Sum (Left (extend (Sum . Left) x))
12:39:22 <roconnor> edwardk: I've noticed it in my code
12:39:26 <burp> something that has head, tail, 
12:39:31 <edwardk> ah
12:39:43 <edwardk> i usually just finish the translation by adding the f into the extend
12:39:48 <burp> a "ListLike"
12:39:57 <edwardk> extend (f . Sum . Left)
12:40:07 <burp> lol, there is ListLike
12:40:07 <roconnor> edwardk: to define extend?
12:40:14 <edwardk> yeah
12:40:21 <edwardk> since i'm already extending/fmapping
12:40:26 <roconnor> ya, I don't feel the need to clutter my paper with that
12:40:30 <edwardk> it provides an opportunity to push for the fusion
12:40:35 <roconnor> but clearly in a real implementation it should
12:42:08 <Dan____> Hi! I came on here earlier seeking help, but what I was asking was quite ambiguous. After some work I've come to a point where I feel I have a question with a definable answer. If someone isn't too busy and could help it'd be much appreciated.
12:42:18 <Palmik_> Botje, and what do you think about replacing "Parameter ..." in Expr with given Exprs? I thought about it and there might be a slight problem in recursive calls or calls of functions withing functions with the same parameter identifier. (if I replace first Parameter everything should be ok, but when I am replacing the second one (if there si such), I might replace Parameters in the Exprs which replaced the first Parameter (if they have the same id, 
12:42:20 <Palmik_> which is bound to happen in recursive calls))
12:43:28 <Botje> Palmik_: it depends on which evaluation strategy you want
12:43:40 <Botje> Dan____: go ahead, there's enough people here :)
12:43:56 <roconnor> do newtypes need to be eta expanded?
12:44:05 <edwardk> nah
12:44:12 <edwardk> we
12:44:13 <edwardk> er
12:44:17 <Botje> Palmik_: if you go for eager evaluation, your function will be called with concrete values, which means you can replace Parameter x with Number (some_number) without any fear
12:44:21 <edwardk> when you make one, yes, but when you use one no
12:44:30 <roconnor> edwardk: how does this sound:
12:44:33 <Dan____> I'm creating a sudoku solver (i looked at online solutions but didn't find them all that useful) and i've found the way to model the blank board... but i need a function to put some numbers in the cells. 
12:44:55 <roconnor> Given a comonad transformer t, we can build a higher-kinded free monad comonad:
12:45:01 <Botje> Dan____: what does your board look like?
12:45:18 <roconnor> newtype FreeComonad t a = Sum Identity (t (FreeComonad t)) a
12:45:43 <roconnor> oh I need some wrappers
12:45:47 <Botje> Palmik_: but if you go for lazy evaluation you will have to do some alpha-renaming, i think
12:45:53 <edwardk> the name is a bit verbose
12:46:12 <edwardk> but i'm not a huge fan of using primitive combinators like Identity for stuff like that
12:46:17 <edwardk> just adds noise
12:46:23 <roconnor> edwardk: what would you do instead?
12:46:29 <edwardk> explicitly define it
12:46:38 <edwardk> eschew obfuscation ;)
12:46:57 <roconnor> edwardk: as written, don't I get a comonad instance for free?
12:47:00 <Dan____> at the moment for simplicity i'm going with a 4x4 grid modelled like so : board :: Int -> [(Int,[Int])] (newline) board x = zip [1..(x*x)] (replicate (x*x) [1..x])
12:47:17 <edwardk> yes, but thats like my category-extras definitions which scared the piss out of folks
12:47:33 <edwardk> i recall someone building a lambdabot plugin ;)
12:47:33 <roconnor> fair
12:47:40 <roconnor> but it will do for my paper
12:47:49 <roconnor> I have an explict definition of CartesianStore
12:47:59 <edwardk> ok
12:48:06 <roconnor> I just want to point out that it is an instance of this more generall free monad comonad construction
12:48:14 <Palmik_> Botje, hmm, I wonder if the alpha renaming would pay off, probably not for such a small thingie :)
12:48:43 <roconnor> edwardk: I renamed my newtype to FreeW
12:48:50 <Botje> Palmik_: you can probably get by with simple lexical addressing ..
12:48:52 <edwardk> *nods*, the one in category-extras will look like Foo t a = Foo { runFoo :: Either a (t (Foo t) a) }
12:49:24 <edwardk> though i don't recall if the Either puts the a first or last in MaybeApply
12:49:28 <Botje> Dan____: okay, so to update field (x,y), you need to replace the existing x*y tuple
12:50:13 * roconnor wonders if people find free monad comonad confusing
12:50:27 <edwardk> yeah
12:50:33 <roconnor> :)
12:50:42 <edwardk> i would be more explicit in the wording rather than making a complicated noun phrase
12:51:08 <Botje> Dan____: you could take advantage of the fact that your board is always ordered by taking the first x*y-1 elements, the new value, and the rest of the board
12:51:34 <roconnor> edwardk: I'll try to find words to explain it to my supervisor :)
12:51:44 <Botje> Dan____: OR, if your lookup function only looks at the first matching tuple in the list, you can simply put prepend the nesw element
12:52:16 <edwardk> i think i'm going back to Coproduct, the Sum name is awkward because 'sum' is taken as an eliminator by Prelude
12:52:36 <roconnor> edwardk: damn you and your co- everything
12:52:40 <roconnor> :)
12:52:47 <edwardk> roconnor: i actually rather hate Co-foo 
12:52:54 <roconnor> oh good
12:52:58 <edwardk> its just here its clearer than the alternative
12:53:03 <roconnor> I guess so
12:53:04 <edwardk> because of the reduced conflicts
12:53:17 <djahandarie> edwardk, you hate copumpkin????
12:53:17 <roconnor> why are you using sum as the eliminator
12:53:19 <edwardk> and the overloaded connotation of EitherT
12:53:25 <Palmik_> Botje, hmm... if I would replace it recursively not by the list of [PIDType] but in terms of the Expr tree itself and zip (or make a Map from) [Expr] with the [PIDType] I could probably avoid that altogether, could not I, since tree would be traversed only once and the replaced parts would not be traversed.
12:53:31 <Dan____> right.. I probably should have explained that my haskel ability is VERY limted and while i get what you're saying to do, i'm not sure of how to translate it into haskelll
12:53:31 <edwardk> roconnor: analogy to either
12:53:31 <copumpkin> :(
12:53:34 <edwardk> :t either
12:53:35 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
12:53:40 <roconnor> oh
12:53:43 <edwardk> copumpkin: you're the exception that proves the rule
12:54:00 <edwardk> I mean, who doesn't love HaskellLove?
12:54:59 <roconnor> edwardk: funny thing.  I thought I was wasting time at work when I defined the Store transformer.  But since I did that I was able to see that my Cartesian store comoand instance was using that very definition
12:55:05 <Palmik_> edwardk, what is that? :P
12:55:22 <edwardk> Palmik_: copumpkin was logged in as HaskellLove yesterday
12:55:25 <roconnor> edwardk: I wouldn't have noticed that if I hadn't done that work for you
12:55:39 <Palmik_> first hit for HaskellLove http://www.facebook.com/group.php?gid=5427020961 :)
12:55:39 <edwardk> =)
12:55:44 <roconnor> plus I got you to use the awesome "Store" name
12:55:50 <edwardk> hah
12:56:04 <edwardk> it establishes credibility for your paper ;)
12:56:14 <edwardk> plus you get a little fragment of coq in the comonad-transformers tar ball ;)
12:57:49 <roconnor> I do?
12:57:50 <Botje> Palmik_: hmm, i don't follow that. Try it out and let me know if/how it works :)
12:58:05 <roconnor> you put my proof in?
12:58:07 <edwardk> yeah that little fragment is currently in the extra-source-files list
12:58:08 <roconnor> =)
12:58:40 <edwardk> and tagged your name at the top of it
12:59:06 <roconnor> edwardk: I've reordered my Store parameters to do like you do with the function first.
12:59:10 <roconnor> edwardk: it is great
12:59:23 <edwardk> its handy
12:59:26 <roconnor> edwardk: there are less flips in the code and lots of things eta contract
12:59:31 <edwardk> yep
12:59:36 <roconnor> it's kinda incrediable
13:00:04 <roconnor> I'm a bit torn as to whether I should eta expand some of them in my paper
13:00:08 <edwardk> yeah i spotted that back when building monad-ran
13:00:14 <roconnor> sometime eta-contracted code can be harder to understand
13:00:17 <edwardk> eta-expansion is a disease ;)
13:00:35 <pkrumins> hey guys, i just published an very simple article on how to write a tcp server in haskell - http://catonmat.net/blog/simple-haskell-tcp-server - any comments welcome!
13:00:49 <roconnor> pkrumins: cool!
13:01:20 <pkrumins> thanks!
13:05:12 <j-invariant> what the hell is a "tcp server"
13:05:18 * hackagebot comonad-transformers 0.10.1 - Haskell 98 comonad transformers  http://hackage.haskell.org/package/comonad-transformers-0.10.1 (EdwardKmett)
13:05:36 <copumpkin> j-invariant: something that accepts tcp connections and sends/receives things over them?
13:05:38 <edwardk> guessing something that sets up a socket, and lets people connect to it
13:05:40 <copumpkin> such as an http server
13:05:57 <Twey> Or that epitome of utility, the echo server
13:06:02 <copumpkin> mmm
13:07:20 <pkrumins> echo server :)
13:07:56 <edwardk> i really need to add all the misc. missing prelude-extras instances to comonad-transformers, i just ran out of steam
13:08:21 <roconnor> haskell has failed
13:08:28 <j-invariant> haskell caht prove anything
13:08:36 <ivanm> roconnor: :o
13:13:11 <roconnor> edwardk: I think it is likely that this free monad comonad stuff will be left out of my ICFP version of this paper for space reasons. :(
13:13:28 <roconnor> maybe I'll have a footnote
13:16:02 <dankna> you know what would be nice
13:16:25 <dankna> a program that automatically builds a single HTML page that lists all the packages I have haddocks for installed
13:16:29 <dankna> and keeps it up to date
13:16:38 <dankna> with links to the actual docs, of course
13:16:40 <j-invariant> dankna: yeah that's a good idea
13:16:54 <dankna> yeah, I may see what I can whip up later tonight after I finish some other stuff :)
13:19:33 <edwardk> roconnor: not a bad idea
13:20:04 <burp> @hoogle (!)
13:20:05 <lambdabot> Data.IntMap (!) :: IntMap a -> Key -> a
13:20:05 <lambdabot> Data.Map (!) :: Ord k => Map k a -> k -> a
13:20:05 <lambdabot> Text.Html (!) :: ADDATTRS a => a -> [HtmlAttr] -> a
13:20:08 <edwardk> i generally avoid writing papers because i hate the editing process
13:20:47 <stepkut> edwardk: Dijkstra had a fix for that I think..
13:20:50 <roconnor> I kinda like the going to Tokyo part though
13:20:52 <monochrom> hehe
13:20:58 <dankna> haha
13:21:42 <edwardk> stepkut: my handwriting isn't that good ;)
13:21:46 <monochrom> but probably you will also hate hand-writing everything with a fountain pen and making no mistake for 20 pages. :)
13:22:04 <edwardk> roconnor: fair nuff. but if i want to go to tokyo, i book a flight to tokyo ;)
13:22:13 <monochrom> (that man really had gigabytes of short-term memory!)
13:22:24 <roconnor> edwardk: you don't work as a postdoc do you?
13:22:34 <edwardk> roconnor: thankfully not ;)
13:22:38 <roconnor> lucky
13:23:08 * monochrom should offer a semi paper-writing service
13:26:26 <Philippa_> as in you'll semi-decide whether you can be arsed to write it?
13:27:14 <marcot> Good evening.  I'm planning to take a look at the options of haskell web frameworks.  What would you recommend to look at first?
13:27:37 <stepkut> marcot: i think happstack is pretty spiffy
13:27:52 <monochrom> no, you send me a draft you're proud of, I edit and rewrite for you to fulfill reviewer demands. I'll chat with you interactively in the process to learn your subject enough to get the paper done.
13:27:56 <stepkut> marcot: there is a nice tutorial, http://happstack.com/docs/crashcourse/index.html
13:28:09 <aavogt> stepkut: ought there to be a disclaimer there :p ?
13:28:46 <marcot> stepkut: Thanks.  Do you think it is more mature than, say, Snap or Turbinado/
13:28:48 <stepkut> marcot: the tutorial is for the darcs version of Happstack (which is likely to be released next week. Just needs a few more haddock improvements).
13:28:54 <dankna> macrot: you should look at FruitTart but why don't you wait a year for me to finish writing it :)
13:29:16 <stepkut> marcot: certainly more mature than Snap -- which is still in the process of adding things like file upload support
13:29:18 <augur> does anyone know of any constraint / optimization tasks that are possible to write so that you can build up an potentially infinite list of answers sorted by optimality?
13:29:31 <marcot> dankna: Well, I guess I prefer things with a closer release date.
13:29:33 <stepkut> marcot: i believe the author of Turbinado decided to leave Haskell altogether
13:29:37 <augur> im sure this isnt possible for all tasks, but are there any tasks where this is indeed possible?
13:29:43 <marcot> stepkut: Yes, I read about it.
13:30:07 <stepkut> marcot: the big three under active development these days are, snap, yesod, and happstack
13:30:11 <dankna> marcot: hehe I know, no worries
13:30:13 <Philippa_> augur: not sure about the potentially infinite part
13:30:14 <marcot> stephenjudkins: What about salvia?
13:30:30 <augur> Philippa_: ok lets assume its finite
13:30:41 <marcot> stepkut: Sorry, what about salvia?
13:30:45 <stephenjudkins> marcot: umm, what?
13:30:52 <stephenjudkins> it's a hell of a drug?
13:30:55 <Philippa_> if the search space is finite, you're looking to optimise sortBy value, no?
13:30:57 <augur> Philippa_: my main interest is in tasks that produce a "sorted" result but without engaging in a separate sort step
13:30:59 <stepkut> marcot: yesod offers a fairly unique system and style of development which some people love and some people hate.
13:31:18 <marcot> smuxi has a bad default for nick completion.
13:31:20 <Philippa_> augur: yep. I'm pretty sure they exist, but don't have an example to hand
13:31:25 <augur> Philippa_: k :)
13:31:35 <marcot> stephenjudkins: Sorry for that.
13:31:41 <monochrom> Luca Cardelli has a LaTeX font to mimic Dijkstra. http://lucacardelli.name/indexArtifacts.html then select the tab "Fonts"
13:32:17 <stephenjudkins> marcot: it's all good, just a bit startling (had no idea "salvia" was a haskell web server)
13:32:42 <stepkut> marcot: I only know that it (salvia) exists. 
13:32:45 <marcot> stepkut: Well, this is great to hear.  I'll certainly consider these three options.
13:33:37 <marcot> stepkut: Thanks
13:34:02 <stepkut> marcot: salvia may be a great choice as well -- I just don't know anything about it :)
13:35:00 <stepkut> marcot: if you check out happstack, definitely use the darcs version, there are darcs install instructions here, http://happstack.com/download
13:35:26 <marcot> Ok, I will, thanks.
13:35:37 <stepkut> marcot: and you can generate the haddock documentation via bin/haddack.sh. But, the crash course is probably the best place to start since it presents things in a logical order and stuff
13:36:01 <marcot> stepkut: Yes, APIs are not good for newcomers.
13:36:21 <stepkut> marcot: agreed
13:38:58 <marcot> stepkut: It seems that yesod and snap are made to be used together, right?
13:39:26 <c_wraith> not really.
13:39:28 <c_wraith> They can be
13:39:32 <marcot> oh, ok.
13:39:44 <c_wraith> But they're mostly independent projects that happen to share one common interface level
13:39:45 <telephone> In ghci, getStdGen trows an exception. This exception comes from a totally different function. So what is going on??
13:40:17 <telephone> "If I use System.Random, I will get something random"?
13:40:23 <monochrom> haha
13:41:14 <monochrom> I can't make it throw an exception. What is your secret of success?
13:42:31 <telephone> I don't know. After running a program, which crashes with an own made exception E, getStdGen crashes with exception E
13:42:37 <mm_freak_> GHC reports an overlapping patterns warning…  how can i disable this for one particular pattern match?
13:42:56 <monochrom> well that program is your secret.
13:43:00 <c_wraith> mm_freak_: I don't think you can disable warnings at any finer granularity than per-file
13:43:08 <doserj> change the pattern
13:43:08 <mm_freak_> hmm, bad
13:43:19 <mm_freak_> doserj: i don't see where the overlapping is
13:43:19 <c_wraith> mm_freak_: so if you put that one pattern in a different file... :)
13:44:26 <mm_freak_> i have a few specific cases and as the last pattern one catch-all
13:44:48 <mm_freak_> all specific cases have different constructors
13:45:08 <marcot> mm_freak_: Don't they cover all possibilitieys?
13:45:32 <telephone> monochrom: note getStdGen crashes after the program crashes
13:45:37 <mm_freak_> marcot: yes, that's the point
13:45:51 <marcot> mm_freak_: They do cover?
13:45:53 <stepkut> c_wraith: what interface level is that ?
13:46:01 <mm_freak_> marcot: yes
13:46:12 <marcot> stepkut: I believe it's WAI
13:46:19 <c_wraith> yes, it's WAI
13:46:34 <marcot> mm_freak_: So why do you added a catch-all in the end?
13:46:40 <doserj> mm_freak_: change the catch all to a specific pattern
13:46:48 <telephone> monochrom: by the way, the program tries to read 10000 lines from a text file. It might be some corruption?
13:46:52 <stepkut> marcot: yesod supports WAI. Snap does not. Happstack is considering moving to WAI and using the warp HTTP backend.
13:47:20 <mm_freak_> doserj: you mean to LOTS of patterns?
13:47:24 <mm_freak_> http://hpaste.org/43384/route_authorizer
13:47:25 <c_wraith> stepkut: Snap supports WAI accidently, give or take
13:47:28 <mm_freak_> here's the code
13:47:39 <mm_freak_> marcot: oh, that's what you mean
13:47:40 <stepkut> c_wraith: ?
13:47:42 <marcot> stepkut: http://www.haskell.org/haskellwiki/Web From here, I thought snap also supported wai
13:47:48 <mm_freak_> oh my
13:47:53 <mm_freak_> i know why i get the warning
13:48:07 <mm_freak_> right now the specific cases cover everything…  that will change in the future =)
13:48:18 <mm_freak_> ok, my fault
13:48:43 <roconnor> edwardk: have you ever thought about monoial natural transformations of algebras.  I.e. values of type (forall f:Functor, (f a -> a) -> (f b -> b)) satifying the laws of a monoidal natural transformation?
13:48:55 <mm_freak_> marcot: btw, it's a yesod project =)
13:49:10 <mm_freak_> i'm rewriting my homepage as a yesod blog
13:49:27 <marcot> Cool.. are you liking it?
13:49:39 <marcot> Any reason why you are using yesod instead of happstack and snap?
13:49:43 <mm_freak_> you mean yesod?  yes, i love it
13:50:21 <stepkut> marcot: no.. i think that is just wishful thinking. Snap does not support WAI -- though it would be nice if they did. 
13:50:36 <mm_freak_> well, it's mostly a personal preference, but yesod is a complete framework, where everything fits together nicely…  i didn't have the same feeling with happstack
13:51:06 <mm_freak_> also i get type-safe routes easily (route = URL, roughly)
13:51:34 <mm_freak_> easy to use form(let)s, etc.
13:51:41 <marcot> mm_freak_: Ok, I'll take that into account.
13:52:17 <mm_freak_> i haven't tried snap, though, but i think snap is not meant to be a web framework/library, just a fast, scalable HTTP server
13:52:56 <marcot> http://snapframework.com/ That's not their marketing.
13:52:58 <stepkut> mm_freak_: but web-routes was developed for use with happstack :)
13:53:25 <mm_freak_> stepkut: do you know web-routes-quasi combined with hamlet? ;)
13:53:52 <stepkut> mm_freak_: no, I need to study that more. But web-routes + HPS is nice. You can just do, <a href=SomeRoute>some route</a>
13:53:57 <byorgey> mm_freak_: I think snap is intended to be a web framework.  but I don't know how full-featured it is yet.
13:54:18 <mm_freak_> byorgey: hmm, ok
13:54:27 <marcot> stepkut: Got a cabal conflict while installing darcs happstack.
13:54:35 <mm_freak_> stepkut: yeah, you can do something similar with hamlet
13:54:44 <stepkut> marcot: what sort of conflict ?
13:54:47 <marcot> stepkut: This was the first time i tried cabal install.  Usually I use the debian packages.
13:54:57 <marcot> cabal: dependencies conflict: happstack-util-0.5.1 requires network ==2.3.0.1
13:55:09 <marcot> however network-2.3.0.1 was excluded because network-bytestring-0.1.3.2 requires network >=2.2.1.1 && <2.3
13:55:10 <mm_freak_> stepkut: web-routes-quasi gives you some additional static checks via TH/QQ
13:55:12 <stepkut> marcot: bah. cabal is really annoying like that.
13:55:23 <stepkut> mm_freak_: what sort of additional static checks ?
13:55:51 <marcot> Let's try with the debian packages for network and network-bytestring installed
13:56:31 <mm_freak_> stepkut: for example it makes sure your URL paths don't overlap
13:56:45 <stepkut> mm_freak_: overlap how?
13:57:00 <mm_freak_> stepkut: / = HomeR, / = RootR
13:57:25 <stepkut> ah
13:57:29 <monochrom> marcot: see http://www.vex.net/~trebla/haskell/sicp.xhtml and find out what can go wrong if you mix apt-get and cabal-install randomly
13:57:38 <stepkut> the quasi stuff is support to work with happstack, but I have not learned how to use it yet
13:58:06 <mm_freak_> well, yesod makes heavy use of TH/QQ, which can be a bit difficult to get used to
13:58:09 <mm_freak_> but i like it
13:58:14 <marcot> monochrom: Thanks, I'll take a look.
13:58:39 <stepkut> for normal webroutes you won't get overlap if you use TH or generics to derive the URL representations. If you create your own representations by hand, then the QuickCheck test that is provided should catch it (but that is not quite as nice as a compile time guarantee)
13:59:33 <tolkad> {-# RULES "" forall a b. (>>=) (a :: forall a. IO a) b = b (unsafePerformIO a) #-}
13:59:40 <tolkad> This does be making my program faster?
14:00:32 <byorgey> o.O
14:00:33 <stepkut> marcot: I just pushed a patch which adds 'build-install-all-alt.sh'. That uses an alternative method to build the packages that is often less finicky than using 'cabal', though it will not automatically install missing dependencies
14:00:52 <mm_freak_> tolkad: no, it just makes it lazier
14:01:11 <mm_freak_> tolkad: but as far as i see, that's an unlikely case anyway
14:01:15 <marcot> stepkut: Ok, great, I'll try that.
14:01:23 <stepkut> marcot: the last significant remaining task for the next release is making sure that 'cabal install happstack' works out of the box as many places as possible though
14:01:35 <stepkut> marcot: What compiler are you using ?
14:01:39 <stepkut> 6.12? or 7.0.1 ?
14:01:48 <byorgey> what sorts of things have type  forall a. IO a  anyway?
14:01:51 <marcot> Squeeze's 6.12.1
14:02:04 <stepkut> k. That should work. 
14:02:15 <byorgey> oh, I guess the output of a call to 'forever' does
14:02:22 <byorgey> @type forever
14:02:23 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
14:02:33 <monochrom> @type fail
14:02:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
14:02:39 <byorgey> that too
14:02:48 <c_wraith> :t Nothing
14:02:48 <lambdabot> forall a. Maybe a
14:02:56 <c_wraith> oh, you explicitly said IO
14:03:14 <edwardk> roconnor: not really, mostly because the laws can't be nicely checked in haskell =/
14:03:44 <roconnor> edwardk: isn't that like saying the monad laws can't be nicely checked in haskell?
14:03:52 <edwardk> roconnor: the closest i get is lifting comonad homomorphisms into transformers, and even there i'm stymied by wanting haskell 98 as much as possible
14:04:02 <stepkut> marcot: like any sizeable haskell project, happstack is running into the types of issues described here, marcot: getting things to install is the hardest 
14:04:05 <stepkut> oops
14:04:15 <stepkut> here, http://cdsmith.wordpress.com/2011/01/16/haskells-own-dll-hell/
14:04:29 <edwardk> roconnor: there the burden is on the producer of a class instance, the latter is on the producer of a value, i tend to apply different tests to each scenario
14:04:50 <edwardk> i presume the library writer knows what they are doing. i presume the user is an idiot ;)
14:05:47 <roconnor> edwardk: here I was thinking foo : forall f:Functor (f a -> a) -> (f b -> b) would be a class member of some MPTC Foo a b.
14:05:59 <roconnor> hence the burden would be on the producer of the class instance
14:06:01 <marcot> stepkut: Well, after you release it, and Giovanni package for debian, it'll just be an aptitude install command.
14:06:48 <edwardk> roconnor: the problem i have is whether or not such instances are uniquely determined
14:07:01 <edwardk> if they aren't then the MPTC seems out of place, and i'd rather reify it as a data type
14:07:09 <roconnor> hmmm
14:09:36 <conal> i'm drawing a blank. what is this math form called? inverse foo . X . foo
14:09:54 <roconnor> conal: conjugate
14:09:55 <monochrom> conjugation
14:10:01 <conal> thanks!
14:10:26 <monochrom> a favourite of group theorists and linear algebra people
14:10:46 <stepkut> marcot: :) if you want to switch to Ubuntu Lucid I have it already debianized :p
14:10:51 <stepkut> marcot: and built
14:11:24 <marcot> stepkut: And uploaded to the official repositories?
14:11:50 <byorgey> and Rubik's cube enthusiasts
14:12:26 <stepkut> marcot: no. Only unofficial. Along with GHC 7 and a bunch of other haskell libraries.
14:12:50 <marcot> stepkut: src/Happstack/Server/Internal/Timeout.hs:28:17: Ambiguous module name `Network.Socket.ByteString': it was found in multiple packages: network-bytestring-0.1.3 network-2.3.0.1
14:13:13 <marcot> stepkut: Oh, great.  Why don't you join the DHG and upload it to Debian directly?
14:15:01 <tolkad> yeah if you like debian so much why don't you just join them huh?
14:15:15 <spvensko> why don't you just marry it?
14:15:29 <monochrom> be nice, people
14:16:00 <edwardk> byorgey: =)
14:19:20 <Maxdamantus> 06:27:58 < j-invariant> and you can't apply functions to functions
14:19:26 <Maxdamantus> Yes you can.
14:19:35 <Maxdamantus> eval $ BinOp Apply (Function "f" (BinOp Apply (Variable "f") (Number 42))) (Function "x" (Variable "x")) = 42
14:19:38 <monochrom> how long ago was that?
14:20:12 <Maxdamantus> 5 hours ago .. I went to sleep before I read it.
14:20:21 <monochrom> heh
14:20:35 <copumpkin> j-invariant seems to troll a lot
14:21:15 <copumpkin> or at least ask fairly loaded questions in here, or make outlandish claims
14:21:41 <j-invariant> Maxdamantus: sometiems it doesn't work
14:22:41 <marcot> What's the suggested way to remove a package installed with cabal install?
14:22:53 <monochrom> ghc-pkg unregister
14:22:56 <edwardk> ghc-pkg unregister
14:23:04 <monochrom> there is also a section on that in my url
14:24:14 <marcot> monochrom: You're right, I'll read it entirely now
14:26:40 <augur> anyone know of any logic programming techniques that can reason about non-individuated phenomena?
14:26:55 <augur> or rather, non-singular phenomena
14:31:07 <roconnor> augur: like Escardo's Search Monad?
14:31:18 <augur> roconnor: not sure.
14:31:59 <augur> what i mean by non-singular is things like pluralities and, more problematically, things that are unindividuatable
14:32:11 <roconnor> yes
14:32:20 <augur> (im make direct analogies to natural language, mind you)
14:32:26 <roconnor> oh
14:32:46 <augur> mass terms, in NL, are especially problematic because like
14:32:54 <roconnor> I was thinking of continuum such as the real line
14:33:01 <augur> well there might be something there
14:33:07 <augur> but im not sure if the reals are quite the intent
14:33:10 <augur> i mean
14:33:31 <augur> suppose you can truthfully say of some individual a that P(a) holds
14:33:59 <augur> maybe it means "John arrived", where a = John, P = arrived
14:34:01 <augur> or something
14:34:31 <augur> and you might get away with saying forall x <- {a,b,c}. P(x)
14:34:53 <augur> where maybe {a,b,c} == The men, so this sentence means "the men arrived"
14:35:19 <augur> but what can you say about something like "pizza arrived"?
14:36:09 <augur> its not as if "pizza" is some individual, or some set of individuals
14:36:15 <augur> a slice of pizza is still pizza
14:36:44 <augur> pizza is a substance, in a sense. like sand and water and whatever you like
14:36:54 <augur> (its an odd substance, to be sure, but thats how we use it!)
14:37:12 <Philippa_> hmm, I'm not sure it's sufficiently uniform to count as one?
14:37:24 <augur> english disagrees with you :)
14:37:38 <Philippa_> a jar containing just oil and water'd normally be said to contain two substances but not one, for example
14:37:44 <Philippa_> add something to get them to mix and that'd be different
14:37:55 <augur> sure, but thats irrelevant
14:38:00 <augur> i can invent a term for such a mixture
14:38:02 <augur> woil
14:38:06 <augur> i have two cups full of woil
14:38:17 <augur> its a mostly water-based woil but woil nonetheless!
14:38:37 <Philippa_> is this in the same sense that "people paté" is a substance and thus so is people?
14:38:38 <augur> the crucial thing here is not what counts as the substance, tho
14:38:50 <augur> water is sufficient for the example
14:39:11 <augur> so lets not get into an argument over the theory of truth behind mass terms right now :p
14:39:39 <augur> i dont care about the english, im just curious about logic programming and substances
14:39:47 <j-invariant> no logic language does this
14:39:57 <augur> j-invariant: im not asking you
14:40:06 <j-invariant> okay ill put you on /ignore
14:40:11 <augur> bye <3
14:40:36 <Philippa_> j-invariant: I'm sure one could invent a fuzzy logic language
14:40:50 <Philippa_> in fact, I'm pretty sure someone must've done it by now
14:40:57 <augur> Philippa_: fuzzy logic is usually a probabilistic system tho
14:41:07 <augur> and thats not quite what im aiming for
14:41:10 <Philippa_> FCVO "probabilistic", sure
14:41:23 <augur> i mean, its not that theres anything fuzzy involved at all, right
14:41:40 <augur> whether or not there is water in a cup is either true or false, not kinda true
14:41:58 <augur> (factoring out our ability to _see_ the water, and ignoring water vapor in the air :P)
14:42:11 <Philippa_> well, what's under discussion is how watery the thing in the cup is, no?
14:42:17 <augur> no no
14:42:20 <sproingie> if there's a single drop of water in the cup?
14:42:31 <Philippa_> you can have the probability behave sharply if you want
14:42:35 <revenantphx> Neat code of the day: https://gist.github.com/799453
14:42:52 <augur> whats at issue is what water counts as, not what counts as water
14:43:17 <augur> what does it mean for water to have arrived, or for water to be in a cup, or for water to surround a house?
14:43:29 * Saizan wonders why such things need to be special cased at all
14:43:39 <sproingie> "if the threshold of the amount of water in the cup is satisfied, there is water in the cup".  little more accurate, kind of tautological
14:43:42 <Saizan> if you have a predicate IsThere(x)
14:43:42 <Cale> A single water molecule somewhere inside the convex hull of the cup ;)
14:44:00 <sproingie> the plastic of the cup probably has water in it
14:44:01 <Cale> No, that's too classical
14:44:09 <augur> sproingie: sure, except that assumes all your predicates are quantitative
14:44:14 <Saizan> IsThere(water) and IsThere(John) both make sense, you just need a decision procedure to calculate
14:44:23 <Maxdamantus> j-invariant: I can't imagine where it wouldn't work, except with a code structure that leaves variables unsubstituted.
14:44:41 <augur> Saizan: but Surrounds(Water,House) and Surrounds(John,House) does not
14:44:42 <Maxdamantus> eg, (a -> b) 5
14:44:44 <Philippa_> augur: okay, so you're looking to describe positional relationships
14:44:49 <Philippa_> I think that's more fuzzy, not less
14:44:56 <sproingie> i'll grant the point tho, once you've satisfied the predicate, there is or is not water in the cup
14:45:00 <augur> Philippa_: its just an example of a relationship
14:45:19 <Cale> We need to account for quantum mechanics somehow ;)
14:45:27 <sproingie> the fuzziness of the predicate doesn't carry through to the "hasWater" predicate
14:45:31 <Saizan> augur: Surrounds(Pizza,House) doesn't make sense either, so?
14:45:42 <c_wraith> Saizan: that sounds tasty
14:45:49 <augur> Saizan: if i have a thousand pizzas around your house, i can surely say that pizza surrounds your house
14:45:51 <Philippa_> Saizan: sure it does, it's just unlikely to occur
14:46:05 <augur> and if i baked a giant pizza and put it around your house, surely i could say the same
14:46:17 <sproingie> mm pizza
14:46:33 <c_wraith> I'm imagining some sort of pizza ring.
14:46:36 <Saizan> heh, ok, i forgot that english-speaking people have a weird relationship with food :)
14:46:41 <c_wraith> With a rather large diameter :)
14:46:42 <augur> ;)
14:46:43 <sproingie> pizza torus
14:46:44 <j-invariant> Maxdamantus: 
14:46:44 <j-invariant>  eval (BinOp Apply (Function "b" foo) (Number 7))
14:46:45 <j-invariant>   where foo = BinOp Apply m (Variable "b")
14:46:45 <j-invariant>         m = BinOp Apply (Function "b" (Function "a" (Variable "a"))) (Function "b" (Variable "b"))
14:46:48 <augur> "we ate pizza last night"
14:46:49 <revenantphx> No one likes my code.
14:46:49 <revenantphx> baw.
14:47:02 <j-invariant> in haskell that would be
14:47:03 <j-invariant> (\b -> ((\b -> \a -> a) (\b -> b)) b) 7
14:47:07 <sproingie> klein pizza
14:47:19 <augur> i mean, i suppose this could be interpreted as there is some volume of substance which can be called pizza, and we ate that volume last night
14:47:22 <c_wraith> ein klein nachtpizza?
14:47:55 <Maxdamantus> Hmm..
14:48:15 * monochrom adds "FSVO last night" and ducks :)
14:48:21 <augur> but obviously there's a distinction between a volume being pizza, and a volume being _a_ pizza. there's a difference between quantities that constitute some sort of packaged whole, like A Pizza, and quantities that are merely measures of a substance
14:48:27 <augur> Beef vs. Cow
14:48:45 <sproingie> is a cow a quantum of beef?
14:48:58 <augur> sproingie: no! and thats kind of the point!
14:49:00 <c_wraith> No.  a cow is a generator of beef
14:49:01 <sproingie> Quantum of Beef would be a great band name
14:49:09 <augur> cow.next_beef
14:49:32 <augur> i feel like mass terms are kind of like mathematical truths
14:49:52 <augur> in that mathematical truths are truth everywhere
14:50:10 <augur> while mass terms are applicable to "something" everywhere that something is
14:53:07 <beastaugh> augur: you mean you believe in the existence of universals?
14:54:02 <augur> beastaugh: no, but thats irrelevant
14:54:25 <Saizan> ?type id -- look ma, an universal!
14:54:26 <lambdabot> forall a. a -> a
14:54:29 <believa> How are multiple directories listed when using cabal's --extra-include-dirs and --extra-lib-dirs flags?
14:55:33 <Hugglesworth> how can I normalize(?)/match the locals of strings?
14:55:47 <j-invariant> Hugglesworth: haskell doesn't do locals
14:55:50 <Hugglesworth> I'm getting a { hGetContents: invalid argument (Invalid or incomplete multibyte or wide character)} error
14:56:01 <j-invariant> you need to turn on UTF8 mode
14:56:06 <j-invariant> its a flag
14:56:35 <Saizan> i wouldn't call hSetEncoding "turning on a flag"
14:56:48 <j-invariant> Saizan: okay
14:57:03 <j-invariant> what is the correct name
14:57:11 <monochrom> believa: I don't know. But on linux I would first guess "--extra-lib-dirs /a1/lib:/a2/lib" and then guess "--extra-lib-dirs /a1/lib --extra-lib-dirs /a2/lib"
14:57:17 <j-invariant> whats the monad for nondeterminstic state
14:57:23 <Entroacceptor> oh, btw., after all the complaining about cabal: I just had to cross-compile some stuff made in C... teh horror
14:57:36 <Philippa_> j-invariant: StateT [[ ?
14:57:39 <Philippa_> [], even?
14:57:47 <kfr> ghc still no cross compilation even though it has an LLVM backend :'(
14:57:52 <j-invariant> Philippa_: thank you
14:58:39 <Philippa_> j-invariant: possibly Logic instead of [], or a number of other tweaks, but yeah
14:58:57 <Saizan> Hugglesworth: anyhow, look at System.IO for the various functions about encodings, there's always the option of making the Handle a binary one so that you can decode it yoursefl
14:59:41 <Hugglesworth> Saizan: so {hSetEncoding utf8 localeEncoding} inside the do?
14:59:58 <Saizan> ?hoogle hSetEncoding
14:59:59 <lambdabot> No results found
15:00:09 <Saizan> ?type System.IO.hSetEncoding
15:00:10 <lambdabot> GHC.IO.Handle.Types.Handle -> GHC.IO.Encoding.Types.TextEncoding -> IO ()
15:00:27 <Saizan> Hugglesworth: hSetEncoding theHandle utf8
15:00:33 <monochrom> hSetEncoding h utf8
15:00:57 <Hugglesworth> Saizan: ah yeah, had that backwards
15:01:25 <j-invariant>     Ambiguous module name `Control.Monad.State':
15:01:25 <j-invariant>       it was found in multiple packages: mtl-2.0.1.0 monads-fd-0.2.0.0
15:01:32 <monochrom> localeEncoding is redundant because that's done by default and presumably that's how you got errors
15:01:33 <j-invariant> what the hell have I done wrong now
15:01:33 <j-invariant> :/
15:01:52 <kfr> j-invariant you probably want the mtl one, I think?
15:02:00 <kfr> ghc-pkg hide monads-fd
15:02:11 <kfr> I've had that one before
15:02:20 <kfr> I can't even remember what package installed monads-fd
15:02:22 <j-invariant> kfr: thanks that seems to work
15:02:28 <kfr> Cheers
15:02:38 <monochrom> probably enumerator
15:03:31 <djahandarie> Hmm
15:04:22 <djahandarie> I have a Parsec parser, but now I want to have a running count of what line I'm on. Is there some way to add this in without having to change every single subparser that parses an \n?
15:04:58 <kfr> That sounds tricky
15:05:22 <monochrom> getPosition
15:05:48 <monochrom> parsec already tracks line number and column number
15:05:48 <djahandarie> Holy ****
15:05:56 * djahandarie bows to monochrom
15:07:39 <Saizan> if getPosition wasn't there you could have done it with a Stream instance
15:09:25 <djahandarie> Saizan, you mean newtype my String and define a Stream instance that keeps track of \ns?
15:10:47 <accel> is it even possible to produce loops in haskell?
15:10:51 <accel> or can the gc just be ref counting
15:10:54 <accel> since loops can't be created
15:11:17 <Philippa_> djahandarie: yep
15:11:27 <Philippa_> or you can wrap the token ops and count that way, or...
15:12:06 <Saizan> accel: "let ones = 1 : ones" counts as a loop, i'd guess
15:12:38 <kniu> :t receive
15:12:39 <lambdabot> Not in scope: `receive'
15:12:57 <Saizan> or you can make a loop with mutable references like in (other) imperative languages
15:13:10 <monochrom> IMO ref counting does not qualify as gc.
15:13:37 <eden> Are there any users or developers of yi around? I have a couple of questions...
15:14:09 <sproingie> refcounting and gc are both memory management.  siblings, not subclass
15:14:36 <sproingie> Saizan: sure.  take a look at my conway's life code, it has mutable stuff all over
15:15:09 <sproingie> cabal unpack life
15:15:26 <monochrom> if making babies were that easy.
15:15:44 <sproingie> making babies is a matter of, ah, packing
15:16:21 <sproingie> https://github.com/sproingie/haskell-cells/blob/master/life/Life.hs
15:17:08 <believa> monochrom: The colon doesn't work, but specifying them separately does - e.g. --extra-lib-dirs=a --extra-lib-dirs=b ... Thanks.
15:17:16 <monochrom> nice
15:18:35 <mafs> sproingie: Nice, I was just about to link you to Will's code
15:19:05 <sproingie> i based it off of his
15:19:28 <mafs> sproingie: yeah. just linked it to him
15:19:48 <sproingie> made it an opengl example.  not the greatest opengl code since it's all immediate mode
15:20:03 <sproingie> but it's really more of a POC
15:20:24 <Hugglesworth> Saizan: I'm getting the string with http-wget though, and it doesn't take a handle... am I SOL for fixing my hGetContents error?
15:23:47 <marcot> monochrom: That was a very interesting read, thanks for the link.
15:23:56 <monochrom> you're welcome
15:24:09 <Saizan> Hugglesworth: i'm afraid so, unless you can change your system locate to utf8 (when running this program at least)
15:24:41 * hackagebot aeson 0.1.0.0 - Fast JSON parsing and generation  http://hackage.haskell.org/package/aeson-0.1.0.0 (BryanOSullivan)
15:24:49 <Hugglesworth> hrm, my system locale /is/ utf8 though `LANG=en_US.utf8`
15:24:55 <ivanm> we have _another_ JSON library now? :o
15:25:00 <danharaj> I wish ghc could do mutually recursive modules painlessly :[
15:25:40 <monochrom> Then your input file is probably not in UTF-8.
15:25:48 <Hugglesworth> and if I'm still SOL, any idea of a better library to get the html from a site?
15:26:03 <Hugglesworth> monochrom: nope, it's not.
15:26:39 <Saizan> heh, then the original suggestion to set utf8 needed to be amended :)
15:26:54 <Hugglesworth> ...
15:26:55 <monochrom> I don't know of a library that will properly choose decoding automatically. All of them require you to "just know the right decoding" and give the command.
15:26:57 <Hugglesworth> do go on
15:27:22 <monochrom> Meanwhile if you are sure the file is in latin1 (for example) then hSetEncoding h latin1
15:27:46 <Saizan> Hugglesworth: hGetContents on a text handle tries to decode according to your locale, so it works iff your locale matches the encoding of the file
15:28:21 <Hugglesworth> Saizan: so how do I safely get html from the internets?
15:29:13 <Saizan> Hugglesworth: tried the HTTP lib?
15:29:35 <Hugglesworth> not yet
15:29:51 <Hugglesworth> I chose this one because it was supposed to be "simple" >_<
15:30:07 <Saizan> i don't know if HTTP handles this right either..
15:30:10 <copumpkin> danharaj: please fix GHC!
15:30:15 <copumpkin> danharaj: many people will love you for it
15:30:20 <copumpkin> (long time)
15:30:23 <monochrom> following html4 standard: if the <head> has <meta blahblah "text/html; charset=xxx">, then you know it's xxx. If it has none, look for it in the http header. if there is still none, something about assume latin1.
15:30:49 <Hugglesworth> monochrom: that's not something /I/ should have to handle if I'm using a http lib
15:30:54 <Saizan> iirc, the header is supposed to override the meta
15:30:56 <monochrom> following html5 standard: replace "assume latin1" by a heuristic of scanning the bytes in the file.
15:31:09 <copumpkin> danharaj: (I'm not saying "patch or shut up"! I genuinely want it :P)
15:31:47 <Hugglesworth> hell, I don't even have to handle that if I'm doing this in C
15:32:04 <believa> I'm trying to build the "gd" package on OSX. I've built and installed libgd as well as other dependent libraries (e.g. libpng, libjpeg, etc) and these are all DLLs of type x86_64. When I go to build the "gd" cabal package I get errors such as "ld: warning: in /opt/local/lib/libjpeg.dylib, file was built for unsupported file format which is not the architecture being linked (i386)" which to me suggests that GHC is doing a 32-bit build an
15:32:05 <believa> is conflicting with the 64-bit DLLs its trying to link against. Has anyone come across this type of problem before and how did you work around it?
15:32:27 <monochrom> oh oops yeah, I have the order reversed. go with http header first.
15:32:56 <monochrom> anyway, AFAIK, none of the hackage http libs do anything on this.
15:33:28 * Hugglesworth hacks it with a system call and stdin/out with curl
15:33:32 <bos> believa: ghc on OSX is currently 32-bit
15:33:43 <monochrom> (I agree the http libs should do this. In addition to gunzipping data when the http header says so.)
15:34:33 <believa> bos: Right. So does that mean I need to make 32-bit builds of the DLLs in order to get things to work? Is there another way?
15:34:44 <copumpkin> bos, believa : there's an x86_64 version on haskell.org for download, maintained by someone else
15:34:46 <copumpkin> I think
15:35:18 <believa> bos: Ok. And what about Linux - does GHC support 64-bit on Linux?
15:35:21 <monochrom> and actually html4 doesn't say "assume latin1" at the end. it says do whatever you like.
15:35:41 <copumpkin> http://www.haskell.org/ghc/download_ghc_7_0_1#macosx_x86_64
15:36:06 <accel> does haskell provide a builtin for "serialize this variable to file" / "read this variable from file", or do I have to create a typclass "Serializable", and have all my times derive from Serializable ?
15:36:23 <monochrom> (and actually between "look for <meta>" and "do whatever you like", there is also "some elements can have charset attributes, honour those")
15:36:28 <believa> copumpkin: Thanks!
15:37:07 <Saizan> accel: there are Show and Read, but they are textual so not fast (and not primarily intended for serialization)
15:37:10 <accel> The programmer need not define the functions explicitly—merely declaring a type to be deriving Read or deriving Show, or both, will make the compiler generate the appropriate functions. <-- how does this magic work?
15:37:26 <Saizan> by compiler magic
15:37:34 <copumpkin> it's going to be extensible sometime soon
15:37:37 <monochrom> the compiler has all the information it needs.
15:37:46 <Saizan> data Foo = .... deriving (Read,Show)
15:37:53 <accel> is there a way to to Binary.Read Binary.Show ?
15:37:56 <accel> and have it also be fast ?
15:38:06 <monochrom> I be damned if the compiler can't even parse your data declaration and turn it into strings.
15:38:06 <Saizan> see the binary package
15:38:10 <conal> accel: note that internal (and unobservable) sharing will be lost. which reduces the benefit of laziness.
15:38:17 <Saizan> and the derive package to make instances of Binary with TH
15:38:29 <accel> conal: can you give a concrete example of internal + unobservable sharing ?
15:38:38 <copumpkin> repeat [1]
15:38:42 <copumpkin> repeat 1 or something
15:38:49 <copumpkin> that can be stored in finite (small) space
15:38:51 <accel> would "repeat 1" hang the serializatio n?
15:38:55 <copumpkin> yes
15:39:03 <lispy> > repeat 1
15:39:04 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
15:39:05 <copumpkin> I started working on vacuum-based serialization with mmorrow back in the day
15:39:06 <monochrom> "let x=5+5+5 in (x,x)" vs "(5+5+5, 5+5+5)"
15:39:35 <lispy> > nub $ repeat 1
15:39:35 <monochrom> or more interestingly "let x=[5,5,5] in (x,x)" vs "([5,5,5], [5,5,5])"
15:39:50 <lispy> > take 1 . nub . repeat 1
15:39:50 <lambdabot>   thread killed
15:39:51 <lambdabot>   No instance for (GHC.Num.Num [a])
15:39:51 <lambdabot>    arising from a use of `e_111' at <inte...
15:40:01 <lispy> > take 1 . nub . repeat $ 1
15:40:03 <lambdabot>   [1]
15:40:28 * hackagebot riak 0.1.0.0 - A Haskell client for the Riak decentralized data store  http://hackage.haskell.org/package/riak-0.1.0.0 (BryanOSullivan)
15:41:25 <Saizan> copumpkin: there's this paper about orthogonal serialization that says most of the work is already done inside Eden and GUM runtime systems (which are "forks" of GHC afaiu)
15:41:42 <copumpkin> ah, interesting
15:42:04 <djahandarie> What's the best Haskell lib for source code highlighting?
15:42:38 <djahandarie> highlighting-kate looks easy enough to use
15:44:12 <copumpkin> aha, bos' secret project is out in the open!
15:45:00 <bos> yep!
15:45:22 <ivanm> djahandarie: that's going to be deprecated as soon as he writes its replacement (which is up on github)
15:45:36 <ivanm> djahandarie: there's hscolour, etc. if you're only highlighting haskell code
15:45:46 <djahandarie> ivanm, it's Javascript
15:45:58 <ivanm> bos: any particular reason for not just improving an existing JSON library?
15:46:00 <djahandarie> Where is the github repo?
15:46:16 <bos> ivan: can't be done due to the representation they use
15:46:34 <ivanm> *nod*
15:47:05 <ivanm> djahandarie: djahandarie http://github.com/jgm/illuminate
15:47:21 <ivanm> actually, he doesn't seem to have touched it in 6 months :s
15:47:30 <djahandarie> Yeah :(
15:47:53 <lispy> bos: Hmm...I guess you could have re-written the existing one
15:48:21 <lispy> bos: anyway, cool and thanks!  do you happen to have #s showing how much better your new json library is? 
15:48:34 <bos> lispy: it's about 2x faster than the json package
15:48:41 <copumpkin> bos: aw, you decided against semigroups? :)
15:48:55 <bos> copumpkin: i might change that
15:49:04 <bos> the unit on a monoid is useless for this
15:49:12 <bos> so a semigroup would be the Right Thing
15:49:14 <copumpkin> having a nice package depending on it would make a good case for a future proposal :)
15:54:59 <augur> copumpkin!
15:55:03 <copumpkin> yo
15:55:53 <lispy> bos: Well, congrats and I look forward to seeing how your venture evolves
15:55:56 * augur flops on copumpkin
15:56:06 <augur> oh this isnt blah
16:03:58 <j-invariant> cant program haskell it just gets to weird and i gev up
16:04:18 <j-invariant> dvont know why I keep trying none of the things wanted to do work
16:05:57 <copumpkin> j-invariant: you could ask for help, too
16:05:58 <bos> lispy: thanks!
16:06:07 <copumpkin> or you could just sit and complain about how you can't do it, your choice
16:06:17 <jmcarthur> well, no, he can't do that too much
16:06:22 <jmcarthur> at least not here :)
16:06:25 <sbahra> What is the most interesting thing you are working on these days copumpkin?
16:06:28 <jmcarthur> the former is fine though
16:07:02 * jmcarthur plays with nested data parallelism
16:07:17 <jmcarthur> apparently it's planned to be released with ghc 7.2 :D
16:07:25 <copumpkin> sbahra: I'm writing some new boring primops for GHC to speed up tibbe's new flatter IntMap, poking around with some presburger solver stuff, and working on my reverse engineering stuff (as well as my day job, which often pretty interesting)
16:07:26 <jmcarthur> although right now i still have issues getting it to build some stuff
16:07:37 <sbahra> Cool.
16:07:41 <sbahra> copumpkin: You have a day job?
16:07:50 <sbahra> copumpkin: Did you graduate/quit?
16:07:56 <copumpkin> quit :)
16:07:57 <sbahra> haha
16:08:02 <sbahra> Sorry to hear. 
16:08:07 <copumpkin> oh, I'm not
16:08:11 <shachaf> copumpkin: Quit what?
16:08:11 <copumpkin> only thing I really miss is the library
16:08:15 <copumpkin> my phd :P
16:08:32 <lispy> copumpkin: university libraries are very easy to miss :(
16:08:36 <jmcarthur> holy crap the vectorizer's been working on this one module for like three minutes already
16:08:42 <sbahra> I didn't look at tibbe's IntMap.
16:08:46 <sbahra> copumpkin: Where is that?
16:08:54 <copumpkin> sbahra: it's not released yet, but I think it's on his github
16:09:02 <copumpkin> he's going to talk about it during the SF hackathon I think
16:09:04 <lispy> copumpkin: then again, I think ACM/IEEE/$journal access should be free online for papers that are completely written and edited by researchers
16:09:16 <j-invariant> I dont know how anyone gets anything done with programming
16:09:18 <copumpkin> lispy: I agree
16:09:30 <jmcarthur> j-invariant: carefully
16:09:35 <copumpkin> j-invariant: is #haskell your twitter stream?
16:10:05 <j-invariant> pr'garmming makes knots in my stomach
16:10:19 * copumpkin shrugs
16:10:47 <jmcarthur> j-invariant: it would be nice if #haskell was used for haskell questions instead of general complaints about things you seem to not think you're good at
16:11:13 <j-invariant> such as
16:11:54 * shachaf lives near a university but they won't let him check books out from the library. :-(
16:11:58 <shachaf> It's annoying.
16:12:01 <copumpkin> wow, that sucks
16:12:07 <jmcarthur> such as... "Here's some of that code I can seem to get right. It gives me XYZ error on line W. Does anybody know what that means?"
16:12:08 <sbahra> Even if you're a part-time student, shachaf?
16:12:10 <jmcarthur> *can't seem
16:12:15 <shachaf> sbahra: Well, I'm not. :-)
16:12:21 <shachaf> So I suppose it's to be expected.
16:12:22 <sbahra> Take horse back riding or something.
16:12:26 <sbahra> That's what I'm doing next semester.
16:13:16 <copumpkin> > text "<copumpkin> maybe I can talk to j-invariant this way!"
16:13:17 <lambdabot>   <copumpkin> maybe I can talk to j-invariant this way!
16:14:32 * copumpkin sets up a hot-or-not clone called malerank, to compete with bos
16:15:37 <jeffwheeler> It's super neat to see applied Haskell like that. It's often not visible.
16:15:40 <j-invariant> nobody can answer my question sthey are too hard
16:15:41 <shachaf> > teхt "<shachaf> copumpkin: I'd be careful with that."
16:15:43 <lambdabot>   shachaf: lambdabot will not be toyed with like that!
16:15:52 <copumpkin> j-invariant: what was the question?
16:15:59 <jmcarthur> j-invariant: so you're just going to complain?
16:16:00 <edwardk> j-invariant: you stumped us all.
16:18:44 <gwern> copumpkin: what's interesting about tibbe's intmap?
16:18:55 * gwern is still on the fence about flying out to SF for the hackathon
16:19:24 <djahandarie> shachaf, uh... what the?
16:20:22 <djahandarie> Is there seriously a check for that? lol...
16:20:47 <copumpkin> gwern: it's flatter
16:21:14 <copumpkin> gwern: 32-ary branches
16:21:25 <copumpkin> which means using arrays in the nodes
16:21:30 <gwern> copumpkin: I can imagine
16:21:40 <copumpkin> which is what we need fancy new array primops for fast array copies
16:21:47 <copumpkin> *why
16:21:51 <pheaver> is there no way to tell ghc which gcc to use?  i tried setting CC and GCC environment variables, but ghc appears to ignore them
16:21:56 <copumpkin> bos: oh, they might be useful to you too
16:24:45 <jmcarthur> what's bos doing?
16:24:52 <copumpkin> text!
16:24:59 <jmcarthur> doh! of course
16:25:23 <jmcarthur> i've been thinking about looking into what it would take to get some SSE stuff into GHC
16:25:24 <ivanm> pheaver: see the /usr/bin/ghc wrapper script
16:25:32 <ivanm> however, it _should_ point to the gcc you used to build ghc
16:25:40 <gwern> > 44.23 - 35.96
16:25:41 <lambdabot>   8.269999999999996
16:25:54 <jmcarthur> i don't know what's involved in adding a primop. my understanding is that it's not too involved
16:26:12 <copumpkin> jmcarthur: I've wondered about that, but it's kinda tricky for SSE
16:26:26 <jmcarthur> would probably require some new types, i guess
16:26:37 <jmcarthur> or maybe require working on bytearrays
16:26:39 <copumpkin> well, stuff going all the way down to the code generator
16:26:46 <copumpkin> whereas the kind of primops I'm adding don't need to make any changes further down
16:26:58 <jmcarthur> i think making it only for bytearrays would not require so much at the code generator level
16:27:01 <pheaver> ivanm: ah, yes, i remember this now.
16:27:14 <jmcarthur> but i don't know for sure
16:27:21 <pheaver> so, my other problem is, i want to pass CFLAG and LDFLAG options to gcc.  it looks like ghc ignores those, is that right?
16:27:44 <jmcarthur> the idea just being that you could add SSE support to an array library directly rather than relying on code gen
16:28:09 <ivanm> pheaver: -optc-... and stuff I think
16:28:14 <ivanm> there are specific ghc flags
16:28:19 <ivanm> pheaver: however, why are you using gcc?
16:28:26 <jmcarthur> but like i said, i have pretty much no idea what i'm talking about
16:28:29 <ivanm> NCG and LLVM ftw!
16:28:33 <pheaver> um, i'm not, ghc is?
16:28:41 <pheaver> ask him heh
16:28:58 <jmcarthur> ghc's C backend is deprecated
16:29:03 <ivanm> pheaver: nowadays ghc only does so if you tell it to, or you use an arch that isn't x86, x86_64 and sparc (pretty sure they're the only ones to have NCG)
16:29:07 <Eduard_Munteanu> pheaver: by default it's not using gcc anymore since quite some time.
16:29:17 <ivanm> assuming you have ghc-6.10+
16:29:19 <pheaver> i did nothing to tell it to use or not to use gcc
16:29:21 <pheaver> no, 6.12.3
16:29:26 <ivanm> pheaver: which architecture?
16:29:27 <pheaver> from the binary tarball on haskell.org
16:29:35 <jmcarthur> then it's not using the C codegen
16:29:40 <ivanm> yup
16:29:47 <j-invariant> I think all this stress gives me an ulcer
16:29:54 <pheaver> it happens to be 32-bit ghc on a 64-bit machine
16:30:04 --- mode: ChanServ set +o copumpkin
16:30:08 <j-invariant> haskulcer
16:30:53 <jmcarthur> j-invariant: please just stop.
16:31:03 <j-invariant> whats your problemk
16:31:17 <jmcarthur> j-invariant: you're just flooding the channel with despair.
16:31:17 <gwern> j-invariant: the problem is you are noise. and we expect signal.
16:31:40 --- mode: ChanServ set +o jmcarthur
16:31:48 <jmcarthur> oh, hah, copumpkin already did this
16:31:51 <shachaf> djahandarie: A check for what?
16:31:53 <gwern> at least Zetsubou-sensei had the courtesy to hang himself
16:31:55 <Eduard_Munteanu> Op fight!
16:31:56 --- mode: jmcarthur set -o jmcarthur
16:32:03 <copumpkin> I guess we didn't mind wli doing it periodically
16:32:06 <j-invariant> m aybe I sh;uold
16:32:06 <bos> copumpkin: i just sent tibbe a pull request for unordered-containers :-)
16:32:07 <copumpkin> preflex: seen wli
16:32:08 <preflex>  wli was last seen on #haskell-blah 121 days, 6 hours, 37 minutes and 30 seconds ago, saying: boshhead: Instead of making the derivatives match up to the n-th order at a single point (Taylor series) you can use several points, or both ends of an interval, or similar.
16:32:08 <shachaf> gwern: You should!
16:32:19 <gwern> shachaf: I should? ;_;
16:32:20 <copumpkin> bos: what changes? :o
16:32:22 <jmcarthur> copumpkin: wli only ever really did it in #haskell-blah, for the most part
16:32:25 --- mode: copumpkin set -o copumpkin
16:32:31 <pheaver> so, as long as i have my distribution's 32-bit compatibility libraries installed, i should be able to use ghc 32-bit on a 64-bit machine, yes?
16:32:32 <gwern> shachaf: I always thought you liked me, at least. that's cold, man
16:32:37 <copumpkin> j-invariant: please take your despair to #haskell-blah :)
16:32:40 <shachaf> gwern: Wait, what?
16:32:53 <shachaf> gwern: Oh, I was still reading a page earlier.
16:32:55 <gwern> shachaf: don't play dumb, you said I should hang himself
16:32:59 <shachaf> gwern: Fly out to the hackathon, I mean.
16:33:11 <pheaver> (and have ghc produce 32-bit builds of my packages)
16:33:15 * gwern eyes shachaf suspiciously
16:33:33 <ivanm> pheaver: I think so, yes
16:33:46 <djahandarie> 20:14 < shachaf> > teхt "<shachaf> copumpkin: I'd be careful with that."
16:33:47 <djahandarie> 20:14 < lambdabot>   shachaf: lambdabot will not be toyed with like that!
16:33:48 <jmcarthur> j-invariant: if you are making some sort of cry for help... not to be insensitive, but do it in #haskell-blah
16:33:53 <djahandarie> shachaf, that.
16:34:00 <shachaf> djahandarie: Oh. No, that's just a trick.
16:34:01 <pheaver> yeah i must have something set wrong.  i keep getting this error when i compile something:   Error: invalid instruction suffix for `push'
16:34:22 <j-invariant> no I've gibven up. I even tried in scheme and other languages but its all the same
16:34:31 <gwern> djahandarie: actually, note the security mechanism there - lambdabot prepends whitespace to output, so you couldn't make it call an op or directly address someone
16:34:32 <jmcarthur> j-invariant: then what are you here for?
16:34:35 <copumpkin> bos: anyway, it's getting way faster with my new primops
16:34:37 <pheaver> and when i run ghc with -v, it's clearly executing gcc right before that error.  which is unexpected, given what you've said about ghc not using gcc
16:34:50 <copumpkin> oh I guess my primops won't affect text
16:34:51 <j-invariant> im getting bored of this jmcarthur 
16:34:57 --- mode: ChanServ set +o jmcarthur
16:34:58 <jmcarthur> me too
16:35:13 <j-invariant> man you #haskell folks are pretty mean
16:35:17 <pheaver> this happens for both ghc-6.12.3 and ghc-7.0.1, installed frmo the binary tarballs on haskell.org
16:35:20 <shachaf> ?where+ isthatthecase gwern: Some security mechanism.
16:35:20 <lambdabot> It is forever etched in my memory.
16:35:22 <shachaf> ?where isthatthecase
16:35:23 <lambdabot> gwern: Some security mechanism.
16:35:35 --- mode: jmcarthur set +q *!*@unaffiliated/j-invariant
16:35:40 <gwern> j-invariant: no, we're famously friendly. but friendliness is not a suicide pact
16:36:01 --- mode: jmcarthur set -o jmcarthur
16:36:11 <gwern> shachaf: never claimed lambdabot is perfect. for example, I'm fairly sure the unlambda or brainfuck interpreters are possible DoS attacks
16:36:16 <bos> copumpkin: i'm using Data.Map's unions function, or else i could use HashMap right away
16:36:24 <jmcarthur> j-invariant: seriously, if you need to vent, you can do it in #haskell-blah. at least you won't be +qed there for it
16:36:29 <sbahra> hmm, hope wli is alright
16:36:43 <copumpkin> bos: ah, well I expect that could be nice and fast with temporary mutation
16:37:28 <bos> copumpkin: yes, right
16:37:36 <gwern> hrm. I wonder if there are any better writing tools for linux than just GNU style and diction. they're alright, but rather simplistic
16:37:46 <bos> copumpkin: just allocate one hashmap, then mash the whole lot into it.
16:37:50 <copumpkin> yep
16:37:56 <copumpkin> mmm
16:38:36 <lispy> gwern: writing tools?
16:38:38 <Eduard_Munteanu> What do you mean by "writing"?
16:38:41 <lispy> gwern: what do you want out of the tool?
16:39:00 <gwern> lispy: I want it to be an editor - you wrote this badly, this is inelegant, this is just ungrammatical, etc.
16:39:00 <lispy> gwern: I've been cobbling together something like the RWH website but compatible with latex
16:39:20 <lispy> gwern: oh I see.  I don't know of any automated editors.
16:39:35 <gwern> lispy: style tells me where I am being prolix, and diction can flag some common style issues, but they are very limited and neither does real grammar checking
16:39:46 <gwern> as a programmer, I want as much automated support as possible :)
16:39:49 <lispy> I'll have to look at them
16:40:05 <Eduard_Munteanu> As a programmer I don't use context-sensitive languages :P
16:40:15 <gwern> (especially since no one comments on my writings on gwern.net much less edits them...)
16:40:23 <gwern> Eduard_Munteanu: oh? and what language are you using right there?
16:40:28 <jeffwheeler> I want a WYSIWYM editor. Write in some specific format, tell it how to format each type of thing (say, # for headers, and then what headers should look like).
16:40:35 <copumpkin> > text "j-invariant: you can also join #haskell-ops if you want to discuss this"
16:40:36 <lambdabot>   j-invariant: you can also join #haskell-ops if you want to discuss this
16:40:38 <Eduard_Munteanu> Heh, just kidding.
16:41:11 <pheaver> would it be more appropriate to ask #ghc about getting ghc 32-bit to work in a 64-bit machine?
16:41:15 <gwern> jeffwheeler: that sounds... painful, actually. any accurate parser you give it will be hard to write, and if they're easy, you'll get bitten on edge cases
16:41:26 <gwern> jeffwheeler: just use a decent writing format like Markdown
16:41:40 <Eduard_Munteanu> jeffwheeler: something that takes XML?
16:41:55 <copumpkin> pheaver: probably
16:42:01 <Eduard_Munteanu> That should be reasonable, but then again Latex is reasonable too.
16:42:07 <copumpkin> pheaver: however, it's late at night in the UK, where most GHC devs reside
16:42:10 <jeffwheeler> Eduard_Munteanu: no, I'm thinking write plaintext (Markdown-ish) and what "CSS" should be applied.
16:42:25 <duckinator> hi
16:42:51 <gwern> (I think Pandoc gives pretty good tex output, FWIW)
16:42:52 <Eduard_Munteanu> Oh.
16:42:53 <jeffwheeler> gwern: mostly, I'm happy with Markdown, but I want to be able to do simple changes. Something like Ulysses for Mac comes close: you can merely define paragraph prefixes for paragraph styles, and I think it's possible to do inline styles too.
16:43:07 <Eduard_Munteanu> Yeah, that's actually closer to what things like Doxygen do.
16:43:11 <duckinator> jeffwheeler: markdown can easily be converted to HTML (see nearly any github repos for prime examples), apply CSS to that?
16:43:24 <duckinator> jeffwheeler: or did i completely misunderstand what you want? :D
16:43:31 <gwern> jeffwheeler: but why do you want to do that? # or == aren't hard section headers to type
16:43:37 <lispy> gwern: what are the false positive rates of style and diction?  Manageable?
16:43:40 <Eduard_Munteanu> duckinator: o/
16:43:53 <jeffwheeler> duckinator: Yeah, that's close to what I want, but I want the CSS to be part of an editor, and really I want it to be more document-oriented than HTML is. That is, I want to be able to see it like "print-preview."
16:43:55 <duckinator> \o Eduard_Munteanu, do i know you? ;P
16:44:06 <jeffwheeler> gwern: Here's the Ulysses I'm talking about: http://www.the-soulmen.com/ulysses/ -- I haven't used it, but it looks close to what I want
16:44:20 <Eduard_Munteanu> duckinator: um, I don't know. I just said 'hi' since nobody else replied :)
16:44:31 <gwern> lispy: diction assumes you're a bad writer, but I removed some of the less helpful false warnings like than/then it's/its or use of 'like', and it seems better
16:44:34 <duckinator> Eduard_Munteanu: oh, alright then :)
16:44:39 <jeffwheeler> I'm also open to doing it differently. More like Word or Pages' "paragraph" and "inline" styles, but more strictly enforced.
16:44:59 <gwern> lispy: false negatives, I really have no idea, though
16:45:07 <duckinator> jeffwheeler: hmm, emacs is your new best friend? ;) it's very extensible if you feel up to designing it yourself
16:45:28 <jeffwheeler> duckinator: I'll use emacs over vim when I'm dead. :)
16:45:46 <gwern> lispy: as for style, it's just a bundle of standard readability statistics like flesh-kincaid or gunning-fog, so it has all the same issues mechanical implementation of them have
16:46:01 * BMeph is looking forward to GHC getting 64-bit numbers working on his 64-bit machine...
16:46:05 <jeffwheeler> duckinator: but seriously, I've been playing with Vala (easier to experiment with Gtk stuff there), and I'm not quite sure the way to build it, or exactly what I want it to look like.
16:46:14 <lispy> gwern: thanks for the info
16:46:27 <gwern> lispy: np. been playing with style/diction over the past few days
16:46:38 <gwern> automate as much as possible, is the programmer's creed!
16:47:19 <Eduard_Munteanu> Hrm, I should be the automation engineer here (or at least, soon)
16:48:40 <mikeg> I'm trying to write my first monad transformer stack... does this look sensible? MaybeT (ReaderT CommandData (WriterT [CommandResult] IO)) ()
16:49:48 <Eduard_Munteanu> Yeah.
16:50:04 <Saizan> MaybeT might be the most redundant wrt IO
16:50:18 <gwern> jeffwheeler: ulysses is down, btw
16:50:40 <Saizan> i.e. IO already has easy ways to throw errors / abort the computation built-in
16:50:53 <jeffwheeler> gwern: yeah, seems to be; sorry about that.
16:51:07 <Eduard_Munteanu> It might be better to factor out IO completely if possible.
16:51:09 <jeffwheeler> gwern: there are a few reviews if you want to Google it, but the website has the good screencasts that explain it.
16:51:20 <mikeg> Mhmm the only reason I need IO is for SQL database access
16:51:44 <mikeg> Everything I've learned about Haskell has said to not use IO for error-handling though...
16:52:43 <Saizan> ah, with your stack even with a MaybeT error you'd still get your [CommandResult], while if you use the IO features you wouldn't
16:53:38 <Eduard_Munteanu> Also if you rely on implicit error handling of Maybe it's probably worth it.
16:53:39 <Saizan> well, IO shouldn't be thrown in just for error-handling, but if you're already using it i think it's a quite fine choice, especially since extensible exceptions
16:54:23 <Saizan> yeah, to as you need to lift a Maybe a to MaybeT m a; you could also lift it to MonadIO m => m a
16:54:40 <Saizan> s/to/though/
16:55:03 <mikeg> What do you mean I'd still get a [CommandResult]? I haven't tried unrolling my stack yet to get the results yet
16:55:34 <Saizan> ?unmtl MaybeT (ReaderT CommandData (WriterT [CommandResult] IO)) ()
16:55:35 <lambdabot> CommandData -> IO (Maybe (), [CommandResult])
16:56:06 <mikeg> ?mtl CommandData -> IO (Maybe [CommandResult])
16:56:07 <Saizan> mikeg: ^^^ even if that Maybe () happens to be a Nothing, you still get a list of CommandResult as the other field in the tuple
16:56:07 <lambdabot> Maybe you meant: ft map msg pl unmtl url
16:56:35 <Saizan> ?unmtl (ReaderT CommandData (WriterT [CommandResult] (MaybeT IO))) ()
16:56:35 <lambdabot> CommandData -> IO (Maybe ((), [CommandResult]))
16:56:55 <Saizan> that's what happens instead if you push MaybeT at the bottom of the stack
16:57:04 <mikeg> ?unmtl (ReaderT CommandData (WriterT () (MaybeT IO))) [CommandResult]
16:57:05 <lambdabot> CommandData -> IO (Maybe ([CommandResult], ()))
16:57:19 <mikeg> Do you know how I could get rid of the empty tuple?
16:57:50 <Eduard_Munteanu> Why get rid of it?
16:57:52 <Saizan> WriterT () is useless
16:57:56 <Eduard_Munteanu> It's the point of WriterT
16:58:25 <Saizan> but in the other case the empty tuple is just the result of this hypotetical computation, it won't always be () in your program
16:58:30 <kfr> The point of the Writer monad is to return its environment at the end
16:58:37 <kfr> So with () it's rather fruitless
16:58:43 <mikeg> Well I was hoping WriterT would let me build the [CommandResult] one CommandResult at a time
16:59:00 <Saizan> WriterT [CommandResult] will
16:59:06 <duckinator> Does implementing all (afaik) boolean logic gates, including implies/implied-by, mean i have no life? :D https://github.com/RockerMONO/hlogic/blob/master/hlogic.hs
16:59:16 <Eduard_Munteanu> For that it should be something like   (ReaderT CommandData (WriterT [CommandResult] (MaybeT IO))) ()
16:59:40 <Eduard_Munteanu> @unmtl (ReaderT CommandData (WriterT [CommandResult] (MaybeT IO))) ()
16:59:41 <lambdabot> CommandData -> IO (Maybe ((), [CommandResult]))
16:59:47 <mikeg> Thanks, I'll try using that :)
16:59:55 <gwern> lispy: one of the unfortunate aspects of style is that the statistical tests are biased against semicolons, which I enjoy using; just removing a semicolon in favor of a full stop can lower the difficulty of a pargraph by 10%
16:59:58 <kfr> duckinator: Those aren't gates >:O those are functions
17:00:15 <duckinator> kfr: err, yes. sorry D:
17:00:26 <kfr> http://www.hitequest.com/Kiss/cross_section.gif
17:00:28 <kfr> That's a gate
17:00:29 <lispy> gwern: heh, wow
17:00:40 <duckinator> also, that has an error?! D: *runs off to fix*
17:00:40 <kfr> p </- q = not (p <-- q) -- that's a function
17:00:40 <Saizan> duckinator: or that you like booleans!
17:00:45 <kfr> Notice the difference!
17:00:53 * gwern knows this because I am going through a page and observed the 10% drop just now
17:00:54 <duckinator> kfr: indeed, that is quite a large difference :o
17:01:16 <lispy> gwern: say that my document is in latex, can it help me?  Or do I have to do some sort of latex to plain text conversion first?
17:01:28 <duckinator> ...*facewall*
17:01:45 <gwern> lispy: I imagine the conversion would help, but I haven't noticed any real issues with markdown
17:02:14 <gwern> lispy: I mean, if you're just trying to reduce the reading difficulty, it doesn't reall matter whether the latex biases scores up a fixed amount
17:02:15 <duckinator> works now, that's what i get for committing code i wrote at ~5am the other day without checking that it worked :)
17:02:23 <lispy> gwern: the largest document I have on hand (written by me) is all in latex and I want to know what it thinks of my writing style (I'm guessing it doesn't think highly)
17:02:25 <ivanm> is there any way of using extensible exceptions and saying "catch either of these errors" ?
17:02:53 <gwern> lispy: just toss it in and see
17:02:54 <Eduard_Munteanu> Though there's some fun stuff I've seen arrows used for, including simulating "circuits".
17:02:56 <Saizan> ivanm: yes
17:03:03 <ivanm> Saizan: how?
17:03:35 <Saizan> ivanm: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Exception.html#v%3Acatches
17:03:41 <ivanm> ta
17:05:12 <kfr> Ta <3
17:07:24 <pickles1> could anyone help me on installing an external lib in windows?
17:07:27 * ivanm really needs to find a better way of localising errors associated with lazy Text values than evaluating its length right after reading it in
17:07:34 <ivanm> pickles1: what lib?
17:07:43 <pickles1> trying to install hsndfile
17:07:52 <pickles1> and got the windows version of the libsndfile library
17:08:03 <pickles1> but when i cabal install hsndfile it errors
17:08:22 * hackagebot streams 0.5.0 - Various Haskell 2010 stream comonads  http://hackage.haskell.org/package/streams-0.5.0 (EdwardKmett)
17:08:27 <edwardk> Eduard_Munteanu: i rather prefer the approach taken by andy gill for circuits
17:08:57 <edwardk> having used both, the arrow sugar is a bit sickeningly sweet ;)
17:08:57 <pickles1> I'm not sure if the error is in cabal or c2hs
17:09:19 <ddarius> edwardk: You'd rather use the combinators?
17:09:19 <ivanm> m3ga: ping!
17:09:24 <ivanm> preflex: seen m3ga 
17:09:24 <preflex>  m3ga was last seen on #haskell 18 days, 5 hours, 44 minutes and 53 seconds ago, saying: ezyang, geheimdienst : thanks
17:09:34 <edwardk> ddarius: i'd rather not use arrows ;)
17:09:36 <ivanm> pickles1: m3ga is the maintainer of libsndfile
17:09:38 <pickles1> errors are "unknown option \"-x\""
17:09:45 <pickles1> o neat
17:09:46 <ddarius> edwardk: I figured that would be your response.
17:09:47 <Eduard_Munteanu> edwardk: this one? Type-Safe Observable Sharing in Haskell
17:09:54 <edwardk> ddarius: observable sharing doesn't take you into arrow lala land
17:09:57 <Eduard_Munteanu> I didn't read that yet.
17:10:05 <edwardk> eduard: yeah. i use that approach all over the place.
17:10:24 <ddarius> Almost no one uses semicolons anymore.
17:10:41 <lispy> ddarius: in haskell or in english?
17:11:02 <Halik> Jalice, Hi!
17:11:02 <Jalice> Halik: Hello there.
17:11:02 <edwardk> syntactic sugar causes cancer of the semi-colon
17:11:04 <ivanm> pickles1: he doesn't maintain hsndfile though
17:11:10 <Eduard_Munteanu> I kinda do sometimes.
17:11:46 <pickles1> ivanm: would he have any ideas on the issue with it though?
17:12:02 <ivanm> depends on where the error lies ;-)
17:12:07 <pickles1> true
17:13:23 <ddarius> lispy: English.
17:14:16 * pickles1 really needs to read error messages better
17:14:25 <pickles1> ivanm: looks like the error is thrown by c2hs
17:14:34 <ivanm> hmmm
17:15:06 <pickles1> it's complaining about an unknown option "-x" and that it can't open input file "c"
17:15:35 <pickles1> (this is from running: cabal install hsndfile --extra-include-dirs=... --extra-lib-dirs=...)
17:16:13 <pickles1> c2hs wouldn't be expecting a lib in a linux format on windows, would it?
17:18:04 --- mode: ChanServ set +o jmcarthur
17:18:09 --- mode: jmcarthur set -q *!*@unaffiliated/j-invariant
17:18:11 --- mode: jmcarthur set -o jmcarthur
17:20:51 <pickles1> man, room's quiet tonite
17:21:14 <ivanm> OK: letting text do the encoding/decoding rather than GHC let's me avoid glibc memory errors! \o/
17:22:01 <ivanm> pickles1: whaddaya mean? it's not even noon!
17:22:02 <edwardk> j is no longer invariant
17:22:16 <ivanm> edwardk: heh
17:22:31 * hackagebot ad 0.47.0 - Automatic Differentiation  http://hackage.haskell.org/package/ad-0.47.0 (EdwardKmett)
17:23:19 <edwardk> (updated ad to use the streams' package's f-branching stream
17:24:39 <edwardk> i'll probably update it again when i move Tensors over
17:24:40 <ivanm> is there a nicer way of doing this? http://hpaste.org/43385/ugly_error_message_handling
17:25:04 <pickles1> ivanm: you mean not everyone here's an american!?!?!?!?
17:25:07 <edwardk> ivanm: in terms of raw number of lines?
17:25:27 <ivanm> edwardk: in terms of the duplication of return . Left . show and the usage of ScopedTypeVariables, etc.
17:25:33 <ivanm> pickles1: strangely enough, no...
17:26:00 * pickles1 hopes the sarcasm came accross in his last comment
17:26:22 <ivanm> yeah, for the most part
17:26:42 <pickles1> just makin sure, its tough to tell with text sometimes
17:26:58 <ddarius> 0.-47-
17:27:01 <ivanm> hence the <sarcasm>...</sarcasm> tags!
17:27:07 <pickles1> tru
17:27:11 <ivanm> ddarius: hmmm?
17:27:24 <edwardk> handler :: you could map (return . Left) over the result, beyond that you can make a combinator that is parametric in the choice of exception and use it over and over with concrete types
17:28:19 <ivanm> edwardk: Handler :: forall e . Exception e => Handler (e -> IO a)
17:28:31 <edwardk> h :: (Exception e) => e -> Either ErrMsg a; h = return . Left . show
17:28:45 <edwardk> erm off by one
17:30:12 <ivanm> huh, tried that before and it didn't work :/
17:30:33 <ivanm> ta
17:30:50 <edwardk> that much work?
17:30:56 <ivanm> yeah
17:31:06 <ivanm> it'd be nice not to have to use ScopedTypeVariables, but it'll do
17:31:17 <edwardk> you can get rid of those with a little more voodoo
17:31:19 * ivanm wonders why his attempt at doing that didn't work...
17:31:22 <ivanm> edwardk: oh?
17:31:34 <edwardk> :t Handler
17:31:34 <lambdabot> Not in scope: data constructor `Handler'
17:31:44 <ivanm> @hoogle Handler
17:31:44 <lambdabot> Control.Exception data Handler a
17:31:44 <lambdabot> Control.Exception Handler :: (e -> IO a) -> Handler a
17:31:44 <lambdabot> System.Console.Editline.Readline callbackHandlerInstall :: String -> (String -> IO ()) -> IO (IO ())
17:32:46 <edwardk> h :: Exception e => Proxy e -> Handler (Either ErrMsg a)
17:33:14 <edwardk> h _ = Handler (return . Left . show)
17:33:36 <edwardk> then use it with hs = [ h (Proxy :: Proxy FooException), h (Proxy :: Proxy BarException) ]
17:33:50 <edwardk> that isn't a scoped type variable so no extension needed
17:34:04 <edwardk> Data.Proxy from the tagged package
17:35:56 <ivanm> I might pass then; this is only a util test script (not built by cabal as it would require building the rest of graphviz a third time :/ )
17:36:06 <edwardk> ah
17:36:11 <edwardk> btw
17:36:13 <edwardk> proxy is just
17:36:15 <edwardk> data Proxy a
17:36:18 <edwardk> er
17:36:22 <edwardk> data Proxy a = Proxy
17:36:28 <edwardk> so you can inline that def ;)
17:36:31 <sm> evening all
17:38:08 <sm> has someone here installed pandoc head recently ? it won't use my pandoc-types 1.8 because of citeproc-hs
17:39:41 <gwern> sm: I tried, but had the same problem
17:39:58 <accel> if i'm writing a haskell program, and I use ! everywhere, except in situations where ! would cause non-termination; that should eliminate all the huge heap space issues right?
17:40:06 <sm> howdy gwern.. building a custom citeproc-hs now
17:40:14 <Cale> accel: It may create heap issues.
17:40:24 <ivanm> sm: you need head citeproc-hs, don't you?
17:40:25 <gwern> accel: no way. that's voodoo programming
17:40:47 <Cale> accel: But it will make the program behave more like a program written in a strict language, so space behaviour might be more intuitive to you even if it's bad.
17:40:50 <ivanm> gwern: is this the same kind of voodoo that edwardk was offering me just before? :p
17:40:59 <gwern> accel: that's like saying if you inject drugs everywhere on your body that isn't instantly fatal, that will fix whatever disease you may have
17:41:07 <gwern> ivanm: I'd say it's worse juju
17:41:16 <sm> ivanm: I suppose.. actually just relaxing the pandoc-types dep in the unpacked citeproc-hs 0.3.0 worked also
17:41:16 <Cale> haha, that's an excellent metaphor
17:41:50 <jmcarthur> death is a pretty tempting alternative
17:41:51 <ivanm> edwardk: oh, and wouldn't your code sample above need to be [h (proxy :: Proxy UnicodeException), ... ] ?
17:41:52 <pickles1> thx for the help ivanm
17:41:55 <pickles1> nite all
17:42:00 <ivanm> cya pickles1 
17:42:17 <Axman6> accel: if using bangpatterns everywhere made sense, it would be the default
17:42:53 <ivanm> Axman6: NO WAI!
17:42:53 <ddarius> @quote Marvin- Java
17:42:53 <lambdabot> No quotes for this person. I am sorry.
17:43:30 <edwardk> h (Proxy :: Proxy UnicodeException), ...
17:43:31 <edwardk> yeah
17:43:48 <edwardk> didn't i say that?
17:43:51 <ddarius> Eager languages just have dual space leaks to lazy languages.
17:44:14 <ivanm> edwardk: you did, but h is a function
17:44:26 <edwardk> yes, i was applying it to Proxy
17:44:31 <ivanm> oh, wait, I get  you now
17:44:32 <ivanm> doh
17:44:33 <edwardk> Proxy here is a concrete data type
17:44:36 <ivanm> since Proxy is the constructor
17:44:41 <edwardk> that is a singleton constructor
17:44:42 <edwardk> yeah
17:45:22 <parcs> is anyone here successfully using direct-fastcgi?
17:45:56 <ivanm> edwardk: though with your solution there is nothing that I can see that ties that Exception type to Handler
17:46:00 <ivanm> so would it actually work?
17:46:03 <edwardk> yes
17:46:22 <edwardk> the exception type is tied through the Proxy argument to h
17:46:35 <edwardk> the instance of Exception is chosen based on that
17:46:45 <edwardk> thats what gets boxed up in the handler
17:46:46 * hackagebot functor-apply 0.10.0.1 - Applicative sans pure, Monad sans return, Alternative sans empty  http://hackage.haskell.org/package/functor-apply-0.10.0.1 (EdwardKmett)
17:46:49 <edwardk> try it ;)
17:47:09 <sm> pandoc with textile support installed.. thanks ivanm, gwern
17:47:22 <ivanm> edwardk: I suppose I _could_... :p
17:47:42 <edwardk> cleaned up the diagram on the haddock front page of functor-apply to match reality
17:47:43 <sm> that list of supported formats is getting nice and long!
17:48:38 <ivanm> heh... for some reason graphviz chokes the most over the dot files it itself generated :p
17:48:42 <ivanm> (I'm guessing due to their size)
17:49:02 <accel> Cale , gwern , Axman6 : can you give any example where using bang pattern causes something bad to happen (that is not non termination) ?
17:49:24 <ivanm> it's a bit weird though... there's no CPU usage, etc. :s
17:49:39 <accel> Cale , gwern , Axman6 : can you give any example where using bang pattern causes something bad to happen (that is not non termination) ? -- it seems like alot of haskell issues with performance/speed boils down to: haskell is lazy, so it'll geneerate all these chunks, and then suddenly, when you don't expect it, it all executes, generating massive heap fun
17:50:25 <Cale> accel: Any program where you don't actually need to compute those things, and you do anyway, and it allocates a bunch of data in the process.
17:50:38 <j-invariant> Cale: wna
17:50:39 <uart14> accel, too many bang patterns can linearize your carefully parallelized code
17:50:45 <j-invariant> why dont you believe in an obejlective universe
17:50:51 <Cale> accel: There are a lot of function applications where the representation of the function application is smaller than the representation of the evaluated result.
17:51:10 <accel> in practice, most programs I write, I need the results
17:51:25 <accel> why would I write code that describes how to compute something, only to throw it away?
17:51:31 * ivanm suspects he needs to fix how graphviz calls dot, etc.
17:51:38 <Cale> j-invariant: Because it seems unnecessary to do so. We have our subjective observations, and we can use the scientific method to try to construct predictive models. These models needn't actually be an approximation of something.
17:51:39 <Axman6> because sometimes you don't know what to compute
17:51:47 <accel> Axman6: when?
17:51:47 * hackagebot functor-apply 0.10.0.2 - Applicative sans pure, Monad sans return, Alternative sans empty  http://hackage.haskell.org/package/functor-apply-0.10.0.2 (EdwardKmett)
17:51:55 <ivanm> accel: you do know about laziness, etc. don't you?
17:52:14 <Axman6> accel: we use infinite lists all the time... surely you don't think those should be completely evaluated strictly?
17:52:22 <accel> ivanm: I know about things like let ones = 1 : ones ;
17:52:27 <j-invariant> Cale: measurements are objective no? so what obsevation is subjective
17:52:35 <accel> Axman6: I said, use strictness, except in cases of non-termination
17:52:48 <Cale> Measurements are subjective.
17:53:00 <Cale> (ultimately)
17:53:02 <accel> Axman6: I understand that if you define fibs recursively, you don't want strictness; however in other cases, what's so bad about strictness?
17:53:02 <ivanm> accel: OK, another example where laziness is useful: you want _a_ solution to the problem; quite often it's easier to code it up such that _all_ solutions are found
17:53:06 <ivanm> and so you just take the head
17:53:21 <accel> ivanm: this is another case where strictness leads to non-termination
17:53:23 <ivanm> accel: in general, you don't want stuff evaluated until (and if) it's neaded
17:53:25 <Cale> There's another sort of almost-objectivity that you can get which is consensus on subjective observations.
17:53:26 <j-invariant> even a ruler?
17:53:32 <accel> my question is: as long as it doesn't lead to non-temrination, shouldn't I always use strictness?
17:53:35 <ddarius> edwardk: Reality is overrated.
17:53:50 <ivanm> accel: not if the actual value won't be needed
17:53:58 <Cale> j-invariant: Ultimately, you're looking at that ruler to make the measurement.
17:54:00 <ivanm> the only times I've generally needed bangs is for accumulating values
17:54:01 <ddarius> accel: No.
17:54:46 <accel> ddarius: give me an example where strictness doesn't lead to non-termination; yet I still don't want strictness
17:54:46 <j-invariant> Cale: wkhy can't you chang the universe just by beleiving then?
17:54:47 <Cale> j-invariant: Two different people can look at the ruler, and they tend to see the same result, but this is something which is better explained as part of some physical model, rather than a fundamental assumption, I think.
17:54:57 <ivanm> *sigh* I wonder if I need to actually go and write deepseq instances for graphviz...
17:54:58 <ddarius> accel: Any time you use foldr you want a lazy argument.
17:55:07 <Cale> j-invariant: I'm not sure what your question means.
17:55:15 <ddarius> Regardless of whether you want to handle infinite inputs or not.
17:55:20 <accel> I challenge everyone in #haskell. Show me a piece of code where (1) strictness doesn't lead to non-termination (2) laziness gives better performance than strictness.
17:55:24 <accel> I challenge everyone in #haskell. Show me a piece of code where (1) strictness doesn't lead to non-termination (2) laziness gives better performance than strictness.
17:55:34 <Cale> accel: The lazy implementation of isInfixOf
17:55:40 <Axman6> god i wish you'd stop repeating yourself
17:55:48 <ddarius> Any uses of map.
17:55:54 <edwardk> accel: play with fingertrees
17:55:55 <Cale> accel: Which has early termination and smaller space usage as a lazy program
17:55:57 <ddarius> (Of course, map is a foldr.)
17:56:07 <uart14> accel, the Idea is that you don't have to worry about what is needed and what is not. You can just produce everything you can and select what you really need later. Of course you could just write your code so that it never calculates anything you don't need, but that is hard.
17:56:15 <edwardk> accel: the spine has to be lazy or the whole thing loses its asymptotic guarantees, quite visibly in practice.
17:56:15 <Axman6> accel: see okasaki's book on functional data structures
17:56:21 <Cale> any (isPrefixOf needle) (tails haystack)
17:56:38 <ddarius> (any is a foldr too)
17:56:54 <Cale> If you make that strict, and you evaluate the whole list of tails first, you'll allocate a bunch of space for list cells you might not even need if the needle is found at the first position.
17:56:56 <edwardk> accel: make a fingertree with certain numbers of elements and keep consing and unconsing one element, and you pay logarithmic cost for each element, you can O(1) if its lazy
17:57:11 <Axman6> ddarius: any's a foldl no?
17:57:13 <ivanm> there's alsoo DLists
17:57:16 <accel> hmm; I will learn about isPrefixOf / fingertrees ; and ask questions later.
17:57:18 <ivanm> @src any
17:57:18 <accel> Thanks :-)
17:57:18 <lambdabot> any p =  or . map p
17:57:19 <ddarius> Axman6: No.
17:57:23 <ivanm> Axman6: ^^
17:57:28 <Axman6> @src or
17:57:28 <lambdabot> or    =  foldr (||) False
17:57:31 <ivanm> > any [True, undefined]
17:57:32 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
17:57:33 <lambdabot>         against inferred ...
17:57:33 <Axman6> oh right, sorry :)
17:57:37 <ivanm> > any id [True, undefined]
17:57:38 <lambdabot>   True
17:57:39 <edwardk> accel: i have slides, in fact, my slides have a strictness error in them! ;)
17:57:43 <Axman6> i even explained why this was so to someone the other day!
17:57:44 <j-invariant> t
17:57:52 <j-invariant> Cale: that is different to solipsism?
17:58:27 <Cale> j-invariant: yeah
17:59:23 <Saizan> accel: a trivial example is "print [1..n]", if the list was strict you'd use O(n) memory, with lazyness it's O(1)
17:59:37 <accel> Saizan: hmm, this I buy
17:59:43 <deech`> I'm looking for advice on how to explain the value of monads in non-Haskell languages. I have a friend who's read the tutorials understands the material but having trouble understanding how to apply the principle to his OO development.
17:59:50 <accel> Saizan: in practice, is sum [1 .. n] constant memory in hakell?
17:59:55 * ivanm -> lunch
18:00:03 <ddarius> But if the list was infinite strictness would lead to non-termination (and no output).
18:00:06 <ivanm> there's also genericLength with lazy Nats...
18:00:12 <Cale> That sort of thing happens all over the place. Places where a list maybe isn't infinite, but is approximately infinite, in that you never expect to reach the end of it.
18:00:23 <Cale> Or similarly with a tree.
18:00:25 <ddarius> accel: It depends.  The Report defines it wrong so implementations are hampered.
18:00:48 <Saizan> accel: with the right implementation of sum, yes
18:00:50 <ddarius> accel: Haskell practice has demonstrated what is important and powerful is not eagerness and not laziness but the mixture.
18:00:53 <Cale> A game tree for some discrete game AI for instance might be finite, but so astronomically large that if you strictly evaluated it, it would be disastrous.
18:01:56 <accel> ddarius , Saizan : thanks; your trivial example has convinced me laziness is a good thing sometimes, even when strictness doesn't lead to non-termination; thanks!
18:02:19 <Cale> Laziness is a good default because it's only less than a quarter of the time that you actually want strictness, and most of the time that you do want strictness, either the strictness analyser will pick it up for you, or a prefab combinator like foldl' will solve your problem.
18:02:53 <accel> so "optimizing haskell" ins
18:02:57 <accel> isn't so much about black magic
18:03:03 <int80_h> so I'm using Network.Curl, and having headers directed to standard error. Any ideas on how to capture standard error in this case?
18:03:04 <accel> as it's about understanding strictness vs laziness?
18:03:19 <ddarius> accel: Mostly thinking about laziness at all.
18:03:51 <edwardk> black magic helps, but you can typically get by with letting things be lazy if they have to do a lot of work, and strict if they do small things like bumping a counter by 1.
18:04:00 <ddarius> Many performance problems people have are because they blithely ignore laziness altogether and are blatantly obvious if you think about it at all.
18:04:21 <sm> interesting rule of thumb edwardk 
18:04:22 <ddarius> It really unsurprising that if you completely ignore the operational semantics of a language you will produce crappy code.
18:04:37 <ddarius> sm: Cale has a similar one.
18:04:38 <edwardk> 99% of my optimizations consist of adding a little ! or {-# UNPACK #-} pragma here or there almost always on counters.
18:04:44 * sm takes note
18:05:15 * ddarius just mentally unfolds the calculation using call-by-name and can usually immediately see the bad spots.
18:05:28 <sm> edwardk: do you find those after careful profiling, or just visually with some trial-and-error or.. ?
18:05:33 <edwardk> or in bit complicated tree structures where i want to ensure its fast to get down to the leaves without all the indirect jumps caused by building those leaves lazily
18:05:36 <accel> edwardk: what does UNPACK do?
18:05:40 <ddarius> Of course, at this point I can see the obvious bad patterns.
18:05:54 <Saizan> maybe we could try a language where Int's are strictly evaluated by default
18:06:05 <edwardk> sm: honestly i get most of them right the first time, by reasoning from analogy to how they are done in containers
18:06:28 <edwardk> saizan: sounds great. i'm sure nobody has tried it before =)
18:06:31 <ddarius> sm: It's quite easy to see these things by calculation.
18:06:39 <edwardk> oh 'Ints'
18:06:43 <edwardk> i missed the qualification
18:06:58 <edwardk> the problem there is parametricity on ints makes that hard to fiddle with
18:07:08 <accel> edwardk: http://www.haskell.org/ghc/docs/6.12.1/html/users_guide/pragmas.html <-- holy crap, does UNPACK let me control memory layout of a data type?
18:07:18 <edwardk> accel yes
18:07:20 <Cale> My rule of thumb is that you want strictness wherever you're collapsing a large number of separately-evaluatable pieces of data into a small number of such, and you're doing it by summarizing, not just searching.
18:07:34 <Cale> For example, adding up the elements of a list
18:08:01 <Cale> In every other case, laziness is either roughly equivalent or better than strictness.
18:08:03 <accel> edwardk: how can I get an unpacked array of unpacked Vec3, where Vec3 = double double double ?
18:08:15 <accel> Cale: so strict for the "reduce" phase of a map-reduce
18:08:17 <edwardk> accel: there you're screwed ;)
18:08:28 <c_wraith> Cale: Another common case is when you're building up a data structure by repeated modifications to its current values.
18:08:37 <edwardk> accel: you can't unpack parametrically
18:08:51 <ddarius> Take sum ns = sum' ns 0; sum' [] acc = acc; sum' (n:ns) acc = sum' ns (n+acc);  Unfold a few steps using CbN, sum [1,2,3] = sum' [1,2,3] 0 = sum' [2,3] (1+0) = sum' [3] (2+1+0) = sum' [] (3+2+1+0) = 3+2+1+0.  Space leak obvious.
18:09:07 <accel> edwardk: what do you mean parametrically, I just want 100 Vec3's in a continuous memory block
18:09:10 <edwardk> accel: you _can_ unpack one data type into another if the former has only one constructor though
18:09:10 <jmcarthur> accel: Data.Vector.Unboxed.Vector (Double, Double, Double)
18:09:21 <Cale> accel: Yeah, where the result isn't just a search result or something which you could evaluate part of it using just part of the input.
18:09:29 <edwardk> accel: you could abuse a StorableArray
18:09:36 <c_wraith> Cale: look at what happens when you use Map.adjust thousands of times in a row.
18:09:39 <Saizan> int80_h: i think the more proper way would be to pass a CurlHeaderFunction f as CurlOption, though the interface looks quite lowlevel
18:09:49 <edwardk> jmcathur's solution works, but the memory layout is different than you'd think
18:10:07 <Cale> c_wraith: That's in some sense a similar thing, in that you're accumulating or collapsing the changes down into a small piece of data.
18:10:36 <c_wraith> Cale: I guess you are summarizing, in some sense.
18:11:04 <Saizan> int80_h: ah, together with easyWriter it's easier :)
18:11:24 <ddarius> sm: Oftentimes you can figure out a good approximation of space behavior with just call-by-name rewriting.  Sometimes you also need to consider the sharing in laziness.
18:12:20 <ddarius> Which can be done with simple call-by-need rewriting rules.
18:12:37 <ddarius> There's no need to even get into "graph reduction" and "STG" or even core for most of this.
18:12:37 <jmcarthur> accel: edwardk is right. the memory layout for my suggestion will look like three arrays of packed Doubles rather than one interleaved array of Doubles
18:12:38 <sm> ddarius: thanks. I don't yet do this often enough to internalise it, but hope to soon
18:13:05 * sm notes Cale's rule also
18:13:28 <jmcarthur> accel: where by "packed" i just mean "dense," not "boxed"
18:13:40 <edwardk> the only other time i ever fidle with strictness annotations is on containers where some operation is typically logarithmic in time to complete, and i'm willing to pay for that up front. this lets me avoid having to pay the doubly-indirect jump in order to evaluate each thunk because everything in the structure will be tagged for the recursive case. this removes the amortization of my bounds, replacing my common case with worst case bo
18:14:07 <accel> Suppose, I have WeirdVec = double double int double ; and I want 100 WeirdVec's, where it's double double int double; double double int double; double double int double; .... is this impossible in Haskell right now?
18:14:09 <jmcarthur> i generally will make records strict, too
18:14:19 <accel> jmcarthur , ddarius , edwardk ^^
18:14:24 <edwardk> accel: add a storable instance and use StorableArray, 
18:14:29 <jmcarthur> accel: Storable
18:14:43 <ddarius> accel: Not really.  Haskell doesn't give you good control of memory layout.  At least not in any reasonable wayi.
18:14:51 <jmcarthur> accel: "unboxed" normally will mean you'd have multiple arrays, one for each component
18:15:01 <edwardk> http://hackage.haskell.org/packages/archive/array/0.3.0.2/doc/html/Data-Array-Storable.html
18:15:03 <jmcarthur> depending on the array library, at least
18:15:05 <accel> why do I want StorableArray rather than IOUArray ?
18:15:15 <edwardk> IOUArray only works for primitive types
18:15:16 <ddarius> Storable works but is hardly "Haskelly" and has it's own issues with performance (not even counting safety and correctness.)
18:15:17 <jmcarthur> accel: Storable gives you direct control over memory layout
18:15:32 <edwardk> StorableArray serializes using the storable instance which serializes to a fixed sized record in memory
18:15:36 <accel> It is similar to IOUArray but slower. Its advantage is that it's compatible with C.
18:15:37 <ddarius> accel: If memory layout is really important to you, Haskell is not the best language to use.
18:15:41 <edwardk> this is the behavior you are requesting
18:15:42 <accel> Why is Storable array slower than IOUArray ?
18:15:58 <edwardk> Because it has to peek and poke the bytes into memory
18:16:04 <jmcarthur> accel: for the same element type, i'd say usually it's slower, yes
18:16:17 <monochrom> STG is too low-level i.e. too many details you won't use. Some kind of graph reduction is fine (and necessary when sharing makes a difference) but again it has to be high-level enough i.e. close enough to call-by-name so you don't work on useless details.
18:16:18 <edwardk> IOUArray does less math
18:16:32 <accel> Why can't Haskell, with all it's compiler knowledge/magic, generate code to do the peek/poking of StorableArray efficiently?
18:16:54 <ddarius> monochrom: Indeed.  Technically doing call-by-name reduction is graph reduction.
18:16:58 <edwardk> accel: it does. but that is still less efficient than the primops that were added by ghc to support iouarray
18:17:05 <edwardk> here you are still passing a dictionary, etc.
18:17:34 <ddarius> Also this isn't a terribly common case so the compiler writers aren't going to spend a lot of time optimizing for it.
18:17:35 <jmcarthur> well, dictionaries are usually inlined, aren't they?
18:17:36 <accel> dumb question: what is the point of unpacked if I can unpck a single data type, but I can't unpack an entire array of it? i.e. what's the use case of unpacked?
18:17:56 <jmcarthur> it's fast
18:18:09 <jmcarthur> accel: why do you need the memory layout to be so specific, btw?
18:18:12 <monochrom> Including and making-explicit "let ... in" in call-by-name is one way to do it just right. Drawing it pictorically helps the visually oriented people.
18:18:22 <ddarius> accel: Do you want to do two indirections and allocations or one?
18:18:26 <accel> jmcarthur: physics/particle simulation
18:18:43 <accel> I want my arrays of Vec3's and Mat3's to be in continuous blocks of memory
18:18:56 <edwardk> if you absolutesmurfly _must_ control the exact byte by byte array layout and don't give a whit about portability you can of course bypass all of this and use GHC.Prim.MutableByteArray# and hand write your methods, etc.
18:19:02 <ddarius> monochrom: Indeed, that's the way I'd recommend for a textual (particularly, calculational) approach to call-by-name.
18:19:22 <accel> edwardk: is that fast?
18:19:32 <edwardk> its what IOUArray uses under the hood
18:19:35 <jmcarthur> accel: non-interleaved arrays can be surprisingly efficient sometimes, but if you are really needing this to be so fast that you need this level of control then maybe haskell is the wrong language
18:19:56 * ddarius already said that Haskell is a bad language for this.
18:20:20 <accel> jmcarthur: maybe; but haske's beautiful in that physics code can look like physics equations almost in haskell
18:20:24 <accel> which is kinda impossible ish in C++
18:20:32 <jmcarthur> accel: or maybe you could try something like the accelerate package? i
18:20:34 <monochrom> "absolutesmurfly" :)
18:20:40 <jmcarthur> *i've not tried it, but it looks kinda spiffy
18:21:00 <ddarius> accel: Choose what's important to you.  Or just have the pretty Haskell be a code generator to C/C++/assembly.
18:21:09 <monochrom> (is there also an "absolute female smurf ly"?
18:21:11 <monochrom> )
18:21:17 <edwardk> monochrom: heh i meant to say absosmurfly ;)
18:21:31 <ddarius> That's a rather effective approach that often produces code that's faster than even reasonably good but sane hand-written C/C++/assembly.
18:21:32 <monochrom> hrm! absosmurfly?
18:21:46 <accel> ddarius: via Harpy ?
18:22:14 <ddarius> accel: That's one approach.  Generating C is usually better in many ways.  You can also generate LLVM.
18:22:17 * monochrom watched the Smurfs in Chinese, wouldn't know their language in English
18:22:31 <accel> ddarius: generate C = "by hand" ? generating LLVM -- as in using ghc-llvm, or geneerating llvm code by hand?
18:22:34 * ddarius can hardly remember the last time he watched smurfs.
18:22:51 <edwardk> anyways, going hom
18:22:52 <ddarius> accel: Doing none of those by hand.  Having your Haskell code generate C or LLVM.
18:22:53 <edwardk> er home
18:22:55 <edwardk> later
18:23:05 <ddarius> edwardk: Why aren't you home yet?
18:23:07 <jmcarthur> accel: basically, make an embedded DSL with a compiler
18:23:21 <jmcarthur> accel: it doesn't have to be as involved as writing a compiler for a general purpose language
18:23:57 <accel> so basically writing haskell code that (1) takes haskell code as input and (2) generates C code as output?
18:24:03 <ddarius> accel: No.
18:24:16 <accel> ddarius: enlighten me
18:24:18 <ddarius> Writing Haskell code that just generates C code rather than executing the semantics.
18:24:29 <ddarius> There's no need for a parser and an AST and such.
18:24:36 * Axman6 is about to start work on a library for array computations that uses LLVM to make JIT'd code specifically for the comuputation you're performing
18:24:39 <accel> ddarius: what's the input to the haskell code?
18:24:49 <jmcarthur> accel: you can write haskell instead of C. that's the point
18:25:07 <accel> so it's basically a compiler that compiles _something_ down to C right?
18:25:08 <c_wraith> accel: the haskell code has no input.  It just generates C output.
18:25:09 <ddarius> accel: Whatever parameters are fixed ahead of time for your particular case.
18:25:11 <accel> question is, what is this _something_
18:25:15 <accel> hmmm
18:25:16 <ddarius> accel: No.
18:25:19 <jmcarthur> accel: basically you just write a lot of functions that represent composable C code and such
18:25:23 <int80_h> Saizan: I noticed this http://hackage.haskell.org/packages/archive/curl/1.3.6/doc/html/src/Network-Curl-Info.html. Could I just use CookieList? That's all I wanted anyway. Just wanted to capture cookies. Having trouble making a cookie jar and looking for another way.
18:25:25 <accel> so it's a haskell program, which when executed, generates C code
18:25:29 <jmcarthur> exactly
18:25:31 <ddarius> accel: Yes.
18:25:39 <accel> jmcarthur , ddarius : got it; thanks :-)
18:25:54 <c_wraith> haskell turns out to be a *really* good language for this purpose.
18:25:57 <Axman6> there's a lot of work being done to make it possible to not need to do that
18:26:00 <jmcarthur> haskell serves as your fancy macro system :)
18:26:16 <Axman6> accel: you should really look into the accelerate package, and things like data parallel haskell
18:26:17 <ddarius> accel: Incidentally, hsc2hs works by translating marked up Haskell to C that prints out normal Haskell.
18:26:34 * jmcarthur is messing with dph right now. it's not quite "there" yet
18:26:38 <ddarius> Axman6: As well as Pancito and FFTW and dons' Monte Carlo stuff.
18:26:40 <Axman6> jmcarthur: aye
18:27:00 <Axman6> ddarius: yeah? i've only heard of FFTW, and not its use from haskell
18:27:04 <jmcarthur> supposedly it will be *released* with GHC 7.2
18:27:12 <accel> i'm pretty sure FFTW predates haskell
18:27:19 <ddarius> accel: It certainly doesn't.
18:27:44 <accel> ddarius: I stand corrected.
18:27:47 <ddarius> FFTW is in O'Caml, but it's the same idea.  There's no need to limit yourself to only looking at examples in Haskell.
18:27:58 <ddarius> Heck, C++ template metaprogramming is another such example.
18:28:06 <Saizan> int80_h: i've never used Curl before, so i don't know
18:28:31 <monochrom> I should try using BASIC to generate Haskell
18:29:37 <djahandarie> You should also try puncturing your skin with needles while walking barefoot on burning charcoal
18:30:00 <monochrom> Nevermind, it's so difficult that the most elegant way is 10 PRINT "<intended haskell code here>"  20 END
18:30:15 <Saizan> @hackage BASIC -- and you'd run it here, right?
18:30:15 <lambdabot> http://hackage.haskell.org/package/BASIC -- and you'd run it here, right?
18:30:36 <ddarius> accel: As a simple example, let's say you want to calculate eigenvalues.  You could write out a specialized routine to efficiently do this, or you could just write (A - λI)^-1 v  and have your interpretations of scaling, matrix multiplication and subtraction and inversion produce that specialized code for you.
18:30:38 <djahandarie> Recursive basic<->haskell code generation
18:31:31 <ddarius> accel: You may also know the matrix size so the code generator can make use of that, whereas you probably don't want to write out the same routine 10 times for tweaked for 10 different sizes and a general routine would be slightly slower.
18:31:59 <accel> ddarius: this sounds great -- is there sample code I can read to learn from this? I find it's often easier to master the basics, then get creativ emyself rather than invent the whole thing myself
18:32:13 <ddarius> accel: I mentioned some examples as have others.
18:32:20 * accel prefers standing on the shoulders of giants rather than building towers to stand on
18:32:25 <accel> Pancito, FFTW, and Monte carlo stuff ?
18:32:58 <ddarius> Actually s/Pancito/Vertigo/
18:32:59 <levifikri> Hi, I'm running Haskell in Windows. My application uses split-0.1.2.2 library. When I compiled with profiling flags, I see this error message " Could not find module `Data.List.Split': Perhaps you haven't installed the profiling libraries for package `split-0.1.2.2'?". Anyone could help?
18:33:14 <accel> http://www.acooke.org/pancito-code/ <-- yeah, that doesn't look very compute intensive
18:33:15 <ddarius> Also a lot of things that target GPUs.
18:33:28 <ddarius> @google monte carlo don stewart
18:33:30 <lambdabot> http://www.scribd.com/doc/19770030/Specialising-Generators-for-HighPerformance-MonteCarlo-Simulation-in-Haskell
18:33:30 <lambdabot> Title: Specialising Generators for High-Performance Monte-Carlo Simulation ... in Haske ...
18:34:25 <accel> so basically the 90/10 rule in haskell is that for 90 of the code, you can write in straight haskell; for the 10% that takes up 90% of the cpu power -- write a DSL in haskell that generates fast code?
18:34:28 <ddarius> It was Pan that I was thinking of: http://conal.net/Pan/
18:34:35 <Axman6> accel: there's libraries like hmatrix which use LAPACK and BLASS
18:34:36 <ddarius> Which is related to Vertigo.
18:34:41 <Axman6> BLAS*
18:34:41 <levifikri> it seems the profiler couldn't find this file: "C:\Users\<myname>\AppData\Roaming\cabal\split-0.1.2.2\ghc-6.12.3\Data\List\Split.p_hi".
18:34:52 <Saizan> levifikri: "cabal install split -p" so that you have the profiling version 
18:34:54 <ddarius> accel: That often works extremely well as in Don's example.
18:34:54 <levifikri> How do I get that file (*.p_hi)?
18:36:46 <gwern> levifikri: install with profiling as you were told
18:36:58 <gwern> p_ denotes a profiled version
18:37:07 <accel> ddarius: just went through those slides; I'm not sure what the high point to learn from it is
18:37:29 <levifikri> gwern it does work! thx :)
18:38:32 <gwern> -_-
18:38:41 <gwern> you're welcome?
18:38:50 <levifikri> I plan to do GPU programming in Haskell, any recommended libraries? Accelerate looks cool, anyone tried using that before?
18:41:08 <ddarius> accel: The paper has more details, though this just mostly sketches the idea and the results.  One aspect of the idea is to find what is worth generating code for.  And the results are: faster, easier, simpler, and more flexible.  Basically a win in every way.
18:41:46 <ddarius> I.e. this technique can be extremely effective, though it does certainly depend on your problem having some exploitable structure.
18:43:11 <levifikri> ddarius did you try using it in Windows? I got problem installing CUDA in Ubuntu..
18:43:28 <levifikri> and haven't try on Windows
18:44:20 <lewis1711> is none haskell-specifc discussion of pure FP off-topic here? can't think of another channel that'd have a lot of people with such knowledge
18:44:24 <lewis1711> *non
18:45:02 <monochrom> on-topic
18:45:36 <lewis1711> ok. is there any advantage to avoiding mutating *local* state, say inside a function? since the function can still be referentially transpearant this way
18:46:37 <lewis1711> say in the case of a for loop inside a function that constructs something
18:47:01 <uart14> lewis1711, It still composes badly
18:47:09 <ddarius> lewis1711: Yes.  The same advantages, albeit greatly attenuated, as avoiding it in general.
18:47:22 <ddarius> lewis1711: In Haskell there's ST when you want to do it.
18:48:31 <gwern> lewis1711: just pretend the pure FP is haskell and discuss it
18:48:55 <gwern> (there aren't a whole lot of other pure FP langs, after all)
18:49:07 <lewis1711> AFAIK, the biggest advantage of pure FP is referentially transparency, which enables clearer reasoning and also memoisation at a lower level
18:49:50 <lewis1711> what advantages would local state mutation concede?
18:50:14 <lewis1711> gwern: yeah but it's possible in impure FPL's to still program purely should you want to. which is my dilemna
18:50:15 <gwern> lewis1711: it also forces clearer reasoning as well as allows it
18:50:24 <dolio> Clear reasoning about the implementation of your function.
18:50:33 <monochrom> when you reason, you convert mutable state back to parameter, so mutable state doesn't make reasoning easier. you can hope to gain execution speed.
18:50:35 <lewis1711> good point
18:50:36 <c_wraith> how often do you really actually *want* local state mutation?  I mean, foldl' doesn't need local state manipulation to work in place.
18:50:59 <ddarius> lewis1711: All the other benefits.  Parallelization, not having to worry about ordering, no hidden dependencies.
18:51:41 <gwern> lewis1711: you can in impure FPs, but you can no longer be sure the impure parts will creep back in, the lang and libs won't cater to it making your code uglier, and the compiler probably won't bother doing pure optimizations because impurity is everywhere and compilers must be conservative
18:51:49 <lewis1711> c_wraith: preformance reasons. it's faster to mutate an existing list than to allocate a new one
18:51:53 <ddarius> In many cases, though, these aren't a big deal for very localized uses of state, but then, it's often just as easy to write those localized uses of state purely in many cases with about the same clarity.
18:52:16 <gwern> lewis1711: too easy access to impurity is like a recoveringalcoholic living next to a bar. with a liquor store on the other side.
18:52:17 <c_wraith> lewis1711: are you actually allocating a new one?  You might be surprised what's going on.
18:52:36 <Cale> lewis1711: Also, nonstrict semantics + mutation is (im)pure insanity
18:52:57 <gwern> lewis1711: the key thing about ST is that its type magic quarantines the mutation
18:52:58 <Cale> lewis1711: Because it's hard to tell what order the effects will happen in
18:53:06 <lewis1711> c_wraith: you're saying that while on a programmer, you may be allocating a new function, but the compiler may well be accomplishing this imperatively?
18:53:19 <ddarius> lewis1711: Or better.
18:53:27 <lewis1711> *new structure, not function
18:53:29 <gwern> lewis1711: sure. look at tail call optimization. looks like recursion, is iteration
18:53:29 <Cale> lewis1711: Well, it absolutely is turning the program into an imperative one
18:53:35 <c_wraith> lewis1711: with lists, the list you create might never exist at all.
18:53:43 <Cale> lewis1711: Because your processor runs an imperative language.
18:54:03 <lewis1711> ha, naturally
18:55:00 <c_wraith> hmmm.  does sum fuse?
18:55:11 <lewis1711> I suppose this is sort of low level thinking. too much C perhaps
18:55:13 <dolio> Depends what framework you're using.
18:57:04 <lewis1711> gwern: are we sharing the same definition of impure FP? AFAIK it means that state change is not encapsulated with a mechanism such as a monad
18:58:02 <lewis1711> something like an ML or a scheme
18:58:16 <gwern> those are impure, yeah
18:58:24 <gwern> most of them. plt scheme has a pure scheme, iirc
18:59:22 <ddarius> c_wraith: It does in stream-fusion based frameworks, but not in the foldr/build framework.
18:59:47 <lewis1711> right. anyway, thankyou for the responses everyone. food for thought.
19:00:00 <c_wraith> hmmm.  you can't implement sum as foldr in constant space, can you?
19:03:14 <Axman6> > foldr (+) 0 [1,2,3,4] :: Expr
19:03:15 <lambdabot>   1 + (2 + (3 + (4 + 0)))
19:03:23 <Axman6> > foldr (+) 0 [1..10] :: Expr
19:03:24 <lambdabot>   1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + 0)))))))))
19:11:01 <djahandarie> c_wraith, well you can write foldl' as foldr, so I imagine you can?
19:13:08 <AnAdorableNick> [A -cl
19:21:09 * ddarius should work out what Paul Taylor's notion of sobriety would look like applied to arbitrary algebraic data types.
19:27:06 <ivanm> does anyone have any suggestions for how I can wrap my call to dot, neato, etc. to time it and try to work out why it's so slow?
19:27:31 <ivanm> i.e. it seems to take much longer to do suff when I have graphviz call it than it does when I call it by hand
19:28:37 <ddarius> Actually, I think sobriety is related (not terribly surprisingly) to Escardo's selection monad.
19:29:21 <accel> ivanm: do you want to profile haskell code, or the C code haskell calls?
19:29:43 <ivanm> haskell
19:29:54 <ivanm> I'm calling the actual dot utility, so there's no poitn in profiling C ;-)
19:30:06 <ivanm> I have the sneaking suspcicioun that I'm being too lazy with sending data to/from dot
19:30:13 <accel> dot/graphviz is written in Haskell ?
19:30:17 <accel> I thought it was written in C
19:30:38 <ivanm> Graphviz is indeed written in C
19:30:42 <ivanm> I'm calling it from haskell though
19:30:46 <ivanm> @hackage graphviz
19:30:46 <lambdabot> http://hackage.haskell.org/package/graphviz
19:36:13 <shash> hi
19:36:24 * ivanm waves idly in shash's general direction
19:36:29 <shash> can any1 tell me /.....how to code fibonacci
19:36:41 <ivanm> is this homework?
19:36:48 <shash> ha ha ...no
19:36:52 <shash> i am new learner
19:37:02 <Rotaerk> isn't that one of the most common examples used to demonstrate haskell
19:37:07 <ivanm> because that seems ridiculously simple, and there are heaps of examples of fibonacci in haskell around everywhere...
19:37:07 <Rotaerk> that and factorial
19:37:09 <ivanm> Rotaerk: yup
19:37:28 <ivanm> factorial = product . enumFromTo 1 ;-)
19:37:32 <ddarius> @where evolution
19:37:32 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
19:37:59 <shash> frnds nt factorial
19:38:05 <shash> fibonacci
19:38:40 <ivanm> @go haskell fibonacci
19:38:40 <lambdabot> Maybe you meant: google googleit do
19:38:44 <ivanm> @google haskell fibonacci
19:38:46 <lambdabot> http://www.haskell.org/haskellwiki/The_Fibonacci_sequence
19:38:46 <lambdabot> Title: The Fibonacci sequence - HaskellWiki
19:38:49 <ivanm> @help googleit
19:38:49 <lambdabot> letmegooglethatforyou.
19:38:52 <ivanm> ahhh
19:39:08 <ivanm> shash: ^^
19:39:19 <shash> thank u
19:39:25 <shash> this is fun
19:39:38 <shash> i can ask questions to real people
19:39:44 <shash> rather than google
19:40:19 <shachaf> shash: Real people generally prefer to answer questions which can't easily be answered with a Google search.
19:40:40 <shachaf> This is why we invented computers, after all.
19:40:59 <shash> ok let me learn ..then i will ask tuff questions
19:41:07 <ddarius> shachaf: That and so real people can better drop bombs on other real people.
19:41:28 <ivanm> ddarius: that sounds more like it!
19:41:46 <shash> computer is not genious
19:41:52 <shash> human brain is genious
19:42:00 <shash> tats y we created computer
19:42:04 <shash> and he dint created us
19:44:50 <shash> hello guys ....i try sort "shashank" and it answered aahhknss
19:45:01 <shash> i want to sort my name backward
19:45:14 <ivanm> that's not sorting
19:45:17 <ivanm> that's reversing
19:45:28 <ivanm> shash: how bout you actually try following a tutorial rather than blindly guessing stuff?
19:45:30 <shash> answer should be -- knahsahs
19:45:56 <shash> ok boss
19:46:09 * ivanm isn't your boss
19:46:52 <shash> i am asking silly and simple questions from experts of haskel
19:46:58 <shash> sorry
19:47:16 <codemac> I seem to remember there being a paper/presentation on the yi editor?
19:47:25 <djahandarie> shash, try out http://learnyouahaskell.com for a guide
19:47:30 <codemac> Does anyone have the link to that? I seem to be failing at internetting right now
19:47:35 <djahandarie> shash, and you want: reverse "shashank"
19:48:43 <shash> thank u
19:49:15 <ddarius> @google yi editor
19:49:15 <lambdabot> http://en.wikipedia.org/wiki/Yi_(editor)
19:49:16 <lambdabot> Title: Yi (editor) - Wikipedia, the free encyclopedia
19:49:37 <shash> do MATLAB and Haskel are same features ?
19:50:15 <codemac> ddarius: aha! didn't see the link at the bottom there, thanks
19:52:29 <gwern> shash: no, and that's a silly comparison to make
19:52:38 <ddarius> Freakin' Hangul fonts.
19:52:52 <gwern> ?
19:52:55 <ddarius> gwern: do Python and Haskel are same features?
19:53:09 <gwern> ddarius: no
19:53:41 <ddarius> gwern: But they both have lambdas, right?  And FP is just lambdas, right?
19:54:03 <gwern> does python have lambdas? I thought the FP functions were getting shoved out to a library
19:54:07 <shash> which is the comptitor language of haskel ?
19:54:23 <applicative> agda, C, a few others
19:54:33 <shash> matlab also have same kind of functions
19:55:18 <aavogt> matlab lambdas are pretty limited
19:55:26 * hackagebot kit 0.6.4 - A dependency manager for Xcode (Objective-C) projects  http://hackage.haskell.org/package/kit-0.6.4 (NickPartridge)
19:59:12 <Apocalisp> copumpkin: You around?
19:59:28 <c3designer> does the tryhaskell.org tutorial really ends at lesson 6 step33 ?
20:00:26 <c3designer> it says "stay tunes for more chapters"...
20:00:29 <copumpkin> Apocalisp: yep
20:01:49 <applicative> c3designer, it's hard to parse, but it looks like lesson 6 is all.  https://github.com/chrisdone/tryhaskell/blob/master/js/tryhaskell.js  
20:01:57 <applicative> write a new one!
20:03:03 <cole> I'm having difficulty getting the wxhaskell development packages to install on my arch linux machine. Has anyone else had difficulty with this?
20:03:33 <c3designer> nice, I always enjoy reading source code to get my answer (not kidding)  :)
20:04:21 <c3designer> and you're right lesson 6 is the last, I'll go back to Real World Haskell :)
20:07:28 * hackagebot kit 0.6.5 - A dependency manager for Xcode (Objective-C) projects  http://hackage.haskell.org/package/kit-0.6.5 (NickPartridge)
20:08:26 * ddarius has a good blog response in the making.
20:09:21 <shachaf> ddarius: To what?
20:12:42 <cole> If I do 'ghci -package wx' I get 'unable to load package '1xcore-0.12.1.6' . . .
20:12:49 <ddarius> One of Martin Escardo's posts, or alternatively Andrej Bauer's posts about Martin Escardo's work, on Andrej Bauer's blog.
20:13:10 <applicative> c3designer I take it you've seen 'learn you a haskell', to make the inevitable additional suggestion
20:13:47 <copumpkin> ddarius: how will you publish the response? surely not a blog of your own??
20:14:01 <ddarius> copumpkin: I'll reply to the post clearly.
20:14:05 <copumpkin> oh :(
20:14:09 * ddarius practices distributed blogging.
20:14:19 <copumpkin> lol
20:14:24 <gwern> exactly the trap - he'll simpl delete your response, and look like the victor
20:14:49 <applicative> have you found the error of escardoism-bauerism?
20:14:52 <ddarius> Actually, I was thinking of potentially making a(nother insane) Monad Reader article out of it.
20:15:11 <gwern> what are we talking about, anyway?
20:15:58 <applicative> there aren't too many Escardo posts in the world.
20:17:50 <bos> what's the name of the programming style that converts algebraic data types into functions?
20:17:58 <bos> and why can i not remember this myself?
20:18:02 <ddarius> Church-encoding (or Scott-encoding)
20:18:05 <Apocalisp> Church encoding
20:18:06 <bos> ah yes, thanks
20:18:08 <ddarius> Though I wouldn't call it a "style."
20:18:27 <Axman6> bos: JIT compilation? :P
20:18:30 <ddarius> (Just to be clear, Church and Scott encoding are different.)
20:19:01 <Axman6> bos: i'm thinking of doing the same thing for an array processing library, that produces LLVM at runtime, when i has more information about the arrays you'll be working with
20:19:25 <ddarius> @google Timothy Budd functional representation
20:19:25 <lambdabot> http://en.wikipedia.org/wiki/Functional_decomposition
20:19:51 * Axman6 wishes that GHC could apply RULES at runtime :(
20:19:52 <ddarius> @google timothy budd
20:19:53 <lambdabot> http://eecs.oregonstate.edu/~budd/
20:19:53 <lambdabot> Title: Timothy A. Budd's home page
20:20:09 <Apocalisp> @let true = const
20:20:10 <lambdabot>  Defined.
20:20:14 <Apocalisp> @let false = flip const
20:20:15 <lambdabot>  Defined.
20:20:27 <bos> ddarius: i'm looking at taking my parser's state type, which is data S = S { 3 params }, and replacing it with function parameters
20:20:36 <bos> so far, it looks like a royal pain
20:20:47 <bos> but it might save me some allocation
20:21:47 <ddarius> @google a new approach for vector code generation for applicative languages
20:21:48 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.52.3959
20:23:37 <ddarius> @google Compiling APL for parallel and vector execution
20:23:38 <lambdabot> http://portal.acm.org/citation.cfm?id=114064
20:23:38 <lambdabot> Title: Compiling APL for parallel and vector execution
20:33:43 <kfr> Hmm I am really annoyed by how the record notation introduces top level functions which forces you to choose rather clumsy/long names. For example, consider: data Point = Point { x :: Int, y :: Int }; data Vector = Vector { x :: Int, y :: Int, z :: Int } -- that won't fly. It seems people currently work their way around this by using C style prefixes for record functions (like pointX, vectorZ etc) or putting them into their own modules each so they can perfor
20:33:43 <kfr> m qualified imports
20:34:09 <Axman6> could make a class
20:34:19 <Axman6> though, that could also get tedious
20:34:33 <ddarius> kfr: The correct solution is local modules.
20:34:40 <kfr> This has been brought up before a few days ago, I think somebody suggested the concept of local modules
20:34:42 <kfr> Maybe that was ddarius
20:34:44 <Axman6> kfr: i think there's a proposal for context sensitive name resolution
20:35:22 <Axman6> which would allow name overloading if they context let you know which type the function was being called on
20:35:23 <ddarius> Axman6: Which is disgusting.
20:35:44 <Axman6> it is a little, but can be used well for things like this
20:36:43 <ddarius> Local modules aren't disgusting at all and can be used well for this and for other things.
20:38:07 <Axman6> how would they work?
20:38:40 * hackagebot authenticate 0.7.2.4 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.7.2.4 (MichaelSnoyman)
20:43:23 <ddarius> Axman6: I'm pretty sure a pre-processing solution that converted module Foo where { import Foo.Bar(<stuff>); <definitions>; module Bar(<export list>) where {...}; <more definitions> } into module Foo where { import Foo.Bar(<stuff>); <definitions>; <more definitions>; } and module Foo.Bar (<export list>) where { import Foo (<definitions>, <more definitions>); ... }
20:43:31 <ddarius> would give the right semantics.
20:43:59 <Axman6> could you paste an example? that's a little hard to read
20:44:37 <ddarius> Though there are variations on this that could also be explored (i.e. not requiring Foo.Bar to explicitly import anything from Foo, requiring Foo.Bar to explicitly import from Foo, and so forth.)
20:44:58 <magicman> Note to self: when using Text.Regex.Posix, use [0-9], and not \d.
20:45:05 <ddarius> (And, of course, this solution would collide with similarly named hierarchical modules, but this would just be a prototype implementation.)
20:45:11 <Axman6> magicman: i hate that too -_-
20:45:14 <magicman> This will cause hours of headaches *every time*.
20:46:35 <magicman> In more positive news, stuff finally works consistently in Linux *and* Windows, so yay \o/
20:46:37 <bos> ddarius: i'm a bit lost with trying to do some church encoding
20:46:40 <bos> ddarius: http://hpaste.org/43386/church_madness
20:47:06 <bos> ddarius: i'm pretty sure that's wrong, but don't have a good picture of what "right" would look like
20:47:33 <ddarius> ChurchS would simply be (ByteString -> ByteString -> Bool -> r) -> r
20:47:42 <bos> OK
20:48:01 <bos> thanks
20:48:46 <ddarius> Well, rank-2 quantified over r to get back the same kind as S and to allow you to pass it around as a first class value.
20:51:38 <ddarius> That translation of local modules would break-down when Foo had an export list and Foo.Bar wanted to use more than what Foo exported.
20:52:41 <ddarius> Though this is another design space trade-off that could be made (though, for -local- modules the, seemingly, most natural thing would be for Foo.Bar to see everything in Foo.)
20:55:32 <cdsmithus> Has anyone here done anything with Haskore recently?  Really, I'm trying, but there's nothing but pages and pages of type signatures, and all the tutorials I can find are 404 errors.
21:03:09 <accel> is there a way to generate postscript graphics from inside of haskell?
21:03:33 <Axman6> have you looked on hackage?
21:03:49 <accel> there's hps
21:03:56 <accel> but it looks very incomplete
21:05:40 <pastorn> accel: what features do you want?
21:05:54 <sproingie> could try the cairo bindings
21:06:28 <accel> i ahve some OpenGL rendering code
21:06:32 <accel> I want to render it in postscript
21:06:36 <accel> i.e. rasterized frames
21:06:40 <sproingie> tall order
21:06:42 <accel> just the outlines of the object + some basic shadings
21:06:48 <accel> in fact, if it's not postscript it's fine
21:06:52 <accel> it just needs to be vector graphics
21:07:00 <accel> and I'mnot familiar with vector outside of postscript
21:07:03 <sproingie> sounds like cairo is right up your alley
21:07:31 <accel> http://hackage.haskell.org/package/cairo-0.12.0 <-- is cairo also incomplete, or does haskell just like 0.?? numbering schemes?
21:07:47 <cdsmithus> Haskell people like 0.* versions
21:07:48 <accel> if, instead of 0.12.0, it was 12.0; I'd feel so much better
21:07:49 <kfr> accel it's customary to start out with 0.1
21:07:54 <sproingie> haskell folks tend to be very reticent about calling something stable
21:07:55 <kfr> After that it's totally random
21:08:01 <kfr> Haha yes
21:08:02 <accel> or even if it was 1.2
21:08:08 <accel> or anything > 1.0; I'd feel happy
21:08:13 <accel> so if haskell numbering starts with 0.1
21:08:20 <accel> I should take the haskell version number, multiply it by 10, then read it
21:08:26 <sproingie> the version number is merely a cultural thing that varies from developer to developer
21:08:31 * accel is running ghc 61.2
21:08:37 <cdsmithus> accel: maybe.  Unfortunately, there's no real standard
21:08:39 <accel> how's ghc 70.0 ?
21:08:57 <sproingie> some devs release their stuff as 0.1 and it's rock solid day 1
21:09:19 <sproingie> the common thread is that you can't rely on backward compatibility at all before 1.0
21:09:38 <sproingie> once things hit 1.0 then things in the 1.x series usually try to be compatible.  but it's also just convention
21:10:02 <cdsmithus> Really, though, you should be able to rely on compatibility within 0.x.*, for any given x
21:10:26 <Henno> quick question, (bit new to haskell), is there a way to check if a number is a square num? (i.e. sqrt returns a perfect integer)
21:10:38 <accel> hmm, so incremeneting by 1 is generally a _bad_ thing, i.e. it breaks compat
21:10:42 <cdsmithus> But there is the implication that the developer might change their mind any minute and release a 0.x+1 with a completely new interface.  However, 0.x will still be there
21:10:57 <sproingie> yah a 0.x.y version usually remains compatible for any y for the same x
21:11:02 <sproingie> that's also conventional
21:11:23 <sproingie> release engineering is something of an oral tradition
21:16:02 <pmatey> Hey team, I'm new to Haskell and am trying to write a simple Parsec lexer for Python. Does anybody know of resources (other than documentation) on how to handle indentation? Many thanks.
21:16:45 <ivanm> pmatey: use one that already exists?
21:17:01 <ivanm> @hackage language-python
21:17:02 <lambdabot> http://hackage.haskell.org/package/language-python
21:17:18 <ivanm> (though it doesn't use parsec)
21:18:27 <sproingie> python is difficult, since to parse it with your usual parsers, you have to lex DEDENT as a token
21:18:34 <sproingie> which is fairly tricky
21:19:02 <pmatey> ivanm: I saw that, but I didn't quite understand how it works. Basically I'm looking for examples of code using IndentParser.
21:19:13 <ivanm> what's IndentParser?
21:19:19 <ivanm> note: I've never used parsec before
21:19:25 <ivanm> polyparse ftw! ;-)
21:19:34 <ivanm> @hoogle IndentParser
21:19:35 <lambdabot> No results found
21:20:22 <pmatey> ivanm: http://hackage.haskell.org/packages/archive/IndentParser/0.2.1/doc/html/Text-ParserCombinators-Parsec-IndentParser.html
21:20:48 <ivanm> looks relatively straight-forward
21:21:47 <pmatey> ok, well I'll keep at it then. Thanks.
21:22:39 <duckinator> is there a module which comes with haskell by default that contains a string-padding function? (i'd prefer pad-center, but pad-right would be fine)
21:24:03 <c_wraith> duckinator: Text.Printf is in base, but that's a kind of terrifying option
21:24:56 <duckinator> c_wraith: indeed it is, i'd rather write my own than that. i just was wondering if there is probably something available rather simply, since this is solely for testing the rest of the module...
21:26:10 <ivanm> duckinator: possibly pretty
21:26:19 <ivanm> I think it does something like that
21:26:25 <ivanm> s/does/can do/
21:28:23 <adnap> can someone write a function the reverse the bytes of a hex number specified as a string (e.g "0x1a2d...")?
21:28:47 <ivanm> adnap: you mean convert the endianness or something?
21:28:50 <adnap> yes
21:29:10 <adnap> do you know a function offhand?
21:29:41 <ivanm> not offhand
21:29:58 <duckinator> if there's not a built-in one, if it's a string anyways: a string is a list of Chars, right? if so it should be a fairly trivial thing (you'd have to skip the 0x, of course)
21:30:07 <adnap> oh
21:30:26 <duckinator> well, by 'fairly trivial' i mean 'your brain probably wont explode'
21:30:41 <adnap> yeah, i know conceptually how to do it
21:30:42 <ddarius> concat . reverse . chunk 2 . drop 2
21:31:02 <duckinator> nice
21:31:04 <adnap> > concat . reverse . chunk 2 . drop 2 $ 0xabc
21:31:05 <lambdabot>   Not in scope: `chunk'
21:31:11 <Axman6> missing "0x"++
21:31:12 <ivanm> ddarius: pattern matching it would probably be easier/nicer
21:31:26 <duckinator> hm, indeed
21:31:43 <ddarius> ivanm: Mine works for arbitrarily large "numbers."
21:32:05 <adnap> is chunk in Data.ByteString?
21:32:07 <ivanm> ddarius: I mean pattern matching on the 0x
21:32:47 <ddarius> How would that be easier or nicer than drop 2 (other than it could give an error if the format is wrong, but there are a -lot- of other ways the format could be wrong.
21:32:49 <accel> holy crap, does laziness work ... when i'm reading a list from a file too?
21:32:51 <ivanm> dammit, I have a regression with my String -> Text conversion: I've got a memory leak somewhere or soemthing :s
21:33:00 <ivanm> accel: if you do it right, it can
21:33:05 <accel> i.e. instead of dealing with buffering and all that crap, i create a lazy list where elements are read from the file on demand
21:33:06 <ivanm> lazy I/O is usually a problem though
21:33:11 <accel> ivanm: why?
21:33:17 <duckinator> IO in haskell makes me sad :(
21:33:26 <ivanm> accel: weird stuff can happen, etc.
21:33:28 <duckinator> it's the one thing about haskell that i can't wrap my head around much at all
21:33:36 <accel> IO or monads?
21:33:44 <duckinator> err, both actually ^^
21:33:57 <ivanm> duckinator: don't consider IO as a monad
21:33:57 <duckinator> so s/one thing/two things/
21:33:58 <accel> if you change a file as an haskell program is reading it; do you screw up haskell ?
21:33:59 <ivanm> just learn IO
21:34:04 <ivanm> _then_ work out monads
21:34:17 <ivanm> accel: depends on what you're doing
21:34:19 <ivanm> same as in any language
21:34:22 <ddarius> Just learn types, then there should be no trouble with IO.
21:34:23 <adnap> how do you tell lamdabot to use a library?
21:34:30 <adnap> does it have any?
21:34:40 <ivanm> adnap: you can't
21:34:56 <sproingie> hack the lambdabot source :)
21:35:20 <duckinator> i prefer sproingie's answer ;)
21:35:22 <sproingie> lambdabot on freenode is set up to make sure you can't do sneaky i/o things with it
21:35:45 <edxs> hi, I am trying to install pcre-light from cabal but I keep getting error: pcre.h: No such file or directory.  I tried installing regex-pcre as well but get the same error.
21:35:45 <sproingie> if you have your own lambdabot this limitation is easily lifted
21:36:03 <djahandarie> ddarius, just learn category theory, then there should be no problem with arithmetic.
21:36:16 <duckinator> edxs: sounds like you need a the pcre C library. not positive, though.
21:36:20 <djahandarie> Or monads.
21:36:35 <ddarius> djahandarie: There will still be problems with arithmetic.
21:36:57 <adnap> i can't find the chunk function
21:37:06 <adnap> everything else is in Data.ByteString
21:37:20 <duckinator> adnap: i've been looking for that too, mostly out of boredom, and i can't find it either :P
21:37:32 <djahandarie> ddarius, US_1(C)?
21:37:54 <adnap> There's pack :: [Word8] -> ByteString
21:38:20 <edxs> duckinator: thanks, I'm installing it now.
21:38:51 <duckinator> edxs: for what it's worth, that was just a guess. sorry if it doesn't work :P
21:39:15 <ddarius> djahandarie: You are going to have to define your terms/notation.
21:39:44 <djahandarie> The category of pointed unary systems
21:40:19 <edxs> duckinator: haha, yeah it didn't work but it sounded right given the extension and the fact that both regex packages were failing on it.
21:40:20 <adnap> aw, it would be cool if google could do it
21:40:50 <drbean> Is \_ tje 
21:40:52 <ddarius> djahandarie: What's C?  And anyway I doubt that gives you a Euclidean domain and thus you'd fail to even be able to state the fundamental theorem of arithmetic.
21:41:19 <drbean> is \_ the same as ( (->) _ _ )
21:41:20 <ivanm> OK, how the hell do I track down where the stack space overflow is coming from? :s
21:42:30 <Axman6> drbean: no, -> is syntax, not a function
21:43:00 <accel> I don't understand why we need mondas to create serialization. If I have functions "f", and "g", and I want "g" to execute after "f", all I need is to write: f g <-- the output of g, being passed as an arugment to f -- this ensures taht g executes before f; what does monads provide?
21:43:22 <Axman6> accel: that's not ensured at all
21:43:28 <Axman6> > const undefined 1
21:43:30 <lambdabot>   *Exception: Prelude.undefined
21:43:35 <Axman6> > const 1 undefined
21:43:36 <lambdabot>   1
21:43:53 <Axman6> undefined is never evaluated in the second example
21:44:02 <accel> Axman6: why not?
21:44:08 <ivanm> accel: laziness, etc.
21:44:13 <Axman6> because this is how laziness works
21:44:24 <Axman6> things are only evaluated when their values are needed
21:44:27 <accel> oh, because it could be that neither f nor g ever execute?
21:44:38 <accel> so, if I had a function "drop"; which was 'a -> ()
21:44:42 <accel> then f ( drop g ); 
21:44:50 <accel> whould just result in "f", and 'g" would never get called?
21:44:55 <Axman6> yes
21:45:31 <accel> okay, so with moands, say I have g >>= drop >>= f
21:46:10 <accel> how does it change?
21:46:15 <accel> g returns a "m a"
21:46:18 <Axman6> well, that doesn't work given the types you have
21:46:33 * ddarius -again- recommends understanding types before most anything in Haskell.
21:46:35 <accel> Axman6: can you fix the types and make it work?
21:46:52 <ivanm> ddarius: and actually going through a tutorial before blindly guessing?
21:47:01 <ddarius> ivanm: Yes, that too.
21:47:18 <ddarius> ivanm: In fact, I generally advocate reading in the myriad of forms it may arise.
21:47:18 <accel> ouch
21:47:40 <accel> am i the only one who only leans
21:47:42 <accel> *learns*
21:47:43 <drbean> Trying it out as code too.
21:47:44 <accel> by reinvention?
21:47:53 * accel finds reading utterly passive
21:48:05 <ddarius> E.g. tutorials, documentation, books (technical and otherwise), the words someone is saying to you, papers, and so forth.
21:48:24 <ddarius> accel: Maybe you shouldn't passively read.
21:48:37 <ddarius> accel: Also, learning by reinvention would not require polling #haskell.
21:48:37 <Axman6> no, most of us do a lot of reinvention to understand things. but i don';t feel you understand the basics of haskell enough to understand what the questions you're asking really mean
21:48:40 <drbean> Typeclassopedia is great for that.
21:49:08 <accel> monads is just (>>=): (m a) -> (a -> (m b) ) -> mb
21:49:13 <accel> and return: a -> (m a)
21:49:19 <accel> i recited taht from memory
21:49:27 <accel> w/o googling, or even paper
21:49:38 <accel> now, how does these two definitions prevent laziness from happening?
21:49:44 <ddarius> accel: They don't.
21:49:53 <duckinator> accel: do you understand what that means? or just what it is?
21:49:59 <Axman6> all your querstions are obviously influenced by your strict and imperative background. you should make an effort to understand the basic concepts of haskell
21:50:12 <ddarius> Also, rote memorization is certainly not understanding.
21:50:20 <Axman6> accel: monads aren't about execution at all. they're much more abstract than that
21:50:34 <ivanm> accel: monads don't really have anything to do with laziness
21:50:59 <ddarius> ivanm: Where "don't really have anything to do" = "have absolutely nothing to do"
21:51:05 <Axman6> > take 10 $ do {x <- [1..]; y <- [1..]; return (x,y)}
21:51:06 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10)]
21:51:17 <ivanm> ddarius: right
21:51:19 <Axman6> > (do {x <- [1..]; y <- [1..]; return (x,y)}) !! 1000
21:51:21 <lambdabot>   (1,1001)
21:51:42 <Axman6> there are lazy monads, and there are more strict monads
21:52:07 <ddarius> Axman6: Give me a definition of when a monad is "lazy."
21:52:29 <Axman6> the list monad? maybe that's not a good description
21:52:31 <accel> > do { x <- [ 1..]; y <- [1..]; return (x, y) }
21:52:32 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12)...
21:52:38 <Axman6> its results are produced lazily
21:52:41 <ddarius> Axman6: An example is not a definition.
21:52:55 <accel> wtf, why is the above not ([1...], [1...]) ?
21:52:58 <Axman6> hey, don't fight me, educate accel 
21:53:04 <accel> yeah, i'm the idiot here
21:53:17 <accel> > ([1..], [1..])
21:53:18 <lambdabot>   ([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
21:53:32 <accel> > let x=[1..], y=[1..] in (x, y)
21:53:33 <lambdabot>   <no location info>: parse error on input `,'
21:53:37 <accel> > let x=[1..]; y=[1..] in (x, y)
21:53:38 <lambdabot>   ([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
21:53:42 * duckinator prods accel with `ghci`
21:53:53 <Axman6> they are not equivalent things
21:53:56 <accel> why not?
21:54:03 <accel> duckinator: the point is so Axman6 can see my confusion and respond
21:54:08 <Axman6> becasue that's not how the list monad is defined
21:54:20 <Axman6> @src [] (>>=)
21:54:20 <lambdabot> xs >>= f     = concatMap f xs
21:54:26 <ddarius> Axman6: Educating accel is not a goal of mine, nor is fighting you.  However, there is no real meaning to "lazy monad" or "strict monad."
21:54:42 <Axman6> ddarius: ok, fine, correct me rather than grilling me :\
21:54:46 <Axman6> that's not helpful
21:55:24 <accel> Axman6: can we walk though this do example with list moand?
21:55:27 <ddarius> Axman6: What if you had a definition?  Should I just assume you are wrong rather than let you clarify what you meant.
21:55:33 <accel> first of all, how does it know the "return" wants to use the do monad?
21:55:54 <Axman6> do monad?
21:55:58 <Axman6> we're using the list monad
21:55:59 <accel> err, the list monad
21:56:00 <ivanm> accel: return is a monad method
21:56:01 <c_wraith> I know it's not formal, but I think of a Monad as lazy if (>>=) is not strict in its first argument.
21:56:12 <ivanm> type inference, strong static typing, etc.
21:56:14 <accel> yesh, how does the "return (x,y)" knows "Axman6 wants to use the list moand" ?
21:56:17 <ivanm> c_wraith: hmmm...
21:56:21 <ivanm> accel: type inference
21:56:21 <accel> so it executes that block of code,
21:56:23 <c_wraith> in which case, the list monad is not lazy
21:56:24 <accel> it sees x = list of int
21:56:25 <accel> y = list of int
21:56:34 <accel> (,) = pair of list of int
21:56:40 <accel> but why does that make return say "gee, I want to use the list monad"
21:56:44 <ddarius> c_wraith: That's a perfectly formal definition with "lazy" replaced with "non-strict."
21:56:49 <ivanm> accel: because the <- is in the list monad
21:56:59 <c_wraith> ddarius: yes, I was being... umm..  lazy.  :)
21:57:01 <djahandarie> accel, <- is not =
21:57:05 <Axman6> accel: (do {x <- [1..]; y <- [1..]; return (x,y)} desugars to [1..] >>= \x -> [1..] >>= \y -> return (x,y)
21:57:11 <djahandarie> accel, x there is an Int, not a [Int]
21:57:21 <Axman6> > [1..] >>= \x -> [1..] >>= \y -> return (x,y)
21:57:22 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12)...
21:57:30 * accel feels enlightened
21:57:38 <Axman6> which in turn, basec on the definition of >>= for lists, becomes:
21:57:53 <accel> @src [] (>>=)
21:57:53 <lambdabot> xs >>= f     = concatMap f xs
21:58:01 <c_wraith> ddarius: also, I meant that's not the accepted definition, really.  Though it is often used that way informally.  Comparing the strict and non-strict identity monads, for instance
21:58:12 <Axman6> > concatMap (\x -> concatMap (y -> return (x,y) [1..10]) [1..]
21:58:13 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
21:58:18 <Axman6> > concatMap (\x -> concatMap (y -> return (x,y)) [1..10]) [1..]
21:58:19 <lambdabot>   Pattern syntax in expression context: y -> return (x, y)
21:58:25 <Axman6> > concatMap (\x -> concatMap (\y -> return (x,y)) [1..10]) [1..]
21:58:26 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,1),(2,2),(...
21:58:37 <c_wraith> > runIdentity $ undefined >> return 5
21:58:39 <lambdabot>   5
21:58:43 <accel> Axman6: cool; thanks
21:58:55 <ddarius> c_wraith: My point is more that there isn't an accepted definition because the terms usually refer to some arbitrary detail of the semantics of particular examples, e.g. the non-strict and strict State monads.
21:59:33 <ddarius> You can certainly give -some- formal definition, such as the one you gave, but it probably won't capture things quite right.
21:59:35 <c_wraith> operationally, that is the difference between the two variants of State, though
21:59:45 <Axman6> accel: read do { x <- xs...} as for each x in xs
22:00:29 <ion> or “drawing x from xs…”
22:00:54 <ion> fits a larger number of monads better.
22:01:03 <Axman6> yeah
22:01:14 <ddarius> c_wraith: What is?
22:01:15 <Axman6> i just meant in the list case
22:01:34 <ion> ah
22:01:48 <ion> (missed the discussion)
22:01:50 <c_wraith> ddarius: whether the pattern match on the first argument of (>>=) is refutable or not
22:01:50 <accel> Axman6: you should write a book on haskell for beginners; I would pirate it
22:02:00 * hackagebot filestore 0.4.0.3 - Interface for versioning file stores.  http://hackage.haskell.org/package/filestore-0.4.0.3 (JohnMacFarlane)
22:02:14 <Axman6> i'd be moreible ar writing a book on haskell for beginners
22:02:16 <djahandarie> accel, and then read it passively?
22:02:20 <Axman6> horrible even
22:02:32 <accel> djahandarie: I said nothing about reading it; just I would bother downloading it
22:02:32 <Axman6> moreible? that's totally a word
22:02:42 <accel> djahandarie: don't set such high standards
22:02:59 <accel> but seriously; someone needs to write a "haskell by example"
22:03:01 * hackagebot gitit 0.7.3.11 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.7.3.11 (JohnMacFarlane)
22:03:04 <accel> ratehr than these existing haskell texts
22:03:18 <ddarius> c_wraith: Certainly not.  The only way that could be for State is if it was defined to seq the first argument.  The difference between strict and non-strict State have to do with an internal detail.  Both satisfy _|_ >>= k = \s -> ...
22:04:20 <ddarius> c_wraith: Another possible definition of "strict monad" is whether there exists a term, t, such that t >>= k = t
22:06:36 <ddarius> (And this would imply that _|_ >>= k = _|_ except [perhaps] in the trivial case.
22:06:37 <ddarius> )
22:06:40 <c_wraith> That would make anything in MonadPlus strict?  How does the term strict get chosen for that?
22:07:33 <ddarius> c_wraith: It means that we can't execute further "statements" without first executing earlier ones, but I agree, it's just as unsatisfying as most definitions.
22:08:27 <ddarius> But it is probably (a potential formalization of) what people mean by IO being "strict."
22:10:02 * ddarius didn't realize accel's notion of reading was quite so passive.
22:10:47 <ddarius> @google "Haskell by example"
22:10:50 <lambdabot> http://learninghaskellbyexample.blogspot.com/
22:10:50 <lambdabot> Title: Learning Haskell By Example
22:10:56 <ivanm> heh
22:11:09 <ivanm> define "haskell by example"
22:11:19 <ivanm> pretty sure most of them have you do stuff whilst you learn Haskell
22:11:24 <ivanm> SoE comes to mind in particular
22:11:34 <Axman6> adnap: what do you thing LYAH is? it's all examples...
22:12:01 <kfr> LYAH is a highly academic mathematical text which comes with little to no examples
22:12:09 <kfr> You can tell by the "GAYBALLS" theorem
22:12:10 <Axman6> this is true
22:12:40 <Axman6> the more elepant comics you have, the more academic it is?
22:12:41 <ddarius> Axman6: As is tryhaskell and, arguably, the Gentle Introduction (and probably RWH, SoE, etc.)
22:12:52 <ddarius> @google sketches of an elephant
22:12:54 <lambdabot> http://www.amazon.com/Sketches-Elephant-Theory-Compendium-Oxford/dp/019852496X
22:12:59 <Axman6> yeah, we need a good tutorial for haskell. 
22:13:24 <djahandarie> LOL ddarius...
22:13:29 <ddarius> Ah, category theory.  I can use you for anything.
22:13:33 <Axman6> ddarius: ... ha!
22:13:40 <ivanm> Axman6: agreed, LYAH sucks
22:13:41 <ivanm> :p
22:14:03 <Axman6> it's just too formal!
22:14:11 * ddarius wouldn't actually mind having Sketches of an Elephant, but he wouldn't pay $410.00 for it, let alone $602.98 used.
22:14:27 <copumpkin> wow
22:14:40 <ivanm> Axman6: other way round actually
22:14:41 * ddarius also thinks it's ultimately supposed to be a 4 or 6 volume set.
22:15:24 <Cale> 1284 pages
22:15:26 <Axman6> kfr: i'm unfamilliar with the GAYBALLS theorum, could you enlighten me?
22:16:59 <pastorn> is that a category theory book?
22:17:18 <pastorn> i've never heard of "topos theory" before
22:17:28 <kfr> Axman6 http://learnyouahaskell.com/higher-order-functions
22:17:36 <kfr> # ghci> filter (`elem` ['A'..'Z']) "i lauGh At You BecAuse u r aLL the Same"  
22:17:36 <kfr> # "GAYBALLS"  
22:17:51 <kfr> It's a mathematical text full of homophobic remarks
22:17:58 * kfr frowns upon BONUS
22:18:00 <copumpkin> pastorn: it's a certain kind of category
22:18:02 <copumpkin> (a topos)
22:18:08 * ddarius likes how the reviewer is Colin McLarty.
22:18:50 <ddarius> Though that is only natural.
22:20:09 * ddarius refers kfr to the isUpper function.
22:20:22 <ddarius> Although Unicode input could foil him.
22:20:51 <kfr> ddarius: Why are you referring me to that function?
22:21:01 <kfr> This is from LYAH, I did not code any of that
22:22:04 <pastorn> > filter (`elem` ['A'..'Z']) "i lauGh At You BecAuse u r aLL the Same"
22:22:05 <lambdabot>   "GAYBALLS"
22:24:47 <lewis1711> haha, is that actually in LYAH?
22:24:47 <lewis1711> awesome
22:27:30 <ion> > filter (liftM2 (||) isUpper (==' ')) "sUpeR MaRio GalAxY" -- http://www.megatonnews.com/wp-content/uploads/2007/09/super-mario-galaxy-urmrgay.jpg
22:27:31 <lambdabot>   "UR MR GAY"
22:27:48 <kfr> ...
22:27:59 <pastorn> ion: :D
22:28:07 <pastorn> too bad the changed that for #2
22:28:16 <kfr> Thanks to BONUS, homophobia is now rampant in the Haskell community
22:34:44 * ddarius considers making a somewhat less insane introduction to fibrations.
22:34:58 <djahandarie> ddarius, put it on your blog!
22:35:18 <ddarius> djahandarie: It's already on every blog of mine.
22:35:35 <kfr> Is lifting a term from category theory?
22:35:47 <ddarius> I wouldn't say so.
22:35:56 <kfr> http://en.wikipedia.org/wiki/Homotopy_lifting_property
22:36:00 <kfr> From http://en.wikipedia.org/wiki/Fibration
22:36:02 <ddarius> Though it's a very common term for a variety of different properties.
22:36:19 <kfr> algebraic topology
22:36:21 * kfr shrugs
22:38:47 <ddarius> At any rate, the categorical notion of fibration generalizes the homotopical one.
22:40:33 <Cale> If you want to learn lots of category theory, eventually you'll probably want to learn at least a bit of algebraic topology.
22:41:16 <kfr> I was told that really grasping category theory is a futile task without learning about its applications in topology
22:41:36 <Cale> I'm not sure I'd go that far, but it certainly helps.
22:41:51 <ddarius> Nowadays category theory has many applications in fields far removed (superficially) from category theory.
22:42:23 <ddarius> That said, there is a strange brand of category theory that lives on mostly in algebraic topology.
22:43:23 <ddarius> Incidentally, Cale's statement can be strengthened to have the weaker antecedent, "if you want to learn lots of <some field of math>"
22:43:39 <ddarius> Well, perhaps with "algebraic topology" reduced to just "topology."
22:55:47 <adnap> doesn't Data.ByteString.reverse essentially change the endianness?
23:00:13 <kfr> Uhm can you make this any shorter or does it look broken in some way? lift . void . forkIO . void $ outerRunner
23:26:00 <ivanm> @type foldl'
23:26:01 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
23:28:32 <Guest75190> hi there
23:29:02 <Cale> hi
23:29:11 <Guest75190> I'm learning haskell, and i'm trying to resolve a bug that I can't explain, can anyone help me understand http://codepad.org/B752Id8m
23:29:54 <ivanm> Guest75190: give a type sig to main
23:30:03 <Axman6> Guest75190: printf takes a string, and needs at least one argument in this case
23:30:21 <Axman6> oh wait, it does have two
23:30:25 <Guest75190> isn't it taking two arguments?
23:30:28 <Cale> Guest75190: The problem is that printf is really polymorphic
23:30:36 <Guest75190> yeah.  this works in ghci
23:30:46 <Axman6> Guest75190: just ass main :: IO () above that line
23:30:48 <Zao> Curse you, MR!
23:31:37 <Guest75190> http://codepad.org/F5Jw36tx ok that worked.  what was that error exactly?
23:32:29 <Cale> I'm pretty sure it was complaining that it couldn't work out what implementation of printf you wanted, because it depends on the type which you demand of it.
23:32:37 <ivanm> Cale: yeah
23:32:38 <Cale> > printf "%s\n" "hello world" :: String
23:32:39 <lambdabot>   "hello world\n"
23:32:43 <ivanm> Guest75190: I think if you actually compiled it it wouldn't have been a problem
23:32:49 <Cale> ^^ see, printf is *really* polymorphic :)
23:32:57 <ivanm> or are there multiple IO-based instances?
23:33:01 <ivanm> @instances PrintF
23:33:01 <lambdabot> Couldn't find class `PrintF'. Try @instances-importing
23:33:02 <Axman6> Guest75190: the error is that you're using hugs, and that you're using printf before you can understand it :P
23:33:07 <ivanm> @type printf
23:33:09 <lambdabot> forall r. (PrintfType r) => String -> r
23:33:10 <Zao> @type [print "lol", printf "%s" "lol"]
23:33:11 <lambdabot> [IO ()]
23:33:43 <Zao> @type [return "huhu", printf "%s" "lol"]
23:33:44 <lambdabot> forall (m :: * -> *). (Monad m, PrintfType (m [Char])) => [m [Char]]
23:33:50 <Guest75190> Axman6: I'm sure I don't!  I wanted to do some formatted output, and figured that would be the best way
23:37:04 <Axman6> Guest75190: hugs is generally not used these days
23:37:24 <Guest75190> yeah, i'm using ghc
23:37:37 <Guest75190> i was just experimenting with codepad for turning in assignments
23:43:26 <Guest75190> well thanks for your help everyone!
23:59:34 <kfr> Whenever I use the bind operator manually I feel like a total overlord. Primarily because it took me weeks to get there.
