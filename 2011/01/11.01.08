00:00:00 <ddarius> edwardk: Last I checked, GHC already had a scheduler.
00:00:04 <edwardk> basically i have a monad for reasonably fine grained workstealing named Task, and then i provide higher level constructs that look a bit like the .net reactive framework
00:01:21 <edwardk> data Observer a = Observer { next :: a -> Task (), handle :: SomeException -> Task (), break :: Task () }; newtype Observable a = Observable { subscribe :: Observer a -> Task Subscription }; newtype Subscription = Subscription { cancel :: Task () }
00:01:28 <edwardk> with a monad for Observable
00:02:46 <edwardk> mostly just seeing how it plays out before i go any deeper
00:03:59 <edwardk> it may be that the RTS kind of subsumes any benefit from this stuff
00:04:29 <edwardk> but i doubt it, because i can't fragment tasks that are in the RTS upon stealing them ;)
00:04:32 <ddarius> I wonder if Reppy's CML stuff would make sense in this context as well.
00:05:22 <edwardk> basically i was building more or less this same thing over in scala — as a sort of bastard child of .net reactive framework, tbb and scala actors
00:05:36 <edwardk> so i felt i should try it out over here, where it can be a lot less code in some areas
00:05:54 <ddarius> edwardk: Apparently that's the in thing to do.
00:06:01 <EliasAmaral> maurer_, i'm thinking. what i would do is: get some comment mark before each function in your set of special functions, get a checksum of your source codes, and make a script to build a resolve-symbol.hs with a map of "function_name" -> function_name, and this checksum. then you need to run this script every time before you compile
00:06:42 <EliasAmaral> the other end needs the source code and this script too, but mostly to know the checksum (you would hardcode the strings in the other end. i think)
00:07:03 <EliasAmaral> or you don't build this checksum thing at all, i don't know if this is useful
00:07:26 <Mitar> how could I fix this: http://hpaste.org/42855/dependencies
00:07:45 <maurer_> EliasAmaral: Thanks for the suggestion, but I think I'm just going to enumerate.
00:07:50 <edwardk> anyways i was deliberately avoiding a CML-like api to start, because i tend to find that synchronous channels are an awkward primitive
00:08:10 <EliasAmaral> maurer_, how do you enumerate functions?
00:08:16 <edwardk> i much prefer living in a world with non-blocking send, like singularity
00:08:32 <ksf_> what do you guys think of a diaspora implementation in haskell?
00:08:33 <EliasAmaral> edwardk, singularity from microsoft research?
00:08:33 <edwardk> but i don't have uniqueness types to enforce channel protocols here
00:08:40 <edwardk> EliasAmaral: yeah
00:08:56 <EliasAmaral> edwardk, why CML-like can't have non-blocking send?
00:09:05 <ddarius> edwardk: I'm just talking about the event type and the higher-order concurrency aspects.  Channels are orthogonal to that.
00:09:20 <EliasAmaral> and how singularity has uniqueness types? it is implemented in C#
00:09:24 <edwardk> ddarius: *nods*
00:09:38 <edwardk> EliasAmaral: the channel protocols are written in spec#, which has theorem proving applied
00:10:14 <EliasAmaral> o.o''
00:10:57 <edwardk> EliasAmaral: open channels can either have a potentially unbounded mailbox or synchronous use, both suck for different reasons ;)
00:11:04 <gienah> Mitar: maybe find a ghc 7.0.1 package prepared for you operating system, rather than trying to cabal install it ?
00:11:16 <Mitar> i used one
00:11:23 <Mitar> from the web site
00:11:25 <Mitar> official
00:11:32 <gienah> Mitar: which operating system?
00:11:38 <Mitar> mac os x
00:11:49 <edwardk> the former forces you into erlang voodoo-land where you set up crazy amounts of redundancy and ability to recover when the system inevitably fails, the latter tends to lead you towards deadlock and blocked processes ;)
00:11:49 <Mitar> and then i bootstraped cabal-install
00:11:56 <Mitar> and now when i want to install darcs
00:11:56 <EliasAmaral> edwardk, you mean, if you permit non-blocking send the reading queue might get too big? (but then, how would uniqueness types prevent that?)
00:12:09 <Mitar> it installs some additional process library which shadows things and breaks everything
00:12:49 <EliasAmaral> if you have a sender that has both guarantees that the message won't be discarded, and is sending in a non-blocking fashion, you can't prevent the queue to get arbitrarily large
00:12:52 <edwardk> EliasAmaral: the singularity model makes it so that you only have a single owner for each channel end point, channels are bidirectional, between two parties. you can send a channel over a channel but you relinquish ownership.
00:13:01 <edwardk> the key is in the protocol
00:13:03 <maurer_> EliasAmaral: As both programs are the same, during the initialization time, I am going to run "uniqueHandle <- registerFunc foo"
00:13:04 <gienah> Mitar: I don't know anything about Macos X, however I think someone was helpfully trying to create a haskell platform package for Macos X for ghc 7.0.1, I'm not sure of the status
00:13:10 <maurer_> Where uniqueHandle is just an ascending number.
00:13:15 <edwardk> sending a message over a channel changes its state in a finite state machine
00:13:19 <maurer_> Then I just send the number, and I can look it up.
00:13:27 <edwardk> every cycle in that finite state machine is required to have both sent and received messages
00:13:29 <gienah> Mitar: maybe check the haskell platform mailing list archives
00:13:35 <EliasAmaral> maurer_, registerFunc? hm
00:13:46 <edwardk> and therefore you can concoct an implementation of the buffer that takes a bounded amount of space as long as both parties obey the protocol
00:14:03 <edwardk> and you have a theorem prover that checks that the code complies with the protocol
00:14:24 <edwardk> and a consistency guarantee provided by milner before he passed away that says that this is sufficient to avoid deadlock
00:15:01 <EliasAmaral> edwardk, so it is asynchronous but if A sent too much messages to B, A might get blocked for a time?
00:15:28 <edwardk> it becomes trickier to do things like implement broadcast channels, etc. but you can basically send n messages in exchange for one write barrier, and you never block on writes
00:15:32 <maurer_> EliasAmaral: I was going to make a stateful function with a private counter and a table. One moment while I mock up the interface in hpaste
00:15:57 <edwardk> technically writing will never block you, but you may run out of channels that you are able to send over because their protocols will all eventually find their way into a receive state ;)
00:16:32 <edwardk> so the only time you have to deal with error handling is at receive sites
00:17:12 <gienah> Mitar: yes it seems confused with installing process-1.0.1.4 when it was already installed, process 1.0.1.4 is a ghc core library and should not be re-installed
00:18:08 <EliasAmaral> edwardk, but if I want to write 1TB of stuff, I begin this and.. will go non-stop? how can the algorithm prevent holding this 1TB at memory until the other side feels like reading?
00:18:12 <Mitar> but why does it try to install it?
00:18:48 <EliasAmaral> you mean that when i write too much, the channel becomes read-only in the type system, so a program that writes too much will not compile?
00:18:55 <edwardk> it can't. your channels however can reference blocks of memory that it is allowed to consign ownership to the other process though
00:19:45 <maurer_> EliasAmaral: http://hpaste.org/42856/registerfunc
00:19:56 <ddarius> EliasAmaral: Your second question is closer to the situation in the sense I think you are interested in.
00:20:15 <maurer_> Then I only export those two functions from the module.
00:20:22 <edwardk> its just the nature of the protocols. you can set up a protocol that says you start in state A, then send a 'getIPAddress?' message transitioning to state B , then when you receive a gotIPAddress! message you transition back to State A, but you can juggle many many channels
00:20:35 <gienah> Mitar: good question.  There is a system cabal package directory, and a user cabal package directory, I wonder if some of these core libs have been installed in system, and some in user?
00:20:46 <maurer_> EliasAmaral: The one thing I'm worried about is that casting it might fuck up the storage class.
00:21:57 <maurer_> Err, there should be IOs in the type signatures.
00:22:39 <lars9> in ghci, how to measure runing time?
00:22:56 <lars9> like in bash: time ./myfunc
00:23:12 <EliasAmaral> ddarius, you mean quoting "Work-stealing is a popular technique for implementing load balancing, where each parallel thread maintains its own work set of items and occasionally steals items from the sets of other threads."? yes that was copied from a paper :P I think I was confused with "Uses more quotation marks" that should be "Use more quotation marks"
00:23:46 <ddarius> EliasAmaral: Hence the "-s" I said immediately after it.
00:23:58 <EliasAmaral> edwardk, I read what you said multiple times. so the magic lies in the type system enforcing constraints
00:24:18 <edwardk> yeah
00:25:07 <edwardk> the main benefit is that if everyone productively obeys their protocols, the system won't deadlock due to the messages moving around in it
00:25:14 <EliasAmaral> I read something about how the type system can prevent one to write to a read-only file: just use a phantom type to mark it. so you instead of having just the file type, you have the file type for reading, for writing, and one that can act as both
00:25:44 <EliasAmaral> those tricks often confuse me because i'm used to very simpler types
00:25:47 <gienah> Mitar: I don't know how to manage the cabal user packages.  I only know how to avoid it by creating system packages: hack the .cabal files to avoid installing conflicting packages, and then fix the breakages by hacking the haskell source code in the packages.
00:26:10 <ddarius> Or you could have the openForReading function simply return something that doesn't supply a "write" operation.
00:26:12 <edwardk> elias: sok, you'll pick em up. =)
00:26:27 <EliasAmaral> edwardk, like if the types encoded a petri net?
00:27:55 <EliasAmaral> @.@ petri nets will move little tags like a state machine after each message sent, or after each fork / join. am i making the wrong picture of "preventing deadlocks"?
00:27:56 <lambdabot> Maybe you meant: . @
00:28:20 <edwardk> pretty much
00:29:01 <edwardk> data keeps moving
00:29:27 <edwardk> anyways, i have no such ability to provide such a system here ;)
00:29:31 <ddarius> Deadlock is dead, long live livelock.
00:29:35 <edwardk> hahaha
00:29:41 <EliasAmaral> <edwardk> sending a message over a channel changes its state in a finite state machine < so it isn't like a petri net at all?
00:29:51 <edwardk> sends the state of the channel
00:29:55 <gio123> is here anybody familier about CLP?
00:29:59 <edwardk> er changes the state of the channel
00:30:22 <edwardk> each channel has an associated state machine, the programs on either end of the channel can be very rich things, but the protocols on the channels are pretty dumb
00:34:21 <EliasAmaral> edwardk, do you have some link on this? or, what is the name of this protocol? i was thinking in how you prevent deadlock by making each message change the state of the protocol (i know that a certain class of petri nets has no deadlock)
00:34:46 <lars9> whats the result of this cmd in your bash? time for i in `seq 1 2000`; do echo -n a; done; echo -n c | grep -cE "(a?){1000}a{1000}" 
00:35:35 <edwardk> EliasAmaral: you might start from http://weblogs.asp.net/podwysocki/archive/2008/03/11/singularity-c-os-released-on-codeplex.aspx
00:37:03 <gio123> is here anybody familier about CLP?
00:37:55 <EliasAmaral> gio123, CLP here is what is PLC in english, or programmable logic controller
00:38:30 <edwardk> EliasAmaral: most of the links i had have rotted, like all things microsoft
00:42:15 <EliasAmaral> i feel bad that such cool FP stuff - even with ambition of having an entire OS with verified software - is being doing mostly with proprietary software. I felt bad when jonathan shapiro from coyotos went to work there. it felt like microsoft wanted to co-opt all research in verified operating systems. and I somehow hope this will be the future of computing, so I get worried (He then said that most C# code he saw there weren't very good to loo
00:42:15 <EliasAmaral> k at..)
00:42:59 <edwardk> well, he and microsoft weren't exactly on the same page, so he's back out hacking on coyotos and what have you in his spare time again
00:43:04 <Sunhay_> ?wiki Monad
00:43:04 <lambdabot> http://www.haskell.org/haskellwiki/Monad
00:46:30 <Sunhay_> @version
00:46:30 <EliasAmaral> I would like to work in this area, of verified software, verified protocols and such. But I don't know much about this aspect of programming (or any other; and, most of all, I lack knowledge on logic)
00:46:31 <lambdabot> lambdabot 4.2.2.1
00:46:31 <lambdabot> darcs get http://code.haskell.org/lambdabot
00:47:42 <EliasAmaral> I think I need to work with some theorem prover on my own. Coq seemed too intimidating. Maybe I should try Agda. (So much things to learn, so little things actually done)
00:47:56 <edwardk> agda is good for learning
00:48:01 <j-invariant> EliasAmaral: why intimidating?
00:48:19 <edwardk> when you write a proof in coq you're sure the compiler knows what you are talking about. when you write one in agda you are sure you know what you are talking about ;)
00:48:26 <j-invariant> lol
00:48:52 <j-invariant> Agda is basicalyl haskell GADTs ... taking too far
00:49:35 <EliasAmaral> oh. i read some things on it. i found it inaccessible to me, but maybe I needed to gather more xp at haskell and so on?
00:50:02 <EliasAmaral> but don't take me wrong, I don't understand most of haskell either
00:51:11 <EliasAmaral> a professor here works with isabelle. pretty intimidating too
00:53:58 <EliasAmaral> gio123, http://www.info.ucl.ac.be/~pvr/book.html i think this book has something on constraint logic programming. (it has a lot of things on a lot of paradigms)
00:55:37 <EliasAmaral> if I could focus on something, I would be studying Oz and all those programming techniques, with that book (but don't get me wrong. I'm not really studying haskell either. I'm too lazy for that)
00:59:21 * ksf_ only ever looked at ctm for inspiration
00:59:56 <EliasAmaral> "The chart classifies programming paradigms according to their kernel languages. Kernel languages are ordered according to the creative extension principle: a new concept is added when it cannot be encoded with only local transformations."
01:00:36 <EliasAmaral> and before "A programming paradigm is a style of programming a computer that is defined by a specific set of programming concepts and techniques, as embodied by its kernel language, the small core language in which all the paradigm's abstractions can be defined. A multiparadigm language allows programming in each of many paradigms without interference from the others. Multiparadigm programming is a natural approach to programming: it allows t
01:00:36 <EliasAmaral> o use the concepts necessary for a program without being encumbered by unnecessary concepts."
01:00:54 <EliasAmaral> not actually the book but i like those views
01:01:45 <EliasAmaral> also the analogy of teaching imperative programming, OO programming, functional programming, etc. as separated subjects with teaching iron bridge building, wood bridge building, etc as separated subjects
01:02:08 <EliasAmaral> the right bridge might have both iron and wood
01:02:29 <j-invariant> good point
01:05:53 <EliasAmaral> http://c2.com/cgi/wiki?ConceptsTechniquesAndModelsOfComputerProgramming
01:09:05 <EliasAmaral> "I've noticed that the positive reviews (like those of most challenging literature, such as JamesJoyce) come primarily from those who studied the text on their own, while most of the negative reviews come from those who either taught or were taught with it."
01:09:58 <EliasAmaral> on a review about SICP. and yes, I tried to push sicp for a lot of people that is doing computer science but doesn't seem very motivated for programming on their own (or even otherwise enjoy it). they haven't liked it at all
01:11:16 <lpsmith> Well,  just a quick hypothesis,  but if you study a text on your own,  and don't like it,  are you going to hate it?
01:11:35 <lpsmith> Maybe you'd be less likely to give it a review at all.
01:11:56 <lpsmith> Whereas if you are forced to study something,  maybe you are more likely to give a review one way or the other
01:14:05 <lpsmith> I hated Pascal before I'd ever read SICP,  basically,  because I couldn't do chapter 2 in pascal to my satisfaction.
01:14:28 <EliasAmaral> chapter 2?
01:14:35 <lpsmith> Chapter 2 of SICP
01:15:08 <lpsmith> Building abstractions with data
01:15:09 <EliasAmaral> point is, if the classroom is very diversified, the professor has to dumb the subject down, or hm, progress more slowly
01:15:20 <EliasAmaral> oh, closures
01:15:29 <EliasAmaral> pascal can't return closures
01:15:40 <lpsmith> no
01:15:53 <lpsmith> I couldn't return records.  I would've been happy with records :)
01:16:17 <lpsmith> I was trying to implement rational and matrix arithmetic in Pascal,  and  couldn't do it very well because of that.
01:16:33 <rumbold1> strange, when i use this code in ghci, it does exacly what i want, but when i use it in my program, it seems to go back to 0 over 255, as if i was using modulo: red = min 255 $ round dist*10
01:17:06 <lpsmith> what's dist?
01:17:23 <rumbold1> some float
01:17:44 <Saizan> maybe you want round (dist*10) ?
01:17:47 <rumbold1> its the distance a ray has to travel to hit a point on a sphere actually
01:17:58 <EliasAmaral> can a float and a int be multiplied?
01:18:08 <EliasAmaral> oh, 10 would be float then
01:18:13 <lpsmith> right
01:18:46 <EliasAmaral> > let f x = x + 1 in f 10 * 10
01:18:47 <lambdabot>   110
01:19:05 <luite> but the problem is not with the type of dist, but the type of red itself
01:19:09 <EliasAmaral> a b * c is (a b) * c o.O
01:19:28 <rumbold1> the type of red?
01:19:36 <Saizan> sure, function application has higher precedence than any operator
01:19:41 <Saizan> so:
01:19:44 <EliasAmaral> but hmm i shouldn't be surprised maybe
01:19:47 <Saizan> > round 0.1 * 10
01:19:48 <lambdabot>   0
01:19:55 <Saizan> > round (0.1 * 10)
01:19:55 <lambdabot>   1
01:19:59 <lpsmith> rumbold1, are you sure that "round dist" isn't zero?
01:20:33 <rumbold1> okay, the missing parantheses were an error, but the resulting picture still looks exactly the same ;)
01:20:49 <luite> rumbold1: yeah, it's probably caused by some overflow. if you evaluate that expression in ghci, it will probably default to Integer, which means that both 255 and (round dist*10) are also of type Integer
01:20:50 <EliasAmaral> @src min
01:20:51 <lambdabot> min x y = if x <= y then x else y
01:21:43 <rumbold1> hmm, red gets put into a list of word8 (a type thats included in the imagelib im using)
01:21:44 <luite> rumbold1: however, if the result is Word8 for example, then 255 and (round dist*10) will both be a Word8
01:21:50 <rumbold1> but 255 should fit
01:22:15 <EliasAmaral> yes, so you should have evaluated with a :: Word8 on it
01:22:28 <EliasAmaral> (at ghci)
01:22:29 <luite> rumbold1: yes 255 fits, but it doesn't make sense to use min with the maximum value that fits in a Word8
01:22:39 <Saizan> rumbold1: yeah but * for Word8 is exactly like using arithmetic modulo 256
01:22:42 <rumbold1> that doesnt work cause the library doesnt work in ghci
01:23:38 <rumbold1> i dont understand :(
01:23:54 <Saizan> > 50 * 100 :: Word8
01:23:54 <lambdabot>   136
01:24:02 <Saizan> > 50 * 100 :: Integer
01:24:03 <lambdabot>   5000
01:24:20 <Saizan> > min 255 (50 * 100) :: Integer
01:24:21 <lambdabot>   255
01:24:26 <Saizan> > min 255 (50 * 100) :: Word8
01:24:27 <lambdabot>   136
01:24:30 <rumbold1> so the round (dist*10) becomes a word8 before it even gets to the min
01:24:38 <rumbold1> but how do i prevent that?
01:24:45 <luite> rumbold1: yes, it is forced to be of the same type as red
01:24:48 <luite> by the type of min
01:24:50 <luite> @type min
01:24:51 <lambdabot> forall a. (Ord a) => a -> a -> a
01:25:06 <Saizan> with fromIntegral 
01:26:05 <Saizan> red = fromIntegral $ min ...
01:26:09 <rumbold1> okay, red = fromIntegral $ min 255 $ round (dist*10) works, thanks
01:26:25 <rumbold1> ill have to think about that now ;)
01:26:57 <pacak> When i am loading a file into ghci via :load or via command line argument - it loads perfectly (and works), but when i am loading it once more, right after that - it complains about overlapping monad instances in mtl/monads-tf.
01:26:59 <Saizan> fromIntegral there gets used at the type Integer -> Word8
01:27:03 <pacak> Is it supposed to do that?
02:00:59 <mm_freak_> Quadrescence: huh?
02:01:12 <mm_freak_> no, but state monads and a parser monad =)
02:07:10 * hackagebot asn1-data 0.4.1 - ASN1 data reader and writer in RAW, BER, DER and CER forms  http://hackage.haskell.org/package/asn1-data-0.4.1 (VincentHanquez)
02:31:44 <Veinor> do computable bijections have computable inverses?
02:32:26 <Veinor> hm, yeah they do. just try each value.
02:54:34 <dabblego> hey edwardk 
02:54:38 <dabblego> thanks for the video mate :)
02:54:42 <edwardk> yo
02:54:46 <edwardk> how did it turn out?
02:54:52 <dabblego> haven't watched it yet 
02:54:53 <edwardk> i didn't get a chance to see it
02:54:56 <dabblego> http://www.vimeo.com/18554216
02:55:29 <edwardk> hrmm vimeo changed my aspect ratio so it clipped the top of the screen
02:56:36 <dabblego> oddballs
03:00:40 <Heffalump> where can I find the contents of the upcoming haskell platform release? I've googled for a while and dug around the HP page without success
03:02:32 <Veinor> why do I want to write a shell in haskell
03:02:47 <Heffalump> never mind, founds the darcs repo (http://code.haskell.org/haskell-platform, obviously enough when I thought of it)
03:02:49 <Veinor> it'd be like the worst language to write it in
03:07:08 <pedro3005> is there a standard notation in haskell for iterated function composition, like f^n = f . f . f ..... n times?
03:07:36 <Veinor> > (iterate (+1) 0) !! 8
03:07:37 <lambdabot>   8
03:07:57 <Veinor> @pl \f n x -> (iterate f x) !! n
03:07:57 <lambdabot> flip . ((!!) .) . iterate
03:08:03 <Veinor> @pl \n f x -> (iterate f x) !! n
03:08:03 <lambdabot> flip (flip . ((!!) .) . iterate)
03:08:11 <Veinor> pick your poison
03:11:38 <Saizan> if your f is strict "foldl' (\x f -> f x) x (replicate n f)" is more appropriate, to avoid stack overflows
03:12:03 <Saizan> though n has to be large for it to matter
03:15:35 <mm_freak_> this is really weird
03:16:09 <j-invariant> how does the untyped lambda calculus relate to languages with types?
03:16:13 <mm_freak_> when i fill a screen with random pixels using direct memory access in IO it is very fast, well reaching C/assembler performance
03:16:38 <mm_freak_> as soon as i switch to a custom StateT over IO the performance drops to 2-3 FPS
03:16:43 <j-invariant> it's like there is a forgetful map from the language to untyped lambda calculus.. but somehow beta reduction is okay
03:17:29 <mm_freak_> is there some optimization of pokeElemOff, which is turned off by having a liftIO inbetween?
03:18:37 <EliasAmaral> j-invariant, it seems that when you add types, programs that were perfectly possible in untyped lambda calculus fails to be typed
03:19:00 <EliasAmaral> so untyped lambda calculus seems to be a superset of any typed language (that is based on this kind of abstraction)
03:19:03 <mm_freak_> good code:  liftIO . forM_ indices $ \ix -> random >>= pokeElemOff ptr ix
03:19:11 <gigabytes> talking about lambda calculus?
03:19:13 <mm_freak_> bad code:  forM_ indices $ \ix -> liftIO (random >>= pokeElemOff ptr ix)
03:19:14 <gigabytes> interesting!
03:19:20 <EliasAmaral> <j-invariant> how does the untyped lambda calculus relate to languages with types?
03:19:56 <mm_freak_> by monad laws the two codes are equivalent, but their performance differs drastically
03:20:19 <j-invariant> EliasAmaral: so the typed languge acould be thought of as a subset
03:20:42 <j-invariant> EliasAmaral: but that still doesn't explain why beta reduction can't make a typed program into an untyped one
03:22:43 <Saizan> mm_freak_: maybe the lib that's providing the StateT should add some INLINE and/or be compiled with -O2, or you might need to unroll the stack into something like Codensity (RealWorld# -> state ->)
03:22:44 <EliasAmaral> j-invariant, why would it make? (sorry i'm kind of unlearned. is beta reduction (\x -> x ..) b => b ..? then it is type safe if (\x -> x ..) has type m -> n and b has type m
03:23:05 <Saizan> mm_freak_: look at the core :)
03:24:52 <j-invariant> actually it's not even lambda calculus exactly
03:25:26 <j-invariant> you have also things like "if" etc
03:25:36 <EliasAmaral> if can be encoded in lambda calculus
03:26:00 <EliasAmaral> http://en.wikipedia.org/wiki/Lambda_calculus#Logic_and_predicates
03:27:00 <mm_freak_> Saizan: the StateT i'm using is already a codensity
03:27:14 <mm_freak_> do i still need to inline stuff?
03:27:16 * edwardk loks up
03:28:02 <Saizan> j-invariant: when you create a type system one of the first theorems you prove is the one saying that beta reduction on a type-correct term produces another type correct term
03:29:02 <mm_freak_> and what could i possibly inline?  (>>=)?
03:29:56 <Saizan> looks like a good candidate
03:30:05 <Saizan> but edwardk should know better :)
03:30:28 <mm_freak_> ok, thanks
03:30:30 <edwardk> barely conscious
03:30:31 <edwardk> ;)
03:30:36 <mm_freak_> edwardk: =)
03:31:02 <j-invariant> is reducibility predicates just writing an interepreter?
03:31:15 <j-invariant> cheating! lol
03:33:00 <mm_freak_> edwardk: does your Ran library do these kinds of optimization?
03:33:40 <mm_freak_> i could imagine there are some rewrite rules associated with pokeElemOff, as it translates to quite fast code
03:33:41 <edwardk> what kind? missed the question
03:33:50 <mm_freak_> and the liftIO inbetween could destroy them
03:34:04 <mm_freak_> edwardk: i'm writing a library for fast software rendering
03:34:09 <mm_freak_> using direct memory access
03:34:15 <mm_freak_> it operates in a custom monad
03:34:25 <edwardk> whats the shape of the monad?
03:35:35 <mm_freak_> it's StateT from http://hackage.haskell.org/packages/archive/contstuff/1.2.0/doc/html/Control-ContStuff-Trans.html#g:6
03:35:54 <mm_freak_> interestingly if the state type s = (), then the performance is good
03:36:13 <mm_freak_> but as soon as the state is some 'data' type it drops to very bad
03:36:15 <edwardk> ah you have the args in the wrong order =)
03:36:29 <edwardk> try (a -> s -> m r) -> s -> m r
03:36:42 <edwardk> then you'll find that fmap gets to be prettier anyways
03:36:49 <edwardk> and you have your args in codensity order
03:37:01 <mm_freak_> hmm, ok
03:37:07 <mm_freak_> can you explain why that makes a difference?
03:37:18 <edwardk> what is your fmap right now?
03:37:35 <mm_freak_>     fmap f (StateT c) =
03:37:35 <mm_freak_>         StateT $ \s0 k -> c s0 (\s1 -> k s1 . f)
03:38:11 <edwardk> it becomes     fmap f m = StateT (\k -> getStateT m (k . f))
03:38:35 <edwardk> you stop shuffling some of the args around
03:38:41 <edwardk> because they remain below you on the stack
03:38:51 <mm_freak_> ah, i see
03:39:14 <edwardk> this becomes particularly nice when your transformer is using unboxed arguments, like Int#
03:39:29 <mm_freak_> but why does the performance depend so drastically on the state type?  i mean, it runs fast with s = ()
03:39:30 <edwardk> because there is no boxing step
03:39:34 <edwardk> thats when it wins a lot
03:39:52 <edwardk> probably because the compiler was spotting that and not plumbing the ()
03:40:02 <mm_freak_> i see
03:40:09 <mm_freak_> ok, i'll try that out, thanks
03:40:14 <j-invariant> can you use category theory to prove the simple lambda calculus normalizes?
03:40:16 <edwardk> you'd have to look at the core to be sure
03:40:25 <edwardk> ask dana scott ;)
03:40:38 <edwardk> there is a post somewhere by him on the topic of category theory and the lambda calculus
03:40:50 <edwardk> old yellowish web site, you'll know it when you find it
03:41:18 <edwardk> but in general your StateT can take all of its definitions for Functor/Applicative/Monad straight from monad-ran
03:41:31 <edwardk> because it is a codensity monad
03:41:39 <j-invariant> http://mathgate.info/cebrown/notes/scott80.php
03:41:43 <j-invariant> aha
03:41:50 <Saizan> 12:07  lambdabot : flip (flip . ((!!) .) . iterate)
03:42:35 <mm_freak_> interesting
03:42:42 <mm_freak_> flipping the arguments really saves a lot of code
03:42:47 <edwardk> yeah
03:43:01 <edwardk> it made a factor of 4 difference on some benchmarks, but pessimized some others
03:43:15 <edwardk> i haven't found all of the differences, but that ordering is key.
03:43:47 <edwardk> because now you have forall r. (a -> f r) -> f r   — and the monad doesn't actually care about the f r
03:43:54 <edwardk> so its just 'cont'
03:44:19 <edwardk> unless you touch the state or the deeper layers of your monad transformer you _don't pay for them_
03:44:41 <edwardk> which can be an insanely huge win for deep transformers
03:45:13 <edwardk> not everything stays in codensity form like that but for state and state-like things like IO, ST, STM, etc it works well
03:45:41 <edwardk> you may place more pressure on the garbage collector though if you aren't careful
03:45:51 <edwardk> so test with things larger than little microbenchmarks if you can
03:46:08 <edwardk> and compiled vs. interpreted will make a big difference one way or the other
03:46:43 <edwardk> ok, i'm cross-eyed with sleepiness and can't see to finish fixing the code i was working on, so i'm going to bed ;)
03:47:16 <mreh> abuse of "type" definitions are satan's spawn
03:47:42 <mreh> always screws up my separation of concerns
03:48:22 <mm_freak_> edwardk: ok
03:48:24 <mm_freak_> thanks a lot =)
03:51:22 <edwardk> just happy someone is playing with this stuff ;)
03:51:37 <edwardk> since i got bored with it and mmorrow wandered away, its kind of languished
03:52:39 <mm_freak_> well, i love this CPS stuff
03:52:55 <edwardk> its tricky to get to pay off
03:53:02 <mm_freak_> and since i virtually always combined StateT with ContT i decided to turn it into a library
03:53:14 <mm_freak_> well, it already paid off
03:53:15 <edwardk> *nods*
03:53:28 <mm_freak_> ChoiceT is considerably faster even than []
03:53:39 <edwardk> mmorrow had one, where he used the two possible implementations for callCC to implement 'commit' and 'abort' for transactions
03:53:56 <edwardk> (mixing state and cont)
03:54:20 <edwardk> the code was all over on moonpatio which seems to be down these days
03:57:43 <mm_freak_> edwardk: such a transaction function should in fact be easy to write using this StateT
03:57:47 <mm_freak_> good idea, thank you
03:58:38 <dabblego> hey edwardk are the slides anywhere?
03:58:48 <edwardk> dabblego: you'd have to ping runar for em
03:58:54 <dabblego> ok ta
04:11:55 <mm_freak_> edwardk: i've rewritten StateT, but it didn't make any difference…  the inlining also didn't help =/
04:12:18 <mm_freak_> so i think this is the first time i look at core…  never used it before
04:14:44 <EliasAmaral> "Anyone can learn Lisp in a day, but if he'd previously been exposed to C, it'd take 3 days..."
04:25:30 <j-invariant> whdat can we prove using candidats?
04:28:22 <Jafet> EliasAmaral: wasn't it Fortran
04:28:45 <mm_freak_> EliasAmaral: i would have learned haskell in a week, if i hadn't coded C++ before
04:33:47 <mm_freak_> ghc-core output is hard to read
04:35:26 <rumbold1> i got a list of (bool,float) tuples. i want to get the one with the lowest float of those where the bool is true. whats an elegant way to do that?
04:37:29 <arcatan> > head . sortBy (compare `on` snd) . filter fst $ [(True, 1.0), (False, 0.0), (True, 0.5)]
04:37:31 <lambdabot>   (True,0.5)
04:38:03 <mm_freak_> :t minimumBy (compare `on` snd) . filter fst
04:38:04 <lambdabot> forall b. (Ord b) => [(Bool, b)] -> (Bool, b)
04:38:24 <mm_freak_> > minimumBy (compare `on` snd) . filter fst $ [(True, 1.0), (False, 0.0), (True, 0.5)]
04:38:26 <lambdabot>   (True,0.5)
04:38:39 <rumbold1> thanks
04:38:40 <arcatan> oh, there's minimumBy
04:38:49 <dabblego> comparing == compare `on`
04:39:02 <mm_freak_> ah, right
04:39:07 <mm_freak_> > minimumBy (comparing snd) . filter fst $ [(True, 1.0), (False, 0.0), (True, 0.5)]
04:39:09 <lambdabot>   (True,0.5)
04:39:17 <ion> @src on
04:39:17 <lambdabot> (*) `on` f = \x y -> f x * f y
04:40:55 <luite> > head . sortBy (compare `on` first not) $  [(True, 1.0), (False, 0.0), (True, 0.5)]
04:40:57 <lambdabot>   (True,0.5)
04:41:55 <luite> (note, this gives a different result than the others on a nonempty list if there is no tuple where the first element is True)
04:42:29 <rumbold1> > head . sortBy (compare `on` first not) $  [(False, 1.0), (False, 0.0), (False, 0.5)]
04:42:31 <lambdabot>   (False,0.0)
04:42:42 <luite> the others would give an exception
04:42:47 <rumbold1> > minimumBy (comparing snd) . filter fst $ [(False, 1.0), (False, 0.0), (False, 0.5)]
04:42:48 <lambdabot>   *Exception: List.minimumBy: empty list
04:47:12 <arcatan> > safeHead . sortBy (comparing snd) . filter fst $ [(False, 1.0), (False, 0.0), (False, 0.5)]
04:47:12 <lambdabot>   Not in scope: `safeHead'
04:47:32 <arcatan> > listToMaybe . sortBy (comparing snd) . filter fst $ [(False, 1.0), (False, 0.0), (False, 0.5)]
04:47:34 <lambdabot>   Nothing
04:47:48 <kingping> Hello
04:47:50 <mm_freak_> > do rec return (); return ()
04:47:51 <lambdabot>   <no location info>:
04:47:51 <lambdabot>      The last statement in a 'do' construct must be an ...
04:47:58 <mm_freak_> hello kingping 
04:48:04 <mm_freak_> > do rec { return () }; return ()
04:48:05 <lambdabot>   No instance for (GHC.Show.Show (m ()))
04:48:05 <lambdabot>    arising from a use of `M870129703...
04:50:35 <kingping> What's parser is most often found in various GHC versions ?
04:51:03 <mm_freak_> kingping: none…  but generally you can assume Parsec to be installed
04:51:10 <kingping> As opposed for instance to parsec.
04:51:36 <mm_freak_> but don't worry too much, as most people install haskell packages via the 'cabal' utility, which fetches all dependencies automatically
04:51:45 <mm_freak_> so use the parser library of your choice =)
04:51:52 <kingping> :] I see
04:52:26 <mm_freak_> i think parsec and attoparsec are the most commonly used libraries
04:52:57 <kingping> atto is it's improved descendant?
04:53:06 <aristid> no
04:53:16 <mm_freak_> no, it's not a descendant, it's a ByteString-specific library mainly for speed
04:53:24 <kingping> oh
04:53:53 <kingping> Does atto support Unicode?
04:54:01 <mm_freak_> nope
04:54:08 <kingping> parsec does?
04:54:13 <mm_freak_> it operates on byte level
04:54:18 <mm_freak_> well, parsec supports Text
04:54:30 <kingping> Funny
04:55:33 <mm_freak_> if you use attoparsec, you should encode the string to parse to a specific character set
04:55:52 <mm_freak_> you can do this on the way, either manually or by using attoparsec-enumerator
04:56:09 <mm_freak_> i.e. read Text, convert to preencoded ByteString, then parse
04:56:45 <mm_freak_> with parsec you don't need to worry about this, as you can parse Text directly
04:57:56 <kingping> As I have more often heard of parsec, I think it's a good lib to start with.
04:58:35 * ivanm still likes polyparse
04:58:47 <ivanm> preflex: seen malcolmw
04:58:48 <preflex>  malcolmw was last seen on #haskell 21 days, 18 hours, 55 minutes and 22 seconds ago, saying: John Peterson is trying to get Yale to give him back his old email address, just so he can officially hand over the domain...
04:59:03 * ivanm is reminded to ping malcolmw to see if he's updated the repo for polyparse
05:07:37 <mm_freak_> i like attoparsec most, since i mostly work with ByteString anyway
05:09:00 <rumbold1> can someone tell me what first does?
05:10:42 <dabblego> @type first
05:10:43 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
05:10:44 <luite> rumbold1: the type is a bit more general than you need in this case, so I'll give an example
05:10:53 <luite> > first (+1) (2,4)
05:10:55 <lambdabot>   (3,4)
05:11:02 <dabblego> (b -> c) -> (b, d) -> (c, d)
05:11:36 <rumbold1> thanks
05:12:01 <luite> > first negate (False, 1)
05:12:02 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
05:12:02 <lambdabot>    arising from a use of `GHC.N...
05:12:09 <dabblego> not
05:12:09 <luite> erm, sorry
05:12:12 <luite> not
05:14:13 <aristid> > first not . second negate $ (False, 1)
05:14:15 <lambdabot>   (True,-1)
05:14:33 <aristid> > negate . (False, 1)
05:14:35 <lambdabot>   (False,-1)
05:14:59 <Jafet> second = fmap
05:15:02 <rumbold1> huh, how does it know what to negate there?
05:15:54 <aristid> rumbold1: imagine this: data (,) a b = (a, b)
05:16:44 <aristid> Functor's parameter is necessarily the b
05:18:27 <rumbold1> hm, what does data do there? isnt that for making new types?
05:18:36 <rumbold1> > data (,) a b
05:18:36 <lambdabot>   <no location info>: parse error on input `data'
05:18:46 <rumbold1> > (,) a b
05:18:47 <lambdabot>   (a,b)
05:19:04 <dabblego> > not &&& negate $ (True, -1)
05:19:05 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
05:19:05 <lambdabot>         against inferred type ...
05:19:06 <rumbold1> was thot not supposed to be part of the code? :p
05:19:22 <augur> copumpkin!
05:19:27 <aristid> > not *** negate $ (True, 1)
05:19:28 <lambdabot>   (False,-1)
05:19:36 <aristid> dabblego: you meant that? :)
05:19:37 <dabblego> yeah thanks
05:23:54 <augur> how peculiar, this notion of computation
05:24:05 <augur> its rather a tree-like thing, isnt it
05:25:07 <augur> halting computation seems rather like a tree indeed... many paths that lead to the same end state, but they never diverge as you move towards that end state
05:25:13 <augur> at least they dont have to in principle
05:26:25 <augur> it would be interesting to see what sort of programming we could do if we had bi-directional computation
05:29:20 <maurer_> augur: See also, the Toffoli Gate.
05:30:33 <maurer_> Then you get bidirectional computation. No more trees, as information isn't destroyed. Everything linear.
05:30:34 <augur> maurer_: quoi
05:30:46 <maurer_> augur: You mentioned bidirectional computation.
05:30:54 <augur> well, i dont know if thats the right term for me
05:31:06 <augur> what i mean by bi-directional is that definitions arent directional
05:31:10 <augur> or dont have to be
05:31:26 <maurer_> What do definitions have to do with computation?
05:31:37 <augur> definitions of functions
05:32:04 <maurer_> Functions aren't inherently necessary for computation, they're a nice abstraction.
05:32:15 <augur> in every language i know of, definitions are direction; foo x = bar y can only ever be used in one way
05:32:22 <augur> reduction of `foo x` to `bar y`
05:32:27 <augur> never the reverse
05:33:15 <augur> but sometimes the reverse can be useful, at least in proofs, because answering some question might be very fast if you can work "backwards" so to speak
05:34:14 <maurer_> augur: For proofs that makes sense, for computations not so much
05:34:26 <augur> maurer_: ahh but suppose we take conal
05:34:37 <augur> conal's rampant multi-threaded approach seriously
05:35:14 <augur> we might then be able to evaluate expressions by spinning off threads for every direction choice possible, and race them
05:35:27 <augur> the preponderance of multiple cores makes this all the more plausible
05:35:27 <maurer_> That's not the issue.
05:35:43 <maurer_> The issue is that if I can translate from bar y back to foo x, where do I go from there?
05:36:17 <augur> maurer_: maybe nowhere. or maybe you go to any function that is defined in terms of foo x!
05:36:29 <maurer_> augur: That can't get anywhere though.
05:36:33 <augur> maurer_: sure it can
05:36:38 <harsh> i want to learn haskell 
05:36:42 <maurer_> You would just keep walking back up the tree, and never hit a constant.
05:36:43 <harsh> any help??
05:36:56 <augur> maurer_: except you would always walk both backwards and forwards
05:37:03 <augur> @where lyah
05:37:03 <lambdabot> http://www.learnyouahaskell.com/
05:37:04 <maurer_> harsh: http://book.realworldhaskell.org/
05:37:14 <augur> there you go hard :)
05:37:15 <augur> harsh*
05:37:16 <augur> XD
05:37:22 <augur> fingers!
05:37:27 <maurer_> augur: But you could never walk down a different path.
05:37:29 <harsh> thank u maurer :)
05:37:32 <augur> maurer_: sure you could
05:37:49 <maurer_> Give me a function definition where I can walk down two paths.
05:38:11 <augur> foo x = if x > 2 bar x else bar (x + 2)
05:38:34 <augur> suppose we're trying to compute bar 3
05:38:42 <augur> there are two things this could have reduced from
05:38:46 <augur> foo 3 or foo 1
05:38:51 <maurer_> Sure.
05:39:15 <maurer_> That joins paths though, not splits them.
05:39:36 <harsh> anyone has an idea how to implement dynamic programming logic in order to find number of ways in which an integer can be represendted as a sum of squares?
05:40:04 <augur> maurer_: im not saying that its easy to even see in current idiom. hell, it might not be possible at all. but im musing.
05:40:05 <Zao> harsh: I favor brute force :D
05:40:07 <maurer_> harsh: Do your own homework.
05:40:30 <harsh> brute force will take 400 years for large values of n :|
05:40:32 <maurer_> augur: There are indeed two things it could have come from, but neither of those can be evaluated.
05:40:36 <Zao> harsh: Eulering?
05:40:59 <harsh> zao:nope 
05:41:16 <maurer_> harsh: Do you know how to do dynamic programming for any problems yet?
05:41:18 <augur> maurer_: they could be. you're thinking too linearly. with too much directional definitions
05:41:39 <maurer_> augur: There are ways to do this, but they don't involve defining functions.
05:41:57 <maurer_> augur: Functions are deterministic, and so when you walk the tree backwards, you always walk forwards talong the same path.
05:42:00 <harsh> i havent tried my hands on it .. new to it .. just a beginer .. i am here to gain knowledge from experts 
05:42:17 <maurer_> harsh: If you have not done dynamic programming before, try an easier dynamic programming problem, like edit distance.
05:42:41 <augur> maurer_: well obviously i dont mean functions in the strictest sense. you'd want relations, strictly speaking.
05:43:05 <augur> not like relations cant be modelled as functions of a higher domain, but thats not the point
05:43:11 <maurer_> augur: In that case, what you are looking for is called a constraint solver, and these exist.
05:43:20 <harsh> maurer:thanks . i really need a mentor 
05:43:24 <augur> it might be a constraint solver indeed!
05:43:27 <augur> ive already considered that.t
05:43:28 <rumbold1> huh, lookslike fst and snd dont work on tuples with more than two elements? is there another way to access the elements except for pattern matching?
05:43:37 <augur> tho im not sure the intent is for it to work like a constraint solver
05:43:57 <augur> the idea would be for it to do reductions exactly like an evaluator does reductions of functions
05:44:09 <maurer_> rumbold1: No. If you are using tuples much larger than 2, you probably want to just use an ADT or record instead.
05:44:11 <augur> only it does multiple parallel reductions that sometimes work "backwwards"
05:44:39 <maurer_> augur: Working backwards is likely much less useful than just having additional evaluation strategies.
05:44:41 <augur> in the hope that working backwards gets you to a non-deterministic forward reduction that's closer to the goal than other things.
05:45:03 <augur> maurer_: maybe! im not saying its obviously a good thing to do. im just curious what it would be like.
05:46:12 <maurer_> augur: Have you looked at prolog?
05:46:19 <augur> yeah
05:46:44 <harsh> maurer: as i am 14 and i am a beginer so i just have vague idea about logic programming involving complexities and different programming principles can u guide me how to start brother?
05:47:05 <harsh> please help me :(
05:47:12 <harsh> i realy want to learn 
05:47:17 <augur> harsh: 14 huh
05:47:22 <augur> message elliott
05:47:28 <harsh> yup 
05:47:38 <maurer_> harsh: Try the book I linked you to.
05:47:40 <maurer_> harsh: +-------------------------------------------------------+#haskell (maurer_@irc.freenode.net -- IRC)+--------------------------------------------------------+
05:47:40 <maurer_> |(05:31:36) maurer_: Functions aren't inherently necessary for computation, they're a nice abstraction.                                                    #|
05:47:41 <maurer_> |(05:31:48) augur: in every language i know of, definitions are direction; foo x = bar y can only ever be used in one way                                   |
05:47:41 <maurer_> |(05:31:54) augur: reduction of `foo x` to `bar y`                                                                                                          |
05:47:41 <maurer_> |(05:31:59) augur: never the reverse                                                                                                                        |
05:48:04 <augur> hes not on right now i dont think, but hes 15 and is a wiz with this stuff, so maybe he can provide some insight into what you could do
05:48:32 <maurer_> Oops.
05:48:35 <augur> maurer_: dummy
05:48:37 <maurer_> Accidentally pasted the chat.
05:48:57 <maurer_> http://book.realworldhaskell.org/ <- that
05:49:15 <augur> maurer_: prolog works directionally too tho
05:49:27 <maurer_> augur: Yes.
05:49:41 <maurer_> As it is a language of implication.
05:49:58 <maurer_> It does have the ability to do nice backtracking from a failure to follow a different path.
05:50:10 <maurer_> Another term you might want to look into is "speculative execution"
05:50:18 <maurer_> Which is the stuff that you want to do, but forward direction only.
05:51:04 <augur> yeah yeah but thats totally against the point of what i want to do
05:51:13 <augur> backtracking is anti-thetical to my question
05:51:17 <augur> as is specex
05:51:49 <augur> forward parallel non-determinism is just amb
05:52:02 <harsh> maurer : i am versed with c and discoverd haskell a while ago and came across some haskell code .. can u interpret that code into c if i provide it you buddy?
05:52:13 <harsh> it would be a lot of help :(
05:52:25 <augur> "buddy"?
05:52:38 <augur> you sound like a 40 year old trying to sound like a 14 year old.
05:52:42 <harsh> whats wrong ?
05:52:56 <harsh> i dont know how old maurer is
05:53:03 <harsh> anyways will use sir
05:53:08 <harsh> that would be better 
05:53:18 <harsh> my appologies 
05:54:00 <akosch> could you recommend a haskell module with a fast prime-test?
05:54:04 <maurer_> harsh: Haskell works very differently from C.
05:54:20 <harsh> ok sir 
05:54:22 <maurer_> harsh: Thus why I was reccomending you read a book.
05:54:43 <Zao> You could of course write it all in IO with mvars and what-have-you, but it'd not be idiomatic.
05:55:19 <maurer_> akosch: I don't think we have one. You might just want to bind a C library, as the interface code would be minimal.
05:57:20 <akosch> maurer_: thanks for the tip
05:58:03 <kamaji> Does anyone know of a fast factorization algorithm implementation anywhere?
05:58:18 <kamaji> I don't want a sieve though, just want to factor numbers
05:58:55 <Zao> MPIR or GMP might have something fancy, but that comes with silly licenses.
05:59:30 <maurer_> Zao: If you're using GHC, you're already using GMP, so you might as well use it.
06:00:23 <kamaji> also, I just saw akosch's question..... that's weird
06:00:49 <akosch> I found Data.Numbers.Primes just now
06:00:55 <akosch> it might work for me
06:01:16 <kamaji> akosch: I found this: http://andrew.bromage.org/darcs/numbertheory/Math/
06:01:30 <Zao> maurer_: I thought that there had been work to get GMP-less Integer quite a while ago?
06:01:47 <Zao> Or am I mixing it up with readline/editline?
06:02:11 <mm_freak_> kamaji: a very simple wheel factorization method is usually a two-liner in haskell
06:02:34 <mm_freak_> if you want something more sophisticated i think you'll have to write it yourself
06:03:02 <mm_freak_> i started writing a quadratic sieve, but stopped working on it a few weeks ago
06:03:04 <kamaji> I just don't want to reinvent the wheel factorization
06:03:05 <kamaji> hohoho
06:03:12 <Zao> :D
06:03:12 <mm_freak_> ;)
06:03:26 <Zao> Reinvent things, put it on Hackage for greater glory.
06:03:43 <kamaji> also i'm not very good at haskell :D
06:04:13 <Zao> For my Euler solutions, I ended up pregenerating to file, slurping totients and primes into memory :)
06:04:21 <mm_freak_> > let splitProduct n = gcd n . product . takeWhile (\x -> x*x < n) $ [1..] in splitProduct 15
06:04:22 <lambdabot>   3
06:05:09 <mm_freak_> simple, slow, makes number theorists climb the walls
06:05:58 <jix> > let splitProduct n = gcd n . product . takeWhile (\x -> x*x < n) $ [1..] in splitProduct 9
06:05:59 <lambdabot>   1
06:06:13 <mm_freak_> > let splitProduct n = gcd n . product . takeWhile (\x -> x*x <= n) $ [1..] in splitProduct 9
06:06:15 <lambdabot>   3
06:08:02 <jix> > let splitProduct n = gcd n . product . takeWhile (\x -> x*x <= n) $ [1..] in splitProduct 100
06:08:03 <lambdabot>   100
06:08:46 <mm_freak_> > let factor f@(f0:fs) n | mod n f0 == 0 = f0 : factor f (div n f0) | otherwise = factor fs n in factor [2..] 15
06:08:50 <lambdabot>   mueval-core: Time limit exceeded
06:09:04 <mm_freak_> > let factor _ 1 = 1; factor f@(f0:fs) n | mod n f0 == 0 = f0 : factor f (div n f0) | otherwise = factor fs n in factor [2..] 15
06:09:05 <lambdabot>   No instance for (GHC.Num.Num [t])
06:09:05 <lambdabot>    arising from a use of `e_11100000215' ...
06:09:13 <mm_freak_> > let factor _ 1 = []; factor f@(f0:fs) n | mod n f0 == 0 = f0 : factor f (div n f0) | otherwise = factor fs n in factor [2..] 15
06:09:14 <lambdabot>   [3,5]
06:09:33 <mm_freak_> there…  turn [2..] into a wheel to get wheel factoring, otherwise you get simple trial division
06:09:59 <mm_freak_> > let factor _ 1 = []; factor f@(f0:fs) n | mod n f0 == 0 = f0 : factor f (div n f0) | otherwise = factor fs n in factor (2:[3,5..]) 15
06:10:00 <lambdabot>   [3,5]
06:10:05 <mm_freak_> > let factor _ 1 = []; factor f@(f0:fs) n | mod n f0 == 0 = f0 : factor f (div n f0) | otherwise = factor fs n in factor (2:[3,5..]) 12827
06:10:06 <lambdabot>   [101,127]
06:21:34 <maurer_> Zao: People started working on it, but they never got anywhere. The current solution is that if there's a problem, use manual linking, rewrite those functions of GMP you're actually using by hand.
06:21:56 <maurer_> Zao: http://hackage.haskell.org/trac/ghc/wiki/ReplacingGMPNotes
06:22:12 <maurer_> Zao: And the current stub list for people wanting to not use GMP: http://hackage.haskell.org/trac/ghc/attachment/ticket/601/jmp.c
06:23:26 <Zao> maurer_: I guess that anyone wanting to use it in a proper commercial application are waiting for functioning dynamic runtime or something.
06:24:03 <Zao> s/commercial/non-open/
06:24:56 <maurer_> Zao: Or they can just roll their own.
06:25:12 <maurer_> GHC's build system does now support linking against different integer packages
06:25:28 <maurer_> i.e. you can use 'integer-simple' instead, but it can give 100x slowdown in some cases
06:26:08 <maurer_> Zao: And the only non-open haskell that I know of is cryptol, and I don't think they use Integer anywhere.
06:28:18 <Zao> maurer_: I'm just saying, it's an obstacle for people intending to write software in H.
06:29:02 <maurer_> Zao: True, if they need arbitrary precision integers.
06:31:56 <mm_freak_> besides the licensing issue it wouldn't be that bad, if GHC would provide all GMP functions
06:32:14 <Zao> maurer_: There's a lot of code using Integer, you know.
06:32:18 <Zao> Particularly in Hackage.
06:32:54 <mm_freak_> just think about it:  there is a blazingly fast integer square root function, and you have to write your own in haskell, producing a much slower algorithm and reinventing the wheel, /even though the fast sqrt code is already there and linked in the binary/!
06:33:27 <maurer_> Zao: Yeah, but if it's not performance critical, you just change "gmp" to "simple" in ghc, rebuild, and you're fine.
06:33:42 <Zao> Rebuild ghc, heh.
06:33:46 <Zao> Never managed to properly build a GHC.
06:33:51 <maurer_> Zao: Really?
06:34:01 <Zao> Not even on the same machine with an existing one.
06:34:10 <Zao> Let alone unregisterised builds.
06:34:33 <Zao> Cobbling together the rather ancient build environment is a bit of a mess too.
06:35:09 * applicative thinks Zao is not brave enough; its just a question of trying a few times and making a mess of things
06:35:26 <Zao> applicative: Believe me, I've tried, at several points in time.
06:35:32 <Zao> I lack some hair on my head now.
06:35:33 * applicative thinks what ghc build itself is one of lifes great pleasures
06:35:37 <applicative> watching...
06:36:02 <maurer_> Zao: I've been fine. I sometimes need to manually throw out my library set if it's a version I already had built with different parameters, but that's it.
06:36:28 <Saizan> Zao: not on linux, right?
06:36:51 <Zao> Saizan: Which platform do you typically write non-open software on?
06:37:05 <Zao> Saizan: As for failing at building GHC, I have failed on them all.
06:37:12 <Zao> FreeBSD, Linux, Windows, OpenSolaris.
06:37:19 <Zao> Heck, I even tried on AIX once, but that was a bit suicidal.
06:37:28 * applicative has failed on them all too
06:37:37 * applicative has succeeded too though
06:38:12 <maurer_> I hate trying to build software on Windows/OSX. Dependency Hell.
06:38:49 <Zao> The license on GMP on Linux is not a problem, as it's dynamically loaded there.
06:39:02 <Zao> I don't know if the GHC folks has gotten the dynamic runtime working on Windows yet.
06:39:18 <maurer_> Argh. Does  anyone know how to make a monad wrapper on IO that doesn't let someone do arbitrary IO actions?
06:39:31 <maurer_> I looked at ST, but then it turned out to be a builtin :(
06:40:15 <dolio> newtype RestrictedIO a = Restrict (IO a)
06:40:20 <dolio> Then don't export the constructor.
06:40:54 <maurer_> dolio: But then my MonadTransformer instance will...oh, I guess I just don't use a monad transformer and manually lift all the IO functions
06:40:55 <maurer_> my bad.
06:44:30 <applicative> maurer_, I take it you
06:44:38 <applicative> have seen things like
06:44:42 <applicative> @hackage jail
06:44:43 <lambdabot> http://hackage.haskell.org/package/jail
06:46:07 <Saizan> Zao: weird, it always compiled pretty smoothly for me, though i wasn't changing anything too radical, e.g. readline instead of haskeline
06:46:47 <maurer_> applicative: Thanks, but in this case the IO actions I'm giving it are kind of complicated (they involve network access and a number of other things)
06:47:12 <applicative> maurer_, yeah, I was only thinking it might illustrate a method
06:47:27 <maurer_> applicative: Yes, the manual lifting is fine.
06:49:30 <mm_freak_> the IntMap documentation confuses me
06:49:47 <mm_freak_> "Many operations have a worst-case complexity of O(min(n,W)). This means that the operation can become linear in the number of elements with a maximum of W -- the number of bits in an Int (32 or 64)."
06:49:54 <mm_freak_> doesn't it get constant?
06:50:42 <mm_freak_> uhm, logarithmic
06:50:44 <mm_freak_> not constant
06:50:50 <mm_freak_> why linear and not logarithmic?
06:50:57 <Botje> iirc IntMaps are tries internally
06:51:20 <mm_freak_> i thought tries have logarithmic complexity
06:51:46 <Botje> not if you don't use the full path
06:51:58 <mm_freak_> i see
06:52:10 <Botje> and O(W) is effectively constant
06:52:20 <mm_freak_> does that mean that Map Int can be more efficient than IntMap in some cases?
06:52:29 <mm_freak_> for very small sets
06:52:45 <Botje> yeah
06:52:49 <Botje> that'd be my guess
06:53:02 <mm_freak_> i see…  so you should use IntMap only for large sets
06:54:36 <aristid> mm_freak_: that conclusion seems premature
06:54:56 <mm_freak_> aristid: yes, i thought so, after all, this is only about asymptotic performance
06:55:05 <mm_freak_> and i wonder what "large" means in this context
06:55:10 <mm_freak_> 32 or 64 elements?
06:55:18 <maurer_> mm_freak: If your set is small enough that Map Int is faster, the performance cost is so low you don't care.
06:55:46 <mm_freak_> maurer_: i'm planning to implement some fast concurrency constructs, so the maps may be small, but there may be lots and lots of them
06:56:41 <maurer_> mm_freak_: Are you sure you want a map then?
06:56:57 <maurer_> How about constructing a function with a case statement?
06:57:07 <mm_freak_> maurer_: i need to associate some identifier with an IO action
06:57:09 <maurer_> It will have slow updates, but bloody fast access
06:57:25 <maurer_> Oh, so you need fast updates as well.
06:57:31 <mm_freak_> there will be many updates as well as many accesses, although most of the accesses will be fold-like
06:57:34 <mm_freak_> so i'm thinking about lists
06:57:48 <mm_freak_> or vectors/arrays
06:57:51 <mm_freak_> or even a Ptr
06:58:13 <mm_freak_> fast hash tables would be great here
06:58:27 <aristid> mm_freak_: how about measuring it? :)
06:58:47 <mm_freak_> aristid: by the time i've measured it i already implemented a Ptr variant =)
06:58:56 <mm_freak_> but i'd like to avoid it, and a measurement is difficult to do
06:59:03 <aristid> mm_freak_: which might end up slower
06:59:07 <mm_freak_> i can measure some common cases, though
06:59:22 <aristid> if performance is not all that critical, just use whatever is most convenient :)
06:59:43 <mm_freak_> it is critical
07:00:14 <mm_freak_> i'm expecting thousands of threads each with many of those constructs in the application i'm planning
07:01:28 <mm_freak_> MVar is the construct i'm using right now, but i rather need semi-transactional IORefs
07:01:39 <mm_freak_> sort of like generalized IVars
07:02:15 <j-invariant> what' special about Godels T?
07:06:30 <Renze> Good afternoon!
07:08:18 <j-invariant> hi
07:08:21 <j-invariant> Renze: 
07:08:32 <Renze> Did someone work with Moe and forms? I'd like to know how I can create label-links (there is nothing like 'for'), file input fields and submit buttons, but I can't find it in their package...
07:09:04 <Renze> Wait, forget about the submit button :)
07:11:01 <taktoa> hello?
07:11:25 <taktoa> anybody awake?
07:11:40 <taktoa> I suppose not :/
07:11:46 <Zao> taktoa: Several.
07:11:51 <Renze> Yes, I am.
07:11:56 <Renze> At least I think.
07:11:57 <taktoa> I see.
07:12:17 <taktoa> Well, I'm trying to make a program in Haskell
07:12:53 <taktoa> that basically tells you the optimum component values for an oscillator of a given frequency
07:12:56 <aristid> :t \f -> map (second f)
07:12:58 <lambdabot> forall b c d. (b -> c) -> [(d, b)] -> [(d, c)]
07:13:11 <aristid> :t \f -> fmap (fmap f)
07:13:12 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
07:13:20 <aristid> @pl \f -> fmap (fmap f)
07:13:20 <lambdabot> fmap . fmap
07:13:38 <aristid> another evil use of (.:)
07:14:25 <taktoa> in abstract, it's a program that takes a function of form (Double, Double...) -> Double, an optimum output, and a tuple of lists, where each list is the range of possible values for each variable
07:15:28 <taktoa> I have an implementation for the Colpitts oscillator, but I'd like to abstract it so that it can be applied to any oscillator or even any situation where you're optimizing a value with constraints on variables
07:15:50 <taktoa> firstly, does anyone know of a program that already does the above?
07:16:32 <taktoa> secondly, does anybody know how I can implement it in Haskell, seeing as there is no type for an arbitrary n-tuple
07:19:42 <taktoa> also, does anybody know of a haskell function that allows one to find the cartesian product of all the lists in a list of lists?
07:20:01 <Saizan> 2) you can use a list, and if you want to ensure it's of a specific length you can use gadts to specify it in the type
07:20:29 <Saizan> > sequence ["abc","dce","fg"]
07:20:30 <lambdabot>   ["adf","adg","acf","acg","aef","aeg","bdf","bdg","bcf","bcg","bef","beg","c...
07:21:28 <taktoa> ok, thanks
07:22:18 <taktoa> > sequence [1, 2, 3]
07:22:19 <lambdabot>   No instance for (GHC.Show.Show (m [a]))
07:22:19 <lambdabot>    arising from a use of `M38480861...
07:22:34 <taktoa> > :t sequence
07:22:35 <lambdabot>   <no location info>: parse error on input `:'
07:24:10 <Saizan> :t sequence
07:24:11 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:27:39 <taktoa> also, is there a function that will sort a list, and take the first n objects of the same value?
07:28:08 <mm_freak_> > take 3 . sort $ [10,9..1]
07:28:10 <lambdabot>   [1,2,3]
07:28:12 <taktoa> so that, say, if you gave it [1, 2, 1, 2, 3, 3, 4] it would give you [1, 1] back?
07:28:33 <taktoa> no, the first n *of the same _value_*
07:28:57 <taktoa> for [10..1
07:28:57 <mm_freak_> > head . group . sort $ [1,2,1,2,3,3,4]
07:28:59 <lambdabot>   [1,1]
07:29:04 <taktoa> thanks
07:29:29 <Cale> > group . sort $ [1,2,1,2,3,3,4]
07:29:31 <mm_freak_> although i'd write a custom function for that
07:29:32 <lambdabot>   [[1,1],[2,2],[3,3],[4]]
07:29:38 <Cale> Why? :)
07:29:50 <mm_freak_> because it's slow, memory-hungry and strict =)
07:30:00 <Cale> I suppose this could be less strict
07:30:16 <Cale> But it shouldn't be too slow
07:30:26 <maurer_> Also O(n log n) instead of O(n)...
07:30:35 <Cale> sort has some laziness to it as well
07:30:46 <Cale> head . sort  should be O(n)
07:31:11 <mm_freak_> if you want to use Data.List functions, better combine minimum and filter
07:32:14 <mm_freak_> > filter . (==x) . minimum $ [1,2,1,2,3,3,4]
07:32:15 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
07:32:15 <lambdabot>         against inferred ...
07:32:17 <taktoa> let's say I wanted to do the same thing, but it would take a list of lists and sort by the first value of each list
07:32:18 <mm_freak_> > filter . (==) . minimum $ [1,2,1,2,3,3,4]
07:32:19 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
07:32:19 <lambdabot>    arising from a use ...
07:32:30 <taktoa> kind of like Data.List.Key functions
07:32:46 <Cale> sortBy (comparing head)
07:33:06 <Cale> (or: comparing (take 1))
07:33:11 <mm_freak_> taktoa: maybe you don't want a list at all
07:33:25 <taktoa> well, it has to generalize to arbitrary sizes
07:33:30 <taktoa> so I can't use tuples
07:33:51 <mm_freak_> i didn't mean tuples either…  what's your application?
07:33:55 <mm_freak_> or are you just experimenting?
07:34:16 <taktoa>  in abstract, it's a program that takes a function of form (Double, Double...) -> Double, an optimum output, and a tuple of lists, where each list is the range of possible values for each variable
07:34:32 <taktoa> Well, I'm trying to make a program in Haskell that basically tells you the optimum component values for an oscillator of a given frequency
07:34:44 <taktoa> I have an implementation for the Colpitts oscillator, but I'd like to abstract it so that it can be applied to any oscillator or even any situation where you're optimizing a value with constraints on variables
07:34:55 <lars9> when cabal build, it's said: Warning: Module `Prelude' is deprecated:
07:35:02 <lars9> is it serious?
07:35:06 <taktoa> no
07:35:16 <lars9> ok
07:35:23 <mm_freak_> lars9: one of your dependent libraries uses an old base
07:35:38 <mm_freak_> don't worry about it, and if you do, report it to the library author
07:35:52 <lars9> base < 4 && >=3, containers, mtl, parsec
07:36:03 <mm_freak_> yes, that's the old base
07:36:20 <mm_freak_> unless you have a reason to stay, switch to the new one
07:36:25 <lars9> change base to >= 4.0?
07:36:31 <mm_freak_> base >= 4 && < 5
07:36:35 <lars9> ok let me try
07:37:46 <taktoa> mm_freak_: this program could be very very useful to electrical engineers (myself included)
07:38:01 <taktoa> since they only sell components in specific denominations
07:38:26 <taktoa> and you often need to create a waveform with an arbitrary frequency
07:38:35 <mm_freak_> taktoa: isn't there anything ready-made?
07:38:40 <taktoa> not that I know of
07:38:52 <mm_freak_> IIRC there are libraries for optimization problems in general
07:39:06 <taktoa> I'll check into that
07:40:17 <taktoa> interestingly enough, my current program is damn fast
07:41:38 <taktoa> even though I'm giving in (10^7 * 24 * 10^-3 * 10^12 * 24) different possibilities
07:41:59 <taktoa> and a calculation of 1/(2*pi*sqrt(6)*x*y) for each possibility
07:42:40 <taktoa> it runs in less than 250 ms
07:44:28 <taktoa> haskell is built for this type of problem
07:44:43 <taktoa> since it has great list / tuple manipulation paradigms
07:45:09 <taktoa> and lazy eval. allows for sorting only part of the list
07:45:18 <parcs> > flip (flip take . repeat) 5 1
07:45:20 <lambdabot>   [1,1,1,1,1]
07:45:30 <parcs> what is the name of this function? i forget
07:45:38 <taktoa> replicate
07:45:39 <jix> > replicate 5 1
07:45:40 <lambdabot>   [1,1,1,1,1]
07:45:41 <taktoa> I think
07:45:45 <parcs> ah
07:46:23 <maurer_> prcs: Try hoogle next time: maurer@daemon:~$ hoogle "Int -> a -> [a]" | head -n 1
07:46:24 <maurer_> Prelude replicate :: Int -> a -> [a]
07:46:34 <maurer_> *parcs
07:46:47 <Jafet> @hoogle Integer -> a -> [a]
07:46:48 <lambdabot> Data.List genericReplicate :: Integral i => i -> a -> [a]
07:46:48 <lambdabot> Prelude enumFromThen :: Enum a => a -> a -> [a]
07:46:48 <lambdabot> Prelude enumFromTo :: Enum a => a -> a -> [a]
07:46:54 <Jafet> Oh, there is on
07:46:56 <knobo> is the Text.JSON library explained anywhere?
07:47:34 <knobo> I'm having trouble understanding what is a JSValue and what is a JSObject and so on.
07:50:18 <knobo> toJSObject [("foo","test")] returns a JSONObject, runCouchDB returns a JSObject. What is the difference from a JSONObject and a JSObject?
07:50:57 <Saizan> are both those types from the same library?
07:52:03 <knobo> Saizan: I don't know. but the JSObject contains a JSONObject
07:53:49 <taktoa> @hoogle comparing
07:53:50 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
07:56:00 <arcatan> knobo: JSValue represents JSON. JSObject is essentially an association list, which is used to represent JSON objects inside JSValues
07:57:14 <knobo> and what is JSONObject, then?
07:57:24 <arcatan> no idea
07:57:33 * Saizan doesn't see JSONObject anywhere in the docs
07:58:43 <hpc> @hoogle JSObject
07:58:43 <lambdabot> No results found
07:58:49 <hpc> @hoogle JSONObject
07:58:49 <lambdabot> No results found
07:59:19 <arcatan> oh, JSONObject is a constructor for JSObject
07:59:32 <arcatan> and also note that JSObject is a constructor for JSValue
07:59:50 <hpc> wtf?
08:00:00 <arcatan> JSON value {"key": true} would parse to something like JSObject (toJSObject [("key", JSBool True)]), which is a JSValue
08:00:15 <arcatan> hpc: yeah, the naming sucks
08:00:47 <knobo> So, it is confusing? It is not me?
08:00:55 <arcatan> yes, it is confusing to everyone
08:00:58 <monochrom> so we have been looking at the equivalent of "what is the difference between Maybe and Just"?
08:01:21 <akosch> I have a fold and want to create a set (Data.Set) from the values of the accumulator during the fold, is there a way of doing this?
08:01:26 <arcatan> monochrom: i think so
08:01:30 <knobo> monochrom: that explains alot.
08:01:41 <monochrom> well that is not confusing
08:01:49 <knobo> I have to draw it down.
08:02:00 <arcatan> monochrom: no, but the naming is
08:02:27 <monochrom> I no longer believe in that.
08:03:04 <knobo> Why is not the constructor of JSObject JSObject, but JSONObject
08:03:26 <Saizan> because JSObject is already taken by JSValue i guess
08:03:52 <akosch> for example from foldl (+) 1 [1,2], i want a set containing the values 1,2,4
08:04:06 <knobo> couldn't JSObject be called JSONObject instead then..
08:04:11 <Saizan> > scanl (
08:04:12 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:04:15 <monochrom> how many constructors does that type have? if it has two constructors, you can't call both JSObject.
08:04:19 <knobo> so that the constructor and type had the same name
08:04:24 <Saizan> > scanl (+) 1 [1,2]
08:04:25 <lambdabot>   [1,2,4]
08:04:30 <Saizan> monochrom: it's two types
08:05:04 <Saizan> knobo: i guess the idea is that you wouldn't use the JSONObject constructor so it gets the longer name
08:06:14 <akosch> Saizan: thx, but is there something similar for creating a set?
08:06:49 <nostrand> akosch: foldr Data.Set.insert Data.Set.empty [1..5]
08:07:24 <akosch> nostrand: thanks, this is most useful
08:07:30 <Saizan> akosch: compose with Set.fromList
08:07:31 <nostrand> akosch: =)
08:07:53 <Saizan> you shouldn't ever use foldr like that to build a Set
08:08:02 <Saizan> insert is strict in its second argument
08:08:54 <Saizan> i guess scanl' would be better here too
08:35:02 <ClaudiusMaximus> hm.  getting a stack overflow with  "es <- getElems someLargeMArray"  :(
08:35:43 <monochrom> probably incurable
08:35:46 <Renze> How can I create a Data.Text.Lazy.Text? I can't import Data.Text.Lazy.Internal; I believe Text is in there (at least I can't just say: import Data.Text.Lazy \n text = Chunk .. Empty or something like that) and I don't see a method who goes from String to a Text...
08:36:14 <ClaudiusMaximus> monochrom: i suspect so.  but +RTS -K100M -RTS works so far, it's just a bit annoyment
08:37:14 <Renze> I think I found it :)
08:38:29 <mm_freak_> ClaudiusMaximus: stack overflow?  not a heap overflow?
08:38:39 <ClaudiusMaximus> mm_freak_: stack.
08:38:55 <mm_freak_> try with -O
08:39:07 <mm_freak_> stack overflows shouldn't happen with getElems
08:39:46 <ClaudiusMaximus> mm_freak_: i'm using -O2 already
08:40:32 <mm_freak_> how large is the array?
08:40:38 <Saizan> ?hoogle getElems
08:40:38 <lambdabot> Data.Array.MArray getElems :: (MArray a e m, Ix i) => a i e -> m [e]
08:40:45 <ClaudiusMaximus> > 788 * 576 * 4
08:40:47 <lambdabot>   1815552
08:40:58 <mm_freak_> ClaudiusMaximus: try using runSTUArray and 'elems'
08:41:12 <mm_freak_> runSTUArray doesn't copy the array
08:41:21 <mm_freak_> (or runIOUArray for that matter)
08:41:27 <mm_freak_> (and possibly without the U)
08:41:55 <mm_freak_> i've had larger arrays and converted them to lists without problems, but i went the run*Array route
08:43:16 <ClaudiusMaximus> mm, maybe it's what i'm doing with the resulting list that's the problem
08:43:40 <ClaudiusMaximus> but that didn't seem particularly special
08:43:42 <mm_freak_> yeah, that's more likely
08:44:14 <mm_freak_> but note that getElems produces a fully evaluated list (up to the cons)
08:44:29 <mm_freak_> if u use *UArray, then even the elements are evaluated
08:44:36 <mm_freak_> 'elems' doesn't do that
08:44:43 <mm_freak_> it produces a lazy list
08:45:20 <jonkri> which was the last version of haskell to break backwards-compatibility?
08:46:05 <ClaudiusMaximus> the other code is essentially:  unsafeThaw . array quux . concatMap foo . sortBy bar . zip [0 ..] . chunk 4
08:46:51 <arcatan> jonkri: are asking about the language or the compiler?
08:47:17 <Saizan> ClaudiusMaximus: it's simply that getElems is a non-tail-recursive loop, so if you use it in a monad whose >>= is sufficiently strict on the first arg you get a stack overflow like you'd get in an eager language
08:47:38 <arcatan> (*a compiler)
08:48:09 <Philippa_> Saizan: ITYM an/other/ eager language :-)
08:48:26 <Saizan> Philippa_: heh, right :)
08:48:36 <newster> hey guys, hoping to find an emacs and haskell user who can help me understand this weird interaction.  With ghci running in an inferior shell (M-x shell in emacs), I type: Prelude> let echo = (getChar >>= putChar)      .... but then echo by itself only works *every other time* !??
08:49:06 <newster> doesn't happen on terminal by itself, under in an inferior shell
08:49:08 <mm_freak_> newster: probably has to do with buffering… have you tried in a command line GHCi?
08:49:28 <newster> mm_freak_: buffering in emacs?
08:49:33 <mm_freak_> newster: GHCi chooses the buffering mode based on whatever is connected on stdin
08:49:39 <mm_freak_> play with hSetBuffering in emacs
08:49:45 <jonkri> arcatan: i'm curious as to both, actually :) erlang has got some stuff in it (like the records implementation over tuples) which i think is sort of an afterthought and has a pretty weird syntax imo, and i was hoping that is not the case with haskell
08:49:52 <newster> mm_freak_: ah, how can I read more about GHCi buffering?
08:50:05 <jonkri> are there some functions that returns the "wrong" types, perhaps?
08:50:14 <mm_freak_> newster: lookup hSetBuffering in the base docs…  it's explained there
08:50:21 <newster> mm_freak_: Thanks!  I'll look at hSetBuffering
08:50:28 <mm_freak_> jonkri: unsafeCoerce can return any wrong type you want =)
08:50:31 <jonkri> a tutorial mentioned that length perhaps should return Num instead of Int or something (sounds weird)
08:50:46 <mm_freak_> jonkri: there is genericLength for that
08:50:50 <mm_freak_> :t length
08:51:03 <mm_freak_> @botsnack
08:51:04 <lambdabot> :)
08:51:04 <lambdabot> forall a. [a] -> Int
08:51:06 <mm_freak_> ah
08:51:08 <lars9> Warning: Definition but no type signature for `reStar'
08:51:09 <mm_freak_> :t genericLength
08:51:10 <lambdabot> forall b i. (Num i) => [b] -> i
08:51:13 <lars9> how to disable this warning
08:51:28 <mm_freak_> lars9: by writing a type signature =)
08:51:29 <jonkri> why is not length generic?
08:51:36 <mm_freak_> jonkri: efficiency
08:52:06 <mm_freak_> you couldn't exhaust the range of Int by any practical means =)
08:52:10 <lars9> mm_freak_: they are not top functions
08:52:25 <lars9> *level
08:52:27 <mm_freak_> lars9: you can write a type signature for non-top-level functions, too
08:52:40 <mm_freak_> > let x :: Int; x = 3 in x+4
08:52:41 <lambdabot>   7
08:52:41 <lars9> mm_freak_: yeah, but how to just disable this warning?
08:53:19 <mm_freak_> dunno, never seen that warning
08:53:50 <mm_freak_> as far as i've seen either types are inferred properly or your code doesn't compile at all
08:55:13 <jonkri> but basically want i want to know is
08:56:05 <jonkri> would the haskell community be really reluctant to make backwards-incompatible change if it would benefit the language elegancy and make it easier for new programs
08:56:07 <lars9> mm_freak_: hmmm, just remove -Wall ...
08:56:24 <jonkri> developers of new programs*
08:56:34 <ClaudiusMaximus> lars9: -fno-warn-missing-signatures perhaps
08:56:43 <jonkri> i guess i'm only talking about the language at this point
08:57:09 <lars9> ClaudiusMaximus: thanks
08:58:46 <Philippa_> jonkri: depends on the size of the incompatibility, IME
08:59:09 <Saizan> i wonder if we should have a tail recursive sequence in Control.Monad
08:59:10 <arcatan> jonkri: not an answer, but people are arguing for example that Monad should be a subclass of Applicative, because all monads are applicative functors
08:59:33 <Saizan> or maybe in the cases where you'd need that you should use something else entirely..
08:59:40 <jonkri> aha ok
08:59:54 <Philippa_> arcatan: yeah, the sorts of things that'd break are mostly fixable in simple-but-tedious manner though
09:00:12 <jonkri> of course i do see the business need for not making those kinds of changes, but for me personally i just like a pretty language to work in without those kinds of inconsistencies you know :)
09:00:12 <arcatan> true
09:00:47 <jonkri> i was hoping that the 20xx -> 20yy versions were aggressive in this sense
09:01:09 <Philippa_> not all elegance-increasing changes remove inconsistencies
09:01:28 <arcatan> Philippa_: has there been any serious proposals that would break lots of things that would be hard to fix
09:01:30 <jonkri> yeah
09:01:42 <Philippa_> arcatan: "add dependent types!" :p
09:01:48 <arcatan> heh
09:02:19 <Philippa_> (I usually hear that one from idiots who can't distinguish sensible additions from sensible branching points in the design space)
09:07:37 <Renze> Is there a function a -> [a] -> [[a]] which splits it's second argument on it's first?
09:08:28 <Renze> splitAt needs an Int, but I want to have my own type so it splits iff nextElementFromList == givenElement
09:08:46 <j-invariant> splitBy . (==)
09:08:48 <j-invariant> :t splitBy . (==)
09:08:54 <ClaudiusMaximus> @hackage split
09:10:04 <ddarius> jonkri: Check out this recent email on Libraries and the thread following it: http://www.haskell.org/pipermail/libraries/2011-January/015557.html
09:10:25 <Renze> Where's that function defined, j-invariant? Hoogle doesn't know it
09:11:17 <mreh> say I want a default instance of a Pretty class for all show instances, what happens if I implement a specific instance for a type that already implements Show
09:11:59 <jonkri> ddarius: wonderful! i will check it out :)
09:12:11 <jonkri> this is exactly what i was looking for ;)
09:13:19 <lambdabot> http://hackage.haskell.org/package/split
09:13:19 <lambdabot> Not in scope: `splitBy'
09:19:28 <Saizan> jonkri: http://www.haskell.org/pipermail/haskell/2011-January/022497.html <- this too then :)
09:33:13 <dcoutts_> any OSX users around who don't use macports (or similar) who could test new iconv release?
09:33:15 <dcoutts_> http://code.haskell.org/~duncan/iconv-0.4.1.0.tar.gz
09:33:22 <dcoutts_> this should work with the native osx iconv C lib
09:40:37 <Botje> I have the ports version
09:41:11 <mreh> was PrettyPrint.HughesPJ implemented before monads?
09:41:22 <mreh> it's pretty complicated inside
09:41:28 <dcoutts_> mreh: no
09:42:37 <mreh> I suppose you can have monads as soon as you like
09:42:53 <aavogt> before monad transformers were acceptable then?
09:43:03 <dcoutts_> mreh: there's a paper about the design of the library
09:43:41 <mreh> is performance a big motivation?
09:44:37 * JuanDaugherty taps fingers.
09:44:50 <mreh> my first thought would be to implement your printers as monads, then you're definition is executed directly
09:45:08 <JuanDaugherty> *your
09:45:32 <Jafet> Your yore
09:45:39 <mreh> a thousand apologies
09:45:41 <JuanDaugherty> Arrr.
09:46:13 <Jafet> What would a monadic formulation of pretty printing be like?
09:46:16 <Eduard_Munteanu> Hm, arrows seem wonderful.
09:46:38 <applicative> dcoutts is the iconv variant for the sake of the Haskell Platform?
09:46:43 <mreh> Jafet: I've done it, it's logically laid out in the order you want to print
09:46:57 <mreh> it's a WriteT w State s
09:46:58 <dcoutts_> applicative: it's a binding to the iconv C API
09:47:18 <dcoutts_> applicative: I'm not sure what you mean about for the sake of the HP
09:47:30 <applicative> no, i'm seeing what you mean
09:47:53 <mreh> I'm just looking how to lay out this HughesPJ implementation
09:48:39 <dcoutts_> mreh: don't be afraid of reading the design documentation
09:48:50 <applicative> dcoutts_ I had it in my head that the GHC installer supplied us with its own libiconv
09:49:19 <applicative> dcoutts_ but I think I was remembering that macports would supply you with an alien one if you installed it that way. 
09:49:43 <dcoutts_> applicative: ah right, there are certainly issues with iconv on osx because ghc now uses iconv too but the macports version gets in the way and causes no end of problems.
09:50:21 <Eduard_Munteanu> So I presume I can use plain do notation for Kleisli arrows and I need the Arrow notation extension for the others?
09:50:29 <mm_freak_> i have the following type:  data DrawObject = forall obj. Drawable obj => DrawObject obj
09:50:38 <mm_freak_> and i'm processing a [DrawObject]
09:50:41 <Eduard_Munteanu> Though I suppose I'll have to go through Paterson's paper first.
09:50:47 <mm_freak_> how does that work without run-time type information?
09:51:25 <Eduard_Munteanu> mm_freak_: the same way classes work without RTTI?
09:51:41 <Eduard_Munteanu> (typeclasses so there's no confusion)
09:51:46 <mreh> it's statically typed, it doesn't need it surely?
09:52:04 <aavogt> well you don't know which obj you're getting
09:52:04 <mreh> we can be guaranteed the widgets have the right interface
09:52:30 <Eduard_Munteanu> Instances of the class constraints do know something.
09:52:43 <quuuux> wasn't this discussed a few days ago? I think GHC does keep the types lying around, or enough to reconstruct the relevant instances
09:53:07 <dcoutts_> mm_freak_: a dictionary passing impl of classes (like ghc uses) will deal with existential types with class restraints like that by storing a dictionary in the constructor
09:53:40 <monadic_kid> mm_freak_: I'd avoid trying to do a renderer this way It's very OO thinking, I would just consider what collections of data you actually need for various operations, working with sets of data grouped by usage, renderers don't usually care what configuration of data is
09:54:02 <dcoutts_> mm_freak_: ie the actual DrawObject data constructor has two fields, one for a Drawable class dictionary, one for the obj field.
09:54:40 <Heffalump> the existential is basicaly equivalent to passing around a record containing the class members, but less ugly
09:54:48 <dcoutts_> mm_freak_: in other words, it looks almost exactly like a OO object
09:55:43 <dcoutts_> applicative: I don't suppose you have osx and are not using macports and could test the binding?
09:56:23 <mm_freak_> monadic_kid: i don't know how to express this otherwise…  the concept is like follows:  you pass a list of objects to a rendering function, and the function renders pixels using informations from these objects
09:56:36 <mm_freak_> it's not that the objects themselves are rendered directly one by one
09:57:05 <mm_freak_> my main problem is something completely different, i just asked out of curiousity
09:57:12 <mm_freak_> i'm having a serious performance problem
09:57:14 <applicative> dcoutts_ today I have macports unfortunately, but i am about to reinstall everything (thinking of following the 'homebrew' method).  It would probably be a couple of days 
09:57:14 <Eduard_Munteanu> mm_freak_: have a Renderable class, and for each object define the way you get pixels out of it (i.e. an instance)?
09:57:19 <mm_freak_> because i'm writing this entirely in haskell
09:57:39 <mm_freak_> Eduard_Munteanu: that would be inefficient, because in that case each object would need to know about each other
09:58:20 <Eduard_Munteanu> Hm, are referring to culling?
09:58:27 * applicative keeps thinking of ways to get a damned mac to our benefactor dcoutts_ not that they're not a menace
09:58:34 <Eduard_Munteanu> *are you
09:58:52 <dcoutts_> applicative: hmm, actually it might still be an interesting test. I expect that since this binding does not depend on any macports libs or other packages that use macports C libs
09:58:53 <mm_freak_> Eduard_Munteanu: for each frame i iterate over all pixels on the screen, calculate the distance of the pixels to all objects and calculate a color value out of that
09:59:13 <dcoutts_> applicative: do you know how to check what the dynamic binding of an exe is on osx, like ldd on linux?
09:59:18 <Jafet> You're raycasting, mm_freak?
09:59:32 <dcoutts_> applicative: ie so we could test if it's binding to the right C lib
09:59:34 <atp> quick notational question: in CS papers, when they discuss reduction rules in the lambda calculus and its variations, they often use a bar notation, where a horizontal bar separates two (series of) expressions. can anyone cluee me in on how to read this notation?
09:59:34 <mm_freak_> Jafet: nope, it's not raycasting, it's just sort of indirect rendering
10:00:05 <dcoutts_> applicative: I've occasionally looked at mac minis, but they're still quite expensive sadly
10:00:16 <mm_freak_> Jafet: but having this concept it wouldn't be too difficult to add raycasting, if you extend the scene objects to 3D and replace distance calculation by collision detection
10:00:17 <opqdonut_> atp: that's a notation from (intuitionistic reasoning) logic
10:00:47 <opqdonut_> atp: what the rules tell you is "if <things over the line> then <things under the line>"
10:01:07 <opqdonut_> atp: you can read them procedurally too: "if you want to reduca <thing under line>, reduce <things over line>"
10:01:33 <atp> opqdonut_: oh i see. how is it different from standard implication, and also, what does it mean if there's nothing above the line?
10:01:50 <Eduard_Munteanu> It's not different from normal implication.
10:02:04 <Eduard_Munteanu> If there's nothing above the line, then I'd take that to be true no matter what.
10:02:09 <opqdonut_> atp: that means an axiom (in the logic sense) or the base case of the reducing function (in the procedural sense)
10:02:27 <Jafet> mm_freak: not sure what you're doing exactly then, but space partitioning or bounding volumes should work
10:02:42 <atp> opqdonut_, Eduard_Munteanu: great, thanks a bunch for your help!
10:03:27 <Jafet> (You can implement bounding volumes as additional "object" types, which requires no modification in the rendering code)
10:04:00 <opqdonut_> atp: IIRC the book "types and programming languages" by pierce does a good job of explaining rules described in this way
10:04:18 <opqdonut_> it's a great book otherwise, too
10:04:19 <mm_freak_> Jafet: sure, but monadic_kid seems to suggest that the whole concept is bad, and i don't know how to express it better
10:04:39 <azaq23> @bot
10:04:42 * Eduard_Munteanu had problems deciphering TAPL's definition of the turnstile though.
10:05:01 <Eduard_Munteanu> But it's good enough though.
10:05:09 <ddarius> The horizontal bar is an implication.  The turnstile is an implication.  The arrow is an implication.
10:05:10 <atp> opqdonut_: yes, it's been recommended to me before. i've been meaning to pick it up...
10:05:24 <opqdonut_> ddarius: turnstile is not an implication
10:05:38 <applicative> dcoutts_ it cabal installed fine.  what test should i put it to?
10:05:41 <opqdonut_> nor is it useful to regard it as such IMO
10:05:50 <Eduard_Munteanu> Yes, in TAPL the turnstile is a bit different.
10:06:11 <ddarius> opqdonut_: Why do you think it is not a form of implication?
10:06:15 <atp> it's funny how different branches of math get attached to different notations ... i studied math unrelated to CS and never saw the bar notation, but in CS papers I see it everywhere
10:06:21 <Jafet> mm_freak: I'm not sure what monadic_kid is suggesting either, but for drawing and modelling physical things, using an OO design sounds pretty natural
10:06:21 <opqdonut_> the turnstile is generally used for the relation that we define inductively
10:06:21 <dcoutts_> applicative: in the tarball there's an example hsiconv program, if we can compile that and check which C libs it is actually linking to, that'd be great
10:06:21 <Eduard_Munteanu> It's a restricted case of implication for deducing types from a context.
10:06:38 <applicative> dcoutts_ yes I just notice it
10:06:39 <opqdonut_> which can be the typing relation, or entailment in logics, or something else
10:06:44 <mm_freak_> in any case i need a list/set/array/vector/whatever of objects, to which i can refer from a rendering function…  the objects are passive
10:06:51 <Jafet> Many implementations of OO are very inefficient, but that only matters once your algorithms are already optimal
10:06:57 <Eduard_Munteanu> It always comes in a \Gamma, foo:Foo |- bar:Bar form in TAPL
10:06:58 <ddarius> opqdonut_: All of these notations can and are used for different or vaguely related things.
10:06:59 <dcoutts_> applicative: if that prog links and runs, and it linked to the iconv from the system (not macports) then I'm satisfied
10:07:07 <mm_freak_> Jafet: for physical things an FRP approach is better, but this doesn't apply here
10:07:16 <opqdonut_> ddarius: well sure, the turnstile is just the turnstile
10:07:19 <opqdonut_> nothing more
10:07:36 <atp> the turnstile is a symbol?
10:07:41 <opqdonut_> indeed
10:07:43 <ddarius> opqdonut_: Well, yes, it is just syntax.
10:07:43 <opqdonut_> the |- symbol
10:07:46 <atp> oh, right.
10:07:50 <ddarius> But then so is the implication arrow.
10:07:55 <applicative> Is there some verbosity flag that will tell me this?
10:07:56 <monadic_kid> I was not talking about in terms of efficiency
10:08:00 <opqdonut_> yes, I was talking of the meanings usually associated it
10:08:01 <applicative> I cant remembe one
10:08:16 <opqdonut_> they _can_ be seen as implication but I don't think that's useful
10:08:39 <opqdonut_> thinking provability, typing, or whatever the actual concept at hand is is more useful
10:08:56 <dcoutts_> applicative: on ELF platforms there's a program ldd that reports what libs an exe is dynamically linked against (& their path etc)
10:09:00 <ddarius> opqdonut_: Well certainly, but often they are just special cases of implication.
10:09:00 <j-invariant> |-   <--- this symbol
10:09:03 <Eduard_Munteanu> In TAPL it's a more restricted kind of implication.
10:09:05 <dcoutts_> applicative: I presume there's something similar on OSX
10:09:17 <j-invariant> It's so funny how everyone asks "What is |-?"
10:09:24 <j-invariant> it's what's being defined!
10:09:47 <atp> j-invariant: i wouldn't say questions when you aren't clear on a concept are "funny"
10:09:55 <ddarius> The rule, Γ,A |- B --> Γ |- A -> B is notable.
10:10:27 <dcoutts_> applicative: ah, the internets reports that the ldd equiv is otool -L
10:10:27 <geheimdienst> ddarius, your L has slipped and fallen over!
10:10:35 <dcoutts_> applicative: so try otool -L ./hsiconv
10:10:50 <lambdabot> :)
10:11:09 <j-invariant> atp: it is funny that a lot of people ask this
10:11:27 <ddarius> opqdonut_: For example, the type theory form of that (what we would just call lambda abstraction) can be viewed as reifying a meta-level implication into a term level one with proof terms.
10:12:28 <applicative> dcoutt_ yes just found out about otool
10:14:15 <geheimdienst> cale: you around? lambdabot is vibrationally aberrant today. she sometimes responds quickly, sometimes with 1-2 minutes lag
10:14:24 <applicative> here's the report http://hpaste.org/42861/otool_hiconv
10:14:31 <applicative> dcoutts_ ^^^
10:14:46 <Eduard_Munteanu> @vixen geheimdienst is complaining about you.
10:14:48 <lambdabot> are you horny?
10:14:53 <dcoutts_> applicative: ta
10:15:26 <dcoutts_> applicative: ok looks good, and presumably it runs ok, e.g. echo foo | ./hiconv -f utf-8 -t latin1 -
10:15:38 <applicative> yes, i'm thinking of things
10:16:16 <Eduard_Munteanu> I presume I can use plain do notation for Kleisli arrows and I need the Arrow notation extension for the others?
10:17:03 <EvanR> how do i test a fractional number to see if its integral?
10:17:37 <EvanR> truncate x == fromIntegral (truncate x) ?
10:17:51 <EvanR> er
10:17:59 <EvanR> fromIntegral (truncate x) == x
10:19:24 <tolkad> > do { let x = 0 :: Integral a => a; print (x :: Int); print (x :: Integer) }
10:19:25 <lambdabot>   <no location info>: parse error on input `;'
10:19:50 <tolkad> > do { let x = 0 :: Integral a => a; print (x :: Int); print (x :: Integer) } :: IO ()
10:19:51 <lambdabot>   <no location info>: parse error on input `;'
10:20:11 <applicative> dcoutts_ so far it seems good.  for some reason it isn't accepting stdin, but writes to stdout
10:20:23 <tolkad> > let x = 0 :: Integral a => a in print (x :: Int) >> print (x :: Integer) :: IO ()
10:20:24 <lambdabot>   <IO ()>
10:21:00 <dcoutts_> applicative: use - as the input filename for stdin
10:21:12 <dcoutts_> applicative: ok, glad it's working, I'll do the release...
10:21:54 <applicative> dcoutts_, yes I thought that wasn't working, it was just that curl http://tunes.org/~nef/logs/haskell/11.01.08 | ./hiconv  -f utf-8 -t latin1 - 
10:22:17 <applicative> but it was because of something edward k said :)   curl http://tunes.org/~nef/logs/haskell/11.01.08 | ./hiconv -c -f utf-8 -t latin1 - 
10:22:19 <applicative> does work
10:22:34 <dcoutts_> ok
10:23:45 <applicative> so i guess that's an adequate argument that it's linking properly etc?  
10:27:21 <tester007> Hello  is anyone familiar with the HaskellMath package, in particular with the PermutationGroups module?
10:27:21 <tester007> sorry, I meant the Haskell for Maths library   anyone could help me about it?
10:27:52 <j-invariant> tester007: I could have a look and try to help if nobody knows it
10:27:59 <ksf> lookup/go                      Main                  24.3   47.0
10:27:59 <ksf> initBucket                     Main                  16.4    0.0
10:27:59 <ksf> new                            Main                  10.5    0.0
10:27:59 <ksf> hashGenome                     Main                   8.6    5.1
10:28:00 <ksf> \o/
10:28:33 <geheimdienst> i often got to things like «lift (withDisplay (\d -> lift $ xftSomething d x y z))». how would i make a function "displify" that lets me write this as: «displify xftSomething x y z»?
10:28:53 <geheimdienst> i've tried some things but ghc keeps telling me my points-free-fu is too weak
10:29:12 <tester007> j-invariant: there's an operator on permutations, (-^), which I do not understand how works
10:29:18 <geheimdienst> *i often got to do things like
10:30:03 <j-invariant> tester007: well he is using it here http://haskellformaths.blogspot.com/
10:30:08 <j-invariant> I guess it's introduced earlier
10:31:02 <j-invariant> # e -^ g - the action of a permutation on an edge
10:31:28 <tester007> thanks, I will look at it     I'd expect this operator to produce the image of an input vector under a given permutation
10:32:04 <j-invariant> tester007: http://hackage.haskell.org/packages/archive/HaskellForMaths/0.3.1/doc/html/src/Math-Algebra-Group-PermutationGroup.html#-^
10:32:09 <applicative> dcoutts_ seems the executable is working well, now that I understand it.  be good
10:32:26 <j-invariant> it's basically just applying x .^ g to every element x 
10:32:29 <j-invariant> then sorting it
10:33:47 * hackagebot lambdacat 0.1.0 - Webkit Browser  http://hackage.haskell.org/package/lambdacat-0.1.0 (AndreasBaldeau)
10:33:57 <burp> oh!
10:34:04 <tolkad> Can I rexport a module with an as'd name?
10:34:16 <tester007> so it's not the image as I'd expect: [0,1] ^- (p [[0,1]]) -> [1,0]
10:34:22 <mauke> you can't re-export modules with any name
10:34:26 <tolkad> like « module A (module B as C) »
10:34:38 <tolkad> mauke: what about like that?
10:34:43 <mauke> you can't re-export modules with any name
10:34:57 <mauke> your caller won't see B nor C
10:35:49 <tolkad> oh
10:35:58 <tolkad> then what's the purpose of putting modules in the export list?
10:35:59 * ddarius looks at strops.
10:36:06 <mauke> re-exporting their symbols
10:36:20 <dcoutts_> applicative: thanks!
10:36:46 <tolkad> I wish ghc wouldn't give me warnings that I am re-exporting the same symbols twice
10:37:41 <erik_> hey all
10:37:43 <burp> tolkad: -Wall doesn't do it?
10:38:09 <tolkad> burp: oh that works
10:38:32 <jix> tolkad: -f(no-)warn-duplicate-exports for fine tuning
10:38:43 <tolkad> what is -Wall?
10:38:50 <tester007> j-invarian: thanks, solved it 
10:38:57 <jix> tolkad: enables all (or most?) warnings
10:38:57 <burp> tolkad: enables all warnings
10:39:04 <burp> -fwarn-duplicate-exports is sufficient for you though
10:39:12 <erik_> i was wondering if anyone has encountered the following error when trying to install packages under ghc7: cannot find -lHStransformers-0.2.2.0-ghc7.0.1
10:39:36 <tolkad> jix: but it DISABLED this warning
10:39:48 * hackagebot zlib 0.5.3.1 - Compression and decompression in the gzip and zlib formats  http://hackage.haskell.org/package/zlib-0.5.3.1 (DuncanCoutts)
10:40:40 <tolkad> oh now they are back
10:40:45 <jix> tolkad: with no- it disables without it enables
10:40:48 <tolkad> it didn't compile the file
10:40:49 * hackagebot bzlib 0.5.0.1 - Compression and decompression in the bzip2 format  http://hackage.haskell.org/package/bzlib-0.5.0.1 (DuncanCoutts)
10:40:51 * hackagebot iconv 0.4.1.0 - String encoding conversion  http://hackage.haskell.org/package/iconv-0.4.1.0 (DuncanCoutts)
10:41:03 <tolkad> thanks
10:41:16 <jix> tolkad: I usually use -Wall and then selectivly disable warnings that annoy me
10:42:26 <tolkad> ooh, thanks for warning me I didn't have a type signature for main, who knows what type it could have had if I didn't make that explicit
10:48:44 <geheimdienst> @pl (\x -> succ (3+x))
10:48:45 <lambdabot> succ . (3 +)
10:48:47 <erik_> if anyone has a second, i know i'm probably just missing some flag, but just wondering what the "-lHS" means on the front of the allegedly missing transformers
10:49:59 <geheimdienst> @pl (\x ->  (3+x) * 7)
10:50:00 <lambdabot> (7 *) . (3 +)
10:53:59 <Ornedan> Is there some command / flag in cabal that'll make it download missing dependencies when building from a .cabal file?
10:54:22 <dcoutts_> Ornedan: you can just cabal install
10:54:30 <mm_freak_> seems like haskell is just not suitable for low level graphics
10:54:50 <dcoutts_> Ornedan: we'll likely add a --only-dependencies flag soonish which will mean it doesn't build the current package itself, just deps
10:55:13 <Ornedan> Thanks. And that would be handy
10:55:52 * hackagebot lambdacat 0.1.1 - Webkit Browser  http://hackage.haskell.org/package/lambdacat-0.1.1 (AndreasBaldeau)
10:59:39 <mm_freak_> is there a way to improve the speed of floating point arithmetic?
11:01:04 <msieradzki> -fexcess-precision?
11:01:14 <msieradzki> on 32-bit GHC -msse(2)
11:01:16 <c_wraith> mm_freak_: well, I'd suggest two steps.  first, look to see if the core is using native ops or not.  second, if it is using native ops, switch to the llvm backend
11:01:21 <msieradzki> also LLVM
11:01:26 <msieradzki> like he said ^^^
11:01:31 <tester007> Please advice me about how to build a 2d table of literal integers for effective lookup
11:01:38 <c_wraith> But my first guess is you've got something going on that's making it not use the native ops
11:01:41 <mm_freak_> hmm…  it seems to be time to switch to GHC 7
11:01:49 <mm_freak_> i have GHC 6.12 here
11:02:01 <msieradzki> yes, I had significantly faster code with -fllvm with 7.0.1
11:02:11 <msieradzki> vs 7.0.1 and C/native gen
11:03:17 <erik_> does anyone have any idea why i might get this error when cabal installing "There is no available version of ghc that satisfies -any"
11:03:22 <erik_> im pretty sure i have ghc 
11:03:24 <erik_> lol
11:03:36 <c_wraith> erik_: you're using the debian/ubuntu ghc install?
11:03:38 <megatron242> Hi, I've got a small question about the State monad.
11:03:42 <monochrom> you made a mistake
11:03:42 <mm_freak_> -fexcess-precision didn't help…  i hope GHC 7 will be in arch soon
11:04:08 <erik_> c_wraith: i'm on ghc7
11:04:08 <j-invariant> I can't program in haskell because of the types being problematic... but I'm too scared to program without types
11:04:11 <msieradzki> -funbox-strict-fields (look up man it might be slightly different name)
11:04:21 <c_wraith> erik_: the "ghc" package is the ghc api.
11:04:23 <dcoutts_> erik_: ghc-pkg list ghc ?
11:04:41 <megatron242> I'm a bit confused by a function signature that uses a State monad. There seems to be only one parameter.
11:04:41 <monochrom> oh, fedora! needs another rpm
11:04:57 <roconnor> j-invariant: what do you mean the types are problematic?
11:04:59 <megatron242> What am I missing?
11:05:03 <monochrom> (I hate fedora for that.)
11:05:04 <c_wraith> I really hate that OS packagers are *removing* packages from the default install of GHC
11:05:08 <j-invariant> roconnor: I couldn't use type safe progrmaming
11:05:10 <erik_> c_wraith: it says i have ghc7.0.1 with ghc-pkg list
11:05:10 <c_wraith> monochrom: debian does the same thing
11:05:12 <roconnor> j-invariant: last time the problem was that the types were not catching enough errors
11:05:22 <j-invariant> yes that is my problemk
11:05:41 <monochrom> no no no, debian is a bit better.
11:05:47 <roconnor> j-invariant: I think Agda supports Haskell extraction.  You could write some of your functionality in Agda.
11:05:53 <roconnor> in theory
11:05:54 <msieradzki> newtype State s a how does that have only 1 type parameter?
11:05:57 * roconnor has never tried
11:06:02 <j-invariant> I wonder if that's a good idea
11:06:10 <j-invariant> my problem was really the typeclasses
11:06:14 <megatron242> Did anyone got my question?
11:06:15 <j-invariant> I wonder how I could do that in agda
11:06:25 <c_wraith> msieradzki: it has two.  But the Monad instance is for "State s".  That is, the type constructor is partially applied
11:06:26 <msieradzki> megatron242, what signature
11:06:29 <azaq23> msieradzki: The State Monad is (State s), not State itself
11:06:29 <monochrom> debian's ghc deb includes the ghc-api. fedora's ghc rpm doesn't.
11:06:38 <roconnor> j-invariant: well, there are tricks you can do to get a surprising abount of type safty in Haskell
11:06:56 <c_wraith> Oh, debian leaves out the profiling libraries.  That's what it does that's so annoying
11:06:58 <erik_> hmm ghc-pkg list ghc says that ghc-7.0.1 i broken
11:07:03 <roconnor> j-invariant: non-uniform recursive types can get you a surprising amount of sophisticated types
11:07:05 <j-invariant> roconnor: I think my case is impossible because oleg and shan use unsafePeformIO to do it
11:07:09 <j-invariant>                      shan use unsafePeformIO to do it
11:07:12 <j-invariant> oops
11:07:13 <monochrom> ah, I personally don't miss profiling
11:07:13 <roconnor> j-invariant: and then GADTs can give you enven more
11:07:26 <megatron242> A function that uses a state monad.
11:07:40 <msieradzki> megatron242, you got your answer above
11:07:57 <roconnor> j-invariant: heh, you could be right, but I don't know what you are trying to do.
11:07:58 <monochrom> anyway I agree with you in spirit. distros hair-split packages too much.
11:08:03 <erik_> c_wraith: have any idea how to go about fixing the ghc api that it thinks im missing?
11:08:43 <c_wraith> erik_: if it says the ghc api is broken, I don't know any way to fix that short of reinstalling ghc
11:09:02 <erik_> yeah i just reinstalled it too which is curious to me
11:10:04 <mm_freak_> no chance to get better performance =/
11:10:06 <megatron242> OK, now I see the answer, but I still don't get it. For instance, I have a function that parse a number from a bytestream: type Parser a = State B.ByteString a, parseLittle32 :: Parser Word32.
11:10:09 <mm_freak_> i'll wait for GHC 7
11:10:09 <monochrom> you installed ghc7 by obtaining from where?
11:10:33 <ksf> hmmm unaligned 64-bit reads aren't particularily efficient are they?
11:10:42 <megatron242> I can use it, but I still don't get the logic behind it...
11:11:01 <mm_freak_> monochrom: who?
11:11:07 <monochrom> erik_
11:11:08 <aristid> ksf: unaligned reads are rumored to be slow
11:11:10 <mm_freak_> ah, ok
11:11:48 <monochrom> unaligned 64-bit reads aren't efficient.
11:11:58 <ksf> looking up what bucket to increase (O(1)) is just as fast as looking up the bucket (O( bigger 1))
11:12:03 <megatron242> Why is the declartion of parseLittle32 valid?
11:12:23 <ksf> hmmm I generally don't have any padding anywhere.
11:12:54 <megatron242> Anyone?
11:12:56 <erik_> monochrom: i downloaded it from the haskell site
11:12:58 <msieradzki> megatron242, get haskell book
11:13:01 <monochrom> "parseLittle32 :: Parser Word32" = "parseLittle32 :: State B.ByteString Word32". Looks fine to me.
11:13:11 <erik_> monochrom: the main 7.0.1 download
11:13:43 <msieradzki> RWH/LYAH/yaht I don't know
11:13:48 <monochrom> then it already has the ghc-api.
11:13:50 <ksf> well... the fun thing is that I can fix those nonaligned reads by throwing ram at them, the code's already there because I'm saving 4 values in a single byte
11:13:57 <azaq23> megatron242 you need to be more precise
11:14:17 <erik_> monochrom: is there a better place to download?
11:14:25 <ksf> but then, it's time to call it a day.
11:14:36 <azaq23> @unmtl State B.ByteString
11:14:37 <lambdabot> err: `State B.ByteString' is not applied to enough arguments, giving `/\A. B.ByteString -> (A, B.ByteString)'
11:14:40 <monochrom> no, that's the best place already. your problem shouldn't happen.
11:14:47 <msieradzki> Parser has 1 type argument, State has 2 so you can bind one type parameter of State and call it "Parser"
11:14:47 <megatron242> I'll ignore the rude answers, and for the record, I read quite a lot tutorials about it.
11:14:49 <ksf> in the end, though, this should be awesomely fast.
11:15:26 <msieradzki> then when you apply second parameter you have complete type (of kind *)
11:15:41 <megatron242> For normal functions, I have something like this: foo :: a -> b, where a is the input and b is the output. Here I only have one argument. So it confuses me.
11:15:54 <mm_freak_> how can i construct a Double# value?
11:16:06 <ksf> ...averaging just slightly more than a cache miss for each nucleotide fragment scanned.
11:16:25 <jix> megatron242: you aren't defining a function you define a value
11:16:50 <msieradzki> newtype State s a = State { runState :: s -> (a, s) }
11:17:06 <msieradzki> there's function underneath it
11:17:18 <erik_> monochrom: i'm going to retry witht he 7.0.1.2010120 version from the stable branch
11:17:18 <megatron242> jix: OK, so what looks like a function, is actually a value?
11:17:34 <msieradzki> you pack a function inside value of type State
11:17:35 <c_wraith> all functions are values in haskell
11:17:50 <erik_> or perhaps the 7.0.2RC
11:17:53 <jix> but this value isn't a function
11:17:55 <erik_> live on the edge
11:17:56 <erik_> lol
11:17:57 <c_wraith> what's interesting about State is that the function is specially wrapped.
11:18:06 <darrint> Is there a function in Text.Text for doing replacement?
11:18:17 <c_wraith> Which means, yes, it's a function.  But you can't apply it directly.
11:18:22 <c_wraith> darrint: yes
11:18:37 <c_wraith> darrint: err, sorry, I don't know.  I misread that as Data.Text
11:18:42 <jix> megatron242: so there is a function hidden in the State but the State itself isn't a function
11:18:56 <darrint> c_wraith: Sorry. I meant Data.Text.
11:19:18 <c_wraith> darrint: oh, then my first answer applies.  yes. :)
11:19:21 <megatron242> well, sorry for the ignorance, but it looks that Haskell is sort of broken, if it's so confusing.
11:19:29 <darrint> c_wraith: Care to name that function?
11:19:34 <erik_> darrint: replace should work
11:19:55 <msieradzki> megatron242, did you read "Yet Another Haskell Tutorial"?
11:20:08 <msieradzki> they explain it all very slowly and it helped me a lot
11:20:13 <darrint> Duh. Didn't search hard enough because "replacement" appears a zillion time in the haddock. Thanks.
11:20:18 <erik_> darrint: you'll need text.regex.pcre if you want to do really fancy substitutions though
11:20:24 <erik_> lol
11:20:49 <monochrom> I think YAHT is too slowly.
11:20:54 <megatron242> msieradzki: I did. I quit in the chapter about IO. Exactly, for the reason that it didn't make any sense.
11:21:05 <monochrom> Also too many repetitive exercises.
11:21:13 <msieradzki> you can skip them
11:21:38 <msieradzki> I don't even think that IO chapter contained anything useful
11:21:56 <megatron242> Look, I can use the State monad, and in fact I did. But I admit that I did it by merly copying some examples I saw, without really understandig the idea behind it.
11:21:58 <msieradzki> more like "5 functions here if you are desperate to use IO that early, before Monad explanation)
11:22:20 <msieradzki> and monad, do you understand what it is?
11:22:46 <monochrom> But most importantly I think there is no need to answer "sorry for the ignorance, but it looks that Haskell is sort of broken, if it's so confusing." You know, "ignore rude statements" and all that.
11:23:50 <megatron242> monochrom: Well, if it so difficult to understand and confusing...
11:24:07 <jix> megatron242: it isnt
11:24:09 <copumpkin> megatron242: that's a function of the understander AND the thing being understood
11:24:24 <copumpkin> megatron242: I had no trouble understanding it
11:24:31 <copumpkin> nor did many of the people in here
11:25:01 <copumpkin> megatron242: you're not going to encourage people to help you by telling them their language is broken. It's just arrogance to assume that if you can't understand something it's somehow its shortcoming rather than yours
11:25:08 <msieradzki> the only difficult part might be to unlearn expectation from C++/OO languages where you can read many lines of code and understand them fast
11:25:11 <roconnor> @unmtl State B.ByteString a
11:25:16 * monochrom is tired of people who classify back-to-basic explanations as rude. Fact is, no one knows how much you already know, how could anyone magically give an answer at the right level?
11:25:57 <megatron242> Great, so you are all smart. It's sort of contradiction, to the fact that there are many references in the web, that Monad are very complicated to new comers.
11:25:57 <azaq23> megatron242: Even if we want to follow that thought process, learning something is not a linear process. If you have one central misunderstanding, surely the rest won't make sense. So you can't generalize like that
11:25:57 <drv__> programmrs 
11:26:11 <geheimdienst> copumpkin: monochrom: i'm with megatron242 here. he asked "... bytestream: type Parser a = State B.ByteString a, parseLittle32 :: Parser Word32. Why is the declaration of parseLittle32 valid?", and the first response was "megatron242, get haskell book"
11:26:12 <roconnor> @unmtl State B.ByteString Word32
11:26:13 <geheimdienst> that's not even grammatical, and redundant because you can say that for every question ever asked in here
11:26:18 <copumpkin> megatron242: yes, and I'd argue that beginners shouldn't even try to learn monads, which would stop them making such a big deal about them, since they aren't really that fundamental
11:26:25 <geheimdienst> saying "i'll ignore the rude answers" is appropritate in my opinion
11:26:41 <monochrom> I see. sorry.
11:27:09 <drv__> i need a project in c
11:27:09 <msieradzki> geheimdienst, I meant
11:27:09 <drv__> anyone who can help me?
11:27:09 <erik_> i think reading the monadologie is a good way to understand monads
11:27:11 <megatron242> On any rate, the fact that I'm here, is obviously because I like Haskell _very_ much, and I want to improve in it.
11:27:11 <drv__> any good projects in c?
11:27:11 <msieradzki> that's basic question and I don't know much he knows so it's easier for both of us if he gets a book
11:27:21 <monochrom> there is no good project in c.
11:27:21 <dolio> roconnor: Since you're around: the only functions from the reals to {true, false} are const true and const false, right?
11:27:23 <msieradzki> it's explained right after IO chapter in YAHT
11:27:30 <aristid> drv__: how about asking in ##c?
11:27:49 <drv__> naa
11:27:51 <drv__> i need in c
11:28:03 <roconnor> dolio: the only (total) continous functions from the reals (that respect the equivelence relation on the reals)  are like that.
11:28:10 <megatron242> msieradzki: So, I guess I'll read it.
11:28:33 <drv__> pla give me a c 0r c++ pro
11:28:50 <roconnor> megatron242: ignore msieradzki and come to #haskell-overflow and I'll try to answer your question
11:29:19 <copumpkin> megatron242: but I agree that the answer wasn't terribly useful :) stepping back from the hostility briefly, I'd really advise against taking all the monad hype seriously, and to approach them tangentially rather than "I'm going to learn monads today"
11:29:29 <copumpkin> -briefly
11:29:52 <rumbold1> how am i supposed to debug my haskell program if i cant print stuff all over my functions? :(
11:30:03 <monochrom> I did "I'm going to learn monads today". But I read Wadler's tutorial for that.
11:30:15 <jix> rumbold1: Debug.Trace
11:30:20 <alpounet> rumbold1, google for "Debug.Trace.trace"
11:30:27 <jix> rumbold1: but use it only for debugging!
11:30:42 <monochrom> Debug.Trace can print stuff all over your functions. Also all over your values, in case your values aren't functions.
11:31:42 <copumpkin> rumbold1: as others have said Debug.Trace works, but most of the time we try to break our functionality into small reusable (general) functions that can be tested individually, and then build them up into the final desired functionality in a way that is obviously correct if the building blocks are
11:31:51 <megatron242> Well, it's not like knowing Monad would make me the most popular kid in school ;) And again, I can use it in practice. It's just that I want to understand it 100%.
11:32:06 <jmcarthur> that is an impossible task
11:32:20 <monochrom> don't take "100%" too literally.
11:32:23 <Eduard_Munteanu> In Haskell monads understand you 100%.
11:32:29 <roconnor> megatron242: come to #haskell-overflow and I'll try to answer your question
11:32:30 <copumpkin> those are comonads
11:32:55 <monochrom> comonads are about to understand copumpkin 100%
11:33:06 <copumpkin> megatron242: beware, roconnor's inviting you alone into a small quiet room with not many people in it...
11:33:08 <Cale> @bot
11:33:09 <lambdabot> :)
11:33:11 <ksf> haskell isn't about monads.
11:33:11 <Eduard_Munteanu> Yeah, #haskell-overflow is the main channel now, #haskell is for offtopic only :P
11:33:14 <msieradzki> actually I was wrong, I read YAHT so long ago  that I forgot how it's laid out, megatron would have to read it all to get to parse32 part
11:33:14 <monochrom> will happen when copumpkin finishes the agda proofs :)
11:33:18 <jmcarthur> for most definitions of 100%, i would caution against overestimating the value of such a level of understanding
11:33:29 <roconnor> msieradzki: exactly
11:33:37 <copumpkin> monochrom: lol, the proof I was trying (of edwardk's comonad) turned out not to be a comonad, so I'm not too surprised I wasn't able to prove it
11:33:47 <ksf> I'm doing a lot of IO-level monadic programming right now and it doesn't really feel like haskell.
11:33:48 <roconnor> copumpkin: you should come too
11:33:50 <azaq23> megatron242: I suggest you just follow this channel for a while, there a discussion about them all the time, so you will likely pick it up successively
11:34:07 <ksf> makes me want to scatter unsafePerformIO all over the place.
11:34:22 <megatron242> OK, thanks everyone for the help.
11:34:23 <jmcarthur> ksf: i look at IO as an embedded imperative language, so in that sense it's *not* haskell
11:34:32 <ksf> yeah, exactly.
11:34:52 <megatron242> Sorry, if I was a bit rude :)
11:35:02 <ksf> and it likes to segfault when proper code would give a useful pattern match error or somethnig.
11:35:17 <megatron242> It's because I like Haskell, and I really want to fully understand it.
11:35:51 <ksf> haskell is also "(x *<< y) f = poke (f x) =<< peek (f y)"  , though.
11:35:59 <ksf> try to do that in C.
11:36:02 <monochrom> I denounced "understanding" and ironically since then I have understood more.
11:36:49 <roconnor> I think you are all being flippant towards megatron242's serious question.
11:37:12 <LittleEndian> monochrom: lol
11:37:19 <ksf> understanding is principially based on wishful thinking.
11:37:37 <monochrom> I replaced "understanding" by more exercises: symbolic manipulations on the theory side, coding on the practice side.
11:37:52 <ddarius> geheimdienst: You can't actually say "get haskell book" to everything that is asked here.  If that were so, I wouldn't be here at all.
11:38:16 <LittleEndian> OK I am totally new to functional programming, is "Real World Haskell" a good buy, or should I buy something else?
11:38:21 <ddarius> monochrom: I thought you symbolically manipulated your code.
11:38:31 <roconnor> ddarius: exactly
11:38:32 <monochrom> yes that too
11:38:33 <ddarius> LittleEndian: You can read RWH for free if you want.
11:38:44 <lelf> ?pl \f x y -> poke (f x) =<< peek (f y)
11:38:45 <lambdabot> liftM2 flip (((.) . (=<<) . poke) .) (peek .)
11:39:00 <lelf> yup, try that in C
11:39:03 <ksf> that elated feeling of grokking is the real stuff. everything else is just you lying to yourself to help you concentrate.
11:39:28 <ksf> understanding is, mentally seen, an entirely passive task.
11:39:45 <LittleEndian> ddarius: true, but the biggest investment is the time spent to read the book... (if the money involved is piddly that is)
11:40:08 * hackagebot epub-metadata 2.0.1 - Library and utility for parsing and manipulating ePub OPF package data  http://hackage.haskell.org/package/epub-metadata-2.0.1 (DinoMorelli)
11:40:12 <ddarius> LittleEndian: RWH is adequate.
11:40:24 <LittleEndian> ddarius: thanks a ton :o)
11:40:24 <ddarius> LittleEndian: Though what's best for you, depends mostly on you.
11:40:25 <roconnor> you guys suck
11:40:28 <monochrom> you could assess online whether you like RWH enough to buy
11:41:33 <monochrom> dear roconnor, despite your noble cause, I think the real problem is that megatron failed to articulate his serious question, no matter how serious it is.
11:41:35 <ddarius> LittleEndian: You could go through the Gentle Introduction.  It's fairly short and reasonably comprehensive (for Haskell 98), but many people think it is "difficult."
11:41:44 <LittleEndian> monochrom: I want opinions on what helped make a transition
11:42:17 <roconnor> monochrom: well asking a question about something you don't understand is difficult.  He was tyring to articulate but you guys shot him down at every step of the way.
11:42:21 <ddarius> copumpkin: Did you start your bread?
11:42:25 <monochrom> heeding a lot of advice from dijkstra
11:42:35 * ddarius is all for shooting people.
11:42:35 <roconnor> s/well//
11:43:01 <copumpkin> ddarius: nope, turns out I didn't have any yeast. Will probably go to store in a bit
11:43:25 <j-invariant> i don't understand how the skilled haskell porgrammer can do it it's like another language to me
11:43:37 <ddarius> copumpkin: Yeah.  The preparation is pretty quick and easy.  Really, the most manually time-consuming process is shaping.
11:43:49 <ddarius> j-invariant: It -is- another language.
11:43:56 <j-invariant> lol
11:44:13 <LittleEndian> ddarius, copumpkin - are you guys seriously into making bread?
11:44:18 <copumpkin> ye[
11:44:22 <roconnor> j-invariant: years of practice and learning techniques.
11:44:26 <copumpkin> well, I'm trying to get better at it :)
11:44:40 <LittleEndian> copumpkin: cool, I bake my own too
11:44:52 <j-invariant> I found haskell gets harder to program in the more you learn
11:45:26 <roconnor> j-invariant: only because you are trying to incorporate more and more invarients into your type and getting stronger guarentees
11:45:30 <ddarius> j-invariant: Perhaps your standards are changing, which isn't a bad thing.
11:45:31 <LittleEndian> j-invariant: on a philosophical level, I think that statement doesn't make sense
11:45:34 <j-invariant> yes I suppose so
11:45:48 <roconnor> fv
11:45:59 <roconnor> and my cat just walked over the keyboard
11:47:30 <mm_freak_> ksf: what's (*<<)?
11:47:57 <mm_freak_> and where do i find it?
11:49:26 <comex> that's certainly true for PHP.
11:51:14 <monochrom> roconnor: apart from "get haskell book" (which could be explained) I find the opposite. megatron was shooting down every attempt at clarifying or resolving the question. For example, megatron: "For normal functions, I have something like this: foo :: a -> b, where a is the input and b is the output. Here I only have one argument. So it confuses me." OK good question. There were several attempted answers, perhaps most notably ji
11:51:14 <monochrom> x: "you aren't defining a function you define a value" You know what's megatron's conclusion? "well, sorry for the ignorance, but it looks that Haskell is sort of broken, if it's so confusing." That is he shooting down all of our help. And the jewel of the crown: He ignored your multiply asserted offer to explain afresh in -overflow.
11:52:24 <copumpkin> omg comex speaks
11:53:10 * ddarius doesn't understand the significance of that.
11:53:18 <aristid> comex!
11:53:35 <aristid> copumpkin: is comex your bot? :P
11:53:41 <comex> yes
11:53:56 <aristid> comex: sudo make me a sandwich
11:54:03 <copumpkin> comex: 5 + 7
11:54:14 <comex> make: *** No rule to make target `me'.  Stop.
11:54:17 <j-invariant> what is it made in?
11:54:21 <ddarius> copumpkin: Incidentally, continuing one conversation from yesterday, the time it took me to learn category theory also included learning many other areas of mathematics and wasn't a continuous sustained effort (at CT.)
11:54:27 <copumpkin> j-invariant: I wrote it in PHP
11:54:50 <geheimdienst> > make clean
11:54:51 <lambdabot>   Not in scope: `make'Not in scope: `clean'
11:54:54 <copumpkin> the spaghetti code was so messy it developed consciousness
11:54:59 <aristid> comex: make clean
11:55:02 <j-invariant> comex: 2.2250738585072011e-308;
11:55:05 <geheimdienst> comex: sudo echo lolcats
11:55:12 <copumpkin> j-invariant: nah, I updated it
11:55:16 <aristid> j-invariant: now you hanged him
11:55:17 <copumpkin> ddarius: ah, I see
11:55:24 <roconnor> monochrom: I see.  Perhaps you are right
11:55:41 <LittleEndian> lol @ j-invariant
11:55:51 <dom96> comex: sudo restart
11:55:53 <comex> j-invariant: NULL
11:56:06 <comex> dom96: sudo: restart: command not found
11:56:08 <ddarius> Back in my day, hanging required quite a bit more rope.
11:56:28 <LittleEndian> ddarius: talk about it
11:56:38 <comex> (perhaps you mean reboot0
11:56:39 <dom96> comex: sudo shutdown -r now
11:56:43 <applicative> copumpkin, I glanced at the github 'recently updated haskell repositories' last night, and came across ... idiom brackets.  Very high style. 
11:56:49 <comex> dom96: no
11:56:57 <j-invariant> it doesn't seem so much like a bot as a client ..
11:57:08 <dom96> comex: Aww :(
11:57:14 <copumpkin> applicative: it cleaned stuff up a lot :) I plan to move some of my other machinery into SHE too, and generally clean it up. Maybe comex will appreciate me then :(
11:57:56 * comex was reading a book the other day in which SHE stood for Secure Hardware Environment, but does not know what it means in this context
11:58:04 <aristid> copumpkin: comex is written in PHP, how can he possibly appreciate that?
11:58:10 <applicative> copumpkin, yeah I checked the diff.  It is characteristic of one really good use of them.
11:58:14 <copumpkin> as edwardk says, "all natural strathclyde haskell enhancement"
11:58:31 <aristid> copumpkin: lol i would actually have typed that correctly!
11:58:47 <Gunni> can someone explain this: https://gist.github.com/771104
11:58:47 <aristid> strathclyde
11:58:49 <copumpkin> aristid: as I said, it became aware, from the huge mess of PHP code I wrote
11:59:02 <copumpkin> now it's pretty smart
11:59:07 <applicative> did you see the video of pigworker's lectures somewhere, the first was all SHE, I haven't looked at the Agda ones yet
11:59:34 <aristid> Gunni: you sent kill -9?
11:59:37 <Gunni> no
11:59:52 <copumpkin> applicative: yeah, that was part of the inspiration actually. Was just watching it the other day, and although I'd used the auto datalifting + "pi" types before, the idiom brackets are more useful for that package
11:59:58 <Gunni> clean system, virtualized in virtualbox 
12:00:11 <Gunni> only me logged on once, on that session
12:01:23 <Gunni> btw aristid this is 100% reproducable
12:01:35 <Gunni> i can run it over and over and it kills always in that same spot
12:01:54 <comex> ulimit?
12:01:55 <applicative> copumpkin, cool.   He managed to make the open and closed filehandle business clear; I found it impenetrable in whatever I read first.
12:02:13 <mm_freak_> are there any alternative compilers, which have better low level performance than GHC?
12:02:17 <Gunni> comex nothing else is running on that machine
12:02:31 <mm_freak_> i'd really like to avoid resorting to C
12:02:43 <copumpkin> applicative: yeah, I want more from him!
12:03:02 <applicative> let's go get advanced degrees at Strathclyde!
12:03:12 <copumpkin> sounds good :D
12:03:20 <copumpkin> we can be the pigminions
12:03:29 * applicative doesn't have the prerequisites, but he's earnest
12:03:49 <aristid> mm_freak_: you already have performance issues?
12:04:26 <Gunni> can someone help me solve this bug?
12:04:38 <Gunni> https://gist.github.com/771104 makes no sense
12:04:43 <copumpkin> applicative: AND on the front page of strath.ac.uk, the first item is "fully funded PHDs"
12:04:44 <j-invariant> applicative: you might be able to apply anyway
12:05:05 <copumpkin> I'm kinda not in the mood for more PhD right now
12:05:09 <copumpkin> but maybe in a few years
12:05:09 <j-invariant> How does one decide if they are capable of doing a PhD?
12:05:26 <j-invariant> (other than waste 5 years failing)
12:06:02 <applicative> being a graduate student is the ultimate pleasure, never mind that it's insane
12:08:17 <mm_freak_> aristid: i'm still experimenting, but my graphics library is currently much too slow
12:08:25 <mm_freak_> it uses direct memory access to the video buffer
12:08:30 <mm_freak_> and is written completely in haskell
12:08:44 <mm_freak_> interestingly the memory access itself is very fast, and i think i've spotted the bottleneck
12:08:59 <mm_freak_> the overloading i think
12:09:24 <jix> mm_freak_: is your code online somwhere?
12:09:28 <Gunni> here is a compile using -v3 http://pastebin.com/gkPyPCL8 makes no sense to me
12:09:56 <medfly`> j-invariant, you finish studying for two degrees and you still don't want to quit it and just get a job, I suppose
12:09:59 <medfly`> :]
12:10:10 <jix> Gunni: OOM killer maybe?
12:10:15 <Gunni> oom killer?
12:10:17 <medfly`> j-invariant, also, school accepts you
12:10:20 <jix> Gunni: out of memory
12:10:31 <medfly`> j-invariant, I'd say that's where 99.9% of the people fail.
12:10:38 <Gunni> 1 G or memory, 446 mb free before compile
12:10:47 <Gunni> ill start htop next to it
12:10:56 <monochrom> linking a lot of stuff takes a long time and a lot of memory. I heard that even 2G is not enough. :)
12:11:29 <monochrom> two work arounds: dynamic linking. the gold linker.
12:12:01 <mm_freak_> jix: not yet
12:12:09 <monochrom> hmm I should give the gold linker a try so I can tell you "works for me" or "doesn't work for me". I heard two different testimonies.
12:12:27 <mm_freak_> jix: i don't like to upload half-baked stuff to hackage =)
12:12:45 <augur> conal: hey dude
12:13:12 <Gunni> jix yep i just saw it, oom killer
12:13:18 <conal> augur: hey
12:13:21 <Gunni> adding more virtual ram :)
12:13:36 <monochrom> what! virtual ram! you're in a virtual machine?!
12:13:41 <Gunni> yes
12:13:49 <ddarius> monochrom: I hear it's significantly better but still not geared to the type of object files GHC produces with -split-objs.
12:13:59 <monochrom> then give it 100G and 32 virtual CPUs while you're at it XD
12:14:01 <augur> conal: whats your opinion on using threads as a way of handling non-deterministic computation that is more like proof search? :x
12:14:10 <Gunni> monochrom i wish i could
12:14:46 <monochrom> well I don't suppose one would need -split-objs if the linker were more efficient
12:14:52 * edwardk waves hello.
12:15:04 <conal> augur: do you really want nondeterministic semantics?
12:15:20 <conal> augur: (makes reasoning more difficult)
12:15:28 <augur> conal: i think so. i mean
12:15:48 * geheimdienst meows at edwardk in a friendly manner
12:16:08 <jix> monochrom: linkers aren't allowed to strip parts of sections as they can't know if it's used or not
12:16:23 <jix> monochrom: so there isn't much a linker can do to avoid split objs
12:16:41 <augur> the idea is sort of to allow alternative definitions to run in parallel and just wait for whichever halts first
12:16:58 <augur> but extended to the possibility that you can use definitions bidirectionally
12:17:33 <mm_freak_> i think to improve the performance of my code i need to get rid of dictionaries
12:17:35 <conal> augur: maybe you're assuming that concurrent execution implies nondeterminism.
12:17:49 <augur> conal: im assuming you can use it to model nondeterminism
12:17:58 <mm_freak_> but getting rid of classes would degrade the elegance of my code considerably
12:18:08 <mm_freak_> and also would make it less composable
12:18:13 <augur> well, confluent nondeterminism, i suppose
12:18:26 <mm_freak_> is there any way to optimize this in a not too invasive manner?
12:18:34 <jix> mm_freak_: have you tried to use specialize pragmas?
12:18:41 <ddarius> mm_freak_: Have you investigated things like SPECIALIZE pragmas and rewrite rules?
12:19:17 <VendoR> hello everyone!
12:19:37 <conal> augur: my advice: clearly separate semantic and implementation issues. decide on your ideal semantics (natural to domain and friendly to rigorous reasoning). then with that foundation explore implementation issues.
12:19:57 <conal> augur: resisting all temptation to allow implementation notions into your semantic musings.
12:20:11 <mm_freak_> jix, ddarius: i'm not sure how to do that, because i'm using an existential type
12:20:22 <augur> conal: i suppose :p
12:20:36 <monochrom> ok the gold linker is significantly faster and seems to produce a usable executable in a simple test that involves gtk2hs
12:20:42 <mm_freak_> i tried specializing one of my functions, but it didn't make any difference
12:21:00 <Heffalump> mm_freak_: did you check the core?
12:21:01 <augur> conal: i suppose the aim is to allow a) multiple definitions to race to an answer, and b) bi-directional definitions
12:21:26 <conal> augur: sounds great.
12:21:28 <mm_freak_> Heffalump: the core is unknowledgable gibberish to me
12:21:29 <edwardk> mm_freak did flopping those args around help performance at all?
12:21:39 <augur> conal: not that i know how to do that precisely, but :P
12:21:43 <monochrom> I understand maybe there are failing cases.
12:21:51 <mm_freak_> edwardk: no, but that's not even related anymore, because i'm working directly in the IO monad
12:21:56 <edwardk> hah
12:21:59 <mm_freak_> related → relevant
12:22:45 <mm_freak_> Heffalump: about core, so far my intuition about compiled haskell code works very well, and i see where my bottleneck is…  now i need not a problem, but a solution =)
12:23:10 <Heffalump> mm_freak_: it should at least give an indication of whether the specialisation worked out
12:23:25 <mm_freak_> edwardk: actually my answer was wrong…  i've completely rewritten my StateT with the arguments flipped, but couldn't see any difference so far
12:24:00 <mm_freak_> Heffalump: i don't think it /can/ work in this case, because of the existential type inbetween
12:24:19 <mm_freak_> i'm afraid i'll need to get rid of the type class entirely
12:24:31 <jix> mm_freak_: it can... for all calls but the first one
12:25:00 <jix> mm_freak_: the first one has to go to the dictionary... but if that function calls other functions they could be specialized i think
12:25:08 <conal> augur: check out warren burton's papers on encapsulating (operational) nondeterminacy to get deterministic semantics. good stuff.
12:25:26 <augur> conal: nifty. ill check it out
12:25:29 <mm_freak_> jix: this existential type is wrapped/unwrapped about 160000*n times each frame, where n is the number of objects in the scene
12:25:44 <mm_freak_> only unwrapped, actually
12:26:22 <jix> mm_freak_: can't you unwrap it n times and have that 160000 times inside that? (since i don't know your code i don't know if that makes any sense)
12:26:25 <conal> augur:  i couldn't find his papers online, so he sent me some. see http://conal.net/papers/warren-burton/ .
12:26:32 <mm_freak_> i've written similar code in C++ and it worked quite fast…  i think there is a lot of room for optimizing how GHC handles dictionaries
12:26:44 <augur> neat
12:26:57 <mm_freak_> jix: unfortunately no, because that will destroy the extensibility of the code
12:27:09 <augur> ive had to do that with a few academics, conal. people really need to put their junk on the internet.
12:27:31 <mm_freak_> jix: i can only do that for predefined object types, but as soon as there is some extension, the performance would drop again
12:27:45 <j-invariant> curse those academics!!
12:28:26 <mm_freak_> i would love to help with GHC development in the optimization area, but unfortunately i have practically no experience with compiler development
12:29:45 <monochrom> publishers do scare-mongering to profs about putting papers on profs' websites. some profs comply.
12:30:26 <ddarius> Don't turn over your copyright.
12:30:50 <ezyang> mm_freak_: Don't worry, me neither :-) 
12:31:04 <mm_freak_> ezyang: are you a GHC developer?
12:31:18 <ezyang> I've been lurking on the lists and submitting occasional patches 
12:31:32 <ddarius> That said, I see no reason why people "need" to put anything on the internet.  One should be thankful that many do and most that don't are willing to email copies.
12:31:40 <ezyang> mm_freak_: You're talking about optimization on the Core/STG level, no? 
12:31:47 <mm_freak_> which VCS does GHC use now?  is it back to darcs?
12:31:51 <ezyang> Traditional compiler technology, as I understand it, isn't really relevant. 
12:31:54 <ezyang> darcs yep 
12:31:55 <ddarius> mm_freak_: It never left darcs.
12:32:41 <dankna> however note that it is stored in multiple repositories - there are wrapper scripts in the top-level repository for working with the other ones in bulk, and directions on the wiki
12:32:58 <ezyang> Yeah, the first thing to do is learn how to build GHC. 
12:33:18 <mm_freak_> ezyang: well, i have no experience with that either =)
12:33:22 <mm_freak_> ddarius: good to know
12:33:39 <mm_freak_> i'm using darcs for my personal projects, which are just a bunch of sporadically updated files
12:34:00 <mm_freak_> and i'm trying to advocate using darcs at work, because i like it much more than SVN
12:34:30 <beastaugh> any DVCS would be a big upgrade on SVN
12:35:06 <mm_freak_> yeah…  i only tried darcs and git and prefer darcs, because it's easier
12:35:57 <beastaugh> lots of people say that
12:36:29 <beastaugh> but they say it about Mercurial too and I can't say I found that
12:36:30 <mm_freak_> i think git is more powerful, but darcs has a nicer interface and more intuitive commands
12:36:54 <beastaugh> however, I used git first and I'm fairly experienced with it, so I'm not in a good position to judge
12:37:20 <beastaugh> I do hear of people having performance problems with Darcs, especially with large repositories
12:37:39 <dankna> in darcs, patches commute.  this obviates the need to do merging.
12:37:48 <mm_freak_> well, once i wanted to merge to very large sets of text files using darcs
12:37:50 <dankna> in git, merging is heavily streamlined, which is good because you have to do quite a lot of it.
12:37:58 <mm_freak_> there i noticed a performance problem
12:38:08 <mm_freak_> but i don't know whether it would exist in git or others, too
12:38:22 <dankna> and I don't know any similar factoids about Mercurial, so.
12:38:38 <ezyang> Git's model doesn't require it to do a lot of legwork, so it's fairly efficient. 
12:39:25 <beastaugh> kowey was talking about a new version of patch theory being in the works
12:39:32 <beastaugh> but I don't know how far along that has come
12:40:15 <mreh> I'd choose usability over reasonably bad performance
12:40:56 <beastaugh> I don't think that is a choice that can be made in general
12:41:03 <beastaugh> people's use cases vary so
12:41:10 <dankna> yeah
12:41:14 <dankna> concur with beastaugh
12:41:28 <monochrom> but you can fix one person and talk about his/her use case.
12:41:29 <mreh> I only use it for small projects :)
12:41:30 <burp> you don't need big repositories for darcs to blow up ;)
12:41:43 <beastaugh> then again, if GHC can manage with Darcs...
12:42:17 <mreh> compiler and repo are independent
12:42:24 <beastaugh> but it's not just repository size, there are issues of development style, how a team works, speed of development, integration with other tools, and so on
12:42:41 <mreh> that's why you enforce standards
12:42:59 <monochrom> "GHC can manage with Darcs" means darcs is not slow
12:43:01 <mreh> but yes, that can be an issue
12:43:01 <edwardk> darcs works very well with single user work flows
12:43:10 <edwardk> and with certain patterns of merging
12:43:21 <beastaugh> mreh: I mean that since the GHC source code is kept under version control in Darcs, it can't be too bad for big projects with similar characteristics
12:43:30 <mreh> beastaugh: oh
12:43:38 <mreh> :d
12:44:07 <beastaugh> mreh: and the standards a development team enforce should reflect the way they feel a project is best run, not necessarily what a particular DVCS constrains them to
12:44:07 <aristid> beastaugh: on the other hand, exactly the same can be said for git (well, with other big projects, not GHC)
12:44:24 <yatta2> noob question: how can one check that the tail of array is also the last element? -- tail xs == last xs -- is not a valid expression because "cannot construct the infinite type: a = [a]"
12:44:29 <beastaugh> aristid: apparently large binary files are very problematic, certaintly
12:45:05 <mreh> yatta2: that's what you would expect te type of last is :: [a] -> a
12:45:10 <edwardk> the tail of an list is a list, but the last element of a list is an element
12:45:12 <monochrom> list not array. not sure what is meant by "tail of list is the last element"
12:45:17 <edwardk> so your statement doesn't make any sense to me
12:45:22 <mreh> head . tail xs == last, (but that's unsafe)
12:45:37 <mreh> monochrom: what  just said
12:45:37 <edwardk> by tail of the list do you mean the second element?
12:45:53 <mreh> he means the case where (x:[y])
12:46:09 <monochrom> well I hope your crystal ball is clear
12:46:17 <mreh> heh
12:46:35 <yatta2> I'm trying to:Write a function lastButOne, that returns the element before the last
12:46:37 * monochrom is against guessing what people mean.
12:46:46 <mreh> use explicit pattern matching
12:46:56 <edwardk> > last (init [1,2,3,4])
12:46:58 <lambdabot>   3
12:47:22 <edwardk> > init [1,2,3,4,5]
12:47:23 <lambdabot>   [1,2,3,4]
12:47:42 <aristid> :t flip (++) . return
12:47:43 <Renze> Did anybody work with Network.Mail.Mime over here?
12:47:43 <lambdabot> forall a (m :: * -> *). (Monoid (m a), Monad m) => a -> m a -> m a
12:47:59 <aristid> @let snoc = flip (Prelude.++) . return
12:48:00 <lambdabot>  <local>:1:12: Not in scope: `Prelude.++'
12:48:07 <aristid> @let snoc = flip (++) . return
12:48:09 <lambdabot>  Defined.
12:48:11 <yatta2> I wrote this and kinda get why it is wrong : lastButOne xs = if tail xs = last xs then head ex else lastButOne (tail xs) 
12:48:24 <aristid> > snoc 4 [1,2,3]
12:48:24 <yatta2> I wrote this and kinda get why it is wrong : lastButOne xs = if tail xs == last xs then head ex else lastButOne (tail xs) 
12:48:26 <lambdabot>   [1,2,3,4]
12:49:15 <Renze> yatta2:
12:49:17 <Renze> :t tail
12:49:18 <lambdabot> forall a. [a] -> [a]
12:49:20 <Renze> :t last
12:49:20 <monochrom> you saw edwardk's solution, don't you?
12:49:21 <lambdabot> forall a. [a] -> a
12:49:27 <cole> When I do "ghc search.hs -o search" I get errors like "undefined reference to '...regex...'". This seems to only be a problem when I include Text.Regex. What's wrong?
12:49:31 <edwardk> yatta: last . init
12:49:32 <yatta2> yea
12:49:46 <edwardk> init drops one element, last gets the last
12:49:46 <Renze> so they can't be (==)
12:49:47 <yatta2> edwardk looks good
12:49:57 <monochrom> ghc --make search.hs -o search
12:49:59 <yatta2> i never knew about that function - thanks 
12:50:02 <edwardk> np
12:50:15 <edwardk> thats the nature of haskell you write lots of code, then you find it in the prelude
12:50:19 <edwardk> and replace it with 4 characters
12:50:31 <mm_freak_> > liftM3 (,,) tails (tails . tail) (tails . drop 2) $ [1..10]
12:50:33 <lambdabot>   ([[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[4,5,6,7,8...
12:50:36 <ddarius> edwardk: Yay, let's traverse twice!
12:50:42 <copumpkin> there should be a zipWithRest :: (a -> b -> c) -> [a] -> [b] -> (c, Either [a] [b])
12:50:47 <copumpkin> [c]
12:51:05 <edwardk> ddarius: with laziness, they likely fuse together into one ugly traversal
12:51:27 <ddarius> edwardk: Laziness won't avoid it doing double the work.
12:51:30 <monochrom> twice is better than n times
12:51:39 <mreh> not if n=2
12:51:40 <ddarius> Unless n = 1 or 0.
12:51:43 <mreh> heh
12:51:48 <monochrom> heh ok
12:52:03 <LittleEndian> OK RWH is good, thanks ddarius
12:52:50 <Renze> with simple functions you can also use n + 2: head . tail . reverse
12:53:00 <Renze> (...and with lazyness, of course)
12:53:34 <ksf> "It would be very natural to add a type Natural providing an unbounded size unsigned integer, just as Prelude.Integer provides unbounded size signed integers. We do not do that yet since there is no demand for it. "
12:53:42 <mm_freak_> > let f [x0,x1] = x0; f (x0:xs) = f xs in f [1..10]
12:53:42 <lambdabot>   9
12:54:10 <yatta2> does the reverse function create a new list in memory?
12:54:10 <ksf> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.0.0/Data-Word.html
12:54:13 <ddarius> It would actually be super natural as GMP operations use natural functions at the base.
12:54:23 <ddarius> yatta2: It has no choice.
12:54:24 <monochrom> It is very integer to add Integer, too. :)
12:54:31 <ksf> that sound like significant loss of reality.
12:54:42 <Renze> yes, yatta2, so mm_freak_'s solutions is the fastest and less memory consuming
12:55:23 <ksf> Natural would also be the perfect type for fromEnum/toEnum
12:55:27 <monochrom> well Haskell 2012 is calling for proposals. Time to show them demand.
12:55:27 <mm_freak_> yatta2: what's your application?
12:55:31 <aristid> ksf: there is no demand for it? who says that?
12:55:33 <ksf> it's the perfect type for a lot of things.
12:55:37 <ksf> the haddock.
12:55:44 <Renze> but imo it's hard to understand what's happening because of patternmatching on 2 elements (well, in this case it isn't so hard at all, but with similar functions when you want the 5-th last..)
12:55:56 <yatta2> no application. http://book.realworldhaskell.org/read/types-and-functions.html
12:56:07 <yatta2> trying to do the excerise 
12:56:14 <mm_freak_> Renze: simple:  the list is fully evaluated, the elements are not evaluated
12:56:15 <aristid> ksf: but there are some problems with Num, i think. negate on InfiniteWord does not make sense
12:56:23 <mm_freak_> yatta2: ah, ok
12:56:46 <ksf> "All arithmetic is performed modulo 2^n, where n is the number of bits in the type. One non-obvious consequence of this is that Prelude.negate  should not raise an error on negative arguments. "
12:57:00 <ksf> erm.
12:57:01 <ksf> well.
12:57:09 <Renze> mm_freak_: I know what's happening, but someone who reads your code doesn't see it in one look, I think (depends on his Haskell knowledge of course)
12:57:11 <copumpkin> > negate (-1)
12:57:12 <lambdabot>   1
12:57:23 <ksf> negate (1::Word)
12:57:25 <ksf> > negate (1::Word)
12:57:26 <lambdabot>   18446744073709551615
12:57:34 <aristid> > negate (0::Word)
12:57:36 <lambdabot>   0
12:57:36 <monochrom> this is why haskell allows comments.
12:57:46 <ksf> > showIntAtBase digitToInt (negate (1::Word)) ""
12:57:47 <mm_freak_> Renze: in the absence of strictness annotations there is an easy rule:  variables in patterns are lazy, rest is strict
12:57:47 <lambdabot>   Couldn't match expected type `GHC.Types.Int -> GHC.Types.Char'
12:57:47 <lambdabot>         agai...
12:57:56 <ksf> > showIntAtBase 2 digitToInt (negate (1::Word)) ""
12:57:57 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
12:57:57 <lambdabot>         against inferred type ...
12:58:03 <ksf> :t showIntAtBase
12:58:04 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
12:58:12 <Renze> I know, I know
12:58:15 <yatta2> I'm not a professional programmer nor have any formal tranning - thanks for helping a noob out
12:58:19 <mm_freak_> Renze: in that case the end of the list is pattern-matched against, so the entire list is evaluated…  and that the function is non-strict in the list elements can be seen from its type
12:58:24 <ksf> > showIntAtBase 2 intToDigit (negate (1::Word)) ""
12:58:25 <lambdabot>   "1111111111111111111111111111111111111111111111111111111111111111"
12:58:27 <mm_freak_> :t let f [x0,x1] = x0; f (x0:xs) = f xs in f
12:58:28 <lambdabot> forall t. [t] -> t
12:58:30 <ksf> there.
12:58:33 <ksf> just use the same thing.
12:58:42 <ksf> that is, negate = complement
12:58:43 <aristid> <mm_freak_> Renze: in the absence of strictness annotations there is an easy rule:  variables in patterns are lazy, rest is strict
12:58:50 <aristid> mm_freak_: is that actually implemented by GHC?
12:59:05 <ksf> err two's complement.
12:59:10 <mm_freak_> aristid: i think so, unless optimization decides otherwise =)
12:59:22 <bsmntbombdood> @pl \f g -> foldl1 f . map g 
12:59:23 <lambdabot> (. map) . (.) . foldl1
12:59:26 <ksf> which makes sense, as coercions from int to word and back are representation, not sign preserving.
12:59:27 <aristid> ksf: that would result in Infinite
12:59:30 <monochrom> it is also in the haskell report
12:59:33 <aristid> ksf: for every input
12:59:42 <Renze> maybe it's because of my "only" ~15 months of experience with Haskell, but I like straightforward functions so comments are even not necessary at all
13:00:01 <ksf> aristid, exactly.
13:00:04 <Renze> of course, it's slower most/all of the times, but clarity comes at a cost
13:00:07 <ksf> your point?
13:00:28 <aristid> ksf: Infinite for that unbounded Word type would probably be bottom
13:00:28 <ksf> actually, it wouldn't.
13:00:31 <monochrom> after a while you find some straightforward functions are inefficient. you hand-optimize, even completely change algorithm. that's when you need comments to explain your derivation.
13:00:32 <mm_freak_> Renze: in production libraries and programs i always comment everything, because even if you think today that "the function name and its type really explains everything", you might find yourself thinking otherwise two months later =)
13:00:38 <ksf> > showIntAtBase 2 intToDigit (negate (20::Word)) ""
13:00:38 <lambdabot>   "1111111111111111111111111111111111111111111111111111111111101100"
13:00:41 <copumpkin> ksf: what would negate on an arbitrary-precision natural return?
13:00:53 <mm_freak_> Renze: also i prefer haddock docs over having to open source code
13:00:53 <aristid> ksf: Word is bounded.
13:00:59 <aristid> > maxBound :: Word
13:01:00 <lambdabot>   18446744073709551615
13:01:08 <ksf> yes. imagine an infinite number of 1's to the left.
13:01:14 <edwardk> ksf: thats why you need 2s complement
13:01:15 <aristid> ksf: which is bottom.
13:01:35 <ksf> no, that's a different constructor of an ADT
13:01:38 <edwardk> i have infinite precision type level 2s and 16s complement integers in a library somewhere
13:01:42 <copumpkin> aristid: Integer behaves like that
13:01:58 <copumpkin> pretends to be an infinite-bit 2's complement thing
13:02:08 <edwardk> yeah
13:02:09 <aristid> copumpkin: negate 0 is not bottom for Integer
13:02:20 <Renze> mm_freak_: I use Haddock comments as well, because it's very handy when you work with a team mate (at school for instance), but still: I'll always write simple functions to start with and only fasten them up in the last ~week, so that we both understand the functions and the principles/ideas behind it
13:02:21 <aristid> > negate 0 :: Word
13:02:23 <lambdabot>   0
13:02:29 <copumpkin> aristid: I never said it was?
13:02:31 <monochrom> in fact even extended euclid's algorithm needs explanation: http://www.vex.net/~trebla/haskell/calculator/Calculator.hs
13:02:32 <aristid> wait, i mean negate 1
13:02:40 <aristid> > negate 1 :: Word
13:02:41 <lambdabot>   18446744073709551615
13:02:48 <aristid> > negate 1 :: Integer
13:02:49 <ksf> aristid, infinity /= bottom
13:02:49 <lambdabot>   -1
13:03:03 <copumpkin> > testBit (-1 :: Integer) 100
13:03:04 <lambdabot>   True
13:03:05 <copumpkin> > testBit (-1 :: Integer) 10000
13:03:06 <lambdabot>   True
13:03:08 <copumpkin> > testBit (-1 :: Integer) 10000000
13:03:09 <lambdabot>   True
13:03:10 <aristid> ksf: well, then it can't be implemented that way
13:03:10 <mm_freak_> Renze: i find it easier to write the comments right away
13:03:12 <monochrom> don't tell me you prefer an exponential-time algorithm that does exhaustive search because it's trivial to figure out
13:03:19 <copumpkin> aristid: as I said, it _pretends_ to be
13:03:27 <copumpkin> clearly it doesn't actually have infinite bits lying aroudn
13:03:27 <ksf> you don't need to, the only way to get such a thing is to use negate.
13:03:48 <ksf> ...and the only way to inspect the hidden information in it is to negate again.
13:03:57 <monochrom> well, I guess sadly 99% of project euler submissions are exactly that. exhaustive search because it's trivial to figure out. and the source code is oh-so-readable.
13:04:05 <ksf> well, or coerce.
13:04:36 <ksf> it might not make sense to a mathematical-numerical mind, but it makes sense to me as a programmer.
13:04:42 <aristid> ksf: then that pretension is not worth its salt
13:04:43 <Renze> monochrom: no, I won't do that of course, most of the times I just write the functions again with (.), ($), and a few tricks (map (f.g), concatMap, foldr) if I didn't use them straight away because I wrote the function bottum-up
13:04:58 <bsmntbombdood> i have a program that's running out of memory, where do i start looking?
13:05:04 <Renze> (map (f.g), concatMap, foldr, ...)*
13:05:13 <edwardk> negate 1 works fine, too. negate (I Os) = succ (O Is) = Is
13:05:28 <monochrom> Alright of course if it's just O(2n) vs O(n) but the O(2n) is more direct, I opt for it too.
13:05:51 <ksf> aristid, aren't you worried by the infinite amount of 0's to the left of every Integer?
13:05:53 <edwardk> assuming O for zero I for one, and Os for an infinite tail of Os, and Is for an infinite tail of Is
13:06:04 * ezyang sometimes wishes there was a way of specifying complexity with more nuance than big-O 
13:06:21 <edwardk> ezyang: sure, use big theta ;)
13:06:25 <ezyang> haha 
13:06:30 <aristid> ksf: no, because i read them from right to left, and can stop at the last non-zero digit
13:06:32 <Renze> monochrom: it also plays a part that I can't think of fast AND working functions at once, so far. I'm always trieing to do it at once, but most of the times I fail and proceed to just working functions (and fasten them up at last).
13:06:53 <ksf> aristid, and so you can with leftmost 1's.
13:07:03 <aristid> ksf: only if you know the sign
13:07:05 <ksf> it's the bit representation that counts.
13:07:27 <ksf> naaaah.
13:07:30 <edwardk> the only tricky bit is that you want to normalize the number so that you always have it in a canonical form (O Os) and (I Is) being disallowed. this is where your infinity runs amuck.
13:07:36 <ksf> only if you know that there's not going to be a 0 somewhere.
13:07:46 <ksf> which is the same problem as in the 0 case.
13:08:11 <edwardk> I suppose infinity can be fix I
13:08:37 <ksf> isn't there some fancy mathematical theory about modulo 2^inf arithmetic?
13:08:45 <edwardk> or you can put the sign up front and destroy the induction principle, so you can at least tell if you are growing or shrinking
13:08:54 <edwardk> probably
13:09:07 <mm_freak_> > fix (Just . In)
13:09:09 <lambdabot>   Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (Just ...
13:09:46 <ksf> anyway, if everything else fails, negate could just error out into both directions.
13:10:31 <ksf> numerical primitives erroring out when the result escapes the type's domain has precedent.
13:11:18 <bsmntbombdood> http://hpaste.org/42864/regex
13:11:27 <bsmntbombdood> that is running out of memory on reasonably large regexes
13:12:04 <aristid> > "This is... " ++ (show . fix) (Just . In)
13:12:06 <lambdabot>   "This is... Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (Jus...
13:12:52 <mm_freak_> i think it's better to swap constructors
13:12:55 <mm_freak_> cleaner type
13:13:02 <mm_freak_> > fix (In . Just)
13:13:04 <lambdabot>   In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (J...
13:13:06 <ksf> though...
13:13:29 <ksf> before all that is done, it'd be nice to have type-level naturals.
13:13:42 * ksf wants (Int 23)
13:15:24 <EvanR> @hoogle Bool -> Maybe ()
13:15:24 <lambdabot> Control.Monad guard :: MonadPlus m => Bool -> m ()
13:15:24 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
13:15:24 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
13:16:11 <augur> ksf: why do you want type level naturals??
13:16:19 <EvanR> > guard False :: Maybe ()
13:16:20 <lambdabot>   Nothing
13:16:24 <EvanR> > guard True :: Maybe ()
13:16:25 <lambdabot>   Just ()
13:16:35 <ksf> because they're useful.
13:16:40 <augur> ksf: oh? how so
13:16:55 <ksf> arbitrarily-sized Int and Word types are just one example.
13:17:05 <ksf> fixed-sized vectors.
13:17:32 <ksf> ...and indispensible in most type-level programming.
13:20:00 <mreh> was PrettyPrint written before typeclasses?
13:20:07 <mikeg> If i want to report a bug in parseTime in the time package, should I put it on the GHC trac or send it to the author?
13:20:31 <mikeg> > parseTime defaultTimeLocale  "%e %B %Y" "April 2000" :: Maybe Day
13:20:32 <lambdabot>   Not in scope: type constructor or class `Day'Not in scope: `parseTime'Not i...
13:21:21 <kxtells> Hello everyone, I've got a little question and maybe someone can guide me
13:21:57 <mreh> kxtells: dont be afraid to ask
13:22:04 <mreh> the worst we can do is ignore you
13:22:30 <kxtells> there's somewhere to ask doubts about the Miranda functional programming language?
13:22:37 <kxtells> I know this is not a miranda channel
13:22:41 <mreh> kxtells: close enough :)
13:22:45 <mreh> I know miranda
13:22:47 <kxtells> but maybe for "some similarity"
13:22:57 <mreh> it was my first functional language
13:22:58 <kxtells> fantastic
13:23:22 <dankna> well, we could always give scathing criticism
13:23:54 <dankna> there are plenty of worse things we could do than ignore, really
13:24:09 <mreh> or nitpick you to death
13:24:48 <dankna> yeah, or that!
13:24:58 <kxtells> or maybe...
13:25:07 <kxtells> you can ask my little question :-)
13:25:07 <ksf> or meta-discuss you to insanity.
13:25:12 <kxtells> or point me somewhere else
13:25:18 <mreh> kxtells: just ask!
13:25:22 <kxtells> and then nitpick me :-)
13:25:29 <dankna> well, actually, I'd answer if a) you had asked it yet, and b) I knew Miranda at all
13:25:36 <dankna> but I'd still be nitpicking, because it amuses me
13:25:41 <monochrom> who is miranda?
13:25:42 <kxtells> is there an easy way (like a function) to generate a random number?
13:25:53 <ezyang> some dude from the tempest 
13:25:57 <EvanR> :t random
13:25:58 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
13:25:58 <ezyang> ^_^ 
13:26:00 <ksf> you are, btw, all in violation of trademark law.
13:26:00 <dankna> the person because of whom we have Miranda Rights (in the US)
13:26:03 <mreh> kxtells: I don't know that much miranda!
13:26:05 <monochrom> interesting!
13:26:05 <bsmntbombdood> functions can't generate random numbers
13:26:07 <EvanR> g -> (Number, g)
13:26:26 <mreh> if you compile your miranda with GHC it should work
13:26:37 <mreh> possibly
13:26:48 <mreh> very similar syntax minus the types
13:26:56 <dankna> really - interesting
13:27:04 <mreh> that's about all the advice I can give, I dunno, google
13:27:20 <jix> kxtells: algorithmically you can only generate pseudo random numbers... for that you have to keep and update a state... so if you want that as a function you have to have the current state as parameter and return the new state besides the pseudo random number
13:27:38 <EvanR> :t randomIO
13:27:39 <lambdabot> forall a. (Random a) => IO a
13:27:42 <EvanR> ;)
13:27:51 <jix> EvanR: does miranda use IO?
13:27:55 <kxtells> thanks, I've been googling and found nothing, that's why I'm asking in a haskell channel
13:27:55 <EvanR> no
13:28:05 <mreh> kxtells: there's a book called programming with Miranda
13:28:05 <EvanR> that makes this question hard
13:28:06 <Eduard_Munteanu> So a quantum computer would generate random numbers in pure functions? :D
13:28:08 <mreh> chris clack
13:28:22 <mreh> that was my first functional prog text book
13:28:28 <Eduard_Munteanu> @hoogle random
13:28:29 <lambdabot> package random
13:28:29 <lambdabot> System.Random random :: (Random a, RandomGen g) => g -> (a, g)
13:28:29 <lambdabot> module System.Random
13:28:34 <Eduard_Munteanu> kxtells: ^
13:28:44 <Eduard_Munteanu> @google random haskell
13:28:45 <lambdabot> http://www.haskell.org/onlinereport/random.html
13:28:45 <lambdabot> Title: The Haskell 98 Library Report: Random Numbers
13:29:01 <EvanR> kxtells isnt using haskell or ghc
13:29:34 <Eduard_Munteanu> Oh, my bad.
13:30:23 <EvanR> randomIO makes generating random <whatever> 'easier' than in any traditional language ;)
13:30:30 <EvanR> its amazing
13:30:44 <mreh> MonadRandom is the bee's knees
13:30:59 <EvanR> but people dont like the Random class or MonadRandom or StdGens
13:31:17 <mreh> why knot?
13:31:34 <EvanR> not sure, besides maybe StdGen isnt high enough performance
13:31:35 <mreh> better than passing them round explicitly
13:32:01 <EvanR> or doesnt have enough distributions
13:32:11 <mreh> never found that a problem personally
13:32:14 <mreh> interesting
13:32:15 <EvanR> or split sucks
13:32:18 <EvanR> or something
13:32:37 <mreh> how much randomness do you need?
13:32:53 <kxtells> not much
13:33:04 <mreh> roll a dice :)
13:34:09 <jix> I think it's impossible to implement a good prng that supports split
13:34:12 <monochrom> how do you do I/O in miranda?
13:34:23 <mreh> with difficulty
13:34:30 <EvanR> lazy lists?
13:34:33 <mreh> probably the old way
13:34:43 <mreh> tbh I never had to do it
13:35:05 <EvanR> > let g = mkStdGen 0 in randomR (1,6) g
13:35:06 <lambdabot>   (6,40014 40692)
13:35:17 <EvanR> > let g = mkStdGen 0 in fst $ randomR (1,6) g
13:35:18 <lambdabot>   6
13:35:27 <mreh> > 3
13:35:27 <lambdabot>   3
13:35:28 <EvanR> 6, totally random
13:35:30 <mreh> I rolled a dice
13:35:31 <EvanR> use that
13:40:25 <kxtells> ok
13:40:30 <kxtells> thanks for the advice
13:41:36 <copton> given a list and an equivalence relation, is there a function which returns a list of listss of equivalent objects?
13:41:54 <copton> groupBy only groups neighbor elements together
13:42:23 <mreh> most of it was bad advice
13:42:44 <copton> and partition can only deal with two equivialence classes
13:43:06 <kxtells> well, better than no advice.... gettin info on miranda is not easy at all
13:44:39 <monochrom> @type elemBy
13:44:40 <lambdabot> Not in scope: `elemBy'
13:44:47 <monochrom> @type findBy
13:44:48 <lambdabot> Not in scope: `findBy'
13:45:04 <mm_freak_> > groups . sort $ "abbaadddeefaaf"
13:45:04 <lambdabot>   Not in scope: `groups'
13:45:07 <mm_freak_> > group . sort $ "abbaadddeefaaf"
13:45:08 <lambdabot>   ["aaaaa","bb","ddd","ee","ff"]
13:47:56 <mauke> > 2^26-27
13:47:57 <lambdabot>   67108837
13:48:14 <monochrom> you should loop over partition.
13:49:02 <argiopeweb> 'Afternoon folks.  I'm looking for some manner of shorthand for "(x `mod` y) == 0".  Is there a more elegant solution?
13:49:26 <ezyang> you could define your own function :-) 
13:49:45 <ezyang> x `de` y = (x `mod` y) == 0 
13:51:06 <mm_freak_> haskell seems so elegant that people seem to expect some elegant combinator even for the most trivial things =)
13:51:15 <argiopeweb> ezyang: That would, indeed, be the simple answer.  Didn't want to rule out the chance that there was an existing function.  No point in re-inventing the wheel.
13:51:30 <monochrom> Prelude.Twitter has every function expressible in 140 words or less
13:51:51 <ezyang> monochrom: Are you being serious? :-) 
13:52:00 <monochrom> sarcastic
13:52:32 <ezyang> Haskell seems to have a lot more combinators built-in then most languages. OCaml doesn't have a zip for arrays by default, for example! 
13:52:38 <monochrom> you may be surprised at how many people secretly wish for a Prelude.Twitter
13:53:11 <mm_freak_> ezyang: i don't think so, but haskell's combinators stick together very well…  that's why people can't get enough of elegance
13:53:23 <mm_freak_> when sometimes in fact they make their code unreadable =)
13:53:34 <ezyang> Enh, it's just another language 
13:53:46 <ezyang> I find fully written out recursion to be unreadable these days :-) 
13:53:49 <ezyang> let alone monster loops 
13:53:50 <mm_freak_> elegant implementation of subsequences:
13:54:01 <mm_freak_> > filterM (const [True, False]) "abc"
13:54:01 <lambdabot>   ["abc","ab","ac","a","bc","b","c",""]
13:54:36 <mm_freak_> how many non-expert haskell programmers understand, how this function works? ;)
13:55:09 <ezyang> the monad combinators for the reader monad and the list monad tend to be mean... 
13:55:27 <mm_freak_> for the reader monad?  which one?
13:55:34 <monochrom> well like I said I don't believe in source code "readable" without comments universally.
13:55:35 <ezyang> for me, it reads pretty naturally 
13:55:37 <mm_freak_> Reader or (->) e?
13:55:43 <ezyang> mm_freak_: as in, r-> 
13:55:45 <hpc> mm_freak_: so long as it does what it is supposed to, and has a descriptive name
13:56:05 <hpc> and with that approach to writing it, you can give a strong proof that it works
13:56:07 <mm_freak_> hpc: yes, until you need to change it
13:56:12 <Renze> :t filterM
13:56:13 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
13:56:23 <hpc> how often do you need to change your implementation of permutations? :P
13:56:36 * hpc is only defending that particular example, btw, and agrees in general
13:56:39 <mm_freak_> ok, much worse example, which combines the reader and list monads into a nightmare =)
13:57:01 <ezyang> monochrom: Since written language has the same problem of terseness versus verbosity, really I think it's just audience audience audience 
13:57:20 <hpc> :t audience audience audience
13:57:20 <lambdabot> Not in scope: `audience'
13:57:20 <lambdabot> Not in scope: `audience'
13:57:20 <lambdabot> Not in scope: `audience'
13:57:25 <hpc> @let audience = fmap
13:57:26 <lambdabot>  Defined.
13:57:31 <mm_freak_> > foldM (\x y -> zipWith (\l r -> l ++ y:r) <$> inits <*> tails $ x) [] "abcd"
13:57:33 <lambdabot>   ["dcba","cdba","cbda","cbad","dbca","bdca","bcda","bcad","dbac","bdac","bad...
13:57:35 <ezyang> fortunately there is no monad instance for \a -> r -> [a] :-) 
13:57:40 <mm_freak_> permutations in nightmare =)
13:57:46 <hpc> mm_freak_: oh good god
13:57:54 <monochrom> on audience, I know of a Dijkstra writing on that
13:58:18 <ezyang> that's a pretty hilarious snippet. 
13:58:25 <monochrom> http://userweb.cs.utexas.edu/users/EWD/transcriptions/EWD10xx/EWD1068.html
13:58:50 <ezyang> I can't read that one off naturally. 
13:58:54 * hpc never really understood how to use folds
13:59:01 <Renze> mm_freak_: the implementation of the list monad is to do all the possible binds with the items of the list (at least that's what I think), so he'll try every possible concatenation of the const True somePartOfTheString"abc" 
13:59:21 <ezyang> hpc: Have you seen the diagrams of what a fold does to : and []? 
13:59:29 <ezyang> (well, a right fold, anyway) 
13:59:32 <Renze> and I think this because you can do list comprehensions in monad style without any concatenation or something like that
13:59:41 <mm_freak_> Renze: yes, once you really think about it, it gets much clearer, but now try the same with my second code
13:59:47 <mm_freak_> my version of 'permutations'
13:59:49 <hpc> ezyang: no, that's specifically the thing that scares me about folds
13:59:52 <ezyang> no, you need concatenation for some list comprehension things 
14:00:07 <hpc> i know some of the tricks, but not how to use it generally
14:00:08 <ezyang> hpc: I mean, it's really the only way I think about folds these days. 
14:00:19 <Renze> :t foldM
14:00:19 <ezyang> If I can't think about it that way, it probably shouldn't be a fold... 
14:00:20 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
14:00:31 <hpc> i find myself thinking "i wish i knew how to do that list-to-list folding bullshit, so this wasn't fifty lines"
14:00:44 <mm_freak_> hpc: whenever you're tempted to write a recursive function to process the elements of a list, a fold may be the natural choice
14:01:06 <Renze> mm_freak_: I'm sorry, my nausea is killing me, I'll try it in a few minutes probably
14:01:12 <mauke> yay, I've solved euler 158 the "right" way
14:01:28 <EvanR> how do i make submodules, if i import X.Y.Z it does not find it in X/Y/Z.hs
14:01:39 <mm_freak_> mauke: so you haven't written any code to solve it?
14:01:53 <mauke> mm_freak_: I have
14:02:07 <mm_freak_> EvanR: your import is right…  forgot to use --make?
14:02:15 <monochrom> X/Y/Z.hs is supposed to work.
14:02:16 <ezyang> EvanR: --make. Or really, Cabal, at this point. 
14:02:16 <mauke> because I can't compute 2^26 in my head
14:02:21 <EvanR> i tried ghci
14:02:25 <hpc> EvanR: does X.Y.Z start with "module X.Y.Z where"
14:02:26 <mauke> also the "lotto distribution" part
14:02:26 <hpc> ?
14:02:26 <EvanR> so its a cabal only thing
14:02:29 <EvanR> hpc: no
14:02:36 <monochrom> well there you go
14:02:36 <Saizan> it should
14:02:38 <ezyang> EvanR: No, but Cabal simplifies matters a bit. 
14:02:41 <EvanR> ok
14:02:42 <hpc> because you can't just say "module Z"
14:03:04 <ezyang> lol Lennart :-) 
14:03:12 <ezyang> (re haskell-cafe) 
14:03:15 <EvanR> when you import X does that mean X/X.hs
14:03:21 <ezyang> no. 
14:03:23 <monochrom> No. just X.hs
14:03:25 <Saizan> it means X.hs
14:03:32 <EvanR> oh
14:03:48 <hpc> typically you will have X.hs and X/lots-of-stuff
14:03:48 <monochrom> wrong assumption is the mother of confusion
14:03:55 <hpc> and X.hs imports everything in X/
14:04:17 <EvanR> ok
14:04:20 <hpc> i personally prefer X.All, because it makes tab completion less difficult
14:04:32 <mm_freak_> mauke: i found that most PE problems can be solved without code
14:04:43 <mm_freak_> without much redundant work, that is
14:04:49 <hpc> (don't use that style for hackage stuff; it is annoying :P)
14:04:52 <mauke> meh, mechanical computation ...
14:05:13 <hpc> PE isn't so much programming problems, as it is number theory problems
14:05:22 <mm_freak_> hpc: that's not a problem, if you have a good editor =)
14:05:40 <hpc> mm_freak_: eh, i use vanilla vim and enjoy it :P
14:05:42 <mauke> I think I've solved all but 2 or 3 euler problems with brute force
14:05:46 <mauke> well, of the ones I've solved
14:06:11 <monochrom> That is the ideal of PE. "a 'prime number' is defined as blahblah. find the largest prime below 100"  answer: main = putStrLn "97"
14:06:14 <copumpkin> most of them become intractable to brute force eventually
14:06:16 <mm_freak_> hpc: one of vim's shortcomings…  it's great inside of a file, but fails miserably once you want to leave it =)
14:06:37 <hpc> fine with me, since i am good with bash too
14:06:53 * hpc bbl
14:07:03 <mm_freak_> hehe
14:07:12 <monochrom> but I disagree about number theory problems. with all the emphasis on decimal expansion (why not binary expansion), that's numerology.
14:07:34 <mm_freak_> it's simply math IMO
14:07:36 <monochrom> I mean PE is about numerology not number theory.
14:08:26 <EvanR> find the longest combination of sentences in the bible whos total letters sums to 666
14:09:12 <mauke> mm_freak_: http://p3rl.org/8784JKHD this is how I did it
14:10:03 <mm_freak_> > filter ((== 666) . snd) . map (id &&& length . concat) . subsequences $ cake
14:10:06 <lambdabot>   mueval-core: Time limit exceeded
14:10:11 <mm_freak_> huh?
14:10:13 <mm_freak_> > filter ((== 666) . snd) . map (id &&& length . concat) . subsequences $ cake
14:10:17 <lambdabot>   mueval-core: Time limit exceeded
14:10:19 <ezyang> > cake 
14:10:20 <mm_freak_> wow
14:10:21 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
14:10:22 * BMeph votes for trinary expansion!
14:10:25 <mm_freak_> seems to be a long recipe
14:10:39 <EvanR> mm_freak_: looks like we need PE
14:10:50 <EvanR> lol
14:11:04 <monochrom> oh God augustss is evil indeed :)
14:11:48 <EvanR> > last cake
14:11:50 <lambdabot>   "That will deodorize and preserve putrid tissue."
14:12:43 <djahandarie> > length cake
14:12:45 <lambdabot>   42
14:12:47 <monochrom> notice that augustss nicely omits intersection, difference, delete, etc. so there is no issue with duplicate elements :)
14:13:10 <mm_freak_> mauke: yeah, you solved it combinatorily
14:13:28 <mm_freak_> i love that cake
14:13:42 <mm_freak_> particularly you can call the haskell super hero through cake
14:13:56 <mm_freak_> he always comes with his characteristic TOOTOOT
14:14:03 <mm_freak_> > splitAt 7 . drop 27 . map head $ cake
14:14:05 <lambdabot>   ("TOOTOOT","ASCIICAT")
14:14:14 <djahandarie> > ala Sum mconcat . map length $ cake
14:14:15 <lambdabot>   Not in scope: `ala'
14:14:18 <djahandarie> Aw :(
14:17:19 <Heffalump> monochrom: the set is only defined by the membership operation, so duplicate elements don't matter (as long as you get difference right)
14:18:33 <aristid> > head . cake
14:18:35 <lambdabot>   "OOTFOTOTDFFFFFPFCOAUFANTOATTOOTOOTASCIICAT"
14:19:07 <EvanR> isnt head . cake a function
14:19:25 <EvanR> er
14:19:26 <aristid> :t head . cake
14:19:27 <lambdabot> [Char]
14:19:34 <EvanR> :t (.)
14:19:35 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:19:53 <parcs> > cake
14:19:55 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
14:20:50 <parcs> > sum . length . cake
14:20:51 <lambdabot>   Couldn't match expected type `[a]'
14:20:51 <lambdabot>         against inferred type `GHC.Types...
14:21:13 <parcs> > sum . length <$> cake
14:21:14 <lambdabot>   Couldn't match expected type `[a]'
14:21:14 <lambdabot>         against inferred type `GHC.Types...
14:21:19 <aristid> > sum . length $ cake
14:21:20 <lambdabot>   Couldn't match expected type `[a]'
14:21:21 <lambdabot>         against inferred type `GHC.Types...
14:21:27 <mauke> ...
14:21:33 <EvanR> :t fail
14:21:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
14:21:36 <aristid> > sum $ length . cake
14:21:36 <parcs> > fail
14:21:37 <lambdabot>   Overlapping instances for GHC.Show.Show (GHC.Base.String -> m a)
14:21:38 <lambdabot>    arising...
14:21:38 <lambdabot>   1393
14:21:48 <aristid> there we go
14:21:52 <dabblego> @type cake
14:21:54 <lambdabot> [[Char]]
14:22:15 <parcs> so a . b . c is (a . b) . c?
14:22:33 <mauke> does it matter?
14:22:44 <parcs> with fmap it does
14:22:46 <parcs> i think
14:22:49 <aristid> parcs: no, it is a . (b . c), but that's the same as (a . b) . c
14:22:50 <EvanR> monoid operation
14:22:50 <mauke> not really
14:22:52 <shachaf> parcs: No, it's associative.
14:22:56 <shachaf> Even with different types. :-)
14:23:01 <aristid> parcs: fmap has a law that says it does not matter
14:23:28 <dabblego> s/fmap/mappend
14:23:47 <parcs> ah, duh
14:23:57 <shachaf> It happens to work with different types because them has to be function composition.
14:24:03 <aristid> dabblego: what? (.) = fmap in lambdabot, not (.) = mappend
14:24:15 <dabblego> aristid, fmap says nothing about associativity
14:24:25 <aristid> dabblego: i did not talk about associativity
14:24:30 <mauke> fmap (f . g) = fmap f . fmap g
14:24:47 <dabblego> ok
14:25:21 <mauke> a.k.a (f . g) . xs = f . (g . xs)
14:25:54 <dabblego> right
14:27:00 <parcs> > fix fail
14:27:01 <lambdabot>   ""
14:28:16 <aristid> :t let f = fail; _ = fix f in f
14:28:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
14:28:18 <shachaf> > fail fiх
14:28:19 <lambdabot>   No instance for (GHC.Show.Show (m a))
14:28:19 <lambdabot>    arising from a use of `M5184080348...
14:28:38 <aristid> damn, the monomorphism restriction would be useful once
14:29:04 <mauke> fail :: [Char] -> [Char]
14:29:20 <aristid> oh, of course :)
14:30:11 <shachaf> > fail fiх :: Maybe Int
14:30:13 <lambdabot>   Nothing
14:30:42 <mauke> I don't get it
14:31:11 <mauke> :t fail fix
14:31:12 <lambdabot>     Couldn't match expected type `String'
14:31:12 <lambdabot>            against inferred type `(a -> a) -> a'
14:31:13 <lambdabot>     In the first argument of `fail', namely `fix'
14:31:30 <mauke> I get it
14:31:38 <mauke> because I'm evil myself :/
14:32:02 <mauke> shachaf++
14:34:38 <EvanR> :t zipWith
14:34:39 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
14:37:51 <EvanR> how to make a 2d array from a [[a]]
14:39:21 <mm_freak_> is IORef the fastest atomically modifyable variable?
14:39:58 <ezyang> Yes, for certain definitions of "fastest" 
14:40:37 <timBau> I was just lucky to find out what nice stuff "replicateM n list" does. Since it took quite some time until I ran into this, can perhaps somebody give me a hint where to find more of such gems?
14:41:18 <EvanR> Control.Monad doc
14:41:29 <ezyang> timBau: One thing you could do is look through Control.Monad and figure out what each of those functions does for a specific monad. 
14:42:00 <timBau> ok, of course I knew replicateM, but I didn't think about in terms of []
14:42:11 <ezyang> right. So work them out for []. 
14:42:24 <timBau> so I should create a table with functions x Monads and go through it
14:43:55 <mm_freak_> timBau: many of the monadic functions are very useful in the list monad
14:44:06 <mm_freak_> sequence generalizes replicateM
14:44:20 <timBau> ok, thanks! This will be fun I guess
14:44:27 <mm_freak_> > sequence ["Bb", "l", "4aA", "h"]
14:44:28 <lambdabot>   ["Bl4h","Blah","BlAh","bl4h","blah","blAh"]
14:45:08 <timBau> nice
14:45:29 <timBau> like cartesian product?
14:45:46 <quuuux> > replicateM 8 "AH" !! 85
14:45:47 <lambdabot>   "AHAHAHAH"
14:46:37 <ezyang> > replicateM 8 "AH" 
14:46:39 <lambdabot>   ["AAAAAAAA","AAAAAAAH","AAAAAAHA","AAAAAAHH","AAAAAHAA","AAAAAHAH","AAAAAHH...
14:46:44 <mm_freak_> timBau: sort of
14:46:49 <mm_freak_> :t sequence
14:46:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
14:47:04 <mm_freak_> it's like a generalized transpose
14:47:25 <mm_freak_> no, it's not
14:47:30 <mm_freak_> > sequence ["abc", "def", "ghi"]
14:47:31 <lambdabot>   ["adg","adh","adi","aeg","aeh","aei","afg","afh","afi","bdg","bdh","bdi","b...
14:47:40 <quuuux> this opens up a whole new tin of tricks to make lambdabot say silly things
14:47:44 <EvanR> > sequence [[1,2,3],[4,5,6]]
14:47:44 <lambdabot>   [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
14:47:54 <EvanR> ol' cartesian
14:48:39 <quuuux> > replicateM 5 "abcdefghijklmnopqrstuv " !! 4189159
14:48:41 <lambdabot>   "o hai"
14:49:05 <timBau> :-)
14:49:09 <EvanR> everything you say is a number!
14:49:32 <mm_freak_> > sequence ["dg", "uw", "am", "ib", "al", "as", "bs"] !! 27
14:49:32 <lambdabot>   "dumbass"
14:50:49 <aristid> > transpose ["dg", "uw", "am", "ib", "al", "as", "bs"]
14:50:51 <lambdabot>   ["duaiaab","gwmblss"]
14:51:20 <aristid> > sequence ["dg", "uw", "am", "ib", "al", "as", "bs"]
14:51:21 <lambdabot>   ["duaiaab","duaiaas","duaiasb","duaiass","duailab","duailas","duailsb","dua...
14:52:22 <mm_freak_> > transpose ["dh", "ua", "mh", "ba", "ah", "sa", "sh"]
14:52:23 <lambdabot>   ["dumbass","hahahah"]
14:52:48 <EvanR> > transpose ["dumbass","hahahah"]
14:52:49 <lambdabot>   ["dh","ua","mh","ba","ah","sa","sh"]
14:53:07 <aristid> EvanR: i suppose that's how mm_freak_ obtained the list :)
14:53:16 <EvanR> nah, couldnt be!
14:53:35 <mm_freak_> hehe
14:54:10 <EvanR> > sequence [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
14:54:11 <lambdabot>   [[1,1,1,2,2,2,3,3,3],[1,1,1,2,2,2,3,3,6],[1,1,1,2,2,2,3,5,3],[1,1,1,2,2,2,3...
14:54:26 <EvanR> > sequence it
14:54:27 <lambdabot>   Not in scope: `it'
14:54:28 <aristid> > sequence ["dumbass"]
14:54:29 <lambdabot>   ["d","u","m","b","a","s","s"]
14:55:04 <aristid> > sequence . sequence $  [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
14:55:06 <lambdabot>   [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:55:22 <aristid> > length . concat . sequence . sequence $ [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
14:55:28 <lambdabot>   *E
14:55:34 <aristid> lol?
14:55:45 <c_wraith> ... what?
14:55:56 <aristid> c_wraith: *E
14:56:05 <mm_freak_> when i started understanding monads i found it amazing how such useful functions pop up out of thin air, once you define a Monad instance
14:56:15 <c_wraith> I'm assuming it was going to talk about exceptions, then got distracted
14:56:56 <mm_freak_> > sequence [sin, cos, tan] 0.5
14:56:58 <lambdabot>   [0.479425538604203,0.8775825618903728,0.5463024898437905]
14:57:55 <EvanR> :t sequence [sin,cos,tan]
14:57:57 <lambdabot> forall a. (Floating a) => a -> [a]
14:58:16 <EvanR> :t sequence [9]
14:58:16 <lambdabot> forall (m :: * -> *) a. (Num (m a), Monad m) => m [a]
14:58:26 <EvanR> ah
14:58:41 <mm_freak_> EvanR: wrong instance
14:58:54 <mm_freak_> there is a Monad instance for the reader monad:  instance Monad ((->) e)
14:58:56 <EvanR> we were not dealing with Monad []
14:59:11 <EvanR> sequence just uses a list
14:59:39 <mm_freak_> right
14:59:55 <ddarius> sum [115,36,76,45,130,20]
15:00:01 <ddarius> > sum [115,36,76,45,130,20]
15:00:01 <lambdabot>   422
15:00:09 <EvanR> posh calculator
15:00:22 <EvanR> ddarius is doing his taxes
15:01:19 <timBau> > replicateM 6 "8k$hn4smta" !! 839416
15:01:20 <lambdabot>   "thanks"
15:01:26 <timBau> to you all
15:01:46 <mm_freak_> timBau: how about "thanks to you all" via replicateM? ;)
15:02:02 <c_wraith> that might time out lambdabot :)
15:02:09 <timBau> I would have to write some tool for this, wouldn't be hard
15:02:11 <EvanR> > (repeat Nothing) !! 100000
15:02:12 <lambdabot>   Nothing
15:02:14 <EvanR> > (repeat Nothing) !! 1000000
15:02:15 <lambdabot>   Nothing
15:02:17 <timBau> but I guess you all have one
15:02:17 <EvanR> > (repeat Nothing) !! 10000000
15:02:18 <lambdabot>   Nothing
15:02:20 <EvanR> > (repeat Nothing) !! 100000000
15:02:21 <lambdabot>   Nothing
15:02:25 <EvanR> O_o
15:02:35 <ddarius> Stop using redundant parentheses.
15:02:40 <ion> > concat $ replicateM 1 "thanks to you all"
15:02:41 <lambdabot>   "thanks to you all"
15:03:00 <EvanR> ddarius: requires me to know more stuff
15:03:06 <ddarius> Not really.
15:03:23 <ddarius> Application binds tighter than anything else.
15:03:34 <EvanR> > [1] ++ [2] !! 1
15:03:35 <lambdabot>   No instance for (GHC.Num.Num [t])
15:03:35 <lambdabot>    arising from a use of `e_1121' at <int...
15:03:38 <EvanR> :(
15:03:44 <EvanR> ddarius: see now i know that
15:03:45 <ddarius> The only time you need parentheses around an application is if you are guarding it from another application.
15:04:05 <quuuux> > (replicateM 5 $ (sequence . transpose $ ["haskell", "list monad"]) !! 37) !! 64081
15:04:08 <lambdabot>   "o hai"
15:07:56 <mm_freak_> > sequence ["tf","hs","aa","cn","mk","sq"," i","tv","oj","y ","yl","vo","uu","j ","ao","ll","lp"] !! 28856
15:07:57 <lambdabot>   "thanks to you all"
15:08:18 <mm_freak_> no search used =)
15:08:29 <timBau> well done
15:09:08 <quuuux> the next step is to find one where the indices drop out of a cute little mathematical expression
15:09:35 <quuuux> I've been running the big numbers by OEIS but no luck :(
15:09:40 <mm_freak_> quuuux: i found it already
15:10:24 <quuuux> mm_freak_: oh, wow. Awesome one for yours
15:10:37 <mm_freak_> quuuux: not too difficult actually
15:12:32 <aristid> > sequence ["ab", "cd"]
15:12:34 <lambdabot>   ["ac","ad","bc","bd"]
15:14:06 <quuuux> @src zipWith
15:14:06 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
15:14:06 <lambdabot> zipWith _ _      _      = []
15:14:35 <parcs> @src [] (>>=)
15:14:35 <lambdabot> xs >>= f     = concatMap f xs
15:15:52 <timBau> > 1 + 1
15:15:54 <lambdabot>   2
15:17:12 <aristid> :t a
15:17:13 <lambdabot> Expr
15:17:18 <aristid> @index Expr
15:17:19 <lambdabot> bzzt
15:17:26 <aristid> @hoogle Expr
15:17:27 <lambdabot> module Text.Parsec.Expr
15:17:27 <lambdabot> module Text.ParserCombinators.Parsec.Expr
15:17:27 <lambdabot> Text.Parsec.Expr buildExpressionParser :: Stream s m t => OperatorTable s u m a -> ParsecT s u m a -> ParsecT s u m a
15:17:36 <aristid> no, no, no, lambdabot
15:29:55 <mikeg> '/j #python
15:29:59 <quuuux> @pf (\ k a b -> a : k b (a + b - 2))
15:29:59 <lambdabot> Maybe you meant: bf pl
15:30:00 <mikeg> eek, sorry
15:30:05 <quuuux> @pl (\ k a b -> a : k b (a + b - 2))
15:30:06 <lambdabot> liftM2 (.) (:) . (. flip (flip . ((-) .) . (+)) 2) . ap
15:30:16 <geheimdienst> i've tried to convert this expression to points-free, but didn't manage so far: «lift (withDisplay (\d -> lift $ xftSomething d x y z))». ideally i'd have a function "displify" that lets me write this as: «displify xftSomething x y z»
15:30:17 <lambdabot> geheimdienst: You have 1 new message. '/msg lambdabot @messages' to read it.
15:30:20 <geheimdienst> any ideas?
15:32:45 <aavogt> geheimdienst: you know the implementation of printf?
15:33:05 <geheimdienst> i'm afraid not
15:34:04 <geheimdienst> you mean from the package "xformat"?
15:34:23 <aavogt> @hoogle printf
15:34:23 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
15:34:23 <lambdabot> module Text.Printf
15:34:23 <lambdabot> Text.Printf class PrintfArg a
15:34:29 <aavogt> no, xformat is different
15:34:47 <aavogt> since the type of the formatting 'string' determines how many arguments you're allowed to supply
15:34:50 <geheimdienst> oh you mean in base. right
15:35:02 <geheimdienst> yeah, i think that's kind of my issue
15:35:35 <quuuux> > (flip (!!) . (!! 23) $ fix (\ k a b -> a : k b (a + b - 2)) 4 3) . replicateM 5 . (!! 37) . sequence . transpose $ ["haskell", "list monad"]
15:35:37 <lambdabot>   "o hai"
15:36:01 <quuuux> enough of that for one day, I think
15:38:01 <mikeg> > transpose ["abc", "def"]
15:38:02 <lambdabot>   ["ad","be","cf"]
15:38:12 <mikeg> @src transpose
15:38:12 <lambdabot> transpose []             = []
15:38:12 <lambdabot> transpose ([]   : xss)   = transpose xss
15:38:13 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
15:39:08 <Saizan> hah, Reusable Theorems
15:40:44 <ph> anyone know how to completely remove the haskell platform from a mac?
15:43:35 <ph> like, is there a list of the files it creates?
15:43:48 <djahandarie> It'd be nice if there were an mconcatMap, so you didn't need to start using Foldable
15:44:41 <djahandarie> :t foldMap
15:44:43 <lambdabot> Not in scope: `foldMap'
15:44:50 <djahandarie> :t Data.Foldable.foldMap
15:44:51 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
15:45:00 <djahandarie> :t \f -> mconcat . map f
15:45:01 <lambdabot> forall a a1. (Monoid a) => (a1 -> a) -> [a1] -> a
15:47:02 <geheimdienst> aavogt, thanks a lot for the pointer to Printf
15:47:15 <aavogt> geheimdienst: look at HList too
15:47:26 <geheimdienst> will do :)
15:49:12 <geheimdienst> "Strongly typed heterogeneous collections" Authors: Oleg Kiselyov, ...
15:49:21 <geheimdienst> ^^ is that the oleg of lambdacat fame?
15:49:48 <aristid> geheimdienst: i thought it was the oleg of type hackery fame
15:50:20 <aristid> http://okmij.org/ftp/
15:50:31 <shachaf> @quote OlegFacts
15:50:32 <lambdabot> OlegFacts says: GHC doesn't have a type checker. It emails your types to Oleg for checking.
15:51:45 <geheimdienst> i don't know type hackery, but i do know http://spl.smugmug.com/Humor/Lambdacats/13227630_eKt46#960831913_rhDdG-L-LB
15:52:56 <Rotaerk> geheimdienst, aww
15:54:00 <geheimdienst> (kids these days. not read a single oleg paper, but they *have* seen oleg cat)
15:54:44 <ddarius> A lot of Oleg's work is not in the form of a paper.
15:58:22 <j-invariant> if [a,b,c] represents a + bx + cx^2 how do I multiply two lists?
15:59:57 <timBau> j-invariant I'm trying to figure it out...
16:00:25 <djahandarie> j-invariant, by making a Num instance
16:01:05 <djahandarie> (f:fs) * (g:gs) = f*g : [f]*gs + fs*(g:gs)
16:01:11 <djahandarie> _ * _ = []
16:02:18 <Cale> http://www.cs.dartmouth.edu/~doug/powser.html
16:02:24 <ddarius> Cale beat me to it.
16:02:42 <timBau> FunkyDrummer > I'm a drummer, too
16:02:54 <timBau> groovy, groovy, jazzy, funky
16:03:07 <FunkyDrummer> good for you
16:07:41 <mreh> gah, writing a pretty printer for every record is such a fag
16:07:52 <mreh> sorry, UKish idiom
16:09:46 <mreh> clever solutions?
16:11:50 <ddarius> mreh: Use ugly printers.
16:12:57 <mreh> ddarius: I shall not have anything ugly in my house
16:13:40 <ddarius> Use ugly printers outside then.
16:15:19 <mreh> but they're so nice to have to debugging
16:15:33 <mreh> oh well
16:17:17 <ddarius> SyntaxNinja: How's life?
16:17:33 <SyntaxNinja> hi ddarius pretty good how are you?
16:19:03 <ddarius> SyntaxNinja: Okay.  I'm filling my life with busyness.
16:20:42 <wagle> cabal: Error: some packages failed to install:
16:20:42 <wagle> texmath-0.5 failed during the configure step. The exception was:
16:20:42 <wagle> ExitFailure 11
16:20:42 <wagle> now what?
16:22:45 <SyntaxNinja> ddarius: in a good way?
16:22:45 <taotree> Can one read in from a db lazily and get out of the IO monad and process the IO [[SqlValue]] outside the IO monad?
16:23:26 <ddarius> SyntaxNinja: Mostly.
16:28:16 <azaq23> taotree: You should not want to get out of the IO monad
16:29:25 <taotree> it's ok, I figured it out--it was my return value not being right... error in different place
16:29:50 <monochrom> don't get out. get in.
16:30:33 <shachaf> > fix (return :: a -> IO a)
16:30:34 <lambdabot>   Occurs check: cannot construct the infinite type:
16:30:35 <lambdabot>    a = GHC.Types.IO a
16:30:53 <taotree> but wouldn't that mean that everything I called from there would have to be in it--it ripple throughout all my code
16:31:27 <monochrom> "get in" means call pure functions from inside IO
16:31:29 <azaq23> and that is what actually happens when you rely on IO, or not?
16:31:48 <shachaf> taotree: No, everything that uses an IO action has to be in IO.
16:31:56 <monochrom> e.g., do { x <- getLine; print (length x) }
16:32:02 <shachaf> An IO action can call regular functions.
16:36:18 <taotree> ok, I think I'm getting it...
16:36:42 <taotree> I'm getting type inference error, I think I need to "get in"... is that what liftM is for or something like that?
16:38:14 <mikeg> taotree: you have some way you want to represent your DB rows. so you make a type, Result, for that, then a function f :: [SqlValue] -> Result or, if you need IO to do that, f :: [SqlValue] -> IO Result
16:38:53 <azaq23> taotree: liftM takes a (a -> b) function and turns it into a IO a -> IO b function. It does do { x <- action; return (f x) } where f is the (a -> b) function
16:39:05 <taotree> mikeg: that's exactly what I did
16:39:23 <mikeg> so if you have the first kind of function, you could use liftM (or fmap)
16:39:29 <taotree> and that's where it's giving me an error... trying to map on that conversion function
16:39:31 <mikeg> if you have the second you would use binding
16:40:39 <mikeg> if you had [[SqlValue]], a function [SqlValue] -> Result, and you wanted [Result], what would you use?
16:41:11 <taotree> I created function: sqlToEvent :: [SqlValue] -> Event
16:41:44 * hackagebot nanoparsec 0.1 - An implementation of attoparsec-like parser around list-like  http://hackage.haskell.org/package/nanoparsec-0.1 (MaciejPiechotka)
16:43:24 <taotree> But I get "Couldn't match expected type `[Event]` against inferred type `IO Event`"
16:43:47 <azaq23> paste your code
16:43:48 <taotree> on line:         events <- fmap sqlToEvent dbData
16:43:49 <azaq23> @paste
16:43:49 <lambdabot> Haskell pastebin: http://hpaste.org/
16:44:38 <mikeg> so.. you would _map_ over your [[SqlValue]] to get a [Event]. But you have IO [[SqlValue]], and you want IO [Resul]t, so you use liftM and map
16:45:05 <taotree> ok, adding liftM gets me past that line
16:45:13 <taotree>         events <- liftM $ map sqlToEvent dbData
16:45:30 <djahandarie> Is there a better way to write f here? http://hpaste.org/42872/a  I feel like there is a standard function but can't remember the name
16:46:49 <ddarius> @src traverse
16:46:49 <lambdabot> Source not found. You speak an infinite deal of nothing
16:47:06 <timBau> is this sequence?
16:47:09 <djahandarie> Yeah
16:47:12 <djahandarie> Just realized
16:47:12 <djahandarie> lol
16:47:24 * djahandarie sighs
16:47:38 <taotree> ok, it didn't get me past that line... now different error
16:47:43 <timBau> > sequence [[1,2,3],[2,3,4],[5,6,7]]
16:47:45 <lambdabot>   [[1,2,5],[1,2,6],[1,2,7],[1,3,5],[1,3,6],[1,3,7],[1,4,5],[1,4,6],[1,4,7],[2...
16:48:04 <taotree> "Couldn't match expected type `a1-> r' against inferred type `[Event]`
16:48:19 <mikeg> taotree: if dbData was already bound with a <-, then you can just use `let events = map ... dbData`
16:48:34 <mikeg> since dbData will be of type [[SqlValue]]
16:49:16 <taotree> mikeg: yes, that's what I thought--ok, that worked
16:49:25 <mikeg> liftM would be used for something like: liftM (map sqlToEvent) getDBRows where getDBRows :: IO [[SqlValue]]
16:49:44 <taotree> Thank you!
16:50:31 <sf_> is haskell used at all in the creation of windows forms or is it generally used for logic based functions (i.e. engines vs. form/gui layout)?
16:51:23 <cdsmithus> So, is there a pure function like Text.decodeUtf8 with type ByteString -> Maybe Text somewhere?  The one in text either throws an exception, or silently ignores or replaces the character, which isn't what I want.
16:55:11 <gwern> cdsmithus: funnily enough, if you google that exact type signature, you turn up hits
16:55:15 <gwern> dunno if they are what you want
16:57:25 <cdsmithus> Eh.  There's one that's built using excToMaybe, but that's ugly.  I'll just replace it with \xFFFD, which will throw a parse error later.  Confusing, but not IO-abusing
16:59:58 <mikeg> Why not build maybe's based on the existence of \xFFFD?
17:01:39 <cdsmithus> I could... in theory there could be other \xFFFD occurrences in the input stream... but I'm just being picky there
17:02:23 <Zao> cdsmithus: There is a thread on haskell-cafe about this just recently.
17:26:47 <lars9> > ['a' .. 'z']
17:26:48 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
17:27:18 <lars9> > let a = 'a'; z = 'z' in [a .. z]
17:27:19 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
17:32:02 <lars9> @pl return . concat
17:32:02 <lambdabot> return . join
17:33:09 <lars9> @pl return . concat $ many $ string "abc"
17:33:09 <lambdabot> return (join (many (string "abc")))
17:36:42 <shachaf> lars9: @pl isn't going to do much when you don't have any named arguments.
17:37:02 <aristid> :t many $ string "abc"
17:37:03 <lambdabot> Not in scope: `string'
17:39:27 <ddarius> @pl map f . map g 
17:39:27 <lambdabot> map (f . g)
17:40:43 <djahandarie> @pl foldr c n (build g)
17:40:44 <lambdabot> foldr c n (build g)
17:40:46 <djahandarie> :(
17:41:00 <djahandarie> @pl destroy g (unfoldr p e)
17:41:00 <lambdabot> destroy g (unfoldr p e)
17:41:03 <djahandarie> :(
17:41:30 <monochrom> @pl \foldr -> foldr c n (build g)
17:41:30 <lambdabot> flip (flip ($ c) n) (build g)
17:43:18 <ddarius> :t build
17:43:19 <lambdabot> Not in scope: `build'
17:43:50 <ddarius> Having a rank-2 type, build cannot even be exposed in Haskell 98.
17:44:41 <djahandarie> And neither can destroy
17:51:54 <aristid> :t \build c n -> foldr c n (build g)
17:51:55 <lambdabot> forall a b a1. (SimpleReflect.FromExpr a1) => (a1 -> [a]) -> (a -> b -> b) -> b -> b
17:52:03 <aristid> :t \build c n g -> foldr c n (build g)
17:52:05 <lambdabot> forall t a b. (t -> [a]) -> (a -> b -> b) -> b -> t -> b
17:58:44 <Saizan> :t \build c n g -> (foldr c n (build g) , g c n)
17:58:45 <lambdabot> forall a b t. (((a -> b -> b) -> b -> t) -> [a]) -> (a -> b -> b) -> b -> ((a -> b -> b) -> b -> t) -> (b, t)
17:59:13 <tswett> I want to write a theorem prover in Haskell.  Unfortunately, I only have about ninety seconds before I have to go do something.
17:59:23 <ddarius> @where yarrow
17:59:23 <lambdabot> I know nothing about yarrow.
17:59:25 <ddarius> Curses
17:59:37 <tswett> I'll just have to spend thirty seconds becoming extremely skilled, and the remaining sixty writing an extremely concise theorem prover.
17:59:44 <tswett> Except now I only have sixty seconds.  Drat.
18:00:23 <heatsink> Maybe you can still do it if you work on it in parallel.
18:05:11 * hackagebot reactive-glut 0.1.10 - Connects Reactive and GLUT  http://hackage.haskell.org/package/reactive-glut-0.1.10 (ConalElliott)
18:05:52 <conal> my thanks to pastorn for fixing reactive-glut to work with recent hopengl
18:07:45 <djahandarie> How do you detect outliers in a non-normal dataset? Like if I had two peaks in the data
18:09:05 <flippo> djahandarie, do you know what distribution it is?
18:09:28 <flippo> djahandarie, if you have a reason for thinking it is non-normal, you must have an alternative in mind.
18:10:20 <flippo> djahandarie, if you have only two samples, you can model it with a bi-modal distribution, allowing only two possibilities, perhaps with equal probability.
18:12:40 <djahandarie> Well, it's just speculation that my data is non-normal, because I'm seeing things pile into two or three different areas basically
18:13:07 <djahandarie> I was thinking of outliers as stuff that is really far away from all the clusters of data
18:13:48 <flippo> Well, it's only an outlier if it doesn't fit your assumed distribution.  If you aren't ready to commit to one, then your histogram is your best guess.
18:14:26 <tswett> heatsink: success!  I forked every thread of myself every second and easily wrote a theorem prover more sophisticated than the Linux kernel.
18:14:27 <alpounet> has anyone tested lambdacat ?
18:17:32 <djahandarie> flippo, I'm currently using an epanechnikov kernel function to do a kernel density estimate over a set of data. And outliers are making it impossible to visualize, so I was going to try and remove them, but the usual stuff for doing that seems to be for normal or unimodal distributions only.
18:19:01 <djahandarie> It's possible this isn't the best way to visualize the data, but the histogram is really hard to read, so I was looking for something nicer
18:19:42 <flippo> djahandarie, I'd trim a few quantiles from each side of your range
18:25:03 <Veinor> is there any good library for rendering graphs as images?
18:25:52 <tswett> > 'b' < 'q'
18:25:53 <lambdabot>   True
18:26:15 <djahandarie> Veinor, chart
18:26:44 <Zao> > let rotate 'b' = 'q' in rotate 'b'
18:26:45 <lambdabot>   'q'
18:26:48 <tswett> Veinor: by "graphs", do you mean nodes connected with edges, or graphs of functions?
18:26:54 <djahandarie> Oh
18:27:00 <djahandarie> Those kinds of graphs
18:27:13 <Veinor> tswett: nodes connected with edges
18:27:47 <Veinor> the better thing to do would actually be to write it in HTML5...
18:28:12 <djahandarie> I know there are bindings to graphviz but I've never used them before and have little clue what they can do
18:28:17 <Veinor> ah
18:28:55 <Veinor> i... don't think my target machine has graphviz installed
18:29:08 <haskell-student> hi everyone, i'm writing a regex lib as a practicing project: http://hpaste.org/paste/42873/, it includes 3 file: Regex.hs defining regex type, regex parser and toAutomata converter; Automata.hs defining automata type and operations, and a sample simplematch.hs shows how to use the lib. could anyone please review my code and give some suggestions? thanks very much
18:29:40 <e32> hi is there any way to run cabal through an ssh proxy? searched around but couldn't find anything.
18:30:35 <jix> e32: using tsocks and an ssh socks proxy you can run almost any program through an ssh proxy
18:31:15 <shachaf> Veinor: Graphviz is a very standard tool for that sort of graph.
18:32:47 <Cale> haskell-student: It might be nice to be able to represent the regular expression which never matches, as a unit to the Alt operation, in a similar way that Eps is a unit to the Seq operation
18:33:41 <dolio> Do we have a library that gives you operations for all things regular languages are closed under yet?
18:33:53 <Cale> haskell-student: This would also let you extend alt' (and you should extend seq') to deal with the empty list case.
18:34:21 <Cale> haskell-student: It's possible to use a fold here if you'd like
18:35:25 <haskell-student> Cale: alt' and seq' are always called with 2 or more regexs
18:35:54 <haskell-student> Cale: at least 1
18:36:00 <Cale> haskell-student: Yeah, but as functions which take lists, it's nice if they behave sensibly when given an empty list
18:36:24 <bsmntbombdood> total functions ftw
18:37:54 <haskell-student> Cale: that makes sense
18:39:03 <haskell-student> Cale: now i cannot use fold
18:39:24 <haskell-student> i mean in seq' and alt'
18:39:41 <Cale> foldr Seq Eps
18:40:02 <Cale> (okay, it's not exactly the same, but it gives an equivalent regular expression :)
18:40:22 <haskell-student> in fact i want to minimize number of automata states
18:41:03 <Cale> You could also handle the list of length 0 case separately and use foldr1 Seq in the nonempty case
18:41:37 <Cale> seq' [] = Eps; seq' xs = foldr1 Seq xs
18:41:54 <haskell-student> i use IntSet to record current states, it consumes a lot of GC time when there are a lot of Epsilon transitions in the NFA
18:45:28 <haskell-student> @src foldl1
18:45:28 <lambdabot> foldl1 f (x:xs) = foldl f x xs
18:45:28 <lambdabot> foldl1 _ []     = undefined
18:45:33 <haskell-student> @src foldl
18:45:34 <lambdabot> foldl f z []     = z
18:45:34 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
18:49:12 <haskell-student> any other suggestions? overall structure?
18:55:23 <nostrand> haskell-student: there's a chapter about profiling in Real World haskell. You could ook at that for help about the GC time.
19:07:24 <Eduard_Munteanu> haskell-student: might help to pass +RTS -H64m   or something to it. It will reduce GC time but will potentially consume more memory.
19:07:45 <Eduard_Munteanu> And won't solve the actual problem.
19:08:44 <haskell-student> Eduard_Munteanu: it consume a lot of mem when pattern is very ill and large, like (a?){100}bc
19:08:55 <haskell-student> s/100/1000/
19:09:28 <haskell-student> then potentially there are 1000-2000 active states at each iteration
19:10:08 <Eduard_Munteanu> Ah, then profiling might be a good way to spot what's causing it.
19:10:14 <haskell-student> active state is stored in a IntSet, so a large IntSet is constructed and droped in each iter
19:11:38 <c_wraith> wait, do you use a pattern of lookup, modify, re-add with the IntSet?
19:11:55 <c_wraith> Doing that *will* cause a space leak if you iterate it many times
19:12:12 <haskell-student> c_wraith: yeah
19:12:26 <haskell-student> c_wraith: oh how to check it?
19:13:24 <c_wraith> How much do you know about lazy evaluation and strictness annotation?
19:13:56 <haskell-student> i know then but not used in my own proj
19:16:15 <c_wraith> well...  It's kind of a huge thing to explain over IRC.  the basic idea is that if you don't force evaluation of a huge expression, somewhere, it uses way more memory than it needs to.  Particularly if you're iteratively building up a large object from a small one
19:17:42 <c_wraith> The quick, brute-force way to see if that's the problem is to throw in some uses of seq and/or deepseq.
19:18:03 <c_wraith> If it is the problem, it's worth spending a bit of time figuring out a minimal application of seq to solve it
19:18:06 <haskell-student> c_wraith: i'm testing with '!', how to enable it with ghc?
19:18:15 <haskell-student> im using cabal
19:18:26 <c_wraith> you mean the BangPatterns extension?
19:18:32 <haskell-student> yeah
19:19:07 <c_wraith> generally, I think it's best to use LANGUAGE pragmas in the files that use the extension..  so add {-# LANGUAGE BangPatterns #-} at the top of the file
19:19:24 <haskell-student> i saw a proj using ! but does not add it into anywhere (according to grep)
19:19:45 <c_wraith> well, ! in data types is Haskell 98
19:19:55 <c_wraith> It's only in pattern-matches that you need the extension
19:20:59 <haskell-student> im doing this now: data Automata c = Automata {initial :: !Slot, ...
19:21:39 <c_wraith> Ok, that makes the field in that constructor strict, but that isn't nearly enough by itself.
19:21:52 <Eduard_Munteanu> For that it also helps to use -funbox-strict-fields, but it doesn't really solve the IntSet problem.
19:21:56 <c_wraith> You also need to make sure that the Automata constructor is evaluated
19:22:58 <Eduard_Munteanu> What you want here is to minimize rebuilding the IntSet.
19:23:25 <Eduard_Munteanu> Although that's only a guess unless you profile.
19:28:22 <augur> who was it that said that programming was like taking psychedelics
19:30:30 <Eduard_Munteanu> Isn't it like the reverse of taking that stuff? I mean, when I'm hunting bugs, I usually don't see things that are clearly there!
19:31:15 <Eduard_Munteanu> @quote psychedelics
19:31:15 <lambdabot> No quotes match. stty: unknown mode: doofus
19:31:21 <Eduard_Munteanu> Grr.
19:33:21 <augur> Eduard_Munteanu: lol
19:34:27 <haskell-student> i defined a flag "prof" in .cabal file (copying from another proj's), how to enable it when cabal build?
19:40:19 <mm_freak_> haskell-student: cabal configure --help
19:40:28 <mm_freak_> it will show your switch, too
19:42:19 <mm_freak_> a few weeks or months ago we had a discussion about parsers…  the claim was that you can parse context-sensitive grammars with purely applicative parsers
19:43:02 <mm_freak_> i'm still having trouble to get why, and i wonder if this claim holds, if you're not allowed to use combinators, which themselves require a Monad instance
19:43:26 <mm_freak_> one of those is 'try'
19:45:13 <ddarius> Unless you mean something else, the try combinator is particular to Parsec.
19:48:02 <haskell-student> iteration of NFA transitions consumes a lot of memory, increasingly
19:50:22 <mm_freak_> ddarius: then maybe we should first define what an applicative parser actually is
19:51:06 <mm_freak_> ddarius: it appears to me that if you have only certain primitive parsers and some combinators, which can be defined in terms of Applicative, then you can only parse context-free grammars
19:54:09 <dolio> > flip runState 0 $ (put 5 *> pure id) <*> get
19:54:11 <lambdabot>   (5,5)
19:59:23 <dolio> In most combinator libraries, you can probably parse any Haskell-recognizable language using only applicative combinators.
19:59:39 <dolio> Because you can represent infinite grammars.
20:04:27 <mm_freak_> dolio: i don't understand…  for example consider the following grammar:  a sequence x of letters, then a space, then a sequence of letters, of which x needs to be the prefix
20:04:36 <mm_freak_> how can you express this with purely applicative combinators?
20:05:17 <dolio> Let f :: String -> Bool be a function that recognizes that language.
20:06:01 <mm_freak_> i see
20:06:03 <haskell-student> ahh... failed to porfile mem leak
20:06:21 <haskell-student> reduced mem comsumption from 138M to 108M, but still too much
20:07:00 <dolio> parser g = pure (g "") <|> (char 'a' *> parser (g . ('a':))) <|> (char 'b' *> parser (g . ('b':))) <|> ...
20:07:10 <dolio> Then, parser f recognizes your language.
20:07:34 <haskell-student> where can I paste a picture?
20:07:51 <dabblego> imgur.com
20:07:56 <haskell-student> dabblego: thanks
20:08:07 <mm_freak_> dolio: ok, i see it now
20:08:09 <dolio> Actually, that's probably not a good way of writing it, but you get the idea.
20:09:39 <haskell-student> http://imgur.com/tFJOu this does not look right, the accumulating compustion part is an iteration of NFA transitions
20:09:47 <dolio> More like 'guard (g "")' as the first part.
20:09:51 <haskell-student> a lot of mem leak there
20:12:03 <haskell-student> anyone could please help me check code? 
20:14:48 <mm_freak_> dolio: 'guard' is monadic
20:15:14 <dolio> guard can be written with Alternative instead.
20:15:23 <mm_freak_> true
20:15:31 <dolio> guard b = f b then pure () else empty
20:15:36 <mm_freak_> but wait
20:15:53 <mm_freak_> but wait
20:16:17 <mm_freak_> you can't use <|> this way, because you're missing 'try'
20:16:57 <dolio> You don't need try. No backtracking is necessary.
20:18:31 <dolio> Or, at most one character, which doesn't require try.
20:19:04 <ddarius> mm_freak_: Again, try is a quirk of Parsec.  It's not inherent to monadic parsers nor limited to monadic parsers.
20:19:47 <mm_freak_> true
20:19:56 <dolio> Anyhow, the only combinators needed are success, failure, alternation and concatenation.
20:20:30 <mm_freak_> yeah, i get it now
20:20:40 <mm_freak_> thanks
20:20:41 <dolio> And 'end of input' I guess, if you don't want to recognize prefixes.
20:22:19 <dolio> And those combinators should be supported even for regular language parsers.
20:22:52 <mm_freak_> that statement was actually very helpful:  "the only combinators needed are success, failure, alternation and concatenation"
20:22:57 <mm_freak_> that makes perfect sense
20:26:44 <turiya> If i create memory in C and return a pointer, which is used on the haskell side, how can the pointer be freed at the end? 
20:27:09 <mauke> manually
20:27:31 <ian_mi> free
20:28:19 <turiya> mauke: by using the C free () function?
20:28:46 <mauke> depends on how you allocated it
20:29:26 <turiya> Assuming i allocated using malloc
20:30:18 <mauke> then you could call a corresponding destructor function in C, or call the free function in one of the Foreign modules, or foreign import free manually
20:31:59 <turiya> Oh..i see, what about creating a foreignptr and adding a finalizer? Is it different than calling free manually?
20:33:01 <mauke> I think that's fine
20:35:07 * ddarius should restring all of his guitars.
20:35:35 <turiya> Ok, i got this doubt cleared, thanks
20:39:25 <mm_freak_> can you intermix Foreign.Marshal.Alloc functions with the corresponding C functions?
20:40:58 <ddarius> @where ffi
20:40:59 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
21:04:17 <ph> i'm having trouble getting file IO to work
21:04:56 <ph> it always returns an error saying the file doesn't exist
21:05:09 <monochrom> I think it's telling the truth.
21:06:05 <ph> im on a mac, i know the filepath is correct because it's the one finder supplies when you drag and drop a file icon
21:06:37 <Cale> ph: what does the path look like?
21:07:19 <ph> um
21:07:25 <ph> it starts with a slash
21:07:28 <Cale> okay
21:07:33 <Cale> That's a good sign :)
21:07:41 <ph> then LuxRender_test_scene.zip
21:08:01 <mauke> that seems unlikely
21:08:04 <Cale> "/LuxRender_test_scene.zip"  would be in your root directory
21:08:11 <ph> it is
21:08:16 <ph> im not very organized
21:08:34 <mauke> wait, you're working as root?
21:08:43 <monochrom> permission flags?
21:08:48 <ph> oh...
21:08:54 <ph> that might be why
21:09:13 <ph> im not
21:09:26 <monochrom> never trust yourself again
21:10:46 <ph> nope, it tried it with a file in my home directory and it said the same thing
21:11:06 <mauke> ok, what's your code?
21:11:35 <ph> main = do filep <- getLine
21:11:37 <monochrom> give full disclosure of full code and full directory listing
21:11:52 <ph> fileh <- openFile filepath ReadMode
21:11:57 <mauke> ph: that's a syntax error
21:12:08 <ph> filec <- hgetconents fileh
21:12:09 <mauke> ph: the last statement in a do block must be an expression
21:12:17 <mauke> holy fuck, dude
21:12:17 <ph> putstrln filec
21:12:20 <mauke> stop
21:12:27 <ph> ?
21:12:44 <mauke> ok, step 0: have you ever heard of copy/paste?
21:12:49 <mauke> step 1: don't paste code into irc
21:12:52 <ph> copy paste doesnt work
21:13:05 <mauke> step 2: don't say "doesn't work", it's meaningless
21:13:16 <ph> well, i was typing it out line by line
21:13:19 <mauke> obviously
21:13:24 <ph> i thought you meant i should copy paste
21:13:49 <mauke> you should put your code in a pastebin
21:14:03 <ph> pastebin?
21:14:13 <monochrom> are you a learned programmer?
21:14:32 <ph> no
21:14:37 --- mode: ChanServ set +o mauke
21:14:37 --- topic: set to '["Paste code/errors: http://hpaste.org", "GHC 7 is out: http://is.gd/hb8vE", "Haskell Platform 2010.2: http://is.gd/dCGPn", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by mauke
21:14:39 <ddarius> monochrom asks silly questions upon occasion.
21:15:16 * edwardk waves hello.
21:15:25 <mauke> what happens when you copy/paste?
21:15:35 <ph> it just doesn't do anything
21:15:36 <chessguy> hiya edwardk 
21:15:37 --- mode: mauke set -o mauke
21:15:47 <edwardk> heya chessguy, ltns
21:16:05 <chessguy> yeah, i don't really hang out here that much these days
21:16:11 <mauke> ph: that sounds like a serious problem with your system
21:16:38 <edwardk> ya, me neither, well, a lot this week, but i've been seriously slacking off lately ;)
21:16:41 <chessguy> ruby is my sweetheart thease days
21:17:18 <ph> you mean my codes ok?
21:17:19 <edwardk> scala here, well, not so much sweetheart, so much as someone i'm in an abusive relationship with
21:17:29 <shachaf> edwardk: Who's doing the abusing?
21:17:32 <mauke> ph: no, I mean copy/paste is pretty fundamental
21:17:32 <chessguy> though in my defense, i did just send a bunch of haskell resources to a guy i heard was learning haskell the other day
21:17:33 <edwardk> its mutual
21:17:44 <edwardk> i break its type system and the compiler, it breaks my code
21:17:46 <ph> its only with my browser
21:17:48 <mauke> ph: I have no idea what your code looks like because you can't copy/paste
21:17:51 <shachaf> edwardk: Why Scala?
21:17:54 <mauke> what
21:17:56 <ph> i said all of it
21:18:02 <mauke> ph: no, you didn't
21:18:05 <ddarius> edwardk: The only question is who is abusing who.
21:18:15 <edwardk> shachaf: because they pay me to write it these days and anything worth doing is worth doing over the top ;)
21:18:31 * ddarius is slow.
21:18:45 <chessguy> edwardk, anything to get away from java but keep the JVM, eh? :)
21:18:56 <dabblego> scala is abusing me at the moment
21:19:00 <ph> want me to put it on that hpaste thing?
21:19:03 * ddarius is happy getting away from both the JVM and Java.
21:19:06 <mauke> ph: yes
21:19:15 <edwardk> i almost cried when i came back to haskell and wrote something in a 10th of the space. i'd gotten to where i was seeing the scala syntactic overhead as natural ;)
21:19:16 <applicative> ph, http://hpaste.org/
21:19:24 <applicative> ph, we will study
21:19:30 <edwardk> well, i'm not a huge fan of the jvm honestly ;)
21:19:36 <chessguy> hm, really? i don't know if i've ever heard anyone say they didn't like the JVM
21:19:56 <chessguy> other than missing TCO, maybe
21:19:59 <edwardk> two words, type erasure
21:20:08 <edwardk> (done poorly)
21:20:16 <dabblego> the JVM is not missing TCO, the Sun implementation is
21:20:30 <ddarius> While the JVM is not a complete piece of crap, it is hardly endearing.
21:20:33 <edwardk> dabblego which is tantamount to the same thing
21:20:46 <dabblego> not when you work on the IBM JVM implementation :)
21:21:00 <ph> it's #42876
21:21:01 <dabblego> there are lawyers making sure there is a clear delineation!
21:21:08 <monochrom> you see how "the JVM" makes no sense.
21:21:18 <ph> my_test_program
21:21:21 <edwardk> write 50 times, run anywhere ;)
21:21:25 <shachaf> Why does the Sun implementation not do TCO?
21:21:31 <chessguy> hehe
21:21:38 <monochrom> probably "there is no demand"
21:21:40 <dabblego> shachaf, the RFE is pages long
21:21:48 <dabblego> monochrom, there is, it was opened in 2001
21:21:56 <ph> http://hpaste.org/42876/my_test_program strange how i can copy paste within my browser...
21:22:16 <ddarius> dabblego: Then we'll see it in the spec sometime around 2050.
21:22:22 <edwardk> dabblego: started porting the reactive machinery i was working on in scala over to haskell, its coming along a lot faster
21:22:29 <dabblego> the RFE has been closed as "won't fix"
21:22:35 <edwardk> i'll see if i can backport once it is coherent
21:22:49 <shachaf> dabblego: Why?
21:22:50 <dabblego> edwardk, I do that a lot -- write it in haskell first, even though it will be scala in the end
21:23:08 <edwardk> scalaz will probably pick up a bunch of comonads soon, too
21:23:12 <mauke> ph: how are you running it?
21:23:16 <dabblego> shachaf, similar misunderstandings to Guido's sentiments and Python
21:23:21 <dabblego> edwardk, woot!
21:23:40 <applicative> ph, whats the problem.  It's valid, it works, etc.
21:23:45 <ph> i look in the build folder and open the executable
21:23:48 <dabblego> shachaf, http://bugs.sun.com/view_bug.do?bug_id=4726340
21:23:58 <mauke> ph: and then?
21:24:01 <ddarius> edwardk: Soon they'll be able to collect dust as noone knows what to do with them on the JVM too.
21:24:21 <edwardk> ddarius: haha =)
21:24:42 <ph> mauke: i put hte results in the paste
21:24:46 <edwardk> well, i'm actually using a a full fledged comonad transformer in some capitaliq code
21:25:20 <mauke> ph: there's a space at the end of the filename
21:25:26 <ddarius> edwardk: Does this actually give you any benefits?
21:25:42 <edwardk> i think the main thing they were missing was the comonadzip machinery that uustalu added to make the EODP machinery work. that gives me applicative-like syntax for them
21:26:16 <edwardk> at that point a comonadzip/comonadapply is like an applicative with extract instead of pure and the addition of extend
21:26:41 <ph> mauke: that's it
21:26:56 <ph> removed the space, now it gives me a different error
21:27:00 <edwardk> it has made for some pretty clean code for dealing with database serialization of all things
21:27:06 <mauke> yay?
21:27:11 <ph> yep
21:27:15 <edwardk> trying to figure out how to generalize the result into something worth doing a talk on
21:27:37 <ph> "invalid argument illegal byte sequence"
21:27:44 <mauke> ph: it's a jpeg, use openBinaryFile
21:27:54 <ph> thought so
21:28:00 <edwardk> i thought i had a clean way to model dataflow with density comonads the other day, but it didn't pan out =/
21:28:11 <monochrom> openFile assumes utf-8 text on your platform by default
21:28:24 <edwardk> it lasted just long enough for me to get excited by it and waste a few hours scribbling
21:28:36 <ph> mauke: now it works
21:28:45 <edwardk> but that led to the cleaner ComonadApply machinery
21:28:45 <ph> thanks :)
21:28:51 <edwardk> which may make comonads tolerable to folks
21:28:58 <applicative> ph, i just used the file itself http://hpaste.org/paste/42876/my_test_program_annotation#p42879
21:29:14 * ddarius figured out his hang up with casting Conal's type class morphisms as algebraic semantics so he should have a (short?) paperish thing soon(er or later.)
21:29:18 <applicative> ph, under the name Util.hs, it read it out just fine.
21:29:41 <edwardk> added a semigroup package, and added Traversable1 and Foldable1 to functor-apply, which lets you do some traversable-like stuff with comonads
21:29:55 <ddarius> edwardk: Dan told me how you came up with "callCV" by the way.
21:29:59 <conal> ddarius: where do you publish your thoughts?
21:30:13 <ph> yeah, its cause it was a jpeg, thanks applicative
21:30:28 <edwardk> ddarius: flipping all the kleisli arrows to be cokleisli ones? it was easy enough, just don't have a good use yet =)
21:30:29 <ddarius> conal: I mostly don't.  They are usually spread through various little replies throughout the web.
21:30:42 <ddarius> edwardk: He mentioned something involving iteration and djinn.
21:30:46 <edwardk> i really want to understand what it means
21:30:55 <conal> ddarius: ah.
21:31:42 <edwardk> ah, i worked out a version that was Discont s (Discont s (Discont s a -> a) -> a) -> a — but that wasn't the most general, djinn helped find the weaker signature
21:32:03 <applicative> ph, yes, i just tried a png file
21:32:10 <edwardk> i suppose that could also be done just by asking ghc
21:32:44 <edwardk> but it was very handy
21:33:11 <applicative> ph, did you want to try to work with jpegs? or just any file
21:33:12 <edwardk> dan also spent an afternoon in agda proving some comonad laws for me when i realized the ContextT in category extras was the wrong ContextT
21:33:49 <ph> text
21:33:52 <edwardk> though we turned out to have the wrong extend, so roconnor beat him to the proof =)
21:33:57 <ph> i got it working now
21:34:00 <adnap> in this tutorial, what is "-&gt;"?  Is that an encoding error on my browser? http://netsuperbrain.com/blog/posts/introducing-reactive-events/
21:34:13 <mauke> should be ->
21:34:14 <shachaf> adnap: &gt; is an HTML representation of >.
21:34:18 <monochrom> -&gt; is ->
21:34:28 <adnap> oh, thanks
21:34:37 <ph> turns out mac os x adds a space to the end of the filename when you drag it's icon into terminal. probably so you can add some other argument after that
21:34:50 <ddarius> edwardk: Yeah, he mentioned that too.
21:35:32 <edwardk> i was going to tag along, but he wanted to head out the door while i was still working on something
21:35:49 <ddarius> Your Haskell deque?
21:35:56 <edwardk> nah that came later
21:36:06 <ddarius> I figured.
21:36:26 <edwardk> that actually started on the T coming home
21:36:26 <copumpkin> omg is this talk about me I see before me
21:39:28 * applicative didn't realize you could drag into Terminal.app, freaky
21:41:47 <ddarius> edwardk: The food was good; the music had abruptly moved to Saturday though.
21:42:09 <copumpkin> I'd have been up to going today but I was already going somewhere else tonight :/
21:42:44 <edwardk> type inference oh how i have missed you!
21:42:49 <copumpkin> :P
21:45:12 <applicative> edwardk, who cant infer types?
21:45:44 <dabblego> scala, when you try to do anything useful
21:46:06 <edwardk> scala, at least meaningfully
21:46:20 <copumpkin> gah
21:46:22 <applicative> i see. scala.  I thought it was supposed to be more avant garde and superadvanced etc. 
21:46:31 <edwardk> especially if you use lots of interfaces, and when it does infer them, it only infers one way
21:46:45 <applicative> i don't care, since it's just as ugly as the worst of them.
21:46:48 <ddarius> applicative: superadvanced means no type inference
21:47:01 <edwardk> applicative; trait Foo { type F[_] } — write that in your code and you can get the compiler to tie itself in knots
21:47:05 <applicative> right, I guess I noticed that even with this haskell thing
21:47:19 <copumpkin> I killed my agda by mistake
21:47:22 <copumpkin> not sure how
21:47:26 <copumpkin> but I've had it happen before
21:47:27 <edwardk> it'll accept it. you can even do stuff with it, but any time you use that internal type, be warned ;)
21:47:59 <applicative> i broke my agda trying to update
21:48:19 <ddarius> edwardk: The difference between what Scala is supposed to do and what it actually does is apparently significant.
21:48:41 <dabblego> yes, Scala has lots of bollocks around it, and lots of people who buy it too
21:49:12 * applicative though ddarius was saying Scala does so much more than it is supposed to do
21:49:19 <edwardk> yeah, if the features that scala's manual claim are there worked uniformly and consistently i'd be a huge fan
21:51:28 <applicative> to use Scala enough to figure out the Idea of Scala, would I have to know about java libraries and nonsense like that?
21:51:36 <edwardk> nah
21:51:39 <dabblego> only a little
21:52:01 <applicative> dealing with C world all the time is horrible enough....
21:52:05 <dabblego> the scala libraries are almost as nonsense as the java ones though
21:52:07 <edwardk> i use them a little more now that i'm doing crazy amounts of concurrency stuff to stay interested, but i went a couple months before i saw a java.anything in my code
21:53:13 <ddarius> edwardk: It sounds like your are porting C# stuff (albeit the new shiny stuff) with additions.
21:54:06 <edwardk> some, mostly its c++ machinery (for tbb style task parallelism) the reactive stuff is a veneer on top
21:55:08 <ddarius> I was looking at the new DLR/dynamic stuff and thinking if there is anything I could do with it that wasn't evil.
21:55:10 <edwardk> i care less about latency and fairness than what the microsoft guys do though, because the focus on task parallelism removes a lot of the ordering requirements
21:55:17 <edwardk> its pretty evil =)
21:55:36 <edwardk> its nice if you want to interop with java or python or what have you though
21:57:44 <edwardk> @pl \a -> f a (p a)
21:57:45 <lambdabot> ap f p
21:57:52 <edwardk> duh
21:58:17 * ddarius doesn't know why C# copied Java about arrays.
21:58:25 <ddarius> Array covariance that is.
21:58:47 <c_wraith> @pl \a -> f (g a) (h a) -- this is something I do often enough I learned the point-free form
21:58:48 <lambdabot> liftM2 f g h
21:59:23 <edwardk> general stupidity?
21:59:35 <ddarius> c_wraith: You should play with J.
21:59:43 <edwardk> and lack of const
21:59:58 <c_wraith> J?
22:00:12 <ddarius> edwardk: C# could readily handle an implicit conversion to ReadOnlyArray<A> that is covariant.
22:00:20 <edwardk> now it could
22:00:45 <edwardk> or even have a covariant read only supertype and a contravariant write only supertype
22:01:07 <edwardk> thats how i handle it in a lot of my data structures
22:02:19 <edwardk> hrmm, ContT doesn't pass through MonadError?
22:02:35 <ddarius> Yeah, I was thinking that too, but I think the read-only case covers most of the actual use-cases.  Heck, the invariant case probably handles most actual use-cases.  It certainly wouldn't be hard to do both.
22:02:57 <ddarius> @google j programming language
22:02:58 <lambdabot> http://www.jsoftware.com/
22:02:58 <lambdabot> Title: J Home
22:03:18 <edwardk> invariant is the way scala arrays handle them
22:03:31 <edwardk> and scala maps, etc are invariant if mutable, covariant if not
22:03:41 <edwardk> which is rather nice
22:05:44 <edwardk> nice in the sense that "the spoiled brat didn't make a mess at dinner, how nice!", but nice ;)
22:07:09 <bsmntbombdood> c_wraith: where does that idiom show up?
22:07:38 <turiya> Is there a general way to add two functions which are described as :: [Int] -> [Float]?
22:07:58 <bsmntbombdood> turiya, define add
22:07:59 <c_wraith> bsmntbombdood: common cases are liftM2 (>>) and liftM2 (<$>)
22:08:52 <bsmntbombdood> turiya, if it's (f x) ++ (g x), then liftM2 (++)
22:09:09 * ddarius casts on a hundred stitches 'cause he just needs to get started.
22:10:38 <turiya> Add f1 f2 = f3 where f3[i,j] = f1[i,j] + f2[i,j] 
22:11:16 <turiya> For lists containing two elements
22:11:55 <bsmntbombdood> that should be s/++/+/ probably
22:12:20 <turiya> And assuming the 'output' lists are of the same length
22:13:01 <turiya> Oh..liftM2, i see..
22:13:18 <applicative> > (++) <$> reverse <*> tail $ [5,4,3,2,1]
22:13:21 <lambdabot>   [1,2,3,4,5,4,3,2,1]
22:13:56 <applicative> > liftM2 (++) reverse tail $  [5,4,3,2,1]
22:13:58 <lambdabot>   [1,2,3,4,5,4,3,2,1]
22:15:02 <turiya> @liftM2
22:15:02 <lambdabot> Unknown command, try @list
22:15:11 <applicative> @type liftM2
22:15:12 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
22:15:14 <turiya> @src liftM2
22:15:14 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
22:15:17 <bsmntbombdood> wow, suitable nickname applicative 
22:15:46 <ion> @src <$>
22:15:47 <lambdabot> f <$> a = fmap f a
22:15:49 <ion> @src <*>
22:15:49 <lambdabot> Source not found. That's something I cannot allow to happen.
22:16:44 <BMeph> turiya: Did folks already mention "zipWith (+)" to you?
22:18:51 <turiya> BMeph: zipWith works only with lists, isnt that so?
22:18:52 <applicative> BMeph, turiya is thinking zipWith (+) (f as) (g as), more or less (I think) 
22:19:12 <bsmntbombdood> @src ap -- ==<*>, ion
22:19:13 <lambdabot> Source not found. There are some things that I just don't know.
22:19:46 <bsmntbombdood> lambdabot doesn't understand comments?
22:20:04 <turiya> applicative: yes, i think that is what i wanted :)
22:20:31 <applicative> but the idea was to abstract out the common "as" , as I wrote it.
22:21:26 <turiya> Ah, there always seems to be a way to do things in a much simpler way
22:22:44 <armlesshobo> i'm trying haskell online and I want to know what the purpose of the 'in' token and why you need to call the function name after it
22:23:04 <bsmntbombdood> armlesshobo, it's part of let
22:23:09 <applicative> armlesshobo, it is just a special restriction in try haskel.
22:23:31 <applicative> it applies in here to lambdabot.   Every line must be a complete evaluable expression. 
22:23:49 <armlesshobo> I see
22:24:01 <applicative> > let armlesshobo = "armlesshobo" in reverse armlesshobo
22:24:42 <applicative> uh oh i've offended her.
22:25:00 <armlesshobo> for me, the syntax isn't completely intuitive, as I've been so used to seeing "let" in other languages
22:25:11 <armlesshobo> and so when I see "in" it really throws me off :P
22:25:51 <armlesshobo> what applications can Haskell be used for besides making lists?
22:25:53 <applicative> armlesshobo, it is different in Haskell too.  It is just the only way to combine function definition with the constraint that you end up with a comlete evaluable expression
22:25:57 <applicative> to put it crudely
22:26:16 <applicative> armlesshobo. You can also reverse lists!
22:26:35 <edwardk> thats it. there is nothing else to it =)
22:26:41 <applicative> In the standard libs, we even have *append*
22:26:41 <armlesshobo> hmmm
22:26:54 <edwardk> i use it when i go to do my grocery shopping at the end of the week.
22:27:06 <applicative> admittedly avant garde types also map over wierd trees, IO actions, etc
22:27:15 <edwardk> comonads
22:27:23 <armlesshobo> so, by finishing the try haskell lessons, i'll officially know everything about Haskell? :P :D
22:27:29 <armlesshobo> ;)
22:27:46 <applicative> uh, then go on to LYAH and RWH
22:27:54 <bsmntbombdood> i don't understand why there's map and fmap
22:27:56 <applicative> @where LYAH
22:28:19 <applicative> bsmntbombdood, the answer, let us say in a grave tone, lies in History
22:29:09 <bsmntbombdood> darn, History always fucks up elegance
22:29:11 <applicative> bsmntbombdood, also, we mark the difference because when we make it from map to fmap we have made a great conceptual step
22:29:28 <applicative> it must be marked specially, 
22:29:43 <armlesshobo> applicative: LYAH? RWH?
22:29:52 <applicative> only the one who has made the rite of passage can say 'fmap'
22:29:58 <applicative> @where lyah
22:30:10 <edwardk> at the time of haskell 98 there was a great push to make sure that there were simple and generic versions of everything.
22:30:14 <applicative> armlesshobo, my bot is missing.
22:30:34 <edwardk> there was a sort of misguided pedagogical justification that it should be easier to teach this way
22:30:49 <bsmntbombdood> applicative, hmm. i know what fmap means, does that mean i can say it?
22:30:51 <edwardk> that and the compiler used to spit out AWFUL errors
22:31:16 <applicative> Learn You a Haskell is the happening tutorial these days soon to be a book; "Real World Haskell" is a book also on line.
22:31:19 <edwardk> in practice it seems the community has roundly rejected that mindset
22:31:25 <edwardk> which makes me happy
22:32:01 <applicative> armlesshobo put "learn you" into google, it will autocomplete you to the right place :)
22:32:03 * ddarius doesn't think the error messages GHC produced in 98 are too much different than the ones it produces today.
22:32:30 <bsmntbombdood> edwardk: easier to teach "map maps a function across lists", instead of "[f]map lifts a function into a functor"?
22:32:54 <edwardk> bstmtbombdood: i usually introduce functors, and then lists ;)
22:33:16 * ddarius usually introduces monoids, adjunctions, and then free monoids.
22:33:27 <edwardk> ddarius is harder core than me ;)
22:33:28 <applicative> bsmntbombdood, it is well to begin with examples.  map for lists is conceptually easier than e.g. for trees. cp the replacement axiom in set theory
22:34:45 <applicative> the moment when we grasp fmap is the greatest moment in learning Haskell.  I have seen it even with adolescents hereabouts. 
22:35:06 <applicative> you would think it was impossible for such a thing to be learned at all.
22:35:21 <ddarius> Most people don't have much/any trouble with Functor.
22:35:28 <jmcarthur> you don't see anybody complaining that they don't understand (+) just because it's generic
22:35:54 <edwardk> functor is nice, because its the first moment when people tend to realize they aren't in python
22:35:57 <c_wraith> yeah, Functor is relatively easy.  Though it's more subtle than I realized at first
22:35:58 <applicative> there is really little comparison between class Functor and class Num
22:36:03 <ddarius> If (+) wasn't generic, it'd have defined strictness characteristics.
22:36:09 <jmcarthur> > sin + cos $ 1
22:36:12 <bsmntbombdood> applicative, it seams functors are relatively easy, doesn't have more trouble when you generalize them into monads?
22:36:18 <jmcarthur> oh no LB :(
22:36:19 <applicative> it is strange to me that they can even fit together syntactically
22:37:11 <applicative> bsmntbombdood no, the claim that functors are easy is false.  the whole intellectual difficulty is fmap, this is my brazen claim. 
22:37:37 <jmcarthur> functors are easy and so are monads
22:37:41 <c_wraith> I feel like I could implement and use Functor/fmap long before I really understood them.
22:37:57 <applicative> jmcarthur, is function application easy?
22:38:24 <jmcarthur> applicative: i see your point that there is some threshold where a lightbulb goes off
22:38:33 <nanothief> I thought functors were easy and monads were hard, but everyones different
22:38:46 <bsmntbombdood> fmap map is the only time i understood the, uh, "mathy" definition
22:38:50 <dabblego> I thought monads were hard, but I was wrong
22:38:55 <jmcarthur> applicative: i'm being a little sarcastic. i'm mainly just arguing that the threshold may be different for different people
22:39:05 <bsmntbombdood> "fmap is a structure-preserving isomorphism between categories"
22:39:27 <nanothief> dabblego: I would argue that monads are hard, but you just got your mind around them eventually
22:39:29 <applicative> jmcarthur, maybe.  i am slowly developing a possibly cranky pedagical theory
22:39:36 <dabblego> nanothief, I wouldn't :)
22:41:03 <jmcarthur> applicative: i felt that i had a grasp on things before i actually did (and there's still a good chance of course that i still don't). my lightbulb moment wasn't very related to functor directly, but tied together all sorts of seemingly unrelated things, i think
22:41:24 <ddarius> bsmntbombdood: It's not an isomorphism and it's only part of a "homomorphism" of categories.
22:42:04 <bsmntbombdood> ah, so it's wrong
22:42:09 <bsmntbombdood> no wonder i though i understood it
22:42:36 <applicative> bsmntbombdood in any case, fmap is stuck in Hask, so more and less can be said about it than the morphism part of a 'real' funcot
22:42:40 <applicative> functor
22:43:31 <bsmntbombdood> i need to learn some more category theory
22:44:23 <applicative> bsmntbombdood, why not just learn a bit more Haskell?  Unless you have an independent interest...
22:45:00 <bsmntbombdood> applicative, well, both
22:45:42 <BMeph> Monads are not hard; they're warm and fuzzy! ;þ
22:46:12 <bsmntbombdood> are there any recommended books about more advanced/theoretical haskell?
22:46:32 <applicative> somehow an idea like 'natural transformation' is pretty rough without an illustration like, I don't know, maybeToList
22:46:47 <applicative> and 10,000 other haskell functions
22:47:03 <ddarius> applicative: A (di)natural transformation is just a polymorphic function.
22:47:37 <BMeph> ddarius: toList! ;)
22:47:39 <applicative> yes, the latter is very easy to understand in Haskell, 
22:47:40 <ddarius> And, in fact, the intuition from polymorphic functions isn't horrible when considering arbitrary natural transformations.
22:47:52 <applicative> ddarius, that was my thought, yes
23:00:09 <adnap> omg this: http://www.starling-software.com/misc/icfp-2009-cjs.pdf
23:03:57 <augur> i think i understand continuation-based backtracking @_@
23:07:26 <adnap> need a good tutorial for tracking down space leaks
23:08:58 <Jafet> GHC has a heap profiler.
23:10:31 <adnap> i know, i've used it
23:11:21 <adnap> i was just referring to the paper i've posted.  i've had similar issues trying to utilize that one program that generates graphs based on heap profiler output
23:11:35 <adnap> hp2ps or something like that
23:12:04 <adnap> and reasoning about laziness and space leaks in general
23:12:47 <adnap> however, i certainly have invested less time learning these things than learning cool new syntax, abstractions, and libraries
23:17:39 <adnap> lol hugglesworth
23:18:24 <Hugglesworth> lol?
23:18:42 <Hugglesworth> I'm huggly, it's not my fault
23:18:56 <adnap> he he
23:19:09 <adnap> and you must be very refined
23:19:20 <Hugglesworth> that I am
23:19:25 <Hugglesworth> *tightens bowtie*
23:19:26 <adnap> like the turtle candy mascot
23:19:56 <Hugglesworth> I actually got a bowtie for x-mas
23:20:04 <Hugglesworth> they're surprisingly hard to find
23:20:16 <adnap> really?
23:20:18 <bsmntbombdood> http://hpaste.org/42852/ugly
23:20:22 <bsmntbombdood> gonna try asking this question again
23:20:26 <adnap> Hugglesworth: http://1.bp.blogspot.com/_9Fx5B5EqTR4/TIykrHz2RBI/AAAAAAAAACo/A9wSbs8wpMQ/s320/S1049%5B1%5D.jpg
23:20:28 <bsmntbombdood> what's the prettier way to write that?
23:21:04 <Hugglesworth> =3
23:21:18 <adnap> bsmntbombdood: i'll give this a shot
23:21:23 <Hugglesworth> bsmntbombdood: no clue, I'm a bit of a newb
23:22:53 <Hugglesworth> adnap: yeah. You can buy the clip-on ones anywhere, but it's really hard to find a proper silk one
23:24:39 <adnap> bsmntbombdood: what is Plus?  at first i thought it was that monoid, but now i realize that's sum
23:24:43 <Sunhay_> map +1 [1..10]
23:24:46 <adnap> bsmntbombdood: *Sum
23:24:46 <Sunhay_> hrm
23:24:59 <Sunhay_> product [1..10]
23:25:02 <adnap> > map (+1) [1..10]
23:25:07 <Sunhay_> eval product [1..10]
23:25:15 <Sunhay_> @eval product [1..10]
23:25:17 <bsmntbombdood> adnap, + in a regular expression
23:25:31 <adnap> bsmntbombdood: did you define it, or is it from a package?
23:25:41 <adnap> where is lambdabot?
23:25:51 <adnap> > putStr "hello?"
23:25:56 <djahandarie> In ping timeout hell
23:25:59 <bsmntbombdood> like a kleene star, but i found it easier to define without the empty result
23:26:07 * djahandarie pokes Cale to tell him lambdabot is borked
23:26:10 <Sunhay_> lol
23:26:14 <Sunhay_> that would explain it
23:26:21 <Sunhay_> i was confused for a second
23:26:27 <bsmntbombdood> adnap, full code: http://hpaste.org/42864/regex
23:26:32 <ddarius> preflex: seen lambdabot
23:26:32 <preflex>  lambdabot was last seen on #haskell 1 hour, 7 minutes and 19 seconds ago, saying: Source not found. There are some things that I just don't know.
23:26:44 <adnap> bsmntbombdood: ty
23:29:21 <bsmntbombdood> @pl \f g -> foldl1 f $ map (foldl1 g)
23:29:49 <bsmntbombdood> @pl \f g -> foldl1 f . map (foldl1 g)
23:29:56 <bsmntbombdood> ...where is lambdabot
23:30:44 <cdsmithus> Apparently not here.
23:32:17 <edwardk> @pl \ env m -> runTask m (success env) (failure env) env
23:32:30 <edwardk> gah
23:39:53 <bsmntbombdood> edwardk, sounds like liftM3
23:40:03 <ivanm> preflex: seen lambdabot
23:40:03 <preflex>  lambdabot was last seen on #haskell 1 hour, 20 minutes and 50 seconds ago, saying: Source not found. There are some things that I just don't know.
23:40:17 * ivanm guesses lambdabot has gone of to find the source
23:40:19 <edwardk> yeah
23:40:32 <ivanm> or has she gone to hit the sauce? :p
23:40:33 <edwardk> i flopped the args around a little and it was fine as a liftA3
23:41:14 <adnap> bsmntbombdood: i'm not sure why you're doing foldr interleave.  it just looks like it would create a mess to me.
23:41:16 <edwardk> hrmm, trying to figure out the right way to tell my tasks that they've been stolen. (as in shape of the function, not how to break it to them) ;)
23:41:29 <edwardk> what i have right now is a cheesy task monad
23:41:53 <edwardk> newtype Task a = Task ((a -> IO ()) -> (SomeException -> IO ()) -> Env -> IO ())
23:42:05 <adnap> bsmntbombdood: is "foldr interleave [] [[1,2,3],[4,5,6],[7,8,9]]" what you expect in ghci?
23:42:10 <bsmntbombdood> adnap, it took non negligible trial and error to get there, but it does work
23:42:12 <edwardk> which is just basically a manually unrolled EitherT'd ReaderT'd IO
23:42:31 <adnap> bsmntbombdood: i get [1,4,2,7,3,5,8,6,9]
23:42:39 <edwardk> the Env is a Deque which is where it puts work it wants to spawn
23:42:49 <bsmntbombdood> adnap, right, that property is important with infinite streams
23:43:13 <edwardk> i could add another member to the Task, but then it is going to box itself
23:43:31 <Jafet> That's an interesting way to interleave streams
23:44:13 <bsmntbombdood> Jafet, first thing i came up with -- is something else more canonical?
23:44:27 <copumpkin> Cale: I played with some magnets tonight
23:44:31 <Jafet> Yours is the most compact I've seen, surely
23:44:32 <copumpkin> Cale: I can see why you're so addicted to them
23:44:32 <adnap> when i think of + with regular expressions, i think of iterate
23:44:49 <Jafet> The one I use is from monad-omega
23:45:04 <edwardk> i guess i could just add an extra argument
23:45:29 <edwardk> (a -> IO()) -> (SomeException -> IO()) -> Env -> Bool -> IO () — telling it has been stolen
23:45:43 <adnap> bsmntbombdood: i just don't see the significance of the ordering
23:46:23 <edwardk> but then i need to clear that at some point in the bind process, so it becomes state, which means it infects the success and failure continuations too
23:46:24 <bsmntbombdood> adnap, the arguments to interleave are often streams
23:46:47 <edwardk> (a -> Bool -> IO ()) -> (SomeException -> Bool -> IO ()) -> Env -> Bool -> IO ()
23:46:47 <bsmntbombdood> otherwise it would just be (++)
23:48:38 <edwardk> on the other other hand, i don't need to enqueue tasks in the deque, i could enqueue 'splittable tasks' that know what to do when they are stolen, so the moand doesn't have to pay for it, just the stuff coming in and out of the deque
23:49:09 <edwardk> that would let me mimic cilk's fast/slow path machinery
23:49:12 <adnap> bsmntbombdood: so you want it to iterleave the last two lists, then interleave that with the next list, and so on from right to left?
23:49:32 <bsmntbombdood> Adamant, the result of the do is a list of streams
23:49:35 <bsmntbombdood> er, adnap 
23:50:12 <edwardk> stolen work executes the slow path, and when you hit the bottom of your stack you strobe some event or barrier
23:50:22 <adnap> bsmntbombdood: it's a list of lists of strings i think
23:50:24 <edwardk> that way they can know you've rendezvoused
23:50:42 <bsmntbombdood> adnap, a list of streams of strings
23:51:13 <adnap> bsmntbombdood: so type Stream = [String]?
23:51:36 <bsmntbombdood> adnap, a possibly infinite list
23:53:45 <ion> cross :: [Stream] -> a
23:53:56 <ion> cross _ = error "Don't cross the streams"
23:54:51 <copumpkin> you know that means Not [Stream] !?
23:55:06 <mauke> it shouldn't error if you only give it a single stream
23:55:27 <copumpkin> leaving the question of what it should return!
23:55:54 <copumpkin> cross [] = undefined; cross [x] = undefined; cross _ = error "Don't cross the streams!"
23:55:58 <copumpkin> yay, different bottoms
23:56:21 <shachaf> All bottoms are equal.
23:56:26 <shachaf> Although some are more equal than others.
23:57:13 <Jafet> unsafeCoerce undefined
23:57:28 <Jafet> (The bottom with many faces)
23:57:51 <copumpkin> Jafet: doubly many faces?
23:57:57 <copumpkin> how about 
23:58:01 <copumpkin> undefined (unsafeCoerce undefined)
