00:06:40 <turiya> Hi
00:07:53 <bsmntbombdood> adnap, and the fold just combines a list of streams into a single one
00:10:32 <adnap> bsmntbombdood: yes, but the order in which it combines them seems strange
00:10:38 <turiya> f::[Int]->[[Int]], 
00:10:38 <turiya> f [10,10] = [[1,1],[1,2
00:10:56 <turiya> Oops..
00:11:04 <adnap> bsmntbombdood: i am still playing with it though
00:11:05 <bsmntbombdood> adnap, could be foldl just as easily
00:11:19 <adnap> bsmntbombdood: do you care how the streams are combined?
00:11:47 <bsmntbombdood> not as long as it actually works with streams
00:11:49 <turiya> Typing problems :P
00:12:28 <adnap> bsmntbombdood: i'm not really familiar with them
00:13:12 <edwardk> i need a class that i can move all the methods for Observable into, but Observable is taken by the type i'm making into a monad. bikeshedding ideas?
00:13:26 <edwardk> Observe is kinda off for a class
00:13:34 <bsmntbombdood> adnap, then just say combineStreams :: [[a]] -> [a] = foldr interleave []
00:13:42 <edwardk> and they aren't the Observation itself
00:14:08 <adnap> bsmntbombdood: anyhow, this is just from toying with it: expand r@(Plus a) = foldr interleave [] $ expand a >>= (\m -> [m : map (m++) (expand r)])
00:14:50 <bsmntbombdood> adnap, ... you just got rid of the do notation
00:15:36 <adnap> bsmntbombdood: pretty much XD
00:16:24 <adnap> i was thinking you could utilize iterate, but i'm a little confused by the ordering
00:16:47 <adnap> iterate (match++) ""
00:17:07 <bsmntbombdood> won't work
00:17:30 <bsmntbombdood> hrm
00:17:47 <turiya> I am having trouble writing a function which does the following: 
00:17:48 <turiya> f :: [Int] -> [[Int]]
00:17:48 <turiya> e.g.
00:17:48 <turiya> f [10,10] = [[1,1],[1,2],[1,3]...[2,1],[2,2],[2,3]...[10,1],[10,2],[10,3]...]
00:18:21 <turiya> Is there an easy way?
00:19:21 <Jafet> turiya: sequence
00:19:50 <turiya> @type sequence
00:20:08 <bsmntbombdood> adnap, with that, expand (Plus (Alteration (Literal "a") (Literal "b") = ["a", "b", "aa", "bb", "aaa", "bbb",...]
00:20:25 <turiya> Oh.. Hmm.. An example?
00:20:37 <bsmntbombdood> when it should be ["a", "b", "aa", "ab", "ba","aaa", "aab",...]
00:21:08 <azaq23> turiya: Monad m => [m t] -> m [t]
00:21:14 <myonov> turiya: f [x1, x2] = [[y1, y2] | y1 <- [1..x1], y2 <- [1..x2]]
00:22:02 <timbau> > sum [1/product[1..n]|n<-[0..25]]
00:22:19 <adnap> bsmntbombdood: check your original code.  it doesn't give that result.
00:23:04 <bsmntbombdood> adnap, yes it does
00:23:14 <azaq23> turiya: your function f [x, y] = sequence [[1 .. x], [1 .. y]]
00:24:05 <turiya> myonov: the input need not be a list of two
00:24:07 <adnap> bsmntbombdood: it does not give ["a", "b", "aa", "ab", "ba","aaa", "aab",...]
00:24:32 <adnap> bsmntbombdood: it gives ["a","b","aa","ba","ab","bb","aaa","baa","aba","bba"]
00:24:33 <bsmntbombdood> > take 10 $ expand (Plus (Alteration (Literal "a") (Literal "b")))
00:24:33 <bsmntbombdood> ["a","b","aa","ba","ab","bb","aaa","baa","aba","bba"]
00:24:45 <adnap> right
00:25:06 <bsmntbombdood> equivalent for this problem
00:25:15 <adnap> ba and ab are reversed from what you said they ought to be.  does that matter?
00:25:21 <bsmntbombdood> no
00:25:30 <turiya> azaq23: i see.. Can that be extended to input lists of more than two elements
00:26:53 <azaq23> turiya: Of course, f xs = sequence [[1 .. x] | x <- xs] - or if you like, f = sequence . map (enumFromTo 1)
00:28:22 <azaq23> turiya: FYI, sequence is used in a group of important and pretty intuitive monadic functions, for example mapM.
00:29:25 <Twey> Yeah, f = mapM $ enumFromTo 1
00:30:34 <myonov> turiya: f [] = [[]]; f (x:xs) = [ (y1 : y2) | y1 <- [1 .. x], y2 <- (f xs)]
00:30:47 * azaq23 <- derp
00:39:55 <turiya> Hmm, what is the <- symbol? Shouldnt that be used in the do notation?
00:40:29 <Rotaerk> turiya, that's part of the comprehension syntax
00:40:43 <turiya> I am a little slow in typing as i am doing it in a phone..
00:40:52 <Jafet> turiya: http://blog.codeslower.com/static/CheatSheet.pdf
00:41:30 <Rotaerk> heh, at 13 pages it ceases to be a cheat sheet
00:42:03 <Jafet> Some languages don't even have one
00:43:21 <turiya> I should probably take a look at the cheat sheet but what is the <- doing outside of the do notation?
00:43:56 <bsmntbombdood> list comprehensions
00:44:04 <bsmntbombdood> although that's really the same thing
00:45:55 <turiya> Can i interpret <- as 'belongs to'
00:46:01 <myonov> yes
00:46:07 <shachaf> Not really?
00:46:17 <shachaf> Maybe kind of in list comprehensions.
00:47:31 <turiya> I understand the previous code better now..
00:47:59 <teki> it's almost exactly analogous to pythonic "for _ in ..."
00:48:01 <shachaf> Oh, there was context.
00:49:33 <timbau> are there some general hints when it's better to use binary vs arbitrary-ary trees?
00:50:18 <turiya> I was looking for a '\forall' quantfier a sometime back, looks like <- comes close
00:51:01 <teki> hehe, forall is used elsewhere in haskell
00:51:18 <teki> not at all like this syntax though
00:52:10 <turiya> Yes, i am not familiar with that usage though
00:52:30 <jeffwheeler> @pl h (n:xs) = take (read n) xs
01:03:32 <turiya> Wow.. One line of code was enough to generate a non-trivial list :)
01:04:15 <a_jazz> hello, folks -- I'm trying to solve this codechef problem using haskell: http://www.codechef.com/problems/INTEST/
01:05:37 <a_jazz> but the code, when executed, exceeds the time limit given by the online judge: http://hpaste.org/42881/codechefintest
01:06:53 <a_jazz> any pointers?
01:08:02 <robinhoode> You're just using straight `mod`? I would expect to be using some fancy number theory for a task like that
01:08:39 <teki> given that n < 10^7 you won't see much improvement from implementing the euclidean algorithm yourself
01:08:47 <teki> and euclid is the fastest way to get divisibility
01:09:02 <teki> i don't know how mod is implemented, but it's almost certainly fast euclid
01:09:30 <robinhoode> teki, Is there a proof that euclid is the fastest algorithm?
01:09:41 <a_jazz> the point of the problem is to be able to process huge amounts of input
01:09:45 <robinhoode> teki, Not saying I don't believe you.. Just wondering if one exists
01:09:45 <teki> i don't know, and i wouldn't bet either way
01:10:01 <a_jazz> for some reason, the way I've done it is  simply not quick enough
01:10:06 <timbau> isn't mod implemented by hardware for 32 bit numbers???
01:10:17 <teki> but my point was that any algorithm that's faster probably has enough sub-dominant terms that you won't se speedups under n = 10^7
01:10:39 <teki> a_jazz: try using the seq command to force evaluation before you do the recursive call
01:10:59 <edwardk> yes, the div instruction places the remainder in edx as i recall ;)
01:11:07 <edwardk> timbau: why
01:11:37 <a_jazz> (the Euclidean algorithm is for determining gcd of two numbers)
01:11:37 <timbau> somebody asked how `mod` is implemented
01:12:08 <edwardk> ah, well, its implemented however your particular Integral instance says its implemented ;)
01:12:38 <ian_mi> doesn't the Euclidean algorithm use mod?
01:13:04 <teki> okay, i just looked
01:13:05 <timbau> in this case, we should use Int, not Integer
01:13:17 <teki> euclid(x,y) is O(log x)
01:13:22 <teki> (assuming x > y)
01:14:01 <teki> so the real problem here is the thunks not the mod
01:14:24 <timbau> why Euclid? you only need to know whether a number is divisable by k
01:15:11 <teki> because euclid is how you check
01:15:24 <teki> how would you check that 314154 is divisible by 3?
01:15:42 <timbau> 314154 `mod` 3 == 0
01:15:45 <teki> yes
01:15:57 <teki> we were discussing the internal implementation of mod
01:16:24 <teki> and i made the point that it almost certainly uses the euclidean algorithm, which is O(log n) in its largest argument
01:16:37 <teki> so your problem isn't the modulus calculations
01:16:44 <teki> it's the evaluation
01:17:21 <ian_mi> I still contest that the euclidean algorithm uses mod
01:17:22 <timbau> yes I guess so, too
01:17:41 <timbau> euclid is for computing gcd what is not required here
01:18:50 <ian_mi> mod is just division
01:19:06 <teki> timbau: johan tibell has some good slides on high performance haskell for beginners, which might help: http://johantibell.com/files/slides.pdf
01:21:11 <a_jazz> so might I save a lot of time if I use getContents rather than getLine n times?
01:21:44 <timbau> I implemented a shorter solution on http://codepad.org/eh5XoU4I
01:22:00 <timbau> it's without the I/O part but you can take your original one
01:22:19 <a_jazz> if I do allInput <- getContents; let allLines = lines allInput; .... etc
01:23:09 <timbau> damn ... it's not fast
01:23:58 <rumbold> when should i use where and when let?
01:27:27 <adnap>         where   matches = expand a
01:27:30 <adnap>                 update (xs, ys) = (xs, xs >>= \x -> map (x++) ys)
01:30:50 <a_jazz> if I wanted to map read over a list of Strings, how/where would I provide the type annotation?
01:31:17 <a_jazz> as in: map read ["42", "4", "5"]
01:31:39 <arcatan> > map read ["42", "4", "5"] :: [Int]
01:32:02 <a_jazz> oh crap, yes
01:32:07 <a_jazz> I just realized
01:32:11 <arcatan> oh lambdabot, where have you gone?
01:32:22 <a_jazz> I was writing ::Int instead of ::[Int]
01:32:39 <a_jazz> thank you
01:39:37 <robinhoode> tryhaskell.org is totally broken..  Unless preventing usage of putStrLn and friends is intended..
01:58:19 <Veinor> snap looks pretty cool
01:58:34 <Veinor> robinhoode: i think that's intended
03:02:27 * hackagebot haskell-src-exts 1.10.0 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer  http://hackage.haskell.org/package/haskell-src-exts-1.10.0 (NiklasBroberg)
03:02:29 * hackagebot citeproc-hs 0.3.0 - A Citation Style Language implementation in Haskell  http://hackage.haskell.org/package/citeproc-hs-0.3.0 (AndreaRossato)
03:05:27 * hackagebot hogre 0.1.1 - Haskell binding to a subset of OGRE  http://hackage.haskell.org/package/hogre-0.1.1 (AnttiSalonen)
03:30:40 <edwardk1> large chunks of reactor now compile =)
03:31:45 <edwardk> code on github: https://github.com/ekmett/reactor/tree/master/Reactor
03:32:09 <edwardk> when i actually have an idea of how it'll work in practice, i'll move it into hackage
03:37:24 <Saizan> :O
03:37:26 <edwardk> heya saizan
03:38:33 <Saizan> hey, building a FRP implementation?
03:38:52 <edwardk> 'kinda', its more of a task parallel programming library
03:39:02 <edwardk> intel tbb with a .net reactive style veneer
03:39:30 <edwardk> you can use the observable monad to program with events and promises though
03:40:00 <edwardk> and if i build some less throughput centric schedulers it'd probably do pretty well at more traditional frp things
03:40:13 <edwardk> though, conal will hate it, lots of IO () going on, atomic variables, etc.
03:40:38 <edwardk> but programming _with_ observables doesn't need to know about all of that
03:40:42 <Saizan> i have a feeling that any working FRP implementation has to be quite dirty inside
03:41:44 <edwardk> the main focus is on spawning tasks. each worker runs a workstealing deque and creates work on his own
03:42:39 <edwardk> when things are stolen off the deque they'll be splittable by the scheduler, so you can do something like enqueue a bit array to be worked on, and have it stolen from you, and carved up into smaller pieces
03:43:39 <edwardk> to that effect, 'pushing' notifications is all about enqueuing work items for yourself to do
03:43:52 <edwardk> and having them stolen when other cores get hungry
03:44:08 <krainboltgreene> You know what'd be neat? Special comments.
03:44:18 <edwardk> ?
03:44:39 <edwardk> Saizan: you take a peek at the code?
03:44:43 <j-invariant> it's really hard to write beta substitution
03:45:06 <krainboltgreene> Well, for example in Ruby the comment character is # and it's the whole line. Special comment characters would be like: #" This is a string that is outputted to the terminal.
03:45:08 <Saizan> edwardk: yep, i'm reading Observable now
03:45:34 <edwardk> yeah everything else is kinda neat and organized, observable is a jumbled mess ;)
03:47:34 <monadic_kid> edwardk: aren't you duplicating some efforts done by ghc mt-runtime? except that you might be able to use it with other haskell compilers. I vague recall ghc mt-runtime uses a work-stealing scheduler
03:48:08 <edwardk> the workstealing is done from a queue not a deque, and i can't tell if a workitem i receive is stolen or not
03:48:11 <edwardk> but yes
03:48:44 <edwardk> breaking those two limitations are what i'm exploring here â€” i've done a lot of workstealing stuff in other environments, i just never ported it all to haskell
03:49:06 <edwardk> i'm not targeting other compilers than ghc at this point
03:49:41 <Saizan> edwardk: so when i do "take n o" i'm subscribing an observer to o that's going to be called for all events(?) of o, even after the first n? (just to know if i'm reading this right :)
03:50:21 <edwardk> Saizan: right now. a soon as i get autodetaching working, then upon completion or handling all observers will detach themselves
03:50:43 <edwardk> that'll be another combinator like 'safe'
03:51:32 <edwardk> my main focus for right now was getting it to work =)
03:53:23 <edwardk> the hope is that with sufficient polish, the end user never sees a naked 'Task' unless writing their own observables or observers
03:54:44 * hackagebot cryptocipher 0.2.2 - Symmetrical Block, Stream and PubKey Ciphers  http://hackage.haskell.org/package/cryptocipher-0.2.2 (VincentHanquez)
03:58:26 <edwardk> if you spot bugs as you go, lemme, know, i haven't checked all the atomic logic yet
03:58:27 <edwardk> ;)
03:58:41 <Saizan> heh, i'm not that awake yet :)
03:59:06 <edwardk> the code has turned out way cleaner than my scala version though
03:59:15 <edwardk> though i miss subtyping in some places
03:59:36 <Saizan> btw, what type corresponds to a worker? Task? or there isn't one?
03:59:51 <edwardk> right now there isn't one
04:00:02 <edwardk> the closest you get is a deque, where you can steal from other workers
04:00:10 <edwardk> if you have a reference to their deque
04:01:15 <edwardk> the way its going to work is there'll be a number of Scheduler objects that know how to let you queue up work items for someone else
04:02:24 <edwardk> so workers would sit idle, when you go to run a Task you register your new deque with the workers so they know to steal from you. then other special threads would be able to listen for queued work items, e.g. whatever forkOS created the opengl context, etc.
04:02:33 <edwardk> that way you can run tasks in particular contexts if needed
04:02:45 <edwardk> but otherwise they enqueue in your deque
04:03:10 <edwardk> i'll probably add per worker queues as well, so you can push work out rather than have it pulled
04:03:39 <edwardk> but the thread that calls 'run' won't count as a worker in that sense, its just a coordinator that happens to be able to run the workitems it deques up for itself
04:04:08 <edwardk> that way you can just invoke parallel maps, etc. in otherwise straight-forward IO or ST code
04:04:28 <edwardk> more imperative than i usually like my haskell
04:11:21 <rumbold> i'm not allowed to divide a word8 by 2? wtf
04:11:28 <Saizan> div
04:11:39 <edwardk> > (12 :: Word8) `div` 2
04:11:48 <edwardk> gah lambdabot is dead again
04:12:03 <rumbold> thanks
04:22:51 * hackagebot hoogle 4.1.3 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.1.3 (NeilMitchell)
04:36:08 <poucet> Hi
04:40:35 <kolmodin> poucet: hi
04:48:38 <poucet> kolmodin: how goes?
04:49:01 <Bynbo7> kolmodin: it was you that wrote that binary post wasn't it?
04:49:10 <kolmodin> poucet: I'm doing good. just about to grab another cup of coffee and to hack a bit :)
04:49:21 <kolmodin> Bynbo7: yes
04:49:35 <kolmodin> I got a few good comments, I'll reply to those
04:49:38 <poucet> kolmodin: What are you hacking on?
04:49:43 <kolmodin> the binary package
04:49:45 <Bynbo7> looking forward to seeing those changes. 
04:49:57 <kolmodin> Bynbo7: yeah, me too :) sorry for the delay
04:50:06 <kolmodin> it's not that much work, I've just had really big trouble to make it fast
04:50:16 <kolmodin> while still having all features
04:50:27 <Bynbo7> i agree with Johan about dropping error reporting and backtracking, things like those should be left to more adcanced packages
04:51:03 <kolmodin> ok
04:51:06 <kolmodin> yeah, it's very reasonable
04:51:19 <kolmodin> I've parsed formats that were simpler with backtracking, but absolutely not impossible to do without
04:51:42 <Bynbo7> binary doesn't currently have a try function does it
04:51:48 <kolmodin> Bynbo7: that is correct
04:52:10 <kolmodin> and nobody has asked for it, so maybe there really is no need :)
04:52:15 <Bynbo7> yeah
04:52:50 <kolmodin> last night I noticed that I handle the input in a clumsy way
04:52:55 <Bynbo7> i think if you need back tracking, you're working on something more complex than binary is designed for. it's basically supposed to be there for (de)serialisation of data, and that's it
04:53:00 <kolmodin> which results in bad performance and lots of allocations
04:53:11 <Bynbo7> oh no :(
04:53:21 <ivanm> Bynbo7: and then use a parsing library for the backtracking, etc.?
04:53:32 <Bynbo7> yeah
04:53:35 <Bynbo7> like cereal
04:53:40 <ksf> someone should go ahead and do the shootout programs in nasm
04:54:03 <kolmodin> binary is designed for what we want it to be designed for. if we could easily get backtracking, then why not?
04:54:04 <ivanm> ksf: you volunteering? :p
04:54:08 <Bynbo7> how easy is threading in nasm?
04:54:33 <ksf> depends.
04:54:48 <ksf> ...on whether you're willing to use C libraries.
04:55:01 <ksf> implementing coroutines, otoh, shouldn't be hard.
04:55:15 <ksf> even managed ones.
04:56:12 <ksf> the reason I'm mentioning nasm, as opposed to gas or anything is that it's got a decent, properly turing-complete (only slightly tarry) preprocessor.
04:56:37 <ksf> if you can deal with tex, you can definitely deal with the nasm pp.
04:56:55 <ksf> http://www.tortall.net/projects/yasm/manual/html/nasm-preprocessor.html
04:58:43 <kolmodin> a problem with backtracking is that even if you get nice performance, you still need to save all the input in case you backtrack
04:59:09 <ksf> dynamic programming.
04:59:29 <ksf> don't question, just do it.
04:59:44 <kolmodin> :D
05:00:05 <ksf> knuth's line-breaking is one of the best examples of it.
05:00:47 <ksf> sadly it's only widely lauded, not widely known or taught.
05:01:17 <kolmodin> I see, I didn't know about it
05:01:51 <qfr> Do any of you have any strong feelings about Learn You A Haskell vs. Real World Haskell or Haskell School of Expression for people who are new to pure FP?
05:02:40 <qfr> Although ultimately it's probably irrelevant how much time I spend on reading any of those.... just got to dive in and start writing a lot of Haskell and have the code reviewed by Haskell hackers to point me into the right direction when I'm doing something clumsy/dumb
05:02:41 <Bynbo7> qfr: there's no vs. between LYAH and RWH, read LYAH then RWH
05:02:48 <ksf> qfr, what kind of strong feelings do you have about academics, enterprise programmers and fuzzy hackers?
05:03:05 <qfr> ksf: What's a fuzzy hacker?
05:03:51 <ksf> hmmm. good question.
05:04:27 <ksf> bluntly put, in comparison to lyah, rwh readers laugh in the basement.
05:04:53 <ksf> wait I don't think that metaphor exists in english.
05:06:15 <qfr> I think CS is as an academic field is widely ridiculed and rightly so because I feel that it is so distant from actual problems in the IT industry, software development etc. I frequently hear complaints about people in the industry who have to deal with graduates who think they are on top of things whereas many of them have had no significant private ambitions to develop software and have no experience with it outside of academia. The regulars often feel the n
05:06:16 <qfr> eed to "deprogram" them (yes, two of them actually used that word).
05:08:10 <qfr> As for "enterprise programmers", uh, I suppose you just mean "professional software developers". Well, I am sometimes saddened by how people who do it for a living lose interest in programming privately because their work ruined it for them as a hobby. they also frequently develop an industrial conformist bias towards programming languages simply because of their prevalence in the industry instead of focusing on what the language actually has to offer.
05:08:20 <hvr> funny, I often have the urge to 'deprogram' java-developers who think that OOP is the only true way to do things
05:08:24 <Adamant> go watch Tony Hoare's video on nullable types, the billion dollar mistake, and get back to us.
05:09:01 <qfr> s/about people/from people/
05:09:36 <asflierl> this "distant from actual problems" talk comes up frequently
05:09:41 <ksf> qfr, lyah is for you.
05:09:57 <asflierl> they said that about so many things in the past that are now in "actual" use
05:10:15 <Adamant> industry doesn't even know what the fuck it's actual problems are half the time.
05:10:38 <Adamant> so I don't bu this
05:10:41 <Adamant> *buy
05:10:48 <qfr> Also, I am expecting a lot of hatred towards me for my remarks about academia now, especially since Haskell is more widely used by people with an academic background. Just to clear up some things, I have a BSc in CS and I am currently finishing my MSc.
05:11:01 <Adamant> not toward you
05:11:14 <asflierl> hatred sucks :)
05:11:22 <Adamant> the idea is in general not true
05:12:33 <Adamant> go read JWZ's screed on garbage collection and how it was resisted tooth and nail by developers of the era when they were doing application programming, where it fits just fine
05:14:19 <Adamant> yes, there are some very, very smart and knowledgeable people in industry who can get away with the "academia sucks" argument, and for some subfields, it really has.
05:14:37 <qfr> I was shocked to find out that most of the people in my early CS lectures had little to no experience nor ambition to develop software privately, most of them seemed semi computer illiterate to me. I talked to some of them about it and it sounded like they just decided to study CS because they thought it would secure them a good job in future.
05:14:49 <asflierl> there was this article about rejected papers not too long ago... let me see if i can dig that up
05:15:01 <Adamant> those people are now in industry too
05:15:03 <ksf> qfr, nah, we give academics proper flak all the time here.
05:15:16 <qfr> Of course many of them dropped out
05:15:34 <qfr> They dropped like flies during the first 2-3 years, over math etc
05:15:45 <Adamant> qfr: quite a few of those folks end up doing popular languages du jour.
05:16:00 <Ke> python, ruby
05:16:06 <Ke> all that dynamic typing
05:16:11 <qfr> Om nom nom
05:16:14 <qfr> And Common Lisp!
05:16:20 <Ke> =o(
05:16:23 <qfr> What?
05:16:37 <qfr> But yeah I've been developing a grudge against dynamic typing lately
05:16:47 <Adamant> why?
05:16:51 <Adamant> it's a tool
05:17:54 <qfr> Because I have a lot of problems with dumb mistakes in dynamically typed languages as soon as the code grows beyond like 150 KiB, and most of those simply wouldn't even pass the compilation
05:18:08 <Adamant> it's like arguing the merits of inline vs. v-configuration for internal combustion engines
05:18:10 <qfr> It caused a lot of frustration when I developed several networked services in Ruby
05:18:20 <qfr> And they kept on dying due to dumb mistakes, at unforeseen moments
05:18:39 <qfr> But I still love Ruby for small random jobs
05:18:53 <hvr> qfr: well, so it might be that dynamic typing doesn't fit your problem-domain 
05:19:01 <ksf> haskell's like the vi of languages.
05:19:13 <qfr> hvr yeah that's one of the reasons I want to dive into Haskell now
05:19:14 <ksf> you need some time to get all the speed benefits.
05:19:31 <qfr> I think static typing pays off on bigger projects
05:19:47 <ksf> definitely.
05:19:59 <hvr> qfr: yeah, it's good for handling complexity
05:20:07 <Jafet> Like in Ada?
05:20:14 <asflierl> ah there it is: http://tinyurl.com/366cu9t
05:20:17 <ksf> and haskell is very, very flexible... iff you know it well enough.
05:20:19 <asflierl> enjoy :)
05:20:43 <qfr> I'll try to do webdev in Haskell :D I want to write a framework on top of that popular FastCGI library for Haskell, and I need some Postgres bindings, not sure which lib to use there yet
05:20:46 <Adamant> Jafet: I'd rather fly in a plane with systems written in Ada than C
05:20:56 <qfr> And some YAML parser
05:21:02 <qfr> There's a reference implementation for Haskell though
05:21:32 <hvr> qfr: just take your time and have patience
05:21:38 <ksf> "Structured
05:21:38 <ksf> programming is a nice academic exercise,
05:21:38 <ksf> which works well for small examples,
05:21:38 <ksf> but I doubt that any real-world
05:21:38 <ksf> program will ever be written in such a
05:21:39 <ksf> style."
05:21:42 <ksf> oh, sorry.
05:21:47 <asflierl> :))
05:22:06 <Jafet> (What about a plane with inline vs. v cycle engines?)
05:22:12 <hvr> ksf: ...and 640kb shall be enough for everybody? :)
05:22:27 <ksf> qfr, there's already web frameworks
05:22:29 <asflierl> that's from the article I linked above :)
05:23:06 <ksf> I strongly recommend using one of happstack or snap, and then just have a look at what to use with them.
05:23:40 <arcatan> hey, does happstack support file uploads?
05:25:05 <qfr> ksf: Haha nice quote
05:25:31 <hvr> hrm... do I really need to list all *.hs files I want included via 'cabal sdist' in the .cabal file? (although 'cabal build' works fine without?)
05:25:42 <qfr> ksf: Yeah, I know, Snap and such, right? But I'll learn less if I use other people's code too much, I want to write more of my own modules, too
05:26:13 <qfr> And when I did webdev in Ruby I also wrote my own framework because I didn't really get Rails and didn't agree with the way it did things
05:26:18 <ksf> "I don’t understand the relevance of discrete sources: No matter what one does, in the end, the signal will have to be modulated using good old-fashioned vacuum tubes, so the signal on the “channel” will always be analogical."
05:26:21 <qfr> (not mentioning the performance prbolems)
05:26:22 <ksf> that pdf is a gem.
05:26:33 * asflierl nods.
05:26:35 <asflierl> absolutely
05:27:33 <ksf> qfr, you'll find opportunities for hacking in both projects.
05:27:57 <ksf> though especially happstack might be a bit harsh on beginning programmers
05:50:58 <qfr> Is it a common convention that the module A.B.C translates to A/B/C.hs in the filesystem in Haskell?
05:52:38 <dolio> Not just a convention.
05:52:50 <qfr> Ah, the compiler will complain about it otherwise?
05:53:03 <dolio> It won't be able to find it, I think.
05:53:37 <qfr> Oh, I expected that you still had to explicitly mention hs files when you compile larger projects, like you would have to in C++
05:56:18 <co_dh> greeting, where can I find the defintion of Equational Theory ? 
06:00:27 <co_dh> anybody here?
06:03:15 <Saizan> informally, afaiu, it's a syntax for expressions together with a bunch of equations that are supposed to hold
06:04:33 * ksf thinks the proper way to do it would be to support java-style A.B.C.hs and A.B/C.hs
06:05:50 <ksf> co_dh, try http://en.wikipedia.org/wiki/Equational_theory
06:06:23 <Twey> ksf: What do you do when you have both
06:06:24 <Twey> ?
06:06:44 <qfr> Prelude> data A = B <interactive>:1:0: parse error on input `data' - what am I doing wrong? Is my statement broken or does data not work in ghci as I would expect it to?
06:06:49 <co_dh> ksf: thanks. 
06:08:24 <Saizan> qfr: ghci doesn't accept declarations at the prompt
06:08:30 * qfr cries
06:08:41 <ksf> Twey, error out.
06:08:54 <Saizan> at best you can use let like in do-notation
06:09:01 <qfr> Are there any Haskell REPLs which are better suited for this?
06:09:13 <qfr> Or maybe REPL is the wrong concept... I don't know
06:09:18 <ksf> or warn and prefer . over / or something.
06:09:35 <qfr> ghc is generally the most advanced Haskell compiler though, right?
06:09:42 <Saizan> yep
06:09:53 <ksf> ghci is basically a huge do-block.
06:09:56 <Saizan> hbc has/had a better REPL i'm told
06:11:38 <Saizan> anyhow, you can put definitions in a .hs file and reload it when you change them
06:11:43 <Saizan> with :r
06:11:51 <qfr> Right
06:12:03 * ksf uses xmonad and two shells for that.
06:12:11 <ksf> one big with vi, one small wiht ghci
06:12:16 * Saizan uses emacs' haskell-mode
06:13:00 <ksf> yeah but while emacs has quite a lot of programs, sometimes one wants an OS that can run arbitrary programs like e.g. firefox.
06:13:33 <ksf> emacs, all in all, seems like an interesting academic exercise, but I can't see anybody will ever be masochistic enough to use it for anything important, like basic text editing.
06:13:36 <hpc> alternatively, one wants not to have to run two OSs
06:13:50 <hpc> or boot into some sort of lisp kernel
06:14:42 <Saizan> you're a bit exaggerating, you know?:)
06:14:49 * qfr uses haskell-mode, too
06:15:26 <Saizan> i've emacs inside screen inside xmonad, and it feels quite natural
06:15:46 <Saizan> oh, i forgot the terminal emulator, but that's so thin
06:28:55 <Adamant> ksf: I don't think people using vi in 2010 have room from which to speak about masochism 
06:29:14 <Adamant> :P
06:29:57 <j-invariant> Arther any Haskell AUDIOS?
06:30:07 <j-invariant> or Lambda.. Types whatever
06:30:14 <j-invariant> mp3s?
06:30:17 <dolio> Using vi helps keep your muscle memory up to date for nethack.
06:30:24 <ksf> vim == vi.
06:32:50 <j-invariant> Where can I downloadthe audio?
06:33:18 <Zao> j-invariant: Are you talking about audio books, audio tutorials or podcasts?
06:33:25 <ksf> there's a decent amount of video lectures
06:33:45 <j-invariant> not books but something like apodcasts I guess
06:33:52 <ksf> mostly only the audio and slides are interesting.
06:33:56 <j-invariant> ksf no video rbility though
06:34:21 <ksf> well as I said, the video part is usually not interesting, anyway.
06:35:26 <ksf> e.g. this one here: http://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-tutorial/index.htm
06:35:49 <ksf> just rip out the audio and hear it, possibly having a look at the slides from time to time and you're fine.
06:36:06 <ksf> all you're missing is spj walking from side to side and moving his mouth.
06:36:12 <j-invariant> :D
06:38:38 <Saizan> but that's half the fun.
06:39:45 <qfr> Hah, does Simon work for M$crosoft?
06:40:25 <ksf> yep.
06:40:31 <ksf> they keep him as a mascot.
06:40:44 <j-invariant> Microsaft <-- a small juice company
06:40:47 <hpc> he is their token smart guy
06:40:56 <ksf> ...a magnet to attract capable people, who they then force to work on .NET
06:41:26 <ksf> he doesn't seem to mind, it's a tuition without the need to give lectures.
06:41:39 <ksf> er wait.
06:41:42 <ksf> vocabulary fail.
06:42:09 <ksf> tenure.
06:42:26 <ksf> ...in the academic sense.
06:55:30 <qfr> http://jekor.com/article/is-haskell-a-good-choice-for-web-applications <- I was just reading this, I am surprised by the FastCGI to SCGI switch since mod_scgi for nginx is no longer being maintained, right? I'd be better off using FastCGI, I think, since it's supported natively
06:55:51 <qfr> It's funny how the FastCGI C code is from 2003 and hasn't been updated since?
06:55:58 <qfr> "Unfortunately, Haskell does not yet have a mature way of interfacing with a relational database in a type-safe way7. You have to build your SQL commands as strings in much the same way as with most other languages. HDBC does take care of preventing SQL injection attacks, but that's about it."
06:56:02 <qfr> Is that true? :[
06:56:23 <ksf> takusen?
06:56:26 <qfr> I am used to work with sequel in Ruby where you write little to no SQL yourself, it's all generated from Ruby syntax
06:56:38 <qfr> So it's difficult to generate invalid queries
06:56:58 <hpc> takusen is indeed the way you are looking for
06:57:00 <ksf> I vaguely remember hearing something about an interface that knows what tables there are (and is thus type safe), but I'm no db guy.
06:57:03 <hpc> i couldn't get it set up though
06:57:13 <hpc> though that's probably just because i suck at that sort of thing
06:57:18 <ksf> you might also want to have a look at happstack-data.
06:57:30 <ksf> it's got its own ACID store.
06:57:45 <qfr> Also, how does cabal deal with C FFI stuff on Windows? I am trying to cabal install fastcgi - does it depend on MinGW?
06:57:51 <hpc> i know there's one db library that gets a description of every table at compilation time
06:58:03 <hpc> or something like that
06:58:06 <qfr> Or does it support the MSVC building environnment, too?
06:58:21 <dcoutts> qfr: it uses the gcc that is bundled with ghc
06:58:25 <qfr> Ah, ok
06:58:41 <qfr> So I will need .a files then
06:58:50 <qfr> Compiling the stuff manually on Windows...
06:58:52 <dcoutts> qfr: or .lib or .dll I think will work too
06:58:59 <qfr> Why would lib work?
06:59:06 <qfr> It's only supported by cl, no?
06:59:07 <dcoutts> because gcc supports that
06:59:11 <qfr> Oh, I had no idea
06:59:33 <dcoutts> qfr: on windows you often have to specify the path, cabal blah blah --extra-lib-dir=... --extra-include-dir=...
06:59:43 <qfr> Right
07:00:25 <qfr> Does ghc use a recent gcc?
07:00:30 <qfr> Or is it a super old one?
07:00:46 <dcoutts> qfr: it's a 3.x one I think, you can check
07:00:48 <qfr> I'm not sure if I should try to build a static library with the same compiler
07:00:51 <qfr> Ouch
07:00:57 <qfr> Why doesn't it use a newer one? :|
07:01:06 <dcoutts> qfr: mingw is slow :-)
07:01:14 <dcoutts> qfr: I think perhaps ghc 7 has a newer one finally
07:01:41 <qfr> Would I break anything by making it use a more recent gcc?
07:03:33 <dcoutts> qfr: you can try it, specify cabal whatever --ghc-options="-pgmc your/newer/gcc.exe"
07:03:47 <qfr> I could just symlink a newer gcc :p
07:04:11 * dcoutts forgets if cabal's --with-gcc= will tell ghc to use that gcc too
07:05:35 <qfr> I'm a sucker for having up to date binaries
07:05:53 <qfr> It's a Gentoo/Arch thing
07:06:03 <qfr> Although I am running Windows on my desktop.
07:06:13 <qfr> Maybe I should ditch Haskell Platform and start using Haskell 7
07:06:30 <qfr> Is there any significant amount of work I'd have to perform manually in that case?
07:07:20 <dcoutts> qfr: if you're doing it just for kicks, go for it. If you're trying to get some work done, stick with the HP releases.
07:07:40 <qfr> dcoutts: Why? Will anything break/not work?
07:07:53 <qfr> It looks like the packages I was interested in all said they supported ghc7,  too
07:08:02 <qfr> "start using Haskell 7" <- wtf
07:08:04 <qfr> I meant ghc 7
07:08:09 <qfr> There's no Haskell 7
07:08:51 <dcoutts> qfr: you'll undoubtedly run into some issues with packages not having been updated/tested. That and you'll have to put more bits together yourself.
07:09:37 <qfr> Is a HP release with ghc7 planned yet?
07:09:45 <dcoutts> yes, there's a schedule
07:10:10 <lelf> ?hackage haskelldb
07:10:27 <dcoutts> qfr: if you enjoy the bleeding edge, reporting issues, helping the process along etc then that's obviously helpful to everyone
07:10:39 <qfr> Yeah I already do that with Linux anyways
07:10:57 <qfr> And knowing how to fix stuff manually is good anyways
07:11:15 <qfr> (watch me go back to ghc 6.12 within 2-3 days)
07:12:08 <lelf> well. there â€” http://trac.haskell.org/haskelldb/
07:12:20 <qfr> http://hackage.haskell.org/package/Takusen looks good
07:13:06 <qfr> I love how a lot of those packages are already available in the AUR for Arch :P
07:13:13 <qfr> (all my servers run Arch)
07:14:08 <qfr> fastcgi says ghc 7 building works, too
07:14:41 <qfr> Same with yaml, I think I'm good to go
07:15:20 <qfr> http://hackage.haskell.org/package/enumerator-0.4.4 wow, the latest enumerator wasn't even checked in ghc6?
07:15:43 <qfr> Same with base, bytestring... does this have any significance?
07:15:48 <qfr> I was just going through the dependencies
07:16:36 <qfr> What's up with the upper version boundaries in the dependencies on hackage?
07:16:52 <qfr> Those hypothetical versions don't even exist yet
07:17:01 <qfr> 	base (4.*), bytestring (â‰¥0.9.1.4 & <0.10), enumerator (0.4.*), transformers (â‰¥0.1 & <0.3)
07:17:18 <qfr> http://hackage.haskell.org/package/transformers-0.2.2.0 is the latest one?
07:17:23 <qfr> No 0.3 in sight
07:24:42 <faust45> hi guy's
07:24:57 <j-invariant> hi 
07:25:10 <qfr> Hi's
07:25:11 <faust45> i try use Haskell OpenGL bindings in Mac OS but catch http://friendpaste.com/6tarlofHSrLSfOdj4kNsON
07:25:46 <faust45> can any one help me?
07:26:15 <j-invariant> faust45: you must use  -framework OpenGL
07:27:08 <faust45> j-invariant: like this  ghc -framework OpenGL  test.hs -o test ?
07:27:18 <braddunbar> ok, i'm a haskell newb - but not a newb in general - and i am having quite a rough time parsing json in haskell
07:27:41 <braddunbar> there must be some secret easy way to do this right?
07:28:40 <faust45> i  use this tutorial http://www.haskell.org/haskellwiki/OpenGLTutorial1
07:29:20 <Twey> braddunbar: The book â€˜Real World Haskellâ€™ contains a worked example of a JSON parser
07:29:41 <Twey> @where rwh
07:29:51 <Renze> Good afternoon :)
07:29:53 <Twey> Oh, Î»b is dead again?  :-\
07:30:11 <burp> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:json
07:30:27 <kamaji> Would it be wrong to look at curried functions as successive bindings of parameters? 
07:30:31 <burp> I can recommend yajl-enumerator, though that might not be the right thing for a haskell beginner :>
07:30:37 <Twey> Yeah, that also works
07:30:46 <Twey> kamaji: Seems reasonable to me
07:31:01 <braddunbar> Twey: i've actually ready that - it does a lot of generating json - not so much parsing
07:31:04 <Renze> How can I send files with my local server (at localhost:...)? I assume my computer somewhere has a directory for it, but really don't have a clue about where. I'm using W7.
07:31:16 <_mpu> Is anyone familiar with colormap handling in the Xlib ?
07:31:16 <kamaji> Twey: coolbeans!
07:31:43 <burp> braddunbar: there are plenty of json parsing libraries
07:31:46 <Twey> braddunbar: Oh, yeah, you're right.  Sorry.  It's a printer, not a parser.
07:31:55 <Twey> braddunbar: Are you familiar with Parsec?
07:32:19 <braddunbar> Twey: heard of it, but haven't gotten that far in RWH yet =)
07:32:30 <burp> these two enumerator things, hjson, â€¦
07:32:35 <Twey> braddunbar: Alrightâ€¦ keep reading ;)
07:33:04 <braddunbar> Twey: will do, really loving that book
07:33:15 <faust45> Maybe i need some special OpenGL libs native to MacOS 
07:33:16 <faust45> ?
07:33:23 <braddunbar> burp: i will look for an hjson tutorial
07:33:32 <burp> braddunbar: http://hackage.haskell.org/packages/archive/hjson/1.2/doc/html/Text-HJson.html that seems quite simple
07:33:39 <burp> look at the source, it uses parsec
07:33:47 <burp> and it's short
07:33:48 <Twey> braddunbar: JSON is pretty trivial to parse once you understand parsing.
07:34:27 <Twey> But yeah, if you want to Get Stuff Done then just use a library.
07:34:42 <j-invariant> faust45: opengl is already on mac os
07:34:44 <braddunbar> Twey: burp: sweet, i will definitely look at the hjson source
07:35:04 <braddunbar> ...and keep reading RWH for some more parsec info  =)
07:35:35 <faust45> j-invariant: but why its not working?  i try ghc -framework OpenGL  test.hs -o test  but its fail too
07:36:11 <romanandreg> Guys, can someone tell me the "raison d'etre" of the monads-fd library, and the difference btw that and the mtl?
07:36:20 <romanandreg> or point me to an insightful link
07:36:22 <romanandreg> that explains that
07:36:25 <j-invariant> faust45: does it  give the same error mesage?
07:36:51 <aristid> romanandreg: monads-fd is legacy now. use mtl 2.0 instead.
07:37:05 <faust45> j-invariant: not same but this one http://friendpaste.com/7grS9ohZuFzrJuCyq6kedH
07:37:42 <j-invariant> faust45: add -framework GLUT as well
07:38:42 <faust45> j-invariant: http://friendpaste.com/6PIndWrKRzeX8qNzxcL109
07:38:57 <j-invariant> tnhats odd
07:39:15 <faust45> j-invariant: you mean ghc -framework OpenGL  -framework GLUT  test.hs -o test?
07:44:22 <jmcarthur> wait, monads-fd is legacy?!
07:44:45 <jmcarthur> i thought transformers was the preferred way to go over mtl, and now mtl just rexports stuff from transformers
07:44:52 <jmcarthur> so either would be okay
07:46:14 <jmcarthur> huh, it is indeed marked as obsolete
07:46:51 <jmcarthur> oh, so now it's simply a choice between mtl and monads-tf?
07:48:01 <aristid> mtl and mtl-tf, i think
07:48:27 <aristid> but i did not investigate the mtl-tf/monads-tf stuff deeply, because i like fundep syntax better
07:49:58 <aristid> jmcarthur: it is true that transformers is now the way to go. and mtl 2.0 depends on transformers, but also contains non-transformers stuff (mainly MPTC/fundep typeclasses like MonadReader)
07:51:15 <qfr> You're supposed to use wai for SCGI stuff right now, right?
07:53:01 <jmcarthur> aristid: well, right, for transformers the type classes are/were the domain of monads-{fd,tf}
07:53:19 <jmcarthur> aristid: i'm noticed that monads-fd is marked obsolete, but not monads-tf
07:53:25 <jmcarthur> *i've
07:53:59 <aristid> jmcarthur: who uses monads-tf anyways? :P
07:54:29 <faust45> j-invariant: ghc -package OpenGL -package GLUT test.hs -o test   Thats compile fine
07:54:38 <jmcarthur> aristid: point
07:54:42 <dolio> I would, if every other library didn't depend on incompatible libraries.
07:55:12 <aristid> jmcarthur: more than i expected: http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/revdeps/monads-tf-0.1.0.0#direct
07:55:30 <qfr> Curious, Cabal installed stuff to %USERPROFILE% but it even did that when I was using HP from the looks of it
07:55:35 <jmcarthur> that's actually less than i expected
07:55:46 <mm_freak_> i view 'transformers' as a common base, but would never use it directly
07:56:21 <aristid> jmcarthur: there we go, real data converging expectations from both sides
07:56:35 <dolio> Type families are simply, obviously the more appropriate construct for the classes in mtl.
07:57:12 <aristid> dolio: i think you can mix mtl and monads-tf, because it uses different classes
07:57:17 <Saizan> some say MonadState shouldn't even have a fundep
07:57:29 <aristid> Saizan: same for MonadError!
07:57:33 <dolio> aristid: Then I'd have to be qualifying all over the place.
07:57:34 <aristid> :D
07:58:21 <aristid> dolio: yeah, but it's at least possible. the mtl/monads-fd mess was much worse
07:59:29 <aristid> dolio: why are tfs more appropriate than fds, tho?
08:00:19 <dolio> If you look in the fd modules, you'll notice that the instances require UndecidableInstances to be enabled.
08:00:53 <aristid> and with tfs, the instances remain decidable?
08:00:59 <david`> j clojure
08:01:01 <dolio> And the fundeps are all expressing simple associated types.
08:01:02 <david`> fuck
08:02:01 <aristid> dolio: well, maybe if tfs had nicer syntax... the current syntax is painfully repetitive, so i only use them when there is a very obvious benefit
08:02:53 <dolio> I will admit that writing StateType m instead of s isn't great.
08:04:32 <aristid> dolio: what annoys me most is the instances. instance Foo (ComplexType a b c) where type Bar (ComplexType a b c) = X -- repetition
08:04:43 <dolio> Ah, yeah.
08:11:54 <qfr> setup.exe: At least the following dependencies are missing:
08:11:54 <qfr> QuickCheck ==1.*
08:12:02 <qfr> Doesn't it automatically install dependencies?
08:12:09 <qfr> Trying to install Takusen on Windows
08:12:23 <Igloo> cabal-the-program does
08:12:27 <Igloo> Setup.hs doesn't
08:12:40 <qfr> Igloo: That's from cabal install takusen
08:13:06 <dcoutts> qfr: cabal --version ?
08:13:08 <Silvah> @pl \a b xs -> map (\x -> if x == a then b else x) xs
08:13:25 <qfr> C:\Windows\System32>cabal --version cabal-install version 0.8.2 using version 1.8.0.2 of the Cabal library
08:13:39 <Silvah> No lambdabot again?
08:14:19 <dcoutts> qfr: hmm, not sure then
08:14:32 <qfr> :|
08:14:59 <Igloo> Is takusen's setup.exe something other than Cabal's defaultMain or similar?
08:15:11 <Igloo> It might not be understanding --user or something
08:15:11 <qfr> cabal install QuickCheck && cabal install Takusen did the trick
08:15:23 <Igloo> Hmm, curious
08:16:12 <dcoutts> qfr: ah, sorry, I was looking at the wrong version number, it's the Cabal lib version here that's relevant.
08:16:25 <qfr> I posted it, too
08:16:27 <dcoutts> qfr: so that is a known bug, fixed in Cabal 1.8.0.4
08:16:34 <qfr> Ah, I see
08:16:40 <dcoutts> posted where?
08:16:56 <qfr> SpecConstr  Function `$wremaining{v s1AJ} [lid]'   has four call patterns, but the limit is 3  Use -fspec-constr-count=n to set the bound  Use -dppr-debug to see specialisations
08:17:01 <qfr> I wonder what is about
08:17:11 <qfr> Takusen installed anyways
08:17:34 * edwardk1 waves hello.
08:17:46 <dcoutts> qfr: so you can avoid that bug in future if you: cabal install cabal cabal-install, ie to rebuild cabal-install against the newer Cabal lib
08:18:12 <qfr> Trying that
08:18:25 <qfr> Does the cabal binary need to be in a special place btw? Or is it irrelevant?
08:18:30 <qfr> I just copied it to the ghc7 \bin
08:19:07 <dcoutts> qfr: cabal itself will install binaries to your user home area, under cabal/bin/
08:19:29 <qfr> Do I use that new binary then?
08:19:30 <dcoutts> qfr: having that dir on your path means you'll be able to more easily run programs you install
08:19:32 <edwardk1> jmcarthur: monads-fd _became_ the new mtl.
08:19:38 <qfr> Ok
08:20:01 <kamaji> hah, fizzbuzz in haskell is so much easier
08:20:01 <edwardk1> jmcarthur: so using the mtl you'll still be able to use transformers, which was the key insight
08:20:14 <kamaji> I like this language
08:20:50 <qfr> Cabal-1.8.0.6 depends on directory-1.0.1.2 which failed to install.
08:21:02 <edwardk1> kamaji: it grows on you ;)
08:21:06 <qfr> dcoutts it failed :(
08:21:21 <qfr> process-1.0.1.4 depends on directory-1.0.1.2 which failed to install.
08:21:39 <dcoutts> qfr: you did install right, not upgrade?
08:21:51 <qfr> I copy pasted cabal install cabal cabal-install
08:21:54 <qfr> to cmd.exe
08:22:07 <tibbe> dcoutts: any ETA on when the Cabal test changes will be public? I could really use the test support to get HPC output for network
08:22:07 <kamaji> edwardk: And to think I hated it when I was made to learn it :P
08:22:25 <dcoutts> tibbe: it's in Cabal-1.10 which is released already
08:22:35 <tibbe> dcoutts: woot!?
08:22:39 <edwardk> kamaji: ah, i was lucky enough to have had to discover it for myself
08:22:56 <tibbe> dcoutts: is the new stanza ignored by older versions of cabal?
08:23:13 <dcoutts> tibbe: ignored by Cabal-1.8 but it will cause problems for Cabal-1.6
08:23:27 <dcoutts> qfr: I suspect you've got some newer versions of core libs installed which is causing cabal to try to install other matching ones
08:23:28 <tibbe> dcoutts: so I should add Cabal >= 1.8 then
08:23:58 <qfr> dcoutts should I remove something?
08:24:04 <dcoutts> tibbe: cabal-version: >= 1.8, yes, though I think at the moment the hackage QA test is stricter and requires 1.10, but I'll fix that
08:24:15 <qfr> I first installed the latest HP, then removed it and downloaded the most recent Windows cabal build and ghc 7
08:24:16 <tibbe> dcoutts: OK
08:24:57 <dcoutts> qfr: ah, you're using ghc 7 now then?
08:25:03 <qfr> dcoutts yep
08:25:08 <qfr> Does that break? :[
08:25:14 <dcoutts> qfr: oh ok, try building cabal with ghc-6.12.x
08:25:22 <qfr> Oh ok
08:25:44 <aristid> tibbe: i got a question about your blog posts about binary/cereal if you don't mind. you mention partial parsing with a special type. it seems to me that this type looks pretty similar to iteratees? why did you not use that in the proposal?
08:26:20 <dcoutts> aristid: you should be able to use iteratees with a binary parser of that form
08:26:27 <tibbe> dcoutts: the only docs are lagging, they're missing the test suite docs
08:26:39 <tibbe> aristid: it is
08:26:54 <tibbe> aristid: we don't have a concrete iteratee type that's simple enough
08:27:19 <aristid> tibbe: the simplified iteratees from the enumerator package are still too complex?
08:27:46 <augur> hey everyone
08:27:53 <augur> hows life? :D
08:27:57 <tibbe> aristid: there are also too may indirections, any additional ones will kill performance
08:27:58 * augur hugs everyone
08:28:06 <tibbe> aristid: for example Chunks [a]
08:28:31 <tibbe> aristid: also you don't need the monadicness of iteratees
08:28:42 <qfr> dcoutts process-1.0.1.4 depends on directory-1.0.1.2 which failed to install.
08:28:50 <qfr> Same problem with ghc 6.12
08:28:55 <tibbe> aristid: like dcoutts said, you can wrap the binary type in iteratees
08:29:00 <qfr> C:\Windows\System32>ghc --version
08:29:00 <qfr> The Glorious Glasgow Haskell Compilation System, version 6.12.3
08:29:23 <tibbe> dcoutts: do we have any docs for test-suite that I can look at?
08:29:26 <aristid> tibbe: hmm.
08:29:30 <tibbe> dcoutts: I only plan to use the simple interface
08:29:33 <qfr> Further up it also printed: cabal: Missing dependency on a foreign library:
08:29:33 <qfr> * Missing header file: HsDirectory.h
08:29:38 <dcoutts> tibbe: yes, I'm just looking for the patch
08:29:56 <tibbe> dcoutts: ok, thanks
08:29:59 <dcoutts> qfr: can you post somewhere the output of cabal install cabal cabal-install --dry-run -v
08:30:09 <qfr> Oh, it still mentions ghc7 though
08:30:10 <qfr> I wonder why
08:30:31 <qfr> Installing library in
08:30:31 <qfr>  C:\Users\void\AppData\Roaming\cabal\random-1.0.0.3\ghc-7.0.1
08:30:37 <qfr> I shall do that
08:31:11 <qfr> dcoutts http://siyobik.info/index.php?module=pastebin&id=549
08:31:42 <tibbe> dcoutts: new Cabal doesn't build for me
08:31:51 <dcoutts> qfr: so you're still using ghc7, that's the problem
08:32:02 <tibbe> dcoutts: missing or recursive dependency on process-1.0.1.4
08:32:03 <dcoutts> tibbe: using what?
08:32:04 <pastorn> tibbe: you need to pull cabal-install
08:32:09 <pastorn> from the darcs repo
08:32:23 <tibbe> pastorn: oh, so we're still waiting for a new cabal-install then?
08:32:39 <qfr> dcoutts: Ah I had to move the cabal.exe to the old ghc
08:32:40 <pastorn> tibbe: you get Cabal with ghc7, but you don't get cabal-install, so just pull it's repo and run $ sh bootstrap.sh
08:32:41 <tibbe> dcoutts: GHC 7 and cabal update && cabal install Cabal cabal-install
08:32:45 <dcoutts> tibbe: do you mean Cabal lib or cabal-install?
08:33:08 <dcoutts> tibbe: ok, so as pastorn says, you need darcs version of cabal-install
08:33:15 <pastorn> tibbe: pulling/geting will take a while... quite a lot of patches :)
08:33:15 <qfr> Now it's running ./configure it seems
08:33:15 <tibbe> dcoutts: I see
08:33:59 <tibbe> pulling
08:34:17 <dcoutts> qfr: still not good, you should not need to reinstall any core libs
08:35:14 <qfr> C:\Users\void\AppData\Roaming\cabal\network-2.3\ghc-6.12.3/libHSnetwork-2.3.a(HsNet.o):HsNet.c:(.text+0x9d): undefined reference to `freeaddrinfo@4'
08:35:18 <qfr> It failed
08:35:38 <dcoutts> qfr: if you're using the HP you already have network installed.
08:35:47 <dcoutts> qfr: can you post somewhere the output of cabal install cabal cabal-install --dry-run -v
08:35:54 <qfr> Those are ws2_32 references
08:36:15 <kamaji> is Data.Array a standard component?
08:36:33 <qfr> dcoutts http://siyobik.info/index.php?module=pastebin&id=550
08:36:38 <ddarius> kamaji: Effectively.
08:36:55 <kamaji> so it should just work in ghci?
08:36:57 <qfr> That cabal.exe is in G:\ghc\ghc-6.12.3\bin\
08:37:02 <ddarius> Yes.
08:38:13 <gb345> noob here, hi! sorry to butt in...  can i get some help w the question in http://hpaste.org/42889 ?
08:38:21 <gb345> basically, do all the f's in (<*>) :: f (a -> b) -> f a -> f b refer to the same functor?
08:38:46 <aavogt> gb345: yes
08:38:46 <sipa> gb345: yes
08:38:57 <gb345> thanks!
08:39:18 <qfr> dcoutts: Should I just remove my cabal directory and start with a fresh one or something?
08:39:19 <aavogt> you can use other instances of  Applicative to define instances of applicative
08:39:22 <dcoutts> qfr: ok, so that looks like it'll work
08:39:45 <qfr> dcoutts: It might be because the gcc in my path doesn't have the Windows libs it wants
08:39:49 <qfr> ws2_32.a
08:39:50 <dcoutts> qfr: no, as you can see from that output, it's just going to reinstall cabal-install-0.8.2, everything else is already installed.
08:40:02 <gb345> aavogt: hhmmm, ok...  thanks
08:40:02 <qfr> I mean, why the build failed
08:40:30 <qfr> dcoutts http://siyobik.info/index.php?module=pastebin&id=551
08:40:35 <dcoutts> qfr: as you can see from the output, it's not going to reinstall network because version 2.3 is installed already.
08:41:01 <dcoutts> ah I see, it's installed but seems to be borked
08:41:16 <qfr> dcoutts: I am using gcc 4.5 in my PATH
08:41:24 <qfr> Maybe it's incompatible with those binaries?
08:41:33 <qfr> Because they were built with gcc 3.4.5?
08:41:34 <dcoutts> qfr: can you run cabal list network, is there just version 2.3 installed?
08:41:39 <gb345> what throws me off is that, e.g., in not :: Bool -> Bool, the two Bools actually refer to different values...
08:41:39 <dcoutts> qfr: that's possible.
08:42:08 <qfr> dcoutts yes, I see 2.3 only
08:42:08 <gb345> i can't tell when the variables in type notations refer to the same entity or not...
08:42:17 <qfr> And lots of other packages which have "network" in their name
08:42:20 <ddarius> gb345: They refer to the same type like True and True refer to the same value.
08:42:24 <tibbe> dcoutts: darcs version of cabal-install fails too
08:42:43 <tibbe> dcoutts: same problem with process
08:43:16 <tibbe> dcoutts: I have process-1.0.1.4 sitting in both the global and user package db if that matters
08:43:21 <ddarius> gb345: Variables at the type level behave just like variables at the value level.  You wouldn't expect in (x, x) to mean different things in each component.
08:43:25 <dcoutts> tibbe: blow away the user one
08:43:36 <ddarius> s/in/x in/
08:43:52 <gb345> yes but by the same token then the f's in (<*>) :: f (a -> b) -> f a -> f b should just mean "some functor", with not all referring necessarily to the same one?
08:44:21 <gb345> ...just like the Bool's in not :: Bool -> Bool don't refer to the same value?
08:44:42 <ddarius> gb345: Again, Bool is a type, it doesn't "refer" to values at all.
08:45:11 <ddarius> Furthermore, the more explicit notation for that which is supported as an extension in most Haskell implementations is forall f a b. f (a -> b) -> f a -> f b
08:45:35 <ddarius> gb345: Also, a functor has kind * -> *, so there are no functor "values."
08:45:40 <applicative> gb345 the f 's all refer to the same type former; just one at a time, as in id :: a -> a
08:46:05 <qfr> dcoutts hah I just tried to start with a fresh build by renaming the cabal directory
08:46:09 <ddarius> :t (<*>)
08:46:20 <qfr> Ran cabal update and then tried to build cabal
08:46:26 <qfr> There are files missing in the `network-2.3' package
08:46:31 <qfr> Without it it can't do anything? :P
08:46:32 <ddarius> lambdabot still gone (or is she gone again?)
08:46:35 <gb345> ok, thank you all, i need to read more i guess...
08:46:39 <gb345> bye
08:46:54 <applicative> gb345, yes come back 
08:46:55 <applicative> ah well
08:47:43 <qfr> dcoutts: Do I need to bootstrap network myself for this to work out?
08:47:44 <dcoutts> qfr: try with the gcc that comes with the HP rather than your newer one.
08:47:50 <qfr> Eeww :[
08:47:54 <dcoutts> qfr: the network that comes with the HP should just work.
08:48:16 <qfr> I want to use a brand new gcc though! Where is the fun in using ghc 7 when I'm using a compiler from like 2003?
08:48:30 <tibbe> dcoutts: what's the best way to avoid problems the day I want to fix network to only use bytestrings?
08:48:37 <Jafet> LLVM, the new gcc
08:48:49 <qfr> Jafet don't you mean clang?
08:49:50 <dcoutts> tibbe: major version bump
08:50:15 <Jafet> I thought we were looking at it from the haskell viewpoint
08:50:35 <romanandreg> guys do you know any Haskell Library Structure Generator?
08:50:51 <romanandreg> something like "snap init" but for normal libraries
08:50:56 <aavogt> romanandreg: like   'cabal init' ?
08:51:10 <romanandreg> oh
08:51:16 <romanandreg> didn't know that cabal had that
08:51:16 <tibbe> dcoutts: anything in addition to that? can I help users avoid problem where one of their deps is "network <= x" and another "network > x && < x+1"?
08:51:37 <qfr> dcoutts can't I just build this manually from http://hackage.haskell.org/package/Cabal-1.10.0.0 ?
08:52:07 <aavogt> romanandreg: it doesn't generate as much as it could though. I guess that's because the organization of source code is kind of arbitrary
08:52:07 <qfr> http://hackage.haskell.org/package/cabal-install oh I will still need this ultimately haha
08:52:16 <tibbe> dcoutts: is there anything holding us back from documenting the exitcode-stdio interface publicly?
08:52:19 <dcoutts> qfr: no, you already have Cabal-1.8.0.6 installed. That's the version you want.
08:52:21 <qfr> That's a lot of dependencies and I suppose I'd have to compile all of those myself then
08:52:23 <romanandreg> aavogt: thanks
08:52:33 <qfr> dcoutts why not the newer one btw?
08:52:44 <dcoutts> tibbe: I think it is actually documented now. Check out the Cabal.markdown in the Cabal-1.10 package
08:53:00 <dcoutts> qfr: if you're using the HP, the network package just works.
08:53:03 <tibbe> dcoutts: but the online user guide doesn't have it I believe
08:53:19 <qfr> dcoutts well I'm not, the entire point of this was to use the brand new stuff for everything, heh
08:53:21 <dcoutts> tibbe: right, the Cabal-1.10 release is not on the Cabal website yet
08:53:44 <tibbe> dcoutts: ok, waiting for the next cabal-install release?
08:53:50 <dcoutts> qfr: but you don't want to debug an entire stack using a new gcc, or if you do, then you have to tackle that head on
08:54:08 <qfr> dcoutts oh do you think it would break on Windows?
08:54:12 <dcoutts> tibbe: yep, I want to make a point release of Cabal lib plus a compatible cabal-install release.
08:54:26 <dcoutts> qfr: well it appears that it does, given your linking problem with network.
08:54:28 <tibbe> dcoutts: ok
08:54:57 <dcoutts> tibbe: but take a look at the user guide, lemme know if you think there's anything missing from the sections on cabal test
08:55:16 <qfr> What are these array and base packages and such btw? I didn't see those anywhere in my cabal directories
08:55:25 <qfr> Are they integrated with ghc somehow?
08:55:34 <monochrom> yes
08:55:49 <qfr> Ah, are all lower case ones integrated?
08:55:54 <qfr> No wait, that doesn't work
08:55:56 <monochrom> especially base is a hardwired lock-in.
08:56:06 <qfr> network is lower case, yet it's not internal
08:57:27 <dcoutts> qfr: there is no upper/lower case naming convention for packages really
08:57:32 <qfr> I se
08:57:46 <tibbe> dcoutts: ok
08:57:56 <joe6_> hello, I am wondering if you have any suggestions on http://hpaste.org/42890/testing_transactions
08:58:00 <Twey> Confusingly enough
08:58:39 <joe6_> please.
08:59:24 <monochrom> there are 4 packages absolutely hardwired locked in: ghc-prim, integer-gmp, base, ffi. You just can't replace them. (If you manage to replace them, the replacement is ignored.)
08:59:49 <tibbe> dcoutts: it seems like the test-suite argument can contain slashes, will Cabal escape those?
09:00:16 <monochrom> and then there are the rest of packages that come with ghc. they could be replaced, but they are so inter-dependent with each other that if you replace one you have to replace all.
09:00:25 <dcoutts> tibbe: you mean the name of the testsuite? that's probably bad.
09:00:25 <qfr> Ah I see them now in G:\ghc\ghc-7.0.1\lib
09:00:29 <tibbe> dcoutts: has the detailed interface been decided upon? otherwise you might want to take that out
09:00:39 <tibbe> dcoutts: right, the docs now says anything but spaces
09:00:55 <qfr> Oh snap, so I am pretty much forced to use an old MinGW version :/ sad
09:01:17 <MHD0> Is there a haskell library for mathematical sound generation or chiptunes or something like that? One not dependent of files, but only functions and data structures for note playing and stuff?
09:01:17 <dcoutts> tibbe: I see, that might be the same for all lib/exes. Whatever it is, the allowed names should be the same. It's one namespace.
09:02:39 <monochrom> actually there are more than 4 hardwired locked in packages. use "ghc -v" and look for "wired-in package xxx mapped to xxx-version-hexcode"
09:03:10 <tibbe> dcoutts: ok
09:03:20 <monochrom> if you don't know the significance of the hexcode, you're doing yourself a disservice. read http://www.vex.net/~trebla/haskell/sicp.xhtml
09:03:22 <joe6_> monochrom: do you have any suggestions on http://hpaste.org/42890/testing_transactions, please?
09:03:40 <monochrom> why pick me?
09:03:51 <tibbe> dcoutts: I'd like to see a note about depending on libraries defined in the same Cabal file, as that's probably a common use case. Is it possible?
09:04:02 <tibbe> dcoutts: and if so, how do you list an internal library in build-depends?
09:04:13 <aristid> monochrom: because you are the lucky one
09:04:43 <joe6_> monochrom:  because sometime ago, I remember that you had some very good suggestions.
09:05:17 <dcoutts> tibbe: I think that's specified elsewhere, in the section about build-depends.
09:05:39 <dcoutts> tibbe: tbh, the user guide needs a full rewrite
09:06:15 <tibbe> dcoutts: user, although it has served me well
09:06:22 <tibbe> dcoutts: it could use a more full featured example
09:06:29 <tibbe> dcoutts: i.e. from a real project, with tests and all
09:06:42 <dcoutts> tibbe: patches accepted! :-)  and it's now markdown so it's much easier.
09:07:27 <tibbe> dcoutts: yes, I love markdown
09:07:33 <Igloo> An actual example (e.g. hello-world, which could also be on hackage) would probably be better, as you could easily test it was actually right
09:07:51 <dcoutts> we need both
09:08:02 <dcoutts> there's already a cabal demo package on hackage
09:08:02 <tibbe> dcoutts: the internal libraries thing is not documented under Build information
09:08:14 <dcoutts> we need that updated, plus info un the user guide
09:08:17 <tibbe> dcoutts: inline example is much easier to cut-n-paste :)
09:08:24 <dcoutts> I agree
09:08:38 <qfr> G:\ghc\ghc-7.0.1\mingw\bin>g++ --version
09:08:38 <qfr> g++ (GCC) 4.5.0
09:08:43 <qfr> Oh nice, they were built with a new one
09:08:44 <Cale> @bot
09:09:23 <tibbe> dcoutts: It's a bit of a bummer that I need to replicate the whole library stanza just to build the library with -fhpc in my test suite
09:09:39 <dcoutts> tibbe: do you need to do that?
09:09:50 <tibbe> dcoutts: to get test coverage reports yes
09:10:07 <tibbe> dcoutts: the library itself needs to be compiled with -fhpc
09:10:17 <tibbe> dcoutts: unless we introduce package stanza subtyping ;)
09:11:54 <dcoutts> tibbe: so we should add hpc support directly, it's was on the original cabal test feature list (but lower down)
09:12:01 <dcoutts> there's a ticket on it already
09:12:14 <tibbe> dcoutts: ok, it can be a bit tricky
09:12:18 <tibbe> dcoutts: well
09:12:30 <tibbe> dcoutts: I guess it's just a flag that gets added to ghc everywhere
09:12:51 <tibbe> dcoutts: how about: --enable-test-coverage which implies ghc-options: -fhpc everywhere?
09:12:55 <dcoutts> tibbe: that's why I wanted a field to indicate that hpc is useless for a particular test, because it doesn't actually link with the code, e.g. just runs a prog
09:13:04 <hpc> wait, i am useless?
09:13:18 <tibbe> dcoutts: I didn't quite get that?
09:13:20 <dcoutts> tibbe: right (modulo details of implementation)
09:13:29 <dcoutts> hpc: ;-)
09:13:32 <tibbe> dcoutts: I think that would get us pretty far
09:13:40 <tibbe> sounds like an hour of work!
09:14:44 <dcoutts> tibbe: suppose I have a testsuite that just runs a program with a few inputs, ie it does not link to hpc'able code. Then we cannot collect hpc info from that testsuite, it'd only cover the testing framework
09:15:21 <dcoutts> tibbe: so we want to be able to run any testsuite with hpc, but some testsuites will need to be able to opt-out since it does not make sense for them.
09:15:56 <tibbe> dcoutts: but does it hurt to generate the report?
09:16:13 <dcoutts> tibbe: yes because its useless, so hackage will fill up with useless reports.
09:16:16 <tibbe> dcoutts: I guess we could provide a list of modules per stanza that don't participate in the report
09:18:59 <sshc> "total alloc = 34,095,784,320 bytes  (excludes profiling overheads)"
09:19:03 <sshc> What exactly is this value?
09:19:34 <tibbe> dcoutts: the coverage support would probably put the tix files somewhere nicer
09:19:47 <dcoutts> tibbe: right
09:19:51 <sipa> sshc: how much is allocated, including things that have been freed again
09:20:02 <Igloo> sshc: Roughly, sum the n's for which malloc(n) is called
09:20:25 <tibbe> dcoutts: and point you to the generated report
09:21:12 <tibbe> dcoutts: perhaps --enable-library-test-coverage would be better? although it's a bit long
09:21:29 <dcoutts> tibbe: for test yes, it can do everything. If you also want to allow building normal exes and libs with hpc then the user has to generate the report themselves I guess
09:21:32 <sshc> I see, thanks.
09:21:48 <Igloo> (very roughly)
09:21:48 <dcoutts> tibbe: well do we want lib and exe separately?
09:21:55 <tibbe> dcoutts: good question
09:22:11 <sshc> Seems I have a bad space leak
09:22:17 <dcoutts> tibbe: we can always have all three
09:22:26 <sshc> Oh, calls to "free" are ignored?
09:22:52 <tibbe> dcoutts: --enable-library-test-coverage is a bit vague, we would to check if coverage data was generated and then point the user to the report
09:22:58 <Igloo> Yes, it's the amount of allocation that is done
09:23:04 <Igloo> Not the peak allocated
09:23:23 <tibbe> dcoutts: --enable-test-coverage would be a bit clearer in that we know that we did generate coverage reports for all test stanzas
09:23:42 <tibbe> dcoutts: do you see the difference, the former really implies pass -fhpc
09:24:08 <Igloo> If you want to look at the space usage, heap profiling is a much better tool, BTW
09:24:45 <dcoutts> tibbe: I don't see how we can point users at a report in the case we're just compiling the lib with -fhpc, since we don't generate any report.
09:25:10 <tibbe> dcoutts: exactly
09:25:11 <dcoutts> tibbe: I agree that with cabal test, in hpc mode, we can do everything (and have tools that upload reports to hackage).
09:25:17 <tibbe> dcoutts: so the lib flag is not enough
09:26:31 <qfr> http://siyobik.info/index.php?module=pastebin&id=552 cabal.exe: Missing dependency on a foreign library: * Missing header file: HsDirectory.h
09:26:43 <qfr> http://hackage.haskell.org/trac/ghc/ticket/3653 is this related? It's really old thoughj
09:27:14 <qfr> I guess I'll try to run it manually like he did
09:27:16 <qfr> To see what happens
09:27:59 <dcoutts> qfr: if you cabal configure -v3 in the network package, you can see why it really failed.
09:28:10 <qfr> Yeah I'll try that
09:28:24 <qfr> dcoutts but it's a problem with directory, not network, right?
09:28:27 <dcoutts> qfr: it tries to compile the headers, it'll report what error gcc produced.
09:28:34 <qfr> That's a file from the directory package
09:28:35 <dcoutts> qfr: oh yes, oops.
09:29:13 <qfr> Running runhaskell Setup configure -v3
09:29:25 <qfr> Odd, it prints no errors?
09:29:29 <qfr> runhaskell Setup configure -v3
09:29:29 <qfr>  executed just fine
09:29:32 <qfr> From the looks of it
09:29:50 <dcoutts> tibbe: at the moment I'm hacking on cabal install http://example.com/~me/foo-1.0.tar.gz
09:30:06 <tibbe> dcoutts: cool
09:30:10 <tibbe> dcoutts: that'll be useful
09:30:15 <tibbe> dcoutts: do you have a particular use case?
09:30:20 <dcoutts> and also local dir and tarball targets
09:30:34 <dcoutts> tibbe: well it makes it a lot easier for people to try out beta versions
09:30:40 <dcoutts> less need to stick betas on hackage
09:31:00 <dcoutts> and it's a first step to things like what the cabal-dev wrapper does
09:31:01 <byorgey> drumroll...
09:31:04 <qfr> dcoutts http://siyobik.info/index.php?module=pastebin&id=553 I don't see any errors?
09:31:04 <dcoutts> isloated builds etc
09:31:06 <tibbe> dcoutts: right, can the install go into a local dir so I can avoid cluttering my package db with these betas?
09:31:20 <byorgey> http://themonadreader.wordpress.com/2011/01/09/issue-17/
09:31:23 <dcoutts> tibbe: yes you can do that now
09:31:25 <byorgey> (finally)
09:31:29 <dcoutts> byorgey: woo!
09:31:31 <tibbe> dcoutts: isolate builds would be great, I have a use case (crawling and building an index of all of Hackage)
09:31:38 <tibbe> dcoutts: is it documented?
09:31:42 <dcoutts> tibbe: right, I've done that.
09:31:51 <dcoutts> tibbe: yes, cabal install --help :-)
09:31:59 <dcoutts> tibbe: and a blog post with an example
09:32:12 <dcoutts> tibbe: you just need --prefix and --package-db
09:32:58 <tibbe> dcoutts: great
09:33:09 <tibbe> dcoutts: I will definitely use that
09:33:26 <dcoutts> tibbe: cabal-dev and capri more or less just call cabal with the right prefix and package db flags.
09:33:28 <tibbe> dcoutts: is there a way to remember configure information so it can be used in the test stage?
09:33:40 <tibbe> dcoutts: I guess that's what the dist/config-something file is for
09:33:46 <dcoutts> tibbe: yes the LocalBuildInfo is saved.
09:33:54 <tibbe> dcoutts: right, you plan to absorb that functionality into Cabal?
09:33:56 <tibbe> dcoutts: cool
09:34:01 <dcoutts> tibbe: yep
09:34:05 <dcoutts> but better
09:35:16 <ezyang> Whoo, new TMR 
09:35:47 <quuuux> @hoogle Ord b => (a -> b) -> [a] -> [a]
09:35:48 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
09:35:48 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
09:35:48 <lambdabot> Prelude takeWhile :: (a -> Bool) -> [a] -> [a]
09:36:24 <ezyang> Oh, huh, difference lists. 
09:36:45 <tibbe> dcoutts: excellent
09:37:57 <ezyang> With lambdas. Of course. :-) 
09:38:30 <qfr> Has nobody here tried to build the most recent cabal lib on Windows with gcc 4.5? :(
09:38:51 <dcoutts> qfr: they must have, because it comes with ghc
09:39:09 <qfr> Oh? I didn't see any cabal binaries in ghc 7
09:39:19 <qfr> Or do you mean gcc coming with it?
09:39:19 <dcoutts> you said cabal lib
09:39:52 <ezyang> I've always thought Haskell list concatenation worked a lot like difference lists, due to laziness. 
09:39:56 <qfr> http://siyobik.info/index.php?module=pastebin&id=554
09:40:07 <qfr> System\Random.hs:78:8: Could not find module `Data.Time':
09:40:11 * qfr shrugs helplessly
09:42:37 <qfr> http://siyobik.info/index.php?module=pastebin&id=555
09:42:53 <qfr> Configuring Takusen-0.8.6... Warning: This package indirectly depends on multiple versions of the same package. This is highly likely to cause a compile failure.
09:42:57 <qfr> :(
09:43:44 <qfr> package QuickCheck-1.2.0.1 requires random-1.0.0.3  package Takusen-0.8.6 requires random-1.0.0.3 package random-1.0.0.3 requires time-1.1.4 package random-1.0.0.3 requires time-1.2.0.3 package Takusen-0.8.6 requires time-1.2.0.3
09:43:48 <qfr> I dont' even understand that
09:44:05 <qfr> How can the same version of a package depend on two different versions of another package..?
09:44:47 <qfr> random-1.0.0.3-f0fdff8c2748d7e1bd79ad0638de0668 is shadowed by package random-1.0.0.3-d36e1a6be6cec702dd6508744ed5eeb7
09:45:37 <qfr> dcoutts I don't understand this at all :(
09:46:56 <dcoutts> qfr: I suggest you stick to the HP release. You need to know a bit more about how the system works to debug theses sorts of dep issues with bleeding edge stuff.
09:47:06 <qfr> Aw :(
09:47:42 <qfr> But if I don't try to understand it now I'll never learn it
09:48:02 <qfr> And when it happens again in future I still won't know how to deal with it
09:49:44 <qfr> It looks like the problem is that random requires two versions of time
09:49:52 <qfr> Is this some kind of ghc 6/ghc 7 collision?
09:50:00 <qfr> Does ghc 6 use time 1 1 4?
09:50:12 <qfr> Whereas ghc 7 uses time 1 2 0 3?
09:51:37 <dcoutts> qfr: first thing is to make sure you only have one instance of each package version. Use ghc-pkg list to see.
09:52:04 <qfr> It has two versions
09:52:13 <qfr> time-1.2.0.3 time-1.1.4
09:52:51 <qfr> http://siyobik.info/index.php?module=pastebin&id=554 <- this was apparent there, here
09:52:56 <tibbe> dcoutts: the test coverage support should probably delete the tix files after generating the report, hpc gets cranky otherwise
09:53:06 <qfr> C:\Users\void\AppData\Roaming\ghc\i386-mingw32-7.0.1\package.conf.d contains an old one
09:53:08 <hpc> argh, this is annoying
09:53:10 * hpc quits
09:53:14 <qfr> I should probably get rid of that one, too
09:53:21 <qfr> I didn't know it stored stuff in ghc, too
09:53:27 <qfr> I just removed the original cabal directory
09:53:59 <dcoutts> tibbe: or before running the test
09:54:06 <tibbe> dcoutts: yes
09:54:08 <qfr> There, got rid of it
09:54:14 <dcoutts> tibbe: it might be useful to users to see the tix after a test run
09:54:23 <tibbe> dcoutts: yes, before the test would be better
09:54:34 <dcoutts> tibbe: and yes we should certainly put them somewhere other than .tix or whatever hpc does by default
09:55:14 <qfr> QuickCheck setup.exe error again now :p going to install it manually
09:55:36 <qfr> Takusen installed :D
09:55:38 <qfr> Victory :D
09:55:45 <qfr> dcoutts thanks for your help
09:55:55 <qfr> All I had to do was to remove the old ghc directory in roaming
09:57:35 <tibbe> anyone here knows hpc well?
09:57:49 <tibbe> I'm getting: hpc: can not find Main in ["./.hpc"]
09:58:15 <qfr> cabal install cabal cabal-install --dry-run -v suggests that it wants to downgrade packages, odd
09:58:24 <qfr> Well, whatever, I guess I have everything I need now :P
09:58:35 <dcoutts> tibbe: you redirected it presumably
09:58:48 <b0fh_ua> Hi. When working with parsec - how do I get 4 bytes from stream and convert them into integer (little endian)?
09:58:49 <tibbe> dcoutts: not to my knowledge
09:58:57 <dcoutts> tibbe: when you build with -fhpc it generates a load of stuff in a .hpc directory
09:59:09 <dcoutts> tibbe: and presumably you redirected that when you did the build
09:59:24 <dcoutts> you need to specify that dir to hpc when generating reports etc
09:59:49 <tibbe> dcoutts: there's a .hpc dir in the package root
10:00:12 <dcoutts> tibbe: ah ok, you didn't redirect it then
10:00:12 <tibbe> dcoutts: with the whole lib's .mix files, plus a file called Main.mix
10:00:36 <tibbe> dcoutts: aha, found the problem
10:00:46 <tibbe> dcoutts: I ran two tests after each other, the latter clobbered the former
10:01:10 <dcoutts> ah
10:01:44 <dcoutts> tibbe: so you need to redirect the .hpc output during the build to somewhere sensible under dist, separate for each component
10:01:55 <dcoutts> and don't use a hidden dir name like .hpc of course
10:02:15 <tibbe> dcoutts: I need to look for hpc related ghc flags then
10:02:16 <qfr> b0fh_ua hmm isn't parsec for parsing text?
10:02:30 <qfr> b0fh_ua is it possible that http://hackage.haskell.org/package/attoparsec is more suited for binary data?
10:02:42 <tlonim> I am getting this "Loading package readline-1.0.1.0 ... <command line>: can't load .so/.DLL for: ncurses (/usr/lib/libncurses.so: file too short)" while building a ghc package
10:03:02 <tlonim> doesn't the linker used by ghc understand linker macors ?
10:03:04 <tlonim> macros*
10:06:18 <b0fh_ua> qfr: well, there's mix of binary and textual data
10:06:34 <tibbe> dcoutts: we definitely need Cabal support for this, it's way to hard
10:07:25 <qfr> cabal install cabal cabal-install --dry-run -v | grep reinstall: process-1.0.1.4 (reinstall) changes: directory-1.1.0.0 -> 1.0.1.2, random-1.0.0.3 (reinstall) changes: time-1.2.0.3 -> 1.1.4
10:07:29 <dcoutts> tibbe: yep, that's always been my view, ghc-options: -fhpc is not nearly enough
10:07:36 <qfr> Why does cabal want to downgrdae my stuff?
10:07:49 <qfr> Apparently this is what caused the old time to install
10:08:00 <dcoutts> qfr: due to packages requiring older versions
10:08:02 <qfr> And the old directory on top of that
10:08:08 <dcoutts> qfr: are you using ghc 7 again?
10:08:11 <qfr> :D yes
10:08:14 <qfr> It worked out btw
10:08:16 <rumbold> can you do comments in haskell that ar nly part of a line like /* */?
10:08:21 <qfr> Takusen and such installed
10:08:26 <qfr> Takusen and Wai
10:08:27 <cdsmithus> rumbold {- comment -}
10:08:32 <dcoutts> qfr: so the cabal-install package you're trying to install requires older versions of various libs.
10:08:32 <rumbold> thanks
10:08:45 <dcoutts> qfr: either use ghc 6.12 or use the development version of cabal-install
10:08:51 <qfr> Ahhh
10:08:56 <qfr> dcoutts I need to darcs that? :D
10:09:40 * qfr loves wasting his time on getting bleeding edge stuff working all the time, it's the Arch/Gentoo genes kicking in
10:10:53 <tibbe> dcoutts: there's an -hpcdir flag to ghc
10:11:08 <tibbe> dcoutts: we need to set it separately for each target we build
10:11:18 <qfr> "selecting cabal-install-0.8.2 (hackage)" hmm http://hackage.haskell.org/package/cabal-install matches the most recent stable
10:11:28 <tibbe> dcoutts: actually noy
10:11:45 <tibbe> dcoutts: we only need to set it once to be something sensible, hpc create its own directory structure under that
10:11:59 <tibbe> dcoutts: we do need to change the pwd when running each test though
10:12:17 <dcoutts> tibbe: no it does need to be separate for each component
10:12:29 <tibbe> dcoutts: how come, there might be name overlaps?
10:12:32 <dcoutts> yes
10:12:33 <tibbe> dcoutts: I guess you're right
10:12:51 <dcoutts> tibbe: I think one can pass +RTS flags to specify the output .tix file
10:13:03 <tibbe> dcoutts: oooo, secret flags
10:13:06 <dcoutts> tibbe: so then we should not need to change the pwd
10:13:17 <dcoutts> tibbe: chaning the pwd has all sorts of bad consequences
10:13:24 <tibbe> dcoutts: yes
10:13:26 <Igloo> You can do HPCTIXFILE=$thisdir/testsuite/hpc_output/ghc.tix
10:13:41 <dcoutts> Igloo: ah ok, not an +RTS flag then
10:14:10 <tibbe> Igloo: thanks
10:14:20 <dcoutts> hmm, perhaps an env var is better since it will be inherited by any progs it calls, not just the top level
10:14:27 <dcoutts> though that may have its own consequences
10:17:14 <tibbe> dcoutts: I've documented the design issues so far here: http://hackage.haskell.org/trac/hackage/ticket/467
10:18:03 <dcoutts> tibbe: looks good
10:18:55 <qfr> Wow, darcsing cabal-install takes ages
10:19:03 <qfr> Why don't they use git? :p
10:19:17 <FauxFaux> It's not written in Haskell or overengineered enough. Â¬_Â¬
10:19:26 <qfr> Haha
10:19:39 <qfr> Wow, it retrieves like 30 1 KiB gz files per second
10:19:53 <FauxFaux> I hear there are actually cases where darcs merges better than git.  Not common or even likely cases.
10:19:54 <qfr> That sounds super inefficient
10:20:03 * qfr wireshark
10:20:05 <FauxFaux> git will do that if you have an unpacked repo and are fetching it over http.
10:20:12 <qfr> Yeah HTTP sucks
10:20:27 <qfr> Doesn't darcs have a proper protocol of its own?
10:20:31 <qfr> Or does it always use HTTP? :/
10:20:37 <FauxFaux> I do not give a single care.
10:20:47 <qfr> Because you don't use darcs? :P
10:20:55 * geheimdienst switched away from git because he was fed up with the million inconsistent, ass-backwards commands and options
10:21:00 <FauxFaux> 'cos it's inferior to git in every way, yes. Â¬_Â¬
10:21:02 <dcoutts> newer versions using more recent repo format have an efficient HTTP transfer
10:21:32 <cdsmithus> What's with all the pie-in-the-sky "git is perfect" stuff here recently?  *shrug*
10:21:35 <qfr> Well, I didn't plan on starting to use darcs :p but I'm trying to get a dev version of cabal-install which I can actually build and install atm
10:21:49 <qfr> cdsmithus: I wasn't aware people talked about git much here
10:22:21 <qfr> It just works really well for me, although I wish cloning and pushing were even faster with github
10:22:30 <qfr> Yaay darcs is finally done.
10:22:37 <geheimdienst> cdsmithus: same here. i don't get it. i did use git for a while, it was nice, but i've moved on
10:22:46 <qfr> geheimdienst what do you use now?
10:22:54 <geheimdienst> hg, darcs
10:23:26 <cdsmithus> I'm using git sometimes.  Darcs sometimes.  Depending on the project.  Git is definitely better for big code bases.  Darcs is far simpler and easier to use.  Each has its advantages
10:23:34 * hackagebot Unixutils 1.34 - A crude interface between Haskell and Unix-like operating systems  http://hackage.haskell.org/package/Unixutils-1.34 (JeremyShaw)
10:23:34 * Heffalump would just like to say, that darcs could really use more developers. I think we could make it really compete with git in almost every field, given even effort.
10:23:41 <Heffalump> s/even/enough/
10:24:08 <aristid> qfr: git vs darcs is a recurring topic :)
10:24:10 <quuuux> worse is better strikes again
10:24:13 <geheimdienst> the final straw for me was when i went on #git and asked something, then they told me basically "uh, you thought that git ls-files --cached would list the cached files? of course not. you must be a little stupid"
10:24:53 <qfr> What really sucks about git is that it doesn't provide a proper API, all the tools that interface with it depend on spawning the git process and parsing text output -_-
10:25:07 <qfr> And a lot of it is written in shell script which is terrible
10:25:09 <cdsmithus> Heffalump: good point.  One thing that I do like about darcs is that while it struggles on, e.g., GHC, it does strive to make things simple and correct first and foremost, and then solve the performance problems without those limits.
10:25:09 <Heffalump> darcs doesn't provide much of an API either, sadly, though we're working on it
10:25:23 <cdsmithus> ^within I meant
10:25:29 <Heffalump> cdsmithus: I'd agree with simple and correct if it wasn't for the conflict handling mess.
10:25:32 <qfr> But other than that I love it, in particular the query language which allows you to modify repositories programmatically
10:25:34 <Heffalump> but I do have a plan :-)
10:25:44 <aristid> geheimdienst: clearly you should write a blog post about the "Foul stench of cargo cult version control" surrounding git :)
10:26:38 <qfr> Cargo cult would be a fun name for a DVCS
10:27:05 <qfr> Haha now that I am thinking about the shortcomings of git I feel like writing a primitive DVCS
10:27:08 <qfr> Might be fun
10:29:01 <copumpkin> write one for dependently typed languages that is aware of their types
10:29:29 <qfr> I don't even know what that means
10:30:03 <qfr> Oh, cabal-install has a bootstrap.sh, I wonder if that will help
10:30:26 <qfr> Hah, lacks wget
10:31:46 <ddarius> copumpkin: Did you make your bread?
10:32:08 <copumpkin> nope, had to go out for dinner with a friend and got back late
10:32:14 <copumpkin> :(
10:32:19 <cdsmithus> Mmmm, I love pumpkin bread.  Never tried co-pumpkin bread
10:32:32 <copumpkin> gonna go get some groceries in a bit though
10:32:38 <copumpkin> so at least I can have yeast and get the thing started
10:32:56 <ddarius> copumpkin: Do you have bread flour?
10:33:00 <copumpkin> yeah
10:33:05 <j-invariant> whkat is bread flour?
10:33:10 <ddarius> Then you should be set.
10:33:11 <j-invariant> sorry gtg
10:33:43 <copumpkin> ddarius: well, I need yeast to get started
10:33:50 <Twey> Hmm
10:33:52 <copumpkin> I also don't have an electric mixer
10:33:53 <copumpkin> hmm
10:33:54 <ddarius> copumpkin: Well, yeah.
10:33:58 <edwardk> hrmm is there a thread delay that takes a time spec of some sort? i see delay which takes an integer number of micoseconds, nanosleep, and threadDelay, is any of them parameterized on some sort of unit?
10:34:02 <ddarius> copumpkin: I don't have an electric mixer either.
10:34:07 <copumpkin> alright
10:34:23 <ddarius> It doesn't really matter, it's just that the dough should be pretty wet which makes it not very fun to work with.
10:34:28 <Twey> I don't know about co-pumpkin bread, but coâ€“pumpkin bread sounds like it might be nice (bread made from ground pumpkin seeds, with wheat embedded in it, perhaps?)
10:34:45 <ezyang> edwardk: No, I don't think so. 
10:34:54 <edwardk> ezyang: shucks
10:34:57 <ezyang> threadDelay is kind of grungy, low level. 
10:35:42 <copumpkin> Twey: :P
10:35:44 <edwardk> yeah, i'm down in the weeds providing a bunch of task-parallel stuff and wanted to provide a scheduler the ability to delay tasks, and was looking for a clean API to emulate
10:36:22 <ezyang> ah :-) 
10:36:39 <ezyang> IIRC, most of the unit parametrized stuff is kind of clunky to use. 
10:37:58 <edwardk> well, the alternative is trying to magically remember if an argument is milliseconds, microseconds, etc.
10:38:35 <ddarius> edwardk: You should use Planck units.
10:38:45 <edwardk> hah
10:38:50 <ezyang> yeah. 
10:38:51 <Twey> Sounds like a plan
10:39:09 <Twey> We should also make operating systems and CPUs tick in terms of Planck times
10:39:37 <geheimdienst> > (maxBound :: Int) / 1000000
10:39:38 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
10:39:38 <lambdabot>    arising from a use o...
10:39:45 <geheimdienst> > (maxBound :: Int) `div` 1000000
10:39:46 <lambdabot>   9223372036854
10:39:49 <edwardk> sleep 5.39124e44
10:40:42 <c_wraith> > (maxBound :: Int32) / 1000000
10:40:43 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Int.Int32)
10:40:43 <lambdabot>    arising from a use o...
10:40:49 <c_wraith> > (maxBound :: Int32) `div` 1000000
10:40:49 <lambdabot>   2147
10:41:09 <Twey> edwardk: Heheh
10:41:12 <ezyang> oh, this reminds me of this little gem from ORc. 
10:41:50 <ezyang> putStrLine ("Just checking you meant to wait "               ++show w++" seconds"))
10:42:10 <geheimdienst> > 2147 `div` 60
10:42:11 <lambdabot>   35
10:42:18 <edwardk> hah
10:42:29 <geheimdienst> so on a 32-bit system, you can threadDelay for only about 35 mins
10:42:40 <c_wraith> yep
10:43:34 <vegai> it's kinda trivial to make your own function that can sleep more
10:43:49 <vegai> but it's also quite silly
10:43:53 <c_wraith> indeed
10:44:05 <qfr> I just darcs'ed and built cabal, yet it still says it's using an old Cabal lib version - 1.8.0.6, instead of 1.10.0.0, I am puzzled
10:44:18 <ezyang> mix 
10:44:27 <qfr> [void@ERDOS ~]$ ghc-pkg.exe list | grep Cabal
10:44:27 <qfr>     Cabal-1.10.0.0
10:44:33 <ezyang> well, there is a (marginal) performance loss from being woken up and going to sleep again. 
10:44:39 <ezyang> Perhaps less so than for humans :-) 
10:44:49 <qfr> cabal-install version 0.8.2 using version 1.8.0.2 of the Cabal library
10:44:57 <qfr> Even older than 1.8.0.6 hmm
10:45:08 <geheimdienst> ezyang, i think we can live with the performance loss of being woken and re-sleeping *once every 35 mins*
10:45:08 <qfr> Oh wait, I am executing the wrong Cabal, I think :P
10:45:11 <geheimdienst> :)
10:45:32 <mm_freak_> well, if you want to sleep more than 35 minutes, you usually don't need subsecond precision =)
10:45:33 <qfr> cabal-install version 0.9.5 using version 1.10.0.0 of the Cabal library
10:45:35 <qfr> Beautiful
10:45:56 <mm_freak_> so just wake up once a second and check, whether the given time has passed by asking for the current system time
10:45:58 <e32> hi, using cabal update I get 'ErrorMisc "Unsucessful HTTP code: (4,0,4)"'? Any ideas lynx 'hackage.haskell.org' brings up the page. Also using http_proxy
10:46:11 <ezyang> see also "marginal" :-) 
10:46:13 <vegai> what was the option to threadDelay that allowed sleeping for longer?
10:46:49 <ddarius> geheimdienst: You'd never make it as a C++ programmer.
10:46:57 <ddarius> Let alone an assembly programmer.
10:47:12 <geheimdienst> ddarius, true, and i'm proud of it
10:47:32 <e32> oh wait looks like a problem with the proxy even web surfing is not working. 
10:48:00 <e32> so nothing to do with haskell/caball as far as i can tell.
10:49:03 <Twey> geheimdienst: But what if your system is being used by fifteen thousand users simultaneously whilst running on an overheating 386?!
10:49:30 <gwern> vegai: move to 64-bit and get an Int which can sleep fro more than a few weeks or whatever?
10:49:53 <geheimdienst> the other day i told my boss that i don't worry about the milliseconds wasted when removing elements from an obj-c array, i worry about the http request to the web service taking 40 seconds. this seemed to be an entirely new notion to him
10:50:08 <Twey> Hahaha
10:50:57 <Baughn> Who has root acess to c.h.o at the moment? I could just send an email, but..
10:51:01 <gwern> geheimdienst: should've invoked authority and quoted Amdahl's law at him, or maybe Knuth
10:51:09 <Baughn> (My last one wasn't answered)
10:51:31 <edwardk> gah, foiled by the time package again. DiffTime is pretty close to what i want but i can't get the answer back out as an Integer
10:51:51 <ezyang> does the time package suck? My (brief) experience with it says yes. 
10:52:07 <edwardk> if it was Integral it'd work
10:52:21 <edwardk> ezyang: i was trying for once to lean on other folks packages ;)
10:52:23 <quuuux> edwardk: threadDelay $ fromInteger $ max 0 $ ceiling $ delta * (10^(6 :: Int))
10:52:24 <byorgey> "suck" is a rather strong term
10:52:31 <quuuux> edwardk: that works, apparently, in my code
10:52:45 <quuuux> where delta :: DiffTime
10:52:47 <ezyang> hahah 
10:52:47 <ezyang> toRational it first. 
10:52:50 <edwardk> ceiling in performance code makes sad
10:52:58 <ezyang> http://www.haskell.org/pipermail/haskell-cafe/2009-June/062544.html 
10:52:59 <quuuux> oh, performace? Never mind then :P
10:52:59 <byorgey> let's say the time package consists of "a maze of twisty functions, all alike"
10:53:11 * ezyang twists and shouts! 
10:53:27 <geheimdienst> gwern, you're right, appeal to authority might work on people that appeal to logic fails on
10:53:47 <gwern> ezyang: yes, the time package isn't very fun, as I found out when working on filestore
10:54:00 <gwern> geheimdienst: even better if the authority's argument is correct, as those two are
10:55:05 <ezyang> maybe we can make it better in the carte blanche coming up 
10:55:17 <ezyang> though one difficulty is I can't quite put my finger on why it is suboptimal 
10:55:37 <FauxFaux> qfr: git clone -v http://gitlulz.goeswhere.com/
10:55:49 <qfr> FauxFaux: Why? :p
10:56:04 <FauxFaux> It's a good example of a pathalogically bad git repo. :p
10:56:07 <e32> and with the correct proxy everything works just fine.
10:56:17 <qfr> the HTTP part sounds bad
10:56:25 <qfr> FauxFaux do you want me to time it? :P
10:56:42 <Twey> :t ((^), (^^), (**))
10:56:43 <lambdabot> forall a b a1 b1 a2. (Num a, Integral b, Fractional a1, Integral b1, Floating a2) => (a -> b -> a, a1 -> b1 -> a1, a2 -> a2 -> a2)
10:56:49 <FauxFaux> qfr: Feel free. Â¬_Â¬
10:57:01 <qfr> FauxFaux: It just took me 12 minutes to darcs cabal
10:57:09 <byorgey> ezyang: honestly, just improving the documentation and maybe adding a nice tutorial would improve it 500% without changing the code
10:57:14 <qfr> For uh 1.2 MiB of code and 1-2 MiB of history :(
10:57:29 <byorgey> ezyang: whenever I've used it I've always eventually managed to figure out the right way to do what I wanted, it just took a long time
10:57:36 <ezyang> Hm. I do feel that way for a lot of Hackage packages. Like Orc and QuickCheck too... 
10:57:36 <geheimdienst> i wish the time package haddock would have a list of "common stuff you might wanna do and what function ya need for it"
10:58:00 <byorgey> yes, writing documentation is hard and boring.
10:58:14 <opqdonut_> and api documentations tend to need a tutorialish counterpart
10:58:15 <byorgey> and very important.
10:58:27 <byorgey> an unfortunate combination.
10:58:28 <opqdonut_> because api documentation tends to be brief and omit examples
10:58:29 <Saizan> QuickCheck has a tutorial/manual for the 1 version, but it should mostly work for 2 too
10:58:36 <byorgey> opqdonut_: yes, I agree
10:58:41 <geheimdienst> opqdonut_: true
10:58:42 <ezyang> Saizan: That's actually really bad. 
10:58:58 <ezyang> because the last thing you want to do when learning a new package is to run into a subtle inconsistency between versions. 
10:59:03 <opqdonut_> a friend of mine says he doesn't like docstrings since they encourage brevity
10:59:12 <edwardk> i can't for the life of me find where Pico is defined in time. any ideas?
10:59:18 <opqdonut_> first by being inline and second by being right next to the implementation
10:59:25 <edwardk> (i'm hunting through sources since it doesn't seem to find its way into the public api
10:59:26 <Saizan> edwardk: Data.Fixed iirc
10:59:29 <geheimdienst> edwardk: istr it's in Data.Fixed
10:59:29 <edwardk> k
10:59:55 <geheimdienst> however that the api docs are so short and free of examples seems to be a haskell tradition. in java for example, i never had trouble learning a completely new thing from the javadocs
11:00:16 <opqdonut_> (good) javadocs tend to have a long introduction that gives examples
11:00:22 <ezyang> Though, one must admit, the average Java class does very little :-) 
11:00:27 <edwardk> hrmm, that might work nicely
11:00:37 <edwardk> pqdonut: so do good haskell packages
11:01:04 <opqdonut_> yes
11:01:05 <edwardk> its just annoying that doing so requires editing the .cabal file and rebuilding ;)
11:01:07 <edwardk> http://hackage.haskell.org/package/ad
11:01:13 <edwardk> was a pain in the butt
11:01:22 <45PABN4G5> how do i pattern match this data Car = Car { company :: String  
11:01:22 <45PABN4G5>                , model :: String  
11:01:22 <45PABN4G5>                , year :: Int  
11:01:22 <45PABN4G5>                } deriving (Show)
11:01:35 <Twey> 45PABN4G5: All of it?
11:01:56 <45PABN4G5> Twey yes
11:01:56 <Twey> f Car { company = c, model = m, year = y } = -- something using c, m, and y
11:02:15 <edwardk> foo Car c m y = â€¦  or foo Car { company = "Foo" } = ..
11:02:26 <ddarius> More parentheses.
11:02:29 <Twey> Or, with {-# LANGUAGE RecordWildcards #-} you can write f Car { .. } = -- something using company, model, and year
11:02:29 <edwardk> er foo (Car c m y) = 
11:02:36 <edwardk> the latter one is fine without though ;)
11:02:53 <Twey> edwardk: Yeah, but this seems like a record that might be modified later in development.
11:02:58 <edwardk> i keep forgetting about language wildcards
11:03:05 <Twey> That doesn't store every possible datum about a car.
11:03:07 <edwardk> er record
11:03:38 <qfr> FauxFaux: Cloning into gitlulz... real    1m49.467s
11:03:51 <qfr> 24M     gitlulz/
11:03:56 <FauxFaux> git repack -adf
11:04:02 <qfr> I already did git gc
11:04:11 <qfr> 700K    .
11:04:23 <qfr> Same after git repack -adf ;D
11:04:30 <qfr> FauxFaux what's the difference?
11:04:34 <edwardk> i rather like Data.Fixed but i kind of wish ashley didn't hide the constructor =/
11:05:16 <FauxFaux> qfr: The initial git gc should run exactly the same as git repack -adf (in that pathalogical repository); I assumed it hadn't as your size hadn't gone down after the gc.
11:05:40 <qfr> But it did, I just hadn't posted the result yet, hehe
11:07:00 <FauxFaux> I think it generated more than 700kb of access log entries, too.
11:08:19 <qfr> Haha.
11:09:35 <ddarius> Toshiya is awesome.  Just so everyone knows.
11:09:38 <45PABN4G5> Twey: ok thx, and how do I construct a Car ?
11:09:55 <ezyang> Context? 
11:10:37 <copumpkin> man, all these idiom brackets make my code so much nicer
11:10:49 <Twey> 45PABN4G5: Car { company = "Jaguar", model = "E-Type", year = 1961 }
11:11:18 <45PABN4G5> Twey: is there any better way?
11:11:29 <Twey> â€˜Betterâ€™?
11:11:39 <Saizan> @google Toshiya
11:11:40 <lambdabot> http://en.wikipedia.org/wiki/Toshiya_(musician)
11:11:40 <lambdabot> Title: Toshiya (musician) - Wikipedia, the free encyclopedia
11:11:45 <ddarius> There's no pleasing people.
11:11:51 <Twey> 45PABN4G5: You can do as edwardk did, Car "Jaguar" "E-Type" 1961, but I recommend against it because it'll break if you introduce new fields into the record later
11:12:16 <45PABN4G5> Twey: ok
11:12:17 <Twey> (that's basically ignoring the fact that it's a record and just using it as a normal data-type)
11:12:45 <edwardk> 45PABN4G5: or if you just want to access some fields, just pass it around as 'p' and access the fields with 'company p' etc as needed
11:13:04 <edwardk> that usually is better for expository purposes anyways
11:13:36 <ezyang> Suppose I have some function that has the following property "With probability of at least X, the estimate falls within Y of the true factor". How would I go about automatically testing that this property holds? 
11:13:42 <aristid> Twey: well, maybe it's good that it breaks when you add new record fields, because otherwise they are quietly initialized with bottom :)
11:13:59 <Twey> aristid: And a warning!
11:14:17 <Twey> aristid: But true
11:14:26 <monochrom> ezyang: first you need a way to compute the true factor
11:14:29 <ezyang> I could do a monte carlo simulation, but I'm not sure UI wise how to interpret things. 
11:14:36 <ddarius> If you make them strict, then it is an error to leave fields uninitialized.
11:14:43 <ezyang> monochrom: Done. 
11:14:56 <aristid> Twey: i still prefer using record syntax when there are more than two or three fields, because it's more readable :)
11:15:01 <ezyang> It might be difficult to do for large inputs, but I can definitely do it for small. 
11:15:17 <aristid> ddarius: you mean with the bang (!) stuff?
11:15:26 <ddarius> Yes.
11:15:36 <monochrom> oh god, after a monte carlo simulation, the fun begins with confidence interval etc
11:15:44 <ezyang> yeah... 
11:15:53 <monochrom> this needs a full-fledge statistics course.
11:15:55 <ddarius> Down with confidence intervals.
11:15:59 <ezyang> I mean, it would be a good learning exercise for me. 
11:16:00 <edwardk> ezyang: look up 'atlantic city algorithms' for information about programs with two sided error
11:16:04 <Twey> aristid: Rightâ€¦ records with less fields than that tend to be really obvious ones, data Point = Point { r, Î¸ :: Rational }, that are never going to need to be modified
11:16:14 <ezyang> edwardk: Sounds like fun. 
11:16:23 <monochrom> heheh monte carlo vs atlantic city
11:16:30 <ddarius> Î˜ :: Rational ?
11:16:53 * monochrom invents "las vegas approach" to refer to an approach where the house always wins
11:17:00 <edwardk> monte carlo = approximate answer, las vegas = may not work, but if it works gives the right answer, atlantic city = approximately gives the right answer
11:17:14 <edwardk> er approximately gives the answer some of the time
11:17:15 <Twey> ddarius: Has to be lower-case
11:17:26 <ddarius> monochrom: Biloxi Mississippi may still be available.
11:17:30 <edwardk> hahaha
11:17:32 <Twey> In terms of Ï€, maybe?  *shrug*
11:17:48 <edwardk> biloxi algorithms are algorithms that are unlikely to terminate before you get bored of watching them
11:18:05 <ezyang> guys guys, in case you didn't already realize, you're all awesome :-) 
11:18:06 <Twey> Haha
11:18:12 * monochrom invents "macau methodology" to mean there is some big guy like China behind
11:19:31 <geheimdienst> what is "biloxi"?
11:19:42 <gb345> does any of you what debian/ubuntu package will give me the haskell source code for Prelude, GHC.base, etc?
11:19:55 <ezyang> Hmm, there is no atlantic city algorithm wikipedia page 
11:19:58 <edwardk> http://maps.google.com/maps?hl=en&q=biloxi&um=1&ie=UTF-8&hq=&hnear=Biloxi,+MS&gl=us&ei=OQoqTZB4wvfwBpTdkJEC&sa=X&oi=geocode_result&ct=title&resnum=1&ved=0CCcQ8gEwAA
11:20:10 <ezyang> gb345: There might not be one. :-/ 
11:20:30 <edwardk> ezyang: google deeper, they may have some under BPP on wikipedia, but wikipedia doesn't seem to use the term
11:21:28 <edwardk> http://answers.google.com/answers/threadview/id/232876.html
11:21:41 <gb345> ezyang, thanks ... what's the best place to download this source from?
11:22:11 <monochrom> http://packages.ubuntu.com/source/maverick/ghc6 ?
11:23:41 <gb345> monochrom, thanks
11:24:38 <ezyang> pinkfreud's answer fails to actually synthesize the info :-/ 
11:24:44 <ezyang> Anyway, I think I've figured it out 
11:25:16 <ezyang> zero-sided error "Las Vegas", one-sided error "Monte Carlo", two-sided error "Atlantic City". 
11:25:35 <ezyang> Although zero-sided error is not quite right, because the randomness is in runtime for Las Vegas :-/ 
11:26:32 <monochrom> buggy error "Redmond" :)
11:27:35 <edwardk> you can convert a las vegas algorithm into a monte carlo one by terminating it early
11:28:26 <edwardk> the way i was first exposed to las vegas algorithms was slightly differently, by claiming that you have an algorithm that may or may not find the answer, but any answer it gives is exact. thats basically a las vegas algorithm with early termination in the forumation used by wikipedia
11:28:37 <ezyang> But not the other way around, IIUC. 
11:28:53 <ezyang> That makes sense. 
11:29:05 <edwardk> i used las vegas searches to speed up visible surface determination in my thesis dramatically
11:29:28 <ezyang> Hmm, this doesn't help me in testing for these properties, though. I wonder if the literature covers this. *searches more* 
11:29:40 <edwardk> stuff went from O(n^4) to (O(n^2 alpha(n))
11:29:53 <monochrom> I'm not sure you should test rather than prove.
11:29:53 <ezyang> sweet :-) 
11:29:59 <ezyang> Well, it's already proven. 
11:30:16 <ezyang> But proving it for my particular implementation would require embedding it in a theorem prover. 
11:30:24 <edwardk> i was just trying to point you in the direction of what literature was out there on the topic of algorithms with that kind of error
11:30:27 <ezyang> And I don't know if I even have the theories to deal with these properties :-) 
11:30:50 <ezyang> edwardk: Yeah. It's a good direction. I'm sure people have written about testing that Monte Carlo algorithms are actually Monte Carlo. 
11:32:59 <m3ga> @hoogle umask
11:32:59 <lambdabot> No results found
11:33:28 <m3ga> hmm, how do i changes a process' umask in haskell?
11:33:53 <ezyang> slightly unrelatedly, the fact that deterministic miller-rabin depends on the reimann hypothesis is kind of awesome 
11:34:00 <ezyang> m3ga: Maybe something in System.Posix? 
11:34:46 <geheimdienst> m3ga: hoogle is not very good for platform-dependent stuff. check hayoo.
11:34:49 <j-invariant> maybe I should just not use typeclasses
11:35:11 <j-invariant> they seem to cause all the problem
11:35:16 <shachaf> System.Posix.Files.setFileCreationMask
11:35:18 * aavogt wonders if it's prime-time yet
11:35:25 <Cale> j-invariant: That's something I wish people would think of more often actually ;)
11:35:35 <hpc> aavogt: no, it's fibs-time
11:35:44 <hpc> :P
11:35:45 <Cale> j-invariant: Typeclasses can be great, but plain old functional programming is still pretty good :)
11:35:56 <ezyang> Who here belives that P = RP = BPP? 
11:35:59 <ezyang> *believes 
11:36:08 <hpc> RP and BPP?
11:36:15 <hpc> oh, bounded polynomial time
11:36:17 <hpc> and...
11:36:30 <hpc> i forget the other
11:36:31 <Cale> and in a lot of cases, can be more flexible than typeclasses are
11:36:53 <m3ga> ezyang, geheimdienst : thanks
11:37:07 <Cale> RP would be randomised polynomial time
11:37:12 <hpc> oh
11:37:54 <Cale> and BPP is bounded-error probabilistic polynomial time apparently
11:38:08 <hpc> ah
11:38:50 <edwardk> hrmm, well, with a little polish, i can now say 'schedule (immediately `after` milliseconds 12) â€” which almost works grammatically ;)
11:39:34 <monochrom> you and your obsession with english grammar.
11:39:37 <edwardk> i'm not willing to go through the contortions that break ((->)n) nums to make the prettier 12 milliseconds work
11:39:48 <ezyang> Hmm. Wikipedia says that all BPP instances have Monte Carlo algorithms. I think one can state something stronger. 
11:40:06 <ghnz> I'm trying to do the 'init' function, only using foldr, but I have some trouble because the function 'f' that use foldr should return a string.
11:40:20 <edwardk> ezyang: sipser has a pretty long second on BPP, etc. if i recall correctly
11:40:26 <edwardk> er section
11:40:38 <monochrom> http://thread.gmane.org/gmane.comp.lang.haskell.cafe/44886/focus=44899
11:40:43 <ezyang> edwardk: Unfortuantely, I don't have my copy with me :-) 
11:40:50 <ghnz> I thought about haveing ['a','b','c'] and then attaching some, ['a','b','c', []], and then play, but its awfull
11:40:51 <Cale> I don't have enough intuition or knowledge about what these complexity classes really contain to say whether I believe they're equal or not.
11:41:03 <ezyang> Dammit, I've studied this. Mostly all I remember is how to do amplification. 
11:41:25 <ezyang> Ah, I see. Some people use Monte Carlo to describe both one-sided errors and two-sided errors. 
11:41:33 <edwardk> yeah, the names are a bit overloaded
11:41:56 <edwardk> metropolis came up with the whole class of them, and just called them monte carlo
11:42:10 <hpc> ghnz: your second bit of code is not possible
11:42:10 <edwardk> well, metropolis, von neumann, and ulam
11:42:20 <hpc> [] and 'a' are different types
11:42:34 <aavogt> > let milliseconds = (*1000) in (12 `milliseconds`)
11:42:35 <lambdabot>   12000
11:42:42 <ghnz> hpc, right, i'm screwed :P
11:43:17 <ddarius> edwardk: You look at "Composing Contracts" recently?
11:43:50 <edwardk> yeah, i went and rewrote it with generic numeric types, and with the observables replaced with applicatives, etc.
11:44:08 <edwardk> the former because i wanted to apply automatic differentiation, the latter because it cleans up the code
11:44:12 <ezyang> haha, http://www.iiap.res.in/astrostat/School07/R/MCMC.html does testing with R. Which might actually be the right thing, to be honest. 
11:44:34 <edwardk> note: MCMC is a different beast =)
11:44:51 <ezyang> oh hey, that's funny. 
11:44:53 <edwardk> well, a more refined beast
11:45:25 <ezyang> Ok. I think plan of attack will be to write a testing jig that gives me some raw data and then figure out what to do with that next. 
11:45:28 <ghnz> This is an exercise from "The craft of Functional Programming"... any ideas? Or where to find the solutions :S
11:45:37 <edwardk> its an example of a metropolis hastings algorithm, which is basically saying you can take a lot of monte carlo algorithms and sample the space non-uniformly and get answers faster
11:46:06 <monochrom> @src init
11:46:07 <lambdabot> init [x]    = []
11:46:07 <lambdabot> init (x:xs) = x : init xs
11:46:07 <lambdabot> init []     = undefined
11:46:19 <ezyang> ghnz: You might have to do something funny with lambdas. 
11:46:29 <ezyang> I'm not sure what the real formulation of the problem is. 
11:46:38 <monochrom> the look-ahead is funny
11:46:45 <ghnz> Give a definition of init, with foldr.
11:46:58 <edwardk> other examples of metropolis hastings are techniques such as metropolis light transport, and the UCT algorithm used to play go.
11:47:12 <ezyang> ghnz: Ok. What's your zero? 
11:47:18 * ddarius needs to implement MLT.
11:47:21 <edwardk> (or to win the latest google ai challenge)
11:47:34 <ghnz> ezyang: What do you mean?
11:47:50 <edwardk> MLT isn't bad to implement. i have a copy of brigade carved up with a metropolis light transport core mostly integrated
11:47:50 <monochrom> @type foldr 
11:47:52 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
11:48:09 <ghnz> Assume the list is never empty...
11:48:14 <ghnz> I want to know the big idea
11:48:17 <edwardk> there is a nice introductory paper, let me find it
11:48:24 <monochrom> > foldr (\x ys -> if null ys then [] else x:ys) [] [1,2,3,4]
11:48:25 <lambdabot>   []
11:48:48 <ddarius> edwardk: I've read several papers/theses on MLT.
11:48:49 <monochrom> oh haha
11:49:05 <edwardk> ah k
11:49:08 <tolkad> > try $ return $ throw IOException :: IO (Either IOException ())
11:49:09 <lambdabot>   Not in scope: type constructor or class `IOException'Not in scope: `try'Not...
11:49:18 <Twey> foldr is not really suited to initâ€¦
11:49:31 <hpc> :t init
11:49:33 <lambdabot> forall a. [a] -> [a]
11:49:33 <edwardk> i implemented it off of the original veach/guipas paper when it came out
11:49:33 <tolkad> will that work?
11:49:38 <ghnz> Twey, I know, but its an exercise from the book.
11:49:47 <tolkad> how do I ensure an exception thrown within purely functional code gets caught?
11:49:53 <Twey> Well, I suppose you could take the length of the list and use that to determine when to stop?
11:49:57 <ezyang> ghnz: If you're doing a right  fold, you must have a zero/nil element. 
11:49:58 <Twey> Inefficient, but hey
11:49:59 <edwardk> tolkad: by not throwing it ;)
11:50:02 <ddarius> edwardk: It looks easy enough.  Just a little tedious in parts and easy to screw up.
11:50:06 <edwardk> yeah
11:50:07 <hpc> tolkad: pray
11:50:11 <monochrom> tolkad: Control.Exception.evaluate
11:50:13 <hpc> and yeah, don't throw it
11:50:19 <j-invariant> easy to screw up <--- but the type system doesn thel?
11:50:21 <Twey> :t foldr
11:50:23 <hpc> pure exceptions are high bullshit
11:50:23 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
11:50:26 <edwardk> its easy to start with a bidirectional path tracer and add it though
11:50:40 <tolkad> hpc: What else am I supposed to do? wrap the whole thing in a big maybe and lose laziness?
11:50:58 <ghnz> ezyang: I don't want to mess with details, suppose I want to use foldr1 instead of foldr.
11:50:58 <edwardk> there are some non-standard optimizations i like to use as well, involving batch-parallelism
11:51:02 <hpc> how would you lose laziness?
11:51:02 <tolkad> hpc: or break it up into tiny chunks of data that make no semantic sense?
11:51:06 <ezyang> Whee, I find out so many interesting things from #haskell, but it takes me several months before I work up the prerequisite knowledge to understand what was working on. 
11:51:26 <ezyang> ghnz: Ok, so what does your function do with [1,2]? 
11:51:37 <edwardk> oh, ddarius, did you see https://github.com/ekmett/reactor/tree/master/Reactor ?
11:51:45 <ghnz> ezyang, oh Im sorry. Its for Strings :$
11:51:50 <ddarius> edwardk: No.  Where should I go eat?
11:51:56 <ezyang> sure. What does your function do for "ab"? 
11:51:58 <tolkad> hpc: because it has to run the whole thunk so it can pattern match for Just/Nothing
11:52:02 <edwardk> we should go get food and discuss/hack on it ;)
11:52:15 <ezyang> ddarius: You're in Boston right now? 
11:52:18 <ghnz> ezyang, I guess we cans say that is [1] anyway. 
11:52:39 <monochrom> I think it's fairly clear "I want evaluation postponed" and "I want exceptions early" are contradictory.
11:52:40 <ezyang> ghnz: Hm? I don't understand. 
11:52:42 <edwardk> i lured him out with the promise of working with me, and then switched jobs the day before he started
11:52:53 <ezyang> Hahaha 
11:52:57 <tolkad> hpc: Wait, Exception.evaluate will do that anyway
11:52:57 <hpc> tolkad: if it is lazy, the exception could happen anywhere though; you don't know where it will actually get evaluated
11:53:07 <hpc> and that
11:53:19 <hpc> find another way, or sacrifice some aspect of your ideal
11:53:25 <tolkad> so how do I keep laziness and at the same time allow myself to abort?
11:53:25 <ghnz> ezyang, init "Hello" is "Hell". init of "OOOOa" is "OOOO". init [1,2,3] is [1,2]
11:53:29 <shachaf> Doesn't ddarius live in Boston?
11:53:45 <aavogt> > let init = snd . foldr (\a (b,x) -> if b then (False,x) else (False,a:x)) (True,[]) in init "hello"
11:53:47 <lambdabot>   "hell"
11:53:47 <j-invariant> tolkad: what is "layzness"?
11:53:58 <tolkad> hpc: hmm, actually I think I just have to move the exception catching out of the library code and into wherever I actually try to walk through the data structure
11:54:13 <monochrom> how do you  keep laziness and at the same time allow yourself to abort? by slapping yourself without slapping yourself. yes I'm saying it's contradictory.
11:54:41 <hpc> how is your code "lazy", too?
11:54:48 <hpc> you can "abort" a lazy string with []
11:55:02 <aavogt> you can probably do the tuple as an additional argument to foldr (ie. b is actually a type containing ->)
11:55:03 <ghnz> aavogt, that's insane
11:55:06 <geheimdienst> monochrom: it's the sound of one hand slapping
11:55:07 <tolkad> j-invariant: when a thunk can be strictly pattern-matched on without being fully evaluated
11:55:08 <ddarius> ezyang, shachaf: I've been in the Greater Boston area for about four monhs.
11:55:10 <ezyang> ghnz: Not really. 
11:55:26 <ezyang> ddarius: Ah, so I haven't been around. We should meet up when I get back in town. 
11:55:36 <monochrom> I understand it is sometimes hard to emotionally accept that two requests, each innocent-sounding alone, combine to an impossibility.
11:55:36 <aavogt> > let init = snd . foldr (\a (b,x) -> if b then (False,x) else (False,a:x)) (True,[]) in init (cycle "hello")
11:55:38 <lambdabot>   "*Exception: stack overflow
11:55:46 <aavogt> > init (cycle "hello")
11:55:47 <lambdabot>   "hellohellohellohellohellohellohellohellohellohellohellohellohellohellohell...
11:55:59 <aavogt> ghnz: ^^ my version isn't equivalent to the real init
11:56:05 <shachaf> Everyone is in Boston. :-(
11:56:06 <hpc> @src init
11:56:06 <lambdabot> init [x]    = []
11:56:07 <lambdabot> init (x:xs) = x : init xs
11:56:07 <lambdabot> init []     = undefined
11:56:10 * ezyang idly wonders if it's possible to do it without threading that extra arg 
11:56:11 <j-invariant> tolkad: so instead of  data List = Cons a (List a)   you need to use   data List a = Cons a (Either Error (List a))  then
11:56:18 <b0fh_ua> guys, how to convert strict bytestring into Int?
11:56:31 <monochrom> @hoogle ByteString->Int
11:56:32 <lambdabot> Data.ByteString length :: ByteString -> Int
11:56:32 <aavogt> length b0fh_ua
11:56:32 <lambdabot> Data.ByteString.Char8 length :: ByteString -> Int
11:56:32 <lambdabot> Data.ByteString count :: Word8 -> ByteString -> Int
11:56:35 <monochrom> length
11:56:38 <shachaf> const 0
11:56:55 <hpc> 5
11:56:58 <monochrom> and count too, more general
11:56:59 <j-invariant> unsafeCoerce
11:56:59 <hpc> > 5 undefined
11:57:00 <lambdabot>   5
11:57:02 <shachaf> ord . head
11:57:07 <tolkad> monochrom: I think I just need to talk to someone about this, it's just so painful
11:57:07 <b0fh_ua> well, I have 4 bytes, little-endian, and I want to get it as Int
11:57:22 <hpc> instance Num ByteString where
11:57:23 <aristid> @hoogle ByteString->Word
11:57:24 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
11:57:24 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
11:57:24 <lambdabot> Data.ByteString foldl :: (a -> Word8 -> a) -> a -> ByteString -> a
11:57:24 <aavogt> @hackage binary
11:57:24 <lambdabot> http://hackage.haskell.org/package/binary
11:57:25 <edwardk> wow. someone got bored: http://hackage.haskell.org/package/base-unicode-symbols-0.2.1.1
11:57:45 <aristid> edwardk: says the author of category-extras :P
11:57:54 <edwardk> aristid: hahahaha
11:58:08 <monochrom> talking is a great way to cure emotional delusions, yes
11:58:12 <ghnz> The next exercise was simulate the 'last' function with foldr, that was easy: foldr1 (\a b -> b)  str ... so I guess that if the previous was simulate 'init' cant be so difficult. :S
11:58:35 <Twey> Oh, hm, it's quite nice with a Maybe.
11:58:44 <ddarius> edwardk: I'm looking at the Boston HUG mailing list, and noticed a (planned) dinner on the 3rd of December.  Did that happen and did Adam end up coming?
11:58:49 <Twey> I guess you could use a pair with Bool or something instead if Maybe isn't allowed.
11:58:54 <edwardk> yeah
11:59:01 <gb345> how come (,) , (,,) , (,,,) , etc. are not Functors?
11:59:04 <edwardk> speaking of which i need to schedule the next one, it'll be the 19th iirc
11:59:13 <aavogt> gb345: you have not imported the instance?
11:59:18 <edwardk> gb: ((,)a) is
11:59:21 <Twey> > let init' = fromJust . foldr (fmap Just . maybe [] . (:)) Nothing in init' "abcde"
11:59:22 <lambdabot>   "abcd"
11:59:27 <j-invariant> gb345: they would have to be bifunctor, trifunction, quartfunctor
11:59:51 <Twey> Quadfunctor?
11:59:53 <ddarius> I guess I should subscribe to that mailing list at some point...
11:59:55 <Twey> Tetrafunctor?
12:00:02 <ezyang> There are totally bifunctors :-) 
12:00:04 <geheimdienst> > fmap succ (3,7)
12:00:04 <lambdabot>   (3,8)
12:00:13 <aavogt> > succ (3,7)
12:00:13 <Twey> fmap = second
12:00:13 <lambdabot>   No instance for (GHC.Enum.Enum (t, t1))
12:00:14 <lambdabot>    arising from a use of `e_137' at...
12:00:19 <monochrom> I don't like (Ã·) = (/). I want (Ã·) = div
12:00:27 <aavogt> you'd think \bot would have that
12:00:31 <aavogt> > 1 + (3,7)
12:00:31 <lambdabot>   (4,8)
12:00:34 <gb345> ok , it's just that list and tuple seem kinda similar and list is a functor so...
12:00:41 <Twey> aavogt: I'm glad she doesn't :Ã¾
12:00:52 <Twey> gb345: Lists and tuples are not at all similar
12:00:54 <ezyang> gb345: Ah, that's definitely an important distinction to understand. 
12:01:30 <ddarius> edwardk: I see that package doesn't define Âµ and Î· for Monad though.
12:01:42 <edwardk> ddarius: you should email the maintainer ;)
12:01:55 <monochrom> yeah!
12:01:57 <gb345> Twey,ezyang: that's quite surprising...
12:02:22 <monochrom> you should fork it and submit canonical-base-unicode-symbols
12:02:52 <Twey> gb345: Surprising if you think of it in terms of values, but perfectly obvious in terms of types
12:02:53 <monochrom> tuple: (True, 'x') is possible. list: [True, 'x'] is impossible.
12:03:02 <gb345> oh, ok, i think i get it...
12:03:15 <hpc> also, you can do [1..] but not (1..)
12:03:19 <gb345> thanks!
12:03:22 <monochrom> of course in untyped languages there is no need to distinguish them
12:03:33 <ezyang> Is there some paper or book I can read about generating random distributions of data structures? 
12:03:41 <hpc> untyped languages are also pure evil :P
12:03:47 <R3van> how to check if a funktion returns an error..... so i whant to write a function wich is checking wether another function throws a error
12:03:53 <ddarius> ezyang: Yes.
12:04:05 <edwardk> ezyang: i think byorgey talked about it in a video that he posted on vimeo somewhere
12:04:06 <monochrom> untyped languages are for people with IQ 200 who don't ever make mistakes
12:04:07 <ezyang> R3van: You can do so in the IO monad using Control.Exception.catch 
12:04:13 <j-invariant> hpc: untyped language aer to haskell as haskell is to theorem prover languages
12:04:14 <aavogt> @hackage spoon
12:04:15 <lambdabot> http://hackage.haskell.org/package/spoon
12:04:15 <ddarius> ezyang: Actualyl, byorgey has something about that with regards to species.
12:04:20 <geheimdienst> i can see how (âˆˆ) = elem and (âˆ‰) = notElem might be useful
12:04:20 <hpc> j-invariant: haha, touche
12:04:30 <edwardk> yeah, thats the talk
12:04:32 <ezyang> species may be a little fancier than I need. 
12:04:33 <ddarius> edwardk: Unless there is another video, I think he only mentions it in the video.
12:04:34 <geheimdienst> the rest of that package seems to be a gimmick
12:04:37 <aristid> monochrom: wouldn't something like [forall a. Show a => a] be theoretically possible, too?
12:04:38 <hpc> monochrom: or the people with IQ 50 who wouldn't get their code to compile otherwise
12:04:44 <ddarius> ezyang: Yes, but all your types are species so it will work.
12:04:45 <ezyang> hmm 
12:04:50 <ezyang> yeah. 
12:05:03 <j-invariant> hpc: I tried to progrma in scheme but it was like not having a saftey net - I tried programming in Coq but I couldnt' do the proofs... I wish I would say "Haskell is just right" now but I can't use that either:/
12:05:06 <aavogt> aristid: gaah, impredicative!
12:05:30 <ddarius> j-invariant: Become a carpenter.
12:05:36 <aristid> aavogt: is that what "impredicative" means? i heard the word a few times, but no idea what it means :)
12:05:43 <aavogt> :P
12:05:48 <monochrom> [forall a. Show a => a] would be fine if we gave up type inference
12:05:48 <j-invariant> ddarius: I value my thumbs too much for that
12:05:58 <hpc> j-invariant: the obvious solution is C++
12:06:01 <j-invariant> plus I never really liked carpets
12:06:01 <ezyang> huh, I can't find a link to the talk 
12:06:03 <hpc> it's the worst of all three!
12:06:33 <aristid> monochrom: there are lots of other extensions that also don't really work with type inference
12:06:43 <shachaf> j-invariant: Don't worry. A carpenter deals with carpents.
12:06:54 <j-invariant> LOL
12:06:58 <geheimdienst> *carpets
12:07:03 <ezyang> I can find his diagrams talk and his FringeDC talk 
12:07:32 <Twey> gb345: Tuples are what you use when you know the type and number of all the elements at compile time: they're a convenient way to make ad-hoc types, if you like
12:08:42 <Twey> gb345: Lists are what you use when you want an ordered sequence of zero or more (unknown at compile time) values of the same type
12:08:56 <aavogt> yeah, who needs Data when you've got  Either, (,) and Mu!
12:09:09 <ddarius> aavogt: Don't forget (->)
12:09:09 <tolkad> so what are exceptions in pure code supposed to be used for? I decided not to use them
12:09:10 <Twey> Heheh
12:09:13 <R3van> ezyang: iam not sure how to deal with it 
12:09:24 <Twey> tolkad: Giving nicer error messages that pattern-match failures :Ã¾
12:09:26 <Twey> than**
12:09:36 <ezyang> R3van: how so? 
12:09:36 <ddarius> Twey: Not really in many cases...
12:09:42 <hpc> also for hiding line numbers, because people are evil like that
12:09:43 <aristid> :k Mu
12:09:43 <Twey> ddarius: Annoyingly :-\
12:09:44 <lambdabot> (* -> *) -> *
12:09:46 <aavogt> tolkad: laziness
12:09:54 <ezyang> ah, found it. 
12:09:55 <aristid> :k Mu ((,) Int)
12:09:57 <lambdabot> *
12:10:00 <gb345> :t 1
12:10:00 <monochrom> Either X (Either Y Z) has one more habitant than data XYZ = X X | Y Y | Z Z. This is why I still need data.
12:10:01 <hpc> aavogt: in the programmer sense of the word, of course
12:10:01 <lambdabot> forall t. (Num t) => t
12:10:02 <Twey> The convention is that they're used for cases that should never occur and indicate programmer error
12:10:05 <aristid> :t undefined :: Mu ((,) Int)
12:10:07 <lambdabot> Mu ((,) Int)
12:10:09 <aristid> :t In
12:10:11 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
12:10:29 <ShaneHudson> Hi all.. I am brand new to functional programming and about to start haskell for the first time so decided best to open up this channel! haha
12:10:29 <aristid> so, how to construct a value of Mu ((,) Int)?
12:10:34 <gb345> :t ((,) a)
12:10:34 <lambdabot> forall b. b -> (Expr, b)
12:10:44 <ddarius> monochrom: So that you can define data Either' a b = Left' a | Right' !b
12:10:47 <hpc> aristid: magic
12:10:55 <R3van> ezyang: i use error not exception (sry for that) and i want to check out wether my called function used error or returned normaly
12:10:57 <aristid> hpc: show me the magic!
12:11:12 <c_wraith> > fix $ In . flip (,) 5
12:11:13 <lambdabot>   Occurs check: cannot construct the infinite type: f = (,) (L.Mu f)
12:11:16 <ezyang> R3van: error turns into an exception. 
12:11:19 <hpc> muTuple x = Mu x muTuple
12:11:24 <hpc> er
12:11:26 <aristid> :t In ((,) 1)
12:11:27 <lambdabot>     Couldn't match expected type `Mu ((->) b)'
12:11:27 <lambdabot>            against inferred type `(t, b)'
12:11:27 <lambdabot>       Expected type: b -> Mu ((->) b)
12:11:28 <hpc> muTuple x = Mu x (muTuple x)
12:11:31 <aristid> :t In . ((,) 1)
12:11:32 <lambdabot> forall t. (Num t) => Mu ((,) t) -> Mu ((,) t)
12:11:33 <hpc> or something like that, perhaps
12:11:37 <aristid> :t fix $ In . ((,) 1)
12:11:38 <lambdabot> forall t. (Num t) => Mu ((,) t)
12:11:41 <Twey> R3van: If you have to check for it, you probably shouldn't be using â€˜errorâ€™
12:11:44 <aristid> \o/
12:11:47 <aavogt> > foldr (\hd tl -> Mu (hd,tl)) undefined [1,2,3] :: Mu ((,) Int)
12:11:48 <lambdabot>   Not in scope: data constructor `Mu'
12:11:52 <gb345> how can i get ghci not barf at ":t ((,) a)" ?
12:11:55 <aavogt> > foldr (\hd tl -> In (hd,tl)) undefined [1,2,3] :: Mu ((,) Int)
12:11:56 <lambdabot>   In (1,In (2,In (3,In *Exception: Prelude.undefined
12:12:00 <Twey> Use a type that encompasses the failure, like Maybe or Either
12:12:01 <aristid> so with Mu and (,) i can construct a Stream?
12:12:05 <R3van> ezyang: well so i tried to catch (myfunction x s).... but how to deal with it 
12:12:11 <aristid> aavogt: yay \o/
12:12:23 <ddarius> Mu ((,) t) is the type of streams.
12:12:39 <ezyang> R3van: "deal with it" is terribly vague. Can you be more precise and/or post code? 
12:12:40 <jonkri> does haskell have something similar to erlang's spawn, a way to create a new extremely light and effective thread
12:12:49 <ezyang> forkIO 
12:12:53 <aristid> ddarius: and with Either we can make lists too?
12:13:10 <aristid> hmm, Maybe should suffice
12:13:14 <ezyang> That would result in an infinite type. But we can do it with Mu. 
12:13:26 <aristid> ezyang: yeah, i mean with Mu of course
12:13:30 <ddarius> But then you need type constructor composition.
12:13:39 <ddarius> In general.
12:13:50 <aristid> so it doesn't work with haskell98?
12:14:28 <R3van> ezyang: i use a function like     myfunction:: param1 param2 -> Bool
12:14:28 <R3van> myfunction p1 p2  = mycalledFunction p1 p2   (i want to check wether my called function throws an error or not... and return True when everything is ok and False when error was thrown) 
12:14:38 <ddarius> aristid: It works fine, you just need to define a compose type constructor.
12:14:51 <gb345> does any of you know how can i get ghci not barf at ":t ((,) a)" ?  it whines about "<interactive>:1:1: parse error on in put `('"
12:14:52 <aristid> ddarius: OK
12:15:01 <ddarius> It gets uglier and uglier, but if you cared about that you'd be using data.
12:15:18 <ezyang> R3van: Ok, and what's the problem with using Control.Exception.catch? 
12:15:19 <hpc> gb: you want :k
12:15:31 <hpc> :t is for expressions, and ((,) a) is a type
12:15:32 <lambdabot> parse error on input `,'
12:15:36 <monochrom> probably because mycalledFunction is not IO
12:15:43 <R3van> ezyang: i dont know how to use...
12:15:46 <ddarius> hpc: ((,) a) is also an expression, albeit a is unbound.
12:15:54 <ddarius> :t ((,) a)
12:15:55 <lambdabot> forall b. b -> (Expr, b)
12:15:58 <gb345> hpc: it barfs at that too: "<interactive>:1:5: Not in scope: type variable `a'"
12:16:01 * hackagebot cgen 0.0.3 - generates Haskell bindings and C wrappers for C++ libraries  http://hackage.haskell.org/package/cgen-0.0.3 (AnttiSalonen)
12:16:30 <monochrom> the real question is why would mycalledFunction throw error, and if it must, why not do it some other way without error?
12:16:33 <aavogt> :t \a -> ((,) a)
12:16:34 <lambdabot> forall a b. a -> b -> (a, b)
12:16:42 <ddarius> :t curry id
12:16:43 <lambdabot> forall a b. a -> b -> (a, b)
12:16:48 <aavogt> :t ((,) ?a)
12:16:48 <lambdabot> forall a b. (?a::a) => b -> (a, b)
12:16:52 <ezyang> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Exception.html#5 
12:17:02 * hackagebot hogre 0.1.2 - Haskell binding to a subset of OGRE  http://hackage.haskell.org/package/hogre-0.1.2 (AnttiSalonen)
12:17:13 <hpc> :t curry ?id
12:17:14 <lambdabot> forall a b c. (?id::(a, b) -> c) => a -> b -> c
12:17:18 <gb345> lambdabot acctpts it, but not ghci
12:17:46 <aristid> gb345: accepts what?
12:17:49 <ddarius> gb345: Since lambdabot basically just calls GHCi, I'm pretty sure you're doing something wrong.
12:17:50 <monochrom> personally if someone asks "why do you want to catch error" and your answer is "because I have a function that throws error" you're just begging the question.
12:17:56 <gb345> ...i mean ":t ((,) a)"
12:18:05 <parcs> gb345: lambdabot is a souped up ghci
12:18:09 <aristid> gb345: use :k
12:18:12 <aristid> :k ((,) a)
12:18:13 <lambdabot> Not in scope: type variable `a'
12:18:17 <gb345> ddarius, i know, i just can't figure out what...
12:18:19 <aristid> lambdabot: what?
12:18:24 <aristid> :k forall a. ((,) a)
12:18:25 <lambdabot>     `(,) a' is not applied to enough type arguments
12:18:26 <lambdabot>     Expected kind `*', but `(,) a' has kind `* -> *'
12:18:26 <lambdabot>     In the type `forall a. (,) a'
12:18:27 <hpc> o.O
12:18:31 <ddarius> :k ((,) Int)
12:18:32 <lambdabot> * -> *
12:18:52 <ddarius> :t ((,) 3)
12:18:53 <lambdabot> forall t b. (Num t) => b -> (t, b)
12:18:56 <hpc> :k forall a :: *. ((,) a)
12:18:57 <lambdabot> parse error on input `::'
12:19:04 <ddarius> hpc: The body of a forall needs to be a type.
12:19:06 <aristid> so :k needs monomorphic types?
12:19:21 <hpc> :k forall (a :: *). ((,) a)
12:19:22 <lambdabot>     `(,) a' is not applied to enough type arguments
12:19:22 <lambdabot>     Expected kind `*', but `(,) a' has kind `* -> *'
12:19:22 <lambdabot>     In the type `forall a. (,) a'
12:19:30 <hpc> ddarius: yeah, that was a kind signature
12:19:31 <ddarius> ((,) a) is not a type.
12:19:35 <gb345> ok, it took ":k ((,) Int)"
12:19:37 <aristid> :k (,) a a
12:19:38 <lambdabot> Not in scope: type variable `a'
12:19:38 <lambdabot> Not in scope: type variable `a'
12:19:43 <aristid> :k (a, a)
12:19:44 <lambdabot> Not in scope: type variable `a'
12:19:45 <lambdabot> Not in scope: type variable `a'
12:19:50 <aristid> :k forall a. (a, a)
12:19:51 <lambdabot> *
12:19:54 <aristid> wtf
12:20:00 <ddarius> (a, a) is a type.
12:20:01 <aristid> :k (,) Int
12:20:02 <lambdabot> * -> *
12:20:05 <ddarius> It has kind *
12:20:14 <hpc> :k forall a. (,) a
12:20:15 <lambdabot>     `(,) a' is not applied to enough type arguments
12:20:15 <lambdabot>     Expected kind `*', but `(,) a' has kind `* -> *'
12:20:15 <lambdabot>     In the type `forall a. (,) a'
12:20:16 <aristid> ddarius: (,) Int is a type too, but with kind * -> *
12:20:18 <ddarius> ((,) a) isn't a type.  It has kind * -> * and thus it can't be in the body of a forall.
12:20:34 <hpc> bleh
12:20:34 <ddarius> aristid: Again, -forall- needs the body to be a type.  It has nothing to do with :k.
12:20:44 <aristid> hmm
12:20:57 <hpc> ddarius: you mean concrete type
12:21:07 <ddarius> hpc: No.
12:21:20 <ddarius> I mean something of kind * as the error messages states.
12:21:24 <aristid> ddarius: i didn't understand until now that with "body" you meant "body of the forall"
12:21:43 <ddarius> aristid: "body of a forall" is exactly what I said.
12:21:45 * hpc is too tired to think about this
12:21:47 <monochrom> oh, not this again. some of us say that "type" is reserved for things of kind *. some of use say no.
12:22:11 <aristid> ddarius: it just didn't click, sorry
12:22:13 <ddarius> monochrom: And the people who say "no" are wrong.
12:22:29 <monochrom> I used to say that "type" is reserved for things of kind *. Then someone pointed me to the haskell report.
12:22:35 <hpc> a type constructor is itself a type, in the same way a value constructor is itself a value
12:22:37 <ezyang> Hmm. Now I'm getting a little confused about how I want my random input generation to work. 
12:22:56 <ezyang> ... Oh. 
12:23:16 <ezyang> I don't need fancy species stuff. I just need to generate distributions on discrete numbers. 
12:23:20 <ezyang> *sets 
12:23:25 <monochrom> So outside #haskell I'll work with whatever definition you like, but inside #haskell I'll stick to how the haskell report uses words.
12:23:31 <ezyang> well, it's species but really really trivial 
12:23:47 <monochrom> Moreover the correct spelling is "type class" not "typeclass".
12:23:54 <ddarius> monochrom: Damn straight.
12:24:06 <aristid> monochrom: that means you'll have a bitchfight with ddarius over whether (,) is a type
12:24:10 <aristid> :k (,)
12:24:11 <ddarius> Are people going to say "typeconstructorclass" when they want to disambiguate?
12:24:11 <lambdabot> * -> * -> *
12:24:44 <monochrom> "The IO type serves as a tag for operations (actions) that interact with the outside world. The IO type is abstract: no constructors are visible to the user. IO is an instance of the Monad and Functor classes." basically nails it.
12:25:00 <gb345> ok, is there some symbol that stands for "any type", so that i can write :k ((,) anytype) and get back ((,) anytype) :: * -> * ?
12:25:09 <Zao> monochrom: What arity does a function have? :D
12:25:12 <monochrom> http://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1240006.1.7
12:25:17 <aristid> monochrom: i think that's pretty lax language in the report. of course IO has no constructors, it doesn't have kind *
12:25:20 <monochrom> @quote 17-ary
12:25:20 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
12:25:39 <ddarius> gb345: No, but it doesn't really matter for that.  Just use any type you feel like, such as Int or ().
12:25:56 <aristid> or 1
12:25:59 <gb345> bummer...  ok thanks!
12:26:13 <monochrom> oh maybe you like "The Maybe type is an instance of classes Functor, Monad, and MonadPlus."?
12:26:40 <monochrom> it doesn't quite matter that IO is abstract or not, does it?
12:27:39 * ddarius will now use "type constructor of kind *" from now on, though people complain about that too.
12:27:55 <hpc> ddarius: only because it is verbose as balls
12:27:59 <edwardk> hrmm, with ghc integers, are all integers that are represented by J# larger than an Int# or is it just an overflow case that once started remains infectious across operations
12:28:03 <hpc> have fun using it though
12:28:05 <monochrom> "Maybe and IO are unary type constructors, and treated as types with kind âˆ—â†’âˆ—" http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-650004.1.2
12:29:04 <c_wraith> edwardk: not all numbers represented by J# are larger than Int#.  It depends on how the numbers were generated.
12:29:11 <edwardk> ddarius: saturated types are what i usually call them, or inhabited type to indicate that you have terms that have that type
12:29:19 <edwardk> c_wraith: thats what i was afraid of, thanks =)
12:33:34 <Eelis> are people working on fixing the currently-broken category-extras package? i'm getting the same errors indicated in the build failure log on hackage
12:33:53 <edwardk> eelis: probably because the base requirement is capped too low
12:33:58 <edwardk> eelis: i'll take a look at it
12:34:04 <Eelis> edwardk: thanks :)
12:34:11 <monochrom> bump bump bump!
12:34:16 <edwardk> eelis: if you are looking for something in particular out of it, parts have been split off into other packages
12:34:42 <Eelis> edwardk: i was installing some other packages which pulled it in
12:34:46 <edwardk> ah
12:34:50 <edwardk> what package?
12:35:00 <edwardk> i'm curious to see what they use and if i can fix the dependency
12:35:11 <Eelis> hm, let me see
12:35:22 <Eelis> NonEmptyList
12:35:45 <edwardk> ah, yeah that one i should definitely talk to the author about, its probably just using comonad, which now has a tiny little haskell 98 friendly package
12:36:30 <ddarius> edwardk: base<10  If it's good enough for dons, it's good enough for you.
12:37:33 <edwardk> ugh, NonEmptyList has a few other issues, because it currently requires the Semigroups module which conflicts with semigroup
12:37:53 <Eelis> edwardk: (and before you ask: although i'm listed as author for NonEmptyList, it's not my package. i just submitted a patch or two some time ago :) )
12:37:59 <Eelis> *coauthor
12:38:37 * ddarius thinks he'll try to find a Wendy's.
12:38:47 <edwardk> let me see if i can download it and put together a patch to make it use the new comonad/functor-apply stuff
12:38:52 <joe6_> i am doing a diff between the contents of the same data structure. I am thinking of using prettyprint and all that. I am curious if there is a "diff --color" library in haskell..
12:39:01 <Eelis> edwardk: that would be great, thanks!
12:40:00 <edwardk> its missing upper bounds on all of the dependencies, etc. this looks like it'll be a bit more involved
12:40:26 <gb345> :i (->)
12:40:39 <monochrom> there is no :i
12:40:44 <rumbold> k = k*2 <-i have this in a where. shouldnt that give me an error?
12:40:57 <gb345> monochrome: thanks
12:41:00 <rumbold> (it compiles)
12:41:10 <monochrom> runtime error only
12:41:18 <ghnz> Ok, I had an idea that works but have some problem... i  need some kind of special symbol. http://pastebin.com/jdBK0fJX
12:41:23 <edwardk> eelis: i was putting together a streams package with a number of stream comonads, one of them is a non empty list like this, what package uses nonemptylist?
12:41:45 <edwardk> maybe its easier for me to fix it one step upstream ;)
12:41:45 <Eelis> edwardk: i use NonEmptyList in my own code :)
12:41:46 <Saizan> > let ones = 1 : ones in ones -- lazyness makes this useful
12:41:47 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
12:41:57 <gb345> :k (->)
12:41:58 <lambdabot> ?? -> ? -> *
12:42:09 <edwardk> eelis: ah, so if i gave you a nice stream package build off of comonad/functor-apply you'd be unblocked?
12:42:12 <gb345> what are those ?? and ?, never saw them before...
12:42:32 <ddarius> gb345: They are GHC things.
12:42:34 <edwardk> gb345: they allow -> to pass around unboxed types
12:42:45 <ddarius> You can treat them as * for pretty much all purposes.
12:42:48 <Eelis> edwardk: well, i don't know anything about "stream" stuff. but if you have a package that does everything NonEmptyList does, but better, then i can switch no problem :)
12:42:58 <edwardk> it says you can also accept unboxed values, and return *, #, or (#)
12:43:00 <gb345> ok, thanks
12:43:34 <gb345> somehow i can't find the part of the ghci documentation where all these things are defined...
12:43:40 <edwardk> eelis: i'll put down reactor for a while and flip back to hacking on my comonads, then. it may take a bit, i'm not done packaging it
12:43:48 <gb345> i mean the ?, ??, #, etc.
12:44:00 <Eelis> edwardk: ok, no real hurry. i've got other things to hack on :)
12:44:06 <ddarius> I don't think that is covered in the user's guide, though maybe in the section on unboxing?
12:44:12 <ddarius> It is covered in the GHC commentary.
12:44:13 <edwardk> k
12:44:31 <ddarius> gb345: But, like I said, you can pretty much completely ignore them.
12:45:03 <gb345> ddarius: it's a more general concern: at this point i'm too lost to know what i can ignore
12:45:42 <ghnz> Anyone?, i refresh the problem: Simulate 'init' with 'foldr', my idea: http://pastebin.com/jdBK0fJX  but as you see uses 'z', there I need some special symbol. Any idea to rescue this approach?
12:46:20 <j-invariant> ghnz: init takes the first bit off the list?
12:46:24 <j-invariant> > init "foobar"
12:46:25 <lambdabot>   "fooba"
12:46:28 <joe6_> is anyone aware of a haskell library that can do a "diff"?
12:46:28 <j-invariant> oh it takes the last bit off
12:47:21 <Twey> ghnz: Note that the type of the â€˜collectingâ€™ value doesn't have to be the same as the type of the values in the list
12:47:34 <Twey> ghnz: So you can store extra information there
12:47:35 <Heffalump> joe6_: lcs will do part of the job
12:47:43 <Twey> With e.g. a tuple or a Maybe like I did above
12:47:49 <joe6_> Heffalump: thanks a lot.
12:48:06 <edwardk> joe6_: gershom bazerman has one
12:48:20 <ghnz> Twey, Maybe?, I thought that was a word no something really in haskell :S hah
12:48:27 <edwardk> http://hackage.haskell.org/package/Diff
12:48:43 <Twey> ghnz: I have no idea what you just said; sorry
12:49:05 <ghnz> Twey, the problem is that if I want to generalize, what kind of special symbol I choose?
12:49:13 <Twey> ghnz: It's a peculiar book you're using that introduces folds before Maybe.  Perhaps you should try using one of Real World Haskell or Learn You A Haskell instead?
12:49:50 <Twey> > let init' = fromJust . foldr (fmap Just . maybe [] . (:)) Nothing in init' "abcde"
12:49:52 <lambdabot>   "abcd"
12:50:11 <Twey> ghnz: You don't want to be using a special symbol in the list at all
12:50:23 <Twey> What if the list contains all the possible values?
12:50:32 <ghnz> Twey, yes, thats my problem
12:50:49 <ion> Couldnâ€™t there have been a Random monad (free of IO, more akin to State) instead of the split function for distributing the RNG to functions?
12:50:52 <ghnz> Twey, I'm using 'The Craft of Functional Programming'.. its a well known book in all Haskell courses.
12:50:58 <j-invariant> ghnz: I know how to derive this
12:51:12 <Twey> Right â€” so you need to attach some special information *as well as* what's in the list, not interpret something that's already in the list as special information
12:51:17 <Twey> ghnz: It's old
12:51:17 <joe6_> edwardk: thanks a lot.
12:51:24 <monochrom> I think MonadRandom is exactly akin to State
12:51:29 <Twey> Is that the one that describes Haskell as a Lisp?  I don't recall
12:52:17 <ion> monochrom: It doesnâ€™t come in base and split still exists, so it definitely isnâ€™t â€œinstead ofâ€ the split function. :-)
12:52:30 <ghnz> Twey, this edition is from 1999. Doesnt seem so old.
12:52:45 <gwern> 'haskell is an acceptable lambda calculus'
12:53:09 <Twey> ghnz: Er, that makes it twelve years old.  There's been a whole new standard since then.
12:53:23 <j-invariant> ghnz: what is the problem?
12:53:34 <ghnz> Twey, I dont think the basic stuff has changed.
12:53:48 <Twey> ghnz: It hasn't, but your book is teaching it in a terrible way.
12:53:51 <j-invariant> (specifically)
12:53:59 <Twey> ghnz: It's jumped you to some relatively advanced stuff before covering basics.
12:54:02 <monochrom> if you don't use getRandoms or getRandomRs you won't run into split.
12:54:26 <j-invariant> ghnz: I could show you the derivation or give you  a hint
12:55:02 <ghnz> j-invariant: Write 'init' function with 'foldr'. Thats the exercise.
12:55:10 <j-invariant> ghnz: yes but what are you struggling with?
12:55:24 <ghnz> Twey, the book its ok for basic stuff. Maybe this exercise was a bad choice.
12:55:37 <ghnz> Twey, or too synthetic
12:55:38 <dolio> You could say, "there's been a whole new standard" for anything more than a year old.
12:55:56 <copumpkin> preflex: seen tteugel
12:55:57 <Twey> dolio: I know, it's great
12:55:57 <preflex>  Sorry, I haven't seen tteugel
12:56:01 <copumpkin> preflex: seen ttuegel
12:56:02 <preflex>  ttuegel was last seen on #haskell 3 days, 3 hours, 36 minutes and 47 seconds ago, saying: dcoutts_: awesome!
12:56:05 <dolio> And the new one isn't that different from the old one.
12:56:21 <monochrom> "use foldr for everything" is not a good exercise
12:56:35 <copumpkin> dcoutts: do you know if he put that documentation for cabal-test up somewhere?
12:56:56 <ski> Twey : i liked the Craft when i read it (some ten years ago) ..
12:57:18 <j-invariant> ghnz: Here http://pastebin.com/raw.php?i=Dw28Q0X6 -- this will get yuo started
12:57:23 <monochrom> you probably didn't do all the exercises
12:57:35 <j-invariant> ghnz: the next step is to split xs into either [] or y:ys
12:57:44 <j-invariant> ghnz: maybe that will help you
12:57:54 <fliebel> Are there people in here who where at the Dutch-FP day? Some guy who looked a bit like Nickelback produced a nice opinion regarding off-shoring, but I managed to forget it. Small chance of succeeding here, but worth a try :)
12:57:54 <lambdabot> fliebel: You have 1 new message. '/msg lambdabot @messages' to read it.
12:58:13 <ski> (monochrom : why is using `foldr' for everything not a good exercise ? ;)
12:58:31 <monochrom> for example "foldr for init".
12:59:10 <j-invariant> monochrom: foldr for init is practice: Like proving that 2^n + 6^m divides 7 (or doesn't whatever).. The problem is stupid and nobody cares about it but ... well.. that's education?
12:59:31 <monochrom> a lot of them are pulling rabbits out of hats.
12:59:48 <j-invariant> monochrom: I think this one is systematic though, aat least the way I do it
13:01:36 <dcoutts> copumpkin: I think it's all in the user guide, see version 1.10 (it's not on the cabal homepage yet)
13:04:26 <copumpkin> dcoutts: is it sufficient to get cabal-install's head or must I get cabal's too?
13:04:33 <copumpkin> (for the actual functionality)
13:05:22 <dcoutts> copumpkin: if you want to use the cabal program then you'll need darcs version of cabal-install. Released version of Cabal-1.10 is ok though, you don't need darcs version of Cabal lib.
13:05:37 <copumpkin> okay cool
13:05:57 <copumpkin> thanks :) just waiting for darcs to finish getting cabal-install
13:06:12 <copumpkin> (darcs asked me to bug you to upgrade the repo, by the way)
13:08:16 <copumpkin> dcoutts: oh, but the latest user guide is in the cabal repository?
13:08:24 <copumpkin> the newer version of http://www.haskell.org/cabal/release/cabal-latest/doc/users-guide/ ?
13:08:30 <j-invariant> ghnz: was that any use to you?
13:09:02 <dcoutts> copumpkin: right
13:09:10 <copumpkin> I see
13:15:40 <teki> would the following function have a well-defined type signature: http://hpaste.org/42904/a_funny_little_function
13:17:07 <sipa> i don't think so
13:17:39 <Saizan> you might be able to do something similar with type class hackery
13:17:55 <copumpkin> not based on an actual Int though
13:17:59 <copumpkin> or whatever you wanted the first parameter to be
13:18:15 <Saizan> but like that it won't typecheck because the type of list would need to depend on the value of the first argument
13:18:20 <copumpkin> you'd need something that reflected its value on the type level
13:19:13 <Saizan> right, and i guess you don't even need the type class at that point
13:20:54 <copumpkin> dcoutts: sorry to keep bugging, but Warning: 'detailed-1.0' is not a supported test suite version :/
13:21:12 <copumpkin> dcoutts: I even installed the latest cabal and it's still telling me that
13:21:18 <dcoutts> copumpkin: right, it's not in version 1.10
13:21:20 <copumpkin> it says the only type available is exitcode-stdio
13:21:32 <copumpkin> hmm
13:21:39 <copumpkin> but I installed head of both cabal-install and cabal
13:21:41 <dcoutts> copumpkin: Cabal HEAD has 'detailed-0.9' but we decided not to put it in the 1.10 release yet
13:21:57 <copumpkin> Registering Cabal-1.11.0...
13:22:07 <dcoutts> ok, then you can use 'detailed-0.9'
13:22:36 <copumpkin> it still claims not to know about it
13:22:36 <copumpkin> hmm
13:22:45 <dcoutts> are you using cabal-install?
13:22:48 <copumpkin> yeah
13:22:57 <dcoutts> but it's built against Cabal-1.10
13:23:01 <copumpkin> and I rebuilt cabal-install after installing
13:23:02 <copumpkin> oh
13:23:06 <copumpkin> I need to adjust its cabal file
13:23:06 <dcoutts> hence your problem
13:26:00 <copumpkin> dcoutts: thanks, that worked
13:35:22 <copumpkin> hmm, I must be doing something wrong
13:36:53 <gb345> does any of you know where in the source (->) is defined?
13:37:03 <copumpkin> it's a primitive
13:37:08 <copumpkin> and couldn't be written in haskell
13:38:03 <gb345> ok, is this the same as in
13:38:04 <gb345> instance Applicative ((->) a) where
13:38:12 <gb345>         pure = const
13:38:12 <gb345>  
13:38:14 <copumpkin> yeah, same
13:38:26 <gb345> ok, thanks!
13:38:26 <gb345>  
13:39:21 <jonkri> what do you generally return for a io function which should not return anything (that only has side effects)?
13:39:40 <copumpkin> ()
13:39:49 <jonkri> thanks
13:39:57 <aristid> IO ()
13:40:09 <jonkri> thanks :)
13:40:19 <gb345> i was looking at the haskell source in the hopes of finding a formal definition of (->), but if it can't be written in haskell, where can i find such a formal definition?
13:40:31 <ezyang> Haskell Report? 
13:40:52 <gb345> ok, i'll look at that now, thanks
13:41:05 <j-invariant> gb345: you cant' define -> in haskell
13:41:08 <j-invariant> it has to be built ni
13:41:28 <copumpkin> dcoutts: do you have another minute? I'm having trouble :( or should I just wait until it's officially released
13:41:42 <dcoutts> copumpkin: what's the issue?
13:41:57 <dcoutts> copumpkin: this is with the detailed interface I suppose?
13:42:02 <gb345> j-invariant, i got that, but it has to be defined formally somewhere, no?
13:42:11 <copumpkin> I have my Test-suite section in the .cabal file, and cabal test says it runs 0 out of 0 tests
13:42:22 <dcoutts> copumpkin: configure with --enable-tests
13:42:24 <copumpkin> dcoutts: indeed. I haven't tried the stdio one
13:42:26 <copumpkin> oh!
13:42:44 <dcoutts> copumpkin: we're changing the way that bit works since we noticed it's quite confusing :-)
13:42:57 <gb345> i mean, without a formal definition of (->), how can it be implemented?
13:42:58 <copumpkin> I see :) yeah, I couldn't see anything about it in the userguide
13:43:02 <copumpkin> yeah, that worked!
13:43:04 <copumpkin> awesome
13:44:30 <gb345> looking in the index of the haskell report, i don't see (->) or arrow...
13:46:00 <copumpkin> actually
13:47:00 <copumpkin> dcoutts: it looked like it worked, but didn't :P I just copied and pasted the sample test module from the user guide and cabal test claims it passed, but looking at the code I'd expect there to be two test cases in it and for one to pass and the other to fail (http://hpaste.org/42905/tests)
13:47:19 <copumpkin> (the output is http://hpaste.org/paste/42905/what_it_tells_me#p42906)
13:47:56 <copumpkin> although
13:48:03 <dcoutts> copumpkin: perhaps you can email the cabal-devel list
13:48:04 <copumpkin> looking at it more carefully, I'm not sure it even built that module
13:48:05 <copumpkin> yeah
13:48:12 <copumpkin> I'll join it :)
13:48:31 <revenantphx> (->) is not actually part of haskell. GHC adds it in because the authors thought it'd be useful.
13:48:44 <revenantphx> Originally you were only suppose to ever be able to use top level definitions in haskell.
13:48:54 <revenantphx> Keeps it much more pure and allows for ridiculous optimizations.
13:49:06 <revenantphx> Haskell ran so fast it was as if it wasnt even doing anything.
13:49:07 <Saizan> what?
13:49:16 <gb345> revenantphx, ah! thanks!
13:49:21 * revenantphx sarcasm
13:49:24 <Saizan> that's actually not true.
13:49:34 <revenantphx> I'm trolling you gb345, don't believe me :3
13:49:57 <gb345> as you can see, i'm maximally gullible...
13:50:20 <revenantphx> Derivative of gullability(x) = 0 where x = gb345
13:50:37 <revenantphx> (and the second derivative is positive)
13:50:42 <gb345> that's why i one "the most gullible award" every year in college...
13:50:53 <revenantphx> Did you also fail English?
13:50:58 <gb345> one^h^h^h won
13:50:58 <revenantphx> Spelling quizzes must have been harsh :P
13:51:05 <revenantphx> ^_^
13:51:18 <ddarius> You didn't actually win it.  They were just kidding with you.
13:51:29 <Saizan> gb345: the report is quite informal, but see e.g. section 4.1.2
13:51:43 <ddarius> Section 4.1.2 is popular today.
13:52:02 <a_jazz> is it possible to do a qualified import at the GHCi prompt?
13:52:23 <gb345> Saizan thanks! ++
13:54:06 <ddarius> revenantphx: The second derivative being positive means concave up and thus a minimum.
13:54:43 <Saizan> anyhow, you can apply the notion of monotone function from domain theory if you want to know what kind of thing a value of type A -> B is supposed to be
13:55:28 <ddarius> Or you can work in a intuitionistic set theory.
13:56:22 <Saizan> making sure it's inconsistent :)
13:57:32 <ddarius> @google "synthetic domain theory"
13:57:33 <lambdabot> http://www.cogs.susx.ac.uk/users/bernhard/PapersFolder/hothm.pdf
13:57:34 <lambdabot> Title: Synthetic Domain Theory in Type Theory : Another Logic of Computable Functions
13:58:17 <revenantphx> ddarius: yeah, I realized my mistake >_>
14:05:03 <a_jazz> can I do an "import qualified" for really long module names in GHCI?
14:05:48 <a_jazz> typing Data.ByteString.Lazy.Char8 every time I want to use a function defined there is a drag
14:06:14 <opqdonut_> import qualified Data.ByteString.Lazy.Char8 as BSC
14:06:59 <a_jazz> that doesn't work
14:07:22 <a_jazz> "parse error on input: `import' "
14:07:40 <lispy_> a_jazz: I think that feature was relatively recent, your ghci may be too cold
14:07:42 <lispy_> er old
14:07:48 <copumpkin> nope
14:07:49 <a_jazz> brrrrr
14:07:54 <copumpkin> it needs to be at the top of the file though
14:07:56 <copumpkin> before any declarations
14:08:00 <lispy_> a_jazz: but, :m + Data.ByteString.Lazy.Char8 should work
14:08:07 <copumpkin> oh in ghci
14:08:08 <copumpkin> yeah
14:08:10 <opqdonut_> oh in ghci
14:08:33 <a_jazz> I noticed the feature request, but the discussion was a bit vague about how the imports were to be done
14:08:44 <lispy_> a_jazz: you can also tab complete identifiers in ghci, which helps a lot
14:08:53 <a_jazz> lispy_: the problem is I still need to use Prelude functions :(
14:09:01 <a_jazz> ooooh yeah
14:10:30 <lispy_> :t Dat<tab>unfoldr
14:10:32 <lambdabot> Not in scope: data constructor `Dat'
14:10:32 <lambdabot>     Precedence parsing error
14:10:32 <lambdabot>         cannot mix `<' [infix 4] and `>' [infix 4] in the same infix expression
14:10:33 <lispy_> that works for me
14:10:47 <lispy_> I just have to do 4 extra keystrokes, not too bad
14:11:57 <Saizan> you could also load a file where you've the qualified import, it'll be available at the prompt then
14:12:16 <Saizan> that's how we get to say M.lookup in lambdabot 
14:12:26 <Saizan> ?ty M.lookup
14:12:26 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
14:20:01 <romanandreg> is there any function to Conver a ByteString to a Num (Float, Int, Integer)?
14:20:38 <Saizan> ?hoogle readInt
14:20:38 <lambdabot> Numeric readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
14:20:38 <lambdabot> Data.ByteString.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
14:20:39 <lambdabot> Data.ByteString.Lazy.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
14:20:46 <mtkocak> interesting
14:21:04 <romanandreg> all of them return Int
14:21:06 <romanandreg> a want
14:21:07 <romanandreg> Num
14:21:11 <romanandreg> I want*
14:22:00 <mtkocak> haskell for web?
14:22:26 <Twey> happstack, Snap, Horse
14:23:04 <Twey> Turbinado?
14:25:39 <Bynbo7> romanandreg: read . map chr . unpack? (the map chr won't be necessary if you use Char8 Bytestrings
14:28:23 <Saizan> which are the same type as the non-Char8 ones, so it's just a matter of which unpack you import
14:28:50 <Bynbo7> yeah
14:32:12 <aristid> Twey: turbinado seems dead
14:33:40 <Twey> Yeah, looks like
14:33:45 <Twey> Maybe not Turbinado, then
14:45:50 <rjo> if I've long list of e.g. eval xx, eval yy, .. is it an efficient approach?
14:46:16 <lispy_> rjo: eval xx?
14:46:54 <rjo> large amount of pattern matchings
14:47:04 <rjo> 15 in this case
14:47:11 <Bynbo7> huh?
14:47:47 <lispy_> rjo: Checking for a constructor is just a check for a specific bit
14:47:53 * ski peers confusedly at rjo
14:48:19 <lispy_> I think rjo means, his function will have 15 equations
14:48:43 <lispy_> eval Foo = ...; eval Bar = ...; etc
14:49:02 <Bynbo7> lispy_: it can be an indirection and a check, if there's more than 4/8 constructors in the type i think
14:49:04 <rjo> eval env (List (Atom "lambda" : DottedList params varargs : body)) = makeVarargs varargs env params body
14:49:07 <rjo> eval env (List (Atom "lambda" : varargs@(Atom _) : body)) = makeVarargs varargs env [] body
14:49:43 <rjo> I went through write yourself scheme in 48 hours
14:49:50 <rjo> now I'm studying the code
14:50:30 <Bynbo7> first write your code for clarity, then write for speedif you find it slow
14:52:34 <hcb> Is it normal that parsec takes over 200mb of ram to link?
14:52:47 <lispy_> hcb: gnu ld is a memory piggy
14:53:08 <lispy_> hcb: 200mb of ram is actually not so bad.  I've seen gnu ld require ~ 1gb to link hello world in Haskell
14:53:25 <hcb> hm, I'm trying to install onto an old machine, guess that goes out the window
14:53:46 <faust45> i try create simple OpenGL app http://friendpaste.com/3Lr16neumwkb2CBJYcHkWS   but  catch error GLUT Fatal Error: redisplay needed for window 1, but no display callback.
14:54:20 <qfr> lispy_: 1 GiB? Are you sure you weren't looking at the vmem column? :p
14:55:03 <Twey> Is it one of those things that will just take as much RAM as it's given?
14:55:11 <hcb> sadly the precompiled binary of the platform doesn't include cabal, but if I can't link any meaty project anyway...
14:55:14 <lispy_> qfr: It was the vmem, but I only had 360mb or so of physical, so it was causing me to swap so badly that I had to rebuild GHC without obj splitting
14:55:54 <lispy_> hcb: In my experience, disabling obj splitting makes the problem go away in most releases of gnu ld
14:55:57 <dcoutts> hcb: you mean the precompiled binary of ghc? the HP does include cabal
14:56:03 <hcb> lispy_: obj splitting?
14:56:42 <lispy_> hcb: yeah, some versions of ghc/cabal do this thing they call obj splitting and that drives some versions of gnu ld insane.  In general though, gnu ld is a memory piggy.
14:57:24 <lispy_> hcb: I'm not 100% sure what obj splitting is, but it has something to do with splitting the object files so that linking of haskell programs can be more precise (eg., you get a smaller binary when done)
14:57:43 <dcoutts> specifically, in default builds of ghc, the libs that come with ghc (like base) use split objs. Cabal does not use split objs by default.
14:58:03 <dcoutts> (behaviour is the same for all recent ghc & cabal versions)
14:58:07 <hcb> do you think 128MB ram would be doable? I did compile gtk+ libs and other fairly large C/C++ stuff without much problems
14:58:43 <dcoutts> hcb: the rule of thumb we used on gentoo was that for machines with 500mb or less one should turn off split objs
14:59:27 <dcoutts> hcb: so a machine with 128Mb would certainly struggle with split objs.
15:00:04 <hcb> thanks for the info, lispy_ and dcoutts! i'll try without split objs
15:09:18 <hcb> dcoutts: oh it looks like I installed the generic ghc precompiled linux package, got confused because it does include haddock, and the cabal page says cabal isn't included somewhere because of issues with system specific libs
15:10:40 <dcoutts> hcb: so you can try the HP which bundles a bunch more stuff. However you may still have problems with split objs if you're linking on a memory constrained system. To link on such a system you'd need a build of ghc that does not use split objs for its core libs. That means building ghc etc from source.
15:11:21 <hcb> ok
15:13:58 * hackagebot hylolib 1.3.2 - Tools for hybrid logics related programs  http://hackage.haskell.org/package/hylolib-1.3.2 (GuillaumeHoffmann)
15:14:58 * hackagebot HTab 1.5.5 - Tableau based theorem prover for hybrid logics  http://hackage.haskell.org/package/HTab-1.5.5 (GuillaumeHoffmann)
15:39:15 <ddarius> 220 Marvelous, 100 Perfect, 36 Great
15:39:55 <djahandarie> 356 total?
15:44:15 <faust45> if i want use HOpenGL i need compile ghc with ./configure --enable-hopengl 
15:44:16 <faust45> ?
15:44:33 <ddarius> djahandarie: Yep.
15:44:53 <monochrom> no, you install HOpenGL or install haskell platform
15:46:44 <monochrom> actually the package name is OpenGL. http://hackage.haskell.org/package/OpenGL
15:47:33 <faust45> monochrom: i try simple example http://friendpaste.com/2T60HV4haMcDOsKGdifcAp but catch many errors
15:48:02 <Eelis> hm, i installed ghc 7 and it came with Cabal 1.10, but cabal-install seems to require Cabal 1.8. can i conclude from this that cabal-install currently doesn't with ghc 7 yet?
15:48:09 <monochrom> then you also need the GLUT package.
15:48:15 <Eelis> *doesn't work
15:48:44 * ddarius is using cabal-install with GHC 7.
15:48:56 <Eelis> ddarius: what Cabal version do you have?
15:49:22 <ddarius> cabal-install 0.8.0, Cabal 1.8.0.2
15:49:35 <Eelis> interesting. where did you get your ghc 7 from?
15:49:38 <monochrom> ddarius probably built cabal-install with ghc 6, then switched ghc to 7.
15:49:45 <ddarius> monochrom: Probably.
15:49:57 <monochrom> without rebuilding cabal-install
15:49:59 <ddarius> Eelis: The Linux generic binary.
15:50:11 <Eelis> ddarius: but that one ships with Cabal 1.10
15:50:23 <faust45> monochrom: i have GLUT lib http://friendpaste.com/19Zdob72cTC2jrIek6zRVg
15:50:37 <faust45> monochrom: but catch errors http://friendpaste.com/30RA735dbLxf8uleanoUIy
15:50:42 <Eelis> ddarius: so then i don't understand how you managed to not have Cabal 1.10 :)
15:50:58 <faust45> monochrom: i compile  ghc -package OpenGL -package GLUT test.hs -o test
15:51:17 <ddarius> I do have Cabal 1.10 and Cabal 1.8.0.6 as well.
15:51:36 <Eelis> oh!! i didn't know those could coexist peacefully
15:52:00 <Eelis> i will try to do it the same way then. thanks :)
15:53:16 <ivanm> Eelis: yeah, Cabal's can co-exist nicely
15:53:50 <faust45> any one try OpenGL?
15:53:52 <ivanm> the only problems I've had with multiple Cabals is that the auto-detection stuff that ManateeLazyCat implemented in gtk2hs assumes that if you have Cabal-1.10 then you have ghc-7 :/
15:54:01 <faust45> i need help
15:55:05 <monochrom> how did you install OpenGL and GLUT?
15:55:19 <Eelis> hm, when i try to install Cabal 1.8 i get: "At least the following dependencies are missing: base >=4 && <3 && >=1 && <5, filepath >=1 && <1.2" . i have base 4.3 and filepath 1.2..
15:55:45 <monochrom> in fact probably easier to "ghc-pkg -v list" and "ghc-pkg describe OpenGL" and "ghc-pkg describe GLUT"
15:56:00 <faust45> monochrom: download from http://hackage.haskell.org/
15:56:01 <monochrom> and please don't put them across three different web pages.
15:57:29 <qfr> base >=4 && <3 && >=1 && <5
15:57:34 <qfr> That looks super bizarre, E
15:57:36 <qfr> Eelis*
15:57:39 <Eelis> qfr: indeed! :(
15:57:53 <monochrom> your program loads fine here. no compile-time error.
15:58:10 * hackagebot semigroups 0.2.0 - Haskell 98 semigroups  http://hackage.haskell.org/package/semigroups-0.2.0 (EdwardKmett)
15:58:34 <monochrom> I'm inclined to judge it as foul installation on your computer
15:58:48 <copumpkin> better than fowl
15:59:25 <monochrom> but you can avoid proving foul installation by not pasting what I requested for evidence.
15:59:38 <qfr> Eelis: What version of ghc is that?
15:59:48 <Eelis> qfr: 7.0.1
15:59:51 <qfr> Also, pastebin your ghc-pkg list perhaps?
16:00:05 <qfr> I had a lot of trouble with setting up ghc7 on Windows today
16:00:14 <qfr> the old cabal broke on some packages
16:00:17 <edwardk> eelis: almost ready with a stream package for you. working on consistency atm
16:00:21 <qfr> And I had to compile a new one, which failed at first, too
16:00:28 <Eelis> qfr: http://codepad.org/wgIEh1y0
16:00:30 <qfr> Had to install MSYS, mDTK, MinGW etc
16:00:35 <Eelis> edwardk: awesome! :)
16:00:44 <edwardk> i have Data.Stream.Branching, Data.Stream.Infinite, and Data.Stream.NonEmpty â€” the latter is what you care about
16:01:07 <faust45> monochrom: http://friendpaste.com/3ok8WzRa3nZR7Z2pxq7YwE 
16:01:13 <edwardk> technically you can do almost everything you can with data.stream.nonempty with data.stream.branching, but its a lot easier to work with
16:01:19 <qfr> Eelis what's your current cabal version
16:01:33 <edwardk> since the latter is just data Stream a = a :| [a]
16:01:37 <qfr> And what command did you use to install it?
16:01:59 <qfr> Did you try the dry v arguments yet to see what it wants to do?
16:02:02 <Eelis> qfr: 1.10, and it was just part of the ghc 7 binary package
16:02:03 <copumpkin> :|
16:02:18 <edwardk> copumpkin: =)
16:02:24 <copumpkin> :| is apathetic about its own name
16:02:38 <Veinor> haha
16:02:38 <qfr> Eelis: Wait, what is 1.8?!
16:02:44 <edwardk> its better than the streams which are snobbishly upset about it :<
16:02:46 <qfr> Newest cabal-install is 0.9.5
16:02:52 <qfr> And lib is 1.10.0.0?
16:02:54 <edwardk> they look like something out of hyperbole and a half.
16:03:01 <Veinor> now i want the anime smiley face combinator, ^-^
16:03:02 <qfr> cabal-install version 0.9.5
16:03:02 <qfr> using version 1.10.0.0 of the Cabal library
16:03:10 <qfr> Built from darcs today ^
16:03:21 <qfr> What is "cabal 1.8"?
16:03:29 <qfr> Oh it's the older version of Cabal
16:03:33 <qfr> Of the library
16:03:43 <Eelis> qfr: are you now talking about your system or my system?
16:03:47 <edwardk> but the infinite streams are happy :>
16:03:49 <qfr> Your system
16:03:56 <edwardk> if somewhat overly enthusiastically so
16:03:58 <qfr> I forgot that 1.8 < 1.10 in they way they count
16:03:59 <Veinor> it's a shame you can't use _ in operator names
16:04:00 <Veinor> ;_;
16:04:08 <monochrom> you have both OpenGL-2.4.0.1 and OpenGL-2.2.3.0. OpenGL-2.4.0.1 takes precedence. Your GLUT is built against OpenGL-2.2.3.0. That's a clear incompatibility. This explains two different versions of $= when there should be only one. Destroy OpenGL-2.4.0.1 or rebuild GLUT.
16:04:09 <Veinor> er, :_: i guess
16:04:19 <ddarius> So non-empty lists are the free semigroup...
16:04:21 <Veinor> qfr: that's true of most version numbers
16:04:23 <qfr> Eelis: Wait, why do you want an older version of the Cabal lib?
16:04:27 <edwardk> ddarius: yep
16:04:42 <edwardk> ddarius: they have a semigroup instance, etc.
16:04:46 <Eelis> qfr: because the latest cabal-install at hackage wants it
16:05:03 <copumpkin> edwardk: if you make semigroup, you should take those ugly First and Last Monoid instances and take the Maybe out from them!
16:05:14 <dcoutts_> qfr: just because there is a later version doesn't mean you have to upgrade immediately :-)
16:05:36 <qfr> Eelis: And you want the latest cabal-install?
16:05:37 <edwardk> copumpkin: hrmm.
16:05:44 <edwardk> i forgot those =)
16:05:54 <qfr> I actually ended up darcs'ing it and I ran sh bootstrap.sh and it worked, even on Windows
16:05:57 <Eelis> qfr: i want _any_ working cabal install :)
16:06:06 <qfr> Eelis it refused to work for me with cabal
16:06:10 <monochrom> read http://www.vex.net/~trebla/haskell/sicp.xhtml to see why upgrading packages at the faint of heart cons yourself
16:06:16 <qfr> Didn't manage to update cabal-install through cabal
16:06:18 <ski> copumpkin : heh, i was just thinking about those ..
16:06:37 <edwardk> so just make First and Last in Data.Semigroup and then you can use the Option semigroup -> monoid conversion to make the existing First and Last
16:06:52 <qfr> Eelis what's your current version? < 0.8.2?
16:06:54 <qfr> http://hackage.haskell.org/package/cabal-install
16:06:59 <edwardk> Option (First a) and Option (Last a) then just do the right thing
16:07:11 <qfr> I just did time darcs get http://darcs.haskell.org/cabal-install/ && cd cabal-install && sh bootstrap.sh
16:07:12 <Eelis> qfr: i don't have any cabal-install at the moment
16:07:20 <qfr> No need for cabal-install for that &
16:07:22 <qfr> ^
16:07:32 <qfr> Oh right, you already said so, sorry, I'm tired
16:07:46 <qfr> But be warned, the darcs'ing takes ages
16:07:53 <Eelis> hm, if i need to start pulling stuff from darcs repos to get it to work, i think i'd rather just revert to ghc 6 and wait for the package ecosystem to assimilate ghc 7
16:07:54 <qfr> Like 10-15 min for 2 MiB of data
16:07:58 <qfr> On a 100 Mbps line
16:08:07 <copumpkin> edwardk: yeah
16:08:17 <qfr> Aw :[ don't give up so easily
16:08:27 <ski> (edwardk : is there a reason for not s/Option/Maybe/ ?)
16:08:35 <qfr> Eelis: I'm a _Windows user_ and I put up more of a fight than you did!
16:08:42 <qfr> We can't have that
16:08:52 <edwardk> i made a separate type for the lifting of semigroups into monoids, because Maybe has the broken monoid => monoid instance in base
16:09:23 <edwardk> if i ever get around to petitioning to fix it, that instance by adding Data.Semigroup, then my Option can go away
16:09:42 <ahihi2> I have a pure function f :: Integer -> Integer that can take a long time to compute, and I'd like to stick it in an IO action so I can stop it with System.Timeout.timeout -- how do I make sure the function evaluates "inside" the IO action? "timeout t $ return (f n)" doesn't seem to work
16:10:22 <ddarius> F -| U where U : Mon -> SemiGrp
16:10:28 <ski> edwardk : hm, i don't recall that. how's it broken, exactly ?
16:10:58 <edwardk> ski: it is the lifting of a semigroup into a monoid, but since they don't _have_ semigroup, it just doesn't use the underlying mempty
16:10:58 <ddarius> Or I should say, Option -| U
16:11:14 <edwardk> so you're supposed to make fake semigroups into monoids, that have busted mempty just to use the stupid instance
16:11:31 <ski> ew
16:12:07 <ski> ddarius : so a free functor ..
16:12:44 <faust45> monochrom:  thank's dude, i run cabal install GLUT  and it's working now!!! 
16:12:59 <ski> ahihi2 : `evaluate' ?
16:13:34 <ski> @hoogle evaluate
16:13:35 <lambdabot> Control.Exception evaluate :: a -> IO a
16:13:35 <lambdabot> Control.OldException evaluate :: a -> IO a
16:13:35 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
16:14:00 <ahihi2> ah, that looks promising
16:14:44 <ahihi2> yeah, it works :)
16:14:45 <ahihi2> thanks ski 
16:16:48 <kafee> do you guys ever heard of POTM?
16:17:41 <ivanm> kafee: some MS Office file type?
16:24:40 <edwardk> copumpkin: added
16:24:44 <copumpkin> yay
16:24:46 <copumpkin> thanks
16:25:22 * hackagebot semigroups 0.3.0 - Haskell 98 semigroups  http://hackage.haskell.org/package/semigroups-0.3.0 (EdwardKmett)
16:26:22 * hackagebot functor-apply 0.7.2 - Strong lax semimonoidal endofunctors (Applicative sans pure)  http://hackage.haskell.org/package/functor-apply-0.7.2 (EdwardKmett)
16:27:32 <kafee> it would nice if a kind soul implement a server for we play
16:29:06 <Eelis> how long does it typically take for hackage to get haddock docs in place for newly uploaded packages?
16:29:16 <edwardk> 12 hours or so
16:29:22 <Eelis> ok
16:29:23 * hackagebot functor-apply 0.7.3 - Strong lax semimonoidal endofunctors (Applicative sans pure)  http://hackage.haskell.org/package/functor-apply-0.7.3 (EdwardKmett)
16:29:43 <edwardk> but you can download them and cabal haddock them almost instantly ;)
16:30:04 <Eelis> yeah, i just figured i'd wait if it was only 10 minutes :P
16:32:33 <Eelis> edwardk: hm, no  Semigroup [a]  instance?
16:32:44 <edwardk> eelis: only because i'm a moron =)
16:33:11 <Eelis> i'm just looking at the instance side by side with the old Semigroup package :)
16:33:19 <Eelis> *instances
16:33:25 <dibblego> yo edwardk 
16:34:12 <edwardk> heya. i wound up trompling on one of your packages again ;)
16:34:26 <dibblego> orly? which this time? :)
16:34:33 <edwardk> NonEmptyList
16:34:42 <dibblego> how did you tromple on it/
16:35:00 <edwardk> just because i was putting together a streams package with a bunch of streams that use the new comonad and semigroup package, etc.
16:35:01 <dibblego> it was only inevitable given that it is a semigroup and not a monoid
16:35:11 <edwardk> yeah
16:35:40 <dibblego> I want to write another package for monad combinators
16:35:45 <edwardk> so now i have Data.Stream.Branching, Data.Stream.Infinite and Data.Stream.NonEmpty â€” the latter is basically the code of your NonEmptyList with some minor tweaks
16:35:47 <dibblego> but I don't want to tromple, what you say?
16:35:57 <aristid> are streams monads?
16:36:01 <edwardk> some of them
16:36:18 <dibblego> in particular, right now, I want bindM, but there have been many in the past where I have thought, "I really should put this on hackage"
16:36:28 <edwardk> Data.Stream.Infinite has a 'diagonal' monad. Data.Stream.NonEmpty behaves like the monad you know and love
16:36:34 <Eelis> edwardk: other instances the old Semigroup package had that might be nice for the new one include () and tuples
16:36:39 <dibblego> edwardk, I could just add you as an owner of NonEmptyList
16:36:45 <edwardk> () i missed
16:37:00 <edwardk> dibblego: yeah but the package isn't the right name for a package of other kinds of streams
16:37:10 <dibblego> edwardk, this is true indeed
16:37:14 <edwardk> and not all of the streams in the new package are nonemptuy
16:37:26 <dibblego> edwardk, could your streams depend on NonEmptyList?
16:37:46 <edwardk> nah, all i'd get is one instance in kinda the wrong namespace
16:37:53 <djahandarie> I did make a cabal package with the Newtype typeclass and ala function due to not being able to find it anywhere else
16:37:53 <edwardk> and it'd drag in a lot of dependencies
16:37:55 <dibblego> furry nuts then
16:38:28 <djahandarie> 'ala Sum foldMap [1,2,3,4,5]' 'ala Product foldMap [1,2,3,4,5]'   etc
16:38:44 <djahandarie> It's funny becuase it ignores the first parameter ;)
16:38:55 <edwardk> i can patch up nonemptylist to use the new plumbing, but i'd rather talk to you about putting a 'forwarding' package up that says where to go
16:39:06 <edwardk> and which imports the other instead
16:39:06 <dibblego> djahandarie, what is the name of this package?
16:39:15 <ddarius> djahandarie: You should make an isomorphisms package and add an 'under' operation.
16:39:17 <djahandarie> dibblego, not on hackage
16:39:19 <dibblego> what is a forwarding package?
16:39:41 <pelotom> is the whole reason for the distinction between "pattern bindings" and "function bindings" to be able to define when the monomorphism restriction comes into play? I don't see why there should be a difference
16:39:55 <djahandarie> ddarius, under operation?
16:40:12 <edwardk> just a package that has a big 'use this instead' message in the cabal file, and which may have modules that import and re-export something form another package, like how the current monads-fd forwards to mtl
16:40:21 <dibblego> oh right
16:40:33 <ddarius> djahandarie: It's APL/J terminology.  It's basically f |-> g^-1 . f . g
16:40:41 <edwardk> because there isn't a way to clean up hackage =/
16:41:20 <djahandarie> ddarius, ah
16:42:10 <alpounet> ddarius, looks closer to math stuffs than APL/J to me :p
16:43:01 <ddarius> http://www.jsoftware.com/help/dictionary/d631.htm
16:43:46 <djahandarie> I do like the name isomorphisms more than newtype
16:44:02 <djahandarie> But it's also a hella less clear unless you know what an isomorphism is
16:45:02 <pelotom> djahandarie: "isomorphism" was used in Tron: Legacy, so maybe it's entering mainstream vocabulary :)
16:45:03 <Twey> But who doesn't?!
16:45:13 <djahandarie> pelotom, haha seriously?
16:45:15 <Twey> pelotom: Haha, was it used *correctly*?
16:45:35 <pelotom> yes, it was, and no, it was not, respectively :)
16:45:47 <Twey> Heh, why am I not surprised?
16:45:59 <Twey> What is an â€˜isomorphismâ€™ in Tron-speak?
16:46:02 <pelotom> The emergent AIs in the grid were called "Isomorphic Algorithms", or "Isos" for short
16:46:10 <djahandarie> -_-
16:46:12 <Twey> Oh, well
16:46:16 <Twey> It *might* be correct
16:46:22 <Twey> That could refer to anything :Ã¾
16:46:30 <pelotom> Twey: true
16:46:34 <edwardk> hrmm, what are the consqeuences of x-follows-version-policy in a cabal file?
16:46:35 <hpc> Twey: might be correct, if you are very flexible with language
16:46:40 <alpounet> yeah Twey but what structure would they keep ?
16:46:46 <alpounet> s/keep/preserve actually
16:46:46 <Twey> hpc: I'm a glass-half-full kind of person
16:46:53 <djahandarie> edwardk, I *think* it doesn't do anything yet
16:46:59 <edwardk> k
16:47:01 <dcoutts> edwardk: none yet
16:47:05 <ddarius> It's clearly technobabble added to sound impressive.
16:47:05 <pelotom> maybe they're algorithms which are isomorphic to human intelligences
16:47:10 <Twey> alpounet: They might not at all.  For all you know, there might just be an isomorphism involved in the algorithm somewhere.  ;)
16:47:32 <dcoutts> edwardk: and we have not decided yet how it will be specified in .cabal files
16:47:34 <Twey> Or someone might have just thought that they *look* a bit like isomorphisms.  >.>  English modifiers are fun like that.
16:47:44 <alpounet> right Twey 
16:48:10 <alpounet> edwardk, preparing a blog post regarding your recent packages ?
16:48:36 <Twey> pelotom: Could be, could be
16:48:51 <edwardk> eventually =)
16:49:04 <alpounet> meaning "during 2011"
16:49:06 <alpounet> okay got it :P
16:49:07 <edwardk> dcoutts: k. just spotted it in time and wondered
16:51:35 <ddarius> > log (exp 3 + exp 4)
16:51:36 <lambdabot>   4.313261687518223
16:52:01 <ddarius> Ah, ^. is log.
16:53:21 <sipa> > log $ exp 5
16:53:23 <lambdabot>   5.0
16:54:28 * ddarius wishes the Zip Calculus were built into Haskell.
16:55:45 <Eelis> ddarius: looks vaguely reminiscent of C++'s new variadic templates
16:55:46 <ddarius> It may be reasonably embeddable with type families.
16:56:23 <ddarius> Though it would still be pretty verbose.
16:56:45 * ddarius wishes we had type lambdas.
16:57:01 <ddarius> s/type/type-level/
16:57:31 <ddarius> (Actually, I wouldn't mind having type lambdas either.)
16:57:41 <edwardk> ddarius: that is the weakness in the your moral fiber that will eventually lead you to scala
16:58:04 <ddarius> edwardk: Greed being yours?
16:58:10 <edwardk> yes
16:59:39 <monochrom> eh? fear leads to greed, greed leads to scala, scala leads to fibre?
17:00:04 <Bynbo7> fibre leads to... bowel movements?
17:00:36 <alpounet> edwardk, do you find scala that good and fun ?
17:00:40 <Bynbo7> âˆ´ scala = shit?
17:00:41 <pelotom> Does anyone know of any work towards lifting the monomorphism restriction while also ensuring proper sharing where possible?
17:00:45 <Bynbo7> you saw it here first folks
17:00:45 <monochrom> fibre leads to thesis or feces
17:01:23 <monochrom> anyway I think scala is ok
17:01:26 <ddarius> pelotom: Just turn off the monomorphism restriction and use monomorphic types when you want to ensure sharing.
17:02:23 <pelotom> ddarius: I'm asking about research into removing the need for one to think about this :)
17:02:41 <ddarius> pelotom: Just don't think about it.  That's what I recommend.
17:02:41 <hcb> I can't say I love using haskell's type system for computing types, e.g. I remember seeing some typed scheme with inductively defined signatures that was a lot more compact
17:02:44 <codemac> anyone have a decent example using Network.Browser? The few snippets I've found lead to type errors and I don't know enough about Haskell network libraries really to get past them
17:03:54 <pelotom> ddarius: I want to think about it... I'm interested
17:05:24 <codemac> The error I'm getting is http://hpaste.org/42911 .. any hints or tips? The code is almost all in the error
17:05:58 <alpounet> i have a little sample codemac
17:07:06 <codemac> alpounet: hurrah, please share!
17:07:22 <alpounet> codemac, http://hpaste.org/42912/networkbrowser_sample
17:09:13 <zerp> I'm having some trouble with the Wikibools chapter on denotational semantics
17:09:29 <codemac> thank you alpounet that got me one step further, and the error makes a LOT more sense now hah
17:09:47 <zerp> Wikibooks* http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
17:09:56 <ddarius> data WikiBool = True | False | Edit
17:10:08 <zerp> haha
17:10:16 <alpounet> codemac, what are you getting now ?
17:10:31 <zomg> I think it also needs NotNotableEnough
17:10:32 <zomg> :P
17:10:42 <alpounet> for what it's worth, i use this function quite intensively, notably for getting titles from web pages
17:10:47 <ddarius> Don't forget CitationNeeded
17:10:48 <azaq23> NPOV
17:11:02 <zerp> Specifically I'm confused about the monotonicity part
17:11:50 <zerp> why is it not possible to have a functiom return 1 for integers and 2 for _|_? It seems to satisfy the monotone condition.
17:12:10 <zerp> argh sorry about the typos I'm on my phone
17:12:41 <gwern> > 150000 * 365
17:12:42 <lambdabot>   54750000
17:13:29 <ddarius> _|_ <= 1, f(_|_) = 2 </= f(1) = 1
17:14:24 <zerp> I thought all integers were "equally defined"?
17:14:41 <ddarius> zerp: No, they are all incomparable with each other.
17:15:07 <ddarius> They are all "totally defined" say, but the question isn't how defined they are but the information order.
17:15:27 <ddarius> Which is a poset, so if they were "equally defined" i.e. 1 <= 2 and 2 <= 1, then they'd all be equal.
17:16:03 <zerp> Oh I'm misunderstanding what a partial order is.  I get it now. Thanks
17:19:41 * hackagebot semigroups 0.3.1 - Haskell 98 semigroups  http://hackage.haskell.org/package/semigroups-0.3.1 (EdwardKmett)
17:20:33 <djahandarie> I've never actually submitted a package to hackage, how does that work anyways? Do I need to get an account from someone?
17:20:39 <dibblego> yes
17:20:54 <dibblego> http://hackage.haskell.org/packages/accounts.html
17:21:26 <djahandarie> Oh god, just remember that hackage takes like two years to load any pages from my connection -_-
17:21:31 <djahandarie> remembered*
17:21:41 * hackagebot UtilityTM 0.0.1 - Utility functions that are missing from the standard library  http://hackage.haskell.org/package/UtilityTM-0.0.1 (TonyMorris)
17:22:27 <edwardk> dibblgo: cute trick with your email address on that package
17:22:39 <dibblego> yeah stops those blasted spammers for sure
17:23:20 <edwardk> yup, when they go to flip it over wont they be surprised when they try to find the upside down at symbol! ;)
17:23:30 <dibblego> haha
17:25:17 <dibblego> edwardk, have you ever written a linter?
17:25:41 <edwardk> to complain about style and all that?
17:25:48 <dibblego> or, are there known techniques or data structures for linting given a AST?
17:25:49 <dibblego> yes
17:26:26 <djahandarie> dibblego, heh that is a neat trick
17:26:35 <edwardk> i'm usually less prescriptivist than that ;) never tried. the closest i've come is a bunch of refactoring browsing code bases
17:26:38 <ddarius> I would imagine it's pretty much straight up pattern matching.
17:26:54 <ddarius> dibblego: However, I'd highly recommend looking at the metal/xgcc stuff.
17:27:07 <dibblego> well, I am linting Javascript, which has the most outrageous programs that parse successfully I have ever seen
17:27:13 <dibblego> ddarius, ok thanks
17:28:17 <mdmkolbe> Does "System.Posix.Signals.signalProcess keyboardSignal pid" work on Windows and/or Mac?  (I'd test myself, but I'm in front of Linux right now.)
17:28:46 <edwardk> dibblego: yeah. i wrote a javascript compiler before. its insane what the grammar allows and will try to semicolon insert, etc.
17:29:04 <dibblego> edwardk, target javascript?
17:29:07 <edwardk> yeah
17:29:15 <dibblego> omg, is it open source?
17:29:17 <copumpkin> binutils -i is rather long when you enable all targets :O
17:29:29 <edwardk> there is an old busted version that is
17:29:33 <copumpkin> or objdump -i, that is
17:29:35 <edwardk> you're welcome to try and fix it up
17:29:40 <dibblego> is there a new non busted version that isn't?
17:29:51 <ddarius> dibblego: I believe "Bugs as Deviant Behavior" and "From Uncertainty to Belief" on this page: http://www.stanford.edu/~engler/  are two of the papers referring to it.
17:29:53 <edwardk> it later got picked up by someone and licensed, so the newer stuff is closed source
17:30:12 <dibblego> ddarius, great thanks
17:30:13 <pelotom> someone should make a language in which absolutely any string of characters produces a program... start with javascript, and for the ones it doesn't understand assign an arbitrary program
17:30:16 <edwardk> but there is a tarball of something on comonad, one sec.
17:30:19 <pelotom> I bet it would be the new hotness
17:30:34 <ddarius> edwardk: What did they use it for?
17:30:53 <edwardk> http://comonad.com/reader/2007/javascript-interpreter-recompiler-atomizer-threading-library/
17:31:38 <edwardk> google web toolkit kinda stuff, not sure if its currently shipping in anything or was just an intellectual property land grab
17:31:52 <ddarius> dibblego: Actually the one most relevant to you is probably "Checking System Rules using System-Specific, Programmer-Written Compiler Extensions"
17:32:06 <hpc> pelotom: start with machine code :P
17:32:24 <dibblego> ddarius, got it, cheers
17:32:33 <ddarius> pelotom: There are already languages that will successfully execute any input string.
17:32:44 <edwardk> dibblego the tar ball is linked from that page, you're looking for js.lang.Parser and the surrounding machinery
17:32:49 <ddarius> Machine code, arguably, will not as not everything encodes an opcode.
17:32:53 <pelotom> good point, I guess we just need to market it now
17:32:59 <ddarius> (Depending on architecture of course.)
17:33:02 <dibblego> edwardk, what language does it compile?
17:33:09 <edwardk> dibblego: it was designed so that the entire parser and compiler could fit in 16k of compressed javascript
17:33:15 <edwardk> javascript ;)
17:33:26 <dibblego> it compiles javascript to javascript?
17:33:29 <edwardk> it converts javascript with support for continuation capture to javascript
17:33:29 <ddarius> It's an implementation of a rather useless T diagram.
17:33:43 <ddarius> It compiles JS to JS using JS.
17:33:58 <dibblego> ok, I have an AST already, I was just thinking about the next part
17:34:00 <hpc> module JS.Compiler where compile = id
17:34:09 <hpc> oh look what i made! :D
17:34:28 <edwardk> dibblego: it let me write stuff like http://comonad.com/js/cps/Thread.js
17:34:57 <edwardk> which let me have client side threads in javascript in the pre-web-worker days
17:35:44 <ddarius> edwardk really likes implementing schedulers and concurrency primitives.
17:35:46 <edwardk> the CPS transformation lets you work around the limitations of javascript in other ways, it let you bypass the million instruction count sequential execution cap without explicitly calling back to yourself.
17:35:58 <edwardk> no, actually i despise writing them =)
17:36:03 <edwardk> i've just written them a lot =)
17:36:27 <edwardk> lemme see if the old slipwave content is still up, it had a bunch of material on the odd cps transform i used
17:36:29 <hpc> wait, what the hell?
17:36:35 <hpc> why is there a million instruction limit?
17:37:05 <edwardk> hpc: how many times have you see the message that 'this page is taking a long time to respond, cancel?' out of your browser?
17:37:12 <hpc> ah
17:37:26 <hpc> i always figured that was time-based
17:37:49 <edwardk> but if i can capture the current continuation, and toss it to a setTimeout every so often, i can fix it
17:38:10 <edwardk> similarly there is a 1000 stack frame count limit
17:38:22 <hpc> that makes the page more responsive too, if what you are doing is heavy
17:38:26 <edwardk> the numbers may have slightly shifted in the interim, but those were the old netscape numbers
17:38:32 <edwardk> exactly
17:38:56 <edwardk> and since i'm CPS'd, i don't care about the stack below me, but trampolining is expensive
17:39:02 <hpc> doing javascript that heavy looks like a design flaw though
17:39:35 <edwardk> so i 'bounce higher' by setting a trampoline that i bounce off of by throwing a Yield exception to, from ~800 stack frames up
17:39:55 <edwardk> the yield exception contains the current continuation
17:40:27 <edwardk> but since i'm at the trampoline anyways, i can just queue it, and resume something else, so blowing the stack chicken-scheme-style gives me a natural thread quantum
17:40:36 <edwardk> hence the threading primitives
17:41:23 <edwardk> if you want to browse it without downloading i think the contents of that jar are at comonad.com/js
17:41:55 <edwardk> but it was assembled by grabbing old working directories off of several machines and throwing them together, so its a bit use-at-your-own-risk
17:42:44 <edwardk> hah, sweet, that folder also happens to contain the only copy i can find of Perlin's old bias and gain functions ;)
17:43:37 <lispy> edwardk: how's it going?
17:43:47 <edwardk> lispy: well.
17:43:52 <lispy> cool
17:44:34 <Eelis> edwardk: will your streams package compete with the Stream package?
17:44:46 <edwardk> probably ;)
17:44:50 <copumpkin> Cale: how far from 5400 are you? I want to see this thing completed! http://www.flickr.com/photos/cgibbard/5102370200/
17:44:52 <Eelis> alrighty :)
17:45:10 <copumpkin> Cale: http://www.flickr.com/photos/cgibbard/5095706738/ :(
17:45:11 <Cale> copumpkin: I'm at 2808 with 432 on the way
17:45:11 <aristid> Eelis: don't let the competition win!
17:45:25 <Cale> copumpkin: :)
17:45:29 <lispy> edwardk: either your work is more obvious to me now or you're more active than you were the last couple years
17:45:41 <lispy> edwardk: what is powering your new found productivity?? :)
17:45:55 <aristid> copumpkin: he can't trap copumpkins in there
17:46:07 <edwardk> i've been active the last week or so, but before that i was off doing other things ;)
17:46:49 * hackagebot BerkeleyDB 0.8.2 - Berkeley DB binding  http://hackage.haskell.org/package/BerkeleyDB-0.8.2 (StephenBlackheath)
17:47:27 <lispy> edwardk: it's impressive and inspiring either way :0
17:47:29 <edwardk> but i had a year or so there where i was buried in projects-for-money rather than projects-for-fun
17:47:47 <Eelis> aristid: i'm not invested in either streams package. i just want nonempty lists, which will be in edwardk's streams package for some reason :)
17:47:57 <edwardk> the main thing i worked on that was publicly visible this last year was the ad package
17:48:11 <aristid> Eelis: nobody needs streams anyways, when we have Mu and (,)
17:48:17 <copumpkin> edwardk: I randomly ran into alexey radul and his wife last night by the way
17:48:24 <copumpkin> who also happens to be working on AD
17:48:29 <edwardk> hah
17:48:35 <copumpkin> in ireland
17:48:49 <edwardk> yeah
17:49:20 <alpounet> edwardk, thanks for 'ad' by the wya
17:49:21 <alpounet> way
17:49:26 <alpounet> I happened to use it a few months ago
17:49:31 <edwardk> they picked my brain before leaving the area
17:49:34 <copumpkin> Cale: I'm thinking of buying a mandala, but I'm afraid I'll get addicted
17:49:44 <edwardk> where did you run into them?
17:50:27 <aristid> edwardk: so they stole your thoughts?
17:50:36 <edwardk> aristid: thoughts freely given ;)
17:50:38 <copumpkin> edwardk: a mutual friend from dartmouth invited me and a few other guests over to his house for dinner last night, and they were some of the other guests
17:51:05 <JimmyRcom> Coming from erlang. How do I get a fold with a tuple to work. Kinda do nothing example fails: foldl (\x (n,xs) -> (n,xs)) (0,[]) [1,2,3]
17:51:34 <edwardk> aristid: once i got 'ad working, i started working with barak pearlmutter tryng to see if we could get a nicer interface on top. they went over there to do a phd (or masters) and postdoc under him between them
17:51:36 <dolio> You have the arguments to the function backwards.
17:51:48 <dolio> foldl (\(n, xs) x -> ...)
17:52:00 <JimmyRcom> a, thank you dolio
17:52:00 <dolio> They're the opposite of foldr.
17:52:21 <edwardk> the argument to foldl's function goes in relative position to how it gets inserted to the list
17:52:52 <shachaf> > foldr f z [a,b,c,d]
17:52:54 <lambdabot>   f a (f b (f c (f d z)))
17:52:55 <shachaf> > foldl f z [a,b,c,d]
17:52:56 <lambdabot>   f (f (f (f z a) b) c) d
17:53:27 <JimmyRcom> thanks for the clarification. I wish every chat had a lambdabot
17:54:33 <ddarius> Bah, no more @seen.
17:54:35 <edwardk> i still need to find a nice way to get type safety out of a scala based ad implementation
17:54:43 <edwardk> preflex: xseen ddarius
17:54:43 <preflex>  ddarius was last seen on freenode/#haskell 10 seconds ago, saying: Bah, no more @seen.
17:55:13 <ddarius> edwardk: Yes, but @seen would list all the channels you were on.
17:55:15 <mauke> @seen edwardk 
17:55:15 <preflex>  edwardk was last seen on #haskell 32 seconds ago, saying: preflex: xseen ddarius
17:55:15 <lambdabot> Unknown command, try @list
17:55:18 <ddarius> (That lambdabot wasl also on.)
17:55:34 <ddarius> So you could do @seen lambdabot and get spammed with all the channels lambdabot was in.
17:56:52 <gwern> 'Because we've reached the limits of moore's law, the computers of the future will have many-core processors and all our programs will need to be written in a combination of haskell and lisp, that will itself be so powerful that the computers of the future will not be able to implement any of our ideas without creating time-travelling algorithms that borrow processing power from other computers that are further into the future. This sounds difficult, ...
17:56:57 <gwern> ... but in lisp it isn't difficult at all. in haskell this is a built-in feature and the way you implement it is just a no-brainer to any one who knows lisp or haskell.'
17:57:56 * ddarius tries to manufacture a stitch out of thin air.
17:59:03 <aristid> gwern: you are a cargo cult!
17:59:18 <shachaf> ddarius: @listchans
17:59:21 <gwern> and since I float like cargo, I am a witch too
17:59:25 <aristid> @listchans
17:59:26 <lambdabot> ##freebsd ##logic ##manatee ##proggit #agda #arch-haskell #darcs #dreamlinux-es #dtp2010 #esoteric #friendly-coders #functionaljava #gentoo-haskell #gentoo-uy #ghc #gp2010 #happs #haskell #haskell-
17:59:26 <lambdabot> blah #haskell-books #haskell-freebsd #haskell-in-depth #haskell-infrastructure #haskell-overflow #haskell-soc #haskell.au #haskell.cz #haskell.de #haskell.dut #haskell.es #haskell.fi #haskell.fr #
17:59:26 <lambdabot> haskell.hr #haskell.it #haskell.jp #haskell.no #haskell.ru #haskell.se #haskell_ru #hscraft-srv #jhc #jtiger #learnanycomputerlanguage #macosx #macosxdev #rosettacode #scala #scalaz #scannedinavian #
17:59:26 <lambdabot> teamunix #unicycling #uscs2010 #xmonad #yi
17:59:33 <aristid> nice list
18:00:30 <shachaf> Hmm.
18:00:40 <shachaf> That's almost as many channels as I'm in...
18:00:44 <alpounet> #macosx ? well, okay.
18:00:47 <mm_freak_> > f <$> c >>= g
18:00:48 <lambdabot>   Couldn't match expected type `m a'
18:00:48 <lambdabot>         against inferred type `SimpleRef...
18:01:29 <shachaf> Oh, it's even more channels.
18:02:02 <shachaf> Why does Freenode even have #macosx?
18:02:15 <ddarius> I believe FreeNode limits how many channels a user can be in and that limit is lifted for lambdabot.
18:02:29 <shachaf> Also lifted for me, mysteriously.
18:02:31 <JuanDaugherty> if so it's large
18:02:52 <ddarius> I'm not saying lambdabot is currently exceeding it.
18:03:02 <JuanDaugherty> certainly > 20
18:03:11 <shachaf> (Mysterious because I asked for it to be lifted, they said no, and somehow it was lifted anyway.)
18:03:43 <edwardk> yeah they can lift it on petition given a good reason iirc
18:03:52 <edwardk> they must have liked you
18:04:36 <shachaf> I specifically asked the oper and he said he hadn't done it, but that since it was already there I might as well keep it.
18:04:56 * hackagebot comonad 0.6.1 - Haskell 98 comonads  http://hackage.haskell.org/package/comonad-0.6.1 (EdwardKmett)
18:06:37 <JuanDaugherty> ur only in 2 channels now
18:06:54 <shachaf> Only in two channels in common with you.
18:07:18 <azaq23> why does this restriction exist?
18:07:31 <JuanDaugherty> i don't think whois works like that, does it?
18:07:39 <ddarius> JuanDaugherty: It does.
18:07:46 <JuanDaugherty> ah
18:08:38 <shachaf> I believe you can configure it.
18:08:49 <ddarius> Indeed.
18:09:14 <shachaf> ddarius: Your don't register your nick?
18:09:38 <ddarius> shachaf: I haven't registered it for almost eight years.  I see no reason to start now.
18:09:51 <hcb> ddarius: lol that's great
18:11:55 <aristid> edwardk: there are no interesting instances of Comonad in the comonad package :/
18:12:02 <aristid> @index Mu
18:12:02 <lambdabot> bzzt
18:12:04 <edwardk> they are all in comonad-transformers
18:12:22 <edwardk> comonad requires nothing hinky that couldn't get standardized by design
18:12:34 <aristid> edwardk: isn't there any base / containers type that makes an interesting comonad?
18:12:57 <ddarius> edwardk: Do you have the free comonad construction in comonad or is it elsewhere?  (I know you have it somewhere.)
18:13:06 <edwardk> functor-apply is needed to make ComonadApply, which is what makes comonads interesting, but the style there is heavily duplicative of Applicative
18:13:31 <edwardk> ddarius: there is a StreamT comonad transformer , which when you use the Stream from that module you get the cofree comonad
18:13:48 <djahandarie> ddarius, so the under function would be   under :: (Newtype n o) => (o -> n) -> (n -> n) -> o -> o  ? Where n is the newtype and o is the original type
18:13:59 <edwardk> the streams package i started putting together, also has Data.Stream.Branching which is the f-branching stream/cofree comonad
18:14:10 * lispy >>= home
18:14:23 <BMeph> edwardk: Do you take syntactic sugar in your cofree comonads? ;)
18:14:56 <edwardk> no room in the cup after all the shots of espresso ;)
18:15:04 <kfish> instance Monad lispy where (>>=) = return
18:15:06 <djahandarie> under Sum (mappend (Sum 3)) $ 5 -- doesn't feel to be very useful here though :P
18:15:35 <ddarius> djahandarie: Yes, that's the right type.  However, you'd want an under2, under3 etc.
18:15:40 <BMeph> edwardk: Well played, Sir, well played. :)
18:15:44 <ddarius> under2 Sum mappend 3 5
18:15:52 <djahandarie> Ugh
18:15:59 <djahandarie> Can I make an Applicative out of this?
18:17:19 <edwardk> aristid: fraid not, Identity isn't in base (which is something i need to get around to petitioning to fix) Data.Functor.Identity is not a transformer.
18:17:51 <aristid> edwardk: if at least non-empty lists were in base/containers!
18:18:11 <edwardk> aristid: i have a few builtin type based comonads
18:18:18 <edwardk> just for (->) e  and for (,) e
18:18:31 <edwardk> the former is cowriter, the latter is coreader
18:18:47 <edwardk> those two have instances in Control.Comonad
18:18:57 <ddarius> Well if you did under2 f g a (under2 f h b c) you'd get inverse f (g (f a) (f (inverse f (h (f b) (f c))))) which would simplify to inverse f (g (f a) (h (f b) (f c))) which is, I think, what you'd want.
18:19:25 <aristid> edwardk: CoreaderT and CowriterT are in comonad-transformers?
18:19:38 <edwardk> as EnvT and StoreT respectively
18:20:10 <e32> hi, want to do something like this getVal xs = [x * N | x <- xs] where N = length xs but the N is outside the scope... I can't seem to find a good example of this. This works getVal xs N = [....] but not quite as neat.
18:20:17 <aristid> edwardk: (,) e seems to be a pretty dull comonad
18:20:20 <edwardk> and comonads-fd gives you monads-fd style typeclass plumbing on top
18:20:28 <edwardk> its more or less the simplest comonad you can have
18:20:32 <edwardk> just like reader
18:21:03 <aristid> edwardk: you really need to bring this to life with examples
18:21:10 <edwardk> i'm working on it. =)
18:21:19 <djahandarie> I prefer zombie code
18:21:23 <edwardk> i needed a streams library before i could really do that
18:21:29 <aristid> djahanderie: ok
18:21:35 <edwardk> because i couldn't give compelling dataflow examples without streams
18:22:02 <edwardk> sadly under haskell semantics the Observer i have in reactor isn't a comonad ;)
18:22:09 <djahandarie> aristid, btw, I'm pretty sure you've misspelled my nick every time you've talked to me to this point :P
18:22:09 <edwardk> er Observable
18:22:29 <aristid> djahandarie: no, only when i want to tease you and don't use tab completion
18:23:40 <ddarius> edwardk: Don't let Haskell's semantics stop you.  It doesn't stop anyone else.
18:24:24 <edwardk> hah, its not like they were ever formally written down ;)
18:24:35 <ddarius> edwardk: That's true too.
18:28:32 <codemac> What does it mean if I'm getting commitAndReleaseBuffer error (Invalid byte sequence)? My program is pasted here: http://hpaste.org/42913/warch
18:28:58 <codemac> I'm trying to download a webpage, do some parsing/replacing of stuff that isn't implemented, and then save to stdout
18:32:11 <edwardk> instance (Typeable1 f, Typeable1 w, Data (w (a, f (StreamT f w a))), Data (f (StreamT f w a)), Data a) => Data (StreamT f w a) where â€¦ jeesh
18:33:02 <ddarius> Just think of what it would be like in Scala.
18:33:11 <edwardk> isInstanceOf ;)
18:33:16 <ddarius> Or should I say, will be like?
18:33:36 <codemac> Hm, it appears the first &nbsp; in the webpage is where it breaks every time.
18:55:02 <edwardk> ok, hand rolled Typeable/Data for all of the transformers that can support it
18:55:11 * hackagebot comonad-transformers 0.6.2 - Haskell 98 comonad transformers  http://hackage.haskell.org/package/comonad-transformers-0.6.2 (EdwardKmett)
18:55:38 <edwardk> and then locked them behind a cpp barrier so the package still works regardless
18:56:42 <forrestv> 'a b c = q c b' is equivalent to 'a = \b c -> q c b'
18:57:18 <forrestv> is there any such equivalence for infix functions?
18:58:03 <forrestv> 'a % b = mod a b' then '% = ???'
18:58:28 <alpounet> \a b -> mod a b ?
18:58:29 <ddarius> (%) = mod
18:58:57 <alpounet> being infix or not doesn't change anything except at the calling site
19:00:33 <forrestv> oh ..
19:01:03 <aefjt> > [ 1 % 2, 1 `mod` 2, (%) 1 2, mod 1 2 ]
19:01:04 <lambdabot>   No instance for (GHC.Real.Integral (GHC.Real.Ratio t))
19:01:05 <lambdabot>    arising from a us...
19:01:19 <aefjt> > let (%) = mod in [ 1 % 2, 1 `mod` 2, (%) 1 2, mod 1 2 ]
19:01:20 <lambdabot>   [1,1,1,1]
19:02:37 <forrestv> i see ... okay, last thing i don't get about infix - how is operator precedence handled?
19:03:28 <aefjt> Explicit fixity declarations, see eg.
19:03:29 <azaq23> forrestv: You can declare operator it using the syntactic elements "infixr" and "infixl". l and r declare left or right associativity. The next "argument" is a number which determines the precendence
19:03:30 <aefjt> @where prelude
19:03:31 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
19:03:45 <copumpkin> @where fugue
19:03:45 <lambdabot> I know nothing about fugue.
19:05:53 <aefjt> You first need to (.) :: a -> Fugue
19:06:15 <copumpkin> :P
19:07:50 <ivanm> aefjt: *groan*
19:14:47 <benmachine> haskell-src-exts has support for negated patterns (- n) -- these don't seem to be in h98 or h2010, what's the deal?
19:17:42 <ivanm> benmachine: my guess is that it's for things like: foo (-1) = ...
19:18:17 <benmachine> ivanm: but the constructor is PNeg Pat -- allows arbitrary patterns inside
19:18:35 <ivanm> probably for simplicity of defining it
19:18:36 <benmachine> and anyway that's just a pattern literal like any other
19:19:03 <benmachine> PLit (Int (-1))
19:19:30 <benmachine> hmm
19:19:47 <benmachine> parsePat "-1" does give PNeg (PLit (Int 1))
19:20:12 <aefjt> > let f (-n) = n in f 42
19:20:13 <lambdabot>   <no location info>: Parse error in pattern
19:20:54 <benmachine> seems to be inherited from the original haskell-src
19:20:56 * benmachine investigate
19:24:33 <variable> what is the length of an infinite list? ghci just hangs on me
19:24:57 <benmachine> variable: ghci is giving the correct response, sort of :)
19:25:10 <benmachine> variable: infinite lists don't really have a length; that's what makes them infinite
19:25:29 <variable> benmachine, I know - is it supposed to go into an infinite loop? return an error? hang? etc
19:25:36 <Axman6> > length (cycle [1])
19:25:40 <ddarius> If you used a lazy natural type, you could constructively use the length of an infinite list, though you'd have to use genericLength rather than length.
19:25:52 <lambdabot>   thread killed
19:25:53 <benmachine> variable: the first and third options are the same, aren't they?
19:25:58 <dmwit> variable: It should hang, yes.
19:26:00 <Axman6> variable: how is it supposed to know it's not just about to get tot the end of the list?
19:26:17 <benmachine> variable: as for whether you get the hanging or the error depends on how magic GHC is feeling today
19:26:23 <ddarius> > genericLength (repeat 1) :: Natural
19:26:24 <lambdabot>   Not in scope: type constructor or class `Natural'
19:26:27 <dmwit> variable: Some infinite loops are detected and cause the program to terminate. But not many.
19:26:29 <ddarius> > genericLength (repeat 1) :: Nat
19:26:30 <lambdabot>   Not in scope: type constructor or class `Nat'
19:26:40 <benmachine> actually probably expecting GHC to work out it's an infinite list is asking a bit much
19:26:47 <variable> dmwit, I just did let ll = [1..]   length ll
19:27:02 * dmwit nods
19:27:10 <copumpkin> omg it's dmwit 
19:27:11 <variable> actually - knowing its an infinite list might require solving the halting problem
19:27:17 <dmwit> omg hi copumpkin 
19:27:19 <benmachine> variable: it would have been surprising if you got, like, seven, no?
19:27:22 <variable> but for simple cases I'd expect it to error out
19:27:23 <Axman6> variable: not might, does
19:27:30 <benmachine> Axman6: well, in general
19:27:33 <copumpkin> variable: why would you?
19:27:41 <Axman6> variable: if you'd like to add that to GHC, go ahead ;)
19:27:53 <benmachine> knowing that that list is infinite doesn't require solving the halting problem, but an arbitrary list being infinite, yeah
19:27:55 <copumpkin> variable: how many languages warn you that you're writing an infinite loop?
19:28:17 <dmwit> > let infiniteloopthatghccatches = infiniteloopthatghccatches in infiniteloopthatghccatches
19:28:17 <variable> copumpkin, I've seen warnings "this loop will never exit"
19:28:21 <lambdabot>   mueval-core: Time limit exceeded
19:28:24 <ddarius> copumpkin: More than you might think.
19:28:44 <dmwit> Eh, ghc catches it, but not ghci. =P
19:29:02 <benmachine> dmwit: yeah you need optimisations I think
19:31:25 <variable> need optimizations?
19:31:43 <aefjt> GHC-haskell must be the only language with a NonTerminationException
19:31:44 <benmachine> variable: some of ghc's optimisations allow it to work out when an infinite loop is in progress
19:31:48 <benmachine> and report a runtime error
19:31:55 <variable> heh - ghc -O exists
19:32:00 <kmc> aefjt, right, in Agda it's a compile-time error
19:32:01 <variable> I didn't even know about that before
19:32:22 <benmachine> variable: basically whenever it detects that evaluating an expression requires evaluating that same expression, it knows something is wrong
19:32:33 <copumpkin> GHC haskell has a runtime check for non-termination that has false negatives
19:32:34 <variable> benmachine, make sense
19:32:42 <copumpkin> agda has a compile-time check for non-termination that has false positives
19:32:59 <variable> agda ?
19:33:06 <benmachine> agda is a different programming language
19:33:11 <benmachine> it is scary
19:33:15 <benmachine> but in a cool way I guess
19:33:17 * variable should learn it :-}
19:33:36 <aefjt> kmc: in HQ9+, it's not even possible!
19:33:37 <benmachine> well, actually, there's some argument about whether it *is* a programming language, last I looked >_>
19:33:41 <variable> what is the name of its compiler ?
19:33:50 <copumpkin> @hackage agda
19:33:51 <lambdabot> http://hackage.haskell.org/package/agda
19:34:01 <copumpkin> @hackage Agda
19:34:02 <lambdabot> http://hackage.haskell.org/package/Agda
19:34:09 * ddarius wonders if this is where things fell apart.
19:37:00 * alpounet wonders when he'll actually have time to investigate agda
19:37:20 <benmachine> hmm, is it possible to match against primitives?
19:37:24 * ddarius checks alpounet's mortal clock.
19:37:27 <ddarius> Only if you hurry.
19:37:38 <benmachine> err, that is to say, unboxed integers/characters/etc in a pattern
19:37:49 <benmachine> why am I even asking
19:37:51 * benmachine pokes ghc
19:37:55 <copumpkin> yes
19:38:11 <benmachine> ah, so it is
19:38:34 <benmachine> heh, cute
19:38:39 <benmachine> -1## is a parse error
19:39:20 <djahandarie> ddarius, I think I'll only provide under, otherwise I'll either need to make 1. underN, or 2. impose some structure on the arguments, like a list, at which point I'd rather them use   ala :: (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> (b -> o')    which tells them "you deal with the structure yourself, I don't care"
19:39:25 <Axman6> do you have MagicHash turned on?
19:39:41 <benmachine> Axman6: yes, 1## works fine
19:39:50 <djahandarie> Like ala Sum foldMap [1,2,3,4,5]
19:40:00 <benmachine> but -1## doesn't because you can't have negative Word#s
19:40:49 <Axman6> nice to know
19:41:38 <copumpkin> djahandarie: his Newtype thing seems better with a type family
19:42:06 <djahandarie> copumpkin, in place of the fundep?
19:42:12 <copumpkin> yeah
19:42:47 <alpounet> ok copumpkin which (introductory) paper should I read ?
19:42:49 <alpounet> (about agda)
19:43:41 <copumpkin> http://www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf is pretty accessible
19:44:12 <ddarius> It's a trap!
19:44:20 <alpounet> I saw "This is aimed at functional programmers." on the wiki
19:44:41 <alpounet> and told myself "this one won't try to make me a logic rules writing monkey"
19:45:09 <djahandarie> copumpkin, because that way we could do something like (Newtype n, Newtype n', Newtype n ~ Newtype n1) ?
19:45:25 <copumpkin> djahandarie: well, something like Payload n ~ Payload n1
19:45:30 <copumpkin> but we could do that anyway
19:45:42 <copumpkin> (Newtype n x, Newtype n' x) =>
19:45:47 <djahandarie> Right
19:45:55 <copumpkin> just cause it's fairly function-like
19:46:06 <copumpkin> and for function-like things fundeps just feel clunky
19:46:10 <copumpkin> but maybe that's just me
19:46:12 <aavogt> does Newtype go both ways?
19:46:19 <copumpkin> no
19:47:05 <aavogt> copumpkin: so   n and n' can be actually different types?
19:47:15 <copumpkin> yeah
19:47:19 <copumpkin> newtype X = X Int
19:47:23 <copumpkin> newtype Y = Y Int
19:47:24 <aavogt> rather than the same type that just has a different name for instance-selection purposes
19:47:44 <djahandarie> aavogt, that is exactly what this represents in typeclass form
19:48:00 * aavogt just jumped in
19:48:27 <djahandarie> class Newtype n o | n -> o where pack :: o -> n; unpack :: n -> o
19:49:12 <djahandarie> I'm going to think about this more before talking about it further though :P
19:58:59 * ddarius plays Cid's Theme.
20:00:46 <JimmyRcom> does haskell have anything yet like erlang's or go's lightweight threads
20:00:58 <ddarius> Yes, it has lightweight threads.
20:01:09 <FauxFaux> ZING
20:01:20 <kmc> Haskell the language does not, but GHC (the most popular Haskell compiler) implements lightweight threads with automatic select()/epoll() asynchronous IO
20:01:36 <shachaf> kmc: No poll()?
20:01:41 <JimmyRcom> nooooo then why did I learn erlang!?
20:01:44 <kmc> and has had that for some time, though the async IO got better in GHC 7.0
20:01:54 <kmc> shachaf, probably poll() too, also kqueue() on BSD
20:02:10 <shachaf> Is there ever a real reason to use select() instead of poll()?
20:02:41 <ddarius> JimmyRcom: Erlang does distributed computation better than Haskell.
20:03:22 <ddarius> But performance-wise, and "expressiveness"-wise, Haskell is better on the concurrency front.
20:04:21 <Draconx|Laptop> shachaf, select is portable to more ancient versions of unix.
20:05:37 <JimmyRcom> I thought only erlang and go had the lightweight threads thing, I think D has something similar now too. I like erlang's bit syntax, otp and how lists can hold any type though.
20:06:01 <shachaf> Draconx|Laptop: I guess...
20:06:44 <kmc> Haskell lists can hold any (single) type
20:07:04 <kmc> if you need heterogeneous lists, there's almost always a way to encode it in Haskell which also makes it more clear and more compile-time-checkable what you're doing
20:07:29 <kmc> lightweight threads are not part of the Haskell standards
20:07:45 <kmc> but they are implemented by the compiler used for the vast majority of work in Haskell
20:09:03 <djahandarie> copumpkin, hmm... the translation to type families results in some odd behavior
20:09:10 <copumpkin> ?
20:09:23 <JimmyRcom> thanks, I wish I could learn things faster
20:09:56 <ddarius> JimmyRcom: Lightweight thread implementations have been around for decades in several languages.
20:10:11 <djahandarie> copumpkin, feels like stuff isn't happening earlier enough in the type checking
20:10:15 <djahandarie> early
20:10:24 <copumpkin> how so?
20:10:31 <dibblego> JimmyRcom, I implemented Erlang's threads (but less broken) in Java
20:10:43 <dibblego> s/I/we
20:11:06 * ddarius is pretty sure Scheme had "lightweight thread" libraries before Erlang existed.
20:11:19 <dibblego> yeah Scheme was the first actors implementation
20:11:37 <djahandarie> copumpkin, op :: Newtype n => (Orig n -> n) -> n -> Orig n;  op _ = unpack;    ":t op Sum" doesn't typecheck but ":t op Sum $ (Sum 3)" does and works
20:11:47 <djahandarie> (Using an associated type synonym)
20:12:42 <JimmyRcom> I know, kernel level they are super lightweight, but things like pthreads and such set room to worst case scenario. not so easy to set it to grow as you add to it
20:12:57 <copumpkin> djahandarie: that seems odd
20:13:44 <djahandarie> copumpkin,  :t op Sum $ (Sum 1)  =>  op Sum $ (Sum 1) :: (Num t) => Orig (Sum t)
20:13:52 <kmc> JimmyRcom, GHC Haskell also has "sparks" which are used for pure parallel computation
20:14:10 <kmc> basically saying "evaluate this expression in parallel" without needing to create and manage a thread or message channels etc
20:14:18 <applicative> djandarie, are you using 'class Newtype'?  
20:14:24 <ddarius> As well as Data Parallel Haskell and STM.
20:14:30 <Axman6> JimmyRcom: i don't know if anyone's mentioned it yet, but haskell's lightweight threads implementation is faster and more lightweight than both erlang's and go's
20:14:39 <applicative> my third favorite type class. 
20:14:51 <kmc> the nice thing is that you have a simple semantic guarantee -- the expression (par x y) will always evaluate the same as "y", except it might be faster (or slower, if you make a bad decision of what to parallelize)
20:15:03 <djahandarie> applicative, trying to put it into a package with all the base instances declared for you
20:15:19 <kmc> and if threads are lightweight, sparks are featherweight... just pushing a single pointer onto a queue
20:15:27 <dibblego> how does class Newtype look?
20:15:37 <djahandarie> dibblego, fd way or tf way?
20:15:45 <dibblego> fd
20:15:45 <applicative> oh cool.  i tried to piece together a 'libconor' with it, just to amuse
20:16:06 <djahandarie> class Newtype n o | n -> o where pack :: o -> n; unpack :: n -> o
20:16:08 <applicative> t f is the way, isn't that the way it is in Epigram?
20:16:23 <djahandarie> applicative, its in Epigram?
20:16:26 <dibblego> ah got it, thanks
20:17:28 <applicative> djahandarie, it in the 'Kit' just a sec
20:18:23 <JimmyRcom> Axman6: I thought haskell was slower than go. I didn't know the threads were more lightweight, even so it's kinda moot because you can stack size on thread creation. It's something like 350 bytes default.
20:18:49 <applicative> djahandarie, http://hpaste.org/42917/missing_library
20:18:54 <JimmyRcom> kmc: I didn't know about sparks 
20:19:16 <Axman6> JimmyRcom: http://shootout.alioth.debian.org/u32/benchmark.php?test=threadring&lang=all
20:19:19 <djahandarie> applicative, so it seems
20:19:33 <djahandarie> applicative, but that is exactly how I've written it and causes some annoying problems
20:19:51 <Axman6> JimmyRcom: actuall, i should really link to: http://shootout.alioth.debian.org/u64q/performance.php?test=threadring
20:19:51 <djahandarie> Ah
20:19:53 <djahandarie> I think I know why
20:20:20 <djahandarie> copumpkin, think it could be because type families are open?
20:20:45 <copumpkin> djahandarie: nope, it can still see the "o"
20:20:59 <copumpkin> Sum :: a -> Sum a
20:21:14 <djahandarie> Hm
20:21:17 <applicative> here it is in the context, of the rest http://www.e-pig.org/darcsweb?r=Pig09;a=headblob;f=/src/Kit/MissingLibrary.lhs
20:21:20 <copumpkin> that's enough to resolve the typeclass instance
20:21:34 <JimmyRcom> Axman6: thanks, had quit messing with haskell for awhile to mess with go. Thought it was a lot faster.
20:21:46 <copumpkin> or rather, it seems like it should be
20:21:50 <Axman6> depends what you're doing with it
20:21:52 <copumpkin> djahandarie: maybe a ticket is in order?
20:22:06 <Axman6> but haskell has by far the nicest threading support of any language i've used
20:22:06 <djahandarie> copumpkin, I'll try in 7 first :)
20:22:10 <copumpkin> djahandarie: oh
20:22:14 <copumpkin> yeah
20:22:27 <djahandarie> But if it only works in 7 I'm going back to fds :P
20:22:30 <applicative> i dimly remember talking to someone about it several months back, Axman6 maybe?, then later saw he was describing difficulties to conal I dimly remember
20:22:36 <Axman6> the fact that it's also got a super fast threading implementation makes it that much more awesome
20:22:44 * applicative is dimly remembering a lit
20:22:46 <applicative> lot
20:22:57 <Axman6> applicative: what's up?
20:23:08 <djahandarie> copumpkin, worked fine in 7
20:23:25 <copumpkin> djahandarie: oh that's good
20:23:36 <applicative> did you ever try 'class Newclass' ala Conor McB, Axman6?  Someone has experience
20:23:51 <applicative> sorry class Newtype
20:23:56 <copumpkin> that's what we were just talking about!
20:24:02 <copumpkin> :)
20:24:08 <djahandarie> copumpkin, yes, that's why he just brought it up ;)
20:24:22 * ddarius has managed to offload all state into the environment and make this knitting project stigmergetic.
20:24:27 <djahandarie> copumpkin, 7 also handles this nicer op Sum $ (Sum 3) :: Num a => a
20:24:34 <copumpkin> djahandarie: nice :)
20:24:35 <djahandarie> No longer have the gunk
20:24:45 <applicative> I noticed djahandarie was talking about it, but also having difficulty.
20:25:02 <djahandarie> applicative, turns out the TF problem was only do to some bug in GHC 6.13
20:25:04 <Axman6> nope, wasn't me
20:25:05 <djahandarie> due*
20:25:15 <applicative> oh, thanks Axman6
20:25:27 * djahandarie rolls back to fd version
20:25:36 <applicative> djahandarie, oh, I see. 
20:25:54 <applicative> wait, you're rolling back because youre using 6.13?
20:26:11 <djahandarie> I'm rolling back because I want normal people to be able to use this :)
20:26:50 <applicative> djahandarie, anyway, what else is in the module?  the typeclass, 'ala', then familiar instances?
20:27:22 <djahandarie> applicative, also op and under
20:27:33 <djahandarie> I renamed his ala to ala'
20:27:41 <djahandarie> And provided ala pa hof = ala' pa hof id
20:27:57 <djahandarie> Because ala' seems to not usually be required
20:28:01 <ddarius> djahandarie: You may also want to look at Erwig's metamorphic programming.
20:30:05 <john_r_watson> I'm confused as to why using 'arr' (arrows) is not required on functions
20:30:08 <applicative> hm, you need a different witticism, how about ala and qua
20:30:10 <john_r_watson> > (arr (\x -> (x + 5)) +++ (arr id)) (Right 5)
20:30:12 <lambdabot>   Right 5
20:30:18 <john_r_watson> > ((\x -> (x + 5)) +++ (id)) (Right 5)
20:30:19 <lambdabot>   Right 5
20:30:27 <djahandarie> applicative, qua?
20:30:39 <ddarius> @src (->) arr
20:30:39 <lambdabot> arr f = f
20:30:44 <ddarius> That's why.
20:30:58 <john_r_watson> arr === id here?
20:31:02 <Axman6> @instances Arrow
20:31:03 <lambdabot> (->), Kleisli m
20:31:05 <copumpkin> yeah, that's the only thing that can work
20:31:14 <Axman6> @src Kleisli arr
20:31:14 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
20:31:17 <copumpkin> how many (a -> b) -> (a -> b) functions do you know?
20:31:26 <applicative> Jones, qua Mayor, castigated her; but as her son, he could only praise here
20:31:37 <john_r_watson> I see.  So if I defined an instance for "stream functions" as Wadler puts it
20:31:42 <djahandarie> copumpkin, id, id . id, id . id . id, id ... id
20:31:57 <john_r_watson> like type SF = { runSF :: ([a] -> [b]) }
20:32:12 <dibblego> \f -> Kleisli (return . f)
20:32:28 <ddarius> copumpkin: I can think of at least five.
20:32:37 <john_r_watson> where arr = SF (map f)
20:32:41 <applicative> some of the lamdabot witticisms are over my head:  BOB says: You seem to have forgotten your passwd, enter another!
20:33:03 <john_r_watson> would that cause the compiler to complain?
20:33:03 <ddarius> djahandarie: Those are observationally equivalent.
20:33:11 <applicative> djahanderie, what is under
20:33:38 <copumpkin> ddarius: now pick the most defined of those!
20:33:55 <john_r_watson> nope...
20:34:07 <copumpkin> john_r_watson: you need an f in that definition
20:34:08 <ddarius> copumpkin: Touché
20:34:18 <applicative> djahanderie, did you see the various -cafe posts advertising class Newtype and 'ala'; the had some illustrations.
20:34:19 <djahandarie> applicative, just unpack . f . pack
20:34:27 <djahandarie> No I didn't
20:34:34 <djahandarie> I just stumbled upon it in some video :P
20:34:39 <djahandarie> Thanks to copumpkin 
20:34:47 * copumpkin beams
20:35:00 * applicative was into it before it was cool.
20:35:24 <Axman6> what is this Newtype class thing anyway :\
20:35:29 * applicative , rather, wanted to be into it, before wanting to be into was cool.
20:35:33 <john_r_watson> copumpkin: righteo arr = SF . map
20:35:43 <copumpkin> john_r_watson: I can believe that
20:35:52 <applicative> Axman6, echt conorism
20:36:00 <john_r_watson> copumpkin: I think I can see how the compiler is so smart... kinda
20:36:12 <john_r_watson> copumpkin: to run the stream function arrow, you have to to call runSF
20:36:23 <copumpkin> yeah
20:36:40 <applicative> Axman6 http://hpaste.org/42917/missing_library see line 48 ff
20:37:03 <john_r_watson> :t arr
20:37:03 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
20:37:56 <djahandarie> applicative, only think I'm uncovering about this on -cafe is posts from Conor himself
20:39:35 <applicative> yes, that's all I meant.  here's one with fd  http://www.haskell.org/pipermail/haskell-cafe/2008-February/039007.html
20:41:01 <applicative> to which the customarily sullen Bulat responded: "oh! i remember faces of my friends when i showed them something like "sortOn snd . zip [0..]". probably i have the same face now :)))"
20:43:31 <djahandarie> copumpkin, I suppose it's worth saying that the fd version only requires two lines for your instance while the tf version requires three :P
20:43:46 <copumpkin> yeah but the first line is longer!
20:43:53 <djahandarie> Though the tf version might be able to avoid flexible instances...
20:44:00 <applicative> yes, but the tf version is beautiful and casts a flood of ligh
20:44:05 <applicative> light
20:44:11 <copumpkin> my thoughts exactly
20:44:32 <alpounet> tf generally look better
20:44:49 * djahandarie starts fd vs tf flamewar
20:45:01 <aavogt> sometimes it's the other way:      class C a b | a -> b, b -> a
20:45:12 * kmc gleefully retrieves his can of gasoline
20:45:20 * applicative is trying to think how to arm himself for tf-defensism
20:45:59 * djahandarie turns on Holy Wars by Megadeth
20:46:24 * applicative consigns fd to the Dustbin of History
20:46:45 * dmwit prefers tf2
20:47:22 * applicative wonders, tf2 ,tf2 whats this ... tf2?
20:47:36 <applicative> applicative wants it whatever it is
20:47:37 <dolio> Team Fortress 2.
20:47:38 <aavogt> dmwit: that one gets properly done superclass equality :p
20:47:41 <applicative> ha
20:48:06 <aavogt> the AT initialism seems to have died
20:49:03 <aavogt> or did whatever paper that introduced types associated with classes not do 'type family T a'?
20:51:17 <dolio> I think the original associated type proposal required such things to be declared in classes.
20:51:50 <dolio> And it didn't have any of the superclass constraint machinery that gets bundled with type families.
20:52:02 <dolio> So they weren't as powerful as functional dependencies.
20:52:26 <dolio> Or, constraint machinery in general, not just superclass constraints.
20:53:04 <aavogt> so just a substitute for     class Container bag thingy | bag -> thingy where head :: bag -> thingy   etc.
20:53:14 <dolio> Right.
20:57:17 <dolio> Many (most?) associated type fundeps require undecidable instances to be enabled, which is a little unsavory, too.
20:57:48 <dolio> Whereas associated types (and type families) don't have that problem for the relevant forms.
20:58:18 <dolio> So they're a little nicer in some ways for the cases they cover.
21:09:27 <edwardk> hrmm, looking for an operator to use like <|> without empty, best i have so far is <!>. ideas?
21:09:46 <edwardk> (to go with <.> in functor-apply)
21:10:19 <dibblego> oh I will smooch that operator
21:10:24 <dibblego> I know the one
21:10:41 <edwardk> it gives streams append, etc.
21:10:44 <dibblego> <||>
21:10:57 <edwardk> <||> is on the short list =)
21:11:24 <dibblego> .<|>.
21:11:42 <edwardk> i think i want to stick to 3 character symbols for symmetry with alternative
21:11:56 <edwardk> which kind of leaves me with <!>
21:11:59 <dibblego> yeah
21:12:10 <edwardk> okay, i've convinced myself ;)
21:12:19 <aavogt> <#>
21:12:31 <edwardk> # never looks good in a symbol ;)
21:12:51 <aavogt> which leads people to think it's illegal
21:13:06 <edwardk> yeah
21:13:37 <edwardk> i think <!> works, since the FunctorApply stuff is <.> they look related
21:14:21 <applicative> djahandarie keep us informed of your module Newtype where.. .   I gave up after I found my libconor was already in the Kit section of Epig.
21:14:55 <ddarius> !/^|^\!
21:15:38 <djahandarie> applicative, yep sure
21:16:11 <djahandarie> ala Endo foldMap is neat in its expressiveness :)
21:16:21 <dibblego> for sure
21:17:28 <djahandarie> I just wish there were a mconcatMap for the sake of making some type signatures easier to look at
21:23:54 <edwardk> okay, one last name-hunt. when working with FunctorAlt, i find that some of these want to be able to offer a unit, (e.g. Map k) offers FunctorApply (but no pure/return) based on intersectionWith, but (<!>) with union, but there is a unit for union
21:24:06 <edwardk> so what i'm looking for is another name for empty ;)
21:25:18 <edwardk> best i have so far is nil
21:26:30 <djahandarie> It'd sure be nice if the way things were layed out didn't require coming up with all sorts of names for things when they are all really the same thing
21:26:40 <edwardk> yeah
21:27:01 <edwardk> alas, this is the language we have
21:31:08 <azaq231> Why not simply emptyFA (FunctorAlt), in analogy to liftA / liftM
21:31:24 <ian_mi> it is rather frustrating that (+) requires all of Num
21:31:35 <Axman6> ian_mi: why?
21:31:52 <edwardk> mostly because the M suffix is used inconsistently and in an ad hoc fashion
21:32:02 <Axman6> just make the others call error "foo not defined" or something
21:32:19 <edwardk> the documentation for Control.Monad specifies what the name is supposed to mean, but if you look, half the time its not used that way in that selfsame module ;)
21:32:21 <ian_mi> Axman6: because I would like to use + for operations in all sorts of non numeric groups
21:32:39 * djahandarie throws type safety out the window with Axman6
21:33:15 <edwardk> now i just need good names for a functorapply with semigroup-like alternative and one with monoid-like alternative
21:33:18 <Axman6> ian_mi: and you can't just use import Prelude hiding ((+))
21:33:18 <ddarius> ian_mi: There are alternate Preludes that are more supportive of traditional algebraic structures.
21:33:20 <Axman6> ?
21:33:36 <ian_mi> Axman6: I still like to use numbers sometimes
21:33:47 <Axman6> well tough ;)
21:34:01 <edwardk> ian_mi: there is a Data.Monoid.Sugar module in my monoids package that gives you (+) for any monoid (maybe semigroup, i don't recall)
21:34:22 <edwardk> then provides an annoying set of monoids for the standard numerical types to make that make sense
21:34:27 * ivanm grumbles about the fact that his testsuite for graphviz is suddenly taking 3 times as long as usual
21:34:31 <ian_mi> edwardk: I was just going to suggest something like that :)
21:34:36 <ddarius> edwardk: Clearly the correct solution is just to omit a character from the monoid case to indicate the semigroup case.
21:34:37 <djahandarie> The real question is why there would be semigroups in the monoid package
21:34:48 <edwardk> ddarius: ring vs rng hahahah
21:35:07 <edwardk> djahandarie: why do you think i made a semigroups package! =)
21:35:34 <ddarius> djahandarie: One is hard pressed to avoid that as every monoid is a semigroup.
21:35:36 * djahandarie sees the day when there is only a single function in each package
21:35:43 <edwardk> Functoring and Functorng â€” easy to tell apart ;)
21:36:14 <djahandarie> ddarius, heh, touche
21:36:25 <ddarius> djahandarie: The day after we decide that modularity is overrated?
21:37:15 <cdsmithus> djahandarie: Yep, to every function its own module, and to every function parameter its own type class.
21:38:27 * djahandarie just hopes everything works out and goes back to coding
21:38:34 <ivanm> cdsmithus: you've forgotten one module per package!
21:39:34 <edwardk> meh, i guess i don't care about the nil case enough to warrant a typeclass for it
21:40:02 <edwardk> since it'll never come up on a ComonadApply
21:40:24 <ian_mi> edwardk: I can't understand why something like that is not the default Prelude class layout
21:40:49 <edwardk> ian_mi: they have Alternative, but i needed something just slightly weaker than Applicative, upon which Alternative is based
21:41:20 <edwardk> i'd be fine if i wasn't such a purist ;)
21:42:25 <ian_mi> I mean seperating the concepts of + and *, making numbers monoids under + by default
21:43:00 <edwardk> ian_mi: the short answer is that Num was put together because it was good enough to handle the stuff that was in the Prelude
21:43:18 <edwardk> and this was a long long time ago when everyone was getting started and it was a brave new world
21:44:11 <edwardk> plus there is a camp that views that monoid should only be used when its unambiguous for the type. i.e. which semigroup do you mean on Int? you have the min semigroup, the max semigroup, the (+) semigroup the (*) semigroup the first semigroup the last semigroup, etc.
21:44:29 <Axman6> who've thought they might not have thought ahead 20 years to how people might eant to use things that didn't exist yet
21:44:48 <edwardk> personally i'm of the camp that says to choose one, and let folks make newtype wrappers if they don't like your choice ;)
21:45:20 <edwardk> yeah haskellers are a lot more tolerant of generalizations now that we are confident that the compilers are doing the right thing ;)
21:45:21 <ian_mi> right, well additive seems to be a sensible default
21:45:24 <Axman6> couldn't you use the first and last semigroups for any monoid?
21:45:53 <edwardk> Axman6: yeah, it was just an example of how you could bolt a semigroup onto any type, if not usefully
21:45:55 <Axman6> (assuming i understand what that means...)
21:46:48 <ian_mi> do you think Prelude will ever see a major overhaul?
21:47:06 <Axman6> not in one go, but slowly
21:47:15 <edwardk> very likely, they just kind of declared open season on fixing a lot of standing issues
21:47:40 <edwardk> will it go as far as i'd like? probably not, but there are deeper language issues that'd need to be addressed to allow that
21:47:45 <ddarius> Clearly the default semigroup for all numeric types should be the tropical semigroup.
21:47:58 <edwardk> at least it'd be warm
21:48:08 <edwardk> plus, Floyd-Warshall becomes easy!
21:48:17 <edwardk> and its a full semiring ;)
21:48:33 <ddarius> edwardk: Do we have a semiring class?
21:48:35 <edwardk> so there is no problem with num
21:48:38 <edwardk> in monoids
21:48:46 <ddarius> Ah yes.
21:48:46 <ivanm> Axman6: haven't you seen the latest messages on libraries@ ?
21:48:51 <edwardk> or at least 0.1.36 of monoids
21:48:59 <ivanm> they're proposing a committee to make wide-sweeping changes to base
21:49:35 <edwardk> thats one of the reasons why i'm playing with comonads now
21:49:38 <azaq231> max semigroup as in semigroup with binary operation a `max` b = if a > b then a else b?
21:49:51 <Axman6> i don't follow any of the mailing lists, too high traffic
21:49:56 <edwardk> really thats an excuse, i just had some time and an urge to fix the transformers after someone asked if there was a standard comonad library
21:50:01 <Axman6> the SNR is too low for my liking
21:50:07 <edwardk> azaq231: yeah
21:50:15 <ivanm> Axman6: whinger! :p
21:50:29 <ivanm> Axman6: it's called "just skip boring threads"
21:50:29 * ddarius will never get used to "whinger."
21:50:43 <ian_mi> as opposed to IRC?
21:50:45 <ddarius> ivanm: He does.  He skips them all.
21:50:50 <ivanm> ddarius: lol
21:50:52 <Axman6> heh
22:11:52 <edwardk> hrmm, this is the third time in as many days that i've been able to find something that works like a comonad, sans extract.
22:12:35 <dibblego> what does that mean?
22:12:36 <edwardk> mostly just stuff that started to become possible once flipping over to talking about semigroups, etc.
22:13:01 <edwardk> meaning you can duplicate/extend it, its a functor, but there is no extract
22:13:15 <copumpkin> what is this one?
22:13:44 <edwardk> Cokleisli composition, using the functor alt machinery to glue together the comonads
22:14:43 <edwardk> basically its the the exponent comonad/cowriter sans the ability to generate mempty, (because otherwise you'd be able to derive anything)
22:15:09 <edwardk> so duplication glues together the two comonads with <!> or the equivalent
22:15:25 <copumpkin> interesting
22:15:35 <edwardk> (maybe (<.>) i haven't checked which works better, probably <.> on the face of it, because it has a law respecting extract
22:16:52 <edwardk> yeah it works a lot nicer for ComonadApply's
22:19:22 <edwardk> i was trying to see if the existence of Alt was enough to make a comonad out of a cokleisli arrow
22:19:39 <edwardk> but it obviously can't be, because you need something to feed the function
22:19:48 <edwardk> the other was the Observable type that i have
22:20:43 <edwardk> the best I can do for it is Observable a -> Task a â€” where Task is a monad.
22:20:53 <edwardk> but it has duplicate/extend
22:23:10 <edwardk> the some/many overloads in Alternative don't need the unit of the semigroup either
22:56:43 <BMeph> Is there a "minMax" function, similar to "divMod" and "quotRem"?
22:57:38 <c_wraith> Uh.  Does there need to be?  The point of divMod and quotRem is that they do the calculation once.  You can write minMax yourself, to only do the comparison once
22:57:39 <dibblego> @type min &&& max
22:57:40 <lambdabot> forall b. (Ord b) => b -> (b -> b, b -> b)
22:57:42 <Axman6> not that i know of, but it would be handy to have
22:57:59 <dibblego> @type min *** max
22:57:59 <lambdabot> forall b b'. (Ord b, Ord b') => (b, b') -> (b -> b, b' -> b')
23:07:11 <copumpkin> minimumMaximum, maybe
23:15:19 <edwardk> hrmm, the Applicative (Either a) instance is missing in base
23:16:05 <edwardk> they added the Monad and Functor to Control.Monad.Instances, but the applicative didn't come along for the ride
23:16:26 <copumpkin> lol
23:19:22 * hackagebot semigroups 0.3.2 - Haskell 98 semigroups  http://hackage.haskell.org/package/semigroups-0.3.2 (EdwardKmett)
23:21:23 * hackagebot functor-apply 0.7.4 - Strong lax semimonoidal endofunctors (Applicative sans pure)  http://hackage.haskell.org/package/functor-apply-0.7.4 (EdwardKmett)
23:21:44 <newsham> cwraith: map a Data.Monoid wrapper over the inputs, then mconcat them?
23:22:22 <edwardk> :t foldMap (Min &&& Max)
23:22:23 <lambdabot> Not in scope: `foldMap'
23:22:23 <lambdabot> Not in scope: data constructor `Min'
23:22:23 <lambdabot> Not in scope: data constructor `Max'
23:23:00 <djahandarie> I don't think semigroups is in lambdabot yet :P
23:23:03 <edwardk> with functor-apply installed it'd be Data.Semigroup.Traversable.foldMap1 (Min &&& Max) ;)
23:23:05 <edwardk> ;)
23:23:43 <edwardk> er Data.Semigroup.Foldable
23:23:53 <newsham> why foldable vs monoid?
23:24:13 <edwardk> Min and Max don't form a monoid
23:24:19 <edwardk> (without bounds)
23:24:39 <edwardk> Data.Semigroup.Foldable adds operations to fold with a semigroup over non-empty containers
23:25:15 <newsham> edward: what about Min of [Maybe Num] ?
23:25:27 <newsham> ahh.. I se
23:25:28 <newsham> see
23:25:35 <wagle> anyone know what happened to rubrication.net?
23:25:52 <edwardk> newsham: you can use Option in semigroup to add a unit to Min and Max
23:26:08 <edwardk> so Min is just a semigroup but Option (Min Integer) is a monoid
23:26:09 <newsham> sounds like a lot of abstractions! :)
23:26:13 <edwardk> not really
23:26:17 <edwardk> Option is Maybe
23:26:21 <newsham> the do he Maybe trick for First in Data.Monoid
23:26:23 <edwardk> its just doing what Maybe does
23:26:36 <xcthulhu> I am doing a lot of FPGA design lately, but I despise VHDL.  Has anyone here had any luck with bluespec?
23:26:40 <edwardk> Data.Semigroup exports a First and Last that don't have the nested Maybes as well
23:26:51 <newsham> makes sense
23:27:01 <xcthulhu> I understand it compiles to verilog; what's the over-head like?
23:27:02 <edwardk> that way its factored out and you only pay for it if you need it
23:27:14 <Axman6> xcthulhu: i've heard quite good things
23:27:16 <edwardk> bluespec is pretty sweet stuff
23:27:53 <xcthulhu> hmm... any good pointers on where to get started?
23:27:59 <edwardk> xcthulhu: i wouldn't worry too much about it, the nice module abstraction machinery should let you get efficiencies in other areas ;)
23:28:53 <xcthulhu> edwardk, Well... I'm trying to do 2D barrell shifters on a spartan3 so gates are sort of precious
23:28:56 <edwardk> i'll admit i'm somewhat sad that the underlying haskell-ish compiler is being used to compile such a clunky surface language though
23:29:04 <edwardk> i wish you luck =)
23:29:08 <Axman6> i thought bluespec was something you had to pay for, am I wrong?
23:29:15 <xcthulhu> I think so too
23:29:19 <edwardk> it is
23:29:28 <edwardk> they are just here in the area
23:29:29 <Axman6> well that's no fun
23:29:59 <edwardk> and the previous boston haskell admin used to work for them
23:30:00 * Axman6 has a spartan3
23:30:15 <xcthulhu> Axman6, armadeus?
23:30:23 <Axman6> ?
23:31:00 <xcthulhu> It's the spartan3 package I'm using.  It's pretty sweet... it has an arm and a spartan3, and the arm runs linux
23:31:07 <xcthulhu> So you can do linux based JTAG
23:31:50 <xcthulhu> Best FPGA design flow I've ever had
23:31:55 <Axman6> oh i think i have heard of that. but no, not what i have
23:32:05 <Axman6> it;'s a pegasus (sp?) board
23:32:36 <edwardk> i've been trying to get my arm to run linux for a while, but the closest i can get is spinning the CD in my fingers.
23:32:36 <xcthulhu> cool
23:32:59 <Axman6> edwardk: heh
23:33:01 <newsham> shoulda gone with a StrongARM
23:33:17 <Axman6> CD's spinn faster with StringARMs
23:33:18 <Axman6> -n
23:33:26 <newsham> xthulhu: sounds like a nice bitcoin board :)
23:39:11 <xcthulhu> newsham, I definitely recommend.  I'm sort of kicking myself for buying an ADC USB peripheral before finding this thing
23:49:55 <lispy_> lambdabot: behave.
23:50:01 <lispy_> ?botsnack
23:50:01 <lambdabot> :)
23:50:13 <lispy_> Cale: CPU usage on lambdabot is oddly high.  Not sure why.
