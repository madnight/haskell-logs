00:00:15 <jeffwheeler> I'm profiling for the first time, and I'm super confused by warnings suggesting I use -fspec-constr-count=n because some special function "has two call patterns."
00:00:39 <jeffwheeler> give me a second and I'll paste the code and warning
00:01:32 <jeffwheeler> http://hpaste.org/paste/42918/profiling_annotation
00:01:49 <Axman6> jeffwheeler: i think they're safe to ignore
00:01:57 <Axman6> it's a ghc7 thing i believe
00:02:09 <jeffwheeler> Axman6: any idea what activates it? Should I send that flag?
00:02:19 <Axman6> no need afaik
00:02:25 <jeffwheeler> fair enough
00:02:54 <Axman6> i think it's just a warning, and ghc just does the right thing anyway
00:02:57 * Axman6 -> beer
00:03:06 <jeffwheeler> it seems to work fine, yeah
00:03:13 <jeffwheeler> (although my code is still slow . . . :P)
00:20:51 <hvr> is the -fspec-constr-count=n warning threshold going to be changed in ghc 7.0.2?
00:21:36 <lars9> can parsec parse a decimal number? didn't find that function
00:22:15 <lars9> @hoogle decimal
00:22:15 <lambdabot> Text.Parsec.Token decimal :: GenTokenParser s u m -> ParsecT s u m Integer
00:22:15 <lambdabot> Text.ParserCombinators.Parsec.Token decimal :: GenTokenParser s u m -> ParsecT s u m Integer
00:22:16 <lambdabot> Data.Char DecimalNumber :: GeneralCategory
00:23:05 <lars9> hoogle rocks
00:25:13 <vv> hi
00:31:03 <jeffwheeler> Hmm, I'm having trouble interpreting my heap profile, but it seems somewhat unusual.
00:31:04 <jeffwheeler> http://i.imgur.com/lq78R.png
00:32:00 <jeffwheeler> I suppose this means that the entire list is getting calculated (last argument to g), and then it's slowly worked through.
00:32:45 <jeffwheeler> . . . but this can't be right, because then I'd expect /many/ small triangles (since I have about 500 numbers that it's doing f on).
00:33:14 <jeffwheeler> It seems like everything should be totally cleared in between calls to f.
00:35:30 <jeffwheeler> (This could make sense if this were the write buffer, but that doesn't seem to be the case since "main" never uses up much memory. It's all in g and isSq.)
00:35:47 <jeffwheeler> Much to my surprise, memoizing isSq made the program far slower . . .
00:37:18 <olsner> maybe that's stack space from main iterating the list (not sure stack space shows up in heap profiles though)
00:37:45 <lars9> @hoogle digital
00:37:46 <lambdabot> No results found
00:38:06 <olsner> or if the "entire list" is about 45-50k you're just holding on to the head of it somewhere?
00:39:43 <lars9> @hoogle fromMaybe
00:39:43 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
00:39:57 <Saizan> jeffwheeler: is (x-y^2) supposed to be x - (y^2) or (x-y)^2 ?
00:40:10 <jeffwheeler> x-(y^2)
00:40:51 <jeffwheeler> Saizan: the algorithm works correctly. It finds the number of sums of two squares that result in the given number.
00:41:19 <jeffwheeler> The input file is a bunch of numbers, where the first number specifies the number of remaining numbers for which the algorithm needs to be applied.
00:41:40 <jeffwheeler> I.e. 25 -> 2, because 0^2 + 5^2 = 25 and 3^2 + 4^2 = 25.
00:41:51 <Saizan> jeffwheeler: n is a lazy accumulator, it might be that
00:42:12 * jeffwheeler opens back up the code
00:42:24 <Saizan> add some bangs to it :)
00:43:10 <Enigmagic> that would be my suggestion too
00:43:16 <Saizan> in both equations, and to lastSq too while you are at it
00:44:13 <jeffwheeler> I had tried bangs to those before, but I had also done it to (y:ys) which slowed things down significantly. I guess that forces it to evaluate the entire big list?
00:44:20 <Enigmagic> lastSq should be forced every iteration already
00:44:35 <jeffwheeler> Adding bangs to !n and !lastSq improves it just a tiny amount.
00:44:55 <jeffwheeler> . . . actually, not at all when recomparing.
00:45:10 <Saizan> jeffwheeler: a bang like !(y:ys) does nothing
00:45:41 <jeffwheeler> Hmm, then what did I do. Something caused it to jump up to 5 seconds from about 1.8. Let me see if I can repeat it.
00:45:59 <olsner> you could... venture into the core and see if the enumFromTo gets merged into g and f as you'd want
00:46:05 <jeffwheeler> Oh, maybe that's when I re-enabled profile.
00:46:41 <jeffwheeler> I was seeing if I could use the llvm core. Does the profiling stuff work with -fllvm?
00:46:42 <Saizan> i'd also use the other kind of profiling that gives you the type of what's using memory
00:47:30 <Saizan> all the slowness might come from read, btw
00:47:59 <jeffwheeler> I don't think so. If I just replace f with (+2) or something, it's super fast.
00:48:42 <jeffwheeler> I'd expect this to put something in tmp/: ghc -O3 --make squares.hs -fllvm -tmpdir=tmp/ -keep-llvm-files
00:49:09 <jeffwheeler> I can't seem to get the ll file to come out.
00:52:37 <Enigmagic> jeffwheeler: try deleting the .hi/.o files or using fforce-recomp
00:53:15 <Enigmagic> i've found -keep-llvm-file/-keep-llvm-files to not be super reliable otherwise
00:53:32 <jeffwheeler> Enigmagic: oh, duh . . . sorry, the no output from ghc should have given that away. I did that earlier too.
00:54:03 <Enigmagic> :)
00:55:56 <Saizan> are you sure the non-improvements weren't caused by that?:)
00:56:25 <jeffwheeler> Saizan: nah, that only happens when you don't change the code
01:03:32 <jeffwheeler> Doh, when you ask GHC to keep the llvm files, it doesn't put it in the tmpdir.
01:03:51 <jeffwheeler> That makes sense and explains why I couldn't find it.
01:04:29 <jeffwheeler> (Wow . . . this is huge.)
01:07:25 <Enigmagic> jeffwheeler: run 'opt -O3 -S filename.ll' to trim it down somewhat
01:07:55 <jeffwheeler> Enigmagic: neato, I'd never used 'opt' (new to llvm)
01:08:53 * jeffwheeler now compares against the reference C++ implementation
01:10:27 <olsner> you can also try looking at the ghc-core output, I think it'll be easier to read than the llvm assembly
01:20:53 <jeffwheeler> Saizan, Enigmagic, olsner: thanks all for your help; I'll play with this more tomorrow
01:20:56 <olsner> jeffwheeler: the y^2 gets compiled into something returning Integer, after replacing that with y*y, the core looks prettier but there's still an intermediate list being constructed and destroyed
01:21:54 <olsner> to get rid of that, the most straight-forward way seems to be to add explicit iteration to 'g'
01:22:45 <jeffwheeler> olsner: what do you mean? I thought that's what I was doing by doing recursion by hand?
01:22:53 <jeffwheeler> (as opposed to some map+filter)
01:23:05 <olsner> I mean take y and ymax instead of a list
01:23:36 <jeffwheeler> Oh, that makes a lot of sense actually.
01:25:01 <jeffwheeler> Also, the y*y trick improves it significantly. Why does that do so much?
01:25:10 <jeffwheeler> I guess mult is super fast.
01:25:17 <jeffwheeler> (especially integer mult)
01:25:54 <olsner> the one thing left in the core after these is properFraction (sqrtDouble# (int2Double# ...)), doesn't look like that function has a nice inlineable implementation for doubles
01:26:24 <jeffwheeler> olsner: what did you do to generate what you're looking at?
01:26:40 <Jafet> y^2 shouldn't be slower than y*y. Unless y is pretty small, then the overhead of mpz_pow shows.
01:26:53 <olsner> jeffwheeler: ghc-core, just cabal install it :)
01:27:10 <Enigmagic> or you can use -ddump-stg
01:27:40 <olsner> Jafet: y is an Int here, but y^2 ends up using Integers for some reason
01:27:41 <jeffwheeler> Jafet: I guess there are enough small numbers. That alone brings the program from 1.6s to 1.1.
01:27:52 <Saizan> ?type (^)
01:27:53 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
01:28:08 <Saizan> the type of the exponent is not the same as the base
01:28:14 <Jafet> Oh. Then you just want a type annotation?
01:28:16 <Saizan> y^(2 :: Int)
01:28:28 <Saizan> though y*y might still be faster
01:29:12 <Saizan> maybe if you define g as a foldl' it'll get fused
01:29:31 <Jafet> ghc might do that optimization; I feel llvm is almost certain to do that optimization
01:29:37 <jeffwheeler> Ah, yeah, the type annotation brings it down to about 1.2 from 1.6. The y*y version does it in 1.1.
01:29:48 <Jafet> Or perhaps not
01:30:03 <quicksilver> I'm not sure llvm *can* do that optimisation, because by the time it gets to llvm, it doesn't look like y^2 any more?
01:30:33 <Jafet> Hm, what does (^) for Int look like down there?
01:30:38 <quicksilver> it just looks like a jump to a procedure (which happens to calculate powers)
01:30:39 <Enigmagic> quicksilver: it could be done with a custom optimization pass in llvm
01:30:45 <quicksilver> Enigmagic: *nod*
01:30:50 <Enigmagic> but the built-in optimizers won't pick it up, for sure.
01:31:21 <jeffwheeler> I saw the foldl' in the RWH chapter. They left that for strictness annotations in something like my g.
01:31:47 <jeffwheeler> Also, I didn't see how to stop foldl' midway through, and assumed just doing nothing for the rest of the list would be slow.
01:32:31 <Saizan> yep, it would
01:32:57 <Saizan> (i forgot about the early exit)
01:33:10 <jeffwheeler> no worries
01:34:09 <Enigmagic> heh
01:34:31 <Enigmagic> try flipping the order of the first two args
01:35:06 <jeffwheeler> . . . what the hell?
01:35:18 <jeffwheeler> That improved things hugely.
01:35:27 <Enigmagic> :)
01:35:47 * jeffwheeler goes to test the C program again, see if it beats it.
01:37:01 <Saizan> n and x ?
01:37:12 <Enigmagic> nm
01:37:26 <jeffwheeler> Saizan: yeah
01:37:41 <Saizan> why does that help?
01:37:42 <jeffwheeler> It dropped from 1.1s to 0.02s.
01:38:34 <jeffwheeler> wait a second
01:38:47 <Enigmagic> i think you missed the other half of the change
01:38:49 <jeffwheeler> Oh
01:38:51 <jeffwheeler> yep
01:38:55 <jeffwheeler> :D
01:39:17 <jeffwheeler> Well, it's safe to say we can print numbers really fast!
01:39:36 <Enigmagic> anyways i gotta pass out
01:39:46 <jeffwheeler> Enigmagic: alright; thanks a bunch for the help
01:40:19 <olsner> with isSq x = x == y*y where y = truncate (sqrt (fromIntegral x)), the assembly looks pretty nice
01:40:42 <olsner> at least with -fllvm, -fasm wants a function call for sqrt
01:42:18 <jeffwheeler> I'm hesitant to say things are improved significantly . . . but this time I checked the output and it's correct.
01:42:32 <jeffwheeler> How did you come up with that?
01:43:00 <olsner> you mean why I changed it, or that particular formulation?
01:43:12 <jeffwheeler> Well, that particular formulation.
01:43:43 <olsner> well, simplest way I could think of
01:44:21 <jeffwheeler> So when you're looking at the ASM, I'm trying ghc-core squares (no extension, the binary)
01:44:27 <jeffwheeler> And I'm searching for isSq?
01:44:41 <jeffwheeler> It doesn't seem to be a label, but just some embedded code.
01:44:58 <olsner> isSq is inlined into g, but you can see the test in the code for g
01:48:05 <jeffwheeler> How do you find the g implementation in the assembly? Is it the one .Lc10g?
01:49:10 <jeffwheeler> I see a bunch of mainN (1-5); not sure what to make of these.
01:49:10 <olsner> the entry point is "Main_mainzuzdszdwg_info", the actual inner loop is somewhere after that
01:49:34 <Twey> preflex: zdec mainzuzdszdwg
01:49:34 <preflex>  main_$s$wg
01:50:17 <jeffwheeler> What is the s, w?
01:51:17 <jeffwheeler> I see a Main_main_info. Does it not start there?
01:53:04 <olsner> main starts there, but that only does that boring lines/read/show/unlines stuff :)
01:53:15 <jeffwheeler> olsner: ah, yep
02:02:42 <olsner> jeffwheeler: hmm, is it just me or does f always return x+1?
02:03:07 <jeffwheeler> Sorry, I've got vim busy with a long macro. Give me a second.
02:03:43 <jeffwheeler> olsner: no, it definitely shouldn't. (f 25) should be 2.
02:03:55 <jeffwheeler> olsner: let me upload the current code.
02:04:21 <jeffwheeler> http://hpaste.org/42922/profiling
02:05:06 <mux> looks like some project euler code
02:05:08 <jeffwheeler> olsner: my version drops the first line, so let the file be "0\n0\n1\n2\n3\n25"
02:05:26 <jeffwheeler> mux: a friend showed it to me, it was in the Facebook Hackers Cup
02:05:34 <jeffwheeler> (the problem, I mean)
02:05:43 <mux> ah
02:06:28 <jeffwheeler> olsner: 0 -> 1 (0^2+0^2), 1 -> 1 (0^2+1^2), 2 -> 1 (1^2+1^2), 3 -> 0, 25 -> 2 (0^2+5^2, 3^2+4^2)
02:06:38 <mux> btw, there are faster ways to check if a number is a square, based on its digits (some just can't appear in a square)
02:06:50 <mux> this is especially true if you're dealing with big numbers
02:07:01 <jeffwheeler> mux: sporadically large, yes
02:08:26 <jeffwheeler> mux: this? http://www.haskell.org/haskellwiki/Generic_number_type#isSquare
02:08:54 <jeffwheeler> mux: actually, that doesn't talk about opts, nevermind
02:09:07 <olsner> in the range of an Int, I doubt anything involving the digits will be much faster - it's just a handful of instructions to sqrt, truncate, multiply, compare
02:09:52 <mux> yes, I meant if you *really* have big numbers, in which case it pays a lot
02:11:21 <olsner> I guess those rules work just as well if you treat bytes as digits in base-256? that seems like it could be pretty fast for bignums
02:11:45 <jeffwheeler> Well, at this point the haskell version is only 30% slower than the C version. That's not too bad.
02:12:02 <jeffwheeler> Originally it was a few hundred orders of magnitude, so this is definitely a big improvement. :)
02:12:11 <jeffwheeler> (way before the versions I first posted here)
02:12:34 <olsner> a few hours in #haskell and still slower than C :(
02:12:37 <Jafet> "The most efficient way is to call the native implementation of the square root of GNU's multiprecision library. (How to do that?)"
02:12:41 * Jafet snickers
02:13:33 <mux> that's cheating :-)
02:14:03 <Jafet> That's currently impossible, because ghc overloads the gmp malloc in such a way that you can't use it from ffi
02:14:23 <jeffwheeler> For what it's worth, the isSquare here is very, very, very slow: http://www.haskell.org/haskellwiki/Euler_problems/191_to_200
02:14:27 <Jafet> Unless you explicitly add a binding in integer-gmp
02:14:57 <Jafet> (Unless you build ghc with integer-simple I guess, which seems questionable also)
02:15:57 <jeffwheeler> Anyways, it's super late here, so I'm off to bed. Thanks a bunch for the help.
02:18:52 <bcsubdiv> hola
02:19:18 <bcsubdiv> I'm not much of a programmer, but I have the following mathematical situation:
02:19:46 <bcsubdiv> Let RelPos denote the category of finite poset pairs W c P
02:19:58 <bcsubdiv> (a finite poset and a subposet)
02:20:27 <bcsubdiv> we define the following functor RelPos->Relpos
02:22:02 <bcsubdiv> the pair P,W maps to the poset of injective maps from finite linearly ordered sets
02:22:50 <bcsubdiv> and its subposet of weak equivalences is determined by the so-called last vertex map
02:24:53 <bcsubdiv> that is, a morphism f=[n]->[m]=g (over P, necessarily injective) in this new poset is a weak equivalence if the induced map fn->gm is in W
02:25:36 <bcsubdiv> What I'd like to program is something that considers the case where P=[2] and W is the minimal poset containing the identities
02:25:42 <bcsubdiv> (subposet rather)
02:25:51 <bcsubdiv> and then draws it
02:26:09 <bcsubdiv> as an undirected graph, this is simply the barycentric subdivision
02:26:57 <bcsubdiv> but considering all of the information, it's somewhat more
02:27:32 <bcsubdiv> is there an easy way to do this in haskell?
02:27:52 <bcsubdiv> because doing it through java is a huge pain. =(
02:31:27 <Jafet> Everything in Haskell is easy in hindsight
02:31:39 <Twey> Heh
02:31:47 <Twey> We should make that our slogan
02:31:51 <Twey> Haskell: It's Easy.  In Hindsight.
02:31:53 <sipa> Everything is easy in hindsight
02:32:16 <Saizan> what do you mean by [2] ? poset with 2 elements?
02:32:27 <Jafet> He's dead, jim.
03:10:05 <ManateeLazyCat> Hi all, i'm back. :)
03:10:56 <qfr> Hmm no ghc7 in the Arch Linux package manager? :[
03:17:41 <copton> in the data definition "data Position = Position String !Int !Int", what is the meaning of the exclamation points?
03:18:20 <ManateeLazyCat> copton: Don't lazy.
03:18:37 <ManateeLazyCat> copton: Mean "evaluate immediately".
03:18:39 <Saizan> copton: it means that the Position constructor will be strict in those parameters
03:19:34 <Saizan> copton: i.e. Position s undefined i = undefined; Position s i undefined = undefined.
03:27:44 <path[l]> hi, is this sort of pattern matching allowed http://hpaste.org/42923/pattern_matching_question
03:31:44 <Saizan> x-1 isn't
03:31:59 <path[l]> ah ok
03:32:07 <path[l]> so I have to use a guard clause for it
03:32:31 <Saizan> yeah
03:33:16 <Saizan> using the same variable twice is already not allowed, actually
03:37:00 <quicksilver> ManateeLazyCat: welcome back!
03:38:28 <ManateeLazyCat> quicksilver: Thanks, i find a Android job, I can contribute to haskell community after work. :)
03:38:49 <quicksilver> ManateeLazyCat: Does your android job involving getting haskell to work on android?
03:39:08 <ManateeLazyCat> quicksilver: No, use Java develop Android application. :)
03:39:28 <ManateeLazyCat> quicksilver: Java is bread language. :)
03:39:36 <ManateeLazyCat> quicksilver: Haskell is dream language. :)
03:40:11 <ManateeLazyCat> quicksilver: I have a HTC-G7, running Android 2.2, i will find some time play Haskell on it. :)
03:40:44 <quicksilver> ManateeLazyCat: good luck with both your bread and your dreams, then!
03:40:55 <ManateeLazyCat> Thanks. :)
03:42:31 <exDM69> waiting for a haskell variant on the JVM
03:42:48 <ManateeLazyCat> exDM69: Possible. :)
03:42:58 <ManateeLazyCat> But i more like any language running on LLVM. :)
03:43:22 <sipa> what is HTC-G7 ?
03:43:34 <exDM69> LLVM does not have a garbage collector and other high level VM bells and whistles
03:43:38 <ivanm> why is it that for some reason the first time I run a program it takes 5 min, but subsequent runs take about 10? :s
03:43:40 <Twey> path[l]: Nesting brackets too deeply makes code hard to read
03:43:55 <exDM69> but I prefer LLVM and static/JIT compilation to a simple virtual machine
03:43:58 <ManateeLazyCat> sipa: http://images.google.com.hk/images?gbv=2&source=hp&hl=zh-CN&q=htc+g7&btnG=%E6%90%9C%E7%B4%A2%E5%9B%BE%E7%89%87&aq=f&biw=1366&bih=679
03:44:09 <quicksilver> exDM69: haskell has been ported to the JVM once or twice
03:44:22 <exDM69> quicksilver: cool
03:44:23 <quicksilver> such efforts always seem to bitrot because nobody cares about them.
03:44:25 <ManateeLazyCat> sipa: Newest Google phone running Android 2.2
03:44:37 <quicksilver> Android, of course, runs Dalvik not JVM
03:44:45 <path[l]> Twey: oh ok thanks
03:45:19 <exDM69> quicksilver: yeah, I imagine in order to gain traction, you'd have to be able to use Java libraries efficiently
03:45:21 <ManateeLazyCat> quicksilver: I have play Android one day, to be honest, very cool .:)
03:45:24 <sipa> ManateeLazyCat: ok, it's called htc desire here i think
03:45:41 <exDM69> I don't like the whole concept of dalvik
03:46:04 <sipa> why not?
03:46:19 <ManateeLazyCat> exDM69: dalvik to avoid patent. :)
03:46:23 <Twey> path[l]: I'd probably write it like this: http://hpaste.org/paste/42923/pattern_matching_question_ann#p42924
03:46:42 <ManateeLazyCat> exDM69: Android is too, change driver layer to around GPL.
03:46:48 <sipa> it's basically java bytecode with register allocation already done
03:46:54 <Twey> path[l]: You can also use view patterns to do something closer in form to what you originally intended, but you just end up with more brackets and it's not that nice in this case
03:47:31 <path[l]> I dont understand line 3 :o
03:47:55 <ksf> http://themonadreader.wordpress.com/2011/01/09/issue-17/
03:48:00 <ksf> InterleaveT is cool
03:48:11 <exDM69> sipa: it's just plain useless, android could run native apps or do anything, now they have a proprietary VM and compiler and are not benefiting from compiler/VM improvements done by others
03:48:48 <exDM69> I work with android kernel/drivers/software stack at work
03:48:58 <exDM69> it's got a really crappy userspace
03:49:23 <ManateeLazyCat> exDM69: I'm newbie to Android... :)
03:49:45 <exDM69> so am I, only done a month of this work and I don't even have an android phone
03:49:52 <ksf> well, you _do_ get access to the hardware.
03:49:57 <ksf> that is, can run native code.
03:50:07 <EliasAmaral> exDM69, android has a proprietary vm and compiler?
03:50:15 <EliasAmaral> õ.o
03:50:16 <ManateeLazyCat> exDM69: Your company haven't give your Android phone?
03:50:18 <exDM69> EliasAmaral: yeah, the dalvik VM
03:50:19 <ManateeLazyCat> exDM69: For test?
03:50:26 <sipa> it's open source
03:50:31 <EliasAmaral> i supposed it were free software
03:50:32 <sipa> it may not be standard-compliant
03:50:35 <Twey> Not proprietary, but novel
03:50:35 <ksf> not all library interfaces are native, too, but then that doesn't matter for non-performance stuff, anyway.
03:50:42 <sipa> but it is not proprietary
03:50:47 <Twey> It's open-source AFAIK
03:50:55 <Twey> And possibly free, too
03:50:59 <exDM69> ManateeLazyCat: I will get an android phone but I don't use that for deving, we have these cool dev boards with not-yet-released HW and SW
03:51:00 <ksf> yep.
03:51:23 <ManateeLazyCat> exDM69: I see. :)
03:51:25 <quicksilver> exDM69 uses proprietary in the less-loaded sense not related to freeness.
03:51:44 <quicksilver> It simply means "they use their own VM developed in house instead of a standard one"
03:51:52 <EliasAmaral> oh
03:51:55 <exDM69> yes, exactly
03:52:13 <sipa> in that case he is right
03:52:21 <ksf> well, who can blame them for not wanting to be tied to oracle.
03:52:21 <EliasAmaral> i heard their vm has better performance than most/all jvm
03:52:42 <ksf> I bet they're going to offer something llvm-based relatively soon.
03:52:51 <ksf> just wait for NaCl to mature a bit.
03:52:58 <sipa> it substantially decreases the work that needs to be done by the JIT/interpreter
03:53:06 <ManateeLazyCat> EliasAmaral: yeah, that's true. :)
03:53:17 <ksf> jvm bytecode is the sux.
03:53:23 <EliasAmaral> i heard that register-based vms has better performance than stack-based ones. but to be honest i don't know if dalvik is register-based
03:53:26 <ksf> it's actually java with a wee bit less sugar.
03:53:42 <exDM69> dows anyone know if LLVM JITting is fast enough for this type of VM's?
03:53:47 <exDM69> EliasAmaral: yeah, it's register based
03:53:48 <sipa> exDM69: davlik is register based
03:53:55 <sipa> *dalvik
03:54:04 <exDM69> EliasAmaral: however, I don't know if it uses an infinite number of registers like LLVM does
03:54:12 <sipa> i don't think so
03:54:13 <ksf> llvm is easy to compile down to machine code.
03:54:13 <quicksilver> ksf: yes, it's a terrible design for a generic bytecode. Much much *much* too tied to language semantics.
03:54:33 <exDM69> so they might have to do register allocation when JITtin
03:54:44 <quicksilver> ksf: it was pretty obvious they'd got it wrong when even the modest changes from java 1.0 to java 1.1 required VM changes, because the old VM was too tied to the java 1.0 way of doing things.
03:55:09 <sipa> i think dalvik doesn't require register allocation by the JIT, that's the point
03:55:20 <ksf> spewing out unoptimised arm code for llvm assembly should be _really_ fast.
03:55:35 <ksf> I wouldn't even use an interpreter.
03:56:04 <exDM69> sipa: that would require all dalvik software to run on a CPU where there's at least a certain number of registers and if there's more, there's no perf gain
03:56:17 <ksf> that is, compiling that should be faster, even for large programs, than starting up a behemoth like the jvm.
03:56:27 <sipa> exDM69: agree
03:56:34 <sipa> i'm not sure though
03:57:07 <exDM69> LLVM jit requires the runtime to link with LLVM and C++ stdlib
03:57:29 <exDM69> which hinders it's portability a little
03:57:38 <ksf> not really
03:57:48 <ksf> there is, after all, gcc.
03:58:13 <ksf> well, llvm has to run on the architecture too, of course
03:58:35 <exDM69> exactly, and ATM f.ex. android can't do C++ exceptions
03:58:36 <Bynbo7> it can compile itself, so in theory should run on any architecture llvm can compile to
03:58:36 <sipa> exDM69: there are 65536 registers apparently in dalvik, but some instructions are only allowed to access the first 16 or 256
03:58:42 <ksf> but that should be a given unless you design your own processor, and using ELF isn't soooooo hard, either.
03:59:17 <sipa> so the JIT indeed needs to do some register allocation still
03:59:28 <ksf> llvm relies on exceptions?
03:59:32 <exDM69> sipa: yep, that confirms it
03:59:41 <gb345> hi everyone . i'm trying to understand the haskell notation for type class definitions; in GHC.Base, the "constant function" is described as "const :: a -> b -> a"; but this means that, for example "double x _ = 2 * x" fits this description; obviously, this double function is not a constant; therefore i figure that there must be some additional constraints on const, but i can't find them; are there? if so where? if not, what's the use
03:59:41 <gb345> of having such a loose definition of what a "constant" is?
03:59:43 <ksf> not for critical stuff, I hope.
04:00:01 <exDM69> ksf: I'd recon they do. They use the C++ standard library extensively, which would be pretty crippled without exceptions
04:00:05 <sipa> but if you have eg. 16 registers in hardware, the first 16 could be mapped to the hw regs, and the rest to memory
04:00:08 <exDM69> someone could confirm this
04:00:26 <ksf> const x y = x
04:00:29 <ksf> that's all there is.
04:00:39 <ksf> otoh,
04:00:49 <ksf> :t double x _ = 2 * x
04:00:50 <lambdabot> parse error on input `='
04:00:50 <quicksilver> gb345: a type definition does not necessarily describe a function entirely.
04:00:55 <Bynbo7> gb345: that definition does not meet the same type as const
04:00:59 <ksf> :t let double x _ = 2 * x in double
04:01:00 <lambdabot> forall t t1. (Num t) => t -> t1 -> t
04:01:05 <ksf> see the num constraint?
04:01:07 <quicksilver> gb345: the fact that const has type "a -> b -> a" does not necessarily mean it is the only function with that type.
04:01:25 <Bynbo7> const x = \_ -> x
04:01:25 <quicksilver> [although in an interesting sense it happens to be the only function with that type, but that's by the by]
04:01:27 <ksf> quicksilver, but it is.
04:01:49 <quicksilver> ksf: not in haskell it isn't. (unfortunately?)
04:01:56 <ksf> modulo bottom.
04:02:09 <ksf> and unsafeCoerce.
04:02:21 <Bynbo7> well, there's const _ _ = undefined, const x y = const x y
04:02:30 <gb345> ksf: i see
04:02:33 <quicksilver> anyhow, the point is (gb345) that types do not always uniquely determine functions.
04:02:34 <Bynbo7> :t let const x y = const x y in const
04:02:34 <ksf> that's both bottom.
04:02:35 <lambdabot> forall t t1 t2. t -> t1 -> t2
04:02:38 <quicksilver> the type is a description not a definition.
04:03:03 <ksf> fast and loose reasoning is morally correct, but you have to shout MODULO BOTTOM at #haskell.
04:03:04 <Bynbo7> ksf: yeah, i started typing before you mentioned bottom :)
04:03:12 <gb345> quicksilver, i know, but then i'm not sure what's the use of that definition
04:03:26 <quicksilver> gb345: what makes you think it's a definition?
04:03:36 <quicksilver> gb345: the definition of const is "const x y = x"
04:03:43 <gb345> declaration, statement, whatever you want to call it
04:03:57 <quicksilver> type declarations are useful because they tell us something interesting about types
04:04:02 <quicksilver> and the compiler uses them to check things
04:04:08 <gb345> ok, where is that definition?
04:04:09 <ksf> > maybe 2 (const 3) $ Nothing
04:04:09 <lambdabot>   2
04:04:17 <ksf> > maybe 2 (const 3) $ Just 42
04:04:17 <EliasAmaral> http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
04:04:17 <lambdabot>   3
04:04:23 <ksf> > maybe 2 (*2) $ Just 42
04:04:24 <lambdabot>   84
04:04:57 <quicksilver> gb345: search for "const" in http://www.haskell.org/onlinereport/standard-prelude.html
04:05:03 <quicksilver> the definition is there.
04:05:03 <jacobian> Is there a wan to get the nth element of a tuple without pattern matching? 
04:05:07 <quicksilver> jacobian: no.
04:05:14 <ksf> jacobian, yes.
04:05:18 <jacobian> haha
04:05:19 <jacobian> :)
04:05:20 <Bynbo7> heh
04:05:20 <ksf> @hackage nthable
04:05:21 <lambdabot> http://hackage.haskell.org/package/nthable
04:05:25 <quicksilver> I meant 'not in the standard libraries)
04:05:34 <Bynbo7> oh man, i was going to write that package ages ago
04:05:34 <quicksilver> whereas ksf is pointing you to a package which can do it.
04:05:48 <Bynbo7> can it do it for all tuples?
04:05:49 <jacobian> nice
04:05:59 <Bynbo7> oh gross
04:06:00 <quicksilver> my unjustified belief is that any program which uses (or needs to use) nthable is broken.
04:06:09 <ksf> defined up to 7
04:06:11 <Jafet> Tuples are broken
04:06:12 <jacobian> yeah
04:06:13 <jacobian> Weird
04:06:16 <gb345> in ghc's Prelude.hs "const" is mentioned exactly once, but there's no equal sign next to it (i.e. it's not defined there)
04:06:17 <Bynbo7> quicksilver: i agree
04:06:25 <jacobian> Mostly I don't use more than 7 tuples though
04:06:25 <ksf> well, thrd can come handy.
04:06:39 <Bynbo7> jacobian: you shouldn't be using more than 4 tuples
04:06:44 <ksf> and if you need it it's nice to have fst and snd work on your 3tuples, too.
04:06:45 <ivanm> gb345: probably defined in some other module and imported and re-exported from the Prelude
04:06:48 <ivanm> @src const
04:06:48 <lambdabot> const x _ = x
04:06:51 <quicksilver> gb345: it's almost certainly imported from somewhere.
04:07:01 <quicksilver> gb345: ghc's Prelude.hs is not particularly readable
04:07:13 <gb345> ok, i'll look some more.  ty
04:07:14 <quicksilver> gb345: unless you are handy with reading import declarations and multi-file-search
04:07:15 <jacobian> I was recently using sequents with 3 contexts, (fctx,vctx,tctx,t,ty)
04:07:35 <ivanm> @djinn a -> b -> a
04:07:35 <lambdabot> f a _ = a
04:07:55 <quicksilver> gb345: however, if you use the online docs at http://haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Prelude.html#v%3Aconst
04:08:03 <quicksilver> gb345: then the 'source' link takes you to the right place
04:08:09 <quicksilver> (turns out to be GHC.Base, in this case)
04:08:18 <quicksilver> the online docs are an easier way to browse the implementation.
04:08:34 <Bynbo7> const                   :: a -> b -> a
04:08:35 <Bynbo7> const x _               =  x
04:08:40 <Bynbo7> ... so much whitespace
04:09:12 <gb345> quicksilver, Bynbo7: thanks! it was right under my nose.
04:10:04 <quicksilver> jacobian: sure, but if that was your standard type you'd be better off with custom named functions.
04:10:18 <quicksilver> jacobian: I'd rather ready "typeContex sqt" than "nth 3 sqt"
04:10:21 <ksf> if you people want to fix tuples, figure out a good way to do oleg-style records without raping the type system.
04:10:22 <quicksilver> s/ready/read/
04:10:25 <exDM69> what is really bitchy about android is that they don't really have a lot of userspace utilities/libs. I have to write some scripts with lua since python/ruby/perl cannot be easily ported to android
04:11:03 <ksf> O GOSH NO NOT LUA
04:11:08 <ksf> (that was sarcasm)
04:11:09 <Bynbo7> hmm, is it possible to write id in pointfree style? I can't think how to define it
04:11:10 <ksf> sorry.
04:11:24 <Bynbo7> (being able to write `id =` would be fun though, heh)
04:11:42 * Twey likes Lua
04:11:47 <quicksilver> Bynbo7: No, you need id or something equivalent as an 'axiom' of your point-free set
04:12:04 <quicksilver> Bynbo7: point free isn't particular magical - it needs all kinds of axioms like (.) id flip fst snd etc.
04:12:08 <ksf> it could use a nicer syntax, but otherwise it's a darn cool language.
04:12:15 <Twey> *nod*
04:12:25 <Twey> The syntax is kind of cool in its own right, too.
04:12:38 <Bynbo7> quicksilver: yeah i was thinking it was too primitive in that sense
04:12:42 <quicksilver> I like lua, but variable scopes being run-time modifiable tables is asking for trouble.
04:12:52 <Twey> Not in a *practical* way, but in a ‘hey look, it's completely unambiguous without separators, that's cool’ kind of way
04:13:01 <Twey> quicksilver: Nahhhh :þ
04:13:13 * Bynbo7 needs to check out lua at some point
04:13:32 <Twey> quicksilver: Lua lets you do evil stuff like that on purpose, so that you can basically adapt it to whatever you need to embed it as
04:13:36 <quicksilver> Twey: sure.
04:13:46 <quicksilver> like lots of bad things, it won't do any harm if you don't do bad stuff with it.
04:14:10 <Bynbo7> like unsafePerformIO
04:14:16 <quicksilver> although I think run-time variable lookups also makes some optimisations harder.
04:14:32 <quicksilver> it definitely makes static analysis harder.
04:14:40 <ksf> Twey, can you elaborate on that unambigious thing?
04:14:40 <quicksilver> (which in turn makes it harder to write secure code)
04:14:45 <Jafet> Bynbo7: id = ap const const
04:14:46 <Twey> quicksilver: E.G. in one of my current projects I'm using setters in combination with that to allow unannounced introduction of arbitrarily-named free mathematical variables à la SimpleReflect
04:14:50 <Jafet> (Duh)
04:15:02 <quicksilver> Twey: Yes. I've done neat tricks with it too.
04:15:14 <Bynbo7> :t ap const const
04:15:15 <lambdabot> forall b. b -> b
04:15:15 <ksf> lua isn't supposed to be a safe language, it's supposed to run sandboxed.
04:15:18 <Twey> ksf: You don't need to separate statements in Lua with e.g. semicolons or linebreaks
04:15:22 <quicksilver> Twey: although my neat tricks have mostly been with opposite intent - to *forbid* accidental declaration of new variables.
04:15:29 <Bynbo7> Jafet: heh, thanks :P
04:15:39 <Bynbo7> :t ap const
04:15:40 <lambdabot> forall b a. (b -> a) -> b -> b
04:15:42 <Twey> ksf: The grammar is carefully designed to always be unambiguous as to where a statement ends
04:15:54 <Jafet> Bynbo7: I = SKx
04:15:57 <Twey> Which is awesome, if not all that practically useful
04:16:05 <Twey> quicksilver: Haha, fair
04:16:18 <Bynbo7> x?
04:16:42 <Jafet> x is any combinator (at least in untyped calculus)
04:16:42 <ksf> a, b, c = x, y, z, x, y, z = d, e, f?
04:16:56 <ksf> oh wait yeah
04:16:57 <ksf> hmmm.
04:17:28 <Bynbo7> that looks fairly ambiguous to me...
04:17:38 <ksf> it's not valid, either.
04:18:10 <Bynbo7> well, that's ok then :)
04:18:10 <ksf> a, b, c = x, y, z x, y, z = d, e, f   is valid
04:18:25 <ksf> ...and the separation is where the , is missing.
04:18:51 <Bynbo7> interesting
04:19:03 <Bynbo7> heh, that feels so barkwards
04:19:37 <ksf> yep.
04:19:50 <ksf> haskell's optionally-layout syntax is better.
04:20:24 <Tomsik> I was just thinking yesterday, why is there no RPN functional languages, that'd let you throw away all these damn parenthesis
04:20:27 <ksf> the {;} thing is useful for generating code and awkward situations, and layout is easy to read and write.
04:20:39 <ksf> there's forth
04:20:48 <Twey> Tomsik: Cat
04:20:52 <Jafet> Isn't joy in rpn?
04:20:54 <Twey> ksf: FORTH is not functional >.>
04:21:02 <Twey> Yeah, Cat, Joy
04:21:09 <ksf> well and monadic programming isn't imperative.
04:21:17 <Jafet> Well, forth functions well
04:22:10 <Twey> Factor is also not purely functional, but a pretty okay functional language
04:22:21 <Tomsik> Hmm, okay, I see
04:22:24 <Twey> (it's better at it than, say, Python, at least)
04:22:37 <Tomsik> Though I was thinking more along lines of postfix lisp on steroids
04:23:05 <Jafet> Python is like driving with the handbrake on.
04:23:59 * Teapot whistles as he codes in Python.
04:25:31 <Twey> Haha
04:25:33 <Twey> Hi, Teapot
04:25:49 <Teapot> Heya :)
04:25:56 <Twey> Tomsik: Sounds like Factor (‘postfix Lisp on steroids’)
04:26:15 <EliasAmaral> In Joy, the meaning function is a homomorphism from the syntactic monoid onto the semantic monoid
04:27:41 <Twey> EliasAmaral: Haha, I saw that
04:27:50 <Twey> ‘Oh, alright then.’
04:27:55 <Twey> ‘… a whatnow?’
04:28:19 <Jafet> It means you can now use cat as your code editor
04:29:00 <EliasAmaral> it sounded nice but i haven't understood
04:29:11 <EliasAmaral> clicking on monoid didn't helped, on the contrary
04:29:14 <Twey> Jafet: Haha
04:29:24 <Twey> EliasAmaral: Well, we all know what a monoid is!  :þ
04:29:30 <Twey> :t mappend
04:29:31 <lambdabot> forall a. (Monoid a) => a -> a -> a
04:29:35 <Jafet> If you pretend Joy programs are functions, then composition of programs is equivalent to composition of those functions
04:29:46 <Jafet> (For some value of "functions")
04:29:56 <Twey> Ah
04:30:13 <Twey> Isn't that the point of concatenative languages?
04:30:22 <EliasAmaral> Twey, yeah we know, with the exception of me
04:30:35 <EliasAmaral> @src mappend
04:30:35 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
04:30:43 <Twey> EliasAmaral: It's a class method
04:30:51 <Jafet> Also, Joy functions "take stacks and return stacks". Which is a pretty vacuous way of calling the denotational semantics the denotational semantics.
04:31:01 <Twey> Jafet: Heheheh
04:31:25 <Jafet> It does beat the lisp (values ...)
04:37:49 <ksf> so... is ghc going to switch to git or are the darcs developers going to produce a glorious hack to protect their honour?
04:38:14 <Entroacceptor> they didn't already?
04:38:15 <Bynbo7> i thought the hashed storage thing was supposed to fix a lot of the problems they were having
04:38:30 <Bynbo7> though, i tell you what, after using git quite a bit, i'd love to see them move
04:40:29 <Twey> What were the problems they were having?
04:42:36 <Tomsik> heh, I can't find factorial or fibbonacci in Factor
04:42:51 <Twey> Tomsik: I dare you to ask slava for them :>
04:43:15 <Tomsik> salva?
04:43:43 <Tomsik> I would like also to see ADTs :p
04:43:54 <Twey> Tomsik: http://rosettacode.org/wiki/Fibonacci_sequence#Factor
04:44:22 <Tomsik> and I wonder why there are no out-of-the-box catamorphisms for ADTs
04:44:23 <Twey> Tomsik: http://rosettacode.org/wiki/Factorial#Factor
04:44:41 <Bynbo7> that hurts to read :(
04:45:20 <Twey> Tomsik: slava's the guy who did most of Factor
04:45:26 <Twey> Hugely prolific
04:45:28 <Tomsik> ah
04:45:43 <Bynbo7> does bi give its first argument to its second and third argurments?
04:45:45 <Twey> But he hates academic examples like Fibonacci and factorials :þ
04:46:33 <Tomsik> well, no idea why, looking at this fibb
04:46:36 <Tomsik> :p
04:47:02 <ksf> Entroacceptor, Twey http://www.haskell.org/pipermail/glasgow-haskell-users/2011-January/019752.html
04:47:46 <Twey> Bynbo7: Yeah
04:48:05 <Twey> Bynbo7: It's pretty nice to read, if you're used to concatenative languages
04:48:31 <Twey> ksf: Ick
04:49:03 <Bynbo7> Twey: yeah.. i'm not at all used to them, so it hurts :P
04:49:17 <Twey> Fair enough
04:49:24 <Twey> I've always found them nicer than other languages to read
04:49:38 <Twey> Straight left-to-right, no confusing stuff
04:49:48 <Twey> No bracket nesting or operator precedence to keep track of
04:50:03 <Twey> Well… Factor kind of does, with quotation brackets and so on :-\
04:50:16 <quicksilver> instead, you have to keep track, mentally, of the contents of the stack
04:50:21 <quicksilver> so you can see what is being operated on
04:50:29 <quicksilver> quite a similar challenge to bracket nesting, IMO
04:50:38 <Bynbo7> yeah
04:50:40 <quicksilver> (technically, I think you could say it's *exactly* the same challenge, in fact)
04:50:49 <Twey> quicksilver: Sure, but that's much less difficult
04:51:09 <Twey> s/difficult/error-prone/
04:51:12 <ksf> you can at least nest visibly.
04:51:23 <ksf> annotating the stack needs more than whitespace.
04:51:43 <Twey> ksf: You'd be surprised what clever application of whitespace can do
04:52:00 <ksf> I know, whitespace is turing-complete.
04:52:22 <Twey> Heheh
04:52:54 <ksf> the design space for esoteric languages is getting really thin, isn't it?
04:53:40 <Twey> Starting to
04:53:43 <ksf> though I think one could always extend the intercal -> c++ -> ??? line.
04:53:49 * Twey laughs.
04:54:28 <Tomsik> A finite-state automata with two counters is turing-complete
04:54:38 <Tomsik> Why there is no language based on *that*
04:54:52 <Tomsik> I mean, brainfuck, that's just lame man
04:54:58 <Jafet> PLEASE DO COMPILE IN LIMIT MINUTES 15;
04:55:22 <ksf> the graphs aren't easy syntax-wise.
04:55:24 <Zao> Jafet: Have a tea break.
04:55:45 <quicksilver> ksf: you can use indentation to signify the size of the stack at that point (relative to its size at procedure entry point)
04:55:45 <ksf> needs ordinary definitions
04:55:58 <quicksilver> but personally I'd rather have the *types* of the stack and that's a bit harder in whitespace
04:56:08 <ksf> exactly.
04:56:17 <EliasAmaral> Tomsik, two unbounded counters? i guess you need only one
04:56:24 <Jafet> Are stack-based languages good for parallelization?
04:56:30 * Twey tries to make an INTERCAL++ joke, but gives up.
04:57:16 <Jafet> EliasAmaral: you need two, if your instructions are limited to increment, decrement, and conditional branch.
04:57:27 <Jafet> (ie. counters)
04:57:36 <Tomsik> EliasAmaral: I'm not sure if you don't end up with a push-down automata then
04:57:48 <EliasAmaral> oh, hm, sure
04:57:48 <Tomsik> maybe this depends on actions you're allowed to take
04:57:56 <EliasAmaral> two stacks == turing complete?
04:58:03 <Tomsik> I remember that two counters with -- and ++ is okay
04:58:07 <Tomsik> EliasAmaral: yeah
04:58:29 <Tomsik> it's harder to show that two stacks with just one stack symbol is TC though :p
04:58:31 * EliasAmaral trying to imagine
04:59:08 <EliasAmaral> i suppose they are wildly different than a turing machine but you can do some trick to transform algorithmically them to a turing machine
04:59:19 <Tomsik> just two stacks: imagine a TM with tape being a zipper :p
04:59:42 <Tomsik> (left_of_tape, current:right_of_tape)
04:59:49 <EliasAmaral> a zipper? like zipWith?
05:00:09 <Tomsik> Nah, it's something like, you keep left of the list(reversed), current and right part of the list
05:00:19 <EliasAmaral> oh, hm
05:00:21 <Tomsik> and you can move head in const time and modify current position too
05:00:38 <EliasAmaral> yes, the TC changes each one from just one side
05:00:39 <Tomsik> and obviously you can easily get more tape
05:00:43 <EliasAmaral> like a stack
05:01:10 <Tomsik> to move, you pop one stack and put it on the other one
05:01:21 <Tomsik> (the popped element)
05:01:51 <Jafet> And you can buy more and more disks to store the swapped-out bits of tape
05:01:55 <EliasAmaral> yes o.o
05:03:14 <Tomsik> Jafet: what o.O
05:03:29 <Tomsik> This is blasphemy
05:04:57 <Boxo> Can anyone help me with a bit of elementary type theory? Here's my question...
05:05:06 <Boxo> Several documents say that (|-) is the typability relation on (Contexts x Terms x Types). But whenever I actually see (|-) used it has a single context to the left and a term and a type to the right of it.
05:05:50 <Tomsik> Well, it's just turnstile
05:05:54 <Boxo> But wikipedia says that "a binary relation on a set A is a collection of ordered pairs of elements of A". How could (|-) be a collection of ordered pairs of (Contexts x Terms x Types)??
05:05:58 <Tomsik> you probably get some rules
05:06:21 <Tomsik> It ain't binary, is the answer?
05:06:24 <Tomsik> Gotta run, see ya
05:06:55 <opqdonut> Boxo: who says |- is a binary relation?
05:07:11 <Boxo> nobody
05:07:15 <opqdonut> Boxo: as you have observed it is a ternary relation
05:07:15 <Boxo> what kind of relation is it then?
05:07:35 <quicksilver> well, |- is a pretty workhorse symbol used for all kinds of related notions
05:07:45 <opqdonut> yes, but in this type theory context
05:07:46 <gb345> does any of you know what file defines the GHC.Prim module?
05:08:06 <Boxo> Okay, yeah. So (|-) is actualyl a subset of (Contexts x Terms x Types).
05:08:08 <opqdonut> the actual syntax for ternary relation is "... |- ... : ..." of course
05:08:18 <quicksilver> in particular theories (type or otherwise) it may well be binary, trinary etc
05:08:19 <Boxo> just found http://en.wikipedia.org/wiki/Finitary_relation
05:08:33 <quicksilver> gb345: GHC/Prim.hs as you might imagine ;)
05:08:38 <opqdonut> one can view |- as a binary relation on Contexts x Typings
05:08:44 <opqdonut> where Typings = Terms x Types
05:08:52 <quicksilver> gb345: beware with GHC internal files though; they expose many implementaiton details are not entirely written in haskell.
05:09:13 <opqdonut> and e : t is syntax sugar for (e,t) in the set Typings
05:09:49 <gb345> quicksilver, that was my first guess, but I'm not finding it in the distro for ghc-6.12.1
05:09:54 <gb345> i'll look some more
05:10:21 <gb345> e.g. "zsh: no matches found: ghc-6.12.1/**/Prim.hs"
05:11:01 <quicksilver> gb345: hmm I might be wrong, actually, GHC.Prim might be special.
05:11:03 <Boxo> I guess I got confused because I assumed that when I'm told r is a relation on the set A, it means it's a subset of tuples of elements of A. But when A is written as the product of a bunch of sets that means something different.
05:11:42 <opqdonut> Boxo: you are confused because _most_ relations are binary
05:11:48 <Boxo> A ternary relation could be a subset of 3-tuples of elements of A and so on...
05:11:52 <opqdonut> indeed
05:12:07 * FauxFaux prods trac.haskell.org.
05:12:13 <gb345> quicksilver, i'm aware of the fact that the GHC files have non-Haskell details, but sometimes seeing something concrete is the only way i have of nailing what the more general definition is getting at...
05:12:46 <gb345> by GHC.Prim being "special" you mean, not defined in the Haskell source?
05:12:57 <gb345> i guess that would make sense, being Prim...
05:13:05 <quicksilver> gb345: learn in whatever way is best for you :) But beware that some of the implementation details may be misleading.
05:13:14 <quicksilver> it might be glue to Cmm
05:13:15 <gb345> ... too Prim even for Haskell :)
05:13:53 <gb345> I was trying to find a digestible definition of (<-)...
05:14:11 <quicksilver> gb345: <- is syntax
05:14:15 <quicksilver> gb345: it's not a function.
05:14:29 <gb345> yes, but it has to have a meaning, no?
05:14:40 <quicksilver> "do a <- foo; g a" is sugar for "foo >>= g"
05:14:56 <quicksilver> the details of the rewriting are in the report
05:15:11 <gb345> qs: ah, ok, that's what i needed, thanks! ++
05:16:47 <gb345> but, wait a minute, <- also appears in comprehensions, outside of any do { }
05:19:16 <parcs> list comprehensions can be regarded as syntactic sugar for the list monad
05:19:49 <gb345> parcs: ah, ok, that makes sense, thanks ++
05:23:41 <gb345> i guess i'm having a hard time figuring out which definition is derived from which, iow sorting out the "axioms" from the "theorems", as it were; actually, a better way to put it, i'm having a hard time figuring out what's syntactic sugar and what isn't...
05:25:55 <quicksilver> gb345: the online report should make it fairly clear what is syntax and what is not.
05:26:55 <gb345> quicksilver, thanks; i'd hoped that looking at the source code would be quicker, but maybe not...
05:28:28 <b0fh_ua> Hello! Can somebody please explain how can I convert ByteString with 4 bytes read from a file, into Int?
05:29:23 <Bynbo7> b0fh_ua: how do you think you might go about doing that?
05:31:35 <b0fh_ua> I could take each byte, shift it 8, 16 and 24 bits to the right and then sum results
05:31:53 <b0fh_ua> but probably there's something already existing which will just create Int for me?
05:32:03 <zygoloid> gb345: <- is also used in pattern guards. that can sort-of be viewed as being monadic, except you have to imagine that "f | p <- x" is really "f | p <- return x", and "f | expr" is really "f | guard expr".
05:32:12 <b0fh_ua> those 4 bytes are integer encoded as little-endian
05:32:28 <Bynbo7> b0fh_ua: have a look at the binary package
05:32:47 <b0fh_ua> well, http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/Data-Binary.html this one?
05:33:08 <Bynbo7> there's functions like getWord32LE for getting things with certain endianess
05:33:11 <Bynbo7> yes
05:33:47 <gb345> zygoloid, i guess that what you're saying is that "<-" does not have a context-independent semantics?
05:34:17 <ksf> \o/
05:34:19 <Bynbo7> b0fh_ua: http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/Data-Binary-Get.html#g:7
05:34:33 <ksf> haskell is the 41st most popular language: http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html
05:34:48 <aristid> ksf: it
05:34:49 <ksf> which mean's we're still successfully avoiding success.
05:34:58 <quicksilver> gb345: well pattern guards are an obscure (arguably) language extension not part of standard haskell.
05:35:04 <aristid> ksf: it is more popular at github
05:35:17 <b0fh_ua> thanks
05:35:21 <quicksilver> gb345: in standard haskell, <- occurs only in do {} and list comps, and it does mean the same thing in those two places.
05:35:43 <quicksilver> (list comps like do blocks with a couple of extra rules)
05:36:31 <gb345> qs: i'm surprised to learn that guards are not pure haskell...  (!!!)
05:36:52 <gb345> who's responsible for such a dastardly deed?
05:36:55 <Bynbo7> guards are, pattern guards aren't i believe
05:37:28 <cpa> hi there
05:37:28 <ksf> comprehensions aren't monadic in standard haskell
05:37:33 <ksf> they're lists-only.
05:37:33 <BONUS> pattern guards are in haskell 2010 afaik
05:37:39 <cpa> i'm trying to get my head around the state monad
05:37:41 <Bynbo7> foo x | bar x = y | otherwise = z is haskell, foo x | Left y <- x = bar x isn't
05:38:05 <ksf> and I think monadic comprehensions are one of those things that could easily be in h', but as an optional feature.
05:38:11 <cpa> and, as an exercise I'd like to reimplement map using the state monad
05:38:17 <cpa> is it possible?
05:38:23 <ksf> that is, implementations are required to support it as an extension, but it's not the default.
05:38:24 <Bynbo7> ksf: interesting to see Ada at #20
05:38:51 <lars9> @src foldl
05:38:51 <lambdabot> foldl f z []     = z
05:38:52 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
05:38:54 <Bynbo7> cpa: as in map :: (a -> b) -> [a] -> [b] map?
05:39:09 <cpa> Bynbo7: yup
05:39:47 <gb345> ok, but i thought the report mentioned comprehensions; i don't recall it saying that they were an extension; i need to doublecheck...
05:39:49 <Bynbo7> i don't see how you'd use the state monad for that
05:40:00 <b0fh_ua> okay, now - how to convert lazy bytestring into strict one ?
05:40:25 <Bynbo7> b0fh_ua: S.concat . L.toChunks
05:40:38 <b0fh_ua> oh
05:40:52 <cpa> Bynbo7: if you write map using an accumulator, it is some kind of state, right ?
05:41:17 <Bynbo7> how do you write map using an accumulator?
05:41:22 <cpa> as in: map f (x:xs) acc = map f xs (f x:acc)
05:41:24 <cpa> somewhat
05:41:33 <Bynbo7> but that reverses the list
05:41:38 <gb345> ksf, sorry i missed the "monadic" part of what you wrote...  i see what you mean
05:41:50 <cpa> right
05:41:57 <cpa> but i don't really care about that
05:42:04 <Bynbo7> heh, ok
05:42:30 <cpa> so is this a case where I could/should use the State monad?
05:42:47 <Bynbo7> i'm just trying to think of a simple one for you
05:43:16 <aavogt> > let m f (x:xs) = do { tell [f x]; m f xs }; m f [] = return () in runWriter $ m (+3) [1..10]
05:43:17 <lambdabot>   ((),[4,5,6,7,8,9,10,11,12,13])
05:43:26 <Bynbo7> i haven't use the state monad much (i actually find using the State monad transformer easier to think about and use, you can get IO with implicit state basically)
05:43:39 <Boxo> > let mop f xs = go [] xs; go as (x:xs) = go (as++[x]) xs; go as [] = as in mop (*2) [1..3]
05:43:40 <lambdabot>   [1,2,3]
05:43:48 <Boxo> > let mop f xs = go [] xs; go as (x:xs) = go (as++[f x]) xs; go as [] = as in mop (*2) [1..3]
05:43:49 <lambdabot>   Ambiguous type variable `t' in the constraints:
05:43:49 <lambdabot>    `SimpleReflect.FromExpr ...
05:43:50 <mux> real men thread state manually.
05:44:01 <Bynbo7> mux: hear hear
05:44:03 <b0fh_ua> Bynbo7: and how to convert strict bytestring into lazy one ?
05:44:19 <Boxo> > let mop f_ xs = go [] xs; go as (x_:xs) = go (as++[f_ x_]) xs; go as [] = as in mop (*2) [1..3]
05:44:19 <lambdabot>   Not in scope: `f_'
05:44:26 <Bynbo7> b0fh_ua: L.fromChunks . (:[]) :P
05:44:28 <Boxo> damnit
05:44:42 <Bynbo7> (L.fromChunks . (:[]))
05:45:07 <gb345> come to think of it, the fact that the <- notations chosen for list comprehension and for do expressions agree at a higher level of abstraction means that they must have had the monadic interpretation for comprehensions in mind...  i wonder why they did not include monadic comprehensions in the report...
05:45:47 <Bynbo7> haskell used to have monad comprehensions
05:45:50 <applicative> had they already come out against them by then?
05:46:59 <quicksilver> monad comprehension were in haskell 1.x but removed from haskell 98
05:47:05 <applicative> hmm, the 'Comprehending Monads' paper in 1992 , 
05:47:12 <quicksilver> where x is some subset of {2,3,4}
05:47:17 <applicative> quicksilver, thats what I was thinking. 
05:47:21 <gb345> ah, ok, i tend to forget that haskell had been kicking around for about 10-15 years before the report came out...
05:48:00 <applicative> gb345, but it seems someone is trying to reimplement them, right?
05:48:07 <gb345> ...so there's a lot of history, haskell history even, implicit in the notation given in the report
05:48:30 * hackagebot xml-enumerator 0.0.1.1 - Pure-Haskell utilities for dealing with XML with the enumerator package.  http://hackage.haskell.org/package/xml-enumerator-0.0.1.1 (MichaelSnoyman)
05:48:34 <gb345> applicative, i don't know: i'm a rank noob
05:49:00 <applicative> gb345 yeah, not sure where I saw, I think the obnoxious 'subreddit'.  let me look
05:49:09 <aavogt> applicative: I think that's done but you'll have to ask McManiaC for confirmation
05:50:49 <applicative> ah aavogt has information http://www.reddit.com/r/haskell/comments/ecu0w/fun_with_monad_comprehensions/ http://blog.n-sch.de/2010/11/27/fun-with-monad-comprehensions/
05:51:23 <gb345> app, thanks for the links, i'll take a look
05:52:49 <applicative> I see, malcolmw says they were in Haskell 1.4, but the error messages were impenetrable; McManiaC says times have changed its not a problem
05:53:39 * applicative wants to try them, especially with some insane transformed monad ....
05:54:18 <aavogt> just use do notation, it's the same except for the noise from  'guard'
05:54:46 <Saizan> and the final return
05:55:02 <applicative> I can do that for lists too
05:55:05 <aavogt> sometimes that one isn't the right thing
05:55:19 <Saizan> anyhow, if it's a language extension you have to turn on the error messages issue is moot
05:55:28 <gb345> i'm trying to figure out what's what in Control.Mondad's definition "liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }"; i gather that "x1 x2" ranges over all possible values coming from m1 and m2; but i can't figure out what "return (f x1 x2)" means; whose return is this?
05:55:49 <gb345> (dang, it's late!!!)
05:55:50 <quicksilver> the return of the given monad
05:55:59 <aavogt> as in, you end up       [ x2 | ... , x2 <- x ]     if you don't want the return
05:56:04 <quicksilver> "ranges over all values of" is a very listmonad-inspired reading of <-
05:56:15 <quicksilver> monads are not all like []
05:56:55 <gb345> qs, indeed: my brain has not stretched enough yet for full monadic awareness :)
05:56:56 <aavogt> well if they are useful at all, they will somehow let you access some values
05:58:03 <gb345> that's why i was trying to find a general definition of what <- means, beyond the list comp meaning...
05:58:17 <quicksilver> gb345: the general defintion is >>=
05:58:24 <quicksilver> you're not going to understand >>= in five minutes ;)
05:58:34 <gb345> ok, ok, i have to figure that out; thanks!
05:58:46 <quicksilver> gb345: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html is a good start for a programmer
05:59:13 <gb345> qs: wow, that looks really useful, thanks ++ !
05:59:17 <gb345> gotta run now; bye
06:13:42 <comb> @type (<$)
06:13:43 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
06:16:44 <zygoloid> quicksilver: pattern  guards are too part of standard haskell! :)
06:43:12 <copumpkin> ttuegel: 
06:43:12 <copumpkin> airpumpkin2:~ pumpkin$ cabal --version
06:43:13 <copumpkin> cabal-install version 0.9.5
06:43:13 <copumpkin> using version 1.11.0 of the Cabal library 
06:44:12 <copumpkin> sorry, I read the bit about the tests not actually running and thought it described my problem anyway :)
06:44:24 <copumpkin> since I can't for the life of me see cabal even building my tests module
06:44:33 <copumpkin> (or find a suitable .hi or .o file for it)
06:45:00 <cpa> @type ($=)
06:45:01 <lambdabot> Not in scope: `$='
06:45:05 <cpa> dammit
06:45:35 <revenantphx> ahahaha >:D
06:45:40 <revenantphx> Fuck you new school firewalls.
06:45:43 <revenantphx> I have SSH tunnels.
06:45:57 * Zao notifies abuse@
06:46:00 <revenantphx> >_>
06:46:45 <revenantphx> it helps to have an external server to use
06:46:49 <revenantphx> im gonna go test some stuff
06:46:53 <ttuegel> copumpkin: i can't get 'cabal' to build the test module, but i can get it tor work if i make a setup.hs and use that
06:47:12 <copumpkin> hm, a custom Setup.hs ?
06:47:41 <copumpkin> cause I have the usual defaultMain-y one
06:47:58 <titania> hi
06:48:40 <ttuegel> copumpkin: i used the defaultMain one, compiled with ghc --make, and ran that instead of using 'cabal'
06:49:04 <ttuegel> copumpkin: i can't get cabal-install HEAD to build against cabal HEAD for some reason it always finds version 1.10 of cabal
06:49:15 <titania> new to this, just a quick info please? how does haskell compare with prolog?
06:49:24 <copumpkin> ttuegel: yeah, I had to change the constraint in the cabal-install.cabal
06:49:27 <Twey> titania: It doesn't
06:49:44 <Twey> Well, um
06:49:49 <Twey> They're… both programming languages?
06:50:21 <Twey> You can do Prolog-like stuff on top of Haskell, if you're clever enough, but generally we don't
06:50:49 <copumpkin> hmm, building Setup.hs manually claims I'm missing dependencies that are clearly present and active in ghc-pkst list
06:51:37 <ttuegel> copumpkin: that's... um
06:51:44 <copumpkin> :P
06:51:53 <titania> did prolog at Uni 17 yrs ago, can't remember much, but was useful. I made a sort of matchmaking program, to find who was most assorted to who for a love date. Could I do that in Haskell?
06:52:18 <Fuco> you can do anything in Haskell
06:52:19 <copumpkin> Setup: At least the following dependencies are missing:
06:52:19 <copumpkin> fclabels ==0.11.*, she ==0.3.*
06:52:19 <Fuco> so yes
06:52:35 <copumpkin> airpumpkin2:charm pumpkin$ ghc-pkg list | grep fclabels
06:52:35 <copumpkin>     fclabels-0.11.1.1
06:52:36 <ski> titania : both use pattern-matching and recursion, and variables are immutable in both
06:52:38 <ttuegel> copumpkin: ./Setup configure --user
06:52:55 <ski> titania : you probably could
06:52:57 <ttuegel> copumpkin: when you use 'cabal' it adds --user by default
06:53:03 <copumpkin> oh I see
06:53:08 <copumpkin> oh, and now I can see it building the tests
06:53:19 <copumpkin> you're right
06:53:21 <copumpkin> it worked!
06:53:37 <ttuegel> copumpkin: the problem i have now is that i got cabal-install installed, and i still can't reproduce :/
06:53:41 <copumpkin> although it seemed to run them a bunch of times :P
06:53:50 <copumpkin> hmm
06:54:01 <alpounet> titania, you can do that in various ways, including the way you did in Prolog
06:54:15 <ttuegel> copumpkin: it probably only ran once, but there is redundant output
06:54:19 <copumpkin> ah I see
06:54:22 <titania> so let's say for example, John has blue eyes, Mary has brown eyes, John is engineer, Mary is widowed, John is married, so you can't match the two, but you could match Mary with any single who has blue eyes and is engineer. Multiply that by thousands of different qualities for people. Haskell?
06:54:41 <copumpkin> ttuegel: could the issue be that my Test-Suite has a custom   Hs-source-dirs:     tests/ ?
06:55:00 <copumpkin> oh, now it's working
06:55:07 * copumpkin looks confused
06:55:14 <copumpkin> I did this a dozen times yesterday :P
06:55:48 <alpounet> titania, yeah, why not ?
06:56:11 <ttuegel> copumpkin: if it makes you feel better, i reproduced your problem once (but only once) using cabal-install HEAD compiled against cabal 1.10 :/
06:56:44 <copumpkin> weird! :)
06:57:04 <copumpkin> it's definitely been compiled against 1.11 for a while because when I first tried it complained about detailed-0.9 so I had to upgrade
06:57:53 <titania> so one could use haskell as a rule-based engine then? Is it difficult to learn (I've grown older since my young days) and I have less time now than then :) - quick and efficient programing?
06:58:30 <copumpkin> titania: it is quick and efficient, but it takes some time to get used to it, especially if you've used other languages
06:58:34 <copumpkin> and have expectations coming from them
06:59:14 * Bynbo7 senses someone looking to make an OK Cupid killer
06:59:39 <Entroacceptor> titania: it's like learning programming all over again
06:59:54 <titania> honestly, it's so long ago, I'm almost a virgin in programming. Some basic, some pascal, bit of html/css, vba macros, but I'm always trying to look out the box, so perhaps haskell might suit me. I've forgotten most of Prolog anyway
06:59:56 <ski> titania : it might be somewhat easier to do that in a logic programming language, depending on the details of what you want to do, but i certainly expect it to be doable in Haskell without *too* much fuss
07:00:15 <cpa> "/alias hideadd eval set activity_hide_targets $activity_hide_targets $-"
07:00:23 <Bynbo7> titania: http://learnyouahaskell.com/ start here
07:00:25 <ski> titania : i'd suggest both learning Haskell and refreshing Prolog knowledge, of course ;)
07:00:43 <cpa> my bad
07:00:52 <Twey> titania: You can't ‘use Haskell as a rule-based engine’, no
07:00:59 <titania> OK Cupid hahaha, let's try matching one of it more famous member!
07:01:11 <Twey> titania: You can write a rule-based engine in Haskell
07:01:33 <titania> you know the guy who's having some governments very scared hehehe.
07:01:33 <djahandarie> ski, was it you who came up with the Functor flip?
07:01:36 <titania> Twey thanks
07:01:50 <Twey> titania: (in fact I believe there are already some out there that you could use)
07:01:52 <copumpkin> ttuegel: anyway, gotta run, but thanks!
07:01:58 <revenantphx> so how is template haskell.
07:02:02 <ttuegel> copumpkin: no problem!
07:02:10 <revenantphx> Any unknown, out of nowhere gotchas like STL? Or is it clean.
07:02:24 <Twey> revenantphx: Well, it's clean compared to STL…
07:02:33 <titania> ski thanks too, and everyone
07:02:55 <revenantphx> ...?
07:03:06 <ski> djahandarie : i suggested it to Cale, yes ..
07:03:14 <Twey> revenantphx: Template Haskell is not really the same thing as C++ templates
07:03:18 <zygoloid> what would it mean to compare TH to STL?
07:03:21 <titania> writing a rule-based engine, woa... perhaps that's what i might want for my project, but not sure
07:03:24 <revenantphx> Well yes, I get but it's also haskell...
07:03:24 <Twey> revenantphx: More like Lisp macros
07:03:26 <revenantphx> that*
07:03:28 <revenantphx> Twey: sure.
07:03:33 <revenantphx> What I meant is,
07:03:37 <revenantphx> are there any hidden gotchas.
07:03:40 <revenantphx> Or is it a clean system.
07:03:40 <ski> (titania : btw, if you want to ask about Prolog as well, there's a ##prolog channel)
07:03:55 <ski> djahandarie : though i think i've seen the idea in a paper
07:03:56 <Twey> revenantphx: I'm sure there are plenty of hidden gotchas to the uninitiated
07:03:56 <zygoloid> revenantphx: the Language.Haskell.TH stuff is pretty nasty
07:03:59 <titania> ski thanks
07:04:07 <revenantphx> I see.
07:04:11 <Twey> revenantphx: It's a complex and frankly quite hairy system
07:04:18 <revenantphx> why can't it be clean though?
07:04:21 <Twey> But nothing on the order of C++ templates
07:04:21 <zygoloid> revenantphx: mostly because TH uses Q [Dec], but the module works in terms of [Q Dec]
07:04:22 <revenantphx> what cuases the hairyness?
07:04:26 <revenantphx> ..what?
07:04:29 <djahandarie> ski, okay, I was trying to remember who suggested it and all I could remember was that their nick started with an s. :o)
07:04:38 <revenantphx> Q and dec are what?
07:04:46 <zygoloid> revenantphx: Q is the quotation monad
07:04:47 <Twey> Q is the quotation monad
07:04:52 <Twey> Dec is a declaration
07:04:56 <revenantphx> uh...huh...
07:05:05 <zygoloid> (basically it's the monad of compile-time operations which can do fresh name generation and reification and stuff)
07:05:12 <revenantphx> sequence is m [a] -> [m a] yes?
07:05:13 <zygoloid> Q is also a MonadIO
07:05:18 <revenantphx> ah wait, other way around
07:05:21 <revenantphx> :t sequence
07:05:21 <Twey> Other way, yep
07:05:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:05:27 <zygoloid> yeah, the other way around is not in general possible.
07:05:30 <revenantphx> @hoogle m [a] -> [m a]
07:05:31 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
07:05:31 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
07:05:31 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
07:05:35 <revenantphx> aw
07:05:58 <zygoloid> the best you can do is: Q [Dec] -> ([Q Dec] -> Q a) -> Q a
07:06:04 <titania> Bynbo7 OK Cupid killer - actually you're not far off
07:06:13 <Twey> It's possible if you have a value of the type :þ
07:06:15 <Bynbo7> :\
07:06:46 <titania> except that I'm an individual, not a company, I want to do it all myself with all my one writing and rules
07:06:50 <Twey> Oh, wait — you need to go from [a] to a
07:06:50 <Twey> Hmm
07:07:12 <ski> zygoloid : `\q_decs k -> q_decs >>= \decs -> k (map return decs)' ?
07:07:22 <Bynbo7> m [a] -> [m a] is easy... const []
07:07:24 <Bynbo7> >_>
07:07:34 <zygoloid> ski: yeah, that's the one.
07:07:49 <Twey> :t (: []) . liftM head
07:07:50 <ski> zygoloid : but that one's not really useful ..
07:07:50 <lambdabot> forall a (m :: * -> *). (Monad m) => m [a] -> [m a]
07:08:07 <zygoloid> ski: how so?
07:08:10 <Twey> zygoloid: Tada
07:08:23 <Twey> Bynbo7: Oh
07:08:25 <Twey> >.>
07:08:29 <Twey> Yeah.  That.  :þ
07:08:29 <ski> zygoloid : why pass a list of `Q'-actions, all of which are trivial ?
07:08:40 <zygoloid> Twey: that's not the inverse of sequence
07:08:51 <zygoloid> ski: because that's what the TH module requires
07:09:01 <zygoloid> (not that they be trivial, but that it be a list of Q actions)
07:09:03 <Twey> zygoloid: No, but it is of the appropriate type.  *shrug*
07:09:08 <Bynbo7> @djinn Monad m => m (Maybe a) -> Maybe (m a)
07:09:08 <lambdabot> f _ = Nothing
07:09:12 <Bynbo7> :D
07:09:28 <ski> zygoloid : oh, some TH interface wants `[Q Dec]' ? .. ok, that's another thing, then
07:09:41 <Bynbo7> congratulations @djinn, you win at trolling
07:09:54 <Twey> Heh
07:10:00 <zygoloid> @type Language.Haskell.TH.letE
07:10:01 <lambdabot> [Language.Haskell.TH.Lib.DecQ] -> Language.Haskell.TH.Lib.ExpQ -> Language.Haskell.TH.Lib.ExpQ
07:10:22 <zygoloid> ski: yeah, it's a crazy interface. i need to get back to my libraries proposal to fix it...
07:10:23 <Twey> Bynbo7: It gave the same answer you did :þ
07:10:35 <ski> @djinn Monad m => m (rho -> a) -> (rho -> m a)
07:10:36 <zygoloid> (DecQ == Q Dec, ExpQ = Q Exp)
07:10:36 <lambdabot> -- f cannot be realized.
07:10:43 <ski> bah
07:11:17 <titania> Last question, won't bother much more. Can Haskell handle spherical trigonometry calculations?
07:11:27 <Bynbo7> Twey: that's what i was hoping for :P
07:11:42 <Twey> titania: There's a concept in programming called ‘Turing-completeness’.
07:11:48 <Bynbo7> titania: can you do those using.... numbers? if yes, of course it can
07:11:53 <zygoloid> ski: the worst part is that the TH language support works in terms of Q [Dec], so you need to convert whenever you use the module
07:12:11 <Twey> titania: Anything you can do in one Turing-complete programming language (which is most of them), you can do in another
07:12:15 <titania> Twey - euh?? I need to look that up
07:12:23 <Twey> titania: The only difference is the manner in which the task is achieved
07:12:57 <Twey> titania: ‘Can I do <some task that is possible in one programming language> in <another programming language>?’ is therefore not a useful question, assuming both are Turing-complete
07:13:07 <Twey> The answer will always be ‘yes’
07:13:22 <Twey> They may, however, differ in how *easily* you can do it.
07:13:26 <djahandarie> Twey, does this mean total languages suck? :)
07:13:35 <Twey> djahandarie: Clearly ;)
07:13:58 <Twey> (more that I doubt that they're relevant to the problem at hand, or that titania has even heard of them :þ)
07:14:16 <ski> zygoloid : hm, is there a reason for not just having `letE :: [Dec] -> Exp -> Q Exp' ?
07:14:18 <Entroacceptor> Twey: minus hardware interfaces, of course
07:14:23 <titania> you're kind all of you. I'm trying to find out what I need for my new project, it's a long time ago since I did all that and my grey cells are old. But I'm stubborn and willing. Cheers guys
07:14:47 <Twey> Entroacceptor: Yep
07:15:03 <Twey> Well
07:15:04 <djahandarie> Twey, they're relevant in the sense that they aren't Turing complete :P
07:15:13 <Twey> I'm not sure
07:15:29 <Twey> Entroacceptor: Couldn't any hardware interface be represented as part of the tape for a Turing machine?
07:15:46 <Twey> Entroacceptor: Thereby making their support a compiler issue rather than a language one?
07:15:58 <Twey> djahandarie: Haha, alright
07:16:19 <Entroacceptor> mhm
07:16:21 <cdsmithus> Twey: Turing machines are about computation.  I/O isn't part of the picture.  The tape of a Turing machine has no external effect on things outside the machine
07:16:32 <Twey> That's true
07:16:54 <damex> hi, im not familar with haskell but i want to know how to get 2 logs live together with xmonad "  logHook = dynamicLogWithPP $ defaultPP {ppOutput = hPutStrLn xmobar},"  that was with xmobar.  ",logHook = dynamicLogWithPP (myPrettyPrinter dbus)" that with gnome-applet but at the #xmonad ppl not answering and i was decided to try ask here. can someone help me?
07:19:17 <Twey> damex: X is a monad, so you can: logHook = dynamicLogWithPP defaultPP { ppOutput = hPutStrLn xmobar } >> dynamicLogWithPP (myPrettyPrinter dbus)
07:19:24 <Jafet> Tape-mapped IO, a paradigm shift in tarpit computing
07:19:45 <damex> Twey: thx:)
07:20:02 <Twey> A.K.A. logHook = on (>>) dynamicLogWithPP defaultPP { ppOutput = hPutStrLn xmobar } (myPrettyPrinter dbus)
07:20:13 <Twey> But either way it's getting pretty long — you should probably assign some names
07:20:29 <Twey> Also, learn Haskell — xmonad is not designed for people who don't know Haskell.
07:20:37 <Twey> (Bluetile is, though)
07:20:41 <ski> (.. wouldn't the tape of a turing machine have an external effect on a person inspecting it ?)
07:20:49 <Twey> Jafet: Haha
07:20:57 <Twey> ski: Heat dissipation, &c. *shrug*
07:21:05 <titania> So if John is defined by [(trig-calc-1=x1) + (trig-calc-2=y1)] and Mary by [(trig-calc-1=x2) + (trig-calc-2=y2)], etc. and the rule is x1 is compatible with x2, but y1 is not compatible with y2, presumably, I could: (a) do the trig-calcs in Haskell; and (b) define the rules of compatibility with the trig-calcs; (c) to find out if Mary is assorted to John. Yes? (sorry but it really is a long time and I do value your advice).
07:21:32 <titania> assuming several thousand rules as defined by trig-calcs
07:22:05 <titania> when I did that with prolog (without the trig, but describing the blue eyes...) I got combinatorial explosion (back in 1993)
07:22:13 <Twey> titania: Err, sure
07:22:28 <Twey> titania: You can do it with Prolog, too (but maybe not in the way you were trying to)
07:22:28 <alpounet> computers are bit more powerful now :P
07:22:29 <djahandarie> Speaking of total languages, has anyone here played with Charity before?
07:22:41 <Twey> First hearing
07:22:44 <alpounet> djahandarie, I did, just a tiny bit, 2 years back
07:22:52 <ski> djahandarie : a little bit, not very much
07:23:42 <djahandarie> Is it any good?
07:23:50 <titania> trying to determine whether I need to relearn Prolog - I'd prefer to start something brand new and *modern"
07:24:35 <ski> djahandarie : it's interesting how they define data and codata types (together with (un)folds and maps)
07:24:37 <Twey> titania: Again, you do not and never will *need* to learn a specific programming language for a specific task, unless your boss demands it of you.
07:24:47 <Entroacceptor> titania: I've done an university course in prolog a few years ago
07:24:48 <ski> also, the exponential-like things are interesting
07:24:53 <Entroacceptor> Haskell feels more alive
07:25:01 <Twey> It's purely a question of what's easier
07:25:09 <titania> my boss is me D)
07:25:39 <qfr> How does compiling large projects work with ghc? Do you run n instances of ghc on single hs files each, producing object files and then you link them all together in the end (where h is the number of logical processors)?
07:25:42 <Twey> Yeah, Prolog seems pretty dead as far as I can tell (outside academia, anyway)
07:25:48 <titania> <Entroacceptor> thanks
07:25:50 <Twey> I've never seen it used for a real project
07:26:01 <ski> logic programming is useful to know .. Prolog is probably the LPL with most resources around ("everybody knows it")
07:26:05 <Twey> Yeah
07:26:13 <Jafet> Twey: or the vendor of the proprietary platform on which you have to perform the task
07:26:13 <Twey> Professors love it ☺
07:26:19 <alpounet> qfr, generally, you create a cabal project and let it handle this
07:26:25 <Twey> Jafet: Nah, bit of reverse-engineering and…
07:26:25 <titania> yeah yeah I also built a program for a robot for doing the washing up (serious!)
07:26:28 <qfr> Oh, ok
07:26:29 <alpounet> just specifying the options, the dependencies, etc
07:26:37 <Jafet> Twey: bam, lawsuit!
07:26:38 <Entroacceptor> Twey: I've seen it used for security analysis
07:26:41 <Twey> :-D
07:26:51 <Twey> Entroacceptor: Oh really?  What sort?
07:26:58 <titania> and for medical diagnosis
07:27:38 <cdsmithus> IMO, Prolog is mainly taught as an example of a very "different" language in university CS courses.  I'm aware of very minor real-world use in the hardware support area at Digital Equipment Corp in the early 90s... but that's the only time I've ever heard of or seen it in a way even indirectly connected to me.
07:27:50 <titania> at the time they also did a Prolog prog for visitors in London for the underground - go from A to B
07:28:00 <Entroacceptor> Twey: building a graph and finding holes in access restrictions to gain privileges on windows
07:28:04 <Twey> titania: I don't think they use Prolog for medical diagnosis any more
07:28:20 <zygoloid> ski: it's for "convenience". there's LetE :: [Dec] -> Exp -> Exp iirc.
07:28:25 <Twey> titania: AFAIK most of the NHS here at least runs on Java and worse
07:28:29 <titania> Yep, it's still done (internally in some Pharma firms)
07:28:29 <zygoloid> @type Language.Haskell.TH.LetE
07:28:31 <lambdabot> [Language.Haskell.TH.Syntax.Dec] -> Language.Haskell.TH.Syntax.Exp -> Language.Haskell.TH.Syntax.Exp
07:28:41 <Twey> Alright, I'll take your word for it
07:28:47 <Twey> Entroacceptor: Ooh, that's cool.
07:28:57 <ski> zygoloid : ah, so there's no `Q'-actions built into `Exp's and `Dec's, then
07:28:58 <Entroacceptor> let me find that again...
07:29:00 <Twey> Entroacceptor: Was this a paper?
07:29:04 <Eelis> qfr: last time i asked, i was told cabal doesn't support something like make's -j yet, which is very unforuntate
07:29:07 <Eelis> *unfortunate
07:29:14 <zygoloid> ski: it's so you can write: f x = $( letE [d| ... |] [| ... |] )
07:29:19 <qfr> Wtf :/ that's pretty essential
07:29:24 <Eelis> qfr: i agree :/
07:29:25 <zygoloid> or at least, that was the intent, but it got broken between the paper and the implementation
07:29:51 <zygoloid> (the paper used [Q Dec] for splices and quotations, which was fixed to Q [Dec] in GHC, but the module follows the paper's convention)
07:29:58 <qfr> Compiling is like one of the only things I can actually use my i7 920 for
07:30:19 <qfr> Compiling C++ got much faster with parallel compilation
07:30:31 <qfr> I don't get why it doesn't support that
07:30:34 <Eelis> me neither
07:30:42 <ski> zygoloid : ok .. and what is the interface that expects `[Q Dec] -> Q Exp -> Q Exp' ?
07:31:00 <ski> hm
07:31:01 <Jafet> Because C++ doesn't have modules
07:31:13 <titania> OK, many thanks guys, much appreciated. Going to investigate more. Happy New Year to you all, and again, thank you from this "oldie"
07:31:16 <zygoloid> ski: the "convenience" interface in Language.Haskell.TH
07:31:29 <qfr> Jafet: Are you saying that Haskell cannot be compiled in parallel?
07:31:51 <Jafet> Oh, thought you were talking about C++
07:32:26 <quicksilver> you can make ghc compile in parallel if you use a makefile and make -j
07:32:27 <Jafet> These days, what I really want is a ./configure -j
07:32:43 <quicksilver> built-in parallel compilation is an open feature request I think
07:32:54 <Jafet> For much of the code I download, configure takes longer than parallel build now
07:33:11 <qfr> I wrote my own building systems for C and C++ in Python and Ruby
07:33:20 <qfr> Is it more complicated for Haskell?
07:33:50 <sunfun> why on freebsd i got this error when i try to install ghc? ./configure: "utils/ghc-pwd/ghc-pwd: 16: Syntax error: "&" unexpected"
07:33:57 <Jafet> Well, no one's going to use it over cabal, at least for a very long time
07:34:16 <alpounet> qfr, wouldn't you rather want to contribute to cabal ?
07:34:19 <Eelis> language-specific build systems are a misguided idea anyway
07:34:19 <hvr> qfr: not really, ghc also supports emitting compile-dependancies
07:34:52 <Jafet> Eelis: why?
07:35:11 <Eelis> Jafet: because they break down as soon as your project gets more complicated than "just some code in language X"
07:35:21 <cdsmithus> Eelis: Languages with language-specific build systems tend to be a heck of a lot easier to use... if you have a better way, by all means, write it down and spread the word.
07:35:33 <dcoutts> qfr, hvr: the main extra complexity with ghc is packages
07:35:47 <Zao> sunfun: It might be using some bashisms?
07:35:55 <alpounet> the problem really is handling package dependencies
07:36:10 <qfr> Ah well, Haskell is probably much faster to compile than my boost C++ stuff anyways
07:36:14 <Zao> sunfun: Is this from source or binary package?
07:36:16 <hvr> dcoutts: isn't that basically the same as having to know a few -L -l lines with gcc?
07:36:20 <Zao> sunfun: What version, why do you not use ports, etc.
07:36:22 <blbrown_win3> anyone here a mathematica person, I am trying to convert this code to haskell.  http://pastebin.com/duRFXgrS
07:36:50 <qfr> Cellular automatons :D his favourite subject
07:36:58 <dcoutts> hvr: no, it's more complicated
07:37:14 <qfr> dcoutts how so?
07:37:17 <dcoutts> hvr: but on the other hand it's better :-)
07:37:19 <Eelis> cdsmithus: yes, systems specialized to a specific narrow use case are easier to implement and use for that specific use case. no surprise there
07:37:26 <blbrown_win3> qfr, whose favorite subject?
07:37:46 <qfr> blbrown_win3: Stephen Wolfram's
07:37:59 <blbrown_win3> ah yes, truly a lifetime adventure for him
07:38:10 <dcoutts> qfr: there can be multiple versions of packages, there are multiple ways of building packages: normal, dynamic, profiling.
07:38:18 <blbrown_win3> qfr, and mathematica kind of looks like haskell
07:38:32 <cdsmithus> Eelis: So add to that the fact that nearly all Haskell libraries are implemented entirely in Haskell... and it's certainly not a bad idea to have a tool specialized to that purpose.
07:38:36 <dcoutts> qfr: ghc packages are registered in package dbs, these have to be managed
07:38:51 <cdsmithus> If you want to combine many languages, yes, you'll need a different tool
07:39:38 <qfr> At least minimal rebuilds are probably much simpler in Haskell
07:39:47 <sunfun> Zao: on ports i'm still on 6.10.4
07:39:52 <qfr> In C++ you change one hpp file and then you have no idea what needs to be rebuilt.. *sigh*
07:40:05 <qfr> When you change a hs file you just need to rebuild one object file I imagine and then it gets relinked
07:40:20 <sunfun> and i've found version 7.10 on the official site
07:40:28 <Eelis> cdsmithus: i obviously disagree about it being a bad idea. i think there is no inherent technical reason why the features of cabal could not be implemented as, say, a SCons module.
07:40:37 <Zao> sunfun: 7.0.1, and it's not recommended for general usage, as the package ecosystem hasn't really caught up yet.
07:40:41 <qfr> I used to use SCons
07:40:43 <qfr> For C++
07:40:48 <titania> Done some of the Haskell lessons, I think I'm going to like this. Thanks and goodbye
07:41:04 <opqdonut> qfr: gcc -MM outputs dependencies
07:41:11 <Eelis> cdsmithus: i'm not at all saying SCons is the way to go, but it at least has the proper philosophy. not provincial like cabal
07:41:14 <qfr> opqdonut ahh nice
07:41:19 <opqdonut> qfr: there are a bunch of folklore Makefiles that do minimal rebuilds using that
07:41:20 <ski> titania : when you get more questions, we're happy to help
07:41:27 <dcoutts> Eelis: that's probably true, it could be added to a sufficiently programmable build tool
07:41:28 <Zao> sunfun: Is this a source or binary build?
07:41:32 <opqdonut> qfr: there's even one generic %.c rule in the make info manual
07:41:32 <copumpkin> titania: I'd recommend just hanging out in here and asking questions as they come up! We're usually very friendly :)
07:41:35 <sunfun> Zao: binary
07:41:57 <titania> you're sweet! Long time since I've met nice people like you lot! Will do. Best wishes.
07:41:59 <opqdonut> now java and minimal rebuilds is a PITA
07:42:08 <dcoutts> Eelis: there's also the package management aspect which would not be covered by something like scons
07:42:22 <Entroacceptor> Twey: I can't find that paper :/
07:42:33 <Entroacceptor> and I don't remember where I got it from, either
07:42:47 <sunfun> Zao: so the latest general stable release is 6.10.4?
07:42:48 <Eelis> dcoutts: yeah, well, i also find language-specific package management systems rather objectionable, so let's not even go there :P
07:42:50 <Jafet> Before that, you need to implement scons in haskell
07:42:56 <dcoutts> Eelis: and indeed we designed the spec so that you can use any build system you want, you don't need to use the simple one that comes with cabal
07:43:26 <zygoloid> Eelis: we have a highly optimized C++-specific build system here, and haven't had any real problems invoking it at the right times from our language-agnostic makefile
07:43:42 <zygoloid> (ours isn't a 100% c++ project)
07:43:43 <Eelis> zygoloid: good for you!
07:43:47 <roconnor> are there laws for the Alternative class?
07:43:53 <dcoutts> Eelis: of course, but the situation there is also not nice. We cannot just pick a single package format because that'll only work with one system. Distros all make their own package systems, forcing languages to do the same. Yes it's crazy.
07:44:01 <zygoloid> point is, the language-specific stuff doesn't necessarily break down once you go multilingual
07:44:02 <Eelis> dcoutts: indeed
07:44:17 <dcoutts> Eelis: what we did was to design our package descriptions so that they could at least be translated. And we have tools to do that.
07:44:24 <Eelis> zygoloid: you just conceded that you had to resort to wiring stuff together with makefiles. that's exactly my point
07:44:44 <dcoutts> Eelis: the cabal tool fills in for systems that have no package manager and for packages that are too bleeding edge to be in a distro yet.
07:44:56 <ski> roconnor : monoid laws at least, i'd expect
07:45:01 <quicksilver> Eelis: cabal isn't really a package management system in the normal sense
07:45:03 <zygoloid> Eelis: then i don't understand your point. how is it different if you wire stuff together with scons or jam?
07:45:29 <quicksilver> Eelis: it's better thought of as a tool for downloading + building haskell packages and following library depenendcy.
07:45:31 <roconnor> ski: true.  However I expect the functions to be somehow related to the applicative functions
07:46:00 <Eelis> zygoloid: very simple: if you don't use language-specific build systems, then you don't need obnoxious wiring and interfacing :)
07:46:04 <ski> roconnor : possibly distributive laws
07:46:12 <roconnor> ski: forexample perhaps empty <*> x = empty = y <*> empty
07:46:13 <dcoutts> Eelis: so yes the ideal situation would be a language neutral and system neutral package format, and a programmable build / packaging tool.
07:46:14 <zygoloid> Eelis: sure you do. that's what your build system /is/
07:46:29 <zygoloid> unless you don't need a build system at all :)
07:46:30 <roconnor> ski: yes and I'd expect some sort of distributive law
07:46:32 <cdsmithus> zygoloid has a point: maybe you'd prefer if some cross-language build tool called Haskell-specific code as a library rather than an executable?  But invoking executables is probably easier that working out foreign function interfaces from whatever language the build tool is written in to whatever language the language-specific code is written in.
07:46:39 <Eelis> zygoloid: surely you can see the difference between having 1 build system for your project and having >1 ?
07:46:46 <ski> roconnor : yeah .. that's the nullary distributive law
07:46:51 <Zao> sunfun: On what architecture? Works perfectly fine here on amd64 with 8.1
07:46:57 <hvr> ...why is it that 'cabal sdist' doesn't honour userHooks?
07:47:09 <Zao> sunfun: Latest release in 6.x series is 6.12 or something.
07:47:22 <Eelis> dcoutts: i'm glad we agree o nprinciple then
07:47:29 <roconnor> ski: x <,> (y <|> z) = (x <,> y) <|> (x <,> z) where (<,>) = liftA2 (,)  perhaps?
07:47:32 <zygoloid> Eelis: nope. the way i see it is: we use make as our build system. where some people use g++ to build c++, we use our own tool. the only difference is that our tool builds more than one c++ source file per invocation
07:47:44 <zygoloid> and i really don't see why (number of source files per invocation) is interesting
07:48:17 <roconnor> ski: I guess I could have used <*> instead of <,>
07:48:41 <sunfun> Zao: ok i'll try to build my own binary then, thank you 
07:49:02 <sunfun> Zao: i'm on a i686
07:49:10 <dcoutts> hvr: it's not on purpose, it's a known bug, but it's tricky to fix due to architecture decisions
07:49:16 <Jafet> I'm sure you can apply M. Conway's principle of conservation of distance to build and packaging systems
07:49:31 <ski> roconnor : *nod*
07:49:46 <Jafet> If n communities agree on a packaging system, it will have at least n+1 parts
07:49:49 <ski> roconnor : i'd try proving these for the common instances ..
07:50:26 <dcoutts> Eelis: however I'm rather sceptical about most of the current crop of programmable build tools. They don't sufficiently enforce accuracy of tracking of dependencies.
07:50:29 <Eelis> zygoloid: we may be talking past eachother. i'm not saying cabal doesn't offer good functionality. i'm saying that the way it's currently implemented, as a standalone tool, is less than ideal. implementing it as a module in a programmable generic build system would make the integration smoother because the dependency and update information could be seemlessly communicated to/from the build system, instead of going through an awkward command line
07:50:44 <Zao> sunfun: Note that you need a GHC installed to build from source.
07:50:52 <dcoutts> Eelis: most of cabal's functionality is available via the Cabal library btw
07:51:01 <Zao> sunfun: http://www.haskell.org/ghc/download_ghc_6_12_3#freebsd
07:51:04 <Eelis> dcoutts: that's good
07:51:14 <sunfun> Zao: yes now i'm on 6.10.4
07:51:46 <Zao> Eelis: The tool 'cabal' is typically referred to as cabal-install.
07:52:16 <dcoutts> well, that's it's package name, it's all jolly confusing :-)
07:52:32 * Zao vaguely remembers cabal-get :D
07:52:42 <zygoloid> Eelis: then i agree with you entirely. :)
07:52:46 <cdsmithus> Eelis: Frankly, though, the problem is that if you use the Cabal library, it means you're writing Haskell.  Other languages similarly have libraries to access similar features, and they are written in those languages.  Working out the foreign function stuff to call all those languages from one build tool is much harder than communicating via the command line.
07:53:01 <Eelis> Zao: even as a library it's still a standalone tool in the sense of not being integrated with a generic build system
07:53:06 <dcoutts> Zao: wow, early adopter :-)
07:53:26 <Eelis> zygoloid: alright then :)
07:53:30 * earthy vaguely remembers cabal-install didn't exist at all
07:53:38 <dcoutts> cdsmithus: it's about collecting dependencies though. Otherwise you're just doing recursive make.
07:53:45 <earthy> but cabal and Setup.hs did
07:54:42 <sunfun> Zao: anyway when i try to install version 7.x i got that error that seems to be a crash with the current shell because i get strange chars
07:54:56 <sunfun> Zao: i'm working with a remote shell 
07:55:09 <Zao> sunfun: It's rather odd, considering that utils/ghc-pwd/ghc-pwd is not a shell script.
07:55:49 <cdsmithus> Well, I guess it doesn't matter until someone builds such an integrated tool. :)  Certainly no one wants to go back to the pre-cabal (or even pre cabal-install) days of Haskell
07:55:55 <Zao> At least not in x64 builds.
07:56:41 <sunfun> Zao: yes i know... but it seems like a crash with stdin/stdout 
07:56:43 <Eelis> zygoloid: furthermore, implementing it as a module in a generic build system should make the implementation substantially simpler because a lot of what cabal currently does could be done by this generic build system. indeed, something like parallel compilation might Just Work when the generic build system already supports it
07:57:08 <Eelis> but due to the isolated approach, we have to wait for someone to replicate -j in Cabal..
07:57:32 <Zao> sunfun: Which FreeBSD version is this?
07:57:38 <sunfun> Zao: 8.1
07:57:40 * dcoutts does not trust -j in most build systems anyway
07:57:47 <zygoloid> Eelis: sure, but there is an opportunity cost. for instance, our build system benefits massively from analysing all the .cpp files at once (it only hashes each .hpp file once, for instance)
07:57:48 <dcoutts> they do not track deps sufficiently well
07:58:17 <Zao> sunfun: Odd. Might be configure that craps itself.
07:58:17 <zygoloid> Eelis: likewise, i could well imagine that GHC benefits from reading the .hi files once rather than once per .hs file which uses it
07:58:55 <Eelis> zygoloid, dcoutts: these are both valid concerns, and addressing them properly in a generic build system certainly isn't trivial, but i think it's the way to go in the long term
07:59:08 <sunfun> Zao: it could be... ok so i have to try with another package
07:59:34 <dcoutts> Eelis: sure, though I fear it may be the very long term, and indeed the generic tool may end up being written in Haskell first :-)
07:59:39 <sunfun> Zao: maybe i have issues with portupgrades
07:59:48 <Eelis> dcoutts: :)
08:00:06 <zygoloid> a good start would be a standardized, build-system-agnostic API for build system extensions
08:00:51 <sunfun> Zao: running ./configure with 6.12.3 works without any problems
08:01:00 <zygoloid> possibly as a simple binary, invoked as: <extension command> <list of file names>, which produces on stdout a list of out-of-date generated files plus build rules for them
08:06:37 <john_r_watson> Question on laziness.  The following code is actually creating 2 intermediate lists (which is probably inefficent, but beside the point) and w/out laziness this would require 3 separate "loops".  i.e. if you thought the Haskell was pumping out C code, we'd have for (){...} for (){...} for (){...}.  My question is whether laziness unifies all this work (effectively) into one for loop (as all the work *could* technically be done in o
08:06:38 <john_r_watson> first'' f = unzip >>> first (map f) >>> uncurry zip
08:07:27 <quicksilver> john_r_watson: it's not clear what it means for it to be one loop or three lops
08:07:37 <quicksilver> but it's true that the three "jobs" being done are interleaved
08:07:42 <quicksilver> not one-after-another like the C
08:08:00 <quicksilver> in particular, the three traversals are done 'together'
08:08:03 <quicksilver> potentially better for cache
08:08:08 <john_r_watson> yeah... I think it's probably an implementation detail
08:08:18 <john_r_watson> but what you just described sounds like what I wanted to here
08:08:53 <john_r_watson> Next I'd like to here that GHC is so awesome that the intermediary lists are elided in machine code
08:08:58 <john_r_watson> :)
08:09:21 * Zao hears
08:09:58 <john_r_watson> *hear
08:09:58 <john_r_watson> yeah
08:09:59 <john_r_watson> wow
08:10:07 <john_r_watson> need more coffee
08:11:29 <dolio> I don't know if that particular sequence gets fused.
08:11:41 <dolio> But many things can be, and are.
08:11:48 <sunfun> i need a tea, green tea with acacia honey
08:12:28 <dolio> However, 'map (first f)' is equivalent to that sequence, and generates no intermediate lists.
08:12:36 <mm_freak_> is there some equivalent to "svn status" in darcs?
08:16:19 <Nullus> hey guys, heres a total newbie question, how to define a list by comprehension for the following geometrical progression [1,2,4,8,16,32..1024]
08:17:26 <sipa> [ 2^x | x <- [0..10] ]
08:17:28 <sipa> > [ 2^x | x <- [0..10] ]
08:17:29 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024]
08:17:40 <Nullus> cheers
08:18:13 <djahandarie> > map (\x -> 2^x) [0..10]
08:18:15 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024]
08:18:35 <djahandarie> > map (2^) [0..10]
08:18:37 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024]
08:18:43 <djahandarie> > (2^) . [0..10]
08:18:45 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024]
08:19:52 <tac-tics> > (^2) [0..10]
08:19:54 <lambdabot>   No instance for (GHC.Num.Num [t])
08:19:54 <lambdabot>    arising from a use of `e_12010' at <in...
08:20:11 <Boxo> > (2^) `fmap` [0..10]
08:20:11 <tac-tics> > (^2) . [0..10]
08:20:12 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024]
08:20:14 <lambdabot>   [0,1,4,9,16,25,36,49,64,81,100]
08:20:24 <trez> different definition of (.) ?
08:20:34 <djahandarie> Yes, (.) = fmap in lambdabot
08:20:35 <tac-tics> @type (.)
08:20:37 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:20:44 <Boxo> @type fmap
08:20:45 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:20:47 <trez> oh, kinda cool :)
08:21:01 <tac-tics> Needlessly cool
08:21:17 <tac-tics> Very haskellesque
08:23:10 <opqdonut> you'll find yourself fmapping quite often once you program more haskell
08:23:39 <opqdonut> for example being able to say "x <- process . getThing" where getThing :: IO Thing and process :: Thing -> Something is a pure transformation
08:23:47 <opqdonut> err, being able to say that is nice
08:24:12 <earthy> process <$> getThing right? :)
08:30:01 <Nullus> another newbie question, how to define the following [[1],[1,1],[1,1,1],[1,1,1,1],[1,1,1,1,1]] in a list by comprehension
08:30:26 <pacak> Nullus: [replicate x 1 | x <- [1..]]
08:30:38 <Nullus> ty pacak
08:32:18 <Nullus> is there any other way of doing it without using a prelude function like replicate pacak?
08:32:21 <Nullus> just wondering
08:33:06 <Eelis> > take 5 [[1 | _ <- [1..x]] | x <- [1..]]
08:33:07 <lambdabot>   [[1],[1,1],[1,1,1],[1,1,1,1],[1,1,1,1,1]]
08:33:18 <Nullus> [[1|y<-[1..x]]|x<-[1..5]]
08:33:22 <BONUS> > [[1 | _ <- [1..n] | n <- [1..]]
08:33:24 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:33:38 <Eelis> weird echo in here
08:34:06 <Zao> @stereo
08:34:06 <lambdabot> Unknown command, try @list
08:34:08 <Zao> Aaw.
08:34:19 <Zao> @quote stereo
08:34:20 <lambdabot> Cale says: Welcome to #haskell, where your questions are answered in glorious stereo!
08:34:24 <Zao> That's the spirit.
08:34:51 <BONUS> > [[1 | _ <- [1..n]] | n <- [1..]]
08:34:52 <lambdabot>   [[1],[1,1],[1,1,1],[1,1,1,1],[1,1,1,1,1],[1,1,1,1,1,1],[1,1,1,1,1,1,1],[1,1...
08:36:27 <Eelis> Nullus: afaik those "[1..]" thingies are translated into calls to prelude functions though
08:36:57 <ski> *nod*
08:37:30 <Eelis> and list comprehensions probably as well
08:37:31 <edwardk> meh, its more like quadrophonic sound
08:37:47 <Nullus> Eelis yeah I was just wondering if there was another way without the replicate
08:38:14 <ski> `enumFrom',`enumFromTo',`enumFromThen',`enumFromThenTo'
08:39:11 <Eelis> > reverse (tails (replicate 5 1))
08:39:12 <lambdabot>   [[],[1],[1,1],[1,1,1],[1,1,1,1],[1,1,1,1,1]]
08:39:50 <ski> @undo [p - d | p <- [0 ..] , prime p , d <- [1 .. p] , d `divides` p - 1]
08:39:51 <lambdabot> concatMap (\ p -> if prime p then concatMap (\ d -> if d `divides` p - 1 then [p - d] else []) [1 .. p] else []) [0 ..]
08:40:34 <Eelis> ski: neat :)
08:40:35 <copumpkin> > heads (replicate 5 1)
08:40:36 <lambdabot>   Not in scope: `heads'
08:40:40 <copumpkin> > inits (replicate 5 1)
08:40:41 <lambdabot>   [[],[1],[1,1],[1,1,1],[1,1,1,1],[1,1,1,1,1]]
08:40:57 <Eelis> @src inits
08:40:58 <lambdabot> inits []     =  [[]]
08:40:58 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
08:41:00 <copumpkin> but the reverse one is probably more efficient memorywise
08:41:44 <copumpkin> > take 6 $ iterate (1:) []
08:41:45 <lambdabot>   [[],[1],[1,1],[1,1,1],[1,1,1,1],[1,1,1,1,1]]
08:42:48 <ski> > (`take` repeat 1) `map` [1 .. 5]
08:42:49 <lambdabot>   [[1],[1,1],[1,1,1],[1,1,1,1],[1,1,1,1,1]]
08:43:33 <copumpkin> ick, take is inefficient!
08:44:46 <Jafet> What efficiency
08:47:49 <ski> > let foo 0 k = k []; foo n k = foo (n-1) (\xs -> xs : k (1 : xs)) in foo 5 (:[])
08:47:51 <lambdabot>   [[],[1],[1,1],[1,1,1],[1,1,1,1],[1,1,1,1,1]]
08:56:31 <ski> > let foo [] k = k []; foo (a:as) k = foo as (\as -> k (a : k as)) in foo [0,1,2,3,4] id
08:56:32 <lambdabot>   [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0]
09:00:04 <trying_out_aweso> Hi. Im new here i have a question. 
09:00:06 <trying_out_aweso> There are also a site for tryruby or smothein like that and now i discoverd tryhaskell, which I love it. So arfe there any other try.... like tryc or tryc++.Thank you. :)
09:00:40 <trying_out_aweso> sorry for grammatical mistakes im eating. lol
09:01:03 <ski> sorry, i have no idea about any try-C or try-C++
09:01:13 <djahandarie> I don't think so.
09:01:13 <EvanR-work> there should be a donttryc++.com
09:01:20 <trying_out_aweso> tryputhon
09:01:22 <trying_out_aweso> tryperl
09:01:26 <trying_out_aweso> trylisp
09:01:28 <sleepynate> http://codepad.org/
09:01:37 <dmwit> You should maybe ask in #python, #perl, #lisp, etc.
09:01:38 <trying_out_aweso> awesome
09:01:51 <djahandarie> Though it shouldn't be too hard to make one, a lot of work is done because of geordi (a C++ evaluator bot written in Haskell)
09:01:54 <trying_out_aweso> thank you.gonna buy u a bear
09:01:58 <trying_out_aweso> :)
09:02:20 <sleepynate> trying_out_aweso: http://codepad.org/yg6yvjlC
09:02:41 <dmwit> do not want a bear, keep your thanks to yourself plz
09:02:49 <trying_out_aweso> ok. why i could use it for opencl
09:02:50 <dmwit> ;-)
09:02:56 <trying_out_aweso> ok
09:03:09 <trying_out_aweso> i mean c
09:03:19 <sleepynate> can i get a battle-bear ?
09:03:26 <sleepynate> with a saddle?
09:03:28 <djahandarie> dmwit, would you prefer a tiger?
09:03:34 <Twey> trying_out_aweso: http://www.trypython.org/ — there's a Python one, but apparently it now needs Silverlight :-\
09:03:41 <companion_cube> is Vorpal a synonym for the head function ?
09:03:56 <Twey> Haha
09:04:04 <sleepynate> companion_cube: instantrimshot.com
09:04:04 <trying_out_aweso> al browser support silverlight
09:04:07 <trying_out_aweso> even chrome
09:04:10 <trying_out_aweso> chromium
09:04:15 <trying_out_aweso> and iron
09:04:23 * djahandarie didn't get that joke
09:04:28 <trying_out_aweso> :)
09:04:28 <sleepynate> trying_out_aweso: unless you don't run windows :P
09:04:43 <trying_out_aweso> weel u could emulated it via Wine
09:04:46 <quuuux> I had trouble getting Silverlight working with lynx, too
09:04:52 <djahandarie> quuuux, haha
09:05:01 <sleepynate> trying_out_aweso: no. you can't.
09:05:02 <trying_out_aweso> there is opensource alternative to silevrlight
09:05:02 <djahandarie> I'd be a little strange if it did work...
09:05:09 <ski> (trying_out_aweso : .. how about w3m ?)
09:05:22 <sleepynate> trying_out_aweso: it's called moonlight and the alpha still doesn't work. novell's been on it for 2 years :D
09:05:27 <trying_out_aweso> yep
09:05:38 <trying_out_aweso> thats the one
09:05:44 <trying_out_aweso> u need a patched wine
09:06:03 <trying_out_aweso> so gonna do some hasskel now
09:06:06 <jacobian> http://wuyausu.com/wallpaper/bearcalvary.jpg
09:06:07 <trying_out_aweso> yupi
09:06:20 <toothbrush0> so, not that I don't enjoy a flame-war about proprietary multimedia software, but I've a question about Cabal breakage
09:06:21 <trying_out_aweso> lol
09:06:40 <toothbrush0> trying to upgrade xmonad and xmonad-contrib, but a dependency (X11-XFT) fails to build
09:07:39 <toothbrush0> full error here http://hpaste.org/42927/cabal_error
09:08:07 <lars9> > liftM (+) (Just 1) (Just 2)
09:08:08 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe t1 -> t'
09:08:09 <lambdabot>         against inf...
09:08:27 <lars9> > liftM2 (+) (Just 1) (Just 2)
09:08:29 <lambdabot>   Just 3
09:08:30 <alpounet> > (+) <$> Just 1 <*> Just 2
09:08:31 <lambdabot>   Just 3
09:08:33 <lars9> > liftM2 (+) (Just 1) (Nothing)
09:08:34 <lambdabot>   Nothing
09:08:44 <lars9> > liftM2 (++) (Just []) (Nothing)
09:08:48 <lambdabot>   mueval-core: Time limit exceeded
09:08:56 <toothbrush0> I'm running Debian, so I had to install libghc6-x11-xft-dev, and I think there's a mismatch in versions used to compile the library
09:08:58 <lars9> > liftM2 (++) (Just []) (Nothing)
09:08:59 <toothbrush0> or something
09:09:01 <lambdabot>   Nothing
09:09:38 <jacobian> Does xmonad deal with transients well? 
09:09:51 <toothbrush0> jacobian: sorry, what are transients?
09:10:02 <quuuux> toothbrush0: does `ghc-pkg list' show anything suspicious? Particularly having the same module in both the global and user databases?
09:10:03 <jacobian> ok/cancel windows and such
09:10:39 <Twey> jacobian: They're fine
09:10:43 <toothbrush0> jacobian: sort of - focus goes weird
09:11:02 <lars9> > fromMaybe [] Nothing ++ fromMaybe [] (Just [1])
09:11:04 <lambdabot>   [1]
09:11:11 <quuuux> jacobian: I've found it varies from application to application. Pidgin is weird, but Firefox copes fine, for example
09:11:33 <jacobian> I've always thought the tiling way was better
09:11:42 <jacobian> But most apps aren't really designed to support it
09:11:50 <toothbrush0> quuuux: a few modules are duplicate... X11-xft in particular, I think
09:12:09 <toothbrush0> jacobian: in practice I'm never really bothered by it
09:12:43 <toothbrush0> only thing is, say I have FF pinned to tab 3, and move it away, then sometimes it can 'lock up' on a pwd prompt, because the dialog appears on the pinned tab, and you've forgotten about it
09:12:59 <toothbrush0> quuuux: is this bad / how can I fix it?
09:13:56 <quuuux> toothbrush0: that's liable to cause problems, yes. There's a link somewhere explaining this, let me look for it
09:14:06 <toothbrush0> quuuux: oh, thanks
09:14:37 <toothbrush0> quuuux: I imagine the /var/lib/ghc.... paths are put there by apt, but I do need the libghc...-dev packages to be able to compile things like X11-xft
09:18:56 <quuuux> toothbrush0: http://www.vex.net/~trebla/haskell/sicp.xhtml
09:19:02 <byorgey> ezyang: you should check out Canou and Darasse,                                      Fast and sound random gener-
09:19:03 <toothbrush0> quuuux: thanks!
09:19:05 <byorgey> ation for automated testing and benchmarking in objective Caml.
09:21:02 <toothbrush0> quuuux: I like that the example of the GHC bug mentions the exact xmonad-contrib I'm trying to upgrade to ;)
09:22:28 <toothbrush0> quuuux: okay, sounds like a reasonable bet would be use non-repo GHC. 
09:23:34 <quuuux> toothbrush0: if your repo is stuck on 6.12.1 and you're running in to the bug, probably
09:24:20 <toothbrush0> quuuux: yep, on Debian (testing) here, so no go
09:24:48 <toothbrush0> I think i'll try install ghc7 from source, need it for a project anyway (a bug in ghc6.12.3 causes me to not be able to compile some valid code)
09:38:56 <toothbrush0> hm, lets say I've installed GHC7 from binary package (on Debian testing, because the repo version is 6.12.1), how do I get the equivalent of the debian package libghc6-x11-xft-dev available?
09:39:50 <Zao> toothbrush0: Preferably by installing cabal-install and via that build the relevant package from Hackage.
09:40:27 <toothbrush0> hm, okay. so cabal-install from source too, then cabal install x11-xft? (because now, cabal install x11-xft fails with "ghc-pkg xft unavailable")
09:41:56 <toothbrush0> Zao: the thing is, I already have cabal-install version 0.8.2
09:42:15 <Zao> But built against what Cabal, with what GHC?
09:42:48 <toothbrush0> don't really know, I imagine still from GHC6.12.1, since I've just removed all traces of ghc6 from my machine with apt
09:43:52 <zygoloid> mm_freak_: 'darcs whatsnew' (or just 'darcs w')
09:44:55 <toothbrush0> Zao: now I'm indeed trying to reinstall cabal 0.8.2 from scratch; this will happen with ghc7 I imagine
09:45:07 <aavogt> toothbrush0: I've use a cabal-install built with ghc-6.12 successfully with ghc-7
09:45:12 <roconnor> In http://stackoverflow.com/questions/3079537/orphaned-instances-in-haskell, the selected answer says "it's possible for a working program to start crashing at runtime because of a distant change."  How is it possible for orphaned instances to make a program crash at runtime?
09:45:23 <toothbrush0> aavogt: oh ok, maybe my upgrade is unnecessary then
09:45:43 <aavogt> toothbrush0: you can't build the same release of cabal-install with that newer ghc
09:45:55 <toothbrush0> aavogt: just discovered that yes :(
09:45:58 <aavogt> or I remember it failing
09:46:13 <toothbrush0> aavogt: thing is, I need the dev-libs for some programs, but obviously the Debian APT versions are too old
09:46:17 <toothbrush0> so I'm sort of stuck
09:46:51 <McManiaC> @tell applicative basic monad comprehensions work, but there are some details that still need to be worked on before they can make it into head… see http://hackage.haskell.org/trac/ghc/ticket/4370
09:46:51 <lambdabot> Consider it noted.
09:47:03 <aavogt> toothbrush0: what's the full error when you run    "cabal install x11-xft"?
09:47:12 <toothbrush0> aavogt: just a second....
09:47:13 <aavogt> toothbrush0: it's worked for me in a very similar configuration
09:47:26 <toothbrush0> aavogt: cabal: The pkg-config package xft is required but it could not be found.
09:47:45 <aavogt> toothbrush0: then you need some -dev  libraries that aren't haskell libraries
09:47:51 <toothbrush0> aaaaaah
09:47:53 <toothbrush0> good point
09:48:12 <toothbrush0> like, not the libghc6-x11-xft-dev, but the "normal" x11-xft-dev, or whatever
09:48:17 <toothbrush0> lemme look in apt-cache
09:48:56 <toothbrush0> aavogt: sweet, thanks, x11-xft built! Now on to XMonad
09:48:57 <toothbrush0> :)
09:50:17 <roconnor> @seen yitz
09:50:17 <lambdabot> Unknown command, try @list
09:50:17 <preflex>  yitz was last seen on #haskell 12 days, 2 hours, 56 minutes and 34 seconds ago, saying: can anyone write this monadically-written parser applicatively, or say why it can't be done?
09:51:45 <roconnor> I don't see how yitz can claim that orphan instances can cause programs to crash at runtime.
09:51:55 <roconnor> How did he get so many votes?
09:52:12 <zygoloid> roconnor: 'cause he dissed haskell on reddit?
09:52:24 <roconnor> zygoloid: this ist stackoverflow
09:52:27 <zygoloid> hmm, stackoverflow, not reddit
09:52:30 <roconnor> http://stackoverflow.com/questions/3079537/orphaned-instances-in-haskell
09:52:47 <roconnor> I don't see how to cause a runtime crash using orphaned instances
09:52:48 <zygoloid> roconnor: that can happen
09:52:55 <roconnor> how?
09:52:55 <zygoloid> but you also need dynamically-loaded code
09:53:02 <roconnor> pft
09:53:27 <roconnor> okay, I'll bite
09:53:42 <roconnor> how does dynamically loded code with orphaned instaces cause this problem?
09:53:49 * zygoloid goes hunting for his Real Code which Actually Crashes
09:53:59 <roconnor> and remember the problem has have to do with orphaned instances
09:54:08 <toothbrush0> say I do ":m XMonad.Layout.NoBorders" in ghci, and it says <no location info> and module not found, how do I make it aware of my available libraries? some environment variable?
09:54:16 <zygoloid> the easy/obvious crash is with an associated type
09:54:38 <roconnor> it really sounds like a problem with dynamically loaded code rather than orphaned instances
09:54:40 <aavogt> toothbrush0: did you cabal install xmonad-contrib
09:54:44 <toothbrush0> yep
09:54:54 <toothbrush0> and it shows up in ghc-pkg list
09:55:05 <roconnor> and yitz didn't mention anything about dynamically loading code
09:55:08 <toothbrush0> uh correction it doesn't :/
09:55:30 <toothbrush0> aavogt: hm, must have missed that in all the thrashing...
09:55:37 <roconnor> yitz says ``You could be using a method that you are assuming comes from a certain instance declaration, and it could silently be replaced by a different instance that is just different enough to cause your program to start inexplicably crashing.''
09:55:50 <roconnor> but orphan instances don't behave like that
09:55:58 <toothbrush0> aavogt: with all the installing/uninstalling I lost track; it's building now, thanks, I'll try again soon
09:56:03 <toothbrush0> should be solved then
09:56:08 <zygoloid> roconnor: without dynamically-loaded code, you can't have two instances for the same type in the Main module, so you can't have two instances for the same type in the same binary.
09:56:27 <roconnor> adding a new instances causes compile time errors
09:56:47 <quicksilver> roconnor: GHC has a bug, compared to a strict reading of the haskell spec
09:56:59 <quicksilver> roconnor: it does not guarantee to cause a compile time error for a duplicate instance
09:57:04 <toothbrush0> aavogt: finally, great, it works again
09:57:15 <quicksilver> it only reports them when it "notices" them - when both are visible from the a single module, when that module is compiled.
09:57:20 <roconnor> quicksilver: wow, that is a serious bug.
09:57:24 <quicksilver> roconnor: I agree.
09:57:35 <roconnor> is that what yitz is getting at?
09:57:41 <roconnor> it doesn't sound like it
09:57:53 <roconnor> but maybe
09:57:56 <quicksilver> not sure :)
09:58:56 <zygoloid> roconnor: ok, i've dug out the case i got a crash, and the root cause is that i had two instances of Typeable for different types with the same name (one from the dynamically-loaded code, and one from the binary). the dynamically-loaded code was interpreted, but the Typeable instances matched anyway, and ... something went wrong.
09:59:20 <zygoloid> i guess interpreted types and compiled ones aren't laid out the same in memory?
09:59:41 <quuuux> zygoloid: that sounds more like a GHC bug than anything
10:00:07 <quicksilver> roconnor: I think there is a trac for the general issue but I'm afraid I can't find it.
10:00:10 <zygoloid> quuuux: ultimately i think it's the old "Typeable is unsound" bug
10:00:18 <roconnor> I do like the idea of making a hackage category for orphans
10:00:24 <roconnor> that seems like it would work well in practice
10:00:26 <quuuux> zygoloid: unsound, but oh-so-useful :(
10:00:28 <zygoloid> with a twist that even the GHC-generated typeable instances are unsound
10:00:43 <quicksilver> I remember SPJ (probably?) explaining it, and John Meacham expressing supress that duplicate instances weren't spotted at link-time by use of a conflicting symbol or similar
10:01:21 <zygoloid> of course, that doesn't save you from someone turning on IncoherentInstances and exploiting overlap that way
10:02:19 <quicksilver> people who turn on incoherentinstances get what they deserve?
10:02:26 <zygoloid> agreed :)
10:02:48 <taotree> Is there a reference somewhere that will tell me how the standard operators should be read (if you were going to verbalize an expression)? =>, ->, <-, etc.
10:03:14 <zygoloid> roconnor: no, i don't know how to make a crash from orphan instances, such that you can't get the same crash without them
10:03:15 <dmwit> #haskell is the reference
10:03:50 <dmwit> I personally never verbalize =>, though if I did it would probably be wordy and mixfix. -> is "to", <- is "from"
10:03:55 <dmwit> Others you want to know about?
10:04:32 <zygoloid> dmwit++ but occasionally i verbalize => as 'implies' or 'gives'
10:06:07 <quuuux> I want to say => as 'given' but the order of arguments is wrong
10:06:42 <dmwit> I would pronounce "Ord a => a -> Bool" as "Assuming a is Ord, a to Bool".
10:06:56 <dmwit> ...I think.
10:06:56 <roconnor> zygoloid: that's what I thought
10:07:07 <roconnor> zygoloid: the anti-orphan camp has gone too far this time!
10:07:09 <roconnor> :)
10:07:29 <Philippa> dmwit: "Given Ord a, a to Bool" for me
10:07:52 <Philippa> (or if I'm feeling silly, Ord a, to, a to Bool)
10:08:46 <sproingie> not sure there's any comfortable way to read it left to right in english
10:09:00 <Philippa> yeah, but big deal - it's all trees under the surface anyway
10:09:04 <quuuux> solution: always carry around a mini-whiteboard and a marker, so you never need to actually -say- these things
10:09:19 <sproingie> for Ord a => a -> Bool, i see the => first and think "for Ord a, a to Bool"
10:09:26 <Philippa> "given Ord a, then a to Bool" just about works
10:09:31 <taotree> that reminds me of the Japanese writing Kanji on their hands and in the air
10:09:50 <Philippa> ("given" emphasises evidence-passing somewhat)
10:10:01 <quuuux> Type -> Vocalisation is ill-defined :)
10:10:36 <sproingie> "for" mildly implies it's overloadable but eh, good enough
10:10:39 <taotree> So let me try: "instance (Monoid a,Monoid b) => Monoid (a,b) where" == "Given an instance of a tuple of Monoid a and Monoid b, we have a Monoid of a tuple a and b where..."
10:10:56 <mtnviewmark> quuuux: This is why I like to have technical meetings with a shared text editor --- I often suggest that people communicate in code, it is generally more clear
10:11:33 <taotree> I'm asking for just my internal brainspeak as I'm trying to learn this. As I'm reading code, it would help if I have keywords to attach to things.
10:11:52 <dmwit> taotree: Sounds good. You might abbreviate: "Given Monoid a and Monoid b, we have Monoid a comma b where ..."
10:12:04 <taotree> thanks all
10:13:04 <roconnor> ``Global instances don't break encapsulation and composability...''
10:13:05 * roconnor sighs
10:13:17 * roconnor bangs head against desk
10:13:20 <mtnviewmark> taotree: I totally rearrange that in my head: "Given instances of Monoid a and b, then (a,b) is an instance of Monoid where..."
10:14:55 <mauke> Monoid ((,) a b) = do Monoid a; Monoid b
10:15:01 <taotree> mtnviewmark, Sounds good, though unless you're using Victor Borge's phonetic punctuation, "(a,b)" has to become "a comma b" or "tuple a b"
10:15:19 <Boxo> "If a is a monoid and b is a monoid, then a tuple of a and b is a monoid"
10:15:50 <mauke> "to call Monoid on (a, b) you need to call Monoid on a and call Monoid on b"
10:16:44 <mtnviewmark> taotree: alas, I don't sound anything like Victor Borge.... when I'm "reading it in my head", I think I often just picture that 'graphic phrase' in that point in the reading, ... but yes, I'd say "tuple of a and b" probably, if pronouncing it aloud
10:17:06 <Philippa> or "pair" for 2-tuple
10:17:07 <taotree> mtnviewmark, right, just a little jok
10:17:11 <taotree> joke
10:17:27 <mtnviewmark> taotree: understood, the V.B. reference made me smile
10:17:59 <mtnviewmark> mauke: "call"? in what sense is there a "call" going on in "instance (Monoid a, Monoid b) => Monoid (a,b) where..."
10:18:18 <taotree> mtnviewmark, I think he's referring to the code he pasted
10:18:21 <mauke> mtnviewmark: I read instance definitions as function equations
10:18:38 <mtnviewmark> interesting
10:19:43 <mauke> instance (F x) => F x would be an infinite loop
10:30:10 <zygoloid> roconnor: if you interpret 'crashing at runtime' as meaning 'bottoming out' (or other unexpected behaviour) then yitz is right (but you still need dynamically-loaded code or IncoherentInstances or some other mechanism to get both conflicting instances to be present in the same program)
10:31:02 <j-invariant> I have this great revelation about haskell but I forgot it!
10:31:32 <ski> mtnviewmark : you can read that roughly as Prolog `monoid(A,B) :- monoid(A),monoid(B).' ..
10:32:03 <mauke> (except I don't know declarative programming, so I read it as functional and/or imperative)
10:32:50 <ski> (in fact, i often think it would have been better if the Haskell syntax was `instance Monoid (a,b) <= (Monoid a,Monoid b)')
10:33:14 <roconnor> zygoloid: that is a pretty big but
10:33:36 <mauke> I like big buts
10:33:38 <EvanR-work> roconnor: ..
10:33:41 <EvanR-work> mauke: dammit
10:33:42 <zygoloid> roconnor: though i think yitz's suggestion that we add a mechanism to prevent instance importing to be a cure which is much much worse than the disease
10:33:55 <roconnor> zygoloid: oh?
10:34:02 <roconnor> it seems like the natural solution to all this nonsense
10:34:03 <zygoloid> it would make it much easier to have the sorts of problems which e is worried about
10:34:34 <roconnor> zygoloid: oh you mean it would become confusing to know which instances are active
10:34:35 <zygoloid> suppose you move some code from one module to another. that can now cause breakage by picking up a different (say) Ord instance
10:34:39 <roconnor> ya, you are probably right
10:34:48 <zygoloid> worse than confusing
10:34:59 <zygoloid> you could fairly trivially break the invariant of, say, Map
10:36:34 <quuuux> zygoloid: devil's advocate, but isn't that possible currently anyway with GHC's behaviour?
10:37:30 <quuuux> that is, different instances being visible in different modules and no warning/error being given if they don't actually collide in a module
10:38:18 <zygoloid> quuuux: all the code you reference has to be directly or indirectly imported into Main (modulo dynamically-loaded code).
10:38:35 <zygoloid> hence all instances are visible in Main, and overlap can be accurately detected
10:41:07 <alpounet> damn
10:41:20 <alpounet> does anybody have a String -> CalendarTime function somewhere ?
10:41:27 <alpounet> do
10:46:51 <byorgey> alpounet: do you really need CalendarTime?  It's from System.Time which is deprecated in favor of the new time package
10:47:16 <byorgey> alpounet: Data.Time.Format from the time package has parseTime
10:47:56 <j-invariant> hi byorgey 
10:48:06 <byorgey> even if you really need CalendarTime, you could use parseTime and then convert
10:48:08 <byorgey> hi j-invariant 
10:48:11 <j-invariant> byorgey: I have watched your excellent vidoe on species!!
10:48:16 <aristid> byorgey: i think the new time package has a bad reputation, undeservedly
10:48:47 <alpounet> byorgey, i need String <-> CalendarTime on the local timezone, plus time diffs (think of it as something analoguous to what's needed for the 'seen' feature of irc bots)
10:48:58 <byorgey> aristid: well, I think it deserves its reputation as being hard to figure out how to use.  But it doesn't deserve a reputation as a bad package
10:49:05 <byorgey> j-invariant: thanks! glad you enjoyed it =)
10:49:22 <j-invariant> byorgey: I was going to buy the book but it costs hundreds of dollas >_>
10:49:41 <byorgey> j-invariant: yeah, I know, I think it is out of print =(
10:50:16 <byorgey> j-invariant: do you have access to any academic libraries?  Or know anyone who does?  You could try to get it through inter-library loan
10:50:18 <aristid> j-invariant: which video?
10:50:19 <j-invariant> by the way, I have considered the idea of a species programming language - like you said
10:51:03 <j-invariant> aristid: http://vimeo.com/16753644
10:51:34 <aristid> j-invariant: thanks
10:51:34 <j-invariant> I think one has to prove theorems to use quotient data types like this -- that's a difficult part
10:52:03 <byorgey> j-invariant: indeed.  that does seem to be the most difficult sticking point.
10:52:33 <j-invariant> of course you can composelots of basic functions: But making the basic functions on the first place needs justification
10:53:03 <j-invariant> on the other hand, the universal property methods of category theory might be able to get around it...
10:53:08 <j-invariant> I don't know about that
10:53:32 <byorgey> j-invariant: right.  So I think the question becomes, can we provide nice sets of primitive functions with pre-proven properties, so the user can just compose them and get the nice properties for free?
10:53:58 <byorgey> At this point I am hand-waving in the extreme, though
10:56:32 <j-invariant> and perhaps show they form a "basis" for all programs
10:56:46 <byorgey> right, something like that
10:57:19 <byorgey> j-invariant: I haven't thought much about species for a little while now (been focusing on other things) but hope to get back to it at some point in the not too distant future
10:58:12 <j-invariant> cool
11:00:53 <Zutai> hey
11:04:48 <edwardk> @hpaste
11:04:48 <lambdabot> Haskell pastebin: http://hpaste.org/
11:06:02 <edwardk> this is kind of what i'm looking at for the streams data type hierarchy: http://hpaste.org/42936/streams_api thoughts?
11:06:15 <byorgey> hi Zutai 
11:07:03 <edwardk> i have Branching. Infinite, and NonEmpty done, and Future to a state with class
11:08:07 <byorgey> edwardk: shouldn't the constructor names First/Last be switched?
11:08:42 <byorgey> looks neat though
11:09:16 <j-invariant> I notice that positive integers are a categery with   3 : 2 --> 6
11:09:22 <j-invariant> the arrow means 2|6
11:09:43 <j-invariant> it's got composition and such
11:10:25 * hackagebot TrieMap 1.0.0 - Automatic type inference of generalized tries.  http://hackage.haskell.org/package/TrieMap-1.0.0 (LouisWasserman)
11:13:05 <byorgey> j-invariant: yes, any poset is a category.
11:13:43 <j-invariant> I wanted to find categories where the objects are groups
11:14:27 <byorgey> well, the category of all groups (where arrows are group homomorphisms) is the canonical one =)
11:14:28 <mm_freak> zygoloid: 'whatsnew' doesn't do, what 'svn status' does, but i found it already
11:14:32 <j-invariant> like the category of subgroups or something idk..
11:14:34 <mm_freak> darcs whatsnew -l
11:15:01 <j-invariant> ah yes the category of groups
11:15:18 <j-invariant> I wonder what a homomorphism between numbers is
11:15:21 <byorgey> j-invariant: given any group you can also form a poset (actually a lattice, I think) of its subgroups, which therefore is also a category
11:16:02 <edwardk> byorgey: they are to comply with EODP
11:16:06 <j-invariant> byorgey: I take the union of all those
11:16:09 <j-invariant> :D
11:16:51 <byorgey> edwardk: EODP?
11:16:55 <alpounet> byorgey, any advice on how to go from a NominalDiffTime to getting the number of years, months, days etc ?
11:16:59 <edwardk> essence of dataflow programming
11:17:04 <edwardk> the uustalu/vene paper
11:17:37 <byorgey> ah, ok
11:19:37 <j-invariant> nice http://en.wikiversity.org/wiki/File:Symmetric_group_4;_Lattice_of_subgroups_Hasse_diagram.svg
11:20:36 <j-invariant> wish there was one for S6
11:20:38 <j-invariant> S5 i mean
11:20:41 <edwardk> the only odd ones are that the sequence versions carry a technically unncessary current position to avoid chaining functions
11:24:41 <byorgey> alpounet: no, sorry
11:24:49 <alpounet> okay
11:24:57 <alpounet> i'll just go with div and mod
11:26:20 <edwardk> byorgey: oh, i did have them flipped =)
11:26:33 <byorgey> hah! ;-)
11:27:38 <lispy> Hey guys, just an FYI:  cabal-dev rocks :)
11:27:52 <lispy> I love being able to build the deps for something and not pollute my system
11:28:17 <lispy> I don't have to worry what version of parsec is installed globally
11:28:25 <lispy> </psa>
11:34:54 <edwardk> cabal-dev?
11:35:15 <quuuux> I have created a monstrosity: IO (a -> IO (IO b))
11:35:40 <edwardk> quux: looks like some of my reactor code ;)
11:35:45 <alpounet> edwardk, http://blog.ciscavate.org/2010/12/cabal-dev-sandboxing-your-haskell-development-and-now-with-ghci.html
11:36:38 <ezyang> quouuux: Could be reasonable. 
11:37:49 <edwardk> — the goal is to get the pretty printing to look like First 1 :> 2 :> 3 :> 5 :> 6 :| 7 :< 8 :< 9 :< Last 10 for a zipper with focus at 6.
11:38:53 <edwardk> alpounet: thanks
11:39:02 <edwardk> i need another precedence level though =/
11:41:34 * hackagebot epub-metadata 2.0.2 - Library and utility for parsing and manipulating ePub OPF package data  http://hackage.haskell.org/package/epub-metadata-2.0.2 (DinoMorelli)
11:42:45 <lispy> edwardk: it's a tool we use internally at galois to make building lots of packages on the same machine more sane :)
11:42:56 <lispy> edwardk: and then we finally got the public release out
11:48:36 * hackagebot extcore 1.0 - Libraries for processing GHC Core  http://hackage.haskell.org/package/extcore-1.0 (TimChevalier)
11:54:53 <edwardk> lispy: nice, i'm juggling a half dozen packages for this comonad stuff and going nuts. this is why category-extras was one monolithic package ;)
12:13:33 <mm_freak> i think i finally understood implicit configurations
12:13:53 <mm_freak> but i don't get why haskell people insist on "dictionary passing" not being RTTI
12:14:57 <mm_freak> after all i'm very sure you can do real OOP with it, and in general generate types at run-time
12:15:08 <mm_freak> only difference is that it's still type-safe
12:15:25 <Philippa> mm_freak: it's a more general mechanism than RTTI, amongst other things
12:15:27 <mm_freak> (being quite a big difference though)
12:15:39 <Philippa> it's also not the classic C++-style "carry RTTI in the object" stuff
12:29:47 <Cin> Why is the implementation of PrintfType class from Text.Printf hidden?
12:30:02 <edwardk> because its scary
12:31:02 <Cin> instance PrintfType (IO a) where
12:31:02 <Cin>     spr fmts args = do
12:31:02 <Cin> 	putStr (uprintf fmts (reverse args))
12:31:02 <Cin> 	return undefined
12:31:07 <Cin> *So* difficult. ;-)
12:31:41 <c_wraith> ...  That returns undefined?  That sounds extra painful.
12:31:53 <mauke> has to, sadly
12:32:06 <Cin> Just ignore the return value, would be unit anyway.
12:32:45 <c_wraith> Oh.  I see.  To make it anything other than undefined, you'd need flexible instances
12:32:48 <Cin> I wanted to define an ErrorT instance for PrintfType so I didn't have to do throwError $ printf .., I could just write printf .. -- alternatives?
12:32:58 <edwardk> c_wraith: or a constraint
12:33:16 <mauke> adding the constraint makes usage annoying
12:33:21 <mauke> type annotations everywhere
12:33:24 <c_wraith> right
12:33:31 <edwardk> class Unit a where unit :: a instance Unit () where unit = ()    instance Unit a => PrintfType (IO a)
12:33:52 <edwardk> it wouldn't be so bad if data-default were in base
12:33:54 <mauke> Cin: that sounds like an abuse
12:34:09 <Cin> mauke: You think so? Would it confuse you to come across it in code?
12:34:13 <mauke> yes
12:34:15 <edwardk> cin: yes.
12:34:17 <Cin> Hmm, ok.
12:34:19 <mauke> I don't expect printf to throw exceptions
12:34:41 <edwardk> yeah
12:35:04 <Cin> I'm used to printf being polymorphic on the return but oh well.
12:35:40 <mauke> I'm not entirely convinced that the IO instance is a good thing
12:35:58 <EvanR-work> printf should do one thing or the other, not both. what is this, php?
12:35:59 <Cin> It's analogous to CLOS's FORMAT, which may be where the inspiration came from.
12:36:08 <Cin> er, CL's
12:36:33 <EvanR-work> if its something different, call it something else
12:36:37 <EvanR-work> printfIO
12:36:48 <EvanR-work> IO ()
12:36:49 <mauke> it's analogous to printf/sprintf from C
12:37:03 <EvanR-work> yeah so have two, printf and sprintf
12:37:09 <Cin> But that isn't one function. FORMAT is one function.
12:37:20 <EvanR-work> s/php/lisp/
12:37:42 <EvanR-work> screw both of them
12:37:48 <mauke> format checks its arguments to decide what to do
12:38:00 <Cin> I think convenience functions for printing might deserve to be generalised.
12:38:13 <EvanR-work> to avoid typing an extra letter ?
12:38:16 <j-invariant> Cin: well typed
12:38:19 <j-invariant> :D
12:38:30 <j-invariant> that's #haskell for I agree
12:38:50 <dolio> I recommend just not using printf at all.
12:39:02 <EvanR-work> printf = puts . sprintf
12:39:08 <EvanR-work> not hard
12:39:10 <mauke> EvanR-work: that doesn't work
12:39:34 <EvanR-work> im sure it doesnt for real haskell printf
12:40:15 <EvanR-work> or what issue are you referring to
12:40:28 <dolio> puts . sprintf :: String -> IO ()
12:40:37 <EvanR-work> .: or .::
12:40:42 <mauke> which one?
12:40:46 <EvanR-work> oh
12:41:09 <dolio> You're defeating the variable argument-ness.
12:41:24 <EvanR-work> yeah, thats stupid too. just screw it all
12:41:36 <EvanR-work> or use a list of existential
12:42:22 <Cale> EvanR-work: The thing is, it's already got to be polymorphic in its result type to support the variable number of arguments
12:42:31 <Cale> EvanR-work: So it might as well do both strings and IO
12:42:38 <Cin> I've got:
12:42:39 <Cin> break :: (PrintfArg r) => String -> r -> Unify a
12:42:39 <Cin> break = (throwError .) . printf
12:42:39 <Cin> It'll do.
12:42:44 <j-invariant> do printf without typeclasses
12:42:54 <j-invariant> Cin
12:43:37 <mauke> br = throwError; ak = printf
12:43:42 <mauke> br$ak "...
12:43:45 <Cin> hehe
12:43:51 <EvanR-work> Cale: replacing variable arguments with the more idiomatic list of arguments wont work right, but seems like something similar should work
12:44:06 <Cin> valid perl code
12:44:18 <mauke> the first part isn't
12:44:21 <j-invariant> haskell
12:44:32 * Cin didn't expect any of it to be, and yet expects any code to be
12:44:44 <EvanR-work> its valid javascript!
12:44:56 <mauke> the second part is theoretically valid
12:45:04 <mauke> parses as $ak->br("...")
12:45:12 <EvanR-work> heh
12:45:41 <Cin> mauke: Are you using the printfqq package?
12:45:47 <mauke> no
12:45:55 <Cin> How do you solve your printf needs?
12:46:00 <mauke> printf-mauke
12:46:04 <dolio> Someone has a type safe printf-alike thing using delimited continuations.
12:46:09 * Cin looks at taht
12:46:22 <dolio> You don't use a string for specifying formatting, though. It's more like formatting combinators.
12:46:53 <mauke> using a format string is the entire point of printf (for me)
12:47:15 <EvanR-work> might as well just concat ["abc", f d, "def", i n, etc]
12:47:18 <Cin> Indeed.
12:47:41 <dolio> Yeah, when I first saw it, "that's not really printf" was my thought.
12:48:01 <dolio> But, formatting combinators aren't a bad idea necessarily. Just not printf.
12:48:18 <dolio> They're more verbose, of course.
12:48:36 <mauke> that way lies c++
12:49:12 <Cin> mauke:  $(printf "%d %d") x y  -- I know a little TH, but I don't know the full extent, can one write: break x = throwError . $(printf x)? I'm guessing it doesn't get inlined cleverly. Am I restricted to using throwError $ $(printf xx) x y everywhere?
12:49:32 <mauke> basically, yes
12:49:38 <Cin> Or should I just write a wrapper TH function?
12:50:03 <mauke> I don't know if that would work
12:50:10 <mm_freak> Philippa: yeah, i see that…  now the only thing missing is some way to generate /classes/ at run-time, not just instances
12:50:16 <c_wraith> Sure it would.  It's an easy wrapper.
12:50:22 <Cin> mauke: Like, er, $(break ..) 'Spose it's not a huge deal.
12:50:23 <mm_freak> but i suppose that's possible, too
12:50:40 <aavogt> Cin: you can't write    break x = throwError . $(printf x)
12:50:48 <Cin> Sure.
12:51:03 <mm_freak> btw, i think you can implement printf using this approach
12:51:09 <aavogt> Cin: that triggers stage restrictions
12:51:15 <mm_freak> without being hacky, that is
12:51:57 <aavogt> mm_freak: what do you mean?
12:52:02 <mm_freak> what bothers me about dictionary passing is that you need to encode data as types, which destroys some of the safety
12:52:20 <mm_freak> aavogt: implicit configurations through dictionary passing
12:52:28 <Cin> Ah, I need access to Mauke.Internal. (Ohh, sexy!)
12:52:29 <c_wraith> Oh.  Hmm.  because the arity of the function printf generates isn't fixed, that actually is kind of ugly.
12:52:37 <mm_freak> aavogt: i.e. a very nice alternative to state monads
12:52:53 <ssworld> this site is so interesting!
12:53:17 <Cin> ssworld: Try Haskell?
12:53:22 --- mode: ChanServ set +o pumpkin
12:53:27 * aavogt is confused as to who is discussing which topic
12:53:53 <mm_freak> aavogt: i just implemented modular arithmetic using this apprach with proper instances even for Eq and Show, which is not possible using the more common functional or State approach
12:55:04 <aavogt> mm_freak: so the maximum number is passed as a type?
12:55:19 <mm_freak> aavogt: the modulus
12:55:22 <mm_freak> but yes
12:55:28 <aavogt>  data Mod n a = Mod a;  instance Num a => Num (Mod n a) ...
12:56:17 <mm_freak> well, i used Integer
12:56:22 <mm_freak> instance Modulus n => Num (Mod n)
12:56:28 <aavogt> it gets a bit awkward to take the modulus from runtime-dependent values
12:56:44 <mm_freak> what do you mean?
12:56:55 <aavogt> mm_freak: if each modulus is a distinct type
12:57:19 <mm_freak> yes, but you can generate those types at run-time from integer values
12:57:36 <j-invariant> aavogt: this is not possible!
12:57:52 <mm_freak> j-invariant: "this"?
12:57:53 <j-invariant> mm_freak: can i see the code
12:57:54 <j-invariant> ?
12:57:55 <aavogt> j-invariant: you're aware of  -XExistentialQuantification?
12:58:01 <mm_freak> j-invariant: sure, just a second
12:58:05 <mm_freak> aavogt: RankNTypes
12:58:12 <j-invariant> aavogt: no
12:58:13 <aavogt> same idea
12:59:10 <aavogt> j-invariant: well it lets you basically treat a some distinct types as the same ones (which all support some common operations)
13:00:02 <aavogt> otherwise I think it's a bit less flexible as to where you may specify the modulus
13:01:33 <mm_freak> j-invariant: http://hpaste.org/42938/modular_arithmetic_using_impli
13:02:31 <mm_freak> you can write:  withModulus 10 (6 + 7)
13:02:35 <mm_freak> and it gives you 3
13:03:13 <j-invariant> are yuo serously acool
13:03:18 <j-invariant> wait
13:03:33 <j-invariant> you have encoded the numbers into the type system :(
13:04:01 <mm_freak> yes
13:04:19 <j-invariant> my problem is polynomials over a ring: I didn't want to encode them into the type system.. maybe it's my only hope
13:04:27 <mm_freak> but you don't need the moduli to be static
13:04:30 <aavogt> mm_freak: ah, that's the standard example for that implict configurations stuff
13:04:38 <mm_freak> they can still be generated from run-time values
13:04:54 <mm_freak> aavogt: not quite…  it's simplified a lot
13:05:14 <aavogt> well the important points are the same
13:09:46 <mm_freak> yeah
13:10:09 <mm_freak> aavogt: but i didn't understand reification until today
13:10:12 <mm_freak> the rest was clear
13:10:57 <mm_freak> not that i wasn't able to implement it, but i didn't understand how it works…  most notably i was confused by the semi-dynamic types in this type system, which was supposed to be completely static
13:11:11 <mm_freak> (it is, still, but it doesn't feel like that)
13:13:51 <EvanR-work> i do i split a list of numbers into consecutive groups
13:14:05 <mm_freak> EvanR-work: example?
13:14:27 <EvanR-work> 1 2 3 5 6 7 9 11 -> [1 2 3] [5 6 7] [9] [11]
13:14:45 <mm_freak> :t groupBy
13:14:46 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
13:15:05 <mm_freak> > groupBy (\x y -> y == x+1) [1,2,3,5,6,7,9,11]
13:15:06 <lambdabot>   [[1,2],[3],[5,6],[7],[9],[11]]
13:15:10 <mm_freak> hmm
13:15:22 <EvanR-work> hrm
13:15:34 <mm_freak> groupBy always compares with the first element, which is unfortunate
13:15:51 <brisbin> i'm curious as to the difference between ($) and ($!), anyone have a good link?
13:16:15 <mm_freak> brisbin: ($!) is eager application…  sort of call by value
13:16:20 <monochrom> non-strict, strict
13:16:26 <mm_freak> > const 3 $! undefined
13:16:27 <lambdabot>   *Exception: Prelude.undefined
13:16:32 <mm_freak> > const 3 $ undefined
13:16:33 <lambdabot>   3
13:16:47 <brisbin> i thought it was strictness, thanks
13:16:58 <monochrom> I can't say "eager, lazy" because of semantics nazis.
13:17:20 <monochrom> oops, "lazy, eager"
13:17:29 <EvanR-work> im using non strict eager evaluation
13:17:31 <mm_freak> dunno, i think "eager" is more appropriate, since the semantics of the function aren't changed
13:18:20 <mm_freak> it's not the function, which is strict, it's ($!) itself
13:18:25 <dixie> > map Data.Char.chr $ (\[a,b,c] -> [a+3,b+8,c+2]) $ map Data.Char.ord $ take 3 "darcs"
13:18:26 <lambdabot>   "git"
13:18:38 <monochrom> at any rate it is "non-strict, strict" or "lazy, eager" or "another way to do non-strict, another way to do strict". it is never sensically "lazy, strict" or "non-strict, eager".
13:19:07 <Lichtlos> hi
13:19:08 <mm_freak> monochrom: well, you can say for sure that ($!) is strict in its second argument
13:20:06 <elliott> How can one generate all strings consisting only of . and : as an infinite list?
13:20:39 <monochrom> generate all natural numbers, convert to binary, except use . and : for bits
13:21:06 <monochrom> prepend the empty string
13:21:26 <elliott> that's cheating, i was hoping for some beautiful list comprehension :)
13:22:02 <krainboltgreene> What kind of government/nation embodies Haskell?
13:22:08 <monochrom> no, I'm sure [0..] and showBin is more beautiful.
13:22:21 <burp> @hoogle showBin
13:22:21 <lambdabot> No results found
13:22:22 <EvanR-work> all strings consisting of . and : or all finite strings?
13:22:30 <elliott> EvanR-work: the latter.
13:22:33 <EvanR-work> ah
13:22:36 <elliott> EvanR-work: the former would be just like the latter, anyway
13:22:39 <elliott> well
13:22:42 <elliott> unless you did it really weirdly
13:22:46 <EvanR-work> i think the form is uncomputable?
13:22:48 <EvanR-work> former
13:22:51 <krainboltgreene> I imagine the Monad as some great war machine that is rolled out onto battlefields. The ensuing slaughter can only be described as "efficient" and "mathmatical".
13:22:53 <byorgey> it depends on your definition of "string"
13:22:55 <elliott> EvanR-work: not really, the latter suffices
13:23:01 <elliott> EvanR-work: the infinite strings come after all the finite ones :-)
13:23:07 <elliott> hehe
13:23:07 <monochrom> well even if you want to include infinite strings, first you should finish with the finite strings first. append infinite strings afterwards.
13:23:08 <EvanR-work> uhm...
13:23:14 <elliott> i'm joking
13:23:16 <EvanR-work> lol
13:23:43 <EvanR-work> unless the problem was 'all infinite strings'
13:23:55 <monochrom> the question obviously leave order open
13:24:40 <monochrom> the question may or may not include infinite strings. does not hurt. I get to choose order. I decide to emit all finite strings first. no one will know I will miss infinite strings.
13:24:57 <EvanR-work> you can show that some infinite strings wont appear in the output
13:25:32 <mm_freak> > [0..] >>= (`replicateM` ":.")
13:25:33 <lambdabot>   ["",":",".","::",":.",".:","..",":::","::.",":.:",":..",".::",".:.","..:","...
13:25:51 <EvanR-work> i use haskell as a posh binary clock
13:26:53 <tromp_> it's not hard to avoid numbers
13:27:23 <elliott> tromp_: in general? i agree!
13:28:20 <tromp_> > let l = "" : (l >>= (\x -> ['.':x,':':x])) in take 20 l
13:28:21 <lambdabot>   ["",".",":","..",":.",".:","::","...",":..",".:.","::.","..:",":.:",".::","...
13:28:31 <EvanR-work> set of finite strings from a countable alphabet is countable?
13:28:55 <Cale> EvanR-work: yes
13:29:01 <EvanR-work> interesting
13:29:46 <Cale> But countable strings on even a finite alphabet is uncountable.
13:29:50 <j-invariant> EvanR-work: you can prove it by what monochrom said
13:30:06 <Cale> (on a finite alphabet with at least 2 elements)
13:30:10 <j-invariant> it's a simple bijection between the natural numbers and their representations in base n
13:30:26 <cdsmithus> EvanR-work: It's pretty easy to see.  Just enumerate all the 0-length strings (finitely many), then all the 1-length, then the 2-length, and so on.  Every finite string has some length, and will be reached eventually
13:30:29 <pumpkin> EvanR-work: in my enumerable package I generate them
13:30:34 <EvanR-work> j-invariant: but i said countable base, so not base n, base infinity
13:30:35 <mm_freak> as soon as you can represent a set as a haskell list it must be countable
13:30:37 <monochrom> I prefer to think of it the other way. you can prove what I said by it.
13:30:43 <j-invariant> EvanR-work: oh I missed that
13:30:48 <Cale> cdsmithus: and interleave those, probably
13:30:53 <pumpkin> oh, if the base is countable infinite, then no
13:31:05 <pumpkin> if it's finite, enumerable can generate all of them
13:31:11 <foo_> What do I do about this? ghci -package containers -package json     results in    cannot satisfy -package json: json-0.4.4-30e5040a9ad4f93b415b0e2d12c8654c is unusable due to missing or recursive dependencies: containers-0.3.0.0-339506fe3cdbf89bbfb2d85bb3085ace
13:31:18 <EvanR-work> uh oh
13:31:20 <j-invariant> when you have a countable base you are sort of looking at it sideways
13:31:31 <cdsmithus> Cale: You don't have to interleave them.  It's the concatenation of a bunch of finite lists.
13:31:52 <Cale> cdsmithus: Strings of length 1 on an infinite alphabet isn't finite.
13:32:01 <cdsmithus> Oh wait... I misread the question
13:32:04 <monochrom> foo_: you have some packages upgraded wrong or replaced wrong
13:32:09 <cdsmithus> I read that as "finite alphabet:"
13:32:17 <mm_freak> foo_: install json via "cabal install"
13:32:19 <EvanR-work> countable != finite ;)
13:32:30 <foo_> I've installed it via cabal install
13:32:41 <foo_> Haven't installed anything manually
13:32:44 <Cale> foo_: Start by ensuring that you have only one version of containers installed
13:32:52 <Cale> foo_: ghc-pkg list containers
13:32:56 <monochrom> OK to see what to do next, first you need to show me "ghc-pkg -v list" and "ghc -v"
13:33:52 <monochrom> but generally you wantonly installed things to get to this state
13:33:53 <Cale> foo_: and then reinstall json, because it's broken (it depends on a build of containers which is apparently no longer installed on your machine)
13:33:57 <foo_> Sorry I'll try again: I have 3 copies, one in /Library/Frameworks/GHC.framework/Versions/612/usr/lib/ghc-6.12.1/package.conf.d and the others in /Users/sengan/.ghc/i386-darwin-6.12.1/package.conf.d
13:34:17 <monochrom> you can only afford 1 copy, always.
13:34:35 <EvanR-work> then why do i have 2 bases
13:34:38 <Cale> okay, ghc-pkg unregister the local ones, which will probably break lots of stuff, but will improve sanity
13:34:38 <EvanR-work> 3 and 4
13:34:40 <foo_> Well I assume cabal did it. 
13:35:01 <monochrom> http://www.vex.net/~trebla/haskell/sicp.xhtml describes what kind of mess you could get into
13:35:06 <foo_> What you're saying is ghc-package unregister both containers?
13:35:22 <Cale> foo_: The local copies of containers, not the one which came with ghc
13:35:34 <Cale> The packages that come with ghc, you never want to upgrade
13:35:58 <monochrom> base is a hardcoded exception
13:36:09 <cdsmithus> foo_: Yeah, you shouldn't have any local copies of containers.  If it's really messed up, you can always 'rm -rf ~/.ghc' and start over.  But next time don't 'cabal install' any core packages
13:36:42 <foo_> Ok. All I did was: A download haskell packaged. Installed it. Then I ran cabal and assumed it did the right thing. I guess it didn't. So the local packages are in .ghc?
13:36:51 <cdsmithus> Yes
13:36:53 <Cale> .ghc and .cabal
13:36:56 <foo_> Ah.
13:37:35 <cdsmithus> The registered libraries are in .ghc; The .cabal directory has binaries and downloaded sources; those won't cause much trouble generally.
13:38:40 <foo_> So how do I unregister the local copies?
13:38:52 <foo_> ghc-pkg unregister containers-0.3.0.0-339506fe3cdbf89bbfb2d85bb3085ace fails
13:39:03 <cdsmithus> Either ghc-pkg unregister containers-...  ; or just 'rm -rf ~/.ghc'
13:39:20 <Cale> foo_: how does it fail?
13:39:21 <monochrom> ghc-pkg --user unregister containers-0.3.0.0
13:39:25 <Cale> ah
13:39:30 <foo_> --user thanks!
13:39:59 <monochrom> actually since user packages take precedence, omitting --user is ok for a moment.
13:42:51 <qfr> I am going to make a UML diagram of my hello world before I write any Haskell
13:43:19 <qfr> I'm not sure if the whole object oriented drivel translates well to Haskell though
13:43:31 <pumpkin> it doesn't at all
13:43:38 --- mode: pumpkin set -o pumpkin
13:43:44 <qfr> Haha
13:43:47 <c_wraith> he's gone co-!
13:44:05 <qfr> Is it a coalgebra? A company? No, it's copumpkin!
13:45:03 <Cale> Haskell is basically its own UML.
13:45:08 <qfr> Haha
13:45:52 <qfr> In Haskell there is no default facility which binds functions to types like methods are associated with classes in C++ and Java, right?
13:46:10 <qfr> It's separated
13:46:19 <mm_freak> UML is to haskell what a hand-written recipe is to a cooking robot
13:46:19 <ziman> you can still use structures.
13:46:30 <Cale> Well, you can put functions inside values of a datatype.
13:46:46 <qfr> Cale hmm I've never seen that before
13:47:23 <qfr> Is that even something that is commonly done?
13:47:27 <Cale> Sure.
13:47:43 <mm_freak> qfr: yes, see State, Reader, Cont and others
13:47:44 <sh10151> mm_freak: if the hand-written recipe were written in rebus form, maybe
13:48:15 <qfr> Great, so that means I can translate my UML to Haskell
13:48:22 <qfr> OOPing like it's 1990
13:48:41 <ezyang> OOP I did it again. 
13:48:54 <qfr> Or perhaps 1995 rather
13:48:56 <quuuux> sh10151: bfultotuerr BOeggsWL?
13:49:01 <qfr> Since Java wasn't around back in 90
13:49:07 <j-invariant> Is there a good place to post to search for people who want to collab on haskell programs??
13:49:12 <hpc> ezyang: if it wasn't for that being actually funny, you would be on my permanent hate list
13:49:16 <hpc> ;)
13:49:26 <alpounet> OOP predates java
13:49:41 <ezyang> heehee 
13:49:55 <mm_freak> j-invariant: great an account on the community server and start your project there, then ask in the -cafe list
13:50:23 <mtnviewmark> Certainly the term OO is at least as early as 1972
13:50:26 <mm_freak> great?
13:50:31 <mm_freak> create
13:51:02 <qfr> <alpounet> OOP predates java
13:51:06 <j-invariant> what is the community server?
13:51:08 <qfr> Well, C++ is from 1983
13:51:15 <earthy> OOP started with simula iirc
13:51:16 <alpounet> j-invariant, community.haskell.org
13:51:21 <Cale> C++ also isn't the first OOP language
13:51:23 <earthy> in the '60;s
13:51:28 <alpounet> qfr, see simula, smalltalk, ...
13:51:43 <qfr> And OOP prior to that was very different from the way it is implemented in C++ and Java, isn't it?
13:51:45 <Cale> Smalltalk is probably what I think of when people say OOP
13:51:47 <mtnviewmark> I believe that "Objects" was Alan Kay's term for the construct in Simula - I don't think it was Simula's term
13:51:58 <qfr> I was told that Smalltalk was radically different from C++ and Java about it
13:52:06 <Cale> Simula is not so far off from Java
13:52:08 <qfr> And that Objective C is more similar to what Smalltalk did
13:52:30 <mm_freak> qfr: not radically, but certainly different
13:52:32 <mtnviewmark> qfr: No, not really, the various ways C++ has implemented Objects were basically all explored prior to it
13:52:57 <mm_freak> qfr: instead of calling methods you send messages
13:53:00 <Cale> The way that C++ and Java do OO is actually pretty wrong, if you ask me.
13:53:02 <qfr> Yeah
13:53:05 <sh10151> abject-oriented programming is the state of the art today
13:53:21 <mtnviewmark> subject-oriented programming!
13:53:22 <hpc> sh10151: s/art/business/ :P
13:53:31 <sh10151> http://typicalprogrammer.com/?p=8
13:53:32 <hpc> oh, icwudt
13:53:33 <alpounet> qfr, well, even Java and C++ differ quite much on the way they provide OOP
13:53:37 <qfr> sh10151: Oh, hey :P didn't know you did Haskell, too
13:53:37 <c_wraith> objectivist-oriented programming?
13:53:41 <mm_freak> Cale: C++/java/c#/d/blub style polymorphism is great for some things
13:53:42 <Cale> In particular, they put method implementations inside class declarations.
13:53:45 <sh10151> i love this passage
13:53:48 <sh10151> "Inheritance is a way to retain features of old code in newer code. The programmer derives from an existing function or block of code by making a copy of the code, then making changes to the copy. The derived code is often specialized by adding features not implemented in the original. In this way the old code is retained but the new code inherits from it."
13:54:36 <Cale> Class declarations ought to be nothing but type signatures.
13:54:50 <Cale> The implementations should go into the objects.
13:55:13 <qfr> alpounet: Where do they differ?
13:55:13 <Cale> But oops! No first class procedures.
13:55:23 <Cale> --> FAIL
13:55:24 <sh10151> qfr: unfortunately these languages are all hobbies, work is Java :-/
13:55:27 <qfr> Other than C++ providing the legacy struct with different default visibiliity and inheritance
13:55:32 <qfr> sh10151: Haha, so common :/
13:55:38 <alpounet> qfr, multiple inheritance
13:55:47 <qfr> Oh right, Java didn't have it?
13:55:53 <sh10151> the worst is some people at work think Groovy is the best thing since sliced bread...
13:55:58 <alpounet> it still doesn't qfr :p
13:56:01 <mm_freak> Cale: there is a problem with that
13:56:18 <mtnviewmark> Java has interfaces, which are a limited form of multiple inheritance
13:56:26 <mm_freak> Cale: how does an object call the parent constructor or a parent method?
13:56:43 <qfr> Why do people keep on building stuff on top of the JVM? I find that so odd
13:56:47 <qfr> http://en.wikipedia.org/wiki/Groovy_%28programming_language%29
13:57:10 <foo_> Thanks Cale, Monochrom and cdsmithus. It now works. I deleted .ghc and started over.
13:57:13 <alpounet> qfr, less work to do I guess
13:57:16 <mm_freak> mtnviewmark: interfaces rather model a primitive form of haskell's type classes
13:57:17 <groovy2shoes> qfr: because the JVM is deployed in a lot of places, yet Java sucks
13:57:21 <mtnviewmark> uhm... cause a huge percentage of computers have a JVM installed
13:57:32 <qfr> The Java standard library in combination with the Oracle VM is such a massive memory hog, I still don't know why
13:57:38 <Cale> mm_freak: Well, if you really insist that objects should always have parent objects, then by explicitly maintaining a reference to its parent.
13:57:38 <ezyang> The JVM is actually pretty impressive. 
13:57:41 <mtnviewmark> mm_freak: sure
13:57:46 <qfr> I wrote this simple GUI in Java which displays 300 KiB of text in a JTable (swing)
13:57:51 <earthy> the java standard libs are also quite impressive
13:57:56 <qfr> And it uses 220 MiB of unshared memory on launch
13:58:06 <mm_freak> Cale: to its parent with the (different) parent fields?
13:58:07 <ezyang> It's gotten a bad reputation for its slow startup and high memory use, but there's actually some really fancy technology in Oracle's implementation. 
13:58:20 <Cale> mm_freak: Yeah.
13:58:21 <mm_freak> Cale: the parent's "methods" would use the parent's fields
13:58:21 <earthy> plus, the jvm also runs in really *tiny* environments
13:58:26 <earthy> (javacard, for one)
13:58:27 <ziman> because jars are zipped, which prevents sharing.
13:58:27 <mm_freak> which is not the point
13:58:29 <qfr> ezyang: Yeah, I'm told they really have a crack JIT team there
13:58:39 <qfr> Yet startup times and memory consumption are insane
13:58:50 <qfr> Since JIT probably doesn't have much to do with that haha
13:58:59 <earthy> qfr: depends on what you call insane
13:59:06 <earthy> if you see what it *does* with all that memory
13:59:11 <earthy> i.e. what infrastructure is provided
13:59:12 <ezyang> yeah. It's well known that you have to run a Java app for a little bit before you benefit from the JIT optimizations 
13:59:56 <Cale> mm_freak: I'm not crazy about the whole concept of inheritance in the first place, but it ought to be easy enough to simply copy the parent's method into oneself and call it.
13:59:57 <mrd> is there a reason why http://haskell.org/gtk2hs/ is a dead link?
14:00:05 <qfr> Somebody I talked to claimed that the JVM generally overcommits by 50-150% on a lot of stuff and only makes an effort to release the overcommitted parts back to the OS when it's under memory pressure
14:00:17 <earthy> makes sense
14:00:26 <ezyang> qfr: That wouldn't be too surprising. Note that for the longest time that's what GHC on Windows did too. 
14:00:38 <qfr> Which sounds odd to me, since you usually want to let the OS use as much memory as possible for file system caching etc, no?
14:00:42 <ezyang> (actually, I think it just never released the memory back) 
14:00:55 <earthy> qfr: no. 
14:00:56 <mm_freak> Cale: then you're wasting both memory and programmer time…  types with function fields just don't model OOP as it is done in the real world very well
14:01:01 <ezyang> qfr: The OS is totally free to put your pages in swap and use the RAM for something else. 
14:01:08 <qfr> Sure
14:01:09 <Cale> mm_freak: hm?
14:01:14 <earthy> the jvm needs to have extra memory available for efficient garbage collection
14:01:17 <Cale> mm_freak: I don't understand why you want to do this anyway.
14:01:23 <mm_freak> Cale: you could write some TH/QQ wrappers though
14:01:30 <mm_freak> Cale: i'm not saying i want to do this
14:01:40 <mm_freak> but there are applications, where OOP is really nice
14:01:55 <qfr> I've also been whining about the memory usage of the main Ruby interpreter recently because it caused quite the workload on this crappy box I was running services on lol
14:02:06 <mtnviewmark> few VM implementations ever release memory back -- I wrote one in the 90s for very constrained OS environments (<1MiB) but that quickly became not so important
14:02:08 <qfr> But I guess most of that can be swapped out, too
14:02:29 <Cale> mm_freak: Either the object was created from its parent by modifying some method, in which case, why are you still trying to call the parent's method? Or that method was unchanged when the child object was created from the parent, in which case, it's already identical.
14:02:42 <mtnviewmark> of course, now on "smart" phones, memory pressure is once again important
14:02:46 <qfr> Did ghc have any VM stuff prior to the LLVM backend?
14:02:48 <mtnviewmark> (no place to swap!)
14:02:57 <ddarius> mtnviewmark: Swap to the cloud.
14:03:00 <mm_freak> Cale: because of the fields
14:03:06 <mtnviewmark> ghc -- IS a VM
14:03:08 <monochrom> the haskell binding for mac cocoa or something uses precisely TH to emit inheritance code.
14:03:13 <Cale> mm_freak: what?
14:03:18 <ezyang> Yeah, what do you mean by VM stuff? 
14:03:25 <mm_freak> Cale: the parent method would access the parent's fields, not the child's
14:03:25 <ezyang> If you mean runtime system, GHC totally has one of those. 
14:03:27 <mtnviewmark> ddarius - talk about a slow disk.....
14:03:30 <cdsmithus> qfr: LLVM isn't really used as a VM anyway.  It's a code generator.
14:03:35 <qfr> cdsmithus yeah
14:03:43 <qfr> Just like in.. Clang?
14:04:19 <ddarius> mtnviewmark: 4G is probably already faster than many disks I grew up with.
14:04:26 <mm_freak> in general to do OOP-style polymorphism you need to write more code in haskell than you would in, say, C++
14:04:37 <monochrom> there is an open-recursion way to have a parent method use child's fields
14:04:38 <mtnviewmark> mm_freak - are you talking about a style of object implementation where each "slice" of an object through the inheritance graph gets it's own "mini-object"?  Or are you trying to describe prototype based object systems?
14:04:40 <cdsmithus> wfr: I suppose so.  And yes, GHC had three other code generators prior to LLVM: the unergisterized C one, the registerized C one, and the NCG (native code generator)
14:05:09 <mm_freak> mtnviewmark: i don't know what you mean, but i'm simply talking about C++ style polymorphism
14:05:16 <mtnviewmark> ddarius - true, but now you have applications that take more memory than the whole compute center at college had (when I was there).... just to draw angry birds!
14:05:19 <monochrom> indeed if you look at all formal semantics of OOP, they all de-sugar OOP into open recursion
14:05:43 <mtnviewmark> ah - so, the former, though in C++'s case, they are all allocated in one block
14:05:50 <mm_freak> mtnviewmark: a subclass inherits methods and fields from the parent, but when a parent method accesses fields, it accesses the child one's
14:05:50 <earthy> monochrom: you mean co-recursion?
14:06:00 <monochrom> no, I absolutely mean open recursion
14:06:03 <Cale> mm_freak: In the parent's context, sure.
14:06:27 <mtnviewmark> mm_freak -- in C++ how can a parent's methods access a child's fields?
14:06:39 <mm_freak> mtnviewmark: common fields
14:06:42 <qfr> ghc6 and ghc7 still default to NCG, right?
14:06:55 <qfr> But both already have an LLVM backend which is not used by default?
14:07:02 <cdsmithus> qfr: Yes.  Or unregisterized C, depending on platform. :)
14:07:09 <qfr> Ah, right
14:07:15 <Cale> mm_freak: You would want that if you copy an object, the references to object-local fields inside the methods now refer to the fields of the new object.
14:07:21 <ddarius> mtnviewmark: That's true.
14:07:29 <qfr> the NCG is limited to IA-32 and AMD64?
14:07:39 <mm_freak> Cale: and how?  write accessor classes for the fields?
14:07:45 <qfr> on other systems it has to resort to external compilers like gcc?
14:08:12 <ddarius> qfr: The NCG has only been in GHC since like 6.8
14:08:17 <qfr> Oh, ok
14:08:17 <mm_freak> Cale: or by passing accessor functions to the methods?
14:08:18 <Cale> mm_freak: That's just how the variable binding would work?
14:08:29 <cdsmithus> qfr: Not sure about the exact list of targets
14:08:30 <mtnviewmark> not sure what you mean by that --- but parent and child aren't clear terms either --- do you mean to say that when a member function defined in a base class is invoked on an instance of a sub-class, that that member function will access fields defined in the sub-class? -- because in C++ that can't happen
14:08:31 <qfr> So 6.1x still uses registerised C on AMD64?
14:08:50 <mm_freak> Cale: right now you're already writing a lot of code to implement a simple OOP concept
14:08:51 <cdsmithus> qfr: 6.12 > 6.8
14:08:53 <Cale> An object is its responses to messages. All accesses to fields are messages.
14:08:54 <earthy> monochrom: hm. I've seen some of the work by e.g. Marieke Huisman and Bart Jacobs on the semantics of Java. I seem to recall that uses coalgebra's and corecursion.
14:08:58 <qfr> cdsmithus oh not again
14:09:02 <qfr> I hate that notation so much
14:09:07 <Cale> mm_freak: I'm not writing any code.
14:09:08 <qfr> I had the same cockup yesterday
14:09:17 <cdsmithus> That's pretty standard version notation, I think.
14:09:30 <qfr> I never encounter it tbh :/ so not used to it
14:09:38 <Cale> mm_freak: and what concept is this?
14:09:44 <qfr> I always interpret them in decimal positional notation
14:10:11 <mm_freak> Cale: C++ style polymorphism
14:10:28 <monochrom> that does not contradict that open recursion is used.
14:10:29 <Cale> My whole point is that C++ style polymorphism is the wrong way around :P
14:11:04 <mm_freak> Cale: yes, but sometimes it's appropriate, and it's tiring to do in haskell
14:11:07 <Cale> Polymorphism should be based on the set of messages that an object will respond to.
14:11:15 <Cale> I'm not even talking about Haskell
14:11:20 <monochrom> look for Luca Cardelli
14:11:31 <Cale> I'm talking about how some putative typed imperative OO language ought to do it.
14:11:34 <mm_freak> Cale: haskell is a good language to try to model this in
14:11:42 <earthy> monochrom: I should and I will. :)
14:11:58 <companion_cube> ocaml's object model is not bad for this, i think
14:12:06 <earthy> (haven't read much by Cardelli, his stuff is still on the 'should read' list)
14:12:37 <mm_freak> dunno, most common lispers argue that CLOS is the only one and true OOP system
14:12:41 <Cale> A class, assuming that we want to formalise those at all, should be *just* a type, and what is the type of an object? It is the set of messages that it responds to, and their types.
14:13:20 <Cale> If you want to do subtype polymorphism, then it should be based around that.
14:13:29 <companion_cube> mm_freak, they cheat, it's dynamic typing
14:13:55 <Cale> If one class is a subclass of another, then it has a superset of the methods, at refinements of their types.
14:14:38 <mm_freak> Cale: i sometimes liked the concept of abstract classes
14:14:47 <ddarius> mm_freak: You can usually dismiss such claims by lispers out of hand.
14:15:07 <mm_freak> Cale: method overriding is an integral part of that
14:15:14 <j-invariant> CLOS is the best object system in the world ever
14:15:19 <taotree> I'm working on a gui application (probably gtk) in Haskell, developing it on Linux, but I want it to work on Windows as well... is that generally going to work? Or is it likely to be a major headache?
14:15:33 <j-invariant> It's better than Java
14:15:45 <kmc> Java is the Haskell of PHP
14:15:47 <hpc> j-invariant: that's not hard
14:15:54 <mm_freak> taotree: expect headaches, but have a look at manatee
14:15:57 <roconnor> j-invariant: does CLOS have typing?
14:15:57 <Cale> mm_freak: So, when you define an object to be a member of some class, you must provide implementations of all of the methods of the class to which you want it to belong, somehow.
14:16:04 <j-invariant> roconnor: no
14:16:08 <earthy> taotree: should work, but not without some headaches
14:16:11 <hpc> kmc: that makes sense to me, but i don't know why!
14:16:13 <Cale> mm_freak: I don't care if you do it by stealing implementations from other objects :)
14:16:14 <jacobian> CLOS has manifest typing, which isn't really based on a type theory
14:16:14 <kmc> i'd expect build system headaches; not a huge degree of incompatibility in the code itself
14:16:21 <earthy> kmc: exactly
14:16:26 <roconnor> j-invariant: the best object system in the world has no guarentees about safety?
14:16:30 <j-invariant> roconnor: it is untyped but obviously a compiler can double check things and tell you if you make mistakes, even if it's not sound and complete
14:16:35 <j-invariant> roconnor: sorry it is sound
14:17:10 <hpc> i would prefer if my type system was code; audible frequencies are useless in this context :P
14:17:13 <j-invariant> roconnor: well it is an untyped language but it is type safe: I mean that nothing can "go wrong" in the sense of interpreting one object as the wrong type
14:17:19 <j-invariant> roconnor: but that is a general property of the language
14:17:38 <mtnviewmark> Cale, mm_freak: That sharing interface contracts, and reusing implementations are conflated in most OO languages is the source of a long line of woes, if you ask me...
14:17:40 <taotree> thank you, I'll plan accordingly
14:17:52 <Cale> mm_freak: Modelling this sort of "let's steal implementations from other objects" thing in Haskell I'll admit can be tricky, because variable binding in Haskell is absolute.
14:18:07 <mm_freak> Cale: not only that
14:18:23 <j-invariant> roconnor: of course you can get runtime conditions that fiddle with control flow: BUt that is very different than using the internal bits of a float as a pointer by accident, or segfaulting
14:18:51 <Cale> But I don't consider inheritance to be a fundamental concept for OO at all.
14:18:55 <mm_freak> Cale: in this style of polymorphism a variable with the parent type can also hold values of child types
14:18:56 <jacobian> around methods can be pretty horrifying 
14:19:10 <Cale> mm_freak: sure
14:19:20 <Cale> mm_freak: that much is easy to do
14:19:24 <mm_freak> this is, in fact, a major point of doing this
14:19:40 <Cale> Subtype polymorphism for OO is overrated.
14:19:42 <mm_freak> Cale: really?  in an extensible fashion?
14:19:43 <monochrom> that's just existential type
14:20:26 <mm_freak> monochrom: existential types give you polymorphism, but no extensibility
14:20:49 <mm_freak> that's the part you need to hand-code
14:21:03 <aristid> Cale: record subtyping would be nice to have :)
14:21:26 * roconnor has begun to think record subtyping is evil
14:21:44 <kmc> subtyping is evil
14:21:52 <Cale> Well, I should rephrase that -- it's not this bolted on sort of subtype polymorphism that we care about so much as the implicit subtype polymorphism that comes from different objects being capable of responding to the same sets of messages.
14:22:21 <roconnor> { a = 1; b = 2 } == { a = 1} && {a = 1} == { a = 1; b = 3 } ... but { a = 1; b = 2 }  /= { a = 1; b = 3 }
14:22:32 <mm_freak> well, smalltalk-style "polymorphism" is easy to do in haskell
14:22:41 <roconnor> sounds like a nightmare for program reasoning
14:22:54 <j-invariant> roconnor: { a = 1; b = 2 } == { a = 1; b = 3 }
14:23:11 <j-invariant> roconnor: I guess the problem is the implicit type which equality is considered at, when you say:Y
14:23:12 <roconnor> j-invariant: that's not true
14:23:18 <j-invariant> roconnor: { a = 1; b = 2 } ==_A { a = 1; b = 3 }
14:23:20 <j-invariant> then it is okay
14:23:46 <roconnor> j-invariant: I see it as the subtype coercion is not injective.
14:23:56 <j-invariant> { a = 1; b = 2 } ==_A { a = 1}
14:24:09 <j-invariant> { a = 1; b = 2 } /=_AB { a = 1; b = 3 }
14:24:15 <j-invariant> { a = 1; b = 2 } ==_B { a = 1; b = 3 }
14:24:17 <roconnor> j-invariant: that is a fair response maybe
14:24:20 <j-invariant> ooops that should have been A
14:24:44 <roconnor> I wonder if that solves my problems
14:24:53 <j-invariant> I hope! :)
14:24:59 * roconnor still wories
14:25:01 <j-invariant> I don't use records
14:25:18 <roconnor> j-invariant: then you have no problem with record subtyping :D
14:25:23 <j-invariant> exaclyt :D
14:25:51 <monochrom> number theorists write that as { a = 1; b = 2 } ≡ { a = 1}  (mod A). apparently 100 years of number theory doesn't find any contradictions from it.
14:26:59 <roconnor> monochrom: number theoriest never had to write what they did into a computer
14:27:13 <roconnor> monochrom: if it was that easy, then formalizing mathematics in Coq would be a simple matter.
14:27:45 <j-invariant> in number thory   a = b (mod m)  means  a + (m) = b + (m)
14:28:00 <j-invariant> and this is a comparison of infinite objects
14:28:16 <roconnor> j-invariant: that is dedekind's definition
14:28:22 <roconnor> j-invariant: kronecker would disagreee
14:28:39 <monochrom> Coq sucks at quotients. Bad example.
14:28:43 <mm_freak> j-invariant: i simply interpret it as a-b = k*m for some integer k
14:28:51 <j-invariant> roconnor: Kronecker is a constructive mathematician :P of course he does it with algorithms
14:29:00 <ddarius> monochrom: Many computer systems don't do quotients well if at all.
14:29:00 <j-invariant> thdat's cheating
14:29:16 <j-invariant> Coq doesn't do it but is there a language which can?
14:29:31 <dolio> Quotients?
14:29:33 <j-invariant> I have dtried to define polynomials in Coq but I couldn't because of no quotients
14:29:36 <dolio> Nuprl.
14:29:44 <copumpkin> epigram 2?
14:29:59 <dolio> Doesn't exist yet.
14:30:14 <copumpkin> pff
14:30:17 <roconnor> j-invariant: in Coq one typically uses a setoid construction to replace the use of quotients in traditiona mathematics.
14:34:14 <roconnor> monochrom: even formalizing mathematics in Mizar is not a simple matter.
14:35:10 <roconnor> j-invariant: btw, the ssreflect standard library I beleive comes with an extensive polynomial library.
14:35:37 <roconnor> j-invariant: if not it is at least part of the finite group theory project.
14:35:39 <monochrom> there is a lot of self-selection bias. theorem prover authors tend to be obsessed with algebraic data types. they don't care about quotients and their theorem provers are designed against quotients. mathematicians who care about quotients tend not to design theorem provers to begin with.
14:35:39 <j-invariant> roconnor: Ill have a look
14:36:05 <roconnor> j-invariant: er, but it is true that the ssreflect library really only works for polynomials over distcrete rings
14:36:05 <j-invariant> monochrom: that is so weird
14:36:17 <roconnor> j-invariant: so if your base ring isn't descrete, the library won't work well for you :(
14:36:22 <j-invariant> what is a discrete ring?
14:36:30 <j-invariant> like rationals?
14:36:30 <roconnor> j-invariant: a ring with decidable equality.
14:36:33 <roconnor> yes
14:36:36 <ddarius> (A+B) -> C <: A -> C, either 1 2 :: (A + B) -> Int == const 1 :: A -> Int == either 1 3 :: (A + B) -> Int
14:36:38 <j-invariant> oh that is fine
14:36:45 <roconnor> but not the reals
14:37:57 <roconnor> ddarius: ==_(A -> C)
14:38:06 <Philippa> monochrom: yeah, that sucks :-( Granted I think quotients are a harder starting point, but even so
14:38:28 <ddarius> roconnor: The point is it is the same issue as the record case.
14:38:44 <roconnor> ah
14:38:46 <mm_freak> enough of the serious talk…  i don't want to get used to it, because tomorrow i'll have to code PHP again
14:38:52 <mm_freak> good night
14:39:04 <hpc> lol
14:39:07 <roconnor> ddarius: right, there are probably other sorts of subtypes that would distrub me.  In fact most of them probably distrubs me.
14:40:17 <monochrom> either 1 2 and either 1 3 are indistinguishable if all you do is try plugging in parameters of A.
14:40:26 <ddarius> monochrom: Exactly.
14:40:36 <roconnor> monochrom: Mizar is a more or less standard set theory.  I don't think your complaints apply to it.
14:41:42 <ddarius> The solution is to have equality be invariant.
14:42:08 <roconnor> ddarius: forcing explicit casting there?
14:42:11 <monochrom> no, the solution is to give up a God-given equality.
14:42:33 <ddarius> roconnor: Yes.
14:42:45 <roconnor> ddarius: not just equality but order comparision too.
14:42:52 <roconnor> ddarius: and basically every other function
14:43:06 <roconnor> ddarius: thus ending up with a system that has no subtyping
14:47:07 <j-invariant> subtyping makes no sense anyway
14:47:18 <j-invariant> you can identify objects up to isomorphism
14:47:33 <j-invariant> if it's not isomorphism you're mad
14:48:05 <Philippa> subtyping makes perfect sense. It's just that it makes best sense when you have to apply the coercion manually
14:49:18 <roconnor> Philippa: I also think it might make sense if the coercion is injective.
14:50:00 <Philippa> and often you've got a case of "injective modulo..."
14:51:11 <roconnor> is there such a thing as a reader applicative functor transformer?
14:51:12 <monochrom> there is probably an isomorphism between isomorphism and subtyping
14:51:59 <Philippa> monochrom: a `iso` b = a <: b && b <: a?
14:52:36 <roconnor> I guess so
14:52:38 <roconnor> Applicative m => Applicative (ReaderT r m)
14:53:50 <EvanR-work> Num provides + and *, which is like a ring. to get to a field, you need division with some properties, which is like Fractional?
14:54:07 <j-invariant> num has /
14:54:15 <roconnor> @type (/)
14:54:16 <opqdonut> @src Num
14:54:16 <lambdabot> forall a. (Fractional a) => a -> a -> a
14:54:16 <lambdabot> class  (Eq a, Show a) => Num a  where
14:54:16 <lambdabot>     (+), (-), (*)           :: a -> a -> a
14:54:16 <lambdabot>     negate, abs, signum     :: a -> a
14:54:16 <lambdabot>     fromInteger             :: Integer -> a
14:54:17 <EvanR-work> Num dont have division
14:54:35 <roconnor> EvanR-work: I *think* what you say is accurate
14:54:41 <roconnor> @src Fractional
14:54:41 <lambdabot> class  (Num a) => Fractional a  where
14:54:41 <lambdabot>     (/)             :: a -> a -> a
14:54:41 <lambdabot>     recip           :: a -> a
14:54:41 <lambdabot>     fromRational    :: Rational -> a
14:54:45 <EvanR-work> does Num + Fractional imply "Field" ?
14:54:58 <roconnor> Rational is the initial field?
14:55:13 <EvanR-work> initial field?
14:55:15 <roconnor> EvanR-work: you cannot have Fractional without beinga  Nim
14:55:17 <roconnor> *Num
14:55:33 <EvanR-work> Fractional implies Field?
14:55:33 <roconnor> EvanR-work: rationals is the initial object in the category of fields
14:55:43 <roconnor> EvanR-work: Fractional implies Num.
14:55:48 <EvanR-work> i got that
14:55:53 <EvanR-work> rationals eh...
14:55:59 <EvanR-work> but why?
14:56:04 <roconnor> So I think it is fair to say that Num is to Ring as Fractional is to Field.
14:56:19 <qfr> How am I supposed to develop software in Haskell if I can't even prepare my projects in UML?! It seems like an impossible task. Will I have to resort to a simpler model which simply has modules as nodes and then it describes the interactions between the modules using directed edges?
14:56:24 <EvanR-work> there are simplier fields than Q
14:56:44 <EvanR-work> wow. UML.
14:56:47 <kmc> hahaha
14:57:21 <roconnor> EvanR-work: inital means there is a homomorphism from it to every object.  In this class the claim that rationals are the initial field means that there is a field homomorphism from Q to every other field.
14:57:27 <Philippa> qfr: that's a good start, yes
14:57:31 <elliott> qfr: i'll let you in on a secret
14:57:31 <roconnor> EvanR-work: which strikes me as likely true
14:57:35 <elliott> qfr: nobody can actually program in haskell
14:57:46 <elliott> qfr: we've been working on the problem of how to write programs without UML for a few years now
14:57:50 <elliott> but the situation doesn't look good
14:57:57 <qfr> elliott: Yeah, I thought as much
14:58:02 <elliott> the largest program so far was 100 lines i think, people got a few papers out of that
14:58:06 <Philippa> qfr: you can make quite large amounts of UML still work with a little tweaking though
14:58:13 <EvanR-work> roconnor: field homomorphism... its been a while..... whats does that mean for the relationship between Q and the trivial field, or a small finite field?
14:58:19 <elliott> Philippa: really? got any links? maybe i can get a program to 110 lines :D
14:58:32 <EvanR-work> elliott: lol
14:58:33 <qfr> Writing software without methods seems like a futile task, it's like a setback to the days of purely procedural programming
14:58:45 <kmc> fortunately 100 lines of Haskell is enough to solve the halting problem, so that's okay
14:58:47 <Philippa> (I find the types used to communicate between modules are usually the biggest deal)
14:58:52 <elliott> UML is a great way to cover up for the fact that your language is making you think stupidly.
14:58:54 <j-invariant> qfr: how do methods help?
14:58:57 <Philippa> qfr: what's the big deal about methods specifically?
14:59:05 <kmc> qfr, my method is that I think really hard about what I want the machine to do, and then I write it down
14:59:09 <elliott> And a great way to cover up that your code is hideously complex relative to your actual _model_.
14:59:16 <elliott> Haskell ... doesn't really help with that, no.
14:59:21 <elliott> And thank god for that.
14:59:21 <quuuux> I've heard Oleg has made some progress with encoding the type system, including rank N types, into UML, so there's hope
14:59:21 <qfr> kmc the suits won't like that
14:59:26 <Philippa> (remember, you will have a bunch of functions that operate around a specific type and take much of the role of methods)
14:59:29 <kmc> qfr, Haskell is not much loved by "suits"
14:59:42 <EvanR-work> UML convo flood
14:59:43 <ddarius> roconnor: The category of fields is a poset.
14:59:50 <roconnor> EvanR-work: it means there is a function from Q to the small field that preserves all the field operations.  Oh wait, there are no nontrivial field homomorphisms
14:59:56 <qfr> kmc: The suits want to be pleased, they want to take part in waht the grunts do. They want to get the programming experience without the code, if you catch my drift. Diagrams are a great way to achieve this.
14:59:56 <elliott> qfr: are you joking, trolling, or just completely alien to me? :) i'm honest, i can't tell
14:59:58 <kmc> though i think people who talk about "suits" are usually smug douchebags
15:00:14 <elliott> A "suit" like that won't be able to understand a single Haskell function.
15:00:22 <Philippa> qfr: you /can/ translate UML into haskell, it just requires some encoding. So that's the business-level design taken care of. For low-level design, UML's not actually all that good for haskell for a variety of reasons
15:00:29 <elliott> But hey, why let programmers do what programmers are paid to do when I can act as if I know more than they do?
15:00:42 <elliott> It's not a programming language's job to work around that sort of disease.
15:00:48 <roconnor> ddarius: what's the initial field?
15:01:06 <kmc> those worthless suits, all they know how to do is run a business and manage money
15:01:12 <dolio> Q seems likely.
15:01:20 <Philippa> elliott: the problem is that the 'disease' is surprisingly hard to replace with a coherent entity - and that's bad for the suits because it means they can't make their strategy concrete
15:01:22 <kmc> that's easy compared to my job as a hacker ninja wizard, writing porn sites in PHP
15:01:25 <dolio> With {0,1} terminal.
15:01:26 <qfr> elliott: It was half joke, half serious reflection on the subject of how to cleanly plan and structure larger amounts of code in Haskell, I am glad that some people actually answered sincerely though while there was some amusing stuff, too
15:01:31 <monochrom> xmonad and yesod were built without a single line of UML
15:01:37 <elliott> qd
15:01:39 <elliott> oops
15:01:44 <elliott> qfr: You plan by thinking and writing things down :-)
15:01:46 <roconnor> dolio: every field homomorphism is either injective :(
15:01:46 <aristid> kmc: you're a rockstar
15:01:49 <elliott> English > diagrams.
15:01:54 <Philippa> qfr: message passing between haskell threads works /very/ nicely for some classes of problem - including many business domain ones
15:01:56 <kmc> oh sorry, *rockstar* hacker ninja wizard
15:01:56 <elliott> kmc: omg do you use jquery
15:02:08 <kmc> qfr, there have been articles / stack overflow questions about how to structure large Haskell programs
15:02:10 <elliott> kmc: i bet you're, like, constnatly surrounded by women
15:02:10 <ddarius> @google "Functional Algorithm Design"
15:02:12 <elliott> *constantly
15:02:12 <lambdabot> http://portal.acm.org/citation.cfm?id=227829
15:02:12 <lambdabot> Title: Functional algorithm design
15:02:13 <roconnor> EvanR-work: well, maybe we should think of Fractional as Fields of characteristic 0 :D
15:02:13 <aristid> elliott: and node.js
15:02:20 <elliott> aristid: SO HARDCORE
15:02:24 <kmc> asking that question is probably more useful than asking about UML though i did get a good chuckle out of it
15:02:26 <EvanR-work> qfr: words like clean and messy are misleading to yourself
15:02:40 <Philippa> ddarius: the problem isn't algorithm design though
15:02:44 <EvanR-work> roconnor: i forgot what characteristic is
15:02:50 <elliott> the great thing about haskell is, if you write a reaaaally ugly function, you can't localise the hideous
15:02:57 <elliott> it starts cropping up all over your program :)
15:03:08 <elliott> so haskell forces you to write... maybe not well, but not /absolutely terribly/
15:03:20 <Philippa> ddarius: the problem is, suits don't get the generality of haskell code or the ease of refactoring, for example, so how you engineer for growth is completely foreign to them
15:03:29 <ddarius> This is what I was looking for: http://www.google.com/url?sa=t&source=web&cd=6&ved=0CEAQFjAF&url=http%3A%2F%2Fkar.kent.ac.uk%2F13634%2F2%2Ffad_a_functional_analysis_russell.ps&rct=j&q=functional%20algorithm%20design%20UML%20fad&ei=EpArTfK3NYT68AaO2Nm7AQ&usg=AFQjCNETBzT4NQu4asacYNCy5-_OO7u88Q&cad=rja
15:03:35 <ddarius> Freakin' Google.
15:03:39 <monochrom> use Jackson Structured Design to structure a large haskell program.
15:03:43 <ddarius> kar.kent.ac.uk/13634/2/fad_a_functional_analysis_russell.ps
15:03:45 <roconnor> EvanR-work: the "smallest" n such that 1 + 1 + ... + 1 (n times) = 0, where smallest measn smallest in the divisibility lattice.
15:03:52 <ezyang> Oh man, I hate that behavior. 
15:04:08 <ezyang> Does anyone know how to make it not do that? 
15:04:13 <ddarius> Philippa: I wasn't looking for algorithm design, I was looking for FAD.  I just forgot what it stood for.
15:04:14 <roconnor> EvanR-work: for characteristic 0 it means taht the only  n such that 1+ 1+ .. + 1 (n times) = 0 is 0.
15:04:20 <aristid> ezyang: which behavior?
15:04:21 <EvanR-work> roconnor: 'infinite fields' ?
15:04:30 <ezyang> Right-click copy URL not working for Google search results. 
15:04:33 <Philippa> monochrom: it's been a loooong time since I read much about it, how well does it play with things like EDSLs as design strategy and the level of polymorphism that we like to exploit?
15:04:34 <dolio> roconnor: You mean they're all injective, or did you leave out a case?
15:04:37 <elliott> ezyang: there are some firefox extensions to do it i think
15:04:38 <aristid> ezyang: ah.
15:04:40 <elliott> ezyang: or probably user scripts
15:04:43 <elliott> to disable their tracking
15:04:45 <elliott> which is the same thing
15:04:50 <roconnor> EvanR-work: all fields are characteristic 0 are infinite, but there are infinite fields that are not characteristic 0.
15:04:57 <EvanR-work> ah
15:05:01 <ezyang> Greasemonkey script is right out, fwiw. 
15:05:06 <dolio> Anyhow, I haven't thought about fields in a long time.
15:05:12 <qfr> kmc: Originally my whole diagram meme thing started out a few days ago when we were making fun of CS people who prefer to draw diagrams for weeks without ever doing any actual work and I ended up downloading Visio and making a convoluted but fancy diagram of a project I finished a while ago, many people found it very amusing. So, now that I want to dive into Haskell I wanted to do the academic stereotype justice since the people in the Haskell community tend t
15:05:13 <qfr> o come from an academical background, mostly CS - I said that I wasn't going to write a single line of Haskell without drawing diagrams of what I wanted to do first.
15:06:07 <Philippa> qfr: we don't usually do that unless it's a category diagram :p We're more algebraic
15:06:08 <roconnor> qfr: people coming from CS draw diagrams?
15:06:22 <qfr> roconnor: That's the stereotype, no?
15:06:29 <monochrom> well the way I understand JSD, it just says "write down the names of a few abstract data types, write down the specifications for the functions over them", which is what everyone has been doing anyway, even EDSL and polymorphic types and functions.
15:06:30 <EvanR-work> qfr: youre going to need to throw a lot of abstract math terms on there for it to be remotely funny
15:06:38 <roconnor> that might explain what I see in Communications of the ACM.
15:06:48 <qfr> roconnor: I am currently finishing my MSc in CS and I have had at least 4 classes which dealt with UML. One of them was actually an EE class, amazingly enough.
15:06:59 <elliott> qfr: My condolences.
15:07:01 <monochrom> and of course s/function/value/ if you want to say "getLine :: IO String" is not a function.
15:07:01 <roconnor> crazy
15:07:04 <Pseudonym> I use diagrams a lot, but at the moment, I seem to be designing a lot of data structures.
15:07:18 <roconnor> qfr: I have a PhD in CS and have never seen UML at all in my entire life.
15:07:19 <EvanR-work> qfr: thats offensive. what are they teaching people in universities >_<
15:07:34 <qfr> Pseudonym haha, do you use any formal method or do you just randomly draw boxes with descriptions and icons and connect them with arrows?
15:07:35 <roconnor> qfr: interesting
15:07:48 <Itkovian> roconnor: I saw it once and avoided it like hell :-D
15:07:51 <Philippa> monochrom: yeah, the haskell revision is to exploit polymorphism like crazy and do abstract algebra across the types
15:07:57 <Pseudonym> qfr: Random, because that's what I'm doing.
15:08:00 <roconnor> I'm not convinced UML is all that bad.
15:08:08 <Pseudonym> By "data structure", I don't mean "database schema".
15:08:14 <roconnor> AFAIU anything that makes you think about what you are doing is helpful.
15:08:21 <Itkovian> roconnor: no, when used for the intended puprpose, it may be good, actually
15:08:24 <Pseudonym> I mean "structured bags of bits".
15:08:26 <Itkovian> the problem is the rest of its use
15:08:36 <EvanR-work> Pseudonym: bag, or vector?
15:08:38 <roconnor> Itkovian: sounds like we agree
15:08:40 <companion_cube> UML is like XML, it can be useful but is not the miracle solution everyone seems to believe it is
15:08:56 <qfr> roconnor: Really? Haha, sounds like a better university. I attend the Karlsruhe Institute of Technology which is considered top of the line for CS in Germany. Maybe some of the people here are actually not so bad - one of the lecturers actually used Haskell over Java in the 101-like CS classes - however I didn't get that one.
15:09:19 <Pseudonym> EvanR: At the lowest level, collection of vectors.
15:09:31 <Pseudonym> But they represent compressed data, so it could be anything.
15:09:38 <ddarius> This link is better: http://www.cs.kent.ac.uk/pubs/2001/1152/
15:09:41 <Pseudonym> At the moment, I am indeed working on bags.
15:10:02 * hackagebot eprocess 1.5.1 - *Very* basic Erlang-like process support for Haskell  http://hackage.haskell.org/package/eprocess-1.5.1 (FernandoBenavides)
15:10:27 <EvanR-work> Pseudonym: well a bag is not very descriptive xD
15:10:35 <qfr> So the general stereotype of CS academia is essentially superficial knowledge of Java, drawing UML diagrams and never doing any actual work to me
15:10:38 <Pseudonym> :-)
15:10:46 <EvanR-work> a bag of bits is essentially two integers, number of zeros and number of ones
15:10:52 <Pseudonym> Which is sometimes usefuol.
15:10:56 <EvanR-work> hehe
15:10:56 <roconnor> @unmtl a -> ReaderT E m a
15:10:56 <ezyang> @djinn a -> b -> c -> a 
15:10:56 <lambdabot> a -> ReaderT E m a
15:10:57 <lambdabot> f a _ _ = a
15:11:05 <roconnor> @unmtl ReaderT E m a
15:11:05 <lambdabot> E -> m a
15:11:10 <ezyang> @pl (\a _ _ =a) 
15:11:11 <lambdabot> (line 1, column 9):
15:11:11 <lambdabot> unexpected "="
15:11:11 <lambdabot> expecting pattern or "->"
15:11:17 <EvanR-work> Pseudonym: i suppose you could encode any data structure into just one of those integers ;)
15:11:18 <ezyang> @pl (\a _ _ -> a) 
15:11:19 <lambdabot> const . const
15:11:27 <quuuux> is there any way to make cabal check to see if it's breaking (or even potentially breaking) packages when it installs one? E.g., just looking to see if foo-1.0 is already in the (user|global) database and asking for confirmation would be a start
15:11:35 <Pseudonym> Goedel numbering!
15:11:36 <ezyang> orite 
15:11:46 <EvanR-work> future computers will have hardware acceleration for bit bags
15:12:55 <Pseudonym> @let choose n k = if k < 0 || k > n then 0 else product [n-k+1..n] `div` product [1..k]
15:12:56 <lambdabot>  Defined.
15:13:27 <Pseudonym> @let 
15:13:28 <lambdabot>  Defined.
15:13:32 <Pseudonym> @let decode max 0 x = []
15:13:32 <qfr> Pseudonym: Also, what program do you use to draw diagrams? I've checked out Visio, yEd, graphviz, OO Draw, Dia, still want to check out Kivio, too, haha
15:13:33 <lambdabot>  Defined.
15:13:36 <aristid> @undef
15:13:36 <roconnor> > [7-8+1..n] `div` product [1..8]
15:13:37 <lambdabot>   No instance for (GHC.Real.Integral [SimpleReflect.Expr])
15:13:37 <lambdabot>    arising from a ...
15:13:40 <monochrom> first use "cabal install --dry-run hahahehe" to see what would be installed. then go through the list to say "yes that kosher" "no why are you re-installing that?"
15:13:42 <msieradzki> qfr, I don't find anything in UML superficial
15:13:45 <aristid> :t decode
15:13:45 <Pseudonym> @let decode max k x = let (n,cnk) = head [ (n,cnk) | n <- [0..max-k], let { cnk = choose (max - n - 1) k }, cnk <= x ] in n : decode max (k-1) (x-cnk)
15:13:46 <lambdabot>  <local>:1:77: Not in scope: `choose'
15:13:47 <lambdabot> Not in scope: `decode'
15:13:48 <roconnor> > [7-8+1..7] `div` product [1..8]
15:13:49 <lambdabot>   No instance for (GHC.Real.Integral [t])
15:13:49 <lambdabot>    arising from a use of `e_1781718...
15:13:51 <msieradzki> if you document business processes and such
15:13:54 <roconnor> > product [7-8+1..7] `div` product [1..8]
15:13:55 <lambdabot>   0
15:13:57 * ddarius has an inkling that Pseudonym uses a pencil or similar writing device.
15:14:05 <Pseudonym> @let decode max k x = let (n,cnk) = head [ (n,cnk) | n <- [0..max-k], let { cnk = L.choose (max - n - 1) k }, cnk <= x ] in n : decode max (k-1) (x-cnk)
15:14:05 <roconnor> > product [7-(-1)+1..7] `div` product [1..(-1)]
15:14:05 <lambdabot>  <local>:1:77: Not in scope: `L.choose'
15:14:06 <lambdabot>   1
15:14:14 <roconnor> :O
15:14:15 <Pseudonym> Yes, I prefer the Stanford Col-Erase pencil.
15:14:20 <Pseudonym> ;Hrm.
15:14:20 <qfr> Haha
15:14:27 <lispy> Cale: ping
15:14:27 <Pseudonym> Why can't I choose choose?
15:14:39 <EvanR-work> > choose choose
15:14:39 <lambdabot>   Not in scope: `choose'Not in scope: `choose'
15:14:44 <qfr> What's the point if you can't post the diagrams on IRC right away? I live on IRC!
15:14:52 <qfr> All the people who matter are on IRC
15:15:00 <monochrom> you can post SVG code if you want
15:15:00 <EvanR-work> scanner script which uploads to imagebin
15:15:01 <ddarius> You can't post diagrams on IRC anyway.
15:15:04 * hackagebot hint-server 1.2.1 - A server process that runs hint.  http://hackage.haskell.org/package/hint-server-1.2.1 (FernandoBenavides)
15:15:06 <qfr> monochrom: Hahaa
15:15:24 <qfr> ddarius: Well duh, links to SVG/PNG obviously
15:15:38 <Pseudonym> I have also been known to use Staedtler and Faber Castell, BTW.  They both work just fine for this purpose.
15:15:48 <ddarius> qfr: Just post links to your notebook.
15:15:49 <Pseudonym> The Pitt Artist Pen is especially nice.
15:16:14 * ddarius hasn't really used technical colored pencils.
15:16:40 <Pseudonym> I do recommend col-erase.
15:16:48 <Cale> lispy: hi
15:16:50 <Pseudonym> They don't really erase _that_ well.
15:17:01 <ezyang> i,i technicolor pencils 
15:17:06 <ddarius> Pseudonym: I'm not aware of any colored pencils that erase well.
15:17:17 <kmc> qfr, your stereotype of CS academia is my stereotype of programming industry (and the schools which act as vocational training for same)
15:17:21 * ddarius has a full set of Prismacolors, but not for technical work.
15:17:38 <kmc> neither my CS education nor the various programming jobs i've held since then match up with either stereotype
15:17:42 <quuuux> monochrom: my use-case isn't installing things off Hackage using cabal-install, I'm afraid. I'm using a package database (not one of the default ones) for hot-swapping, and there's an annoying technical limitation in GHC that means it won't re-import a package with the same version number, ever.
15:17:58 <Pseudonym> ddarius: These do better than most.
15:18:01 <lispy> Cale: do you know why lambdabot has been using so much CPU in the last 24 hours?
15:18:05 <Cale> no idea
15:18:06 <lispy> Cale: it's just going crazy
15:18:09 <Pseudonym> They're the tool of choice for most traditional animators.
15:18:20 <Cale> I'll take a look
15:18:21 <ddarius> Pseudonym: Interesting.
15:18:22 <qfr> ddarius: Like, as data NotebookLink = NotebookLink { angle1 :: Float, angle2 :: Float, distanceFromOrigin :: Float } --or something similar?
15:18:38 <EvanR-work> kmc: maybe a decent cs education wards off IT stereotypes. maybe replace cs and it with formal parameters and generalize ;)
15:18:40 <qfr> The origin being the hypothetical center of the earth
15:18:46 <Cale> lispy: That's not lambdabot
15:18:47 <ddarius> qfr: That is indeed one solution.
15:18:51 <Pseudonym> I believe that old-school architects also like them.
15:18:51 <Cale> lispy: That's mueval-core
15:19:31 <lispy> Cale: What can we do about it?
15:19:31 <qfr> Although you also need a framce of reference for the angles then
15:19:42 <qfr> Perhaps a geographical pole
15:19:42 <lispy> Cale: is it legitimate usage or is it a run-away process?
15:19:53 <qfr> Although it might seem more natural to pick a magnetic pole
15:20:17 <ddarius> qfr: Why?  The magnetic pole moves.
15:20:17 <Cale> lispy: I'll add a -9 to my script which cleans up runaway muevals.
15:20:24 <dino-> Hey, I used to be able to navigate quickly from the haskell.org main page to the GHC pages (say, for downloading the ghc installer). It's all changed!
15:20:26 <qfr> ddarius: Oh, right :(
15:20:30 <lispy> Cale: ah, thanks
15:20:33 <qfr> I forgot about those problems
15:20:38 <Cale> lispy: It had apparently been trying to kill it, but wasn't able to.
15:20:39 <lispy> gwern: ^^
15:20:47 <monochrom> just type in www.haskell.org/ghc/
15:20:52 <Pseudonym> Woah.
15:21:11 <Pseudonym> I'm getting my name on a human research ethics committee application.
15:21:13 <dino-> monochrom: thanks. But removing that from main page: bad
15:21:22 <Pseudonym> That's a first.
15:21:42 <quuuux> will anyone believe it, seeing as how you're Pseudonym? :)
15:21:59 <monochrom> please help approve all research involving "passing electric current through humans".
15:22:50 <ddarius> monochrom: For you: http://www.ted.com/talks/lang/eng/sherwin_nuland_on_electroshock_therapy.html
15:23:20 <monochrom> there is something redundant about "monochrom: For you:"
15:23:39 <ddarius> monochrom: I thought about that but redundancy isn't always bad.
15:23:42 <shachaf> For you: You're right.
15:23:49 <Pseudonym> It's amazing what you need ethics approval for these days.
15:23:53 <aristid> Monochrome: it is absolutely unnecessary.
15:24:34 <Pseudonym> It's not so amazing that the forms tend to be written for research projects not in computer science, and so tend to be fairly unhelpful here.
15:25:04 <qfr> Btw how common is it even to use named componets in types in Haskell like in the following example: data NotebookLink = NotebookLink { angle1 :: Float, angle2 :: Float, distanceFromOrigin :: Float } --? Since I come from C++, Ruby, Python, etc I have a strong drive to use that when defining types. What is the preferred way of modeling more complex types in Haskell? Do you try to decompose them into multiple simpler types where all types are ultimately unammed 
15:25:04 <qfr> like in data Blah = Type1 Type2 | Type 3 and then you simply combine them until you have a more complex type?
15:25:34 <dino-> I guess we're trying to gently nudge people to use the Platform is really the thing.
15:25:36 <Pseudonym> qfr: It's common for types which are essentially records.
15:25:41 <monochrom> pretty common
15:26:00 <ezyang> qfr: A less common approach is to newtype like hell, but that doesn't work too well when you have angle1 and angle2 :-) 
15:26:06 <monochrom> they even do it with merely newtype State s a = State { runState :: ...
15:26:42 <qfr> ezyang heh ok
15:26:43 <Pseudonym> People don't use views enough.
15:26:45 <Philippa> Pseudonym: research on programming language usability is unethical due to the mental pain inflicted by unpleasant langs? :-)
15:26:56 <ezyang> long live view patterns 
15:26:56 <Pseudonym> :-)
15:27:14 <qfr> Views in what sense? I only know the term from PostgreSQL
15:27:26 <ddarius> Philippa: Is it unethical if the subjects are nevertheless willing?
15:27:39 <Pseudonym> qfr: THat's pretty much what they are.
15:28:00 <Pseudonym> http://www.haskell.org/haskellwiki/Concrete_view
15:28:08 <Pseudonym> http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
15:28:15 <monochrom> view: http://www.haskell.org/ghc/docs/7.0-latest/html/users_guide/syntax-extns.html#view-patterns
15:28:22 <Pseudonym> Ah, yes, the manual.
15:28:32 * Pseudonym considers reading the manual cheating
15:28:51 * ddarius distinguishes between views and view patterns (which, in an earlier incarnation, were called "transformational patterns.")
15:29:07 <ddarius> Pseudonym: Is reading the source code cheating?
15:29:11 <ezyang> ddarius: Huh. 
15:29:16 <Pseudonym> Definitely not!
15:29:33 <monochrom> reading the sgml source code of the manual is not cheating
15:29:54 <mrd> I like how http://www.ohloh.net/p/gtk2hs says that Gtk2hs is "Mostly written in Pascal"
15:30:00 * Pseudonym once debugged a Windows program by downloading the stolen Win2k source code to work out what was going wrong
15:30:13 <monochrom> hahaha
15:30:35 * ddarius has Pseudonym extradited and fined.
15:30:59 <quuuux> mrd: /p/ -> /h/ is an entirely plausible diachronic sound change!
15:31:13 <shachaf> quuuux: But the emphasis is on the wrong syllable.
15:31:16 <monochrom> Hascal
15:31:29 <mrd> quuuux: I've encountered that when speaking, but not when writing
15:31:43 <Kaidelong> any chance monadic regions will make it into GHC some time in the future?
15:31:54 <djahandarie> monochrom, is that related to Hascale?
15:31:55 <mrd> quuuux: and certainly not when analyzing the contents of a source folder :)
15:31:55 <Twey> Everybody always thinks I said ‘Pascal’ *grumph*
15:31:59 <monochrom> no
15:32:05 <qfr> shachaf: That change is minor in comparison to phonemic shifts such as the one quuuux mentioned
15:32:05 * ddarius doesn't know what Kaidelong is talking about.
15:32:07 <quuuux> mrd: well, I make phonetic typos. I kept typing 'frontent' earlier
15:32:12 <djahandarie> Is Hascale related to webscale?!?!
15:32:27 <qfr> Stress can even vary dialectically even within the same language
15:32:31 <ddarius> Twey: It is possible that you are always saying Pascal.
15:32:47 <Twey> ‘What are you using?’ ‘Haskell.’ ‘Oh, Pascal?’ ‘No, Haskell.’ ‘Oh, I've heard of that… what's special about it again?  It forces you to use only OO techniques?’  ‘No.’
15:32:48 <ddarius> HasCale
15:32:53 <qfr> Haskell -> Hakarl
15:32:54 <qfr> http://en.wikipedia.org/wiki/Hakarl
15:32:59 <Twey> ddarius: Heh.
15:33:00 <monochrom> there was a time I mistyped Handle for Handel and vice versa
15:33:02 <mrd> quuuux: I'm pretty sure that webpage is determining the source language programmatically though
15:33:12 <qfr> Recursively fermenting shark meat.
15:33:21 <Kaidelong> ddarius: alternative to garbage collection where you infer where destructors go, as I understand it
15:33:40 <mrd> @seen dcoutts_ 
15:33:40 <lambdabot> Unknown command, try @list
15:33:40 <preflex>  dcoutts_ was last seen on #haskell 23 hours, 28 minutes and 26 seconds ago, saying: qfr: just because there is a later version doesn't mean you have to upgrade immediately :-)
15:33:47 <ddarius> Kaidelong: In the usual case, wouldn't this be completely transparent to the user?
15:33:52 <qfr> Curse you dcoutts.
15:34:05 <qfr> I did upgrade ultimately and now I am a bleeding edge Hakarler!
15:34:09 <qfr> err I mean, Haskeller!
15:34:23 <Kaidelong> I think so? It's a compiler implementation thing, not really that visible to the programmer
15:34:28 <Kaidelong> but it looks like a good idea
15:34:45 <ddarius> It has its benefits, but it also has significant issues.
15:35:23 <mrd> quuuux: /p/ is a partially voiced /h/ though.  I like how in hiragana the same character is used for /h/, /p/ and /b/ syllables with different diacritical marks
15:35:48 <ddarius> Kaidelong: Have you looked at Fluet's thesis, by the way?
15:36:21 <qfr> mrd: Yeah, I came across that a few weeks ago
15:36:40 <qfr> There's also the orthographical connection between [s] and [S] in Hiragana
15:36:49 <Philippa> Kaidelong: also, "A Linear Bestiary" is worth a read
15:37:18 <qfr> Wait, not [S]
15:37:23 * mrd was wondering
15:37:29 <qfr> [ɕ] in proper IPA :(
15:37:34 <Philippa> monadic regions probably aren't a good choice for Core or similar
15:37:38 <qfr> (S was supposed to be X-SAMPA btw)
15:37:42 * mrd does not know proper IPA, unless you mean Smuttynose IPA
15:37:42 <quuuux> mrd: only in Japanese :) /p/ is a labial stop. /h/ is a glottal fricative. In Japanese, what happens is that /h/ is (can be) realised with bilabial articulation, so /f/ gets lumped in on that row of the kana too
15:37:43 <qfr> (post-alveolar fricative)
15:37:56 <gwern> lispy: sure, but *why* isn't mueval-core being killed by its watchdog?
15:38:07 <mrd> quuuux: /f/ is only for one syllable and it's not the same as english
15:38:30 <Pseudonym> It turns out that automatically detecting languages is hard.
15:38:35 <qfr> ha hi fu he ho, same group of gojuon
15:38:43 <mrd> right
15:38:43 <Pseudonym> Even many humans can't tell the difference between Indonesian and Malay.
15:38:56 <quuuux> mrd: right. It's not actually [f], it's... [P], I think. Anyway, it's close enough to [f] that things get confusing in the allophone marshes
15:39:00 <qfr> Pseudonym: My flatmate is from Jawa
15:39:19 <qfr> We jokingly refer to fruit in their Indonesian names
15:39:21 <Pseudonym> Selamat pagi to your flatmate.
15:39:22 * ddarius doesn't even know if he's heard Malay.
15:39:25 <qfr> Hehe
15:39:29 <Pseudonym> Have you tried durian?
15:39:32 <qfr> No.
15:39:39 <Pseudonym> Probably for the best.
15:39:41 <gwern> qfr: it's 18:39; do you know where your droids are?
15:39:42 <qfr> Today I bought 3 big jeruk bali
15:39:50 <mrd> I found durian in a freezer in my local market
15:39:58 <mrd> that was scary
15:40:01 <Pseudonym> Does he leave his kaus kaki lying around?
15:40:02 <qfr> Pseudonym: my flatmate used to eat durian when he was a kid, he told me
15:40:29 <qfr> lol I had to look that up
15:40:33 * Pseudonym did two years of Indonesian in high school
15:40:44 <qfr> Curious :D how come? Are you from SEA?
15:40:46 <Pseudonym> This is about as much as I can remember.
15:40:50 <Pseudonym> Yeah, Australia.
15:41:45 <qfr> Pseudonym: What are the most common foreign languages to be taught in primary/highschool and how many are mandatory?
15:42:05 <Pseudonym> qfr: I have no clue.  I went to a Lutheran school, so German was mandatory.
15:42:10 <qfr> Ew :/
15:42:16 * qfr speaks German natively
15:42:22 <Pseudonym> Oddly enough, both of my kids, going to different government schools, are both also doing German.
15:42:32 <Pseudonym> I have no idea why German is so popular around here.
15:42:39 <qfr> Poor kids
15:42:44 <ddarius> English is a Germanic language.
15:42:49 <qfr> Indeed
15:42:49 <monochrom> poor German
15:42:51 <qfr> West Germanic
15:42:56 <Pseudonym> Anglo-Saxon is Germanic.
15:42:58 <qfr> Just like German
15:43:06 <Pseudonym> English is a bastard of Germanic and Gallic.
15:43:14 <Ke> and latin
15:43:21 <ddarius> Nowadays, English is a bastard of many, many languages.
15:43:26 <Pseudonym> Well, Germanic languages are Romance languages.
15:43:29 <qfr> However North Germanic languages like Norwegian and Swedish are actually simpler to learn than German, I think
15:43:35 <qfr> For native speakers of English that is
15:43:41 <Kaidelong> ddarius: that's what got me on this, yes
15:43:47 <Pseudonym> I _think_ the easiest Indo-European language to learn is Farsi.
15:43:51 <qfr> <Pseudonym> Well, Germanic languages are Romance languages. <- ? Eh?
15:43:53 <qfr> They are not
15:43:59 <Kaidelong> I'll have to look into the disadvantages
15:44:02 <Pseudonym> At least that's what my Iranian cow-orker keeps telling me.
15:44:08 <Pseudonym> qfr: Sorry, you're right.
15:44:12 <Pseudonym> Coffee hasn't kicked in yet.
15:44:17 <qfr> Germanic languages and Romance languages are different branches of the Indo-European family
15:44:18 <quuuux> qfr: The Holy Roman Empire begs to differ! :)
15:44:32 <qfr> However they were in close proximity for thousands of years
15:44:38 <qfr> So there was a big sprachbund
15:44:46 <qfr> A lot of lexicon is shared
15:44:53 <qfr> Although the core grammar is still different
15:45:19 <qfr> Pseudonym: Is Farsi easy? I have no idea, but the whole Abjad thing definitely ruins it for me.
15:45:21 <aristid> Pseudonym: Iranian (that's his nick) says you might be right about farsi :P
15:45:24 <ddarius> We'll have Carolus Magnus and Karl der Groe fight it out.
15:45:42 <aristid> ddarius: is charlemagne invited to the fight as well`
15:45:44 <qfr> I was playing with Arabic recently but the Abjad really is a huge pain for foreigners
15:45:45 <aristid> ?
15:45:46 <qfr> aristid haha
15:45:48 <quuuux> is there actually a sprachbund? Looking at, say, Belgium or Switzerland, it seems like there's more bilingualism than borrowing
15:46:18 <Pseudonym> Abjad isn't so hard, especially if you already speak Quenya.
15:46:34 <qfr> quuuux I'm sure they share an even greater lexicon dialectically than is usual for French French and Italian Italian etc
15:46:48 <qfr> I know that Flemish Dutch does, for example
15:47:09 <qfr> I was recently watching a Flemish movie, they used a ton of French loans and expressions
15:47:17 <Pseudonym> It's true, though, that languages in Semitic alphabets tend to be exercises in decipherment to begin with.
15:47:24 <qfr> Pseudonym yeah haha
15:47:31 <qfr> Even if it had full vowels it would still be a pain
15:47:35 <qfr> At least with Arabic
15:47:44 <quuuux> qfr: Intresting. I know some Belgian Francophones, and they speak something pretty close to standard French (though I think there's definitely some register switching going on)
15:47:51 <qfr> Hebrew is arguably easier although several letters still look annoyingly similar :P
15:47:52 <Pseudonym> But Farsi has, for example, no genders on nouns.  Or pronouns.
15:48:15 <qfr> Pseudonym: But how much agreement does it generally have?
15:48:21 <sproingie> only time you see fully vowelled arabic is quotes from the quran, and then it's often drawn extra-squiggly for artistic reasons
15:48:22 <qfr> How large is the number of inflections?
15:48:26 <hpc> Pseudonym: that's a feature
15:48:28 <sproingie> with ligatures and such that don't exist anywhere else
15:48:31 <Pseudonym> Yes, it is.
15:48:38 <Pseudonym> qfr: Not sure.
15:48:42 <qfr> sproingie yeah haha :(
15:49:01 <Kaidelong> Phillipa: So a compiler that relies on monadic regions would probably use something other than Core as its intermediate language?
15:49:11 <Kaidelong> and thus probably not be GHC?
15:49:13 <qfr> That's what I find so brutal about German, for example, there is an excessive degree of word agreement and there are so many inflections for adjectives, nouns and verbs etc
15:49:27 <sproingie> meh german was easy
15:49:39 <Kaidelong> hmm, at an implementation level, is IO done with things resembling linear types?
15:49:46 <ddarius> Kaidelong: No.
15:49:54 <sproingie> i hardly remember any german but the only thing that struck me as weird were uncommon verb tenses
15:50:36 <ddarius> Kaidelong: I highly suspect that it would take significant work to make a monadic regions based storage system for GHC that provided any kind of consistent improvement.
15:50:53 <aristid> sproingie: english is your native language?
15:50:58 <qfr> The first thing I found annoying in Arabic is that the tenses of a verb have an impact on the cases of their objects
15:51:13 <qfr> In the past tense they change from the nominative to the accusative :/
15:51:18 <Itkovian> I have a program, built using GHC 6.12.3. On once linux machine this program finished in < 1s, uses 191M heap (using -sstderr). On another machine, the same binary spins off into consuming > 1GB resident heap, using the same input set. Any tips on how to investigate?
15:51:20 <sproingie> aristid: yep
15:51:49 <qfr> sproingie: I find all the rules about word order in German painful, too
15:52:07 <sproingie> i have a couple books and cds on arabic but i havent studied it that much.  but it's freakin difficult
15:52:23 <sproingie> telling long vowels apart from short, damn near impossible for me
15:52:52 <sproingie> they're long as stretched out, not actually a different sounda
15:52:58 <quuuux> do I need `Build-Type: Custom' if all I'm doing is using some UserHooks?
15:52:59 <sproingie> -a
15:53:05 <Itkovian> The program is quite simple, but alas, I cannot provide the sources
15:53:16 <aristid> qfr: if german is your native language, you should not have any trouble with word order
15:53:20 <monochrom> perhaps it's 32-bit vs 64-bit
15:53:30 <Saizan> quuuux: yes
15:54:02 <hpc> Itkovian: are you running the same binary on both, or compiling on both?
15:54:06 <Itkovian> monochrom: you talking to me? both machines are 64-bit
15:54:10 <Itkovian> the same binary
15:54:12 <hpc> oh
15:54:23 <hpc> same version of GHC i assume
15:54:28 <Itkovian> It's built on the machine where it fails
15:54:33 <hpc> check library versions possibly
15:54:34 <Itkovian> yes, same GHC 6.12.3
15:54:37 <hpc> er
15:54:54 <qfr> aristid: Well it is, so I don't, that doesn't make it any easier though and I see people struggle with this stuff on linguistics channels on IRC
15:55:08 <hpc> how strange...
15:55:14 <Itkovian> indeed :-/
15:55:23 <Itkovian> prolly something stupid, but I am clueless
15:55:45 <hpc> these sorts of errors usually are
15:55:46 <Saizan> env vars? dynamically linked libs?
15:55:51 <hpc> but it is subtle stupidity
15:56:02 <hpc> and thus significantly less stupid
15:56:03 <ddarius> Unless it's crashing on one and not on the other.
15:56:12 <hpc> ddarius: no, he said it just explodes
15:56:25 <Itkovian> well, one machine is a Xen VM ... but that should not cause my binary to go bezerk, no?
15:56:39 <ddarius> hpc: I'm talking about the actual semantic behavior of the program.
15:56:48 <Itkovian> well, not sure if it crashes since I have to kill it as it consumes all mem
15:57:03 <hpc> ah
15:57:14 <Itkovian> but it should really not do that
15:57:39 <ddarius> If one simply terminates with "Could not load foo.so" it will probably much faster and less memory hungry than one that works correctly.
15:57:46 <Itkovian> even if the list were generated in a strict manner, it only allocates no more than say 600K ints
15:58:01 <Itkovian> ddarius: no, the one that does work finishes correctly
15:58:28 <Itkovian> so the output is what I expect on the one machine
15:58:38 <hpc> not knowing anything about Xen, it looks like a good source of problems
15:58:48 <hpc> depending on the sort of stuff your code does
15:59:03 <Itkovian> nothing spectacular
15:59:06 <redd_> Can instances of a type class be prohibited from importing, e.g., from Control.Monad.Instances?
15:59:11 <Itkovian> pure, except the reading of the data
15:59:11 <quuuux> Itkovian: is it pure-ish Haskell?
15:59:15 <Itkovian> yeah
15:59:18 <Itkovian> ah well.
15:59:22 <Itkovian> I'll check back tomoroow
15:59:28 <hpc> redd_: as in, can you keep an instance out of an export list?
15:59:29 <Itkovian> I'll let you know if/what I find
15:59:36 <Itkovian> thx
15:59:38 <Itkovian> night
15:59:40 <hpc> or out of an import list
15:59:51 <hpc> i don't believe either are possible
16:00:02 <monochrom> instances cannot be prohibited from importing.
16:00:05 <hpc> and you would need to put that instance in its own module or something
16:00:46 <hpc> so Control.Monad.Instances.Maybe would be the module you make, or something like that
16:01:20 <redd_> That's unfortunate. Thanks, though.
16:01:44 <qfr> I like my Haskell as I like my heroin
16:01:53 <qfr> Impure.
16:02:10 <qfr> And delivered with a syringe!
16:02:39 <redd_> Sometimes you just want that print statement.
16:02:51 <qfr> Hahaha
16:03:26 <monochrom> Debug.Trace has your print statements
16:04:05 <monochrom> Control.Exception.assert is your assertion
16:05:00 <hpc> @quote oasis
16:05:01 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
16:06:08 <qfr> http://www.mail-archive.com/haskell@haskell.org/msg18171.html haha
16:06:20 <qfr> "In object-oriented programming, UML is used to model programs. In
16:06:20 <qfr>  functional programming (especially Haskell) we use ???
16:06:20 <qfr> "
16:06:26 <qfr> Urgh, newline removal fail
16:06:45 <hpc> oh lord
16:06:55 <ddarius> qfr: That is the thing I linked before.
16:07:10 <qfr> ddarius oh you did? I must be a terrible person to have ignored it
16:07:23 <Pseudonym> Even in object-oriented programming, UML is usually not used to model programs.
16:07:37 <ddarius> Programs are usually not modeled.
16:07:39 <monochrom> I should have replied with JSD back then.
16:07:44 <Pseudonym> if it's used, it's usually used to document programs.
16:07:49 <Pseudonym> JSD FWT!
16:07:51 <Pseudonym> FTW!
16:08:01 <qfr> JSD = ?
16:08:16 <Pseudonym> I actually still use Jackson Standard Design.  Is that pathetic?
16:08:31 <monochrom> <monochrom> well the way I understand JSD, it just says "write down the names of a few abstract data types, write down the specifications for the functions over them", which is what everyone has been doing anyway, even EDSL and polymorphic types and functions.
16:09:02 <qfr> http://en.wikipedia.org/wiki/Jackson_Structured_Programming ?
16:09:06 <monochrom> yeah
16:09:12 <Pseudonym> Ah, yeah, that.
16:09:31 <Philippa> qfr: we use burritos
16:09:38 <Pseudonym> The bit I still use is to design the program as a dataflow diagram, then pick up one node and shake it.
16:09:49 <Pseudonym> And what you get is a module design.
16:10:06 <monochrom> JSD and JSP. I tend not to make a big distinction. I just use D or P to suit the context.
16:10:13 <ddarius> Pseudonym: I thought you used the Cowboy Coding module of Rational Rose.
16:10:20 <Pseudonym> Less useful in Haskell.  Laziness makes JSD/JSP mildly obsolete.
16:10:33 <qfr> Java Server Pages!
16:10:38 <Pseudonym> ddarius: So it's true.  Every programming methodology has been subsumed into Rational.
16:10:59 <qfr> I thought Rational Rose was UML only lol
16:10:59 <Pseudonym> Is there a "first year undergraduate debug-by-random-mutation" module yet?
16:11:00 <hpc> > 4 / 3 :: Rational
16:11:01 <lambdabot>   4 % 3
16:11:14 <hpc> @let rose = 1; rose :: Rational
16:11:15 <lambdabot>  Defined.
16:11:20 <hpc> Rational rose!
16:11:33 <monochrom> "debug-by-random-mutation" is a built-in in human minds
16:11:33 <Pseudonym> Meeting.  BBL
16:11:39 <ddarius> That's a rosy Rational, not a rational rose.
16:12:52 <ddarius> Though I guess you could call the things in Prolog when you want some kind of foundations but don't want the occurs check "rational (rose) trees")
16:13:14 <qfr> "On the topic of Haskell, I've found that traditional dataflow modelling techniques (dataflow diagrams, JSD etc) can model lazy code pretty well. But, once again, we're talking about a subset of what the language provides.  Lambda is also the ultimate imperative, after all." haha did you write that?
16:13:25 <qfr> That was in what ddarius linked and what I googled later
16:13:47 <ddarius> qfr: I didn't like the mail article.  I linked what the first one linked.
16:13:55 <ddarius> Also, Pseudonym is ajb.
16:13:55 <qfr> It also says UML is mostly just used for documentation or for really big projects upfront
16:13:59 <qfr> Ah, ok
16:14:14 <qfr> Hahaha I see
16:14:20 <qfr> I thought I recognised him there
16:14:37 <qfr> What he said pretty much summed up to that one particular post
16:16:29 * ddarius gets dressed.  Now he has to decide on a place to go.
16:16:45 <qfr> Why do you have to go?
16:19:13 <adnap> can someony explain the implementation of <*> for functions in Applicative to me? f <*> g = \x -> f x (g x)
16:19:36 <j-invariant> adnap: it's the only function with the correct type?
16:19:43 <j-invariant> adnap: what do you want to know
16:19:55 <ddarius> (<*>) = ap
16:20:17 <adnap> okay, let's just work through my confusion if you don't mind.  i'll tell you why i'm confused and maybe you can point out where i'm wrong.
16:20:36 <quuuux> ...wow. I never noticed that (<*>) was the S combinator before
16:20:46 <adnap> in this case, f and g are functions that both take the same type of argument.
16:20:57 <adnap> (->) a
16:21:19 <j-invariant> adnap: so f,g :: a -> _
16:21:22 <ddarius> quuuux: Going solely by the title of one of the new Monad Reader articles, I think these connections are covered in detail there.
16:21:26 <adnap> yes
16:21:27 <azaq23> quuux: and pure is K
16:21:27 * geheimdienst is not an expert himself, but it seems (g x) takes one x and f takes f (x) (g x)
16:21:54 <adnap> wait, could f and g be functions of any number of arguments, as long as their first type is the same?
16:21:57 <j-invariant> geheimdienst: (f x) (g x)
16:22:26 <j-invariant> :t (<*>)
16:22:26 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:22:39 <ddarius> j-invariant: Writing "f,g :: a -> _" suggests that f and g have the same type, not just the same outer type constructor.
16:22:55 <geheimdienst> > let f = (+) in let x = 42 in (f x) (id x)
16:22:56 <lambdabot>   84
16:22:57 <j-invariant> adnap: f :: e -> a -> b, g :: e -> a
16:23:24 <adnap> here's where the definition of <*> confuses me
16:23:36 <adnap> let's say f :: Int -> String and g :: Int -> Bool
16:23:47 <j-invariant> adnap: that wont typecheck
16:23:57 <ddarius> adnap: Do you understand the reader monad or liftA2?
16:24:08 <j-invariant> adnap: f :: Int -> Bool -> smoething, if g :: Int -> Bool
16:24:29 <adnap> i understand liftA2 takes a normal function of two arguments and "lifts" it to work on applicatives
16:24:52 <adnap> i don't know the reader monad
16:25:42 <j-invariant> adnap: make sure to understand what I said
16:25:44 <adnap> > liftA2 ["woo"] ["hoo"]
16:25:45 <lambdabot>   Couldn't match expected type `a -> b -> c'
16:25:45 <lambdabot>         against inferred type `[...
16:25:49 <adnap> > liftA2 (++) ["woo"] ["hoo"]
16:25:52 <lambdabot>   ["woohoo"]
16:26:19 <adnap> j-invariant: i don't know what you said
16:26:34 <adnap> j-invariant: it won't typecheck?
16:27:02 <j-invariant> adnap: yes I wrote that above
16:27:14 <ddarius> (<*>) = liftA2 ($)
16:27:21 <geheimdienst> adnap, i still think that in "f x (g x)", f is a function of 2 arguments ... think of it as f (x) (g x)
16:27:30 <adnap> it looks like when (f x) (g x) are next to each other, (f x) is going to be applied to (g x)
16:27:32 <j-invariant> geheimdienst: try writing it as (f x) (g x)
16:27:50 <ddarius> adnap: It will be.
16:27:55 <geheimdienst> j-invariant: i did ...
16:27:58 <geheimdienst> > let f = (+) in let x = 42 in (f x) (id x)
16:27:59 <lambdabot>   84
16:27:59 <ddarius> Try further writing it as: (f x) $ (g x)
16:28:02 <adnap> ddarius: but what if f is a function of one argument?
16:28:13 <ddarius> adnap: Thet you have a type error.
16:28:21 <adnap> what does the instance of Applicative for functions say about the number of arguments?
16:28:37 <adnap> doesn't it only say that the first argument has a certain type?
16:28:48 <ddarius> All functions take only one argument.  Some just return a function as a result.
16:28:55 <ddarius> adnap: Correct.
16:28:57 <adnap> ahhh
16:29:30 <adnap> waut
16:29:32 <adnap> wait
16:29:42 <adnap> but are f and g free to return results with different types?
16:29:53 <j-invariant> adnap: look
16:29:58 <adnap> it seems so
16:29:59 <j-invariant> adnap: f :: e -> a -> b, g :: e -> a
16:30:12 <adnap> j-invariant: right, i understand that will work
16:30:28 <j-invariant> adnap: this is the complete schema
16:30:39 <j-invariant> adnap: it's not just one example that works, every working example is an instance of this one
16:31:00 <adnap> j-invariant: how is it that Applicative ensures this?
16:31:09 <j-invariant> tbhat's the type of <*>
16:31:28 <j-invariant> (e -> a -> b) -> (e -> a) -> (e -> b)
16:31:31 <adnap> j-invariant: so by writing (f x) (g x), we've restricted the type?
16:31:35 <j-invariant> no
16:31:59 <adnap> oh, it has that type for all Applicatives
16:32:15 <adnap> wait, i get it i think
16:32:34 <ddarius> :t (<*>)
16:32:35 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:32:39 <ddarius> That is the type (<*>) has.
16:32:40 <adnap> f (a -> b) f (a)
16:32:46 <ddarius> You get j-invariant's type when f = (e ->)
16:33:15 <adnap> and in this, b could even be a function
16:33:32 <ddarius> b could be anything, but that isn't actually relevant.
16:33:47 <adnap> well, i was thinking of functions with lots of arguments
16:34:01 <adnap> i guess it's not really relevant
16:34:09 <j-invariant> adnap: a function with lots of arguments is  (a,b,c,d) -> x
16:34:14 <ddarius> adnap: It's relevant for some uses.
16:34:29 <adnap> find, a function that returns a function that returns a function bla blA
16:34:32 <adnap> *fine
16:34:53 <adnap> j-invariant: that is a function of 1 argument
16:35:00 <adnap> j-invariant: a 4-tupler
16:35:06 <adnap> j-invariant: tuple*
16:35:13 <j-invariant> okay
16:35:22 <adnap> at least, the way i think of it
16:35:31 <j-invariant> I understand that point of view
16:35:33 <edwardk> preflex: xseen jbapple
16:35:33 <preflex>  jbapple was last seen on freenode/#haskell 122 days, 7 hours, 33 minutes and 20 seconds ago, saying: I think lazy IO tripped me up again
16:37:10 <adnap> i thought a two argument function could be thought of as a function that takes an argument and returns a function that takes one argument
16:37:39 <adnap> maybe that's not the only way people think about it
16:38:07 <j-invariant> adnap: it's all meaningless: The only thing that matters is the type:   a -> b   or  a -> b -> c -> d  or ((a,b) -> c) -> d whatever
16:38:55 <adnap> :t (<*>)
16:38:56 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:39:20 <quuuux> argh. Apparently when the Cabal docs say 'all installed packages', what it means is 'all installed packages in the transitive closure of your package's dependencies'
16:39:53 <dcoutts> quuuux: problem?
16:40:36 <quuuux> dcoutts: ah, help is at hand! Let me just cobble together a smaller example
16:40:46 <adnap> j-invariant: i understand now
16:40:53 <j-invariant> okay!
16:42:00 <adnap> j-invariant: i think!
16:42:07 <adnap> j-invariant: let me try an example
16:43:55 <azaq23> @djinn (a -> b -> c) -> (a -> b) -> (a -> c)
16:43:55 <lambdabot> f a b c = a c (b c)
16:44:01 <adnap> oh, wait
16:44:28 <geheimdienst> > ((+) <*> (*2)) (4,0)
16:44:29 <lambdabot>   (12,0)
16:44:40 * geheimdienst feels so knowledgable right now
16:45:31 <geheimdienst> > ((+) <*> (*2)) [4]
16:45:32 <lambdabot>   No instance for (GHC.Num.Num [t])
16:45:32 <lambdabot>    arising from a use of `e_124' at <inte...
16:45:58 * geheimdienst notices the feeling subsiding
16:46:58 <adnap> is something that is constant a function?
16:47:06 <adnap> like if something has the type :: Int
16:47:10 <azaq23> no
16:47:13 <azaq23> it is a value
16:47:23 <azaq23> there is not "null-ary" function
16:47:24 <quuuux> dcoutts: http://pastebin.com/wDaammxB but according to http://hackage.haskell.org/packages/archive/Cabal/1.8.0.2/doc/html/Distribution-Simple-LocalBuildInfo.html#t:LocalBuildInfo it's a listing of "All the info about all installed packages."
16:47:25 <adnap> isn't the value what it returns?
16:47:28 <geheimdienst> adnap, no, you can't apply an Int to an argument
16:47:59 <geheimdienst> > (\x -> "lol") 42
16:48:00 <lambdabot>   "lol"
16:48:02 <adnap> ah, it makes sense
16:48:06 <geheimdienst> > ("lol") 42
16:48:07 <lambdabot>   Couldn't match expected type `t1 -> t'
16:48:07 <lambdabot>         against inferred type `[GHC....
16:48:09 <adnap> with Applicative, you need a "hole"
16:48:17 <azaq23> (a -> b) is also just a value
16:48:21 <adnap> which is what is returned by the function
16:48:34 <dcoutts> quuuux: yep, so how is it a problem?
16:48:49 <adnap> with (a -> b), b fits in the "hole"
16:49:30 <adnap> like, sometimes i think of functors as things with a "hole"
16:49:48 <adnap> and a type fits in the hole
16:50:27 <geheimdienst> adnap, yeah
16:51:16 * azaq23 doesn't understand what is meant by "hole" here
16:51:30 <quuuux> dcoutts: I want to query the package database at configure time, so I can make sure I'm not installing duplicate PackageIds. This is part of my hotswapping system, and GHC has a limitation that it can't re-load packages with the same name and version number
16:51:46 <adnap> > (>) <*> id
16:51:47 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> GHC.Bool.Bool)
16:51:48 <lambdabot>    arising fro...
16:52:02 <monochrom> the dispute is over the semantics of "all installed packages"
16:52:15 <dcoutts> quuuux: you can call ghc-pkg directly if you like
16:52:23 <adnap> > ((>) <*> id) 2
16:52:24 <lambdabot>   False
16:52:27 <monochrom> the English semantics, to be clear.
16:52:39 <dcoutts> quuuux: there's an API for it
16:52:59 <quuuux> dcoutts: hmm. In the GHC API?
16:53:06 <geheimdienst> > ((+) <*> (*2) 3
16:53:07 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
16:53:08 <dcoutts> quuuux: no, Cabal API
16:53:12 <geheimdienst> > ((+) <*> (*2)) 3
16:53:13 <lambdabot>   9
16:53:16 <geheimdienst> oh
16:53:30 <dcoutts> quuuux: does this need to be in the Setup.hs? what is your hotswapping system? sounds interesting
16:54:04 <adnap> i read lyah and it sort of went over functions as applicatives, but i think it didn't go deep enough
16:54:31 <adnap> infact, here's a quote: "The instance implementation for <*> is a bit cryptic, so it's best if we just take a look at how to use functions as applicative functors in the applicative style."
16:54:56 <monochrom> I agree with that.
16:55:07 <monochrom> Generally, all implementations are cryptic.
16:55:17 <adnap> i don't think the examples are very illuminating though
16:55:30 <quuuux> dcoutts: it needs to be done at some point prior to the install step, so yes. The 'system' is just a local package database that the hotswappable bits are installed in to, then they're imported through Hint and the GHC API
16:55:33 <monochrom> alright, but examples are the only way.
16:55:50 <adnap> i thought working through the type of <*> was more helpful
16:55:53 <dcoutts> quuuux: btw, the reason we prune the packages is simply to make the saved state files smaller and thus quicker. When you've got 100's of installed packages it can get pretty slow otherwise.
16:55:56 <adnap> as it applies to functions
16:56:09 <monochrom> that's also good
16:57:00 <quuuux> dcoutts: okay, thanks. I think that bit of the docs could use clarifying, still
16:57:17 <dcoutts> quuuux: so you're trying to work around a limitation of the GHC API where it will not reload packages if the version number has not changed (but installed package id has changed)?
16:57:29 <quuuux> dcoutts: precisely
16:57:40 <adnap> there's something i want to say about f <*> g, but it's hard to put into words
16:57:59 <dcoutts> quuuux: presumably you have reported that. It should be looking at the InstalledPackageId, not the PackageId (source)
16:58:03 <adnap> the type of g has to be the first argument to f maybe?
16:58:18 <monochrom> perhaps put into formulas. a formula is worth a thousand pictures. dijkstra said.
16:58:35 <adnap> like, if f :: Int -> Int -> Bool, then g :: Int -> Int
16:59:26 <dcoutts> quuuux: I've clarified the docs about that field, thanks.
16:59:48 <dcoutts> quuuux: now reads "All the info about the installed packages that the current package depends on (directly or indirectly)."
16:59:58 <quuuux> dcoutts: awesome :)
17:00:01 <adnap> so a formula is worth a million words?
17:00:38 <adnap> i'd be sort of afraid to read a formula worth that many words
17:01:11 <believa> I want to be able inject a different value into a haskell program each time I cabal install it. One way I was thinking was to represent this value as a C macro in the haskell code, and use GHC's  CPP language option, is there a way to create a cabal package such that a value (e.g. a string) can be specified when calling cabal install where the value can be used a C pre-processor token 
17:01:17 <monochrom> recall that a type is a formula too. you are not afraid of type formulas.
17:01:44 <dcoutts> believa: yes but not nicely, and you'd better have a default.
17:02:09 <dcoutts> believa: consider that nobody else knows about the parameter, certainly tools that translate into distro packages do not.
17:02:23 <adnap> :t liftA2 mappend
17:02:24 <lambdabot> forall a (f :: * -> *). (Monoid a, Applicative f) => f a -> f a -> f a
17:02:38 <kmc> presumably you can set ghc-options: -DFoo=Bar
17:02:43 <kmc> not sure how to get that from the cmd linve
17:02:51 <geheimdienst> could you say (<*>) is a little like a cross between (.) and (&&&)?
17:02:56 <geheimdienst> i mean, (.) takes a value, applies a function to it, then applies a function to the result. (&&&) applies two functions to the same value, giving a tuple. so (<*>) applies a function to a value, then puts the result and the original value into a second function
17:03:41 <kmc> "(.) takes a value, applies a function to it, then applies a function to the result"  no, that's what (f . g) does
17:04:59 <monochrom> f :: Int -> Int -> Bool is not a very illustrative example. f :: Int -> Char -> Bool is better. Then you need g :: Int -> Char.
17:05:07 <adnap> what's an example of something that is both a monoid and an applicative?
17:05:14 <adnap> oh, a list?
17:05:47 <believa> dcoutts: understand. This is for a Yesod project where the package is a web server- point is, it wouldn't be a public package. The value that would change each time is the domain name of the web server. I'd like to supply the domain name to cabal each time I cabal install it. So, how would I go about doing that, and if it's not pretty, is there an alternative solution?
17:05:51 <azaq23> a list, yes
17:06:26 <adnap> argh, i'm trying to make sense of how liftA2 mappend will work
17:06:36 <dcoutts> believa: I would use a separate deploy script that provides the configuration
17:06:53 <dcoutts> believa: cabal is just one part of deployment, just use it to create the image
17:07:23 <azaq23> @type liftA2 mappend
17:07:24 <lambdabot> forall a (f :: * -> *). (Monoid a, Applicative f) => f a -> f a -> f a
17:07:45 <azaq23> > (liftA2 mappend) ["a", "bcd", "efg"]
17:07:46 <adnap> > (liftA2 mappend) [Sum 2] [Sum 3]
17:07:46 <lambdabot>   Overlapping instances for GHC.Show.Show
17:07:47 <lambdabot>                              ([[GHC...
17:07:47 <lambdabot>   [Sum {getSum = 5}]
17:07:48 <monochrom> No, you don't need something to be a monoid and a functor at the same time. read (Monoid a, Applicative f) again. a /= f
17:07:53 <adnap> woo
17:08:27 <monochrom> You need one functor and one monoid, then store the monoid type inside the functor.
17:08:28 <dcoutts> believa: the number of config items is bound to grow (port number, location of db files etc etc) so I would just use a proper configuration mechanism
17:08:40 <dcoutts> believa: and then integrate that into your deployment system
17:08:46 <azaq23> > (liftA2 mappend) ["a", "bcd", "efg"] ["d", "e", "f"]
17:08:47 <lambdabot>   ["ad","ae","af","bcdd","bcde","bcdf","efgd","efge","efgf"]
17:08:48 <monochrom> For example f=Maybe and a=() works.
17:09:09 <azaq23> > (fmap mappend) ["a", "bcd", "efg"] ["d", "e", "f"]
17:09:10 <lambdabot>   Couldn't match expected type `t -> a' against inferred type `[a1]'
17:09:16 <monochrom> s/functor/applicative/
17:09:48 <adnap> > (liftA2 mappend) ["woo"] ["hoo"]
17:09:49 <lambdabot>   ["woohoo"]
17:10:38 <adnap> > (liftA2 mappend) ["hi", "there"] ["where", "is", "there"]
17:10:39 <lambdabot>   ["hiwhere","hiis","hithere","therewhere","thereis","therethere"]
17:10:48 <azaq23> > (liftM2 mappend) ["a", "bcd", "efg"] ["d", "e", "f"] == (liftA2 mappend) ["a", "bcd", "efg"] ["d", "e", "f"] 
17:10:49 <lambdabot>   True
17:11:18 <believa> dcoutts: yes - good point. thanks for the advice.
17:12:09 <monochrom> liftA2 mappend is not so different from liftA2 binop :: (Applicative f) => f a -> f b -> f c for general binop :: a->b->c.  the mapppend part is a red herring.
17:12:31 <adnap> i was trying to understand this:
17:12:40 <adnap> instance Monoid b => Monoid (a -> b) where mempty  = pure   mempty mappend = liftA2 mappend
17:13:24 <monochrom> then you should use (a->) as your applicative.
17:13:32 <c_wraith> pure = const, liftA2 - 
17:14:01 <c_wraith> err.  typing fail :)
17:14:12 <adnap> so, it is going to mappend the results of the functions?
17:14:24 <c_wraith> yes
17:14:26 <BONUS> adnap: that one is clearer written like this
17:14:46 <monochrom> (a -> b) -> (a -> b) -> (a -> b)
17:14:55 <monochrom> (Monoid b) => (a -> b) -> (a -> b) -> (a -> b)
17:15:04 <adnap> yeah, that makes more sense
17:15:33 <BONUS> mempty x = \_ -> x, mappend a b = \x -> a x `mappend` b x
17:16:09 <adnap> > (liftA2 mappend) (const "woo") (const "hoo")
17:16:10 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> [GHC.Types.Char])
17:16:10 <lambdabot>    arising ...
17:16:34 <azaq23> > (liftA2 mappend) (const "woo") (const "hoo") $ 0
17:16:34 <adnap> > (liftA2 mappend) (\x y -> "woo") (const "hoo")
17:16:35 <lambdabot>   "woohoo"
17:16:35 <lambdabot>   Couldn't match expected type `t -> [GHC.Types.Char]'
17:16:36 <lambdabot>         against inferr...
17:16:41 <monochrom> so generally it's instance (Applicative f, Monoid b) => Monoid (f b) where mempty  = pure   mempty mappend = liftA2 mappend.  Except that may need UndecidableTypeDirectedNameResolution or something.
17:16:53 <adnap> :t const (const "woo")
17:16:54 <lambdabot> forall b b1. b1 -> b -> [Char]
17:17:07 <adnap> > (liftA2 mappend) (const . const $ "woo") (const "hoo")
17:17:09 <lambdabot>   Couldn't match expected type `b -> [GHC.Types.Char]'
17:17:09 <lambdabot>         against inferr...
17:17:41 <azaq23> adnap you still get a function back
17:17:53 <aristid> :t (liftA2 mappend) (const "woo") (const "hoo")
17:17:54 <lambdabot> forall b. b -> [Char]
17:18:11 <aristid> :t (liftA2 mappend) (const . const $ "woo")
17:18:13 <lambdabot> forall b b1. (b -> b1 -> [Char]) -> b -> b1 -> [Char]
17:18:20 <aristid> :t (<*>)
17:18:21 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
17:18:26 <monochrom> > (liftA2 mappend) (const . const $ "woo") (const "hoo") undefined
17:18:27 <lambdabot>   Couldn't match expected type `b -> [GHC.Types.Char]'
17:18:27 <lambdabot>         against inferr...
17:18:41 <aristid> :t (const . const $ "woo") <*> (const "hoo")
17:18:42 <lambdabot> forall b. b -> [Char]
17:18:43 <adnap> > (liftA2 mappend) (const . const $ "woo") (++)
17:18:44 <lambdabot>   Overlapping instances for GHC.Show.Show
17:18:44 <lambdabot>                              ([GHC....
17:18:52 <monochrom> > (liftA2 mappend) (const "woo") (const "hoo") undefined
17:18:53 <lambdabot>   "woohoo"
17:18:57 <aristid> adnap: you're not making any sense!
17:19:02 <adnap> i knowwww
17:19:48 <aristid> adnap: i always use :t first to see what i'm actually doing :)
17:20:08 <monochrom> good sanity check
17:20:47 <monochrom> a type is worth a thousand tests
17:21:02 <Philippa> is there anything much that can sensibly be done to indicate a datatype that's intended to be strictly finite other than making all the constructors strict in itself?
17:21:14 <pheaver> how would i make it so that every package gets built with a particular ghc option, such as -threaded?  there doesn't seem to be a way to do this in your ~/.cabal/config file, and it seems my only option is to always pass the option to cabal configure/install, which is a little annoying.
17:21:29 <adnap> i thought i had it right with liftA2 mappend (const "woo") (const "hoo"), but i guess it doesn't know what to do until it gets an argument?
17:21:56 <ddarius> Philippa: Switch to Agda.
17:22:04 <adnap> then i got all confused and started thinking about <*> again by accident
17:22:05 <copumpkin> (and avoid #)
17:22:14 <adnap> i have an annoying brain
17:22:34 * ddarius thinks copumpkin has "Agda" highlighted.
17:22:46 <copumpkin> I didn't, but good idea
17:22:47 <aristid> adnap: it's like you're dealing in a big Reader, except your consts all ignore the input :)
17:23:10 <aristid> epigram
17:23:19 <copumpkin> :o
17:23:20 <adnap> i don't know the Reader monad
17:23:34 <gwern> I like quoting epigrams about Ada
17:23:38 <aristid> @unmtl Reader s a
17:23:39 <lambdabot> s -> a
17:23:41 <gwern> 'a mistake carried through to perfection'
17:23:58 <monochrom> the Reader monad is just (s->) with a newtype wrap. end of definition.
17:24:07 <adnap> why is it called Reader?
17:24:25 <aristid> adnap: because you can read the parameter of the function
17:24:26 <monochrom> every once in a while you read the value of s.
17:24:28 * ddarius prefers the term "Environment"
17:25:08 <Philippa> ddarius: yeah, I had a suspicion that was the answer. In which case, for now I cba
17:25:30 <dcoutts> pheaver: there's a ticket on that, the fact that prog options cannot be given in the ~/.cabal/config file
17:25:48 <pheaver> dcoutts: ah!
17:26:04 <adnap> :t (Reader $ (+)) >>= (show)
17:26:06 <lambdabot> Not in scope: data constructor `Reader'
17:26:27 <pheaver> any suggestions for a work around, or... alias cabal-install="cabal install --ghc-options=-threaded" ?
17:26:29 <ddarius> Philippa: "Switch to Agda" is the answer to all questions of the form "How do I do something I can't do in Haskell?"  If only you could program in Agda.
17:26:32 <adnap> oh wait
17:26:55 <Philippa> ddarius: well, I was partly asking about convention
17:27:11 <dcoutts> pheaver: http://hackage.haskell.org/trac/hackage/ticket/446
17:27:11 <adnap> :t (Reader $ (+)) >>= (\x -> Reader $ \x y -> show x ++ y )
17:27:12 <lambdabot> Not in scope: data constructor `Reader'
17:27:12 <lambdabot> Not in scope: data constructor `Reader'
17:27:18 <Philippa> and yeah, I know I'm being horribly lazy here and probably should learn agda
17:27:21 <dcoutts> pheaver: oh, I see there's a patch on that ticket (grr, wish trac let one search for that)
17:27:31 <adnap> lol, i have no idea what i'm doing
17:27:32 <ddarius> Philippa: That was a generic "you" in the last sentence.
17:27:34 <monochrom> j-invariant would love to hear that. do all his math in agda instead
17:27:41 <ddarius> Philippa: I haven't written a line of Agda.
17:27:42 <aristid> :k Reader
17:27:43 <lambdabot> * -> * -> *
17:27:47 <copumpkin> okay, no more agda highlight for me
17:28:05 <monochrom> copumpkin loves agda :)
17:28:14 <Philippa> ddarius: yeah, I realise. Still. Personal life's been continually hair-raising in terms of energy spare for such things though
17:28:16 <adnap> how do you tell lambdabot to look up reader?
17:28:21 <monochrom> but yeah why would you highlight anything to begin with
17:28:21 <ddarius> copumpkin: You need to make it like a Schmitt trigger.
17:28:39 <aristid> adnap: the constructor of Reader is ReaderT in modern versions of mtl
17:28:44 <adnap> oh
17:28:47 <aristid> (and in monads-fd)
17:28:50 <aristid> :t ReaderT
17:28:52 <lambdabot> forall r (m :: * -> *) a. (r -> m a) -> ReaderT r m a
17:29:06 * roconnor kinda thinks hackage's main page should get rid of categories, since he doesn't use them anyways
17:29:14 <adnap> :t ReaderT id
17:29:16 <lambdabot> forall (m :: * -> *) a. ReaderT (m a) m a
17:29:27 <aristid> :t asks
17:29:28 <lambdabot> forall r a (m :: * -> *). (MonadReader r m) => (r -> a) -> m a
17:29:36 <aristid> adnap: i think asks is what you want
17:29:47 <adnap> aristid: for what?
17:30:03 <aristid> adnap: instead of the non-existent Reader constructor
17:30:05 <adnap> i still don't even know what Reader is good for
17:30:07 <aristid> :t asks id
17:30:08 <lambdabot> forall r (m :: * -> *). (MonadReader r m) => m r
17:30:19 <aristid> (asks id happens to be equivalent to ask)
17:30:29 <adnap> i'm just trying to find out based on the type of reader and my knowledge of monads
17:30:48 <monochrom> A thing in a library doesn't have to be good for anything.
17:31:01 <adnap> why would someone write it?
17:31:08 <aristid> adnap: Reader is like a function, but as a monad. (functions are already monads, so Reader is not particularly useful, but who cares)
17:31:09 <monochrom> delusion
17:31:40 <aristid> type Reader s a = ReaderT s Identity a
17:31:47 <aristid> not a whole lot of effort to define it
17:31:47 <adnap> so, is there already instance Monad ((->) r)?
17:31:51 <aristid> adnap: yes
17:32:00 <monochrom> there is a difference between "objectively provably useful" and "deluded into thinking it's useful"
17:32:01 <adnap> wtf
17:32:15 <pheaver> dcoutts: what is meant by your comment in http://www.mail-archive.com/cabal-devel@haskell.org/msg04624.html ?  it sounds like you're saying that compiling a library with -threaded doesn't make any difference?
17:32:16 <aristid> adnap: that's what you were using with your liftA2. well, almost, you use the Applicative equivalent
17:32:29 <dcoutts> pheaver: well if you want it fixed then try adam's patch, it probably needs cleaning up so it applies cleanly to latest code.
17:32:38 <adnap> and why "Reader"?  it doesn't seem to relate to "Writer" at all.
17:32:42 <ddarius> monochrom: The former being "deluding -several- people into thinking it's useful."
17:32:49 <monochrom> haha
17:32:58 <pheaver> dcoutts: yeah, i think we'll give that a try
17:33:07 <aristid> adnap: yes it does. Reader has the primary operation ask, and Writer has the primary operation tell...
17:33:15 <adnap> oh, really?
17:33:17 <aristid> adnap: note how ask and tell are exact opposites? :)
17:33:21 <adnap> yess
17:33:32 <adnap> but do they work well in conjunction?
17:33:38 <adnap> or is someone trying to fool me?
17:33:41 <copumpkin> not really opposites as much as connected!
17:34:22 <BONUS> a reader value needs something extra (a parameter), whereas a writer value gives something extra (a monoid value)
17:34:23 <adnap> if they work well together, i could see why someone would want to give the monad instance for functions a new name
17:34:24 <monochrom> I have never seen anyone feeding a Writer to a Reader, so no. I mean yes, it's trying to fool you.
17:34:25 <BONUS> that's how i look at it
17:34:48 <BONUS> but i don't think they're opposite in any sort of mathematical sense, just an intuitive one
17:35:00 <dcoutts> pheaver: that's correct -threaded makes no difference when compiling libraries. It only affects the linking of executables.
17:35:06 <adnap> :t ask
17:35:08 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
17:35:19 <aristid> :t ask :: Reader r r
17:35:20 <lambdabot> forall r. Reader r r
17:35:31 <aristid> :t ask :: a -> a
17:35:32 <lambdabot> forall a. a -> a
17:35:35 <adnap> oh
17:35:40 <aristid> :t tell
17:35:40 <adnap> it gives id in a Reader
17:35:41 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
17:35:53 <aristid> :t tell :: w -> Writer w ()
17:35:54 <lambdabot>     Could not deduce (Monoid w) from the context ()
17:35:54 <lambdabot>       arising from a use of `tell' at <interactive>:1:0-3
17:35:54 <lambdabot>     Possible fix:
17:36:08 <aristid> :t tell :: Monoid w => w -> Writer w ()
17:36:09 <lambdabot> forall w. (Monoid w) => w -> Writer w ()
17:36:17 * ddarius generally frowns on anthropomorphizing... unless you are going to assign hostile intent.  Then, anthropormorphize away.
17:36:47 <BONUS> ddarius: anthropomorphizing? 
17:36:51 <ddarius> BONUS: As Kleisli arrows, ask : 1 -> R, tell : W -> 1.
17:37:05 <BONUS> ah
17:37:16 <BONUS> i see
17:37:19 <ddarius> But I still wouldn't too much into that.
17:37:24 <adnap> so ask gives you a Reader with the identity function for whatever type the Reader is?
17:37:54 <aristid> we should name everything with UUIDs
17:38:15 <aristid> that way, nobody can anthropomorphize based on the names of things
17:38:18 <hpc> :t tell :: a -> a -> ()
17:38:20 <lambdabot>     Could not deduce (MonadWriter a ((->) a)) from the context ()
17:38:20 <lambdabot>       arising from a use of `tell' at <interactive>:1:0-3
17:38:20 <lambdabot>     Possible fix:
17:38:26 <aristid> or assign anthropomorphizing names
17:38:34 <aristid> hpc: wtf?
17:38:36 <monochrom> you can demonize things
17:38:36 <BONUS> aristid: like monad 3afb8c95?
17:38:47 <hpc> yeah, i wasn't thinking
17:38:49 <ddarius> aristid: That's what I said, but then 4cc88032-a57c-4f79-bd22-9a964a3388a2 shot me down.
17:38:54 <adnap> i don't see what is wrong with anthroblabla if it fits well
17:39:03 <kmc> we should name everything with the SHA1 hash of its contents
17:39:06 <adnap> like "with" i think is good
17:39:08 <aristid> BONUS: more like 78e1d326-c68f-4916-8e94-c621f4438cb7 8734b98c-d0c5-4759-8da1-5bb0a0e9f0c0
17:39:11 <BONUS> haha
17:39:28 <adnap> lol
17:39:33 <monochrom> "with" is not anthroblabla.
17:39:39 <aristid> kmc: then we couldn't change its contents :)
17:39:44 <aefjt> Those look like class names all right!
17:39:50 <adnap> it's not?
17:39:50 <kmc> aristid, immutable data?!? sounds impractical ;)
17:39:58 <aristid> kmc: indeed!
17:40:05 <adnap> :t with
17:40:06 <lambdabot> Not in scope: `with'
17:40:19 <aristid> kmc: nobody would base anything on immutable data. that would be inefficient and stupid.
17:40:34 <aristid> @hoogle with
17:40:35 <lambdabot> Foreign.Marshal.Utils with :: Storable a => a -> (Ptr a -> IO b) -> IO b
17:40:35 <lambdabot> System.Environment withArgs :: [String] -> IO a -> IO a
17:40:35 <lambdabot> Foreign.Marshal.Array withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
17:40:37 <monochrom> "I fix computers with a wrench" not anthroblabla
17:40:49 <adnap> oh, that's not what i was thinking of
17:41:06 <kmc> @. elite nixon
17:41:07 <adnap> it's something that starts with "w" and applies to monads
17:41:07 <lambdabot> i CAn +AK3 It. the 7ou9hER IT G37S, +H3 c001eR I ge7.
17:41:10 <adnap> :t where
17:41:11 <lambdabot> parse error on input `where'
17:41:27 <kmc> 'where' is a keyword
17:41:33 <adnap> ha ha
17:41:35 <kmc> and isn't about monads
17:41:42 <adnap> yeah, it's not where
17:41:46 <adnap> you're right
17:41:51 <adnap> :t when
17:41:52 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
17:41:54 <adnap> yes!
17:41:56 <adnap> that one
17:41:59 <kmc> :D
17:42:01 <hpc> when is awesome
17:42:01 <adnap> that's anthroblabla
17:42:09 <kmc> @quote blah
17:42:10 <lambdabot> geheimdienst says: "#haskell-blah.™ Just setting the topic is so difficult that 192 people of IQ 220 need about 46  tries to get it right.™"
17:42:31 <monochrom> "I fix computers with a wrench when full-moon" is still not anthroblabla.
17:42:32 <adnap> lol
17:42:34 <quuuux> haskell-blah is a trademark now?
17:42:41 <aristid> @quote wrench
17:42:41 <lambdabot> RaptorJesus says: using analogies on logic is like using a wrench on rivets
17:42:57 <adnap> i like analogies on logic
17:43:02 <adnap> it's a good stepping stone
17:43:13 <aristid> it's like anthroblabla on monads
17:43:18 <adnap> sometimes it can come back to bite you in the butt though
17:44:35 <adnap> another word i hate is hierarchy
17:44:45 <ion> ddarius: Yeah, abstract concepts absolute hate being anthropomorphized,.
17:44:50 <ion> ly
17:44:56 <monochrom> hahaha
17:45:11 <aristid> @remember ion ddarius: Yeah, abstract concepts absolutely hate being anthropomorphized.
17:45:11 <lambdabot> Good to know.
17:45:25 <aristid> ion: i hope you don't mind my spelling corrections :P
17:45:25 <adnap> what does ly stand for?
17:45:36 <aristid> adnap: it stands for absolute=>absolutely
17:45:40 <adnap> urban dictionary says "love you"
17:45:48 <ivanm> @wn ly
17:45:49 <lambdabot> No match for "ly".
17:45:52 <ion> aristid: I appreciate the fix :-)
17:45:58 <monochrom> you're so reading between the lines where there is nothing
17:46:12 <aristid> Monochrome: go tell him
17:46:26 <monochrom> I'm already telling him.
17:46:29 <aristid> (i only said this to write monochrom's nick wrong.)
17:46:51 <adnap> okay, could this be possible in the future?
17:46:58 <monochrom> yes
17:47:01 <adnap> wiat
17:47:02 <adnap> wait
17:47:06 <adnap> i haven't said it yet :P
17:47:20 <monochrom> safe to bet yes no matter what it is.
17:47:22 <adnap> we have synthetic brains that can play back other peoples' though processes
17:47:32 <adnap> so we can totally understand things easily
17:48:01 <adnap> or, just load a bunch of knowledge into our brains
17:48:27 <adnap> like, we already have a map of a neuron connections
17:48:55 <aristid> adnap: maybe for research we might do some synthetic brains, but i don't think we will beat the energy efficiency of the human brain anytime soon
17:49:16 <aristid> adnap: so whole-brain simulation on a large scale seems pretty far-fetched to me :)
17:49:26 <ddarius> We need to combine temporal modal logic with the modal logic of possibility and necessity.
17:49:27 <monochrom> if we have synthetic brains to play back people's thought process, no we won't be totally understanding things, instead we will be totally seeing how those people's ideas are broken.
17:49:50 <adnap> aristid: i saw some people making parts of brains on a chip
17:50:14 <adnap> aristid: and connections can be made between neurons with pointers
17:50:31 <kmc> it's true, an entire human consumes less than 100 watts
17:50:42 <monochrom> in fact just playing with small artificial neural networks is already very illuminating on the many failure modes of the real brain.
17:51:02 <aristid> kmc: that's amazing
17:51:04 <adnap> monochrom: can you be more specific?  what do you mean?
17:51:18 <aristid> kmc: i knew it already, but it's amazing anyways :)
17:51:52 <ion> kmc: That can rise up to 1 kW when excercising physically judging from something i watched.
17:52:04 <adnap> ion: what did you watch?
17:52:38 <ion> adnap: /me searches his web history… http://www.youtube.com/show/cosmicjourneys
17:53:04 <Rotaerk> maybe in the future our hardware will be wetware
17:53:06 <adnap> ion: is this similar to that carl sagan show?
17:53:07 <aristid> monochrom: the human brain is full of inaccuracies and systematic mistakes, but it's damn of an energy-efficient bitch :)
17:53:13 <monochrom> for example when training artificial neural networks you often get them stuck in "local minima", i.e., they don't learn the real lesson you want them to learn, they learn the accidental patterns of your training set. Well that happens to most humans all the time too, it's called "you're getting the wrong message".
17:53:18 <Rotaerk> like that movie eXistenZ
17:53:23 <ddarius> monochrom: "Beginner's difficulty with Haskell modelled as an over-trained neural network"
17:53:35 <adnap> monochrom: okay, i totally get it
17:53:51 <adnap> monochrom: that's what happend to me with applicative functors and lyah's examples i think
17:54:21 <adnap> monochrom: i thought i understood but i didn't
17:54:37 <conal> does anyone know how CPP & .lhs interact? i can define a single-line CPP macro in a .lhs, but when I try a multi-line macro def, ending lines with a backslash, only the first line ends up in the macro def.
17:54:38 <aristid> ddarius: that would imply that learning haskell is REALLY easier when you have no prior experience in programming. sadly, we don't have enough data to verify this yet
17:54:38 <ion> adnap: The show is quite nice, but as usual, a bit too much on the pop science side. I haven’t seen the Carl Sagan one.
17:55:06 <Philippa> aristid: we do have evidence that having to unlearn imperative programming is often a problem though?
17:55:07 <adnap> ion: i saw one episode of the carl sagan one with my friend and we couldn't stop laughing over the metaphors he would come up with
17:55:56 <aristid> Philippa: but that's a weaker statement
17:55:59 <monochrom> We just need to pool money to get Cale to do a large scale experiment.
17:56:16 <adnap> Philippa: i never felt like my previous knowledge of imperative programming got in the way of learning haskell
17:56:30 <adnap> i kind of treated haskell as a blank slate
17:56:45 <adnap> however, i hadn't been programming for more than a few years before learning haskell
17:56:49 <Philippa> adnap: often != always
17:57:11 <adnap> Philippa: i think the most confusing thing was "do"
17:57:16 <Philippa> *nod*
17:57:24 <Philippa> I remember having to explain to my dad that it's not a do loop
17:57:41 <adnap> maybe anthroblabla *is* a bad idea :)
17:59:31 <adnap> Philippa: i didn't think it was a do loop, but as a series of statements like in an imperative program, but that's really only useful for some things like IO.  it get's totally confusing with other monads, like list or something.
18:00:00 <Philippa> list's a particularly weird example, yeah
18:00:16 <adnap> Philippa: do makes less sense in the context of some other monads, basically
18:00:25 <azaq23> "series of ..." is still correct though
18:00:27 <rks> hi guys, does anyone know why vim auto indentation is completly fucked up in the presence of « : » ?
18:00:28 <adnap> i think people came up with do while thinking about IO
18:00:36 <Philippa> in the general case, do is "monadic let"
18:00:45 <aristid> adnap: do is awesome for list monads :)
18:00:52 <FauxFaux> rks: 'cos you're running one that doesn't understand unicodes?
18:00:55 <adnap> aristid: meh, i don't like it
18:00:56 <aristid> adnap: more readable list comprehensions :>
18:01:06 <adnap> aristid: i prefer using >>=
18:01:10 <rks> FauxFaux: hm?
18:01:20 <aristid> adnap: you do?
18:01:27 <rks> I got 7.3.3
18:01:28 <adnap> aristid: with lists, i think of every element getting sucked through >>=
18:01:33 <aristid> adnap: i rarely use >>= on lists
18:01:37 <monochrom> It is not clear that the « » there are in his/her file or just quotation marks for you.
18:01:39 <rks> (and I use it in urxvt)
18:01:55 <rks> (if that's what you asked, otherwise I didn't understand you FauxFaux)
18:02:06 <Philippa> aristid: I need to work out my new preferred form for functional constraint programming and/or logic programming in a monad
18:02:07 <azaq23> do presents a "sequence" of functions. It may look silly for the list monad, but it's correct nonetheless, because do {x <- [1 .. 10]; y <- [21 .. 30] ...} is different from do { x <- [21 .. 30]; y <- [1 .. 10]}
18:03:06 <aristid> Philippa: uh, like logict? i'm not sure if i know what you mean
18:03:13 <adnap> i just don't think "do" gives any meaning when using it with list
18:03:24 <Philippa> aristid: yeah, or like the typical typechecking monad
18:03:31 <aristid> adnap: why? do list comprehensions give any meaning?
18:03:41 <monochrom> at any rate, auto-indentation for haskell is hard
18:03:42 <adnap> i guess it just sort of works with anything because "do" is a work that can take on any context
18:03:45 <Philippa> aristid: they have a better connotational meaning for most readers, yes
18:03:52 <aristid> adnap: think of it as a reordered list comprehension.
18:04:22 <aristid> Philippa: list comprehensions for some reason tend to become pretty unreadable, so i avoid them
18:04:31 <adnap> yeah, i don't like them either
18:06:27 <Philippa> aristid: yeah, I agree if you're not porting set comprehensions from elsewhere or something
18:06:41 <Philippa> do has the nice advantage that it's essentially let
18:06:51 <Philippa> (nested non-recursive let, but even so)
18:07:49 <aristid> some people even use do with Identity as a non-recursive let :D
18:07:59 <aristid> :t mfix
18:08:00 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
18:08:20 <aristid> :t mfix :: (a -> Identity a) -> Identity a
18:08:21 <lambdabot> forall a. (a -> Identity a) -> Identity a
18:08:35 <Philippa> heh, hadn't seen that before but then I'd probably just write the lets out in sequence
18:08:42 <Philippa> let foo = bar in
18:08:45 <Philippa> let baz = quux in
18:08:46 <Philippa> ...
18:08:54 <ddarius> Philippa: But then you can't do, let x = x + 1
18:09:07 <aristid> ddarius: that's the point...
18:09:11 <azaq23> > take 20 . runIdentity $ mfix (\x -> Identity $ 0 : x) []
18:09:12 <lambdabot>   Couldn't match expected type `[t]'
18:09:12 <lambdabot>         against inferred type `Data.Func...
18:09:20 <aristid> ddarius: oh you mean you still can do it?
18:09:31 <aristid> can vs can't
18:09:43 <Philippa> ddarius: point
18:11:56 <azaq23> > take 20 . runIdentity $ mfix (\x -> Identity $ 0 : x) -- Pretty sure the stuff you can do with this when m != Identity is crazy
18:11:58 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
18:12:29 <Philippa> azaq23: yeah, but you don't get that out of do notation itself unless you use mdo
18:13:20 <aristid> one of mdo and do rec is obsolete i think. which?
18:13:28 <ddarius> azaq23: It's the same stuff you can do in Scheme with letrec.  In fact, if you say, "Well you can also use the list monad, say." I refer you to continuations.
18:13:46 <Philippa> hmm, I think ado is probably the obvious way to do functional constraint programming unless you really need to go to monads, anyway
18:13:52 <ddarius> mdo
18:14:00 <aristid> ddarius: mdo is obsolete?
18:14:10 <ddarius> Yes.
18:14:19 <aristid> ok
18:14:25 <Philippa> hrmm, whose arm do I have to twist to get "do app" or similar?
18:14:52 <ddarius> Probably more less people's if you changed that to "do wop"
18:15:38 <hpc> module FarOut where main = goo goo gajoob
18:17:11 * ddarius asserts that goo is an instance of id.
18:17:23 <ddarius> Or a method of a type class.
18:17:44 <aristid> :t \goo gajoob -> goo goo gajoob
18:17:45 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1 -> t2
18:17:46 <lambdabot>     Probable cause: `goo' is applied to too many arguments
18:17:46 <lambdabot>     In the expression: goo goo gajoob
18:18:14 <aristid> :t \gajoob -> id id gajoob
18:18:16 <lambdabot> forall a. a -> a
18:18:19 <roconnor> @seen zooko
18:18:19 <lambdabot> Unknown command, try @list
18:18:19 <preflex>  zooko was last seen on #darcs 19 hours, 5 minutes and 47 seconds ago, saying: <zooko> I don't know. It seems like a mistake.
18:18:53 <aristid> ddarius: goo could also be const undefined
18:19:11 <ddarius> aristid: At that rate, it could just be undefined.
18:19:46 <aristid> :t fix ($)
18:19:48 <lambdabot> forall a b. a -> b
18:19:57 <aristid> or fix ($) or fix id
18:20:03 <hpc> @let unsafeCoerce = fix id
18:20:04 <lambdabot>  Defined.
18:20:10 <aristid> hpc: hahaha
18:20:11 <hpc> :D
18:24:11 <qfr> http://hackage.haskell.org/packages/archive/nano-hmac/0.2.0/logs/failure/ghc-7.0 noooo!
18:24:20 <qfr> Why is it breaking?
18:24:41 <qfr> <no location info>: 
18:24:41 <qfr> Failing due to -Werror.
18:25:00 <FauxFaux> "-Werror" means "any warning is a fatal error".
18:25:04 <qfr> Oh I get it now
18:25:12 <qfr> ...great haha
18:25:19 <qfr> So it would probably compile
18:25:29 <qfr> I just need to get rid of the -Werror and do it manually? :D
18:26:28 <hpc> evaluate the reason for -Werror being there in the first place though
18:26:34 <FauxFaux> The warning is about a flag that does nothing, so you could get rid of the flag instead.
18:26:41 <qfr> Ah, I see
18:27:04 <FauxFaux> Actually, it doesn't actually say that the flag does something; you should probably check that.
18:28:49 <ddarius> I say you say "Screw you GHC" and then compile it to machine code by hand.
18:30:21 <blbrown_win3> general question, does a compiler or operating system "reimplement" basic arthimetic operations or are those operations passed down to the hardware?
18:30:39 <blbrown_win3> for integers
18:30:55 <hpc> blbrown_win3: it depends on how sane the compiler is
18:30:56 <Pseudonym> It depends on the integer.
18:31:01 <hpc> also that
18:31:05 <FauxFaux> It depends on the operation.
18:31:13 <hpc> and depends on how the OS is being run
18:31:20 <blbrown_win3> so all of that is a factor, cool
18:31:25 <Pseudonym> Generally speaking, the hardware implements basic arithmetic on word-sized integers, both signed and unsigned.
18:31:30 <hpc> vbox won't give a guest OS hardware access
18:31:49 <hpc> but only up to the word size of the processor
18:31:53 <Pseudonym> But even first-generation SPARCs didn't implement division.
18:32:01 <hpc> they also tend to support enormous float precision
18:32:09 <Pseudonym> It provided a shift-and-conditionally-subtract instruction.
18:32:09 <int80_h> ghci 6.12.3 seg faults now. This used to work, I'm poretty sure. COuld someone help me troubleshoot why it doesn't work anymore? I may have globally disabled a module it needs, for example. How do I check that on the command line?
18:32:29 <ivanm> int80_h: you can try with "ghc-pkg check"
18:32:29 <Pseudonym> Some CPUs implement 128-bit IEEE 754 in hardware, some trap to software.
18:32:32 <blbrown_win3> I am playing around with general cellular automata rules in haskell and trying to implement basic arthimetic based on CA rules.  It is pretty fun. 
18:32:48 <ivanm> I wonder, hwoever, if you upgraded some C library that it runs on...
18:32:55 <ivanm> s/runs on/needs/
18:32:56 <blbrown_win3> and was curious how the hardware or software did it
18:32:57 <int80_h> ivanm: I did, it didn't return anything, so I'm in the clear that way.
18:33:18 <int80_h> I don't know what I could have done to bork things, if it wasn't that.
18:34:36 <int80_h> would an install/uninstall help?
18:35:46 <int80_h> ivanm: this could be. I don't know how to find out.
18:36:07 <ivanm> neither do I; I let my PM find that out for me :s
18:42:39 <copumpkin> preflex: seen tomberek
18:42:39 <preflex>  tomberek was last seen on #haskell 42 days, 20 hours, 35 minutes and 4 seconds ago, saying: ddarius: hey, sorry my internet crashed
18:43:49 <alpounet> copumpkin, did he get you involved in reviewing his work on graphs ? :P
18:43:55 <copumpkin> nope
18:44:02 <copumpkin> was just wondering
18:44:19 <alpounet> i haven't heard from him for a while too
18:49:21 <j-invariant> "The notion of monad was invented by Godement in 1958"
18:59:37 <j-invariant> wbere could I find an example of using Monad to do monoid, ring, group theory.. anything like taht
19:00:06 <int80_h> could someone help me troubleshoot why ghci segfaults when I try to run it?
19:00:26 <lars9> is there a strict version of scanl?
19:01:03 <Pseudonym> @hoogle (a -> b -> a) -> a -> [b] -> [a]
19:01:03 <lambdabot> Prelude scanl :: (a -> b -> a) -> a -> [b] -> [a]
19:01:04 <lambdabot> Data.List scanl :: (a -> b -> a) -> a -> [b] -> [a]
19:01:04 <lambdabot> Prelude foldl :: (a -> b -> a) -> a -> [b] -> a
19:01:16 <lars9> nope...
19:04:13 <shachaf> lars9: If anything, you'd want a strict version of scanr.
19:09:58 <copumpkin> roconnor: you can't have used git much :P
19:10:12 <copumpkin> maybe it's true that they don't commute nicely, but it's remarkably pleasant to use for branching and merging all the time
19:11:58 <teki> is it possible to derive any classes other than the standard six (Eq, Ord, Bounded, Enum, Show, Read)?
19:12:16 <monochrom> no
19:12:25 <teki> can you _implement_ it?
19:12:28 <roconnor> copumpkin: I used git to develop CoRN for my thesis
19:12:42 <roconnor> copumpkin: the merging semantics are still broken
19:12:46 <monochrom> yes if you use Template Haskell
19:12:46 <copumpkin> yeah, fine
19:12:54 <copumpkin> it still works remarkably well :P
19:13:04 <Axman6> teki: Data, Typeable and Binary are all derivable
19:13:12 <roconnor> copumpkin: remember what Dijstra said
19:13:21 <klapaucjusz> Hi.
19:13:23 <copumpkin> roconnor: we still need to contribute to GHC
19:13:25 <Axman6> the first two require an extension, not sure about Binary
19:13:45 <klapaucjusz> Any suggestions for Haskell books at third-fourth university year level?
19:13:48 <teki> monochrom: thanks, i'll take a look
19:13:57 <Axman6> copumpkin: would you be more inclined to do that if the ghc team were using git?
19:14:01 <copumpkin> yeah
19:14:10 <Axman6> klapaucjusz: do you know any haskell already?
19:14:14 <int80_h> could someone help me troubleshoot why ghci segfaults when I try to run it?
19:14:33 <klapaucjusz> Yep.
19:14:33 <monochrom> klapaucjusz: try some of http://www.vex.net/~trebla/weblog/fpbooks.xhtml
19:14:42 <klapaucjusz> I'm the one teaching the course ;-)
19:14:42 <Axman6> klapaucjusz: how much?
19:14:56 <Axman6> well, i hope you know a fair bit then
19:15:06 <klapaucjusz> I'm okay.
19:15:32 <Axman6> although, experience has shown that knowing haskell well is sadly not a prerequisite to teaching it
19:15:49 <roconnor> copumpkin: I tried contributing to GHC once.  My patch was rejected
19:15:49 <Axman6> ... i really hope you're not the mapReduce project guy ;)
19:15:56 <roconnor> ;(
19:15:57 <copumpkin> roconnor: aw, what was it?
19:16:19 <nettok> klapaucjusz: so you want a book for your students?
19:16:23 <roconnor> something about trying to optimize bitwise rotate calls
19:16:33 <int80_h> copumpkin: hi, have a minute?
19:16:41 <nettok> what's the class about?
19:16:42 <roconnor> so it doesn't check that 7 is less than 32 every single call
19:16:49 <Axman6> roconnor: sounds like a useful patch, what was the reason it was rejected?
19:16:51 <klapaucjusz> Both something to suggest to my students, and something to help me design the course.
19:16:57 <klapaucjusz> Advanced functional programming.
19:17:02 <copumpkin> roconnor: that seems legit. why would they reject it?
19:17:07 <roconnor> Axman6: it make a few benchmarks slower and a few benchmarks faster
19:17:08 <copumpkin> damn you Axman6 !
19:17:09 <klapaucjusz> ...which means that I'm pretty much free to do whatever I wish.
19:17:31 <monochrom> knowing how to teach is more important than knowing haskell. the mapReduce thing is an example of not knowing how to teach, not an example of not knowing haskell.
19:17:45 <klapaucjusz> The students already know some Caml, but they've never done any pure functional lazy programming.
19:17:48 <Axman6> klapaucjusz: seen http://www.cambridge.org/9780521513388 ?
19:18:26 <klapaucjusz> No, but that'll be definitely over their heads.
19:18:30 <monochrom> the lecture roadmap was like "here is foldl, here is foldr, here is map. now let's unify them with mapReduce"
19:18:47 <klapaucjusz> Heh.
19:18:59 <Axman6> klapaucjusz: the things ion it are pretty simple really, if you can understand them, then it should be fairly easy to teach and for them to learn
19:19:05 <klapaucjusz> No, the Caml course they had last semester already made them hate map and reduc ;-)
19:19:09 <monochrom> it was a really big jump. that is a failure of how to teach. you never make big jumps.
19:19:23 * nettok curses his internet connection
19:19:33 <klapaucjusz> Axman6: it's a programming course, not an algorithms course.
19:19:37 * int80_h curses his cursed ghci
19:19:59 <monochrom> not to mention that the lecture showed insufficient examples so all of the homework was sink-or-swim.
19:20:03 <klapaucjusz> I want to show them some purely functional data structures, some infinite data structures, some type classes, some monads, and perhaps a few existentials.
19:20:09 <Axman6> klapaucjusz: real world haskell then?
19:20:09 <Maxdamantus> *it has little effect*
19:20:32 <klapaucjusz> Yeah, I guess you could call it that.
19:20:51 <carter> hey all, i'm trying to get cabal-install installed from source with ghc 7  64bit  on snow leopard, and i get the following linker error http://hpaste.org/42948/ld_error_with_ghc_7
19:21:04 <klapaucjusz> And I need a good programming book in Haskell so that the students who skip my lectures still have a chance.
19:21:23 <carter> and i was wondering if other have encountered this problem
19:21:38 <Axman6> klapaucjusz: no, i meant the book, real world haskell
19:21:41 <Axman6> @where rwh
19:21:41 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
19:21:57 <monochrom> I haven't seen a book covering existentials
19:22:27 <monochrom> but all books have to cover all the rest
19:22:34 <klapaucjusz> Cool.
19:23:09 <int80_h> monochrom: hiya, do you have a minute?
19:23:27 <monochrom> yes but I can't rescue segfaults
19:23:34 <int80_h> hmm
19:24:02 <klapaucjusz> Hmm.
19:24:09 <klapaucjusz> I'm not sure I like the way they introduce monads.
19:24:14 <int80_h> well I have a solution, but it's rather extreme
19:24:30 <Axman6> klapaucjusz: well, check out lyah too
19:24:33 <Axman6> @where lyah
19:24:33 <lambdabot> http://www.learnyouahaskell.com/
19:24:42 <int80_h> I know I must have done something to cause this as ghci was working fine a few weeks ago
19:25:43 <spvensko> hi, i am a python user and am trying to transistion to haskell, i am having differences "thinking" in haskell, i am currently reading learn you a haskell and am making good progress but i was wondering if there were any other good resources for newbies
19:25:49 <Axman6> klapaucjusz: my usual recommendation for anyone beginning haskell is to real lyah, then the bits of rwh they find interesting
19:26:09 <int80_h> spvensko, have you looked at "Real World Haskell"?
19:26:17 <monochrom> http://www.vex.net/~trebla/haskell/learn-sources.xhtml
19:26:35 <spvensko> int80_h: no, probably the next step for me?
19:26:38 <Axman6> spvensko: lyah is the best tutorial, but if you aren't asking questions in here as well, then you're missing out on a hell of a lot. #haskell is probably the best learning resource we have
19:26:58 <klapaucjusz> Lyah looks good.
19:27:01 <int80_h> spvensko, I'm a newb too but lots of people here think LYAH and RWH make a great match
19:27:06 <aavogt> Axman6: you mean Cale?
19:27:08 <spvensko> Axman6: #python has scarred me from asking newbie questions :x
19:27:22 <Axman6> spvensko: we strongly encourage newbie questions
19:27:27 <monochrom> logically, #haskell subsumes Cale.
19:27:28 <Kaidelong> well you never stop being new at haskell really
19:27:35 <int80_h> you can ask here, #haskell is newbie-friendly
19:27:51 <int80_h> Kaidelong, I suspected as much
19:27:58 <Kaidelong> just when you have one thing down some other fascinating thing pops up
19:28:03 <Axman6> well, most of it is, Cale is newbie friendly, but his version of lambdabot is not sadly
19:28:18 <spvensko> one of my major issues is that i am currently working on projects in python which are time-sensitive so it's hard to code in python then try to completely change my perception when reading lyah
19:28:21 <aavogt> > 2 3 4
19:28:22 <lambdabot>   2
19:28:25 <int80_h> like the mysterious segfaulting ghci, that's a new problem.
19:28:37 <Cale> int80_h: what?
19:28:40 <Axman6> heh
19:28:42 <Kaidelong> GHC 7?
19:28:49 <Kaidelong> I heard it still needs some work
19:29:02 <carter> @Kaidelong are you referring to my question?
19:29:03 <lambdabot> Unknown command, try @list
19:29:12 <monochrom> don't use @
19:29:19 <klapaucjusz> Hmm, the only book I can remember from my time learning Haskell is Thompson.
19:29:23 <Kaidelong> carter: no, to int80_h's comment
19:29:25 <int80_h> Cale, oh hi. My version of ghci segfaults when I try and start it. This is new. It worked fine a few weeks ago. I nbeed ideas on how to troubleshoot how I borked it.
19:29:28 <aristid> carter: if you talk to people and use @ in front, lambdabot thinks it's a command for him
19:29:30 <klapaucjusz> ...I think.
19:29:59 <carter> aristid : noticed, thanks
19:30:09 <Kaidelong> clearly lambdabot is just missing some features and the command "Kaidelong" is planned functionality
19:30:09 <int80_h> ghci 6.12.3
19:30:17 <Cale> int80_h: hmm, I'd probably just try reinstalling first and/or blowing away ~/.ghc
19:30:26 <int80_h> ah!
19:30:56 <int80_h> Cale, okay I will re-install.
19:31:24 <int80_h> I had re-installing as my last resort. I was hoping this would be a chance to learn something new about the haskell ecosystem.
19:31:33 <Cale> int80_h: Well...
19:31:44 <Cale> int80_h: Segfaults are definitely not supposed to happen
19:31:54 <carter> in my case, ghci works, but even a minimal hello world makes the linker complain
19:31:57 <monochrom> http://www.vex.net/~trebla/haskell/sicp.xhtml is how you learn the haskell ecosystem.
19:31:57 <int80_h> I thought maybe I had a critical package hidden
19:32:09 <monochrom> I mean the ghc ecosystem
19:32:38 <monochrom> hidden packages don't cause ghci to segfault
19:33:17 <int80_h> well I needed to replace archlinux with debian anyway. So now is a good time
19:33:18 <Axman6> carter: see if you can find where ghc uses that flag
19:33:28 <carter> what flag?
19:33:32 <carter> Axman6 what flag
19:33:35 <carter> ?
19:33:43 <Axman6> the one that was complained about by the linker
19:34:09 <carter> Axman6 : where should I look?
19:34:22 <Axman6> you're on OS X right?
19:34:26 <carter> yeah
19:35:50 <BMeph> > text "Hello, World!"
19:35:50 <lambdabot>   Hello, World!
19:35:51 <carter> where would I look?
19:35:51 <spvensko> it seems that in haskell that it pays off to think about the algorithm you're programming before you start coding instead of coding it (as i often do) as you go
19:35:51 <Axman6> if you open up /Library/Frameworks/GHC.framework and do a search in there for the flag, hopefully that'll find it. i'm hoping the flag is just called in a script somewhere
19:35:52 <spvensko> is this reasonable?
19:36:02 <Cale> spvensko: yeah
19:37:00 <gwern> spvensko: a cliche observation
19:37:00 <BMeph> "If you don't know what you want, then how will you know when you get it?"
19:37:29 <spvensko> BMeph: when it eventually spits out the output i want to see? :)
19:38:16 <spvensko> i'm reading the pragmatic programmer at the same time as lyah so hopefully they will complement each other
19:38:17 <BMeph> spvensko: Ah. Then, you do kow what you want: a certain output for a certain input.
19:39:09 <spvensko> BMeph: instead but my method of getting to that output are always clear
19:39:16 <Cale> It's probably true in any language that it pays off to think before you write code, but it's particularly true in Haskell, where if you design things right, things can be pretty concise, and so quite a lot of functionality can fit into your head at a time.
19:39:29 <spvensko> whereas it seems to be reasonably fast in haskell coding you need to know what you want to do before hand
19:40:33 <monochrom> I think before I code. Even when I used BASIC.
19:40:52 <Axman6> bleh, bloody freenode
19:41:08 <carter> Axman6 : this is one of the community builds for ghc 7, not one of the framework installs
19:41:19 <carter> (because its the 64bit build)
19:41:37 <spvensko> monochrom: i don't feel productive unless my fingers are moving :(
19:41:37 <Axman6> ok, well whereever it is installed, see if you can find that flag being used somewhere
19:41:43 <spvensko> unfortunately
19:41:56 <spvensko> i'm also self-taught which problem explains a lot of my nastier habits
19:42:01 <monochrom> When I think, I also write on paper. So my fingers are also moving.
19:42:03 <Axman6> spvensko: that's a great way to write a lot of code
19:42:14 <spvensko> monochrom: i do too, my research notebook is roughly 800 pages
19:42:15 <Axman6> s/a lot of/a lot of bad/
19:42:21 <spvensko> Axman6: indeed
19:42:36 <monochrom> I write with a fountain pen. Watching non-viscous ink flowing out is a pleasure.
19:43:12 <spvensko> i'm hoping reading more of the pragmatic programmer will instill more good habits
19:43:33 <gwern> monochrom: you're such a Djikstra wannaba
19:43:37 <gwern> *wannabe
19:43:53 <blackdog> i agree it's a good idea to at least have some idea what you're doing before you start, but i'd hate to lose the assistance of the type system in checking whether my thoughts are coherent.
19:44:12 <gwern> monochrom: also, how does something non-viscous flow?
19:44:25 <monochrom> You can easily write "f :: Int -> Int; f = undefined" as part of your thinking and planning.
19:44:35 <aristid> gwern: Dijkstra
19:45:04 <gwern> aristid: I have a theory that even Djikstra couldn't spell his own name correctly and so my spelling is the true one
19:45:09 <monochrom> I don't know. I have forgotten the physics
19:45:10 <aristid> it's only 5 consonsants in a row, after all
19:45:20 <Axman6> gwern: biro ink is non-viscous
19:45:30 <aavogt> gwern: all at once
19:45:36 <Axman6> uh, or is is viscous
19:46:37 <aristid> gwern: well Dijkstra makes phonetically more sense for a Dutch, i think
19:46:38 * Maxdamantus stabbed himself with a fountain pen once.
19:46:57 <Maxdamantus> Everything went all blurry.
19:47:16 <Maxdamantus> and it left a black mark in my hand for a month.
19:47:20 <gwern> aristid: mm. I would agree except my own dutch surname is pretty weird
19:47:37 <gwern> so why not Djikstra?
19:50:03 <lars9> can not define a 'type ABC' as an instance of a class?
19:50:09 <lars9> has to be data or newtype?
19:50:26 <Axman6> yes
19:50:27 <monochrom> The other night I had a dream about getting a macbook. My thought during the dream: "I have always wanted it. Finally! Just not sure how I got the money for it. But here it is! A macbook in front of me, it's mine now. But wait, I think there was another reason, in addition to lack of money, why I haven't bought a macbook."
19:50:52 <monochrom> I woke up and completed the thought: "Indeed, the other reason is GHC".
19:51:29 <blackdog> monochrom: ghc on mac is less painful than it was
19:51:43 <blackdog> dylibs work now :) although some 64 bit support would be nice.
19:52:23 <aristid> gwern: i cannot even imagine how Djikstra would be pronounced in dutch :)
19:53:10 <gwern> aristid: iirc, it's pronounced like dike-stra
19:53:10 <Maxdamantus> Dyike stra?
19:53:26 <allbery_b> "ij" is "y", roughly
19:53:40 <Maxdamantus> So "ji" would be "yi"
19:53:45 <Maxdamantus> (roughly)
19:53:48 <gwern> watched an interview with him once and I think that's how it was pronouned
19:53:48 <aristid> gwern: it sounds like Deijkstra to me german ears: http://upload.wikimedia.org/wikipedia/commons/8/85/Dijkstra.ogg
19:53:59 <aristid> -me+my
19:54:21 <Maxdamantus> Oh, the spelling mistake was unintentional?
19:54:31 <allbery_b> (actually "ÿ", it's not combining letter values, it's just a sort of anti-ligature)
19:54:54 <gwern> aristid: hm. a little subtle to my ears. dike-stra seems like a good approximation
19:56:03 <aristid> gwern: but i hear no j between d and i
19:56:19 <gwern> aristid: my suggestion has no j as well
19:56:25 <Maxdamantus> Somewhere between dike and dake.
19:56:31 <allbery_b> are you sure it's not front-y
19:56:33 <allbery_b> ?
19:56:34 <aristid> gwern: why do you spell it consistently with dji then? :)
19:56:47 <gwern> I HAVE NO IDEA
19:56:53 <Axman6> heh
19:56:57 <allbery_b> which is hpw I'd pronounce ÿ
19:57:08 <aristid> gwern: let's resolve this by saying that it is dutch and does not have to make sense :P
19:57:33 <allbery_b> and as to gwern, might as well ask why people type "teh"
19:57:37 * gwern puzzles over the silent g in his dutch surname. 'tge' is pronounced as 'teh'? how does that work
19:57:55 <monochrom> heh
19:57:59 <aristid> allbery_b: well, he always writes it like that, and insisted that it must be this way :)
19:58:44 <allbery_b> don't know for Dutch.  It'd make sense in Turkish, if you posit that the yumusak got lost somewhere
19:58:59 <carter> Axman6  :  so the crazy thing is, the binarys produced work, despite that linker error!
19:59:07 <allbery_b> (dammit, vnc is eating s-cedilla.)
19:59:14 <Axman6> carter: not crazy, handy :P
19:59:26 <aristid> allbery_b: maybe there is a secret historic connection between turkey and netherlands!
19:59:28 <monochrom> crazy evaluation is handy
20:00:02 <aristid> monochrom: does GHC have a flag for it yet? :D
20:00:07 <allbery_b> might not even be secret
20:00:14 <monochrom> Ottoman was secretly a Dutch. He also secretly liked Haskell.
20:00:59 <allbery_b> Turkish maritime activities in the 18th century led to a certain amount of Turkish going to other countries and a fair amount of other countries' words getting absorbed into Turkish
20:01:57 <allbery_b> (for example, "yogurt", or "yoghurt", is from Turkish; the "gh" is someone's interpretation of the yumusak g, which is itself silent but lengthens the following vowel)
20:05:21 <aristid> allbery_b: oh, i have a short list. dilmaç, ordu, havyar are some examples of words that were transferred from turkish :D
20:05:44 <aristid> yoğurt, köşk
20:06:19 <gwern> ordu?
20:06:21 * Axman6 hasn't heard of any of them
20:06:27 <aristid> gwern: Horde
20:06:31 <gwern> ah
20:06:38 * digitteknohippie reads ahead a few chapters in real world haskell, and encounters folds, which at first glance, barely understanding, makes haskell seem very advanced n powerfull n flexible.
20:07:05 <allbery_b> folds are a simple concept with immense ramifications
20:07:13 <codemac> Is there any useful tool to inspect types of objects visually? I'm trying to wrap my head around several libraries at a time, and it's hard to keep track of types
20:07:36 <aristid> digitteknohippie: folds are cool!
20:07:36 <Axman6> codemac: vacuum and it's various packages
20:07:52 <gwern> Axman6: isn't that for inspecting instances of data structures?
20:08:15 <Axman6> ah, yes, didn't quite read the whole question ;)
20:08:24 <gwern> digitteknohippie: but you do understand the common idiom being wrapped up as folds, right, the same way map is something you already write a lot
20:08:28 <codemac> it's useful none the less!
20:08:29 <digitteknohippie> codemac & aristid, yuyeah
20:09:06 <carter> Axman6 : yes, in the sense that only if once I have a working cabal install this error doesn't kill using cabal
20:09:30 * digitteknohippie goes back to earlier on in the book, to continue reading n learning, so he can one day know what gwern meant
20:09:33 <codemac> Is using a different editor advantageous for this as well? I'm using emacs right now..
20:10:12 <aristid> digitteknohippie: you should have an instance of ghci open
20:10:18 <aristid> digitteknohippie: so you can try out stuff
20:10:24 * digitteknohippie does
20:10:43 <allbery_b> haskell mode can have a ghci session running in a window for testing and such
20:10:58 <gwern> digitteknohippie: I mean, if you want to write an 'increment list' function, you write 'foo (x:xs) = [x+1] ++ foo xs; foo [] = []'; and map packages that so you can write 'foo xs = map (+1) xs'
20:11:07 <digitteknohippie> have a second tilda built to run ghci insteada bash.   very handy.  always just a button press away.
20:11:36 <codemac> allbery_b: I have ghci running in an eshell
20:11:49 <codemac> but I'm at the functionally retarded stage of haskell
20:12:11 <codemac> I run up against type errors instead of logic errors as my main battle when trying to play around, and it gets frustrating
20:12:13 <digitteknohippie> codemac, i'm not even that far yet.
20:12:30 <codemac> hahah
20:12:46 <Axman6> codemac: learn to love it, type errors are great :D
20:12:48 <allbery_b> I still do that too
20:13:03 <allbery_b> but type errors are your friewnd, resolving them usually also resolves the logic errors
20:13:22 <codemac> yea, I guess I usually just stare at them, wonder wtf they're talking about, and then close my laptop
20:13:24 <Axman6> most languages let you avoid the pain of type errors by letting you produce code that doesn't make sense
20:13:29 <digitteknohippie> just made xmonad configurations, read a little of learn u a haskell for great good, and a little of real world haskell.   wud learn faster if i could shove everything else off my plate, n devote 24/7 to haskell.  ^_^
20:14:06 <codemac> I got into haskell when I was in school, but work is all systems C, so I don't have much time for type theory during the day
20:14:11 <gwern> I view dynamic typing as laziness - the program produces as much as output as it can before it is killed by a type error
20:14:16 <aavogt> while not all valid programs can be given correct types, you probably don't want to write such programs
20:14:38 <gwern> laziness of the type system, if you will, rather than terms
20:14:56 <gwern> (this goes back to kay's point about delaying binding as long as possible)
20:14:57 <aavogt> gwern: you have the choice though
20:15:23 <aavogt> as there is  Data.Dynamic, -XExistentialQuantification
20:16:10 <allbery_b> practical type theory can help you even in C, as learning to write correctly typed programs the first time teaches you to write logically correct programs the first time, even in other languages
20:16:13 <int80_h> can I install ghci be itself or do I need to install ghc ?
20:16:26 <gwern> aavogt: as a practical matter, none of the matters for someone learning
20:16:29 <allbery_b> the latter
20:17:30 <gwern> aavogt: you can see why type laziness would be helpful - it lets them get *some* feedback on the correctness of their code so far = 'ok. it did print out some stuff, so terminal IO is at least working...'
20:17:55 * aavogt doesn't remember when things started/stopped mattering
20:18:25 <gwern> (if they could carefully write their program piecemeal in the exact right order to get that sort of feedback with strict typing, then they wouldn't be beginners either)
20:19:13 <aavogt> gwern: have you used haskelldb (or some library that gives you similarly large types)?
20:19:21 <gwern> no
20:19:44 <allbery_b> int80_h: even if you could, yoou'd have something like 95% of GHC
20:20:07 <aavogt> gwern: well compile-time type errors can be more difficult to decipher
20:20:23 <aavogt> "no instance for   blaaaaaaaaaargh"
20:21:27 <codemac> is the vacuum webpage dead?
20:21:39 <aavogt> @hackage vacuum
20:21:39 <lambdabot> http://hackage.haskell.org/package/vacuum
20:21:49 <aavogt> codemac: yes
20:22:01 <aavogt> preflex: seen mmorrow
20:22:01 <preflex>  mmorrow was last seen on #ghc 358 days, 1 hour, 24 minutes and 15 seconds ago, saying: * mmorrow is rtfm'ing
20:22:08 <Axman6> :(
20:22:20 <codemac> That's a long manual
20:22:49 <allbery_b> ok, who sent mmorrow the VMS system documentation? :)
20:23:44 <aristid> codemac: that joke is soooo old its beard is older than your first-born son
20:24:28 <codemac> sorry, brain is at minimum low burn after work
20:25:40 <gwern> allbery_b: I hear the lisp machine documentation was even bigger
20:27:39 <aristid> gwern: maybe he compared both systems
20:28:16 <codemac> how do you use vacuum? I cabal install'd it, but there's no binary.. just load the library in ghci?
20:28:49 <Axman6> codemac: you probably want the cairo version, to give you pretty pictures
20:30:18 <codemac> also, who is the latest person to take up yi?
20:30:31 <codemac> it seems like an awesome project for haskell. I need an emacs that has fucking threads
20:30:45 <codemac> well, MP, threading isn't necessary
20:31:54 <codemac> ah damn, cairo wont install
20:31:56 <gwern> codemac: maybe you'd prefer working on manatee
20:34:49 * hackagebot plot-gtk 0.1.0.2 - GTK plots and interaction with GHCi  http://hackage.haskell.org/package/plot-gtk-0.1.0.2 (VivianMcPhail)
20:35:26 <codemac> manatee.. is a thing
20:36:34 <allbery_b> <codemac> it seems like an awesome project for haskell. I need an emacs that has fucking threads
20:36:39 <allbery_b> yes, oh, yeeeesssssssss
20:37:00 * allbery_b has of late been slamming headlong into emacs' failure to even do green threads
20:37:13 <adnap> lol, never seen this before, but just read someone referring to the IO monad as the "sin bin"
20:37:51 <Axman6> @pl \x -> foo ["-r",x]
20:37:52 <lambdabot> foo . ("-r" :) . return
20:37:58 <Axman6> yeah no
20:40:29 <gwern> I say manatee because right now no one is working on yi really
20:41:15 <edwardk> yeah. a couple of yi guys pinged me about the monoidal parsing machinery a year or so back, but its been pretty quiet since
20:41:25 <Axman6> i think there's some work being done on it, while getting it properly integrated into leksah
20:41:47 <Axman6> hamishmack would be able to tell you more (i think)
20:41:48 <dolio> Yes, the monoidal parsing buzz has been quiet. :)
20:42:36 <edwardk> =)
20:42:45 <edwardk> sorry, other distractions ;)
20:42:49 <codemac> what is manatee's scope? It seems to want to replace my web browser. I am are confused
20:42:55 <edwardk> i got it to where it met my needs and moved on =P
20:43:17 <Axman6> codemac: it seems to me to want to replace my whole OS
20:43:29 <Axman6> it's a hell of a lot more than a web browser
20:43:40 <codemac> Yea, I got lost in the video with what they were trying to show me
20:44:14 <aristid> edwardk: monoids package does does not build btw :P
20:44:29 <gwern> edwardk: you have actual needs?
20:44:39 <gwern> I thought it was just research
20:45:23 <edwardk> aristid: yeah, base got bumped i think and it just languished. i need to roll back monoids to ~ 0.1.36 and update dependencies
20:45:44 * gwern respects edwardk less now, I think
20:45:56 <aristid> gwern: because he has actual needs?
20:46:02 <edwardk> gwern: my needs are for my own research n this regards ;)
20:46:23 <edwardk> but i do occasionally ship software that is used by other people
20:46:24 <gwern> yes. I had envisioned him as a luminous being of light emitting beautifully formatted haskell
20:47:00 <edwardk> well, the light thing is true. my wife gets a bit annoyed though, when i come to bed and the room lights up.
20:47:40 <BMeph> edwardk: Your kids must be brilliant! <cues rimshot>
20:47:43 <gwern> perhaps one day she will realize the honor it is to be shown upon
20:47:56 <ddarius> BMeph: Every last one of them is.
20:48:24 <edwardk> trying to figure out a nice fast way to insert small complete binary trees into a fingertree quickly.
20:48:53 <ddarius> Suitable application of unsafeCoerce.
20:48:57 <edwardk> hah
20:49:39 <edwardk> basically i have a skew-binary random access list, and a fingertree that i'm trying to use together as a stream zipper with log n seek
20:50:46 <edwardk> but while i can peel off n nodes from the skew binary list in O log n time, i get them in the form of complete binary trees.
20:51:15 <edwardk> i could put them into the fingertree that way, but then drop (-1) costs O(log n)
20:52:33 <edwardk> i was hoping to pick jbapp;e
20:52:44 <edwardk> er jbapple's brain but he seems to have vanished
20:54:16 <aristid> edwardk: "drop (-1)"?
20:54:24 <edwardk> (moving the zipper backwards)
20:54:54 <edwardk> basically its <fingertree> <current pointer> <skewbinarylist>
20:55:01 <edwardk> er
20:55:13 <edwardk> <fingertree> <current pointer> <fingertree> <skewbinarylist>
20:55:21 <edwardk> the skewbinary list lets it have an infinite tail
20:55:31 <edwardk> the fingertrees are the explored portion of the stream
20:59:52 <teki> aavogt: i have come across one example of a function which would be useful that Haskell does not allow to compile due to type errors: http://hpaste.org/42904
21:00:07 <teki> aavogt: (well two, if you count the fmap version of the same)
21:02:44 <aavogt> teki: you want to go down n levels of nested lists?
21:03:24 <aristid> edwardk: if "drop (-1)" makes sense, maybe you should use another name
21:03:52 <edwardk> hah, well, i just kept the main operations the same, the move operations aren't named yet ;)
21:04:18 <ddarius> I suggest giddyup and woahNelly.
21:05:25 <edwardk> @hpaste
21:05:26 <lambdabot> Haskell pastebin: http://hpaste.org/
21:05:58 <edwardk> http://hpaste.org/42949/more_streams is kinda what i'm thinking regarding streams
21:06:07 <edwardk> though i only have 3-4 of those implemented
21:08:10 <edwardk> the skew streams are to enable me to have a compromise between the hand-over-hand crawling i have to do in a traditional stream and the O(1) speed associated with a Sequence that doesn't let me update at all efficiently
21:08:34 <aristid> edwardk: you somehow manage to explode every tree (of haskell modules in this case). i didn't even know there are so many kinds of Streams
21:09:03 <edwardk> eelis asked for a nonempty list in a package.. i got a little sidetracked
21:09:05 <edwardk> ;)
21:09:49 <edwardk> all of those are comonads (except the tensors)
21:09:49 <teki> aavogt: yeah, and i don't want to write fmapAt2, fmapAt3, so on and so forth
21:10:00 <ddarius> aristid: What Ed does is research the general case and then implement that.  Then no one uses it because it's insane.  Then he reimplements a million instantiations of the general case.
21:10:01 <edwardk> and most of them are monads
21:10:15 <teki> aavogt: admittedly writing those would solve the problem, just not the general case :P
21:10:22 <edwardk> hahahahaha
21:10:57 <edwardk> yeah, these are just the versions i can make haskell 98 :P
21:11:54 <aristid> edwardk: so streams-gadt is coming later? ;)
21:12:11 <edwardk> aristid: meh, unboxed-streams ;)
21:12:50 <edwardk> this list was mostly put together as a way to explore the design space and see what made sense
21:13:22 <edwardk> what i have right now are Branching, NonEmpty, Future and Future.Infinite
21:13:29 <edwardk> i also have the Tensors in my AD package
21:13:48 <edwardk> (at least Tensors.Infinite in this terminology)
21:13:50 * ddarius had forgot about the tensors.
21:14:01 <aristid> edwardk: you should also include finite lists :)
21:14:26 <edwardk> aristid: Data.List.* was cut from scope when the streams/sequences started exploding ;)
21:14:45 <aristid> edwardk: but the completeness is destroyed!
21:14:53 <edwardk> nah, just another package ;)
21:15:11 <edwardk> the model was for everything here to be a comonad
21:15:26 <aristid> which list does not obey
21:15:39 <edwardk> the lists have fewer requirements than this stuff, so they should probably be in a package with fewer dependencies
21:15:56 <aristid> fair enough
21:16:26 <aristid> edwardk: will you reimplement ordinary lists (of the possibly empty, possibly infinite variety) too?
21:16:29 <aavogt> teki: http://hpaste.org/paste/42904/a_funny_little_function_annot#p42950
21:16:30 <edwardk> plus, not being comonads they don't fit into my obsession du jour
21:16:48 <edwardk> aristid: no sense reinventing what already exists  =P
21:16:55 <aavogt> teki: a bit of preprocessor magic can make specifying the numbers less awkward
21:17:42 <aristid> edwardk: there needs to be a tiny tiny bit of variation to warrant implementation, eh?
21:17:49 <edwardk> i'm just trying to figure out if the skew zippers are fast enough to be worth it
21:18:04 <aavogt> teki: I'm not completely sure about the unsafeCoerce, but otherwise I can't think of another way to improve type inference
21:18:22 <edwardk> i was originally only intending to implement the infinite, non-empty and branching cases
21:18:41 <edwardk> since they are nicely very different (co)monads
21:19:22 <edwardk> but then in order to implement 'Semigroup.Traversable' for NonEmpty i had to make a more nicely inductive form of future, and it snowballed from there
21:20:26 <aavogt> teki: the issue is to get ghc to pick the first instance when it looks like the f supplied to mapAt won't match with what  mapAt it given/produces
21:20:31 <edwardk> ( i need to convert data NonEmpty a = a :| [a] into something where every constructor has an a in it, like data Future a = Last a | a :< Future a, then use traverse1, then turn it back)
21:21:06 <edwardk> the former is nicer for interop with haskell lists though, since converting it back and forth requires only reconsing the head
21:22:51 <edwardk> i'll probably just package up the 3-4 i have and call it a ay
21:22:53 <edwardk> er day
21:24:32 <sproingie> aaaayyyyyyyy</fonzie?
21:24:36 <sproingie> >
21:24:39 <carter> this is awesome, I now have 64bit haskell with a working cabal install running on snow leopard
21:26:04 <aefjt> Does that imply that it's usually very difficult to get those running on "snow leopard"?
21:32:25 <john_r_watson> I'm having trouble using where/let in ghci
21:32:38 <john_r_watson> for instance defining my own scanl
21:33:34 <john_r_watson> let scanl' f a xs = ys; where y = a : zipWith f xs y
21:33:38 <john_r_watson> doesn't work
21:33:42 <john_r_watson> > let scanl' f a xs = ys; where y = a : zipWith f xs y
21:33:42 <lambdabot>   <no location info>: parse error on input `where'
21:34:07 <alpounet> > let scanl' f a xs = ys where y = a : zipWith f xs y
21:34:08 <lambdabot>   not an expression: `let scanl' f a xs = ys where y = a : zipWith f xs y'
21:34:09 <john_r_watson> I assume I need braces, but I've tried numerous combinations to no avail
21:34:14 <alpounet> this should work in ghci
21:34:19 <alpounet> remove the ";" before where
21:34:48 <john_r_watson> so it does...
21:34:49 <john_r_watson> weird
21:35:25 <john_r_watson> I must have been trying a different example
21:36:36 <carter> aefjt : yes, because its only as of ghc release 7 that theres 64 bit haskell on snow leopard
21:36:46 <carter> and the haskell platform release isn't out yet
21:36:58 <carter> so i had to hand feed cabal install into running
21:37:29 <carter> (this pain will be gone as soon at the next haskell platform release it out, which i think is within the next month)
21:38:38 <carter> and its only problematical if you're trying to use foreign libs that were complied in 64 bit
21:39:01 <carter> which on the mac can happen if you like to use the homebrew package manager for software normally
21:40:47 <blackdog> carter: ... when did ghc 7 get 64 bit on mac?
21:41:14 <carter> blackdog : you can get an unregisterised one from the ghc site
21:42:29 <blackdog> carter: urgh. not exactly production-ready, then
21:42:55 <blackdog> i got all excited for a second, getting ruby to build in 32 bit mode for hubris is an epic pain in the arse.
21:43:23 <carter> blackdog : in this case, what do you mean by production ready?
21:43:58 <blackdog> carter: the unregisterised version is pretty slow, no?
21:44:12 <carter> blackdog : does that apply to the llvm backend?
21:44:16 <blackdog> i thought the point was just to be able to build the registerised version on new platforms
21:44:19 <blackdog> hm. don't know.
21:44:27 <carter> i don't think so...
21:44:36 <carter> and how else will i use lapack etc 
21:45:14 <blackdog> have you benchmarked it? i'll have to ask david terei next time i see him, i guess..
21:46:49 <carter> what benchmark would be desired
21:47:59 <blackdog> carter: well, 32-bit unregisterised llvm vs 32-bit registerised llvm vs 32-bit NCG, i guess. it's hard to do accurately, especially given what you actually want to know about is 64-bit unregisterised
21:48:42 <blackdog> it looks like he has branches for both: http://sites.google.com/site/haskell/notes/ghc-llvm
21:48:45 <carter> i don't have the time to do that :)
21:48:59 <blackdog> carter: yeah, fair enough. me either
21:49:00 <blackdog> :
21:49:05 <carter> but if folks want, i could do the 64bit run
21:49:07 <blackdog> which is why i was hoping someone else had:)
21:49:31 <carter> umm, that doesn't look like a page on profiling
21:50:00 <blackdog> carter: no, that's just about the llvm backend - shows he has branches for each.
21:50:07 <carter> ok
21:50:09 <carter> well
21:50:22 <carter> i was moreso asking about standard benchmark things :)
21:50:40 <blackdog> oh, right. there's nofib, i guess. it's in a bit of a parlous state really.
21:50:50 <blackdog> not very glamorous
21:51:22 <carter> ahh
21:51:43 <carter> my stance: lapack takes less time to use than native haskell linear alg :)
21:52:41 <blackdog> if you're spending most of your time there then it almost doesn't matter if the haskell code is a bit slower, i guess.
21:53:03 <blackdog> i'm trying to sell haskell to rubyists as a performant but concise drop-in language
21:53:50 <blackdog> am a bit annoyed with UNSW atm - they've dropped David's website.
21:54:29 <aefjt> But haskell doesn't have eval!
21:54:45 <carter> eval's never performant :p
21:55:21 <aefjt> It creates bugs really fast
21:56:17 <Axman6> High Performance Bug Creation (TM)
21:58:15 <kfish> blackdog, which David?
21:59:46 <Veinor> oh god, compiling things on my 512MB vm is painful
21:59:57 <sproingie> haskell to rubyists ... might be a tough sell
22:00:09 <sproingie> maybe if you call it a DSL
22:00:25 <Axman6> Veinor: i'd imagine a few things you'd compile with ghc would not cope at all well with that
22:00:34 <Veinor> Axman6: like snap
22:00:40 <Axman6> sproingie: where the domain is "fast code"
22:00:51 <sproingie> Axman6: and "if it compiles, it works"
22:00:55 <Veinor> snap caused my irc client to swap out entirely
22:01:07 <Axman6> hah, ouch
22:01:36 <sproingie> but man, ruby tends to make python look rigorous
22:01:37 <mightybyte> Veinor: How did that happen?
22:01:47 <Veinor> i run my irc client on my VM too
22:01:58 <ManateeLazyCat> Veinor: Which your irc client? Link?
22:02:01 <Veinor> Axman6: it was amusing switching to the haskell window and then waiting for 3 seconds for it to swap it all back in
22:02:10 <Veinor> http://www.weechat.org/
22:02:39 <blackdog> kfish: David Terei
22:02:53 <ManateeLazyCat> Veinor: You write it?
22:03:00 <Veinor> nah
22:03:00 <carter> the one tricky thing with preemy ghc 7 on snow leopard is making the lib deps interactnicely
22:03:02 <blackdog> sproingie: well, the whole point is to cast it as an alternative to C
22:03:15 <Axman6> this is why i need 8GB RAM in my next laptop
22:03:17 <blackdog> "Don't rewrite your whole app: just do a little bit in haskell and leave the rest in rails"
22:03:25 <ManateeLazyCat> Veinor: That irc client looks cool. :)
22:03:41 <Veinor> it is
22:03:43 <sproingie> blackdog: ruby is well known for having a dead simple C FFI.  would that apply to haskell?
22:03:45 <blackdog> Axman6: i managed to take down ci.shimweasel.com by actually building on the host, instead of just using it as a front-end
22:04:19 <blackdog> sproingie: erm. i wouldn't say it's that simple :)
22:04:26 <Axman6> blackdog: what's ci.shimweasel.com?
22:04:35 <kfish> blackdog, bummer, i thought pls had their own server
22:04:35 <sproingie> blackdog: it beats perl XS
22:04:36 <Veinor> also, random style question
22:04:50 <blackdog> but the Ruby->Haskell ffi i have is pretty nice - uses HINT to see which functions are "translatable"
22:04:52 <sproingie> tho while we're on python, cython has it beat
22:05:05 <Veinor> oh... hm, nevermind
22:05:08 <blackdog> so you can just say "import this haskell module as a ruby module"
22:05:17 <blackdog> and any monomorphic functions will be imported
22:05:20 <djahandarie> What is the proper way to link to another package/module in your Haddock documentation on hackage?
22:05:20 <sproingie> blackdog: no kidding.  got a url?
22:05:29 <djahandarie> With <...>?
22:05:33 <blackdog> http://github.com/mwotton/hubris.git
22:05:48 <sproingie> 404
22:05:55 <blackdog> kfish: i think they do, but they're the clusters on pill*
22:06:08 <sproingie> god github's 404 page is cute
22:06:13 <blackdog> sproingie: sorry, s/.git//g
22:06:23 <blackdog> kfish: they're not actually exposed as web hosts
22:06:37 <sproingie> blackdog: cool, bookmarked
22:06:53 <aefjt> (Why does obi-wan have tentacles?)
22:07:03 <blackdog> UNSW hosting is pretty draconian - i remember gernot coming down all full of righteous fury because the machines were down for maintenance and he'd just been slashdoted
22:07:11 <sproingie> aefjt: because it's the octocat in a robe
22:07:23 <blackdog> kfish: I was on SS at the time - not so much fun. they're very much command-and-control.
22:07:39 <sproingie> don't ask me where github's octocat came from
22:08:00 <blackdog> sproingie: it's _almost_ done. i got it working in "works-on-my-machine" style a while ago, and have been working on making the install halfway acceptable since
22:08:45 <sproingie> blackdog: i've been looking at doing a general migration to ruby, this could be _the_ killer app for that :)
22:08:59 <blackdog> Axman6: ci.shimweasel.com is my hudson instance running on the free EC2 vm i got
22:09:28 <Axman6> hudson? never heard of it
22:09:47 <blackdog> so each time i commit, there's a post-commit hook that pulls the source and tests it in another environment. the cool thing is you can do matrix builds, where you get the cartesian product of OS/Ruby version/GHC version/whateverelseyouwant
22:10:01 <blackdog> hudson is a continuous integration server written in java, and it is shockingly good.
22:10:08 <blackdog> sproingie: what are you trying to migrate?
22:10:22 <Axman6> sounds good :)
22:10:43 <blackdog> sproingie: i'd be very interested in helping get hubris into actual use somewhere :) it's a bit of a solution looking for a problem at the moment.
22:10:43 <sproingie> blackdog: since seeing ruby 1.9's benchmarks next to python 3, and also Rails 3, i think ruby's gotten all grown up :)
22:11:20 <blackdog> ruby is not too intolerably disgusting. I hope that doesn't get me lynched here.
22:11:42 <sproingie> blackdog: what i would migrate would be a hojillion scripts in perl, various python web apps, and stuff i have in C++ because it was too slow in perl
22:12:04 <blackdog> admittedly they made a total mess of scoping in 1.8, and the speed is pretty bad, and the whole Proc/lambda thing is a bit messy. but still. i used to program in perl professionally (or at least i got paid for it)
22:12:25 <sproingie> i actually tried the C++ code in haskell but my haskell skills were so bad at the time that it space-leaked like mad
22:12:52 <sproingie> blackdog: scope was bad, but unicode support was a total non-starter in 1.8
22:13:14 <sproingie> even 1.9 doesn't have the greatest support but it's at the level of "adequate"
22:13:45 <sproingie> and proc/lambda is a bit schizo but i can live with it
22:13:58 <ManateeLazyCat> WeeChat looks very cool. Find time perfect manatee-ircclient. :)
22:13:59 <blackdog> sproingie: oops, i almost forgot. yes. unicode was awful.
22:15:07 <blackdog> sproingie: sure. it doesn't decrease expressivity, it's just a bit of a wart.
22:15:11 <blackdog> very perlish.
22:15:37 <sproingie> perl has the utf8 flag, though i end up having to use bits of Encode.pm if i want to be rigorous
22:15:45 <sproingie> arguably python does it quite well
22:16:27 <sproingie> ruby 1.8 basically didn't do unicode at all, 1.9 at least standardizes the unicode operations
22:16:28 <djahandarie> copumpkin, http://althack.org/Data-Newtype.html
22:16:53 <sproingie> i'm fine with treating "text" and "string" differently if i have to
22:16:58 <blackdog> sproingie: one thing that i miss heaps in haskell is RVM
22:17:33 <sproingie> eh, i'm used to having so many parallel installs of perl that i don't really need rvm
22:17:37 <blackdog> you can sort of hack it a bit, but it's really helpful to be able to set an environment where you're using a particular version of ruby, along with a particular subset of gems
22:17:39 <djahandarie> I see spelling errors in there but I'll fix it at some later time :P
22:17:41 * djahandarie goes to bed
22:17:43 <sproingie> i use local::lib in perl
22:17:46 <blackdog> (hack it in haskell, i mean)
22:18:02 <sproingie> in python i use virtualenv
22:18:04 <blackdog> sproingie: so you have the problem but you're so calloused it doesn't hurt any more? :)
22:18:08 <ManateeLazyCat> djahandarie: Good dream. :)
22:18:12 <blackdog> i've heard virtualenv is ok
22:18:51 <sproingie> local::lib is basically equivalent to virtualenv
22:19:11 <sproingie> and yes it'd be FREAKING NICE if ghc supported it
22:19:32 <sproingie> does ghc use an environment var to look for packages?
22:20:51 <sproingie> if so then it's just a small tweak away from having the same thing
22:21:43 <blackdog> hm. it does have the -package-database flag
22:21:59 <blackdog> and the GHC_PACKAGE_DATABASE env var
22:22:09 <sproingie> sounds like it'd do the trick then
22:22:55 <sproingie> should be easy to create a local hackage/ dir in the same spirit that i create a local cpan/ dir for my perl projects
22:24:25 <Axman6> isn't that was cabal-dev does?
22:24:31 <blackdog> sproingie: that sounds like an excellent avenue of attack, actually.
22:24:58 <blackdog> Axman6: hm, hadn't really thought of it that way. i guess i should look into it more.
22:26:45 <sproingie> wasn't aware of cabal-dev.  looks like exactly what i'm looking for
22:27:20 <sproingie> i've gotten to the point where i never install anything in site-packages in perl, i only ever use a virgin perl and local::lib
22:28:09 <sproingie> would be terrific to maintain haskell projects the same way
22:31:53 <joe6_> head $ (either (\_ -> []) (\x -> x) (txns :: Either ParseError [ControlTxn])
22:32:00 <joe6_> is there a better way to write the above?
22:34:05 <joe6_> i am just trying to get the  [ControlTxn] without the  "Either ParseError" portion
22:34:44 <Axman6> :t fromEither
22:34:45 <lambdabot> Not in scope: `fromEither'
22:34:51 <Axman6> guess that doesn't exist
22:34:57 <Axman6> @hoogle Either
22:34:57 <lambdabot> module Data.Either
22:34:58 <lambdabot> Prelude data Either a b
22:34:58 <lambdabot> Data.Either data Either a b
22:35:00 <Axman6> urgh
22:35:27 <Axman6> joe6_: \x -> x shouwl be id anyway
22:35:29 <Axman6> should*
22:37:05 <joe6_> Axman6: yes, this worked too: head $ (either (\_ -> []) (id) txns)
22:37:56 <Axman6> wait... you're using head when you are explicitly saying you might produce an empty list? this is a bad idea
22:38:24 <joe6_> Axman6: i could use take instead. it was a sample.
22:38:33 <joe6_> I just want the right portion of either.
22:39:06 <joe6_> something like fromEither. rights of Data.Either seems to work only on arrays.
22:39:10 <Axman6> @hoogle c -> (b -> c) -> Either a b -> c
22:39:10 <lambdabot> No results found
22:39:15 <Axman6> :(
22:39:19 <joe6_> or maybe I could write a function like that.
22:39:23 <Axman6> @djinn c -> (b -> c) -> Either a b -> c
22:39:23 <lambdabot> f a b c =
22:39:23 <lambdabot>     case c of
22:39:23 <lambdabot>     Left _ -> a
22:39:23 <lambdabot>     Right d -> b d
22:45:42 <joe6_> just found Data.Either.Utils fromRight
22:45:50 <joe6_> which  might help
23:21:33 <joe6_> any thoughts on this error: http://hpaste.org/42951/bytestring
23:21:50 <joe6_> GHCi runtime linker: fatal error: I found a duplicate definition for symbol fps_minimum
23:34:14 <sipa> @pl \x -> \y -> f (g x y)
23:34:15 <lambdabot> (f .) . g
23:34:50 <Axman6> or f .: g
23:35:28 * Axman6 thinks it might be nice to have a bunch of operators like that, .: for two arguments to the second function, .:. for three, maybe even .:: for four
23:35:48 <Axman6> though, beyond that i think would be unnecessary
23:36:14 <sipa> @pl \x -> \y -> f $ g >>= \z -> (h $ i x y z)
23:36:14 <lambdabot> ((f . (g >>=) . (h .)) .) . i
23:38:18 <sipa> @pl f $ g >>= \z -> (h $ i x y z)
23:38:19 <lambdabot> f (h . i x y =<< g)
