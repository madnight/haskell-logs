00:05:30 <edwardk> hrmm
00:05:32 <edwardk> looks like
00:06:03 <edwardk> class Functor g => Distributable g where mapW :: Comonad w => (w a -> b) -> w (g a) -> g b; distribute :: Comonad w => w (g a) -> g (w a)
00:06:45 <edwardk> so for its worked for the various right adjoints i've had lying around
00:06:54 <edwardk> er so far
00:07:13 <edwardk> and anything i can give a consistent 'shape' to.
00:07:22 * hackagebot digestive-functors-blaze 0.0.2.1 - Snap backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-blaze-0.0.2.1 (JasperVanDerJeugt)
00:21:37 <Apocalisp_> edwardk: I am translating your "heaps" module to Scala
00:22:09 <edwardk> apocalisp: fun stuff. that package was designed never to be looked at under the hood ;)
00:22:33 <edwardk> its pretty much a straight translation of the 'advanced' section at the end of the paper though
00:24:13 <Apocalisp_> Yeah, the paper has too much caml
00:34:04 <joe6> is there a way to see the hsSyn output of the ghc compilation stage?
00:38:33 * hackagebot comonad 0.6.2 - Haskell 98 comonads  http://hackage.haskell.org/package/comonad-0.6.2 (EdwardKmett)
00:40:53 <Bynbo7> joe6: the what output?
00:41:03 <mreh> :t liftIO
00:41:04 <lambdabot>     Ambiguous occurrence `liftIO'
00:41:04 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
00:41:04 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
00:42:28 <mreh> @bots
00:42:29 <lambdabot> :)
00:42:34 * hackagebot adjunctions 0.2.1 - Adjunctions  http://hackage.haskell.org/package/adjunctions-0.2.1 (EdwardKmett)
00:42:39 <mreh> can't get her to respond in pvtmsg
00:42:42 <joe6> in the compile phase of the ghc, there are different stages.
00:43:35 <mreh> > map succ "Bynbo7"
00:43:36 <lambdabot>   "Czocp8"
00:44:21 <newhaskell> Newbie question: When I load this code into ghci
00:44:24 <Kaidelong> mreh: ":t" doesn't seem to work with lambdabot in private
00:44:32 <Kaidelong> hence why I make a habit of using @ty instead
00:44:33 <newhaskell> data Something a = Something { 
00:44:33 <newhaskell> 	theFunction :: a -> Int
00:44:33 <newhaskell> }
00:44:33 <newhaskell> example :: Something(Int)
00:44:33 <newhaskell> example = Something { theFunction = \(a) -> a}
00:45:10 <newhaskell> I would assume I could use example(5) to return 5.
00:45:52 * Kaidelong wonders if @ty is hardwired or if it is fuzzily matched to @type
00:46:51 <Bynbo7> newhaskell: no, you've just made a new piece of data which has that function in it. you can call `theFunction example 5` and the result will be 5
00:47:34 <newhaskell> wow. never saw that coming.
00:47:48 <Bynbo7> newhaskell: also all the brackets you've used there are unnnecessary. example :: Simething Int; example = Something { theFunction = \a -> a }
00:49:42 <Bynbo7> newhaskell: when you define a datatype using record syntax, it's sort of a little bit like defining a method for an object in OOP languages. for example, if you wanted to get the function out in say java, you would use example.theFunction. in haskell, theFunction is a function which takes a Something, and returns the function inside that Something, so `theFunction example` returns the function inside example
00:49:44 <newhaskell> i see. The portion that is "Something { theFunction = \a -> a }" what is that called - is that a value constructor?
00:50:07 <Bynbo7> yes, you've just created a new value
00:50:21 <Bynbo7> you could also write that as example = Something (\a -> a)
00:50:34 <newhaskell> record syntax, got it.
00:52:44 <newhaskell> yes, I'm very much thinking example.theFunction.
00:54:13 <Bynbo7> when you use record syntax, it defines two things for you: names for each element inside the datatype, and functions which given a piece of data of that type, it will return the element inside that value with the given name
00:54:45 <Bynbo7> it should also probably be noted that records are considered one of the more ugly parts of haskell ;)
00:55:20 <Nereid> eww records :P
00:55:27 <newhaskell> are records common? Is there another way that is preferable?
00:56:27 <Bynbo7> they're not particularly common. the usual way to do things is to just pattern match on the constructors
00:57:52 <newhaskell> that seems like a one to many - what if I had theFunction and theFunction2 listed in the record syntax, is that considered concurrent?
00:58:31 <Bynbo7> what do you mean?
00:58:47 <newhaskell> yeah, when i read that back it didn't come out right
00:58:53 <Bynbo7> heh :)
00:59:33 <newhaskell> my understanding of patterns is that they provide different functions, sort of like a case statement for different input values
01:00:04 <Bynbo7> yes, they are basically the same as case statements (and they get compiled into case statements)
01:00:16 <newhaskell> but if I had theFunction and theFunction2, I could compute two things at once, given the same set of values
01:00:24 <newhaskell> is this correct?
01:00:47 <Bynbo7> no? can you give an example of what you mean?
01:01:08 <Kaidelong> I use records a fair bit when passing around complicate state
01:01:17 <Kaidelong> or record syntax for newtypes
01:02:17 <Veinor> GHCi runtime linker: fatal error: I found a duplicate definition for symbol my_inet_ntoa
01:02:19 <mreh> how am I going to catch an IOException and raise that to ErrorT without going under the hood so to speak
01:02:34 <Veinor> what's this error about then?
01:05:40 <Bynbo7> it means it found two definitions of the C function my_inet_ntoa
01:05:59 <Veinor> oh, it's loading network twice for some reason
01:06:01 <Veinor> that's annoying
01:06:26 <newhaskell> Bynbo7:
01:06:27 <newhaskell> data Something a = Something { 
01:06:27 <newhaskell> 	theFunction :: a -> Int,
01:06:28 <newhaskell> 	theFunction2 :: a -> Bool
01:06:28 <newhaskell> }
01:06:28 <newhaskell> example :: Something(Int)
01:06:28 <newhaskell> example = Something { theFunction = \(a) -> a, theFunction2 = \(a) -> if a>10 then True else False}
01:06:28 <newhaskell> I would assume that I could call 
01:06:29 <newhaskell> theFunction2 example 9
01:06:29 <newhaskell> theFunction example 3
01:06:30 <newhaskell> concurrently. Maybe it has nothing to with concurrency and it's just a list of functions like methods.
01:08:18 <Bynbo7> newhaskell: you don't call functions like that in haskell. if you don't look at their results, they don't do anything
01:09:05 <Bynbo7> `theFunction example 9` by itself doesn't do anything. you need to get its result
01:09:35 <Bynbo7> remember, functions in haskell are like mathematical functions. there's no side effects, they take inputs, and return values, nothing more
01:10:21 <newhaskell> In that case, theFunction example 9 returns False.
01:10:40 <Bynbo7> well, if you meant theFunction2, then  yes
01:10:44 <newhaskell> sorry, theFunction2 .
01:10:47 <newhaskell> lol, yes
01:10:48 <Bynbo7> yup
01:10:56 <Bynbo7> where are you learning haskell from by the way?
01:11:13 <newhaskell> I bought every book that is available on kindle and you.
01:11:29 <newhaskell> even the cheat sheet
01:11:41 <min> I didn't know we could buy people now!
01:11:54 * Bynbo7 feels bought
01:12:08 <newhaskell> I'm having a difficult time getting out of OO. I'm looking for my for loops.
01:12:10 <Bynbo7> newhaskell: i would suggest a different, free source:
01:12:19 <Bynbo7> @where lyah
01:12:19 <lambdabot> http://www.learnyouahaskell.com/
01:12:23 <Bynbo7> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
01:13:10 <shachaf> Bynbo7: You sold out?
01:13:32 * locks is reading lyah
01:13:34 <newhaskell> looks good, thanks. Seems like every book is totally different.
01:13:37 <shachaf> Bynbo7: How much do you think I can get for my #haskell integrity?
01:13:41 <Bynbo7> i was sold, i would never sell out!
01:14:47 <newhaskell> Just playing around, find it interesting that functions in two different types can't be named the same in a module. Would assume that would be a scope within the type.
01:14:51 <min> You can translate for-loops into idiomatic Haskell code, often, but using recursion combinators like maps, folds, and filters. A for-loop confuses these concepts; in Haskell they're distinct.
01:15:40 <Bynbo7> newhaskell: what would the type of the function be then?
01:15:44 <newhaskell> Yeah, that's a really cool concept, one of the reasons I keep going. 
01:15:50 <mauke> newhaskell: how hard would that clash with type inference?
01:15:59 <shachaf> newhaskell: The function *is* of a type. There's no overloading in that sense (becuase of type inference etc.).
01:16:33 <newhaskell> I keep seeing it as <type>.function. can't get it out of my head. 
01:16:40 <Bynbo7> if you have foo :: Int -> String; and foo :: Bool -> Double; and you ask what the type of foo is, what should it return?
01:16:43 <shachaf> newhaskell: However, there are type classes that let you have similar functions.
01:17:09 <shachaf> newhaskell: If you're feeling particularly OOy, ignore any mention anyone makes of "type classes" for a while. :-)
01:18:09 <Bynbo7> ha, how bizzare. i've been reading a C++ tutorial, check the links down the bottom: http://www.4p8.com/eric.brasseur/cppcen.html
01:18:41 <Veinor> Bynbo7: O_o
01:18:53 <newhaskell> I would assume foo is overloaded :)
01:18:58 <min> You can't really do that, though. Even the simplest Haskell functions require knowledge of type classes! Isn't it just about training your mind to think "type class = relation (predicate)"?
01:19:03 <Bynbo7> also, after reading that tutorial, i am feeling much less inclined to start playing with C++
01:19:15 <Bynbo7> newhaskell: but that's not well typed!
01:19:28 <Bynbo7> newhaskell: there is a mechanism for overloading:
01:19:34 <Bynbo7> > show (1 :: Int)
01:19:34 <lambdabot>   "1"
01:19:36 <Bynbo7> > show (1 :: Double)
01:19:37 <lambdabot>   "1.0"
01:19:48 <Bynbo7> > show (True :: Bool)
01:19:49 <lambdabot>   "True"
01:20:00 <Bynbo7> > show ""
01:20:01 <lambdabot>   "\"\""
01:20:26 <Bynbo7> but, i would avoid looking into it for now, or you'll confuse yourself
01:20:33 <newhaskell> ok
01:20:43 <Bynbo7> newhaskell: i strongly suggest you take a look at learn you a haskell for great good
01:20:59 <newhaskell> I'll definitely spend tomorrow diving into that.
01:21:03 <Bynbo7> it might look like a kids book, but it's also an extremely good introduction to haskell
01:21:08 <Bynbo7> excellent :)
01:21:19 <Veinor> BONUS is a pretty awesome guy
01:21:24 <min> LYAH has a tutorial on zippers now? Cool. I wonder what pictures will be conjured up for comonads.
01:21:31 <Bynbo7> i like you, you're willing to learn. we get plenty of people in here who don't seem to want to
01:21:49 * hackagebot comonad 0.6.2.1 - Haskell 98 comonads  http://hackage.haskell.org/package/comonad-0.6.2.1 (EdwardKmett)
01:21:49 <Bynbo7> min: i had no idea really what sippers were until reading that :)
01:21:57 <Bynbo7> it's a fantastic introduction to them
01:22:12 <Veinor> 04:29:11              <min> LYAH has a tutorial on zippers now? Cool. I wonder what pictures will be conjured up for comonads.                                                                                         
01:22:14 <Veinor> 04:29:36                  * hackagebot comonad 0.6.2.1 - Haskell 98 comonads  http://hackage.haskell.org/package/comonad-0.6.2.1 (EdwardKmett)                                                                         
01:22:17 <Veinor> so are you psychic or
01:22:49 * hackagebot comonad-transformers 0.6.5 - Haskell 98 comonad transformers  http://hackage.haskell.org/package/comonad-transformers-0.6.5 (EdwardKmett)
01:22:49 <newhaskell> before i leave, can you explain the call 'theFunction example 5'? Once again, I'm expecting example theFunction 5. Just a framing issue.
01:23:14 <min> No, but certainly clairvoyant.
01:23:37 <mauke> newhaskell: example is not a function; you can't call it
01:23:48 <Bynbo7> newhaskell: the type of theFunction is: theFunction :: Something -> (a -> a) which says it takes a Something and returns a function that takes any a and returns an a
01:23:54 <Bynbo7> actuallt, that's slightly wrong
01:24:10 <Bynbo7> it should be: theFunction :: Something a -> (a -> a)
01:24:22 <shachaf> nelhage++
01:24:30 <Veinor> shachaf: what'd he do now?
01:24:40 <Veinor> oh, reptyr?
01:24:50 <newhaskell> that's where I'm getting in trouble. I thought example was a function of type Something.
01:24:52 <Bynbo7> newhaskell: maybe the implementation of theFunction would help you: theFunction (Something f1 f2) = f1
01:25:04 <shachaf> Veinor: Various things.
01:25:07 <Veinor> ah
01:25:41 <mauke> newhaskell: Something is not a function type (it's not even a type)
01:25:48 <Bynbo7> newhaskell: putting functions inside datatypes can be quite confusing
01:25:58 <mauke> NO, IT CAN'T
01:26:50 * hackagebot adjunctions 0.2.2 - Adjunctions  http://hackage.haskell.org/package/adjunctions-0.2.2 (EdwardKmett)
01:27:56 <newhaskell> So Something is a datatype, which contains the function theFunction. When I assign example, what is that actually doing? I thought the signature said it's of type Something(Int)
01:28:41 <Bynbo7> it is of type Something Int
01:28:49 <mauke> Something(Int) better written as Something Int
01:28:50 <newhaskell> I'm sure this is a basic idea of functional programming that I"m totally missing.
01:28:56 <Bynbo7> (the brackets aren't needed at all)
01:28:57 <mauke> actually, (x) better written as x for all x
01:29:08 <newhaskell> yes, forgot.
01:29:27 <mauke> I wouldn't say it contains theFunction
01:29:33 <newhaskell> hard to break that habit
01:29:39 <mauke> theFunction is a freestanding function whose first parameter is a Something x
01:30:54 <newhaskell> ah. With the syntax it doesn't seem like a freestanding function. I didn't get that.
01:31:24 <newhaskell> Seems to be a composition of Something.
01:35:43 <min> Suppose I have an Applicative instance for (Monoid e) => ((,) e), a (zip) tree, and the composition of both. What property of e's being a monoid would allow me to calculate the depth of a tree composed with an ((,) e) using only the framework provided by Applicative? I can't figure this out.
01:36:02 <newhaskell> Ok, that does help. I see that if theFunction is freestanding, and expects a type of Something Int, then theFunction example 5 does make sense. I'll pound on learnyouahaskell - thanks for all the help.
01:36:18 <mauke> newhaskell: there's less magic here than you may think
01:36:40 <newhaskell> it's pretty mysterious at this point. Can't quite see it.
01:36:52 * hackagebot hjson-query 1.0.2 - library for querying from JSON  http://hackage.haskell.org/package/hjson-query-1.0.2 (YuriyIskra)
01:37:38 <Bynbo7> newhaskell: yeah, do read LYAH and come back to it after records have been covered, and you understand functional programming better
01:38:29 <ivanm> mauke: awwwww....
01:38:30 <ivanm> :p
01:38:38 * ivanm wanted magic!
01:38:44 <Bynbo7> s/do/go
01:44:12 <locks> what fun is anything without magic
01:56:26 <joe6> dreixel: are you around?
01:56:44 <joe6> does anyone know what this does? $(deriveAll ''Test  "PFTest")
01:58:28 <ivanm> joe6: depends on what deriveAll is
01:58:44 <ivanm> but I would hazard a guess that it's a TH splice to derive all instances from some library for the datatype Test
02:00:03 <joe6> just found in regular-0.3.2/src/Generics/Regular/TH.hs
02:00:18 <joe6> ivanm: and your observation is spot on.
02:00:27 <joe6> ivanm: do you have a few mins?
02:01:27 <ivanm> not really
02:01:50 <ivanm> but I would question why you're looking into stuff with generics becaues IIRC you only started learning Haskell recently...
02:02:34 <joe6> ivanm: i have been messing around haskell for more than a few years now.
02:02:44 <ivanm> ahhh, OK
02:02:52 <ivanm> my recollection was wrong then ;-)
02:02:59 <joe6> ivanm: still not an expert, by any means.
02:03:14 <ivanm> *shrug* very few are
02:04:00 <joe6> do you know how to see the output of the different phases of the compilation of a haskell file?
02:05:46 <ivanm> don't think you can
02:05:49 <ivanm> except for the core output
02:05:52 <ivanm> why do you want to?
02:05:59 * hackagebot adjunctions 0.3 - Adjunctions  http://hackage.haskell.org/package/adjunctions-0.3 (EdwardKmett)
02:06:54 <joe6> i want to see how types and data constructors are internally stored.
02:08:00 * hackagebot adjunctions 0.3.1 - Adjunctions  http://hackage.haskell.org/package/adjunctions-0.3.1 (EdwardKmett)
02:08:05 <edwardk> joe6: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage
02:08:30 <edwardk> joe6: as for getting the output of different phases there are compiler flags, one sec
02:09:12 <joe6> edwardk: thanks a lot.
02:09:38 <edwardk> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/options-debugging.html
02:09:57 <edwardk> there are like 50+ -ddump-foo flags in there
02:10:23 <joe6> edwardk: I am going through simonpj's talks to the hackathon to understand the ghc internals. Is that the best out there? or is there anything else better than that?
02:10:45 <edwardk> thats not a bad place to start. another might be with the 'tackling the awkward squad' paper
02:11:10 <edwardk> http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/
02:11:54 <jelly2> i wonder what might be a good way of extending my haskell knowledge without having to think about what for an program to write, so the haskell 99 questions are good for beginners as example?
02:12:44 <Bynbo7> jelly2: project euler is quite good
02:12:48 <jelly2> ok
02:12:53 <jelly2> Bynbo7: i was thinking about that too ;)
02:13:00 <jelly2> and i will get the haskell book
02:13:31 <jelly2> i know the most of haskell except monads, fold(r) 
02:14:03 <joe6> edwardk: thanks.
02:15:23 <Bynbo7> jelly2: if you don;t know those, then you don't really know most of the concepts at all ;)
02:15:36 <Bynbo7> but haskell is something you'll never know everything about
02:15:54 <ivanm> especially foldr
02:16:24 * jelly2 grabs a copy of real work haskell
02:16:26 <jelly2> Bynbo7: yeah
02:16:32 <jelly2> ok you can't know everything
02:16:42 <jelly2> but i never understood foldr and fold
02:17:08 * jelly2 atleast understands his XMonad config :p
02:18:04 * hackagebot json2 0.3 - This library provides support for JSON.  http://hackage.haskell.org/package/json2-0.3 (YuriyIskra)
02:21:21 <edwardk> i need a name for the opposite of a transformer that is short and doesnt suck =)
02:22:09 <edwardk> class Foo t where liftOp :: Comonad w => w a -> t w a — class Bar t where lowerOp :: Monad m => t m a -> m a
02:23:14 <Bynbo7> decepticon
02:23:16 <Bynbo7> >_>
02:23:20 <edwardk> =)
02:23:42 <Bynbo7> if you don;t use that, i will be quite hurt, and you will have lose a very good chance for the haskell community to get some awesome geek cred
02:24:12 <edwardk> but MonadAutobot and ComonadDecepticon are pretty verbose
02:24:14 <ivanm> Bynbo7: I don't know if either of those two rationales are really any good
02:25:37 <edwardk> the best i have so far is like MonadLower and ComonadLift
02:25:55 <edwardk> which is kinda sad because their opposites are both (Co)monadTrans
02:27:11 <edwardk> the other option is (Co)monadContra, with a Control.(Co)Monad.Contra which is a transformer that sandwhiches a (co)monad between an a contravariant (dual) adjunction and flips it to its opposite
02:27:49 <Zao> (known in the EU as (Co)Monad.Probotector)
02:29:53 <Philippa> edwardk: (mylittle)pony?
02:30:01 <edwardk> Philippa:  =)
02:30:13 <Philippa> though there's already a pony package
02:31:55 <xarch> are there examples of cases where adjunctions are useful?
02:32:45 <edwardk> xarch: for various degrees of useful
02:32:58 <edwardk> xarch: you like the state monad don't you? =)
02:33:17 <edwardk> the state monad transformer is also given rise to by an adjunction
02:33:39 <edwardk> all those monads you love, technically each give you (at least one) adjunction
02:35:08 <min> This is a little off topic, but does anyone know where I can find Buchi's paper on MSO and regular languages online?
02:36:31 <xarch> hm yes
02:36:44 <xarch> ok, thanks
02:37:02 <FauxFaux> min: http://www.google.co.uk/search?q=Buchi's+paper+on+MSO+and+regular+languages That one?
02:38:33 <min> Yeah, "Weak Second-Order Arithmetic and Finite Automata." The original is nowhere to be found, and I realy don't want to "library" it.
02:39:19 <edwardk> xarch: at the moment i'm putting together the package to explore ways to build monads out of comonads and vice versa
02:39:44 <edwardk> xarch: its already led to the right insight to finally crack how one should build a dual to traversable
02:40:16 <xarch> hm ok, I'll look at the code then
02:40:25 <edwardk> because left adjoints tend to be traversable and right adjoints tend to be 'cotraversable'
02:43:12 <edwardk> hrmm i'll probably need to migrate in all the kan extension stuff into the adjunctions package as well
02:53:15 * hackagebot haskore 0.2.0.1 - The Haskore Computer Music System  http://hackage.haskell.org/package/haskore-0.2.0.1 (HenningThielemann)
02:55:47 <b0fh_ua> Hi there! Can somebody please explain what is it supposed to do about Partial result from attoparsec? How do I fed the parser with another bytestring?
02:57:10 <Bynbo7> if you get Partial f, then you just use parse f newByteString
02:57:18 <Bynbo7> uh, no
02:57:28 <Bynbo7> sorry, you want feed
02:57:52 <Bynbo7> so, if you get Partial f, then you want to use feed (Partial f) newByteString
03:02:56 * Kaidelong double-takes at Partial here...
03:03:21 <Kaidelong> is this something specific to attoparsec, like a state holding type or something, or is this related to partial values?
03:05:10 <Bynbo7> Kaidelong: it holds a continuation that can take more input and return another Result (Partial meaning it wants more input, Done with the remaining bytestring and the parsed value, or Fail
03:05:16 <Bynbo7> Kaidelong: http://hackage.haskell.org/packages/archive/attoparsec/0.8.3.0/doc/html/Data-Attoparsec.html
03:05:43 <Kaidelong> ah okay so completely unrelated to Conal's partial
03:05:49 <Kaidelong> or mine until I found his
03:27:54 <edwardk> kaidelong: correct, its just attoparsec's way of telling you the parser is capable of accepting more input. it effectively inverts control. with parsec the parser needs all the input up front or you need to have some scary monad interleaved into every parse action
03:28:11 <edwardk> in attoparsec the monad is factored out and is responsible just for feeding the parser huge chunks of text on demand
03:28:30 <edwardk> this is slightly weaker, but potentially way faster
03:29:41 <Bynbo7> Kaidelong: if you're interested, parsec is basically an iteratee (and probably the easiest way of understanding what iteratees do, at least in a basic way)
03:31:10 <Kaidelong> Iteratee? So a scanner or folder?
03:31:27 <Kaidelong> a scan or fold, I should say
03:42:31 * hackagebot adjunctions 0.4.0 - Adjunctions  http://hackage.haskell.org/package/adjunctions-0.4.0 (EdwardKmett)
03:43:31 <b0fh_ua> that's clear, thanks
03:43:50 <b0fh_ua> just now wandering how to debug the parser...
03:43:56 <b0fh_ua> probably with writer monad
03:45:36 <edwardk> my usual mechanism is to write the parser in parsec, then flip over to attoparsec once i have it right
03:45:57 <IanCal> (crosspost from #snapframework) I'm having trouble getting hint-0.3.3.1 with cabal install (GHC 7.0.1 64bit). The error is  Module `DynFlags' does not export `supportedLanguages'. Can anyone replicate this or have I missed something
03:46:57 <b0fh_ua> still not clear about how to debug the parser
03:47:20 <edwardk> well at least with parsec you get 'i expected foo, bar or baz' error messages that work
03:48:03 <aristid> if parsec turns out not to be a performance problem, why not keep it?
03:48:53 <edwardk> mainly because its easier for me to integrate an iteratee based parser into my monoidal parsing pipeline
03:50:40 <Blkt> good day everyone
03:52:00 <Bynbo7> doesn't parsec have some way of tracing it's parsing progress?
03:52:08 <Bynbo7> maybe that's uu-parsinglib
03:52:28 <edwardk> uu-parsinglib is breadth/first maintaining a few possible parses
03:53:00 <edwardk> and has a fairly complicated 'Step' GADT that reifies its internal state
03:53:21 <IanCal> (solved in #snapframework) for anyone finding this in logs, it's a known bug in hint with GHC 7
03:56:43 <ivanm> that's one thing that's a bitch with polyparse: you can tell *which* parser failed (if you gave it an explicit error message), but not where :/
03:57:22 <ivanm> edwardk: _great_ description of your adjunctions package :@
03:57:52 <edwardk> ivanm: i hadn't gotten around to documenting it yet. ;) i needed it for something else ;)
03:57:58 <ivanm> heh
03:58:03 <ivanm> it's almost as good as the "foo - Haskell bindings to the foo library" ones
03:58:23 * ivanm suddenly realises that graphviz's synopsis isn't much better than that
03:58:24 <ivanm> :s
03:58:47 <edwardk> 'graphs' has the tagline 'A simple monaic graph library'
03:58:52 <edwardk> I haven't really added any more ;)
04:00:20 <ivanm> edwardk: "monaic", eh? :p
04:00:29 <ivanm> did you just call it "graphs"?
04:00:31 <edwardk> s/aic/adic/g ;)
04:00:32 <edwardk> yes
04:00:40 <ivanm> I have that projct name reserved on p.h.o already! :@
04:00:48 <edwardk> p.h.o?
04:00:54 <ivanm> projects.haskell.org
04:00:58 <edwardk> oh
04:01:01 <edwardk> sorry
04:01:06 <ivanm> that's the name of the one I've been working on on and off for the past couple of years...
04:01:15 <ivanm> admittedly, I haven't done anything _release-worthy_... :p
04:01:29 <ivanm> (and I was thinking of calling the actual package graph-classes... >_>)
04:01:32 <aristid> edwardk: there are multiple aic there?
04:01:36 <aristid> or why the /g?
04:01:42 <edwardk> reflex
04:01:57 <ivanm> edwardk: should I pull out the "don't call it `fgl' " arguments and say you should really call the package monadic-graphs? :p
04:02:27 <edwardk> ivanm: well, the arguments don't hold here. i'm not trompling a pre-existing hackage package and i carefully avoided the names used by others
04:02:36 * hackagebot graphs 0.3 - A simple monadic graph library  http://hackage.haskell.org/package/graphs-0.3 (EdwardKmett)
04:02:41 <edwardk> (with regards to the namespacing)
04:03:03 <ivanm> I'm still glaring at you!
04:03:04 <ivanm> ;-)
04:03:25 <Veinor> speaking of namespace trampling!
04:03:26 <b0fh_ua> edwardk: the problem is that there
04:03:35 <b0fh_ua> 's no errors
04:03:38 <Veinor> my askitter tramples the Web.Twitter module namespace
04:03:38 <ivanm> edwardk: do you realise that hackage hasn't been able to build versions 0.1 and 0.2?
04:03:42 <ivanm> for a _really_ simple error?
04:03:42 <b0fh_ua> it simply parses things and returns wrong results
04:03:43 <Veinor> since hs-twitter doesn't work any more
04:03:55 <edwardk> it happens. i had a 8 months project underway called parsimony when some minimalist extension to parsec stole my name
04:03:56 <ivanm> edwardk: http://hackage.haskell.org/packages/archive/graphs/0.1/logs/failure/ghc-7.0
04:03:57 <edwardk> ;)
04:04:02 <edwardk> ivanm: yeah
04:04:09 <ivanm> have you fixed that yet?
04:04:11 <edwardk> i just patched the 1 character flaw in the cabal file
04:04:18 <edwardk> that was what this push was
04:04:33 <koala_man> I have a [IO()] and I'd like to execute them on a thread pool. how can I most easily do this?
04:05:10 <ivanm> edwardk: heh
04:05:18 <edwardk> cd
04:05:24 <edwardk> er wrong window
04:05:35 <ivanm> heh
04:05:48 <edwardk> ok. builds now
04:05:56 <ivanm> edwardk: how "usable" is your package now?
04:06:34 <edwardk> ivanm: you can use it for breadth and depth first searches, there are (rather surprisingly) monads for both for combining multiple traversals
04:06:49 <ivanm> how usable is it for an actual graph library?
04:06:59 <edwardk> i have a decent collection of basic graph classes that describe the skeleton of the structure of the boost fgl.
04:07:10 <aristid> edwardk: how usable is it for implementing maximum clique problems?
04:07:11 <ivanm> i.e. do you think your approach will work well enough that I might as well transfer my efforts to annoying you by sending you patches? :p
04:07:17 <edwardk> what i call a graph library and what you call a graph library have very different goals
04:07:25 <ivanm> *nod*
04:07:34 <edwardk> i don't care at all about building new graphs, i care about solving problems on a graph
04:07:52 <luite> what kind of problems?
04:07:53 <edwardk> aristid: haven't ported any of those algorithms yet, but the basic machinery is there to enable you to implement such a solver yourself
04:08:03 <ivanm> edwardk: I currently don't care about building new graphs either; I'm trying to focus on accessign info from pre-existing graph-like types
04:08:09 <ivanm> e.g. to be able to use graphviz on them
04:08:11 <edwardk> luite: reachability, graph isomorphism, etc.
04:08:16 <ivanm> does your approach suit that?
04:08:22 <ivanm> edwardk: how would you do graph isomorphism?
04:08:28 <edwardk> ivanm: yes, thats all it does =)
04:08:35 <ivanm> hmmmmm.....
04:08:40 <edwardk> ivanm: still working on that one, they asked what problems interested   me ;)
04:08:45 <ivanm> ahhh
04:08:46 <luite> I have some very basic graph isomorphism in haskell, but for now, I've used nauty (C) for the more difficult problems
04:09:14 <edwardk> in fact the design was set up so i could manipulate non-enumerable graphs or graphs that had most of their storage offline and had to retrieve it via IO, explicitly so i could tackle distributed graph algorithms
04:09:19 <ivanm> edwardk: well, brendan mckay of nauty fame doesn't really recommend using nauty anymore... he prefers constructing graphs in such a way that they aren't isomorphic to start with :s
04:09:30 <edwardk> heh
04:09:55 <ivanm> luite: I tried porting nauty (from the original paper) since jyp's hgal port is horrendous
04:10:02 <luite> ivanm: hmm, how does he do that?
04:10:15 <ivanm> I'm still tempted to ask brendan (who's my phd supervisor) to relicense nauty so I can write bindings to it
04:10:29 <edwardk> anyways the gist of the library is that a graph is described by a monad, and you're allowed to apply monad transformers to your graph without changing its structure if they are useful to resolving your algorithms
04:10:33 <luite> I know the orderly algorithms, but those still rely on some canonical relabling procedure to determin whether or not to accept a new graph
04:10:49 <edwardk> in fact the identity monad _is_ the empty graph
04:10:53 <ivanm> luite: he calls it 'canonical construction method" or something: I didn't really understand his explanation, but when doing graph expansions you ensure that at each stage your expansion is the canonical one to get to that new graph
04:11:12 <ivanm> luite: right, something along those lines
04:11:13 <edwardk> then i can define things like disjoint unions of graphs using graph-monad homomorphisms 
04:11:16 <luite> ivanm: oh I'm pretty sure I know how it works then :)
04:11:35 <ivanm> he tried to explain it to me using matrices... and I've never done any graph stuff with matrices :s
04:12:34 <edwardk> there is an AdjacencyMatrixGraph class and an AdjacencyMatrix monad in the library for dealing with them matrix style. it exists so i can do things like Floyd-Warshall that really require the full matrix and O(1) edge membership testing
04:12:35 <aristid> ivanm: i'm told that graphs and matrices are really the same thing
04:12:48 <edwardk> aristid: thats one approach to them
04:12:52 <ivanm> edwardk: I'm personally leaning towards the view that you should use per-type specific manipulation functions (i.e. addition and deletion) anyway, since "generic" ones don't work for things like planar graphs, etc.
04:13:00 <aristid> edwardk: but not the one you prefer?
04:13:05 <ivanm> aristid: yeah, but I've never treated them in that fashion
04:13:15 <ivanm> also, there are a few things you can do in one but not the other IIRC
04:13:19 <edwardk> ivanm: yes. thats why every one of my classes is tied to some asymptotic guarantee. don't implement it if you can't meet it
04:13:21 <ivanm> (can't recall what though)
04:13:36 <ivanm> edwardk: *nod* is that guarantee _documented_ yet though? :p
04:13:38 <aristid> ivanm: but sometimes for small graphs, it can make sense to write them down as a (dense) matrix, no? :)
04:13:40 <edwardk> aristid: i'm viewpoint agnostic. i like to keep all my options open until forced =)
04:13:51 <ivanm> aristid: possibly, but I've never done so
04:13:59 <luite> ivanm: hmm, I like the groups and orbits explanation better, at least that's how I explain the method to myself :) you relable the vertices, and you know which vertices are in the same orbit of the automorphism group. now you only need to make sure that the new vertex you add to your candidate graph is in one particular orbit
04:13:59 <aristid> edwardk: lazy viewpoint evaluation :)
04:14:07 <edwardk> ivanm:  actually it is. the sole documentation is a few O(n),  O(v)   O(1)    O(v+e)'s strewn throughout ;)
04:14:20 <ivanm> edwardk: heh
04:14:26 <ivanm> luite: what's an orbit?
04:14:48 <ivanm> edwardk: so, do you mind if I can work out how to do something along the lines I was thinking of witih your approach and send you patches?
04:14:48 <edwardk> ivanm: and when in doubt you can fall back on the boost FGL, because basically the AdjacencyListGraph is a hybrid of the IncidenceGraph and AdjacencyGraph models
04:15:04 <ivanm> edwardk: "boost FGL"? you mean boost graph library?
04:15:07 <edwardk> ivanm: feel free. its sort of a back burner project for me
04:15:07 <luite> ivanm: two vertices are in the same orbit if they can be "mapped onto each other" under the automorphism group.
04:15:24 <ivanm> edwardk: *sigh* does this mean I need to get a github account and learn git? :p
04:15:28 <edwardk> ivanm: yes
04:15:30 <ivanm> luite: ahhh
04:15:35 <edwardk> its easy
04:15:42 * ivanm likes darcs :s
04:15:47 <aristid> ivanm: just do it, you will reap the benefits for a lifetime.
04:15:55 <aristid> github really is huge.
04:16:13 * Bynbo7 <3 github
04:16:14 <ivanm> aristid: how does huge imply good?
04:16:22 <aristid> ivanm: by statistics.
04:16:26 <edwardk> 'git clone git:///....' 'git pull' 'git add' 'git commit -a' 'git push' that takes care of 90% of your usage pattern
04:16:31 <ivanm> aristid: so microsoft is good?
04:16:39 <aristid> ivanm: some of their stuff is.
04:16:54 <edwardk> i fought against moving to git for a couple of years, and now regret it
04:16:59 <Bynbo7> GHC is >_>
04:17:00 <edwardk> (regret that it took so long)
04:17:06 <ivanm> edwardk: yeah, I've tried committing patches to git projects: can't work out how to do darcs-style recordings without explicitly removing some changes :s
04:17:15 <aristid> ivanm: i mean, github has thousands and thousands of projects, you are doing yourself no benefit by ignoring them
04:17:18 <asmund> How would you count the number of occurences of each character in a string, i.e. turn "abaabc" into [('a',3),('b',2),('c',1)]?
04:17:21 <ivanm> aristid: true, I don't mind their ergonomic keyboards...
04:17:22 <Bynbo7> edwardk: and git add -p
04:17:26 <ivanm> Bynbo7: it's MSR, not MS!
04:17:39 <ivanm> asmund: first of all, is this homework?
04:18:00 <asmund> I'm not a student, just curious
04:18:02 * ivanm is suspicious after helping out with too many problems that ended up being homework recently >_>
04:18:04 <ivanm> asmund: OK
04:18:11 <ivanm> in that case: 1) sort your list
04:18:17 <ivanm> 2) group common elements together
04:18:22 <edwardk> ivanm: anyways i wanted the graph library to have something big to try parallelizing through reactor, so its sort of a side-project for me
04:18:25 <ivanm> 3) count number of each element
04:18:28 <luite> anyway, I haven't used those canonical relabeling things very much lately, I made some graph generation programs and hoped that I would be able to use more interesting theory about counting under permutations (polya enumeration) for my project (analysis of some algorithms), but haven't really gotten the results I wanted
04:18:31 <ivanm> edwardk: *nod*
04:18:34 <Bynbo7> > map (head &&& length) . sort $ "abaabc"
04:18:35 <lambdabot>   Couldn't match expected type `[a]'
04:18:35 <lambdabot>         against inferred type `GHC.Types...
04:18:36 <aristid> > map (head *** length) . group . sort $ "abaabc"
04:18:37 <lambdabot>   Couldn't match expected type `([a], [a1])'
04:18:38 <lambdabot>         against inferred type `[...
04:18:40 <Bynbo7> > map (head &&& length) . group . sort $ "abaabc"
04:18:42 <lambdabot>   [('a',3),('b',2),('c',1)]
04:18:45 <ivanm> edwardk: I'll have a look through it next week inbetween talks at linux.conf.au
04:18:46 <aristid> dang.
04:18:59 <ivanm> Bynbo7: stop confusing the newbie witih &&&!
04:19:02 <ivanm> *with
04:19:20 <Bynbo7> > map (\xs -> (head xs, length xs)) . group . sort $ "abaabc"
04:19:22 <edwardk> ivanm: i was mostly amused that i found a monad in my breadth first searches
04:19:22 <lambdabot>   [('a',3),('b',2),('c',1)]
04:19:25 <aristid> i always confuse (&&&) and (***) :D
04:19:30 <asmund> ivanm: thanks! i think that's what i'll go for
04:19:31 <ivanm> and I _was_ trying to get him to look up the functions himself! ;-)
04:19:34 <edwardk> the monad _is_ the visitor object
04:19:44 <ivanm> edwardk: "visitor object"?
04:19:51 <ivanm> I never got patterns...
04:19:57 <ivanm> (if that's what you were referring to)
04:20:02 <Bynbo7> aristid: yeah, i tend to thing of (&&&) as taking one thing, and doing a & b to it
04:20:06 <edwardk> ivanm: https://github.com/ekmett/graphs/blob/master/Data/Graph/Algorithm/BreadthFirstSearch.hs
04:20:12 <edwardk> look at the Bfs data type
04:20:14 <Bynbo7> but, (***) can take the same description i guess
04:20:31 <edwardk> its a set of 4 'callbacks' made by the actual bfs function as it executes
04:20:35 <ivanm> Bynbo7: I consider *** as applying two different functions to a tuple
04:20:43 <ivanm> since I don't tend to use any other arrows
04:20:50 <edwardk> you can override one or all by just extending it, (its defaultable)
04:21:06 <ivanm> edwardk: "grey" and "black" ?
04:21:34 <aristid> :t (***)
04:21:35 <edwardk> common parlance for a vertex still being processed. so a breadth first search that found its way back to a node thats currently in the queue
04:21:36 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
04:21:39 <edwardk> happens when its not a tree
04:21:47 <edwardk> you can ignore them if you don't care about it
04:22:03 <ivanm> @type succ *** read
04:22:04 <lambdabot> forall b a. (Enum b, Read a) => (b, String) -> (b, a)
04:22:14 <edwardk> basically you're returning a result in some monoid, the 'g' there is to allow it to have side-effects
04:22:36 <ivanm> are you still allowing pure graphs?
04:22:37 <Bynbo7> damnit, my laptop needs more mass. Boléro just doesn;t sound right :(
04:22:42 <edwardk> yes
04:22:51 <ivanm> Bynbo7: no, that just means you need better speakers
04:22:58 <edwardk> g is usually just something that looks like Array i [i] -> a
04:23:06 <ivanm> *nod*
04:23:16 <edwardk> but it _can_ be a monad that has an STarray in the environment, and is built over ST
04:23:19 <Bynbo7> uh, yeah, i meant to say my laptop speakers need more bass
04:23:19 <edwardk> or even IO
04:23:20 <edwardk> or STM
04:23:27 * ivanm needs to hit the sack
04:23:29 <Bynbo7> my typing has be horrible lately
04:23:43 <ivanm> edwardk: yeah, I'll have a closer look next week and see what I can come up with
04:23:55 <ivanm> Bynbo7: haven't noticed it becoming any worse...
04:23:59 <edwardk> it is the antithesis of your functional approach
04:24:00 <ivanm> :p
04:24:10 <mgsloan> 'lo all.  In response to the recent posts discussing cabal deps etc, I had an idea that might be rather silly.  What if we included the version in the namespace identifiers?  Eg, import Data.List#1.0.0, etc.  Of course, this doesn't solve the problem posed, but it does allow us to include a bunch of definitions for old versions of the library, implementing the old version's API in terms of the new code.
04:24:11 <Bynbo7> it's always bad, it's just been worse lately
04:24:29 <edwardk> but i just wanted something i could ship code on
04:24:53 <ivanm> edwardk: my approach is just "class Graph g where vertices :: g -> [Vertex g], edges :: g -> [Edge g]", etc.
04:25:12 <ivanm> but I was always wondering about how to deal with monadic graphs as well cleanly (not thinking of forcing it to be a monad)
04:25:23 <edwardk> my graphs don't supply those two functions by default. you hav to be all the way down to VertexEnumerableGraph and EdgeEnumerableGraph to get them ;)
04:25:32 <ivanm> hmmm...
04:25:42 <ivanm> maybe just have a cleaner alias on top of your approach...
04:25:42 <mgsloan> eg, an individual package would be split out into a bunch of different modules each defining a version, all eventually implemented in terms of the original package.  Major versions would be used for redesigns that break the practicality of this scheme
04:25:42 <edwardk> since few useful representations provide them with desirable asymptotics
04:25:50 <ivanm> anyway, I'll see
04:25:55 <ivanm> g'night all
04:25:58 <edwardk> night
04:25:59 <aristid> damn
04:26:02 <aristid> good night
04:26:06 <Bynbo7> night ivanm 
04:26:14 <aristid> @time ivanm
04:26:15 <lambdabot> Local time for ivanm is Sat Jan 22 22:34:07
04:26:21 <edwardk> ivanm: but note in the code there, Dfs, etc. doesn't care at all about those functions, so why cripple yourself by requiring them?
04:26:32 <aristid> ivanm: it's not even that late where you are :P
04:26:39 <edwardk> hence why they are buried down in a fine-grained hierarchy
04:26:42 <edwardk> yeah
04:26:47 <edwardk> where i am is late ;)
04:26:48 <ivanm> edwardk: as a simplistic layer for people starting out!
04:26:50 <edwardk> @time edwardk
04:26:56 <aristid> @time
04:26:58 <lambdabot> Local time for aristid is Sat Jan 22 13:34:49 2011
04:27:02 <aristid> @time edwardk
04:27:04 <ivanm> aristid: well, I'm going to read for a while... and I have to get up earlier than usual tomorrow
04:27:06 <ivanm> *shrug*
04:27:06 <edwardk> ivanm: i don't care about simplistic layers
04:27:12 <aristid> edwardk: you have no time
04:27:12 <edwardk> i care about USABLE layers
04:27:15 <edwardk> nice
04:27:22 <aristid> edwardk: you care about usability? oO
04:27:26 <edwardk> usable for me =)
04:27:28 <ivanm> edwardk: CTCP time is probably blocked for you
04:27:40 <ivanm> edwardk: not everyone can talk about comonads as easily as you can ;-)
04:27:42 <edwardk> meh, its about 7:30 here. i should get some sleep
04:27:47 <aristid> edwardk: you and oleg have no problems using your libraries :)
04:27:50 <edwardk> ivanm: thats why i dualized it
04:27:56 <edwardk> ivanm: and made them monad =)
04:28:00 <edwardk> everyone understands monads!
04:28:10 <ivanm> they do? :/
04:28:20 <edwardk> if not they aren't my target audience =P
04:28:25 <ivanm> edwardk: we need a "a monad is just a graph!" tutorial :p
04:28:37 <ivanm> edwardk: so, apart from yourself, who _is_ your target audience? :p
04:28:41 <aristid> oleg.
04:28:41 <edwardk> i'm officially out of the business of writing random monad tutorials
04:28:59 <c_wraith> what about deterministic monad tutorials?
04:29:02 <ivanm> anyway, I'm off
04:29:19 <edwardk> i work with a bunch of FP guys. if the model works out well here i'll port it to scala and we'll use it at the office
04:29:48 <edwardk> and they are all pretty comfortable with what a comonad is ;)
04:29:51 <aristid> edwardk: do you like scala?
04:30:22 <edwardk> aristid: more than most languages, less than some. its got a fairly adhoc feel to it, which isn't helped by my ability to find all the corners of the language that don't work
04:30:48 <aristid> but less adhoc than c++?
04:30:57 <edwardk> i like that i have higher kinds, i like type level functions. i don't like that i've implemented the untyped lambda calculus in their type system
04:31:50 <edwardk> aristid: its pretty good if you stick to the corners of the language that work
04:32:08 <Twey> Haha
04:32:17 <Twey> Scala has corners that don't work, C++ has corners that work?
04:32:20 <aristid> edwardk: and how does it compare to haskell?
04:32:47 <edwardk> in haskell when i have a problem i assume its my fault. in scala when i have a problem, its a coin flip of whether its my bug, or a compiler bug.
04:33:05 <aristid> so GHC is more solid than scala's compiler
04:33:09 <edwardk> now this mostly comes up because i'm encoding things I can't _say_ in haskell.
04:33:23 <edwardk> for instance in scala i can express the fact that Mu is a subtype of Nu.
04:33:28 <edwardk> because i have subtypes
04:33:46 <edwardk> and because i have subtypes i can make categories take an upper and lower bound for the types in them.
04:33:54 <edwardk> this lets me back into having things like product categories
04:34:09 <edwardk> by saying that the bound is a subtype of a product of the subtypes of two other categories
04:34:15 <edwardk> i can't give that a type in haskell
04:34:21 <aristid> i have the impression that scala is the C++ of functional programming languages: powerful, supports a variety of styles and concepts, but also fairly ad hoc, complex and muddled together
04:34:22 <edwardk> that is pretty flippin cool
04:34:33 <edwardk> this lets me encode a category of categories as a category in scala
04:34:40 <edwardk> in haskell i can't even give that a kind
04:35:10 <edwardk> this makes my bifunctors into ordinary functors between a product category and a category
04:35:52 <aristid> why don't you use scala for everything, then?
04:35:55 <edwardk> contravariant functors are just functors, and you can take a product of a magma and a category in my scala libraries and it all just kind of works
04:35:59 <Twey> Isn't Scala impure?
04:36:19 <aristid> Twey: it's just everything in IO :)
04:36:29 <edwardk> aristid: because a.) its way more verbose, b.) its a lot harder to think in, c.) half the time i have a bug its the compiler's fault, not mine.
04:36:35 <edwardk> twey: yes
04:36:40 <Twey> aristid: >.-
04:37:51 <edwardk> plus, haskell has a way nicer community
04:38:14 <aristid> Twey: i think there is some very strong connection between normal haskell functions and kleisli functions, and if every function is in IO, you get an impure language :D
04:38:17 <edwardk> and a channel that doesn't entirely flip out when i talk about monad homomorphisms
04:38:46 <aristid> edwardk: what is a homomorphism again?
04:39:45 <edwardk> a homomorphism is just an arrow in some category. they compose associatively, and have units. a monad homomorphism is a function between values in two monads, that in a sense preserves the structure of the monad.
04:40:07 <aristid> ah, like a functor but the other way round?
04:40:12 <edwardk> e.g. there are lots of functions from Maybe a -> [a] — but a monad homomorphism would map the unit onto the unit, etc.
04:40:16 <Twey> aristid: That's lovely, but it still means you can't rely on anything being safe :þ
04:40:46 <aristid> edwardk: i.e. hom (return a) = return a?
04:41:05 <edwardk> yeah, and it preserves binds as well
04:41:29 <edwardk> that is a _monad_ homomorphism, there are other structure-preserving homomorphisms as well.
04:41:58 <aristid> Twey: haskell's safety guarantees in some areas are pretty weak too. for example you can't have numbers in a bounded range
04:42:07 <Twey> Yeah
04:42:09 * locks hasn't understood a single word in the last two screens
04:42:16 <edwardk> a graph homomorphism would map a graph into a another way that the connectedness of the graph was preserved, so that it mapes all points onto points such that if there was an edge connecting them, there is one in the target graph
04:42:21 <Twey> But that's an order of magnitude less far-reaching than having everything in IO
04:42:51 <edwardk> in that sense a functor is just a 'category homomorphism' which preserves the connectedness of all of the arrows in your category
04:43:04 <edwardk> sorry locks, i've been told i have that effect
04:43:07 <aristid> edwardk: so a graph homomorphism has to keep the graph itself (if not the labels and the representation) intact?
04:44:04 <edwardk> aristid: correct. it can smash 2 vertices into 1, but if there was a path in the source graph that same path has to exist in the target graph as it maps over each individual edge and vertex, they have to be mapped consistently
04:44:54 <aristid> edwardk: do homomorphisms have to be reversable?
04:44:59 <edwardk> it can't map one edge that ends on vertex 3 and another edge that ends on vertex 3 to edges that don't share an endpoint in the target graph without failing to be a graph homomorphism
04:45:00 <edwardk> no
04:45:38 <edwardk> there are subtypes of them though: http://en.wikipedia.org/wiki/Monomorphism
04:46:43 <edwardk> a 'monic' morphism or monomorphism is basically an injective function, so you could reverse it. epic morphisms are effectively surjective, etc.
04:47:13 <edwardk> i say 'basically' and 'effectively' because the meaning is a bit more subtle, but when applied to the category of sets thats what they are
04:47:54 <aristid> edwardk: what does "smash 2 vertices into one" mean?
04:48:00 <parcs> @hoogle Int -> [a] -> Bool
04:48:01 <lambdabot> Prelude (!!) :: [a] -> Int -> a
04:48:01 <lambdabot> Data.List (!!) :: [a] -> Int -> a
04:48:01 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
04:48:11 <edwardk> x /= y, but f(x) = f(y)
04:48:23 <aristid> edwardk:  i'm a bit confused as to what is allowed and what not, why still being allowed to claim that the structure is preserved
04:49:42 <AnAdorableNick>  \la
04:50:22 <edwardk> in the case of the graph homomorphisms that we've been talking about, i'm going to map vertices onto vertices in the target graph, and i'll map edges onto edges in the target graph such that the function i'm mapping the vertices with, and the function 'm mapping the edges with is consistent. if i take v1 to f(v1) and v2 to f(v2) then i'll take the edge (v1,v2) to (f(v1),f(v2))
04:50:45 <edwardk> and that edge is required to exist in the target graph if it existed in the source graph
04:51:20 <edwardk> i may choose to map 5 vertices onto the same vertex, but i won't break any edges in the process.
04:52:58 <edwardk> aristid: say you have a graph with 6 vertices and 6 edges that looks like a hexagon
04:53:23 <edwardk> i could take two of the vertices on opposite sides of the hexagon and map them onto one vertex in the target graph the new graph looks like a bowtie.
04:53:55 <edwardk> but there exists a graph homomorphism (even one that doesn't introduce multiple parallel edges, or collapse nodes or equire self-edges, etc)
04:54:17 <locks> so, what is all that useful for?
04:54:56 <edwardk> locks: the Functor class in haskell is based on a form of generalization of that theory. graph isomorphism is a hard problem you can base crypto on, etc.
04:55:46 <locks> hmm
04:58:29 <edwardk> locks: and in my case, i'm using them to allow me to embed to smaller graph monads into a larger graph monad
04:59:07 <aristid> edwardk: so all graphs can be converted to a single vertex with an edge to itself, by a homomorphism?
04:59:24 <aristid> at least all graphs with at least one edge
04:59:49 <edwardk> aristid: that would be a perfectly valid homomorphism. in fact there is exactly one such homomorphism for every source graph.  congratulations you've just discovered the concept of a 'terminal object' =)
05:00:06 <aristid> yay
05:00:11 <edwardk> you can even uniquely determine how to map all of the edges of the '0' edge graph onto that one as well
05:00:33 * locks gives aristid the achievement badge
05:00:41 <edwardk> you map all of edges it has to the one edge in your target graph. it doesn't have any, so thats vacuously true ;)
05:00:48 <aristid> thank you for the enlightening explanations, time for lunch :)
05:01:04 <edwardk> the empty graph also has a unique property. it gives you a unique homomorphism TO any other graph
05:01:17 <edwardk> so if you view the homomorphisms as arrows connecting graphs
05:01:47 <edwardk> then the 'initial' empty graph and the terminal 'single node' graph sit at either side of the mishmash of all possible graph homomorphisms
05:02:31 <edwardk> i should get a few hours of sleep
05:02:41 <vex7> sleep is for the weak
05:03:02 <locks> ^
05:03:03 <edwardk> yes, thats why i've been up for the last 36 hours ;)
05:03:10 <vex7> how do you do it?
05:03:34 <edwardk> i gave up sleep when i went back to college at one point, and then when i returned to the real world i never really picked it back up
05:03:37 <locks> graphs dude, they feed you
05:03:52 <edwardk> i just switch topics, i guess it lets other parts of my brain sleep.. like the part that keeps an eye out for typos
05:05:59 <edwardk> ok, bbiab
05:08:59 <Bynbo7> urgh, how do you add documentation to the beginning of a file with haddock, and then also follow it by the first section's title? at the moment i'm using module Foo (\n --$intro \n -- * First section ... but it's eating the first section and not displaying it
05:09:31 <Bynbo7> well, the heading anyway
05:10:15 <Bynbo7> ah, needs a new line, that's all
05:16:32 <Bynbo7> would anyone mind taking a look over this for me and giving me suggestions? https://github.com/axman6/array-utils/blob/master/Data/Array/Util.hs
05:17:06 <Bynbo7> these will hopefully be in GHC 7.2's array library
05:18:34 <Bynbo7> hmm, could probably also add some setAll functions to do things like zero an array
05:19:36 <Bynbo7> though, i guess they're probably a bit redundant
05:52:16 * Bynbo7 sets off a loud firework in the channel
05:53:46 <parcs> does the order of function definitions wrt to pattern matching (i.e. blah [] = ...; blah (x:xs) = ... vs blah (x:xs) = ...; blah [] = ...) affect performance? should i place definitions with more frequent/common pattern matchings before those with less frequent ones, or does it not matter?
05:55:03 * hackagebot array-utils 0.1 - Primitive functions for updating many elements in mutable arrays at once  http://hackage.haskell.org/package/array-utils-0.1 (AlexMason)
05:55:42 <Bynbo7> whoot
05:56:21 <Bynbo7> parcs: i believe that if all constructors are matched they're checked in the order the constructors are defined
05:56:24 <Bynbo7> @src []
05:56:25 <lambdabot> data [] a = [] | a : [a]
05:56:39 <Bynbo7> so, in that example, i think the [] gets checked first
05:56:47 <Bynbo7> not sure if this has changed
05:57:24 <Bynbo7> parcs: but in reality, for most constructors, it's a matter of checking the last 2 or three bits of the pointer to figure out which constructor it is, so it's quite fast anyway
06:24:03 <ill_logic> Hello, I was wondering if somebody could help me with what seems to be a linking error.
06:24:32 <Zao> (try -make, try -package whatever)
06:25:03 <Zao> --make, that apparently is.
06:25:10 <Zao> ill_logic: Ask and see :D
06:25:52 <ill_logic> Zao: Cool, it seemed quiet so I wasn't sure if anybody was around (despite the huge list of people in the room)
06:26:11 <ill_logic> Well the example program from http://hackage.haskell.org/packages/archive/pulse-simple/0.1.12/doc/html/Sound-Pulse-Simple.html is what I'm trying out.
06:26:22 <ill_logic> (I'm still quite new to Haskell)
06:26:31 <ill_logic> I see that it's experimental so maybe this won't be worth it.
06:26:43 <ill_logic> So I installed pulseaudio-dev (ubuntu Lucid)
06:26:48 <ill_logic> cabal install'd pulse-simple
06:27:02 <ill_logic> and i'm getting things like
06:27:06 <ill_logic> (.text+0x46): undefined reference to `pulsezmsimplezm0zi1zi12_SoundziPulseziSimple_simpleWrite_closure'
06:27:18 <ill_logic> hmm....
06:27:38 <ill_logic> so Zao I don't know if the --make answer was targeted toward me, but I guess it somehow fixed it?
06:28:01 <ill_logic> though as long as I asked maybe it's worth knowing what went wrong and how this worked :P
06:28:17 <Twey> ill_logic: --make
06:28:20 <Philonous> ill_logic: ghc doesn't chase package dependencies by default
06:28:22 <Twey> Oh, someone gave it you already
06:28:53 <ill_logic> Yep. Thanks!
06:29:02 <Philonous> ill_logic: --make tells it to link your exsecutable against all the libraries that you import from
06:29:17 <ill_logic> Interesting. So the dependency it wasn't chasing in this case was what, the pulseaudio libs? Not a Haskell package?
06:29:35 <ill_logic> Oh, so you do mean the Haskell package, ok.
06:29:41 <Philonous> ill_logic: No, it was the haskell lib
06:30:10 <Philonous> ill_logic: --make will be (or rather: is) the default behaviour in ghc 7
06:30:53 <ill_logic> Cool, that makes sense. Any good reason ghc6 didn't? Saves time?
06:31:29 <Philonous> ill_logic: I have no clue. Maybe there isn't a convincing reason, that's why they changed it.
06:31:51 <Philonous> Hysterical raisins, probably ;)
06:32:21 <ill_logic> Philonous: Gotcha.
06:49:22 * hackagebot logic-TPTP 0.2.0.6 - Import, export etc. for TPTP, a syntax for first-order logic  http://hackage.haskell.org/package/logic-TPTP-0.2.0.6 (KiYungAhn)
06:53:23 * hackagebot logic-TPTP 0.2.0.7 - Import, export etc. for TPTP, a syntax for first-order logic  http://hackage.haskell.org/package/logic-TPTP-0.2.0.7 (KiYungAhn)
07:03:46 <brooksbp> hello
07:04:13 <brooksbp> if I have an abstract machine, and a type system.  How can I proof they are similar
07:04:30 <brooksbp> err
07:05:28 <brooksbp> if I have an abstract machine that implements some language with syntax XYZ, and a separate type system based on syntax XYZ, how can i proove their equivalence
07:15:13 <dhragon> wtf is this?
07:15:19 <dhragon> anyone?
07:16:52 <Bynbo7> -_-
07:18:42 <kuffaar> http://siyobik.info/index.php?module=pastebin&id=573  <- "Unexpected semi-colons in conditional" Perhaps you meant to use -XDoAndIfThenElse? What did I do wrong there? I was already noticing that haskell-mode failed to parse my code so it would no longer indent stuff probably, didn't manage to figure out the error though, but it has something to do with the if statement starting on line 67
07:19:21 <mauke> haskell doesn't have an if statement, which is part of the problem
07:19:30 <mauke> you're in a do block
07:19:35 <aristid> :t fix join
07:19:37 <lambdabot>     Occurs check: cannot construct the infinite type: a = m a
07:19:37 <lambdabot>       Expected type: m (m a)
07:19:37 <lambdabot>       Inferred type: m a
07:19:53 <kuffaar> mauke what do you call it?
07:20:00 <kuffaar> if function?
07:20:00 <mauke> every line that starts at the same indentation level as the token after do (which is 'let' in line 51) is the start of a new statement
07:20:01 <Philonous> kuffaar: else has to be indendet at least one step more than the accompanying if 
07:20:09 <mauke> if expression
07:20:32 <mauke> that means it's parsing "if DB.null clientData then ..." and "else ..." as two separate statements
07:20:33 <kuffaar> Philonous: Oh
07:21:06 <Botje> kuffaar: put the then on a line by itself, indented wrt the if
07:21:14 <Botje> put the else at the same indentation level
07:21:30 <kuffaar> Philonous: https://github.com/epicvrvs/Knyaz/blob/master/Source/Knyaz/String.hs then why does this even compile?
07:21:37 <kuffaar> The else is always on the same level as the if
07:21:44 <kuffaar> And ghc 7 didn't compile
07:21:48 <kuffaar> And ghc 7 didn't complain*
07:22:02 <Bynbo7> kuffaar: you don't have an else for your last if
07:22:18 <mauke> kuffaar: there is no 'do' here
07:22:22 <Bynbo7> oh yes you do
07:22:41 <kuffaar> mauke: Does if behave differently in do and non do blocks?
07:22:45 <mauke> kuffaar: the whole function definition is one statement, with the body being free-form
07:22:51 <kuffaar> Yes
07:22:54 <mauke> kuffaar: what's a non-do block?
07:23:00 <kuffaar> readMaybe, mauke
07:23:07 <mauke> that's not a block
07:23:32 <kuffaar> mauke: Does if behave differently in do and non do bodies*?
07:23:35 <kuffaar> Happy? :p
07:23:42 <mauke> no
07:23:48 <mauke> "body" is irrelevant
07:24:05 <mauke> indentation matters only in layout mode
07:24:15 <mauke> layout is triggered by "where", "do", "let", "of" ... anything else?
07:24:16 <kuffaar> What is "layout mode"?
07:24:34 <mauke> that's where haskell looks at the indentation of your code to determine the meaning
07:24:57 <mauke> it's optional, btw
07:25:03 <kuffaar> So in general you're always supposed to have the then on its own line, with both the then and the else being at +2 spaces from the if?
07:25:06 <mauke> you can write everything with { } instead
07:25:30 <mauke> dunno, I don't do that
07:26:52 <marred> Hi all, for type like data Wrap a = Wrap a I need a function with signature like extract::(Wrap a -> a)-> (Wrap (Maybe b), Wrap b)-> b
07:27:06 <Kaidelong> IIRC the rule is the same as in the MLs and is quite simple
07:27:28 <Kaidelong> one space worth of whitespace is enough but things have to align correctly
07:27:58 <marred> I can't do it because type system requires first param not to be polimorfic
07:28:25 <mauke> marred: extract _ (_, Wrap x) = x
07:28:36 <Bynbo7> @djinn (Identity a -> a) -> (Identity (Maybe b), Identity b) -> b
07:28:37 <lambdabot> Error: Undefined type Identity
07:28:41 <Bynbo7> :(
07:28:59 <Bynbo7> @djinn (Sum a -> a) -> (Sum (Maybe b), Sum b) -> b
07:28:59 <lambdabot> Error: Undefined type Sum
07:29:00 <Kaidelong> marred: pfft~ turn off the monomoprhism restriction. It's useless. Alternatively, do a type annotation
07:29:02 <mauke> @djinn-add data Identity a = Identity a
07:29:10 <Bynbo7> @djinn (Identity a -> a) -> (Identity (Maybe b), Identity b) -> b
07:29:10 <lambdabot> f _ (a, b) =
07:29:11 <lambdabot>     case a of
07:29:11 <lambdabot>     Identity c -> case c of
07:29:14 <mauke> Kaidelong: huh?
07:29:26 <Kaidelong> Oh
07:29:33 <Kaidelong> polymorphic ARGUMENT not allowed?
07:29:39 <marred> I would need extract f (ma a) = fromMaybe (f ma) (f a)
07:29:47 <kuffaar> I suppose the regular way is if a\n  then b\n  else c
07:29:58 <kuffaar> Need to update plenty of ifs then :[ I liked my own form much better
07:29:59 <Kaidelong> well it could still be the monomorphism restriction if it is at the top level without an annotation
07:30:04 <lars9>  @src error
07:30:16 <Kaidelong> if the result type is somehow inferred from the argument
07:30:25 <mauke> kuffaar: extract :: (forall b. Wrap b -> b) -> (Wrap (Maybe a), Wrap a) -> a
07:30:34 <lars9> lambdabot: hi there?
07:30:39 <lars9>  @src error
07:30:42 <mauke> @botsnack
07:30:42 <kuffaar> mauke: You are confusing marred and me, I think
07:30:42 <lambdabot> :)
07:30:49 <mauke> indeed I am
07:31:04 <mauke> kuffaar: but it's worse! I'm also tab-confusing you and Kaidelong 
07:31:22 <mauke> lars9: space
07:31:38 <kuffaar> My haskell-mode is putting then and else on the same indentation level as the if before it
07:31:42 * kuffaar is puzzled
07:31:46 <lars9> @src error
07:31:46 <lambdabot> error s = throw (ErrorCall s)
07:31:47 <Kaidelong> I'm confusing everything
07:31:51 <lars9> @src throw
07:31:52 <lambdabot> throw exception = raise# exception
07:31:57 <Kaidelong> the guy wants a type signature that is not allowed or something?
07:32:01 <lars9> @src raise#
07:32:01 <lambdabot> Source not found. Where did you learn to type?
07:32:07 <lars9> @src "raise#"
07:32:07 <lambdabot> Source not found. Just try something else.
07:32:31 <mauke> Kaidelong: 'extract' can't be written in Haskell 98
07:32:35 <mauke> Kaidelong: you need a rank-2 type
07:33:07 <Kaidelong> mauke: the signature he wrote looks possible
07:33:18 <Kaidelong> but perhaps that's not the signature that is actually wanted here?
07:34:44 <marred> This is the function that I need: extract f (ma,a)= fromMaybe (f a) (f ma) 
07:34:47 <kuffaar> Isn't stuff after <<let blah = blah in>> supposed to be indented more than the let?
07:34:57 <marred> mauke said that i can not be done in Haskell 98
07:35:06 <kuffaar> haskell-mode only adds a single indentation space if I put the in on its own line
07:35:06 <mauke> marred: but I also told you how to do it
07:35:10 <mauke> well, I told kuffaar
07:35:17 <kuffaar> Haha
07:35:19 <mauke> but same thing
07:35:39 <mauke> kuffaar: I'd say no
07:35:50 <mauke> kuffaar: if you're not in a block, indentation doesn't matter
07:35:57 <kuffaar> Oh ok
07:35:59 <mauke> kuffaar: if you're in a do-block, why are you using let .. in?
07:36:06 <kuffaar> Well I'm not
07:39:38 <kuffaar> Apparently haskell-mode intentionally uses different indentation levels for if expressions in blocks hmm
07:39:53 <kuffaar> Outside of blocks they're all the same indentation (if, then, else)
07:40:08 <kuffaar> In blocks, then/else are indented after the if
07:40:17 <kuffaar> That seems rather incosistent :[
07:41:38 * hackagebot TernaryTrees 0.2.0.2 - Efficient pure ternary tree Sets and Maps  http://hackage.haskell.org/package/TernaryTrees-0.2.0.2 (AlexMason)
07:42:00 <Bynbo7> hooray
07:43:41 <kuffaar> Getting "Segmentation fault/access violation in generated code" 20% of the time when I use cabal-install, this is really annoying
07:46:52 <kuffaar> dcoutts why does it do that? :'(
07:47:22 <Bynbo7> which OS?
07:47:31 <kuffaar> Windows 7
07:47:50 <kuffaar> cabal-install version 0.9.5
07:47:50 <kuffaar> using version 1.10.0.0 of the Cabal library
07:47:54 <Bynbo7> what's segfaulting?
07:48:07 <kuffaar> cabal install randomly segfaults
07:48:13 <kuffaar> No matter what Haskell project
07:48:17 <Bynbo7> have you tried updating it?
07:48:27 <Bynbo7> cabal install cabal-install
07:48:28 <kuffaar> I am on the darcs HEAD pretty much
07:48:34 <Bynbo7> :\
07:48:40 <kuffaar> Bynbo7 this version isn't even on Hackage
07:48:53 <kuffaar> http://hackage.haskell.org/package/cabal-install
07:48:56 <kuffaar> 0.8.2
07:49:15 <kuffaar> It's nearly one year old ^
07:50:25 <marred> mauke: didn't understand at first, but now it's working. thanx
07:51:39 <Bynbo7> kuffaar: they're pretty strongly tied to GHC versions for a reason
07:51:46 <BlubbTec> hello there, i'm wondering where i have to place my .ghci file under windows 7
07:52:01 <kuffaar> BlubbTec depends on when you want to have it executed, I think?
07:52:11 <kuffaar> %USERPROFILE%\.ghci if you want it to be global
07:52:37 <kuffaar> Most UNIX ports translate ~ to %USERPROFILE%
07:52:49 <kuffaar> i.e. C:\Users\<blah>
07:52:55 <BlubbTec> yeah, thanks
07:53:06 <BlubbTec> it wont let me create a .ghci file though -.-
07:53:32 <kuffaar> Yes, that's because the Windows explorer sucks
07:53:40 <kuffaar> cmd into it and make something like uh
07:53:46 <kuffaar> Create a file called ghci first
07:53:55 <kuffaar> Then go "rename ghci .ghci" in the prompt
07:54:24 <BlubbTec> yes that worked, thanks a lot :D
07:54:32 <kuffaar> Cheers
07:55:40 <kuffaar> package HTTP-4000.0.10 requires network-2.2.1.10
07:55:40 <kuffaar> package cabal-install-0.9.5 requires network-2.3
07:55:41 <kuffaar> Nice.
07:56:59 <ill_logic> Getting a newbie type error I don't understand. Could somebody explain this? http://pastebin.com/VcC5EDN6 Error/confusion described in comments.
07:57:22 <kuffaar> http://hackage.haskell.org/package/HTTP-4000.1.1 <- what is up with these version numbers anyways?
07:57:31 <mauke> ill_logic: samplingRate is not a function
07:57:47 <mauke> ill_logic: also, the problem is the monomorphism restriction
07:57:50 <Heffalump> kuffaar: no idea :-) (I maintain HTTP, but the previous maintainer chose the scheme)
07:58:18 <mauke> ill_logic: possible fix: samplingRate :: (Num a) => a
07:58:54 <Igloo> It's because it used to use a date as a version number
07:58:56 <kuffaar> mauke: How is it not a function?
07:59:03 <mauke> kuffaar: it takes no arguments
07:59:06 <Heffalump> kuffaar: HTTP doesn't have any explicitly versioned deps on network (which is actually bad practice, but quite often convenient)
07:59:07 <kuffaar> So what?
07:59:14 <mauke> kuffaar: so it's not a function
07:59:23 <ill_logic> I was taught that everything is a function in Haskell
07:59:29 <mauke> ill_logic: you were taught wrong
07:59:36 <hatds> everything is a *value*
07:59:41 <ill_logic> And even if you call it a constant, you could do the same multiple inferencing that way too right?
07:59:45 <kuffaar> Well, it isn't in the mathematical sense hmm true
07:59:48 <mauke> ill_logic: yes
08:00:06 <kuffaar> Heffalump I wonder why it claimed it did in this case then
08:00:14 <kuffaar> claimed to*
08:00:20 <ill_logic> well let's try the fix...
08:00:22 <kuffaar> It also used an old version of HTTP hm
08:00:36 <ill_logic> cool that seemed to work, at least in the test example. thanks!
08:00:36 <Maxdamantus> If you were modelling the semantics of Haskell in a language with strict-semantics, you'd probably implement every value as being obtained via a function.
08:01:03 <Maxdamantus> (but you don't have to)
08:01:04 <BlubbTec> ok, so i want to use jedit to pop up when i use :e and created a jedit.bat in system32 that runs jedit.. however, setting :set editor "C:\\Windows\\System32\\jedit.bat" doesn't work
08:01:11 <BlubbTec> (in ghci=
08:01:16 <kuffaar> mauke: What do you call it then?
08:01:29 <mauke> kuffaar: what, numbers? I call them numbers
08:01:43 <ill_logic> mauke: so what did that do exactly? gave samplingRate the typeclass Num?
08:01:43 <kuffaar> You call samplingRate a number?
08:02:01 <alpounet> samplingRate is a (constrained) polymorphic value
08:02:23 <mauke> ill_logic: override the monomorphism restriction so samplingRate takes on 44100's type instead of being forced to a single concrete type
08:02:27 <mauke> kuffaar: yes
08:02:45 <kuffaar> And you call blah :: IO () an IO action?
08:02:52 <ill_logic> mauke: cool. i'll look up "monomorphism restriction" then
08:02:55 <mauke> kuffaar: yes
08:02:56 <elitheeli> Is there a more concise way to get a function that subtracts one from its input than "((-1)+)"? Obviously "(-1)" is the number, not a function
08:03:04 <mauke> elitheeli: subtract 1
08:03:04 <hatds> without "NoMonomorphismRestriction" enabled, the compiler essentially tries to avoid giving samplingRate the type (Num a) => a by choosing one particular a (e.g. a=Int)
08:03:11 <kuffaar> And as soon as either of those take an argument you no longer call them a number or an IO action? Then you call them functions?
08:03:13 <elitheeli> mauke: that's more characters
08:03:18 <mauke> elitheeli: and?
08:03:33 <mauke> kuffaar: ... yes?
08:03:34 <elitheeli> I was looking for more concise, not more readable
08:03:39 <Bynbo7> :t (-1+)
08:03:41 <lambdabot> forall a. (Num a) => a -> a
08:03:42 <kuffaar> Oddball :o
08:03:46 <mauke> elitheeli: it's fewer tokens, so more concise
08:03:52 <elitheeli> Bynbo7: thanks
08:04:02 <mauke> kuffaar: do you know any other programming languages?
08:04:06 <kuffaar> Yeah
08:04:32 <mauke> then I don't see what's so surprising
08:05:07 <kuffaar> Actually I agree with you
08:05:26 <kuffaar> BlubbTec: You want to use ghci to launch an editor?
08:06:37 <juhp> what is bin-package-db used for?
08:07:47 <BlubbTec> kuffaar yeah i want :edit to open up my .hs file in another editor
08:08:04 <BlubbTec> it uses notepad by default, which isnt quite what i want
08:09:53 <kuffaar> Notepad is horrid
08:10:35 <BlubbTec> yeah, that is why i want to use jedit, but i cant get it to work, lol
08:10:47 <kuffaar> BlubbTec well what's the error you get?
08:10:47 <systemfault> what? notepad is perfect.
08:10:54 <systemfault> It's just not a programmer tool.
08:11:24 <kuffaar> Perfect? It doesn't even interpret \n as a newline
08:11:25 <mauke> notepad is far from perfect :-|
08:11:26 <kuffaar> It's useless
08:11:41 <BlubbTec> it tells me that the file or command i tried to run doesn't exist
08:11:46 <mauke> yeah, line endings and encodings :-(
08:11:50 <BlubbTec> standard cmd error when you try to run something that doesnt exist
08:12:09 <kuffaar> BlubbTec have you tried debugging it to see what file it opens?
08:12:21 <kuffaar> Using OllyDbg, for example?
08:12:27 <kuffaar> (assuming you have 32-bit binaries)
08:12:39 <BlubbTec> kuffaar no, didnt do that
08:13:40 <kuffaar> Attach a debugger to ghci.exe and add a breakpoint of CreateProcessEx
08:13:48 <Saizan> maybe the .exe is not in your %Path% ?
08:13:50 <BlubbTec> ahh i got it
08:14:03 <BlubbTec> actually it tries to access SysWOW64, and not system32
08:14:05 <kuffaar> Saizan he uses an absolute path
08:14:13 <kuffaar> BlubbTec: system32 is the AMD64 directory
08:14:20 <kuffaar> SysWOW64 is the IA-32 directory
08:14:40 <Saizan> so they inverted them=
08:14:42 <Saizan> ?
08:15:07 <kuffaar> Saizan something like that, it's very confusin
08:15:22 <kuffaar> breakpoint on*
08:15:35 <BlubbTec> ok, now it finds my bat/.lnk, but the file it references to in my programfiles dir cannot be opened by java.
08:15:41 <BlubbTec> cause jedit executable is a .jar file
08:16:09 <kuffaar> And the thing is, when you execute stuff in the system directories it actually performs some translation sometimes
08:16:10 <maurer_> BlubbTec: Use ":set editor" in ghci
08:16:17 <kuffaar> maurer_: They are
08:17:12 <kuffaar> BlubbTec I wouldn't try to put the bat/cmd anywhere close to the Windows directory btw
08:17:40 <BlubbTec> yeah, ima just put it into C:
08:17:45 <maurer_> Eh. This is one of the many reasons I stay away from windows. Nothing has a properly configured command line unless you write one for it.
08:18:47 * hackagebot convertible-text 0.3.0.9 - Typeclasses and instances for converting between types  http://hackage.haskell.org/package/convertible-text-0.3.0.9 (MichaelSnoyman)
08:19:04 <BlubbTec> ok, my .lnk file references to C:\Program Files\jEdit
08:19:16 <kuffaar> A .lnk? Wtf
08:19:27 <BlubbTec> which is, when i use :edit interpreted as C:\Program Files(x86)\jEdit
08:19:27 <kuffaar> .l 
08:19:34 <BlubbTec> yeah, a .lnk file
08:19:44 <kuffaar> .lnk is an extension specific to the Windows explorer, no?
08:19:48 <BlubbTec> yes
08:19:51 <Twey> Windows shortcuts
08:19:54 <BlubbTec> yep
08:20:21 <kuffaar> Wait, can you actually call CreateProcess on that?
08:20:36 <BlubbTec> yeah, it works
08:20:39 <kuffaar> :O
08:20:51 <maurer_> You have NTFS, no? Stop using the old hacks and just use a proper symlink :/
08:21:02 <kuffaar> Yeah I use symlinks all the time, on NTFS
08:21:12 <BlubbTec> how do you create them in windowS?
08:21:15 <BlubbTec> is it built in?
08:21:15 <kuffaar> mklink
08:21:17 <kuffaar> Yes it is now
08:21:19 <maurer_> mklink
08:21:29 <maurer_> Yeah.
08:21:30 <kuffaar> But the target/link order was reversed I think
08:21:36 <kuffaar> In comparison to ln
08:22:43 <Bynbo7> ooo, wolframalhpa API, that could be fun
08:23:57 <BlubbTec> ok, mklink worked, but how can i now "execute" using that link i just created?
08:24:06 <BlubbTec> i linked jedit to "C:\...\jedit.jar"
08:24:48 <kuffaar> BlubbTec you can't run CreateProcessEx on a jar
08:25:05 <kuffaar> You need to run it on java.exe or javaw.exe which in turn loads the jar
08:25:31 <kuffaar> By passing it in the class load path and then specifying the correct entry point
08:25:34 <BlubbTec> well, not even windows explorer can run symlinks
08:25:50 <kuffaar> It can afaik
08:26:00 <kuffaar> I open symlinks occasionally
08:26:07 <BlubbTec> lol, doesnt work for me then
08:26:19 <BlubbTec> but ghci can run java
08:26:42 <kuffaar> Wait, but you can ShellExec a jar
08:27:16 <BlubbTec> that means?
08:27:26 <BlubbTec> :set editor "java -jar C:\\Program Files\\jEdit 4.3.2\\jEdit.jar"
08:27:33 <kuffaar> Right
08:27:36 <BlubbTec> this actually gives me a "unable to open jar C:\Program"
08:27:39 <mauke> doesn't that need more quotes?
08:27:48 <kuffaar> Lacks quotes yeah
08:27:51 <BlubbTec> yeah, but i don't know which ones
08:27:56 <mauke> double quotes
08:28:00 <BlubbTec> ' thesE?
08:28:04 <mauke> no
08:28:08 <kuffaar> :set editor "java -jar \"C:\\Program Files\\jEdit 4.3.2\\jEdit.jar\""
08:28:12 <kuffaar> I would have guessed that
08:28:13 <BlubbTec> ahh
08:28:45 <BlubbTec> lol
08:28:52 <BlubbTec> unable to access jarfile "C:\Program
08:29:00 <mauke> haha
08:29:07 <mauke> foiled
08:29:25 <mauke> do 8.3 names still exist/
08:29:36 <BlubbTec> ?
08:29:37 <mauke> PROGRA~1, etc
08:29:40 <BlubbTec> ah
08:29:43 <BlubbTec> guess they still work
08:29:50 <kuffaar> It's amazing how many programs developed for UNIX likes fail when there's a space in the path btw
08:30:13 <kuffaar> Lots of coders never even consider that case
08:30:20 <mauke> huh. I've never had that problem
08:30:34 <sipa> the only problem really is shells :)
08:30:35 <hatds> it seems impossible to figure out how you are supposed to create your strings in these situations
08:30:38 <mauke> newlines in filenames, yes; but not with spaces
08:30:57 <BlubbTec> can i escape whitespaces?
08:31:06 <kuffaar> Try 
08:31:12 <kuffaar> Try "\ " perhaps
08:31:17 <BlubbTec> and what about C:\jedit where jedit is a symlink?
08:31:25 <sipa> seems here that ghci tries to parse that editor string itself into commandline arguments
08:31:25 <BlubbTec> well should be \\ then
08:31:30 <hatds> I might try using single quotes for the inner quotes
08:31:36 <sipa> instead of passing it to a shell
08:32:01 <mauke> shells are mostly irrelevant here
08:32:06 <BlubbTec> unable to access jarfile 'C:\Program
08:32:10 <mauke> windows programs receive a single command line arg and parse it themselves
08:32:45 <kuffaar> BlubbTec do you know how to use OllyDbg?
08:32:49 <kuffaar> Or WinDbg?
08:32:57 <mauke> whoa
08:33:00 <kuffaar> What
08:33:10 <BlubbTec> no, why?
08:33:11 <mauke> that seems excessive
08:33:22 <mauke> why not use 8.3 names?
08:33:29 <kuffaar> mauke it helped me to figure out an issue with a HackageDB lib the other day
08:33:33 <kuffaar> (network 2.3)
08:33:50 <BlubbTec> YES
08:33:52 <BlubbTec> got it to run
08:33:57 <BlubbTec> using a C:\jedit symlink
08:33:58 <kuffaar> PROGRA~1 still works btw
08:34:16 <BlubbTec> then using :set editor "java -jar C:\jedit"
08:34:23 <kuffaar> Yeah
08:34:45 <hatds> I wonder what the problem was and if there was a standard solution
08:35:17 <kuffaar> Maybe it provides no way to encode " in that string?
08:35:40 <BlubbTec> now this crashes jedit after startup.
08:35:40 <hatds> 'it' being java?
08:35:56 <kuffaar> lol
08:36:12 <BlubbTec> jedit says docs/tips directory couldnt be found, it has one of those "show tips at startup" features
08:36:33 <hatds> working directory problem maybe?
08:36:35 <kuffaar> BlubbTec: Because the CWD is wrong?
08:36:55 <kuffaar> Make a cmd file to launch it using the start command
08:37:11 <kuffaar> The syntax was strange, I think
08:37:37 <BlubbTec> start /B
08:37:54 <hatds> imagine what would be required to fully document what is actually going on so a person could in principle read the documentation and have it work the first time
08:37:55 <kuffaar> start /d "directory where jedit.jar resides" java <arguments to be passed to java>
08:38:19 <BlubbTec> ahh
08:38:20 <BlubbTec> kk
08:38:36 <BlubbTec> gonna use a smylink for that aswell.
08:38:37 <hatds> so "start" sets a CWD?
08:38:43 <BlubbTec> it can
08:38:47 <kuffaar> hatds yeah I think it can
08:39:26 <hatds> what else does 'start' do?  why would you use it instead of just calling the program?
08:39:47 <kuffaar> hatds: It's like blah &
08:39:58 <kuffaar> But the csrss shell has no &
08:39:59 <hatds> don't know what that means
08:40:04 <kuffaar> Oh
08:40:09 <Twey> It lets you control how the system interacts with the program
08:40:16 <BlubbTec> ok, now jedit runs
08:40:22 <kuffaar> It launches a background process instead of blocking until it terminates
08:40:23 <Twey> You can start it minimised, wait until it's finished, carry on in the background, &c.
08:40:25 <BlubbTec> however, when i do :e test.hs
08:40:37 <BlubbTec> it opens test.hs in the jedit directory
08:40:44 <kuffaar> Nice
08:40:46 <Zao> Have you Java slackers considered using -blah or some other off-topic channel to do your troubleshooting?
08:40:46 <BlubbTec> and i doubt that is where ghci wants it.
08:40:55 <Twey> Heh
08:41:11 <kuffaar> Zao: No.
08:41:24 <kuffaar> BlubbTec: Why are you even trying to hard to use ghci :e?
08:41:26 <hatds> I don't know, getting things like this to work is a common haskell problem for some
08:41:30 <kuffaar> I've never even heard of it before
08:41:39 <hatds> well windows users at least
08:42:06 <kuffaar> I use ghci to test small stuff only
08:42:11 <BlubbTec> kuffaar yeah, i guess after its loaded once, i will simply keep jedit open and do :r
08:42:14 <Zao> I'd except that most people use editors that do not try to look in the CWD for their data files.
08:42:14 <kuffaar> And I use emacs for editing the code
08:42:58 <hatds> it's not about the editor, it's about understanding how to use the various apis for calling programs
08:44:30 <kuffaar> And I just open the files in the Windows explorer, by double clicking them
08:45:35 <hatds> everyone does, but it's not really a choice (because of stuff like this)
08:46:59 <BlubbTec> okay, how can i delete a symlink? lol
08:47:03 <kuffaar> Ahh, the darcs cabal-install has an old constraint
08:47:09 <kuffaar> BlubbTec: Just del
08:47:12 <kuffaar> HTTP     >= 4000.0.2 && < 4001,
08:47:20 <BlubbTec> it asks me if i want to delete c:\ghcidir\*
08:47:27 <kuffaar> D:
08:47:32 <BlubbTec> yes.
08:47:50 <kuffaar> BlubbTec when you remove it in the explorer it should just remove the symlink, I thinkp
08:47:59 <kuffaar> I thought del removed the symlink only hmm
08:48:12 <BlubbTec> no
08:48:33 <monochrom> command line? explorer?
08:49:00 <kuffaar> Wait, that constraint is up to date
08:49:08 <kuffaar> The latest one is 4000.1.1
08:49:18 <kuffaar> Then why does it try to install 4000.0.10?
08:49:29 * kuffaar shrugs helplessly
08:49:34 <BlubbTec> neither command linke nor explorer
08:50:01 <BlubbTec> now it opens the file in the ghci-directory
08:50:07 <BlubbTec> but cant save it, due to limited access
08:50:09 <kuffaar> Ah I don't need to use bootstrap.sh anymore
08:50:25 <BlubbTec> if i run ghci as administrator, however, it looks for the .ghci in another path
08:50:27 <BlubbTec> ...
08:50:35 <kuffaar> :D
08:51:20 <kuffaar> If you have only one account and you just raise the privilege level through runas/UAC it should still have the same %USERPROFILE% path though
08:51:39 <BlubbTec> i ran cmd as administrator
08:52:51 <kuffaar> Yeah in my case the path stays the same
08:53:44 <Heffalump> kuffaar: that's a bizarre constraint, it's got an upper bound that doesn't rule out incompatible changes
08:53:45 <Bynbo7> oh nice, the latest Mathematica had OpenCL support
08:54:11 <kuffaar> But I just use cabal install instead of bootstrap.sh now
08:54:16 <kuffaar> So it worked fine
08:54:28 <kuffaar> But I doubt this fixed the whole segfault issue :p
08:54:28 <BlubbTec> okay i guess i will just give up on it, open files in my ghci directory manually using jedit, save them manually, and then just load them
08:54:42 <kuffaar> BlubbTec yay
08:54:50 <kuffaar> I can't really use ghci for most of my stuff anyways
08:55:01 <kuffaar> Because of external dependencies and such
08:55:13 <BlubbTec> well i've just started learning it, so having a shell to play around is quite awesome 8)
08:55:21 <kuffaar> Heffalump ahhh I located the source of that
08:55:28 <kuffaar> bootstrap.sh line 52
08:55:34 <kuffaar> HTTP_VER="4000.0.10";   HTTP_VER_REGEXP="4000\.0"   # == 4000.0.*
08:55:43 <kuffaar> It has hard coded outdated paths
08:56:06 * kuffaar shrugs
08:56:18 <kuffaar> Might be nicer to look up the current ones instead
08:56:31 <kuffaar> So you don't end up with 5+ outdated libraries
08:56:36 <monochrom> understandably bootstrap.sh cannot be too smart about versions
08:56:53 <kuffaar> Oh I just realised that it's probably wiser to use old versions actually
08:57:07 <monochrom> if it could be done with merely a shell script, cabal-install would be written as a shell script too.
08:57:16 <hatds> I couldn't even get notepad.exe to run with :e when I tried some time ago
08:57:54 <kuffaar> Heffalump: Btw, line 161 ignores that the file won't be called "Setup" on Windows :p
08:58:00 <monochrom> you could then tell beginners "don't learn haskell, shell scripts suffice" :)
08:58:36 <kuffaar> [ -f Setup ] && rm Setup <- interesting
08:58:42 <kuffaar> -f actually returns true with MSYS hehe
08:58:55 <kuffaar> Although it's called Setup.exe
08:59:03 <kuffaar> Probably for compatibility
09:00:09 <bla123> how can i kill a thread that is blocked on a foreign function call? (in ghc)
09:00:40 <Glert> where do i look to take screenshots in windows? is there any library capable of that?
09:00:46 <bla123> (killThread just blocks the calling thread)
09:00:47 <kuffaar> TerminateThread/pthread_kill >:O
09:01:08 <monochrom> probably can't be killed
09:01:26 <bla123> :(
09:02:15 <kuffaar> Glert: Use GetDC/CreateCompatibleDC/CreateCompatibleBitmap/SelectObject/BitBlt/DeleteDC/DeleteObject/ReleaseDC
09:02:20 <kuffaar> user32.dll
09:02:53 <Glert> hrmkay
09:02:54 <monochrom> do you... actually memorize that sequence? :)
09:03:08 <Heffalump> Glert: print-screen to do it manually
09:03:09 <kuffaar> monochrom: Coders do that :/
09:03:18 <Glert> i'm not interested in manually :)
09:03:44 <Bynbo7> Glert: why are you asking here? o.O
09:03:57 <Bynbo7> why not ##windows (pretty sure that exists)
09:04:11 <kuffaar> Bynbo7: The channel has little to no computer literates
09:04:27 <kuffaar> It's like #ubuntu but far worse
09:04:28 <Glert> because #windows people have no clue about haskell?
09:04:58 <Bynbo7> Glert: oh, you want to do it from a library, righto
09:04:59 <systemfault> ##Windows is a support channel...
09:05:01 <kuffaar> Glert I'd just roll my own library in C and then use the Haskell FFI with it
09:05:09 <systemfault> Perhaps #Winapi would be better
09:05:19 <bla123> Glert: it's actually a winapi question, it will probably look in haskell the same way it does in C
09:05:28 <kuffaar> Glert http://social.msdn.microsoft.com/Forums/en-US/vssmartdevicesnative/thread/cdd260fc-f34d-4650-b529-8fc3d68b37b4 there's an example in C
09:05:49 <kuffaar> You might not want the SaveBitmap part though if you want to keep it in memory
09:05:51 <hatds> if there is a standard way to do it via the windows api then there might already be a binding in one of the Win modules
09:06:03 <systemfault> I found my wife on ##Windows ... haha but no help for anything technical..
09:06:29 <Saizan> @gackage Win32
09:06:29 <lambdabot> http://hackage.haskell.org/package/Win32
09:06:52 <kuffaar> Ah it already has GDI bindings etfc
09:07:34 <kuffaar> I laughed at the build failure logs
09:07:45 <BlubbTec> ok, thanks alot for all the hope, see you all soon :)
09:07:52 <BlubbTec> help*
09:07:55 <BlubbTec> ~
09:08:06 <kuffaar> There is no hope, there is only
09:08:10 <kuffaar> @quote SPJ cheerful
09:08:11 <lambdabot> SPJ says: "He used to be a cheerful young man, a productive member of society. Then he learned Haskell."
09:09:13 <Bynbo7> you love that quote don't you
09:09:21 <kuffaar> Such a gem
09:13:18 <kylesmith> newbie here.  What's wrong with this type signature? deriv :: (Num h, Num x) => f h x -> x
09:13:32 <mauke> nothing?
09:13:59 <kylesmith> ghc says "cannot construct the infinite type: x = h -> h -> x"
09:14:11 <kuffaar> Haha nice, cabal install for cabal fails with: "cabal.exe: Package unix-2.4.1.0 can't be built on this system."
09:14:19 <kuffaar> Need to skip stuff I guess
09:14:28 <mauke> > let deriv :: (Num h, Num x) => f h x -> x; deriv _ = 42 in deriv undefined
09:14:29 <lambdabot>   42
09:14:34 <mauke> kylesmith: works here
09:14:40 <kylesmith> hmmm
09:15:11 <kuffaar> kylesmith post all of the code
09:15:43 <kylesmith> deriv f h x = (((f . (+) h) x) - ((f . (-) h) x)) / (2 * h)
09:15:44 <kuffaar> ... in a pastebin that is
09:15:49 <kuffaar> Or like that if it's short, heh
09:15:54 <mauke> kylesmith: that code makes no sense
09:16:01 <kylesmith> I know. newbie
09:16:04 <mauke> kylesmith: your type signature says deriv only takes one argument
09:16:14 <mauke> here you're defining it with three
09:16:32 <mauke> well, the type was impossible anyway
09:16:59 <ryanakca> I'm trying to write a 'dropEvery xs n' that drops every nth item in xs. I managed it using take an recursion, now I'm trying to use foldl. I'm however getting "Occurs check: cannot construct the infinite type: a = [a]" in regards to my helper function. Any suggestions? http://hpaste.org/43230
09:17:33 <hatds> "f h x" in a type means f is a type constructor applied to typesh and x
09:17:49 <kuffaar> I think they might actually want three arguments
09:18:10 <kuffaar> (? -> ?) -> Num -> Num -> Num
09:18:13 <kuffaar> Or something like that
09:18:24 <ryanakca> (the relevent one is dropEvery' in the above paste)
09:19:05 <kylesmith> kuffaar: that might be what I want
09:19:44 <kuffaar> deriv :: (Num -> Num) -> Num -> Num -> Num
09:19:48 <kuffaar> Perhaps something like that
09:19:53 <hatds> ryanakca: not sure, maybe in helper you are confusing 'y' with a single element?  it is a list.  [y] is a singleton list containing a list
09:19:55 <Twey> Num is not a type
09:20:09 <kuffaar> Oh right
09:20:09 <Twey> It's a typeclass
09:20:10 <kuffaar> Fail
09:20:14 <mauke> :t (/)
09:20:15 <lambdabot> forall a. (Fractional a) => a -> a -> a
09:20:17 <aavogt> @type deriv
09:20:18 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
09:20:24 <kuffaar> deriv :: Num a => (a -> a) -> a -> a -> a
09:20:34 <mauke> kuffaar: Fractional a, not Num a
09:20:44 <byorgey> ryanakca: I think you have the y and ys arguments to helper backwards
09:21:09 <mauke> kylesmith: (f . (+) h) x better written as f (h + x)
09:21:30 <kylesmith> mauke: ok, thanks
09:22:27 <kylesmith> got it. thanks, guys.
09:22:42 <ryanakca> byorgey, hatds: Thanks, I'll look at it after lunch
09:22:43 <aavogt> > let deriv f h x = (f (x+h) - f x) `div` h in deriv (^2) 1 1000
09:22:44 <mauke> > deriv (sin + cos) x
09:22:45 <lambdabot>   1 * cos x + 1 * negate (sin x)
09:22:45 <lambdabot>   2001
09:23:08 <mauke> > deriv (sin^2 + cos^2) x
09:23:09 <lambdabot>   1 * cos x * sin x + sin x * (1 * cos x) + (1 * negate (sin x) * cos x + cos...
09:23:28 <Bynbo7> which should be 0 no?
09:23:31 <pedro_saints> hello
09:23:48 <aavogt> > deriv (sin / cos) x
09:23:49 <lambdabot>   1 * cos x * recip (cos x) + sin x * negate (1 * negate (sin x) * recip (cos...
09:24:15 <Bynbo7> hello pedro
09:24:26 <pedro_saints> I'm confused on how to install the haskell platform. Oh hi
09:24:44 <pedro_saints> I'm supposed to download ghc first correct?
09:24:46 <alpounet> pedro_saints, on which OS ?
09:24:52 <pedro_saints> ubuntu
09:25:02 <pedro_saints> maverick meerkat, if that makes a diff
09:25:08 <mauke> how apt
09:25:16 <kuffaar> Hmm I just built cabal-install with the Cabal 1.11 but the binary it produces still says using version 1.10.0.0 of the Cabal library
09:25:17 <pedro_saints> i like meerkats, but i digress.
09:25:39 <aavogt> kuffaar: do you have PATH issues?
09:25:49 <kuffaar> aavogt I checked the binary in dist/...
09:26:02 <kuffaar> aavogt I even hid the old cabal version in ghc-pkg
09:26:07 <kuffaar> Just in case it was using the wrong one
09:26:14 <kuffaar> I also checked the cabal.cabal
09:26:16 <aavogt> kuffaar: hiding packages doesn't matter to cabal builds
09:26:18 <kuffaar> And it has no version constraint
09:26:24 <kuffaar> Oh.
09:26:33 <kuffaar> Maybe I should just unregister it entirely then
09:26:53 <aavogt> you can build it with some extra flags to force another version
09:27:13 <pedro_saints> can i just download the haskell-platform tar and just go to town?
09:27:17 <kuffaar> Oh, I have plenty of packages which depend on the 1.10
09:27:19 <aavogt> kuffaar: something like   --constraint="Cabal >= 1.11" I think
09:27:24 <kuffaar> Ok
09:27:39 <aavogt> kuffaar: but if it works with the older Cabal, why is it a problem?
09:27:49 <kuffaar> aavogt it doesn't work
09:27:54 <kuffaar> It segfaults about 20% of the time.
09:27:57 <mauke> pedro_saints: doesn't ubuntu have a package for that?
09:27:59 <aavogt> oO
09:28:27 <pedro_saints> mauke: through synaptic i believe
09:29:01 <pedro_saints> not for the platform though
09:29:43 <mauke> http://packages.ubuntu.com/search?keywords=haskell-platform ?
09:29:48 <mauke> I don't use ubuntu, though
09:30:26 <kuffaar> cabal.exe: cannot configure cabal-install-0.9.5. It requires Cabal ==1.10.*
09:30:27 <kuffaar> For the dependency on Cabal ==1.10.* there are these packages: Cabal-1.10.0.0. However none of them are available.
09:30:57 <kuffaar> aavogt I don't get where the Cabal ==1.10.* part comes from?
09:31:28 <pedro_saints> i went there, but it only tells me what is inside the platform
09:32:09 <kuffaar> I think it may be because lots of ghc packages are tied to the 1.10?
09:32:14 <pedro_saints> maybe i just forget about it and just make visual basic programs
09:32:29 <kuffaar> Visual Basic on Ubuntu :o
09:32:33 <pedro_saints> :p
09:32:35 <Twey> Haha
09:32:36 * kuffaar doesn't actually use the Haskell Platform
09:32:38 * kuffaar uses ghc 7
09:32:41 <pedro_saints> no I'll go to windows
09:32:48 * kuffaar uses ghc 7 on Windows!
09:33:06 <pedro_saints> then i just use Unix
09:33:29 <pedro_saints> anyways...
09:33:33 <kuffaar> Why not Linux? :o
09:34:03 <pedro_saints> :o
09:34:03 <chessguy> hm. what's a good way to find all the functions in the standard library that are written in terms of arbitrary functors?
09:34:40 <pedro_saints> i installed haskell last time, but it was a pain in the groin
09:34:46 <kuffaar> There is no "standard library" is there?
09:34:51 <kuffaar> Just lots of packages
09:34:53 <kuffaar> Like base etc
09:35:11 <hatds> there's standard library as defined in the report,
09:35:22 <kuffaar> Oh hmm what does it refer to then?
09:35:25 <hatds> also base, and then haskell platform
09:35:33 <chessguy> i guess i mean the packages that come with ghc
09:35:36 <chessguy> http://www.haskell.org/ghc/docs/latest/html/libraries/
09:36:48 <pedro_saints> oh dear
09:37:19 <hatds> that's different than the standard library
09:37:28 <hatds> http://www.haskell.org/onlinereport/haskell2010/haskellpa2.html#x20-192000II
09:38:36 <chessguy> ok, well that's VERY basic. i doubt anything in there is written in terms of Functors
09:40:18 <hatds> you are probably looking for Data.Functor or one of the modules from the category theory packages
09:40:32 <hatds> or perhaps Foldable / Traversable / Applicative
09:41:10 <Bynbo7> i don't think you understand what he's looking for...
09:41:45 <chessguy> these are not the higher-ordered-types i'm looking for
09:41:48 * chessguy waves his hand
09:42:15 <applicative> @hoogle Endo
09:42:16 <lambdabot> Data.Monoid newtype Endo a
09:42:16 <lambdabot> Data.Monoid Endo :: (a -> a) -> Endo a
09:42:16 <lambdabot> Data.Monoid appEndo :: Endo a -> a -> a
09:42:19 <Saizan> grep the sources for "Functor f" ?:)
09:42:28 <Bynbo7> those are not the higher-ordered-types you're looking for...
09:42:37 <chessguy> move along now
09:42:45 <Bynbo7> move alone now...
09:42:54 <Bynbo7> damn it
09:42:59 <chessguy> freudian slip
09:43:01 <Bynbo7> one day, i will learn to type
09:43:06 <chessguy> Saizan, i guess that's one way to do it
09:43:27 <applicative> chess guy, what are you looking for? 
09:43:54 <chessguy> applicative, just trying to get a sense of what is/can-be written in terms of generic functors
09:43:59 <hatds> All the functions with (Functor f) => type signatures are going to be in one of those Data/Control modules
09:44:01 * Bynbo7 pokes hackagebot
09:44:09 <chessguy> in particular, i'm comparing it with Ruby Enumerables
09:44:10 * hackagebot array-utils 0.2 - Primitive functions for updating many elements in mutable arrays at once  http://hackage.haskell.org/package/array-utils-0.2 (AlexMason)
09:44:48 <applicative> @instances-importing Functor
09:44:50 <lambdabot> ((,) a), ((->) r), ContT r m, Either a, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
09:45:08 <applicative> ^^^ pretty boring selection.  
09:45:14 <sipa> @instances Functor
09:45:15 <lambdabot> ((,) a), ((->) r), ContT r m, Either a, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
09:45:17 <applicative> @instance-importing Monad
09:45:18 <lambdabot> ((->) r), ArrowMonad a, ContT r m, Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
09:47:24 <pedro_saints> I'm making a 7 minute abs application in Haskell, anyone want in?
09:47:36 <Bynbo7> eh?
09:47:45 <kuffaar> abs = ?
09:47:52 <mauke> > abs (-42)
09:47:53 <lambdabot>   42
09:47:54 <Bynbo7> > abs (-3)
09:47:55 <lambdabot>   3
09:47:59 <pedro_saints> lol, no
09:48:03 <Bynbo7> > abs (-0)
09:48:04 <lambdabot>   0
09:48:05 <kuffaar> abs = Arch building system to me
09:48:13 <pedro_saints> exercise 
09:48:26 <Bynbo7> oh, 7 minute amdominals
09:48:27 <pedro_saints> abdominal
09:48:40 <Bynbo7> what's it do?
09:48:47 <pedro_saints> i should have been more specific, i forgot who my audience was
09:49:12 <pedro_saints> It's like the 8 minute abs application, but in 7 minutes
09:49:37 <chessguy> abdominables?
09:49:38 <kuffaar> What is the 8 min abs app like?
09:49:38 <pedro_saints> sorry, I'm just killing time, waiting for the platform to d/l
09:49:39 <Bynbo7> shit, that's a saving of like 12.5%
09:49:45 <Bynbo7> that's like a whole minute!
09:49:45 <chessguy> what does haskell have to do with snowmen?
09:49:47 <kuffaar> <pedro_saints> It's like the 9 minute abs application, but in 8 minutes
09:49:53 <kuffaar> Recursion! Pow!
09:50:00 <pedro_saints> exactly!
09:50:15 <pedro_saints> :(
09:50:38 <chessguy> wheeeeeeeeeeee
09:50:48 <Bynbo7> pedro_saints: so, you're doing it in haskell because it's lazy, so it won't workout for the whole 8 minutes? =)
09:50:55 <pedro_saints> hi chessguy, a/s/l/
09:50:56 <pedro_saints> ?
09:50:57 <kuffaar> HAHAHA
09:51:00 <kuffaar> Nice one, Bynbo7
09:51:19 <Bynbo7> > a / s / l
09:51:20 <lambdabot>   a / s / l
09:51:21 <pedro_saints> Bynbo7, I completely forgot about haskell's laziness
09:51:23 <chessguy> Bynbo7, but if it ever needs to have worked out, all time will stop until it does
09:51:45 <kuffaar> Bynbo7 wait, why doesn't that cause an error?
09:51:49 <Bynbo7> chessguy: yeah, it's fucking sweet, i can't wait until that day
09:51:55 <kuffaar> a, s, l are all undefined values, no?
09:52:00 <chessguy> > a
09:52:00 <Bynbo7> no
09:52:01 <lambdabot>   a
09:52:02 <Bynbo7> :t a
09:52:03 <chessguy> @type a
09:52:04 <lambdabot> Expr
09:52:05 <lambdabot> Expr
09:52:05 <Bynbo7> :t 2
09:52:06 <lambdabot> forall t. (Num t) => t
09:52:10 <Bynbo7> :t s
09:52:11 <lambdabot> Expr
09:52:11 <Bynbo7> :t l
09:52:13 <lambdabot> Expr
09:52:21 <Bynbo7> > [a..z]
09:52:23 <lambdabot>   *Exception: not a number
09:52:25 <chessguy> @hoogle Expr
09:52:26 <Bynbo7> :(
09:52:26 <lambdabot> module Text.Parsec.Expr
09:52:26 <lambdabot> module Text.ParserCombinators.Parsec.Expr
09:52:26 <lambdabot> Text.Parsec.Expr buildExpressionParser :: Stream s m t => OperatorTable s u m a -> ParsecT s u m a -> ParsecT s u m a
09:52:30 <kuffaar> <interactive>:1:1: Not in scope: `a'
09:52:35 <pedro_saints> isCompatible a s l
09:52:40 <alpounet> @type [a, b, c, d, e]
09:52:40 <lambdabot> [Expr]
09:52:46 <alpounet> and so on
09:53:11 <alpounet> that's lambdabot specific
09:53:16 <Bynbo7> > a ^ 15
09:53:17 <lambdabot>   a * a * (a * a) * (a * a * (a * a)) * (a * a * (a * a) * (a * a * a))
09:53:24 <pedro_saints> isDesperate ( isCompatible a s l )
09:53:37 <mauke> kuffaar: http://hackage.haskell.org/package/simple-reflect
09:54:03 <chessguy> there was a nice blog post about that a year or two back
09:54:08 <chessguy> twanvl, i think?
09:54:16 <chessguy> yeah
09:54:29 * Bynbo7 has just finished a nice blog post... http://random.axman6.com/blog/?p=285
09:54:32 <Bynbo7> >_>
09:54:38 <mauke> deriv + simple-reflect = synergy!
09:55:03 <mauke> > deriv (^ 2) x
09:55:04 <lambdabot>   1 * x + x * 1
09:55:16 <kuffaar> Bynbo7 it says it was written by Axman6
09:55:20 <Bynbo7> > deriv (sin ^ 3 + 2 * sin) x
09:55:21 <lambdabot>   (1 * cos x * sin x + sin x * (1 * cos x)) * sin x + sin x * sin x * (1 * co...
09:55:25 <kuffaar> Also, interesting that it says Jan 23
09:55:34 <Bynbo7> > map pred "Bynbo7"
09:55:35 <lambdabot>   "Axman6"
09:55:35 <alpounet> > deriv (\x -> x*x + 4) x
09:55:36 <lambdabot>   1 * x + x * 1
09:55:38 <mauke> > succ . "Axman6"
09:55:40 <lambdabot>   "Bynbo7"
09:55:59 <kuffaar> I see
09:56:08 <Bynbo7> kuffaar: it is January 23
09:56:20 <Bynbo7> why are these things to amazing to you :P
09:56:21 <kuffaar> Bynbo7: What timezone is that?
09:56:22 <mauke> @localtime Bynbo7 
09:56:25 <lambdabot> Local time for Bynbo7 is Sun Jan 23 03:04:25 2011
09:56:33 <kuffaar> UTC + 9?
09:56:36 <Bynbo7> JST i think it's called
09:56:38 <pedro_saints> cool
09:56:40 <Bynbo7> Tokyo
09:56:49 <mauke> @localtime kuffaar 
09:57:07 <bos> preflex: seen gcollins
09:57:07 <preflex>  gcollins was last seen on #ghc 1 day, 19 hours, 31 minutes and 21 seconds ago, saying: he told me insert still needs a bunch of work
09:57:17 <pedro_saints> @localtime  lambdabot
09:57:18 <lambdabot> I live on the internet, do you expect me to have a local time?
09:57:26 <finnomenon> Tokyo?
09:57:40 <Bynbo7> yes?
09:57:40 <pedro_saints> lamdabot: you don't have to be snooty about it
09:57:42 <finnomenon> if you're in tokyo and looking for a haskell job: http://www.tsurucapital.com/en/
09:57:42 <kuffaar> Bynbo7 where are you from?
09:58:05 <Bynbo7> finnomenon: o rly? i'll have to talk to Simon about getting another job at Tsuru then :P
09:58:05 <mauke> @localtime pedro_saints 
09:58:06 <lambdabot> Local time for pedro_saints is Sat Jan 22 13:06:08
09:58:14 <Bynbo7> kuffaar: Australia
09:58:21 <finnomenon> do you work for them Bynbo7?
09:58:25 <Bynbo7> yup
09:58:26 <chessguy> @vixen you don't have to be snooty about living on the internet
09:58:26 <pedro_saints> Canada
09:58:28 <kuffaar> How well do you speak Japanese?
09:58:29 <lambdabot> nothing good is on TV
09:58:30 <luite> hm it says that only the training is in Tokyo
09:58:36 <finnomenon> nice :)   how is it?
09:58:37 <Heffalump> how many Haskell programmers does Tsuru have?
09:58:48 <Bynbo7> it's awesome fun :D
09:58:53 <kuffaar> A relative of mine and his girlfriend emigrated to Japan
09:58:57 <Bynbo7> Heffalump: 6 currently
09:59:13 <finnomenon> I hope they'll still be lookingfor interns once I'm in my 5th semester
09:59:29 <luite> I don;t think I'd want to live in japan though (or in singapore)
09:59:34 <pedro_saints> @vixen have you heard that song 'me so horny' ?
09:59:35 <lambdabot> If you're not horny you're not alive.
09:59:36 <Bynbo7> sure, they have a rolling intern policy
09:59:47 <pedro_saints> @vixen so true
09:59:48 <lambdabot> *giggles*
09:59:58 <Bynbo7> luite: japan's great. i'm not so sure about singapore. 
10:00:18 <luite> Bynbo7: do you live there?
10:00:27 <Bynbo7> I do at the moment
10:00:27 <kuffaar> luite: No, he commutes.
10:00:35 <pedro_saints> lol
10:00:39 <pedro_saints> that's harsh
10:00:41 <kuffaar> Australia <-> Japan
10:00:48 <Bynbo7> Tsuru provided me with accomodation
10:00:51 <kuffaar> Two plane flights per day!
10:01:10 <kuffaar> Bynbo7: How good is your Japanese?
10:01:20 <Bynbo7> about four words?
10:01:24 <kuffaar> Haha.
10:01:26 <luite> hehe
10:01:29 <pedro_saints> oragato mr. roboto?
10:01:33 <luite> hmm, I think I know at least five :p
10:01:34 <kuffaar> Weak!
10:01:38 <kuffaar> origato*
10:01:41 <mauke> arigato
10:01:48 <Bynbo7> mauke wins
10:01:49 <pedro_saints> which is it?
10:01:56 <sipa> ありがとう
10:02:03 <mauke> baka
10:02:05 <kuffaar> Oh, fail
10:02:08 <pedro_saints> at least i got mr. roboto right
10:02:16 <mauke> and that's the extent of my japanese
10:02:26 <Bynbo7> pedro_saints: yeah, that's definitely japanese
10:02:32 <pedro_saints> lol
10:02:38 <kuffaar> pedro_saints no
10:02:40 <pedro_saints> :()
10:02:51 <kuffaar> That would be arigatoo roboto-san!
10:02:51 <pedro_saints> -_-
10:03:34 <pedro_saints> I'd just talk in english with a fake japanese accent like portrayed in the Simpsons
10:03:39 <Bynbo7> moto okii wa?
10:03:48 <pedro_saints> Hello chief, let's talk why not.
10:04:09 <Bynbo7> pedro_saints: that actually works surprisingly well
10:04:30 <Bynbo7> if you japaneseify everything you say in english, they uderstand you better
10:04:41 <luite> how many whales have you eaten so far? ;)
10:04:49 <pedro_saints> lol, that makes sense
10:05:06 <pedro_saints> i hear dolphins are all the rage
10:05:32 <pedro_saints> i prefer human horn
10:05:46 <Bynbo7> luite: we tried to get some in Tsukiji, but the sushi place didn't have any
10:06:09 <Bynbo7> it was pretty funny trying to ask for it though, ebcause the guy i was with didn't know the japanese name
10:06:10 <luite> perhaps they don't sell them to gajin
10:06:22 <luite> gaijin
10:06:27 <Bynbo7> possibly
10:06:36 <kuffaar> Gaikoku-jin
10:06:38 <kuffaar> wwwwwwww
10:06:55 <pedro_saints> just tell them you know Ryu
10:07:00 <pedro_saints> that always works
10:07:16 <kuffaar> 笑う笑う笑う
10:08:24 <pedro_saints> @vixen hi
10:08:25 <lambdabot> hiya
10:08:30 * Bynbo7 tries to find the one piece of kanji he can read
10:09:34 <kuffaar> I can read about 6 hanzi but I don't think more than 1-2 of those are even used in Japanese
10:09:38 <Bynbo7> oh hey, i recognise two, this is on the toilet! 小
10:10:31 <Bynbo7> hey, this is awesome, there's heaps of info in the OS X character chooser
10:10:44 <Bynbo7> s/chooser/pallet
10:11:53 <engla> you can even search it
10:12:30 <Bynbo7> not particularly usefully though
10:12:42 <Bynbo7> works for some things, not for japanese symbols
10:13:02 <Bynbo7> finnomenon: so, you're interested in working for Tsuru
10:14:47 <kuffaar> Bynbo7: Why do they go out of their way to employ somebody from Australia who can't even speak Japanese btw?
10:15:33 <Bynbo7> kuffaar: because they all speak english (only the latest employee is japanese), and i'm fucking awesome?
10:15:36 <Bynbo7> :P
10:15:47 <finnomenon> Bynbo7: I'm a long way from being useful to them, but it sounds great from what's on their homepage
10:16:05 <kuffaar> All gaijin?
10:16:17 <Bynbo7> finnomenon: well, it's even more fun than i imagined it would be :)
10:16:22 <Bynbo7> yes
10:16:33 <kuffaar> Why is it even located in Japan then?
10:16:45 <kuffaar> Did a Japanese employer require native speakers of English or something like that?
10:17:35 <Bynbo7> because the CEO likes and lives in Japan
10:18:11 <kuffaar> Hah
10:18:18 <Bynbo7> as do all the full time employees
10:18:21 <monochrom> no disagreement about you being awesome :)
10:18:43 <medfly> Bynbo7, you could just make a job ad specifying you want English speakers, or write it all in English
10:19:26 <kuffaar> findSubstring is now deprecated? http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#v:findSubstring didn't even mention this
10:19:52 <Bynbo7> monochrom: i'm sensing sarcasm :P
10:20:48 <kuffaar> I also don't see why it would be deprecated
10:20:53 <kuffaar> I'll just have to write my own one then
10:21:18 <ill_logic> Is there a way to do implicit type conversion? Supposing I have two types A and B. If I pass an object of type B to a function f :: A -> C, can I define a function, perhaps via a typeclass, that does the conversion from B to A without being called?
10:21:44 <ill_logic> maybe that just leads to ambiguity
10:21:55 <sipa> you can create a typeclass ToA t, with a function toA :: t -> a
10:22:26 <sipa> and then definethe function f as f :: ToA t => t -> C
10:23:25 <Bynbo7> ill_logic: doesn't sound well typed at all!
10:23:26 <ill_logic> so there's a bit of magic that it knows to call "toA"?
10:23:38 <Bynbo7> no, you have to use toA
10:24:00 <luite> haskell doesn't do magic :p
10:24:18 <ill_logic> glad it doesn't
10:25:26 <ill_logic> yeah ok. I get the feeling that the types of things Haskell won't let me do are the types of things I haven't yet realized I shouldn't be doing :P
10:25:43 <Bynbo7> http://strfriend.com/
10:26:12 <Bynbo7> http://tinyurl.com/4adj6uu <- what the perfect email validation regex looks like
10:26:16 <monochrom> there is a proposal "type directed name resolution" to get you one step closer to magic.
10:26:47 <Bynbo7> monochrom: what's it do?
10:26:48 <monochrom> perhaps you are surprised. let me describe it.
10:26:55 <luite> hmm, perfect? I thought email addresses aren't even a regular language
10:28:04 <monochrom> if you have several functions with the same name but different types, for example "to :: Int -> Bool", "to :: String -> Int", "to :: Bool -> Int", "type directed name resolution" says the compiler will know which one to use by checking types.
10:28:38 <Bynbo7> and the compiler will complain when there's multiple matches i assume
10:29:02 <Bynbo7> is this actually being proposed officially?
10:29:09 <monochrom> So, if you are looking for "automatic" conversions... while the above isn't exactly "automatic", it allows you to use the name "to" uniformly.
10:29:29 <monochrom> everything you need conversion you just write like "to x"
10:30:30 <Bynbo7> hmm, will that allow things like let x = 1 :: Int; x = 1.5 :: Double in (x+)?
10:31:06 <monochrom> it is not "official proposal" but there is no "unofficial proposal" either. all proposals are pretty much equal status, as long as they're filed properly on the trac website. and type directed name resolution is properly filed.
10:31:33 <Bynbo7> yeah, that's what i meant
10:31:55 <monochrom> in retrospect it is not that hard to file trolling proposals.
10:32:03 <Bynbo7> heh
10:32:16 <ion> bynbo7: Haha :-D (@ the email “validation” regexp)
10:32:35 <Bynbo7> someone had a good idea for one the other day, function local data types
10:35:45 <paper_cc> is there any implementation of Amb or "ListT done right" on Hackage?
10:41:21 <hatds> alternatively, instead of defining an overloaded "to" function, you may try making your values overloaded instead
10:41:56 <jacobian> What's the simplest way to do a build of a bunch of files in ghc for a fairly simple project.  
10:42:12 <kuffaar> jacobian: cabal
10:42:25 <kuffaar> Unluckily cabal does not support multi threading right now :'(
10:42:35 <Saizan> @hackage ListT
10:42:35 <lambdabot> http://hackage.haskell.org/package/ListT
10:42:42 <kuffaar> Which is a real shame
10:43:20 <monochrom> "ghc --make" may suffice for very simple projects
10:43:47 <alpounet> and use the --main-is option if necessary
10:43:55 <alpounet> but for tiny projects indeed ghc --make is sufficient
10:44:27 <jacobian> sweet, thanks
10:44:28 <Saizan> paper_cc: you could use LogicT
10:48:44 <pedro_saints> ummm does anybody know about zlib?
10:49:02 <pedro_saints> platform won't install without it and i can't find it
10:49:17 <alpounet> the original library (in C) or the binding ?
10:49:19 <monochrom> http://hackage.haskell.org/package/zlib probably does
10:49:46 <monochrom> zlib1g-dev if ubuntu
10:49:48 <Saizan> platform has the haskell lib, so it must be the C one
10:49:54 <paper_cc> pedro_saints: the hackage package should be contained in the platform itself, and your system's package manager knows about the underlying C library
10:50:16 <jkn> is anybody using hdbc-postgresql with postgres 9.0?
10:50:41 <paper_cc> Saizan: thanks =)
10:50:57 <monochrom> http://www.vex.net/~trebla/haskell/haskell-platform.xhtml helps you build the haskell platform from source
10:51:07 * paper_cc tries to understand LogicT using the pieces of Prolog he knows
10:51:18 <pedro_saints> it's the zlib1g-dev i think
10:51:20 <pedro_saints> i'll try
10:51:59 <pedro_saints> yup that was it
10:52:03 <pedro_saints> thanks all
10:52:06 <Shamar> hi, where I can find some link to study function composition identities and theorems?
10:52:19 <pedro_saints> and by all i mean monochrom
10:52:28 <pedro_saints> :p
10:52:34 <monochrom> haha ok
10:52:35 <Shamar> from a mathematical point of view, I mean
10:53:13 <monochrom> pretty much just monoid axioms or category theory axioms.
10:53:17 <beastaugh> Steve Awodey's introductory category theory book is quite good
10:53:51 <beastaugh> http://ukcatalogue.oup.com/product/9780199237180.do
10:53:53 <monochrom> id . f = f; f . id = id; (f.g).h = f.(g.h).  THE END
10:55:02 <beastaugh> don't you mean f . id = f ?
10:55:12 <monochrom> oops yeah
10:56:46 <Bynbo7> my PS1: [\[\033[01;30m\]\d \t\[\033[00m\] \[\033[01;32m\]\u\[\033[00m\]@\[\033[01;31m\]\h\[\033[00m\] \[\033[01;31m\]\j\[\033[00m\]]$(__git_ps1)\n\[\033[01;34m\]\w\[\033[00m\] \[\033[01;35m\]$\[\033[00m\]
10:57:29 <Bynbo7> looks like: http://cl.ly/2K3S091n3x2T3j322m0E
10:57:57 <Bynbo7> whoops, wrong chan >_<
10:58:03 <Bynbo7> sorry all
11:09:43 <Twey> @index Functor f => f a
11:09:44 <lambdabot> bzzt
11:09:46 <Twey> Er
11:09:50 <Twey> @hoogle Functor f => f a
11:09:50 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
11:09:50 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
11:09:50 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
11:10:11 <Twey> chessguy: Something like that?
11:12:52 <philo> hi it is possible to define find in term of fold ?
11:13:01 <chessguy> Twey, is it safe to assume that everyone who refers to a function uses type variables with those names?
11:13:23 <Twey> chessguy: IIRC Hoogle does proper type unification
11:13:32 <Twey> It's not a text search
11:13:33 <chessguy> ooh, fancy
11:13:50 <Twey> (hence getting fmap, which is -> f b)
11:14:36 <Bynbo7> philo: in terms of foldl and foldr, yes
11:15:25 <philo> we need booth ?
11:19:20 <chessguy> Twey, hm. seems to return some irrelevant things. http://www.haskell.org/hoogle/?hoogle=Functor+f+%3D%3E+f+a
11:19:33 <chessguy> unwrapMonad :: WrappedMonad m a -> m a ?
11:21:38 <Twey> chessguy: Matches if m is a Functor (which it can be, since it's arbitrary)
11:22:29 <chessguy> Twey, sure, but i'm not interested in things that match *anything*
11:22:44 <Twey> Yeah
11:22:52 <Twey> I don't know how to narrow it down further, sorry
11:23:21 <chessguy> Twey, no problem, thanks
11:23:24 <horse_kicker_> How does one do a default case pattern? Not like [ ] but for a custom data type. 
11:23:33 <sipa> _
11:24:18 <Twey> horse_kicker_: Match against the wildcard pattern, _
11:24:27 <Twey> Or give it a name like ‘a’
11:25:05 <horse_kicker_> hmm. isn't "_" just another variable name?
11:25:13 <Twey> No, _ is special
11:25:33 <Twey> You can use it as many times as you like, because it doesn't bind anything: it just ignores that part of the pattern
11:25:54 <Twey> In contrast, names must be unique within a pattern
11:26:20 <kuffaar> _ is usually used when you perform matching and you want to ignore a part of the match (for example Just _ when yuo don't care about what the Just contains) or when you want a catch-all case and stuff like that
11:26:27 <aristid> couldn't ReaderT be an instance of Arrow?
11:27:04 <horse_kicker_> oh. learnyouahaskell is slightly misleading  - "_ means that we don't care what we'll draw from the list anyway so instead of writing a variable name that we'll never use, we just write _. "
11:27:15 <augustss> philo: foldl can be defined in terms of foldr
11:28:13 <aristid> augustss: without reverse?
11:28:23 <augustss> aristid: yes
11:28:32 <aristid> with (++)?
11:28:36 <aristid> no wait
11:28:40 <aristid> *confused*
11:28:51 <dcoutts_> but it needs a cunning transformation to make it efficient
11:28:57 <Kaidelong> foldr . flip
11:28:59 <Twey> horse_kicker_: Doesn't seem very misleading to me
11:29:04 <Twey> horse_kicker_: ‘Instead of writing a variable name…’
11:29:09 <Kaidelong> wait
11:29:11 <Kaidelong> no
11:29:11 <aristid> Kaidelong: that only gets the type right.
11:29:14 <Kaidelong> @ty foldr
11:29:14 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
11:29:22 <augustss> foldl f a bs = foldr (\b g x -> g (f x b)) id bs a
11:29:50 <kuffaar> dcoutts_: Why does cabal install in cabal-install end up using Cabal 1.10 instead of 1.11 although I have 1.11 installed? Is it because base and such force it to 1.10?
11:30:06 <Kaidelong> aristid: I see, the problem is with associativity here
11:30:14 <kuffaar> Also, how do I figure out why my cabal.exe on Windows 7 built with MSYS segfaults randomly?
11:30:16 <augustss> philo: and it's easy to define find interms of foldr
11:30:17 <aristid> augustss: ah, it's "tail recursing" through the functions
11:30:38 <Kaidelong> you could use CPS to define foldr in terms of foldl
11:30:56 <augustss> Kaidelong: no, I don't think so
11:31:11 <dcoutts_> kuffaar: for the first Q, it's because the cabal-install.cabal file says build-depends: Cabal >= 1.10 && < 1.11
11:31:14 <Kaidelong> hmm, what would stop you?
11:31:24 <horse_kicker_> Twey : _ _ is like * * in regex. a a is different, in that both match the same. The difference could have been highlighted. That's all.
11:31:36 <Kaidelong> oh
11:31:37 <kuffaar> dcoutts_: Oh, I thought I had checked that, odd
11:31:40 <Kaidelong> you'd need more than just foldl
11:31:43 <Twey> horse_kicker_: a a is an error
11:31:56 <dcoutts_> kuffaar: for the second, that's not easy to track down, but I'd start by rebuilding things from clean and if it's reproducible then report it with as much detail as you can
11:31:59 <Twey> > let f a a = a in f 5
11:32:00 <lambdabot>   Conflicting definitions for `a'
11:32:00 <lambdabot>  Bound at: <interactive>:1:6
11:32:00 <lambdabot>            <in...
11:32:04 <augustss> Kaidelong: foldl in terms of foldr fails on infinite lists
11:32:42 <c_wraith> foldl fails on infinite lists, so that's not so surprising
11:32:47 <Kaidelong> ah right, defining foldr in terms of foldl (and the thing to run the resulting continuation) would change the semantics
11:32:48 <kuffaar> :p
11:34:26 <kuffaar> dcoutts_ I haven't discovered anything that lets me produce it with any regularity. I am puzzled as to why this could even happen. It's not like cabal deals with any low level stuff, right? It's just some file IO?
11:34:31 <Kaidelong> interesting that foldl' is useful, you'd think that you'd be able to make foldl into foldl' at compile time in most cases just by checking that the given function is strict in both arguments
11:35:01 <dcoutts_> kuffaar: right, files and running programs
11:35:20 <dcoutts_> kuffaar: there's a little FFI, but not much
11:35:30 <augustss> Kaidelong: well, the strictness analyzer tends to do the right things with functions like sum that are defined in terms of foldl
11:35:48 <c_wraith> Kaidelong: I think it's an issue with foldl not being inlineable, because it's recursive, so the code isn't available for examination at the call site, making the strictness analyzer fail
11:36:01 <kuffaar> dcoutts_ so how do I debug this to figure out where it segfaults? Apparently ghc binaries catch this themselves instead of passing it on to the OS so I wouldn't know how to debug it really
11:36:20 <kuffaar> Perhaps I could start out by turning on super verbose output to see what the last good line is?
11:36:25 <c_wraith> augustss: in my experience, the strictness analyzer does *not* work with sum or product
11:37:01 <augustss> c_wraith: really?
11:37:04 <dcoutts_> kuffaar: yep
11:41:15 <c_wraith> augustss: I guess sum is getting strictified properly in my test case.  I guess I just don't use -O2 enough
11:41:26 <augustss> c_wraith: I just summed a billion numbers.  it worked fine
11:41:50 <c_wraith> will I just summed minBound..maxBound :P
11:41:53 <c_wraith> err, *well
11:42:07 <augustss> c_wraith: yeah, you need the optimizer, otherwise you don't get strictness analysis
11:42:30 <c_wraith> huh.  32-bit Int.  is there ever going to be a 64-bit build of GHC for os x?
11:42:43 <augustss> I hope so
11:43:03 <augustss> I'm surprised there isn't, given the number of mac users
11:43:14 <c_wraith> well, I'm using 6.12.3
11:43:19 <c_wraith> Maybe 7.0.1 is 64-bit?
11:43:38 <augustss> well, i'm using leopard still :)
11:44:03 <augustss> but the App Store has convinced me to upgrade
11:44:19 <c_wraith> heh.  First thing I did when the app store showed up in my dock was delete it.
11:45:21 <augustss> c_wraith: my wife got a RAR file yesterday to her macbook air.  that convinced me i need the app store
11:46:26 <augustss> c_wraith: she double clicked on it, it said there's no app, but do you want me to search the app store.  she said yes, and downloaded the free app to open RAR files, and it opened.
11:46:28 <c_wraith> also, I'm kind of amused overflow didn't make the sum wrong in my test.  Though thinking about it for a second, it's kind of obvious why.
11:47:03 <augustss> c_wraith: the positive and negative numbers cancel out just fine even with overflow.
11:47:08 <c_wraith> yep.
11:47:20 <c_wraith> so the result is clearly...  minBound!
11:47:25 <augustss> yep
11:47:31 <beastaugh> c_wraith: I think the problem is that no one has stepped up to make it happen
11:47:36 <augustss> a very tricky number!
11:47:42 <beastaugh> c_wraith: there is certainly demand, just not supply
11:48:56 <c_wraith> in fact, with two's complement, overflow is the reason positive and negative numbers add properly.
11:49:39 <c_wraith> Or even why negative numbers add together properly.
12:17:34 <try[haskell]> ah the try haskell console froze on me
12:18:47 <monochrom> it doesn't freeze on me yet. I just tried 23*26.
12:30:38 <edwardk> quiet in here
12:31:09 <kaol> We're just busy avoiding success.
12:31:24 <edwardk> well, then work quieter! =)
12:35:28 <try[haskell]> I wonder how haskell was so fast in the game benchmakrs
12:36:16 <augustss> why shouldn't it be?
12:37:31 <kuffaar> Because it's an abstract academia trash language
12:37:33 <kuffaar> Duh.
12:38:03 <joe6> dreixel: are you around?
12:38:07 <applicative> yeah, augustss. 
12:38:37 <try[haskell]> i wonder why an old language like lisp wasn't up there... haskell takes allot from it right ?
12:39:14 <try[haskell]> old = has had time to mature compiler 
12:39:39 <applicative> Is Int completely reliable as a funny sort of modular arithmetic?  I suppose it must be.  It's not as much like Float as all that.
12:39:48 <alpounet> Haskell isn't what I'd call _young_
12:39:56 <Eelis> hm, i find myself writing quite a bit of     (case x of p1 -> Just e1; p2 -> Just e2; p3 -> Just e3; _ -> Nothing)   where the patterns together do not cover all possible values for x. perhaps a "maybe case" syntax sugar feature would be neat. it would implicitly put Just in front of all the given branches, and add a wildcard branch returning Nothing. so the example could be written as:   mcase x of p1 -> e1; p2 -> e2; p3 -> e3
12:40:03 <kuffaar> <try[haskell]> i wonder why an old language like lisp wasn't up there... haskell takes allot from it right ?
12:40:20 <kuffaar> I'd say Lisp and Haskell have rather little in common
12:40:46 <monochrom> allegro lisp should be pretty optimizing. but wetware trumps anyware. lisp people are probably just not interested in competing in benchmarks
12:41:01 <Philippa> haskell takes very little directly from lisp - they have shared heritage in the lambda calculus
12:41:03 <kuffaar> There isn't even a mainstream LLVM backend for any Lisp yet
12:41:46 <try[haskell]> well it's on the game benchmark list but really low 
12:41:55 <kuffaar> I asked a CL dev once why and he said "the LLVM C++ stuff is too difficult to integrate because most Common Lisp compilers are written in CL"
12:42:19 <kuffaar> ghc has had an LLVM backend for quite a while now and it's not written in C++ either
12:42:20 <try[haskell]> lol
12:42:35 <jacobian> Yeah, I don't think that makes much sense
12:42:38 <Eelis> kuffaar: sounds like that guy doesn't understand what LLVM is
12:42:39 <Philippa> haskell does have a pretty good FFI though
12:42:46 <Saizan> "quite a while" ~1 year
12:42:52 <monochrom> recall that ghc isn't written in cl either :)
12:43:00 <Jesin> hmm
12:43:05 <try[haskell]> ask stupid questions like this in #lisp and you get muted and abused on PM
12:43:11 <Jesin> what's the distinction between type classes and type families?
12:43:40 <kuffaar> #haskell and #lisp has a bit of an overlap btw
12:43:48 <kuffaar> But not by much
12:44:02 <jacobian> I think the main reason is that most CL compilers predate the LLVM by a long long time. 
12:44:03 <Saizan> Jesin: the only thing they have in common is that you can add instances to them
12:44:06 <applicative> Jesin, type families are newer for one thing...
12:44:18 <Philippa> hell, #polyamory and #haskell have overlap, that doesn't mean there's any particular relationship between the concepts
12:44:26 <try[haskell]> overlap as in people ?
12:44:34 <jacobian> lol
12:44:38 <monochrom> the language is just an excuse. the community matters. the community influences the language, of course. but the language doesn't tell you everything.
12:44:47 <kuffaar> ghc started in 1989
12:44:53 <try[haskell]> what's the point of the let syntax simply to define a function for a short time only ?
12:44:56 <mreh> can I pass control over to the shell at all?
12:45:16 <Philippa> try[haskell]: let has nothing to do with functions per se, it just binds values to variables
12:45:17 <Saizan> Jesin: type classes are like predicates or relations over types (with associated methods), while type families are (some restricted form of) type level functions
12:45:20 <kuffaar> SBCL was forked in 1999
12:45:36 <c_wraith> try[haskell]: Static scoping.  The names bound by let have access to other names in scope, and they won't be visible outside of their scope.
12:45:43 <ion> A named local binding for clarity perhaps.
12:45:44 <kuffaar> CMUCL goes back to around 1980
12:45:47 <applicative> Saizan, you mean I cant reduce type classes to type functions that map types to something like booleans among types
12:45:49 <Philippa> we already had extant LLVM bindings, IIRC
12:45:50 <kuffaar> SBCL was a fork off that
12:46:00 <monochrom> mreh: what is pass control to the shell?
12:46:25 <monochrom> if you know the shell's name, you could system "/bin/sh" or something
12:47:17 <monochrom> wait, system already runs the shell
12:47:53 <Saizan> applicative: sure, you can encode predicates as functions and vice versa
12:47:57 <mreh> oh, spawn another shell
12:48:12 <monochrom> indeed (system "echo $PATH") works on linux
12:48:38 <applicative> maybe we can use this to get rid of all the confusion type classes cause for people when they know other languages that have "classes"...
12:48:44 <mreh> well, I wanted to spawn a shell, or pass control back to the shell so I don't need to echo all the output
12:49:33 <mreh> I'm shell scripting
12:50:24 <applicative> "we don't really have classes in Haskell, everything is a function; even type classes are type functions...etc etc."  Not too compelling, that.
12:50:41 <monochrom> everything is a bit
12:50:46 <Saizan> applicative: though you can rarely say "false", most of the time you can only say "don't know"
12:51:24 <Saizan> reduction done like that is not very useful to explain language features.
12:51:25 <applicative> or "not yet anyway"
12:51:42 <mreh> Process.run? Is that a legacy module?
12:52:01 <monochrom> Yeah. modern name is System.Process
12:53:07 <applicative> it doesn't have a function 'run' does it
12:53:11 <monochrom> and there is no "run" in System.Process. there are runProcess etc.
12:54:09 <Saizan> mreh: have you seen system or rawSystem?
12:55:03 <mreh> Saizan: yeah
12:55:12 <mreh> I was just looking under the hood to see how it works
12:55:26 <mreh> if it's returning an exit code, then it cant be lazy
12:55:45 <monochrom> yeah it blocks until the child finishes
12:55:46 <Saizan> right, you can forkIO it though
12:56:05 <mreh> heyal naw
12:56:26 <Saizan> ?
12:56:31 <mreh> hell no :)
12:57:04 <mreh> I need it to make my program behave like a bash script
12:57:07 <monochrom> not convinced that you want it lazy. do you also want getLine lazy? putStrLn lazy? openFile lazy?
12:57:21 <mreh> I don't want it to be lazy!
12:57:29 <mreh> I've found what I need \o/
12:57:43 <monochrom> well problem solved
12:58:15 <j-invariant> if I have an infinite periodic sequence how do I find the period?
12:58:30 <edwardk> fiddling with Data.Distributive. i think i want to flop the order of things for cotraverse in practice, because it seems that i get more opportunities to fuse fmaps
12:58:45 <monochrom> there is some Floyd's algorithm for finding the period
12:59:00 <edwardk> right now cotraverse :: (Distributive g, Comonad w) => (w a -> b) -> w (g a) -> g b
12:59:25 <edwardk> i'm leaning towards cotraverse :: (Distributive g, Comonad w) => (a -> g b) -> w a -> g (w b)
12:59:42 <edwardk> which really kind of ceases to be a cotraverse so needs another name
13:00:56 * hackagebot streams 0.3 - Various Haskell 2010 stream comonads  http://hackage.haskell.org/package/streams-0.3 (EdwardKmett)
13:03:24 <Saizan> so Distributive has cosequence :: w (g a) -> g (w a) ?
13:03:28 <edwardk> yeah
13:03:47 <edwardk> saizan: works for things like g = (->)e — or Identity or infinite streams or fixed sized vectors
13:03:57 <edwardk> anywhere where a potentially infinite number of g's can be mashed together
13:04:17 <edwardk> i called it 'distribute' rather than cosequence, but thats the gist
13:05:39 <edwardk> saizan: i needed it for http://hackage.haskell.org/packages/archive/adjunctions/0.4.0/doc/html/Control-Comonad-Trans-Adjoint.html dual to the need for Traversable in http://hackage.haskell.org/packages/archive/adjunctions/0.4.0/doc/html/Control-Monad-Trans-Adjoint.html
13:06:01 <joe6> does anyone know where this link is hosted? http://www.haskell.org/bz/thdoc.htm
13:06:19 <joe6> it does not seem to work anymore.
13:06:33 <joe6> wondering if anyone knows of any alternate locations for the tutorial
13:06:49 <edwardk> sorry joe, never read it
13:07:13 <edwardk> saizan: have a better name for me for the not-quite-cotraverse?
13:07:14 <jem777> hey, is there a way to convert a function (a -> b -> m c) to  m (a -> b -> c) ?
13:07:30 <edwardk> jem777: no
13:07:54 <edwardk> jem777: that would require you to know all possible inputs a and b and perform 'all of their effects' when creating the function a -> b -> c
13:08:05 <edwardk> for _some_ monads m you could do it
13:08:09 <edwardk> e.g. reader
13:08:19 <edwardk> a -> b -> e -> c  can become e -> a -> b -> c pretty easily
13:09:01 <edwardk> amusingly given the current discussion, that works if m is an instance of Distributive ;)
13:09:04 <jem777> edwardk, it is a StateT monad
13:09:21 <edwardk> jem777: then no dice.
13:09:37 <aavogt> joe6: http://web.archive.org/web/20080822110753/http://haskell.org/bz/thdoc.htm
13:09:55 <jem777> edwardk, thanks
13:09:56 <joe6> aavogt: thanks a lot.
13:10:06 <Saizan> edwardk: i'd almost go with mapD, since it's like mapM where s/Monad/Distributive/
13:10:22 <edwardk> you're asking to turn a -> b -> s -> (c, s)  into s -> (a -> b -> c, s) what if the s in the result depends on a or b?
13:10:56 <edwardk> saizan: i was kicking around mapW because of the M W monad/comonad thing, but mapW would be the proper name for what i was previously calling cotraverse
13:11:17 <edwardk> but in general i tend to shy away from smashing random letters into my names
13:12:50 <Saizan> there are only so many synonyms of "map" one can use though
13:12:55 <edwardk> yeah
13:13:04 <BMeph> edwardk: Do you have a (FSVO) simple package for comonads? :)
13:13:17 <edwardk> BMeph: 'comonad'
13:13:37 <edwardk> BMeph: very minimalist haskell 98. its just Control.Comonad and Data.Distributive
13:13:49 <edwardk> all of the rest of the comonads are in comonad-transformers or comonads-fd
13:14:44 <edwardk> saizan: fortunately its s lightly different concept, ts about diffusing or distributing the comonad w across some fixed shape
13:15:31 <edwardk> so ultimately we coalesce a g (w b) out of a (a -> g b) and 'w a'
13:15:59 <edwardk> descibe the fact that 'w a' as a comonad could have infinitely many 'a's
13:17:42 <edwardk> i guess its more of a zipW
13:18:24 <edwardk> but there is that terrible letter again
13:18:44 <Saizan> so, w is a wave function, g some measurements, and for each variable measured we get a wave for the results? :) (extract = collapse of course)
13:18:47 <alpounet> edwardk, out of curiosity, do you have some pieces of code for modelling Poincaré's hyperbolic half-plane ? :P
13:18:50 <BMeph> edwardk: Thank you much.
13:19:09 <edwardk> saizan: note distribute can't use extract typically. its got to work through the comonad usually just with fmap
13:19:34 <edwardk> in fact, i may be able to weaken it to just distribute :: Functor w => w (g a) -> g (w a) — which would be pleasing
13:19:49 <edwardk> alpounet: i do
13:19:58 <edwardk> alpounet: in javascript though.
13:20:05 <edwardk> alpounet: and in java
13:20:29 <edwardk> alpounet: you may have better luck looking at the javascript infovis toolkit and adapting their algorithms though
13:20:29 <alpounet> seriously? could you share this?
13:21:18 <alpounet> hm
13:21:25 <edwardk> alpounet: if i can dig it up. i wrote it about 6 years ago for the linguist list. they ultimately replaced it with startree's inxight
13:21:33 <kuffaar> My Haskell code starts feeling like I am doing OOP in C where I pass around a "this" pointer all the time. Many of my functions share like up to 2-4 arguments which are just continously passed around and this just strikes me as a total anti pattern. Would you usually use a monad for stuff like this?
13:21:37 <edwardk> mainly because i was leaving and they needed to maintain the resulting system
13:22:01 <edwardk> http://multitree.linguistlist.org/ used it
13:22:26 <edwardk> kuffarr: yes
13:22:38 <alpounet> kuffaar, sounds like a use case for the State monad to me
13:22:44 <edwardk> kuffar: move into the state monad or a reader monad for the immutable parameters. ust stack up monad transformers
13:23:22 <kuffaar> alpounet hmm ok and then I'd have a composite type which is passed around implicitly within the state monad?
13:23:25 <edwardk> type M = ReaderT MyStuffThatDoesn'tChange (StateT MyStuffThatIChangeAllTheTime SomeBaseMonadOrIdentity)
13:23:36 <edwardk> then use 'M a' as the result type of your functions
13:23:59 <alpounet> kuffaar, the perfect model would be what edwardk just gave you
13:24:14 <kuffaar> I tried something like this before to conceal my concurrent printing function in the signature like that
13:24:19 <edwardk> and you can use 'ask' or 'asks' to access the members of your MyStuffThatDoesn'tChange and 'get' and 'modify' to tweak the MyStuffThatIChangeAllTheTime
13:24:21 <alpounet> that is, separating what would change from time to time and what would never ever change
13:24:54 <kuffaar> I ended up drowning in the LockedConsole IO () stuff and got confused by all the lifting required etc, never managed to even make the code compile
13:25:10 <alpounet> edwardk, looks quite fun
13:25:17 <alpounet> i would have liked to see this in Haskell
13:25:24 <alpounet> but it seems it's not gonna happen
13:25:25 <em> how does haskel do i/o without using side effects?
13:25:35 <kuffaar> em: It doesn't
13:25:36 <edwardk> kuffaar: with the monad transformer library you don't wind up lifting much, ask and get can both be done on the composite monad, so the only thing you need to lift are IO actions, and thats just liftIO
13:25:39 <jmcarthur> kuffaar: a good API will hide all the lifting stuff underneath a few blessed primitives
13:25:39 <alpounet> i'll try to write it if i find the time during my semester, but i'm not there yet...
13:26:04 <edwardk> em: we carefully encapsulate out IO by caging it in a monad, so you can tell if something does IO from the type
13:26:04 <em> kuffaar: i thought haskell was purely functional and that meant never having side effects.
13:26:14 <Saizan> kuffaar: now that you've seen that the alternative of passing everything by hand is painful, you've more incentive to learn enough of haskell's type system to not drown again :)
13:26:15 <jmcarthur> kuffaar: and what edwardk is talking about uses type classes to automatically choose the appropriate lifts for you
13:26:15 <em> okay
13:26:24 <kuffaar> em: To do anything interesting in Haskell you will perform impure stuff
13:26:34 <j-invariant> A haskell program is an interactive process that produces instructions for an "IO" machine
13:26:37 <edwardk> em: this lets us pass around IO 'actions' as pure functional objects by separating the act of determining 'what to do' from the act of doing it
13:26:37 <jmcarthur> kuffaar: not really true, i'd say
13:26:51 <j-invariant> the IO machine interacts with the purely function haskell program to decide wat actions to take
13:26:54 <alpounet> em, anything performing side effect will return a value of type 'IO something'
13:26:57 <jmcarthur> kuffaar: i think a lot of pure haskell code is very interesting :)
13:29:19 <kuffaar> The thing is, I need more than just "ask" / "asks" though. I want to be able to use my mutexed version of putStrLn without having to go printFunction <- asks recordFunction; printFunction $ "HAY HAY" whenever I want to print something
13:29:36 <kuffaar> Having to do that seems just as redundant as passing around all the stuff all the time
13:30:12 <monochrom> in that case I skip the Reader Monad and just pass printFunction as parameter. I actually do that in my program.
13:30:12 <Saizan> define "foo x = do f <- asks recordFunction; f x" ?
13:30:23 <monochrom> If there are many such parameters, I pass a record.
13:30:46 <joe6> has anyone used haskell Drift?
13:31:05 <monochrom> forkIO (mySecondThread myRecordOfActions)
13:31:08 <edwardk> hrmm, 'collect :: (Distributive g, Functor f) => (a -> g b) -> f a -> g (f b)
13:31:18 <edwardk> easy to remember
13:32:23 <kuffaar> monochrom: :'( how disheartening
13:32:43 <kuffaar> Can't I just make something similar to ReaderT which simply offers 5-10 different ask like functions?
13:33:07 <monochrom> yes actually that's even better
13:33:11 <kuffaar> Then I'd save myself some typing
13:33:38 <kuffaar> but I might want to try it with a record and ReaderT first so I can figure out all the lifts necessary and scuh
13:34:14 <j-invariant> A haskell program is a strategy for the "IO Game"
13:34:20 <j-invariant> em ^
13:34:36 <j-invariant> put simply
13:36:27 <monochrom> a program/specification is a game (or the rules of a game)
13:37:19 <monochrom> (see "The Refinement Calculus" by Back & von Wright)
13:39:27 <joe6> any thoughts on "First Class Types"?
13:39:57 <j-invariant> joe6: pointless
13:40:08 <j-invariant> might as wel use a dynamics language
13:40:20 <edwardk> kuffaar: you can do so, its just redious
13:40:33 <edwardk> kuffar you could also define your '5-10 different ask' functions as
13:40:38 <edwardk> foo = asks getFoo
13:41:17 <edwardk> kuffaar: keep in mind if you use the mtl, 'asks' does all of its lifting _for you_
13:41:17 <saiko-chriskun> how do you get a function to be able to return different types?
13:41:17 <Twey> Umm
13:41:26 <Twey> First-class types sounds like dependent typing
13:41:39 <Twey> Which is very different to dynamic typing :þ
13:41:42 <j-invariant> saiko-chriskun: use a GADT
13:41:48 <joe6> i hear that this is on the horizon of computer science.
13:41:52 <kuffaar> saiko-chriskun: test x = x
13:41:54 <azaq23> coq has that
13:42:03 <j-invariant> yeah but dependent types arent practal
13:42:16 <kuffaar> > let test x = x in (test 2, test "lol")
13:42:17 <lambdabot>   (2,"lol")
13:42:18 <j-invariant> and its not programming anyway since they're not turing complete
13:42:27 <monochrom> types in dependent typing are still not first-class, although already pretty high status
13:42:34 <Twey> j-invariant: … are you serious?
13:42:43 <j-invariant> prove me wrong ;)
13:42:51 <Twey> (real question: I'm not sure whether or not you're joking)
13:42:59 <monochrom> also IMO:
13:43:03 <monochrom> @quote monochrom poor
13:43:03 <lambdabot> monochrom says: dynamic type is poor man's dependent type, they are so poor they can't buy a theorem prover.
13:43:10 <Twey> Haha
13:43:21 <kuffaar> <edwardk> foo = asks getFoo <- oh true, so then I need nothing but ReaderT really
13:43:29 <kuffaar> ReaderT and one record type that is
13:43:42 <kuffaar> Then I just make some top level helper functions and I'm good to go
13:43:43 <Rotaerk> dynamic typing is the lazy man's solution to a crappy static typing system
13:43:55 <j-invariant> no its not
13:43:56 <Guest96062> hola
13:44:05 * hackagebot explicit-iomodes 0.6.0.2 - File handles with explicit IOModes  http://hackage.haskell.org/package/explicit-iomodes-0.6.0.2 (BasVanDijk)
13:44:07 <Rotaerk> instead of coming up with a better static type system, just get rid of it altogether
13:44:10 <Adamant> dynamic typing is the solution to things that need dynamic typing
13:44:31 <azaq23> a tautology is a tautology
13:44:34 <Rotaerk> I'm not convinced anything exists that "needs" dynamic typing
13:44:42 <Adamant> yes, but sometimes it's informative
13:44:50 <j-invariant> azaq23: thats truer than the crap other people were coming up with
13:45:25 <j-invariant> Rotaerk: there is a well typed program in every type system than cant be typed: Godels incompleteness theorem
13:45:39 <j-invariant> Rotaerk: but in practice you uare probably right
13:45:41 <Jesin> umm
13:45:48 <kuffaar> Rotaerk sometimes I just want to code stuff where I don't notice bugs in the program until I get runtime errors when certain functions are executed, ok?
13:45:51 <Jesin> in *every* type system?
13:45:52 <Jesin> :p
13:46:01 <joe6> seeing some of the stuff around rank-n types and all that, I feel that first class types will be the next big thing.
13:46:07 <Jesin> or just the ones that express Robinson arithmetic
13:46:09 <Jesin> :p
13:46:25 <Rotaerk> j-invariant, I'm not particularly clear on godel's theorem, especially on its context of applicability
13:46:37 <j-invariant> Rotaerk: see Jesin remark then
13:46:49 <joe6> "most of the practical template haskell stuff seems to be working around the type system?" -- Does this make sense?
13:46:52 <Rotaerk> and his remark means even less to me :)
13:46:58 <Jesin> http://en.wikipedia.org/wiki/Robinson_arithmetic
13:46:58 <Rotaerk> "robinson arithmetic" is a new term to me
13:47:00 <j-invariant> oh well its not very important
13:48:18 <monochrom> joe6: probably doesn't make sense. the author has the burden to provide evidence. ignore most blogs.
13:48:33 <Jesin> {Sx ≠ 0; (Sx = Sy) → x = y; y=0 ∨ ∃x (Sx = y); x + 0 = x; x + Sy = S(x + y); x*0 = 0; x*Sy = (xy) + x}
13:48:44 <Jesin> ^is robinson arithmetic
13:49:03 <monochrom> in this case the author probably can't even point to one anecdotal example, nevermind proving "most".
13:49:03 <Twey> j-invariant: http://www.impredicative.com/ur/ — dependent types can be used for real code, and have nothing to do with totality.
13:49:07 <Rotaerk> guess I didn't take enough math in school; that doesn't mean much of anything to me
13:49:23 <j-invariant> Twey: that doesn't have dependent types
13:49:29 <Twey> Yes it does
13:49:46 <monochrom> the scientific method is very powerful in discarding junk and saving you time
13:50:01 <j-invariant> duck season
13:50:47 <kuffaar> monochrom: <insert Christian fundamentalist/anti scientific remark here>
13:51:14 <edwardk> sweet, Distributive no longer needs comonads at all. time to factor it out into a separate package
13:51:35 <Tomsik> Okay, it's haskell time
13:51:39 <azaq23> j-invariant: Why aren't dependent types practical?
13:51:39 <j-invariant> Twey: it has polymorphism but that's not dependent types
13:51:53 <j-invariant> azaq23: I am just saying that nobody has been able to make real world use of them YET
13:51:54 <Tomsik> Why does GTK doesn't update my treeview after I update liststore
13:52:01 <jmcarthur> kuffaar: btw, if you just make a record type, say (data Foo = Foo { bar :: Int, baz :: String }, then you can use the Reader monad without using the Reader newtype at all. just pass it as a parameter and then you can say:   do { x <- bar; y <- baz; return (show x ++ y) }
13:52:06 <j-invariant> azaq23: people are strarting to write small libraries of data types but most programmers don't WANT proofs
13:52:07 <Tomsik> I mean, it updates only after I move mouse over and back on it
13:52:07 * hackagebot pointedlist 0.4.0.2 - A zipper-like comonad which works as a list, tracking a position.  http://hackage.haskell.org/package/pointedlist-0.4.0.2 (JeffWheeler)
13:52:10 <telephone> How do I export typeclasses in a module?
13:52:15 <edwardk> azaq23: mostly comes down to the loss of type inference. the loss of power to weight ratio is hard to stomach
13:52:18 <j-invariant> azaq23: there is even a movement /against/ well typed languages
13:52:31 <j-invariant> some people think they are unnesseary or make you a worse programmer etc.
13:52:41 <aristid> edwardk: somebody other than you made a comonad package oO
13:52:45 <kuffaar> jmcarthur: Curious
13:52:47 <j-invariant> and the small fraction of people who care about types ... therei's an ever small fragment of them who want proofs
13:53:01 <jmcarthur> kuffaar: that expression has this type:   Foo -> String
13:53:08 * hackagebot safer-file-handles-text 0.1.0.5 - Extends safer-file-handles with Text operations  http://hackage.haskell.org/package/safer-file-handles-text-0.1.0.5 (BasVanDijk)
13:53:36 <kuffaar> jmcarthur: What newtype do you mean btw? ReaderT?
13:53:43 <jmcarthur> kuffaar: yeah
13:54:03 <Tomsik> okay, I needed widgetQueueDraw AND -threaded AT THE SAME TIME
13:54:14 <Tomsik> unituitive
13:54:30 <jmcarthur> kuffaar: (->) Foo  has the same monad instance as  Reader Foo
13:54:36 <jmcarthur> kuffaar: (and their implementations are the same)
13:54:42 <aavogt> joe6: it doesn't make sense. Code generated by template haskell is eventually typed, so it doesn't do things the type system stops you from doing
13:54:44 <jmcarthur> kuffaar: for a transformer, though, it's less convenient
13:54:50 <aristid> j-invariant: there are even people who say that good programmers are equally productive in all languages, so there is no reason not to use PHP
13:55:10 <azaq23> j-invariant edwardk: alright, I can see that. I'm asking because I'm learning coq at the moment and it seems a bit hard to get a grasp on, so I can't see why it uses dependent typing. though the tutorials already do stuff like Theorem x : False (where : is haskell's ::)
13:55:18 <j-invariant> aristid: indeed, if you do a course in computer science you will be taught to write PHP which has security exploits in it
13:55:30 <Twey> j-invariant: Hm, yes, I think you're right.  Okay.
13:55:48 <edwardk> azaq23: you can prove way more than you can with traditional types. this is great if you want correctness over ease of use
13:55:54 <j-invariant> azaq23: you can't see why Coq uses dependent types?
13:55:54 <edwardk> in some domains thats very important
13:55:58 <j-invariant> azaq23: s that what you mean
13:55:59 <kuffaar> Haha, I've never come across any CS classes which dealt with web dev or even *urgh* PHP
13:56:11 <j-invariant> kuffaar: you are /very/ lucky :P
13:56:18 <Tomsik> Dependent types are kind of counterproductive
13:56:27 <j-invariant> Tomsik: yeah
13:56:32 <aristid> edwardk: that comonad package from jeff wheeler does not use your Comonad class :/
13:56:33 <j-invariant> so are normal types sometimes
13:56:33 <jmcarthur> j-invariant: this explains quite well a likely reason that people are so against types: http://www.cs.utexas.edu/users/EWD/ewd10xx/EWD1036.PDF
13:56:37 <Tomsik> if you spend as much time writing proof of correctness as you'd spend coding carefully
13:56:49 <j-invariant> cool jmcarthur ill have a look
13:57:08 * hackagebot distributive 0.1 - Haskell 98 Distributive functors -- Dual to Traversable  http://hackage.haskell.org/package/distributive-0.1 (EdwardKmett)
13:57:12 <edwardk> aristid: it predates mine a bit
13:57:13 <edwardk> meh
13:57:16 <jmcarthur> it has nothing to do with types specifically
13:57:23 <azaq23> j-invariant yes, not at the moment, the main tutorial doesn't really go into that, I know only the concept of dependent typing (from a paper on the lambda cube / pure type systems)
13:57:25 <monochrom> Tomsik: you have to call cellLayoutSetAttributes to provide your code for how to display ListStore contents to "cells".
13:57:25 <telephone> ok, I export a typeclass in a module with 'module Module ( Typeclass(..), ...) where ...'. But what if I leave out the (..), what will that mean?
13:57:36 <edwardk> aristid: i had one inc ategory-extras, so i put this together because category-extras was too large of a single dependency
13:57:40 <jmcarthur> j-invariant: the gist is that people don't like change and would rather stick to whatever they find "intuitive" at the time
13:58:05 <jmcarthur> where "intuitive" really just means "familiar"
13:58:05 <aristid> edwardk: yeah, and i think people should use the comonad package :)
13:58:18 <jmcarthur> i've already used the comonad package :D
13:58:25 <kuffaar> Apropos GTK, do you think that there is any reason not to use Qt over GTK for an open source project?
13:58:26 <edwardk> aristid: i'm slowly working over the existing packages getting them to move
13:58:30 <jmcarthur> i did the moment i heard about it, in fact
13:58:36 <kuffaar> And Haskell already has Qt bindings
13:58:53 <jmcarthur> kuffaar: one reason is that some people (like me) hate the Qt look and feel
13:58:53 <j-invariant> azaq23: it's because they let you hbave a computational language which is also expressive
13:58:58 <j-invariant> azaq23: and reflective
13:58:58 <edwardk> the main uses so far are comonad-transformers which is far more comprehensive than category-extras on the topic (and more correct) and comonads-fd
13:59:01 <edwardk> and the streams package
13:59:07 <kuffaar> jmcarthur: Really? I thought it was just native
13:59:15 <edwardk> jmcathur: yay =)
13:59:21 <jmcarthur> Qt may seem native if all you use is KDE
13:59:33 <kuffaar> I use Windows and Gnome only really
13:59:35 <jmcarthur> oh you mean on non-linuxes?
13:59:41 <aristid> edwardk: pointedlist is something already contained in comonad-transformers?
13:59:45 <jmcarthur> i still don't find that Qt apps feel all that native
13:59:55 <jmcarthur> *non-unixes
14:00:14 <jmcarthur> Qt definitely doesn't fit in with all my GTK stuff
14:00:17 <jmcarthur> :\
14:00:24 <edwardk> aristid: not yet, that'll be in streams when its done, there is a manifesto of about 30 different stream types i need to do for that package
14:00:40 <edwardk> aristid: that counts as one of the stream zipper variants
14:00:42 <mreh> is there a trick to generating multiple executables?
14:00:42 <aristid> edwardk: plus you need to add documentation this time :)
14:01:01 <edwardk> aristid: =P i produce the code as fast as i can, docs sometimes come with =P
14:01:02 <mreh> no output will be generated because there is no Main module
14:01:39 <mreh> ah, main-is
14:02:09 * hackagebot comonad 0.7.0 - Haskell 98 comonads  http://hackage.haskell.org/package/comonad-0.7.0 (EdwardKmett)
14:02:45 <mreh> that still doesn't work
14:03:01 <jmcarthur> mreh: only one executable per cabal project right now
14:03:04 <alpounet> jmcarthur, there's some work in Qt for Qt apps to look like GTK apps
14:03:15 <elliott>     No instance for (Data.String.IsString ByteString)
14:03:19 <elliott> what do i need to import for that? Char8?
14:03:27 <azaq23> j-invariant edwardk: reflection as in more-or-less reified types? Yes, of course, that is what dependent typing is. Well, I guess I don't get the whole proving stuff thing and therefore also not the way coq uses it. Best will be I just continue on the tutorials. Thanks.
14:03:48 <jmcarthur> alpounet: that's kind of the point of Qt, actually... to mimick other toolkits in look and feel. i just don't think they succeed as well as i wish they did
14:04:08 <edwardk> the whole point of dependent types is that you can have _types_ which depend on terms in your language. i.e. a vector of length (2 + 3)
14:04:18 <jmcarthur> mreh: oh sorry, i had that wrong.
14:04:28 <jmcarthur> mreh: only one *library* per project
14:04:32 <edwardk> this lets you compute arbitrarily complicated invariants and prove they are correct at _compile time_
14:04:37 <edwardk> so you don't crash at runtime
14:04:59 <mreh> jmcarthur: shall I paste my cabal file?
14:05:03 <jmcarthur> mreh: sure
14:05:06 <alpounet> jmcarthur, iirc, there was some options to pass to your apps to use the GTK look&feel
14:05:08 <edwardk> its not the reification of -types- that is interesting, its that terms bleed into the type level — the reification of 'terms' as it were.
14:05:21 <jmcarthur> alpounet: i've tried it. it doesn't work well
14:05:25 <alpounet> okay
14:06:29 <alpounet> jmcarthur, let's just write a neat GUI haskell library using the native look&feel with a bunch of combinators to generate the layout etc properly, alright? :P
14:06:52 <jmcarthur> alpounet: talk to conal :)
14:06:58 <alpounet> heh yeah
14:07:00 <mreh> hum, not pastebot
14:07:01 <alpounet> guitv
14:07:07 <mreh> http://hpaste.org/43234/lji_cabal
14:07:15 <alpounet> i watched (again) his talk about tangible values
14:07:20 <alpounet> the idea's just great
14:08:10 <jmcarthur> mreh: try "Cabal-version:       >=1.8"
14:08:10 * hackagebot functor-apply 0.7.4.1 - Strong lax semimonoidal endofunctors (Applicative sans pure)  http://hackage.haskell.org/package/functor-apply-0.7.4.1 (EdwardKmett)
14:08:28 <kuffaar> 1.8 pff that's old
14:08:42 * kuffaar has 1.11 installed
14:08:54 <kuffaar> Bleeding edge snobbery
14:09:00 <edwardk> kuffaar: yes, but its good to let your constraints be as minimal as possible =)
14:09:05 <jmcarthur> mreh: i have to do that when my executables depend on the library in the same package. you aren't doing that, but this may help anyway
14:09:11 * hackagebot comonad-transformers 0.7.0 - Haskell 98 comonad transformers  http://hackage.haskell.org/package/comonad-transformers-0.7.0 (EdwardKmett)
14:09:14 <edwardk> most of mine are 1.6 coz thats when they added support for source repo locations
14:09:23 <jeffwheeler> When do Hackage packages' documentation get built? Midnight UTC?
14:09:33 <edwardk> jeffwheeler: ~ every 12 hours
14:09:46 <jeffwheeler> edwardk: I'm always impatient. :P
14:10:06 <jeffwheeler> But hey, haskell-server is on Hackage, right? ;)
14:10:21 <edwardk> jeffwheeler: thats why i started adding links to the source repo ;)
14:10:23 <mreh> I was using cabal init!
14:10:29 <kylesmith> parsexyz :: Floating a => String -> [[a]]
14:10:31 <kylesmith> parsexyz = map (map (\x -> read x :: Float).words).drop 2.lines
14:10:33 <kylesmith> "Couldn't match expected type `a' against inferred type `Float'"
14:10:34 <mreh> is it pessemistic?
14:10:37 <kylesmith> Anyone know why this won't work?
14:10:49 <jmcarthur> mreh: it always sets 1.2
14:10:50 <jeffwheeler> edwardk: I added source, I like to see it successfully build on Hackage before I breathe out
14:10:58 <edwardk> yeah
14:11:11 <dibblego> cabal check is handy
14:12:28 <Twey> kylesmith: You want a Floating a => a, but you returned a Float
14:13:12 * hackagebot comonads-fd 0.7.0 - Comonad transformers using functional dependencies.  http://hackage.haskell.org/package/comonads-fd-0.7.0 (EdwardKmett)
14:13:39 <Twey> parsexyz = map (map read . words) . drop 2 . lines
14:13:58 <Twey> You don't need the type signature on read at all — it's covered by your function's type signature
14:14:08 <Twey> Though you do need to add Read a
14:14:15 <kylesmith> ahh, thanks. I thought I needed it
14:14:30 <Twey> You would if you hadn't added a signature for the function
14:15:12 * hackagebot streams 0.3.1 - Various Haskell 2010 stream comonads  http://hackage.haskell.org/package/streams-0.3.1 (EdwardKmett)
14:15:21 <js__> hi i am working through the online edition of realworldhaskell with ghci and i do not understand why :type (5, 3) yields (5, 3) :: (Num t, Num t1) => (t, t1) rather than what i expected which is (5, 3) :: (Integer, Integer). 
14:15:47 <js__> can anyone explain or recommend a resource? thanks!
14:16:08 <edwardk> js: the numerical literals in haskell are overloaded.
14:16:12 * hackagebot adjunctions 0.4.1 - Adjunctions  http://hackage.haskell.org/package/adjunctions-0.4.1 (EdwardKmett)
14:16:17 <edwardk> js: most languages '2' means an int 2
14:16:31 * jeffwheeler is wondering how many packages edwardk is uploading
14:16:40 <edwardk> in haskell we choose to let your individual numerical types tell you what 2 means, this way you can use 2 as a Float or as a Complex Double
14:16:48 <edwardk> without having to have special syntax for each
14:16:56 <edwardk> jeffwheeler: changed something way down in the chain of dependencies =)
14:17:06 <shachaf> edwardk: Really? I'd think it's overloaded in some sense for most languages.
14:17:07 <edwardk> jeffwheeler: i _think_ that should stabilize it
14:17:20 <js__> k thx :) edwardk++
14:17:20 <jeffwheeler> edwardk: what'd you change?
14:17:21 <edwardk> shachaf: nah, most give 1 as an int, and then provide implicit coercions
14:17:35 <shachaf> edwardk: Ah, fair enough.
14:17:39 <edwardk> jeffwheeler: i factored Data.Distributive into its own 'distributive' package since it no longer mentions comonads
14:17:56 <jeffwheeler> edwardk: ah
14:18:06 <edwardk> and then because that was a breaking api change i had to change all the stuff downstream to comply with the PVP
14:19:13 <jeffwheeler> edwardk: also, you haven't uploaded distributive to github yet, so it's a 404 right now
14:19:20 <edwardk> yeah
14:19:21 <edwardk> thats next
14:19:26 <jeffwheeler> sweet :)
14:20:25 <edwardk> done
14:21:08 <kuffaar> Oh, no! You mentioned git in #haskell! Massive darcs vs. git flamewar incoming!
14:21:25 <edwardk> kuffaar: nah, the darcs boys know they are beat ;)
14:21:32 <kuffaar> :D
14:21:52 <edwardk> i love darcs. i just also like the github community
14:22:08 <jeffwheeler> edwardk: that seems about right; github is just so pretty, but darcs UI is nice
14:22:32 * Saizan is asocial anyway
14:23:11 <edwardk> Saizan: i like github because it has a better workflow for collaboration. someone just forks the repo, makes their changes and pings you to pull. no emailing patches
14:23:29 <edwardk> the barrier to entry is so much lower than you actually get collaboration
14:23:35 <edwardk> er that you
14:24:09 <kuffaar> I never work with other people really
14:24:31 <edwardk> i may have gone a little nuts in terms of breaking up my projects after category-extras though
14:24:32 <Saizan> though there's the git barrier, and the "which branch should i work on" one
14:24:35 <aristid> kuffaar: you don't need to. they can work on their own, and propose that you merge some patchset. you don't need to communicate all that much.
14:24:42 <edwardk> Saizan: 'master' =)
14:25:01 <dibblego> edwardk, will there still be a category-extras that puts them all back together? :)
14:25:03 <mreh> i changed the cabal number, cabal didn't complain
14:25:07 <mreh> no reconfigure required
14:25:10 <Saizan> edwardk: not everyone agrees with that :)
14:25:16 <kuffaar> aristid: Yeah, but I mean I still never work with other people really. People don't want to use/change my code.
14:25:18 <edwardk> dibblego: nah, its more like 50+ little packages
14:25:35 <edwardk> dibblego: each one able to be digested in its own right
14:25:37 <kuffaar> If they want something modified they just tell me so
14:25:47 <kuffaar> And then I may or may not code it
14:26:26 <edwardk> Saizan: i'm merely talking about using it as a darcs replacement. for that the single master + github distribution works perfectly. other projects like dibblego's scalaz are bigger and more mature and have multiple branches, etc. and that works fine for those more stable projects
14:26:29 <jre2> what's the best way to convert 4 bytes into an unsigned integer?
14:26:48 <dibblego> @hoogle [Word8] -> Integer
14:26:48 <lambdabot> Data.List genericLength :: Num i => [b] -> i
14:26:48 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
14:26:48 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
14:27:04 <edwardk> jre2: there is always Storable
14:27:17 <edwardk> jre2: but you then need to care about endianness, etc. 
14:27:30 <edwardk> folding over them and multiplying by 256 and adding works well =P
14:27:48 <jre2> edwardk: folding and multiplying by powers of 256 is how I'm doing it right now ;)
14:28:33 <jre2> I just figured it would simplify things to use some library
14:29:01 <edwardk> jre2: nah, i thought there was something in Numeric. but apparently i'm mistaken. just the machinery to extract digits from a float
14:29:01 <monochrom> Tomsik: example http://hpaste.org/43235/gtk_liststore_treeview  A table of 2 columns (fields) n::Int and b::Bool, 3 rows. Every 3 seconds, a row is modified. The display is updated properly.
14:30:47 <Tomsik> well, I'm using async concurrent gtk
14:30:58 <Tomsik> but found the solution already
14:31:25 <Tomsik> it's just that -threaded is necessary just as commanding widgets to redraw queue
14:31:40 <monochrom> oh haha yeah
14:32:58 <jmcarthur> edwardk: yeah, i wish patch-tag had a one-click "fork" button like github does
14:33:42 <jmcarthur> i haven't even tried darcsden yet. my understanding is that it's very minimal though
14:34:04 <jmcarthur> ooh, darcsden has a fork button
14:34:07 <sm> http://darcsden.com has received some nice polish lately and works well
14:34:20 <jmcarthur> i might switch over for that fork button
14:34:21 <sm> except, there's a problem getting large repos onto it currently
14:34:31 <jmcarthur> good thing none of mine are large
14:34:55 <jmcarthur> wow, even an issue tracker
14:35:31 <alexsuraci> jmcarthur: darcsden started minimal, it's growing though
14:35:46 <alexsuraci> doing the release early, release often model :)
14:36:22 <jmcarthur> alexsuraci: awesome
14:36:32 <iph2> noob question here: when designing a program in the early stages, how do I know whether to make some concept a type or a type class? I get the (naive) impression that an ideally extensible program would have everything as type classes.
14:36:38 <jmcarthur> just registered. i'll stick a repo on it later tonight to try it out
14:36:48 <jmcarthur> alexsuraci: keep it up!
14:36:57 <alexsuraci> jmcarthur: cool, let me know if you run into anything strange
14:37:02 <jmcarthur> will do
14:37:55 <sm> and unlike github, you can hack on it.. I assume
14:38:14 <monochrom> make a type. generalize to type class when the generalization is needed and you know generalize to what. extensibility is often a lie, you don't even know the future.
14:38:19 <jmcarthur> alexsuraci: what is the "bootstrap" field for? give it a repo url and it pulls from it initially?
14:38:28 <alexsuraci> jmcarthur: yeah, exactly
14:38:31 <jmcarthur> cool
14:39:02 <mreh> I can't find any change log for cabal versions
14:39:11 <edwardk> jmcarthur the problem is the kind of workflow that deals with merging multiple streams (like the ones you get from forking) is precisely what darcs hates
14:39:27 <mreh> >= 1.8 isn't sufficient to make multiple executables
14:39:30 <mikeg> Is there a more monadic/simpler way to write this, for more levels of fromMaybe? f x = fromMaybe (fromMaybe "" (h x)) (g x) 
14:39:39 <mikeg> :t fromMaybe (fromMaybe "" (h x)) (g x)
14:39:39 <jmcarthur> edwardk: what do you mean? i've always found pulling from multiple repos enjoyable with darcs
14:39:40 <lambdabot>     No instance for (SimpleReflect.FromExpr (Maybe [Char]))
14:39:40 <lambdabot>       arising from a use of `h' at <interactive>:1:25-27
14:39:40 <lambdabot>     Possible fix:
14:40:11 <edwardk> jmcarthur: its the only situation left that can lead to exponential patch fighting
14:40:21 <edwardk> jmcarthur: most of the time its fine
14:40:22 <j-invariant> :t \h g x -> fromMaybe (fromMaybe "" (h x)) (g x)
14:40:22 <lambdabot> forall t. (t -> Maybe [Char]) -> (t -> Maybe [Char]) -> t -> [Char]
14:40:26 <Saizan> g x `mplus` h x `mplus` return ""
14:40:46 <mikeg> ooh that's much nicer, thanks :)
14:40:50 <Saizan> and fromJust i guess..
14:40:52 <edwardk> gx <|> hx <|> pure ""
14:41:21 <jmcarthur> edwardk: well, i know it's still around in some form, but i've not run into that since darcs 1.
14:41:51 <Saizan> or fromMaybe "" (g x `mplus` h x)
14:42:59 <jmcarthur> alexsuraci: bootstrapping a repo from patch-tag gave me a 504, which i suppose isn't that strange, but since i just got a generic error page instead of a nice looking report i figured i should report that as "something strange"
14:43:13 * sm reported it
14:43:15 <alexsuraci> jmcarthur: patch-tag or darcsden?
14:43:42 <jmcarthur> alexsuraci: made a new repo on darcsden and tried to bootstrap it with a repo on patch-tag
14:43:48 <jmcarthur> alexsuraci: darcsden gave the error
14:43:52 <alexsuraci> jmacarthur: yeah, gigantic repositories can be a pain. darcsden only has 520MB of memory, which darcs will happily eat up while applying
14:44:25 <alexsuraci> i may get around it by allowing archives to be uploaded or something
14:44:40 <alexsuraci> jmcarthur: how large was the repo?
14:44:48 <Jesin> @src Data.Foldable.foldl
14:44:49 <lambdabot> Source not found. My pet ferret can type better than you!
14:44:53 <Jesin> lol
14:44:55 <Jesin> eh
14:45:17 <Jesin> in the Foldable class in Data.Foldable
14:45:22 <Jesin> foldl is defined like this:
14:45:26 <Jesin> foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z
14:45:41 <Jesin> I just wonder if this might be nicer:
14:45:42 <jmcarthur> alexsuraci: i just pulled it myself and maximum residency was about 200 kilobytes (darcs 2.5)
14:45:45 <jmcarthur> alexsuraci: very small repo
14:45:52 <alexsuraci> weird
14:46:00 <jmcarthur> alexsuraci: http://patch-tag.com/r/jmcarthur/comonad-random
14:46:05 <alexsuraci> thanks
14:46:11 <Jesin> foldl f z t = appEndo (foldr (flip mappend . f) mempty (Endo . flip f) t) z
14:47:57 <alexsuraci> jmcarthur: could you try again, and I'll monitor the vps?
14:48:17 <alexsuraci> actually it did create the repo, it's just empty
14:48:26 <alexsuraci> http://darcsden.com/jmcarthur/comonad-random
14:48:30 <jmcarthur> alexsuraci: i just tried pushing and it's locked
14:48:38 <alexsuraci> ah yes. another part of the issue.
14:48:50 <Jesin> ...hmm.
14:48:54 <alexsuraci> jmcarthur: removed the lock
14:49:02 <jmcarthur> alexsuraci: success
14:49:09 <ddarius> monochrom: This is rather late, but YHC(?) was originally written in CL.
14:49:23 <alexsuraci> so just the bootstrap crashed and burned. I tried it locally and it worked fine here, didn't take long.
14:49:32 <monochrom> nice
14:49:37 <jmcarthur> alexsuraci: i could try creating another if you want to watch
14:49:44 <alexsuraci> jmcarthur: sure, thanks
14:49:46 <Jesin> why do we even have Endo?
14:49:49 <jmcarthur> alright, gimme a sec
14:50:12 <Jesin> why not just instance Monoid (a -> a) where {mempty = id; mappend = (.)}
14:50:22 <dibblego> Jesin, because Monoid b => a -> b 
14:50:41 <ddarius> Jesin: Actually, that -was- the original Monoid instance for functions.
14:50:44 <jmcarthur> alexsuraci: alright, i'm submitting it now
14:50:51 <ddarius> Which when it changed broke my code in interesting ways.
14:50:52 <alexsuraci> jmcarthur: k
14:52:04 <jmcarthur> alexsuraci: 504
14:52:28 <alexsuraci> jmcarthur: didn't see anything weird here. hmm.
14:52:50 <Jesin> hmm, ok
14:59:12 <jmcarthur> alexsuraci: another strange thing, btw:   http://darcsden.com/jmcarthur/ai-engine/changes/page/9    "Page 9 of 0"   <-- navigable with "url hacks"
14:59:14 <jmcarthur> *without
15:00:03 <alexsuraci> yeah, I haven't gotten to minor things like that since it fails "sanely" anyway
15:00:45 <jmcarthur> anyway, don't playing with it for now. thanks for being responsive :)
15:00:50 <jmcarthur> *done
15:01:02 <alexsuraci> np :)
15:09:12 <ryanakca> Why do I get unexhaustive pattern in http://hpaste.org/43236/slice ? My guard has an otherwise that should catch everything else, no? (I'm writing a slice function that takes a slice of a list)
15:10:38 <Jesin> is there any point in having MonadPlus?
15:10:43 <jmcarthur> ryanakca: if you get rid of the n+k pattern it doesn't complain
15:11:11 <jmcarthur> Jesin: yes. it has stronger properties than Monoid
15:11:19 <Jesin> why?
15:11:24 <Jesin> or, like what?
15:11:25 <jmcarthur> because sometimes you want that
15:11:35 <jmcarthur> Monoid by itself doesn't say anything about Monad
15:11:43 <Jesin> umm
15:11:50 <jre2> Jesin: yea, it's quite useful to write up something in the Maybe monday, right? So it's even more useful to be able to cast that to an Either or IO or whatever
15:11:51 <Jesin> can't you just have two type constraints, then?
15:11:51 <jmcarthur> but MonadPlus specifies some properties about bind
15:12:11 <jmcarthur> Jesin: it's stronger than Monoid and Monad combined
15:12:18 <ddarius> ryanakca: slice (1:[]) 0 doesn't match.
15:12:37 <jmcarthur> Jesin: see the properties here: http://www.haskell.org/haskellwiki/MonadPlus
15:13:24 <Jesin> hmm
15:13:38 <Jesin> wouldn't it be possible to have something like
15:13:41 <ryanakca> jmcarthur, ddarius: Fixed it, thanks
15:14:15 <Jesin> (Monad m, Monoid (m a)) => MonadPlus m
15:14:46 <jmcarthur> Jesin: you mean in the class definition?
15:15:10 <jmcarthur> Jesin: that wouldn't work because "a" doesn't appear on the right side of "=>"
15:16:16 <Jesin> is there some extension
15:16:20 <Jesin> like explicit forall
15:16:24 <Jesin> that would allow that?
15:16:34 <Jesin> or -XFlexibleInstances or something
15:16:41 <Jesin> ...eh.
15:17:19 <Jesin> or
15:17:23 <jmcarthur> Jesin: not possible as far as i am aware
15:17:29 <Jesin> hmm.
15:18:07 <Jesin> (Monad m, forall a. Monoid (m a)) => MonadPlus m
15:18:10 <Jesin> doesn't work?
15:18:23 <Jesin> =/
15:18:28 <jmcarthur> Jesin: i do with we had FunctorMonoid or something, then it could be a superclass of MonadPlus and Alternative
15:18:55 <jmcarthur> in fact, i don't really see much reason for Alternative to exist. i don't think it imposes anything stronger than Monoid + Applicative
15:19:09 <jmcarthur> maybe it does and i just didn't know about it though
15:19:14 <Jesin> hmm... ok
15:19:33 <jmcarthur> s/i do with/i do wish/
15:20:04 <jmcarthur> oh, maybe it does. empty *> a == empty, perhaps
15:20:31 <Jesin> umm, jmcarthur
15:20:33 <jmcarthur> not in the docs though
15:20:48 <Jesin> the only law that MonadPlus gives that's consistently satisfied
15:20:50 <Jesin> is mzero >>= k = mzero
15:21:05 <jmcarthur> Jesin: yeah, and even that one isn't implied by Monoid + Monad alone
15:21:10 <Jesin> =/
15:21:12 <jmcarthur> hence MonadPlus's existence
15:21:31 <Jesin> well
15:21:52 <jmcarthur> the inconsistent use of MonadPlus does suck
15:22:43 <Jesin> ooh
15:22:44 <Jesin> http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
15:22:48 <Jesin> ok
15:22:55 <jmcarthur> yeah, that's been around for a while now
15:24:03 <jmcarthur> Jesin: mzero >>= k = mzero isn't the only law that's consistent used in the standard libs though. the monoid laws are still obeyed as well
15:24:12 <jmcarthur> *consistently
15:24:22 <Jesin> well, yes.
15:34:27 <Jesin> but
15:34:38 <Jesin> the monoid laws
15:34:52 <Jesin> doesn't that mean that every MonadPlus instance is trivially also a Monoid
15:35:09 <jmcarthur> yes
15:35:16 <jmcarthur> well, aside from kind issues
15:35:43 <jmcarthur> @instances MonadPlus
15:35:44 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
15:35:47 <Jesin> instance MonadPlus m => Monoid (m a) where {mempty = mzero; mappend = mplus;
15:35:49 <Jesin> }
15:36:07 <Jesin> ^ is that valid code?
15:36:45 <jmcarthur> Jesin: you could do that with some extensions, but then you could never define another Monoid instance for types of the form (a b)
15:37:30 <jmcarthur> and in fact you could only do that if there were no instances of that form in the first place
15:37:34 * ddarius considers downloading bondi.
15:37:47 <Jesin> =/
15:37:52 <jmcarthur> unless OverlappingInstances allows it i guess...
15:38:00 <jmcarthur> but i don't recommend that avenue
15:38:07 <djahandarie> ddarius, how do you manage your papers
15:39:15 <ddarius> djahandarie: You make me laugh.
15:40:32 <Jesin> "In general, GHC requires that that it be unambiguous which instance declaration should be used to resolve a type-class constraint. This behaviour can be modified by two flags: -XOverlappingInstances and -XIncoherentInstances"
15:40:49 <jmcarthur> Jesin: those should sound scary :)
15:41:00 <Jesin> incoherent does especially, yes
15:42:40 <ddarius> djahandarie: I have a ToRead directory, and a Read directory and I sort the ToRead by date descending.
15:43:21 <ddarius> I also use Google Desktop occasionally.
15:44:41 <djahandarie> lol
15:45:06 <djahandarie> Do you even rename them from 10001.0101010100.0--192309.pdf or whatever format they are in?
15:45:24 <ddarius> No.
15:45:30 <aristid> djahandarie: why do people even give them such stupid names?
15:45:41 <ddarius> Though, CiteSeer used to use more reasonable file names.
15:45:51 <ddarius> aristid: They don't.  Systems do.
15:46:02 <ddarius> aristid: People give things stupid names like thesis.pdf.
15:46:14 <aristid> right.
15:46:21 <aristid> both people and systems could do better.
15:46:39 <djahandarie> ddarius, so... when you want to find a paper after reading it, you don't? :P
15:46:49 <aristid> djahandarie: google desktop?
15:47:12 <ddarius> djahandarie: Usually I can remember about when and about what topics are I explored before/after a paper to get approximately where I want.
15:47:40 <djahandarie> lol this system does not sound efficient
15:47:48 <ddarius> I mostly use Google Desktop when I'm looking for a paper I read like seven years ago, usually for reference for someone else.
15:48:23 <djahandarie> I think there are things out there that organize papers for you
15:48:25 <ddarius> The problem is there's a large up-front cost of fixing it.
15:48:54 <ddarius> djahandarie: Yes.  There's mendeleydesktop which I've used.  It's mostly a pile of crap, though I do now have a bibliography for a large portion of my papers.
15:49:21 <ddarius> Google Desktop works better for actually finding stuff.
15:51:17 <ddarius> There was some Mac software that also was supposed to organize stuff.  I don't know how good it is, but when advertised "organize dozens of papers," I laughed.
15:51:43 <djahandarie> lol
15:51:55 <djahandarie> I think ezyang mentioned one at some point which he liked but I don't remember it
15:54:12 <aristid> djahandarie: you need a tool to organise your irc
16:03:37 <parcs> is it safe to strip the binaries generated by ghc? i see size reductions up to 50% in doing so. it looks too good to be free of consequence...
16:04:27 <Saizan> it's free
16:04:32 <Saizan> *safe
16:05:25 <Adamant> try calibre
16:05:36 <parcs> Saizan: okay, good :)
16:05:37 <Adamant> great for ebook/edoc management
16:05:45 <Adamant> but a lot of upfront work
16:06:40 <jre2> Adamant: what was that in response to?
16:06:59 <jre2> (although I agree, I use it as well)
16:07:04 <kylesmith> Can anyone help me with this?  http://hpaste.org/43237/adjugate3
16:07:10 <Adamant> jre2: doc stuff
16:07:48 <jre2> Adamant: ah, I see it now after scrolling up a bit
16:09:51 <elliott> Is there a good way to deal with text in an unknown encoding?
16:10:05 <elliott> Specifically it is most likely either UTF-8 or that common Windows-15something encoding.
16:11:42 <edwardk> elliot: ibm's icu library provides statistical tools to analyze text and determine encoding, and text-icu can use it to convert to Data.Text
16:12:07 <mikeg> kylesmith: that's building [[[a]]] instead of [[a]]
16:12:23 <kylesmith> d'oh!
16:12:56 <edwardk> is there a good library out there with a MonadArray class or some such that provides access to a type family for MArray's in a given monad?
16:13:55 <edwardk> closest i have is Data.Primitive.Array out of primitive.
16:14:22 <kylesmith> mikeg: I took out the extra []'s, and it still gives me the same error
16:16:20 <yip> I'm trying to implement tryTakeMVar in IOSpec, but i'm stuck
16:16:22 <yip> http://hackage.haskell.org/packages/archive/IOSpec/0.2.2/doc/html/src/Test-IOSpec-MVar.html
16:16:42 <yip> What should the TryTakeMVar  constructor for MVarS a look like?
16:17:15 <mikeg> you're missing commas too... why don't you generalize the function for NxN matrices?
16:17:33 <saiko-chriskun> anyone give some advice by any chance? http://bit.ly/hzAq6i
16:18:05 <elliott> is WAI the "thing to use"? the scgi library says it is deprecated in favour of it.
16:18:07 <elliott> but fastcgi doesn't.
16:20:07 <yip> I have: TryTakeMVar Loc (Maybe Data -> a)
16:20:11 <yip> but I'm not sure if it's correct
16:20:26 <ddarius> That may work, though I think it would actually be better to use just Data.
16:21:17 <yip> why?
16:22:38 <ddarius> From what I can tell, Data is just for storing stuff in the heap, so you're going to end up getting a Data anyway.
16:23:04 <yip> ddarius: but if the location is empty then i have to return "Nothing" right away
16:23:41 <ddarius> yip: The only difference between your code and the takeMVar code (besides the return type) is that you will return something different in the Nothing case (and wrap with a Just in the non-Nothing case.)
16:24:01 <yip> hm...
16:24:04 <ddarius> In fact, the code should be simpler than takeMVar's step, as you should be able to just immediately return the contents of the MVar.
16:24:23 <yip> thanks i'll try
16:25:30 <kylesmith> mikeg: fixed the commas and it works, thanks.  I'll definitely generalize once I get something working
16:25:33 <ddarius> Actually, I guess if lookupHeap is giving you a Maybe Data anyway, then Maybe Data will be better.
16:26:55 <yip> hm... now i'm confused
16:28:11 <aristid> elliott: i think using WAI is probably a good idea
16:28:58 <ddarius> step will look like: do var <- lookupHeap; when (isJust var) $ emptyLoc loc; return (Step (fmap t var)) or alternatively return (Step (t var)), but then that allows t to do more than it should.
16:29:07 <ddarius> So, I'm back to voting for the Data -> a version.
16:29:11 <elliott> aristid: Okay. Even if it scares me.
16:29:37 <aristid> elliott: why?
16:29:41 <elliott> It's modern!
16:29:43 <elliott> Modern things are scary.
16:30:00 <elliott> Although converting charsets is scarier.
16:30:05 <ddarius> elliott: You should go to an old-fashioned dentist or doctor.
16:30:06 <elliott> So right now I am exceedingly scared.
16:30:08 <aristid> elliott: yes. use Go, it's basically just ALGOL with a new name.
16:30:16 <elliott> aristid: That sounds reassuring.
16:30:19 <ddarius> aristid: ALGOL was better.
16:31:05 <aristid> ddarius: now that's a devastating statement (unless, which i somehow can imagine, you think ALGOL is a decent programming language)
16:31:29 <elliott> the ALGOL that Go is most often compared to, I think 68, is, uh
16:31:33 <elliott> ... featureful ...
16:31:50 <elliott> ALGOL is really three languages with the same name.
16:33:22 <ddarius> "ALGOL" usually means ALGOL 60.
16:33:27 <elliott> Yeah.
16:33:34 <elliott> Did ALGOL 60 have the concurrency stuff?
16:35:48 <tolkad> What do I do if I don't want exceptions that happen in a forked thread to cause output?
16:36:36 <yip> ddarius: i'm using (Data -> a), but i can't get step to compile
16:36:55 <tolkad> like if I'm writing an HTTP server and I don't really care if some exception occurred when server a client a request but I don't want the HTTP server to output anything to the command line
16:37:06 <ddarius> elliott: Probably not as it didn't even have IO.
16:37:14 <elliott> right
16:37:22 <elliott> algol 68 is the one with that long article comparing it to Go without naming i
16:37:23 <elliott> t
16:38:29 <tolkad> I'm just worried I'll end up breaking a ^C or something
16:38:34 <tolkad> how can I do this safely?
16:39:04 <ddarius> tolkad: Catch them and handle them as you want.
16:41:04 <monochrom> serve a client by a new thread. the new thread catches all exceptions and ignores (and cleans up). then you will have no output.
16:41:28 <tolkad> oh I thought that would break ^C
16:41:41 <tolkad> thanks
16:41:45 <monochrom> ^C is probably better handled by putting the whole process in the background, detaching from tty, etc.
16:42:21 <monochrom> if ^C is seen by your process, one thread will be chosen to receive it, and no one knows which thread.
16:42:24 <aristid> i guess there is some package for daemonisation
16:42:51 <monochrom> worst comes to worst you can use a shell script to daemonise your haskell program.
16:42:52 <yip> in my app, ^C always causes an exception to be raised in the main thread
16:42:58 <tolkad> aristid: I usually just put the "&" after the command
16:43:21 <aristid> tolkad: that doesn't fully detach it
16:44:25 <elliott> aristid: & disown
16:44:31 <tolkad> so a UserInterrupt exception is thrown to a random thread? how does it get to the main thread?
16:44:31 <elliott> progs shouldn't daemonise themself imo
16:44:43 <monochrom> for ^C which is SIGINT you could also use System.Posix.Signal to say "ignore SIGINT" if that's your cup of tea
16:45:03 <aristid> elliott: why not? if it's an option.
16:45:32 <elliott> aristid: --dameonise is longer than &disown
16:45:37 <elliott> and also adds more code bloat
16:45:37 <monochrom> oh oops, ^C goes to the main thread.
16:45:38 <aristid> -d
16:45:38 <elliott> what's the point
16:45:40 <tolkad> yip: you might not be using -threaded
16:45:45 <elliott> aristid: <elliott> and also adds more code bloat
16:45:46 <elliott> what's the point
16:45:53 <aristid> elliott: which shells support &disown?
16:46:06 <elliott> aristid: bash, zsh, probably even ksh
16:46:10 <elliott> everything basically
16:46:22 <elliott> it's the same as
16:46:23 <elliott> $ foo &
16:46:24 <elliott> $ disown
16:46:28 <elliott> just in one go
16:46:31 <elliott> i use it all the time
16:46:47 <monochrom> but catching UserInterrupt is still wrong because there is no such thing as "resume from exception". you're better off with "ignore that signal" or "it cannot happen".
16:47:34 <yip> tolkad: i definitely am
16:47:44 <Rotaerk> hmm, I'm writing a function in F# that has this basic signature, and trying to name it... (List v -> a) -> (v -> a -> Bool) -> List v -> (a, List v)
16:47:59 <elliott> Rotaerk: welcome to #haskell!
16:48:11 <Rotaerk> the concept is independent of the language :P
16:48:20 <monochrom> echo '$1 & disown' > svchost  :)
16:48:25 <Rotaerk> lol
16:48:39 <Rotaerk> I would use haskell, but I like certain libraries available via .NET..
16:48:51 <Rotaerk> so I compromised/gave-in
16:48:52 <yip> Rotaerk: you can call .NET functions from haskell
16:49:02 <ddarius> Rotaerk: And what is the function supposed to do?
16:49:31 <tolkad> monochrom: if I do « main = do { forkIO (throwIO (ErrorCall  "x")); forever getChar } » my program will output an error message about x and then run forever
16:49:35 <elliott> monochrom: enterprise!
16:49:41 <tolkad> monochrom: the default behavior is to recover from exceptions
16:49:52 <ddarius> tolkad: No.
16:49:53 <Rotaerk> ddarius, say I have a list of records R with properties X and Y, and I want to get all R for which X is greater than the average Y
16:49:59 <ddarius> tolkad: The thread that throws the exception dies.
16:50:04 <Rotaerk> ddarius, i.e. it's a filter dependent on an aggregation of the list
16:50:07 <tolkad> ddarius: yeah but the program doesn't
16:50:11 <Rotaerk> that's what this function is supposed to do
16:50:14 <elliott> monochrom: I upgraded your program: echo 'while :; "$@" & disown' >svchost
16:50:29 <Rotaerk> yip, hmm how cumbersome is it?
16:50:33 <tolkad> ddarius: so if a UserInterrupt is thrown to a random thread, how does the main thread get killed?
16:50:36 <Rotaerk> say I wanted to use, say, the XNA framework
16:50:43 <Rotaerk> would I have to do a bunch of work just to bridge the gap
16:50:52 <monochrom> hmm what does the "while:" do there?
16:51:08 <elliott> monochrom: : is the same as true
16:51:11 <elliott> so it's just "while true;"
16:51:24 <elliott> oh I forgot do and done
16:51:31 <elliott> also
16:51:32 <monochrom> I see! nice.
16:51:38 <elliott> the disown is a bit of a mistake
16:51:44 <elliott> in that that creates processes forever :D
16:51:49 <Rotaerk> ddarius, I'm considering "filterByAggregate" as the name
16:51:51 <yip> Rotaerk: http://haskell.forkio.com/dotnet
16:51:57 <elliott> monochrom: echo '(while :; do "$@"; sleep 5; done) & disown' >svchost
16:51:58 <elliott> there we go!
16:52:14 <monochrom> anyway if one thread aborts and other threads go on, that is not my idea of "recover". that is only shielding.
16:52:19 <elliott> i think it's ready for google now
16:52:44 <ddarius> Rotaerk: filterWithAggregate seems slightly better.
16:52:51 <tolkad> so I have been told that: 1. an exception thrown in a haskell thread kills the thread but not the program. 2. a UserInterrupt exception is thrown to a random haskell thread if it occurs.
16:52:51 <tolkad> I can conclude from this that UserInterrupts are not guaranteed to terminate the program?
16:52:56 <Rotaerk> hmm yea
16:53:14 <tolkad> only if it happens to be thrown to the main thread will it terminate the program?
16:53:34 <monochrom> well I made a mistake. like I said later, UserInterrupt goes to the main thread
16:53:56 <Rotaerk> yip, interesting.
16:54:06 <monochrom> but people are too busy arguing to read.
16:54:51 <ddarius> monochrom: There is only one person that needs to have read it.
16:56:08 <tolkad> monochrom: oh sorry I didn't notice
17:04:34 <tolkad> in the future all communication will be monitored by natural language processing algorithms. gross grammatical incorectness will be illegal
17:04:54 <kuffaar> incorrectness*
17:05:01 <monochrom> haha
17:05:14 <kuffaar> No, it's not funny
17:05:20 <kuffaar> That was lexicon, not grammar!
17:05:23 <j-invariant> "grammar" is a type system
17:05:52 <koninkje> We'll have to get NLP algorithms to respect grammar first
17:06:16 <kuffaar> We'll need a strong AI
17:06:17 <koninkje> As it is they produce... "special" output
17:06:20 <kuffaar> Written in Common Lisp
17:06:32 <koninkje> ha!
17:06:33 <kuffaar> CL is perfect for coding AIs as we all know
17:06:42 <kuffaar> The Google contest demonstrated this
17:06:51 <koninkje> I thought Prolog was perfect for coding strong AI?
17:07:02 <monochrom> was
17:07:19 <kuffaar> No, Prolog is for tackling linguistic problems
17:07:23 <tolkad> strong AI.. that's just propositional calculus right?
17:07:29 <kuffaar> No
17:07:33 <monochrom> Yes
17:07:34 <j-invariant> koninkje: LOLOL
17:09:04 <koninkje> Amr Sabry just gave a great talk on how quantum mechanics is just Prolog (if we replace union by symmetric difference)
17:09:04 <tolkad> kuffaar: strong AI be smart computer which being is logical so therefor the strong AI be logical which logical is be propositional calculus QED
17:09:19 <tg_> whoa, engrish?
17:09:38 <tg_> koninkje: oh really? As a physicist, I'm skeptical. ;)
17:09:57 <ddarius> koninkje: That presumably coincides with the various "quantum logics"
17:10:05 <koninkje> tg_: well, once you generalize QM and think aboutfields other than the complex numbers
17:10:37 <tolkad> kuffaar: guess I just proved you wrong huh
17:10:38 <koninkje> the example was for the boolean field
17:10:41 <j-invariant> koninkje: is there a video?
17:10:46 <j-invariant> I would lkei to watch that
17:11:00 <monochrom> kuffaar: just say yes. :)
17:11:19 <koninkje> I don't think so, but there are some papers. 
17:11:43 <tg_> koninkje: sure, and I advocate considering fractal groups instead of the standard model groups, but I wouldn't ever make a statement that crazy ;)
17:11:50 <jmcarthur> everybody knows that lisp is makes stronger AI than prolog
17:12:00 <jmcarthur> *lisp makes
17:12:18 <tg_> koninkje: to be specific, does this person say quantum mechanics is prolog, or quantum field theory is prolog?
17:12:23 <kuffaar> monochrom: Why?
17:12:33 <tolkad> jmcarthur: keep be reading my sentences and it is be happening more often hMM??? : )))
17:12:45 * ddarius considers trying the "Mysterious Flavored Chicken."
17:13:07 * tg_ wonders if mysterious is a flavor or simply an adjective
17:13:31 <koninkje> tg_: He says, when we choose appropriate fields other than C we can demonstrate most of the complexities/oddities of QM, but in a simpler setting where we may have a better chance of understanding them
17:13:42 <kuffaar> monochrom: Maybe it won't even be digital!
17:13:43 <koninkje> e.g., superdense coding, teleportation,...
17:14:18 <ddarius> tg_: As an adjective and not a flavor, it would require a comma.
17:14:29 <koninkje> The boolean field (with xor & and) suffices to get interference, superdence coding, teleportation, etc...
17:14:56 <koninkje> ...but while it's mathematically "the same", we've yet to show the parallelism that arises with QM
17:15:00 <kuffaar> It would be baffling if they managed to run a strong AI on some crappy x86 box from 2020
17:15:08 <j-invariant> koninkje: "Reasoning about General Quantum Programs over Mixed States"?
17:15:46 <koninkje> the standard example showing that we can do things in one unit time in QM what takes two units in Classical, doesn't transport to the boolean field
17:15:58 <tolkad> koninkje: teleportation? I can use prolog for that?
17:16:11 <tg_> tolkad: what have we been doing all this time?
17:16:18 <tg_> a shame, for sure
17:16:24 <koninkje> tolkad: Ony once you hack Prolog to use symmetric difference instead of union
17:16:38 <tg_> can you link the video at least?
17:17:09 <ddarius> tg_: Solving n-queens for small values of n.
17:17:10 <koninkje> j-invariant: Yeah that's one of them
17:17:27 <andy_> is there is reason there isn't a utf8 in the Get monad, other than no one has bothered yet?
17:17:34 <koninkje> j-invariant: there's another that's not by Amr, but which showed up litterally a week after they were discussing the topic
17:17:34 <andy_> i wonder because i am planning on doing so
17:17:59 <ddarius> andy_: What does "a utf8 in the Get monad" mean?
17:18:11 <tg_> ddarius: ah. so we've invented all these other languages, just because the universe doesn't like the n-queens problems.
17:18:13 <elliott> A way to read a utf8 string using Data.Binary's Get monad presumably
17:18:15 <koninkje> tg_: if you're talking to me, I don't think they taped the talk
17:18:40 <koninkje> tg_: I can ask around on monday though
17:18:58 <tg_> koninkje: Did he give any suggestions on what groups?
17:19:42 <koninkje> tg_: How do you mean?
17:20:06 <tg_> koninkje: if you forumlate something like QFT (but not fields, because not C), then you're probably going to have some groups in mind
17:20:14 <ddarius> elliott: With that interpretation, then it most of the time it wouldn't do what you want to do which is actually have the string.  It would still be useful for reading the correct amount of data though.
17:20:14 <koninkje> tg_: The specific example he gave was (Bool,xor,and) since it was a talk for a general audience
17:20:43 <elliott> ddarius: I can't really parse that. "what you want to do which is actually have the string"?
17:20:48 <koninkje> tg_: (and since he was drawing connections between QM and relational programming)
17:21:19 <monochrom> I have a feeling that in the Get monad you should just ask for one Char.
17:21:49 <ddarius> s/then it/then/
17:21:49 <andy_> ddarius, i mean getChar :: Get Char that decodes via getWord8 as if it was ut8 encoded
17:21:51 <tg_> koninkje: ok.
17:21:57 <andy_> ddarius, probably not the best wording..
17:21:59 <elliott> andy_: ah.
17:22:03 <elliott> that makes more sense :)
17:22:05 <monochrom> \∩/
17:22:11 <elliott> andy_: I'd call it getUTF8Codepoint
17:22:14 <andy_> *utf8
17:22:15 <elliott> but i'm anal like that
17:22:16 <tg_> I don't get the point, and it's my CS chops and not my physics chops that are hurting me. :(
17:22:17 <elliott> well
17:22:18 <elliott> utf8Codepoint
17:22:20 <ddarius> andy_: There are several libraries that do strings at a time.
17:22:20 <elliott> or whatever
17:22:25 <koninkje> tg_: I'm coming at this quantum stuff from the direction of quantum probability theory, I haven't done any physics in a decade or so
17:22:29 <ddarius> They may also do individual characters.
17:22:45 <andy_> ddarius, the issue for me, is that the file i am decoding has nul-terminated utf8 encoded strings
17:22:55 <monochrom> eww
17:22:59 <elliott> ouch
17:23:07 <elliott> is 0 valid utf8 anyway?
17:23:10 <monochrom> then again, not the end of the world
17:23:11 <elliott> dunno if 0 is a unicode codepoint
17:23:12 <elliott> I think it is
17:23:20 <elliott> so nul-terminated utf-8 is possibly unwise
17:23:25 <koninkje> I think its NUL, isn't it?
17:23:25 <elliott> but probably not in practice :P
17:23:31 <elliott> yeah...
17:23:34 <ddarius> Won't 0 not occur except for the NUL character anyway?
17:23:37 <andy_> not sure if it is, be the specification i am going from acts as if it is (the spec is often wrong)
17:23:37 <yip> a utf8 stream will have no null bytes
17:23:40 <elliott> ddarius: yes, indeed
17:23:43 <yip> so it is ok to nul terminate them
17:23:48 <elliott> yip: are you sure, U+0000 is a valid codepoint
17:23:51 <ddarius> So it can just be treated as a nul-terminated string of bytes.
17:23:55 <elliott> represented in UTF-8 as \0 I think
17:23:55 <tg_> koninkje: ok, is this guy trying to say something about QM or prolog?
17:23:56 <andy_> yip, that is as the spec said as well
17:23:58 <elliott> but maybe there's a special-case for it
17:23:58 <yip> elliott: i'm sure. the spec explicitly mentions this
17:24:05 <ddarius> No need to decode the UTF8.
17:24:06 <koninkje> tg_: yes :)
17:24:06 <elliott> yip: ah. so there is no way to represent that codepoint?
17:24:10 <elliott> or do you just use the longer form?
17:24:12 <elliott> of some sort
17:24:12 <tg_> or relational programming in general?
17:24:23 <koninkje> tg_: Mostly about QM as a mathematical/computational construct
17:24:26 <elliott> if there's no way to represent it full stop that sucks :(
17:24:30 <ddarius> elliott: If the string is nul-terminated, it can't contain nul.
17:24:41 <elliott> ddarius: naturally, i am asking about utf-8 in general
17:24:46 <andy_> ddarius, no need how? just hold it as a [Word8]?
17:25:02 <ddarius> andy_: Yes, or whatever.
17:25:03 <monochrom> in UTF8 if you see the byte \0 it's NUL
17:25:14 <ddarius> andy_: If you actually need the string to do something with it, use a library like Text.
17:25:15 <elliott> right.
17:25:25 <elliott> so nul-terminated utf-8 can't represent all of utf-8 or whatever :P
17:25:29 <andy_> ddarius, ok, i have been meaning to look into that library
17:26:39 <monochrom> you could always use Gödel numbering :)
17:26:49 <yip> there is no such thing as null byte in utf8. if a utf8 decoder encounters a null byte it is an error
17:27:01 <elliott> gödel numbering is the solution to all problems
17:27:07 <elliott> but never the practical solution :D
17:27:20 <monochrom> double-Gödel it to be double-safe!
17:27:21 <elliott> yip: so a UTF-8 stream cannot encode the codepoint U+0000?
17:27:25 <elliott> that seems like a design flaw to me.
17:27:37 <elliott> monochrom: paper title: Gödel Numbering of the Natural Numbers
17:27:52 <allbery_b> In Modified UTF-8,[15] the null character (U+0000) is encoded as 0xC0,0x80; this is not valid UTF-8[16] because it is not the shortest possible representation. Modified UTF-8 strings never contain any actual null bytes but can contain all Unicode code points including U+0000,[17] which allows such strings (with a null byte appended) to be processed by the traditional ASCIIZ string functions.
17:28:18 <j-invariant> elliott: what's the godel number of the godel numbering function?
17:28:27 <elliott> j-invariant: DUUUUUUUUUUUUUUUUUUUUUUUUDE
17:28:29 <andy_> elliott, flash has a serious issue with it
17:28:30 <yip> elliott: it can, utf-8 can encode all unicode codepoints
17:28:32 <j-invariant> lololol
17:28:38 <ddarius> j-invariant: It wouldn't fit in IRC's limits.
17:28:39 <allbery_b> more importantly, what is the godel number of its negation?
17:28:45 <elliott> yip: then what is the utf-8 encoding of the codepoint U+0000?
17:28:53 <elliott> <allbery_b> In Modified UTF-8,[15] the null character (U+0000) is encoded as 0xC0,0x80; this is not valid UTF-8[16] because it is not the shortest possible representation. Modified UTF-8 strings never contain any actual null bytes but can contain all Unicode code points including U+0000,[17] which allows such strings (with a null byte appended) to be processed by the traditional ASCIIZ string functions.
17:28:57 <yip> elliott: don't remember. but you can write a one-liner in haskell to tell you :)
17:28:59 <elliott> this suggests to me that utf-8 cannot represent it
17:29:12 <elliott> yip: everything i'm reading suggests that the only valid encoding would be 0x00, which is explicitly _not_ valid
17:29:33 <elliott> unless it is.
17:29:50 <monochrom> if you trust wikipedia, U+0000 is encoded to byte 0
17:30:14 <allbery_b> I am under the impression that modified utf8 is used when NUL is a data delimiter
17:30:20 <djahandarie> If I don't trust Wikipedia I don't trust myself
17:30:22 <elliott> monochrom: so yip is wrong then :)
17:30:28 <elliott> or wikipedia but that is unthinkable
17:30:41 <monochrom> I don't have enough money to buy and read the real Unicode 5.0 document.
17:30:50 <elliott> 6.0 is out now isn't it
17:31:06 <monochrom> but url to pirated copies are welcome
17:31:11 <mikeg> I'm reading Graham Hutton's Intro to Cat Theory (http://www.cs.nott.ac.uk/~gmh/cat.html), and I'm confused by the bullet in lecture 2: "PA is the powerset (set of all subsets) of A, e.g. P{0,1} = {empty,{0},{1},{1,2}}"
17:31:19 <pikhq> allbery_b: Modified UTF-8 also has some complete brain-damage...
17:31:24 <j-invariant> mikeg: yes?
17:31:29 <allbery_b> the more telling point is that same wikipedia page says that modified utf8 is used for java serialization, where nul bytes qre problematic
17:31:30 <j-invariant> mikeg: its jlust a typing mistake
17:31:31 <pikhq> allbery_b: Typically, it also uses surrogate pairs, as per UTF-16.
17:31:46 <mikeg> Ah, ok.. it is hand-written, though
17:32:06 <djahandarie> Where is the error?
17:32:12 <elliott> djahandarie: "{1,2}"
17:32:15 <elliott> definitely not a subset of {0,1}
17:32:15 <djahandarie> Oh
17:32:16 <djahandarie> Haha
17:32:20 <elliott> should be {0,1}
17:32:25 <edwardk> mikeg: typo
17:32:27 <j-invariant> powerset is a functor?
17:32:30 <kuffaar> monochrom: It's avaialble for free, no?
17:32:37 <elliott> I think Unicode is free, yes.
17:32:38 <j-invariant> or is it a contrafunctor?
17:32:46 <elliott> They have a lot of pdfs on unicode.org at least that look suitably official.
17:32:47 <monochrom> I don't know. Where?
17:33:01 <j-invariant> Pow(f) : Pow(X) -> Pow(Y)
17:33:05 <elliott> http://unicode.org/versions/Unicode6.0.0/
17:33:08 <edwardk> j-invariant: 'contrafunctor' is an induced concept. its not critical to the their a contravariant functor is just one from a category to some dual category
17:33:16 <elliott> e.g. http://www.unicode.org/versions/Unicode6.0.0/ch03.pdf
17:33:17 <elliott> see the sidebar
17:33:19 <allbery_b> http://en.wikipedia.org/wiki/CESU-8
17:33:19 <edwardk> er to their use
17:33:25 <allbery_b> the surrogate pairs nonsense
17:33:38 <monochrom> well I guess UTF-8 alone is free as RFC 3629
17:33:40 <ddarius> j-invariant: P = (-> 2)
17:33:42 <allbery_b> (unsurprisingly, horricle uses it as "utf8")
17:33:51 <j-invariant> Pow(f) = map f
17:33:56 <edwardk> and powerset is a functor on Set.
17:33:57 <yip> elliott: i think wikipedia is wrong
17:33:59 <monochrom> RFC 3629 also encodes U+0000 to byte 0
17:34:03 <ddarius> edwardk: You're being more pedantic that usual.
17:34:09 <elliott> yip: citation?
17:34:20 <j-invariant> instance Functor (-> 2) where fmap f = f . fmap?
17:34:26 <elliott> i mean if wikipedia was wrong
17:34:33 <elliott> there'd be no reason for enhanced utf-8 to exist.
17:34:37 <ddarius> j-invariant: (->) is contravariant in its first argument.
17:34:37 <edwardk> there is a contravariant version though =)
17:34:40 <elliott> if you are right.
17:34:42 <elliott> which it clearly does.
17:34:48 <pikhq> monochrom: Well, yes. UTF-8 is a fairly simple algorithmic encoding of Unicode code points to bytes...
17:34:50 <j-invariant> oh man this is so confusing haha
17:34:53 <pikhq> elliott: "Enhanced UTF-8"?
17:34:53 <edwardk> ddarius: it comes and goes ;)
17:34:59 <elliott> er.
17:35:01 <elliott> Modified UTF-8.
17:35:06 <elliott> you know what i mean, bah humbug
17:35:13 <ddarius> edwardk: You're actually usually not pedantic.
17:35:46 <gwern> the only thing pedantic about edwardk is his code
17:35:48 <pikhq> elliott: Modified UTF-8, of course, exists to allow encoding U+0 as distinct from 0x00.
17:35:49 <edwardk> i'll take that as a complement =)
17:36:02 <monochrom> pikhq: The discussion was dispute over what the standard documents actually say.
17:36:08 <elliott> pikhq: so yip is wrong. :p
17:36:08 <pikhq> monochrom: Ah.
17:36:10 <edwardk> i need to package up this little monadic-array package
17:36:27 <edwardk> now that it compiles. next step unboxed arrays
17:36:34 <ddarius> edwardk: You don't have a tool to do that for you yet?
17:36:42 <edwardk> finally i can have MArray's for monad transformers
17:37:06 <edwardk> ddarius: nah, its usally a couple minute process of cutting and pasting cabal files and setting up the git repo, etc.
17:37:25 <ddarius> edwardk: Dan got me my alcohol (or will once he gets back.)
17:37:55 <ddarius> edwardk: Sounds completely automatable, and then you can use it on itself.
17:37:59 <gwern> edwardk: hm, cabal init isn't faster than cooking up some copy-pasta?
17:38:32 <edwardk> gwern:  not typically. i have so many fiddly things like naming the source repo, copying my license, etc.
17:38:45 <edwardk> setting up the git repo
17:38:48 <edwardk> that kinda stuff
17:38:51 <gwern> is that intrinsic or accidental complexity?
17:39:12 <edwardk> it makes my OCD parts happy ;)
17:40:04 <gwern> I see
17:43:25 <jmcarthur> you can customize cabal init, i think
17:43:29 <jmcarthur> edwardk: ^^
17:43:36 <edwardk> jmcarthur: hrmm
17:43:51 <jmcarthur> i'd been meaning to give that a shot myself
17:44:45 <edwardk> let me know how it goes. not really in the market for a fishing expedition right now ;)
17:45:13 <monochrom> you mean customize cabal init by command line parameters?
17:45:27 <jmcarthur> monochrom: i was under the impression that you could stick a template somewhere and use it
17:45:42 <monochrom> I see.
17:46:24 * ddarius briefly considers that wearing all black might not be the best thing for a pedestrian situation at night and then carries on.
17:46:33 <edwardk> hah
17:46:47 <Jesin> umm
17:47:09 <Jesin> so, I guess I kinda accept that having both Monoid and MonadPlus makes some kind of sense
17:47:11 <Jesin> but
17:47:14 <Jesin> why Alternative
17:47:25 <Jesin> it even has the same kind as MonadPlus
17:47:31 <Jesin> it just lacks >>=
17:47:38 <ddarius> Monad has the same kind as MonadPlus.
17:47:46 <Jesin> yes, I know
17:47:51 <Jesin> so does Alternative
17:48:03 <gwern> wow. I didn't realize how much space was reserved for root by default. by setting ext's reserve to 1% I just got another 20GB of space to use
17:48:08 <Jesin> http://haskell.org/ghc/docs/latest/html/libraries/base-4.3.0.0/Control-Applicative.html#t:Alternative
17:48:29 <gwern> my torrents will appreciate said 20GB a lot
17:48:31 <ddarius> Alternative has the same issues as MonadPlus.
17:48:34 <Jesin> "class Applicative f => Alternative f where
17:48:36 <Jesin> A monoid on applicative functors. "
17:49:21 <ddarius> A monoid that interacts with the Applicative structure in given ways.
17:49:32 <jmcarthur> the docs actually don't state any properties about that though
17:50:04 <jmcarthur> although it would make sense for consistency with MonadPlus for this to hold:  empty *> a = empty
17:50:12 <edwardk> jesin: Lots of things lack >>= though but could support <|> 
17:50:34 <Jesin> so why not use Monoid for those?
17:50:47 <edwardk> plus MonadPlus/Alternative vs Monoid says that you can generate a default value despite what the argument type is
17:51:10 <Jesin> [] is a MonadPlus and an Alternative, [a] is a Monoid
17:51:18 <Jesin> I'm pretty sure at least one of those is redundant
17:51:22 <edwardk> there are times when you need to be able to generate an empty value regardless of the argument type, each Monoid instance is independent, there isn't a way to say that you have a monoid instance for all a.
17:51:35 <Jesin> umm
17:51:36 <edwardk> and then use it at Int, Bool, and [[[[[[[[[[[Double]]]]]]]]]
17:51:38 <jmcarthur> no i don't think those are redundant
17:51:47 <edwardk> they aren't
17:51:52 <Jesin> what's with the "instance Monoid [a]" then?
17:52:04 <Jesin> if "there isn't a way to say" that
17:52:06 <Jesin> :p
17:52:37 <edwardk> jesin i can't call a function with a constraint like: foo :: forall a. Monoid (f a) => Bar f 
17:52:49 <edwardk> if the 'a' doesn't leak out into my type signature, I can't use Monid.
17:52:50 <jmcarthur> Jesin: *there isn't a way to say that you have a monoid instance for things of kind * -> * without specifying the type argument as well, even if it's polymorphic
17:53:47 <edwardk> consider: newtype Action m = Action (m ()) 
17:53:51 <Jesin> umm
17:53:59 <Jesin> why can't you use forall a?
17:54:24 <edwardk> jesin: because the 'a' has to appear on the right hand side of the => or be guared by a fundep in order to go on the left hand side of the =>
17:54:28 <Jesin> it's not officially in the language I guess but it's a GHC extension with few setbacks, right?
17:54:35 <edwardk> no
17:54:41 <edwardk> you can't give that type in ghc.
17:54:49 <Jesin> what does "guar" mean
17:54:53 <Jesin> fundep?
17:54:53 <edwardk> guarded
17:55:07 <Jesin> what kind of fundep would satisfy this
17:55:09 <edwardk> ignore that for the sake of this discussion, it was a minor technical quibble ;)
17:55:13 * hackagebot monadic-arrays 0.1 - MArray instances for monad transformers  http://hackage.haskell.org/package/monadic-arrays-0.1 (EdwardKmett)
17:55:13 <edwardk> it cant
17:55:33 <Jesin> hmm
17:55:50 <Jesin> well
17:55:54 <jmcarthur> well i can't find anything on customizing cabal init, so maybe i was mistaken...
17:55:56 <Jesin> why both MonadPlus and Applicative, then
17:56:04 <Jesin> err
17:56:07 <Jesin> *Alternative
17:56:19 <monochrom> Alternative adds <|>
17:56:20 <edwardk> jesin: MonadPlus came first, plus MonadPlus saves you the overhead of typing 'Alternative m, Monad m'
17:56:31 <Jesin> XD
17:56:34 <Jesin> "overhead of typing"
17:56:38 <edwardk> plus there are laws relating Alternative and Applicative
17:56:46 <edwardk> and laws relating MonadPlus and Monad
17:57:02 <Jesin> the MonadPlus laws aren't even followed consistently
17:57:12 <Jesin> except the one about >>= and mzero
17:57:16 <edwardk> (though it'd be really hard to make an Applicative for a monad that was consistent with the Applicative that somehow broke the laws with respect to >>=
17:57:22 <edwardk> jesin: correct
17:57:30 <edwardk> MonadPlus is at least two classes munged into one
17:57:47 <Jesin> so it's really just "MonadPlus came first"?
17:57:54 <edwardk> I even have a FunctorAlt floating around in a module somewhere which is an even weaker Alternative
17:58:06 <edwardk> well, Monad and Alternative don't relate to one another in the current class hierarchy
17:58:17 <Jesin> [21:04:56]	<edwardk>	plus there are laws relating Alternative and Applicative
17:58:20 <Jesin> where are those laws
17:58:26 <Jesin> I don't see them in the Applicative docs
17:58:27 <edwardk> in the idiom paper
17:58:31 <Jesin> what
17:58:49 <Jesin> there in some other paper but not even in the documentation
17:59:12 <edwardk> the paper defined the notion
17:59:20 <Jesin> if Alternative is in the library and there are certain laws it should follow, they should be in the Alternative documentation
17:59:50 <edwardk> probably. go submit a patch and emaail the libraries@ mailing list
17:59:53 <edwardk> they probably won't object
18:00:15 <teki> is there a function similar to (!!) but which returns a Maybe-wrapped value?
18:00:18 <edwardk> but the problem is the alternative laws have the same moral ambiguity that the monadplus laws have
18:00:29 <edwardk> :t index
18:00:30 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Int
18:00:33 <edwardk> er
18:00:54 <edwardk> :t elemIndex
18:00:55 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
18:00:56 <koninkje> @t (!!)
18:00:56 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
18:01:03 <koninkje> :t (!!)
18:01:03 <edwardk> not that either
18:01:04 <lambdabot> forall a. [a] -> Int -> a
18:01:40 <koninkje> teki: I don't think so, but it's easy to define
18:01:55 <edwardk> foo = listToMaybe . drop n 
18:02:11 <edwardk> er foo xs n = listToMaybe (drop n xs)
18:02:25 <teki> koninkje: alright, i'll just write it myself
18:02:34 <edwardk> heya koninkje, ltns
18:02:48 <koninkje> yeah, it's been a while since I logged in
18:04:44 <koninkje> teki: what're you using it for? In general if you need to use (!!) that means you're doing things wrong, since it takes time linear in the index
18:12:30 <teki> koninkje: i really just wanted to check if a list is at least five elements long
18:12:55 <teki> although this could have been accomplished with length $ take 5 xs = 5
18:13:08 <koninkje> teki: see http://hackage.haskell.org/packages/archive/list-extras/0.4.0.1/doc/html/Data-List-Extras-LazyLength.html
18:13:41 <teki> i think you've thought way too much about this problem, and i feel bad now, because you seem to have thought more about it than i have
18:14:01 <teki> i just checked the specs for data.list and then asked here to see if i was missing something in Prelude
18:14:42 * koninkje :)
18:20:56 <gwern> teki: why would you write 'length $ take 5 xs = 5'?
18:21:06 <kuffaar> return $ return () -- this looks odd
18:21:16 * kuffaar struggling with the damned stack of monads
18:21:32 <edwardk> kuffaar: erm, what monad stack is this?
18:21:38 <edwardk> kufaar: why no transformer?
18:21:50 <kuffaar> I suppose I should be using ReaderT instead
18:21:54 <edwardk> yeah
18:21:57 <kuffaar> That one can deal with this one return?
18:21:59 <jmcarthur> gwern: assuming == was intended instead of =, that would be a way to see if the length is at least 5 without forcing the whole list spine
18:22:03 <edwardk> yeah
18:22:20 <gwern> jmcarthur: oh right, we don't have lazy numbers
18:22:23 <jmcarthur> well, and there would need to be parens instead of $
18:22:25 * gwern keeps forgetting
18:22:37 <jmcarthur> at least not in the standard libs we don't :(
18:22:46 <kuffaar> Ahh and with ReaderT you can do ReaderT Blah IO ()
18:22:52 <kuffaar> Instead of Reader Blah (IO ())
18:23:11 <edwardk> yep
18:23:20 <kuffaar> Slowly getting the hang of this!
18:23:28 <edwardk> then you only need to write 'lift' when you want to perform an IO action
18:23:36 <edwardk> (though you should probably use liftIO for that
18:23:53 <edwardk> the nice thing is you can chain them and still avoid lifts
18:24:22 <edwardk> ReaderT Blah (StateT Blargh IO) () — works the same way, so changing the monad _doesn't require you to change the code_
18:24:36 <edwardk> this lets you add features as you need them without replumbing everything
18:25:21 <kuffaar> Right and you just update some type
18:25:59 <edwardk> yeah. which is why its handy to just put that type in a type alias somewhere so you can factor that change out of your code as well
18:31:30 <teki> gwern: i meant (length $ take 5 xs == 5)
18:31:43 <teki> gwern: as a way to test if a list has at least five elements
18:32:42 <teki> gwern: there was a better way to solve the underlying problem, though, via a position accumulator
18:33:12 <koninkje> teki: yes, take a look at the library I posted earlier
18:33:43 <koninkje> It effectively gives you lazy naturals without the performance cost
18:33:53 <geheimdienst> so why should you prefer liftIO to lift? i looked up the docs, but ...
18:34:25 <monochrom> liftIO is more magic. one liftIO lifts it all.
18:35:01 <geheimdienst> meaning lift reaches down one level, whereas liftIO reaches down all the way to the bottom?
18:35:15 <monochrom> yeah
18:35:24 <geheimdienst> (cue inception and/or turtles all the way jokes)
18:35:29 <monochrom> ONE RING TO RULE THEM ALL!
18:35:36 <geheimdienst> ok thanks for the explanation
18:35:56 <monochrom> and in your monad >>= them!
18:36:24 <geheimdienst> @remember monochrom one ring to rule them all! and in your monad >>= them!
18:36:25 <lambdabot> It is stored.
18:38:59 <gwern> teki: yes, but the accumulator is longer to write, so going with take/length is understandable
18:39:49 <jmcarthur> teki: you mean (length (take 5 xs) == 5). the ($) won't work right, there
18:41:48 <hpc> monochrom: a ring that's also a monad? madness!
18:43:03 <aristid> comparing lengths with a small fixed value is a bad idea anyways
18:44:09 <jmcarthur> @quote ring
18:44:10 <lambdabot> edwardk says: i just got bitten in the ass by the lack of a notion of commutative monad for a in a toy kind of memoizing hylomorphism that now has way too much 'ordering' baked into it
18:44:16 <jmcarthur> @quote ring rule
18:44:17 <lambdabot> No quotes for this person. Just try something else.
18:44:20 <tolkad> Is there any way to get cabal to tell me if a package is being compiled with outdated packages?
18:44:28 <jmcarthur> @quote ring to rule
18:44:28 <lambdabot> No quotes for this person. Where did you learn to type?
18:44:31 <jmcarthur> bah
18:44:36 <tolkad> @quote tolkad
18:44:36 <lambdabot> tolkad says: haskell isn't even turing complete without infinite memory
18:44:47 <jmcarthur> @quote jmcarthur
18:44:48 <lambdabot> jmcarthur says: we might be getting into edwardk territory now
18:44:56 <jmcarthur> i don't remember that
18:45:35 <edwardk> heh i don't remember saying that =)
18:45:52 <tolkad> 08:40:00 <ski> jmcarthur : it's always useful to have laws that ensure your operations are sensible :)
18:45:52 <tolkad> 08:41:18 <jmcarthur> ski: we might be getting into edwardk territory now
18:45:53 <ddarius> edwardk: I'm pretty sure I remember you saying that.
18:45:54 <edwardk> oh, probably back when i was hacking up chrono
18:45:56 <Rotaerk> hmm... I'm starting to think that "fst" and "snd" are harmful to readability
18:46:02 <aristid> @quote jmcarthur
18:46:02 <lambdabot> jmcarthur says: web monads are unicorn burritos that have been laying around in the attic for a few years
18:46:06 <geheimdienst> it's okay, lambdabot is making up most of those quotes
18:46:16 <aristid> but are web monads web scale?
18:46:17 <gwern> @quote geheimdienst 
18:46:17 <lambdabot> geheimdienst says: We employ a simple implementation of cryomorphobalonical panfunctors as introduced by Axman6
18:46:20 <Rotaerk> and that instead of using them, one should have an explicit lambda, so that one can *see* the deconstruction of the tuple
18:46:29 <Rotaerk> i.e. so that the components can be named
18:46:38 <jmcarthur> @quote gwern
18:46:39 <lambdabot> gwern says: if hlist is the answer, I don't want to know the question
18:46:43 <jmcarthur> lol
18:46:58 <ddarius> Rotaerk: Who uses fst and snd?  Except in point-free code?
18:47:15 <Jesin> @pl \z -> (return $ fmap z . join z) z
18:47:15 <tolkad> :t fst . snd
18:47:15 <lambdabot> liftM2 (.) fmap join
18:47:16 <gwern> ddarius: lots of people. do you wish me to grep all my local repos and name names?
18:47:17 <lambdabot> forall a b a1. (a1, (a, b)) -> a
18:47:23 <ddarius> gwern: Yes.
18:47:32 <jmcarthur> i think Rotaerk is making an argument against point free code
18:47:33 <gwern> ...drat
18:47:40 <Jesin> @pl fmap >>= \x -> join >>= \y -> return $ x . y
18:47:41 <lambdabot> (`fmap` join) . (.) =<< fmap
18:47:48 <Rotaerk> http://rotaerk.pastebin.com/wJZe4GyD  vs  http://rotaerk.pastebin.com/7WUhn0H3
18:47:53 <Rotaerk> note this is F#...
18:47:59 <Rotaerk> but again, a language independent issue
18:48:05 * gwern punches in `find bin/ -name "*.hs" -exec grep fst {} \;`
18:48:20 <Rotaerk> I created "tup2'2" which is equal to snd
18:48:24 <tomberek> edwardk: hey
18:48:24 <lambdabot> tomberek: You have 1 new message. '/msg lambdabot @messages' to read it.
18:48:40 <jmcarthur> wow, F# looks scary
18:48:55 <brisbin> agreed
18:49:03 <Rotaerk> I'm just finding the second more readable because the components of the tuples are named there
18:49:07 <ddarius> If tup2'2 had been a standard name, I'd unambiguously consider it better than the latter.
18:49:24 <gwern> ddarius: you want me to email you the output? it's too big to hpaste
18:49:31 <Rotaerk> i created that because I also have some for 3-tuples, 4-tuples, and 5-tuples
18:49:32 <jmcarthur> Rotaerk: i think i actually like the first one better
18:49:34 <aristid> i propose cbr
18:49:40 <Rotaerk> so "fst" and "snd" isn't appropriate in that context
18:49:44 <Rotaerk> aren't*
18:49:59 <geheimdienst> > fst (1,2,3)
18:50:00 <lambdabot>   Couldn't match expected type `(a, b)'
18:50:01 <lambdabot>         against inferred type `(t, t1...
18:50:07 <jmcarthur> @hoogle fst3
18:50:07 <lambdabot> No results found
18:50:19 <geheimdienst> thrd, frth, ffth
18:50:23 <jmcarthur> well, there's a fst3, snd3, and thd3 on hackage somewhere
18:50:41 <Rotaerk> hmm I colud rename it according to that pattern, hadn't thought of that
18:50:43 <aristid> > let tup3'1 (a,_,_) = a in tup3'1 (1,2,3)
18:50:44 <lambdabot>   1
18:50:45 <ddarius> gwern: Does your grep regex also filter out the point-free cases?
18:50:46 <tolkad> @pl \fx -> x x (b-> x (\y -> y x (\c -> x c) f) f) (\p -> p f x)
18:50:47 <lambdabot> (line 1, column 14):
18:50:47 <lambdabot> unexpected ">"
18:50:47 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
18:51:00 <tolkad> @pl \fx -> x x (b -> x (\y -> y x (\c -> x c) f) f) (\p -> p f x)
18:51:01 <lambdabot> (line 1, column 15):
18:51:01 <lambdabot> unexpected ">"
18:51:01 <lambdabot> expecting variable, "(", operator or ")"
18:51:05 <Rotaerk> jmcarthur, it's more concise sure, but without names for the intermediate values, i.e. via the deconstruction of the tuples, it's harder to track what's being transformed
18:51:09 <tolkad> @pl \fx -> x x (\b -> x (\y -> y x (\c -> x c) f) f) (\p -> p f x)
18:51:10 <lambdabot> const (x x (const (x (flip (flip ($ x) x) f) f)) (flip ($ f) x))
18:51:13 <jmcarthur> Rotaerk: i disagree
18:51:17 <gwern> ddarius: no, you saw it. it's just grepping for fst
18:51:17 <geheimdienst> jmcarthur: it's in missingh apparently
18:51:28 <jmcarthur> Rotaerk: i find it harder to track all these names, personally
18:51:31 <tolkad> @pl \f x -> x x (\b -> x (\y -> y x (\c -> x c) f) f) (\p -> p f x)
18:51:31 <lambdabot> ap (ap . ap (join id) . (const .) . (flip =<< ap id . flip (flip . (flip =<< flip id)))) (flip . flip id)
18:51:34 <Jesin> :t \c -> (\a -> \d -> (\b -> return (a . b)) (join d) d) (fmap c) c
18:51:35 <lambdabot> forall a (f :: * -> *). (Functor f) => (a -> a -> f a) -> a -> f (a -> f a)
18:51:45 <tolkad> :t ap (ap . ap (join id) . (const .) . (flip =<< ap id . flip (flip . (flip =<< flip id)))) (flip . flip id)
18:51:46 <lambdabot>     Occurs check: cannot construct the infinite type:
18:51:47 <lambdabot>       m = (->) (m (a1 -> a -> b))
18:51:47 <lambdabot>     Probable cause: `id' is applied to too few arguments
18:51:53 <ddarius> gwern: I missed that as I was looking at Rotaerk's code.
18:51:56 <jmcarthur> Rotaerk: it's easier for me to view code as a somewhat more abstract graph or something than it is for me to memorize names as i go along
18:52:02 <jmcarthur> Rotaerk: (usually)
18:52:06 <gwern> ddarius: there are a lot of pointy examples, looking through some output
18:52:06 <tolkad> wait a second
18:52:18 <tolkad> why did @pl add a Monad constraint to my function?
18:52:25 <geheimdienst> fst/snd don't give you a reminder of what's in the tuple
18:52:32 <Jesin> @pl \c -> (\a -> \d -> (\b -> return (a . b)) (join d) d) (fmap c) c
18:52:32 <lambdabot> join =<< (. join) . (return .) . (.) . fmap
18:52:45 <Jesin> @pl \c -> (\a -> \d -> (\b -> const (a . b)) (join d) d) (fmap c) c
18:52:45 <lambdabot> join =<< (. join) . (const .) . (.) . fmap
18:52:51 <Rotaerk> jmcarthur, hmm if it were actually represented by a graphical flowchart, that might be nice
18:52:52 <tolkad> oh it's the Monad instance for the function constructor type
18:53:10 <jmcarthur> geheimdienst: if you look at Rotaerk's code you can infer what the data is from the function you're applying to it
18:53:10 <Rotaerk> hmm, I wonder how graphically doing functional programming would be
18:53:12 <kuffaar> F# looks a bit odd but it supposed borrowed some stuff from Haskell? I wonder what
18:53:24 <Rotaerk> kuffaar, it's ML-derived
18:53:26 <tolkad> Is there any way to get cabal to tell me if a package is being compiled with outdated packages?
18:53:27 <jmcarthur> Rotaerk: i didn't mean that i'm doing it visually
18:53:31 <gwern> kuffaar: linq among other things
18:53:33 <jmcarthur> even in my head
18:53:34 <kuffaar> supposedly*
18:53:37 <Rotaerk> oh
18:53:38 <ddarius> gwern: Workflows.
18:53:45 <kuffaar> Well, Linq isn't even specific to F#
18:53:53 <jmcarthur> Rotaerk: i just mean that i find it easier to track relationships between different parts of code when i'm not also having to track various bindings
18:53:59 <gwern> kuffaar: so the borrowing is even more extreme!
18:54:01 <Rotaerk> gwern, LINQ isn't really used much in F#
18:54:12 <Rotaerk> it's got it's own analogous library for the same thing
18:54:28 <Rotaerk> jmcarthur, ah.
18:54:53 <tolkad> I want cabal to tell me if my package is using any packages which have since been updated
18:55:10 <gwern> ddarius: grep finished. file is 12k lines, and I'd guess at least 1/10th are pointy
18:55:13 <jmcarthur> Rotaerk: it's like the difference between having an array of letters and having an array of letters couples with an array of indices into the first where you are supposed to interpret it as a permuted array. the former is a lot simpler for my head
18:55:19 <jmcarthur> *coupled with
18:55:26 * hackagebot FileManipCompat 0.16 - Expressive file and directory manipulation for Haskell.  http://hackage.haskell.org/package/FileManipCompat-0.16 (ThomasHartman)
18:55:53 <jmcarthur> Rotaerk: i intend for the indices to be analogous to bindings
18:56:00 <Rotaerk> right
18:56:16 <Rotaerk> yea in theory that sounds good
18:56:36 <jmcarthur> Rotaerk: what it means in practice, of course, is that for the "array" to be meaningful you have to structure it in a readable way
18:56:48 <jmcarthur> Rotaerk: and in practice, that can be tough, which is why not *all* code is point free
18:56:57 <Rotaerk> yea
18:57:03 <jmcarthur> @pl \a b c d e -> d c e b a
18:57:04 <lambdabot> flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip id))
18:57:15 <jmcarthur> anyway, g2g
18:57:22 <geheimdienst> another thing ... does f# have "where" or something? could you pull out the tup2'2 >> EventForecast.timeOfNextEvents? that occurs twice, which is a little duplication
18:57:36 <Rotaerk> jmcarthur, I'm convinced that there is an easier-to-read pointfree style of that same function
18:57:50 <Rotaerk> jmcarthur, and that just because @pl spits it out one way, doesn't mean that's the best way
18:58:29 <Rotaerk> geheimdienst, it unfortunately doesn't have a where; I could do a binding for that though
18:58:32 <ddarius> jmcarthur: Write in Joy.
18:58:43 <Eelis> is there a way to get haddock to use pretty '→' arrows instead of ugly '->' arrows for function types? i'm used to writing code with pretty arrows using UnicodeSyntax, and it's kinda weird to see the function types actually look uglier in the haddock docs
18:59:21 <aristid> Eelis: you could postprocess the HTML?
18:59:37 <Eelis> aristid: sure, that would be a last resort
18:59:42 <Eelis> i was hoping it wouldn't have to come to that :)
18:59:48 <ddarius> gwern: What's wc -l for this repository?
18:59:54 <aristid>   -U            --use-unicode          use Unicode in HTML output
18:59:58 <gwern> ddarius: repository?
18:59:59 <aristid> haddock --help
19:00:20 <Eelis> aristid: ah, great! i normally build docs using cabal. didn't even know haddock could be invoked directly
19:00:22 <tolkad> @pl \a b c d e f g h -> (\i j k l m n o p q r s t u v w x y z -> k d m e i w q p s z m d i e w k l z x m s w q p d k d w q e y) (\i j k l m n o p q r s t u v w x y z -> w q a p k d m n x h d d a s k w r p o e u a)
19:00:25 <lambdabot> const . const . ((const .) .) . ((const .) .) . ap (ap . ((.) .) . ((const .) .) . (((((const .) .) .) .) .) . (((((const .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . ((((((((const .) .) .) .
19:00:25 <lambdabot> ) .) .) .) .) . ((((((((const .) .) .) .) .) .) .) .) . ((((((((const .) .) .) .) .) .) .) .) . ((((((((((flip .) .) .) .) .) .) .) .) .) .) . flip (ap . (flip .) . ((flip .) .) . (((flip .) .) .) .
19:00:26 <lambdabot> ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . (((((((((flip .) .) .) .) .) .) .) .) .) . (
19:00:28 <aristid> Eelis: haha
19:00:43 <geheimdienst> @slap tolkad
19:00:44 <lambdabot> stop telling me what to do
19:00:51 <geheimdienst> @slap lambdabot
19:00:52 * lambdabot hits lambdabot with an assortment of kitchen utensils
19:01:10 <geheimdienst> aristid: what does that mean? what does haddock use unicode for?
19:01:16 <Rotaerk> geheimdienst, actually, i guess doing that solved the readability issue:  http://rotaerk.pastebin.com/TdEJixqL
19:01:49 <aristid> geheimdienst: no idea. Eelis wants his -> to be unicode symbols instead, MAYBE it does that
19:02:15 <ddarius> gwern: In the general sense of the word.  Whatever you a grepping.
19:02:22 <tolkad> @pl let x = x in x
19:02:23 <lambdabot> fix id
19:02:33 <geheimdienst> Rotaerk: that's what i suspected
19:02:38 * geheimdienst feels like a big f# expert
19:02:42 <Rotaerk> :P
19:02:50 <gwern> ddarius: I have hundreds of haskell repos. it's nothing in particular
19:02:52 <aristid> Rotaerk: |> is reverse function application?
19:02:58 <geheimdienst> you could now get rid of tup2'2 with little effort
19:03:05 <Rotaerk> aristid, a |> b = b a
19:03:09 <tolkad> aristid: no, it's a disinterested man with a beard
19:03:12 <Jesin> @pl \f x -> fmap f (f x x)
19:03:13 <aristid> Rotaerk: so, yes.
19:03:13 <lambdabot> liftM2 (.) fmap join
19:03:21 <Rotaerk> and >> is reverse composition
19:03:24 <aristid> tolkad: you're 3|>
19:03:41 <geheimdienst> |> is a nice idea actually. do we have a haskell equivalent?
19:03:42 <Jesin> apparently, do {x <- fmap; y <- join; return $ x . y}
19:03:47 <Jesin> simplifies to \f x -> fmap f (f x x)
19:04:04 <ddarius> geheimdienst: Import MPS which redefines (.) to be flip id.
19:04:09 <aristid> Rotaerk: i think that the reverse order makes this less readable: eventForecasts |> EntityTable.toList
19:04:18 <Jesin> do {x <- fmap; y <- join; return $ x . y}
19:04:20 <Jesin> :t do {x <- fmap; y <- join; return $ x . y}
19:04:21 <lambdabot> forall a (f :: * -> *). (Functor f) => (a -> a -> f a) -> a -> f (a -> f a)
19:04:22 <ddarius> Now you can write, list.sort.head
19:04:23 <Jesin> :t \f x -> fmap f (f x x)
19:04:24 <lambdabot> forall a (f :: * -> *). (Functor f) => (a -> a -> f a) -> a -> f (a -> f a)
19:04:40 <geheimdienst> ddarius: but (.) is already taken for function composition ...?
19:04:55 <aristid> Rotaerk: http://rotaerk.pastebin.com/tpe206L7
19:05:00 <Jesin> ...
19:05:06 <Jesin> [22:12:23]	<ddarius>	geheimdienst: Import MPS which redefines (.) to be flip id.
19:05:10 <Jesin> that's horrible
19:05:12 <ddarius> geheimdienst: Why do you want your code to be understandable?
19:05:16 <Jesin> XD
19:05:37 <Rotaerk> aristid, are you saying that you find it best not to pump the initial value in via a |>, but to just use normal application syntax for that
19:05:50 <aristid> Rotaerk: in this case at least
19:05:52 <Rotaerk> and the same with $ in haskell
19:06:07 <Rotaerk> i.e. instead of a $ b $ c $ d, have a $ b $ c d
19:06:14 <aristid> Rotaerk: my refactored expression places less load on my brain.
19:06:15 <geheimdienst> you're right. if i was shooting for understandable, i wouldn't be doing haskell anyway
19:06:27 <aristid> geheimdienst: you wouldn't?
19:06:28 <Jesin> umm
19:06:43 <aristid> Rotaerk: a . b . c $ d
19:06:46 <Jesin> (Control.Category.>>>) is reversed composition
19:07:06 <Rotaerk> aristid, why prefer a chain of composition and a single pipe, versus a bunch of pipes?
19:07:20 <geheimdienst> @src >>>
19:07:20 <lambdabot> Source not found. I've seen penguins that can type better than that.
19:07:23 <Jesin> or even
19:07:25 <aristid> Rotaerk: because i like it better
19:07:26 <Jesin> a . b $ c d
19:07:38 <Rotaerk> it all seems so arbitrary :D
19:07:41 <Jesin> they both get inlined anyway
19:07:43 <Jesin> :p
19:07:45 <Jesin> btw
19:07:53 <aristid> Rotaerk: well, a . b . c is a valid function this way
19:08:14 <aristid> Rotaerk: and (.) is associative. ($) is not
19:08:15 <Rotaerk> aristid, it's a one-time-use function though, which makes using composition pointless imo
19:08:17 <Jesin> with the INLINE ($) pragma
19:08:27 <Jesin> why is $ defined as f $ x = f x
19:08:30 <Rotaerk> aristid, oh, so you're saying a $ b $ c $ d isn't valid?
19:08:34 <Jesin> instead of just ($) f = f
19:08:35 <Jesin> :p
19:08:37 <tolkad> wait what... flip id will turn id into (a -> b) -> a -> b which becomes a -> (a -> b) -> b...
19:08:37 <Rotaerk> the equivalent in F# is, without ()'s
19:08:38 <aristid> Rotaerk: of course it's valid
19:08:52 <aristid> Rotaerk: it's just different from (a $ b $ c) $ d
19:08:56 <Jesin> tolkad: yes, ($) = id by the way
19:09:07 <maurer_> Any idea how to get a FunPtr from a foreign library?
19:09:12 <aristid> Rotaerk: (a . b) . c is the same as a . (b . c)
19:09:29 <Rotaerk> aristid, i would expect a $ b $ c $ d to be equivalent to a $ (b $ (c $ d))
19:09:42 <aristid> Rotaerk: it is.
19:09:45 <Jesin> > 3 `flip id` (2+)
19:09:46 <lambdabot>   <no location info>: parse error on input `id'
19:09:47 <Rotaerk> which is equivalent to a . b . c $ d
19:10:01 <tolkad> Jesin: but how does that get unified with (x -> y) -> (z -> x) -> z -> y?
19:10:05 <maurer_> Nevermind, found it.
19:10:14 <Jesin> umm
19:10:22 <Jesin> :t id
19:10:23 <lambdabot> forall a. a -> a
19:10:24 <Jesin> :t ($)
19:10:25 <lambdabot> forall a b. (a -> b) -> a -> b
19:10:42 <Jesin> (a -> b) -> (a -> b) is a special case of a -> a
19:10:47 <tolkad> Jesin: yes but they said (.) = flip id
19:10:53 <tolkad> :t (.)
19:10:54 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:10:57 <Jesin> no, tolkad
19:11:01 <tolkad> wait what
19:11:04 <Jesin> they said there was a library that REDEFINES (.) to be that
19:11:05 <Eelis> aristid: thanks, it works like a charm with:  runhaskell Setup haddock --haddock-options=-U
19:11:08 <tolkad> Jesin: oh
19:11:10 <Jesin> XD
19:11:14 <aristid> Rotaerk: i think the reason is that a composition chain of functions is easier to understand than an application chain, because you don't have to look at the order
19:11:16 <Jesin> which is quite frankly a horrible idea
19:11:21 <aristid> Eelis: cool
19:11:21 <Rotaerk> geheimdienst, I think even if that composition of tup2'2 and EventForecast.timeOfNextEvents wasn't duplicated, it'd have still been beneficial to extract it, for readability
19:11:57 <Rotaerk> aristid, hmm good point
19:12:41 <aristid> Rotaerk: very sloppily expressed by myself :/
19:13:10 <geheimdienst> yeah, anytime you write code that you have already written, a little bell with "extract me" should jingle
19:13:21 <Jesin> :t (\f x -> fmap f (f x x)) <*> (.)
19:13:22 <lambdabot>     Occurs check: cannot construct the infinite type:
19:13:23 <lambdabot>       a = f1 a -> f1 (a -> f a)
19:13:23 <lambdabot>     Probable cause: `.' is applied to too few arguments
19:13:30 <Rotaerk> I'm saying even if it *wasn't* duplicated
19:13:46 <Rotaerk> naming it would've helped readability
19:13:48 <geheimdienst> sorry, i misread
19:13:53 <geheimdienst> you're right
19:14:05 <aristid> Rotaerk: maybe you can find a shorter name tho?
19:14:23 <Rotaerk> haven't thought of a shorter name that's no less descriptive
19:14:25 <tolkad> :t fix flip
19:14:26 <lambdabot> forall a b. a -> a -> b
19:14:35 <Rotaerk> well, guess I could get rid of "get"
19:14:45 <aristid> :t flip fix
19:14:46 <lambdabot> forall a b. a -> ((a -> b) -> a -> b) -> b
19:15:19 <aristid> Rotaerk: and the Of
19:15:35 <tolkad> @pl (\x -> fix flip x x)
19:15:36 <lambdabot> join (fix flip)
19:15:48 <Rotaerk> nextEventsTime rather than timeOfNextEvents
19:15:48 <aristid> Rotaerk: timeForecastNextEvents?
19:16:02 <Rotaerk> and eventForecastNextEventsTime
19:16:06 <geheimdienst> nextTime?
19:16:17 <tolkad> @let undefined_ = join (fix flip) "wat"
19:16:18 <lambdabot>  Defined.
19:16:22 <tolkad> > undefined_
19:16:26 <lambdabot>   mueval-core: Time limit exceeded
19:16:40 <tolkad> > undefined_ :: Bool
19:16:44 <lambdabot>   mueval-core: Time limit exceeded
19:17:04 <Rotaerk> geheimdienst, I'd be fine with a less descriptive name for a *variable* in a context where it's obvious, but this name must distinguish itself from EventForecast.timeOfNextEvents
19:17:13 <tolkad> @let unsafeCoerce = join (fix flip) id
19:17:14 <lambdabot>  Defined.
19:17:21 <aristid> :t join flip
19:17:22 <lambdabot>     Occurs check: cannot construct the infinite type: a = f (a -> b)
19:17:22 <lambdabot>       Expected type: f (a -> b) -> f (a -> b) -> a1
19:17:23 <lambdabot>       Inferred type: f (a -> b) -> a -> f b
19:17:32 <aristid> :t join . flip
19:17:33 <lambdabot> forall a a1. (a1 -> a1 -> a) -> a1 -> a
19:18:07 <ddarius> ($) /= id
19:18:32 <Rotaerk> s/variable/value/
19:18:37 <tolkad> ddarius: their types unify is what he meant
19:19:31 <revenantphx> hnggggh
19:19:36 <revenantphx> I'm designing a binary protocol with people
19:19:40 <revenantphx> and they have integers and lists
19:19:43 <revenantphx> but then refuse to allow tuples!
19:20:03 <revenantphx> they'd prefer [Int], [Byte], [Byte] over [(Int, Byte, Byte)]
19:20:06 <revenantphx> it makes me angry :(
19:20:55 <tolkad> revenantphx: zipWith3?
19:21:19 <revenantphx> >_>
19:21:43 <tolkad> :t zip3
19:21:45 <lambdabot> forall a b c. [a] -> [b] -> [c] -> [(a, b, c)]
19:23:54 <aristid> :t zipWith3
19:23:55 <lambdabot> forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
19:23:58 <aristid> \o/
19:24:06 <aristid> i was in fear that it would not exist.
19:28:21 <tolkad> a terrible fear gnawing at your very soul
19:29:32 <geheimdienst> fear.nom(soul)
19:31:53 <Jesin> @src (>=>)
19:31:54 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
19:31:57 <ddarius> :t zip7
19:31:57 <lambdabot> forall a b c d e f g. [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]
19:32:49 <revenantphx> finally.
19:32:53 <revenantphx> my rage has worked.
19:33:07 <revenantphx> I have convinced them arrays of tuples are a better abstraction than just saying the arrays are interleaved.
19:33:12 <revenantphx> :)
19:33:20 <revenantphx> my Type System Vengeance has been quenched.
19:34:21 <ddarius> revenantphx: You can have both.
19:34:30 <revenantphx> Well, tuples are just an abstraction here.
19:34:34 <revenantphx> basically given say, Ints
19:34:45 <revenantphx> I think [(Int, Short)] is better than [Int], [Short]
19:35:07 <revenantphx> because the latter requires unzipping/zipping after fully parsing, whereas the former can be parsed one by one and worked with immediately.
19:35:32 <revenantphx> and the former is a better more human understandable representation of what's going on.
19:35:40 <ddarius> revenantphx: Those are simply different.
19:35:46 <revenantphx> yep.
19:35:51 <Jesin> @pl \f g x y -> g (f x y) y
19:35:52 <lambdabot> flip flip id . ((flip . (ap .)) .) . flip ((.) . (.))
19:35:52 <revenantphx> Then they said "okay fine we'll interleave them"
19:36:01 <Jesin> :t \f g x y -> g (f x y) y
19:36:03 <revenantphx> and I said "well then just write up the spec using tuples >:("
19:36:03 <lambdabot> forall t t1 t2 t3. (t -> t1 -> t2) -> (t2 -> t1 -> t3) -> t -> t1 -> t3
19:36:31 <revenantphx> [(extensionName::String, extensionVersion::Int)] is so much nicer than
19:36:48 <revenantphx> "an array of interleaved extension names as stringd and extension versions as ints.
19:37:04 <revenantphx> it's much more concise and gets the point across without so many words.
19:37:11 <j-invariant> qheae to fpaoa
19:37:48 <revenantphx> Also now their binary protocol matches up with Haskell almost exactly :3
19:38:14 <revenantphx> I'll start writing up packet structures in a C struct/Haskell ADT mashup syntax and they'll *never know*
19:39:03 <Jesin> > (>=>) (+) (*) 2 3
19:39:05 <lambdabot>   15
19:39:11 <Jesin> > (<=<) (+) (*) 2 3
19:39:12 <lambdabot>   9
19:39:30 <Jesin> > (>=>) (*) (+) 2 3
19:39:32 <lambdabot>   9
19:39:34 <Jesin> > (>=>) (*) (-) 2 3
19:39:35 <lambdabot>   3
19:39:40 <Jesin> > (>=>) (-) (*) 2 3
19:39:42 <lambdabot>   -3
19:39:50 <Jesin> > (>=>) (-) (*) 5 3
19:39:51 <lambdabot>   6
19:40:02 <Jesin> > (>=>) (*) (-) 5 3
19:40:03 <lambdabot>   12
19:40:04 <troutwine> I've been away for a while; what is the default character encoding of ghc 6.12?
19:45:26 <Bynbo7> @quote geheimdienst.Axman6
19:45:26 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
19:46:40 <Bynbo7> @quote cryomorphobalonical
19:46:40 <lambdabot> geheimdienst says: We employ a simple implementation of cryomorphobalonical panfunctors as introduced by Axman6
19:46:58 <geheimdienst> @quote geheimdienst Axman6
19:46:58 <lambdabot> geheimdienst says: We employ a simple implementation of cryomorphobalonical panfunctors as introduced by Axman6
19:47:15 <Bynbo7> I don't remember doing that... was i drunk?
19:47:24 <geheimdienst> i think any nickname has to go as the first arg ...
19:52:17 <lars9> who can give a one line split :: a -> [a] -> [[a]] ?
19:52:58 * geheimdienst gets a sad look in his eye
19:53:04 <brisbin> wordsBy
19:53:21 <jmcarthur> :t (>>>)
19:53:23 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
19:53:30 <Olathe> > wordsBy 5 [1..10]
19:53:30 <jmcarthur> oh i was scrolled up
19:53:31 <lambdabot>   Not in scope: `wordsBy'
19:54:05 <geheimdienst> lars9, i think what most people recomment is to install and import Data.List.Split
19:54:07 <Olathe> > span (==5) [1..10]
19:54:07 <lambdabot>   ([],[1,2,3,4,5,6,7,8,9,10])
19:54:19 <brisbin> > Data.List.Split.wordsBy (=='a') "alphabet"
19:54:20 <lambdabot>   Not in scope: `Data.List.Split.wordsBy'
19:54:26 <brisbin> oh well
19:55:28 <geheimdienst> brisbin, i think it is an unlucky state of affairs. the recommended way is some semi-obscure package not installed by default, which hoogle doesn't find, which lambdabot doesn't know about ...
19:56:05 <brisbin> geheimdienst: all i can say is, when i knew i need a wordsBy, google found it
19:56:20 <lars9> geheimdienst: every language has split in their std lib, except C and Haskell
19:56:34 <brisbin> atleast that's decent company?
19:58:48 <elliott> So how does one... use this TextEncoding stuff in GHC.IO.Encoding.Types?
20:03:31 <ddarius> geheimdienst: Would you prefer the old recommended way of writing it yourself?
20:04:05 <geheimdienst> i think the right thing would be to stick it in Prelude ...? "break" and stuff like that are already in there
20:04:53 <ddarius> @hoogle break
20:04:54 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
20:04:54 <lambdabot> Data.ByteString break :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
20:04:54 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
20:05:26 <ddarius> geheimdienst: Adding stuff to the Prelude could break existing code.
20:07:36 <geheimdienst> yeah ... let's make a new module then or something
20:07:43 <geheimdienst> MoarPrelude
20:07:48 <geheimdienst> Prelude.Moar
20:07:57 <j-invariant> MOAR
20:08:10 <revenantphx> :)
20:08:25 <revenantphx> defining all packets in terms of ints, reals, lists and tuples...
20:08:28 <revenantphx> makes it so much easier to work with
20:08:39 <revenantphx> no complex data structures that arent just compounded simple ones ^_^
20:09:27 <ddarius> (Actually, adding split to the Prelude probably -would- break a good amount of existing code.)
20:09:47 <geheimdienst> anyhoo, what i'm saying is: when hacking xmonad for instance, i have written my own split, because it's easier to add those 3 lines. the alternative would've been to install Data.Lists.Split, add a new dependency to .cabal, import the thing, and then call wordsBy ...
20:10:01 <ddarius> geheimdienst: The problem that led this is that people couldn't decide on the semantics for "split."  If you note, there is a lot more than one "split" function in that module.
20:10:39 <geheimdienst> true, but put the thing that covers 80% into prelude and the bells and whistles somewhere else
20:11:06 <ddarius> geheimdienst: We already have words and lines in there.
20:12:04 <ddarius> revenantphx: Just define everything in terms of untyped pairs.  People will think you are a genius.
20:12:23 <revenantphx> the lists are pretty much just that.
20:12:28 <revenantphx> Since there's no metadata on a tuple.
20:12:44 <revenantphx> (so a 3-tuple is really just (a, (b, c))
20:13:24 * ddarius recommends (a, (b, (c, ())))
20:14:15 <Olathe> > let split x xs = let f [x] = fst x:[drop 1 (snd x)]; f (x:xs) = fst x:f xs in f . tail . takeWhile (not . null . snd) . iterate (break (== x) . drop 1 . snd) $ (undefined, undefined:xs) in split 5 [1..10]
20:14:17 <lambdabot>   [[1,2,3,4],[6,7,8,9,10]]
20:14:41 <ddarius> Olathe: Do you like writing ugly code?
20:15:11 <j-invariant> lOL
20:15:11 <geheimdienst> so what? there's also strange stuff like readsPrec and seldom-used things like gcd and lcm. it's not like Prelude has only a limited amount of space
20:15:12 <j-invariant> harsh
20:15:39 <ddarius> geheimdienst: I'm saying lines/words -are- the functions that cover 80% of the cases.
20:19:04 <ddarius> readsPrec is used by derived instances of Read and will be handy for most Read instances for non-trivial types.
20:21:13 <geheimdienst> i think lines and words are handy, but i don't think they cover 80%. PATHs are foo:bar:baz. there's tons of comma-separated and tab-separated things. in javascript, which has split, "give me the part after the last ." is simply «"tons.of.lolcats.zip".split(".").slice(-1)»
20:21:38 <gwern> geheimdienst: well, that's what the split package is for
20:23:51 <ddarius> Actually not having split handy is probably helpful in the same way that not having regexes handy is.
20:24:03 <geheimdienst> i'm saying it's inconvenient. a commonly needed thing, in most languages part of the standard library, is a little far away in haskell. this seems like an odd omission to me.
20:24:20 <edwardk> class (applewebdata://B8D975E8-E619-4A0E-B0CB-2456B145C208/Control-Monad-Array-Class.html#t%3AMonadArray m, MArray (applewebdata://B8D975E8-E619-4A0E-B0CB-2456B145C208/Control-Monad-Array-Class.html#t%3AUArr m) applewebdata://B8D975E8-E619-4A0E-B0CB-2456B145C208/Library/Frameworks/GHC.framework/Versions/612/usr/share/doc/ghc/html/libraries/base-4.2.0.2/Data-Bool.html#t%3ABool m, MArray (applewebdata://B8D975E8-E619-4A0E-B0CB-2456B145C2
20:24:47 * hackagebot monadic-arrays 0.2 - Boxed and unboxed arrays for monad transformers  http://hackage.haskell.org/package/monadic-arrays-0.2 (EdwardKmett)
20:26:32 <edwardk> now with all of that, i can save a few bytes of memory in my graph lib ;)
20:26:59 <gwern> geheimdienst: there are too many splits
20:27:04 <gwern> geheimdienst: so it's best in a library
20:28:37 <geheimdienst> gwern, yes i agree to not spam Prelude. i just thought it's a good idea to put the common thing that covers 80% in there, while putting the less common things in other modules
20:29:04 <geheimdienst> that "there are many splits" didn't prevent a split on \n and a split on " " from being put in the Prelude ...
20:29:50 <edwardk> thats what words/lines are for
20:30:07 <edwardk> plus there isn't a good name that isn't all camelcasey
20:31:40 <geheimdienst> yeah i was referring to words/lines
20:31:50 <edwardk> and there are no good laws for it, because what do you do with the whitespace or newline? it gets thrown away so you can't graft it back together, and Just (l, r) <- splitNewLine foo, l ++ '\n' ++ r isn't a suitable law because there are potentially multiple newline characters
20:32:02 <geheimdienst> and there's maybe 30-40 camelcasey names in Prelude
20:32:18 <ddarius> Actually the difference between words and lines is a good argument against a "standard" split.
20:32:30 <ddarius> Words is not "split on ' '"
20:32:35 <edwardk> yeah
20:32:42 <troutwine> I've got "http-enumerator >= 0.3.1 && < 0.4" in my cabal build-depends but I'm told that the dependency is missing when I go to configure. Am I doing something wrong? My Arch box is still on ghc 6.12. 
20:32:48 <edwardk> good point
20:33:32 <gwern> how did lines and words get put in? I don't think they're list processing stuff I see very much in other contexts...
20:33:54 <geheimdienst> edwardk, your point that there's no laws for it would be an argument against having words/unwords in Prelude
20:33:55 <ddarius> interact
20:33:59 <ddarius> ^ gwern
20:34:18 <elliott> Is there a way to make GHCi print out that oldschool ASCII art when it starts up? I think it would have a calming effect on me.
20:34:35 <Zao> Maybe you can do naughty things in your .ghcirc or whatever it's called?
20:34:44 <gwern> ddarius: they're just to make interact easier to use? lame
20:34:56 <edwardk> gehemdeinst: they are there. i'm not advocating taking them out. i'm just pointing out that the semantics of such a split operation are complicated and unintuitive enough that it doesn't provide enough benefit to outweigh the difficultyu explaining it, and half the time you'd have to write your own anyways
20:34:58 * ddarius think geheimdienst failed to understand my point re the analogy to regexes.
20:35:02 <elliott> Zao: possibly.
20:35:44 <revenantphx> x06 Multi Block Change [list(x, y, z, type, meta)]
20:35:44 <revenantphx>     Blocks :: [(X, Y, Z :: Int64, Type :: UInt16, Meta :: UInt8)]
20:35:45 <revenantphx> :)
20:35:47 <revenantphx> yay.
20:35:56 <edwardk> words/lines are rather non-surprising in their behavior. any use of such a manual split requires you to think carefully about its semantics because you're going to be calling it over and over
20:35:57 <revenantphx> (It's not really haskell, but it looks similar ish)
20:36:08 <Mathnerd314> is there an explanation of mfix for people who barely understand fix?
20:36:13 <j-invariant> no
20:36:19 <ddarius> Mathnerd314: Why do you care?
20:36:19 <geheimdienst> edwardk: i don't think it has to be difficult to explain. it's like break, only that it runs over the entire list
20:37:00 <edwardk> gehemdeinst: does it consume the token?
20:37:19 <Mathnerd314> ddarius: I was hoping for a large quantity of "MonadFix is like a burrito" tutorials
20:37:33 <edwardk> gehemdeinst: meh, its not there. i'm not worried about there are a dozen libraries providing variations with different semantics
20:37:36 <ddarius> Mathnerd314: Why do you care?
20:38:02 <edwardk> the only real good overview i;ve seen on mfix is the original paper
20:38:18 * ddarius highly recommends not using mfix directly.
20:38:24 <Mathnerd314> ddarius: because it looks easier to understand than arrows?
20:38:27 <edwardk> http://1661695479693904713-a-1802744773732722657-s-sites.googlegroups.com/site/leventerkok/recdo.pdf?attachauth=ANoY7cpt92hkdfZjxtj7snhUzZHBTuAHlGOpRTtQV24-XFlHF5U6rEJOq1E_wBXzJhAuZS__wtu-vWls16uFfr6rqT1xxWW8KXcTaWg6UDqMzvfm2DQFb_yPACe0uPlE3GQl89jPj8mPNm5-KkoLW24MgIUnvX0xu9JKfSPG5Qjh97OAh1UiwRrcSF6rxR5jxY3HgHV_YvgN&attredirects=0
20:38:29 <edwardk> ugly link
20:38:32 <geheimdienst> yes. if i was gonna make a GeheimPrelude, i'd put in the consuming split and have the non-consuming split in another module
20:38:41 <edwardk> http://sites.google.com/site/leventerkok/ — a Recursive do for Haskell
20:38:56 <troutwine> Oh, cabal doesn't automatically pull in dependencies. Wow, I have been gone from Haskell for too long. 
20:39:52 <ddarius> Mathnerd314: I highly suspect there is something more relevant to what you might actually want to do that you should learn before.
20:39:58 <bapuche> Back with another beginner's question: How can I make the following pattern more elegant? [[a]|a<-[1..10]]; [[a,b]|a<-[1..8],b<[1..8]]; [[a,b,c]|a<-[1..8],b<-[1..8],c<-[1..8]]; [[a,b,c,d]|a<-[1..8],b<-[1..8],c<-[1..8],d<-[1..8]] i.e. add another variable to the output list.
20:40:44 <j-invariant> bapuche: use recursion
20:41:02 <Bynbo7> [[a]]|a<-[1..10]] is map return [1..10]
20:41:06 <j-invariant> > sequence (map return "abc" ++ ["d","D"])
20:41:08 <lambdabot>   ["abcdD"]
20:41:10 <davidL> > replicateM 3 [1..8]
20:41:11 <lambdabot>   [[1,1,1],[1,1,2],[1,1,3],[1,1,4],[1,1,5],[1,1,6],[1,1,7],[1,1,8],[1,2,1],[1...
20:41:22 <j-invariant> > sequence (map return "abc" ++ [["d","D"]])
20:41:22 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
20:41:23 <lambdabot>         against inferred type...
20:41:35 <j-invariant> > sequence (map (return . return) "abc" ++ [["d","D"]])
20:41:37 <lambdabot>   [["a","b","c","d"],["a","b","c","D"]]
20:41:46 <revenantphx> ahahahahaha >:D
20:41:50 <revenantphx> I have them all writing ADT
20:41:53 <revenantphx> and they DONT KNOW IT.
20:42:12 <revenantphx> "oh this is a convenient way to write out the structure of these packets"
20:42:36 <revenantphx> But unbeknownst to them they are secretly using a ripoff of haskell's type syntax.
20:42:48 <shachaf> revenantphx: Have whom?
20:42:56 <bapuche> Not following you.
20:43:01 <revenantphx> I'm working on a protocol specification for a large project with some people.
20:43:17 <revenantphx> And I had to bitch for 30 minutes to get them to add tuples (in addition to arrays, ints, reals, etc)
20:43:25 <shachaf> Which project?
20:43:31 <revenantphx> it's a secret :P
20:43:50 <shachaf> Ha.
20:43:59 <Cale> revenantphx: Try to convince them to add a representation for functions ;)
20:44:00 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
20:44:10 <revenantphx> Cale: this is a wire protocol sadlt.
20:44:14 <bapuche> Don't see how to use recursion to add another variable to the list comprehensions.
20:44:17 <gwern> 'Zuck was -- remarkably! -- unphased by this line of thinking and went ahead and built Facebook, and just to prove how useless everything we teach about efficiency and careful software design in CS161 really is, he implemented it in PHP. And it worked. Oh yeah, and he managed to grow the site to over 175 million users. So clearly I know pretty much zip when it comes to figuring out what a good startup business strategy is going to be, which explains ...
20:44:17 <revenantphx> We can't wire functions as far as I know.
20:44:24 <gwern> ... why I should remain safely ensconced in my office at Harvard.'
20:44:26 <revenantphx> but Cale, when one of them wrote
20:44:26 <revenantphx> Blocks :: [(X, Y, Z :: Int64, Type :: UInt16, Meta :: UInt8)]
20:44:28 <revenantphx> I was like
20:44:33 <revenantphx> YESSSSS MISSION SUCCES
20:44:36 <Cale> @tell BMeph http://analogical-engine.com/
20:44:37 <lambdabot> Consider it noted.
20:44:45 <j-invariant> what do you say instead of return in haskell?
20:45:04 <Cale> j-invariant: evaluate to?
20:45:12 <edwardk> j-invariant: 'pure' *da-dum-dum*
20:45:15 <Cale> j-invariant: result in, return
20:45:19 <shachaf> j-invariant: "be"
20:45:21 <j-invariant> haha
20:45:30 <Cale> Or yeah, be/is
20:45:55 <Cale> revenantphx: Heh, you could wire lambda terms ;)
20:45:56 <geheimdienst> invisabl return!
20:46:09 <revenantphx> Cale: encode lisp, rule the world!
20:46:53 <Mathnerd314> ddarius: my current goal is nothing except to internally comprehend what MonadFix does.
20:46:54 <ddarius> gwern: Worse is better.  We already have a paper on it.
20:47:06 * gwern sighs. no kidding.
20:49:31 <jetkoten> hi guys, i'm new to haskell and thinking of installing the platform (on OSX), but i notice that there is a new major release due in only about a week, will it be a problem to reinstall everything when it comes out, or will it likely just work fine? thanks in advance.
20:51:34 <Bynbo7> jetkoten: just install the platform, if you're new to haskell, you ptobably won't run into many problems anyway
20:53:43 <edwardk> ddarius: cool, so my lack of documentation is a feature!
20:53:45 <j-invariant> is "Mu" a functor?
20:54:19 <ddarius> j-invariant: No, it doesn't have the right kind, unless you meant categorically.
20:54:36 <edwardk> categorically it maps endofunctors on a category to objects in that category
20:54:39 <ddarius> edwardk: People don't read documentation anyway, so you spending less time on documentation = you spending more time on code which is a feature.
20:54:47 <edwardk> yeah
20:55:28 <djahandarie> ddarius, what? I read documentation all the time lol
20:55:48 <ddarius> From this we can conclude that djahandarie isn't a person.
20:56:05 <bapuche> Along the same lines, why is there a zip, zip3, zip4, etc? Why not a zip n function?
20:56:29 <Bynbo7> what would its type be?
20:56:46 <ddarius> Damn.  Bynbo7 knows my secret weapon.
20:56:48 <Bynbo7> :t zip
20:56:49 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
20:56:53 <Bynbo7> :t zip3
20:56:54 <lambdabot> forall a b c. [a] -> [b] -> [c] -> [(a, b, c)]
20:56:58 <Bynbo7> :t zip4
20:56:59 <lambdabot> forall a b c d. [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]
20:57:08 <jetkoten> Bynbo7: Thanks!
20:57:11 <Bynbo7> those types don't look at all the same!
20:57:17 <monochrom> you can probably do "zip n" with dependent types
20:57:31 <ddarius> The Chinese, so innocent.  "Ignorance never settles a question."
20:57:39 <djahandarie> Might be able to do it with type families...
20:57:40 <ddarius> monochrom: There is no probably about that.
20:57:51 <ddarius> You don't even need dependent types for the usual case.
21:05:01 <zzing> In a setup.hs is there a way of specifying a list of files except for that in the cabal file?
21:05:06 <ddarius> @google "zip calculus"
21:05:07 <lambdabot> http://www.springerlink.com/index/4k66738119u02119.pdf
21:05:07 <lambdabot> Title: SpringerLink - Abstract
21:14:19 <Saizan> "genericity over the length of tuples" sounds quite narrow as a field of study
21:19:22 <j-invariant> there is all thisnice theroy about free algebras (Data types) but what about non-free?
21:19:33 <j-invariant> why cant we have non-free data tpes
21:19:41 <copumpkin> captive data types
21:19:42 <lambdabot> copumpkin: You have 1 new message. '/msg lambdabot @messages' to read it.
21:19:56 <dolio> Data is free by definition.
21:20:17 <j-invariant> what do you mean
21:20:39 <bvck> hi folks, can someone please explain the (or provide a pointer) to the syntax for evalState? What does -> s and -> a do there?
21:21:20 <bvck> (this is from State.hs in hugs98
21:21:21 <dolio> Data types are defined by their constructors. They are the set of syntactic terms built up of those constructors.
21:21:28 <dolio> That is a free algebra.
21:21:31 <j-invariant> yeah but Im talking about something else
21:22:32 <monochrom> @type evalState
21:22:33 <lambdabot> forall s a. State s a -> s -> a
21:23:07 <bvck> Duh! Got it. Thanks.
21:23:35 <monochrom> an example: evalState (get >>= \n -> put (n+1) >> return True) 4
21:24:10 <bvck> Thanks monochrom.
21:26:26 <Saizan> j-invariant: maybe you meant quotient types?
21:33:23 <brbrooks> hello
21:33:36 <brbrooks> how can i prove that a type system is equivalent to an abstract machine
21:34:18 <j-invariant> brbrooks: that doesn't make sense
21:34:50 <Kaidelong> perhaps he means a particular aspect of how you'd use a type system?
21:39:09 <brbrooks> let me rephrase
21:40:50 <Rotaerk> @pl \f g a b c -> g a b + g b c + g c a
21:40:51 <lambdabot> const (ap (ap . ((flip . (liftM2 (+) .)) .) . (flip =<< (liftM2 ((.) . (+)) .))) flip)
21:41:19 <brbrooks> say an abstrac machine implements a language, but it's possible for this machine to reach stuck states.  How do I prove that I have found a type system that prevents reaching those stuck states
21:42:30 <brbrooks> is this done somewhere in literature
21:42:33 <brbrooks> ?
21:43:07 <j-invariant> brbrooks: that is called type soundness - you can prove it by induction
21:45:52 <Saizan> also "progress"
21:47:40 <brbrooks> does the proof use operational semantics?
21:48:37 <brbrooks> how do you correlate the types to the evaluation rules..? does it matter whether it's an abstract machine or plain inference-style evaluation rules ?
21:49:34 <Saizan> you can e.g. prove that each evaluation step preserves the type
21:51:52 <Saizan> not sure if using an abstract machine changes things much
21:54:22 <revenantphx> @quote #haskell
21:54:23 <lambdabot> LoganCapaldo says: madness? This is #haskell!
21:54:29 <revenantphx> @quote irc://hubbard.freenode.net/#haskell revenantphx
21:54:30 <lambdabot> No quotes for this person.
21:54:37 <revenantphx> @quote revenantphx #haskell
21:54:37 <lambdabot> revenantphx says: You don't need category theory to understand Haskell, though you may need it to understand #haskell.
21:54:46 <revenantphx> something along those lines.
22:03:39 <gienah> brbrooks: I just love slide 4 of this presentation on how to prove the typing rules :-) http://www.seas.upenn.edu/~sweirich/talks/cuny09.pdf
22:04:59 <tg_> it's like the matrix
22:05:41 <gienah> how deep does the rabbit hole go ?
22:07:06 <tg_> that phrase always bothered me a bit. It's not the deepness of the rabbit hole that gets you in trouble, it's the rabbit-diamater-ness
22:07:48 <tg_> that slide really is nice though
22:07:53 <tg_> hammers the point home
22:08:08 <gienah> its not to you get in deep that it starts get narrower ...
22:08:32 <tg_> yeah, to be totally honest, I'm not sure I've ever seen a rabbit hole
22:10:09 <gienah> there is a book called "certified programming with dependent types" it has some really neat automated stuff for proving typing rules in coq, however even for a small language it could take half an hour for coq to crunch it
22:10:58 <gienah> so maybe it might be better to prove it more manually, I'm not sure
22:11:31 <dolio> The deep rabbit hole is presumably a reference to Alice in Wonderland.
22:12:08 <tg_> wit is
22:12:12 <tg_> and it's also used in the Matrix
22:12:18 <dolio> Shallow rabbit holes aren't portals to wonderland.
22:12:33 <tg_> oh
22:12:43 <tg_> either way you have to be rabbit sized to take advantage of rabbit transporation systems
22:13:05 <dolio> Mirrors are clearly the better method of travel.
22:13:15 <zzing> I prefer magic carpets
22:13:32 <tg_> I suppose one could postulate *very* large rabbits, but I digress
22:13:36 <zzing> I hear that is the main form of travel in saudi arabia
22:14:01 <tg_> that must explain why they have so much oil
22:14:06 <geheimdienst> zzing, in what country are rabbit holes the preferred form of transportation?
22:14:29 <zzing> geheimdienst: Austrailia
22:14:40 <tg_> can't be, they use kangaroo pouches
22:15:12 <c1de0x> so my resident haskell master is asleep. i have a question.
22:15:19 <geheimdienst> those are not exclusive at all. hop in your kangaroo pouch and head into the rabbit hole
22:15:28 <tg_> plus, knowng that place, their rabbits are probably venemous, professional boxers with wicked right hooks
22:15:51 <c1de0x> is it possible to retrieve the sequence of monadic operations in a do sequence without executing them?
22:16:18 <c1de0x> i.e. if i'd like to 'inspect' the sequence, by iterating over it, and perhaps building a use-def tree
22:17:52 <gienah> c1de0x: I wonder if you came to haskell via lisp or scheme, I have no idea sorry
22:18:03 <c1de0x> no. not via lisp or scheme ;)
22:18:32 <Eduard_Munteanu> Probably not, it's like asking to get a list from an already folded one.
22:22:24 <tolkad> If I use a TChan and I have one long transaction involving reading from it, and many frequent short transactions involving reading from it, is the long one likely to never complete?
22:23:16 <Bynbo7> it's quite possible. you should try and heel transactions as small as possible
22:23:38 <tolkad> how do you heel them?
22:23:59 <tolkad> oh nevermind
23:01:03 <zzing> Does anyone know why I am getting a parse error in this code when I load it up in ghci? I am sure it is something simple, but not sure. https://gist.github.com/ec5620d68cd34893b477
23:03:32 <Bynbo7> well, the types don't make sense:
23:03:34 <Bynbo7> :t (/)
23:03:35 <lambdabot> forall a. (Fractional a) => a -> a -> a
23:03:45 <Bynbo7> needs to be Fractional not Num
23:04:04 <zzing> Bynbo7: You are correct, but doesn't explain the parse error
23:04:16 <Bynbo7> are you using tabs?
23:04:31 <Bynbo7> also, it would help greatly if you pasted the parse error
23:04:51 <zzing> <interactive>:1:8: parse error on input `secant' 
23:05:06 <zzing> and there are no tabs
23:05:18 <Bynbo7> i assume you're writing this in a file right?
23:05:25 <zzing> yes
23:05:40 <Bynbo7> can you try removing the type signature line? just to figure out which secant it's taking about
23:06:12 <zzing> It makes no difference
23:07:35 <Bynbo7> also there's no need to put brackets around the arguments to f: f(x) == f x
23:07:43 <ddarius> Most likely a tabs thing.
23:07:55 <zzing> oops, yes I of course know that, I was kind of copying from a math book :p
23:08:23 <zzing> ddarius: there are no tabs
23:08:28 <zzing> I have checked this in vi
23:08:46 <Bynbo7> works fine for me when i change Num to Fractional
23:09:26 <zzing> hmm
23:12:41 <zzing> This is the exact version of what I am loading: https://gist.github.com/f1c54d123fd66afdac5f I still can't figure out why I have this parse error. Would there be anything from ghc7 that might cause it?
23:12:56 <Bynbo7> I'm using ghc 7
23:13:44 <Bynbo7> hmm, that comment didn't quite work properly
23:14:06 <Bynbo7> is there anything else in the file?
23:14:20 <zzing> Nope, i pasted all of it
23:14:35 <Bynbo7> which OS?
23:14:40 <zzing> mac
23:14:44 <Bynbo7> wondering if it's maybe a new line issue
23:14:49 <Bynbo7> which editor?
23:14:57 <zzing> textmate and textwrangler
23:15:10 <zzing> LF line endings
23:15:14 <zzing> UTF-8
23:15:27 <Bynbo7> well textmate works fine for me, that what i used to make the file
23:20:10 <zzing> Bynbo7: What did you name the file and what did you use to load it? I think the error is on ghci not the source file
23:20:26 <kenjin2201> what's -O2 option in ghc, like in $ghc --make -O2 file.hs ?
23:24:04 <shachaf> kenjin2201: -O is optimization.
23:26:59 <ddarius> Poor equality symbol.  It has been steadily shrinking since its inception.
23:27:30 <ddarius> zzing: The question is, what did -you- do to load it?
23:27:53 <zzing> Prelude> import Secant
23:27:53 <zzing> module is not loaded: `Secant' (./Secant.hs)
23:28:12 <ddarius> zzing: That's not how you load a file.
23:28:23 <zzing> I must forget something :p
23:28:26 <ddarius> Use :load or you can put it on the commandline of ghci when you invoke it.
23:28:41 <zzing> dear lord, how did I forget that
23:29:58 <kenjin2201> shachaf: Thank you. I find when I use the option, the compiled program uses increased stack than without it
23:30:04 <zzing> ddarius: merci
23:30:30 <BMeph> So, informal survey: I'm thinking of requesting "remove 'if-then-else" from Haskell. Like it, don't like it, don't even try it? Tell me. :)
23:30:30 <lambdabot> BMeph: You have 1 new message. '/msg lambdabot @messages' to read it.
23:32:30 <ddarius> You can try it.  You won't succeed though.
23:33:17 <zzing> BMeph: why would people want that?
23:34:35 <BMeph> zzing: Because it, like "return" are puns that now-a-days do more harm than good. In my opinion, that is, which of course, means nothing. :)
23:35:03 <zzing> Perhaps you should explain what that really means
23:35:25 <ddarius> BMeph: If you go with that argument, you definitely won't succeed.
23:35:26 <n0den1te> Maybe he's punning himself. 
23:35:28 <n0den1te> :)
23:36:14 * ddarius wishes there was a place open 24 hours within easy walking distance.
23:36:17 <Eduard_Munteanu> BMeph: I use it sometimes, but it sucks on longer statements. I tend to use 'case' constructs to avoid indentation requirements of if-then-else
23:36:34 <BMeph> zzing: if-then-else is a form of statement familiar to folks who use C/C++/Java/Python et al. They know how it works and are comfortable with it. Unfortunately, the way it works in Haskell defies those expectations. We can do without it in Haskell, and I think we should.
23:36:38 <zzing> Perhaps replace it with ?: :P
23:36:53 <ddarius> Except that it isn't a statement.
23:37:21 <BMeph> ddarius: It isn't a statement in Haskell. Which is part of my point. :)
23:38:28 <ddarius> BMeph: Optimizing for people who can't tell the difference between a statement and an expression isn't a worthy goal.
23:38:47 <ddarius> zzing: b ? (t, e) = if b then t else e
23:38:58 <BMeph> ddarius: I think we should not cater to expectations that are false from the get-go.
23:39:14 <zzing> ddarius: b ? t : e     :P 
23:39:19 <zzing> Yes it is evil
23:39:37 <BMeph> ddarius: Just like I dislike the "return" function's name. It provokes expectations that are misleading. Deliberately.
23:39:48 <ddarius> BMeph: I don't believe if-then-else was added to "pun" off of imperative notation.  It's perfectly reasonable functional notation.
23:40:08 <zzing> BMeph: What better name?
23:40:42 <zzing> I am a little rusty, but is it like lift?
23:40:51 <n0den1te> BMeph: adding to what ddarius said, there's something equivalent in scala. val foo = if boolean_conditional x else y. I have found it very useful.
23:40:59 <BMeph> ddarius: It's reasonable, it's just a "special form" whose specialness irks me.
23:41:06 <zzing> @src return
23:41:06 <lambdabot> Source not found. My brain just exploded
23:41:13 <ddarius> BMeph: That's a different argument.
23:42:16 <BMeph> zzing: "pure" works. I also like "inject" since it suggests a counter to the comonadic "extract".
23:42:24 <n0den1te> :t return
23:42:25 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
23:42:41 <n0den1te> aww, I don't grok monads yet. :(
23:42:44 <zzing> Correct me if I am wrong, but doesn't return basically bring a into m?
23:42:52 <BMeph> ddarius: But to the same end: "if-then-else" delenda est. 
23:43:39 <ddarius> I wasn't complaining about the ends, I was complaining about the argument.
23:44:02 <zzing> BMeph: Recte fortasse
23:44:33 <BMeph> n0den1te: liftM2 f ma mb == do { a <- ma; b <- mb; return f a b }
23:45:25 <ddarius> The only benefit of getting rid of if-then-else for me would be annihilating the DoIfThenElse ridiculousness.
23:45:35 <BMeph> n0den1te: That form looks familiar, doesn't it?  ;)
23:45:38 <zzing> ddarius: doifthenelse?
23:45:44 <n0den1te> BMeph: ah. :)
23:46:48 <n0den1te> BMeph: that looks like forall. :)
23:47:10 <ddarius> BMeph: That's a type error.
23:47:22 <ddarius> Well, maybe not quite.
23:47:26 <BMeph> ddarius: I think that is just one more reason to kill it. But I'm not sure what your complaint about the argument was besides "it's a different one from what I first said."...
23:47:42 <ddarius> BMeph: I was complaining about your -first- argument.
23:48:05 <ddarius> Then you presented another.
23:48:14 <ddarius> I merely noted that it was a different one.
23:49:28 <BMeph> ddarius: How about "if-then-else is a statement in other PLs that programmers are familiar with. In Haskell, it isn't a statement, but an expression that looks similar. but doesn't quite work the same way."
23:49:45 <ddarius> BMeph: I wasn't complaining about the wording of your original.
23:50:16 <zzing> It is essentially equivalent to the C ?: is it not?
23:50:23 <ddarius> zzing: Yes.
23:50:47 <Eduard_Munteanu> 'pure' worked if Monads were Applicatives.
23:51:06 <Eduard_Munteanu> I suspect a 'pure'-only typeclass makes sense.
23:51:32 <zzing> Has work begun on haskell 20[whatever]? 
23:52:09 <BMeph> ddarius: Followed by the "Familiarity with if-then-else in other languages leads people to mess up the layout for its use, to the point that a change was prompted in Haskell's syntax to accomodate the error."
23:53:28 <Eduard_Munteanu> Some call/cc variant of 'return' that worked a bit more like C's return would be nice.
23:53:41 <ddarius> BMeph: You just make the argument even less compelling.  People are simply going to be going to assume if we were willing to change the syntax of the language for this feature, it must be in demand/useful/worth keeping.
23:54:01 <ddarius> Eduard_Munteanu: There is.  Use callCC.
23:54:04 <BMeph> Eduard_Munteanu: The "pure" function is used in Applicative, Pointed, and (possibly no longer) Arrow. Using it in Monad would be consistent, in a way that does not mislead.. I personally think that non-misleading expectations in a language are a Good Thing(TM). ;)
23:54:17 <ddarius> Eduard_Munteanu: Otherwise there's nothing delimiting a "function."
23:55:34 <Eduard_Munteanu> OTOH, I'm all for 'unit' and 'join', and provide typeclass defaults for 'bind' and an out-of-typeclass alias for return.
23:56:23 <BMeph> Eduard_Munteanu: Except "unit" risks confusion with "()", also pronounced "unit".
23:56:50 <ddarius> BMeph: Don't worry, we'll just rename () to void to avoid confusion.
23:57:45 <n0den1te> Oh, I don't see unit very useful here. Unit == void. 
23:58:34 <Eduard_Munteanu> But I don't think these things are the biggest issue.
23:58:52 <Eduard_Munteanu> IMHO, the biggest issue is the namespace mess that Prelude causes because it's not using Foldable etc.
23:59:25 * ddarius hardly considers that a "big issue."
