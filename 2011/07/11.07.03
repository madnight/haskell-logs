00:06:51 <wli> lhs2TeX is doing a bad job formatting floating point numbers like 1.0e-14
00:07:11 <wli> Can something be done about this?
00:09:19 <ndandy> @messages?
00:09:20 <lambdabot> Sorry, no messages today.
00:10:14 <ion> wli: Yes
00:11:20 <wli> ion: Pray tell, what?
00:11:35 <ion> It’s open-source software, isn’t it?
00:11:56 <wli> ion: http://hpaste.org/48654 <-- the code where formatting goes wrong
00:37:53 <ClaudiusMaximus> hm, System.Posix.IOCtl is nice.. but how do i get the errno out of the IOException to see if it was EGAIN?
00:38:01 <ClaudiusMaximus> *EAGAIN
00:38:53 <ClaudiusMaximus> apparently it gets mapped to ResourceExhausted somewhere, but i can't figure out how to extract that from anywhere
00:40:24 <Saizan> is ResourceExhausted a type^
00:40:26 <Saizan> ?
00:41:07 <ClaudiusMaximus> i don't know, can't remember where i found it now..
00:42:39 <ClaudiusMaximus> http://hackage.haskell.org/packages/archive/base/4.3.1.0/doc/html/src/Foreign-C-Error.html#errnoToIOError
00:42:40 <Saizan> i was thinking that maybe it's another instance of Exception
00:44:43 <ClaudiusMaximus> aha, defined in GHC.IO.Exception
01:01:43 <Phyx-> time to find my leak
01:01:49 * Phyx- opens WinDbg
01:03:44 <Phyx-> can you instruct cabal to install a file *somewhere*, for instance a .NET DLL into the GAC?
01:32:39 <Totramon> how would I go about mapping a list to a boolean list so that an element should be true if substituting it in the original list has certain results
01:33:05 <edwardk> substituting it in the original list how?
01:33:28 <Totramon> for the sake of simplicity, say if the list was a list of numbers, substituting it by 0
01:33:55 <Totramon> and the test might be whether then sum of all elements is 10
01:34:07 <edwardk> ah
01:34:29 <Saizan> re categorical presentation of unification: using as the base the category where S -> T is an arrow that goes from term in T to terms in S rather than the opposite is insane
01:34:32 <edwardk> let me dig up something similar, one sec.
01:35:04 <ivanm> Totramon: first of all, I would say that list is probably the wrong data type :p
01:35:31 <ivanm> I would guess that you'd start by zipping together the inits with the tails ...
01:36:23 <edwardk> vars in http://hackage.haskell.org/packages/archive/ad/1.1.0/doc/html/src/Numeric-AD-Internal-Dense.html does something similar. it sets up a diagonal which gets handled specially, yielding a structure full of structures, then you can map sum over that
01:36:34 <Totramon> let's see
01:37:14 <edwardk> in that case its setting up a diagonal of a matrix, represented as a pair of traversables, which is a bit more than you are looking for
01:38:08 <Totramon> that's a bit too tough for me to read at the moment, just starting out with the language
01:38:25 * hackagebot eddie 0.1 - Command line file filtering with haskell  http://hackage.haskell.org/package/eddie-0.1 (MikeMeyer)
01:38:26 <edwardk> totramon: np, we can work up a simpler way
01:38:33 <Totramon> let's simplify my problem a bit: how do I map each element to a new list that has that element substituted as a 0?
01:39:04 <geheimdienst> > map (\_ -> 0) [7..12]
01:39:05 <lambdabot>   [0,0,0,0,0,0]
01:39:10 <edwardk> let's simply a step further
01:39:27 <edwardk> how do you substitute for the nth element in your list, and replace it with 0
01:40:01 <edwardk> so start by writing
01:40:24 <ion> @pl \_ -> 0  -- const
01:40:24 <lambdabot> const 0
01:40:31 <edwardk> adjust :: Int -> (a -> a) -> [a] -> [a]
01:40:46 <edwardk> or update :: Int -> a -> [a] -> [a]
01:41:03 <edwardk> once you have one of those the next step is easy
01:41:08 <ion> update n x = adjust n (const x)
01:41:16 <Totramon> let me check that one
01:41:28 <edwardk> you need to define them. they don't exist
01:41:37 <Totramon> ah
01:41:41 <edwardk> (well, adjust is in one of my packages, but its way bigger than you want)
01:41:56 <ddarius> Saizan: There are reasons it's done that way (and it's not quite that), but for that example it really doesn't make much of a difference if you use that or the opposite category.
01:42:17 <edwardk> adjust 0 f [] = []; adjust 0 f (a:as) = f a:as; adjust n f (a:as) = a:adjust (n - 1) f as
01:42:24 <Jafet> > let xs = [1,2,3,2,1] in map (\x -> map (\y -> if x == y then 0 else y) xs) xs
01:42:25 <lambdabot>   [[0,2,3,2,0],[1,0,3,0,1],[1,2,0,2,1],[1,0,3,0,1],[0,2,3,2,0]]
01:42:49 <edwardk> jafet: not quite =)
01:42:57 <Totramon> almost :)
01:43:01 <edwardk> you can do that version by zipping with a counter though
01:43:21 <edwardk> thats basically what the scary mapAccumL version i sent him to originally does
01:43:39 <Jafet> I thought he meant that
01:43:44 <edwardk> so given adjust, now you just need to be able to adjust an appropriate entry
01:43:47 <Jafet> With a nub
01:44:15 <Totramon> yeah I could have been clearer
01:44:29 <edwardk> > zip [0..] "hello"
01:44:30 <lambdabot>   [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
01:44:54 <edwardk> with zip or zipWith we can decorate each entry in the list with its position in the list
01:44:58 <edwardk> @type zip
01:44:59 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
01:45:07 <edwardk> @type zipWith
01:45:07 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
01:45:23 <Saizan> ddarius: it gets a bit twisty when you try to match their definition of ground or constant with the usual intuition
01:45:42 <Totramon> I actually read about zip a while ago, hmm
01:45:46 <accel> is there a shorter way to write: someFunc = do { x <- someMonadDependentFunc; if (x) then a else b } ?
01:46:00 <Botje> :t ifM
01:46:01 <lambdabot> Not in scope: `ifM'
01:46:05 <Saizan> ddarius: but msotly because i didn't pay attention to the inversion until there, i guess
01:46:24 <Botje> accel: you can define an ifM yourself
01:46:25 <accel> lol, liftM if ?
01:46:49 <Jafet> Well, you'd want to write if'
01:46:50 <accel> ifM a b c = liftM2 a b c ?
01:47:06 <Jafet> Which is the usable version of if_then_else_
01:47:21 <edwardk> \xs -> map (\n -> sum (adjust n (const 0) xs) == 10) [ 0 .. length xs]
01:47:40 <edwardk> er 0 .. length xs - 1
01:47:58 <geheimdienst> i have written my own ifM, and i was wondering why i couldn't find anything in base or missingh or similar ...
01:48:35 <edwardk> so what we do is we make a new list, that has the same length as the old one that just consists of the numbers 0 .. length xs − 1
01:48:51 <accel> Botje , Jafet : thanks
01:49:11 <Jafet> Or in this case, move the first parameter to the end and do ma >>= select a b where select :: a -> a -> Bool -> a
01:49:23 <edwardk> then we map over that list. for each n, we adjust the appropriate entry in the original list, getting a new list, then we run whatever aggregate check we wanted
01:49:45 <Totramon> edwardk: I realize my real problem was not knowing how to simply replace a given element in a list :)
01:49:56 <accel> ifM a b c = do x <- a; if (x) then b else c
01:49:59 <accel> what is the type of this guy?
01:50:14 <Jafet> :t \a b c = do x <- a; if (x) then b else c
01:50:15 <lambdabot> parse error on input `='
01:50:18 <Jafet> :t \a b c -> do x <- a; if (x) then b else c
01:50:18 <lambdabot> forall (m :: * -> *) b. (Monad m) => m Bool -> m b -> m b -> m b
01:50:28 <accel> err
01:50:29 <geheimdienst> @hoogle select
01:50:29 <lambdabot> Text.Html select :: Html -> Html
01:50:29 <lambdabot> Text.XHtml.Frameset select :: Html -> Html
01:50:30 <lambdabot> Text.XHtml.Strict select :: Html -> Html
01:50:37 <accel> how do I write that as a "::" type expression in my source code?
01:50:47 <accel> i.e. "ifM :: ..... " ?
01:50:55 <accel> do I copy that entire forall expression?
01:51:02 <accel> (seems awfully long type expression)
01:51:03 <ion> (Monad m) => m Bool -> m a -> m a -> m a
01:51:04 <merijn> accel: What lambdabot says works, but you can simplify to: (Monad m) => m Bool -> m b -> m b -> m b
01:51:16 <Jafet> You can (should?) drop the forall quantification
01:51:23 <edwardk> if (x)  ಠ_ಠ
01:51:26 <Jafet> But I prefer to write it these days
01:51:33 <edwardk> brb
01:51:43 <accel> ion, merijn : got it; thanks
01:52:10 <Jafet> What's a KANNADA LETTER TTHA?
01:52:45 <edwardk> ?
01:52:46 <ion> jafet: ಠ
01:52:47 <accel> before I leave; one last question, is there an inverse of 'gets' ? i.e. there's get/put ... what does gets get paired with?
01:53:05 <Jafet> Well, of course
01:53:16 <c_wraith> accel: you need some sort of accessor/lens package to get a real inverse of gets
01:53:44 <edwardk> accel: no. there can't be
01:53:50 <edwardk> accel: on the other hand you can use lenses
01:53:56 <edwardk> accel: those provide both a getter and a setter
01:53:59 <accel> c_wraith , edwardk : noted , thanks
01:54:01 <ion> :t gets
01:54:02 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
01:54:14 <edwardk> see my data-lens package or one of the others ;)
01:54:27 <ion> fclabels has getM, setM, modifyM (or something like that) for that.
01:54:36 <edwardk> puts would have to take an (a -> s -> s)
01:54:47 <accel> edwardk: http://hackage.haskell.org/packages/archive/lenses/0.1.2/doc/html/Data-Lenses.html is the first google result for lenses haskell
01:54:50 <accel> you wrote it?
01:54:55 <edwardk> accel: no
01:54:56 <edwardk> not that one
01:55:02 <edwardk> take any of the packages but that one ;)
01:55:13 <accel> oh
01:55:23 <edwardk> http://hackage.haskell.org/packages/archive/data-lens/1.8.0/doc/html/Data-Lens-Common.html
01:55:37 <accel> got it; thanks
01:55:56 <edwardk> http://hackage.haskell.org/packages/archive/data-lens/1.8.0/doc/html/Data-Lens-Lazy.html provides the ways to use them with StateT
01:56:27 <edwardk> http://hackage.haskell.org/packages/archive/data-lens-fd/1.8.0/doc/html/Data-Lens.html provides the ability to work with any MonadState
01:56:58 <edwardk> http://hackage.haskell.org/packages/archive/data-lens-template/1.8.0/doc/html/Data-Lens-Template.html lets you automatically build instances for them
01:57:08 <edwardk> er automatically build them
01:58:12 <edwardk> http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutation/5769285#5769285 provides an overview of the different lens packages.
02:02:43 <edwardk> (i just updated that post to reflect the fact that they are in data-lens, not comonad-transformers these days
02:09:24 <lysgaard> Does there exists a really fast Tree datastructere like UVector for Lists?
02:11:52 <ion> edwardk: Nice post.
02:13:55 <Saizan> we also want a strictly-positive-functors package
02:17:04 <edwardk> ion: which one?
02:17:14 <edwardk> oh the stackoverflow
02:17:32 <edwardk> saizan: what for?
02:18:30 <sam_> so what is Haskall used for? I found this on stumble..
02:18:55 <edwardk> sam_ writing software, especially when you want it to be correct
02:19:06 <sam_> web or device?
02:19:09 <merijn> sam_: The same things C, python and all other programming languages are used for? :)
02:19:21 <sam_> well they each have their uses
02:19:22 <ivanm> Saizan: what's a positive functor?
02:20:13 <edwardk> ivanm: types are in positive position when they are on the left of an even number of ->'s. they are in strictly positive position when they are on the left of 0 of them.
02:20:29 <merijn> sam_: Well, there have been several new and nice web frameworks, but most haskell development is not web focussed
02:20:34 <edwardk> ivanm: if all occurrences of a type 'a' occur in positive position you can define fmap, basically.
02:20:42 <edwardk> if they all occur in negative position you can define contramap
02:21:03 <edwardk> strict positivity is important in some theorem prover settings
02:21:25 <sam_> so you write desktop programs with it?
02:21:48 <ivanm> sam_: it's a general purpose programming language
02:21:58 <edwardk> Either a a — has both a's in strictly positive position.   a -> r  — has the a in negative position, but (a -> r) -> r — has a in positive but not strictly positive position
02:22:09 <edwardk> sam_: there are some web frameworks, some bingings for gtk, etc.
02:22:27 <edwardk> i use it to write a lot of abstract mathematics, but i'm not exactly indicative of the audience for haskell as a whole
02:22:36 <merijn> sam_: People are writing version control, compilers, web frameworks, etc. I believe some large financial firms are using Haskell for their financial software
02:23:08 <sam_> so far (as I do the tutorial) I'm seeing a lot of similarities to python
02:23:39 <edwardk> sam_: python stole bits of syntax here and there. i think you'll find them to be more consistent here ;)
02:24:02 <edwardk> sam_: the major difference between python and haskell is that haskell actually has types that the compiler can check at compile time
02:24:21 <merijn> sam_: Well, it has some similarities (python got list comprehensions from Haskell, both have functions as first class values and support higher-order functions)
02:24:22 <edwardk> sam_: while python code that is off the most frequently traveled code path tends to just bit rot
02:25:47 <Jafet> sam: and those are likely to be the only similarities between haskell and python
02:25:56 <Jafet> Superficial ones
02:26:11 <merijn> Jafet: Well, both have great IRC channels here on freenode :p
02:26:17 <Saizan> edwardk: it's just that when i see representable functors R -> a i want to add a sum there to get Sigma (\s -> R s -> a), i'm not sure what could be generically done with them that you can't do with Functor though
02:26:26 <Saizan> also, haskell lacks sigmas..
02:26:43 <Jafet> I wouldn't call functions first class in python
02:26:47 <ivanm> Jafet: well, we don't need to have explicit C/C++/Java/etc.-style type annotations...
02:26:49 <edwardk> hrmm
02:26:49 <merijn> Jafet: Why not?
02:26:53 <ivanm> Jafet: oh? why not?
02:27:05 <ivanm> Saizan: what do you mean by "sigmas"?
02:27:19 <Jafet> Because the designers intentionally nerfed the lambda syntax, among other things
02:27:21 <edwardk> saizan: so why the need for strict positivity?
02:27:38 <edwardk> other than to get this stuff to work in agda? =)
02:27:43 <merijn> Jafet: How are anonymous functions a requirement for functions being first class?
02:27:57 <merijn> sam_: Its a very nice language to learn, as someone who learned Python first I always thought that static typing sucked. Then I learned Haskell and finally figured out static doesn't suck, it's just that the static type system of C/Java/C++/etc's sucked :p
02:28:13 <edwardk> ivanm: because we have hindley-milner
02:28:14 <Jafet> And intentionally omitted tail-call optimization, so that you cannot even write a loop in the functional style
02:28:31 <sam_> cheers guys!
02:28:37 <merijn> Jafet: IMO the only requirement to calling functions first class is that they are treated as any other value by the language, which they are. (Unlike say C or Java)
02:28:56 <Saizan> edwardk: well it just happens that every strict positive functor can be built that way
02:29:01 <ivanm> edwardk: yeah, but that's another "similarity" with python in terms of how code _looks_
02:29:08 <edwardk> jafet: gah. guido's inability to comprehend the purpose of tail calls, let alone the reason they are important disturbs me
02:29:14 <Jafet> Nope, they must also not be syntactically burdened and semantically nerfed.
02:29:19 <Saizan> and vice versa
02:29:30 <Jafet> If they are, it displays a clear intention on the designers' part to not treat them like other types or values
02:29:54 <edwardk> saizan: sure but there are also lots of representable functors that have exponentials in them
02:30:11 <merijn> Lambda's in python allow any arbitrary expression like in Haskell, it's just that in python you often times don't want an expression in your lambda but statements...
02:30:14 <Jafet> Would you use lambda functions in Haskell if you had to type an extra line of boilerplate code for each one?
02:30:21 <edwardk> my representable-tries btw- are intended to be the representable-functors that are strictly positive like you say
02:30:37 <edwardk> they support traversable, adjustable, etc.
02:31:45 <edwardk> the need for countable representation is the key (though technically exponentials are also in countable territory)
02:38:15 <Saizan> so tries would be the intersection of representable and strictly positive functors?
02:39:55 <edwardk> yeah
02:40:15 <edwardk> it has worked well for me so far
02:43:45 <Saizan> but R -> a is strictly positive in 'a', so a functor can be isomorphic to a strictly positive one while not being so?
02:44:42 <edwardk> yeah
02:44:44 <Saizan> i guess (Void -> a) -> a is one :)
02:44:58 <edwardk> Yoneda f a for representable f for instance
02:45:18 <edwardk> (forall r. (a -> r) -> r) as well
02:45:48 <edwardk> but they'd make crappy memo-tries =)
02:50:26 <Saizan> relatedly, it'd be nice to have memo-tries that respected laziness
02:50:51 <edwardk> am i insufficiently lazy?
02:51:58 <Saizan> if you memo (map (+1)) and apply it to fix (1:) you get _|_
02:52:08 <Saizan> which is quite fair
02:52:11 <edwardk> ah
02:52:34 <edwardk> good luck ;)
02:53:39 <Saizan> i wonder what kind of evil hack i'd need to implement tabulate, if possible at all
02:54:28 <edwardk> as far as i can gather you'd need to have the answer when forced check to see how much of the input was forced
02:55:20 <Saizan> yep
03:13:06 <edwardk> going off to get some sleep
03:14:36 <ivanm> @time edwardk
03:14:57 * ivanm grumbles about people who block CTCP time
03:18:00 <Jafet> ivanm, u can't touch it
03:18:39 <ivanm> heh
03:18:52 <roconnor> @seen copumpkin
03:18:52 <preflex>  copumpkin was last seen on #haskell-blah 11 hours, 17 minutes and 10 seconds ago, saying: pretty well :) I get just over 1 coin a day
03:18:52 <lambdabot> Unknown command, try @list
03:19:10 <ivanm> hey roconnor
03:19:13 <roconnor> hey
03:19:14 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
03:19:30 <Jafet> Heh
03:20:33 <Jafet> lambdabot won't give you memos if you do her wrong?
03:21:48 <ivanm> Jafet: for some reason using plugin commands for lambdabot won't trigger her "let's see if this person has a message" check
03:38:35 <accel> is there a pattern for the following? I have a set of 12 functions. They all need depend on 3 variabless. I'm thinking of sticking these varaibles in a state monad, instead of passing them around all the time. Is there a better way to do this?
03:38:52 <accel> is there a pattern for the following? I have a set of 12 functions. They all need depend on 3 variabless. I'm thinking of sticking these varaibles in a state monad, instead of passing them around all the time. Is there a better way to do this? [the values of these variables do not change ... but they are computed at run time at the start of the program]
03:38:58 <ClaudiusMaximus> reader monad?
03:39:35 <ClaudiusMaximus> :t asks
03:39:36 <lambdabot> forall r a (m :: * -> *). (MonadReader r m) => (r -> a) -> m a
03:40:22 <Jafet> Compute them in unsafePerformIO and force them in main
03:40:35 <accel> reader monad description soudns like what i wantf
03:40:45 <accel> even the help page mentions it's often cleaner than control.monad.state
03:40:50 <accel> and as we know, the internet never lies
03:41:34 <Jafet> It is strictly weaker than State
03:41:50 <Jafet> Which people consider a good thing
03:41:53 <accel> which weirdly enough is what I want
03:41:57 <accel> since i only need read only access
03:42:37 <ivanm> @hoogle asks
03:42:38 <lambdabot> Control.Monad.Reader.Class asks :: MonadReader r m => (r -> a) -> m a
03:42:59 <ivanm> is it possible to have sub-states like Reader supports a sub-reader (or whatever the terminology is)?
03:43:13 <roconnor> yes
03:43:17 <roconnor> using lenses!
03:43:17 <accel> ivanm: lol, it's just what Im reading right now (asks)
03:43:42 * roconnor <3 lenses
03:44:12 <ivanm> accel: yeah, you reminded me ;-)
03:44:50 <ClaudiusMaximus> ouch.  seems bindings-DSL and unions is a bit explosive (eg, when the half of the union you don't want contains a nullPtr and you peek the thingy..)  *conjecture/hypothesis - but i have no other explanation thus far
03:46:25 <roconnor> ivanm: http://hackage.haskell.org/packages/archive/data-accessor/0.2.2/doc/html/Data-Accessor-MonadState.html#g:2
03:48:44 <erus`> anyone got google +1?
03:50:19 <roconnor> @ask edwardk where is your statemonad lifter in your lens library?
03:50:19 <lambdabot> Consider it noted.
03:50:34 <ivanm> erus`: you mean google+ ?
03:50:40 <Lemmih> erus`: Quite a few Haskellers work at google.
03:50:43 <ivanm> AFAIK _everyone_ with a google account has google +1
03:50:55 <erus`> yeah i mean google+
03:51:01 <BCoppens> it seems like the question is becoming 'who has NO google+ yet' :o
03:51:01 <lambdabot> BCoppens: You have 1 new message. '/msg lambdabot @messages' to read it.
03:51:04 <Jafet> > succ (10^100)
03:51:05 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
03:51:16 <ivanm> roconnor: which one are you referring me to?
03:51:22 <ivanm> BCoppens: that'd be me ;-)
03:51:25 <ion> Not everyone. No Google Apps users get to have G+ yet.
03:52:06 <ion> Ah, +1. I don’t think that’s available either.
03:52:16 <BCoppens> ion: yeah, I heard about google apps, that's rather silly
03:52:40 <BCoppens> ivanm: ahw, did you try to get in?
03:52:55 <ivanm> BCoppens: nope
03:52:56 <accel> is there a good tutorial for using reader/show in haskell for serialization? (slow is fine); or is this so simple I'm an idiot for not seeing how to use it
03:53:03 <BCoppens> ivanm: want to? :)
03:53:13 <ivanm> I'm doing my best to resist :p
03:53:13 <Jafet> You mean Read/Show?
03:53:16 <BCoppens> :D
03:53:22 <roconnor> ivanm: the two at the bottom
03:53:24 <ion> One would think it would be good engineering to make gmail.com just an Apps instance, but i guess not.
03:53:28 <ivanm> besides, I thought invites were no longer available atm...
03:53:33 <BCoppens> ivanm: and in response to your message: yeah I think usually in these kind of algorithms, DFS is the better choice :-)
03:53:54 <roconnor> Lemmih: I made a darcs repo for purecoin and I am slowly trickling code into it.
03:55:16 <idnar> ghc is complaining about wanting -XFlexibleContexts when I try to use the type declaration "mkPath :: MonadError String m => [String] -> m Path", but without the explicit type declaration it appears to infer the same type for this function without any problems
03:55:27 <BCoppens> ivanm: (especially because once you find a solution, you can output it and forget about it, while otherwise you have to hang on to all intermediate results too ;))
03:55:33 <idnar> do I just want to add that flag, or am I screwing up?
03:55:51 <BCoppens> ivanm: (and google+ invites are technically over, afaiui, but there are ways around that)
03:56:30 <accel> Jafet: yes, Read/Show
03:57:49 <ivanm> BCoppens: do you mean DFS or BFS?
03:58:23 <ivanm> accel: ummm... if you do Read/Show properly (say by deriving it) then you automatically get serialisation...
03:58:48 <chrisdone> ivanm: Did you try haskell-emacs?
03:58:48 <preflex>  chrisdone: you have 1 new message. '/msg preflex messages' to read it.
03:58:49 <BCoppens> ivanm: with DFS, once you have a solution, and backtrack a bit, you can throw away the part of the space already explored :)
03:59:04 <BCoppens> if you output it in the meantime, that is
03:59:09 <ivanm> chrisdone: nah, just did a watch because I happened to run across it just before
03:59:20 <ivanm> BCoppens: brendan says BFS is usually better for graph algorithms... >_>
03:59:48 <BCoppens> ivanm: oh, then I'm wrong :(
03:59:57 <BCoppens> ivanm: I'm fairly sure he'll know it better than me :D
04:00:04 <chrisdone> Well if anyone feels like trying it out I made it easy, just clone the repo, cd into it and run emacs -nw -Q -l examples/init.el
04:00:41 <ivanm> chrisdone: does it use haskell-mode?
04:00:45 <chrisdone> At this point I can't tell if I make assumptions because of my setup/particular versions.
04:00:49 <chrisdone> ivanm: Nope.
04:01:06 <ivanm> oh? so you re-implemented all indentation, highlighting, etc.?
04:01:14 <ivanm> I might have a play with it later this week
04:02:28 <byorgey> idnar: you want to add that flag
04:03:34 <idnar> byorgey: okay, thanks
04:03:44 <chrisdone> ivanm: I did, but only until I can cleanly integrate haskell-mode's later on. It's a bit flimsy but I use it daily. However, I do want to (and started a bit) re-implement indentation with an exhaustive set of test cases. Anyway, the more interesting part is how it knows about sessions/projects (i.e. having many cabal projects open and a corresponding REPL for each), the new REPL, completion, etc.
04:04:10 <ivanm> ooooohhhh.....
04:05:00 <ivanm> chrisdone: if I re-install a particular library, do I still have to kill each REPL manually before being able to use the updated version?
04:05:07 <chrisdone> Ah, and it supports (read: requires >_>) cabal-dev.
04:05:45 <chrisdone> ivanm: Yeah. Maybe I should make a 'reload REPL' shortcut?
04:06:11 <chrisdone> I find myself doing that fairly often.
04:06:33 <ivanm> oh, I'm not using cabal-dev yet...
04:06:38 <chrisdone> :o
04:07:09 <ivanm> *shrug* no need for it
04:09:22 <chrisdone> I pretty much can't work without it for work (as each project has a strict set of deps) but now I use it for all projects. I seem to patch libraries a lot and include them in my project. I'm not sure how I got by before, probably just installing globally and hoping for the best.
04:10:20 <ivanm> well, most of my "patched" libraries are the ones I'm developing, so this isn't an issue ;-)
04:10:24 <ivanm> I don't do web dev, etc.
04:10:31 <luite> I still think that, with the exception of patching libraries, cabal-dev really shouldn't be necessary :p
04:10:59 <chrisdone> Sure.
04:12:07 <ClaudiusMaximus> how does hsc2hs determine the size of enum types?  i think i might be running into something fishy where my kernel thinks they're 32bit and hsc2hs thinks they're 64bit...?
04:12:23 <chrisdone> In my lib/ directory for hpaste I have: css  named-formlet  pgsql-simple  stepeval. I tweak the css library and the named-formlet library fairly often, so that's for convenience. pgsql-simple isn't released yet, and stepeval I patched.
04:12:42 <luite> ClaudiusMaximus: it uses the c compiler to make a program that spits out the .hs
04:12:53 <luite> maybe it uses the wrong one
04:14:58 <ivanm> preflex: seen dschoepe
04:14:59 <preflex>  dschoepe was last seen on #haskell 1 day, 14 hours, 26 minutes and 35 seconds ago, saying: fwiw, vimpulse adds a few features that viper-mode lacks
04:15:12 <ClaudiusMaximus> luite: hm, well gcc prints out the same sizeof() as the haskell, and works fine, so it's probably not that...
04:15:19 <ivanm> @ask dschoepe any chance of updating xmonad-extras to use latest libmpd?
04:15:19 <lambdabot> Consider it noted.
04:15:45 <ivanm> chrisdone: so why does it _need_ cabal-dev?
04:28:35 <chrisdone> ivanm: Just 'cause I assumed that. I changed it to use ghci by default.
04:28:52 <chrisdone> (setq hs-config-use-cabal-dev t) to use cabal-dev.
04:29:27 <chrisdone> Its main use is cabal-dev ghci which loads the right packages for the particular project context.
04:31:07 * benmachine waves to chrisdone
04:31:20 <haskellhustler> hi folks, is there an easy way to get the haskell plattform installed on ubuntu 11.04? I did some googling etc. and I saw that I'm not the only one with that problem
04:31:50 <benmachine> chrisdone: I realise in retrospect that it was nowhere made obvious how unfinished stepeval was, so sorry about that :P
04:33:34 <ClaudiusMaximus> is it normal for a Storable instance to have alignment = sizeOf ?
04:34:00 * ClaudiusMaximus on third guess as to what might be causing segfault..
04:34:28 <benmachine> as far as I'm concerned it's normal for Storable instances to be autogenerated and/or written by someone else :P
04:35:19 <ivanm> chrisdone: fair enough
04:36:01 <byorgey> haskellhustler: what problem are you having, exactly?
04:36:41 <ClaudiusMaximus> benmachine: right, it is (by me but using bindings-DSL - but i'm geting segfaults in some ioctls)
04:37:17 <benmachine> ClaudiusMaximus: ah. I'd be inclined to trust bindings-dsl, or at least it's always worked for me
04:38:53 <chrisdone> benmachine: Yeah, I could tell from some superficial experimentation, but it gets the job done in the simple case.
04:39:00 <haskellhustler> byorgey: well, I'd like to install the haskell-package with one script or something, as far as I've understood I have to either build it from source or download every dependency manually
04:39:01 <benmachine> ok :)
04:39:15 <benmachine> I'm glad you've found a use for it at any rate
04:39:16 <chrisdone> (Also, I find using a library on hpaste, being a public site tends to encourage them to hack more on it. ;-P)
04:39:45 <benmachine> I think it needs to be redone with a more coherent design
04:40:02 <benmachine> I sort of built it by just going "ok what haven't I implemented yet" *bolton*
04:40:03 <chrisdone> When I added hlint I was like 'hey Neil, check this', and he was all 'Oh noes! I must fix all the bugs!'
04:40:05 <ClaudiusMaximus> benmachine: right, i'm thinking i'm doing it wrong
04:40:09 <benmachine> heh
04:40:30 <chrisdone> benmachine: Sure. “Plan to throw one away.” :-)
04:40:49 <ClaudiusMaximus> benmachine: but if there are any examples of wrapping linux kernel APIs with sometihng, it'd help - not had much luck looking  (trying to get v4l2 going..)
04:41:06 <byorgey> @remember chrisdone [on hpaste as motivational tool] When I added hlint I was like 'hey Neil, check this', and he was all 'Oh noes! I must fix all the bugs!'
04:41:06 <lambdabot> I will never forget.
04:41:17 <chrisdone> :-D
04:41:30 <luite> hehe
04:42:22 <merijn> So truee
04:42:38 <luite> has hpaste been running reliably with snap by the way?
04:42:51 <merijn> *pastebin* -> hlint produces redundant parenthesis/bracket warning -> OMG! Must remove brackets!
04:43:10 <byorgey> haskellhustler: doesn't ubuntu have a 'haskell-platform' package?
04:43:15 <merijn> I noticed hpaste is missing line numbers nowadays :(
04:43:28 <byorgey> haskellhustler: or is there some reason it is broken in 11.04?
04:44:00 <chrisdone> merijn: Ah, d'oh. I forgot about that.
04:44:14 <byorgey> oh, yeah, I want line numbers back too
04:44:25 <byorgey> or at least a toggle switch for turning them on/off
04:44:55 <merijn> Someone nicely pastebins a GHC error with line numbers and then I'm stuck handcounting them :p
04:45:27 <haskellhustler> byorgey: when I open the 'haskell-platform.deb' with synaptic it tells me that I need to install this and this dependency first
04:46:00 <haskellhustler> byorgey: I don't know if thats what you call 'broken'
04:46:21 <merijn> What happens if you install those dependencies? :p
04:46:45 <benmachine> haskellhustler: synaptic is supposed to do it all for you, that is what it's *for* :P
04:46:50 <byorgey> haskellhustler: I agree it shouldn't do that
04:47:31 <byorgey> haskellhustler: hmm, where did you get this 'haskell-platform.deb'?
04:48:21 <haskellhustler> byorgey: then I guess it's broken, since it looks like I have to go through the whole list of dependencies and through their dependencies and so on
04:48:26 <byorgey> haskellhustler: you should just be able to  'apt-get install haskell-platform' if you have the universe repository enabled
04:49:31 <luite> (but you will get an older haskell platform if you use that)
04:49:43 <byorgey> oh, right
04:49:50 <haskellhustler> byorgey: http://packages.ubuntu.com/oneiric/haskell-platform
04:50:27 <luite> haskellhustler: that's a package for the next ubuntu version
04:51:38 <byorgey> oh, yeah, 11.04 is 'natty'
04:51:47 <haskellhustler> luite: ok I didn't see that - where does it say that?
04:52:03 <byorgey> seriously though, you should just open a terminal and type 'apt-get install haskell-platform'
04:52:33 <luite> haskellhustler: natty = 11.04, oneiric = 11.10 (if all goes well, it's supposed to be released in october)
04:52:42 <haskellhustler> ok its the name for ubuntu 11.04 - I just cant remember these names
04:53:08 <haskellhustler> byorgey: ok
04:53:36 <haskellhustler> byorgey: thanks to you all then, bye
04:53:47 <byorgey> haskellhustler: let us know if it works!
04:53:49 <byorgey> bah
04:53:49 <luite> if you're just learning haskell and don't really need the latest features, then just apt-get install haskell-platform, and upgrade your ubuntu in october to get the latest and greatest :)
04:54:03 <luite> oh
04:54:15 <nus> https://bugs.launchpad.net/ubuntu/+source/haskell-platform/+bug/711366
04:54:47 <nus> https://bugs.launchpad.net/ubuntu/+source/haskell-platform/+bug/742052
04:55:12 <luite> hmm
04:55:20 <nus> so that gives https://launchpad.net/~brcha/+archive/ppa
04:57:04 <idnar> @hoogle m [xs] -> [m xs]
04:57:05 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
04:57:05 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
04:57:05 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
04:57:19 <idnar> ah, sequence
04:58:05 <benmachine> idnar: sequence backwards
04:58:30 <benmachine> idnar: it's possible to do the typesig you gave but it's slightly odd
04:58:42 <idnar> benmachine: oh, sorry, my type signature was backwards from what I wanted
04:58:49 <idnar> actually I just want mapM, I think
04:59:02 <benmachine> oh ok :)
04:59:16 <benmachine> :t fmap (zipWith (flip (!!)) [0 ..]) -- in any case
04:59:17 <lambdabot> forall a (f :: * -> *). (Functor f) => f [[a]] -> f [a]
04:59:23 <benmachine> oh erm
04:59:47 <benmachine> hmm
04:59:48 * benmachine fiddle
04:59:52 <idnar> I don't actually think the sig I asked for is possible
05:00:01 <idnar> since you're "escaping" the monad
05:00:20 <benmachine> idnar: well, const [] would do it :)
05:00:26 <idnar> haha
05:00:34 <benmachine> it would be impossible to get the length of the list right, yeah
05:00:41 <byorgey> or \m -> [liftM head m]
05:00:45 <benmachine> but you could produce an infinite list that was sort of the right thing
05:00:52 <benmachine> but errored out eventually
05:01:35 <benmachine> yeah I was essentially thinking \m -> [fmap (!! 0) m, fmap (!! 1) m, ..]
05:01:37 <byorgey> I think it's impossible to do it up to some 'obvious' naturality condition
05:01:58 <byorgey> where by 'obvious' I mean 'I can't be bothered to actually figure it out'
05:02:00 <benmachine> it's impossible, I think, to write a function f such that sequence . f = id
05:02:34 <nus> @type UnwrapMonad
05:02:34 <lambdabot> Not in scope: data constructor `UnwrapMonad'
05:02:46 <nus> @type unwrapMonad
05:02:47 <lambdabot> forall (m :: * -> *) a. WrappedMonad m a -> m a
05:04:04 <idnar> oh, replacing fmap with liftM fixes my other type errors
05:04:09 <idnar> man, my Haskell is really rusty now :/
05:05:17 <ClaudiusMaximus> works:  peekArray (sizeOf (unsafePerformIO (peek p))) (castPtr p :: Ptr Word8)  segfaults:  peek p  -- i think i'm going insane :/
05:06:09 <idnar> @pl \f g xs -> liftM f (mapM g xs)
05:06:10 <lambdabot> (. mapM) . (.) . fmap
05:07:27 <benmachine> ClaudiusMaximus: :<
05:08:25 <benmachine> ClaudiusMaximus: you could try asking gdb what it thinks?
05:08:38 <ClaudiusMaximus> benmachine: i've been starting at assembly for 10mins getting confused
05:08:50 <benmachine> that sounds more complicated than what I had in mind
05:10:11 <hpaste> ClaudiusMaximus pasted “segfault disassemble” at http://hpaste.org/48664
05:11:40 <Peaker> Has anyone explored the similarity/relationship between the Stream type (from "lists to streams to nothing at all") and Iteratees?
05:12:30 <Peaker> Iteratees are recursively defined -- so may not enjoy the optimizations that Streams do.  Streams are not monad-lifted and have no chunking/error support, so cannot be used as Iteratees.  I think one can make a type that unifies both things
05:12:48 <Peaker> I am wondering if that would mean losing the power of iteratees along the way or not
05:20:13 <nus> ClaudiusMaximus, how does the .hc file look?
05:24:28 <hpaste> spuz pasted “Project Euler 14” at http://hpaste.org/48665
05:25:41 <ClaudiusMaximus> nus: not sure, i just found a typo... might be related, recompiling...
05:25:42 <spuz> Hello, I'm trying to do Project Euler prolem 14 (http://projecteuler.net/index.php?section=problems&id=14) here is my code: http://hpaste.org/48665
05:25:56 <spuz> This works fine but is incredibly slow (doesn't complete on my laptop)
05:26:19 <spuz> The same algorithm in Java takes about 10 seconds. What can I do to speed the algorithm up?
05:27:23 <ClaudiusMaximus> spuz: you're probably not sharing enough; and recomputing things many times
05:28:36 <spuz> ClaudiusMaximus: Perhaps, I can't see how I can compute less than I am though
05:30:53 <spuz> I'm not sure how to profile haskell code. How can I see how many times a particular function is called?
05:35:14 <ClaudiusMaximus> spuz: ghc -prof -auto-all -caf-all -rtsopts -fforce-recomp foo.hs && ./foo +RTS -P
05:35:29 <chrisdone> @g profiling haskell
05:35:29 <lambdabot> Maybe you meant: gazetteer get-shapr ghc girl19 google googleit gsite gwiki . ? @ v
05:35:34 <chrisdone> @google profiling haskell
05:35:35 <lambdabot> http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/profiling.html
05:35:35 <lambdabot> Title: Chapter�5.�Profiling
05:41:05 <nus> spuz, you're effectively recomputing the same values many times
05:42:23 <nus> @google haskell recursive memoization
05:42:24 <lambdabot> http://www.haskell.org/haskellwiki/Memoization
05:42:24 <lambdabot> Title: Memoization - HaskellWiki
05:47:10 <linduxed> is there a interpreter equivalent of the prolog interpreters function ".trace" ?
05:47:21 <linduxed> to see what gets bound to what step by step?
05:47:34 <linduxed> for debugging purposes...
05:47:34 <ezyang> there are a bunch of libraries you can try.
05:47:39 <ezyang> @package hood
05:47:39 <lambdabot> http://hackage.haskell.org/package/hood
05:49:31 <linduxed> i'll try that
05:49:37 <linduxed> how do i load and use it?
05:53:07 <Twey> Looks like Debug.Trace, with worse English >.>
05:54:30 <linduxed> hmmm, i know this might not be the right channel for this. but how do i get a hold of haskell-array 0.3.0.1 for arch linux?
05:56:20 <parcs> linduxed: install cabal-install from the official repositories and use that to install haskell packages
05:56:37 <ion> cabal install haskell-array
05:58:59 <linduxed> parcs: oooh, so it's like rubygenms?
05:59:01 <linduxed> *gems
05:59:16 <parcs> yep
06:13:23 <linduxed> yey \o/
06:13:27 <linduxed> hood installed
06:13:33 <linduxed> now how do i use it?
06:13:51 <linduxed> gonna google some...
06:14:00 <Peaker> trying to read OOHaskell, Oleg's paper -- and I can't see where he's defining the labels.  He uses    something .=. whatever     but where is "something" defined?
06:15:34 <hpaste> dshady pasted “Problem with monadic types” at http://hpaste.org/48666
06:15:47 <Lemmih> linduxed: Hood usually isn't the first choice for debugging Haskell programs.
06:16:13 <linduxed> Lemmih: well it was the first tip i got...
06:17:08 <dshady> anyone got a clue about my problem? I want mapM to unwrap the DatabaseEnv and Maybe-stuff and give me Maybe [ScheduleUnit].
06:17:29 <linduxed> uuuh, is there no uninstall command for cabal??
06:17:47 <ion> assigned :: [Maybe a], and you’re trying to match assigned against Just a.
06:18:23 <dshady> ion: but shouldn't Maybe be placed outside by the call to mapM? or is that just DatabaseEnv?
06:18:46 <benmachine> that's just DatabaseEnv, yeah
06:19:19 <benmachine> you've got a -> m (n b) and mapMing thing over [a] gives you m [n b]
06:19:35 <dshady> sequence did it, thanks!
06:20:09 <dshady> I'm still lacking some basic skills but it's fun to play around with this stuff.
06:27:05 <b0fh_ua> hi! having 2 numbers in form x^y, how can I put them to single base but different power?
06:27:33 <ezyang> Give a concrete example? You sound like you're asking for factoring.
06:27:48 <b0fh_ua> like 99^140 and 66^210 - I want to make them as 66^x and 66^210
06:28:05 <ivanm> logarithms!
06:28:06 <b0fh_ua> need to transform 99^140 to 66^smth
06:28:13 <benmachine> um, 99^140 isn't 66^whole number
06:28:18 <benmachine> (I don't think)
06:28:19 <ivanm> > logBase 66 (99^140)
06:28:19 <lambdabot>   153.5488766092662
06:28:31 <ClaudiusMaximus> wow, bindings-DSL really explodes on struct A { union B b; }; union B { struct C c; struct A a; };  -- spot the mistake
06:28:38 <ivanm> > (66 ** 153.5488766092662, 99^140)
06:28:39 <lambdabot>   (2.4486529903492664e279,244865299034929792545490603081965408810155381880822...
06:28:46 <ivanm> > (66 ** 153.5488766092662, 99**140)
06:28:47 <lambdabot>   (2.4486529903492664e279,2.448652990349298e279)
06:28:53 <ezyang> Infinite loop?
06:28:56 <ivanm> b0fh_ua: ^^
06:29:03 <ClaudiusMaximus> (i left out a * in the union, so 'peek' went looping...
06:29:19 <b0fh_ua> okay, but what about powers like 140%x
06:29:21 <b0fh_ua> Rational ones
06:29:29 <lysgaard> I want to run a ST action in another monad, does there exist some sort of lift that achieves this?
06:29:39 <benmachine> b0fh_ua: are you sure there is a solution?
06:29:47 <b0fh_ua> not really )
06:29:52 <ezyang> lysgaard: Not what you're looking for, but runST
06:29:59 <ezyang> What are you actually trying to do?
06:30:10 <benmachine> b0fh_ua: it can't be done in general
06:30:12 <ivanm> @type logBase
06:30:13 <lambdabot> forall a. (Floating a) => a -> a -> a
06:30:15 <ivanm> @type (**)
06:30:16 <lambdabot> forall a. (Floating a) => a -> a -> a
06:30:26 <benmachine> you can do it if one of the numbers is a power of the other
06:30:40 <b0fh_ua> okay, but what about bigger numbers?
06:30:51 <ivanm> use CReal? :p
06:30:59 <b0fh_ua> like: 632382^518061
06:31:03 <benmachine> b0fh_ua: "what about bigger numbers?" is quite a vague question
06:31:05 <benmachine> what about them
06:31:07 <ivanm> b0fh_ua: what about it?
06:31:15 <ivanm> b0fh_ua: why are you wanting to do this anyway?
06:31:15 <lysgaard> ezyang: I'm trying to modify a hastable inside the ProcessM monad of CloudHaskell
06:31:33 <ezyang> What is the type of ProcessM?
06:31:43 <ezyang> If it does not have an appropriate ST s, you're SOL.
06:31:53 <b0fh_ua> it will take some time to convert 632382^518061 to the base 519432 for example
06:32:12 <benmachine> b0fh_ua: yes it will
06:32:23 <ivanm> > logBase 519432 (632382^518061)
06:32:24 <lambdabot>   Infinity
06:32:29 <ivanm> \o/
06:32:33 <ivanm> > logBase 519432 (632382^518061) :: CReal
06:32:36 <lambdabot>   mueval-core: Time limit exceeded
06:32:39 <ivanm> heh
06:32:40 <lysgaard> ezyang: What did that last sentence mean?
06:32:46 <ivanm> b0fh_ua: why are you doing this?
06:32:56 <benmachine> lysgaard: (SOL means, um, out of luck)
06:32:58 <ezyang> lysgaard: the point of the ST monad is you have mutable state that is local.
06:33:10 <b0fh_ua> just trying to solve: http://projecteuler.net/index.php?section=problems&id=99 :)
06:33:10 <dropdrive> What's an example of a program that's ugly to write without iteratees but pretty to write with?
06:33:14 <ezyang> http://www.urbandictionary.com/define.php?term=SOL
06:33:18 <ivanm> benmachine: the "S" stands for "sweet", doesn't it? :p
06:33:31 <ivanm> @all-dicts SOL
06:33:32 <ezyang> But I think acronymizing euphemizes.
06:33:32 <lambdabot> *** "sol" gcide "The Collaborative International Dictionary of English v.0.48"
06:33:33 <lambdabot> G \G\ (j[=e])
06:33:33 <lambdabot>    1. G is the seventh letter of the English alphabet, and a
06:33:33 <lambdabot>       vocal consonant. It has two sounds; one simple, as in
06:33:33 <lambdabot>       gave, go, gull; the other compound (like that of j), as in
06:33:33 <lysgaard> ezyang: The ProcessM monad is a instance of Monad, MonadIO, Functor and Typeable1
06:33:34 <lambdabot> [84 @more lines]
06:33:37 <benmachine> ivanm: sure, that sounds believable
06:33:57 <ivanm> OK, that's a weird definition...
06:33:59 <benmachine> ok, definition of G, that's interesting
06:34:05 <ezyang> lysgaard: Instances do not really help
06:34:19 <ivanm> @list dicts
06:34:19 <lambdabot> No module "dicts" loaded
06:34:24 <ivanm> @help all-dicts
06:34:24 <lambdabot> I perform dictionary lookups via the following 13 commands:
06:34:24 <lambdabot> all-dicts ... Query all databases on dict.org
06:34:24 <lambdabot> devils ...... The Devil's Dictionary
06:34:24 <lambdabot> easton ...... Easton's 1897 Bible Dictionary
06:34:24 <lambdabot> elements .... Elements database
06:34:26 <lambdabot> [9 @more lines]
06:34:30 <benmachine> ezyang: they do inasmuch as you can convert ST to IO (possibly unsafely, I forget) and then lift IO to MonadIO
06:34:30 <ivanm> @more
06:34:30 <lambdabot> foldoc ...... The Free On-line Dictionary of Computing
06:34:31 <lambdabot> gazetteer ... U.S. Gazetteer (1990)
06:34:32 <lambdabot> hitchcock ... Hitchcock's Bible Names Dictionary (late 1800's)
06:34:34 <lambdabot> jargon ...... Jargon File
06:34:36 <lambdabot> lojban ...... Search lojban.org
06:34:38 <lambdabot> [4 @more lines]
06:34:40 <ivanm> @jargon SOL
06:34:41 <lambdabot> No match for "SOL".
06:34:46 <lysgaard> ezyang: Then I don't understant what I should check to se if it's possible?
06:35:40 <ezyang> Well, if ProcessM is opaque to you, it is almost certainly impossible.
06:35:53 <ezyang> Turn your hash table into state living in IO, either an IORef or MVar.
06:37:28 <lysgaard> ezyang: The ProcessM monad forbids IORef and MVars
06:37:57 <ezyang> Doesn't it have a MonadIO instance?
06:38:27 <ezyang> (benmachine: Yes, you can do that. It would also be wrong. :-)
06:38:51 <benmachine> ezyang: technicality >_>
06:38:51 <ezyang> We might need to pop a "what are you really trying to do" very shortly.
06:39:02 * ezyang wonders if there's a name for that. 
06:40:32 <lysgaard> ezyang: Yeah it does. So I have to turn the ST actions into IO actions in some way?
06:40:41 <ddarius> @vera SOL
06:40:42 <lambdabot> *** "sol" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
06:40:42 <lambdabot> SOL
06:40:42 <lambdabot>      Simulation-Oriented Language
06:40:42 <lambdabot>  
06:40:45 <ezyang> No!
06:40:47 <ddarius> Ha.
06:40:59 <ezyang> @hoogle ST s a -> IO a
06:40:59 <lambdabot> Control.Monad.ST unsafeSTToIO :: ST s a -> IO a
06:40:59 <lambdabot> Control.Monad.ST runST :: ST s a -> a
06:40:59 <lambdabot> Control.Monad.ST.Lazy runST :: ST s a -> a
06:41:07 <ezyang> There's a reason why it's "unsafeSTToIO".
06:41:28 <benmachine> @hoogle stToIO
06:41:28 <lambdabot> Control.Monad.ST stToIO :: ST RealWorld a -> IO a
06:41:28 <lambdabot> Control.Monad.ST.Lazy stToIO :: ST RealWorld a -> IO a
06:41:28 <lambdabot> Control.Monad.ST unsafeSTToIO :: ST s a -> IO a
06:51:22 <ezyang> lysgaard: Where is your ST code coming from?
06:51:31 <ezyang> What are you actually trying to do?
07:00:41 <ddarius> Travelling for pleasure is hard.
07:01:44 <lysgaard> ezyang: The ST is coming from opperations on: http://hackage.haskell.org/packages/archive/hashtables/1.0.0.0/doc/html/Data-HashTable-ST-Linear.html
07:02:03 <ezyang> Use http://hackage.haskell.org/packages/archive/hashtables/1.0.0.0/doc/html/Data-HashTable-IO.html instead then.
07:06:25 <akosch> I need a book for learning haskell, what would you people recommend? (I already read Real World Haskell)
07:06:38 <ion> LYAH
07:06:50 <sipa> @where lyah
07:06:50 <lambdabot> http://www.learnyouahaskell.com/
07:07:03 <akosch> ion: sorry, forgot to mention that I read that too
07:07:25 <ion> Well, i guess you already learned Haskell. :-)
07:07:54 <akosch> ion: hmm, I guess... but there is always room for improvement ;)
07:08:26 <ion> That happens by doing stuff you are motivated to do and learning as you go.
07:09:31 <akosch> yeah, but I'm still not comfortable enough to write bigger things
07:11:20 <akosch> I would like to know more about how ghc works for example
07:11:55 <nus> who doesn't (-;
07:12:00 <nus> it's pure magic
07:12:10 <akosch> was just about to say that ;)
07:12:38 <nus> http://hackage.haskell.org/trac/ghc/wiki/
07:12:48 * hackagebot scrypt 0.3.0 - Stronger password hashing via sequential memory-hard functions.  http://hackage.haskell.org/package/scrypt-0.3.0 (FalkoPeters)
07:12:53 <jmcarthur> akosch: practice works a lot better than reading
07:13:02 <Peaker> Using Iteratees, does it make sense to stick IO delays in the iteratee/handlers?
07:13:12 <Peaker> (to e.g: rate limit)?
07:13:52 <akosch> jmcarthur: I guess you're right. Just wondering if I really ran out of material...
07:15:02 <jmcarthur> well, rwh and lyah are certainly good books and i doubt reading more books would be helpful. papers, on the other hand, can still be nice, but those are best consumed more slowly
07:15:38 <akosch> what about this one: http://www.amazon.com/Programming-Haskell-Graham-Hutton/dp/0521692695/
07:15:49 <Jafet> No game consists entirely of tutorials
07:16:15 <Guest39286> @help
07:16:15 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:16:58 <nus> akahn, what are those smaller things you wrote?
07:17:30 <nus> errr, s/akah/akosh/
07:17:38 <jonkri> how would you validate that a string is a valid host name (domain name, ipv4, ipv6)?
07:17:38 <nus> akosch, even
07:17:39 <akosch> nus: I did a lot of the PE problems
07:17:52 <akosch> haskell was quite nice for those kinds of problems
07:17:58 <Guest39286> list
07:18:04 <akosch> I mean Project Euler of course
07:18:08 <Guest39286> @help list
07:18:08 <lambdabot> list [module|command]
07:18:08 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
07:18:22 <nus> Guest39286, use /msg
07:18:58 <Guest39286> thanks!
07:20:31 <akosch> nus: I also did a small program to brute-force crack password hashes
07:22:49 * hackagebot randproc 0.4 - Data structures and support functions for working with random processes  http://hackage.haskell.org/package/randproc-0.4 (DavidBanas)
07:25:11 * pants_
07:27:45 <nus> akosch, find an ongoing Haskell project and ways to contribute
07:29:11 <sully> write a compiler for something
07:29:18 <roconnor> is there some sort of unintercalate function?
07:29:44 <sipa> @hoogle a -> [a] -> [[a]]
07:29:45 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
07:29:45 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
07:29:45 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
07:29:46 <ezyang> @package split
07:29:47 <lambdabot> http://hackage.haskell.org/package/split
07:30:14 <roconnor> @hoogle [a] -> [a] -> [[a]]
07:30:14 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
07:30:14 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
07:30:14 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
07:30:41 <akosch> nus: hm, any tips?
07:32:10 <roconnor> sipa: I'm slowly migrating my code to a darcs repo:  darcs get http://r6.ca/Purecoin
07:38:41 <roconnor> I wish Data.Serialize.isolate took an Int64 instead of an Int.
07:39:10 <roconnor> or an Integer even.
07:39:20 <merijn> roconnor: Wow, I hope you never find a wishing lamp if you dream that small :p
07:39:41 <roconnor> its what I desire most of all!!
07:39:57 <merijn> I'd aim for infinite precision machines and/or infinite random access memory with short and uniform access times :>
07:40:28 <sipa> let's just hope for a O(1) turing machine
07:40:48 <merijn> P=NP \o/
07:40:59 <sipa> what about NP=L ?
07:41:08 <merijn> With a solution which of practical speed
07:41:16 <Jafet> My program can be executed in O(1) program executions
07:41:16 <merijn> I have no clue what L stands for
07:41:55 <sipa> log space
07:42:49 <merijn> Irrelevant if I get my wish of machines with infinite short & uniform access RAM :p
07:47:16 <roconnor> merijn: but think of how much data we could isolate if isolate took an Integer instead of an Int!
07:49:13 <nus> akosch, in no particular order: http://snapframework.com/faq#how-can-i-help ; http://www.yesodweb.com/page/todo ; http://projects.haskell.org/gtk2hs/development/
07:57:28 <amacleod> If I were reading "x >>= f" aloud, would it be more correct to say "x bind f" or "x bound to f"?
07:58:34 <Jafet> I might read it differently, if it was a particular Monad
07:58:46 <Jafet> And if I ever, ever had to read code aloud
07:59:10 <amacleod> Jafet, hmm, right.  I guess its meaning differs from monad to monad.
07:59:34 <Jafet> If you're presenting something inherent to all Monads, then you probably can't do better than “bind”.
08:00:14 <Jafet> “bound to” seems like a weird use of tense — is that intentional?
08:01:10 <amacleod> Jafet, not really.  I'm just trying to massage my mind into the patterns of thinking about monads.
08:01:55 <ion> ‘Drawing a from x, f of a’
08:02:22 <ion> Thinking in terms of the equivalent do notation.
08:02:32 <amacleod> ion, awkward to say, but that helps me make sense of it.
08:02:34 <Jafet> But that isn't point-free
08:02:38 <Jafet> Shame on you
08:03:33 <amacleod> @type (>>=)
08:03:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:04:06 <dylukes> ion: Telling people to read it that way is probably a good idea for newbies.
08:04:50 <ClaudiusMaximus> hooray, got v4l2 bindings working-ish http://claudiusmaximus.goto10.org/g/haskell/haskell-v4l2-bindings-preview.png
08:07:49 <amacleod> Do Haskellers have a prevailing opinion about do notation?  Is it an essential convenience, or an unfortunate crutch?
08:08:04 <Jafet> Yes, yes, and yes.
08:08:11 <merijn> amacleod: It's nice, but I have no strong opinion either way
08:08:41 <dylukes> amacleod: in my opinion, do notation can be really convenient for very large monadic expressions.
08:08:43 <Jafet> Some people have explored “functional reactive programming”, but most results so far are theoretical.
08:08:54 <dylukes> For shorter ones, I tend to use applicative style.
08:08:59 <Jafet> Er, to replace monadic sequencing.
08:09:02 <merijn> amacleod: I don't think of it so much as a crutch as a superior way of writing imperative code
08:09:10 <ezyang> You can pretty closely mimic do notation with >>=
08:09:13 <ezyang> It's just nicer.
08:09:22 <ezyang> Structurally it's all the same.
08:09:35 <dylukes> do notation, being monadic, also has the advantage of allowing you to pass around state under the scenes.
08:09:40 <amacleod> Hmm, yeah.  My main worry is, since most of the programming I've done is in the imperative style, do notation might lull me into thinking I'm just writing more imperative code.
08:09:43 <Jafet> To replace pure computations, you might prefer other classes like Applicative or Functor
08:09:49 <dylukes> So you don't have the issue you have in C where, in a set of functions, you have global state.
08:09:51 <merijn> amacleod: You are
08:09:56 <Jafet> If you use do-notation to write imperative code, so be it.
08:09:57 <dylukes> In a monadic context, that state can actually just be carried around.
08:10:29 <dylukes> Jafet: mm, I use do-notation mainly for imperative code, sometimes for lists or parser combinators.
08:10:37 <dylukes> Usually I try to use applicative style wherever… applicative.
08:11:10 <merijn> amacleod: If you're writing code in the IO monad you effectively *are* writing imperative code. Its not some sort of strange misconception that is going to trip you up. If you wanted you could have all your functions take and return IO values and write imperative Haskell (hence why some people say Haskell is their favorite imperative language)
08:11:13 <amacleod> dylukes, I see what you did there.
08:11:51 <merijn> amacleod: It's just that the IO part forces you to actually realize that not all of your code has to be imperative
08:11:53 <Jafet> I see that you misspelled “applicable”
08:12:07 <dylukes> Haskell just requires you to be explicit about which part of your code is imperative.
08:12:26 <amacleod> merijn, right.  The advice I've heard is to try to squeeze the IO part "out to the edges" as much as possible.
08:12:48 * edwardk waves hello.
08:12:48 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
08:12:52 <dylukes> Hey edenc
08:12:55 <dylukes> edwardk*
08:12:58 <edwardk> amacleod: good advice
08:12:59 <edwardk> @messages
08:13:00 <lambdabot> roconnor asked 4h 22m 47s ago: where is your statemonad lifter in your lens library?
08:13:12 <Jafet> A lot of IO code seems to be written in a combinatorial style, as far as I've seen
08:13:13 <dylukes> Often the structure I see amacleod, is a core IO, and pure functions used throughout as often as possible.
08:13:16 <merijn> amacleod: Yes, by writing code that is not of the IO type you effectively tell the compiler "this is guaranteed not imperative and thus can be reordered/parallelized/optimized away at will"
08:13:24 <dylukes> For instance, your database lookup may be in IO, but your predicates can be pure.
08:13:56 <edwardk> @tell roconnor Data.Lens.Lazy in data-lens or Data.Lens in data-lens-fd
08:13:56 <lambdabot> Consider it noted.
08:14:00 <merijn> amacleod: Which is why you want to move code out of IO as much as possible, but there is no reason why you would have to
08:14:04 <amacleod> dylukes, and even the transformations I wish to subject the looked-up data to can be pure, yes?
08:14:18 <merijn> amacleod: Yup
08:14:22 <dylukes> You can easily use pure code from within monadic code.
08:14:35 <dylukes> We have lift and `ap` too.
08:14:50 <amacleod> @type lift
08:14:51 <lambdabot>     Ambiguous occurrence `lift'
08:14:51 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
08:14:51 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
08:14:59 <roconnor> edwardk: ah focus!
08:14:59 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
08:15:04 <roconnor> I don't know how I missed taht
08:15:07 <merijn> amacleod: You can think of the interaction of IO actions and pure functions as the pure function being treated as a callback to the IO being finished
08:15:11 <edwardk> ah
08:15:32 <Axman6> :t liftM
08:15:32 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
08:15:44 <Axman6> a.k.a fmap
08:15:44 <amacleod> merijn, that's handy.  I'm familiar with that pattern from Twisted Python.
08:15:56 <edwardk> focus :: Monad m => Lens a b -> StateT b m c -> StateT a m c
08:15:58 <amacleod> fmap is the Applicative version, right?
08:16:06 <Axman6> functor
08:16:13 <edwardk> sadly i don't have a MonadState equivalent
08:16:16 <Axman6> there's liftA
08:16:39 <merijn> amacleod: It behaves very much like Twisted and other callback frameworks, except that you don't have to worry about the global state and adding callbacks in the proper order :)
08:16:46 <Axman6> but they all do the same thing
08:17:26 * monochrom is not religious about functional or imperative
08:17:56 <Axman6> amacleod: you'll learn soon enough that IO is evil and should be avoided as much as possible
08:18:07 <amacleod> I'm all about avoiding evils.
08:18:07 <luite> ugh monomorphism restriction why do you always biteme
08:18:23 <roconnor> edwardk: that's okay; AFAIK it isn't possible to have a MonadState version.
08:18:28 * amacleod started excising GOTOs from his BASIC code when he was 10.
08:18:48 * roconnor starte excising GOTOs from his Pascal code when he was 11.
08:19:02 * luite used goto's in his C code last year
08:19:04 <Axman6> goto has a place, but it's very small
08:19:06 <edwardk> yeah, but it is still unfortunate ;)
08:19:12 <merijn> I started adding goto's to my C code 2 years ago :D
08:19:23 * Nimatek heard that people actually use goto in his late teens.
08:19:25 <roconnor> I dont' use GOTO very often in Haskell.
08:19:29 <merijn> It made my code so much better
08:19:32 * edwardk wrote a goto combinator in haskell a couple months ago
08:19:40 * merijn is a rebel
08:20:00 <Nimatek> Also, obligatory http://xkcd.com/292/
08:20:02 <edwardk> for playing around with indexed store comonads actually
08:20:09 <Axman6> i had some gotos in some code to 'optimise' an early termination case. using if and return in the loop was faster
08:20:28 <edwardk> sorry for unleashing the velociraptors
08:20:48 <merijn> I had some triple or quadruple nested server loop in some code, and goto was the nicest way to break out back to the top of the first loop
08:20:53 <dylukes> goto's can actually be really useful.
08:20:59 <luite> edwardk: it's ok, they taste like chicken
08:20:59 * Axman6 -> sleep
08:21:04 <dylukes> For instance, arbitrarily deep routines with a common error routine.
08:21:09 <merijn> To sorta mimic the same behaviour as Go's panic/recover
08:21:12 <dylukes> just goto error; if it messes up, cleaner, etc.
08:21:21 <dylukes> it's basically a way to simulate a try/catch exception style.
08:21:25 <luite> on error resume next
08:21:55 <merijn> panic/recover is one of the saner error handling mechanism I've seen
08:22:15 <merijn> I can tell luite knows the feeling of true pain :>
08:22:24 <monochrom> java and perl etc have improved loop commands for you to quit several loops at once, so that you don't need goto for that
08:22:32 <Jafet> @remember luite *amacleod started excising GOTOs from his BASIC code when he was 10.  *roconnor started excising GOTOs from his Pascal code when he was 11.  *luite used goto's in his C code last year.
08:22:32 <lambdabot> Nice!
08:22:47 <monochrom> if you need goto just for that, you're in C or something
08:22:57 <merijn> Did lambdabot lose some of his quotes? There seems to be only one MMR restruction
08:23:19 <merijn> s/restruction/restriction
08:24:04 <Peaker> Has anyone explored the similarity/relationship between the Stream type (from "lists to streams to nothing at all") and Iteratees? Iteratees are recursively defined -- so may not enjoy the optimizations that Streams do.  Streams are not monad-lifted and have no chunking/error support, so cannot be used as Iteratees.  I think one can make a type that unifies both things
08:24:25 <Peaker> And I'm wondering if venturing there will just duplicate existing work
08:24:35 <jonkri> looking at http://hackage.haskell.org/packages/archive/network/2.3.0.4/doc/html/Network-URI.html, i find isIPv4Address to be a little mis-placed. why is it in the URI module? "isIPv4address "foo://anonymous@192.168.1.1:42/ghc?query#frag"" returns false. also, any idea where i can find something like isHostaddress? :)
08:24:46 <ezyang> My impression is that streams tend to be pure, while iteratees monadic.
08:24:54 <ezyang> The chunking is an incidental implementation detail.
08:25:13 <luite> oh now I will be remembered for using goto's :(
08:25:23 <luite> well, serves me right I guess
08:25:38 <Peaker> ezyang: well, streams can be lifted
08:25:41 <Peaker> ezyang: to be monadic
08:25:53 <ezyang> Yes, but then you end up with the resource utilization problems that iteratees set out to solve.
08:25:53 <Peaker> ezyang: and the chunking/error stuff can probably be layered on top of streams
08:26:05 <Peaker> ezyang: really? why?
08:26:15 <ezyang> Give me the type of your lifted stream.
08:26:15 <Peaker> ezyang: iteratees are also lifted in the same way
08:26:31 <ezyang> Control for iteratees is "inverted".
08:27:53 <Axman6> would supercompilation be a good way fo getting stream fused code automatically, instead of having to write rules?
08:27:56 <hpaste> Peaker pasted “Lifted Stream” at http://hpaste.org/48667
08:28:24 <Axman6> seems to me that i could be excellent when used there
08:28:41 <ezyang> Oh, we disagree on what a stream is. Sure, now you have a iteratee.
08:28:57 <Peaker> ezyang: that's from the paper, with an added "m"
08:29:04 <ezyang> (Iteratees are "chunked", but IMO that's incidental, I just say Stream m (Chunk a))
08:29:13 <Peaker> ezyang: but it's a producer, not a consumer, actually, I'm a bit confused, and thinking about it :)
08:29:33 <Peaker> ezyang: yeah, I agree that the chunks are incidental and should have just been a layer on top if at all
08:29:44 <ezyang> (and then maybe some combinators to make handling chunks transparent)
08:29:56 <Peaker> yep
08:30:01 <ezyang> The latter bit might be a little difficult. I don't have a good sense for that.
08:30:35 <Peaker> So, Iteratee is a consumer state machine.  Stream is a producer state machine.   I think adding a consumption to the Stream would make it a transformer (Enumeratee) so it can function as an iteratee or enumerator depending on whether input or output types become ()
08:32:19 <hpaste> Peaker annotated “Lifted Stream” with “Lifted Stream (annotation)” at http://hpaste.org/48667#a48668
08:32:57 <Peaker> ezyang: the thing is -- Iteratees do their own recursive consumption,  which may cause the same ill effects that the Stream type is meant to solve
08:33:29 <ezyang> Not really sure what you mean here.
08:33:42 <Peaker> ezyang: well, do you remember why they have the Skip constructor in the paper?
08:33:52 <ezyang> nope.
08:34:58 <Peaker> ezyang: the idea is each Stream processor (e.g: Stream a -> Stream b)   is allowed to not-yet-have-a-result after getting the next input.   Then, it is the responsibility of some "engine" outside to recurse again and again until input is available
08:35:16 <Peaker> ezyang: the reason is that this allows the entire pipeline of stream processors to have no recursive functions
08:35:42 <Peaker> ezyang: and GHC can rip those to shreds, optimizing them using the ordinary optimizers
08:35:44 <Cadynum> is there a version of throwTo which doesn't block at all? (the exception just gets lost if the receiving thread is masked)
08:36:05 <ezyang> sounds like a kind of worker/wrapper transform.
08:36:22 <Peaker> ezyang: does that also involve getting rid of all recursions in the pipeline?
08:37:54 <Peaker> So, Iteratee is something like [pseudo-syntax]:   Iteratee m input output = input -> m (output | Iteratee input output)    -- and so the iteratee function recursively calls itself
08:38:36 <ClaudiusMaximus> Cadynum: you could forkIO the throwTo maybe?
08:39:15 <roconnor> @hoogle genericReplicateM
08:39:15 <lambdabot> No results found
08:39:16 <Peaker> whereas  Stream is something like:  Stream out = exists s. s -> (Done | (s, Yield out | Skip))
08:39:16 <Cadynum> ClaudiusMaximus, i could, but it will be thrown often so there would be a lot of forkio's
08:42:35 <Tomsik> Uh. I have trouble chosing what to use for a web db-centric application.
08:43:16 <Tomsik> Yesod seems okay, but it's very template-heavy, which doesn't make me happy
08:43:33 <merijn> HappStack seemed rather nice
08:43:59 <mm_freak> i'm using a combination of yesod and HDBC
08:44:33 <Tomsik> I'm particularly unhappy about state of Yesod forms
08:45:40 <mm_freak> Tomsik: yesod's forms are actually fine, as long as you don't try to bring forms and DB entities into a 1:1 correspondence
08:45:52 <HugoDaniel> i like happstack
08:46:11 <HugoDaniel> the crashcourse is easy to follow
08:46:18 <luite> there's a new yesod-forms by the way, that's a bit cleaner, and adds internationalization
08:46:31 <avartanian_> So here is a challenge. Can anyone write -b +- sqrt(b^2 - 4ac) / 2a using only point free or applicative functors?
08:46:35 <luite> but its documentation is underwhelming, like that for the rest of yesod :p
08:47:20 <Clint> win 23
08:47:23 <Tomsik> mm_freak: I've noticed that, but uh, making custom forms is neither html-land nor haskell-land, it's just messy as hell
08:47:30 <Tomsik> at least that's how I felt
08:48:10 <mm_freak> Tomsik: what is a "custom form"?
08:48:25 <luite> you're using the monadic forms or input forms?
08:48:26 <Tomsik> I don't want a new line for each field
08:48:50 <mm_freak> Tomsik: a new line in the source code?
08:48:58 <Tomsik> no, on the page
08:49:03 <mm_freak> ah
08:49:10 <mm_freak> well, i do that with CSS
08:49:23 <luite> do you use renderDivs?
08:49:24 <mm_freak> use div-based forms and CSS for laying out
08:49:31 <mm_freak> i use runFormDivs
08:49:43 <luite> oh I guess renderDifs is yesod-forms 0.2
08:49:46 <luite> Divs
08:49:52 <Tomsik> but doesn't that generate a generic div?
08:50:05 <mm_freak> every div gets a unique id
08:50:16 <mm_freak> you can give specific ids, if you want, but i seldomly need that
08:51:15 <Tomsik> But you have to know the id of div to put it in the CSS, right?
08:51:18 <luite> I wish the docs/examples for 0.2 would give more types
08:53:03 <mm_freak> Tomsik: yes
08:53:21 <mm_freak> Tomsik: the way to do it is to generate an id (there is a function for that) and use it in both the form and the stylesheet
08:53:38 <Tomsik> Hmm
08:54:23 <Tomsik> So maybe my frustration is coming just from lack of good docs related to that stuff
08:54:51 <mm_freak> well, the docs cover all that =)
08:55:05 <mm_freak> the yesod book does, at least
08:55:10 <mm_freak> the haddock docs don't
08:55:34 <luite> every time I want to know how to do something with yesod, I seem to need an unfinished chapter of the yesod book :p
08:55:59 <mm_freak> yeah, that's unfortunate
08:56:02 <Tomsik> mm_freak: huh? I've never seen that stuff in the book
08:56:02 <mm_freak> docs are quite incomplete
08:56:40 <Twey> I remember seeing ID-generation in the book…
08:58:10 <Tomsik> Twey: I don't remember any example using divs
09:01:33 <Peaker> ezyang: after a discussion with a coworker, I can't really figure out why inversion of control of Iteratees is necessary for predictable resource consumption. If the "main loop" if the Iteratee's enumerator, pushing until no more is wanted, and then freeing resources -- or if it is the some consumer eating away the pipeline values until it says "done/close, release" to the pipe's end,   either way -- it should clear resources predictably
09:03:28 <c_wraith> Peaker: and what if you're reading from a file, and have read enough, and you're done with it?
09:03:41 <Peaker> c_wraith: then the consumer loop signals a "close" which propagates to the producer, which closes the file
09:03:51 <c_wraith> Peaker: with inversion of control, you *know* it will get closed with no effort on your part
09:04:01 <c_wraith> Peaker: without, you have to manually close it
09:04:08 <c_wraith> Peaker: one of these is more error-prone than the other
09:04:12 <Peaker> c_wraith: not really - because the consumer can block and delay the closing inevitably, just as it can delay consumption/closing
09:04:28 <Peaker> c_wraith: you don't have to manually close -- if you execute the pipeline via a standard consumption loop which closes at the end
09:04:52 <dylukes> Peaker: the point is to be asynchronous and *not* block.
09:04:54 <c_wraith> Peaker: ...  "standard consumption loop" sounds amazingly like "iteratee"
09:05:27 <Peaker> dylukes: No, blocking for flow control. e.g: iterHandle into a slow socket
09:05:48 <Peaker> c_wraith: except iteratee is push-based, and it has a "standard production loop", rather than a "standard consumption loop"
09:06:07 <Peaker> c_wraith: I think there's really an isomorphism between a producer-based and a consumer-based pipeline model
09:06:27 <c_wraith> Peaker: no, enumerators produce.  Iteratees consume.  At least in the slowly-standardizing vocabulary
09:06:43 <Peaker> c_wraith: Well, in this context I meant "iteratee" as the name of the whole framework/approach
09:07:12 <c_wraith> Peaker: I think that means you're arguing for an identical system with different names
09:07:31 <Peaker> c_wraith: Enumerator(which implements the loop) -> Enumeratee -> Enumeratee -> Iteratee        vs:  Producer -> Transformer -> Transformer -> Consumer(which implements the loop)   and using a Stream-like type from the "streams to nothing at all" paper, would be the same
09:07:33 <edwardk> you could invert control, and pump the source yourself. the iteratees just are the other side of that perspective. iteratees care nothing about your source.
09:07:48 <edwardk> they provide a separation of concerns
09:07:57 <edwardk> the inversion of control isn't critical to space performance
09:08:28 <Peaker> edwardk: well, I don't think there would be an operational difference, but a pull-based model would be more like the "nothing at all" paper -- and might: A) unify two previously separate concepts  B) enable more fusion optimizations as in the paper
09:08:31 * cmccann wonders about the utility of separating the driving loop from both the source and sink.
09:08:38 <edwardk> one thing they do provide is nice space performance because of they way they use continuation passing style, which makes them cheaper to bind than the free definition of an iteratee
09:09:31 <edwardk> cmccann: you have a lot more flexibility in what and how to drive that way, when you have more than one iteratee you are caring for and feeding ;)
09:09:32 <Peaker> edwardk: well, Iteratees still use sum types for the iteratee results, not CPS
09:10:16 <edwardk> http://hackage.haskell.org/packages/archive/iteratee/0.8.5.0/doc/html/Data-Iteratee-Base.html#t:Iteratee
09:10:16 <Peaker> edwardk: but what if you have multiple producers that need to go into a single iteratee, in parallel?
09:10:36 <edwardk> looks cps'd to me ;)
09:10:40 <Peaker> edwardk: oh, I'm using the Enumerator package :)
09:10:48 <edwardk> oh.
09:11:23 <Peaker> it has Iteratee=newtype of m(Step..)  and Step = sum type
09:11:26 <edwardk> blech. left associated binds there are expensive
09:12:04 <edwardk> the cps'd version is actually rather fundamentally better =)
09:12:26 <Peaker> edwardk: hmm.. Maybe the Stream approach can be CPS'd too
09:12:52 <edwardk> it probably can. the iteratee version is just a right kan extension
09:13:02 <cmccann> edwardk, btw, don't iteratees work out to be the free monad on ((->) t) or something like that?
09:13:25 <edwardk> they almost do, if you don't allow for the extra crap dangling off of Done.
09:13:44 <Peaker> edwardk: actually, in the Stream approach CPS makes no difference -- because the intermediate data constructors are all eliminated by standard optimizations due to the non-recursive structure of the code
09:13:55 <edwardk> sure
09:14:24 <Peaker> anyway, now I'm all motivated to implement an Iteratee-like framework based on the Stream type from the paper
09:14:32 <edwardk> hah
09:14:41 <Peaker> and a "consumption" loop, and perhaps Applicative-based fold fusion on the consumers (as in Conal's blog)
09:14:41 <cmccann> yeah, with some extra stuff bolted on, though I think that all boils down to composing the free monad with another functor to create the full result type or something simple like that
09:15:02 <Peaker> but I have boring C work to do, instead :)
09:16:25 <edwardk> good luck. i'm busy enough playing with rings that i'm unlikely to go stealing your thunder ;)
09:16:47 <dylukes> I'm trying to think of ways to model organic systems in computer space.
09:17:04 <roconnor> I should name (either fail return) something
09:17:25 <edwardk> @type either fail return
09:17:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => Either String a -> m a
09:17:26 <dylukes> The only thing I've really concluded is that the function of some object must follow its structure, not values in a list or such.
09:32:02 <nus> roconnor, waitforDeathMessage ?-)
09:36:21 <amacleod> Is there a way to ask ghci for the definition of a function with a particular context?  I want to see the definition of fmap when used on Maybe.
09:37:46 <kmc> no, but lambdabot knows some of them
09:37:53 <kmc> @src Maybe fmap
09:37:54 <lambdabot> fmap _ Nothing       = Nothing
09:37:54 <lambdabot> fmap f (Just a)      = Just (f a)
09:38:21 <kmc> lambdabot is just reading from a database someone compiled; it's not guaranteed to be comprehensive or even correct
09:38:47 <kmc> amacleod, otherwise I would use GHCi's ":i"
09:38:52 <kmc> Prelude> :i Maybe
09:38:58 <kmc> instance Functor Maybe -- Defined in Data.Maybe
09:39:14 <kmc> then you can find API docs at http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/index.html or off a particular package on Hackage
09:39:18 <amacleod> :i is short for :info, right?
09:39:20 <kmc> yeah
09:40:20 <amacleod> @src [] fmap
09:40:20 <lambdabot> fmap = map
09:40:33 <kmc> in the case of fmap, there's usually only one reasonable way you could define it, given the types involved
09:40:46 <amacleod> Indeed.
09:40:55 <Tomsik> fmap = [] :p
09:41:04 <Tomsik> err const []
09:41:10 <edwardk> tomsik: reasonable given the types and the laws involved
09:41:11 <Tomsik> even const const
09:41:16 <merijn> amacleod: The prelude sources are usually quite readable so you can always check those
09:41:20 <edwardk> tomsik: fmap id = id rules out that one
09:41:30 <Tomsik> heck
09:41:36 <edwardk> once you show fmap id = id for your definition, you don't need to show anything else
09:41:43 <edwardk> the other law follows from that and the free theorem
09:41:52 <kmc> (fmap f) on an algebraic value of type (F t) should preserve the constructor, apply f to each field of type t, and apply (fmap f) to each field of type (F t)
09:42:03 <kmc> and leave other things alone
09:42:10 <edwardk> it also shows that any two such definitins for which fmap id = id holds are equivalent.
09:42:24 <kmc> the other law is fmap f . fmap g = fmap (f . g) ?
09:42:27 <edwardk> also a consequence of the free theorem
09:42:29 <edwardk> yeah
09:43:08 * hackagebot regex-applicative 0.1 - Regex-based parsing with applicative interface  http://hackage.haskell.org/package/regex-applicative-0.1 (RomanCheplyaka)
09:43:15 <edwardk> the unambiguous choice of definition is why we can have {-#LANGUAGE DeriveFunctor #-} =)
09:45:40 <amacleod> So, restating for my edification, a Functor is something that takes values from the category of "bare values" and transforms them into the category of "decorated values", while preserving identity and in-category transformations?
09:45:56 <kmc> well, GHC is happy to derive Ord even though the inverted ordering is just as good
09:46:16 <kmc> amacleod, are you describing a functor in category theory or a Haskell Functor?
09:46:25 <amacleod> Well, I'm trying to relate the two.
09:46:28 <edwardk> yeah
09:46:39 <kmc> categories aren't really "of values"; they're "of morphisms"
09:46:52 <edwardk> and Traversable and Foldable are also derivable but non-canonical, just subject to convention
09:46:57 <kmc> types are just there to tell you which morphisms can compose
09:47:29 <amacleod> Okay.  Is it safe to think of unary functions as morphisms?
09:47:59 <kmc> yes
09:48:27 <kmc> the category Hask is the category whose objects are Haskell types and whose morphisms are Haskell functions
09:48:40 <kmc> a Haskell Functor is an endofunctor from Hask to Hask
09:48:53 <edwardk> amacleod: a Functor is a categorical endofunctor from Hask -> Hask, more properly it is functor from Hask to Hask_f where f is the proper subcategory of Hask give by an inclusion functor based on f. the action of fmap describes the mapping of arrows.
09:49:39 <amacleod> Are arrows the same or different from morphisms?
09:49:45 <edwardk> same
09:50:00 <kmc> but not particularly related to the Haskell Arrow typeclass
09:50:09 <edwardk> generally when talking about a category the objects are boring, being just places to hang arrows. so we talk about the composition of arrows
09:51:09 <edwardk> amacleod: unary functions in haskell can be treated as both arrows and as objects (exponentials) depending on your needs at the time.
09:51:35 <edwardk> amacleod: that becomes an important distinction when you try to puzzle through haskell's Monad categorically
09:51:36 * amacleod loves treating functions as objects.
09:53:10 * hackagebot bindings-linux-videodev2 0.1 - bindings to Video For Linux Two (v4l2) kernel interfaces  http://hackage.haskell.org/package/bindings-linux-videodev2-0.1 (ClaudeHeilandAllen)
09:53:36 <kmc> Jackie Treehorn treats objects like women!
09:53:37 <wli> glpk has writing-to-stdout/stderr side effects... looks like linear programming is next on the agenda.
09:54:12 * hackagebot bindings-mmap 0.1 - bindings to mmap for Linux  http://hackage.haskell.org/package/bindings-mmap-0.1 (ClaudeHeilandAllen)
09:54:14 * hackagebot bindings-libv4l2 0.1 - bindings to libv4l2 for Linux  http://hackage.haskell.org/package/bindings-libv4l2-0.1 (ClaudeHeilandAllen)
09:54:16 * hackagebot v4l2-examples 0.1 - video for linux two examples  http://hackage.haskell.org/package/v4l2-examples-0.1 (ClaudeHeilandAllen)
09:54:20 <dylukes> kmc: an endofunctor is what again?
09:54:26 <dylukes> a functor within the same universe?
09:54:31 <edwardk> a functor from a category to itself
09:54:35 <dylukes> ah, right right.
09:54:48 <amacleod> I've been told that monads are endofunctors.
09:54:51 <dylukes> But, as you said, in this case its a functor to a subset.
09:55:07 <edwardk> amacleod: they are. they are endofunctors with a bit more structure
09:55:11 <dylukes> So, what is a setoid?
09:55:26 <amacleod> Does the "proper" in "proper subset" mean that the subset isn't identical with its superset?
09:56:00 <edwardk> dylukes: a functor to a subcategory can be used as a functor to the category or more properly extended along the inclusion functor to be a functor to the category, so there is no real problem
09:56:11 <edwardk> amcleod: yeah
09:56:12 <amacleod> Given that Haskell's Functor is a functor from Hask to Hask, does that mean that every instance of Functor is an endofunctor?
09:56:22 <dylukes> can you explain that a bit more thoroughly edwardk?
09:56:22 <edwardk> amacleod: yep
09:56:58 <edwardk> dylukes: try to define a 'true' identity functor in Hask, that takes Hask to Hask. it would have fmap :: (a -> b) -> a -> b, but we can't have that because we need the newtype noise to dispatch fmap
09:57:24 <dylukes> ?...
09:57:24 <lambdabot> Not enough arguments to @.
09:57:29 <edwardk> so we can only target f a -> f b ,the arrows of which form a subcategory of hask
09:57:37 <dylukes> aaah, right
09:57:59 <roconnor> @src intercalate
09:57:59 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
09:58:28 <idnar> @hoogle isdigit
09:58:28 <lambdabot> Data.Char isDigit :: Char -> Bool
09:58:36 <idnar> @hoogle isalpha
09:58:37 <lambdabot> Data.Char isAlpha :: Char -> Bool
09:58:37 <lambdabot> Data.Char isAlphaNum :: Char -> Bool
09:58:48 <idnar> does that use the ASCII definition of alpha, or the Unicode one?
09:58:50 <edwardk> so the pedant in me says that Functors are precisely the functors from Hask -> Hask_f, where Hask_f is the subcategory of Hask given by an appropriate inclusion functor.
09:59:08 <ClaudiusMaximus> > isAlpha 'æ'
09:59:08 <lambdabot>   True
09:59:32 <edwardk> and it is a proper subcategory, because of the necessary newtype noise ;)
09:59:45 <roconnor> edwardk: you have the best job in the world!
10:00:02 <edwardk> roconnor: i tried to get you to come down and join me at it ;)
10:00:07 <mercury^> But it is equivalent – even isomorphic – to Hask, so that's no problem.
10:00:10 <roconnor> ya, I won't move yet
10:00:14 <edwardk> roconnor: the offer still stands if you ever change your mind
10:00:17 <edwardk> yeah i know
10:00:21 <roconnor> maybe next year
10:00:38 <roconnor> oh wait I forgot you don't program in Haskell at your job
10:00:39 <edwardk> mercury^: not isomorphic to hask.
10:00:43 <roconnor> okay, so maybe it isn't that great
10:00:46 <roconnor> :D
10:00:56 <edwardk> mercury^: the Identity functor case is, but the others are smaller =)
10:01:03 <mercury^> edwardk: yes.
10:01:16 <mercury^> But that's not an issue.
10:01:33 <mercury^> Just the identity functor should go to something equivalent.
10:01:36 * roconnor wonders if sun life financial uses Haskell
10:02:06 <dylukes> edwardk: What do you mean "inclusion functor"?
10:02:15 <mercury^> edwardk: what is your job, at the moment? :>
10:02:28 <edwardk> dylukes: http://en.wikipedia.org/wiki/Subcategory
10:02:56 <roconnor> dylukes: I don't know but it seems to involve a lot of comonads
10:03:02 <roconnor> er
10:03:06 <roconnor> mercury^: : I don't know but it seems to involve a lot of comonads
10:03:25 <mercury^> Sounds good to me. =p
10:04:06 <edwardk> mercury^: i work at ClariFi, we make tools for quants
10:04:06 <edwardk> mercury^: if you are looking for work, send me a resume!
10:04:41 <mercury^> Hah, not at the moment. But thanks. Maybe at some point in the future I would like to fall back on that. :)
10:05:18 <edwardk> we have a nice toy functional programming language with type inferable row types and disjoint union constraints, category theory classes every friday, ...
10:05:33 <edwardk> keep it in mind. i'll happily give the sales pitch later if you want ;)
10:05:35 <roconnor> and semantics for IO
10:05:51 <edwardk> roconnor: those made me really happy =)
10:06:43 <edwardk> our current implementation has drifted a bit from the free monad of an indexed store comonad though
10:06:46 <Saizan> well, it's still as much semantics as your standard free monad
10:07:11 <wli> Sounds pretty wild.
10:07:25 <edwardk> well, it gives an intuitive understanding of FFI as an asymmetric coroutine driven by the RTS
10:08:05 <edwardk> the language then exists entirely passively, until asked by something external to evaluate a term
10:08:33 <edwardk> wli: i described the general idea in the yielding io post on my blog
10:10:09 <wli> Some way to silence glpk's pollution of stdout/stderr would make it usable and dodge the need to reimplement linear programming.
10:10:15 <dylukes> Hm.
10:10:36 <dylukes> So, what's the state of the LLVM backend, and how independent is it from the target platform?
10:10:54 <dylukes> Can GHC be directed to output LLVM bit code or IR?
10:14:29 <Saizan> it's not independent
10:15:53 <dylukes> Basically what I'm saying is,
10:15:58 <dylukes> "is GHC a cross compiler"
10:16:13 <dylukes> Seems to be a "no".
10:16:43 <dylukes> How difficult is it to implement a Haskell 98 compiler?
10:17:09 <olsner> it has been done, several times, so it can't be *that* hard :P
10:17:23 <dylukes> I need some sort of project I can really focus on, and i'm thinking maybe an embedded-systems Haskell compiler might be a nice project.
10:17:30 <Saizan> right, it's not a cross compiler, there's been some effort in that direction though
10:17:49 <dylukes> That is, a rudimentary haskell compiler intended off the bat to be a cross-compiler.
10:18:01 <dylukes> so, ARM and MIPS rolled in off the bat.
10:18:12 <dylukes> Might be an interesting way for me to combine all of the various things I'm trying to learn.
10:18:26 <Saizan> an haskell98 compiler is not a so small task, that's one reason why there aren't a gazillion implementations
10:18:37 <edwardk> dylukes: i have a toy 'turbo haskell' compiler i keep playing with in off hours
10:18:56 <dylukes> edwardk: I'd love to see it sometime, heh.
10:19:04 <dylukes> So, what were those papers on STG and such?
10:19:08 <Eduard_Munteanu> edwardk: THC?
10:19:15 <edwardk> Eduard_Munteanu: =)
10:19:20 <dylukes> Even if I decide not to try, I think it'd be worthwhile to read some papers on implementing haskell.
10:19:22 <Saizan> edwardk: and the poor kata?
10:19:24 <edwardk> Eduard_Munteanu: that is the current project folder =)
10:19:31 <edwardk> saizan: that too
10:19:36 <Eduard_Munteanu> Heh.
10:19:42 <dylukes> I'm visualizing a marijuana leaf combined with monadic bind.
10:19:44 <dylukes> It's amusing.
10:19:51 <edwardk> turbo haskell is basically me trying out evaluation machinery for kata
10:20:08 <Saizan> ah, makes sense
10:20:20 <edwardk> i figure it lets me change one thing at a time
10:20:28 <edwardk> and that way i can sanely benchmark against ghc
10:20:33 <dylukes> What is Kata?
10:20:43 <edwardk> to see how much speed can be gained or lost by my tracing jit stuff
10:20:49 <merijn> dylukes: You could also see if you can use GHC's llvm backend to turn it into a cross compiler
10:21:18 <dylukes> merijn: That's what I was thinking, but now that I look closer, it probably extern's to system-specific methods and such.
10:21:33 <merijn> Well, go fix that! ;)
10:21:35 <edwardk> kata is a toy language of mine, basically take haskell rip out the types, add back in enough ml-like modules to get what you lost from type class inference, then do a bunch of crazy multiple inheritance stuff to make that not suck
10:21:47 <dylukes> edwardk: sounds weird :P
10:21:49 <Eduard_Munteanu> edwardk: what is it, a Haskell JIT compiler?
10:21:54 <edwardk> a bunch of other second system stuff is included
10:22:01 <edwardk> Eduard_Munteanu: the turbo haskell stuff?
10:22:10 <Eduard_Munteanu> Ah, you mentioned JIT.
10:22:30 <edwardk> Eduard_Munteanu: ah, basically a tracing jit is all but _MADE_ for the spineless tagless g-machine.
10:22:53 <edwardk> case evaluation requires 1-2 indirect jumps to calculated addresses
10:23:05 <edwardk> moved into a tracing jit those become direct jumps
10:23:14 <dylukes> What is tracing jit?
10:23:19 <dylukes> I need to read on the STG.
10:23:22 <edwardk> and effectively it iteratively closes the world over the thunk cases that emerge in practice
10:24:14 <edwardk> a tracing jit is an approach to jitting that has recently gained some attention being what is used in spidermonkey's tracemonkey inside of firefox. basically what you do is you watch until a back edge in your code gets 'hot' from being called too much
10:24:28 <edwardk> then rather than just compiling blindly from that spot like a usual jit what you do
10:25:21 <edwardk> is you evaluate and log what you do as you go and what branches you take become assumptions. you gamble that by getting hot there was some cycle that passed through that code location, and that you'll get back there before the trace fills up
10:25:46 <edwardk> if you get back to where you started you now have a basic block with a bunch of side-exits to optimize. that is compiler gold right there.
10:27:02 <nominolo> edwardk: you have to duplicate tails, though
10:27:02 <edwardk> you can do runtime constant folding, you've ALREADY done inlining, you can unbox any thunk you allocate for which no reference escapes the trace, you can strictly evaluate any thunk that is forced on all exits of the trace, and you only have to reify the stack side-effects when you fall off the trace and go back to boring evaluation
10:27:12 <edwardk> nominolo: that is the price
10:27:28 <edwardk> but you do so in a loop inverted manner anyways
10:27:40 <nominolo> how's your tracing jit implemented?
10:27:57 <dylukes> edwardk: That made little to no sense. Too much jargon ^^;
10:28:10 <edwardk> dylukes: sorry. read stuff by andreas gal
10:28:14 <dylukes> Links?
10:28:26 <edwardk> google him and tracemonkey and you'll find lots
10:29:05 <nominolo> dylukes: see section 2 http://dl.dropbox.com/u/3265448/schilling.haskell-jit.2011-03-23.pdf
10:29:27 <edwardk> nominolo: well i have one for x86-64 assembly to x86-64 assembly which is an opt-in jit, which is nice because i can use it to trace through things like glibc and do non-haskell specific stuff. i've been exploring more conventional jits with bigger grains for simple bytecodes close to ghc's bytecode
10:30:24 <edwardk> it has been something i've kicked around for about 3 years now, and talked about in here. i've just had too many other draws on my time
10:30:33 <kmc> dylukes, interpreting Javascript is slow.  if you find your interpreter is executing the same code path ("trace") over and over, you compile that to native code
10:30:49 <nominolo> edwardk: well, jitting x64 bytecode seems hard.  For example, DynamoRIO had lots of issues.
10:30:56 <dylukes> I guess you wouldn't want to just compile the whole thing ,that might be too slow?
10:31:04 <nominolo> To be fair, though, DynamoRIO needs to maintain transparency
10:31:07 <edwardk> nominolo: yes, but they tried to be invisible. i'm not trying to be
10:31:13 <edwardk> nominolo: yeah =)
10:31:21 <kmc> dylukes, well, sure, but the big win in compiling traces is that you get to make lots of assumptions
10:31:29 <dylukes> hm?
10:31:37 <kmc> you produce native code which is not *in general* a faithful translation of the source program
10:31:47 <kmc> but holds for the particular way that code is being called right now
10:31:55 <kmc> if the assumptions are violated you just bail and go back to the interpreter
10:31:55 <dylukes> what if that code is called slightly differently?
10:32:01 <dylukes> then it doesn't use the JIT'd path?
10:32:04 <kmc> yeah
10:32:09 <edwardk> i spent quite a bit of time talking to greg sullivan from the dynamo rio project a couple of years back
10:32:10 <edwardk> dylukes: or you start a new trace
10:32:11 <Eduard_Munteanu> dylukes: the code runs in a managed environment
10:32:11 <dylukes> so "trace" means "path" here?
10:32:12 <kmc> and it might eventually JIT another trace
10:32:14 <nominolo> edwardk: regarding trace selection there's an interesting recent paper on "false loop filtering": http://www.trl.ibm.com/people/inouehrs/pdf/ASPLOS2011_FalseLoop.pdf
10:32:20 <dylukes> "trace" seems like confusing terminology ^^;… oh well
10:32:27 <Eduard_Munteanu> So the compiler can always step in.
10:32:29 <kmc> dylukes, so you get to do runtime constant folding, runtime inlining, etc.
10:32:52 <kmc> the programmer can write very general abstract code, and the system dynamically recompiles it to suit the particular way it's being executed right now
10:32:54 <edwardk> nominolo: nice. i'm a bit behind on current tracing papers
10:33:06 <kmc> so you can see why it could be a huge win for Haskell
10:33:19 <nominolo> edwardk: there's also a workshop now: http://pppj2011.imm.dtu.dk/iwtc.php#content
10:33:28 <nominolo> I'm currently writing a paper for it
10:33:31 <edwardk> dylukes: a trace is a path execution actually took. a compiled trace is an optimized version of that for subsequent evaluation
10:33:37 <dylukes> constant folding?
10:33:47 <edwardk> nice
10:34:16 <dylukes> kmc: I see, so if say, a factorial method is being called over and over with input '0', it could compile the relevant traces to just inline a constant '1' instead?
10:34:19 <edwardk> basically what i'm looking towards is the most naive haskell compiler possible, coupled with a nice tracing jit to see how well it stacks up against more conventional approaches
10:34:27 <kmc> yeah
10:34:50 <edwardk> sadly i can't use the old nhc/yhc bytecodes because i still want eval/apply rather than push/enter
10:34:52 <dylukes> though if this is a compiled language,
10:35:00 <dylukes> static analysis could do that in the bc translation phase
10:35:13 <edwardk> dylukes: at a combinatorial explosion in cost.
10:35:17 <kmc> you have way more information at runtime
10:35:18 <Eduard_Munteanu> edwardk: oh, do you want to compile to a bytecode first?
10:35:23 <dylukes> Hm.
10:35:24 <nominolo> edwardk: well, that's pretty much what I'm doing ;)
10:35:25 <dylukes> True.
10:35:25 <c_wraith> wasn't one of the GHC papers on how eval/apply is actually better-suited to compilation?
10:35:34 <kmc> "Making a fast curry"
10:35:39 <c_wraith> yeah, that one
10:35:43 <edwardk> Eduard_Munteanu: yeah. my original goal was to just exploit my x86-64 tracing jit
10:35:52 <edwardk> c_wraith: exactly
10:35:59 <edwardk> c_wraith: thats why i can't use the yhc stuff
10:36:21 <edwardk> push/enter hides too much stuff from the jit
10:36:46 <nominolo> edwardk: not sure I agree with that
10:36:57 <nominolo> edwardk: since in traces there are no function calls left
10:36:59 <edwardk> nominolo: nice. well, if i don't get back to it, you're welcome to carry the torch forward ;)
10:38:11 <edwardk> my original work on this was started back when mmorrow was still around here. at the time i was stuck quotienting out some of the calls from the trace, because i was calling in to native thunks occasionally
10:38:28 <edwardk> nominolo: so there was still a concrete difference
10:38:54 <Eduard_Munteanu> edwardk: jitplusplus?
10:39:06 <edwardk> the main reason i stopped working on it was that mmorrow wandered away, and he was my main guide to ghc internals
10:39:29 <edwardk> Eduard_Munteanu: that at least has the tracing machinery for x86-64 assembly. i was using that and some hand compiled traces for a while
10:40:01 <edwardk> Eduard_Munteanu: it has kind of languishes for wont of attention for a few years now.
10:40:11 <edwardk> er languished
10:40:22 <nominolo> edwardk: I see, so you want to interface with GHC compiled code
10:40:51 <edwardk> that was my original goal. now i'm just leaning towards doing it directly, because i need an STG-like back end for a toy language of mine anyways
10:41:20 <Eduard_Munteanu> I guess you could also hook into LLVM so you get a common LIR easily.
10:41:36 <edwardk> the problem is LLVM gives me no control over stack layout
10:41:51 <edwardk> which means i can only tracing jit something with off-to-the-side Haskell-like stacks
10:42:26 <nominolo> edwardk: I'm using a GRIN-like bytecode.  I don't have a spec, yet, but here's teh interpreter: https://github.com/nominolo/lambdachine/blob/master/rts/InterpThreaded.c#L236
10:42:32 <edwardk> my previous code-emission back end looked a lot like lua-jit's assembler. emitting code in reverse to do cheap register allocation
10:42:38 <Eduard_Munteanu> Ah, I see. Supposedly that's so you don't break debugging and calling conventions, no?
10:43:15 <edwardk> at the time i thought grin was kind of the wrong path, because it takes you towards whole-program territory
10:43:16 <nominolo> edwardk: the bytecode format is pretty much LuaJIT2's
10:43:17 <Eduard_Munteanu> BTW, what do you use for register allocation? Linear allocation?
10:44:01 <edwardk> Eduard_Munteanu: well, when compiling from x86-64 to x86-64 i can do some pretty AWESOME register allocation, because it was already done for me in the original trace ;)
10:44:18 <Eduard_Munteanu> Hm.
10:44:19 <nominolo> edwardk: well, I have a polymorphic EVAL, so you could call is STG, if you want..
10:44:22 <edwardk> so i can do that with linear reverse allocation on the extra stuff
10:44:40 <edwardk> nominolo: ah. yeah, built that grin variant once =)
10:45:34 <Eduard_Munteanu> And do you do SSA?
10:45:53 <edwardk> Eduard_Munteanu: as for stg tracing, i don't have any real plans other than to copy my old reverse linear approach
10:46:19 <edwardk> yes to the limited extend i need to do anything at all
10:46:37 <nominolo> Eduard_Munteanu: traces are almost automatically in SSA form
10:46:38 * wli vomits on linear allocation.... GURRR FTW.
10:46:47 <Eduard_Munteanu> nominolo: how so?
10:47:04 <edwardk> wli: keep in mind this is being done in a setting where i've already inverted all my loops implicitly
10:47:06 <nominolo> Eduard_Munteanu: because you have only one join point
10:47:23 <edwardk> so there isn't any allocation strategy that is obviously better to apply here =)
10:47:44 <edwardk> i could play some coloring games, but keep in mind the clock is ticking because this is at runtime
10:48:00 * Eduard_Munteanu wonders if any JITs do normal graph coloring if it turns out something is a hot path
10:48:56 <edwardk> in my x86-64 jit case i wasn't able to ensure that i remained with a single join point, largely because i don't invert ALL loops. my jit points were programmatically inserted.
10:49:53 <Eduard_Munteanu> AFAIH, linear allocation is pretty good anyway.
10:49:59 <nominolo> edwardk: how were you planning on dealing with thunk updates?
10:50:03 <edwardk> so you'd expand a JIT macro in the code which would be responsible for expanding to a static declaration of a jit point counter and forwarding pointer, and then decrementing that counter towards zero, and jumping into the tracing machinery if it hits zero
10:51:38 <edwardk> well, thats part of why i'm in the STG, a thunk is just a chunk of memory with an infotable/code pointer, and a forwarding pointer. so do what ghc does, update the forwarding pointer. my traces are walking the infotable pointers. and constant fold the lookup of the code pointer from the infotable.
10:52:18 <edwardk> runtime constant folding is based on reflectively looking at /proc/self/map and believing that unless told otherwise all read-only memory will remain invariant throughout runtime
10:52:27 <edwardk> (with the exception of the top of memory page supplied by the kernel)
10:52:36 <edwardk> so infotables are in constant memory
10:53:01 <edwardk> Eduard_Munteanu: especially once you've inverted loops
10:53:23 <edwardk> nominolo: i have to admit your comment about push/enter has me thinking.
10:53:40 <edwardk> nominolo: now that i've scrapped my goal of direct ghc-interop, that could make my life a lot easier
10:54:15 <edwardk> basically its easier to steal a page out of ndm's book with supero than it is to steal lemmih's lhc approach in terms of interacting with ghc
10:54:50 <edwardk> and i'm not wedded to doing all the boring bits of haskell myself.
10:55:00 <chrisdone> http://open.spotify.com/track/4UYW3jllzFyWdaxob0UVMr
10:55:06 <chrisdone> Erm. Accident.
10:55:14 <edwardk> so borrowing ghc through to core would be nice
10:55:19 <chrisdone> http://www.haskell.org/pipermail/haskell-cafe/2011-July/093712.html
10:55:27 <chrisdone> That sounds great. v4l bindings. :-)
10:55:33 <nominolo> edwardk: I find the tricky part is thunk updates, though.  The problem is this: you start tracing somewhere in the middle of some loop and there is a thunk update happening.  If you do the thunk update you also need to allocate the data that the thunk is overwritten with.
10:55:44 <nominolo> edwardk: this makes it impossible to do deforestation
10:56:02 <edwardk> not so much. the key is allocation is handled specially by my tracer
10:56:29 <edwardk> so what i do is i check to see if any references to the allocated slab of memory escape my trace
10:56:42 <edwardk> if not then i treat the locations on the slab as registers
10:56:57 <edwardk> and they get optimized like everything else
10:57:10 <nominolo> but if you store into a thunk that you received from outside the trace the updated data escapes
10:57:19 <edwardk> yeah
10:57:43 <edwardk> but if you don't you risk devolving to by-name
10:58:11 <edwardk> i'm requiring preservation of asymptotics (modulo trace recompilation overhead)
10:58:43 <nominolo> right, never updating thunks is one "solution" ;)
10:58:55 <edwardk> from my toy hand-made traces, this seems to work pretty well in practice. i'm sure there are degenerate cases where you'll get the thunk across a large gap
10:59:07 <nominolo> I'm planning to evaluate what happens if I track uniqueness info in the pointers.
10:59:28 <edwardk> i've played with that
11:00:08 <edwardk> a old type system of mine from about 5-6 years back was all about substructural types
11:00:35 <nominolo> ah, so static analysis
11:00:45 <edwardk> it'll probably help. i have something related due to an unrelated language feature for how i was working with inter-thread communication in kata.
11:01:16 <nominolo> I'm putting that off, because all systems seem to be very tricky to implement
11:01:23 <wli> F-bounded polymorphism or some such?
11:01:33 <edwardk> but you can also tag the pointer itself with a bit, which in my case pays out because i don't have dynamic pointer tagging
11:01:33 <edwardk> i've never gotten it to pay off though.
11:01:58 <nominolo> yes, that's what I was planning to do
11:02:06 <edwardk> in my case i have processes that communicate by sending messages over singularity style 2-endpoint channels. but i want each heap to be able to garbage collect independently
11:02:18 <edwardk> without paying for read or write barriers.
11:02:40 <edwardk> so i've built a collector that allows this local collection of most garbage, except for stuff that has been shared
11:03:14 <frode> Hello. In ghci I can use :module Database.HDBC, but doing import Database.HDBC in a .hs file and compiling it gives an undefined reference error. What's usually the reason for this?
11:03:48 <Saizan> are you using --make ?
11:04:09 <edwardk> to deal with that though, when i send a pointer over a channel i need to pin the memory on this side, and when i evaluate a thunk that is owned by someone else i need to pin MY result
11:04:36 <edwardk> but i can mitigate that by propagating uniqueness information
11:04:43 <monadic> frode: You need --make or -package hdbc I think.
11:04:47 <edwardk> (which is how this is relevant)
11:05:15 <edwardk> the annoying part of tagging the pointers with uniqueness is that reads become writes
11:05:22 <frode> --make seems to do the trick. Time to look that up in the manual :) Thanks Saizan & monadic.
11:05:34 <edwardk> rather contraction becomes writing
11:06:27 <nominolo> edwardk: how do reads become writes?  Do you mean register writes or memory writes?
11:06:27 <edwardk> so if i contract a pointer that is stored in an environment somewhere i need to update that environment
11:06:53 <edwardk> potentially memory writes
11:08:13 <edwardk> also the uniqueness horizon is somewhat ill specified, if i contract a reference to a list of unique pointers, everything in the list ceases to be unique, so how do you cheaply update them all?
11:08:29 <nominolo> Hm.  So I'm trying to get away with the invariant that a non-unique object is only reachable through a sequence of pointers at least one of which is tagged as non-unique.
11:08:40 <edwardk> this is why uniqueness propagation seems best done as a compile time concern
11:08:51 <edwardk> where there is no asymptotic-changing runtime cost
11:09:08 <nominolo> That means, I don't have to modify an untagged pointer if the parent becomes shared.
11:09:08 <idnar> where is the canonical location to import IsString from?
11:09:14 <nominolo> Data.String
11:09:51 <edwardk> hence why i said somewhat ill-specified rather than intractable.
11:10:17 <edwardk> its been a while since i played with this one, so my recollections may be off
11:10:46 <edwardk> that seems like a reasonable invariant
11:11:45 <edwardk> i got distracted by other shiny things ;)
11:12:04 <nominolo> edwardk: I haven't implemented it yet, though.  So there maybe some sleeping dragons somewhere
11:12:18 <nominolo> may be*
11:12:35 <edwardk> i do have a fun hack if you want to get very cheap pointers on x86-64 with these tags though
11:12:51 <sanjoyd> Monad m => (m a, >>, return) is a monoid, right?
11:12:52 <edwardk> if you care about those kinds of operational concerns
11:12:58 <nominolo> edwardk: yes, I do.
11:13:23 <nominolo> edwardk: Loading a pointer is currently 4 instructions.  Would be great to get that down
11:13:46 <idnar> hmm, do I have to use -XOverloadedStrings to be able to define an IsString instance?
11:14:04 <idnar> oh nevermind
11:14:07 <monadic> idnar: I doubt so
11:14:19 <idnar> I just forgot to import fromString and misinterpreted the error message
11:14:28 <mm_freak> hmm
11:14:31 <edwardk> i use 32 bit pointers, but i steal the most significant bit for a tag. (in kata's case its an evaluated bit, in yours, likely uniqueness). then to dereference a pointer i add it to itself, which shifts the evaluated bit into the carry flag, then i dereference it as an index register multiplied by 8. that gives me pointers to memory on 16 byte alignments
11:14:42 <idnar> I didn't actually realise you had to import the method as well as the class
11:14:43 <mm_freak> die HDBC functions seem to catch and ignore exceptions
11:14:45 <mm_freak> that's very bad
11:14:51 <mm_freak> at least for postgresql they do that
11:15:08 <edwardk> and access to 32 gigs of heap (if i choose to add a base pointer, slightly less if i do not)
11:15:26 <ntoronto> I have a question about the list monad
11:15:38 <ntoronto> probably very newb
11:15:50 <edwardk> this is basically java 1.6.x's "Compressed OOPs", tweaked to get an extra doubling of alignment, and read a tag bit
11:15:52 <ntoronto> why does [4] >>= id not work?
11:16:15 <edwardk> so the act of setting up the pointer for dereferencing gets you the tag
11:16:22 <sanjoyd> ntoronto: Because id is not of the type Int -> [a].
11:16:29 <roconnor> > [4] >>= Identity
11:16:30 <lambdabot>   Couldn't match expected type `[b]'
11:16:30 <lambdabot>         against inferred type `Data.Func...
11:16:37 <edwardk> and the pointers are half the size, which dramatically reduces pressure on caches
11:16:44 <sanjoyd> ntoronto: what are you trying to do?
11:16:49 <mm_freak> > [[4]] >>= id
11:16:49 <lambdabot>   [4]
11:16:52 <ntoronto> test the monad laws
11:16:58 <mm_freak> (>>= id) = join
11:17:10 <monadic> Admittingly the message "No instance for Num [b]
11:17:15 <monadic> is a little confusing :\
11:17:19 <ntoronto> yes :)
11:17:58 <edwardk> it is good enough that it nets you 32 bit performance in a 64 bit environment, while giving you a good sized heap
11:18:38 <nominolo> edwardk: right, mine is more complicated: https://gist.github.com/1062479
11:18:55 <ntoronto> oh, duh
11:19:01 <ntoronto> nvm, and thanks for the help
11:19:03 <edwardk> yeah
11:19:04 <ntoronto> I had the wrong types
11:19:22 <edwardk> mine winds up really small in code cache footprint as well
11:22:32 <edwardk> add eax, eax; jc alreadyEvaluated; mov dest, [heap + eax*8 + i*4] my slot offsets are all precalculated.
11:22:45 <edwardk> and using 32 bit rather than 64 registers means you have lots of room
11:23:31 <edwardk> 16 byte alignment lets you load whole blocks of 4 fields at a time as well
11:24:36 <kmc> and you can use SSE :)
11:24:48 <edwardk> yeah
11:24:58 <edwardk> which is something java's compressed oops can't do
11:25:03 <edwardk> because they only have 8 byte alignment
11:25:04 <nominolo> neat trick
11:26:13 <edwardk> since most of your thunks fit in a single 16 byte slab this means reading all of the fields, takes an add, a predicable branch and an sse load.
11:26:41 <edwardk> without alignment stalls
11:27:02 <edwardk> and 16 byte alignment means you can support long doubles ;)
11:27:37 <edwardk> going off to spend some time with my wife
11:28:40 <nominolo> yeah, need to get back to paper-writing, too
11:30:59 <Peaker> nominolo: if you know what I mean
11:38:14 <burp_> chrisdone_: tryhaskell.org is broken?
11:38:33 <mekeor> > let myfr _ l [] = l; myfr f l (x:xs) = f x (myfr f l xs) in myfr (+) 0 [1..10]
11:38:34 <lambdabot>   55
11:39:35 <mekeor> burp_: try isup.me :)
11:39:41 <Eduard_Munteanu> burp_: seems to be working here
11:39:45 <mekeor> burp_: it seems to be working for me
11:39:51 <burp_> ah, works again
11:40:03 <burp_> 5 minutes ago all inputs resulted in "terminated"
11:40:38 <chrisdone_> burp_: Seems alright here. Sometimes the VPS slows down and the custodian kills things for taking too long. Might be that.
11:40:51 <burp_> ah ok
11:42:24 * chrisdone_ decides to move it to the new vps
11:50:21 * hackagebot scrypt 0.3.1 - Stronger password hashing via sequential memory-hard functions.  http://hackage.haskell.org/package/scrypt-0.3.1 (FalkoPeters)
11:51:54 <roconnor> oh yes
11:52:14 <roconnor> plz let that be native haskell implementation fo scrypt and not a binding
11:52:33 <roconnor> This package provides bindings to Colin Percival's scrypt implementation
11:52:35 <roconnor> damn!
11:52:55 <roconnor> bindings are for the weak willed
11:55:24 <nand`> I'm having a very hard time trying to clone the standard “sequence” function. I can clone “sequence_” (which discards output) easily, but the former has had me confused for over an hour now
11:55:29 <nand`> Here my current code: http://pastebin.com/i7XbH5eg
11:55:31 <mauke> The paste i7XbH5eg has been copied to http://hpaste.org/48677
11:55:40 <nand`> Could anybody go through the second function and tell me why it does not work as expected?
11:56:05 * roconnor predicts nand` is using [] instead of [[]]
11:56:08 * roconnor looks
11:56:14 <roconnor> I'm right!
11:56:39 <roconnor> nand`: it's okay.  I always make that mistake when I implement sequence.
11:56:56 <nand`> Hmm, so you're suggesting that all I need to do is replace line 7 by: mySequence [] = [[]] ?
11:57:00 <roconnor> yes
11:57:05 <roconnor> > sequence []
11:57:06 <lambdabot>   No instance for (GHC.Show.Show (m [a]))
11:57:06 <lambdabot>    arising from a use of `M55159175...
11:57:06 <nand`> I did that and it still does not work as expected
11:57:11 <roconnor> > sequence [] :: [[()]]
11:57:12 <lambdabot>   [[]]
11:57:12 <hpaste> mbil99 pasted “bounding values” at http://hpaste.org/48678
11:57:35 <roconnor> nand`: do you get a type error?
11:58:03 <nand`> mySequence [print 1, print 2, print 3] generates “Couldn't match expected type `[[a0]]' with actual type `IO ()'”
11:58:19 <nand`> Meanwhile, “sequence [print 1, print 2, print 3]” works as expected, outputting [(), (), ()]
11:58:29 <roconnor> nand`: oh, you are writing a sequence to work on all monads?
11:58:39 <roconnor> then you need to return [] instead of [[]]
11:58:48 <roconnor> (return [])
11:59:13 <nand`> Same result
11:59:55 <mm_freak> > let mySeq [] = pure []; mySeq (c:cs) = liftA2 (:) c (mySeq cs) in mySeq ["abc", "def"]
11:59:56 <lambdabot>   ["ad","ae","af","bd","be","bf","cd","ce","cf"]
12:00:00 <roconnor> nand`: yes, that is because the body of mySequence (x:xs) isn't well typed
12:00:19 <roconnor> nand`: given a type signature to top level functions helps you and helps the error messages you get.
12:00:21 <roconnor> *giving
12:01:48 <mekeor> is 'foldr (+) 0 [1..100]' or rather 'foldl (+) 0 [1..100]' faster?
12:01:58 <mm_freak> mekeor: foldl
12:02:04 <mm_freak> (almost always)
12:02:09 <nand`> mm_freak: Ah, that helps - I actually tried using liftM (:) for about half an hour, I completely forgot that I needed to use liftM2 for functions taking two arguments
12:02:18 <mekeor> mm_freak: and, why? :)
12:02:32 <nand`> mm_freak: Why do you use liftA2 instead of liftM2, and why do you use pure instead of return?
12:02:34 <mm_freak> mekeor: if you're going for speed you should use foldl' instead of foldl
12:03:05 <mbil99> hi folks brand spanking new haskell noob here, could I get a critique and help with a little function?
12:03:10 <mm_freak> mekeor: look at the definition of foldr
12:03:16 <mm_freak> tell me:  is it tail-recursive?
12:03:18 <mbil99> The function Im trying to write works like this, given a list [1, 2, 4, 5] and a number 3, the function should return a list of the number immediately smaller and immediately bigger than 3. So in this case the result would be [2, 4]
12:03:34 <mm_freak> nand`: because that makes a sequenceA, which works for all Applicatives
12:03:43 <mm_freak> nand`: liftM2 works only for those, which are monads
12:03:46 <Peaker> mbil99: sure, show the function?
12:03:50 <mbil99> now I'll let you guys think for a minute to figure out how you would solve it, and then I can show you the function I wrote
12:04:06 <nand`> mm_freak: Oh, I see. No wonder I didn't recognize it, I haven't learned about Applicatives yet - only Monads
12:04:22 <mbil99> now considering that I just figured out how to use "let" and "when" in the past hour, the function is very rudimentary, can basically walk with crutches.
12:04:38 <nand`> Thank you for your help, my problem was trying to use liftM (:seq' xs) x instead of liftM2 (:) x (seq' xs)
12:04:50 <mbil99> so what would be a better way to write it? http://hpaste.org/48678
12:05:47 <mm_freak> mbil99: that's not a good way to write it
12:05:57 <mm_freak> mbil99: i think it's best to use explicit pattern matching and recursion
12:06:18 <mm_freak> myFunc (x0:x1:xs) …
12:06:39 <nand`> mbil99: You should sort the list first
12:07:02 <mm_freak> yeah, and that =)
12:07:34 <Peaker> sort is N*logN, you might want to take the maximum of the smaller and the minimum of the higher
12:07:40 <Peaker> which is O(N)
12:07:46 <mbil99> do you mean sort the list with "n" in it? otherwise sorry the assumption is that xs passed into the function will always be sorted
12:08:25 <mbil99> Peaker ah makes sense
12:09:08 <Peaker> mbil99: what mm_freak was saying is that head/last are unsafe/partial functions -- so you might want to use total pattern matching instead
12:09:24 <Tomsik> but you could do it in 3/2*n-2 time instead 2*n!
12:10:58 <mekeor> mm_freak: foldr is not tail-recursive, right?
12:11:16 <mm_freak> Peaker: no, that wasn't my point
12:11:32 <mbil99> Peaker, sorry I don't understand what kind of patterns would I use?
12:11:36 <monadic> Where can I get the haddock oceanic theme thats used on Hackage?
12:11:57 <mm_freak> mekeor: is that a question, a guess or a statement? ;)
12:12:10 <mm_freak> monadic: that's the new default
12:12:15 <mekeor> mm_freak: :D i don't know, too :D
12:12:15 <mm_freak> get a later haddock
12:12:24 <monadic> mm_freak: In what version? Its probably hardmasked on mine :S
12:12:26 <mekeor> mm_freak: maybe all in one?
12:12:38 <mm_freak> monadic: i've got 2.9.2
12:13:00 <monadic> mm_freak: Yep, hardmasked.
12:13:03 <mm_freak> mekeor: then you have to learn how to figure it out
12:13:05 <bahamas> why does defining this in the REPL raise an error but there's no problem if it's defined in a file? 'doubleUs x y = x*2 + y*2'. putting 'let' in front in the REPL makes the error go away
12:13:30 <monadic> mm_freak: Is there a way to the the theme for a lower version of haddock, though? I know how to unmask, I just want to avoid if necessary
12:13:33 <mm_freak> bahamas: the REPL is like a do-block
12:13:38 <mm_freak> so the let-variant is really the right one
12:13:51 <Peaker> mm_freak: ah, sorry, I thought that's what you meant
12:14:00 <mm_freak> monadic: dunno, sorry
12:14:07 <Peaker> mbil99: well, consider the cases that the smaller/larger lists are empty
12:14:13 <bahamas> mm_freak: sorry, i don't know what you mean by that. it's my first day of haskell. but i'll believe you :)
12:14:20 <monadic> mm_freak: I'll just unmask then.
12:14:50 <mbil99> Peaker yeah currently my function as written barfs if smaller or larger is empty
12:15:16 <mm_freak> bahamas: oh, then don't bother for now =)
12:15:40 <mm_freak> bahamas: you'll eventually learn it, when you learn the syntactic sugar for monads
12:17:10 <bahamas> mm_freak: ok. i think it's going to take a while until i get there. i'm using learn you a haskell
12:17:17 <monadic> mm_freak: Nevermind, requires unmasking of GHC 7 which is something I don't wish to do since it doesn't seem to install correctly for me.
12:17:56 <mm_freak> monadic: i'm using GHC 7 for a while now…  but i'm installing binaries
12:18:39 <mekeor> mm_freak: ok. i think i figured it out, and thus i still say foldr is not tail-recursive.
12:18:43 <monadic> mm_freak: Eh, I have a problem bootstrapping cabal and don't really wish to make it work. I guess I could try to find the .css file
12:19:01 <mekeor> mm_freak: please correct me, if i am wrong :)
12:19:33 <mm_freak> mekeor: i won't tell you, but now check foldl
12:19:50 <mm_freak> monadic: gentoo?
12:19:54 <monadic> mm_freak: Yes.
12:20:19 <monadic> mm_freak: I might check #gentoo-haskell, but I think getting the CSS file is pretty platform-agnostic :)
12:21:13 <mm_freak> i see
12:23:37 <mekeor> mm_freak: foldl is is tail-recursive.
12:23:40 <bahamas> can a statement be an expression as well or is it one way or the other? this book mentions that the if statement is an expression
12:24:41 <mm_freak> mekeor: i think, you just figured out the answer to your original question yourself =)
12:24:45 <monadic> bahamas: No such thing as a statement really
12:25:27 * hackagebot aws 0.0.5 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.0.5 (AristidBreitkreuz)
12:26:34 <xil> hello. I'm trying to create a video file with haskell and having some trouble. I'm wondering if someone can suggest a possible method for doing this that I could try, instead of what I'm currently doing
12:26:35 <xil> @
12:26:41 <xil> s/@//
12:27:15 <bahamas> monadic: ok. so the wording should 'if expression'
12:27:52 <bahamas> xil: you should say what your doing and what's wrong
12:29:31 <xil> the problems I'm having are with ffmpeg. I can't get it to run properly and accept image data via a pipe. Every time I try writing to the pipe haskell gives me a "broken pipe" error. Thing is, I believe that the problem is with the options I used to run ffmpeg. Sadly, I'm not getting any help from people at #ffmpeg
12:33:09 <xil> the reason I'm asking for a different method is because I've talked to a lot of people and spent many many hours on this, and in all that time I didn't pursue other methods...mostly because I couldn't find any. But if there is another way, a library perhaps, then I'd like to try that. Anyone know of anything?
12:39:24 <hpaste> mbil99 pasted “bounding values take2” at http://hpaste.org/48680
12:40:02 <mbil99> woohoo I was able to take care of the empty smaller range/larger range
12:40:15 <mbil99> but this still looks like a pretty crappy function
12:40:33 <mbil99> would some kind soul rewrite it for me in an idiomatic haskell way?
12:40:47 <mbil99> http://hpaste.org/48680
12:41:33 <bgamari> kmc: ping
12:42:03 <mekeor> is fold' not in the Prelude?
12:44:21 <adimit> mekeor: no, foldl' is only in Data.List
12:45:43 <mekeor> can i do ...
12:45:48 <mekeor> @hoogle foldl'
12:45:48 <lambdabot> Data.ByteString foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
12:45:49 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
12:45:49 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
12:45:52 <mekeor> cool :)
13:10:07 <kmc> pong bgamari
13:11:25 <kmc> xil, long ago when i did nonlinear video editing with shell scripts
13:12:00 <kmc> i would output ppm files, one per frame
13:12:07 <kmc> and then convert them to png
13:12:35 <kmc> and run that into mencoder mf://*.png
13:13:51 <xil> kmc: Portable Pixel Map? I don't know what ppm stands for
13:14:06 <kmc> yup, man 5 ppm
13:14:14 <kmc> it is a braindead simple image file format
13:15:33 <xil> kmc: I don't have the man page, but I found the specs online. Thanks, Ill check that out. At least it is better then outputting the RGB data raw to a file and converting after the fact, which is almost what I was going to do....almost
13:16:01 <kmc> PPM is raw RGB data (packed binary or ASCII text)
13:16:08 <kmc> with a tiny simple ASCII header
13:18:03 <xil> kmc: I see...may be a problem then. at about 30 fps, and an image of 640x640, even 30 minutes of video is encroaching on a lot of space
13:18:19 <roconnor> preflex: seen copumpkin
13:18:19 <kmc> yeah
13:18:19 <preflex>  copumpkin was last seen on #haskell-blah 21 hours, 16 minutes and 52 seconds ago, saying: pretty well :) I get just over 1 coin a day
13:18:27 <kmc> you can compress them to png as you go
13:18:57 <xil> kmc: well how were you compressing?
13:19:21 <kmc> i only had a few minutes of video
13:19:26 <kmc> i would compress it to png
13:19:33 <kmc> and then mpeg something for the final result
13:19:33 <xil> but after the fact
13:19:38 <kmc> yeah
13:19:52 <kmc> because my "video editing" was all shell scripts invoking various netpbm filters
13:20:27 <xil> yeah, I'm doing an evolutionary simulaton that needs to run for quite a while, possibly even a couple hours worth of video at least at first when I'm tuning the constants
13:22:25 <xil> here's a question...if I'm allocating about 1MiB for a pointer, should I use malloc or alloca?
13:22:42 <xil> given that I'm going to be doing it again and again every frame
13:23:05 <kmc> oh, is the question "should i allocate once, or many times"?
13:23:13 <kmc> i don't think the size is relevant to deciding between the two
13:23:25 <kmc> in C, alloca is stack allocation, and there's generally a small maximum stack size
13:23:34 <kmc> but in Haskell alloca is just a nice wrapper for malloc
13:24:01 <lispy> hello
13:24:02 <xil> that was the question I meant. Because I was thinking, is it a waste to free up that pointer every time
13:24:25 <lispy> I'm having an issue where ghci hangs.  I'm not even sure how to debug it.
13:24:55 <lispy> I know that when I compile my program and run it it's fun (it's a GUI program) but when I run `main` from ghci, it hangs
13:25:06 <lispy> and I have to force quit (osx) the ghci process
13:25:21 <xil> really alloca is a bit easier because I don't need to pass a pointer to the function
13:25:45 <JuanDaugherty> lispy, conflict with the GUI?
13:25:53 <JuanDaugherty> (whichever one it is)
13:26:12 <lispy> JuanDaugherty: what kind of conflict are you thinking of?  (not sure I follow)
13:26:44 <JuanDaugherty> for the keyboard/console resources for one. There's more than one GUI on mac.
13:27:12 <JuanDaugherty> SFAIK, but prolly out of date, no haskell lib supports the native one
13:27:32 <lispy> JuanDaugherty: hmm...well, the GUI library I'm using is GLFW.  It's a Haskell binding to a C library that calls some of the objective-c GUI stuff
13:27:55 <kmc> xil, assuming your simulation is nontrivial to start with, i don't think malloc'ing a 1MB buffer is going to be a bottleneck
13:28:03 <kmc> GHC's allocator is very fast in general
13:28:04 <JuanDaugherty> sounds broken and/or never tested or meant to run on OSX
13:28:15 <kmc> although i don't know if that applies to the pinned contiguous buffers it uses for malloc
13:28:29 <lispy> xil: are you choosing between alloca/malloc in C or in Haskell?
13:28:36 <JuanDaugherty> or at least under ghci which I would thing was the case for any GUI
13:28:45 <xil> lispy: Haskell
13:28:50 <lispy> xil: GHC's alloca will be faster (but prone to segfaults on large requests)
13:29:00 <kmc> really? why?
13:29:00 <lispy> xil: Much faster than malloc anyway
13:29:17 <lispy> kmc: because the malloc that you call is really C's malloc
13:29:26 <xil> lispy: but I'd only be calling malloc once, whereas I'll be calling alloca many times per second....well....often
13:29:39 <kmc> oh, it is
13:29:59 <kmc> i thought they both used newPinnedByteArray# or whatever
13:30:03 <lispy> xil: alloca just resizes the stack frame (in C at least).  I couldn't actually find the definition that GHC uses for alloca, but I was told it's something fast
13:30:12 <kmc> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.1.0/src/Foreign-Marshal-Alloc.html
13:30:53 <lispy> xil: but, be warned about alloca, due to a bug in GHC the behavior of a large alloca is undefined (actually, it means an uncatchable exception that crashes the RTS)
13:32:03 <kmc> oh, i bet you're supposed to use ForeignPtr if you want memory allocated in the GHC heap which scopes more flexibly than 'alloca'
13:32:39 <lispy> kmc: not sure what you mean, but ForeignPtr just adds a finalizer around a Ptr
13:33:04 <kmc> well alloca uses newPinnedByteArray# and allocates in the GHC heap
13:33:09 <kmc> malloc as you said is just a foreign call to C's malloc
13:33:26 <kmc> so what do i do if i want memory allocated in GHC's heap, but don't want the alloca interface?
13:33:30 <lispy> I'd like to know how newPinnedByteArray# is implemented though
13:33:53 <kmc> does ByteString use the C malloc for allocation?
13:33:56 <kmc> i think it might actually
13:34:15 <lispy> kmc: StablePtr right?
13:34:24 <lispy> kmc: (I didn't mean BS)
13:34:36 <xil> so....should I use malloc then? Since I'll only be calling it the one time?
13:34:44 <kmc> StablePtr is something else entirely
13:35:05 <kmc> it's a "pointer" to a Haskell expression, not to a chunk of memory
13:35:18 <kmc> it's not guaranteed to actually look like a pointer when you pass it to C
13:35:22 <lispy> xil: malloc + finalizer seems quite reasonable and IIRC there is already a function that does that combo
13:35:37 <kmc> or malloc and don't even bother freeing
13:35:40 <geheimdienst> is there any convention about saying "IO a" versus "IO alpha"? as seen here http://hackage.haskell.org/packages/archive/unbounded-delays/0.1.0.1/doc/html/Control-Concurrent-Timeout.html
13:35:45 <kmc> if it lives as long as your program
13:35:53 <xil> it will live as long as the program
13:35:54 <geheimdienst> or is it just that the guys like greek
13:35:59 <kmc> geheimdienst, i think it's just misc unicode wankery
13:36:31 <kmc> lispy, the only guarantees on StablePtrs are that you can pass them through C as a void* and use deRefStablePtr in Haskell to get the original value
13:36:40 <kmc> it's undefined what happens if you try to use that void* in C
13:36:51 <lispy> xil: checkout the malloc* functions here at the bottom: http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.1.0/Foreign-ForeignPtr.html
13:36:51 <geheimdienst> kmc: that's what i suspected :)
13:38:21 * lispy wonders about how to debug this GHCI hang
13:38:34 <lispy> I wonder if threadscope would shed any light
13:40:14 <xil> lispy: ultimately I need a Ptr in the end, not a ForeignPtr. Do you recommend I use the ForeignPtr and extract it's Ptr from it?
13:40:43 <accel> I know how to use the state monad. I know how to use the reader monad. I want to use a reader monad in a state monad. What is an intense/painful/hardway intrudction to state transformers ?
13:40:58 <kmc> i think you mean 'monad transformers'
13:41:07 <kmc> *shrug* All About Monads covers them
13:41:11 <accel> yes, I meant monad transformers.
13:41:27 <kmc> or just look at the API docs at http://hackage.haskell.org/package/transformers
13:41:32 <lispy> I wonder if this is what I'm hitting: http://web.archiveorange.com/archive/v/nDNOvMeDATtTGn026lbI
13:41:34 <JuanDaugherty> *think
13:41:36 <kmc> there's not much to it, really
13:41:49 <kmc> @unmtl StateT s (Reader r) a
13:41:49 <lambdabot> s -> r -> (a, s)
13:41:55 <kmc> @unmtl ReaderT r (State s) a
13:41:56 <lambdabot> r -> s -> (a, s)
13:42:03 <kmc> in this case the order does not matter
13:42:11 <kmc> because ReaderT commutes with other monad transfomers in a stack
13:42:36 <lispy> xil: Well, extracting the Ptr from a ForeignPtr is trivial.  The advantage to using the ForeignPtr is that if you later refactor your program you'll already have memory management in place
13:42:50 <kmc> accel, alternatively, instead of screwing around with monad transformers and the clunky APIs that you get
13:42:54 <kmc> just implement the monad you want directly
13:43:00 <lispy> ?hoogle withForeignPtr
13:43:01 <lambdabot> Foreign.ForeignPtr withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b
13:43:04 <accel> I actually want to understand monad transformers.
13:43:21 <accel> Is "All About Monads" available in HTML rather than pdf? google only gives me pdf, and the pdf is clearly from a HTML, but the pdf links aren't clickable.
13:43:37 <kmc> i think writing your own monad from scratch is often simpler
13:43:42 <xil> lispy: right, that's the type of answer I was looking for, thanks =]
13:44:04 <kmc> as long as you understand how State and Reader are implemented
13:44:40 <kmc> whether or not i'm using transfomers, i tend to put my custom monad in a newtype and only expose certain domain-specific "primitives" to the rest of the program
13:44:54 <kmc> if all your code all over is full of "lift get" or whatever, that's just awful
13:47:02 <luite> unfortunately it's more difficult to remove the liftIO's
13:47:21 <kmc> you bake them into your primitives, same as anything else
13:47:47 <accel> hmm
13:47:50 <kmc> does your program really need to do arbitrary IO within your custom monad
13:47:54 <kmc> i think the hardest part to understand about monad transfomers is just the kind of polymorphism involved
13:48:14 <kmc> a monad transfomer is a type constructor which takes a type constructor (a monad) and returns another type constructor
13:48:18 <kmc> :k StateT Int
13:48:19 <lambdabot> (* -> *) -> * -> *
13:48:19 <luite> kmc: dunno about that, would you make a liftIO'd version for everything you use, like a liftIO readFile?
13:48:39 <kmc> luite, i've not worked on projects where this is an issue
13:48:47 <slavik1> what is the recommended compiler for a newbie in haskell world?
13:48:52 <kmc> GHC
13:48:59 <kmc> and its interactive environment, ghci
13:49:07 <kmc> GHC is by far the most popular Haskell compiler
13:49:09 <luite> hmm, all my recent projects had the application monad some instance of MonadIO
13:49:10 <slavik1> do I got for ghc7 or is ghc6 fine?
13:49:22 <kmc> not a huge difference but i'd go with the latest unless you have a reason not to
13:49:34 <kmc> ghc7 lets you do "import qualified" in ghci which could be very nice when learning
13:49:40 <slavik1> kmc: ubuntu repo have ghc6, ghc7 not listed
13:49:47 <slavik1> I see
13:49:52 <arw__> slavik1: if you have no idea, just use haskell platform or whatever your distro ships.
13:50:31 <slavik1> ghc6 it is
13:50:33 <slavik1> thank you
13:50:40 <kmc> :)
13:53:38 <hpaste> “Ben Gamari” pasted “And more GC churn” at http://hpaste.org/48681
13:54:02 <bgamari> kmc: I implemented your (I hope it was yours) suggestion regarding Data.Binary serialization
13:54:17 <bgamari> kmc: Resulting in, naturally, more GC churn
13:54:39 <bgamari> kmc: Which I suspect may be due to the fact that the writes are now done sequentially
13:54:57 <bgamari> kmc: e.g. First I write out the donor time byte string
13:55:31 <bgamari> kmc: Forcing the acceptor byte string to be built
13:56:16 <bgamari> Rather, not the byte string but the list of put actions for the acceptor byte string
13:56:29 <bgamari> Any way around this that you can think of?
13:56:41 <bgamari> Be back in 15 minutes
14:08:12 <gwern> @quote cannot.proceed
14:08:13 <lambdabot> No quotes match.
14:08:19 <gwern> @quote proceed
14:08:19 <lambdabot> No quotes match. You untyped fool!
14:11:14 <gwern> @remember AlanPerlis One can't proceed from the informal to the formal by formal means.
14:11:14 <lambdabot> It is stored.
14:11:39 <adimit> gwern: I disagree. c.f. NLP.
14:11:49 <gwern> adimit: I disagree with you. see NLP.
14:12:06 <adimit> … well, that's a matter of debate, even among NLPers.
14:12:14 <adimit> You can formalize (fragments of) informal stuff.
14:12:20 <gwern> then perhaps you should find better grounds for disagrement
14:12:50 <adimit> well, "better"… I do think natural language can be formalized.
14:13:17 <ccc> pacman -Syu
14:13:21 <adimit> But you're not alone in thinking it's not possible. It is definitely possible to formally define a fragment of, say, English, and formalize that completely.
14:13:28 <adimit> (however.)
14:14:23 <monadic> adimit: Thats formal -> formal via formal means
14:15:32 <adimit> monadic: Why would you say that? It's not like that fragment of English isn't observable as part of an informal entity.
14:16:14 <adimit> if you restricetd English to this fragment alone, it would not be formal without a formalization (that happened by formal means.)
14:21:27 <adimit> (BTW, I think just the restriction of English to a fragment alone is already formalizing something informal by formal means.)
14:24:53 <xil> I keep getting "Broken pipe" errors when trying to use hPutBuf on a handle I got from runInteractiveProcess. Could someone take a look at my call to runInteractiveProcess and tell me if I'm doing it right?
14:24:57 <hpaste> xil pasted “runInteractiveProcess code” at http://hpaste.org/48682
14:29:31 <kmc> xil, can you use strace to debug it?
14:29:53 <xil> what is strace?
14:30:07 <kmc> http://linux.die.net/man/1/strace
14:31:03 <xil> kmc: should I just do "strace runhaskell ..."?
14:31:24 <kmc> and/or strace ffmpeg inside your invocation
14:31:39 <kmc> you probably have to know a fair amount about UNIX for this to be useful
14:32:11 <arw__> usually you want something like 'strace -f -o /tmp/strace.output <program to be traced>'
14:32:35 <gwern> @flish
14:32:53 <xil> well I ran it and got some output
14:32:56 <arw__> -f follows possible forks and -o redirects the output of strace, because otherwise it would get very slow and possibly unusable because you won't see normal program output
14:32:58 <geheimdienst> did you mean: @fish
14:33:06 <gwern> geheimdienst: @go
14:33:28 <xil> arw__: I'll try it with those again
14:34:59 <arw__> somewhere around the end of the strace output you should see some SIGPIPE beeing received. above that there should be some I/O syscall like read() or write() which fails due to the broken pipel.
14:35:00 <xil> so...I don't know how to interpret this. Should I ask over at a linux channel? I know some good people in #archlinux (I'm an Arch guy)
14:35:03 <arw__> -l
14:35:11 <xil> arw__: ah, let me check
14:36:26 <arw__> the first argument of that read or write is the file descriptor. with that you can try to track the usage of that file descriptor and e.g. see if somebody closes it or if there is a problem when opening it.
14:37:56 <arw__> the "opening" it part can either be an open()-syscall that returns that exact fd number. or it can be something like socket/socketpair/accept which does something like open for network communication
14:38:25 <xil> arw__: found the broken pipe line
14:38:27 <arw__> but the details are somewhat more complicated and you might need somebody with some background in unix system programming...
14:40:31 <merijn> That's my queue?
14:40:57 <xil> arw__: okay...I see the stop where it tries to do the runInteractiveProcess. It's looking for ffmpeg in a bunch of directories, I would imagine on my PATH? But each one fails
14:42:21 <merijn> Do you know which process is exiting with SIGPIPE, the ffmpeg process or your own?
14:42:38 <bgamari> kmc: no ideas?
14:43:05 <kmc> no
14:43:13 <bgamari> bummer
14:43:20 <bgamari> Does my explanation sound plausible?
14:43:30 <xil> arw__: could it be that my runInteractiveProcess call in written incorrectly?
14:43:37 <arw__> xil: depends, just look at your path with 'echo $PATH'. if ffmpeg is nowhere in there, try adding the directory where it resides with 'export PATH=$PATH:<somewhere>'
14:43:53 <merijn> xil: Do you know which process is exiting with SIGPIPE? The ffmpeg process or your own?
14:44:17 <xil> arw__: I did "locate ffmpeg" and it's in /usr/bin which is one of the ones tried in that list of failures. Yet it still failed
14:44:21 <arw__> xil: could be, don't know. it could also be something else. try answering merijn's question.
14:44:25 <bgamari> It really seems like what I need to do can't be done without some major contortions
14:44:32 <bgamari> i.e. putting the algorithm in the IO monad
14:44:36 <xil> merijn: uh....let me check. There are a couple SIGPIPEs
14:45:21 <merijn> If you run the ffmpeg command manually (i.e. from the shell where you would run the haskell code) does it work?
14:45:33 <arw__> xil: if the file exists but some syscall failed, its possible that you have no permissions on that file.
14:46:43 <xil> arw__: but I tested it numerous times in a terminal, without su or sudo, so I could figure out the proper arguments
14:46:56 <xil> merijn: yes. I've done it several times
14:47:10 <merijn> xil: How quickly does it exit? Immediately?
14:47:22 <xil> merijn: the Haskell program?
14:47:32 <merijn> ffmpeg. Also, does it produce output?
14:50:35 <xil> merijn: well...I run ffmpeg to take input from stdin, so it exits when I want it to. And it does produce output while I work with it
14:51:38 <xil> well...really the only way I've found to exit from ffmpeg on the cli is ^C ^D ^D Enter
14:51:39 <merijn> Hmm, I don't have time to stay around and debug it right now. You could try replacing the default SIGPIPE handler in your haskell code with one that doesn't exit your program on SIGPIPE
14:51:46 <xil> which doesn't seem legit, but it works safely
14:52:11 <xil> merijn: I will look into that, thanks
14:52:13 <arw__> xil: ^D should be the right way to kill stuff that waits for input on stdin
14:52:15 <merijn> System.Posix.Signals.installHandler will let you change the SIGPIPE handler
14:52:41 <arw__> xil: could you hpaste the strace output? might be easier to see stuff when I look at it.
14:52:42 <merijn> You can just install a function which does nothing for example. It's just that the default behaviour for almost all signals is to crash the program :p
14:52:44 <xil> arw__: you should think, and yet it doesn't, but in this case I might understand since it's interpreting everything I give it as image data
14:52:52 <xil> arw__: sure, just a sec
14:52:56 <merijn> Anyhoo, good luck and good night :)
14:54:04 <hpaste> xil pasted “strace” at http://hpaste.org/48683
14:57:03 <xil> arw__: if you search for ffmpeg you'll see a block of execve calls that all fail
14:57:42 <geheimdienst> xil: i guess you're mixing up system and rawSystem
14:57:45 <geheimdienst> @hoogle rawSystem
14:57:46 <lambdabot> No results found
14:57:49 <arw__> xil: oh
14:57:50 <geheimdienst> *grrr*
14:57:55 <arw__> xil: 12068 execve("/usr/local/bin/ffmpeg -an -f rawvideo -pix_fmt rgb24 -s 640x640 -i - -r 30 -y fneatout.mp4", ["ffmpeg -an -f rawvideo -pix_fmt "...], [/* 37 vars */]) = -1 ENOENT (No such file or directory)
14:57:57 <xil> arw__: right above those calls is a call to "close(11)" and the broken pipe error is caused on a "write(11...)" way later
14:58:22 <arw__> xil: thats your problem right there: its not looking for a binary named '/usr/local/bin/ffmpeg'
14:58:38 <xil> okay.....
14:58:39 <arw__> xil: its looking for a binary named '/usr/local/bin/ffmpeg <long list of parameters'
14:58:48 <geheimdienst> yeah, that's what i mean
14:58:52 <xil> well did you see my call to runInteractiveProccess?
14:58:58 <xil> geheimdienst: do you know how to fix?
14:59:19 <geheimdienst> xil: check those. http://haskell.org/ghc/docs/latest/html/libraries/process/System-Cmd.html
14:59:29 <xil> I thought that I was making a mistake like that, but I don't know because I don't see examples for runInteractiveProcess
14:59:45 <geheimdienst> the one is that you call using rawSystem "ffmpeg" ["-switch", "-switch", "param"]
15:00:04 <geheimdienst> the other you call by saying: system "ffmpeg -switch -switch param"
15:00:29 <geheimdienst> the latter does splitting on whitespace for you. it's a little more magic and error-prone, but occasionally you want that
15:00:37 <arw__> xil: i did see your call to runInteractiveProcess, it looked fine to me. that behaviour of it is surely surprising (and I would call it buggy)
15:00:42 <xil> geheimdienst: but I'm doing: runInteractiveProcess "ffmpeg" ["-switch","-switch","param"] Nothing Nothing
15:00:43 <geheimdienst> i think runInteractiveProcess and the like are similar
15:01:41 <xil> so...is there another way for me to get my hands on a pipe to ffmpeg? Could I perhaps pipe the stdout from my program into ffmpeg, but outside of the program?
15:01:47 <geheimdienst> xil: uh, that's interesting. have you pasted the haskell code somewhere?
15:01:57 <xil> geheimdienst: yes...one sec
15:02:08 <xil> http://hpaste.org/48682
15:03:30 <xil> the thing I'm afraid of with doing something like "runhaskell fNEAT | ffmpeg ..." is that I'm sending many MBs of data through that pipe. Is that the same as doing it internally? Something makes me feel like piping that way does text conversion first and I don't want that
15:04:29 <arw__> usually no sane unix program should do any text conversion on stdin/out. thats only common on windows.
15:04:45 <trygvis> piping is very efficient and it is byte-oriented
15:05:20 <geheimdienst> anyway, what i find mighty weird is those lines repeating ffmpeg in a string AND and array like this: execve("/usr/bin/vendor_perl/ffmpeg -an -f rawvideo -pix_fmt rgb24 -s 640x640 -i - -r 30 -y fneatout.mp4", ["ffmpeg -an -f rawvideo -pix_fmt "...], [/* 37 vars */]) = -1 ENOENT (No such file or directory)
15:05:27 <arw__> and letting the shell create the pipe is as efficient as doing it internally with runInteractiveProcess. give or take a few cycles.
15:06:04 <xil> well let me give it a shot then. I access the handle to my Haskell programs stdout with "stdout"? So something like: hPutBuf stdout somePtr someInt
15:09:44 <geheimdienst> xil, have you looked at the output ffmpeg puts on its stderr? i suspect it will write complaints that "-f rawvideo" is not a proper argument, it should be "-f" "rawvideo" and such
15:10:12 <xil> geheimdienst: let me see...
15:16:36 <xil> geheimdienst: indeed you're right, but it's not quite what you said
15:16:47 <xil> geheimdienst: it says "unrecognized option "f rawvideo"
15:16:53 <xil> without the hyphen
15:17:24 <geheimdienst> well yeah. if you said "ffmpeg -doodle", it would tell you: unrecognized option "doodle"
15:17:27 <geheimdienst> :)
15:17:35 <xil> oh
15:17:52 <xil> so should I change my argument list to separate switches from their values?
15:18:50 <geheimdienst> yeah, that's the same case here, it treats "f rawvideo" as one argument that just happens to contain a space somewhere
15:19:25 <geheimdienst> > words "-an -f rawvideo -pix_fmt rgb24 -s 640x640 -i - -r 30 1.1.mp4"
15:19:26 <lambdabot>   ["-an","-f","rawvideo","-pix_fmt","rgb24","-s","640x640","-i","-","-r","30"...
15:19:46 <geheimdienst> this might make it less tedious to write out all those args
15:20:18 <xil> yeah that's what I did, haha
15:20:32 <xil> and ffmpeg doesn't error
15:21:00 <xil> this time it doesn't break immediately, but it does eventually break
15:21:56 <pedro3005> @hoogle replace
15:21:56 <xil> is there a way to fork a thread that will just always try to put ffmpeg's stderr to the stdout?
15:21:56 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
15:21:56 <lambdabot> System.FilePath.Posix replaceBaseName :: FilePath -> String -> FilePath
15:21:56 <lambdabot> System.FilePath.Windows replaceBaseName :: FilePath -> String -> FilePath
15:22:29 <pedro3005> that first one looks exactly like what I want but why is it in network.cgi.protocol? lol
15:23:21 <geheimdienst> pedro3005: try the one in missingH
15:24:03 <elliott_> Is it possible to have a repa array of Integers?
15:24:05 <Peaker_> Xil: why not 2>&1?
15:24:10 <elliott_> It's not an instance of Elt, and integers can't really be unboxed.
15:24:19 <monadic> :q
15:24:23 <monadic> ahh this isn't vim
15:24:38 <geheimdienst> xil: i believe rawSystem from System.Cmd will help you
15:25:01 <kmc> elliott_, interesting idea
15:25:10 <kmc> you could "semi-unbox" them
15:25:49 <xil> Peaker_: inside Haskell, not on the terminal
15:25:56 <geheimdienst> schrödinger's integers are in a semi-unboxed state!
15:26:02 <kmc> have an array of things which are either unboxed machine ints or pointers to bignums
15:26:10 <kmc> with a tag bit each
15:26:12 <xil> geheimdienst: how does rawSystem help?
15:26:14 <elliott_> kmc: eurgh
15:26:18 <elliott_> I just want something simple :P
15:26:22 <kmc> implementing this would require some GHC hacking, though
15:26:46 <geheimdienst> it outputs the stderr by default. with runInteractiveProcess, it's extra work to get at the stderr contents
15:27:53 <Peaker_> Probably possible to fork a child process, dup2 on stderr...
15:29:49 <xil> geheimdienst: but I need the pipe to stdin that runInteractiveProcess gives me. That's why I'm using it
15:30:47 <xil> geheimdienst: I got it to work though. I mean...I ran it again and it worked, so....well....it sort of works. It doesn't break and it does record, but the resulting video is messed up. That's a different problem though, haha
15:32:01 <geheimdienst> about not being able to use rawSystem: okay i see. (sorry, haven't followed the entire conversation). then i'd definitely add code to check stderr ...
15:32:08 <geheimdienst> hang on
15:33:10 <hpaste> geheimdienst pasted “runinteractiveprocess” at http://hpaste.org/48684
15:33:30 <geheimdienst> try something like that. it has served me well :)
15:33:47 <geheimdienst> (the function strip is from missingh. it's not essential)
15:36:05 <xil> geheimdienst: it's no problem, I've said a lot today, haha. I wrote some small little thing I fork that just forever checks if there's anything on the strerr and if so outputs. I'll hold on to your code though because then I clean this all up when it's finally done I'll want something a bit more legit than this little thing
15:42:43 <geheimdienst> xil, if i can give you any tip at all -- add the error output rightaway. it's really only a few lines, and it can save you hours of debugging :) nothing is as evil as suppressed error messages
15:44:06 <Peaker_> The Zen of Python is mostly good, saying: errors should never pass silently, unless explicitly silenced...
15:44:10 <zmoazeni> Hi there guys. I'm slowly picking up haskell, and came across this glut example: http://code.haskell.org/GLUT/examples/OrangeBook/ogl2brick/Brick.hs - could someone explain the semantics behind "$=". I'm hard pressed to find information about it.
15:45:00 <cmccann> zmoazeni, $= is defined in a library used by the OpenGL bindings
15:45:12 <kmc> zmoazeni, it's an overloaded operator which assigns to mutable reference cells
15:45:18 <kmc> IORef and OpenGL state thingys and maybe others
15:45:26 <cmccann> in general terms it's for assign values to mutable references, as kmc says
15:45:29 <elliott_> I really dislike the OpenGL bindings :(
15:45:35 <Peaker_> It's an ad-hoc assignment operator for opengl state vars iirc
15:45:39 <cmccann> in practice I've never seen it used except for poking values into OpenGL
15:45:40 <elliott_> although, that is probably just me disliking OpenGL in general.
15:45:53 <kmc> i think the OpenGL bindings are fine
15:46:00 <zmoazeni> Thanks cmccann and kmc - I was trying to figure out if it was an infix operator. Checking into ghci, I couldn't get any information from ":info $="
15:46:15 <elliott_> kmc: they're probably the best a Haskell binding to the OpenGL API can be, it's just that that API is kind of terrible.
15:46:23 <kmc> you can't expect something describing itself as "OpenGL bindings" to be a pure functional declarative 3D engine based on co-functorial turbo arrows
15:46:31 <kmc> that's another layer up
15:46:33 <cmccann> note that OpenGL, especially the oldschool style, is essentially a huge state machine, so an operator for setting state values makes a lot of sense. In Haskell in general, it's not very useful
15:46:46 <zmoazeni> Oh wait, I just found it. I had to "import Graphics.UI.GLUT" first before I could ":info" it
15:46:50 <kmc> i've also heard the complaint that the OpenGL library is too *high-level*
15:46:53 <elliott_> GLUT :(
15:46:59 <elliott_> kmc: haha, really??
15:47:00 <kmc> but if you really want the OpenGL C API you can use OpenGLRaw
15:47:08 <kmc> elliott_, yes, people want to use C API docs with it
15:47:20 <cmccann> zmoazeni, see here: http://hackage.haskell.org/package/StateVar
15:47:30 <elliott_> kmc: considering that even begin/end is deprecated, I can't think of any non-deprecated way to use the OpenGL binding that doesn't directly translate to C nowadays
15:47:34 <zmoazeni> I wasn't particularly interested in OpenGL, just poking around the code and that syntax caught me offguard.
15:47:38 <elliott_> I mean, it uses raw (Ptr a)s!
15:47:51 <elliott_> zmoazeni: It's not syntax -- it's just another operator. (This applies to most "syntax" in Haskell.) :)
15:48:18 <zmoazeni> elliott_: Thanks for the correction. I'm fumbling over the terminology starting out.
15:48:34 <cmccann> zmoazeni, yeah, keep in mind that lazy evaluation + defining your own infix operators = lots of stuff that looks like "syntax" is just a library
15:48:47 <elliott_> zmoazeni: It's a common misconception that Haskell has a lot of syntax or a busy non-minimalist syntax, or whatever.
15:48:56 <elliott_> zmoazeni: Actually it is almost all just operators that you yourself could define.
15:49:05 * cmccann actually can't think of any truly baked-in infix operators off the top of his head, other than maybe (->)
15:49:20 <elliott_> Lazy evaluation lets you implement control structures without resorting to language extension facilities, so it's sometimes hard to tell what's syntax and what's not, for a newbie.
15:49:27 <elliott_> At least that's my perception.
15:49:45 <cmccann> where by baked in I mean "can't be replaced using GHC's rebindable syntax"
15:53:08 <zmoazeni> As far as crawling in the source code of cabals, is there a more efficient method than finding the tarball in ~/.cabal copying it to a tmp dir and unpackaging it? I'm coming from the ruby world and there are packages like gemedi and open_gem that will do some of that tedious work for you.
15:53:19 <zmoazeni> *gemedit
15:53:42 <cmccann> zmoazeni, you can use "cabal unpack" to do the first few steps
15:53:47 <zmoazeni> cmccann: Thanks
15:53:58 <cmccann> that will fetch and unpack the tarball in the current directory, I think
15:54:15 <geheimdienst> yeah, and it's pretty painless. cabal unpack is nice
15:54:31 <zmoazeni> Yup, that's good enough. Thanks.
15:54:36 <cmccann> also, most libraries have their source viewable from http://hackage.haskell.org/, so doing a google search on "site:hackage.haskell.org" can be pretty effective
15:55:06 <cmccann> at a higher level, there's a couple search engines for looking up functions
15:55:33 <zmoazeni> Right on. I just came across http://haskell.org/hoogle/ earlier today
15:55:57 <geheimdienst> @where hayoo
15:55:57 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
15:56:05 <cmccann> "Hayoo" linked from the Hackage page searches all of hackage in a relatively simpleminded way, and Hoogle (which you've already found apparently) searches types by a more abstract notion of similarity
15:56:11 <xil> geheimdienst: oh I did add error output. I was just saying that I'm going to save your code extra because it looks great, so that I can use it right out of the box sort of thing on future projects
15:56:24 <geheimdienst> hayoo is much more complete. i like it better than hoogle
15:56:47 <geheimdienst> xil, good thinking :)
15:56:49 <Peaker_> I wish hoogle indexed all the libs or alternatively that Hayoo! used hoogle's engine..
15:56:50 <cmccann> Hayoo is a less clever search algorithm, but I think it indexes all of Hackage
15:57:04 <cmccann> Hoogle is much nicer, but only searches some standard libraries I think
15:57:15 <shachaf> Clearly someone needs to create Hayoogle.
15:57:24 <geheimdienst> cmccann: "some" being the operative word, unfortunately ...
15:57:52 <geheimdienst> but i think they're working on expanding hoogle coverage
15:58:13 <Peaker_> It's not hard to add more indices to Hoogle. Just a matter of running the indexing process upon new package releases
15:59:03 <shachaf> Wy does `cabal unpack base` only give me base 3?
15:59:10 <shachaf> s/./Wh/
15:59:20 <cmccann> anyway, can't you install hoogle locally and index whatever you like? there's always that.
15:59:27 <cmccann> can even get GHCi integration, I think
16:00:02 <geheimdienst> shachaf: checked your preferred-versions file?
16:00:53 <shachaf> Oh, cabal defaults to base-3 because old packages didn't use to specify versions?
16:02:25 <shachaf> Hmm, where is this preferred-versions file?
16:03:05 <zmoazeni> Since I'm asking questions, I'll throw one out there about Monads (with respect, I'm sure you guys answer these all day). I'm getting that the monad concept is a lot simpler than it's perceived. And the "do"/"<-" desugaring is beginning to click in my head (effectively chaining functions together)....
16:03:11 <shachaf> Aha, ~/.cabal/packages/hackage.haskell.org/00-index.tar
16:03:16 <zmoazeni> ... But regarding the IO monad vs other monads. My brain interprets IO monadic actions as "recording to be played later" (e.g. putStrLn "Hello World"). Does the haskell runtime trigger the "ok, run now through the IO actions "? Are there other Monads where the actions are "stored" and replayed or is this all a consequence of lazy evaluation?
16:03:31 <kmc> zmoazeni, you've got a lot of the key ideas there
16:03:49 <kmc> yes, the GHC RTS is effectively what's responsible for actually executing the IO actions you described
16:04:04 <kmc> no, it's not lazy evaluation -- you can force evaluation on an IO action with "seq" and still no IO occurs
16:04:08 <kmc> evaluation ≠ execution
16:04:15 <zmoazeni> gotcha
16:04:18 <kmc> yes, IO is a special case among monads
16:04:32 <kmc> the fact that IO is a monad is only incidental to how it works
16:04:47 <kmc> you could just have «returnIO :: a -> IO a» and «bindIO :: IO a -> (a -> IO b) -> IO b»
16:04:52 <kmc> you might call this "continuation-passing IO"
16:05:09 <shachaf> Or you could just pass the continuations directly to IO primitives.
16:05:43 <shachaf> For that matter, you wouldn't even need "IO a", would you? Just an opaque type "IO".
16:06:00 <kmc> probably so
16:06:24 <kmc> zmoazeni, as for other monads where actions are stored and replayed -- that's a question of viewpoint more than anything else
16:06:31 <hpaste> fxr pasted “Crypto.hash.md5 problem” at http://hpaste.org/48685
16:07:02 <fxr> I have this kind of problem with cryptohash
16:07:05 <shachaf> You can look at every instance of Monad that way.
16:07:13 <_Ray_> Newbie question. In the Functor class, what would be the mathematical equivalent of the restriction "fmap (g . h) = fmap g . fmap h"? Say I have categories A, B, and a functor F: A -> B.
16:09:10 <zmoazeni> shachaf, kmc By "You can look at every instance of Monad that way." do you mean by viewing all monadic actions as stored/replayed? If so, what is the trigger to "begin playing" the actions?
16:09:23 <kmc> well, take State as an example
16:09:25 <kmc> @unmtl State s a
16:09:25 <lambdabot> s -> (a, s)
16:09:29 <zmoazeni> (That may be on a case by case basis)
16:09:31 <kmc> @src State (>>=)
16:09:31 <lambdabot> Source not found.
16:09:35 <kmc> hrm
16:09:38 <kmc> well anyway
16:09:54 <kmc> «State s a» is just a wrapper on a function from old state to new state
16:10:00 <monochrom> yes, different monads require different "play"s
16:10:03 <kmc> when you combine them with (>>=) you are just composing these functions in some way
16:10:08 <kmc> then you call runState to actually pass in the 's'
16:10:13 <kmc> at which point you can evaluate the final result 'a'
16:10:22 <kmc> (it doesn't happen immediately because it's still lazy)
16:10:50 <shachaf> @unmtl (b -> State s c) -> (a -> State s b) -> a -> State s c
16:10:50 <lambdabot> (b -> State s c) -> (a -> State s b) -> a -> State s c
16:10:59 <shachaf> Hmm, @unmtl isn't very smart, is it.
16:11:07 <accel> http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors <-- what are the big difference between 1, 7, & 8? I'm tempted to just use "1" for now; but what is the "right way" to handle exceptions in haskell?
16:11:22 <accel> http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors <-- what are the big difference between 1, 7, & 8? I'm tempted to just use "1" for now; but what is the "right way" to handle exceptions in haskell? [most of my exceptions are IO related ... i.e. calling of external programs; I don't like the idea of passing around Maybe's]
16:12:35 <benmachine> passing around maybes is a pretty good idea
16:12:41 <_Ray_> Oh, that if g: Y -> Z and h: X -> Y are morphisms in A, then F(g o h) = F(g) o F(h), where F(g): F(Y) -> F(Z), and F(h): F(X) -> F(Y).
16:12:45 <accel> i want the program to die on the first error
16:12:48 <accel> and print out a msg
16:13:23 <mike-burns> Maybe is an instance of Monad.
16:13:28 <mike-burns> This is what makes it awesome.
16:13:49 <mike-burns> Oh they mention that.
16:14:22 <_Ray_> (Re-reading typeclassopedia after taking abstract algebra :))
16:14:24 <Peaker_> Accel: I like using Either when possible. Io exceptions are fine and very easily translatable to Either and back
16:14:30 <accel> hmm
16:14:32 <accel> I really like method 6
16:14:39 <accel> how deos throwDyn and "throw" differ?
16:15:00 <benmachine> accel: I think that article is quite old
16:15:08 <benmachine> and was written before the current throw and catch became popular
16:15:20 <accel> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html <-- is a bit hard to read
16:15:25 <accel> is there examples on how to use Control.Exception ?
16:16:17 <accel> http://book.realworldhaskell.org/read/error-handling.html is what I want
16:16:19 <accel> victory
16:16:22 <benmachine> accel: there are a few in that page you just linked :P
16:16:26 <benmachine> (the doc page I mean)
16:16:56 <_Ray_> Hrm. If functors can "transport" both morphisms and objects, but Functor in Haskell only requires the definition of fmap, how could a Haskell Functor transport objects from one category to another?
16:16:57 <accel> i couldn't see them in all the complexity they were buried in
16:17:18 <accel> actually; I still dont's ee them
16:17:19 <accel> which section?
16:17:30 <geheimdienst> :t throw
16:17:31 <lambdabot> Not in scope: `throw'
16:17:39 <geheimdienst> ^^ sometimes i wonder ...
16:17:42 <benmachine> accel: they're scattered about, for example there's one in the docs for catchJust
16:17:50 <benmachine> :t Control.Exception.throw
16:17:50 <lambdabot> forall e a. (GHC.Exception.Exception e) => e -> a
16:17:52 <ddarius> _Ray_: The objects of the relevant "category" are Haskell types.  The action on objects is the type constructor, e.g. taking a to [a].
16:18:12 <_Ray_> Oh, so that part of being a functor is already taken care of by the syntax of being a type constructor.
16:18:15 <geheimdienst> benmachine: thanks, although i find that a little strange
16:18:53 <benmachine> geheimdienst: what's a little strange?
16:19:13 <_Ray_> Nice, OK, so [*] is a functor that takes a type to a type, which is an object in the category Hask to another such object.
16:19:37 <cmccann> _Ray_, do keep in mind that the Functor type class is nowhere near general enough to describe all functors in the categorical sense
16:20:16 <_Ray_> Well, it seems like it's describing endofunctors of Hask, is it not?
16:20:29 <cmccann> yes, but that's still too general
16:21:07 <cmccann> a type constructor f maps all types in Hask to a subcategory of Hask whose objects are all types of the form "f a"
16:21:17 <geheimdienst> benmachine: oh just which things are available in lambdabot, and which aren't, and which if you give the qualified name
16:21:29 <benmachine> geheimdienst: oh, right, yes
16:21:35 <_Ray_> Oh, that is right. A true functor could map types as diverse as Integer to Char.
16:21:46 <benmachine> :t catch
16:21:47 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
16:21:48 <benmachine> geheimdienst: might be to prevent name clash with Prelude
16:21:58 <geheimdienst> :t Prelude.throw
16:21:59 <lambdabot> Not in scope: `Prelude.throw'
16:22:00 <cmccann> _Ray_, so it's not possible to describe, say, an endofunctor between arbitrary types in Hask, or between distinct subcategories of Hask
16:22:07 * geheimdienst scratches his head
16:22:20 <_Ray_> Aww. Well, it still looks like it's plenty powerful :) Thanks!
16:22:40 <benmachine> geheimdienst: tbh you don't often need to use lambdabot to do exception handling anyways :)
16:23:24 <cmccann> and because Haskell compresses everything vaguely morphism-like into polymorphic functions, the morphism half of the functor ends up just being a family of morphisms in Hask anyway
16:23:28 <cmccann> it's all very confusing really
16:23:55 <kmc> yes, it is funny that people think they need to learn category theory to learn Haskell, when Haskell kind of makes a mess of all the CT concepts
16:24:12 <djahandarie> You should see what the categorical model of Arrows is
16:24:22 <djahandarie> (You shouldn't unless you want your eyes to bleed out)
16:24:41 <cmccann> since in the type signature for fmap :: (a -> b) -> f a -> f b, two of the function arrows are the morphisms acted on by the functor, while the third is the functor itself
16:24:45 <geheimdienst> oh yes Arrows, pinnacle of comprehensibility >_>
16:24:46 <_Ray_> I started learning Haskell without knowing that stuff, and I had to force-feed myself notions like Pointed, Arrow, or Monoid. With a bit of abstract algebra, these stop being scary :)
16:25:05 <_Ray_> And the old joke of "A monad is just a monoid in the category of endofunctors. What's the problem?" actually starts making sense :)
16:25:24 <cmccann> the Arrow type class describes arrows in some not terribly well-defined manner of category
16:25:39 <cmccann> this differs form the Category type class, which describes arrows in generic categories
16:25:46 <cmccann> this is not at all confusing, of course
16:26:22 <geheimdienst> kmc, what we could do is move some modules. if Control.Category was AbstractNonsense.Control.Category that would be a start
16:26:29 <kmc> :D
16:26:31 <_Ray_> Would you say there's more of a distance from 1+1 to the concept of monad, or from the concept of monad to the concept of a coyoneda functor?
16:26:43 <kmc> whose 1+1?
16:26:46 <kmc> Russell and Whitehead's?
16:26:50 <_Ray_> heh
16:27:00 <_Ray_> Let's say primary school.
16:27:11 <JuanDaugherty> monad was a really unfortunate choice of words
16:27:19 <ddarius> It's not really confusing.  Haskell functors are strong functors from Hask to Hask.  They aren't all strong functors.
16:27:26 <cmccann> _Ray_, that quote is actually a place where the limitations of Functor show up, because neither the operation or unit of the monoid mentioned can be described sensibly in Haskell
16:27:49 <cmccann> because you can't talk about functor composition directly, so join looks weird, and the identity functor is elided, so return looks weird
16:28:18 <cmccann> and the type class is defined in terms of (>>=) anyway, which is a composite operation that's convenient for programming but makes little sense in category theory terms
16:29:04 <monochrom> 1+1 of haskell is not too far from monads of haskell. both use type classes, Num and Moand
16:29:15 <mike-burns> Every programming langauge I've used has re-used some terminology incorrectly. No reason for Haskell to be different.
16:29:16 <ddarius> cmccann: (>>=) isn't reasonably for arbitrary monads, but is straightforward for strong monads.
16:29:31 * edwardk looks up.
16:29:35 * _Ray_ shivers at using functors for C++ objects with operator() :s
16:29:46 <kmc> mike-burns, yeah, it's better than C++ Functors ;P
16:29:54 <cmccann> ddarius, it's confusing because Haskell persistently uses terms from category theory to describe a specialized
16:29:56 <cmccann> er
16:30:02 <cmccann> specialized versions of those concepts
16:30:06 <ddarius> Arrows describe closed Freyd categories, which are well-defined, but pretty unstructured in some regards.
16:30:28 <ddarius> cmccann: That's pretty hard to avoid in any application.
16:30:31 <Jafet> It's not so bad when they're merely specialized over Hask
16:31:40 <cmccann> ddarius, agreed, and the specialized versions are the ones that make sense in the context of Haskell, but it's awkward when people are new to the ideas and wonder how "return" is a natural transformation
16:31:41 <djahandarie> ddarius, not exactly. Have you read Bob Atkey's paper on this?
16:31:47 <edwardk> cmccann: well you'd need better control over universes and kinds in order to do anything else. see copumpkin's work in agda for instance
16:31:53 <ddarius> djahandarie: Yes.
16:32:07 <ddarius> djahandarie: Either way the result is still well-defined.
16:32:08 <cmccann> edwardk, I realize that it's not easy to do better, yes :]
16:32:09 <djahandarie> Didn't he need to come up with enriched Freyd categories?
16:32:28 <djahandarie> But yes, it is.
16:32:29 <ddarius> djahandarie: That would be related to things being strong.
16:33:30 <ddarius> cmccann: People who wonder how return is a natural transformation can simply apply the definition of natural transformation.
16:33:31 <cmccann> edwardk, I'm just noting that it's unfortunately easy for newcomers to get the wrong idea
16:34:16 <cmccann> ddarius, which doesn't work if they assume that the Functor type class is equivalent to the general idea of functors
16:34:33 <ddarius> cmccann: No, it works completely fine in this case.
16:35:07 <cmccann> ddarius, how so
16:35:23 <ddarius> return -is- a natural transformation.  The fact that it is a natural transformation between strong endofunctors doesn't change that.
16:36:06 <cmccann> ddarius, the point is that it's a natural transformation from an identity functor that's not explicitly mentioned
16:36:46 <cmccann> because actually putting identity functors everywhere in Haskell would be a pain in the ass
16:37:03 <edwardk> its clearer if you model it in something like ML where the identity functor doesn't have to have newtype noise
16:37:17 <ddarius> edwardk: ?
16:37:48 <kmc> type family Id a :: *
16:37:50 <edwardk> ddarius: just saying you can make a real identity functor/monad/etc in that setting
16:38:05 <kmc> i feel like i don't hear about data/type families here as much as i used to
16:38:09 <ddarius> edwardk: Oh, you mean having a Functor module.
16:38:10 <kmc> did people decide they're useless and move on?
16:38:18 <edwardk> ddarius: yeah
16:38:28 <edwardk> kmc: more we just internalized them and use them where appropriate now
16:38:33 <cmccann> return would make more sense if you could define "type Id a = a", make Id an instance of Functor somehow, and then have return :: Id a -> m a
16:38:34 <ddarius> kmc: No, people just stopped going "squeeee."  They aren't new anymore.
16:38:36 <cmccann> or something like that
16:38:39 <kmc> k
16:38:42 <geheimdienst> cmccann: i completely agree with your point that the obscure math term are a barrier for learners. the odd words pollute the material and give you a false sense that you would be a better haskell programmer if you just understood monads-the-math-thing, where from all i've heard that's actually very dubious
16:38:52 <edwardk> cmccann: yeah, that was what i was saying you can do in ML-like languages
16:39:00 <kmc> ddarius, but beginners keep showing up and wanting to learn all the cool bits
16:39:05 <kmc> yet they don't ask about type families either
16:39:07 <edwardk> cmccann: but you lose the machinery haskell needs to use to dispatch the fmap.
16:39:25 <cmccann> edwardk, I figured, but I'm not very familiar with ML-ish languages, so I wasn't sure
16:39:51 <djahandarie> ddarius, isn't a closed Freyd category the same thing as a strong monad actually?
16:39:58 <ddarius> djahandarie: No.
16:40:11 <cmccann> geheimdienst, I'd still say that understanding the mathematical abstractions does help, it's just that the mathematical concepts are much broader than how the same terms are used in Haskell
16:41:28 <djahandarie> ddarius, I definitely remember it being so.
16:41:43 <djahandarie> Let me try and find a reference since I don't remember why
16:41:48 <cmccann> and when people take the "learn the math first" idea too seriously, they get sidetracked and confused when they come back to the Haskell concepts, because they don't actually match up directly
16:42:01 <lispy>  anyone have ideas about this? http://www.haskell.org/pipermail/haskell-cafe/2011-July/093717.html
16:42:45 <ddarius> I don't think I've ever seen anyone take "learn the math first" seriously, and then come back and get confused.
16:43:16 <ddarius> I will agree that it is a sidetrack and not very relevant to learning Haskell, but no one tells anyone to go learn category theory before learning Haskell.
16:43:50 <cmccann> I've seen a few people on Stack Overflow who'd clearly confused themselves by trying to learn both at the same time and got confused because of expecting the concepts to align
16:43:54 <lispy> ddarius: go read my link and offer some advice :P
16:44:36 <cmccann> and at least one person who I think already knew some CT trying to learn Haskell and not really understanding how the terms differ (as well as not understanding what type variables meant)
16:44:48 <djahandarie> ddarius, okay, in cartesian category C, a strong monad with Kleisli exponentials on C and a closed Freyd category J : C -> K are equivalent.
16:44:49 <ddarius> lispy: I rarely use GHCi and have heard things about GUI library not working in it.
16:44:54 <djahandarie> ddarius, http://www.cs.bham.ac.uk/~hxt/research/closed-freyd-and-kappa.ps
16:46:30 <geheimdienst> ddarius, i think it's not so much that people get told to learn CT. you just get the idea because the terms come up. if you have any curiosity at all, you will at some point wonder what a monad "really is"
16:46:40 <lispy> ddarius: hmm...Yeah, I've heard that two but I thought it was due to threading issues.  I think I ruled that out in my case
16:47:03 <lispy> geheimdienst: it's a burrito, right? j/k
16:47:15 <geheimdienst> for comparison, java's terms "object" or "interface" don't suggest there's some mathematical theory governing the whole thing, which might be beneficial to understand
16:47:40 <kmc> @quote fuck.yeah.i.am.ninja
16:47:40 <geheimdienst> anyhoo, my 2 cents
16:47:40 <lambdabot> HaskellLove says: haha fuck yeah i am ninja... anyways... when someone asks u about monads ask him is he a programmer or a mathematician... to a programer u can explain it in 5 minutes, not tell him
16:47:40 <lambdabot> how complex it is so he goes studies a hole day and at night he says : wait why the fuck do i waste time, i will never use this
16:47:49 <geheimdienst> lispy: tell that to wikipedia
16:50:32 <cmccann> lispy, I think monads are overloaded burrito operators in an endospacesuit category, or something like that. I dunno, sounds pretty complicated.
16:51:09 <geheimdienst> *nod*. also, i remember radioactive waste being involved at some point
16:51:51 <lispy> ?quote spacesuit
16:51:51 <lambdabot> syntaxglitch says: a monad is an endospacesuit on a burrito category
16:51:53 <lispy> ?quote spacesuit
16:51:53 <lambdabot> syntaxglitch says: a monad is an endospacesuit on a burrito category
16:51:58 <lispy> ?quote orange
16:51:58 <lambdabot> integerToBreakfast says: = (["Cornflakes", "Strawberry jam toast", "Grapefruit", "Cup of tea and a biscuit, gotta dash", "Bacon, eggs, toast, tomato and mushroom. You deserve it", "Waffles", "
16:51:58 <lambdabot> Porridge of some description", "Orange juice and muffins", "Apples, pears, mango and kiwi", "A selection of cold meats with crisp bread", "Headache pills and water", "Leftover pizza", "Leftover
16:51:58 <lambdabot> vindaloo curry"] !!)
16:52:00 <lispy> hmm
16:52:08 <lispy> ?quote dons.orange
16:52:08 <lambdabot> No quotes match. I feel much better now.
16:52:12 <lispy> ?quote dons orange
16:52:12 <lambdabot> No quotes match. Maybe you made a typo?
16:52:15 <lispy> ?quote dons.*orange
16:52:15 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
16:52:20 <lispy> lambdabot: you suck
16:52:28 <ddarius> "orange"?
16:52:32 <lispy> the spacesuit quote is by dons
16:52:58 <cmccann> lispy, the endospacesuit quote there is me BTW, under a different nick
16:53:10 <ian_mi> Why are finalizers limited to Ptrs?
16:53:13 <lispy> http://telofy.soup.io/post/23797479/Think-of-a-monad-as-a-spacesuit
16:53:25 <lispy> ddarius: ^^
16:53:36 <lispy> ?quote oranges
16:53:36 <lambdabot> No quotes match. You speak an infinite deal of nothing
16:53:39 <_Ray_> What happened to http://projects.haskell.org/hat/ ?
16:54:10 <lispy> _Ray_: when the haskell.org sever was moved it was not restored properly
16:54:14 <geheimdienst> lispy: i think you're (*puts on sunglasses*) comparing apples to oranges
16:54:44 <ian_mi> :|
16:55:56 * cmccann wonders what other quotes lambdabot has for his old nick
16:55:58 <cmccann> ?quote syntaxglitch
16:55:58 <lambdabot> syntaxglitch says: copumpkin, remember, there's no "I" in "haSKell"
16:56:03 <cmccann> ?quote syntaxglitch
16:56:03 <lambdabot> syntaxglitch says: <Kleene> hey al check this out <Kleene> > fix not <lambdabot> mueval-core: Time limit exceeded <Church> well crap
16:56:09 <cmccann> heh
16:56:25 <cmccann> ?quote syntaxglitch
16:56:26 <lambdabot> syntaxglitch says: every time I have a cool idea about something that might work in Haskell, I go check Oleg's stuff and find that 1) he already did it 2) thought it out better 3) did it incidentally
16:56:26 <lambdabot> while working on something way more interesting
16:56:45 <cmccann> ?quote syntaxglitch
16:56:45 <lambdabot> syntaxglitch says: a monad is an endospacesuit on a burrito category
16:56:52 <cmccann> ?quote syntaxglitch
16:56:52 <lambdabot> syntaxglitch says: copumpkin, remember, there's no "I" in "haSKell"
16:56:55 <cmccann> ?quote syntaxglitch
16:56:55 <lambdabot> syntaxglitch says: <Kleene> hey al check this out <Kleene> > fix not <lambdabot> mueval-core: Time limit exceeded <Church> well crap
16:57:00 <cmccann> seems to be it
16:57:24 <shachaf> Why is the type-level fix called Mu?
16:57:51 <geheimdienst> applied probability. try 5x -> last 2 were duplicates -> seems to be it
16:57:54 <geheimdienst> :)
16:58:05 <kmc> shachaf, least fixed point is written as μ in TaPL and probably many other books
16:58:08 <kmc> i don't know beyond that
16:58:24 <kmc> greatest fixed point is ν i think
16:58:45 <kmc> > fix not
16:58:45 <cmccann> geheimdienst, probability is just a formalized way of deciding when to say "forget it, that's good enough"
16:58:49 <lambdabot>   mueval-core: Time limit exceeded
16:59:01 <geheimdienst> yes that's right :)
16:59:12 <kmc> iirc lambdabot tries to cycle quotes deterministically for a given query
17:00:49 <elliott_> <shachaf> Why is the type-level fix called Mu?
17:00:59 <Jafet> shachaf: it's the zen hacker answer to the question “how do you write the type of the Y combinator in Haskell?”
17:01:01 <elliott_> isn't μx.T a common notation?
17:01:03 <elliott_> for recursive types
17:01:22 <kmc> yes
17:05:52 <jk_> newbie here trying to find a function like splitAt but returns a list of lists rather than a tuple of lists. like Clojure (partition...)
17:06:12 <jk_> is there such a thing in the library already? not seeing it
17:06:17 <Jafet> @hackage split
17:06:17 <lambdabot> http://hackage.haskell.org/package/split
17:06:18 <kmc> it's not there :/
17:06:20 <kmc> see the 'split' package
17:06:23 <cmccann> kmc, btw in case the quote wasn't clear enough, "fix not" is basically a trivial restatement of the generic self-negation style of "paradox", in this case referring to the Kleene-Rosser paradox that showed Church's lambda calculus to be inconsistent
17:06:26 <kmc> or roll your own with repeated splitAt
17:06:35 <jk_> kmc: ok, got it. thanks!
17:09:44 <pedro3005> @hoogle shift
17:09:44 <lambdabot> Data.Bits shift :: Bits a => a -> Int -> a
17:09:45 <lambdabot> Data.Bits shiftL :: Bits a => a -> Int -> a
17:09:45 <lambdabot> Data.Bits shiftR :: Bits a => a -> Int -> a
17:10:13 <pedro3005> is there a shift function that shifts [1, 2, 3] as [2, 3, 1] ?
17:10:24 <wli> roll?
17:10:29 <pedro3005> :t roll
17:10:30 <lambdabot> Not in scope: `roll'
17:10:44 <kmc> > take 3 . drop 1 $ cycle [1,2,3]
17:10:46 <lambdabot>   [2,3,1]
17:10:48 <wli> rotate
17:10:54 <pedro3005> :t rotate
17:10:55 <lambdabot> forall a. (Bits a) => a -> Int -> a
17:10:59 <wli> Data.Bits.rotate
17:11:12 <Jafet> Also not there.
17:11:34 <lispy> I made a lazy rrotate and lrotate once for lists, but I don't know where they ended up
17:11:42 <kmc> only in Haskell would you rotate a list by extending it to be infinitely long and then throwing out most of it ;P
17:12:40 <lispy> kmc: and many programming languages where you migh try extending it to be infinitiely long and then taking all of it
17:12:47 <lispy> I call it, _|_
17:13:13 <kmc> ah, the british power outlet
17:13:45 * lispy wonders how he can fix this ghci issue
17:15:46 <cmccann> > zipWith const <$> tail . cycle <*> id $ [1, 2, 3]
17:15:47 <lambdabot>   [2,3,1]
17:15:53 <cmccann> obviously the best way to do it
17:16:46 <cmccann> although
17:16:49 <cmccann> > join (zipWith const <$> tail . cycle) [1, 2, 3]
17:16:51 <lambdabot>   [2,3,1]
17:16:54 <cmccann> that works too
17:17:22 <cmccann> hm
17:17:35 <cmccann> > zipWith const =<< tail . cycle $ [1, 2, 3]
17:17:36 <lambdabot>   [2,3,1]
17:17:47 <cmccann> dunno why I didn't do that in the first place
17:17:50 <cmccann> oh well
17:18:42 <ddarius> shachaf: It's possible that the  comes from minimization in recursive function theory.
17:19:16 <dylukes> µ is being weird on my keyboard
17:19:23 <shachaf> ddarius: What Unicode character is that? It's showing up as U+FFFD on my terminal.
17:19:23 <dylukes> it keeps italicizing automatically. oh well.
17:19:27 <elliott_> shachaf: mu
17:19:32 <shachaf> Ah.
17:19:38 <dylukes> shachaf: olololol, ASCII ...
17:19:40 <shachaf> Odd, your mu worked.
17:19:50 <elliott_> maybe ddarius is not using utf.
17:20:51 <lispy> interesting, I just crashed gdb
17:21:35 <pedro3005> how do I convert from integer to char (ascii representation)?
17:21:52 <shachaf> pedro3005: What if the integer doesn't fit in one character?
17:22:19 <pedro3005> shachaf, shit happens
17:22:30 <fxr> great, just implemented a brute forcer for my modem... Network.Browser is greatly fitted my needs.
17:22:42 <shachaf> So you just want ord c - ord '0'?
17:23:06 <Jafet> if n < 256 then chr n else shit
17:23:06 <pedro3005> :t ord
17:23:07 <lambdabot> Char -> Int
17:23:24 <Jafet> Well, n < 128
17:23:25 * cmccann considers defining shitHappens as an alias for undefined
17:23:38 <shachaf> Oh, I misunderstood.
17:23:46 <lispy> oh, I think gdb just crashes when ghc needs more memory
17:23:52 <pedro3005> where are those functions?
17:23:55 <pedro3005> it says out of scope
17:24:00 <shachaf> cmccann: Better precede that with "unsafe".
17:24:02 <lispy> -H512m seems to have worked around it
17:24:06 * hackagebot simple-sendfile 0.1.2 - Cross platform library for the sendfile system call  http://hackage.haskell.org/package/simple-sendfile-0.1.2 (KazuYamamoto)
17:24:14 <Jafet> undefined is pretty well defined; it causes a UserError with the string “Prelude.undefined”
17:24:24 <Jafet> Ohh, you mean in Haskell
17:28:23 <Jafet> shitHappens = fromIntegral <$> randomRIO (0, 31) >>= raiseSignal
17:28:39 <shachaf> Jafet: Don't forget unsafePerformIO.
17:28:51 <Jafet> That's unsafeShitHappens, of course.
17:29:13 <Jafet> @index chr
17:29:13 <lambdabot> Data.Char
17:30:48 <Jafet> @quote randomRIO
17:30:48 <lambdabot> <kmc> says: head [] = peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32)
17:32:16 <Jafet> Actually, I just noticed that kmc's code isn't correct
17:32:22 <kmc> yeah it's not :/
17:32:25 <Jafet> Oh well
17:32:26 * kmc hangs head in shame
17:32:59 <cmccann> correctness being the main concern when using that code, clearly
17:33:53 <Jafet> Well, you could say that it encourages correctness
17:42:51 <elliott_> Can one unbox a polymorphic member of an ADT?
17:43:20 <elliott_> i.e. data Foo a = Foo {-# UNPACK #-} !a | ...
17:43:42 <kmc> doubtful
17:44:17 <elliott_> :(
17:44:23 <elliott_> What if I make it a data family?
17:44:32 <elliott_> Hmm
17:44:34 <elliott_> That would obviously work
17:44:37 <elliott_> It would be repetitive though
17:44:58 <elliott_> data instance Foo Blah = BlahCons {-# UNPACK #-}  !Blah | BlahOtherCons ...
17:45:05 <elliott_> data instance Foo Bluh = BluhCons {-# UNPACK #-}  !Bluh | BluhOtherCons ...
17:45:06 <elliott_> etc.
17:46:22 <Jafet> Hm, that might work
17:46:39 <elliott_> yeah and i could make a typeclass so i have cons and otherCons as functions
17:46:42 <elliott_> that's really kind of totally hideous though :)
17:46:47 <elliott_> and also, means I cannot pattern match on Foo values anywhere
17:46:51 <Jafet> At least GHC now warns you that the former doesn't work
17:46:56 <elliott_> so yeah, that's not really doable
17:46:56 <elliott_> hmm
17:47:13 <elliott_> I _could_ make it into !(Vector a), actually, if I dropped support for different kind of leaf types
17:47:16 <elliott_> that would kind of suck though :/
17:47:33 <elliott_> although that's more a "everything should be as general as possible!!!" thing than an actual practical issue, I think
17:47:52 <Jafet> You can't write polymorphic functions anymore in any case, because the representation for each type is different
17:47:57 <elliott_> yeah
17:48:02 <Jafet> STG machine doesn't likey.
17:48:04 <elliott_> well I can, if I write a destructor as a typeclass function, haha
17:48:11 <Jafet> Sure
17:48:19 <elliott_> what I want, I suppose, is a SPECIALISE pragma for _ADTs_...
17:49:02 <kmc> maybe what you want is a macro system less shitty than CPP and less cumbersome than TH
17:49:02 <lambdabot> kmc: You have 1 new message. '/msg lambdabot @messages' to read it.
17:49:19 <elliott_> kmc: I generally call that: Haskell
17:49:36 <kmc> Haskell sorely needs this
17:49:49 <elliott_> Haskell needs Haskell :-)
17:49:59 <shachaf> kmc: So does C, for that matter.
17:50:09 <Jafet> It would be nice to be able to write explicit representations for data types
17:50:11 <elliott_> Every language needs Haskell at the meta-layer.
17:50:14 <Jafet> Using Storable
17:50:34 <elliott_> Jafet: It would be nice if that was built into the ADT mechanism directly (thinking from the POV of writing an OS in a pure language).
17:50:42 <Jafet> And then forget about it until you realize you needed laziness somewhere, oh shit
17:50:43 <kmc> Habit has some of that, doesn't it?
17:51:29 * cmccann has started to think that using laziness to handwave the difference between data and codata is not really a good idea
17:53:02 <elliott_> cmccann: I think I might agree
17:53:28 <elliott_> although I appreciate the pervasive laziness of Haskell, when any "practical" program has five hundred exclamation marks in it, something is wrong
17:54:34 <kmc> the problem isn't needing 500 bang patterns
17:54:34 <Jafet> With Haskell, or your RAM capacity?
17:54:40 <kmc> the problem is needing one bang pattern in just the right place
17:54:47 <kmc> and needing guru-level knowledge to find that place
17:54:47 <elliott_> Jafet: hehe
17:57:11 <lispy> kmc: What would the definition of finite length lists look like if you separate data and codata in a Haskell based language?
17:57:16 <Jafet> So if you meditate in a closet for long enough, you'll find it?
17:57:24 <lispy> (finite but arbitrary)
17:57:38 <kmc> i have no idea
17:57:45 <cmccann> lispy, the same as lists in Haskell
17:58:08 <cmccann> you just wouldn't be allowed to define values in a corecursive manner
17:58:36 <lispy> cmccann: hmm
17:58:59 <lispy> unrelated to that, I was able to recreate the same behavior as ghci in my compiled version using forkIO
17:59:31 * lispy tries forkOS to see if the behavior is the same
17:59:50 <lispy> indeed it is
18:00:07 * lispy wonders what this means
18:00:08 <dpotian> I've written a program using the STM and I have 2 cores.  What flags do I need to pass to ghc make it really concurrent, if that makes sense?
18:00:31 <Jafet> How would you statically assure that no values are corecursive?
18:00:41 <lispy> dpotian: -threaded but that may be the default anyway.  try, program +RTS --info and look at RTS_Way
18:00:50 <kmc> ghc -threaded --make foo.hs
18:00:55 <kmc> ./foo +RTS -N2
18:01:06 <kmc> with GHC7 you also need to build with ghc -rtsopts
18:01:07 <dpotian> i'll try that, thx
18:01:08 <Jafet> Or even computably
18:01:48 <lispy> Jafet: I don't know enough about this sort of thing...you may need to make the language total
18:01:56 <cmccann> Jafet, well, if nothing else you can just forbid general recursion :P
18:02:45 <Jafet> Agda can do that inductively, at least
18:03:04 <cmccann> only allow definitions that add a finite amount to an existing value, or definitions that are recursive on an existing value of some finite data type
18:03:55 <cmccann> for instance, given a finite natural number type, replicate :: Nat -> a -> [a] would be allowed
18:04:10 <dpotian> @kmc and lispy, yeah that did it, i was forgetting -rtsopts
18:04:10 <lambdabot> Maybe you meant: ghc rc src
18:04:42 <lispy> dpotian: ah great.  Yeah, the need for -rtsopts is a bit restrictive at the moment
18:05:00 <Jafet> If you allowed [a] without allowing corecursion, I think the language would inevitably have to be a bit strange
18:05:16 <Jafet> Like forbidding certain bindings to be used in certain places
18:06:00 <cmccann> Jafet, depends on your definition of "strange"
18:06:50 <lispy> is there a way to write a "forever yield" loop in ghc?
18:07:11 <lispy> forever (return ()), never actually yields to the other threads because it doesn't create garbage, right?
18:07:42 <nine9> does anyone know a book/website for programming in haskell for complete programming beginners?
18:07:49 <cmccann> Jafet, simply removing built-in recursion everywhere would be consistent and not really "strange", just awkward to program with
18:07:57 <shachaf> lispy: forever (threadDelay maxBound)?
18:08:07 <kmc> Control.Concurrent.yield
18:08:11 <cmccann> nine9, I think "Learn You a Haskell" is the most popular for complete beginners
18:08:11 <smop> nine9: learn you a haskell/real world haskell
18:08:25 * lispy tries forever yield
18:08:29 <nine9> thx, cmccann, smop
18:08:30 <cmccann> Real World Haskell is more pitched at programmers who know other languages
18:08:51 <zmoazeni> nine9: Real World Haskell was easier for me to grok. I went through both
18:09:06 <Jafet> cmccann: for example, I don't see a need to ban let-binding, (:) or non-strict evaluation, but nevertheless (let x = a:x in x) can't be allowed
18:09:17 <Jafet> I'm not sure what you mean by “built-in recursion”.
18:09:58 <cmccann> Jafet, built-in recursion meaning anything that lets you write arbitrary recursive definitions, which would otherwise not be well-typed
18:10:16 <cmccann> having identifiers be in scope within their own definitions being a prime example
18:10:46 <cmccann> for both data types and arbitrary values
18:10:47 <Jafet> Yeah, I think my example illustrates why “built-in recursion” might be a bit hard to pin down
18:11:06 <cmccann> it's not hard to pin down, it's just something you expect to be possible
18:11:46 <cmccann> there's no reason why an identifier needs to be in scope within the expression that is being used to define it
18:12:35 <_Ray_> How can I write this pointfree? countprimes xs = foldl (++) 0 (map isprime xs). Removing parenthesis and xs doesn't work :(
18:12:55 <cmccann> for example, your (let x = a:x in x), where's the x in "a:x" coming from? It doesn't need to be available, it's not defined yet.
18:13:09 <shachaf> @pl countprimes xs = foldl (++) 0 (map isprime xs)
18:13:09 <lambdabot> countprimes = foldl (++) 0 . map isprime
18:13:26 <Jafet> Identifiers in definitions would have to be acyclic throughout the program, ie. a somewhat non-local property
18:13:48 <_Ray_> shachaf, ghci didn't like "let countprimes = foldl (++) 0 . map isprime"
18:14:24 <kmc> monomorphism restriction?
18:14:26 <shachaf> _Ray_: My ghci likes it.
18:14:29 <_Ray_> Where isprime is the supremely shitty let isprime n = if length [x | x <- [2..n-1], n `mod` x == 0] == 0 then 1 else 0
18:14:44 <shachaf> Yes, try :set -XNoMonomorphismRestriction
18:15:02 <kmc> :t any
18:15:03 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
18:15:04 <cmccann> Jafet, well yeah, Haskell is designed with the expectation of implicitly recursive definitions, so it will seem awkward
18:15:06 <kmc> ^^^ _Ray_
18:15:21 <zmoazeni> _Ray_: That bit me earlier: http://www.haskell.org/haskellwiki/Monomorphism_restriction
18:15:24 <_Ray_> Oh, I would /never/ have suspected that was directed to me, sorry!
18:15:32 <Jafet> ghci might like that better if it was well-typed, ray
18:15:38 <cmccann> Jafet, it's not something that can just be bolted onto Haskell as it exists, certainly
18:15:38 <Jafet> Assuming (++) is Prelude.(++)
18:15:51 <_Ray_> Yep
18:15:58 <shachaf> Oh, yes, there is that.
18:16:08 <Jafet> Or Num [a]!
18:16:19 <kmc> :t let isprime n = fromEnum $ any ((== 0) . (n `mod`)) [2..floor . sqrt $ fromIntegral n)] in isprime
18:16:20 <lambdabot> parse error on input `)'
18:16:21 <shachaf> You probably just want (+).
18:17:21 <Jafet> cmccann: self-reference or cyclic reference is allowed in many languages, so it'll seem awkward to many people
18:17:41 <Jafet> I don't think you can allow recursive function definitions either, for instance
18:17:46 <zmoazeni> I hope mentally parsing those composed functions for isprime gets easier the more you work with Haskell, because I have to step through that bit by bit. I almost want a scratch pad.
18:17:56 <cmccann> Jafet, you realize that I'm talking about defining a language that's not Turing-complete, right? :]
18:18:41 <cmccann> as an illustration of the extreme case of how to distinguish data vs. codata, mind
18:18:41 <danharaj> zmoazeni: Reasoning about it bit by bit works pretty well in Haskell. You don't have to keep the whole function in your head to understand it.
18:18:52 <kmc> yay equational reasoning
18:18:54 <kmc> equals for equals
18:19:07 <cmccann> bah, equality is overrated
18:19:10 <Jafet> That's a consequence of removing corecursion? I thought most languages just weren't Turing-complete for other reasons
18:19:11 <cmccann> stick with equivalence
18:19:57 <cmccann> Jafet, a consequence of removing arbitrary recursion, leaving only restricted kinds of well-founded recursion and productive corecursion
18:20:02 <accel_> dumb question: why does cabal not use gpg signatures?
18:20:23 <Jafet> What would the point be, accel?
18:20:31 <koninkje> Does anyone know what the canonical paper is (if any) that higher-order unification is undecidable?
18:20:34 <koninkje> I have the paper for 3rd-order; but not for 2nd
18:20:46 <Jafet> And do you mean Hackage, not Cabal (or cabal-install)?
18:20:59 <accel> Jafet: I mean Hackage.
18:21:21 <accel> or maybe "why does hackage not use gpg, and cabal not auto check gpg signatures of downloaded packages?
18:21:41 <accel> seems like no additional work for the user typing in "cabal install ...."
18:21:57 <elliott_> that would require the user to manually add keys they trust
18:22:00 <Jafet> What's the point?
18:22:22 <accel> http://scarybeastsecurity.blogspot.com/2011/07/alert-vsftpd-download-backdoored.html <-- avoid thigns like that
18:23:16 <elliott_> that guy sure takes his vulnerabilities seriously
18:23:43 <Jafet> If I wanted to backdoor hackage, all I'd need to do is write a Better Version of SYB or something, insert my backdoor, apply for an account and upload it
18:23:43 <mike-burns> That's reasonable.
18:24:10 <accel> Jafet: yeah, and there should be a hindrance against that
18:24:13 <Jafet> Hackage packages are uploaded, and used, on a mostly as-is basis
18:24:34 <Jafet> What do you propose to hinder that?
18:24:47 <accel> there should be a list of contricutors and their pgp keys
18:24:50 <accel> and after you do it once
18:24:54 <accel> we kick you out and never trust you again
18:25:07 <accel> it doens't prevent backdoors from ever happening
18:25:18 <accel> it does require you spend enough years to build a reputation in the haskell community
18:25:26 <accel> then sacrifice it in one attempt to backdoor machines
18:25:30 <cmccann> yeah, from any sort of serious security standpoint Hackage is basically one gigantic welcome mat
18:26:12 <Jafet> Then I just apply again as another Bourbaki
18:26:30 <cmccann> the only reason it hasn't blown up is 1) a small community with enough implicit trust 2) enough people who look at code and would notice something fishy 3) too small of a target to bother
18:27:02 <Jafet> 4) how many of those packages get used?
18:27:23 <elliott_> accel: that's basically just a big old people's club :P
18:27:28 <mike-burns> Is there any evidence of people being stopped by apt-get of FreeBSD port's GPG or MD5 checks?
18:27:33 <elliott_> you just need to hang around for a while and plant your backdoor
18:27:59 <cmccann> if someone trusted in the community wanted to put a backdoor in some heavily-used package in arcane heavily-optimized code that most people wouldn't look at in detail, I don't think there's much defense against that
18:28:49 <cmccann> so basically there's some small likelihood that dons has a backdoor into the machines of everyone here but probably not
18:29:02 <accel> killall -9 xmonad
18:29:38 <accel> hmm; man, I guess i just looke paranoid
18:29:45 <accel> though it surprises me how lax the security is
18:29:57 <Jafet> If someone in the community has a backdoor, it would be the guy who writes GHC's installer script
18:29:58 <mike-burns> Paranoid, maybe, but reasonably so.
18:30:04 <Jafet> Nothing else gets run as root over and over again
18:30:05 * cmccann actually thinks that bytestring would be the best target for sneaking a backdoor in
18:30:12 <mike-burns> Yeah.
18:30:27 <Jafet> And no self-respecting Haskell programmer reads those shell scripts
18:31:42 <lispy> does ghc  use posix threads on osx for the threaded rts?
18:31:54 <cmccann> accel, you're not paranoid, you're just thinking out of context. There's not likely to be enough payoff to justify the effort in going after the flaws you're pointing out
18:32:30 <cmccann> in the context of a larger system with more end-users vs. programmers something like Hackage would be a nightmare waiting to happen
18:34:50 <accel> how do systems like debian/ubuntu solve this problem?
18:35:01 <accel> i.e. I don't recall the last time I heard a backdoor in debian
18:35:13 <Jafet> They don't
18:35:23 <Jafet> There is no way to solve an unfounded trust problem
18:35:32 <accel> how do they _mitigate_ this problem
18:35:44 <dpotian> it's difficult to be a debian maintainer
18:35:46 <Jafet> What cmccann said
18:36:01 <zmoazeni> Wouldn't gpg signatures be reactive anyway? It requires someone to notice and take action, but does nothing for those that already installed the bad package. I'd imagine someone is maintaining the Hackage/Cabal distribution server, and if it was malicious enough, an email to the right person would rip it down.
18:36:04 <cmccann> they approximate a solution by not throwing the door wide open to anyone and everyone, give or take
18:36:11 <Jafet> Well, if the backdoors were done properly, you would never have heard of them
18:36:32 <Jafet> So you can't point to a huge system and say “it has no backdoors, it must be doing something right”
18:37:01 <arw__> maintainers are implicitly trusted. they upload signed source packages. source packages are compiled into binaries by trusted systems. binaries are md5-summed and the catalogue of md5sums is distributed by trusted people (the ftp-maintainers) along with the packages themselves.
18:37:03 <cmccann> in practice, you have to trust someone, and the people in the Haskell community that have that level of trust are roughly the same people who'd have a chance of sneaking something into Hackage undetected
18:37:58 <mike-burns>  Beyond trusting the package maintainers, there's also the chance of a man-in-the-middle attack.
18:38:27 <cmccann> there's virtually no upper limit to the complexity that can be introduced in the name of security verification
18:38:34 <zmoazeni> Doesn't the md5 work to prevent the man-in-the-middle attack?
18:38:34 <cmccann> it's all a matter of cost/benefit
18:38:55 <mike-burns> Yeah, the MD5 would help with MITM.
18:39:02 <arw__> oh, i forgot one step. the list of md5sums is signed with the ftp maintainers' key.
18:39:19 <cmccann> also, note that the Haskell Platform already qualifies as a slightly higher level of assurance
18:39:24 <cmccann> in a rather limited way
18:39:38 <Jafet> Well, I've read much of the ByteString code, for what that's worth!
18:39:50 <Jafet> Most of it is fairly straightforward
18:40:19 <cmccann> Jafet, and people like you are why Hackage isn't as problematic as it seems, because people actually do read a lot of code
18:40:31 <arw__> well. reading code and understanding code is something entirely different: http://underhanded.xcott.com/
18:40:45 <Jafet> There are some programming choices that aren't obvious unless you're dons, but the choices have no security implications either way
18:41:19 <kmc> i would be really really hesitant to say that any programming choice has no security implications
18:41:20 <Jafet> Like tuning for cache size, unless dons is moonlighting as a cache timer
18:42:05 <cmccann> I'm very doubtful that there's any code on Hackage that's widely used but not subject to semi-regular inspection, if only from people looking at it to see how the crap the thing works
18:42:24 <kmc> i agree that the situation is far worse in C, where tiny "mistakes" in routine string manipulation lead to total compromise
18:42:45 <cmccann> it helps that a lot of Haskell libraries a really quite small, in terms of both code size and conceptual complexity
18:43:04 <zmoazeni> Cabal's have some sort of concept of an "owner" right? I couldn't hijack regex-posix right now and push up a vulnerability could I?
18:43:19 <shachaf> zmoazeni: Last I heard you could.
18:43:23 <accel> zmoazeni: excellent question
18:43:24 <kmc> GPG could make that stronger
18:43:25 <accel> shachaf: you're kidding right?
18:43:34 <Jafet> You could, but the cabal administrator would have to approve it.
18:43:38 <Jafet> Er, hackage administrator.
18:43:46 <cmccann> and your name would be on it
18:43:52 <shachaf> Are all Hackage uploads manually approved?
18:43:59 <kmc> does hackage even support SSL?
18:44:05 <kmc> i can just MITM any download or upload
18:44:21 <ddarius> There is a new Hackage server that, I believe, has at least some notion of security, though still a far way away from the ideal.
18:44:24 <kmc> people install via 'cabal install' and don't check the source inside the *particular* tarball they downloaded
18:44:30 * cmccann reiterates that from a security standpoint Hackage is basically a gigantic welcome mat
18:44:33 <cmccann> I wasn't kidding about that
18:44:34 <kmc> ddarius, ah, yes, I've been hearing about this new Hackage server for quite some time
18:44:54 <Jafet> At least packages are versioned and archived…
18:45:07 <arw__> MITM is significantly harder than just uploading or posing as somebody else with some kind of "sorry, i'm on a holiday but need to push this urgent patch"-excuse.
18:45:10 <ddarius> I don't know what's going on about it.  It seems like they were just about to switch to it, and then nothing happened.
18:45:29 <cmccann> the main obstacle is that it's difficult to do anything sketchy on Hackage that would be *undetected*
18:46:17 <ddarius> cmccann: That statement is inherently unverifiable from an empirical perspectivwe.
18:46:20 <kmc> MITM is quite easy
18:46:24 <arw__> cmccann: the question is not _if_ it would be detected but _when_ and _how_
18:46:37 <kmc> SSL would make it somewhat harder and would cost almost nothing
18:46:41 <cmccann> well, yes
18:46:47 <arw__> kmc: well, conference wlan would be the canonical example of where its easy
18:46:49 <kmc> and would not require any changes in the end-to-end process
18:46:51 <kmc> yep
18:47:08 <kmc> or a classroom full of people being instructed on how to use cabal ;P
18:47:15 <cmccann> I should probably say that I'm not at all satisfied with how hackage works right now
18:47:23 <ddarius> There's a lot of easy things Hackage could do that would dramatically increase the, currently non-existent, security.
18:47:39 <kmc> ddarius, so who do we bitch at to get SSL, as a first step?
18:47:42 <cmccann> just saying why it's not blown up in our faces yet
18:48:21 <ddarius> I actually find it fascinating that the current Hackage has worked as well as it has.
18:48:36 <kmc> we should switch to a distributed package repository based on proof-of-work hash chaining
18:48:51 <accel> but we should not host it with mtgox
18:49:02 <arw__> ddarius: either that, or even the evil haskell people are significantly smarter and go about undetected...
18:49:04 <cmccann> ddarius, yes, it's an interesting case study in how well implicit trust actually holds up in the wild, namely better than most people who worry about security tend to expect
18:49:04 <Cale> I think part of the reason is that idiots tend not to use Haskell. :)
18:49:18 <kmc> Cale, that makes their backdoors much harder to find
18:49:20 <Jafet> Appears to have worked as well as it has.
18:49:43 <Cale> and the barrier to entry for messing with Hackage packages is just large enough that if you're not actually a Haskell user, it's too much of a pain
18:50:13 <Cale> (to get an account)
18:50:26 <cmccann> Cale, yes, Hackage offers security through repeated trivial inconveniences
18:51:35 <cmccann> though honestly, I doubt the current situation can last much longer :I
18:51:57 <Jafet> Like having to give a username that looks like a real name, I guess
18:51:59 <ddarius> Of course it can't last indefinitely.
18:52:18 <Cale> Depends on how popular Haskell gets.
18:52:37 <Jafet> (Would people be less trusting if packages were uploaded under obvious nicknames?)
18:52:46 <Cale> The security only has to hold out until we all jump ship to the next futuristic language.
18:52:49 <ddarius> Jafet: Packages are.
18:53:08 <cmccann> Cale, ooh, which language is that?
18:53:13 * cmccann wants to get a head start
18:53:13 <Cale> Not sure yet
18:53:15 <cmccann> aww
18:53:21 <Cale> Maybe an Agda?
18:53:22 <arw__> cmccann: Haskell++
18:54:17 <Cale> Probably something dependently typed.
18:54:30 <accel> TimeTravel: values aren't computed until you're done using them.
18:55:02 <kmc> i'm waiting for Learn You An Agda
18:55:05 <kmc> or Real World Agda
18:55:08 <Jafet> Maxwell might have something to say about that paradigm
18:55:20 <djahandarie> I really don't think Agda is stable enough for serious usage yet.
18:55:24 <Axman6> well, if C++ is anything to go by, the next Haskell will have lambdas and easy concurrency!
18:55:27 <kmc> let's write a RSS reader using GTK+ and then prove that it's equivalent to a co-yoneda turbofunctor
18:55:34 <djahandarie> People are working on Learn You An Agda though.
18:55:37 <kmc> @remember Axman6 well, if C++ is anything to go by, the next Haskell will have lambdas and easy concurrency!
18:55:38 <lambdabot> Okay.
18:55:38 <cmccann> kmc, I asked BONUS about writing LYAA at one point but I don't think he went for it
18:55:38 <Jafet> kmc: that sucks, Agda is supposed to be our escape from the real world
18:55:41 <arw__> sounds like a language for "tachyon computing". the next step after quantum computing
18:55:47 <shachaf> kmc: Is that a functor with a Turbo button?
18:55:48 <Axman6> :)
18:55:49 <kmc> Jafet, they said the same about Haskell too
18:56:00 <kmc> i love the "turbo" button
18:56:00 * shachaf misses Turbo buttons.
18:56:07 <kmc> it is the perfect synergy of engineering and marketing
18:56:18 <ddarius> A 1970s/1980s language isn't what to look at for the future.  You should be looking at the late 1990s if we are considering a post-Haskell future.
18:57:01 <kmc> ddarius, but will the post-Haskell language work in the post-cloud paradigm
18:57:18 <ddarius> kmc: The cloud didn't exist in the late 1990s.
18:57:35 <arw__> ddarius: only the word didn't exist.
18:57:35 <Jafet> Post-cloud sounds like vapourware
18:57:49 <kmc> yes, this "cloud" idea is very old
18:58:01 <ddarius> Well so is functional programming.
18:58:02 <kmc> we used to do it with timesharing multi-user operating systems
18:58:14 * cmccann moves from cloud computing to entire low pressure storm system computing
18:58:34 <kmc> since OS research is a total failure, now we do it with the brute force solution of virtualization instead
18:58:35 <zmoazeni> fog computing?
18:58:57 <zmoazeni> f . g
18:58:58 <kmc> (failure at least at getting the real world to apply their ideas)
18:59:00 <Cale> STEAM computing. Hydraulics.
18:59:19 <kmc> zmoazeni, surely f∘g
18:59:30 <lispy> Steam is very profitable lately with their game store
18:59:42 <arw__> and cloud services are 1990 promise of thin terminals talking to an "intelligent" network.
18:59:53 <arw__> an idea SUN was founded around.
19:00:05 <arw__> or adapted, don't remember.
19:00:25 * cmccann still likes that one question on Stack Overflow where Alan Kay asked everyone "hey, what's new since the 80s" and the response was mostly "uhhhh....."
19:00:39 <Cale> Are cloud services categorically modelled by stratofunctors?
19:01:16 <kmc> cmccann, was he recently thawed from cryogenic sleep?
19:01:37 <kmc> arw__, right, of course today's "thin" client is executing megabytes of Javascript on a multi-core GHz-class processor
19:02:04 <kmc> it's the same software delivery model but with far more of the implementation burden on the client side
19:03:25 <cmccann> kmc, nah, mostly it was about the fact that most "modern" ideas involving computers are just polishing extensions of ideas from 1980 or earlier, and polling for people's thoughts on what's really new since then
19:03:35 <kmc> so, what is actually new?
19:03:35 <arw__> kmc: yes, often its disturbing what is left from those ideas from "good old times"
19:03:52 <ddarius> Yes, javascript, Java applets, Flash, Silverlight, are all not very different from downloading a native code executable and executing it.
19:03:54 <cmccann> it was pretty funny how many answers he replied to with "no, I remember some guy at Xerox doing that in 78" or such
19:04:10 <zmoazeni> ... I can extend my "elastic social graph" with http://www.color.com/ ....
19:04:18 <cmccann> kmc, here's the question: http://stackoverflow.com/questions/432922
19:06:07 <arw__> kmc: quantum computing
19:06:22 <kmc> hmm, distributed version control
19:06:23 <kmc> i like that answer
19:07:19 <cmccann> kmc, it's one of the better suggestions, in that coherent version control at all is (if memory serves me) only slightly older than 1980, and dvcs is enough of a conceptual jump well after that point
19:08:03 <kmc> "The monad was instrumental in allowing a pure, lazy language (Haskell) to become a practical tool"
19:08:05 <kmc> cue rant
19:08:17 <cmccann> hahahaha yeah not even gonna go there
19:08:40 <kmc> hmm how old are the techniques for allowing scalable SMP?
19:08:48 <cmccann> though to be fair it was kind of an improvement over what Haskell did before that
19:08:51 <kmc> like cache coherency protocols and all the stuff that makes NUMA work?
19:09:05 <kmc> cmccann, oh yes, it's just that the nature of that improvement doesn't have much to do with the abstract monad concept
19:09:53 <cmccann> kmc, yeah, it's just a poorly stated justification combined with a (fairly trivial) combination of ideas much older than 1980
19:09:58 <arw__> around 1990 iirc. some, like cray multiprocessor machines are older of course, but the significant advances came around that time.
19:10:25 <cmccann> the answer suggesting type inference makes a stronger case, even though the original type inference algorithms are also much older
19:11:20 <kmc> higher-rank polymorphism and type classes for them might count as a new idea
19:11:23 <djahandarie> kmc, fwiw, monads are actually critical for modeling side effects in your language semantics (from the categorical angle).
19:11:58 <kmc> djahandarie, why can't i just take the view of a pure functional program which generates an effect-description?
19:11:59 <cmccann> djahandarie, there are other ways of modeling that, though
19:12:23 <arw__> uh. strike cray, write KSR.
19:12:36 <arw__> cray was somewhat late in the multiprocessor game.
19:13:09 <ddarius> djahandarie: Actually, it wasn't really a "categorical" perspective that drove it.
19:13:48 <cmccann> the main thing I took from that question is that it takes about 30 years for ideas to hit the mainstream, so that anything new developed since 1980 is too obscure to notice yet
19:14:16 <kmc> in the case of functional programming, it took about 80 years
19:14:23 <ddarius> Type classes are genuinely post-1980.
19:15:00 <cmccann> kmc, yes, with the caveat that outdated ideas tend to stick around much longer than is justifiable and sometimes obstruct new things
19:15:12 <djahandarie> kmc, I think you'll still need to deal with it when describing the semantics for your 'effect description'. I'm not sure though, I've only seen it from the angle of putting effect-ish things directly into your language.
19:15:16 <cmccann> though really, a lot of modern functional programming is much more recent
19:15:16 <ddarius> (Also, monads were introduced to organize the extant ways of modelling effects, not to provide the means to.)
19:15:33 <kmc> djahandarie, i would give a separate, straightforward world-transformer semantics for the effect descriptions
19:16:12 <djahandarie> kmc, so you wouldn't have a denotational semantics at all?
19:16:23 <kmc> i don't know, i haven't really thought this through
19:16:29 <cmccann> there's a pretty big gulf between lambda calculus or very early lisp vs. modern functional programming languages
19:17:03 <kmc> when were algebraic data and pattern matching invented?
19:17:06 <kmc> before 1980, anyway
19:17:07 <dobblego> is there a type-class to go from z Identity -> z f?
19:17:17 <kmc> but i suppose that's a place to draw the line
19:17:36 <kmc> STM is another plausible "new idea"
19:17:41 <kmc> but i'm not sure how new it is
19:17:46 <kmc> transactions in databases are very old
19:17:58 <ddarius> cmccann: Actually, the gap is surprisingly small.
19:18:30 <ddarius> kmc: Hardware transactional memory is pretty old.
19:18:32 <cmccann> kmc, the original ML was developed in the 70s
19:19:11 <ddarius> cmccann: It took a bit before it evolved its full ADT concept (and you can still see aspects of the evolution today), but yeah, at least the 70s with ML.
19:19:12 <kmc> what about RISC? does that count as a "new idea"?
19:19:32 <cmccann> ddarius, it's smaller in retrospect because of how much of the modern concepts can be reimplemented in primitive systems
19:21:06 <ddarius> I'd say many functional languages (particularly pure ones) were explicitly designed to be "sugared" versions of the lambda calculus.  I'd say that in retrospect the gap is occasionally larger than expected as some changes/additions turned out to be more profound than originally thought.
19:21:13 <ddarius> E.g. pattern matching and type classes.
19:21:40 <kmc> yeah, type classes are almost as much of a runaway feature as C++ templates
19:24:13 <cmccann> ddarius, yes, I'm just saying that the concepts implicit in that sugar are pretty significant and functional programming before those concepts existed would have been very different
19:25:14 <kmc> i think old Lisp programming was also not particularly "functional" and certainly not high-level
19:25:36 <cmccann> I'm sure it was especially exciting before lexical scoping was invented
19:25:37 <ddarius> cmccann: My point is that much of the sugar, even in Haskell, is actually pretty trivial, though not all of it.
19:25:40 <ddarius> kmc: It wasn't.
19:25:43 <kmc> viz. car, cdr referring to specific registers on the IBM 701
19:25:49 <kmc> (or parts of registers?)
19:26:27 <cmccann> ddarius, trivial to describe, not so trivial to invent in the first place
19:26:39 <pikhq_> I thought it was specific *opcodes* for fetching parts of a register.
19:26:52 <ddarius> No, a lot of it is is completely trivial.
19:27:13 * cmccann shrugs
19:28:02 <cmccann> guess I'll take your word for that, then :P
19:29:34 <ddarius> My point is that Haskell looks very different from the lambda calculus, but a surprisingly large amount of that is just very superficial sugar.  Some of it is much less superficial sugar, either in complexity or concept.  And some is fundamentally different.
19:30:39 <dolio> Before lexical scoping was invented?
19:31:20 <cmccann> ddarius, yes, I realize that, I just tend to assume that anything I could reimplement in a fraction of the time it took for the ideas to be developed in the first place must have been less trivial at the time than in hindsight
19:32:12 <dolio> So, before computers were actually invented?
19:32:48 <Jafet> Lisp started out as a language for bootstrapping itself
19:32:51 <cmccann> quite a bit of Haskell could have been specified without computers on which to run it, I think
19:32:58 <kmc> Lisp started out as a theoretical exercise
19:33:44 <Jafet> So perhaps a lot about it was a coincidence
19:36:50 <cmccann> dolio, oh, and I was being somewhat tongue in cheek there, but a lot of early languages did use dynamic scoping before picking up lexical scoping from elsewhere
19:37:29 <cmccann> but obviously lexical scoping as a concept does predate programming languages a bit
19:37:42 <dolio> Yeah, because they didn't lern their lambda calculus, clearly.
19:37:58 <cmccann> and even in programming it's not really much younger than anything else, I think it was introduced with ALGOL or such
19:38:31 <cmccann> dolio, it's like lambda calculus except without those pesky clauses about "...where x is not free in f" and such!
19:38:45 <Jafet> I think call-by-name was introduced by ALGOL
19:38:55 <Jafet> Of course, no one implemented it correctly then
19:39:25 <Jafet> Probably because of the pesky impure semantics
19:40:00 <cmccann> Jafet, regarding ALGOL 60: "Here is a language so far ahead of its time that it was not only an improvement on its predecessors but also on nearly all its successors." -- C. A. R. Hoare
19:40:26 <Jafet> And thus no one used it
19:40:33 <Jafet> Hm, now there's a big could-have-been.
19:49:38 <glguy> edwardk: It's pretty cool how much you get for free with your Monad instances for things with free monads and DerivingFunctor :)
19:50:07 * glguy has been reading the recent three part series on improving the performance of free monads
19:50:21 * sanjoyd googles free monads.
19:50:35 <glguy> sanjoyd: http://comonad.com/reader/2011/free-monads-for-less/
19:50:42 <mike-burns> I've been paying full price for my monads all this time?!
19:50:49 <Qata> I'm trying to build gtk2hs and gtk in cabal on mac.
19:50:54 <sanjoyd> glguy: thanks.
19:51:01 <Qata> and I keep getting the ~/.cabal/bin error installing gtk
19:51:07 <hpaste> “Neat state monad definition” pasted “glguy” at http://hpaste.org/48688
19:51:13 <Qata> did build gtk2hstools to the wrong place?
19:51:24 <Qata> gtk2hs-buildtools*
19:51:36 * sanjoyd notices 22 of his 24 tabs are open on something Haskell related.
19:52:33 <Qata> help, anyone? :o
19:53:24 <cmccann> Qata, sorry, I mostly use linux :T
19:53:38 <Qata> ahh cmccann
19:53:40 <Qata> So do I
19:53:43 <Qata> that's my issue :)
19:53:46 <cmccann> haha
19:53:52 <Qata> Mac is too damn simple.
19:54:01 <cmccann> yeah I occasionally try to do Haskell stuff on my macbook, it sometimes works
19:54:09 <cmccann> I mostly gave up on anything with UI stuff though
19:54:23 <Qata> well, I'm just trying to build gtk2hs
19:54:31 <Qata> my question may just be noobishness
19:54:35 <cmccann> but I don't spend enough time using the macbook to bother getting it all working properly
19:54:39 <Qata> and it could be pretty generic
19:54:49 <Qata> considering I'm trying to follow the ubuntu build instructions >_>
19:55:19 * cmccann really wouldn't know :[
19:55:58 <Qata> :<
19:56:03 <Qata> awrighty.
19:56:26 <Qata> anyone? :o
19:56:57 <Cale> Qata: Maybe ensure that ~/.cabal/bin is in your path somehow?
19:57:16 <zmoazeni> Qata: No clue if this will help, but have you tried installing gtk libraries from a mac package manager? (e.g. homebrew)
19:57:40 <tommd> Qata: What is "the ~/.cabal/bin error"?
19:57:46 <tommd> What is the actual error?
19:57:49 <Qata> Cale: I had to create the file bin
19:57:58 <tommd> bin should be a directory
19:58:07 <Qata> ld: warning: PIE disabled. Absolute addressing (perhaps -mdynamic-no-pic) not allowed in code signed PIE, but used in ___gmpn_modexact_1c_odd from /Library/Frameworks/GHC.framework/Versions/7.0.3-x86_64/usr/lib/ghc-7.0.3/integer-gmp-0.2.0.3/libHSinteger-gmp-0.2.0.3.a(mode1o.o). To fix this warning, don't compile with -mdynamic-no-pic or link with -Wl,-no_pie
19:58:08 <Qata> Cannot find gtk2hsC2hs
19:58:08 <Qata> Please install `gtk2hs-buildtools` first and check that the install directory is in your PATH (e.g. HOME/.cabal/bin).
19:58:08 <Qata> cabal: Error: some packages failed to install:
19:58:08 <Qata> cairo-0.12.0 failed during the configure step. The exception was:
19:58:09 <Qata> ExitFailure 1
19:58:09 <Qata> gio-0.12.0 depends on glib-0.12.0 which failed to install.
19:58:17 <Qata> oh, sorry
19:58:21 <Qata> I'll pastebin next time.
19:58:21 <mike-burns> http://hpaste.org/
19:58:31 <Cale> yeah, make sure that gtk2hs-buildtools gets installed...
19:58:37 <hpaste> Qata pasted “:<” at http://hpaste.org/48690
19:58:40 <tommd> Qata: Are you familure with the concept of paths?
19:58:43 <Cale> bin should *not* be a plain file
19:58:52 <Qata> tommd: not entirely.
19:59:14 <tommd> so if you type "ls -l ~/.cabal" what do you get?
19:59:17 <Qata> Cale: I installed gtk2hs-buildtools first
19:59:25 <Cale> It looks like it's not installed properly
19:59:39 <tommd> Qata: If so, then you should just be able to run "export PATH=$PATH:~/.cabal/bin"
19:59:40 <Qata> -rw-r--r--  1 legend  staff  2644 Jul  3 23:16 config
19:59:41 <Qata> -rw-r--r--  1 legend  staff  2644 Jul  3 23:16 config.platform
19:59:42 <tommd> Qata: And install gtk
19:59:50 <tommd> oh, well, that says you don't have a bin
19:59:51 <Cale> At the commandline, when you type a command, the shell searches in a certain (configurable) set of directories, called the PATH to see if there's a program with that name
20:00:23 <Cale> cabal will install programs to the directory ~/.cabal/bin/
20:00:37 <Cale> I'm not sure what it does if that file exists and is not a directory, it probably gives up.
20:01:12 <Qata> alright, tommd I'm trying this
20:01:14 <Qata> lets see
20:01:20 <Cale> But regardless of that, even if it does install the program correctly there, you still need to make sure that ~/.cabal/bin is one of the directories in your PATH variable
20:01:20 * Qata crosses fingers
20:01:29 <Qata> it isn't
20:01:36 <Qata> I'm pretty sure I installed it correctly.
20:01:58 <elliott_> if you did, it would work :)
20:02:03 <Qata> good point
20:02:09 <Qata> Ok, I'm trying again.
20:05:20 <Qata> Ok, tommd, Cale
20:05:21 <Qata> I tried again
20:05:28 <Qata> installing from scratch after specifying path
20:05:34 <Qata> still no dice.
20:06:32 <Cale> Run the command:  which gtk2hsC2hs
20:06:37 <Cale> on the commandline
20:06:41 <Cale> what does it tell you?
20:08:15 <Cale> If it prints nothing, then the gtk2hs buildtools aren't in your path.
20:08:35 <Cale> (you could also safely just try to run  gtk2hsC2hs
20:08:37 <Cale> )
20:09:01 <Cale> It should say something like "Supply the header file followed by the binding file"
20:10:25 <Qata> -bash: gtk2hsC2hs: command not found
20:10:30 <Cale> yeah, okay
20:10:37 <Cale> So, cd ~/.cabal/bin
20:10:41 <Cale> and then ls
20:11:11 <elliott_> are we sure the installation of whatever puts things into ~/.cabal/bin is actually succeeding here?
20:11:14 <Qata> -bash: cd: /Users/legend/.cabal/bin: No such file or directory
20:11:20 <Cale> okay
20:11:24 <Cale> So that's a problem
20:11:30 <Cale> cd ~/.cabal/
20:11:40 <Cale> mkdir bin
20:11:59 <Qata> done.
20:12:01 <Cale> and then  cabal install gtk2hs-buildtools
20:12:02 * elliott_ suspects that gtk2hs-tools is just failing during the build
20:12:07 <elliott_> that would explain ~/.cabal/bin not existing.
20:12:13 <Qata> cd into the bin folder?
20:12:14 <elliott_> it's not like it isn't normally created automatically
20:12:22 <elliott_> Qata: doesn't matter which directory you're in when using cabal install
20:12:23 <Cale> yeah, that's probably failing because it would normally create the directory on its own
20:12:37 <Qata> ok
20:12:42 * Qata crosses fingers again
20:13:08 <ivanm> *sigh* switching data structures after you have a large working program is a PITA
20:13:18 <ivanm> even something simple as a real type instead of tuples
20:13:23 <elliott_> Qata: after that cabal command finishes, try "echo $?"
20:13:30 <elliott_> if it's not 0, there's a problem, and you should hpaste.org the output of cabal
20:13:49 <Cale> ivanm: Not as much of a pain as it is in scheme
20:13:57 <Cale> ;)
20:14:00 <Qata> ok
20:14:00 <ivanm> heh
20:14:26 <Qata> echo $
20:14:28 <Qata> I get $
20:14:36 <elliott_> Qata: um with the ? included.
20:14:38 <Cale> noooo
20:14:40 <Qata> no
20:14:41 <Qata> haha
20:14:41 <Cale> heh
20:14:41 <Qata> ok
20:14:44 <Cale> too late now
20:14:48 <Qata> k
20:14:48 <elliott_> oh, indeed
20:14:50 <Qata> it's a 0
20:14:52 <elliott_> too late
20:14:56 <Qata> ok
20:14:57 <elliott_> hpaste.org the output of cabal, anyway
20:14:57 <Cale> $? is the status of the last command you ran
20:15:02 <Cale> which was now echo :)
20:15:06 <elliott_> easy to tell from that whether it failed or not
20:15:07 <elliott_> well, hopefully.
20:15:12 <elliott_> unless cabal crashed or something :D
20:15:25 <pchiusano> what is the difference between import Foo.Bar as F and import qualified Foo.Bar as F  ?
20:15:41 <hpaste> Qata pasted “build log” at http://hpaste.org/48691
20:15:42 <elliott_> pchiusano: the former also imports all of Foo.Bar's names into the current scope
20:15:52 <Cale> pchiusano: With the qualified, you're *required* to qualify the names from that module when you use them
20:15:54 <elliott_> pchiusano: I guess so you can qualify clashing names if necessary
20:15:57 <elliott_> pchiusano: It's kind of ugly though
20:16:07 <elliott_> "import Foo as Bar" triggers my typo sensors
20:16:11 <elliott_> I don't know why you would use it
20:16:23 <Cale> You'd use it when Bar was much shorter than Foo
20:16:25 <elliott_> Qata: aha
20:16:27 <Qata> elliott_: what do you think?
20:16:28 <Qata> :P
20:16:30 <Qata> ahhhh
20:16:33 <elliott_> Qata: you have cabal-install set to install globally.
20:16:35 <Qata> I think you see something that I don't
20:16:37 <Qata> ok.
20:16:39 <Cale> import Data.Map as M
20:16:40 <elliott_> you should fix that
20:16:41 <Qata> so how do I change that?
20:16:42 <Cale> import Prelude as P
20:16:44 <pchiusano> wait, so import Foo.Bar as F has basically no effect? it still imports everything
20:16:44 <elliott_> Cale: yes so use it qualified?
20:16:50 <elliott_> Cale: that would mess up tons of Prelude functions doing it like that
20:16:55 <Cale> elliott_: Use it qualified when there are clashes
20:16:55 <elliott_> Qata: ok, open ~/.cabal/config in your favourite text editor
20:17:11 <elliott_> Cale: if there are no clashes, why give it an abbreviated name? just use the imported names directly
20:17:21 <Qata> elliott_: then what?
20:17:27 <Cale> pchiusano: yes, it imports things, but when you get a clash, you can use F.whatever to disambiguate
20:17:27 <elliott_> Qata: find the line that looks like
20:17:30 <elliott_> -- user-install: True
20:17:30 <ddarius> pchiusano: It has the effect of also naming Foo.Bar.x, F.x.
20:17:31 <Cale> instead of Foo.Bar.whatever
20:17:34 <elliott_> or anything with user-install, really
20:17:35 <elliott_> change it to
20:17:36 <elliott_> user-install: True
20:17:39 <elliott_> with no dashes, and save the file
20:17:48 <elliott_> hmm, although gtk2hs-buildtools is already installed globally now
20:17:53 <elliott_> and uninstalling cabal packages is a pain :/
20:17:59 <pchiusano> i see, are clashes type errors?
20:18:03 <Qata> ok
20:18:05 <Qata> I changed it.
20:18:10 <elliott_> Qata: well, do the PATH thing but with ~/Library/Haskell/ghc-7.0.3/lib/gtk2hs-buildtools-0.12.0/bin rather than ~/.cabal/bin :P
20:18:11 <Qata> should I just reinstall.
20:18:12 <ddarius> pchiusano: No, they are syntax errors.
20:18:20 <Qata> ok
20:18:23 <elliott_> you can't really reinstall because it is already installed and there is no uninstall
20:18:24 <Qata> so should I revert my file changes?
20:18:31 <elliott_> <Cale> pchiusano: yes, it imports things, but when you get a clash, you can use F.whatever to disambiguate
20:18:34 <elliott_> this irks me
20:18:39 <elliott_> why would you have clashing names in scope?
20:18:41 <edwardk> glguy: nice! =)
20:18:43 <elliott_> Qata: yeah, probably the best idea
20:18:53 <elliott_> Cale: I mean, as opposed to hiding what clashes
20:18:55 <elliott_> and importing again qualified
20:19:09 <ddarius> elliott_: If a module evolves to add an identifier that you don't use, do you want your code to require changes?
20:19:10 <Cale> elliott_: Well, you can do that too...
20:19:18 <pchiusano> okay, so it seems like you should pretty much always import qualified as, or just import qualified
20:19:26 <elliott_> Cale: That just seems a lot cleaner to me.
20:19:28 <ddarius> pchiusano: That is what happens in practice.
20:19:42 <Qata> alright
20:19:46 <Qata> caballing gtk
20:19:47 <elliott_> ddarius: Indeed not, but that is a fault of Haskell's module system pretty much any way you slice it; the only resolution is to import everything qualified, or list every single import you use.
20:19:54 <elliott_> ddarius: Ideally we'd have module signatures blah blah blah.
20:20:08 <edwardk> evenin pchiusano, long time no see in these parts =)
20:20:22 <pchiusano> hey edwardk :)
20:20:29 <hpaste> Qata pasted “more errors :<” at http://hpaste.org/48693
20:20:34 <Qata> elliott_:  ^^
20:20:57 <elliott_> Qata: you need pkg-config. I suspect you already have it but it's not in your PATH
20:21:04 <elliott_> What was it on OS X again... /Developer/bin/pkg-config?
20:21:14 <Qata> I'd assume so
20:21:16 <Qata> let me go check
20:21:55 <edwardk> ddarius: made quite a bit of progress on the ring code. have the endomorphism ring, opposite ring, bezout domains, etc. working up better ideals, polynomail representations, etc.
20:21:56 <pchiusano> ddarius and elliott_ and Cale - thanks for explanations
20:21:59 <zmoazeni> Can someone help point me in the right direction on interpreting this expression from http://happstack.com/docs/crashcourse/HappstackState.html - "$(deriveSerialize ''Counter)" - at first I was thinking it was the prefix version of derviceSerialize $ ''Counter, but I'm not so sure anymore from playing in ghci. Also I can't figure/google what the single quotes before Counter do.
20:22:05 <Qata> elliott_: no /bin file in developer.
20:22:15 <ddarius> elliott_: You are free to import everything qualified or explicitly list all your imports.
20:22:15 <edwardk> polynomial even
20:22:16 <kmc> zmoazeni, it's a Template Haskell splice
20:22:32 <elliott_> Qata: directory, not file. :) Eh, I will step out until someone who knows where pkg-config is likely to be says something.
20:22:36 <elliott_> It might even be in your Gtk installation...
20:22:37 <kmc> zmoazeni, read the GHC manual section on Template Haskell, and maybe the original TH paper
20:22:44 <ddarius> edwardk: Have you figured out sigma algebras yet?
20:22:52 <Qata> elliott_: I meant directory
20:22:55 <zmoazeni> Ahh, I see the {-# LANGUAGE TemplateHaskell, CPP #-} declaration at the top of SerliazeTH.hs
20:22:56 <Qata> but it's not there nonetheless.
20:22:58 <dankna> my pkg-config is in /usr/local/bin
20:23:07 <zmoazeni> Thanks kmc
20:23:08 <kmc> zmoazeni, it's compile-time metaprogramming.  the function deriveSerialize returns a Haskell abstract syntax tree which is spliced into the code at that position
20:23:12 <dankna> I presume that means it doesn't come with the system, or didn't when I installed it
20:23:12 <kmc> '' is a way to quote a type name
20:23:15 <elliott_> dankna: right, but unless Qata has been using a package manager or manually compiling, I doubt they will have it there
20:23:33 <edwardk> ddarius: i replied to the RandProc guy about how the ones in his package aren't sigma algebras, but i haven't heard back
20:23:34 <dankna> right, but I mean, I wouldn't have put a copy there unless I couldn't find it anywhere else
20:23:45 <Qata> I installed xcode 4.1 before I installed the haskell library.
20:23:48 <edwardk> it seems in the constructive setting you just have fields rather than sigma-fields
20:24:08 <edwardk> and you make up for it in the measure definition
20:24:43 <elliott_> edwardk: can I ask if you have any opinions on lenses with efficient modify? i.e., being conceptually build out of get and modify rather than get and set. I can't actually tell which approach data-lens takes, actually, because I haven't looked at StoreT yet...
20:24:50 <Qata> elliott_: Are you talking about the application ''PackageMaker''?
20:24:52 <elliott_> It seems that none of the lense-esque packages on Hackage have this
20:24:56 <Qata> in which case, I have that.
20:25:01 <edwardk> elliott_: the ones i use have an efficient modify
20:25:09 <elliott_> edwardk: data-lens, that is?
20:25:10 <edwardk> elliott_: a -> (b, b -> a)
20:25:10 <elliott_> Qata: no
20:25:13 <edwardk> yes
20:25:14 <Qata> :<
20:25:17 <edwardk> that shares the work
20:25:25 <elliott_> edwardk: ah. I have a prototype efficient-modify version here that looks like
20:25:29 <elliott_> data Lens a b = Lens { get :: a -> b, modify :: (b -> b) -> a -> a }
20:25:34 <elliott_> it has some nice properties, like   Lens g m . Lens g' m' = Lens (g.g') (m'.m)
20:26:16 <elliott_> and IMO manual lens definitions are very readable with that, but I haven't used data-lens myself, so I wouldn't be able to comment on how it compares really...
20:26:22 <edwardk> yes, but that is worse for cases where you, say, want to take a function from b -> f a.
20:26:30 <elliott_> right
20:26:36 <elliott_> hmm
20:26:51 <edwardk> this is why the optimal split is to fuse the getter and setter
20:27:01 <glguy> edwardk: Was the point of switching from Codensity to Yoneda purely theoretical, or do you end up with additional flexibility / additional performance?
20:27:08 <elliott_> I've mostly avoided data-lens because of the operator names seeming cluttered to me -- no offence -- maybe I should take a closer look :)
20:27:17 <edwardk> glguy: honestly, it made the type a lot easier to read
20:27:36 <glguy> edwardk: I haven't done my second readthrough to actually understand part 2
20:27:59 <edwardk> in some cases the codensity implementation may actually still be faster
20:28:22 <Qata> dankna: I have /usr/bin/pkgbuild
20:28:23 <Qata> :/
20:28:33 <dankna> unrelated
20:29:05 <glguy> edwardk: and the point of improve is that the only Monad instance directly on the Free type has to dig through a stack of Wraps which continues to accumulate on the left side of binds?
20:29:08 <elliott_> edwardk: can I ask why you chose e.g. (^$), (^%=)? I just find those really ugly personally
20:29:14 <edwardk> glguy: but it is nice that you can actually think through the yoneda'd implementation, rather than the codensity one, the yoneda one makes it easy to figure out where the terms should go. there is a bit too much flexibility in the codensity presentation, being isomorphic to the composition with its adjoint
20:29:16 <elliott_> I haven't read any code using data-lens though
20:29:52 <edwardk> elliott: to let the state ones be pretty =)
20:30:04 <Qata> elliott_: I ran gtk2hsC2hs
20:30:09 <Qata> and got the following lines
20:30:11 <edwardk> http://hackage.haskell.org/packages/archive/comonad-transformers/1.5.2.6/doc/html/Data-Lens-Strict.html
20:30:21 <hpaste> Qata pasted “gtk2hs” at http://hpaste.org/48694
20:30:24 <Qata> ^^
20:30:24 <elliott_> edwardk: you call (^!*=) pretty? :D
20:30:36 <elliott_> Qata: good, that means you are finished with that step.
20:30:44 <edwardk> *=, -=, etc.
20:30:48 <elliott_> ah, that's nicer.
20:30:55 <zmoazeni> kmc: Ok, it makes a little more sense what's going on. But that certainly is going to go on the "grok later" shelf. I'm feeling dizzy. Thanks for the pointer.
20:30:59 <edwardk> the ^ is a cue its the non-state presentation
20:31:00 <elliott_> I dunno though, I feel like I use non-state versions as much as I do state versions
20:31:14 <edwardk> so its ^ prepended on to the state version
20:31:19 <nswill> I have a question about Parsec. If I want to use the user state to keep track of how many tokens I read with one specific parser sub expression, it seems that all of the parser combinators require me to spread that same user type to all of my parser sub expressions. ie you can't mix user types in a single parser monad. It seems to me if I want to mix user types I have to split my stream and run a sub parser monad. Is this how I'm supposed 
20:31:20 <nswill> handle this situation? Or is there some more clever way to do this I'm missing?
20:31:50 <edwardk> and ! indicates that it is being done, so its a $! analogue
20:31:58 <edwardk> er being done strictly so
20:32:17 <kmc> zmoazeni, yeah, for now you can just think of it like they've extended GHC to allow "deriving Serialize"
20:32:30 <edwardk> ^$! is a lens analogue to $!
20:32:34 <kmc> with funny syntax
20:32:51 <edwardk> and its not in state so it has the ^
20:33:18 <elliott_> edwardk: maybe I should just make my very own special data-lens wrapper with all my best perfect excellent-taste operator names :P
20:33:26 <edwardk> ultimately there are only so many symbols, and the library is designed to work unqualified with all my other libraries, so i had to make some compromises
20:33:51 <elliott_> unicode!
20:33:54 <edwardk> but my goal was to make the state versions as clean as possible
20:33:56 <elliott_> THOUSANDS of characters to choose from!
20:34:21 <elliott_> Look at this fine specimen -- ⏥ U+23E5 FLATNESS!
20:34:33 <edwardk> if you ignore the ^! ones, which are admittedly a bit of an acquired taste, they arent bad =P
20:34:42 <zmoazeni> kmc: Either way, I learned that if I can track down part of the function definition to first check the top of the file for extensions. That helps in figuring out if it's plain ol' language defined or coming from an extension.
20:35:03 <edwardk> the goal was internal consistency, so that once you knew what the general shape of the operators was you could reach for them without looking them up
20:35:25 <kmc> ^!^
20:35:27 <edwardk> and i have twice as many to deal with because i provide the strict versions of everything
20:36:49 <elliott_> just put !!!!!! after every strict operator
20:37:05 <elliott_> it'll only be as ugly as every other piece of hyper-strict code :)
20:37:15 <kmc> zmoazeni, yeah, there aren't that many extensions which add "surprising" new syntax
20:37:20 <kmc> TemplateHaskell is definitely one of them
20:38:02 <cmccann> most "surprising new syntax" is added by libraries written by people who really like infix operators
20:38:17 <zmoazeni> Good to know
20:38:58 <edwardk> the main thing i don't like about the api is that in order to lay it out optimally for haskell i have to put the ugliest operators in the Data.Lens.Common module, because i can't put the state monad operations in the same place, being that there are 3 sets of them
20:39:07 <Jafet> Too bad the hieroglyphs are classified as letters
20:39:09 <Cale> Libraries in Haskell can blur the lines between what's a library and what's a language, a bit more often than most people might be used to though.
20:39:11 <elliott_> edwardk: hmm, i'm actually not sure why my definition makes (b -> f a) more difficult/worse...
20:39:19 <elliott_> I thought I understood but I don't :)
20:39:26 <kmc> Cale, not as much as Lisp though! :)
20:39:40 <cmccann> Jafet, I'm still unhappy that lambda is a letter :[ no unicode syntax...
20:39:44 <edwardk> the two haskell 98 ones in data-lens, and the fd based ones in data-lens-fd
20:39:48 <Cale> Well, maybe. :)
20:40:11 <Cale> We don't use our macro system all that much.
20:40:15 <cmccann> kmc, Lisp is more consistent in how libraries introduce new syntax though
20:40:18 <cmccann> namely they don't
20:40:21 <Jafet> What if you're working in a domain that uses it as a letter!
20:40:25 <elliott_> cmccann: uh-huh?
20:40:25 <Cale> But even without macros, the things people do in Haskell tend to be pretty fancy.
20:40:29 <elliott_> cmccann: Ever heard of the read table??
20:40:30 <cmccann> which is consistent with lisp itself, which also has no syntax
20:40:37 <elliott_> ok, surely you are trolling now :)
20:40:39 <cmccann> it's just a glorified AST
20:40:47 <Cale> That's kind of a lie though
20:40:50 <elliott_> so sufficiently simple syntaxes aren't syntaxes?
20:40:59 <Cale> The thing about lisp not having much syntax
20:41:00 <elliott_> better add some more kludges to haskell, or it might stop counting as a language
20:41:02 <edwardk> elliott_: it was one of the versions i rejected. the reason is if i have an a, and a function from a -> (b, b -> a), i can extract a b, then fmap the b -> a function over the result of my b -> f b intermediate result
20:41:04 <Cale> There are a lot of special forms
20:41:06 <Cale> in lisp
20:41:12 <edwardk> yielding an f a
20:41:12 <Cale> they just have very similar concrete syntax
20:41:20 <edwardk> you can't do that with the 'efficient modify version
20:41:31 <edwardk> you _can_ however mess around and try to make one that has a rank 2 type
20:41:37 <elliott_> edwardk: hm, right
20:41:46 <cmccann> elliott_, yes I'm joking, but compared to most other languages, S-expressions really do resemble the output of the parser more than the typical input :P
20:41:56 <edwardk> (a -> b, forall f. Functor f => (b -> f b) -> a -> f a)
20:42:05 <kmc> cmccann, new abstract syntax counts as new syntax
20:42:10 <kmc> i'm sick of Lisp zealots telling me that Lisp has no syntax
20:42:20 <kmc> is it (let ((x a) (y b)) ...) or (let (x a) (y b) ...) ?
20:42:29 <kmc> that sounds like a syntactic question to me
20:42:32 <elliott_> Lisp zealots don't say that
20:42:32 <edwardk> but that one knows nothing about the functor, so the polymorphic function it supplies is going to just call fmap, and not recycle any of the work from the breakdown of a into b.
20:42:35 <elliott_> Lisp haters say that
20:42:36 <elliott_> at least IME
20:42:46 <edwardk> so that version is less efficient
20:42:49 <kmc> IME the people advocating Lisp say it too
20:43:02 <edwardk> the costate comonad coalgebra approach leads to the most efficient implementation overall
20:43:03 <kmc> as some argument about why Lisp is easy to learn
20:43:17 <kmc> edwardk, i think you can factor out a "co" there
20:43:26 * cmccann seems to recall that S-expressions were created as the result of post-processing what was supposed to be the "real" syntax, but people just used them as-is
20:43:29 <edwardk> co (state monad algebra) ;)
20:43:30 <elliott_> (I really wish we could stop calling people zealots because they like something a lot... it seems to be slung at anyone who has a lot of enthusiasm about something)
20:43:36 <elliott_> cmccann: yeah :)
20:43:38 <elliott_> M-exprs
20:43:38 <kmc> > unwords . map ("co"++) $ words "state monad algebra"
20:43:40 <lambdabot>   "costate comonad coalgebra"
20:43:42 <Cale> yeah, lisp was originally intended to have M expressions
20:43:51 <Cale> If you want to see a language like that, look at Mathematica ;)
20:44:02 <kmc> isn't there also some proposal for encoding S-exprs with whitespace?
20:44:14 <kmc> anyway, once again my point is proven
20:44:17 <Cale> It has M-expressions as the core of its language. (Plus a ton of special 2D math syntax)
20:44:20 <kmc> that it is impossible to talk about Lisp
20:44:25 <kmc> online
20:44:29 <kmc> due to endless discussion of lexical syntax
20:44:30 <elliott_> Really? Looks like we just talked about Lisp.
20:44:35 <cmccann> anyway, saying "lisp has no syntax" is mostly a statement about how easy it is to turn text input into a proper AST, which is objectively easier in Lisp than almost anything else
20:44:36 <edwardk> kmc: =)
20:44:40 <elliott_> kmc: you are the one who brought up lexical syntax :P
20:44:52 <edwardk> elliott: well, that is one way to prove his point ;)
20:44:56 <kmc> cmccann, but the AST is not an AST in the sense of other languages
20:45:05 <edwardk> all he has to do is track down any discussion about lisp and bring up lexical syntax
20:45:10 <kmc> that's only valid if you think of Lisp as a data language for describing nested lists
20:45:11 <kmc> a la xml
20:45:23 <cmccann> anyway, the most important thing here, I think, is lexical syntax of comments
20:45:23 <elliott_> edwardk: ah, the politician's approach!
20:45:31 <kmc> if you want to talk about Lisp the *programming language* with various *special forms* analogous to the *lambda calculus*
20:45:43 <kmc> then you have to ask "is it (define f (x y) ...) or (define (f x y) ...)"
20:45:54 <kmc> more syntax
20:45:58 <mike-burns> People who say Lisp has no syntax have never tried teaching it to high school students.
20:46:07 <kmc> Lisp has three layers of syntax where most languages have two
20:46:11 <edwardk> mike-burns: very true =)
20:46:18 <zmoazeni> http://xkcd.com/224/
20:46:28 <cmccann> kmc, yes, but I'd still rather write a parser for Scheme than for Haskell :P
20:46:38 <elliott_> kmc: oh come on :P
20:46:58 <edwardk> i'm rather with keegan on this one
20:47:11 <elliott_> you know, #lisp-nitpicking is a much more boring channel than #haskell :P
20:48:16 * Saizan suggests an ignore on lisp.*syntax to everyone
20:48:42 <kmc> :)
20:48:44 * cmccann doesn't really understand why lisp syntax is such a contentious issue anyway :I
20:49:12 <Saizan> because people keep bringing it up as something truly special when it isn't
20:49:47 <edwardk> cmccann: well, they have so little of it so they few points of debate that they have available are the backbone of internal religious strife. they have no room to negotiate on dogma )
20:49:52 <kmc> :D
20:50:01 <cmccann> edwardk, ah yes of course, good point
20:50:12 <kmc> i think the three-level syntax is the great strength of Lisp; I think people should be honest about it instead of claiming the top level doesn't exist
20:50:25 <cmccann> kmc, which are you calling the "top level" there?
20:50:35 <ddarius> Actually, Common Lisp's lexical syntax, even ignoring reader macros, is much more complicated than Haskell's.
20:50:40 <edwardk> cmccann: the s-expressions
20:50:53 <kmc> cmccann, how to interpret nested lists as an executable program
20:50:59 <kmc> questions like "is it (define f (x y) ...) or (define (f x y) ...)"
20:51:05 <kmc> you can't claim that's *not* syntax
20:51:14 <cmccann> well, it's pretty self-evident that s-expressions exist syntactically :P
20:51:19 <kmc> in fact Common Lisp, Scheme, and Clojure make different choices here
20:51:52 <elliott_> Saizan: I sure wish semantic ignores existed
20:51:58 <kmc> each special form adds new syntax rules
20:52:04 <kmc> elliott_, feel free to propose a Haskell-related topic
20:52:37 <cmccann> kmc, I suspect a lot of it comes down things blurring the line between syntax and library APIs, at least visually
20:52:46 <elliott_> kmc: Implementing Scheme in the type system
20:52:47 <cmccann> which is something that comes up in Haskell as well, I've seen
20:52:54 <elliott_> Also: implementing Oleg in the type system.
20:52:54 <edwardk> then of course there is the great hygiene debate. i suppose one could say something particularly nasty about how many discussions between schemers devolve into how much hygiene is too much or too little. ;)
20:52:57 <cmccann> elliott_, pretty sure Oleg's already done that
20:53:07 <elliott_> cmccann: But has he ported HIMSELF yet????
20:53:22 <ddarius> Saizan: I agree that there is absolutely nothing significant about Lisp syntax (other than, I guess, the fact that CL lets you have infinite syntax...)
20:53:25 <kmc> if Oleg lurks here I'm sure he thinks we're all a bunch of creepy stalkers
20:53:35 <edwardk> s/schemers/schemers and lispers/
20:53:39 <elliott_> kmc: Oh, he doesn't. I know everywhere Oleg lurks... EVERYWHERE...
20:54:00 <kmc> i enjoyed the earlier discussion of writing Haskell code with underhanded security flaws
20:54:03 <kmc> it put some ideas into my head
20:54:07 <edwardk> kmc: he doesn't, but he is aware of the oleg norris facts ;)
20:54:13 <elliott_> kmc: in the type system
20:54:20 <kmc> i think an Underhanded Haskell Code Contest would be fun
20:54:48 <ddarius> edwardk: There's no question that CLers are dirtier than Schemers.
20:55:11 <elliott_> they're unwashed and smelly
20:55:13 <elliott_> just like the french
20:55:22 <elliott_> now, french CLers...
20:55:26 <cmccann> edwardk, I've only dabbled in lisp-family stuff, though Scheme was my first intro to any sort of functional programming, a lot of the stuff that happens around various lisps kinda baffles me :T
20:55:39 <cmccann> but I've found Haskell much more to my taste these days, so eh
20:56:47 <aspect> as an ex-schemer trying to get my head around haskell, I've got to say the amount of syntax is what consistently gets in the way
20:56:58 <edwardk> cmccann: i really like scheme and racket in many ways. the hygienic-by-default approach goes far, mandatory tail call optimization, etc. make for a nice language. i dont like some corners of r5rs scheme, in particular the ones that made it so you have to do crazy analysis to do eta-reduction
20:57:25 <aspect> .. and respectfully bow out of the discussion - surely there's something more on-topic and less religious that can be discussed :-)
20:57:36 <cmccann> edwardk, yeah, I don't think I spent enough time with it to really get a feel for the implications of stuff like that
20:57:37 <elliott_> edwardk: I hate how Scheme is "objects are never freed ever garbage collection is an implementation detail" one second and then "YOU MUST NOT ALLOCATE STACK FRAMES FOR A CALL IN TAIL POSITION" the next :(
20:57:37 <edwardk> by comparison lisp just makes me sad, its like python. TCO probably doesn't work. you have to fight with horrible loop constructs, etc.
20:58:04 <elliott_> It sets up my hopes for pages of academic wonder disconnected from any physical reality and then makes me cry and think about bits.
20:58:18 * elliott_ sensitive functional programmer
20:58:43 <monqy> :'(
20:58:45 <cmccann> on the other hand, I kind of like the idea of a Haskell dialect with syntax based on S-expressions, seems like the perfect way to provoke a maximal number of ridiculous arguments about syntax
20:58:51 <ddarius> elliott_: Tail call optimizations doesn't require thinking about bits.
20:58:55 <elliott_> cmccann: Liskell (it's kind of bad)
20:59:04 <elliott_> ddarius: they could have phrased it in a nicer way, though :)
20:59:14 <elliott_> I'm not sure how
20:59:35 <cmccann> elliott_, last time I looked Liskell seemed to be abandoned, though I could be wrong
20:59:40 <ddarius> elliott_: It's actually somewhat tricky to do.
20:59:49 <elliott_> cmccann: sure, it proved it was a bad idea :P
20:59:49 <edwardk> stack frames for tail calls is important because it impacts space performance. gc can't reclaim the stack, so talking about the parts that the gc can't effectively address is important. talking about gc would make too many previous implementors feel constrained
21:00:07 <edwardk> remember as a document r5rs was trying to evoke a consensus among a wide variety of implementors
21:00:27 <edwardk> r6rs on the other hand is a horrible monstrosity full of unimplementable crap
21:00:27 <elliott_> edwardk: sure gc can reclaim the stack
21:00:29 <elliott_> see spaghetti stack
21:00:47 <Cale> It seems to me that the stack itself should be an implementation detail though
21:00:55 <elliott_> you just have to stop treating invocation records specially :P
21:00:57 <Cale> Why must there exist a stack?
21:01:10 <elliott_> Cale: well call/cc is tricky to specify without it
21:01:12 <edwardk> as someone who currently has to spend half his time rewriting crap in scala to work around their lovely choice of how to deal with crap on the stack i have very little sympathy for folks who want to let tail calls suffer ;)
21:01:17 <elliott_> Cale: but: there doesn't exist a stack in Scheme, AFAIK
21:01:18 <cmccann> elliott_, being a bad idea was part of my interest in the idea, recall :P
21:01:24 <elliott_> except maybe for one paragraph when tail calls are mentioned
21:02:08 <edwardk> for instance, i can't even use a fold right on a stream in scala, because odersky refuses to let in any patches that would actually make it work, because they complicate the ability to reason about the code =(
21:02:41 <ddarius> @google "Proper tail recursion and space efficiency"
21:02:42 <lambdabot> http://portal.acm.org/citation.cfm?id=277719
21:02:43 <lambdabot> Title: Proper tail recursion and space efficiency
21:02:44 * elliott_ throws Odersky in the van Rossum Pile
21:02:59 <cmccann> edwardk, I've been considering learning scala, think it's worth playing with? stuff like that seems kinda off-putting :I
21:03:06 <dolio> That's because of the type, though, isn't it?
21:03:10 <Guest38561> Sorry bothering. I am trying out the online Tutorial for haskell. My first lines. :-) Question: The interpreter keeps telling me "Terminated!" after each time I enter something and hit ENTER. Why is that?
21:03:12 <dolio> Not because of tail recursion.
21:03:16 <edwardk> and most implementations want to live on a real c stack, because they have ffi concerns
21:03:16 <edwardk> and spaghetti stacks, etc. are hard to make work in this era of pthreads, etc.
21:03:42 <Guest38561> + for+
21:03:44 <elliott_> edwardk: You don't need a C stack to FFI to C.
21:03:44 <ddarius> elliott_: You don't need a stack to specify call/cc, and it's definitions have traditionally not used any notion of stack.
21:03:44 <Cale> Guest38561: which interpreter are you using?
21:04:04 <Guest38561> Clae, the one on http://tryhaskell.org/
21:04:12 <Cale> Guest38561: Maybe a server problem
21:04:15 <elliott_> edwardk: C code that doesn't invoke ker-aazy undefined behaviour (that would break any language implementation anyway, i.e. fiddling with the stack) won't care about the stack frame below the one it's in, on any architecture I know.
21:04:25 <edwardk> dolio: the foldright for streams is problematic because they tie evaluation to the jvm stack. pchiusano had a nice patch to fix that, allocating a local growable array and doing the necessary pumping, so that foldr wouldn't use n stack frames for n items
21:04:25 <elliott_> So you just need little C stack frames dotted about the place in your stack of any sort. :p
21:04:30 <Cale> yeah, it sounds like the evaluation server is down
21:04:33 <lispy> Is there a way to force my code to run on the first thread that ghci gets?
21:04:38 <edwardk> dolio: but the patch was rejected.
21:04:38 <Guest38561> Cale, good to know. I thought I wasn't getting it right. Thanks!
21:04:57 <Cale> preflex: seen ChrisDone
21:04:57 <preflex>  ChrisDone was last seen on #xmonad 10 hours, 8 minutes and 31 seconds ago, saying: x
21:05:01 <Cale> hrm
21:05:07 <dolio> edwardk: Ah, so even if it's lazy, it still uses stack.
21:06:06 <ddarius> preflex: seen chrisdone_
21:06:06 <preflex>  chrisdone_ was last seen on #haskell 9 hours, 23 minutes and 54 seconds ago, saying: * chrisdone_ decides to move it to the new vps
21:06:09 <edwardk> elliott_: as someone who has had to construct stacks that comply with libpthread's expectations, its uglier than that. recall if you're binding to that becauseyou want to talk to almost any c library, there are assumptions about the relative position of where errno gets stored, information about thread locals, etc.
21:06:16 <styfle> hello
21:06:20 <Cale> hello
21:06:47 <elliott_> edwardk: well yeah, pthreads makes it uglier.
21:06:53 <edwardk> elliott_: interacting with any c library written in the last 15 years means giving up a fair bit of control over the stack layout
21:06:54 <elliott_> edwardk: but it's not impossible.
21:06:57 <styfle> is tryhaskell.com not working?
21:07:05 <edwardk> elliott_: though hardly worth it
21:07:08 <styfle> i mean .org
21:07:22 <elliott_> edwardk: Sure it is, if you're implementing something with complex non-local control and you want it to be efficient
21:07:27 <Cale> Yeah, it appears to be down :/
21:07:52 <Cale> (well, whatever server-side program does evaluation isn't working anyway)
21:07:57 <styfle> is it possible to build haskell from source and not install it...i just want to try it out
21:08:20 <Cale> styfle: Don't build GHC from source. Just get a binary of it for whatever platform you're on
21:08:21 <ivanm> styfle: by "Haskell" you mean GHC?
21:08:37 <ivanm> why not install it?
21:08:46 <styfle> because i am only using it for 1 week
21:08:51 <styfle> its for 1 assignment :/
21:08:59 <ivanm> and you can't uninstall afterwards?
21:09:11 <Cale> (GHC takes forever to compile, and requires that you have an existing installation of GHC to compile anyway)
21:09:23 <styfle> yeah i didnt have much luck with GHZ or HUGS
21:09:27 <styfle> GHC*
21:09:32 <Cale> styfle: hrm
21:09:34 <parcs> styfle: what os?
21:09:38 <edwardk> elliott_: my approach there has mostly been to throw an exception, unwind the stack, stackhack style, pushing inverted frames out onto the heap. the excuse is that at that point in time i can put them into a workstealing deque rather than a stack anyways. so most of my local control is done on a stack, but once i fill it up (chicken-scheme style) or try to capture a continuation it flushes to the deque, enabling workstealing
21:09:46 <styfle> i tried on Mac OS and on CentOS
21:10:00 <mauke> hugs should compile just fine
21:10:21 <ivanm> Cale: doesn't take _forever_ ...
21:10:24 <elliott_> edwardk: well, that's kind of gross, though. :)
21:10:46 <Cale> Yeah, not technically forever. Just long enough that you don't want to be the one to do it yourself.
21:10:59 <edwardk> then the stack works like a cache. when you steal work you start building frames locally, so enqueueing into the deque is only paid for at the site of control effects or upon the stack exploding in size, and i only pay for deque rendezvous at the bottom of the stack, and only for fences when stealing or when i drain the deque dry
21:11:03 * ivanm begs to differ
21:11:05 <elliott_> Cale: pah, ghc compilers unite
21:11:10 * elliott_ waves a little flag
21:11:27 <parcs> it can take forever if you're building the latest git version
21:11:32 <elliott_> edwardk: This is preferable to just doing the hackery necessary to make pthreads happy? I can hardly see that being /less/ work
21:11:46 <edwardk> elliott_: its kinda ugly in that i compile the same code 4 times ;). stack version, continuation marshalling, and deque fast path and deque slow path.
21:11:52 <edwardk> yes, because i can do work stealing
21:12:05 <edwardk> the constant factors are actually really nice compared to cilk
21:12:08 <elliott_> Eh, compiling code multiple times isn't a problem per se
21:12:22 <styfle> mauke: have you compiled hugs on Mac OS X 10.6?
21:12:26 * elliott_ is speaking from a VM point of view anyway, as opposed to you from a compiler(?) point of view
21:12:27 <mauke> styfle: no
21:12:31 <elliott_> Well, JIT
21:12:33 <edwardk> and it allows for nice ffi
21:12:43 <styfle> mauke: then how do you know it works just fine?
21:12:43 <cmccann> GHC compiles in a finite amount of time
21:12:49 <mauke> styfle: I compiled it on linux
21:12:56 <mauke> styfle: how does it fail for you?
21:13:24 <edwardk> i do a lot of tracing jit stuff. the goal was to take that and run the tracing jit on the abstracted form, rather than the literal stack, which would be basically a 5th compiled version
21:13:28 <styfle> mauke: let me try it again...I'm not the only one that had the problem because google returned several hits with the same error message
21:14:27 <edwardk> anyways, yes, in my experience that works out better than fighting with pthreads ;)
21:14:36 <edwardk> and oddly comes out much more portable
21:14:59 <rata_> hi
21:15:13 <elliott_> A custom stack tends to make GC a bit more convenient IMO, although that could just be programming placebo :P
21:15:55 <edwardk> if only the old pre-posix makecontext, etc. functions actually _worked_
21:15:55 <rata_> how may I write a fold that finishes when a predicate becomes true?
21:16:10 <edwardk> i agree
21:16:32 <mauke> rata_: what's wrong with foldr?
21:16:34 <Axman6> rata_: what should it return if the predicate never trturns true?
21:16:36 <edwardk> i've been benchmarking off and on the approach i mentioned above against just using a separate haskell-ish stack
21:16:46 <Axman6> returns*
21:16:48 <edwardk> the latter has a lot of benefits, in particular its easy to work with llvm, etc.
21:17:09 <elliott_> I'm speaking from the POV of a custom JIT, no LLVM or anything
21:17:10 <edwardk> and the c stack is always available in nearly its entirety for ffi
21:17:17 <rata_> Axman6: it should work like a normal foldr then
21:17:17 <edwardk> but you make crappy use of fast stack access
21:17:23 <edwardk> yes
21:17:34 <rata_> but if the predicate becomes true before consuming the whole list, then it stops there
21:17:35 <Axman6> @src foldr
21:17:35 <lambdabot> foldr f z []     = z
21:17:35 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
21:17:44 <mauke> rata_: so what's wrong with foldr?
21:17:53 <Axman6> just make the second case use a guard
21:18:00 <edwardk> my current back end is basically a linear reverse assembler, a la luajit
21:18:10 <rata_> mauke: that foldr always consumes the whole list
21:18:11 <Axman6> also, you can just sue foldr
21:18:14 <mauke> rata_: no, it doesn't
21:18:17 <Axman6> rata_: it doesn't have to
21:18:28 <Axman6> :t foldr
21:18:29 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
21:18:44 <elliott_> edwardk: pasting together the mangled and modified output of gcc is the one true jit
21:18:53 <mauke> > foldr const 0 [1 ..]
21:18:54 <lambdabot>   1
21:18:56 <elliott_> one true, i tell ya
21:18:58 <Axman6> > foldr (\acc x -> if acc > 10 then acc else acc + x) 0 [1..10]
21:18:59 <lambdabot>   55
21:19:03 <Axman6> tmm
21:19:09 <Axman6> hmmm even >_>
21:19:15 <edwardk> but the argument for using an off-to-the-side leave-the-c-stack-alone approach is that i _can_ then lean on such tools. ;)
21:19:23 <Axman6> ah
21:19:28 <edwardk> and then i can spaghetti the hell out of that thing =P
21:19:29 <Axman6> > foldr (\x acc -> if acc > 10 then acc else acc + x) 0 [1..10]
21:19:30 <lambdabot>   19
21:19:39 <edwardk> not that continuation capture is as big of a deal for me now as it was
21:19:49 <mauke> Axman6: that consumes the whole list
21:19:57 <styfle> mauke: it says just run `make` in the top level directory. everything seems to work up until this: http://pastebin.com/xeKpFhgx
21:20:00 <mauke> The paste xeKpFhgx has been copied to http://hpaste.org/48697
21:20:14 <edwardk> but in my case i can flush marked par frames out to a workstealing deque just the same during gc
21:21:02 <rata_> mauke: I don't understand your example
21:21:05 <edwardk> this has been the approach i've been leaning towards lately, because my attempts to lean so heavily on the c stack are starting to hurt me more than help me
21:21:12 <mauke> rata_: why?
21:21:28 <edwardk> (lately being the last year or so, i don't steal time to work on this much)
21:21:35 <rata_> mauke: because const 0 1 returns 1, then const 1 2 returns 2 and so on
21:21:57 <mauke> rata_: const 0 1 returns 0
21:22:01 <mauke> rata_: it never calls const 0 1
21:22:03 <rata_> oh yes.. sorry
21:22:18 <rata_> mauke: why?
21:22:34 <elliott_> edwardk: the stack isn't actually much of a stack in my case i.e. any sort of spaghetti stack _would_ be separate
21:22:35 <mauke> rata_: it never calls sqrt 42 either
21:22:39 <mauke> what do you mean by "why"?
21:22:41 <elliott_> it's just that temporary variables are stored raw on the stack, basicall
21:22:42 <elliott_> y
21:22:47 <elliott_> (it's stack-based)
21:22:50 <elliott_> without any C baggage
21:23:04 <rata_> mauke: why doesn't it call const 0 1?
21:23:19 <mauke> rata_: why doesn't it call sqrt 42?
21:23:31 <rata_> it should call const 0 1, you're asking for that
21:23:43 <mauke> rata_: no, I'm not
21:23:49 <Saizan> rata_: foldr f z (x:xs) = f x (foldr f z xs) -- because of lazyness, if f doesn't make use of its second argument then (foldr f z xs) doesn't get evaluated
21:24:07 <rata_> ok
21:24:18 <rata_> thanks Saizan =)
21:24:26 <Cale> foldr const 0 [1..] = foldr const 0 (1:[2..]) = const 1 (foldr const 0 [2..]) = 1
21:25:43 <rata_> so I should use a function that doesn't make use of the second argument to stop foldr before consuming the whole list?
21:26:10 <elliott_> rata_: pretty much, just return a result that doesn't use the second argument when you decide you are "done"
21:26:15 <elliott_> and the rest of the list won't be processed
21:26:35 <ddarius> You should probably stop thinking in terms of "stopping" foldr and think about what properties should hold of the result.
21:26:45 <styfle> Does anyone have any idea why hugs wont build? http://pastebin.com/xeKpFhgx
21:26:45 <mauke> The paste xeKpFhgx has been copied to http://hpaste.org/48697
21:27:01 <elliott_> ddarius: to be honest, a lot of folds end up basically being an obfuscated state monad IMO
21:27:12 <elliott_> well, the type matches exactly, but I mean in spirit
21:27:22 <ddarius> elliott_: I have no idea what you are talking about.
21:27:50 <ddarius> mauke: Do you only do pastebin or do you do others?
21:27:55 <elliott_> ddarius: As in: you may be right about thinking in terms of the result rather than in terms of an imperative algorithm with state over the list, but I find that folds are often used in such a way anyway
21:28:05 <ddarius> elliott_: I have no idea what you are talking about.
21:28:10 <mauke> ddarius: pastebin.com only
21:28:15 <elliott_> ddarius: /shrug
21:29:29 <elliott_> ddarius: I was just expressing an observation relating to <ddarius> You should probably stop thinking in terms of "stopping" foldr and think about what properties should hold of the result., that's all.
21:29:50 <ivanm> preflex: seen BCoppens
21:29:50 <preflex>  BCoppens was last seen on #haskell-blah 6 hours, 21 minutes and 46 seconds ago, saying: crawl the web? :p
21:30:13 <ddarius> elliott_: I know what you are responding to.
21:31:07 <styfle> i guess i'll just download the official mac os GHC
21:31:11 <mauke> styfle: http://web.archiveorange.com/archive/v/kwlsgTqYnIsxhWkS42G6 looks related
21:31:22 <elliott_> ddarius: fine
21:33:28 <rata_> @src Data.Vector.ifoldr
21:33:28 <lambdabot> Source not found. My mind is going. I can feel it.
21:33:38 <sanjoyd> HAL?
21:35:18 <styfle> mauke: how can i pass the parameters -bundle -undefined dynamic_lookup ??
21:38:43 <rata_> mauke: do you know if what you told me holds for Data.Vector.ifoldr?
21:41:02 <rata_> Saizan, Cale?
21:41:10 <Cale> hello
21:41:20 <Cale> (just had to reset X, what's up?)
21:41:23 <rata_> hello
21:41:29 <styfle> GHC is a 900MB install???
21:41:29 <rata_> do you know if what you told me holds for Data.Vector.ifoldr?
21:41:42 <kmc> sounds about right styfle
21:41:44 <Cale> styfle: That sounds a bit large
21:41:48 <Cale> But maybe?
21:41:53 <kmc> for the whole Platform anyway
21:41:54 <styfle> it says 871MB
21:42:02 <Cale> oh
21:42:04 <styfle> this is why i wanted to build from source
21:42:09 <styfle> it was like 5MB lol
21:42:17 <elliott_> styfle: yeah, that's a whole 0.2% of a typical hard drive!!!!!!
21:42:19 <kmc> where does it say that styfle?
21:42:22 <Cale> It'll still be installing the same stuff
21:42:29 <Cale> Even if you were building from source
21:42:34 <elliott_> Cale: well, e could skip the haskell platform.
21:42:35 <kmc> just now i discovered a 2 GB microSD card in a box
21:42:38 <elliott_> but then e'd just end up installing it anyway.
21:42:39 <kmc> i don't remember buying it
21:42:42 <Cale> The binary package download isn't anywhere near that large
21:42:44 <styfle> does it? I thought it doesnt come with a GUI
21:42:57 <styfle> this is for Mac btw
21:42:59 <elliott_> styfle: what constitutes "a GUI" here that you think the Haskell Platform includes?
21:43:03 <Cale> But I think it compresses well
21:43:20 <deech> Hi all, I'm looking for Haskell<->Objective-C bindings have come across HOC which looks like it hasn't been updated in a while and a Trac page (http://hackage.haskell.org/trac/ghc/wiki/ObjectiveC) that doesn't seem to have a link to any source. Is HOC the binding to use?
21:43:21 <styfle> yeah actually the uncrompessed source is like 50MB
21:43:42 <Cale> deech: Might be the thing to try updating...
21:43:44 <elliott_> deech: HOC is dead AFAIK
21:43:55 <elliott_> I have a feeling most people call Haskell from their Objective-C code
21:44:51 <deech> elliott_: That would be what I need. So I guess the best way to write some C glue for the functions I need, correct?
21:45:06 <styfle> whats the difference between haskell platform and GHC?
21:45:14 <elliott_> deech: yeah, i guess. or do all your UI/whatever code in Objective-C.
21:45:17 <elliott_> and just translate the types for Haskell.
21:45:22 <elliott_> that could be inefficient though.
21:45:24 <deech> styfle: Haskell platform includes a lot of blessed libraries.
21:45:39 <elliott_> styfle: Haskell Platform = GHC + useful, common libraries + on Windows, WinGhci
21:46:01 <ivanm> deech: try asking copumpkin
21:46:30 <styfle> hmm i dont think i need most libraries
21:46:44 <deech> ivanm: Is he the HOC maintainer?
21:46:55 <styfle> GHC has modules like "zip" right?
21:47:01 <elliott_> zip isn't a module.
21:47:04 <elliott_> It's a function in the Prelude.
21:47:12 <elliott_> But seriously, your life will be a lot easier if you just install the Haskell Platform :)
21:47:34 <styfle> if you say so :P
21:47:58 <monqy> life for one week
21:48:09 <deech> styfle: If youre wanting Haskell code to deal with zip archives: http://hackage.haskell.org/package/zip-archive
21:48:32 <elliott_> I think e means
21:48:33 <elliott_> :t zip
21:48:34 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
21:48:38 <ivanm> deech: dunno, but he's been working on some haskell <--> obj-c stuff IIRC
21:48:45 <elliott_> The most advanced module in GHC :-)
21:48:57 <styfle> yes thats what i meant, not compression zip
21:48:58 <deech> ivanm: I'll check with him. Thanks for the heads up.
21:49:32 <ivanm> preflex: seen copumpkin
21:49:32 <preflex>  copumpkin was last seen on #haskell-blah 1 day, 5 hours, 48 minutes and 16 seconds ago, saying: pretty well :) I get just over 1 coin a day
21:50:06 <styfle> i guess i'll install the haskell platform....thanks for the help everyone
21:50:22 <deech> styfle: sure. Good luck@
21:50:29 <deech> s/@/!
21:56:21 <styfle> installed...now what?
21:56:31 <styfle> how can i launch prelude?
21:56:57 <monqy> what do you mean?
21:57:31 <rata_> styfle: ghci?
21:57:59 <styfle> thanks
21:58:48 <rata_> styfle: you meant the interpreter (or repl)... prelude is just a module afaik
22:00:17 <styfle> yeah just the interpreter...i gotta learn me a haskell
22:09:09 <styfle> is it considered bad style to always call a function with parenthesis around the arguments?
22:09:19 <styfle> such as myfunc(5)
22:09:28 <c_wraith> yes
22:09:32 <styfle> i noticed you have to use them to do myfunc(-5) i think
22:09:45 <c_wraith> unnecessary parens are always considered bad style
22:09:46 <shachaf> styfle: No, it's "myfunc (-5)".
22:10:12 <styfle> the space matters?
22:10:32 <styfle> or is that convention?
22:11:11 <monqy> usually there aren't any parentheses at all
22:11:20 <monqy> unary - is just a bit weird
22:14:06 <mike-burns> The parens don't go around the arguments.
22:14:11 <mike-burns> They go around function calls.
22:14:15 <mike-burns> (-) is a function.
22:20:33 <Axman6> styfle: you need myFunc (-5) because if you write myFunc -5, that gets parsed as myFunc minus 5, not myFunc being passed -5 (so you can think of it being read as ((myFunc) - (5)) )
22:34:35 <ivanm> since no-one is answering in #darcs: anyone know how to force "darcs push" to apply a patch even if it would result in breakage?
22:45:24 <orifichu> how i can install ghc in my hosting?
22:46:43 <CrazyThinker> Is the Maybe-Nothing like int? in .NET
22:46:50 * hackagebot GLFW-b 0.0.2.10 - GLFW bindings  http://hackage.haskell.org/package/GLFW-b-0.0.2.10 (BrianLewis)
22:47:11 <orifichu> when i write "./configure" there is an error: "version GLIBC_2.9 not found". how i can solve it?
22:48:48 <Axman6> CrazyThinker: huh?
22:49:03 <Axman6> orifichu: by installing glib 2.9?
22:49:30 <cmccann> CrazyThinker, yes, nullable value types in .NET were actually inspired by option types in languages like ML and Haskell
22:49:46 <orifichu> Axman6: how i could know my glivc version?
22:50:00 <Axman6> i have no idea, but this isn't a haskell problem imo
22:50:10 <CrazyThinker> cmccann, Thank you so much
22:50:49 <cmccann> CrazyThinker, except that in Haskell nothing is ever nullable by default, so you would use Maybe in any situation where you want that
22:53:38 <orifichu> how i can install the haskell platform? some have it step by step?
22:54:46 <CrazyThinker> cmccann, wow, Haskell is really hard to understand compared to .NET
22:54:58 <cmccann> CrazyThinker, nah, it just takes a bit of getting used to
22:55:04 <Axman6> CrazyThinker: not really, you should learn it and find out ;)
22:55:31 <cmccann> .NET has more weird exceptions and corner cases to worry about, Haskell seems strange at first but everything makes more sense as a whole once you get the hang of it
22:55:39 <Axman6> > let safeDiv x y = if y == 0 then Nothing else Just (x/y) in safeDiv 7 4
22:55:40 <lambdabot>   Just 1.75
22:55:43 <Axman6> > let safeDiv x y = if y == 0 then Nothing else Just (x/y) in safeDiv 7 0
22:55:44 <lambdabot>   Nothing
22:56:06 <Axman6> > let safeDiv x y = if y == 0 then Nothing else Just (x/y) in safeDiv 7 0.000000001
22:56:06 <lambdabot>   Just 7.0e9
22:56:43 <Sgeo_> CrazyThinker, imagine if in .NET, SomeReferenceType could never be null, only SomeReferenceType? could
22:56:54 <ddarius> Axman6: Not a whole lot of sense to that with IEEE floating point numbers.
22:57:08 <Axman6> sure
22:57:11 <Axman6> > 7/0
22:57:12 <lambdabot>   Infinity
22:57:39 <cmccann> not that IEEE floats are what would normally be called "numbers" but oh well
22:58:38 <CrazyThinker> I hate the infix notation. having to type ` everytime :(
22:59:03 <ddarius> You don't have to type ` ever.
23:02:05 <ivanm> yeah, you don't _have_ to use infix notation...
23:07:51 <Axman6> CrazyThinker: if you've got a function that you always use infix, you might consider making it more operator like: addMul x y = x*y+y; (+.) = addMul
23:08:37 <CrazyThinker> wow Thats interesting
23:10:36 <Axman6> > let addMul x y = x*y+y; (+.) x y = x*y+y in (6 `addMul` 7, 6 +. 7)
23:10:36 <lambdabot>   (49,49)
