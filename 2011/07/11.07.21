00:07:11 <Samuel> quick question, Does Haskell support DSL?
00:09:22 <c_wraith> that question could afford to be a little less quick.
00:09:36 <pikhq> Define "DSL".
00:09:46 <Samuel> Domain Specific language
00:10:13 <c_wraith> how does a language *not* support domain-specific languages?
00:10:17 <pikhq> Ah. Simple answer is "yes, and it would be hard to make a high-level language not support it."
00:10:34 <Samuel> Ruby and Groovy offer runtime metaprogramming that let you design Domain Specific languages
00:11:06 <c_wraith> I think you've bought too far into someone's bizarre choice of terminology.
00:11:23 <pikhq> Samuel: Domain-specific languages are one of the oldest techniques in the book.
00:12:20 <c_wraith> (all this aside, though, haskell is terrific for embedded domain-specific languages.  the ability to use haskell as your meta-language on top of custom primitives is amazing)
00:12:56 <osfameron> Samuel: coming from a dynamic language background too (I'm a perl guy) it's *surprising* just how good HAskell is at declarative DSLs
00:13:17 <Samuel> any reference and good materials too read through
00:13:25 <shachaf> Haskell lets you design languages that will only run on haskell.org.
00:14:09 <osfameron> Samuel: they don't end up being written in the same way (e.g. not so much with runtime metaprogramming etc.) but give it a go
00:15:17 <osfameron> Samuel: a quick google of "haskell dsl" gives, among other things, http://augustss.blogspot.com/2007/06/representing-dsl-expressions-in-haskell.html which seems quite accessible
00:16:06 <osfameron> Samuel: you could also search for spj's talk on representing financial contracts in Haskell - that's a really good *high-level* investigation on how types can be used to model real-world scenarios really effectively
00:16:57 <Samuel> I appreciate that guys.
00:40:30 * hackagebot yi 0.6.4.0 - The Haskell-Scriptable Editor  http://hackage.haskell.org/package/yi-0.6.4.0 (JeffWheeler)
00:40:32 * hackagebot yi-contrib 0.6.4.0 - Add-ons to Yi, the Haskell-Scriptable Editor  http://hackage.haskell.org/package/yi-contrib-0.6.4.0 (JeffWheeler)
01:05:37 <sanjoyd> Is there some nice way to say "if a is Nothing, then b else a" ? Basically the opposite of >>
01:09:09 <ziman> :t maybe
01:09:10 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
01:09:17 <ziman> :t fromMaybe
01:09:18 <lambdabot> forall a. a -> Maybe a -> a
01:09:26 * sanjoyd tries.
01:09:30 <ziman> :t fromMaybe 5 Nothing
01:09:31 <lambdabot> forall t. (Num t) => t
01:09:39 <ziman> > fromMaybe 5 (Just 3)
01:09:41 <lambdabot>   3
01:09:47 <shachaf> > Nothing `mplus` (Just 5)
01:09:48 <lambdabot>   Just 5
01:09:48 <shachaf> > (Just 3) `mplus` (Just 5)
01:09:49 <lambdabot>   Just 3
01:10:00 <sanjoyd> Yes, mplus will do very well.
01:10:11 <shachaf> > Nothing <|> Just 5
01:10:12 <lambdabot>   Just 5
01:10:17 <shachaf> > Just 3 <|> Just 5
01:10:18 <lambdabot>   Just 3
01:10:23 <ziman> > Nothing ++ Just 5
01:10:24 <lambdabot>   Ambiguous type variable `a' in the constraints:
01:10:25 <lambdabot>    `Data.Monoid.Monoid a'
01:10:25 <lambdabot>  ...
01:10:28 <tansell-laptop> Hey guys, we are live streaming FP-Syd tonight at http://view.streamti.me/fpsyd - "specs2: go functional!" and "Functional Pretty Printer Combinators" and "Joint Evaluation Contexts"
01:10:45 <sanjoyd> Is <|> an alias for mplus?
01:11:32 <shachaf> @ty (<|>)
01:11:33 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
01:11:38 <shachaf> It's the Applicative equivalent, more or less.
01:12:11 <tansell-laptop> thought you guys might be interested
01:26:01 <mreh> @instances MonadPlus
01:26:02 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
01:33:26 <huangyi> @info Alternative
01:33:27 <lambdabot> Alternative
01:33:47 * hackagebot bindings-dc1394 0.2 - Library for using firewire (iidc-1394) cameras  http://hackage.haskell.org/package/bindings-dc1394-0.2 (VilleTirronen)
01:33:49 <shachaf> @info is the best command
01:33:49 <lambdabot> is the best command
01:39:48 * hackagebot simple-firewire 0.1.1 - Simplified interface for firewire cameras  http://hackage.haskell.org/package/simple-firewire-0.1.1 (VilleTirronen)
01:44:37 <sanjoyd> I'm trying to add an instance (Ord a) => Ord (a, b); but am unable to because of (Ord a, Ord b) => Ord (a, b) in GHC.Classes.
01:45:12 <sanjoyd> It seems a rather elegant thing to do would be to somehow tell Haskell to use my instance on (Ord a) and GHC.Classes instance on (Ord a, Ord b).
01:45:15 <sanjoyd> Is there some way I can do that?
01:46:04 <shachaf> sanjoyd: (Ord a, Ord b) *is* (Ord a), you know. :-)
01:46:10 <rtharper> has anyone managed to get GHC running on Lion, yet
01:46:19 <rtharper> or even better, the haskell platform ;)
01:46:38 <mreh> rtharper: it's more restrictive
01:46:43 <mreh> it contains fewer types
01:46:50 <rtharper> mreh: what does?
01:46:55 <dankna> rtharper, use a binary distribution of GHC for now
01:46:56 <sanjoyd> shachaf: how?
01:47:03 <mreh> (Ord a, Ord b) => (a, b)
01:47:04 <rtharper> dankna: kk
01:47:23 * sanjoyd is confused now.
01:47:30 <shachaf> sanjoyd: How would GHC decide which instance to use?
01:47:47 <sanjoyd> The more specific one?
01:48:08 <sanjoyd> I don't know if there is some way I can tell it to do so, though.
01:48:19 <kosmikus> GHC doesn't look at left hand sides of instance declarations in order to decide which to pick
01:52:23 <rtharper> wow ld is giving FUN warnings
01:52:36 <benmachine> sanjoyd: the problem with that suggestion is that it means if I later add an instance to something, it should theoretically change the behaviour of other code
01:52:59 <benmachine> sanjoyd: at the moment, adding instances can stop things compiling or make them compile, but it can't make them do something different
01:53:06 <sanjoyd> Oh, okay.
01:53:23 <sanjoyd> But in this case, I don't think behaviour will change.
01:53:39 <sanjoyd> I'll only be able to compile code that would not otherwise compile.
01:53:46 <sanjoyd> But I understand what you're getting at.
01:54:20 <benmachine> well, that's (one of the reasons) why GHC doesn't do that sort of thing, as I understand it
01:54:27 <huangyi> can not hide instance when import ?
01:54:39 <benmachine> huangyi: no, instances are kind of infectious
01:54:47 <benmachine> people disagree on whether this is a good thing or a bad thing
01:55:23 <benmachine> if you want named instances that you can choose between, you could just have a record of functions instead
01:56:09 <benmachine> data Eq a = Eq { equalsWith :: a -> a -> Bool }
01:56:12 <benmachine> something like that
01:56:46 <sanjoyd> I guess I'll just do a Pair a b = P a b and be done with it.
01:57:03 <benmachine> sanjoyd: yeah, that's one option, or you can make a newtype on tuples
01:57:14 <benmachine> (either is just as good, really)
01:57:28 <benmachine> (newtype Pair a b = Pair { getPair :: (a,b) })
01:59:33 <brence> Does inserting an element at a certain position in a list creates a new list ? is memory copied ?
01:59:44 <rtharper> brence: everything before that position is
02:00:20 <brence> rtharper: if the list is stored in a mutable cell, will it be like a "mutable list" ?
02:00:33 <rtharper> brence: No
02:00:47 <mm_freak> anyone see a way to compile haskell to a flash app?
02:00:52 <mm_freak> i guess not
02:01:07 <rtharper> brence: that just means that the pointer that was stored in the mutable cell is destructively updated
02:01:17 <brence> rtharper: isn't the old list thrown away, once the mutable cell is modified ?
02:01:26 <rtharper> brence: if nothing else points to it, yes, it will be
02:01:40 <rtharper> brence: but there will still be copying
02:02:09 <rtharper> by thrown away I mean that it will eventually be garbage collected
02:02:11 <huangyi> brence: maybe you can use a zipper
02:02:27 <brence> rtharper: So the expense in this particular situation as compared to an imperative language for example is the copying part ?!
02:03:01 <brence> huangyi: what's special about zippers ?
02:03:04 <rtharper> brence: yes.  All data structures are persistent in Haskell.  Lots of work is done to tune data structures to reduce copying ;)
02:03:19 <benmachine> zippers allow you to edit lists quickly
02:03:30 <benmachine> at a 'cursor'
02:04:40 <brence> rtharper: is there any package immitating "mutable lists" ?
02:05:06 <benmachine> brence: you can design mutable structures with ST
02:05:13 <benmachine> arrays and lists
02:05:18 <benmachine> but it's usually not necessary
02:05:38 <erus`> opengl in haskell is a nightmare
02:05:47 <erus`> Hopengl is too far from 1:1
02:05:58 <erus`> raw opengl is too near
02:06:01 <rtharper> brence: Usually if you program in a FP-style, you structure your programs in a way where you take advantage of any copying
02:06:17 <erus`> A raw, with translated types would be perfect
02:06:21 <rtharper> brence: but it is a different way of thinking.  Also, don't get too hung up on the cost of copying.  In many cases it isn't that high
02:06:40 <rtharper> erus`: GoldilocksGL? ;)
02:06:44 <brence> rtharper: nice point
02:06:59 * rtharper removes intermediate data structures for a living...
02:07:27 <rtharper> brence: I find it's bet to write a solution that you like/makes sense, then refine if you are having a problem of too much copying
02:07:35 <erus`> rtharper: yer :P
02:07:55 <erus`> in the meantime i will use HOpengl, but i will make sure to moan about it
02:07:59 <rtharper> In my experience, Haskell code is rarely written without a bit of fiddling afterward
02:08:06 <benmachine> s/Haskell //
02:08:24 <rtharper> benmachine: touché, though I feel it's easy in Haskell
02:08:35 <benmachine> ah, yes, agreed :)
02:09:16 <erus`> has anyone tried the yesod on heroku thing?
02:09:18 <brence> benmachine: to define a mutable linked list in ST, should STRefs be used ?
02:09:23 <benmachine> brence: yes
02:09:43 <rtharper> aha, if you have the types, you're 90% there
02:10:01 <Guest28965> Good morning, i have a little question (my first in haskell :)...) if anyone could answer: is possible to "currie" a function of "2 parameters"? for example: element-at = last $ take not work, but element-at n list = last $  take n list is ok...
02:10:57 <benmachine> I was imagining something like STList s a = Nil | STCons a (STRef s (STList s a))
02:11:37 <benmachine> Guest28965: currying gets a bit more confusing when you have $ involved
02:11:50 <MasseR> @pl \n list -> last $ take n list
02:11:50 <lambdabot> (last .) . take
02:11:58 <MasseR> Guest28965: That's what you meant?
02:12:02 <benmachine> Guest28965: last $ take n list is actually ($) last (take n list)
02:12:12 <benmachine> which is the same as last (take n list)
02:12:31 <Guest28965> maybe... i am a beginner
02:12:37 <benmachine> I would suggest saying elementAt n = last . take n
02:12:52 <sanjoyd> So either you're just a beginner or nothing at all.
02:12:57 <benmachine> (note element-at is not a valid function name, because it looks like you are taking at away from element)
02:13:02 <Guest28965> ok, thank you very match benmachine.
02:13:31 <benmachine> Guest28965: although, I would say head . drop n makes more sense :)
02:13:32 <Guest28965> but is possible best than that? without the "n" ?
02:13:53 <benmachine> Guest28965: you can get rid of the n too but it's not necessarily better
02:13:54 <Guest28965> yes :)... more sense!
02:14:16 <benmachine> you have to decide when removing parameters from a function when to stop
02:14:21 <geheimdienst> sanjoyd: what was that remark supposed to mean?
02:14:28 <sanjoyd> It was a bad joe.
02:14:32 <sanjoyd> s/joe/joke/
02:14:41 <benmachine> geheimdienst: because he said Maybe he's a beginner?
02:15:11 <benmachine> Guest28965: so you can write elementAt = (last .) . take but I think the version with the n in is more clear
02:15:21 <geheimdienst> oh, ok ...
02:15:47 <Guest28965> thanke you veri match benmachine :)!
02:15:48 <rtharper> geheimdienst: were you about to be trolled into an argument? =p
02:18:02 <brence> defining a mutable linked list in ST, how can I have the node value and the pointer to the next node ?
02:19:44 <benmachine> brence: did you see my idea earlier
02:19:55 <brence> I just disconnected
02:19:58 <benmachine> oh right
02:20:09 <brence> can you copy it
02:20:40 <benmachine> data STList s a = Empty | Cons a (STRef s (STList s a))
02:20:57 <benmachine> an STRef is a bit like a pointer
02:21:45 <brence> benmachine: Ohh I see
02:22:11 <benmachine> it'll still be kind of slow to edit items in the middle of that list
02:22:26 <benmachine> you could use a zipper *with* the mutable list
02:22:30 <benmachine> or you could use an STArray
02:22:34 <benmachine> depending on what you wanted
02:23:30 <Guest28965> another little question if possible: for (my) educational pourpose, is possible to write a multiline code in ghci?
02:23:59 <benmachine> toList :: STList s a -> ST s [a]; toList Empty = return []; toList (Cons a r) = fmap ((a :) . toList) (readSTRef r)
02:23:59 <brence> benmachine: besides fusion, is does Vector outperform STArray ?
02:24:07 <benmachine> brence: I don't know
02:24:24 <benmachine> Guest28965: sort of. usually it's easier to edit a file and load it with :l
02:24:52 <benmachine> Guest28965: but if you use :{ in ghci then write a bunch of lines and then do :} at the end, the lines in between will be joined together and run as one
02:24:59 <benmachine> (if I recall correctly)
02:25:10 <hpaste> “Mukesh Tiwari” annotated “Compilation Erro” with “Compilation Erro (annotation)” at http://hpaste.org/49300#a49301
02:25:13 <benmachine> I recommend using a file, even just a temporary one
02:25:49 <Guest28965> thanks again,  i will use a file :)!
02:25:49 <rtharper> brence: "besides fusion" is a pretty big besides ;)
02:26:10 <keep_learning> hello all
02:26:29 <tibbe> brence, STArray is a bit weird in how it does indexing (because is supports more general indexes), so I'd expect Vector to outperform it
02:26:34 <keep_learning> could some one please tell me why this code is giving compilation error http://hpaste.org/49300
02:26:54 * hackagebot simple-firewire 0.1.2 - Simplified interface for firewire cameras  http://hackage.haskell.org/package/simple-firewire-0.1.2 (VilleTirronen)
02:26:55 <tibbe> brence, Vector also allows you to skip bounds checks (at your own risk), which can give you some extra performance when needed.
02:27:25 <brence> tibbe: I see your point
02:28:12 <tibbe> brence, I generally don't like the standard haskell array package; its interface is quite baroque
02:28:38 <tibbe> in theory it's nice to have non-zero indexed arrays, in practice it's a huge pain because you (almost) never need it
02:29:27 <keep_learning> any one please .
02:29:34 <brence> tibbe: Vectors are more like C arrays ?
02:30:39 <Lemmih> keep_learning: What do you think the type of 'l' is?
02:30:52 <mm_freak> tibbe: 0-indexed standard haskell arrays are the fastest arrays you can get, so they still have value
02:30:55 <rtharper> brence: what tibbe says is veyr true regarding bounds checking, if you don't use unsafe* functions, it does bounds checking before every read/write
02:31:09 <erus`> i find myself using recursion in C so much now
02:31:14 <erus`> what has haskell done!?
02:31:23 <keep_learning> Lemmih, its value who is instance of Num class
02:31:33 <mm_freak> erus`: good question, as in well styled haskell you seldomly use direct recursion ;)
02:31:50 <osfameron> erus`: how do you do that? I mean with malloc/free etc.?
02:32:08 <Lemmih> keep_learning: Incorrect, it has the type 'Num a => String -> a'.
02:32:10 <keep_learning> Lemmih, when i am commenting this line its compiling so you are correct
02:32:13 <brence> mm_freak: how are they the fastest haskell arrays ?
02:32:14 <erus`> transversing trees and stuff
02:32:21 <tibbe> mm_freak, why do you think so?
02:32:23 <osfameron> or does it already Do The Right Thing for variable scoping in recursive routines?
02:32:28 * osfameron should really learn C properly
02:32:44 <erus`> i think i just swapped my for loops for recursive calls
02:33:06 <hvr> erus`: got a big stack?
02:33:09 * osfameron never has a need to write in C, thankfully
02:33:10 <mm_freak> brence, tibbe:  when used in an imperative style, because of the most direct translation to the corresponding low level instructions you get the best performance, and personal benchmarks proved it
02:33:33 <mm_freak> Vector is faster, where you want to code in a higher level style and make use of fusion to get good low level code
02:33:35 <erus`> hvr: i just never work on anything too big :)
02:33:46 <keep_learning> Lemmih, yes
02:33:47 <Lemmih> keep_learning: 'l' is a function which takes a String and gives you a number. But you haven't given it a String.
02:33:52 <tibbe> mm_freak, really, index on arrays is not the same as the underlying indexArray# primop
02:34:08 <erus`> do the majority of javascript VMs do tail recursion now?
02:34:12 <Lemmih> keep_learning: In your other 'main', 'interact' did that for you.
02:34:31 <Lemmih> keep_learning: If you don't use 'interact', you have to do it yourself.
02:34:32 <keep_learning> Lemmih, yes
02:34:42 <mm_freak> tibbe: yet Vector is very high level, whereas Data.Array is very low level
02:35:02 <keep_learning> Lemmih, so it means i can't take input like this ?
02:35:03 <Lemmih> keep_learning: Keep in mind that 'printf' can also generate Strings without doing IO.
02:35:08 <mm_freak> erus`: it depends on the compiler you use
02:36:10 <erus`> there are javascript compilers?
02:36:34 <mm_freak> oh, javascript
02:36:35 <mm_freak> sorry =)
02:36:40 <mm_freak> but indeed there are
02:36:46 <mm_freak> haxe for example compiles to javascript
02:36:55 <mm_freak> (but doesn't perform TCO)
02:37:10 <Lemmih> keep_learning: The easiest solution would be to use both 'interact' and 'printf'.
02:37:29 <mm_freak> (as a side note, when you want to write javascript, it's much more pleasant to write in the statically, strongly typed haxe and compile to javascript)
02:38:07 <tibbe> mm_freak, look at the implementation of readArray here: http://hackage.haskell.org/packages/archive/array/0.3.0.2/doc/html/src/Data-Array-Base.html#readArray
02:38:07 <mm_freak> (… at least if you are a haskell programmer)
02:38:14 <keep_learning> Lemmih, some thing like interact $ printf "%.2f "  ?
02:38:33 <luite> mm_freak: how does that work if your code relies on lots of existing javascript libraries?
02:38:43 <Lemmih> keep_learning: Yeah, something like that.
02:39:38 <erus`> im still waiting for a decent haskell -> Javascript compiler
02:40:19 <keep_learning> Lemmih, i did main = interact $ printf "%.2f" $   solve . convexHull . format . map  ( map readInt . words ) . tail . lines
02:40:20 <tibbe> mm_freak, follow the implementation from there. it needs to compute the real (zero based) index from the Ix instance, which requires a bunch of additional instructions. it also needs to compute the size of the array from the bounds, adding more overhead
02:40:20 <mm_freak> tibbe: i know that, and i guess for 0-indexed arrays that part gets compiled away…  i can tell you that my safe bit array code in haskell runs at 50-75% the speed of equivalent but unsafe C code
02:40:28 <keep_learning> like this but still out of luch
02:40:31 <keep_learning> *luck
02:40:45 <mm_freak> tibbe: assuming you use the Int index type
02:40:47 <tibbe> mm_freak, I believe my Array# based code runs at the speed of C code
02:41:09 <mm_freak> tibbe: not arguing with that…  of course Array# is faster
02:41:11 <tibbe> mm_freak, that part is not compiled away as the lower and upper bounds are only known at runtime
02:41:26 <tibbe> mm_freak, Vector is more like Array# than STArray
02:41:26 <mm_freak> but Data.Array is likely faster than Vector, when used the way it is supposed to be used
02:41:33 <tibbe> no
02:41:39 <tibbe> read the core
02:41:50 <Lemmih> keep_learning: Almost there. Keep trying.
02:42:03 <keep_learning> Lemmih, :)
02:42:04 <mm_freak> tibbe: i didn't read the core (that stuff is totally unintelligible to me), but i compared the runtimes
02:42:06 <luite> mm_freak: hmm, do you need to wrap all functions of existing javascript libraries if you use haxe?
02:42:19 <tibbe> mm_freak, perhaps your benchmark was faulty?
02:42:30 <Lemmih> keep_learning: It helps to know the difference between '$' and '.'.
02:42:33 <mm_freak> luite: so far i haven't accessed other libraries from haxe other than for what bindings are already available
02:42:48 <mm_freak> luite: check out the website haxe.org…  there are lot of packages
02:42:48 <luite> hmm, it's probably useless for me then
02:43:10 <mm_freak> tibbe: yes, that may well be…  a common problem with benchmarks =)
02:43:17 <tibbe> :)
02:43:19 <tibbe> yes, unfortunately
02:43:34 <mm_freak> anyway, i'll have my pizza now…  TTYL
02:44:03 <tibbe> ttyl
02:45:55 <brence> tibbe: Can actually Array# be used in a user-defined datatype ?
02:46:51 <tibbe> brence, yes, it's GHC only so you'll need to import GHC.Exts
02:47:09 <tibbe> brence, if you want a barebones array type you can try the smallarray package, with is a simple wrapper arround Array#
02:47:57 <tibbe> brence, you couldn't go wrong with Vector though
02:48:07 <brence> tibbe:that seems like a suitable package
02:48:31 <tibbe> brence, it's written by experts, well maintained, etc
02:49:20 <keep_learning> Lemmih, should it be like this main = interact $   printf "%.2f" .  solve . convexHull . format . map  ( map readInt . words ) . tail . lines
02:49:47 <keep_learning> Lemmih, but i am still getting compiler error which i am not able to understand
02:50:15 <brence> tibbe: I never had problem with Vectors. I was just wondering why many different implementations of the same static memory structure
02:50:50 <Lemmih> keep_learning: Oh?
02:51:20 <Lemmih> keep_learning: You may need more concrete types.
02:51:40 <keep_learning> Lemmih, in solve function ?
02:52:12 <Lemmih> keep_learning: try (printf "%.2f" :: Double -> String)
02:53:17 <keep_learning> Lemmih, thank you
02:53:25 <fenris_kcf> hy. is there a simple way to make haskell show some kind of working-protocol, that lists all the functioncalls during execution? do i have to use a debugger-module for this?
02:53:36 <keep_learning> Lemmih, i will try to keep these things in mind from next time
02:53:44 <keep_learning> Lemmih, thanks a lot
02:55:23 <tibbe> brence, historical reasons, vector was extracted from the DPH project
02:57:09 <brence> tibbe: DPH stands for ?
02:57:40 <tibbe> brence, data parallel haskell
02:58:45 <brence> tibbe: I see
03:07:48 <MasseR> I'm reading learn you some erlang, and I'm even more certain that haskell has one of the prettiest/minimalistist syntax. Coffeescript and clojure comes close, but even erlang seems.. monolithic?
03:26:28 <erus`> i prefer haskell to coffee script
03:26:54 <shachaf> I prefer Haskell to coffee.
03:26:55 <erus`> f x = x * x    vs f = x -> x * x
03:27:26 <erus`> i duno actually
03:27:33 <erus`> its a toughy
03:27:50 <erus`> its easier to see that f is a function
03:28:23 <shachaf> That's a very superficial comparison...
03:28:39 <int-e> I'd prefer f x = x * x over f = \x -> x * x, and both over  join (*)
03:29:05 <shachaf> How about (^2)?
03:29:37 <int-e> (^2) would be nice if ghc managed to produce good code for it. I don't think it does, but I should try.
03:31:28 <ptd> int-e: if it doesn't you could try using a RULES pragma
03:32:05 <int-e> It's still that way. (^) isn't getting inlined because it's recursive.
03:32:31 <quicksilver> IIRC, (^) uses repeated squaring, at least, if you get the right implementation.
03:32:47 <int-e> yes, but for x^2 I really want x*x :)
03:33:25 <ptd> something along the lines of {-# RULES "square" (^2) == (\x -> x*x) #-}
03:33:34 <quicksilver> well, repeated squaring does get you x*x, just via a lot of if statements ;)
03:33:35 <frerich> Sorry for not being a bit offtopic, but is anybody aware of a bridge which makes planet.haskell.org posts available on Google+?
03:33:43 <frerich> err
03:33:45 <frerich> s/not//
03:34:00 <quicksilver> you might hope the inliner would solve that but I think that's a bit cleverer than the GHC one is.
03:35:15 <int-e> quicksilver: yeah, that was my whole point, I guess.
03:35:56 <ptd> frerich: Doubt it, I don't think google have even released public apis yet
03:38:02 <int-e> {-# RULES "square" forall x. x^2 = x*x #-} would be nice if it actually fired :)
03:38:42 <quicksilver> does it help to fix the type?
03:38:50 * quicksilver doesn't understand the issues about rules firing etc.
03:39:04 <quicksilver> but in some cases isn't ^ rewritten by existing rules?
03:40:14 <quicksilver> ah, that's write. ^ isn't a method.
03:40:16 <quicksilver> right.
03:40:18 <quicksilver> damn homonyms
03:41:18 <ptd> so would {-# RULES "square" forall x. (^2) x = x*x #-} work
03:41:44 <quicksilver> I don't think that's any different from int-e's suggestion
03:41:53 <quicksilver> I don't think syntax matters like that
03:43:48 <int-e> ptd: I wasn't trying with (^2), I experimented with g x = x^2. But a rule for x^b fires for (^2), too.
03:44:12 <benmachine> doesn't inlining get that?
03:44:29 <benmachine> or I guess it might not since ^ is recursive
03:47:09 * roconnor_ wonders if Const o a is a monoid when o is a monoid.
03:48:18 <benmachine> roconnor_: can't you find out? :P
03:48:28 <benmachine> (it sounds like it should be?)
03:48:30 <roconnor_> I'm trying to find const
03:48:32 <roconnor_> :D
03:48:41 <benmachine> oh you mean, if it *is* rather than if it shoudl be
03:48:46 <benmachine> it's in Control.Applicative I think
03:49:06 <benmachine> it doesn't seem to be
03:49:18 <roconnor_> orphan instances to the rescue!
03:49:22 <benmachine> wooooo
03:50:11 <ptd> int-e: so why doesn't it fire?
03:50:14 <int-e> module Orphanage where ...
03:50:34 <int-e> ptd: presumably because 2 is not just 2; it's fromInteger 2 and has polymorphic type.
03:50:54 <int-e> (which later gets defaulted to integer, but I'm not sure exactly when)
03:54:37 <Saizan> i'd think defaulting would happen before
03:55:06 <Saizan> while typechecking
03:55:22 <Samuel> reading a book about Haskell, it is called "Real World Haskell" it was published in 2008 do you guys think that it is still a good book to read
03:56:28 <geheimdienst> Samuel: absolutely. RWH is great
03:57:05 <geheimdienst> it's aimed more at the intermediate level. i think beginners should first read learn you a haskell
03:57:05 <ptd> Samuel: One of the very best
03:57:07 <geheimdienst> @where lyah
03:57:08 <lambdabot> http://www.learnyouahaskell.com/
03:58:05 <Samuel> Learn You a Haskell for Great Good is good, but the author misses out on lots of details
03:59:08 <gienah> Samuel: there is the craft of functional programming if want over 500 pages of details starting at the very beginning
03:59:11 <ptd> Samuel: RWH goes through the basics very fast
03:59:28 <gienah> the craft goes the basics really slow :-)
04:00:17 <Samuel> craft?
04:00:27 <ptd> Samuel: RWH is brilliant for "I sort of get how haskell works, but how do I write useful programs in it"
04:00:31 <gienah> Samuel: yes its a book
04:00:56 <gienah> @google "the craft of functional programming"
04:00:58 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/
04:00:58 <lambdabot> Title: Haskell: The Craft of Functional Programming, Second Edition
04:01:10 <gienah> oops, you want the 3rd edition
04:01:30 <gienah> @google "the craft of functional programming" "third edition"
04:01:32 <lambdabot> http://www.haskellcraft.com/
04:02:50 <Samuel> sweet
04:03:17 <Samuel> Thanks for the input, I will read through them
04:17:25 <erus`> damn i thought i would be a minecraft clone written in haskell
04:18:17 <quicksilver> you thought you would *be* one?
04:18:42 <quicksilver> you are only an illusion of conciousness, driven by a truly gigantic automaton built in haskell minecraft? that's awesome.
04:19:03 <quicksilver> although myself I'd rather be built in dwarf fortress.
04:23:25 <Guest28965> hi all, a question: the following code raise an excepion that claim a Non-exhaustive patterns... but i don't understand why... many thanks for help :).
04:23:28 <Guest28965> segmentNotBeginningWidth :: Eq a => a -> [a] -> [a]
04:23:28 <Guest28965> segmentNotBeginningWidth _ [] = []
04:23:28 <Guest28965> segmentNotBeginningWidth b ls = if b /= (head ls) then ls else (parteCheNonIniziaCon b (tail ls))
04:24:01 <gienah> Guest28965: ls could be []
04:24:13 <quicksilver> that would be matched by his first clause
04:24:18 <gienah> right
04:24:39 <quicksilver> that segment alone has no non-exhaustive patterns in it
04:24:47 <Samuel> Hey that book cost money :)
04:24:48 <Samuel> Haskell: The Craft of Functional Programming
04:24:49 <Samuel> 3rd Edition
04:24:49 <quicksilver> it's very bad style to use 'head' and 'tail' like that
04:24:59 <quicksilver> but that won't cause a non-exhaustive patterns error
04:25:03 <quicksilver> must be coming from somewhere else?
04:26:37 <Guest28965> sorry... i am a beginner in haskell ... but if you show me how :)...
04:26:59 <benmachine> Guest28965: to fix your error, we'll need to see more of your code
04:27:05 <benmachine> (use hpaste.org)
04:27:23 <benmachine> but we can tell you for free that your function can be made prettier by pattern-matching on the list
04:28:08 <benmachine> segmentNotBeginningWidth b ls@(h:t) = if b /= h then ls else (parteCheNonIniziaCon b t)
04:28:24 <hpaste> Samuel pasted “test” at http://hpaste.org/49304
04:28:36 <Samuel> sorry :) I was testing.. that is awesome
04:28:43 <Guest28965> sorry... one moment that i fix...
04:29:22 <Guest28965> the right code is:
04:29:23 <Guest28965> segmentNotBeginningWidth :: Eq a => a -> [a] -> [a]
04:29:23 <Guest28965> segmentNotBeginningWidth _ [] = []
04:29:23 <Guest28965> segmentNotBeginningWidth b [ls] = if b /= (head [ls]) then  [ls] else (segmentNotBeginningWidth b (tail [ls]))
04:31:03 <Guest28965> but i suppose that the [] enclosure of ls is not the problem...
04:31:34 <Saizan> it is the problem
04:32:16 <Saizan> [ls] will match only singleton lists
04:32:24 <Guest28965> Saizan: the first version is widthout but non worked for me...
04:33:11 <Saizan> ok, so there was some other problem somewhere else, but [ls] is surely wrong
04:34:30 <Guest28965> Saizan, yes.
04:35:53 <hpaste> Rosario pasted “segmentNotBeginningWidth” at http://hpaste.org/49305
04:35:58 <sebz> is there a synonym for concat.repeat.map?
04:36:32 <hpaste> Guest28965 pasted “segmentNotBeginningWidth” at http://hpaste.org/49306
04:36:38 <benmachine> concat.repeat = cycle, I think
04:37:12 <sebz> great, thanks benmachine :)
04:38:16 <quicksilver> cycle . map = OSLandranger
04:39:49 <dpratt71> what does an underscore mean in a vim command? i.e. the command _ct to create tags file
04:40:57 <Guest28965> benmachine thanks a lot, width ls@(h:t) worked fine. :)
04:41:08 <benmachine> :)
04:41:35 <benmachine> Guest28965: what that pattern does is make ls refer to the list, h refer to head ls, and t refer to tail ls
04:41:53 <benmachine> Guest28965: but it only matches if the list is non-empty, so you know the head and tail actually exist
04:41:59 <benmachine> which is why it's better than using those functions
04:42:26 <Guest28965> many many thanks for your explanations
04:43:09 <Guest28965> i learned more in 5 minutes than in hours of debugging
04:44:00 <benmachine> glad to be of help :)
04:44:26 <Guest28965> :)!
04:48:25 <huangyi> dpratt71: It's LocalLeader, use maplocalleader to configure that, see :h maplocalleader
04:49:18 <Ptival> Guest28965: In general, foo@(Bar a b) allows you to patter match againt "Bar _ _" binding the first to "a" and the second to "b", while also binding the whole thing to "foo" (and allows you to use "foo" instead of repeating "Bar a b" in your right-hand-side)
04:50:02 <Ptival> (in case you didn't figure it out --- meaning it's not only for lists)
04:52:03 <dpratt71> huangyi: ok, thanks
05:36:19 <jaapweel> A friend of mine mentioned that dons had written about how to write Haskell code that re-uses the same memory for creating similar objects, rather than generating garbage. (That sort of thing would be very important if you are, say, writing a memcache-like service.) Anyone know where to find said writing, or something similar?
05:37:09 <jaapweel> I imagine I just don't know the right phrase to google, and the man is so prolific I don't really want to go through all of his blog posts...
05:39:12 <quicksilver> jaapweel: that sounds surprising to me.
05:39:28 <quicksilver> jaapweel: I've never heard of anything like that, and the assumptions run pretty deep.
05:39:41 <quicksilver> unless it was about managing memory completely manually in a mutable vector, or something.
05:40:17 <jaapweel> quicksilver: That might well be it, actually.
05:41:16 <quicksilver> I disagree that it would be very important to write an memcache clone by the way ;)
05:41:22 <quicksilver> GC is really not that expensive.
05:41:29 <quicksilver> in many uses cases it's cheaper than malloc().
05:41:51 <quicksilver> but obviously writing a good memcache clone does require a considerable amount of good engineering.
05:43:00 <zygoloid> i'd be very surprised if such a technique could actually make allocation faster in any non-contrived case
05:43:20 <jaapweel> quicksilver: It happens I work on memcache and its variants for a living ;-) The nasty thing is that hit rate is directly correlated with how many items you can store in memory, and GC is only cheap if the working set is smaller than the total heap size by some reasonable factor.
05:43:37 <zygoloid> hmm, i take that back, it could save a lot of GC time
05:44:31 <jaapweel> For a lot of programs we write every day, GC is actually better than malloc/free, but in-memory key/value stores are not one of those.
05:45:09 <jaapweel> Anyway, the phrase "mutable vector" is really all I needed. Now I can google ;-)
05:45:43 <zygoloid> you'd need the elements in the vector to be mutable too, for it to be useful
05:46:24 <jaapweel> zygoloid: Unfortunately, yes. Caching is a pretty inherently stateful thing...
05:47:02 <roconnor__> what are in memory key/value stores?
05:47:43 <jaapweel> roconnor__: Simple databases in RAM, like memcached.
05:48:04 <roconnor__> Data.Map?
05:48:05 <jaapweel> roconnor__: They're often used as a buffer between a "real" database and its clients.
05:48:33 <jaapweel> roconnor__: Data.Map, but with an eviction policy and a network interface.
05:57:02 <roconnor> what is the categorical definition of an arrow?
05:57:11 <roconnor> like how an applicative functor is a lax monoidal functor.
06:02:46 <dpratt71> grr...either I'm way misunderstanding how this haskellmode thing is supposed to work (extremely possible) or something is broken
06:02:58 <erus`> are we the bad guys?
06:04:07 <dpratt71> erus`: you were not responding to me just then, right?
06:04:27 <MasseR> dpratt71: vim haskellmode?
06:04:33 <dpratt71> MasseR: yes
06:04:54 <MasseR> What do you mean "something is broken"?
06:04:55 <djahandarie> roconnor, like a Freyd category, but even worse! http://personal.cis.strath.ac.uk/~raa/arrows.pdf
06:05:05 <dpratt71> some things appear to work, like when I type :make, other things not so much
06:05:45 <djahandarie> roconnor, wait, you're at nottingham? What're you doing there?
06:06:01 <dpratt71> the docs say if I type :IDoc {identifier} something magical will happen, but all I get is 'not an editor command'
06:06:07 <roconnor> djahandarie: I'm giving a talk
06:06:10 <roconnor> you coming?
06:06:16 <erus`> working on bitcoin haskell
06:06:20 <roconnor> :)
06:06:27 <roconnor> erus`: purecoin :)
06:06:38 <Eliel> erus`: hey, I'm interested
06:06:53 <MasseR> dpratt71: Hmm... I use :make (bound to F5) a lot so I know that works. So does _t and _T
06:06:56 <MasseR> Others I don't use too much
06:06:59 <erus`> Eliel: its roconnor not me
06:07:07 <MasseR> :ghci command seems to work, but IMO is quite useless
06:07:20 <erus`> i would check it out but its a darcs repo
06:07:22 <Eliel> roconnor: do you have a public repository somewhere?
06:07:33 <roconnor> Eliel: darcs get http://r6.ca/Purecoin -- but I haven't quite put all the code in there yet.
06:07:34 <dpratt71> MasseR: stupid question, do you literally type _t? or does the underscore represent something else?
06:07:42 <MasseR> dpratt71: Literally _t
06:07:52 <djahandarie> roconnor, hehe, no, a bit too far away
06:08:16 <MasseR> dpratt71: In normal mode
06:08:25 <Eliel> time to finally install darcs then :)
06:08:39 <roconnor> darcs get http://darcs.com/
06:08:44 <dpratt71> MasseR: ok, I think it worked that time; I wonder what I was doing before
06:09:10 <Eliel> roconnor: that link gives 403 when I open with a browser. Is that normal?
06:09:17 <roconnor> yes
06:09:22 <djahandarie> It's darcs.net
06:09:26 <roconnor> the purecoin link does
06:09:28 <erus`> why cant everyone use git like linus intended ?
06:09:43 <roconnor> I was joking about using darcs to get darcs.com
06:10:02 <roconnor> erus`: http://r6.ca/blog/20110416T204742Z.html
06:10:33 <erus`> deterministic merges
06:10:40 * hackagebot cmdlib 0.3.1 - a library for command line parsing & online help  http://hackage.haskell.org/package/cmdlib-0.3.1 (PetrRockai)
06:10:42 <erus`> does it really matter?
06:11:02 <roconnor> erus`: that is a difficult question to answer.
06:11:04 <erus`> @faq does it matter?
06:11:05 <lambdabot> The answer is: Yes! Haskell can do that.
06:12:00 <copumpkin> yes
06:12:35 <quicksilver> on the other hand there is something to my mind equally fundamentally wrong with darcs
06:12:47 <quicksilver> the assumption that just because patches syntactically commute they semantically commute.
06:12:54 <mreh> yes
06:12:59 <mreh> but that's a difficult problem to solve
06:13:27 <quicksilver> it makes me prefer systems (bzr,hg) which model trees well, rather than modelling patchsets.
06:13:43 <quicksilver> it's a sufficiently complex design question that it admits more than one plausible right way, though.
06:14:03 <roconnor> erus`: Dijkstra said those who sacrifice correctness to obtain speed will deserve neither and lose both.
06:14:11 <roconnor> erus`: or something like that.
06:14:22 <mreh> given the sematics of a language, can a revision control system separate what is an isn't going to commute?
06:14:25 <copumpkin> but as quicksilver, it's not necessarily correct either
06:14:37 <copumpkin> quicksilver said, that is
06:15:19 <ptd> mreh: No, it is possible to invent a language where that would reduce to the halting problem
06:15:37 <mreh> my point :)
06:15:38 <copumpkin> just use agda
06:15:47 <sbahra> alo alo copumpkin
06:15:53 <copumpkin> hi sbahra!
06:15:54 <roconnor> quicksilver: the notion of a patch is not necessiarly syntax based; however all the patches supported by darcs are.
06:16:09 <dpratt71> MasseR: are you able to execute any of the _? commands? like _?1 (search Hoogle)? every time I try, it just puts '?1' in the command buffer
06:16:13 <roconnor> quicksilver: I kinda want to build a semantic set of patches for epigram.
06:16:31 <quicksilver> roconnor: yes, it might work for epigram
06:16:42 <mreh> all I ever really need is change control on my specification
06:16:44 <quicksilver> but for more 'normal' programming, I want to know that a set of patches have been tested together.
06:16:51 <mreh> which for my haskell projects, tends to exist in my head
06:16:54 <MasseR> dpratt71: Ye
06:17:00 <quicksilver> and I call a 'set of patches that have been tested together' a "tree" or a "a branch"
06:17:02 <roconnor> quicksilver: doesn't tagging let you do that?
06:17:13 <quicksilver> roconnor: I believe so. Darcs permits many workflows.
06:17:21 <quicksilver> I just think patch theory isn't all its cracked up to be.
06:17:26 <roconnor> ah
06:17:31 <mreh> is the darcs way, one workflow per repo?
06:17:34 <roconnor> fair
06:17:53 <quicksilver> I think that the notion of 'tree/branch' is a better axiom for a practical workflow than that of 'patch'.
06:17:58 <roconnor> though my problem with git is orthgonal to the tree based vs patch based approaches ... granted this seems to have been lost on many of my readers.
06:18:19 <quicksilver> git has an unpleasant design but it is effective and efficient.
06:18:33 <quicksilver> and supported by some excellent tools like github and pull requests.
06:18:52 <mokus> github is the sole reason i use git
06:18:56 <erus`> yup
06:18:59 <mokus> i prefer darcs actually
06:19:00 <ptd> roconner: Semantic patches would be piling on the functionality to fix a problem that doesn't occur often in real life. e.g. merges that don't collide syntactically, rarely do semantically
06:19:03 <erus`> its like vhs vs betamax
06:19:11 <quicksilver> ptd: I disagree rather strongly.
06:19:29 <mreh> but darcs has superior picture quality
06:19:31 <copumpkin> programmers in the trenches don't encounter it
06:19:34 <copumpkin> >_>
06:19:40 <copumpkin> quicksilver: dude, give up now!
06:19:59 <quicksilver> ptd: my anecdotal experience (as a developer, and tester, and deployer of production systems) is that mergees which don't collide syntactically but do collide semantically are the bane of my life.
06:20:21 <quicksilver> so they happen often enough to hurt me (even if it might be a small %age of the exponiental number of *possible* collisions)
06:20:37 <quicksilver> copumpkin: I gave up years ago :)
06:21:23 <copumpkin> reductio ad vitam veram
06:22:10 <djahandarie> expecto patronum
06:22:21 <erus`> no spoilers!
06:22:42 <quicksilver> there is no spoon.
06:22:42 <roconnor> Eliel: I can send you the rest of the code that isn't in the repository if you ask.
06:23:12 <roconnor> @quote there.is.no.state
06:23:12 <lambdabot> MonadState says: Do not try to change the state; that's impossible. Instead only try to realize the truth: There is no state.
06:23:14 <copumpkin> I like how most people's reaction to me using latin is to quote harry potter to me
06:23:30 <EvanR> lol
06:23:44 <quicksilver> rowling's curse
06:23:58 <quicksilver> any sufficiently unfamiliar language will sound like hermione granger.
06:24:09 <ptd> The most dangerous enemy of a better solution is an existing codebase that is just good enough -- Eric S. Raymond
06:24:30 <roconnor> ptd: that would explain git.
06:24:37 <mreh> cuss
06:24:42 <mreh> oooooh
06:24:47 <EvanR> git rocks!?
06:24:49 <Saizan> copumpkin: arma virumque cano, troiae qui primus ab oris
06:25:53 <Eliel> roconnor: the code that's mission, is it still incomplete?
06:26:06 <Eliel> but yes, I'd like to look at the part too.
06:26:08 <copumpkin> Saizan: :O
06:26:08 <ptd> roconnor: That was my intention, the original quote applies to plan9 vs. unix rather than darcs vs. git
06:26:26 <mreh> I sing of arms and truth
06:26:33 <roconnor> Eliel: msg me your email address and I can send it to you.
06:27:27 <copumpkin> mreh: arms and a man
06:27:27 <erus`> what does linus say about it?
06:27:33 <mreh> shit
06:28:12 <roelof> hello, I have this function : replicate a n = [n | y <- [1..a]]
06:28:24 <Saizan> mreh: man not truth
06:28:40 <Saizan> ah, too late
06:28:52 <mreh> 1/10 SEE ME
06:28:56 <roelof> but when I do replicate 3 true I see this message : Ambiguous occurrence `replicate'
06:29:03 <roelof> How to solve this ?
06:29:09 <quicksilver> roelof: replicate is already a built in function
06:29:12 <copumpkin> roelof: someone else already wrote replicate. Call yours something else
06:29:16 <quicksilver> roelof: try giving it another name
06:29:47 <roelof> oke, So the exercise let me make a existing function
06:30:43 <Eliel> roconnor: I love how simple this base58 stuff ended up in haskell :)
06:30:52 <copumpkin> OMG BITCONZ
06:31:07 <mreh> wut
06:31:11 <roconnor> Eliel: true, but I hate the existance of the base58 stuff
06:31:16 <copumpkin> roconnor: now we need your implementation to be higher-order, so we can abstract out the distinction between bitcoin and namecoin
06:31:16 <roelof> oke, I named the function to myself
06:31:27 <roconnor> copumpkin: this might be doable
06:31:29 <Eliel> roconnor: there's a good reason for it :)
06:31:45 <roelof> But when I do roelof 3 'true' I now see this message ;  lexical error in string/character literal at character 'r'
06:31:57 <copumpkin> "true"
06:31:59 <copumpkin> not 'true'
06:32:05 <roconnor> Eliel: is there a good reason to have it encode integers instead of bytestrings?
06:32:07 <Eliel> although, base64 with 6 characters of FEC coding would probably be equally useful.
06:32:12 <copumpkin> roelof: I think it would help if you read the error message :P
06:32:30 <mreh> :t 'r'
06:32:31 <lambdabot> Char
06:32:33 <mreh> :t "r"
06:32:34 <lambdabot> [Char]
06:32:52 <mreh> > ['H','i']
06:32:53 <lambdabot>   "Hi"
06:32:55 <Eliel> roconnor: I have to admit I'm not sure what you mean.
06:33:01 <roelof> oke, but the error message don't say anything to me
06:33:13 <copumpkin> roelof: you got the syntax wrong.
06:33:14 <roconnor> the base58 encoding encodes integers instead of bytestrings
06:33:14 <mreh> see what I did there roelof
06:33:37 <copumpkin> roelof: how would you approach that problem if you weren't on IRC right now?
06:33:49 <roelof> yep, with ' it's a char with "" will be a list
06:33:55 <roconnor> so 0x00ab and 0xab are both encoded the same way in base58
06:33:58 <roelof> Googeling
06:34:23 <mreh> roelof: yup, and a [Char] in haskell is a synonym with String
06:34:37 <roelof> oke
06:35:09 <Eliel> roconnor: you sure? I think I read something about 0's at the beginning being encoded as is.
06:35:18 <Eliel> as an exception of sorts.
06:35:45 <roelof> next exercise : list comprehesion and pygthagorean numbers
06:35:48 <copumpkin> roconnor: quick quick, mine namecoins while they're still easy
06:37:41 <roelof> but for now thanks for the help
06:37:59 <roelof> this one I have to look which steps I have to take
06:38:05 <roconnor> Eliel: I'm almost certain.
06:38:09 <roconnor> Eliel: email'd
06:38:18 <Eliel> thank you
06:39:36 <roconnor> let me know if I missed anything
06:41:23 <erus`> reddit said namecoins were twice as profitable as bitcoins at the moment
06:42:24 <Ke> =D
06:44:08 <dpratt71> are haddock docs automatically installed as part of the Haskell platform?
06:45:54 <mreh> dpratt71 i don't think so
06:46:43 <mreh> dpratt71: depends on your distribution, ubuntu for example has a separate package
06:47:03 <quicksilver> I think the platform does come with docs
06:47:10 <quicksilver> IIRC.
06:47:10 <dpratt71> mreh: I'm using the Windows distro :)
06:48:20 <mreh> wikipedia say it doesn't!
06:48:42 <mreh> anyway, use cabal to download docs you dont have
06:48:51 <mreh> if the library you are using ships with them
06:49:04 <mreh> and then edit your cabal config to always download docs, that's what i've done in the past
06:49:08 <dpratt71> hmm, vim complains that it can't find html documentation, but my (admittedly very suspect) interpretation of the .vim file says it should find it fine
06:49:48 <dcoutts> mreh: btw, the haddock docs are generated at install time not shipped
06:50:08 <mreh> dcoutts: true
06:50:43 <mreh> and you get haddock for free with the haskell platform, yay!
07:08:26 <erus`> are there any chess players in here?
07:09:10 <Nimatek> erus`: Yes, I am a shitty chess player.
07:10:21 <erus`> me too :)
07:10:33 <Axman6> i seem to remember there being quite a few people who chirped up last time there was a chess discussion
07:10:49 <erus`> look at my checkmate last night http://www.reddit.com/tb/iv8r3
07:13:09 <Nimatek> Nice. It is of course a complete fail on the part of your opponent :)
07:13:14 <frerich> erus`: I only know the rules, but now how to play the game.
07:13:52 <erus`> yeah he played a few wtf moves
07:15:44 <Xaphiosis> I think I'm a bit confused... given that "data A = A" and "data B = B" are both instances of type class C, is it even possible to write a function which given an int will return either A or B, hiding that info under C?
07:16:19 <Xaphiosis> so: intToC :: forall a. C a => Int -> a
07:16:37 <Saizan> Xaphiosis: yes, but that's not the type that function will have
07:17:00 <erus`> intToC :: C a => Int -> a
07:17:02 <erus`> ?
07:17:21 <Saizan> intToC :: forall a. C a => Int -> a means that the caller of intToC is the one that is free to pick whichever instance of C it wants
07:17:35 <Xaphiosis> ah
07:17:57 <Saizan> you need an existential wrapper if you want intToC to choose instead
07:18:04 <Xaphiosis> with erus`'s version, I still get "Couldn't match type A with B"
07:18:23 <Saizan>  C a => Int -> a is the same as forall a. C a => Int -> a
07:18:51 <erus`> i never used forall :|
07:18:54 <Xaphiosis> hmm. could you point me in the direction of what to read to understand such an existential wrapper?
07:19:15 <Saizan> you need: data AnyC = forall a. C a => AnyC a; intToC :: Int -> AnyC
07:19:30 <Xaphiosis> basically, I'm rendering stuff with cairo, and I don't really care what I have in a table so long as it is renderable
07:19:48 <Xaphiosis> oh
07:20:34 <Saizan> maybe you could just make intToC return a partial application of the rendering function to whatever it wanted to return?
07:21:02 <Xaphiosis> that might work for the next iteration
07:21:30 <Xaphiosis> I think to get this thing off the ground tonight (I want to render guitar scale diagrams and save them as svg)
07:21:55 <Xaphiosis> I'll use the wrapper version, as my SizeRender class kind of painted me into a corner
07:22:16 <Xaphiosis> but thanks Saizan, those are good ideas for both alternatives!
07:22:41 <msieradzki> why does "network" package have 3 copies of every single API with different behavior in each one? ;)
07:23:07 <Saizan> heh, if you come from OOP and you think you want a typeclass you should think twice :)
07:23:36 <Saizan> http://www.haskell.org/haskellwiki/Existential_type <- for more on existential types, btw
07:24:35 <Xaphiosis> oh certainly blindly trying the OOP approach in haskell can be a mistake... but I think in this situation it isn't so bad
07:25:41 <Xaphiosis> I guess the proper way would be do actually put all the renderables in one datatype
07:26:17 <Xaphiosis> ah well, I'll get it to work and worry about perfectionism later :)
07:27:15 <rvn_> I seem to be getting Prelude.undefined when I try and load a .o with System.Plugins load_ function if the object file is in a subdirectory, yet, if the .o file is in the same directory as the executable it works fine.
07:27:27 <rvn_> Any ideas?
07:29:36 <Saizan> Xaphiosis: well, a class might even be the best solution here, or maybe a record type where you have a field for each method, there are a lot of variants
07:32:31 <Xaphiosis> I'm sorry, I'm afraid I'm still confused
07:32:45 <Xaphiosis> I've got data AnySizeRender = forall a. SizeRender a => AnySizeRender a
07:32:53 <Xaphiosis> that works
07:33:06 <Xaphiosis> but then: intToSR :: Double -> Int -> AnySizeRender
07:33:14 <Xaphiosis> intToSR r i = if i == 0 then Void (2*r,2*r) else BoxedCircle r
07:33:27 <Xaphiosis> that obviously doesn't work
07:33:29 <Saizan> you've to apply the constructor
07:33:33 <msieradzki> is there one canonical library for binary serialization (binary, binary-strict, cereal)? cereal seems to be updated recently but I don't know if it's because others were perfect before or abandoned
07:34:18 <Saizan> intToSR r i = if i == 0 then AnySizeRender (Void (2*r,2*r)) else AnySizeRender (BoxedCircle r)
07:34:23 <Xaphiosis> yes, if I do apply the constructor by putting "AnySizeRender $" in front of the if, I get Couldn't match expected type `Void' with actual type `BoxedCircle'
07:34:39 <Saizan> you can't put it in front of the if
07:35:09 <benmachine> msieradzki: I think there's a plan to merge binary into cereal or cereal into binary, I forget which
07:35:11 <Xaphiosis> right, I think I'm expecting the compiler to be sentient tonight
07:35:19 <quicksilver> congratulations you have found an abstraction leak :)
07:35:22 <benmachine> they're both commonly used, binary possibly more so
07:36:10 <quicksilver> haskell polymorphism has some limits which mean that certain obvious rewrites like "if p then f x else f y ---> f $ if p then x else y" are invalid.
07:36:20 <Xaphiosis> Saizan: that worked! Thank you so much!
07:36:23 <quicksilver> it's a crying shame. Notwithstanding there are good reasons for it.
07:37:01 <quicksilver> well dealing with polymorphic code you also end up, for example, with [f x, f y, f z, f w] which can't be rewritten as map f [x,y,z,w]
07:37:23 <bonussmile> gem install rails
07:37:23 <bonussmile> ERROR:  While executing gem ... (Errno::EACCES)
07:37:23 <bonussmile>     Permission denied - /kunden/homepages/17/d123456789
07:37:30 <bonussmile> any clue?
07:37:34 <benmachine> quicksilver: yeah that always upset me, but I don't see a way to make things better
07:37:40 <Saizan> benmachine: wrong channel?
07:37:45 <Saizan> er, bonussmile
07:37:58 <luite> benmachine: the correct command is cabal install snap ;p
07:38:04 <luite> oops bonussmile
07:38:08 <benmachine> ._.
07:38:50 <Saizan> benmachine: union/intesection types are in the literature, never seen them in practice though
07:38:53 <quicksilver> benmachine: neither do I. You can devise slightly obscene type inference engines which get a few simple cases correct.
07:39:07 <quicksilver> but a general solution is very far way.
07:39:23 <benmachine> Saizan: sounds sneaky
07:39:25 <quicksilver> union/intersection types have this nasty habit of assigning types to too many terms
07:39:32 <quicksilver> in same cases, *every* term gets a type
07:39:37 <quicksilver> ...so you get no more type errors.
07:39:40 <benmachine> :P
07:39:46 <benmachine> yeah, I wondered about that
07:39:48 <copumpkin> but zomg ceylon has them
07:39:52 <copumpkin> ZOMG
07:39:59 <quicksilver> (well, you only get type errors when you have an annotation which is directly inconsistent with an inferred type)
07:40:15 <kmc> no type errors? sounds great, i hate type errors
07:40:16 <kmc> ;P
07:40:23 <benmachine> @slap kmc
07:40:23 <lambdabot> I'd rather not; kmc looks rather dangerous.
07:40:25 <quicksilver> there was an interesting post about ocaml -rectypes
07:40:26 <benmachine> :<
07:40:34 <quicksilver> which is a related (although different) extension
07:40:51 <quicksilver> and they demonstrated six 'natural' errors in the writing of a function which all result in errors under ocaml
07:41:00 <quicksilver> and each one gets a valid (although absurd) type under -rectypes
07:42:35 <Xaphiosis> Saizan: does it make any sense to attempt to make the wrapper an instance of SizeRender as well?
07:42:48 <Saizan> Xaphiosis: yes, it does
07:43:03 <Saizan> it's not always possible though
07:43:10 <Xaphiosis> hmm
07:43:14 <Saizan> it depends on the class
07:43:59 <erus`> how can i do (f.f.f.f...n) x?
07:43:59 <Xaphiosis> could you elaborate on that? I'm just dealing with simple datatypes and a wrapper exactly like you suggested
07:45:05 <quicksilver> erus`: (iterate f) !! n $ x
07:45:29 <Saizan> Xaphiosis: well, if you have class C a where foo :: a -> SomeType it's easy: instance C AnyC where foo (AnyC x) = foo x
07:46:25 <Xaphiosis> yup, I just did that, was wondering about hidden traps though
07:46:39 <Xaphiosis> and what you meant by "not always possible"
07:46:43 <djahandarie> erus`, you could do what quicksilver said, or something like applyN :: Integer -> (a -> a) -> (a -> a); applyN 0 f = id; applyN n f = f . applyN (n-1) f
07:47:23 <Saizan> Xaphiosis: with "class C a where bar :: a -> a -> SomeType" it's impossible (without Typeable), "bar (AnyC x) (AnyC y) = bar x y" won't typecheck because x and y don't have the same type
07:47:58 <Xaphiosis> ahh
07:48:07 <rvn_> So, has anyone else has problems loading .o objects from a seperate directory?
07:52:34 <djahandarie> erus`, and that applyN generalizes to appendN for any monoid. In this case you'd want the Endo type for composition
07:52:58 <Xaphiosis> Saizan: haha, it works, but the notation has become a wee bit silly: let strs = map (AnySizeRender. Center . AnySizeRender . (AllMargin 4) . AnySizeRender . (ArialText 5)) ["A", "B", "C"]
07:53:24 <quicksilver> djahandarie: is that really any better than mconcat . replicate though?
07:53:57 <quicksilver> Xaphiosis: yes, that's a common pattern/problem. You need to play with your combinators a bit to work out the right ones
07:54:06 <Saizan> Xaphiosis: you could have arialText = AnySizeRender . ArialText
07:54:14 <quicksilver> Xaphiosis: for example, you might define "center = AnySizeRender . Center"
07:54:15 <djahandarie> It's a good question which one is 'better'. Not sure
07:54:49 <Xaphiosis> I was just about to do that... I'm glad to hear it's both a standard problem and solution
07:55:07 <Xaphiosis> now I can finish up and go to bed
07:55:17 <Xaphiosis> thank you so much fellow haskell users :)
07:56:22 <Saizan> then you should ask yourself if you ever find useful distinguishing e.g. ArialText 5 and Center .. by type
07:57:52 <quicksilver> Saizan: don't you mean arialTex n = AnySizeRender . ArialText n, by the way?
07:58:34 <Saizan> quicksilver: ah, yes
07:59:00 <quicksilver> or, (AnySizeRender .) . ArialText, but I don't enjoy writing like that.
08:12:15 <markamber_mobile> Hey, where should I go to learn Haskell I am really interested and come from a java+python and php background
08:12:44 <companion_cube> @where lyah
08:12:44 <lambdabot> http://www.learnyouahaskell.com/
08:13:22 <markamber_mobile> Thanks companion_cube
08:13:53 <markamber_mobile> Anywhere else, in case that one is not for me
08:14:42 <arw_>  haskell.org has a long list of tutorials and introductory documentation.
08:14:51 <markamber_mobile> Ok, I will look
08:15:45 <markamber_mobile> I am just really excited to learn, and once the current project I am doing is done you will be seeing a lot of me here
08:16:32 <markamber_mobile> Now I am working on a python game with a group of friends, (I know eww in you opinion)
08:18:14 <erus`> how old are you markamber_mobile ?
08:18:27 <markamber_mobile> 16
08:18:45 <erus`> you should go outside and stuff
08:18:53 <markamber_mobile> outside?
08:18:56 <erus`> dont spend your teen years on a pc like i did
08:19:03 <markamber_mobile> What's an outside?
08:19:24 <erus`> i been on the internet so much that joke isnt funny anymore :(
08:19:28 * markamber_mobile laughs
08:20:18 <markamber_mobile> Yea, I do other things, but programming is kind of my thing
08:20:33 <Xaphiosis> I think I owe some of my remaining sanity to having a pc to run away to
08:20:34 <cheater_> outside is the big room with the blue ceiling
08:20:40 <cheater_> and those wooden things called "trees"
08:21:09 <markamber_mobile> And the grass I have to cut
08:22:17 <markamber_mobile> Well thanks for the info, as I said I am quite busy with this end of the month deadline but you will see me sometime soon
08:22:54 <erus`> markamber_mobile: when you start learning haskell, stick with it
08:23:10 <erus`> the learning curve is insane but its great once you 'get it'
08:23:37 <markamber_mobile> Yea, I found that out by trying to read it
08:23:50 <markamber_mobile> Plus it is an entirely new way to think
08:24:11 <develhevel> i wrote a programm and now want to check which function cost how much time/performance, how to do this? are there any tools for it
08:24:26 <markamber_mobile> Profiling
08:24:26 <quicksilver> develhevel: yes. ghc has a built in profiler.
08:24:32 <markamber_mobile> I know that answer
08:24:38 <quicksilver> http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/profiling.html
08:24:50 <mattp_> hey guys. what are some good questions to turf someone full of shit who writes haskell on their resume?
08:25:10 <erus`> whats a monad :P
08:25:12 <mattp_> 'please explain to me what a monad is'. (note: not hiring for a haskell job)
08:25:17 <develhevel> quicksilver: how to use it?
08:25:32 <erus`> if they dont come out with a ridiculous comparison then they are full of shit
08:25:37 <Xaphiosis> markamber_mobile: there's also the book "real world haskell", which has quite practical aspects to it... I learnt how to write simple parsers using parsec from there
08:25:59 <kmc> how is monadd formed
08:26:28 <Nimatek> According to lyah, monads are a bit like socks.
08:26:31 <byorgey> kmc: ?
08:26:37 <kmc> see above
08:26:56 <byorgey> oh, hehe
08:28:10 <byorgey> mattp_: 'name three Monoid instances'
08:28:44 <kmc> not big on trivia questions
08:29:08 <byorgey> knowing Monoid instances is not trivia.
08:29:10 <kmc> mattp_, i would give them some messy project involving recursive algorithms, IO, concurrency, and a few other things
08:29:17 <kmc> and see if they can come up with a generally reasonable design
08:29:21 <kmc> they don't have to write out all the code
08:29:54 <quicksilver> develhevel: by reading that page I linked!
08:30:21 <develhevel> dont saw it sry. thx
08:30:39 <mattp_> whats weird is he applied for a graphic designer job XD
08:30:51 <kmc> then maybe it's not relevant? ;P
08:30:55 <develhevel> howto remove a package with cabal?
08:31:00 <kmc> Haskell is a good thing to put on your resume
08:31:31 <magicman> > join (***) (map snd) . partition fst . zip (cycle [True,False]) $ [1..15]
08:31:33 <lambdabot>   ([1,3,5,7,9,11,13,15],[2,4,6,8,10,12,14])
08:31:57 <byorgey> develhevel: you can't.  Just  'ghc-pkg unregister foo'
08:31:59 <kmc> it impresses a lot of employers and they don't necessarily have a way to test your knowledge / skill
08:32:10 <magicman> > take 10 . fst . join (***) (map snd) . partition fst . zip (cycle [True,False]) $ [1..]
08:32:12 <lambdabot>   [1,3,5,7,9,11,13,15,17,19]
08:32:50 <byorgey> fst . join (***) map snd === map snd . fst
08:33:10 <magicman> Yeah, but I just wanted to see if partition deals properly with infinite lists.
08:33:13 <develhevel> when i want to profile i get the error: "Could not find module `Safe'" but i have the modul installed and use it!
08:33:14 <magicman> I do need both parts of the tuple.
08:33:35 <byorgey> magicman: eh? not once you've already done the partition you don't
08:34:29 <byorgey> > fst . join (***) (map snd) $ ([(1,2), (3,4)], [(5,6), (7,8)])
08:34:31 <lambdabot>   [2,4]
08:34:32 <magicman> Let me rephrase: I need both parts of "join (***) (map snd) . partition fst . zip (cycle [True,False]) $ blah" (where blah is a possibly infinite list).
08:34:39 <byorgey> > map snd . fst $ ([(1,2), (3,4)], [(5,6), (7,8)])
08:34:41 <lambdabot>   [2,4]
08:35:04 <magicman> I just checked with "take 10 . fst" to see if I could use 'take' on the lists that are returned by partition.
08:35:07 <byorgey> oh, you just stuck on the  take 10 . fst  for testing?
08:35:08 <byorgey> oh, ok.
08:36:23 <magicman> I wrote a manual version of this alternation thing with foldr (\x (ys,zs) -> (x:zs,ys)) ([],[]), but that wasn't lazy enough. I figured I could put a ~ in front of the tuple pattern, or I could use a chain of horribly convoluted functions and Monad instances :p
08:37:08 <kmc> yeah, that sounds like a use case for lazy tuple patterns
08:37:14 <kmc> does it work?
08:37:21 <magicman> Lazy tuple patterns? Like a charm.
08:37:22 <benmachine> > foldr (\ x ~(ys,zs) -> (x:zs,ys)) ([],[]) [1 ..]
08:37:23 <lambdabot>   ([1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,...
08:37:27 <kmc> > foldr (\x ~(ys,zs) -> (x:zs,ys)) ([],[]) "hello world"
08:37:28 <lambdabot>   ("hlowrd","el ol")
08:38:44 <anandjeyahar> numChainsLonger :: (a -> [a]) -> Int -> Int numChainsLonger cf x = length (filter \xs -> length xs > x  (map cf [1..100])) Can anyone see the error here??
08:38:55 <anandjeyahar> i get parse error on '\'
08:39:13 <parcs> filter $ \x
08:39:15 <byorgey> filter \xs ->  ... is not valid syntax
08:39:31 <byorgey> need a $ after filter or parentheses around (\xs -> ...)
08:39:41 <ptd> :t (\cf x -> length (filter \xs -> length xs > x  (map cf [1..100])))
08:39:42 <lambdabot> parse error on input `\'
08:39:44 <kmc> is there a good reason for the syntax to work that way?
08:39:55 <kmc> i feel like «f \x -> x» should be unambiguous
08:39:59 <anandjeyahar> byorgey :Oh ok..
08:40:16 <ptd> but "\" doesn't look like lambda
08:40:30 <ptd> "(\" does look like lambda
08:40:34 <kmc> heh
08:40:35 <quicksilver> kmc: I have wondered that.
08:40:40 <benmachine> me too
08:40:40 <kmc> upper-case lambda?
08:40:41 <anandjeyahar> ptd:-P
08:40:59 <Iceland_jack> kmc: lambda was upper case before they started using the lower-case λ
08:41:07 <kmc> in the lambda calculus?
08:41:13 <develhevel> i have a question, i want to profile my code (ghc -prof ..) but now when i want to run geht, i always get: Perhaps you haven't installed the profiling libraries for package. But i use many packages, so i caht use profiling?
08:41:25 <byorgey> lambda was a carat before they started using lower-case
08:41:30 <c_wraith> develhevel: you'll have to install profiling libraries for each.
08:41:32 <kmc> no, you just need to install the profiling libraries for those packages
08:41:33 <Iceland_jack> kmc: it comes from Principia Mathematica
08:41:35 <kmc> like it says
08:41:39 <anandjeyahar> byorgey: thanks..
08:41:46 <Iceland_jack> it used to be a ^ on top of the free variable
08:41:51 <kmc> Iceland_jack, oh, really? i thought the notation was invented by Church
08:41:52 <benmachine> develhevel: I have cabal-install install profiling libraries by default
08:41:54 <kmc> i was wrong :)
08:42:01 <develhevel> c_wraith: but where do i find them? e.g. for safe-3.0
08:42:10 <Iceland_jack> then Russell started writing ^x(...) instead
08:42:11 <benmachine> develhevel: cabal install -p, I think
08:42:15 <kmc> --reinstall
08:42:24 <benmachine> develhevel: go edit your .cabal/config and set profiling to true
08:42:24 <Iceland_jack> and then ^ became upper-case lambda which then became λ
08:42:39 <byorgey> Iceland_jack: I thought it went straight from ^ to lower-case lambda
08:42:41 <byorgey> but I am not sure
08:43:07 <Iceland_jack> I believe he felt it was too similar to an upper case A
08:43:14 <ptd> The author of unlambda uses "^" for lambda.
08:43:47 <Iceland_jack> Paradigms Of Artificial Intelligence: Programming Case Studies In Common Lisp agrees with me
08:44:09 <quicksilver> barendregt used a lower-case lambda
08:44:10 <ptd> The inventor of the lambda calculus used lambda (obviously). He had pen and paper and lambda is really easy to write.
08:44:31 <develhevel> thank you
08:44:50 <arw_> with a properly configured keyboard layout, lambda is just altgr-l or something similarly simple.
08:45:26 <c_wraith> you europeans and your altgr button.
08:45:38 <kmc> us americans and our compose key
08:46:22 <ptd> arw_: If we were to actually use lambda we would need unicode, haskell predates widespread use of unicode.
08:47:28 <ptd> arw_: Having to configure your keyboard to use haskell would be a pain (It's hard enough to learn already)
08:47:36 <magicman> Does {-# LANGUAGE UnicodeSyntax #-} allow a lambda to be used for lambda?
08:48:16 <Saizan> no
08:48:18 <arw_> ptd: depends, configuring your keyboard to do stuff is quite normal outside the US i guess.
08:48:51 <Cale> λ is easy for me to type, but it's not the lambda you'd want to use, because it's a letter.
08:49:16 <magicman> Ah, it's a valid variable name.
08:49:19 <Cale> You'd probably want one of the mathematical lambdas, rather than stealing the Greek letter.
08:49:46 <byorgey> oh, are there other unicode lambdas?
08:50:18 <Cale> yeah
08:50:40 <siracusa> For function Data.Time.Format.formatTime, is there a way to get the seconds up to milliseconds, i.e. like parameters %q or %Q but with only 3 decimals?
08:51:10 <Cale> 𝛌𝜆
08:51:45 <ptd> arw_: modern operating systems come with a massive selection of keyboard layouts, so choosing the right one is merely selection from a drop down list
08:52:38 <quicksilver> the mere fact there are multiple lambdas in unicode is the reason why unicode is pretty impractical for programming.
08:52:50 <quicksilver> it's not pleasant programming in a font which contains many similar characters with different semantics.
08:53:01 <dmwit> siracusa: I guess the documentation of formatTime is pretty exhaustive; if you don't see it there, you'll have to hack something up yourself.
08:53:10 <dmwit> siracusa: I can imagine a few ways of doing it, none of them pretty. =)
08:53:33 <siracusa> okay
08:53:34 <dmwit> siracusa: e.g. use take/drop on the resulting String; use the various instances to do the math yourself; etc.
08:54:29 <siracusa> I think I'll add zeros and take the last 3 decimals then
08:55:13 <siracusa> No, the first 3 decimal after the period, that is
08:56:24 <ptd> quicksilver: Almost all languages compose Unicode characters from ASCII ones (e.g. "(\"), although some support Unicode in identifiers (e.g. Google Go)
08:58:39 <derrida> apl :)
09:00:05 <ptd> derrida: Ah, The One True Exception!
09:00:29 <quicksilver> ptd: yes, I just don't think it's a very good idea if people actually use it.
09:00:45 <quicksilver> the difference between the three different epsilons which look the same or almost the same in many fonts
09:00:51 <quicksilver> is just another really annoying source of error
09:01:07 <develhevel> when i try to profile my programm, i get the message: /usr/bin/ld: cannot find -lHShxt-regex-xmlschema-9.0.0_p. what is that?
09:01:08 <quicksilver> (if you were ever attempted to name your error term epsilon - which GHC would accept, depending which epsilon, in fact)
09:01:31 <quicksilver> develhevel: you can't profile withour profiling libraries.
09:01:45 <quicksilver> develhevel: unforutnately you'll have to reinstall all the libraries that this project uses with --enable-profiling
09:02:02 <Peaker> Unicode symbols also get into the whole mess of bidirectional languages
09:02:15 <develhevel> quicksilver: just reinstalled hxt with profiling
09:02:22 <magicman> Agda uses Unicode everywhere. Though I wouldn't call that a widely-used language >_>
09:02:24 <Peaker> and the gain seems so minimal..
09:02:32 <Peaker> magicman: And I find that fact very unfortunate...
09:02:42 <magicman> Aye.
09:02:58 <quicksilver> java permits unicode in identifiers, strings, and comments doesn't it?
09:03:03 <ptd> Peaker: There was even a windows security venerability, that involved hiding the file extension with bidirectional text
09:03:14 <quicksilver> but not custom unicode operators of course.
09:03:17 <Peaker> ptd: ah, heh
09:03:43 * edwardk waves hello
09:03:45 <magicman> I've yet to find the balance between putting every property ever in the type, and just leaving it for what it is.
09:04:17 * byorgey waves at edwardk 
09:06:14 <ptd> There's a nigh infinite number of programming languages and we've found two with Unicode in the core, this suggests my "almost all" statement was true in the strict mathematical sense.
09:06:46 * copumpkin waves at byorgey 
09:07:02 * ptd waves at copumpkin
09:09:08 * dmwit waves vaguely without looking up from his book
09:09:33 <anandjeyahar>     No instance for (Num a)       arising from the literal `4'     In the expression: 4     In the second argument of `map', namely `[1, 3, 4, 4]'     In the second argument of `filter', namely `(map cf [1, 3, 4, 4])' Failed, modules loaded: none.
09:09:40 <anandjeyahar> what does this error mean?
09:10:31 <ptd> anandjeyahar: Your expression doesn't typecheck, can we have a look at it please?
09:11:10 <anandjeyahar> ptd: numChainsLonger :: (a -> [a]) -> Int -> Int numChainsLonger cf x = length (filter (\xs -> length xs > x)  (map cf [1,3,4,4]))
09:11:11 <dmwit> That doesn't look like a complete error message to me.
09:11:21 <anandjeyahar> there you go.. sorry for my newbieness.
09:11:55 <dmwit> ah
09:12:15 <ptd> anandjeyahar: The trick here is to decompose the expression into bits and see if they typecheck
09:12:19 <ptd> :t (map cf [1,3,4,4])
09:12:21 <lambdabot> Not in scope: `cf'
09:12:28 <ptd> :t (\ cf -> map cf [1,3,4,4])
09:12:29 <lambdabot> forall a b. (Num a) => (a -> b) -> [b]
09:12:45 <dmwit> anandjeyahar: Your type claims that your "cf" function works for any "a" -- including an "a" chosen by some vicious attacker.
09:12:46 <Peaker> anandjeyahar: it's hard to read your line-pastes, maybe you can paste at hpaste?
09:12:57 <dmwit> anandjeyahar: But you're applying it to things which must be instances of "Num".
09:13:19 <dmwit> anandjeyahar: So your vicious attacker could just make up a new type without giving it an instance of "Num" and break your code. This is GHC's complaint.
09:13:30 <ptd> :t (\ cf x -> filter (\xs  -> length xs > x) map cf [1,3,4,4])
09:13:32 <lambdabot>     Couldn't match expected type `[[a]]'
09:13:32 <lambdabot>            against inferred type `(a1 -> b) -> [a1] -> [b]'
09:13:32 <lambdabot>     In the second argument of `filter', namely `map'
09:13:38 <dmwit> anandjeyahar: Why not add a "Num a" constraint to your context, or specialize the type of "cf" in another way?
09:13:40 <anandjeyahar> dmwit: am just learning haskell
09:13:46 <ptd> :t (\ cf x -> filter (\xs  -> length xs > x) (map cf [1,3,4,4]))
09:13:47 <lambdabot> forall a a1. (Num a1) => (a1 -> [a]) -> Int -> [[a]]
09:14:54 <ptd> :t (\ cf x -> length (filter (\xs  -> length xs > x) (map cf [1,3,4,4])))
09:14:55 <lambdabot> forall a a1. (Num a1) => (a1 -> [a]) -> Int -> Int
09:15:15 <anandjeyahar> ptd: am beginning to get some clue thnk for the type check by parts tip
09:16:44 <ptd> The use of such powerful type inference facilities causes really cryptic error messages
09:17:14 <ptd> generally, more power implies worse error messages
09:17:17 <anandjeyahar> ptd:Yeah... am realizing that to be the most frustrating part of haskell yet..
09:17:24 <copumpkin> cryptic is a function of person reading
09:17:31 <copumpkin> and their experience
09:17:50 <anandjeyahar> this is infact modification example code straigt off LYAH
09:17:55 <quicksilver> whilst that's true, I think the typeclass errors really are cryptic.
09:18:29 <quicksilver> becuase you subsitute 'x does not match y' with "hmm, x would match y if x was an instance of class Z - can I prove or assume that? No, report error in trying to find instance of Z"
09:18:35 <anandjeyahar> copumpkin: agreed. but then for a functional programming newbie with no Formal CS background this is cryptic
09:18:47 <quicksilver> ...without giving an evidentary trail back to *why* we were looking for an instance of Z in the first place.
09:19:45 <Saizan> it usually points to an use of a method of Z when it gives you an error like that
09:20:14 <ptd> anandjeyahar: The typesystem works on your side as well, it can catch simple schematic errors as well
09:21:59 <anandjeyahar> ptd: Yeah, overall am not complaining too much.. so far i have liked haskell/functional approach so much that, i resolved to learn web programming only on yesod
09:22:01 <anandjeyahar> :)
09:23:12 <quicksilver> Saizan: it does, but the identity of the thing which is not a member of Z needs to be traced back through several contexts to the place in which evidence suggests it is not (necessarily) one.
09:23:27 <noob1234> hi
09:24:10 <quicksilver> for example, a better error this time would have been "type signature too general - as written (a -> [a]) -> ... but must be Num a => (a -> [a]) -> ...
09:24:13 <byorgey> hi noob1234
09:24:18 <noob1234> anyone up for another question about monads?
09:24:31 <quicksilver> howveer I do understand that giving a better error message for one case doesn't easily generalise.
09:24:57 <dmwit> noob1234: I'm up for questions about monads, but I'm not up for questions about questions about monads... ;-)
09:26:23 <anandjeyahar> Ok, bye guys. i gotta sleep now. my brain's stopped thinking
09:26:25 <anandjeyahar> bye
09:26:35 <ptd> Groking monads is the hardest stage of learning haskell
09:26:37 <ptd> bye
09:27:13 <noob1234> so it's my understanding that in fp, you can't change the nature of a function - it accepts argument(s) and returns value(s)
09:27:30 <siracusa> I guess the Haddock docs cannot tell me in what source file an instance definition is, can it?
09:28:18 <ptd> siracusa: They should be able to, since they can track down a definition in a different file for you
09:28:41 <siracusa> So how then?
09:29:08 <noob1234> so you create another function to handle the data and some metadata?
09:29:53 <ptd> noob1234: Functions are pure, they cannot have side effects
09:30:22 <Saizan> siracusa: they don't
09:30:49 <siracusa> Specifically, I'm looking for the place Show UTCTime is defined
09:30:59 <ptd> siracusa: Sorry, my bad
09:31:35 <Saizan> siracusa: it's in some .Format* module iirc
09:31:52 <noob1234> so monads are a design pattern for propagating extra data?
09:32:30 <ski> noob1234 : i'm not sure what you're after with "data and some metadata"
09:32:47 <Entroacceptor> they are often used for that
09:33:00 <dmwit> noob1234: In short: yes!
09:33:12 <ski> noob1234 : take the `Maybe' monad e.g. -- is it "propagating extra data" ?
09:33:27 <dmwit> ski: Yes! It's propogating the bit "has there been a failure yet".
09:33:53 <ski> dmwit : yeah. but i'm not sure that this is *extra* data ..
09:34:07 <ski> imho, it's *alternative* data
09:34:21 <ski> of course, it all depends on what noob1234 means by "extra data"
09:34:21 <dmwit> I don't see a meaningful distinction.
09:34:33 <noob1234> that's a good question
09:34:34 <ptd> noob1234: The IO monad is the strangest monad around, learn the others first
09:34:45 <dmwit> I think noob1234 has hit on a fine intuition for most practical use-cases of Monad in Haskell.
09:35:03 <noob1234> what should i mean when i say metadata or extra information?
09:35:11 <noob1234> when i *ask*
09:35:22 <ski> "A, and extra B" leads me to think of `A /\ B', `A * B', `(A,B)'
09:35:23 <ski>   while "A, or alternatively B" leads me to think of `A \/ B', `A + B', `Either A B'
09:35:46 <ski> noob1234 : i dont know :)
09:36:15 <ptd> ski: and both of those are monads, State and Either respectively
09:36:18 <ski> i think it's probably better to look at concrete examples, and see what you can actually do with monads
09:36:42 <ski> ptd : hehe. the former could as well be `Writer B' :)
09:36:59 <ptd> noob1234: Monads are types that enhance other types
09:37:24 <djahandarie> Monad is a typeclass.
09:37:29 <ptd> Integer is an Integer
09:37:43 <ski> in some sense, monads are a design pattern for sequencing, with data dependencies
09:37:44 <noob1234> so what you do with the enhanced types determines what kind of monad you create?
09:37:45 <djahandarie> That is a tautology.
09:38:03 <ptd> Maybe Integer is either an Integer or a failure to produce an Integer
09:38:15 <ski> what "sequencing" actually means will depend on the monad in question
09:38:26 <ptd> noob1234: Yes, different monads do different things
09:38:33 <ptd> Consider the list monad
09:38:47 <ski> > do x <- [0,1,2]; y <- [0 .. x]; return (10 * x + y)
09:38:48 <lambdabot>   [0,10,11,20,21,22]
09:39:03 <ski> here "sequencing" means which way around "nested loops nest"
09:39:09 <ptd> It represents computations that produce more than one result
09:39:36 <ptd> > [0, 1, 2] >>= (+1)
09:39:38 <lambdabot>   No instance for (GHC.Num.Num [b])
09:39:38 <lambdabot>    arising from a use of `e_10121' at <in...
09:39:49 <ptd> > [0, 1, 2] >>= return (+1)
09:39:51 <lambdabot>   The section `GHC.Num.+ 1' takes one argument,
09:39:51 <lambdabot>  but its type `[b]' has none
09:39:59 <ptd> > [0, 1, 2] >>= (return (+1))
09:40:00 <lambdabot>   The section `GHC.Num.+ 1' takes one argument,
09:40:01 <lambdabot>  but its type `[b]' has none
09:40:10 <Eduard_Munteanu> > [0, 1, 2] >>= return . (+1)
09:40:11 <lambdabot>   [1,2,3]
09:40:16 <ski> noob1234 : do you have any concrete monad question ? or are you wondering more what is possible and is not possible with monads, trying to get a grip on them ?
09:40:28 <ptd> Eduard_Munteanu: thanks
09:40:49 <noob1234> still trying to wrap my head around the concept
09:41:11 <ski> ok. i suggest looking at more specific monads
09:41:14 <ptd> All about monads is a great in-depth explanation
09:41:25 <noob1234> in other words, what's the pattern?
09:41:36 <ptd> horna.org.ua/books/All_About_Monads.pdf
09:41:47 <ski> "in general" monads don't have that much of a pattern
09:41:57 <noob1234> what is the problem it's trying to solve, in general terms
09:42:00 <john> so… just installed OS X 10.7 Lion, ghc works fine, but I tried to install something from cabal and I got what seems like a billion lines of ld warnings
09:42:07 <Cale> noob1234: Many libraries have a similar looking interface
09:42:09 <noob1234> or the problems you can solve using them
09:42:30 <ski> noob1234 : "sequencing, with data dependencies", is one attempt of an answer
09:42:45 <Cale> noob1234: Monad captures that particular "shape", to a certain extent, and lets us write functions which operate with any library whose API has that particular shape.
09:43:08 <Cale> noob1234: What the generic functions do will depend on what the library does.
09:43:12 <Eduard_Munteanu> noob1234: I'd recommend starting with the Maybe monad for error handling
09:43:23 <Eduard_Munteanu> @src Monad Maybe
09:43:23 <dmwit> ?where sigfpe_monads
09:43:23 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
09:43:24 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
09:43:25 <ski> noob1234 : another answer is that a monad is a type `m' with two operations `return :: forall a. a -> m a' and `(>>=) :: forall a b. m a -> (a -> m b) -> m b' that satisfy three simple-looking laws
09:43:30 <Eduard_Munteanu> @src Maybe Monad
09:43:31 <lambdabot> Source not found. The more you drive -- the dumber you get.
09:43:33 <Eduard_Munteanu> Damn.
09:43:37 <ski> @src Maybe return
09:43:38 <lambdabot> return              = Just
09:43:40 <ski> @src Maybe (>>=)
09:43:41 <lambdabot> (Just x) >>= k      = k x
09:43:41 <lambdabot> Nothing  >>= _      = Nothing
09:43:43 <Cale> For example, in the IO monad, sequence :: [IO a] -> IO [a] will take a list of IO actions, and produce an IO action which when run, will run each of them in turn and collect up a list of the results.
09:43:43 <alpounet> @google you could have invented monads
09:43:44 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
09:43:45 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
09:43:52 <noob1234> lambdabot: that's what i just read and that's why i'm here
09:44:23 <Cale> In a parser monad, sequence :: [Parser a] -> Parser [a] will take a list of parsers, and produce a parser which will parse the concatenation of the things they parse, returning a list of the results
09:44:45 <Eduard_Munteanu> noob1234: she's a bot :). You can talk to her via the @vixen command, if you really want to :D
09:44:48 <Cale> In the list monad, sequence :: [[a]] -> [[a]] takes a list of lists, and produces a list of ways of picking one element from each of them
09:45:01 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
09:45:01 <noob1234> lol, ok
09:45:02 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
09:45:21 <Cale> ("running" a list in the list monad means picking one element from it in all possible ways)
09:45:21 <Eduard_Munteanu> @vixen Hey!
09:45:22 <lambdabot> cool
09:45:36 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
09:45:37 <lambdabot>   [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2...
09:45:55 <newbieHaskell> hello guys, does haskell produce multithreaded code ?
09:46:01 <ptd> > [1,2,3] >>= return . (+1)
09:46:03 <lambdabot>   [2,3,4]
09:46:11 <Cale> newbieHaskell: You can write multithreaded code.
09:46:14 <Eduard_Munteanu> newbieHaskell: yep, you can write parallel code
09:46:20 <Cale> Parallel and concurrent
09:46:32 <copumpkin> and everything in between!
09:46:33 <Eduard_Munteanu> Yeah.
09:46:40 <newbieHaskell> i mean since it is functional isn't it automagicly concurent too ?
09:46:45 <Cale> no
09:46:50 <Cale> because that's unrealistic
09:47:01 <Eduard_Munteanu> newbieHaskell: autoparallelization is a really tough problem
09:47:03 <copumpkin> newbieHaskell: it's a lot easier to make parallel when that is possible
09:47:11 <ski> noob1234 : i happen to like <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html> as a small attempt of an answer for what could motivate one to invent monads (note that that monad tutorial is a bit old though, some library functions mentioned have been renamed)
09:47:12 <copumpkin> but automatic parallelization isn't really feasible yet
09:47:12 <Cale> Determining how to split evaluation tasks across parallel processors is a hard problem
09:47:14 <copumpkin> (or ever)
09:47:27 <noob1234> ski: thanks
09:47:33 <newbieHaskell> yeah i can imagine
09:47:37 <newbieHaskell> thanks
09:47:40 <Cale> You can annotate your code with par and various strategies composed from it, and get parallelisation pretty easily though.
09:47:54 <ptd> newbieHaskell: How does the complier know when to make it multithreaded, will it be an optimisation or a pessimism?
09:48:01 <Cale> parMap for example, in Control.Parallel.Strategies, is pretty handy
09:48:57 <ptd> newbieHaskell: You tell the compiler how to parallelize your code and it does it for you.
09:49:12 <Eduard_Munteanu> DPH kinda does that for you.
09:49:29 <Eduard_Munteanu> Though I'm not sure it's ready yet.
09:50:27 <Cale> newbieHaskell: In GHC, we have: very lightweight sparks created by par (representing expressions to be evaluated by some worker if there's time) and lightweight concurrent threads created by forkIO, and both of those things are M-to-N scheduled onto a number of workers as determined by the +RTS -N<n> flag.
09:50:39 <ski> noob1234 : anyway, iirc, the "all about monads" tutorial ptd mentioned about works through most of the commonly used monads -- doing that (and then combined monads, like with monad transformers) should give you some kind of a feel for what's possible with monads
09:51:00 <Cale> You'll need to compile with -threaded to get the threaded runtime system for that
09:51:35 <Cale> and I think -rtsopts now, because someone was a bit of a dick and requested that those be turned off by default :P
09:54:11 <burbul> Is it good practice to rely on the order of pattern matches (where you are matching against one of several patterns), or should one make sure that all of the pattern matches are mutually exclusive?
09:55:18 <Cale> burbul: Well... it depends. You should certainly be aware of the order of pattern matches.
09:55:21 <ski> if it's no extra burden, i'd go for making them mutually exclusive (or at least agree on overlap)
09:56:32 <ski> if such a rewriting would be a larger burden (syntactically vel efficiency-wise), it's probably better to rely on ordering
09:56:51 <burbul> The case I;ve got is
09:56:52 <burbul>         filter_node' f n@(Node _ _ _ []) = Just n
09:56:52 <burbul>         filter_node' f n@(Node from to cat readings)  = ...
09:57:17 <burbul> So I could write readings@(r:rs) --- or even, I suppose, readings@(_:_)
09:57:27 <burbul> To emphasise that 'readings' will be nonempty...
09:57:39 <noob1234> sorry, afk
09:57:55 <noob1234> thanks for the advice, i'll be back
09:58:18 <ski> hm, i suppose in this case it's pretty obvious at first glance that there's an overlap -- so do whichever you prefer
09:58:24 <burbul> ok -- thanks!
09:59:15 <ski> (an alternative would be to use `null readings' with a guard)
09:59:54 <Cale> As an additional point, most Haskellers prefer camelCase, because the standard library uses it.
10:00:30 <Cale> You can use underscores if you want of course :)
10:00:53 * ski sometimes uses both camelCase *and* underscores
10:00:53 <burbul> Hm -- I've been using pattern matching instead guards because of http://www.haskell.org/haskellwiki/Things_to_avoid#Guards
10:00:59 <ski> (in the same name)
10:01:04 <burbul> :)
10:01:41 <ski> what you generally should avoid is using `head' and `tail', for lists
10:01:43 <Cale> That things to avoid document...
10:01:44 <burbul> I do intend to move across from _s to camelCase at the moment (not least because  it makes hlint complain a lot) -- but it'll take a little work...
10:02:02 <burbul> ski: so use pattern matching instead?
10:02:03 <newbieHaskell> haskell looks amazing, do you have any book or getting started tutorial to propose to a haskell noob ?
10:02:05 <ski> `null' is fine more commonly than `head',`tail'
10:02:08 <Cale> I haven't read it in a while, but it was started out by some people who wrote Haskell code in a very unusual style :)
10:02:16 <burbul> ah, ok
10:02:50 <Cale> (basically some people extremely opposed to syntactic sugar)
10:02:53 <ski> burbul : imo, in this case guards would be as fine as pattern-matching (since you're not really extracting any parts out in the matching)
10:03:06 <mightybyte> newbieHaskell: Real World Haskell (http://book.realworldhaskell.org/) and Learn You a Haskell (http://learnyouahaskell.com/)
10:03:14 <Cale> But yeah, avoid head and tail, and other functions like that.
10:03:14 <burbul> Re: head... I know it's a problem, but I'm not sure what the idiomatic workaround is;
10:03:15 <burbul> cf.
10:03:18 <burbul>     = do let input = map Token . split isSpace . head . lines $ text
10:03:23 <Cale> null is okay where it's convenient though
10:03:45 <newbieHaskell> thank u :-D
10:04:03 <Cale> newbieHaskell: And don't be afraid to ask questions about the language here.
10:04:06 <burbul> (that's inside a monad m which I'm just using to handle errors)
10:04:08 <ski> burbul : the question you should ask yourself is "what is `text' is the empty string ?"
10:04:08 <roconnor> null is about as bad as Bool is.
10:04:18 <burbul> yes -- I know it's a problem
10:04:34 <ski> burbul : if you're sure `text' can't be empty, then i think that use of `head' is ok
10:04:40 <burbul> I wrote the code, make sure it worked and then started going through and generating proper error messages
10:04:51 <Cale> case lines text of
10:04:55 <Cale>   [] -> ...
10:05:00 <burbul> In this case it's something I'd rather generate an error for
10:05:01 <Cale>   (x:xs) -> ...
10:05:08 <burbul> Calse: thanks
10:05:10 <ski> roconnor, aye
10:05:14 <mightybyte> newbieHaskell: Yes, Cale is right.  The Haskell community (especially this IRC channel) is one of the most newbie-friendly communities I've seen.
10:05:22 <burbul> I can strongly agree with that
10:05:28 <kmc> > let sum xs = if null xs then 0 else head xs + sum (tail xs) in sum [1..10]
10:05:29 <lambdabot>   55
10:05:36 <kmc> ^^^^ how not to do it :)
10:05:42 <burbul> I've asked very basic questions here and everyone has been extremely helpful
10:05:48 <newbieHaskell> nice
10:05:48 <kmc> that's why 'null' is a warning sign -- it goes with that style
10:06:06 <ski> Cale,burbul : s/(x:xs)/x:xs/ :)
10:06:52 <newbieHaskell> thanks for everything, best irc help channel evah :-D, bb
10:09:17 <burbul> Is there a statement like 'guard' that I can use to check that text is not empty *and fail with an appropriate error message if it is* ?
10:09:35 <burbul> actually, when looks good...
10:10:07 <hpaste> silver pasted “fererer” at http://hpaste.org/49319
10:10:24 <silver> :S
10:12:54 <burbul> If you have a moment, could you look at http://hpaste.org/49320 ? [It does what I needed to, but I'm not sure whether it's good style.]
10:13:52 <ski> i would bind `lines text' to a name in a `where' (or `let', if you prefer)
10:14:24 <ski> i'd probably use `error' directly instead of `fail'
10:14:27 <burbul> ok -- thanks!  (But you wouldn't rewrite it to use pattern matching?)
10:14:28 <ski> (which monad is this ?)
10:14:38 <burbul> I haven't specified -- I just wrote
10:14:46 <burbul> packedforest_from_string :: Monad m => String -> m PackedForest
10:14:59 <acowley> Can I get haddock to resolve a type synonym to what it is standing in for if the type synonym itself isn't exported from a module?
10:15:10 <ski> i see you use both `head (lines text)' and `tail (lines text)' so yes, then i would use pattern-matching instead
10:15:11 <burbul> Cf #4 in http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors
10:15:34 <burbul> ok -- thanks again
10:16:43 <ski> imho, `fail' is a bit ugly hack, and should normally only be called implicitly by pattern-match failure
10:17:07 <burbul> got it
10:17:10 <ski> @undo do Just x <- foo; bar x
10:17:10 <lambdabot> foo >>= \ a -> case a of { Just x -> bar x; _ -> fail ""}
10:17:27 <burbul> Although in this case I would like to generate a meaningful error message
10:17:33 <burbul> Which, I think, means calling fail?
10:17:50 <ski> if you want to report error, then either `error', or do you own inspectable error type (using a monad or applicative functor, typically)
10:18:16 <ski> `fail' is `error' per default, if the monad in question hasn't overridden it
10:18:23 <burbul> I don't want to stop execution
10:18:38 <burbul> I will probably be executing this in the Maybe monad or the Either monad
10:18:51 <burbul> (Haven't decided yet, and Monad m => ... gives me flexibility)
10:18:53 <ski> in the `Maybe' monad and the list monad, `fail' is defined to ignore your error message string and give `Nothing' resp. `[]'
10:19:14 <burbul> Yes; that's fine for now. Later on I might want to get hold of the error messages and if so I will switch to the either monad
10:19:40 <ski> what do you mean by "I don't want to stop execution" ? -- do you want to be able to recover from an error ? inspect the error programmatically ?
10:20:29 <burbul> The program works in a 'batch' mode on a bunch of paragraphs. If there's an error in one paragraph, it should output as suitable message to stderr and then move on to processing the next paragraph.
10:20:42 <burbul> So I guess that's 'recover from an error' + something else
10:20:58 <ski> ok
10:21:35 <ski> it looks like your error there is pretty opaque, so the only sensible thing one can do with it is print it out
10:21:59 <ski> otherwise, i'd prefer making a new type of errors, with a constructor for each kind of error
10:22:41 <burbul> String error messages is fine, at least for now.
10:23:00 <burbul> The difficulty is combining pattern matching with  raising an error...
10:23:10 <burbul> At the moment I have
10:23:14 <burbul> when (null . lines $ text) (fail "packedforest_from_string: Empty input.")
10:23:18 <burbul> let (input_text:section_text) = lines text
10:23:32 <c_wraith> fail scares me.
10:23:37 <burbul> But I feel like there ought to be nice way of matching against [] and invoking fail
10:24:21 <burbul> c_wraith: I didn't pull it out of thin air -- it's from http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors (which also recommends it for anything that generates string error messages). I like the flexibility of being able to ignore the error (in Maybe) or get hold of it (in Either)
10:24:56 <ski> (burbul : i.e. i was talking about #5 at the above link. .. except that i hate that `Error' class, so would use a monad library which didn't require it (i don't recall which that is, right now))
10:25:12 <burbul> ok
10:25:37 <ski> but `error' or `fail' is probably fine, for now
10:26:12 <burbul> Well, the thing that seems ugly is having a separate 'when'... I feel like there should be a way of using pattern matching instead
10:26:16 <ski> burbul : how about :
10:26:27 <ski>   case lines text of
10:26:50 <ski>     [                     ] -> fail "packedforest_from_string: Empty input."
10:26:56 <ski>     input_text:section_text -> do
10:26:58 <ski>       ...
10:27:01 <ski> ?
10:27:24 <burbul> so that involves having a do block nested inside another do block ?
10:27:54 <ski> well, you probably don't need to have the `case ... of ...' inside a `do'-expression
10:28:26 <ski> (anyway, this way around, you don't compute `lines text' twice)
10:30:16 <burbul> I see
10:30:19 <burbul> How about
10:30:20 <burbul>          (input_text:section_text) <-
10:30:20 <burbul>              case lines text of [] -> fail "packedforest_from_string: Empty input."
10:30:20 <burbul>                                 l:ls -> return (l:ls)
10:30:22 <burbul> ?
10:30:44 <kmc> the last line can be just v -> v
10:30:47 <burbul> [ that's inside the main do block]
10:30:51 <kmc> because you already checked the other case
10:30:54 <ski> `v -> return v'
10:30:56 <kmc> or v -> return v i mean
10:31:16 <kmc> if you actually need to check a constructor but want to use the overall value rather than a field, you can use an @-pattern
10:31:19 <burbul> yes -- thanks
10:31:21 <kmc> v@(_:_) -> return v
10:31:51 <ski> burbul : also, you can replace `(input_text:section_text) <-' by `input_text:section_text <-'
10:32:20 <burbul> right -- thanks.
10:32:55 <ski>   input_text:section_text <- case lines text of
10:33:00 <ski>     [] -> fail "packedforest_from_string: Empty input."
10:33:00 <ski>     v  -> return v
10:33:13 <ski> i would consider as prettier indentation .. ymmv
10:33:44 <burbul> No, you're right, it does look nicer.
10:33:44 * ski still thinks this feels a bit icky in that it matches on `lines text' two times ..
10:33:59 <burbul> Two times? I don't follow that...
10:34:00 <ski> .. but it's your code :)
10:34:23 <burbul> Well, the reason I'm asking here is that I want to know how to write nicer Haskell. (There's a lot of stuff on the Internet that tell you how to do things, but not so much stylistic advice)
10:34:25 <ski> first the `case' matches on `[]' in the branch, then the `<-' matches on a cons pattern
10:34:57 <burbul> So you would use the 'when' guard instead?
10:35:06 <ski> i'm not saying that doing the above is necessarily bad style
10:35:22 <ski> i'm just saying i would probably use the previous `case' version i mentioned above
10:35:25 <burbul> ah
10:35:41 <burbul> The reason I was not as keen on that is that it seems to increase the level of indentation...
10:35:50 <ski> (matching on `[]' in one branch and on `input_text:section_text' in the other)
10:35:51 <burbul> If I had to catch several errors using that method I would introduce a new nested do block for each one
10:35:54 <roconnor> f =<< lines text where f [] = fail "whatever" f (inputText:sectionText) = ...
10:37:12 <ski> burbul : that's certainly an argumen in favor of your variant .. possibly one could abstract that "catch several errors" pattern in a better way, when/if it happens, though
10:37:35 <burbul> ok
10:37:53 <burbul> thanks again!
10:38:15 <ski> roconnor's version is also ok, if you can invent a nice name for `f', or keep a "nothing-saying" one like `f' or `match' or something
10:38:59 <ski> roconnor : though shouldn't it be `f (lines text)' ?
10:39:58 <roconnor> maybe
10:42:13 <xephyr> kmc: I heard haskell sucks. Please prove me wrong.
10:42:20 <kmc> ;P
10:43:09 <c_wraith> I heard you can write software in haskell.  What does this mean?
10:44:08 <ski> @type \f text -> f =<< lines text
10:44:09 <lambdabot> forall b. (String -> [b]) -> String -> [b]
10:44:10 <ski> @type \f text -> f (lines text)
10:44:11 <lambdabot> forall t. ([String] -> t) -> String -> t
10:45:35 <albertid> why does the second parameter from modifyMVar_ be of type (a -> IO a)? how do I use a pure function a -> a there?
10:46:34 <ski> @type \f -> return Prelude.. f
10:46:35 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> b) -> a -> m b
10:46:39 <parcs> albertid: IO a allows more 'freedom'
10:46:52 <ski> albertid : pass `return . f' instead of your `f :: a -> a'
10:47:39 <ski> @type Control.Concurrent.MVar.modifyMVar_
10:47:39 <lambdabot> forall a. GHC.MVar.MVar a -> (a -> IO a) -> IO ()
10:47:44 <ski> @type Control.Concurrent.MVar.modifyMVar
10:47:45 <lambdabot> forall a b. GHC.MVar.MVar a -> (a -> IO (a, b)) -> IO b
10:48:34 <ski> @type \mvar -> Control.Concurrent.MVar.modifyMVar mvar . runStateT
10:48:35 <lambdabot> forall b. GHC.MVar.MVar b -> StateT b IO b -> IO b
10:49:14 <ski> @type ReaderT . flip Control.Concurrent.MVar.modifyMVar . runStateT
10:49:15 <lambdabot> forall a. StateT a IO a -> ReaderT (GHC.MVar.MVar a) IO a
10:49:18 <albertid> hmmm
10:49:26 <ski> albertid : ok ?
10:49:32 <albertid> yea, thanks
10:50:02 <albertid> I was wondering if hoogle did not return anything useful for (a -> b) -> a -> IO b
10:50:09 <albertid> s/if/why/
10:50:43 <ptd> albertid:because there is anything defined with that type
10:50:46 <ski> i suppose it's not directly a library function or a simple specialization of one
10:51:11 <sipa> @pl \f -> (\x -> return (f x))
10:51:12 <lambdabot> (return .)
10:51:23 <sipa> :t (return .)
10:51:25 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f a -> f (m a)
10:51:33 <ski> @type \f -> return Prelude.. f
10:51:34 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> b) -> a -> m b
10:51:58 <ptd> @type Control.Concurrent.MVar.modifyMVar
10:51:59 <lambdabot> forall a b. GHC.MVar.MVar a -> (a -> IO (a, b)) -> IO b
10:52:11 <albertid> well, works perfectly
10:52:20 <ptd> @type flip Control.Concurrent.MVar.modifyMVar . return
10:52:21 <lambdabot> forall a b. IO (a, b) -> GHC.MVar.MVar a -> IO b
10:52:43 <ptd> @type (flip Control.Concurrent.MVar.modifyMVar) . return
10:52:45 <lambdabot> forall a b. IO (a, b) -> GHC.MVar.MVar a -> IO b
10:54:10 <ski> @type flip ((flip Control.Concurrent.MVar.modifyMVar) . (return .))
10:54:11 <lambdabot> forall a b. GHC.MVar.MVar a -> (a -> (a, b)) -> IO b
10:55:57 <albertid> @type flip ((flip Control.Concurrent.MVar.modifyMVar_) . (return .))
10:55:58 <lambdabot> forall a. GHC.MVar.MVar a -> (a -> a) -> IO ()
10:56:43 <ptd> @pf (\x -> [x])
10:56:44 <lambdabot> Maybe you meant: bf pl
10:57:03 <ski> @type (res . arg . res) return Control.Concurrent.MVar.modifyMVar
10:57:04 <ski> @type (res . arg . res) return Control.Concurrent.MVar.modifyMVar_
10:57:04 <lambdabot> forall a b. GHC.MVar.MVar a -> (a -> (a, b)) -> IO b
10:57:05 <lambdabot> forall a. GHC.MVar.MVar a -> (a -> a) -> IO ()
10:57:17 <ptd> @pf (\x -> [x])
10:57:18 <lambdabot> Maybe you meant: bf pl
10:57:23 <ptd> bf pl
10:57:23 <byorgey> ptd: try @pl
10:57:30 <ptd> @pl :t (\x -> [x])
10:57:31 <lambdabot> (line 1, column 1):
10:57:31 <lambdabot> unexpected ":"
10:57:31 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
10:57:36 <ptd> @pl (\x -> [x])
10:57:37 <lambdabot> return
10:57:55 <byorgey> ptd: you can also use the robot monkey operator, (:[])
10:57:58 <ptd> lambdabot: lol
10:58:25 <byorgey> robot monkeys like eating things which then end up in their robot stomach
10:58:29 <byorgey> > (:[]) 3
10:58:30 <lambdabot>   [3]
10:58:31 <ptd> byorgey: good idea, return is a tad cryptic
10:58:41 <ski> @type ("foo" ++ ':' :)
10:58:42 <lambdabot>     The operator `:' [infixr 5] of a section
10:58:42 <lambdabot>         must have lower precedence than that of the operand,
10:58:42 <lambdabot>           namely `++' [infixr 5]
10:58:48 <ski> @type ("foo" ++ ":" ++)
10:58:48 <lambdabot>     The operator `++' [infixr 5] of a section
10:58:49 <lambdabot>         must have lower precedence than that of the operand,
10:58:49 <lambdabot>           namely `++' [infixr 5]
10:58:56 * ski is unhappy about that
10:59:14 <ptd> @type (("foo" ++ ":") ++)
10:59:15 <lambdabot> [Char] -> [Char]
10:59:23 <dmwit> :t ("foo" ++) . (':' :)
10:59:24 <lambdabot> [Char] -> [Char]
10:59:25 <ski> yeah, that's the workaround
10:59:28 <byorgey> @type (++ "foo" ++ ":")
10:59:29 <lambdabot> [Char] -> [Char]
10:59:33 <ptd> > (("foo" ++ ":") ++) "hi"
10:59:35 <lambdabot>   "foo:hi"
10:59:49 <dmwit> byorgey: ...wut
10:59:52 <byorgey> that kind of makes sense to me actually, since ++ is right-nested
11:00:05 <ptd> > ("foo" ++ ":" $ ++) "hi"
11:00:06 <lambdabot>   <no location info>: parse error on input `++'
11:00:11 <ski> yeah, but `(++)' is supposed to be associative ..
11:00:18 <byorgey> sure, but ghc doesn't
11:00:19 <ski> (as is `(.)')
11:00:46 <ptd> :t (\a b c -> a.b.c)
11:00:47 <byorgey> (I'd be all for special support for associative operators though)
11:00:48 <lambdabot> forall a b a1 (f :: * -> *). (Functor f) => (a -> b) -> (a1 -> a) -> f a1 -> f b
11:00:54 <ptd> :t (\a b c -> (a.b).c)
11:00:55 <lambdabot> forall a b a1 (f :: * -> *). (Functor f) => (a -> b) -> (a1 -> a) -> f a1 -> f b
11:01:02 <ptd> :t (\a b c -> a.(b.c))
11:01:03 <lambdabot> forall a b a1 (f :: * -> *). (Functor f) => (a -> b) -> (a1 -> a) -> f a1 -> f b
11:01:12 <ski> @type \a b -> (a . b .)
11:01:13 <lambdabot>     The operator `.' [infixr 9] of a section
11:01:14 <lambdabot>         must have lower precedence than that of the operand,
11:01:14 <lambdabot>           namely `.' [infixr 9]
11:01:42 <dmwit> :t (3 + 5 *)
11:01:43 <ptd> at least the error messages are readable
11:01:43 <lambdabot>     The operator `*' [infixl 7] of a section
11:01:43 <lambdabot>         must have lower precedence than that of the operand,
11:01:43 <lambdabot>           namely `+' [infixl 6]
11:01:48 <dmwit> :t (3 * 5 +)
11:01:50 <lambdabot> forall t. (Num t) => t -> t
11:01:56 <dmwit> Okay, maybe I understand.
11:02:11 <ptd> (3 * 5 +) 1
11:02:17 <ptd> > (3 * 5 +) 1
11:02:18 <lambdabot>   16
11:02:23 <ptd> > (3 * (5 +)) 1
11:02:25 <lambdabot>   18
11:02:25 <byorgey> yeah, but you might wish that, say, (3 + 5 *) desugared to  \x -> 3 + (5 * x)
11:02:30 <dmwit> yeah
11:02:41 <dmwit> Seems a bit artificial that it doesn't, in fact.
11:03:00 <byorgey> I guess it would just make parsing more difficult.
11:03:09 <ptd> (3 * 5 +) is cryptically unreadable either way
11:03:13 <dmwit> Really?
11:03:15 <byorgey> with the current system, sections can be parsed as (expr op)
11:03:23 <byorgey> or (op expr)
11:03:35 <dmwit> oh
11:03:41 <byorgey> but if you want to be able to parse (3 + 5 *) you can't parse (3 + 5) as an expression
11:03:44 <ptd> > (3*).(5+) 1
11:03:45 <lambdabot>   No instance for (GHC.Num.Num (f t))
11:03:45 <lambdabot>    arising from a use of `e_1351' at <i...
11:03:48 <ptd> > (3*).(5+) $ 1
11:03:50 <lambdabot>   18
11:03:58 <dmwit> I thought every parser basically parsed expressions as sequences of expr's/op's and resolved fixity and precedence after-the-fact. =P
11:04:12 <byorgey> well... maybe you're right, I don't know
11:04:19 <ptd> > (3*5).(+) $ 1
11:04:21 <lambdabot>   15
11:04:23 <dmwit> But yeah, it shouldn't be required to do that.
11:04:28 <dmwit> So I understand a bit more now.
11:05:51 <ptd> I'm actually not quite sure about the cryptically unreadable comment now
11:05:57 <ski> byorgey : yeah, i'd like that `(3 + 5 *)' ..
11:09:41 * hackagebot boomerang 1.0.1 - Library for invertible parsing and printing  http://hackage.haskell.org/package/boomerang-1.0.1 (JeremyShaw)
11:10:55 <acowley> I'm having a brain short: if I have some singleton types from a GADT, can I reify them as values without a typeclass?
11:11:26 <acowley> I've got too many class constraints, and the family defined by the GADT is closed, so ... it's frustrating
11:11:50 <byorgey> acowley: not sure I understand the question.  have some code you can paste?
11:12:42 <hpaste> acowley pasted “singletons” at http://hpaste.org/49323
11:13:22 <acowley> Something like numChannels is doing type case
11:13:36 <acowley> but isn't useful when all I've got are phantom types
11:14:02 <joe6> boomerang is pretty cool.
11:14:25 <acowley> fooChannels is what I would want to work if I could have an instance for Channels c without an explicit class constraint
11:15:46 <acowley> I think what I want just isn't possible, but I still want it.
11:15:47 <byorgey> acowley: well, type classes are open, so there's no way to write fooChannels without a HasChannels constraint
11:15:53 <acowley> right
11:16:01 <acowley> but Channels c is closed
11:16:08 <acowley> and I'm not benefitting from that enough
11:16:25 <acowley> oops
11:16:30 <acowley> well it's closed at the value level I suppose
11:16:31 <develhevel> i have a problem running cabal, i always get: directory-1.1.0.0-98c0f0b4d8d214aab8d10d4fbbbab222 is shadowed by package directory-1.1.0.0-0e7c40c9b025e8ec8d1130f97b092890
11:16:32 <develhevel> . but dont know how to resolve it
11:17:06 <dcoutts> develhevel: remove the one in the user package db
11:17:12 <byorgey> acowley: I see.  but there's no declared connection from the type level to the value level
11:17:28 <acowley> byorgey: aren't you working on something that will let me close it at the type level by having a better kind than star on the parameter to the Channels type constructor?
11:17:39 <byorgey> acowley: yes!
11:17:46 <acowley> byorgey: can I have it? :)
11:18:09 <byorgey> acowley: I can send you a LaTeX document with some typing rules ;)
11:18:09 <acowley> without that, this little cul-de-sac is a big pain
11:18:15 <develhevel> dcoutts: and how? :(
11:18:25 <dcoutts> develhevel: using ghc-pkg unregister
11:18:32 <acowley> is it a literate haskell document?!?!
11:18:38 <byorgey> haha, no
11:18:57 <acowley> It's such a tease that you can get this far, but then smack into the need for typeclasses again
11:19:36 <acowley> byorgey: is there a timeline on your work appearing in GHC, or is it still long-term research?
11:20:34 <byorgey> there's no specific timeline at the moment.  But as of a few weeks ago there are multiple people hard at work on it.  So assuming everything goes well it may land in HEAD by the end of 2011 or so.
11:20:49 <byorgey> that's a complete wild guess
11:21:10 <ptd> @help
11:21:11 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:21:17 <ptd> @list
11:21:18 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:21:18 <joe6> what is the best command to compile a haskell file: "ghc -o" is the simplest one, I assume.
11:21:28 <djahandarie> byorgey, can I have this LaTeX document? :p
11:21:34 <acowley> byorgey: it will be a welcome addition, and I'm really looking forward to it!
11:22:16 <byorgey> djahandarie: all in good time.  It is still in quite a bit of flux.
11:22:30 <djahandarie> :(
11:22:40 <acowley> joe6: "ghc" is all you need to get started. "ghc -O" is a good idea to involve the optimizer.
11:23:01 <acowley> djahandarie: the paper will make you yearn for what you can't have
11:23:16 <byorgey> acowley: too late ;)
11:24:00 <joe6> acowley: thanks.
11:28:34 <thoughtpolice> acowley: oh, typekinds? i've been yearning for it since byorgey decided to blog about it, and then mysteriously have the work not be mentioned again ;)
11:30:06 <acowley> thoughtpolice: yeah, I had forgotten about it until just now when I was trying to figh off an invasion of class constraints on some type-level logic
11:30:10 <copumpkin> it's a conspiracy!
11:30:16 <copumpkin> they're trying to hold us back
11:30:23 <copumpkin> by gagging byorgey
11:30:28 <thoughtpolice> they always are.
11:30:32 <thoughtpolice> get the pitchforks!
11:31:04 <acowley> I'm using empty data decls, and thought it'd be better to use GADTs (which is annoying because GHC warns about unused data constructors) but still ran into the need for the classes because my type isn't as closed as I thought it was
11:31:07 <joe6> is "ghc -O3" the fastest / most optimized code?
11:31:09 <develhevel> i want to use profiling but when i want to make it with ghc i get: /usr/bin/ld: cannot find -lHShxt-regex-xmlschema-9.0.0_p. but i have already installex HXT with profiling option
11:31:17 <acowley> joe6: people usually stick to -O2
11:31:28 <thoughtpolice> joe6: -O2 - ghc doesn't actually support an -O3 setting, i think it's just interpreted as -O2 anyway
11:32:06 <acowley> joe6: other flags can be important, too. If you use the LLVM backend (-fllvm), there are various flags. There are also GC flags that can make a difference. And then there's -N
11:32:14 <kmc> cabal will complain if you use -O2
11:32:22 <kmc> they claim -O is usually as good and takes much less compilation time
11:32:33 <joe6> oh, ok. thanks.
11:32:48 <kmc> joe6, on GHC before 7, you really want ghc --make
11:32:56 <kmc> it is now the default
11:33:01 <kmc> see the manual to know what it does
11:33:14 <dcoutts> unlike gcc where people's default optimisation level is -O0, for ghc the default is -O
11:33:22 <dcoutts> erm, -O2 for gcc
11:33:37 * Cale grumbles about spurious GHC panics.
11:33:47 <kmc> gcc -O3 can break a lot of fairly reasonable compliant code
11:33:49 * acowley panics about Cale's grumbling
11:33:51 <thoughtpolice> yeah
11:33:51 <kmc> i don't think ghc has any mode like that
11:33:55 <acowley> panics due to what?
11:34:23 <thoughtpolice> -O2 is for basically the class of optimizations that "always make your program go faster" - as far as GCC standards go, -O3 can not only break your code, it could even make it slower
11:34:36 <Cale> ghc: panic! (the 'impossible' happened)
11:34:36 <Cale>   (GHC version 7.0.3 for i386-unknown-linux):
11:34:36 <Cale> 	lookupVers1 main:IPwn.Render.Texture TFCo:R:LiveTexture{tc}
11:34:42 <Cale> stuff like that
11:34:56 <thoughtpolice> and now in GCC 4.6 you have -Ofast, but that's really just -O3 + -ffast-math
11:34:59 <acowley> I guess the texture wasn't live
11:35:00 <ptd> kmc: That's because the definition of complaint is really subtle in the case of C
11:35:03 <Cale> They randomly go away if I clean and recompile things
11:35:26 <kmc> thoughtpolice, yeah.  if you're using C, making the code slower is a lot worse than making it completely incorrect or hilariously insecure
11:36:05 <ray> @tell edwardk thanks! i have no idea what you're tlaking about though
11:36:06 <lambdabot> Consider it noted.
11:36:19 <thoughtpolice> kmc: duh, man. i'd rather have my program mysteriously crash on a friday 3 years from now seemingly because i'm wearing a polo than have it go slow
11:36:40 <thoughtpolice> that's just like,
11:36:42 <thoughtpolice> unacceptable
11:37:41 <ptd> The only time you're likely to have optimisation breaking code in Haskell is rewrite rules that strictly stuff in subtle ways (thus making terminating programs enter infinite loops)
11:39:08 <monochrom> and also my http://article.gmane.org/gmane.comp.lang.haskell.cafe/88120/ :)
11:46:21 <ski> thoughtpolice : "typekinds" ?
11:47:01 <acowley> ski: * isn't very expressive
11:48:07 <acowley> ski: suppose you want to index your Vector type family by its length with a type-level Nat. Today, you have to write Vector n, where n :: * which admits types like Vector Char into the family
11:48:46 <acowley> ski: byorgey is doing work to reuse types at the kind level so you can restrict your types to come from specific kinds
11:50:31 <Eduard_Munteanu> kmc: there's also the complaint that compilation is slower on -O3
11:50:42 <Eduard_Munteanu> with minimal benefits in lots of cases
11:51:09 <Eduard_Munteanu> I don't think they meant -O3 to include unsafe optimizations at all
11:51:16 <kmc> oh, is that -Ofast?
11:51:19 <kmc> does that still exist?
11:51:22 <Eduard_Munteanu> Just -O2 + expensive stuff.
11:51:36 <kmc> is there a -O level that turns on fast-math and finite-math and all that?
11:51:40 <ptd> @pl (\x -> return.(,) x)
11:51:41 <lambdabot> (return .) . (,)
11:51:50 <Eduard_Munteanu> I don't think so, maybe -Ofast but that's a new flag
11:52:21 <kmc> after writing a bunch of x87 assembly by hand i have newfound sympathy for gcc's fpu codegen
11:53:00 <Eduard_Munteanu> Heh. It's also trivial to switch to SSE with -mfpmath :)
11:53:25 <Eduard_Munteanu> But anyway, GCC is a really reasonable compiler.
11:53:52 <Eduard_Munteanu> say, performance-wise
11:54:11 <kmc> yeah, i wanted to use SSE in my code
11:54:16 <kmc> but i don't think it's available in real mode
11:54:35 <Eduard_Munteanu> Oh. The IO challenge?
11:54:45 <kmc> yes
11:54:57 <parcs> @hoogle m Bool -> m a -> m a
11:54:57 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
11:54:57 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
11:54:57 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
11:55:09 <kmc> not to be confused with the #haskell IO challenge, which is to write a function of type IO String -> String
11:55:18 <Eduard_Munteanu> Heh
11:55:31 <mauke> trivial
11:55:38 <kmc> :t const "womp womp" :: IO String -> String
11:55:39 <lambdabot> IO String -> String
11:56:12 <mauke> :t \x -> const "" [x, getLine]
11:56:14 <lambdabot> IO String -> [Char]
11:56:43 <kmc> :t \x -> const "" (x `asTypeOf` getLine)
11:56:44 <lambdabot> IO String -> [Char]
11:57:02 <ptd> :t unsafeIOPerform
11:57:03 <lambdabot> Not in scope: `unsafeIOPerform'
11:57:08 <Eduard_Munteanu> kmc: did you try writing it in C?
11:57:13 <kmc> no
11:57:27 <ptd> :t unsafePerformIO
11:57:28 <lambdabot> Not in scope: `unsafePerformIO'
11:57:35 <Eduard_Munteanu> Ah, I wondered how that'd work out.
11:57:44 <ptd> :t unsafePerformIO
11:57:45 <lambdabot> Not in scope: `unsafePerformIO'
11:57:53 <ptd> I was sort of expecting that
11:58:08 <kmc> Eduard_Munteanu, I think not that well, I used almost exclusively register variables, broke the C calling convention in a bunch of ways, etc.
11:58:18 <quicksilver> :t System.IO.unsafePerformIO
11:58:20 <lambdabot> Not in scope: `System.IO.unsafePerformIO'
11:58:36 <kmc> lambdabot's @run needs to prohibit unsafePerformIO, obviously
11:58:44 <quicksilver> :t Foreign.unsafePerformIO
11:58:45 <lambdabot> forall a. IO a -> a
11:58:47 <kmc> and i guess @type should use the same environment
11:58:49 <kmc> ;O
11:58:50 <ptd> If you remove a few key functions (the unsafe* family), then your completely safe
11:58:52 <quicksilver> nothing unsafe about typechecking it :)
11:58:56 <Eduard_Munteanu> Presumably GCC should do that too with 'static' and cross-unit compilation / LTO
11:59:02 <kmc> i thought they used the same env though
11:59:03 <sheyll> hi
11:59:10 <kmc> Eduard_Munteanu, you try that and get back to me on how it works out for you
11:59:11 <ptd> :t fix
11:59:13 <lambdabot> forall a. (a -> a) -> a
11:59:13 <kmc> > Foreign.unsafePerformIO (return 3)
11:59:15 <byorgey> hi sheyll
11:59:15 <lambdabot>   Not in scope: `Foreign.unsafePerformIO'
11:59:39 <ptd> > fix id
11:59:44 <lambdabot>   mueval-core: Time limit exceeded
12:00:02 <ptd> They have the other way of breaking it covered as well
12:00:07 <codensity> > show . typeOf1 $ putChar
12:00:09 <lambdabot>   "-> Char"
12:00:27 <ptd> :t putChar
12:00:29 <lambdabot> Char -> IO ()
12:00:37 <codensity> oh i'm still codensity
12:00:48 <Eduard_Munteanu> codensity: yes, you've been for a couple of days :P
12:01:28 <applicative> a stale joke, but then so is my 'real' nick...
12:02:57 <thoughtpolice> kmc: -Ofast in GCC 4.6 is -O3 + -ffast-math
12:03:05 <thoughtpolice> (that's about all it does, IIRC)
12:04:53 <Eduard_Munteanu> Well, -ffast-math is "unsafe" in the sense it breaks standard compliance.
12:05:20 <ptd> The power of pure functions is demonstrated by the fact that there are pretty much only two conceivable ways to break lambdabot with @run
12:05:34 <ptd> > fix ([]:)
12:05:35 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
12:06:03 <Eduard_Munteanu> How does that break lambdabot ?
12:06:04 <thoughtpolice> Eduard_Munteanu: yes
12:06:08 <dainanaki> > putStrLn "I broke"
12:06:09 <lambdabot>   <IO ()>
12:06:13 <thoughtpolice> oh, the question is how to break lambdabot?
12:06:19 <Guest98925> What do you guys use haskell for?
12:06:26 <thoughtpolice> i wasn't aware of the context, i was just saying that -Ofast = -O3 + -ffast-math
12:06:31 <Eduard_Munteanu> Assasinating lambdabot :P
12:06:33 <erus`> programming
12:06:40 <Cale> At iPwn, we're using it for an RPG for iPhones and other mobile devices
12:06:44 <ptd> Eduard_Munteanu: If it was poorly implemented it might run out of memory
12:06:51 <Guest98925> better than python?
12:06:57 <erus`> ptd:  what compiler?
12:07:02 <Cale> Guest98925: I think it is
12:07:10 <Cale> (by a good margin actually)
12:07:11 <Eduard_Munteanu> thoughtpolice: that was the context too, though earlier :)
12:07:16 <ryant5000> Guest98925: Haskell and Python are so different it's difficult to even compare them
12:07:18 <dainanaki> I use Haskell for every programming task I can conceivably manage to.
12:07:23 <thoughtpolice> Eduard_Munteanu: ah
12:07:28 <Guest98925> oh
12:07:31 <erus`> Guest98925: i think python would be a little slow for games on an embedded device
12:07:40 <ryant5000> i like Haskell much better than python, but the two languages have very different goals
12:07:45 <ptd> erus`: Well spotted, my bad
12:08:10 <ptd> > (\x -> (x,x)) fix ([]:)
12:08:11 <lambdabot>   Couldn't match expected type `t1 -> t'
12:08:11 <lambdabot>         against inferred type `(t2, ...
12:08:18 <ptd> > (\x -> (x,x)) $ fix ([]:)
12:08:19 <lambdabot>   ([[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[...
12:08:20 <thoughtpolice> yes, they're extremely different from all practical aspects (also worth noting it's not impossible for python to be fast, just a bit of work)
12:08:27 <thoughtpolice> (see: pypy)
12:08:55 <erus`> pypy targets arm?
12:09:04 <thoughtpolice> there's a port in progress, actually.
12:09:11 <erus`> then i conceed
12:09:14 <thoughtpolice> (somewhat OT, go to #pypy if you want to learn more. :)
12:10:02 <erus`> Cale: whats your build setup like for iphone?
12:10:24 <dainanaki> I'm curious about that too!
12:10:47 <thoughtpolice> Cale: on that note, are you guys still using ryan/stephen's original 6.10 GHC iPhone port? (ryan is also here, maybe he would rather answer :)
12:10:56 <Cale> erus`: We have a special bunch of patches to GHC that gives it a cross-compiling backend
12:11:25 <Eduard_Munteanu> :t fmap . fmap . fmap . fmap . fmap            -- the only way to "abuse" it AFAIK
12:11:26 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) (f3 :: * -> *) a b (f4 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3, Functor f4) => (a -> b) -> f (f1 (f2 (f3 (f4 a)))) -> f (f1 (f2 (
12:11:27 <lambdabot> f3 (f4 b))))
12:11:37 <ryant5000> thoughtpolice: we're in the process of updating it
12:11:44 <Eduard_Munteanu> and this sort of stuff.
12:11:46 <thoughtpolice> i'm wondering because I remember at one point jinjing wang had actually updated the patches to something like GHC 6.13 - he had working iphone apps on the store even
12:11:50 <thoughtpolice> IIRC
12:11:54 <Cale> The new version will use the LLVM backend
12:11:57 <ryant5000> thoughtpolice: yes, he did
12:12:11 <erus`> guys were working on the llvm port allready
12:12:16 <thoughtpolice> ryant5000: awesome! lots of work has been done on making GHC more amenable to cross compilation too
12:12:20 <Eduard_Munteanu> Though you might be able to increase lambdabot's load otherwise too.
12:12:30 <thoughtpolice> erus`: yes, but there is no ARM native code generator in GHC. it'd have to use the LLVM backend
12:12:30 <ryant5000> erus`: yeah, that's true; we've been trying to help out with that a bit
12:12:43 <thoughtpolice> oh, i see what you mean. my bad
12:13:04 <Cale> thoughtpolice: Isn't there some native ARM support?
12:13:08 <erus`> thats cool :) i wanna target my android phone
12:13:18 <ryant5000> erus`: we want to target it, too :P
12:13:21 <thoughtpolice> Cale: there isn't a native code generator, but karas et al have been doing work in the RTS etc
12:13:25 <erus`> is there opengl es librarys anywhere?
12:13:33 <ryant5000> erus`: the normal OpenGL library works
12:13:35 <dainanaki> Hopefully ARM can become a level-1 platform someday
12:13:46 <ryant5000> although it throws a runtime exception when you use something that isn't in OpenGL ES
12:13:56 <erus`> o cool
12:14:03 <thoughtpolice> Cale: also, via-C isn't supported for registerized backends anymore, so the LLVM codegen is basically the only way to go other than writing a whole NCG for ARM
12:14:17 <joe6> which is better; "watch -n 1 <ghc built executable - size is 14M>" or, a forever loop in haskell that sleeps for a second between runs?
12:14:18 <thoughtpolice> as far as i see it, anyway
12:14:18 <Eduard_Munteanu> Presumably there will be little work to be done to port GHC to an arch once the LLVM backend becomes default, no?
12:14:30 <kmc> no Eduard_Munteanu
12:14:31 <erus`> i would probly abstract the openglstuff away in practise. opengl on haskell is a nightmare
12:14:33 <kmc> try it and find out
12:14:47 <kmc> speaking of which, ryant5000, did you ever get my GHC stuff to compile?
12:14:49 <thoughtpolice> Eduard_Munteanu: oh, no. there's plenty of stuff you have to do for a port
12:14:56 <thoughtpolice> beyond just the code generator
12:15:10 <Eduard_Munteanu> The code generator is a huge part, isn't it?
12:15:14 <kmc> all of the GHC backends still make assumptions about how structs are layed out in memory
12:15:16 <ryant5000> kmc: hm, i don't think so; i'll look at it again soon
12:15:21 <kmc> Eduard_Munteanu, try an unregisterised C port and get back to me
12:15:24 <thoughtpolice> yeah, but you also have to worry about things like the RTS
12:15:26 <kmc> it seems easy because you haven't tried to do it
12:15:27 <Eduard_Munteanu> :)
12:15:38 <kmc> everything seems easy if you don't know how to do it
12:15:39 <Eduard_Munteanu> kmc: it didn't seem easy, it was more like a question
12:15:54 <thoughtpolice> just the x86_64 OS X port has been a challenge in and of itself
12:16:05 <thoughtpolice> (granted that's somewhat of a special case since the userland transparently supports both archs all the time)
12:16:12 <Eduard_Munteanu> I assume the library needs porting too.
12:16:21 <thoughtpolice> but a lot of work has been done on GHC recently to make it more amenable to cross compilation
12:16:21 <Guest98925> did you guys learn Haskell in school or on your own?
12:16:26 <Eduard_Munteanu> erm primitives used by the library
12:16:41 <thoughtpolice> mark (mzero) contributed a bunch of patches that allowed him to build a stage1 GHC under google NaCL, for example
12:16:47 <Cale> Guest98925: on my own. I've been programming in Haskell for around 10 years.
12:16:52 <thoughtpolice> there are also plans to work on this at hac phi
12:17:04 <kmc> Guest98925, i took a small class at school, but it did not cover very much
12:17:07 <thoughtpolice> (if dankna and copumpkin are still interested; i think copumpkin may be doing agda)
12:17:10 <kmc> i've learned a ton on my own by reading and by hanging out here
12:17:13 <ptd> Guest98925: I learnt on my own (as with the rest of my programming experience)
12:17:20 <copumpkin> ?
12:17:23 <thoughtpolice> Guest98925: on my own, for about 5 years now. mostly learned a lot by hanging out here like kmc said
12:17:33 <kmc> Eduard_Munteanu, one problem with Android in particular is that the userland is not actually UNIX at all
12:18:01 <thoughtpolice> copumpkin: oh, i remember you mentioned you'd be doing agda work there. still interested in the CC work? :)
12:18:02 <kmc> the Android libc is basically the bare minimum subset of UNIX needed to get the Dalvik VM to run
12:18:12 <Eduard_Munteanu> Ah.
12:18:14 <copumpkin> thoughtpolice: I'll probably jump around a bit, but yeah
12:18:21 <kmc> you know how people are always on about "GNU/Linux"?  Android is actually a legit example of a system which is Linux-based but not GNU-based
12:18:36 <ptd> kmc: Is the solution to port haskell to the JVM?
12:18:37 <kmc> to the extent the UNIX userland exists, it's BSD based
12:18:47 <kmc> ptd, it's been tried various times
12:18:50 <kmc> none of the projects really took off
12:18:53 <Eduard_Munteanu> ptd: I'm not sure that's going to work well
12:18:59 <kmc> it will be slow and crappy
12:19:09 <kmc> JVM is a bad target for strict functional languages let alone lazy evaluation
12:19:20 <dainanaki> Is there any way to target the JVM through LLVM?
12:19:24 <Eduard_Munteanu> I hear even .NET/CLR is a better target
12:19:24 <ptd> We a specialised garbage collector and stuff, I guess
12:19:30 <erus`> 10 mins to download a linux distro :) i love my new internet
12:19:50 <kmc> dainanaki, I saw a project which compiles C and C++ for JVM by compiling to MIPS machine code and then  translating that
12:19:53 <thoughtpolice> dainanaki: you could go LLVM -> JVM bitcode, sure. nobody's done that work though :)
12:20:21 <kmc> anyway having something which claims to do "LLVM -> JVM" is not magically going to make all of what GHC can produce work on Android's not-even-JVM
12:20:29 <Eduard_Munteanu> kmc: anyway, I imagine getting the codegen ported is a huge task in itself
12:20:33 <thoughtpolice> yeah
12:20:34 <monochrom> I went to a monastary to learn haskell
12:20:46 <dainanaki> lol
12:20:47 <thoughtpolice> you actually have to process the generated bytecode and generate dalvik code for it.
12:20:53 <kmc> Eduard_Munteanu, yes, but I can tell you there are other huge tasks -- I never had to touch codegen, because I was using unreg'd via-C, and LLVM would be a similar situation
12:20:54 <thoughtpolice> who knows how well that'll go
12:20:55 <erus`> android can run native arm code...
12:20:55 <Eduard_Munteanu> Besides going through GCC doesn't let you write that much arch-independent code
12:21:31 <Eduard_Munteanu> kmc: doesn't LLVM offload some work related to arch-dependent conventions?
12:21:36 <Eduard_Munteanu> wrt via-C
12:21:39 <ptd> Eduard_Munteanu: It was designed to be flexible in the first place (with C#, F#, VisualBasic.NET, etc), whereas the JVM was just for Java
12:22:07 <kmc> and the Java world considers basic functional programming to be advanced wizardry
12:22:16 <kmc> not suitable for the "average programmers" they look down on
12:22:16 <erus`> ptd: it didnt have support for dynamic languages until recently
12:22:21 <thoughtpolice> Eduard_Munteanu: the bitcode has to be specifically generated with the intent of being architecture independent. endianness is an example of this - if the bitcode depends on word endianness or size for example, it's definitely going to break when you use 'llc' to generate code for some other architecture
12:22:47 <thoughtpolice> Eduard_Munteanu: the LLVM backend in GHC already has a couple of #ifdef's for example based on whether or not it's x86 or x86_64, etc
12:22:57 <Eduard_Munteanu> Ah.
12:22:59 <thoughtpolice> granted they are very very minimal
12:23:06 <thoughtpolice> so not *that* much of an impediment
12:23:18 <Eduard_Munteanu> So I guess you don't get a lot over via-C then.
12:23:27 <Enigmagic> ptd: wasn't really 'designed' for F#, look at syme's ILX... which is what the F# compiler actually targets (and is then translated to IL)
12:23:33 <thoughtpolice> Eduard_Munteanu: it's more practically a problem if you were to say, generate bitcode from a C program. include headers -> you get platform/arch specific headers -> parts of the bitcode may inevitably depend on this
12:23:38 <thoughtpolice> etc
12:24:06 * Eduard_Munteanu doesn't know much about LLVM's underlying machine model though
12:25:03 <ptd> Enigmagic: Oh, ok
12:25:56 <Enigmagic> ptd: it was designed to have tail calls and supported other languages, but functional language support is still pretty weak. f# has to do a lot of tricks to make it reasonably performant.
12:27:32 <erus`> ghc had to add new instructions to llvm did they not?
12:27:33 <ptd> Would compiling an imperative language to Haskell give dismal performance as well?
12:27:41 <kmc> Haskell is an imperative language
12:27:44 <Enigmagic> erus`: new calling convention
12:27:47 <Eduard_Munteanu> I wonder if language VMs have to be so CISCy
12:27:59 <Eduard_Munteanu> as in define language-specific primitives
12:28:12 <ptd> kmc: I thought haskell was a functional one
12:28:13 <thoughtpolice> erus`: no, they had to define their own calling convention however
12:28:15 <kmc> ptd, it is
12:28:15 <Enigmagic> erus`: wasn't required though, just was needed to approximate gcc's global registers
12:28:22 <kmc> ptd, "imperative" is not the opposite of "functional"
12:28:35 <kmc> in Haskell, functions are first-class, and so are IO actions
12:28:38 <thoughtpolice> which only affects how register allocation happens at call sites/function call entry points
12:28:41 <kmc> hence functional and imperative
12:29:11 <Eduard_Munteanu> Maybe a CPU-like instruction set that's easier to JIT might make sense.
12:29:33 <thoughtpolice> this is largely so that 1) libraries compiled with the LLVM backend will still work if you later link with libraries NOT compiled with it and 2) so the RTS can obviously make calls to/from generated code and vice versa
12:29:56 <kmc> ptd, note that every good language supports first-class functions and first-class IO actions
12:30:08 <kmc> it's very silly to carve up the programming world into warring "functional" and "imperative" camps
12:30:18 <kmc> it's mostly something people do so they'll have an excuse not to learn one or the other
12:30:24 <kmc> "oh, I can't use haskell, it's a functional language"
12:30:24 <Dashkal> burn the heathens?
12:30:41 <thoughtpolice> DID SOMEONE SAY PITCHFORKS?
12:31:10 <thoughtpolice> Eduard_Munteanu: you can JIT LLVM code. :) it's not very well supported though. unlike most of the LLVM infrastructure, the JIT doesn't really have any high-profile users interested in making it substantially better...
12:31:16 <kmc> "i can't use Haskell because my problem has state"  like xmonad or a webapp server don't?
12:31:21 <thoughtpolice> (as opposed to basically every other part of the toolset)
12:31:30 <ptd> kmc: All code in haskell is functional and pure
12:31:31 <kmc> thoughtpolice, that is strange
12:31:39 <thoughtpolice> at the moment they're actually writing a new JIT backend and have a new register allocator in the works for this stuff
12:31:51 <kmc> ptd, no, "functional" is a style
12:31:53 <Eduard_Munteanu> thoughtpolice: the question is if it fundamentally supports languages like Java or Haskell in an efficient manner
12:31:55 <thoughtpolice> of course it's not complete, and isn't going very fast, but at the same time nobody works on the old one either
12:31:59 <thoughtpolice> etc
12:32:10 <kmc> ptd, if you compute a the fibonacci sequence in Haskell by destructive updates to an IORef then I will not call your code "functional"
12:32:12 <thoughtpolice> kmc: those are the words from people in #llvm, not really mine
12:32:32 <kmc> good JIT is super useful even for "static languages" and bare machine code
12:32:38 <Enigmagic> thoughtpolice: it's reasonably well supported but the MCJIT work was taking a very long time since nobody was working on it
12:32:47 <thoughtpolice> Eduard_Munteanu: depends on how 'efficiently' you want it. haskell seems to do pretty well. there's also VMKit which is basically a JVM that uses LLVM for compiling
12:33:00 * Eduard_Munteanu remembers edwardk has a x86-64 -> x86-64 JIT or something like that
12:33:02 <thoughtpolice> Enigmagic: yeah, MCJIT is supposed to be the new hotness
12:33:27 <ptd> kmc: So is C a functional language?
12:33:28 <thoughtpolice> but yeah, unlike say clang or even some of the backends, they don't have many people interested in significantly improving its capabilities
12:33:43 <Eduard_Munteanu> ptd: you can't really do functional stuff in C
12:33:48 <Eduard_Munteanu> Like closures.
12:33:57 <thoughtpolice> Eduard_Munteanu: of course, I think I agree with mike pall in a sense that if you really want your implementation to be efficient, you have to abandon all those UNCOL-like principles
12:34:00 <Dashkal> ptd You can write code in C and in functional style, but it's painful.  Sin.. yeah, closures aren't easy to model
12:34:17 <Enigmagic> thoughtpolice: i'd say more than nobody was interested in making the JIT faster, it wasn't obviously lacking in capabilities compared to the other emitters
12:34:21 <Eduard_Munteanu> thoughtpolice: UNCOL?
12:34:36 <Enigmagic> *that
12:34:42 <Dashkal> You can do it in asm if you really want to, but ny the time you have enough of the framework in place to make it work, you've written GHC
12:34:49 <ptd> Equally you can write imperative code in haskell, but that is also painful
12:34:59 <thoughtpolice> ptd: no it's not
12:35:21 <thoughtpolice> Eduard_Munteanu: tl;dr 'UNCOL' stood for 'universal compiler language' and people back in the day hoped it could be an IR all compilers could emit to, and then just get fast execution 'for free'
12:35:33 <sbahra> Hi thoughtpolice
12:35:43 <Eduard_Munteanu> thoughtpolice: yeah, that's what I'm hoping for :)
12:35:43 <Dashkal> Note that while I say that you _can_ write code in C in functional style, this doesn't make C functional.  You have to fight the language.
12:35:52 <kmc> what Dashkal said
12:36:01 <ptd> It's definitely not as painful as write C functionally
12:36:01 <sbahra> thoughtpolice, have you had the chance to start that ARM port yet?
12:36:08 <kmc> ptd, just give up on this "paradigms" concept and learn each language for what it is
12:36:15 <thoughtpolice> naturally, this did not happen. some speculated at the time it was because there wasn't good enough tech, but some would argue (like mike) that the approach is just too inherently complex to make it work reasonably
12:36:24 <sbahra> thoughtpolice, I have a long queue of improvements (and some minor fixes) rolling in relatively soon.
12:36:29 <sbahra> Anyways, off-topic. Sorry :-P
12:36:40 <thoughtpolice> Eduard_Munteanu: for example, all those projects that use LLVM for a language like python, or lua. LLVM is not a fit for these and they will never perform as well as something like pypy or luajit
12:36:40 <kmc> ptd, what the paradigms really mean is "languages like Java" and "scary other things i want to ignore"
12:36:44 <thoughtpolice> which avoid such impedence mismatches
12:37:01 <thoughtpolice> sbahra: i hope to start on it soon, but i'm relatively busy. i do have the iOS platform files in place for the most part though
12:37:07 <thoughtpolice> so i may push those to my branch tonight or tomorrow
12:37:09 <Eduard_Munteanu> thoughtpolice: or perhaps a layered VM architecture makes sense.
12:37:18 <sbahra> Ah, rather than ARM.
12:37:27 <thoughtpolice> sbahra: yes, although ARM is part of the thing too :)
12:37:40 <thoughtpolice> sbahra: truthfully i should probably put them in seperate branches, since you can just use gcc intrinsics with the platform files i have now
12:37:42 <Eduard_Munteanu> Say, a common IR + language layers which add necessary primitives / data structures.
12:37:45 <sbahra> Sounds good to me. I'm tracking your branch.
12:38:01 <sbahra> thoughtpolice, you know we have an IRC channel, right?
12:38:11 <thoughtpolice> sbahra: nope! let me guess, ##concurrencykit ?
12:38:17 <sbahra> One #.
12:38:22 <thoughtpolice> cool!
12:38:47 <sbahra> I look forward to seeing you there ;]
12:39:08 <thoughtpolice> Eduard_Munteanu: maybe. however there are always impedence mismatches and if you really want performance, it's going to suffer from them. mike talks a lot about this being basically a god at assembly and lua among other things
12:39:20 <sbahra> Alright, I need to get back to hacking. Buh-bye.
12:39:38 <thoughtpolice> static compilation frameworks for example are a *large* mismatch with dynamic languages. there are just way too many possible paths to take for the compiler to determine what's profitable, statically
12:39:49 <thoughtpolice> so you end up pessimizing every single path (remember, compilers have to register allocate across slow paths too)
12:40:33 <thoughtpolice> truthfully given that luajit gets damn near to C speeds, I have to believe the approach mike advocates has a lot of merit, especially when you look at prior attempts like this which wanted to bolt on something like LLVM to a dynamic language
12:41:03 <thoughtpolice> luajit is very very lua specific, the backend and frontend are designed with one another in mind, and this affects every design decision from IR layout to the JIT compiler to the memory optimizations possible, and the design of the very fast interpreter
12:41:07 <thoughtpolice> etc
12:41:20 <ptd> kmc: Agreed, paradigms are ways programming languages encourage you to code. Languages tend to have a particular set of paradigms and following a different set makes coding harder usually.
12:41:36 <ptd> the boundaries tend to be fluid
12:42:26 <kmc> right
12:42:34 <kmc> but Haskell actually supports the imperative style very well
12:42:34 <thoughtpolice> Eduard_Munteanu: mike himself said it better than me. abstractions (all of them) have costs, direct in the form you must possibly pay for a runtime penalty, and indirectly in that you must now work to optimize it away
12:42:48 <thoughtpolice> in this sense, bad abstractions, or the composition of things which do not go well together, are going to cost you a whole lot more
12:43:55 <thoughtpolice> maybe a multi-tiered VM design in the future will alleviate these problems, but in the mean time static platforms for example are not the way to go for say, a dynamic language. a tracing JIT seems to be a clear winner here, given enough love. it's also not yet clear just how applicable an approach like tracing is in general
12:43:56 <ptd> kmc: Haskell's type system means it supports everything except simple, fast compilers and readable error messages.
12:43:58 <Saizan> (whole program optimization at the assembly level?)
12:44:33 <kmc> ptd, how is that a property of the type system?
12:44:43 <dainanaki> I'm not sure most other languages support readable error messages either.
12:44:45 <thoughtpolice> granted part of this stems from the fact programming language implementations don't really have much of a market anymore outside of a niche. nobody is going to want to invest in a relatively unproven technique like tracing, so it's not surprising it hasn't seen more application
12:44:47 <kmc> the type system exists to *limit* what you can do.  if there was no type system Haskell would support even more "paradigms"
12:44:54 <dainanaki> I'd much rather read a Haskell error than a C++ template error.
12:45:45 <kmc> the type system tries to forbid the "randomly change things until my test cases happen to pass" paradigm and the "cast everything to void*" paradigm and such
12:46:00 <c_wraith> thoughtpolice: is tracing still unproven, after what it's been shown to be able to do with javascript and lua?
12:46:39 <kmc> ptd, also, I would say Haskell supports functional and imperative styles in a way it does not support object-oriented or logic styles
12:46:43 <thoughtpolice> i said 'relatively unproven' - how long have tracemonkey and luajit2 been around for example?
12:46:52 <kmc> you can implement the latter two pretty easily, but there's not much built in to help you
12:47:00 <thoughtpolice> maybe 3 years? how many notable tracing JIT compilers were there before that?
12:47:14 <thoughtpolice> tracemonkey in particular, despite being a tracing JIT, was not a good example of the tech initially either
12:47:34 <ptd> The type system prevents fast compilers because the inference takes time (compare "runhaskell" and "python" on similar programs)
12:47:38 <thoughtpolice> oh sure it was fast at numeric loops and always has been, but it's performance used to be hilariously bad in some cases because the tracing just would not happen. jaegermonkey takes a 3-tier approach
12:47:48 <thoughtpolice> so spidermonkey now actually includes an interpreter, tracing JIT, and a method-at-a-time JIT
12:48:02 <c_wraith> so many monkeys!
12:48:10 <thoughtpolice> (whether or not that's insane or practical i'll leave up to you)
12:49:13 <thoughtpolice> c_wraith: i think it's showing a lot of promise. they definitely seem to be the way to go for dynamic languages at the moment if you really want high performance. tracing as an idea goes back long before any of this (back to the 70s,) but again it never took off because there weren't many actual real implementations of the design
12:49:20 <kmc> i think readable error messages are not impossible -- at least, I think we can do a lot better than GHC currently does
12:49:22 <thoughtpolice> according to mike in the early 90s, there was a C based tracing compiler
12:49:27 <thoughtpolice> called the 'multiflow C compiler'
12:49:33 <kmc> the way inference works, there's a "chain of argument" on the expected and inferred types
12:49:40 <ptd> the type system prevents simple compiliers because of all  the complexity needed to implement Type Classes, Functional Dependecies, etc
12:49:47 <kmc> you could present these in some nice
12:50:03 <c_wraith> ptd: if you go with straight haskell98, most of that complexity vanishes.
12:50:16 <c_wraith> ptd: ghc is complicated because it does *so* much more than just haskell98
12:50:34 <danharaj> fortunately the extensions are fairly modular
12:51:52 <thoughtpolice> ptd: all of GCC's C extensions also make it massively hard to implement a C compiler that works 'in the wild' on real world code without crazy man-hours and effort. these kinds of things happen all the time and are not specific to GHC
12:52:19 <ptd> c_wraith: but pure haskell98 would be much harder to program in
12:52:44 <kmc> i think the only truly essential extension to H2010 is Rank2Types
12:53:08 <thoughtpolice> how many man-hours have gone into clang? and they *still* don't support anywhere near all GCC extensions, much less all of the ones you would actually find in the wild. and they don't plan on some of them either, because they're just too damn hard or ugly.
12:53:16 <kmc> -fheinous-gnu-extensions
12:53:22 <thoughtpolice> yep
12:53:42 <ptd> thoughtpolice: I know, that situation sucks HIDEOUSLY.
12:53:44 <c_wraith> kmc: and hasn't theory on rank2types advanced a LOT since haskell was first formulated?
12:53:56 <kmc> no idea
12:54:05 <kmc> you mean wrt inference?
12:54:10 <c_wraith> yes
12:54:45 <ptd> The original didn't have the IO Monad.
12:54:58 <kmc> the original what?
12:55:02 <c_wraith> haskell
12:55:02 <ptd> Haskell
12:55:07 <kmc> Haskell 98 has it, though
12:55:12 <kmc> (the fact that it's a monad is irrelevant)
12:55:14 <monochrom> how many man-years have gone into gcc? :)
12:55:23 <monochrom> even man-decades
12:55:30 <ptd> monochrom: you mean man-decades
12:55:32 <c_wraith> I wouldn't have liked using old-style IO.  That looked very error-prone.  I'm glad the current IO type was added.
12:55:36 <monochrom> yes!
12:56:43 <monochrom> but with the clang-llvm combination, perhaps people decide that some optimizations are better off done at the llvm stage
12:56:59 <Eduard_Munteanu> thoughtpolice: ah, I see.
12:57:12 <Eduard_Munteanu> Thanks, tho' I have to go out for a beer now :)
12:57:14 <Eduard_Munteanu> BBL.
12:57:38 <thoughtpolice> later!
12:59:28 <c_wraith> a co-worker asked me to review an FFI binding for him.  I looked at it for like 30 seconds and went "I found a memory leak".  Isn't c fun?
12:59:58 <c_wraith> Who knows how many I didn't find!
13:00:22 <Iceland_jack> c_wraith: always three times more than you found
13:00:38 <Iceland_jack> by finding n more memory leaks you actually create 3n
13:00:43 <c_wraith> haha
13:01:33 <Iceland_jack> C kōan: “The only Way to no bugs is when you stop looking.”
13:01:47 <olsner> and every leak you fix has a 1/3 to 1/1 chance at spawning another memory leak
13:02:00 <Iceland_jack> olsner: I *like* those odds!
13:02:19 <gwern> never tell a c programmer the odds
13:02:24 <c_wraith> actually, it's not that bad.  this is a short binding.  It only used malloc twice.  Both of those were replaced with alloca
13:02:27 <ptd> The problem with memory leaks is they only cause problems when they accrue for hours, days or even weeks
13:02:31 <joe6> is yesod the best haskell web server app there is?
13:02:44 <c_wraith> joe6: define "best"
13:02:55 <joe6> i want to build a website, and am not sure which is the most used web framework.
13:02:57 <c_wraith> joe6: happstack and snap are also good, depending on your needs
13:03:20 <gwern> Banzan overhead a conversation between a butcher & his customer.\u000a"Give me the best piece of meat", said the customer.\u000aThe butcher replied: "Everything in my shop is the best. You cannot find any piece of meat that is not the best!"\u000aAnd Banzan was enlightened.
13:03:21 <joe6> something, that is not kludgy?
13:03:42 <joe6> which is recommended? better?
13:03:48 <c_wraith> all of them are reasonable to use and performant now.  Pick whichever provides the interface you want
13:04:38 <c_wraith> joe6: my company's using snap, if you're looking for a recommendation.  But that's because we picked it based on what it does best-matching what we needed.
13:08:44 <joe6> c_wraith: ok, thanks.
13:09:41 <dainanaki> *disclaimer, I help a little with yesod development*
13:09:48 <dainanaki> I think Yesod is really fantastic
13:10:09 <dainanaki> it's the most rails-ish in the sense that it does a lot out of the box.
13:10:27 <dainanaki> Snap is a little more DIY
13:12:50 <stepcut> happstack has a good intro, http://happstack.com/docs/crashcourse/index.html
13:13:48 <joe6> stepcut: thanks. that was what I was looking for.
13:14:43 <joe6> happstack seems the easiest to get off the ground.
13:15:00 <joe6> just a few  lines and you have a webserver and an app server.
13:15:11 <stepcut> yep
13:17:53 <burbul> @type foldl . id
13:17:54 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
13:18:45 <ion> @type foldl . id . id . id . id . id . id
13:18:47 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
13:19:14 <burbul> Gah -- thanks!
13:19:22 <ptd> @type id . foldl
13:19:24 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
13:19:31 <burbul> @t foldl (.) id
13:19:32 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
13:19:37 <burbul> @type foldl (.) id
13:19:38 <lambdabot> forall a. [a -> a] -> a -> a
13:20:05 <joe6> stepcut, that material is pretty good and well written.
13:20:13 <stepcut> joe6: thanks!
13:20:14 <ash___> so… on OS X lion, when I make something by doing: ghc --make file.hs it gives me 10k lines of ld: warning: text reloc in <long_function_name> to <long_function_name>
13:20:44 <burbul> BTW, should I use foldl or foldl' or foldr to compose a sequence of functions?
13:20:55 <Cale> foldr
13:20:56 <burbul> (It's a short sequence here, but it would be nice to know in general)
13:21:00 <c_wraith> foldr, yes.
13:21:00 <burbul> thanks
13:21:00 <Cale> foldr (.) id
13:21:04 <Cale> is the most efficient
13:21:48 <ash___> think re-building ghc might solve the problem? or…?
13:22:16 <Cale> because the evaluation of f (...) proceeds by evaluating f, passing along the expression
13:22:32 <Cale> (not evaluating the parameter first)
13:23:14 <Cale> ash___: Rebuilding GHC might be difficult, since you need a working GHC to do it.
13:23:20 <ptd> As for foldr vs. foldr'
13:23:40 <c_wraith> foldr' is mostly useless in haskell
13:24:09 <ash___> Cale: well, the binaries work after doing ghc --make but I just get like 10k lines of warnings...
13:24:20 <Cale> ash___: Ah, then maybe
13:24:35 <ptd> > foldr' (.) [(+1), (+1)]
13:24:37 <lambdabot>   Not in scope: `foldr''
13:24:55 <c_wraith> it's not even defined anywhere standard, because it has so little utility :)
13:25:08 <ptd> oh, fine
13:26:28 <c_wraith> also, it'd be liable to overflow the stack on any long list, since it would have no way to proceed without evaluating the whole thing.
13:26:36 <c_wraith> much like foldl, actually
13:27:04 <c_wraith> except that there's no way to fix it by adding strictness.
13:27:17 <c_wraith> the problem is too much strictness, not a lack of it
13:33:15 <ash___> can you use a 32-bit version of ghc to make 64 bit version?
13:33:24 <ash___> or how does the bootstrapping work?
13:34:09 <c_wraith> bootstrapping ghc is kind of terrifying.  you might want to ask in #ghc
13:38:11 <burbul> Is there any way to get hold of a line number for the error message "packedforest: Prelude.(!!): index too large" ?
13:39:05 <burbul> Or even find out whether it's a !! I'm calling directly or one in a library function?
13:45:37 <edward__> I want to use Haskell in Python and I am using foreign export ccall to export values, works okay for Ints but I want to export Strings, that requires Pointers (because length of string is not defined in Haskell), but don't know how to go about... any ideas
13:45:41 <joe6> is happstack the fastest, according to the benchmarks. I came across a file with warp > yesod >..happstack. But, then it mentioned that happstack was going with warp pretty soon.
13:46:08 <danharaj> edward__: Use CString instead.
13:47:36 <edward__> I tried that , created newCString and that compiled (The hs-file), but I got an error when linking it to create a dll in Windows
13:49:06 <ByronJohnson> burbul: You can use ghci's debugging features; part of the GHC manual covers this.
13:49:40 <burbul> thanks... I narrowed  it down by hand now. (By copying !!)
13:49:47 <ByronJohnson> burbul: Alternatively, you can always use Debug.Trace to hunt down the problem.
13:50:09 <burbul> I have an assert in the code that's crashing...
13:50:12 <burbul> assert (k < length children) $ filter_node f' (children !! k)
13:50:25 <burbul> But the assert isn't being triggered -- is this because of laziness?
13:51:01 <ByronJohnson> burbul: assertions aren't triggered with otimizations enabled
13:51:25 <danharaj> use the flag -O0 to turn off optimizations
13:51:29 <burbul> ah
13:51:31 <burbul> Thanks
13:53:16 <edward__> danharaj: I tried that , created newCString and that compiled (The hs-file), but I got an error when linking it to create a dll in Windows
13:54:08 <danharaj> edward__: Strange... I'm not too familiar with exporting Haskell. you should ask on stackoverflow
13:54:35 <danharaj> also, what is the error you get?
13:55:54 <edward__> danharaj: The error is: adder.o:fake:(.text+0x11d): undefined reference to `__stginit_haskell98zm1zi1zi0zi1_CString_'     collect2: ld returned 1 exit status
13:56:04 <burbul> no, -O0 still isn't fixing it
13:57:35 <burbul> Nor is trace kicking in...
13:57:45 <burbul>      trace (show (k, length fparts)) assert (k < length fparts) (fparts !!! k)
13:58:45 <burbul> [The trace works fine for a number of calls where k < length fparts, then I get a crash without a trace]
13:58:45 <danharaj> edward__: There's a library you have to link with, but I forgot what it's called.
13:58:53 <danharaj> kmc: I think you know since I learned it when you mentioned it to another user.
14:01:18 <danharaj> edward__: Have you read this page? http://www.haskell.org/ghc/docs/6.4/html/users_guide/win32-dlls.html
14:01:45 <burbul> nm, assert is working now
14:03:06 <danharaj> burbul: Did you have to force a complete recompile?
14:03:10 <danharaj> (You probably had to)
14:04:45 <burbul> I'm working via Leksah, so I'm not sure ... it just spontaneously started working.
14:05:20 <edward__> danharaj: Thak you for the link, but that info is already deprecated. For example it is not required anymore to link -fglasgow-exts (it actually says that is deprecated when using it).
14:06:20 <danharaj> ah, unfortunate
14:06:37 <danharaj> anyway, stackoverflow is the best place to go to get up to date help, a lot of knowledgable people answer questions there.
14:09:29 <edward__> danharaj: I follwed the description of the newest version to the letter , and that only worked  when I export Ints instead of Strings. But thanks anyway, try my luck at stackoverflow
14:22:10 <ptd> Is the MonadSupply availible anywhere on hackage?
14:22:51 <thoughtpolice> don't think so, but there's also value-supply on hackage which fills a similar role
14:24:37 <ptd> I remain mystified as to how value-supply works
14:25:09 <thoughtpolice> it's mystical, yes. :P
14:28:01 <develhevel> have a problem with profiling, always i do "./Main +RTS -p" i get "Main: Most RTS options are disabled. Link with -rtsopts to enable them." and i dont find any output file.i compile with "ghc -prof -auto-all -rtsopts Main.hs"
14:29:23 <thoughtpolice> develhevel: make sure it properly relinked. do 'ghc -prof -auto-all -rtsopts -fforce-recomp Main.hs' - if you had compiled it in the past but not changed the source code, GHC may not have rebuilt it
14:29:36 <thoughtpolice> (and thus not relinked it either)
14:32:37 <develhevel> thoughtpolice: thx
14:40:17 <djahandarie> So, what is 'the' library for IRC stuff these days? When I looked into it awhile ago, fastirc seemed to be the best looking, but it'd be neat if there was something that tried to do more on the type-level.
14:42:23 <djahandarie> Maybe I'll write a layer on top of fastirc
14:48:35 <djahandarie> Ah, right, that was mm_freak who wrote that. ping!
14:54:11 <ptek> As a newbie to Haskell, I need a help with fmap: I have a list of values which is in Maybe - [Just "/tmp/a", Just "/tmp/b", Nothing] and I need to map over this with readFile which is in IO Monad. Can I do this at all and if yes, how?
14:54:57 <dolio> What type should the result have?
14:54:58 <ptek> ... so basically I'd like to write something like fmap readFile [Just "/tmp/a", Just "/tmp/b"]
14:55:40 <ptek> probably IO Maybe String
14:55:50 <benmachine> IO (Maybe String)
14:55:57 <dolio> > catMaybes [Just 1, Nothing, Just 2, Just 3, Nothing]
14:55:57 <benmachine> parentheses are important
14:55:57 <lambdabot>   [1,2,3]
14:56:08 <benmachine> but what would the string be?
14:57:50 <ptek> The point is that we need an fmap which would accept monadic function...
14:58:02 <ptek> so the String would be the contents of the file
14:58:49 <ptek> Maybe is just an example. We try to create our own functor...
15:00:47 <burbul> ptek: are you trying to get out a list of Strings, or a list of (Maybe String)s, or what?
15:01:14 <siracusa> djahandarie: "Maybe I'll write a layer on top of fastirc" -- heh, I had the very same idea just a few days ago
15:01:27 <SuperSonicSound> Hello World!
15:01:35 <djahandarie> Get anywhere? I've started and I've found it's already somewhat a pain that I'm not working in Agda instead :p
15:01:57 <ptek> burbul: we'd need a list of (Maybe String)s at the end
15:02:28 <ptek> maybe we are going in the wrong direction with fmap, we just don't know anything better...
15:02:32 <siracusa> djahandarie: No, I don't have enough time at the moment
15:02:40 <djahandarie> Okay.
15:03:07 <burbul> I'm really new to Haskell myself, but I think that
15:03:09 <burbul> mapM :: Monad m => (a -> m b) -> [a] -> m [b]
15:03:12 <burbul> Might be what you're looking for
15:03:14 <benmachine> ptek: so you want IO [Maybe String]? so basically turning each Just "filepath" into Just "contents" and leaving Nothings as they are?
15:03:30 <ptek> benmachine: right
15:03:31 <benmachine> mapM, yes
15:03:50 <siracusa> djahandarie: SimpleIRC as a higher level lib is nice but still has some flaws
15:04:01 <benmachine> but for mapM you need to construct a function Maybe String -> IO (Maybe String)
15:04:06 <burbul> If you first figure out a function that works on *one* Maybe String, you can then use MapM to make it work on a list of Maybe Strings
15:04:11 <burbul> snap
15:04:14 <djahandarie> Okay I'm convinced this is going to be a major pain to do in Haskell and it's only been a minute :p
15:04:28 <djahandarie> I already need ByteStrings on the type-level. Darn.
15:04:33 <benmachine> :t maybe Nothing (fmap Just . readFile)
15:04:34 <lambdabot>     Couldn't match expected type `Maybe a'
15:04:35 <lambdabot>            against inferred type `IO String'
15:04:35 <lambdabot>     In the second argument of `(.)', namely `readFile'
15:04:48 <benmachine> :t maybe (return Nothing) (fmap Just . readFile)
15:04:49 <lambdabot> Maybe FilePath -> IO (Maybe String)
15:05:51 <benmachine> (you can do it with explicit case expressions/do notation if it makes you feel better)
15:07:38 <rakete> hi, can I somehow force haskell to import something that is not explicitly exported by a module?
15:09:28 <rakete> I'd really like to use a constructor for a data structure in some xmonad module, the author only exported a few functions to create a very limited set of that structure
15:09:30 <ptek> ok. thanks a lot! we'll try that...
15:10:44 <copumpkin> oh snap, the snap bot is watching us
15:10:59 <copumpkin> lucky we can trick it into spamming #snapframework on our behalf
15:11:53 <djahandarie> copumpkin, do you happen to have a type-level list lying around anywhere?
15:12:03 <djahandarie> Maybe I should just use SHE.
15:12:15 <copumpkin> nope
15:14:04 <rakete> well I guess I just can't
15:14:35 <djahandarie> Actually, I just need a list of booleans, I can get away with maskish type-level arithmitic to do what I need
15:15:30 <JuanDaugherty> [[zz]] is the snap bot?
15:17:50 <ptek> benmachine: we found something even better, which does what we want - its traverse function from Data.Traversable
15:18:05 <benmachine> traverse is very similar to mapM
15:18:19 <benmachine> :t Data.Traversable.traverse
15:18:20 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
15:18:28 <benmachine> it essentially is a generalisation of mapM
15:18:52 <benmachine> of course, you need an appropriate Traversable instance
15:18:57 <benmachine> possibly for MaybeT IO
15:19:17 <benmachine> or possibly not, I'm not sure
15:20:35 <ptek> benmachine: yep, an instance is needed... we are trying to connect the pieces now
15:20:40 <[[zz]]> JuanDaugherty, not really
15:20:55 <benmachine> :t mapM (maybe (return Nothing) (fmap Just . readFile))
15:20:56 <lambdabot> [Maybe FilePath] -> IO [Maybe String]
15:21:03 <benmachine> just sayin'
15:21:18 <parcs> JuanDaugherty: it's etabot i think
15:21:36 <[[zz]]> LoL
15:22:06 <JuanDaugherty> ah
15:23:29 <djahandarie> Hm, undefined makes things pretty annoying. :)
15:33:08 <SuperSonicSound> So
15:33:18 <SuperSonicSound> This is like a math chat room too, I hear?
15:33:35 <dmwit> #math certainly is
15:33:46 <SuperSonicSound> ahh, kk thanks
15:34:19 <dmwit> You can ask here if you really want. If your question is off-topic you'll be ignored or directed elsewhere. =)
15:34:32 <SuperSonicSound> I just need a word.
15:34:38 <dmwit> "the"
15:34:42 <SuperSonicSound> Thanks
15:34:46 <SuperSonicSound> See ya round
15:34:49 <benmachine> @slap dmwit
15:34:50 * lambdabot loves dmwit, so no slapping
15:34:50 <SuperSonicSound> XD
15:34:55 <benmachine> :<
15:34:55 <dmwit> hehe
15:35:02 <benmachine> lambdabot never slaps who I want slapping
15:35:14 <cmccann> @slap benmachine
15:35:15 <lambdabot> Come on, let's all slap benmachine
15:35:24 <benmachine> :(
15:35:26 * benmachine cries
15:35:34 <cmccann> at least lambdabot is consistent I guess
15:35:56 <SuperSonicSound> I need the word that means "identical in size and shape, but without regard to direction."
15:36:29 <cmccann> congruent?
15:36:36 <SuperSonicSound> "Identical" describing two or more structures is kinda ambiguous in terms of direction.
15:37:59 <SuperSonicSound> I suppose that word fits the bill.
15:38:26 <SuperSonicSound> And there probably aren't too many others that do.
15:38:27 <SuperSonicSound> Thanks
15:38:31 <cmccann> :]
15:39:26 <SuperSonicSound> Is this sentence correct then?
15:39:26 <ptek> benmachine: thanks! You guys are great!
15:39:28 <SuperSonicSound> A, B, E, and F style apartments are all congruent, single-room estates.
15:39:40 <benmachine> ptek: :)
15:40:15 <benmachine> SuperSonicSound: in the context of apartments, I would already assume direction irrelevant
15:40:38 <cmccann> SuperSonicSound, I don't know if most people would ever use the term "congruent" in that context but it seems correct enough
15:41:15 <cmccann> and yeah, apartments already sort of imply irrelevant direction, probably irrelevant reflection, and invariant scale
15:41:57 <cmccann> large apartments are not generally just scaled-up versions of a small apartment in my experience
15:42:59 <JuanDaugherty> conformal, informally
15:43:26 <azaq23> "All apartments presented for sale have the property that d(x, y) = d(f(x), f(y)) for an arbitrary point transformation f. Buy now!"
15:44:08 <SuperSonicSound> lol
15:44:31 <SuperSonicSound> http://www.planetcalypsoforum.com/gallery/files/7/4/6/5/Apartments1_low01.jpg
15:44:39 <SuperSonicSound> There is a chart of the apartments.
15:44:51 <SuperSonicSound> "Identical," "congruent," or some other word?
15:45:49 <SuperSonicSound> A, B, E, and F style apartments are all _______, single-room estates.
15:48:14 <parcs> is (==) O(n) where n is the number of distinct values a data type has?
15:48:15 <copumpkin> @ask kmc oh god, you got assimilated into the borg :(
15:48:15 <lambdabot> Consider it noted.
15:49:03 <dolio> copumpkin: What?
15:49:14 <copumpkin> dolio: Oracle bought a ksplice
15:49:17 <copumpkin> :P
15:50:20 <parcs> the derived instance, anyway
15:50:33 <benmachine> SuperSonicSound: I wouldn't say identical because they're mirrored, I guess congruent is pedantically correct but not intuitive
15:50:40 <benmachine> perhaps "virtually identical"? :)
15:50:54 <SuperSonicSound> That's another option I suppose.
15:51:26 <SuperSonicSound> Would you consider that any more intuitive then?
15:51:39 <benmachine> it's more common language
15:51:46 <benmachine> it's less precise
15:51:52 <SuperSonicSound> yeah
15:51:57 <benmachine> but I don't know if you lose any information of value exactly
15:51:59 <SuperSonicSound> alright, we'll go with it
15:52:02 <benmachine> depending on what exactly you want to communicate
15:53:00 <pumpkin> gah
15:54:29 <parcs> why isn't there a MaybeT in the mtl?
15:55:20 <ben> So there is room for tutorials to tell you how to make one
15:55:31 <cmccann> ha
15:55:39 <dmwit> parcs: there is...?
15:55:45 <dmwit> Oh, maybe not in mtl, though.
15:56:05 <cmccann> in transformers, I think
15:56:20 <dmwit> Control.Monad.Trans.Maybe
15:56:21 <cmccann> which mtl now depends on
15:58:58 <dolio> copumpkin_: Ed just observed that he was trying to set wli up there.
15:59:10 <dolio> So he could have been back working for Oracle.
16:01:58 <copumpkin> dolio: aha, I see
16:02:10 <copumpkin> my power keeps dying cause of my miner and AC together, I guess
16:03:05 <dmwit> copumpkin: If you don't mind me asking, how much did you spend on your miner?
16:16:22 <gwern> @remember x11 -- this assumes bytes are 8 bits.  I hope X isn't more portable than that :(
16:16:22 <lambdabot> It is forever etched in my memory.
16:16:26 <gwern> @quote bytes
16:16:26 <lambdabot> elliott says: Only two things in the universe are certain: Death, and two of the libraries you've decided to use taking different types of ByteString.
16:16:31 <elliottcable> what
16:16:40 <gwern> @quote bytes
16:16:41 <lambdabot> ozone says: when will bytestring be O(1) for all operations?
16:16:47 <gwern> @quote more.portable
16:16:48 <lambdabot> x11 says: -- this assumes bytes are 8 bits.  I hope X isn't more portable than that :(
16:16:52 <gwern> good
16:16:53 <gwern> @flish
16:17:00 <elliottcable> elliottt: You are. My. FAVOURITE PERSON EVER for changing your nick.
16:17:10 <elliottcable> elliottt: you don’t want my money? I was serious in my offer.
16:17:28 <shachaf> elliottcable: What?
16:17:33 <shachaf> elliottcable: Wait, which one are you?
16:17:42 <elliottcable> Not your regular.
16:17:51 <elliottcable> Another dude who ocassionally talks in here, and lurks all the time.
16:18:09 <elliottcable> I just share quite a few channels with that-other-elliott; and everytime he talks or someone mentions him, I was getting hilighted.
16:18:15 <shachaf> elliottcable: I'm pretty sure we have a regular elliott who's distinct from elliottt.
16:18:22 <elliottcable> what, really?
16:18:22 <shachaf> preflex: seen elliott
16:18:24 <elliottcable> god *damnit*
16:18:24 <Lemmih> gwern: Do you use melatonin regularly?
16:18:31 <shachaf> preflex_: seen elliott
16:18:32 <preflex_>  elliott was last seen on #haskell 3 days, 18 hours, 2 minutes and 19 seconds ago, saying: Are there any active projects to write a Haskell/Java bridge using JNI? All the ones I can find are bitrotten.
16:18:33 <elliottcable> and I was so excited.
16:18:36 <gwern> Lemmih: most every night, sho nuff
16:19:01 <Lemmih> gwern: How long have you been doing so?
16:19:06 * glguy waves to elliottt 
16:19:09 <elliottcable> I got so fed up of having to leave channels that I literally offered him a shitton of money just to never use a nickname that was a subset of my own again.
16:19:12 <Lemmih> gwern: (I'm on my third night)
16:19:15 <gwern> Lemmih: hm... hard to say. 6 years?
16:19:20 <shachaf> /nick e
16:19:24 <glguy> elliottcable: fix your irc client?
16:19:30 <elliottcable> glguy: Been trying.
16:19:31 <gwern> Lemmih: at least 3. almost surely not >7
16:19:39 <elliottcable> glguy: irssi’s channel-masking on regex hilights seems to be broken.
16:19:55 <gwern> elliottcable: why didn't you offer a bounty with a shitton of money instead?
16:20:05 <gwern> elliottcable: then others would benefit from your suffering
16:20:09 <mauke> elliottcable: why don't you change your nick?
16:20:12 <elliottcable> gwern: true :3
16:20:30 <Lemmih> gwern: That's very interesting. I wish I could get it over-the-counter here in Denmark.
16:20:37 <gwern> Lemmih: you can't? that's so sad
16:20:58 <gwern> Lemmih: I was about to mention that I am experimenting with adderall and armodafinil, but if you can't even get something as utterly harmless and natural as melatonin...
16:21:51 <elliottcable> mauke: been using this for more than half a decade.
16:21:59 <Lemmih> gwern: I'm bought some from the UK at nearly a dollar per pill.
16:22:02 <elliottt> elliottcable: why would you want my nick?
16:22:11 <elliottcable> elliottt: I don’t. I apparently hilighted the wrong person, sorry.
16:22:12 <mauke> elliottt: not yours
16:22:15 * gwern feels physical pain at the idea of melatonin pills costing a dollar a pill
16:22:22 <elliottcable> elliottt: I thought you were elliott, having changed his nick. ^‿^
16:22:33 <elliottt> hah, no.  i've always been elliottt :)
16:22:34 <elliottcable> elliottt: forgive me for the superfluous hilights. ^‿^
16:22:39 <gwern> (it's like a throbbing twinge high up on my forehead and about half an inch into my skull)
16:22:45 <elliottt> just thought i might be missing something :)
16:22:52 <Lemmih> gwern: I would love to get my hands on some adderall but even SR doesn't have any available in europe.
16:22:54 <elliottcable> elliottt: though, since you’re here … is that your name? “Elliottt” with three T’s? Or is it a last name, i.e. “Elliott T.”
16:22:55 <mauke> elliottcable: what are your hilight settings?
16:23:03 <elliottt> yes, trevor elliott
16:23:11 <elliottcable> \b(e(lliott?)?c(able)?|elliott?)\b  -word -regexp -priority 100
16:23:28 <mauke> \b? in my irssi regex?
16:23:33 <elliottcable> hahaha
16:23:44 <gwern> Lemmih: fwiw, I'm a lot more impressed by armodafinil than adderall; I wonder how much either is prescribed in europe (that's the limiting factor, people selling off their prescription)
16:24:03 <elliottcable> unnecessary, I’m aware. I used to use my own über-light client, copied it from there.
16:24:49 <monochrom> elliottt means elliott transformer :)
16:24:49 <mauke> no, I'm surprised this works at all
16:25:32 <dmwit> But you explicitly ask it to highlight you on plain old "elliott"!
16:25:39 <gwern> mauke: like a woman preaching or a dog walking on two legs, eh
16:25:52 <elliottt> monochrom: that's elliottT, thank you very much :)
16:26:02 <elliottcable> dmwit: yep!
16:26:06 <Lemmih> gwern: I'll check it out. I quite enjoy your writing, btw.
16:26:09 <mauke> becb
16:26:11 <elliottcable> dmwit: That’s, y’know, my name. People call me that, generally.
16:26:16 <ion> /nick e1liott
16:26:18 <gwern> Lemmih: but not my haskell stuff eh
16:26:18 <elliottcable> dmwit: either “elliott” or “ec”
16:26:43 <monochrom> is there also an elliottwireless? :)
16:26:48 <elliottcable> dmwit: for some asinine reason, though, I didn’t squat “elliott” when I started using Freenode. Just elliottcable and ec. /=
16:27:11 <elliottcable> monochrom: lol, nah. “ec|iPad” or “battlecollie”
16:27:29 <monochrom> w00t, haskell weekly news!
16:27:34 <dmwit> So, what's the (foo?)? thing doing? Is one '?' not enough, or does perl really do something different there?
16:27:49 <ion> That matches "", "fo" and "foo"
16:27:51 <dmwit> Oh, does that match "", "fo", and "foo"?
16:27:52 * monochrom fears "battle e coli"!
16:27:53 <dmwit> I see.
16:27:54 <elliottcable> dmwit: that’s intentional. Matches `e`, `elliot`, and `elliott`
16:28:06 <mauke> dmwit: it's not perl
16:28:18 <dmwit> elliottcable: Ah, makes sense.
16:28:25 <mauke> and I have no idea why or how this \b works
16:28:35 <elliottcable> dmwit: I used to use el+iot+, but it started a running joke wherin everyone would call me ellllllliotttttt unnecessarily, since they knew it would hilight me. Dropped that years ago.
16:28:37 <mauke> irssi uses POSIX extended regexes for highlights
16:28:41 <aninhumer> \b is word boundry iirc
16:28:46 <dmwit> mauke: Oh, huh. I just assumed it was since I knew irssi was extended in perl and "\b" looked like a perl-ism to my untrained eyes.
16:28:48 <elliottcable> aninhumer: not in irssi, hence his confusion
16:28:49 <ion> Haha
16:29:00 <mauke> \b should match "b"
16:29:00 <elliottcable> mauke: now that you point it out I have honestly no idea. Maybe it’s special-cased? *shrug*
16:29:17 <elliottcable> somebody type belliottcableb
16:29:23 <elliottcable> just out of curiosity
16:29:25 <mauke> I already typed becb
16:29:27 <dmwit> belliottcableb
16:29:28 <monochrom> haskell weekly news is lacking seriously. the current issue covers july 10 - 16, and it is out like 4 days after july 16
16:29:30 <elliottcable> nope.
16:29:31 <elliottcable> werd.
16:29:37 <ion> The regexp implementation in my irssi uses the \<\> dialect, not the \b one. But perhaps there’s a compile-time option for the regexp library or something.
16:29:46 <gwern> monochrom: at least it's out within a week
16:29:59 <elliottcable> I’m pretty sure my irssi is about a million years old, anyway.
16:30:10 <mauke> latest version
16:30:13 <elliottcable> oddly enough, not
16:30:27 <elliottcable> yeah, I don’t remember updating it. Or anything else on this miniscule toy VPS, either, for that matter.
16:30:34 <ion> How secure
16:30:36 <elliottcable> quick, someone hack me with known vulenerabilities!
16:31:02 <cmccann> the trick is to run stuff so ancient nobody can remember what vulnerabilities it had
16:31:08 <cmccann> security through antiquity
16:31:11 <ion> hah
16:31:15 <elliottcable> cmccann: ahhahhah
16:31:38 <ion> “Security through weird architecture” is another great method.
16:31:39 <elliottcable> well, fuck. I was intending to go out and irradiate the back yard before it got dark.
16:31:47 <elliottcable> instead, I’ve fucked around on IRC all evening.
16:31:51 <ion> I should turn my 68k Amiga into a server.
16:32:07 <gwern> elliottcable: irradiate?
16:32:12 <monochrom> yikes, s/lacking/lagging/
16:32:16 <ion> Yes, with plutonium. Don’t you do that?
16:32:21 <elliottcable> gwern: don’t ask. >,<
16:32:26 <gwern> Lemmih: wasting time on IRC is one of the failure modes of adderall, I've found
16:32:33 <dmwit> elliottcable: irradiate?
16:32:34 <elliottcable> failure modes lol
16:32:39 <elliottcable> dmwit: 6 ſ 989 275 < elliottcable> gwern: don’t ask. >,<
16:32:40 <dmwit> elliottcable: (Since gwern isn't allowed to ask. =P)
16:32:46 <elliottcable> lol.
16:32:51 <ion> 6 ſ 989 275?
16:32:57 <elliottcable> … don’t ask about that, either.
16:33:00 <elliottcable> >,> <,<
16:33:01 * elliottcable leaves
16:33:30 <cmccann> gwern, congratulations, you've massively improved your ability to focus intently on your procrastination
16:33:48 <gwern> cmccann: with adderall, I can procrastinate at the speed of light!
16:34:25 <elliottcable> Did Dyle privmsg anybody else for help with hscan? >,<
16:34:28 <thoughtpolice> yes amphetamines will do that
16:35:04 <mauke> preflex_: seen Dyle
16:35:05 <preflex_>  Sorry, I haven't seen Dyle
16:35:09 <kmc> amphetamines are great if you want to really carefully and thoroughly implement what turns out to be the wrong design
16:35:21 <kmc> depth-first at the expense of breadth-first
16:35:29 <cmccann> amphetamines worked for Erdos, can't argue with that
16:36:08 <kmc> "of the advice given to freshmen I think 'you are not Erdős' goes pretty high on the list"
16:36:14 <elliottcable> kmc: ahhahhahha
16:36:25 <cmccann> that's probably good advice for anybody
16:36:33 <elliottcable> #fact.
16:36:34 <kmc> i mean, amphetamines will also help you carefully and thoroughly implement the right design
16:36:39 <elliottcable> This channel is actually pretty awesome.
16:36:51 <elliottcable> *California governer* I’ll be back.
16:36:55 <mauke> and now I can type ő
16:36:55 <gwern> cmccann: amphetamines also gave us ayn rand
16:36:58 <kmc> but you lose that ability to glance at the problem sideways and notice "wait, actually, this is totally wrong"
16:37:39 <cmccann> gwern, which just goes to show that there are worse things to do than waste time on IRC
16:38:48 * hackagebot OddWord 1.0.0 - Provides a wrapper for deriving word types with fewer bits.  http://hackage.haskell.org/package/OddWord-1.0.0 (RobinKay)
16:39:28 <gwern> cmccann: of advice given to freshmen, 'you are not Rand' goes pretty high on the list, I think
16:39:42 <Lemmih> gwern: I would love to pick your brain next time I'm in your vicinity. For now, though, I have to go to sleep as the melatonin is kicking in.
16:39:45 <gwern> (neither angel nor devil, that's most of us)
16:40:01 <gwern> Lemmih: the sandman beckons us all eventually
16:40:08 <gwern> (tempus edax rerum)
16:40:29 <cmccann> "you are not X" is pretty solid advice for all famous lunatics X, regardless of quality of their output
16:41:14 <kmc> you are not emperor norton
16:41:37 <gwern> kmc: you know, I almost visited his grave back in march, but I procrastinated too much and missed the metro
16:41:41 <cmccann> kmc, I'll make an exception for him, that guy was pretty cool
16:41:54 <gwern> even had a little bottle of wine to pour over his grave
16:42:04 <cmccann> nice
16:56:14 <monochrom> you are not a modem XD
17:29:10 <dmead> ?yow
17:29:11 <lambdabot> Couldn't find fortune file
17:29:14 <dmead> :/
17:30:31 <gwern> dmead: @quote is a much better fortune than @yow
17:30:33 <gwern> @quote
17:30:34 <lambdabot> Jafet says: Javascript is pretty much a DSL for making your web browser take up more CPU
17:30:40 <cmccann> ha
17:30:44 <dmead> @quote
17:30:45 <lambdabot> sethg says: I feel like I still don't understand comonads.  Maybe I just need a Zen comaster to hit me with a costick and then I'll become coenlightened.
17:30:45 <ben> heh
17:30:57 <dmead> thats not funny at all.
17:31:00 <dmead> @quote
17:31:01 <lambdabot> sm says: if this url is infinite, I'm screwed :(
17:31:02 <ben> I'm sorry.
17:31:15 <gwern> fine, take this!
17:31:17 <gwern> @quote gwern
17:31:18 <lambdabot> gwern says: [wrt dons dissertation/defense being due shortly] 'I am half-raptor, and know neither fear nor fatigue.'
17:31:31 <cmccann> @quote cmccann
17:31:32 <lambdabot> cmccann says: C++ is dual to Haskell in a sense: it's much too hard for the average programmer to use safely, but they do anyway with disastrous results; whereas Haskell isn't actually that difficult
17:31:32 <lambdabot> to use but people don't even try
17:31:40 * gwern shakes sword. ARE YOU NOT ENTERTAINED
17:31:50 <dobblego> if I :set prompt in ./.ghci and ~/.ghci the one in ~/.ghci always wins -- can I make it lose?
17:31:53 <Eduard_Munteanu> @quote Eduard_Munteanu
17:31:54 <lambdabot> Eduard_Munteanu says: [In response to "GHC can go jump out a window" and "GHC has already jumped out a window and flied and left you behind"] Yes, GHC even implements optimizations such as defenestrat
17:31:54 <lambdabot> ion.
17:33:00 <gwern> @quote lazier
17:33:01 <lambdabot> gwern says: the best way to optimize a program is to make it lazier or stricter.
17:33:23 <cmccann> wise words indeed
17:33:30 <Rotaerk> false!
17:33:55 <gwern> Rotaerk: but it's an inclusive or!
17:34:51 <kmc> @quote ChrisOkasaki
17:34:51 <lambdabot> ChrisOkasaki says: Historically, the most common technique for analyzing lazy programs has been to pretend that they are actually strict.
17:35:06 <cmccann> hahahaha
17:35:24 <Eduard_Munteanu> He came in here?
17:35:27 <kmc> no
17:35:31 <c_wraith> no, that's from his thesis
17:35:31 <Eduard_Munteanu> Ah :)
17:35:32 <kmc> lambdabot has many quotes from outside irc
17:35:37 <gwern> Eduard_Munteanu: the camelcase convention usually indicates non-IRC
17:35:38 <kmc> c_wraith, i saw it in the book but it's probably in both
17:35:59 <gwern> if he had been here, it'd look more like cockasaki
17:36:07 <gwern> *cokasaki
17:36:08 <cmccann> the book is the thesis
17:36:12 <cmccann> nice typo there
17:36:13 <Eduard_Munteanu> Heh.
17:36:26 <gwern> you know what, the correct version still looks dirty -_-
17:36:28 <ion> < lambdabot> ion.
17:36:30 <ion> lambdabot.
17:36:54 <Eduard_Munteanu> defenestrat-ion, I'd guess
17:36:59 <dobblego> edwardk: is t (f a b) -> f (t a) (t b) in category-extras? bitraverse?
17:37:26 <Eduard_Munteanu> @vixen You can't hyphenate properly!
17:37:27 <lambdabot> *giggles*
17:38:16 <cmccann> dobblego, up for a bit of minor language trolling? :D
17:38:30 <dobblego> cmccann: bit busy, but don't let that stop me
17:38:42 <cmccann> dobblego, ah, just an anecdote
17:38:47 <Eduard_Munteanu> dobblego: fmap?
17:38:52 <dobblego> cmccann: I'm unclear, what do you mean?
17:38:59 <dobblego> Eduard_Munteanu: fmap?
17:39:02 <Eduard_Munteanu> Ah, no.
17:39:02 <cmccann> I was at the bookstore the other day, glanced over the programming books
17:39:14 <dobblego> ah right
17:39:15 <cmccann> they had stuff on Scheme, Erlang, F#, and Haskell
17:39:18 <cmccann> but no scala
17:39:32 <gwern> sensible of them
17:39:33 <trygvis> cmccann: probably sold out :)
17:39:37 <Eduard_Munteanu> dobblego: I'm taking f as some (->) and t as a functor
17:39:51 <cmccann> trygvis, nah, was pretty clearly no space on the shelf for any
17:39:54 <gwern> @quote scala
17:39:54 <lambdabot> ym says: sigh. i could have just become another ruby snob in the time it's taking me to figure out Scala's type system
17:40:09 <Eduard_Munteanu> So I guess...    t (a -> b) -> t a -> t b
17:40:14 <hpaste> djahandarie pasted “Type-level lists” at http://hpaste.org/49327
17:40:34 <c_wraith> Eduard_Munteanu: that would be <*> or ap
17:40:36 <djahandarie> copumpkin, Eduard_Munteanu ^^
17:40:38 <dobblego> Eduard_Munteanu: t=[] and f=Either
17:40:49 <djahandarie> Let me know if you can think of a better way to do Delete
17:41:05 <Eduard_Munteanu> Ah, right, that'd be the one
17:41:12 <djahandarie> Especially a way that doesn't require me to tag Any with Here and There
17:41:31 <dobblego> Eduard_Munteanu: I think it is bitraverse, but haven't demonstrated to myself yet
17:41:36 <djahandarie> But I think that's the type-level information required which you would normally get with dependent-types
17:41:53 <dpratt71> a lot of people say learning Haskell is hard, but I've had a much harder time absorbing Scala
17:42:43 <djahandarie> Man, I know I'm thinking a little too fast when I start hyphenating random words
17:42:55 <Eduard_Munteanu> djahandarie: I'm not sure, which one are you implementing? The Agda or Haskell variant?
17:43:02 <djahandarie> My own variant.
17:43:03 * Eduard_Munteanu is confused
17:43:06 <shachaf> djahandarie: You're just giving away that you're really geheimdienst.
17:43:32 <djahandarie> Eduard_Munteanu, :t delete (There (undefined :: Cons Z (Cons (S Z) Nil)) (Here undefined (Refl :: S Z :=: S Z))) :: Cons Z Nil
17:43:56 <djahandarie> i.e., given a proof that a certain element satisfies a property, delete it.
17:44:04 <Eduard_Munteanu> Oh, fake dependent types in Haskell, by the looks of '::'
17:44:26 <dobblego> s/bitraverse/bisequence (like woteva same same)
17:44:34 <parcs> you know what would be cool? a language extension that turns an incomplete case expression of type `a` to a complete one of type `Maybe a`
17:45:01 <dobblego> incidentally, scala almost achieves that, but fucked it at the finish line instead
17:45:05 <djahandarie> And this Any variant of delete of course lets you pick any element rather than the first one
17:45:10 <edwardk> djahandarie: clearly those should be Proxy's ;)
17:45:10 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
17:45:23 <djahandarie> edwardk, Proxys?
17:45:28 <edwardk> Data.Proxy
17:45:35 <edwardk> to eliminate the undefineds =)
17:45:40 <djahandarie> Ah, from Tag
17:45:56 <djahandarie> Yeah, thanks, was wondering if this would exist already somewhere
17:46:53 <edwardk> in general i write the functions that take them ti just take proxy foo instead of Proxy foo, that way i can use them for pattern matching but not care what witness i get, that lets me usually use a Bar Foo as a Proxy Foo directly without making up a witness and passing it
17:47:46 <edwardk> djahandarie: for concrete reference: http://hackage.haskell.org/packages/archive/algebra/0.7.1/doc/html/Numeric-Coalgebra-Geometric.html under euclidean and antiEuclidean
17:48:35 <djahandarie> edwardk's idea of concrete is apparently abstract algebra ;)
17:48:35 <edwardk> the nice thing about defining functions that take proxies that way is that the package user doesn't even need to know the Data.Proxy package exists.
17:48:43 <edwardk> djahandarie: hahahahahaha
17:48:59 <edwardk> @remember djahandarie edwardk's idea of concrete is apparently abstract algebra
17:48:59 <lambdabot> Okay.
17:48:59 <Eduard_Munteanu> :)
17:49:33 <edwardk> most of these are coalgebras anyways =P
17:49:38 <kmc> coabstract?
17:49:40 <edwardk> they are much easier to implement
17:49:49 <edwardk> preflex: xseen ddarius
17:50:06 <shachaf> edwardk: Thailand, I hear.
17:50:15 <shachaf> preflex_: xseen ddarius
17:50:16 <preflex_>  ddarius was last seen on freenode/#haskell 7 days, 19 hours, 48 minutes and 50 seconds ago, saying: @free beer
17:50:27 <Eduard_Munteanu> Abstract and "backwards", does it get better?
17:50:48 <edwardk> kmc: i heard you guys were getting acquired by oracle. would have been really funny had wli wound up with you. =P
17:51:10 <kmc> yes indeed
17:51:21 <edwardk> Eduard_Munteanu: well, i'm sure i'll have to do a package for working with algebroids next ;)
17:51:36 <kmc> i've declined Oracle's job offer, by the way
17:51:49 <edwardk> so when do we interview you? =)
17:51:51 <kmc> haha
17:51:55 <kmc> copumpkin already asked ;)
17:51:59 <edwardk> damnit
17:52:10 <kmc> i have the luxury of not needing to get a new job immediately
17:52:15 <edwardk> fair nuff
17:52:17 <kmc> when i do i will keep you guys in mind for sure
17:52:22 <Eduard_Munteanu> Wow. What's that one? Like monoidoids but just any algebra?
17:52:35 <edwardk> well, standing offer and all that
17:52:39 <kmc> is there really a thing called a monoidoid?
17:52:43 <edwardk> kmc: yeah
17:52:45 <Eduard_Munteanu> kmc: sure there is
17:52:54 <Eduard_Munteanu> A category :P
17:53:10 <edwardk> Eduard_Munteanu: ringoids are rings with more than one object, basically they are categories where the hom-sets act like abelian groups.
17:53:23 <edwardk> Eduard_Munteanu: an algebroid is an algebra over a ringoid
17:53:23 <ornicar> I love reading this chan.
17:53:53 <djahandarie> For some reason I constantly forget how to do multi-line comments in Haskell
17:54:05 <Eduard_Munteanu> {-  ...   -}  ?
17:54:06 <kmc> > {- " -} " -}
17:54:07 <lambdabot>   <no location info>:
17:54:07 <lambdabot>      lexical error in string/character literal at end o...
17:54:09 <edwardk> {- silly djahandarie -}
17:54:10 <djahandarie> Ah, right.
17:54:34 <kmc> so there is valid Haskell code which can't be commented out using {- -}!
17:54:35 <djahandarie> I do PHP all day, I have the right to be brainwashed about my non-C-style comments
17:55:27 <dainanaki> ew, php
17:55:35 <Eduard_Munteanu> Presumably something starting and ending with #
17:56:04 <djahandarie> Actually I'm pretty sure this is the first time I've touched Haskell in months :p
17:56:09 <Eduard_Munteanu> Though '{- ' and ' -}' might be safe
17:56:29 <hpaste> djahandarie pasted “Type-safe IRC” at http://hpaste.org/49328
17:56:36 <Eduard_Munteanu> djahandarie: how is it to get down to Earth after a long time? :P
17:56:43 <djahandarie> So, that is what all that type-hacking was for
17:56:53 <djahandarie> And I have no idea if it 1) makes sense or 2) is useful
17:56:55 <djahandarie> But it's there!
17:57:28 <djahandarie> Eduard_Munteanu, well, I was doing Agda and Coq. I think that's just on the other moon though.
17:57:53 <Eduard_Munteanu> It kinda looks contrived in Haskell.
17:58:02 <djahandarie> That's because I haven't cleaned it up yet :p
17:58:09 <djahandarie> I'll make it nicer, I promise
17:58:29 <burbul> I want to write
17:58:30 <burbul>           case sequence potential_filters of
17:58:31 <burbul>               Left err -> error "Invalid filter."
17:58:49 <burbul> But that seems to be illegal, because there isn't a Right _ clause .
17:58:59 <kmc> it's not illegal
17:59:02 <kmc> GHC will give you a warning
17:59:11 <djahandarie> I could also reuse Z and S for Here and There, since its isomorphic, but not sure if I'm going to
17:59:15 <kmc> if a "Right" value reaches there, it will be a runtime error
17:59:23 <kmc> burbul, what do you want to do on Right?
17:59:28 <burbul> Nothing
17:59:35 <burbul> (I'm working in the IO monad)
17:59:35 <kmc> sorry, Haskell is not about "do"
17:59:36 <kmc> i meant
17:59:42 <kmc> what value do you want
17:59:48 <Eduard_Munteanu> Then use a fallback case    _ -> error "boom!"
17:59:49 <kmc> ok, you want a do-nothing IO action?
17:59:53 <burbul> yup
17:59:55 <kmc> Right _ -> return ()
18:00:01 <burbul> oh, of course!
18:00:07 <burbul> d'oh. thanks!
18:00:19 <kmc> burbul, see also Control.Monad.when
18:00:21 <burbul> I tried mzero, but that was of course wrong
18:00:33 <kmc> @src when
18:00:34 <lambdabot> when p s = if p then s else return ()
18:00:38 <burbul> does when let you pattern match ?
18:00:43 <kmc> not directly
18:00:49 <kmc> :t either (const True) (const False)
18:00:51 <lambdabot> forall a b. Either a b -> Bool
18:00:51 <Eduard_Munteanu> Oh, right, you wouldn't want to error out in both cases I suppose :)
18:00:52 <kmc> kinda ugly though
18:03:04 <djahandarie> The interesting part here is going to figure out how to make my IRC evaluator interact in real time with the real world
18:03:34 <gwern> djahandarie: that probably involves IO> I dunno why you;d dirty your hands
18:04:38 <djahandarie> For science!
18:05:07 <c_wraith> what if it blinds you?
18:05:39 <djahandarie> That's a risk I'm willing to take
18:06:19 <Eduard_Munteanu> You'd have to write some tedious bindings I suppose.
18:06:46 <Eduard_Munteanu> Or maybe not, if you pipe stuff into and out of it.
18:07:00 <djahandarie> I don't think the end product will be bad... I think the process will be
18:07:26 * Eduard_Munteanu shakes head
18:07:35 <Eduard_Munteanu> I forgot this wasn't about Agda code.
18:07:43 <parcs> why isn't Map Traversable?
18:08:37 <edwardk> it is
18:09:34 <edwardk> keep in mind Map is in containers, and Traversable is in base, so you don't see it in the traversable docs, but go to Data.Map and look at instances
18:10:05 <c_wraith> Seems somewhat less useful than one would hope, though.
18:10:14 <c_wraith> Map really wants some sort of keyed-traversable
18:10:24 <c_wraith> which I'm sure you have somewhere already, right?
18:10:26 <edwardk> c_wraith: Like Data.Key.TraversableWithKey ?
18:10:33 <edwardk> yes of course i do
18:10:34 <edwardk> =)
18:10:38 <edwardk> and it even has an instance for Map
18:10:57 <edwardk> the reason containers doesn't have such a class is it isn't haskell 98.
18:11:09 <c_wraith> oh, I suppose not.
18:11:10 <edwardk> because it needs an MPTC or type family to describe the key type
18:11:53 <parcs> well the code works but ghci doesnt show that Map is traversable through :i Map nor :i Traversable
18:13:01 <edwardk> :info isn't very good at showing instances
18:13:18 <edwardk> the instance is on Map k, not Map and isn't defined in Traversable
18:15:47 <parcs> that's inconvenient
18:16:13 <Eduard_Munteanu> How so?
18:16:30 <Eduard_Munteanu> Oh, :info
18:17:12 <Eduard_Munteanu> You might want to use Haddock docs
18:20:30 <parcs> strange
18:21:00 <parcs> the (Map k) Foldable instance is shown with :i Foldable ..
18:21:54 <djahandarie> ByteString.Char8 is probably the right thing to use for IRC data, right? Since there are no guarentees about charset
18:22:25 <kmc> depends on what you want to do
18:23:03 <kmc> for clogparse i decode message body as UTF-8 in a lenient mode
18:23:11 <kmc> that module is designed for this channel in particular
18:23:20 <djahandarie> Right, I was looking at it earlier
18:23:27 * kmc wonders if there are any channels that use multibyte-only encodings
18:23:45 <djahandarie> See irc.2ch.net
18:24:39 <djahandarie> Since I'm just writing a general library sort of thing, I think it's best to use a ByteString and then let an application on top of it make assumptions about charset
18:25:54 <Eduard_Munteanu> kmc: channels, or servers?
18:26:42 <Eduard_Munteanu> I'm guessing that's a server thingy, no?
18:26:47 <kmc> encoding?
18:26:53 <Eduard_Munteanu> Yes.
18:26:59 <djahandarie> Encoding isn't specified anywhere.
18:27:01 <kmc> it is a consensus thing only
18:27:15 <kmc> IRC is effectively a protocol for the exchange of byte sequences
18:27:19 <kmc> (non-NUL-byte sequences?)
18:27:30 <ion> of limited length
18:27:32 <kmc> servers are free to impose or not impose an encoding policy
18:27:39 <kmc> same for channels
18:28:09 <Eduard_Munteanu> Ah, but the policy isn't something enabled by the protocol, I see.
18:28:20 <kmc> right, any more than a "no trolling" policy
18:28:36 <kmc> in fact some channels will treat "wrong encoding" the same way
18:29:22 <kmc> here is an illustrative anecdote: my guillemets here used to be in the IRC ad-hoc Latin-1 / UTF-8 hybrid, until Twey bugged me about it enough that I switched to UTF-8
18:36:29 <Eduard_Munteanu> So IRC doesn't even tag messages with an encoding specifier?
18:36:49 <danharaj> hahaha
18:36:57 * Eduard_Munteanu could look, but he's asking :)
18:37:00 <danharaj> IRC doing anything other than sending strings of bytes?
18:37:05 <danharaj> So drole.
18:37:42 <Eduard_Munteanu> DCC receiving is some sort of ad-hoc tagging of that sort I guess.
18:37:42 <cmccann> danharaj, that's not all it does
18:37:56 <danharaj> lies
18:38:00 <danharaj> IRC is a series of tubes
18:38:06 <cmccann> occasionally IRC also involves sending nothing
18:38:13 <Eduard_Munteanu> (for binary encoded files)
18:38:22 <cmccann> though I suppose you could call that a string of bytes of length zero, so eh
18:38:29 <ColonelJ> anyone written an IRC server in Haskell yet?
18:38:50 * ColonelJ is too lazy to google right now
18:39:17 <ColonelJ> you took too long so I googled
18:39:21 <ColonelJ> http://chrisdone.com/posts/2011-01-30-hulk-haskell-irc-server.html
18:39:35 <shachaf> Typing a query into #haskell takes longer than typing into the Google.
18:40:16 <ColonelJ> typing into google gets old
18:40:40 <ColonelJ> anyway I was wondering what's the state of the art in using haskell for web applications with databases?
18:40:58 <danharaj> Yesod probably
18:41:00 <danharaj> with Persistent
18:41:04 <danharaj> and HDBC?
18:41:06 <ColonelJ> I am considering using it for my project
18:41:12 <ps-auxw> I've written an IRC server to learn Haskell, but it was too ugly, so I never released it. :)
18:41:50 <ColonelJ> Haskell has a lot of tricks
18:41:52 <ps-auxw> It wasn't really feature complete anyway.
18:42:54 <cmccann> a lot of people seem to be put off by yesod though
18:44:15 <ColonelJ> I still don't know what RESTful is haven't looked into it
18:45:00 <kmc> ColonelJ, REST is the idea that you should actually pay attention to the verbs provided in HTTP instead of doing everything through some shitty form-encoded POST
18:45:01 <danharaj> What's a good resource for learning how to make C bindings?
18:45:09 <kmc> danharaj, RWH chapter on FFI
18:45:19 <cmccann> I think it's mostly that RESTful means making the HTTP verbs and URLs actually mean something
18:45:22 <danharaj> o rly I did not know
18:45:33 <kmc> danharaj, it's a good one
18:45:44 <cmccann> rather than building huge baroque edifices of XML nonsense on top of generic HTTP
18:46:02 <kmc> RWH gets some criticism from beginners but I at least think its topics chapters (FFI, profiling, STM, etc.) are great and more comprehensive than any comparable resource
18:46:11 <danharaj> pff beginners
18:46:18 <danharaj> we suck at opinions
18:46:27 <kmc> i got a lot out of reading those chapters even though i already knew Haskell decently well
18:46:57 <ColonelJ> cmccann: any decent examples?
18:47:06 <cmccann> not off the top of my head
18:47:08 <cmccann> ask google
18:47:12 * Eduard_Munteanu thinks wikibooks is similar in that respect
18:47:12 <ColonelJ> trying
18:47:13 <danharaj> I'm working on lispy's freetype2 bindings. I'm aiming to implement a pure interface on top of the horrifically stateful API the C code provides.
18:47:40 <danharaj> My plan is to write a less stateful wrapper in C and then bind that.
18:47:49 <kmc> danharaj, oh, I would go the opposite way
18:47:59 <kmc> Haskell is a decent language even for stateful pointerful code
18:48:23 <danharaj> Yeah, but freetype is architected in an annoying manner :\
18:48:44 <kmc> wrappers are often a lot more concise with a few HOFs
18:48:49 <danharaj> HOF?
18:48:55 <kmc> higher-order functions
18:49:04 <kmc> danharaj, you might also like my slides at http://www.ugcs.caltech.edu/~keegan/talks/high-level-ffi/talk.html
18:49:28 <kmc> (they don't quite render right in chrome unless you hit the "ø" button in the upper right corner)
18:49:37 <danharaj> pff chrome
18:49:53 <djahandarie> That was a good talk
18:49:57 <djahandarie> Too bad it wasn't recorded
18:49:58 <kmc> thanks
18:50:04 <kmc> yeah, edwardk didn't bust out the ipad until later
18:50:04 <danharaj> you should do a video blog
18:50:10 <kmc> are we doing a Boston Haskell thing soon?
18:50:14 <djahandarie> Hmm
18:50:26 <djahandarie> Nothing planned afaik, but I think we want to do one at some point
18:50:44 <shachaf> djahandarie is in Boston now?
18:50:51 <djahandarie> No, I just like to pretend I am
18:50:59 <parcs> wouldn't it be better to produce a 1:1 wrapper and then build a better abstraction on top of that?
18:51:02 <kmc> you're still in deepest connecticut?
18:51:06 <kmc> parcs, that's what I like to do
18:51:08 <djahandarie> Yes
18:51:14 <kmc> the talk explains the three layers in hdis86
18:51:15 <djahandarie> In the middle of the woods somewhere
18:51:36 <djahandarie> Hacking on type theory...
18:51:43 * djahandarie kindles the fire
18:51:46 <copumpkin> kmc: I think so
18:51:48 <kmc> which are roughly a) C in Haskell syntax; b) imperative Haskell with algebraic data and garbage collection; c) functional Haskell
18:52:03 * cmccann suggests djahandarie look into deforestation techniques for optimization
18:52:32 <kmc> oh, there was a suggestion i should use ST instead of IO for (b)
18:52:39 <kmc> so that the wrapper to (c) isn't "unsafe"
18:54:00 <kmc> i think it would work, if the UD type contained the 's' type parameter
18:54:16 <kmc> though i should be careful because Hdis86.Pure.disassemble is also using "lazy IO" tricks
18:54:39 <kmc> (except not as bad as real lazy IO, because udis86 really is a closed world and won't throw disk errors etc)
18:54:59 <kmc> but it does make FFI calls behind the scenes as your [Instruction] is consumed
18:55:07 <edwardk> kmc: i've been talking to pchiusano and dolio about talking in early august
18:55:20 <edwardk> i'm trying for august 5th
18:55:30 <edwardk> i'll know tomorrow i think
18:55:56 <kmc> cool
18:56:11 <kmc> i'd rather have it the next week, but whatever works
18:56:57 <edwardk> racketcon this weekend, hac phi the next, i'm looking at heading to michigan that week, so its the lull in the middle
18:58:04 <djahandarie> That should work for me
18:58:05 <kmc> i see
19:01:39 <djahandarie> Man, I need dependent types now. :(
19:02:21 <ColonelJ> this yesod site is very hard to navigate
19:03:14 <djahandarie> What I really need right now is just a unique phantom type for a tag, it doesn't really need to have anything to do with the value
19:03:31 <djahandarie> I vaguely remember this functionality being somewhere but I don't remember
19:04:18 <cmccann> unique at compile time or run time?
19:04:56 <parcs> ColonelJ: indeed. yesod is woefully undocumented. i learned most of its operations by looking at the source code of one of the author's websites
19:05:11 <cmccann> the documentation is getting better over time
19:05:12 <djahandarie> cmccann, wait, what do types have to do with run time?
19:05:50 <ColonelJ> this is really stupid I have to use google to navigate the site because there's no way to do so otherwise
19:06:00 <cmccann> djahandarie, in the sense of do you need to have things be of arbitrary but distinct types somewhere that they're not statically known?
19:06:05 <cmccann> or just generate some tags up-front
19:07:09 <djahandarie> data Example x = Example String;    Every new Example I create I want a different x, or something.
19:07:47 <ColonelJ> what's all this about reverse proxying
19:08:10 <cmccann> djahandarie, ok, and do you create all your Example values in a predetermined way, or can arbitrary amounts be created at run time?
19:08:15 <parcs> ColonelJ: i feel like yesod is a big hack. take a look at snap and happstack instead
19:08:17 <scooty-puff> can anyone help me right a Data.Generics-style transform involving some type A :: * -> *, that goes A a -> A b?
19:08:21 <scooty-puff> *write
19:08:34 <djahandarie> cmccann, arbitrary amounts can be created at run time.
19:10:05 <cmccann> djahandarie, then probably time for some existential angst
19:10:10 <djahandarie> I would do this with a pi type with a dependently-typed language. But I don't actually need to work with x ever, I just need it to be a unique type so different values don't get mixed up with each other, so I'm wondering if I can get away with something in Haskell.
19:10:21 <djahandarie> Yeah, that's probably the right way to do it
19:11:05 <scooty-puff> an owning monad and a forall?
19:11:13 <scooty-puff> *dependent?
19:11:23 <scooty-puff> *that it is dependent on for creation?
19:11:55 <luite> parcs: why a big hack?
19:12:04 <djahandarie> Yep, should be able to do this with a forall. Thanks for the push in the right dir cmccann
19:12:21 <scooty-puff> data Unique s = Unique; data UniqueT s m a = UniqueT (m a); etc.
19:12:28 <cmccann> djahandarie, pretty sure it's the only way to do it, since you've specified that arbitrary values can be created at runtime, and each value needs a unique type :]
19:13:11 <cmccann> and since you can't really do that in a meaningful sense, you probably want something like what ST does to create type variables that can't unify with anything else, etc.
19:13:18 <djahandarie> Right.
19:16:06 <scooty-puff> anyone really familiar with Data.Generics in general?
19:16:37 <scooty-puff> mostly its that the standard schemes aren't quite enough, but some of it seems kind of tricky
19:17:27 <cmccann> scooty-puff, what are you trying to do?
19:18:57 <scooty-puff> cmccann, A a -> A b, not really sure it can be done - basically, i would like to describe how to turn a to b, and let that be enough to go A a -> A b without having to deconstruct/reconstruct all of the structure
19:19:48 <scooty-puff> without catching anything that may just happen to be of type a0 ~ a
19:19:57 <scooty-puff> though that last bit can be worked around
19:21:06 <cmccann> scooty-puff, I'm still not really clear on what you're trying for, sorry :T
19:21:21 <scooty-puff> :t everything
19:21:22 <lambdabot> forall r a. (Data a) => (r -> r -> r) -> GenericQ r -> a -> r
19:21:27 <scooty-puff> er..
19:21:29 <scooty-puff> :t everywhere
19:21:30 <lambdabot> forall a. (Data a) => (forall a1. (Data a1) => a1 -> a1) -> a -> a
19:21:35 <scooty-puff> so i would like to have
19:22:51 <scooty-puff> :: (forall a1 b1. (Data a1, Data b1) => a1 -> b1) -> f a -> f b
19:22:53 <scooty-puff> or something..
19:23:05 <scooty-puff> hmm, guess i can be as specific:
19:23:33 <scooty-puff> :: (Data (f a), Data (f b), Data a, Data b) => (a -> b) -> f a -> f b
19:23:53 <scooty-puff> hmm, maybe i can find code for default fmap via data.generics
19:24:54 <TooTall> Hey everybody check is cool Chat room out #theedj
19:25:40 <cmccann> scooty-puff, yeah, there's a bunch of stuff in there that might help. Is your "f" going to be a Functor instance there?
19:25:57 <scooty-puff> it isn't now, but it could be
19:26:08 <scooty-puff> the the identifier type for Stmt, Exp's
19:26:15 <kmc> TooTall, don't spam
19:26:21 <kmc> did you want to talk about Haskell?
19:26:52 * TooTall Likes #theedj
19:27:32 <scooty-puff> http://www.haskell.org/haskellwiki/Scrap_your_boilerplate, 1.2 fmap
19:27:34 <cmccann> scooty-puff, if you can make it a Functor then you don't really need to do anything else, do you?
19:27:36 <scooty-puff> exactly what i need
19:27:41 <ion> @ops
19:27:41 <lambdabot> Maybe you meant: docs oeis pl
19:27:42 <scooty-puff> hmm, duh
19:27:51 <kmc> @where ops
19:27:52 <scooty-puff> yes
19:27:52 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
19:28:01 <scooty-puff> (think i'll just derive that..)
19:28:54 <cmccann> scooty-puff, probably simpler that way
19:29:01 --- mode: ChanServ set +o monochrom
19:29:19 --- mode: monochrom set +b *!*@c-71-58-154-32.hsd1.pa.comcast.net
19:29:31 <scooty-puff> thanks for the help - don't know why didn't just make a functor
19:30:28 <cmccann> scooty-puff, sometimes it's hard to remember to try the stupidly simple way :]
19:30:57 <kmc> especially in Haskell
19:31:16 <aavogt> one thing is the -XDeriveFunctor doesn't derive fmaps which modify the n'th type variable
19:31:37 <scooty-puff> standalone deriving can make it work if its the last one atleast
19:31:46 <scooty-puff> (or a GADT)
19:31:49 <aavogt> as in   fmap1 :: (a -> x) -> (a,b,c) -> (x,b,c)
19:31:54 <scooty-puff> o, right
19:31:55 <scooty-puff> yeah
19:32:19 <aavogt> if you change around that fmapData, you can write those
19:34:50 * hackagebot web-routes-boomerang 0.25.1 - Library for maintaining correctness and composability of URLs within an application.  http://hackage.haskell.org/package/web-routes-boomerang-0.25.1 (JeremyShaw)
19:51:22 --- mode: monochrom set -b *!*@c-71-58-154-32.hsd1.pa.comcast.net
19:51:25 --- mode: monochrom set -o monochrom
20:07:45 <Twey> Eduard_Munteanu: IRC is defined in terms of bytes
20:08:25 <Twey> So long as the encoding doesn't use the Forbidden Bytes, it can be anything the server supports
20:08:58 <Twey> IIRC the old spec makes some assumptions about a particular Finnish ASCII-set encoding, but I don't think the new one does
20:09:49 <kmc> «Nuapurista kuulu se polokan tahti jalakani pohjii kutkutti.»
20:09:51 <Twey> CTCP is a quoting mechanism rather than an encoding specifier, per se
20:10:18 <kmc> «Hra-tsa-tsa, ia ripi-dapi dilla barits tad dillan deh lando. Aba rippadta parip parii ba ribi, ribi, ribiriz den teahlando»
20:10:31 <Twey> Haha, Loituma
20:10:37 <Twey> I love those guys.
20:12:31 <ion> I think IRC nicks are still handled case-insensitively using the ISO-646-FI encoding.
20:13:15 <Twey> ion: I don't think the standard requires it any more
20:13:20 <Twey> I know it is the case on Freenode
20:13:37 <ion> Ok. foo| and foo\ can coexist on Freenode?
20:13:47 <monochrom> CASEMAPPING=rfc1459 CHARSET=ascii is what a typical server announces, for what it's worth
20:13:56 <Twey> But there are also other servers that have different rules; Unilang's server allows (some subset of?) all of Unicode, for example
20:14:08 <Twey> ion: Not on Freenode, no
20:14:09 <monochrom> otoh servers don't actively enforce ascii-only
20:14:44 <monochrom> as in, they don't use the 8th bit for parity check! :)
20:15:10 <kmc> just use 9 bit bytes, what's the problem
20:15:17 <Twey> Huh, yeah.
20:15:27 <kmc> AVR serial has configurable width of 6-9 bits
20:15:49 <Twey> Unilang says CASEMAPPING=rfc1459 CHARSET=ascii too
20:15:53 <ion> My byte width goes up to eleven.
20:15:55 <monochrom> there was a famous public ftp server that ran on a 36-bit computer
20:16:04 <Twey> monochrom: O.O
20:16:14 <Twey> monochrom: … why?  :þ
20:16:15 <kmc> IBM's s390 architecture is the only 31-bit architecture supported by Linux
20:16:38 <monochrom> because whatever organization sponsoring it had a 36-bit computer
20:16:39 <listofoptions> that's what most minicomputers ran on, that and any evenly divisible number of bits
20:17:12 <listofoptions> honywell minicomputers ran on about 46bits methinks
20:17:19 <listofoptions> iirc
20:17:29 <kmc> writing this now on a 36-bit computer
20:17:32 <kmc> or 48-bit
20:17:53 <monochrom> it was in the 1990s. computer biodiversity actually existed back then
20:19:30 <Twey> Seems odd to use a size for a binary word that isn't a power of two
20:19:53 <listofoptions> pic microcontrollers use 12 bits
20:20:10 <monochrom> perhaps because to accomodate some programs that preferred octet+parity
20:20:19 <listofoptions> actually whatever size that works for their harvard arch
20:20:30 <monochrom> 36 = 4*(8+1) afterall
20:22:19 <listofoptions> hell ia32 procs have a 48 bit addr buss
20:23:11 <ion> We seem to be confusing two things here. The size of a byte and the width of the address bus.
20:23:46 <ion> The width of the address bus can be pretty much anything. A non-power-of-two byte size is a bit more interesting.
20:23:53 <listofoptions> true
20:25:18 <kmc> as far as physical addrs go, most x86 chips are 20, 36, or 48 bits
20:26:09 * monochrom remembers 20-bit (address) 8088!
20:26:30 * monochrom remembers the subsequent A20 extension too!
20:26:37 <kmc> monochrom, you should enter something for http://io.smashthestack.org:84/intro/
20:28:03 <monochrom> yikes, "has to run in the MBR of an USB drive (real mode/446bytes)". I'm too spoiled by haskell to write short assembly code
20:28:07 <Eduard_Munteanu> I think the PDP was rather odd.
20:29:48 <monochrom> on the bright side, x87 is not "daunting" to me. I learned it
20:30:30 <listofoptions> i preffer the parallax prop miself
20:30:36 <listofoptions> *myself
20:40:06 <sshc> It'd be convenient to have a single-character alias of >>> .
20:40:36 <kmc> yes
20:41:02 <dobblego> http://hackage.haskell.org/packages/archive/base-unicode-symbols/0.2.1.5/doc/html/src/Control-Category-Unicode.html#%22D9
20:41:09 <kmc> or you can use (.) with (=<<)
20:41:14 <ion> ⋙
20:41:23 <dobblego> (⋙) ∷ Category (⇝) ⇒ (α ⇝ β) → (β ⇝ γ) → (α ⇝ γ)
20:41:29 <copumpkin> lol
20:41:36 <copumpkin> for those who miss agda in haskell
20:41:40 <kmc> ⋙ ntbcw »
20:41:41 <copumpkin> yet are content with lambdas still being slashes
20:41:44 * djahandarie rages
20:41:55 <kmc> copumpkin, lambda is a letter, you insensitive clod
20:42:05 <copumpkin> in other news, that's an awfully squiggly arrow there
20:42:19 <copumpkin> kmc: pff, fucking greeks
20:42:25 <copumpkin> I mean
20:42:28 <copumpkin> f***ing greeks
20:42:36 <ion> falling?
20:42:41 <ion> fishing?
20:42:43 <kmc> i know, right? first they take all your bailout money and then they take your lambda calculus operators
20:43:05 <ion> fitting?
20:43:31 <monochrom> haha
20:45:08 <sshc> The problem with unicode is that it's hard to read with a 6.5pt font.  I always need to increase the size when I know I'm going to work with it.
20:45:09 <kniu> is there a function that reads from a handle only what is available for reading in the handle?
20:46:18 <monochrom> there are some non-blocking read functions
20:47:29 <kniu> I only see hGetBuf, which requires using Foreign.Ptr
20:55:05 <hpaste> sebz pasted “edit” at http://hpaste.org/49329
20:55:11 <sebz> is there a slicker way to write this? (or not have to?)
20:55:43 <sebz> applies a function to the nth element of a list
20:56:05 <kmc> well, lists are not really the right structure here
20:56:14 <kmc> you want something with random access
20:56:23 <sebz> yeah
20:56:28 <kmc> Data.Sequence? Data.IntMap?
20:56:39 <kmc> presuming you want to stick with lists, this looks all right
20:57:19 <kmc> :t zipWith ($) (replicate ?n id ++ [?f] ++ repeat id)
20:57:20 <lambdabot> forall a. (?n::Int, ?f::a -> a) => [a] -> [a]
20:57:27 <kmc> would be another approach
20:58:13 <sebz> oh that looks better
20:58:28 <sebz> yeah I'm representing a 19x19 go board
20:58:31 <kmc> heh
20:58:45 <kmc> i would use Data.Map (Int, Int) Whatever
20:58:53 <kmc> you could use Array but i kinda dislike the array API
20:59:04 <kmc> and you probably want the ability to update the board at a single location efficiently
20:59:09 <kmc> which tree-based structures give you, and arrays don't
20:59:19 <confab-school> I have a random question. if I have a list with a random number of nested lists to a random number of levels.  what is the best way to flatten that list?
20:59:33 <sebz> okay, thanks kmc!
20:59:39 <kmc> confab-school, that question doesn't type-check
20:59:44 <kmc> what would the type of your "flatten" function be?
21:00:20 <confab-school> I'm not sure.
21:00:22 <kmc> in fact, what's the type of "nested lists to a random number of levels"
21:00:38 <RayNbow> copumpkin: thanks for tweeting that pastebin link :)
21:00:42 <kmc> it's not well-typed, if you mean Haskell's standard list type
21:00:46 <kmc> you can define a new type which is like that
21:00:54 <copumpkin> RayNbow: I approve! ;)
21:00:56 <kmc> data Tree a = Node [Tree] | Leaf a
21:01:02 <kmc> and you can define flatten :: Tree a -> [a]
21:01:04 <kmc> as a simple recursion
21:01:12 <kmc> err Node [Tree a]
21:03:31 <RayNbow> copumpkin: I was actually having a discussion with some colleagues yesterday about the publishing system
21:04:01 <RayNbow> (topic came up because some notifications from a conference were sent out and that CompSci conferences usually have low acceptance rates)
21:11:35 <fengshaun> oh God, learning a new kb layout is so hard!  My brainz is expolding!
21:12:32 <confab-school> hmm. I see.
21:14:03 <danharaj> fengshaun: trust me, the harder part is learning how to switch between layouts on the fly :)
21:14:06 <kmc> fengshaun, which one?
21:14:10 <kmc> danharaj, that came automatically to me
21:28:02 <danharaj> kmc: It took my a while before I could consciously code switch from qwerty to dvorak and back. I wonder if that process is the same when a bilingual code switches.
21:29:42 <luite> maybe because they're sufficiently different? I find it difficult to switch between US and German kezboard layouts
21:29:58 <danharaj> I think it's practice mostly.
21:30:31 <kmc> luite, nice ;)
21:31:27 * hackagebot algebra 0.8.0 - Constructive abstract algebra  http://hackage.haskell.org/package/algebra-0.8.0 (EdwardKmett)
21:37:59 <fengshaun> danharaj: switching on the fly...don't even talk about it!  Although that's getting better with dvorak and qwerty.
21:38:06 <fengshaun> kmc: colemak!
21:38:09 <kmc> fuck colemak
21:38:11 <confab> so what i gather kmc, is that it's best to start with the type of the function first, before attempting to write anything?
21:38:17 <kmc> okay, that was pointlessly hostile fengshaun, sorry
21:38:19 <kmc> but i don't see the point
21:38:29 <fengshaun> kmc: why not?
21:38:30 <kmc> is it really easier to learn something that's half qwerty
21:38:37 <kmc> it's still half not qwerty
21:38:42 <fengshaun> I already know qwerty and dvorak.
21:39:02 <Elbar> qwertz ... the only way to go ;)
21:39:13 <fengshaun> kmc: doesn't help being half qwerty, since I'm switching to it from dvorak
21:39:45 <danharaj> pointless hostility is the best hostility
21:39:46 <danharaj> fucker.
21:40:54 <copumpkin> o.O
21:40:56 <kmc> fengshaun, oh, so what's in it for you then?
21:41:17 <fengshaun> I'll find that out when I learn it and compare it!
22:08:27 <hpaste> LoganSperman2 pasted “LoganSperman2” at http://hpaste.org/49331
22:13:19 <NemesisD> hi all. i've got some code along the lines of: do { as <- mas; bs <- bs; return as ++ bs } isn't there a more concise way to put this
22:13:46 <shachaf> @ty liftM2 (++)
22:13:47 <lambdabot> forall a1 (m :: * -> *). (Monoid a1, Monad m) => m a1 -> m a1 -> m a1
22:14:04 <copumpkin> (| mas ++ bs |)
22:14:35 <kmc> or liftA2 (++)
22:14:56 <NemesisD> copumpkin: isn't that a preprocessor thing?
22:15:03 <NemesisD> i forgot the name for it
22:15:05 <kmc> she
22:15:08 <NemesisD> yeah!
22:15:08 <copumpkin> yep
22:17:15 <NemesisD> thanks. liftM2 and friends completely escaped me
22:17:41 <fryguybob> @. pl undo do x <- xs; y <- ys; return (x ++ y)
22:17:41 <lambdabot> (`fmap` ys) . (++) =<< xs
22:18:40 <fryguybob> oops
22:18:42 <fryguybob> @. pl undo \xs ys -> do x <- xs; y <- ys; return (x ++ y)
22:18:43 <lambdabot> liftM2 (++)
22:19:45 <NemesisD> i've found myself using =<< much more than >>=, is that a common thing or considered bad practice?
22:19:57 <shachaf> copumpkin: Wait, someone implemented idiom brackets?
22:20:13 <kmc> she implements them
22:20:13 <NemesisD> it seems to read more functionally than imperatively to me
22:20:14 <shachaf> NemesisD: It's in the same order as $ and ., so it makes sense.
22:20:47 <kmc> i think it's a stretch to call that functional vs. imperative
22:20:48 <shachaf> Pff. she.
22:20:52 <kmc> but yeah, it goes with (.)
22:20:58 <shachaf> iI (++) mas bs Ii
22:21:00 <kmc> silly mathematicians
22:22:30 <shachaf> People should just use RPN languages.
22:22:44 <shachaf> Then there'd be no silly distinctions like that.
22:24:21 <djahandarie> Gah. Couldn't make it work with existential types
22:24:30 <djahandarie> I think I definitely need dependent types
22:24:58 <djahandarie> Or to start reflecting a bunch of data
22:29:02 <hpaste> LoganSperman2 pasted “LoganSperman2's Real Identity” at http://hpaste.org/49333
22:31:18 <hpaste> “Unlimited Truth” pasted “Madeleine McCann, JonBenet Ramsey & Other Sick "Lulz"” at http://hpaste.org/49334
22:33:28 <hpaste> YTVHome pasted “LoganSperman2: A Good Kid” at http://hpaste.org/49335
22:35:43 <hpaste> Irish282 pasted “True Words: LoganSperman2 IS A Hero” at http://hpaste.org/49336
22:45:04 <hpaste> Irish282 pasted “Logan Sperman aka LoganSperman aka LoganSperman2” at http://hpaste.org/49338
22:45:44 <djahandarie> Wheee! I got it. :)
22:47:03 <djahandarie> I think spam bots found hpaste, btw...
22:47:07 <hpaste> “Logan Sperman” pasted “Irish282 aka Irish282” at http://hpaste.org/49339
22:47:33 <djahandarie> I'll shoot an email to chris
22:47:46 <kmc> or kick hpaste ;)
22:47:52 <kmc> i don't really understand this spam anyway
22:48:26 --- mode: ChanServ set +o copumpkin
22:48:38 --- kick: hpaste was kicked by copumpkin (come back when you have a captcha :))
22:48:44 --- mode: copumpkin set -o copumpkin
22:48:55 <djahandarie> Heh.
22:49:06 <djahandarie> Something tells me it didn't get a captcha.
22:49:15 --- mode: ChanServ set +o copumpkin
22:49:27 --- mode: copumpkin set +b *!~hpaste@unaffiliated/chrisdone
22:49:27 --- kick: hpaste was kicked by copumpkin (and may the power of vectron bring prosperity to your house)
22:49:34 --- mode: copumpkin set -o copumpkin
22:50:09 <djahandarie> So, here is my solution: http://hpaste.org/49340
22:50:09 <copumpkin> Praise Vectron!
22:50:23 <djahandarie> good typechecks, bad doesn't
22:50:31 <kmc> by vectron's beard!
22:50:36 <loupgaroublond> is there a quick way to compose enumeratees? i have enumerator $= enumeratee1 $= enumeratee2, the only way to make the types line up is to put the first operater and operands in parens
22:50:49 <copumpkin> djahandarie: fancy!
22:51:00 <copumpkin> djahandarie: have you seen the session types stuff?
22:51:05 <djahandarie> Nope
22:52:54 <djahandarie> I ended up going with the CPS-style stuff thing for makeServer and makeChannel, but I could replace it with foralls in a wrapper data type and use case expressions when building good and bad
22:53:12 <djahandarie> But that's even uglier
22:53:22 <copumpkin> @hackage Coroutine
22:53:22 <lambdabot> http://hackage.haskell.org/package/Coroutine
22:53:27 <copumpkin> @hackage sessions
22:53:27 <lambdabot> http://hackage.haskell.org/package/sessions
22:53:32 <copumpkin> @hackage simple-sessions
22:53:33 <lambdabot> http://hackage.haskell.org/package/simple-sessions
22:53:56 <djahandarie> Where exactly does Ryan work? He seems to do all sorts of cool type-level shit
22:54:09 <copumpkin> beats me :P
22:54:10 <djahandarie> Like every mailing list post I ever read about types ends up being from him
22:54:33 <djahandarie> This looks complicated.
22:54:48 <djahandarie> But it is also probably exactly what I need, but I'll disregard it and then realize that fact later
23:15:31 <dented42> Is it known for sure if the haskell platform functions properly on mac os 10.7?
23:27:16 <c_wraith> I think it's known to have some issues, actually, but I haven't been following the details.
23:32:18 <chrisdone> djahandarie: okay, i deleted the spam pastes. i'd disable the announcing but maybe it's died down now. if the spam continues i guess you can judge whether to ban hpaste as i won't be around
23:32:19 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
23:33:15 <chrisdone> i was thinking of restricting announcements to authors that correspond to nicknames in the channel, that might cut down outside spam mostly altogether
23:55:39 * hackagebot repa 2.1.1.1 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-2.1.1.1 (BenLippmeier)
23:58:16 * frerich wishes he could motivate his boss to accept *some* haskell software development, at least for in-house tools.
23:58:41 <frerich> As it is, with C++ in the day job and a little son at home, you don't really get around to do something non-trivial with Haskell. :-}
23:58:47 <frerich> I can't get past the "tictactoe game" stage.
23:59:41 <shachaf> frerich: Write Haskell that generates C++. :-)
