01:48:30 * osfameron reads augustss's post about polymorphic do bindings, wonders if that kind of thing is codified in test cases for haskell
01:52:42 <Saizan> there's nothing special about do-bindings there btw
01:53:17 <Saizan> and var's type is simply not valid in standard haskell
02:20:54 <Saizan> edwardk: you forgot the operations in the Left/RightModule classes in your post
03:06:53 <notostraca> Is there a publicly available formal grammar for Haskell 98 (or Haskell')?
03:07:10 <Saizan> there's one in the report
03:07:17 <Saizan> @where report
03:07:17 <lambdabot> http://www.haskell.org/onlinereport/
03:07:29 <notostraca> Thank you very much, wow that was quick
03:09:58 <notostraca> Hmm, maybe I asked the wrong question -- is there a Parsec grammar that can parse Haskell 98?  Or any PEG, I'm not picky here.
03:10:21 <ivanm> haskell98 and haskell-src-exts provide parsers
03:10:29 <ivanm> @hackage haskell98
03:10:30 <lambdabot> http://hackage.haskell.org/package/haskell98
03:10:35 <ivanm> no, wait, wrong package
03:10:39 <ivanm> @hackage haskell-src
03:10:39 <lambdabot> http://hackage.haskell.org/package/haskell-src
03:10:44 <ivanm> @hackage haskell-src-exts
03:10:44 <lambdabot> http://hackage.haskell.org/package/haskell-src-exts
03:10:53 <ivanm> notostraca: ^^ they're the two
03:11:04 <notostraca> Thanks, I will check them out
03:11:12 <ivanm> you almost definitely want the latter
03:11:24 <ivanm> notostraca: what are you wanting to use them for, if I may ask?
03:12:40 <notostraca> Mostly, I want to see how a parser for an eye-pleasing language like Haskell looks; I am also hoping to use Haskell to implement some experimental language
03:13:14 <Peaker> I find that I still turn to the Python interactive shell because ghci makes it more of a pain to do some things (decimal to hex, encoding/decoding hexdumps, replacing strings within strings, string splitting) -- anyone has some nice .ghci/alternate-prelude that makes it nice to do these things?
03:13:23 <notostraca> The plan is to either hack GHC (thank you, bootstrapping!) or translate to Neko VM
03:13:29 * hackagebot unification-fd 0.5.0 - Simple generic unification algorithms.  http://hackage.haskell.org/package/unification-fd-0.5.0 (WrenThornton)
03:13:44 <ivanm> notostraca: well, the source for haskell-src-exts is generated from the grammar using happy I believe
03:14:12 <notostraca> Ah, and Happy is LALR?  I can't remember
03:15:15 <ivanm> I don't know what LALR means, but it's a parser generator
03:15:18 <ivanm> and alex is a lexer
03:15:50 <merijn> Look-Ahead Left Recursive grammar if my memory serves me
03:16:18 <notostraca> Yeah, I believe it allows backtracing?
03:16:58 <ivanm> *shrug*
03:17:14 <notostraca> I'm pretty new to parsing, I was looking to Haskell because it has some excellent parser libraries (so far I have looked at Parsec and Frisby)
03:17:33 <ivanm> Frisby? I think I heard of it but have never seen it actually used...
03:17:53 <erus`> where is the idiomatic place to put a "where"
03:18:06 <erus`> on the same line
03:18:07 <notostraca> Currently it seems to be the only maintained Packrat parser in Haskell
03:18:08 <erus`> on the line below?
03:18:11 <erus`> how many tabs?
03:18:12 <ivanm> ahhh, it's one of John Meacham's packages
03:18:20 <quicksilver> on the same line if it will fit in a convenient way
03:18:21 <ivanm> erus`: don't use tabs in Haskell code!
03:18:31 <quicksilver> on the line below, one indent-stop in, if not.
03:18:49 <ivanm> and then all things defined within the where block one extra stop in after that
03:18:50 <notostraca> But yes, tabs are bad
03:19:01 <osfameron> tabs are so right in theory, so wrong in practice :-(
03:19:13 <hpaste> erus` pasted “where to put where” at http://hpaste.org/48970
03:19:17 <ivanm> osfameron: too true
03:19:23 <erus`> like that?
03:19:40 <quicksilver> yes, except don't use tabs.
03:19:44 <ivanm> erus`: most people use either 2 or 4 spaces for indentation, not 8
03:19:55 <erus`> i use tabs set to 4 spaces
03:20:03 <merijn> erus`: Hence, don't use tabs
03:20:05 <quicksilver> don't use real tabs, though.
03:20:05 <notostraca> Sting?
03:20:05 <ivanm> Haskell code tends to have long lines :p
03:20:12 <merijn> GHC assumes tabs are 8 spaces
03:20:21 <ivanm> merijn: on *nix it does
03:20:24 <ivanm> 4 spaces on windows
03:20:32 <merijn> Just like every sane text editor on the planet
03:20:32 <ivanm> hence why they're highly discouraged
03:20:41 * merijn goes on a death to tabs rant
03:20:46 <quicksilver> ivanm: are you sure? that sounds extremely unlikely.
03:20:52 <arw__> indent-based syntax is very broken when it comes to different methods of indentation. surprise!
03:20:58 <ivanm> quicksilver: pretty sure
03:21:03 <Peaker> '\x09' is responsible for a lot of pain...
03:21:05 <quicksilver> ivanm: you're wrong.
03:21:15 <arw__> (just to pour some gasoline on the fire :)
03:21:20 <quicksilver> ivanm: the haskell report specifies that tabs are to be interpreted as 8 spaces.
03:21:22 <ivanm> I know students who intermixed 4 spaces and tabs in windows and it worked; when we ran them on *nix they failed
03:21:30 <Peaker> arw__: I think Python's indent-based syntax is only broken if you mix in '\x09', which is a character that simply doesn't have a well-defined meaning
03:21:34 <ivanm> quicksilver: huh
03:21:51 <Peaker> arw__: can you give an example of when a valid "indent style" breaks Python's indentation rules?
03:21:51 <notostraca> ivanm, were they using the same compiler across platforms?
03:21:59 <ivanm> yes
03:22:03 <zygoloid> tabs aren't the problem. saying "tabs are 8 spaces" is the problem :)
03:22:15 <erus`> yeh
03:22:23 <ivanm> zygoloid: technically speaking, mixing tabs and spaces for indentation is the problem
03:22:23 <erus`> treat a tab as one space
03:22:26 <ivanm> which is what usually occurs
03:22:38 <Peaker> Just ban this stupid character from all text files
03:22:41 <merijn> I only know two types of people
03:22:48 <zygoloid> ivanm: that's only a problem because you're allowed to mix them, which only happens because there's an exchange rate
03:22:51 <quicksilver> ivanm: http://www.haskell.org/onlinereport/syntax-iso.html#layout
03:22:53 <merijn> People who use spaces only and people who mix tabs and spaces
03:22:58 <arw__> Peaker: of course. try mixing tabs of 8 with code from somebody using indents of 4. or various kinds of "expand tabs to n spaces" and stuff.
03:23:10 <notostraca> treat "n" tabs as "fib n" spaces
03:23:18 <arw__> Peaker: looks fine in the editor, does weird things in the interpreter.
03:23:20 <Peaker> arw__: That's because tabs are broken...
03:23:31 <quicksilver> zygoloid: there is a haskell prime proposal to make it illegal if the interpretation depends on the exchange rate, effectively outlawing the mixing.
03:23:36 <ivanm> quicksilver: OK, now I'm _really_ confused about the behaviour of the student's code... because it definitely worked on windows where they would have been 4 spaces (as defined by the OS) :/
03:23:37 <Peaker> arw__: It's not really an "indentation style", it's a use of an undefined character in text files
03:23:45 <zygoloid> quicksilver: that sounds extremely sensible to me :)
03:23:46 <ivanm> notostraca: lol
03:23:46 <Nisstyre> yes
03:23:56 <quicksilver> ivanm: I don't think the windows OS 'defines' tabs as 4 spaces in any meaningful sense.
03:23:58 <merijn> Better yet
03:24:06 <arw__> Peaker: thats because a) the syntax that allows tabs but doesn't handle them right is broken or b) the syntax that assumes that tabs are always n spaces wide is broken.
03:24:16 <ivanm> quicksilver: that's what I've always heard...
03:24:18 <merijn> I propose any source files mixing tabs and spaces are promptly deleted by GHC
03:24:22 <Peaker> arw__: Well, python -tt disallows tabs mixture with spaces
03:24:37 <arw__> Peaker: so either you need to disallow tabs in your syntax, or you need to make your syntax non-whitespace-based.
03:24:38 <Peaker> arw__: But a style that mixes spaces and tabs is not a "valid indentation style"
03:24:42 <ivanm> well, Cabal prohibits tabs in .cabal files
03:24:54 <Peaker> arw__: Disallow tabs is the far superior option
03:24:54 <arw__> Peaker: the interpreter allows it. so its valid.
03:25:40 * zygoloid still recalls arguing with the authors of a text editor that it should not be 'canonicalizing' whitespace when copying it from the previous line when the user hits return
03:25:47 <arw__> Peaker: i think parentheses are far superior. to end this pointless discussion: indent-based syntax is fascism!
03:25:53 <notostraca> The main problem I have with tabs is that it is impossible to paste them across programs and expect them to stay the same
03:26:05 <merijn> arw__: Pfft
03:26:31 <merijn> arw__: I disagree with you all, text is just the incorrect medium for code, real editors work directly on ASG's
03:26:37 <merijn> Speaking of which...
03:27:06 <Peaker> arw__: Problem: '\x09' is undefined and then interpreted in conflicting/confusing ways   solution:  Avoid all whitespace-sensitive syntax.     Throwing the baby with the bathwater much?
03:27:18 <Peaker> merijn: :-)
03:27:31 <zygoloid> merijn: i disagree with that :) code is for much more than presenting an algorithm to a machine. the layout is important to human readers and should be preserved :)
03:27:49 <merijn> zygoloid: You can have editors render ASG's in text to humans
03:27:51 <Peaker> zygoloid: Layout is a presentation thing, though, and not a characters-in-a-file/string thing
03:27:57 <arw__> Peaker: there are more problems with whitespace-based syntax than that. tabs are just the most obvious breakage.
03:27:59 <zygoloid> merijn: rendering is not the same as preserving
03:28:00 <Peaker> zygoloid: (if you use ASG editors)
03:28:13 <notostraca> If I paste something from a webpage into Pidgin (XUL-to-GTK), then I get a mess of tabs, which seems odd because I can't type a tab in a message-based editor since that would change the focus on the widget...
03:28:16 <Peaker> arw__: Ah, that's why I asked for any other problem :)
03:28:22 <merijn> zygoloid: Does avoid any indentation based discussions though :>
03:28:26 <Peaker> arw__: tabs are breakage even if whitespace is not significant
03:28:39 <Peaker> arw__: at work, we have coworkers who use eclipse which mixes tabs&spaces, and uses the non-standard tab-width=4 setting, too
03:28:51 <zygoloid> merijn: "how far to the right should i put 'where' nodes when laying out my ASG"? :)
03:28:51 <Peaker> arw__: It's C code -- so it compiles, but it's *utterly unreadable* in a different editor
03:29:01 <arw__> Peaker: but e.g. try c&p-ing whitespace-sensitive code from various documents, websites, etc. try reading whitespace-sensitive code in non-equal-width fonts. try unicode.
03:29:08 <Peaker> arw__: I would rather the code was whitespace-significant, so this problem would have been caught/avoided in the first place
03:29:28 <zygoloid> Peaker: oh ffs, are there still people who think that tabs are a nifty form of compression?
03:29:30 <Peaker> arw__: Worst-case you have to shift the entire paste left or right -- you have key bindings in your editor that does that
03:29:38 * zygoloid nukes emacs from orbit
03:29:40 <Peaker> zygoloid: Yes, plenty of them :-(
03:29:44 <arw__> Peaker: it wouldn't be avoided. it just would lead to broken code instead of just unreadable code.
03:30:08 <Peaker> arw__: No, broken code does not survive our regression suites
03:30:34 <Peaker> arw__: it would cause enough breakage that anyone who had his tabs set up wrong in his editor would *have* to fix it, or none of his code would work
03:30:37 <notostraca> Peaker, if you are using Java in Eclipse, you can create a custom formatting style, then just Ctrl-A Ctrl-Shift-F
03:30:39 <arw__> Peaker: then you shouldn't have any problem in doing indent -i8 -kr on checkin or something.
03:30:53 <arw__> Peaker: do regression tests before and after and everything is fine.
03:30:58 <Peaker> arw__: You would think that -- but as soon as you have branches&merges, you have a big problem doing that
03:31:06 <Peaker> arw__: We'd get lots of spurious conflicts
03:31:29 <Peaker> notostraca: Making comprehensive changes on code is avoided because of the merge/conflict mess it would ensue (we have branches)
03:31:43 <notostraca> oh of course, yes
03:32:03 <arw__> Peaker: oh, merge conflicts. ever used a VCS that considers whitespace changes insignificant?
03:32:04 <Peaker> so we just have to reconfigure our editors so they can show things "correctly" according to whichever editor edited the file we're looking at :-(
03:32:23 <Peaker> arw__: None of those will avoid a conflict if you fix whitespace in a line that someone else deleted
03:32:36 <Peaker> arw__: git doesn't, bzr doesn't, afaik darcs doesn't.. which does?
03:32:45 * zygoloid wants an editor/vcs combination where the editor tracks /how/ you edited the file and uses that to resolve conflicts
03:33:06 <merijn> I think mercurial can be configured to ignore whitespace, but that's not the default
03:33:12 <Peaker> zygoloid: I've started work on that (as part of the structural code editor -- there's structural revision control, which tracks your actual editor changes)
03:33:15 <notostraca> zygoloid, could you explain further?
03:33:26 <arw__> Peaker: fortunately for the whitespace-sensitive guys, only weird stuff. i've seen visual source safe doing something like "well, its only whitespace, just take the newer version"...
03:33:27 <Peaker> merijn: if you do that -- will it ignore it even in modify/delete conflicts?
03:33:34 <merijn> Peaker: No clue
03:33:36 <arw__> Peaker: but no idea if its configurable.
03:34:00 <quicksilver> zygoloid: tabs are, in principle, a mechanism by which the viewer can impose a preference on how they want to view it.
03:34:05 <Peaker> arw__: anyway, we use git, and we configure our merge tools to ignore whitespace as much as possible, and we *still* get a lot of spurious conflicts if we fix indents
03:34:12 <quicksilver> zygoloid: that can work if you use them in certain ways.
03:34:23 <Peaker> Certain ways that no editor I know of supports, though
03:34:47 <Peaker> No editor inserts tabs just up to the "indent-point" and spaces after.. they will always convert the spaces after to tabs too if there are enough of them
03:34:58 <arw__> Peaker: yes, but anyways, you will get those conflicts only once if you do it right. just indent your entire codebase, then only real changes will trigger a reindent.
03:35:02 <notostraca> zygoloid, a quick and dirty fix would be to save undo/redo history I think
03:35:05 <arw__> Peaker: so no problem there.
03:35:32 <Peaker> arw__: conflicts are *really* hard. Harder than re-configuring the editor repeatedly.
03:35:36 <zygoloid> quicksilver: for a long time i was a tab apologist. these days, i value the pragmatism of spaces more highly.
03:35:40 <Peaker> arw__: so we stick with reconfiguring the editor.. all the time :-(
03:35:52 <quicksilver> Peaker: http://www.emacswiki.org/emacs/SmartTabs
03:35:57 <quicksilver> Peaker: I don't actually use it though.
03:36:38 <zygoloid> notostraca: interesting idea :)
03:36:44 <Peaker> quicksilver: that is hopeless -- everyone else who'd work on the code would just mess it up
03:36:54 <arw__> Peaker: your next problem: why isn't your eclipse preconfigured? you can let your sysadmin pre-set all those weird configurations, then that problem will vanish.
03:36:55 <quicksilver> Peaker: that's not really the point.
03:37:05 <quicksilver> Peaker: the point is it can be done, it makes sense, editors can support it.
03:37:10 <zygoloid> notostraca: the sort of thing i'd like to work naturally is, if i select a block of code and indent it and modify it, and someone else adds a line in the block i indented, i want the VCS to understand how to resolve that
03:37:18 <quicksilver> Peaker: *obviously* yes, everyone involved in the code needs to do it right.
03:37:26 <Peaker> arw__: I think they've fixed it -- but we have a lot of legacy tabs.  People still re-install eclipse however they like though, and we don't restrict people's choice of software
03:37:26 <quicksilver> Peaker: but to some extent that's true of all possibilities.
03:37:42 <erus`> whats the equivalent of [2:] in python?
03:37:56 <zygoloid> notostraca: and if i copy/paste some code, and someone modifies the original, i might want the modification in the pasted copy
03:38:04 <Peaker> quicksilver: It's easier to explain, enforce, and fix problems in the "no tabs whatsoever" policy
03:38:10 <quicksilver> Peaker: Yes.
03:38:24 <arw__> Peaker: then your primary problem is uneducated or undisciplined developers. or a lack of coding style rules.
03:38:25 <Peaker> And "configurable indent views" are overrated anyway
03:38:26 <lunaris> erus`: Assuming that takes a slice of a list from the second element, is it something like drop 2?
03:38:38 <notostraca> zygoloid, that sounds really nice... might be a good thing for me to try to work into a pet language
03:38:47 <erus`> lunaris: perfect thanks
03:39:02 <Peaker> arw__: And the lack of good tools to implement any policy involving tabs. Even if emacs has SmartTabs, eclipse/notepad++/VS/etc may not
03:39:03 <merijn> zygoloid: structural editors can do that :>
03:39:37 <notostraca> merijn, I haven't heard that term
03:39:44 <arw__> Peaker: your VCS can just refuse checkins. its not hard to configure.
03:39:44 <Peaker> arw__: The problem of uneducated/undisciplined developers + lack of coding style are HARD to solve (we have opinionated developers, and nobody can agree on a coding style)
03:40:26 <zygoloid> merijn: :D i would love to see a working system for an existing language with these properties
03:40:27 <Peaker> arw__: we talked about adding that, but then there are some guys who have to conform to an external project's policy of using tabs (some code is contributed back) so it became a bit of a pain to implement, so I think they didn't add it
03:40:34 <arw__> Peaker: yes. but dealing with developers and their different opinions and styles is not something a language should enforce. thats why i made the 'whitespace syntax is fascism'-statement above.
03:41:26 <Peaker> arw__: On the contrary -- uniformity is great. The problem was lack of uniformity (and other forms of incorrect use of tabs) to begin with
03:41:31 <notostraca> arw__, if someone's opinion and style is to use void pointers and casts exclusively in C++ code...
03:41:41 <arw__> Peaker: even with python you would have the questions of 'how many spaces?', 'where do we do line breaks?', 'do we use else or return?', etc.
03:41:53 <Peaker> arw__: Even if the language enforced tab use, but correct tab use (e.g Smart Tabs) that would be good (although it would make some editors unusable with the language)
03:42:09 <arw__> Peaker: it is almost impossible to design a language which can really enforce uniformity.
03:42:16 <Peaker> arw__: But any bit of uniformity helps
03:42:16 <notostraca> APL?
03:42:29 <notostraca> Lisp?
03:42:31 <merijn> zygoloid, notostraca: Peaker and dankna are both working on one, there was quite a nice python prototype showing what you can do with it :)
03:42:31 <ciaranm> ada! specification-mandated 3-space tabs
03:42:56 <Peaker> more of a mock-up than a prototype, it can't really edit almost at all :)
03:43:03 <Peaker> (nor can it save.. heh)
03:43:05 <notostraca> ciaranm, excellent
03:43:07 <merijn> Sssh :p
03:43:36 <zygoloid> merijn, Peaker: is there an integrated VCS? or is that still done via a text serialization?
03:43:53 <arw__> Peaker: thats untrue. there are many cases where enforced uniformity is just very annoying.
03:44:04 <Peaker> zygoloid: The Python mockup was just about showing how an ASG editor could present to screen something very similar to text editors
03:44:21 <notostraca> ciaranm, although Ada and Indentation Rules Are Fascism... and the DoD Mandate to Use Ada... this is so ripe for the picking, I'm not going to bother
03:44:23 <Peaker> zygoloid: the project I started more recently (and will [hopefully] soon resume) has integrated structural VCS
03:44:31 <Peaker> arw__: I've not encountered any :-)
03:45:07 <Peaker> arw__: I like Python's indent syntax, it enforces a lot of uniformity and makes random Python code more readable than random code in other languages that have crazy non-uniform styles
03:45:12 <arw__> Peaker: just as an example, many languages allow defining lists by some (a, b, c, d) syntax. many languages allow adding a trailing comma after element d, like (a, b, c, d,). some consider it a syntax error.
03:45:19 <haskelldude> hi, i need to small example for "operator overloading" in haskell
03:45:31 <haskelldude> *i need a
03:45:34 <Peaker> I like Haskell's case-sensitive names -- they make it easy to know for *sure* what's a constructor and what's not
03:45:36 <notostraca> hey haskelldude I think it shouldn't be to hard
03:45:52 <notostraca> *too
03:45:58 <arw__> Peaker: while considering it a syntax error enforces some uniformity, in reality it doesn't, because reordering (especially when operating on lines) becomes very painful.
03:46:09 <Peaker> arw__: Ah, good point -- uniformity there is kind of useless, as the extra comma has benefits but no readability impact
03:46:16 <quicksilver> I don't agree with that about reordering.
03:46:32 <quicksilver> in all the non-whitespace sensitive languages I've used, I'd alway reindent after re-ordering lines anyway
03:46:46 <quicksilver> so the fact that it actually *matters* doesn't change it - I'd be doing it anyway.
03:46:56 <erus`> > countIndent = length $ takeWhile (\c -> c == ' ' || c == '\t')
03:46:57 <lambdabot>   <no location info>: parse error on input `='
03:47:06 <Peaker> quicksilver: in Python, you can have [ \n   1, \n  2, \n  3, \n  ]       and it's easy to swap around any lines..  in Haskell the last one will not have a comma at the end, or the first one won't have a comma at the start
03:47:13 <haskelldude> notostraca can u pls show sm example
03:47:17 <erus`> > let countIndent = length $ takeWhile (\c -> c == ' ' || c == '\t') in countIndent "Hello"
03:47:18 <lambdabot>   Couldn't match expected type `[a]'
03:47:18 <lambdabot>         against inferred type `[GHC.Type...
03:47:30 <notostraca> haskelldude, http://www.haskell.org/tutorial/classes.html
03:47:42 <zygoloid> erus`: length . takeWhile...
03:47:47 <ciaranm> erus`: you don't mean $
03:47:48 <Peaker> > let countIndent = length . takeWhile (`elem` " \t") in countIndent "Hello"
03:47:50 <lambdabot>   0
03:47:51 <notostraca> You can make any funtion infix, if that's what you need
03:48:00 <notostraca> (well, any binary function)
03:48:27 <erus`> i dont know why i use $
03:48:27 <notostraca> (actually I'm not sure about that, disregard)
03:48:37 <nlogax> > let foo a b c = a + b + c in (1 `foo` 2) 3
03:48:38 <zygoloid> > (1 `id`) -- in ghc, any function at all
03:48:38 <lambdabot>   6
03:48:38 <lambdabot>   1
03:48:49 <lunaris> notostraca: Indeed, you can play tricks with currying to make any n-ary (n > 2) function a ``binary function'' :)
03:49:04 <notostraca> lunaris, of course, currying!
03:49:06 <Peaker> arw__: Some uniformity is useless, I agree.  A uniform indent syntax is very useful, as is a uniform naming convention. That's why I welcome any enforced convention by the language. Any convention is arbitrary anyway, the only important thing there is uniformity, and only a language can enforce comprehensive uniformity
03:49:09 <arw__> Peaker: and especially when considering the reordering of code, stuff like "move that block over there", whitespace-based languages suck. with everything else, i can just move that block and hit reindent.
03:49:16 <hpc> :t (1 `id`)
03:49:17 <lambdabot> forall t. (Num t) => t
03:49:35 <merijn> arw__: And why can't you do that in whitespace languages?
03:49:41 <Peaker> arw__: It's a mild disadvantage with editor support for the language
03:49:43 <lunaris> > let f a b c d = a + b + c +d in zipWith (2 `f` 3) [1..4] [5..8]
03:49:43 <lambdabot>   [11,13,15,17]
03:49:45 <osfameron> Peaker: version control commit hooks too ;-)
03:49:45 <merijn> I do that all the time in python...
03:49:46 <hpc> > let (x !!!) = fact x in (5 !!!)
03:49:47 <lambdabot>   <no location info>: Parse error in pattern
03:49:50 <hpc> bah
03:49:59 <arw__> merijn: not really, because the editor can't know on which indentation level the pasted code should belong.
03:50:08 <Peaker> osfameron: that only enforces it inside your project (and then only for commits going through your controls)
03:50:16 <Peaker> osfameron: you may still interface with 3rd parties/etc
03:50:18 <zygoloid> > let (!) 0 = 1; (!) x = x * ((x-1)!) in (10!)
03:50:19 <lambdabot>   3628800
03:50:29 <Peaker> osfameron: or (god forbid) have to read others' code :)
03:50:44 <zygoloid> hpc: the ghc extension only applies to expressions, not to patterns. ugly, huh? :)
03:50:58 <osfameron> Peaker: the horror!  the horror!
03:50:58 <arw__> Peaker: yes, you need an editor that understands the language, and even in that case there will always be cases where there are ambiguous situations the editor can't decide.
03:51:29 <haskelldude> thanks. i don't get the dfference between type and data. can
03:52:11 <Peaker> arw__: In emacs/python I just use a key that says move pasted block left/right
03:52:20 <notostraca> > let x `+/-` y = [x + y, x - y]
03:52:21 <lambdabot>   <no location info>: parse error on input `+/-'
03:52:42 <zygoloid> haskelldude: 'type' is just a way of introducing type-level sugar. 'data' defines new data types.
03:52:46 <notostraca> > let x `thing` y = [x + y, x - y]
03:52:47 <lambdabot>   not an expression: `let x `thing` y = [x + y, x - y]'
03:52:51 <lunaris> > let x +/- y = (x + y, x - y)
03:52:52 <lambdabot>   not an expression: `let x +/- y = (x + y, x - y)'
03:52:57 <lunaris> > let x +/- y = (x + y, x - y) in 3 +/- 4
03:52:57 <lambdabot>   (7,-1)
03:53:06 <arw__> Peaker: yes, but its useless extra work. in 'normal' languages, the position where i pasted the code is information enough.
03:53:22 <Peaker> arw__: you'd still re-indent it, of course
03:53:32 <notostraca> > x `+/-` y = (x + y, x - y)
03:53:33 <lambdabot>   <no location info>: parse error on input `+/-'
03:53:36 <Peaker> arw__: re-indenting is probably the same number of key strokes as "move left" or "move right"
03:53:50 <lunaris> notostraca: +/- is a symbol, and so treated implicitly like an operator
03:53:55 <notostraca> ah
03:54:07 <arw__> Peaker: of course. but there is no additional decision required, and no opportunity to break anything.
03:54:08 <lunaris> You're effectively trying to write the same as x `+` y, which is unnecessary for the same reason.
03:54:27 <arw__> Peaker: if i forget the reindent the code just looks ugly, but its not broken or does weird things
03:54:28 <lunaris> Backticks are only needed for functions that start with alphanumerics.
03:54:43 <notostraca> lunaris, excellent
03:54:47 <lunaris> You could also write:
03:54:50 <Peaker> arw__: it's not an additional decision -- either it fails to parse (then normal indent key stroke would work)  or it would be ambiguous -- then the decision whether to move-left or not is the same as the decision whether to paste before/after the "}"
03:54:55 <lunaris> > let (+/-) x y = (x + y, x - y) in 3 +/- 4
03:54:56 <lambdabot>   (7,-1)
03:55:01 <lunaris> But that's it
03:55:04 <notostraca> it is nice how Haskell is flexible about identifiers
03:55:07 <lunaris> Indeed.
03:55:18 <zygoloid> notostraca: you can use (+/-) to use an operatory-named thing prefix, just like you can use `foo` to use a identifiery-named thing infix
03:55:20 <lunaris> > let x `plusMinus` y = (x + y, x - y) in 3 `plusMinus` 4
03:55:21 <lambdabot>   (7,-1)
03:55:25 <Peaker> arw__: Code that looks ugly is broken in a way that's harder to detect than code that doesn't parse -- or that has big bugs
03:55:58 <arw__> Peaker: yes, but in the latter case i have to make that decision twice, consistently. if i don't, its a bug that i introduced by broken syntax.
03:56:14 <arw__> Peaker: and usually bugs introduced by syntax are something a language should avoid.
03:56:51 <lunaris> <cough>n+k</cough>
03:56:51 <arw__> Peaker: after all, thats why 'if (stuff) work();'-syntax is considered evil in C.
03:56:52 <Peaker> arw__: it's in the time-frame of a single second -- choosing where to paste + reindent, or choosing where to paste + move-left   is really the same amount of "choice"
03:57:16 <notostraca> Peaker, just use Ada's "don't use tabs" rule: a tab is 3 spaces.  This was devised after no one could decide on tab length being 2 or 4 spaces.
03:57:19 <arw__> Peaker: doesn't matter. bugs will happen. bugs cost money.
03:57:50 <arw__> Peaker: i'm off now, colleagues want to go to lunch :)
03:57:51 <arw__> bbl
03:59:29 <ski> (lunaris : s/needed/allowed and needed/)
03:59:37 <ski> merijn : istr hearing two or three persons here using only tabs for indentation in Haskell
04:06:42 <benmachine> ski: sounds painful
04:09:44 <ski> as long as you always break line after layout-introducing keywords, it should work ok
04:11:34 <erus`> hmm $ and . dont do the same thing
04:11:55 <ivanm> erus`: I'd hope not, since their types are different!
04:12:06 <ion> hmm, + and * don’t do the same thing.
04:12:46 <hpc> ion: you can't know that! they have the same type, and both form monoids over real numbers!
04:13:09 <hpc> :P
04:13:19 <erus`> :t .
04:13:20 <lambdabot> parse error on input `.'
04:13:30 <erus`> @type .
04:13:31 <lambdabot> parse error on input `.'
04:13:34 <erus`> @hoogle .
04:13:34 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
04:13:35 <lambdabot> Control.Category (.) :: Category cat => cat b c -> cat a b -> cat a c
04:13:35 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
04:13:37 <ion> :t (.)
04:13:37 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:13:45 <ion> :t (Prelude..)
04:13:46 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
04:14:11 <hpc> (λbot uses (.) = fmap)
04:17:07 <erus`> how can i call a function on a list and then call the same function with the return value
04:17:12 <erus`> over and over again
04:17:53 <lunaris> iterate?
04:18:00 <lunaris> > take 3 $ iterate (2*) [1..]
04:18:01 <lambdabot>   No instance for (GHC.Num.Num [t])
04:18:01 <lambdabot>    arising from a use of `e_1321' at <int...
04:18:06 <lunaris> > take 3 $ iterate (2*) [1::Int..]
04:18:07 <lambdabot>   <no location info>: parse error on input `Int..'
04:18:08 <erus`> iterate (drop 1) "Hello"
04:18:12 <lunaris> > take 3 $ iterate (2*) [(1::Int)..]
04:18:13 <erus`> > iterate (drop 1) "Hello"
04:18:13 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Int])
04:18:13 <lambdabot>    arising from the literal `...
04:18:14 <lambdabot>   ["Hello","ello","llo","lo","o","","","","","","","","","","","","","","",""...
04:18:24 <lunaris> Yea
04:18:25 <benmachine> > tails "Hello"
04:18:25 <lambdabot>   ["Hello","ello","llo","lo","o",""]
04:18:27 <lunaris> I'm an idiot.
04:18:30 <lunaris> > take 3 $ iterate (2*) 1
04:18:31 <lambdabot>   [1,2,4]
04:20:03 <erus`> i have a function parseToken :: [String] -> [Token]
04:20:19 <erus`> meh
04:23:33 <denebola> Is there a generally agreed upon tutorial/book/resource that teaches Haskell
04:23:44 <merijn> denebola: Learn You a Haskell
04:23:47 <merijn> @where lyah
04:23:47 <lambdabot> http://www.learnyouahaskell.com/
04:24:10 <denebola> thanks
04:24:48 <merijn> There's also the Try Haskell website and Real World Haskell book, but I think LYAH is a better start. RWH is a decent "real world" follow-up, though
04:26:11 <hpc> RWH is a lot closer to a "list of tutorials" than a tutorial itself
04:26:22 <JuanDaugherty> Is there a gromit that befuddles Haskell?
04:26:24 <hpc> need to learn a library? turn to the chapter
04:26:40 <hpc> imo, Try Haskell is a poor substitute for ghci
04:26:53 <JuanDaugherty> (wanted to see if it would parse that)
04:27:03 <merijn> hpc: Agreed, but it might get someone to the point of installing ghci
04:27:39 <denebola> I followed some link on haskell.org and I get the feeling this tutorial is kinda just quickly going over stuff because I get the feeling that I do not understand half of what it is saying (though admittedly LYAH was a link so I guess it was just bad luck in picking the link I did)
04:28:10 <merijn> denebola: A lot of Haskell tutorials tend(ed?) to be rather...obtuse
04:28:23 <Botje> 2/w 11
04:28:25 <Botje> oops
04:28:53 <merijn> LYAH is refreshingly easy to read for newcomers and I still refer to it occasionally since I don't write as much code as I should :p
04:29:49 <denebola> Well it seems silly to be, as you put it obtuse over the basics. I imagine you'd want that stuff to be concrete fundamentals
04:30:25 <erus`> element:list
04:30:31 <erus`> is there a list:element ?
04:31:02 <frerich> erus`: No, but you can write (rather inefficient) list ++ [element}
04:31:26 <frerich> erus`: If you do this repeatedly, it may be more efficient to prepend the elements and then reverse once, when you are done.
04:31:36 <erus`> ok fair enough#
04:34:00 <erus`> i don't know why people would use a lexer
04:34:04 <erus`> this is easy :)
04:35:32 <fasta> erus`: for efficiency.
04:36:06 <erus`> i have nearly the same functionality as my 200 lines of C++ in about 20 lines of haskell
04:36:14 <osfameron> LYAH is good indeed.  It manages to judge the cutesy distractions to about the right level, which some "amusing" technical books don't.
04:38:56 <quicksilver> osfameron: right level is pretty subjective.
04:39:06 <quicksilver> osfameron: works for me - I think LYAH is awesome.
04:39:28 <quicksilver> then again, by the time I read it I knew everything it was trying to teach, so I just thought "Yay! Cute caterpillar".
04:39:48 <erus`> the pictures look like rauld darl
04:39:51 <osfameron> yeah.  many people loved the poignant guide, whereas I just thought "fuck the cartoon foxes, when does he start talking about Ruby?" and then gave up
04:40:13 <Peaker> I have a coworker who didn't like humor in his Haskell intro.. :P
04:40:37 <Peaker> he basically said a "more boring" book would work :P
04:41:18 <benmachine> @remember quicksilver [on LYAH] by the time I read it I knew everything it was trying to teach, so I just thought "Yay! Cute caterpillar".
04:41:18 <lambdabot> Done.
04:41:45 <osfameron> LYAH is creative commons, right?  /me forks it and translates it into "Teach yourself Haskell: a guide for the humourless"
04:42:36 <Peaker> It was hard for me to stick to reading LYAH too as I'm past that stage too
04:45:37 <erus`> osfameron: lol
04:46:21 <quicksilver> osfameron: Disclaimer - in extreme cases of lack of humour, great good may not result.
04:54:19 <osfameron> quicksilver: heh
04:55:55 <ivanm> quicksilver: or if someone prefers an alternate type of humour?
04:56:13 <ivanm> I quite like the mathematically-oriented tutorials
04:56:19 <ivanm> but I am quite aware that I'm abnormal
05:02:14 <HalfWayMan> Quick question: Why does Data.Binary use decodeFloat rather than just storing the 32/64-bit form?
05:02:43 <bs338> it's sometimes nice to be portable
05:03:23 <HalfWayMan> bs338: Problem is that the devices I'm talking to don't have an understanding of the encoding of Integer.
05:03:48 <HalfWayMan> I could write one of course.
05:04:01 <Saizan> you shouldn't use the Binary class if you need to control the serialization format
05:04:08 <hpc> ByteString is the interface you should use for that
05:04:22 <Saizan> you can still use the Get/Put combinators though
05:04:37 <HalfWayMan> What should I use?
05:06:40 <HalfWayMan> I understand that Get/Put are just writer and state monads, but the Binary type class makes my life easier. Is there a suitable alternative?
05:08:02 <erus`> whats the default case in a case of statement
05:08:29 <erus`> if its default i will sound a bit silly
05:08:35 <mauke> none
05:08:41 <mauke> just use a pattern that always matches
05:08:57 <osfameron> 'otherwise' ?
05:09:11 <mauke> osfameron: no
05:09:20 <HalfWayMan> erus`: _ ->
05:09:25 <erus`> im matching a ' ', '"' or anything else
05:09:34 <erus`> thanks HalfWayMan
05:10:43 <osfameron> > let n = 3 in case n of { 1 -> "one"; 2 -> "two"; otherwise -> "a big number!" }
05:10:44 <lambdabot>   "a big number!"
05:11:06 <osfameron> ok, otherwise == True
05:12:05 <erus`> > let n = 3 in case n of { 1 -> "one"; 2 -> "two"; _ -> "a big number!" }
05:12:05 <lambdabot>   "a big number!"
05:12:17 <mauke> > let n = 3 in case n of { 1 -> "one"; 2 -> "two"; osfameron -> "a big number!" }
05:12:18 <lambdabot>   "a big number!"
05:12:29 <HalfWayMan> Hehe :)
05:12:36 <osfameron> eeek!
05:13:22 <osfameron> > otherwise
05:13:23 <lambdabot>   True
05:13:29 <HalfWayMan> Saizan: Would you suggest cereal as an alternative?
05:13:50 <osfameron> whereas presumably 'osfameron' there is just bound (successfully) to 3, so the case matches ?
05:13:59 <erus`> arg this is a brain treaser
05:14:25 <erus`> im writing a words function that also parses quotes correctly
05:14:37 <mauke> osfameron: just like 'otherwise'
05:14:40 <osfameron> I'm surprised ghc doesn't warn about the variable 'osfameron' only being used once
05:14:49 <osfameron> mauke: except that otherwise is bound to True
05:14:55 <mauke> osfameron: not in your example
05:15:04 <osfameron> mauke: well, it seems to be, by default
05:15:14 <osfameron> :t otherwise
05:15:15 <lambdabot> Bool
05:15:18 <mauke> > let osfameron = True in let n = 3 in case n of { 1 -> "one"; 2 -> "two"; osfameron -> "a big number!" }
05:15:19 <lambdabot>   "a big number!"
05:15:19 <osfameron> and also in my gci
05:15:24 <osfameron> *ghci
05:15:33 <mauke> irrelevant, your example doesn't use that 'otherwise'
05:15:35 <ion> He said "hi, did you say 'I'll come back after the machine days "beep"'?" or something along those lines.
05:19:00 <erus`> is there a not element of ?
05:19:27 <mauke> see hoogle
05:19:41 <Botje> notElem
05:19:42 <erus`> @hoogle a -> [a] -> Bool
05:19:42 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
05:19:42 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
05:19:42 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
05:19:47 <erus`> haha
05:21:11 <osfameron> mauke: aha, I see, I think
05:21:18 <azaq23> osfameron: otherwise is the idiomatic choice for something which always matches in an if-then-else context; so, for example, for guards. case statements though pattern match, and if you just use a variable for the match, the value just gets bound to it and the pattern matches
05:21:22 <osfameron> > let otherwise = False; n = 3 in case n of { 1 -> "one"; 2 -> "two"; otherwise -> "a big number! " ++ (show otherwise) }
05:21:23 <lambdabot>   "a big number! 3"
05:21:36 <osfameron> so the outer binding is irrelevant
05:21:41 <azaq23> yes
05:21:46 * osfameron is enlightened, slowly, and no doubt partially
05:21:52 <Peaker> @type not :. elem
05:21:53 <lambdabot> Not in scope: data constructor `:.'
05:21:57 <Peaker> @type not .: elem
05:21:58 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
05:22:22 <azaq23> > case True of { False -> ""; (name @ True) -> show name }
05:22:23 <lambdabot>   "True"
05:24:28 <azaq23> > let f n | n > 0 = "Greater than zero" | otherwise = "Nope" in (f 3, f $ negate 3)
05:24:29 <lambdabot>   ("Greater than zero","Nope")
05:26:07 <nus> > let f n | n > 0 = "Greater than zero" | otherwise = "Nope" in (f 3, f $ negate undefined)
05:26:08 <lambdabot>   ("Greater than zero","*Exception: Prelude.undefined
05:27:38 <ion> > let f ((\x -> let g x | x > 0 = "Greater than zero" | otherwise = "Nope") -> y) = y in f 3
05:27:39 <lambdabot>   <no location info>: parse error on input `)'
05:29:23 <ion> > let f ((\x -> let g y | y > 0 = "Greater than zero" | otherwise = "Nope") -> z) = z in f 3
05:29:24 <lambdabot>   <no location info>: parse error on input `)'
05:29:38 <ion> err
05:29:53 <ion> > let f ((\x -> let g y | y > 0 = "Greater than zero" | otherwise = "Nope" in g x) -> z) = z in f 3
05:29:54 <lambdabot>   "Greater than zero"
05:30:45 <palalach> ping
05:33:01 <palalach> ping #haskell
05:33:28 <Saizan> pong?
05:33:38 <arw__> > pong "never ask to ask"
05:33:39 <lambdabot>   Not in scope: `pong'
05:36:00 <palalach> help set
05:36:26 <palalach> userllist
05:40:27 <erus`> wtf
05:40:32 <erus`> cmd line irc
05:46:34 <erus`> in google+ can you put people in circles without them seeing?
05:46:51 <erus`> then you could filter people by race and make racist jokes as much as you like :)
05:47:55 <benmachine> erus`: you know, I've never actually wanted to do that
05:48:57 <quicksilver> people do not find out which circle they are in unless you tell them.
05:49:30 <benmachine> or unless they look over your shoulder at an inopportune moment
05:49:45 <benmachine> or unless google accidentally the whole privacy
05:50:39 <quicksilver> benmachine: (again)
05:50:46 <benmachine> :P
05:58:10 <arcatan> yes, jokes about racists, they're the best!
06:02:38 <notostraca> erus`, make racist jokes all you like, but share them with a circle that consists only of your boss and his bosses
06:03:16 <froztbyte> or ideally of yourself only
06:03:20 <froztbyte> racism ftl :(
06:03:58 <froztbyte> s/of/with/
06:04:16 <benmachine> froztbyte: is it ok to be awful if you're awful in secret? :P
06:04:34 <tgeeky> benmachine: aren't we all? :O
06:04:42 <benmachine> tgeeky: are we all ok?
06:04:55 <tgeeky> awful in secret :o
06:04:59 <tgeeky> that's the message I got, at least
06:05:23 <benmachine> tgeeky: that doesn't mean it's ok, is what I meant :P
06:05:39 <tgeeky> benmachine: oh, yeah.
06:06:02 * benmachine is publically awful at clarity of communication
06:06:13 <tgeeky> now being awe-full
06:06:22 <froztbyte> benmachine: I'd say that if someone intends to be a dick^W^W^Wcontinue racist jokes, then keeping those jokes to themselves is a better option than spreading the crap around
06:06:26 <tgeeky> reverence I think is accepted
06:06:48 <tgeeky> froztbyte: like chain email. If you are so internally dirty that you *do* like them, like them and delete them :O
06:06:51 <erus`> i make jokes about froztbyte dont be over sensitive
06:06:58 <froztbyte> lesser of evils, all that
06:06:59 <benmachine> froztbyte: well, maybe. if they spread it around we know that they're awful and can avoid them/fix them
06:07:17 <haskelldude> hi, how to check if a string is empty is IO?
06:07:19 <froztbyte> benmachine: people don't like being told they're wrong
06:07:29 <froztbyte> so "fixing" them is a more difficult option
06:07:29 * hackagebot toolshed 0.11.1.0 - Utilities used by other packages.  http://hackage.haskell.org/package/toolshed-0.11.1.0 (AlistairWard)
06:07:54 <benmachine> froztbyte: true, but it's pretty cool if you manage it
06:08:05 <erus`> there is a difference between laughing at a stereotype and treating someone differently because they are different
06:08:17 <azaq23> haskelldude: "null s" or s == "" checks for emptiness; what do you mean by "is IO"?
06:08:24 <froztbyte> benmachine: aye, that I can agree with
06:08:29 <froztbyte> erus`: that too
06:08:29 * hackagebot squeeze 1.0.1.4 - A file-packing application.  http://hackage.haskell.org/package/squeeze-1.0.1.4 (AlistairWard)
06:08:32 <ciaranm> erus`: you sound fat
06:08:39 <tgeeky> lolol
06:08:45 <erus`> im a bit on the skinny side
06:08:47 <froztbyte> erus`: but the levels reasons of motivation, etc, all come into play
06:08:56 <tgeeky> "you sound fat" -- delicious
06:09:06 <tgeeky> man
06:09:08 <haskelldude> azaq23 a small typo. "in IO"
06:09:10 <tgeeky> some of you people have cool names
06:09:15 <tgeeky> Alistair Ward? how awesome.
06:09:17 <benmachine> haskelldude: what do you mean by in IO :P
06:09:56 <benmachine> tgeeky: but yours is a secret? :O
06:09:58 <azaq23> haskelldude: You mean you've got a IO String and want a IO Bool? Use liftM / fmap
06:09:59 <benmachine> I bet it's not cool
06:10:09 <tgeeky> benmachine: mine's boring: Drew Day
06:10:10 <azaq23> @type liftM null (m :: IO String)
06:10:11 <lambdabot>     Couldn't match expected type `IO String'
06:10:11 <lambdabot>            against inferred type `Expr'
06:10:11 <lambdabot>     In the second argument of `liftM', namely `(m :: IO String)'
06:10:19 <tgeeky> it's alliterative (but only my nickname)
06:10:19 <benmachine> tgeeky: those are both dictionary words, that's pretty cool
06:10:26 <tgeeky> i suppose
06:10:38 <benmachine> in fact it's *almost* a sentence :P
06:10:44 <azaq23> @type \m -> liftM null (m :: IO String)
06:10:45 <lambdabot> IO String -> IO Bool
06:10:46 <tgeeky> and I can make corny jokes about phrases like "it's a beautiful day"
06:10:54 <benmachine> yeah
06:10:58 <benmachine> you have *scope*
06:11:01 <exeter> naive question. I'm using winGhci and typing (6 + 9.4). The result shown is correct (15.4) but I wonder. How and where happens the implicit conversion? I've read the class interface ( Num ) but still have no clue.
06:11:14 <tgeeky> and my nickname is d-day! :o
06:11:20 <Botje> exeter: 6 has type Num a => a
06:11:20 <zygoloid> tgeeky: you sound like a Stan Lee character :)
06:11:23 <Botje> :t 9.4
06:11:24 <lambdabot> forall t. (Fractional t) => t
06:11:30 <Botje> exeter: note how 9.4 is Fractional.
06:11:42 <tgeeky> zygoloid: could be worse. I could be a Spike Lee character.
06:11:46 <zygoloid> haha :)
06:12:18 <erus`> well my sirname is cumming
06:12:27 <erus`> so i have ups and downs
06:12:54 <erus`> if i had a bigger willy i could be a pornstar and wouldnt need to change my name
06:13:47 <benmachine> exeter: the way numeric literals work is that writing 6 in the source file is actually 'fromInteger 6' (where *that* 6 is of type Integer)
06:13:47 <Botje> exeter: + requires both arguments to be the same type, so both 9.4 and 6 have type (Fractional a, Num a) => a
06:14:07 <Botje> @instances Fractional
06:14:08 <lambdabot> Double, Float
06:14:12 <exeter> mmhhhhhhhhhhhhhhhhhhhhhhhhh
06:14:15 <benmachine> and 9.4 is fromRational 9.4
06:14:24 <exeter> fromInteger
06:14:25 <exeter> ok
06:14:48 <benmachine> type defaulting will kick in and decide to use Double for the whole expression
06:15:37 <benmachine> exeter: the key thing is that if you have n :: Integer and m :: Double, n + m won't convert anything, it'll just fail to typecheck
06:15:39 <exeter> benmachine: that's quite an handy feature. Is it valid only for numeric literals? Or could I use it for my types too?
06:15:56 <benmachine> exeter: only numeric literals have anything implicit going on
06:16:04 <exeter> cool
06:16:12 <benmachine> otherwise you have to make the conversions explicit
06:16:22 <exeter> I liked c++ but disliked when it did something behind my back
06:16:29 <benmachine> yeah, likewise
06:16:35 <benmachine> well
06:16:37 <benmachine> I didn't like c++
06:16:49 <benmachine> but I especially didn't like it when it converted things without telling me :P
06:16:59 <ciaranm> no-one likes c++. it's just that there are times when nothing else can do the job at all...
06:17:07 * zygoloid likes c++
06:17:15 * zygoloid dons flame-proof armour
06:17:22 <ciaranm> then you haven't used it enough!
06:17:38 <benmachine> ciaranm: everyone's used c++ enough :P
06:17:40 <zygoloid> ciaranm: i hack on a c++ compiler. written in c++. next question?
06:17:41 <ciaranm> heh
06:17:43 <quicksilver> you fail to appreciate quite how twisted zygoloid is ;)
06:17:54 <ciaranm> although c++0x will be quite a bit nicer if it's ever implemented anywhere
06:17:58 <Ke> ghc does loads of unsandboxable system calls behind your back
06:18:03 <zygoloid> ciaranm: now on /that/ point i disagree
06:18:18 <zygoloid> it'll be nice if the implementers agree on the correct way to misimplement it
06:18:26 <zygoloid> as specified, it's a disaster
06:18:43 <exeter> thanks for the explanation, I go back plotting to conquer the world
06:20:39 <quicksilver> zygoloid: it's a bunch of good ideas which are being turned into a standard by a committee
06:20:54 <quicksilver> zygoloid: ... building on a language which is already much more complex than it wants to be.
06:20:59 <quicksilver> zygoloid: what could possibly go wrong?
06:21:14 <ciaranm> reality is complex
06:25:57 <zygoloid> quicksilver: it's a bunch of unimplemented formal wording for untested features with unknown interactions
06:26:24 <zygoloid> the haskell standardization model is much better here: implement first, then standardize!
06:26:39 <merijn> zygoloid: Sounds like...every freaking committee standard I ever encountered :>
06:27:07 <merijn> zygoloid: I think that only works so well because no one cares about anything other then GHC :p
06:28:05 <zygoloid> some of the haskell' proposals have been implemented only in jhc iirc
06:32:27 <quicksilver> quite a lot of haskell2010 was implemented in hugs
06:32:32 <quicksilver> some of it was implemented there first
06:32:49 <quicksilver> zygoloid: yes, although aren't quite a few features implemented in g++?
06:33:58 <ciaranm> http://gcc.gnu.org/projects/cxx0x.html just not some of the fun ones
06:34:36 * ciaranm suspects user defined literals will get hairy...
06:35:04 <quicksilver> there are not many things on that list I would not expect to get hairy
06:35:13 <quicksilver> I suppose hairtolerance varies
06:35:30 <ciaranm> you can't comb a hairly language flat
06:36:28 <notostraca> user defined literals could be wonderful, I mean hashes/maps/dictionaries right now...
06:36:30 <zygoloid> quicksilver: some of them are. some of them are incorrectly implemented in g++. some of them have not been implemented in any compiler.
06:37:26 <quicksilver> ciaranm: actually, you can if you can embed the language on a torus
06:37:33 <quicksilver> toroidal compilation ftw.
06:37:57 <zygoloid> ciaranm: user-defined literals are a nice idea. it's a shame about the wording. all the nice suffices are reserved for future standardization
06:38:03 <ville> zygoloid: I am not sure how familiar you are with the C++ standardization but they do actually require a working implementation
06:38:16 <zygoloid> ville: that is not true.
06:38:18 <ciaranm> ville: there's no working implementation of about half of 0x
06:38:43 <zygoloid> ville: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3250.html
06:38:53 <zygoloid> this proposal was voted down for the FDIS
06:39:37 <zygoloid> ciaranm: it's much less than half these days :)
06:39:42 <ville> require/prefer whatever the wording was when proposals were asked
06:41:56 <zygoloid> so haskell's LANGUAGE pragma is an excellent idea, and whoever came up with it deserves karma :)
06:42:44 <dankna> the LANGUAGE pragma is fantastic
06:45:25 <mokus> LANGUAGE_pragma++
06:46:52 <Peaker> zygoloid: it's essentially the same as "from __future__" in Python
06:47:13 <Peaker> I guess every language ends up adding one like that :)
06:47:39 <ion> from __future__ import haskell
06:48:37 <mokus> I'd settle for "from __future__ import staticTypes"
06:49:09 <benmachine> haha
06:49:09 <tibbe> mokus, you'd also need from __future__ import camelCase
06:49:15 <mokus> heh, true
06:49:30 <mokus> been a while since i did any python, forgetting the conventiens i guess
06:49:35 <tibbe> :)
06:50:00 <mokus> i do remember that "from __future__ import braces" is a syntax error though
06:50:21 <zygoloid> error: never gonna happen iirc
06:50:29 <mokus> yea, something like that
06:50:37 <zygoloid> SyntaxError: not a chance
06:51:31 <monadic> mokus: And they say python is well designed... Naming modules with annoying underscores
06:51:52 <mokus> well, as long as it's consistent things like that don't bother me much
06:52:06 <merijn> monadic: __future__ is not a module, though so that hardly counts
06:52:06 <mokus> took me a while to get used to camel case the first time i was exposed to it
06:52:19 <monadic> mokus: What about len(list) instead of list.length() in an OOP language? :D
06:52:20 <zygoloid> monadic: And they say haskell is well designed... Naming unused function parameters with annoying underscores
06:52:20 <mokus> oh, you're talking about the __
06:52:35 <merijn> The entire reason __future__ has underscores is because __ mean magic in python
06:52:42 <monadic> zygoloid: But those ones aren't annoying :D
06:52:42 <mokus> well, I did say I haven't used python lately ;)
06:52:45 <Iceland_jack> merijn: __ means magin in real life as well
06:53:02 <sipa> what does this __future__ mean?
06:53:10 <monadic> merijn: __future__ is a real module, and serves three purposes: - from python.org
06:53:31 <merijn> monadic: It also extends the interpreter, which are modules cannot
06:53:47 <mokus> sipa: it's python's version of {-# LANGUAGE ... #-}
06:53:58 <merijn> sipa: It is a way to load future enhancements into the interperter kinda like LANGUAGE pragma's
06:54:08 <sipa> i see
06:55:00 <merijn> For example, there was a switch in division behavior (dividing ints switching to returning a float instead of returning an int), "from __future__" lets you utilize that before the release were it becomes the standard behavior
06:55:54 <merijn> monadic: You could do "from __future__ import division" (or something similar to that) to switch the behaviour of division, normal modules cannot do this sort of thing
06:56:43 <monadic> merijn: It is a module though, it just has special behavior embedded in the interpreter... See docs.
06:58:15 <monadic> Hmm, now I want to submit a patch to the python mailing list that enables braces ;)
06:58:51 <mokus> monadic: pretty sure it'd just be rejected - i assume guido has final say on what patches go in, and i've heard he's pretty passionately against it
06:59:23 <dylukes> So, is there really no python/ruby-esque language with static typing?
06:59:35 <mokus> monadic: you could maintain your own fork though, if it came down to that ;)
06:59:49 <mokus> tracking the mainline, with the only difference being support for braces
06:59:51 <merijn> dylukes: There is a reason for that, though
07:00:06 <dylukes> merijn: Freemason agenda?
07:00:14 <merijn> dylukes: I started designing one, but came to the conclusion I was designing the IO monad and might as well write Haskell instead
07:00:34 <Botje> dylukes: you can retrofit gradual typing onto python & ruby
07:00:36 <dylukes> Not pure, just statically typed.
07:00:50 <merijn> dylukes: Yes, I know. That was my plan
07:01:03 <merijn> But statically typed python is essentially just the IO monad
07:01:04 <Botje> i'm doing exactly that for our own language
07:01:05 <quicksilver> dylukes: scala?
07:01:26 <dylukes> quicksilver: Not really a "scripting" language per say… idk...
07:01:32 <dylukes> It's something different.
07:01:40 <notostraca> CoffeeScript?
07:01:41 <quicksilver> IME, "scripting" doesn't mean anything
07:01:56 <dylukes> I guess I learned PPR like languages.
07:01:58 <mokus> timber/OOHaskell have an interesting record system which seems like it could be a good fit for a "static duck typing" system
07:01:58 <quicksilver> I would say scala is a bit like python/ruby/javascript in feel, but has static typing.
07:01:58 <dylukes> meant*
07:02:12 <dylukes> quicksilver: It feels a bit different to me personally.
07:02:15 <mokus> not sure if those are still alive though
07:02:20 <monadic> scripting language doesn't really mean anything at all, all programs are scripts if you ask me
07:02:42 <notostraca> with Typed Racket and custom syntax, well...
07:03:17 <parcs> cython is sorta static
07:09:15 <notostraca> oh! haXe
07:09:50 <notostraca> haXe is similar to Scala, but can compile to dynamic languages, oddly enough -- but it is statically typed
07:12:01 <notostraca> https://github.com/jashkenas/coffee-script/wiki/List-of-languages-that-compile-to-JS
07:13:37 <notostraca> holy... you can use the LLVM backend for haskell and make it into JS https://github.com/kripken/emscripten/wiki
07:14:51 <luite_> notostraca: you still need to translate the rts
07:15:23 <notostraca> luite_, ?
07:16:58 <luite_> notostraca: it's written in C, and probably uses some system calls and other things that would take some work to run properly in javascript
07:17:18 <quicksilver> luite_, notostraca : but there are some working projects to compile haskell to JS
07:17:24 <luite_> yeah
07:17:31 <luite_> but not "production" :)
07:17:44 <quicksilver> I think this is the most recently worked on https://github.com/sviperll/ghcjs
07:19:24 <dylukes> When did we establish JS as the de-facto web language.
07:19:35 <dylukes> I'd honestly be happier if we just said "sandboxed JVM" or "sandboxed CLR"
07:19:45 <dylukes> javascript is a bit painful, and the DOM shit is maddening sometimes.
07:19:55 <dylukes> It has some good parts, but...
07:20:15 <luite_> but compiling haskell to javascript doesn't have much to do with the dom
07:21:30 <dylukes> I'm not talking about hs->js.
07:22:28 <luite_> dunno if JVM is much better
07:23:17 <saati> back when it became the default there was no clr and the jvm was not a usable piece of software
07:23:26 <luite_> though the byte code format is probably specified better and changes less
07:24:20 <dylukes> Nonetheless, I think a unified byte code format (maybe with a DOM feature set built in) would be pretty good.
07:24:44 <luite_> and sandboxed x86 like google is trying to do?
07:24:51 <parcs> +
07:25:16 <dylukes> luite_: ?
07:25:29 <dylukes> idk, I guess it would end up probably being some sort of register machine.
07:25:36 <dylukes> I'd imagine something that could be easily "mapped" to ARM/x86.
07:25:48 <luite_> dylukes: http://code.google.com/chrome/nativeclient/
07:25:57 <dylukes> but with some sort of 'domload' instructions and dom registers that point to dom elements.
07:26:06 <dylukes> Ah right, NaCL
07:26:48 <luite_> dom registers, really?
07:26:58 <quicksilver> I'm not sure a common bytecode format has compelling advantages over javascript (as a compilation target)
07:27:06 <dylukes> oh well.
07:27:22 <quicksilver> javascript already runs rather efficiently on several different hardware platforms
07:27:32 <quicksilver> and there are people with a vested interest in keeping it running as fast as it can.
07:27:57 <dylukes> It just seems to be an awkward compilation target.
07:28:15 <dylukes> idk, I'm not speaking from experience in that regards.
07:28:19 <dylukes> I'm going to go get back to work.
07:29:04 <duobei> Aha, I'm going to bed.
07:31:16 <duobei> It seems there are less people care about the speed of running.
07:32:26 <ocharles> Who wants to play the compose-the-functions game with me! https://gist.github.com/1078098 is what I have atm
07:32:43 <ocharles> I don't like it atm, with the whole shadowing of the book variable and I'm sure there's some way I can cleverly compose this together
07:32:47 <ocharles> but I haven't quite worked it out yet
07:33:31 <Botje> (just call it book' ? )
07:33:44 <ocharles> right, but that's going around the solution I'm aiming for
07:33:50 <monadic> ocharles: That code doesn't make sense, its not even monadic but you are using do notation
07:34:22 <ocharles> it's very slightly tweaking from the code that actually builds
07:34:32 <erus`> can i check if a string is an int?
07:34:35 <monadic> ocharles: Or is Model itself a monad?
07:34:37 <erus`> like readMaybe?
07:34:42 <ocharles> monadic: Model is a monad
07:35:06 <ocharles> monadic: https://gist.github.com/1078098 updated with the full code below the snippet
07:35:23 <ocharles> but I only want to focus on the book loading stuff for now, the rest can be cleaned up later
07:35:26 <quicksilver> ocharles: >=> composes functions of the form 'a -> m b'
07:35:37 <parcs> erus`: readS or readMay from the 'safe' package
07:36:10 <quicksilver> ocharles: but since you use the 'book' twice in the second line it's probably easiest to name it.
07:36:29 <ocharles> quicksilver: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#v:-62--61--62- says it ends up (a -> m c), but I guess a and c can be the same typ?
07:36:44 <ocharles> quicksilver: indeed, the reference to book twice seems to be the problem
07:37:15 <quicksilver> ocharles: yes. whenever you have two different type variable they *can* be the same type, of ource.
07:37:22 <ocharles> just checking
07:37:34 <quicksilver> ocharles: otherwise you couldn't use the normal (.) to compose functions of type Int -> Int.
07:37:41 <ocharles> oh yea
07:37:51 <quicksilver> anyhow I'm not sure you have a problem as such
07:38:00 <quicksilver> it's just that when you use somethign twice it's generally nicest to name it
07:38:01 <ocharles> but I don't have any functions that are a -> m b. only a -> m a, and b -> m b, along with a -> b
07:38:24 <fenris_kcf> hy. how can i assert something when defining something with "instance"? example: i want to instanciate Show for a defined data, then uses the type "a". in order to implement my show-function for this data, there must exist a show-function for the type "a"
07:38:30 <ocharles> quicksilver: if you look at L32 on the paste, you'll see I already have the book variable
07:38:32 <dylukes> Consider a function that takes an number, and returns Just n if it's positive, and Nothing otherwise.
07:38:45 <ocharles> oh actually, I guess it gets replaced, so the book on L33 isn't the same book
07:38:47 <dylukes> or, Just True if its positive.
07:38:48 <quicksilver> ocharles: I know you do.
07:38:54 <dylukes> (contrived example, but for whatever reason)
07:38:59 <fenris_kcf> instance Show (MyType a) where ...
07:39:12 <fenris_kcf> "(Show a) =>" somewhere ?
07:39:17 <quicksilver> ocharles: I'm saying that I don't find anything particularly wrong with your code :)
07:39:19 <merijn> fenris_kcf: "instance Show a => Show (MyType a) where.." (if I remember the syntax right)
07:39:53 <ocharles> quicksilver: ok :) To me I have some worries for how things might look in the future, but I can get to that when it becomes a problem then!
07:40:44 <ocharles> for example having to load editionFormat, editionLanguage, editionCountry, and so on, but I think that won't come out as bad as I'm worrying
07:40:58 <erus`> parcs: can you show me a quick example
07:41:13 <fenris_kcf> merijn: thx, looks like this works just fine
07:41:21 <erus`> let isInt str = reads str :: Int
07:41:47 <parcs> :t reads
07:41:47 <lambdabot> forall a. (Read a) => String -> [(a, String)]
07:42:29 <parcs> > reads "4" :: [(Int, String)]
07:42:30 <lambdabot>   [(4,"")]
07:42:36 <parcs> > reads "u" :: [(Int, String)]
07:42:37 <lambdabot>   []
07:42:57 <erus`> cool thanks
07:43:59 <ocharles> quicksilver: while you're around and you've seen the code, I shouldn't be worried about the multiple case statements either?
07:44:08 <ocharles> It felt like my code was marching off a little bit
07:44:24 <ocharles> I'm probably trying to factor that out too soon before I see the real patterns in their though (like 404 on Nothing, etc)
07:46:14 <quicksilver> ocharles: yes, the nested cases on Maybes look slightly nasty
07:46:30 * ocharles nods
07:46:33 <quicksilver> ocharles: but how you solve them depends how the Controller monad works, which I don't know ;)
07:46:49 <quicksilver> so I opted not to comment on something I didn't know the answer to.
07:47:30 <quicksilver> you could refactor the whole thing to run inside ErrorT Something Controller, and 'throw exceptions' out which generate your error pages in some consistent way
07:47:36 <ocharles> quicksilver: not much special there, it's just to limit IO/play with Snap https://github.com/ocharles/BookBrainz/blob/master/src/BookBrainz/Types/MVC.hs
07:47:45 <quicksilver> but then you'd have to lift the nortmal controller actions.
07:47:57 <quicksilver> so it might not have a good power/weight ratio
07:48:35 <quicksilver> ocharles: oh, it's under your control?
07:48:39 <ocharles> yea
07:48:45 <quicksilver> in that case I'd consider adding exception support to it
07:49:25 <ocharles> what should I read about to learn about that? Control.Exception?
07:49:28 <quicksilver> no
07:49:33 <quicksilver> not those kinds of exceptions
07:49:39 <quicksilver> I mean adding ErrorT into the definition
07:49:48 <ocharles> oh, ok
07:50:04 <ocharles> I wasn't sure if that was only if I didn't have control of Controller
07:50:14 <quicksilver> what this means is that your 'runController' might return "Left ...some description of error page.."
07:50:27 <quicksilver> and if it does your harness (whatever is calling runController)
07:50:32 <quicksilver> should build the error page
07:50:45 <ocharles> indeed, that's pretty nice
07:50:56 <quicksilver> that would get rid of the nested cases
07:51:00 <quicksilver> instead you'd have something like
07:51:00 <ocharles> yea
07:51:12 <erus`> can i catch error's ?
07:51:18 <ocharles> And Left could be a function of some sort too probably, to give me either more flexibility
07:51:22 <quicksilver> gid <- maybeGid `onError` (400,"InvalidBBID")
07:51:39 <quicksilver> and the code would just continue as if gid existed
07:51:50 <quicksilver> (if the error happens the code beyond them doesn't execute)
07:51:59 <quicksilver> onError I just made up, you'd have to define it
07:52:12 * ocharles nods
07:52:21 <ocharles> pretty slick
07:52:25 <quicksilver> it's not the right name
07:52:35 <quicksilver> `onNothing` would be better
07:52:40 <ocharles> well, this is handwaving for now until I write code
07:52:47 <ocharles> but I certainly get the gist of what you propose
07:52:50 <quicksilver> in fact, you'd tie it into the previous action
07:53:08 <quicksilver> gid <- (fromString . unpack . fromJust) <$> getParam "gid" `onNothing` (400,"InvalidBBID")
07:53:15 <quicksilver> eliminate 'maybeGid' and the case both.
07:53:31 * ocharles nods
07:53:46 <ocharles> doesn't that need a fromJust too?
07:53:55 <ocharles> Assuming onNothing returns Just gid if it's not Nothing
07:54:04 <ocharles> or would it unwrap out of Maybe too
07:54:15 <quicksilver> it unwraps
07:54:24 <quicksilver> the Nothing case throws the exception
07:54:30 <ocharles> yea
07:54:33 <ocharles> cool, makes sense :)
07:54:34 <quicksilver> so if the exception isn't through --- you definitely have  Just, which is auto-unwrapped
07:54:39 <quicksilver> s/through/thrown/
07:54:55 <EvanR> hows gtk2hs for windows
07:55:19 <dcoutts> EvanR: I've used it for commercial projects on windows without any real problems
07:55:23 <erus`> i prefer throw/catch in C++
07:55:29 <ciaranm> in Pearls of Functional Algorithm Design there's code that uses the slashed curly-E "not member of a set" symbol as an operator. is that just something fancy they've done when typesetting the book?
07:56:05 <Twey> ciaranm: Maybe, but it's valid Haskell too
07:56:46 <Twey> > let (∉) = notElem in 5 ∉ [1, 2, 3]
07:56:47 <lambdabot>   True
07:56:50 <ocharles> ciaranm: http://hackage.haskell.org/packages/archive/containers-unicode-symbols/0.3.0.2/doc/html/Data-Set-Unicode.html
07:57:08 <EvanR> dcoutts: did lgpl result in you having to release the code?
07:57:09 <ciaranm> interesting, thanks
07:57:21 <ciaranm> does that mean i can use a unicode snowman as an operator
07:57:26 <merijn> ciaranm: Yes
07:57:34 <merijn> Actually, not sure
07:57:35 <ocharles> heh
07:57:39 <dcoutts> EvanR: not the code of the proprietary app, but yes obviously the code of gtk2hs itself
07:57:40 <Twey> Yes, pretty sure
07:57:43 <erus`> lets all write code in APL or whatever its called
07:57:44 <merijn> Depends whether it counts as a letter or not
07:57:56 <merijn> (i.e. which unicode page it is defined on)
07:57:58 <EvanR> dcoutts: did you statically link your final product and it used gtk?
07:58:04 <dcoutts> EvanR: yes
07:58:06 <EvanR> doesnt that make the whole thing lgpl
07:58:08 <Twey> > let (☃) = elem in 3 ☃ [1, 2, 3]
07:58:08 <lambdabot>   True
07:58:10 <ciaranm> can't use a snowman in java since java only allows "letters" in identifiers, and doesn't support operators
07:58:21 <ciaranm> i've always wanted to use a snowman for something
07:58:31 <Twey> I'm not sure what you would use it for, though :þ
07:58:36 <dcoutts> ciaranm: the "good taste" guide hasn't really caught up with unicode operators yet. Most Haskell programmers don't use them (yet)
07:58:41 <merijn> Guess it is an operator character :)
07:58:57 <merijn> dcoutts: Mostly because input is usually inconvenient I guess
07:59:05 * ocharles uses skull & cross bones for his error operator, discussed above
07:59:10 <dcoutts> ciaranm: and historically the typesetting you see in papers doesn't carry over into real code
07:59:15 <ciaranm> typeset haskell looks really pretty
07:59:31 <EvanR> eww type setting
07:59:40 <EvanR> s/e s/es/
07:59:41 <dcoutts> ciaranm: we've got lhs2tex to thank for that
07:59:42 <dylukes> I use them often actually.
07:59:55 <dylukes> The thing is, I wish there was some sort of "programmer" keyboard.
08:00:15 <dcoutts> ciaranm: are you looking into using Haskell these days then? not for paludis surely ;-)
08:00:19 <dylukes> With easier Unicode input. atm I just use the Unicode OS X input method (kind of like windows U-num sequence)
08:00:42 <ocharles> dylukes: M-x set-input-method tex
08:00:49 <ciaranm> dcoutts: naah, uni stuff. c++ is getting in my way.
08:00:53 <dcoutts> ciaranm: you may be interested to know that we're working on a new package constraint solver ourselves
08:01:00 <dcoutts> ciaranm: ah right, ok
08:01:04 <dylukes> ocharles: Yeah, that or agda-input
08:01:06 <quicksilver> dylukes: http://www.artlebedev.com/everything/optimus/
08:01:08 <ciaranm> i'd not use haskell for *doing* stuff :P
08:01:09 <ocharles> yea, or that
08:01:12 <dylukes> quicksilver: I saw those :P
08:01:15 <dcoutts> ciaranm: hah :-)
08:01:47 <ciaranm> i'd like to be able to type x `snowman` y and have that typeset as x ☃ y automatically. that'd be neat.
08:01:49 <dylukes> Too bad Optimus seems to be… "dead"
08:01:52 <applicative> dylukes, is there some input method that works in ghci on os x?
08:01:55 <dylukes> The Tactus has gone no where :<
08:01:58 <dcoutts> ciaranm: you can do that with lhs2tex
08:01:59 <merijn> dylukes: That's actually the reason I don't use unicode, I wish OSes supported inputting unicode via latexcodes :>
08:02:02 <dylukes> applicative: Sure, the Unicode one.
08:02:11 <dylukes> merijn: You could probably add the input method to OS X...
08:02:16 <EvanR> dcoutts: if youd like to clarify your legal stuff with me in pm...
08:02:24 <dylukes> It has a pretty substantial system for input sources.
08:02:27 <ciaranm> dcoutts: interesting, thanks
08:02:30 <EvanR> dcoutts: were thinking about a commercial app
08:02:35 <merijn> dylukes: Yeah, but I'm lazy :p
08:02:35 <dylukes> It has goddamn Cherokee Nation built in.
08:03:09 <dylukes> http://cl.ly/8N1R
08:03:51 <applicative> hm I am using 'option as meta' maybe thats a problem
08:04:05 <dylukes> applicative: You shouldn't use the built in Terminal with emacs, it has an issue or two.
08:04:10 <dylukes> i.e, C-SPC becomes C-@
08:04:24 <dylukes> Use http://emacsformacosx.com/
08:04:45 <dylukes> It just launches a special interface that's a bit more pleasant, no big differences.
08:04:51 <dylukes> Menu bars are hoisted to the actual menu, thats about it.
08:05:16 <dylukes> (it'll still use your ~/.emacs file, and all the configuration is still group config. It's pure emacs)
08:05:51 <dylukes> http://cl.ly/8OA2
08:06:12 <dylukes> I use emacs for ghci anyhow.
08:06:59 <joe6> openFile: resource exhausted (Too many open files) : I am using readFile in my program. I am wondering if replacing the use of readFile with withFile will help.
08:07:27 <ezyang> Lazy IO is probably biting you.
08:08:10 <applicative> dylukes, i use the Terminal for ghci and for emacs,
08:08:25 <dylukes> I wouldn't as I said.
08:08:27 <dylukes> I've found some issues.
08:08:42 <joe6> ezyang, will replacing readFile with withFile help?
08:08:45 <ion> withFile is guaranteed to close the file descriptor in the end. With readFile it’ll be closed whenever, perhaps.
08:08:50 <ezyang> I can't remember off the top of my head.
08:09:06 <ion> @src withFile
08:09:06 <lambdabot> withFile name mode = bracket (openFile name mode) hClose
08:09:25 <applicative> dylukes, the gui emacs always seem like theyre about to crash...
08:09:31 <dylukes> What do you mean?
08:09:41 <dylukes> that one I just linked has never crashed once :|
08:09:55 <dylukes> Plus, it has working mouse input so you can use painter if needed.
08:11:03 <applicative> dylukes, you're presumably a more expert user, I just use emacs for agda, sml and some plain text writing.
08:11:15 <dylukes> Not really, I've been using emacs a month at most.
08:11:20 <dylukes> I found agda-mode unusable in terminal.
08:11:27 <dylukes> Since you can't use C-SPC and so forth.
08:11:40 <fabjan> that linked emacs is really just vanilla emacs though, nothing special GUIy about it
08:11:51 <fabjan> the gnu distribution of emacs has Cocoa support
08:12:21 <fabjan> it looks like that site has binaries built from it
08:12:44 <quicksilver> yes, it's just GNU emacs binaries as far as I know - maybe it bundles some contrib lisp?
08:12:54 <quicksilver> it's convenient to download a binary though.
08:12:56 <fabjan> it could be just straight binaries
08:13:17 <fabjan> since many mac users are more familiar with installing apps from dmgs or something
08:13:59 <fabjan> GNU does not provide the binaries som someone has to :)
08:14:36 <dylukes> fabjan: It's just the straight binary wrapped in a cocoa interface.
08:14:41 <dylukes> Which is kind of the point.
08:14:42 <applicative>  control-space - to begin marking?
08:14:53 <dylukes> applicative: No, C-@ begins marking. C-SPC is for goals.
08:15:05 <dylukes> Er, C-c C-SPC
08:15:10 <dylukes> C-SPC is indeed marking.
08:15:11 <applicative> oh indeed, yes,
08:15:28 <dylukes> C-SPC doesn't work either though. It'll map to C-@
08:15:31 <dylukes> try it out.
08:15:43 <quicksilver> C-@ and C-SPC are the same for most emacs modes, which is why you normally don't see a problem.
08:15:43 <dylukes> This might be only in newer OS X versions though, I dunno.
08:15:49 <dylukes> quicksilver: Right, for *most*.
08:15:51 <quicksilver> agda mode being a rare exception.
08:15:55 <joe6> this does not return anything : withFile "datafile" ReadMode hGetContents :: IO String, where as readFile "datafile" returns the contents of the file
08:16:02 <quicksilver> but of course import if it's the one you're trying to use ;)
08:16:04 <quicksilver> important.
08:18:51 <dylukes> I would just use the emacs I linked befre.
08:18:57 <dylukes> It's more up to date, and it works perfectly.
08:19:06 <dylukes> You can barely tell you're not in a terminal (which is good imo).
08:19:29 <dylukes> Hitting Preferences just opens M-X customize group :P
08:22:29 <parcs> joe6: hGetContents is lazy - by the time its result is needed the file handle will already be closed returning nothing
08:22:38 <joe6> ion, withFile is not reading the contents as readFile used to.
08:22:52 <joe6> parcs, oh, ok. that makes sense.
08:24:00 <ion> If you need explicit closing of the file descriptors at certain points, you’ll need to write your code that way.
08:24:13 <ion> :t withFile
08:24:14 <lambdabot> Not in scope: `withFile'
08:24:49 <joe6> c <- withFile "equityData/A" ReadMode (\h -> hGetContents h >>= return)
08:24:57 <joe6> how can I add a seq to the hGetContents above
08:25:04 <joe6> to force strict evaluation
08:26:06 <joe6> or, is there a better way of forcing strict evaluation.
08:26:15 <ion> Instead of c <- withFile …; doSomethingWith c, try withFile foo ReadMode $ \h -> doSomethingWith =<< hGetContents h
08:26:56 <joe6> ion, oh. let me check. that would mean a lot of rewriting.
08:27:03 <joe6> thanks.
08:28:38 <ion> Depending on what you’re doing, making your program out of enumerators and iteratees might also be a good idea.
08:29:02 <shapr> @quote
08:29:03 <lambdabot> p_l says: I still wonder why bubble-sort isn't prohibited
08:29:09 <ion> @quote
08:29:10 <lambdabot> hortzjigshire says: how to set up make video4linux in red heat haskell install connet sambafs nautilus in KDE making GIMP ??
08:29:19 <joe6> ok, I have no idea what enumerators or iterators are. let me check.
08:29:28 <ion> @hackage enumerator
08:29:28 <lambdabot> http://hackage.haskell.org/package/enumerator
08:29:44 <quicksilver> if you learn one lesson though, let it be never ever ever ever ever use hGetContents or readFile.
08:30:01 <quicksilver> and it's unfortunate that the term 'lazy IO' besmirches the good name of laziness ;)
08:30:06 <Philonous> joe6:  (>>= return) is (by definition) the identity, so your example boils down to withFile "..." ReadMode hGetContents h, and that is just readFile "..."
08:30:08 <shapr> quicksilver: Especially because they're not referentially transparent!
08:30:39 <parcs> @src readFile
08:30:39 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
08:30:46 <Philonous> (strike the h)
08:33:33 <parcs> @src withFile
08:33:33 <lambdabot> withFile name mode = bracket (openFile name mode) hClose
08:34:31 <ocharles> quicksilver: sorry to bug you more, but having a look at your onNothing stuff - https://gist.github.com/1078227 - I don't think that's quite what you meant :)
08:35:44 <erus`> > let i(x) = x in i(123)
08:35:44 <lambdabot>   123
08:36:54 <ion> > let i((((((((((x)))))))))) = ((((((((((x)))))))))) in ((((((((((i))))))))))((((((((((123))))))))))
08:36:55 <lambdabot>   123
08:37:45 <xarch_> hm
08:37:48 <applicative> joe6, I assume you're aware of this shameless expedient for strict readFile http://stackoverflow.com/questions/6081794/openfile-permission-denied-when-reading-and-writing-to-the-same-file
08:37:51 <quicksilver> ocharles: if you move onNothing into the monad you won't need the ugly >>= \gid' part
08:38:03 <ocharles> quicksilver: yea, that's what I'm quite not seeing how to do
08:38:04 <b52> i got a list of FilePaths and want to get information to each filepath like permissions and modification date, finally i would like to create a list of triples with path, permission and modification date, whats the best way to do so?
08:38:05 <joe6> Philonous: ok, thanks.
08:38:18 <ocharles> I can see why it doesn't work, but I can't see how to make it work :)
08:38:45 <quicksilver> ocharles: onNothing act err = do val <- act; case val of Just a -> return a; Nothing -> throwError err;
08:38:55 <ocharles> ah
08:38:58 <joe6> applicative, thanks. that helps
08:39:37 <Philonous> joe6:  (Actually, as  parcs pointed out, I was not quite correct, readFile uses openFile, not withFile)
08:39:50 <quicksilver> ocharles: which you can rewrite as something like act >>= maybe (throwError err) return
08:39:55 <applicative> so basically  readFileStrict f = readFile f >>= \body -> (length body `seq` return body)
08:40:05 <ocharles> quicksilver: nice, beat me to it there, heh
08:40:59 <Philonous> applicative:  Wouldn't that mean that there is a race condition where the GC might collect the handle before we are done forcing all the data?
08:41:26 <joe6> applicative, thanks.
08:42:03 <applicative> Philonous, I don't think dons meant it to be all-powerful.  Like if the file is 6 gigabytes
08:43:04 <ocharles> quicksilver: I had to wrap the left side with (), does that mean I need to change the precedence of onNothing?
08:43:19 <quicksilver> ocharles: yeah, you could do
08:43:28 <ocharles> or maybe it's just cleaner with brackets
08:43:30 <quicksilver> ocharles: although precedences of user defined operators are hard to remember.
08:44:41 <applicative> Philonous, I see, he notes the length/seq trick is used by Roman L in the 'strict' package  http://hackage.haskell.org/packages/archive/strict/0.3.2/doc/html/src/System-IO-Strict.html
08:47:15 <d7> Is there a version of intercalate that doesn't have so restrictive a type signature?
08:47:24 <d7> Something more like a -> [a] -> [a]?
08:48:27 <parcs> inter
08:48:35 <parcs> sperse
08:48:50 <d7> perfect, ty
08:49:34 <b52> how can i check if the first list starts with a seconds list? [1,2,3] [1,2] <- ok [1,2] [1,2,3] not ok
08:49:42 <quicksilver> b52: isPrefixOf
08:50:19 <applicative> @type intercalate
08:50:20 <lambdabot> forall a. [a] -> [[a]] -> [a]
08:51:04 <ocharles> quicksilver: aaand more :) I wondered if it was possible to have the error data an actual other controller action. But that means something like: newtype Controller a = { runController :: ErrorT (Controller a) Snap a }, which it doesn't like because then it can't derive any type classes
08:52:48 <Twey> NewtypeDeriving?
08:53:16 <ocharles> is that a language extension?
08:53:34 <ocharles> I already have {-# LANGUAGE GeneralizedNewtypeDeriving #-}
08:53:46 <Twey> http://hackage.haskell.org/trac/haskell-prime/wiki/NewtypeDeriving
08:54:39 <ocharles> "this mechanism also cannot be used with recursive newtypes."
08:55:32 <quicksilver> ocharles: that's a bit annoying isn't it?
08:55:45 <quicksilver> ocharles: you should be able to cheat in the following way:
08:56:09 <quicksilver> newtype Controller a b = { runController :: ErrorT b Snap a }
08:56:23 <quicksilver> type RealController a = Controller a (Controller a)
08:56:27 <quicksilver> or similar.
08:57:58 <Twey> Does Snap not already include an ErrorT?
08:59:09 <ocharles> Twey: http://hackage.haskell.org/packages/archive/snap-core/0.5.1.4/doc/html/Snap-Types.html not that I can see?
08:59:52 <Twey> Hm, StateT SnapState (Iteratee ByteString IO) (SnapResult a)
08:59:58 <Twey> Strange… I would expect it
09:00:23 <ocharles> quicksilver: clever... nice
09:00:25 <joe6> my program is taking a long time with this line:  return . read . last . splitOn "," . last . lines , as I execute this line 3000 times. It is rading the last column of the last line of a csv file.
09:00:31 <Twey> Oh, but SnapState contains an error-logging function…
09:00:34 <joe6> any suggestions on speeding it up, please?
09:01:04 <ocharles> quicksilver: wait... but the second Controller is lacking a final type
09:01:06 <joe6> the return type is a Float.
09:01:19 <Twey> joe6: Why are you executing it 3000 times?
09:01:20 <ocharles> quicksilver: should that be type RealController a = Controller a (RealController a) or something?
09:01:31 <Twey> Is it a big CSV file?
09:01:41 <joe6> it is because it is reading 3000 different files.
09:02:00 <Twey> You would probably do better to seek to the end and then seek backwards until you hit a newline
09:02:03 <joe6> and I want to pick the last column of the last line of 3000 files.
09:02:05 <applicative> joe6, always the very last number?
09:02:11 <Twey> Rather than reading through the whole file from the start
09:02:14 <joe6> applicative, yes
09:02:38 <Twey> Oh, yeah — you only need to seek backwards to a comma, even
09:02:45 <joe6> Twey, good idea. will check it out. Thanks.
09:06:21 <applicative> > let lastbit :: String -> Integer; lastbit = read . reverse . takeWhile (/=',') . reverse in lastbit "45,46,47\n57,58,59 "
09:06:23 <lambdabot>   59
09:06:44 <applicative> seems kinda lame though
09:06:52 <travisyay> i am working on doing concurrent programming in haskell and am having issues running the threaded program.. can anybody help?
09:07:53 <blubsala> why exactly doesn't (\f -> f . f) concat work?
09:08:08 <applicative> travisyay: if they are simple enough?. ...
09:08:12 <quicksilver> ocharles: yes, sorry.
09:08:26 <applicative> travisyay: you compiled it okay, but can't run it?
09:08:39 <parcs> blubsala: f needs a type a -> a
09:08:50 <ocharles> quicksilver: ok, cause that gives a "Cycle in type synonym declarations" error :
09:08:52 <parcs> concat is [a] -> a
09:08:57 <quicksilver> ocharles: oh, bother :(
09:09:05 <quicksilver> ocharles: I'm not sure, then. You could write the instance by hand.
09:09:22 <quicksilver> ocharles: or oyu could hide the 'Left' thing inside another newtype.
09:09:24 <blubsala> but concat . concat works, is it something how haskell infers the types?
09:09:24 <ocharles> I tried type RealController a = Controller a (Controller a String) and it didn't like that either anyway
09:09:26 <quicksilver> it's still annoying.
09:09:38 <parcs> @type \f -> f . f
09:09:39 <lambdabot> forall b. (b -> b) -> b -> b
09:09:52 <quicksilver> Twey: ocharles specifically wants a short-circuiting behaviour; I did wonder if Snap already had something but I don' tuse Snap
09:09:59 <ocharles> Think I might just go with an ErrorDetails type for now, and stuff an error code and view into it that
09:10:04 <quicksilver> Twey: possibly Snap uses IO exceptions to short circuit?
09:10:32 <Twey> Hm, perhaps
09:10:40 <mightybyte> Snap has the pass function.
09:10:57 * hackagebot yesod-examples 0.8.0.3 - Example programs using the Yesod Web Framework.  http://hackage.haskell.org/package/yesod-examples-0.8.0.3 (MichaelSnoyman)
09:12:15 <joe6> i can use hSeek to seek to the end of the file, but I cannot use a negative number to seek back.
09:12:39 <ocharles> Well, I gotta get some food shipping
09:12:52 <ocharles> I might see what the haskell cafe have to say about this
09:13:14 <joe6> is reverse lazy?
09:13:17 <ion> @hoogle hSeek
09:13:18 <lambdabot> System.IO hSeek :: Handle -> SeekMode -> Integer -> IO ()
09:13:19 <applicative> yes
09:13:23 <ion> @src SeekMode
09:13:23 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
09:13:35 <joe6> applicative: oh, cool.
09:13:36 <applicative> hSeekLn is what you need
09:13:37 <ion> SeekFromEnd
09:13:51 <joe6> @hoogle hSeekLn
09:13:51 <lambdabot> No results found
09:14:11 <joe6> ion, but you cannot seek from the back.
09:14:25 <applicative> oh sorry, joe6, i was making hSeekLn up
09:14:35 <joe6> applicative, ok, thanks.
09:14:35 <Twey> joe6: Why not?  I think you can pass a negative number to hSeek…
09:14:48 <joe6> no, you cannot.
09:14:50 <mightybyte> ocharles: If the behavior you want is for the current handler to fail and the next alternative to be tried, you can do something like "book <- fromMaybe pass $ getBook gid"
09:15:04 <joe6> Twey, "It is not possible to set a negative I/O position, or for a physical file, an I/O position beyond the current end-of-file."
09:15:12 <ion> ghci> withFile "/etc/motd" ReadMode $ \h -> hSeek h SeekFromEnd (-5) >> hTell h
09:15:12 <ion> 186
09:15:13 <mightybyte> oops, that should be "book <- maybe pass return $ getBook gid"
09:15:13 <joe6> Twey, this is what is found in the manual.
09:15:20 <joe6> Twey, I could be wrong, though.
09:15:33 <Twey> joe6: ‘Negative’ as in before the beginning of the file, I imagine
09:15:35 <joe6> and the ghci did not take a negative number either.
09:15:57 <mightybyte> ...or some variation depending on the actual type of getBook.
09:15:58 <Twey> Not negative as in before the current position or the end
09:16:08 <joe6> Twey, http://pastebin.com/8bhGamFL
09:16:10 <mauke> The paste 8bhGamFL has been copied to http://hpaste.org/48973
09:16:31 <Twey> joe6: ITYM (negate 100)
09:16:55 <Twey> Unary minus is a bit of a wart in Haskell.
09:17:17 <Twey> You can write (-100), equivalently.  I prefer ‘negate’, though.
09:17:54 <joe6> Twey, you are correct. That worked like a charm.
09:17:58 <joe6> Twey, thanks.
09:18:21 <quicksilver> Twey: (subtract 0 100) ftw.
09:18:45 * Twey wishes we could just have consistently significant spacing and sidestep the whole fiasco.
09:19:36 <dylukes> blubsala: Did you get an answer to that question?
09:19:40 <dylukes> I was curious but I had to leave.
09:19:47 <dylukes> > (\f -> f . f) concat
09:19:48 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
09:20:23 <dylukes> :t concat
09:20:24 <lambdabot> forall a. [[a]] -> [a]
09:20:31 <dylukes> oh, theres the issue.
09:20:36 <Twey> (\f -> f . f) will only typecheck for arguments that have a return type the same as their argument type
09:20:38 <dylukes> that'd only work for an a -> a function.
09:20:40 <Twey> Yes
09:20:40 <dylukes> Twey: ^
09:20:57 <dylukes> > (\f -> f . (liftM f)) concat
09:20:58 <lambdabot>   Overlapping instances for GHC.Show.Show ([[[a]]] -> [a])
09:20:58 <lambdabot>    arising from a ...
09:20:58 <Twey> > (\f -> f . f) id
09:20:59 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> b)
09:20:59 <lambdabot>    arising from a use of `...
09:21:01 <dylukes> That works though.
09:21:05 <Twey> Yep
09:21:22 <Twey> (inner brackets are unnecessary)
09:21:25 <dylukes> > (\f -> f . (liftM f)) concat [[[10], 12],  23]]]
09:21:26 <lambdabot>   <no location info>: parse error on input `]'
09:21:28 <dylukes> true
09:21:35 <dylukes> > (\f -> f . (liftM f)) concat [[[10], 12],  23]
09:21:35 <lambdabot>   No instances for (GHC.Num.Num [a], GHC.Num.Num [[a]])
09:21:36 <lambdabot>    arising from a use...
09:21:38 <Twey> That's not a valid list
09:21:46 <dylukes> whoops
09:22:03 <dylukes> > (\f -> f . (liftM f)) concat [[[1,2,3]], [12]]
09:22:04 <lambdabot>   No instance for (GHC.Num.Num [a])
09:22:04 <lambdabot>    arising from a use of `e_112312' at <i...
09:22:09 <Twey> (what are you actually trying to do?  I didn't see the original question)
09:22:15 <Twey> Also not a valid list
09:22:20 <Twey> Lists must be homogeneous
09:22:29 <dylukes> I know, just messing around.
09:22:35 <quicksilver> Twey: it's a seductive idea but I'm scared of more significant whitespace to be honest.
09:22:42 <Twey> quicksilver: Why?
09:22:47 <quicksilver> Twey: I already don't like the significant whitespace around .
09:23:01 <Twey> quicksilver: It's only bad because it's inconsistent
09:23:06 <quicksilver> because it breaks the general rule that whitespace around operators is merely a matter of taste.
09:23:09 <quicksilver> yes, agreed.
09:23:10 <Twey> Right
09:23:21 <Twey> If we had consistently significant whitespace, that would be fine.
09:23:24 <quicksilver> if it was *illegal* to omit the whitespace around operators that would be consistent.
09:23:26 <blubsala> didn't want to do something particular, i was just interested how haskell copes with this because on the first sight you would thing it would work
09:23:27 <Twey> *nod*
09:23:33 <quicksilver> a+b -- syntax error
09:23:39 <Twey> blubsala: It doesn't
09:23:45 <Twey> quicksilver: Or valid identifier, I would prefer
09:24:03 <blubsala> so in a dynamicly typed language this should work?
09:24:08 <Twey> blubsala: Yes
09:24:19 <Twey> blubsala: Haskell lists are homogeneous.  There are ways to get hetero lists (see the HList package) but they're quite complicated.
09:24:31 <Twey> And in practice rarely necessary
09:24:36 <dylukes> I think requiring whitespace is good.
09:24:36 <quicksilver> Twey: nod
09:24:39 <dylukes> Look at Agda for instance.
09:24:50 <dylukes> using a+b=c as a proof type can be useful.
09:25:01 <dylukes> or, proposition, or what have you.
09:25:03 <Twey> Yeah, you get cool stuff like that as a bonus.
09:25:10 <Twey> And operators like -o-
09:25:18 <dylukes> mm.
09:25:21 <quicksilver> yes, I can definitely see advantages to that
09:25:26 <quicksilver> it's the inconsistency I don't like
09:25:30 <Twey> *nod*
09:25:39 <dylukes> I would vote for consistently requiring whitespace.
09:25:39 <quicksilver> (although I do expect lots of people would be annoyed by a+b not working)
09:25:47 <dylukes> The only time it's "annoying" is in tuples.
09:25:52 <dylukes> i.e (1, 2) looks nicer than (1 , 2)
09:25:57 <dylukes> but, thats a minor quibble.
09:25:59 <ion> , is not an operator.
09:26:04 <Twey> dylukes: That's syntax rather than an operator anyway, though.
09:26:08 * dylukes is still in Agda mode anyhow.
09:26:31 <Twey> , would have to be invalid.  Likewise . and a couple of other things.
09:26:58 <Twey> ( ) [ ] { } ;
09:27:01 <Twey> And space, obviously
09:27:46 <Twey> Well, actually, no — I guess you could require them to be tokens on their own, surrounded by whitespace, too
09:27:56 <Twey> I think most of us would rather not, though
09:28:04 <Twey> At least for , and
09:28:04 <Twey> ;
09:28:13 <Tomsik> > fst (1,2,3,4)
09:28:14 <lambdabot>   Couldn't match expected type `(a, b)'
09:28:14 <lambdabot>         against inferred type `(t, t1...
09:28:20 <dylukes> The only thing unpleasant in the Agda style with mix fixes is, i.e
09:28:25 <dylukes> [_]
09:28:29 <dylukes> you have to do [ 10 ]
09:28:31 <thoughtpolice> i think we should steal this idea from rust: https://github.com/graydon/rust/issues/666
09:28:33 <dylukes> you can't drop those spaces.
09:28:45 <thoughtpolice> "The compiler should accept both "unsafe" and "☢" as synonyms, and the pretty-printer should canonicalize to ☢. Implement this."
09:29:00 * hackagebot happstack-server 6.1.6 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-6.1.6 (JeremyShaw)
09:29:23 <Tomsik> Am I the only one who is unhappy with (1,2,3) not being the same as /any/ of (1, (2,3)) ((1,2), 3)?
09:29:24 <applicative> "Using ? has the advantage of being hard to type, thereby discouraging the use of unsafe." probably true...
09:29:51 <thoughtpolice> applicative: that was my favorite part :P
09:29:57 <applicative> pretty good
09:30:05 <Tomsik> I know it doesn't make a lot of sense, but uh, there are no generic tuple accessors
09:30:27 <dolio> ? is hard to type?
09:30:45 <applicative> dolio, it's the nuclear waste sort of warning unicode
09:31:01 <Twey> Tomsik: A little bit
09:31:04 <applicative> ?
09:31:16 <thoughtpolice> applicative: comes out as '?' on this side
09:31:36 <Tomsik> thoughtpolice: your font is lacking
09:32:08 <thoughtpolice> Tomsik: ah
09:32:16 <quicksilver> Tomsik: no, you're not the only person. It's discussed fairly often.
09:32:20 <dylukes> thoughtpolice: What OS are you on?
09:32:22 <applicative> thoughtpolice: yeah I see, somewhere my encodings are mixed up
09:32:26 <quicksilver> Tomsik: however in practice I seldom use tuples.
09:32:35 <dylukes> I know OS X and most Linuxes will replace missing symbols with the proper glyph from another font.
09:32:37 <quicksilver> Tomsik: and lambda expressions are an easy way to deal with them when you do.
09:32:54 <dolio> If we're talking about ☢, my font displays it.
09:33:01 <quicksilver> map (\((x,y),(z,w)) -> [x,y,z,w]) someListOfNestedTuples
09:33:06 <thoughtpolice> my font also displays what dolio said
09:33:12 <thoughtpolice> dylukes: linux, but this machine is a rather odd beast
09:33:32 <dylukes> heh.
09:33:48 <thoughtpolice> (you can think of it as an unholy mixing of things from debian lenny/testing/unstable as I need them. I don't upgrade my xorg server anymore, as I like to have my graphical login continue to work)
09:33:49 <dylukes> I can see ☢ perfectly well.
09:33:52 <thoughtpolice> not that I ever reboot this machine anyway
09:33:58 <dolio> Anyhow, missing symbols certainly don't turn into a question mark here.
09:34:01 <thoughtpolice> dylukes: so can i, but for applicative it gave me a '?'
09:34:05 <dylukes> hm.
09:34:22 <luite_> same here
09:36:16 <shapr> I want to write more Haskell code :-(
09:39:33 <erus`> > 1 = 2
09:39:34 <lambdabot>   <no location info>: parse error on input `='
09:39:44 <erus`> > (-) = +
09:39:45 <lambdabot>   <no location info>: parse error on input `='
09:39:59 <erus`> > let 1 = 2 in 1 + 1
09:40:00 <lambdabot>   2
09:40:04 <erus`> :O
09:40:35 <Tomsik> > let 1 = x in 1
09:40:36 <lambdabot>   1
09:40:43 <Tomsik> > let y = x in y
09:40:44 <lambdabot>   x
09:40:55 <Tomsik> :t let y = x in y
09:40:55 <lambdabot> Expr
09:41:00 <Tomsik> ah right
09:42:01 <applicative> thoughtpolice, I see a warning sign, but send a '?' there is a conversion for purposes of the transmission at the moment, not sure why
09:42:16 <thoughtpolice> applicative: ah
09:44:08 <Sinner> awesome
09:44:31 <blubsala> dylukes: I think I found out why exactly (\f -> f . f) doesn't work:
09:44:36 <applicative> Sinner, what's so awesome
09:44:42 <dylukes> It does work blubsala, just not for concat.
09:44:52 <siracusa> Haskell is awesome, of course
09:45:09 <Sinner> sorry, I'm testing "Try Haskell" on HaskellWiky
09:45:10 <parcs> :t ?f . ?f
09:45:11 <lambdabot> forall a. (?f::a -> a) => a -> a
09:45:22 <blubsala> if f is concat then in both positions
09:45:31 <EvanR> anyone have success with haskell package management on arch
09:45:35 <blubsala> then concat has two different types in both positions
09:45:39 <EvanR> ive been avoiding it and using cabal normally
09:46:22 <blubsala> but i guess each argument can only have one type
09:46:23 <dylukes> For example
09:46:23 <dylukes> > (\f -> f . f) tail [1,2,3,4]
09:46:25 <lambdabot>   [3,4]
09:46:26 <dylukes> No, it's because
09:46:28 <dylukes> :t concat
09:46:28 <lambdabot> forall a. [[a]] -> [a]
09:46:44 <dylukes> f . f implies [a] == [[a]] which constructs the infinite type a = [a]
09:47:18 <benmachine> :t concat . concat
09:47:19 <lambdabot> forall a. [[[a]]] -> [a]
09:47:28 <benmachine> I think blubsala is right
09:47:36 <blubsala> :t (\f g -> f . g) concat concat
09:47:37 <dylukes> :t (.)
09:47:37 <lambdabot> forall a. [[[a]]] -> [a]
09:47:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:47:50 <dylukes> caleskell again. :|
09:48:02 <benmachine> :t concat Prelude.. concat -- irrelevant
09:48:02 <lambdabot> forall a. [[[a]]] -> [a]
09:48:05 <dylukes> :t Prelude..
09:48:06 <lambdabot> parse error on input `Prelude..'
09:48:09 <dylukes> :t Prelude.(.)
09:48:10 <lambdabot> Not in scope: data constructor `Prelude'
09:48:10 <benmachine> :t (Prelude..)
09:48:11 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
09:48:17 <dylukes> yeah, there it is.
09:48:34 <dylukes> So, for f . f to work, it has to be (a -> a) -> (a -> a) -> a -> a
09:49:04 <dylukes> that's an interesting definition… the functor one.
09:49:23 <benmachine> the important thing is that parameters to lambdas are monomorphic
09:49:30 <dylukes> > (+ 1) . [1, 2, 3, 4]
09:49:32 <lambdabot>   [2,3,4,5]
09:49:35 <dylukes> :|
09:49:36 <benmachine> in (\f -> f . f) concat, concat can only have one type
09:49:49 <dylukes> :t fmap
09:49:50 <benmachine> whereas
09:49:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:49:50 <dylukes> :t (.)
09:49:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:49:56 <benmachine> :t let f = concat in f . f
09:49:56 <lambdabot> forall a. [[[a]]] -> [a]
09:49:57 <dylukes> (.) … is fmap.
09:49:58 <dylukes> what.
09:50:15 <benmachine> dylukes: it's a natural enough generalisation
09:50:23 <dylukes> I never really thought about it...
09:50:28 <dylukes> how would it apply to functions though?
09:50:47 <lunaris> :t fmap fmap fmap -- ?
09:50:48 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
09:50:49 <EvanR> compose
09:50:56 <EvanR> ?
09:51:06 <benmachine> dylukes: there's an instance Functor ((->) r)
09:51:11 <benmachine> where fmap = (.)
09:51:16 <dylukes> Yeah, I see there must be.
09:51:25 <benmachine> :t fmap
09:51:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:51:34 <benmachine> replace 'f' with 'r ->'
09:51:42 <benmachine> and you get the signature for (.)
09:51:46 <dylukes> mm, I see :)
09:51:52 <dylukes> thats neat, I didn't think of that.
09:52:34 <EvanR> Warning: Module `Control.OldException' is deprecated
09:53:00 <EvanR> exactly which kind of exception is it talking about
09:55:48 <benmachine> EvanR: old?
10:05:36 <Cadynum> what is the preprocessor "#if defined(mingw32_HOST_OS) || defined(__MINGW32__)" counterpart for mac osx?
10:06:55 <Clint> Cadynum: do a `gcc -E -dM -` and look for things like apple or darwin
10:06:55 <rothwell> #if defined(__APPLE__) || defined(__MACH__)
10:07:05 <dncr> is there a breakSubstring for lazy bytestrings?
10:07:09 <rothwell> that's at a minimum
10:08:09 <rothwell> yes, i have lists of this crap
10:08:13 <rothwell> http://paste.lisp.org/display/123223
10:08:14 <Cadynum> rothwell, thanks
10:08:48 <mauke> what, no __linux__?
10:08:54 <rothwell> hehe
10:11:09 <rothwell> http://predef.sourceforge.net
10:29:29 <b52> http://paste.pocoo.org/show/437095 anyone? blazehtml 5
10:31:32 <siracusa> b52: You need toAttr or toAttribute or so, IIRC
10:33:04 <b52> siracusa: ah, toValue is it
10:33:09 <b52> thanks for the hint
10:34:33 <siracusa> Ah, that was is, yes
10:38:11 <applicative> ghc-7 has killed a bunch of the 'shootout' entries.
10:39:35 <applicative> http://shootout.alioth.debian.org/u64q/haskell.php
10:39:55 <applicative> i repaired regex-dna, but it's kind of slow compared to everything else
10:41:38 <saml> http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=gcc
10:41:54 <saml> gcc killed a bunch of shootout entries
10:47:48 <applicative> gcc always kills them.  things like java are better to worry about, no?
10:48:33 <saml> no. gcc please.
10:49:53 <joe6> @hoogle Jul
10:49:54 <lambdabot> module Data.Time.Calendar.Julian
10:49:54 <lambdabot> Data.Time.Calendar.Julian julianMonthLength :: Integer -> Int -> Int
10:49:54 <lambdabot> System.Time July :: Month
10:50:37 <wli> The shootout is ill-conceived.
10:50:55 <joe6> is "Jul" defined anywhere instead of "July"
10:51:09 <applicative> anything that used -fvia-C seems to have a make error
10:51:40 <applicative> no that's not right
10:52:10 <parcs> the shootout is stupid now that it benchmarks languages instead of implementations
10:52:34 <zygoloid> parcs: huh? what does that even mena?
10:53:23 <EvanR> erm what does any mean in a type signature
10:53:33 <EvanR> eventWindow :: EventM any DrawWindow
10:53:59 <parcs> zygoloid: the maintainer removed all alternative language implementations ie pypy, rubinius
10:54:15 <EvanR> eventSent :: EventM any Bool
10:54:26 <Silvah> EvanR: the same as a, b, c and so on?
10:54:29 <zygoloid> what does it mean for a language implementation to be 'alternative'?
10:54:30 <EvanR> oh
10:54:36 <EvanR> tricky
10:54:43 <zygoloid> there is no official haskell or c or c++ implementation, for instance
10:54:49 <wli> The shootout was tupid before that even.
10:54:53 <parcs> zygoloid: exactly
10:55:01 <Silvah> Lower-case identifiers in this context are all type variables.
10:55:06 <parcs> its arbitrary
10:55:48 <EvanR> Silvah: even if they spell the name of some typical function ;)
10:55:49 <parcs> yet the maintainer seems to know..
10:57:16 <wli> e.g. the individual microbenchmarks would be better to have some parameter for problem size and another for parallelism level.
10:58:45 <wli> I speak as if I were Japanese. The problem size and parallelism levels are not optional.
11:02:24 <elliotstern> What's the default directory haddock outputs to?
11:02:28 <elliotstern> in unix
11:02:47 <EvanR> gah... gtk2hs EventM exists for the purpose of passing event data to the handler.. why not just use function parameters a -> IO b instead
11:18:26 <huntaz556> helo
11:18:28 <huntaz556> hello
11:18:43 <huntaz556> what kinds of programs can i make with haskell?
11:18:49 <saml> you can't
11:18:56 <huntaz556> what can i do with haskell?
11:18:57 <saml> haskell isn't for making programs
11:19:14 <saml> you can research interesting stuff with haskell
11:19:16 <sully> haskell is for writing cute little one liners that generate the infinite list of something
11:19:20 <huntaz556> like?
11:19:23 <sully> while not using any variable names
11:19:30 <sully> and then feeling clever
11:19:34 <huntaz556> lol
11:19:46 <saml> huntaz556, http://okmij.org/ftp/Haskell/   basics of haskell
11:20:05 <huntaz556> thanks ill look over that
11:20:09 <rekahsoft> hi all..is there anything like tail recursion in haskell?
11:20:20 <sully> > let fibs = [0,1] ++ zipWith (+) fibs (tl fibs)
11:20:20 <lambdabot>   not an expression: `let fibs = [0,1] ++ zipWith (+) fibs (tl fibs)'
11:20:28 <saml> rekahsoft, yes
11:20:29 <sully> argh, how do you do declarations?
11:20:56 <sully> @let fibs = [0,1] ++ zipWith (+) fibs (tl fibs)
11:20:58 <lambdabot>  <local>:2:34: Not in scope: `tl'
11:21:04 <sully> @let fibs = [0,1] ++ zipWith (+) fibs (tail fibs)
11:21:06 <lambdabot>  Defined.
11:21:10 <sully> > take 10 fibs
11:21:11 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
11:21:17 <olsner> > fix$(<$>)<$>(:)<*>((<$>((:[{- thor's mother -}])<$>))(=<<)<$>(*)<$>(*2))$1 -- speaking of "cute little one liners that generate the infinite list of something" :)
11:21:18 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
11:21:19 <saml> sully, okay. you are too smart.
11:21:20 <sully> HugoDaniel: that's what you can do in haskell
11:21:23 <sully> oh, you're already gone
11:21:29 <rekahsoft> saml: is it the same idea as in scheme? for example use an accumlator and finally ruturn it so i don't overload the stack?
11:21:36 <sully> saml: hm?
11:21:42 <rekahsoft> any exmaples of this?..i'm googling myself right now
11:21:42 <sully> saml: that's a standard example, I think
11:21:44 <saml> rekahsoft, yes.
11:21:57 <sully> @pl fibs = [0,1] ++ zipWith (+) fibs (tail fibs)
11:21:57 <lambdabot> fibs = fix (([0, 1] ++) . ap (zipWith (+)) tail)
11:22:04 <saml> rekahsoft, what do you want to do?
11:22:04 <sully> "great"
11:22:35 <saml> > let f = f f in f 1
11:22:35 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t
11:23:25 <rekahsoft> saml: i am just learning haskell so i have been doing all sorts of excersise stuff having to do mostly with math and problems i find intersting
11:23:52 <saml> rekahsoft, that's nice.   i think GHC does optimize tail calls
11:23:52 <rekahsoft> also i found a nice page on tail call optimization in haskell on the haskellwiki :P
11:24:22 <clsmith> hey all. i was wondering what the recommended zipper library is. on hackage i've found ListZipper and syz ('scrap your zippers'). which should i use?
11:25:11 <rekahsoft> haskell is pretty sick tho..really really nice for applying to mathematical problems..going to grab a linear alg book and write some of that into code for s&g
11:27:59 <ash__> so, i am having trouble thinking of how solve a problem. I solved it once in python, but I wanted to try writing it in haskell but I just dont know how to do one part of the code in haskell
11:29:07 <Jetbeard> ash__: what's the problem and what do you have so far?
11:29:17 <ash__> so given a list of values, lets say they are [Bool], and I need to find the distance between True's and count up then down, so... given [True, False, False, False, True] you'd get [-1, 1, 2, 1, -1]
11:30:16 <Jetbeard> (wouldn't 0 be a more appropriate distance from a True to the nearest True?)
11:31:02 <ash__> ya, i just put a -1 as a value to represent the position of the true's
11:31:16 <ash__> it could be 0, or Nothing if I did a list of Maybe Ints
11:31:33 <EvanR> eww -1
11:31:50 <ash__> it could start a 0, 1, ... instead of 1, i just need a way of telling the current distance to the nearest True
11:31:59 <Jetbeard> imo 0 would be more sensible -- not only does it fit the specification (the distance from anything to itself is 0), but it will also more easily lead to a recursive solution
11:32:33 <ash__> okay, a 0 would be fine
11:32:49 <saml> ash__, i don't get it
11:32:59 <saml> why not -1,1,2,3,-1
11:33:17 <Jetbeard> saml: it will replace each element with the distance from that element to the nearest True
11:33:29 <saml> ash__, why do you need it?
11:33:49 <saml> Jetbeard, thanks
11:34:03 <ash__> i am trying to make a voronoi diagram, to decompose a 2d map for planning the path of a robot
11:34:17 <ash__> right now I am just simplifying it to 1 dimension
11:34:17 <saml> ash__, is the list always 5 elements?
11:34:25 <saml> can the list be infinite?
11:34:32 <ash__> no, but they could be N large
11:34:37 <ash__> the field size varies
11:34:48 <saml> N is fixed through out program run?
11:34:59 <ash__> we can set it to be a constant, sure
11:35:46 <ash__> ultimately, at any given (x, y) on the field, I should be able to find the distance to the nearest obstacle
11:36:24 <ash__> I have a list of [[Bool]] that represent which spaces in the map are occupied
11:36:55 <erus`> ash use an array
11:37:02 <erus`> or map
11:37:15 <Jetbeard> initially i was thinking that an array would be the most sensible thing
11:37:19 <Jetbeard> but a solution is unfolding in my mind
11:38:03 <ash__> well, i started using Data.Vector but I decided to switch to [] just to simplify it
11:40:49 <ash__> I can show you the python version if you want
11:41:09 <Jetbeard> I've worked out the Haskell solution, let me just type it up, document it and test it
11:41:37 <saml> i have it in my head
11:41:45 <saml> it's like.. xmonad a bit
11:46:41 * hackagebot hbro 0.6.3 - A suckless minimal KISSy browser  http://hackage.haskell.org/package/hbro-0.6.3 (koral)
11:50:59 <ash__> http://goo.gl/jTKTO is a description of the application, I did it for a robotics competition were we made an autonomous lawnmower
11:51:43 * hackagebot web-routes 0.25.2 - Library for maintaining correctness and composability of URLs within an application.  http://hackage.haskell.org/package/web-routes-0.25.2 (JeremyShaw)
11:52:24 <cebewee> Hi. Does current haskell-src-exts provide a facility to access a non-standard pragma (like {-# HASKABELLE foo bar #-}?
11:52:59 <cebewee> haskell-src-exts-0.4.8 provided this via UnknownDeclPragma, but this seems to be gone since ANN pragmas are supported
11:53:25 <ash__> https://github.com/wjwwood/au-automow/blob/master/au_automow_common/automow_planning/src/costmap.py is the python implementation
11:54:29 <siracusa> cebewee: There's "UnknownExtension String"
11:55:40 <siracusa> cebewee: No, forget what I said, that seems to be something else
11:55:44 * hackagebot web-routes-wai 0.20.0 - Library for maintaining correctness of URLs within an application.  http://hackage.haskell.org/package/web-routes-wai-0.20.0 (JeremyShaw)
12:01:26 <dcoutts> EvanR: the reason for EventM is that retrieving some of that data is a bit expensive, and we cannot do it lazily
12:01:39 <EvanR> weird
12:01:49 <dcoutts> EvanR: in particular getting the expose region in expose events is expensive
12:02:15 <EvanR> cairo and pango are pretty cool, just looking into them. testing in C
12:02:15 <lispy> preflex: seen pastorn
12:02:16 <preflex>  pastorn was last seen on #haskell 22 days, 22 hours, 9 minutes and 8 seconds ago, saying: gwern: ^^^
12:02:28 <dcoutts> EvanR: then they did it all that way to be consistent, personally I'd tend to agree with you that it's a bit unnecessary
12:02:46 <lispy> lambdabot: seen pastorn
12:02:51 <lispy> ?seen pastorn
12:02:51 <lambdabot> Unknown command, try @list
12:03:01 <dcoutts> EvanR: yeah, they're pretty good, cairo has a fairly good api, both cairo and pango can produce good quality results
12:03:35 <dcoutts> pango's api is a bit more involved but not totally unreasonable, and it's got quite a lot of features
12:09:18 <cebewee> siracusa: Ok, it seems I'm stuck with the old library.
12:09:49 <cebewee> Now, find out why GHC does not terminate ...
12:13:31 <EvanR> ls
12:13:41 <EvanR> oops
12:14:18 * EvanR makes a hello world pdf with two standard american sized pages
12:14:22 <EvanR> yay
12:14:45 <saml> ash__, let f [] l c = reverse l; f (True:xs) l c = f xs (0:zipWith min l [1..]) 0; f (False:xs) l c = f xs (c:l) (c+1)  in f [True, False, False, False, True] [] 1
12:14:48 <saml> something like that
12:14:50 <saml> but it's buggy
12:15:03 <EvanR> now to set up haskell on windows
12:15:29 <ash__> saml, what do you mean?
12:15:35 <ash__> or, in what ways?
12:15:39 <saml> > let f [] l c = reverse l; f (True:xs) l c = f xs (0:zipWith min l [1..]) 1; f (False:xs) l c = f xs (c:l) (c+1)  in f [True, True, False, False, False, False, True, False] [] 1
12:15:39 <lambdabot>   [0,0,1,2,2,1,0,1]
12:15:45 <saml> ash__, is that okay?
12:15:58 <ash__> looks right to me
12:16:01 <saml> nice
12:16:28 <saml> haskell is so tricky. once you write, you don't want to maintain it.. you can only rewrite.
12:16:38 <saml> no refactoring..etc .. or different refactoring is possible
12:17:27 <EvanR> 'major refactoring' is easy in haskell ;)
12:17:38 <saml> the algorithm is  like xmonad.. or book flipping
12:17:57 <saml> you flip through the book.. queuing previously viewed pages..  if you hit True page, you have to go back the queue and reindex.
12:18:29 <saml> and as you flip through the book, you enumerate the page 1,2,3,4... hit True.. reindex the previous pages.. 5,6,7,8...
12:18:35 <byorgey> saml: actually, I find maintaining/refactoring Haskell code to be far easier than in any other language, because of the strong type system.
12:18:44 <saml> yup you are byorgey
12:18:49 <saml> !!
12:19:03 * Twey agrees.
12:19:06 <byorgey> hehe
12:19:14 <bobzhang> @@
12:19:17 <saml> i mean.. if one is experienced in haskell, probably it gets easier.. same as any language :P
12:19:38 <quicksilver> byorgey: for multiple reasons
12:19:51 <EvanR> it never gets easier to refactor php python
12:19:52 <quicksilver> byorgey: one is that I tend to produce more refactorable designs, because the type system makes me think more carefully
12:20:07 <saml> do document those refactoring tips though.. it'll be immencely useful for new comers like me
12:20:10 <quicksilver> byorgey: the other is that if I make a mistake in refactoring it's almost always a compile error.
12:20:13 <Twey> saml: The type system guides you when refactoring, though — it prevents you from doing anything obviously silly.  Kind of like having differently-shaped sockets — you can't accidentally plug a square plug into a round socket like you can in dynamic languages.
12:20:37 <byorgey> quicksilver: yup, the second is what I meant, but I agree about the first as well
12:20:43 <saml> yah, that could sometimes mean "rewriting" a huge part of the program
12:21:10 <EvanR> saml: which is pretty easy
12:21:16 <saml> write a best practice book quicksilver
12:21:35 <saml> i would like to learn about "careful" haskell program designs
12:21:38 <applicative> > let op True n = 0; op False n = (n+1) ; scan1 = init . scanr op 0 ; scan2 = reverse . scan1 . reverse ; ls = [True, False, False, False, True] in zipWith min (scan1 ls) (scan2 ls)
12:21:39 <lambdabot>   [0,1,2,1,0]
12:22:25 <ash__> saml: thanks for the help, now I am just trying to comprehend all of that so I know how it works :P
12:26:29 <ash__> zip's are one of those functions I have always had trouble figuring out where they go
12:26:32 <Jetbeard> wow saml, that's far better than my solution
12:27:00 <saml> ash__, zipWith is same as python's zip function. except that you can supply a method of "zipping"
12:27:28 <saml> python's zip is   zipping with Pair  constructor in a way.
12:27:35 <ash__> ya, but I never know where to use it in python, its more I dont know where its applicable
12:28:20 <sshc> http://hackage.haskell.org/packages/archive/numeric-prelude/latest/doc/html/Number-Peano.html#Peano — And the C's are obvious.
12:30:07 <ash__> in haskell, is there an easy way to see intermediate values of set of operations? I mean you cant just put prints in as bad as that sounds it can be useful sometimes to understand whats happening... (and I dont understand a lot of haskell, still learning)
12:30:44 <EvanR> Debug.trace
12:32:14 <ash__> i guess i'd need to be in ghci for that, correct?
12:32:31 <Clint> @pl map ((++)"/") (map snd (filter ((==user).fst) alldirs))
12:32:32 <lambdabot> map ('/' :) (map snd (filter ((user ==) . fst) alldirs))
12:32:44 <thoughtpolice> ash__: no, just use Debug.Trace.trace in any pure computation where you want to spit out the values
12:33:06 <nand`> According to http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors, ((-> r) is a member of the Applicative typeclass. In the example given, (+) <$> (+3) <*> (*100) $ 5 should return 508. However, I get an error when executing this: http://pastebin.com/Ma5ynkEt
12:33:08 <nand`> What's up with that?
12:33:10 <mauke> The paste Ma5ynkEt has been copied to http://hpaste.org/48981
12:33:10 <thoughtpolice> ash__: but because haskell is lazy, you won't see anything printed unless you force evaluation of the 'trace' expression, so it's also possible to not see anything at all (if the values are not forced)
12:33:39 <Cale> nand`: import Control.Monad.Instances
12:33:41 <doughsay> trying to cabal install on windows, i get "setup.exe: internal error: unexpected package db stack: [UserPackageDB]"
12:33:50 <Cale> nand`: Or perhaps  Data.Function  would also do it
12:33:59 * Twey wonders why these instances aren't Prelude.
12:34:09 <Cale> Yeah, they should be in Prelude
12:34:12 <nand`> Cale: Thanks, that made it run. Mind explaining briefly what exactly is in Control.Monad.Instances?
12:34:17 <ash__> thoughtpolice: thanks
12:34:33 <dcoutts> doughsay: usually a problem in a custom Setup.hs script, would need more details to diagnose
12:35:00 <Cale> nand`: file:///usr/local/share/doc/ghc/html/libraries/base-4.3.1.0/src/Control-Monad-Instances.html
12:35:02 <Cale> errrr
12:35:05 <Cale> dang
12:35:22 <doughsay> dcoutts: it's "cabal install cairo"
12:35:22 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.3.1.0/src/Control-Monad-Instances.html
12:35:26 <Cale> there we go :)
12:36:25 <dcoutts> doughsay: oh, odd. What is the full command line you're using to install it?
12:37:30 <doughsay> dcoutts: that's really just it, nothing more.  "cabal install cairo".  i can try and get a screenshot of the output, can't copy and paste it from this dumb terminal
12:38:08 <dcoutts> doughsay: what does cabal --version say?
12:38:10 <nand`> Cale: Oh, I see what's happening now. Control.Applicative is defining an Applicative instance for ((->) r), but this relies on fmap; so it's failing because I haven't included the Functor instance for ((->) r), correct?
12:38:26 <applicative> no applicative requires functor
12:38:34 <nand`> oh
12:38:36 <nand`> right
12:38:40 <nand`> I forgot, it's in the definition
12:39:03 <doughsay> dcoutts: cabal-install version 0.10.2, version 1.10.1.0 of the cabal library
12:40:13 <saml> > trace "1" 1
12:40:14 <lambdabot>   Not in scope: `trace'
12:40:26 <doughsay> dcoutts: i found this as well, i can try something like this: http://stackoverflow.com/questions/6288942/cabal-install-glib-makes-error
12:41:55 <dcoutts> doughsay: ohh, if that SO question is right then yeah it's a problem in the Setup.hs, I'm surprised I've not seen that come up more often.
12:42:18 <applicative> nand` it strange, why doesn't it have the Functor instance available?
12:43:01 <ktosiek> Hi! I'm writing a simple snake game in wxHaskell, at the moment the game starts with the program and I have no way to make the snake die (it just stops moving until a valid direction is given if it would hit something in the next move)
12:43:10 <nand`> applicative: Solved already. Functor instance is in Control.Monad.Instances
12:43:12 <applicative> if you import Control.Monad.Instances as well it's okay
12:43:20 <applicative> yeah
12:43:23 <ktosiek> how do I organize pre/post game parts?
12:43:46 <applicative> Oh wait, I get it.  It's that <$> is associated with the Functor class
12:43:54 <monadic> Is there a way to profile my criterion benchmarks instead of rewriting them into a standalone main/wrapper main that can dispatch?
12:44:04 <nand`> no it's because class (Functor f) => Applicative f
12:44:10 <nand`> but that also
12:44:17 <ktosiek> (I want to have a screen with highscores + some way to choose speed/level/etc.)
12:44:22 <nand`> <$> is an otherwise identical infix version of `fmap` as far as I can tell
12:44:45 <monadic> neilk_: Yes, thats right
12:45:06 <EvanR> dcoutts: please make a note of that in your 'gotchas for windows' list ;)
12:45:10 <danharaj> the pattern is foo <$> bar <*> baz <*> blah
12:45:13 <HugoDaniel> anyone here develops the lambdacube ?
12:45:26 <danharaj> for fmapping functions that take multiple parameters
12:45:35 <danharaj> <$> gets you the first, <*> gets the rest
12:45:39 <monadic> And in terms of monads, that would be foo `liftM` bar `ap` baz `ap` blah.
12:46:11 <dcoutts> EvanR: :-) it used to be a lot harder to install, the version I used for a project a couple years ago was all a makefile based build system
12:46:15 <nand`> <$> is defined as <*>.pure, right?
12:47:07 <monadic> nand`: Don't see why it wouldn't be <$> = fmap
12:47:13 <byorgey> nand`: no, it's defined as fmap, but  f <$> x == pure f <*> x  is a law that Applicative instances should follow
12:47:30 <nand`> byorgey: monadic: Yeah I was going by the assumption that both are identical
12:47:36 <nand`> I just think it's cleaner to define the applicative in terms of itself
12:47:41 <danharaj> A real applicative instance makes them equivalent
12:47:53 <danharaj> one that doesn't is not really applicative.
12:48:08 <byorgey> nand`: well, but pragmatically speaking, defining <$> that way would require an Applicative instance for anything using it, which makes it less useful
12:48:18 <poisonarms> im just now getting into haskell, can anyone recommend essential reading?
12:48:38 <nand`> byorgey: Isn't <$> defined inside Applicative either way?
12:48:38 <EvanR> please read the monads are like burrito tutorials
12:48:39 <doughsay> dcoutts: editing Gtk2HsSetup.hs in the way SO suggested worked.  thanks for your help.
12:48:41 <monadic> nand`: How is that clearer? Anyway, it doesn't make sense, since <$> doesn't even involve applicative. I'm not sure why its in Control.Applicative
12:48:45 <byorgey> @where lyah
12:48:45 <lambdabot> http://www.learnyouahaskell.com/
12:48:46 <EvanR> poisonarms: ^
12:48:48 <monadic> :t <%>
12:48:49 <lambdabot> parse error on input `<%>'
12:48:53 <monadic> :t <$>
12:48:53 <lambdabot> parse error on input `<$>'
12:48:54 <dcoutts> doughsay: great
12:49:01 <monadic> :t (Control.Monad.<$>)
12:49:02 <lambdabot> Not in scope: `Control.Monad.<$>'
12:49:04 <danharaj> monadic: because it's used in conjunction with <*> most of the time.
12:49:04 <monadic> wow I'm bad at this
12:49:09 <monadic> :t (Control.Applicative.<$>)
12:49:10 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:49:12 <monadic> there
12:49:12 <sp3ctum> i just started too, i started reading that book, it's very good!
12:49:13 <monadic> see
12:49:16 <monadic> Functor, not Applicative. Functor.
12:49:22 <nand`> I see
12:49:27 <poisonarms> thanks guys
12:49:28 <danharaj> poisonarms: Write Yourself a Scheme in 48 Hours
12:49:35 <danharaj> It's a 'real' project.
12:49:36 <nand`> I thought <$> was for applicatives only due to it being in Control.Applicative
12:49:45 <danharaj> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
12:49:52 <poisonarms> danharaj: what do you mean, haha
12:49:52 <applicative> isnt it defined in Data.Functor?
12:49:53 <byorgey> nand`: <$> is defined in Control.Applicative which means you must import that module to use it.  But it still has the type  Functor f => (a -> b) -> f a -> f b
12:50:05 <byorgey> nand`: as opposed to  Applicative f => (a -> b) -> f a -> f b
12:50:15 <nand`> byorgey: Aren't the modules laid out a bit badly if that is the case
12:50:25 <EvanR> dcoutts: k so if all the 'g' packages for windows are broken, something needs to be done about it
12:50:34 <monadic> <$> is also in Data.Functor.
12:50:40 <nand`> oh
12:50:43 <applicative> <$> is imported from Data.Functor
12:50:44 <nand`> duplicated for convenience?
12:50:45 <EvanR> i wonder whos in charge of that
12:51:23 <danharaj> Wait people actually use Data.Functor?
12:51:28 <byorgey> nand`: yeah, historically, <$> arose first because of its idiomatic usefulness with applicatives in  f <$> x <*> y <*> z ...
12:51:51 <monadic> danharaj: I imagine most people just import Control.Applicative. But I don't see anything wrong with Data.Functor if you need <$> but not <*> or pure.
12:52:35 <danharaj> I don't think I've seen a use of <$> outside of ( a <$> b <*> c ...) that was more readable than fmap.
12:52:57 <monadic> danharaj: a `fmap` b <*> c is just as readable
12:53:13 <nand`> Is there any reason to use “map” or “fmap” over <$>?
12:53:16 <nand`> I think <$> looks nicer
12:53:17 <nand`> but that's just me
12:53:19 <dylukes> danharaj: Sometimes I use it for parser combinators, where I'm boxing the result in my own datatype. For instance
12:53:31 <dcoutts> EvanR: standard thing for gtk2hs on windows is to use the installer rather than building from source, since it needs a rather careful setup of the gtk+ development sources anyway
12:53:31 <dylukes> NumberAST <$> … parser …
12:53:38 <dylukes> the <$> aligns with the <|> on the next line and such.
12:53:41 <dylukes> It often looks prettier.
12:53:42 <monadic> nand`: I think <$> is nicer than fmap as infix only. I like map better than <$> for lists most of the time though, since you don't use it infix
12:53:48 <danharaj> dylukes: yeah, <$> is 'combinator style'.
12:53:50 <dylukes> monadic: ^
12:54:03 <dylukes> What is the formal definition of a combinator?...
12:54:07 <dylukes> something I should probably know.
12:54:15 <danharaj> I doubt there's one
12:54:17 <dcoutts> EvanR: but yes, it should "just work" on windows, I agree. It's not hard it just requires developer time.
12:54:18 <danharaj> well I mean there is
12:54:20 <nand`> monadic: Well, stuff like “f <$> [1..10]” has a nice ring to it
12:54:26 <danharaj> but those combinators are different
12:54:27 <nand`> monadic: I sort of read it as “f over [1..10]”
12:54:40 <dylukes> nand`: I certainly prefer fmap there :\
12:54:47 <dylukes> Beides <$> is obnoxious with operators like $.
12:54:50 <dylukes> I.e you have to do
12:54:56 <dylukes> Something <$> ( … )
12:54:57 <EvanR> dcoutts: that change to the setup file, is it compatible with linux
12:54:59 <danharaj> nand`: If you put that inside an expression with binary operations, operator precedence might mess things up.
12:55:08 <dylukes> instead of fmap Something $ ....
12:55:10 <danharaj> especially if you're using `$'
12:55:12 <dcoutts> EvanR: indeed
12:55:16 <doughsay> dcoutts: according to http://projects.haskell.org/gtk2hs/download/, there is not installer for windows.  the instructions provided there are what i'm following.
12:55:39 <dylukes> So, I'm reading Bananas, Lenses, Envelopes and Barbed Wire...
12:55:51 <dylukes> a hylomorphism is just anamorphism + catamorphism?
12:56:00 <augur> iinm, syb only lets you scrap boiler plate when the target type is unique inside a data structure, yes?
12:56:01 <dylukes> in other words, something that builds up a structure and then condenses it?
12:56:09 <augur> forcing you to use wrapper types a lot
12:56:13 <dylukes> The factorial example makes sense to me I guess,
12:56:15 <codolio> A combinator is a function whose definition is of the form 'f <vs> = <expression involving vs and other combinators only>'.
12:56:33 <shachaf> @google hylomorphism computer science
12:56:34 <lambdabot> http://en.wikipedia.org/wiki/Hylomorphism_(computer_science)
12:56:34 <lambdabot> Title: Hylomorphism (computer science) - Wikipedia, the free encyclopedia
12:56:54 <nand`> danharaj: True enough. I'll try to stick to fmap where possible to avoid code golf
12:56:55 <codolio> So, S f g x = f x (g x) is a combinator.
12:57:01 <augur> eg if you want to have a tree with two Int slots, but syb over one of them, you have to at least make that one some synonymous other type, no?
12:57:04 <nand`> but I'm a fan of elitism so yeah
12:57:14 <shachaf> When are we getting @bing in lambdabot?
12:57:15 <monadic> something that has an operation that combines two of them?
12:57:15 <monadic> which I imagine is just an Applicative instance...
12:57:17 <monadic> codolio: Yeah, since function application is applicative
12:57:18 <augur> or well, not synonymous but newtyped
12:57:20 <poisonarms> so was haskell written intended to be a replacement for lisp/scheme or something?
12:57:30 <poisonarms> i see a lot of talk on haskell related websites about lisp and scheme
12:57:43 <codolio> N f = f (\x y -> x) (\f g x -> f x (g x)) is not a combinator on its own.
12:58:04 <augur> poisonarms: lisp/scheme is the other historically major functional language
12:58:13 <monadic> poisonarms: No? They are related though since they are both functional. More so than say, Haskell vs Pascal.
12:58:27 <EvanR> lisp <-> php, haskell <-> c
12:58:29 <codolio> Hence why claims of "one combinator bases" are incorrect.
12:58:31 <EvanR> or something
12:59:12 <nand`> Ironically, haskell is a super-set of lisp and lisp is a super-set of haskell. I don't quite know how that works out
12:59:23 <EvanR> nand`: error
12:59:25 <nand`> well
12:59:26 <nand`> no
12:59:28 <poisonarms> what are some notable applications written in haskell?
12:59:30 <nand`> lisp + macros is a super-set of haskell
12:59:30 <EvanR> unless they are the same set
12:59:34 <nand`> poisonarms: xmonad
12:59:40 <dylukes> Lisp + Macros is a subset of everything. :|
12:59:59 <nand`> lisp with macros can turn the english language into a valid programming language if you so desire
13:00:00 <nand`> but yeah
13:00:04 <EvanR> poisonarms: ghc
13:00:07 <nand`> that's still pointless imo, since you can just use haskell
13:00:09 <augur> dolio: is that to say that iota isnt actually a one combinator syste,?
13:00:09 <dylukes> You've got lambda calculus and a mechanism for direct substituions.
13:00:22 <augur> or just that applicatives arent? :P
13:00:24 <monadic> I don't understand why show isn't Show a => String -> Maybe a... or there isn't a showMaybe function...
13:00:29 <augur> im not following your discussion x3
13:00:31 <joe6> i am getting these errors at different run times in the same program. *** Exception: Prelude.tail: empty list . could it point to some kind of memory leak?
13:00:37 <dylukes> Is a "system of combinators" and "algebra"?
13:00:41 <monadic> poisonarms: xmonad
13:00:43 <joe6> i am sifting through a lot of files and data.
13:00:44 <dylukes> The definition of the word "algebra" is confusing me a lot.
13:00:47 <dolio> augur: Right, if it's the one I'm thinking of.
13:01:12 <dolio> augur: The usual one-combinator basis is something like "Jf = fSK", but you need to define S and K before you can define J to make it a combinator.
13:01:13 <monadic> joe6: An empty list has no tail, since tail is tail (x:xs) = xs. Nothing to do with a memory leak, its a failure in your program. Fix your code.
13:01:13 <augur> dolio: the semantics of iota is usually defined in terms of S and K, but its still a one combinator system
13:01:14 <joe6> given that it is happening at different places, I am beginning to think that it coud be the ghc
13:01:25 <nand`> Overall I think lisp, especially scheme, is better for purely functional thinking -> you have to implement everything from scratch, it's a new experience for most. Haskell on the other hand bases on existing functional knowledge and provides a powerful language to use with a very flexible type-system and advanced constructs built-in to the syntax and stdlib
13:01:29 <joe6> monadic, ok, thanks.
13:01:30 <nand`> I think haskell is more real-world oriented
13:01:38 <augur> in the same way that S and K are defined, often enough, in terms of lambda terms
13:01:45 <monadic> nand`: Nah, its research oriented
13:01:53 <monadic> nand`: But that doesn't mean its not useful in the real world ;)
13:01:59 <dylukes> I do wish scheme was more strongly typed.
13:02:00 <dylukes> :\
13:02:02 <dolio> Combinators can't have lambda terms in their definition.
13:02:02 <augur> the question is whether or not you can do without the definition in terms of S and K
13:02:08 <augur> dolio: no, but they _can_
13:02:11 <dolio> That is the definition of combinators.
13:02:11 <dylukes> and statically typed would be nice.
13:02:20 <dylukes> Statically typed macros are feasible I suppose.
13:02:35 <monadic> Ugh typing in lisp would be ugly
13:02:41 <monadic> It doesn't have enough syntax for it...
13:02:49 <clsmith> hey all. if i have a type R = (P,P,D,D), and i create a (P,P,D,D), why can't haskell match it with "expected type `R'"?
13:02:55 <dylukes> You can define any amount of syntax you like.
13:02:57 <EvanR> dolio: not sure if there is 'the' one definition of combinators
13:03:00 <augur> i mean, its not uncommon to explain S and K in terms of \f p x -> (f p) (x p) and \x y -> x
13:03:03 <dylukes> Actually, you could just make a (define-typed ...
13:03:05 <nand`> The beaty in lisp relies on its highly regular syntax. With anything more complex than what it currently is, it would quickly turn into an abomination
13:03:11 <dylukes> that takes an extra sexp of the form a -> b ...
13:03:12 <dylukes> ie
13:03:22 <joe6> monadic: the same program runs fine if I run it again. hence, the thought that it could be a memory leak or something.
13:03:25 <augur> dolio: its just a question of whether or not such definitions are necessary. for SKI, its not, right
13:03:27 <dylukes> (define-typed (number -> number -> number) add (lambda (a b) (+ a b)))
13:03:31 <EvanR> nand`: what i dont like about lisp syntax is... different things dont look different
13:03:33 <dylukes> wouldn't be that unpleasant.
13:03:36 <augur> you just define by reduction rules
13:03:37 <EvanR> i.e. special forms
13:03:40 <monadic> joe6: Are you using something ugly like unsafePerformIO or random numbers?
13:03:54 <yip> did people see this?
13:03:54 <yip> http://bartoszmilewski.wordpress.com/2011/07/11/monads-in-c/
13:04:07 <dolio> augur: That such a definition is possible is why they get to be called combinators.
13:04:11 <monadic> joe6: That sounds like either you are using unsafe functions improperly or ghc is compiling wrong, and highly doubt the latter.
13:04:17 <joe6> monadic, other than currentTime and System.IO.Strict
13:04:22 <nand`> EvanR: To some, that's part of the beauty. I'm personally not a fan of highly uniform syntax either
13:04:24 <augur> dolio: yes, but you have to show that iota is NOT definable purely as reduction rules
13:04:36 <joe6> i am reading a lot of data. I am not sure if that can cause something like that.
13:04:43 <dolio> augur: No. You have to show that it is to prove that there is a one-combinator basis.
13:04:44 <joe6> a few MB, not GB though.
13:04:45 <EvanR> yip: thats offensive. you go to that url and it turns out to be 'monads in c++'
13:04:56 <monadic> joe6: Don't see why reading a lot of data causes an empty list
13:04:57 <EvanR> its like a rick roll almost
13:05:05 <dylukes> Hm, I just had a fun little brainfart.
13:05:10 <augur> dolio: i suppose. i mean, it'd've been better if barker had done that, yeah
13:05:15 <monadic> joe6: Can you hpaste relevant code?
13:05:18 <danharaj> oh that link
13:05:23 <dylukes> In ObjC its possible to get the name of a method by introspection, as well as the parameter types.
13:05:26 <danharaj> a lot of stupid comments on the reddit link to that blog post
13:05:29 <dylukes> I should be able to make a curry'er.
13:05:36 <dylukes> I'm going to go try this~
13:06:06 <augur> i mean, i dont know if iota really is validly a single combinator system or not, im just saying that to claim flat out that its not suggests that you have a proof that its not
13:06:14 <joe6> monadic, ok. will trace and see if I can come up with something
13:06:20 <augur> whereas simply saying "the definition barker gave is in terms of S and K!" is not a proof
13:06:21 <joe6> monadic: before bothering you with the code
13:06:30 <augur> its just a complaint that his definition is in terms of some other system
13:06:31 <monadic> joe6: No bother, it fills up time ;
13:06:42 <augur> which itself is only a proof that its cheaper to do it that way
13:06:54 <augur> or cheap enough, in terms of definitional space
13:07:00 <joe6> nand`: lisp is history. agda'ish is the future. haskell is the present.
13:07:07 <augur> for all we know iota can be defined as a one-combinator system but you need 50 reduction rules
13:07:24 <joe6> nand`: IMHO
13:07:24 <dolio> Fine. iota x = ?
13:07:35 <dolio> What goes on the left? It can only contain x.
13:07:48 <augur> dolio: it can only contain iota, you mean
13:07:48 <dolio> Er, the right.
13:08:16 <monadic> unlambda is the future, you fools
13:08:16 <augur> like i said, i dont know what goes on the left. maybe there are indeed things that can go there
13:08:18 <augur> im not sure
13:09:28 <augur> you need to prove that there are an infinite number of cases for iota
13:09:39 <augur> if there is a finite number of cases, even absurdly large, then iota is a one combinator system
13:11:54 <dolio> My claim that iota isn't a one combinator basis is based on my viewing that as a very unlikely-to-be-solvable situation.
13:12:14 <dolio> Go ahead and solve it if you want to change my mind.
13:12:40 <nus> err, define 'combinator'?
13:12:42 <augur> i would prefer if it you had a formal proof that its not possible to define iota with a finite number of cases :)
13:13:10 <augur> nus: combinators are syncategorematic objects that control how a string is rewritten
13:13:36 <nus> whatmatic?
13:14:06 <augur> syncategorematic -- purely ways of combining things, not things in and of themselves
13:14:27 <augur> tho i suppose in the case of SKI, its syncategorematicity all the way down
13:19:08 <monadic> So back to my original question that got overrun in the whole thing about combinators - is there a way to profile criterion benchmarks?
13:19:33 <augur> monadic: there is using combinators!
13:19:36 <augur> x3
13:23:09 <nus> augur, seems to translate to: you need two languages to combine things, one in which could you describe 'things' and other in which you couldn't
13:23:23 <augur> nus: what?
13:23:36 <nus> re syncategorematic
13:23:41 <augur> oh, no not at all
13:23:54 <augur> you just need two classes of things in your language
13:23:58 <augur> combiners and combined
13:24:49 <augur> for instance, parentheses are syncategorematic objects in haskell's grammar
13:25:12 <augur> they dont form substantive pieces of the syntax, they're just there to tell you how you're combining things.
13:25:26 <nus> hold your horses (-:, let's quibble if you call two classes a language or two languages
13:25:33 <augur> they have no denotations.
13:26:06 <augur> thats not to say you couldnt give them denotations. i doubt you could but who knows. many syncategorematic things can be given denotations in a different system
13:26:28 <augur> for instance, in the tarski language, & is syncategorematic -- it has no meaning, its jus a directive to the evaluation procedure
13:26:47 <augur> sort of like, eval (p :&: q) = eval p && eval q
13:27:18 <nus> @type ()
13:27:18 <lambdabot> ()
13:27:23 <augur> eval :&: is just nonsense, :&: is just a way of combining things, not some substantive object itselve
13:27:34 <augur> combinators can be see as similar
13:27:40 <augur> eval (K x y) = x
13:27:45 <nus> @src ()
13:27:45 <lambdabot> data () = ()
13:27:56 <nus> is that a 'substance'?
13:28:15 <augur> who knows :)
13:28:35 <augur> im not really trying to give a thorough answer, just a rough answer
13:28:54 <augur> you can get into deeper questions like "what is substantivity" but im not sure there is an answer to that
13:29:00 <EvanR> augur: youre not a substantive object
13:29:12 <augur> is :&: substantive in the definition above? who knows. its not given a denotation, but...
13:29:18 <augur> EvanR: no u :|
13:30:12 <nus> augur, I'm trying to nudge you to the conclusion that when you used 'syncategorematic' you were dangerously close to philosophy (-;
13:30:36 <augur> nus: oh im well beyond dangerous closeness
13:30:51 <augur> the term itself comes, iinm, from philosophical logic
13:31:02 <joe6> monadic, it was a screw-up in my code.
13:31:19 <augur> and my reference to tarski cements this discussion in philosophical domains
13:31:40 <monadic> joe6: Okay
13:31:46 <augur> theres a whole literature on the question of the substance of syncategorematic things, nus
13:31:55 <augur> the question of logicality, etc.
13:32:21 <jonkri> i don't get the Cookie Size section (third paragraph) of http://happstack.com/docs/crashcourse/RqData.html... why would you send the cookie along with the images? surely happstack applications must be easily customized to only send cookies on certain requests?
13:35:48 <Saizan> jonkri: it's the client that sends cookies back to the server
13:38:03 <jonkri> oh...
13:38:39 <jonkri> then i'm happy :)
13:45:51 <tgeeky_> what's with all of the recent hackage build failures?
13:46:36 <dpratt71> newb question: how should one compile in GHC (i.e. with what flags) if one is trying to evaluate the performance of some code?
13:46:39 <monadic> tgeeky_: Err, people posting bad code to hackage?
13:46:48 <tgeeky_> monadic: maybe
13:46:55 <tgeeky_> cabal: There is no available version of web-routes that satisfies ==0.25.2
13:47:12 <monadic> dpratt71: I don't think you need to compile GHC with anything special, but for the program use -prof as well as possible -auto-all and -caf-all.
13:47:21 <tgeeky_> in the package web-routes 0.25.2
13:47:26 <monadic> dpratt71: Oh, and -rtsopts
13:47:37 <monadic> dpratt71: Then you can use +RTS -p when you run the code.
13:48:08 <dpratt71> monadic: ok, I'll give that a go, thanks!
13:48:44 <monadic> dpratt71: Wait, by evaluate do you mean profile to find the failure or just benchmark?
13:48:55 <monadic> dpratt71: For benchmarking, you don't need anything special. Just check out criterion.
13:48:59 <dpratt71> monadic: benchmark
13:49:37 <monadic> dpratt71: http://hackage.haskell.org/package/criterion-0.5.0.10
13:49:56 <dpratt71> monadic: checking it out, thanks again
13:50:22 <benmachine> tgeeky_: that is weird.
13:51:00 <tgeeky_> same thing with hbro
13:51:09 <tgeeky_> even better
13:51:09 <tgeeky_> http://hackage.haskell.org/packages/archive/toolshed/0.11.1.0/logs/failure/ghc-7.0
13:51:23 <dylukes> Thoughts?
13:51:24 <dylukes> https://gist.github.com/1078963
13:51:39 <dylukes> I haven't implemented curry yet, but, it all typechecks.
13:52:51 <dylukes> A prize to anyone who can make this work in pure C/Objective-C without casting!
13:59:05 <argiopeweb> Is there a general standard for the creation of hierarchical module names for libraries designed to be used internally to a company which don't fit into the existing categories (such as the com.yadda.yadda.yourapphere seen in Java)?
14:01:07 <jonkri> is there somehow i can have a happstack-server route function somehow return a file OR a String? it currently has the type ServerPart String, but i can't figure out how to put serveFile in there
14:01:24 <jonkri> route function = a ServerPart response handler
14:10:54 <jonkri> i guess i'll have to use Reponse instead
14:11:32 <Evious> I'm thinking about implementing a "where"-like syntax in another functional language, and am trying to understand what makes it tick in Haskell. How is the order of evaluation in where defined?
14:11:53 <companion_cube> Evious: there is no order of evaluation
14:12:01 <companion_cube> evaluation is lazy
14:12:22 <benmachine> where can always be translated into let
14:12:31 <benmachine> it is just a convenience
14:12:42 <benmachine> the order of evaluation in let is sometimes called outermost-first?
14:24:35 <Evious> So in "foo where a=b;c=d;..." evaluation order of a/c/... depends lazily on how they're used inside foo. Including any effects.
14:24:58 <EvanR> there shouldnt be any effects?
14:31:07 <Cale> Evious: Not a problem since there are no effects.
14:31:25 <Cale> Evious: (but if you're using magic stuff like Debug.Trace, then yes.)
14:32:06 <Cale> Evaluation order is up to the implementation to determine.
14:32:23 <Cale> The compiler can reorder evaluation all it wants as long as it doesn't change the result of the program.
14:32:33 <Cale> (or termination behaviour, of course)
14:32:44 <Evious> I guess I don't remember seeing where used with :: IO a code.
14:33:04 <Cale> The execution of IO actions is separate from their evaluation.
14:33:11 <benmachine> Evious: that's still fine because the order in which IO is done is... yes that
14:33:20 <Cale> (execution is what's ordered, evaluation can be in any order)
14:33:29 <benmachine> determined by do-notation or >> rather than by when things are or aren't evaluation
14:33:33 <benmachine> er evaluated
14:34:21 <Evious> So evaluation can be in any order, as long as execution order is maintained. And the compiler can do this because the types tell it what executes actions, and what doesn't?
14:35:07 <Cale> Evaluation is the process of turning expressions into values, execution is the process of taking IO action values, and actually carrying out the effects they describe.
14:35:28 <HugoDaniel> :)
14:35:43 <Cale> Evaluating an IO action doesn't cause any of its effects to happen, any more than loading a program in a text editor and looking at it causes that program to execute.
14:36:00 <Evious> So a Haskell interpreter would have two stages, an eval::[Exp]->[Val] and an execute::[Val]->IO () ?
14:36:06 <Cale> Something like that
14:36:44 <benmachine> we don't mind when eval happens, as long as we get our list of Vals
14:36:55 <benmachine> and it doesn't make any difference when eval happens as to what the order of the produced list is
14:37:24 * Saizan wonders why lists there
14:37:36 <benmachine> in retrospect that was a perverse way of structuring that sentence
14:37:39 <Cale> (probably not lists as such, but schematically, that's not too bad)
14:37:43 <benmachine> please excuse me from talking ever
14:37:44 <Evious> And if an IO action reads from the outside world... Then lazy evaluation means evaluation doesn't progress beyond a certain point until the information it reads is available?
14:38:29 <sipa> an io action being evaluates remains an io action
14:38:54 <sipa> its evaluation is lazy, but independent from its execution
14:38:58 <Cale> Evious: There are some magical IO actions like readFile and getContents which confusingly produce lazy streams (which do actual reading when the string is consumed), and it's best not to be distracted by those.
14:39:34 <Cale> For the most part, all the I/O effects happen before the result of the IO action is available.
14:40:03 <hpc> (ignoring threading too)
14:40:35 <Evious> But in short, Haskell's 'where' syntax is more than just "definitions come after usage, not before" sugar. And isn't easily re-implementable in another language.
14:42:09 <Evious> Which is annoying, because not caring about the order my pure functions are evaluated in may be the main reason I like "where".
14:42:32 <benmachine> Evious: huh? when did you get that idea? :P
14:42:43 <sipa> lazy evaluation has nothinf
14:42:54 <hpc> where gets desugared to let-in
14:43:04 <benmachine> Evious: if you got rid of where completely, you'd not lose any expressivity
14:43:05 <sipa> nothing to do with a syntactic construct?
14:43:07 <benmachine> only convenience
14:43:40 <Evious> benmachine, I'm trying to figure out why my Erlang code isn't as elegant as my Haskell code, and what syntax sugar I can implement in Lisp Flavored Erlang to bring the two closer together.
14:43:53 <Evious> I'm pretty much grasping at straws.
14:44:15 <benmachine> Evious: once you have let ... in ..., where is basically the same
14:45:02 <shachaf> seen aavogt
14:45:08 <shachaf> preflex: seen aavogt
14:45:09 <preflex>  aavogt was last seen on #haskell 17 hours, 47 minutes and 26 seconds ago, saying: @hoogle TypeCast
14:48:47 <Evious> benmachine, to implement Haskell-like let ... in ..., I'd need to force it to not do side effects when evaluating let. Otherwise the order that stuff is defined in becomes important.
14:49:50 <benmachine> Evious: it depends how haskell-like you want it to be, you could just *make* the order important
14:50:09 <benmachine> adding small amounts of laziness to an otherwise strict language sounds awkward
14:52:42 <Evious> Making the order unimportant, and suggesting that the definitions are kept pure if at all possible, seems like a reasonable approach. Dynamically typed languages can rely on conventions.
14:54:15 <benmachine> Evious: that sounds tricky to implement imo... good luck I guess :P
14:55:02 <Evious> Fun though! Scraping the symbols used, checking for dependencies, rearranging in an acceptable order and pruning unused ones!
14:57:09 <jonkri> is there a way to hide modules from the Modules section of the haddock index that works on hackage?
14:57:28 <d7> So I was reading reddit—a turrible mistake, I know— and someone brought up that in haskell monads are not functors.
14:57:47 <hpc> this is true, depending on how you prefer to think
14:58:04 <hpc> haskell monads are not required to be functors, but there is an implementation for every monad, fmap = liftM
14:58:04 <d7> The only reasons I could think of for why this might be written this way
14:58:06 <d7> 1. Historical
14:58:11 <hpc> correct
14:58:38 <d7> 2. Because when you start loading type constraints on top of type classes, the compiler can get pretty antsy with you.
14:59:13 <hpc> nope; ghc is totally cool with applicative requiring functor
14:59:16 <c_wraith> superclasses are common enough.  It's just historical
15:00:04 <d7> Ah
15:01:41 <augur> http://okmij.org/ftp/gengo/NASSLLI10/index.html
15:01:51 <augur> what does he mean by "regions" and "staging"?
15:02:47 <d7> This was the thread that had the guy calling haskell's use of monads "cargo cult math"
15:03:07 <hpc> haha
15:03:28 <hpc> if only there were enough people who practiced enough advanced math for cargo cults to be able to form
15:03:37 <ion> Updated <http://heh.fi/haskell/functors>. An example of the relationships between various functor/applicative/monad operators. Corrections to errors are appreciated.
15:03:39 <d7> True story.
15:04:21 <d7> ion: makes me wish RWH had a more updated chapter on applicatives and how to use them. I feel like I've been conditioned to reach for monads too much.
15:05:19 <d7> Is there like an awesome applicative functor boot camp blogpost/document/paper somewhere?
15:05:34 <benmachine> @where typeclassopedia
15:05:34 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
15:08:03 <MHD> I'm making a GLFW-RAW package, just an FYI
15:08:27 <Eduard_Munteanu> augur: maybe as in region inference? I'm not sure, it looks like a heterogenous enumeration what he said.
15:08:35 <HugoDaniel> MHD: why ?
15:08:42 <augur> Eduard_Munteanu: ??
15:09:03 <MHD> HugoDaniel: Because GLFW and GLFW-b are, quite frankly, bad.
15:09:08 <HugoDaniel> eheh true
15:09:15 <HugoDaniel> btw, check out my GLHUI :)
15:09:25 <HugoDaniel> if your are running linux, it might be the minimalist approach
15:10:23 <MHD> That's pretty cool
15:10:26 <Eduard_Munteanu> augur: I mean having both "side effects" and "dependent types" in the same enumeration made me think the concepts he's enumerating aren't really related.
15:10:30 <MHD> But alas, I am not yet on Linux
15:11:01 <d7> benmachine: Ty
15:11:28 <MHD> HugoDaniel: GLFW is also, while still lightweight, a bit more finely tunable
15:11:29 <Eduard_Munteanu> http://en.wikipedia.org/wiki/Region-based_memory_management
15:12:55 <HugoDaniel> yeah
15:13:41 <MHD> HugoDaniel: And then there's the ability to get Ctrl, Alt and Shift as separate button presses.
15:14:11 <thoughtpolice> augur: oleg isn't quite talking about region inference, which is a memory reclamation strategy
15:14:32 <thoughtpolice> augur: the tl;dr of it is that regions are a way to define the scope of a resource, and statically ensure it can't be leaked beyond that. there are haskell packages that do this already
15:14:44 <augur> oookay
15:14:47 <thoughtpolice> like bas's 'regions' package
15:14:57 <Eduard_Munteanu> Oh.
15:15:00 <thoughtpolice> so you can ensure for example, a file handle cannot be leaked outside of it's accompanying region
15:15:07 <thoughtpolice> (oleg wrote a few things about this.)
15:15:11 <thoughtpolice> although you can do things like nest regions
15:15:24 <thoughtpolice> bas has several packages that add region-support to things like Ptr's in Foreign, for example
15:16:40 <HugoDaniel> MHD: i like the GLFW approach to a binding :)
15:16:43 <thoughtpolice> augur: when he says 'staging', he means 'staged metaprogramming' basically, where you effectively have parts of your program computed in 'stages'
15:16:50 <thoughtpolice> he's also written some stuff about this too
15:17:03 <HugoDaniel> it compiles the lib and provides the ffi functions
15:17:07 <thoughtpolice> augur: for staging, i'd recommend you google 'MetaOCaml', which adds staging computation to OCaml. it's basically the main implementation
15:17:25 <MHD> HugoDaniel: I'll be aiming more fore a GLUT approach when I make a proper haskellized GLFW for use in my games...
15:17:26 <HugoDaniel> that way you get a static file that doesn't depend from a possibily installed lib on the system
15:17:39 <thoughtpolice> oleg recently released a 'newer' version of MetaOCaml, called BER Ocaml, that's a much simpler distribution and implementation (although it's distributed as a set of patches to the main ocaml source :/)
15:17:41 <HugoDaniel> which is always my pain in creating redistributable linux binaries :/
15:18:08 <thoughtpolice> augur: http://www.cs.rutgers.edu/~ccshan/capability/region-io.pdf
15:18:25 <thoughtpolice> the formulation in bas's package is a bit different and easier to grok than oleg's implementation in that paper though
15:18:42 <augur> way over my head
15:18:52 <thoughtpolice> augur: that's actually one of his easier to grok papers IMO
15:18:57 <augur> :P
15:19:08 <thoughtpolice> regions and iteratees are his two ideas i think really are quite useful and understandable by most (honestly! :P)
15:19:19 <thoughtpolice> no question there are others that are also quite useful
15:19:26 <thoughtpolice> not necessarily understandable, at least by me though
15:19:27 <thoughtpolice> :P
15:38:26 <EvanR> 16:41 < Cale> For the most part, all the I/O effects happen before the result  of the IO action is available.
15:38:41 <EvanR> Cale: i disagree, what about beginGlobalWarming :: IO ()
15:40:45 <wli> EvanR: Perhaps a meaningful variation on haltAndCatchFire
15:40:48 <ion> The effect of beginGlobalWarming is to trigger the beginning of the global warming. When said triggering has been done, the action is done.
15:40:54 <EvanR> lol
15:41:13 <EvanR> crashInFiveSeconds
15:44:35 <Eduard_Munteanu> quitAndGoToSleep
15:47:01 <ion> putStrLn may very well return before a network has transferred the bytes to your ssh client, your ssh client has handled the packets, your terminal has told your display to emit appropriate photons and the photons sent from Earth have reached your eyes on Jupiter where you happen to be hanging out.
16:05:12 <Phyx-> with cpphs, is there a way to make it not produce whitespaces in the place where an #ifdef was false?
16:36:05 <HugoDaniel> there seems to be loads of frp packages on hackage
16:36:10 <HugoDaniel> can anyone recomend me one ?
16:38:41 <ddarius> HugoDaniel: None of them.
16:39:13 <djahandarie> ddarius, type error.
16:42:06 <HugoDaniel> ddarius: im looking at elerea
16:42:30 <ddarius> elerea ∉ {}
16:45:09 <HugoDaniel> :D
16:45:19 <HugoDaniel> why none ?
16:45:20 <mm_freak> HugoDaniel: incidently i'm right now experimenting with Animas, which is a fork of yampa
16:45:24 <mm_freak> i'm loving it so far
16:45:37 <HugoDaniel> :D
16:45:46 <HugoDaniel> yampa always seemed a bit too much for me
16:45:51 <HugoDaniel> im not that smart
16:46:08 <mm_freak> it's not so difficult, and in fact pretty intuitive
16:46:18 <mm_freak> you just move from signals to signal functions
16:47:16 <bobzhang> hi. is or patterns supported in haskell? thanks~
16:47:44 <ion> Left ParseError
16:47:51 <HugoDaniel> :D
16:48:46 <mm_freak> bobzhang: can you rephrase the question?  i'm seeing at least two people having parse errors =)
16:49:26 <nus> what's an 'or pattern'?
16:50:38 <mm_freak> anyway i tried with yampa, and i liked to concept, but the library never seemed quite mature enough…  animas seems to be a major improvement
16:52:04 <liyang> HugoDaniel: reactive is quite nice, but I haven't used it for anything major.
16:58:47 <bobzhang> mm_freak: thank you. I mean `combined patterns' in ML,
16:59:39 <bobzhang> like data T = A Int |B Str | C V
16:59:51 <bobzhang> (A _ | B _) is also a pattern
17:00:09 <mm_freak> not directly
17:00:48 <ion> How would this behave? (\(A a | B b) -> a) B "foo"
17:00:59 <mm_freak> case x of { A _ -> handleAB; B _ -> handleAB; C _ -> handleC }; where handleAB = …
17:01:00 <ion> (\(A a | B b) -> a) (B "foo")
17:01:23 <bobzhang> yea, handleAB is replicated
17:01:32 <mm_freak> direct combined patterns are semantically illdefined, as ion shows
17:02:00 <bobzhang> no, or patterns should not introduce different variables
17:02:21 <mm_freak> they can't produce any variables in the example you gave
17:02:38 <bobzhang> and the same variable shall have the same type
17:02:53 <mm_freak> bottom line is:  haskell doesn't support that
17:03:10 <mm_freak> to get around code duplication write a function like handleAB
17:03:12 <bobzhang> mm_freak: I see, thank you ~
17:03:21 <bobzhang> how to avoid such duplication?
17:03:30 <mm_freak> or write a predicate, which you can use in a guard
17:03:55 <mm_freak> case x' of x | isAorB x -> …
17:04:05 <mm_freak> i'd prefer the other solution though
17:04:08 <bobzhang> oh, i see
17:05:19 <mm_freak> (shorter:  case x of _ | isAorB x -> …)
17:05:40 <Axman6> or case x of A y -> Just y; B y -> Just y; _ -> Nothing, this also makes sure the y's are the same type
17:06:12 <mm_freak> Axman6: handleAB gives the same guarantee without having to go through Maybe
17:06:28 <Axman6> that's the type of handleAB?
17:06:38 <mm_freak> case x of A y -> handleAB y; B y -> handleAB y
17:07:28 <mm_freak> in do-blocks the Maybe variant is a bit inconvenient, unless you use MaybeT instead of Maybe
17:07:34 <Axman6> that works too i guess, but my way can be split out into another function that can be used elsewhere
17:07:35 <augur> what are some none (->) arrows that are relatively simple?
17:07:47 <ion> The type was: data T = A Integer | B String | C V
17:07:53 <mm_freak> augur: Kleisli
17:08:05 <augur> besides monad arrows?
17:09:18 <mm_freak> augur: i think other arrows are special purpose
17:09:24 <augur> ok
17:09:39 <mm_freak> there is an arrow-based parsing library (PArrows)
17:10:01 <mm_freak> but the arrow interface is really only for internal purposes there
17:10:20 <mm_freak> other than that yampa/animas use arrows for signal mutation functions
17:10:38 <mm_freak> in the latter example the arrow interface makes sense
17:10:39 <luite_> HXT uses arows that are user-visible
17:10:42 <augur> i was just curious if there were other useful things that arrows can do, without getting to complicated
17:10:55 <mm_freak> (in the former it does, too, but not visibly)
17:10:56 <luite_> but it's not exactly simple
17:12:05 <mm_freak> i think arrows are really a special purpose construct…  i can't think of any sensible general purpose instance other than (->) and Kleisli
17:16:46 <edwardk> mm_freak: they can help with frp space leaks
17:17:16 <edwardk> mm_freak: they also make for a nice encoding of linear mappings and continuous functions in some toy code of mine
17:18:13 <edwardk> mm_freak: also arrow/applicative based parsing can be more efficient than the monoidal case, because you can do things like analyze what the next symbol each 'live' parser wants to consume.
17:18:24 <edwardk> er s/monoidal/monadic/
17:26:00 <mm_freak> edwardk: yes, as said, those uses of arrows have benefits invisible to the user
17:26:41 <mm_freak> (->), Kleisli and SF (animas) use arrows for concept/expressiveness
17:26:49 <mm_freak> i don't know about HXT
17:27:59 <luite_> HXT uses arrows to make selectors / filters for XML nodes
17:35:41 <othiym23> :t pure
17:35:41 <lambdabot> othiym23: You have 1 new message. '/msg lambdabot @messages' to read it.
17:35:42 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
17:36:14 <othiym23> :t const
17:36:15 <lambdabot> forall a b. a -> b -> a
17:43:58 <augur> are there any time-travelling monads/functions/etc. that dont involve circular definitions?
17:44:12 <Axman6> like the reverse state monad?
17:44:23 <augur> like, but without the circularity
17:45:11 <poisonarms> how fast is haskell?
17:45:23 <kyagrd> poisonarms: you mean GHC?
17:45:26 <augur> as fast as like!
17:45:28 <augur> ..
17:45:29 <augur> light
17:45:30 <augur> :|
17:45:34 <augur> fingers no work D:
17:45:40 <poisonarms> kyagrd: sure
17:45:56 <edwardk> augur: no
17:46:15 <augur> edwardk: ok. so i will never grok them :(
17:46:38 <edwardk> augur: they are effectively all based on some logical paradox writ in the form of a type ;)
17:47:04 <Cale> Has anyone really been far even as decided to use Haskell even go want to do look more fast?
17:47:14 <augur> edwardk: i feel like there should be some way to make circularity elegant but
17:47:28 <edwardk> it is elegant ;)
17:47:31 <augur> Cale: WAT
17:47:40 <wli> Cale: Rephrase please.
17:47:45 <edwardk> cale has been possessed by edwardk
17:47:51 <augur> edwardk: circularity is utterly incomprehensible
17:48:15 <edwardk> augur: that statement seems very circular ;)
17:48:33 <fxr> that ocr guy should really check out emacs with ghc-mod.
17:48:43 <luite_> circularity is easy as pi
17:48:47 <augur> edwardk: thats because you're all loopy!
17:49:00 <augur> its just hard to see when circularity can work and when it cant
17:49:19 <augur> its not readily clear from many circular definitions that you dont get self-dependence and infinite loops
17:49:22 <edwardk> i'm torn. i found another way to represent many vectors and its turning out to be fun as well
17:49:30 <augur> lolol
17:49:35 <augur> the horror!
17:50:45 <edwardk> well it'll make me rewrite a lot of code if i go down this representable-vectors route ;)
17:51:30 <edwardk> but it could be a lot more efficient
17:52:31 <Cale> poisonarms: anyway, GHC produces reasonably fast code
17:52:56 <Cale> (but that's a really really vague question)
17:53:03 <poisonarms> faster than the jvm?
17:53:12 <Cale> sure
17:53:26 <luite_> not in the language shootout
17:53:27 <Cale> But it doesn't compile Java code
17:53:32 <Cale> So...
17:53:33 <luite_> so please fix that ;p
17:53:43 <Cale> kinda hard to measure
17:56:04 <augur> Cale: uh
17:56:07 <augur> i think you're wrong there
17:56:28 <augur> @faq can haskell compile into java code?
17:56:28 <lambdabot> The answer is: Yes! Haskell can do that.
17:56:40 <edwardk> what i'm kind of kicking around is that every free module is a representable functor in hask. if nothing else its trivially representable, because it is a function arrow.
17:57:02 <augur> haskell sucks, im going back to agda! >|
17:57:04 <augur> |<
17:57:07 <augur> <|
17:57:08 <augur> |>
17:57:16 * wli is not even looking into anything so deep on the language front.
17:57:23 <edwardk> so i can go back and forth between say data Quaternion a = Quaternion a a a a
17:57:34 <augur> agh
17:57:36 <augur> quaternions
17:57:52 <edwardk> and given data QuaternionBasis = E | I | J | K, the functions from QuaternionBasis -> a
17:57:53 <augur> what do they MEAN!?
17:57:55 <augur> noone knows!
17:58:16 <edwardk> the QuaternionBasis is a representation of Quaternion
17:58:40 <edwardk> the algebra and coalgebra on the QuaternionBasis is easy to define
17:58:56 <edwardk> Basically just the Cayley table
18:00:07 <edwardk> then the next thought is that the direct product of two free vector spaces (a -> r) and (b -> r) is (a, b) -> r,   or a -> b -> r   which if a and b are both representations is f (g r) — subject to using a slightly different group, etc.
18:00:14 <Cale> augur: My point was just that GHC is a Haskell compiler and not a Java compiler, so it's not possible to compile a Java program with it and compare the performance.
18:00:18 <Axman6> poisonarms: 'how fast is <language X>?' is not a very meaningful question. the code produced by the GHC haskell compiler can be very fast (concurrent code in general runs extremely fast using GHC), but there's no such thing as language speed
18:00:34 <augur> Cale: i know, i was just being funny
18:00:35 <augur> :|
18:00:38 <augur> |:
18:01:28 <edwardk> so i can represent a Quaternion^2 over R by wrapping Quaternion (Quaternion R)
18:01:40 <edwardk> and just dealing with newtype noise
18:01:55 <ddarius> edwardk: I told you representable functors were where it is at.
18:02:07 <edwardk> ddarius: that you did
18:03:13 <edwardk> this nets me a nice reasonable representation for any direct product of (infinite) free vector spaces
18:03:54 <edwardk> and i can still program in the covector monad for it if i want to.
18:04:01 <edwardk> just bring along the representation
18:04:39 <edwardk> er wait
18:04:41 <edwardk> no i can't
18:04:48 <edwardk> ok, so covectors are still slow
18:04:55 <edwardk> well, no faster
18:07:26 <edwardk> ddarius: what this does tell me is i need a module full of combinators to let me just say (*) = timesRep, etc. for representable algebras
18:11:20 <edwardk> using the representable functor approach, the tensor algebra becomes the free monad of the functor.
18:11:57 <djahandarie> Wait, what? That sounds interesting
18:12:00 <edwardk> Free Quaternion
18:12:02 <edwardk> =)
18:12:44 <edwardk> which gives me an algebra for any free monad of something for which i have an algebra
18:13:27 <edwardk> so now i'm left playing with Cofree Quaternion by analogy, though i think it doesn't work out to be anything interesting off hand
18:15:23 <edwardk> now to tie this the rest of the way back to the formal definition of a representation of an algebra that i've been playing with all day, and we;ll be all set ;)
18:15:44 <djahandarie> All day? Do you work? ;)
18:16:42 <edwardk> well, ok, not all day
18:16:48 <edwardk> but off and on during the day
18:16:57 <ddarius> Say 95% of the day.
18:17:06 <edwardk> mayhap
18:18:19 <edwardk> yeah, the two notions of representation seem to coincide =)
18:18:54 <ddarius> That's probably not too surprising for an algebra.
18:19:35 <edwardk> yeah
18:20:18 <edwardk> its just nice when two internally consistent but disjoint parts of the world in your head connect
18:20:22 <edwardk> very satisfying
18:21:18 <edwardk> now this approach will sadly only work for free modules, but so far all of my modules except for my ideals, etc. are free
18:24:38 <cocon> does it make sense to implement subexpression sharing and let-floating in one shot for a simple language with lambdas and lets?
18:25:21 <drbean> > unlines ["abc","def"]
18:25:22 <lambdabot>   "abc\ndef\n"
18:25:58 <edwardk> if nothing else you'll learn how they work
18:26:07 <drbean> How do I get ghci to convert ["abc","def"] to:
18:26:14 <drbean> "abc"
18:26:17 <drbean> "def"
18:26:27 <drbean> ?
18:26:51 <cocon> edwardk: how do they work?
18:27:29 <argiopeweb> > putStr $ unlines ["abc", "def"]
18:27:30 <lambdabot>   <IO ()>
18:27:34 <edwardk> that is what you'll discover by implementing them. ;) i'll dig up some references when i get a chance
18:27:41 <argiopeweb> Well, it's IO so it won't do it, but that is how it's done.
18:27:55 <cocon> drbean: mapM_ putStrLn ["abc", "def"]
18:28:27 <argiopeweb> Slightly less efficient approach, but equally correct.
18:29:33 <cocon> edwardk: thanks, any references would be greatly appreciated
18:31:09 <greenage> hi everyone
18:34:16 <greenage> it's my first time coming across haskell
18:34:36 <greenage> and i really think it's pretty nice
18:35:23 <parcs> 727 others agree
18:35:41 <sully> eh, it's all right :P
18:37:42 <edwardk> i think i heard of it once, some kind of academic language, no?
18:38:11 <greenage> hmmm...
18:38:28 <luite_> yeah you must have three PhD's in category theory to understand it
18:38:45 <greenage> wow!!!
18:38:53 <clsmith> it's funny because it's true :)
18:39:05 <greenage> are u kidding me?
18:39:18 <edwardk> they certainly help
18:39:19 <edwardk> greenage: in all seriousness haskell is a pretty fun language to learn
18:39:35 <edwardk> but the rabbit hole can go pretty deep if you want it to =)
18:39:36 <greenage> i think so
18:39:47 <edwardk> what are you using to learn it now?
18:39:50 <greenage> that wld be fun
18:40:05 <greenage> can some1 recommend any books
18:40:09 <edwardk> yes
18:40:15 <edwardk> there are two that come to mind off hand
18:40:22 <edwardk> learn you a haskell for great good
18:40:24 <poisonarms> there any good haskell ides?
18:40:32 <edwardk> which is available online if you want to try it out
18:40:33 <clsmith> my experience of haskell has been being annoyed that it can't do 'x', switching to some other language, and then getting annoyed that it can't do what haskell can. and oscillating.
18:40:38 <edwardk> and there is also 'real world haskell'
18:41:03 <edwardk> which is aimed more at helping folks who have been doing lots of real world programming to forget the stuff they know and learn the way to think about it in haskell ;)
18:41:29 <greenage> pls can i get the web link or the name
18:41:36 <edwardk> that one is an o'reily book and also available online
18:41:41 <luite_> @where lyah
18:41:41 <lambdabot> http://www.learnyouahaskell.com/
18:42:05 <edwardk> http://book.realworldhaskell.org
18:42:18 <ddarius> Haskell can't do global variables!  Save me PHP!
18:42:48 <greenage> Edward  i guess u mst be pretty good at it
18:42:52 <edwardk> LYAH is fun, but takes a pretty sedate pace and doesn't go too deep. RWH is focused very much on applications. so they complement each other nicely
18:43:10 <greenage> okies
18:43:12 <edwardk> I've written a few things
18:43:15 <aavogt> and the urls are equally long
18:43:27 <greenage> what kind of applications are they used for
18:43:33 <luite_> haskell has been carefully designed to not allow you to think the wrong things :p
18:43:34 <edwardk> my stuff?
18:44:05 <shachaf> aavogt++ for the idiom thing, by the way.
18:44:08 <cheater__> suppppp
18:44:24 <greenage> i mean real life apps
18:44:26 <aavogt> shachaf: it's uglier than fundeps though
18:44:27 <edwardk> i tend to write the crazy abstract category theory stuff that folks were joking about earlier. but i also play around a lot with parallel and distributed programming ;)
18:44:32 <ion> R’lyah
18:45:04 <shachaf> aavogt: Kind of, yes. :-)
18:45:13 <edwardk> well, if you look at what apps are out ther ein the real world written in haskell that have as wide or wider distribution than the compiler itself you find xmonad, which is a window manager for xwindows and darcs which is a version control system like git
18:45:40 <greenage> hmm...
18:45:51 <greenage> i think its worth trying
18:45:54 <edwardk> there are web programming frameworks like snap, stuff to talk to databases, opengl, etc. so you can write pretty much any kind of app in haskell
18:46:11 <greenage> okies
18:46:19 <aavogt> I learned fundeps first, so they are easier and look prettier even if you need more consistency with naming all those extra type variables that type families sometimes hide
18:47:11 <ddarius> I recommend not trying any language unless someone is providing you a job with a six*-figure salary (* or more.)
18:47:12 <edwardk> when we get superclass equality constraints in 7.2 or so i'll start using type families more
18:47:33 <copumpkin> at least seven
18:47:42 <edwardk> the seventh digit is the key
18:47:47 <copumpkin> if not eight or nine
18:48:01 <copumpkin> edwardk: yeah, I always want my salary to end in a seven
18:48:05 <copumpkin> it makes me feel luckier
18:48:22 <greenage> nup am learning it now in school
18:48:37 <greenage> i have just been introduced for the first time now
18:48:44 <edwardk> that and you can improve your odds of some criticals in final fantasy that way
18:48:53 <wli> ddarius: Eh? Programming languages aren't difficult to learn.
18:49:11 <ddarius> School, where they teach you how to work for free.  A valuable market skill.
18:49:40 <luite_> greenage: do see what people are using it for, look at this: http://hackage.haskell.org/packages/archive/pkg-list.html
18:49:41 <greenage> hey ddarius i meant haskell
18:49:51 <ddarius> wli: I didn't say they were.
18:50:20 <luite_> greenage: this is where most haskell libraries (and also some programs) are stored. if you install the haskell platform, you can install these with the cabal install program
18:50:36 <BrianF_> Is Haskell good as a first language? My impression is that people who try to learn it are either (a) in school or (b) already serious programmers with years of experience in other languages.
18:50:50 <BrianF_> But I'm neither
18:51:01 <edwardk> greenage: ddarius can be rather sarcastic
18:51:03 <aavogt> it was my first, and it's ok
18:51:05 <ddarius> Haskell probably isn't the best first language, but it is better than most of what is suggested as a first language.
18:51:31 <ddarius> edwardk: I wasn't being sarcastic about the school comment at least.
18:51:40 <augur> edwardk: hm
18:51:42 <monochrom> programming languages aren't difficult to learn, objective. but people make a big fuzz about "why should I", subjectively
18:51:46 <augur> i think i have a way of grokking circularity
18:51:46 * wli isn't really trying to learn it but just using it as a literate language that strongly resembles ASCII math for the purposes of stuff that's mostly about the formulas anyway.
18:51:56 <augur> and even of writing comprehensible circular code
18:52:07 <wli> i.e. lesser impedance mismatch between formulas and code
18:52:11 <augur> i have to work on it a bit but
18:52:19 <napping> If you stick to simple functions and stuff, Haskell can be pretty simple
18:52:22 <edwardk> to grok circularity first you must grok circularity
18:53:05 <greenage> i think i have no choice but to learn it
18:53:20 <greenage> cos its part of my curriculum
18:53:44 <clsmith> hmm. actually, i have a question. i'm sort of slowly wading into haskell, and my final year project is on combinatory logic and so on -- but i failed a level maths :p so... does anyone have any recommendations for the kind of math text book in which type theory, lambda, etc lay?
18:53:49 <ddarius> greenage: You could drop out of school or choose a different major or choose a different school.
18:53:57 <ddarius> greenage: That's already a lot of choices.
18:54:15 <monochrom> I think people just want to come and whine
18:54:29 <ddarius> monochrom: That's the only reason I'm here.
18:54:34 <monochrom> haha
18:54:45 <luite_> clsmith: types and programming languages by pierce?
18:54:59 <wli> I can't figure out the math behind the code so there's no code to talk about yet.
18:55:06 <edwardk> clsmith: tapl by pierce is a great starting place
18:55:33 <greenage> ddarius: am already in my last semester in school lol
18:55:41 <greenage> so there is no way out
18:55:42 <wli> ML for the Working Programmer?
18:55:46 <monochrom> if you have a project on combinatory logic, get a book on combinatory logic
18:56:09 <clsmith> oh neat, i looked up TAPL and it's in the uni library, i'll pick it up tomorrow
18:56:15 <ddarius> greenage: Yes, they've already fully inculcated trained helplessness.
18:57:00 <clsmith> monochrom: well, i'm working my way through lambda-calculus and combinators by hindley and seldin atm. and it's kinda making sense
18:57:04 <aavogt> @google rat learned helplessness
18:57:05 <greenage> y did u say dat
18:57:05 <lambdabot> http://www.ppc.sas.upenn.edu/lh.htm
18:57:05 <lambdabot> Title: Learned Helplessness
18:57:48 <clsmith> the problem i find is when you read maths books they're so eager to jump into greek
18:57:59 <monochrom> or hebrew
18:58:03 <gienah> clsmith: this is an excellent course on type theory: http://www.seas.upenn.edu/~cis500/current/sf/html/index.html
18:58:03 <ddarius> clsmith: Learn Greek.
18:58:15 <monochrom> I would use Chinese
18:58:22 <aavogt> read the english they put around the symbols
18:58:54 <shachaf> monochrom: Math books jump into Hebrew?
18:58:55 <clsmith> gienah: thanks, i'll check that out
18:59:03 <ddarius> Read Greek math texts and then they'll perhaps use Roman numeric symbols.
18:59:06 <napping> shachaf: cardinals, at least
18:59:08 <nus> `The best book on programming for the layman is "Alice in Wonderland"; but that's because it's the best book on anything for the layman.'
18:59:20 <monochrom> yes, ℵ for cardinals for example
18:59:58 <clsmith> aavogt: yeah. they often seem to assume you come from a maths background, though. it's possible, progress is just slow :)
19:00:08 <luite_> monochrom: any other examples? :p
19:00:14 <dolio> Beth.
19:00:16 <shachaf> Right, but anything other than א and maybe ב?
19:00:37 <monochrom> I am not convinced that a book on type theory helps learning combinatory logic. rather, I think it distracts.
19:00:57 <shachaf> Hmm, monochrom's alef is fancier.
19:01:09 <ddarius> monochrom: But the distraction is better.
19:01:38 <clsmith> monochrom: well, in some ways the two are linked and stuff
19:01:49 <gienah> clsmith: 10 videos on coq and type theory, start with this one: http://www.vimeo.com/18138042
19:01:56 <monochrom> some people in this channel do tend to suggest type theory for every subject
19:02:09 <ddarius> @google ambient calculus
19:02:10 <lambdabot> http://en.wikipedia.org/wiki/Ambient_calculus
19:02:10 <lambdabot> Title: Ambient calculus - Wikipedia, the free encyclopedia
19:02:17 <gienah> monochrom: :-)
19:04:28 * ddarius decides that "Human Helplessness: Theory and Applications" is perhaps not the best title for a book.
19:05:42 * shachaf wonders what the best title for a book is.
19:07:36 <nus> "The best title"
19:08:03 <monochrom> "Trapped in IO: Everything about Helplessness"
19:08:20 * wli doesn't like the direction this is going.
19:08:28 <edwardk> ddarius is in an uplifting mood tonight
19:08:56 <ddarius> I'm always uplifting.
19:09:06 <edwardk> its like he switched computers with wli for a bit ;)
19:09:18 <monochrom> haha
19:12:24 <wli> edwardk: Usually I suspect a right-wing diametrically-opposite position to mine getting pushed vs. anything like what I actually go on about.
19:18:12 <danharaj> What's the point of liftIO and MonadIO?
19:18:26 <edwardk> you don't have to count the number of lifts you want to do
19:19:09 <edwardk> lifIO foo vs. lift foo vs. lift $ lift foo vs. lift $ lift $ lift foo — depending on how many transformers you have
19:19:17 <edwardk> er liftIO
19:19:17 <danharaj> ah, sounds good.
19:19:30 <danharaj> I'm trying to find the right design for my problem and I stumbled upon it :[
19:20:07 <ddarius> liftIO is a mitigation for the fact that we don't have a MonadIO class like we have a MonadState class (instead we have the MonadIO class that we have.)
19:20:17 <danharaj> mm
19:20:57 <augur> ddarius: lmfao
19:21:02 <aavogt> often you don't need a lift, since instances like this one exist:    instance MonadState s m => MonadState s (ReaderT r m)
19:21:23 <cheater__> is that a thing that could have been done better or is that just the nature of it?
19:22:46 <ddarius> (Actually, you'd probably want something more like MonadFileIO, MonadConc, etc.)
19:23:02 <edwardk> cheater: technically you could probably make an instance (MonadTrans t, MonadIO m) => MonadIO (t m) where liftIO = lift . liftIO
19:23:38 <edwardk> along with a single base instance for MonadIO IO you'd have two instances that don't overlap and cover everything
19:33:01 <jcp> Is there any sort of article that explains what lifting is for those of us not particularly well versed in math?
19:33:25 <ddarius> jcp: What makes you think it has anything to do with math?
19:36:40 <jcp> Well, math might be the wrong word, but I was reading http://www.haskell.org/haskellwiki/Lifting, and it doesn't really seem to explain what this concept of "lifting" is other than that it's some generalization thing.
19:37:03 <jcp> It just gives this brief summary of what lifting is used for, then goes into examples of things that are lifts, and I can't figure out how any of them are related.
19:38:59 <edwardk> lifting is just a monad homomorphism. ;)
19:41:04 <edwardk> but in general, a monad transformer takes a monad and adds more 'stuff'
19:41:23 <copumpkin> preflex: seen dons
19:41:24 <preflex>  dons was last seen on #haskell 12 days, 2 hours, 56 minutes and 14 seconds ago, saying: tommd: i manually ran it a couple of times, after the captcha was added
19:41:28 <copumpkin> oh man, a new record
19:41:42 <edwardk> lifting lets you take a computation in a simpler monad and embed it in one which offers that extra stuff
19:41:47 <ddarius> Perhaps he's being fed O'Caml.
19:42:02 <edwardk> between new york and singapore he's been a bit distracted i'd guess
19:42:26 <wli> I'm vaguely concerned that these weak Chebyshev spaces are inapplicable as the intersections of quadrics are not linear subspaces.
19:42:32 <edwardk> and i can see that being fed a'caml might take a while ;)
19:43:56 <edwardk> you really need to break from the parametric representation and switch to something implicit
19:44:17 * ddarius huggles F-Rep.
19:44:28 <edwardk> get a formula where the 0s are your surface rather than try to crawl across the surface and you'll have a much easier time
19:45:39 <wli> edwardk: I'm not sure what that means.
19:47:19 <edwardk> what you have right now is a surface where you have a f(t) = (x,y,z), parametrically, the implicit rep is that the surface is wherever f(x,y,z) = 0
19:47:43 <ddarius> The world needs more Zariski topology.
19:47:47 <wli> edwardk: So you mean to parametrize the (hyper)surface somehow?
19:48:09 <edwardk> parametric is fine when you want to work intrinsically in the surface, but it is hard to establish any extrinsic relationships with other surfaces
19:49:49 <wli> edwardk: If I could parametrize it, it'd be much nicer.
19:50:05 <wli> edwardk: I'm at a loss for how to do so just yet...
19:50:27 <edwardk> parametric surfaces are the problem. the implicit rep is quite the opposite ;)
19:50:35 <tommd> Yes, he was.  I wish he'd show up and say something else.
19:51:18 <wli> edwardk: I've already got an implicit representation I can't do anything with.
19:52:04 <JuanDaugherty> in contrast to my earlier report of the TIOBE position (#44) there's a strange sense in which Haskell is number 1 at least in general purpose compiled langs by virtue of the nature of the entries above it at
19:52:04 * ddarius considers formulating an computational implicit representation explicitly based on projective schemes.
19:52:17 <JuanDaugherty> http://lang-index.sourceforge.net/
19:53:03 <edwardk> wli: perhaps an example is in order. checking to see if i have enough stuff here to do it easily
19:53:45 <edwardk> are you familiar with clines?
19:53:49 <isaac> hello
19:53:58 <wli> edwardk: They don't sound familiar.
19:54:05 <isaac> really
19:54:16 <isaac> i  need assisstance
19:54:19 <edwardk> http://en.wikipedia.org/wiki/Generalised_circle
19:54:46 <isaac> how to learn haskell fast
19:54:55 <edwardk> @where lyah
19:54:55 <lambdabot> http://www.learnyouahaskell.com/
19:54:59 <edwardk> @where realworldhaskell
19:54:59 <lambdabot> http://www.realworldhaskell.org/
19:55:06 <luite_> isaac: how fast? before the exam tomorrow? ;)
19:55:10 <edwardk> both of those are excellent
19:55:55 <edwardk> wli: i have a little toy DSL based on one from barney stratford for laying out train tracks.
19:56:07 <edwardk> http://www.scribd.com/doc/57589897/StratfordTrackLayout
19:56:09 <isaac> really
19:56:11 <isaac> i will see to dat
19:56:12 <edwardk> describes his implementation
19:56:32 <EvanR> you can only really learn by doing
19:57:23 <edwardk> he uses an implicit surface representing each cline as quadruple, (p, a, b, k)
19:57:47 <edwardk> representing the set of points p(x^2 + y^2) - 2ax - 2 by + k = 0.
19:57:50 <isaac> ok
19:58:10 <wli> Ideals, Varieties, and Algorithms has a brief note on parametrization. Using Algebraic Geometry has almost nothing on it.
19:58:46 <edwardk> you don't need parametrization though, you can solve for incidence and continuity constraints on the implicit representation
19:58:52 * ddarius doesn't think algebraic geometers care all that much about parameterization.
19:59:03 <edwardk> just leave some of the unknowns and solve it using automatic differentiation and newton raphson
19:59:26 <isaac> ok
19:59:32 <isaac> i will try my best
19:59:38 <edwardk> the version in that paper is naive it only solves a single circle at a time, but the way he combines constraints is correct
19:59:44 <wli> Newton-Raphson is grossly ineffective; eigensystem-based methods are how these affairs are approached.
19:59:58 <edwardk> thats fine
20:00:11 <edwardk> i was giving you A solution, not the best solution =P
20:00:19 <isaac> u have been helpful i apprecaite
20:00:46 <edwardk> once you have the basic technique there are plenty of tweaks you can make
20:00:58 <wli> Well, that's not quite so easy to say. When the numerical methods are ineffective, what they hand back are numbers that don't actually solve the equations and so on.
20:01:50 <edwardk> well, my main point was that you don't need to move to parametric representation to solve your continuity constraints
20:02:08 <edwardk> in fact its probably best that you don't, because those extra variables just muck things up
20:02:11 <tlasrflj> aleator: hello
20:02:15 <tlasrflj> sorry
20:02:27 <edwardk> and then have to be quotiented out of the solution
20:02:29 <tlasrflj> this is the first time i been here
20:02:47 <JuanDaugherty> edwardk, how much code is the actual library?
20:03:06 <edwardk> JuanDaugherty:  the combinator library for train tracks? not much
20:03:21 <JuanDaugherty> edwardk, yes as SLOC oder
20:04:22 <wli> Okay, well, moving around the surface in a Newton-ish fashion can be arranged. Maybe just arranging that while ignoring what direction is best to move in would be good for now, then think about how to pull off minimax affairs later.
20:04:27 <edwardk> 104 SLOC https://github.com/ekmett/dsl2011/blob/master/TrainTrack.hs to do basic solutions, probably 60 more to add multiple simultaneous cline solving
20:04:42 <JuanDaugherty> nice
20:04:44 <edwardk> i have that on my other laptop
20:05:06 <edwardk> see the comments at the bottom to see how one expresses constraints using the combinator set
20:05:26 <EvanR> train tracks? so like, a graph lib?
20:05:58 <tlasrflj> any thing for newbie?
20:06:01 <edwardk> evanr: train tracks basically consist of lines and circles with a bunch of incidence relations and known intersection points from surveying.
20:06:04 <tlasrflj> i am newbie
20:06:27 <EvanR> tlasrflj: learn you a haskell for great good?
20:06:49 <EvanR> edwardk: so each section of track has actual geometry
20:06:49 <edwardk> evanr: so the DSL here enables you to specify what circles intersect, what constraints you have on them, like that they pass at a 30 degree angle, that this connects to a line segment, etc.
20:06:58 <edwardk> yeah
20:07:13 <EvanR> does it come with the train ? :)
20:07:22 <EvanR> or sold separately
20:07:41 <wli> edwardk: I suppose I have more general quadrics, but it appears from the constraint language that they're expressible.
20:07:46 <edwardk> so you wind up with a set of derivatives, now its a 3 dimensional projective space so you have 4 variables, one of which is free for homogeneous scaling
20:08:21 <edwardk> in stratford's paper he used a fixed set of 3 partial derivatives and basically hand rolled AD.
20:08:28 <tlasrflj> list
20:08:31 <wli> edwardk: I wonder if this sort of thing could just do Karush-Kuhn-Tucker outright.
20:08:33 <edwardk> but I _have_ an AD library that is vastly more general
20:08:34 <tlasrflj> help
20:08:37 <tlasrflj> :help
20:09:14 <edwardk> and so when solving multiple simultaneous surfaces i just put all of those coefficients into the AD blender, and then use it to extract whatever derivatives i need for whatever kind of optimization technique comes to mind
20:09:17 <wli> edwardk: And set up linear systems for hmatrix/GSL outright.
20:09:50 <edwardk> wli: quite possibly, i explored this for all of a saturday morning, and long enough to live code most of what you see there ;)
20:09:54 <synonymous> tlasrflj: learn you a haskell for great good"
20:10:17 <synonymous> tlasrflj: is a name of a good haskell tutorial, google it
20:10:45 <tlasrflj> ok , thanks
20:10:45 <wli> edwardk: The pain will doubtless fall within the active set maintenance.
20:10:51 <tlasrflj> @help
20:10:51 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:10:59 <tlasrflj> @list
20:10:59 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
20:11:01 <wli> edwardk: (That is, for the inequality constraints.)
20:11:14 <tlasrflj> how to list all commands
20:11:19 <tlasrflj> @list
20:11:19 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
20:11:44 <edwardk> wli: sure, its not perfect
20:11:49 <tlasrflj> ??list
20:11:56 <edwardk> i just wanted to give you some kind of way to approach it that kept you out of parametric =)
20:12:13 <tlasrflj> ?help
20:12:13 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:12:18 <tlasrflj> ??help
20:12:25 <edwardk> these are pretty cheesy surfaces here, my old NURBS solvers were vastly more complicated by comparison ;)
20:12:32 <tweety> hi good haskel programmer here
20:12:35 <edwardk> but they also didn't fit in 104 lines of haskell
20:13:18 <wli> edwardk: Not sure why to stay out of parametric since constraint elimination is extremely helpful when possible, but the constraint elimination procedures are basically not there (and from a quick perusal of Ideals, Varieties, & Algorithms, not even always possible).
20:13:49 <tweety> hi friends, good day, please am very new to this and will love to really understand it
20:15:46 <EvanR> haskell is awesome
20:15:56 <EvanR> welcome to the realm beyond
20:15:57 <danharaj> what does `f` mean when f is a unary function?
20:16:14 <edwardk> the main problem with parametric is the parametrization is yet another variable adding at least the dimensionality of your surface worth of complexity to the problem and then you have to quotient out that extra flexibility. On the other hand, it is great locally when you know you can project onto one of the planes without approaching any poles
20:16:18 <EvanR> danharaj: we dont ask these questions lol
20:16:28 <bian> hello
20:16:34 <edwardk> because there you reduce the dimensionality
20:16:52 <bian> what is haskell about?
20:16:56 <danharaj> :t (`id` "what")
20:16:57 <lambdabot> forall t. ([Char] -> t) -> t
20:17:08 <edwardk> bian: writing code
20:17:12 <aavogt> danharaj: with ghc at least, it allows f to be applied postfix
20:17:22 <wli> edwardk: When the constraints are nasty, it saves headaches.
20:17:32 <aavogt> > ("123" `head`)
20:17:32 <lambdabot>   '1'
20:18:00 <EvanR> :t (`head` "123")
20:18:01 <lambdabot> forall t. [[Char] -> t] -> t
20:18:07 <EvanR> :t ("123" `head`)
20:18:07 <lambdabot> Char
20:18:09 <bian> oh!!!
20:18:10 <aavogt> but apparently that needs some extensions
20:18:10 <EvanR> o_O
20:18:11 <danharaj> so (\x -> (x `f` y)) means apply f to x and then apply that to y?
20:18:40 <ddarius> XAML is sin.
20:19:10 <danharaj> I'm trying to understand edwardk's post on making monads out of comonads, and I wasn't familiar with that notation w.r.t. unary functions.
20:19:13 <danharaj> Is that part of the standard?
20:19:29 <ion> @@ @unpl @pl \x -> (x `f` y)
20:19:29 <lambdabot>  (\ a -> f a y)
20:19:35 <ion> @pl \x -> (x `f` y)
20:19:35 <lambdabot> (`f` y)
20:20:21 <edwardk> sure, if your surface doesn't double back on itself and you can project down to some plane or something, thats awesome, but when you just need to say you have a 2 dimensional surface in say a 3 dimensional projective space and here are how it changes with respect to local x y, then the parametric representation is awesome to render, but annoying to change
20:21:38 <edwardk> danharaj: sure, (+) turns an infix + into a prefix operator. `foo` takes a prefix foo and makes it an infix operator.
20:22:29 <edwardk> danharaj: (x `f` y) = f x y
20:22:38 <edwardk> and because it is infix you can section it
20:22:54 <danharaj> edwardk: yeah, if you think about it logically it makes sense.
20:22:59 <edwardk> (`f` x) = flip f x   ,  (x `f`) = f x, (`f`) = f
20:24:26 <danharaj> edwardk: I find it striking how often things that look like almost CPS transforms come up.
20:24:36 <edwardk> =)
20:24:49 <edwardk> given my current work that is disturbingly true ;)
20:25:14 <danharaj> right now I'm working through Co Stream to see what monad you get.
20:25:18 <danharaj> as an exercise.
20:25:19 * ddarius is going to get more security paraphanelia.
20:25:24 <edwardk> yeah that one is fun
20:25:25 <isaac> how i go frm prelude to chgi
20:25:34 <isaac> in the command line
20:25:43 <danharaj> edwardk: I think after that I'll see what you get from Co (Cofree f)
20:25:48 <edwardk> you get a stream full of continuations, and get to pick one
20:26:12 <edwardk> yeah Co (Cofree f) is quite distinct from Free f =)
20:26:21 <danharaj> ah, but is there a nice morphism between them?
20:26:24 <edwardk> both are excellent choices
20:26:26 <isaac> how do i go forom the prelude to chgi in the command line
20:26:31 <edwardk> i don't think so
20:26:46 <isaac> y?
20:27:04 <ion> Left ParseError
20:27:08 <edwardk> cofree is right adjoint to a forgetful functor, free is left adjoint. they really have little to do with one another ;)
20:27:30 <danharaj> pff, look at them in a mirror
20:28:03 <edwardk> i've probably spent as much time staring at them as anyone =P
20:28:30 <danharaj> I can imagine what it's done to your brain
20:28:44 <danharaj> there's probably an area devoted to diagram chasing, and next to it one devoted to parametric reasoning.
20:28:50 <edwardk> it has attained a vaguely tapioca like consistency
20:29:15 * ddarius doesn't much care for "diagrams."
20:29:28 <danharaj> They're just encodings of equations as graphs.
20:29:45 <edwardk> diagrams are great while you are drawing them, and when the discussion is happening.
20:29:52 <ddarius> Very sparse encodings, though they also include type information (which is usually inferrable.)
20:29:59 <edwardk> afterwards they are a lot more boring =)
20:31:04 <danharaj> god, bind is making my head melt
20:31:10 <wli> Hmm, I should learn how to use haddock.
20:31:11 <danharaj> wait maybe if I write it unbackwards it'll look cleaner
20:31:22 <edwardk> they do at least provide enough clues as to context that you can follow along and let you employ spatial reasoning to stitch them together
20:31:43 <edwardk> i can never remember haddock syntax. which is why half my modules are undocumented
20:31:46 <ddarius> They have some mnemonic value.
20:34:01 * wli is a big believer in documenting whatever it is he does.
20:34:20 * ddarius is a big believer in documenting the nothing that he does.
20:37:33 <wli> I will add substantial haddock affairs to the literate code I write.
20:42:20 <sshc> Does hint really not have an equivalent of Language.Haskell.Interpreter.loadModules that isn't restricted to only reading files?
20:45:23 <luite_> sshc: do you want to give it your source code as a String or Text instead?
20:45:42 <sshc> luite_: Yes.
20:45:53 <wli> Okay, I have vague ideas of how haddock works. Good question of what LaTeX-style literate Haskell code does with it besides choke.
20:46:54 <luite_> sshc: hmm I don't think it has, the ghc api does allow you to do that though
20:47:03 <sshc> Of course, there's always the less satisfactory means that involves temporary files.
20:47:51 <luite_> yeah hint already uses those anyway, to create the module with the Show function for evaluate, and for qualified imports
20:47:59 <luite_> neither is necessary with ghc 7
20:50:00 <luite_> sshc: what are you using it for?
20:50:16 <sshc> luite_: My goal is to interpret Haskell source into a value.
20:51:09 <luite_> haskell source is already a value of type String ;)
20:51:45 <sshc> luite_: Specifically, I'm exposing a monad stack and I want to dynamically interpret code that defines a value that has the type of the monadic stack at runtime and use that monadic value.
20:52:53 <luite_> err I don't understand what you mean :)
20:55:10 <sshc> luite_: A simpler example of something that's similar to what I want is to read haskell code from the user and interpret it into a value.  For example, if I want a "Maybe Integer", the user can provide the code for such a value.  I then, with the value that I interpreted at runtime, print that value.
20:56:08 <sshc> String -> IO (Maybe Integer), perhaps
20:56:31 <wli> haddock's choking on Numeric.LinearAlgebra
20:56:50 <edwardk> whose?
20:57:02 <wli> Not sure. HaskellForMaths?
20:57:08 <edwardk> ah
20:57:21 <sshc> luite_, anybody else: Will the GHC api allow me to do this?  I'm not familiar with that library.
20:57:27 <luite_> sshc: oh that's still fairly easy with th ghc api
20:57:46 <luite_> yeah you need to do some unsafeCoerce to get your value though
20:57:56 <luite_> hint nicely hides that
20:58:09 <sshc> Because, as far as I can tell, I can't do this with hint (without writing to temporary files)
20:59:34 <luite_> sshc: what you're looking for is probably setTargets, and then a Target with targetContents set to some StringBuffer
20:59:35 <EvanR> is there a type for an array of exactly N whatever
21:00:26 <luite_> EvanR: there are libraries that use some type level naturals for that
21:00:36 <luite_> vector-static
21:01:37 <luite_> EvanR: but in general, for regular vectors and arrays, there's no type difference between arrays of different length
21:01:50 <EvanR> ok
21:02:13 <EvanR> no better than C then ;)
21:02:21 <EvanR> as far as safety
21:02:41 <luite_> well some implementations do perform bound checks
21:02:47 <luite_> but those are runtime
21:03:02 <EvanR> yeah i dont see why that needs to be runtime
21:03:20 <tlasrflj> hi, i just finished meal
21:03:27 <sshc> luite_: I don't see setTargets or Target anywhere
21:03:35 <luite_> sshc: GHC
21:03:54 <luite_> that's where the high level api lives
21:04:17 <luite_> if you need to get to the internals of the linker, type checker or other part, you need other modules :)
21:04:27 <luite_> http://www.haskell.org/ghc/docs/7.0.4/html/libraries/ghc-7.0.4/GHC.html
21:04:37 <sshc> Thanks
21:05:10 <sshc> Ah, "interpret" looks promising
21:05:14 <sshc> @hoogle interpret
21:05:15 <lambdabot> No results found
21:05:27 <luite_> sshc: you probably want compileExpr
21:05:49 <EvanR> is there a type for 'amount between 0% and 100% inclusive)
21:05:51 <EvanR> ' '
21:05:56 <danharaj> edwardk: Do you have any sample code for Co Stream? I'm having trouble wrapping my head around it.
21:06:17 <edwardk> danharaj: nah, just some stuff that was written up on the whiteboards at work
21:06:26 <danharaj> I'll see if I can come up with some then.
21:06:48 <edwardk> you may find the keys package useful
21:07:14 <edwardk> you can index into a cofree comonad using the index combinator from there if the functor is indexable
21:07:42 <danharaj> ooh
21:07:44 <luite_> sshc: you'll need to perform some unsafeCoerce on the HValue
21:07:47 <edwardk> using [Key f] as the Key
21:07:57 <luite_> sshc: but that will give you a value that you can use in the rest of your program
21:08:02 <tlasrflj> hi
21:08:12 <edwardk> that gives you the continuation, and you feed it some 'a' you have lying around.
21:08:17 <sshc> luite_: Wonderful!  Thanks
21:08:17 <tlasrflj> can i use unsageCoerce to cast Float to Word32?
21:08:56 <edwardk> return just uses the [] key effectively extracting the head continuation from the cofree comonad by default
21:09:24 <edwardk> but other actions are allowed to pick any of the other 'a -> r's in the tree and perform that action
21:09:35 <edwardk> the quantifier keeps them from calling more than one
21:09:36 <EvanR> tlasrflj: no
21:09:46 <EvanR> er yes
21:09:52 <EvanR> do you want the value to make any sense?
21:09:54 <sshc> luite_: Also, out of curiosity, does hint's loadModules support loading modules of packages installed with cabal install?
21:10:01 <danharaj> EvanR: It's not defined.
21:10:30 <EvanR> danharaj: ideas?
21:10:31 <sshc> (That question is probably indicative of my lack of knowledge about GHC's package system; a link to decent documentation about it would be appreciated)
21:10:48 <k3yb1n> someone know about uuagc for code genereting? Im looking for some example about this
21:11:08 <luite_> sshc: hmm, yes, I think it does, but you cannot make something a top level module unless you have the source
21:11:53 <sshc> luite_: Um, that's not a problem.  What is a problem is having to write the source to a file.  Did you mean "file"?
21:12:06 <luite_> sshc: hint makes ghc automatically read the package database files. if you use the ghc api directly, you'llneed to call setDynFlags or something like that
21:12:17 <danharaj> EvanR: I can't find a function in GHC.Float that returns the underlying representation.
21:12:35 <danharaj> If unsafeCoerce works, it's highly non-portable.
21:12:37 <luite_> sshc: no you can just give it a StringBuffer
21:12:41 <sshc> luite_: Now, GHC *does* support top-level modules with a string, right?
21:12:52 <luite_> yes
21:13:08 <luite_> and qualified imports with ghc 7 :)
21:13:17 <sshc> And, to clarify what's probably already been said: hint doesn't?
21:13:36 <danharaj> I just looked at the de docs for unsafeCoerce# and it seems that coercing from Floats to Ints is undefined.
21:13:41 <luite_> probably not, though I don't know every detail :)
21:13:50 <danharaj> Also, I can't think of many good ideas where you want to cast from Float to Int
21:14:15 <copumpkin> Word32, I could see
21:14:27 <sshc> luite_: Great.  My last concern, then, is portability
21:14:34 <danharaj> Float doesn't have to be IEEE754'd
21:14:40 <tlasrflj> yes
21:14:44 <sshc> luite_: Which choice would be more portable?
21:14:53 <tlasrflj> you need to import Data.Ext
21:15:04 <tlasrflj> import Data.Word
21:15:08 <edwardk> danharaj: yes, but in practice there isn't a platform where it isn't. the price we've paid for this 'flexibility' is rather beyond the pale
21:15:27 <luite_> sshc: hint has some compatibility stuff to make a uniform api across ghc versions. if you just want to make it work with ghc 7, then the ghc api is probably fine
21:15:35 <danharaj> edwardk: that's true, but GHC doesn't provide a way to go from Float to the underlying word representation.
21:15:39 <augur> if i have a gadt   data Foo a b ...
21:15:39 <danharaj> I assume that's why.
21:15:58 <augur> do all of my constructors have to be   yadda yadda -> Foo a b?
21:16:03 <edwardk> sure it does.  =) just unsafeCoerce a Float to an Int, they both have one unboxed slot and one constructor ;)
21:16:17 <danharaj> the docs for unsafeCoerce say that's undefined :\
21:16:27 <augur> that is to say, are a and b genuinely bound in the body of the gadt def, or are they just arity place holders?
21:16:46 <danharaj> "Casting an unboxed type to another unboxed type of the same size (but not coercions between floating-point and integral types)"
21:16:47 <ddarius> data Foo :: * -> * -> * where ... is legal and preferable syntax.
21:16:58 <edwardk> it is, but operationally it holds up okay you may have to mask off high bits on a 64 bit platform
21:17:04 <augur> ddarius: ok. im glad. its more agda that way and that makes me comfortable. :D
21:17:16 <sshc> luite_: Portability is important to me, but I also am only using Haskell2010-compatible implementations; ie, in this case, >= 7
21:17:33 <edwardk> danharaj: i was casting boxed types there, knowing the physical representation of the unboxed types they housed
21:17:33 <danharaj> edwardk: Maybe I've been making a big fuss because I want the asker to rethink whether he wants to do something so hairy :p
21:17:50 <danharaj> I'd get nervous about this cast in C!
21:17:55 <luite_> sshc: you may end up with more #ifdef in your own code if ghc 7.2 or higher changes more things
21:18:07 <edwardk> i'm being difficult because you need that cast to do lots of things in the real world ;)
21:18:17 <danharaj> pff
21:18:19 <danharaj> like what.
21:18:21 <ddarius> @hoogle decodeFloat
21:18:22 <lambdabot> Prelude decodeFloat :: RealFloat a => a -> (Integer, Int)
21:18:54 <edwardk> for much of the range of floating point numbers it is better to compare them based on how many representable floats lie between the two floats than with some epsilon
21:19:03 <danharaj> ironically, unsafeCoerce is the only thing that comes up when you hoogle "Float -> Word32"
21:19:10 <tlasrflj> decodeFloat wont cast into Word32
21:19:20 <edwardk> assuming you have dealt with nans that is the difference between the two numbers _as ints_
21:19:51 <danharaj> edwardk: Fair enough. I tend to avoid using epsilons and making sure I have enough extra precision that I can use exact equality.
21:20:03 <danharaj> er
21:20:09 <danharaj> that sentence doesn't say what I want it to say.
21:20:11 <edwardk> danharaj: exact equality on floats is a myth ;)
21:20:15 <edwardk> hahaha
21:20:18 <edwardk> i'm glad
21:20:40 <c_wraith> > 0.25 + 0.25 == .5
21:20:41 <lambdabot>   <no location info>: parse error on input `.'
21:20:43 <edwardk> you cant even get cos x == cos x to work with floats reliably =P
21:20:45 <c_wraith> > 0.25 + 0.25 == 0.5
21:20:45 <lambdabot>   True
21:20:51 <danharaj> Pff, transcendental functions.
21:21:06 <danharaj> With enough bits, you can be accurate when you're working with only algebraic functions.
21:21:10 <c_wraith> there are *some* cases where exact equality returns True when you'd expect in floats. :)
21:21:10 <edwardk> meh, even without, its a matter of potentially enlarged intermediaries
21:21:42 <edwardk> c_wraith: =P
21:21:46 <danharaj> what I do is represent my values as Floats, but do calculations with Doubles.
21:21:49 <c_wraith> that's almost useful!
21:21:56 * ddarius just programs in the "algebra" of floating point numbers.
21:22:21 <danharaj> floating point numbers don't respect topology when you try do to computational geometry on them :p
21:22:29 <edwardk> danharaj: that works fine until you leak 20+ bits because you're stuck working with nearly or slightly denormalized numbers
21:22:48 <edwardk> then counting ulps is a pretty good idea =P
21:23:13 <danharaj> edwardk: I just have to postpone that date until quad precision becomes common in commodity hardware.
21:23:14 <danharaj> :p
21:23:31 <edwardk> i do a lot of calcs with MPFR just for that reason.
21:23:47 <edwardk> and there are usable quad precision libraries built by chaining doubles now ;)
21:23:59 <edwardk> even if the exponent range is still crappy
21:24:01 <danharaj> you can't just chain two doubles though
21:24:07 <danharaj> that gives you slightly less than quad precision.
21:24:08 <edwardk> yeah you can.
21:24:16 <edwardk> it costs you the exponent range
21:24:29 <danharaj> well then it's not ieee754 quad :p
21:24:34 <edwardk> and you lose a bit or two of mantissa
21:25:04 <edwardk> anyways the same argument applies in the quad case, then you're stuck waiting until x6 or x8 precision goes mainstream =P
21:25:16 <edwardk> i'd rather just have something that does the right thing for n bits of mantissa
21:25:43 <danharaj> with quad precision I could do everything I'd like. You don't need much more to get topological correctness with the basic computational geometry primitives.
21:25:51 <danharaj> If you're smart about it.
21:26:07 * ddarius wonders if IEEE754 is fully specified.
21:26:12 <edwardk> oh i definitely understand
21:26:32 <danharaj> It should be said, I prefer your method over epsilons. Epsilons don't even make sense.
21:27:21 <edwardk> well, you use both
21:27:56 <ddarius> edwardk's method is to use epsilon * 2^exp to compare mantissa * 2^exp
21:28:00 <danharaj> the way most people use epsilons is "fuck it I don't want to think about how much error there is" :p
21:28:20 <ddarius> The computer should be thinking about the error.
21:28:26 <edwardk> yeah
21:29:06 <edwardk> well, you can estimate error by using randomized rounding
21:29:29 <edwardk> then run the algorithm a few times and look at the flipped bits, gives you ~95% accuracy without intervals
21:29:46 <danharaj> heh, sounds like quantum computation a bit :p
21:30:40 <danharaj> damn, it's 12:40 and I got no work done today.
21:32:20 <edwardk> if libm didn't flip its shit when fed non-standard rounding modes i'd use that approach a lot more
21:32:54 <ddarius> danharaj must be quite the workaholic complaining about not accomplishing anything in the first 40 minutes of the day.
21:32:56 <edwardk> but alas ulrich drepper is still alive
21:40:35 <peddie> any ideas why, under ghc 7.0.3, I get a message from cabal saying "There is no available version of ghc that satisfies >6.6" ?
21:42:19 <peddie> maybe it's a problem with my instances of Ord :)
21:43:09 <wli> Integer/fraction-free Gaussian elimination wants a diametrically opposite pivoting strategy from numerical/floating point/etc. Gaussian elimination.
21:44:12 <wli> Also, there's the age-old abs issue: abs doesn't yield an Ord result.
21:44:40 <edwardk> i'm just now starting to play with the fraction-free approaches, because of beckermann-labahn
21:44:56 <edwardk> which i need for some pade approximant machinery
21:45:07 <wli> No idea what Beckermann-Labahn is about.
21:45:19 <edwardk> http://www.cs.uwaterloo.ca/~glabahn/
21:45:59 <edwardk> they compute pade approximants while avoiding fractional intermediate results
21:46:07 <edwardk> same basic stuff you're on about ;)
21:46:39 <wli> Rational functions are involved, but from a very different point of view.
21:46:56 <edwardk> i meant with regards to fraction-freeness
21:47:02 <edwardk> not to your overall problem
21:47:33 <wli> I don't know of a way fraction freeness comes up apart from as an issue surrounding generality.
21:47:39 <edwardk> http://www.cs.uwaterloo.ca/~glabahn/Papers/tenerife.pdf
21:47:44 <edwardk> that is a pretty good start
21:48:14 <edwardk> it has some interesting applications, notably http://mathinfo06.iecn.u-nancy.fr/papers/dmAG431-434.pdf
21:48:33 <wli> Bear with me for a clothes change (which is quite an ordeal for me anymore).
21:48:42 <edwardk> its about the conditioning of your intermediate values
21:50:36 <edwardk> http://mathoverflow.net/questions/32937/how-to-find-guess-a-polynomial-sequence goes on for some additional length on the topic of applications
21:52:15 <wli> Well, about the only application for what I'm on about is precomputing approximations for use in e.g. computer hardware or very routinely called code of transcendental functions.
21:54:32 <edwardk> ah
21:56:20 <wli> Best uniform approximants are very difficult to compute and all you can do with the result is evaluate it.
21:58:21 <wli> edwardk: Dealing with constraints like min_{t\in[t_{k-1},t_k]} q_k(t) > 0 is very difficult.
21:58:36 <edwardk> yeah. one of the reasons i've been playing with chebyshev-pade is so i can get good uniform/near uniform approximation
21:59:16 <wli> Hmm, well, you can just do a huge point sample and do linear programming.
22:00:04 <edwardk> well there is some known trickery for exploiting the relaxed chebyshev center, iirc its used in mathematica as well
22:00:47 <wli> Not entirely sure what you mean.
22:01:06 <wli> Rather, I've never heard of the relaxed Chebyshev point center.
22:01:08 <edwardk> seeing if i can find a doc referencing it
22:02:12 <wli> edwardk: There are Remez algorithms for piecewise polynomial splines. I've got a reference on it.
22:03:49 <edwardk> yeah the limitation there is that it is polynomial and not rational. i started this whole endeavor by looking at piecewise chebyshev approximation
22:04:16 <edwardk> before i was sent off on the rational function approximaton tangent by those in the know ;)
22:04:24 <wli> edwardk: There are also Remez algorithms for rational functions, but there aren't Remez algorithms for piecewise rationals like there are for piecewise polynomials.
22:04:40 <edwardk> there's the rub
22:05:00 <wli> edwardk: Which I have the wild hair up my hind end about doing something about.
22:05:40 <wli> edwardk: The Remez algorithm for piecewise polynomials even has a "free knot" version, i.e. a version that figures out how to optimally subdivide the interval.
22:05:42 <edwardk> i mostly want a good initial approximation so i can come along and integrate, etc.
22:08:15 <wli> Unclear how much good the spline version will do since it appears to rely heavily on the linearity of the space of spline functions.
22:08:32 <edwardk> ah
22:09:00 <edwardk> i'll see if i can dust off any of my old tools from playing with nurbs in the graphics world
22:09:02 <wli> There's a reason no one's done what I'm on about yet.
22:09:13 <edwardk> but i'm doubtful
22:09:32 <wli> Yeah ISTR the denominators getting shared across the whole domain.
22:10:02 <wli> Whole parameter domain that is, across all sub-intervals of the piecewise-defined function.
22:10:12 <edwardk> there i was mostly using them to slice and dice each other, though i did do some work towards trying to do visibility skeleton calculations in a view-field of splines
22:10:48 <edwardk> that might not be so bad, because between poles you could fiddle with convexity, etc.
22:11:09 <edwardk> not linear but you at least know where the poles are and can adjust
22:12:26 <augur> hmm hmm
22:12:27 <wli> There are other uglies like homogeneous coordinates so all coordinates share denominators too.
22:12:36 <augur> synthetic properties of attribute grammars are interesting
22:13:15 <edwardk> augur: yeah, we like to just call those arguments to Applicative functors in the haskell world ;)
22:13:17 <ddarius> AGs are just state/backward-state monadic folds.
22:13:26 <augur> edwardk: ey?
22:13:34 <augur> ddarius: yes, they seem to be
22:13:47 <augur> but im trying to phrase them in a nice way
22:14:33 <edwardk> applicative parsers (used inductively not coinductively) can be used to parse context-free grammars and retrieve an synthesize an attribute
22:14:43 <augur> so that you can have some very generic in-haskell combinators that will let you build the attribute readers out of folds
22:15:01 <edwardk> since we have functions as values, the attribute you synthesize can be a function, so you can do inherited attribytes using that one mechanism
22:15:01 * ddarius doesn't feel like lexing.
22:15:18 <augur> edwardk: yes, i imagine this is so
22:15:19 <wli> edwardk: I feel like I'm the conservative one here.
22:15:31 <augur> edwardk: im not thinking of a parsing context tho
22:15:44 <edwardk> wli: probably =)
22:15:54 <augur> i mean in the AGs-as-a-way-to-avoid-repetition-in-code thing
22:15:57 <augur> like in Why AGs matter
22:16:06 <edwardk> augur: sure. just trying to give you some intuition about them
22:16:18 <augur> edwardk: oh, well, that didnt help ;p
22:16:28 <augur> actually im findng that they look suspiciously arrow-like
22:16:37 <augur> at least the synthetic attributes
22:16:47 <ddarius> We need more multi-layer van Widjngaarden grammars.
22:17:03 <ddarius> Off by a d.
22:17:08 <augur> yes
22:17:14 <edwardk> that is because applicatives are oblivious arrows =P
22:17:21 <augur> maybe!
22:17:31 <augur> but like
22:18:29 <augur> if you have a list AG, you'll have an "attibute" of type a -> b -> b that acts like foldr's combinator function argument
22:18:34 <wli> Are there libs popular nowadays for "efficient" matrix affairs?
22:18:45 <mustelo> does anyone have intelligent advice on how to choose a curses binding for haskell? what are the relevant differences?
22:18:46 <augur> and if you have multiple attributes, thats just a -> (b,c) -> (b,c), say
22:19:06 <wli> I forgot what I used ages ago that had weird monads associated with it.
22:19:09 <augur> which is obviously very arrow-like: pair :: (a -> b -> b) -> (a -> c -> c) -> a -> (b,c) -> (b,c)
22:19:12 <edwardk> yes, but you can always fuse folds, which is all that is saying
22:19:27 <edwardk> and you can always (,) <$> f <*> g in an applicative
22:19:33 <augur> edwardk: not quite. fold fusion is about sequences of folds, right
22:19:38 <augur> whereas this is about parallel folds
22:19:53 <augur> i mean, maybe fold fusion gets you that too, i dont remember
22:20:08 <wli> vector?
22:20:09 <edwardk> no, i mean fuse in the sense that if i have two f-algebras in hask i can get one f-algebra of their paired results
22:20:17 <augur> oh, sure ok
22:20:40 <edwardk> i blogged and used that somewhere along the way
22:20:57 <augur> but the real point is that you can in principle have a tight little combinator library that lets you describe the attributes succinctly so that you dont need an AG pre-processor like UUAG
22:21:12 <edwardk> http://comonad.com/reader/2009/incremental-folds/ provides the tupling of algebras in a larger more interesting context
22:21:17 <wli> Data.Vector?
22:21:42 <edwardk> well honestly you don't need a preprocessor, you just need to spot that the concept of an attribute grammar is basically that of an applicative ;)
22:22:02 <augur> edwardk: well you should write a blogpost about that then!
22:22:12 <copumpkin> http://snapplr.com/s8m8
22:22:26 <wli> Hmm, Data.Vector doesn't have multidimensional affairs; is there something I should use for matrices?
22:22:35 <copumpkin> repa
22:22:39 <copumpkin> or hmatrix
22:22:45 <copumpkin> depending on what you want to do with them
22:22:49 <edwardk> wli: i never did ship blase, so you're stuck with hmatrix or something
22:23:26 <wli> copumpkin: Using them on multiple precision floating point libs' numerical types as the underlying field.
22:24:11 <wli> copumpkin: What's repa? (I already know hmatrix isn't polymorphic.)
22:24:19 <copumpkin> @hackage repa
22:24:20 <lambdabot> http://hackage.haskell.org/package/repa
22:24:35 <copumpkin> repa isn't fully polymorphic either
22:25:09 <edwardk> being dragged away
22:25:10 <augur> edwardk: i find the idea of being able to write something like   avg = uncurry (/) $ ag (0,0) ((+) & (1+))   to be appealing
22:25:56 <augur> or maybe that'd be (attr 0 (+)) & (attr 0 (1+))
22:25:58 <edwardk> augur: sure, but folds are composable without calling them attributes ;)
22:26:10 <augur> edwardk: thats utterly irrelevant
22:26:19 <augur> the point is not are they composable
22:26:21 <confab> so i've been idling in this channel for the past few days
22:26:35 <augur> the point is is it intuitive
22:26:35 <confab> evesdropping on converstations here and there
22:26:45 * wli quakes in fear at the prospect of having to reimplement the whole of Golub & van Loan...
22:26:54 <confab> it seems to me you have to be excellent with math in order to have some understanding of haskell
22:27:01 <augur> actually that shouldve been   (attr 0 (+)) & (attr 0 (const (1+)))
22:27:03 <confab> is that a fair statement?
22:27:09 <mustelo> confab, no.
22:27:10 <augur> confab: no
22:27:18 <confab> or am i only paying attention to the wrong converstations
22:27:23 <augur> confab: that
22:27:25 <ddarius> copumpkin: There's apparently a reason you are not rotting in a Japanese prison right now.
22:27:32 <confab> haha okay
22:27:36 <augur> most of the conversations are math heavy, sure, but only because we're all a bunch of nerds
22:27:53 <mustelo> confab, that's not to say that a lot of things here are very mathy
22:28:05 <augur> you dont have to be into star trek if you want to talk to someone about scifi, just if you want to talk to a trekkie
22:28:25 <edwardk> if you make something like
22:28:25 <edwardk> data Foldr a b = forall c. Foldr (c -> b) (a -> c -> c) c — you can add the monad instance, etc for manipulating your folds, and glue together whatever you want. then toss in a couple of combinators and you have your AG framework
22:28:39 <confab> hmm
22:28:44 <edwardk> i'm a bad influence
22:28:56 <augur> edwardk: well yes, im sure. the point is the combinators...
22:29:08 <kmc> i like augur's analogy
22:29:16 <augur> kmc: <3
22:29:30 <confab> augur: mustelo: that brings back some confidence
22:29:38 <augur> i say that having just watched All Good Things
22:29:43 <kmc> confab, people use Haskell as a language for talking about maths.  that's different from saying Haskell itself requires knowing maths
22:30:05 <augur> kmc: oh dont lie to the boy. real math is done in agda ;)
22:30:25 <kmc> i can write all this weird math shit in C++ too, the difference is that people in ##c++ will ignore or ban me if i bring it up there
22:30:45 <copumpkin> or worse!
22:30:54 <augur> kmc: they cant help it
22:30:58 <confab> kmc: why is that? is it because of the syntax of the language, or the functional design?
22:31:08 <augur> if they let you talk, the inscrutability of your code would give their brain bleeds
22:31:16 <augur> could you imagine this stuff written in C++?
22:31:18 <confab> i know nothing about haskell so forgive my ignorance if i misspeak
22:31:29 <augur> its bad enough in ruby and JS like people do
22:31:32 <kmc> Haskell lends itself to thinking logically
22:31:45 <confab> kmc: sounds sexy
22:31:56 <edwardk> anways, my point was that the combinators are in general definable almost perfectly generically on top of existing plumbing, so we don't need to go 30 years backwards into imperative land in search of abstractions. ;) beyond that we're largely in violent agreement using too many words ;)
22:32:09 <confab> i pretend to be a logician in real life
22:32:28 <edwardk> confab: then you'll fit right in
22:32:37 <augur> edwardk: er.. im not doing anything of the sort, unless what you mean is that its bad to use Arrows...
22:33:01 <edwardk> i just meant the attribute grammar formalism itself
22:33:04 <ddarius> edwardk: Wasn't your wife (presumably) calling you?
22:33:12 <edwardk> yes
22:33:32 <augur> edwardk: i just like the notation. it provides an easy way to think of how the data flows around
22:33:34 <edwardk> but there is that "someone is wrong on the internet" component ;)
22:33:39 <edwardk> yeah
22:33:48 <edwardk> fair nuff
22:33:57 <augur> edwardk: and consequently, the combinators would allow you to pretend like you dont have circularity, by doing the circular lifting for you
22:34:10 <augur> the inherited stuff, for instance, would be transparent
22:34:26 <edwardk> i have no problem with writing combinators for it
22:34:55 <edwardk> but having used some of these separate attribute grammar compilers, etc. i find them to be god awful DSLs
22:35:10 <augur> edwardk: well you wait until i write this little bit of code :P
22:35:22 <edwardk> take a look at kiama in the scala world
22:35:36 <confab> so, if i may continue with questions, i'm reading through SICP before even thinking of starting with haskell, is this a bad idea, good idea, or indifferent?
22:35:37 <edwardk> its the best of a bad breed if you get my drift =)
22:35:55 <confab> meaning, will the idioms i pick up in scheme affect me negatively when trying to learn haskell?
22:36:05 <edwardk> confab: it won't help or hinder much
22:36:15 <edwardk> its a very different world
22:36:17 <confab> okay cool
22:37:00 <edwardk> you'll get used to plumbing around continuations and that skill will be useful every once in a while
22:38:13 <confab> alright, well that all sounds good.  thanks everyoine for your opinions
22:39:04 <augur> edwardk: my goal is to be able to write the x-avg code as something like   diff = (attr 0 (+)) *** (attr 0 (const (1+))) >>> (attr [] (\(sum, len) -> sum / len))
22:39:45 <augur> or something to that effect
22:39:47 <edwardk> augur: anyways kiama's approach is nice because it also deals with attributes that accumulate information cyclically to a fixed pointand with memoizing the attribute results for the points in your tree
22:40:09 <samd> hi, why curried functions are favored over uncurried?
22:40:24 <augur> samd: less noise.
22:40:31 <edwardk> samd: because i don' thave to write a new set of combinators for every function arity
22:40:31 <copumpkin> partial application is nice when possible
22:40:39 <augur> samd: for instance, as a stupid example, suppose you want to add 1 to every number in a list
22:40:57 <augur> samd: its nicer to write   map (1+) xs   instead of map (\x -> 1 + x) xs
22:41:14 <augur> actually thats more sectioning, but
22:41:18 <edwardk> > zipWith (,) [1,2,3] [4,5,6]
22:41:19 <lambdabot>   [(1,4),(2,5),(3,6)]
22:41:20 <ddarius> edwardk: (.), (.).(.), (.).(.).(.), etc.
22:41:22 <augur> its currying too
22:41:47 <edwardk> ddarius: =) well its not a panacea i guess ;)
22:42:17 <edwardk> ok. i've burned what good will i have left to burn here at home. head off
22:42:28 <ddarius> Here's an exercise.  Extend the zip calculus to handle an n-ary curry/uncurry.
22:44:18 <wli> Linear programming is in various senses just constrained optimization with a bunch of assumptions about all the constraints and objective being linear.
22:52:41 * hackagebot wai 0.4.1 - Web Application Interface.  http://hackage.haskell.org/package/wai-0.4.1 (MichaelSnoyman)
22:53:42 * hackagebot wai-extra 0.4.0.2 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.4.0.2 (MichaelSnoyman)
22:55:08 <samd> i ddnt get the concept of tail recursion. can som1 explain in laymans terms?
22:56:25 <augur> samd: yes
22:56:51 <augur> consider the following two definition cases
22:57:22 <augur> f x = 1 + f y
22:57:31 <samd> ok
22:57:32 <augur> g x = g (x + y)
22:57:43 <wli> edwardk: In terms of Padé approximants, it's actually possible (ignoring the point at infinity) to use some vaguely brute-force linear algebra to do something like Lagrange-Hermite interpolation with rationals.
22:57:49 <augur> in the f example, what is the outermost function/operation?
22:58:16 <samd> addition
22:58:42 <augur> samd: right. either (+) or (1 +) depending on what you want. lets say its (1 +) because that truest
22:58:48 <augur> what about in the g example?
22:59:25 <samd> application of g itself
22:59:39 <augur> samd: right
22:59:59 <augur> so when you evaluate f, sometimes you might build up a big stack of function application
23:00:10 <augur> like.. 1 + (1 + (1 + (1 + ...)))
23:00:19 <samd> k
23:00:29 <augur> and you cant reduce this to a number until you get a value for ...
23:00:43 * hackagebot regex-applicative 0.1.2 - Regex-based parsing with applicative interface  http://hackage.haskell.org/package/regex-applicative-0.1.2 (RomanCheplyaka)
23:01:02 <wli> edwardk: My favorite is to just use the Lagrange-Hermite polynomial interpolation basis for the numerator and denominator, and then apply degree constraints to it i.e. d^m/dx^m p(x) == 0 (identically equal) for m > d_p and d^m/dx^m q(x) == 0 for m > d_q
23:01:13 <augur> so if you have a LOT of recursive calls to f, you'll have a LOT of functions piled up like this, waiting to be discharged
23:01:20 <augur> taking up space in memory
23:02:17 <augur> but with g, you could go as deep into the recursive call as you like, and all you'll ever have is a single level -- the outermost g -- waiting to be reduces
23:02:32 <augur> g x  =>  g x'  =>  g x''  =>  ...
23:03:23 <samd> thanks augur
23:03:32 <augur> g is an example of a tail-recursive case
23:03:45 <augur> i stress case, because you can mix tail recursion and other kinds of recursion
23:04:03 <augur> if your whole function has only tail recursion and non-recursive cases, its a tail recursive function
23:04:19 <augur> which is really useful, because it can optimized by a compiler to become a loop
23:04:44 <augur> which makes it faster and more memory efficient
23:23:59 <wli> Are there polymorphic linear algebra projects in the works?
23:27:10 <sshc> luite_: Is hint sufficient for carefully analyzing the interpreted code or its AST?  Is it sufficient to run untrusted code in a sandboxed / safe environment?  Is GHC sufficient for either of these?
23:44:02 <wli> Hmm, tracking row and column permutations and undoing them looks like I can follow the formulas in this proof. Trick is finding ways of carrying around the whole matrices and also avoiding copying rows and columns around during swap operations.
23:48:13 <wli> Maybe I should just use immutable arrays and say the heck with efficiency at that level.
