00:00:00 <kmc> if you're just profiling or whatever
00:00:14 <copumpkin> I think they explicitly say not to do unsafePerformIO in STM, as it's double plus unsafe
00:00:20 <copumpkin> or something like that
00:00:25 <codensity> orElse looks like it would do, no?
00:00:45 <kmc> copumpkin, one of them is actually a checked runtime error.  maybe that's (unsafeSTMToIO . atomically)
00:00:47 <cmccann> no, they tell you not to use STM inside unsafePerformIO
00:00:48 <edwardk> well unsafePerformIO in STM is fine as long as you never ever loop back and try an atomically inside it
00:01:01 <copumpkin> ah
00:01:02 <wuxingbo> :) orElse should be fine, right?
00:01:03 <cmccann> in the sense that I think atomically blows up the program if you try it
00:01:30 <edwardk> yeah orElse is perfectly safe
00:01:34 <edwardk> yeah
00:01:41 <edwardk> atomically checks a flag then dies
00:01:51 <cmccann> they really mean it about not doing that
00:02:08 <edwardk> which is really really annoying when people try to make little unsafePerformIO $ atomically tricks like the one that was in Unique
00:02:13 <cmccann> I'm not sure why but must be serious if they don't even want to let you shoot yourself in the foot
00:02:27 <edwardk> it has to do with nesting transactions and deadlocking
00:02:33 <cmccann> it's also why things like newTVarIO or whatever it's called exist
00:02:45 <edwardk> there is no way to have a successful backtracking strategy that copes with it
00:02:49 <edwardk> yeah
00:03:02 <wuxingbo> does unsafePerformIO cause some memorization? it doesn't eval a second time?
00:03:03 <cmccann> because of potential for an unsafePerformIO'd atomically to have non-local effects on otherwise sane STM use, I suppose?
00:03:08 <copumpkin> edwardk: so I think my confusion is that in the monad-polymorphic case, I can see what you're talking about, but for State and Reader in particular, it seems to be the other way around?
00:03:17 <ion> atomically blows up the program in an atomic fashion
00:03:20 <copumpkin> oh wait
00:03:22 <copumpkin> no
00:03:58 <copumpkin> nevermind, I see
00:04:08 <copumpkin> wait, no I don't
00:04:12 * copumpkin dies
00:04:32 <kmc> and then copumpkin was enlightened
00:04:54 <edwardk> copumpkin: in the state and reader case, consider lift :: (s -> a) -> s -> (a, s)
00:05:04 <copumpkin> yeah
00:05:05 <cmccann> ion, yes, using atomically inside unsafePerformIO will not only crash your program, it will send a signal to SPJ's secret arctic stronghold where an automated system will launch the missiles at your location
00:05:08 <copumpkin> but in that case you can go both ways
00:05:10 <edwardk> and a retraction (s -> (a, s)) -> s -> a
00:05:10 <copumpkin> so I do see
00:05:25 <edwardk> then retractLift . lift  = id
00:05:42 <edwardk> you throw away the extra ability to return the state when you retract back down
00:06:01 <edwardk> all the other cases are similar
00:06:07 <copumpkin> yeah, I see
00:06:11 <edwardk> you have a right adjoint and a left adjoint you can use to index into it
00:06:25 <copumpkin> I'd just done something dumb when playing with it
00:06:30 <edwardk> because we're representable
00:06:33 <edwardk> *nods*
00:06:35 <edwardk> np
00:07:04 <edwardk> i have most of the geometric coalgebra stuff written
00:07:11 <edwardk> it turned out rather nicely
00:07:16 <copumpkin> oh great
00:07:20 <copumpkin> preflex: seen ddarius
00:07:20 <preflex>  ddarius was last seen on #haskell 4 days, 2 hours, 3 minutes and 10 seconds ago, saying: @free beer
00:10:04 <cmccann> edwardk, didn't seem to compile very well last time I checked though :P
00:10:21 <edwardk> i'm trying to devise a consistent theory for these division coalgebras, though, since they don't appear to actually come up in the usual algebraic treatments
00:10:28 <edwardk> cmccann: if you pulled from the repo it is very much in flux
00:10:41 <edwardk> cmccann: in fact i just shuffled 90% of the module names around
00:10:42 <cmccann> yeah, I could tell ;]
00:11:31 <edwardk> when i'm done with the current batch of changes you'll have nice quaternions and complex numbers and free tensor algebras, free commutative bands, etc.
00:11:36 * cmccann poked at it a bit to see what was going on and decided it would be better to wait for you to finish reorganizing it
00:12:06 <edwardk> yeah
00:12:26 <edwardk> i was out on the beach at the time, so my ideas were as half-baked as i was ;)
00:12:38 <cmccann> haha
00:13:04 <kmc> edwardk gives out a lot of free stuff... comonads, monoids, commutative bands
00:13:18 <edwardk> =)
00:13:38 <shachaf> kmc: Don't be fooled, they're only free-as-in-lunch.
00:13:42 <edwardk> =)
00:13:47 <edwardk> free as in puppies
00:13:50 <kmc> haha
00:13:50 <shachaf> They still have no rights.
00:14:57 * cmccann saw an ad for "free burritos" the other day and was reminded of edwardk's libraries
00:15:53 <edwardk> "This software is "free as in puppies": it's free, but you'll have to pay to get it fixed or else live with a lot more problems…"
00:16:00 <edwardk> hah
00:16:19 <luite> hehe
00:16:34 <kmc> haha
00:16:45 <copumpkin> edwardk: went back and reread the posts and they woke me up, dammit
00:16:54 <edwardk> =)
00:17:25 <edwardk> i'm just trying to get the much shrunken algebra package to compile
00:17:35 <copumpkin> shrunken how!
00:17:39 <edwardk> its grown in features, but shrunken in module count
00:17:48 <edwardk> went down from ~70 to ~44
00:18:10 <edwardk> i moved the multiplicative modules into the algebra modules, and then exposed a single Numeric.Algebra facade for all the classes
00:18:19 <copumpkin> do you have a generalized factoring algorithm?! :P
00:18:22 <edwardk> so its only the concrete types that get exposed as user visible modules other than that
00:18:34 <edwardk> not yet
00:18:34 <copumpkin> factor :: UFD a => a -> [a]
00:18:49 <edwardk> can't have UFDs, were constructive
00:19:11 <copumpkin> hmm, can't say I've really thought through the ramifications of it there
00:19:46 <edwardk> you need to play with http://en.wikipedia.org/wiki/B%C3%A9zout_domain and Prufer domains instead
00:19:52 <edwardk> thats basically what i'm building on
00:20:40 <edwardk> noetherian rings say _all_ ideals are finitely generated, since every non-empty set of ideals has a maximal element
00:20:58 <edwardk> but we can only do that for finitely generated ideals
00:21:05 <edwardk> because we have to look at all the members
00:21:24 <edwardk> so we get lots of annoying names ;)
00:23:00 <copumpkin> damn constructivists
00:23:37 <edwardk> they're wimps. kill all their witnesses and they have nothing
00:24:39 * hackagebot svm-simple 0.2.1 - Medium level, simplified, bindings to libsvm  http://hackage.haskell.org/package/svm-simple-0.2.1 (VilleTirronen)
00:27:41 <edwardk> !@#&*(
00:28:16 <edwardk> i was fighting to keep a bunch of classes from having to go into the same file, now i'm going to have to relent and put them in one place =(
00:28:21 <edwardk> damn orphans
00:29:19 <edwardk> i decided to use Set as the representation for my free idempotent commutative module
00:29:46 <edwardk> but to make instances for it I need monoidal to live in the same place as additive, but i need leftModule for monoidal, and semiring for leftmodule
00:30:01 <edwardk> so now basically a dozen classes HAVE to live together
00:32:34 <edwardk> Set was fine, it was IntMap and Map as the commutative (but not idempotent) bands that got me
00:32:52 <copumpkin> ack
00:37:47 <cmccann> edwardk, just make a module for all the instances and call it "Orphanage" :P
00:37:53 <edwardk> =)
00:38:10 <edwardk> right now its Numeric.Algebra.Class because they keep balling up in there
00:38:32 * cmccann really thinks the orphan instance issue needs a better solution, but eh
00:38:34 <edwardk> which is an internal module reexported by a slightly more sane set of other internal modules for my own sanity and by the big Numeric.Algebra catch-all
00:40:36 <edwardk> otoh: it IS streamlining all the downstream imports ;)
00:50:01 <BrianF> Is there a more efficient way to write this (just an example)?: map (`rem` 5) (map (*7) [1..10])
00:50:33 <BrianF> In other words, use map with two or more operations in sequence...
00:50:52 <edwardk> sure, fuse them
00:50:55 <kmc> map ((`rem` 5) . (* 7))
00:51:02 <kmc> map f (map g x)  ≡  map (f . g) x
00:51:02 <edwardk> map ((`rem` 5) . (* 7))
00:51:17 <BrianF> Cool, thanks :-)
00:51:34 <kmc> in fact GHC applies this optimization automatically, to make your program faster, but it's also a nicer way to write the code usually
00:52:51 <BrianF> Good to know; I figured it could be done, just didn't know syntax for it (total newbie :-P)
00:52:58 <kmc> ah, it's not really syntax
00:53:06 <kmc> (.) is an ordinary infix operator
00:53:09 <kmc> @src (.)
00:53:10 <lambdabot> (f . g) x = f (g x)
00:53:10 <lambdabot> NB: In lambdabot,  (.) = fmap
00:53:26 <BrianF> Ohh, okay
00:54:42 * hackagebot bindings-svm 0.2.1 - Low level bindings to libsvm.  http://hackage.haskell.org/package/bindings-svm-0.2.1 (VilleTirronen)
01:19:44 <paczesiowa> dcoutts: unpack function in tar library uses 'mkdir' (createDirectoryIfMissing False), whereas it should (imo) use 'mkdir -p' (createDirectoryIfMissing True), otherwise it cannot even unpack ghc tarballs.
01:42:18 <ari> Hi. Is there a way to to get the type of an expression inside a function, such that you could annotate the expression with that type and the program's meaning wouldn't change?
01:42:53 <sipa> :t typeOf
01:42:55 <lambdabot> forall a. (Typeable a) => a -> TypeRep
01:43:55 <ziman> ari, you can replace that expression with some nonsense and get the type from the error message :)
01:44:04 <benmachine> hah
01:44:12 <ion> typeOf cannot return polymorphic type representations.
01:44:15 <benmachine> or you could move it to the top level and use :t in ghci
01:44:21 <benmachine> yeah typeOf isn't what you want really
01:44:39 <ziman> if the function is polymorphic, sometimes this is not possible without the extension whose name I cannot remember (adds lexical scoping for type variables)
01:44:51 <ion> You could also just figure out the type. :-)
01:44:57 <benmachine> ziman: what's not possible?
01:45:04 <liyang> {-# LANGUAGE ScopedTypeVariables #-}
01:45:44 <ziman> benmachine, "head :: [a] -> a; head (x:xs) = x :: a" is not possible
01:45:58 <benmachine> ziman: ah, I see what you mean
01:48:06 <ari> Well, what do you know... I don't need to worry about scoped type variables so long as I'm not seeing any foralls, right? Because I was too confused by generics to remember that I could just do what benmachine said
01:49:42 <ziman> If you include implicit foralls in the "foralls", then yes, you needn't worry about scoped type variables.
01:54:39 <erus`> stand back everyone... im going to write a game in haskell!
01:55:45 <JuanDaugherty> you think you're the first?
01:57:27 <cheater_> erus`, nice
01:57:59 <erus`> one of the first 50 people in the world
01:58:09 <erus`> 50 out of 6 billion
01:58:28 <JuanDaugherty> more like 7 at this point
01:59:53 <JuanDaugherty> 7.1 apparently
02:00:28 <JuanDaugherty> but what's a billion ape-like creatures here or there
02:02:24 <erus`> overpopulation
02:02:29 <erus`> scary stuff
02:06:59 * hackagebot hslua 0.3.4 - A Lua language interpreter embedding in Haskell  http://hackage.haskell.org/package/hslua-0.3.4 (GracjanPolak)
02:07:05 <erus`> i need a list of games in haskell
02:07:10 <erus`> do i can do something different
02:07:27 <quicksilver> erus`: here is a partial list : http://hackage.haskell.org/packages/archive/pkg-list.html#cat:game
02:07:31 <quicksilver> I'm sure there are more.
02:07:59 <quicksilver> here is another, probably overlapping, partial list http://www.haskell.org/haskellwiki/Applications_and_libraries/Games
02:08:19 <erus`> 'ines of monad' :)
02:08:36 <cheater_> lol
02:09:03 <cheater_> zelda :: triforce :: haskell :: y combinator?
02:09:29 <benmachine> Raincat is nice
02:10:01 <ion> y u confuse me
02:11:48 <erus`> ok bomberman it is
02:22:44 <erus`> good old glfw
02:28:43 <ion> @tell djahandarie The Control.Newtype function types might be made clearer simply by using actual words instead of single-letter type variables.
02:28:44 <lambdabot> Consider it noted.
02:34:50 <ion> @tell djahandarie How about something like this? ala ∷ (Newtype new orig, Newtype new' orig') ⇒ (orig → new) → ((orig → new) → b → new') → b → orig'
02:34:50 <lambdabot> Consider it noted.
02:38:35 <ion> @tell djahandarie Of course, it would be even nicer to somehow say “b is probably a container of orig” in the signature. :-)
02:38:36 <lambdabot> Consider it noted.
02:41:22 <nCdy> how to read System.Process (cmd command) output ?
02:41:49 <nCdy> I want to get kernel's version
02:44:03 <quicksilver> nCdy: use readProcess?
02:52:21 <benmachine> @where rwh
02:52:22 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
02:52:33 <erus`> whats it called where you name members of a type?
02:53:45 <ehamberg> kmc: did you end up writing a blog post about your kakuro solver?
02:58:46 <ari> Ooookay, I think I'm starting to confuse ghc as well as myself. I have a function here whose type is annotated in the source code... but ghci's :t reports the function as having a different type than that. And it accepts *neither* of those as the function's type when I copypaste them into ghc.
02:58:49 <identity_> erus`: record syntax?
02:59:39 <hpaste> ari pasted “Generics craziness” at http://hpaste.org/49163
03:01:07 <ari> The function in question is gzipWithQ. I have no idea what I'm doing really, I've just been taking code from syb's Data.Generics.Twins and blindly adding a proxy argument to everything. Except with gzipWithQ which wouldn't typecheck without a type annotation on perkid and funs.
03:07:23 <erus`> identity_: cheers
03:11:55 <erus`> can i have a list of a class?
03:12:38 <dankna> erus: no, but see existentially quantified types
03:15:03 <roconnor> @seen twanvl
03:15:03 <preflex>  twanvl was last seen on #haskell 15 days, 12 hours, 19 minutes and 34 seconds ago, saying: roconnor: were you looking for me?
03:15:03 <lambdabot> Unknown command, try @list
03:16:25 <Jafet> What's a list of a class?
03:17:20 <Jafet> With a little investment, you can make a list of values of types in a class.
03:19:25 <dankna> so
03:19:50 <dankna> I'm trying to make a type-level ontology of certain units of measurement
03:20:00 <dankna> for example, specific heat is Joules per kilogram times Kelvin
03:20:12 <dankna> is there such a thing as type-level sets?
03:20:27 <roconnor> the already exists a dimension library IIRC
03:20:33 <roconnor> I'm not sure how it deals with this
03:20:33 <dankna> yeah, I looked, it doesn't do what I want
03:20:51 <quicksilver> type-level sets are very hard to do I think
03:20:54 <benmachine> http://hackage.haskell.org/package/dimensional
03:20:59 <quicksilver> because type-level Ord is hard.
03:21:07 <dankna> yes, that was exactly what I was going to ask about
03:21:10 <quicksilver> however for dimensions you could probably just write instances manually
03:21:19 <dankna> that's true, hmm
03:21:22 <quicksilver> and/or generate them with a program you wrote
03:21:28 <quicksilver> since there aren't *that* many cases.
03:21:33 <dankna> yeah the thing about dimensions is that I want to store the scale as part of the type
03:21:37 <roconnor> aren't there an infinite number of cases?
03:21:45 <dankna> or use TH, indeed.
03:21:51 <quicksilver> roconnor: not for the "set" part, I think
03:22:22 <quicksilver> there are just 2^n possibilites where n is the number of orthogonal dimensions
03:24:48 <dankna> yeah, I'm not clear on how I would write it though.  hmm.  something like data TypeLevelSet TypeLevelNaturalNumber = Empty :: TypeLevelSet Zero | Cons :: Dimension TypeLevelNaturalNumber -> TypeLevelSet TypeLevelNaturalNumber -> TypeLevelSet TypeLevelNaturalNumber
03:25:29 <dankna> but then I need to enforce the constraint that the nat associated with the consed Dimension is greater than the nat associated with the previous set
03:27:26 <dankna> the nice thing about that approach is that I can then just do data Dimension TypeLevelNaturalNumber = Grams :: Dimension Zero | Meters :: Dimension One | Seconds :: Dimension Two ...
03:27:36 <dankna> without having to do the n^2 thing you just said
03:28:56 <dankna> I actually want the type of Cons to be a little more complicated than that, Cons :: ScalingFactor -> Dimension TypeLevelNaturalNumber -> TypeLevelInteger -> TypeLevelSet TypeLevelNaturalNumber -> TypeLevelSet TypeLevelNaturalNumber
03:29:36 <dankna> where ScalingFactor is an enumeration type like UnitScaling | Kilo | Mega | Milli | Micro
03:29:44 <dankna> and the TypeLevelInteger expresses the power
03:29:45 <dankna> oh!
03:29:52 <dankna> that actually suggests a solution
03:29:58 <dankna> given the relatively small number of dimensions...
03:30:04 <dankna> I can just be like
03:30:22 <erus`> @hoogle Float -> GLFloat
03:30:23 <lambdabot> Warning: Unknown type GLFloat
03:30:23 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
03:30:23 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
03:31:19 <dankna> data UnitOfMeasure = UnitOfMeasure { gramsScaling = ScalingFactor, gramsPower = TypeLevelInteger, metersScaling = ScalingFactor, metersPower = TypeLevelInteger, ? }
03:31:25 <dankna> where each possible dimension is enumerated in the type
03:31:34 <dankna> and then I let the power be zero for any dimension not relevant
03:31:49 <dankna> that should actually work!  of course, I need type-level integers haha
03:32:09 <bxc> i had a play with doing this sort of stuff in agda once
03:32:13 <bxc> never got very far
03:32:13 <dankna> and I need type-level functions to multiply two UnitOfMeasures together.  can type families do that?
03:32:19 <Jafet> Download ghc8
03:32:22 <dankna> really?  I would have thought Agda with dependent types could do it
03:32:27 <dankna> GHC8 ? exists?
03:32:40 <bxc> yeah i think it should be fine - just got busy with other things
03:32:46 <Jafet> Sorry, I coughed. That was "ghc head"
03:33:01 <dankna> oh, yeah.  why, did the type-level nats thing get rolled into it?  I hadn't heard!
03:33:23 <dankna> I am running HEAD from two months ago - I can't update to latest because GHC doesn't build on OS X Lion
03:33:26 <Jafet> I would be sad if it was still in a branch
03:33:29 <dankna> (I and some others are working on fixing that)
03:33:52 <dankna> I would have expected to have heard if it had been rolled in
03:33:59 <dankna> http://hackage.haskell.org/trac/ghc/ticket/4385
03:34:50 * Jafet is hereby sad
03:34:54 <dankna> sorry!  hehe
03:35:02 <dankna> maybe I should use that branch for this project though
03:35:17 <dankna> it does have a milestone set, and I bet they'd appreciate the testing
03:35:30 <Jafet> But why do you want a prefix in the type system?
03:36:02 <Jafet> (More fun: the SI base unit is kilogram, not gram)
03:36:19 <dankna> (tough shit, I'm using grams lol)
03:36:31 * hackagebot blakesum 0.3 - The BLAKE SHA-3 candidate hashes, in Haskell  http://hackage.haskell.org/package/blakesum-0.3 (KevinCantu)
03:36:39 <dankna> because I want to then define data DimensionedQuantity (Integral i) => DimensionedQuantity i UnitOfMeasure
03:36:59 <dankna> to make an /integral/ value in that unit, rather than a floating-point one
03:37:28 <Jafet> You can do it at the value-level with Fixed
03:37:31 <dankna> since not all units of the same dimensions are commensurate (for example, the ratio between centimeters and inches is irrational), you can't do this without storing the prefix at type level
03:37:45 <Jafet> Oh, very well
03:37:48 <dankna> hehe
03:38:17 <Jafet> But you should know that all numbers are actually rational
03:38:21 <roconnor> > (:[]) 5
03:38:22 <lambdabot>   [5]
03:38:25 <dankna> you mean because irrationals aren't numbers?
03:38:27 <dankna> very funny :)
03:38:36 <NihilistDandy> dankna: Oh, good. I'm glad I'm not the only one who had trouble building head on Lion
03:38:51 <dankna> NihilistDandy, don't worry, we're on top of it.  We /might/ even manage to get it ready by the time Lion is released.
03:39:15 <NihilistDandy> dankna: That's pretty awesome. Was it the integer-gmp issue, or is there another?
03:39:37 <NihilistDandy> Maybe even general linker pickiness
03:39:55 <dankna> we haven't hit the integer-gmp issue.  I can't really discuss the biggest issue in public, because of the NDA.
03:40:04 <NihilistDandy> Righto
03:41:05 <dankna> I wonder if Apple would do this work for us if I burned a (paid-for) developer tech support issue on it, haha
03:41:14 <dankna> probably not
03:41:23 <dankna> it's more work than an issue is really supposed to cover
03:41:40 <Jafet> Perhaps if the iphone game becomes a killer app
03:41:49 <dankna> and it would be changes to our code rather than theirs
03:41:51 <dankna> heh indeed!
03:42:23 <dankna> okay right
03:42:41 <dankna> but I still want to define a type-level function that takes two units of measure and multiplies (or divides) them
03:42:47 <dankna> is that even possible?  is that what type families are for?
03:43:50 <Saizan> sounds plausible
03:43:53 <dankna> hmm
03:44:55 <Jafet> That sounds like you'd need 2^n instances, as above
03:44:59 <araujo> hello there
03:45:14 <araujo> anybody knows who should I currently contact about haskell.org access?
03:45:23 <araujo> I had some projects hosted there but it seems they were removed
03:45:53 <dankna> araujo: how long ago did you have them?  about a year ago there was a break-in to the server, it might be fallout from that if you haven't looked at your work in some time
03:46:32 <Jafet> Perhaps you could represent units as lists of natural numbers, and write some general list metafunctions for those
03:46:37 <dankna> hmm!
03:46:45 <araujo> dankna, yeah, that could be it .... long time since I didn't check the project, like 1 year ago or so
03:46:59 <Jafet> Or lists of tuples (unit, power, scaling), where unit corresponds with N, and power and scaling correspond with Z
03:47:11 <dankna> araujo, they didn't delete anything, you just need to get in touch and verify your identity and stuff like that
03:47:12 <Jafet> (And power/=0)
03:47:30 <araujo> dankna, ok you know who should I contact these days?
03:47:55 <dankna> araujo: I think dons maybe?  Not totally sure.
03:48:17 * araujo been away from the haskell community for so long
03:48:25 <araujo> does dons still get online here? :P
03:48:32 <Jafet> preflex, seen dons
03:48:33 <preflex>  dons was last seen on #haskell 17 days, 11 hours, 7 minutes and 18 seconds ago, saying: tommd: i manually ran it a couple of times, after the captcha was added
03:48:35 <dankna> araujo, well, welcome back!  sorry your welcome wasn't a happy one.  yes he does, and you can use the bot's @tell feature if you want
03:48:46 <dankna> Jafet: that's not quite what I was thinking, with my record-based approach
03:48:51 <Jafet> Perhaps you should email him or someone else at galois
03:48:52 <araujo> dankna, indeed ... thanks, will do
03:49:08 <araujo> Jafet, yeah, will start sending emails :P
03:49:16 <wuxb> I'm back again for STM :) It seems that for readTVar/writeTVar I can't find when it failed and automatically retried. here is my paste: http://pastebin.com/5xHThZEL
03:49:18 <mauke> The paste 5xHThZEL has been copied to http://hpaste.org/49164
03:49:39 <dankna> Jafet: I was thinking more along the lines of letting power equal zero and having the "list" be of fixed length
03:50:02 <dankna> I don't mind the 2^n because TH, heh
03:50:23 <Jafet> Eh, that's 2^n instances GHC has to slog through every time
03:50:35 <dankna> hmm
03:50:36 <dankna> point
03:50:58 <Jafet> And consider your hi files...
03:51:58 <dankna> so how does the list approach avoid that, exactly?
03:52:31 <wuxb> how can I dig into one 'writeTVar' and count for how many times it retried? internally.
03:53:05 <dankna> not sure, never used STM
03:53:15 <Jafet> dankna: ideally, you write as many instances as you need to implement the general units handling, and then you can add as many units as you need
03:53:35 <dankna> Jafet: hmm
03:54:00 <Jafet> Eg. a strictly ascending list of the aforementioned tuples uniquely represents a dimensional unit
03:54:15 <dankna> Jafet: well I'll try it your way first.  I think though that I'm going to get back into hacking Cabal, which is the perpetrator of the largest unresolved issue in GHC-Lion compatibility, so that I can build HEAD-plus-naturals and use it for this
03:54:21 <Jafet> Then you can manipulate them using the usual linear merge/difference
03:54:30 <dankna> right
03:54:38 <dankna> okay, that makes sense to me
03:54:48 <Jafet> Well, I think it's feasible to use the old skool type naturals for this.
03:55:06 <dcoutts> dankna: what's the GHC-Lion incompatibility?
03:55:07 <dankna> probably, but I like the new ones and this is not a production project :)
03:55:27 <dankna> dcoutts: as far as Cabal is concerned, it's the issue you and I discussed a few weeks ago with Cabal thinking gcc is the C compiler
03:55:44 <dankna> you told me roughly how you'd like it handled, I just have to do it
03:56:20 <dcoutts> dankna: you mean how it thinks ghc is the C compiler
03:56:25 <dankna> yes, sorry, that.
03:56:28 * dcoutts thought gcc was a C compiler :-)
03:56:38 <dankna> gcc is /a/ C compiler
03:56:42 <dankna> but not /the/ C compiler anymore
03:57:04 <dankna> I did a hell of a lot of autoconf hacking to fix the GHC build system to no longer make that assumption, and provide some needed information about the C compiler
03:57:37 <dankna> well, even a tiny amount of autoconf hacking is a hell of a lot? SUCH an ugly language
03:58:03 <dankna> well actually m4 is a thing of beauty.  the autoconf surrounding it is a thing from the elemental plane of ugly, however.
03:58:11 <dankna> much like how pearls are surrounded by oysters.
03:58:27 <Jafet> All automation was implemented manually
03:58:42 <dankna> I'm not even sure what that means :)
03:59:47 <dankna> dcoutts: got a moment to talk about this again?  because I actually do have a question for you now that I think of it
04:00:48 <dankna> dcoutts: I had changed the GHC build system to expect --with-cc to ./configure instead of --with-gcc.  now, you explained to me that that's not how Cabal thinks of things; it doesn't have abstract tools that fill roles, it has specific programs.  so --with-cc doesn't make sense, only --with-gcc, --with-llvm-gcc, --with-clang, etc, as far as Cabal is concerned.
04:01:23 <dcoutts> dankna: yes, that's how it is now
04:01:33 <dcoutts> there's no generic notion of binutils toolchain
04:01:49 <dankna> right.  well, I need/want to add such a notion, of course, but I won't call it --with-*, to avoid confusion
04:02:15 <dankna> I'm thinking make --with-gcc, --with-llvm-gcc, --with-clang, --with-ld be four separate options
04:02:53 <dankna> that last one might be a separate issue, if we can get away with still letting GHC do our final linking for us for now.  in the long run we want to change that but I also want the patch to be minimal in size so all y'all can review it faster.
04:03:19 <dankna> this issue has gotten limited attention to date, but as soon as Lion hits the general public it will be getting a lot more!
04:03:24 <hpaste> “Mukesh Tiwari” pasted “Elliptic Curve” at http://hpaste.org/49165
04:03:37 <dcoutts> dankna: how do we decide whether to use gcc, clang etc? is that just a bit of baked in platform knowledge?
04:03:48 <keep_learning> hello all
04:03:59 <keep_learning> could some one please tell me
04:04:03 <dankna> dcoutts: it's settable at ./configure time by a --with-cc option to configure, with the default being baked-in, yes
04:04:13 <keep_learning> http://hpaste.org/49165
04:04:46 <dankna> dcoutts: the codepath that determines the default first checks the OS and defaults to gcc if not OSX, then checks the installed XCode version and conditionalizes on that to decide whether gcc or clang.
04:04:51 <dcoutts> dankna: so does --with-cc specify the C compiler flavour? or the path to the C compiler?
04:04:59 <keep_learning> i am getting error "tmp_1.hs:22:8: parse error on input `|' "
04:05:21 <dankna> dcoutts: the path to it.  like all autoconf paths, you can also specify just a filename and it will check $PATH for it.
04:06:06 <dankna> dcoutts: it then runs the specified program with options that get it to emit version information, and does some ugly evil sed hacking to extract the flavor and version number from that.
04:06:10 <ion> Some seem to use “case foo in pattern → bar” instead of “let pattern = foo in bar”. Is there a non-aesthetic reason for using case for that purpose?
04:06:20 <dcoutts> dankna: there's a precedent here, which is --ghc/--hugs etc which select the Haskell implementation
04:06:41 <dankna> dcoutts: oh!  okay.  you're talking about Cabal options, not configure options, though, yes?
04:06:47 <dcoutts> dankna: yes
04:06:52 <dankna> okay.
04:07:31 <dcoutts> dankna: I thought you were too, we don't really care what autoconf ./configure does, except perhaps as one model/precedent to follow, but I'm not sure autoconf helps us here
04:07:53 <hpc> ion: with let-in, you can't add more patterns after the fact
04:07:56 <hpc> with case, you can
04:07:58 <dankna> dcoutts: good, sorry, I was talking about autoconf options.  I'm glad to hear you don't care because it's my opinion that Cabal shouldn't care
04:08:02 <dankna> ? what autoconf does
04:08:11 <dcoutts> dankna: well, autoconf does have a CC= env var, and it expects that cc to follow some standardish options
04:08:12 <hpc> at least, that's why i would use case over let-in
04:08:36 * hackagebot docidx 1.0.1 - Generate an HTML index of installed Haskell packages and their documentation.  http://hackage.haskell.org/package/docidx-1.0.1 (AndyGimblett)
04:08:37 <dankna> dcoutts: no, the GHC build system ignores the CC env var I think, but hold on one sec while I check my notes, I definitely checked that, I just don't remember
04:08:48 <Saizan> ion: "let p = foo in bar" is "case foo of ~p -> bar"
04:08:51 <ion> hpc: I mean cases where there will never, ever be more than one pattern.
04:08:54 <keep_learning> any one please.
04:09:10 <keep_learning> i am not able to debug it  after many tries .
04:09:12 <Saizan> ion: i.e. the let one is lazier
04:09:48 <dankna> dcoutts: okay here's the status.  we never used $CC in the GHC build system.  we did use $GCC but all it did was provide a default for --with-gcc.
04:10:02 <dankna> dcoutts: I renamed both the env var, to $CC, and the option, to --with-cc
04:10:15 <dankna> dcoutts: but kept the interaction between them the same
04:10:43 <dcoutts> dankna: doesn't ghc's build system actually need gcc
04:10:47 <dcoutts> not any old cc
04:10:57 <dcoutts> it uses some gnu C isms in places
04:10:57 <dankna> dcoutts: not any more!  I did a lot of work to change that, would you like to see my patch notes?
04:11:06 <dcoutts> what about the global register vars?
04:11:17 <dankna> dcoutts: someone else did some work on that, which I am in the process of merging with my patch
04:11:28 <dankna> dcoutts: except I can't yet because of the Cabal issue preventing me from getting that far in the build
04:11:31 <dcoutts> fair enough
04:11:34 <dcoutts> dankna: ok, so there's two options here then, one is to go for a --with-cc, --with-linker, --with-assembler style options that specify a path and have cabal figure out which implementation it is talking to.
04:12:05 <dankna> except I strongly feel that they shouldn't be called --with-* in that case
04:12:15 <dankna> maybe --tool-*?
04:12:29 <dcoutts> dankna: we already have --with-compiler and --with-hc-pkg which are generic options
04:12:33 <dankna> to make it clear that they are different things from --with-<program> options
04:12:35 <dankna> oh okay then
04:12:38 <dankna> I retract my objection :)
04:12:56 <dankna> I would probably make it --with-c-compiler personally, rather than --with-cc, are you fine with that?
04:13:11 <dcoutts> --with-compiler specifies the location of the Haskell compiler and hc-pkg prog respectively (though in practice only ghc has a hc-pkg prog)
04:13:12 <Saizan> keep_learning: you can't attach "where" to guards
04:13:20 <dankna> right, makes sense to me
04:13:30 <dcoutts> dankna: the other is to have the existing --with-$PROG=$LOCATION style options and have some other flag to say which toolchain style to use
04:13:45 <Saizan> keep_learning: you can only have a single where that span over both
04:13:53 <dankna> dcoutts: right, hmm.
04:14:03 <dcoutts> dankna: so while --with-compiler specifies the Haskell compiler location, it does not select the compiler flavour, you have to do that with --hugs --jhc etc
04:14:11 <Saizan> keep_learning: you could use let ... in .. though
04:14:36 <dankna> dcoutts: then what I would do is a hybrid approach.  I don't fancy teaching Cabal how to detect C compiler flavor, it's finicky.
04:14:56 <dcoutts> dankna: and of course in practice one probably does not need to select the toolchain flavour since the default automatic decision should be right
04:15:03 <nkpart> hey, is anyone aware of an article on the differences between the iteratee and the enumerator packages?
04:15:12 <dankna> dcoutts: so how about --with-c-compiler=$LOCATION, --with-linker=$LOCATION, --with-assembler=$LOCATION, --gcc --llvm-gcc --clang to specify the flavor of all three
04:15:16 <dreamer_> ahhhhhh man this has been compiling for hours
04:15:17 <dankna> (the flavor must agree, probably)
04:15:20 <tew88> I installed the haskell platform on Ubuntu 11.04 from a PPA. I did a cabal update and a cabal install of hlint (which, despite a few warnings, seemed to complete), but when I attempt to: hlint file.hs - I'm informed that hlint is not installed and that I should install it with apt-get install hlint
04:15:26 <tew88> Any suggestions?
04:15:34 <dankna> dcoutts: yes, the default automatic decision is going to be a pain to implement, but I agree that it should be right
04:15:44 <dreamer_> and it isn't even the platform
04:15:54 <dcoutts> dankna: so we can make it something else entirely, like --toolchain-cc=gcc, --toolchain-foo=bar
04:16:12 <dcoutts> dankna: ie an override for the toolchain flavour
04:16:43 <dcoutts> dankna: and continue to specify actual program locations specifically, --with-gcc-llvm=... rather than --with-c-compiler=...
04:17:01 <dankna> dcoutts: okay, yes, that's what I was about to suggest, and I like --toolchain-* as the naming pattern.
04:17:41 <dankna> then we're in agreement
04:17:42 <dcoutts> dankna: so that might be the least invasive change too
04:17:46 <dankna> yeah
04:17:48 <Saizan> tew88: check ~/.cabal/bin/hlint
04:18:03 <dankna> I'll note that we can actually snarf the default flavors out of ghc --info
04:18:33 <dcoutts> dankna: so to be clear --toolchain-blah=flavour, selects the type/flavour of the blah toolchain item, not the path/location of any program
04:18:48 <dankna> right, exactly what I was thinking
04:19:04 <dankna> where flavor is an enumeration with (for now) three values, gcc llvm-gcc clang
04:19:06 <dcoutts> dankna: yes, this would be done in configureToolchain in GHC.hs, default detection with overrides from the command line
04:19:12 <dcoutts> dankna: right
04:22:01 <dankna> now, another thing
04:22:09 <dankna> ghc as far as I can tell never calls ld directly
04:22:17 <dankna> instead it calls the C compiler
04:22:23 <dankna> ditto the assembler
04:22:29 <dcoutts> yes
04:22:46 <dcoutts> dankna: well, it calls ld directly in one place
04:22:49 <dankna> oh
04:22:52 <dcoutts> but mostly via gcc
04:22:58 <dankna> well, even one place is enough haha
04:23:18 <dankna> what is that place?  if you know offhand
04:23:19 <dcoutts> to combine multiple .o files into one .o file
04:23:23 <dankna> oh, okay
04:23:25 <dcoutts> for ghci .o files
04:23:28 <dankna> right
04:23:43 <dankna> I'm amazed I didn't notice that
04:23:44 <dankna> heh anyway
04:23:53 <dcoutts> dankna: do you think that'd be a problem?
04:23:59 <dankna> hopefully ghc doesn't need to know the ld flavor
04:24:11 <dcoutts> it's just ld -r out.o ${lots of input .o files}
04:24:13 <dankna> ld's command-line interface is supposedly a superset of the POSIX one
04:24:34 <dankna> I think that's fine and we can continue to ignore the issue of ghc not knowing the ld flavor it's dealing with
04:24:40 <dankna> but Cabal should know
04:24:53 <dankna> shouldn't it?  hmm
04:25:25 <dankna> I should remember this without asking, but I don't.  does Cabal ever call ld directly?  do we ever plan for it to?
04:28:09 <dcoutts> dankna: I just said, yes it does call ld directly.
04:28:15 <int-e> there's Distribution.Simple.Program.Ld
04:28:30 <dankna> oh, I misunderstood - thought you were saying ghc made that call
04:28:47 <dcoutts> ghc does something similar actually
04:28:54 <dankna> we have two sets of knowledge here, ghc's and Cabal's
04:29:17 <dankna> there's no fundamental reason they have to be the same; in general I would expect ghc to know exactly as much as it really need to, and Cabal to know all there is to know
04:29:55 <dankna> okay, so we do need all three toolchain itmes - cc, ld, as
04:30:29 <dankna> oh I have one more question!  I notice that the ghc copy of the Cabal library uses git, as opposed to your master copy which uses darcs
04:30:42 <dankna> and they aren't in sync as far as I can tell
04:30:59 <int-e> and cpp?
04:31:16 <dcoutts> dankna: ghc has lagged mirrors of many upstream libraries
04:31:17 <dankna> int-e: we want to move away from using cpp at all in the long run :/
04:31:32 <dankna> obviously since I want to use this immediately, I have to actually develop against GHC's copy, and make it a git patch instead of a darcs patch.  is that going to cause a hassle for you, or can you migrate it in the other direction?
04:32:01 <dcoutts> dankna: they are synced manually so that someone is able to test that ghc continues to build against the updated libs (so lib authors themselves do not need to test ghc every time they make some minor commit)
04:32:13 <dankna> that of course makes sense, yes, it's a good policy
04:32:15 <dcoutts> dankna: a git patch is not going to be useful
04:32:26 <dankna> damn though, because I can't even test my own work against the darcs HEAD
04:32:28 <dcoutts> because it's git and because it's against a lagged version
04:32:37 <dankna> what I need is a copy of the darcs repo which matches the lagged git version
04:32:39 <dcoutts> but it's likely the same patch will apply upstream
04:32:42 <dankna> how can I construct such a copy?
04:32:56 <dcoutts> take the darcs repo and obliterate the last few patches until they match
04:33:04 <dankna> good thought, yes, thank you
04:33:05 <dcoutts> compare the git log and darcs changes
04:33:08 <dankna> okay!
04:33:48 <dcoutts> dankna: or just use the working copy of ghc's branch of the lib and then use meld or something to move your changes over to cabal head
04:34:08 <dankna> that sounds more complicated :) but the pointer to meld is a good one
04:34:08 <dcoutts> so you can submit patches against the upstream version
04:34:40 <dankna> what I think I'll do is construct my patch against the obliterated darcs repo, then merge it against the darcs head
04:34:46 <dcoutts> ok
04:34:57 <dankna> that way I can deal with merge and port-to-darcs as two separate operations, heh
04:35:34 <dankna> okay, I think that answers every question I had.  thank you for your time, as usual!
04:35:46 <dcoutts> np :-)
04:36:55 <zong_sharo> if i want to generate c code, what is my best option?
04:37:10 <tibbe> zong_sharo, there's a lib, hold on
04:37:33 <tibbe> zong_sharo, http://hackage.haskell.org/package/language-c
04:38:14 <tibbe> zong_sharo, use Language.C.Pretty to pretty-print an AST from Language.C.Syntax.AST
04:40:50 <zong_sharo> tibbe: tried it, not really looks viable option for generation
04:42:05 <zong_sharo> damn, even atom does not uses it
04:42:35 <hpaste> erus` pasted “stupid lets” at http://hpaste.org/49166
04:42:53 <erus`> Guys, i would like to replace the lets there with a where statement
04:43:03 <erus`> but i get parse error on where when i try an add one
04:43:11 <erus`> i have tried every indent level
04:44:24 <tibbe> zong_sharo, I haven't used it personally, but to my knowledge it's the most complete library in terms of support all of C. What's your problem?
04:45:24 <erus`> ok ignore that
04:56:37 <zong_sharo> tibbe: give me some time, and i will show you what is exactly my problem with language-c
04:58:07 <jonkri> how can i debug a "Server error: Maybe.fromJust: Nothing" error in happstack? i use fromJust in a couple of places and i would like to get at least the line number :)
05:00:22 <dankna> jonkri: you can recompile with --enable-executable-profiling --ghc-options=-rtsopts=all (note: this requires you to have your entire Haskell universe built with profiling) and then make sure happstack is invoked with +RTS -xc
05:00:28 <dankna> wait
05:00:50 <dankna> compile with --enable-executable-profiling --ghc-options="-rtsopts=all --auto-all" and run with +RTS -xc
05:00:59 <dankna> I think it might be -auto-all, not --auto-all
05:01:02 <dankna> anyway, something like that
05:01:10 <dankna> this will give you a dump of the stack of call centers
05:01:15 <dankna> it might very well not be useful though
05:01:28 <zong_sharo> tibbe: long story short, even to generate something like int main(int argc, char** argv) {return 0; } i need to construct overly-complicated ast whic is completely not suited for generation purpoces
05:01:34 <dankna> cost centers (not call centers, oops again) don't have line numbers associated with them
05:02:03 <jonkri> cost centers?
05:02:07 <dankna> and it may just print the deepest one, for some reason I don't understand, which would not be useful as the deepest one is fromJust.  I know that's the case with array indexing at least.
05:02:15 <dankna> they're a concept from the profiler, which is why you're compiling with profiling options
05:02:27 <dankna> loosely a cost center is any expression that has a name for profiling attached to it
05:02:34 <dankna> the -auto-all flag creates one for each top-level function
05:02:43 <dankna> imo fromJust should be removed from the language
05:02:51 <jonkri> phew, ok, will try it out. thanks :)
05:02:52 <jonkri> why?
05:03:04 <dankna> because of precisely this issue: it's very difficult to trace the source of an exception it generates
05:03:21 <jonkri> would it not be better if the tracing tools improved instead?
05:03:23 <dankna> it's not immediately feasible to get rid of pure code that throws exceptions, but we can stop encouraging it
05:03:27 <dankna> welllll
05:03:35 <jonkri> i mean
05:03:35 <dankna> tracing is nontrivial in Haskell, because of lazy evaluation
05:03:56 <jonkri> i'm the one in the wrong here. i should not use fromJust unless i'm sure
05:04:01 <dankna> most people in this channel probably agree with my sentiment if not my conclusion
05:04:21 <dankna> that pure code that generates exceptions is bad
05:04:40 <dankna> you're not "in the wrong", there is no right or wrong, it's just code, just a tool to be used as you see fit
05:04:50 <jonkri> so you think the head function should be redesigned as well?
05:04:52 <dankna> but you did make your own bed and now have to lie in it, yes, heh :)
05:05:01 <dankna> yes, I think head should be removed or redesigned
05:05:10 <jonkri> interesting
05:05:22 <dankna> I'm not sure how to achieve that exactly though :(
05:06:03 <dankna> for me a very problematic one has been ! (or do I mean !!? whichever one is for arrays) because there is no real alternative to it
05:06:54 <dankna> for arrays, it's obvious how to redesign them - put the size of the array into its type - but that requires type-level arbitrary indices, heh
05:07:42 <dankna> I'd like to see us move in that direction but I don't expect it to happen soon.  as languages go, Haskell is not at all afraid of innovation (the LANGUAGE pragma is brilliant in that regard), but
05:07:53 <dankna> this would be a major and invasive change breaking zillions of libraries
05:08:17 <dankna> anyway!  heh
05:08:22 <quicksilver> well first of all you'd do it experimentall without breaking libraries
05:08:24 <quicksilver> as a new thing
05:08:28 <dankna> well yeah
05:08:34 <quicksilver> and then when it was proven you could make a call about integrating it.
05:08:37 <dankna> for the sized arrays, that would be easier
05:08:56 <dankna> for removal of pure functions that generate exceptions from base, breaking things would be the entire point
05:09:00 <roconnor> what's the best colour scheme for Haskell code (in slides)?
05:09:12 <dankna> roconnor: black on manila (#ffffcc)
05:09:24 <roconnor> I guess I mean syntax highlighting
05:09:52 <dankna> pronouns should be blue, prepositions should be chartreuse, articles bright red, and verbs yellow.  nouns can be black.
05:10:04 <roconnor> haskell syntax
05:10:07 <dankna> adjectives should be hand-drawn to resemble their meanings.
05:10:25 <dankna> yes, I was trying to make a point about syntax coloring in general by being purposefully ridiculous.
05:10:33 <dankna> I don't find it useful so I'm the wrong person to ask :)
05:10:43 <roconnor> ya
05:11:20 <roconnor> but I'm hoping that a little bit of syntax highlighting will make the Haskell code easier to read
05:11:23 <dankna> well
05:11:29 <dankna> types in one color, variables in another
05:11:36 <tibbe> zong_sharo, so the API is too detailed?
05:11:44 <dankna> type variables in the same color as type constructors, because case already distinguishes them
05:11:55 <tibbe> zong_sharo, could you alleviate that be creating some smart constructors that creates bigger chunks of AST?
05:12:05 <dankna> functions and values in the same color also because they are almost the same thing in Haskell
05:12:32 <dankna> I would leave operators and numeric literals in black
05:12:45 <roconnor> types are blue right?
05:12:46 <dankna> so just two colors plus black
05:13:02 <dankna> I would personally put types in a color that stands out more, because they're important to understanding the code they're near
05:13:07 <dankna> so perhaps dark red
05:13:11 <dankna> or even bright red
05:13:26 <roconnor> ya I did that before
05:13:30 <ion> While we fix the pure functions with exceptions, might as well finally get this: class Pointed f => Monad f where f >>= k = join (f <$> k); join x = x >>= id
05:13:35 <dankna> maybe orange if red is too garish?
05:13:59 <dankna> that can leave a shade of blue (I'd use steel blue, to be close to black but not the same as it) for variables
05:14:17 <aninhumer> dankna: type-level integers is one thing that dependent type languages introduce (I don't know a lot about them though)
05:14:24 <dankna> aninhumer: I'm aware :)
05:14:39 <aninhumer> Thought you might be
05:14:51 <dankna> aninhumer: there is apparently an ongoing conversation between Oleg and everyone else about whether and in what sense Haskell already has dependent typing :)
05:14:58 <dankna> aninhumer: but I'm not familiar with the details :)
05:15:42 <roconnor> but I think Conor says that types are blue, because they are Tory or something like that.
05:15:47 <erus`> how do i install Graphics.Rendering.OpenGL.Raw.ARB.Compatibility ?
05:15:50 <dankna> roconnor: that's a stupid reason lol
05:16:08 <zong_sharo> tibbe: no, i'm afraid it's not possible
05:16:09 <dankna> roconnor: there are known and important principles of graphic design which tell us that warm colors stand out better
05:16:33 <tibbe> zong_sharo, what would you like the library to look like?
05:16:43 <dankna> roconnor: mnemonic value to the colors is unimportant because those same principles also tell us that two colors plus black is almost certainly the exact right number, no less and no more
05:16:43 <tibbe> zong_sharo, is the problem as you want to incrementally output C?
05:16:51 <dankna> roconnor: and anyone can memorize two colors
05:16:57 <tibbe> zong_sharo, as a side-effect of something else?
05:17:03 <atoll> Hi, im trying to install the haskell-mode for emacs. It seems to work but There is command explained in the doc that are not recognized. http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs#Tips_and_use
05:17:05 <int-e> erus`: it's part of the OpenGLRaw package
05:17:14 <tibbe> zong_sharo, This is how most compilers work (although they output e.g. assembly)
05:17:19 <dankna> roconnor: I guess I have remarkably strong opinions on this considering that I actively advocate against doing it at all, lol!
05:17:27 <roconnor> :)
05:18:07 <aninhumer> I certainly think size-typed arrays/lists would be useful, I never feel like using a variable size list for data that has a fixed size is fitting with the "use types to avoid errors" ideas
05:18:57 <dankna> yes :)
05:19:09 <zong_sharo> tibbe: this is not an issue, the problem is - ast is plainly unusable to the means of generation, at least for me
05:19:40 <tibbe> zong_sharo, I'm afraid I don't understand your problem well enough.
05:19:43 <dankna> and if you want your function to be polymorphic on size, you just use a type variable for that size, which implicitly means forall quantification (or did I get that backwards? either that or exists quantificaiton, anyway, haha)
05:19:50 <dankna> which lets the caller specify the size
05:19:51 <tibbe> zong_sharo, what would you like it to look like?
05:21:23 <zong_sharo> it would like, that for a simple "int main(int argc, char** argv) { return 0; } i need to generate a ast that if it will be written manually will be at least 500 chars in length
05:21:32 <zong_sharo> just that's dead simple
05:21:50 <aninhumer> dankna: How do you use that information in a way that can be typechecked though?
05:22:07 <zong_sharo> by my standarts - no sane person will bear such nonsense
05:22:26 <benmachine> haskell does already support statically sized arrays, but they're clumsy to use
05:22:27 <dankna> aninhumer: well, I'm not certain, there's definitely a hard problem there.  I think it might require an additional extension, an "integer in a given range" type...
05:22:47 * hackagebot dclabel-eci11 0.2 - Dynamic labels to assign confidentiality and integrity levels in scenarios of mutual distrust  http://hackage.haskell.org/package/dclabel-eci11-0.2 (AlejandroRusso)
05:23:14 <dankna> zong_sharo: so your complaint is that the AST is too versatile and therefore too verbose.  I don't have a lot of sympathy for that.  it's not possible to make a simpler one that can still express all of C.
05:23:17 <benmachine> http://hackage.haskell.org/package/vector-static
05:23:35 <aninhumer> benmachine: Do they have type level size though?
05:23:38 <dankna> zong_sharo: just write helper functions for the cases you care about.  which will be different from the cases everyone else cares about, which is why the library doesn't already have them.
05:23:49 <benmachine> aninhumer: yes, but like I said, clumsy to use
05:24:40 <dankna> ah.  that page informs me that compumpkin is Daniel Peebles.  right.  I was trying to remember that this morning when looking at my Google+ feed :)
05:26:07 <mreh> this place keeps getting bigger
05:26:10 <mreh> are we top yet?
05:28:10 <tibbe> zong_sharo, so the library generates to verbose output?
05:29:45 <Botje> we're bigger than #perl, at least
05:30:05 <mreh> if Foldable implements toList, what can I use to get fromList, I've got Pointed and Monoid
05:30:23 <mreh> Botje, God does exist
05:30:24 <zygoloid> we're 8th overall on freenode
05:30:35 <mreh> yea, i just looked it up :)
05:30:57 <zygoloid> 2nd highest programming language (after #python)
05:31:29 <zygoloid> mreh: God does exist, and is lurking in #perl :)
05:32:17 <quicksilver> mreh: there is an obviois fromList using Pointed and Monoid but as far as I know it's not written down anywhere.
05:32:18 <mreh> what a cruel and unloving god he is
05:32:38 <mreh> quicksilver: was it an original thought on my part then?
05:32:53 <quicksilver> mreh: I'm afraid not :)
05:33:11 <mreh> i'll never write that papre
05:33:28 <quicksilver> mreh: there are some ramblings in http://www.haskell.org/haskellwiki/Foldable_and_Traversable along those lines
05:33:45 <dankna> are we really bigger than #perl?  awesome!
05:33:52 <quicksilver> mreh: (filter described there needs pretty much the same things as fromList)
05:34:34 <mreh> i was having alot of fun wrapping lists deriving type classes, but then when I was parsing things trying to stuff them into these types ala sequence or liftM2 (:) it wasn't going to work
05:34:48 <mreh> so I thought liftM2 (mappend . pure) was the next best thing
05:35:11 <mreh> quicksilver: well it's not far from concatMap really is it
05:36:49 <quicksilver> no.
05:36:58 <zong_sharo> tibbe: no use, it's complicated beyond usability (at least for generation), funny but stuff like feldspar or atom does not bother to use it either
05:38:00 <mreh> i was too tired of seeing type errors that included types like [[[Foo]]]
05:38:02 <atoll> Hi, i've install the haskell-mode for emacs, but some bind described here http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs#Tips_and_use are undefined in my emacs. Why ?
05:38:34 <atoll> By exemple C-c C-= doesn't work
05:40:02 <Botje> is it enabled?
05:40:27 <atoll> I've added the mode in my .emacs and it is displayed in my bottom bar
05:41:26 <quicksilver> atoll: those commands have been removed.
05:41:38 <atoll> quicksilver: Why are them described in the wiki ?
05:41:42 <atoll> they*
05:42:02 <quicksilver> the wiki was correct when it was written
05:42:09 <quicksilver> unfortunately it doesn't magically update when things change
05:43:30 <atoll> One day robots will write wikis and it will magically update §
05:48:57 <mreh> i thought wikipedia was updated by robots
05:49:17 <aninhumer> wikipedia will accurately record the number of enslaved humans at all times
05:49:36 <aninhumer> in all languages
05:52:28 <mreh> not binary?
05:55:48 <mokus> binary isn't a language, it's an alphabet
05:58:33 <mreh> silence human
06:02:28 <aninhumer> mreh: are you suggesting the robots need to be *told??*
06:05:40 <mreh> i just came here to talk about haskell
06:06:58 <mreh> wouldn't it be amazing if I could save the whole state of my signal function graph, then I could reinstate my system precisely where it was when it stopped
06:07:26 <Botje> doesn't mobile haskell do something like that?
06:08:05 <mreh> i don't know but I am intruiged
06:08:22 <mreh> we could implement web services this way too
06:08:37 <mreh> no need for all this database crap
06:09:00 <mreh> which have nothing to do with the relational database model as it is
06:13:08 <roconnor> @free eta :: F a -> G a
06:13:09 <lambdabot> $map_G f . eta = eta . $map_F f
06:15:07 <copumpkin> @free fix :: (a -> a) -> a
06:15:08 <lambdabot> f . g = h . f => f (fix g) = fix h
06:15:41 <roconnor> intresting law
06:16:50 <djahandarie> Not sure how useful that is though
06:16:51 <lambdabot> djahandarie: You have 3 new messages. '/msg lambdabot @messages' to read them.
06:16:54 <djahandarie> Oh god
06:17:45 <djahandarie> @tell ion That does help. Will make that change.
06:17:46 <lambdabot> Consider it noted.
06:30:55 <ion> djahandarie: I wonder if it would make sense to substitute “b” with “origs”, or whether that would be just more confusing? :-)
06:31:17 <djahandarie> More confusing, I think
06:31:36 <djahandarie> @type ala
06:31:37 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
06:32:00 <ion> @type Data.Traversable.foldMap
06:32:01 <lambdabot> Not in scope: `Data.Traversable.foldMap'
06:32:13 <ion> err
06:32:17 <djahandarie> @type Data.Foldable.foldMap
06:32:18 <ion> @type Data.Foldable.foldMap
06:32:19 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
06:32:19 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
06:33:42 <ion> @djinn (o -> n) -> (n' -> o') -> ((o -> n) -> b -> n') -> b -> o'
06:33:43 <lambdabot> f a b c d = b (c a d)
06:35:06 <djahandarie> @djinn (n' -> o') -> ((o -> n) -> b -> n') -> (o -> n) -> b -> o'
06:35:07 <lambdabot> f a b c d = a (b c d)
06:35:21 <identity_> what is neil mitchell's handle on here again?
06:35:41 <identity_> @seen ndm
06:35:41 <lambdabot> Unknown command, try @list
06:35:42 <preflex>  ndm was last seen on #haskell 210 days, 18 hours, 29 minutes and 35 seconds ago, saying: if you don't, then there was a parse error
06:36:59 <identity_> wasn't he one of those frequenters?
06:37:09 <ion> It’s always sad to see the Internet lose someone to a life.
06:37:39 <mokus> ion: we come back sometimes, i was idle on here for a year or 2
06:39:18 <identity_> at any rate, his implementation of tagsoup's getTagContent uses head and is thus unsafe or whatever it's called
06:39:24 <identity_> it's not documented that it uses it either
06:43:36 <ketil> identity_, ndm reads email, so it's not like he's gone all that far away...
06:44:06 <Botje> he's still blogging too
06:44:19 <ketil> identity_, and you need to email him anyway, since IRC isn't really useful for sending patches.
06:49:03 <mreh> does anyone work for streamtech here?
06:54:36 <TubeSteak> hi
06:56:25 <TubeSteak> I'm trying to build ghc 7.0.3 but I get "ld: rts/dist/build/RtsStartup.dyn_o: relocation R_X86_64_PC32 against symbol `StgRun' can not be used when making a shared object; recompile with -fPIC"
06:57:30 <aristid-uni> TubeSteak, os x?
06:57:52 <TubeSteak> I tried to upgrade to binutils 2.21 (in a private tree, not system wide) as I saw recommended in a mail thread, but I still get the same error :(
06:58:08 <TubeSteak> gcc is 4.1.2
06:58:41 <TubeSteak> does anybody have any idea how could I get this to compile?
06:58:53 <TubeSteak> without upgrading gcc
06:59:07 * hackagebot she 0.4 - A Haskell preprocessor adding miscellaneous features  http://hackage.haskell.org/package/she-0.4 (ConorMcBride)
06:59:29 <djahandarie> :O
07:00:44 <TubeSteak> aristid-uni:  no, RHEL 4 (sorry, I didn't see your message)
07:00:59 <aristid-uni> interesting.
07:01:25 <aristid-uni> TubeSteak, you're not using 32-bit libraries anywhere?
07:01:30 <identity_> what was the name of that relatively new concurrency paper?
07:01:33 <identity_> from may 2011 iirc
07:01:48 <identity_> got it
07:01:51 <aristid-uni> TubeSteak, but maybe your whole environment is simply too old
07:02:00 <TubeSteak> aristid-uni: in theory, I shouldn't
07:02:06 <TubeSteak> i know, but I can't upgrade it
07:02:15 <aristid-uni> TubeSteak, can you run a virtual machine?
07:02:24 <TubeSteak> not really
07:03:11 <TubeSteak> i need a very specific environment for other tools, and that's only working (or at least tested) with RHEL4
07:03:11 <saati> wasn't gcc 4.1 an awfully buggy minor version?
07:03:38 <TubeSteak> it doesn't work with 3.46 either
07:03:43 <TubeSteak> 3.4.6
07:03:56 <aristid-uni> TubeSteak, and running these tools and RHEL 4 in a virtual machine with a more modern host, and GHC in another virtual machine is not possible?
07:04:10 <erus`> how do i get values from an Either?
07:04:19 <alpounet> erus`, pattern matching
07:04:21 <sipa> by pattern matching on it
07:04:22 <aristid-uni> erus`, pattern matching is most easy
07:04:30 <erus`> (Either _ b) = a
07:04:35 <erus`> Either not found.
07:04:41 <erus`> i just imported it
07:04:43 <sipa> Either is the data type
07:04:47 <sipa> it is not a value
07:04:54 <aristid-uni> Left and Right are the constructors you need
07:04:54 <sipa> on the value level you use Left or Right
07:05:04 <erus`> @hoogle Right a -> a
07:05:05 <lambdabot> Did you mean: Either a a -> a /count=20
07:05:05 <TubeSteak> aristid-uni: no, I don't have permission anyway to do that kind of stuff (I would need to mount some NFS shares and register with clearcase)
07:05:06 <lambdabot> Prelude id :: a -> a
07:05:06 <lambdabot> Data.Function id :: a -> a
07:05:16 <aristid-uni> TubeSteak, well, sucks :P
07:05:17 <alpounet> > let { f (Left x) = "Left!" ; f (Right x) = "Right!" } in (f (Left 1), f (Right 1))
07:05:18 <lambdabot>   ("Left!","Right!")
07:05:26 <TubeSteak> aristid-uni: indeed :)
07:05:31 <TubeSteak> at least I have 6.12.3 working
07:05:49 <aristid-uni> TubeSteak, then just use that for the time being?
07:06:03 <TubeSteak> and maybe one day I can convince the powers that be to have a private machine to run haskell :)
07:06:05 <aristid-uni> TubeSteak, to be honest, i still use 6.12.1 :D
07:06:17 <TubeSteak> aristid-uni: yeah, that's what i'll do
07:06:25 <erus`> I need to pull the value OUT of the either
07:06:43 <aristid-uni> erus`, and that's what pattern matching does.
07:06:47 <alpounet> erus`, Either a b is a *type*. You can create values of that type with `Left <something>' or `Right <something>'. The same goes for "pattern matching". To get what's inside the Either a b, you pattern match just like i did a few lines above
07:06:55 <saati> TubeSteak: can't you make a modern enviroment in a chroot?
07:07:01 <TubeSteak> aristid-uni: at least I get to use Haskell at work and for work
07:07:21 <aristid-uni> TubeSteak, yeah i don't, so i guess you have the advantage there. but still. RHEL 4.
07:08:00 <erus`> ah my bad it was an IO Either
07:08:01 <TubeSteak> saati: that would be too complicated, my program works with 6.12, but it's faster on 7
07:08:17 <TubeSteak> so it's not that I really *need* 7, but it would be nice to have
07:08:26 <TubeSteak> and I thought somebody found a quick fix for it :)
07:08:43 <TubeSteak> since it's a known problem (listed on ghc troubleshooting page)
07:09:04 <aristid-uni> TubeSteak, why is it hard to get a dedicated machine tho?
07:09:08 <saati> with debian it's really not complicated, i haven't used rh in ages
07:09:41 <TubeSteak> aristid-uni: a dedicated machine with all the permissions (like NFS shares and clearcase client) yes
07:09:48 <TubeSteak> at least at this stage
07:10:13 <TubeSteak> if more things will depend on my program then probably i will convince the bosses to get me a machine
07:10:41 <aristid-uni> TubeSteak, what kind of firm do you work for, if i may ask?
07:11:00 <TubeSteak> networking devices
07:11:31 <TubeSteak> but what i wrote is a source code analyzer for C
07:11:48 <aristid-uni> ah, there haskell has a huge advantage of course
07:12:08 <TubeSteak> language.c is awesome
07:39:22 <sannysanoff> hello, my program does not compile ;-)
07:39:27 <sannysanoff> http://hpaste.org/49172
07:39:47 <sannysanoff> how should i rewrite that runction?
07:39:57 <quicksilver> you can't.
07:40:05 <quicksilver> the type inside an existential is unknown
07:40:19 <sannysanoff> how should I rewrite that program?
07:41:15 <aristid-uni> sannysanoff, make ResultExpr non-existential
07:41:15 <sannysanoff> I don't want to add a parameter to ResultExpr
07:41:26 <aristid-uni> well you don't really have a choice there
07:41:46 <quicksilver> sannysanoff: don't try to factor getExp out into a separate function.
07:41:58 <quicksilver> just do the case-expansion on ResultExpr in your main
07:42:09 <quicksilver> and then you will be able to check the JInt case and print the contents.
07:42:41 <quicksilver> your getExp is essentially meaningless.
07:43:07 <aristid-uni> quicksilver, pattern matching on existentials works? interesting
07:43:23 <quicksilver> well existentials wouldn't be very useful if you couldn't get inside them at all.
07:43:28 <zygoloid> sannysanoff: i've added an annotation to your paste
07:44:37 <sannysanoff> zygoloid, i already tried that, but you know, in reality functions are more useful (and bigger) to inline them like that. I will try to understand why my function is "meaningless"
07:45:52 <benmachine> sannysanoff: a type of ResultExpr -> Exp a says I can give it a ResultExpr and get an Exp Char
07:46:01 <benmachine> even though Exp Char doesn't exist
07:46:14 <benmachine> it's way too permissive
07:46:24 * sannysanoff is thinking hard
07:46:26 <quicksilver> sannysanoff: this type doesn't mean anything "getExp :: ResultExpr -> Exp a"
07:46:43 <quicksilver> sannysanoff: because it promises an Exp of some specific a, chosen by the caller.
07:46:56 <benmachine> it *does* mean something, just not something that's at all useful :P
07:46:58 <quicksilver> the best you can do is getExp :: ResultExpr -> (exists a. Exp a)
07:47:14 <quicksilver> ...but we don't have a real exists, so you'd need another data type to wrapit up
07:47:22 <quicksilver> which would look exactly like ResultExpr without the SomethignElse case.
07:47:52 <quicksilver> benmachine: sorry, poor communication - it doesn't mean anything in the context of his data type - there is no meaningful implementation given the data stored in a ResultExpr.
07:48:11 <benmachine> ah, yeah, that makes more sense
07:52:52 <sebz> is haskell expected to have first-class modules anytime soon?
07:52:53 <sannysanoff> quicksilver, thanks
07:55:32 <quicksilver> sebz: no.
07:59:11 <execat> Guys, I was going through this page: http://www.haskell.org/haskellwiki/Functional_programming
07:59:23 <execat> When the word "Closure" comes in. What is closure referring to?
07:59:44 <Twey> execat: A closure is a function bound up with the environment in which it was created
08:00:35 <KaffeeJunky123> I just tried to qsort a list of 10000 Ints and my haskell interpreter started to eat all my random access memory, is this normal behaviour of haskell?
08:00:36 <execat> Twey: Nice try, still blank. I was trying to get started with a functional language (Know Java, C++, C, but I don't think that'd help)
08:00:37 <Twey> E.G. f x = \y -> x + y; f x is a closure that binds the function ‘\y -> x + y’ up with the value of x from the scope above
08:00:50 <Twey> execat: Ever used anonymous classes in Java?
08:00:55 <execat> Yep
08:01:09 <Twey> execat: You know how you can access local variables in a local anonymous class?
08:01:17 <mauke> execat: it's a function that refers to outer local variables
08:01:22 <Twey> That's a closure
08:01:30 <Twey> (more or less)
08:01:35 <mauke> it is now
08:01:45 <execat> Ok.
08:02:00 <ion> kaffeejunky123: It’s the behavior of your code.
08:02:05 <execat> Oh right! Javascript added this feature sometime back, right?
08:02:13 <Twey> execat: Javascript has had it all along
08:02:24 <Twey> Most recent languages have
08:02:31 <Twey> C kind of does these days, too
08:02:36 <JuanDaugherty> KaffeeJunky123, you should pastebin your code.
08:02:39 <execat> Right! One of those moments when you go "I know this!"
08:02:45 <execat> Thanks Twey mauke
08:02:45 <illissius_> Twey: Blocks, you mean?
08:02:53 <_mpu> Twey: can you explain (about c) ?
08:02:58 <KaffeeJunky123> It's the demo qsort from haskell.org
08:02:58 <Twey> illissius_: http://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Nested-Functions.html#Nested-Functions
08:03:07 <Twey> (_mpu ↑)
08:03:30 <Twey> It's a gcc extension
08:03:32 <JuanDaugherty> KaffeeJunky123, but in general, yeah until you know how to write efficient code, that's a standard think in Haskell.
08:03:39 <JuanDaugherty> *thing
08:03:39 <mauke> KaffeeJunky123: 1) the interpreter isn't very efficient  2) that qsort implementation isn't very efficient
08:03:54 <mauke> so ... depends
08:04:05 <monadic> In general sorting a linked list will be worse than sorting a vector, iirc
08:04:15 <monadic> unless theres some good algorithm for it I don't know
08:04:32 <illissius_> Twey: ah, i see. there's also http://en.wikipedia.org/wiki/Blocks_(C_language_extension) .
08:04:40 <Athas> Can you recommend a good Haskell interface to Ncurses?
08:04:41 <lambdabot> Athas: You have 1 new message. '/msg lambdabot @messages' to read it.
08:05:54 <Twey> illissius_: That's confusing… ‘block’ already has a C definition >.<
08:06:07 <illissius_> yeah, i know.
08:07:32 <brianm> anyone know of a halfway mature ssh client library for haskell? Googling around has lead me to conclud that shelling out to ssh command line will be least painful :-(
08:07:41 <_KY_> Cabal complains "At least the following dependencies are missing: binary -any, pureMD5 -any, utf8-string -any"
08:07:47 <_KY_> What should I do?
08:07:55 <dcoutts> install them :-)
08:07:56 <mauke> install them?
08:08:17 <dcoutts> cabal install --dry-run --only-dependencies
08:08:24 <_KY_> Like "cabal install binary" ?
08:08:54 <dcoutts> or just cabal install --dry-run on its own (will install the thing in the current dir too)
08:09:41 <_KY_> Returned 10 dependencies
08:10:33 <_KY_> Can I install them elsewhere?
08:11:43 <monochrom> "install the thing in the current dir" = "install (the thing in the current dir)" /= "(install the thing) in the current dir"
08:13:18 <dankna> lol
08:13:23 <dankna> yes, monochrom
08:13:55 <_KY_> lol
08:14:02 <_KY_> Done, thanks=)
08:14:26 <monochrom> and someone last night dared to refute me with "you speak as though people haven't reached a consensus on english"
08:14:39 <dcoutts> heh heh
08:14:48 <monochrom> that's right, people haven't reached a consensus on english, see the above example
08:15:07 <monochrom> s/english/english semantics/
08:15:57 <sfvisser> Hi all, I'm trying to install the binary version ghc-7.0.4 on ubuntu. This doesn't work because the ghc-pwd (and ghc-stage2) is linked to a non-existing libgmp3.so.
08:16:02 <sfvisser> Any idea how to fix this?
08:16:24 <JuanDaugherty> dared to refute me
08:16:27 <derdon> is there a public repo for the content of learnyouahaskell.com?
08:16:56 <Saizan> sfvisser: apt-get install libgmp3-dev
08:17:06 <illissius_> what's the necessary/sufficient condition for something being safe to unsafeDupablePerformIO? is the operation being idempotent (e.g. write a given value to a given place in memory) either of them? (I know multiple cpu cores might both end up executing it, but not whether both are guaranteed to finish before the unsafeDupablePerformIO is considered evaluated.. if the second one ends up performing the write later in the middle of
08:17:07 <illissius_> something different, that might be unpleasant.)
08:17:33 <sfvisser> Saizan: already did that, doesn't seem to do the trick
08:18:03 <quicksilver> illissius_: that unpleasant thing might happen, AIUI
08:18:16 <quicksilver> illissius_: it must genuinely not matter when it happens - even if it happens twice.
08:20:09 <JuanDaugherty> monochrom, a lay person would likely confound the efficacy of natural languages with a scientific understanding of same such as could be rendered in a machine
08:20:39 <illissius_> quicksilver: hm. ok. thanks.
08:20:47 <JuanDaugherty> for "lay" read, not knowledgeable about nlp/nl understanding
08:20:49 <quicksilver> illissius_: I could be wrong :) but that's my understanding.
08:21:02 <JuanDaugherty> or linguistics generally
08:21:16 <monochrom> no machine or nlp is involved in the above example. only a few humans
08:21:43 <illissius_> it's also logical, when thinking about it - if you unsafeDup something which returns a value, it can't return more than one, so presumably it's going to return the first one which completes, and the second one just keeps running somewhere off in the distance
08:22:51 <sfvisser> Saizan: this worked: sudo apt-get install libgmp3c2
08:22:52 <sfvisser> thanks
08:23:51 <monochrom> that's strange, libgmp3-dev depends on libgmp3c2 already.
08:23:58 <albertid> did anyone succesfully install "reactive" with cabal/ghc-7.0.3 ? I fail to compile category-extras-0.53.5 and checkers-0.2.8 which are requirements.
08:24:35 <JuanDaugherty> well a complication in a venue like this is that many/most are not native speakers of English
08:24:36 <Saizan> category-extras is not maintained anymore
08:26:55 <albertid> Saizan, so what to do?
08:29:20 <felher> g /go weechat
08:30:28 <albertid> ah I see that hackage says build failure for ghc-7.0. So reactive is not supported on ghc-7.0
08:30:35 <albertid> maybe I should check the darcs version
08:30:48 <albertid> maybe I should stop speaking out loud
08:45:25 * hackagebot majority 1.0 - Boyer-Moore Majority Vote Algorithm  http://hackage.haskell.org/package/majority-1.0 (NisWegmann)
08:48:26 * hackagebot majority 1.1 - Boyer-Moore Majority Vote Algorithm  http://hackage.haskell.org/package/majority-1.1 (NisWegmann)
08:56:30 <linduxed> what's the equivalent of drop but going from the back?  basically reverse (drop (reverse "foobar") 4)
08:57:01 <kmc> that's it
08:57:28 <linduxed> kmc: there's no easier command?
08:57:43 <Saizan> > let xs = "foobar" in zipWith const xs (drop 4 xs)
08:57:44 <lambdabot>   "fo"
08:58:03 <Saizan> but that's lazier, not easier :)
08:58:04 <kmc> linduxed, maybe, but the basic problem is that lists are really only meant to be accessed from the left side
08:58:18 <kmc> they are basically singly-linked lists
08:58:21 <linduxed> kmc: oh i see
08:58:31 <kmc> so dropping from the beginning just involves getting a pointer to a middle node
08:58:38 <kmc> but dropping from the end involves copying all the nodes
08:58:40 <linduxed> but what i wrote isn't bad code is it? i'm not doing some newbie mistake?
08:59:13 <kmc> the newbie mistake if any is using lists at all
08:59:22 <kmc> for tasks that need bidirectional / random access
08:59:38 <kmc> what problem are you solving?
08:59:46 <benmachine> the Seq type in Data.Sequence is nice
09:00:50 <linduxed> kmc: i've got a string, i want to remove the last four characters from it
09:00:56 <linduxed> kmc:  that's all
09:01:48 <kmc> ok
09:01:51 <kmc> maybe use Data.Text
09:02:23 <kmc> it's a space-efficient type for text
09:03:09 <Cale> linduxed: Sure, you can reverse . drop 4 . reverse if it's just a short string.
09:03:26 <Cale> linduxed: Most of the comments seem to be related to the efficiency of this (it's not efficient at all)
09:03:35 <Cale> linduxed: but it works
09:05:05 <Cale> It'd probably be premature optimisation to do anything too much fancier
09:05:18 <Cale> The lazier version is nice in the case that it might be an infinite string.
09:05:37 <Cale> (or if you want to use it lazily)
09:06:32 * hackagebot representable-tries 1.8.1 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-1.8.1 (EdwardKmett)
09:07:06 <parcs> that lazy version is awesome
09:08:35 <parcs> > let xs = [1..] in zipWith const xs (drop 4 xs)
09:08:36 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
09:08:43 <kmc> yeah, i guess Text does not have fast end-slicing either?
09:09:46 <copumpkin> you can also write reverse . take 4 . reverse efficiently
09:09:53 <copumpkin> but it takes more work
09:09:58 <edwardk> kmc: nope
09:10:28 <Cale> It does have lots of other operations at the end of a string, but not drop
09:11:20 <parcs> @src Num
09:11:21 <lambdabot> class  (Eq a, Show a) => Num a  where
09:11:21 <lambdabot>     (+), (-), (*)           :: a -> a -> a
09:11:21 <lambdabot>     negate, abs, signum     :: a -> a
09:11:21 <lambdabot>     fromInteger             :: Integer -> a
09:14:13 <Cadynum> is there any easy and safe way to open an url in the default browser on windows? the "start" command could be used but that also creates a cmd window which i'd like to avoid.
09:15:44 <kmc> Cadynum, this is probably not the best place to ask
09:15:46 <kmc> try ##windows
09:16:23 <Cadynum> kmc, i was hoping for some pre-made haskell code involving looking up the registry or something like that
09:16:42 <silver> http://www.mail-archive.com/haskell-cafe@haskell.org/msg83031.html
09:16:44 <silver> look here
09:17:50 <silver> @hoogle appInfoLaunchUris
09:17:50 <lambdabot> No results found
09:17:56 <silver> ;/
09:18:25 <Cadynum> i've found that post too but the functions are missing from the gio or gtk library
09:24:01 <benmachine> missing?
09:33:39 <Cadynum> sorry, my mistake. i looked at the outdated documentation at gtk2hs website
09:40:36 * hackagebot hakyll 3.2.0.4 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.2.0.4 (JasperVanDerJeugt)
09:44:22 <edwardk> preflex: xseen ddarius
09:44:23 <preflex>  ddarius was last seen on freenode/#haskell 4 days, 11 hours, 40 minutes and 30 seconds ago, saying: @free beer
09:44:40 <djahandarie> And he was killed by lambdabot shortly afterwards
09:45:47 <edwardk> doh
09:50:39 * hackagebot algebra 0.5.0 - Constructive abstract algebra  http://hackage.haskell.org/package/algebra-0.5.0 (EdwardKmett)
09:51:06 <edwardk> now with my first stab at geometric coalgebra
09:51:21 <acfoltzer> is there a straightforward way to make the System.Process tools emulate the bash 2>&1 redirect?
09:51:26 <augur> edwardk: theres someone in here called codensity :(
09:51:34 <acfoltzer> basically I want to spawn a process and read stdout and stderr from a single handle
09:52:48 <edwardk> =)
09:53:09 <edwardk> now to see how long until coalgebra joins the channel
09:53:56 <augur> edwardk: im ok with co-- OH SHIT KAN EXTENSIONS
09:55:05 * anafunctor stares menacingly at augur 
09:55:17 <augur> no obviously im kidding
09:55:19 <augur> i dont understand coalgebras at all
09:55:19 * monomorphism restricts your polymorphism!
09:55:22 <augur> no no i do. they- AGH
09:55:30 <augur> this is great, its like ive got magical powers to make people in raving CT lunatics
09:55:31 * dimorphism restricts your polymorphism slightly less!
09:55:43 <augur> AWAKE, MY ARMY OF CT NUTTERS
09:55:52 <dimorphism> WHAT IS YOUR BIDDING MY MASTER?
09:56:03 * benmachine enables the MonochromRestriction
09:56:39 <gwern> CT nutters, able to chase diagrams at .1c and beyond!
10:00:14 <edwardk> i don't want to chase diagrams. i want to catch them
10:00:49 * gwern is like a dog chasing diagrams, he wouldn't know what to do with them if he caught them. he just wants to watch the world burn
10:04:04 * codensity is still studying codensity
10:05:42 <Cale> edwardk: Gotta catch 'em all! Pokemonad!
10:06:04 <ion> Pokemonad :-D
10:07:00 <ion> Mi inna Jamaica, monad
10:07:22 * applicative has finally find a use for @p1
10:07:30 <ion> cinnamonad rolls
10:07:55 <ion> The Mormonad faith
10:08:00 <applicative> namely getting things with signatures like (<<*>>):: (forall x. ((a -> b) -> x) -> x) -> (forall x. (a -> x) -> x) -> (forall x. (b -> x) -> x) past the ghc's scrutiny
10:08:11 <ion> Ramonad noodles
10:08:53 <applicative> @pl \a2b2x2x a2x2x -> ($ (a2b2x2x a2x2x))
10:08:54 <lambdabot> (flip id .)
10:09:26 <applicative> ^^^ no one's gonna tell me about bound skolemized whatnot with (flip id .)
10:11:01 <ion> A game of Backgammonad, anyone? It’s a rather uncommonad game. Do you like lemonad with salmonad? The Mormonad minister held a nice sermonad. (Ok, will stop now. :-P)
10:11:12 <clsmith> Cale: heh, the only result on google for "+pokemonad monad" is the #haskell 2010/03/09 logs, where that exact pun was made
10:11:16 <djahandarie> It's interesting that ala is more or less just a reordering of (.) . (.)
10:11:30 <clsmith> 16 (?) months later, we're back to where we began
10:12:01 <djahandarie> (With pack/unpack thrown in of course)
10:12:07 <sm> morning all
10:12:50 <applicative>  sm, dont tell me its already morning in France.
10:13:12 <djahandarie> I'm pretty sure it's like 7:22pm
10:13:12 <sm> applicative: no, don't worry
10:13:28 <sm> just a little local flavour from california timezone
10:13:36 <applicative> you can see why I have trouble with continuations...
10:14:07 <clsmith> ion: http://sprunge.us/fYZL for your enjoyment
10:14:25 <ion> clsmith: Hah
10:14:45 <bos> noddy: you called?
10:14:58 <applicative> is there any use for a sort of Cont monad that is higher rankish like data Cont a = Conty (forall r . (a -> r) -> r) or is it immediately trivial
10:15:36 <earthy> evening all :P
10:15:55 <applicative> earthy dont tell me its evening on earth already
10:16:32 * earthy laughs
10:16:42 <earthy> it's bound to be evening on earth somewhere ;)
10:16:57 <applicative> you can see why I have trouble with continuations
10:17:17 <earthy> hardly
10:18:01 <applicative> it seems plain that  (forall r . (a -> r) -> r) has to be isomorphic to a, so there are no new values, etc.
10:18:08 * earthy nods
10:18:15 <earthy> that's why cont has a fixed r
10:19:36 <applicative> yeah, but I was reasoning about 'Codensity f a = Codensity (forall r . (a -> f r) -> f r
10:20:31 <earthy> the usecase being?
10:21:07 <applicative> though now that I think about it, the argument of edwardk that it's bigger than a turned on fixing an r or rather z using Reader z for the functor or whatever
10:21:23 <sm> I have a nagging issue with option handling in hledger, wondering if anyone has a good solution. Report functions in the core library use various flags to affect searching, sorting, etc. These correspond to some of the command-line tool's options, but I don't want to put all the cli-specific options in the core library. It seems getopts or cmdargs need all the options defined in one place. So I think I'll need to translate between CliOptions and CoreOptions or
10:21:23 <djahandarie> Are there any programming languages that actually use classical logic, like Girard's System LC?
10:21:23 <sm> something... ?
10:21:25 <applicative> oh Codensity comes up as an optimization
10:21:33 <djahandarie> Arg. 2 questions at once. :(
10:22:16 <applicative> earthy: I saw it in 'the Kleisli arrows of outrageous fortune', mentioning 'factorizing folds for faster functions' mentioning a certain Voigtlander
10:23:00 <applicative> earthy, it turned out edwardk had already moved on, it seems: http://comonad.com/reader/2011/free-monads-for-less/ and the following posts
10:24:52 <sm> djahandarie: we cancelled out :(
10:25:09 * earthy reading
10:25:16 <djahandarie> :(
10:27:14 <noddy> bos: i wrote some code for RFC3339 timestamp parsing for some web services i made that i thought would best fit straight in aeson, since it has FromJSON instances for UTCTime and .NET time.
10:27:59 <noddy> bos: but i can wrap it up in a patch and submit a pull req on github. i'll comment there.
10:28:23 <bos> noddy: is there some json provider that uses rfc3339 dates?
10:28:36 <applicative> sm you are trying to rewrite using 'cmdargs'?
10:28:38 <noddy> bos: a certain "google"
10:28:41 <bos> a
10:28:42 <noddy> bos: :)
10:28:43 <bos> ah
10:28:52 <bos> noddy: cool
10:29:11 <sm> applicative: not yet, I plan to sooner or later.
10:30:00 <noddy> bos: it's really a yyyy-mm-ddThh:mm:ss.sss[+/-tzoff|Z], parsed into ZonedTime. i liked how it fit together infomation-wise, so i thought it could be included into the big lib itself.
10:30:12 <earthy> hm. interesting.
10:31:22 <bos> noddy: i'd be up for that, i think.
10:31:54 * hackagebot http-enumerator 0.6.5.6 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.6.5.6 (MichaelSnoyman)
10:32:41 <applicative> i should figure out hledger.  But hey, I'd need an Iphone app...
10:33:08 <sm> applicative: I need one too
10:33:47 <sm> I have xPenseIt (money) and Eternity (time)... need to import those to hledger format
10:34:06 <sm> as a first step
10:34:40 <applicative> oh, those are already existing 'apps' that you make notes in.
10:35:07 <sm> yeah, they are existing expense tracking and time tracking apps
10:35:14 <sm> Eternity is quite good
10:36:37 <applicative> Are you thinking of trying to port something like them to your format, or just get their format parsed into yours and vice versa
10:38:45 <applicative> Oh i see, eternity is presumably a very complicated bit of objective c.
10:39:38 <sm> applicative: the latter, in some adhoc way, would be first. Eg, Eternity has a backup mode, where it runs a temporary http server. I have a curl script which grabs the data (an sqlite db). I could use HDBC or something to dump the entries to hledger journal file format - should be easy
10:40:27 <sm> slightly harder but nicer would be to write a new hledger storage backend using the persistent lib to read the sqlite db directly
10:41:32 <applicative> i see.  does the eternity app interact with your bank?
10:41:41 <applicative> i mean the other one
10:41:46 <edwardk> Cale: have you ever seen anything on division coassociative coalgebras?
10:41:55 <sm> down the road someone might write a custom app that's more integrated
10:41:58 <edwardk> cale; i'm unable to dig up anything on the internets
10:42:05 <tommd> preflex: seen tibbe
10:42:06 <preflex>  tibbe was last seen on #ghc 47 minutes and 38 seconds ago, saying: anyone going to camhac and taking the train from heathrow?
10:42:21 <sm> applicative: no, I think no iphone apps do except for each bank's specific one
10:42:29 <ion> Co- in cocategory cotheory is like tri- in Tristar Tritrek.
10:42:34 <Cale> edwardk: Nope
10:42:49 <edwardk> division coalgebras could be codivision coalgebras, or invertible coalgebras or something, but, basically i need a recipriocal that is compatible with comultiplication
10:42:56 <tommd> @tell tibbe You want a strict version of unionWith (great!), so I assume I should move the current unionWith from HashMap/Common.hs to HashMap/Lazy.hs also.  Correct?
10:42:56 <lambdabot> Consider it noted.
10:43:33 <tommd> @tell lambdabot It is so considered
10:43:33 <lambdabot> Nice try ;)
10:44:23 <tibbe> tommd: check what I did for e.g. map (which has both a strict and lazy version)
10:44:23 <lambdabot> tibbe: You have 1 new message. '/msg lambdabot @messages' to read it.
10:44:28 <sm> applicative: using mint.com to extract bank data, and fetching their csv, is another approach
10:44:45 <applicative> sm: I see
10:44:56 * hackagebot heist 0.5.2.1 - An xhtml templating system  http://hackage.haskell.org/package/heist-0.5.2.1 (DougBeardsley)
10:45:45 <applicative> sm: but maybe some simple html+javascript "app" could load some sensible static html representation of hledger's data, and collect entries as they arise, then somehow you load the info into hledger and upadate every few days?
10:47:02 <sm> applicative: you lost me there..are you talking about scraping bank data from their web interface ?
10:50:32 <Cale> edwardk: Um, so, how is this different from a Hopf algebra, actually? What law does the inverse have to satisfy?
10:50:45 <Cale> (or a bialgebra)
10:51:20 <edwardk> its not a hopf algebra, because i don't necessarily also have algebra to get a full bialgebra
10:51:48 <edwardk> i have hopf algebras in the library now
10:51:54 <Cale> Doesn't the diagram for the antipode normally involve both multiplcition and comultiplication though?
10:52:01 <applicative> sm, no, I was just thinking about how you could use your handheld to collect data for hledger and to view it, with periodic 'synch'ing or something
10:52:12 <DukeDave> Hi there has anyone in here experience with graphs (as in graph theory) in Haskell?
10:52:13 <edwardk> yes, but antipode is a hopf algebra concept
10:52:20 <Cale> Yeah, or inverse
10:52:27 <Cale> antipode = inverse :)
10:52:28 <edwardk> here i just have a comultiplication and i need a corecipriocal that is compatible
10:52:37 <Cale> In what way though?
10:53:18 <anti-anti-helix> brandonw, you.
10:53:19 <Cale> I'm having trouble writing down the diagram for what the coreciprocal should satisfy without using a multiplication somewhere
10:53:23 <anti-anti-helix> What are you doing here?
10:53:24 <edwardk> ideally so that when i'm working with, say coalgebras of the group ring, that division works out for the covectors =)
10:53:32 <anti-anti-helix> At last, we meet again.
10:53:45 <anti-anti-helix> The mighty brandonw, back from the death
10:53:57 <anti-anti-helix> Your deeds at Altrazath were worthy of song, my old friend.
10:54:06 <Philonous> Is there a canonical method to parse time according to RFC 822?
10:54:07 <anti-anti-helix> Or wait, that's probably 'dead'
10:54:19 <edwardk> https://github.com/ekmett/algebra/blob/master/Numeric/Covector.hs gives me multiplication of covectors using coalgebras
10:54:36 <edwardk> i want division of covectors
10:54:57 <zzo38> Do they exist Knuth-style literate Haskell?
10:55:24 <applicative> DukeDave, what do you want to do with graphs?
10:56:09 <clsmith> zzo38: http://www.haskell.org/haskellwiki/Literate_programming ?
10:56:19 <Philonous> edwardk:  Is Covector = Cont?
10:56:19 <sm> applicative: oh. Indeed that would be handy. If you have an accessible hledger-web instance, you could use that and give it a better mobile ui (http://demo.hledger.org:5001)
10:56:33 <edwardk> philonous: its very close
10:56:40 <edwardk> philonous: it is subject to a linearity constraint
10:56:55 <clsmith> so what's the reason behind ($) being a dollar sign? :p
10:57:16 <edwardk> you need f $* (x .* a + b) = x * (f $* a) + f ($* b)
10:57:26 <DukeDave> applicative: Well I have been using Data.Graph.Wrapper and run in to a problem
10:57:34 <sm> but periodic syncing sounds better. Oops better go, see you
10:57:39 <edwardk> Philonous: that happens to rule out using callCC for instance
10:58:00 <edwardk> Philonous: but anything you can write with Cont that is oblivious to the choice of r is correct
10:58:49 <Cale> edwardk: Normally when you write down the law for what an inverse for multiplication does, you need a comultiplication so that you can do something like A -> A (x) A and then apply the inverse to one side or the other before multiplying
10:59:07 <DukeDave> applicative: Bare with me, just constructing an example :)
10:59:22 <monochrom> I think $ was chosen because other symbols were all taken
10:59:30 <Cale> edwardk: (even if that comultiplication is just the diagonal map induced by the categorical product)
10:59:42 <edwardk> cale: hrmm
11:00:02 <edwardk> cale: well, i'm willing to accept the diagonal map, since that can be implemented trivially in a functional setting
11:00:17 <zzo38> clsmith: No. I mean Knuth-style, it is a bit different.
11:00:19 <Cale> and so when you turn this all around, you'll need a multiplication of some type to be able to say what an inverse for the comultiplication is
11:00:35 <Cale> (or coinverse, whatever)
11:01:49 <edwardk> do you see where the multiplication drops out for covectors in that code?
11:02:36 <parcs> $ looks like S and the S combinator does function application
11:03:02 <applicative> zzo38:  what are you thinking of as the important difference between Knuth literate programming and the things possible with lhs lhs2tex etc
11:03:58 <edwardk> cale: perhaps the best example of why i prefer working with coalgebras is seen in https://github.com/ekmett/algebra/blob/master/Numeric/Algebra/Class.hs if you look at the implementation for Algebra r [a] and for Coalgebra r [a]
11:04:01 <clsmith> parcs: no it doesn't... S is ap:
11:04:03 <clsmith> :t ap
11:04:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
11:04:07 <zzo38> applicative: Table of contents, index, pretty printing, named chunks that can be included inside of others, etc. (I also like to use Plain TeX format rather than LaTeX, although this is a matter of preference)
11:04:09 <edwardk> the coalgebra is much nicer to work with
11:04:40 <parcs> @src (->) ap
11:04:41 <lambdabot> Source not found. Where did you learn to type?
11:05:16 <zzo38> (I also prefer to use DVI as the output format rather than PDF, although this is also a matter of preference.)
11:06:22 <clsmith> anyway, the S combinator is (Sxyz => xz(yz)). $ is just (x$y => xy), purely a precedence operator
11:06:31 <applicative> zzo38: Oh, I see, I was thinking that by 'knuth style' you meant something more about the form of the file itself, not the presentation
11:06:38 <Cale> edwardk: It feels like that multiplication should be nicely writable in terms of a fold over tails?
11:06:54 <Cale> (maybe I just haven't read it carefully enough...)
11:07:01 <edwardk> possibly
11:07:07 <edwardk> remember i need the heads as well
11:07:33 <parcs> clsmith: S is the only combinator that does application
11:07:43 <Cale> oh, I see... so you're splitting up the list in all possible ways, and summing over f applied to the splits?
11:07:46 <edwardk> basically its splitting [x,y,z] into ([],[x,y,z])   ([x],[y,z])  ([x,y],[z]) and ([x,y,z],[])
11:07:49 <edwardk> yeah
11:07:50 <applicative> well <$> is, or can be the S combinator.
11:07:51 <zzo38> applicative: Well, it is mostly the presentation. Although partly about the things the file format itself supports (but not necessarily its exact format)
11:08:10 <edwardk> that yields the tensor algebra of the free module with basis a
11:08:31 <edwardk> but the tensor coalgebra is much nicer to work with =)
11:09:36 <copumpkin> f :: ([a] -> Bool) -> [a] -> Maybe ([a], [a])
11:09:56 <copumpkin> guess what it does!
11:10:20 <Chewie[]> kmc: remember the partition algo question yesterday?
11:10:48 <Chewie[]> kmc: bisect (x:xs) = nub $ concat [ [(x:a, b), (x:b, a)] | (a, b) <- bisect xs ]
11:11:02 <Cale> copumpkin: Find a partition where the first part satisfies the given predicate?
11:11:09 <copumpkin> Cale: and the second does not!
11:11:13 <zzo38> Do you know of such things exists?
11:11:17 <applicative> like Cale said. oh
11:11:57 <clsmith> parcs: what about B, aka (.) ?
11:12:08 <Chewie[]> kmc: added call to nub, and reversed the order on the second pair generated (i.e. (x:b, a) instead of (a, x:b))
11:12:27 <applicative> so Just xs ys is the first p chunk, paired with the following non p chunk ?
11:13:05 <Eduard_Munteanu> Yeah, that explains the Maybe.
11:13:20 <Eduard_Munteanu> (otherwise it could've been ([a], [a]))
11:13:43 <applicative> copumpkin: Oh wait, in the Just xs ys , xs ++ ys is the original list, it fails if it doesn't divide properly
11:14:02 <applicative> or rather it nothings.
11:14:13 <edwardk> cale: another example is when working with the polynomial basis, the coalgebra is really easy for me to define but the algebra requires me to insert non-negativity constraints
11:14:37 <edwardk> with the coalgebra is can use finite lorentz series, work with fractional powers, etc.
11:14:46 <edwardk> er finitely negative
11:15:06 <parcs> clsmith: is there an operator that looks like a B? :P
11:15:17 <copumpkin> preflex: seen micahjohnston
11:15:18 <preflex>  micahjohnston was last seen on #haskell 5 days, 1 hour, 22 minutes and 6 seconds ago, saying: doesn't ArrowApply kind of take away the point of arrows?
11:15:58 <clsmith> parcs: &. if you squint. :)
11:17:56 <monochrom> & looks like et
11:18:05 <Cale> edwardk: Yeah, coalgebras are usually so natural to define that they're classically not even studied, which is kinda sad.
11:18:21 <clsmith> monochrom: psh, hardly, anymore
11:18:39 <clsmith> unless you're using a very fancy font...
11:18:48 <Cale> (the trivial ones sort of overshadow the less trivial ones)
11:19:10 <edwardk> but you can see how here, i have lots of places where it'd be really nice to have a division-like operator i can use on covectors, even when the algebra is awful and undefined
11:19:19 <clsmith> hmm, where can i find out exactly what is meant by the type 'a b' (or 'a b c')? i got it with monads, but now i'm reading about arrows it's sort of blending my brain
11:19:27 <edwardk> for instance i have a coalgebra for geometric products, but i'm not willing to write the algebra that goes with it ;)
11:19:38 <copumpkin> clsmith: it's just the type constructor `a` applied to `b`
11:19:40 <Cale> clsmith: 'a' is the new 'm'
11:19:48 <Cale> and instead of one type parameter, it has two
11:19:54 <edwardk> https://github.com/ekmett/algebra/blob/master/Numeric/Algebra/Geometric.hs
11:19:58 <clsmith> so just kinda like composite types?
11:20:00 <copumpkin> clsmith: if you use (~>) instead of `a` it makes a lot more sense
11:20:01 <Cale> It may help to replace each 'a' with infix '~>'
11:20:05 <edwardk> lets me program with geometric algebra in the dual space
11:20:12 <Cale> So that (a b c) becomes (b ~> c)
11:20:14 <copumpkin> clsmith: you know (->) on the type level is actually a type constructor that takes two types?
11:20:35 <edwardk> the nice part is that i don't need to fix a pseudo-scalar, and it doesn't matter that i have an infinite dimensional space, as long as i only inspect a finite cross-section with any covector
11:20:38 <clsmith> copumpkin: i did not know that.
11:20:53 <copumpkin> clsmith: a function Int -> Int can be written as (->) Int Int
11:21:03 <Eduard_Munteanu> :t (>>>)
11:21:04 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
11:21:38 <Eduard_Munteanu> For cat = (->), that's flip (.)
11:21:42 <edwardk> and with that in 200 lines i can do contractions, geometric, outer, hestenes products, etc. over an arbitrary eigenbasis
11:21:45 <Cale> edwardk: I guess you can just make a class with the right type, but it's hard to say what properties the thing should have, no?
11:21:52 <edwardk> yeah
11:22:00 <Cale> edwardk: Maybe if you can identify some axioms from the setup that you have...
11:22:49 <edwardk> the bottom of https://github.com/ekmett/algebra/blob/master/Numeric/Algebra/Division.hs is all i have so far
11:23:20 <DukeDave> How do I lift a monadic action to a tuple, e.g:   (a, m b) -> m (a, b)
11:23:39 <clsmith> oh the ~> thing is really helping. now i can see (>>>) :: (a ~> b) -> (b ~> c) -> (a ~> c). thanks guys
11:24:05 <sipa> liftTup (a,m) = do { b <- m; return (a,b) }
11:24:12 <sipa> like that?
11:24:59 <sipa> @pl \(a,m) -> m >>= (\b -> return (a,b))
11:25:00 <lambdabot> uncurry (fmap . (,))
11:25:16 <sipa> :t uncurry (fmap . (,))
11:25:18 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a1, f a) -> f (a1, a)
11:25:31 <DukeDave> sipa: Nice :)
11:25:56 <DukeDave> sipa++
11:26:08 <copumpkin> it's called strength
11:26:10 <edwardk> cale: any ideas what those laws would be? =)
11:26:11 <copumpkin> usually
11:26:26 <copumpkin> I use it all the time when working with Map
11:26:38 <Eduard_Munteanu> The same thing called strength for monads?
11:26:48 <edwardk> Eduard_Munteanu: yep
11:26:55 <copumpkin> except you only need functors here
11:26:59 <edwardk> Eduard_Munteanu: every functor is strong in this sense in haskell
11:27:22 <edwardk> http://comonad.com/reader/2008/deriving-strength-from-laziness/
11:27:30 <Eduard_Munteanu> Oh, thanks.
11:27:47 <Nibble> what is an identity
11:29:27 <c_wraith> You'll have to provide a bit more context than that.
11:29:42 <Nibble> hold on
11:30:46 <sipa> an explicit representation of not doing enything
11:31:31 <Eduard_Munteanu> edwardk: would there be a name for the other one, A x M B -> M (A x B)? I'm getting a feeling this is related to a coproductish injection somehow.
11:31:35 <Nibble> I was listening to this talk
11:31:44 <Eduard_Munteanu> Or it's not so interesting which one we actually use?
11:31:46 <Nibble> turns out it was about theorem provers
11:32:13 <Nibble> What's an isomorphism?
11:32:16 <Eduard_Munteanu> Nibble: an identity arrow? Perhaps a mathematical identity?
11:33:03 <copumpkin> Eduard_Munteanu: "the other one?"
11:33:15 <copumpkin> that's strength
11:33:25 <copumpkin> you mean M (A x B) -> A x M B ?
11:33:37 <copumpkin> you can't write that one
11:33:50 <copumpkin> there's costrength, but that involves eithers
11:33:51 <Eduard_Munteanu> copumpkin: no, edwardk used M A x B -> M (A x B) in his article
11:33:54 <c_wraith> an isomorphism is a relationship between two structures that preserves whatever property you care about
11:34:06 <copumpkin> Eduard_Munteanu: A x B is isomorphic to B x A
11:34:24 <Eduard_Munteanu> Yeah, sure, I thought there was some duality going on in there.
11:34:34 <Philonous> Nibble: An isomorphism is a function that's both injective and surjective. Put differently, it's a one-to-one corespondence. Usually it also preserves some structure.
11:34:54 <Nibble> what's injective and surjective?
11:34:57 <copumpkin> :t let f (x, y) = fmap (,y) x in f
11:34:58 <lambdabot> Illegal tuple section: use -XTupleSections
11:35:14 <Eduard_Munteanu> Nibble: depending on the context, you might want to see http://en.wikipedia.org/wiki/Isomorphism
11:35:18 <copumpkin> :t let f (x, y) = fmap (\q -> (q,y)) x in f
11:35:20 <lambdabot> forall (f :: * -> *) a t. (Functor f) => (f a, t) -> f (a, t)
11:35:29 <copumpkin> :t let f (x, y) = fmap (\q -> (x,q)) y in f
11:35:30 <lambdabot> forall t (f :: * -> *) a. (Functor f) => (t, f a) -> f (t, a)
11:35:38 <Chewie[]> i need a "zipMaybe" function that throws out pairs if any source list is Nothing.
11:35:58 <copumpkin> Chewie[]: give us a type
11:36:24 <Nibble> oh
11:36:28 <Eduard_Munteanu> Nibble: as in injective/surjective functions.
11:36:37 <copumpkin> :t liftA2 zip
11:36:38 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f [a] -> f [b] -> f [(a, b)]
11:36:44 <Nibble> so like, give it something and it returns something, but you can also do it the other way around?
11:36:49 <copumpkin> :t liftA2 zip :: Maybe [a] -> Maybe [b] -> Maybe [(a,b)]
11:36:50 <lambdabot> forall a b. Maybe [a] -> Maybe [b] -> Maybe [(a, b)]
11:37:18 <Eduard_Munteanu> injective ~ maps different values to different values
11:37:25 <copumpkin> :t ((join . maybeToList) .) . liftA2 zip
11:37:26 <lambdabot> forall a b. Maybe [a] -> Maybe [b] -> [(a, b)]
11:37:31 <Eduard_Munteanu> surjective ~ covers its whole codomain
11:38:37 <Philonous> Nibble:  A function f from A to B is injective when for all a and b in A we have f a = f b if and only if a = b. It is surjective if for all b in B we there is an a in A so that f a = b. In other words it is injective if it maps different elements to different elements, and it is surjective if it reaches all the element in it's Image
11:38:50 <Eduard_Munteanu> Nibble: yes, bijective (injective + surjective) functions are invertible
11:39:00 <Eduard_Munteanu> In fact they're equivalent notions there.
11:39:13 <Nibble> Eduard_Munteanu, ah, that must have been what the guy was trying to say
11:39:17 <applicative> > let chewie = ((join . maybeToList) .) . liftA2 zip  in chewie (Just "hi") (Just [1,2])
11:39:19 <lambdabot>   [('h',1),('i',2)]
11:39:21 <Chewie[]> i have avoided the need i think.
11:39:23 <Nibble> who knows, the one who held that talk might even be in this channel
11:39:27 <applicative> > let chewie = ((join . maybeToList) .) . liftA2 zip  in chewie (Just "hi") Nothing
11:39:29 <lambdabot>   []
11:40:20 <Eduard_Munteanu> copumpkin: oh ok, I thought there might've been different names depending on which one you used, like some inj\_1 and inj\_2
11:40:28 <copumpkin> I don't think so
11:41:04 <Nibble> Philippa, I see
11:41:39 <Nibble> Philonous, *
11:43:34 <Chewie[]> applicative: thanks anyways
11:46:15 <zzing> What is the latest news on using the llvm backend? The stuff I am finding is really old for news.
11:47:27 <Nibble> zzing, isn't it enabled by default now?
11:50:01 <thoughtpolice> Nibble: it's not the default, but it's there by default (nothing special needed to enable it, but to use it you need llvm installed)
11:50:21 <thoughtpolice> the regular native code generator is still the default for all major platforms
12:08:16 <dainanaki> I was advised last night after manually piecing together a haskell shared library that exports some C functions that cabal might be able to do it more easily for me, but I'm not sure what to put in the cabal file to get it to produce a dynamic library for usage with a non-haskell language.
12:08:28 <dainanaki> Anyone know how to get cabal to do this>
12:08:58 <c_wraith> if anyone does, dcoutts will.  But I've never seen it used that way.
12:09:39 * dcoutts ponders
12:10:11 <dcoutts> dainanaki: currently cabal is really designed for making Haskell shared libs rather than foreign shared libs
12:11:06 <dcoutts> dainanaki: that said, it may just work anyway, you'll get more symbols exported than necessary
12:11:20 <dainanaki> dcoutts, I don't really care if more symbols get exported or not.
12:12:23 <dainanaki> I've got in my cabal config file a single module exposed called Test, a C-source called EngineEntry.c, and my flags are -shared -fPIC -dynamic
12:12:35 <dcoutts> dainanaki: also note that currently the libs do not get linked against the rts
12:12:51 <dainanaki> Right, I also have extra-libraries: HSrts
12:12:56 <dcoutts> dainanaki: you would not need -shared -fPIC -dynamic, just configure with --enable-shared
12:13:53 <dcoutts> dainanaki: note also that this approach means you get one shared library per Haskell package you're using
12:14:05 <dcoutts> rather than one big shared lib with all the Haskell code linked into it
12:14:41 <dainanaki> Define package in this context, please.
12:14:50 <dcoutts> ghc's notion of a package
12:14:58 <dcoutts> a Haskell library
12:15:30 <dainanaki> right, but do you mean one dynamic library per *external* package that I use in my code?
12:15:37 <dcoutts> yes
12:15:51 <dcoutts> rts, base, containers, mtl, etc ...
12:16:06 <edwardk> Eduard_Munteanu: the dual notion of strength is costrength, which i show in that article isn't available for all functors
12:16:15 <shapr> o hai edwardk
12:16:20 <edwardk> in general you need something like preservation of colimits or traversable
12:16:22 <edwardk> heya shapr
12:16:31 <shapr> Will anyone here be in Portland this upcoming weekend?
12:16:40 <shapr> I'll be in Portland!
12:16:45 <edwardk> how fares the process of getting edjumacated?
12:16:57 <dcoutts> edwardk: btw, I presume it was you who filled in my GSoC eval, if so thanks! :-) (and sorry for being late)
12:17:20 <edwardk> dcoutts: yeah i threw it in there prophylactically. the only one that went unevaluated was the student who failed
12:17:41 <shapr> edwardk: It's about to start.. I'm going full-time next term, student loans, the whole thing. I'm also hoping to do a bunch of Haskell webdev portfolio-style stuff around the edges.
12:18:14 <dcoutts> shapr: cool
12:18:44 <shapr> My decade of Python skills mean I can easily get Python jobs, but ... I don't wanna :-(
12:18:57 <djahandarie> :)
12:18:57 <shapr> Clearly I need more HASKILLZ!
12:19:02 <dainanaki> dcoutts: If I build a shared lib for foreign usage, do I have to make sure they have a copy of ghc installed on their computer, or will linking it against the rtl do the trick?
12:19:20 <djahandarie> Maybe you can learn Agda and then when you combine your Agda and Python skills you'll automatically know Haskell? ;)
12:19:27 <shapr> djahandarie: that's an interesting idea
12:19:27 <dcoutts> dainanaki: you'll need to ship all the .so libs
12:19:39 <shapr> djahandarie: All depends on how much time I have left around class.
12:19:41 <monochrom> (you'll automatically know Ur/Web instead)
12:19:51 <Nibble> shapr, getting haskell jobs is really easy
12:19:51 <shapr> I think I'll be taking cs110 :-(
12:19:56 <shapr> Nibble: How so?
12:20:04 <Nibble> shapr, there are so many
12:20:06 <dcoutts> dainanaki: (I'm assuming you're on ELF unix platform) you can use ldd to check if you've got them all
12:20:09 <monochrom> what's wrong with cs110? :)
12:20:10 <djahandarie> shapr, I highly recommend trying to test out of everything you can
12:20:19 <shapr> Nibble: bara i sverige? :-/ Jag bor inte på Göteborg :-)
12:20:38 <Nibble> shapr, troligen flera hundra jobb bara i Sverige
12:21:04 <dcoutts> dainanaki: but you don't need the rest of ghc
12:21:28 <shapr> Nibble: Sure, I agree. And I've had a Haskell job before, but I'd still like to build up my skills before I complete my degree.
12:21:45 <Nibble> I was being sarcastic
12:21:47 <Nibble> xD
12:21:55 <shapr> Actually, it really is easy to find Haskell jobs.
12:21:59 <dainanaki> OK, thanks, I'm not totally clear on all of the intricacies of dynamic linking.
12:22:06 <dainanaki> shapr: do tell.
12:22:41 <shapr> dainanaki: Write awesome libraries, put them on hackage, write insightful blog entries, apply to the various Haskell companies.
12:22:47 <shapr> tadah, you'll have a Haskell job!
12:23:21 <dainanaki> even without a PHD or Masters?
12:23:21 <Nibble> get a C# job -> Be 12 years old and understand how to operate on strings
12:23:23 <monochrom> I don't think that's easy
12:23:35 <shapr> dainanaki: Sure, I got my first Haskell job without a bachelor's degree.
12:25:49 <Nibble> shapr, what university?
12:26:10 <Nibble> dsek?
12:26:36 <shapr> Nibble: Nej, jag bor i Alabama, USA.. una.edu
12:26:42 <Nibble> jaja
12:26:44 <Nibble> jaha*
12:27:32 <dainanaki> now if only I could find a haskell job in japan, my life would be complete.
12:27:34 <shapr> Nibble: I'm originally from Alabama... the Swedish speaking part.
12:27:50 <shapr> dainanaki: Are you attending the Tokyo FP meetings?
12:27:52 <copumpkin> dainanaki: have you talked to liyang?
12:27:56 <Nibble> shapr, there is one?
12:28:05 <copumpkin> dainanaki: tsuru
12:28:06 <shapr> Nibble: Wherever I'm standing =)
12:28:19 * shapr cackles
12:29:11 <olsner> shapr: but it wasn't swedish-speaking when you originally came from it, was it?
12:29:28 <shapr> olsner: That's true. I learned the Swedish in Sweden.
12:29:36 * monochrom is in the haskell-speaking part of canada!
12:29:53 <dainanaki> shapr, I'm not currently living in Japan, just looking to in the future
12:29:55 <shapr> Even worse, I speak like a native of Norrbotten! I'm speak farmer Swedish :-/
12:30:13 <ejackson> its better than speaker farmer Haskell....
12:30:27 <shapr> ejackson: true that, what would it look like?
12:31:15 <shapr> Nibble: But srsly, Haskell jobs aren't that hard to find and get.
12:31:27 <Nibble> depends if you are 15 or not
12:31:53 <djahandarie> Yes, it's definitely easier if you're 15 and you know Haskell
12:31:57 <shapr> djahandarie: truly
12:32:05 <shapr> But I'm not fifteen :-(
12:32:38 <monochrom> you were 15 when you rocked on haskell
12:32:44 <monochrom> or python
12:33:36 <shapr> Nah, I only wrote x86 assembly when I was fifteen, and some BASIC.
12:34:07 <shapr> monochrom: Did you code when you were fifteen?
12:34:30 <monochrom> yes, BASIC
12:34:33 <dainanaki> I guess I started writing Haskell at about 15.
12:34:38 <monochrom> I also drew flow charts
12:34:39 <kmc> that's really cool
12:34:43 <Nibble> monochrom, flow charts
12:34:49 <sipa> dainanaki: wow, really?
12:34:50 <kmc> i downloaded Hugs when i was 15 but didn't really know what to do with it
12:35:11 <dainanaki> sips, yep, I used it a lot in high school
12:35:16 <sipa> i was 20 when i heard about Haskell :)
12:35:19 <dainanaki> I hated my CS class because it was in Java
12:35:26 <Nibble> dainanaki, why would you hate it
12:35:29 <Nibble> Java has its uses
12:35:35 <joe6> it is so annoying to get this error: *** Exception: Prelude.head: empty list
12:35:41 <monochrom> I think I did something resembling what Floyd said about correctness done on flow charts
12:35:43 <Nibble> joe6, it is
12:35:52 <joe6> is there a custom function that can identify where the error is occurring?
12:35:55 <dainanaki> Nibble, I was less wise back then.
12:35:58 <joe6> or, I could write one.
12:36:00 <azaq23> I tried to compile a linux kernel when I was 15 by reading every help option available and guessing. It didn't run.
12:36:25 <Nibble> joe6, pastebin your function
12:36:34 <joe6> just curious if there is something like that..
12:36:41 <kmc> @where+ RTS-xc ghc --make -fforce-recomp -prof -auto-all -rtsopts foo.hs && ./foo +RTS -xc
12:36:42 <lambdabot> It is stored.
12:36:44 <shapr> joe6: ndm wrote a 'safeHead' though I forget where it's stored.
12:36:45 <kmc> @where RTS-xc
12:36:46 <lambdabot> ghc --make -fforce-recomp -prof -auto-all -rtsopts foo.hs && ./foo +RTS -xc
12:36:46 <monochrom> Control.Exception.assert has line numbers
12:36:49 <kmc> joe6, ^^^
12:37:01 <Nibble> assert
12:37:08 <Nibble> :(
12:37:11 <joe6> let me check that.
12:37:15 <kmc> joe6, the best solution is not to use 'head' though
12:37:15 <joe6> thanks a lot
12:37:16 <shapr> joe6: safehead is mentioned here: http://neilmitchell.blogspot.com/2011/02/corner-cases-and-zero-and-how-winforms.html
12:37:22 <kmc> 'head' and 'tail' and 'null' should be banished from Prelude
12:37:27 <kmc> use pattern-matching instead
12:37:33 <copumpkin> kmc: how about init and last? :)
12:37:46 <monochrom> one rule to ban them all
12:37:47 <joe6> kmc, oh, that is a good idea.
12:37:50 <joe6> will do that.
12:37:52 <djahandarie> Has anyone tried to make parts of the network stack typesafe? Like formalizing subnets and stuff
12:38:40 <shapr> djahandarie: Two FP network stacks I've heard of... one got proved in Isabelle/HOL, one is pure Haskell in LightHouse, and it works okay :-)
12:39:01 <Nibble> kmc, that makes sense
12:39:17 <olsner> shapr: proven correct but works only "okay"? :)
12:39:27 <kmc> it's better to pattern-match even if one case is «error "fall over and die"»
12:39:30 <shapr> olsner: I've not tried the proven stack, only the one in Lighthouse.
12:39:35 <kmc> because at least you've made that explicit in your code
12:39:42 <olsner> aha, would've been funny though
12:40:47 <joe6> kmc, yes, they should be banned from prelude.
12:40:59 <joe6> makes me wish I was using agda, when I hit these errors.
12:41:41 <copumpkin> and agda is webscale
12:41:49 <copumpkin> unlike haskell, which is impractical for the real world
12:42:24 <joe6> haha, isn't thet the reason we use haskell. a stop-gap arrangement till agda gets off its' training wheels..
12:42:44 <djahandarie> shapr, any idea on the name of the Isabelle/HOL one?
12:45:12 <monochrom> adga needs an agdage
12:45:47 <sipa> -ge ?
12:45:58 <monochrom> and a "gadal install"
12:47:14 <monochrom> and also an official sanction to define "adga" = "agda" so typos are forgiven
12:54:09 <joe6> matter of time before agda dominates the world..
12:54:35 * djahandarie starts the giant countdown globe
12:57:37 <Saizan> agda is webscale in the sense that you need half of The Cloud to run the typechecker
12:59:31 * hackagebot cabal-dev 0.8 - Manage sandboxed Haskell build environments  http://hackage.haskell.org/package/cabal-dev-0.8 (RoganCreswick)
13:08:48 <paczesiowa> is cabal-install backward/forward compatible? would it be possible to use old cabal-install now, or new cabal-install with old ghc?
13:14:25 <Saizan> cabal-install is tested against older ghc's
13:15:53 <monochrom> @remember Saizan agda is webscale in the sense that you need half of The Cloud to run the typechecker
13:15:54 <lambdabot> I will remember.
13:17:55 <paczesiowa> so installing simple packages (like cabal-install itself) should work forever?
13:18:08 <identity_> Rejoice, for I have recruited a new member to the congregation
13:18:11 <tsuraan> is there a way to convert from a Handle to a Socket, the opposite of the way that socketToHandle works?
13:18:20 <edwardk> hahahah
13:18:23 <edwardk> (re cloud)
13:18:41 <identity_> Daily tasks: convince someone to learn haskell (Check)
13:18:56 <mauke> tsuraan: I don't think that would make sense
13:19:02 <zmv> haha
13:19:56 <benmachine> paczesiowa: work forever?
13:20:01 <benmachine> what do you mean?
13:20:22 <monochrom> maybe you can System.Posix.IO.handleToFd
13:21:22 <benmachine> my instinct is that sockets contain more information than handles
13:21:23 <tsuraan> mauke: Network.accept returns a Handle, but I want to use it with sendfile, which needs a Socket.  Now that I look again, though, Network.Socket also has an accept that returns a Socket
13:21:29 <tsuraan> I guess I'll use that :-)
13:21:48 <tsuraan> hooray for looking at more docs :)
13:21:49 <paczesiowa> benmachine: I'm working on something that looks like ghc installer: ghc is easy (there are binary packages on ghc's www), installing cabal-install is hard - I'd have to autoinstall its deps, to do that I'd have to be cabal-install.
13:22:14 <paczesiowa> benmachine: but if the user already has any version of cabal-install, maybe the problem is already solved
13:22:28 <benmachine> paczesiowa: cabal-install comes with a bootstrap script to find and install its dependencies
13:22:38 <benmachine> maybe use that?
13:22:49 <paczesiowa> benmachine: sweet! thanks
13:24:54 <paczesiowa> benmachine: this looks like exactly what I needed!
13:25:20 <benmachine> :)
13:45:27 <paczesiowa> @seen dcoutts
13:45:27 <lambdabot> Unknown command, try @list
13:45:27 <preflex>  dcoutts was last seen on #ghc 2 minutes and 17 seconds ago, saying: next step, blog methinks
13:55:52 <dcoutts> paczesiowa: did you want to talk to me?
13:57:33 <paczesiowa> dcoutts: yes. have you read what I wrote here about tar library?
13:57:48 <dcoutts> paczesiowa: yes, I made a note in my local copy
13:57:57 <dcoutts> about creating the parent dirs or not
13:58:41 <paczesiowa> dcoutts: so will it be fixed/changed in the next version?
13:59:25 <dcoutts> paczesiowa: yeah, or I'll decide to do something else
13:59:42 <dcoutts> paczesiowa: btw, you can code your own custom unpack, everything you need is exposed
14:00:14 <dcoutts> e.g. the one provided doesn't do anything to preserve file permissions etc, it's just supposed to be simple & portable
14:00:29 <paczesiowa> dcoutts: I tried copying Unpack.hs, but it needs fromLinkTarget (which is not exported)
14:00:37 <dcoutts> oh
14:01:20 <dcoutts> paczesiowa: oh, yes it is, from Codec.Archive.Tar.Entry
14:01:30 <dcoutts> which has all the more detailed stuff
14:01:40 <paczesiowa> I have another question: is it possible to write a function that would work like "--strip-components N" (don't know if it's posix or GNU only)
14:01:40 <dcoutts> Codec.Archive.Tar is just the simple, most usually useful bits
14:01:51 <paczesiowa> dcoutts: oh, great
14:01:55 <dcoutts> paczesiowa: what does that do?
14:02:43 <paczesiowa> dcoutts: instead of unpacking ghc tarball to ghc-7.0.4 it unpacks contents of that dir to the top (-C) target dir
14:02:43 * dcoutts consults man tar
14:02:55 <dcoutts> paczesiowa: so that's a good use case for writing your own unpack
14:03:29 <paczesiowa> dcoutts: I was hoping for some function that would have type Entries -> Entries
14:03:32 <dcoutts> paczesiowa: or perhaps you can implement it as a map on the TarEntries prior to unpack
14:03:53 <dcoutts> paczesiowa: right, exactly, and that should not be hard for you to implement
14:04:20 <paczesiowa> dcoutts: great! one less call to non-haskell binary
14:04:36 <dcoutts> paczesiowa: if you think it's generally useful I might consider including it as a utility function
14:05:10 <paczesiowa> dcoutts: great!
14:05:25 <dcoutts> paczesiowa: presumably you use --strip-components 1 right? that's the usual use case?
14:05:51 <dcoutts> so that instead of unpacking ./ghc-7.0.2/foobar you get ./foobar
14:05:53 <paczesiowa> dcoutts: I use N=1, no idea about the usual case - that's the first time I've ever needed it
14:05:59 <paczesiowa> dcoutts: yes
14:06:04 * dcoutts wonders if ./ will confuse it
14:11:28 <dylukes> Could some help explain why this isn't equivalent?
14:11:28 <dylukes> https://gist.github.com/1090679
14:11:39 <dylukes> the F# version is the one not working, I'm trying to learn by comparison...
14:17:34 <burbul> I'm just rewriting some Python code in Haskell (to which I'm pretty new), and I replaced a regular expression with a Parsec parser (as my Haskell textbook recommends). It's *really* long. See   http://hpaste.org/49176   . Can anyone recommend a way of shortening/tidying it up?
14:18:21 <Amtal> burbul, I'm not sure if my answer will be helpful... But you could look into applicative functors.
14:18:48 <burbul> Thanks...  Just googling it.
14:19:17 <paczesiowa> burbul: create a lexeme function "lexeme p = do x <- p; whites; return x"
14:19:37 <kmc> burbul, do { let f x = whites >> string x >> whites; f "("; ... f","... }
14:19:41 <burbul> I thought about doing something pretty similar -- actually I was thinking of just writing the whites on the same line as
14:19:55 <kmc> or if you are more comfortable with "do", let f x = do { whites; string x; whites }
14:20:07 <burbul> no, I'm happy with >>
14:20:07 <kmc> the beauty of parser combinators is that parsers are first-class values
14:20:13 <kmc> you can make functions that take and return parsers
14:20:13 <hpaste> int80_h pasted “can't get the syntax right for this constructor” at http://hpaste.org/49177
14:20:14 <burbul> I know I can use higher order functions
14:20:18 <kmc> cool :)
14:20:36 <burbul> In fact I was thinking I could build a monad  on top of the standard parser that inserted 'whites' between each pair of arguments
14:20:37 <hpaste> benmachine annotated “parsec long parser” with “parsec long parser (annotation)” at http://hpaste.org/49176#a49178
14:20:50 <kmc> int80_h, data ServerStatus = StatusUp ServerD | StatusDown
14:21:02 <kmc> a data type has to introduce new constructors
14:21:05 <benmachine> burbul: see annotation
14:21:08 <burbul> thanks
14:21:10 <kmc> you can't say "data Foo = ExistingTypeA | ExistingTypeB"
14:21:26 <benmachine> burbul: there's an applicative functor way of doing it too, but not sure it's less confusing
14:21:42 <benmachine> burbul: in general regexps are more concise than parsec, but less readable
14:21:45 <kmc> int80_h, you could also just use Maybe ServerD
14:21:50 <benmachine> (and parsec is much more composable)
14:21:52 <Amtal> I'd love to see a golfed/beautified/well abstracted version of that code.
14:21:56 <burbul> benmachine thanks
14:21:59 <int80_h> kmc: I was wanting something like a Union C construct... Maybe ServerD sounds right
14:22:12 <kmc> "data ServerStatus = StatusUp ServerD | StatusDown"
14:22:17 <kmc> is isomorphic to "Maybe ServerD"
14:22:19 <Sebastian> I have a problem with number types. What it boils down to is that I want to have a function accepting any number (Num) and then squaring it. But I have to convert the number type first, which I can't without knowing if it is a rational or integral, etc. anybody know what I can do?
14:22:21 <kmc> data Maybe a = Just a | Nothing
14:22:31 <kmc> :t f x = x * x
14:22:33 <lambdabot> parse error on input `='
14:22:35 <mauke> Sebastian: why convert?
14:22:38 <kmc> :t let f x = x * x in f
14:22:39 <lambdabot> forall a. (Num a) => a -> a
14:22:44 <kmc> the (*) function already works on all Num types
14:22:52 <int80_h> kmc: Thanks :)
14:23:21 <kmc> int80_h, it's generally good to introduce new types that are meaningful for your problem domain, rather than using Maybe, Either, tuples, etc.  the flip side is that Maybe already has useful helper functions in Data.Maybe
14:23:26 <kmc> i think here i would go with Maybe ServerD
14:23:40 <kmc> but it's hard to say, depends on how you're using these things
14:25:13 <hpaste> Sebasti0n pasted “numConvert” at http://hpaste.org/49179
14:25:44 <kmc> Sebastian, right, square roots are different from squaring
14:25:46 <kmc> :t sqrt
14:25:47 <lambdabot> forall a. (Floating a) => a -> a
14:25:53 <kmc> you can't sqrt all numbers
14:26:09 <ash__> anyone know of a nearest neighbor search library for 2d operations?
14:26:29 <kmc> remember "Num" includes not just Int and Float but also vectors, complex numbers, quaternions, matrices, polynomials, infinite-dimensional vector spaces...
14:27:22 <int80_h> kmc: Hmm, yeah I just wanted a way to organize the types involved in displaying the status of a set of servers. I think I'll go with Maybe ServerD. Now that I think about how I'm going to use this, my initial attempt seems superfluous.
14:30:11 <Sebastian> lets says I have a data structure which can hold int, integer, double, float and I want to be able to sum up its elements and then take the sqrt, would I have to define my own number class with a conversion function to convert the result of the sum to double before squaring it?
14:30:34 <Sebastian> before taking the sqrt, sorry
14:30:56 <hpaste> Amtal annotated “parsec long parser” with “parsec long parser (annotation) (Control.Applicative annotation)” at http://hpaste.org/49176#a49181
14:30:58 <benmachine> you would not have to define your own class
14:31:10 <Amtal> burbul, see http://hpaste.org/49176#a49181
14:31:26 <Amtal> I suspect I've got an error or two, but the theme should be roughly right.
14:31:56 <ourfrank> Is there a way to use Data.Dynamic with polymorphic types?
14:32:19 <Sebastian> what should I do then benmachine?
14:32:29 <elliottt> ourfrank: you might be better off using an existential.
14:32:34 <c_wraith> ourfrank: nope.
14:32:52 <elliottt> essentially the same effect, but you get to specify the constraints you want, other than Typeable
14:32:55 <benmachine> Sebastian: it depends on what your data structure looks like, and what exactly you're holding in it
14:33:03 <c_wraith> ourfrank: Data.Dynamic depends on Data.Typeable, which means that a concrete type is needed.
14:34:26 <Sebastian> benmachine: I have a vector and i want to calculate its length (sum up the square of the elements and then take the sqrt)
14:35:03 <ourfrank> Thanks. I'm using an existential, but the problem is that I don't know in advance which constraints I'll need. I'm generating and compiling a Haskell program, then connecting to it, all at runtime. I'm using TChans to communicate and only know which types go into the generated program and which ones go out.
14:35:35 <benmachine> Sebastian: if you want your vectors to have lengths, you might as well always store them as Doubles
14:35:46 <benmachine> why would you want a vector of ints?
14:36:42 <ourfrank> Is there a way to make a function return different types of values, depending on the types it is given?
14:36:52 <Cale> ourfrank: yes
14:37:07 <Cale> ourfrank: You use a typeclass, possibly with an associated type (synonym)
14:37:08 <monadic> ourfrank: Something like f :: a -> [a] fits the description
14:37:08 <Sebastian> benmachine: you are right. though the actual dimension values could be int and the resulting length double
14:37:20 <burbul> Amtal: thanks!
14:37:24 <Cale> Or just normal parametric polymorphism, if you can get away with it :)
14:37:55 <benmachine> Sebastian: it's possible, but for most uses of vectors I can think of you don't want ints in the dimension values (or you're not interested in lengths)
14:37:58 <Cale> ourfrank: Probably it's best if you describe exactly what you want :)
14:38:10 <monadic> You would need a functional dependency or a type family to do it with typeclasses
14:38:34 <ourfrank> Thanks for the hints. However, this function needs to operate on the values it is given. For example, for a given Int it might increment it. For a given String it might append "meow" to the end. Is this possible in Haskell, or is it very not Haskell-like?
14:38:58 <benmachine> Sebastian: in any case, you'd probably use realToFrac to do the conversion
14:39:08 <c_wraith> ourfrank: that's what type classes are for
14:39:10 <monadic> ourfrank: All all of the functions of the form a -> a? A single type variable typeclass would suffice
14:39:27 <hpaste> Amtal annotated “parsec long parser” with “parsec long parser (annotation) (Control.Applicative annotation) (annotation)” at http://hpaste.org/49176#a49182
14:39:44 <ourfrank> Ah, I see now. Thanks!
14:39:46 <benmachine> > fix (++ " (annotation)")
14:39:50 <lambdabot>   mueval-core: Time limit exceeded
14:39:55 <Amtal> burbul, ^ applicative functors can be much neater and more compact than do-syntax.
14:40:09 <Sebastian> benmachine: yeah, you are right. thanks for the help
14:40:31 <benmachine> Sebastian: realToFrac can convert any of the types you mentioned into ones that can be square rooted
14:40:40 <benmachine> (i.e. Doubles)
14:40:45 <Cale> ourfrank:  class Foo a where foo :: a -> a
14:40:55 <Cale> ourfrank: instance Foo Int where foo n = n + 1
14:41:06 <Cale> ourfrank: instance Foo String where foo x = x ++ "meow"
14:41:09 <benmachine> ourfrank: it *is* a bit of a strange thing to do, though
14:41:27 <benmachine> Cale: for that last one you'll need FlexibleInstances or the silly showList type thing
14:41:33 <Cale> yeah
14:41:46 <Cale> FlexibleInstances is uncontroversial
14:41:52 <benmachine> or perhaps IsChar a => Foo [a]
14:41:53 <benmachine> >_>
14:42:12 <benmachine> or turn on TypeFamilies and do (a ~ Char) => Foo [a] :P
14:42:20 <Cale> lol
14:42:44 <Sebastian> another question, is there a way to define a synonym for a function signature?
14:42:53 <benmachine> you can define type synonyms
14:43:01 <benmachine> annoyingly though you can't put class contexts in them
14:43:53 <Cale> I think that too is an extension
14:44:18 <benmachine> Cale: well, I think you can do it by enabling rank-n types, but you don't really get what you want
14:44:25 <benmachine> or maybe I'm thinking of something else
14:44:42 <Sebastian> I wanted to define something like foo = (Int -> Int) so that I can have a function head bar :: foo -> Int -> Int
14:45:18 <benmachine> you can do type IntFunction = Int -> Int; bar :: IntFunction -> IntFunction
14:46:16 <Sebastian> ah, ok, but no class contexts
14:46:33 <Sebastian> is that going to be changed any time soon?
14:46:45 <Sebastian> or is there a reason for that particular feature missing?
15:01:58 <Lemon> Besides the stuff from Mr. Augustsson's blog, are there any other "tutorials" on the use of the Haskell LLVM bindings?
15:27:10 <ourfrank> How much of a performance penalty does using Data.Dynamic.toDyn on a value incur?
15:27:22 <ourfrank> (Also, unwrapping it back.)
15:27:29 <hpaste> Amtal annotated “parsec long parser” with “parsec long parser (annotation, Applicative /w correct precedence)” at http://hpaste.org/49176#a49183
15:30:44 <Amtal> Hey neat, (<*) is like (>>) but discards the second value instead of the first.
15:31:02 <kmc> yes
15:31:03 <c_wraith> and (*>) is exactly like (>>)
15:31:28 <mauke> ourfrank: they look pretty cheap
15:31:29 <kmc> ourfrank, benchmark it with Criterion and find out :)
15:31:40 <wli> (<*) == flip (*>) ?
15:31:52 <kmc> don't think so
15:31:57 <kmc> both operators combine "effects" in the same order
15:31:59 <mauke> toDyn is a simple wrapper; fromDyn is an integer comparison and a cast
15:32:02 <ion> @src (<*)
15:32:03 <lambdabot> (<*) = liftA2 const
15:32:04 <kmc> the question is which result is returned
15:32:06 <ion> @src (*>)
15:32:06 <lambdabot> (*>) = liftA2 (const id)
15:32:09 <ourfrank> mauke, kmc: Thanks. I'll benchmark it just to make sure, then.
15:32:19 <shachaf> And ap is like (<≶>), I suppose?
15:32:26 <shachaf> Er.
15:32:30 <ion> @@ @unpl @src (<*)
15:32:31 <lambdabot>  ()
15:32:39 <kmc> @let (€) = flip ($)
15:32:40 <lambdabot>  Defined.
15:32:41 <c_wraith> ap is (<*>), yes
15:33:01 * shachaf meant to say "(<*>) is like (<≶>)"
15:34:22 <ion> a <* b = liftA2 const a b = const <$> a <*> b = (\a' _ -> a') <$> a <*> b
15:35:17 <mgccl> I was wondering, are there algorithms that will always use a higher complexity in pure functional languages than languages like C?
15:35:20 <Peaker> @type [flip (liftA2 const), liftA2 (flip const)]
15:35:21 <lambdabot> forall (f :: * -> *) b a. (Applicative f) => [f a -> f b -> f b]
15:35:57 <Peaker> mgccl: A "pure functional language" like Haskell can express non-pure algorithms just fine...
15:36:12 <Peaker> mgccl: I think the term "purely functional" is somewhat unfortunate, I'd much rather a term like "typed effects"
15:36:25 <c_wraith> mgccl: there are several algorithms that are known to be a factor of O(log n) worse when they can't use mutation.  I think that's what you *actually* meant to ask?
15:36:42 <mgccl> c_wraith: yes, that's what I meant
15:37:16 <copumpkin> can people upvote http://www.reddit.com/r/haskell/comments/it67k/rewritten_agda_introduction/ to get it out of limbo?
15:37:21 <copumpkin> I'm not sure why it isn't showing up on the front page
15:37:28 <c_wraith> mgccl: well, "known" is too strong.  None of them are proven to be worse.  But a simple example is random shuffling.
15:38:01 <c_wraith> mgccl: There's no known random shuffle that's better than O(n log n) using immutable structures.  It's trivial to make it O(n) using mutable structures.
15:38:19 <ion> Cool, upvoted.
15:38:23 <shachaf> copumpkin: Well, the front page of reddit.com/r/haskell is a hard spot to get to. Lots of competition.
15:38:25 <thoughtpolice> copumpkin: spam filters? i really hate the reddit ones sometimes :/
15:39:05 <thoughtpolice> also, an upvote to the left has been applied.
15:39:53 <mgccl> c_wraith: thanks, that is a good example, is it proven there can't be problems where mutable version can beat immutable version by more than a factor of log(n)
15:40:13 <c_wraith> mgccl: yes, that much is proven.
15:42:11 <Peaker> I think many of the objections to Haskell I hear about are related to it being "purely functional" and "our task is about a lot of effects, so it can't be a good idea to use Haskell". Bah.  "typed effects" would have worked much better
15:42:44 <kmc> yep
15:42:52 <kmc> it's a convenient way to dismiss Haskell without knowing Haskell
15:43:29 <Peaker> "purely functional" doesn't even mean anything
15:43:30 <c_wraith> mgccl: just because it's trivial to replace any number of mutable cells with an immutable tree that's O(log n) on update, instead of O(1).  That sets an upper bound on how much worse it can get, extremely naively
15:43:39 <kmc> Peaker, it means something specific and technical
15:43:51 <kmc> people then draw conclusions from that technical property about what it's like to use the language in a practical sense
15:43:56 <kmc> which turn out to be false
15:44:14 <kmc> "OOP is good, PHP has OOP, therefore PHP is good"
15:44:14 <absentia> (1) is haskell with .5 speed of C? and (2) is it practical in that it's available for the platform I'm coding for (ie: ios/osx) and (3) what is the business risk of using a language with potentially hard to find replacement coders?
15:44:31 <kmc> absentia, "Haskell" has no speed, as it's a standardized language, not an implementation
15:44:38 <kmc> GHC produces pretty fast code
15:44:50 <kmc> but you should not expect the 2-line clean idiomatic Haskell code to perform as well as 50 lines of hand-tuned C
15:44:52 <Peaker> kmc: http://en.wikipedia.org/wiki/Purely_functional   -- Haskell doesn't seem to adhere to this definition because it does have destructive modifications, etc (they just have a different type/etc)
15:44:54 <absentia> right, I see that... and it's possible to write bad code in any language.  not the point.
15:45:05 <kmc> Peaker, no, it has pure values which describe modifications which could occur
15:45:13 <kmc> you can then optimize the parts of your Haskell code which matter
15:45:21 <kmc> up to and including actually calling C
15:45:46 <kmc> absentia, there's a few people doing Haskell coding for iOS
15:45:49 <kmc> talk to Cale about that
15:45:54 <kmc> it's not exactly a supported platform for GHC
15:46:05 <kmc> situation is better on OS X though it's still not as smooth as Linux
15:46:12 <kmc> (3) is tricky
15:46:15 <Peaker> absentia: Haskell speed varies very greatly.. Example: If you use the standard String type, which is a linked list of unicode code points -- you might get worse-than-python performance.  If you use Text instead, you get within a small factor of C's speed (and orders of magnitude faster than equivalent Python)
15:46:28 <kmc> (3) is a big concern
15:46:46 <kmc> there are not many proficient Haskell programmers, but they tend to love Haskell so much that just getting to use the language serves as a form of compensation :)
15:46:56 <kmc> but maybe they are overall still more expensive
15:47:11 <ion> A chicken and egg problem
15:47:14 <kmc> employers love to hire people based on Haskell knowledge and then make them write Java or Scala
15:47:28 <Nibble> kmc, which is not a bad idea
15:47:38 <wli> No F#?
15:47:47 <Peaker> kmc: are you basically saying that all of IO is just a library that's not really a part of Haskell?  If it is a part of Haskell, then Haskell has support for destructive modifications/etc -- it just types them differently
15:47:59 * hackagebot apelsin 1.1 - Server and community browser for the game Tremulous  http://hackage.haskell.org/package/apelsin-1.1 (ChristofferOjeling)
15:48:07 <kmc> Peaker, it types them differently and also treats them fundamentally different
15:48:11 <kmc> IO is not just a "tag" on impure values
15:48:13 <Nibble> Peaker, what is it with IO that performs destruction?
15:48:49 <Cale> actually, talk to blackh if you're interested in iOS support
15:49:00 <absentia> riht
15:49:02 <Peaker> One could write a completely impure program in any non-pure-functional language. One could then mechanically translate that program to Haskell, using slightly different syntax.  The program has not magically become pure. It is still the same.
15:49:03 <Cale> (I work with him, he's the guy who knows about that)
15:49:16 <Peaker> Nibble: e.g: writeIORef
15:49:30 <absentia> cale: the issue is -- I work on a team of devs for mobile devices... ios = objc, android = java ... etc.
15:49:38 <Nibble> Peaker, isn't that using a state monad or something?
15:49:45 <Peaker> Nibble: or just using IO
15:49:57 <absentia> business would never approve of using haskell... next, they don't even like only 1 coder on any one project.
15:50:49 <mgccl> c_wraith: thanks :) wow, this is a trivial result, can't believe I was going to ask this question on some research level Q&A forum lol.
15:51:08 <Cale> absentia: ? I don't understand what your questions were about in that case.
15:51:25 <c_wraith> mgccl: well, it's not obvious the first time you look at it.  But once you see it, you do wonder how you missed it.
15:51:53 <Peaker> kmc: the ability to write impure programs virtually in the same way in Haskell as you would in other languages makes the "pure functionality" thing moot, IMO.  Sure, you would use do blocks and "<-" instead of "=" for your effects -- but the program has the same pureness as in any other language, and is written in Haskell.  There are certainly advantages -- but these are advantages of typed effects
15:52:05 <absentia> cale: don't worry 'bout it.
15:52:43 <Nibble> Peaker, I don't see what you are getting at
15:52:49 <kmc> Peaker, no, the advantages are more than tagging effects.  The advantage is that an effect doesn't go off early while you're still describing it
15:52:58 <kmc> anyway this is probably one of those meaningless arguing-over-terminology things
15:53:06 <Nibble> of course if you write haskell the same way you would write C you don't get all the advantages.
15:53:30 <Nibble> If it's nice, use it, if it is not, don't use it
15:53:34 <Nibble> unless someone pays you lots of money
15:53:47 <Peaker> Nibble, kmc: You've probably seen http://conal.net/blog/posts/the-c-language-is-purely-functional  -- I agree with it in general.
15:54:11 <Cale> Peaker: I thought that wasn't serious.
15:54:29 <Cale> (or at least, not to be taken at face value)
15:54:51 <Nibble> Peaker, why even care
15:54:58 <monochrom> every plain text file is purely functional along that line.
15:55:00 <Peaker> Cale: of course it isn't serious -- I think the idea is to poke a hole in the notion that "purely functional" is a significant property of a language, if it includes completely imperative programs in it
15:55:27 <Peaker> Nibble: I'm saying it would be much better to call Haskell a language with "typed effects" -- rather than "purely functional".  The latter implies to people that Haskell cannot be used to describe effectful programs
15:55:38 <Cale> I'm not sure I would go as far as saying that programs written using the IO monad library are "completely imperative" either.
15:56:16 <Peaker> Cale: I wasn't implying that -- but of course one *can* write completely imperative programs in Haskell with IO -- are they really using a "purely functional" language?
15:56:26 <Cale> They have imperative meanings
15:56:28 <Nibble> Peaker, my understanding of the word pure is that there are no side-effects, that a function given the same input will produce the same output
15:56:29 <Cale> hmm
15:56:32 <Nibble> isn't that true for haskell?
15:56:54 <zygoloid> Nibble: depends what you arbitrarily choose to label a 'function'
15:57:01 <benmachine> Nibble: it's difficult to talk about "same" in terms of outputs when you're looking at IO
15:57:04 <Peaker> Nibble: Sure, Haskell's *functions* are pure. But Haskell's IO actions are pure when used as values, but they represent completely impure computations
15:57:08 <Cale> Well, functions in Haskell are proper mathematical functions. That's what I take "purely functional" to mean.
15:57:15 <benmachine> because IO doesn't have an obvious notion of equality
15:57:35 <Nibble> Peaker, what they represent doesn't really matter?
15:57:54 <Peaker> Cale: Well, I keep meeting more people ridiculing the notion of using Haskell for programs that happen to have effects -- because *everyone* I talk to assumes "purely functional" means it doesn't really do effects or at least doesn't do them well...
15:58:03 <kmc> Cale, except for ⊥ ;)
15:58:12 <Peaker> Nibble: it does when you can place any part (even a majority!) of your program in them
15:58:25 * zygoloid likes the idea of calling haskell 'a language with typed effects' rather than 'a purely functional language'
15:58:28 <Cale> Peaker: oh, I see, people who have no idea what they're talking about don't know what they're talking about.
15:58:29 <kmc> yeah, there is a stage of learning IO where it seems like, at best, a kludge to allow mediocre effects in a language that doesn't want them
15:58:34 <kmc> fortunately, you get past this stage :)
15:58:36 <Philonous> Peaker:  I partially agree. I think saying that haskell is "purely functional" stresses the fact that what we do is construct IO actions from other IO actions in a completely side-effect free way. Inside pure haskell those effects are opaque and are only bestowed with a semantics by the RTS
15:58:49 <Peaker> Cale: Yes.. But better terminology would go a long way to give people the right idea
15:58:59 <Cale> Maaaaybe
15:59:03 <kmc> you can judge whether someone is past this stage by whether they can conceive of a type like Int -> IO (IO a -> IO a)
15:59:16 <Peaker> Philonous: that puts a big emphasis on the pure part, as if the IO actions themselves are not programs that we write as well
15:59:17 <shachaf> kmc: Not if you're conal.
15:59:18 <Cale> To some extent, you just have to learn the language to understand it
15:59:21 <kmc> . o O ( still think that should be Int -> IO (forall a. IO a -> IO a) but GHC really wouldn't like that one)
15:59:47 <benmachine> yay impredicativity :P
15:59:53 <benmachine> (what does the Int do?)
16:00:00 <shachaf> Timeout?
16:00:03 <c_wraith> impredicative types work...  with enough help
16:00:12 <kmc> http://hackage.haskell.org/packages/archive/spawn/0.2/doc/html/Control-Concurrent-Spawn.html#v:pool
16:00:12 <Peaker> It's somewhat unfair to say Haskell is just the pure part -- and what happens in IO is not Haskell anymore, so Haskell is still pure.  The things inside IO are Haskell programs too, and impure ones at that
16:00:27 <shachaf> Oh.
16:00:32 <Philonous> Peaker:  Yes, I don't like it, either. But I think it is sensible to stress that (unlike ML) haskells ambient Monad doesn't allow for arbitrary side effects
16:01:07 <Peaker> Philonous: Yes, I like that too.. But I don't think saying it is a "purely functional language" really gives that idea at all
16:01:14 <Peaker> (to someone not familiar with the language)
16:01:16 <benmachine> what haskell does very well is separate the impure from the pure
16:03:28 <c_wraith> kmc: http://hpaste.org/49185  That works in GHC 6 and GHC 7.  Impredacativity lives!
16:03:41 <c_wraith> (however, it's really verbose)
16:04:34 <dsilva> hi all
16:04:49 <c_wraith> hi
16:04:50 <dsilva> anybody here could inform me about Haskell
16:04:54 <dsilva> the purpouse
16:05:02 <dsilva> and what could I do with it
16:05:07 <dsilva> ???
16:05:20 <dsilva> the Haskell Boundaries ?
16:05:45 <dsilva> anyone
16:05:56 <dsilva> c_wraith ????
16:05:59 <Nibble> dsilva, what do you want to know.
16:06:35 <dsilva> Well surfing the web
16:06:46 <Philonous> Peaker:  What makes it even worse is that haskell 98 actually specifies the operational semantics of the primitive IO actions. So pretending they are somehow not part of haskell is rather silly
16:06:54 <dsilva> looking for other programming languages
16:07:02 <dsilva> Suddenly I found this one
16:07:25 <Peaker> Philonous: and they probably do not belong as part of a "purely functional" language, at least according to the meaning of "purely functional" in Wikipedia
16:07:36 <dsilva> ho ok
16:07:38 <dsilva> :)
16:07:42 <dsilva> jeje
16:07:58 <dsilva> its good to know about it
16:09:07 <Cale> dsilva: Nobody answered you though....
16:09:19 <Cale> dsilva: (that was part of another discussion that was going on)
16:10:05 <Philonous> Peaker:  So haskell has a purely functional core plus an opaque, continuation-based interface to IO. Unfortunately, that sounds not nearly as snappy as just "purely function"
16:10:09 <Cale> dsilva: Haskell is a pretty nice general purpose programming language. I consider it to be the nicest language which is practical for real world use at the moment.
16:10:29 <Nibble> Cale, what's the nicest language that isn't practical
16:10:59 <Philonous> Nibble:  Epigram, I guess
16:11:19 <Cale> Nibble: I'm not sure there's a single nicest one, but there's some interesting research languages which are more futuristic, like Agda and Epigram.
16:11:22 <Peaker> Philonous: "typed effects" sounds good and gives the right idea IMO
16:11:56 <dsilva> C#
16:12:27 <Cale> C# is boring. :P
16:12:52 <dsilva> jejeje
16:13:00 <dsilva> That is why I am Here now
16:13:02 <dsilva> :)
16:15:58 <Peaker> @where LYAH
16:15:59 <lambdabot> http://www.learnyouahaskell.com/
16:16:03 <Peaker> dsilva: visit that site
16:17:02 <dsilva> ok consider it Done :)
16:17:07 <dsilva> Right away
16:17:21 <Philonous> Peaker:  Ultimately it doesn't matter too much. I think "continuation based" explains it better, because it is immediately clear whay you cant "extract" a String from an IO String. But you can't condense haskell IO system in two words, anyway.
16:18:05 <Philonous> Peaker:  But I agree, I was myself was puzzled how one could write a useful program without invoking some sort of side effect.
16:19:42 <Philonous> otoh I doubt too many people understand continuations. We might bait some schemers, though
16:20:35 <dsilva> I am starting reading it
16:21:12 <dsilva> I hope this language give me fun
16:21:17 <dsilva> ;)
16:22:36 <Peaker> Philonous: yeah, most programmers' minds IME have not yet been warped by thinking of compositions of continuations :-)
16:23:18 <c_wraith> @qutoe stack-machine
16:23:34 <c_wraith> ...  missing lambdabot, or did I mangle that too much?
16:24:04 * hackagebot enumerator 0.4.12 - Reliable, high-performance processing with left-fold enumerators  http://hackage.haskell.org/package/enumerator-0.4.12 (JohnMillikin)
16:24:19 <ttuegel> speaking of compositions of continuations...
16:24:55 <Nibble> just reading what goes on in this channel gives me headaches
16:25:45 <dsilva> jejeje
16:26:32 <hpaste> nyingen pasted “+RTS -sstderr” at http://hpaste.org/49188
16:26:48 <dainanaki> suppose I have a number of seconds in a unix time_t parsed from a binary file. What is the most straightforward way to turn it into a UTCTime?
16:26:57 <danharaj> oh god time
16:26:59 <nyingen> hpaste automatically notifies the channel now?
16:27:13 <danharaj> hpaste will tell the channel if you select a channel in the submission form
16:27:18 <nyingen> I see
16:27:23 <hpc> hpaste has for a long while
16:27:31 <nyingen> well, I have this RTS report that I'm trying to understand
16:27:33 <hpc> i remember hpaste being around when i joined
16:27:59 <danharaj> Resonance cascade.
16:29:08 <dsilva> jejeje everything seems a little Rare
16:29:09 <dsilva> jejeje
16:29:33 <dsilva> But I won' t give up easily
16:29:33 <dainanaki> actually, nevermind, found the solution to my time problem
16:29:34 <dsilva> jejeje
16:31:03 <nyingen_> a sudden thunderstorm affected my network connection
16:32:20 <monochrom> heh, you need an UPS
16:32:41 <benmachine> and an uninterruptable network connection?
16:33:04 <nyingen_> I was logged in via a remote host, which went offline in the storm
16:33:21 <dsilva> huuuuuuuuuuuuuu
16:33:24 <dsilva> bad bad bad
16:33:25 <monochrom> the remote host needs an UPS then :)
16:33:26 <dsilva> so bad
16:33:27 <nyingen_> anyway what does "MUT time" refer to in the RTS report?
16:33:52 <dsilva> I think you need to be Sat Connection
16:34:26 <dsilva> Ho
16:34:38 <dsilva> you need to have a SAT connection
16:34:39 <dsilva> jejeje
16:38:31 <nyingen> this enumerator stuff works pretty well.
16:48:53 <dsilva> jejej
17:04:57 <mdgeorge> hello
17:06:02 <mdgeorge> is there something like C++ iterators in haskell that can express iteration over a variety of data structures using a  common interface?
17:06:31 <cmccann> that depends partly on what you mean by iteration
17:07:02 <mdgeorge> I'm trying to port a library from C++ that makes heavy use of iterators to specify ranges over which to apply operations
17:07:04 <copumpkin> you probably want iteratees
17:07:08 <copumpkin> but maybe not
17:07:13 <mdgeorge> what are those?
17:07:21 <cmccann> basically the answer is "yes, we have lots". but hard to say which kind you want in general
17:07:46 <copumpkin> mdgeorge: many things C++ uses iterators for, we use nothing for :P
17:07:54 <mdgeorge> yes, I understand
17:08:06 <copumpkin> so the specific use cases should probably be examined individually
17:08:07 <cmccann> mdgeorge, if you're just using pure functions all you probably need is folding over lists
17:08:25 <mdgeorge> well, I'm particularly interested in folding over lists, arrays, and subarrays
17:08:41 <cmccann> if you expect to accumulate side effects in IO or something like that over an existing list, there are similar functions
17:09:05 <mdgeorge> I'm mostly interested in the generic programming aspect of iterators
17:09:11 <cmccann> if you want to get the data you're iterating over using IO and accumulate with a pure function you'd do things another way, etc. etc.
17:09:42 <cmccann> ok well if you want generic then start here: http://hackage.haskell.org/package/recursion-schemes
17:09:48 * cmccann is (mostly) joking about that
17:10:25 <NihilistDandy> I don't think I can even *write* a program without some futumorphisms in it, anymore~
17:10:48 <cmccann> mdgeorge, anyway, the most generic version of this in the standard libraries is probably Traversable
17:10:54 <cmccann> http://hackage.haskell.org/packages/archive/base/4.3.1.0/doc/html/Data-Traversable.html
17:11:29 <mdgeorge> thanks cmccann, that looks like what I'm after
17:11:36 <cmccann> so that's probably a good place to start, then ask again if it doesn't do everything you need
17:11:58 <mdgeorge> I want to have a good handle on iterators before I try to figure out the right way to do circulators
17:12:09 <shachaf> Was Traversable the class that was equivalent to having a toList function?
17:12:26 <magicman> Also look at its cousin, Foldable. http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Foldable.html
17:12:45 <shachaf> Oh, I might've been thinking of Foldable.
17:13:00 <magicman> (which is the one that has toList. Foldable is required for Traversable, though)
17:13:42 <cmccann> yeah, Foldable lets you fold it, Traversable lets you spindle and mutilate as well
17:13:52 <copumpkin> I wouldn't say mutilate
17:13:58 <copumpkin> whatever you put in comes out in the same shape :)
17:15:17 <copumpkin> edwardk: thanks for the earbuds! my life is twice as good now
17:15:26 <copumpkin> I'll try to find you some replacements
17:16:33 <cmccann> copumpkin, for certain definitions of shape at least. sequence can mess with stuff quite a bit if it wants
17:16:59 <copumpkin> how?
17:17:16 <cmccann> trivial example, data K x a = K x, sequence :: [K x a] -> K x [a]
17:17:26 <mdgeorge> is it possible to use → in place of ->?
17:17:37 <copumpkin> mdgeorge: if you -XUnicodeSyntax
17:17:38 <cmccann> mdgeorge, I think that's allowed with unicode syntax enabled
17:17:42 <mdgeorge> thanks
17:19:13 <copumpkin> cmccann: oh, sure
17:19:32 <copumpkin> but any [a] left in it will be the same size as the thing being traversed
17:19:35 <copumpkin> if there is one :)
17:21:47 <dylukes> okay, I'd like to discuss this piece
17:21:47 <dylukes> https://gist.github.com/1090679
17:22:02 <dylukes> So, I get why the Haskell version memoizes,
17:22:22 <dylukes> but I feel like it might be a bit hackish or GHC-dependent?... is that behavior in the spec?
17:22:25 <cmccann> copumpkin, but anyway I was mostly abusing a figure of speech in the first place, so eh :P
17:22:31 <copumpkin> dylukes: no, it isn't a hack
17:22:38 <copumpkin> cmccann: ZOMG NOT ALLOWEd
17:22:44 <cmccann> D:
17:22:45 <dylukes> I mean, I can see why it works, but I'm wondering if it's a formalized thing.
17:22:58 <copumpkin> not sure if the spec actually says we're call-by-need
17:23:11 <dylukes> I mean, does the spec say that list will be the SAME list between calls?
17:23:26 <dylukes> Couldn't the implementation reasonable just create a new one for each call?
17:23:31 <dylukes> reasonably*
17:23:37 <shachaf> I thought the spec just said non-strict.
17:24:19 <dylukes> Basically, I'm wondering where that's defined as portable behavior.
17:24:40 <dylukes> It seems to me totally fine that the compiler could create a new list for each recursive call instead.
17:24:46 <dylukes> (though not as optimized/useful)
17:25:09 <dylukes> And, that seems to be the exact behavior going on in the F# version.
17:25:19 <cmccann> doesn't the Haskell report justify the monomorphism restriction as avoiding recomputation of expressions that look like they shouldn't need it?
17:25:25 <c_wraith> It's true that the Haskell spec doesn't specify any particular garbage collection/memoization policy
17:25:39 <cmccann> that seems to imply it expects that recomputation being avoided for a monomorphic value would be the default
17:25:48 <c_wraith> You could always re-calculate every expression, even named ones.
17:26:02 <c_wraith> But I think all practical implementations have approximately the same rules.
17:26:22 <dylukes> So, the only for-sure portable way to memoize is to use an IORef or STRef or something :\?
17:26:33 <dylukes> I happen to like this hehe.
17:26:35 <copumpkin> fuck portability
17:26:47 <dylukes> Anyways, the F# version seems to be doing exactly what I mentioned earlier.
17:26:49 <copumpkin> and all haskell implementations do call-by-need anyway
17:26:57 <dylukes> That one is *not* memoizing.
17:28:00 <copumpkin> ?
17:34:19 <dylukes> copumpkin: I know I can make it work using a mutable dictionary or such (CLI collection).
17:34:24 <dylukes> But I wanted to try to emulate the haskell one.
17:34:49 <dylukes> Seq's are lazily computed, initInfinite takes a function (int -> b') to generate each value.
17:40:04 <dylukes> I put a print statement in,
17:40:08 <dylukes> and it's DEFINITELY not memoizing.
17:51:32 <sm__> bummer.. haddock's --ignore-all-exports ignores the section headings in exports too
18:01:51 <edwardk> preflex: xseen cale
18:01:51 <preflex>  cale was last seen on freenode/#haskell 1 hour, 49 minutes and 27 seconds ago, saying: C# is boring. :P
18:15:45 <tgeeky> some of you guys are probably vim geeks. anyone know how to specify to vim that a section of comments should be rendered using a seperate syntax (say, markdown?)
18:17:14 <shachaf> tgeeky: #vim would probably know even more about vim than #haskell. :-)
18:17:27 <tgeeky> shachaf: yeah, but i'd have to register a username and I don't want to do that (yet)
18:17:43 <NihilistDandy> Because IRC usernames are set in stone O.o
18:17:58 <NihilistDandy> Laser-etched into self-repairing gold tablets
18:17:59 <tgeeky> you need to give them email addresses, and they wont let me use + to filter
18:18:03 <shachaf> You can have an IRC account associated with multiple usernames.
18:18:05 <shachaf> Oh.
18:18:20 <tgeeky> i hate giving out my flat email address :(
18:18:31 <NihilistDandy> Use a fake one
18:18:35 <tgeeky> anyway i guess i'll go through with it
18:18:37 <NihilistDandy> tgeeky@mailinator.com
18:18:46 <joe6> i am trying to use the Text.JSON library to read some json data. The data is very small. I am using decode to read the data into a JS structure. Should I be writing a function to walk through the json objects.
18:18:47 <tgeeky> where will that go? :O
18:18:52 <hpc> it needs email confirmation
18:18:56 <joe6> or is there a simpler method of reading the data.
18:19:04 <NihilistDandy> tgeeky: Go to mailinator.com
18:19:05 <hpc> set up a junk yahoo account or something
18:19:07 <NihilistDandy> Type in tgeeky
18:19:18 <NihilistDandy> It's a mailbox
18:19:26 <shachaf> tgeeky: You can probably take inspiration from lhaskell.vim.
18:19:31 <tgeeky> oh what do you know
18:19:33 <tgeeky> they support it now!
18:19:46 <NihilistDandy> hpc: You can do email confirmation with it
18:19:52 <shachaf> NihilistDandy: COme on, not mailinator.
18:20:02 <NihilistDandy> shachaf: The throwaway of all throwaways
18:20:04 <hpc> oh, neat
18:37:29 <tgeeky> if anyone wants to know, the answer to my question is 'no'
18:38:46 <shachaf> tgeeky: Really? I doubt that.
18:39:32 <shachaf> tgeeky: Oh, without writing your own syntax file. Why?
18:39:59 <tgeeky> i dunno. I suppose I'm taking one guy's word for it, but he said the best solution is to just switch filetypes
18:40:30 <tgeeky> i really want this to be a general thing (say, haskell with markdown comments, ruby with markdown comments, puppet with markdown comments)
19:05:11 <joe6> i get the feeling that I am doing something that has already been done: http://pastebin.com/8sXXFM2J, data: http://pastebin.com/wsuEgYW9
19:05:15 <mauke> The pastes 8sXXFM2J wsuEgYW9 have been copied to http://hpaste.org/49191 http://hpaste.org/49192
19:05:38 <joe6> i just want to read the json data as a haskell record/datatype without all the json syntax
19:06:02 <joe6> i would love to use functions as: readJSArray :: GetJSON JSValue
19:06:18 <joe6> but, I am not able to understand how to use GetJSON
19:06:27 <joe6> > :i GetJSON
19:06:28 <lambdabot>   <no location info>: parse error on input `:'
19:06:37 <joe6> > :i Text.JSON.GetJSON
19:06:38 <lambdabot>   <no location info>: parse error on input `:'
19:06:45 <joe6> > i Text.JSON.GetJSON
19:06:46 <lambdabot>   Not in scope: data constructor `Text.JSON.GetJSON'
19:07:13 <joe6> GetJSON : http://pastebin.com/d3Qjm5Rk
19:07:15 <mauke> The paste d3Qjm5Rk has been copied to http://hpaste.org/49193
19:07:20 <joe6> any thoughts, please ?
19:07:38 <joe6> the structure seems to be similar to parsec.
19:08:07 <joe6> but, I just cannot seem to get it working.
19:08:15 <joe6> Just a sample/direction should get me going.
19:20:26 <dylukes> Finally filling in my missing knowledge of fix.
19:20:29 <dylukes> Interesting ^^.
19:20:47 <dylukes> Somewhat weird that throwing in fix for a memoization function works...
19:20:56 <dylukes> I'm going to have to expand that by hand to see it, but its interesting.
19:21:00 <cmccann> what was missing in your knowledge of fix? I'm guessing it was knowledge of fix.
19:21:29 <djahandarie> dylukes, now learn about type-level fix (Mu), F-Algebras, and catamorphisms!
19:21:41 <shachaf> @ty \f -> (\x -> outR x x) (InR (\x -> f (outR x x)))
19:21:42 <lambdabot> forall a. (a -> a) -> a
19:21:52 <dylukes> catamorphisms I've already looked at bit :)
19:21:56 * shachaf wonders about a type-level Y combinator.
19:21:57 <dylukes> I'm planning on looking at Mu in a second.
19:22:06 <shachaf> Mu is just like fix.
19:22:10 <cmccann> I'm still pretty sure that most practical use for "fix" is telling lambdabot "fix error"
19:22:12 <shachaf> Mu f = f (Mu f)
19:22:30 <shachaf> cmccann: No, fix $ \loop -> do ...; when blah loop is useful.
19:22:35 <dylukes> Yeah, I've seen it before.
19:22:41 <dylukes> shachaf: what does that do >.>?
19:22:49 <shachaf> Exactly what it says.
19:22:53 <dylukes> I feel like fix is something I just need to use/see enough so it becomes more second nature.
19:23:00 <dylukes> Just like recursion back when I was 9.
19:23:02 <dylukes> >_>
19:23:11 <shachaf> let { loop = do ...; when blah loop } in loop
19:23:19 <cmccann> shachaf, eh, I usually direct recursion to be more readable than using fix
19:23:23 <cmccann> usually find, rather
19:23:29 <shachaf> cmccann: Right, but it's kind of ugly in that case.
19:23:36 <shachaf> Once you get used to the fix idiom it's nice.
19:23:43 <shachaf> dylukes: You don't understand recursion if you don't understand fix. :-)
19:23:57 <shachaf> (That's not completely true, I guess.)
19:24:00 <dylukes> shachaf: I understand fix!
19:24:04 <dylukes> I just don't QUICKLY>
19:24:09 <dylukes> :P
19:24:11 <cmccann> I also prefer to avoid doing recursion directly in a monadic expression anyway
19:24:32 <Philippa> Y actually makes a lot more sense if you write it out in equational style and compare to S and omega = S S...
19:24:49 <shachaf> cmccann: True; but I don't really know of a clearer way of doing that sort of loop in general.
19:25:07 <Philippa> does unfoldM exist?
19:25:19 <cmccann> btw, strictly speaking I think Y is a specific fixed-point combinator, not a general name for such insofar as that matters at all
19:25:21 <dylukes> what
19:25:24 <lispy> Philippa: I wrote it last time I needed it
19:25:26 <dylukes> Prelude> fix (\rec n -> if n == 0 then 1 else n * rec (n-1)) 5
19:25:33 <dylukes> "Here we have used fix to "encode" the factorial function: note that (if we regard fix as a language primitive) our second definition of fact doesn't involve recursion at all"
19:25:39 <Philippa> cmccann: yep, and was the one I was referring to
19:25:39 <dylukes> Yes it does. You're calling rec inside it .__.
19:25:40 <lispy> Philippa: I had some issues with getting the strictness to behave the way I wanted (my monad was IO)
19:25:48 <dylukes> oh wait, lambda.
19:25:52 <dylukes> thats not a function name.
19:25:54 <dylukes> durp.
19:25:55 <cmccann> in fact, strictly speaking I think Y is also a non-strict fixed point combinator, it diverges under strict evaluation
19:25:58 <shachaf> cmccann: Right, which is why I asked about the Y combinator specifically in the type system.
19:26:15 <cmccann> shachaf, in that case, you can't write fixed point combinators in Haskell
19:26:17 <Philippa> cmccann: yep, though there's a "strict Y" which is just a fairly obvious translation
19:26:21 <lispy> Philippa: I looked before I wrote it and asked here.  If you find anything I'd love to hear about it.
19:26:24 <cmccann> you can only use recursion provided by the language somehow
19:26:36 <Philippa> lispy: honestly, I should go sleep, anyway
19:26:43 <cmccann> Philippa, also true :]
19:27:47 <lispy> :)
19:27:55 <Philippa> cmccann: yeah, a type system that lets you write fix from scratch with the type (a -> a) -> a or something approximately equivalent is, uh, not your friend
19:28:18 <Philippa> (as opposed to one that's fine with it so long as you handle any termination proofs, that is)
19:28:21 <djahandarie> Unfortunately that includes (naive) recursive types
19:28:25 <cmccann> shachaf, also, as far as writing loops go I prefer to break them up in many cases and have a generic driver function and some recursive step functions, makes things easier to understand (to me at least)
19:28:26 <shachaf> cmccann: ?
19:28:48 <dylukes> What's meant by "open recursion"?
19:28:50 <shachaf> cmccann: You can write fixed-point combinators in Haskell, but you have to use recursion.
19:29:15 <Philippa> dylukes: consider this/self in OO, and how it interacts with mutation and inheritance
19:29:15 <djahandarie> shachaf, you don't have to use value-level recursion
19:29:20 <shachaf> djahandarie: Right.
19:29:25 <cmccann> shachaf, that's not really writing a fixed-point combinator in that case... it's just writing a combinator that includes a fixed-point combinator in it
19:29:35 <dylukes> Philippa: so, that the actual function called recursively is late-bound?
19:29:35 <djahandarie> Oh, you just wrote that thing up there, you clearly know already
19:29:39 <cmccann> even if only implicitly, by the translation of syntactic recursion
19:29:47 <dylukes> Does it mean "open" in terms of "possibly different"?
19:29:59 <shachaf> djahandarie: I was wondering if there could be some type-level equivalent.
19:30:21 <Philippa> dylukes: yeah, lets you change bits inside the fixpoint and have the recursion work how you want it to
19:30:43 <djahandarie> shachaf, you were wondering or you are still wondering?
19:31:07 <shachaf> Am, I suppose.
19:31:07 <Philippa> so eg if you've got a mutually recursive pair of functions f and g, swapping f with f' somewhere results in f' -> g -> f' -> ... instead of a single f' step followed by the same old same old
19:31:17 <Philippa> open recursion is really important
19:31:24 <Philippa> also, poorly supported in its own right
19:31:57 <dylukes> Could you show me an example, I guess?
19:32:16 <shachaf> Wasn't that an example?
19:32:30 <Philippa> pretty much. Put f and g in a record, call it an 'object'...
19:32:34 <djahandarie> shachaf, Mu IS a type-level fix
19:32:54 <shachaf> djahandarie: Right, but it's not a type-level Y combinator. It's defined recursively.
19:32:55 <Philippa> if I do a record update to replace f with f' normally, calling f' would get the pattern f' -> g -> f...
19:33:05 <Philippa> which isn't what I want
19:33:11 <Eduard_Munteanu> shachaf: neither is the value level 'fix' AFAIK
19:33:25 <Philippa> but with open recursion, ala OO, you get f' -> g -> f'
19:33:30 <Philippa> that is, g calls the /new/ f
19:33:36 <cmccann> shachaf, you can't write it directly on types for mostly the same reason you can't write it directly on terms
19:33:46 <Philippa> but that isn't necessarily "late-bound" as such
19:33:54 <dylukes> Philippa: okay, basically that's a side effect of using a method lookup table though.
19:33:57 <Philippa> the important thing is /re-/bound
19:34:14 <Eduard_Munteanu> Presumably Haskell's fix has similar semantics to the Y combinator, but it's not that one.
19:34:26 <Philippa> dylukes: nope, plenty of ways to encode open recursion
19:34:34 <Philippa> playing "replace fix" is a good one
19:34:40 <shachaf> cmccann: That's what I expected.
19:34:41 <dylukes> replace fix...
19:34:41 <dylukes> How would you do it in Haskell?
19:34:41 <dylukes> ?
19:34:45 <Philippa> (and one I've used in anger)
19:34:48 <dylukes> haha.
19:35:03 <Philippa> first, you write the recursive code you would write, using recursion-in-terms-of-fix
19:35:19 <Philippa> so you've got a record (because you're doing mutual recursion)...
19:35:38 <Philippa> or rather, a function that takes that record and spits itself out
19:35:56 <Philippa> well, instead of fix, you can use something that frigs with the record first, then delegates back to an actual fix
19:36:07 <Philippa> this lets you not just update the record, but change its type
19:36:14 <Philippa> so you could eg add new fields
19:36:31 <Philippa> I've done that for sharing rules in a family of typecheckers, for example
19:36:37 <Philippa> (though there wasn't actually a record)
19:38:14 <Philippa> anyway, I need bed. Someone else can figure out what I mean and puke it up in a pastebin somewhere :-)
19:40:27 <loupgaroublond> is there a better way to go from Data.Attoparsec.Number.Number to Data.Time.Clock.UTC.NominalDiffTime aside from 'fromInteger . toInteger' ?
19:41:14 <shachaf> @src fromIntegral
19:41:15 <lambdabot> fromIntegral = fromInteger . toInteger
19:41:55 <loupgaroublond> hehe, i guess that just makes it look nicer :)
19:42:00 <loupgaroublond> thanks
19:44:00 <loupgaroublond> oh, sorry, attoparsec's notion of a number isn't Integral
19:45:35 <applicative> hm no: data Number = I !Integer | D {-# UNPACK #-} !Double
19:58:49 <joe6> anyone knows how to use the Text.JSON?
19:59:05 <EvanR> joe6: ive used it
19:59:56 <joe6> EvanR. I am trying to use it and I bet I am doing something stupid. code: http://pastebin.com/wdXtbwAY
19:59:58 <mauke> The paste wdXtbwAY has been copied to http://hpaste.org/49195
19:59:59 <cmccann> shachaf, I take it back, you can actually write a type-level Y combinator in Haskell without using recursive newtypes
20:00:15 <dylukes> cmccann: ?
20:00:20 <dylukes> Did you actually write it?
20:00:23 <joe6> all the myRead.. functions should not be necessary. I should be able to use the read functions in the JSON library.
20:00:36 <joe6> but, i could not figure out the GetJSON
20:00:36 <shachaf> cmccann: How?
20:00:39 <joe6> and how to use it.
20:00:43 <joe6> any thoughts, please?
20:00:48 <cmccann> shachaf, shenanigans
20:00:53 * shachaf approves.
20:01:15 <EvanR> joe6: i would say decode the entire json data at once
20:01:20 <EvanR> with decode
20:01:26 <hpaste> “C. McCann” pasted “Shenanigans” at http://hpaste.org/49196
20:02:05 <cmccann> note that's the actual legit definition of Y
20:02:12 <cmccann> thanks to type metaprogramming being untyped
20:02:24 <joe6> i did that.
20:02:26 <cmccann> and abusing indirection to get general recursion in the evaluator function
20:02:31 <joe6> i used decode to get the Result
20:02:33 <EvanR> joe6: then you dont have strings anymore
20:02:34 <edwardk> cmccann: that is basically the evaluator that student i was mentioning was playing with last year
20:02:48 <joe6> yes, it is all JSObject.
20:02:59 <EvanR> joe6: runGetJSON :: GetJSON a -> String -> Either String a
20:03:01 <joe6> do you see the myRead.. functions at the end of the file.
20:03:02 <cmccann> edwardk, it's a pretty obvious encoding, I think Oleg did the equivalent with type classes forever ago
20:03:06 <EvanR> so you dont want GetJSON
20:03:10 <edwardk> yeah
20:03:13 <edwardk> back at icfp06
20:03:20 <joe6> EvanR, I want GetJSON,
20:03:26 <joe6> but I  could not figure out how to use it.
20:03:51 <joe6> do you have a quick sample using GetJSON?
20:04:01 <cmccann> er, with fundeps I mean, not just type classes, that was probably obvious though
20:04:02 <joe6> that I can read to understand.
20:04:04 <EvanR> i dont understand why you want to use GetJSON to decode
20:04:11 <EvanR> just use decode
20:04:16 <edwardk> yeah
20:04:16 <joe6> i have decoded the value
20:04:19 <cmccann> I seem to recall the fundep version being lazier though
20:04:24 <EvanR> then you don have strings anymore
20:04:33 <cmccann> in the sense of sending GHC into an infinite loop instead of getting a stack overflow
20:04:34 <EvanR> if you have JSValue, then youre done
20:04:50 <EvanR> or if dont want JSValue, then dont decode to JSValue
20:05:00 <EvanR> decode to some other type which is in class JSON
20:05:08 <joe6> EvanR: this is what I have after decode: http://pastebin.com/r8Gnt9TE
20:05:34 <EvanR> joe6: the paste you went to triggered out auto spam detection
20:05:39 <joe6> I want more than JSValue. The value held by JSValue
20:05:52 <cmccann> shachaf, so, did that satisfy you? ;P
20:06:03 * cmccann can't actually think of any other way to write a legit Y combinator in Haskell
20:06:08 <joe6> EvanR, i can see it.
20:06:20 <EvanR> joe6: i see the result, but i dont understand what the problem is. do you want different data ?
20:06:24 <cmccann> though this is cheating anyway, since it uses a layer of indirection
20:06:30 <EvanR> joe6: decode doesnt always produce that
20:06:32 <joe6> no, I want to read what is there
20:06:37 <joe6> oh, really.
20:06:44 <shachaf> cmccann: Can you use this in turn to write the value-level Y combinator?
20:07:07 <joe6> EvanR: this is how I am using decode: http://pastebin.com/qLik141H
20:07:09 <mauke> The paste qLik141H has been copied to http://hpaste.org/49197
20:07:18 <cmccann> shachaf, probably, just change the type family to a class and create an evaluator function that works in parallel
20:07:24 <joe6> as, the first line is a bad line.
20:07:39 <joe6> so, just dropping it. and then decode'ing the JSON.
20:07:44 <EvanR> joe6: if you have a tree of JSValues like above, then you can just use it. no need to 'read' it
20:07:47 <cmccann> I'm pretty sure any sort of type-level recursion can be used to introduce term-level recursion, possibly via a bit of trickery
20:08:12 * shachaf is kind of satisfied, then.
20:08:35 <EvanR> joe6: have you tried decode and encode in the ghci interpreter to get a feel for i
20:08:38 <EvanR> t
20:08:43 <joe6> EvanR, For example, http://pastebin.com/R5qzwbA0, I want to read the marketId out.
20:08:45 <mauke> The paste R5qzwbA0 has been copied to http://hpaste.org/49198
20:09:02 <joe6> i have the tree of JSValues.
20:09:14 <joe6>  but, How do I walk the tree and extract the value that I want.
20:09:26 <joe6> I was hoping that the read..'s are for that purpose.
20:09:30 <EvanR> joe6: in your last example, then you should either use lookup, or use a Map rather than JSObject
20:09:41 <cmccann> shachaf, technically this isn't really any different from implementing the combinator evaluator directly using regular data types
20:09:45 <EvanR> joe6: no. read stuff usually means parsing
20:10:06 <EvanR> not unparsing
20:10:12 <shachaf> cmccann: What do you mean?
20:10:53 <cmccann> shachaf, replace the combinator types with a single (recursive) data type representing an expression tree for combinatory logic, then run an evaluator
20:11:14 <cmccann> the type-level trickery just lets you avoid a directly-recursive type or whatnot
20:11:15 <joe6> EvanR, that is what I am struggling with. extracting the values. I am building an extractor for each JSValue type.
20:11:41 <joe6> EvanR, the last lines of this file: http://pastebin.com/zKN72HvM
20:11:44 <mauke> The paste zKN72HvM has been copied to http://hpaste.org/49199
20:12:03 <joe6> myReadJSString myReadJSArray
20:12:12 <joe6> those functions.
20:12:22 <cmccann> shachaf, on the other hand, if you wrote the combinators directly as functions, y would have an infinite type
20:12:27 <joe6> is there a simpler way than having to patternmatch every JSValue?
20:12:59 <EvanR> joe6: lets say the raw json is encoding your desired 'sane data' types, make your data types a class of type json. then decode will produce a list or data.map of those types, recursively
20:13:08 <EvanR> class JSON
20:13:11 <cmccann> which is also the same thing going on here, you just disguise that fact in the same way that the diverging term doesn't have an infinite lexical representation
20:13:29 <shachaf> cmccann: Right, but wasn't the point of that to avoid directly-recursive types? :-)
20:13:34 <EvanR> joe6: basically youre trying too hard ;)
20:13:56 <cmccann> shachaf, yeah, just saying that it's all a shell game in the end
20:13:56 <joe6> EvanR, that is what I am missing. and, which basically means I do not understand something simple.
20:14:07 <EvanR> joe6: thats the thing, its too simple
20:14:13 <EvanR> lol
20:14:39 <cmccann> > let s f g x = f x (g x) in s id id (s id id)
20:14:39 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
20:15:06 <joe6> EvanR, For example, I want http://pastebin.com/UxEQgqaP from http://pastebin.com/iKaEdhdM
20:15:09 <cmccann> writing indirect recursion gives you infinite type errors like that
20:15:09 <mauke> The paste UxEQgqaP has been copied to http://hpaste.org/49200
20:15:13 <EvanR> joe6: do you have some picture of what data you are trying to represent with json
20:15:16 <joe6> EvanR, how would you recommend I do that.
20:15:48 <cmccann> in my code, (Y :$> I :$> I) is also an infinite type, but disguised, and GHC dies trying to expand it
20:16:01 <EvanR> joe6: yeah, make runner an instance of JSON
20:16:22 <EvanR> then you can decode lists of Runner, and Runner as members of js objects
20:16:24 <EvanR> or maps
20:16:56 <joe6> EvanR, that is what I do not know how to do..
20:17:05 <EvanR> ok
20:17:07 <joe6> do you have a small sample lying around.
20:17:11 <EvanR> ill write it
20:17:15 <cmccann> I suspect you could defer enough of the instance resolution to sneak it past GHC and actually run a recursive function that way, but I'm not certain
20:17:15 <joe6> thanks a lot.
20:19:21 <cmccann> ok, hm, think I'm done rambling about recursion now :T
20:20:59 <joe6> EvanR, very sorry for the bother.
20:30:04 <EvanR> joe6: doing the verification manually is kind of tedious
20:30:23 <joe6> yes, i agree.
20:30:31 <EvanR> but i can show you how to use GetJSON, and then i will tell you to use Aeson ;)
20:30:45 <joe6> oh, there is Aeson?
20:32:19 <joe6> thanks, that would be great.
20:32:49 <EvanR> ok lets say you have json *text* that you want to convert to Runner OR error message
20:32:55 <EvanR> you can use GetJSON
20:33:25 <EvanR> actually you cant
20:33:59 <EvanR> the part where you verify that each member is decodable to the correct type must be done manually
20:34:07 <EvanR> in this case the three members
20:34:25 <EvanR> case member of
20:34:35 <EvanR>   JSNumber x -> Ok x
20:34:43 <EvanR>   _ -> Error "not a number"
20:35:04 * EvanR turns the page to Aeson
20:36:04 <EvanR> in Aeson there is something like readJSNull and friends but lets you declare 'member must exist and be decodeable to certain type
20:36:09 <EvanR> called .:
20:36:38 <EvanR> ill write the parser now and paste it
20:37:25 <joe6> EvanR, found this: uri: http://stackoverflow.com/questions/6566149/haskell-aeson-how-to-convert-value-into-custom-type
20:41:49 <EvanR> joe6: so here something http://codepad.org/vH7Q8TCd
20:42:39 <EvanR> youd use (runner <- parseRunner myObj) as part of a larger parser in this case
20:42:55 <joe6> ok, thanks a lot.
20:43:07 <joe6> let me try it.
20:43:26 <EvanR> and "xyz" probably wont work as is, since its [Char] and not Data.Text
20:43:39 <EvanR> and Aeson works on ByteString only
20:43:53 <EvanR> simple to translate though
20:44:05 <EvanR> or use polymorphic string literals
20:44:27 <joe6> EvanR, {-# LANGUAGE OverloadedStrings #-} ?
20:47:21 <EvanR> yes
20:47:42 <joe6> ok, thanks.
20:48:17 * EvanR looks for a way to sanely use this to simply decode a list of runners
20:48:56 <joe6> seen this error: http://pastebin.com/wp2UV8M8
20:48:58 <mauke> The paste wp2UV8M8 has been copied to http://hpaste.org/49201
20:49:34 <EvanR> joe6: yes, your normal libs are messed up
20:55:22 <_KY_> What is current best way to interface C# with haskell?
20:56:27 <EvanR> with tcp/id
20:56:29 <EvanR> tcp/ip
20:56:49 <luite> hmm, Phyx should know something about that, unfortunately he's currently pirating the caribbean
20:59:51 <ksf__> gobject?
21:00:27 <loupgaroublond> is there a way to get aeson's .: or .:? as an empty list?
21:00:49 <ksf> :t (.:)
21:00:50 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
21:02:20 <loupgaroublond> my workaround is to use Maybe [a], but that seems silly
21:02:52 <chenhl> hi
21:04:26 <ksf> loupgaroublond, Parser even gives you Either String [a]
21:04:38 <ksf> ...semantically, that is.
21:06:58 <loupgaroublond> Parser?
21:07:12 <ksf> ...the result type of .:
21:07:48 <loupgaroublond> i know, http://hackage.haskell.org/packages/archive/aeson/0.3.2.9/doc/html/Data-Aeson-Types.html seems to be missing from hackage
21:07:52 <loupgaroublond> :t Parser
21:07:53 <lambdabot> Not in scope: data constructor `Parser'
21:08:04 <loupgaroublond> :t Data.Aeson.Types.Parser
21:08:05 <lambdabot> Couldn't find qualified module.
21:08:20 <ksf> lambdabot doesn't import aeson
21:09:24 <loupgaroublond> oh
21:09:45 <joe6> @hoogle String -> ByteString
21:09:45 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
21:09:46 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
21:09:46 <lambdabot> Prelude read :: Read a => String -> a
21:11:58 <hpaste> loupgaroublond pasted “bad parser” at http://hpaste.org/49202
21:12:52 <ksf> null is not an empty list, is it?
21:13:59 <loupgaroublond> null is how couchdb represents an empty list
21:14:46 <loupgaroublond> this is what happens when you step into the impure world of '0 == false == []'
21:14:56 <ksf> if you just don't like json's semantics as they are used, do ClockIn a = ... ci_tags a, parse with ClockIn (Maybe [T.Text]) and then change it to ClockIn [T.Text] afterwards.
21:15:03 <ksf> do a type synonym and you're done.
21:15:25 <loupgaroublond> that might work
21:15:55 <loupgaroublond> thanks again
21:17:11 <ksf> then, of course, Parser is also a functor. so you could do (f <$> v .: T.pack "tags")
21:17:32 <ksf> where f :: Maybe [T.Text] -> [T.Text]
21:18:05 <loupgaroublond> that'd work even better
21:18:35 <loupgaroublond> gives me some interesting leeway to do something really stupid too like make "no list" be a string representation of an empty list :P
21:19:17 <ksf> while you're at it, you might want to write your own version of .: than does the packing.
21:20:19 <ksf> and you can use `div` instead of / and going via Rational
21:21:57 <joe6> EvanR, I am getting this error: http://pastebin.com/4jzPt0qq
21:21:59 <mauke> The paste 4jzPt0qq has been copied to http://hpaste.org/49203
21:22:48 <ksf> principially, I'd prefer to parametrize ClockIn as that's clean separation of outside and inside semantics, but then haskell doesn't really excel at messing with records.
21:23:20 <loupgaroublond> ksf, the latter won't work because of how Attoparsec defines it's Number
21:23:36 <ksf> joe6, unsafeCoerce!
21:23:37 <loupgaroublond> and i thought about parameterizing, but i'm prototyping something right now, so a few constraints make my life easier
21:24:45 <hpaste> loupgaroublond pasted “FromJSON UTCTime” at http://hpaste.org/49204
21:24:49 * ksf really wants a tightly integrated HList
21:24:54 <loupgaroublond> so i ended up with that
21:25:29 <loupgaroublond> i'm storing timestamps as milliseconds since the unix epoch
21:25:41 <aavogt> ksf: is anything really missing besides the terrible error messages with HList as-is?
21:26:01 <aavogt> err, I mean the error messages are terrible
21:26:05 <ksf> ew, no Integral.
21:26:37 <ksf> the whole type system integration smells of hack.
21:27:00 <ksf> that is, I don't want to be thinking about olegery when using records.
21:27:12 <ksf> performance is an issue, too.
21:27:47 <aavogt> well the implementation would be even worse if wasn't a linked list
21:27:51 <joe6> i am totally confused now with the json parser..
21:28:04 <joe6> need a break and will start tomorrow.
21:28:07 <aavogt> as far as being able to understand and write functions for it
21:28:28 <ksf> well, it could be linked records.
21:28:56 <ksf> automagically derived from how you slice your records etc.
21:29:54 <ksf> what I actually think is that we need proper support for TC-complete typelevel stuff, as well as hinting the compiler on how and what to infer, especially contexts.
21:30:33 <ksf> typefams being as powerful as fundeps would be a great start.
21:31:45 <ksf> and, especially for HList, proper support for type equality, that is, type instance (a ~ b) => a b = TTrue; type instance a b = TFalse
21:32:47 <ksf> ("proper support" including closed type families, so you can do fallthrough matching)
21:33:53 * hackagebot heroku 0.1 - helpers for deploying to Heroku  http://hackage.haskell.org/package/heroku-0.1 (GregWeber)
21:34:26 <ksf> haskell already is the best imperative language (at least as long as disciple didn't hit production, yet), so why not become the best OO language, too?
21:34:27 <luite> heroku!
21:34:55 <dolio> How about adding records to the type system in a way that isn't an enormous hack?
21:35:29 <luite> oh it only parses db urls
21:35:39 <ksf> I'm fine with records being a library, as long as the integration isn't hacky.
21:36:10 <ksf> then we can get *rid* of traditional record syntax, and it's lambdas all the way down, finally.
21:36:17 <dolio> I'm not.
21:36:24 <dolio> I don't want record labels to be types.
21:37:00 <ksf> disciple abuses (.) to mean type-directed field selection.
21:37:35 <cmccann> ksf, really, just skip the whole "type family" thing at that point and lift arbitrary terms to the type level
21:37:51 <cmccann> most type-level programming is kind of a horrible hack, even with "nice" stuff like type families
21:37:53 <ksf> that is, basically, (.) :: Record a => a -> Projection a b -> b
21:38:22 <ksf> err, projection'd be a typeclass, too.
21:38:46 <ksf> or, rather, multiple.
21:38:54 <ksf> hand-encoding that stuff is a bugger.
21:39:26 <ksf> what's so wrong with first-class lables?
21:40:05 <ksf> cmccann, I think the plan was to lower type-level stuff to the value level.
21:41:03 <cmccann> ksf, er, how's that?
21:42:16 <ksf> ...because the type level isn't necessarily TC.
21:42:28 <ksf> anyway, all I'm parroting is just uninformed rumour.
21:42:58 * cmccann is confused, probably missed something that was being discussed earlier :T
21:43:00 <cmccann> nevermind I guess
21:52:30 <applicative> joe6 I see I'm getting the same ugly error with libstc++ when Aeson needs it
21:54:46 <aperrien> hello again
21:55:39 <aperrien> Still learning haskell
21:56:29 <ksf> In contravariant functor, haskell learns you.
21:56:38 <aperrien> and I'm still learning the type system
21:56:48 <aperrien> I wash
21:57:18 <aperrien> self programming would be cool
21:57:31 <aperrien> I'm trying this construct
21:57:51 <aperrien> ( floor .sqrt ) 23
21:58:10 <ksf> > (floor . sqrt) 23
21:58:11 <cmccann> ksf, nah
21:58:12 <lambdabot>   4
21:58:17 <aperrien> it works on the command line, with a number
21:58:26 <cmccann> contravariant learning means that every time you learn something new, you find you know less afterwards
21:58:32 <ksf> :t (floor . sqrt) 23
21:58:33 <lambdabot> forall b. (Integral b) => b
21:58:37 <shachaf> aperrien: You probably want fromIntegral (or, better yet, integer square root).
21:58:46 <ksf> cmccann, exactly what haskell does to you.
21:58:55 <cmccann> ksf, :]
21:58:56 <shachaf> ksf has a point.
21:59:01 <applicative> aperrien: what answer do you want for ( floor .sqrt ) 23 ?
21:59:06 <aperrien> but if I use it as a function or a lambda I get a type error
21:59:23 <shachaf> @where dmr
21:59:23 <lambdabot> I know nothing about dmr.
21:59:34 <applicative> > let aperrien = ( floor .sqrt ) in aperrien 23
21:59:35 <lambdabot>   4
21:59:47 <shachaf> @where+ dmr http://www.haskell.org/haskellwiki/Monomorphism_restriction
21:59:47 <lambdabot> It is stored.
21:59:58 <shachaf> applicative: lambdabot has it disabled.
21:59:59 <ksf> my crystal ball says you want to use it as a float afterwards, but in haskell, sqrt returns an integral type.
22:00:05 <aperrien> I want to do this, really:
22:00:09 <ksf> err, floor.
22:00:19 <shachaf> Or there's what ksf says.
22:00:21 <aperrien> \(float . sqrt) n
22:00:42 <shachaf> It's part of Saneskell.
22:00:44 <shachaf> I mean Caleskell.
22:01:02 <aperrien> ksf: exactly!
22:01:17 <ksf> :t fromIntegral
22:01:18 <lambdabot> forall a b. (Integral a, Num b) => a -> b
22:01:20 <shachaf> @ty fromIntegral
22:01:21 <lambdabot> forall a b. (Integral a, Num b) => a -> b
22:01:25 <ksf> that's the magic function.
22:01:59 <ksf> but in reality, you most likely want to use an integer square root, as the float one will fail for bigger numbers.
22:02:09 <aperrien> ok
22:02:09 <applicative> @type sqrt
22:02:10 <lambdabot> forall a. (Floating a) => a -> a
22:02:22 <aperrien> and :t sqrt gives me sqrt :: Floating a => a -> a
22:02:46 <ksf> it *ought* to be in the standard libraries somewhere, but when it comes down to it, there's a fast integer sqrt somewhere in the haskell-cafe archives.
22:02:54 <aperrien> how do I get integer square root?
22:02:55 <ksf> :t floor
22:02:56 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
22:03:32 <applicative> what is the 'integer square root' of 23
22:03:55 <shachaf> \n -> head . dropWhile ((<n).(^2)) $ [1..]
22:04:38 <applicative> > let shachaf = \n -> head . dropWhile ((<n).(^2)) $ [1..] in shachaf 23
22:04:40 <lambdabot>   5
22:04:43 <ksf> oh. have a look at numeric-prelude.
22:05:01 <aperrien> So :t floor gives floor :: (RealFrac a, Integral b) => a -> b
22:05:09 <shachaf> applicative: Oh, it's both slow *and* wrong.
22:05:29 <ksf> http://hackage.haskell.org/packages/archive/numeric-prelude/0.2.2/doc/html/Number-FixedPoint.html#v:sqrt
22:05:30 <aperrien> is there a way to turn a Float to a RealFrac?
22:05:48 <applicative> @instances RealFrac
22:05:49 <lambdabot> Double, Float
22:06:01 <applicative> it already is a RealFrac
22:06:12 <shachaf> aperrien: You want integer square root anyway.
22:06:19 <aperrien> Why do I get the type error, ethen?
22:06:29 <aperrien> I'm dumb, must have missed it
22:06:38 <aperrien> If it's already been expolained
22:06:48 <aperrien> explained, even
22:06:51 <shachaf> Because of the DMR and/or lack of fromIntegral and/or concrete types somewhere.
22:07:13 <applicative> > map (floor.sqrt) [1..5]
22:07:14 <lambdabot>   [1,1,1,2,2]
22:07:27 <applicative> > map (floor.sqrt) [1..5::Integer]
22:07:28 <lambdabot>   No instance for (GHC.Real.RealFrac GHC.Integer.Type.Integer)
22:07:28 <lambdabot>    arising fro...
22:07:36 <applicative> there it is^^^?
22:07:55 <aperrien> I think that's it
22:07:59 <applicative> > map (floor.sqrt.fromIntegral) [1..5::Integer]
22:08:00 <lambdabot>   [1,1,1,2,2]
22:08:01 <aperrien> let me retype it
22:08:19 <ksf> oh, wait, I think what I was remembering was an integer log.
22:08:30 <ksf> ...so just take the numeric-prelude sqrt, there.
22:08:31 <applicative> you are feeding Ints or Integers to sqrt, but
22:08:36 <applicative> @type sqrt
22:08:37 <lambdabot> forall a. (Floating a) => a -> a
22:09:09 <ksf> > map (floor.sqrt.fromIntegral) [1..5::Integer]
22:09:11 <lambdabot>   [1,1,1,2,2]
22:09:49 <applicative> so you have to convert from an Integral type (Integer or Int) to a suitable Floating one (Double or Float)
22:10:54 <ksf> nah. if you want an integer sqrt, use an integer sqrt, not the float one.
22:10:56 * hackagebot iproute 1.2.1 - IP Routing Table  http://hackage.haskell.org/package/iproute-1.2.1 (KazuYamamoto)
22:11:13 <aperrien> is that what the double colon does?
22:11:18 <applicative> aperrien: so instead of (floor . sqrt) 23 you want (floor . sqrt . fromIntegral) 23  -- pay no attention to ksf
22:11:27 <shachaf> Pay no attention to applicative.
22:11:30 <sipa> aperrien: forces a type
22:11:31 <shachaf> What you want is integer sqrt.
22:11:33 <applicative> haha
22:11:45 <shachaf> You *also* want to understand the Haskell type system.
22:11:59 <applicative> aperrien wants the Prelude sqrt and to understand the number types and classes
22:12:03 <yitz> > let isqrt x = stable $ iterate (\y -> (y*y+y+x)`div`(2*y)) 2; stable(y:ys@(y':_))|y==y'=y|otherwise=stable ys in isqrt 11
22:12:05 <lambdabot>   3
22:12:09 <ksf> applicative, your sqrt isn't going to work for input greater than rougly 777!
22:12:18 <applicative> really?
22:12:21 <ksf> ...and probably give incorrect results even beforehand.
22:12:26 <ksf> yes. double is precision-limited.
22:12:38 <sipa> :t stable
22:12:39 <lambdabot> Not in scope: `stable'
22:12:43 <aperrien> I'm trying to lean the type system. What would you reccomend for a reference?
22:13:00 <ksf> LYAH.
22:13:04 <applicative> well, we have more than one point to make for aperrien, one about the number heirarchy, the other about sqrt ...
22:13:10 <applicative> @where LYAH
22:13:10 <lambdabot> http://www.learnyouahaskell.com/
22:13:19 <yitz> to use that for Int, use a value just less than sqrt maxBound as the initial value instead of 2.
22:13:20 <aperrien> learn the type system, even. my spelling sucks tonight
22:13:22 <shachaf> @where applicative
22:13:23 <lambdabot> http://darcs.haskell.org/packages/base/Control/Applicative.hs
22:13:36 <applicative> @where shachaf
22:13:36 <lambdabot> I know little about shachaf.
22:13:48 <shachaf> @where norway
22:13:54 <yitz> sipa: i defined stable myself inside the let expression
22:13:58 <ksf> @where coffee
22:13:59 <lambdabot> I know nothing about coffee.
22:14:02 <ksf> !!!
22:14:14 <ksf> @where+ coffee I drank it all
22:14:15 <lambdabot> Okay.
22:14:15 <shachaf> @vixen Did you just ignore my @where?
22:14:16 <lambdabot> yes, still here
22:14:19 <aperrien> I have LYAH, I'll look at the other one
22:14:26 <sipa> yitz: yeah, just noticed it :)]
22:14:32 <yitz> @google shachaf
22:14:35 <lambdabot> http://eteacherhebrew.com/Hebrew-Names/shahaf-shachaf
22:14:35 <lambdabot> Title: Shahaf (Shachaf) | Boy | Hebrew Names | Learn Hebrew with eTeacher
22:14:43 <shachaf> Ugh.
22:14:46 <shachaf> google--
22:14:50 <yitz> heh
22:15:14 * applicative suspected shachaf was a boy.
22:15:32 * shachaf suspected applicative was a functor.
22:16:14 <aperrien> Ok, thank you all! I really appreciate the help, things make more sense now
22:16:26 <codensity> somewhere there's a pictorial representation of the number heirarchy in Haskell
22:16:41 * shachaf would not want to look at that picture.
22:17:31 <aperrien> Or so I thought
22:18:52 <aperrien> I get : No instance for (Num [a0]) arising from the literal `5'  in  "map (\ n -> (floor . sqrt . fromIntegral) n) 5"
22:19:25 <codensity> now its because you gave it 5 not [5] or [5,6 ,7]
22:19:32 <yitz> @vixen pay no attention to that man behind the curtain
22:19:33 <lambdabot> i didn't think so
22:19:46 <aperrien> Ah, ok, I'm dum
22:20:01 <codensity> no, not at all.
22:20:16 <codensity> > map (\ n -> (floor . sqrt . fromIntegral) n) 5
22:20:17 <lambdabot>   No instance for (GHC.Num.Num [a])
22:20:18 <lambdabot>    arising from the literal `5' at <inter...
22:20:19 <codensity> bad
22:20:19 <aperrien> There's a lot to learn in this language
22:20:24 <codensity> > map (\ n -> (floor . sqrt . fromIntegral) n) [5]
22:20:25 <lambdabot>   [2]
22:20:37 <codensity> > (\ n -> (floor . sqrt . fromIntegral) n) 5
22:20:39 <lambdabot>   2
22:20:56 <codensity> the 'map' at the beginning meant it wanted a list.
22:21:06 <shachaf> > (\n -> (floor . sqrt . fromIntegral) . n) [5]
22:21:08 <lambdabot>   [2]
22:21:17 <codensity> @type map (\ n -> (floor . sqrt . fromIntegral) n)
22:21:18 <lambdabot> forall a b. (Integral b, Integral a) => [a] -> [b]
22:21:20 * aperrien misses his type coercion
22:21:39 <aperrien> Oh well, it's a crutch of a weak mind anyway
22:21:42 <codensity> you can 'coerce' or if you like inject with 'fromIntegral' and so forth
22:22:18 <yitz> aperrien: once you get used to your programs working as soon as they compile, you won't miss type coersion anymore
22:22:20 <shachaf> > unsafeCoerce 5 :: [Int]
22:22:21 <lambdabot>   Not in scope: `unsafeCoerce'
22:23:13 <aperrien> yitz: I know, it always takes a while to adjust to a new language though
22:23:15 <codensity> aperrien: the difference between sqrt and (map sqrt) is very beautiful, it might take a couple days
22:23:51 <aperrien> And I do look forward to being able to write proveably correct code
22:23:53 <yitz> aperrien: it takes a little longer to adjust to haskell if all you've used before are imperative languages
22:24:14 <codensity> the business about Integer vs Int and Double vs Float is not very pleasant, admittedly
22:25:31 <aperrien> That does descreibe me! C, C++, C# Pascal, VB, D, SQL... I used to know Lisp a long time ago, and I'm relearning FP now
22:26:05 * yitz is getting a headache from the continual mental effort of pronouncing "codensity" as "applicative"
22:26:21 <yitz> thanks
22:26:46 <shachaf> /nick codensity
22:27:02 <yitz> @hit shachaf
22:27:05 <lambdabot> No match for "shachaf".
22:27:22 <yitz> @list
22:27:22 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
22:28:05 <shachaf> @what shachaf
22:28:05 <lambdabot> I know little about shachaf.
22:28:14 <shachaf> Hmm, I'm surprised it doesn't consider that ambiguous.
22:28:17 <yitz> @slap shachaf
22:28:18 * lambdabot places her fist firmly on shachaf's jaw
22:28:40 <PatrickRobotham> lambdabot is a she?
22:28:44 <applicative> of course
22:28:51 <yitz> @vixen are you a she?
22:28:52 <lambdabot> yes, i am
22:28:59 <applicative> @vixen what about PatrickRobotham
22:29:00 <lambdabot> i dunno, what about?
22:29:02 <shachaf> I was talking about the matching algorithm.
22:29:14 <PatrickRobotham> applicative: No, I'm male.
22:29:44 <applicative> somehow i sensed that
22:29:47 * PatrickRobotham feels sexist now
22:30:09 <applicative> @vixen where are you from?
22:30:09 <lambdabot> Huntington Beach California
22:30:45 * applicative thought she was from "Moscow Russia"
22:30:53 <PatrickRobotham> so what's with the @vixen command?
22:31:10 <ksf> not only lambdabot is female, all haskell programs are.
22:31:12 <ksf> by definition.
22:31:27 <PatrickRobotham> ksf: I don't remember that in LYAH...
22:31:30 <ksf> which isn't strange at all, ships are female, too, after all.
22:31:43 <PatrickRobotham> Well I suppose haskell programs are things of beauty.
22:32:04 <shachaf> Not strange to a German speaker like ksf.
22:32:11 <aperrien> Thank you all and good night
22:32:29 <applicative> good luck aperrien!
22:33:03 <ksf> it's actually "das programm"
22:33:09 <ksf> but then, it's also "das schiff"
22:33:21 <shachaf> Fine. In Hebrew it's feminine.
22:33:42 <shachaf> (A program, I mean. Not a bot.)
22:34:05 <applicative> in English the noun has no gender, but one still uses 'she' from time to time; on what principle I dont know.
22:34:48 <Cale> applicative: Basically to sound like a French person.
22:34:55 <shachaf> > "principle" `isInfixOf` "English"
22:34:56 <lambdabot>   False
22:35:20 <Cale> (unless you're anthropomorphising something)
22:36:59 * hackagebot path-pieces 0.0.0 - Components of paths.  http://hackage.haskell.org/package/path-pieces-0.0.0 (MichaelSnoyman)
22:52:37 <travisyay> does anybody know how to compare contents of mVars?
22:52:53 <travisyay> like i want to see if the integer currently in one mVar is the negative of the other
22:53:32 <ksf> you read both, then compare.
22:53:58 <ksf> "currently" is of course a not entirely trivial concept when it comes to MVars
22:54:15 <travisyay> oh okay
22:54:22 <travisyay> but when im trying to read
22:54:42 <travisyay> i currently have a <- takeMVar valueToReceiveMVar
22:55:07 <travisyay> and the error is that there's no instance for Monad to Int
22:55:25 <ksf> cmpMVar a b = (==) <$> takeMVar a <*> takeMVar b
22:55:48 <c_wraith> travisyay: sounds like you're trying to make the return type of this an Int, when it should be an IO Int.  or the like
22:55:51 * ksf is part of the society to rescue applicative functors
22:56:11 <travisyay> ohh i see
22:56:31 <travisyay> <ksf>: can you explain the syntax? sorry im really new to this
22:56:39 <travisyay> ksf: ^
22:58:07 <ksf> the syntax part is easy, what requires a bit more thought are the types
22:58:11 <ksf> :t (<$>)
22:58:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:58:16 <ksf> :t (<*>)
22:58:17 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
22:59:13 <travisyay> thank you
22:59:16 <ksf> conceptually, those two together allow to use function application for stuff that isn't a vanilla function.
22:59:40 <ksf> :t \
22:59:41 <lambdabot> parse error (possibly incorrect indentation)
22:59:50 <ksf> :t \a b -> takeMVar a <*> takeMVar b
22:59:51 <lambdabot> Not in scope: `takeMVar'
22:59:51 <lambdabot> Not in scope: `takeMVar'
22:59:58 <ksf> argh.
23:00:00 <travisyay> lol
23:00:13 <travisyay> so you would put the <*> in the type?
23:00:26 <ksf> :t undefined :: IO a <*> undefined :: IO b
23:00:27 <lambdabot> parse error on input `::'
23:00:40 <ksf> :t (undefined :: IO a) <*> )undefined :: IO b)
23:00:41 <lambdabot> parse error on input `)'
23:00:46 <ksf> :t (undefined :: IO a) <*> (undefined :: IO b)
23:00:47 <lambdabot> forall b. IO b
23:01:02 <travisyay> woah
23:01:05 <ksf> uuuhhhh.
23:01:32 <c_wraith> I'm not sure how it got that answer
23:01:50 <travisyay> just wondering, do you any good tutorials for concurrent/parallel programming?
23:01:51 <ksf> :t (undefined :: IO (a -> b)) <*> (undefined :: IO a)
23:01:52 <copumpkin> I guess you need to ask yourself what does it mean to put a polymorphic annotation on something
23:01:52 <lambdabot> forall b. IO b
23:02:11 <copumpkin> with and without scoped type variables
23:02:21 <c_wraith> oh.  I see.  the b in the type it printed is not the same as the b in the annotation
23:02:21 * ksf once understood how <*> works. I don't do now, apparently.
23:02:30 <copumpkin> :t (undefined :: IO (a -> b)) <*> (undefined :: IO zomg)
23:02:31 <lambdabot> forall b. IO b
23:02:34 <copumpkin> ksf: you do
23:02:42 <copumpkin> it's type annotations you're misunderstanding :P
23:02:47 <ksf> fsvo "understand", maybe.
23:03:19 <azaq23> isn't just a instantiated to (a -> b), thus making it into (undefined :: IO (a -> b)) :: (undefined :: IO b)?
23:03:23 <Samuel> what is the best way to maintain large code in Haskell
23:03:23 <c_wraith> :t (undefined :: IO c) <*> (undefined :: IO d)
23:03:25 <lambdabot> forall b. IO b
23:03:26 <ksf> mentally, I'm somewhat stuck in f a -> f b -> f (a -> b)
23:03:31 <ksf> which is pure nonsense.
23:03:31 <Samuel> and is there a unit testing framework
23:03:33 <c_wraith> yeah
23:03:50 <copumpkin> ksf: it should be f (a ->b) -> f a -> f b
23:03:55 <ksf> exactly.
23:04:01 * hackagebot domain-auth 0.1.1 - Domain authentication library  http://hackage.haskell.org/package/domain-auth-0.1.1 (KazuYamamoto)
23:04:01 <copumpkin> the other way around would be really odd
23:04:22 <ksf> and the solution is... <$> binds tighter than <$>
23:04:30 <ksf> make the last one a *
23:04:40 <copumpkin> (f a -> f b) -> f (a -> b) might make a little more sense
23:05:21 <copumpkin> but that would basically require pointed and copointed, as far as I can tell
23:07:50 <Eduard_Munteanu> Samuel: maybe start by using a VCS?
23:08:36 <Samuel> VCS for what?
23:08:38 <ksf> vcs are for wuzzies not capable of incremental refactoring
23:08:55 <Eduard_Munteanu> Samuel: for your large codebase
23:09:14 <ksf> ...and organising patches over the internet.
23:09:47 <Eduard_Munteanu> ksf: so you're that old-fashioned? Like, you prefer patches in a .tar.gz? :)
23:10:33 <ksf> I just don't delete code before a replacement is in place.
23:10:33 <shachaf> Eduard_Munteanu: .patch.gz, surely?
23:10:46 <Eduard_Munteanu> shachaf: nope
23:11:03 <ksf> add somewhat regular backups to that.
23:11:04 <Eduard_Munteanu> shachaf: you still need to publish a set of patches
23:11:18 <Eduard_Munteanu> Without collapsing them into a single one.
23:11:58 <Samuel> is there a framework that help maintain that code, or we need to go back 10 years like ksf was recommending
23:12:15 <Samuel> :) joking
23:12:56 <Eduard_Munteanu> Samuel: Git?
23:13:11 <Eduard_Munteanu> For unit testing in Haskell, I'm not sure what to recommend though.
23:13:14 <ksf> darcs?
23:13:18 <_nickel> is the applicative `<*>` referred to as "apply" or just as the applicative infix opperator for application
23:13:22 <Eduard_Munteanu> Or Darcs.
23:13:34 <ksf> _nickel, it's actually "ap"
23:13:36 <ksf> :t ap
23:13:37 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
23:13:44 <ksf> ...just generalised for applicatives.
23:14:05 <_nickel> ksf: hmm thats how its referenced in the typeclassopedia as well
23:14:12 <_nickel> ksf: thanks!
23:14:13 <ksf> the typeclass hierarchy is messed up for hysterical raisins.
23:14:40 <_nickel> ksf: hysterical raisins -> historical reasons messed up?
23:15:17 * _nickel heads back to his hole
23:15:19 <_nickel> ksf: thanks again
23:16:16 <ksf> http://www.catb.org/jargon/html/H/hysterical-reasons.html
23:17:25 <Samuel> can we write classes in Haskell. Reason for asking I am trying to figure out how to create a finite state machine. Is this even possible? because state are immutable in Haskell so can change states
23:17:30 <Eduard_Munteanu> shachaf: like say... http://kernel.org/pub/linux/kernel/people/akpm/mm/broken-out-2007-01-28-00-31.tar.bz2
23:18:18 <shachaf> Eduard_Munteanu: That looks like a lot of patches.
23:18:21 <Eduard_Munteanu> TBH, I'm not really sure what became of Andrew's -mm tree recently
23:18:38 <Eduard_Munteanu> (migrated to Git?)
23:18:57 <ksf> Samuel, http://stackoverflow.com/questions/4980817/state-machine-pattern-in-haskell-infinite-type-error  gives a possible way.
23:19:42 <Eduard_Munteanu> Samuel: there might be stuff on Hackage to help you with manipulating a FSM
23:21:00 * ksf has a look at his own DFA code and realises it's not newbie-friendly.
23:21:05 <Eduard_Munteanu> Occasionally, the -mm tree was overloaded with new patches, so testing it became overly difficult. On Sep 17 2007, Andrew Morton sent a mail saying that "this just isn't working any more".
23:21:09 <Eduard_Munteanu> Today, the -mm tree is no longer being developed and has been superseded by the -next tree.
23:21:12 <Eduard_Munteanu> -- wikipedia quote
23:21:23 <ksf> ...using reify-graph.
23:22:09 <Eduard_Munteanu> Though I remember he wasn't the maintainer of that
23:23:30 <Eduard_Munteanu> *moves to blah*
23:36:49 <wvl_> Hi, I was reading some beginners haskell code and I was confused about the following: when you have a type constructor with type vars such as IO or [], the instances are often only declared with the type constructor itself like 'instance Monad [] where'. Is this partial application of type constructors or something else, since [] doesn't seem a full type to me?
23:37:40 <shachaf> wvl_: [] is a special case of syntax.
23:37:58 <shachaf> [a] really means "[] a", where "[] sometype" is a list of that type.
23:38:16 <shachaf> instance Monad [] is similar to instance Monad Maybe.
23:38:31 <shachaf> By the way, your introduction to type classes should probably not use Monad as an example. :-)
23:39:29 <wvl_> Well, it wasn't but this was a part where I got stuck because [] doesn't seem a 'complete' type to me.
23:40:23 <wvl_> I was expecting to see 'instance <class> <type> where' but this seems 'instance <class> <type constructor> where'.
23:40:32 <sipa> [] isn't a type
23:40:48 <sipa> ([] a) is
23:41:21 <shachaf> wvl_: Right, a class can have a type constructor as an instance.
23:41:32 <wvl_> Indeed that was why I got confused. That is allowed in instances or in any type declaration? And what does it mean exactly?
23:41:46 <shachaf> It means exactly what you'd expect. :-)
23:41:55 <shachaf> Look at Functor for a simpler example.
23:42:01 <sipa> [] is a type function, which maps types to the type of lists of it
23:42:09 <killerswan> so, does anyone know how `cabal test` is supposed to work?
23:42:21 <sipa> and [a] is syntactic sugar for ([] a), being [] applied to a
23:42:24 <shachaf> class Functor f where fmap :: (a -> b) -> f a -> f b
23:42:32 <shachaf> instance Functor [] where fmap = map
23:42:45 <shachaf> instance Functor Maybe where fmap f Nothing = Nothing; fmap f (Just x) = Just (f x)
23:43:23 <confab> it's starting to seem like everything is syntactic sugar for something else
23:43:29 <confab> is there ever an end to it?
23:43:30 <shachaf> You couldn't do that if an instance was only for concrete types.
23:43:49 <shachaf> confab: There's not *that* much sugar, really.
23:44:00 <shachaf> wvl_: It might be helpful to look at how type classes are implemented.
23:44:36 <wvl_> shachaf: So I assume that functions need concrete types? Or can I use this in functions too?
23:45:11 <shachaf> wvl_: That depends on what you mean.
23:45:17 <Eduard_Munteanu> Functions need to have concrete types.
23:45:49 <shachaf> You can certainly write a function :: forall f a. (f a -> a) -> f a -> a, or something like that. :-)
23:46:17 <Eduard_Munteanu> But  f a. (f a -> a) -> f a -> a    ::   *
23:46:31 <Eduard_Munteanu> It can't end up as something of kind * -> *
23:46:38 <confab> also, i thought [a] was sugar for a:[], or am i off there as well?
23:46:48 <shachaf> confab: It's different in the type level.
23:46:50 <sipa> confab: on the value level, yes
23:46:51 <c_wraith> confab: that's true at the value level, not at the type level
23:46:58 <confab> ah
23:47:01 <sipa> [] is a value and a type function
23:47:02 <confab> makes sense
23:47:06 <sipa> [a] is a value and a type
23:47:16 <shachaf> wvl_: You might want to use data List a = Nil | Cons a (List a) instead for figuring it out.
23:47:28 <Eduard_Munteanu> :t ()
23:47:30 <lambdabot> ()
23:47:32 <Eduard_Munteanu> :t []
23:47:33 <lambdabot> forall a. [a]
23:47:37 <sipa> :k []
23:47:38 <shachaf> :t {}
23:47:38 <lambdabot> * -> *
23:47:39 <lambdabot> parse error on input `{'
23:48:06 <wvl_> shachaf: well I suppose I mean if you have 'data Sometype a b = S a b' can you have a function 'f :: Int -> S Int'.
23:48:31 <wvl_> *Sometype Int
23:48:42 <Eduard_Munteanu> wvl_: nope
23:48:49 <frerich> Hrm, questions like http://stackoverflow.com/questions/6743093/composability-of-stl-algorithms make me wish there would be a nice trick to "embed" Haskell into C++.
23:49:25 <shachaf> wvl_: No, you can't do that. Every value needs to be of a concrete type.
23:49:26 <azaq23> wvl_: Sometype Int is not of kind *; it doesn't have any values
23:50:09 <Eduard_Munteanu> You can have   type Foo = Sometype Int    IIRC
23:50:48 <Eduard_Munteanu> in a way it's equivalent to     type Foo a  = Sometype Int a    but you still have to have values/functions as concrete stuff
23:50:50 <azaq23> Eduard_Munteanu: You're required to name type variables in a type decleration, so type Foo t = Sometype Int t
23:51:33 <Eduard_Munteanu> Ah, my bad. I remembered some form of partial application was allowed.
23:52:10 <wvl_> Ok I think I got the gist of it, I'll test some things later. Thanks everyone :)
23:52:44 <Eduard_Munteanu> Agda spoiled me :)
23:52:59 <olsner> Eduard_Munteanu: there might be an extension you can enable for that
23:53:12 <azaq23> Eduard_Munteanu: Hm, I just tested "type K = Maybe; f :: Maybe Int; f = Nothing" and it worked, so I'm wrong; I could have sworn I tested that already a few weeks ago and it didn't work
23:55:43 <frerich> Hm, is ghc able to apply loop fusion to a function 'map snd . filter (even . fst)', that is: the 'filter' function loops over more elements than 'map'?
