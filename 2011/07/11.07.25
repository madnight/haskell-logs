00:09:39 <EvilMachine> sorry for the many re-logins
00:09:53 <EvilMachine> had a problem with my irc client's connection
00:16:22 <EvilMachine> hey, what was the OT channel of #haskell again?
00:17:01 <ion> -blah
00:17:50 <EvilMachine> thanks. :)
00:18:10 <cwl> Int is not in class Fractional?
00:18:59 <shachaf> Nope.
00:19:57 <cwl> shachaf: ghci> 1 / 2  -- that is ok
00:20:10 <cwl> ghci> :t 1 -- that is Num
00:20:18 <shachaf> cwl: No, it's forall a. Num a => a
00:20:22 <ion> How would you define / or recip for Int?
00:20:44 <cwl> (/) :: Int -> Int -> Int
00:20:59 <coppro> That's a type signature, not a definition
00:21:32 <burbul> I want a type of computations which a) can interact with the system and b) can fail with string error messages . Is    EitherT String (IO a)     the right thing to use? [ First time I'm playing with monad transformers.]
00:22:21 <burbul> (EitherT doesn't seem to come with the HAskell platform, so I feel like I'm doing something wrong)
00:24:17 <cwl> (/) a b = if a < b then 0 else 1 + ((/) (a-b) b)
00:24:28 <EvilMachine> i would also like to know that. i'm still not fit with transformers. ("more than meets the eye!" ;)
00:24:48 <cwl> hmm... only suit for positive Int
00:24:50 <mauke> cwl: that's just div
00:25:13 <burbul> EvilMachine: it's the invisible lifting that I find a little confusing.
00:25:38 <ion> Control.Monad.Trans.Error has this example: type ErrorWithIO e a = ErrorT e IO a
00:25:48 <ion> http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-Error.html#g:4
00:26:00 <cwl> mauke: type of 1 is not Int right?
00:26:01 <burbul> Right -- I'll use ErrorT. thanks!
00:26:16 <mauke> cwl: depends
00:26:43 <cwl> mauke 1 / 2 is ok
00:27:07 <mauke> cwl: depends
00:27:11 <cwl> but one :: Int    one = 1             two::Int  two = 2           one / two failed
00:27:39 <ion> 1 :: Num a => a
00:27:43 <ion> 1/2 :: Fractional a => a
00:28:08 <cwl> does Fractional inherit from Num
00:28:16 <mauke> yes
00:28:32 <ion> See :i Fractional in ghci.
00:28:54 <cwl> where can I find more information about build-in type inheritance
00:29:09 <cwl> graph is better
00:29:13 <mauke> the library documentation
00:29:45 <EvilMachine> cwl, the haskell report has some kind of graph image for the basic types.
00:30:09 <ion> http://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1270011
00:30:52 <cwl> thanks
00:35:28 <cwl> var1 :: Num a => a          fun :: (Fractional a) => a -> a    Is (fun var1) legal?
00:35:34 <cwl> or depends
00:36:00 <mauke> try it
00:36:40 <coppro> cwl: also consider (%)
00:44:54 <mreh> :t (%)
00:44:55 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
00:45:09 <mreh> > 1  % 2
00:45:10 <lambdabot>   1 % 2
00:47:15 <ion> > 1 / 2 :: Rational
00:47:16 <lambdabot>   1 % 2
00:47:24 <burbul> @type (>>=)
00:47:25 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
00:48:46 <burbul> @pf chart_input x >>= filter_trans "foo"
00:48:46 <lambdabot> Maybe you meant: bf pl
00:48:48 <cwl> @type (%)
00:48:49 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
00:48:51 <burbul> @pl chart_input x >>= filter_trans "foo"
00:48:51 <lambdabot> filter_trans "foo" =<< chart_input x
00:49:05 <burbul> @pl \x -> chart_input x >>= filter_trans "foo"
00:49:05 <lambdabot> (filter_trans "foo" =<<) . chart_input
00:57:03 <ion> burbul: filterTrans "foo" <=< chartInput
00:58:03 <ion> :t \x -> ?foo =<< ?bar x
00:58:04 <lambdabot> forall a (m :: * -> *) b t. (?foo::a -> m b, ?bar::t -> m a, Monad m) => t -> m b
00:58:08 <ion> :t ?foo <=< ?bar
00:58:09 <lambdabot> forall b (m :: * -> *) c a. (?foo::b -> m c, ?bar::a -> m b, Monad m) => a -> m c
01:12:22 <cwl> is (->) a type?
01:12:31 <cwl> just like Int Double ...
01:12:54 <cwl> I have never seen a var has type (->)
01:13:25 <dibblego> no it is a type constructor
01:13:40 <dibblego> a binary type constructor specifically
01:14:06 <cwl> when will you use that?
01:14:15 <cwl> any examples?
01:14:25 <dibblego> instance Category (->) where ...
01:14:32 <dibblego> or partially-applied
01:14:40 <dibblego> instance Functor ((->) t) where ...
01:15:25 <cwl> hmm
01:15:50 <dibblego> it's also used full applied as in a type signature
01:15:51 <cwl> is it for function
01:15:55 <dibblego> like Int -> String
01:15:56 <dibblego> yes
01:16:05 <cwl> I see
01:16:08 <dibblego> @type reverse
01:16:09 <lambdabot> forall a. [a] -> [a]
01:16:20 <dibblego> "takes a list of a and returns a list of a"
01:16:37 <cwl> cool, it clear now
01:16:50 <dibblego> great
01:17:16 <sipa> cwl: you can see Int as a type constant, just as 0 is a value constant; you can see (->) as a type function that takes two types and returns the type of functions from one to the other
01:22:10 <ion> Maybe :: * -> * (a type constructor; a type level function of one parameter) Maybe Integer :: * (a type)
01:22:38 <sipa> indeed, those are "types of types", called kinds
01:22:39 <ion> (->) :: * -> * -> *, (->) Integer :: * -> *, Integer -> Integer :: *
01:24:31 <cwl> what does * stand for?
01:24:55 <sipa> cwl: * is any fully instanciated type
01:24:59 <opqdonut> all normal types are of kind *
01:25:01 <ion> An ordinary type
01:25:04 <sipa> i.e. a type of which values can be created
01:25:31 <sipa> Int, String, Int -> ([String] -> IO Bool) -> Maybe Double, ...
01:25:33 <sipa> are all *
01:26:06 <sipa> but Maybe, [], IO, (->), ... are not in *
01:26:08 <cwl> (->) takes any two parameters and return any fully instanciated type?
01:26:16 <sipa> cwl: exactly
01:26:42 <sipa> even more so: it takes 2 fully instanciated types, and returns a new fully instanciated type
01:27:06 <cwl> sipa: but (->) Integer String should ONLY return type (Integer -> String)
01:27:21 <sipa> and (Integer -> String) is in *
01:27:26 <ion> (->) Integer String is just another way to write Integer -> String
01:28:32 <cwl> sipa: is Integer in *?
01:28:44 <sipa> yes
01:28:54 <sipa> the question is just: can you create a value of that type
01:29:00 <sipa> :t (5 :: Integer)
01:29:01 <lambdabot> Integer
01:29:14 <cwl> sipa: can I write fun :: Integer -> Integer as fun :: Integer -> *?
01:29:20 <sipa> no
01:29:26 <ion> Not anymore than you can write 5 + Integer
01:29:28 <sipa> cwl: * is the type of the type
01:29:33 <sipa> it is not a type itself
01:30:55 <cwl> so (->) Integer Integer :: (Integer -> Integer) cannot be wrote as (->) Integer Integer :: *
01:31:13 <sipa> :: means "is of type"
01:31:39 <sipa> (->) Integer Integer :: (Integer -> Integer)
01:31:41 <sipa> is meaningless
01:32:17 <sipa> you can say "5 :: Integer", or "id :: Integer -> Integer" or "(+5) :: (->) Integer Integer"
01:32:17 <cwl> can I write fun :: Integer -> Integer as fun :: *
01:32:23 <sipa> no
01:32:40 <sipa> * is not a type, you cannot use it in places where a type is expected
01:32:47 <sipa> it is a property of a type
01:32:56 <sipa> just like a type itself is a property of a value
01:33:33 <cwl> when will * be used
01:33:47 <ion> :k Maybe
01:33:48 <lambdabot> * -> *
01:34:03 <cwl> I can only see * in ghci error message
01:34:39 <sipa> cwl: unless you're using some specific extensions to the haskell language, you won't ever write those kinds yourself
01:35:27 <cwl> sipa: I see, learn it latter
01:36:00 <sipa> cwl: but it is useful to reason about
01:36:08 <sipa> do you know monad transformers?
01:36:18 <cwl> sipa: not yet
01:36:37 <cwl> sipa: I read realworldhaskell
01:36:39 <sipa> ok
01:36:43 <cwl> chapter 4 now
01:36:57 <cwl> still a long way to go >_<
01:37:37 <cwl> do you know any famous program written in Haskell?
01:38:04 <Clint> pandoc, hledger
01:38:33 <Ptival> GHC?
01:38:38 <earthy> cwl: xmonad
01:38:54 <Ke> darcs
01:41:17 <ion> Btw, what extension makes :t print kind signatures, like this?
01:41:19 <ion> :t (.)
01:41:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:41:57 <Ptival> with the explicit forall?
01:42:25 <ion> Tried -XExplicitForall -XKindSignatures, that wasn’t it.
01:42:31 <mreh> Haskelloids
01:43:46 <Ptival> -XExplicitFor*A*ll ?
01:44:05 <ion> yes
01:44:36 <mreh> -XNoUnkindSignatures?
01:44:56 * earthy points to Ptival's capitalization
01:46:56 * mreh ducks
01:47:17 <earthy> ofcourse, that still doesn't seem to work with 6.12.3
02:00:25 <ion> -fglasgow-exts at least turns it on.
02:05:10 * hackagebot HaXml 1.22.2 - Utilities for manipulating XML documents  http://hackage.haskell.org/package/HaXml-1.22.2 (MalcolmWallace)
02:21:04 <earthy> ion: not in ghc 6.12.3 :)
02:58:11 <ion> It’s -fprint-explicit-foralls, btw. Not a -XSomething.
02:58:34 <ion> A ghci-specific flag.
02:59:10 <ion> @quote
02:59:11 <lambdabot> ben_m says: "perl -MTime::HiRes=sleep -e '$|++; for(1..30) { print "\r8" . "=" x $_ . "D"; sleep 0.2 }'"
03:12:44 * hackagebot collada-types 0.3 - Data exchange between graphic applications  http://hackage.haskell.org/package/collada-types-0.3 (TillmannVogt)
03:13:44 * hackagebot collada-output 0.6 - Generate animated 3d objects in COLLADA  http://hackage.haskell.org/package/collada-output-0.6 (TillmannVogt)
03:14:45 * hackagebot triangulation 0.3 - triangulation of polygons  http://hackage.haskell.org/package/triangulation-0.3 (TillmannVogt)
03:14:47 * hackagebot tga 0.2 - Reading and writing of tga image files  http://hackage.haskell.org/package/tga-0.2 (TillmannVogt)
03:16:46 * hackagebot SVGPath 1.1 - Parsing the path command of SVG  http://hackage.haskell.org/package/SVGPath-1.1 (TillmannVogt)
03:16:48 * hackagebot SVGFonts 1.0 - Fonts from the SVG-Font format  http://hackage.haskell.org/package/SVGFonts-1.0 (TillmannVogt)
03:38:46 <Ptival> ion: thanks :)
03:58:14 * hackagebot syb 0.3.3 - Scrap Your Boilerplate  http://hackage.haskell.org/package/syb-0.3.3 (JosePedroMagalhaes)
04:00:31 <Guest42788> can any one tell me whats the practical use of this languaga
04:00:49 <Guest42788> chinalo help
04:01:20 <styx_> hi guys! Can someone suggest me a vim plugin which can handle indents automatically? I tried out googles results, but found nothing working. i want for example my guards to be aligned
04:01:37 <Ke> you can use haskell to make your computer do repetitive tasks that you do not wan't to do yourself
04:02:25 <Ke> app-vim/haskellindent http://www.vim.org/scripts/script.php?script_id=1968
04:02:38 <mreh> i'm gonna try that
04:03:16 <styx_> Ke are you using this plugin?
04:03:21 <Ke> yes
04:03:31 <Ke> it's not perfect5, but then nothing is
04:03:47 <styx_> and it works like i expect it?
04:04:05 <Ke> I have no idea about your expectations
04:06:09 <styx_> Guards for example should look like in test2 not like test1
04:06:11 <styx_> http://paste.pocoo.org/show/445953/
04:06:27 <styx_> and they should be aligned automatically
04:07:44 <styx_> when i press enter after " = x " my cursor should be in a new line under "|"
04:09:32 <styx_> is this what your plugin does Ke?
04:11:16 <Ke> hmm it is somewhat syntax aware obviously, but it's not mine and I don't remember the details
04:11:20 <Ke> try it out
04:15:40 <styx_> Ke the plugin produces something like that: http://paste.pocoo.org/show/445956/
04:16:04 <Ke> yup
04:16:24 <styx_> why does it not align to the first guard?
04:17:21 <Ke> heh, no idea
04:17:26 * hackagebot instant-generics 0.3.3 - Generic programming library with a sum of products view  http://hackage.haskell.org/package/instant-generics-0.3.3 (JosePedroMagalhaes)
04:21:38 <aninhumer> Hmm is there a better way to write code working with a tree structure that depends on depth than recursing with a depth accumulator?
04:25:01 <Peaker> aninhumer: in what way does it depend on depth?
04:27:31 <aninhumer> I'm implementing the DHT algorithm described here: http://www.bittorrent.org/beps/bep_0005.html
04:27:46 <aninhumer> The bucket structure more specifically
04:28:59 <aninhumer> The dependence on depth is that when a bucket is split, the nodes are distributed depending on their ID and the depth in the tree
04:30:46 <aninhumer> I'm actually thinking now that just putting the depth in the tree structure might be easier, given that's likely only a few dozen ints
04:32:18 <aninhumer> But I'm still interested in whether there's an idiom for recursion which passes an accumulator
04:34:33 <earthy> scanl ?
04:35:33 * hackagebot simple-firewire 0.1.3.3 - Simplified interface for firewire cameras  http://hackage.haskell.org/package/simple-firewire-0.1.3.3 (VilleTirronen)
04:37:19 <hatty> Hello. I'm looking for the GHC and the standard library sources. Where is the repository? I can find GHC but the tar ball doesn't include the libraries, and I can't find a VCS repository at all. Whenever I look I just get told to use the haskell platform, but that's not useful if I want to read the source.
04:38:47 <Botje> hatty: http://hackage.haskell.org/trac/ghc/wiki/Building
04:38:50 <Botje> will this help?
04:39:43 <aninhumer> hatty: Also, there are source links in the docs if you just want to read source for specific functions
04:39:46 <Botje> of course, disconnected already
04:40:31 <earthy> hatty: the 'base' package is at http://hackage.haskell.org/package/base
04:40:42 <earthy> including darcs link. :)
04:41:09 <aninhumer> earthy: they left already :/
04:41:48 <earthy> aninhumer: but, what you want seems like it might be possible using the mapAccum functions in Data.Traversable
04:47:39 <johnbenson> hi - i'm reading the docs on control.concurrent, and it says that GHC doesn't create os threads. does this mean that a concurrent haskell program only runs on one cpu? what about multicores?
04:48:05 <earthy> johnbenson: GHC has a N:M threading implementation
04:48:19 <earthy> where N haskell threads are multiplexed over M OS threads
04:48:40 <johnbenson> ok great
04:49:44 <johnbenson> the latest docs don't say that tho - "the downside of having lightweight threads is that only one can run at a time", and it says that it only uses os threads if you're using safe foreign calls
04:50:57 <quicksilver> johnbenson: there are two runtimes.
04:51:06 <quicksilver> johnbenson: which docs are you reading? can you paste the URL?
04:51:08 <earthy> johnbenson: read http://hackage.haskell.org/packages/archive/base/4.3.1.0/doc/html/Control-Concurrent.html#g:8
04:51:15 <johnbenson> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
04:51:27 <johnbenson> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html#g:9
04:52:16 <quicksilver> johnbenson: the sentence you quoted has important context in the following sentences
04:52:39 <earthy> most importantly: 'The runtime maintains a pool of these worker threads so that multiple Haskell threads can be involved in external calls simultaneously.'
04:52:58 <johnbenson> ok, but i'm not using any foreign calls, but i still want to use more than one core
04:52:59 <quicksilver> well that still suggests it's only used for foreign calls
04:53:13 <earthy> and 'The runtime will run a Haskell thread using any of the available worker OS threads.'
04:53:33 <quicksilver> still I agree the docs are confusing.
04:53:56 <quicksilver> johnbenson: GHC uses N:M threading, where the number of true threads created is determined by the RTS option -N
04:54:04 <quicksilver> s/created/running at once/
04:54:12 <quicksilver> (more will be created, for foreign calls)
04:54:14 <earthy> the docs could be clearer, agreed
04:54:31 <quicksilver> in very recent GHCs the option defaults to the number of hardware cores it believes you have
04:54:35 <quicksilver> I think.
04:54:38 <quicksilver> or hardware 'execution units'
04:54:53 <quicksilver> you do still need -threaded to get any of this though.
04:55:08 <mreh> did they fix the n-1 threads bug
04:55:14 <mreh> if that ever was a bug
04:57:08 <earthy> see also http://www.haskell.org/ghc/docs/7.0-latest/html/users_guide/using-smp.html
04:58:37 <rtharper> anyone else using Lion and getting a ton of ld errors from GHC?
04:58:50 <rtharper> saw a tticket about it already
04:58:55 <rtharper> doesn't seem to affect anything...
05:01:27 <mercury^> Why is --threaded not the default by now?
05:02:27 <Botje> it slows down a bit for unicore stuff
05:02:54 <mercury^> Yes, but very marginally, I would believe.
05:03:44 <quicksilver> I don't if there is a specific reason it's not the default
05:04:40 <earthy> hasn't it been mostly bugfree and stable only since the release 7.0.1?
05:05:08 <earthy> ISTR there were issues in the threaded runtime with regards to GC performance
05:14:08 <paczesiowa> dcoutts: regarding our last week talk about tar: I wrote my own unpack (with mkdir -p and chmod +x) ( https://github.com/Paczesiowa/virthualenv/commit/f2d2db1596197bf438a2da54024f5e77ceb3f714#diff-1 ) and the only thing that seems not working are paths longer than 100 chars - they are truncated to 100 chars, which is not enough to install ghc
05:15:22 <dcoutts> paczesiowa: be with you in a mo, but check you're using the right thing, the old tar format was limited to 100, but the new standard allows up to 255 and the tar lib supports that
05:15:49 <shu22> is ghc the official haskell implementation? haskell.org seems to be a front to this project, rather than generic haskell, and a lot of the packages in hackage.haskell.org seem to be tied to GHC.
05:16:27 <dcoutts> shu22: there is no official impl. There is however a de facto standard implementation, and that is GHC.
05:17:41 <paczesiowa> dcoutts: I'm only writing unpack function, I don't touch the format field, maybe ghc tarballs use the wrong one (they still work with gnu tar)? htar has the same problem (on archives created with gnu tar)
05:18:09 <dcoutts> paczesiowa: oh, that's odd then
05:19:36 <dcoutts> paczesiowa: you can take a look at the TarPath code, you'll see what I mean about the 100+155 thing
05:19:44 <dcoutts> in Codec/Archive/Tar/Entry.hs
05:25:53 <paczesiowa> dcoutts: toTarPath and fromTarPath seem to work ok with paths >100 chars, maybe there's something wrong with reading code
05:26:31 <flux> have you noticed that the tar header has only 100 bytes available for the file name?
05:26:50 <dcoutts> flux: it's got 100+155 available
05:27:03 <flux> oh, right, didn't spot the optional prefix part
05:48:17 * hackagebot BiobaseXNA 0.5.0.0 - Efficient RNA/DNA representations  http://hackage.haskell.org/package/BiobaseXNA-0.5.0.0 (ChristianHoener)
05:48:39 <gubbo> cusa l'è
06:04:23 * hackagebot BiobaseInfernal 0.5.0.0 - Infernal data structures and tools  http://hackage.haskell.org/package/BiobaseInfernal-0.5.0.0 (ChristianHoener)
06:10:55 <nda> @pl \x y -> f (g x) y
06:10:55 <lambdabot> f . g
06:14:03 <nda> @pl \x y -> h (f (g x) y)
06:14:03 <lambdabot> (h .) . f . g
06:21:12 <paczesiowa> dcoutts: it seems that gnu tar creates entries, where the whole path (>100) is stored in 'name' and the 'prefix' is empty
06:35:45 <eddayyy> hmmm.. haskell platform is failing to compile at cabal-install linking
06:35:52 <eddayyy> anyone have any idea why this could happen?
06:43:40 <Egbert9e9> how do i avoid very long one-liners?
06:43:51 <Egbert9e9> all those piped monads
06:44:19 <Egbert9e9> x . y =<< z $ =<< =<< =<<
06:44:47 <Nimatek> Egbert9e9: do - notation?
06:45:49 <Egbert9e9> uhm.. maybe i do need to use do more often
06:46:29 <paczesiowa> dcoutts: ok, I think I finally get it, ghc tarballs are in posix format, they store truncated paths (compatible with ustar), and in a separate place full filepaths
06:47:18 <ski> Egbert9e9 : you could also try `(<=<)' or `(>=>)'
06:47:19 <Egbert9e9> if i want to "replicate" some action inside "do"
06:47:32 <ski> @type replicateM
06:47:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
06:47:32 <Egbert9e9> how do i do that?
06:48:11 <Egbert9e9> uhm
06:49:50 <ski> either `replicateM' is what you want, or you'll have to elaborate more on what you want exactly
06:53:18 <Egbert9e9> randList range = do { sg <- newStdGen; return $ randomRs range sg }
06:53:21 <Egbert9e9> that's one
06:53:36 <eddayyy> cabal-install build fails to link, any help?
06:53:53 <eddayyy> confusing because it builds correctly, but fails on the linking stage
06:54:26 <Egbert9e9> at some point i do "replicateM n $ randList ('a', 'z')"
06:55:21 <Saizan> eddayyy: do you get any errors?
06:55:23 <paczesiowa> eddayyy: what's the error?
06:55:46 <Egbert9e9> then i map take on the list
06:55:47 <eddayyy> cabal-install: Build failure
06:55:55 <eddayyy> one sec i'll rebuild and see
06:56:46 <Egbert9e9> any other way i can make random strings of certain range(s) of characters of a specific length?
06:57:00 <eddayyy> hmm now happy is failing to build
06:57:29 <Egbert9e9> maybe i'm trying to itch my left ear with my right hand
06:59:23 <ski> @type \n -> runState (replicateM n (state random))  -- Egbert9e9 ?
06:59:24 <lambdabot> forall s a. (Random a, RandomGen s) => Int -> s -> ([a], s)
07:00:07 <Egbert9e9> uh.. let me seeee
07:01:19 <ski> if you want to, you could probably take the global `StdGen', feed it into that, and put back the resulting one in the global
07:01:32 <Egbert9e9> woah. there are several runState's
07:02:23 <Egbert9e9> ski: global? how do you have global values?
07:03:14 <ski> @type getStdGen
07:03:14 <lambdabot> IO StdGen
07:03:17 <ski> @type newStdGen
07:03:18 <lambdabot> IO StdGen
07:03:21 <ski> @type setStdGen
07:03:22 <lambdabot> StdGen -> IO ()
07:03:31 <ski> @type getStdRandom
07:03:32 <lambdabot> forall a. (StdGen -> (a, StdGen)) -> IO a
07:06:15 <mreh> who writes a book called "x, the good parts"
07:06:38 <nda> @pl \x y -> f ( g (h x) (i y))
07:06:38 <lambdabot> (f .) . (. i) . g . h
07:06:41 <ski> @type \n -> getStdRandom (runState (replicateM 2 (state random)))  -- Egbert9e9
07:06:42 <lambdabot> forall t a. (Random a) => t -> IO [a]
07:07:00 <ski> @type getStdRandom . runState
07:07:01 <lambdabot> forall a. State StdGen a -> IO a
07:07:22 <Egbert9e9> which runState should i choose? strict, right?
07:07:25 <ion> It would be nice if something like @random replicateM 5 (state random) worked as a lambdabot command for randomness.
07:08:01 <mreh> she only evaluates right?
07:08:11 <mreh> > putStrLn "Hello"
07:08:12 <lambdabot>   <IO ()>
07:08:15 <mreh> yurs
07:08:29 <ski> Egbert9e9 : which monad library are you using ? do you have link to documentation ?
07:08:56 <Egbert9e9> i've just "import Control.Monad"
07:09:24 <ski> ion : so accepting things of type `State StdGen a' alt. `Reader StdGen a' ?
07:10:05 <ski> Egbert9e9 : i see no `runState' in <http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.3.1.0/Control-Monad.html>
07:10:08 <ion> ski: Yeah, State StdGen a, and print the result value in the end.
07:10:33 <mokus> evalState (replicateM 5 (state random)) (mkStdGen 42) :: [Int]
07:10:35 <eddayyy> arrrrg
07:10:36 <ski> ion : for `Reader StdGen a', it could use `newStdGen' instead of `getStdRandom'
07:10:38 <eddayyy> Error:
07:10:38 <eddayyy> Building the cabal-install-0.10.2 package failed
07:10:38 <eddayyy> make: *** [build.stamp] Error 2
07:10:48 <mokus> > evalState (replicateM 5 (state random)) (mkStdGen 42) :: [Int]
07:10:49 <lambdabot>   [-3907187990116499535,-2519438828217931933,-8264534369199619667,86887135830...
07:11:45 <Eduard_Munteanu> @random
07:11:45 <lambdabot> Unknown command, try @list
07:12:13 <mreh> @roll
07:12:14 <lambdabot> Plugin `tell' failed with: Prelude.head: empty list
07:12:15 <Eduard_Munteanu> Well you could compose lambdabot commands if @random existed
07:12:27 <ski> > (evalState . replicateM 16 . state . randomR) (-9,9) (mkStdGen 1234)
07:12:28 <lambdabot>   [8,-5,-3,5,4,-2,2,9,-6,1,5,-1,-5,-3,-5,1]
07:12:38 <mreh> haha
07:12:42 <Eduard_Munteanu> Ah, wait that works already.
07:12:54 <mreh> i feel a let coming along
07:13:14 <ski> @die 0d6
07:13:14 <lambdabot> 0d6 => 0
07:13:38 <mreh> > intercalate " " cake
07:13:40 <lambdabot>   "One 18.25 ounce package chocolate cake mix. One can prepared coconut pecan...
07:13:46 <sipa>  cake
07:13:48 <sipa> > cake
07:13:50 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
07:14:56 <mreh> > length cake
07:14:57 <lambdabot>   42
07:15:02 <ion> Perhaps be as generic as possible and have @random \gen -> whatever, in which the @random command applies the code to the result value of newStdGen.
07:15:59 <mreh> :t mkStdGen
07:16:00 <lambdabot> Int -> StdGen
07:16:06 <mreh> :t state
07:16:07 <lambdabot> forall s a. (s -> (a, s)) -> State s a
07:17:13 <mokus> > last cake
07:17:15 <lambdabot>   "That will deodorize and preserve putrid tissue."
07:17:49 <Egbert9e9> ski: if i run hoogle "runState" it throws out a bunch of modules
07:18:02 <ski> @hoogle runState
07:18:05 <lambdabot> Control.Monad.State.Lazy runState :: State s a -> s -> (a, s)
07:18:07 <lambdabot> Control.Monad.State.Strict runState :: State s a -> s -> (a, s)
07:18:09 <lambdabot> Control.Monad.State.Lazy runStateT :: StateT s m a -> s -> m (a, s)
07:18:28 <Egbert9e9> oh, it's StateT
07:18:37 <Eduard_Munteanu> I think Control.Monad.State brings in the lazy one
07:18:41 <Egbert9e9> -_-
07:19:21 <Eduard_Munteanu> @index runState
07:19:22 <lambdabot> Control.Monad.State, Control.Monad.RWS
07:19:29 <linduxed> why does http://paste.pocoo.org/show/446057/ get a InteractWith.hs:23:22: parse error on input `='
07:20:21 <quicksilver> linduxed: 'myFunction =' is not a valid statement inside a do-block
07:20:23 <nda> \x y -> g (h x) (i y)
07:20:36 <nda> @pl \x y -> g (h x) (i y)
07:20:36 <lambdabot> (. i) . g . h
07:20:37 <quicksilver> linduxed: it is presumably your intention it be part of the enclosing 'where' clause
07:20:57 <mreh> Control.Monad.State is lazy
07:21:18 <Botje> @pl \(x,y) -> g (h x) (i y)
07:21:19 <lambdabot> uncurry ((. i) . g . h)
07:21:28 <Botje> hmm. no arrow combinators? boo
07:24:38 <linduxed> quicksilver: hmm, yes, it was one level too high
07:26:17 <ski> Eduard_Munteanu : hm yes, the docs/source seems to say that
07:26:31 <nda> @pl \x y -> f (g (h x) y)
07:26:31 <lambdabot> (f .) . g . h
07:26:33 * ski had forgotten that `State' also had lazy/strict variants
07:27:09 <ski> Egbert9e9 : the `Lazy' one, i.e. plain `Control.Monad.State' should probably be fine, i think
07:30:43 * frerich thinks a partially-applied (.) invocation like "(f .)" is confusing as hell
07:31:01 <frerich> Is there a trick to remember how it works or than carefully dissecting it in my mind?
07:31:05 <fazzone> Better yet, ((f .) .)
07:31:53 <fazzone> If you think it's confusing, then why not just avoid it?
07:32:04 <fazzone> (I think it's rather arcane as well)
07:32:13 <Eduard_Munteanu> :t ((.) (.))
07:32:14 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
07:32:31 <Eduard_Munteanu> Better yet, boobs ^ :P
07:32:52 <ski> nda,frerich,fazzone : `(f .) . g . h' is `f .: g . h'
07:33:57 <Peaker> frerich: SECs
07:34:09 <Peaker> The best way to remember how the boobs operator works is with SECs
07:34:09 <nda> thanks, this i knew, but i would like to find some useful abbreviation for (. f) in this context
07:34:15 <Peaker> @where SEC
07:34:15 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
07:39:33 <mreh> did anyone else snigger at SECs?
07:40:13 <Peaker> I thought it was a good pun at the time :)
07:40:58 <dcoutts> paczesiowa: how/where are they storing the extended path info?
07:41:18 <dcoutts> paczesiowa: I thought we had support for the gnu tar format
07:45:23 <parcs> is it possible to convert a bytestring to a Ptr Word8?
07:45:31 <dcoutts> parcs: yes
07:45:39 <dcoutts> check the docs
07:45:54 <dcoutts> look for CString
07:46:39 <c_wraith> is CString a Ptr Word8?
07:46:57 <dcoutts> no, it's a Ptr CChar
07:47:10 <c_wraith> ah, but a quick castPtr fixes that. >_>
07:48:22 <linduxed> is there an opposite of null?
07:48:28 <linduxed> as in the function
07:48:38 <dcoutts> not . null
07:48:38 <parcs> awesome :)
07:48:40 <linduxed> or should i just use not on the output of null
07:48:49 <linduxed> dcoutts: ok that's what i thought
07:49:47 <quicksilver> isJust . listToMaybe !
07:53:36 <parcs> (> 0) . length for maximal efficiency
07:54:20 <benmachine> it's a fair question, inasmuch as there *is* a notElem
07:54:40 <benmachine> but there isn't a notNull
07:54:43 <quicksilver> yes
07:55:09 <quicksilver> and it's not 100% clear that not . null would optimise to the same code as you'd want
07:55:12 <quicksilver> maybe it does, though.
07:55:33 <ski> @type notElem
07:55:34 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
07:58:39 <Eduard_Munteanu> @src length
07:58:39 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
07:58:54 <nda> @pl \x y -> h (f x y) (g x y)
07:58:54 <lambdabot> ap (ap . (h .) . f) g
07:59:21 <ski> @let repeatMT :: Monad m => StateT sr m a -> ReaderT sr m [a]; repeatMT (StateT smas) = ReaderT loop where loop s = do (a,s) <- smas s; liftM (a:) (loop s) in repeatMT
07:59:22 <lambdabot>   Parse error: in
07:59:25 <ski> @let repeatMT :: Monad m => StateT sr m a -> ReaderT sr m [a]; repeatMT (StateT smas) = ReaderT loop where loop s = do (a,s) <- smas s; liftM (a:) (loop s)
07:59:26 <lambdabot>  Defined.
07:59:41 <Eduard_Munteanu> > (> 0) . length $ [1..]
07:59:45 <lambdabot>   mueval-core: Time limit exceeded
08:00:39 <Eduard_Munteanu> If it's implemented in terms of 1 + length xs, then it's not lazy enough
08:01:08 <quicksilver> Eduard_Munteanu: how else could you implement it?
08:01:12 <Wild_Cat> Eduard_Munteanu: how else would you implement it?
08:01:19 <Eduard_Munteanu> Maybe succ is lazier?
08:01:20 <quicksilver> however you need a lazy (>) to take advantage of it
08:01:27 <ski> `length xs + 1' .. maybe ?
08:01:40 <quicksilver> and Int/Integer don't have a lazy (>)
08:02:49 <Eduard_Munteanu> Hm, indeed.
08:03:25 <linduxed> let's say that i've got a two or more strings, how do i join them into a list of strings?
08:03:43 <Eduard_Munteanu> > let length [] = 0; length (_:xs) = succ (length xs) in (> 0) . length $ [1..]
08:03:45 <lambdabot>   *Exception: stack overflow
08:04:04 <Eduard_Munteanu> So I suppose it's (> 0) at fault now.
08:04:04 <benmachine> linduxed: huh? you've got two or more strings, isn't that already a list of strings?
08:04:07 <quicksilver> linduxed: [a,b] ?
08:04:07 <linduxed> like having "foo", "bar" and "tez" and turn them into ["foo","bar","tez"]
08:04:18 <benmachine> oh
08:04:20 <benmachine> erm
08:04:22 <Wild_Cat> Eduard_Munteanu: you need an integer, not a thunk, to compare to 0.
08:04:24 <benmachine> writing them like that?
08:04:25 <quicksilver> linduxed: the same way as you'd turn two or more ints into a list of ints
08:04:32 <quicksilver> linduxed: or two or more rabbits into a list of rabbits
08:04:42 <quicksilver> using [,,,,] notation or the (:) operator.
08:04:43 <linduxed> (:) ?
08:04:47 <Eduard_Munteanu> Yeah, it'd need a lazy integer anyway
08:04:54 <ski> > ["foo","bar","tez"]
08:04:54 <lambdabot>   ["foo","bar","tez"]
08:04:56 <Eduard_Munteanu> Or Peanos.
08:05:02 <ski> > "foo" : "bar" : "tez" : []
08:05:02 <lambdabot>   ["foo","bar","tez"]
08:05:17 <Wild_Cat> Eduard_Munteanu: even then, lazy integers aren't really feasible. What guarantee is there that somewhere down the line of computation you don't start substracting like crazy?
08:05:17 <linduxed> hmmmm
08:05:43 <linduxed> then in that case it was as i thought... it must be that i messed up my code somewhere else
08:06:03 <Eduard_Munteanu> Wild_Cat: well if they're defined inductively you just look at the head constructor
08:06:17 <ski> Wild_Cat : you could take the pushout of `Natural' with itself, e.g.
08:07:15 <ski> Wild_Cat : `data Integer = Zero | One_Plus Natural | MinusOne_Minus Natural'
08:08:15 <Wild_Cat> ski: yeah, but then what do you make of One_Plus One_Plus MinusOne_Minus MinusOne_Minus Zero ?
08:08:30 <Eduard_Munteanu> > let length [] = Nothing; length (_:xs) = Just $ length xs; gtz (Just _) = True; gtz _ = False in gtz . length $ [1..]
08:08:31 <lambdabot>   Occurs check: cannot construct the infinite type:
08:08:32 <lambdabot>    a = Data.Maybe.Maybe a
08:08:45 <Wild_Cat> at some point you have to normalize it to be able to do comparisons, and you're screwed into evaluating it entirely.
08:08:49 <Eduard_Munteanu> Grr.
08:08:51 <nda> @pl \x -> (f x, g x)
08:08:51 <lambdabot> liftM2 (,) f g
08:09:31 <ski> Wild_Cat : well, in some cases, you know whether you're talking about non-negative integers or non-positive integers
08:09:51 <Eduard_Munteanu> Yeah, my attempt to go around lambdabot's limitations didn't work :)
08:09:54 <ion> :t \x -> (f x, g x)
08:09:54 <benmachine> Wild_Cat: hold on, that's not an integer
08:09:55 <lambdabot> forall t t1 t2. (SimpleReflect.FromExpr (t -> t1), SimpleReflect.FromExpr (t -> t2)) => t -> (t1, t2)
08:09:58 <Wild_Cat> not in the general case, though.
08:10:01 <ski> Wild_Cat : e.g. when taking an integer to index a bi-directional stream
08:10:02 <ion> :t \f g x -> (f x, g x)
08:10:02 <Eduard_Munteanu> But anyway, inductive naturals would do
08:10:03 <lambdabot> forall t t1 t2. (t -> t1) -> (t -> t2) -> t -> (t1, t2)
08:10:07 <benmachine> Wild_Cat: notice that the Integer type ski made is *not* recursive
08:10:24 <Wild_Cat> benmachine: I assumed it was a typo... Was it not?
08:10:25 <ion> :t \f g x -> (f &&& g) x
08:10:26 <lambdabot> forall b c c'. (b -> c) -> (b -> c') -> b -> (c, c')
08:10:32 <ski> Wild_Cat : it was not a typo :)
08:10:39 <Eduard_Munteanu> ski: I think that's how Agda defines them too
08:10:55 <Eduard_Munteanu> *Agda's stdlib
08:10:58 <benmachine> Wild_Cat: I'm assuming you have data Natural = One | Succ Natural; data Integer = Zero | Plus Natural | Minus Natural
08:11:01 <benmachine> something like that
08:11:39 <Wild_Cat> benmachine: sure, but to make them useful to our case you need to define + on them.
08:11:46 <linduxed> ok this is inexplicable to me.... in this paste http://paste.pocoo.org/show/446091/ i get told that InteractWith.hs:28:52:  Couldn't match expected type `Char' with actual type `[Char]'
08:11:59 <benmachine> Wild_Cat: you can do that!
08:12:15 <benmachine> you get limited laziness
08:12:17 <Wild_Cat> benmachine: yeah, and then how do you check whether the result of such an addition is positive or negative?
08:12:18 <linduxed> this makes absolutely no sense to me since i even went to the length of forcing emptyHead to be String -> String
08:12:40 <benmachine> Wild_Cat: hmm.
08:12:42 <Eduard_Munteanu> Isn't there an alternate Prelude with lazy Nums already?
08:12:46 <Wild_Cat> benmachine: the entire point of the exercise is to check whether a list's length is >0, remember ;)
08:13:15 <ski> Wild_Cat : well, just using (a lazy) `Natural' is enough for that
08:13:17 <benmachine> shouldn't length have return type Natural anyways
08:13:18 <Wild_Cat> (by calling length l, where length returns the integer type I maintain can't be lazy enough to work on [1..])
08:13:24 <Wild_Cat> ski: ^
08:13:42 <Eduard_Munteanu> Wild_Cat: you'd choose which arg you substract from, by some convention, I suppose
08:13:49 <benmachine> 'length' ends up being roughly 'map (const ())' :P
08:14:01 <Wild_Cat> it's about lazy length computation
08:14:24 <benmachine> Eduard_Munteanu: you'd have to fully evaluate at least one of the arguments to give a result
08:14:29 <Eduard_Munteanu> Yes.
08:14:43 <Wild_Cat> although hasMoreThan :: Integer -> [a] -> Bool would be trivial to implement
08:14:45 <ski> Wild_Cat : `length [] = IZero; length (_:as) = One_Plus (loop as) where loop [] = Zero; loop (_:as) = Succ (loop as)'
08:16:32 <linduxed> could someone tell my why it would expect Char there, even though it's neither getting Char, nor (according to me but apparently not the interpreter) expecting it
08:16:33 <Wild_Cat> ski: mmh. Extremely partial use case, I guess. You get semi-lazy ordering, where (<) requires fully evaluating one of the operands
08:16:36 <Wild_Cat> (but not both)
08:17:28 <ski> i don't see that
08:18:25 <Wild_Cat> ski: well, consider (a < b). How would you implement a version that doesn't require fully evaluating at least one of a and b?
08:19:20 <Wild_Cat> I'm not good at Haskell yet, so there's a good chance there's something obvious I'm overlooking -- me, I'd have gone with hadMoreThan 0 :p
08:19:34 <PatrickRobotham> Wild_Cat: (
08:19:48 <PatrickRobotham> Wild_Cat: Here's a lazy-ish version of  <
08:19:48 <Wild_Cat> what?
08:20:16 <Eduard_Munteanu> You wouldn't compare two infinite numbers anyway
08:20:20 <ski>   MinusOne_Minus _ < IZero = True
08:20:27 <ski>   MinusOne_Minus _ < One_Plus _ = True
08:20:31 <ski>   IZero < One_Plus _ = True
08:20:39 <ski>   MinusOne_Minus m < MinusOne_Minus n = n < m
08:20:45 <ski>   One_Plus m < One_Plus n = m < n
08:20:47 <ski>   _ < _ = False
08:20:58 <Wild_Cat> ski: good point, I forgot about the case where you compare two numbers of opposing signs.
08:21:17 <PatrickRobotham> Wild_Cat: (<) _   Zero       = False
08:21:18 <PatrickRobotham>                  (<) Zero (Succ y) = True
08:21:20 <PatrickRobotham>                  (<) (Succ x) (Succ y) = x < y
08:21:24 <PatrickRobotham> Oh, we're doing integers ;(
08:21:24 <ski> in this representation, whether the number is negative, zero, or positive is "strict"
08:21:28 <ski> the rest is lazy
08:21:35 <fazzone> linduxed: You can't cons (:) a list onto a list, you can only cons a value onto a list
08:21:37 <c_wraith> > (-0.0) < (0.)
08:21:38 <lambdabot>   No instance for (GHC.Real.Fractional (f b))
08:21:38 <lambdabot>    arising from the literal `0....
08:21:53 <c_wraith> > (-(0.0)) < (0.)
08:21:54 <lambdabot>   No instance for (GHC.Real.Fractional (f b))
08:21:54 <lambdabot>    arising from the literal `0....
08:21:54 <Wild_Cat> ski: well, comparing two non-zeros of same sign still requires the full evaluation of the one with the smallest absolute value.
08:21:58 <c_wraith> > (-(0.0)) < (0.0)
08:21:59 <lambdabot>   False
08:22:04 <benmachine> c_wraith: (0.) is being parsed as (0 .)
08:22:09 <benmachine> i.e a section on dot
08:22:14 <c_wraith> benmachine: I didn't even see that I'd typo'd that.
08:22:18 <fazzone> linduxed: line 27, change the : to a ++
08:22:38 <c_wraith> > maxBound :: Double
08:22:39 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Double)
08:22:39 <lambdabot>    arising from a use o...
08:22:46 <c_wraith> hmm.  not bounded.  interesting.
08:22:57 <ski> Wild_Cat : yes, just as for lazy `Natural's
08:23:54 <linduxed> fazzone: but won't that concatenate the strings? i want to keep them as separate list objects
08:24:20 <fazzone> :t (:)
08:24:21 <lambdabot> forall a. a -> [a] -> [a]
08:24:35 <fazzone> linduxed: you need to make the second parameter to (:) a list-of-lists then
08:24:35 <ski> linduxed : `map emptyHead inLines' is a *list* of strings
08:25:02 <quicksilver> linduxed: [map emptyHead inLines,transpose (map tail inLines)] would be another option
08:25:03 <ski> linduxed : so that will concatenat the list with another list, it's not concatenating the strings in the list, though
08:25:09 <quicksilver> if you really do want it to be a list of two elements
08:25:26 <ski> quicksilver : which would be a list of list of strings :)
08:25:27 <fazzone> Oh, hold on, I think I'm reading this wrong
08:25:34 <quicksilver> ski: right.
08:26:06 <quicksilver> ski: Im' not entirely clear what linduxed wants but I'm hoping that by outlining some different options I might find out :)
08:26:10 <ski> so,yes `concat [map emptyHead inLines,transpose (map tail inLines)]' would also work
08:26:37 <ski> linduxed wants to generate a list of strings
08:26:41 <linduxed> quicksilver: well the end result should be transposing a text file
08:27:05 <quicksilver> oh that's a recursive invocation of transpose
08:27:11 <quicksilver> I read it as the standard function transpose
08:27:59 <ski> linduxed : interesting layout inside `main', there :)
08:28:16 <ski> (conceptually i mean, not syntactically)
08:28:50 <linduxed> ski: dude, it's just a copypaste from the realworldhaskell tutorial
08:29:06 <ski> ok
08:29:09 <linduxed> ski: only things i've written are myFunction and emptyHead
08:29:24 <linduxed> oh and the commented out function, but that was just a test
08:30:38 <fazzone> linduxed: fmap (transpose . lines) getContents >>= mapM_ putStrLn   -- is this what's going on?
08:31:43 <ski> linduxed : you may (or may not) like to define `onLines :: ([String] -> [String]) -> (String -> String); onLines f = unlines . f . lines' and `perLine :: (String -> String) -> (String -> String); perLine = onLines . map'
08:32:25 <ski> linduxed : that way you could say `myFunction = onLines transpose' respectively `{- myFunction = perLine (head . words) -}'
08:33:23 <ski> (i borrowed those functions from conal's <http://www.haskell.org/haskellwiki/TV#IO>)
08:33:57 <nda> @pl \x (f,g) -> h (f x) (g x)
08:33:57 <lambdabot> (`ap` snd) . (. fst) . ap (flip . (((.) . h) .) . flip id) (flip id)
08:34:31 <nda> @pl \(f,g) x -> h (f x) (g x)
08:34:31 <lambdabot> uncurry (liftM2 h)
08:35:14 <ski> nda : `\(f,g) -> uncurry h . (f &&& g)', for the latter one
08:36:27 <nda> thanks
08:46:34 <paczesiowa> dcoutts: after some more research, these files are in gnu tar format, but they use LongLink extensions
08:59:39 * hackagebot HsOpenSSL 0.10 - (Incomplete) OpenSSL binding for Haskell  http://hackage.haskell.org/package/HsOpenSSL-0.10 (MasatakeDaimon)
09:05:57 <nda> @pl \x -> f x (g x)
09:05:57 <lambdabot> ap f g
09:18:04 * sm__ meant *C-x b*
09:18:08 <sm__> oh lord
09:37:36 <parcs> is there a function interleave :: [[a]] -> [a] where interleave [[1,2,3],[4,5,6]] == [1,4,2,5,3,6]
09:37:46 <parcs> hmmm wait
09:38:09 <parcs> > concat . transpose $ [[1,2,3],[4,5,6]]
09:38:10 <lambdabot>   [1,4,2,5,3,6]
09:38:50 <djahandarie> > join . ala ZipList Data.Traversable.foldMap $ [[1,2,3],[4,5,6]]
09:38:51 <lambdabot>   Not in scope: `Data.Traversable.foldMap'
09:38:57 <djahandarie> > join . ala ZipList Data.Foldable.foldMap $ [[1,2,3],[4,5,6]]
09:38:58 <lambdabot>   No instances for (GHC.Num.Num [a],
09:38:58 <lambdabot>                    Data.Monoid.Monoid (C...
09:39:33 <identity_> :t ala
09:39:37 <identity_> what is this magic
09:39:38 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
09:39:40 <identity_> ah
09:39:48 <djahandarie> > join . ala ZipList Data.Traversable.traverse $ [[1,2,3],[4,5,6]]
09:39:50 <lambdabot>   [1,4,2,5,3,6]
09:39:59 * djahandarie is obviously not having a good day
09:40:20 <ptd> djahandarie: concat . transpose is easier to read
09:40:51 <mercury^> :t ala
09:40:51 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
09:40:54 <identity_> djahandarie: I don't know if it's obvious. My day's success does't depend on my ability to tell lambdabot to run haskell code :P
09:40:57 <mercury^> What is that?
09:41:04 <djahandarie> @package newtype
09:41:05 <lambdabot> http://hackage.haskell.org/package/newtype
09:41:09 <djahandarie> From there ^^
09:41:11 <identity_> mercury^: Oblivion. Avert your eyes :|
09:43:58 <djahandarie> In case you want to see how a simple ala expression reduces: http://hpaste.org/46677
09:45:02 <ptd> djahandarie: I rarely get lambdabot code (or any haskell) to run first time.
09:45:43 <djahandarie> Well, the reason I'm having a bad day is because I've done this before many times, I just can't think straight right now :p
09:45:53 <mercury^> djahandarie: that example is a bit boring. Would one of the examples given at the beginning of the package description be much more difficult?
09:45:53 * djahandarie was at a concert for like 12 hrs yesterday
09:46:02 <linduxed> i'm not familiar with the operator ($), so what does this mean?
09:46:07 <c_wraith> @src ($)
09:46:08 <linduxed> heads = concat $ map safeFirst xs
09:46:08 <lambdabot> f $ x = f x
09:46:16 <djahandarie> mercury^, no, about the same level of difficulty.
09:46:22 <djahandarie> Just more annoying details to lug around
09:46:24 <sipa> linduxed: it's essentially a way to override the priority of operators
09:46:35 <sipa> linduxed: f $ g $ x y = f (g (x y))
09:46:46 <mercury^> The examples given there seem quite interesting. I have no clue yet why it works. :(
09:47:16 <djahandarie> mercury^, essentially the Newtype class just maps packs to unpacks. That's really it.
09:47:29 <sipa> linduxed: f x $ g y $ h z = f x (g y (h z))
09:47:34 <linduxed> sipa: oh, it looks like a way to get rid of a lot of parenthesis
09:47:44 <sipa> linduxed: indeed, together with .
09:48:11 <sipa> @unpl f . g $ h x
09:48:12 <lambdabot> (f (g (h x)))
09:48:14 <djahandarie> mercury^, however, alone, that would be pretty useless, becuase then your code would be littered with packs and unpacks instead of Products and getProducts or whatever
09:48:58 <djahandarie> mercury^, so the idea is to try and come up with useful combinators that let you avoid writing pack and unpack. ala is one of those
09:49:27 <ptd> linduxed: f.g.h $ x is the same as f $ g $ h $ x
09:49:35 <djahandarie> Looking at the source for ala' is probably the fastest way to understand what it does
09:49:56 <djahandarie> I haven't been able to come up with an explanation that I like yet
09:50:02 <sipa> @unpl f . g $ h . i $ j . k
09:50:02 <lambdabot> (f (g (h (i (\ s -> j (k s))))))
09:50:44 <drdo> What's a nice, mature way to talk TLS in haskell? (either bindings or pure haskell are fine)
09:52:04 <c_wraith> currently, there is none
09:52:10 <c_wraith> the openssl bindings tend to segfault
09:52:20 <c_wraith> and the pure haskell lib is not mature
09:57:16 <identity_> Anyone here that has built lambdabot recently?
09:57:37 <c_wraith> gwern's the maintainer.  So hopefully.
09:57:47 <djahandarie> I thought Cale was the maintainer?
09:57:48 <parcs> :t join (.) join
09:57:49 <gwern> identity_: you are using darcs of course
09:57:49 <lambdabot>     Occurs check: cannot construct the infinite type: a = m a
09:57:49 <lambdabot>       Expected type: m (m a) -> m a
09:57:49 <lambdabot>       Inferred type: m (m a) -> m (m a)
09:58:09 <Cale> No, lambdabot doesn't have an official maintainer
09:58:18 <c_wraith> eh.  Gwern's as close as it gets :)
09:58:30 <djahandarie> Oh, you mean of the package
09:58:31 <Cale> And yeah, I'd agree with that :)
09:58:55 <geheimdienst> this may well be a stupid question, but (>>) seems to ignore its left argument for me: http://hpaste.org/49505
09:58:55 <identity_> gwern: I'm following the wiki guide
09:58:58 <Cale> I just run lambdabot in the IRC channel, I don't actually do much with the code.
09:59:03 <identity_> I haven't run into problems yet, but the guide is somewhat out of date
09:59:05 <geheimdienst> here's the type signature in question: http://hackage.haskell.org/packages/archive/Cabal/1.10.2.0/doc/html/Distribution-Simple.html#v:buildHook
09:59:12 <identity_> like haskell-src-exts darcs link 404'ing
09:59:20 <gwern> identity_: not a surprise. I care only enough to keep it working, not to keep the docs up to date
09:59:21 <identity_> I cabal-installed it instead
09:59:26 <identity_> ah
09:59:30 <identity_> fair enough
10:00:37 <identity_> gwern: Getting it I get CRC errors that are "probably harmless" reported by darcs. Should I repair them?
10:00:57 <gwern> identity_: if you don't have OCD, I wouldn't bother. those darcs problem, have nothing to do with lb
10:01:11 <identity_> ah
10:01:12 <identity_> kk
10:02:36 <identity_> gwern: There is a patch that is listed in the guide that 404's but nothing is said about what it is needed for or anything. Is it still required?
10:02:46 <gwern> identity_: surely not
10:02:55 <identity_> very well
10:02:56 <benmachine> geheimdienst: in the function monad, which seems to be what you're using, that may be what happens
10:03:07 <parcs> djahandarie: does ala have runtime overhead?
10:03:08 <benmachine> @free (r -> a) -> (r -> b) -> (r -> b)
10:03:08 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
10:03:14 <benmachine> @free thing :: (r -> a) -> (r -> b) -> (r -> b)
10:03:14 <lambdabot> g . k = p . f => h . q = f1 . f => h . thing k q = thing p f1 . f
10:03:18 * benmachine melts
10:03:54 <djahandarie> parcs, that's a good question. There would be a typeclass dictionary, but it would be empty. I don't know if GHC would optimize that away.
10:04:00 <djahandarie> So theoretically, there shouldn't be.
10:04:25 <geheimdienst> benmachine: ok, interesting. how do we ascertain if i am actually using this function monad? i thought i was using IO
10:04:31 <parcs> interesting
10:04:49 <identity_> gwern: If you don't mind takign a look: http://pastebin.com/ktWeZjaF is there anything I can do to get past this?
10:04:51 <mauke> The paste ktWeZjaF has been copied to http://hpaste.org/49506
10:04:57 <identity_> ghc 6.12.3
10:05:13 <gwern> ah, good old dependency issues.
10:05:24 <gwern> identity_: what ghc is this anyway?
10:05:31 <identity_> ghc 6.12.3
10:05:35 <benmachine> geheimdienst: the arguments you are passing to >> are functions, aren't they?
10:05:53 <benmachine> as in, buildHook simpleUserHooks :: blah -> whatever
10:05:57 <geheimdienst> yes sir
10:06:36 <benmachine> that means you're using the function monad
10:06:44 <gwern> identity_: hm, I'm on ghc 7 now, but I used 6.12 for a while. maybe try installing darcs mueval on its own
10:06:57 <identity_> I did install mueval from darcs
10:06:59 <benmachine> you'd need your types to be IO something, i.e. you need to pass them arguments
10:07:25 <benmachine> something like \thing foo bar -> f thing foo bar >> buildHook simpleUserHooks thing foo bar
10:08:02 <identity_> @ gwern
10:08:17 <geheimdienst> yeah, i noticed that "print 42 >> print 37" seems to work in ghci. must be because those don't take arguments
10:09:29 <gwern> identity_: hm, not sure then. you could try removing darcs mueval and then hoping cabal install will pick an acceptable version from hackage?
10:09:57 <geheimdienst> i'm still confused, i could have sworn i saw (f >> g) run f and g with the same arguments. i remembered (>>) to be vaguely similar to (&&&)
10:10:11 <geheimdienst> thanks for the explanation, benmachine
10:10:12 <identity_> alright
10:10:14 <identity_> I'll try that
10:10:39 <identity_> but is there any easy way to remove a package like that?
10:11:05 <benmachine> geheimdienst: liftA2 (>>) f g is the same as \x -> f x >> g x, if that helps
10:11:17 <gwern> identity_: ghc-pkg hide, eg
10:11:19 <geheimdienst> oh! nice
10:11:20 <benmachine> liftA2 (liftA2 (>>)) f g = \x y -> f x y >> g x y, I think
10:11:29 <benmachine> but that starts to get silly :P
10:11:34 <geheimdienst> indeed
10:11:35 <identity_> gwern: aaah, thanks
10:11:36 <gwern> identity_: the dep is on the library of mueval, since cabal can't track the executable of mueval
10:12:11 <gwern> identity_: if that doesn't work, you can always edit out the mueval dep from lambdabot and install, since you apparently have a working mueval binary (lambdabot just shells out to mueval for >)
10:12:56 <Peaker> If you're comfortable with SECs, then:  (liftA2 . liftA2) (>>)   is actually readable :-)
10:13:29 <benmachine> oya
10:13:30 <benmachine> silly me
10:13:59 <benmachine> but in your case you'd need to lift four times :P
10:14:42 <djahandarie> @type liftA2
10:14:43 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
10:14:49 <geheimdienst> @type (>>)
10:14:50 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
10:15:08 <djahandarie> @type liftA2 . liftA2
10:15:08 <lambdabot> forall (f :: * -> *) a b c (f1 :: * -> *). (Applicative f, Applicative f1) => (a -> b -> c) -> f (f1 a) -> f (f1 b) -> f (f1 c)
10:15:26 <djahandarie> @type iterate liftA2
10:15:27 <lambdabot>     Occurs check: cannot construct the infinite type: a = f a
10:15:27 <lambdabot>       Expected type: a
10:15:27 <lambdabot>       Inferred type: f a
10:16:55 <identity_> gwern: Thanks. Removing the dep seemed to work. However, this is what I ran into when I tried to just cabal install lambdabot; readline won't install. Is this a C library I need to install?
10:17:06 <gwern> think so
10:17:16 <monadic> identity_: readline comes on most GNU systems, but you likely need the headers
10:17:31 <identity_> monadic: thanks
10:17:35 <identity_> I'll install readline-dev then
10:17:40 <monadic> identity_: Try installing readline-dev, readline-devel, or something
10:18:13 <monadic> It might be readline6-dev as well
10:18:33 <djahandarie> I wonder if you can write an applyN that doesn't constrain the type of the function to (a -> a)
10:18:35 <monadic> seeing as the different versions are slotted on gentoo, its probably seperate packages on the other repos
10:19:09 <djahandarie> So some modification of   applyN 0 f = id; applyN n f = applyN (n-1) f . f    presumably using type families to give a better type
10:19:19 <monadic> djahandarie: How?
10:19:47 <drdo> c_wraith: :S So people just don't do it?
10:20:04 <monadic> djahandarie: The returned value has to be suitable for the next use, so at most you can get forall b. (forall a. a -> b)
10:20:20 <monadic> or I suppose (forall a b. a -> b)
10:20:24 <geheimdienst> so, what module defines the (->) instance of Monad?
10:20:33 <monadic> geheimdienst: Control.Monad.Instances
10:20:37 <geheimdienst> thanks
10:21:04 <djahandarie> monadic, there are various functions that can compose with themselves any finite number of times but aren't of type  a -> a
10:21:40 <monadic> djahandarie: Examples? a -> b would work but would require higher ranked polymorphism
10:21:47 <Peaker> hmm.. are the blogs true about Go's error handling idiom being:  is_err, result = ...;   ?
10:21:50 <djahandarie> @type (liftA2, liftA2.liftA2, liftA2.liftA2.liftA2, liftA2.liftA2.liftA2.liftA2)
10:21:51 <lambdabot> forall a b c (f :: * -> *) (f1 :: * -> *) a1 b1 c1 (f2 :: * -> *) (f3 :: * -> *) (f4 :: * -> *) a2 b2 c2 (f5 :: * -> *) (f6 :: * -> *) (f7 :: * -> *) (f8 :: * -> *) a3 b3 c3 (f9 :: * -> *). (
10:21:52 <lambdabot> Applicative f, Applicative f1, Applicative f2, Applicative f3, Applicative f4, Applicative f5, Applicative f6, Applicative f7, Applicative f8, Applicative f9) => ((a -> b -> c) -> f a -> f b -> f c,
10:21:52 <lambdabot> (a1 -> b1 -> c1) -> f1 (f2 a1) -> f1 (f2 b1) -> f1 (f2 c1), (a2 -> b2 -> c2) -> f3 (f4 (f5 a2)) -> f3 (f4 (f5 b2)) -> f3 (f4 (f5 c2)), (a3 -> b3 -> c3) -> f6 (f7 (f8 (f9 a3))) -> f6 (f7 (f8 (f9 b3)))
10:21:52 <lambdabot>  -> f6 (f7 (f8 (f9 c3))))
10:22:03 <djahandarie> Oops. That wasn't as clear as I wanted it to be :p
10:22:05 <monadic> djahandarie: Man, can't you use ghci :)
10:22:10 <benmachine> :P
10:22:30 <benmachine> :t fst.fst.fst.fst.fst.fst.fst -- monadic
10:22:31 <lambdabot> forall a b b1 b2 b3 b4 b5 b6. (((((((a, b), b1), b2), b3), b4), b5), b6) -> a
10:22:36 <djahandarie> monadic, how would the higher-ranked type help here?
10:23:22 <monadic> djahandarie: Because if you have just (a -> b) then it requires a ~ b. Whereas forall b. (forall a. a -> b) will allow any first argument
10:23:43 <monadic> Hence, say, `const True` would work
10:24:29 <benmachine> const True is of the type a -> a, sorta
10:24:32 <benmachine> or can be, at least
10:24:44 <benmachine> whereas fst genuinely isn't but can still compose with itself arbitrarily many times
10:24:49 <monadic> @type const True
10:24:50 <lambdabot> forall b. b -> Bool
10:25:25 <monadic> OKay, lets see, how would we type the function that can take (a, b) -> a as its argument to continually apply
10:25:50 <monadic> because that would require a ~ (a, b), since we have to assume we can do it infinitely times?
10:26:30 <djahandarie> Maybe this is just a problem with Haskell only having Nat_omega?
10:27:07 <benmachine> monadic: arbitrarily, not infinitely
10:27:23 <benmachine> oh hold on
10:27:29 <benmachine> I joined this conversation partway through
10:27:50 * djahandarie specifically said finite earlier
10:27:50 <benmachine> and missed the bit about applyN
10:28:15 <benmachine> you could use TH to do that, that's not overkill at all
10:28:16 <monadic> The reason why I mentioned rank 2 types is that
10:28:21 <djahandarie> applyN was written using induction over a (theoretically) inductive data type.
10:28:24 <monadic> applyN 5 (const True) 20
10:28:33 <monadic> does not work without rank-2 polymorphism
10:28:38 <identity_> So I'm building lambdabot and I do believe I'm close. But this happened:
10:28:40 <identity_> http://hpaste.org/49508
10:28:56 <monadic> At least, with the implementation of applyN I used (is there one in the ghc distribution)
10:29:13 <identity_> gwern: If you have time I'd appreciate if you'd take a look
10:29:18 <djahandarie> No, I don't even know if it's called that, I just made it up.
10:29:37 <benmachine> monadic: I see what you mean
10:29:47 <clsmith> there might be differing opinions on this, but i'm looking to write an experimental text editor in haskell -- which of the various libraries should i use? gtk2hs seems to IO-filled
10:29:58 <clsmith> *too
10:30:22 <monadic> clsmith: If you don't want IO you can use an FRP library
10:31:22 <benmachine> monadic: what about applyN 0 (const True) 20?
10:31:34 <clsmith> monadic: ok, there are a few of those, is there one that's more common?
10:32:23 <monadic> clsmith: I've seen reactive-banana gaining popularity. I've never managed to find one I liked, mainly because reactive-banana doesn't seem to have a gtk driver. I dislike wx
10:32:33 <monadic> benmachine: Nope
10:33:01 <monadic> benmachine: The actual value won't affect typechecking, remember?
10:33:20 <benmachine> monadic: sure, but my point was to illustrate that rank-whatever polymorphism won't save
10:33:23 <benmachine> you
10:33:29 <benmachine> because the *specification* is ill-typed
10:33:42 <benmachine> (because applyN 0 (const True) 20 should be 20)
10:33:57 <monadic> benmachine: No, applyN 0 _ _ is undefined
10:34:00 * benmachine is not using terminology well
10:34:07 <benmachine> monadic: hm. don't like that :P
10:34:15 <monochrom> gtk2hs is IO-filled. nevertheless, if you want to see how it's like, see the "manatee" project
10:34:57 <benmachine> monadic: so your typesig is something like Integer -> (forall a. a -> b) -> a -> b? isn't that isomorphic to Integer -> b -> b, i.e. const id?
10:35:37 <benmachine> oh it's not const id, it's const id-except-we-crash-for-some-integers
10:35:53 <dolio> Yes, the latter.
10:36:06 <monadic> benmachine: Yep!
10:36:19 <benmachine> monadic: oh, right :P
10:36:34 <monadic> benmachine: But it supports more than just a -> a :)
10:36:51 <monadic> benmachine: The real question is, can we type applyN 0 fst 20 with some type for applyN
10:37:23 <monadic> benmachine: I feel like you can't because it would have to be an infinite tuple (as in, we can't unwrap a finite tuple that way)
10:39:03 <dolio> If you mean a type that's valid in GHC, then no.
10:39:27 <linduxed> fazzone: i'm sorry but that is not something i can answer, it's too complicated for me to mix in stuff like mapM_ or something like that
10:39:29 <djahandarie> dolio, what would you need?
10:40:00 <fazzone> linduxed: http://paste.pocoo.org/show/446108/
10:40:02 <linduxed> ski: but dude, that transforms my entire code, and i'm not good enough to rethink everything
10:41:13 <linduxed> fazzone: aaah now i think i understand what you talked about, you were just discussing an alternative way of reading in the files
10:41:19 <linduxed> fazzone: and writing
10:41:20 <dolio> If something like 'F (x, y) = x' were a first-class (partial) type function, then something like (n : Integer) -> (forall a. a -> f a) -> a -> f^n a would cover it.
10:41:26 <linduxed> fazzone: yes, that's what happening
10:41:47 <djahandarie> dolio, can't we do this with type families?
10:42:17 <fazzone> linduxed: yeah; i prefer to use getContents and IO redirection with my shell, but that's just a matter of taste
10:42:30 <c_wraith> drdo: Eh.  http://hackage.haskell.org/package/tls-0.7.1 appears to *work*.  It's just not fully mature.  It's certainly used by a few different things.
10:42:48 <dolio> Or alternately (forall a. f a -> a) -> f^n a -> a
10:43:04 <dolio> Although that's also too limited.
10:43:15 <linduxed> ok, can someone please explain to me why i get this error http://paste.pocoo.org/show/446185/ from this code http://paste.pocoo.org/show/446185/ ?
10:43:25 <linduxed> i've been thinking about it for some time now
10:43:35 <sp3ctum> linduxed, same link twice?
10:43:39 <linduxed> and i have no idea why it expects a Char
10:43:45 <linduxed> sp3ctum: wooops
10:43:55 <linduxed> the second one should be http://paste.pocoo.org/show/446184/
10:44:32 <linduxed> i just can't understand why it would want Char when there's no function signature that requests it
10:44:38 <linduxed> especially not safeHead
10:44:52 <fazzone> put a bunch of parens around everything to make sure things are associating the way you want them to
10:45:27 <Egbert9e9> i want to write something but i have no clue what's the right way to do it
10:45:44 <Egbert9e9> i've already did, but now i wonder if it's the right way
10:45:54 <linduxed> fazzone: there aren't many more places to put parens....
10:46:04 <Egbert9e9> thinking from an design pov
10:47:18 <linduxed> yeah, i tried putting some parens around the "map safeHead inLines", didn't help one bit
10:47:43 <linduxed> i can't see anywhere else where i could put them, so i don't think it's that
10:48:33 <Egbert9e9> so, it's a game where the player has a set amount of time to recognize, from 6 columns of words, the word that appears in the central column (there are 7 columns total)
10:49:05 <Egbert9e9> goal is getting as many as you can in that time period
10:50:31 <Egbert9e9> how do i check for timeout?
10:52:18 <fazzone> linduxed: look at the type for (:)
10:52:34 <fazzone> something -> [something] -> [something]
10:53:27 <fazzone> type of (map safeHead inLines) is [String], so (:) is expecting a [[String]] for it's second argument, but it's getting a [String], so error
10:53:34 <knoc> What can I do, if I want a floating point number with more digits after the comma than Double (~18)?
10:53:53 <knoc> I need ~ 1000000
10:54:22 <fazzone> knoc: might I inquire as to why?
10:54:44 <kmc> knoc, don't use floating point, then
10:54:48 <kmc> knoc, maybe Rational is what you want
10:54:58 <mwc> knoc: use a bignum library, but as a professional applied mathematician I have to say that I've never seen any application for that kind of precision
10:55:18 <knoc> It is for an euler problem
10:56:58 <mwc> knoc: which one (number?)
10:57:06 <knoc> mwc: 40
10:57:13 <linduxed> fazzone: oh i see... so basically i need to use something like ++ ?
10:58:03 <knoc> mwc: I solved that problem in theory with strings and lists, but thats horrible slow^^
10:58:20 <fazzone> linduxed: If that's what you want ... I don't understand what's going in that function, to be honest
10:59:13 <mwc> knoc: instead of storing each term in the sum as a giant bignum, consider storing them as a (Float, Integer) where the Integer gives a base
11:01:07 <mwc> defining a suitible multiplication operator should be a simple exercise in arithmetic
11:01:36 <mwc> hint, you probably want to maintain the magnitude float between 1 and 10,
11:02:25 <kmc> i put floating point in your floating point so you can lose precision while you lose precision
11:02:34 <root___> exit
11:02:35 <mwc> Anybody used the regional-pointers package, specifically the alloca functions? I'm having trouble figuring out how multiple allocations should be handled
11:03:12 <knoc> mwc: Thanks, I see want you want to tell me, now I have too implement it ;)
11:04:02 <mwc> knoc: it's reasonable to do [Bool], Integer and store a list of 1/2, 1/4, 1/8, ... bits instead
11:04:09 <mwc> if you want exact precision
11:04:26 <mwc> given how many numbers you need to multiply the product should be exactly representable in the form of a Float, Integer
11:04:29 <mwc> tuple
11:05:34 <alex-shpilkin> can anyone remind me where the (~>) combinator was defined
11:05:40 <alex-shpilkin> *defined?
11:05:43 <fazzone> Control.Applicative ?
11:06:15 <alex-shpilkin> it was something like (~>) :: (a' -> a) -> (b -> b') -> (a -> b) -> a' -> b' I think
11:06:20 * edwardk1 waves hello
11:06:32 <fazzone> alex-shpilkin: hoogle ?
11:06:40 <byorgey> alex-shpilkin: http://matt.immute.net/content/pointless-fun  perhaps?
11:07:02 <byorgey> I don't know if it's in any library on Hackage
11:07:44 <alex-shpilkin> byorgey: exactly, thank you =) and the problem is (was) that it isn't
11:08:11 <edwardk1> clearly it should be generalized to arbitrary profunctors
11:08:36 <alex-shpilkin> ahem
11:08:57 * alex-shpilkin tries to invent what profunctors could be
11:09:03 <edwardk> http://blog.sigfpe.com/2011/07/profunctors-in-haskell.html
11:09:04 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
11:09:26 <bobzhang> hi, did  anyone manage to derive ListLike instance automatically?
11:09:33 <edwardk> copumpkin has them in agda somewhere too
11:09:45 <bobzhang> like this : newtype Stream a = Stream [a]
11:09:56 <bobzhang> deriving instance LL.ListLike (Stream a) a
11:09:58 <copumpkin> wat
11:10:02 <copumpkin> oh
11:10:10 <copumpkin> I have a definition of profunctors and the profunctor identity
11:10:15 <copumpkin> never did figure out how to compose them
11:10:24 <copumpkin> one day I'll get back to it
11:10:25 <edwardk> *scoff*
11:11:28 <Egbert9e9> how do i set a specified amount of time for an expression to be thunked, otherwise it returns a Nothing or an equivalent?
11:11:47 <Egbert9e9> thunks into Nothing
11:12:28 <copumpkin> NEED MOAR PROFUNKTOR
11:12:35 <c_wraith> Egbert9e9: Do you want timeout?
11:12:44 <Egbert9e9> c_wraith: oh, i do
11:13:03 <c_wraith> @hoogle timeout
11:13:03 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
11:13:03 <lambdabot> module System.Timeout
11:13:03 <lambdabot> Network.Socket RecvTimeOut :: SocketOption
11:13:03 <Egbert9e9> c_wraith: got it
11:13:10 <Egbert9e9> thanks
11:13:34 <parcs> will if-then-else branches be optimized away if the predicate is a top-level constant?
11:13:44 <mwc> Has anyone used the regional-pointers package? Having trouble with the alloca replacements, specifically how to do a pair of alloca operations, seeing a type error related to having nested allocas
11:13:54 <c_wraith> Egbert9e9: just be sure that the IO action actually evaluates the expression you want fully before returning.  Otherwise it may not help.
11:14:27 <c_wraith> parcs: that seems likely.  check the core :)
11:14:57 <parcs> core scares me
11:15:19 <kmc> Egbert9e9, see also Control.Exception.evaluate
11:15:27 <monochrom> parcs: do you have an example of where the if-then-else appears?
11:15:50 <kmc> timeout n (evaluate x)  -- Egbert9e9
11:16:02 <monochrom> is it like a top-level "x = if b then ... else ...; b = 100*100 > 1000"
11:16:45 <monochrom> or is the if-then-else hidden deeper?
11:16:58 <Egbert9e9> kmc: seems like another way to return
11:17:16 <kmc> 'return' and 'evaluate' are different
11:17:20 <Egbert9e9> except it's specific for IO
11:17:39 <parcs> monochrom: it's in the middle of a do-block
11:17:47 <hatds> template haskell newbie question:  I can use ListE to go from [Exp] to Exp, but is there a simple way to go from (Exp, Maybe Exp, [Exp]) to Exp?
11:17:48 <kmc> 'evaluate' produces an IO action that, when executed, forces some value to WHNF before returning it
11:18:00 <kmc> 'return' does not force anything
11:18:36 <kmc> Egbert9e9, main = do { x <- return undefined; putStrLn "okay!" }
11:18:38 <Egbert9e9> is there a package with as much as documentation of haskell and its modules i can download so i won't have to wait for my latenceous internet to react?
11:18:56 <kmc> runs fine, now replace 'return' with 'evaluate' and it will crash
11:19:31 <Egbert9e9> ah
11:19:34 <kmc> the results of IO actions can be fully lazy values
11:20:00 <kmc> the way IO sequences execution of effects has nothing to do with sequencing evaluation
11:20:13 <kmc> (although evaluation of the IO actions themselves is forced by their execution)
11:20:19 <Egbert9e9> so it's a way to thunk
11:20:24 <kmc> ?
11:20:32 <kmc> i don't think "thunk" has a well-understood meaning as a verb
11:20:45 <Egbert9e9> there isn't?
11:20:55 <Egbert9e9> i thought it's when the value of an expression is decided
11:21:04 <kmc> that would be "to evaluate"
11:21:11 <Egbert9e9> ouhm
11:21:26 <kmc> thunk (noun): an unevaluated expression
11:21:28 <c_wraith> or "force", sometimes.
11:21:31 <Egbert9e9> okay, i'll try fixing my terminology
11:21:45 <hatds> return doesn't add another thunk ontop of the value if that is what you are thinking, rather return simply does not force its argument
11:21:46 <Egbert9e9> kmc: oh wow. i was completely off
11:22:02 <c_wraith> "force" is specific to thunks.  "evaluate" is the general name for the process, whether thunks are involved or not.
11:22:06 <parcs> i'm thinking that, instead of using CPP/#ifs/#elses in tons of files, it would be cleaner use it in a single module, bind some Bools, and import and use those bindings
11:22:06 <kmc> (return $! x) is also different from (evaluate x)
11:22:15 <monochrom> parcs: core says the if-then-else stays, and b is evaluated at run time, though at most once
11:22:17 <kmc> in the former case, evaluating the IO action is enough to evaluate x
11:22:28 <Egbert9e9> a thunk, then, is one of those lazy being so common in haskell
11:22:30 <kmc> in the latter case, evaluating the IO action is not enough to evaluate x, but executing the IO action is
11:22:32 <Egbert9e9> beings
11:22:35 <monochrom> at least for "b = 100*100 > 1000"
11:23:04 <Egbert9e9> kmc: never saw ($!)
11:23:24 <Egbert9e9> @t ($!)
11:23:24 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
11:23:35 <monochrom> however, with "b = True", b and the if-then-else are eliminated.
11:23:36 <Egbert9e9> ack
11:23:36 <c_wraith> I still don't understand the reason (return $!) isn't sufficient to function as evaluate.  It's subtle enough that it's explicit in the documentation.
11:23:44 <Egbert9e9> @type ($!)
11:23:45 <lambdabot> forall a b. (a -> b) -> a -> b
11:23:47 <kmc> @src ($!)
11:23:48 <lambdabot> f $! x = x `seq` f x
11:24:02 <kmc> c_wraith, you don't want evaluation of the IO action to force evaluation of the thing
11:24:12 <kmc> you want to defer that until the IO action is performed
11:24:25 <c_wraith> Hmm.  Ok, that's true.
11:24:38 <kmc> (return $!) is sufficient in many cases, though
11:24:46 <c_wraith> Though only visible in the presence of seq
11:25:01 <kmc> c_wraith, because you can't pattern-match on IO actions?
11:25:02 <kmc> fair enough
11:25:04 <c_wraith> Well, or of pattern-matching on IO, if you're mucking about with Internals
11:25:08 <kmc> right
11:25:45 <Egbert9e9> @src (seq)
11:25:45 <lambdabot> Source not found. My pet ferret can type better than you!
11:25:48 <Egbert9e9> uh
11:25:51 <monochrom> there are also some other kinds of b that get folded at compile time. here is another example. b = f (Just ()); f (Just _) = True. this b gets eliminated at compile time
11:25:51 <c_wraith> seq is magical
11:25:52 <kmc> Egbert9e9, seq is a magical builtin
11:25:59 <kmc> you can write it yourself for specific types, e.g.
11:26:00 <c_wraith> seq cannot be implemented in haskell
11:26:04 <kmc> seq True x = x; seq False x = x
11:26:20 <c_wraith> well.  yes.  You can't implement it with its exact type signature in haskell
11:26:23 <kmc> but you can't do this for all algebraic types at once, and you can't do it for functions at all
11:26:53 <kmc> seq allows you to distinguish (undefined :: () -> ()) from (const undefined :: () -> ()) which you can't do otherwise, i think
11:27:02 <parcs> monochrom: thanks
11:27:04 <monochrom> . o O ( instance Data x => CanSeq x where ... )
11:27:24 <kmc> in earlier versions of Haskell, seq was in a type class to reflect its magical ad-hoc polymorphism
11:27:47 <kmc> though the implementation still provided an instance magically for every type
11:28:16 <c_wraith> It turns out they got rid of the type class just because of how much type signature mangling it caused when adding strictness to remove certain types of space issues in early haskell projects
11:28:17 <kmc> also seq's stated guarantee is almost useless and really people usually want pseq
11:28:40 <kmc> but this information has not yet permeated the libraries or the community
11:28:53 <c_wraith> seq usually works for what I want. *shrug*
11:28:56 <monochrom> true, it sucks to say "f :: (Seq a, Seq b, Seq c) => ..." all the time :)
11:29:11 <kmc> c_wraith, sure, you're relying on behavior that's not guaranteed
11:29:20 <kmc> monochrom, it must suck even more without FlexibleContexts
11:29:33 <kmc> c_wraith, just like all kinds of things "usually work" in C
11:29:34 <monochrom> example of seq's guarantee useless: http://article.gmane.org/gmane.comp.lang.haskell.cafe/88120/
11:29:44 <kmc> i'm not sure what the point was of providing seq with only a denotational contract
11:29:45 <Egbert9e9> i still don't understand what seq does
11:29:47 <c_wraith> kmc: I'm really not, as far as I understand it.
11:29:51 <kmc> Egbert9e9, that's because nobody told you
11:29:57 <monochrom> strictness still does not order evaluation
11:30:04 <kmc> evaluating (pseq x y) evaluates x, then evaluates y and returns it
11:30:07 <linduxed> fazzone: well the idea is that if i got a text that looks like this http://pastie.org/2269675 then transpose should turn it into this http://pastie.org/2269685 . well that's what the entire procedure of "unlines . transpose . lines" should do, so transpose in itself should just return (using that "Hello this is text."-example) ["Htit","ehse","li x","ls t","o  ."]
11:30:21 <kmc> Egbert9e9, seq is like pseq except the actual temporal ordering of those two events is not guaranteed
11:30:27 <Egbert9e9> ah
11:30:36 <fazzone> Oh, so don't you want to do words somewhere?  (linduxed)
11:30:50 <kmc> the only guarantee about seq is that  seq ⊥ x = ⊥  and otherwise  seq y x = x
11:31:10 <kmc> ⊥ ("bottom") stands for any expression that can't evaluate to weak head-normal form successfully, i.e. due to "error" or infinite loop
11:31:11 <Egbert9e9> so it's kinda like (>>) for monads
11:31:14 <kmc> no
11:31:28 <kmc> okay, a little bit
11:31:33 <Egbert9e9> yey
11:31:34 <linduxed> fazzone: well, no. no need really, lines splits the input text up into... lines. after that i just want to shave off the head in each line.
11:31:36 <kmc> but i think that analogy will give you more trouble than help
11:31:41 <clsmith> @hoogle [a] -> ([(a,a)], Maybe a)
11:31:41 <lambdabot> No results found
11:31:41 <kmc> because monads aren't about evaluation
11:31:43 <linduxed> fazzone: after that i just unlines it
11:31:47 <clsmith> i thought that might be a bit obscure
11:31:52 <c_wraith> kmc: Well.  seq works for me where I use it, because I almost always use it for (return $!) in IO.  That's a case where it will do the right thing, since (>>=) in IO evaluates its first argument.
11:32:11 <c_wraith> kmc: but I *am* relying on that behavior of (>>=)
11:32:35 <fazzone> >let something = transpose . words in something "Hello this is text."
11:32:48 <parcs> :t sizeOf
11:32:49 <lambdabot> Not in scope: `sizeOf'
11:33:06 <linduxed> fazzone: my issue is only that in that spot where you pointed out before (about the usage of :)... i could really use a : that can take a list on both the right and the left
11:33:24 <linduxed> fazzone: just that magic would finish the entire function
11:33:40 <fazzone> linduxed:  (++) ?
11:33:46 <linduxed> ++ does not work, since it concatenates
11:33:48 <Egbert9e9> what about bottom and seq? didn't quite get it
11:34:15 <c_wraith> > let x = undefined in True || x
11:34:16 <lambdabot>   True
11:34:25 <c_wraith> > let x = undefined in x `seq` (True || x)
11:34:26 <lambdabot>   *Exception: Prelude.undefined
11:34:26 <fazzone> linduxed: maybe instead of something : somethingElse you want [something] : somethingElse ?
11:34:28 <linduxed> fazzone: if i concatenate, then i wont get a transposed text, i'll get one column of text
11:34:44 <linduxed> fazzone: hmmm, that could be it
11:34:46 <monochrom> kmc, in those days they still haven't completely separated denotational concerns and operational concerns. it's evident in their wording. Bird's book speaks like "lazy vs strict". haskell 98 section 6.2 explicitly states "Function application in Haskell is non-strict; that is, a function argument is evaluated [sic] only when required. ... seq is usually introduced to improve performance by avoiding unneeded laziness [sic]."
11:34:52 <linduxed> fazzone: or wait, let me think
11:35:01 <kmc> monochrom, i see
11:35:05 <fazzone> linduxed: but then you get a [[String]], is that what you want?
11:35:09 <kmc> dark days
11:35:20 <Egbert9e9> c_wraith: hmmm
11:35:27 <kmc> Egbert9e9, what didn't you get? i described seq
11:35:44 <kmc> (seq ⊥ x = ⊥), and (seq y x = y) otherwise
11:35:47 <Egbert9e9> i don't understand the consequences
11:36:02 <c_wraith> the consequences are subtle, as kmc is pointing out.
11:36:03 <kmc> Egbert9e9, you can use seq to force evaluation to occur earlier than it otherwise would
11:36:07 <c_wraith> pseq is much easier to understand.
11:36:10 <kmc> e.g. to avoid space leaks
11:36:18 <kmc> but you should actually use pseq for that
11:36:25 <Eduard_Munteanu> Why pseq?
11:36:26 <linduxed> fazzone: nope this did not work
11:36:30 <kmc> Eduard_Munteanu, read above
11:36:53 <c_wraith> @hoogle pseq
11:36:53 <lambdabot> Control.Parallel pseq :: a -> b -> b
11:36:53 <monochrom> Eduard_Munteanu, http://article.gmane.org/gmane.comp.lang.haskell.cafe/88120/
11:37:01 <c_wraith> That's my big problem with pseq.
11:37:09 <c_wraith> I don't want to depend on parallel.
11:37:15 <c_wraith> Put it in base
11:37:21 <Eduard_Munteanu> Oh... "This is normally no problem when using seq to express strictness, but it can be a problem when annotating code for parallelism, because we need more control over the order of evaluation; we may want to evaluate a before b, because we know that b has already been sparked in parallel with par. " from the Haddock stuff
11:37:38 <linduxed> fazzone: listen, if transpose gets ["foo","bar"] from lines, then it should return ["fb","oa","or"] to unlines
11:37:45 <monochrom> pseq is also available in GHC.Conc :)
11:37:49 <Egbert9e9> oh poop, no Control.Parallel
11:37:50 <kmc> Eduard_Munteanu, I would argue most cases of strictness, e.g. for avoiding space leaks, care about ordering
11:38:01 <linduxed> fazzone: it's like a zip for an arbitrary amount of lines
11:38:03 <kmc> i don't see the point of seq otherwise
11:38:07 <fazzone> linduxed: Why are you rewriting transpose again?  One exists in Data.List
11:38:12 <c_wraith> Egbert9e9: cabal install parallel
11:38:16 <kmc> maybe the point of seq otherwise is to help GHC's strictness analyzer
11:38:22 <Egbert9e9> yeah, doing that
11:38:26 <linduxed> fazzone: it's a training excercise
11:38:39 <fazzone> linduxed: okay, let me read and comprehend your code for a while
11:38:41 <linduxed> fazzone: and one that is damn close to being finished
11:38:53 <c_wraith> but yeah.  My only real issue with pseq is that extra dependency on parallel.  Otherwise I'd use it, because it explicitly does what I want.
11:38:55 <monochrom> no one wants to read my example!
11:39:18 <Egbert9e9> so i wonder how should i write that game
11:41:14 <Egbert9e9> the player will be shown a bunch of lines on screen and for each line press in the number of the word they choose in that line
11:41:58 <Egbert9e9> player can only press the keyboard while the timeout didn't end
11:42:50 <mahmutbulut> Where is the AI team?
11:42:51 <mahmutbulut> :)
11:42:51 <Egbert9e9> all the code i write is ad hoc and with very little planning
11:43:05 <monochrom> seq is probably enough to control order in other haskell implementations
11:43:51 <mahmutbulut> anyone from AI team? I have lots of questions from ml?
11:44:41 <monochrom> hrm, today's xkcd has a "thunk" :)
11:45:26 <c_wraith> the reaction when you read what's supposed to be the punchline?
11:45:54 <kmc> the joke is that mr hat is sick of hearing about google plus?
11:46:21 <monochrom> I don't know. but surely, irc is still... :)
11:46:22 <kmc> or the joke is that the reader has also heard of google plus and therefore accepts the comic's author as one of his own tribe?
11:47:42 <mahmutbulut> haskell platform for lion ?
11:48:05 <linduxed> fazzone: sorry to bother... but any idea?
11:48:26 <monochrom> lion is probably too new
11:48:46 <fazzone> linduxed:  Yes.  Just now.
11:48:50 <rtharper> mahmutbulut: the current release...functions...on Lion
11:49:20 <monochrom> nevermind, lion should be ok
11:49:36 <mahmutbulut> rtharper: snow leopard build can run on lion ?
11:50:27 <fazzone> linduxed: This is what mine looks like: http://paste.pocoo.org/show/446213/
11:50:54 <rtharper> mahmutbulut: yes
11:51:08 <fazzone> linduxed: No wait, I'm not sure that actually works
11:52:31 * hackagebot profunctors 0.1 - Haskell 98 Profunctors  http://hackage.haskell.org/package/profunctors-0.1 (EdwardKmett)
11:53:28 <fazzone> No, that definitely doesn't work.  I'm a moron!
11:55:48 <ptd> fazzone:first is in prelude as head, butfirst is in prelude as tail
11:55:52 <linduxed> fazzone: i see where you'se going with that...
11:56:57 <fazzone> ptd: Yes, but not really -- head and tail cause errors when fed empty and <2-element lists, respectively.
11:57:03 <kmc> don't use 'head'
11:57:08 <copumpkin> omg profunctors
11:57:13 <edwardk> =P
11:57:15 <kmc> no, tail on a 1-element list is fine
11:57:19 <rtharper> > tail [1]
11:57:20 <lambdabot>   []
11:57:28 <kmc> head (x:xs) = x; tail (x:xs) = xs
11:57:40 <kmc> you should usually use pattern-matching instead
11:57:42 <rtharper> head and tail simply require non-empty lists
11:58:01 <rtharper> > init [1]
11:58:02 <lambdabot>   []
11:58:04 <rtharper> > last [1]
11:58:05 <lambdabot>   1
11:58:15 <rtharper> @src init
11:58:15 <lambdabot> init [x]    = []
11:58:16 <lambdabot> init (x:xs) = x : init xs
11:58:16 <lambdabot> init []     = undefined
11:58:19 <rtharper> ah right
11:58:21 <kmc> harder to replace init / last with pattern-matching, unfortunately
11:58:22 <rtharper> @src head
11:58:23 <lambdabot> head (x:_) = x
11:58:23 <lambdabot> head []    = undefined
11:58:29 <fazzone> the undefined is undesirable
11:58:44 <rtharper> > undefined
11:58:45 <lambdabot>   *Exception: Prelude.undefined
11:58:55 <kmc> > fix error
11:58:56 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
11:59:45 <ptd> Are there standard maybe variants of head and tail.
12:00:25 <kmc> @hoogle listToMaybe
12:00:25 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
12:00:52 <kmc> if you're going to pattern-match on that Maybe, you might as well pattern-match the list
12:01:04 <kmc> it can be useful if you're instead using some Maybe combinators
12:02:16 <copumpkin> > let safeTail ys = listToMaybe [xs | (x:xs) <- [ys]] in safeTail []
12:02:17 <lambdabot>   Nothing
12:02:33 * hackagebot profunctor-extras 0.1 - Profunctor extras  http://hackage.haskell.org/package/profunctor-extras-0.1 (EdwardKmett)
12:02:34 <dolio> If you're using Maybe combinators, you might as well use list combinators. :)
12:02:49 <ptd> @pl f x = case x of [] -> Nothing ; (y:ys) -> Just y
12:02:49 <lambdabot> (line 1, column 20):
12:02:49 <lambdabot> unexpected ">" or "-"
12:02:49 <lambdabot> expecting variable, "(", operator or end of input
12:02:58 <copumpkin> > let safeTail = listToMaybe . drop 1 in safeTail []
12:03:00 <lambdabot>   Nothing
12:03:02 <copumpkin> > let safeTail = listToMaybe . drop 1 in safeTail [1,2,3]
12:03:04 <lambdabot>   Just 2
12:03:08 <copumpkin> dayum
12:03:17 <ptd> @pl f x = case x of [] -> Nothing ; (y:ys) -> Just y
12:03:17 <lambdabot> (line 1, column 20):
12:03:17 <lambdabot> unexpected ">" or "-"
12:03:17 <lambdabot> expecting variable, "(", operator or end of input
12:03:41 <ptd> @pl f x = case x of [] -> Nothing ; (y:ys) -> Just y;
12:03:41 <lambdabot> (line 1, column 20):
12:03:41 <lambdabot> unexpected ">" or "-"
12:03:41 <lambdabot> expecting variable, "(", operator or end of input
12:03:59 <dolio> > let safeTail = listToMaybe . drop 1 . tails in (safeTail [], safeTail [1], safeTail [1..10])
12:04:01 <lambdabot>   (Nothing,Just [],Just [2,3,4,5,6,7,8,9,10])
12:04:12 <copumpkin> fancy
12:04:14 <ptd> @pl f x = case x of [] -> Nothing
12:04:14 <lambdabot> (line 1, column 20):
12:04:14 <lambdabot> unexpected ">" or "-"
12:04:14 <lambdabot> expecting variable, "(", operator or end of input
12:04:27 <copumpkin> mine is shorter though
12:04:44 <copumpkin> or is it
12:04:46 <ptd> @pl f x = case x of{ [] -> Nothing ; (y:ys) -> Just y;}
12:04:46 <lambdabot> (line 1, column 16):
12:04:46 <lambdabot> unexpected "{"
12:04:46 <lambdabot> expecting variable, "(", operator or end of input
12:04:49 <copumpkin> > length "listToMaybe [xs | (x:xs) <- [ys]]"
12:04:50 <lambdabot>   33
12:05:00 <copumpkin> > length "listToMaybe . drop 1 . tails"
12:05:01 <lambdabot>   28
12:05:02 <copumpkin> ooh fail
12:05:07 * copumpkin hangs head in shame
12:05:21 <byorgey> copumpkin: you don't need all those spaces.  nor two-letter variable names.
12:05:34 * hackagebot profunctor-extras 0.1.0.1 - Profunctor extras  http://hackage.haskell.org/package/profunctor-extras-0.1.0.1 (EdwardKmett)
12:05:57 <earthy> > length "listToMaybe [xs|(x:xs)<-[ys]]"
12:05:58 <lambdabot>   29
12:06:06 <earthy> still fail. :)
12:06:08 <byorgey> > listToMaybe [f|_:f<-[1,2,3]]]
12:06:08 <lambdabot>   <no location info>: parse error on input `]'
12:06:12 <byorgey> > listToMaybe [f|_:f<-[1,2,3]]
12:06:13 <lambdabot>   No instance for (GHC.Num.Num [t])
12:06:13 <lambdabot>    arising from a use of `e_1123' at <int...
12:06:21 <byorgey> > listToMaybe [f|(_:f)<-[1,2,3]]
12:06:21 <lambdabot>   No instance for (GHC.Num.Num [t])
12:06:21 <lambdabot>    arising from a use of `e_1123' at <int...
12:06:33 <byorgey> oh, duh
12:06:41 <byorgey> > listToMaybe [f|_:f<-[[1,2,3]]]
12:06:42 <lambdabot>   Just [2,3]
12:06:50 <byorgey> see, you don't even need the parentheses
12:07:00 <dolio> > length "listToMaybe.tail.tails"
12:07:01 <lambdabot>   22
12:07:20 <copumpkin> waaah
12:07:31 <coppro> :t listToMaybe
12:07:31 <lambdabot> forall a. [a] -> Maybe a
12:07:34 * hackagebot profunctors 0.1.0.2 - Haskell 98 Profunctors  http://hackage.haskell.org/package/profunctors-0.1.0.2 (EdwardKmett)
12:07:52 <coppro> > listToMaybe [1,2]
12:07:53 <lambdabot>   Just 1
12:08:19 <byorgey> edwardk++
12:08:33 <edwardk> representable-profunctors coming in just a minute
12:08:36 * hackagebot profunctor-extras 0.1.0.2 - Profunctor extras  http://hackage.haskell.org/package/profunctor-extras-0.1.0.2 (EdwardKmett)
12:08:40 <dolio> edwardk--
12:08:45 <edwardk> =P
12:08:59 <companion_cube> ohhhh, look, he can see the future!
12:09:00 <clsmith> time to google profunctor
12:09:49 <clsmith> sometimes i think wikipedia is written by people who don't actually want to explain anything
12:10:04 <Eelis> i get that feeling, too
12:10:32 <kmc> wikipedia on math or CS is really hit or miss
12:11:51 <Cale> Well, it's meant for reference, right?
12:12:14 <Cale> I think it actually does fairly well if you're thinking of it as an encyclopedia.
12:12:15 <cheater_> it's meant for confusion
12:12:22 <parcs> let f _ = 1 in f (head [])
12:12:27 <parcs> > let f _ = 1 in f (head [])
12:12:28 <lambdabot>   1
12:12:34 <parcs> phew
12:12:36 <cheater_> confusious says: read wikipedia for true unlightenment
12:12:37 <Cale> Normally encyclopedias don't really explain things too carefully.
12:13:01 <cheater_> that's funny, because dieudonne's encyclopedia of analysis explains it in great detail
12:13:04 <Cale> If you want to learn something new, you get a book on that topic.
12:13:21 <Cale> rather than something for general reference
12:13:23 <mokus> references (which include encyclopedias) are generally for people who already know at least the basics of the subject
12:13:45 <mokus> or encyclopediae? ;)
12:13:46 <Cale> Though, in wikipedia's case, there's certainly the potential for more exposition than a normal encyclopedia would have.
12:14:18 <parcs> http://simple.wikipedia.org/wiki/Category_theory
12:14:29 <Cale> lol, simple wikipedia
12:15:38 <clsmith> sigh, there needs to be a wikipedia in the middle of simple.* and en.*
12:16:41 <danharaj_> My favorite simple english wiki entry is "Manifold"
12:16:51 <mokus> clsmith: wikibooks isn't exactly a wikipedia but I think it fits in that space
12:17:14 <Cale> Well, the simple English Wikipedia isn't really supposed to be dumber than the normal English wikipedia, it's just supposed to use simpler words.
12:17:38 * hackagebot profunctors 0.1.1 - Haskell 98 Profunctors  http://hackage.haskell.org/package/profunctors-0.1.1 (EdwardKmett)
12:17:50 <danharaj_> Cale: Yes, but that breaks down in Math where everything is definitions depending on previous definitions :p
12:17:52 <Cale> It should probably be a patch set against the normal English Wikipedia.
12:18:09 <Cale> Well, the simple English Wikipedia is okay with technical terms
12:18:33 <Cale> It's just the non-technical English in it which is supposed to be simple.
12:18:38 * hackagebot profunctor-extras 0.1.1 - Profunctor extras  http://hackage.haskell.org/package/profunctor-extras-0.1.1 (EdwardKmett)
12:19:17 <danharaj_> Cale: In my experience, explaining a mathematical concept is 85% jargon and 15% actual English.
12:19:19 <danharaj_> :D
12:19:39 <Cale> right, so it should be pretty easy for the simple English wikipedia to have good math articles
12:20:43 <danharaj_> Cale: They're still amusing :p
12:21:00 <Cale> I can translate non-English math articles for the most part even when I don't know the language in question, just because it's math :)
12:21:31 <clsmith> trouble is, maths is also a language. and it's got a really dumb alphabet.
12:21:39 <Cale> (particularly when it's math that I actually know already)
12:21:41 <kmc> a lot of maths PhD programs require you to learn to read maths in another language
12:21:56 <kmc> often (in English-speaking schools) French, German, or Russian
12:22:31 <fazzone> I got it!
12:22:36 <Cale> kmc: Yeah, but from what I understand, the test tends to be stupidly easy. Like they'll give you some standard thing like the definition of a group in whatever other language and ask you to translate it.
12:22:43 <kmc> hehe
12:22:47 <danharaj_> kmc: ehh, it's more like they require you to be able to take a dictionary and produce an intelligible rough translation.
12:22:57 <kmc> but you have to know that a field in french is a body!
12:23:04 <kmc> or whatever
12:23:08 <Cale> yeah
12:23:10 <Cale> corps
12:23:12 <danharaj_> Cale: My friend got stuck with translating something Hilbert wrote. German mathematical terminology from a hundred years ago is fucking opaque.,
12:23:27 <Cale> lol
12:23:42 <danharaj_> I know Germans who agree.
12:23:49 <Cale> English mathematical terminology from 100 years ago is also weird
12:23:54 <Cale> It's surprising
12:23:56 <danharaj> indeed.
12:24:20 <mwc> Go back to Newton's time, the conventions are just bizarre. Negative numbers were consistently avoided in favour of moving them to the other side of an equality
12:24:27 <fazzone> that I should be shot for bringing it into being notwithstanding, I got my transpose to work http://paste.pocoo.org/show/446237/ (linduxed)
12:24:30 <Cale> People tend to think that mathematics doesn't change that much, but it's actually changed a lot in the last 50 years
12:24:40 <Cale> at least in terms of the way that we express it
12:25:33 <dolio> Obviously it can't change, since it's merely a description of the ethereal Platonic realm of sets.
12:26:07 <Cale> trololol
12:26:34 <kmc> dolio, itym categories
12:26:51 <clsmith> seriously, in my opinion, common mathematical syntax is so incredibly broken. if only it was more like a program..
12:26:52 <smop> chapter 2 sucess
12:26:59 <companion_cube> you can do math without categories...
12:27:14 <dolio> You can do math without lots of stuff.
12:28:33 <arw_> you can almost do math without the axiom of choice even...
12:28:40 <Cale> clsmith: Mathematical syntax is intended to communicate mathematics between smart humans, not between much dumber computers.
12:28:57 <edwardk> you can do lots of math without the axiom of choice, we tend to call it computer science though
12:29:23 <arw_> clsmith: mathematical syntax is more a human language than a parseable syntax.
12:29:34 <Cale> You can do some math without the axiom of choice, but you lose big chunks of it, including almost all of functional analysis, and some pretty major parts of algebra.
12:30:09 <edwardk> though you can still define some interesting bits of algebra, just everything where Emmy Noether's name comes up goes away ;)
12:30:20 <clsmith> Cale: i'd argue that languages like haskell intend to do both
12:30:34 <dolio> Didn't Bishop do a lot of functional analysis?
12:30:59 <Cale> clsmith: Yeah, but you gain a lot of flexibility if you know that your intended audience is a human and it's not required to communicate with a machine.
12:31:25 <dolio> You just lose all the stuff where you prove, "Every T is P, except that fact is useless if you want concrete examples of it being P."
12:31:39 <clsmith> Cale: maybe so; you also apparently gain the inability to use multi-character variable names
12:31:41 <linduxed> fazzone: what's tr?
12:32:02 <Cale> clsmith: not true at all
12:32:40 * hackagebot representable-profunctors 0.1 - Representable profunctors  http://hackage.haskell.org/package/representable-profunctors-0.1 (EdwardKmett)
12:32:43 <Cale> clsmith: though single letter variable names are common because they make expressions easy to manipulate on paper
12:32:57 <danharaj_> Math notation is really mutable
12:33:07 <danharaj_> It can be switched in the middle of a conversation next to a blackboard.
12:33:11 <arw_> clsmith: the single-character-disease directly comes from the math-is-always-done-on-a-blackboard-disease :>
12:33:13 <Cale> It depends on the intention of the notation. A lot of the names for things are much longer than one letter. :P
12:33:27 <edwardk> ok. representable-profunctors is in
12:33:34 <edwardk> 3 packages for a simple concept. yay
12:33:41 <Cale> Like "representable profunctor" is a good deal longer than one letter
12:33:48 <clsmith> when people publish stuff, they need to expand from arbitrary (and namespace-conflicting) greek letters
12:33:56 <clsmith> Cale: i'm talking notation
12:34:05 <Cale> You're saying that's not notation?
12:34:08 <Cale> ;)
12:34:23 <Cale> There's more to notation than the choice of local variables.
12:34:42 <linduxed> fazzone: i think something broke there... tr is not a function as far as i can find
12:34:47 <monadic> How can I use something like Network.HTTP.getRequest, but for ByteString? The problem seems to be that parseURI is internal...
12:34:56 <fazzone> linduxed: tr is my transpose function?
12:35:20 <fazzone> oh, whoops.  I renamed the function to transpose but forgot to change the recursive call
12:35:29 <linduxed> aaah
12:35:29 <Cale> The one-letter names for things mostly come from setups like "Let V be a Banach space and T be a linear operator V -> V."
12:35:30 <monadic> Oh nevermind, I found it ^_^
12:35:35 <linduxed> fazzone: i'll fix it
12:35:41 <Cale> and apply locally
12:36:40 <Cale> There'll usually be some single-letter names for very commonly used or important stuff which scopes over a whole book or paper.
12:38:57 <clsmith> Cale: in large algorithms, i think it just becomes suoup.
12:38:59 <clsmith> *soup
12:39:14 <fazzone> linduxed: yes>
12:39:24 <Cale> clsmith: Well, some authors are better than others.
12:39:35 <Cale> There's no accounting for some people's taste :P
12:39:48 <arw_> often its just a bunch of conventions to improve readability. as i, j, k are the preferred counters in loops in CS, x is just the preferred unknown and p and q are primes, at least in number theory, in statistics they are probabilities, etc.
12:40:08 <arw_> just saves you from having to read through tons of 'let p and q be primes and ...'
12:40:19 <Cale> I feel like sometimes CS authors overuse notation where English descriptions of things would be fine
12:40:38 <fazzone> I generally thing that longNamesLikeThis are bad for clarity -- if you need them, your functions should be shorter and have more intelligent names (which is not always achievable)
12:40:59 <kmc> Cale, I feel like your statement (call it statement s) has a truth value (call it t) equal to true
12:41:01 <fazzone> I mean, isn't (x:xs) much nicer, if less descriptive, than (firstThing:restOfTheThings)
12:41:03 <Cale> Like, defining things as giant tuples
12:41:07 <kmc> i love introducing and then never using variables
12:41:16 <monadic> Hmm does Network.HTTP not support SSL?
12:41:20 <Cale> instead of just saying what things they consist of
12:41:37 <Cale> (I'm thinking of the definition of most automata)
12:42:07 <thoughtpolice> monadic: don't think so, but http-enumerator is a HTTP client w/ ssl support, fwiw
12:42:51 <monadic> thoughtpolice: I assume that'll work with aeson too via attoparsec-enumerator?
12:43:38 <tswett> @type \y -> [x | x <- y]
12:43:39 <lambdabot> forall t. [t] -> [t]
12:43:40 <dolio> A Turing machine is {A,S,t,s, ...}
12:43:54 <thoughtpolice> monadic: you can probably wire them together, yes. i haven't done it myself, however.
12:44:07 <monadic> thoughtpolice: Argh. 27 uninstalled dependencies... ;(
12:44:12 <Saizan> A Category is {Ob,Hom,.. } ?:)
12:44:32 <thoughtpolice> monadic: i know. :( it's a rather large dependency list. michael is good about making sure it always builds at least...
12:44:43 <monadic> thoughtpolice: Although haskell packages build so fast because most of them are like 1-2 modules anyway
12:45:08 <Cale> kmc: Yeah, that too. Introducing variables for things that you don't ever refer to again is kinda dumb most of the time.
12:46:50 <dainanaki> I'm trying to debug an attoparsec parser, but for some reason I can't get my own error messages to show. I only get a basic: "Failed reading: takeWith". Does anyone have any experience with this?
12:47:15 <monadic> dainanaki: Attoparsec doesn't care about error handling ;) All I can say is to debug the inner parsers
12:48:02 <dainanaki> why even bother with the <?> combinator then
12:48:06 <dainanaki> jeez.
12:48:36 <monadic> dainanaki: I guess to provide at least some error messages, but in general its goal is for speed where no errors should be found in the input
12:49:09 <dainanaki> I understand that point, I just figured it would at least provide the most local error.
12:49:43 * hackagebot roundtrip-xml 0.3.0.0 - Bidirectional (de-)serialization for XML.  http://hackage.haskell.org/package/roundtrip-xml-0.3.0.0 (StefanWehr)
12:51:05 <monadic> thoughtpolice: Is there some kind of intermediate between simpleHTTP and http? I'd like to just specify the url as a string and get the iteratee
12:51:56 <monadic> thoughtpolice: Oh nevermind, parseUrl looks like the trick :)
12:54:33 <hatds> template haskell really needs better documentation
12:55:26 <parcs> hmm, how can i pattern match on a record within a record?
12:56:39 <parcs> never mind, i got it. god that's convoluted
12:56:47 <thoughtpolice> er, well, since records are really just thin veils over the constructor, you can just match in a nested way like you're used to, right? f (Con1 _ (Con2 _ True) ...) = etc?
12:57:04 <clsmith> what's the difference between parsec and attoparsec..?
12:57:16 <thoughtpolice> if you actually want to bring the record names into scope there are some extensions that manage this. RecordWildCards & co
12:57:35 <hatds> attoparsec is only for bytestring input
12:57:58 <monadic> hatds: Or Text
12:58:00 <tromp> > let f (Just (Just x)) = x in f . return . return $ 42
12:58:01 <lambdabot>   42
12:58:27 <thoughtpolice> they're mostly for dealing with different kinds of data. attoparsec is faster in general and only works over bytestrings, but it's designed for things like network protocols and whatnot
12:58:44 * hackagebot profunctor-extras 0.1.2 - Profunctor extras  http://hackage.haskell.org/package/profunctor-extras-0.1.2 (EdwardKmett)
12:58:46 <thoughtpolice> using it isn't always necessarily a win in speed over parsec3 with bytestrings, from what i understand. on different parsers, it can be substantially faster
12:59:04 <thoughtpolice> (also parsec has better err messages among other things, and attoparsec is continuation based where parsec is not)
12:59:05 <dainanaki> I'm currently working on parsing pcap data
12:59:15 <dainanaki> and attoparsec is making me angry
12:59:40 <dainanaki> so, fwiw, attoparsec comes with an anger module
12:59:44 * hackagebot representable-profunctors 0.1.0.1 - Representable profunctors  http://hackage.haskell.org/package/representable-profunctors-0.1.0.1 (EdwardKmett)
12:59:48 <edwardk> now with profunctor collages
13:03:43 <c_wraith> profuntors went to college?  Is that part of the normal path to professionalism for functors?
13:03:44 * hackagebot representable-profunctors 0.1.0.2 - Representable profunctors  http://hackage.haskell.org/package/representable-profunctors-0.1.0.2 (EdwardKmett)
13:05:40 <kmc> pro functors don't have time for that sissy book-learnin'
13:14:36 <conal> solidsnack: ping
13:24:45 <byorgey> edwardk: why does the github page for representable-profunctors say "Nothing to see here yet, move along"?
13:25:03 <edwardk> probably because i haven't pushed it there yet =)
13:25:24 <byorgey> I suppose that could explain it =)
13:25:35 <edwardk> pushing in a sec. adding collages to profunctor-extras correctly, then adding (co)representable profunctor composition
13:26:41 <byorgey> take your time, I was just curious =)
13:28:53 * hackagebot profunctor-extras 0.2 - Profunctor extras  http://hackage.haskell.org/package/profunctor-extras-0.2 (EdwardKmett)
13:29:17 <edwardk> try now. loading to hackage
13:29:53 * hackagebot representable-profunctors 0.2.0 - Representable profunctors  http://hackage.haskell.org/package/representable-profunctors-0.2.0 (EdwardKmett)
13:30:26 <conal> @seen solidsnack
13:30:26 <lambdabot> Unknown command, try @list
13:30:26 <preflex_>  solidsnack was last seen on #haskell 284 days, 1 hour, 40 minutes and 46 seconds ago, saying: zygoloid: However, once you have worked with Ruby modules that try to connect to a database when you load them into your interpreter to inspect some of their definitions, you will be glad for the absence of this functionality :)
13:30:42 <conal> @list
13:30:42 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
13:30:52 <byorgey> edwardk: note, the representable-profunctors .cabal file seems to list a git:// URL as the home page rather than http://, which makes firefox complain that it doesn't know what to do with it
13:30:59 <edwardk> gah
13:31:00 <edwardk> i missed one
13:31:16 <conal> oh, wow. solidsnack has been away for a good while.
13:31:54 * hackagebot representable-profunctors 0.2.0.1 - Representable profunctors  http://hackage.haskell.org/package/representable-profunctors-0.2.0.1 (EdwardKmett)
13:32:17 <conal> i'm trying to use the maccatcher package (MAC address capturing) on mac os x. found that the docs say it works for windows & linux.
13:32:52 <conal> has anyone here played with hums (upnp/dlna server in haskell)?
13:33:18 <edwardk> byorgey: that work now?
13:33:25 <byorgey> edwardk: yep, thanks
13:35:54 * hackagebot semigroups 0.5.0.1 - Haskell 98 semigroups  http://hackage.haskell.org/package/semigroups-0.5.0.1 (EdwardKmett)
13:36:54 * hackagebot contravariant 0.1.2.1 - Haskell 98 contravariant functors  http://hackage.haskell.org/package/contravariant-0.1.2.1 (EdwardKmett)
13:38:54 * hackagebot distributive 0.2.0.1 - Haskell 98 Distributive functors -- Dual to Traversable  http://hackage.haskell.org/package/distributive-0.2.0.1 (EdwardKmett)
13:39:54 * hackagebot comonad 1.1.0.1 - Haskell 98 comonads  http://hackage.haskell.org/package/comonad-1.1.0.1 (EdwardKmett)
13:40:55 * hackagebot data-lens 1.8.0.1 - Haskell 98 Lenses  http://hackage.haskell.org/package/data-lens-1.8.0.1 (EdwardKmett)
13:41:55 * hackagebot comonad-transformers 1.8.0.1 - Comonad transformers  http://hackage.haskell.org/package/comonad-transformers-1.8.0.1 (EdwardKmett)
13:41:56 <Evious> What's a good tutorial/guide/paper about these "lens" things?
13:42:35 <edwardk> twan van laarhoven has a nice blog post that describes a few. i have a talk i gave in scala that is on youtube that covers their basic usage
13:46:08 <kmc> conal has blog posts about "semantic editor combinators" which are very similar, iirc
13:46:27 <kmc> also the fclabels haddock has a full tutorial in
13:46:46 <mreh> :q
13:46:58 <kmc> ultimately not much to it; they're just a getter and a setter paired up
13:47:12 <Saizan> "semantic editor combinator" is quite a big name
13:47:29 <kmc> that might be why "lens" is the more popular term ;)
13:48:20 <edwardk> personally i think the semantic editor combinators serve a different purpose, they move you around in some combination of (bi)functors to some subset
13:48:44 <edwardk> and usually only provide the mutation rather than the full getter/setter functionality
13:49:16 <kmc> isn't that what composition of lenses does?
13:49:45 <edwardk> composition of lenses still gives you a lens. the semantic editor combinators only give you a 'modify' basically
13:50:15 <jonkri> would it not be nice if OverloadedStrings worked with string concatenation? :)
13:53:10 <parcs> :t (++)
13:53:11 <lambdabot> forall m. (Monoid m) => m -> m -> m
13:53:18 <tommd> jokri: So you propose a partial evaluation in which all strings are of type String, then an application of fromString?
13:53:57 <tommd> That is considerably more complex than a simple application of a function to all string literals.
13:55:08 <jonkri> i'm not proposing anything :)
13:55:13 <jonkri> i give up :)
13:56:15 <jonkri> thanks for the explanation :)
13:56:50 <dainanaki> Why does lambdabot think (++) is over mono ids?
13:56:54 <dainanaki> *monoids
13:57:05 <dainanaki> I thought it was only over lists
13:57:09 <kmc> non-default imports
13:57:12 <kmc> "Caleskell"
13:57:16 <kmc> :t (.)
13:57:17 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:57:49 <dainanaki> i'd like to know what package those are in
13:58:02 <dainanaki> it looks like a prelude without training wheels
13:58:12 <shachaf> It's in L.hs.
13:58:16 <shachaf> @version
13:58:16 <lambdabot> lambdabot 4.2.2.1
13:58:16 <lambdabot> darcs get http://code.haskell.org/lambdabot
13:58:41 <shachaf> http://code.haskell.org/lambdabot/State/L.hs
13:59:06 <shachaf> > cake
13:59:07 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
13:59:13 <dainanaki> heh
13:59:14 <shachaf> > map head cake
13:59:15 <lambdabot>   "OOTFOTOTDFFFFFPFCOAUFANTOATTOOTOOTASCIICAT"
13:59:32 <kmc> > concat $ transpose cake
13:59:33 <lambdabot>   "OOTFOTOTDFFFFFPFCOAUFANTOATTOOTOOTASCIICATnnhonhnwoiiiiiuianlniniwnnwwnnhn...
13:59:35 <dainanaki> ASCII Cat
13:59:59 * hackagebot comonad-extras 0.4.0 - Comonad transformers requiring extensions to Haskell 98  http://hackage.haskell.org/package/comonad-extras-0.4.0 (EdwardKmett)
14:01:42 <monadic> whats the point of the release announcements if you can't view docs :(
14:02:18 <edwardk> monadic: =( basically i'm just widening the dependencies as someone asked for. apparently its a pain to work with 7.2 because of the bumped base
14:02:59 * hackagebot data-lens-fd 1.8.0.1 - Lenses  http://hackage.haskell.org/package/data-lens-fd-1.8.0.1 (EdwardKmett)
14:03:18 <edwardk> at least that is what all of the x.y.z.1 ones are. any others are actual changes =)
14:03:59 <edwardk> you should be able to follow the link to the source repository though
14:04:08 <edwardk> some of them are still borked and show as git:// though
14:05:00 * hackagebot data-lens 1.8.0.2 - Haskell 98 Lenses  http://hackage.haskell.org/package/data-lens-1.8.0.2 (EdwardKmett)
14:06:00 * hackagebot data-lens-fd 1.8.0.2 - Lenses  http://hackage.haskell.org/package/data-lens-fd-1.8.0.2 (EdwardKmett)
14:08:00 * hackagebot semigroups 0.5.0.2 - Haskell 98 semigroups  http://hackage.haskell.org/package/semigroups-0.5.0.2 (EdwardKmett)
14:09:00 * hackagebot comonad-transformers 1.8.0.2 - Comonad transformers  http://hackage.haskell.org/package/comonad-transformers-1.8.0.2 (EdwardKmett)
14:11:00 * hackagebot comonad-extras 0.4.0.1 - Comonad transformers requiring extensions to Haskell 98  http://hackage.haskell.org/package/comonad-extras-0.4.0.1 (EdwardKmett)
14:11:02 * hackagebot categories 0.58.0.1 - categories from category-extras  http://hackage.haskell.org/package/categories-0.58.0.1 (EdwardKmett)
14:14:23 <c_wraith> edwardk: which is the lenses library that shouldn't be used?
14:14:36 <monadic> Is using withManager for each transfer with http-enumerator costly?
14:14:54 <edwardk> c_wraith: i'm not fond of henning's or of the one that uses state everywhere.
14:15:01 <edwardk> fclabels or data-lens are fine
14:15:06 <edwardk> though i'm biased towards data-lens ;)
14:15:32 <edwardk> i think the state one is Lenses
14:15:47 <edwardk> i only remember because it conflicted with the name i was going to give my package
14:16:58 <kmc> better name yours co-lensoids instead
14:17:01 * hackagebot keys 1.8.0.1 - Keyed functors and containers  http://hackage.haskell.org/package/keys-1.8.0.1 (EdwardKmett)
14:17:09 <edwardk> i'll get on that
14:17:23 <edwardk> and i'll add corepresentable-colensoids when i get a chance
14:19:02 * hackagebot representable-functors 2.0.0.1 - Representable functors  http://hackage.haskell.org/package/representable-functors-2.0.0.1 (EdwardKmett)
14:20:57 <ddarius> The Monoid definition with (++) is not a different import but a lambdabot-only addition.
14:21:02 * hackagebot kan-extensions 2.0.0.1 - Kan extensions, the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-2.0.0.1 (EdwardKmett)
14:21:12 <edwardk> heya ddarius
14:21:22 <ddarius> edwardk: Hola.
14:21:47 <edwardk> i presume this means you are back from thailand?
14:22:24 <ddarius> edwardk: Yes, though I could have gotten on in Thailand.
14:23:02 * hackagebot adjunctions 2.0.0.1 - Adjunctions  http://hackage.haskell.org/package/adjunctions-2.0.0.1 (EdwardKmett)
14:26:29 <edwardk> i thought of you when i was writing some co-(geometric algebra) code the other week. =P
14:27:03 * hackagebot data-lens-template 1.8.0.1 - Utilities for Data.Lens  http://hackage.haskell.org/package/data-lens-template-1.8.0.1 (EdwardKmett)
14:28:01 <thoughtpolice> hmm, edwardk is dominating the hackage "what's new page." i do not find this very surprising for some reason.
14:28:02 <edwardk> https://github.com/ekmett/algebra/blob/master/Numeric/Coalgebra/Geometric.hs
14:28:04 * hackagebot either 0.2.2.1 - Haskell 98 either monad transformer  http://hackage.haskell.org/package/either-0.2.2.1 (EdwardKmett)
14:28:17 <edwardk> i'm more surprised when i'm not ;)
14:28:21 <thoughtpolice> apparently i just invoked even more domination by mentioning it!
14:29:07 <Raynes> DOMEENASHUN
14:30:04 * hackagebot graphs 0.3.2.1 - A simple monadic graph library  http://hackage.haskell.org/package/graphs-0.3.2.1 (EdwardKmett)
14:30:25 <kmc> does hackage have achievements
14:30:32 <monochrom> hahaha
14:30:32 <edwardk> hahahaha
14:31:04 * hackagebot semigroupoids 1.2.2.1 - Haskell 98 semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-1.2.2.1 (EdwardKmett)
14:33:04 * hackagebot semigroupoid-extras 0.2.4.1 - Semigroupoids requiring Haskell extensions  http://hackage.haskell.org/package/semigroupoid-extras-0.2.4.1 (EdwardKmett)
14:33:41 <edwardk> hey i have at least 9-10 packages that i don't have to refresh ;)
14:34:04 * hackagebot streams 0.8.0.1 - Various Haskell 2010 stream comonads  http://hackage.haskell.org/package/streams-0.8.0.1 (EdwardKmett)
14:34:17 <monochrom> speaking of the devil...
14:34:50 <monochrom> or even, the devil speaking... :)
14:35:05 * hackagebot syb-extras 0.2.1.1 - Higher order versions of the Scrap Your Boilerplate classes  http://hackage.haskell.org/package/syb-extras-0.2.1.1 (EdwardKmett)
14:35:06 <edwardk> =P
14:35:36 * monochrom surrenders!
14:36:48 <copumpkin>  /mode +q hackagebot
14:36:56 <edwardk> hahaha
14:37:05 * hackagebot prelude-extras 0.1.0.2 - Haskell 98 - higher order versions of Prelude classes  http://hackage.haskell.org/package/prelude-extras-0.1.0.2 (EdwardKmett)
14:37:32 <shachaf> edwardk: What are you updating all these packages for?
14:37:32 <thoughtpolice> IT JUST WILL
14:37:33 <thoughtpolice> NOT
14:37:33 <thoughtpolice> STOP
14:37:55 <shachaf> ddarius: Were you in Thailand?
14:38:06 <kmc> that's a very personal question
14:38:19 <dolio> Is it?
14:38:23 <edwardk> shachaf: i wrote some new profunctor packages, which incurred a couple of changes, but then i also wanted to fix up some systemically broken homepage urls, and widen the dependency on base so that 7.2 can compile them
14:38:55 * ddarius just assumes that profunctors are in the air.
14:39:17 <edwardk> ddarius: just added them coz they seemed fashionable =P
14:39:35 <copumpkin> that's why I do all my CT stuff
14:39:37 <copumpkin> fashion
14:39:38 <dolio> Added them to a new package.
14:40:28 <edwardk> that explains your trendy 'Helbotica' t-shirt
14:40:38 <Saizan> he just didn't want someone else using that package name
14:41:05 <nus> heh
14:41:06 * hackagebot representable-tries 2.0.0.1 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-2.0.0.1 (EdwardKmett)
14:41:13 * shachaf considers making a prelude-extras-extras package.
14:41:16 <nus> hackage namesquotting?-)
14:41:46 <dolio> shachaf: You should grab amateurfunctors while it's still around.
14:41:59 <edwardk> nus: nah, just wanted to write up profunctors, define profunctor composition and provide a semigroupoid for collages
14:42:07 <kmc> reperesentabe-semigroupoid-comonoids
14:42:18 <copumpkin> yeah, we definitely need a comonoids package
14:42:23 <edwardk> all the comonoids are in algebra at the moment
14:42:25 <kmc> data-adjunction-extras-transformer
14:42:33 <kmc> what's a comonoid copumpkin?
14:42:38 <aLgEBrA> yes ?
14:42:41 <copumpkin> a monoid object in the opposite category
14:43:01 <edwardk> i sense there is going to be an edwardk package naming bot command soon
14:43:08 <shachaf> presentable-functors
14:43:41 * ddarius would be more interested in left exact rather than presentable functors.
14:44:12 <shachaf> Hackage needs an edwardk category.
14:44:23 <kmc> reperesentabe-semigroupoid-comonoids: Representable semigroupoid comonoids for free
14:44:33 * benmachine giggles
14:44:51 <dented42> would it be possible to build GHC with hugs?
14:44:54 <copumpkin> > map (intercalate "-") (sequence [["monad", "monoid", "semigroupoid", "semigroup"], ["transformers", "extras"], ["", "extras"]])
14:44:55 <lambdabot>   ["monad-transformers-","monad-transformers-extras","monad-extras-","monad-e...
14:44:57 <ddarius> dented42: No.
14:45:08 <kmc> sadly
14:45:11 <edwardk> not nearly enough 'co' constructions in there
14:45:15 <copumpkin> oh, of course
14:45:22 <ddarius> or 'representable'
14:45:24 <nus> semicoprofunctors
14:45:29 <kmc> i really think each badass self-hosting optimizing compiler should come with a portable ANSI C bytecode interpreter
14:45:30 <djahandarie> Holy smokes, it's ddarius
14:45:33 <benmachine> nus: coprofunctors o_O
14:45:35 <copumpkin> well, you guys can play with the components
14:45:41 <kmc> and with a copy of the bytecodes for the compiler
14:45:48 <kmc> it makes bootstrapping so much easier
14:45:48 <ddarius> kmc: ghc foo.c
14:45:51 <copumpkin> benmachine: don't even want to think about what that means
14:45:51 <benmachine> "shitty type functions"
14:46:01 <kmc> iirc that's how ocamlc works
14:46:07 * hackagebot recursion-schemes 1.8.0.1 - Generalized bananas, lenses and barbed wire  http://hackage.haskell.org/package/recursion-schemes-1.8.0.1 (EdwardKmett)
14:46:40 <thoughtpolice> kmc: yep, they have a bootstrap ocaml you compile first that's then run to compile everything else (including normal ocamlc, ocamlc.opt, etc)
14:47:07 * hackagebot pointed 1.8.0.1 - Haskell 98 Pointed and copointed data  http://hackage.haskell.org/package/pointed-1.8.0.1 (EdwardKmett)
14:49:08 * hackagebot numeric-extras 0.0.2.1 - Useful tools from the C standard library  http://hackage.haskell.org/package/numeric-extras-0.0.2.1 (EdwardKmett)
14:49:54 --- mode: ChanServ set +o copumpkin
14:50:01 --- mode: copumpkin set +q hackagebot!*@*
14:50:07 <edwardk> ack!
14:50:14 <kmc> haha
14:50:29 --- mode: copumpkin set -q hackagebot!*@*
14:50:32 --- mode: copumpkin set -o copumpkin
14:50:40 <thoughtpolice> edwardk unlocked an achievement: annoy the hell out of everybody with hackagebot
14:50:42 <edwardk> it'll promise to be good
14:51:01 <thoughtpolice> that's probably a first i would imagine.
14:51:04 <dainanaki> I'm doing some heap profiling on cost centers in an app, but part of the names of the cost centers are elided. how can I get it to show the full names
14:51:41 <edwardk> he did successfully mute at least one package =)
14:51:50 <Eliel> copumpkin: is roconnor usually busy with things?
14:51:58 <copumpkin> not sure
14:52:08 * hackagebot monad-st 0.2.0.1 - Provides a MonadST class  http://hackage.haskell.org/package/monad-st-0.2.0.1 (EdwardKmett)
14:52:18 <Eliel> does anyone here know?
14:53:51 <edwardk> eliel: well, he is working and stuff, not sure what you mean
14:54:08 * hackagebot monad-products 0.2.0.1 - Haskell 98 monad products  http://hackage.haskell.org/package/monad-products-0.2.0.1 (EdwardKmett)
14:54:17 <benmachine> edwardk: why doesn't your monadtrans instance for monadst overlap the st instance?
14:54:25 <benmachine> is it the different kinds?
14:54:26 * ddarius suspects roconnor fills all of his with existing.
14:54:29 <edwardk> benmachine: kinds
14:54:29 <edwardk> yeah
14:54:32 <benmachine> oh
14:54:33 <benmachine> clever :o
14:54:34 <Eliel> wondering how long I can expect it to take for him to have time to get to my email :)
14:54:48 <edwardk> same game could be played with IO
14:54:59 <edwardk> to get a 'define once' MonadIO
14:55:06 <benmachine> could be but isn't?
14:55:08 * hackagebot intervals 0.2.0.2 - Interval Arithmetic  http://hackage.haskell.org/package/intervals-0.2.0.2 (EdwardKmett)
14:55:11 <edwardk> correct
14:55:22 <benmachine> is there a sensible reason for this
14:55:31 <benmachine> or is it hysterical raisins again
14:55:32 <edwardk> timidity?
14:55:41 <benmachine> heh, fair enough
14:55:54 <benmachine> "in case someone invents IOT one day"
14:57:15 * hackagebot free 1.8.0.1 - Monads for free  http://hackage.haskell.org/package/free-1.8.0.1 (EdwardKmett)
15:00:03 <sipa> has it stopped?
15:01:26 <edwardk> nah
15:04:45 <edwardk> the shelling continues
15:05:11 * hackagebot rope 0.6.1.1 - Tools for manipulating fingertrees of bytestrings with optional annotations  http://hackage.haskell.org/package/rope-0.6.1.1 (EdwardKmett)
15:06:23 <kmc> edwardk, did you write these all today? ;P
15:07:00 <edwardk> yeah, started over from scratch =P
15:07:12 <edwardk> you're watching in realtime man
15:09:13 * hackagebot unboxed-containers 0.0.2.2 - Self-optimizing unboxed sets using view patterns and data families  http://hackage.haskell.org/package/unboxed-containers-0.0.2.2 (EdwardKmett)
15:09:35 <edwardk> i _think_ that is everything that i need to update
15:11:50 <fragamus> :t runListT
15:11:51 <lambdabot> Not in scope: `runListT'
15:13:12 <benmachine> ListT smells
15:13:15 <benmachine> true fact
15:17:54 <burbul> @pl \s -> runErrorT s >>= either (hPutStr stderr) (print)
15:17:55 <lambdabot> (either (hPutStr stderr) print =<<) . runErrorT
15:18:11 <int80_h> what is the best approach for removing leading spaces in a String?
15:18:34 <benmachine> int80_h: dropWhile?
15:18:34 <monochrom> dropWhile (' ' ==)
15:18:52 <int80_h> ah I was trying to use elem with dropWhile
15:19:31 <c_wraith> :t isSpace
15:19:32 <lambdabot> Char -> Bool
15:19:44 <c_wraith> dropWhile isSpace, if you want to be unicode-friendly
15:19:56 <int80_h> is isSpace in Prelude?
15:20:02 <c_wraith> it's in Data.Char
15:20:02 <monochrom> and get rid of tabs and newlines too
15:20:09 <coppro> dropWhile (`elem` [' ', '\t', '\n', '\r', '\v']) as an example, but use isSpace
15:22:37 <benmachine> (`elem " \t\n\r\v") if you are lazy
15:22:58 <benmachine> sufficiently lazy that you leave off one of your `s and thus get a parse error
15:24:58 <companion_cube> it seems that "haskell excels" is quite a good tongue twister
15:26:08 <sipa> well haskell and excel are both purely functional languages!
15:27:29 <kmc> haha
15:27:51 <dainanaki> How can I  get hp output to print the full names of cost centers?
15:28:44 <dainanaki> * also, how can I get it to produce colored ps output
15:29:56 <dainanaki> never mind on the second question
15:34:22 <dainanaki> and the first
15:37:25 * hackagebot profunctor-extras 0.3.0 - Profunctor extras  http://hackage.haskell.org/package/profunctor-extras-0.3.0 (EdwardKmett)
15:40:27 * hackagebot representable-profunctors 0.3.0 - Representable profunctors  http://hackage.haskell.org/package/representable-profunctors-0.3.0 (EdwardKmett)
15:40:54 <benmachine> edwardk: what are you even doing to all these poor packages?
15:41:36 <edwardk> these last two were actual new content
15:43:18 <edwardk> i was going through and adding the (->) identity laws to profunctor composition.
15:47:05 <fragamus> yo
15:47:17 <monadic> Is there a good way to incrementally parse JSON (ie, the Value type generated by aeson), for use with enumerator?
15:47:28 <fragamus> http://hpaste.org/49521
15:48:32 <thoughtpolice> monadic: attoparsec-enumerator automatically can convert a attoparsec Parser to a enumerator, so you can just combine aeson + attoparsec-enumerator
15:49:16 <monadic> thoughtpolice: Yes, I figured that part out already
15:49:33 <monadic> thoughtpolice: Let me explain more, I'm writing a client library for Github Gists. Hence, I need to be going from Value -> Gist
15:49:51 <monadic> thoughtpolice: It would be nice to have that as part of the Iteratee, I think
15:50:55 <fragamus> well I want to print the list of states
15:51:45 <monadic> The internal parser from Aeson doesn't seem fit for an iteratee based solution, though
15:52:32 * hackagebot profunctor-extras 0.3.1 - Profunctor extras  http://hackage.haskell.org/package/profunctor-extras-0.3.1 (EdwardKmett)
15:53:11 <fragamus> btw, I am using the good MList
15:54:32 * hackagebot representable-profunctors 0.3.1 - Representable profunctors  http://hackage.haskell.org/package/representable-profunctors-0.3.1 (EdwardKmett)
15:58:13 <mm_freak> i think, i haven't stated it today yet
15:58:18 <mm_freak> i hate PHP
15:59:13 <danharaj> A good habit to form
15:59:19 <danharaj> is regularly hating php
16:00:17 <dainanaki> this may be a silly question, but what's a reasonable amount of memory usage for a command-line parser using bytestrings?
16:00:35 <HugoDaniel> :)
16:00:41 <HugoDaniel> php is prone to hate
16:00:52 <edwardk> dainanaki: somewhere less than all of it
16:01:05 <parcs> dainanaki: at most 640kb
16:01:19 <dainanaki> edwardk: indeed :)
16:01:20 <edwardk> parcs: that should be enough for anybody
16:01:33 * hackagebot representable-profunctors 0.4.0 - Representable profunctors  http://hackage.haskell.org/package/representable-profunctors-0.4.0 (EdwardKmett)
16:01:59 <Nimatek> Welcome to #haskell cabaret.
16:03:55 <dainanaki> ok, well more specifically, I've got a base memory usage of about 3k for all of the functions in my program except for one. This one causes total heap usage to spike up to 16k for ~0.5 seconds or so.
16:04:04 <dainanaki> several times
16:05:39 <dainanaki> for what it's worth, it's an enumerator and it might be due to chunking behaviors, but I'm not really sure
16:11:07 <ddarius> 16k!  Good lord that's a lot of heap.
16:11:27 <kmc> haha
16:20:21 <dainanaki> Well, I'm just paranoid I guess
16:24:37 <monadic> okay ive been staring at the same 3 line code for a parse error... this is driving me insane
16:24:51 <kmc> i'll take a look :)
16:25:24 <monadic> kmc: https://gist.github.com/1105551
16:25:39 <monadic> postRequest is of type `String -> Request IO`
16:26:49 <monadic> oh wow
16:26:52 <monadic> I am so stupid
16:26:56 <monadic> nevermind ;)
16:28:31 <aninhumer> IRC idlers make for good rubber ducks :P
16:28:45 <ddarius> aninhumer: They don't float well.
16:29:37 * hackagebot groupoids 0.1 - Haskell 98 Groupoids  http://hackage.haskell.org/package/groupoids-0.1 (EdwardKmett)
16:35:08 <djahandarie> edwardk, I assume this is step one towards implementing HTT
16:35:15 <edwardk> =P
16:36:40 * hackagebot groupoids 0.1.1 - Haskell 98 Groupoids  http://hackage.haskell.org/package/groupoids-0.1.1 (EdwardKmett)
16:37:39 * hackagebot semigroupoid-extras 0.2.5 - Semigroupoids requiring Haskell extensions  http://hackage.haskell.org/package/semigroupoid-extras-0.2.5 (EdwardKmett)
16:59:43 * hackagebot semigroupoid-extras 0.2.6 - Semigroupoids requiring Haskell extensions  http://hackage.haskell.org/package/semigroupoid-extras-0.2.6 (EdwardKmett)
17:07:30 <Cale> semigroupoid, wtf? :)
17:07:55 <djahandarie> Where have you been Cale? He's been ranting about them for awhile :p
17:08:09 <fxr> :)
17:11:09 <fazzone> Is it just me, or is the syntax for case-expressions strange?  Why 'case (something) of {patterns}'?  to me it makes more sense the other way, but why use case/of at all?  why not choose something like 'match (something) against {patterns}' ?
17:12:53 <kmc> in ML it's "match ... with ..."
17:13:16 <kmc> i don't know why haskell uses "case"; the choice of keywords is uninteresting
17:13:52 <kmc> i think putting the scrutinee first makes sense
17:14:18 <kmc> the scrutinee has to be evaluated before the patterns can be tested
17:14:46 <fazzone> kmc: it's definitely a very minor quibble, sure -- it just seems strange.  I suppose it makes no difference once you learn it.  I do think the scrutinee-first way makes more sense (more like an imperative 'switch'), but it makes no sense to read that way with the current case/of keywords
17:15:34 <fragamus> dmwit: are you here?
17:16:36 <kmc> i would be interested to know the answer, if only for trivia's sake
17:16:51 <aavogt> > case undefined of Endo (Endo a) -> 1
17:16:52 <lambdabot>   Couldn't match expected type `t -> t'
17:16:52 <lambdabot>         against inferred type `Data.M...
17:17:12 <aavogt> > case undefined of Endo a -> 1
17:17:13 <lambdabot>   1
17:17:42 <kmc> fine, it doesn't *always* have to be evaluated ;)
17:17:51 <kmc> also the patterns might be only wildcard or variable patterns
17:19:16 <aavogt> `where' is an example of when you might define things after you use them
17:19:29 <siracusa> @src Endo
17:19:29 <lambdabot> Source not found. Maybe you made a typo?
17:19:33 <aavogt> so it wouldn't be all that odd if case was flipped around
17:19:40 <aavogt> siracusa: just a random newtype
17:19:48 <kmc> yeah, 'where' bugs me for that reason
17:21:54 <fazzone> are where and let in any way different besides their order?
17:22:12 <kmc> "where" can scope over multiple guards on a single equation
17:22:30 <hpc> irritatingly, where doesn't scope over multiple patterns
17:22:41 <kmc> "where" can't be used to build expressions directly; it attaches to a declaration
17:22:45 <kmc> "let .. in .." is an expression
17:22:45 <aavogt> @wiki let_vs_where
17:22:45 <lambdabot> http://www.haskell.org/haskellwiki/let_vs_where
17:23:12 <kmc> they are different syntactically but have the same semantics
17:23:20 <aavogt> oh it's called http://www.haskell.org/haskellwiki/Let_vs._Where
17:25:04 <aavogt> that last section there is pretty tricky
17:33:22 <linduxed> ok so i've got this transpose code working, but the thing is that if i put in this text http://paste.pocoo.org/show/446387/ then i expect to get http://paste.pocoo.org/show/446388/ , but instead i get this http://paste.pocoo.org/show/446389/
17:33:33 <linduxed> so somehow i need to get those spaces in there
17:33:45 <fazzone> linduxed: did you read mine?
17:33:57 <linduxed> fazzone: yours did the same thing
17:34:06 <fazzone> where is the source
17:34:40 <linduxed> fazzone: http://paste.pocoo.org/show/446237/
17:34:56 <linduxed> fazzone: that's yours, and it did the same thing
17:36:19 <linduxed> fazzone: btw it turned out that all i needed to really do to make my code work was to exchange the first "map safeHead inLines" for concatMap safeHead inLines"
17:36:34 <aavogt> > getZipList $ sequenceA $ map ZipList ["abc","def","ghi"]
17:36:35 <lambdabot>   Not in scope: `sequenceA'
17:36:50 <fazzone> okay, well the transpose in Data.List does the same thing as mine
17:37:02 <fazzone> what you want it transpose . map (++ (repeat ' '))
17:37:29 <aavogt> > getZipList $ Data.Traversable.sequenceA $ map ZipList ["abc","def","ghi"]
17:37:30 <lambdabot>   ["adg","beh","cfi"]
17:37:49 <fazzone> Oh wait, that makes mine not work
17:38:35 <fazzone> well obviously, because that makes infinite lists -- You can do the same sort of thing to get that behavior, but it'd most likely be really ugly
17:39:06 <linduxed> fazzone: hmmm, yeah i guess it could get ugly... i've already bumped into the infinite loops
17:42:01 <aavogt> > getZipList $ Data.Traversable.sequenceA $ map ZipList $ map words "this is ragged text too a"
17:42:02 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
17:42:02 <lambdabot>         against inferred ty...
17:42:09 <aavogt> > getZipList $ Data.Traversable.sequenceA $ map ZipList $ words "this is ragged text too a"
17:42:10 <lambdabot>   ["tirtta"]
17:42:29 <fazzone> linduxed: see http://paste.pocoo.org/show/446393/ -- transpose . pad will give you what you want
17:43:19 <fazzone> linduxed: also, if you ensure that all [String]s that transpose sees are padded, you can eliminate the 'what' function and use map tail instead of concatMap what
17:43:29 <fazzone> linduxed: i think
17:44:56 <linduxed> well thx, that pad function did the trick
17:45:16 <aavogt> > map (map fromJust . takeWhile isJust) $ getZipList $ Data.Traversable.sequenceA $ map (ZipList . (++repeat Nothing)) $ map (map Just) $ words "this is ragged text too a"
17:45:17 <lambdabot>   ["tirtta","hsaeo","i","s","","","","","","","","","","","","","","","","","...
17:46:02 <linduxed> fazzone: oh i see, so you add spaces before transpose gets to work with it...
17:46:24 <linduxed> fazzone: i was thinking of trying to add them during the runtime of transpose
17:46:33 <linduxed> fazzone: i guess that could be trickier
17:47:05 <fazzone> linduxed: http://paste.pocoo.org/show/446399/
17:48:12 <fazzone> linduxed: hold on, i'm not sure that works :/
17:48:38 <fazzone> ah no wait, it does
17:51:11 <fazzone> You can remove the ugly 'takeWhile (not . null)' if you add tr ([]:_) = [[]], but you're still left with a [] on the end every time .. hmm
18:05:57 <amindfv> what should I do when I want to do IO things and CGI things inside one do-block? I keep getting "No instance for (MonadCGI IO) arising from a use of output"
18:06:21 * shachaf wonders what "CGI things" are.
18:06:24 <shachaf> liftIO might work.
18:06:52 <amindfv> shachaf: :) renderHtml etc.
18:07:29 <amindfv> and "IO things" are doesFileExist, ...
18:08:11 <c_wraith> amindfv: liftIO is probably the answer.
18:08:38 <c_wraith> though the CGI package really doesn't impress me
18:09:02 <shachaf> amindfv: I've never heard of renderHtml.
18:09:14 <linduxed> fazzone: well you know, i think that first addition of pad did just fine, thx for the idea, code and help
18:09:17 <shachaf> You should mention the name of the package you're using, or something. :-)
18:09:19 <c_wraith> but yeah
18:09:20 <c_wraith> type CGI a = CGIT IO a
18:09:29 <c_wraith> shachaf: the name of the package is "cgi" :P
18:09:30 <shachaf> Anyway, liftIO is somewhat limited.
18:09:35 <aavogt> > takeWhile (not . all (==' ')) $ ala ZipList traverse $ map (++repeat ' ') ["abcd","xy","r","","d"]
18:09:36 <lambdabot>   Not in scope: `traverse'
18:09:38 <shachaf> c_wraith: Fine, but it's not standard, is it?
18:09:44 <aavogt> > takeWhile (not . all (==' ')) $ ala ZipList Data.Traversable.traverse $ map (++repeat ' ') ["abcd","xy","r","","d"]
18:09:46 <c_wraith> MonadIO m => MonadIO (CGIT m)
18:09:46 <lambdabot>   ["axr d","by   ","c    ","d    "]
18:10:05 <shachaf> You can't do e.g. withOpenFile, or bracket, or catch, with liftIO.
18:10:09 <c_wraith> shachaf: it's the only real package for doing cgi.  It's just that doing cgi is a very non-standard thing.
18:11:16 <c_wraith> heh.  this library has a whole bunch of its own error-handling functions.  Just because of the limitations of IO
18:11:25 <c_wraith> I really think more things need to start using monad-control
18:11:36 <amindfv> shachaf: http://www.haskell.org/haskellwiki/Practical_web_programming_in_Haskell uses is in most examples eg. (output . renderHtml)
18:13:28 <amindfv> c_wraith: why not, and do you have any recommendations? I'm not looking for a web framework.
18:15:04 <dmwit> c_wraith: Considering that there's an overlap between the authors of "cgi" and "monad-control", I'm guessing "cgi" predates "monad-control".
18:15:37 <dmwit> (And, according to Hackage, the last version of cgi released predates the first version of monad-control released.)
18:16:01 <c_wraith> well, like I said.  No one uses cgi anymore.  :)
18:16:20 <aavogt> c_wraith: monad-control  or MonadCatchIO?
18:16:36 <c_wraith> aavogt: monad-control.  It actually works.  MonadCatchIO is broken.
18:17:14 <c_wraith> It's more complicated, so it's harder to really grasp.  But it's more complicated because it handles situations correctly that MonadCatchIO does not.
18:17:32 <aavogt> in what way? The instances in MonadCatchIO look like how I'd write catch etc. for those transformed monads
18:17:59 <c_wraith> Doesn't work for ListT IO
18:18:24 <c_wraith> especially not the support functions, like bracket and finally
18:18:55 <c_wraith> those only work in a *tiny* subset of cases.  (when (>>=) doesn't provide any flow-control, basically)
18:21:52 <aavogt> for more popular transformers, there's only one correct way:     catchReaderT :: ReaderT r IO a -> (e -> ReaderT r IO a) -> ReaderT r IO a; catchReaderT x f = ReaderT $ \r -> catch (runReader x r) (\e -> runReader (f e) r)
18:22:59 <c_wraith> Basically, MonadCatchIO is designed specifically for the case of things that have the exact same control flow as IO itself does.
18:23:16 <c_wraith> Anything that presents an alternative control flow won't work right.
18:23:46 <aavogt> c_wraith: there's no MonadCatchIO (ListT IO)  anyways
18:24:08 <c_wraith> aavogt: check the other MonadCatchIO.  I know one of them had it, one didn't.
18:24:11 <aavogt> the ErrorT might be seen as a control flow-sort of thing
18:24:21 <c_wraith> ErrorT is definitely control-flow
18:24:29 <c_wraith> and so definitely wrong in the presence of bracket and finally
18:32:35 <huangyi> @type when
18:32:36 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
18:33:10 <aavogt> maybe somebody besides c_wraith can explain why this is broken (or a better example) http://hpaste.org/49529
18:56:50 <_Ray_> This is a relatively dumb question but... a Monad must be a Functor, correct? I'm reading wikibooks and found " However, GHC thinks it different, and the Monad class has actually nothing to do with the Functor class."
18:57:47 <Cale> _Ray_: yes
18:58:27 <_Ray_> So there's no instance Functor Monad where... ?
18:58:29 <Cale> _Ray_: It's just that for hysterical raisins, the Prelude still has no superclass context on Monad, so there's nothing requiring instances of the Monad class to be instances of the Functor class
18:58:42 <Cale> But there's always a natural way for instances of Monad to be made into instances of Functor
18:58:48 <_Ray_> Fmap can be rewritten using <<=, correct?
18:58:59 <_Ray_> Something like <<= . return or whatever xP
18:59:00 <Cale> instance Functor MyMonad where fmap = liftM
18:59:08 <Cale> <<= is a comonad thingy
18:59:17 <Cale> =<< is what you want
18:59:30 <Cale> or just do-notation :P
18:59:31 <_Ray_> Gack, evil syntax.
18:59:40 <Cale> fmap f x = do v <- x; return (f v)
18:59:44 <_Ray_> How much harder are comonads than natural transformations?
18:59:57 <Cale> comonads are exactly as hard to understand as monads
19:00:11 <_Ray_> Yeah, I always remember do { x <- list; y <- list; return (x+y); } for "Return all possible pairs of sums from a list" :)
19:00:18 <Cale> because they're the same thing only with all the arrows reversed ;)
19:00:54 <_Ray_> Well tbh I've never seen the commutative diagram for monads, I remember them as monoids in the category of endofunctors, or as the kleisli triple
19:04:21 <Cale> _Ray_: So, comonads are still endofunctors with some extra natural transformations
19:04:46 <Cale> But instead of eta: 1 -> T, you have epsilon: T -> 1
19:05:01 <Cale> and instead of mu: T^2 -> T, you have delta: T -> T^2
19:05:19 <_Ray_> So like, counit (IO^t x) = x?
19:05:40 <_Ray_> Where IO^t would be some comonad, where I'm abusing ^t to mean "make a comonad out of me".
19:06:20 <_Ray_> Is there a non insane example of a comonad? (Like lists are for monads)
19:06:23 <Cale> yeah, though IO isn't naturally a comonad
19:06:28 <Cale> Okay...
19:06:36 <Cale> So pick your favourite monoid
19:06:57 <Cale> Say, (Integer, Integer) with componentwise addition, is nice
19:07:31 <Cale> Then functions from a monoid (to other types) form a comonad
19:07:45 <Cale> with evaluation at the identity being the extract: W a -> a
19:08:02 <Cale> and  duplicate :: W a -> W (W a)
19:08:07 <Cale> being given by
19:08:27 <Cale> duplicate f x y = f (x `mappend` y)
19:09:16 <_Ray_> What would mappend be for (Integer, Integer)?
19:09:32 <_Ray_> Oh, addition componentwise?
19:10:40 <_Ray_> Hrmph. I would assume duplicate (x, y) = ((x, y), (x, y)). But what about extract (x, y)?
19:11:53 <Cale> If w is our monoid, then  type W a = (w -> a)
19:12:23 <Cale> So a "coaction" in our comonad here is a function (Integer, Integer) -> a
19:12:49 <Cale> Which you can picture as an infinite 2D array, with values of type a at each point in the integer plane :)
19:13:05 <Cale> extract :: W a -> a
19:13:10 <Cale> gives us the value at the origin
19:13:22 <Cale> and duplicate :: W a -> W (W a)
19:13:52 <Cale> gives us a 2D array of 2D arrays
19:14:04 <Cale> and the one at position (x,y) is a translated version of our original
19:14:15 <Cale> so that the point at the origin is what used to be the point at (x,y)
19:14:35 <Cale> (so it's the 2D array of all possible translations of our original array)
19:14:43 * djahandarie just drops a reminder remark that someone would be providing extract and duplicate for a concrete type a with a typeclass instance, they can't be defined with parametric polymorphism
19:14:57 <Cale> yeah
19:15:07 * hackagebot CHXHtml 0.2.0 - A W3C compliant (X)HTML generating library  http://hackage.haskell.org/package/CHXHtml-0.2.0 (PaulTalaga)
19:15:12 <Cale> extract :: ((Integer, Integer) -> a) -> a
19:15:16 <_Ray_> Hrmph. Is this used widely?
19:15:38 <Cale> Well, this specific comonad makes it really easy to write 2D cellular automata
19:16:13 <Cale> Because you can just work out what the cellular automaton does at the origin, as a function ((Integer, Integer) -> Bool) -> Bool
19:16:49 <Cale> and then duplicate your initial CA state to get all translations of it, before fmapping the evaluator over it :)
19:17:14 <Cale> and that's what cobind does
19:17:21 <_Ray_> Hrm, interesting. Question though, when you say "If w is our monoid, then  type W a = (w -> a)", do you mean that capitalization exactly? Wouldn't a monoid be W, not w? Or what would w be?
19:17:30 <Cale> W is our comonad
19:17:33 <Cale> w is a monoid
19:17:43 <Cale> sorry about that
19:17:46 <Cale> if it's confusing
19:18:07 <_Ray_> Oh OK
19:18:08 <Cale> also, in Haskell, you wouldn't use type, but newtype
19:18:11 <kmc> it's kind of confusing because w isn't actually a type variable
19:18:14 <Cale> but I wanted to save us the unwrapping
19:18:23 <Cale> oh, I suppose that too
19:18:25 <Cale> heh
19:18:44 <kmc> newtype MyComonad a = Mk (MyFavoriteMonoid -> a)
19:19:12 <kmc> or you can generalize
19:19:22 <_Ray_> That reminds me of... "tying the knot" or something? An article on a type-based fixpoint.
19:19:36 <kmc> newtype MkC m a = MkC (m -> a); instance (Monoid m) => Comonad (MkC m) where ...
19:19:45 <kmc> _Ray_, what's the relation?
19:20:40 * _Ray_ finds the article
19:22:08 <_Ray_> Hrm, doesn't seem to be much relation, "  newtype Fix f = MkFix (f (Fix f))".
19:22:29 <kmc> yeah, there's no recursive types in this monoid -> comonad construction
19:23:16 <copumpkin> :k Mu []
19:23:16 <lambdabot> *
19:23:20 <djahandarie> (However, you can generate a cofree comonad which does use something like that)
19:23:29 <kmc> djahandarie, how does that look?
19:23:53 <djahandarie> Like Free but with (,) rather than Either, if I remember correctly
19:23:54 <copumpkin> :k Pair
19:23:55 <lambdabot> Not in scope: type constructor or class `Pair'
19:24:30 <djahandarie> newtype Cofree f a = Cofree { runCofree :: (a, f (Cofree f a)) }
19:24:56 <djahandarie> instance Functor f => Functor (Cofree f) where fmap f = Cofree . (f *** fmap (fmap f)) . runCofree -- edwardk's definition of it
19:25:16 <djahandarie> Thought he doesn't define the actual comonad, annoying
19:25:18 * djahandarie looks harder
19:25:36 <kmc> what are the comonad operations on it?
19:25:47 <clsmith> :t ap
19:25:48 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:30:39 <djahandarie> instance Functor f => Comonad (Cofree f) where extract (Cofree (a, b)) = a; extend f w@(Cofree (a, b)) = Cofree (f w, fmap (extend f) b); duplicate w@(Cofree (a, b)) = (w, fmap duplicate b)
19:30:43 <djahandarie> Hell if I got that right
19:32:36 <kmc> i guess one way to explain the Haskell / category thing is that Haskell supports weird schemes of polymorphism far beyond what's known to be useful for practical code
19:32:50 <kmc> you don't need CT to describe the obviously useful polymorphism
19:33:10 <kmc> you need it to describe the weirder stuff
19:34:36 <kmc> and you want to describe the weirder stuff because it might turn out to be useful after all
19:47:56 <dainanaki> How can I optimize this byte string show functions for memory?
19:48:03 <dainanaki> http://hpaste.org/49531
