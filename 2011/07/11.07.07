00:29:12 <habitat> ok, i'm hitting the 'which language to use' stumbling block again.
00:29:26 <habitat> the choice is lisp or haskell. i'm not convinced by either.
00:29:58 <habitat> i have a fairly particular view of both as useful in their fields, with a lot of cross-over and understand the mental constraints imposed by both, also cleanliness, etc.
00:30:24 <habitat> But to choose is a nightmare.. and they're both complete enough to be reasonably sure that once learning one, the other will disappear.
00:30:27 <habitat> Some help?!
00:31:04 <dmwit> Hi, habitat!
00:31:08 <Enigmagic> you are in #haskell..
00:31:22 <habitat> i know Enigmagic!
00:31:25 <Enigmagic> without knowing your problem, i'd recommend lisp.
00:31:26 <ddarius> Just learn them both and pick the one you like better.
00:31:28 <habitat> hi there dmwit
00:31:49 <dmwit> I like Haskell a lot.
00:32:07 <ddarius> Alternatively, just say "Screw it" and learn/use PHP instead.  Problem solved.
00:32:09 <Enigmagic> actually, no, i'd recommend haskell.
00:32:45 <habitat> I would ddarius, except my view on them is they are both architecturally heavy i.e. for them to be useful it takes a lot of time.
00:32:59 <habitat> Why not just go straight for the knife and my jugular, i.e. learn Visual Basic. 8)
00:33:10 <dmwit> One of the things I like a lot is that the type system is: 1. restrictive enough that it catches bugs; 2. expressive enough that it doesn't get in the way; 3. flexible enough that I can write types that enforce strong invariants or types that allow hacky code.
00:33:14 <ddarius> VB.NET isn't as bad as the older VBs.
00:33:21 <habitat> I do PHP for work.. and when I get home I unmangle myself.. so yeah.
00:33:49 <Enigmagic> visual foxpro 9.0.
00:33:56 <habitat> fark.
00:34:05 <pikhq_> ddarius: Isn't VB.NET more syntactic antisugar for C#?
00:34:11 <dmwit> I also find Haskell's syntax relatively clean -- and especially that it made a lot of good decisions compared to lisp (in my opinion, of course).
00:34:30 <Enigmagic> pikhq_: there are a few linq features that vb.net has that c# does not.
00:34:32 <Enigmagic> otherwise...
00:34:33 <Enigmagic> yes.
00:34:50 <dmwit> Haskell also avoids the need for macros in many cases by allowing laziness. I consider this quite a strength: there's no need to worry about binding and so forth in normal, day-to-day programming.
00:34:58 <ddarius> pikhq_: Sure, but C# is fairly nice as far as mainstream languages go.
00:35:15 <Enigmagic> habitat: if you're doing php during the day, almost anything would be better :-)
00:35:19 <pikhq_> ddarius: Yeah, that wasn't meant to contradict your claim.
00:35:23 <habitat> i'd agree ddarius, but i am definitely out of that arena.
00:36:06 <habitat> so very true. i hardly even see php any more. the code process is: *think of idea* *spend 20 minutes writing nonsense* *remember intention and wonder why it needs so much dicking around*
00:36:07 <pikhq_> ddarius: "Somewhat worse way of writing a relatively sane language" vs. "The enemy of all that is good", it's obvious which is better. :)
00:37:58 <habitat> The book I've read on Haskell partially is 'Real World Haskell'.. is there a better introduction recommended?
00:38:26 <dmwit> ?where lyah
00:38:26 <lambdabot> http://www.learnyouahaskell.com/
00:38:28 <dmwit> ?where gentle
00:38:28 <lambdabot> http://www.haskell.org/tutorial/
00:38:34 <dmwit> RWH is great; so are the above.
00:38:58 <Enigmagic> lyah is probably the better of the intros
00:39:11 <dmwit> The Gentle Introduction doesn't get a lot of love these days, but it's how I learned it and I found it to be exactly the right pace.
00:39:27 <pikhq_> RWH is great, but LYAH is a much smoother introduction.
00:39:56 <MatrixFrog> and with much more colorful pictures :D
00:40:05 <pikhq_> RWH feels more to me like a book on doing things *with* Haskell, whereas LYAH is more about getting you to understand the basic semantics of Haskell.
00:40:49 <Axman6> i do believe that's how they were both designed
00:42:22 <habitat> What is LYAH an acronym for?
00:42:22 <habitat> 'Learn You a haskell'?
00:42:50 <Axman6> which is Learn You a Haskell For Great Good
00:43:02 <Axman6> which is short for*
00:44:58 <habitat> alright, i'll give it a read. i have been impressed with haskell in general so far, and like dmwit said its type system. lisp can be too putty-like a lot of the time.
00:45:45 <dmwit> ?where ychim
00:45:45 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
00:45:55 <habitat> in terms of numbers, i want to be able to take slices of things easily (which i know is basically fundamental) and also do the same with structures (which i see looks just as easy).
00:46:14 <dmwit> What is a slice of a number?
00:46:25 * Axman6 seconds that
00:46:28 <dmwit> ...or of a structure?
00:46:46 <Axman6> I've heard of slicing arrays in other languages...
00:46:46 <habitat> er.. creating sets.
00:47:05 <habitat> oh nothing like that.
00:47:09 <Axman6> > [1..10] -- like this?
00:47:10 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
00:47:14 <habitat> as in, generating a field of numbers and reducing out what i need.
00:47:39 <habitat> a list comprehension i suppose would be approximately it, but with larger sets and actions on nodes.
00:47:40 <dmwit> Oh. You just want a "set" library?
00:47:50 <dmwit> Have you worked in a language that didn't have one??
00:48:25 <habitat> the problem i'm working on is basically.. huge set of constantly changing numbers with actions on certain conditions.
00:48:44 <Axman6> :\
00:48:45 <habitat> so, parallel.
00:49:04 <habitat> yeah.. i know. i stopped speaking computer some time ago.. sorry.
00:49:07 <habitat> :/
00:49:56 <Enigmagic> sounds like a trading engine :P
00:50:15 <kmc> sounds like a computer
00:50:40 <dmwit> kmc++
00:50:43 <habitat> hehe yes. half the reason i stopped caring about language so much was really just because everything happened to be a metaphor for everything else.
00:51:07 <habitat> it's a game engine, or more accurately a game.
00:51:26 <kmc> taking LSD is a good way to feel like everything is a metaphor for everything else
00:52:01 <habitat> i read a paper a while back on emergent gameplay.. objects interacting in ways not initially programmed in, they used haskell to describe the system.
00:52:05 <kmc> dmwit, C doesn't have a standard set library :/
00:52:17 <habitat> been there, done that kmc.
00:52:33 <kmc> i'm continually surprised that there's no widespread even 3rd-party data structures library for C
00:52:34 <habitat> the experience holds. :)
00:52:40 <kmc> people really do roll their own linked list every time
00:52:48 <habitat> yes.
00:52:49 <kmc> or copy-paste list.h from Linux
00:53:12 <Enigmagic> kmc: the last big project i worked on had roughly 5 different hash tables in it
00:53:13 <kmc> i guess glib is supposed to be this
00:53:33 <habitat> a mathematics professor i know who works on fluid solving problems practically invented an object system for c.
00:53:46 <habitat> he could have just incremented.
00:53:46 <habitat> :p
00:54:07 <kmc> the linux kernel has at least a dozen implementations of binary search *and* many of them are wrong in the common way
00:54:37 <habitat> from a functional perspective, it does a lot of things wrong..
00:56:17 <Enigmagic> http://en.wikipedia.org/wiki/Worse_is_better
00:56:34 <kmc> wonder if anyone has a wrapper that lets you use C++ stl vector<void*> and map<void*,void*> and such from C
00:56:37 <ddarius> kmc: (a+b)/2 instead of a+(b-a)/2 ?
00:56:45 <kmc> yeah ddarius
00:58:05 <dmwit> Wait, really?
00:58:15 <shachaf> kmc: Is that just wrong because of overflow?
00:58:20 <dmwit> That's really amazingly bad.
00:58:29 <kmc> that's the only way I know of in which it's wrong
00:58:34 <dmwit> Is it just hard to write a reusable data-structure library in C for some reason?
00:58:40 <habitat> the irony of course being he a) wasted a lot of time and b) ended up using more memory. for someone that concious of space-time it was strange, just for the dislike of C++ v-tables.
00:58:59 <kmc> dmwit, it is hard to do it in a way with nice types
00:59:04 <kmc> but that usually does not stop C programmers
00:59:27 <kmc> a library of reusable data structures which only store void* would still be a huge improvement
00:59:36 <dmwit> right
00:59:46 <dmwit> And, like, every intro programmer ever has written one.
01:00:07 <dmwit> So what gives? O_o
01:00:13 <kmc> i've also worked on a project which had a collection of macros for declaring hash tables and resizable vectors of structs, with static typechecking
01:00:26 <ddarius> You just copy and paste the definition out of your textbook.  It's just like a library.
01:02:43 <quicksilver> dmwit, kmc: there are also quite a lot of C++ projects which don't trust the STL so have written their own data structures/algorithms from scratch.
01:03:14 <dmwit> Well, sure.
01:03:21 <dmwit> There's always going to be projects like that.
01:03:36 <quicksilver> there aren't so many in python/perl/java/haskell though
01:03:50 <quicksilver> mind you the STL has a bad history, maybe it's an abberant example
01:04:00 <shachaf> quicksilver: Or have slightly different requirements from what the STL provides.
01:04:05 <habitat> can anyone give me an example of a not-too-long haskell program (real world preferably) that exemplifies the style/elegance haskell has to offer? i'd like to see something neat.
01:04:26 <quicksilver> shachaf: that might be a reason in some of the cases but it's not in the ones I was thinking of.
01:04:28 <habitat> STL is 'untrustworthy' .. it compiles poorly on different platforms and has implementation schisms.
01:04:36 <dmwit> habitat: xmonad is a great example, I think.
01:04:51 <mauke> STL doesn't exist
01:04:57 <dmwit> habitat: ~500 lines of actual code, but a fully-functional window manager (and even a somewhat popular one)
01:05:19 <shachaf> If you want to look at xmonad, SPJ gave a talk (A Taste of Haskell) about it a while ago which might be helpful.
01:05:20 <dmwit> All of the code is nicely partitioned into pure bits and nasty X-bits.
01:05:22 <mauke> more like 1500 lines
01:05:27 <dmwit> 1500?
01:05:39 <mauke> guesstimate
01:06:01 <habitat> Somewhat Standard Template Library.
01:06:04 <shachaf> mauke: dmwit distinguishes "code" from "actual code", which is the way we remember the codebase after a few months have passed. :-)
01:06:07 <trygvis> xmonad is ~2372 lines
01:06:08 <habitat> cool, thanks. i'll have a look.
01:06:27 <mauke> ah, haven't counted in a while
01:06:34 <kmc> habitat, my small contribution to this sort of question is http://mainisusuallyafunction.blogspot.com/2010/10/tour-of-real-toy-haskell-program-part-1.html
01:06:36 <habitat> 'when i read it' vs. 'what is possibly is now' lol
01:06:46 <dmwit> 401 lines by my count.
01:06:51 <kmc> part 2 goes more into the implementation details
01:06:54 <dmwit> crabgrass:~/inst/xmonad% grep -v "^--" XMonad.hs XMonad/**/*.hs | sed '/{-/,/-}/d' | wc 401    2843   21586
01:07:26 <trygvis> and you really can't use xmonad without the contrib and/or extra module which adds ~30k lines (wc -l lines)
01:07:40 <dmwit> Oh, for sure, the contrib modules are somewhat larger.
01:08:07 <shachaf> xmonad is very different in spirit from dwm.
01:08:25 <trygvis> habitat: I find hledger to be a comprehensible piece of code
01:08:42 <shachaf> The "minimal line of code" competition came from that, but I don't think a comparison is even applicable nowadays.
01:09:14 <hpaste> ClaudiusMaximus pasted “v4l2toppm” at http://hpaste.org/48806
01:09:32 <shachaf> kmc: How's your WM doing?
01:10:04 <Saizan> i think bare xmonad is quite fine to use
01:10:22 <mauke> I'm counting 1396 lines
01:10:42 <kmc> not good shachaf
01:10:43 <dmwit> mauke: I shared my command line; care to share yours?
01:10:45 <ClaudiusMaximus> hopefully releasing a preliminary version of Graphics.V4L2 at some point soon, enough to capture video and fiddle with formats/controls
01:11:29 <shachaf> kmc: You can't just go around saying "this is how a WM should work, and I'm going to write one that works that way" and then not do anything about it!
01:11:32 <shachaf> What is this, IRC?
01:11:37 <kmc> looks like
01:12:03 <mauke> % cat Main.hs XMonad.hs XMonad/* | perl -p0777 -e 's,("(?:[^\\"]|\\.)*"|'\''(?:[^\\'\'']|\\.)*'\''|[^\W\d][\w'\'']*|(?!--+(?![!#\$%&*+./<=>?\@\\^|~:]))[!#\$%&*+./<=>?\@\\^|\-~:]+)|(?:--[^\n]*|()\{-(?>\{-.*?-\}|.)*?-\})(),$+ . (defined $2 ? " " : ""),gse' | grep '[^ ]' | wc -l
01:12:07 <mauke> 1396
01:12:44 <mauke> the perl thing was originally a separate program but I inlined it for comedic effect
01:12:55 <kmc> you're using perl -0777
01:13:05 <mauke> yes?
01:13:17 <kmc> just noting that
01:16:13 * dmwit gives up
01:16:57 <ClaudiusMaximus> quick (hopefully..) license question: i'm binding via FFI to an LGPL library (typically shipped as an .so), but i'm fine with the bindings being BSD3 - would setting BSD3 in my .cabal cause problems?  is a note in the docs saying "btw the upstream dependency is LGPL, so be careful if you distribute binaries" enough?
01:17:19 <ddarius> Why not use sloccount?
01:17:54 <ddarius> You are only licensing your code.
01:18:02 <kmc> ClaudiusMaximus, people will post angry comments on your blog
01:18:10 <kmc> does that count as "causing problems"
01:18:13 <ClaudiusMaximus> kmc: my blog doesn't have comments
01:18:18 <kmc> problem solved!
01:18:20 <ClaudiusMaximus> :)
01:18:22 <ddarius> He is a master.
01:22:01 <kmc> the Win32 bindings are BSD3
01:23:30 <kmc> ddarius, sloccount is great.  "this project would take 13.9 years and cost $14,783,921 to develop according to numbers i pulled out of my ass just now"
01:24:42 <ddarius> kmc: I ignore those numbers.  Ohloh is like that too (and may well use sloccount.)
01:30:13 <GiraffeFrenzy> When I was 13 years old I spent 3 days on the Neverland Ranch with Michael Jackson, and it is an experience that I will never forget!  We passed the time cuddling in bed, drinking jesus juice, and riding gokarts!  On the first day we climbed a tree together, and I let myself rest holding onto a branch.   Michael yanked down my shorts and underoos and proceeded to tease my pert tight bum with his nice 8 inch hard ramrod!
01:30:27 --- mode: ChanServ set +o mauke
01:30:27 --- mode: mauke set +b $a:GiraffeFrenzy
01:31:17 --- mode: mauke set -o mauke
01:41:33 <ivant> I was taking a train going home from work today, and I was reading the new issue of "The Monad Reader". The guy in the car suddenly asked me if I indeed was reading the Monad Reader — he never saw it being read printed.
01:41:54 <ivant> I guess Haskell's plan to avoid success at all cost is an utter failure now
01:42:44 <shachaf> ivant: Who was it?
01:42:47 <Axman6> haskell users almost colided on the train? the odds are near zero!
01:42:50 <shachaf> ivant: Also, can I have it when you're done? :-)
01:43:24 <ivant> shachaf, some fellow Haskeller, apparently. I invited him to our next user group meeting
01:43:44 <ivant> shachaf, sure, probably on Friday
01:43:47 <kmc> i think the odds where i am are pretty good
01:44:33 <kmc> ITA buys ad space on public transit and puts in algorithms and UNIX puzzles
01:44:41 <ivant> mind you, I was going only two stops. However the odds of that happening between Mountain View and Palo Alto are probably not that low.
01:44:56 <kmc> Google just puts up giant QR codes with no name or context
01:45:04 <ivant> wasn't ITA bought by Google?
01:45:08 <kmc> yeah
01:45:44 <shachaf> I understand they're still pretty independent, though, as far as hiring and such are concerned.
01:45:50 <kmc> but they haven't yet become one with the omni-mind
01:45:55 <kmc> what shachaf said
01:46:09 <kmc> the deal was announced like a year ago but final regulatory approval was only a few months ago
01:46:14 <ivant> is omni-mind the same as hive-mind?
01:46:18 <kmc> dunno
01:47:04 <kmc> ivant, also, i'm sincerely sorry that you have to ride Caltrain
01:48:25 <maurer_> shachaf: We have group meetings?
01:48:48 <shachaf> maurer_: If you're near SF, yes. ivant runs bahaskell.
01:48:50 <shachaf> @where bahaskell
01:48:50 <lambdabot> I know nothing about bahaskell.
01:49:01 <shachaf> @where+ bahaskell http://groups.google.com/group/bahaskell
01:49:02 <lambdabot> I will never forget.
01:49:04 <maurer_> shachaf: I live with rerntzdb
01:49:42 <shachaf> Oh. In that case, yes. :-)
01:49:51 <shachaf> ivant: When's the next meeting?
01:52:41 <shachaf> maurer_: In fact, the group meetings take up most of the "Recent Events" section of the front page of haskell.org. :-)
01:59:26 <hpaste> chrisdone pasted “Control.Concurrent.Jobs” at http://hpaste.org/48807
02:00:21 <chrisdone> kmc: Might be of interest. ^
02:02:17 <shachaf> chrisdone: What is the use of a JobList?
02:03:16 <chrisdone> shachaf: In my particular use, someone sends a request on a service for an action that takes a couple minutes to complete. Rather than waiting, they take a job id and periodically ask the server for the job's result.
02:04:08 <shachaf> chrisdone: Oh, the JobList is on one machine and the JobId is on another?
02:04:14 <roconnor> @seen twanvl
02:04:14 <preflex>  twanvl was last seen on #haskell 4 days, 11 hours and 39 seconds ago, saying: roconnor: were you looking for me?
02:04:14 <lambdabot> Unknown command, try @list
02:04:40 <chrisdone> shachaf: Sure.
02:05:46 <shachaf> Ah. Otherwise (if it was in-process) I don't see why you wouldn't just have the MVar be the JobId. :-)
02:05:53 <shachaf> The map still seems odd.
02:07:09 <chrisdone> shachaf: How would you do it without a map?
02:09:02 <shachaf> chrisdone: Make the JobId be the MVar?
02:09:08 <shachaf> I'm probably misunderstanding.
02:26:41 <roconnor> How does the SML spec formalize IO?
02:27:00 <stdio11> hey
02:27:45 <stdio11> anyone home?
02:28:06 <Axman6> there's about 600 people home
02:28:37 <osfameron> several billion even
02:30:25 --- mode: ChanServ set +o mauke
02:30:26 --- mode: mauke set -b $a:GiraffeFrenzy
02:31:15 --- mode: mauke set -o mauke
02:41:08 <Axman6> weak, speant the last few hours implementing Okasaki's efficient queue structure, and it turns out that list ++ [x] is a hell of a lot faster in this case :(
02:45:49 <cheater_> Axman6: why did you think ghc would be implementing something inferior?
02:46:34 <Axman6> well list ++ [x] incurs an O(n) cost every time it occurs
02:46:47 <ddarius> Axman6: I'm inclined to think that you did something wrong, or you are using way overkill for whatever you are doing.
02:47:11 <Axman6> well, i have a feeling the length of the list is usually going to be very small
02:52:57 * hackagebot iptables-helpers 0.3 - Static checking of iptables rules  http://hackage.haskell.org/package/iptables-helpers-0.3 (EvgenyTarasov)
02:54:57 * hackagebot pam 0.1 - Haskell binding for C PAM API  http://hackage.haskell.org/package/pam-0.1 (EvgenyTarasov)
02:54:59 * hackagebot iptadmin 1.0.0 - web-interface for iptables  http://hackage.haskell.org/package/iptadmin-1.0.0 (EvgenyTarasov)
02:55:32 <erikde> oh, nice, i was wanting to play with PAM
03:00:58 <QinGW> bye
03:04:00 <Watermind> is there some word for "non-lifted" ,  to distinguing    Just x :: Maybe a     from    x :: a
03:04:14 <Watermind> Just x  -> lifted     x -> ?
03:04:45 <lunaris> Watermind: unlifted?
03:04:49 <quicksilver> unlifted is the word but it's quite overloaded
03:05:15 <Watermind> it's just that unlifted kind of makes it sound like it were lifted before....
03:05:21 <lunaris> To be honest I don't use the word lifted that much (not in reference to something like Just x anyway)
03:05:24 <Watermind> and then it was unlifted
03:05:39 <lunaris> Unusual doesn't imply that something was previously usual.
03:05:54 <Watermind> lunaris: good point
03:05:59 <lunaris> Similarly for unfamiliar, etc.
03:06:03 <quicksilver> Watermind: nonetheless, unlifted is the word ;)
03:06:08 <lunaris> As quicksilver mentioned though, it's a bit overloaded.
03:06:10 <Watermind> yes you're right, bad english no my part
03:06:20 <Watermind> what else can it mean then?
03:06:23 <quicksilver> but it's more often used in the context of types containing _|_
03:06:30 <quicksilver> (,) is a "lifted pair"
03:06:31 <lunaris> ^^
03:06:48 <Watermind> I see
03:06:56 <quicksilver> whereas the GHC-internal (# , #) tuple is unlifted.
03:07:01 <Watermind> got it
03:07:08 <lunaris> Then there's lifting values to types, types to kinds.
03:07:15 <lunaris> Values to functors, monads.
03:07:19 <lunaris> Monad transformers.
03:07:28 <lunaris> Oh such fun we have with lifting.
03:57:18 <jsaacmk> I'm using the ghci version 6.12.1 and it doesn't seem to like ranges with steps, e.g., [3,3..100] multiples of 3 <= 100. Should it work? I just get 3,3,3,3,3..... forever
03:58:45 <testmonad> shouldnt it be [3,6,100]?
03:58:55 <testmonad> sorry ... [3,6..100]
03:58:56 <jsaacmk> 3,6,9,12
03:59:02 <jsaacmk> maybe
03:59:03 <jsaacmk> let me try
03:59:19 <jsaacmk> yes, that's it
03:59:43 <jsaacmk> wait no, it worked, but is not right
03:59:48 <testmonad> tells haskell to start at 3, then 6 and go on like that up to 100 taking the diff between the first two as step
04:00:33 <jsaacmk> well that makes more sense than the way I was reading it
04:00:55 <jsaacmk> it's like [first number, second number..until some number]
04:01:16 <testmonad> i think so :-)
04:01:25 <jsaacmk> (and in reference to me saying it's not right, I had typed [3.6..100], so it was my mistake)
04:01:43 <Botje> > take 10 [3.6..100]
04:01:44 <lambdabot>   [3.6,4.6,5.6,6.6,7.6,8.6,9.6,10.6,11.6,12.6]
04:01:47 <Botje> heh.
04:02:22 <testmonad> nice ... didn't know that botje
04:02:51 <testmonad> > drop 10 [3,6..100]
04:02:52 <lambdabot>   [33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,81,84,87,90,93,96,99]
04:03:00 <testmonad> : )
04:03:59 * testmonad bows to lambdabot
04:08:22 <jsaacmk> > repeat 5 == cycle [5]
04:08:26 <lambdabot>   mueval-core: Time limit exceeded
04:12:55 <doox> halp
04:13:00 <doox> help
04:13:13 <rtharper> help with what? =p
04:13:30 <ion> That’s for us to figure out.
04:13:35 * rothwell sprays doox with fire extinguisher
04:13:59 * ion gives doox the HIV antidote
04:15:45 * testmonad hands ion some electrons hoping that he will become more balanced ...
04:16:01 <ion> Thanks, now i’m even more negative.
04:16:09 <testmonad> haha
04:16:29 <testmonad> sorry about that
04:19:48 <testmonad> \o\ |o| /o/
05:22:44 * hackagebot hashable 1.1.2.1 - A class for types that can be converted to a hash value  http://hackage.haskell.org/package/hashable-1.1.2.1 (JohanTibell)
05:28:41 <Polarina> Does anyone know of any libraries for spatial indexing?
05:54:54 <saml> i wanna learn haskle
05:55:21 <roconnor> @where lyah
05:55:22 <lambdabot> http://www.learnyouahaskell.com/
05:56:00 <insane> is it possible to make a type synonym instance of a Show class for example, and if not (which is the case, I guess) is there a way around it?
05:56:22 <roconnor> insane: not without enabling scary extensions.
05:56:33 <roconnor> insane: the way around it is to use a newtype instead of a type synonym
05:56:39 <insane> roconnor: :)
05:56:59 <roconnor> enabling scary extensions is maybe okay for small experimental projects
05:57:14 <insane> roconnor: this requires me to rewrite a significant amount of code on the other hand
05:57:31 <ion> Someone should come up with a programming language called Haskle.
05:57:47 <ion> that’s completely different from Haskell for the lulz.
05:57:52 <roconnor> insane: using newtypes are not that much work; and it is better anyways.
05:58:14 <insane> roconnor: Okay, I'm gonna do as you suggest
05:58:19 <insane> roconnor: thanks!
05:58:32 <Twey> ion: Make it a COBOL variant?
05:58:46 <Twey> I have enough trouble with people thinking I've said ‘Pascal’
05:59:12 <ion> insane: Newtype deriving may even be able to autogenerate the proper instances for the classes you don’t need to customize.
05:59:32 <roconnor> newtype deriving is a less scary extension
06:00:48 * hackagebot reactive-banana 0.4.0.0 - Small but solid library for  functional reactive programming (FRP).  http://hackage.haskell.org/package/reactive-banana-0.4.0.0 (HeinrichApfelmus)
06:00:51 <ion> insane: That and GeneralizedNewtypeDeriving
06:02:49 * hackagebot reactive-banana-wx 0.4.0.0 - Examples for the reactive-banana library, using wxHaskell.  http://hackage.haskell.org/package/reactive-banana-wx-0.4.0.0 (HeinrichApfelmus)
06:03:49 * hackagebot narc 0.1 - Query SQL databases using Nested Relational Calculus embedded in Haskell.  http://hackage.haskell.org/package/narc-0.1 (EzraCooper)
06:29:04 <Gilgamesh> hey guys... good afternoon... I am trying to get the maximum value in a list of integers in GHCi, and it is taking a long time
06:29:14 <Gilgamesh> the list has 1 million values...
06:29:36 <Gilgamesh> any idea why it is taking too long? (it has been running for more than 3 minutes now)
06:29:47 <dafis> Gilgamesh: does it take long to compute the list?
06:30:17 <Gilgamesh> dafis: i don't think so... length returns instantaneously
06:30:40 <testmonad> > maximum [1..1000000]
06:30:41 <lambdabot>   *Exception: stack overflow
06:30:47 <testmonad> hmmmm
06:30:51 <dafis> Gilgamesh: that still allows for the computation of the elements to take long
06:31:21 <parcs> looks like PackageImports doesn't work in ghci :(
06:31:21 <dafis> however, it might be that maximum is too lazy, try Data.List.foldl' max 0 list
06:31:25 <Gilgamesh> well, I can paste the code somewhere and show you... can you have a look? I am new to haskell, so I can't really say... to me the computation seems fast enough
06:31:32 <saml> > maximum [1..]
06:31:38 <dafis> (if there's at least one positive Integer in the list)
06:31:52 <Gilgamesh> yes, all integers in the list are positive
06:31:54 <dafis> @where paste
06:31:59 <dafis> Gilgamesh: ^^
06:32:14 <lambdabot> <http://hpaste.org/>, <http://paste.lisp.org/new>, <http://codepad.org/>
06:32:14 <dafis> oops, lambdabot away?
06:32:20 <saml> > min (maximum [1..])
06:32:20 <dafis> no, just slow
06:32:22 <Gilgamesh> nah, just a little laggy
06:32:24 <saml> why is that bottom?
06:32:24 <lambdabot>   mueval-core: Time limit exceeded
06:32:27 <Gilgamesh> ok, I will paste the code
06:32:29 <Gilgamesh> give me a minute
06:32:49 <saml> maximum [1..]  should know it is greater or equal to 1
06:32:55 <dafis> saml: maximum (infinite list) is bottom
06:33:02 <saml> why?
06:33:06 <saml> make it smart please
06:33:11 <dafis> saml: how should it know?
06:33:20 <saml> compiler should be smart
06:33:25 <roconnor> saml: if you use Natural it does know
06:33:32 <saml> even i can know min 1 (maximum [1..])  is 1
06:33:51 <benmachine> roconnor: does it really? you could define a maximum that did but I'm not sure the default one deos
06:33:52 <dafis> > min 1 undefined
06:33:53 <lambdabot>   *Exception: Prelude.undefined
06:33:58 <zygoloid> parcs: 'import' in ghci is horrible sugar for :m +
06:33:58 <roconnor> > min (1 : Nat) (maximum [1..])
06:33:59 <lambdabot>   Not in scope: data constructor `Nat'
06:34:05 <roconnor> > min (1 :: Nat) (maximum [1..])
06:34:06 <lambdabot>   Not in scope: type constructor or class `Nat'
06:34:09 <saml> > min 1 (maximum [1..])  :: Natural
06:34:10 <lambdabot>   Not in scope: type constructor or class `Natural'
06:34:16 <ion> saml: I’m gonna begin feeding you an infinite list of numbers one by one. Feel free to tell me what is the biggest number in the list at any time of your choosing.
06:34:20 <benmachine> saml: even you! and your computing equipment has been in development for just a few million years ;)
06:34:22 <dafis> zygoloid: but import qualified as is nice
06:34:31 <roconnor> > min 1 (maximum [1..]) :: Natural
06:34:31 <lambdabot>   Not in scope: type constructor or class `Natural'
06:34:34 <saml> ion, do you know meaning of [1..] ?
06:34:50 <ion> saml: Yes. Do you?
06:34:54 <roconnor> lambdabot used to know about Natural.  What happend?
06:35:00 <saml> it's an infinite list that starts from 1 and use succ
06:35:01 <hpaste> Gilgamesh pasted “Maximum taking long” at http://hpaste.org/48811
06:35:10 <Gilgamesh> that one
06:35:13 <Gilgamesh> :)
06:35:23 <Gilgamesh> hope it is not too confusing
06:35:23 <saml> and succ is for Int is +1 .. so compiler should know
06:35:31 <zygoloid> dafis: does it support that in recent ghci's?
06:35:41 <dafis> Gilgamesh: 32-bit system?
06:35:50 <benmachine> Gilgamesh: don't use ghci, compile with optimisations
06:35:53 <Gilgamesh> dafis: yes
06:35:56 <dafis> zygoloid: aye, it does
06:36:05 <dafis> Gilgamesh: overflow
06:36:28 <Gilgamesh> benmachine: I am still not familiar with writing compiled programs :(
06:36:37 <Gilgamesh> dafis: overflow?
06:36:37 <dafis> Gilgamesh: make it collatz :: Integer -> Int
06:36:41 <tromp> > succ (maxBound::Int)
06:36:42 <lambdabot>   *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
06:36:43 <benmachine> Gilgamesh: sure you are, there's one right there :)
06:36:44 <zygoloid> dafis: it always used to be a trivial rewriting: s/import /:m +/. 6.12 allowed 'import *Foo' for instance.
06:36:56 <Gilgamesh> benmachine: i mean about writing a main function hehe
06:37:03 <dafis> Gilgamesh: for some values, the colloatz sequence leaves 32-bit Int range
06:37:05 <Gilgamesh> dafis: let me try
06:37:15 <benmachine> Gilgamesh: oh, you don't necessarily need to do that. just make sure the call to "maximum" gets compiled with optimisations
06:37:21 <dafis> Gilgamesh: then you get a negative value and an infinite loop
06:37:23 <tromp> @src enumFrom
06:37:23 <lambdabot> Source not found. Just try something else.
06:37:30 <Gilgamesh> benmachine: oh... ok, i will try that too
06:37:34 <roconnor> saml benmachine: oh wait; I'm wrong.  Natural isn't smart enough.
06:37:49 <Gilgamesh> dafis: well, in that case length y should never return, no?
06:38:12 <benmachine> roconnor: you could write maximum (Succ n : ns) = Succ $ maximum n : map pred ns
06:38:20 <benmachine> but you couldn't make a generic maximum that clever, I think
06:38:35 <dafis> Gilgamesh: the length of the collatz-sequence doesn't get computed when you ask length [colltaz n | n <- [1 .. 1000000]]
06:38:43 <roconnor> @src maximum
06:38:43 <lambdabot> maximum [] = undefined
06:38:43 <lambdabot> maximum xs = foldl1 max xs
06:38:49 <roconnor> @src max
06:38:49 <lambdabot> max x y = if x <= y then y else x
06:38:58 <tromp> so [1..] is a finite list
06:39:00 * hackagebot acid-state 0.4.2 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.4.2 (DavidHimmelstrup)
06:39:12 <roconnor> @type Max
06:39:13 <tromp> when of type [Int]
06:39:15 <roconnor> @type max
06:39:16 <lambdabot> Not in scope: data constructor `Max'
06:39:17 <benmachine> tromp: yes
06:39:17 <lambdabot> forall a. (Ord a) => a -> a -> a
06:39:30 <dafis> > length [1 :: Int16 .. ]
06:39:31 <lambdabot>   32767
06:39:38 <dafis> tromp: sometimes
06:39:39 <roconnor> benmachine: I guess if max were part of the Ord class, it would work
06:39:42 <tromp> > length ([1..]::[Int])
06:39:46 <lambdabot>   mueval-core: Time limit exceeded
06:39:50 <benmachine> roconnor: apparently it is :o
06:39:55 <roconnor> it is?
06:39:58 <benmachine> so I guess that could work
06:40:00 <Gilgamesh> dafis: oh i see... well, I am trying with Integer now
06:40:26 <tromp> > length ([1..]::[Word8])
06:40:27 <lambdabot>   255
06:40:27 <Gilgamesh> still pretty slow... let me try t compile as suggested by benmachine
06:40:28 <roconnor> wait, why didn't this work then?
06:40:36 <roconnor> oh wait
06:40:42 <roconnor> I fogot the Natural annotation
06:40:46 <benmachine> roconnor: possibly max was put in Ord relatively recently?
06:40:57 <benmachine> and/or whoever defined instance Ord Nat didn't think of it
06:41:00 <zygoloid> not only can it work, it /does/ work for Natural
06:41:04 <zygoloid> iirc i wrote that code :)
06:41:29 <roconnor> oh the damn foldl
06:41:42 <benmachine> heh
06:41:50 <roconnor> who thought that was a good idea
06:42:01 <benmachine> people who like code that performs? :P
06:42:26 <roconnor> still doesn't work
06:42:41 <zygoloid> it's almost as if people don't have O(N) memory just sitting there waiting to be used :)
06:42:51 <dafis> roconnor: would need a rewrite rule for Nat, wouldn't it?
06:43:01 <roconnor> I'm trying foldr1 max
06:43:17 <dafis> roconnor: that should work indeed
06:43:40 <roconnor> *Data.Number.Natural> min 1 (max 1 infinity) :: Natural
06:43:42 <roconnor> 1
06:43:49 <roconnor> I've got that far
06:44:08 <roconnor> oh wait
06:44:11 <roconnor> it doesn't work
06:44:19 <roconnor> because it doesn't know that 0 isn't in [1..]
06:44:35 <benmachine> roconnor: it doesn't care, because of max, surely?
06:44:38 <dafis> roconnor: shouldn't be a problem for maximum
06:44:42 <benmachine> it knows that 1 is in there
06:44:54 <benmachine> however, are you getting infinity and trying to print it? :)
06:45:18 <roconnor> oh maybe the definition of max is bad
06:45:39 <roconnor> ah yes
06:45:45 <roconnor> max needs to be more lazy
06:46:16 <Twey> roconnor: You're redefining Nat?
06:46:42 <zygoloid> roconnor: max can't be lazier without arbitrarily being left- or right-biased
06:46:51 <zygoloid>     S x `max` S y = S (x `max` y)
06:46:51 <zygoloid>     x   `max` y   = x + y
06:46:58 <zygoloid> ^^ assuming that's the definition you're working with
06:46:59 <roconnor> right
06:47:09 <roconnor> it needs to be left/right bias or lazier
06:47:21 <zygoloid> however, + forces the LHS first, so maybe max should too
06:47:23 <roconnor> if we make it right bias then maximum will work!
06:47:43 <roconnor> and if + were right biased then sum would work!
06:47:48 <roconnor> oh wait
06:47:55 <roconnor> foldl never works on infinite lits
06:48:05 <roconnor> okay right bias then
06:48:14 <roconnor> I mean left bias then
06:48:38 <zygoloid> clearly this calls for unamb
06:49:14 <saml> let's make it smart.  maximum [1..]  ::  Int i >= 1    and    min 1 :: Int -> Int i <= 1      so,  (min 1) (maximum [1 ..]) :: Int i <= 1
06:49:37 <Nimatek> Gilgamesh: You can optimize it using memoization, but even the brute force version should take under 20sec when compiled.
06:50:06 <roconnor> *Data.Number.Natural> min 1 (foldr1 max [1..]) :: Natural
06:50:08 <roconnor> 1
06:50:08 <Gilgamesh> Nimatek: what flags should I give the compiler?
06:50:14 <Nimatek> Gilgamesh: -O2
06:50:21 <roconnor>     S x `max` y = S (case y of { S y' -> x `max` y ; Z -> x })
06:50:22 <Gilgamesh> I just tried running a simply compiled (ghc --make) and it overflowed
06:50:22 <roconnor>     Z   `max` y =  y
06:50:24 <roconnor> saml: there you go
06:50:25 <Nimatek> As for memoization, that's not a compiler flag.
06:50:33 <saml> u so rad
06:50:46 <Gilgamesh> the stack keeps overflowing...
06:50:52 <dafis> Gilgamesh: without optimisations, you get a lazy maximum, that will overflow
06:50:56 <Gilgamesh> $ ./p14
06:50:57 <Gilgamesh> Stack space overflow: current size 8388608 bytes.
06:50:59 <Gilgamesh> Use `+RTS -Ksize -RTS' to increase it.
06:51:06 <roconnor> Maybe I should upload a new version of the numbers package
06:51:11 <roconnor> with the lazier max
06:51:27 <dafis> Gilgamesh: ghc -O2 -fforce-recomp p14
06:51:47 <roconnor> min should probably be lazier too
06:52:09 <zygoloid> roconnor: sounds good to me.
06:52:14 <roconnor>     Z   `min` _   = Z
06:52:15 <roconnor>     _   `min` Z   = Z
06:52:17 <roconnor>     S x `min` S y = S (x `min` y)
06:52:53 <zygoloid> it's augustss' package, but he said he doesn't mind other people uploading fixes
06:53:29 <Gilgamesh> dafis: great!
06:53:37 <hpaste> roconnor pasted “lazy min and max” at http://hpaste.org/48812
06:53:41 <Gilgamesh> dafis: that worked :) took 6 seconds
06:53:42 <Gilgamesh> :D
06:54:09 <Gilgamesh> thanks dafis, Nimatek and benmachine
06:54:46 <dafis> Gilgamesh: you can spped it up, though
06:54:52 <dafis> *speed
06:55:04 <Nimatek> Gilgamesh: For that projecteuler problem you need the index of the maximum, not the maximum itself though ;)
06:55:10 <zygoloid> roconnor: incidentally: "S x `max` y = S (x `max` pred y); Z `max` y = y" would be more consistently left-biased (and i think lazier)
06:55:30 <roconnor> ah good
06:55:49 <dafis> zygoloid: what's pred Z?
06:55:56 <roconnor> zygoloid: and space leaky?
06:55:59 <Gilgamesh> Nimatek: yes, I took the index
06:56:30 <zygoloid> dafis: _|_, if it's ever forced
06:56:38 <roconnor> anyhow laziness is more important than space leaks, right?
06:56:38 <zygoloid> roconnor: sure, but this is Nat :)
06:56:51 <dafis> zygoloid: so that would die on (S z) `max` Z
06:57:07 <zygoloid> dafis: nope.
06:57:30 <dafis> (S x) `max y = S (case y of { Z -> x; S w -> w})
06:58:10 <zygoloid> dafis: ? roconnor's one would die, yes. hence my formulation is lazier.
06:58:25 <roconnor> dafis: S w -> x `max` w
06:59:00 <dafis> zygoloid: (S Z) `max` Z ~> S (Z `max` pred Z) ~> S (pred Z)
06:59:34 <zygoloid> dafis: eep! right you are.
07:00:08 <roconnor> fine
07:00:33 <roconnor> (S x) `max` y = S (x `max` (Z `min` pred y))
07:00:41 <roconnor> the clearest definition of max evar
07:00:46 <zygoloid> S x `max` y = S (x `max` sublimatedPred y); ... where sublimatedPred (S x) = x; sublimatedPred Z = Z
07:00:47 <dafis> but postponing the pattern match for the second arg is good, I think
07:01:29 <roconnor> zygoloid: using min is okay right?
07:01:36 <roconnor> er wait
07:01:50 <zygoloid> not so much ;)
07:02:45 <roconnor> (S x) `max` y = S (x `max` (case y of { S y' -> y' ; Z -> Z }))
07:02:51 <dafis> (S x) `max` y = S (case y of { Z -> x; S w -> x `max` w})
07:03:21 <roconnor> dafis: the whole point is to move the case y inside the recursive call to max
07:03:25 <zygoloid> roconnor: (that's equiv. to my sublimatedPred thing)
07:03:30 <roconnor> yep
07:03:48 <roconnor> zygoloid: do you think using sublimatedPred is better?
07:03:59 <roconnor> I don't really like case statement :)
07:04:03 <zygoloid> *shrug* no strong opinions
07:04:08 <bgamari> Are there any well-defined conventions on how to use QuickCheck
07:04:14 <sipa> @pl \f t -> t
07:04:14 <lambdabot> const id
07:04:17 <sipa> @pl \f t -> f
07:04:17 <lambdabot> const
07:04:20 <bgamari> i.e. should properties be in the module they apply to
07:04:34 <zygoloid> roconnor: i actually like the case statement: it makes it clear you're deferring forcing y
07:05:05 <bgamari> Or should each module have an associated module containing the quickcheck machinery necessary to test its functionality
07:05:12 <roconnor> *Data.Number.Natural> max 1 0
07:05:13 <roconnor> 1
07:05:45 <sipa> @pl \b t f -> b f t
07:05:45 <lambdabot> flip
07:06:18 <ion> @pl \butt f -> buff t
07:06:19 <lambdabot> const (const (buff t))
07:06:23 <roconnor> *Data.Number.Natural> max 1 0 :: Natural
07:06:25 <roconnor> 1
07:06:26 <roconnor> even
07:07:06 <cpa> hi there, I have a question about Data.Graph: scc give a list of SCCs but how do I get the SCCs graph?
07:11:26 <bgamari> Can anyone list a packages that uses QuickCheck in an idiomatic way?
07:16:20 <lunaris> @check \xs -> and (zipWith (==) xs (tail xs))
07:16:21 <lambdabot>   "OK, passed 500 tests."
07:20:07 <parcs> @check \xs -> and (zipWith (==) (xs :: [Int]) (tail xs))
07:20:08 <lambdabot>   "Falsifiable, after 0 tests:\n[-1,3]\n"
07:24:45 <ion> @check \((`asTypeOf` [0]) -> xs) -> xs == reverse xs
07:24:46 <lambdabot>   Parse error at "->" (column 20)
07:25:17 <ion> > quickCheck $ \((`asTypeOf` [0]) -> xs) -> xs == reverse xs
07:25:18 <lambdabot>   Not in scope: `quickCheck'
07:25:37 <ion> > Test.QuickCheck.quickCheck $ \((`asTypeOf` [0]) -> xs) -> xs == reverse xs
07:25:38 <lambdabot>   Not in scope: `Test.QuickCheck.quickCheck'
07:26:27 <ion> Ah, duh, quickCheck is of course :: … -> IO ()
07:26:46 <ion> Anyway, @check doesn’t seem to have ViewPatterns even though > does.
07:27:11 <ion> @type \((`asTypeOf` [0]) -> xs) -> xs == reverse xs
07:27:12 <lambdabot>     Illegal view pattern:  ((`asTypeOf` [0]) -> xs)
07:27:12 <lambdabot>     Use -XViewPatterns to enable view patterns
07:27:27 <ion> Neither does @type
07:30:27 <parcs> :t \(x :: Bool) -> x
07:30:28 <lambdabot> Bool -> Bool
07:31:36 <ion> Does @check have ScopedTypeVariables either?
07:31:46 <ion> @check \(xs :: [Integer]) -> xs == reverse xs
07:31:46 <lambdabot>   Parse error in pattern at "->" (column 20)
07:31:59 <ion> @type \(xs :: [Integer]) -> xs == reverse xs
07:32:00 <lambdabot> [Integer] -> Bool
07:55:25 <bgamari> Hmmm, this is quite mysterious
07:55:51 <bgamari> :t Test.QuickCheck.orderedList
07:55:52 <lambdabot> forall a. (Ord a, Arbitrary a) => Gen [a]
07:56:02 <bgamari> Yet the documentation claims
07:56:04 <bgamari> Generates an ordered list of a given length.
07:56:15 <bgamari> How does one specify the "given length?"
07:57:07 <quicksilver> bgamari: defined by the size it's trying to generate I imaging.
07:57:25 <quicksilver> bgamari: the quickcheck context knows how big a 'thing' it's trying to make, that's how it starts with small test cases and works up.
07:58:05 <ion> bgamari: resize 5 orderedList results in lists of length 0 to 5.
07:58:10 <bgamari> quicksilver: Ahh
07:58:37 <bgamari> I see, thanks!
07:58:54 <bgamari> Where are QuickCheck tests usually placed?
07:58:59 <bgamari> In the module you are checking?
07:59:17 <bgamari> There are functions I want to check which aren't publicly available
07:59:42 <bgamari> So I'm currently exposing a check function in the module which exposes all of the checks which rely on hidden functions
07:59:48 <quicksilver> yes, they pretty much have to be there in the module.
07:59:55 <bgamari> Alright
08:00:02 <quicksilver> I don't know a good way to arrange and scale quickcheck tests, I've only ever written them locally.
08:00:09 <quicksilver> (and I just run them in ghci)
08:00:21 <bgamari> Yeah, it seems like there's not a whole lot of consensus on this
08:00:27 <quicksilver> I bet there are some good examples out there - doesn't xmonad use quickcheck?
08:00:27 <bgamari> at least not documented
08:00:35 <bgamari> perhaps
08:00:41 <bgamari> I was looking at Cryto before
08:01:01 <thoughtpolice> test-framework is IMO the bees kness
08:01:01 <bgamari> but it doesn't use quickcheck very extensively
08:01:37 <thoughtpolice> colored output, does checks in paralell (+RTS -N) while remaining deterministic (so you can diff testsuite results,) XML output if you want something different, and a simple interface
08:01:46 <thoughtpolice> http://batterseapower.github.com/test-framework/
08:01:53 <bgamari> cool
08:01:57 <thoughtpolice> it basically covers all the infrastructure you just need to write tests
08:02:12 <bgamari> I'll have a look
08:02:45 <bgamari> I guess people often rely on a combination of QuickCheck and HUnit?
08:03:05 <thoughtpolice> i've never used hunit personally
08:04:54 <bgamari> thoughtpolice: alright, so I guess not
08:05:20 <bgamari> quicksilver: It seems like XMonad stuffs all of its testing code in a Properties module
08:10:32 <dpratt71> has any one had a chance to read the article on "Attributed Variables" in the latest issue of The Monad Reader (#18)?
08:11:03 <dpratt71> the article was also posted on the author's blog: http://logicaltypes.blogspot.com/2011/04/attributed-variables-their-uses-and-one.html
08:11:51 <dpratt71> the code references a function 'domain' the definition of which I do not see in the article
08:12:07 <dpratt71> I was wondering if there was an obvious implementation
08:12:43 <bgamari> thoughtpolice: How does one generate a list of exactly the size I'm supposed to generate
08:13:19 <bgamari> Ahh, perhaps sized vectorOf?
08:13:36 <bgamari> :t sized
08:13:37 <lambdabot> forall a. (Int -> Gen a) -> Gen a
08:13:42 <bgamari> :t vectorOf
08:13:42 <lambdabot> forall a. Int -> Gen a -> Gen [a]
08:14:05 <bgamari> damn, I guess not
08:15:29 <ion> Perhaps replicateM 40 arbitrary :: Gen [Integer]
08:15:49 <mm_freak> what's Gen?
08:16:15 <ion> mm_freak: http://hackage.haskell.org/packages/archive/QuickCheck/2.4.1.1/doc/html/Test-QuickCheck.html#g:3
08:16:39 <bgamari> Ahh, I think I have it
08:16:46 <mm_freak> ah, quickcheck
08:16:52 <bgamari> sized (vectorOf arbitrarySizedIntegral)
08:17:06 <ion> bgamari: Actually, vector 40 :: Gen [Integer]
08:17:50 <ion> …which seems to be the same as vectorOf 40 arbitrary :: Gen [Integer]
08:18:16 <bgamari> ion: I need to use the size that I'm asked to generate
08:18:30 <ion> What do you mean?
08:18:50 <bgamari> This is to implement a Test.QuickCheck.Arbitrary instance
08:19:05 <ion> Ah! sized $ \n -> … n …
08:19:11 <bgamari> yep
08:19:19 <bgamari> I'm not quite right though
08:19:32 <bgamari> the argument order seems to be incorrect for this application
08:20:10 <bgamari> I'd need sized (\s->vectorOf s arbitraryBoundedIntegral)
08:20:29 <bgamari> Surely that's not what they intended
08:20:50 <ion> What’s wrong with it?
08:21:41 <bgamari> well, I guess nothing
08:21:50 <bgamari> It would have been nice if the lambda wasn't necessary
08:21:59 <bgamari> but that's a pretty minor objection
08:22:13 <ion> Ah, arbitraryBoundedIntegral doesn’t follow the size, it generates random numbers uniformly from the range of the type. Are you sure that’s what you want?
08:22:16 <ion> @pl \s -> foo s bar
08:22:16 <lambdabot> flip foo bar
08:22:20 <bgamari> ion: Yep
08:22:36 <ClaudiusMaximus> @unpl (`foo` bar)
08:22:36 <lambdabot> (\ a -> foo a bar)
08:22:47 <bgamari> ion: Thanks for asking though
08:23:38 <ion> Try: listOf arbitraryBoundedIntegral
08:24:03 <bgamari> listOf generates a randomly sized list
08:24:09 <bgamari> I think
08:24:10 <bgamari> sized (flip vectorOf arbitraryBoundedIntegral)
08:24:11 <bgamari> works
08:24:23 <bgamari> it just seems odd to me that the flip is necessary
08:25:06 <ion> What’s the problem with the list having a random size between 0 and the size parameter?
08:25:29 <bgamari> I'm generating two lists which will then be zipped
08:25:34 <bgamari> they must be of the same length
08:26:23 <joe6> @hoogle Word8 -> Word8 -> Word16
08:26:24 <lambdabot> Data.Fixed div' :: (Real a, Integral b) => a -> a -> b
08:26:24 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
08:26:25 <lambdabot> Prelude curry :: ((a, b) -> c) -> a -> b -> c
08:27:05 <bgamari> Damn
08:27:11 <bgamari> overlapping instances bite me again
08:27:18 <bgamari> Is there no way to override an instance
08:27:27 <Cale> bgamari: Of course, zip cuts the list off at the shorter of its inputs, but that may skew your distribution to rely on
08:27:36 <bgamari> I need an instance Arbitrary [Datum]
08:27:44 <Cale> newtype
08:27:47 <bgamari> with certain properties
08:27:49 <bgamari> alright
08:28:20 <Cale> (you'll see lots of examples of newtyping things to get different instances of Arbitrary in QuickCheck itself)
08:29:27 <Cale> http://hackage.haskell.org/packages/archive/QuickCheck/2.4.1.1/doc/html/Test-QuickCheck-Modifiers.html
08:30:47 <bgamari> Cale: Thanks!
08:31:07 <ion> zip <$> listOf arbitraryBoundedIntegral <*> sequence (repeat arbitraryBoundedIntegral) :: Gen [(Int, Int)]
08:32:01 <ion> One sized list of ints, one infinite list of ints, zipped together resulting in the size of the shorter one.
08:32:21 <bgamari> ion: Does this have any advantage over vectorOf
08:32:57 <ion> It uses some randomness. listOf does something like sized $ \s -> choose (0, s) >>= \n -> vectorOf n …
08:34:02 <ion> @pl \x -> sequence (repeat x)
08:34:02 <lambdabot> sequence . repeat
08:34:28 <ion> @pl \n x -> sequence (replicate n x)  -- replicateM?
08:34:28 <lambdabot> (sequence .) . replicate
08:34:39 <lunaris> @src replicateM
08:34:40 <lambdabot> replicateM n x = sequence (replicate n x)
08:34:46 <lunaris> Indeed.
08:35:05 <Lemon> I saw this thing where "forall x y. x ~ y => ..."
08:35:09 <Lemon> or similar
08:35:32 <Lemon> does that mean the type tries to unify x and y?
08:35:46 <lunaris> x ~ y is type equality -- it's a constraint that x and y are unifiable
08:35:51 <Lemon> okay
08:35:53 <lunaris> So in a sense.
08:36:09 <Lemon> is there a way to express that WITHOUT using (~)?
08:36:12 <bgamari> Cale: If I newtype DatumList v = DatumList [Datum v] is there an easy way to use the usual list operations (e.g. map) on DatumLists?
08:36:28 <lunaris> My gut says no.
08:36:29 <lunaris> I mean.
08:36:39 <lunaris> There're things like Oleg's TypeEq stuff.
08:36:54 <lunaris> And there are tricks you can play with GADTs.
08:36:55 <ion> bgamari: Use newtype deriving to derive a Functor instance and use fmap.
08:37:03 <lunaris> So it's emulatable.
08:37:13 * lunaris is digging a large, overloaded hole.
08:37:28 <lunaris> For example, are you familiar with GADTs?
08:37:49 <Lemon> yes
08:37:59 <lunaris> Well, you can define a type such as:
08:38:10 <ion> As for what i was trying to do with @pl was to find a function like the imaginary repeatM, but @pl can’t derive replicateM like that either.
08:38:18 <lunaris> data Equals a b where Equals :: Equals a a
08:38:22 <Lemon> huh
08:38:33 <Lemon> what does that mean
08:38:47 <lunaris> Effectively you're defining your own notion of a proof that two types are equal.
08:39:01 <lunaris> The constructor ``Equals'' is a witness that the type a is equal to itself.
08:39:02 <Lemon> yeah that's exactly what I want.
08:39:10 <Lemon> except
08:39:17 <Lemon> what if I don't want to use GADTs?
08:39:26 <lunaris> Hmm.
08:39:31 <lunaris> I'll let the channel field this one.
08:39:41 <Lemon> well I'll be honest
08:39:49 <Lemon> This isn't really a Haskell question
08:39:50 <quicksilver> if you don't use GADTs or type families then haskell can be interpreted into System F
08:40:03 <quicksilver> type equality cannot be formalised inside System F.
08:40:04 * lunaris breathes out.
08:40:09 <quicksilver> ergo, it's impossible. Right?
08:40:10 <lunaris> Thanks quicksilver
08:40:11 <Lemon> quicksilver, well that's a bummer.
08:40:18 <quicksilver> I'm not as sure as I sounded :)
08:40:56 <lunaris> I just quote code and step back when it gets real.
08:40:57 <quicksilver> But certainly GHC's semantics specifically adds type equality to interpret GADTs, and they later realised they could interpret type families in the same setting.
08:41:00 <lunaris> Or abstract, in this case.
08:41:19 <lunaris> And then came System F 2: Return of System F
08:41:39 <thoughtpolice> the sequel!
08:41:39 <lunaris> (Showing with InsideOut(X) surround sound)
08:42:01 <lunaris> System F 2 ~ Succ (System F)?
08:42:12 <Lemon> alright, so System F alone ain't enough
08:42:15 <lunaris> {-# LANGUAGE KitchenSink #-}
08:42:16 <lunaris> Run!
08:42:22 <ion> bgamari: {-# LANGUAGE GeneralizedNewtypeDeriving #-} newtype DatumList v = DatumList { fromDatumList :: [v] } deriving (Eq, Ord, Read, Show, Monoid, Functor, Applicative, Monad, MonadPlus); (succ <$> MyList [0..5]) == MyList [1..6]
08:42:32 <lunaris> Now that's a deriving line I can believe in.
08:42:38 <bgamari> hah
08:42:40 <bgamari> ion: Thanks
08:42:56 <Lemon> now back to GADTs
08:43:04 <lunaris> It's always back to GADTs.
08:43:21 <Lemon> so you write something like data Equal a b where Equals :: Equals a a
08:43:34 <Saizan> Lemon: in system F you can use leibniz equality: EQ (A : *) (x y : A) = forall (p : A -> *) . p x -> p y
08:44:34 <Lemon> Saizan, I am somewhat confused as to what that means
08:45:11 <bgamari> ion: It seems like I need {-# LANGUAGE DeriveFunctor #-} as well, no?
08:45:26 <lunaris> bgamari: No, since there is a functor instance for [] already.
08:45:39 <lunaris> Though maybe DeriveFunctor would derive the same instance as GeneralisedNewtypeDeriving.
08:45:52 <Saizan> Lemon: heh, sorry, i gave you the dependent version
08:45:53 <bgamari> bah
08:46:01 <bgamari> lunaris: The compiler thinks otherwise
08:46:15 <bgamari>     Can't make a derived instance of `Functor DatumList'
08:46:15 <bgamari>       (even with cunning newtype deriving):
08:46:15 <bgamari>       You need -XDeriveFunctor to derive an instance for this class
08:46:16 <Lemon> isn't (p : A -> *) just (p : * -> *)?
08:46:18 <Saizan> Lemon: EQ (x y : *) = forall (p : * -> *) . p x -> p y
08:46:22 <Lemon> wait no that's not right
08:46:42 <lunaris> bgamari: Stupid compiler
08:47:03 <Lemon> Saizan, what's the difference between that and the GADT equality thing?
08:47:15 <Saizan> in haskell you'd say newtype EQ x y = EQC (forall p. p x -> p y)
08:47:21 <lunaris> bgamari: Works for me... :/
08:47:25 <bgamari> lunaris: Perhaps this is relevant, http://hackage.haskell.org/trac/ghc/ticket/4816
08:47:34 <bgamari> looks like I might need a newer compiler
08:47:46 <hpaste> ion pasted “DatumList, GeneralizedNewtypeDeriving” at http://hpaste.org/48815
08:47:47 <thoughtpolice> Equals is a value-level witness term that show's equality. leibniz's axiom states logically that "two things are equivalent iff they have the same properties" (x and y being 'two things' in saizan's example, p being the predicate)
08:47:52 <thoughtpolice> *shows
08:47:55 <Saizan> Lemon: well, mostly that this one doesn't need gadts, but it's not as nice to use
08:48:07 <ion> bgamari: That code works for me at least.
08:48:23 <bgamari> ion: Yeah, I think it's a compiler bug
08:48:26 <siracusa> When releasing packages with executables, is there a recommended way to manage where e.g. config files are stored? I vaguely recall cabal using a data directory for some programs.
08:48:39 <Saizan> a value of type (EQ a b) is still a value-level witness of the equality of a and b, maybe not so explicitly though
08:48:41 <bgamari> ion, lunaris: Or perhaps not. I'm running 7.0.3
08:48:50 <bgamari> ion, lunaris: Which should have this bug fixed
08:48:59 <thoughtpolice> yeah, i guess the compiler in the GADT case is just figuring out more for you
08:49:01 <Lemon> Saizan, then what was that about System F not being able to formalize type equality, according to quicksilver?
08:49:25 <dcoutts> siracusa: for runtime conf files you should use the System.Directroy.getAppUserDataDirectory "yourapp"
08:49:26 <quicksilver> well, Saizan knows more than me ;)
08:49:31 <Lemon> also I think I understand now what that thing means
08:49:41 <dcoutts> siracusa: the datadir is for static (read-only) data files
08:49:41 <quicksilver> I was recalling things that I had heard, possibly wrongly.
08:49:48 <dcoutts> siracusa: the Cabal datadir I mean
08:50:03 <Lemon> hm
08:50:52 <siracusa> dcoutts: And how do I get the path of the data dir from my program after installation?
08:51:00 <Spockz> kosmikus: can I somehow include source files inside a begin{spec} block? If I just do \begin{spec}%input file\end{spec} it takes the input directive literally
08:51:15 <dcoutts> siracusa: using the Paths_pkgname module that cabal generates for you
08:51:33 <dcoutts> siracusa: getDataFileName :: FilePath -> IO FilePath
08:51:45 <Lemon> also shouldn't that newtype be
08:52:03 <Lemon> forall p. (p x -> p y, p y -> p x)?
08:52:06 <Lemon> or something
08:52:34 <Lemon> the function arrow is "if", not "if and only if", right?
08:52:38 <Saizan> Lemon: you can build EQ a b given EQ b a
08:52:38 <bgamari> ion: Ahh, the problem is I'm doing this: newtype DatumList v = DatumList [Datum v]
08:52:48 <ion> bgamari: Btw, if you have newtype MyList a = MyList { fromMyList :: [a] } for an Arbitrary instance, the ViewPatterns extension is very nice if your properties want lists, not MyLists: prop_foo :: MyList Int -> Bool; prop_foo (fromMyList -> xs) = … xs …
08:52:54 <bgamari> ion: It doesn't like the fact that it's a list of (Datum v)s
08:53:00 <Saizan> Lemon: and similarly transitivity
08:53:06 <accel> is there any usable irc client written in haskell?
08:53:13 <siracusa> dcoutts: Ok, I'll try that
08:53:20 <bgamari> ion: If I keep the type as DatumList [v] things work
08:53:35 <Lemon> Saizan, how do you build EQ b a from EQ a b?
08:53:42 <ion> bgamari: Ah
08:53:50 <bgamari> ion: But it doesn't make much sense to define DatumList as [v]
08:53:59 <bgamari> ion: Any ideas what's going on here?
08:54:47 <Saizan> Lemon: by applying the function inside to a (EQC (\ px -> px) :: EQ a a)
08:55:09 <lunaris> bgamari: Effectively there's no functor instance for ([] . DatumList) (where . is the mythical type composition operator)
08:55:15 <ion> bgamari: Oh, why didn’t i figure this out earlier? How about just listOf (liftA2 (,) arbitrarySizedIntegral arbitrarySizedIntegral)?
08:55:26 <ion> bgamari: arbitraryBoundedIntegral that is
08:55:50 <lunaris> ion, bgamari: If you've got MonadComprehensions on, you might get away with (not sure):
08:56:01 <Lemon> wut
08:56:06 <Lemon> oh god my brain
08:56:19 <lunaris> listOf [ (x, y) | x <- arbitrarySizedIntegral, y <- arbitrarySizedIntegral ]
08:56:26 <bgamari> ion: That is pretty cool
08:56:38 <lunaris> (Not sure of the Applicative/Monad instances though, might need a parallel comprehension)
08:56:40 <bgamari> lunaris: Any idea what to do about that?
08:57:08 <lunaris> @hoogle DatumList
08:57:08 <lambdabot> No results found
08:57:11 <lunaris> @hoogle Datum
08:57:11 <lambdabot> No results found
08:57:25 <bgamari> lunaris: Sorry, it's my own type
08:57:28 <lunaris> Ah
08:57:32 <lunaris> QuickCheck noob
08:57:33 <bgamari> lunaris: data Datum v = Datum !Time !v deriving Show Ord
08:57:47 <lunaris> Well, assuming it's just some opaque type.
08:58:14 <bgamari> ignore the Ord there
08:58:32 <Saizan> Lemon: ah, also, this requires at least System F_3, not sure if by System F you meant System F_2 or System F_omega
08:59:40 <cpa> is there a simple way to a run a shell command and get the result in a string?
08:59:51 <cpa> System.Cmd.system prints the result
08:59:57 <Lemon> Saizan, I'm still trying to figure out that previous thing you said
09:00:17 <Lemon> applying the function inside to (Eq id)?
09:00:25 <Lemon> what would that do?
09:00:36 <bgamari> lunaris: assumed...
09:00:45 <lunaris> bgamari: Sorry, just playing.
09:00:56 <Saizan> Lemon: you have f :: forall p. p a -> p b, right? and EQ a a
09:01:02 <bgamari> lunaris: No worries, take your time
09:01:03 <lunaris> bgamari: I don't think it's going to let you derive Functor with just GeneralizedNewtypeDeriving.
09:01:09 <Clint> cpa: System.Posix.POpen?
09:01:10 <Lemon> Saizan, right
09:01:12 <lunaris> bgamari: So I see two options
09:01:16 <lunaris> bgamari: Either use DeriveFunctor
09:01:24 <Lemon> so I say (f = id)
09:01:29 <quicksilver> cpa: there is lots of stuff in system.process
09:01:49 <lunaris> bgamari: Or write instance Functor DatumList where fmap f = DatumList . fmap (fmap f) . fromDatumList (substitute constructors/destructors appropriately)
09:01:50 <Saizan> Lemon: now, if we take p to be (\(t :: *) -> EQ t a); then f :: EQ a a -> EQ b a
09:01:58 <quicksilver> cpa: http://www.haskell.org/ghc/docs/7.0.2/html/libraries/process-1.0.1.5/System-Process.html
09:02:02 <quicksilver> cpa: you might want 'readProcess'
09:02:14 <cpa> quicksilver: yup I just found readProcess actually
09:02:20 <cpa> I missed it at first glance
09:02:26 <cpa> thanks!
09:02:33 <Lemon> oh
09:02:35 <accel_> accel_:
09:02:40 <Saizan> Lemon: which you can apply to the EQ a a value to get EQ b a
09:02:41 <accel> damn it; irssi color is still yellow
09:02:41 <Lemon> I think I see where this is going
09:03:52 <bgamari> lunaris: It seems the right thing to do here would be use DeriveFunctor, no?
09:03:58 <bgamari> Assuming I'm always using GHC
09:04:10 <lunaris> bgamari: Indeed.
09:04:21 <lunaris> bgamari: There's nothing wrong with that assumption IMO :)
09:04:30 <lunaris> GeneralizedNewtypeDeriving makes the same one, for example.
09:04:35 <bgamari> heh, agreed
09:04:58 <bgamari> lunaris: Why is DeriveFunctor separate from GeneralizedNewtypeDeriving?
09:05:29 <c_wraith> bgamari: you can use DeriveFunctor for *all* types with at least one type variable.  Not just newtypes.
09:06:19 <c_wraith> bgamari: this is a consequence of there being only one correct Functor implementation for a particular type, and it being mechanically derivable.
09:07:53 <Saizan> Lemon: while this is theoretically nice the gadts way fits better with haskell's and other more advanced type systems
09:08:00 <kosmikus> Spockz: no, no directives in code/spec blocks
09:08:42 <Lemon> Saizan, did you mean that (forall c :: * -> *. c x -> c y) is sufficient in System F_3 only, so that in System F_2 or lower you must write something else?
09:09:05 <Spockz> kosmikus: so is there a way to highlight source files with lhs2TeX which themselves are not `literate'?
09:09:06 <bgamari> Cale, ion: Bah, now how do I use list deconstruction (e.g. a:as) on this newtype
09:09:07 <Lemon> also, what is (forall a b. a ~ b) anyway?
09:09:28 <bgamari> Cale: It seems like the newtype imposes a very high cost
09:09:33 <bgamari> on existing code
09:09:33 <Saizan> Lemon: in System F_2 you can't write (forall c :: * -> *. c x -> c y) as a type
09:09:39 <lunaris> bgamari: A syntactic cost, yes.
09:09:47 <kosmikus> Spockz: why not make them literate?
09:09:55 <bgamari> c_wraith: Thanks!
09:09:59 <Lemon> I mean, it looks like a type, but is it inhabited by anything?
09:09:59 <lunaris> bgamari: You can use ViewPatterns and something like f (unwrapNewtype -> d : ds) = ... for example.
09:10:14 <Saizan> Lemon: because in System F_2 you can only abstract over type variables of type *, not * -> *
09:10:15 <lunaris> Lemon: Is has one inhabitant (I believe)
09:10:25 <lunaris> Which is the proof that a and b are unifiable.
09:10:32 <ion> bgamari: With ViewPatterns, f (fromDatumList -> (x:xs)) = foo x bar xs
09:10:37 <Lemon> which is what, in haskell?
09:10:39 <Lemon> id?
09:10:52 <lunaris> Lemon: In Haskell, I'm not sure it's actually realised by anything.
09:11:05 <lunaris> Though I'm a complete n00b in this area and just speculating here.
09:11:06 <bgamari> ion: Hmm, alright. I guess that works
09:11:18 <Saizan> Lemon: forall a b. a ~ b is not a valid haskell type
09:11:28 <bgamari> It's just unfortunate that existing code is hit so hard
09:11:31 <Saizan> Lemon: since a ~ b is a constraint, like typeclass ones
09:11:37 <Lemon> oh
09:11:46 <lunaris> bgamari: I've been looking at this for a few days, ironically.
09:11:50 <Spockz> kosmikus: because then our parser cannot read them anymore, it's a basic lambda language
09:11:50 <bgamari> Really I just want QuickCheck to generate a list of Datums which are sorted
09:12:02 <lunaris> One option that can work is something like the newtype(s?) package.
09:12:16 <lunaris> Which makes a Newtype type class which means you can avoid explicit packing/unpacking.
09:12:16 <bgamari> I can define Ord on Datum if that helps
09:12:18 <Saizan> so e.g. "forall a b. a ~ b => a -> b" would be a valid haskell type
09:12:19 <lunaris> :t ala
09:12:20 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
09:12:30 <lunaris> So you can do something like:
09:12:36 <lunaris> > ala Product foldMap [1..4]
09:12:37 <lambdabot>   Not in scope: `foldMap'
09:12:43 <lunaris> > ala Product Data.Foldable.foldMap [1..4]
09:12:44 <lambdabot>   24
09:12:50 <lunaris> > ala Sum Data.Foldable.foldMap [1..4]
09:12:51 <lambdabot>   10
09:12:55 <lunaris> Etc.
09:13:54 <bgamari> lunaris: Perhaps it would be easiest just to sort each of the [Datum]s that QuickCheck gives me before using them
09:14:09 <lunaris> bgamari: I'm not sure what the pattern is here
09:14:16 <lunaris> What's the type of the function you want to write?
09:14:40 <lunaris> Got an hpaste or something that shows what you have and what you want to make?
09:15:42 <hpaste> “Ben Gamari” pasted “Correlator ” at http://hpaste.org/48816
09:16:01 <bgamari> lunaris: I'm trying to write properties for dot
09:16:28 <bgamari> lunaris: Which expects lists of monotonically increasing abscissas (the first field in Datum)
09:16:42 <lunaris> Ok.
09:17:16 <Clint> what's the sanest way to write a function that acts on either [a] or [[a]]?
09:17:28 <lunaris> Clint: What kind of function?
09:17:33 <bgamari> lunaris: So as far as I can tell I have two options
09:17:56 <bgamari> lunaris: I can write a Arbitrary instance for Datum
09:18:06 <bgamari> and sort the result at some point
09:18:12 <bgamari> resulting list, that is
09:18:31 <bgamari> or I could write an Arbitrary instance for [Datum], newtype'd
09:18:39 <bgamari> the latter I really am not liking
09:18:40 <Clint> lunaris: in this case, sum $ map ((\x -> x*x) . length) $ L.group xs
09:18:50 <Clint> (where L is Data.List)
09:19:45 <lunaris> bgamari: So you write newtype DatumList v = DatumList { getDatumList :: [Datum v] }
09:19:49 <lunaris> Ok...
09:20:01 <Cale> bgamari: Did you see the example code in the Haddock I linked? It's usually not too hard to select which instance you want just by pattern matching with the newtype
09:20:39 <Cale> bgamari: (at least, the cost is just one identifier per variable you want to use that newtype's instance with, which seems pretty minimal)
09:20:47 <Clint> @unpl sum $ map ((\x -> x*x) . length) $ L.group xs
09:20:47 <lambdabot> (sum (map (\ g -> (\ x -> x * x) (length g)) (L.group xs)))
09:21:16 <hpaste> Baughn pasted “Stack overflow” at http://hpaste.org/48817
09:21:18 <Clint> @pl (sum (map (\ g -> (\ x -> x * x) (length g)) (L.group xs)))
09:21:18 <lambdabot> sum (map (join (*) . length) (L.group xs))
09:22:02 <ion> @pl \xs -> sum $ map ((\x -> x*x) . length) $ L.group xs
09:22:02 <lambdabot> sum . map (join (*) . length) . L.group
09:22:13 <Baughn> http://hpaste.org/48817 <- So I was trying to do a simple threading performance test (forkIO vs. forkOS), when I ran into something more disturbing.
09:22:16 <bgamari> Cale: I did see it, although I'm not entirely sure what you mean?
09:22:31 <Baughn> Why does this simple little program overflow the stack? >_>
09:22:35 <Clint> ion: thanks
09:23:33 <ion> clint: Although one could just write ((^2) . length)
09:23:45 <Cale> bgamari: You never use values of the newtype directly, you just use them as parameters to lambdas where you pattern match away the newtype constructor immediately
09:24:01 <Cale> bgamari: which means that you still get to work with [Datum] values,
09:24:08 <bgamari> Cale: Ahhh
09:24:11 <Cale> bgamari: but you get the special instance you wanted
09:24:21 <bgamari> Cale: Excellent
09:24:21 <Cale> Also, iirc, there's already a Sorted newtype
09:24:33 <Cale> Ordered, it's called actually
09:25:09 <Cale> So  myProperty (Ordered (xs :: [Datum])) = ... something that ordered lists of Datum should satisfy ...
09:25:22 <bgamari> Cale: Ahh, that explains why I didn't find it
09:27:56 <Clint> @pl \vv -> sum $ map c $ map (\j -> [(vv L.!! (i-1) L.!! (j-1)) | i <- [1..L.length vv]]) [1..L.length (head vv)]
09:27:56 <lambdabot> sum . map c . ap (map . flip flip [] . ((:) .) . ap (flip . ((<-) .) . flip flip i . ((|) .) . (. subtract 1) . (!!) . (!! (i - 1) L.) . ($ L.)) (enumFromTo 1 . L.length)) (enumFromTo 1 . L.length .
09:27:56 <lambdabot> head)
09:28:09 <ion> :-D
09:28:11 * Clint stares.
09:28:54 <Jafet> {- as L -}
09:29:03 <bgamari> Somehow the act of merely splitting up my project into two modules resulted in a 4-fold slowdown
09:29:17 <Clint> Jafet: hm?
09:29:19 <siracusa> Any ideas why I get "Unknown fields: data-files" from cabal configure? I guess Cabal-Version: >= 1.6 should fine for that!?
09:29:26 <benmachine> bgamari: module boundaries probably affect inlining
09:29:26 <bgamari> Presumably because it's no longer using my specialized polymorphic function
09:29:37 <bgamari> benmachine: Apparently
09:29:47 <Jafet> Well, @pl isn't @compress
09:29:52 <benmachine> bgamari: you could try INLINE pragmas
09:29:55 <bgamari> benmachine: But nothing needs to be inlined across module boundaries the way I split it up
09:30:04 <benmachine> oh
09:30:06 <Tomsik> bgamari: afaik no inlining happens between modules
09:30:12 <benmachine> Tomsik: untrue
09:30:19 <bgamari> All of the expensive operations all occur within the library module
09:30:24 <benmachine> well, I'm not an expert, but I'm pretty sure cross-module inlining happens
09:30:34 <benmachine> bgamari: are you exporting anything you want inlined?
09:30:37 <bgamari> I only split out the front-end code into the new module
09:30:40 <bgamari> nope
09:30:43 <benmachine> oh
09:30:44 <Jafet> Definitions in the interface file can be inlined.
09:30:47 <quicksilver> cross-module inlining is pretty much vital for GHC
09:30:56 <benmachine> mm
09:31:06 <Tomsik> Okay, haskellwiki says you're right
09:31:07 <bgamari> benmachine: The only thing I can think of is that I have a {-# SPECIALIZED #-} declaration in the library
09:31:20 <Jafet> And you call that across modules?
09:31:24 <benmachine> isn't that supposed to be SPECIALIZE
09:31:29 <bgamari> yes
09:31:31 <benmachine> k
09:31:36 <hpaste> lunaris pasted “Ordered Arbitrary Instances” at http://hpaste.org/48818
09:31:49 <bgamari> and perhaps the specialized instance isn't being used
09:31:50 <lunaris> bgamari: This seems to work for me, but I don't know ^^
09:32:02 <bgamari> lunaris: Awesome. Thanks!
09:32:11 <lunaris> (Well, it typechecks -- hah)
09:32:12 <Baughn> > replicateM 4 [2] :: [Int]
09:32:14 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
09:32:14 <lambdabot>         against inferred type ...
09:32:14 <benmachine> Clint: oh btw, @pl can't handle list comprehensions
09:32:32 <dcoutts> siracusa: wierdly the data-files field is global, not beloning to the library/exe sections
09:32:37 <benmachine> it just thinks <- and | are operators
09:32:39 <Baughn> > replicateM 4 [2] :: [[Int]]
09:32:39 <lambdabot>   [[2,2,2,2]]
09:32:43 <benmachine> you have to feed it into @undo first
09:32:47 <Baughn> > length $ replicateM 1000000 [2] :: [[Int]]
09:32:48 <lambdabot>   Couldn't match expected type `[[GHC.Types.Int]]'
09:32:48 <lambdabot>         against inferred t...
09:32:56 <Baughn> > length $ (replicateM 1000000 [2] :: [[Int]])
09:32:58 <lambdabot>   *Exception: stack overflow
09:33:19 <parcs> does dynamic linking affect cross-module inlining?
09:33:21 <ion> @undo [ f x | x <- [a..b], p x ]
09:33:21 <lambdabot> concatMap (\ x -> if p x then [f x] else []) [a .. b]
09:33:37 <ion> Cool, i didn’t know @undo handles list comprehensions.
09:33:49 <Jafet> > length [1..10^9]
09:33:53 <lambdabot>   mueval-core: Time limit exceeded
09:33:54 <bgamari> benmachine: Looks like I might have found the issue
09:33:55 <lunaris> @. pl undo [ f x | x <- [a..b], p x ]
09:33:55 <lambdabot> flip (liftM2 if' p (return . f)) [] =<< [a..b]
09:33:57 <siracusa> dcoutts: Putting it globally it gives me "Construct not supported at this position: F 20"
09:33:59 <benmachine> parcs: I don't imagine so
09:34:16 <bgamari> benmachine: I was SPECIALIZEing the wrong function (dot', called from dot which is the one which I exposed)
09:34:18 <Jafet> > replicateM 1000000 [2::Int] `deepseq` ()
09:34:20 <lambdabot>   Not in scope: `deepseq'
09:34:22 <benmachine> bgamari: ic
09:34:23 <Clint> benmachine: oh, good to know
09:34:31 <dcoutts> siracusa: in the same section as the initial things, not on its own
09:34:46 <Baughn> > deepSeq
09:34:47 <lambdabot>   Not in scope: `deepSeq'
09:34:57 <Baughn> > rnf
09:34:58 <lambdabot>   Not in scope: `rnf'
09:35:07 <saml> we need cms written in haskell, right?
09:35:19 <lunaris> :t Control.Parallel.Strategies.deepseq
09:35:20 <lambdabot>     Not in scope: `Control.Parallel.Strategies.deepseq'
09:35:20 <Jafet> Haskell isn't webscale yet
09:35:23 <lunaris> :(
09:35:38 <Jafet> But I hear that GHC 8 will allow you to write programs in XML.
09:35:38 <lunaris> @hoogle deepSeq
09:35:38 <lambdabot> No results found
09:35:51 <lunaris> LANGUAGE XmlSyntax
09:35:56 <ion> And Template Haskell will be replaced with XSLT.
09:36:13 <lunaris> Reflection via XPath
09:36:25 <lunaris> fromString shall be abolished.
09:37:01 <saml> xpath is good dsl for querying web. i'm sure google search uses xpath
09:37:06 <siracusa> dcoutts: Ok, moving it to the top section fixes it, thanks.
09:41:56 <joe6> are you guys serious about ghc8 and xml?
09:42:11 <copumpkin> ?
09:42:19 <ion> yes
09:42:33 <saml> yah. but it's actually html5. to follwo windows 8
09:42:57 <joe6> isn't xml for the managament?
09:43:17 <joe6> just throwing in more terminology..
09:43:22 <saml> xml is better version of s-expression
09:43:34 <joe6> no, it is not.
09:43:35 <saml> haskell is finally accepting lisp
09:43:45 <joe6> it is a more noisy version of s-expression.
09:43:54 <joe6> s-expression are simpler
09:44:13 <ion> saml: Yeah, s-expressions don’t use URI-form namespaces.
09:44:19 <saml> so it's better. xml has various editors that you can control with kinect.. interfacing dirctly with ast
09:44:36 <ion> So XML has less namespace conflicts than s-exprs.
09:44:40 <saml> s-expression is bound to emacs and textual editors
09:44:57 <joe6> basically, microsoft'ize ghc then?
09:45:09 <Jafet> You don't know where GHC is developed?
09:45:21 <saml> textually editing programs are so 70's
09:45:30 <ion> Well, SPJ is working for Microsoft™ isn’t he?
09:45:36 <companion_cube> microsoft research
09:45:39 <saml> you navigate 3d space with kinect to interact with AST represented by xml
09:45:48 <companion_cube> how can one use a kinect to manipulate xml? ôO
09:46:13 <Jafet> Web 3.0, all the cool kids do it now
09:46:18 <joe6> kinect is slow.
09:46:25 <erus`> did you see the gmail gestures thing?
09:46:28 <joe6> it will not be a programming tool, as it is now.
09:46:36 <saml> not with microsoft speech api. u can use voice command too, to manipulate ast
09:47:01 <ion> It’s as simple as speaking XSLT transformations out loud.
09:47:02 <joe6> i doubt that these tools will be good enough to navigate something as dense as code.
09:47:04 <companion_cube> Jafet: what do you call web 3.0 ?
09:47:29 <saml> using zoom interface, it's easy. think of google map
09:47:42 <Jafet> It's called Web 3.0. Not sure what its name is though.
09:47:42 <ion> That’s another win for XML: s-exprs don’t have XSLT.
09:47:43 <companion_cube> ion: try with perl
09:47:57 <companion_cube> i thought web 3.0 would be "semantic web"
09:48:16 <Jafet> What better semantics than Gibson-era physical metaphors?
09:48:43 <saml> and of course, your xml will be ajax-ed from the cloud. your code will be part of giant code base in hackage.
09:48:49 <erus`> web3.0 is the semantic net
09:49:16 <ion> I have two megabytes of hot RAM. Any buyers?
09:49:17 <joe6> saml, i get the sarcasm now.
09:49:29 <joe6> and it will all be flowing out of microsoft..
09:49:55 <saml> i think the future will be like this.. u directly commit to Apple's source code repository to release your iphone app
09:50:03 <Jafet> saml sounds perfectly serious to me
09:50:39 <saml> haskell needs to adapt to the future of cloud computing. so, i'm gonna start WebScale monad
09:50:41 <joe6> Jafet, yeah, right..
09:50:53 <companion_cube> commit to apple's source base ? you mean everyone will be employee of apple ?
09:50:58 <Jafet> Well, relative to myself, at least
09:51:14 <ion> companion_cube: Everyone will be a servant of Steve.
09:51:22 <companion_cube> iServant
09:51:24 <joe6> and Bill.
09:51:25 <saml> no.. like AppStore, apple will announce CodeStore
09:51:40 <companion_cube> only 9.99$ to push a commit!
09:51:46 <joe6> xml is lousy. I felt EDI was a lot better.
09:52:21 <joe6> come on, adding more text wrappers to data is a lousy idea? unless, it is for some management guy.
09:52:33 <saml> xml is extensive. accept the future.  u can easily create simple dsl with extensibility of xml.
09:52:39 <joe6> so, is EDI.
09:52:51 <joe6> that has always been the case.
09:53:15 <sm> morning all
09:53:19 <saml> midi is better than edi
09:53:20 <companion_cube> saml: who cares about extending syntax of a language ? text is fine for this, problems are more for interfacing with libs, rpc, other langages...
09:53:22 <joe6> most good code is extensible.
09:53:45 <ion> I store all my Haskell programs in MIDI SysEx dumps.
09:53:49 <saml> xml is universal VM for everything.
09:54:18 <companion_cube> xml is runnable now ? how convenient
09:54:23 <joe6> in my experience, xml has been a hindrance rather than a help for anything serious/big.
09:55:10 <joe6> putting text into dense data is a bad idea. speed, bandwidth..
09:56:14 <joe6> anyway, let's start with putting xmonad into xml...
09:56:18 <joe6> haha..
09:56:27 <gwern> yo mamma is like xml; she's fat and gets around and everyone abuses her
09:57:11 <HugoDaniel> how do i delete a package from hackage ?
09:57:12 <joe6> midi does not seem to have anything to do with EDI. I am talking about the EDIFACT
09:57:18 <HugoDaniel> i have a package that i want to rename
09:57:20 <HugoDaniel> :)
09:57:29 <gwern> HugoDaniel: you email someone and ask
09:57:32 <companion_cube> HugoDaniel: packages are immutable and pure
09:57:36 <HugoDaniel> :D
09:57:56 <HugoDaniel> ok, ill try to mail and ask
09:58:05 * gwern whispers to HugoDaniel - the hackage specifies unsafePerformEmailRoconnor as an escape hatch from purity
09:58:13 <HugoDaniel> mr.hackage@haskell.org :)
09:58:24 <gwern> *hackage standard
09:58:32 <HugoDaniel> ahah
09:58:41 <gwern> I think it was roconnor.
09:58:47 <gwern> I could be mistaken. maybe it was someone else.
09:58:56 <companion_cube> unsafeDisturbSpj
09:59:01 <companion_cube> we could do more of those
09:59:01 <smarter> joe6: xmonad in xml might happen with the proposed rewrite in Java, "xfactoryfactory" : http://hackage.haskell.org/trac/summer-of-code/ticket/1575 :]
09:59:29 <companion_cube> XSingletonAdapterFactoryFactory
09:59:37 <companion_cube> the simple tiling WM !
10:00:32 <smarter> It's so abstract, you can easily make it work on your own monitor if you just write implementations for ten interfaces!
10:01:02 <companion_cube> you can also adapt it to work on a laser printer with only 10,000 java lines !
10:01:52 <smarter> but you only get aliased text, anti-aliasing might work with JDK8
10:01:55 <joe6> smarter, I am being sarcastic.
10:02:20 <joe6> smarter, i think adding xml to solve any problem, is like adding oil to stop a fire.
10:02:35 <smarter> joe6: I am too, don't worry ;)
10:14:36 <Bfv9000> where can i ask a databases question?
10:17:36 <kmc> Bfv9000, is it Haskell-related?
10:17:46 <Bfv9000> maybe...
10:17:54 <kmc> then you can ask it here
10:18:12 <Bfv9000> i was just joking, it has to do with the entity relationship model
10:18:43 <Bfv9000> i am facing a problem that would be easily solved with double inheritance (ie, inheritance from two different entities)
10:18:58 <Bfv9000> and i'm not sure if it's valid under the basic framework
10:20:09 <Bfv9000> kmc, any ideas? :p
10:21:39 <_habnabit> is there a better way of writing, for example, `map (\x -> x y) z`
10:21:59 <kmc> map ($ y) z
10:22:59 <ion> bfv9000: I don’t think you asked the question.
10:23:24 <Bfv9000> ion, is double inheritance valid in the framework of the entity relationship model?
10:23:32 <_habnabit> aha.
10:23:44 <ion> bfv9000: maybe
10:23:57 <Bfv9000> great answer. :|
10:23:57 <_habnabit> I always forget you can partially apply the rhs of operators.
10:27:37 <dafis> _habnabit: then you could also map (flip id y) z
10:27:56 <dafis> @ty flip id
10:27:57 <lambdabot> forall a b. a -> (a -> b) -> b
10:28:56 <ion> or flip ($) y, which seems clearer to me since the use of the specialized version of id has some semantic value. :-)
10:29:39 <dafis> map (`id` y)
10:29:43 <_habnabit> heh
10:30:11 <kmc> lots of ways to skin this cat
10:30:29 <ion> Haskell’s slogan is TMTOWTDI for a reason.
10:30:33 <kmc> is it?
10:30:51 <sm> I thought that was perl's slogan
10:30:53 * dafis thought it was ASAAC
10:31:01 <dafis> (Haskell's slogan)
10:31:15 <kmc> ASAAC?
10:31:18 <kmc> oh, right
10:31:24 <dafis> Avoid success at all costs
10:31:27 <kmc> expanding the acronym would be counterproductive
10:31:33 <kmc> nooo
10:31:34 <sm> too late
10:31:40 <dafis> sorry
10:32:36 <ion> Haskell would be successful if it were more like Perl.
10:33:04 <kmc> i love the preachy blog posts about what Haskell needs to do to be popular
10:33:11 <kmc> which just presuppose that this is the goal
10:33:12 <dafis> I disagree being like perl is utter failure
10:33:18 <dafis> *,
10:33:22 <osfameron> Perl would be more successful if it was more like Haskell!
10:33:27 <osfameron> etc.
10:33:28 <Jafet> Success is failure
10:33:41 <osfameron> War is Peace
10:33:43 <dafis> Jafet: that's an odd Monad instance
10:33:48 <Baughn> forkIO is serialization
10:33:51 <Baughn> ..
10:34:04 <Jafet> Or with blogs, ignorance is strength
10:34:14 * Baughn twitches. If I run this program without forkIO, it uses 400% cpu. If I have the forkIO, it caps at 150%.
10:34:17 <Jafet> :t strength
10:34:18 <lambdabot> Not in scope: `strength'
10:34:25 <Baughn> And, of course, the non-forkIO version is faster.
10:34:36 <osfameron> kmc: we get the preachy blogs about what to do to be more successful for Perl too
10:34:37 <Baughn> But still takes twice as long as the version without -threaded.
10:34:42 <osfameron> mostly stuff about marketing
10:35:02 <Baughn> ..hmm. Maybe randomRIO is..
10:35:36 <dafis> Baughn: methinks randomRIO doesn't parallelise well
10:35:44 <Baughn> This seems likely.
10:39:29 <ski> Saizan,quicksilver : istr you can't define e.g. `unMaybe :: EQ (Maybe a) (Maybe b) -> EQ a b', though ..
10:43:42 <ivant> kmc, what's wrong with Caltrain? I actually quite enjoy the ride
10:48:44 <kmc> inconvenient schedule
10:48:49 <kmc> tends to hit people / cars / animals
10:51:04 <kmc> isn't electrified and really should be
10:54:44 * hackagebot heist-async 0.3.0.0 - Adding support for asynchronous updates ("AJAX") with heist  http://hackage.haskell.org/package/heist-async-0.3.0.0 (DanielPatterson)
11:06:47 * hackagebot entropy 0.2 - A platform independent entropy source  http://hackage.haskell.org/package/entropy-0.2 (ThomasDuBuisson)
11:18:00 <Saizan> ski, quicksilver: yeah, you need type families for that http://okmij.org/ftp/Computation/extra-polymorphism.html#injectivity
11:25:53 * hackagebot text-format 0.3.0.3 - Text formatting  http://hackage.haskell.org/package/text-format-0.3.0.3 (BryanOSullivan)
11:36:39 <poindontcare> is there a haskell mascot ?
11:37:16 <djahandarie> Lambda cats!
11:37:26 <thoughtpolice> um, i don't think there's an official one, although narwhals and cats are popular in this community i think :)
11:37:48 <dafis> Wasn't there a sloth on the cover of RWH?
11:38:20 <poindontcare> dafis: it is some kind of beetle
11:38:35 <dafis> pity
11:38:37 <thoughtpolice> a beetle that i believe was chosen due to it's incredible size-to-power ratio ;)
11:39:09 <Jafet> An astronaut
11:39:41 <poindontcare> Hercules beetle it is then :)
11:51:00 * hackagebot scrypt 0.3.2 - Stronger password hashing via sequential memory-hard functions.  http://hackage.haskell.org/package/scrypt-0.3.2 (FalkoPeters)
11:53:42 <gwern> a hackagebot announcement is a heck of a way to learn that you reinvented the wheel
11:54:00 * gwern looks mournfully at http://www.gwern.net/Self-decrypting%20files#memory-bound-hashes 
11:54:01 * hackagebot HaLeX 1.2 - HaLeX enables modelling, manipulation and animation of regular languages  http://hackage.haskell.org/package/HaLeX-1.2 (GwernBranwen)
11:56:02 <kmc> the beetle is a monad analogy you see
11:56:56 <roconnor> gwern: is yours pure or bindings?
11:57:05 <gwern> roconnor: no, it was just the general idea
11:59:23 <roconnor> gwern: wanna help me develop a homomorphic encryption based alternative to bitcoin? :)
11:59:44 <ezyang> If you develop homomorphic encryption, that'd be cool enough :-)
12:00:05 <roconnor> partial homomorphic encryption has been around for a while
12:00:17 <roconnor> though full homomorphic encryption is recent.
12:01:52 <copumpkin> :O
12:02:08 <copumpkin> roconnor: on an unrelated note (to homomorphic encryption)
12:02:15 <copumpkin> (but still related to crypto)
12:02:26 <copumpkin> did you see http://ed25519.cr.yp.to/index.html ?
12:02:29 <copumpkin> it looks neat
12:03:33 <gwern> no side-channels eh
12:04:02 <luite> gwern: hmm, increasing the number of memory accesses might not help much if your cpu/gpu can do large scale simultaneous multithreading
12:04:22 <luite> since that could hide memory latency to a large extent
12:04:43 <gwern> luite: what operations would you be multithreading in serial hashing?
12:04:54 <gwern> roconnor: how would that work, even?
12:06:09 <roconnor> the main idea is that to verify a transaction, you don't need the account balances to be public;  all you need to know is that the sum of the inputs equals the sum of the outputs and that each output is non-negative.
12:07:00 <gwern> that doesn't sound like it solves the coordination problem of agreeing on what fork of a double-spend is valid
12:07:01 <luite> gwern: you could test multiple strings simultaneously? although I don't know what exactly serial hashing is
12:07:30 <roconnor> gwern: oh that would use the bitcoin method.  I just want to enchance privacy.
12:08:05 * ski idly wonders what this `bitcoin' thing might be ..
12:08:10 <gwern> roconnor: so then what does homomorphic encryption do that the old chaum digital cash or multiparty computations (multiparty poker) didn't?
12:08:15 <copumpkin> ski: a neat idea!
12:08:44 <roconnor> gwern: allows us to use bitcoins decentralized ledger mechanism.
12:09:02 <gwern> butl... what are you storing on this ledger besides the balance of each address?
12:09:21 <roconnor> we would store encrypted balances instead of plaintext balances
12:10:16 * ski almost succeeds burning bread in toaster
12:10:21 <gwern> hm... ok, that might buy you something then
12:10:53 <roconnor> I think there is also room to hide who is doing transactions better ... but I haven't figured out how yet.
12:11:07 <luite> gwern: wasn't the objective to make brute forcing or rainbow table generation slower?
12:11:24 <gwern> luite: no. maybe you should read my page first. I'm a readable writer, I think.
12:12:13 <gwern> roconnor: it's not a *huge* improvement, it's more of a privacy worry that addresses are linked at all, the specific amounts are only extra cursed frosting on the damned cake, but worth thinking about
12:12:58 <ddarius> ski: Since the browning of toast dramatically increases it's absorption of radiant energy, most of the toasting actually happens just before burning.  Therefore, anyone who makes good toast is almost succeeding in burning it.
12:13:03 <roconnor> ya ... honestly I thought hiding the recipeients of the transactions would be easier ...
12:13:35 <ezyang> This is also why cities are hotter than the surronding countryside.
12:13:39 <luite> gwern: I started at the memory-bound hashes part, because that's what you linked.
12:14:34 <gwern> luite: oh, then see http://www.gwern.net/Self-decrypting%20files#hashing
12:15:02 <gwern> my chain of thought was first describe the scheme, then cover why it can'bt parallelized, then cover why it can't be serially sped up
12:19:39 <edwardw> @t (<=<)
12:19:39 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
12:19:53 <copumpkin> :t (<=<)
12:19:54 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
12:20:16 <edwardw> Thanks ;)
12:20:31 <danharaj> comonadic edwardk?
12:20:37 <ski> ddarius : *nod*, i have noticed that. in this case though, some parts of the edges (maybe one centimeter in) were completely black
12:20:58 <ski> (not that long ago i actually manages to get fire in the toaster ..)
12:21:07 <edwardw> danharaj: no
12:23:06 <parcs> mmmm, carcinogens
12:23:13 <nicoo> hi
12:23:43 * ddarius starts honing a joke by replacing "Does not compute" with "does not commute."
12:23:45 <xil> hi. Is it possible for someone to help me understand Haskell state? I've been using IORefs for all of my state but there is something that I would really like to not have to pass to every function as an input. I've been told to look at the State and StateT monads, but I just don't get how to use them; I don't see why they don't need to be passed in as inputs
12:24:36 <ski> they are passed the state as input, just not explicitly
12:25:31 <mauke> xil: Reader sounds more appropriate
12:25:58 <Cale> xil: Values of type State s a are internally represented as functions s -> (s,a), that is, they take an initial state of type s as a parameter, and produce a final state of type s and a result of type a.
12:26:09 <mauke> you can think of it this way: every monad adds special superpowers to your code
12:26:11 <edwardw> xli: I found "monad transfotmers step by step" was very helpful.
12:26:14 <ski> xil : yeah, if you only want to pass as input, then environment monads such as `Reader r' or `ReaderT r m'
12:26:30 <mauke> Reader gives you the ability to automatically pass a value to every part of the code
12:26:39 <ski> xil : in case you also want to return a new state, and thread the state through the calls, then `State s' and `StateT s m'
12:26:41 <mauke> State is similar but lets you also modify that value
12:26:47 <Cale> xil: The library (particularly the monad instance) gives you a convenient way of chaining together such computations, so that the final state from one computation becomes the initial state of the next.
12:27:11 <ski> xil : <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html> might be helpful in explaining how `State s' is just hiding passing a state argument (and returning an updated state)
12:27:16 <xil> I don't know how many of you are familiar with OpenGL but I want something like that StateVars that it uses for all of it's callbacks etc.
12:27:24 <kmc> @djinn (s -> (a, s)) -> (a -> (s -> (b, s))) -> (s -> (b, s))
12:27:25 <lambdabot> f a b c =
12:27:25 <lambdabot>     case a c of
12:27:25 <lambdabot>     (d, e) -> b d e
12:27:43 <ion> xil: I wrote http://heh.fi/state-monad some time ago. It may or may not be helpful.
12:27:55 <ski> heh
12:28:15 <Cale> ;___; emulating OpenGL's library design
12:28:57 <kmc> xil, if you want something like StateVar then you can use IORef, STRef, MVar, TVar, etc
12:28:58 <Cale> xil: You can of course use the StateVar library
12:29:01 <kmc> which are real mutable cells
12:29:12 <kmc> State does not provide real mutable cells, it's just sugar for passing states functionally
12:29:15 <kmc> as described above
12:29:29 <Cale> It's available as Data.StateVar from the StateVar package
12:29:31 <kmc> mauke, superpowers? ;P
12:29:33 <ddarius> Doesn't OpenGL not use its library design anymore?
12:29:47 <ski> well, `State s' gives a single (unnamed) mutable cell of type `s'
12:29:53 <xil> Cale: that's what I was looking to do really, but I can't see how to create a new StateVar, only manipulate one
12:29:57 <Twey> What's the difference between StateVar and IORef/STRef?
12:30:11 <Cale> xil: makeStateVar
12:30:22 <kmc> Twey, StateVar is an overloaded API, iirc
12:30:27 <kmc> but i doubt it deals with ST anyway
12:30:27 <Twey> Oh
12:30:30 <Twey> Oh.
12:30:37 <Twey> So what exactly does it encompass?
12:30:45 <Cale> makeStateVar :: IO a -> (a -> IO ()) -> StateVar a
12:30:50 <xil> kmc: I want the mutability of all of those, but without having to pass them as arguments. Right now I have tons of IORefs and MVars but I have to pass them as inputs to my functions, which is really annoying me because of how often I use them, unless you're saying I don't have to do that
12:30:57 <xil> Cale: yeah, I can't find such a function on hoogle
12:31:17 <kmc> xil, you can use (ReaderT IO) with IORef etc.
12:31:20 <Cale> http://hackage.haskell.org/packages/archive/StateVar/1.0.0.0/doc/html/Data-StateVar.html#v:makeStateVar
12:31:32 <kmc> if (State s a) is sugar for (s -> (a, s)) then (Reader s a) is sugar for (s -> a)
12:31:33 <xil> Cale: I saw it in the OpenGL source, but came up with nothing when I searched for it, don't know why
12:31:39 <ddarius> xil: Doesn't this fairly explicitly illustrate that your code is painfully coupled?
12:31:48 <Cale> Probably hoogle doesn't know about the StateVar package
12:32:10 <kmc> if GHC supported ACIO then there would be a good answer to "how do I make a global IORef?", even if that's also a bad question
12:32:36 <ski> xil : are these `IORef's and `MVar's you pass mostly short-lived, or longer-lived ?
12:32:38 <kmc> as is, you can make global IORefs only with low-level trickery
12:32:46 <xil> ddarius: I don't know. I am sort of scrambling to put together too complex things with insufficient knowledge. But that's how I've been learning about Haskell. I get better the more I try to use this stuff
12:32:59 <xil> ski: they live as long as the whole program
12:33:02 <kmc> {-# NOINLINE ref #-} ref :: IORef Int; ref = unsafePerformIO (newIORef 0)
12:33:42 <Cale> xil: My recommendation is just to put up with one additional parameter for each function which needs access to the mutable state of your program. You can bundle a bunch of StateVars or IORefs, etc. in a record datatype
12:34:15 <ski> xil : then either you could try what kmc suggests, or you could (which is probably better) bundle up all of then in a single state you pass around in `StateT MyVars IO'
12:34:25 <kmc> or ReaderT MyVars IO
12:34:33 <ski> hm, yeah, `ReaderT'
12:34:37 <Cale> Don't ReaderT just for this
12:34:43 <Cale> Just use a function parameter :P
12:34:46 <xil> Cale: that is ultimately what I want to do. Today I plan on going through and bundling them, but when I was first writing this stuff I didn't know I'd have so many. However, the global state I need is unrelated to the IORefs. I need it for a new thing that can't be bundled with the others
12:34:56 <kmc> yeah, Reader does not get you much sugar at all
12:35:11 <Cale> ReaderT will make a bunch of things more awkward (like anything higher-order on IO actions)
12:35:32 <ski> `Reader' and `ReaderT' are more useful when you want to abstract your type, or you want to nest it inside other monad transformers (which doesn't commute)
12:36:27 <ski> hm .. maybe we should have a list on haskellwiki or something about which standard monad transformers commutes, and which doesn't ?
12:36:56 * ski can mostly never recall which commutes and which doesn't -- having to rederive each time
12:37:17 <xil> so you have all given me a much bigger response than I was expecting, haha. So in order to make this easier on myself, how about I ask this, "of all of your suggestions, you haven't said much about StateVar. I'm just wondering why not. Do most of you think I shouldn't use it?" I ask because I like the interface it has with OpenGL. Makes things really easy for me
12:37:37 <kmc> StateVar does not solve your problem
12:37:48 <xil> kmc: aha, okay. So why not?
12:37:51 * ski has no idea what `StateVar' really does
12:38:03 <kmc> ski, it's just type classes for reference read and write
12:38:05 <Cale> xil: Because it's extraneous to the rest of your question, which is how to get references to state to bits of your code (the right answer to which is function parameters)
12:38:12 <kmc> xil, what goes on the left hand side of ($=)?
12:38:23 <kmc> if you want to write ($=) instead of writeIORef then go ahead and use StateVar
12:38:33 <kmc> but you still need to get that (IORef t) value to the right place either way
12:38:39 <parcs> use implicit params!
12:38:48 <ddarius> Use implicit configurations.
12:39:30 * ski ponders "use linear implicit parameters !"
12:39:34 <xil> kmc: no but what StateVar gives me, or what it looks like it gives me, is the ability to have a global variable I don't pass to functions as arguments. It looks to be just as easy to use as IORef, but I have to pass IORefs as arguments. With OpenGL I just set the viewport to whatever I want whenever I want. I never pass it to a function
12:39:45 <kmc> it doesn't do that
12:39:58 <kmc> read the StateVar library docs
12:40:07 <kmc> the OpenGL library already has global variables, defined in C
12:40:17 <Cale> xil: That's because OpenGL has global state, and the StateVars contain IO actions for reading and writing the global state
12:40:30 <kmc> what it's doing is no better founded than my unsafePerformIO hack above
12:40:42 <xil> ah
12:40:47 <kmc> anyway, read the docs to the library
12:41:16 <xil> kmc: well that's why I'm confused, because I read them and they don't look like the kind of state I want, but OpenGL seems to use them that way. That's why I was confused
12:41:58 <Visham> join #haskell
12:42:03 <kmc> data StateVar a = StateVar (IO a) (a -> IO ())
12:42:03 <ski> xil : you're basically saying "i want global state, too", which you can get using the `unsafePerformIO' hack
12:42:17 <kmc> (modulo extra wrapping)
12:42:23 <kmc> for OpenGL those IO actions are C FFI calls
12:42:29 <ski> xil : but it's usually better to refrain from global-extent state, if you can
12:42:39 <kmc> you could instead build a StateVar value where they're readIORef and writeIORef calls
12:42:44 <kmc> but... now you have to pass around that StateVar
12:42:51 <Cale> OpenGL uses global state in a ridiculous fashion, even. At least in the Haskell binding, there are some extra conveniences, but ordinarily, you can't even observe the state 100% of the time without also changing it. (You change one piece of state to determine what other piece of state another call will observe.)
12:43:05 <ski> (xil : and whether the state is global-extent or not is independent on whether you use `IORef' or `StateVar')
12:44:10 <xil> okay, so should I just bundle as much as I can in datatypes and just use the normal mutable stuff then?
12:44:20 <Cale> xil: yep
12:44:26 <xil> haha, okay
12:44:30 <Tomsik> Well, you know. GPUs aren't stateless and CPU has no hold on it, so it did make sense when they specified it as C-centric standard
12:44:34 <ski> the easiest is probably to make a record of your `IORef's
12:44:36 <Cale> xil: Of course, if you like the StateVar syntax, go ahead and make statevars
12:45:12 <xil> well I can really bundle all the IORefs into one IORef, so that's not too big a problem
12:45:26 <Cale> xil: Note also that you can control whether each part of the code has read or write permissions by passing  readIORef foo  or  writeIORef foo  selectively to the parts of the code which use the piece of state in question.
12:45:29 <xil> I didn't want the state for that, though, I wanted it for something else
12:45:48 <ski>   makeStateVarFromIORef :: IORef a -> StateVar a
12:45:49 <ski>   makeStateVarFromIORef ioref = makeStateVar (readIORef ioref) (writeIORef ioref)
12:45:56 <xil> Cale: that's good to know
12:46:03 <xil> but I have another question regarding threading
12:46:03 <ski> could be used to easily convert from `IORef' to `StateVar'
12:47:02 <xil> right now I'm just using MVars for the things that go between threads. Thing is, only one thread ever writes to it, even though many read from it. Should I still care about using another thread safe types? I don't really know the difference between them all
12:47:14 <iratsu> does parsec work with lazy bytestrings?
12:47:33 <ski> xil : btw, note that you don't *need* to "bundle all the IORefs into one IORef", you can just bundle al the `IORef's into a single record of them
12:48:29 <ski> (Cale : or using `CoYoneda IORef' and `CoYonedaOp IORef' :)
12:48:30 <xil> ski: what I meant was to make a datatype of non IORefs, and just instantiate an IORef of that type. Is that what you mean?
12:49:34 <ski> xil : i was talking about `data MyVars = MV { foo :: IORef Foo , bar :: IORef Bar , ...}'
12:50:29 <xil> ski: oh okay, well I actually only use the IORefs in one place, the same place at the same time, so I could just leave the IORefs out of it and put it outside
12:50:56 <ski> xil : in my case, i have several indepenent cells (with potential for race conditions), in your case you have a single cell
12:51:14 <ski> so they're different. i just wanted you to see that there's a choice
12:51:30 <saml> so let's start enterprise content management system
12:52:12 <xil> ski: yeah I got that. I was originally thinking about doing what you suggest, but then realized that I only use them at the same time in the same place. They are only intended for one particular function to be able to maintain information between calls
12:52:22 * ski . o O ( `newtype ECMS a = MkECMS (a -> ECMS a)' )
12:53:05 <ski> ok, so a single `IORef' (or `MVar') is probably good then
12:58:41 <xil> ski: but what about the threading stuff? If only 1 thread ever writes to something, and I don't care about a race condition, then should I even be using MVars for the state?
13:00:47 <ski> i don't recall if `IORef' is safe in the case one thread reads and another writes
13:01:39 <xil> ski: but at least MVar will do the job? I know there are a whole bunch of thread safe types and I am at least wondering if the others are overkill
13:01:53 <ski> yeah, `MVar' or `SampleVar' should definitely work
13:02:46 <ski> `SampleVar' if you want reads to get the last value (like with `IORef'), and `MVar' if you want reads to empty the value, so that you have to write a new value before reading again
13:04:53 <xil> ski: oh awesome, I do want SampleVar, never knew about it. I was always bothered by how MVar wouldn't let me just look at what's in there and then overwrite it later. I think there is a peek but in order to overwrite I have to swap and then disregard the returned value, which doesn't really matter but was just sort of "what a waste"
13:28:47 <MHD> Is it just me or does the haskell GLFW smell like odd design desicions?
13:29:07 <msieradzki> MHD use glfw-b
13:29:24 <msieradzki> can you tell what is bad in it?
13:29:53 <dpratt71> I need a function that will take every other  element of a list to produce a new list. Is there a library function that will do this (or almost do this)?
13:30:27 <saml> i think so
13:30:34 <saml> like, unzip?
13:30:39 <dafis> dpratt71: I don't think so, too easy to define yourself
13:30:56 <kmc> > catMaybes . zipWith ($) [Just, const Nothing] $ [1..10]
13:31:00 <lambdabot>   mueval-core: Time limit exceeded
13:31:22 <dafis> everyOther (x:_:xs) = x : everyOther xs; everyOther ys = ys
13:31:24 <kmc> > catMaybes . zipWith ($) (cycle [Just, const Nothing]) [1..10]
13:31:25 <lambdabot>   Couldn't match expected type `[Data.Maybe.Maybe a]'
13:31:25 <lambdabot>         against inferre...
13:31:38 <MHD> msieradzki: It's not that it is bad, more... odd? Like enableSpecial/disableSpecial. That pair can be implemented elegantly with a "specialFeature :: SpecialFeature -> StateVar Capability" instead
13:31:43 <kmc> > catMaybes $ zipWith ($) (cycle [Just, const Nothing]) [1..10]
13:31:44 <lambdabot>   [1,3,5,7,9]
13:31:57 <dpratt71> kmc: :)
13:32:20 <Cale> > take 1 <=< takeWhile (not . null) . iterate (drop 2) $ [1..10]
13:32:22 <lambdabot>   [1,3,5,7,9]
13:32:30 <kmc> > concat . zipWith ($) (cycle [pure, const []]) $ [1..10]
13:32:32 <lambdabot>   [1,3,5,7,9]
13:32:57 <Cale> > [x | (n,x) <- zip [0..] "Hello, World!", odd n]
13:32:58 <lambdabot>   "el,Wrd"
13:33:01 <Cale> > [x | (n,x) <- zip [0..] "Hello, World!", even n]
13:33:02 <lambdabot>   "Hlo ol!"
13:33:22 <dpratt71> heh
13:33:31 <dpratt71> which do I choose? :)
13:33:32 <kmc> > map snd . filter (even . fst) . zip [0..] $ "Hello, world!"
13:33:34 <lambdabot>   "Hlo ol!"
13:33:58 <Cale> dpratt71: whatever you like best :)
13:34:13 <dafis> dpratt71: depends, do you want extensibility or performance?
13:34:47 <Tomsik> > (\lst -> map fst . filter even . zip [0..] $ lst) ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']
13:34:47 <lambdabot>   No instance for (GHC.Real.Integral (a, GHC.Types.Char))
13:34:48 <lambdabot>    arising from a u...
13:34:50 <kmc> > map snd . filter fst . zip (cycle [False..]) $ "Hello, world!"
13:34:51 <lambdabot>   <no location info>: parse error on input `]'
13:34:51 <Tomsik> huh
13:35:00 <kmc> > map snd . filter fst . zip (cycle [False ..]) $ "Hello, world!"
13:35:01 <lambdabot>   "el,wrd"
13:35:10 <dpratt71> dafis: probably perf is more relevant to my problem, but I prefer definitions that are very declarative in nature
13:35:12 <Tomsik> > (\lst -> map snd . filter (even . fst) . zip [0..] $ lst) ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']
13:35:13 <lambdabot>   "acegi"
13:35:14 <saml> > let f [] l = reverse l; f (x:[]) l = f [] (x:l); f (a:b:xs) l = f xs (a:l)  in f [1,2,3,4,5] []
13:35:15 <lambdabot>   [1,3,5]
13:35:29 <kmc> does (map snd . filter fst) fuse?
13:35:58 <Tomsik> Don't ask me the hard questions, ghc knows such things.
13:35:59 <dafis> dpratt71: then take one of the elegant definitions and check the core, if that's not good, use the direct recursion
13:35:59 <saml> what does fuse mean?
13:36:26 <dafis> saml: eliminate the intermediate list
13:36:30 <kmc> saml, i'm asking whether GHC will optimize it to a single list traversal
13:36:31 <dafis> (in this case)
13:36:31 <Tomsik> It's easy to define this as a fold, but um
13:36:34 <dbpatterson> is there a built in function to test if all elements of a list are the same? I searched hoogle for Eq a => [a] -> Bool but didn't come up with anything.
13:36:36 <Tomsik> or rather unfold
13:36:51 <dpratt71> I'm kinda partial to Cale's list comprehension atm; surprised there isn't a general version in the libraries somewhere
13:36:58 <saml> ghc can do it
13:37:03 <saml> if it is possible
13:37:04 <kmc> :t let f [] = True; f (x:xs) = all (==x) xs in f
13:37:04 <dafis> dbpatterson: and $ zipWith (==) list (tail list)
13:37:05 <lambdabot> forall a. (Eq a) => [a] -> Bool
13:37:19 <saml> ghc can do anything that's possible for a compiler can do
13:37:28 <kmc> sadly no
13:37:33 <dbpatterson> kmc: that'll do :)
13:37:47 <Tomsik> GHC can't do fancy whole-program analysis
13:37:48 <saml> then we need more ph.ds contribute to ghc
13:38:02 <kmc> @pl \(x:xs) -> all (==x) xs
13:38:02 <lambdabot> ap (all . (==) . head) tail
13:38:04 <Nimatek> > all (==1) [1,1,1,1,1,1]
13:38:04 <lambdabot>   True
13:38:09 <dpratt71> thanks all, as usual almost more help than I can handle :)
13:38:37 <Tomsik> I read a paper on a lisp dialect called Stalin once, it used aggressive whole-program analysis that made it faster than hand-written C
13:38:46 <Tomsik> but compiling this way is damn slow
13:39:04 <kmc> MLton is a whole-program compiler for SML
13:39:15 <kmc> there are also whole-program compilers for Haskell
13:39:18 <kmc> JHC and some other projects
13:39:37 <kmc> Tomsik, I think the more practical thing is to do that whole-program analysis lazily, at runtime
13:39:41 <MHD> You know what would be swell? If there was some GLUT hack that made glutGetModifiers work outside the keyboard callback
13:39:43 <kmc> by way of a sophisticated tracing JIT
13:39:46 <ski> > let flop = writer . (snd &&& fst) . runWriter in (runWriter . foldr (flop .: (>>) . tell . (:[])) (return [])) [0 .. 7]
13:39:48 <lambdabot>   ([0,2,4,6],[1,3,5,7])
13:40:03 <kmc> you can also make stronger assumptions at runtime, assumptions that don't hold in general (because you bail out of the trace if they fail)
13:40:35 <kmc> and you only spend time optimizing the hot paths
13:40:36 <msieradzki> MHD GLFW-b doesn't have any such things I think
13:40:39 <kmc> good advice for humans as well as computers ;)
13:40:41 <msieradzki> old GLFW maybe
13:40:48 <kmc> GLUT is such a pile
13:40:53 <MHD> msieradzki: I am talking about GLUT
13:40:54 <kmc> even SDL is better
13:41:15 <Nimatek> SFML!
13:41:15 <kmc> drawing in SDL is painful but if all you need is a GL context and a window with input, it's all right
13:41:29 <msieradzki> kmc, GLUT or freeglut? (not that any of them is a proper library ;)
13:41:39 <kmc> don't know the difference
13:42:02 <cheater_> kmc, is ghc not a whole program compiler?
13:42:03 <msieradzki> there's barely any, neither of them allows getting opengl 3.1 context
13:42:11 <kmc> no cheater_
13:42:12 <MHD> Ideally, get me a system that allows multiple windows with their own rendering context
13:42:16 <kmc> it does do some inter-unit optimizations
13:42:36 <kmc> .hi files contain intermediate representations of some functions
13:42:48 <kmc> so a module can inline functions from its imports
13:42:51 <kmc> kind of like gcc's -flto
13:42:58 <kmc> that's far from a whole-program compiler, though
13:43:25 <MHD> It would be awesome if GLFW allowed multiple windows
13:43:32 <kmc> MHD, does SDL?
13:43:46 <MHD> kmc: Not sure
13:43:49 <Tomsik> I'm not sure that whole-program compilers are the way
13:44:01 <MHD> kmc: Pygame2 sure doesn't, and it runs SDL
13:44:14 <Tomsik> It's fun, it gives good results if spent a lot of time to work on, but it's just painful
13:44:24 <kmc> Tomsik, what about doing the same work at runtime
13:45:07 <msieradzki> MHD I digged up something old
13:45:09 <msieradzki> http://www.codeproject.com/KB/openGL/GLFW.aspx
13:45:18 <msieradzki> "Support for multiple windows rendering on up to 10 different windows. "
13:45:54 <olsner> eugh, if they bothered supporting 10, couldn't they just as easily have supported any number of windows?
13:46:37 <kmc> olsner, that would require dynamically allocating memory!
13:46:38 <kmc> that's hard!
13:48:29 <MHD> I would probably actually have to use more than that for my project
13:48:49 <MHD> It's a game
13:49:06 <MHD> that uses the window manager for the HUD
13:49:30 <MHD> so you have windows for character screen, main menu, combat scene, dialogue and so on
13:49:37 <MHD> a lot of windows
13:49:50 <MHD> with haskell glut it is really easy to do that
13:49:52 <Tomsik> kmc: it could make a cool probabilistic runtime
13:50:21 <kmc> i mean fancy tracing JITs are important for getting good performance out of dynamic languages
13:50:27 <kmc> but there's no reason they shouldn't help with heavily static languages
13:50:30 <kmc> or even with raw machine code
13:50:40 <kmc> the result really is a lot like whole-program compilation
13:50:48 <kmc> except selectively, with more information, and stronger assumptions
13:52:31 <msieradzki> MHD I was looking for something similar - I'd like to put my ogl window/context inside main window of gtk/qt/wx
13:53:29 <MHD> msieradzki: I don't really know anything about gtk, qt and wx
13:53:35 <msieradzki> but you have to say 1 thing: GLFW doesn't control whole program flow by making some inaccesible event loop
13:53:44 <msieradzki> MHD in other words some widget library
13:53:45 <iratsu> does parsec work with lazy bytestrings?
13:53:52 <msieradzki> MHD have you seen crysis 2 editor?
13:53:52 <MHD> msieradski: freeGLUT fixes that
13:54:06 <MHD> msieradzki: No?
13:54:18 <bobzhang> hi, anyone know how to add search path in ghci? thanks :)
13:54:40 <MHD> msieradski: And with haskell GLUT, the mainloop actually makes sense...
13:54:48 <kmc> search path for what?
13:55:08 <msieradzki> MHD any game editor?
13:55:14 <kmc> maybe http://mainisusuallyafunction.blogspot.com/2010/09/ghci-and-cabal.html ?
13:55:17 <msieradzki> that has render window and normal UI widgets
13:55:20 <bobzhang> kmc: add search path to load modules in another directory
13:55:27 <MHD> msieradski: I don't edit games. I make them :)
13:55:40 <msieradzki> I haven't asked you if you used one, just seen
13:55:49 <MHD> nope...
13:55:59 <dafis> bobzhang: ghci -ipath
13:56:11 <bobzhang> dafis: on the toplevel
13:56:58 <dafis> bobzhang: within ghci?
13:57:06 <bobzhang> dafis: yeap,
13:57:53 <dafis> bobzhang: :set -ipath
13:57:59 <dafis> (just tried)
13:58:31 <bobzhang> dafis: thanks
14:00:27 <bobzhang> dafis: doesn't work :set -i ../test
14:00:28 <bobzhang> Some flags have not been recognized: ../test
14:00:29 <msieradzki> MHD http://ui05.gamespot.com/452/20071107230546_2.png there's main menu, ui, all this stuff and there's d3d part that belongs to engine and uses same code that game does
14:00:47 <dafis> bobzhang: no space
14:00:50 <msieradzki> GLUT doesn't solve any problems with such integration or I haven't noticed it yet
14:02:16 <MHD> msieradzki: I am sorry if i sound rude now, it is not my intention, why should I find that interesting? I don't play crysis, hardly ever play any games other than indie timewasters. My prime interest right now is discussing OpenGL and stuff.
14:03:59 <gwern> ...                      For the parameterized KDFs the parameters are chosen such that the running time on one core of a 2.5 GHz Intel Core 2 Duo processor^18^ is less than 100 ms (for the lower parameters) or less than 5 s (for the higher parameters) ...[18] This processor is also known as “the CPU in the author’s laptop”.'
14:04:17 <msieradzki> MHD it's not interesting I just meant integration of d3d/ogl window with GUI framework
14:04:37 <msieradzki> it just was 1st thing I had on my mind to show it
14:05:08 <MHD> i don't really know about that i think there is some misunderstanding because I have littel clue as to what you're talking about :)
14:29:00 <MHD> GLFW-b is horribly inelegant
14:31:51 <ivant> For those of  you in San Francisco Bay Area: we have a Haskell user group next week in San Francisco (SoMa) http://goo.gl/kp4Bv
14:32:14 <kmc> hugs for everyone :)
14:33:42 <Axman6> kmc: not ghc? :(
14:33:52 <shachaf> maurer_: See above.
14:34:09 <maurer_> shachaf: Yeah, i got the email
14:35:39 <ivant> is there a way to define a type alias or data/newtype in a where clause, to restrict the visibility?
14:35:55 <kmc> no
14:36:06 <kmc> the best you can do in GHC is module scope
14:36:25 <kmc> Hugs has a cool feature where you can make something be an alias in a certain scope and an opaque type elsewhere
14:36:50 <ivant> bummer
14:38:54 <roconnor> Data.Fixed comes with GHC?
14:39:06 * maurer_ still wants some form of scoped typeclasses, but all my ideas end up unsound or requiring excess syntax
14:39:27 <sipa> explain
14:39:32 <roconnor> wholy crap!
14:40:09 <kmc> maurer_, you can accomplish a similar effect with ImplicitParams
14:40:47 <kmc> and yes, there is a soundness issue
14:41:10 <kmc> what happens if you create two values of type (Map Foo Int) under different Ord Foo instances and then try to union them?
14:41:27 <sipa> roconnor: i know holy and wholly
14:42:22 <roconnor> sipa: I'm going to define a Satoshi to be a precission of 10^8
14:42:27 <ivant> kmc: okay, forget type classes. At least types aliases and algebraic types should be possible without making it unsound
14:42:37 <kmc> yes
14:42:48 <sipa> roconnor: ?
14:42:57 <maurer_> kmc: I'd say that's not one of the real issues.
14:42:58 <MHD> all right, screw it. I'm gonna make my own GLFW binding
14:43:04 <sipa> precision or precessiion? ;)
14:43:11 <MHD> GLFW-b is rediculous
14:43:15 <sipa> precession
14:43:19 <roconnor> precision
14:43:24 <maurer_> kmc: The union function itself would be overridable, and there simply wouldn't be a good choice for what to override it with
14:43:30 <copumpkin> preflex: seen TacticalGrace
14:43:30 <preflex>  TacticalGrace was last seen on #ghc 8 days, 7 hours, 46 minutes and 39 seconds ago, saying: Axman6: no, I don't know whether anybody tried that
14:43:32 <MHD> displayMode_accumNumGreenBits my ass
14:45:42 <copumpkin> any repa experts around?
14:46:12 <copumpkin> I'm wondering if anyone can elaborate on slices in it
14:48:50 <copumpkin> and/or the new stencil stuff
14:50:21 <copumpkin> well, stencil looks like a convolution thing
14:50:26 <copumpkin> but I'm still curious about slices
14:50:36 <copumpkin> I think I get them, but they're not terribly obvious to me
14:53:44 <SirFrancisDrake> when does one need fancy stuff like GADT? Save for hardware modelling
14:53:45 <danharaj> In Haskell, it seems that any monad's `return' needs to be mono on each type. Is that true?
14:54:01 <kmc> what does that mean danharaj?
14:54:26 <kmc> SirFrancisDrake, you don't *need* GADT, Haskell is a complete language without it
14:54:32 <copumpkin> SirFrancisDrake: whenever you have invariants you want to reflect in types
14:54:41 <danharaj> kmc: return .  f = return . g implies f = g.
14:54:51 <danharaj> or if we think about types as sets, then return is injective.
14:54:53 <SirFrancisDrake> kmc: well, i don't *need* Parsec, but it helps sometimes
14:55:23 <SirFrancisDrake> copumpkin: uh, thanks
14:55:41 <kmc> danharaj, can you prov that from monad laws
14:55:54 <danharaj> kmc: no. Argument by lack of imagination :p
14:55:57 <kmc> SirFrancisDrake, an example is if you're writing a compiler for a statically typed language in Haskell
14:56:00 <SirFrancisDrake> copumpkin: but I still can't come up with a real-life example
14:56:05 <nicoo> SirFrancisDrake: another usefull use is when you are building ASTs for other languages
14:56:08 <kmc> SirFrancisDrake, you can model your language's type system in Haskell's type system
14:56:29 <kmc> and thereby the GHC type checker proves that your compiler passes generate well-typed terms and are type-preserving
14:56:41 <nicoo> for exemple, Equal will be a constructor from (a expr)*(a expr) to bool expr
14:56:42 <copumpkin> SirFrancisDrake: you can also use GADTs as a roundabout way to make an effectively closed typeclass
14:56:51 <nicoo> kmc: exactly my point ^^
14:57:04 <copumpkin> class IsAorB x where witness :: IsAorBWitness x
14:57:24 <copumpkin> data IsAorBWitness a where IsA :: IsAorBWitness A; IsB :: IsAorBWitness B
14:57:25 <copumpkin> :P
14:57:39 <Visham> help
14:57:44 <copumpkin> halp!
14:57:50 <danharaj> hilfer
14:58:07 <SirFrancisDrake> kmc, nicoo, copumpkin: thanks
14:58:11 <kmc> SirFrancisDrake, another GADT example is lists with statically typed length
14:58:17 <Visham> sorry, still figuring how to use the chat
14:58:40 <kmc> data SList n t where { Nil :: SList Z t; Cons :: t -> SList n t -> SList (S n) t }
14:58:48 <kmc> data Z; data S n
14:59:12 <Visham> am on #haskell, right? do i need to join a discussion/conversion first or can i just throw my question here?
14:59:18 <kmc> just throw it out
14:59:21 <kmc> IRC is primitive :)
14:59:30 <Visham> :)
14:59:33 <kmc> SirFrancisDrake, generally things done with GADTs can also be done with the "phantom types" technique, but not as nicely
15:00:29 <SirFrancisDrake> I see.
15:01:09 <Visham> could someone tell me what the spine of a list is?
15:01:38 <kmc> Visham, the (:) cells
15:01:56 <danharaj> Visham: Think about a list as a tree where the inner nodes are labelled with data constructors and the leaves are labelled with the elements. The spine is the tree of (:)
15:03:21 <Visham> Ok, when I read seq evaluates the spine of the list, what does that mean?
15:03:29 <kmc> it's a lie, anyway
15:03:39 <kmc> seq only forces the outermost data constructor
15:03:42 <kmc> the *first* (:)
15:03:51 <kmc> > undefined `seq` ()
15:03:52 <lambdabot>   *Exception: Prelude.undefined
15:03:55 <kmc> > (undefined : undefined) `seq` ()
15:03:56 <lambdabot>   ()
15:04:15 <monochrom> seq doesn't evaluate the spine actually
15:04:39 <danharaj> deepSeq does.
15:04:50 <kmc> don't use deepSeq
15:04:51 <Visham> ghci> let a = [1..10]
15:04:53 <kmc> unless you really have to
15:04:53 <Visham> ghci> :print a
15:04:55 <Visham> a = (_t1::[Integer])
15:04:56 <Visham> ghci> a `seq` ()
15:04:58 <Visham> ()
15:04:59 <Visham> ghci> :print a
15:05:01 <Visham> a = 1 : (_t2::[Integer])
15:05:20 <ddarius> It is not the case that return needs to monomorphic.
15:05:21 <Visham> i pasted some tests i'm doing on ghci
15:05:24 <kmc> Visham, cool, that's a good demo
15:05:41 <monochrom> you get one cons cell
15:05:44 <Visham> would like someone to explain though :)
15:05:55 <ddarius> Admittedly, I think there is essentially only one (or so) monad in Haskell where that is not true.
15:05:58 <kmc> seq evaluates its first argument to "weak head-normal form"
15:06:15 <kmc> meaning that the outermost expression is a lambda abstraction or a data constructor
15:06:18 <kmc> (:) is a data constructor
15:06:19 <danharaj> ddarius: Which would that be?
15:06:24 <kmc> seq doesn't care what the args of (:) are
15:06:54 <kmc> > (\x -> undefined) `seq` ()
15:06:55 <lambdabot>   ()
15:06:59 <kmc> > (Just undefined) `seq` ()
15:07:00 <lambdabot>   ()
15:07:18 <ddarius> type Const a = (); instance Monad Const where return _ = (); _ >>= _ = (); in slightly-pseudo-code.
15:07:39 <danharaj> :p
15:09:46 <Visham> Ok, I'm still a bit confused cause there's deepseq and rdeepseq, and they seem to change the name of the functions everytime
15:10:00 <kmc> deepseq recurses into the structure of the value
15:10:07 <kmc> > (undefined : undefined) `deepSeq` ()
15:10:08 <lambdabot>   Not in scope: `deepSeq'
15:10:12 <kmc> it uses a type class to do so
15:10:21 <kmc> while the one-step 'seq' is a primitive
15:10:28 <kmc> you could implement 'seq' yourself for any given data type
15:10:31 <Visham> a `deepseq` () -> works fine
15:10:36 <kmc> but you can't implement it for function types
15:10:42 <kmc> and you can't make it magically polymorphic the way it is
15:10:48 <Visham> if i want to use rdeepseq (which is a strategy?), how do i?
15:10:50 <kmc> (Haskell 1.4 put it in a type class, the way deepSeq is now)
15:12:57 <kmc> Visham, you use strategies using "using"
15:13:12 <kmc> > (undefined : undefined) `using` rseq
15:13:12 <lambdabot>   [*Exception: Prelude.undefined
15:13:43 <kmc> > (undefined : undefined) `using` rdeepseq
15:13:44 <lambdabot>   *Exception: Prelude.undefined
15:14:00 <kmc> (the first one succeeded except that it had to print the list)
15:14:15 <kmc> > ((undefined : undefined) `using` rseq) `seq` ()
15:14:16 <lambdabot>   ()
15:14:18 <kmc> > ((undefined : undefined) `using` rdeepseq) `seq` ()
15:14:19 <lambdabot>   Ambiguous type variable `a' in the constraint:
15:14:19 <lambdabot>    `Control.DeepSeq.NFData a...
15:14:32 <kmc> > ((undefined : (undefined :: [()])) `using` rdeepseq) `seq` ()
15:14:33 <lambdabot>   *Exception: Prelude.undefined
15:16:41 <Visham> seq (rseq) -> evaluates to whnf
15:16:43 <Visham> deepseq (rdeepseq) -> to nf
15:16:45 <Visham> do we have any other evaluation degree we could specify?
15:17:02 <kmc> sure
15:17:17 <kmc> you could force the spine of a list without forcing its contents
15:17:26 <kmc> :t evalList rseq
15:17:27 <lambdabot> forall a. [a] -> Eval [a]
15:17:43 <kmc> > length ([undefined, undefined] `using` evalList rseq)
15:17:44 <lambdabot>   *Exception: Prelude.undefined
15:17:51 <kmc> er, wrong
15:18:00 <kmc> > length ([undefined, undefined] `using` evalList r0)
15:18:00 <lambdabot>   2
15:18:06 <kmc> that's the right one
15:18:57 <kmc> another way to force a list spine is "map id"
15:19:01 <kmc> but that will also break sharing
15:19:35 <kmc> (fix ('x':)) is a small object in memory but (map id (fix ('x':))) will grow as you force it
15:20:19 <ion> fixAgain (map id (fix ('x':)))
15:20:37 <dixie> > permutation :-)"
15:20:38 <kmc> observable sharing? in my pure language?
15:20:38 <lambdabot>   <no location info>: parse error on input `)'
15:21:34 <Visham> (taking to time to absorb :))
15:22:24 <kmc> deepSeq is a pretty blunt instrument
15:22:35 <kmc> people throw it around indiscriminately to try to fix laziness-related performance problems
15:22:51 <danharaj> Shouldn't you almost always use a strict data structure instead?
15:22:53 <kmc> but deepSeq does a full traversal of your data tree
15:23:01 <kmc> danharaj, yes, or simply put seq in the right place
15:23:03 <Visham> ghci> let a = undefined
15:23:05 <Visham> ghci> :print a
15:23:07 <Visham> a = (_t5::forall a. a)
15:23:21 <Visham> why is the type of undefined forall a. a
15:23:26 <kmc> because it's undefined
15:23:28 <kmc> it can be any type
15:23:35 <danharaj> :t error
15:23:36 <kmc> :t undefined :: [(Int, Bool -> Char)]
15:23:36 <lambdabot> forall a. [Char] -> a
15:23:37 <lambdabot> [(Int, Bool -> Char)]
15:23:39 <ion> ghci’s :print seems to be strict.
15:23:50 <kmc> how so ion?
15:23:58 <kmc> _t5 is a thunk
15:24:07 <ion> let xs = fix ('x':)
15:24:14 <ion> head xs
15:24:18 <ion> :print xs
15:24:42 <kmc> i blame showList
15:24:48 <kmc> not sure though
15:25:01 <shachaf> ion: It works without the "head xs".
15:25:14 <kmc> hmm, i see what you mean
15:25:24 <Botje> (i read that as '_t5 is a drunk')
15:25:28 <kmc> ":print" is consuming the whole output of 'show'
15:25:30 <kmc> unlike "print"
15:25:37 <kmc> but it's not forcing its argument
15:25:41 <ion> botje: _t5 *is* a drunk.
15:25:53 <Botje> :)
15:25:54 <kmc> "f is strict" means "f ⊥ = ⊥" and that's not true for ghci's ":print"
15:26:01 <kmc> (disregarding that it's not a function anyway)
15:26:37 <ion> Yeah, i was imprecise.
15:28:52 <monochrom> ghci :print prints out non-thunks. well, after you have seq'ed fix ('x':) once, it's all non-thunks now
15:31:18 <ezyang> Can tail recursion be adequately defined purely syntactically?
15:31:35 <monochrom> yes, I think that's the only definition
15:31:49 <ezyang> OK.
15:32:04 <c_wraith> didn't we have some interesting conclusion about this several months back?
15:32:29 <c_wraith> That thanks to aggressive inlining, the optimizer can treat things that aren't syntactically tail-recursive as though they are?
15:32:44 <ezyang> Yes, that is the case for >>= in IO.
15:33:01 <c_wraith> I think we were looking at (||) specifically, in this case.
15:33:10 <ezyang> oh yes, I could believe it for || too.
15:33:23 <ezyang> any "control" function needs this sort of behavior.
15:37:29 <joeyh_> I need to catch exceptions in a StateT monad.. is there a recommended library for this? Or better, an example?
15:37:53 <joeyh_> looking at Control.Monad.IO.Control and MonadCatchIO-mtl etc..
15:38:15 <kmc> in StateT s IO?
15:38:20 <joeyh_> yes
15:38:29 <kmc> look at monad-peel also
15:38:50 <joeyh_> well, Control.Monad.IO.Control seems to think it's a better version of peel
15:38:52 <kmc> MonadIO and MonadTrans are too weak to use callbacks
15:38:53 <kmc> ok
15:38:55 <kmc> what package?
15:39:28 * shachaf is annoyed at monad transformers.
15:39:47 <kmc> i think the more Haskell i've learned, the less I use monad transformers
15:39:52 <kmc> also type classes in general
15:40:02 <kmc> when you start out the idea of writing your own monad sounds pretty intimidating
15:40:09 <joeyh_> yeah, I can see that
15:40:19 * djahandarie barely uses monad transformers
15:40:20 <kmc> but it can be cleaner than making some pile of semi-relevant transformers
15:40:34 * djahandarie also barely writes things in Haskell so this may be related
15:40:48 <kmc> either with or without transformers, it's nice to wrap your monad in a newtype and only expose certain domain-specific primitives
15:41:13 <kmc> not good to have user code with State / Reader / Cont functions all over
15:41:27 <joeyh_> that would be ideal.. it's an ideal I've not realized myself
15:41:37 <kmc> maybe i should do everything in the ContT r IO monad
15:41:44 <joeyh_> ... I have liftIO all over
15:41:55 <djahandarie> liftIO is the one you can't always avoid
15:41:59 <cmccann> in my experience, the three main scenarios for using monad transformers are simple stacks that are easily written directly, large boring stacks that are probably inefficient, or large complicated stacks that behave strangely and cause bugs
15:42:26 <joeyh_> yeah, the efficiency issues with large stacks is why I can see writing my own, if I needed more than state+IO
15:42:54 <kmc> or you can use monad-ran
15:43:08 <cmccann> I think the main way that I've found them helpful is for writing my own composite transformer, so I can parameterize it over various base monads
15:43:35 <kmc> *nod*
15:43:40 <monochrom> monad-peel supersedes monadcatchio
15:44:01 <kmc> I guess I feel like libraries should export transformers, but client code should wrap and hide their use as much as possible
15:44:02 <cmccann> e.g. if I want the same reader environment type for working in two or more of IO, ST, STM, &c.
15:44:09 <joeyh_> what about MonadCatchIO-transformers?
15:44:10 <monochrom> but if you just want to catch-throw, I guess monadcatchio suffices and easier to learn
15:45:07 <joeyh_> it seems to have a lot of ugly caveats for eg, ContT
15:45:11 <cmccann> my rule of thumb is that more than one transformer class in the type for a function probably indicates problems
15:45:49 <cmccann> well, ContT is a reified ugly caveat in most cases
15:45:52 <cmccann> so that makes some sense
15:47:51 <kmc> ♥ continuations
15:47:57 <monochrom> ContT has its own idea of control-flow and of course conflicts with other control-flows you try to mix in
15:48:00 <kmc> they are the trippiest thing in fp
15:48:38 <monochrom> note that you could use ContT to implement catch-throw
15:48:38 <djahandarie> Continuations are time traveling classical logic devils!
15:48:45 <ddarius> kmc just likes constructive classical logic.
15:48:49 <joeyh_> wait, MonadCatchIO-transformers and Control-Monad-CatchIO look almost identical. now I'm really swamped in choices
15:49:05 <cmccann> in ContT, flow controls you
15:49:39 <monochrom> @remember cmccann in ContT, flow controls you
15:49:39 <lambdabot> Done.
15:49:47 <cmccann> heh
15:49:51 <parcs> joeyh_: monad-control
15:50:15 <joeyh_> yeah, those are the three I have open in my browser trying to find a reason to pick one :)
15:52:52 * djahandarie . o O ( ? cmc.... = kmc ? )
15:53:02 <parcs> monad-control is latest and greatest
15:53:09 <monochrom> anyway I ♥ continuations and ContT and classical logic too
15:53:17 <kmc> I ask this periodically but:
15:53:32 <kmc> can I read "Cont" as a modal operator for "classically provable"
15:53:45 <kmc> or perhaps "classically true"?
15:54:05 <c_wraith> @ty callCC
15:54:06 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
15:54:14 <monochrom> oh, monad-control supersedes monad-peel
15:54:26 <djahandarie> kmc, I think that'd be safe to say in some vague sense
15:54:26 <monochrom> yes
15:54:42 <kmc> do i gain anything particular this way
15:55:13 <cmccann> kmc, if you accept the "CPS = double-negation" correspondence, isn't that a given, due to classical logic working within a constructive system if you replace every "true" value with "not false"?
15:55:22 <cmccann> or am I getting something confused here
15:55:33 <monochrom> I don't know. it is not like you have never seen classical logic elsewhere
15:56:11 <kmc> cmccann, what you said makes sense
15:56:16 <kmc> i'm not sure how to fit it all together
15:56:28 <kmc> i know that some classical proofs can be constructivized by CPS
15:56:49 <kmc> i guess for that you have to "undo" the double negation at the top level somehow
15:57:21 <cmccann> kmc, I'm not certain how well that holds either, both in whether classical logic can be imitated that way in all cases and whether the analogy between CPS and double negation holds up well enough
15:57:22 <kmc> also #haskell is the 8th biggest channel on FreeNode :x
15:57:30 <kmc> and second biggest language channel
15:57:37 <shachaf> After what?
15:57:41 <kmc> #python
15:57:48 <kmc> whose topic is "NO LOL... NO PROJECT EULER"
15:57:50 <cmccann> with C++ a close third, I think
15:57:53 <joeyh_> parcs: any good examples of using monad-control for a simple catch?
15:57:57 <shachaf> Pft. So the first biggest *real* language channel.
15:58:12 <monochrom> prove x classically = prove ¬¬x intuitionistically
15:58:18 <kmc> C++ is much smaller
15:58:50 <kmc> the next "programming language" is perl
15:59:02 <cmccann> ah, ok
15:59:11 <kmc> arbitrarily excluding vim, bash, and mysql
15:59:12 * cmccann doesn't really go anywhere else but here :P
15:59:31 <monochrom> I applaud both no-lol and no-PE
16:00:08 * monochrom is really tired of "hi how do I be yet another re-inventor of the dumbest trial-division loop ever?"
16:00:20 <kmc> i'm not so much tired of that
16:00:34 <kmc> i'm tired of "hi #haskell, should I learn Haskell? also why is it good?"
16:00:47 <kmc> providing zero information about one's goals in learning a language
16:00:53 <monochrom> yes, I'm equally tired of that too
16:00:54 <kmc> providing zero context for "good"
16:01:17 <djahandarie> Wouldn't the proper thing be to just probe back for more info, and maybe also provide a link to the wiki page?
16:01:19 <kmc> "should i learn Haskell to get rich" and "should I learn Haskell to impress my friends" are better questions
16:01:20 <monochrom> but also equally tired of those who bother to answer
16:01:37 <cmccann> @faq will haskell be a good language to learn?
16:01:37 <lambdabot> The answer is: Yes! Haskell can do that.
16:01:40 <cmccann> problem solved
16:01:43 <monochrom> should just say "it's up to you" and "go with your heart" and be done with it
16:01:54 <monochrom> don't answer to answer. just don't answer
16:02:21 <parcs> joeyh_: Control.Exception.Control.catch should work out of the box
16:02:45 <monochrom> answer-to-answer is worse than ask-to-ask, because answer-to-answer gives incentive for ask-to-ask
16:03:35 * cmccann really thinks we should just let lambdabot field content-free questions like that
16:03:56 <joeyh_> parcs: absolutely, but you said it wasn't latest&greatest :)
16:04:41 <joeyh_> oh wait, I mixed up all this stuff.. ok
16:05:05 <joeyh_> thanks, got it now.. also, this email is a good way to understand it http://www.mail-archive.com/haskell@haskell.org/msg23278.html
16:05:25 <kmc> ...I was talking about monad-peel just now, without realizing that I'm literally sitting next to its author
16:05:34 <monochrom> haha
16:10:46 <prbh> @faq test
16:10:46 <lambdabot> The answer is: Yes! Haskell can do that.
16:10:58 <RichardBarrell> Are there any Happstack people around? http://tutorial.happstack.com/ is down and you probably want to know if you don't already.
16:11:27 <prbh> @faq evaluate
16:11:27 <lambdabot> The answer is: Yes! Haskell can do that.
16:11:33 <shachaf> Are there any Happstack people?
16:12:15 <kmc> @faq Are there any Happstack people?
16:12:15 <lambdabot> The answer is: Yes! Haskell can do that.
16:12:21 <kmc> @. faq nixon
16:12:21 <lambdabot> The answer is: Yes! Haskell can do that.
16:12:27 <kmc> @. elite . faq nixon
16:12:27 <lambdabot> +he 4n$WEr is: Y3s! H45xE|l (AN DO +H4T.
16:12:55 <prbh> how to ask lambdabot a question and how accurate is it?
16:13:03 <kmc> @vixen how accurate are you?
16:13:04 <lambdabot> i truely am
16:13:18 <kmc> @. vixen nixon
16:13:19 <lambdabot> :)
16:13:20 <kmc> @. vixen nixon
16:13:21 <lambdabot> who is the he we are talking about?
16:13:52 <shachaf> @vixen vixen vixen
16:13:52 <lambdabot> we all have a little vixen in us
16:13:58 <prbh> @vixen what is forall
16:13:58 <lambdabot> let's don't talk about that
16:14:02 <djahandarie> Haha shachaf
16:14:38 <prbh> @vixen strictness
16:14:38 <lambdabot> so?
16:14:57 <kmc> @protontorpedo
16:14:57 <lambdabot> I dont know any programming yet at 33 dream of learning ti and gettign rich
16:14:59 <djahandarie> @. vixen . vixen vixen
16:14:59 <lambdabot> oh, you're such a smart gambler!
16:15:01 <kmc> @yhjulwwiefzojcbxybbruweejw
16:15:01 <lambdabot> Just 'J'
16:15:26 <prbh> @help
16:15:27 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:15:43 <prbh> @haskell
16:15:43 <lambdabot> Unknown command, try @list
16:15:52 <prbh> @vixen haskell
16:15:52 <lambdabot> church is my favourite computer scientist.
16:16:06 <prbh> @vixen java
16:16:06 <lambdabot> So, tell me your biggest and darkest secret. Something that no one knows of you.
16:16:23 <prbh> @vixen why
16:16:23 <lambdabot> why anything?
16:16:35 <prbh> @vixen why anything?
16:16:35 <lambdabot> why not?
16:16:42 <prbh> @vixen why not?
16:16:42 <lambdabot> good question, why not indeed?
16:16:54 <prbh> @vixen don't know?
16:16:54 <lambdabot> well find out then
16:17:04 <prbh> @vixen why?
16:17:04 <lambdabot> why not?
16:17:14 <prbh> tired now
16:30:02 <ski> monochrom : "prove x classically ..." -- for propositional logic, yes. not for predicate logic, iirc
16:31:09 <ski> (the problem being that one needs `(forall x. NotNot (P x)) -> NotNot (forall x. P x)' as well)
16:33:13 <kmc> (∀x. ((P x → r) → r)) → ((∀x. P x) → r) → r
16:33:22 * kmc goes crazy counting ∀'s left of →'s
16:34:47 <ski> ok, apparently in the case of propositional logic, it's known as "Glivenko's theorem for propositional logic"
16:37:21 <ski> while apparently `CQC |- B  <=>  IQC + DNS |- NotNot B', `CQC' being classical predicate logic, `IQC' being intuitionistic predicate logic, and `DNS' (double-negation shift) being the above extra axiom, was proved by Glivenko 1929 and Gödel 1933
16:39:30 <droidboi> Is Haskell to pure to be useful?
16:39:35 <droidboi> too
16:39:39 <monochrom> no
16:39:47 <c_wraith> nope.  It's almost pure enough to be really useful.
16:39:57 <monochrom> haskell is too impure to be theoretical
16:40:02 <cmccann> yes, a bit more purity would be nice
16:40:39 <droidboi> why do people find monads hard do understand?
16:40:58 <c_wraith> because they think they must be hard to understand
16:41:01 <cmccann> they don't
16:41:04 <c_wraith> It's kind of circular.
16:41:09 <cmccann> the only people who say that are the ones who haven't actually tried
16:41:20 <dobblego> because they are scared of the dark
16:41:26 <cmccann> they just hear that they're difficult, and don't understand them immediately, and stop there
16:41:33 <monochrom> why do you care what other people think
16:41:52 <droidboi> why hasnt someone made monads simple
16:42:07 <monochrom> it's already simple
16:42:09 <dobblego> they have, they also made the dark simple (the sun disappears duh)
16:42:15 <monochrom> and please stop asking loaded questions
16:42:23 <cmccann> yes, monads are very simple
16:42:30 <cafesofie> where are simple monads? i'd like that
16:42:44 <shachaf> data Null a = Null
16:42:54 <shachaf> That one's simple.
16:42:57 <cafesofie> funny
16:43:06 <dobblego> but more importantly, simple
16:43:30 <cafesofie> nothing is more important than humor
16:43:51 <droidboi> "monads" :) wtf are monads
16:44:20 <cmccann> monoids objects in an endofunctor category, of course. what's the problem?
16:44:24 <droidboi> who is stupid enough to introduce monads
16:44:29 <cmccann> sigh
16:44:37 <monochrom> read some haskell tutorial books to find out. for example learnyouahaskell.com
16:45:20 <droidboi> nobody like haskell because of monads
16:45:31 --- mode: ChanServ set +o monochrom
16:45:36 <cmccann> droidboi, that statement is provably false
16:45:39 <dobblego> droidboi: you mean ill-informed people don't understand haskell nor monads -- whats news?
16:45:41 <cmccann> really, you're not even trying
16:46:00 --- mode: monochrom set +q *!*@212.183.140.30
16:46:22 <cmccann> trolls these days just aren't like they used to be
16:46:22 <dylukes> ill-informed people are prone to forming ill-formed expressions, with ill consequences!
16:46:26 <cmccann> no respect for the art
16:46:31 <cmccann> no effort, no quality
16:46:33 <cmccann> it's a disgrace
16:46:45 <joeyh_> huh, cabal sdist fails if the package has a file >= 100 chars.
16:46:52 <dylukes> I mean, there are even some classics cmccann, such as going into a room and insisting the monty hall problem is 50/50.
16:47:03 <joeyh_> I'm gonna guess this is due to tar's issues with long filenames, although all moderns tars work around that
16:47:07 <dylukes> If you insist long enough, someone will rage and try to prove it… of course it doesn't matter, you just say its wrong
16:47:11 <Tomsik> cmccann: you mean /an/ disgrace
16:47:56 <benmachine> @protontorpedo
16:47:56 <lambdabot> so haskell is different from lisp?
16:47:59 <benmachine> @protontorpedo
16:48:00 <lambdabot> is functional ebtter than oo?
16:48:02 <benmachine> @protontorpedo
16:48:02 <lambdabot> or does it become a mishmash of code?
16:48:13 <benmachine> hmm
16:48:19 <benmachine> @commands
16:48:19 <lambdabot> Unknown command, try @list
16:48:24 <benmachine> @list
16:48:24 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
16:48:38 <benmachine> @keal
16:48:38 <lambdabot> will it return [] if map gives fpu infinite list?
16:48:51 <benmachine> @girl19
16:48:52 <lambdabot> I have been into not actually hacking, but social engineering
16:49:20 <thoughtpolice> @protontorpedo
16:49:20 <lambdabot> so is haskell going to redo x windows and make it better?
16:49:31 <thoughtpolice> @. elite protontorpedo
16:49:32 <lambdabot> 5yn7Ax ur RUNiN9 /\/\Y |-|I9|-|
16:49:40 <thoughtpolice> i don't know why i love 'elite' so much considering how stupid it is.
16:49:48 <benmachine> :)
16:49:50 <thoughtpolice> a brain deficiency or something i suppose.
16:49:51 <thoughtpolice> :P
16:50:05 * hackagebot git-annex 3.20110707 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20110707 (JoeyHess)
16:50:54 * ski can't recall seeing any B1FF-speak in old demos and intros ..
16:51:30 <lispy> What do you guys think of having a contest to see who can implement the best security model on top of existing hackage (the security model would be there to address the current issue of anyone uploading over top of existing packages they don't "own")
16:51:42 <holmak> @. elite nixon
16:51:42 <lambdabot> +h3y'r3 nOT Like uz. 7h3y Sme|1 dIphFER3N7, TH3y |O0x diphfERent, 7h3Y 4c7 DiffEren7. t|-|e TROu81E I$, joo c4n'+ fINd oN3 THat'$ HOnEst.
16:52:10 <monochrom> cool but hard to set good rules for the contest i.e. who wins
16:52:33 <mm_freak> joeyh_: if you use darcs, use 'darcs dist' instead of 'cabal sdist'
16:52:35 <holmak> the person whose submission isn't uploaded over wins
16:52:42 <lispy> holmak: heh
16:52:57 <joeyh_> mm_freak: I don't, sadly.. sdist has given me all kinds of trouble, since I have hundreds of extra files
16:52:57 <mm_freak> i believe other VCSes also provide some distribution function
16:53:22 <thoughtpolice> lispy: hackage 2 apparently solves this. according to dcoutts, it is 90% of the way finished. the remaining 90% is all that remains
16:53:27 <lispy> monochrom: joeyh_ you can use wildcards in the .cabal file for extra files
16:53:31 <joeyh_> well yeah, I can easily make a tarball myself.. but I asked on here and it was suggested some things might rely on cabal sdist actually working
16:53:48 <lispy> thoughtpolice: I'll send him an email to find out more about that
16:53:57 <joeyh_> lispy: cabal's wildcard support is intentionally crippled, so I'd need at least many dozen wildcards, often changing
16:54:12 <thoughtpolice> at least, i believe there is actually a notion of users owning a package and not letting others overwrite it
16:54:25 <lispy> joeyh_: yes, the wildcard support is weird.
16:54:45 <thoughtpolice> hackage 2 is actually pretty functional from the demo that was on sparky for a while... i guess it's not as much fun to hack on a web UI for a package db as much as other things
16:54:45 <cmccann> thoughtpolice, data Project a = Project { first90Percent :: a, other90Percent :: Project a }
16:56:03 <gfarfl> cmccann: 180% ?
16:56:33 <cmccann> gfarfl, just a correct way of describing project completion
16:56:53 <ski> (surely it should be a continued fraction ?)
16:57:06 <thoughtpolice> > fix ("only 90% left...":)
16:57:07 <lambdabot>   ["only 90% left...","only 90% left...","only 90% left...","only 90% left......
16:57:11 <cmccann> ski, no, that's the joke :P
16:59:17 <MHD> Isn't the full phrase "The first 90% of a project takes 90% of the time, the last 10% takes 90% of the time."
17:01:03 <dbpatterson> are there any mirrors of GHC? I'm getting 10-15Kb/s download right now...
17:01:38 <thoughtpolice> MHD: now everyone feels silly :P
17:01:56 <lispy> dbpatterson: github, IIRC
17:01:58 <thoughtpolice> dbpatterson: a GHC binary? i tested this not long ago and i was getting good speeds, although ghc could probably use some mirrors
17:02:04 <MHD> thoughtpolice: I am just a language nerd, don't mind me
17:02:09 <thoughtpolice> for git repos, yeah, github is responsive enough
17:02:27 <lispy> dbpatterson: https://github.com/ghc/ghc
17:02:57 <lispy> dbpatterson: if you want to install haskell, then you probably want the haskell platform instead
17:03:05 <dbpatterson> no, trying to get a binary. maybe it's on my connection, but I was getting other stuff at 100-200Kb/s
17:03:11 <lispy> dbpatterson: which should have a fast download speed
17:03:32 <dbpatterson> lispy: going to install platform, but I need GHC first (my distro is on an ollld version of the platform)
17:03:47 <thoughtpolice> dbpatterson: yeah people have reported this. in all my tests on a fast network @ work i got a full GHC binary (~112mb) in something like 5 minutes, no problem
17:04:08 <thoughtpolice> this was maybe a week or two ago. i could actually test this again if i booted up my other machine
17:04:30 <hpaste> MHD pasted “Threading stuff.” at http://hpaste.org/48827
17:04:38 <lispy> dbpatterson: from here then? http://haskell.org/ghc/download_ghc_7_0_4#binaries
17:04:39 <dbpatterson> hmm. maybe it is my connection. just tried from a server of mine and it was fast
17:04:41 <thoughtpolice> since this issue keeps being brought up though, maybe it would be good to have some mirrors about...
17:04:50 <MHD> Does that code do what I presume?
17:05:05 <dbpatterson> lispy: yeah, that's where I was looking. except 7.0.3, to match current platform
17:05:15 <MHD> Whoops spelling mistake
17:05:37 <shachaf> MHD: Why both "yield" and "sleep"?
17:05:43 <thoughtpolice> MHD: yes, it'll fork a thread that just loops and sleeps for a period of time
17:05:53 <shachaf> Assuming that sleep is threadDelay.
17:05:53 <thoughtpolice> MHD: ghc's threads are also pre-emptive, so you do not need to explicitly 'yield'
17:06:10 <lispy> dbpatterson: Ah.  7.0.4 fixes a bug with 7.0.3 and I bet it will work (although untested)
17:06:16 <shachaf> Even if they weren't pre-emptive sleep should yield. :-)
17:06:20 <MHD> shachaf: Yeah, I typed it pretty fast
17:06:34 <MHD> thoughtpolice: All right, but is the yield in the right place?
17:06:36 <lispy> dbpatterson: having said that, I'm still on 7.0.3 on my work computer.  No complaints so far :)
17:06:42 <shachaf> MHD: You can also use forever.
17:06:56 <MHD> shachaf: oh, right!
17:07:05 <shachaf> MHD: "the right place"? That depends on what you want it to do. :-)
17:07:16 <shachaf> Since it's doing nothing useful where it is, probably not.
17:07:27 <MHD> shachaf: The simplest thing imaginable, make a looping thread with delay...
17:07:43 <thoughtpolice> strictly speaking, i'm pretty sure 'yield' is a no-op as far as GHC is concerned.
17:07:58 <shachaf> forkIO (forever (act >> threadDelay N))
17:08:01 <MHD> thoughtpolice: Yeah, but what if you are not using GHC?
17:08:03 <thoughtpolice> but in this case even if you weren't dealing with GHC, shachaf is right, the sleep would need to yield
17:08:39 <MHD> thoughtpolice: I am using GLFW sleep... Should I use GLFW threads?
17:09:03 <thoughtpolice> well, realistically the sleep would yield to another thread. in this case the yield isn't really doing anything
17:09:42 <thoughtpolice> MHD: i'm having a hard time understanding - do you have a specific problem? i only ask since you bring up GLFW, it may be easier to answer your question if it's more specific
17:09:54 <MHD> thoughtpolice: Nah, just making sure
17:10:33 <thoughtpolice> i don't know the details of GLFW's sleep, but presumably you would want a sleep routine to yield to other threads i would think. :) in the case of GHC, everything is pre-emptive though, so you're fine
17:11:30 <sshc> Is anybody here aware of a library that implements floating-point numbers (at least as precise and Doubles) whose behaviour is deterministic across all platforms in any environment?  (The implementation might use Integers)?
17:12:13 <c_wraith> does it need to be floating-point?  is Rational not going to work?
17:13:10 <dpratt71> there's something I just don't get about formal logic systems...well, ok, there's a lot I don't get, but...there seems to be a lot of simply restating something in a slightly different form, (apparently) adding nothing; maybe that's the point, but I don't get it
17:13:14 <sshc> c_wraith: I'm considering Rational.  Knowing the status of implementation of deterministic floating point numbers is also important
17:14:49 <dpratt71> like: if assuming A means B then if we had an A, we could get a B (is that even right?)
17:15:31 <dpratt71> how is the second part not just restating the first part?
17:16:08 <cmccann> dpratt71, in the end everything boils down to true statements being true
17:16:56 <cmccann> everything is either a tautology, a falsehood, or something you haven't figured out
17:17:00 <kmc> dpratt71, are you asking about the difference between «A ⊢ B» and «⊢ A → B» ?
17:17:05 <kmc> cmccann, that's awfully classical of you ;)
17:17:13 <dpratt71> kmc: I guess I am, yes
17:17:35 <kmc> see also http://en.wikipedia.org/wiki/What_the_Tortoise_Said_to_Achilles
17:17:37 <dpratt71> cmccann: I believe you, but I don't yet see the use
17:18:05 --- mode: monochrom set -q *!*@212.183.140.30
17:18:08 --- mode: monochrom set -o monochrom
17:18:12 <kmc> dpratt71, we're playing a game with symbols.  → is one of those symbols; it has no "meaning"
17:18:23 <kmc> ⊢ is not one of the symbols of the game
17:18:30 <kmc> it's something whose meaning we've already agreed on
17:18:37 <kmc> it's more like an English word
17:18:44 <cmccann> kmc, how's that classical? I very pointedly didn't exclude any middles :P
17:19:01 <kmc> so if i say:   A ⊢ B  ⇒  ⊢ A → B
17:19:08 <kmc> i'm writing down one of the rules of the game
17:19:20 <kmc> using the informal, pre-arranged vocabulary of ⊢ and ⇒
17:19:27 <kmc> to define the formal symbol →
17:19:45 <kmc> or not even "define" -- just to state what one of the legal moves i
17:19:46 <kmc> s
17:20:02 <dpratt71> kmc: I see; kinda
17:20:23 <kmc> (you'd usually typeset that with a horizontal line between «A ⊢ B» and «⊢ A → B»)
17:20:28 <kmc> (on separate lines)
17:21:01 <dpratt71> kmc: yeah, that's what I'm looking at
17:21:15 <kmc> A, B, ... ⊢ P  means "If you can build terms A, B, ... then you can also build P"
17:21:28 <kmc> a rule about manipulating strings of meaningless symbols
17:21:32 <smop> ah got my word count working
17:21:52 <kmc> er
17:22:00 <kmc> sort of
17:22:05 <monochrom> to be safe, you shouldn't attach any "meaning" to ⊢ either, apart from what the rules promise
17:22:33 * monochrom is formal all the way up, i.e., meta, metameta, ...
17:22:51 <kmc> so modus ponens says that, if term B can be built from term A, then you're allowed to build term A → B
17:23:31 <dpratt71> kmc: ok, I guess I can accept that
17:23:40 <cmccann> the value of the symbol juggling game is that, because of how the rules work, if you assign certain (abitrary) meaning to one symbol, you know that manipulating it according to the rules will preserve the meaning in some way
17:23:45 <dafis> I thought MP was: A -> B, A |- B
17:23:52 <kmc> maybe i've got it backwards
17:24:04 <kmc> dpratt71, another way to look at this is that we're describing a set of pairs; each pair has type (Set Term, Term)
17:24:12 <kmc> and (A ⊢ B) is just a fancy way to write (A, B)
17:24:27 <Itkovian> is there any way to tell cabal to take all the installed packages for, say 612, and build them for 703?
17:24:37 <dpratt71> kmc: ok
17:24:38 <kmc> and then each rule of derivation (each horizontal line) says "if pairs matching the stuff above are in our set of pairs, then the pair below is"
17:24:42 <dafis> Itkovian: cabal install world
17:24:46 <Itkovian> as in ...
17:24:46 <Itkovian> ]
17:24:48 <Itkovian> ok thx
17:24:52 <dcoutts> --dry-run !
17:25:09 <kmc> and then the formal system is defined as a minimal set satisfying all those rules
17:25:13 <dafis> Itkovian: listen to dcoutts
17:25:20 <Itkovian> i am listening
17:25:22 <Itkovian> thx
17:25:31 <Itkovian> need to update cabal first anyhow
17:25:32 <dpratt71> kmc: thanks for trying to clarify this for me
17:25:35 <kmc> and the stuff provable in the system are P if ({}, P) is in the set
17:25:39 <dcoutts> Itkovian: with lots of packages in your world file it may or may not work
17:25:50 <Itkovian> ok
17:25:53 <dpratt71> kmc: wait, what?
17:25:58 <Itkovian> there aren't that many
17:25:59 <dcoutts> Itkovian: oh if you're using an old cabal-install and you have no world file at all then it will not help you
17:26:11 <kmc> bad wording
17:26:13 <Itkovian> aha
17:26:16 <sshc> ua, altfloat seems quite decent.
17:26:22 <Itkovian> let's find out
17:26:23 <kmc> the provable statements are the terms P such that ({}, P) is in that set of pairs
17:26:35 <kmc> that is, «⊢ P»
17:26:52 <Itkovian> dang
17:27:11 <MHD> Holy damn, Concurrency is a dream in haskell
17:27:16 <kmc> yes :)
17:27:37 <kmc> you can build really powerful concurrency tools in a few lines of code
17:27:54 <cmccann> MHD, heh, what prompted that remark?
17:27:55 <kmc> i especially like closing over concurrency primitives
17:28:15 <dpratt71> kmc: ok, I'm gonna read back through all that and see if I can grok it, thanks much
17:28:26 <MHD> cmccann: Just messing around with implementing my own GLFW binding
17:28:57 <MHD> cmccann: Doing the timing parts I went away from using the concurrency parts of GLFW and used the haskell ones instead
17:29:29 <cmccann> MHD, yeah, I can imagine that would be nicer
17:29:47 <cmccann> which Haskell concurrency thingies are you using?
17:29:48 <MHD> so much
17:30:07 <MHD> cmccann: Just looking at them. Chan is pretty much the greatest thing ever
17:30:25 <cmccann> isn't that sorta deprecated in favor of TChan these days?
17:30:33 <MHD> cmccann: The only concurrency I have dealt with before are Python's nightmare
17:30:51 <monochrom> sometimes Chan may be faster than TChan
17:31:02 <MHD> where is this TChan you speak of?
17:31:11 <c_wraith> TChan is part of STM
17:31:21 <Nisstyre> MHD: python mostly uses threads doesn't it?
17:31:26 <cmccann> MHD, http://hackage.haskell.org/package/stm
17:31:32 <shachaf> kmc: "closing over concurrency primitives"? As in Spawn?
17:31:37 <monochrom> stm comes with the haskell platform
17:31:40 <cmccann> STM = software transactional memory
17:31:40 <c_wraith> I still have issues with using a TChan like it was a Chan.  The performance characteristics are entirely different
17:31:57 <cmccann> fair enough about Chan vs. TChan
17:32:11 * cmccann is hardly an expert
17:32:33 <MHD> Nisstyre: Yes, modelled after Java. It is insane.
17:32:41 <cmccann> I just like the basic idea of STM in terms of sticking things together and not having to worry as much about nonlocal interactions
17:32:52 <kmc> shachaf, or many other libraries, yes
17:32:58 <Nisstyre> MHD: I use python a lot but I never write anything that is concurrent
17:33:12 <MHD> Nisstyre: multicore processors make the threads slower!
17:33:12 <Nisstyre> I think python is getting continuations and coroutines though
17:33:12 <kmc> yes, the killer feature of STM is that it's composable
17:33:14 <monochrom> orElse is the best thing since sliced bread
17:34:00 <cmccann> I've mostly used concurrency stuff in code where it was conceptually cleaner, with no significant performance requirements
17:34:33 <kmc> the CPython interpreter is a disaster for parallel concurrency
17:34:43 <Nisstyre> stackless python seems nice
17:34:52 <kmc> the only tractable way to do it is the 'multiprocessing' library, which uses fork() and shared memory
17:34:56 <kmc> and has tons of caveats
17:35:03 <kmc> other implementations do better
17:35:11 <kmc> i'm not sure to what extent they're considered "standard Python"
17:35:19 <thoughtpolice> i hope pypy wins in the end :D
17:35:25 <kmc> the language comes from a tradition where standards are not very important
17:35:29 <kmc> but it's better than Perl at least
17:35:36 <MHD> stackless python should be the greatest thing for oython concurrency since 2.0
17:35:49 <Nisstyre> kmc: it comes from a Dutch guy who doesn't like having more than one way of doing things
17:35:52 <kmc> i hope berp wins
17:35:56 <cmccann> MHD, anyway, you might enjoy looking at STM as well, but anything in Haskell is probably going to be a major improvement over the alternatives you have, so heh
17:35:59 <MHD> I personally like ruby better, but I have never gotten around to learning it
17:36:02 <kmc> 'cause GHC already has a cool concurrent RTS
17:36:32 <cmccann> kmc, hahahahaha, is berp an active project? I assumed it was an elaborate joke to be honest
17:36:37 <kmc> no idea
17:36:41 <kmc> it's on Hackage though
17:36:50 <MHD> cmccann: I know, I'm new to haskell concurrency, not haskell as a whole. God, I feel like doing an old spice commecial spoof.
17:36:55 <thoughtpolice> yeah, pypy seems to be the future in my opinion. those guys are doing some rockin work IMO
17:37:02 <MHD> Look at you language!
17:37:09 <MHD> Now back at haskell
17:37:11 <cmccann> haha
17:37:17 <MHD> etc.
17:37:25 <thoughtpolice> and it's already quite close to drop in compatibility with pure python, but C extensions are a little more troublesome :/
17:37:33 <MHD> Sadly, you language isn't haskell.
17:37:35 <Boney> Hello haskellers.
17:37:40 <kmc> hello Boney
17:37:43 <cmccann> MHD, I avoided doing anything with concurrency for a while because, well, ugh. but it's actually remarkably painless in many cases
17:37:47 <Boney> How can I include 'mu' the greek letter in a haskell string?
17:37:53 <kmc> > "μ"
17:37:53 <lambdabot>   "\956"
17:37:54 <thoughtpolice> there seems to be a theme about extensions and shit fucking up future prospects for language implementations. who would have thought depending on internal details of your specific implementation was a bad idea
17:38:06 <kmc> Boney, Haskell source code is UTF-8 encoded.  you can just write it as-is
17:38:10 <kmc> or use an escape like so
17:38:13 <kmc> > text "\956"
17:38:14 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
17:38:18 <kmc> wha?
17:38:26 <Boney> kmc: okay, I'll see what I can do with that.
17:38:30 <monochrom> yes it's half-broken half-working
17:38:30 <mauke> > "µ"
17:38:31 <lambdabot>   "\181"
17:38:40 <monochrom> and yes there are two mu's
17:38:46 <kmc> only two?
17:38:55 <monochrom> only two, thank God
17:39:02 <kmc> where's my full-width circled non-breaking mu with grass radical #5?
17:39:12 <monochrom> oh oops, forgot those :)
17:39:15 <Boney> ugh, I want the mu that means milli
17:39:38 <mauke> Boney: no such thing
17:39:48 <dafis> micro
17:39:54 <mauke> that would be "\181"
17:39:54 <Boney> ah, micro.
17:40:34 <Boney> milli sounds like million, but it's 1/1000
17:40:41 <Boney> not 1/1,000,000
17:40:47 <Boney> STUPID
17:40:57 <MHD> waitasec
17:41:09 <MHD> threadDelay takes MICRO seconds?
17:41:12 <mauke> Boney: why aren't you complaining that a million isn't 1000?
17:41:16 <monochrom> yes
17:41:27 <Boney> mauke: :-)
17:41:28 <monochrom> haha mauke wins
17:41:48 <monochrom> threadDelay 1000000 gives you 1 second only
17:42:11 <MHD> good thing I caught that one
17:42:31 <cmccann> "milli" means thousand, so given "million" we can conclude that "on" also means thousand, giving 1000 * 1000
17:42:33 <cmccann> LOGIC
17:43:03 <Axman6> and bi means two, so billion = 2 * 1000 = 2000!
17:43:10 <cmccann> Axman6, yes exactly
17:43:19 <Igloo> I put it to you that "on" means "squared"!
17:43:20 <cmccann> logic demands it
17:43:57 <cmccann> Igloo, ooh, that's persuasive, I like it
17:44:03 <Axman6> so billion = 2^2 = 4?
17:44:09 <Axman6> it's getting smaller all the time!
17:44:11 <cmccann> Axman6, must be
17:44:14 <Igloo> And hence billion means 1000 squared twice. The Great British billion, 1e12.
17:44:31 <dafis> Igloo: not since 1973
17:44:49 <Igloo> dafis: Oh, don't give me your newfangled billions
17:44:50 <cmccann> Igloo, that sounds awfully like making sense, I don't think I can agree there
17:45:08 <cmccann> this stuff is supposed to be completely ridiculous and inconsistent
17:45:10 <cmccann> it's how things work
17:45:44 <Axman6> does anyone actually still use the old UK meaning of billion?
17:45:47 <MHD> The long scale which we use in Denmark is considerably nicer
17:45:59 <MHD> Where billion = 1e12
17:46:03 <mauke> Axman6: yes, non-english countries
17:46:07 <dafis> Axman6: pretty much the whole world except USA and UK
17:46:12 <MHD> and "Miliard" = 1e9
17:46:18 <Axman6> and Australia apparently
17:46:31 <dafis> Axman6: part of UK
17:46:32 <MHD> and most importantly, Centilion = 1e600
17:46:37 <Axman6> heh
17:46:56 * cmccann prefers to just use SI prefixes on everything
17:47:10 <shachaf> Millibyte.
17:47:14 <MHD> and, by the way, Common Lisp's number namer goes no higher than a vigintillion
17:47:29 <MHD> which in the short scale is... something
17:47:37 <MHD> and in the long scale is 1e120
17:47:58 <shachaf> It doesn't handle "vigintillion and one"?
17:48:24 <MHD> shachaf, of course it does, but 1e121 and it goes bananas
17:48:30 <Axman6> nano technology means we'll soo be able to use nanobytes of data
17:48:35 <Axman6> soon*
17:48:35 <MHD> or sorry, 1e126
17:48:53 <mauke> here's a C program to format numbers in german: http://mauke.dyndns.org/stuff/c/ausschreib.c
17:48:53 <MHD> Axman6: That sounds... useless?
17:48:54 * dafis waits for attobytes
17:49:05 <Axman6> =)
17:49:08 <mauke> goes up to quinquagintilliards
17:49:42 <dafis> mauke: you should have given that to Waigel
17:50:44 <MHD> If you use the long scale and have a latin numbernamer ready you can go seriously nuts
17:50:47 <mauke> argh, annnnd I found a bug
17:50:54 <Boney> George Bush was told that 300 US suldiers and one Brazilian soldier where killed in action.
17:51:35 <MHD> Boney: What's the punchline?
17:51:46 <Boney> He put his hed in his hands and cries,  eventually he asked,  "Can someone tell me exactly how many one brazilian is?"
17:51:57 <mauke> *brazillion
17:52:05 <monochrom> heh
17:52:05 <Boney> yeah,
17:52:18 <MHD> oh man i saw that coming the moment I asked for it
17:52:19 <Axman6> Boney: you're australian right?
17:52:29 <Boney> Axman6: yeah.
17:52:39 <Boney> Right now I'm in the USA.
17:52:39 <Axman6> why aren't you at AusHac D:
17:52:45 <Boney> hand having a lot of lag.
17:52:46 <Axman6> ah, good excuse
17:53:04 <Boney> I'm at ICLP
17:56:08 <kmc> pufferüberlauf
17:56:35 <mauke> source updated; bug hopefully fixed
17:56:43 <mauke> (duff's device)++
17:56:47 <kmc> Segmentierungsfehler
17:57:08 <MHD> Where do you guys come from?
17:57:12 <mauke> Kein Weltraum links auf Gerät
17:57:18 <MHD> just an off topic question
17:57:24 <Ulfalizer> du bist eine kartoffel
17:57:33 <kmc> employees must wash hands before returning to libc
17:58:17 <MHD> What eventmodel should I use for my GLFW implementation?
17:58:35 <MHD> Queue based or callbacks?
17:59:03 <dafis> MHD: queue based callbacks!
17:59:33 <MHD> dafis: GLFW natively implements callbacks, maybe have a queue system as default?
17:59:35 <kmc> blocking threads with an implicit transparent async IO scheduler
18:00:09 <dafis> MHD: I have no idea what would be better
18:00:31 <MHD> dafis: The native callback stuff would be faster...
18:01:11 <dafis> MHD: so, what would be a reason not to use it?
18:01:40 <MHD> dafis: elegance?
18:02:06 <dafis> MHD: it's a library, it needn't be pretty, it's gotta be fast
18:02:18 <MHD> dafis: right
18:02:51 <joe6> this morning, there was a discussion that ghc8 was going the xml route.
18:03:11 <dafis> joe6: ?
18:04:09 <joe6> that haskell will start to look like xml or some such thing.
18:04:23 <joe6> I am not sure if they were just bull-shitting or were serious.
18:04:30 <kmc> haha
18:04:33 <joe6> i think saml was the nick mentioning it.
18:04:37 <dafis> joe6: the former
18:04:38 <kmc> http://hackage.haskell.org/trac/summer-of-code/ticket/1575
18:05:17 <MHD> the NOINLINE/unsafePerformIO combo really needs a less hacky alternative
18:05:27 <kmc> for global IORefs?
18:05:38 <kmc> it's called ACIO, JHC has it
18:05:42 <MHD> kmc: global mutable state in general
18:05:50 <ezyang> MHD: I'll pass.
18:05:55 <joe6> it got me thinking about what I should pick up as my programming language..
18:06:10 <joe6> if haskell ever turns out to head down that path..
18:06:32 <joe6> glad to know that they were just kidding around..
18:07:14 <MHD> ezyang: what do you mean? Do you like the NuPIO hack?
18:07:25 <MHD> (I just made the NuPIO up)
18:07:37 <kmc> there is an opinion that "global variables are bad so they should also be difficult and dangerous"
18:07:41 <ezyang> As in, I'd rather not make global mutable state easier.
18:07:49 <kmc> ezyang, harm reduction!
18:08:12 <kmc> we can bury it under some insane category theory name so that beginners won't use it
18:08:19 <MHD> just make it some unsafe GHC extension
18:08:39 <_habnabit> so, when will we see hoogle+ ?
18:08:52 <MHD> kmc: Are there any category theoretic practice that concerns itself with global changes?
18:09:05 <kmc> nfc
18:09:15 <MHD> nfc?
18:09:19 <kmc> no effing clue
18:09:23 <MHD> of
18:09:26 <kmc> ezyang, i don't see Haskell as the sort of language that condescends to its users in that way
18:09:50 <kmc> do you also think that the helpers in Foreign.* should be removed because they make it easier to use C libraries?
18:10:15 <cmccann> kmc, right, the Haskell way would be to remove the kludge entirely and demand that users live up to its expectations of doing things properly
18:10:53 <ezyang> I consider unsafeXXX to be a great feature of, well, unsafe Haskell functions. I would not demand them removed, but I would vigorously object to their renaming.
18:10:53 <cmccann> either formalize something and do it right or don't do it at all, rather than handwave stuff :P
18:11:16 <MHD> Is there some way to disable screen output in OpenGL?
18:12:09 <MHD> Never mind
18:12:26 * cmccann wonders if things like top-level IORefs and such would be best expressed in terms of staged compilation, where an earlier stage defines things that following stages use
18:13:01 <kmc> MHD, you can render to things other than the screen
18:13:07 <kmc> like framebuffer objects or something
18:13:19 <ski> ezyang : well, global-extent state is more "you probably don't want to do that" rather than "be very careful doing this, stuff may break"
18:13:21 <kmc> i dunno, I learned OpenGL at the point in time when this was all undocumented vendor-specific messes
18:13:23 <MHD> kmc: It's more for concurrency
18:13:35 <kmc> right, a major point of ACIO is to make global state safe
18:14:27 <kmc> Haskell should make bad ideas hard to do by accident, but easy to do on purpose
18:14:42 <kmc> in GHC Haskell it is really hard to execute an arbitrary buffer of bytes as machine code, by accident
18:14:47 <kmc> and pretty easy to do it explicitly
18:15:00 <ski> cmccann : well, generating an `IORef' a compile-time seems very different from generating one for each process started from the executable
18:15:29 * ski agrees with kmc
18:15:42 <MHD> Maybe I should do my own OpenGL binding too, to ensure concurrent stability of openGL calls
18:15:52 <MHD> MADNESS!
18:16:45 <ski> (cmccann : .. if that's what you had in mind, i.e.)
18:17:28 <ski> (sometimes it would be nice to be able to have parameters to modules .. sigh)
18:17:34 <kmc> one nice thing you can do in haskell is "inSpecialOpenGLThread $ do ..."
18:17:58 <aavogt> is that implemented with throwTo?
18:18:16 <kmc> i would implement it with Chan (IO ())
18:18:21 <kmc> that's what GTK+ does too
18:18:27 <kmc> i think they have some (gasp!) global Chan
18:18:57 <kmc> or they use GTK global state to store it
18:19:15 <aavogt> doing it with exceptions is not going to guarantee ordering in the same way?
18:19:23 <dbpatterson> are there checksums of the ghc binaries tarballs? I'm getting this error and wonder if my download was corrupted: cp: cannot stat `ghci-7.0.3': No such file or directory. my md5 is 80adbf2356bacbe79234da730a7dfb88  ghc-7.0.3-i386-unknown-linux.tar.bz2
18:19:31 <cmccann> ski, if I'm remembering things correctly the idea of staged compilation blurs the line between compile-time and run-time, so I was thinking having a limited "compilation" step at what would normally be run time, creating top-level stuff before running the actual program
18:19:32 <kmc> i don't know.  async exceptions are generally bad
18:19:44 <kmc> that's right, if you make global variables hard in Haskell, people will write their global variables in C and use Foreign.StablePtr
18:20:50 <jmcarthur> i'd like global variables to be no harder to use than IO is, as long as they are as hard to accidentally use in the wrong place as IO is
18:21:13 <kmc> ACIO does a pretty good job of being explicit
18:21:19 <kmc> for starters, you don't get to run arbitrary IO actions at top level
18:21:29 <ski> cmccann : ok. as soon as it's after process creation, it would work, yes
18:21:43 <ski> cmccann : s/soon/long/
18:21:43 <aavogt>  main = do global <- newIORef empty; let ?global = global; ...
18:22:04 <ezyang> implicit parameters kind of fail if you follow best practices and provide type signatures.
18:22:06 <kmc> you can only run ACIO actions, which are unobservable if unused ("Affine") and commute with all of IO ("Central")
18:22:17 <ski> cmccann : but being able to pass parameters to modules would also work here, i think
18:23:21 <kmc> and there's a thing to embed IO actions in ACIO, but in a reasonable way
18:24:04 * ski sometimes would like to see more laws about `IO'-actions
18:24:06 <aavogt> ezyang: putting signatures in patterns and expressions (iirc, the tendency in ocaml) might be a way to get somewhere close to "best practices" while we still don't have partial type signatures
18:25:12 <mm_freak> i think implicit configurations are a cleaner abstraction than implicit parameters
18:25:14 * aavogt wonders about using quasiquoters for types making the faking of partial type signatures
18:25:30 <mm_freak> and more powerful, too
18:26:28 <mm_freak> also i think partial type signatures, if they were there, shouldn't be abused to hide implicit parameters
18:26:36 * ddarius hugs monochrom.
18:27:28 <ski> (aavogt : it's really ascriptions, not signatures)
18:49:36 <monochrom> dbpatterson: your checksum equals mine
18:52:20 <codolio> Good. You've both got files infected with the same virus, then.
18:52:59 <Eduard_Munteanu> Mine's bigger :P
18:57:25 <dbpatterson> monochrom: I think the virtual machine I was installing on was corrupted. so bigger problems :(. thanks though :)
19:12:46 <aavogt> http://hpaste.org/48828 <- partial type signatures making the `asTypeOf` (undefined :: sig)  a bit less backwards
19:15:13 <aavogt> I guess it's not possible to write one clause for a function with TH and leave the rest normal
19:20:44 <orifichu> Do I need the haskell platform to work with the snap framework?
19:22:13 <Axman6> you don't specifically need the platform, but it will make setting up snap a lot easier
19:24:01 <orifichu> Axman6: What do I need to install snap?
19:24:27 <Axman6> ghc, and cabal-install. both of which come in the haskell platform
19:24:37 <monochrom> all packages that snap depends on. which means too many to mention
19:25:44 <monochrom> if you have cabal-install, it will chase those dependencies for you
19:25:56 <Axman6> orifichu: do you know haskell?
19:26:47 <orifichu> Axman6: yes, i have ghc installed in my host but i have a lot of problems to install the haskell platform
19:27:03 <Axman6> what problems?
19:27:10 <cmccann> I should start using (⩵) as the equality operator in my Haskell code
19:27:38 <monochrom> haha
19:28:04 <cmccann> ♥ unicode
19:28:57 <orifichu> Axman6: for example when i try to configure it(with ./configure) it tells me that needs the GLUT C library
19:29:11 <Axman6> have you install GLUT?
19:29:17 <Axman6> also what OS are you on
19:29:53 <orifichu> Axman6: i have a bluehost host with red-hat 64
19:30:32 <Axman6> hmm, then going with ghc and cabal-install is probably the best way to go.
19:31:12 <Axman6> orifichu: follow the instructions on http://www.haskell.org/haskellwiki/Cabal-Install#Unix
19:31:43 <Axman6> then you should be able to use cabal install snap
19:33:27 <orifichu> Axman6: i have installed the freeglut library(a free version of glut) but when i try with ./configure it tells me another problem with a glutMainLoop function
19:33:40 <GreaseMonkey> � unicode
19:33:42 <Axman6> you don't need glut for snap
19:34:48 <orifichu> Axman6: haskell platform have many libraries.....snap dont need any of these?
19:37:35 <c_wraith> it needs a small fraction of them.  like...  mtl.
19:37:46 <c_wraith> and bytestring and text
19:37:51 <cmccann> okay ⑾ seems like a very useful unicode character
19:39:42 <SirFrancisDrake> previous loving unicode conversation took place about 22 hours ago. Is there a pattern?
19:39:59 <SirFrancisDrake> that time, it was about lambda
19:40:07 <cmccann> at least lambda is a single letter
19:40:16 <cmccann> I mean, people actually use it to write words
19:40:38 <cmccann> why a single character for (11) exists I have no idea
19:41:06 <SirFrancisDrake> for APL
19:41:18 <codolio> Really?
19:41:25 <cmccann> there is a whole unicode section for APL operators
19:41:31 <cmccann> but (11) wasn't in there
19:41:41 <cmccann> though I suppose it could be related I have no idea
19:41:52 <SirFrancisDrake> just guessing
19:42:11 <codolio> (11) doesn't look very APLy.
19:43:30 <codolio> Far too mundane.
19:43:47 <cmccann> I mean there's also like thirty different copies of A-Z in different weights and typefaces because mathmaticians insist on giving typefaces semantic content
19:43:56 <cmccann> but (11) just seems weird
19:44:11 <codolio> Is it just (11)?
19:44:24 <codolio> Also, what is the name of the character?
19:44:25 <cmccann> no, it's got 1-20 in parentheses I think
19:45:07 <cmccann> codolio, that one is "PARENTHESIZED NUMBER ELEVEN"
19:45:11 <codolio> Wow.
19:45:16 <SirFrancisDrake> no such symbol in APL. Just checked
19:45:16 <cmccann> truth in advertising, I will admit
19:45:34 <cmccann> oh wait I just figured it out
19:45:38 <cmccann> it's for numbering lists
19:45:41 <codolio> ⒒
19:45:44 <codolio> There's also that.
19:45:45 <cmccann> or such
19:46:02 <codolio> NUMBER ELEVEN FULL STOP
19:46:17 <cmccann> well, most stop at ten
19:46:37 <cmccann> unicode goes to eleven :T
19:46:45 <SirFrancisDrake> enumerated lists of length <= 20. How twisted is that
19:46:51 <cmccann> ...actually 20 but that spoils the joke
19:47:18 <SirFrancisDrake> it's for the basque language
19:48:20 <orifichu> how can i install cabal?
19:48:52 <SirFrancisDrake> sudo aptitude install cabal-install?
19:48:57 <dafis> orifichu: download the tarball from hackage, unpack and ./bootstrap.sh
19:54:55 * cmccann defines "type a :───────→ b = a -> b" to use as the type for functions that are expensive to compute
19:55:13 <copumpkin> sounds handy
19:55:15 <cmccann> it's self-documenting
19:55:34 <orifichu> dafis: i need cabal, cabal-install or both?
19:55:39 <cmccann> just like using (⩵) for equality
19:56:35 <dafis> orifichu: cabal-install provides the cabal executable, the Cabal library comes with GHC
19:57:06 <dafis> orifichu: choose the right cabal-install version for your Cabal library
19:58:49 <SirFrancisDrake> my font doesn't have your equality symbol
19:58:55 <orifichu> dafis: i have installed ghc-6.12.3...which is the version of my cabal library?
19:58:59 <Jafet> Some fonts are more equal than others
19:59:02 <cmccann> SirFrancisDrake, it's a double equal sign
19:59:09 <cmccann> looks exactly like (==)
19:59:13 <cmccann> except as a single character
19:59:24 <SirFrancisDrake> cmccann: I've just googled it, but thanks
19:59:39 <dafis> orifichu: cabal-install-0.8.2
20:00:28 <SirFrancisDrake> cmccann: does your editor replace self-documenting symbols with native ones before compiling, or how does this work?
20:00:40 <dafis> orifichu: your Cabal library is (probably) 1.8.0.6
20:00:48 <Jafet> In the distant future, people are going to examine our UnicodeSyntax with the same interest as historians today studying Egyptian hieroglyphs
20:00:53 <cmccann> SirFrancisDrake, well, you can define whatever operators you want of course
20:01:00 <cmccann> but I'm mostly just being ridiculous
20:01:10 <orifichu> dafis: where i can find it?
20:01:13 <dafis> orifichu: you can check with "ghc-pkg list Cabal"
20:01:25 <cmccann> Though I define stuff like "type ℤ = Integer" sometimes because why not
20:01:28 <dafis> orifichu: where can you find what?
20:01:48 <orifichu> dafis: my cabal version
20:02:13 <dafis> @hackage cabal-install
20:02:13 <lambdabot> http://hackage.haskell.org/package/cabal-install
20:02:20 <dafis> orifichu: ^^
20:02:25 <cmccann> (un)fortunately GHC is smart enough when parsing to distinguish unicode space characters as such, so I can't define invisible functions
20:02:32 <monochrom> "cabal --version"
20:02:32 <orifichu> dafis: i found it....is Cabal-1.8.0.6
20:02:52 <dafis> orifichu: so cabal-install-0.8.2
20:05:50 <orifichu> dafis: ok, i have it. how can i install it?
20:06:23 <dafis> orifichu: unpack the tarball, cd cabal-install-0.8.2, ./bootstrap.sh
20:06:47 <dafis> perhaps you need chmod +x bootstrap.sh first
20:07:07 * monochrom doesn't understand. why ghc 6.12.3? ok probably because that's what your distro gives you. so why not cabal-install from the same distro? there is something self-contradictory here
20:07:11 <orifichu> dafis: yes...i need that chmod thing
20:08:24 <Jafet> > let cmccann = 20; cmccаnn = 22 in cmccann + cmccаnn
20:08:25 <lambdabot>   42
20:08:40 <dafis> orifichu: okay, then it wgets a couple of packages and installs them, finally you should get a message that cabal-install is installed in ~/.cabal/bin, and you should put that in your $PATH
20:09:18 <cmccann> Jafet, too bad I can see the difference in the font I'm using
20:09:23 <orifichu> dafis: how can i indicate the ghc directory in the installation?
20:09:34 <Jafet> Which font do you use?
20:09:56 <dafis> orifichu: you don't need to
20:10:06 * edwardk waves hello.
20:10:12 <dafis> (assuming ghc is in the path)
20:10:23 <SirFrancisDrake> how do I catch an exception inside a thread?
20:10:46 <Jafet> Control.Exception.catch, as usual
20:10:51 <orifichu> dafis: yes i have. i want to install it in my hosting...and i have to intall ghc in a separate directory
20:11:11 <SirFrancisDrake> Jafet: yeah, but where do I put it? I'm probably missing some understanding
20:11:30 <Jafet> Uh, you put it where you want exceptions to be caught
20:11:36 <aavogt> SirFrancisDrake: what code throws the exception?
20:12:20 <dafis> orifichu: not a private machine?
20:12:43 <orifichu> dafis: yes. is a shared server
20:13:20 <cmccann> hey, unicode actually has a "function application" symbol
20:13:32 <cmccann> GHC ought to support that with unicode syntax enabled
20:13:39 <cmccann> that would definitely make code more readable
20:13:44 <dafis> orifichu: then open bootstrap.sh in a text editor and set the variables according to where cabal-install should go
20:14:32 <orifichu> dafis: i will try changing the PATH first
20:16:35 <cmccann> > let (⁡) f x = f x in fix⁡error
20:16:36 <lambdabot>   <no location info>: lexical error at character '\8289'
20:16:39 <cmccann> pfffff lame
20:16:59 <hpaste> SirFrancisDrake pasted “exception” at http://hpaste.org/48830
20:17:22 <SirFrancisDrake> aavogt: something like that, just a clarifying sample
20:17:48 <orifichu> dafis: yes! the PATH thing works....i waiting while it compiles
20:18:04 <SirFrancisDrake> cmccan: what is function application symbol?
20:18:20 <cmccann> SirFrancisDrake, the one I tried to define a moment ago
20:18:21 <SirFrancisDrake> cmccann: sorry, lost an "n"
20:18:52 <SirFrancisDrake> oh
20:18:58 <cmccann> :]
20:19:06 <cmccann> there's also an "invisible times" character
20:19:23 <cmccann> which should obviously be a synonym for (*) with UnicodeSyntax enabled
20:19:34 <cmccann> but somehow I don't see that catching on :[
20:20:00 <hpaste> SirFrancisDrake annotated “exception” with “exception (annotation)” at http://hpaste.org/48830#a48831
20:21:42 <orifichu> dafis: which will be the cabal-install directory?
20:22:43 * cmccann tries to define (�) as an alias for undefined
20:22:57 <cmccann> ...only to be foiled again :[
20:23:03 <SirFrancisDrake> should I just wrap al the thread code into a catch?
20:23:13 <SirFrancisDrake> cmccann: that would be awfully elegant
20:23:25 <SirFrancisDrake> cmccann: even better than (==)
20:23:29 <cmccann> SirFrancisDrake, like I keep saying, self-documenting
20:23:32 <dafis> orifichu: I don't know, $HOME/.cabal/bin is probably not the one on a shared server, is a global install in /usr/local/bin possible?
20:23:54 <cmccann> what could be a better name for _|_ than the unicode symbol used for undefined symbols?
20:24:29 <SirFrancisDrake> cmccann: and much less annoying to type when you write, like, 10 type signatures and undefined`s just to type check
20:25:19 <orifichu> dafis: the /usr/local/bin directory don't have permission....maybe the installation will not be complete
20:25:37 <orifichu> dafis: how can i indicate the directory installation?
20:26:07 <iratsu> does attoparsec have a <|> cominator?
20:26:08 <dafis> orifichu: wait, let me have a look
20:26:27 <cmccann> > let (☠) = error $ repeat '☠' in (☠)
20:26:28 <lambdabot>   *Exception:
20:26:37 <cmccann> phooey
20:26:48 <SirFrancisDrake> is there a good way to pause and then unpause a forked thread? The best I can come up with is -- throw an exception "stop", then throw "resume", with two nested catches itt
20:29:06 <Jafet> In agda it's just ()
20:29:20 <dafis> orifichu: PREFIX=/where/it/should/go ./bootstrap.sh [--global]
20:29:27 <Jafet> SirFrancisDrake: you can't “resume” from an exception
20:30:20 <Jafet> If what you want to achieve is some sort of synchronization, use an MVar
20:30:35 <ddarius> Probably the most sensible thing would be to have the forked thread poll an MVar or somesuch.
20:31:05 <orifichu> dafis: oh, i ever use --prefix=directory but when i try ./bootstrap.sh --help i didn't see the --prefix thing
20:31:27 <orifichu> dafis: i need write "[--global]"?
20:31:35 <SirFrancisDrake> Jafet, ddarius: thanks. Though checking the MVar on every iteration doesn't look very elegant to me
20:31:39 <Axman6> ddarius: the problem with that is that you can only pause the thread when it checks the mvar
20:31:58 <ddarius> Axman6: That's intentional.
20:32:08 <SirFrancisDrake> Axman6: that's fine with me in this case.
20:32:12 <Axman6> ok
20:32:25 <dafis> orifichu: depends on whether you want a global install or a user install, does anybody except you use your share of the server?
20:32:31 <Jafet> Um, dunno, then check it every other iteration.
20:32:39 <SirFrancisDrake> ddarius: uh, intentional?
20:32:49 <SirFrancisDrake> even less elegant :p
20:33:13 <dafis> orifichu: and the "[" "]" were meant to indicate that "--global" is optional
20:33:29 <orifichu> dafis: ah ok...got it
20:33:34 <Jafet> Not so much intentional as being the only reasonable method
20:34:01 <Axman6> SirFrancisDrake: you could make a function: foo mv = takeMVar mv >>= putMVar mv
20:34:05 <ddarius> The reason its reasonable is that it allows the paused thread to only be paused during a "safe" point.
20:34:32 <orifichu> dafis: i can see a ".cabal" directory in $HOME...maybe the PREFIX thing will not be necessary
20:34:45 <Axman6> you could make new monad that wraps IO, but checks a given MVar at every >>= =)
20:35:07 <dafis> orifichu: if you have a $HOME, you can use that
20:35:25 <ddarius> If you wanted it to be more elegant, you could use a concurrency monad scheme and have your own scheduler, and then to pause a thread you would just temporarily remove if from the ready queue.
20:35:50 <orifichu> dafis: ok
20:36:06 <mustelo> can anyone point me to papers that discuss functional programs solving the exact cover problem?
20:36:55 <orifichu> dafis: yes! installation successful...in the $HOME/.cabal/bin directory
20:38:09 <dafis> orifichu: if that is already in the path, next is "cabal update"
20:38:22 <dafis> (to get the package list)
20:38:36 <orifichu> dafis: yes, i will do that
20:39:51 <SirFrancisDrake>  >>= putMVar is actually cool
20:40:09 <dafis> orifichu: that should also create a config file in ~/.cabal, edit that to suit your preferences (it's probably a good idea to set documentation : True and library-profiling: True in the config)
20:40:22 <orifichu> dafis: downloading the latest packeage now...im waiting
20:41:32 <orifichu> dafis: which are the benefits of that settings in the config file?
20:42:43 <dafis> orifichu: cabal will build haddock documentation for each package it installs, respectively it will build profiling versions of each library in addition to the vanilla version
20:43:44 <dmwit> Axman6: Could you? Would that satisfy the monad laws?
20:43:57 <cmccann> hm
20:43:59 <cmccann> aha
20:44:01 <Axman6> I'm not sure it would
20:44:03 <dmwit> return x >>= f = f x -- seems to behave differently
20:44:04 <orifichu> dafis: ah ok ok
20:44:06 <Axman6> i think it would
20:44:09 <cmccann> 𝔫𝔬𝔴 𝔪𝔶 𝔲𝔫𝔦𝔠𝔬𝔡𝔢 a𝔟𝔲𝔰𝔢 𝔦𝔰 𝔯𝔢a𝔩𝔩𝔶 𝔤𝔢𝔱𝔱𝔦𝔫𝔤 𝔰𝔬𝔪𝔢𝔴𝔥𝔢𝔯𝔢...
20:44:24 <Axman6> dmwit: the result is the same though, if it returns
20:44:26 <dmwit> cmccann: That string of gibberish also led me to enlightenment!
20:44:28 <orifichu> dafis: i need install the update of the cabal-install?
20:44:31 <ddarius> The ideal situation would be if you could communicate with GHC's scheduler.
20:44:45 <Axman6> but no, it probably doesn't satisfy the laws
20:44:54 <ddarius> cmccann: Why are your a's jacked u.
20:44:55 <cmccann> dmwit, it seems your font is suboptimal
20:44:57 <ddarius> up.
20:44:59 <dafis> orifichu: no, that's for version 1.10 of the Cabal library
20:45:01 <dmwit> Axman6: ...but one might return, and the other not.
20:45:15 <cmccann> ddarius, hm, good question
20:45:19 <dafis> orifichu: (which comes with ghc-7.0)
20:45:43 <orifichu> dafis: can i update ghc with cabal?
20:45:57 <dafis> orifichu: no, not yet anyway
20:46:17 <Axman6> dmwit: depends on how you define the equality in return x >>= f = f x i guess
20:46:20 <dmwit> cmccann: Oh, yes, it's probably some combination of zsh, screen, irssi, ssh, gnome-terminal, and installed fonts that's screwing me up. Plenty of places for things to screw up.
20:46:36 <orifichu> dafis: snap framework work with any ghc version?
20:46:52 <Axman6> if it never gives a result, then it's true under partial correctness isn't it? (i think that's the right term, it's been a while)
20:47:09 <dafis> orifichu: no idea, never looked at snap (that's web stuff, isn't it?)
20:47:31 <dmwit> Axman6: You're willing to relate undefined and defined values in your equality?
20:48:16 <orifichu> dafis: yes, a web framework
20:48:47 <ski> dmwit : you mean using `]=' or `=[' instead of `=' ?
20:48:47 <Axman6> doesn't the same thing hold for IO? if you have f x = f x, then doesn't that mean the laws don't hold for pretty much anything?
20:48:48 <cmccann> 𝔱𝔥𝔢𝔯𝔢 𝔴𝔢 𝔤𝔬, 𝔣𝔦𝔵𝔢𝔡 𝔱𝔥𝔢 𝔭𝔯𝔬𝔟𝔩𝔢𝔪 𝔴𝔦𝔱𝔥 𝔞. 𝔪𝔲𝔠𝔥 𝔟𝔢𝔱𝔱𝔢𝔯!
20:48:52 <Jafet> If you're willing to write a thread scheduler just to synchronize execution… that's a trivial concession
20:49:23 <dafis> orifichu: well, it should work with al recent enough ghc versions, and 6.12 should be recent enough, but you'll have to try to find out
20:49:28 <cmccann> dmwit, well no, I'm pretty sure what's screwing things up is that I'm abusing unicode in stupid ways
20:49:50 <dmwit> Axman6: I don't understand. f x = f x seems like a perfectly cromulent law to me.
20:50:08 <ivanm> preflex: seen BCoppens
20:50:08 <preflex>  BCoppens was last seen on #haskell-blah 18 hours, 40 minutes and 49 seconds ago, saying: shachaf: no :P
20:50:12 <cmccann> 𝕙𝕖𝕣𝕖, 𝕙𝕠𝕨'𝕤 𝕥𝕙𝕚𝕤 𝕝𝕠𝕠𝕜 𝕚𝕟𝕤𝕥𝕖𝕒𝕕?
20:50:15 <Jafet> > "𝔟𝔢𝔱𝔱𝔢𝔯 𝔟𝔦𝔱𝔱𝔢𝔯 𝔟𝔞𝔱𝔱𝔢𝔯"
20:50:16 <lambdabot>   "\120095\120098\120113\120113\120098\120111 \120095\120102\120113\120113\12...
20:50:40 <Axman6> no, i mean the definition of f being that. then if you have return x >>= f = f x, since both don't terminate, does that make them still equal?
20:50:44 <ivanm> boxes, boxes everywhere, but nothing that can be read! :p
20:50:47 <Axman6> you'll never get a result from that equality
20:50:55 <dmwit> Axman6: Yes. I'm perfectly happy equating two undefined things.
20:50:58 <orifichu> dafis: ah ok
20:51:00 <Axman6> ivanm: lrn2unicode :P
20:51:02 <edwardk> hrmm i need a good name for an additive monoid for which I can, given c, generate the set of all pairs (a,b) such that a + b = c
20:51:05 * dafis has nostalgia for the times when there was only ASCII
20:51:10 <ivanm> Axman6: hey, I'm using a unicode font!
20:51:11 <dmwit> Axman6: I'm not perfectly happy equating a defined thing with an undefined thing, though.
20:51:19 <Jafet> There was never a time when there was only ASCII.
20:51:35 <ski> dmwit : "return x >>= f = f x -- seems to behave differently" -- which (proposed) monad are you considering ?
20:51:55 <cmccann> 𝓱𝓮𝓻𝓮'𝓼 𝓪𝓷𝓸𝓽𝓱𝓮𝓻 𝓿𝓮𝓻𝓼𝓲𝓸𝓷 𝓽𝓱𝓪𝓽'𝓼 𝓪𝓬𝓽𝓾𝓪𝓵𝓵𝔂 𝓼𝓸𝓻𝓽 𝓸𝓯 𝓻𝓮𝓪𝓭𝓪𝓫𝓵𝓮.
20:51:57 <opdolio> edwardk: Do we have anything to talk about tomorrow?
20:51:58 <ivanm> specifically, DejaVu Sans Mono (however it's capitalised
20:52:00 <ivanm> )
20:52:00 <Axman6> one which checks reads from and then writes back to an MVar in each >>=
20:52:12 <edwardk> opdolio: i haven't got anything planned
20:52:14 <dmwit> ski: One in which (>>=) checks an MVar and pauses if it holds True, awaiting a next False.
20:52:26 <cmccann> 𝒷𝓊𝓉 𝓂𝓎 𝒻𝓄𝓃𝓉 𝒹𝓄𝒺𝓈𝓃'𝓉 𝓈𝓊𝓅𝓅𝓄𝓇𝓉 𝓉𝒽𝒾𝓈 𝓄𝓃𝒺, 𝒶𝓁𝒶𝓈
20:52:30 <edwardk> opdolio: i've been playing with abstract algebra since i got out of the doctors' office
20:52:47 <dolio> Okay. Just present that.
20:52:53 <edwardk> opdolio: =)
20:52:58 <Axman6> ivanm: doesn't mean your using unicode though, there's much more to it than just using a unicode font
20:53:08 <edwardk> https://github.com/ekmett/algebra/tree/master/Numeric is what i have so far
20:53:25 <ivanm> Axman6: and I've built everything with unicode support
20:53:28 <edwardk> i'm going through and dropping in missing bits and pieces as i go. since this is the fleshed out 'everything in the right place' version of things
20:53:47 <ivanm> hmmm.... for some reason in the edit box the text is indeed shown, but in the main scroll window it isn't...
20:54:24 <ivanm> edwardk: do you have a polynomial implementation yet?
20:54:35 <edwardk> ivanm: not in that repository, but its coming. =)
20:54:41 <ivanm> heh
20:54:44 <edwardk> thats actually why i wanted the answer to the question i posed above
20:54:55 <edwardk> because i'm trying to see if i can give them just in terms of arbitrary monoid rings
20:54:57 <Axman6> data PauseIO a = PIO (MVar ()) (IO a); instance Monad PIO where (>>=) (PIO mv i) f = PIO mv $ do {x' <- x; takeMVar mv >>= putMVar mv; f x' }
20:55:05 <Axman6> something like that
20:55:07 <ivanm> you asked a question?
20:55:20 <ivanm> I saw a statement that you needed a name.... but not a question :p
20:55:20 <Axman6> though, more Reader like
20:55:39 <edwardk> but for that i need the ability to take a monoidal value c, and split it into all [(a,b)], such that a + b = c
20:55:58 <edwardk> well, i need a name for it ;)
20:56:05 <orifichu> dafis: when i try "cabal install snap" it tells me a warning: "module 'prelude' is deprecated"
20:56:28 <dafis> orifichu: that can safely be ignored
20:56:38 <ski> edwardk : "splittable-monoid" ? :)
20:56:45 <cmccann> edwardk, I think your library needs more unicode
20:56:50 <edwardk> ski: *twitch* i guess its as good as any
20:57:00 <dmwit> edwardk: Factorizable?
20:57:20 <ddarius> Axman6: A reader monad would make more sense to me.
20:57:21 <edwardk> dmwit: thats pretty good
20:57:39 <Axman6> ddarius: yeah, i just couldn't remember how to implement one off the top of my head =)
20:57:49 <ski> dmwit : that would (to me) seem to carry connotations of being able to compute a factorization which can't be (non-trivially) further factorized
20:57:59 <edwardk> factorable even
20:58:06 <ddarius> Axman6: Really?
20:58:16 * dmwit nods at ski
20:58:28 <ski> Axman6 : `(MVar () ->)' instead of `(MVar (),)'
20:58:28 <Axman6> really, i don't go around implementing such things very often
20:58:33 <edwardk> ski: well, unique factorization domain it does, but i have lots of weaker rings =)
20:58:38 <orifichu> dafis: when i try "cabal install something"...where will be installed the "something" package?
20:59:01 <ski> edwardk : well, i wasn't talking about necessarily *unique* factorization, though ..
20:59:05 <dmwit> Still "factorable
20:59:07 <edwardk> i think Factorable wins
20:59:15 <dmwit> " seems a bit better than "Splittable".
20:59:33 <edwardk> except for the fact that want to use it in an additive context ;)
20:59:36 <Axman6> data PauseIO a = PIO (MVar () -> (IO a)); instance Monad PIO where (>>=) (PIO p) f = PIO $ \mv -> do {x' <- x; takeMVar mv >>= putMVar mv; f x' }?
20:59:40 <dmwit> Oh, well.
20:59:42 <dmwit> hm
20:59:58 <ski> edwardk : "termable" ? "addendable" ? "summandable" ? :D
21:00:11 <ddarius> Axman6: You still need to define return, and, in all likelihood, that will break the monad laws.
21:00:12 <Maxdamantus> AdditivelyFactorable
21:00:31 <Axman6> probably
21:00:32 <dmwit> "summandable" sounds like the sharp bits of an ant's mouth
21:00:39 <Axman6> but who's ever cared about that anyway!
21:00:39 <edwardk> dmwit: =)
21:00:48 <dafis> orifichu: That's a good question. The package description goes into ~/.ghc/version, the object code in ~/.cabal/compiler
21:01:08 <Axman6> ddarius: i thought it sounded like an incantation
21:01:15 <Axman6> dmwit*
21:01:22 <dafis> (where version and compiler stand for whichever compiler version that stuff is installed with)
21:01:25 <Axman6> too many d-names!
21:01:29 <edwardk> 'serial' since it can be turned into a finite series?
21:01:42 <ski> "partitionable" ?
21:02:14 <ski> "reducible" ?
21:02:22 <dmwit> Oh, I like Partition.
21:02:46 <edwardk> Partitionable is pretty good
21:02:47 <ddarius> Axman6: Also, you want do x <- p mv; takeMVar mv >>= putMVar mv; unPIO (f x) mv
21:02:59 <Axman6> yes
21:03:25 <orifichu> dafis: got it
21:03:31 <ivanm> ski: damn, I was just about to suggest partitionable!
21:03:43 <ski> hehe
21:03:56 <orifichu> dafis: allways in that directories?
21:04:01 <cmccann> by analogy of integrals as generalized sums, how about "disintegrable" :P
21:04:41 <ski> @type liftM2 (>>=) Control.Concurrent.MVar.takeMVar Control.Concurrent.MVar.putMVar
21:04:42 <lambdabot> forall a. GHC.MVar.MVar a -> IO ()
21:04:48 * hackagebot network-protocol-xmpp 0.4 - Client->Server XMPP  http://hackage.haskell.org/package/network-protocol-xmpp-0.4 (JohnMillikin)
21:04:54 <edwardk> cmccann: heh
21:05:30 * ski . o O ( "eradicable" )
21:05:54 <dafis> orifichu: not always, if you install a package with the --global flag, the package description goes into the global package database where ghc is installed, I'm not sure where the object code is put in that case
21:05:57 <edwardk> unless something epically appropriate comes up i think i'll go with partitionable
21:06:43 <cmccann> edwardk, there's just not as many good terms for addition as there are for multiplication it seems
21:07:04 <edwardk> yeah
21:07:29 <ski> edwardk : hm, are you assuming commutativity/abelianess, btw ?
21:07:35 <ddarius> edwardk: I recommend Garret Sobczyk's paper(s) on spectral bases.
21:07:48 <edwardk> ski: not in this.
21:07:50 <cmccann> I suppose that when you have two operations with appropriate interactions, the name "addition" tends to be given to the more boring one
21:07:58 <ddarius> edwardk: It may give you ideas (or it may be irrelevant.)
21:08:02 <edwardk> ddarius: oh?
21:08:07 <edwardk> ddarius: added to the pile
21:08:49 * ddarius recently added an organic chemistry textbook to his pile.
21:09:11 <djahandarie> Hmm, chemistry.
21:09:18 <djahandarie> That's something that I'd like to learn properly some time.
21:10:17 <dolio> Mark it zero!
21:10:30 <aavogt> ddarius: re PIO, it would be sensible to wait only on the IO side of things, whcih you could have with:   PIO = ReaderT (MVar ()) IO, then   liftIO io = do mv <- ask; takeMVar mv >>= putMVar mv; lift io
21:12:35 <ddarius> aavogt: Yes, pulling the takeMVar/putMVar out of (>>=) and sticking it into a yield action would make much more sense (and save the monad laws) and in that case, liftIO = (yield >>) . lift
21:12:53 <aavogt> @hoogle yield
21:12:54 <lambdabot> Control.Concurrent yield :: IO ()
21:14:26 <ddarius> Cooperative concurrency is under-utilized/-supported.
21:16:07 <cmccann> edwardk, out of curiosity, how would you represent a free group over a type in Haskell?
21:16:37 <aavogt> but liftIO /= lift  is sort of odd
21:16:42 * ski was irritated that equilibrium constants were not defined in way that respects the equivalence between different representants of the stochiometric coefficients ..
21:16:42 <cmccann> most other free algebraic structures seem to lend themselves to some sort of straightforward representation
21:18:11 <edwardk> cmccann: make up something like data Signed a = Pos a | Neg a; then work with Seq (Signed a) — cancelling Pos a with Neg a and vice versa on the edges when you go to merge them
21:18:35 <ddarius> cmccann: The doctrine that groups fall into is slightly different than the doctrine that monoids fall into which leads to some complications.
21:18:45 <ddarius> s/doctrine/hyperdoctrine/
21:19:07 <edwardk> cmccann: that gives an encoding of the free group for a free generating set
21:20:03 <aavogt> ski: use G = RT log K, which will be off by a multiple instead?
21:20:04 <cmccann> edwardk, it's the canceling when merging that bugged me, I guess
21:20:39 <edwardk> cmccann: you need Eq for that, then just view right edge of the thing on the left and the left edge of the thing on the right, and compare, if they equal remove and repeat.
21:20:57 <edwardk> (if they are equal and differ in sign)
21:21:20 <edwardk> tedious and boring, but not hard ;)
21:21:38 <cmccann> yeah, it's not that hard to implement, it's more than there's no guarantee of a unique representation
21:21:54 <edwardk> how so? you get a reduced representation
21:22:02 <dmwit> cons (Pos a) (Neg a':as) | a == a' = as; cons (Neg a) (Pos a':as) | a == a' = as; cons a as = a:as
21:22:14 <cmccann> in the sense that the type contains values that aren't reduced
21:22:15 <aavogt> but you then have the same issue of picking which quantity reacted to divide the G by (in it's units)
21:22:16 <edwardk> you get the guarantee that no element is adjacent to its inverse
21:22:23 <dmwit> mappend = foldr cons
21:22:24 <edwardk> that is all you can assume
21:22:30 <edwardk> given the free group
21:22:49 <edwardk> all values that can be reduced freely are.
21:23:13 <cmccann> with a free monoid the type itself guarantees the representation is unique, whereas with the group there's an extra step to ensure it
21:23:23 <cmccann> I know it's easy enough, it just bugs me :[
21:23:49 <dolio> Just take the quotient type.
21:23:54 <cmccann> structures without inverses avoid the issue, commutative structures avoid it another way, etc.
21:23:58 <dmwit> cmccann: Yep, you get the same problem for any presented monoid (i.e. a free monoid modulo some equalities).
21:24:16 <ski> aavogt : i mean that if in `a * A + b * B <-> c * C + d * D' with equilibrium constant `K', if you scale all the coefficients `a',`b',`c',`d' by a common (natural number) factor `k', then the equilibrium constant will be `K^k', instead of `K', still
21:24:41 <dmwit> cmccann: About the best you can do is hide the constructors in a trusted module, and do some proofs about canonical forms...
21:25:18 <dmwit> You can do better with dependente types, of course. =)
21:25:29 <cmccann> dmwit, of course, yes :]
21:25:31 <_Ray_> Hi. If I say let fix f = f(fix f), and f x = (x^5)/6.0, the reason fix f isn't a fixed point of f is because of numerical precision, ne?
21:25:40 <dolio> With fancy enough types, you can inductively define a type with only the right inhabitants.
21:25:56 <ddarius> ski: Then aavogt's suggestion to use the log instead seems sensible.
21:26:00 <dmwit> cmccann: You might be able to do something with an antidiagonal...
21:26:01 <aavogt> ski: so use G instead, and say it's units are  joules per mole A reacted
21:26:03 <dmwit> http://blog.sigfpe.com/2007/09/type-of-distinct-pairs.html
21:26:23 <dmwit> Haven't read that blog post, though, so I only know the blurb description.
21:26:24 <aavogt> to specify that you've divided all the coefficients by a
21:26:38 <cmccann> it just seemed odd to me that I couldn't find a way to describe it directly in Haskell, since I'm used to a lot of free structures having that kind of direct representation
21:27:02 <ski> i just would like it to be independent on representation ..
21:28:05 <ski> (of course my teacher didn't even understand my complaint at the time. i couldn't articulate sufficiently clearly what was wrong)
21:29:24 <ddarius> _Ray_: fix f is a fixed point of f, just with respect to a different poset.
21:29:44 <_Ray_> "with respect to a different poset"?
21:29:52 <_Ray_> (I know what a poset is, I think :))
21:30:48 <ski> _Ray_ : wrt the definedness ordering
21:31:07 <ddarius> > iterate (\x -> x^5/6) 0.5
21:31:08 <lambdabot>   [0.5,5.208333333333333e-3,6.38767197953003e-13,1.772400158141982e-62,2.9151...
21:31:53 <_Ray_> goes to 0 quickly after :p
21:32:25 <cmccann> > last $ iterate (\x -> x^5/6) 0.5
21:32:54 * hackagebot mongrel2-handler 0.2.0 - Mongrel2 Handler Library  http://hackage.haskell.org/package/mongrel2-handler-0.2.0 (BardurArantsson)
21:33:16 <ddarius> Anything with norm less than 6^(1/5) will approach zero, and everything else will approach infinity.
21:33:50 <dafis> 6^(1/4)
21:34:04 <ddarius> dafis: Yeah, I realized I was off by a factor of x.
21:34:31 <dafis> the famous off-by-one
21:35:07 * ddarius will describe his future correct answers as being off by a factor of 1.
21:35:27 <_Ray_> And what would be a way to output the value x such that x = x^5/6, meaning sqrt[4]{6}?
21:35:46 <dmwit> > sqrt (sqrt 6)
21:35:47 <lambdabot>   1.5650845800732873
21:35:48 <dafis> > sqrt (sqrt 6)
21:35:49 <lambdabot>   1.5650845800732873
21:35:53 <dmwit> blammo
21:35:55 <_Ray_> :p
21:36:05 <dmwit> :t (^^)
21:36:07 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
21:36:12 <dmwit> :t (^)
21:36:12 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
21:36:15 <dmwit> :t (**)
21:36:15 <dafis> :t (**)
21:36:16 <lambdabot> forall a. (Floating a) => a -> a -> a
21:36:16 <lambdabot> forall a. (Floating a) => a -> a -> a
21:36:22 <dmwit> > 6 ^^ (1/4)
21:36:23 <lambdabot>   Ambiguous type variable `t' in the constraints:
21:36:23 <lambdabot>    `GHC.Real.Fractional t'
21:36:24 <lambdabot> ...
21:36:31 <ddarius> You need **
21:36:32 <dmwit> > 6 ^^ (1/4) :: Double
21:36:33 <lambdabot>   Ambiguous type variable `t' in the constraints:
21:36:34 <lambdabot>    `GHC.Real.Fractional t'
21:36:34 <lambdabot> ...
21:36:36 <dmwit> aaaargh
21:36:39 <dafis> > 6 ** 0.25
21:36:40 <lambdabot>   1.5650845800732873
21:36:47 <dmwit> All that work to see I wanted (**), and I still used the wrong one.
21:36:53 <ddarius> (^^) only additionally allows negative exponents.
21:37:19 <aavogt> ski: a bigger annoyance is that if   a + b /= c + d,  the value of K is different if you use a different reference concentration
21:37:21 <dmwit> Yes, yes, I know the differences (if you give me the types).
21:38:39 <orifichu> dafis: i have some errors (after too much installing time)...the last was: unix-compat-0.2.1.3 failed during the building phase. The exception was: ExitFailure 1
21:38:50 <orifichu> dafis: some idea?
21:38:53 <aavogt> without multiplying all the coefficients by a constant (which isn't an issue in practice, because people divide through by the lcm, or 2*lcm)
21:38:56 <ddarius> You'd know the differences even better from the types if (^) only required Monoid and (^^) Group.
21:39:19 <ski> aavogt : i've forgotten what reference concentration is
21:39:26 <sshc> http://hackage.haskell.org/trac/ghc/wiki/SafeHaskell — Sounded like a bad idea to me on the surface.  But, after reading it, I think this sounds interesting.
21:39:34 <dafis> orifichu: try "cabal install unix-compat -v2", that should give more info
21:39:58 * MatrixFrog thought that was going to be about functions like safeHead
21:40:28 <aavogt> ski: to make K dimensionless even when a+b/=c+d, people just divide through by say (1 mol / L)^(c+d -(a+b))  or so
21:40:44 <orifichu> dafis: what is unix-compat?
21:41:25 <dafis> orifichu: don't know exactly, a compatibility package for unix functionality, I presume
21:42:33 <orifichu> dafis: and what means "-v2"?
21:42:51 <dafis> orifichu: verbosity level 2
21:43:06 <aavogt> ski: http://en.wikipedia.org/wiki/Gibbs_free_energy#Standard_change_of_formation and depending on accuracies, they might even specify 'as if it was an ideal gas' for that reference
21:43:45 <ski> i see
21:45:07 <orifichu> dafis: an error with the unix-compat installation: cabal: Error: some packages failed to install: unix-compat-0.2.1.3 failed during the building phase. The exception was: ExitFailure 1
21:45:33 <dafis> orifichu: nothing before that? then try -v3
21:46:35 <orifichu> dafis: before that: running dist/build/System/PosixCompat/Extensions_hsc_make failed command was: dist/build/System/PosixCompat/Extensions_hsc_make  >dist/build/System/PosixCompat/Extensions.hs
21:47:22 <dafis> orifichu: Hmm, doesn't help me, unfortunately
21:47:57 <dafis> orifichu: what were you originally trying to install that pulled in unix-compat, snap?
21:48:10 <tgeeky> oh snap, he said snap.
21:49:12 <orifichu> dafis: yes, i try: cabal install snap
21:50:36 <dafis> orifichu: try "cabal install snap unix-compat-0.2", that version of unix-compat built with 6.12 on hackage, so it should work for you
21:52:07 <edwardk> preflex: xseen copumpkin
21:52:07 <preflex>  copumpkin was last seen on freenode/#haskell-blah 1 hour, 40 minutes and 57 seconds ago, saying: ski: http://hpaste.org/48829
21:54:25 <mm_freak> can i have multiple versions of the base library installed?
21:54:57 <orifichu> dafis: how can i know the unix-compat version that works with ghc 6.12?
21:55:14 <mm_freak> OpenCLRaw unfortunately requires base <= 4.1, but i've got 4.3
21:57:56 <dafis> orifichu: on the hackage page, you can click through the versions and see whether they built with 6.12; it's not definitive because a) hackage stopped using 6.12 some time ago, so recently only 7.0 has been tried, as far as I know; and b) some packages depend on foreign libraries (C) which may be present on your machine but not on hackage or the other way round
21:58:46 <orifichu> dafis: oh yes...i can see that
21:59:49 <dafis> orifichu: in the end, you have to try
22:02:25 <orifichu> dafis: when i try: cabal install unix-compat-0.2 i have the error:  running dist/build/System/PosixCompat/Extensions_hsc_make failed command was: dist/build/System/PosixCompat/Extensions_hsc_make  >dist/build/System/PosixCompat/Extensions.hs cabal: Error: some packages failed to install: unix-compat-0.2 failed during the building phase. The exception was: ExitFailure 1
22:05:12 <killerswan__> so i have a problem with laziness, and a program that blows up the heap...
22:05:33 <killerswan__> a successful run looks comical like this: http://kevincantu.org/code/blake/profiling/blakesum-june29-foldl--hd.png
22:05:40 <dafis> orifichu: same as before, doesn't give me a clue what might be wrong. Try with -v3?
22:06:00 <kmc> killerswan__, you're building a list of Word8's?
22:06:59 <dafis> unpack a ByteString?
22:07:00 <killerswan__> i'm taking a ByteString, unpacking it, putting it in Word32s (or Word64s) and then computing a digest
22:07:22 <kmc> can you compute the digest on the ByteString directly?
22:07:40 <kmc> you can convert a ByteString to a Data.Vector.Storable vector without a copy
22:07:45 <kmc> assuming it's in native byte order
22:07:51 <dafis> killerswan__: that's probably not so good, if you can't calculate directly on the ByteString, perhaps using lazy ByteStrings helps
22:08:14 <killerswan__> this is lazy ByteStrings
22:08:48 <dafis> killerswan__: then it looks like your digest is not strict enough
22:09:35 <dafis> (assuming it can be calculated incrementally)
22:09:57 <killerswan__> i've been shotgunning exclamation points all over the place, but haven't put one in the right spot yet
22:10:20 <killerswan__> it is incremental on 16 words (of 32 or 64 bits)
22:10:23 <orifichu> dafis: in the middle of the log i can see thing like : searching for alex in path. Cannot find alex on the path
22:10:31 <orifichu> dafis: that is important?
22:10:42 <killerswan__> (well, my code clearly isn't behaving that way, but theoretically)
22:10:50 <kmc> killerswan__, what about using vector?
22:11:15 <killerswan__> kmc: that is, I think, what I should have done from the start
22:11:18 <dafis> orifichu: it very probably is, in addition to alex, you'll sooner or later also need happy, so "cabal install alex happy"
22:11:31 <killerswan__> kmc: or repa, or something like that
22:11:51 * ddarius has heard of very few people succeeding in resolving performance problems by "spraying" bangs all over the place.
22:12:51 <orifichu> dafis: there is many packages with "not found"....i have to install all of these right?
22:13:00 <killerswan__> ddarius: hehe
22:13:25 <dafis> orifichu: not necessarily, but alex and happy are often needed, so it's good to have those anyway
22:13:56 <orifichu> dafis: ok, i will try
22:14:13 <dafis> orifichu: what else was "not found"?
22:14:14 <orifichu> dafis: any alex and happy version?
22:14:29 <dafis> orifichu: whatever cabl decides to pick
22:14:37 <dafis> *cabal
22:14:41 <killerswan__> ddarius: i actually got significantly better performance by replacing a foldl' with a foldl, before I started the ! carpet bombing (but elsewhere, not where the heap is going nuts)
22:15:25 <dafis> killerswan__: foldl better than foldl' sounds strange
22:15:25 <orifichu> dafis: ok....another packages are "not found" like hmake hugs jhc
22:16:17 <dafis> orifichu: not relevant, hugs is a haskell interpreter, jhc a compiler, hmake a build system, you don't need those
22:16:44 <killerswan__> dafis: something done on each round is written poorly, so lazy evaluation of that straightens things out a wee bit, I suspect
22:17:37 <orifichu> dafis: oh ok
22:19:26 <orifichu> dafis: now an error trying to install alex
22:19:34 <orifichu> dafis: cabal: Error: some packages failed to install: alex-2.3.5 failed during the configure step. The exception was: ExitFailure 127
22:19:44 <dafis> orifichu: that sounds bad, what error?
22:20:09 <dafis> orifichu: up the verbosity, -v3
22:21:03 <dafis> orifichu: and paste the entire output @hpaste (or something)
22:21:30 <orifichu> dafis: well, im not shure...the log is too big and i cant read all
22:21:54 <dafis> orifichu: copy and paste, hpaste.org
22:23:01 <orifichu> dafis: the linux shell doesnt show all the log
22:23:22 <dafis> orifichu: then redirect the output to a file
22:23:33 <Eduard_Munteanu> orifichu: try wgetpaste
22:23:38 <orifichu> dafis: ok
22:23:59 <dafis> orifichu: probably we need stderr
22:24:19 <Eduard_Munteanu> 2>&1
22:24:37 <Eduard_Munteanu> (to combine stderr into stdout)
22:25:20 <m4k3r> Eduard_Munteanu: !
22:25:27 <m4k3r> Ops, sry
22:26:32 <orifichu> dafis: what's stderr?
22:26:55 <dafis> orifichu: the error message output stream
22:27:53 <dafis> orifichu: like Eduard_Munteanu said above, "cabal install alex -v3 2>&1 logfile"
22:28:20 <dafis> captures both, stdout and stderr
22:29:41 <orifichu> dafis: when i try with "cabal install alex -v3 2>&1 logfile" i have: cabal: "file.txt" is not valid syntax for a package name or package dependency.
22:30:30 <dafis> orifichu: without the quotes, they were only to separate the command from my text
22:31:16 <orifichu> dafis: yes im trying:  cabal install alex -v3 2>&1 file.txt
22:31:23 <orifichu> dafis: with that i have the error
22:32:17 <dafis> orifichu: strange, from the 2>&1 on, everything should be handled by the shell, cabal shouldn't even see it
22:32:30 <killerswan__> depends on the shell
22:32:40 <killerswan__> try also 2&>1 instead
22:33:17 <killerswan__> i can never remember all the obscure possibilities, though, for tcsh, etc.
22:34:31 <orifichu> killerswan__: with cabal install alex -v3 2&>1 file.txt               nothing happens
22:34:55 <dafis> orifichu: cat file.txt
22:34:55 <tgeeky> what options should I pass to cabal to try and build a packge with more performance? :o
22:35:01 <tgeeky> -o RTS or something like that?
22:35:07 <killerswan__> that would be what you want... if that creates a file.txt which contains both the errors and output
22:35:10 <tgeeky> regex-genex packag,e specifically, if it matters
22:35:38 <Eduard_Munteanu> orifichu: cabal install alex -v3 2>&1 >file.txt
22:35:53 <orifichu> dafis: nothing
22:36:00 <Eduard_Munteanu> "nothing happens" because you don't see the output
22:36:20 <Eduard_Munteanu> You could    tail -f file.txt   from another terminal to see what's going on.
22:37:10 <dafis> or cabal install alex -v3 2>&1 | tee file.txt
22:37:31 <orifichu> Eduard_Munteanu: yes...with that line the process works
22:37:32 <Eduard_Munteanu> Yeah, that should do better.
22:38:05 <orifichu> but the file.txt is too short
22:38:15 <orifichu> not like the log that i can see in the shell
22:38:16 <dafis> orifichu: ???
22:38:21 <killerswan__> in the version of Bash i have here, you'd want to use 2&>1
22:39:07 <killerswan__> orifichu: for example, for the nonexistant file "wtf":      ls wtf 2&>1 temp.txt
22:39:39 <killerswan__> orifichu: running that puts the error "...no such file..." into the file temp.txt
22:39:42 <dafis> that could of course be it, I can never remember the exact syntax, where the & goes
22:39:48 <hpaste> orifichu pasted “installing alex error” at http://hpaste.org/48832
22:40:01 <Eduard_Munteanu> killerswan__: is that bash?
22:40:07 <killerswan__> bash
22:40:20 <Eduard_Munteanu> You're sure it doesn't make a file named '1' in there?
22:40:47 <orifichu> dafis: that is the hpaste
22:41:07 <killerswan__> Eduard_Munteneanu: version 4.1.10 in Cygwin on Windows 7 (and it does have that 1 in there)
22:41:38 <killerswan__> Eduard_Munteanu: 2&>1
22:42:49 <Eduard_Munteanu> orifichu: looks like you're only getting stderr or something
22:43:02 <orifichu> i think that the file.txt content is too short.....in the shell i can see much more
22:43:07 <killerswan__> Eduard_Munteanu: wait, bah, you're right...
22:43:41 <dafis> orifichu: that doesn't show the error, unfortunately, try cabal install alex -v3 > file.txt
22:44:20 <killerswan__> Eduard_Munteanu: just &>
22:44:22 <orifichu> dafis: ok...trying
22:44:49 <killerswan__> Eduard_Munteanu: so run:  ls wtf &> temp.txt
22:45:20 <killerswan__> or in this case:    cabal install alex -v3 &> file.txt
22:45:40 <Eduard_Munteanu> Oops, I was wrong too.
22:45:57 <Eduard_Munteanu> Yeah 2>&1 works only with '|', not '>'
22:46:16 <orifichu> dafis: well, with that line the log is the same
22:46:33 <Eduard_Munteanu> (so only if you 'tee' or 'wgetpaste' directly)
22:46:44 <dafis> orifichu: then, we have now figured out, &> instead of >
22:47:34 <Eduard_Munteanu> Tee... 2>&1... hot!
22:47:36 <orifichu> Eduard_Munteanu: with | i get: -bash: file.txt: command not found
22:47:52 <Eduard_Munteanu> orifichu: that pipes output to another command, not to a file
22:48:06 <dafis> orifichu: with | you'd want | tee file.txt
22:49:14 <orifichu> dafis: hey! it works with &>........there is much more now
22:49:35 <dafis> orifichu: good, then paste
22:49:42 <hpaste> orifichu pasted “installing alex error” at http://hpaste.org/48833
22:49:59 <orifichu> dafis: there is it
22:50:30 <dafis> looking
22:54:07 <quicksilver> Eduard_Munteanu: 2>&1 works fine with >, you just need to do it first.
22:54:10 <Eduard_Munteanu> Looks to me like setup fails somewhat silently.
22:54:32 <quicksilver> Eduard_Munteanu: (compare the output of ls lkjh 2>&1 >/dev/null and ls lkjh >/dev/null 2>&1 )
22:54:41 <Eduard_Munteanu> quicksilver: oh, thanks.
22:55:15 <Eduard_Munteanu> Yeah, it makes sense because otherwise stderr keeps pointing to same stdout.
22:56:54 <killerswan__> also, if I remember right, there are differences between POSIX and Bash handling of these operators
22:57:26 <orifichu> so....nothing?
22:57:28 <killerswan__> and don't even start me on csh
22:57:46 <dafis> orifichu: strangely, it doesn't tell us what went wrong, nothing :(
22:58:01 * Eduard_Munteanu should try zsh sometime... though he longs for a usable Haskell(-like) shell :)
22:58:59 <orifichu> dafis: mmm....maybe with an anormal verbosity level.....v999999999 or something like that..jaja
22:59:11 <Eduard_Munteanu> dafis: maybe it's just Setup.hs exiting with a non-zero code (i.e. failing pretty much silently)?
22:59:17 * Eduard_Munteanu isn't a Cabal expert at all.
23:00:39 <orifichu> can i install alex without cabal? only with setup.hs?
23:01:09 <dafis> Eduard_Munteanu: yep, I'd think so, but I've no idea what could cause that
23:01:12 <killerswan__> Eduard_Munteanu: for little things, I've been quite happy playing with F# interactive for tasks I would have used Bash on otherwise
23:02:17 <killerswan__> Eduard_Munteanu: (though i'm not so happy with GHCi yet)
23:02:32 <dafis> orifichu: you can, unpack the tarball, in that directory: runghc ./Setup.lhs configure --prefix=wherever; runghc ./Setup.lhs build; runghc ./Setup.lhs install
23:02:32 <orifichu> mmm....well. many many thanks to all....i will googling
23:26:55 <sanjoyd> byorgey: I really liked the Typeclassopedia article.
23:27:03 <sanjoyd> Thanks for taking out time to write it.
