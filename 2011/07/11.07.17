00:44:13 <ivan> https://github.com/jschaf/shime ?
00:44:54 <ivan> oh, https://github.com/chrisdone/shime disappeared
00:46:32 <ivan> maybe https://github.com/chrisdone/haskell-emacs is a replacement
01:13:28 <norm2782> I'm trying to make cabal execute c2hs for me and compile & link my library with  a C library, but I'm getting an error: https://gist.github.com/1086661 . what am I doing wrong here?
01:17:15 <MatrixFrog> no idea but maybe ask the maintainer of hgit?
01:31:23 <_KY_> In lhs2tex, how can I put boxes around my code?
01:36:40 <kosmikus> _KY_: \framedhs
01:37:30 <gienah> norm2782: I'm not sure, maybe this blog article might help: http://blog.ezyang.com/2010/06/setting-up-cabal-the-ffi-and-c2hs/
01:38:54 <norm2782> gienah: thanks. I found that one, but so far it hasn't helped me a lot yet :)
01:39:27 <norm2782> I get the nagging feeling that it might be something OS X-specific as well
01:39:44 <_KY_> kosmikus great! thanks
01:39:49 <norm2782> Lion-specific maybe even
01:40:17 <norm2782> but I'm not experienced enough with packaging FFI projects to really tell
01:40:18 <gienah> norm2782: maybe looking at other c2hs projects might help, here's mine:  https://github.com/markwright/antlrc/blob/master/antlrc.cabal
01:40:28 <norm2782> ah great
01:40:31 <norm2782> I'll do that
01:45:16 <norm2782> gienah: hmm.. I can't find huge differences just yet.. if you have time, could you maybe give compiling my lib a go? https://github.com/norm2782/hgit2
01:45:48 <keep_learning> hello all
01:46:30 <keep_learning> i am trying to use GHC.Integer.GMP.Internals.gcdInteger# ( 1 )  ( 2)
01:47:07 <keep_learning> but it shows Not in scope: `#'
01:48:24 <Jafet> # is the GHC magic hash; see the GHC manual
01:48:36 <Jafet> You need MagicHash extension to use it.
01:49:08 <Jafet> Also, it probably won't work on 1, which is a boxed Integer
01:49:16 <yitz> keep_learning: why are you using internals? are you trying to hack GHC somehow?
01:49:37 <keep_learning> https://www.spoj.pl/problems/NDIVPHI2/
01:49:54 <Jafet> Heh
01:49:54 <keep_learning> yitz, and its getting time limit exceed
01:50:08 <Jafet> That means your algorithm sucks, improve it
01:50:12 <yitz> last i checked spoj used a very old GHC.
01:50:14 <copumpkin> yeah
01:50:21 <copumpkin> you should really be using low-level functions like that
01:50:46 <Jafet> The boxing for Integer, especially large Integers, has practically no effect on performance
01:51:15 <mauke> copumpkin: :-|
01:51:19 <keep_learning> Jafet, http://www.spoj.pl/problems/NDIVPHI/ this one accepted
01:51:23 <copumpkin> shouldn't, sorry
01:51:25 <copumpkin> it's 5am :)
01:51:46 <keep_learning> and hard one's algorithm is also same
01:51:47 <copumpkin> keep in mind that if you call gcdInteger# you'll have to think about S# and J#
01:51:57 <copumpkin> and you probably don't know how to construct a J#
01:52:15 <copumpkin> although I guess you can just pass it fromIntegral :)
01:52:18 <Jafet> So, what algorithm are you using for the problem?
01:52:57 <copumpkin> keep_learning: either way, gcdInteger# won't help you at all, as I'd imagine if there's a binding in the gmp GHC uses for it, then GHC already has a rewrite rule for it
01:53:02 <copumpkin> and you're thus already using it
01:53:12 <copumpkin> there are no "optional" gmp bindings in GHC right now
01:53:56 <yitz> generally the classic definition of gcd is very fast, i doubt that's your problem.
01:54:55 <Jafet> gmp leaves the classic definition in the dust
01:55:08 <keep_learning> Jafet,  take product of the primes and product of primes should not exceed N.
01:55:23 <keep_learning> Jafet, http://mukeshiiitm.wordpress.com/2011/06/17/spoj-6556-n-div-phi_n/
01:55:45 <gienah> norm2782: removing the space char in  -U__BLOCKS__ makes some difference
01:56:10 <yitz> Jafet: that makes no difference unless that is the bottleneck in his algorithm
01:56:29 <yitz> which i very much doubt
01:57:15 <yitz> the classic gcd leaves any prime factoring algorithm in the dust, for example.
01:57:30 <keep_learning> i saw the first comment by Michael T on spoj
01:57:32 <copumpkin> yeah, it's already using that function
01:57:41 <Jafet> Well, I wouldn't be surprised if copumpkin was right and Integer uses the gmp gcd
01:57:53 <keep_learning> and he says "Maybe haskell's gmp saves here."
01:57:56 <copumpkin> there's a rule "gcd/Integer->Integer->Integer" gcd = gcdInteger'
01:57:57 <Jafet> So yes, it won't be the bottleneck
01:58:12 <copumpkin> which then calls out to gcdInteger#
01:58:31 <copumpkin> and also has a special case for one or both operands being an Int
01:58:43 <copumpkin> (since gmp has a different function for that)
01:58:51 <yitz> again, even so, that's probably irrelevant. figure out where this algorithm spends its time.
01:58:55 <copumpkin> so basically, your algorithm is slow for other reasons :)
01:59:20 <keep_learning> copumpkin, yes , i think its multiplication
01:59:28 <norm2782> gienah: hah... nice one!
01:59:43 <norm2782> I would've never thought that to be the problem
02:00:33 <hpaste> gienah pasted “ norm2782: c2hs cabal tweaks” at http://hpaste.org/49124
02:00:51 <keep_learning> and for this problem we need only first six thousand primes
02:01:11 <keep_learning> i don't think it should  prime function
02:01:26 <norm2782> gienah: many thanks, it seems to compile just fine now :)
02:01:40 <gienah> norm2782: great, thanks
02:02:54 <copumpkin> keep_learning: multiplication?
02:03:22 <keep_learning> copumpkin, yes ,  i think so
02:03:34 <keep_learning> copumpkin, multiplying those 6000 primes
02:03:43 <keep_learning> for input 10^25000
02:03:50 <Jafet> > product [1..10000]
02:03:51 <lambdabot>   284625968091705451890641321211986889014805140170279923079417999427441134000...
02:04:05 <copumpkin> multiplication is comparatively trivial
02:04:14 <copumpkin> these problems aren't about micro optimizations, usually
02:04:18 <Jafet> Nope, multiplication goes through gmp (again)
02:04:29 <copumpkin> they're about coming up with an algorithm that is more clever
02:04:33 <copumpkin> than the obvious one
02:05:18 <copumpkin> > length . show . product $ [1.100000]
02:05:20 <lambdabot>   3
02:05:23 <copumpkin> :o
02:05:25 <copumpkin> :)
02:05:28 <keep_learning> show.length.product $  [1..8000]
02:05:46 <copumpkin> > show . product $ [1.100000]
02:05:48 <lambdabot>   "1.1"
02:05:54 <copumpkin> > length . show . product $ [1..100000]
02:05:56 <keep_learning> copumpkin, :)
02:05:59 <lambdabot>   mueval-core: Time limit exceeded
02:06:02 <Jafet> well, you can't multiply [1..100000] the obvious way
02:06:15 <copumpkin> > length . show . product $ [1..20000]
02:06:17 <Jafet> But you can do it with binary splitting for mueval
02:06:17 <lambdabot>   77338
02:06:39 <keep_learning> Jafet, i can but then i will again time out
02:07:20 <keep_learning> Jafet, i am thinking about the possibility of using gmp as per suggested by Micheal T comment on problem page
02:07:21 * copumpkin goes to sleep
02:07:28 <copumpkin> keep_learning: you are already using gmp
02:07:29 <Jafet> Integer already uses gmp.
02:07:42 <copumpkin> keep_learning: as I said, you won't get anywhere on these problems with that approach
02:07:49 <Jafet> Try listening to people here when they tell you stuff, keep_learning.
02:08:26 <keep_learning> Jafet, i do and if i offended any body then i am sorry .
02:09:06 <keep_learning> Jafet, i am just trying to learn Haskell and consider me as noob
02:09:07 <copumpkin> keep_learning: my point was that you are already using the highly optimized GMP algorithms in your program, because GHC uses GMP for you with Integer. If it's slow, it's because _your_ approach to the problem is wrong, not because your integers are slow
02:09:20 * Jafet now away, good luck
02:09:37 <keep_learning> copumpkin, thank you
02:09:38 <copumpkin> if I told you do add all the numbers from 1 to 100000000
02:09:52 <copumpkin> you could iterate over all the numbers and add
02:09:59 <copumpkin> or you can think about the problem for a bit
02:10:08 <copumpkin> and write a simple multiplication to get the answer
02:10:20 <copumpkin> one will take way longer than the other
02:10:37 <copumpkin> and yes, it's because it adds a lot, but the solution isn't to get a faster adding algorithm
02:10:45 <copumpkin> it's to avoid adding all the numbers up in the first place
02:11:23 <keep_learning> copumpkin, thank you for you valuable suggestion
02:11:44 <shachaf> copumpkin: Adding takes about 8 seconds here. If you don't already know what the simple multiplication is, thinking will probably take longer. :-)
02:13:16 <copumpkin> > [1..10000]
02:13:17 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
02:13:19 <copumpkin> > sum [1..10000]
02:13:20 <lambdabot>   50005000
02:13:25 <copumpkin> > > (1 + 10000) * 10000 `div` 2
02:13:26 <lambdabot>   <no location info>: parse error on input `>'
02:13:30 <copumpkin> > (1 + 10000) * 10000 `div` 2
02:13:31 <lambdabot>   50005000
02:13:41 <copumpkin> one of those will be a lot faster than the other
02:13:55 <copumpkin> especially when the problem later asks you to do [1..1000000000000000000000000000]
02:13:56 <copumpkin> :)
02:13:57 <shachaf> Sure, if you don't include the time to figure the latter one out.
02:14:03 <shachaf> And if you don't have that many zeros. :-)
02:14:31 <copumpkin> yeah, I hope you can figure out the solution before you iterate over that many zeros
02:15:04 <shachaf> λ> foldl' (+) 0 [1..10000] -- 50005000 -- (0.01 secs, 6311288 bytes)
02:15:19 <shachaf> λ> (10000+1)*10000 `div` 2 -- 50005000 -- (0.02 secs, 8116624 bytes)
02:15:28 <shachaf> Conclusive proof!
02:15:33 <copumpkin> indeed!
02:15:36 * copumpkin fails
02:15:41 * copumpkin goes to sleep
02:15:49 <shachaf> sleep++
02:19:03 <jpx> help
02:19:37 <shachaf> @where help
02:19:37 <lambdabot> Got the code? Got the info? Then we've got the help for you!
02:20:59 <marianna> Hi, I have sent a question to the haskell-cafe mailing list, but haven't received an answer: http://article.gmane.org/gmane.comp.lang.haskell.cafe/91080 Can someone help?
02:22:06 <yitz> shachaf: you're right. spoj doesn't time your brain though. so i suppose that is one way in which these problems are not realistic.
02:23:54 <yitz> marianna: ask that question on the ghc-users list.
02:24:18 <yitz> marianna: or even try #ghc, you might get an immediate response on that if the right people happen to be on the channel.
02:24:59 <marianna> yitz: okay, thank you!
02:25:26 <yitz> marianna: nothing wrong with asking it on the cafe. it's just that there is so much traffic there these days that busy people like the ghc core devs tend not to read it as often as they used to.
02:25:58 <marianna> yitz: okay, sure.
02:53:38 * hackagebot warp 0.4.2 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-0.4.2 (MichaelSnoyman)
03:05:27 <derdon> learnyouahaskell is fun to read :D
03:05:29 <derdon> "You can think of an I/O action as a box with little feet that will go out into the real world and do something there (like write some graffiti on a wall) and maybe bring back some data. "
03:06:03 <derdon> "In an imperative language, you have no guarantee that a simple function that should just crunch some numbers won't burn down your house, kidnap your dog and scratch your car with a potato while crunching those numbers."
03:06:36 <sanjoyd> TBH, you have not guarantee that putStrLn won't do those things either. :)
03:06:42 <sanjoyd> s/not/no/
03:07:39 <EEVIAC> well strictly the putStrLn function won't do those things
03:07:53 <EEVIAC> it's the IO action that the function returns that can do nasty stuff
03:08:02 <sanjoyd> EEVIAC: yes.
03:08:11 <shachaf> EEVIAC: sanjoyd didn't say "the putStrLn function". :-)
03:08:35 <EEVIAC> well true, but putStrLn is a function
03:08:57 <Jetbeard> isn't the point of the IO monad so that you can point to everything outside it and say "i know *this stuff* won't burn my house down"?
03:09:14 <dankna> technically it could.  pure computation still produces heat.
03:09:55 <Jetbeard> dankna: I run Haskell on my brain, I'd die before producing the kind of heat that could burn down my house
03:10:03 <dankna> fair enough
03:10:48 <shachaf> You run Haskell on your brain? That's computers are for.
03:11:01 <shachaf> s/'s/'s what/
03:11:28 <Jetbeard> shachaf: most of my functional programming course was proving stuff
03:11:37 <Jetbeard> ie. being a human reduction machine for Haskell :)
03:11:57 <shachaf> If computers can do it then they should do it.
03:12:59 <mauke> computers can connect to and talk on irc
03:13:14 <shachaf> mauke: Does preflex keep logs, by the way?
03:13:21 <mauke> no
03:13:26 <shachaf> preflex++
03:13:35 <Jetbeard> Can a Haskell implementation use automated proof techniques to improve the asymptotic complexity of your algorithms?
03:13:51 <mauke> @faq Can a Haskell implementation use automated proof techniques to improve the asymptotic complexity of your algorithms?
03:13:51 <lambdabot> The answer is: Yes! Haskell can do that.
03:14:00 <Jetbeard> I saw that coming :)
03:14:26 <Amadiro> Jetbeard, replacing an algorithm by a different one entirely is not really something a compiler should do, if that's what you mean.
03:14:34 <Jetbeard> @faq Can Haskell implement Maxwell's Demon?
03:14:35 <lambdabot> The answer is: Yes! Haskell can do that.
03:14:41 <shachaf> You should cut out the middleman and @faq it yourself.
03:14:43 <Saizan> for some loose enough sense of automated proof technique that's what an optimizing compiler does
03:15:08 <mauke> head . sort
03:15:15 <Amadiro> Since it breaks assumptions like the numerical stability of your algorithm and exact reproducibility of the results etc
03:15:17 <derdon> Jetbeard: does the bot always answer with "yes"?
03:15:27 <Saizan> also, GHC accepts arbitrary rewrite rules :)
03:15:32 <Jetbeard> @faq Can Haskell prove that P=NP?
03:15:32 <Amadiro> But yeah, sometimes the compiler can apply an optimisation that reduces the asymptotic complexity
03:15:33 <lambdabot> The answer is: Yes! Haskell can do that.
03:15:55 <Jetbeard> Amadiro: My point was simply that in my functional programming course there was a fair bit of taking O(n^2) algorithms and calculating that they're equal to O(n) algorithms
03:16:05 <derdon> @faq Can Haskell prove that it doesn't exist?
03:16:06 <knoc> @faq Can Haskell create black holes with impure functions?
03:16:06 <lambdabot> The answer is: Yes! Haskell can do that.
03:16:07 <lambdabot> The answer is: Yes! Haskell can do that.
03:16:23 <shachaf> knoc: That last one is actually quite correct.
03:16:30 <shachaf> GHC can even detect them.
03:16:41 <shachaf> > fix id
03:16:44 <lambdabot>   mueval-core: Time limit exceeded
03:16:45 <mauke> Jetbeard: solutions: P = 0, N = 1
03:16:46 <shachaf> Oh, well, it used to work.
03:16:56 <mauke> shachaf: yeah, like 5 years ago
03:17:24 <shachaf> mauke: I wasn't in this channel 5 years ago. :-)
03:17:28 <knoc> shachaf: Then it may better than the LHC
03:17:29 <knoc> ^^
03:17:48 <mauke> that was when lambdabot used ghc -O2 instead of ghci
03:17:56 <Amadiro> knoc, well, of course it is, after all G sorts before L.
03:21:23 <Jetbeard> Amadiro: my programming language, \0, is the best of all :)
03:21:42 <Amadiro> cool story, bro.
03:21:57 <mauke> did you mean: worst
03:22:05 <mauke> > "Haskell" > "\0"
03:22:06 <lambdabot>   True
03:22:30 <sanjoyd> How would you pronounce it?
03:22:32 <knoc> "GHC" > "THC"
03:22:33 <Jetbeard> > head ["\0","Haskell","C","Scheme"]
03:22:35 <lambdabot>   "\NUL"
03:22:37 <knoc> > "GHC" > "THC"
03:22:39 <lambdabot>   False
03:22:44 <Jetbeard> It's pronounced 'null', clearly :)
03:22:53 <sanjoyd> Then how do you pronounce "null"?
03:23:00 <Jetbeard> rhymes with "hull"
03:23:25 <Jetbeard> or "gull" or "mull" but not "bull" or "pull"
03:23:27 <mauke> preflex_: nick preflex
03:23:28 <merijn> Exactly like the word for zero in Dutch </unhelpful contribution>
03:23:43 <mauke> preflex: quote . einstein
03:23:45 <preflex>  <monochrom> einstein's theory implies that haskell cannot be faster than c
03:24:34 <shachaf> preflex: nick preflex_
03:24:37 <shachaf> :-(
03:25:06 <merijn> sanjoyd: Or http://translate.google.com/#en|nl|null and press "listen" on either side :p
03:25:15 <mauke> preflex: kick shachaf
03:25:40 <shachaf> preflex: be mauke
03:25:41 <preflex>  I'm going to write a lib33t.so just so you have to link with gcc -l33t
03:25:49 <shachaf> preflex: be shachaf
03:25:49 <preflex>  There was a study once where they gave one group real placebos and the other group fake placebos, and the effects were exactly the same.
03:25:54 <shachaf> Ugh.
03:26:05 <Jetbeard> @bf >+++++++++[<++++++++>-]<.>+++++++[<++++>-]<+.+++++++..+++.[-]>++++++++[<++++>-] <.>+++++++++++[<++++++++>-]<-.--------.+++.------.--------.[-]>++++++++[<++++>- ]<+.[-]++++++++++.
03:26:05 <lambdabot>   Hello world!
03:26:17 <Jetbeard> oh cool, haskellwiki wasn't lying :D
03:26:29 <merijn> lambdabot has a brainfuck interpreter? >.<
03:26:35 <Jetbeard> @bf +[>+]
03:26:37 <lambdabot>  Done.
03:26:53 <shachaf> @unlambda `.si
03:26:53 <lambdabot>   s
03:27:06 <sanjoyd> What is this preflex ?
03:27:18 <Jafet> preflex, help
03:27:19 <preflex>  try 'help help' or see 'list' for available commands
03:27:20 <shachaf> It's what came before flex.
03:36:01 <dibblego> where is Data.Time.Calendar.WeekDate in GHC7?
03:39:19 <shachaf> dibblego: I have it with GHC7.
03:40:06 <dibblego> oh er, I am a dick, sorry
03:44:02 <NihilistDandy> preflex: be NihilistDandy
03:44:03 <preflex>  no quotes found for NihilistDandy
03:44:10 <NihilistDandy> T_T
03:49:59 <ior3k> is there a function that transforms a single element into a list, or returns the element unchanged if it's a list already?
03:50:13 <shachaf> ior3k: What type would you want this function to have?
03:51:15 <ior3k> shachaf: well, I'm not sure, I suppose it would be a -> [a] or [a] -> [a] depending on the argument given
03:51:30 <dibblego> Either a [a] -> [a]
03:51:31 <merijn> ior3k: The only way that function could work would be with a type like "Either [a] a -> [a]" which you probably don't want
03:51:38 <shachaf> ior3k: Right, which is a pretty weird type.
03:51:46 <merijn> Because imo that type is awful
03:52:06 <shachaf> Since the type of the argument is already known at compile time, this sort of function is probably not as useful as you might imagine.
03:52:13 <merijn> ior3k: Context? i.e. what is your actual problem that requires this solution?
03:52:16 <shachaf> You can also use a type class. :-)
03:52:29 <mauke> shachaf: overlapping instances!
03:52:29 <merijn> Because there are probably better ways to solve this...
03:52:45 <shachaf> mauke: Absolutely.
03:52:56 <ior3k> I have a type A with 3 records, 2 of them single items, 1 a list
03:53:01 <ior3k> and I have a list of As
03:53:06 <mauke> what do you mean by "3 records"?
03:53:20 <merijn> mauke: "data Foo = Foo a a [a]", probably?
03:53:32 <dibblego> data A = A a a [a] -- I assume
03:53:44 <dibblego> data A a = A a a [a] -- I assume
03:53:55 <mauke> Aaaaa!
03:54:05 <ior3k> data Perspective = Perspective { tag :: WorkspaceId, layouts :: Maybe (Layout Window),  actions :: X () }
03:54:06 <NihilistDandy> I'll get all the A's out of my computer
03:54:12 <NihilistDandy> AAAAAAAAAAAAAAAAA
03:54:15 <yitz> perhaps data A = A1 a | A2 a | A3 [a]
03:54:22 <ior3k> oh, wait, wrong type, lol
03:54:38 <ior3k> data Group = Group { name :: Name , dir :: FilePath , perspectives :: [Perspective] }
03:54:47 <shachaf> data Data = Data Data Data Data [Data]
03:54:53 <mauke> deriving Data
03:54:57 <yitz> ok you were all right, i was wrong
03:55:03 <ior3k> then I have this function:
03:55:04 <ior3k> fromGroups :: (Group -> [a]) -> [Group] -> [a]
03:55:04 <ior3k> fromGroups f gs = foldl' (++) [] $ map f gs
03:55:22 <shachaf> Are type classes in the same namespaces as types?
03:55:26 <mauke> ior3k: did you mean: concatMap
03:55:36 <merijn> :t concatMap
03:55:37 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
03:55:51 <mauke> deriving Data.Data.Data
03:56:33 <ior3k> mauke: concatMap acts only on a list of lists, right? but in the case of name or dir, it's just a list of Strings
03:56:38 <ior3k> well, with are [Char]
03:56:42 <mauke> ior3k: what?
03:56:45 <ior3k> but I don't want to concatenate those
03:56:45 <thomas`> Hi, could someone help me troubleshoot some cabal/package dependency issues?  I'm trying to install wxCore, but keep getting an error on 'missing or recursive dependencies: process-1.0.1.5-...'
03:56:46 <NihilistDandy> forall Data Data. (Data -> [Data]) -> [Data] -> [Data]
03:57:11 <shachaf> NihilistDandy: If you break the rules of Haskell syntax then there's no point.
03:57:16 <ior3k> mauke: err, I'm lost, what's the "what" about?
03:57:17 <NihilistDandy> Fair
03:57:25 <NihilistDandy> I'll go sit in the corner
03:57:27 <mauke> ior3k: everything you said
03:57:27 <yitz> ior3k: a list of Groups is a list of lists
03:57:40 <mauke> ior3k: "concatMap acts only on a list of lists, right?" <- no
03:58:46 <yitz> mauke: true it acts on a list of things have a representation as a list
03:58:53 <ior3k> mauke: hmm, I'm not sure if I understand concatMap's description
03:59:00 <yitz> mauke: where i am using representation in the mathematical sense
03:59:15 <mauke> fromGroups :: (Group -> [a]) -> [Group] -> [a]
03:59:16 <mauke> concatMap  :: (a     -> [b]) -> [a]     -> [b]
03:59:54 <yitz> > let f x = [ x + 2, x * 7] in concatMap f [1..5]
03:59:55 <lambdabot>   [3,7,4,14,5,21,6,28,7,35]
04:00:50 <ior3k> ok, maybe I have to experiment a bit, I'm getting really confused :)
04:01:43 <merijn> ior3k: Write out type signature of fromGroups and concatMap on a paper, stare until enlightenment is reached :>
04:03:31 <ior3k> merijn: I understand that they're the same, or very similar, the thing is
04:03:54 <ior3k> if I used concatMap perspectives [g1, g2, g3] I'll get [[Perspective]]
04:04:05 <ior3k> err [Perspective]
04:04:25 <ior3k> but that won't work with say concatMap dir [g1, g2, g3]
04:04:30 <ior3k> because dir doesn't return a list
04:04:38 <mauke> so don't use concatMap for dir
04:05:40 <ior3k> well, I could use concatMap if I could write a function that always returns a list, i.e., converts a single element to a list, or returns a list unchanged
04:06:03 <mauke> no, you just have to wrap the result of dir in a list
04:06:10 <mauke> concatMap (return . dir)
04:06:29 <ior3k> whoa
04:06:45 <mauke> 'return' because I'm too lazy to type (: [])
04:06:53 <ior3k> isn't return a monad thing?
04:06:54 <shachaf> mauke: Or just to type "map"?
04:07:00 <mauke> <mauke> so don't use concatMap for dir
04:07:05 <shachaf> Oh.
04:07:07 <shachaf> Monad laws and all. :-)
04:07:32 <Saizan> use map instead
04:07:35 <Saizan> ?type map
04:07:36 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
04:07:44 <shachaf> @ty fmap
04:07:45 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:07:47 <ior3k> but won't this force me to write different functions depending on the type of the argument, which is what I'm trying to avoid?
04:07:49 <Saizan> > map (+1) [1..5]
04:07:50 <lambdabot>   [2,3,4,5,6]
04:07:57 <shachaf> > (+1) . [1..5]
04:07:59 <lambdabot>   [2,3,4,5,6]
04:08:15 * shachaf is still not sure what ior3k is trying to do.
04:08:31 <merijn> ior3k: Return is a monad thing yes, but lists are a monad
04:08:35 <merijn> :t return
04:08:36 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
04:08:37 <mauke> ior3k: why are you trying to avoid writing different code to do different things?
04:08:49 <merijn> > return 1 :: [Int]
04:08:50 <ior3k> let me explain
04:08:51 <lambdabot>   [1]
04:08:57 <merijn> > return [1..] :: [Int]
04:08:58 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
04:08:58 <lambdabot>         against inferred type ...
04:09:05 <merijn> hmm
04:09:23 <merijn> @hoogle m (m a) -> m a
04:09:25 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
04:09:25 <lambdabot> Prelude concat :: [[a]] -> [a]
04:09:25 <lambdabot> Data.List concat :: [[a]] -> [a]
04:09:40 <knoc> Is there some haskell function to compute: f (635) = 6 + 3 + 5 = 14 ?
04:09:49 <ior3k> I'd like the fromGroups function to always return a list of things related to a group, as a flat list
04:10:06 <mauke> > sum . map digitToInt . show $ 635
04:10:08 <lambdabot>   14
04:10:09 <aninhumer> shachaf: how does (+1) . [1..5] work?
04:10:11 <merijn> knoc: I'd probably convert 635 to string, then convert the Char's back to ints
04:10:19 <shachaf> > sum . map digitToInt . show $ 635
04:10:21 <lambdabot>   14
04:10:32 <shachaf> aninhumer: lambdabot has (.) = fmap
04:10:33 <mauke> ior3k: why?
04:10:53 <knoc> yeah, I had problems with digitToInt, thanks all
04:11:08 <shachaf> knoc: Is this for Project Euler?
04:11:21 <knoc> shachaf: Yes, problem 8
04:11:28 * shachaf knew it.
04:11:33 <shachaf> Evil.
04:11:34 <merijn> knoc: Which problem? You didn't know it existed? :>
04:12:19 <ior3k> mauke: err, I'm utterly confused now, I'm going back to the drawing board :)
04:12:27 <knoc> I did know it, but I forgot digitToInt and was trying to solve that with a mix of show and read and so on
04:12:43 <knoc> the problem was me forgetting digitToInt^^
04:12:57 <shachaf> No, you should be able to do it with a mix of show and read.
04:13:19 <mauke> > sum . map (read . return) . show $ 635
04:13:21 <lambdabot>   14
04:14:18 <mauke> > sum $ read . return . show 635
04:14:20 <lambdabot>   14
04:14:53 <knoc> mauke: Why do use return? I do not see the point in using it
04:15:08 <mauke> 'return' because I'm too lazy to type (: [])
04:15:33 <knoc> ahh, that transforms each char into a string?
04:18:37 <shachaf> > fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap (fmap fmap fmap) fmap fmap sum (fmap fmap fmap fmap fmap read) return show $ 635
04:18:39 <lambdabot>   14
04:18:52 * shachaf doesn't feel like doing the rest of it.
04:19:11 <mauke> needs more (.)
04:19:50 <dankna> ....... wtf
04:20:01 <mauke> @unpl fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap (fmap fmap fmap) fmap fmap sum (fmap fmap fmap fmap fmap read) return show $ 635
04:20:01 <lambdabot> (fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap (fmap fmap fmap) fmap fmap sum (fmap fmap fmap fmap fmap read) return show 635)
04:20:03 <knoc> that looks interesting, but I do not know fmap^^ have to read on
04:20:21 <shachaf> GHC is getting slow.
04:22:05 <shachaf> Is there a program like @pl that does this automatically?
04:23:40 <gienah> http://hackage.haskell.org/package/pointful
04:23:48 <Botje> don't fmap so much, you'll go blind.
04:23:50 <knoc> now I have
04:23:52 <knoc> sum $ map (\x -> read x :: Integer)  . map (:[]) $ show 635
04:24:14 <shachaf> Wait, this doesn't terminate!
04:24:17 * shachaf has been taken in!
04:24:48 <gienah> http://hackage.haskell.org/package/pointfree
04:25:19 <merijn> Personally I think "map digitToInt" is much better
04:25:31 <mauke> knoc: why so complicated?
04:25:48 <knoc> merijn: I wanted to code it without digitToInt
04:25:53 <mauke> knoc: (\x -> read x) == read
04:26:08 <mauke> knoc: map read . map (: []) == map (read . (: []))
04:26:27 <shachaf> fmap (fmap fmap fmap fmap) fmap fmap fmap fmap === fmap (fmap fmap fmap fmap) ?
04:26:47 <shachaf> @ty fmap (fmap fmap fmap fmap)
04:26:48 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *) (f3 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3) => f3 (f (f1 (a -> b))) -> f3 (f (f1 (f2 a -> f2 b)))
04:26:50 <shachaf> @ty fmap (fmap fmap fmap fmap) fmap fmap fmap fmap
04:26:51 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b (f3 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3) => f (f1 (f2 (a -> b))) -> f (f1 (f2 (f3 a -> f3 b)))
04:27:18 <knoc> mauke: that looks good^^
04:27:33 <shachaf> :-(
04:29:26 <knoc> shachaf: what did you mean with "doesn't terminate"?
04:29:56 <shachaf> The process of adding fmaps.
04:30:30 <mauke> EnterpriseFmapFactory
04:31:04 <knoc> ok^^
04:31:45 <shachaf> fmap (fmap fmap fmap) === fmap fmap fmap fmap fmap fmap fmap
04:33:31 <mauke> fmap (fmap fmap) (fmap fmap) wait
04:35:17 <mauke> hah, it follows atomically if you take the right path
04:35:30 <shachaf> mauke: ?
04:37:06 <mauke> shachaf: fmap₁ (fmap₂ fmap₃ fmap₄) = (.:) fmap₁ fmap₂ fmap₃ fmap₄ with (.:) = fmap fmap fmap
04:38:15 <shachaf> Oh.
04:38:19 <CindyLinz> sooooo many fmap!
04:38:48 <shachaf> Hmm, if you introduce a (.::) primitive, would there still be non-terminating cases?
04:38:51 <shachaf> I assume so.
04:45:54 <opensourcegeek> hey guys
04:46:14 <opensourcegeek> im just checking if this works
04:46:26 <azaq23> IRC does in fact work
04:47:00 <yitz> @type fmap fmap fmap fmap fmap fmap
04:47:01 <lambdabot> forall a (f :: * -> *) a1 b (f1 :: * -> *). (Functor f, Functor f1) => (a -> a1 -> b) -> f a -> f (f1 a1 -> f1 b)
04:47:03 <opensourcegeek> true wrote a client - checking it
04:47:09 <yitz> @type fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
04:47:10 <lambdabot> forall a b (f :: * -> *) a1 (f1 :: * -> *). (Functor f1, Functor f) => (a1 -> a -> b) -> f1 a1 -> f1 (f a -> f b)
04:47:43 <yitz> so fmap fmap fmap fmap fmap fmap == fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
04:47:47 <shachaf> Oh. :-(
04:48:51 <shachaf> > fmap fmap fmap fmap fmap fmap fmap fmap fmap (fmap fmap fmap) fmap fmap sum (fmap fmap fmap fmap fmap read) return show $ 635
04:48:53 <lambdabot>   14
05:02:07 <PatrickRobotham> oh god it's horrible
05:07:14 <PatrickRobotham> shachaf: do you really understand what that's doing?
05:08:30 <shachaf> PatrickRobotham: Sure, it's doing sum . map (read . return) . show $ 635
05:09:21 <PatrickRobotham> ok
05:19:07 <progrock> I'm trying to upgrade cabal on a clean ubuntu 11.04 install.   I'm geting: cabal-install-0.10.2 depends on zlib-0.5.3.1 which failed to install.
05:19:23 <progrock> anyone know what packae I need, i cant seem to find a zib package that'll fix his
05:19:50 <shachaf> Probably a package called zlib or libzlib or something in your package manager?
05:20:06 <progrock> yeah, i was looking for anything along those lines
05:22:00 <progrock> think I got it.. I had zib1g, think I needed zlib1g-dev
05:25:28 <NihilistDandy> What's the error during the zlib build say, anyway?
05:27:12 <progrock> that was the error
05:27:54 <progrock> oh mna, missing quite a few things for hakyll
05:28:20 <progrock> would think cabal woul get the dependencies fr you
05:28:29 <NihilistDandy> It does
05:28:33 <monadic> Eh it just needs the header files
05:28:47 <monadic> any binding to a C library will need the -dev package if the package manager stupidly splits up the build like that ;)
05:29:21 <progrock> http://pastebin.com/B7zPe12U
05:29:24 <mauke> The paste B7zPe12U has been copied to http://hpaste.org/49126
05:29:29 <progrock> do I just go 1 by 1 and seach myapt for them?
05:29:41 <monadic> Anyway cabal can't get dependencies that aren't haskell like the C library itself
05:30:30 <progrock> gotcha
05:30:46 <monadic> progrock: I don't have cabal on this system, but I think running it with -v and installing texmath should give you the exact error.
05:31:06 <monadic> Considering its name, I would assume you need some tex-related library/headers or just tex itself
05:31:11 <progrock> can't wait to get hakyll up and running.... gonna be sooo fast if 99% f the content of my sites are on a CDN
05:31:56 <monadic> For hopensssl try openssl-dev
05:32:17 <monadic> regex-pcre is going to need pcre-dev (note that my package names might be off, I'm not an ubuntu user)
05:38:07 <progrock> man I installed pandoc and texmath and still seeing errors for them
05:38:30 <NihilistDandy> What are the errors?
05:40:58 <progrock> pretty much the same: http://pastebin.com/myAr5n52
05:41:01 <mauke> The paste myAr5n52 has been copied to http://hpaste.org/49127
05:42:06 <NihilistDandy> Those aren't the errors
05:42:16 <NihilistDandy> Those are notifications of build failure
05:42:57 <progrock> well arent the errors taht they neded libraries are not installed?
05:43:10 <NihilistDandy> Not necessarily
05:43:17 <NihilistDandy> The errors could be all kinds of things
05:44:47 <progrock> 1 sec ill post the whle thing
05:45:29 <augur> anyone know of syntax highlighters that output html?
05:47:10 <progrock> http://pastebin.com/rs8vmZFr
05:47:15 <mauke> The paste rs8vmZFr has been copied to http://hpaste.org/49128
05:47:20 <progrock> augur: hakyll has one
05:48:00 <augur> hmm
05:49:38 <augur> oh! pastebin does what i need
05:49:39 <augur> hooray
05:51:34 <Twey> augur, progrock: Hakyll uses highlighting-kate
05:51:42 <romanmue> regex-pcre is missing?
05:52:01 <romanmue> You probably have to install libpcre3-dev.
05:53:36 <romanmue> (perl compatible regular expressions)
06:01:15 <progrock> man, I keep installing the packages I'd pretty much be betting are the ones I need, but still getiing mos =t o thhe same errors
06:03:49 <HugoDaniel> hi
06:03:55 <HugoDaniel> is there any website with haskell exercises ?
06:03:59 <Saizan> progrock: you need libssl-dev for the evp.h header
06:04:10 <Saizan> http://packages.debian.org/cgi-bin/search_contents.pl?word=evp.h&searchmode=searchfiles&case=insensitive&version=stable&arch=i386
06:05:22 <NihilistDandy> HugoDaniel: tryhaskell.com
06:05:29 <progrock> ok, but, texmath is killing me, i tought i got the riht thing: libghc6-texmath-dev
06:05:32 <NihilistDandy> er tryhaskell.org
06:06:51 <HugoDaniel> oh
06:06:55 <HugoDaniel> those are too basic :/
06:07:07 <HugoDaniel> i need something for the elite guys who never coded haskell
06:07:41 <NihilistDandy> RWH?
06:07:46 <NihilistDandy> The book's online
06:08:08 <NihilistDandy> Or just do Project Euler back to front
06:08:22 <Saizan> progrock: it's not the right version, probably
06:08:55 <Saizan> progrock: also, your problem with building texmath is that ld needs more memory, you could enable swap maybe
06:09:10 <progrock> Saizan: that sucks :( would think using the newest ubuntu woudl give you new enogh braries
06:09:40 <Saizan> nah, ubuntu is always quite behind
06:09:57 <progrock> Saizan: whre do you see that? I could jsut upgarde the memory on he server temporaily
06:10:46 <Saizan> progrock: it's a guess, but ld tends to be quite memory hungry when linking stuff produced by ghc
06:11:06 <Saizan> progrock: gold is better at this
06:11:17 <HugoDaniel> i like yaht
06:11:23 <progrock> hmmm, you may be right with the version at keast
06:12:06 <yitz> HugoDaniel: http://www.itasoftware.com/careers/work-at-ita/hiring-puzzles.html
06:12:09 <yitz> and http://www.itasoftware.com/careers/puzzle_archive.html
06:12:23 <yitz> HugoDaniel: get 'em fast, before Google changes the site :)
06:12:25 <Saizan> btw, hakyll is the sort of thing you don't need on the server, afaiu
06:13:19 <yitz> HugoDaniel: the archive is better; some of the "current" ones are specifically for Java.
06:13:29 <progrock> Saizan: well theres reasons for me having it on the server
06:13:46 <yitz> HugoDaniel: the archive puzzles were designed with Common Lisp in mind
06:14:00 <HugoDaniel> :D
06:14:03 <progrock> Saizan: its gotta communicate with mongo and the other end points I need
06:14:28 <progrock> whats weird is, I installed hakyll a few times 2 weeks ago without a problem
06:20:20 <Shammah> hey, why is it possible to do something like (+) 4 5 but not (<-) name getLine?
06:20:33 <shachaf> Shammah: <- isn't an operator, it's syntax.
06:20:38 <Shammah> oh
06:20:51 <shachaf> do { x <- y; ... } translates to y >>= (\x -> do { ... }), more or less.
06:21:04 <Shammah> oh okay, thought it was an operator
06:21:05 <Shammah> thanks
06:28:08 <progrock> of couse hakl installed locally no problem
06:28:08 <progrock> hakyll*
06:35:54 <drbean> How do I change the length of .ghc/ghci_history from the default 100 lines?
06:36:43 <drbean> There appears to have been System.Console.Editline.Readline.stifleHistory.
06:37:01 <shachaf> drbean: Do you want it to be 0?
06:37:10 <shachaf> If so, ln -s /dev/null ~/.ghc/ghci_history
06:37:17 <drbean> No, I want it to be 50000
06:37:23 * wli tries to figure out how to get haddock to do something useful on multiple LaTeX-style literate Haskell source files.
06:37:30 <Saizan> drbean: http://trac.haskell.org/haskeline/wiki/UserPrefs
06:37:49 <Saizan> unless you are using an ancient ghci without haskeline
06:38:21 <Saizan> wli: if you have a cabal project you can call cabal haddock
06:41:02 <wli> Saizan: Looking into it.
06:43:11 <wli> Saizan: The implication here is that cabal figures out how to generate haddock from just about anything?
06:43:57 <Saizan> wli: you still need to use haddock formatting in the files
06:44:09 <wli> Saizan: Of course, yes.
06:44:56 <wli> Saizan: It's a bit awkward but I've figured out how to get it past literate Haskell preprocessing.
06:45:35 <wli> i.e. %if False %endif around a literate Haskell code block containing nothing but the pertinent comment.
06:46:11 <Saizan> yeah, cabal also expects the haddock comments in code blocks
06:50:23 <progrock> of course cabal install texmath   jsut freezes up
07:10:41 <augur> are type and newtype declarations potentially polymorphic?
07:10:50 <augur> eg type List a = [a] ??
07:14:53 <]OLI[> yep
07:34:37 <progrock> man, i wish I knew why I wa shaving trouble geting hakll installde on my VPSes but locally on the sam OS it installe dno problem
07:46:07 <progrock> damn it, texmath freezes on liek the laast step up installing
07:57:47 <progrock> Gotta love 'cloud' VPS providers (as far as I can tell at this point, Cloud now usually refers to a 'automatic setup', an usually horly/daily billing)
07:57:50 <progrock> I love buzz words
07:58:21 <progrock> but cloud vps providers are awesome... soo convenient to set up, duplicate, fuck aound, whatever you wanna do for ver litle mone
07:58:37 <monadic> Cloud means everything now
07:58:48 <progrock> Oh, I know
07:58:58 <monadic> My operating system is a cloud now probably
07:59:03 <progrock> anything from Grid, to jsu a fucking normal VPS
07:59:11 <progrock> hahahaha
07:59:30 <monadic> I mean, the kernel provides services to the userspace applications
08:00:16 <progrock> well I thought cloud was iniitially somethign similar to a grid...but now its almost the inverse if that
08:00:26 <monadic> weren't you having problems with texmath or something?
08:01:14 <progrock> like instead of a super computer (grid) built from lots of omputers connected... its ike 1/100th of a computer (VPS)... thenb it's "Cloud" if setting up doesnt require human inervention, lol
08:01:28 <progrock> haha, yeah, still am, really odd
08:01:37 <monadic> Any error messages?
08:01:38 <cmccann> #haskell is a cloud-based Haskell debugging provider
08:03:08 <progrock> 1 sec
08:03:08 <Twey> I'm a cloud
08:03:18 <progrock> my pee turns into clouds
08:07:18 <tomh> anyone here knows what is meant with "parameterized over" ?
08:07:35 <tomh> that something has a parameter?
08:07:40 <ash__> is there any library that uses ATLAS, LAPACK or Accelerate?
08:08:13 <cmccann> ash__, hmatrix?
08:08:20 <progrock> monadic: heres the hakyll error, 1 sec will post the texmath only in a sec: http://pastebin.com/qdZcFKZT
08:08:27 <mauke> The paste qdZcFKZT has been copied to http://hpaste.org/49133
08:08:28 <cmccann> ash__, it says "internally implemented using GSL, BLAS and LAPACK"
08:08:43 <ash__> cmccann: thanks, i didn't see that one when I was searching earlier
08:09:05 <ash__> i have a python program thats faster than my haskell version, i think its because of numpy, pretty sure its because of numpy
08:09:16 <cmccann> probably, yes
08:10:31 <ash__> numpy's pretty amazing, and has so many nice easy features right there for you to work with, i'll see how hmatrix is, hopefully its picked up a few tricks from numpy and matlab :P
08:10:39 <cmccann> naive pure haskell will be faster than naive pure python in most cases, and very clever haskell can approach the performance of C, but python using highly-optimized C libraries is potentially going to be faster than the sort of haskell you'd actually want to write
08:11:01 <cmccann> ash__, I think it's mostly a wrapper around the libraries mentioned but I'm not sure
08:11:15 <cmccann> there's probably nicer stuff out there, that's just the one I was aware of
08:11:48 <cheater_> cmccann, you're totally forgetting about PyPy
08:12:03 <monadic> you need pcre and openssl
08:12:38 <cmccann> cheater_, yeah, was assuming CPython there, sorry
08:12:55 <ash__> scipy & numpy & matplotlib's goal is basically to do everything matlab does but have a simple to use interface, its really nice the amount of stuff they simplify, its one of the reasons I always fall back to python for most my work, although haskell is giving it a run for its money these days
08:13:04 <cmccann> cheater_, in fact, read "haskell" as "GHC" there as well :P
08:14:18 <progrock> monadic: texmath just sits at thsi forever: http://pastebin.com/hKp6pXUi
08:14:25 <mauke> The paste hKp6pXUi has been copied to http://hpaste.org/49134
08:14:36 <risrr> can someone explain to me why `evalStateT (forever $ modify (+1)) 0` will spiral memory out of control and never clean up old states?
08:14:46 <monadic> forever linking? Maybe its just slow... check your cpu usage
08:16:26 <shachaf> XMonad.Hooks.DynamicLog has a type error!
08:16:37 <shachaf> Which isn't caught because of the use of type synonyms. :-(
08:17:03 <cheater_> ash__, have you seen wolfgang lambda?
08:17:18 <ash__> no...? i am not sure what that is
08:17:20 <kamaji> Why is the sum of Ai*Bi smallest when the smallest As are multiplied with the largest Bs?
08:17:28 <kamaji> or vice versa
08:17:29 <cheater_> it's mathematica in haskell
08:17:34 <Cale> risrr: There are a couple problems with that. One is that you're constructing an expression whose size is linear in the time the program is allowed to run
08:17:53 <cheater_> ah shit it's down:
08:17:54 <cheater_> http://jabberwock.xs4all.nl/exp/wolfgang/
08:17:58 <cheater_> it's VERY well made though
08:18:03 <Cale> (and which looks like  ((...((0+1)+1)...)+1)
08:18:19 <cheater_> luite, plz2fixlambda
08:18:21 <ash__> cheater_: is it on hackage? or..?
08:18:26 <risrr> cale: sorry, forgot to mention that i'm using the strict state monad
08:18:39 <cheater_> ash__, no it's on that link i gave you, except now it's just replaced with a message it's down for rebuilding
08:18:41 <Cale> even if you're using the strict state monad, you're still building that expression
08:19:01 <risrr> is there a way to force it to just do the iteration and no build the expression?
08:19:09 <Cale> yep
08:19:11 <monadic> risrr: seq
08:19:29 <progrock> monadic: CPU is arely being used at all
08:19:33 <risrr> awesome
08:19:37 <risrr> i'll go take a look
08:19:39 <monadic> progrock: Odd
08:19:39 <risrr> thanks
08:19:44 <Saizan> progrock: it's probably swapping a lot
08:20:00 <progrock> ohhh
08:20:00 <Cale> You want to force the evaluation of the state
08:20:02 <progrock> yeah'
08:20:07 <Cale> using seq or $!
08:20:09 <progrock> you are right
08:20:28 <risrr> i guess im not sure how to force the state for something simple like the example i gave
08:20:29 <Cale> evalStateT (forever $ do x <- get; x `seq` put (x+1)) 0
08:20:33 <Cale> something like that
08:20:37 <risrr> ah
08:20:41 <risrr> awesome
08:20:48 <Cale> Or
08:20:56 <Cale> evalStateT (forever $ do x <- get; put $! x+1) 0
08:21:03 <risrr> ok, i see
08:21:07 <progrock> so.. am I not gonna e able to run on 256mb of ram?.... I guess I can temporarily boost it p, but I wouldnt want to do that all the time
08:21:08 <risrr> and understand now
08:21:22 <risrr> i thought using the strict state monad just did that for me implicitly
08:21:54 <Cale> nope, the strictness/laziness has to do with how the (result,state) pairs get bound
08:22:01 <Cale> inside the definition of >>=
08:22:06 <ash__> how does forever know when to exit?
08:22:14 <Cale> It doesn't exit.
08:22:17 <ash__> ah
08:22:28 <ash__> is there a way to get it to exit?
08:22:28 <Cale> forever x = x >> forever x
08:22:37 <risrr> was just as simple an example as i could make :)
08:22:46 <Cale> Using Cont/ContT, you can call the continuation
08:23:17 <Cale> callCC $ \ret -> forever $ do ... ret x ...
08:23:32 <Saizan> progrock: depends on how often you have to link, i guess :)
08:23:34 <Cale> Will behave like "return" from most imperative languages.
08:24:26 <Cale> You can also just use a different looping function
08:24:30 <shachaf> Isn't http://www.haskell.org/haskellwiki/New_monads/MonadExit simpler?
08:24:34 <Cale> which does something to evaluate a condition
08:25:07 <Cale> shachaf: I dunno, I guess.
08:25:35 <ash__> hmatrix is exactly what I was looking for, thanks cheater_
08:25:54 <cheater_> ash__, never heard of hmatrix
08:26:01 <cheater_> :)
08:26:23 <Cale> shachaf: The fact that there are data constructors everywhere will probably make it harder for GHC to optimise, if you care about that.
08:26:26 <ash__> oh, oops cmccann was the one that suggest it, sorry
08:26:36 <cmccann> heh
08:26:45 <ash__> i apparently have the memory of a goldfish its been to long
08:26:49 <Cale> Err...
08:26:51 <ash__> and scrolling up is hard
08:26:58 <shachaf> Cale: Bah. It seems nicer, if you only need to exit once.
08:26:59 <Cale> Oh, there's also a functional dependency here
08:27:02 <cmccann> ash__, anyway, you're welcome, have fun with it
08:27:10 <Cale> You can have only one exit type per monad
08:27:10 <shachaf> I guess there's always Cont.
08:27:24 <Cale> and you need to encode that type with an instance
08:27:30 <shachaf> Oh.
08:27:39 <Cale> Er, I guess you'd be using ExitT anyway
08:27:47 <shachaf> Ah, right, I see.
08:28:18 <luite> cheater_: working on it ;p but it's juist a user interface :
08:28:27 <Saizan> abort x = Cont (\ _ -> x)
08:28:41 <luite> cheater_: working on it ;p but it's juist a user interface, other people need to write the libraries
08:28:59 <Cale> error "Exit monad did not exit."   （╯°□°）╯︵ ┻━┻
08:29:00 <luite> whoops
08:30:04 <cheater_> luite, NOT FAST ENOUGH
08:30:09 <cheater_> :p
08:31:07 <kmc> a nice simple way to do loops is:  fix $ \again -> do ... when (whatever) again ...
08:31:18 <monadic> if its something more complex you might need deepseq, although if it is more complex it might be beneficial to leave it lazy. I would benchmark that case
08:31:35 <monadic> if its something more complex you might need deepseq, although if it is more complex it might be beneficial to leave it lazy. I would benchmark that case
08:31:43 <monadic> oh i was scrolled up ^_^
08:31:51 <kmc> deepseq is a brute force solution
08:32:13 <monadic> useful if you have a tuple or simple ADT
08:32:13 <Cale> Yeah, you almost never need deepseq
08:32:25 <Cale> you just need a seq placed at the right point
08:32:32 <kmc> or a strict data type
08:32:41 <Cale> Or a strict data type, yeah
08:33:01 <hpc> or a better algorithm
08:33:07 <hpc> :P
08:33:12 <kmc> or more RAM
08:33:20 <kmc> ;P ;P
08:33:27 <sanjoyd> @src deepseq
08:33:28 <lambdabot> Source not found. That's something I cannot allow to happen.
08:33:40 <monadic> I disagree with that one unless you really _do_ need a better algorithm. Recursion can't really be avoided if you need to iterate...
08:33:41 <hpc> deepseq is a class method, iirc
08:33:49 * sanjoyd hoogles.
08:33:50 <monadic> hpc: No, thats rnf
08:33:59 <hpc> :t deepseq
08:34:00 <lambdabot> Not in scope: `deepseq'
08:34:09 <parcs> @src NFData
08:34:10 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
08:34:13 <monadic> :t Control.Deepseq.deepseq
08:34:14 <lambdabot> Couldn't find qualified module.
08:34:28 <monadic> :t Control.DeepSeq.deepseq
08:34:29 <lambdabot> forall a b. (Control.DeepSeq.NFData a) => a -> b -> b
08:34:38 <hpc> deepseq a b = rnf a `seq` b
08:39:44 <cmccann> Cale, that table flipping emoticon is a work of art
08:40:08 <kmc> now i get
08:50:11 <monochrom> ♥ haskell
08:54:43 <monochrom> @botsnack
08:54:44 <lambdabot> :)
09:09:51 <bobzhang> hi, i have a  strange type error for parsec3. :t try
09:09:51 <bobzhang> try :: forall tok st a. GenParser tok st a -> GenParser tok st a
09:09:52 <bobzhang> :t try . string
09:09:53 <bobzhang> try . string :: forall st. String -> GenParser Char st String
09:09:54 <lambdabot> Not in scope: `try'
09:09:54 <lambdabot> Not in scope: `string'
09:10:10 <wavewave> hi
09:10:29 <wavewave> is there any good tutorial for plugins package?
09:11:26 <bobzhang> why the type of (try . string ) in parsec3 becomes : forall st. string -> GenParser Char st String?
09:11:39 <bobzhang> I guess the source should not be Char, right?
09:11:54 <wavewave> Formerly known as hs-plugins
09:12:14 <clsmith> @hoogle Monad m => (a -> m a) -> a -> m ()
09:12:14 <lambdabot> Data.Foldable mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
09:12:14 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
09:12:14 <lambdabot> Control.Monad mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
09:12:51 <clsmith> is anything like "bindForever f x = f x >>= bindForever f
09:12:56 <clsmith> " already defined somewhere?
09:13:15 <shachaf> I don't think so.
09:13:28 <dmwit> bobzhang: I don't understand the question. What did you expect the type to be?
09:13:39 <parcs> @type mfix
09:13:41 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
09:13:46 <clsmith> okay, i guess i'll just define it myself
09:14:08 <shachaf> clsmith: It has a more general type than what you searched for, though. :-)
09:14:59 <clsmith> shachaf: oh? oh i guess it could be 'm b' instead of 'm ()'
09:15:11 <clsmith> but .. that would never actually happen
09:15:14 <bobzhang> dmwit: I think the type should be general, like Stream s m Char => String -> ParsecT s u m String
09:17:15 <bobzhang> dmwit: oh, i see, the "try" is not general, is ther general try in parsec3?
09:18:04 <dmwit> bobzhang: "try" looks general to me, so I now understand your question.
09:18:18 <dmwit> Have you turned the monomorphism restriction off?
09:19:08 <bobzhang> i see :t Text.Parsec.Prim.try . string is right
09:19:14 <dmwit> Prelude Text.Parsec> :t try . string
09:19:14 <dmwit> try . string :: (Stream s m Char) => String -> ParsecT s u m String
09:19:21 <dmwit> Yep.
09:19:45 <bobzhang> :t Text.ParseCombinators.Parsec.Prim.try . string is not general
09:19:46 <lambdabot> Couldn't find qualified module.
09:20:00 <dmwit> ah
09:21:02 <bobzhang> they are the same "try", but the latter is qualified, why??
09:23:44 <dmwit> bobzhang: They are not the same try.
09:25:25 <monochrom> programming lesson 000: names don't mean anything
09:26:10 <Saizan> monochrom++
09:27:29 <monochrom> it is mathematics lesson 000 too. example: "natural number" and "natural transformation" are unrelated. typical beginner misguided question "how is 'natural' defined in mathematics?"
09:27:40 <wli> monochrom: They mean a lot. Self-documentation.
09:28:01 <bobzhang> dmwit: you can read the source code, the are indeed
09:28:17 <bobzhang> try :: GenParser tok st a -> GenParser tok st a
09:28:23 <wli> If names meant nothing, no on would bother with programming languages.
09:28:38 <monochrom> yeah, "self-documentation" like calling a million different things "try" and another million different things "lift" and another thousand different things "natural". great documentation, yeah
09:28:49 <hvr> monochrom: ...but it doesn't harm to try to find good names for symbols though... ;)
09:29:49 <monochrom> if you are the only programmer in the whole world, you assign your favourite meaning to names, they are meaningful *to only you*
09:30:25 <dmwit> bobzhang: They may have the same source, but they have different types. =P
09:30:57 <monochrom> if you and a few friends are the only programmers in the whole world and the gang of you work tightly together, you guys reach a consensus on mapping meanings to names, and they are meaningful *to only your gang*
09:31:16 <dmwit> monochrom: I thought "natural" actually does end up being given a meaning in category theory?
09:31:18 <monochrom> but even then within your group you already keep debating how to do that map
09:32:30 <monochrom> but now in practice there are many disparate groups programming, each thinking it has the best idea of how to map meanings to names, and they don't even convene to reach any consensus. in this way, names have lost meanings
09:32:46 <monochrom> if there is no consensus, there is no meaning
09:33:28 <hvr> monochrom: ...you make it sound as if we couldn't have ever found a consensus on our natural language 'english'...
09:33:47 <clsmith> @pl bindForever f x = f x >>= bindForever f
09:33:47 <lambdabot> bindForever = fix (liftM2 flip ((>>=) .))
09:34:13 <monochrom> "meaningful names" is not self-documentation. it's self-congratulating-documentation. an independent individual may come along anyday finding that your choice of names or your choice of meanings is unhelpful
09:35:29 <monochrom> have we even found a consensus on the english word "god"?
09:36:11 * wli goes about arranging for LaTeX-style literate Haskell with glossary, index, and bibliography, and also haddock.
09:37:12 * wli will have to hit up people on other channels for diagramming/etc. for the LaTeX doc to be generated from the literate Haskell.
09:37:23 <Rotaerk> monochrom, the names should be self-documenting as long as the one reading the code is familiar with the conceptual context is made clear or explained elsewhere
09:37:59 <monochrom> yes
09:38:00 <Rotaerk> err, as long as the conceptual context is made clear or explained elsewhere to the reader
09:38:35 <clsmith> hmm, how would i use 'fix' in the definition of bindForever, above, excluding the other point-freedom? so, i guess, how would i define bindForever without referring to bindForever?
09:38:44 <Rotaerk> so if you're writing a library for some obscure purpose with vocabulary that's not well established, and you name things in terms of that vocabulary, explain your model elsewhere
09:38:57 <clsmith> (Y combinators still confuse me.)
09:39:53 <shachaf> @pl bindForever f x = f x >>= bindForever f
09:39:53 <lambdabot> bindForever = fix (liftM2 flip ((>>=) .))
09:40:03 <shachaf> @unpl liftM2 flip ((>>=) .)
09:40:03 <lambdabot> (\ e -> (\ i l -> (>>=) (i l)) >>= \ b -> e >>= \ a -> return (\ h -> b h a))
09:40:12 <kmc> fix is not the Y combinator or "a Y combinator"
09:40:15 * clsmith frowns
09:40:27 <shachaf> kmc: Well, it could be.
09:40:31 <monochrom> as an empirical example, look at the threads in haskell-cafe on the iteratee enumerator etc libs, how their names are poor, and most importantly how *no consensus* has reached on supposedly better names
09:40:32 <Rotaerk> but to say that naming alone isn't sufficient documentation isn't to say that you shouldn't bother with naming
09:40:32 <kmc> not in Haskell
09:40:35 <kmc> without various extra hoops
09:40:50 <shachaf> Sure. But it could be. :-)
09:41:03 <shachaf> @ty let y = \f -> (\x -> outR x x) (InR (\x -> f (outR x x))) in y
09:41:03 <parcs> :t bindForever f x = f x >>= bindForever f
09:41:04 <lambdabot> forall a. (a -> a) -> a
09:41:05 <lambdabot> parse error on input `='
09:41:23 <Saizan> clsmith: \f -> fix $ \bindForever x -> f x >>= bindForever
09:41:29 <parcs> :t let bindForever f x = f x >>= bindForever f in bindForever
09:41:30 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m a) -> a -> m b
09:41:47 <eleruin> I'm trying to install nano-md5 with cabal install, but I got errors like : ".size expression for s1HQ_ret does not evaluate to a constant"
09:41:55 <parcs> :t let bindForever f x = fix $ \bindForever f x >>= bindForever f in bindForever
09:41:57 <lambdabot> parse error on input `>>='
09:42:02 <parcs> f it
09:42:23 <shachaf> @ty fix (\bindForever f x -> f x >>= bindForever f)
09:42:24 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m a) -> a -> m b
09:42:56 <shachaf> @ty \f -> fix (\bindForeverF x -> f x >>= bindForeverF)
09:42:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m a) -> a -> m b
09:43:35 <hpaste> eleruin pasted “nano-md5 errors” at http://hpaste.org/49135
09:43:36 <sm> hi all. https://gist.github.com/1087784 shows two backtracking versions of parsec's choice. choice'' looks more efficient but I suspect its behaviour is different - am I right ?
09:45:44 <Cale> sm: What's with the init/last?
09:46:04 <sm> Cale: I was mimicking what I previously did by hand: try all but the last one
09:46:29 <Cale> oh, right
09:46:31 <sm> I want it to fail if none of them match
09:46:45 <Cale> try won't cause it to succeed
09:46:57 <Cale> It just means that if it fails, then it has consumed no input
09:47:07 <sm> you're right.. I just can't remember exactly what effect it has.. right you are
09:47:39 <sm> so I think that changes the semantics in a way I wouldn't expect, and I'll go with choice'
09:48:52 <sm> hmm. Or not. I guess I'm splitting hairs and until it bites me one way or another it makes no difference
09:53:24 <Cale> sm: Here's a difference: what happens when the list of parsers is empty? :)
09:54:50 <sm> Cale: good point! choice'' gives a parse error instead of init failure
09:55:16 <sm> I could fix that, but I guess choice'' wins for simplicity - thanks
09:56:22 <eleruin> Does anybody know how to install nano-md5?
09:58:40 <shachaf> Cale: I missed that about MonadExit. Seems kind of inappropriate, yes.
10:04:42 <Phantom_Hoover> I'm having some trouble running cglib.
10:07:51 <Phantom_Hoover> I get the error Loading package GeomAlgLib-0.2.0 ... linking ... <interactive>: /usr/local/lib/GeomAlgLib-0.2.0/ghc-7.0.2/HSGeomAlgLib-0.2.0.o: unknown symbol `__stginit_ghczm7zi0zi2_Maybes_'
10:07:51 <Phantom_Hoover> ghc: unable to load package `GeomAlgLib-0.2.0'
10:08:45 <wli> Code should really be literature... now I need to diagram some sort of 1D minimization algorithm.
10:09:23 <wli> A real one instead of brute-force search refining meshes to huge sizes.
10:23:15 <Phantom_Hoover> Hello?
10:23:18 <Phantom_Hoover> Anyone?
10:25:12 <Eduard_Munteanu> Phantom_Hoover: hi
10:25:29 <Phantom_Hoover> Eduard_Munteanu, please tell me what is wrong.
10:25:33 <Eduard_Munteanu> If you have a question, you can just post it.
10:25:51 <Eduard_Munteanu> Oh.
10:26:09 <Eduard_Munteanu> Sorry, well, I'm not sure what's wrong there.
10:26:26 <dmwit> Phantom_Hoover: The first thing to check is if you can compile the module in question.
10:26:47 <dmwit> Use ghc --make or so.
10:26:55 <dmwit> Add a useless "main" if necessary.
10:27:09 <Phantom_Hoover> Yep, works.
10:27:39 <Phantom_Hoover> And loading the module works as well.
10:30:32 <dmwit> preflex: zdec __stginit_ghczm7zi0zi2_Maybes_
10:30:33 <preflex>  __stginit_ghc-7.0.2_Maybes_
10:31:07 <dmwit> I don't see a package named GeomAlgLib on Hackage.
10:32:39 <Phantom_Hoover> dmwit, yes, I found it elsewhere.
10:33:33 <Eduard_Munteanu> Maybe it hasn't been ported/adapted to GHC 7?
10:34:08 <Phantom_Hoover> That's probable, yes.
10:34:29 <Phantom_Hoover> But it didn't look like it used anything particularly liable to change.
11:46:14 * hackagebot couch-hs 0.1.4 - A CouchDB view server for Haskell.  http://hackage.haskell.org/package/couch-hs-0.1.4 (PeterSagerson)
12:04:24 <Oddity007> Woah, I'd hate to be in here when a netsplit happens.
12:13:57 <elliotstern> Suppose I have a pcap file.  There's a library for working with pcap (http://hackage.haskell.org/packages/archive/pcap/0.4.5/doc/html/Network-Pcap.html#7), however, the processing functions take a callback of type PktHdr -> ByteString -> IO ().  However, what I'd really like to do is to transform the packet stream into a list of PacketData (for some user-defined PacketData type), so I can...
12:13:58 <elliotstern> ...e.g. sort the packets.  How would I do this?
12:14:57 <elliotstern> Basically, I want a lazy list of the packet's information, but that library seems to be very... imperative.
12:15:24 <alpounet> maybe writing that list in an IORef
12:15:35 <ivanst> i'm a haskell newbie here... i have a smallish web that uses snap, and fails to 'cabal configure' on osx horribly... it works wonderfully on linux though... i have a detailed error here: http://hpaste.org/49136 - any ideas? i tried to remove .ghc and .cabal a few times, have the latest haskell tools from mac homebrew... no ideas really
12:17:13 <elliotstern> alpounet:  yeah, that seems like a good idea
12:46:03 <Fuco> what would you guys recommend as a simple web framework to try out haskell on the web?
12:46:07 <ziman> well, I doubt that the list would be lazy.
12:46:12 <Fuco> I'm looking at snap right now and it seems to be most solid one
12:46:51 <augur> are trees monoids?
12:47:50 <monochrom> there may be some difficulty with associativity
12:48:10 <augur> ahh right, monoids are associative
12:48:28 <Jetbeard> :t replicate
12:48:29 <augur> hm.
12:48:29 <lambdabot> forall a. Int -> a -> [a]
12:48:46 <dmwit> ?src Tree
12:48:47 <lambdabot> Source not found. Take a stress pill and think things over.
12:48:52 <augur> is there a property that identifies the "filterable" things like there is with mappable things (ie Functors)?
12:49:26 <hpc> enumerators?
12:49:46 <augur> hmm
12:49:51 <augur> but i mean, law-wise
12:50:32 <rostayob> Is there any documentation on HJScript?
12:53:47 <Jetbeard> :t partition
12:53:49 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
12:53:58 <Jetbeard> > partition id [True,False,True]
12:53:59 <lambdabot>   ([True,True],[False])
13:14:26 <ivanst> anyone with any ideas about my osx woes?
13:20:50 <hpaste> djh pasted “GOB's Program” at http://hpaste.org/49137
13:23:24 <NemesisD> hi all. i get an odd error running something with runhaskell: "Main.hs: This ELF file contains no symtab. Main.hs: Main.hs: panic! (the 'impossible' happened)" whats up with that
13:29:31 <dcoutts> ivanst: the message describes the problem, those packages are broken and need to be reinstalled
13:29:50 <dcoutts> ivanst: try: cabal install --only-dependencies --dry-run
13:30:14 <dcoutts> it'll probably say that it'd install those listed packages
13:30:56 <ivanst> dcoutts: trying now...
13:32:47 <JuanDaugherty> hmm, galois.com is registered in Portland OR, wonder where it's incorporated?
13:37:27 <JuanDaugherty> same apparently
13:41:27 <JuanDaugherty> http://www.hoovers.com/company/Galois_Inc/rjftcci-1.html is informative. I wonder if the typical Galois programmer makes $175K.
13:42:37 <NemesisD> good god
13:42:45 <djahandarie> I wish I made anything near $175k. :(
13:43:12 <bxc> uh oh
13:43:19 <bxc> i read the terms and conditions of galois website
13:43:27 <bxc> now i guess i'm not allowed to visit it again
13:43:35 <bxc> (according to them)
13:44:55 <JuanDaugherty> well that's in line, as the article states the typical ROI on a single programmer is 380K, google programmers are known to make 100-300K
13:45:09 <benmachine> bxc: hmm, why?
13:45:16 <kmc> which article?
13:45:29 <kmc> a thousand karma to the person who hpasted "GOB's Program"
13:45:52 <JuanDaugherty> prolly the typical galois employee has a CS doctorate, unlike the typical google employee
13:46:02 <bxc> benmachine: my interest in their site is business related, and i do not have a written licence from them.
13:46:11 <benmachine> oh
13:46:13 <benmachine> eep
13:46:20 <JuanDaugherty> kmc, if you were talking to me, the one I linked
13:46:46 <kmc> oh, revenue per worker
13:46:48 <kmc> i see
13:46:57 <kmc> to me that's quite different from ROI
13:47:37 <kmc> also that's not for galois in particular
13:47:55 <JuanDaugherty> yes, I used ROI because for me it's 6 of 1 half a dozen of the other
13:48:06 <kmc> and what they do sounds like "custom programming" not "packaged software"
13:48:31 <JuanDaugherty> well commercial software dev is the common thin
13:48:32 <JuanDaugherty> g
13:49:03 <kmc> it's not like each programmer contributes exactly 1/n value
13:49:14 <kmc> a small software company is worth more than the sum of its parts
13:51:15 <JuanDaugherty> the thing is, if this is at the acme of western intellectual development, why do such ventures fall back on hackneyed models of economic operation?
13:51:25 <JuanDaugherty> *co-operation
13:52:32 <JuanDaugherty> is the standard case of academic savanterie? Knowlegable in a narrow field, but unable to apply g generally to life circumstances>
13:52:39 <JuanDaugherty> s/>/?/
13:54:16 <confab> erm
13:54:22 <djh_> @kmc t'was me, GOB's program always makes me smile and I always endeavour to make it one of my first tasks in any programming language!
13:54:22 <confab> what are we discussing?
13:54:23 <lambdabot> Maybe you meant: ghc rc src
13:54:47 <confab> i'm trying to folow you JuanDaugherty, but i'm lost
13:55:00 <kmc> which hackneyed models are those
13:55:16 <kmc> my experience with programmers in general is the opposite of academic savanterie
13:57:08 <kmc> in my experience programmers have broad interests throughout and outside of tech, but often lack the academic background applicable to whatever it is they're doing
13:57:16 <JuanDaugherty> the standard for profit private corporation driving a herd (a relatively small high end one in this case) of wage labor, that hackneyed model
13:57:34 <kmc> for example, most people designing programming languages know nothing about PL theory or how to avoid various well-known mistakes
13:58:19 <kmc> what aspects of that do you think should be reformed?
13:59:15 <kmc> i don't know about galois but at good small software companies nobody is 'driving' any 'herd'
13:59:17 <JuanDaugherty> some kina workers cooperative where nobody is arbitrating the sale of any individuals work product at an unknown markup
14:00:19 <azaq23> djh_: You could write that as putStr "..." >> liftM (== "Y") getLine >>= flip when (forever $ putStr "... ")
14:00:55 <ion> :t \f g x y -> liftA2 f ($x) ($y) g
14:00:56 <lambdabot> forall c a b. (b -> b -> c) -> (a -> b) -> a -> a -> c
14:00:57 <ion> :t on
14:00:59 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
14:04:47 <laar>  :t liftA2
14:05:28 <JuanDaugherty> :t liftA2
14:05:29 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
14:05:38 <ivanst> dcoutts: that dependency problem seems to be a loop... each of the packages depends on something else, and following deps eventually breaks something i had working before :-/ and the ABI ids are completely borked :(
14:06:09 <dcoutts> ivanst: the trick is to install them all together in one shot, that way cabal will work out consistent dependencies
14:06:26 <ivanst> hm...
14:06:37 <dcoutts> ivanst: if you install each in turn that indeed can lead to a situation where installing later things breaks earlier things
14:06:48 <ivanst> let me try that. that sounds like an interesting idea...
14:06:56 <dcoutts> ivanst: use cabal install --dry-run ...
14:07:14 <ivanst> dcoutts: right, use that to capture all the deps, then install all in one shot, right?
14:07:41 <dcoutts> ivanst: simplest is to say: cabal install --only-dependencies --dry-run ./
14:07:57 <dcoutts> assuming you're in the dir of the package you're interested in
14:08:13 <dcoutts> or just cabal install --dry-run if you want to install the local package too
14:10:04 <paczesiowa> what's the status of the tar library? I'm trying to extract a ghc tarball and it fails after 2s with "createDirectory: does not exist" (I do get some of top-level dir files)
14:17:19 <hpaste> azaq23 pasted “GOB's Program 2” at http://hpaste.org/49138
14:17:48 <hpaste> djh annotated “GOB's Program 2” with “GOB's Program 2 (annotation)” at http://hpaste.org/49138#a49139
14:21:41 <JuanDaugherty> paczesiowa, why don't you just use tar?
14:23:22 <paczesiowa> JuanDaugherty: it's not portable
14:23:42 <JuanDaugherty> ah
14:23:49 <paczesiowa> JuanDaugherty: and I prefer calling haskell functions than readProcess this, runInteractiveProcess that
14:24:05 <JuanDaugherty> that's what I thought
14:24:16 <JuanDaugherty> thanks for clarifying
14:28:02 <ivanst> dcoutts: suppose i have a package already installed (checked with cabal info), should that show up in the deps to be installed by another package when i --dry-run --only-dependencies? i checked the version numbers, and my installed one matches, but it still wants to reinstall it...
14:28:39 <dcoutts> ivanst: if you add a -v to the cabal install --dry-run command then it'll say what is changing
14:29:09 <dcoutts> ivanst: it'll say that it's reinstalling that package, and say what dependencies would be changed
14:30:21 <progrock> lol.. so all that time, just couldnt get cabal to install hakyll beucase it was out of ram
14:31:21 <c_wraith> yes, ld is not very good at linking programs created by GHC
14:32:16 <monochrom> if you're on linux, the "gold" linker is very effective for ghc-generated link jobs
14:33:10 <paczesiowa> monochrom: is there an easy way to use gold only for ghc?
14:34:02 <Saizan> progrock: i told you!
14:39:33 <monochrom> only with PATH tricks
14:40:24 <paczesiowa> monochrom: no --with-ld= arg?
14:42:40 <monochrom> I don't know
14:44:21 <monochrom> well, it seems to be -pgml
14:51:52 <rostayob> does anybody have ghc-mod working?
14:56:23 <parcs> paczesiowa: http://hackage.haskell.org/trac/ghc/ticket/4862 see the 4th comment
14:56:35 <bobzhang> does anyone try the package _derive_? I find it very useful, but I didn't find any documentation except some papers, where could I get start?
15:02:31 <ivanst> dcoutts: i am in your debt sir. installing deps manually is indeed shot, compared to automatic install by cabal...
15:06:30 <paczesiowa> parcs: thanks!
15:12:01 <romanmue> Is there a function which applies a function f n-times to g in prelude?
15:12:42 <copumpkin> no
15:12:55 <hpc> there's oodles of ways to make it though
15:12:58 <paczesiowa> > iterate (*2) 1 !! 10
15:12:58 <copumpkin> > iterate f x !! 5
15:12:59 <lambdabot>   1024
15:12:59 <lambdabot>   f (f (f (f (f x))))
15:13:09 <hpc> foldr (.) id .: repeat
15:13:10 <copumpkin> that approach isn't ideal though
15:13:32 <paczesiowa> :t f
15:13:33 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
15:13:36 <copumpkin> > iterate (+1) 0 !! 100000
15:13:37 <lambdabot>   100000
15:13:39 <copumpkin> > iterate (+1) 0 !! 10000000
15:13:47 * copumpkin sighs
15:13:50 <lambdabot>   *Ex
15:13:55 <copumpkin> > iterate (+1) 0 !! 1000000
15:14:00 <lambdabot>   *Exception: stack overflow
15:14:02 <copumpkin> there we go
15:14:03 <hpc> whoa, that was impressive
15:14:16 <hpc> you managed to get λbot to kill itself in the middle of printing the exception
15:14:26 <ion> hah
15:15:06 <ion> How is that even possible? The output isn’t buffered at all?
15:15:18 <copumpkin> > let applyN 0 f !x = x; applyN n f !x = applyN (pred n) f (f x) in applyN 1000000 (+1) 0
15:15:20 <lambdabot>   1000000
15:15:27 <copumpkin> much faster, no stack overflows
15:15:30 <copumpkin> > let applyN 0 f !x = x; applyN n f !x = applyN (pred n) f (f x) in applyN 10000000 (+1) 0
15:15:34 <lambdabot>   mueval-core: Time limit exceeded
15:41:01 <ivanst> heh... and at the end of it all, i get bit in the ass by this: http://hackage.haskell.org/trac/ghc/ticket/5289
15:54:49 * hackagebot digestive-functors-hsp 0.4.3 - HSP support for digestive-functors  http://hackage.haskell.org/package/digestive-functors-hsp-0.4.3 (JeremyShaw)
16:14:52 * hackagebot digestive-functors-hsp 0.4.4 - HSP support for digestive-functors  http://hackage.haskell.org/package/digestive-functors-hsp-0.4.4 (JeremyShaw)
16:15:48 <adxp> this a reasonable place to ask potentially noob questions?
16:16:12 <mauke> evidently
16:16:21 <copumpkin> adxp: we'll flame you like crazy
16:16:24 <copumpkin> but you can ask them
16:16:29 <hpc> you only get one question, and that was it :P
16:16:37 * copumpkin pulls out his baseball bat and taps it menacingly in his hand
16:16:55 <copumpkin> adxp: I'm ready for your question now
16:17:01 <adxp> :)
16:17:06 <adxp> ok, coming up...
16:17:17 <hpaste> adxp pasted “Hmm” at http://hpaste.org/49141
16:17:19 <identity_> adxp: Please, oh please, shoot
16:17:26 <identity_> You will start an avalanche of answers
16:17:35 <identity_> The simpler it is, the more golfing you get
16:17:40 <copumpkin> you doing objc?
16:17:45 <adxp> so, I have this function to convert a CFString (used in OS X, etc) to a Haskell string
16:17:46 <copumpkin> well
16:18:03 <adxp> copumpkin: well, os x, though I don't think this is anything to do with that part
16:18:10 <bos> i wish we had a decent library for stateful parallel programming
16:18:34 <copumpkin> adxp: well, an NSString is secretly a CFString and vice versa :)
16:18:40 <adxp> and anyway, if I do "do str <- cfStringCreate "foo"; cfStringToString str", I get garbage
16:18:50 <kmc> bos, stateful parallel programming?
16:18:55 <adxp> but if I uncomment the commented line, it magically works
16:19:11 <copumpkin> bos: you tried http://hackage.haskell.org/package/reactor ?
16:19:13 <adxp> I've poked around in GDB, and the str returned by cfStringCreate is fine, and has its refcount set correctly
16:19:25 <bos> kmc: as in, i want to use multiple cores to compute an answer to a single question, but the computation is stateful
16:19:54 <mauke> adxp: what's the type of cfStringGetCString?
16:20:02 <bos> copumpkin: doesn't seem to build?
16:20:28 <copumpkin> hmm, should bug edwardk
16:20:34 <copumpkin> @tell edwardk is reactor broken?
16:20:35 <lambdabot> Consider it noted.
16:21:09 <adxp> mauke: CFStringRef -> CString -> CInt -> CInt -> CInt
16:21:19 <mauke> adxp: that's wrong
16:21:44 <bos> copumpkin: hm, builds on my machine
16:21:50 <bos> oh!
16:21:51 <copumpkin> weird
16:21:52 <bos> i see what it is.
16:21:53 <hpaste> adxp annotated “Hmm” with “Hmm (annotation)” at http://hpaste.org/49141#a49142
16:22:00 <bos> copumpkin: haddock can't parse it.
16:22:04 <copumpkin> ah I see
16:22:18 <bos> @tell edwardk hey, reactor doesn't build with "cabal install --enable-documentation"
16:22:19 <lambdabot> Consider it noted.
16:22:27 <adxp> mauke: oops, pasted the wrong annotation. but curious what you see that's wrong?
16:22:29 <copumpkin> @tell edwardk spamspamspam
16:22:30 <lambdabot> Consider it noted.
16:22:32 <dobblego> hey I am looking for edwardk too!
16:22:46 <hpaste> adxp annotated “Hmm” with “Hmm (annotation)” at http://hpaste.org/49141#a49144
16:22:59 <copumpkin> bos: anyway, he was going on about that one a lot at work a few months ago. It sounded neat, but I don't remember the details
16:23:08 <mauke> adxp: your function takes a pointer and returns an int. it can't do anything useful
16:23:27 <adxp> mauke: well, it writes to the buf. can I not access that afterwards or something?
16:23:36 <mauke> adxp: it can't write to the buf. it returns an int.
16:23:50 <bos> @tell edwardk error is on line 22 of Reactor/Deque.hs
16:23:51 <lambdabot> Consider it noted.
16:23:52 <adxp> mauke: ah, it should return IO CInt?
16:23:55 <mauke> adxp: yes
16:24:03 <adxp> mauke: aha, makes sense. thanks!
16:24:55 <bos> copumpkin: he seems to have not documented it at all
16:27:19 <copumpkin> bos: oh no
16:27:45 <copumpkin> I'll bug him tomorrow to do that
16:27:58 <copumpkin> he seems to be in the mood for blogging recently, so maybe we can get him to write a blog pots on it
16:28:07 <bos> copumpkin: it looks like it might be interesting, mind you.
16:28:18 <copumpkin> he really likes work-stealing deques
16:28:38 <copumpkin> and I think reactor uses them
16:28:38 <bos> basically, my problem is that i have a big statistical computation that requires a PRNG to work.
16:28:44 <copumpkin> ah, I see
16:29:06 <bos> i can thread it, but that's a pain in the nethers.
16:29:17 <copumpkin> speaking of stats, those stream processor/iteratees I mentioned on twitter are mostly motivated by the desire to have something like your stats package that can work on datasets larger than memory :)
16:29:35 <copumpkin> and my utter horror when looking at iteratee
16:29:36 <bos> ah!
16:29:47 <bos> enumerator is a little simpler than iteratee.
16:29:54 <copumpkin> yeah, looked at that too
16:29:56 <copumpkin> still not a fan
16:29:56 <bos> but it's still gobbledygook to me.
16:30:00 <kmc> bos, i'd probably use some terrible unsafePerformIO hack there
16:30:03 <kmc> which illustrates your point
16:30:48 <bos> i'm trying to extend criterion's analyses to http load testing.
16:31:03 <bos> but an http load tester generates a lot of data, much more than criterion does.
16:31:33 <bos> so the numeric techniques that worked fine for small datasets don't scale well to much bigger ones.
16:32:00 <copumpkin> oh nice
16:32:04 <bos> hence wanting to use all cores.
16:32:07 <copumpkin> yeah
16:32:17 <copumpkin> being able to make things parallel is another concern of mine :)
16:32:26 <copumpkin> and I think I have some ideas for it, but it's tricky
16:41:26 <bos> also needed: holey views on vectors
16:41:49 <copumpkin> holey views on vectors?
16:41:56 <copumpkin> if it's what I think you mean, I've wanted it too
16:42:14 <bos> i want to be able to compute a function over every element of it except for a chunk in the middle.
16:42:23 <bos> preferably without copying the vector.
16:42:24 <copumpkin> ah, I see
16:42:34 <copumpkin> seems like something the new REPA implementation would support
16:42:38 <copumpkin> but I'm not sure there's an API to do that
16:42:44 <bos> because i actually need to slide that chunk over the entire vector.
16:42:55 <dcoutts> copumpkin: I'd expect it's easy
16:43:01 <copumpkin> sliding window calculations?
16:43:07 <dcoutts> it's just a index function
16:43:19 <bos> so if it's a million-element vector, i have to currently copy the vector-less-the-chunk a million times.
16:43:25 <copumpkin> I was actually thinking a lot about those recently
16:43:52 <bos> or else zip the vector together with a window that tells me whether i should inspect an element or not, which gives a slow loop.
16:44:45 <bos> fun problems to have!
16:44:48 <copumpkin> yep :)
16:44:59 <copumpkin> dcoutts: an index function?
16:45:14 <copumpkin> I was talking about the chunky regions that the new repa uses
16:45:33 <dcoutts> copumpkin: well even with the old repa, it's just an index space transformation
16:45:35 <copumpkin> but those would be a property of the array that would be a pain to change in a sliding way
16:45:42 <dcoutts> and repa is set up to handle and fuse those
16:45:54 <fxr> repa is fast
16:46:10 <copumpkin> dcoutts: I'm not sure how you'd map over a subset of the indices?
16:46:44 <copumpkin> (maintaining the other elements unchanged)
16:46:52 <copumpkin> if you just wanted to pull out a chunk
16:46:55 <copumpkin> that's easy
16:47:05 <bos> right now, i can rewrite functions so that they operate over a list of vectors instead of a single vector
16:47:10 <bos> but that makes me a sad panda
16:47:25 <copumpkin> yeah
16:47:54 <copumpkin> well, I was thinking of the magic of groups for sliding window calculations
16:48:10 <copumpkin> but not every calculation can be groupified
16:51:02 <identity_> Does anyone have any information/tutorial on how to use Regex.TDFA?
16:51:04 <bos> i'm kind of wishing i had a port of the statistics package to repa.
16:51:13 <copumpkin> :)
16:52:32 <dcoutts> copumpkin: does select do what you want?
16:56:04 <dcoutts> copumpkin: or just traverse
16:57:57 <dcoutts> mm, I think traverse is the right one
16:58:45 <dcoutts> bos: ^^ have you tried traverse to cut out your chunk?
16:59:16 <copumpkin> dcoutts: cutting out the chunk isn't hard
16:59:27 <copumpkin> backpermute would do it too, and is a bit less powerful than traverse
16:59:36 <copumpkin> dcoutts: have you seen my agda repa? :P
16:59:39 <dcoutts> so what's the problem?
16:59:41 <copumpkin> it's called derpa
16:59:58 <NihilistDandy> derpa.derp
17:00:02 <dcoutts> heh
17:00:17 <copumpkin> dcoutts: well, I doubt it would fuse very well to pull a chunk out, map over it, then reincorporate it to the rest of the vector (unmodified
17:00:23 <copumpkin> oh actually
17:00:26 <identity_> Anyone, re the regex.tdfa? The docs really aren't helping
17:00:29 <copumpkin> backpermuteDft I think would do it nicely
17:00:54 <dcoutts> copumpkin: right, you'd use a combination of traverse and traverse2
17:01:14 <dcoutts> traverse to map the function over some sub-array
17:01:15 <copumpkin> https://github.com/copumpkin/derpa is derpa if anyone's interested :)
17:01:29 <dcoutts> and then traverse2 to combine the new with the original
17:01:39 <bos> dcoutts: hmm, haven't tried it
17:01:52 <dcoutts> or perhaps a single traverse that just reads from the source for the hole
17:02:04 <copumpkin> yeah, you're right
17:02:09 <copumpkin> traverse will do the map for you, too
17:02:11 <dcoutts> the whole point of doing things via array as function is that it does fuse
17:02:14 <copumpkin> even without traverse2
17:02:34 <copumpkin> yeah, I know, I just thought we'd have to pull the chunk out, map over it, and put it back in
17:02:39 <dcoutts> and traverse just constructs a new array function, based on the lookup function of the original
17:02:39 <copumpkin> which didn't feel very fusion-friendly
17:03:09 <dcoutts> copumpkin: even if you do structure it like that, it'll still fuse
17:03:17 <dcoutts> you'd just be doing a couple comparison per element
17:03:30 <bos> identity_: http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
17:03:34 <copumpkin> dcoutts: fair enough
17:04:03 <bos> dcoutts: where's traverse?
17:04:18 <copumpkin> Operators.Traverse
17:04:23 <copumpkin> but I think a couple of them are exported from the main repa module
17:04:27 <dcoutts> bos: Data.Array.Repa
17:04:50 <copumpkin> oh all of them are
17:05:06 <NemesisD> anyone familiar with aeson?
17:05:12 <copumpkin> NemesisD: its author is right here
17:05:23 <NemesisD> copumpkin: fantastic!
17:05:41 <bos> dcoutts: oh.
17:06:00 <NemesisD> copumpkin: the author being you?
17:06:10 <copumpkin> nope
17:06:10 <kmc> haskell sure has a proliferation of json libraries
17:06:11 <dcoutts> bos: morally a repa array is just Array a = (Int, Int -> a)
17:06:13 <copumpkin> the author being like a bos
17:06:17 <bos> dcoutts: but traverse requires repa, which puts me back at square 1?
17:06:28 <dcoutts> bos: I thought you were using repa?
17:06:35 <bos> copumpkin: what are you pinning on me?
17:06:37 <kmc> i do enjoy that aeson's docs start with a page of performance notes
17:06:41 <copumpkin> bos: aeson?
17:06:42 <bos> dcoutts: just plain vector in statistics-land
17:06:47 <identity_> bos: It uses Regex.Posix
17:06:49 <bos> copumpkin: ah
17:06:51 <identity_> Not TDFA
17:06:55 <dcoutts> bos: ooh, sorry, got the wrong end of the stick
17:06:55 <bos> identity_: same API, i believe
17:06:59 <identity_> bos: Not even close
17:07:03 <identity_> as far as I can see
17:07:18 <identity_> posix lets you do "foo" =~ "foo" :: TypeYouWant
17:07:21 <identity_> Bool, [String] etc..
17:07:25 <identity_> doesn't work with tdfa
17:07:33 <kmc> that (=~) is like my least favorite operator ever
17:07:39 <kmc> it's overloaded to hell for no good reason
17:07:53 <kmc> that API is so unlike the rest of Haskell
17:08:01 <bos> identity_: regex-tdfa is a back end to the regex-base API, so it *is* compatible
17:08:08 <NemesisD> hey bos, i'm looking to port the applicative (?) style of parsing JSON to XML, i.e. fromJSON (Object v) = SomeRecord <$> v .: "field1" <*> v.: "field2"
17:08:14 <bos> but the regex-base API is terrible
17:08:54 <identity_> bos: I'm telling you that the examples in that tutorial do not work with tdfa
17:08:55 <NemesisD> the only difference with xml-enumerator is that i'm working with a cursor to the xml doc instead of the v. i'm quite a novice though so I'm not sure where I should begin researching to implement this functionality
17:09:02 <bos> identity_: unless there's something very specific you need there, i'd recommend simply not using that package
17:09:03 <mauke> someone thought "hey, perl is too simple with its two overloaded versions, so let's overload fucking EVERYTHING"
17:09:06 <identity_> I even found another guy asking about it, etc
17:09:12 <identity_> I may just not use regexes
17:09:15 <identity_> I should probably use parsex
17:09:17 <identity_> or something
17:09:32 <cmccann> mauke, overloading on return type is the most fun thing ever
17:09:38 <bos> NemesisD: i don't know anything about xml-enumerator.
17:10:31 <NemesisD> bos: that's fine. the only part about it that is relevant is that cursor in this case is analogous to the value that Object wraps in the argument to fromJSON
17:11:01 <NemesisD> i'm just not sure how you achieved the API you did. i've looked through the source but its a bit daunting
17:20:04 * hackagebot chan-split 0.1.2 - Concurrent Chans as read/write pairs. Also provides generic  Chan, Cofunctor classes.  http://hackage.haskell.org/package/chan-split-0.1.2 (BrandonSimmons)
17:20:28 <hpaste> j pasted “tuples” at http://hpaste.org/49151
17:29:08 <bos> NemesisD: well, there's a big difference between the two packages
17:29:19 <bos> NemesisD: xml-enumerator is designed as a streaming API
17:34:15 <NemesisD> bos: the cursor module is a bit different from that. i've found it lends itself quite well to non-streaming applications
17:34:45 <NemesisD> that module is based on axes as defined in the xpath (?) spec
17:36:52 <dreamer_> hi guys
17:37:03 <dreamer_> bit of a noob here
17:37:20 <dreamer_> runhaskell gives me <command line>: not built for interactive use
17:38:12 <gienah> dreamer_: the haskell interpreter is ghci
17:38:40 <dreamer_> how can i change that?
17:38:48 <NemesisD> bos: the ideal api i'm trying to create is: given a cursor scoped to the root node: parseArtist root = Artist <$> root @<> "id" <*> root <>> "name", where @<> gets an attribute, <>> would read the contents of a child element by name
17:39:20 <gienah> dreamer_: http://learnyouahaskell.com/starting-out#ready-set-go
17:39:35 <NemesisD> i just don't know what approach i should take for that api. i can write (@<>) and (<>>) easily
17:47:01 <dreamer_> right...
17:48:33 <NemesisD> dreamer_: did you see http://www.haskell.org/haskellwiki/GHC:FAQ#When_I_try_to_start_ghci_.28probably_one_I_compiled_myself.29_it_says_ghc-5.02:_not_built_for_interactive_use
17:49:11 <fxr> I like sunday night
17:49:18 <NemesisD> you may have built ghci with a mismatched version of ghc?
17:49:31 <NemesisD> fxr: whys that
17:50:33 <dreamer_> i installed it from a package. I guess it's  not a very complete package. Will recompile tonight
17:50:37 <dreamer_> and build my own package
17:50:43 <fxr> because other 6 days probably patented by some giant c0rp...
17:57:38 <identity_> Anyone else get the "thread blocked indefinitely in an mvar operation" bug on windows with 7.0.2 using ghci?
17:57:51 <identity_> I found a ticket referring to ctrl+c in ghci and that error, but it seems to happen randomly
17:57:57 <identity_> and it is ruining my programming mojo.
17:59:04 <fxr> I also got it when I try to call an exported function from an apache module.
18:03:20 <luite> identity_: do you have a way to repoduce it?
18:06:08 <identity_> luite: Hmm, it hasn't appeared now for a few minutes, so no
18:06:29 <identity_> I originally assumed it was from ctrl+c inside ghci as well, even before the ticket
18:06:41 <identity_> but it appeared before without using ctrl+c.. unless I accidentally hit it
18:06:42 <identity_> I'll see
18:12:48 <luite> identity_: Simon Marlow asked for ways to reproduce it on the ghc mailing list, apparently it's tricky to fix, and it's affecting lots of people
18:14:44 <Chewie[]> i need help deciphering an algorithm which generates all partitions of a set. i want to write it in haskell. here's a python implementation... http://compprog.wordpress.com/2007/10/15/generating-the-partitions-of-a-set/#comment-465
18:21:10 <NihilistDandy> Chewie[]: Okay, what do you need?
18:21:36 <NihilistDandy> I know one way
18:22:09 <kmc> > filterM (const [False ..]) "abc"
18:22:11 <lambdabot>   ["","c","b","bc","a","ac","ab","abc"]
18:22:57 <kmc> don't know a short way to do it for partitioning into >2 parts
18:23:16 <Chewie[]> NihilistDandy: well mostly i want to figure out how that algorithm works, maybe more of a #python question.
18:24:23 <Chewie[]> but the end goal is a haskell implementation.. i need it for a quick and dirty solution to an optimization problem (finding the best way to cut lumber).
18:24:53 <kmc> i really hope you're actually using this to decide how to cut real lumber
18:24:54 <NihilistDandy> If I weren't late for work, I'd be all over it. kmc's version does the job nicely
18:25:41 <Chewie[]> kmc: well i have a set of needed boards and i have a set of raw lumber lengths and i need to find the best way to fit it to minimize cost.
18:25:56 <Chewie[]> so my quick and dirty solution will basically generate all groupings and find the minimal cost.
18:26:09 <kmc> this isn't, like, a programming puzzle? you're really cutting wood?
18:26:11 <kmc> that's fantastic
18:26:31 <Chewie[]> yes, i build lofts out of 2x4s and am sick of doing this by hand.
18:26:36 <Chewie[]> and getting it wrong.
18:26:37 <NihilistDandy> Haskell just got *real*~
18:26:42 <kmc> Haskell is already used to run hydraulic dump trucks
18:26:59 <NihilistDandy> ~ == sarcasm
18:27:07 <cmccann> kmc, {insert garbage collection joke here}
18:27:08 <Chewie[]> so i have a set of boards and can buy 7.25', 8, 10 and 12'... yeah. anyway. =P
18:28:51 <identity_> luite: I see, thanks
18:28:55 <kmc> Chewie[], i can roughly explain how the python code works anyway
18:29:20 * hackagebot chan-split 0.1.3 - Concurrent Chans as read/write pairs. Also provides generic  Chan, Cofunctor classes.  http://hackage.haskell.org/package/chan-split-0.1.3 (BrandonSimmons)
18:29:40 <kmc> it would be clearer to write this with a 2-partitions function and a separate recursion that uses that
18:30:05 <kmc> each value of i represents (bitwise) a 2-partition i.e. subset of set_
18:30:15 <identity_> So, my haskell debugging foo is subpar. I'm writing some code and it's failing on a head on an empty list, except my code doesn't use head anywhere, so it's one of the libraries I'm using. How can I track this down?
18:30:54 <kmc> so each one splits set_ into parts[0] and parts[1]
18:30:55 <Chewie[]> identity_: remember, subpar is good...
18:31:21 <identity_> Chewie[]: haha.
18:31:34 <kmc> each partition you output is parts[0] plus one of the partitions of parts[1], obtained recursively
18:32:24 <kmc> identity_, ghc --make -fforce-recomp -prof -auto-all -rtsopts foo.hs && ./foo +RTS -xc
18:32:28 <kmc> yes this is kind of ridiculous
18:32:30 <kmc> but it might work
18:34:15 <Chewie[]> kmc: not sure i'm following.
18:34:50 <kmc> which part?
18:34:52 <identity_> hmm
18:35:04 <identity_> need profiling libraries for http-enumerator
18:35:54 <identity_> how can I get these, or find out if they even exist?
18:36:26 <_nickel> when defining an instance of Applicative is `pure` expected to be "the way" to lift values into it?
18:36:51 <kmc> _nickel, depends.  some instances of Functor / Monad / Applicative / etc. export their data constructors and let you manipulate them "directly"
18:36:59 <kmc> some are abstract types and force you to go through those APIs
18:37:02 <_nickel> I was just going to ask it that way
18:37:14 <kmc> whether a type is abstract is orthogonal to whether it implements Functor or Applicative or what-not
18:37:18 <Chewie[]> kmc: hmm, i don't understand what happens to parts[0]. i grok where the recursion comes in, and i'm almost comfortable with that generating all possibilities...
18:37:38 <kmc> you're yielding a partition of set_, i.e. a set of subsets of set_
18:37:48 <kmc> the first subset is parts[0]
18:37:56 <_nickel> kmc: is there a reason for labeling them "abstract" when you don't export the data contructor?
18:38:00 <_nickel> *constructor
18:38:10 <kmc> the rest are a partition of parts[1]
18:38:24 <kmc> you do this yielding for every partition of parts[1]
18:38:38 <kmc> and you in turn do all that for every 2-split of the input
18:38:45 <alpounet> identity_, just gotta give the right option to cabal
18:38:49 <kmc> _nickel, that's what "abstract data type" means
18:38:58 <_nickel> kmc: thanks
18:38:59 <identity_> alpounet: -p seems to be it, indeed
18:38:59 <kmc> following the general idea of abstraction = hiding implementation details
18:39:05 <alpounet> yep
18:39:07 <fxr> oh I just learned that world calls our javascript/cc functions as JSONP :)
18:39:08 <kmc> Chewie[], it really will be a lot clearer in haskell, i think
18:39:18 <_nickel> kmc: makes sense
18:39:29 <Chewie[]> kmc: i agree it will be clearer.
18:39:29 <kmc> partition xs = [[b] : p | (a, b) <- splitInto2 xs, p <- partition b]
18:39:34 <alpounet> identity_, you can also make it a global behavior, in your cabal configuration file
18:39:37 <kmc> really you could write this list comprehension in python too
18:40:11 <hpaste> “C. McCann” pasted “really awful n-way partitioning” at http://hpaste.org/49154
18:40:12 <identity_> now it cries about a dependency of http-enumerator not having that installed
18:40:13 <identity_> great
18:40:15 <identity_> hmm
18:40:28 <cmccann> not kidding about awful btw
18:41:21 * cmccann is pretty sure he's forgetting about some standard functions that do some of that already, too
18:41:44 <identity_> alpounet: how does one make it global?
18:41:59 <Chewie[]> cmccann: is that your version of the py code in haskell? or did you find that somewhere.
18:42:02 <alpounet> identity_, edit your ~/.cabal/config file
18:42:06 <alpounet> you have to uncomment a line
18:42:15 <identity_> alpounet: thanks
18:42:24 <kmc> Chewie[], did you see mine above?
18:42:25 <cmccann> Chewie[], I just wrote it
18:42:31 <Chewie[]> kmc: yes
18:42:32 <kmc> uh i think it should be b:p not [b]:p
18:42:46 <kmc> and i don't have a super clever way to write splitInto2 but it's a straightforward recursion anyway
18:42:46 <Chewie[]> agreed, but understood.
18:42:49 <cmccann> Chewie[], assuming I understood what you were looking for at least
18:43:42 <alpounet> identity_, it's "-- library-profiling: False"
18:43:45 <alpounet> uncomment and set it to True
18:43:58 <alpounet> to installing profiling-enabled versions of ALL the libraries you install
18:44:03 <alpounet> to install*
18:44:16 <identity_> alpounet: indeed, found it, thanks
18:44:24 <Chewie[]> cmccann: may work, will just need to concat for various n
18:44:40 <Chewie[]> kmc: yes it is clarifying, still trying to understand it.
18:44:59 <kmc> (you'll need a base case too)
18:45:09 <kmc> i'm pretty sure
18:45:13 <kmc> you can never quite tell in haskell ;P
18:45:21 <Chewie[]> kmc: pretty much i don't see why starting from 2-partitions works to get all partitions, just need to stare at it long enough i think.
18:45:48 <cmccann> Chewie[], anyway my code is horrible but it seems to work when I tried it, kmc's version is probably the better way
18:45:51 <Chewie[]> cmccann: s/may/will/, i.e. you understood correctly =P
18:45:53 <kmc> because a list of subsets has a "first subset" and a "rest of subsets"
18:46:18 <kmc> you 2-partition to pick the first subset, and then you n-partition the rest
18:46:44 <kmc> hmm i bet my code will give you lots of partitions of the form [[], [], [], [], ...]
18:46:56 <kmc> you might have to add "not (null p))" or something to the list compr
18:47:04 <identity_> alpounet: So I'm now stuck in a recursive dependency reinstall-with-profiling hell. any way to lessen my pain by automating this?
18:47:06 * cmccann just did it the stupid way, taking the head of the list, each integer in the range, and each result from the recursive case, then append the head to the nth element of the result
18:47:15 <cmccann> then sort and nub and whatnot to clean up all the duplicates
18:48:04 <cmccann> indexing it like that is kinda awful, but was too lazy to think through doing it properly right now :T
18:48:31 <alpounet> identity_, is this hell *that* deep ?
18:48:44 <Chewie[]> cmccann: yeah it seems legit and i coudl copy+paste your code and use it, but i'm trying to understand why it works +P
18:48:45 <alpounet> generally i handle such situations manually
18:48:47 <Chewie[]> =P*
18:49:11 <cmccann> hm
18:49:38 <Chewie[]> cmccann: TBH i think kmc's is more instructive because i'm not conversational on the Monad imports you're using
18:49:50 <kmc> mine is also secretly monadic
18:50:07 <identity_> alpounet: seems like it, yeah
18:50:08 <kmc> because list comprehensions are just alternative syntax for "do", which is just alternative syntax for the monad operators
18:50:20 <Chewie[]> kmc: it helps to not think about it that way though. particularly when trying to understand the underlying mathematical problem.
18:50:21 <identity_> meh
18:50:22 <alpounet> identity_, what are you working on by the way ?
18:50:24 <identity_> I will soldier on
18:50:28 <kmc> but it's not necessary (or even helpful) to think of it that way
18:50:34 <kmc> yeah
18:50:38 <Chewie[]> yeah =P
18:50:43 <identity_> alpounet: nothing special really
18:53:14 <Chewie[]> partition xs = [right : p | (left, right) <- bisect xs, p <- partition right]
18:53:20 <Chewie[]> changed some variable names is all.
18:53:33 <Chewie[]> conceptually, why isn't "left" used anywhere?
18:53:37 <kmc> good names
18:54:23 <alpounet> Chewie[], 'cause when you want to get all the subsets of a set, you actually for most of them have to drop a part of the set
18:54:40 <alpounet> 'left' is what you're dropping
18:54:58 <kmc> uh, i think it's wrong
18:55:00 <kmc> it should be left : p
18:55:05 <Chewie[]> lol
18:55:06 <kmc> yet another way my original code was bad
18:55:10 <Chewie[]> that makes a little more sense
18:55:14 <alpounet> consider {1,2,3,4}
18:55:15 <Chewie[]> lemme change and keep staring.
18:55:17 <kmc> "it's the concept that counts"
18:55:24 * cmccann is sticking with his terrible version, he thinks
18:55:26 * kmc hides in shame
18:55:27 <identity_> cabal really needs a --reinstall-all-dependencies-with-profiling option
18:55:30 <cmccann> kmc, did you look at mine?
18:55:34 <kmc> yes
18:55:36 <kmc> briefly
18:55:53 <Chewie[]> kmc: bisect returns a list of all bisections correct?
18:56:01 <Chewie[]> (as tuples)
18:56:02 <kmc> yes
18:56:04 <Chewie[]> kk
18:56:06 <Chewie[]> just checking =P
18:56:08 <kmc> bisect :: [a] -> [([a], [a])]
18:56:11 <kmc> partition :: [a] -> [[[a]]]
18:56:14 <Chewie[]> *nod*
18:56:30 <kmc> might be clearer with "type Partition a = [[a]]"
18:56:36 <kmc> partition :: [a] -> [Partition a]
18:57:06 <Chewie[]> no i understand [[[a]]], i already arrived at that myself and was uselessly hoogling/googling for [a] -> [[[a]]] for a little while =P
18:57:11 <kmc> haha
18:57:52 <identity_> great, so now it seems semigroup doesn't have a profiling version which is a depdency of tagged, which is a dependency of crypto-api, .. of entropy, .. of cryptohash, .. of tls, .. of tls-extra, .. of http-enumerator
18:57:55 <Chewie[]> cmccann: yes i may use your version to check, thanks for the code =]  this is really an endeavor to understand though.
18:57:58 <identity_> so no profiling for me
18:58:00 <kmc> amusingly if you leave out "not (null left)" you still get finite partitions with non-empty elements
18:58:01 <identity_> and no solution to my problem
18:58:13 <kmc> there's just an infinite number of them and they have increasingly many empty elements ;P
18:58:19 <kmc> diagonalization ftw
18:58:19 <alpounet> identity_, cabal unpack semigroup
18:58:22 <alpounet> modify the cabal file
18:58:27 <alpounet> to enable library profiling
18:58:31 <identity_> ah, thanks
18:58:33 <alpounet> then cabal install
18:58:34 <identity_> I'll do that, but later
18:58:36 <alpounet> it should work
18:58:40 <identity_> it's 4 am, so I'm off to bed
18:58:47 <alpounet> oh, 4am for you too
18:58:48 <alpounet> :P
18:59:02 <dreamer_> i'm im compiling haskell platform
18:59:06 <dreamer_> to a package
18:59:11 <identity_> thanks for the help, I'm off.
18:59:17 <dreamer_> would i remove ghc package before installing platform?
18:59:20 <hpaste> kmc pasted “partitions (with permutations)” at http://hpaste.org/49156
18:59:42 <kmc> i think this is a consequence of my "diagonal" bisect
19:00:22 <kmc> nope, hmm
19:01:04 <kmc> there's at least three reasonable-sounding alternative base cases for 'partition'
19:01:28 <kmc> but i think this is the "right" one, wrt the rest of the algorithm
19:02:24 <Chewie[]> kmc: your bisect function is also slightly mindblowing...
19:03:37 <Chewie[]> kmc: but i understand, it basically builds the set of bisections two at a time and grows as n^2
19:03:51 <kmc> n^2?
19:04:11 <Chewie[]> hmm, that is a bad way to express what i am thinking.
19:04:26 <kmc> the way i see it, it grows as 2^n
19:04:29 <Chewie[]> i.e. with each recursion the number of bisections doubles.
19:04:33 <kmc> as you'd expect from a power-set function
19:04:37 <kmc> right, that's 2^n
19:05:04 <Chewie[]> simple mistake, forgive me.
19:05:12 <kmc> you are forgiven ;P
19:08:37 <Chewie[]> IMO the non-null should be enforced on bisect.
19:08:38 <kmc> if you're only after subsets (i.e. only want the first component of that pair) it's more common to write something like "let ys = bisect xs in ys ++ map (x:) ys"
19:08:55 <kmc> you mean "bisect [] = []" ?
19:09:23 <kmc> doesn't work for me
19:09:34 <Chewie[]> i.e. (a,b) <- bisect xs, not (null a), not (null b)
19:09:38 <Chewie[]> untested
19:09:50 <kmc> i think you need to allow at least one to be null
19:09:54 <Chewie[]> hmm.
19:10:01 <kmc> hmm, maybe this is why the python code only iterates to 2^n / 2
19:10:10 <kmc> so the top bit will always be 0
19:10:25 <Chewie[]> your understanding is king here.
19:12:48 <Chewie[]> it seems like the python code is taking an ordered bisection only.
19:13:06 <Chewie[]> if that makes sense.
19:13:16 <kmc> right
19:13:48 <Mathnerd314> I know Agda can compile to Haskell; are there any other languages targeting Haskell?
19:13:57 <kmc> python (see berp)
19:14:03 <kmc> disciple? or not?
19:14:25 <kmc> Chewie[], from a n-element input xs, mine produces (inter alia) the n! permutations of xs, expressed as n-way partitions into singletons
19:14:51 <Chewie[]> hmm
19:15:07 <kmc> i guess there is a way to do that without resorting to a set datatype
19:15:11 <kmc> but maybe not?
19:15:43 <Chewie[]> okay nevermind, i was confused on a point that i have now clarified.
19:16:06 <Chewie[]> for some reason i thought "i" was only taking on values like 1, 11, 111, 1111, 11111 (etc).
19:16:26 <Chewie[]> when that is obviously untrue and purely confusing.
19:16:38 <Mathnerd314> kmc: looks like disciple has its own compiler targeting LLVM and C
19:16:44 <kmc> ok
19:17:31 <kmc> epigram?
19:18:25 <Chewie[]> kmc: i am going to run with this for now so i can get the rest of the program done. can i BSDL your code? what kind of attribution do you want?
19:18:43 <Chewie[]> i will wrap my head around this some other time =P
19:20:59 <kmc> i hearby license that code under all of GPL2, GPL3, LGPL, AGPL, 3-clause BSD, 4-clause BSD, MIT, "public domain" (to the extent such a concept exists in your jurisdiction), and especially the WTFPL
19:21:17 <Mathnerd314> kmc: epigram homepage says to use Epic, which compiles straight to C
19:21:21 <kmc> ok
19:21:40 <Chewie[]> kmc: okay so i'm having enough trouble with recursive combinatorics and you want me to be a lawyer now?! =P
19:21:52 <kmc> :D
19:22:22 <kmc> http://sam.zoy.org/wtfpl/
19:23:53 <Chewie[]> that makes me smile =P
19:24:05 <kmc> http://cl.ly/5nAo
19:25:38 <cmccann> hahaha yes wtfpl
19:26:27 <Chewie[]> bahahaha the path to AGPL..
19:26:44 <kmc> my main objection to this chart is that it portrays LGPL as the sane alternative
19:26:48 * cmccann uses the wtfpl for short snippets of code as a protest against the idea of trivial stuff even needing a license
19:27:12 <confab> i just like that there's no way to get to lucent
19:27:27 <kmc> the best is when some company decides they need to audit licenses of all the code ever
19:27:51 <kmc> and a bunch of lawyers get paid $700 an hour to inspect in detail the WTFPL and the "buy me a beer if you're in town" license and whatever else
19:28:23 * cmccann chuckles at "But I'm from Sun" --> Not Anymore
19:28:38 <kmc> "/* Wirzenius wrote this portably, Torvalds fucked it up :-) */"
19:28:44 <kmc> "now, does that count as an attribution?"
19:29:27 <kmc> i wonder if "const True" can be considered a valid license
19:29:56 <kmc> like, a license establishes that, while you continue to hold the copyright to the work, you promise to answer certain questions of "can I do X" in a certain way
19:30:07 <kmc> so what if you promise to answer all questions with "yes"
19:30:17 <kmc> i guess this is basically the WTFPL
19:30:43 <Draconx|Laptop> kmc, will you answer all questions with "no"?
19:31:00 <kmc> yes
19:31:12 <kmc> > const True False
19:31:13 <lambdabot>   True
19:31:16 <kmc> that's an easy one
19:33:11 * cmccann releases code licensed as "you are free to do as you please with this code if, and only if, you violate the terms of this license"
19:34:56 <kmc> i am pleased that for once licenses were mentioned here without starting a big serious shitfit about GPL vs BSD
19:35:13 <Chewie[]> you're welcome. =P
19:35:18 <Mathnerd314> @let will_I_let_you x = True
19:35:19 <lambdabot>  <local>:4:0:
19:35:19 <lambdabot>      Warning: Pattern match(es) are overlapped
19:35:19 <lambdabot>               In...
19:35:35 <Mathnerd314> @let will_I_let_you x = True
19:35:36 <lambdabot>  Defined.
19:35:40 <Mathnerd314> > will_I_let_you "use my code"
19:35:43 <lambdabot>   True
19:36:49 <Mathnerd314>  /probably/ a valid license
19:37:29 <confab> sorry, i dont know if my last messages got sent
19:37:33 <confab> so i'm working my way through lyah, and the author does not seem to care much for list comps, being a pythoneer, I love them dearly, is this going to be something i'm going to have to get over?
19:37:34 <Chewie[]> we should define federal law in haskell.
19:37:41 <confab> what does the haskell community say?
19:38:06 <confab> i mean, I just saw kmc's example with a list comp
19:38:07 <mauke> confab: list comprehensions aren't that great but at least they're better than in python
19:38:11 <cmccann> confab, list comprehensions exist, you can use them, sometimes they're prettier to look at
19:38:14 <kmc> harsh mauke
19:38:15 <Chewie[]> confab: you can use list comprehensions all you want, just a matter of style as far as i've seen. there will be better ways that you have yet to find though.
19:38:19 <kmc> confab, i find them convenient sometimes
19:38:26 <kmc> there are other ways to do things
19:38:34 <kmc> Haskell is not like Python, there's not an Official One True Way
19:38:43 <confab> hmm
19:38:50 <confab> maybe that's what i'll have to get used to
19:38:53 <kmc> we generally avoid naming things when unnecessary
19:39:00 <cmccann> for expressions where I don't need to pattern match, I prefer regular expressions
19:39:08 <kmc> so like [x+1 | x <- xs] is worse than (map (+1) xs)
19:39:10 <kmc> and \xs -
19:39:11 <kmc> err
19:39:18 <cmccann> for very large expressions, I'd rather write it out as a do block instead of a list comprehension
19:39:24 <kmc> and «\xs -> map (+1) xs» is worse than «map (+1)»
19:39:39 <cmccann> and by regular expressions I mean normal everyday ones, not regexps
19:39:45 <kmc> but you can definitely go wrong with this "points free" style
19:40:10 <mauke> free the points!
19:40:44 * cmccann sends the points to the gulag
19:41:26 <confab> i see, thanks mauke cmccann Chewie[] kmc
19:42:04 <cmccann> confab, seriously though, nobody's going to put you on trial for using list comprehensions as long as they're readable
19:42:07 <kmc> basically, don't feel bad about using list comprehensions
19:42:32 <cmccann> it's mostly that in some cases there are tidier alternatives, i.e. simple expressions involving map, filter, etc.
19:42:33 <kmc> but try to think of alternatives and pick the clearest one, whichever it is
19:42:45 * Mathnerd314 is waiting for monad comprehensions
19:42:45 <kmc> #haskell is a great place to ask questions of the form "how do i express this more clearly"
19:42:54 <kmc> and the answer is different for every problem, of course
19:42:57 <kmc> Mathnerd314, they're in GHC HEAD
19:43:06 <kmc> party like it's 1990
19:43:07 <confab> yes, i'm starting to fall in love with map
19:43:09 <cmccann> kmc, you mean the answer is different for every person who answers
19:43:19 <kmc> Python has map too, but they have this weird complex where you're supposed to avoid it
19:43:32 <Mathnerd314> kmc: yeah, but I'm too lazy to build GHC, so I'm waiting for a release
19:43:32 <kmc> because the Fearless Leader was once touched inappropriately by lambdas, or something
19:43:43 <kmc> Mathnerd314, it's not hard, it just takes a long time and makes your computer rather warm ;P
19:43:45 * cmccann doesn't understand the insistence on needless verbosity that Python insists on for some things
19:43:50 <confab> i never used to use map, filter or reduce but i don't think i can go back to python and not use it
19:44:01 <Chewie[]> what are the practical implications of monad comprehensions? what do they look like? are they just list comprehensions generalized?
19:44:03 <kmc> GHC doesn't support parallel compilation yet, but GHC itself is built with make and not ghc --make ;P
19:44:07 <confab> also, i just want to say i really enjoy this channel
19:44:15 <kmc> Chewie[], same syntax as list comprehensions, generalized to other monads
19:44:17 <cmccann> Chewie[], list comprehensions for arbitrary monads basically
19:44:29 <cmccann> just like you can write do blocks for the list monad and they work like list comprehensions
19:44:32 <confab> the discussions are great, and there's not a lot of yelling if you ask a stupid question
19:44:36 <Mathnerd314> kmc: how warm? it's summer... I don't want my computer to melt :p
19:44:37 <cmccann> now it works the other way around
19:47:01 <Chewie[]> kmc, cmccann: sounds sexy.
19:47:16 <cmccann> hm, actually
19:47:30 <cmccann> Mathnerd314, you might be able to grab one of the snapshot builds
19:48:03 <cmccann> I just tried with one and it seems to handle monad comprehensions
19:48:19 <cmccann> as well as the class contexst equalities, which is what I was mostly after :P
19:48:22 <ion> By default or with -XMonadComprehensionsOrSomething?
19:48:37 <cmccann> with {-# LANGUAGE MonadComprehensions #-}
19:49:15 <thoughtpolice> superclass constraints are very recent, but they finally complete the TF story
19:49:28 <cmccann> thoughtpolice, yes, I am very happy about those
19:49:37 <cmccann> I still want closed type functions or some such though
19:49:41 <cmccann> :[
19:49:59 <cmccann> something to replace certain uses of overlapping instances, which were horrible but useful at times
19:50:20 <thoughtpolice> cmccann: spj says that the new coercions stuff in core (which made superclass constraints really easy to implement; previously they were very hard) has applications to many tantalizing new things in the future
19:50:35 * cmccann looks forward to it
19:50:42 <thoughtpolice> (i still want typekinds)
19:50:52 <ion> What do superclass constraints look like?
19:51:19 <cmccann> iom, same as always, it's the ability to put equalities in there that's new
19:52:03 <thoughtpolice> yeah, i really meant 'superclass equality constraints'
19:52:12 <Chewie[]> is there a built-in function to thread two lists together? i.e. [a] -> [b] -> [(a,b)] which gives all possible pairings of [a] and [b]?
19:52:21 <cmccann> e.g., consider: class (T1 a ~ b, T2 b ~ a) => C a b where { type T1 a :: *; type T2 b; ... }
19:52:24 <Chewie[]> easy to write but it seems like it would be built-in
19:52:37 <thoughtpolice> i.e. you can say 'class Bar a => Foo a', but *now* you can say 'class (Bar a ~ Baz) => Foo a', etc
19:52:40 <cmccann> Chewie[], the cartesian product is what you want?
19:53:04 <cmccann> > (,) <$> "abc" <*> "def"
19:53:05 <lambdabot>   [('a','d'),('a','e'),('a','f'),('b','d'),('b','e'),('b','f'),('c','d'),('c'...
19:53:09 <alpounet> > sequence [1..5] [6..10] -- Chewie[]
19:53:10 <lambdabot>   No instance for (GHC.Enum.Enum ([t] -> a))
19:53:11 <lambdabot>    arising from a use of `e_1156...
19:53:20 <alpounet> hm
19:53:25 <Chewie[]> cmccann: yes
19:53:32 <alpounet> > sequence [[1..5], [6..10]] -- Chewie[]
19:53:33 <lambdabot>   [[1,6],[1,7],[1,8],[1,9],[1,10],[2,6],[2,7],[2,8],[2,9],[2,10],[3,6],[3,7],...
19:53:41 <Chewie[]> alpounet: also yes
19:54:00 <cmccann> Chewie[], cartesian product is the generic behavior of the list monad
19:54:32 <cmccann> > [ (x, y) | x <- "abc", y <- "def" ]
19:54:33 <lambdabot>   [('a','d'),('a','e'),('a','f'),('b','d'),('b','e'),('b','f'),('c','d'),('c'...
19:54:48 <kmc> > liftM2 (,) "abc" "def"
19:54:50 <lambdabot>   [('a','d'),('a','e'),('a','f'),('b','d'),('b','e'),('b','f'),('c','d'),('c'...
19:54:53 <kmc> > liftA2 (,) "abc" "def"
19:54:54 <lambdabot>   [('a','d'),('a','e'),('a','f'),('b','d'),('b','e'),('b','f'),('c','d'),('c'...
19:54:58 <cmccann> and for homogeneous lists you can use sequence, as alpounet showed
19:55:33 <Chewie[]> okay kmc's version is the most clear so far.
19:55:46 <Chewie[]> cmccann's seems like the most general.
19:55:55 <cmccann> mine were all the same as kmc's
19:55:55 <ion> They’re both the same.
19:55:57 <confab> so to a seasoned haskeller, which seems the most clear of those?
19:56:01 <cmccann> different ways of the writing the same thing
19:56:16 <Chewie[]> i don't have a good Functor base though so cmccann's are less clear to me.
19:56:17 <ion> The definition of liftA2 f a b is f <$> a <*> b
19:56:20 <cmccann> > do { x <- "abc"; y <- "def"; return (x, y) }
19:56:21 <kmc> confab, if you just want the list of pairs, i'd go with liftM2 or liftA2 depending on which i happen to have in scope
19:56:22 <lambdabot>   [('a','d'),('a','e'),('a','f'),('b','d'),('b','e'),('b','f'),('c','d'),('c'...
19:56:42 <progrock> man, I got hakyll installed, but for some reasson its only copying my css files (not even my static js files~no error message that I could se :(
19:56:42 <Chewie[]> cmccann: holy crap that's cool! =P
19:56:58 <kmc> applicative is more "correct" -- after the apocalypse, when civilization is rebuilt from first principles, Monad will be a subclass of Applicative and you'll use liftA{n} in place of liftM{n} everywhere
19:57:06 <confab> cmccann: is it save to assume that's the do version of the list comp above?
19:57:09 <kmc> but if i have Control.Monad in scope and not Control.Applicative, fuck it
19:57:26 <ion> What, you don’t have Control.Applicative in scope? ;-)
19:57:30 <cmccann> confab, do notation in the list monad is basically the same as a list comprehension, so yeah it's the same thing
19:57:31 <confab> kmc: right over my head
19:57:49 <kmc> confab, read Typeclassopedia if you want to understand in detail
19:57:53 <confab> heh
19:58:06 <ion> http://heh.fi/haskell/functors/
19:58:41 <bos> yay, my latest changes to mwc-random make it 30% faster!
19:58:52 <kmc> nice
19:58:59 <cmccann> Chewie[], anyhow, the list monad basically means "try all possibilities, collect the results"
19:59:02 * kmc ♥ mwc-random, btw
19:59:10 <bos> https://github.com/bos/mwc-random/commit/6e83d217edd5231420bbfbec57768f00e3b4ca4f
19:59:11 <kmc> even the old, not-30%-faster version
19:59:24 <cmccann> so liftA2 means "lift a 2-argument function into the list monad", which means "apply it to each combination of both argument lists"
19:59:34 <kmc> @src liftM2
19:59:35 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
19:59:42 <bos> kmc: glad to hear it :-)
19:59:47 <kmc> or in list comprehensions, liftM2 f m1 m2 = [ f x y | x <- m1, y <- m2 ]
20:00:17 <confab> hmm
20:00:25 <confab> @src liftA2
20:00:25 <lambdabot> liftA2 f a b = f <$> a <*> b
20:00:26 <ion> “liftA2 f a b” means “f <$> a <*> b” which is equivalent to “pure f <*> a <*> b”
20:00:34 <Mathnerd314> hmm, monad comprehensions could just be applicative comprehensions
20:00:41 <kmc> not all of them
20:00:43 <confab> okat that makes ense
20:01:27 <confab> wait it doesnt'
20:01:35 <confab> oh wait it does!
20:01:39 <cmccann> heh
20:01:39 <ion> “a <*> b” runs the actions “a” and “b” sequentially, and its result value is the result function(s) of “a” applied to the result value(s) of “b”.
20:01:42 <confab> (,) is an operator?
20:01:45 <kmc> yes
20:01:46 <confab> awesome
20:01:47 <kmc> > (,) 2 3
20:01:48 <lambdabot>   (2,3)
20:01:52 <confab> wow
20:02:01 <confab> okay
20:02:01 <ion> :t pure (,)
20:02:03 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f (a -> b -> (a, b))
20:02:05 <ion> :t pure (,) <*> [0..2]
20:02:06 <cmccann> if you enable some extension you can get tuple slices, which are very pretty
20:02:06 <lambdabot> forall a b. (Num a, Enum a) => [b -> (a, b)]
20:02:09 <confab> i offically love haskell
20:02:11 <ion> :t pure (,) <*> [0..2] <*> [3..4]
20:02:12 <lambdabot> forall a a1. (Num a, Enum a, Num a1, Enum a1) => [(a, a1)]
20:02:28 <Chewie[]> confab: you can transform any infix operator into a function by putting into parentheses.
20:02:36 <cmccann> er, sections, I think is the right term. I can never recall for some reason
20:02:55 <confab> Chewie[]: right, i just didn't think of comma as an operator
20:02:57 <cmccann> :t (,True)
20:02:59 <lambdabot> Illegal tuple section: use -XTupleSections
20:03:03 <cmccann> pf
20:03:23 <cmccann> confab, it isn't exactly, it's special syntax that's baked in
20:03:24 <Chewie[]> confab: another fun operator is $
20:03:28 <parcs> :t (,,())
20:03:30 <lambdabot> Illegal tuple section: use -XTupleSections
20:03:44 <kmc> (,) is special syntax, though
20:03:55 <kmc> while ($) follows all the normal rules for user-defined infix operators
20:04:31 <Chewie[]> when i am making two-parameter functions and i don't know what the best name or param order is, i will usually think "hmm what if i use this in infix, how does it make sense then?"
20:04:52 <kmc> i'm not that big on TupleSections, just because I feel like a dick enabling a GHC extension to make one line of code 3 characters shorter
20:05:07 <kmc> Chewie[], yeah.  the killer app for infix operators is that you can section them on either side
20:05:08 <cmccann> > ($ 10) <$> [(`div` 2), (+ 3), (^ 2)]
20:05:09 <lambdabot>   [5,13,100]
20:05:12 <ion> I usually think “which one would i be more likely to want pointfree”
20:05:20 <luite> kmc: enabled it in your .cabal file ;)
20:05:21 <kmc> but i guess you can also do (`f` x)
20:05:24 <kmc> luite, ouch
20:05:32 <kmc> then nobody will read my code
20:05:35 <kmc> tower of fucking babel here
20:06:38 <kmc> "What, you didn't enable -XDeriveFlexibleTypeDirectedSynonymFamilySection?  Oh, you probably haven't heard of it.  It's a pretty new extension, still underground"
20:06:39 <cmccann> yeah my personal code tends to be pretty arcane anyway, I don't really worry about making it worse with GHC extensions
20:07:05 <cmccann> I try to tone it down when the code ends up in public though :P
20:07:06 <Chewie[]> i usually avoid extensions, makes me feel like i'm deviating from purity...
20:07:20 <kmc> Chewie[], the dirty secret is that nobody writes 100% compliant Haskell 98
20:07:29 <kmc> hierarchical module names aren't H98!
20:07:29 * Mathnerd314 just enables every extension by default
20:07:29 <confab> okay wait, i thought that $ was like a right associative parens, why do you use it in that line cmccann?
20:07:37 <luite> kmc: yeah long lists of extensions at the top of each file are better for intimidating readers
20:07:43 <cmccann> confab, because it's not ;]
20:07:44 <cmccann> :t ($)
20:07:46 <lambdabot> forall a b. (a -> b) -> a -> b
20:07:46 <kmc> confab, it's an ordinary user-defined infix operator, with low precedence and right associativity
20:07:48 <kmc> @src ($)
20:07:49 <lambdabot> f $ x = f x
20:07:59 <kmc> luite, i try to list each one about three or four times just for effect
20:08:18 <kmc> > zipWith ($) [succ, pred] [10, 20]
20:08:18 <kfish> hipster hackers love obscure extensions
20:08:20 <lambdabot>   [11,19]
20:08:43 <confab> okay, i'll have to read up on that again
20:08:45 <kmc> Haskell *is* the ultimate hipster language.  we talk all day about how everyone else is dumb for not liking it, yet we also want it to "avoid success" and stay indie
20:09:10 <confab> might also explain why i lack the intuition to use it properly
20:09:15 <kmc> well, *I* talk all day.  y'all have better  things to do
20:09:32 <Chewie[]> lol.
20:09:34 <Mathnerd314> kmc: there's some way to quote that, right?
20:09:38 <cmccann> also we have obscure injokes, that helps too
20:09:39 <luite> kmc: make sure that you have a slightly different list for each file so that it looks like you've carefully selected the best extensions, instead of just a standard copy/pasted list
20:09:42 <Chewie[]> like optimizing wood construction problems. =p
20:10:07 <kmc> back in my day we just had -fglasgow-exts
20:10:08 <luite> two-dimensional?
20:11:30 <kmc> -fglasgow-exts -fedinburgh-exts -fdundee-exts
20:11:31 <Mathnerd314> kmc: maybe it could be revived as {-# LANGUAGE GHC #-}
20:11:57 * cmccann notes that meta-humor injokes consist of jokes about jokes; given any joke, you can create a meta-joke referencing it; and a joke referencing another injoke transitively references the original as well
20:12:17 <cmccann> ergo, meta-humor is a monad
20:12:20 <cmccann> qed
20:12:22 <kmc> itym {-# LANGUAGE GHC_7_1_2011_07_17 #-}
20:12:29 <kmc> :O
20:12:33 <kmc> cmccann, !!
20:14:27 <tommd> Isn't the real question about how much humor is in a monad, not how monadic certain forms of humor are?
20:17:15 <cmccann> tommd, I don't think humor is specified by the monad laws, so they're probably not funny at all
20:17:43 <sanjoyd> return lifts an ordinary joke to a meta joke. join collapses a meta meta joke to a meta joke ?
20:18:10 <cmccann> sanjoyd, yes, that was the idea :]
20:18:36 * cmccann handwaved the definition of fmap in there but it can probably be made to work somehow
20:20:00 <cmccann> I suppose a function would be regarded as representing a comedy routine, with function application telling one joke as set-up for the next
20:20:47 <kmc> "so there's an infinite number of parallel universes, eh?"
20:20:50 <kmc> "nope, just the two"
20:23:22 <danharaj> what if we're in hyperbolic metaspace?
20:23:44 <hpaste> “C. McCann” pasted “testing a monad comprehension” at http://hpaste.org/49158
20:23:47 <cmccann> heh
20:23:56 <cmccann> that's not obfuscated at all
20:24:16 <cmccann> but it works! that is the important thing.
20:25:04 <gwern> @quote Neo
20:25:05 <lambdabot> gwern says: Unfortunately Neo, no one can be *told* what the Monad is.
20:25:13 <monochrom> heh
20:25:27 <cmccann> @quote monad
20:25:27 <lambdabot> revenantphx says: My monads are itchy.
20:25:30 <cmccann> @quote monad
20:25:30 <lambdabot> lilac says: class Monad m where / return and Kleisli compose / must form a monoid
20:25:36 <cmccann> ha
20:25:42 <cmccann> @quote monad
20:25:43 <lambdabot> shapr says: [on causing trouble in #java] I told a java newbie to use a parser monad...
20:25:51 <cmccann> @quote monad
20:25:52 <lambdabot> Boney says: "Im in ur monads, changing ur state"
20:32:03 <confab> wait how does that quote work?
20:32:11 <cmccann> confab, ?
20:32:17 <confab> i guess a better querstion is, how does lambdabot work?
20:32:20 <Boney> hrm, I barely remember that.
20:32:22 <confab> is it parsing every line at all times?
20:32:34 <cmccann> no, you can tell lambdabot to remember things
20:32:35 <kmc> confab, no, you add stuff with @remember
20:32:38 <Boney> confab: I think people explicitly recorded those quotes.
20:32:38 <confab> ah
20:32:40 * hackagebot tremulous-query 1.0.2 - Library for polling Tremulous servers  http://hackage.haskell.org/package/tremulous-query-1.0.2 (ChristofferOjeling)
20:32:43 <kmc> lambdabot does in general parse every line that comes to the channel
20:32:46 <kmc> to scan them for commands
20:32:50 <kmc> but they don't get stored
20:32:57 <cmccann> @quote kmc
20:32:58 <lambdabot> kmc says: most CS courses will teach you four kinds of Java
20:33:01 <cmccann> @quote kmc
20:33:02 <lambdabot> kmc says: you see a lot of Rubyists who associate static typing with C++ lunacy or Java's kingdom of nouns, and thus refuse on principle to have any idea what their programs do before they run
20:33:02 <lambdabot> them
20:33:10 <kmc> (the logbot is clog)
20:33:24 <kmc> yeah, all of my quotes are inflammatory statements about other programming languages
20:33:25 <kmc> classy, i know
20:33:29 <cmccann> people like kmc who spend a lot of time in here tend to get lots of quotes remembered ;P
20:33:32 <luite> hehe
20:33:34 <cmccann> @quote kmc
20:33:35 <lambdabot> kmc says: i am Jack's monad operator
20:33:38 <danharaj> @quote danharaj
20:33:38 <lambdabot> danharaj says: phd programs are one-way functions. They're easy to get into and hell to get out of ;)
20:33:41 <kmc> i was freaked the first time i was quoted in HWN
20:33:50 <kmc> haha danharaj
20:33:55 <kmc> isn't it kind of the opposite?
20:33:57 <danharaj> Past me is a pretty cool guy.
20:34:08 <confab> haha
20:34:09 <kmc> eh makes quote and doesn't afraid of anything?
20:34:14 <danharaj> let's find out
20:34:16 <danharaj> @quote danharaj
20:34:16 <lambdabot> danharaj says:  The industry wields types like an ancient weapon of forgotten technology.
20:34:25 <kmc> haha
20:34:28 <kmc> brilliant
20:34:40 <luite> I tried to explain some of the advantages of haskell in #coffeescript and someone said "I'd use erlang for concurrency and ocaml for static typing" - must be fun having a separate langauge for each feature :)
20:35:27 <confab> hmm
20:35:33 <confab> is there a random feature for quote?
20:35:36 <danharaj> I wonder what else I said.
20:35:39 <danharaj> let's find out
20:35:40 <danharaj> @quote
20:35:41 <lambdabot> DanielFranke says: Genuine quote from my old logic professor: “Haskell? Oh, must be named for Haskell Curry. Good guy. I dated his daughter.”
20:35:44 <danharaj> yes there is.
20:35:46 <confab> nice
20:35:48 <kmc> haha
20:35:53 <danharaj> Wait, we have to be scientific. Our sample size is too small.
20:35:54 <danharaj> @quote
20:35:55 <lambdabot> shepheb says:  I've got a Spanish test at 11:30 that I should be studying for now instead of reading proggit.
20:36:00 <luite> hehe
20:36:04 <danharaj> Ok. Now it's big enough for me.
20:36:40 <danharaj> @quote danharaj
20:36:40 <lambdabot> danharaj says: unsafeCoerce should be renamed to badPun
20:36:55 <kmc> there's your meta-joke
20:37:00 <danharaj> Either I was once clever, or people are really good at selecting favorable quotes.
20:37:11 <confab> both?
20:37:11 <cmccann> @quote cmccann
20:37:12 <lambdabot> cmccann says: programming is a lot easier if you avoid working with dates/times, text, or numbers. I say stick to category theory, it's simpler
20:37:19 <cmccann> @quote cmccann
20:37:20 <lambdabot> cmccann says: programming is a lot easier if you avoid working with dates/times, text, or numbers. I say stick to category theory, it's simpler
20:37:20 <danharaj> heh
20:37:20 <kmc> so true!
20:37:27 <kmc> edwardk has it figured out
20:37:40 <kmc> after working on compilers, graphics, numerics, telco operations, and whatever the fuck else
20:37:43 <danharaj> I think those three things are probably the hardest 'real world' crap programmers have to deal with.
20:37:53 <cmccann> danharaj, yes
20:38:06 <danharaj> @quote edwardk
20:38:07 <lambdabot> edwardk says: shapr is the only person i know of who just decides to drive across the country with a car full of machetes
20:38:08 <cmccann> where text and numbers should be taken to mean "unicode" and "floating point"
20:38:14 <cmccann> if that wasn't obvious from the joke ;]
20:38:21 <danharaj> Unicode and time are pretty hard.
20:38:25 <danharaj> Floating point *shouldn't* be hard
20:38:32 <kmc> backwards compatibility and concurrency are responsible for most of the bugs in the Linux kernel
20:38:44 <danharaj> But people ride loose and dirty with IEEE754 riding shotgun.
20:38:48 <kmc> bad or nonexistent hardware documentation is probably pretty far up there
20:39:03 <cmccann> danharaj, the problem is that people want to treat floats as if they were numbers, which is wrong
20:39:10 <danharaj> well, as fields.
20:39:12 <danharaj> as a field.
20:39:28 <cmccann> I'm not sure what concept of "number" they make sense as
20:39:34 <cmccann> since addition isn't associative, for instance
20:39:39 <cmccann> equality is not reflexive
20:39:51 <cmccann> they don't have a total order
20:40:25 <cmccann> etc., etc.
20:41:47 <danharaj> well equality is equality provided your input is some N bits and your calculation has F(N) bits to work with, where F is a function determined by your algorithm.
20:42:20 <confab> hmm so lambdabot seems pretty interesting, is this someone's pet project, or a community effort?
20:42:21 <cmccann> > let x = (0/0) in x == x
20:42:23 <lambdabot>   False
20:42:28 <danharaj> oh, and that.
20:42:31 <danharaj> that totes doesn't count :p
20:42:38 <cmccann> NaN breaks everything
20:42:44 <danharaj> 'breaks'
20:42:51 <cmccann> and is misleadingly named, in that it implies that the other values are numbers
20:43:04 <danharaj> NaN is an indicator that something is broken.
20:43:18 <cmccann> no, NaN has a perfectly sensible and well-defined semantics in calculations
20:43:31 <cmccann> it's just that those semantics don't match any standard concept of numbers
20:43:50 <cmccann> but  actually work very well for certain kinds of computation if you know what you're doing
20:44:03 <danharaj> ah, but normal floating values do behave as numbers provided you have enough bits of precision to work with.
20:45:17 <cmccann> not if the exponent has a sufficiently large number of bits vs. the mantissa
20:45:30 <cmccann> since that gets you the associativity issue
20:46:06 <danharaj> true.
20:46:12 <danharaj> multiplication behaves better than addition
20:46:20 <cmccann> basically how it ends up is that it only works if your floating points are close enough in magnitude that you could have just used fixed point math
20:47:35 <cmccann> also, NaN has a tendency to mess things up in subtle ways if you don't account for it, so it's not like you can just pretend it's not there
20:48:00 <luite> danharaj: but not everything is exactly representable in floating point numbers
20:48:32 <danharaj> anyway
20:48:39 <danharaj> I just think that unicode and time are way harder than floating point.
20:48:47 <danharaj> Even if floating point is quite a bit harder than anything other than those.
20:49:04 <hpaste> “C. McCann” pasted “hooray for NaN” at http://hpaste.org/49159
20:49:31 <danharaj> wow that's
20:49:38 <danharaj> hilarious
20:49:46 <cmccann> I do agree though, the difference is that floats have a method to the madness and make sense in a way that's useful if you use them right
20:50:04 <cmccann> date/time and general text are just ridiculous and not sensible at all
20:50:05 <copumpkin> I don't think NaN /= NaN was a good idea
20:50:09 <copumpkin> at all
20:50:18 <copumpkin> I can see why you'd want the value in there
20:50:25 <copumpkin> but the self-inequality is dumb
20:50:41 * cmccann shrugs
20:50:50 <kmc> the real numbers are a ridiculous construction, of course you should expect something broken if you try to represent them in a computer
20:50:52 <cmccann> I can see why it makes sense in some cases as well
20:51:09 <Yrogirg> Am I right that types in Haskell are first-class objects?
20:51:13 <kmc> no
20:52:06 <cmccann> danharaj, anyway, credit where do, I swiped the NaN example from a message on haskell-cafe, and modified it slightly (using Data.Set instead of sorted lists)
20:52:12 <cmccann> where due, even, ugh
20:52:43 * copumpkin slaps cmccann 
20:52:55 <danharaj> Types aren't first class citizens in Haskell, but at least they have green cards.
20:53:01 <cmccann> copumpkin, :[
20:53:20 <copumpkin> types are almost first-class citizens in agda
20:53:29 <copumpkin> although in some sense, they aren't still
20:53:30 <Yrogirg> and did anybody here have experience with languages where types are first-class objects? What are the benefits?
20:53:41 <dainanaki> Hello all, I'm trying to load up a haskell library that exports a function to be used from C, and I am getting an error saying Symbol not found: _alloc_blocks_lim
20:53:44 <copumpkin> Yrogirg: I don't even know what that would mean, in the most general sense
20:53:49 <kmc> Yrogirg, there are a lot of vastly different languages with that property
20:53:50 <copumpkin> except maybe the planned features of epigram 2
20:54:00 <kmc> types are first-class in Python, because they only exist at runtime
20:54:03 <dainanaki> Does anyone know where that symbol is supposed to be coming from?
20:54:06 <kmc> that makes them useless for static proving of anything
20:54:19 <danharaj> dainanaki: That sounds like something that lives in the run-time system.
20:54:22 <Yrogirg> I've just started learning Aldor, it is said types are first-class objects there
20:54:22 <kmc> types are (nearly?) first-class in Agda, because an evaluator exists at compile-time
20:54:31 <kmc> which makes them very useful for static proving, vastly more useful than Haskell's types
20:54:31 * cmccann thinks it doesn't make sense to call runtime metadata tags "types"
20:54:39 <danharaj> dainanaki: Hopefully someone who is familiar with GHC is around to elucidate the situation.
20:54:52 <copumpkin> Yrogirg: the question is
20:54:56 <copumpkin> why do you want them to be?
20:55:00 <kmc> dainanaki, uh -lHSrts or something?
20:55:03 <kmc> a guess
20:55:03 <cmccann> "types" in Python etc. are really not the same thing as "types" in Haskell
20:55:06 <cmccann> like, at all
20:55:10 <copumpkin> python has one type
20:55:12 <kmc> yeah, they are distantly related at best
20:55:14 <copumpkin> in the haskell sense
20:55:16 <kmc> PyObject* :D
20:55:21 <copumpkin> yeah
20:55:27 <kmc> i think *some* useful comparisons can be drawn between the two
20:55:42 <kmc> for example, I'd really love to have algebraic data types and pattern-matching in Python, even if there is zero static checking
20:55:45 <dainanaki> kmc, that did the trick I think!
20:55:52 <kmc> cool!
20:55:56 * kmc is a little surprised
20:55:57 <cmccann> copumpkin, right, hence the term "unityped" as some prefer
20:55:57 <dainanaki> thanks, I've been tearing my hair out.
20:56:03 <Yrogirg> >copumpkin: why do you want them to be?
20:56:03 <Yrogirg> they are that in Aldor, i'm learning it. I was wonder what would be the differences to haskell in that way.
20:56:20 <danharaj> kmc: what does that flag do?
20:56:32 <kmc> links in the C library named HSrts
20:56:36 <danharaj> heh
20:56:43 <danharaj> so it links in the rts?
20:56:43 <kmc> i.e. libHSrts.a or libHSrts.so.*
20:56:46 <kmc> yes
20:56:55 <kmc> i'm not sure what the FFI spec says you should do
20:57:04 <kmc> if there's some portable way to know what the compiler flags should be
20:57:10 <kmc> but this should work for GHC
20:57:19 <danharaj> the FFI is only a specification in one direction, isn't it?
20:57:25 <kmc> how do you mean?
20:57:28 <kmc> dainanaki, as an aside, Cabal is great for building mixed-language projects
20:57:40 <kmc> i don't know if it works in your case, but it does take care of a lot of linker bullshit for you
20:57:43 <danharaj> kmc: It describes how to interface from Haskell to foreign code, not foreign code to Haskell.
20:57:57 <kmc> -lHSrts may require some -L flag, which will depend on the system, blah blah
20:57:58 <dainanaki> kmc, thanks, but I'm just experimenting right now
20:58:02 <cmccann> > sort [0,-1,0/0,-5,-6,-3,0/0,-2]
20:58:04 <lambdabot>   [-6.0,-5.0,-3.0,-2.0,NaN,NaN,-1.0,0.0]
20:58:12 <cmccann> hm
20:58:14 <kmc> danharaj, I think "interface" is symmetric
20:58:18 <wli> Possibly also haddock bullcrap too.
20:58:24 <kmc> danharaj, it has both "foreign import" and "foreign export" if that's what you mean
20:58:30 <danharaj> oh, it does?
20:58:35 <copumpkin> yeah
20:58:35 <danharaj> I did not know that.
20:58:48 <cmccann> > compare (0/0) (0/0)
20:58:50 <lambdabot>   GT
20:59:33 <kmc> the GHC manual seems to think it specifies the C-side interface
20:59:47 <kmc> e.g. http://www.haskell.org/ghc/docs/latest/html/users_guide/ffi-ghc.html#using-own-main
21:00:00 <kmc> note that parts of the C are in #ifdef __GLASGOW_HASKELL__ and parts are not
21:00:15 <kmc> but i'm not sure where the "standard" bits come from -- they weren't in the H98 FFI Addendum, from a cursory glance
21:00:43 <kmc> dainanaki, you may want to look at that manual section too
21:00:48 <kmc> §8.2.1.2
21:00:53 <dainanaki> thanks, will do
21:08:44 * hackagebot verilog 0.0.0 - A Verilog parser.  http://hackage.haskell.org/package/verilog-0.0.0 (TomHawkins)
21:13:19 <Chewie[]> is there a way to "pretty-print" a complex, nested data structure involving tuples and lists?
21:13:36 <cmccann> how do you want to print it?
21:13:40 <kmc> @hackage groom
21:13:41 <lambdabot> http://hackage.haskell.org/package/groom
21:13:43 <kmc> Chewie[], ^^^^^
21:14:08 <Chewie[]> cmccann: i don't care so much that's it's worth it to write a function for it. mostly just want indentation
21:14:27 <cmccann> then you want exactly what kmc linked to
21:15:10 <kmc> theres another lib like that on hackage
21:15:13 <kmc> but this one has a memorable name ;P
21:15:52 <Chewie[]> installing. looks promising.
21:17:56 <bos> groom is nice.
21:18:31 * cmccann thinks groom needs a counterpart named "bride"
21:18:57 <cmccann> I'd write one but I have no idea what it would do differently from Read, since that already handles whitespace :T
21:34:42 <dncr> and a generalization, spouse
21:36:47 * hackagebot digestive-functors-hsp 0.4.5 - HSP support for digestive-functors  http://hackage.haskell.org/package/digestive-functors-hsp-0.4.5 (JeremyShaw)
21:37:37 <Rotaerk> that just sounds yummy.
21:37:52 <Rotaerk> makes me think of sphincters
21:38:19 <wli> Sea cucumbers?
21:40:52 <Chewie[]> kmc: for the record i now have a working program
21:40:55 <Chewie[]> but.
21:41:17 <Chewie[]> for 7 boards and 2 types of lumber, it takes 20 seconds to compute.
21:41:27 <Chewie[]> average 19 boards, 4+ types of lumber.
21:41:30 <Chewie[]> time to optimize!
21:41:36 <kmc> well, there are a lot of partitions ;P
21:41:39 <luite> what kind of optimization problem is it?
21:41:56 <kmc> you should use some kind of high-powered and/or cargo-cult generalized optimization algorithm
21:41:58 <Chewie[]> luite: i wrote code stupid.
21:42:23 <kmc> use genetic programming to train an SMT solver to do convex optimization on an SVM kernel
21:42:37 <kmc> that's the way to cut wood
21:42:38 <cmccann> ah yes, making code not stupid. the most fiendish optimization problem known to humanity :[
21:42:41 <Chewie[]> kmc: i'm willing to give it a go if you can give me sufficient references to actually make it happen.
21:42:47 <kmc> hmm
21:42:54 <kmc> this might be a case for max-sat
21:43:03 <kmc> dunno much about that
21:43:07 <cmccann> alternatively, buy a faster computer
21:43:13 <Chewie[]> it is really an optimal fitting problem.. probably NP hard or whatever.
21:43:18 <cmccann> that's how professionals solve optimization problems
21:43:22 <Chewie[]> cmccann: i think i'd need a MUCH faster computer.
21:43:33 <luite> Chewie[]: yeah, but those problems are often similar
21:43:37 <cmccann> yes, you may need to be VERY professional about it
21:43:48 <Chewie[]> like, i have a feeling the computation with real params would take, like, 10+ hours and run me out of memory many times over ;P
21:43:53 <Chewie[]> i wrote powerfully stupid code.
21:44:07 <luite> Chewie[]: do you have a simple explanation of the problem somewhere?
21:44:18 <Chewie[]> luite: yes, let me spend 30 seconds writing it.
21:44:44 <Chewie[]> i have a cookie-cutter model of a loft structure that i have made for 3-4 people now. it is constructed with 2x4s.
21:45:04 <Chewie[]> when i go to the lumber yard i usually make a good guess on what to buy based on experiental knowledge.
21:45:13 <Chewie[]> to formalize, i need like 19 boards of different, known lengths.
21:45:25 <Chewie[]> and i can buy 2x4s in different lengths at different costs.
21:45:41 <kmc> sounds like knapsack problem
21:45:41 <Chewie[]> i want to minimize cost by optimally buying wood.
21:46:27 <luite> kmc: bin packing actually
21:46:58 <cmccann> cf. http://en.wikipedia.org/wiki/Bin_packing_problem
21:47:12 <cmccann> sound about right, Chewie[]?
21:47:28 <Chewie[]> http://en.wikipedia.org/wiki/Cutting_stock_problem
21:47:56 <luite> yeah cutting stock is slightly simpler, but it's a generalization of that
21:48:22 <cmccann> cutting stock would be if you already had the wood and wanted to use it efficiently, I think
21:48:25 <luite> the delayed column generation approach for cutting stock might still be applicable here
21:49:42 <Chewie[]> hmm.
21:50:07 <Chewie[]> bin packing problem doesn't seem right because it is really a process of selecting bins as well as selecting their contents.
21:50:12 <adxp> what's the best way to convert a CInt (which is a pointer) to a Ptr a, without changing the type signatures of the underlying functions? (presumably latter is the *right* way)
21:50:35 <ash__> anyone have experience with vim's haskell syntax?
21:50:45 <ash__> mines all funky... and its finally bothering me enough to ask about it
21:51:09 <Chewie[]> ash__: what does funky mean?
21:51:13 <ash__> and by funky i mean it only highlights {- -} comments and "quoted strings"
21:51:24 <ash__> everything else is unformatted
21:51:24 <luite> adxp: that sounds like a unsafeCoerce
21:51:46 <luite> adxp: though a CInt can usually not be a pointer on x86-64
21:51:47 <Chewie[]> ash__: does ":set syn" display haskell?
21:51:57 <ash__> ya
21:52:15 <adxp> luite: unsafeCoerce sounds like exactly what I want, thanks
21:52:35 <Chewie[]> ash__: i've had that happen before, but closing+reopening has always fixed. is the hs syntactically valid?
21:52:59 <Chewie[]> i'm assuming you've tried reopening, different :colo(rscheme)s
21:53:15 <luite> adxp: but keep in mind that it's rather unsafe and possibly very unportable :)
21:54:03 <ash__> Chewie[]: ya, the file compiles, TextMate shows it fine with its syntax highlighting, so does Leksah, and i have tried closing and reopening
21:54:23 <adxp> luite: understood, thanks :). might ask your thoughts about a better solution if you have a moment...
21:55:51 <Chewie[]> ash__: ask #vim yet? i'm out of ideas
21:56:01 <ash__> alright, i'll try there
22:01:55 <copumpkin> I wonder why Foldable doesn't have a generic null function
22:08:06 <c_wraith> hmm.  I guess it could.
22:08:49 <c_wraith> null = foldr (\ _ _ -> True) False
22:08:55 <copumpkin> yep
22:09:02 <copumpkin> oh vice versa
22:09:14 <c_wraith> err, yes
22:09:14 <c_wraith> null, full
22:09:14 <c_wraith> whatever
22:09:17 <c_wraith> :)
22:11:50 * hackagebot vty 4.7.0.4 - A simple terminal access library  http://hackage.haskell.org/package/vty-4.7.0.4 (CoreyOConnor)
22:18:58 <elliott> Are there any active projects to write a Haskell/Java bridge using JNI? All the ones I can find are bitrotten.
22:21:04 <dobblego> why does Data.Iteratee.Base.Iteratee have instance (Functor m, Monad m) => Functor (Iteratee s m) when the implementation doesn't use the Monad constraint?
22:22:55 <edwardk> because someone likes passing around wasteful instances
22:22:55 <lambdabot> edwardk: You have 4 new messages. '/msg lambdabot @messages' to read them.
22:23:25 <edwardk> @tell copumpkin yeah. reactor is currently broken
22:23:26 <lambdabot> Consider it noted.
22:23:31 <copumpkin> aha
22:23:31 <dobblego> so it's an oversight you think? or some kind of "good idea" that I am missing?
22:23:32 <lambdabot> copumpkin: You have 1 new message. '/msg lambdabot @messages' to read it.
22:23:36 <copumpkin> bos wanted to use it :)
22:23:39 <copumpkin> or rather
22:23:47 <copumpkin> I suggested he use it because he wanted a nice parallel thingy
22:23:54 <edwardk> dobblego: its a bad idea caused by someone wanting to enforce a style of use with a spurious constraint
22:24:10 <dobblego> edwardk: oh even worse than I thought
22:24:16 <dobblego> thanks
22:24:27 <edwardk> it needs a lot of work, its just a sketch of a design right now
22:24:36 <bos> ah
22:25:15 <edwardk> even once you get it to compile there are places i know its broken, for instance, it needs to do a lot more intelligent queuing for replay in some areas
22:26:23 <hpaste> NemesisD pasted “Verbose Monad” at http://hpaste.org/49162
22:27:00 <kmc> NemesisD, typically "x <- return y" is better written "let x = y"
22:27:14 <NemesisD> is there a way I can make that a little more compact? I pull bind a bunch of values in the monad only to put them all into a record result
22:27:20 <dobblego> edwardk: I can't even think of the bad idea that would let someone think this bad idea is a good idea, do you know the path of reason?
22:27:32 <copumpkin> you even get a Monad constraint on the foldl
22:27:33 <NemesisD> kmc i know, it was mostly for visual consistency, i'm going for something that looks sort of declarative
22:27:37 <copumpkin> foldl :: (Monad m, ListLike s el, FoldableLL s el) => (a -> el -> a) -> a -> Iteratee s m a
22:27:43 <kmc> oh, well, "return" is the opposite of declarative to me
22:27:52 <seafood> Mutually recursive modules. Are they ever used in practice?
22:28:02 <kmc> NemesisD, you could use liftM9
22:28:08 <kmc> (except idon't think they go that high)
22:28:33 <kmc> but you could say "Artist <$> (el !<@> "id") <*> (el !<|> "name") <*> ... "
22:28:50 * kmc doesn't know what to make of an infix operator named !<//|>
22:28:54 <NemesisD> kmc: ah yeah thats a possibility
22:29:05 <kmc> NemesisD, you could also use RecordWildCards
22:29:40 <copumpkin> or just the <$> / <*>
22:29:43 <kmc> do { artistName <- foo; artistId <- bar;... return Artist { .. } }
22:29:59 <NemesisD> kmc: it makes sense to me lol. the <> bit on those are to indicate it is operating on xml. ! prefix means the value is required. | gets the content of the node. those silly operators aren't exported anyhow
22:30:09 <edwardk> kmc: man, and i thought _i_ had some obscure operator names ;)
22:30:43 <copumpkin> or idiom brackets in SHE
22:30:44 <copumpkin> mmm
22:30:58 <copumpkin> those would save you from annoying pures or lambdas
22:32:49 <NemesisD> i.e. some of them have ?, that means it is optional. the ones with // are for specifying paths (sort of like XPath)
22:33:23 <NemesisD> she?
22:33:34 <copumpkin> the strathclyde haskell enhancement
22:36:23 <NemesisD> i think ill just try <$> / <*> for a while, rage when I can't get it to compile, then leave it how it was
22:36:53 <copumpkin> it's fairly mechanical to translate
22:39:14 <NemesisD> to she? probably, but i don't really want to put a dependency on a preprocessor in the project and learn the novel syntax
22:39:31 <copumpkin> oh I mean it's mechanical for both
22:39:38 <copumpkin> if you want to use <$> or <*>
22:39:41 <copumpkin> or she
22:39:59 <NemesisD> ohh
22:40:30 <NemesisD> vim is good at such mechanical coding ;)
22:41:04 <sp3ctum> what do you think of vim's support for haskell? i'm just starting with haskell and don't really know
22:41:31 <sp3ctum> i downloaded some plugins for it and it seemed all right for newbie hacking to me
22:41:38 <nihtml> i really prefer the emacs' haskell-mode
22:41:41 <copumpkin> omg a TacticalGrace
22:41:53 <kfish> TacticalGrace, welcome back
22:42:00 * copumpkin eats kfish 
22:42:10 <kfish> yow!
22:42:26 <copumpkin> perhaps I should stop eating people I've never met
22:42:42 <NemesisD> it works fine for me. my day job is ruby. i'm used to working with an editor rather than an ide like leksah, and i'm way too dialed into modal editing to use something like emacs
22:42:50 <kmc> @remember copumpkin perhaps I should stop eating people I've never met
22:42:50 <lambdabot> Done.
22:43:05 <sp3ctum> :)
22:43:14 <kfish> copumpkin, that's ok, i'll add you to my eaters circle on g+
22:43:14 <kmc> i hear emacs has a vim keybinding mode
22:43:20 <copumpkin> kfish: lol
22:43:20 <kmc> but it probably sabotages your code subtly
22:43:27 <kmc> like, inserts backdoors that will get you fired
22:43:32 <NemesisD> yeah viper mode. a poor substitute
22:44:32 <kfish> copumpkin, ok done, now go read my food spam lol :)
22:45:06 <copumpkin> food spam :o
22:45:19 <copumpkin> oh wow
22:45:34 <NemesisD> i'm a lost cause. i browse with VImium, use vi-mode in my readline in my shell, edit with vim, use gmail with vi-like bindings...
22:45:45 <copumpkin> man I miss japan
22:45:54 <applicative> wow, that is a verbose do block, NemesisD
22:46:02 <NemesisD> applicative: it sure is!
22:46:09 <copumpkin> applicative: that's the best kind!
22:46:13 <copumpkin> remember
22:46:14 <NemesisD> thanks to control.you i should be able to cut it down quite a bit
22:46:15 <applicative> oh yes
22:46:20 <copumpkin> if you write code that's too clever, you won't be able to debug it
22:46:25 <copumpkin> kernighan said it so it must be true
22:46:45 <applicative> Yes,I see what copumpkin meant suggesting applicative
22:46:47 <sp3ctum> NemesisD, me too, except i use pentadactyl for firefox. it's basically the same thing i guess
22:47:04 <copumpkin> omg it's a more up-to-date TacticalGrace
22:47:06 <cmccann> it tends to be other way around in Haskell, you have to write code clever enough that it can debug you
22:47:43 <TacticalGrace> copumpkin: ;)
22:47:47 <TacticalGrace> kfish: hey
22:47:57 * TacticalGrace yawns.
22:48:05 <kfish> TacticalGrace, ready to party?
22:48:06 <copumpkin> kfish: what's yum?
22:48:06 <applicative> I'm not sure this wisdom applies to Haskell.  Parsec is pretty clever to take a standard example
22:48:25 <kfish> copumpkin, it's all yum
22:48:27 <NemesisD> to haskell's credit, i've never thrashed for so long on a problem and still felt productive
22:48:37 <copumpkin> oh, I see
22:48:46 <danharaj> debugging Haskell is completely different from debugging something like C, unless you're doing FFI work.
22:48:49 <copumpkin> NemesisD: haskell just lowered your standards
22:49:33 <copumpkin> as I was just telling #scala, I tried to write hello world in haskell today, but GHC gave me "Error: You do not have a Ph.D. in Category Theory"
22:49:44 <danharaj> heh
22:50:04 <copumpkin> haskell is too impractical
22:50:06 * copumpkin goes back to agda
22:50:12 <danharaj> Hello World is the initial object in the category of programs people write.
22:50:52 <kmc> copumpkin, yeah, i had to forge my PhD to get GHC to run
22:50:58 <copumpkin> in the order category arising from the programs ordered by the time when they write them?
22:51:01 <kmc> put a post-it note on my BS diploma
22:51:14 <copumpkin> kmc: ah, good idea
22:51:20 <copumpkin> now I just need to find my diploma
22:51:27 <NemesisD> i dunno, i like thinking about haskell despite my paltry BS degree
22:51:37 <copumpkin> I wonder if a high school diploma would fool it
22:51:41 <copumpkin> can't find my college one
22:51:47 <NemesisD> i don't know who in here said it, but haskell "makes hard problems easy and easy problems a lax monoidal endofunctor"
22:51:57 <NemesisD> or something...
22:52:04 <copumpkin> lol
22:52:11 <applicative> Just put a comment to GHC that the IO monad arises from the adjunction of (RealWorld, _) and (RealWorld -> _)
22:52:14 <danharaj> wait, so easy problems are always solvable by applicative functors?
22:52:54 <copumpkin> applicative: what if you compose them there functors backwards!
22:53:02 <copumpkin> do I get the OI comonad?
22:53:19 <applicative> Its a problem.
22:53:30 <danharaj> You can't get the OI comonad.
22:53:35 <copumpkin> in OI comonad, missiles launch you
22:53:36 <danharaj> IIRC edwardk demonstrated that.
22:53:38 <cmccann> danharaj, well, any type "a" is the result of applying the identity functor to that type "a", and Identity is applicative, so yes
22:54:12 <danharaj> or rather, that's where I recall seeing the demonstration from.
22:54:21 <danharaj> I don't know if he did it first or whatever.
22:54:26 <copumpkin> I mean, if they're adjoint
22:54:31 <copumpkin> and one way is a monad
22:54:36 <copumpkin> I don't see why the other wouldn't be a comonad
22:54:39 <copumpkin> not sure what use it'd be
22:54:54 <copumpkin> you get the store comonad or something for general State
22:55:12 <danharaj> yeah, but IO isn't really a State monad.
22:55:22 <danharaj> And not every monad has a comonad counterpart.
22:55:31 <copumpkin> :O
22:55:33 <danharaj> edwardk had a post about that recently.
22:55:34 <applicative> (RealWorld, Realworld -> _ )
22:55:39 <applicative> heresy
22:55:42 <danharaj> Onoes concurrency.
22:55:45 <copumpkin> not every monad has a comonad counterpart?
22:55:51 <danharaj> in Hask at least.
22:56:14 <danharaj> or phrased in another way
22:56:18 <danharaj> you can turn any comonad into a monad
22:56:23 <danharaj> but not every monad can be turned into a comonad
22:56:24 <copumpkin> oh that thing
22:56:30 <applicative> every monad arises from some adjunction, and you if they'r endo you can go the other way no?
22:56:30 <copumpkin> that's not the same though
22:56:44 <copumpkin> he has the magic converter (from ddarius) from comonads to monads
22:57:05 <danharaj> applicative: ah, but the dual structure lives in another category.
22:57:25 <applicative> thats why I mentioned they were endo functors
22:57:46 <danharaj> well not every monad in Haskell arises from an adjunction of endo functors, I'm pretty sure.
22:57:49 <applicative> but youre right, i probbly can't have the part
22:57:51 <copumpkin> that's true
22:57:51 <applicative> right
22:58:02 <copumpkin> but the state one does
22:58:08 <danharaj> but IO isn't State :p
22:58:12 <copumpkin> and its counterpart is store
22:58:12 <copumpkin> yeah, I buy that
22:58:42 <applicative> the ghc seems to think it is....
22:58:43 <danharaj> fwiw, the magic comonad converter gives you State when you plug in Store.
22:59:07 <danharaj> Well, something iso to it.
22:59:15 <copumpkin> I wonder if that magic converter works in other categories
22:59:22 <copumpkin> and if so, how to categorize ones in which it works
22:59:32 * copumpkin runs back to agda to prove it
22:59:36 <danharaj> heh
22:59:46 <danharaj> It seems to rely on parametricity quite a bit.
22:59:47 <copumpkin> have you seen the category theory library in agda? :O
22:59:49 <copumpkin> boo
22:59:52 <danharaj> I'm afraid.
22:59:54 <copumpkin> screw parametricity
23:00:01 * copumpkin postulates
23:00:03 <danharaj> Parametricity is the sauce of my pizza.
23:00:13 <copumpkin> I like my pizza without sauce
23:00:21 <applicative> parametricity rules.
23:00:29 <copumpkin> I love it
23:00:33 <copumpkin> I just can't prove anything about it in agda
23:00:38 <danharaj> Why not?
23:00:47 <copumpkin> well, not unless I "model" it in a roundabout fashion
23:00:50 <copumpkin> but if I have
23:00:55 <danharaj> oh, it's not easy to express it?
23:01:02 <copumpkin> I can't prove something like
23:01:30 <copumpkin> proof : (f : forall {A} -> A -> A) -> forall x -> f x == x
23:01:34 * applicative awaits a flood of unicode
23:01:38 <applicative> what no unicode
23:01:38 <copumpkin> hah!
23:02:11 <danharaj> is that because you don't have access to parametricity as a property of the type system itself in Agda?
23:02:27 <copumpkin> yeah, pretty much
23:02:36 <danharaj> I can see that being hobbling.
23:02:45 <danharaj> I thought you meant you played around with your own type systems in Agda.
23:02:49 <danharaj> Using Agda as the meta language.
23:02:49 <copumpkin> well
23:02:59 <copumpkin> you can prove arbitrary things in general
23:03:13 <TacticalGrace> kfish: More like ready to sleep...but I. must. stay. awake.
23:03:15 <copumpkin> but you have to make a roundabout model of the parametric types you're talking about
23:03:26 <copumpkin> and prove things about that
23:03:46 <copumpkin> TacticalGrace: derpa will keep you awake!
23:03:52 <danharaj> oh god
23:03:55 <danharaj> speaking of wakefulness
23:03:56 <kmc> derpa derp derp
23:04:02 <copumpkin> https://github.com/copumpkin/derpa
23:04:08 <TacticalGrace> copumpkin: optimist ;)
23:04:10 <danharaj> I need to go pass out for about eight to ten hours.
23:04:10 <applicative> what is derpa
23:04:11 <applicative> oh
23:04:23 * djahandarie needs to sleep too
23:04:33 <TacticalGrace> Europe->AU jet lag is harsh
23:04:34 <copumpkin> Dependent ERgular Parallel Arrays
23:04:42 <djahandarie> Also, interested in magic comonad converter in the more general setting too
23:04:55 <copumpkin> djahandarie: we can hac something out at hac phi
23:05:06 <djahandarie> Assuming you don't solve it by then
23:05:16 <copumpkin> I'm too interested in this other stuff I'm doing now
23:05:51 * djahandarie hits the sack
23:05:55 <copumpkin> poor sack
23:06:11 <copumpkin> TacticalGrace: that sounds terrible
23:06:44 * edwardk looks up at the mention of comonads just in time to see everyone leave
23:07:11 <copumpkin> edwardk: have you thought about ddarius' magic comonad->monad converter in other categories?
23:07:20 <copumpkin> and what kinds of categories it does work in?
23:09:18 <edwardk> copumpkin: well, ddarius just sandwiched it between cont
23:09:44 <edwardk> so that was a contravariant endofunctor
23:10:19 <edwardk> the cont version works anywhere you can take any adjunction and jam a monad in the middle
23:10:39 <edwardk> we did that with string diagrams one of those fridays
23:10:47 <copumpkin> I think it was one of the ones I was gone
23:11:14 <edwardk> the reason it goes from comonad to monad is the adjunctions is from Hask^op -> Hask rather than Hask -> Hask
23:11:42 <applicative> hm, this 'model' of repa, would it have some use? I remember people thinking e.g. that Nat indexed types would help evade bounds checking with Vector, for example
23:11:59 <edwardk> basically all i did was take the you can sandwich a monad in an adjunction hack of ddarius and switched from the contravariant adjunction for cont up to one which used a right kan extension instead
23:12:00 <copumpkin> applicative: that was me :P
23:12:03 <copumpkin> applicative: Fin?
23:12:19 <edwardk> same adjunction effectively, just taking an end around it.
23:12:20 <copumpkin> applicative: not in its current state, since it's all inductive and super inefficient
23:12:32 <applicative> Oh, i see. It is a dim memory, but sounded good.  I have a sense it would cost something...
23:12:33 <copumpkin> there are unary numbers all over the place
23:12:38 <edwardk> over the index of the indexed adjunction
23:12:47 <applicative> oh, copumpkin, just throw in some 'codensity'.
23:12:49 <copumpkin> applicative: it cost ease of use in haskell. in agda it's fairly easy to work with such types
23:12:54 <copumpkin> applicative: :P
23:13:09 <copumpkin> applicative: my plan is to make another version that just calls out to haskell with many of the properties postulated
23:13:16 * frerich gets up, reads the backlog, hits "so that was a contravariant endofunctor" and goes "ooookayyyy..."
23:13:23 <copumpkin> but it calls out to all the unsafe haskell calls with no bounds checks
23:13:37 <copumpkin> edwardk: hmm okay
23:13:48 <edwardk> http://hackage.haskell.org/packages/archive/contravariant/0.1.2/doc/html/Data-Functor-Contravariant.html contravariant endofunctors
23:13:57 <edwardk> not so scary once you look at em
23:14:00 <applicative> I read the "Kleisli arrows of outrageous fortune' the other day.  It took forever to get it working with his example, but it was true there was a zillion x speedup
23:14:54 <copumpkin> I liked that paper
23:15:02 <applicative> I mean, by codensitifying everything.
23:15:17 <copumpkin> yeah
23:15:28 <edwardk> applicative: though we've shown you don't need to use codensity to do that now =P
23:15:29 <copumpkin> I hear about that a lot from certain people at work ;)
23:15:36 <edwardk> hahahaha
23:15:38 <applicative> I wish I could be more adept at continuation thinking.
23:15:57 <applicative> what do we use.  I'm always out of date?
23:16:15 <edwardk> applicative: see the 'free monads for less' series on my blog
23:16:29 <edwardk> it shows how you can get by with just a weaker yoneda-ish functor
23:16:37 <edwardk> and how its a lot easier to understand
23:16:48 <applicative> if that's true, then ok
23:17:01 <dreamer_> can i get this to install on arm?
23:17:05 <edwardk> its a church encoded free monad, effectively
23:17:26 <applicative> though codensity is easier to understand than 'continuation passing' in the more familiar (haskell) sense
23:17:34 <edwardk> the church encoding gives you just enough control over the continuation to get the asymptotic win of voightlaender's codensitied-free monads
23:18:13 <edwardk> applicative: well, codensity of free is the common use case in my experience, because no free monad ever benefits from a left associated bind
23:18:53 <edwardk> but codensity (Free f) is bigger than Free f
23:21:43 <applicative> hm, I was thinking because of the universality of (forall r. (a -> m r) -> m r) it woulnt really be much 'bigger' in the sense of having more valus
23:22:18 <edwardk> it turns out to be quite a bit bigger
23:22:22 <edwardk> take m to be (->) r
23:22:28 <edwardk> and it goes from reader to state
23:22:33 <edwardk> er (->) e
23:22:39 <edwardk> so it doesn't conflict with your r in scope
23:23:05 <edwardk> this is the running topic of the next 5 or so blog posts
23:24:07 <applicative> well, maybe i should study them, though I have a suspicion my dimness, or rather density, when it comes to 'cps' may be congenital
23:25:18 <edwardk> try to implement MonadState on Codensity (Reader e)
23:25:26 <edwardk> that should convince you Codensity m is bigger than m
23:32:38 * codensity is lost in an immense pile of arrows
23:33:12 <edwardk> just look at the type signature for a sec
23:33:15 <ion> Burn them with fire.
23:33:20 <edwardk> (forall r. (a -> s -> r) -> s -> r
23:33:29 <edwardk> and take a guess at return ;)
23:33:40 <edwardk> the monad should write itself. its a codensity monad!
23:33:49 <edwardk> you can crib the monad etc from me elsewhere
23:33:56 <edwardk> the only things you need are get and put
23:34:01 <edwardk> everything else is free
23:34:34 <edwardk> so get :: forall r. (a -> s -> r) -> s -> r
23:34:41 <edwardk> get f s = ?
23:34:45 <edwardk> er
23:34:54 <edwardk> get :: forall r. (s -> s -> r) -> s -> r
23:35:00 <edwardk> the types tell you what to do
23:35:45 <copumpkin> forall r. (a -> s -> r) -> s -> r ==> s -> (forall r. (a -> s -> r) -> r) ==> s -> (a, s)
23:35:55 <edwardk> put :: s -> forall r. (() -> s -> r) -> s -> r
23:35:59 <copumpkin> for a more direct conversion to State
23:36:28 <codensity> oh sorry didnt see this. the return shouldnt it just be the usual, return x = ($ x)
23:37:04 <edwardk> codensity: yeah the state monad we just described is a codensity monad, so you can steal the functor, monad, applicative, etc. from that
23:37:11 <frerich> I wonder, with all these super generic functions having more or less simple signatures - aren't chances pretty good that you often have two or more names for the same function?
23:37:19 <edwardk> codensity: its only get and put that are bigger than in reader
23:37:53 <edwardk> frerich: it happens fairly often, different libraries providing something either identical or isomorphic
23:38:41 <codensity> but why is get making things big, its get f x = f x x
23:38:44 <codensity> no
23:40:35 <edwardk> get f x = f x x
23:40:37 <edwardk> you got it
23:40:49 <edwardk> put s f _ = f () s
23:41:10 <edwardk> so you can fit get and put into Codensity ((->) s), but not into ((->) s)
23:42:06 <codensity> Now I am seeing your point -- why reader is at the bottom of this pile
23:42:20 <edwardk> the reason is that Codenstity ((->) e) is isomorphic t e -> (e, a), the compositition of the two halves of the (,) e -| (->) e
23:42:44 <edwardk> er of the (,) e -| (->) e adjunction
23:43:14 <copumpkin> edwardk: this fitting talk seems backwards
23:43:16 <edwardk> it provides an embedding for (->) e into that composition
23:43:35 <edwardk> how so?
23:44:51 <copumpkin> in a hand wavey way, it seems like there are fewer inhabitants of Codensity ((->) s) because it satisfies more properties than (->) s
23:45:44 <codensity> which properties?
23:45:55 <copumpkin> the ability to provide meaningful get and put that satisfy laws
23:46:19 <copumpkin> maybe I'm just being dumb late at night
23:48:17 <codensity> they dont get to be inhabitants of Codensity (->a) by themselves separately satifying properties, I'dthink.  Maybe
23:48:29 <copumpkin> true
23:48:37 <copumpkin> in which case I'd think they'd be the same size
23:48:53 <edwardk> Codensity ((->) s) a = Ran ((->)s) ((->)s) a = s -> Ran ((->) s) Id a = s -> (a, s) = State s a
23:49:05 <codensity> edwardk: you haven't begun this series of posts?
23:49:11 <copumpkin> yeah, but does State s a have more inhabitants than (s ->) ?
23:49:15 <edwardk> codensity: the free monads for less series is up there
23:49:21 <copumpkin> yeah, but does State s a have more inhabitants than (s -> a) ?
23:49:27 <edwardk> because state is isomorphic to the composition of (->) with its adjoint
23:49:54 <edwardk> and there is an embedding given by the fact that that right adjoint is representable
23:50:45 <edwardk> http://comonad.com/reader/2011/free-monads-for-less/ http://comonad.com/reader/2011/free-monads-for-less-2/ http://comonad.com/reader/2011/free-monads-for-less-3/
23:51:30 <edwardk> the first post talks at some length about why codensity is bigger
23:52:24 <edwardk> bah, nobody seems to write about DivisionCoalgebras / CodivisionCoalgebras or whatever they would be called
23:52:28 <copumpkin> you don't actually define bigger, as far as I can tell
23:52:32 <copumpkin> it does feel "fancier"
23:52:36 <copumpkin> but I'm not sure how I'd define that
23:52:57 <codensity> ok. I think partly what was baffling me was what was contained in the idea of 'bigger', or rather why it mattered .  Will study.
23:52:58 <edwardk> bigger is actually quite easy. relative size is defined based on whether or not you can section.
23:53:56 <codensity> I see you begin with Voigtlnder
23:54:04 <edwardk> yeah
23:54:28 <copumpkin> so if I can send X to Y but not Y to X, Y is bigger?
23:54:37 <copumpkin> in an invertible sense
23:55:10 <edwardk> yeah, this is where all the section/retraction machinery comes from, monomorphisms, epimorphisms, etc.
23:55:14 <copumpkin> yeah, sure
23:55:28 <edwardk> so its quite rigorous in that way
23:55:56 <copumpkin> but I can take (s -> (a, s)) and turn it into (s -> a), not vice versa
23:56:30 <ion> @djinn (s -> (a, s) -> s -> a
23:56:31 <lambdabot> Cannot parse command
23:56:31 <edwardk> what you're looking at is the existence of a retraction for lift.
23:56:34 <ion> @djinn (s -> (a, s)) -> s -> a
23:56:35 <lambdabot> f a b =
23:56:35 <lambdabot>     case a b of
23:56:35 <lambdabot>     (c, _) -> c
23:57:19 <edwardk> lift :: m a -> Codensity m a — liftRetraction :: Monad m => Codensity m a -> m a
23:57:25 <wuxingbo> greetings! I have a question: I'm using STM, one 'atomically' may re-run several times to make a effective commit, how can I get this count? thanks!
23:57:31 <edwardk> such that liftRetraction . lift = id
23:57:47 <edwardk> er lift :: Monad m =>
23:58:18 <edwardk> wuxingbo: you can use the orElse machinery to bump some kind of counter, or you can use unsafePerformIO to leak information
23:59:26 <codensity> wuxingbo: please dont leak information
23:59:46 <kmc> or unsafeIOToSTM
23:59:54 <edwardk> or that =)
23:59:57 <kmc> i think it's fine in some circumstances
