00:01:20 <NihilistDandy> I suppose I'm mostly curious about what direction I should be thinking in. I've got these shadows of ideas lurking, but I can't quite get them to materialize in an elegant (or even hackish) fashion
00:08:01 <drbean> There doesn't appear to be anything in Data.Tuple which corresponds to fst, and snd with triples.
00:08:18 <kmc> correct
00:08:25 <applicative> where is that, its a hackage package by lennart a.
00:08:37 <kmc> use pattern-matching instead
00:08:41 <NihilistDandy> Right, and triples are only one idea. I could implement my own for those, but it sort of sidesteps the issue of generality
00:09:04 <NihilistDandy> I've thought about pattern matching, but I can't get the idea to crystallize
00:09:10 <NihilistDandy> At least not in a general sense
00:09:36 <applicative> http://hackage.haskell.org/packages/archive/tuple/0.2.0.1/doc/html/Data-Tuple-Select.html
00:10:08 <NihilistDandy> I was thinking about playing with type-level naturals in HEAD, but I don't know if that'll make it too much of a toy
00:10:21 <NihilistDandy> I suppose it's a toy, anyway, though :D
00:10:50 <NihilistDandy> Just something I saw in one of my algebra books, and I thought "I wonder how you do that in Haskell."
00:11:18 * applicative hadn't known there was so much tuple madness on Hackage
00:11:37 <NihilistDandy> applicative: When I asked hoogle, I was a bit agog, yes
00:13:06 <applicative> "Data.Tuple.OneTuple -- OneTuple fills the *tuple* gap with a singleton tuple."
00:13:46 <kmc> NihilistDandy, the code you pasted uses a higher-order representation of permutations
00:13:49 <kmc> i.e. using functions as data
00:13:50 <applicative> drbean, the important thing is the function to extract the element from a one-tuple, viz only
00:14:10 <kmc> but now it sounds like you're talking about a first-order representation
00:14:22 <kmc> i.e. a list of length n, possibly with the length enforced statically
00:14:23 <applicative> i see HaskellForMaths uses a Map a a for newtype Permutation
00:14:40 <kmc> harder to enforce the uniqueness statically
00:15:11 <applicative> uniqueness?
00:15:34 <kmc> if representation a permutation on a set of n elements as a list of n elements
00:15:42 <kmc> you have to mention each one exactly once
00:16:34 <NihilistDandy> kmc: Aha. I was hoping I could do something cute like `f (1,3,5) [1..5]` and get a result like [3,2,5,4,1], but then I couldn't think how that could be done without loss of generality. Tuples, and all
00:16:40 <applicative> yeah, Amos uses Map a a, then everything is subject to something like filter (uncurry (/=)
00:16:47 <kmc> NihilistDandy, what, just for the syntax?
00:16:55 <NihilistDandy> kmc: No, not strictly
00:17:19 <NihilistDandy> I suppose I'm not entirely clear on *what* I want it to look like, just the sort of functionality I'd like
00:17:28 <kmc> well you can write a function that takes a cycle decomposition as a [[Elem]]
00:17:42 <kmc> and returns a permutation represented some other way -- a function, Map, list of elements, etc
00:17:48 <NihilistDandy> hmm
00:18:22 <NihilistDandy> Any chance you could annotate a quick example onto my paste? I may have to look into how Haskell for Maths or the permutations lib do it
00:18:34 <kmc> i'm not clear on what you want
00:18:40 <NihilistDandy> Right
00:19:04 <NihilistDandy> A list of elements is my goal, at the moment, I suppose
00:19:13 <NihilistDandy> The permuted set, as it were
00:19:24 <NihilistDandy> And I've achieved that, in a way, but not in quite the way I like :D
00:21:46 <NihilistDandy> It's even composable, after a fashion, which is also important
00:32:44 <erasmas> NihilistDandy: I don't have a math background so this might be going the wrong direction, but in your `f (1,3,5) [1..5]` example, what would be the consequence of using `f [1,3,5] [1..5]` (a much easier function to code...)?
00:33:04 <applicative> somehow that the number of permutations on n things is n ... factorial, suggests that a beautiful representation is lurking somewhere in the type system
00:33:29 <NihilistDandy> None at all, as far as I know. The implicit ordering of lists makes it a non-issue. The tuple cuteness was just math pollution
00:35:00 <NihilistDandy> I thought about using lists as well, I just couldn't wrap my head around just what to do
00:35:39 <hpaste> erasmas pasted “Playing with permutations” at http://hpaste.org/49704
00:37:07 <erasmas> what about something like http://hpaste.org/49704? it seems to work for your example, in the sense that nextPermWith [1,3,5] [1..5] == [3,2,5,4,1], but I feel I'm missing the larger goal
00:38:53 <NihilistDandy> erasmas: I just tried it out, actually. That's quite a nice solution
00:39:08 <NihilistDandy> And, rather creepily, we used exactly the same test parameters
00:40:19 <NihilistDandy> And it works properly with arbitrary cycle and set sizes
00:40:45 <erasmas> that's where lists are handier than tuples in this case
00:41:21 <NihilistDandy> Quite so. I think the whole idea of tuples was just math notation getting in the way of thought :D
00:44:30 <NihilistDandy> And expanding the type constraint to Eq opens up a lot of other neat possibilities :)
00:44:40 <NihilistDandy> Oh, that's very exciting
00:47:13 <accel> you know what's fucking amazing?
00:47:21 <accel> when you're staring at a piece of code
00:47:26 <accel> involving filter, map, zip
00:47:32 <accel> and you're like .... hmm, I have the logic parts separated out in chunks
00:47:46 <accel> too bad all these intermediate lists are created, whereas in an imperative langauge, I would stuff all the logic in a single for loop
00:47:49 <accel> then you realized wait ....
00:47:52 <accel> haskell is fucking lazy ....
00:47:56 <accel> there aren't intermediate lists ....
00:48:03 <accel> nothing is computed until it's needed ....
00:48:15 <accel> so it's almost as if the compiler folded all my independent pieces of logic into a single for loop
00:48:20 <accel> and suddenly, laziness seems like a good thing
00:48:44 <accel> [where is the applause, cheers, and my nobel prize in literature?]
00:49:08 <NihilistDandy> > replicate 3 "clap"
00:49:09 <lambdabot>   ["clap","clap","clap"]
00:49:16 <shachaf> accel: Well, laziness alone isn't sufficient.
00:49:43 <accel> shachaf: I'm not using stream fucison or any of the more advancesd techniques
00:50:13 <shachaf> Well, it's probably building some intermediate structures, then. :-)
00:50:22 <shachaf> Though it's consuming them lazily too, of course, presumably.
00:50:26 <accel> but the intermediate ones are of soze O(1)
00:50:28 <accel> rather than O(n)
00:50:29 <accel> iirc
00:50:34 <accel> s/iirc/imo
00:50:55 <NihilistDandy> But your constant grows quadratically ~grown~
00:51:02 <NihilistDandy> *groan
00:51:12 <NihilistDandy> Jesus. I haven't used that word in almost a decade
00:51:25 <Liskni_si> they are O(1) in space, but there's a time cost as well
01:04:24 <bj0> i'm trying to teach myself haskell by solving the balanced partition problem because it seems well suited to it, and i've solved it before in python a while back.  no matter what i try i can't get it to solve near as fast as python though, anyone want to look at it and tell me what i'm doing dumbly? :)
01:05:10 <NihilistDandy> It's that hat you're wearing
01:08:45 <bj0> what if i said i'm totally nude...
01:08:51 <shurikas> tmi
01:08:56 <shurikas> unless you are a girl
01:09:14 <shachaf> bj0: You should just @paste instead of asking someone to commit to looking at your code.
01:10:49 <bj0> i figure'd it'd probably get ignored, but ok :)
01:11:17 <silver> bj0, or it won't, "asking to ask" is more likely to be ignored :)
01:11:41 <shachaf> It also makes people feel bad if they offer to help and then it turns out they can't.
01:12:01 <shachaf> Whereas if you just @paste, anyone can look at your link, and possibly at least one of them will have an answer.
01:12:30 <bj0> here's the haskell: http://hpaste.org/49705
01:13:22 <bj0> here's the python, if it helps: http://hpaste.org/49706
01:13:38 <bj0> the idea for the solution is: http://people.csail.mit.edu/bdean/6.046/dp/dp_4.swf
01:13:42 <bj0> *is from
01:15:13 <mm_freak> Cale: after experimenting a lot, i changed my concept to using IO under the hood
01:16:00 <mm_freak> so my transition function is now:  data Wire a b where WGen :: (WireState -> a -> IO (b, Wire a b)) -> Wire a b
01:17:13 <bj0> the haskell solution is fast enough for lists of ~ 10, but doesn't scale at all, the python version can do > 200 in seconds
01:19:32 <NihilistDandy> erasmas, kmc, et al.: Another version, courtesy of esoteric:
01:19:34 <mm_freak> bj0: are you deliberately reinventing the wheel?
01:19:37 <hpaste> NihilistDandy pasted “kmc, erasmas, et al.” at http://hpaste.org/49707
01:19:55 <NihilistDandy> *#esoteric
01:19:58 <mm_freak> bj0: for example the 'powerset' function is already in Data.List, but called 'subsequences'
01:20:11 <bj0> i didn't know that...
01:20:20 <bj0> but the 'faster' methods don't use it
01:21:52 <mm_freak> bj0: what exactly are you trying to do anyway?
01:21:56 <mm_freak> could you give an example?
01:22:08 <bj0> did you look at the mit link?
01:22:16 <bj0> it's a little flash animation that explains it really well
01:23:56 <andares> whee quicksort
01:24:14 <mm_freak> bj0: ah, understood
01:24:54 <bj0> in the python version, i build the "P" array from the bottom up, so i don't have to build the whole thing, i ignore sums that get too big or stop at the solution
01:25:22 <bj0> i tried to do the same thing in haskell, but it scales poorly, so i think i'm calculating more than i need to
01:25:41 <mm_freak> the 'subsequences' function has proper laziness
01:25:57 <mm_freak> > last (subsequences [1..100])
01:26:01 <lambdabot>   mueval-core: Time limit exceeded
01:26:07 <mm_freak> > last (subsequences [1..20])
01:26:08 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
01:26:25 <mm_freak> should run in constant space
01:27:05 <mm_freak> then you can make a zipped list of norms and the original list
01:27:46 <mm_freak> however, that way the whole thing will be in memory
01:28:14 <mm_freak> to get a more memory-efficient solution, i believe you'll have to take a less functional approach
01:28:28 <bj0> i'm more concerned with speed than memory
01:28:36 <mm_freak> then try that one
01:28:41 <bj0> but using subsequence, wouldn't you need to calc the whole powerset to find the min?
01:29:20 <mm_freak> the powerset is generated lazily
01:29:43 <mm_freak> > subsequences [1..]
01:29:44 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,...
01:29:58 <bj0> yea but can't find the 'minimum' unless you check each entry that satisfies the constraint
01:30:24 <mm_freak> you can't do anything about that without placing assumptions on the input list
01:30:29 <mm_freak> like being presorted
01:31:06 <bj0> thats what the solution in the flash animation is for, generating a solution w/out calculating the full powerset
01:31:33 <mm_freak> oh, i only watched it so far as to understand the problem =)
01:31:40 <bj0> :)
01:32:14 <bj0> the only way to use the powerset's lazyness is to make sure it's generated in order of sum
01:32:19 <bj0> not sure how to do that ><
01:36:32 <mm_freak> wait a minute
01:36:36 <mm_freak> you're not looking for subsets
01:36:38 <mm_freak> but for partitions
01:38:57 <mm_freak> perhaps the following function might help you =)
01:39:07 <mm_freak> @let part = foldM (\(xs, ys) e -> [(e:xs, ys), (xs, e:ys)]) ([], [])
01:39:07 <lambdabot>  Defined.
01:39:12 <mm_freak> > part "abc"
01:39:13 <lambdabot>   [("cba",""),("ba","c"),("ca","b"),("a","cb"),("cb","a"),("b","ca"),("c","ba...
01:40:35 <mm_freak> it gives you all distinct subset pairs
01:41:04 <bj0> wouldn't that be the same as generating all subsets, and for each one take List \\ subset ?
01:41:29 <mm_freak> no, because now you only scan this list
01:41:47 <mm_freak> you don't have two pointers into the powerset, but only one pointer into the subset pairs
01:42:07 <bj0> but i have the same number of possibilities right?
01:42:14 <bj0> there's too many to calculate
01:42:55 <Heraklit> Is there a HStringTemplate-expert?
01:43:21 <NihilistDandy> If you know the size of the set, you know the number of partitions
01:43:59 <Heraklit> A list-output is done in HStringTemplate by using the template-string $values;separator=\", \"$, but how can I output a list of lists?
01:44:54 <Heraklit> For example, I want to ouput the list [[1,2,3],[4,5,6]]. How shall I design the corresponding template?
01:45:34 <bj0> well for a list of say 30 items, there will be 2^30 possibilities (minus the empty set and full set?)
01:46:17 <mm_freak> bj0: 2^29, because for each pair (xs, ys) there will be a (ys, xs) counterpart
01:46:46 <bj0> but the powerset doesn't include those duplicates does it?
01:46:57 <mm_freak> i didn't really care too much for the algorithm presented in the video, but it appeared to me like you can translate it verbatim to haskell
01:47:28 <bj0> thats what i did for 'try2' in the code i posted
01:47:30 <bj0> i think
01:57:29 <chrisdone> sutabi: did you fix your string reversing problem?
02:00:02 <accel> is there a function
02:00:06 <accel> that extracts the second element
02:00:08 <accel> out of a pair?
02:00:11 <accel> i.e. (a,b) -> b ?
02:00:15 <accel> @hoogle (a,b) -> b
02:00:16 <lambdabot> Prelude snd :: (a, b) -> b
02:00:16 <lambdabot> Data.Tuple snd :: (a, b) -> b
02:00:16 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
02:00:20 <accel> snd
02:00:23 <accel> who would have guessed
02:00:59 <accel> @hoogle readFile
02:00:59 <lambdabot> Prelude readFile :: FilePath -> IO String
02:00:59 <lambdabot> Data.ByteString readFile :: FilePath -> IO ByteString
02:00:59 <lambdabot> System.IO readFile :: FilePath -> IO String
02:04:18 <karlicoss> Hello guys. How can I use minimum function with a specific comparator?
02:04:27 <mm_freak> karlicoss: minimumBy
02:04:39 <karlicoss> mm_freak: thx
02:05:07 <mm_freak> > minimumBy (comparing (^2)) [-3, -2, 1, 5]
02:05:07 <lambdabot>   1
02:06:01 <ion> :t (comparing, (compare `on`))
02:06:02 <lambdabot> forall b a b1 a1. (Ord a, Ord b1) => ((b -> a) -> b -> b -> Ordering, (a1 -> b1) -> a1 -> a1 -> Ordering)
02:24:45 <mm_freak> Cale: what would you think of impure FRP?  for my application something like this would be useful:  x <- execute -< someIOAction
02:24:59 <mm_freak> the IO action specifically being a signal itself
02:26:38 <Cale> I think it's interesting, and that there should be a way to make it work well.
02:28:28 <Cale> The other night I was considering  ioExec, ioFork :: (ArrowIO (~>)) => Event (~>) (IO a) ~> Event (~>) a
02:29:48 <Cale> Where ioExec would be synchronous (halt the execution of the whole arrow until the IO finishes), and ioFork would run the IO actions concurrently and the resulting Event's occurrences would be at whatever future time they finished.
02:42:59 <mm_freak> Cale: that was exactly my idea
02:43:31 <mm_freak> i also pondered about abortable subwires
02:43:54 <mm_freak> but actually with ArrowChoice that should be fairly easy to get
02:44:10 <mm_freak> (a "wire" is a signal network in my library)
02:44:20 <mm_freak> (i didn't like "SF")
03:07:09 <karlicoss> can I "map" data constructor to a list of it's parameters? for example, i have Dot Double Double data constructor and I want to construct a list of Dot's from two lists of it's coordinates.
03:07:31 <sipa> you want zipWith
03:07:34 <sipa> :t zipWith
03:07:35 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
03:08:18 <karlicoss> so, it will look as zipWith Dot xlist ylist?
03:08:23 <sipa> exactly
03:08:29 <karlicoss> wow, cool
03:08:38 <karlicoss> thanks
03:08:38 <sipa> Dot is normal function, of type Double -> Double -> Dot
03:08:40 <santhi> hiii
03:12:41 <JuanDaugherty> yello santhi
03:15:42 <mm_freak> Cale: could you explain briefly what a time leak is?
03:16:16 <JuanDaugherty> leak is a general expression for a uncontrolled loss of something
03:16:49 <JuanDaugherty> orginally for memory exhaustion but now used colloquially
03:17:16 <mm_freak> JuanDaugherty: i'm talking about time leaks in reactive programming
03:17:47 <mm_freak> there are some papers, which discuss time leaks, but there doesn't seem to be a quick summary of what that is
03:17:56 * JuanDaugherty found its use irritating at first too but has adjusted; presume same in reactive, arrows, whatever.
03:18:10 <mm_freak> i'm concerned, because i'm writing an FRP implementation right now
03:18:35 <JuanDaugherty> lemme know if you find it to be a defined substantially different construct
03:18:54 <JuanDaugherty> s/me/the channel/
03:20:08 <JuanDaugherty> for example I use a C++ pkg which emits warnings "Application but not leak ANY exceptions".
03:21:16 <ion> uhuhuhuh, “leak”
03:21:22 <ion> Ok, too much Beavis and Butt-Head.
03:21:46 <mm_freak> oh, i found it
03:22:03 <JuanDaugherty> and?
03:23:06 <mm_freak> a time leak is when a signal at an instant cannot be calculated from the input value alone, but needs values from past instances
03:23:43 <JuanDaugherty> so a leaked interval
03:24:02 <mm_freak> no, it is indeed a memory leak…  why that is called time leak i don't understand
03:24:46 <JuanDaugherty> it sounds like a special construct from the defintion you gave, somekina "basis leak"
03:25:34 <mm_freak> i think it's comparable to lazy lists
03:25:46 <JuanDaugherty> sometime linugistic aesthetics are the fail with many non-native english speakers and a lot of terms moving from very poorly defined stats into mathematical argot
03:25:47 <mm_freak> lists, which can't be expressed by the 'iterate' combinator have that particular leak
03:25:56 <JuanDaugherty> *sometimes
03:26:28 <JuanDaugherty> use of a generalized "leak" struck me that way at first, but as I said I've adjusted
03:26:52 <mm_freak> "time leak" seems to be a common term in FRP
03:27:32 <JuanDaugherty> how it's a memory leak from the def you gave is unclear
03:27:57 <mm_freak> picking an element from an iterate-generated list is an O(1) space operation
03:28:12 <JuanDaugherty> unless thos values are implied to have become stranded
03:28:17 <JuanDaugherty> e
03:28:25 <mm_freak> running an instant of an FRP signal network without time leaks is also an O(1) space operation
03:28:47 <mm_freak> > iterate (\x -> mod (x^2 + 1) 101) 0 !! 1000
03:28:47 <lambdabot>   97
03:30:12 <mm_freak> actually i have a combinator, which has a time leak, but its documentation states that explicitly…  i just didn't know that was called a "time leak"
03:30:16 <mm_freak> to me it's a space leak
03:30:20 <mm_freak> perhaps a spacetime leak =)
03:31:25 <JuanDaugherty> *status
03:47:55 <Entroacceptor> hab ich dann doch bis halb drei oder so geschlafen
03:48:01 <Entroacceptor> whoops
03:48:02 <JuanDaugherty> *"Application must not .."
03:48:25 <JuanDaugherty> keine Problem, Entroacceptor
03:48:45 <JuanDaugherty> *kein
03:48:45 <mm_freak> kein problem
03:48:51 <Entroacceptor> Oo
03:48:57 <mm_freak> deutsche sprache schwere sprache, weißt ja
03:49:34 <JuanDaugherty> nicht wirklich, fur Englischsprechenden irgendfalls
03:50:26 <Entroacceptor> "irgendfalls" is wrong, but cute :)
03:51:14 <JuanDaugherty> :)
03:51:46 <mauke> I refudiate that
03:52:10 * JuanDaugherty is only really concerned to be have the highest levels of fluency in English and Mandarin, can be cutesy in other langs
03:52:32 <k0ral> hi, how do you use to spawn a new process independent from the spawning one, meaning that if the latter is killed, the former keeps running ?
03:53:15 <JuanDaugherty> that's not really a haskell question k0ral
03:53:28 <sipa> what is 'irgendfalls' supposed to mean?
03:53:37 <JuanDaugherty> any case
03:53:58 <mauke> jedenfalls
03:54:04 <JuanDaugherty> ah, right
03:54:27 <k0ral> JuanDaugherty: isn't it ? I know means to do it outside haskell with nohup for example, my point here is to know how to reproduce this behavior in a haskell environment
03:54:48 <JuanDaugherty> haskell just a lang
03:55:02 <JuanDaugherty> *haskell's
03:55:27 <mm_freak> k0ral: you probably what to look into the System.Process module
03:55:44 <mauke> k0ral: isn't that the default behavior?
03:56:15 <mm_freak> it provides functions for spawning new processes, but only portable once, i.e. you get no fork() equivalent
03:56:21 <mm_freak> if you want that, there is also System.Posix.Process
03:56:37 <mm_freak> s/once/ones/
03:56:56 <k0ral> unless I'm mistaken, everything in System.Process creates a child process
03:57:10 <JuanDaugherty> i presume it's CreateProcess
03:57:36 <k0ral> child implies that it dies with its parent
03:57:37 <mm_freak> k0ral: yes, every process is a child process of some other process, but it lives along, if the mother dies
03:57:45 <k0ral> huh ?
03:57:59 <mm_freak> no, it doesn't…  child just means that the mother process is notified of the death of her children
03:58:28 <k0ral> hmmm I may have done something wrong, but last time I tried, it did die with its parent
03:58:32 <mm_freak> you actually also want to receive that notification, otherwise you get zombie processes…  you need to handle SIGCHLD
03:58:44 <JuanDaugherty> in general k0ral any process can survive its parent
03:58:57 <mm_freak> perhaps you used forkIO/forkOS, which doesn't have anything to do with OS threads/processes
03:59:15 <k0ral> no no, I didn't use fork*
04:00:37 <k0ral> I guess I have to read more about how to handle processes in general and stop bothering you :)
04:01:32 <mm_freak> the fork() manpage explains everything there is to know for POSIX-based operating systems
04:02:00 <JuanDaugherty> it is kina basic unix/OS stuff k0ral
04:11:33 <mm_freak> Cale: may i query you again?
04:51:17 <k0ral> I damn can't find the piece of information I want, that's insane
04:51:48 <k0ral> seems like I should do a forkProcess followed by an executeFile
04:52:29 <k0ral> but I still can't find how to manage the parent/child relationship: is SIGHUP still sent ? should I manage SIGCHLD ?
04:54:19 <mm_freak> k0ral: forkProcess immediately followed by executeFile is equivalent to System.Process.createProcess
04:54:44 <mauke> k0ral: what does SIGHUP have to do with anything?
04:54:56 <mauke> SIGCHLD depends on what the parent does
04:55:37 <k0ral> SIGHUP would be sent to children processes when their parent would die
04:55:51 <mauke> no
05:19:26 <namkoita> Hi.Is Haskell the most advanced programming language on the planet.:)
05:19:55 <Axman6> im many ways, yes
05:20:43 <namkoita> Thanks.:)
05:21:16 <Axman6> that's a pretty unusual question to ask though
05:21:20 <XniX23> is it just me or is haskell a bit too expressive?
05:21:34 <Botje> how is that a bad thing? :)
05:21:35 <Axman6> that's a bad thing?
05:21:51 <drbean> It appears to be impossibe to define a function using pattern matching with let in ghci, even with multiline commands
05:21:58 <Axman6> "damn, i wish it was harder to convey my meaning to other developers without having to worry about minor details"
05:22:11 <XniX23> well it means that reading other's people code, the coder probably had a different idea of implementing a solution
05:23:33 <Axman6> drbean: Prelude> let foo Nothing = 0; foo (Just x) = x
05:23:34 <Axman6> Prelude> foo Nothing
05:23:34 <Axman6> 0
05:26:34 <sonoflilit> Hi
05:26:52 <sonoflilit> Compiling on ghc7 is taking forever... it hits my machines's 1GiB RAM pretty quickly
05:27:09 <sonoflilit> do I have anything to do except go back to an older version or buy a new machine?
05:27:32 <kalven> well, it's the most advanced compiler for the most advanced language, so you might need to get a more advanced computer.
05:27:38 <akosch> sonoflilit: what are you compiling?
05:27:55 <XniX23> kalven: nice sum up
05:27:55 <sonoflilit> what made me despair was "frag"
05:28:16 <sonoflilit> but my work project is also not far from driving me mad
05:29:32 <sonoflilit> frag's BSP.hs, a mere 1K LoC, takes more time to compile than I'm prepared to wait for it...
05:30:24 <akosch> sonoflilit: I'll try on my box, I have 1GiB RAM too...
05:30:43 <sonoflilit> you'll need to modify quite a lot to get it to compile
05:30:55 <sonoflilit> want me to send
05:30:58 <sonoflilit> tahanks, btw :-(
05:31:03 <sonoflilit> thanks, btw*
05:31:05 <sonoflilit> :-)
05:31:07 <Axman6> sonoflilit: are you compiling with profiling turned on?
05:31:33 <Axman6> also, 1GB RAM is pretty small these days...
05:32:42 <sonoflilit> ahh, my machine's slowness while compiling is making me sound uncapable of finishing a sentence :P
05:32:51 <sonoflilit> I meant to say "want me to send a patch?"
05:33:00 <sonoflilit> I might be compiling with profiling, let me check
05:37:47 <MaskRay> How can I get `hxt-curl' installed? http://paste.pocoo.org/show/449870/
05:43:15 <Saizan> sonoflilit: can you tell at which point of the compilation it's using so much memory? linking maybe?
05:43:28 <sonoflilit> as I said, in BSP.hs's compilation
05:43:37 <sonoflilit> it seems to be a bit better with profiling turned off
05:44:03 <sonoflilit> took a few tries to really turn it off though :P
05:47:47 <sonoflilit> well, I lost patience again
05:47:55 <sonoflilit> half of infinity is still infinity
05:48:16 <sonoflilit> the "cc1" process had all my cycles and memory and wasn't making any signs of finishing soon
05:48:34 <sonoflilit> oddly, it was its second appearance for the same .hs file being compiled, is that normal?
05:48:58 <sonoflilit> as in, cc1 was created, ate some cycles and memory, died, and now a second cc1 was created after a while
05:50:49 <sonoflilit> so do I have any saviour except going back to Haskell 6.12?
05:57:15 <sonoflilit> :(
05:57:20 <hpaste> bla123 pasted “Specialized function” at http://hpaste.org/49711
05:57:48 <bla123> is there a way to specialize a function on a certain type? I tried it with type classes
05:58:04 <bla123> (see hpaste)
05:58:05 <mauke> so I heard you like to break parametricity
05:58:21 <Saizan> that would work with OverlappingInstances
05:58:54 <Saizan> which doesn't have a great reputation though
05:59:21 <bla123> it works, thanks
05:59:34 <bla123> now that it made my code work ... why shouldn't i use it? ;)
05:59:57 <Axman6> isn't it one of the extensions that can send the compiler into an infinite loop?
06:00:15 <Saizan> no, but also that wouldn't be much of a problem
06:00:26 <bla123> that in itself doesn't need to be a bad thing
06:00:41 <Saizan> the main problem is that it can easily end up breaking canonicity of instances
06:00:42 <bla123> the compiler could give up aftzer some time .... the program will be faulty anyway
06:01:11 <bla123> err ... canonicity?
06:02:46 <Saizan> i.e. your program could end up using different instances for the same type
06:03:33 <Saizan> but that shouldn't happen if all the instances of the class reside in the same module where you've declared the class, even with OverlappingInstances i mean
06:04:10 <bla123> doesn't it always prefer the most specific instance?
06:04:33 <bla123> ah, you mean when one instance is sometimes in scope and sometimes not
06:05:17 <bla123> hm, ok, very important to keep that in mind
06:06:16 <bla123> is there a better way to solve my problem at hand? (a function specialized on some types)
06:06:53 <Zyclops> hey guys… we're looking at writing a game engine for a online game which we expect will have 10000 or so concurrent users.  We're investigating whether to write this in our current set of languages (ruby, javascript, postgres) or try to use a much faster language.  Ruby we have found is quite slow when you are trying to run lots of these operations in parellel
06:07:04 <Saizan> another way is to use Typeable i guess, not sure if that's better though
06:07:31 <Zyclops> would haskell be worth investigating?  if so do you guys know of any good websites that point out the comparisons between haskell and say ruby/python/java/erlang
06:07:38 <bla123> with Typeable, it would be resolved at runtime, i guess?
06:07:54 <Saizan> yeah
06:09:57 <gienah> Zyclops: haskell has very lightweight threads like erlang and go, so you can keep the state in the threads for a more natural programming style
06:10:39 <Zyclops> i'm not very used to threaded programming (neither are any of the guys in my team) …. they're all pretty smart though
06:10:44 <Zyclops> is it hard to get used too?
06:10:53 <gienah> Zyclops: haskell has a very strong type system, which at first you will probably find is a hindrance to writing anything
06:10:58 <bla123> Zyclops: haskell also can be pretty fast (http://shootout.alioth.debian.org/u64q/which-programming-languages-are-fastest.php?java=on&ghc=on&hipe=on&erlang=on&python3=on&yarv=on&calc=chart)
06:11:27 <gienah> Zyclops: yes haskell is hard to get used to, once you do get used to it though the strong type system actually makes it easier to sketch out code
06:11:39 <Zyclops> gienah: nah .. i've been thinking recently that non typed languages are stupid though… we spend 80% of time debugging stuff
06:11:45 <Zyclops> something i reckon types would reduce
06:11:52 <Zyclops> ah yep
06:11:53 <gienah> yes exactly
06:11:58 <sonoflilit> Zyclops: for me, Haskell has been amazing in reducing the number of bugs
06:12:03 <Saizan> concurrency is much easier in a pure language though :P
06:12:18 <sonoflilit> Zyclops: on the other hands, I've been writing Haskell for half a year by now, and still can't get performance right
06:12:25 <sonoflilit> Zyclops: though I know it is possible
06:12:38 <bla123> Zyclops: do you or your team have experience with functional programming? otherwise, that may be a hindrance at first
06:12:53 <Zyclops> nah, no experience with functional except for one guy
06:13:01 <sonoflilit> Zyclops: also, a lot of my data structures are convoluted things meant to serve the language's harsh limits
06:13:30 <Zyclops> sonofilit: right … you've found a reduction in the bugs?  do you still write unit tests in haskell or not?
06:13:44 <sonoflilit> Zyclops: again, I don't see that with more experienced haskellers' code
06:13:59 <Zyclops> wow.. why is java so really ridiculously fast
06:14:14 <gienah> Zyclops: this is a good comparison of erlang and haskell: http://jlouisramblings.blogspot.com/2010/04/haskell-vs-erlang-for-bittorent-clients.html
06:14:30 <Zyclops> oh important question
06:14:37 <Zyclops> does haskell have an equivilent of rails?
06:14:38 <bla123> Zyclops: I think it is precompiled on the server editions
06:14:50 <sonoflilit> Zyclops: I ported my big app to a new version of a framework with many breaking changes, by blindly finding something that makes every place the compiler shouted about compile, and I don't know of any bugs that were introduced by that
06:14:55 <Zyclops> like a server framework
06:15:10 <sonoflilit> Zyclops: Yesod and Snap, among others
06:15:19 <Zyclops> ah nice.. so good web support
06:15:22 <sonoflilit> but it's not clear you'd want to work with one
06:15:59 <sonoflilit> maybe just something basic like Wai
06:16:00 <gienah> Zyclops: others being happstack
06:16:25 <Zyclops> really just need something that can render some html
06:16:32 <sonoflilit> Zyclops: what kind of game is it?
06:16:34 <Zyclops> and then respond to http requests
06:16:43 <Zyclops> sonofilit: ever played risk?
06:16:48 <Zyclops> the board game
06:16:50 <sonoflilit> many a time :)
06:17:00 <Zyclops> ah yeah.. all the existing implementations are shit
06:17:05 <Zyclops> the online ones that is
06:17:18 <Zyclops> so we want to make one that actually works properly with a nice interface
06:17:26 <Zyclops> which doesn't drop out, crash and runs really fast
06:17:40 <Zyclops> also with an AI that can thrash most people
06:17:55 <sonoflilit> so not more than 8 players in a match, and no realtime logic
06:17:57 <Zyclops> we've already coded an engine in ruby just to test out the AI side of things
06:18:16 <Zyclops> 8 players in match, every move has to be updated to each of the players
06:18:23 <Zyclops> some of the players can be AIs
06:18:30 <Zyclops> AIs will connect using the same interface the players do
06:18:45 <Zyclops> i.e. the AIs will issue http requests to make their moves
06:18:58 <bla123> Zyclops: you may want to read "Why FP matters" (http://www.google.de/url?sa=t&source=web&cd=1&ved=0CBgQFjAA&url=http%3A%2F%2Fwww.cs.utexas.edu%2F~shmat%2Fcourses%2Fcs345%2Fwhyfp.pdf&rct=j&q=why%20fp%20matters&ei=ilo1TsGSAozKswaxj5m6Ag&usg=AFQjCNH5JgRnO3OFW4dShG4WuZ46NP2B3Q&cad=rja). it is mostly about haskell and it ha a neat AI example in it for some round-based game
06:18:59 <Zyclops> we're also going to keep the AIs on their own server
06:19:18 <Zyclops> the AIs fairly procedural though
06:19:33 <Zyclops> i.e. we've broken the AI down to about 40 different tactics
06:19:39 <Zyclops> and it switches between them
06:19:44 <Zyclops> depending on various factors
06:21:01 <sonoflilit> is it imporant for you to survive server crashes?
06:21:15 <sonoflilit> i.e. keep game data on disk?
06:22:03 <Zyclops> i'm not sure
06:22:17 <Zyclops> how important it is
06:22:22 <Zyclops> i mean it will piss everyone off
06:22:25 <Zyclops> if the server goes down
06:22:36 <Zyclops> one option though is to send the game state each go
06:22:38 <Zyclops> to be saved
06:22:42 <Zyclops> which is fairly easy
06:22:54 <Zyclops> since the game state has to be sent to all the clients every move anyway
06:23:10 <Zyclops> I was considering using SimpleDB
06:23:14 <benmachine> is there any hidden information in risk, I forget
06:23:24 <Zyclops> hidden information like what?
06:23:25 <sonoflilit> <comment>you can, and probably should, just send updates</comment>
06:23:34 <sonoflilit> there is
06:23:38 <benmachine> I know the entire board is always visible but do people have like, hands of cards that no-one else can see
06:23:38 <sonoflilit> every player has cards
06:23:43 <benmachine> oh right
06:23:56 <Zyclops> oh yeah.. you don't know what cards the other players have (although that's largely unimportant)
06:24:11 <sonoflilit> Zyclops: it can make or break a game which cards the other players have
06:24:13 <Zyclops> sonofilit: yeah, we will only send updates…. but we were thinking about having a checksum or something
06:24:18 <Zyclops> so that if they get outta sync
06:24:23 <Zyclops> we can send them the entire game board
06:24:33 <Zyclops> sonofilit: not really
06:24:39 <Zyclops> sonofilit: number of cards
06:24:40 <benmachine> sonoflilit: I dunno, is it really worth bothering? the entire board state is pretty small
06:24:57 <Zyclops> not really what the cards are… although we wouldn't broadcast the cards to the other players
06:25:18 <benmachine> if you send the entire board every time then there's no danger of out-of-sync
06:25:23 <Zyclops> sonofilitit:  42 countries {country_name, no_of_troops, player}
06:25:24 <sonoflilit> Zyclops: has this never happened to you? You're thinking whether to cash your cards now or next round, and it all depends on whether your rival can cash /his/ cards this round after you and launch a massive attack?
06:25:40 <Zyclops> sonofiliti: all the time
06:26:15 <sonoflilit> benmachine: he wants one server to support 10K players
06:26:17 <Zyclops> actually
06:26:22 <sonoflilit> makes every byte matter
06:26:26 <Zyclops> yeah
06:26:31 <Zyclops> also every time someone makes one attack
06:26:33 <benmachine> ok, fair enough
06:26:35 <Zyclops> or places one troop
06:26:41 <Zyclops> it has to update all the other players
06:26:58 <Zyclops> sonofilit: doens't have to be one server.. probably am just going to host it on ec2
06:27:57 <sonoflilit> Zyclops: anyway, so if you knew Haskell, I'd probably advise going with it for this project, but I'm not sure it's a good first big project, and haskell - for me at least - has an unusually steep learning curve
06:28:34 <sonoflilit> I must say that I'm a relative newbie in this channel, so don't take advice from me too seriously
06:28:49 <Zyclops> ah yep
06:29:04 <Zyclops> well i probably would program some much smaller stuff
06:29:13 <Zyclops> or just start programming and refactor later
06:30:49 <Zyclops> what do you do for testing?
06:30:51 <Zyclops> in haskell
06:30:56 <Zyclops> do you guys write unit tests?
06:31:06 <benmachine> Zyclops: I do for some projects
06:31:18 <sonoflilit> Zyclops: there's a very impressive framework for testing pure code, QuickCheck
06:31:24 <benmachine> I think it depends on the project both how easy it is to test and how important it is
06:31:39 <sonoflilit> I've never tried to test IO code
06:33:38 <Zyclops> right
06:33:41 <Zyclops> in ruby it's pretty much
06:33:46 <Zyclops> you write unit tests
06:33:49 <Zyclops> or your code doesn't work
06:36:31 <ion> QuickCheck is awesome, yeah.
06:37:42 <Zyclops> do you guys compile your haskell to machine code?
06:38:08 <ion> No, i interpret it with pen and paper.
06:38:11 <sonoflilit> Zyclops: ghc outputs an executable
06:38:16 <Nimatek> I compile it to PHP code.
06:38:28 <Zyclops> haha
06:45:17 <ulidtko> hey
06:45:26 <ulidtko> any suggestions on visualization library?
06:45:58 <ulidtko> I'd like to draw a couple of rectangles, and interactively move&zoom them
06:47:05 <Zyclops> what do they mean when they say pascal is pure?
06:47:13 <Nimatek> ulidtko: OpenGL maybe?
06:48:27 <ulidtko> Nimatek: I'll have to handle the primitives completely myselves with OpenGL...
06:50:10 <benmachine> Zyclops: pascal?
06:50:19 <gienah> Zyclops: I guess you mean haskell instead of pascal
06:50:44 <Nimatek> ulidtko: What do you mean with 'handle'? You have to define the coordinates and.. that's it.
06:50:55 <Nimatek> ulidtko: And resizing can be done with glScalef
06:51:04 <Zyclops> lol
06:51:06 <Zyclops> yeah
06:51:10 <Zyclops> haskel'
06:51:57 <gienah> pure code will always return the same result for the same input parameters
06:52:13 <gienah> so pure code can not do input output
06:52:23 <gienah> this is enforced by the type system
06:53:29 <mauke> it's not enforced by the type system
06:53:42 <mauke> it's enforced by not having functions that do I/O
06:54:11 <Zyclops> hmm
06:54:16 <Zyclops> ok i'm still confused
06:54:43 <Zyclops> you mean.. the scope of a function
06:54:47 <mauke> what
06:54:52 <mauke> functions don't have scopes
06:54:56 <Zyclops> can not access anything outside that funciton
06:55:00 <Zyclops> yeah exactly
06:55:10 <Zyclops> i.e. there's no such thing as global variables
06:55:14 <mauke> yes, there is
06:55:24 <Zyclops> hmmm confuse
06:55:35 <mauke> why?
06:55:43 <mauke> are you a python programmer?
06:57:30 <XniX23> mauke: do you have any py example?
06:57:44 <mauke> of what?
06:58:28 <_Ray_> Hi. What is GHC telling me about the types of these expressions when it says: " Couldn't match expected type `SecIO s3 t0' with actual type `Sec s1 String' in a stmt of a 'do' expression: fs <- cf"
06:58:35 <benmachine> there are no global variables if by variable you mean a value that can change
06:58:42 <XniX23> mauke: nevermind, i thought you were gonna give a python example of whatever you two are discussing about
06:58:44 <benmachine> you can't have global IORefs (without cheating)
06:59:15 <mauke> XniX23: no, I associate a lack of understanding of scopes with experience in python
07:00:11 <gienah> Zyclops: I really like the chapter on software transactional memory, it gives some motivation on why the separation of pure code from IO code is useful: http://research.microsoft.com/~simonpj/papers/stm/#beautiful
07:00:11 <mauke> _Ray_: what's the first part you don't understand?
07:00:14 <XniX23> mauke: makes sense why i dont get it
07:00:36 <mauke> python :-[
07:00:38 <_Ray_> mauke, basically which binding it is saying has which type. Does fs have type SecIO s3 t0, or is that cf?
07:00:45 <benmachine> mauke: I have experience with python, yet I understand scopes :O
07:00:52 <mauke> _Ray_: neither
07:01:17 <_Ray_> THEN WHO WAS PHONE???
07:01:26 <benmachine> _Ray_: is SecIO a monad?
07:01:27 <romildo> Hi.
07:01:30 <_Ray_> yup
07:01:50 <mauke> _Ray_: cf :: Sec x y
07:01:57 <mauke> but the context demands a SecIO
07:02:20 <benmachine> _Ray_: my guess is that cf is being inferred to be Sec s1 String, but the do-expression and use of fs leads ghc to want it to be SecIO s3 t0
07:02:34 <Zyclops> erm.. my progamming liniage went…. BBC basic -> basic -> visual basic -> c++ -> java -> php -> ruby
07:02:39 <_Ray_> mauke: So GHC inferred that, based on following usage of cf, cf has to be a SecIO?
07:02:49 <mauke> _Ray_: no
07:02:52 <benmachine> presumably GHC has decided the do-block is a SecIO do-block
07:03:00 <romildo> When installing encoding, I am getting a bunch of error messages. The first one gives says "Perhaps you haven't installed the "dyn" libraries for package `HaXml-1.22.2'?" What is it talking about?
07:03:03 <mauke> _Ray_: cf :: Sec x y
07:03:26 <benmachine> romildo: have you recently enabled dynamic libraries?
07:03:39 <romildo> benmachine, no
07:03:47 <benmachine> hm
07:03:58 <mauke> _Ray_: consider an expression like 'f x'
07:04:06 <benmachine> did you install haxml from your package manager? (I'm sorta guessing here)
07:04:16 <mauke> _Ray_: when we look at x we have to consider two type contexts
07:04:33 <romildo> I am configuring a new notebook to compile my Haskell program. It runs gentoo linux ~amd64.
07:04:48 <mauke> _Ray_: one is the intrinsic type of 'x' itself. this is influenced by the declaration of x and how it's used in other places
07:05:17 <mauke> _Ray_: the other is the argument type expected by 'f'. this is the "expected" type of x
07:05:28 <romildo> benmachine, all haskell packages has been installed using emerge, the gentoo package manager.
07:05:38 <gienah> romildo: I conditionally patched encoding for haxml 1.22.2 in the gentoo haskell overlay
07:06:09 <_Ray_> Ah. In this case, since I'm using <- in a do block, the expected type is the type that my expression needs to be for my following statements to make sense, because they take that value as a parameter?
07:06:10 <gienah> romildo: probably better to ask us in #gentoo-haskell
07:06:44 <mauke> _Ray_: well, do ... <- ... desugars to cf >>= (\fs -> ...)
07:06:48 <romildo> gienah, in the case of encoding, I have used hackport to get an ebuild for the latest version from hackage. So it is not the one from the haskell overlay.
07:07:17 <gienah> romildo: so I'm not surpised it does not work :-/
07:07:21 <mauke> _Ray_: so the "expected" type comes from >>=, the rest of the do block, and the context >>= itself is in
07:07:27 <mauke> they all need to match up
07:08:40 <mauke> foo :: IO (); foo = do { x <- bar; return () }; bar = "hi"  -- type error
07:09:25 <mauke> in 'x <- bar' the inferred type of bar is String (because of the definition bar = "hi"), and the expected type is IO a
07:09:59 <mauke> 'IO' because I gave foo a type signature that specifies IO, and 'a' because x isn't actually used anywhere so it can be whatever I want
07:10:06 <_Ray_> That makes sense. Thanks. I'll have to mess around with it a bit to understand how it works when you have two monads like Sec and SecIO
07:10:26 <mauke> ^ the example above uses two monads, IO and []
07:10:53 <_Ray_> lol :)
07:10:55 <mauke> foo :: [()]; foo = do { x <- bar; return () }; bar = "hi"  -- valid
07:11:35 <_Ray_> Can one have nested do blocks?
07:13:06 <opqdonut> yes
07:14:57 <mauke> > do { do { do { "yes" } } }
07:14:57 <lambdabot>   "yes"
07:15:38 <MaskRay> How can I get `hxt-curl' installed? http://paste.pocoo.org/show/449870/
07:15:55 <_Ray_> Hrmph. And if I have something like Foo (Bar x), how can I extract that x? I need two do-blocks, right?
07:16:26 <ion> > do do do do do do do do do do do do do do do do batman
07:16:27 <lambdabot>   batman
07:16:54 <_Ray_> xD
07:17:20 <ion> What are Foo and Bar?
07:17:40 <_Ray_> Two monads. Specifically SecIO s1 (Sec s2 String) here.
07:18:49 <ptd> :t batman
07:18:49 <lambdabot> Not in scope: `batman'
07:18:56 <ptd> > do batman
07:18:56 <lambdabot>   Not in scope: `batman'
07:19:48 <ion> I’m not familiar with seclib. I take it there is a reason to nest Sec within SecIO?
07:20:17 <_Ray_> readFileSecIO :: File s -> SecIO s' (Sec s String)
07:20:31 <_Ray_> Secure computation that returns a secure value.
07:21:24 <_Ray_> If I say cg <- readFileSecIO foo, where foo is a file, and I'm in a do-block, is cg :: Sec s String?
07:21:55 <_Ray_> (Common sense says no. "Magic do block" says yes.)
07:22:08 <mauke> your common sense is broken
07:22:11 <mauke> what else would it be?
07:22:43 <_Ray_> SecIO s' (Sec s String)
07:23:01 <mauke> then what does the <- do?
07:23:12 <_Ray_> Then again, if I have a t :: [foo], and I x <- t, x :: foo
07:23:33 <ion> revealIO :: SecIO s a -> IO (Sec s a)
07:23:34 <mauke> (and how would <- differ from = ?)
07:23:48 <ion> reveal :: Sec s a -> a
07:24:00 <ion> Something like b <- reveal <$> revealIO a perhaps.
07:24:11 <_Ray_> ion: But I can't return an IO, unfortunately :( I'm trying to concatenate two files, so I have to do this: cat2 :: (Less s1 s3, Less s2 s3) => File s1 -> File s2 -> File s3 -> SecIO s3 ()
07:26:01 <erus`> how do i install ghc7 on ubuntu?
07:26:02 <hpaste> “_Ray_” pasted “Sec / SecIO” at http://hpaste.org/49712
07:27:09 <_Ray_> The error being at "sf <- up cf", it expected SecIO s3 t0, but I gave it Sec s'0 a0.
07:28:33 <mm_freak> is there any way to utilize mfix in IO, if you don't use unsafeInterleaveIO?
07:31:25 <Axman6> _Ray_: why do you have nested do blocks?
07:32:10 <Guest28011> In ghci, I want to see which undefined function throwing "Prelude.undefined". How can this be done?
07:32:10 <_Ray_> Because I have two monads, and I thought a do block was an X-do-block, where X is a particular monad?
07:32:28 <Axman6> two monads? i don't think so...
07:32:36 <hpaste> Axman6 annotated “Sec / SecIO” with “Sec / SecIO (annotation)” at http://hpaste.org/49712#a49713
07:32:44 <Axman6> that looks what i think it should be
07:32:51 <erus`> wow its easier to install ghc on windows than ubuntu
07:33:00 <erus`> how about that...
07:33:43 <Guest28011> erus`: how does it works with shell programming in windows?
07:34:13 <erus`> fine :)
07:34:28 <hpaste> “_Ray_” annotated “Sec / SecIO” with “Sec / SecIO (annotation) (annotation)” at http://hpaste.org/49712#a49714
07:35:07 <Guest28011> erus`: ie, making programs for the command prompt. The command prompt i Windows does not seem good.
07:35:19 <Axman6> _Ray_: this would be a hell of a lot easier if you provided us with the types of each of the functions there
07:35:28 <Axman6> or at least a link to the package you're using
07:35:34 <_Ray_> oh, sorry. this is in hackage, SecLib. http://www.cse.chalmers.se/~russo/eci11/info/doc/seclib/SecLib-Untrustworthy.html#t:Sec
07:35:45 <erus`> checking for path to top of build tree... utils/pwd/pwd: error while loading shared libraries: libgmp.so.3: wrong ELF class: ELFCLASS64
07:35:53 <erus`> this is a nightmare
07:36:08 <Axman6> do you have gmp installed?
07:36:21 <_Ray_> (it's also at http://hackage.haskell.org/packages/archive/seclib/0.7/doc/html/SecLib-Untrustworthy.html )
07:36:24 <hpaste> cafaro pasted “xmonad.hs” at http://hpaste.org/49715
07:37:00 <Axman6> _Ray_: i think you need `value (up foo)`, because up has type Less s s' => Sec s a -> Sec s' a, not Less s s' => SecIO s a -> SecIO s' a
07:37:12 <erus`> why is there no ghc7 package?
07:37:39 <Jester_Racer> hi
07:37:46 <Axman6> eevar: talk to the ubuntu guys, not us. they're the ones who control what packages their distro has
07:37:55 <Axman6> uh, erus`, not eevar
07:38:06 <_Ray_> Axman6, but isn't "cf <- readFileSecIO f -- unpack the sec string" a Sec a String?
07:38:27 <_Ray_> (since I'm in a do block and readFileSecIO returns a SecIO (Sec String))
07:38:32 <Axman6> yes, but you're working inside the SecIO monad, which is something different to Sec
07:38:40 <eevar> Axman6: pretty close, though. I just logged on irc to bitch to #debian about cabal being broken ;)
07:39:07 <Guest28011> erus`:https://wiki.ubuntu.com/MOTU/Teams/UncommonProgrammingLanguages/Haskell
07:39:09 <Axman6> _Ray_: look at the type of up
07:39:21 <_Ray_> Oh, OK. So I have to take the stuff from Sec and put it in a SecIO.
07:39:23 <Axman6> eevar: heh
07:39:25 <erus`> uncommon?
07:39:28 <Axman6> yes
07:39:37 <_Ray_> Nice. That works :) (Or, at least, types). Thanks.
07:39:37 <Axman6> (at _Ray_)
07:39:53 <Axman6> _Ray_: something slightly nicer would be this though... (one sec)
07:40:06 <Guest28011> erus`: linux-programmers only know about shell scripting and C
07:41:36 <hpaste> Axman6 annotated “Sec / SecIO” with “Sec / SecIO (annotation) (annotation)” at http://hpaste.org/49712#a49718
07:41:41 <Axman6> _Ray_: ^^^
07:42:10 <_Ray_> hrmph.
07:42:25 <_Ray_> oh, ok, you're taking advantage that ++ plays well with taking stuff in and out the monad
07:42:44 <_Ray_> specifically you're using ++ in a Sec context, then putting the result in a SecIO context, as opposed to taking two Secs, and putting their concatenation in a SecIO
07:42:48 <Axman6> urgh, Sec isn't an applicative -_-
07:43:36 <_Ray_> what would that give you? ability to use ++ with the Sec stuff?
07:47:55 <mistertim> Hey all- any of you guys use cabal-dev and know how to provide a search path for imported modules to 'cabal-dev ghci'? It doesn't want to look in my src/ directory, and neither "cabal-dev ghci -isrc/" nor setting "hs-source-dirs" in my cabal file seem to help...
07:49:13 <mistertim> chrisdone: have you looked at Mendeley? it's not quite that advanced but certainly helps with organising /categorising papers &c: http://www.mendeley.com/
08:03:57 <chrisdone> http://hackage.haskell.org/packages/archive/HJavaScript/0.4.7/doc/html/Language-HJavaScript-Syntax.html
08:03:57 <chrisdone> the pretty printer on here seems incorrect for: JCall (JFunction Nothing () EmptyBlock) ()
08:03:57 <chrisdone> it outputs function(){}() which is invalid syntax, it should output (function(){})()
08:03:59 <chrisdone> because i can't be bothered patching the library on this machine or writing a new pretty printer, does anyone know another way to achieve the apply-anonymous-function construct?
08:05:01 <mauke> that prettyprint is valid depending on context
08:05:27 <_Ray_> (i.e. expression context)
08:05:52 <mauke> expression context is not enough
08:06:25 <_Ray_> var t = function(){}() seems to work
08:07:56 <mauke> If foo EmptyBlock NoElses  -- evil
08:08:31 <mauke> oh, doesn't work anyway
08:08:35 <mauke> too much typing
08:10:34 <chrisdone> λ> ExpStmt $ JCall (JFunction Nothing () EmptyBlock) ()
08:10:34 <chrisdone> function (){}()
08:10:40 <chrisdone> mauke: isn't this enough context?
08:10:53 <mauke> it is; the module's broken
08:11:34 <mauke> what the heck is a JRec?
08:12:02 <chrisdone> tch, no docs
08:12:05 <mysticc> whats the problem in [(map (+1) j) | j <- [2..20] ]
08:12:12 <mauke> mysticc: j is not a list
08:12:13 <chrisdone> ahhh
08:12:22 <_Ray_> chrisdone, can you tell it that this is happening in a statement context?
08:12:23 <chrisdone>     JRec e1 e2             ->  showString "{fst:" . shows e1 . showString "," .
08:12:23 <chrisdone>                                showString  "snd:" . shows e2 . showString "}"
08:12:23 <chrisdone> heh ^
08:12:40 <mauke> ok, who the heck designed this shit
08:12:49 <mysticc> mauke: then what is it .. cause this works [(take 5 j) | let j = [2..20] ]
08:12:51 <luite> is it really worth the hassle to use hjavascript? :)
08:13:00 <mauke> mysticc: that j is a list
08:13:04 <_Ray_> mysticc, one has =, one has <-
08:13:11 <_Ray_> = is "is", <- is "take one from".
08:13:25 <chrisdone> luite: heh. i looked at about 5 js outputting libraries on hackage. thought this one looked well-typed
08:13:34 <mauke> chrisdone: that's exactly the problem
08:13:39 <mauke> it can't represent most javascript
08:13:45 <mysticc> luite: What is the one that has <-
08:13:54 <chrisdone> mhm
08:14:20 <mysticc> ok thanks ....
08:14:21 <luite> mysticc: sorry haven't read the conversation, what do you mean? :)
08:14:34 <mauke> chrisdone: do you know what JBlock is?
08:14:47 <mysticc> luite: Sorry my mistake .... it was not directed to you
08:15:18 <mysticc> _Ray_: Can you tell when <- is used in list comprehensions
08:15:20 <chrisdone> mauke: as I understand it the block is zero or more statements { x; x1; .. }
08:15:34 <chrisdone> oh, wait
08:15:41 <chrisdone> you mean as an expression. i have no idea
08:15:55 <mauke> how does it prettyprint?
08:16:02 <_Ray_> mysticc, a list comprehension is: [f x | x <- somelisthere]. x first is the first element of somelisthere, then the second, etc... . for each element, you calculate f x and append it to the resulting list.
08:16:13 <luite> do people here use yesod-form? I have a post about better validation on the yesod mailing list, but I find it kind of hard to believe that it requires replacing about half of the yesod-form code
08:16:48 <mysticc> _Ray_: Thanks ..... :)
08:16:51 <chrisdone> H> JBlock (Sequence (Sequence EmptyBlock (VarDecl "x")) (VarDecl "y"))
08:16:51 <chrisdone> var x;var y;
08:16:58 <mauke> argh. they mistyped Or. I'm going to kill the fuckers
08:17:00 <chrisdone> mauke: ^ oooops
08:17:14 <mauke> lol wut
08:18:13 <luite> who makes good 15" laptops with full hd screen?
08:18:23 <chrisdone> JBlock EmptyBlock outputs an empty string... k, /me moves onto the next DSL
08:18:33 <luite> hmm, that was supposed to be -blah
08:18:58 <mauke> JCall (JIfOp (JBool True) foo foo) ()
08:19:06 <_Ray_> Why wouldn't this work, assuming Sec is a monad? (map (return :: Sec L) [True, True, False])
08:19:09 <mauke> that's the best I can do given the constraints
08:19:20 <mauke> _Ray_: return is a function
08:19:34 <_Ray_> (err, Sec L Bool, I mean)
08:19:39 <_Ray_> mauke: And isn't that the point of map?
08:19:45 <mauke> _Ray_: irrelevant
08:19:53 <mauke> _Ray_: return :: Sec L Bool is an error
08:20:03 <mauke> inferred type: a -> m a
08:20:09 <mauke> expected type: Sec L Bool
08:20:18 <_Ray_> How could I get from [True, True, False] to [return True, return True, return False] then?
08:20:26 <mauke> map return
08:20:43 <_Ray_> But then it doesn't know which return to use
08:20:48 <mauke> why not?
08:21:09 <_Ray_> Because return isn't defined without a Monad, at least.
08:21:18 <mauke> have you tried it?
08:21:25 <_Ray_> yep
08:21:28 <benmachine> _Ray_: the way in which you use the result will tell GHC what monad to use
08:21:32 <mauke> what's the error message?
08:21:47 <_Ray_> " map return [True, True, False]" gives     Ambiguous type variable `m0' in the constraint:
08:21:48 <_Ray_>       (Monad m0) arising from a use of `return'
08:21:48 <_Ray_>     Probable fix: add a type signature that fixes these type variable(s)
08:21:48 <_Ray_>     In the first argument of `map', namely `return'
08:22:08 <_Ray_> benmachine, can't I... help ghc?
08:22:15 <benmachine> _Ray_: yes
08:22:23 <benmachine> there are several ways of doing so
08:22:41 <_Ray_> none of which seems to be return :: Sec H Bool, unfortunately :(
08:22:42 <mauke> _Ray_: is that the real code or just ghci?
08:22:54 <_Ray_> mauke, ghci
08:22:57 <mauke> ...
08:22:59 <kosmikus> map return [True, True, False] :: [Sec L Bool]
08:23:07 <_Ray_> I want it to show  me the result of the expression
08:23:08 <kosmikus> ^^ one way
08:23:22 <_Ray_> ah, that works
08:23:29 <mauke> map (return :: Bool -> Sec L Bool) [...]
08:23:42 <_Ray_> ah
08:24:03 <chrisdone> mauke: hahaha, the output: true?function (){}:function (){}()
08:24:07 <chrisdone> this library is balls
08:24:12 <mauke> wat
08:24:25 <luite> hmm
08:28:22 * chrisdone goes for a walk
08:30:25 <mauke> JBinOp (JInt 2) Times (JBinop (JInt 3) Plus (JInt 4))
08:30:42 <mauke> if that generates 2*3+4 I'm going to lose all hope in humanity
08:31:03 * chrisdone lols
08:31:12 <chrisdone> H> JBinOp (JInt 2) Times (JBinOp (JInt 3) Plus (JInt 4))
08:31:12 <chrisdone> 2 * 3 + 4
08:31:18 <mauke> …
08:31:21 <luite> hehe
08:31:30 <hpc> wait what
08:31:33 <mauke> so basically no one ever tested or used this
08:31:41 <mauke> it can't represent half of javascript
08:31:46 <luite> there are more libraries like that on hackage
08:31:53 <mauke> but it's got cool types and non-standard excentions like tuples and 'show'
08:31:54 <luite> and usually the authors don't respond to email
08:32:03 <namkoita> What does STM stand for
08:32:08 <benmachine> hackage 2.0 plx
08:32:10 <luite> I really think that we should be able to kick packages off  hackage :p
08:32:11 <hpc> software transactional memory
08:32:15 <pr> Software Transactional Memory namkoita
08:32:20 <namkoita> Thanks
08:32:21 <erus`> is ghc6 drasticly different from 7?
08:32:27 <benmachine> erus`: no
08:32:38 <erus`> i'll just use that then
08:32:39 <benmachine> well, depending on what you think of as drastic, but probably not
08:32:48 <erus`> save some hastle
08:33:24 <mauke> "excentions"? I meant extensions
08:33:42 <chrisdone> pretty special. i look forward to some kind of quality rating on hackage2
08:33:47 <mauke> ok, round 2: exploit bugs to generate valid code
08:34:25 <hpc> mauke: what library i tis?
08:34:31 <hpc> *is this
08:34:37 <mauke> Language.HJavaScript.Syntax
08:35:33 <hpc> i think even the module i hacked up in a week might be better than that
08:36:12 <mauke> hmm, harder than expected. this module simply doesn't generate parens, ever
08:37:20 <hpc> a cursory glance through the code at least makes it seem like the types were chosen well
08:37:49 <mauke> no, they obviously weren't
08:39:08 <sonoflilit> Does anyone know how I assign a uniform matrix with Haskell's OpenGL bindings?
08:39:33 <mauke> hpc: JNeg :: Exp t -> Exp t; JNot :: Exp Bool -> Exp Bool
08:39:40 <mauke> that's pretty much the opposite of what I'd expect
08:40:04 <mauke> oh shit, I completely missed that
08:40:11 <hpc> eh?
08:40:22 <mauke> this fucking module can't represent the only fucking numeric type javascript has
08:44:03 <mauke> hpc: that means I can negate any type (not just numbers), but negation only works on bool (not all values)
08:44:07 <ClaudiusMaximus> sonoflilit: i think you can use 'uniformv' (which is ugly; or use the raw bindings...)
08:44:59 <hpc> it sort of makes sense
08:45:07 <hpc> JNeg "x" = "-x"
08:45:13 <hpc> JNot "x" = "!x"
08:45:22 <hpc> but JNeg does need a Num constraint
08:45:40 <mauke> it doesn't make sense
08:46:05 <sonoflilit> ClaudiusMaximus: do you know how to use it?
08:46:35 <ClaudiusMaximus> sonoflilit: i think i used it once, but i have to go now...
08:46:44 <sonoflilit> then I'll have to figure it out :)
08:46:47 <mauke> ok, your best bet when working with this module is VarDecl ("window;" ++ generateJS)
08:46:48 <ClaudiusMaximus> sonoflilit: ...will be back in about 3 hours
08:46:52 <sonoflilit> probably the code for uniform is based on uniformv
08:56:08 <Darkproger> guys, if the function returns IO Bool, how to get bool result out of it? i'm trying to play with the library inside ghci
08:56:39 <hpc> x <- ioAction
08:56:48 <hpc> if ioAction :: IO a, x :: a
08:57:18 <Darkproger> thanks!
08:57:57 <erus`> @pl f x = (x + x) * x
08:57:57 <lambdabot> f = (*) =<< join (+)
09:12:23 <aristid> is there a nice, well-known data structure that is an ordered sequence and associative map at the same time? like [(k,v)], but hopefully more efficient
09:13:04 <XniX23> which book is better for a beginner lyah or rwh?
09:13:53 <aristid> XniX23: lyah, i guess
09:14:30 <Axman6> lyah, followed by rwh when you're comfortable with haskell
09:15:05 <monochrom> Data.Map sufficies usually
09:15:33 <flux> monochrom, I think he wants to preserve an order that cannot be determined from the values themselves
09:15:58 <djahandarie> aristid, dunno, people here say a sequence of (k,v) or something with a map from the key to the index in the sequence
09:16:03 <djahandarie> Probably doesn't exis
09:16:23 <hpc> aristid: s/[]/Tree/ perhaps?
09:16:33 <hpc> (Tree (k,v))
09:16:51 <aristid> hpc: then i don't get both efficient lookup and arbitrary ordering
09:17:10 <hpc> ah right
09:17:55 <kmc> XniX23, read them both, see which one you like
09:18:08 <aristid> djahandarie: hmm, maybe if you use IntMap, you can make a lot of flexible data structures by first translating everything to an Int, and then looking the actual value up in the IntMap
09:19:00 <aristid> i was hoping that arbitrary ordering + key-based lookup was a sufficiently common requirement that there would be a dedicated data structure for it
09:20:11 <XniX23> kmc: im actually thinking of buying lyah
09:20:33 <aristid> preflex: seen BONUS
09:20:33 <preflex>  BONUS was last seen on #haskell 91 days, 21 hours, 12 minutes and 15 seconds ago, saying: yeah i think that's better as well
09:20:37 <aristid> uh.
09:21:43 <aristid> XniX23: do you know any other programming languages?
09:22:05 <XniX23> aristid: java, php, python
09:22:16 <XniX23> mostly python
09:22:33 <monochrom> note: the more you know, the more you have to unlearn
09:23:07 <c_wraith> XniX23: first lesson - Haskell is not a new syntax for the same ideas those three languages have share.
09:23:46 <XniX23> c_wraith: thats the reason i want to learn it
09:23:53 <c_wraith> *sigh*.  minus the word "have"
09:24:00 <XniX23> monochrom: motivating
09:24:35 <XniX23> so bonus is not around anymore?
09:24:57 <c_wraith> XniX23: regarding your question, I'd start with LYAH.  when it starts feeling abstract, and you start wondering how to actually do stuff with everything you're learning, that's when it's time to add in RWH
09:25:15 <c_wraith> preflex: seen BONUS
09:25:16 <preflex>  BONUS was last seen on #haskell 91 days, 21 hours, 16 minutes and 57 seconds ago, saying: yeah i think that's better as well
09:25:29 <c_wraith> Looks like he hasn't been around in three months
09:26:27 <monochrom> I think he will yet appear again
09:26:40 <c_wraith> likely
09:27:30 <chrisdone> monochrom: http://www.gifsforum.com/images/image/op%20will%20delivers/grand/op_will_surely_deliver_lets_just_wait.jpg
09:28:12 <monochrom> speaking of which, I'm precisely waiting for you!
09:28:44 <monochrom> why is Data.List in scope when evaluating an expression but not when loading declarations?
09:30:53 <Eliel> what is wrong with this instance declaration? instance ToJSON (Fixed E8) where toJSON = toJSON . toRational
09:31:01 <Eliel> ghci tells me it's illegal instance declaration
09:32:06 <benmachine> Eliel: in basic haskell, you can only define instances for type constructors applied to type variables
09:32:15 <benmachine> in that case you've got a type constructor applied to a type constructor
09:32:34 <chrisdone> monochrom: good question
09:32:46 <benmachine> Eliel: if you enable FlexibleInstances ghc will stop whining, probably; FlexibleInstances is one of the less controversial extensions
09:33:05 <XniX23> does haskell give you a better understanding of how other languages work?
09:33:11 <chrisdone> monochrom: what's a non-Prelude Data.List function I can check with?
09:33:19 <benmachine> intercalate
09:33:28 <Eliel> it seems to have fixed the the problem now that I replace E8 with letter r and added HasResolution r => to the beginning
09:33:36 <benmachine> Eliel: ah yes, that works too :)
09:33:38 <chrisdone> okies
09:33:45 <roconnor> XniX23: Haskell is pretty good at letting you get by without even knowing how Haskell is implemented.
09:34:25 <Eliel> the E8 type is defined as: newtype E8 = E8 E8, not my code and I still don't quite understand what it's doing :)
09:34:49 <ddarius> Eliel: What is actually desired is data E8; but that requires an extension.
09:34:53 * chrisdone tests tryhaskell on his shiny new ipod
09:35:04 <benmachine> Eliel: E8 is only supposed to exist as a type, you're not supposed to use its values
09:35:29 <Eliel> ah, so abstract type in a way?
09:35:34 <roconnor> ya
09:35:49 <roconnor> it's almost like a phantom type ... maybe it is even a phantom type in a sense.
09:35:49 <ddarius> Eliel: I wouldn't describe it that way.
09:35:52 <ddarius> It has no values.
09:36:15 <ddarius> (at least that is the intent)
09:36:25 <Eliel> ddarius: well, java has abstract classes which have no values, I figured "abstract" might work for describing this too :D
09:36:36 <chrisdone> hah. it works. surprising
09:36:49 <ddarius> Eliel: Concrete subclasses of an abstract class are values of that abstract class.
09:36:58 <Jester_Racer> hi everyone. I would like to implement a graphic scene in which I can store graphic objects. these graphic objects can be displayed and moved on the screen. I've already tried to implement it but I'm not sure that it's haskell'ish :) Is there any tutorials or examples on the net?
09:37:06 <Jester_Racer> (I'm using SDL)
09:37:22 <roconnor> Eliel: actually whether it has or has no values is irrelevent for the use of E8.  It is only supposed to be used on the type level.  Thought giving it no values helps disincentive it's use on the value level.
09:37:23 <ddarius> Eliel: Also, "abstract type" has different meanings [sans context] here as opposed to in Java, etc.
09:37:55 <benmachine> roconnor: it's fair to say that it has no interesting values
09:38:09 <Eliel> roconnor: ah, you're here :) how's PureCoin getting along?
09:38:18 <roconnor> ddarius: can we call E8 a phantom type?  It has similar properties to normal phantom types, but is a little different.
09:38:31 <ddarius> roconnor: I wouldn't call it a phantom type.
09:38:51 <benmachine> how *do* you guys define phantom types? I wrote the wiki article on them and it's starting to sound like I wrote it wrong :P
09:38:57 <roconnor> well, we definitely need a name for types used in this sense.
09:39:06 <benmachine> ( http://haskell.org/haskellwiki/Phantom_type )
09:39:37 <chrisdone> monochrom: intersperse works here http://tryhaskell.org/haskell.json?method=eval&contents=x=%22ab%22&expr=intersperse%20','%20x
09:39:40 <roconnor> benmachine: well I don't know a definition, but usually it is type variables that occur as parameters to type constructors but are not used in the type constructor's definition.
09:40:01 <benmachine> roconnor: would you agree with the wording of the article?
09:40:07 <roconnor> benmachine: so phantom types are always type variables in the context I've seen them used.
09:40:28 <benmachine> roconnor: hm.
09:40:30 <chrisdone> lonely type variables with no friends on the right
09:40:35 <kmc> XniX23, Haskell will give you a better understanding of how other languages don't work
09:40:53 <kmc> and the degree to which most programming languages are designed by people who have no idea what the hell they're doing
09:40:59 <benmachine> roconnor: that sounds right, although I wonder if there's a distinction between "phantom type" and "phantom type variable"
09:41:05 <roconnor> benmachine:  I don't know enough about the definition of phantom types to know if that article is right or wrong.
09:41:47 <roconnor> Eliel: I've finally resumed working on it.
09:41:47 <ddarius> http://web.archive.org/web/20061011032657/http://www.haskell.org/hawiki/PhantomTypes
09:41:53 <kmc> the way i understand the term, it's a property of type parameters andnot types themselves
09:41:59 <Eliel> roconnor: great! :)
09:42:30 <Eliel> roconnor: I hope you have time to comment on the code I sent you in email sometime soon :)
09:43:00 <chrisdone> ViewPatterns are particularly nice for splitting up huge pattern matches
09:43:29 <XniX23> kmc: making me depressed at work having to use other languages?
09:43:40 <benmachine> ddarius: that's a nice example but it's sufficiently vague in the way it uses language that I'm not sure how to translate it
09:43:41 <kmc> yes
09:43:48 <hpaste> chrisdone pasted “view patterns are nice” at http://hpaste.org/49723
09:44:11 <ddarius> benmachine: This is the first line of the abstract to the referenced paper: Recent work on embedding object languages into Haskell use ``phantom types'' (i.e., parameterized types whose parameter does not occur on the right-hand side of the type definition) to ensure that the embedded object-language terms are simply typed.
09:44:16 <XniX23> kmc: whats the upside of learning it then :S
09:44:23 <ddarius> That doesn't seem vague to me.
09:45:04 <Axman6> XniX23: you learn new ideas you can use in those other languages
09:45:11 <dmcohen> hi
09:45:31 <benmachine> ddarius: hm. so the type itself is phantom, not the parameter?
09:45:42 <kmc> XniX23, do you generally agree with the statement "ignorance is bliss"?
09:46:07 <ddarius> kmc: It's true.  Any lack of bliss can be solved by increasing ignorance.
09:46:22 <benmachine> ddarius: that seems to imply that in data FormData a = FormData String, FormData would be a phantom type, but I'd be more used to saying 'a' is a phantom type
09:46:34 <roconnor> Eliel: looking at it now.  The outline seems more or less fine, but orthogonal to what I'm interested in implementing (which is probably a good thing).  My goal is to get a core bitcoin library up and running so that people like you can write P2P or RPC code that uses it.
09:46:45 <chrisdone> kmc: if ignorance is bliss, then knock the smile off my face, yeeeeaahhh (Rage Against the Machine)
09:47:26 <Eliel> roconnor: yes, I tried to pick a part you hadn't been working on yet :)
09:48:12 <XniX23> kmc: sadly, no
09:48:22 <monochrom> chrisdone, my point is the load method, not the eval method
09:48:26 <roconnor> Eliel: you've found it :D  I have just barely enough Networking code to build a test harness for the core code.
09:49:05 <chrisdone> ddarius: right -- if you've lost your car in the car park that ignorance doesn't feel good, but then you just need to forget that you even have a car and now you're happy again! just walk home :-)
09:49:19 <_Ray_> If I have a long list, how can I break its definition up into multiple lines? GHC keeps complaining about a "possibly incorrect indentation".
09:49:33 <roconnor> Eliel: I know nothing about building P2P networks ... and frankly I'm not entirely convinced the bitcoin people know much about it either.
09:49:47 <ddarius> benmachine: The usage in that paper is also how the term is used in "First Class Phantom Types."
09:50:01 <Eliel> roconnor: To me, it looks like they're still just learning too. The original developer is no longer participating either.
09:50:15 <roconnor> ya
09:50:22 <chrisdone> monochrom: ah, you mean the contents parameter. uhmm
09:50:44 <benmachine> ddarius: so you'd agree that FormData is a phantom type?
09:50:48 <ddarius> Yes.
09:50:52 <benmachine> oh ok
09:51:03 <monochrom> http://tryhaskell.org/haskell.json?method=load&contents=x=intersperse
09:51:12 <chrisdone> yah i got it
09:52:31 <chrisdone> i can't fix it right now. my linux laptop's charge is fubared and my macbook doesn't have the ssh details. i'll add a todo item in my calendar
09:54:06 <chrisdone> fwiw 'eval' with a 'contents' parameter is a little nicer. referentially transparent API is referentially transparent
09:54:34 <_Ray_> Given a list of (a, b), how could I map over them a function f :: a -> b -> c?
09:54:52 <kmc> :t map (uncurry ?f)
09:54:52 <lambdabot> forall a b c. (?f::a -> b -> c) => [(a, b)] -> [c]
09:55:08 <_Ray_> Nice, thanks :)
09:56:53 <monochrom> oh, eval can take contents too? nice
09:57:02 <ddarius> benmachine: Also, even if the example that Chris Angus provided is vague, it clearly doesn't use what you are calling phantom types at the top.
09:57:09 <kmc> _Ray_, re long lists, you just have to make sure each "continuing" line is indented further than the column where definitions start inside this "let" or "where" block
09:57:27 <benmachine> ddarius: right, I'm editing it now
09:58:21 <chrisdone> does anyone actually use implicit parameters in their projects? i haven't once used it. i go straight for a reader monad
09:58:23 <_Ray_> kmc: Thanks :)
09:58:44 <luite> hmm, I've never seen them used, never felt the need to do so myself
10:00:04 <nihtml`> @pl let f x = (x,x)
10:00:04 <lambdabot> (line 1, column 16):
10:00:05 <lambdabot> unexpected end of input
10:00:05 <lambdabot> expecting variable, "(", operator, ";" or "in"
10:00:14 <args[0]> j #flac
10:00:36 <kmc> i can't recall ever using them
10:01:54 <PhillipA> @pl f x = (x,x)
10:01:54 <lambdabot> f = join (,)
10:03:30 <nihtml`> :t join
10:03:31 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
10:04:21 <PhillipA> > join ["a", "bc"]
10:04:22 <lambdabot>   "abc"
10:04:29 * edwardk waves hello,
10:04:37 <benmachine> chrisdone: iirc, some parts of lambdabot use implicit params
10:04:40 * ddarius waves goodbye.
10:04:43 <benmachine> but that's the only time I've ever seen it
10:04:58 <roconnor> @type either fail return
10:04:59 <lambdabot> forall (m :: * -> *) a. (Monad m) => Either String a -> m a
10:05:04 <_Ray_> How can I, given a [IO ()], perform those actions?
10:05:13 <roconnor> @type sequence
10:05:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
10:05:18 <roconnor> @type sequence_
10:05:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
10:05:23 <roconnor> _Ray_: ^^
10:05:29 <_Ray_> Thanks :)
10:05:40 <roconnor> you probably want sequence_ in this case.
10:05:41 * hackagebot intern 0.1 - Efficient hash-consing for arbitrary data types  http://hackage.haskell.org/package/intern-0.1 (EdwardKmett)
10:06:03 <roconnor> _Ray_: note that mapM_ is the composition of sequence_ and map
10:06:10 <roconnor> @src mapM_
10:06:10 <lambdabot> mapM_ f as = sequence_ (map f as)
10:06:17 <edwardk> now that that yak is shaved i can actually work on what i wanted to work on
10:06:27 <edwardk> pay no attention to the naked yak
10:06:32 <roconnor> _Ray_: I almost always use mapM_ over sequence_
10:06:49 <_Ray_> hrmph. well, I have a [(DCLabel, DCLabel)] called labels, I want to say , and a printFlowTo :: DCLabel -> DCLabel -> IO (), I want to say sequence_ $ map (uncurry printFlowTo) labels
10:06:50 <roconnor> edwardk: have you ever tested the performance of van Laarhoven lenses?
10:07:06 <kmc> _Ray_, sequence_ . map ≡ mapM_
10:07:11 <roconnor> _Ray_: that is mapM_ (uncurry printFlowTo) labels
10:07:25 <Axman6> @src mapM_
10:07:25 <lambdabot> mapM_ f as = sequence_ (map f as)
10:07:48 <_Ray_> Does that type well though? Should I use it as "main = do mapM_ ... "?
10:07:58 <kmc> (my equation is not correct :/)
10:08:03 <kmc> :t mapM_
10:08:04 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
10:08:11 <roconnor> _Ray_: you can. though if that is the only line you can drop the do.
10:08:34 <_Ray_> Nice, thanks :)
10:08:42 <edwardk> roconnor: the problem with them is they require way too much work on the behalf of implementors. so they fail that performance test. otherwise you wind up doing a lot of work to meet the isomorphism invariant
10:08:45 <benmachine> sequence . map f = mapM f
10:09:33 <edwardk> they did inspire me the other day to give the snap framework guys a more efficient lensed state monad for their snaplet code though, which basically carries around an s with a v shaped hole in it and the v as the state so you can work efficiently with local state until you have to refocus
10:09:39 <roconnor> edwardk: oh, is this because the get and set functions for records are practically free?
10:09:45 <edwardk> yeah
10:09:51 <PhillipA> _Ray_: see also http://mauke.dyndns.org/stuff/haskell/how-to-io.html#a7
10:10:12 <edwardk> but the isomorphism lenses require you to write O(n) code for each lens. where n is proportional to the number of other fields
10:10:19 <roconnor> edwardk: so van Laarhoven lenses might work better for abstract lenses.
10:10:24 <Axman6> so, i wonder why there's a tail recursive version of sequence, suing reverse. it's guaranteed to have the same results, without the huge stack usage
10:10:40 <edwardk> wait, the van laarhoven ones were which again?
10:10:41 <roconnor> edwardk: oh I don't mean isomorphism lenses
10:10:43 <roconnor> heh
10:10:44 <edwardk> for a second there i thought you meant iso
10:10:51 <edwardk> because he'd switched to those
10:11:01 <roconnor> I mean the forall f:Functor. (b -> f b) -> (a -> f a)
10:11:11 <edwardk> oh, those =(
10:11:21 <Axman6> sequence xs = go xs []; go [] ys = return (reverse ys); go (x:xs) ys = do y <- x; go xs (y:ys)
10:11:23 <edwardk> they've never performed well for me
10:11:29 <roconnor> (satifying the laws of a monoidal natural transformation)
10:11:32 <edwardk> i don't have hard benchmarks handy though
10:11:40 <roconnor> edwardk: but you've tried?
10:11:43 <edwardk> yeah
10:11:46 <roconnor> huh
10:11:51 <chrisdone> i can't concentrate with my neighbor playing guitar. he sucks at it but seems to have infinite motivation
10:11:55 <roconnor> it looks so continuationy
10:12:03 <edwardk> intuitively you can view them as being forced to use whatever fmap you give them, so they pay an 'interpreter tax'
10:12:03 <roconnor> I figured it would be fast
10:12:12 <roconnor> with no data structures to compose or decompose.
10:12:15 <edwardk> they have to take some unknown map and apply it
10:12:15 <_Ray_> Also, how can I ask lambdabot for a function matching a type signature? (I can't remember the name of the function that takes a list of strings and a string separator and joins them)
10:12:25 <dankna> :t liftM2
10:12:26 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
10:12:26 <chrisdone> @hoogle [a] -> Int
10:12:27 <lambdabot> Prelude length :: [a] -> Int
10:12:27 <lambdabot> Data.List length :: [a] -> Int
10:12:27 <lambdabot> Prelude head :: [a] -> a
10:12:27 <edwardk> so all they can do is dig around in the dictionary and call that method
10:12:36 <_Ray_> Cool, thanks :)
10:12:46 <PhillipA> _Ray_: hoogle, but it's also a command line program and a web page
10:12:47 <benmachine> _Ray_: http://www.haskell.org/hoogle/ full version
10:12:48 <dankna> _Ray_ oh that wasn't an answer to your question
10:12:54 <dankna> oh chrisdone answered it, good
10:13:13 <PhillipA> _Ray_: intercalate
10:13:23 <_Ray_> hell yeah, that was so awesome xD
10:13:46 <benmachine> oh man we have a philipa with one l and two ps and with two ls and one p
10:13:48 * benmachine dies
10:14:40 <dankna> :t liftM2 (,) (xh :: [(Type, Type)]) (x :: [Type])
10:14:40 <lambdabot> Not in scope: `xh'
10:14:40 <lambdabot> Not in scope: type constructor or class `Type'
10:14:40 <lambdabot> Not in scope: type constructor or class `Type'
10:16:19 <dankna> :t liftM2 (,) [(1, 2), (2, 3)] [1, 2, 3]
10:16:19 <lambdabot> forall a2 t t1. (Num t, Num t1, Num a2) => [((t, t1), a2)]
10:16:23 <_Ray_> Hrm, can a do-block be made pointfree?
10:16:31 <kmc> yes
10:16:35 <chrisdone> yeah but usually not pretty
10:16:36 <kmc> "do" is just sugar for (>>=)
10:16:37 <hpc> it can be undo'd, then pl'd
10:17:00 <_Ray_> Well, would that still be a do block, or would it just be a chaining of >>=?
10:17:06 <roconnor> @undo do { x <- f a; y <- f b; g x y}
10:17:06 <lambdabot> f a >>= \ x -> f b >>= \ y -> g x y
10:17:17 <hpc> @pl f a >>= \ x -> f b >>= \ y -> g x y
10:17:17 <lambdabot> (f b >>=) . g =<< f a
10:17:22 <kmc> _Ray_, the latter
10:17:25 <hpc> huh, that wasn't so bad
10:17:27 <roconnor> @. pl undo do { x <- f a; y <- f b; g x y}
10:17:27 <lambdabot> (f b >>=) . g =<< f a
10:17:28 <_Ray_> Ah :)
10:18:00 <ion> :t \f g a b -> f a >>= \ x -> f b >>= \ y -> g x y
10:18:00 <kmc> i mean technically you can write expressions using "do" which are free of name binding
10:18:00 <lambdabot> forall t (m :: * -> *) a b. (Monad m) => (t -> m a) -> (a -> a -> m b) -> t -> t -> m b
10:18:22 <kmc> (do { f b} >>=) . g =<< (do { f a })
10:18:25 <kmc> no point though ;;P
10:18:59 <\yrlnry> Is there a name or a better way to write this combinator?
10:19:00 <PhillipA> benmachine: capitalization matters
10:19:02 <\yrlnry>  \f ls -> uncurry (zipWith f) $ unzip ls
10:19:09 <\yrlnry> :t  \f ls -> uncurry (zipWith f) $ unzip ls
10:19:09 <lambdabot> forall a b c. (a -> b -> c) -> [(a, b)] -> [c]
10:19:24 <ion> :t \f g a b -> join (liftA2 g (f a) (f b))
10:19:24 <lambdabot> forall t a (m :: * -> *) a1. (Applicative m, Monad m) => (t -> m a) -> (a -> a -> m a1) -> t -> t -> m a1
10:19:36 <Axman6> isn't that just map (uncurry f) ls?
10:19:44 <PhillipA> :t map . uncurry
10:19:45 <lambdabot> forall b a b1. (a -> b1 -> b) -> [(a, b1)] -> [b]
10:19:56 <\yrlnry> Thanks!
10:19:56 <Axman6> yes
10:19:58 <Axman6> go me
10:20:03 <\yrlnry> go you!
10:20:09 <PhillipA> no u
10:20:17 <benmachine> go yo!
10:20:21 <dafis> go yo?
10:20:31 * dafis was too slow again
10:20:34 <benmachine> :D
10:20:49 <\yrlnry> fro-yo
10:20:55 <Axman6> yo yo!
10:21:27 <adrake> it looks like Data.Iteratee.Iteratee.enumHandle doesn't hand off a chunk until its buffer is full, which is somewhat... suboptimal for network IO
10:21:37 <ion> :t \f g -> join .: (liftA2 g `on` f)
10:21:37 <lambdabot> forall (m :: * -> *) a b a1. (Monad m, Applicative m) => (a1 -> m b) -> (b -> b -> m a) -> a1 -> a1 -> m a
10:21:40 <adrake> is there a variant that hands off a chunk of however many bytes read returned?
10:22:53 <Axman6> adrake: it's something that's probably fairly easy to implement, and if you do, worth sending a patch to the author
10:23:09 <adrake> Axman6, yeah, it doesn't seem too hard
10:23:18 <adrake> Axman6, just didn't want to re-write it if somebody already had done it :)
10:24:01 <sonoflilit> Does anyone know how I assign a uniform matrix with Haskell's OpenGL bindings?
10:25:18 <cmccann> the GL bindings are generally pretty close to the C API
10:25:33 <parcs> sonoflilit: with the raw or the "high-level"  bindings?
10:25:48 <cmccann> are you not finding an equivalent to something in C? or just asking in general?
10:28:11 <ion> Btw, for using the letter λ for the lambda construct, a precedent of a similar construct with an alphabetic name: proc pattern → foo
10:29:41 <PhillipA> \ is superior in every regard
10:30:07 <kmc> true ion
10:30:16 <kmc> but one-letter reserved words are generally frowned upon
10:31:06 * PhillipA reserves x and i
10:31:17 <cmccann> there's also the point that it wouldn't replace \
10:31:41 <chrisdone> there's a § on my keyboard. there should be a lambda instead of that
10:31:59 <hpc> there should be anything instead of that
10:32:02 <cmccann> so you'd have two equivalent things, one of which is a single-letter keyword and the other a special symbol
10:32:15 <chrisdone> is there a test list somewhere for haskell implementors to check that their implementation conforms?
10:32:18 <hpc> i don't think i have ever seen that character used to represent anything except sims money
10:32:29 <cmccann> chrisdone, just see how much of hackage compiles? :P
10:32:41 <chrisdone> specifically, runtime
10:32:43 <ion> phillipa: I hear Intellecutal Ventures already patented x and i.
10:33:06 <ion> It seems today is a typo day.
10:33:09 <chrisdone> like a nice "x should produce y", "x should pattern match fail", etc
10:33:41 <chrisdone> phillipa and philippa is gonna get real confusing
10:34:06 <ion> I’ve seen § in law references.
10:34:24 <cmccann> it's called "section sign" btw
10:34:26 <cmccann> http://en.wikipedia.org/wiki/Section_sign
10:35:04 <hpc> oh nifty
10:35:21 <chrisdone> cmccann: i'm using ghc for compiling (i.e. type checking) anyway, i'm talking about code generation and runtime
10:35:58 <ion> chrisdone: If you switched to the us layout, there more useful `~ would probably be in its place.
10:36:57 <chrisdone> ion: nop, i have those too on the same keyboard
10:36:59 <PhillipA> on my keyboard § gives me #
10:37:10 <dafis> ion: I know a few lawyers who would dispute your usefulness ranking
10:37:21 <ion> chrisdone: Ah, ok. Which layout is it?
10:37:30 <cmccann> I know a few people who would dispute the usefulness of lawyers
10:37:33 <chrisdone> macbook default; us i guess
10:38:14 <joe6> just read about the const of C. Isn't that the same as a pure function of haskell?
10:38:17 <PhillipA> my physical layout is german; my logical layout is a modified version of en_US
10:38:23 <dafis> cmccann: as with so many things/people, sometimes they're very useful, even if terribly annoying most of the time ;)
10:38:25 <PhillipA> joe6: no
10:38:47 <joe6> PhillipA: oh, really.
10:38:57 <chrisdone> cmccann: i know a few lawyers who would dispute the usefulness of people -- given enough money? hehe
10:39:37 <cmccann> dafis, lawyers are basically programmers, really. the write their programs in an odd dialect of english, and run them using the legal system
10:39:40 <pikhq_> joe6: __attribute__((const)), maybe.
10:39:52 <joe6> pikhq_: yes, that is what I meant.
10:39:58 <pikhq_> (which isn't really C, but GNU C, but anyways)
10:40:04 <PhillipA> that's not C, that's gcc
10:40:14 <Axman6> joe6: C functions taking const arguments can still modify global state
10:40:26 <cmccann> which is why it's always laughable when people want programming languages to look more like english, because that exists, and people make fun of legalese for exactly the reason it works
10:40:27 <joe6> oh, ok.
10:40:43 <Axman6> there's a reason GNC C had __attribute__((pure)) ;)
10:40:57 <Axman6> has*
10:40:59 <pikhq_> Axman6: __attribute__((const)) functions can't even read global state, much less modify it.
10:41:13 <pikhq_> (__attribute__((pure)) isn't quite the same: it can *read* global state.)
10:41:25 <Axman6> the original question was ambiguous
10:41:34 <dafis> cmccann: but that's not a remotely predictable machine, I'd rather stick to von Neumann architecture
10:41:35 <PhillipA> I disagree
10:41:40 <PhillipA> I think the original question was wrong
10:41:45 <Axman6> heh
10:42:16 <cmccann> dafis, I agree, but it does begin to show why lawyers are well-paid. you'd have to be, to put up with that kind of nonsense.
10:42:38 <cmccann> it's like doing enterprise INTERCAL development on windows ME
10:42:39 <ion> It’s a very predictable machine. The result value is a function of input money.
10:43:22 <dafis> cmccann: lawyers generally aren't well-paid here in Germany, excepting a few, they just get by so-so
10:43:32 <ddarius> cmccann: For contract law, reducing legalese to logic is probably a good idea.  For criminal law, everything is much more ambiguous by design and any analogy or desire of an analogy with logic/programming would be ill-advised.
10:43:43 <Axman6> AppleScript looks like english, but only slightly.
10:43:52 <dafis> cmccann: disturbing idea you had there
10:45:10 <cmccann> ddarius, yes, contract law and such is mostly what I had in mind. criminal law has a rather different character, agreed.
10:45:39 <chrisdone> :) http://research.microsoft.com/en-us/um/people/simonpj/papers/financial-contracts/contracts-icfp.htm
10:53:24 <adrake> which is the preferred way to allocate a temporary <n> byte buffer for the duration of an IO action?
10:53:37 <adrake> I know of bracketing the action with malloc/free, using alloca, or using finalizers
10:53:49 * hackagebot eq 0.3.4 - Leibnizian equality  http://hackage.haskell.org/package/eq-0.3.4 (EdwardKmett)
10:54:11 <Ke> adrake: what do you mean by byte
10:54:13 <PhillipA> alloca
10:54:16 <thoughtpolice> adrake: allocaBytes sz $ \ptr -> do ...
10:54:29 <Ke> heh
10:54:59 <kmc> adrake, alloca, if it's really temporary in that way
10:55:08 <adrake> kmc, thoughtpolice PhillipA, thanks!
10:55:20 <kmc> if the pointer might escape or get stashed away somewhere then you can't use alloca
10:55:31 <adrake> Ke, 8 bits
10:55:34 <adrake> Ke, :P
10:55:51 <adrake> kmc, yeah, it's really temporary that way
10:56:47 <sonoflilit> sorry for forgetting to check for answers :P
10:56:57 <sonoflilit> parcs: with the high level API
10:57:04 <sonoflilit> it is less than trivial
11:02:07 <kmc> anyone here made slides with Haskel code using the LaTeX "beamer" package?
11:08:03 <Cale> sonoflilit: Well, if all else fails on the uniform front, the relevant calls have bindings in OpenGLRaw
11:08:26 <Cale> sonoflilit: I don't know if there are higher level bindings or not
11:09:10 <Cale> glUniformMatrix4fv :: GLint -> GLsizei -> GLboolean -> Ptr GLfloat -> IO ()
11:09:12 <Cale> etc.
11:11:33 <Cale> http://hackage.haskell.org/packages/archive/OpenGLRaw/1.1.0.1/doc/html/Graphics-Rendering-OpenGL-Raw-Core31.html#v:glUniformMatrix2fv
11:13:41 <Cale> glGetUniformLocation :: GLuint -> Ptr GLchar -> IO GLint
11:14:23 <Cale> and then you'll need to allocate a C string to be able to call that
11:15:10 <Cale> (and room for your uniform matrices)
11:18:47 <mistertim> hello, just wondering, is it possible to constrain the parameters of a parameterised type by a class? Eg - "data Order (OrderType o) (SideOfBook s) = Order o s deriving (Eq, Show)" where OrderType and SideOfBook are typeclasses? This particular line gives me a "Type found where type variable expected" error - am I trying to do something impossible, or have I just got the syntax wrong?
11:19:49 <kmc> http://www.cs.utexas.edu/users/EWD/transcriptions/EWD13xx/EWD1304.html
11:20:03 <kmc> mistertim, you have the syntax wrong for one
11:20:07 <mistertim> aha, sorry - I think I've just found it: "data (OrderType o, SideOfBook s) => Order o s = Order o s?
11:20:15 <kmc> yeah, but it probably doesn't do what you want
11:20:37 <mistertim> kmc: aah ok
11:20:57 <kmc> why are these things type classes?
11:21:49 <kmc> what's wrong with «data OrderType = Market | Limit; data SideOfBook = Bid | Ask; data Order = Order OrderType SideOfBook»
11:22:23 <mistertim> kmc: aha - Buy and Sell side orders have different semantics for Ord, and therefore are different types
11:22:52 <kmc> you could roll that into the Ord instance for Order
11:22:54 <kmc> but, okay
11:23:02 <kmc> making them different types is a worthy goal
11:23:08 <kmc> so you don't mix up sides of the book by accident
11:23:39 <kmc> another option is a GADT:
11:24:18 <kmc> data Bid; data Ask; data Order side where { BuyOrder :: OrderType -> Price -> Order Bid; SellOrder :: OrderType -> Price -> Order Ask }
11:24:58 <kmc> i'm generally suspicious of designs that involve lots of type classes
11:25:03 <kmc> as they're not first-class and are generally a pain to work with
11:26:27 <tim_> kmc: aah, that's interesting - I'm not entirely sold on the idea yet either, not least because both those classes are ones that shouldn't really be extended beyond the instances I've defined
11:27:03 <kmc> right
11:27:09 * cmccann thinks type classes end up being used for too many things that they're not all that good at
11:27:14 <kmc> sounds like GADTs are a better fit, then
11:27:39 <mistertim> And, in fact, they're not really needed, apart from to ensure you can't create a type like "Order Int String" which would be meaningless
11:28:31 <kmc> (did you see my GADT example?)
11:29:16 <mistertim> @kmc aah yep
11:29:16 <lambdabot> Maybe you meant: ghc rc src
11:29:47 <mistertim> kmc: the problem is I'd like the 'side-of-market' and type of order to be encoded in the type itself
11:29:58 <kmc> you get that with GADTs
11:30:11 <kmc> you have types Order Bid and Order Ask
11:30:16 <kmc> and you can also write (Order t) when you don't care
11:30:20 <mistertim> kmc: aah, it's possible I'm looking at the wrong example in that case
11:30:27 <kmc> data Bid; data Ask; data Order side where { BuyOrder :: OrderType -> Price -> Order Bid; SellOrder :: OrderType -> Price -> Order Ask }
11:30:57 <mistertim> kmc: aah that's interesting, I'm not familiar with 'data foo where' syntax
11:31:03 <kmc> that's the GADT syntax
11:31:05 <kmc> it's a GHC extension
11:31:10 <kmc> the GHC manual has some good examples
11:31:12 <mistertim> kmc: aah, ok
11:31:13 <Cale> I will continue being a bit suspicious of designs with lots of typeclasses at least until we get context synonyms ;)
11:31:51 <mistertim> kmc: that looks much more like what I had in mind, thanks! will go and have a read...
11:31:57 <Cale> But in seriousness, yeah, often people go nuts with typeclasses and forget about good ol' fashioned functional programming.
11:32:14 <kmc> lambda the ultimate typeclass
11:32:31 <Cale> Exactly
11:32:39 <cmccann> type classes are just lambda abstractions taking types as arguments and returning dictionaries
11:35:06 <accel> i have just written the most beautiful 2 lines of code in my life
11:35:13 <accel> and am trying to figure out which library to contribteu it to
11:35:19 <accel> assert :: Bool -> MyErr -> IO()
11:35:19 <accel> assert b e = if b then return () else throw e
11:35:25 <accel> which library does it belong in?
11:35:59 <ClaudiusMaximus> @src when
11:35:59 <lambdabot> when p s = if p then s else return ()
11:36:00 <kmc> assert b e = when (not b) $ throw e
11:36:16 <ClaudiusMaximus> @src unless
11:36:17 <lambdabot> unless p s = if p then return () else s
11:36:21 <kmc> ooh
11:36:24 <accel> fuck
11:36:36 <_Ray_> lambdabot: are you a wizard
11:36:40 <hatds> no reason not to keep in your personal libraries
11:36:43 <kmc> @pl \b e -> unless b $ throw e
11:36:44 <lambdabot> (. throw) . unless
11:36:54 <cmccann> @vixen are you a wizard?
11:36:54 <lambdabot> yes, i am
11:36:57 <PhillipA> @src assert
11:36:57 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
11:36:58 <hatds> isn't there an assert function already that magically gives the source loc?
11:37:10 <accel> someday
11:37:17 <accel> I will write a line of haskell source code worth remembering
11:37:21 <accel> and it will be engraved in my grave
11:37:33 <ClaudiusMaximus> hatds: i seem to recall it gets ignored when optimization is enabled, though
11:39:02 <Liskni_si> and then there's http://hackage.haskell.org/packages/archive/loch-th/0.1/doc/html/Debug-Trace-LocationTH.html#v:assert, which prints the srcloc as well as the expression, and works with optimizations
11:39:04 <ptd> Control.Exception.assert is treated magically by ghc
11:39:26 <ptd> Ghc does rewrites it
11:39:27 <ptd> assert pred val ==> assertError "Main.hs|15" pred val
11:40:15 <ptd> See http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/assertions.html
12:07:14 <sonoflilit> I'm porting an OpenGL tutorial to Haskell
12:07:29 <sonoflilit> and I need to pass mixed data to the GPU
12:07:56 <sonoflilit> as in, a list of a struct that has a few GLfloat-s but also a few GLubyte-s
12:08:02 <sonoflilit> how can I do that?
12:09:13 <Cale> How would you do it in C?
12:09:14 <sonoflilit> would newtype Row = !GLfloat !GLfloat !GLubyte !GLubyte work?
12:09:19 <Cale> nope
12:09:29 <Cale> newtypes can only have one field and one constructor
12:09:30 <sonoflilit> in C it is much easier to control layout of stuff in memory :)
12:09:44 <PhillipA> sonoflilit: I disagree
12:09:45 <Cale> In Haskell you would define an instance of Storable
12:10:06 <sonoflilit> Cale: I'll look into it, thanks
12:10:10 <Cale> which says exactly how to place values in memory, what the alignment requirements of the structure are, etc.
12:10:13 <sonoflilit> anything I need to know?
12:10:51 <Cale> Well, you should read the FFI standard, because it's pretty tutorial-like and is useful if you're going to be doing low-level stuff
12:11:02 <Cale> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi.html
12:11:23 <Cale> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise5.html#x8-320005.7 -- here's the bit about Storable
12:11:28 <PhillipA> you need help from some external tool like hsc2hs
12:11:59 <Cale> Well, maybe you don't *need* it, if you know already how you want things to look in memory, it's not so bad writing a Storable instance yourself.
12:12:03 <Cale> But yeah, it can help a lot :)
12:12:17 <PhillipA> oh, true
12:12:32 <PhillipA> yeah, just poke things into place
12:13:30 <hpaste> “_Ray_” pasted “Indentation” at http://hpaste.org/49726
12:13:39 <_Ray_> ^-- why is that badly indented?
12:14:00 <PhillipA> lines 4 and 5 are not separate statements
12:14:11 <PhillipA> 'let s = 0' is not a valid expression
12:14:18 <Cale> if length xs == 1
12:14:25 <Cale>   then ...
12:14:28 <Cale>   else ...
12:14:33 <PhillipA> 's <- binToInt . evaluate $ tail xs' is not a valid expression
12:14:35 <Cale> but 'let s = 0' is nonsense
12:14:45 <_Ray_> Should I wrap the second one in a do block?
12:14:54 <PhillipA> what
12:15:05 <_Ray_> That s <- thing
12:15:10 <PhillipA> you did
12:15:22 <Cale> _Ray_: It looks like you want s to be in scope after the if?
12:15:41 <Cale> _Ray_: Neither binding for s will exist outside the if the way you've written it there.
12:15:49 <_Ray_> Hrm, OK; this seems to compile xD         s <- if length xs == 1 then evaluate 0 else binToInt . evaluate $ tail xs
12:16:01 <Cale> _Ray_: return 0
12:16:07 <Cale> not evaluate
12:16:21 <Cale> (though evaluate works, it's just... odd, since 0 is already evaluated)
12:16:27 <_Ray_> :o How did you know what evaluate did?
12:16:36 <hpaste> dmwit pasted “timeout or something?” at http://hpaste.org/49727
12:16:40 <Cale> Control.Exception.evaluate
12:16:51 <Cale> :t Control.Exception.evaluate
12:16:52 <lambdabot> forall a. a -> IO a
12:16:53 <hpaste> mauke annotated “Indentation” with “Indentation (annotation)” at http://hpaste.org/49726#a49728
12:17:01 <PhillipA> _Ray_: ^
12:17:04 <dmwit> In Linux, the pasted code works perfectly; in Windows, it ends in tears.
12:17:08 <Cale> (I was assuming it's that one)
12:17:17 <_Ray_> evaluate :: Label l => a -> LIO l s a actually, from http://hackage.haskell.org/packages/archive/lio-eci11/0.1/doc/html/LIO-TCB.html
12:17:29 <Cale> oh
12:17:38 <dmwit> Network.Browser.request: Error raised ErrorClosed
12:17:42 <dmwit> Any idea why?
12:17:47 <mistertim> kmc: thanks very much, it turns out GADTs were exactly what I had in mind! Finished product here https://gist.github.com/1117119
12:18:03 <Cale> okay, then maybe you do want evaluate, I have no idea what that library is :)
12:18:21 <ddarius> @hoogle withSocketsDo
12:18:22 <lambdabot> Network withSocketsDo :: IO a -> IO a
12:18:22 <lambdabot> Network.Socket withSocketsDo :: IO a -> IO a
12:18:22 <lambdabot> Network.Socket.Internal withSocketsDo :: IO a -> IO a
12:20:46 <Cale> Apparently it's kinda the same thing as what Control.Exception.evaluate does
12:20:58 <Cale> In which case, yeah, just use return
12:22:50 <Cale> _Ray_: be careful with head and tail. It's much safer to use case to pattern match and handle all the possibilities
12:23:07 <Cale> _Ray_: Currently, if xs is empty, even the annotated paste will die.
12:23:08 <_Ray_> Cale, I thought of that, but I don't (think I?) have the constructors for the monad
12:23:15 <Cale> You don't need them
12:23:20 <Cale> xs <- bs
12:23:22 <Cale> case xs of
12:23:23 <_Ray_> oh, case of?
12:23:24 <Cale>   [] -> ...
12:23:25 <_Ray_> yeah
12:23:28 <ddarius> Cale: Not just safer.  More performant and clearer.
12:23:30 <_Ray_> cool, thanks :)
12:23:50 <_Ray_> I forgot pattern matching wasn't just for guards
12:24:12 <_Ray_> well, not guards. hopefully what I meant is understood :p
12:24:19 <Cale> Y U PERFORMANT
12:24:28 <PhillipA> _Ray_: you didn't look at my paste :-(
12:24:32 <_Ray_> oh, no!
12:24:55 <_Ray_> I thought you meant the lambdabot sentence xP
12:25:29 <Cale> s/more performant/better performing/?
12:25:41 <_Ray_> Philippa, by [_] you mean [] right?
12:25:55 <Cale> [_] matches an arbitrary one-element list
12:26:07 <Cale> (and discards the thing it matched)
12:26:15 <_Ray_> Oh right, xs hasn't been modified yet
12:26:20 <_Ray_> (meaning, it's xs, not tail xs)
12:26:40 <Cale> It's best never to shadow things
12:26:45 <Cale> If you can avoid it
12:26:56 <_Ray_> What do you mean by "shadowing"? The _?
12:26:58 <PhillipA> _Ray_: I'm not Philippa
12:27:02 <_Ray_> dskgdsfkjhdfgh
12:27:11 <ddarius> Cale: When would you not be able to avoid it?
12:27:22 <_Ray_> Sorry PhillipA
12:27:36 <Cale> ddarius: Well, you might not be aware of every binding that's in scope
12:27:46 <Cale> (if you're importing various things)
12:28:02 <Cale> But yeah, it's usually pretty easy :)
12:28:04 <ddarius> That's a long way from unavoidable.
12:28:56 <PhillipA> I use guids for all my variables
12:29:23 <Cale> I've seen a lot of the word "performant" around here lately. It's kind of a strange word. :)
12:29:57 <Cale> apparently it's new
12:30:26 <dafis> Cale: not very
12:30:50 <dafis> but it used to be used less often
12:32:11 <hpaste> Cale annotated “Indentation” with “Indentation (annotation) (annotation)” at http://hpaste.org/49726#a49730
12:32:43 <_Ray_> Is there a common monad way of going from [M a] to M [a]?
12:32:50 <Cale> oh, might still need the unlabel
12:32:56 <ion> :t sequence
12:32:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:32:57 <Cale> I don't know what that stuff is about
12:33:05 <Cale> yeah, sequence
12:33:41 <_Ray_> goddamnit, is there anything lambdabot can't do
12:33:53 <Cale> @hoogle [m a] -> m [a]
12:33:53 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
12:33:53 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
12:33:53 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
12:33:57 <PhillipA> @vixen is there anything you can't do?
12:33:57 <lambdabot> i can to!
12:33:58 <ion> @vixen Is there anything you can’t do?
12:33:58 <cmccann> @vixen is there anything you can't do?
12:33:58 <lambdabot> i think i can...
12:33:58 <lambdabot> i'll hafta plead the fifth on that one.
12:34:01 <cmccann> heh
12:34:04 <Cale> rofl
12:34:09 <cmccann> 3x hit combo!
12:34:47 <ion> Great butts poop alike.
12:45:04 <hpaste> ezyang pasted “Proposed strict functions for IntMap” at http://hpaste.org/49733
12:46:26 <Cale> Isn't IntMap already strict?
12:46:34 <ezyang> It's spine-strict, but not value strict.
12:46:44 <Cale> right
12:47:44 <Cale> So this is mostly just seq'ing the values before you insert them
12:48:17 <Cale> I don't think you should have to seq the key, should you?
12:48:18 <ezyang> Yep.
12:48:19 <hatds> but it should have a strict map somewhere in there?
12:48:26 <ezyang> I don't think so, though it existed in the old code.
12:48:33 <ezyang> yes, keep scrolling.
12:48:39 <ezyang> (map = function map)
12:50:19 <accel> map (\(x,y) -> ...) lst
12:50:27 <accel> can I do pattern matching in the in-lined function there?
12:50:37 <accel> like \(Cat x, _) -> ...
12:50:43 <accel> \(Dog blah, _) -> ...
12:50:44 <PhillipA> you already do
12:50:49 <PhillipA> (x,y) is a pattern
12:50:58 <accel> how do I specify a 2nd pattern
12:51:05 <PhillipA> you don't
12:51:12 <accel> so there is only one pattern alowed?
12:51:22 <PhillipA> well, one equation
12:51:22 <ezyang> Yeah, only one, sorry.
12:51:30 <Cale> accel: case
12:51:33 <PhillipA> you'll have to case manually
12:51:36 <hpc> you want map (\(x,y) -> case x of ...) ...
12:51:43 <Cale> It's unfortunate that we don't have case sections
12:52:04 <Cale> You should be able to write  (case of ...) to mean (\x -> case x of ...)
12:53:10 <hpc> that would be cool
12:53:19 <hpc> make that extension
13:09:32 <accel> i have a question for the great wizards of haskell
13:09:37 <accel> why was it, in the development of haskell
13:09:40 <accel> afer the choice of ==
13:09:41 <accel> peopel were like
13:09:45 <accel> how do we pick not equals sign
13:09:47 <accel> and someone decided
13:09:48 <accel> hmm
13:09:52 <accel> != is whate everyone else uses
13:09:56 <accel> so le's pick /= instead
13:09:58 <kmc> avoid success at all costs
13:10:03 <accel> it's similar enough to not be notifacable
13:10:12 <accel> but different enough to fuck over everyone who tries !=
13:10:15 <Cale> The symbol for not equals is ≠
13:10:15 <companion_cube> they could have choosen <>
13:10:18 <kmc> @wn notifacable
13:10:19 <lambdabot> No match for "notifacable".
13:10:23 <kmc> companion_cube, yeah, like Visual Basic!
13:10:26 <companion_cube> or ocaml
13:10:27 <Clint> notiface
13:10:29 <Cale> which looks like / and = put on top of each other
13:10:29 <mike-burns> Or SQL.
13:10:44 <accel> by taht logic
13:10:47 <mike-burns> ! is "not" in languages like C, but not in Haskell.
13:10:54 <accel> instead of +, let's use -|
13:11:01 <mike-burns> The ! is syntax already.
13:11:03 <companion_cube> accel: i suppose that '!' is too much related to strictness in haskell community
13:11:08 <zmv> yah
13:11:11 <zmv> -| is cool :D
13:11:14 <kmc> wp says Visual Basic 9.0 is influenced by Haskell
13:11:15 <accel> companion_cube: that logic (strictness) makes sense
13:11:21 <kmc> > let (-|) = (+) in 2 -| 3
13:11:22 <lambdabot>   5
13:11:25 <zmv> or better |-
13:11:34 <kmc> or better ⊢
13:11:40 <parcs> -|-
13:11:40 <kmc> > let (⊢) = (+) in 2 ⊢ 3
13:11:41 <lambdabot>   5
13:11:45 <accel> and instead of *, we can use \/|
13:11:48 <zmv> because you often do the vertical stroke first
13:11:59 <|-> >>>:D
13:12:28 <companion_cube> or better, negation is  → ⊥
13:12:53 <kmc> i was going to ask a conceptual question, but arguing about the spelling of infix operators is so much more interesting
13:12:53 <zmv> instead of g, let's use oj
13:12:57 <parcs> what i don't understand is why !! is lookup on lists and ! is lookup on every other container
13:13:16 <kmc> parcs, because Array is in Haskell 98 and they didn't want to tell you to import Array qualified?
13:13:18 <zmv> because lists are more ! than other containers
13:13:18 <accel> parcs: over the years, I have learned
13:13:32 <zmv> lists!!
13:13:38 <accel> haskell was designed in a way to ensure anyone with a a two digit IQ and who can't keep 1- things in memory at a time can't use haskell
13:13:43 <zmv> other containers!
13:13:45 <zmv> see?
13:14:15 <kmc> two digit IQ is below average intelligence
13:14:17 <kmc> (by definition)
13:14:35 <kmc> though iirc they stopped normalizing a while ago
13:14:36 <accel> that is not a problem for php
13:14:41 <kmc> and so the average is actually above 100
13:14:43 * roconnor remembers when the scientologists tried to tell him that an average IQ was 110.
13:14:55 <roconnor> kmc: oh really?
13:14:59 <kmc> iirc
13:15:00 <roconnor> now I feel kinda dumb
13:15:01 <companion_cube> php has been designed to be unusable for people with more than 2 digits IQ :D
13:15:04 <Philippa> roconnor: maybe it is on whatever FUBAR scale they use?
13:15:27 <geheimdienst> companion_cube: i hear the cutoff for objective-c is around 90
13:15:30 <roconnor> I think I got 140 or 145, but they said I could still use help.
13:16:01 <Philippa> well yeah, they're scientologists. They want to 'help' everyone
13:16:08 <companion_cube> i don't want to know my IQ :/
13:16:11 <kmc> so i want to make the claim that declarative programming (in Haskell, for example) is more composable than alternatives like imperative programming
13:16:15 <kmc> what's a good example?
13:16:38 <kmc> i want to show a function built from small parts, each of which looks like a specification
13:16:41 <parcs> what is the iq required to join mensa?
13:16:49 <kmc> and in a way that's not obviously translatable to imperative code
13:17:08 <kmc> i was thinking mergesort
13:17:12 <companion_cube> kmc: maybe a bad idea, but STM monad ?
13:17:17 <kmc> companion_cube, i'll get to that much later
13:17:22 <kmc> this is for slide 2 of a talk
13:17:25 <kmc> STM will be like slide 50
13:17:26 <companion_cube> or sql combinators
13:17:31 <Saizan> whyfp has some on that on solving chess
13:17:36 <kmc> i want something simple and self-contained
13:17:41 <kmc> that fits on one slide
13:17:48 <cmccann> kmc, parser combinators are a pretty persuasive example there
13:17:48 <pr> @where whyfp
13:17:48 <lambdabot> http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html
13:17:54 <cmccann> but probably not something you can fit in
13:17:56 <kmc> cmccann, yeah, that's like slide 20 ;)
13:18:33 <geheimdienst> kmc, dunno about composability, but whenever i have to write imperatively, i keep repeating myself. i'd like to pull the common bits out into a function and just call the function multiple times with the varying parts as parameters, but too often, that's impossible or tedious in an imperative language
13:18:37 <calsaverini> hi
13:18:41 <calsaverini> hackage is down?
13:18:48 <kmc> geheimdienst, that's not about "imperative" though
13:18:58 <kmc> it's just coincidence that a few common imperative languages (Java, C++) have poor abstraction power
13:19:17 <kmc> the same doesn't happen when you write imperative code in Haskell or even Python
13:19:49 <kmc> that's why I like Haskell for imperative programming
13:19:57 <geheimdienst> fair point
13:20:10 <roconnor> is @ free to use?
13:20:12 <kmc> but right now i'm arguing declarative > imperative (even if both are in Haskell)
13:20:15 <roconnor> as an operator?
13:20:19 <kmc> roconnor, $5
13:20:29 <kmc> or 3 for $12
13:20:34 <geheimdienst> > let (@) = (+) in 3 @ 5
13:20:35 <lambdabot>   <no location info>: parse error on input `@'
13:20:42 <roconnor> oh right
13:20:48 <roconnor> it is used in patterns
13:21:05 <pr> > let f a@(x:xs) = a in f [1,2,3]
13:21:06 <lambdabot>   [1,2,3]
13:21:07 <kmc> iirc the Prelude-free one-letter ASCII operators are & # ! %
13:21:10 <ddarius> kmc: Perhaps the split package?
13:21:17 * kmc remembers this from writing obfuscated Haskell
13:21:33 <pr> is there a obfuscated haskell contest?
13:21:42 <kmc> maybe i should run one.
13:21:43 <ddarius> kmc: Wouldn't it be more obfuscated to reuse the Prelude symbols?
13:21:45 <kmc> there was long ago
13:21:45 <Cale> pr: There have been some in the past
13:21:57 <kmc> ddarius, but then you have to hide or qualify them
13:22:08 <sonoflilit> I'm writing a Storable instance for my VertexWithAttributes... and I wonder what would be a good alignment value
13:22:10 <kmc> i guess obfuscated code should begin with "import qualified Prelude as Q"
13:22:23 <kmc> Real Programmers page-align everything
13:22:26 <ddarius> import qualified Prelude as BS
13:22:27 <sonoflilit> do I understand correctly that it is only meaningful for performance reasons?
13:22:40 <kmc> sonoflilit, some architectures forbid misaligned accesses
13:22:41 <sonoflilit> page is 16bytes, right?
13:22:51 <kmc> a page is 4096 bytes on most systems
13:22:56 <kmc> it was a joke
13:23:02 <kmc> you can tell also because i said "Real Programmers"
13:23:03 <ddarius> A paragraph is 16 bytes.
13:23:09 <sonoflilit> ah, right
13:23:11 <ddarius> But people don't usually talk about paragraphs anymore.
13:23:19 <kmc> ddarius, where's that from?
13:23:34 <ddarius> kmc: x86-16 segmentation
13:23:38 <kmc> oh, right
13:23:58 <sonoflilit> why, I hear that C compilers like to paragraph-align, ain't it so?
13:24:07 <monochrom> oh! I seem to remember "paragraph"
13:24:16 <kmc> sonoflilit, C compliers on x86 still like to 16-byte-align stuff
13:24:25 * hackagebot haxr 3000.8.4 - XML-RPC client and server library.  http://hackage.haskell.org/package/haxr-3000.8.4 (GracjanPolak)
13:24:26 <sonoflilit> and what is the min alignment that wouldn't get me in trouble?
13:24:27 <kmc> for the benefit of using SSE instructions
13:24:30 <andares> argh so many module functions to learn..
13:24:53 <kmc> sonoflilit, that depends on the C code accessing the struct
13:25:12 <kmc> the best would be to define the struct in C, then use some alignof macro from Haskell (probably via hsc2hs, etc.)
13:25:15 <kmc> or, just use 16
13:25:22 <sonoflilit> I can tell the C code the offset of each field and the length of each row
13:26:32 <kmc> some compilers use 16-byte alignment in order to get 4 tag bits
13:27:25 <kmc> or there's edwardk's trick: 32-bit pointers shifted over 4 bits
13:27:35 <kmc> lets you access 64 GB of heap and still keep the pointers small
13:27:39 <kmc> (double your cache size today!)
13:34:10 <kmc> besides i like the idea of using "mergesort" as a slide-2 example just because everyone else uses "quicksort" ;)
13:34:34 <shachaf> You should use "bubblesort".
13:34:42 <kmc> bogosort!
13:34:48 <shachaf> (Ooh, bubble sort on linked lists. Just when you thought it couldn't get any worse.)
13:35:05 <siracusa> sleepsort!!
13:35:25 <kmc> a sorting algorithm invented by 4chan
13:36:06 <hpaste> “_Ray_” pasted “Indentation” at http://hpaste.org/49734
13:36:08 <kmc> maybe i should upload Acme.Sleepsort to Hackage
13:36:15 <Cale> Sleepsort is elegant in Haskell
13:36:30 <_Ray_> Hi. What is badly indented about this? http://hpaste.org/49734
13:36:48 <cmccann> kmc, use nondeterministic bogosort
13:36:59 <cmccann> kmc, generate every permutation using the list monad, then find the one that's sorted
13:37:25 <kmc> i'll use the list monad!
13:37:28 <parcs> _Ray_: putStrLn isn't aligned with (result,
13:37:50 <_Ray_> khgsjkgfgh. one space. :(
13:37:52 <kmc> Cale, like this? do c <- newChan; mapM_ (forkIO . liftM2 (>>) threadDelay (writeChan c)) xs; take (length xs) <$> getChanContents c
13:38:07 <Cale> kmc: Yeah, something like that :)
13:38:22 <kmc> wrap it in unsafePerformIO ;)
13:39:35 <kmc> it's *probably* fine
13:39:39 <parcs> that's elegant?
13:39:45 <erasmas> I don't see why quantum sort isn't more widely used
13:39:50 <kmc> parcs, compared to most languages
13:44:43 <PhillipA> kmc: you don't even need a chan
13:44:52 <PhillipA> use an implicit queue a.k.a. MVar
13:45:27 <kmc> ah yeah
13:45:32 <kmc> a synchronous 1-element queue
13:45:45 <kmc> chan seems prettier and the code is shorter, though
13:45:47 <kmc> maybe
13:46:42 <PhillipA> newEmptyMVar ... putMVar ... mapM (const (takeMVar c)) xs
13:47:28 * hackagebot MetaHDBC 0.1.2 - Statically checked database access  http://hackage.haskell.org/package/MetaHDBC-0.1.2 (MadsLindstroem)
13:48:22 <andares> is there a trick to remembering all these library functions? learn you a haskell just throws about 100 at you in a row.
13:48:47 <PhillipA> they are all Intuitively Obvious™
13:48:57 <kmc> PhillipA, hmm, maybe MVar is better
13:49:26 <kmc> andares, I don't know a trick
13:49:35 <kmc> just have all the docs at your fingertips
13:49:35 <PhillipA> it's probably just a lot of practice
13:49:39 <kmc> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/index.html
13:49:46 <kmc> GHCi's ":i" will tell you what module something is in
13:49:50 <PhillipA> hoogle is your friend
13:50:03 <andares> cool.
13:50:04 <kmc> hoogle and #haskell are good ways to ask "is there a library function for this task"
13:50:08 <kmc> in fact you can ask both at once
13:50:53 <PhillipA> there are various categories of functions, like numeric stuff or list processing
13:51:53 <ddarius> PhillipA: s/Intuitively Obvious/Self-evident/
13:52:15 <PhillipA> some of them you use all the time (map, filter, +, ^), others you have to look up (showOct, mapAccumL)
13:53:01 <kmc> i think sleepsort is my new counterexample to the claim that sorting can't be done "faster than O(n log n)"
13:53:31 <parcs> is sleep sort theoretically O(n)?
13:54:04 <PhillipA> kmc: that "claim" is a theorem about comparison-based sorts
13:54:05 <kmc> it's O(largest element)
13:54:20 <kmc> PhillipA, yes.  the popular but incorrect claim applies it to all sorts
13:54:29 <kmc> more reasonable counterexamples include radix sort and the like
13:54:41 <kmc> parcs, ignoring the cost of concurrency and the overall ridiculousness of the situation
13:54:41 <PhillipA> is that the one where I build a trie?
13:54:54 <kmc> PhillipA, that sounds like a generalization, yeah
13:55:59 <andares> hey, is there a typeclass for functions?
13:56:09 <kmc> not in general, no
13:56:11 <PhillipA> not really "for" functions, no
13:56:12 <kmc> why do you want one?
13:56:22 <andares> I'm trying to make a combine <num times> <function> function that combines a function with itself numtimes times.
13:56:34 <andares> so like combine 2 f == f . f
13:56:36 <kmc> why would you need type classes for that?
13:56:36 <PhillipA> why do you need a typeclass for that?
13:56:44 <kmc> :t iterate
13:56:45 <lambdabot> forall a. (a -> a) -> a -> [a]
13:57:07 <andares> I don't think iterate does that, does it?
13:57:29 <kmc> :t \n f -> (!! n) . iterate f
13:57:29 <lambdabot> forall a. Int -> (a -> a) -> a -> a
13:57:44 <kmc> anyway, why type classes?
13:58:06 <PhillipA> :t let combine n f = (!! n) . iterate f  in  combine 2 f x
13:58:06 <lambdabot> Expr
13:58:09 <PhillipA> > let combine n f = (!! n) . iterate f  in  combine 2 f x
13:58:09 <andares> I get a compile error and thought it was because ghc didn't know if I could use the . operator without a type class specification.
13:58:10 <lambdabot>   f (f x)
13:58:24 <PhillipA> andares: . isn't a class method
13:58:30 <PhillipA> at least the one in the Prelude isn't
13:58:34 <cmccann> @src Category
13:58:35 <lambdabot> Source not found.
13:58:38 <andares> I've defined it as combine n f = f . (combine (n-1) f).. not working for some reason.
13:58:38 <cmccann> pf
13:59:00 <PhillipA> :t let combine n f = f . (combine (n-1) f) in combine
13:59:00 <lambdabot> forall a b (f :: * -> *). (Functor f, Num a) => a -> (b -> b) -> f b
13:59:09 <PhillipA> :t let combine n f = f Prelude.. (combine (n-1) f) in combine
13:59:10 <lambdabot> forall a c a1. (Num a) => a -> (c -> c) -> a1 -> c
13:59:15 <PhillipA> andares: works
13:59:29 <andares> ...huh.
13:59:40 <Saizan> that type is suspicious
13:59:46 <kmc> andares, maybe you need a base case?
13:59:55 <PhillipA> :t let combine 0 f = id; combine n f = f . (combine (n-1) f) in combine
13:59:55 <lambdabot> forall t b. (Num t) => t -> (b -> b) -> b -> b
14:00:44 <andares> I don't understand the type signature.
14:00:48 <andares> I think that's my issue.
14:00:55 <kmc> :t \n f -> foldr (.) id $ replicate n f
14:00:56 <lambdabot> forall b. Int -> (b -> b) -> b -> b
14:01:03 <kmc> why not andares?
14:01:36 <andares> why is the last type in the chain f b?
14:01:42 <ddarius> Saizan: There is no base case.
14:01:55 <PhillipA> andares: wait, which one?
14:02:11 <kmc> andares, the first one used Caleskell's weird (.) instead of the standard (.)
14:02:25 <andares> well, I was expecting (Num a) => a -> b -> b to work.
14:02:39 <PhillipA> that makes no sense
14:02:40 <andares> where b is the type of the functor.
14:02:44 <kmc> functor?
14:02:47 <PhillipA> what
14:02:48 <andares> er whatever function.
14:03:04 <PhillipA> ok, then that's right
14:03:11 <kmc> sure, that expands to (Num a) => a -> (c -> c) -> (c -> c)
14:03:15 <kmc> :t \n f -> (!! n) . iterate f
14:03:16 <lambdabot> forall a. Int -> (a -> a) -> a -> a
14:03:25 <kmc> :t \n f -> (!! fromIntegral n) . iterate f
14:03:26 <lambdabot> forall a a1. (Integral a1) => a1 -> (a -> a) -> a -> a
14:03:28 <andares> kmc: what's with the c -> c?
14:03:35 <PhillipA> andares: that's the type of the function
14:03:43 <PhillipA> b = c -> c in your version
14:03:44 <kmc> andares, a function that can be composed with itself has type (c -> c) for some c
14:03:47 <kmc> :t ?f . ?f
14:03:48 <lambdabot> forall a. (?f::a -> a) => a -> a
14:03:53 <andares> kmc: oh, that makes sense.
14:04:43 <kmc> :t \f -> f . f
14:04:43 <lambdabot> forall b. (b -> b) -> b -> b
14:04:49 <kmc> i.e. (b -> b) -> (b -> b)
14:06:50 <ddarius> :t return . return
14:06:51 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (Monad m, Monad m1) => a -> m (m1 a)
14:06:53 <kish`_> nothing makes sense here
14:07:01 <andares> kmc: oh, I think I see how your foldr implementation works. it just folds them using the . operator right?
14:07:02 <kish`_> i'm sticking to literature
14:07:12 <kmc> :t foldr (.) id
14:07:13 <lambdabot> forall b. [b -> b] -> b -> b
14:07:21 <andares> neato.
14:07:35 <kmc> there's no standard function for that afaik
14:07:36 <andares> :t id
14:07:37 <lambdabot> forall a. a -> a
14:07:37 <kmc> not directly
14:07:44 <kmc> :t appEndo . mconcat . map Endo
14:07:45 <lambdabot> forall a. [a -> a] -> a -> a
14:07:49 <ddarius> kmc: I see how your foldr implementation works.  It uses foldr.
14:07:58 <andares> I am new to this okay. =/
14:08:08 <kmc> i filled the bowling balls using a funnel
14:09:21 <PhillipA> andares: do you understand the iterate version?
14:12:20 <ddarius> The iterate version is horrible.
14:12:36 <kmc> :(
14:12:46 <pr> :t Endo
14:12:47 <lambdabot> forall a. (a -> a) -> Endo a
14:13:01 <kmc> @src Endo
14:13:01 <lambdabot> Source not found. :(
14:13:04 <pr> :(
14:13:12 <kmc> newtype Endo a = Endo { appEndo :: a -> a }
14:13:30 <c_wraith> appendo!
14:13:36 <PhillipA> ddarius: no, it's totally sweet
14:13:36 <pr> appendo, sounds spanish
14:13:38 <pr> haha
14:13:43 <kmc> yo appendo el listo
14:13:47 <ion> appEndix
14:14:03 <kmc> instance Monoid (Endo a) where { mempty = Endo id; Endo x `mappend` Endo y = Endo (x . y) }
14:15:07 <kmc> «(n !!) . iterate f» shouldn't actually build an n-element list, right?
14:16:17 * BMeph whispers to kmc: Psst! "(!! n) . ..."
14:16:30 <kmc> err, yep
14:17:30 <shachaf> @ty ala Endo foldMap
14:17:31 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => t (a -> a) -> a -> a
14:19:52 <kmc> :t ala
14:19:53 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
14:19:56 <kmc> o_O
14:20:23 <_Ray_> Hi. Is there a way to know where an exception was thrown? Sort of a like a backtrace?
14:20:59 <kmc> @where RTS-xc
14:20:59 <lambdabot> ghc --make -fforce-recomp -prof -auto-all -rtsopts foo.hs && ./foo +RTS -xc
14:21:07 * kmc waves a dead chicken
14:21:21 <joseanpg> hello
14:21:37 <mike-burns> _Ray_: No, last I checked. That's simply not recorded.
14:21:54 <mike-burns> I last looked maybe a year ago so ideally it's changed since then.
14:22:20 <kmc> hi joseanpg
14:22:41 <kmc> _Ray_, let me know if the RTS -xc thing works
14:23:20 <_Ray_> <Ex52U.add_prefix,Ex52T.execute,Ex52T.CAF><Ex52T.execute,Ex52T.CAF>Main: LerrLow
14:23:46 <_Ray_> Seems like the correct expression :) I assume there's nothing more detailed like a debugger, right? To be able to see what variables caused it?
14:23:55 <kmc> GHCi has a debugger built in
14:23:59 <kmc> it's not that popular afaik
14:24:35 <kmc> the main way of debugging Haskell functions is to test them in ghci
14:24:41 <kmc> if 'f' is wrong and f = g . h, then you try g and h
14:24:52 <kmc> also i use Debug.Trace a lot
14:24:53 <cmccann> no, the main way of debugging Haskell functions is to write them without bugs
14:24:57 <cmccann> the second way is in GHCi
14:25:12 * mike-burns looks words up in dictionaries
14:25:14 <cmccann> the third way is probably quickcheck and/or Debug.Trace.unsafePerformPrintfDebugging
14:25:51 <Cale> lol unsafePerformPrintfDebugging
14:25:53 <mike-burns> Does -RTS-xc have a noticeable performance hit?
14:25:53 <adrake> (aliased to Debug.Trace.trace for convenience :)
14:26:05 <kmc> mike-burns, profiling does in general
14:26:09 <cmccann> Cale, that's what it IS!
14:26:17 <Cale> mike-burns: Compiling with profiling options on is a performance hit
14:26:33 <Cale> It doesn't generally matter which profiling RTS options you choose after that
14:26:55 <mike-burns> Excellent to know.
14:27:27 <karlicoss> oh, have i missed any reply to my question, i have been disconnected?
14:27:34 <Cale> (though there's probably some extra overhead associated with each)
14:27:51 <Cale> -xc should be the cheapest though
14:28:02 <kmc> karlicoss, i don't think we got your question
14:28:07 <mike-burns> Oh -xc is stderr only? I had hoped, a while back at least, for a way to extract the backtrace as a datastructure at runtime. Print it, inspect it, report it to Hoptoad, etc.
14:28:14 <Cale> no
14:28:25 <kmc> mike-burns, you might be able to do that with 'vacuum'
14:28:27 <kmc> but i'm not sure
14:28:42 <Cale> I'd actually be kinda surprised, even with vacuum
14:29:26 <kmc> yeah
14:29:35 <mike-burns> I assume -xc causes it to print but then discards it.
14:29:36 <karlicoss> kmc: i need a library to draw simple geometric objects - lines, dots for example. do you know any?
14:29:46 <mike-burns> Oh well.
14:30:00 <Cale> karlicoss: Maybe something like gloss?
14:30:03 <Cale> http://hackage.haskell.org/package/gloss
14:30:11 <kmc> the cleanest way to get the -xc backtrace programmatically probably involves modifying GHC
14:31:10 <karlicoss> Cale: thanks
14:31:41 <kmc> the reason this is tied into profiling is that the "native" stack in GHC is not a stack of function calls; it's a stack of nested forcings
14:31:54 <Cale> mike-burns: It's not actually a well-defined "thing" as such. It's the cost-centre stack, which is a sort of organisational thing for profiling (and does indicate a part of the code that some evaluation happens in), but isn't really relevant at all to how GHC is actually evaluating the code.
14:31:54 <kmc> and that is probably less useful in tracking down exceptions
14:32:20 <mike-burns> Yeah, I see what you're saying.
14:32:34 <Cale> It's a stack which wouldn't exist in any sense if it weren't for profiling being turned on.
14:33:16 <Cale> and which doesn't correspond in any way to any datastructure which is actually used to execute Haskell code
14:33:54 * kmc wonders if the forcing-stack would be useful for profiling, too
14:34:02 <mike-burns> Tradeoffs are such a bummer.
14:34:16 <kmc> i bet there's a good pun to be had here about demand-side economics
14:35:38 <Cale> It might be nice to have the pattern matching stack occasionally (a stack of case expressions?)
14:37:02 <Cale> (which is at least a stack that actually exists)
14:39:35 <accel> is there a haskell builtin to strip all leading spaces from a string?
14:39:46 <accel> for example "   accel is awesome" -> "accel is awesome"
14:40:02 <PhillipA> dropWhile isSpace
14:40:27 <erasmas> with an import of Data.Char
14:41:55 <PhillipA> @index dropWhile
14:41:55 <lambdabot> Data.List, Prelude
14:41:58 <PhillipA> @index isSpace
14:41:58 <lambdabot> Data.Char
14:42:33 <accel> PhillipA: nice; thanks!
14:44:46 <accel> > drop 2 [1, 2, ..]
14:44:46 <lambdabot>   <no location info>: parse error on input `..'
14:44:50 <accel> > drop 2 [1..]
14:44:51 <lambdabot>   [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,...
14:45:17 <joseanpg> @index lookup
14:45:17 <lambdabot> Data.HashTable, Data.IntMap, Data.Map, Data.List, Prelude
14:45:25 <joseanpg> index seq
14:45:34 <joseanpg> @index seq
14:45:34 <lambdabot> Prelude, Control.Parallel
14:46:03 <joseanpg> what is lambdabot?
14:46:11 <kmc> a helpful robot
14:46:24 <kmc> Lambda Robots: 100% Loyal
14:46:24 <_Ray_> the hero #haskell deserves
14:46:26 <joseanpg> always active here?
14:46:32 <luite> usually :)
14:46:35 <kmc> except when broken
14:47:00 <joseanpg> who is its creator?
14:47:05 <geheimdienst> we don't say she *breaks*, we say she has that time of the month
14:47:07 <Cale> Lambda Robots: 98.7% Loyal
14:47:15 <joseanpg> I like this channel
14:47:15 <kmc> @djinn ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)
14:47:16 <lambdabot> f a b c = a (\ d -> b d c)
14:47:27 <kmc> one nine?
14:47:29 <joseanpg> @index liftM
14:47:29 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
14:47:51 <joseanpg> commands of lambdabot?
14:48:26 <joseanpg> @help
14:48:26 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:48:35 <PhillipA> list is lying
14:48:38 <joseanpg> @list
14:48:38 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
14:49:07 <tommd> preflex: seen tibble
14:49:07 <preflex>  Sorry, I haven't seen tibble
14:49:32 <knoc> preflex: seen preflex
14:49:32 <preflex>  what
14:49:43 <tommd> preflex: seen tibbe
14:49:44 <preflex>  tibbe was last seen on #ghc 4 days, 10 hours, 1 minute and 23 seconds ago, saying: TacticalGrace, I think JaffaCake is on vacation still.
14:50:14 <joseanpg> @eval 4 +5
14:50:15 <tommd> @tell tibbe There's a pull request for you on github - fixed my bone-headed bugs once and for all (no proofs, but 500K QC tests say yes)
14:50:15 <lambdabot> Consider it noted.
14:50:19 <brett> hrm is ghc broken on 10.7?
14:50:34 <PhillipA> joseanpg: @eval does nothing
14:50:44 <PhillipA> it's a trick command
14:51:11 <joseanpg> ok
14:51:38 <ddarius> @help eval
14:51:38 <lambdabot> eval. Do nothing (perversely)
14:51:41 <joseanpg> @src foldM
14:51:41 <lambdabot> foldM _ a []     = return a
14:51:41 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
14:52:00 <PhillipA> @help run
14:52:00 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
14:52:02 <joseanpg> @src zipWith
14:52:03 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
14:52:03 <lambdabot> zipWith _ _      _      = []
14:52:21 <joseanpg> @run 4+5
14:52:22 <lambdabot>   9
14:52:29 <sonoflilit> how do I make a strict data type with named fields?
14:52:47 <sonoflilit> data A = A {!a, !b :: Int} doesn't work
14:52:55 <joseanpg> @run let {loop=loop} in seq loop
14:52:55 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
14:52:55 <lambdabot>    arising from a use of `...
14:53:08 <joseanpg> @run let {loop=loop} in seq loop 5
14:53:11 <lambdabot>   mueval-core: Time limit exceeded
14:53:25 <shachaf> sonoflilit: :: !Int
14:53:32 <sonoflilit> thanks
14:54:54 <_Ray_> :undo do t1 <- readLIORef r1;   writeLIORef r1 (p ++ t1);  t2 <- readLIORef r2; writeLIORef r2 (p ++ t2);  return ()
14:55:04 <_Ray_> Lambdabot hates me :(
14:55:10 <_Ray_> @undo do t1 <- readLIORef r1;   writeLIORef r1 (p ++ t1);  t2 <- readLIORef r2; writeLIORef r2 (p ++ t2);  return ()
14:55:10 <lambdabot> readLIORef r1 >>= \ t1 -> writeLIORef r1 (p ++ t1) >> readLIORef r2 >>= \ t2 -> writeLIORef r2 (p ++ t2) >> return ()
14:55:17 <_Ray_> Oh, it doesn't hate me :D
14:57:17 <nihtml`> @pl f x = length . filter ((==) x)
14:57:17 <lambdabot> f = (length .) . filter . (==)
15:01:50 <Eliel> how do I build a lazy list that has data from several IO actions? I tried blocks <- mapM action [1..100000] followed with processing and writing the output to several files but the code first reads all the data and only then writes.
15:02:24 <PhillipA> Eliel: you might want to spawn a separate thread
15:02:34 <nihtml`> @pl f elem x y = if x == elem then y+1 else y
15:02:34 <lambdabot> f = flip flip id . (ap .) . flip flip (1 +) . (((.) . if') .) . (==)
15:03:20 <Eliel> PhillipA: thread and MVar? yes, that could work but still, it feels like it should be possible without threading.
15:04:09 <kmc> the "avoid threading at all costs" attitude does not carry over to GHC Haskell
15:04:13 <PhillipA> why should it be possible to interleave side effects with evaluation of other code?
15:04:13 <kmc> threads are easy and cheap
15:04:31 <PhillipA> that's the answer, btw: unsafeInterleaveIO
15:04:34 <kmc> Eliel, a list where evaluating certain elements forces certain IO to occur breaks the basic rules of Haskell
15:04:40 <accel> when you don't have side effects
15:04:43 <accel> it's hard to have race conditions
15:04:44 <PhillipA> as its name indicates it's probably not a good idea
15:04:53 <kmc> but there are standard library functions that produce such a list
15:04:55 <kmc> like readFile
15:05:01 <kmc> they're considered unhealthy, though
15:05:03 <ddarius> Something less strong than full concurrency, such as declarative concurrency or coroutines would be somewhat more elegant.
15:05:20 <kmc> accel, if you don't have effects, don't use threads at all
15:05:23 <kmc> use par, etc.
15:05:33 <kmc> threads (i.e. forkIO) are used in effectful contexts
15:05:36 <kmc> and can have race conditions
15:05:39 <kmc> quite easily
15:06:10 <PhillipA> that's racist
15:06:10 <Eliel> I guess I get to figure out how to make this work with the enumerator package :)
15:06:21 <Eliel> ... as soon as I figure out how to write files with it
15:06:52 <benmachine> declarative concurrency would be nice
15:09:23 <erasmas> I'm still getting the hang of the enumerator package but it does make it easy to compose multiple functions (including writing to file handles) over a stream
15:10:09 <Eliel> then again, adding one unsafeInterleaveIO in one place looks like it would "solve" the problem.
15:10:58 <bla123> hm, will the community settle on one iteratee package (iteratee, enumerator), or will we continue to add two flavors of many packages to hackage?
15:11:08 <benmachine> Eliel: this is acceptable as long as you've read the disclaimer :)
15:11:44 <benmachine> bla123: judging by the mtl/transformers debacle, it might be a while
15:12:39 <bla123> :(  it looks like wasted effort to me. or has each of these packages some benefit over the other?
15:12:48 <Eliel> yes, they do
15:12:54 <PhillipA> http://memearchive.net/memerial.net/page/2003.jpg
15:13:09 <Eliel> IterIO package's documentation has an overview of the differences
15:13:09 <benmachine> bla123: there are small differences. my understanding is that iteratee is strongly performance-focused, and enumerator arose because iteratee was viewed as unfriendly
15:13:56 <Eliel> IterIO is similar to enumerator but has some features not present in enumerator
15:14:04 <bla123> benmachine: iterator seems to change its implementation frequently
15:14:19 <sonoflilit> If I write something like let {[a, b] = l; l = [2, 3, 4]}, how does it compile with no error? isn't the optimizer suppposed to notice?
15:14:51 <Eliel> hopefully someone will come up with a way to combine all the best of each in one style :)
15:14:54 <PhillipA> sonoflilit: notice what?
15:15:06 <sonoflilit> that it's erratic
15:15:06 <joseanpg> Pattern bindings are lazy
15:15:06 <benmachine> bla123: it's a relatively recent innovation I think, give it time
15:15:25 <PhillipA> > let {[a, b] = l; l = [2, 3, 4]} in 42
15:15:26 <lambdabot>   42
15:15:26 <bla123> oh, a third iterator package. now i have to choose one by deciding which packages i can rather live without, beacuse they are only available for the other library
15:15:38 <PhillipA> > let {[a, b] = l; l = [2, 3, 4]} in a
15:15:39 <lambdabot>   *Exception: <interactive>:3:5-14: Irrefutable pattern failed for pattern [a...
15:15:48 <joseanpg> [a,b] = l is lazy
15:16:06 <sonoflilit> yes, but it can be evaluated at compile time
15:16:08 <joseanpg> the types are fine
15:16:10 <sonoflilit> and I expect it is
15:16:12 <joseanpg> l is a List
15:16:17 <joseanpg> [a,b] is a list
15:16:27 <joseanpg> no
15:16:51 <joseanpg> lazy, [a,b] = lis is lazy
15:16:56 <benmachine> sonoflilit: according to the semantics of haskell, let [a,b] = l; l = [1,2,3] in 42 is *not* an error
15:17:14 <sonoflilit> mm, I see what you mean
15:17:22 <benmachine> the compiler could reasonably issue a *warning* but I suspect it would only be able to catch obvious cases
15:17:29 <sonoflilit> but a warning would still be very nice
15:17:57 <bla123> at a first glance, the iteratee package looked friendlier (the late versions, not the early ones), so i'll give it a first try ... or do you think that enumerator is easier to use?
15:18:11 <joseanpg> let { [a,b] = undefined} in 7
15:18:23 <joseanpg> you wait a warning?
15:18:31 <joseanpg> is the same
15:19:21 <sonoflilit> I want a warning if my function would always crash and it is not "f = error ..." or "f = undefined"
15:19:33 <BMeph> sonoflilit
15:19:44 <BMeph> sonoflilit" Why do you want that?
15:20:03 <parcs> sonoflilit: weren't you warned about a non-exhaustive pattern matching?
15:20:14 <BMeph> sonoflilit: Do you not want a warning if f = error ...?
15:20:24 <sonoflilit> parcs: no
15:20:55 <sonoflilit> BMeph: there are a few cases where it is obvious that someone wanted an error, like if they use the "error" function of "undefined" value
15:21:32 <joseanpg> @run let { a = undefined } in 7
15:21:32 <lambdabot>   7
15:21:43 <joseanpg> @run let { (a,b) = undefined } in 7
15:21:44 <lambdabot>   7
15:21:46 <BMeph> sonoflilit: Specifically, why should you be warned about a value which you never use? That sounds like an (over-eager, "premature") nightmare to me. ;)
15:21:52 <joseanpg> @run let { (a,b) = undefined } in a
15:21:53 <lambdabot>   *Exception: Prelude.undefined
15:22:08 <joseanpg> this is the semantic of Haskell
15:22:16 <PhillipA> BMeph: why should I be warned about type errors in definitions I never use?
15:22:26 <joseanpg> do yi see sonoflilit?
15:22:27 <PhillipA> that sounds like an (over-eager, "premature") nightmare to me
15:22:34 <joseanpg> yes
15:22:46 <benmachine> possibly there is an argument that there should be a warning
15:23:00 <kmc> i think warning on an irrefutable pattern match that will certainly fail is a good thing
15:23:09 <benmachine> "this pattern match can never succeed"
15:23:13 <parcs> maybe 7.2 implemented something about that
15:23:22 <kmc> warning on unused variables is also a good thing
15:23:29 <kmc> if your declaration triggers both warnings, so be it
15:23:30 <joseanpg> ok, but think
15:23:38 <PhillipA> I've got the opposite in my 6.10.2, warnings for patterns that always succeed
15:23:43 <joseanpg> f x = g x
15:23:47 <benmachine> I suspect to be useful it would require a good deal more analysis than ghc can offer
15:23:48 <joseanpg> g x = h x
15:23:50 <benmachine> er
15:23:50 <kmc> yeah, unreachable cases should also be warned
15:23:54 <benmachine> than ghc does at the moment, at least
15:24:12 <BMeph> PhillipA: Actually, I would question that as well - why sould you be warned about a type error in a definition that you never use?
15:24:18 <BMeph> *should
15:24:26 <PhillipA> BMeph: yeah, static typing totally sucks
15:24:29 <benmachine> BMeph: because working out in general if something is used is p tricky
15:24:34 <PhillipA> I want a ~lazy~ typechecker
15:24:39 <joseanpg> h x = case of x { 1 -> undefined, _ -> 2}
15:25:20 <joseanpg> let {a = h 1} in 5
15:25:26 <joseanpg> warning too?
15:25:57 <joseanpg> sorry
15:26:05 <joseanpg> let {a = f 1} in 5
15:26:25 * BMeph resigns.
15:26:43 <BMeph> PhillipA: You got me. :)
15:26:55 <joseanpg> too much analysis for the compiler
15:27:42 <sonoflilit> how do I go about debugging OpenGL code?
15:28:01 <sonoflilit> I have a program that's supposed to draw some stuff, and it doesn't
15:28:19 <sonoflilit> the interesting question is "what does the shader get as input"
15:28:24 <sonoflilit> how can I answer it?
15:28:24 <ddarius> benmachine: You can implement declarative concurrency on top of the existing concurrency mechanisms rather easily.
15:28:35 <parcs> sonoflilit: mesa right?
15:28:37 <joseanpg> @index NFData
15:28:37 <lambdabot> Control.Parallel.Strategies
15:28:43 <sonoflilit> parcs: yup
15:29:12 <parcs> these environment variables help a bit: MESA_DEBUG= MESA_GLSL=useprog LIBGL_DEBUG=
15:29:36 <erasmas> random question about iteratees... is there any chance this concept will one day take over lazy IO in the standard libraries? It may be a far-fetched dream, but I'd love to write code like `funcOne . funcTwo $ readFile "something.txt"` and get the same benefit as composing iteratees with a file enumerator
15:30:00 <benmachine> ddarius: I thought you might, has anyone done it?
15:32:16 <joseanpg> @run data Zas = Zas
15:32:16 <lambdabot>   <no location info>: parse error on input `data'
15:32:29 <sonoflilit> parcs: thanks, found one error already :)
15:32:37 <Saizan> erasmas: the problem seems to be that iteratees are way uglier than that :)
15:32:41 <joseanpg> @run a = 5
15:32:41 <lambdabot>   <no location info>: parse error on input `='
15:33:00 <Saizan> that won't get magically solved by being pushed into the standard libs
15:33:47 <joseanpg> @run let {fibs = 1:1:zipWith (+) fibs tail fibs}
15:33:48 <lambdabot>   not an expression: `let {fibs = 1:1:zipWith (+) fibs tail fibs}'
15:34:00 <joseanpg> @run let {fibs = 1:1:zipWith (+) fibs tail fibs} in fibs !! 5
15:34:01 <lambdabot>   Couldn't match expected type `[a]'
15:34:01 <lambdabot>         against inferred type `[a1] -> [...
15:34:17 <ddarius> benmachine: It would be trivial to do as a restricted IO monad.  You would allow forkIO and putMVar and an atomic readMVar.  However, ideally, you'd be able to use these from pure code, so you'd throw in a little safePerformIO.
15:34:23 <parcs> sonoflilit: see here for more shader debugging: http://www.mesa3d.org/shading.html#envvars
15:35:01 <benmachine> ddarius: well, *I'm* not going to write it
15:35:11 <ddarius> But, declarative concurrency is still somewhat statement-oriented so it doesn't completely fit in with pure (functional) code, though it does fit nicely with monadic code.
15:35:41 <erasmas> Saizan: I know, but some of the libraries out there are doing amazing things while still offering a very simple API, like the bytestring library or techniques like stream fusion. It seems like there'd be a way to eventually compose pure functions over a controlled stream of input
15:35:49 <kmc> ddarius, how do you avoid nondeterminism?
15:35:50 <joseanpg> @run let {fibs = 1:1:zipWith (+) fibs (tail fibs)
15:35:51 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
15:36:07 <kmc> oh, you can't write to a full MVar?
15:36:11 <joseanpg> @run let {fibs = 1:1:zipWith (+) fibs (tail fibs)}
15:36:12 <lambdabot>   not an expression: `let {fibs = 1:1:zipWith (+) fibs (tail fibs)}'
15:36:18 <joseanpg> @run let {fibs = 1:1:zipWith (+) fibs (tail fibs)} in 6
15:36:18 <lambdabot>   6
15:36:29 <joseanpg> @run let {fibs = 1:1:zipWith (+) fibs (tail fibs)} in fibs !! 4
15:36:29 <lambdabot>   5
15:36:45 <joseanpg> @run let {fibs = 1:1:zipWith (+) fibs (tail fibs)} in fibs !! 40
15:36:45 <lambdabot>   165580141
15:36:50 <joseanpg> @run let {fibs = 1:1:zipWith (+) fibs (tail fibs)} in fibs !! 100
15:36:51 <lambdabot>   573147844013817084101
15:36:58 <joseanpg> @run let {fibs = 1:1:zipWith (+) fibs (tail fibs)} in fibs !! 1000
15:36:58 <lambdabot>   703303677114228158218352548771835497701812698363587327426049050871545371181...
15:37:15 <parcs> joseanpg: /query lambdabot
15:37:57 <joseanpg> sorry parcs, new in irc
15:38:21 <PhillipA> a Chan is just 2 MVars
15:38:52 <kmc> that's how GHC implements them, yeah
15:39:03 <kmc> i'm not sure it's a useful way to think about them
15:44:38 <ddarius> kmc: Writing different values to the same variable is a runtime error.  So the non-determinism is collapsed into deterministically failing.
15:45:39 <kmc> i see
15:45:44 <kmc> that's a bit of a kludge, but ok
15:46:26 <kmc> it seems like a thunk is a fine substitute for a write-once MVar
15:46:40 <kmc> what kind of problems are easier to solve with deterministic concurrency than with pure parallelism?
15:46:46 <ddarius> kmc: The problem with that is that it doesn't separate declaration from binding.
15:46:57 <kmc> elaborate?
15:47:06 <ddarius> kmc: Pure parallelism a la par, has no semantic import.
15:47:16 <kmc> *nod*
15:47:57 <kmc> you can rephrase my question as "what kind of problems are easier to solve with concurrent semantics even when you've limited them thus?"
15:48:12 <ddarius> kmc: I cannot declare a list of variables and give that to a thread that will fill them with values and then wait on the results with thunks.  I would have to know what the thunks are being bound to when I created the variables.
15:48:20 <kmc> (setting aside that deterministic concurrency may also admit efficient parallel implementation)
15:51:14 <ddarius> kmc: Producer-consumer concurrency is something that can easily be done in the declaratively concurrent paradigm.  Something similar but different can be done with laziness.
15:56:14 <ddarius> Difference lists (i.e. the actual ones from Prolog) would be another thing that could be done.
16:02:56 <Cale> ghc: panic! (the 'impossible' happened) (GHC version 7.0.3 for i386-unknown-linux): initC: srt_lbl
16:04:33 <kmc> yikes
16:05:05 <Cale> （╯°□°）╯︵ƆH⅁
16:05:28 <shachaf> Cale: That's a bit inscrutable.
16:05:35 <ddarius> Cale: Did you make a little script to flip a string and prepend that prefix?
16:05:46 <shachaf> Oh, I see, GHC.
16:05:49 <Cale> ddarius: There's a website which does it, but I fixed the G
16:06:04 <Cale> (since I knew there was a better one than the one it chose)
16:06:04 <ddarius> The G looks a little weird.
16:06:17 <Cale> It's a game quantifier from logic
16:06:42 <shachaf> TURNED SANS-SERIF CAPITAL G
16:08:57 <Cale> apparently it's an error from the code generator monad
16:10:08 <Cale> ugh, it's essentially an uninitialised field of a record datatype :P
16:10:36 <hatds> I feel when I don't report those 'impossibles'
16:10:40 <hatds> *I feel bad
16:10:46 <shachaf> Cale: Why is that even allowed?
16:10:53 <shachaf> Allowed implicitly, that is.
16:11:26 <Cale> shachaf: Well, that wouldn't affect anything here, since it's actually explicitly being set to  error "initC: srt_lbl"
16:11:40 <shachaf> OK.
16:11:43 <kmc> great error message
16:11:45 <shachaf> But in general, it seems pretty silly.
16:11:55 <shachaf> @ghc
16:11:56 <lambdabot> ghc says: Simplifier reached fixed point
16:12:04 <Cale> @ghc
16:12:04 <lambdabot> ghc says: From-type of Coerce differs from type of enclosed expression
16:14:29 <Cale> I was able to bypass the error by removing class contexts from a few GADT data constructors.
16:14:43 <ddarius> shachaf: You are allowed to leave non-strict fields of a record undefined.
16:14:55 <shachaf> ddarius: Right, bu why is it allowed implicitly?
16:14:58 <ddarius> Cale: Try a newer GHC.
16:15:06 <shachaf> If you didn't use record syntax, you'd have to type out "undefined".
16:15:52 <ddarius> shachaf: Only because the positional syntax doesn't allow partial specification at all.
16:16:16 <ddarius> shachaf: I may declare a record and a) only use parts of it, or b) update it later to fill in the parts left undefined.
16:16:31 <shachaf> Right. It seems to me like implicit partial specification is a bad idea.
16:16:54 <shachaf> E.g. if it was disallowed, then you'd get warnings/errors if the record type was updated and its uses weren't.
16:17:04 <ddarius> shachaf: You do get warnings.
16:17:10 <shachaf> Ah.
16:17:17 * shachaf didn't, at one point.
16:17:20 <shachaf> But there's at least that.
16:19:07 <ddarius> > let x = Just {} in x
16:19:08 <lambdabot>   Just *Exception: <interactive>:3:8-14: Missing field in record construction
16:20:05 <shachaf> data Maybe a = Nothing | Just { unJust :: a }
16:20:44 <ddarius> unJust would be fromJust
16:20:53 <shachaf> Right.
16:20:57 * shachaf likes "unJust" better.
16:21:12 <coppro> it should be called Wrong
16:21:34 <coppro> or unFair
16:21:52 <hatds> fromNothing *cringe* :0
16:22:02 <kmc> fromNothing :: Maybe a -> ()
16:22:31 <hpc> :D
16:22:36 <shachaf> fromJust should have a safe version that doesn't return _|_.
16:22:41 <joseanpg> How could ask lambdabot the source of fmap in Maybe?
16:22:43 <shachaf> safeFromJust :: Maybe a -> Maybe a
16:22:50 <kmc> shachaf++
16:22:58 <kmc> @src Maybe fmap
16:22:58 <lambdabot> fmap _ Nothing       = Nothing
16:22:58 <lambdabot> fmap f (Just a)      = Just (f a)
16:23:19 <Cale> :| my clever type directed arrow-constructing machinery works, but makes our new preprocessor fail to optimise as well (because the newtype pattern matching requires some use of arr)
16:23:25 <shachaf> joseanpg: But lambdabot's database of definitions is somewhat ad-hoc, not generated from source files or anything.
16:24:08 <kmc> joseanpg, to get the real deal, GHCi ":i Maybe"
16:24:11 <joseanpg> thank kmc
16:24:13 <kmc> instance Functor Maybe -- Defined in Data.Maybe
16:24:19 <shachaf> kmc: That won't give you the source.
16:24:23 <kmc> the find that module on http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/index.html
16:24:29 <shachaf> Oh. Yes.
16:24:29 <kmc> or appropriate hackage package
16:24:40 <shachaf> I wish :info told you the package name.
16:24:46 <kmc> yeah...
16:24:52 <kmc> you should add it!
16:24:54 <kmc> you have the power!
16:25:12 <joseanpg> where is running lambdabot?
16:25:12 * shachaf becomes corrupted.
16:25:28 <parcs> joseanpg: on the cloud, duh
16:25:29 <kmc> joseanpg, a VPS Cale owns on Linode, iirc
16:25:42 <shachaf> "owns"
16:25:47 <Cale> no
16:25:49 <shachaf> This is the Cloud, remember. You own nothing.
16:25:54 <joseanpg> @src Maybe <*>
16:25:54 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
16:25:55 <Cale> VPS *lispy* owns on Linode
16:25:56 <shachaf> It's lispy's VPS, isn't it?
16:26:04 <PhillipA> @time joseanpg
16:26:06 <lambdabot> Local time for joseanpg is Mon Aug 01 01:47:08 2011
16:26:09 <Cale> I just have an account and run the bot in it
16:29:11 <joseanpg> Amazing Cale
16:29:22 <Cale> ?
16:30:28 <joseanpg> lambdabot is an amazing creation
16:30:47 <kmc> it's pretty nice
16:31:02 <kmc> the code was written by a number of people
16:31:23 <shachaf> lambdabot is an egregious mess.
16:31:34 <ddarius> An -amazing- egregrious mess.
16:32:57 <thoughtpolice> it hasn't had versions in many years, i wonder what's the oldest piece of code in the source these days...
16:33:46 * hackagebot HROOT 0.5.0.0 - Wrapper for ROOT  http://hackage.haskell.org/package/HROOT-0.5.0.0 (IanWooKim)
16:34:01 <ddarius> Lambdabot started as a large #haskell community project, then became the playground/testing grounds for at the time bleeding edge technology, and now has become somewhat less inchoate.
16:37:41 <avartanian_> I have a silly question. Does Haskell have something close to Clojure's ->>?
16:38:41 <kmc> i don't know what Clojure's ->> is
16:38:41 <Axman6> what does ->> do?
16:40:05 <dafis> @faq Does Haskell have something close to Clojure's ->>?
16:40:05 <lambdabot> The answer is: Yes! Haskell can do that.
16:40:29 <avartanian_> It takes a value as its first operand, then it takes a variable number of operands and it performs composition "in reverse".
16:40:37 <avartanian_> Or rather threads it through, i.e.
16:41:15 <avartanian_> (->> (range 1 10) (map (fn [n] (* n 2)) (filter even?))
16:41:30 <shachaf> avartanian_: In Haskell that's probably just composition.
16:41:33 <dafis> :t (>>>)
16:41:33 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
16:41:42 <shachaf> Because of the way "partial" application works.
16:41:43 <kmc> :t filter even . map (*2) $ [1..10]
16:41:44 <lambdabot> forall a. (Integral a) => [a]
16:41:52 <shachaf> > map (*2) . filter even $ [1..10]
16:41:53 <lambdabot>   [4,8,12,16,20]
16:42:01 <dafis> > 1 >>> (+3) >>> (* 4)
16:42:01 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
16:42:01 <lambdabot>    arising from a use of `...
16:42:07 <shachaf> (Or, yes, backwards.)
16:42:18 <dafis> > 1 >>> (+3) >>> (* 4) $ 0
16:42:19 <Twey> > (+ 3) >>> (* 4) $ 1
16:42:19 <lambdabot>   16
16:42:19 <lambdabot>   16
16:42:23 <shachaf> > 16
16:42:23 <lambdabot>   16
16:42:34 <Twey> Heh
16:42:36 <Axman6> 16!
16:43:08 <cmccann> avartanian_, so that's taking an argument, and a function, and applying the function to the argument?
16:43:26 <Twey> > let facts = scanl (*) 1 [1 ..]; (!) = (facts !!) in (16 !)
16:43:27 <lambdabot>   20922789888000
16:43:30 <shachaf> cmccann: Except functions aren't curries in Clojure. :-)
16:43:38 <Axman6> ->> seems like a very ugly way to do things
16:44:15 <shachaf> cmccann: So (->> (a b) (c d) (e f)) turns into (e f (c d (a b)))?
16:44:24 * cmccann is just guessing
16:44:38 <dafis> cmccann: apparently takes an arbitrary number of functions and passes the value to the (reverse?) composition
16:44:39 <cmccann> I don't know clojure and it's hard to google for "->>"
16:44:41 <avartanian_> cmcann, yup only in reverse of the usual Haskell syntax.
16:44:49 <shachaf> Apparently it's called "thrush".
16:44:59 <cmccann> that's an intuitive name
16:45:03 <Twey> Like the yeast infection?
16:45:05 <avartanian_> The name
16:45:11 <Axman6> ha
16:45:11 <avartanian_> comes from to mock a mockingbird
16:45:17 <Twey> Sure it's not ‘thrust’?  That would seem to make more sense
16:45:24 <cmccann> haha, bird combinators
16:45:31 <avartanian_> it is one of smullyan's birds
16:45:37 <cmccann> avartanian_, you want this then: http://hackage.haskell.org/package/data-aviary
16:45:47 * hackagebot HROOT 0.5.0.1 - Wrapper for ROOT  http://hackage.haskell.org/package/HROOT-0.5.0.1 (IanWooKim)
16:46:01 <avartanian_> cmccann wow that package name just put a big smile on my face
16:46:01 <Twey> Haha
16:46:16 * ddarius is pretty sure none of Smullyan's combinators are variadic.
16:46:24 <cmccann> and apparently thrush is just "flip ($)"
16:46:37 <avartanian_> I don't think it is thrush.
16:46:47 <avartanian_> Not exactly.
16:46:55 <mdgeorge> what do people think of the wisdom of porting the C++ STL to haskell?
16:47:11 <avartanian_> I think it is unwise.
16:47:14 <cmccann> mdgeorge, to what end
16:47:26 <kmc> Haskell already has some good data structure libraries
16:47:31 <kmc> that better fit the way people write Haskell code
16:47:32 <Twey> This is very bizarre.
16:47:39 <Twey> mdgeorge: This is very frightening.
16:47:42 <kmc> new data structures are welcome but they should have some purpose
16:47:51 <mdgeorge> well, I find myself frustrated that I can't write algorithms that are generic to different implementations of data structures
16:48:04 <cmccann> avartanian_, well, if you're expecting something that works with functions of variable numbers of arguments, that's not going to work the same in Haskell as it does in Clojure
16:48:05 <Axman6> of course you can
16:48:05 <Twey> mdgeorge: Introduce a typeclass library
16:48:15 <kmc> mdgeorge, yes, that's a problem
16:48:17 <shachaf> Apparently Smullyan's Thrush is (flip ($)).
16:48:26 <kmc> i would not describe that problem as "lack of C++ STL"
16:48:30 <Twey> You don't actually need to write the implementations — just make some typeclasses and instances for the common types
16:48:39 <Twey> Strong agreement
16:48:51 <mdgeorge> Twey: I agree, but don't you think that stl-style iterators are a good way to organize that library?
16:48:58 <avartanian_> cmccann yes I grant that part. Can't do varargs in Haskell. I was just trying to think of an elegant way of expressing the rest of it.
16:49:03 <Axman6> no! :|
16:49:06 <Twey> mdgeorge: … no
16:49:08 <kmc> this is still a totally different idea from "porting the C++ STL to haskell"
16:49:18 <Axman6> iterators are one of the reasons i stopped learning C++
16:49:19 <mdgeorge> kmc: ok, fine.  it's what I had in mind though
16:49:22 <shachaf> avartanian_: You can usually do varargs of some sort in Haskell.
16:49:25 <Twey> mdgeorge: Iterators are totally unrelated and don't make much sense in Haskell
16:49:28 <kmc> C++ iterators have a weird, imperative interface
16:49:33 <cmccann> avartanian_, I'm not sure what else it should do, so it's hard to say
16:49:57 <Axman6> > printf "%s %d %f" "hello" 1 pi :: String
16:49:58 <lambdabot>   "hello 1 3.141592653589793"
16:50:01 <mdgeorge> I guess they would be closer to const_iterators
16:50:02 <kmc> mdgeorge, did you look at Data.Foldable and Data.Traversable?
16:50:02 <avartanian_> shachaf well with a list, right?
16:50:05 <Twey> mdgeorge: All you need are some typeclasses and trivial instances.  You're overcomplicating ☺
16:50:07 <mdgeorge> kmc: yes
16:50:11 <cmccann> Haskell already has an iterator interface, it's ... er, what kmc just said
16:50:13 <kmc> mdgeorge, the iterator itself is still a mutable object
16:50:17 <Axman6> > printf "%s %d %f %f" "hello" 1 pi (22/7) :: String
16:50:17 <shachaf> avartanian_: Or with e.g. type classes.
16:50:17 <lambdabot>   "hello 1 3.141592653589793 3.142857142857143"
16:50:29 <mdgeorge> I don't see a good way to represent ranges using foldable/traversable
16:50:59 <avartanian_> cmccann it's basically  f x y z = (z . y)  x
16:51:17 <mdgeorge> let me show you what I had in mind...one second
16:51:18 <joseanpg> Where could I see the source of <*> for Maybe?
16:51:37 <avartanian_> cmccann but for for as many args as you want. i was just curious if there was already a notation for something like that.
16:51:46 <Axman6> @src Maybe (<*>)
16:51:46 <lambdabot> (<*>) = ap
16:51:51 <Axman6> @src Maybe ap
16:51:51 <lambdabot> Source not found. You type like i drive.
16:52:01 <cmccann> avartanian_, hm, I don't think that's something that has a clearly-defined type
16:52:05 <kmc> @src ap
16:52:05 <dafis> @src ap
16:52:05 <lambdabot> ap = liftM2 id
16:52:05 <lambdabot> ap = liftM2 id
16:52:19 <shachaf> > text "ap = liftM2 id"
16:52:19 <lambdabot>   ap = liftM2 id
16:52:27 <Axman6> ap (Just f) (Just x) = Just (f x); ap _ _ = Nothing
16:52:51 <Axman6> (Just f) <*> (Just x) = Just (f x); _ <*> _ = Nothing
16:53:37 <joseanpg> thanks
16:53:39 <joseanpg> :)
16:53:46 <mdgeorge> http://dl.dropbox.com/u/3989078/STL/Iterator.hs
16:54:21 <avartanian_> cmccann for any given # of arguments it does f :: a -> (a -> b) -> (b -> c) -> c
16:54:34 <avartanian_> cmccann but in the general case, no. maybe i need template haskell?
16:54:51 <cmccann> avartanian_, I suspect that's just overcomplicating things, honestly
16:55:09 <kmc> don't try to write Clojure in Haskell
16:55:20 <Axman6> @djinn Maybe (a -> b) -> Maybe a -> Maybe b
16:55:20 <lambdabot> f a b =
16:55:20 <lambdabot>     case a of
16:55:20 <lambdabot>     Nothing -> Nothing
16:55:20 <lambdabot>     Just c -> case b of
16:55:20 <lambdabot>               Nothing -> Nothing
16:55:22 <lambdabot>               Just d -> Just (c d)
16:55:24 <avartanian_> kmc cmccann oh i agree. this is just a mental experiment to see if i could translate a clojure idiom in haskell. if the answer is no, then the answer is no.
16:55:34 <cmccann> for any number of arguments, what you want is basically "x (flip ($)) (f . g . h)" etc., right?
16:55:46 <avartanian_> cmccann yup
16:56:13 <cmccann> then other than defining a nice name for (flip ($)) I doubt anything else is better
16:56:18 <kmc> what's a good /short/ example of laziness for composability?
16:56:31 * cmccann recommends (|>) as the name for (flip ($))
16:56:34 <ddarius> mdgeorge: You do realize most or even all of those functions are partial.
16:56:42 <Saizan> kmc: and and/or or ?
16:56:48 <Axman6> instance (BidirectionalIterator i) => ForwardIterator (Reverse i) where next (Reverse i) = Reverse $ prev i
16:56:57 <avartanian_> cmcann why (|>) ?
16:56:57 <Axman6> where's the constraint saying that i has to be an Enum?
16:57:32 <mdgeorge> ddarius: yes.
16:57:55 <mdgeorge> Axman6: ?
16:57:55 <kmc> Saizan, hmm, implemented in terms of foldr, yeah
16:58:07 <Axman6> ah, misread, i thought it was pred, not prev
16:58:17 <Saizan> kmc: ah, sorry, i mean all/any as compositions of and/or and map
16:58:32 <kmc> ok
16:58:36 <cmccann> avartanian_, because it's got decent visual mnemonic value, and that operator exists by that name in F#
16:58:36 <kmc> i bet i can fit all that on one slide
16:58:54 <mdgeorge> so, am I smoking a crackpipe?
16:58:57 <avartanian_> cmccann ah thanks. i was wondering how you came up with that so quickly.
16:59:00 <ddarius> mdgeorge: Yes.
16:59:14 <mdgeorge> good.  that's what I thought.  why?
16:59:15 <avartanian_> cmccann any advice for a flip (.) operator?
16:59:21 <cmccann> :t (>>>)
16:59:22 <kmc> :t (>>>)
16:59:22 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
16:59:22 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
16:59:26 <cmccann> pf
16:59:37 <Axman6> mdgeorge: i think it looks kinda cool, not it does look like you've just reinvented Zippers
16:59:38 <ddarius> It is probably possible to make some reasonable library inspired by C++'s STL, but it would still look -very- different.
16:59:57 <cmccann> avartanian_, anyway, yes, (>>>) does what you want
17:00:06 <mdgeorge> Axman6: yes, that was deliberate...zippers seem to be the right way to iterate over lists, no?
17:00:07 <kmc> it's not the crackpipe that matters, it's what you put in it
17:00:12 <cmccann> heh
17:00:19 <kmc> we were discussing this in #haskell-blah recently
17:00:22 <cmccann> words to live by, kmc
17:00:25 <Axman6> mdgeorge: they're probably the right way to do everything you want :P
17:00:42 <mdgeorge> how do I use zippers to represent a range?
17:00:59 <avartanian_> cmccann cool beans i never used control.category before. one small step
17:01:02 <ddarius> mdgeorge: Your interface doesn't really foster correctness and, as far as I can tell, offers little or nothing to using lists.
17:01:07 * kmc wonders if finger trees would be useful here
17:01:11 <kmc> as a generalization of zippers
17:01:14 <ddarius> Lists are simple functional iterators.
17:02:20 <mdgeorge> ddarius: the thing I'm hoping to offer is that I can implement that interface for other data structures
17:02:35 <ddarius> mdgeorge: You're missing my point.
17:02:36 <kmc> mdgeorge, no, you don't understand.  lists *are* iterators
17:02:50 <kmc> an iterator and a toList function are the same thing
17:03:50 <kmc> Saizan, ah, I was also going to give the small example of how (head . sort) can be O(n)
17:04:02 <Axman6> ranges are just range a b = take (b-a) . drop a
17:05:08 <Saizan> kmc: ah, right, that might strike a point more easily
17:05:49 <drdo`> Damn VPS, still running linux 2.6.18, so i can't get a more recent glibc, so i can't install a more recent ghc :S
17:06:16 <kmc> CentOS 5 ?
17:06:34 <avartanian_> Only trouble with [1..10] |> map (*2) >>> map (+2) is that it is doesn't type-check. I suppose I need to change the fixity.
17:06:40 <drdo> kmc: they offer a few choices, most of them don't even work because of this problem
17:06:44 <parcs> hmm, wouldn't it be logical to have ghci's :reload command unconditionally reload modules who have IO in their TH?
17:07:46 <mdgeorge> Axman6: that doesn't seem like a good implementation for arrays though
17:07:46 <kmc> nice, the Haskell wiki article on prime number sieves actually cites Eratosthenes, in the original Greek
17:08:12 <djkfdalkj> link?
17:09:16 <kmc> well i guess it's citing Nicomachus
17:09:21 <kmc> http://www.haskell.org/haskellwiki/Prime_numbers
17:11:20 <djkfdalkj> i should have payed attention during greek class
17:11:39 <mdgeorge> I should have taken greek class.
17:14:08 <NihilistDandy> I should have built a Trojan horse
17:14:17 <NihilistDandy> In my Latin class
17:14:50 <mdgeorge> is that like a sawhorse, only instead of a saw you use a trojan on it?
17:15:15 <NihilistDandy> Yes. The chafing is unbelievable
17:16:10 <mdgeorge> sounds like it.
17:16:23 <avartanian_> hmmm I would have thought that infixr 9 |> would have done it but guess not
17:17:45 <Saizan> you want it to have a lower fixity than >>>
17:18:11 <shachaf> Right. |> should have a very low fixity, like $.
17:18:39 <avartanian_> I don't see a fixity defined for >>> so I'm assuming it is infixl 9
17:18:57 <shachaf> It's infixr 1.
17:18:58 <cmccann> it's infixr 1
17:19:01 <cmccann> argh
17:19:10 <shachaf> cmccann++
17:19:16 <shachaf> (:i >>> in ghc.)
17:19:23 <cmccann> anyway, you want (|>) to be fixity 0
17:20:02 <cmccann> also, (|>) should probably be left-associative
17:20:06 <cmccann> mirroring ($)
17:20:13 <shachaf> cmccann: No, $ being infixr is evil.
17:20:38 <cmccann> shachaf, yes, but having them inconsistent seems worse to me :T
17:20:41 <avartanian_> thanks so much everyone for your help today. definitely took my haskell-fu up a notch
17:21:05 <avartanian_> mjrosenb, you totally should not be here, but should be trying to sneak photos out of the dark knight rises shoot on campess
17:21:06 <avartanian_> campus*
17:21:22 <mjrosenb> avartanian_: huh?
17:21:33 <adrake> mjrosenb is on the wrong coast for that
17:21:38 <adrake> :P
17:21:41 <mjrosenb> oh right
17:21:47 <mjrosenb> i'm on iridium
17:22:05 <Saizan> is that a drug?
17:22:27 <mjrosenb> Saizan: well, it will most likely kill you.
17:23:09 <shachaf> Only in large quantities.
17:23:30 <adrake> wikipedia claims elemental iridium is basically inactive in humans
17:23:50 <adrake> unless radioactive
17:23:54 * shachaf isn't confident that Saizan is human.
17:24:09 <NihilistDandy> The LD50 of iridium tetrachloride in rats is 4.67 mg/kg
17:24:11 <cmccann> almost anything can kill you sufficient quantities, anyhow
17:24:14 <cmccann> including water
17:24:21 <NihilistDandy> Especially water
17:24:23 <adrake> NihilistDandy, compounds of iridium are various sorts of nasty :P
17:24:30 <NihilistDandy> And don't even get me started on how terrible oxygen is for you
17:24:30 <adrake> NihilistDandy, also "tetrachloride" yuck
17:25:02 <shachaf> Compounds of almost anything are various sorts of nasty.
17:25:03 <cmccann> and I don't mean that in the "ha ha, drowning etc." joke sense, I actually mean that drinking too much water will give you "water poisoning"
17:25:05 <Cale> dihydrogen monoxide, a silent killer
17:25:14 <avartanian_> adrake mjrosenb i saw the cmu address and assumed pittsburgh
17:25:16 <cmccann> and people die from that on regular basis
17:25:21 <NihilistDandy> cmccann: Yes, I know. How about how oxygen causes tissue death? :D
17:25:41 <shachaf> NihilistDandy: Taking pure oxygen with you for SCUBA diving is a bad idea.
17:25:49 <NihilistDandy> Precisely
17:25:58 <karlicoss> how can i print stack trace?
17:25:59 <NihilistDandy> Though that's a tangential issue
17:26:08 <kmc> karlicoss, that's the question of the day
17:26:09 <Cale> karlicoss: what stack?
17:26:12 <kmc> @where RTS-xc
17:26:12 <lambdabot> ghc --make -fforce-recomp -prof -auto-all -rtsopts foo.hs && ./foo +RTS -xc
17:26:40 <Axman6> what;s that do?
17:27:14 <kmc> print profiling cost-center stack on exception
17:27:20 <Cale> (hint: the stack that GHC refers to in "stack overflow" is not a stack used for anything like what you're probably used to from strict evaluators)
17:28:05 <karlicoss> Cale: call stack
17:28:14 <Cale> karlicoss: There is no call stack, really.
17:28:28 <Cale> But you can get a cost-centre stack if you compile with profiling.
17:29:02 <Axman6> karlicoss: call stacks are somewhat meaningless when the order of evaluation is different from the text that you write
17:29:06 <avartanian_> Haskell's truly a lovely language. I spent the whole weekend reading up on Clojure and, to be honest, I don't like it nearly as much.
17:29:14 <NihilistDandy> A gram of iridium goes for upwards of $35 dollars. That's an expensive drug
17:29:28 <karlicoss> Cale: but there is something like "substitution stack"?
17:29:48 <NihilistDandy> avartanian_: That's because of all that Java down there :D
17:29:53 <Cale> karlicoss: There's a stack of pattern matches which are waiting for their scrutinees to be sufficiently evaluated to match
17:30:00 <kmc> NihilistDandy, do you know how much a gram of LSD costs?
17:30:01 <cmccann> avartanian_, Clojure and Haskell are very different styles of language, to some extent it's a matter of taste
17:30:16 <NihilistDandy> kmc: You also don't need a whole gram to get an effect :P
17:30:17 <karlicoss> Cale: yeah, that's somewhat i've meant :)
17:30:23 <kmc> indeed
17:30:25 <Cale> Evaluation is essentially left to right -- outermost first
17:30:32 <Cale> so you don't put calls on a stack
17:30:35 <NihilistDandy> Not that I would mind the experience :D
17:30:55 <avartanian_> cmccann NihilistDandy well right now I just think there is a lot more complexity in the collections classes than there needs to be. maybe I will get used to it over time, but there seems to be a lot to keep in mind.
17:30:56 <Cale> So the problem is that the order of evaluation *is* the order that you write the code :)
17:31:03 <kmc> i don't know how much a gram of LSD costs, either
17:31:13 <NihilistDandy> Hmm
17:31:14 <kmc> at retail prices it would be on the order of $200,000
17:31:17 <Cale> (but that most other languages are backward ;)
17:31:18 <kmc> but i'm sure there's a bulk discount ;P
17:31:19 <adrake> NihilistDandy, a gram of LSD goes for tens of thousands of dollars bulk price
17:31:21 <NihilistDandy> Yeah, that sounds about right
17:31:27 <adrake> NihilistDandy, /that's/ an expensive drug!
17:31:32 <adrake> :P
17:31:37 <drdo> lsd is mad expensive here
17:31:45 <NihilistDandy> But again, you'd need more iridium than lsd to get some kind of effect
17:32:04 <adrake> that's probably true
17:32:13 <adrake> but at 35 dollars a gram
17:32:13 <NihilistDandy> Granted, the iridium would probably just be a bloody nose and a stomach ache... but that's what you get for skipping out on LSD
17:32:15 <kmc> the payoff distribution for LSD manufacture is even more bimodal than for software startups
17:32:49 <NihilistDandy> kmc: More bimodal? So trimodal? :D
17:32:50 <kmc> either you make 10 kg of LSD and sell it for $20 million
17:32:57 <kmc> or you fail / burn down your house / get arrested
17:33:06 <NihilistDandy> Or you make a bad batch
17:33:09 <NihilistDandy> And that's just sad
17:33:19 <NihilistDandy> Oh, that was "fail"
17:33:32 <NihilistDandy> Though I suppose you can make a "bad" batch successfully
17:33:36 <NihilistDandy> I just wouldn't want to have it
17:33:47 <mjrosenb> kmc: speaking of software startups, you have any plans?
17:33:50 <kmc> haha mjrosenb
17:33:52 <kmc> not at present
17:34:01 <kmc> you probably heard about what happened to my current employer
17:34:30 <shachaf> Rather tragic.
17:34:35 <kmc> nah
17:34:57 <NihilistDandy> Who was your employer?
17:35:00 <kmc> Ksplice
17:35:02 <kmc> they got bought by Oracle
17:35:09 <adrake> /ouch/
17:35:09 <NihilistDandy> Ouch
17:35:12 <kmc> i've declined Oracle's job offer so I'm once again gainfully unemployed
17:35:13 <cmccann> A fate worse than death.
17:35:16 <kmc> haha
17:35:23 <kmc> y'know, I'm not sure Oracle is as bad as everyone thinks they are
17:35:23 <shachaf> kmc: Gainfully?
17:35:34 <kmc> they do evil big-company things... so do Google, Apple, Microsoft, Facebook, Red Hat, ...
17:35:36 <cmccann> shachaf, compared to working for oracle, I imagine
17:35:47 <adrake> kmc, a bunch of cmu students responded with "fuck you for what you did to sun" to job offers from oracle
17:35:48 <kmc> drdo, I think LSD is expensive because it's really hard to make
17:35:51 <NihilistDandy> I got so much more done when I was unemployed
17:36:01 <kmc> people who just want money will make meth
17:36:08 <adrake> kmc, oracle responded "we've been getting a lot of fuck you's, what exactly is wrong again?"
17:36:11 <NihilistDandy> Until they blow up :D
17:36:15 <kmc> people who want money and care a little bit about not being evil will make MDMA, 2C-I, etc
17:36:39 <NihilistDandy> Mmm, research
17:36:39 <drdo> kmc: It's way sadder that mph is dirt cheap to make yet i can't buy it easily
17:36:42 <adrake> kmc, the LSD synthesis is not particularly hard itself, but all of the precursors are really hard to get
17:36:49 <kmc> right
17:37:01 <adrake> (it's not like, an easy synthesis, but it's not impossibly hard either)
17:37:06 <kmc> can't someone make mutant e.coli that synthesizes LSD or at least psilocybin already?
17:37:21 <adrake> I'm still amazed we have a total synthesis of chlorophyll
17:37:24 <NihilistDandy> It's probably out there
17:37:33 <Martty> w..what channel have i come to
17:37:36 <kmc> haha Martty
17:37:47 <kmc> adrake, how did they get the job offers in the first place?
17:37:53 <kmc> did they apply and then reject Oracle?
17:37:57 <kmc> or were these unsolicited?
17:38:04 <adrake> kmc, oracle sent a bunch of offers unsolicited with no interviews
17:38:05 <avartanian_> You know, I don't know much about Oracle. Unlike say Google, people go to Oracle and I never hear from them again. in other words, I have a ton of books by Google employees, but I don't have anything on my shelf from an Oracle engineer.
17:38:08 <kmc> haha
17:38:16 <cmccann> kmc, a microorganism that synthesizes and excretes LSD and is highly contagious would be the most hilarious bioweapon ever
17:38:18 * mjrosenb got a job offer from microsoft by giving them my resume
17:38:21 <adrake> kmc, also, when told to fuck off, they persisted
17:38:25 <kmc> cmccann, you and I think alike
17:38:33 <mjrosenb> adrake: who did this happen to?
17:38:33 <NihilistDandy> avartanian_: I think I have one thing, but I'm pretty sure he was at Sun at the time
17:39:13 <NihilistDandy> cmccann: I will bankroll that war
17:39:19 <avartanian_> honestly, I measure what a company thinks of its engineers by how many famous engineers I know at the company
17:39:28 <adrake> mjrosenb, I don't remember who exactly, just that several people in 3k were complaining about getting repeated emails
17:39:28 <NihilistDandy> As long as you can do it for 600 USD or less
17:39:33 <kmc> cmccann, thank Eris the CIA didn't have recombinant DNA technology during MKULTRA
17:39:34 <adrake> mjrosenb, I know at least jwatzman sent a fuck you
17:39:44 <avartanian_> other than things they bought, I also don't know of any open source projects that I use that originated from Oracle
17:39:57 <kmc> avartanian_, they do a lot of Linux kernel development
17:39:59 <avartanian_> so it's all a big black hole. I have no idea what their culture is like.
17:40:06 <mjrosenb> avartanian_: btrfs -- sort of.
17:40:10 <avartanian_> kmc thanks. i didn't know that.
17:40:12 <kmc> hugetlbfs
17:40:19 <kmc> they're consistently one of the top 10 corporate contributers
17:40:33 <adrake> btrfs was "F U SUN WE DON'T NEED NO ZFS"
17:40:34 <kmc> and some of the ones above them are hw manufacturers who just contribute drivers for their own stuff
17:40:41 <adrake> and then they bought sun and zfs
17:41:09 <NihilistDandy> I want ZFS /whine
17:41:09 <mjrosenb> adrake: last i checked, they had not abandoned zfs, even though i think they are now able to re-license zfs under a gpl-compatible license
17:41:18 <mjrosenb> NihilistDandy: i have zfs!
17:41:25 <adrake> kmc, oracle has a couple guys that keep modern firefox working on sparc/64
17:41:29 <adrake> kmc, and solaris
17:41:38 <kmc> cmccann, see also http://en.wikipedia.org/wiki/Pont-Saint-Esprit#1951_mass_poisoning
17:41:40 <NihilistDandy> mjrosenb: What are you running?
17:41:58 <mjrosenb> NihilistDandy: freebsd.
17:42:02 <NihilistDandy> I thought so
17:42:11 <adrake> NihilistDandy, \exists ZFS for linux now
17:42:13 <shachaf> A coworker has had two different btrfs partitions fail.
17:42:20 <adrake> NihilistDandy, you just have to turn off preemption in your kernel
17:42:28 * shachaf is not encouraged to try it.
17:42:29 <NihilistDandy> Did they figure out booting from ZFS now on FreeBSD?
17:42:37 <mjrosenb> NihilistDandy: yes
17:42:39 <NihilistDandy> adrake: I'm on OS X :|
17:42:39 * kmc runs btrfs on his RAID0 and ext4 on his RAID1
17:42:47 <adrake> NihilistDandy, welp.
17:42:56 <NihilistDandy> mjrosenb: Hmm... might have to move back in that direction. :D
17:43:05 <mjrosenb> it is not the default (and suspect it won't be for quite some time), but it does work
17:43:13 <NihilistDandy> adrake: PROMISES WERE MADE
17:43:20 <kmc> adrake, that's interesting.  i'm glad sparc is still relevant, at least in the massive SMT space
17:43:22 <NihilistDandy> I blame Oracle :D
17:43:25 <kmc> it's an interesting design position
17:44:05 <adrake> I'm still not sure who would care about firefox 14 for sparc 32 though
17:44:38 <kmc> firefox 14 comes out next month, right?
17:44:45 <Axman6> NihilistDandy: therte is a project for zfs on os x thaty's taken apple's work ansd continued ut
17:44:50 * kmc thinks that's roughly their new version number schedule
17:45:07 <adrake> kmc, as a mozillian, you've got it about right :(
17:45:16 <kmc> another mozillian!
17:45:23 * shachaf wonders why anyone cares about version numbers.
17:45:23 <NihilistDandy> Axman6: Yeah, I've seen it. It's just not quite as workable as I'd like :D
17:45:27 <adrake> (mjrosenb sits next to me)
17:45:32 <kmc> sweet
17:46:01 <adrake> (I even got mozilla to pay me to write a little haskell!)
17:46:08 <shachaf> adrake: Are you still at Mozilla?
17:46:13 <Axman6> two haskellers, together, and not at a hackathon? :O
17:46:34 <adrake> shachaf, yep, I've got 20 days left until I disappear back to CMU
17:46:36 <shachaf> Axman6: I write some Haskell at work nowadays with another Haskeller!
17:47:06 <Axman6> what do you call a collections of haskell users?
17:47:20 <adrake> Axman6, I didn't know there was such a thing!
17:47:27 <Axman6> a hackathon!
17:47:30 <NihilistDandy> adrake: Is that Central Michigan or Carnegie Mellon? :D
17:47:32 <Axman6> >_>
17:47:33 <kmc> how many haskellers does it take to screw in a lightbulb?
17:47:38 <NihilistDandy> kmc: Just 1
17:47:41 <adrake> NihilistDandy, carnegie mellon, we have the domain damnit!
17:47:45 <adrake> NihilistDandy, :D
17:47:54 <Axman6> kmc: we'll find out when we need the light?
17:48:03 <cmccann> how many prolog programmers does it take to screw in a lightbulb?
17:48:11 <adrake> cmccann, 2^n
17:48:13 <cmccann> No.
17:48:15 <NihilistDandy> cmccann: Hang on, I'm still writing my rules
17:48:34 <coppro> kmc: fallacious; there are no female haskellers
17:48:43 <NihilistDandy> coppro wins
17:48:43 <Axman6> n = 1 surely?
17:48:54 <Axman6> heh
17:49:30 <mokus> kmc: depends whether unsafePerformIO is allowed ;)
17:50:07 <wavewave> I am happy to announce HROOT : haskell binding to ROOT
17:50:24 <Axman6> what's ROOT?
17:50:55 <wavewave> Axman6: see en.wikpedia.org/wiki/ROOT
17:51:12 <wavewave> numerical analysis package
17:51:25 <Axman6> argh, missing i!
17:51:28 <NihilistDandy> lol
17:53:04 <Axman6> Cern have too much time on their hands
17:53:26 <wavewave> HROOT has a homepage http://ianwookim.org/HROOT
17:53:30 <wavewave> ;-)
17:55:13 <NihilistDandy> I see a serious flaw in the design of ROOT
17:55:14 <NihilistDandy> to wit:
17:55:18 <NihilistDandy> "Thanks to the built-in CINT C++ interpreter the command language, the scripting, or macro, language and the programming language are all C++."
17:55:42 <Axman6> all your language are belong to C++?
17:55:44 <adrake> O.O
17:55:50 <NihilistDandy> adrake: No, OO
17:55:51 <kmc> oh boy, best scripting language
17:55:58 <cmccann> NihilistDandy, that was almost physically painful to read
17:56:06 <adrake> NihilistDandy, well played
17:56:12 <adrake> cmccann, almost?
17:56:23 <NihilistDandy> It was definitely existentially painful
17:56:32 <Axman6> he stopped himself poking out his own eyes, but only just
17:56:43 <NihilistDandy> I thought CERN would think things through a little more
17:56:51 <wavewave> that's why I made this ;-)
17:57:07 <adrake> is the scripting language still C++?
17:57:08 <cmccann> adrake, well, there was a mental flinch reaction that kept me from reading the whole thing
17:57:09 <Axman6> apparently Ada can be used very successfully for scientific computing
17:57:17 <wavewave> you know physicists recently moved from Fortran to C++
17:57:22 <NihilistDandy> Now I won't be surprised when the LHC rips a hole in universe. I'll die with these words:
17:57:26 <NihilistDandy> NULL POINTER EXCEPTION
17:57:33 <adrake> cmccann, ah, I made the mistake of struggling all the way through :(
17:57:56 * hackagebot intern 0.2.0 - Efficient hash-consing for arbitrary data types  http://hackage.haskell.org/package/intern-0.2.0 (EdwardKmett)
17:58:28 <shachaf> C++ is a great scripting language!
17:58:33 <kmc> NihilistDandy, no null-pointer exception in C++.  you just get a segfault, if you're lucky
17:58:43 <kmc> i guess it's different in CINT
17:59:10 <NihilistDandy> kmc: Right, but do you really think they'll have stopped at C++ by that point?
17:59:13 <NihilistDandy> I think not
17:59:23 <wavewave> CINT has some garbage collection, I remember.
17:59:25 <NihilistDandy> JHC, brought to you by CERN and Oracle
17:59:31 <NihilistDandy> Coming 2015, and then never again
17:59:34 <kmc> but C++ is fast! what with all that copying due to no garbage collection
17:59:41 * shachaf wonders whether anyone has done [[Shakespare (programming language)]] in reverse, writing plays in computer program syntax.
17:59:54 <NihilistDandy> exit;
18:00:05 <kmc> Oracle bought John Meacham?
18:00:37 <NihilistDandy> Java Hadron Collider
18:00:47 * adrake saves '[18:18:03] <shachaf> C++ is a great scripting language!' for blackmail
18:01:09 <shachaf> Uh-oh.
18:01:18 * shachaf needs to find some adrake blackmail material now.
18:01:24 <gwern> shachaf: you can always disclaim it - it wasn't signed with your personal key
18:01:32 <adrake> shachaf, here, I'll help, http://git.hax.so :P
18:03:51 <Axman6> anyone used Ada before?
18:04:04 <mjrosenb> Axman6: the compiler i used to work on supported ada
18:04:14 <Axman6> gcc? :P
18:04:38 <copumpkin> Axman6: you forgot the G
18:04:49 <Axman6> gccg?
18:04:56 <Axman6> Adag?
18:04:59 <shachaf> copumpkin is referring to Gada.
18:05:00 <Axman6> Gada?
18:05:00 <NihilistDandy> Agda
18:05:04 <kmc> gaga?
18:05:08 <NihilistDandy> Rara
18:05:08 <Axman6> bah
18:05:18 <geheimdienst> copumpkin, aka Lady Agda
18:05:20 <Axman6> It's actually a very interesting language
18:05:46 <shachaf> adrake: Come on, why do you hate C++ so much?
18:05:49 <shachaf> It has templates!
18:05:49 <geheimdienst> ... or lady gagda
18:06:00 <coppro> As someone who works on a C++ compiler as a hobby
18:06:06 <coppro> I assure you it's horrid
18:06:12 <mjrosenb> 21:25 < shachaf> adrake: Come on, why do you hate C++ so much?
18:06:15 <copumpkin> coppro: interesting hobbies you have
18:06:15 <mjrosenb> 21:25 < shachaf> It has templates!
18:06:18 <shachaf> Surely you mean a C/C++ compiler.
18:06:27 <mjrosenb> shachaf: you just answered your own question.
18:06:47 <shachaf> mjrosenb++
18:06:49 * shachaf should probably stop.
18:06:52 <adrake> shachaf, cpp:         258364 (81.66%)
18:07:06 <adrake> shachaf, do /you/ want to work with 258 thousand lines of C++?
18:07:17 <shachaf> That's a lot of lines of lines of C preprocessor code.
18:07:39 <adrake> shachaf, file a bug with http://www.dwheeler.com/sloccount/sloccount.html :P
18:07:45 <shachaf> adrake: What project is that, Mozilla?
18:07:51 <adrake> shachaf, hahahahaha
18:07:56 <adrake> shachaf, that's the javascript engine
18:08:07 <wavewave> V8
18:08:09 <wavewave> ?
18:08:14 <adrake> no, spidermonkey
18:08:19 <adrake> v8 is chrome's thing
18:08:20 <mjrosenb> iirc, the ghs compiler was about 1,000,000 of c++
18:08:20 <wavewave> I see.
18:08:44 <wavewave> what language is used for V8 by the way?
18:08:54 <mjrosenb> c++ most likely
18:08:59 <shachaf> C++.
18:09:04 <mjrosenb> el goog seems to like c++
18:09:17 <shachaf> And Java.
18:09:25 <adrake> shachaf, that count isn't really fair, as it also counts glue that's only needed for browser integration
18:09:36 <adrake> shachaf, but actual relevant code is at least 150k SLOC
18:09:41 <andares> hey, I'm trying to write a simple text-mode adventure game in Haskell, and I'm not sure how I should be structuring my program.
18:10:24 <hatds> which parts are you working on right now?
18:10:49 <NihilistDandy> andares: STRUCTURE IT LIKE A LABYRINTH
18:10:52 <shachaf> adrake: Sounds fun and exciting.
18:10:54 <wavewave> by the way, ghci seems not working with foreign library written in C++.
18:11:07 <coppro> andares: Structure the pure code first
18:11:41 <wavewave> I really wanted to replace CINT with ghci, but not successful yet.
18:12:06 <coppro> once you have a structure of pure code that you're satisfied with, build the other code on top of it
18:12:12 <hatds> yea, ghci and C++ object files doesn't work for me either, even specifying ghci use the g++ linker
18:12:32 <dafis> ghci++
18:12:39 <wavewave> some name-mangling problem.
18:12:50 <mjrosenb> extern C?
18:13:07 <wavewave> I did extern.
18:13:17 <wavewave> It worked with compilation.
18:13:42 <gienah> wavewav: I guess its probably not a name-mangling problem, the problem I have seen is the C++ destructors not being exported
18:14:03 <gienah> wavewav: you can check though by doing echo 'some_mangled_name' | c++filt
18:14:28 <wavewave> gienah: okay let me check.
18:14:45 <coppro> @src return :: a -> State s a
18:14:45 <lambdabot> Source not found.
18:15:01 <shachaf> adrake: I don't see anything really blackmail-worthy.
18:15:17 <adrake> shachaf, "tjit" ?
18:15:36 <coppro> andares: personally I prefer the reader monad to the state monad where it's available
18:18:16 <gienah> wavewave: there was a problem with the git build of llvm where ghci wanted a template function that was declared in a .cpp file, for that it would have worked to make the template function inline
18:18:55 <gienah> wavewave: the maintainer just got rid of the template function, another way to fix the problem
18:25:31 <ivanm> hooray, I just solved the same problem I solved a month ago... switching libraries for something made me forget that work-around I added in :s
18:39:17 <mjrosenb> ivanm: i hope it was easier the second time around.
18:45:03 * hackagebot hlibev 0.4.0 - FFI interface to libev  http://hackage.haskell.org/package/hlibev-0.4.0 (AycanIrican)
18:45:28 <ivanm> mjrosenb: once I realised what the problem was, yeah
18:45:40 <ivanm> but this time I had way more results to dig through before the problem appeared :/
18:46:15 <mjrosenb> ivanm: :(
18:48:04 * hackagebot HROOT 0.5.0.2 - Wrapper for ROOT  http://hackage.haskell.org/package/HROOT-0.5.0.2 (IanWooKim)
18:49:58 <scooty-puff> is it possible to, having defined a Set type class (with specialized elements - i.e. e -> s), and allow for newtype deriving of this sort:
18:50:14 <scooty-puff> deriving instance Set (Unique s) (UniqueSet s)
18:50:28 <scooty-puff> where Unique s = Unique Int, UniqueSet = UniqueSet IntSet
18:50:33 <scooty-puff> *UniqueSet s
18:50:54 <milktrader> When I type in the following in terminai: boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]  , I get a  parse error on input `='
18:51:15 <milktrader> but when I put it in a file and load it it works
18:51:17 <Axman6> you need let milktrader
18:51:18 <ivanm> scooty-puff: don't think so...
18:51:23 <Axman6> let boomBangs = ...
18:52:27 <milktrader> Axman6: yes, that does it. Thanks. Making my way through Learn You a Haskell
18:52:37 <Axman6> good work :)
18:52:44 <milktrader> why does it work that way though?
18:52:50 <Axman6> make sure you ask more questions here if you don't understand something!
18:52:55 <kmc> GHCi prompt is like an IO "do"-block
18:52:59 <kmc> it is not like the top level of a file
18:53:05 <Axman6> because ghci is sort of like a do block... which you probably haven't covered yet
18:53:07 <ivanm> kmc: well, more akin to a do-block
18:53:19 * ivanm forgets who does the usual "ghci is not a do-block" rants
18:54:07 <milktrader> alright, that's a good enough understanding for now. Thanks
18:54:08 <Axman6> but it so like totally is
18:55:07 <Axman6> milktrader: it's enough to know that to define functions in ghci, you need to use let. (you can;t define other things, unless you could named values [let x = 5^9734] as not functions). i.e. you can't define data types in ghci
18:58:14 <milktrader> Axman6: so far, I'm liking Haskell. I'm also beginning the learning of Prolog. Two languages I've always wanted to explore further
19:10:39 <shapr> yay Haskell!
19:10:45 <ivanm> yay shapr!
19:12:25 <Rabbit-AFO> yay ivanm!
19:13:29 <sshc> yay sshc!
19:18:08 <shapr> howdy ivanm!
19:18:54 <hatds> @pl \g x -> (f . g) x
19:18:54 <lambdabot> (f .)
19:19:10 <shapr> @pl x >>= x =<< y
19:19:10 <lambdabot> (line 1, column 9):
19:19:10 <lambdabot> unexpected "="
19:19:10 <lambdabot> expecting variable, "(", operator, ">>", ">>=", space or end of input
19:19:10 <lambdabot> ambiguous use of a right associative operator
19:19:17 <shapr> @pl x >>= x
19:19:17 <lambdabot> x =<< x
19:19:23 <shapr> @pl x >>= x >>= x
19:19:23 <lambdabot> x >>= x >>= x
19:19:55 <wavewave> hmm, how can I use parsec in Setup.lhs for a package that will be uploaded in hackage?
19:20:09 <wavewave> Should I not use it?
19:20:26 <roconnor> which do you prefer ((x /= 0) || (0x7f < y)) or ((x == 0) <= (0x7f < y)) ?
19:21:45 <Saizan> <= as implication is not that obvious
19:21:45 <hatds> I've defined `implies` as <= before, although I later felt that it's better just to give descriptive names.  let x_okay = x /= 0
19:22:14 <shachaf> You could define ==> as implication.
19:22:24 <kmc> if (<=) is implication do you use (≤) for lte?
19:22:41 <roconnor> kmc: <= is already boolean implication
19:22:49 <kmc> o_O
19:22:54 <hatds> fromEnum 0 :: Bool
19:23:00 <roconnor> > False <= True
19:23:00 <lambdabot>   True
19:23:01 <jmcarthur> > 1 <= 2
19:23:02 <lambdabot>   True
19:23:05 <roconnor> > True <= False
19:23:05 <lambdabot>   False
19:23:07 <kmc> my mind is blown
19:23:15 <hatds> fromEnum False
19:23:17 <kmc> i must tell everyone i know
19:23:19 <hatds> > fromEnum False
19:23:19 <lambdabot>   0
19:23:20 <hatds> :)
19:23:32 <roconnor> ... kmc I think this is why I always draw my boolean lattices upsidedown
19:24:10 <Eduard_Munteanu> Spread the word of Boolos.
19:24:12 <kmc> when computer scientists rebuild the world after the apocalypse, we will have hanging gardens with trees that grow downward
19:24:16 <kmc> hi Eduard_Munteanu
19:24:20 <Eduard_Munteanu> o/
19:25:02 <NihilistDandy> @quote kmc when computer scientists rebuild the world after the apocalypse, we will have hanging gardens with trees that grow downward
19:25:03 <lambdabot> No quotes match.
19:25:16 <NihilistDandy> @addquote kmc "when computer scientists rebuild the world after the apocalypse, we will have hanging gardens with trees that grow downward"
19:25:16 <lambdabot> Unknown command, try @list
19:25:23 <NihilistDandy> @list
19:25:23 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
19:25:41 <NihilistDandy> @remember kmc "when computer scientists rebuild the world after the apocalypse, we will have hanging gardens with trees that grow downward"
19:25:41 <lambdabot> Done.
19:25:44 <NihilistDandy> Jesus
19:26:06 * Saizan is reminded of NGE's geofront
19:26:11 <shachaf> One person here draws all his trees growing upwards.
19:26:16 <shachaf> It's infuriating.
19:26:40 <NihilistDandy> Maddening
19:26:41 <adrake> wait, what
19:26:43 <adrake> that's heresy
19:26:53 <jmcarthur> everybody knows that trees grow down
19:27:25 <shachaf> adrake: It's insane, isn't it?
19:27:26 <kfish> except decision trees!
19:27:36 <shachaf> When he draws them out it's one thing.
19:27:57 <shachaf> But when he writes a comment like "go up the tree", it's just unreasonable.
19:28:51 <NihilistDandy> TRAVERSE
19:39:22 <joe6> i am looking to do some parallel port programming using haskell. Is it possible to guarantee latency? For, oxample, I want a pin set high for x clock period, and then another pin for y clcok period.. and so on and so forth.
19:40:30 <adrake> joe6, the OS interface on linux at least sets the bits at once, and then it's hardware latency from there
19:41:07 <adrake> or you want to guarantee latency from change to change
19:41:23 <joe6> adrake, I want to send the data at different clock cycles.
19:41:24 <joe6> yes
19:41:44 * adrake is not aware of any real-time haskell facilities, sorry
19:41:45 <joe6> adrake: for example, clock cycle 1, data pin 1 is high, clock cycle 2, data pin 2 is high
19:41:48 <joe6> and so on..
19:41:57 <adrake> someone else may have more of an idea
19:43:52 <kmc> joe6, Haskell isn't a good language for hard real-time like that
19:43:57 <kmc> but neither is vanilla Linux a good OS for it
19:44:06 <joe6> oh, ok.
19:44:12 <kmc> the control software for my cheapo CNC laser cutter uses a special real-time kernel
19:44:26 <hatds> I feel that saying ":module + *Foo" in ghci should force interpreting Foo even if it's already available in compiled form.  ghci refuses and tells me to use ":add *Foo" if that's what I really want.  But why would I specify the '*' explicitly if it wasn't what I wanted?
19:44:48 <joe6> but, i see that there are a lot of mcu programmers  and they seem to be doing with some error margin.
19:45:42 <Eduard_Munteanu> joe6: if you do userspace parport frobbing in C, you don't get any latency guarantees there either
19:46:15 <joe6> Eduard_Munteanu: ha, the electronics and haskell man..
19:46:31 <joe6> Eduard_Munteanu: so, do not have to bother with latency, then.
19:46:49 <joe6> Eduard_Munteanu: how do they guarantee the data and clock changes? sleep for microseconds/
19:46:53 <joe6> s,/,?
19:47:13 <liyang> y'allo y'all
19:47:23 <joe6> I am looking to build a parallel port programmer for pic using haskell.
19:47:25 <Eduard_Munteanu> joe6: sleeps will last at least the specified amount
19:47:52 <joe6> I am tired of using the ones on the internet. I might, as well, do it and learn how it works.
19:48:10 <joe6> Eduard_Munteanu: it does not seem to be that hard from the programming spec
19:48:27 <joe6> Eduard_Munteanu: can I use haskell to set the parallel port bytes?
19:48:33 <kmc> joe6, to be safe, I would load up a buffer with bytes, and then call a C function
19:48:41 <kmc> C functions can't be preempted by the GHC garbage collector
19:48:49 <joe6> kmc, good idea.
19:48:49 <Eduard_Munteanu> No, if you supply your own clocking and you don't have any hard timing constraints, then it's probably doable.
19:49:05 <kmc> yeah, with asynchronous serial it may not be a problem
19:49:11 <kmc> because you control the clock
19:49:16 <kmc> if you're late on a clock pulse the mcu will wait
19:49:24 <kmc> i don't know how far that holds, though
19:49:28 <liyang> What's the proper way of bundling .so and .a blobs with cabal packages? I've added them to extra-source-files and put ./lib down as an extra-lib-dirs, but cabal register then complains about using relative paths for library-dirs.
19:49:35 <joe6> kmc, i control the clock, but there are some minimum time periods for the clock to be at a certain state
19:49:37 <Eduard_Munteanu> The STROBE# on the parport can be used similarly.
19:49:42 <kmc> minimum should be no problem
19:49:57 <kmc> the worry is maximum clock time / minimum data rate
19:50:06 <kmc> because your code might get preempted by garbage collection
19:50:11 <kmc> (or the OS scheduler for that matter)
19:50:28 <joe6> kmc, will check on the minimum clock time.
19:50:43 <joe6> i think there is no minimum data rate, though. let me doublecheck.
19:51:02 * kmc has only used USB programmers, and for AVR
19:51:08 <joe6> kmc, how about if I run it at a very high nice level. then, the OS scheduler might not be a bother.
19:51:16 <kmc> there's more you can do
19:51:20 <liyang> (It didn't complain a few months ago while I was on GHC 6.12.3.)
19:51:26 <kmc> you can set a POSIX real-time priority
19:51:43 <kmc> you can actually make a process on Linux that never get scheduled out
19:51:52 <joe6> kmc, what's that? I will google for more details.. That is very interesting.
19:51:57 <joe6> exactly what I need.
19:52:02 <Eduard_Munteanu> joe6: and yes, there are lots of MCU programmers that use userspace drivers to send data.
19:52:02 <kmc> great way to hard-lock the machine
19:52:15 <kmc> but you can still be preempted by hardware interrupts
19:52:18 <Eduard_Munteanu> Those cheap JTAG emulators.
19:52:58 <Eduard_Munteanu> joe6: what MCU is that?
19:53:09 <joe6> pic24FJ32GB002
19:53:17 * kmc notes that x86 Linux code can invoke "cli" after iopl(3) but this seems... inadvisable
19:53:40 <joe6> i use a picpgm(an859 parallel port programmer) on the pic18f's currently.
19:53:42 <Eduard_Munteanu> Ah, so you want to use ICSP I guess.
19:53:47 <joe6> yes.
19:54:17 <joe6> kmc, i have no idea what you just said. will read up on it.
19:54:34 <Eduard_Munteanu> kmc: I'd stay away from direct iopl-ing and instead use the userspace parport frobbing API, i.e. ppdev
19:55:00 <joe6> Eduard_Munteanu: are you aware of haskell bindings to ppdev?
19:55:24 <Eduard_Munteanu> Hm, no, though I haven't looked.
19:55:44 <joe6> nothing seems to come up on google.
19:55:59 <kmc> x86 is a weird architecture...
19:56:12 <kmc> it's fashionable to hate on x86
19:56:19 <kmc> but i find some of its weirdness clever or at least endearing
19:56:45 <Eduard_Munteanu> joe6: I'm not sure how easy it is to do ICSP yourself, but I'd look into stuff like ponyprog, that might do it already.
19:57:08 <Eduard_Munteanu> Or get a BusPirate, that will be faster and it's a nice tool.
19:57:32 <joe6> the spec does not seem that hard.
19:57:33 <Eduard_Munteanu> (these days you can barely find parallel ports on computers anyway)
19:58:25 <joe6> Eduard_Munteanu: and, will give me an opportunity to learn how ICSP works and also use an excuse to use haskell
19:58:33 <joe6> s/also use/also/
19:59:08 <joe6> i have one, and, it could be probably as easy to use serial. I assume, if need be, at a later stage.
19:59:30 <joe6> just checked out ponyprog and it does not support my pic.
19:59:46 <joe6> i used to use picpgm for a different chip and it was closed source.
19:59:48 <Eduard_Munteanu> Ah. I mentioned it because the BusPirate has an ICSP pin header IIRC.
20:01:08 <joe6> Eduard_Munteanu: the spec does not seem that hard. http://ww1.microchip.com/downloads/en/DeviceDoc/39934b.pdf
20:01:30 <joe6> Eduard_Munteanu: do you have any experiences that suggest it could be a lot harder?
20:02:14 <joe6> Eduard_Munteanu: will also check in the #elect.. forum.
20:02:42 <Eduard_Munteanu> I remember it being a bit more obnoxiuous than programming an AVR through the serial interface.
20:04:52 <joe6> there are a lot of tools around. But, they are all limited by what devices they support. I would rather just have something of my own, with the hardware that I have. and then add en for any device, I need.
20:06:54 <Eduard_Munteanu> Yeah, these days I try to avoid the parallel port as much as I can given its reduced availability.
20:07:38 <Eduard_Munteanu> (the serial port too)
20:08:39 <Eduard_Munteanu> Which usually leaves only USB for such purposes, which isn't that bad to setup with one of those FTDI chips.
20:09:13 <joe6> Eduard_Munteanu: the ftdi's are nice. but, the usb is nowhere as simple as the serial/parallel. they have their uses.
20:10:54 <kmc> joe6 et al: did you see http://www.pjrc.com/hub_isp/
20:11:37 <Eduard_Munteanu> Why? FTDI basically gives you an USB-pluggable serial port, with all control lines available.
20:11:54 <Eduard_Munteanu> AFAIK, in Linux you can treat it as a regular serial port.
20:12:15 <Eduard_Munteanu> (if you don't need the extra special I/O pins)
20:12:23 <joe6> kmc: that is pretty cool. I need something like that for a pic, though.
20:12:35 <kmc> it's also dog slow
20:12:45 <joe6> more complexity, when it breaks, more to think about.
20:12:48 <kmc> "It takes almost 13 minutes to write all 1950 bytes"
20:15:29 <Eduard_Munteanu> FTDI provides nice schematics in their specs/documentation, no need to think hard about it :)
20:16:51 <Eduard_Munteanu> (tho' that doesn't help that much for PICs)
20:22:59 <Eduard_Munteanu> joe6: http://hackage.haskell.org/packages/archive/ioctl/0.0.1/doc/html/System-Posix-IOCtl.html    -- that's just about all you need, plus actual ppdev constants, for it
20:23:20 <joe6> Eduard_Munteanu: cool, thanks a lot.
20:25:58 <Eduard_Munteanu> And here's the C reference: http://people.redhat.com/twaugh/parport/html/ppdev.html
20:25:58 <joe6> kmc, all the times are minimum times.
20:26:03 <joe6> no maximum times.
20:26:28 <joe6> Eduard_Munteanu: thanks a lot. that was very kind of you.
20:31:16 <hatds> hmm.. so you can't deriving Num ala newtype-deriving for data Foo = Foo Int deriving Num?
20:31:23 <hatds> *derive
20:31:59 <epdtry> hatds: you can't use GeneralizedNewtypeDeriving on things that aren't a newtype
20:32:13 <hatds> yea :) but I want to
20:33:10 <epdtry> hatds: why not "newtype Foo = Foo Int deriving Num"?
20:33:50 <parcs> does anyone know the name of the pragma that allows compile-time configuration of rtsopts?
20:34:16 <hatds> I think I will use newtype, but the restriction seems unecessary
20:37:00 <kmc> parcs, there's nothing direct afaik
20:37:21 <kmc> parcs, there's some symbol you can define in a C file
20:37:33 <haole> hello there... i'm thinking about learning haskell to write less code that can do a lot more than in mainstream languages like C++ and Java... i've a little background in scheme and i saw the benefits of having code as data for metaprogramming and i was wondering how haskell's features keep up with that, just as a motivation :)
20:37:52 <kmc> haole, GHC implements Template Haskell
20:38:01 <kmc> which is sort of like Scheme or Lisp macros
20:38:05 <kmc> you can read the paper and the GHC manual about it
20:38:09 <kmc> in general, it's a lot more cumbersome
20:38:15 <kmc> because Haskell has more syntax
20:43:34 <haole> kmc, i see... but i was wondering if haskell's design would prevent me needing macros this much
20:43:44 <haole> *me from needing
20:44:55 <kmc> likely so
20:45:09 <kmc> macros in Lisps are often used to delay evaluation
20:45:12 <joe6> haole: check out TH. it is pretty cool. Not as simple as the lisp macros, but they do a pretty good job.
20:45:19 <kmc> Haskell is lazy by default, so this isn't an issue
20:45:34 <kmc> also, Haskell has more syntactic flexibility without macros
20:45:40 <kmc> even though it has less with macros
20:45:59 <haole> i'm sorry if i'm asking dumb questions, but i'm trying to measure the challenge before me :)
20:46:03 <kmc> if you care a lot about the exact concrete syntax, it can get pretty ugly
20:46:14 <haole> what about dsls in haskell? is it good for them?
20:46:17 <kmc> but usually there is a "good enough" Haskell syntax without needing anything heavy like Template Haskell
20:46:24 <loupgaroublond> haole, haskell's functions are very composable, so many workflows that need macros in lisp can be done with pure code in haskell
20:46:31 <kmc> yeah, Haskell is one of the premier languages for DSLs
20:46:38 <kmc> a lot of the industrial uses are DSLs
20:47:04 <kmc> DSLs for programming realtime control systems, for modeling financial contracts, for hardware design, etc.
20:47:29 <haole> i'm not a veteran programmer but if i get proper dsls and delayed evaluation, than there is no need for macros in my needs
20:47:47 <kmc> the need still comes up
20:47:51 <kmc> especially because Haskell is statically typed
20:48:05 <kmc> but the situation is pretty good overall
20:48:55 <haole> i like lisp a lot, but haskell looks very cool too
20:48:58 <Axman6> haole: it's worth noting that in general, haskell does not treat code as data (that can be modified anyway)
20:49:16 <Axman6> template haskell is an extension that can be used for that, but it's GHc specific
20:49:20 <Axman6> GHC*
20:49:49 <haole> Axman6, maybe i'm worrying too much for a begginer :D this stuff looks pretty advanced
20:50:07 <Axman6> haole: yeah, it'll feel that way for a while, but the effort is well worth it
20:50:30 <Axman6> just don't expect "to learn haskell in a week", because you can;t do that with any language imo
20:50:51 <Axman6> you could learn all of C's syntax in a week, but it takes a lifetime to become a great C programmer
20:51:02 <haole> maybe i could learn to write C or Scheme in haskell's syntax, but not haskell itself :)
20:51:15 <haole> this happens a lot with lisp begginners, trying to find a way to make things imperative
20:51:25 <NihilistDandy> You can fit all of Smalltalk on an index card~
20:51:45 <Axman6> NihilistDandy: doesn't mean you 'know' the language though
20:52:08 <NihilistDandy> I didn't say it did. You made a comment about "all of C syntax in a week"
20:52:13 <NihilistDandy> I wanted to one-up you :D
20:52:20 <thoughtpolice> haole: i think it's perfectly OK to start off for example with lots of imperative code that sits in IO for example. haskell is a good imperative language too. you can slowly work yourself into decomposing your computations and state later
20:54:10 <Johannes`> how can it be an imperative language when variables are all consts? :S
20:54:38 <haole> sorry... didn't want to start a flame lol
20:55:10 <Johannes`> hey, no flame :)
20:55:18 <haole> beginner's questions usually are polemic
20:56:54 <Axman6> we're very open to beginner's questions :)
20:58:02 <kmc> what's the headline impressive statistic about the GHC IO manager?
20:58:05 <haole> Axman6, that's nice to know... once i made one of those questions in the FORTH group and i was beaten up by some guys, and then they started fighting each other! lol
20:58:20 <kmc> Johannes`, http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.1.0/Data-IORef.html
20:58:42 <Axman6> we're somewhat prone to getting into debates about what's correct, but we'll usually try and be helpful at the same time :P
20:59:00 <NihilistDandy> haole: Well, we're not going to Forth you to do anything you don't want to
20:59:11 <Axman6> Johannes`: Haskell has many different types of mutable variables
20:59:20 <Johannes`> aha :)
20:59:43 <kmc> GHC Haskell has software transactional memory
20:59:52 <kmc> which is an advanced form of concurrent imperative programming
20:59:56 <kmc> that few other imperative languages have
21:00:02 <kmc> Microsoft tried and failed to add it to C#
21:00:21 <Axman6> IOrefs, MVars (boxes which can either be empty of full, and block when you try to put/take to/from a full/empty box, which is very nice for concurrency), there's mutable arrays, and even access to pointers
21:00:28 <haole> well, thanks for the tips... gonna be back for more :)
21:00:32 <Axman6> oh and software transactional memory of course
21:04:29 <NihilistDandy> Are there any Forth jokes that aren't about Lisp?
21:05:21 <test> test
21:05:26 <Axman6> fail
21:05:45 <thoughtpolice> kmc: i was talking with pumpkin about STM and the failed C# implementation last night. we're afraid in the future people will point and say "look! MS tried STM with C# and it did not work! STM is a failure!" instead of "look! STM works great in haskell because you don't have to track every memory/read write by default!"
21:05:52 <kmc> heh
21:06:02 <kmc> fuck them, then
21:06:10 <kmc> people who don't want to learn something new can always find an excuse
21:06:12 <thoughtpolice> totes
21:06:23 <kmc> there are 1001 excuses not to learn Haskell
21:06:55 <thoughtpolice> also i met edwardk finally and i reiterate mark dominus's sentiments. i expected a floating head with an extra large, glowing brain with 5-dimensional cubes coming out of it.
21:07:02 <NihilistDandy> NO ONE USES IT. THE SYNTAX IS HARD. LOOPS > RECURSION
21:07:19 <Axman6> thoughtpolice: well, all you have to say is "it works great in haskell, because restricted IO is the worng default"
21:07:20 <kmc> thoughtpolice, he was kind enough to assume a humanoid form
21:07:29 <Axman6> unrestricted*
21:07:39 <thoughtpolice> kmc: hah
21:07:52 <NihilistDandy> thoughtpolice: Isn't that what he looks like? Every time I see a picture of edwardk, I black out and awake enlightened as if from a dream.
21:08:14 <shachaf> thoughtpolice: Wait, edwardk isn't a floating head?
21:08:18 <Axman6> thoughtpolice: i expect him to be an actopus, it's the only way i can explain the numbert of packages he writes at one
21:12:47 <Axman6> octopus even
21:13:30 <danharaj_> http://hackage.haskell.org/package/on-a-horse
21:13:31 <danharaj_> haha what
21:13:43 <danharaj_> Found that while hoogling 'on' because I forgot where it was defined.
21:14:23 <NihilistDandy> 500 error. I guess his combinators weren't good enough.
21:24:58 <kmc> what's the headline impressive statistic about the GHC IO manager?
21:25:04 <kmc> apologies if someone answered this earlier and I missed it
21:26:33 <danharaj> I can't count how many times I've accidentally alt-tabbed to this window instead of ghci and typed :r, but I haven't ever accidentally pressed enter yet.
21:26:58 <kmc> we get a lot of :r
21:27:00 <kmc> and also :wq
21:27:03 <medfly> should probably have joins and stuff displayed, it doesn't look like code that way
21:27:06 <medfly> at least to me
21:27:25 <shachaf> kill -9 $$
21:27:43 <NihilistDandy> AGH
21:28:40 <kmc> $ exec strace -p $$
21:28:40 <kmc> strace: I'm sorry, I can't let you do that, Dave.
21:28:40 <medfly> haha
21:29:11 <shachaf> Hah, it actually prints that.
21:30:00 <kmc> indeed
21:31:44 <thoughtpolice> zsh: command not found: strace
21:31:48 <thoughtpolice> how does i mac os x?
21:32:02 <Axman6> OS X had DTrace
21:32:18 <NihilistDandy> *has
21:32:25 <NihilistDandy> Also, zsh?
21:32:25 <Axman6> which i believe serves the same purpose, along with a hell of a lot more
21:32:27 <thoughtpolice> i know, i'm just being dumb
21:32:27 <NihilistDandy> wut
21:32:32 <Axman6> yeah, has, typo
21:32:37 <kmc> i hear dtrace is the best thing ever
21:32:56 <kmc> Linux is getting all these different kernel tracing mechanisms
21:32:59 <thoughtpolice> it's pretty neat you can use dtrace in cooperation with the GHC eventlog infrastructure stuff
21:33:01 <kmc> and they're all motivated by dtrace envy ;)
21:33:12 <Axman6> heh
21:33:24 <thoughtpolice> (that is, they're basically synced, so all eventlog events also fire off dtrace probes)
21:33:25 * shachaf has never used dtrace and isn't quite sure what it's supposed to do.
21:33:30 <Axman6> DTrace is pretty damn awesome, Apple's Instruments GUI makes is very nice to work with
21:35:52 <Eduard_Munteanu> ftrace/perf is also nice.
21:36:01 <Eduard_Munteanu> I haven't used DTrace though.
21:36:05 <Axman6> can be used for all sorts of things, like tracing system calls, monitoring memory usage, finding leaks, monitoring performance (including in multithreaded apps, on a per thread basis), and using Instruments you can even record GUI events along with all the rest
21:37:21 <Eduard_Munteanu> I kinda wish Ingo's idea was put to use, i.e. using ftrace for event (e.g. syscall) filtering.
21:38:31 <Eduard_Munteanu> Also unified access and resource controls would be nice. I wonder if one can simply have all filtering (including firewalling for example) integrated in the same infrastructure.
21:40:00 <kmc> > quickCheck isLatin1
21:40:01 <lambdabot>   Not in scope: `quickCheck'
21:40:05 <kmc> @check isLatin1
21:40:05 <lambdabot>   "Falsifiable, after 0 tests:\n'\\187807'\n"
21:40:56 <kmc> @check isAscii
21:40:56 <lambdabot>   "Falsifiable, after 0 tests:\n'\\109547'\n"
21:43:32 <Eduard_Munteanu> @check liftM2 (==) isAscii isLatin1
21:43:32 <lambdabot>   "OK, passed 500 tests."
22:01:30 <hpaste> dd pasted “dd” at http://hpaste.org/49735
22:02:17 <c_wraith> agh.  OverlappingInstances is become more overlappier.
22:02:24 <c_wraith> Good thing I try not to understand it anyway
22:02:40 <c_wraith> err, is becoming
22:06:45 <gwern> > 26.30 - 24.16
22:06:46 <lambdabot>   2.1400000000000006
22:07:04 <gwern> > 1.29 - 0.75
22:07:05 <lambdabot>   0.54
22:12:34 <NihilistDandy> That's unpleasant
22:28:06 * kmc has skillfully crafted a 21-slide overview of "Haskell and why you should care" without once mentioning type classes
22:28:39 <NihilistDandy> kmc: Interested
22:28:49 <shachaf> kmc hates type classes.
22:29:00 <kmc> pretty much ;P
22:29:14 <NihilistDandy> You should link to this overview
22:29:18 <kmc> NihilistDandy, eventually
22:29:25 <kmc> it's for a talk i'm giving later this year, date tbd
22:29:32 <NihilistDandy> Neato
22:29:58 <kmc> type classes are a nice way to solve the + / +. problem
22:30:20 <kmc> they're one of the main ways Haskell improves on Hindley-Milner
22:31:07 <kmc> they can be used for a lot more, but the result has a distasteful similarity to C++ template metaprogramming
22:31:28 <kmc> and they provide a lot of rope for beginners to hang themselves with
22:32:41 <ddarius> There are plenty of uses of type classes beyond "obvious" overloading scenarios that aren't logic programming in the type system.
22:33:21 <kmc> sure, and there are uses of C++ templates beyond parametric polymorphism that aren't obviously constructing lambda terms
22:33:27 <hatds> what is +.?
22:33:47 <kmc> hatds, in OCaml,  (+) :: Int -> Int -> Int and (+.) :: Double -> Double -> Double
22:33:53 <kmc> or something along those lines
22:33:58 <hatds> ah
22:34:11 <kmc> also there's sort of one built-in type class for (==)
22:34:12 <ddarius> kmc: Agreed.  Those uses of C++ templates are fine (admittedly, I find no real problem with C++ template metaprogramming either.)
22:34:15 <kmc> but you can't define new ones
22:34:18 <Eduard_Munteanu> Not having typeclasses at all ends up being problematic AFAICT.
22:34:31 <kmc> yes, I'm not proposing to eliminate type classes from Haskell
22:34:42 <kmc> aside from perhaps a beginner's subset a la Helium
22:34:59 <kmc> i'm just saying people sometimes get carried away with type classes and lose sight of good ol' functional programming
22:35:37 <kmc> especially if Haskell is your first exposure to FP
22:36:42 <Eduard_Munteanu> Well, Prelude is quite a mess especially because they didn't use typeclasses as much as they should have.
22:36:43 <ddarius> In all likelihood, most people both underuse and overuse type classes.
22:36:48 <kmc> Eduard_Munteanu, where?
22:37:27 <hatds> re good ol FP: yea I find the standard typeclasses are super useful but prefer just using functions where I once used a typeclass
22:37:28 <Eduard_Munteanu> kmc: Prelude focuses too much on lists, and that pollutes the namespace
22:38:22 <hatds> I think defining a type to more or less just let yourself dispatch on it is a bad pattern
22:38:27 <ddarius> It would be nice if the Boolean operations were in a Lattice type class.
22:42:19 <kmc> Eduard_Munteanu, designing a typeclass-overloaded container API is hard
22:42:30 <kmc> especially in Haskell 98
22:42:56 <kmc> i'd be happy to see more progress there
22:43:11 <kmc> but i think the current situation with simple Prelude and qualified imports is all right
22:44:38 <hatds> I was thinking about this and I realized that when I wanted the comfort of container flexibility I did that by creating a narrow set of domain specific functions for whatever that container does
22:44:52 <hatds> *when=whenever
22:45:38 <hatds> so having a container typeclass isn't so compelling for that situation
22:46:25 <Eduard_Munteanu> Well, you can't expect Prelude-like primitives to be completely opaque wrt the underlying container, e.g. some patterns work reasonably on lists only.
22:46:45 <Eduard_Munteanu> What I think is more worrisome is the namespace pollution.
22:47:09 <kmc> there's no "the" namespace
22:47:12 <kmc> once you stop worrying and learn to love qualified imports, a lot of things become better
22:47:36 <hatds> hmm.. which list functions aren't foldable/travesable that take good names?
22:47:38 <ddarius> I think simply casting some of the more popular data structures' interfaces into type classes would provide a lot of benefit for little cost, and is unlikely to stifle any innovation.
22:48:23 <kmc> i actually worry more about implementation duplication than interface duplication
22:48:59 <Eduard_Munteanu> kmc: I think it's especially ugly for infix operators, and the only other solution is coming up with alternate names.
22:49:24 <kmc> between ByteString / Text / smallstring / Vector / DPH / Repa i feel like a lot of code is getting copy-pasted, or nearly so
22:49:39 <kmc> Eduard_Munteanu, the other only solution is to hide those operators in Prelude and import non-qualified
22:50:31 <kmc> Eduard_Munteanu, how many infix operators does Prelude have for data structures, anyway?
22:50:49 <Eduard_Munteanu> That essentially amounts to making an alternate Prelude in case you don't want to do that yourself everytime.
22:51:15 <Eduard_Munteanu> Besides you can't really hide everything in Prelude that easily.
22:51:52 * kmc counts one, unless you consider functions as data structures
22:52:04 <kmc> oh, sorry, two
22:52:10 <kmc> (!!) and (++)
22:52:24 <kmc> and there's already a reasonable type class for (++)
22:52:30 <kmc> i'd be fine with that change
22:53:31 <Eduard_Munteanu> I wonder about a 'map'-able class that'd suit Bytestring.
22:53:56 <kmc> that probably requires mptc+fundeps or asstypes
22:54:15 <kmc> that's why i said a generic containers API is especially hard in Haskell 98 (or 2010)
22:54:41 <kmc> since the landscape of those features in GHC is still actively changing, i think standardizing on a containers API would be premature
22:55:17 <Eduard_Munteanu> That didn't prevent ST from being used though.
22:55:22 <Eduard_Munteanu> Or stuff like that.
22:55:57 <kmc> no, i mean that fundeps and asstypes are "competing" features and it's not clear which if any will win-out
22:56:11 <kmc> did a similar situation exist for Rank2Types at the time of ST's widespread adoption?
22:56:35 <Eduard_Munteanu> Ah, I see.
22:56:54 <kmc> ST generally has a lot fewer design choices to make
22:57:05 <kmc> and Rank2Types are a more conservative extension with a lot of theory going back even before Haskell existed
22:57:29 <hatds> ST is weird when I think about it.  It seems like there a lot more to the idea than just encapsulating mutable references, but that idea is never transported anywhere.
22:57:44 <kmc> how do you mean?
22:57:52 <hatds> e.g., can't we define a withFile or a bracket that statically ensures you don't leak the resource handle?
22:57:59 <kmc> yes
22:58:20 <kmc> iirc ezyang did a SMT solver binding that used the ST trick
22:58:35 <kmc> and edwardk's 'ad' library uses similar things
22:58:43 <kmc> it might not be worth it for withFile
22:58:53 <kmc> i don't know
22:59:55 <hatds> yea, true .. there is a sort of mental overhead involved
23:00:27 <Eduard_Munteanu> The problem I see with ST is you kinda get some ugliness when you want to design an opaque container type that uses mutation internally.
23:00:33 <Eduard_Munteanu> You have to carry that 's' around.
23:00:43 <kmc> the situation regarding runST (do foo) vs. (runST $ do foo) is murky enough to me
23:00:55 <kmc> that i wouldn't feel comfortable signing off on similar approaches with withFile
23:01:18 <Eduard_Munteanu> You kinda need impredicativity to get composable runST no?
23:01:22 <kmc> explain?
23:01:47 <Eduard_Munteanu> e.g. writing stuff like   foo . runST . bar
23:02:06 <kmc> Eduard_Munteanu, those difficulties with opaque container types gave rise to a gnarly type problem which is what made me start blogging about haskell :)
23:02:07 <kmc> http://mainisusuallyafunction.blogspot.com/2010/09/higher-rank-type-constraints.html
23:02:16 <kmc> Eduard_Munteanu, where does that require impredicativity?
23:04:09 <Eduard_Munteanu> > (runST . return) 5
23:04:10 <lambdabot>   Couldn't match expected type `forall s. GHC.ST.ST s a'
23:04:10 <lambdabot>         against infe...
23:04:14 <kmc> :t ?foo . runST . ?bar
23:04:15 <lambdabot>     Cannot match a monotype with `f (forall s. ST s a)'
23:04:15 <lambdabot>       Expected type: f (forall s. ST s a)
23:04:15 <lambdabot>       Inferred type: t
23:04:21 <thoughtpolice> @remember kmc that probably requires mptc+fundeps or asstypes
23:04:21 <lambdabot> Okay.
23:04:26 <thoughtpolice> quoted for 'asstypes'
23:04:35 <kmc> heh, i've been pushing that name for a while
23:04:46 <Eduard_Munteanu> > runST (return 5)
23:04:46 <lambdabot>   5
23:04:55 <thoughtpolice> fundeps vs asstypes. round 1. begin!
23:04:57 <kmc> :t runST . return
23:04:58 <lambdabot>     Couldn't match expected type `forall s. ST s a'
23:04:58 <lambdabot>            against inferred type `m a1'
23:04:58 <lambdabot>       Expected type: a1 -> forall s. ST s a
23:05:19 <kmc> Eduard_Munteanu, i see
23:05:35 <Eduard_Munteanu> As far as some people explained to me, "proper" ST requires impredicativity somewhere.
23:06:05 <thoughtpolice> yeah, i've never totally understood that with ST, the $ vs ()
23:06:16 <Axman6> :t \x -> runST (return x)
23:06:16 <lambdabot> forall a. a -> a
23:06:37 <thoughtpolice> fuuuuu. so clang is fast, but it turns out it's still not *that* fast when it compiles to compiling, say, a 300k C file
23:06:42 <thoughtpolice> actually
23:06:57 <kmc> :t (.) :: ((forall s. ST s a) -> a) -> (a -> ST s a) -> (a -> a)
23:06:57 <lambdabot>     Couldn't match expected type `forall s. ST s a'
23:06:57 <lambdabot>            against inferred type `ST s a'
23:06:57 <lambdabot>       Expected type: (forall s1. ST s1 a) -> a
23:06:58 <thoughtpolice> oh, derp. DEBUG + asserts
23:07:34 <kmc> :t (.) :: ((forall s. ST s a) -> a) -> (a -> forall s. ST s a) -> (a -> a)
23:07:35 <lambdabot> forall a. ((forall s. ST s a) -> a) -> (a -> forall s. ST s a) -> a -> a
23:07:39 <sshc> thoughtpolice: "asstypes"?
23:07:56 <kmc> :t let (.) :: ((forall s. ST s a) -> a) -> (a -> forall s. ST s a) -> (a -> a); (.) = (Prelude..) in runST . return
23:07:57 <lambdabot>     Inferred type is less polymorphic than expected
23:07:57 <lambdabot>       Quantified type variable `s' escapes
23:07:57 <lambdabot>     In the second argument of `(.)', namely `return'
23:07:58 <Eduard_Munteanu> kmc: will read your post shortly, but yeah, I considered making a mutable tree type, but you end up choosing between ST and IO.
23:08:00 <thoughtpolice> sshc: kmc's name for 'associated types', not mine.
23:08:07 <Eduard_Munteanu> IO sucks because it's obviosuly too much.
23:08:11 <thoughtpolice> although frankly, that's kind of a hilarious name. i may have to start using it
23:08:13 <sshc> :D
23:08:16 <Eduard_Munteanu> ST sucks because you have to carry an 's' around.
23:08:33 <kmc> you can provide the ST api and use it in IO
23:08:38 <kmc> but that doesn't solve your problem
23:09:02 <Eduard_Munteanu> I still favor the ST approach because maybe you can't get rid of that 's' in any meaningful way.
23:09:33 <Eduard_Munteanu> (even if the rank-2 types solution might be seen as a hack)
23:09:48 <kmc> if you're implementing an immutable data structure then you just push the runST inside
23:10:13 <kmc> if you're implementing a mutable API then you need that 's'; it's just as fundamental as with STRef directly
23:10:17 <kmc> but yeah, it is annoying
23:10:42 <Axman6> i'd love it if ST were more high performance than it is :(
23:10:54 <Eduard_Munteanu> I wonder about a restricted IO subset that effectively maps to ST.
23:10:58 <Axman6> it feels to me like it should be a high level wrapper for some very low level operations
23:11:01 <kmc> the performance of ST in general should be exactly the same as IO
23:11:09 <sshc> kmc: Do you not like associated types?
23:11:16 <kmc> sshc, no, what gave you that idea/
23:11:22 <Eduard_Munteanu> So you start your program in IO and "drop privileges" to a unique "IOST" thread.
23:11:59 <kmc> Axman6, you can use the fancy unboxed fusing vector whatever with an ST API or an IO API
23:12:03 <sshc> kmc: Why not?
23:12:12 <kmc> sshc, I mean I don't dislike them
23:12:15 <kmc> similarly boxed array performance sucks whether it's IO or ST
23:12:25 <sshc> kmc: monads-fd requires UndecidableInstances while monads-tf doesn't
23:12:27 <kmc> the difference between IO and ST exists only at compile time
23:12:39 <Eduard_Munteanu> Boxed arrays would suck everywhere no?
23:13:02 <kmc> Eduard_Munteanu, it would be nice to have more fine-grained subdivisions of IO, yes
23:13:12 <kmc> but that's solving a separate and much narrower problem than what ST is solving
23:13:29 <Eduard_Munteanu> Yeah, the main point of ST is runST.
23:13:30 <kmc> you won't get a safe run :: IOST a -> a
23:14:55 <Eduard_Munteanu> You do get a safe runIOST :: IOST a -> IO a   I think.
23:15:34 <kmc> sure
23:15:42 <kmc> that's just a newtype unwrapping probably
23:18:05 <Eduard_Munteanu> I'm still unsure how safe it'd be to build a mutable container using something like unsafePerformIO . stToIO internally.
23:18:25 <kmc> that should be exactly as safe as unsafePerformIO by itself
23:18:47 <kmc> you can implement IOST by exporting "newtype IOST a = IOST { runIOST :: IO a }" without its constructor
23:18:54 <Eduard_Munteanu> Yes, but could you build containers that are safe up to the "trust me" part?
23:19:09 <kmc> and then wrapping whatever operations you feel are worthy of inclusion
23:19:29 <kmc> and exporting those as "primitives"
23:19:34 <Eduard_Munteanu> Something like that is being exploited in DiffArray, AFAIK.
23:19:57 <kmc> wait, you're building a *mutable* container using unsafePerformIO?
23:19:58 <kmc> where?
23:20:16 <Eduard_Munteanu> I'm not. I *was* building a mutable contatiner using ST and carrying 's' around.
23:20:27 <Eduard_Munteanu> Basically, an STTree s a
23:20:40 <kmc> "<Eduard_Munteanu> I'm still unsure how safe it'd be to build a mutable container using something like unsafePerformIO . stToIO internally."
23:20:45 <kmc> can you explain the context for that question?
23:21:20 <Eduard_Munteanu> Yes, I'm wondering if you can safely get rid of the 's' there by using unsafePerformIO internally.
23:21:53 <Eduard_Munteanu> In other words, having pure objects achieving true mutation internally. Just like DiffArray.
23:22:04 <kmc> then you're not providing a mutable API anymore
23:22:10 <kmc> you've totally changed the goal
23:22:30 <Eduard_Munteanu> Yeah.
23:23:06 <Eduard_Munteanu> Basically, I'm saying "here's the container X", but X is just a bunch of pointers.
23:23:08 * kmc is still confused, but whatever
23:23:19 <Eduard_Munteanu> The user needn't know that.
23:23:41 <Eduard_Munteanu> The question is, can this be achieved safely in Haskell?
23:24:21 <Eduard_Munteanu> DiffArray works reasonably safe AFAIK, except its performance isn't quite good.
23:24:45 <Eduard_Munteanu> (due to locking IIRC)
23:24:48 <kmc> a better example of a data structure with a pure interface which uses IO internally is ByteString
23:25:02 <kmc> but its buffers are immutable after creation
23:25:36 <kmc> DiffArray is somewhat misguided imo
23:25:58 <kmc> with that access pattern you want a tree of some kind, not a flat array
23:26:01 <Eduard_Munteanu> I'm not that sure it is. Couldn't the locking mechanism be blaimed for its performance?
23:26:05 <kmc> probably a trie
23:26:34 <kmc> a trie and a flat array both have "O(1)" access, which is roughly meaningless
23:26:35 <hatds> I've yet to actually need a mutable array.  Unboxed and contiguous are important sometimes, but not mutable.
23:27:23 <Eduard_Munteanu> kmc: nah, the actual context there was implementing an adaptive Huffman coding.
23:27:29 <Eduard_Munteanu> It kinda sucked.
23:27:52 <Eduard_Munteanu> I pretty much ruled out zippers and every other pure approach.
23:28:06 * kmc isn't sure what you're "nah"ing
23:28:17 <Eduard_Munteanu> The trie approach.
23:28:23 <kmc> ah
23:28:27 <kmc> and how have you refuted tries?
23:28:53 <kmc> did you try a cache-aware high-arity trie with packed nodes?
23:28:54 <Eduard_Munteanu> What I really needed was mutable trees that allowed me to keep pointers to leaves.
23:29:16 <Eduard_Munteanu> No.
23:30:11 <Eduard_Munteanu> Well, I could've reworked the entire algorithm, but that would've been harder.
23:30:17 <Eduard_Munteanu> (or maybe not possible?)
23:30:23 <Eduard_Munteanu> Who knows.
23:30:51 <hatds> right now I'm working on a similiar problem.  I discard a zipper design for my tree as well as a cyclic doubly linked design
23:31:07 <Eduard_Munteanu> Anyway, in C it's quite natural to swap subtrees, keep pointers to leaves and all that reasonable stuff which gives you reasonable performance.
23:31:29 <kmc> it's natural to do those things in Haskell too
23:31:31 <kmc> inside IO or ST
23:31:32 <hatds> what I'm doing now is using Data.Sequence as my "zipper", and the elements of the sequence point to the elements of the Tree
23:31:55 <kmc> i expect building a pure interface will be harder in C than in Haskell
23:32:15 <Eduard_Munteanu> kmc: yeah, in retrospect my design wasn't really great. What I should've gone for was mutable pointers in IO I guess, for maximum ease of use.
23:32:29 <Eduard_Munteanu> That is, something IORef (IORef a)
23:32:39 <kmc> Mu IORef !
23:33:10 <Eduard_Munteanu> Seriously, I haven't thought about that... is there any use?
23:33:52 * kmc doesn't know of one
23:34:01 <kmc> Mu Chan is useful
23:34:09 <kmc> it is the only "data structure" in the π calculus
23:34:14 <kmc> which is Turing-complete
23:34:33 <Eduard_Munteanu> Hm, I don't know about that, I should look it up.
23:37:23 <Eduard_Munteanu> I'd be interested in seeing a DiffArray variant which didn't do locking at all.
23:37:41 <Eduard_Munteanu> I know, some would complain loudly :)
23:40:22 <kmc> i still think the whole idea of DiffArray is misguided
23:40:40 <kmc> which you didn't respond to
23:40:53 <kmc> other than to say that you didn't actually try good persistent data structures
23:41:10 <kmc> Eduard_Munteanu, did you try using an IntMap as your "pointer store"?
23:41:22 <kmc> i.e. a "pointer" is an IntMap key
23:42:41 <Eduard_Munteanu> kmc: not really. I did do normal Huffmann and Shannon-Fano before which didn't require that sort of mutation. I used IntMaps there for a similar purpose and it didn't feel like the performance was great.
23:42:58 <Eduard_Munteanu> e.g. 3x slower than not-so-optimized C code.
23:43:15 <kmc> that seems all right to me
23:43:25 <kmc> i mean, it's all relative / conditional
23:44:14 <Eduard_Munteanu> kmc: DiffArray itself might be misguided, but then again GHC's approach is a bit misguided too, from a performance POV. The copying overhead is just too big, and mutable interfaces are sometimes just too ugly.
23:44:33 <hatds> is there a name the style of storing Ints representing pointers or offsets?  It can be technically pure but it sure doesn't feel like it.
23:44:43 <hatds> *name for the style
23:45:04 <kmc> Eduard_Munteanu, the reason I suggested tree-shaped structures is that you *avoid* most of that copying
23:45:14 <kmc> you just point back into the old tree
23:45:22 <kmc> i don't know what you mean by "GHC's approach"
23:46:05 <Eduard_Munteanu> kmc: I mean GHC doesn't turn most operations into in-place mutations as often as it'd need to for some application. Though I'm not suggesting that's easy.
23:46:16 <Eduard_Munteanu> *applications
23:46:39 <kmc> ah
23:46:39 <Eduard_Munteanu> I'd really like it to be oblivious wrt mutable vs immutable interfaces, at least in trivial cases.
23:47:03 <theorbtwo> Hm.  It does seem that ghc could figure out that the "old" version is unreachable, and mutate instead of copying.
23:47:20 <kmc> when you write 'insert' for balanced binary trees in the naive way
23:47:25 <kmc> you get code which only copies O(log n) data
23:47:26 <theorbtwo> (Or does it already do so and I'm misunderstanding the problem.)
23:47:42 <kmc> and that's not a crazy GHC optimization; it's a fundamental property of how data works in any sane Haskell implementation
23:47:57 <kmc> when you update one part of a tree you do not need to copy the whole tree
23:48:06 <kmc> when you update one part of an array you do need to copy the whole array
23:48:16 <kmc> DiffArray attempts to paper over that problem
23:48:31 <kmc> but it seems saner to start with the data structure that intrinsically doesn't need much copying
23:50:13 <Eduard_Munteanu> Well, if GHC could determine a certain container, say an array, wasn't accesible from other threads and no other references were kept to it, it could mutate in-place.
23:50:53 <Eduard_Munteanu> That amounts to inferring uniqueness AFAICT, at least in some sense.
23:51:08 * kmc thinks nobody is paying attention
23:51:41 <Eduard_Munteanu> You mean the part about O(log n)? That sometimes isn't good enough.
23:51:47 <hatds> I think you are making perfect sense kmc :)
23:51:50 <kmc> Eduard_Munteanu, it's "O(1)" for hash tries
23:51:50 <frerich> I do glance over the backlog every 15 minutes or so, but I long lost track of what the topic is.
23:52:33 <avartanian> quick dumb question: if i have a list, what's the most idiomatic way to turn it into a list of lists of length two? i.e. [1,2,3,4,5,6] => [[1,2],[3,4],[5,6]]
23:52:43 <kmc> avartanian, there's not a great standard way actually
23:53:02 <kmc> > takeWhile (not . null) . map (take 2) . iterate (drop 2) $ [1..6]
23:53:04 <lambdabot>   [[1,2],[3,4],[5,6]]
23:53:06 <hatds> direct recursion
23:53:14 <hatds> direct/explicit
23:53:14 <avartanian> kmc my god you are fast
23:53:44 <dibblego> that's what she said
23:53:50 <kmc> Eduard_Munteanu, if you're summarizing it as "the part about O(log n)" then I think you're not understanding what I'm saying
23:54:14 <dibblego> >> splitEvery 2 [1..6] -- Data.List.Split
23:54:15 <dibblego> [[1,2],[3,4],[5,6]]
23:54:27 <kmc> anyway you can go on wishing for vaguely specified, extremely difficult GHC optimizations
23:54:52 <Eduard_Munteanu> kmc: well, I'm thinking about that specific application. I'm not sure any immutable structure can guarantee O(1) lookups and O(1) mutation.
23:55:17 <kmc> and i will go on using the data structure that works right in the first place
23:55:25 <Eduard_Munteanu> And AFAIK, hash tries aren't exactly identical to hash tables wrt complexity.
23:55:34 <kmc> Eduard_Munteanu, it's all O(1) because your machine has finite RAM ;P
23:55:38 <kmc> asymptotic complexity sucks
23:55:44 <Eduard_Munteanu> LOL
23:55:51 <kmc> it's a way to compare your theoretical CS paper to someone else's theoretical CS paper
23:55:53 <theorbtwo> kmc has a certian point.
23:55:57 <kmc> it's not a valid way to decide which data structure to use in practice
23:56:20 <kmc> you need to profile a real DiffArray with real cache effects against a real 32-ary packed-node hash trie with real cache effects
23:56:23 <ddarius> In practice, hash tables tend to perform -very- well.
23:57:01 <kmc> ddarius, yes, but I'm not optimistic about providing a persistent API to one
23:57:10 <Eduard_Munteanu> kmc: I'm comparing optimization opportunities. And when I'm mostly doing lookups, I'd rather dereference a pointer than go from the root all the way to the leaves.
23:57:28 <kmc> Eduard_Munteanu, do a little math for me... how many steps to a leaf in a 32-ary tree?
23:57:42 <kmc> a 32-ary trie, I mean -- indexed by 64-bit hash values
23:58:18 <theorbtwo> Especially if you take a bit of care to avoid accidental or intentional-by-an-attacker worst-case scenerios.
23:58:29 <Eduard_Munteanu> Well, you're expecting the algorithm I'm using can settle with a trie.
23:59:47 <kmc> your hash table may be O(1) but my trie is O(12)
23:59:53 <kmc> anyway whatever, i'm sick of this argument
23:59:54 <Eduard_Munteanu> You do get log n asymptotics and in practice not many lookups but it's not enough for many CPU-intensive tasks which do *lots* of lookups.
