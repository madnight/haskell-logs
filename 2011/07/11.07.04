00:08:58 <ivanm> what do people recommend for a queue data structure?
00:09:01 <ivanm> just using Seq ?
00:11:59 <Saizan> i think so
00:12:37 <ivanm> is okasaki's implementation in a library?
00:13:02 <c_wraith> edison
00:13:10 <c_wraith> has two of okasaki's queues
00:14:51 <ivanm> hmmm, edison uses haskell98, so I wonder how long it'll last...
00:17:00 * ivanm guesses that edwardk has some weird type-classes that put together act as a queue interface :p
00:54:25 <ivanm> preflex: seen Cale
00:54:25 <preflex>  Cale was last seen on #haskell 3 hours, 10 minutes and 47 seconds ago, saying: deech: Might be the thing to try updating...
00:55:56 <Giraffer> When I was 11 years old I visited Neverland Ranch for 3 days and had a ball with Michael Jackson.   We would go gokarting around sipping jesus juice and cuddling.     My favorite moment was when we climbed a tree, and he pulled off my shorts and underoos to stick his nice hot nigger dick into my ass while I grabbed a giraffe's head by the horns to felate me!
00:56:23 <ivanm> @where ops
00:56:23 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
00:57:53 <ivanm> OK, the troll has gone
01:00:55 <elliott> IORefs have an Eq instance, but they don't have an Ord instance, which is unfortunate since it means you can't use them as a Map key
01:06:31 <Saizan> Eq uses pointer equality, if you do the same with Ord you get an order that can change after every GC
01:06:51 <elliott> Saizan: And an equality that changes every GC is better how?
01:07:00 <elliott> I assumed the Eq instance would be smarter than that.
01:07:08 <Saizan> the equality doesn't change
01:07:20 <elliott> Hmm, I see what you mean
01:07:30 <elliott> Still, it's very annoying
01:07:36 <elliott> I guess the right thing to do is to use StableName
01:07:39 <elliott> But StableName is quite ugly
01:08:02 <quicksilver> or just generate your own IDs along with your IORefs
01:08:13 <quicksilver> wrap the type
01:08:18 <accel> is "try/catch" or "handle" the standard way to handle exceptions in haskell?
01:08:27 <elliott> quicksilver: yeah, that's probably the best idea I guess
01:09:09 <Saizan> ?hoogle Control.Exception.handle
01:09:09 <lambdabot> Control.Exception handle :: Exception e => (e -> IO a) -> IO a -> IO a
01:09:10 <lambdabot> Control.Exception.Base handle :: Exception e => (e -> IO a) -> IO a -> IO a
01:09:10 <lambdabot> Control.Exception handleJust :: Exception e => (e -> Maybe b) -> (b -> IO a) -> IO a -> IO a
01:09:22 <Saizan> that looks like just "flip catch"
01:10:07 <elliott> quicksilver: hmm, I guess that'll involve a top-level unsafePerformIO newIORef to keep track of the maximum id... gross
01:10:17 <elliott> or, well, a StateT over my entire program, but that's even grosserer
01:10:24 <Saizan> also, C.E.catch and C.E.try are mostly to be used separately, catch alone is already doing what try/catch constructs do in python or java
01:10:31 <cheater_> Saizan: what's flip catch?
01:10:46 <Saizan> ?type flip catch
01:10:47 <lambdabot> forall a. (IOError -> IO a) -> IO a -> IO a
01:10:48 <opqdonut> catch with arguments the other way around
01:10:55 <Saizan> ?type flip Control.Exception.catch
01:10:56 <lambdabot> forall a e. (GHC.Exception.Exception e) => (e -> IO a) -> IO a -> IO a
01:11:00 <cheater_> oh ok.
01:11:26 <accel> ?type catch
01:11:27 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
01:11:30 <accel> ?type handle
01:11:31 <lambdabot> forall (a :: * -> * -> *) e b ex. (ArrowError ex a) => a e b -> a (e, ex) b -> a e b
01:11:50 <quicksilver> elliott: nothing gross about StateT over your whole program.
01:11:58 <elliott> quicksilver: it is when it's for one single Int.
01:12:03 <quicksilver> elliott: no, it's not.
01:12:07 <elliott> that only needs to exist because of an implementation detail :)
01:12:12 <Saizan> accel: i was referring to Control.Exception.catch and Control.Exception.handle
01:12:24 <quicksilver> it's not an implementation detail, it's a design choice.
01:12:32 <quicksilver> all the bits of code which use IORefs have to be in IO as well
01:12:40 <quicksilver> putting them in a custom monad is a natural idiom.
01:12:40 <accel> Saizan: they're different from catch/handle ?
01:12:49 <elliott> quicksilver: The fact that you can't implement a decent Ord IORef in GHC is an implementation detail
01:12:52 <accel> I've only started reading about exceptions today.
01:12:54 <quicksilver> sure.
01:13:09 <quicksilver> but putting all your IO code in a custom monad is an entirely natural choice.
01:13:09 <Saizan> accel: they are different from the ones in scope in lambdabot's ?type
01:13:21 <elliott> If there was such an instance, I'd need no state at all; what I'm trying to define now is my own Ref type that /does/ have such an instance.
01:13:28 <elliott> I find the top-level unsafePerformIO stomachable because it's basically a workaround.
01:15:15 <accel> would it be better if it was named unicornsAndRainbowsUnsafePerformIO ?
01:15:59 <elliott> accel: Undoubtedly.
01:18:13 <accel> handleJust requires a function to specify whether it can handle the exception
01:18:20 <Saizan> it'd be better to be able to parametrize your module by a (maxid :: IORef ID) -- no hack, explicit dependency, no StateT all over your IO
01:18:26 <accel> is there a way to make this work without handleJust
01:19:00 <Saizan> what is "this"?
01:19:09 <accel> "this" = handling of exceptions
01:19:14 <accel> http://book.realworldhaskell.org/read/error-handling.html#errors.exceptions
01:19:17 <accel> involves the use of handleJust
01:19:30 <accel> and handleJust requires specifying a function that tests whether the exception can be tested
01:20:10 <Saizan> use handle rather than handleJust?
01:20:19 <accel> but then I get hit with all the exceptions
01:20:24 <accel> rather than just the one I should be handling
01:20:39 <accel> i.e. if the handler is of type
01:20:45 <accel> BlahException -> IO()
01:20:50 <MatrixFrog> is there a simple haskell equivalent to "start = getCurrentTime(); doSomeAction(); print getCurrentTime() - start"
01:20:58 <accel> then handle should be able to know that it only handlles BlahException
01:21:01 <MatrixFrog> just to get a rough idea of how long a function takes
01:21:01 <accel> even if I don't specify it, no?
01:21:10 <Saizan> accel: that's exactly how it works, in fact
01:21:19 <accel> lol
01:21:21 <MatrixFrog> (like the python timeit module if anyone is familiar with python...)
01:21:23 <accel> why does handleJust exist then?
01:21:31 <Saizan> accel: handleJust is for when you want a finer grained selection than types provide
01:22:34 <accel> Saizan: noted. Thanks.
01:23:52 <Saizan> MatrixFrog: "do start <- getCurrentTime; doSomeAction; end <- getCurrentTime; print (end - start)" works
01:24:01 <Saizan> hackage might have a lib for it though
01:24:20 <MatrixFrog> it seemed likely that it would, yeah...
01:24:23 <Saizan> ?index getCurrentTime
01:24:23 <lambdabot> bzzt
01:24:30 <MatrixFrog> ?index time
01:24:30 <lambdabot> bzzt
01:24:32 <Saizan> ?hoogle getCurrentTime
01:24:33 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
01:24:33 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
01:24:35 * MatrixFrog shrugs
01:24:56 <Saizan> MatrixFrog: http://hackage.haskell.org/package/timeit
01:25:17 <MatrixFrog> so i should have just literally thought "maybe it has the exact same name as the python version"
01:25:22 <MatrixFrog> :-/ obvious in retrospect. thanks
01:26:34 <colah> Can I have a multi-part definition of a function (eg. fib 0 = 1; fib 1 = 1...) in a let/where staement?
01:26:43 <colah> I can't seem to get the syntax to work.
01:27:15 <c_wraith> colah: yes.
01:27:26 <c_wraith> colah: you just need to indent properly
01:27:34 <Saizan> they must be aligned vertically
01:27:49 <Saizan> and overall be indented more than let/where
01:28:14 <colah> Ah, I was putting the first one on the same line as the let/where. Probably my mistake.
01:28:15 <accel> how do I tell *.cabal "-XDeriveDataTypeable" ?
01:29:48 <ivanm> accel: IIRC there's an extension field
01:30:00 <ivanm> accel: though IMHO it's better to put LANGUAGE pragmas at the top of files
01:30:02 <Saizan> colah: you can do that, but the other "fib .." lines must still be aligned with that
01:30:03 <c_wraith> accel: do you have a reason not to just put a LANGUAGE pragma in the file?
01:30:26 <Saizan> colah: tabs sometimes make you and ghc disagree on what's aligned or not though :)
01:30:35 <edgar> elliott: Can't you derive an unique value, which is an instance of ord,  from the data in the ioref?
01:30:57 <elliott> edgar: I am not sure what you mean.
01:30:59 <accel> ivanm, c_wraith: yep, got it working via. extensions:
01:36:06 <edgar> elliott: Just a thought, I am not sure, what kind of data you have. But it would be nice if you could make a hash function for your data and store the key from that into a wrapped tuple together with the ioref.
01:36:25 <quicksilver> edgar: but he doesn't want an Ord instance which works on the data.
01:36:31 <quicksilver> edgar: he wants it to work on the IORef
01:36:40 <quicksilver> so that he can store IORefs in Maps, etc.
01:44:25 <Saizan> also, the data in the IORef is likely to change
01:54:53 <bob31> I was just reading hutton's excellent book as an intro to haskell
01:55:12 <bob31> and wondered how the base case in the trivial factorial definition is reached
01:55:34 <bob31> how do I have to dissect the following
01:55:57 <bob31> factorial (n+1) = (n+1) * factorial n
01:56:12 <bob31> usually one subtracts 1 to reach the base case
01:56:27 <bob31> maybe I should run this in that stepwise eval service
01:56:36 <sipa> it uses the n+k pattern
01:56:58 <bob31> sipa: I see that, just couldn't find the explanation
01:57:23 <zygoloid> bob31: f (n+k) = ... desugars to: f n' | n' >= k, n <- n' - k = ...
01:58:09 <zygoloid> (where n' is a unique name invented for exposition)
01:59:01 <mercury^> Oh, so f(n+0) = ... is different from f(n) = ...
02:00:16 <ion> Stepwise eval service?
02:00:35 <bob31> zygoloid: thanks, but I haven't learned some of the stuff you use in there, will eventually
02:00:42 <bob31> zygoloid: I get the basic idea
02:01:08 <bob31> zygoloid: will find a definition and read, surprised this is just thrown at you in hutton's book
02:01:29 <zygoloid> bob31: it's also worth noting that your example is not legal in modern haskell
02:01:37 <zygoloid> the n+k patterns feature has been removed from the languange
02:01:48 <bob31> oh
02:01:52 <bob31> I'm using 7.0.4
02:01:59 <bob31> hadn't tried to run that though
02:02:19 <bob31> just started reading chapter 6 and wondered about the evaluation of that
02:02:45 <bob31> https://sites.google.com/site/haskell/notes/nkpatterns
02:02:53 <zygoloid> iirc 7.0.4 defaults to Haskell98 not to Haskell2010.
02:03:18 <bob31> what's the replacement in hs2010?
02:03:33 <sipa> not using it
02:03:39 <zygoloid> bob31: http://stackoverflow.com/questions/3748592/what-are-nk-patterns-and-why-are-they-banned-from-haskell-2010
02:04:37 <zygoloid> n+k patterns are an ugly way to let us pretend that we have a Natural type. :)
02:04:45 <bob31> thx, will read, AFK for a lil bit
02:14:03 <accel> whoa
02:14:06 <accel> proper exception handling
02:14:10 <accel> makes Haskell code so elegant
02:18:21 <accel> is there a way to write the following as a single line?
02:18:22 <accel> parseSpace = do x <- many1 (oneOf " ") return ()
02:18:28 <accel> parseSpace = do x <- many1 (oneOf " ")\n return ()
02:19:09 <Twey> parseSpace = do x <- many1 (oneOf " "); return ()
02:19:15 <accel> lol
02:19:20 <accel> there's no way to do some type of lifting
02:19:26 <accel> or >>= , or >>, or something else?
02:19:42 <Twey> ‘Lifting’?  That's not lifting
02:19:46 <Twey> You can write it without the do-notation, sure
02:19:58 <Twey> parseSpace = many1 (oneOf " ") >> return ()
02:20:12 <Twey> parseSpace = () <$ many1 (oneOf " ")
02:20:13 <Twey> Also
02:20:23 <Twey> oneOf " " = char ' '
02:20:41 <Twey> parseSpace = () <$ many1 (char ' ')
02:20:56 <ivanm> fmap (const ()) $ many! (oneOf " ")
02:21:01 <ivanm> s/!/1/
02:21:10 <Twey> Same thing :þ
02:22:32 <Twey> accel: ‘Lifting’ is usually when you convert an action from one monad type to another, like (Monad m1, Monad m2) => m1 a -> m2 a
02:22:35 <Twey> :t liftIO
02:22:36 <lambdabot>     Ambiguous occurrence `liftIO'
02:22:36 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
02:22:36 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
02:22:47 <Twey> :t Control.Monad.Error.liftIO
02:22:47 <lambdabot> forall a (m :: * -> *). (Control.Monad.Error.MonadIO m) => IO a -> m a
02:23:01 <zygoloid> accel: for parser combinators i use this a lot: ignore x = x >> return ()
02:23:40 <Twey> ‘ignore x’ is no shorter than ‘() <$ x’ :þ
02:23:56 <zygoloid> sure, but i find it much more readable :)
02:24:02 <Twey> Haha, alright
02:24:45 <zygoloid> i think i've just not figured out the logic which makes the <$ operators consistent and mnemonic
02:25:05 <zygoloid> (i'd expect there to be some rule which ($), (<$), (<$> and ($>) all conform to)
02:27:52 <ion> :t void
02:27:53 <lambdabot> Not in scope: `void'
02:27:56 <accel> yeah, I find "ignore x" more readable too
02:27:57 <ion> :t Control.Monad.void
02:27:58 <lambdabot> Not in scope: `Control.Monad.void'
02:28:59 <ion> @hoogle void
02:28:59 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
02:29:00 <quicksilver> zygoloid: <$ and <* follow the convention that the arrow points to the return value
02:29:14 <quicksilver> I mean, the arrow points to the bit which is actually return
02:29:28 <zygoloid> @type (<*)
02:29:29 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
02:29:33 <quicksilver> char '(' *> expression <* char ')'
02:29:35 <ion> @hoogle Control.Monad.void
02:29:36 <lambdabot> No results found
02:29:37 <ion> huh
02:29:41 <jonkri> i'm looking at writing the pseudo code from http://tools.ietf.org/html/rfc3492#section-6 in haskell. is there something i should keep in mind when going from imperative programming like this to haskell?
02:29:50 <quicksilver> ^^ parse your bracketted expressions returning the sam thing as expressions.
02:29:54 <ion> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html#v:void
02:32:30 <zygoloid> quicksilver: i see, that's quite nice. so the trick is to pretend they're unrelated to <$> and <*> :)
02:33:49 <quicksilver> zygoloid: right. They are certainly unrelated in my mental model.
02:34:04 <quicksilver> zygoloid: but "return x <* blah" == "x <$ blah"
02:34:42 <quicksilver> and the $/* distinction is consistent. (for *-operators, both parameters are in the applicative)
02:34:58 <bob31> zygoloid: thx again. got it. so hutton's and other books are the reason this was kept in hs98 :)
02:35:13 <quicksilver> (... while "return f <*> blah" == "f <$> blah" )
02:35:22 <ion> x <$ blah = const x <$> blah = pure (const x) <*> blah = pure x <* blah
02:35:50 <Twey> jonkri: That you can't?  Just reimplement the algorithm — don't try to translate.
02:36:06 <jonkri> Twey, ok
02:37:45 <jonkri> thanks
02:53:05 <Cale> jonkri: actually, you can translate pretty straightforwardly
02:53:15 <Cale> one sec while I do it :)
02:53:21 <quicksilver> haskell is the best imperative language I know.
02:53:47 <Cale> You can translate to some simple mutually recursive pure functions
02:53:51 <Cale> and then simplify the result
02:55:47 <jonkri> ok :)
02:56:34 <Cale> (I'm being distracted by some other things, though...)
02:57:25 <jonkri> no rush :)
02:59:10 <ciaranm> http://learnyouahaskell.com/input-and-output#randomness the randomRs example: is the :: [Char] at the end useless?
02:59:22 <accel> does haskell support polymorphic functions? something where "foo" is either "Foo -> Int" or "Bar -> String" ?
02:59:31 <accel> I just want to overload the name of a function
02:59:34 <accel> and have it dispatch
03:00:05 <stroan> type classes with functional dependencies will get you that
03:00:57 <quicksilver> type classes are normally a clumsy solution if you are just looking for name overloading.
03:01:11 <quicksilver> but they're a good solution if the overloading really does describe some common feature.
03:02:39 <ivanm> hmmm.... should I use local within my Reader monad or just pass the values around?
03:02:48 <accel> will tyep classes allow me to say:
03:03:06 <accel> only "Foo -> Int", "Bar -> String"; ... but not allow "Foo -> String" and not allow "Bar -> Int"
03:03:39 <stroan> http://www.haskell.org/haskellwiki/Functional_dependencies
03:04:01 <quicksilver> accel: Yes.
03:04:12 <accel> stroan, quicksilver : reading link; thanks.
03:04:15 <quicksilver> using associated types
03:04:21 <quicksilver> or functional dependencies.
03:04:44 <hpaste> Cale pasted “mechanical translation” at http://hpaste.org/48704
03:05:27 <Cale> This is an extremely baroque translation though, and there's a lot of obvious things we can start doing to simplify it
03:05:43 <Cale> (now that its imperative nature is all gone)
03:06:08 <Cale> We can combine f5 and f6
03:06:31 <Cale> by substituting the definition of f6 into f5
03:06:35 <lunaris> @check \(a, b) -> (a == b)
03:06:36 <lambdabot>   "OK, passed 500 tests."
03:06:49 <Cale> @check \(a, b) -> (a == b :: Int)
03:06:49 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
03:06:56 <Cale> @check \(a, b) -> (a == (b :: Int))
03:06:57 <lambdabot>   "Falsifiable, after 0 tests:\n(3,1)\n"
03:07:13 <lunaris> I'm afraid I'll have to take your first answer, lambdabot.
03:07:42 <lunaris> @scheck \(a, b) -> (a == b)
03:07:43 <lambdabot>   "OK, passed 500 tests."
03:07:54 <lunaris> @lscheck \(a, b) -> (a == b)
03:07:55 <lambdabot>   "OK, passed 500 tests."
03:08:02 <hpaste> Cale annotated “mechanical translation” with “mechanical translation (annotation)” at http://hpaste.org/48704#a48705
03:08:34 <Cale> and now we can eliminate f5 in the same way
03:08:49 <Cale> (by plugging its definition into f4)
03:09:16 <jonkri> Cale, interesting :)
03:09:16 <hpaste> Cale annotated “mechanical translation” with “mechanical translation (annotation) (annotation)” at http://hpaste.org/48704#a48706
03:09:28 <Cale> and f7 :)
03:09:50 <hpaste> Cale annotated “mechanical translation” with “mechanical translation (annotation) (annotation) (annotation)” at http://hpaste.org/48704#a48707
03:09:53 <jonkri> do you mind contributing this to https://github.com/jonkri/punycode?
03:10:04 <Cale> I don't mind
03:10:11 <Cale> (as long as to don't have to do anything :)
03:10:19 <Cale> I don't*
03:10:46 <Cale> f3 is easy to eliminate too
03:11:12 <jonkri> do you mind creating a github patch that i can pull? (you can update the Cabal and README files with your name if you want to)
03:11:36 <hpaste> Cale annotated “mechanical translation” with “mechanical translation (annotation) (annotation) (annotation) (annotation)” at http://hpaste.org/48704#a48708
03:11:46 <jonkri> i'm thinking it would be easier to see where the code is coming from, but perhaps it's not necessary
03:12:11 <Cale> You can treat this code as public domain.
03:13:04 <Cale> also now, we can notice that nothing past f1 actually depends on firsttime, though it didn't go out of scope in the imperative code
03:13:50 <hpaste> Cale annotated “mechanical translation” with “mechanical translation (MOAR ANNOTATION)” at http://hpaste.org/48704#a48709
03:14:25 <Cale> and f4 doesn't really depend on numpoints either
03:15:05 <hpaste> Cale annotated “mechanical translation” with “mechanical translation (MOAR ANNOTATION!)” at http://hpaste.org/48704#a48710
03:15:53 <jonkri_> sorry, got disconnected
03:16:03 <Cale> there's a couple more annotations now
03:16:27 <Cale> removing extraneous passing around of firsttime and numpoints
03:16:48 <Cale> which though they didn't go out of scope in the imperative code, stopped being relevant halfway through
03:17:09 <jonkri_> hehe ok
03:17:56 <Cale> we can also eliminate f1 trivially, I only introduced it to name the line of the imperative program
03:18:20 <Cale> oh, also f2 is really easy to remove
03:18:20 <accel> z: Prelude.head: empty list
03:18:26 <accel> when I run my program "z", I get:
03:18:26 <accel> z: Prelude.head: empty list
03:18:33 <Cale> well...
03:18:35 <accel> is there a way to get haskell to print out a stack trace?
03:18:56 <Cale> accel: Not in quite the way you mean it
03:19:05 <Cale> There's not really a stack, as such
03:19:20 <Cale> (the evaluator doesn't work like a strict evaluator)
03:19:21 <accel> can I get the list where the functions are expanded/evaluated
03:19:25 <Cale> but yeah...
03:19:28 <accel> that brings to the place where the head is called
03:19:31 <accel> how do I get that?
03:19:35 <Cale> you can try compiling with -prof -auto-all
03:19:39 <jonkri_> Cale, how would you take care of the stateful variables, such as skew?
03:19:45 <Cale> er  -rtsopts
03:19:48 <Cale> too
03:19:52 <Cale> (that one is new :)
03:19:59 <Cale> and then run the program with +RTS -xc
03:20:03 <Cale> on the commandline
03:20:22 <Cale> jonkri_: they become a parameter to anything which depends on them
03:20:37 <Cale> jonkri_: If there are a lot of them, you can bundle them up into a record datatype
03:21:46 <accel> z build-all +RTS -xc
03:21:50 <accel> doesn't quite work
03:22:23 <jonkri_> Cale, where did the while go? :P
03:23:18 <Cale> jonkri_: I used the specification of a while loop while translating the program initially
03:23:38 <Cale> If you look at the very first translation
03:23:49 <Cale> f4 tests the while condition
03:24:01 <Cale> and if it is true, the next step of the program is f5
03:24:09 <Cale> and if not, then the next step is f7
03:24:28 <Cale> and at the end of the while loop, f6
03:24:41 <Cale> the next step is to test the while condition, which is f4
03:24:51 <jonkri_> aha
03:26:07 <jonkri_> Cale: do you mind creating a github patch that i can pull? (you can update the Cabal and README files with your name if you want to). i'm thinking it would be easier to see where the code is coming from, but perhaps it's not necessary
03:26:14 <Cale> I don't know how to do that
03:26:25 <Cale> (never used github before)
03:26:32 <Cale> or git, for that matter
03:26:36 <jonkri_> me neither, i just started with it :)
03:26:43 <jonkri_> got to say that i absolutely love github though
03:26:59 <edwardk> github just works =)
03:27:00 <Cale> You don't even have to give me credit for that code. I only acted mechanically in its construction.
03:27:12 <jonkri_> edwardk, exactly :)
03:27:14 <Cale> Credit the Network Working Group
03:27:16 <Cale> ;)
03:27:18 <Cale> lol
03:27:34 <jonkri_> ok :)
03:28:06 <jonkri_> thanks Cale :)
03:44:59 <hpaste> “Ben Gamari” pasted “Type class instancing confusion” at http://hpaste.org/48711
03:45:24 <hpaste> Jafet annotated “mechanical translation” with “Really mechanical translation” at http://hpaste.org/48704#a48712
03:45:31 <hpaste> “Ben Gamari” annotated “Type class instancing confusion” with “Type class instancing confusion (error)” at http://hpaste.org/48711#a48713
03:46:07 <bgamari> Could someone comment on what is wrong with my instance declaration?
03:46:16 <bgamari> It seems I'm not understanding kinds correctly
03:47:50 <Saizan> Iter takes 2 arguments but you've given only one to it
03:48:19 <quicksilver> also, you can't usefully write class instances like that
03:48:24 <accel> why is the type of deepseq not "b->b", and instead is: Control.DeepSeq deepseq :: NFData a => a -> b -> b
03:48:30 <quicksilver> even if you fix the arguments to be right.
03:48:36 <accel> why is it a -> b -> b
03:48:53 <Saizan> ?type seq
03:48:53 <lambdabot> forall a t. a -> t -> t
03:49:06 <quicksilver> instance-schemes of the form "any member of class x is also a Functor" are not encodable in core haskell
03:49:16 <quicksilver> and overlapping instances might appear to allow it but it's a bit broken really.
03:49:47 <quicksilver> the best thing to do is make Functor a superclass of Iter.
03:49:51 <Saizan> that implementation of fmap wouldn't typecheck anyhow
03:50:11 <quicksilver> and define a 'defaultIterFmap" that people can use to write the instance.
03:59:17 <wli> Calling glpk over a pipe or something is needed to prevent pollution of stdout/stderr.
04:04:37 <accel> http://www.haskell.org/cabal/users-guide/ <-- I see that there is a --enable-executable-profiling. However, how do I stick it in a *.cabal ?
04:05:17 <ivanm> accel: you don't
04:05:24 <accel> okay
04:05:29 <ivanm> you _can_ specify ghc-prof-options
04:05:35 <accel> how do I build an app with --enable-executable-profiling?
04:05:42 <accel> I tried sticking a "-prof" in ghc-options:
04:05:47 <accel> but it tells me to use --eanble-executable-profiling
04:05:47 <ivanm> but you have to specify at the configure stage that you actually want to enable profiling
04:05:57 <ivanm> accel: cabal install --enable-executable-profiling
04:06:19 <ivanm> and in the .cabal file, have: ghc-prof-options: -prof -auto-all -caf-all
04:06:23 <ivanm> (or whatever flags you want)
04:07:45 <luite> wli: or calling glp_term_out(0)? does that still let some messages through?
04:08:14 <wli> luite: Unclear what you're on about.
04:08:33 <luite> glpk function
04:08:58 <luite> are you using a separate glpk executable?
04:09:56 <wli> luite: No, the glpk-hs library.
04:11:30 <luite> oh that one is terribly broken, don't use it
04:11:45 <luite> it gives the wrong results
04:11:52 <wli> luite: What do I do, then?
04:12:28 <luite> I've mailed the author to fix it, but he doesn't reply to mail. I should actually update the hackage package and let it fail with a big fat warning or something like that
04:12:36 <luite> hmatrix-glpk works
04:13:00 <luite> glpk-hs can claim to have found an optimal solution even when the problem is infeasible
04:14:02 <luite> it calls the glpk preprocessing, and when the preprocessor doesn't say that the problem is infeasible, then it just assumes the end result will always be an optimal solution
04:14:38 <luite> so it's kind of tricky to find it, you have to make a non-trivially infeasible instance to catch this bug :p
04:16:20 <Choko> http://pastebin.com/zuyHFe3T <- Network.Socket.ByteString.Lazy don't have an export function on windows, is this a known issue?
04:16:22 <mauke> The paste zuyHFe3T has been copied to http://hpaste.org/48714
04:16:45 <wli> luite: Does hmatrix-glpk pollute stdout/stderr?
04:17:01 <luite> I don't think it does
04:17:02 <Choko> it's version 2.3.0.4
04:17:12 <luite> and it has a much simpler api than glpk-hs
04:19:20 <wli> luite: I'm trying to do Remez-like affairs, cf. http://proxima.lp0.eu/~wli/BestRat.{lhs,bib,pdf}
04:26:32 <wli> luite: Do you know of 1D optimization libs that don't have nasty runtime issues like calling abort(3) on nonconvergence or polluting stdio?
04:27:04 <beate> Alright, so most Cabal-Packages have documentation/description included. How to "browse" that documentation? (Sorry, I'm very new to Haskell)
04:28:18 <luite> wli: hmm, does hmatrix-glpk still do that? I use it as a subroutine in my own non-linear (quasiconvex) solver and it seems to work fine
04:28:41 <wli> luite: I can't plug it in quite that fast.
04:29:35 <wli> luite: What I've got thus far is reimplementing 1D optimization because the Brent lib I know of calls abort(3) on nonconvergence/etc.
04:30:36 <jonkri_> Cale: i found this to be most intuitive for me: https://github.com/jonkri/punycode/blob/master/Data/Text/Punycode.hs ... ugly?
04:31:09 <jonkri_> disregard the State record :)
04:31:29 <luite> wli: hmm, I've never used Brent's method in haskell, so I have no idea, sorry
04:34:32 <Cale> jonkri_: seems fine
04:34:55 <Cale> jonkri_: Yeah, if you make those parameters into a record, remember the RecordWildCards extension :)
04:35:08 <jonkri_> ok, will check it out :)
04:35:19 <wli> luite: I'll vaguely be attempting something on the order of sequential linear programming or something.
04:36:03 <Cale> http://www.haskell.org/ghc/docs/6.12.3/html/users_guide/syntax-extns.html#record-wildcards
04:36:37 <jonkri_> Cale, just what i was reading. thanks! :)
04:37:07 <Cale> wli: I read that too quickly and it ended up as "sesquilinear programming" in my head for a moment :)
04:37:54 <Cale> not quite a googlewhack, there are three results for it :)
04:39:36 <Cale> I love how once you get to a certain point in maths, you can just make up technical terms and chances are there are people who study that thing.
04:44:50 <roconnor> Cale: do they study it under the name you made up?
04:46:31 <Cale> roconnor: Well, I don't know, there's at least a book which includes the "sesquilinear programming problem"
04:46:44 <roconnor> :)
04:48:09 <Cale> It's among a list of problems based arond positive definite matrices which are NP-hard
04:48:15 <Jafet> They had to make up the term too; your chances aren't bad
04:50:34 <Wooga> hello, i am writing own haskell parser
04:50:49 <Wooga> can i relay on that all root expressions are on 0 column always?
04:50:53 <Wooga> rely*
04:51:10 <Jafet> Parsing Haskell?
04:51:12 <Wooga> yes
04:51:15 <Wooga> for indenting
04:51:36 <Jafet> Why not use haskell-src?
04:51:51 <Wooga> it's emaks i am writing for
04:51:52 <Jafet> To answer your question: no
04:51:54 <Wooga> emacs*
04:52:01 <Wooga> ah, okay
04:52:04 <Jafet> There's already a haskell-mode that you could look at.
04:52:05 <Wooga> thanks for answering
04:52:12 <Wooga> yes, it is not enough for me
04:52:23 <Cale> Apparently it's the problem of determining whether sup over Z in the n-dimensional closed unit disc of |Z^H A Z| < 1, where A is a given n-by-n real positive definite matrix, and Z^H is the conjugate transpose.
04:52:47 <Jafet> I think Manatee is also doing something related for emacs
04:53:10 <luite> Wooga: I think you can assume that they're in the same column, but not necessarily the first
04:54:25 <Cale> oh, errr
04:54:27 <Jafet> I've never actually seen any code indent past zero, though.
04:54:47 <Jafet> Maybe some lhs-formatted code
04:54:55 <opqdonut> lhs definitely
04:55:04 <luite> I didn't even know this until I started playing with haskell-src-exts to rename haskell modules :)
04:55:12 <Cale> maybe I mis-worded that, it's Z in (closure of D)^n, where I take it D is the unit disc in C.
04:56:15 <dicey> wow, didnt think this channel would be so popular
04:56:54 <Axman6> why not?
04:56:57 <Cale> It's popular because it has a tendency to be quite friendly :)
04:56:59 <luite> but it seems to be really tricky to make minor changes (such as renaming the module) to a haskell source file, while retaining the existing layout as much as possible
04:56:59 <Axman6> we're lovely
04:57:17 <dicey> are you guys n00b friendly?
04:57:21 <luite> very!
04:57:23 <Cale> and it's probably friendly because everyone remembers what it's like to be a beginner at Haskell :)
04:57:25 <Axman6> dicey: it's imo one of the most helpful and friendly channels on the Internet
04:57:26 <Jafet> If the n00b is friendly to us
04:57:32 <Axman6> we love noobs!
04:57:55 <Axman6> Cale: it's like AA like that
04:58:05 <dicey> im learning haskell as my first real attempt to learn a language. i was forced to dabble in others in the past, but im hoping to be able to make some sizable code in this one!
04:58:13 <Cale> cool! :)
04:58:30 <Axman6> dicey: what languages have you used already?
04:58:42 <dicey> mathematica, matlab
04:59:06 <Axman6> they're both pretty terrible languages -_-
04:59:13 <Axman6> matlab can be cool at times though
04:59:20 <Cale> Mathematica can be cool too
04:59:22 <dicey> i think they serve a purpose...but they aren't generic languages
04:59:31 <Axman6> (especially if you never code in matlab, and only use simulink >_>)
04:59:34 <Jafet> Mathematica has some neat symbolic programming, but it's too ad-hoc to facilitate thinking
04:59:35 <dicey> there are things i think i will always use mathematica for above all else.
04:59:44 <Axman6> they're also just not nice languages imo
05:00:01 <Jafet> Syntactically, they're pretty terrible
05:00:12 <Jafet> But isn't that true of most languages?
05:00:25 <dicey> axman: if you need some quick solutions to some differential equations, integrals, etc, mathematica is probably one of the quickest possible ways
05:00:30 <Axman6> they're kinda like Java in a way, the language isn't great, but there's a hell of a lot of work done by other people so you don't have to
05:00:30 <hpc> it's certainly true of the non-general purpose ones
05:00:31 <Cale> I like Mathematica's syntax. It's just M-expressions along with some fanciness that translates into M-expressions.
05:00:35 <dicey> but i guess then its just using it as a glorified calculator
05:00:38 <Axman6> dicey: agreed
05:00:52 <osfameron> can you use haskell for mathematica-like things?
05:01:00 <hpc> osfameron: most definitely
05:01:01 <kingping> mapM_ hello haskell
05:01:12 <osfameron> I mean, are there libraries to facilitate that kind of thing?
05:01:14 <hpc> it just takes work to reimplement things
05:01:15 <dicey> if you had an extensive module library on hand...i suppose
05:01:19 <Cale> If you're conservative about how much you use Mathematica's funny infix operators for things like Map and Apply, then programs will look nice.
05:01:22 <Axman6> dicey: so how are you learning haskell? are you reading LYAH?
05:01:31 <dicey> yes
05:01:36 <luite> osfameron: step 1: implement Risch algorithm in haskell, step 2: profit
05:01:36 <Axman6> excellent start
05:01:37 <hpc> oh, there's currently a summer of code project to build a mathematica-ish haskell lib
05:01:40 <Jafet> Mathematica isn't a language as much as it's a massive collection of symbolic and numerical methods
05:01:47 <Cale> also, stick to functional programming in Mathematica
05:01:49 <Axman6> dicey: please feel free to ask questions whenever there's something confusing
05:01:53 * osfameron looks up "Risch algorithm"
05:02:03 <luite> osfameron: it's for indefinite integration
05:02:08 <Axman6> we will do our best to clear it up for you with examples and clear explanations
05:02:09 <hpc> it's the closest algorithm yet to indefinite integration
05:02:13 <Axman6> and by we, i mean Cale
05:02:17 <Jafet> Comparing it to other languages invariably gives you the answer “yes, but you have to reimplement Mathematica“
05:02:18 <Axman6> but everyone else will try
05:02:31 <hpc> once you get past the arithmatic operators, the problem becomes intractable
05:02:33 <dicey> im already confused tbh! on one of the earlier pages he defines a "sum" function, but in the text file it seems to need to be defined as "sum
05:02:40 <dicey> "sum'" instead of just "sum"
05:02:44 <hpc> er, non-total rather
05:02:48 * osfameron looks up indefinite integration ;-)
05:02:52 <dicey> and i cant figure out way
05:02:54 <dicey> why*
05:03:01 <Axman6> dicey: yeah, sum is already defined in the standard prelude
05:03:02 <kingping> dicey: ' doesn't make a function anything special.
05:03:14 <hpc> dicey: sum' is just a different name from sum
05:03:16 <osfameron> (my dad is a mathematicician.  I once tried to show him haskell, but I think he was more comfortable with Matlab)
05:03:25 <Axman6> foo and foo' and f'o'o' are all valid names for functions in haskell
05:03:30 <dicey> but if its already defined in prelude, why cant i call on it?
05:03:33 <kingping> dicey: ' is just used as any other letter.
05:03:34 <hpc> dicey: it's a somewhat nicer way of saying "other_sum" vs "sum"
05:03:35 <Cale> dicey: probably because sum is already defined in the Prelude, and they don't want name collisions
05:03:41 <luite> osfameron: invite him to this channel!
05:03:49 <Axman6> dicey: what do you mean you can't call it?
05:03:58 <Cale> dicey: It's common while learning the language to implement a lot of the basic libraries for yourself :)
05:04:07 <dicey> it doesnt work until after i define my own sum.
05:04:18 <Cale> > sum [1..10]
05:04:19 <lambdabot>   55
05:04:29 <kingping> dicey: Are you using something different than GHCi ?
05:04:46 <NTU> who uses haskell anymore?
05:04:51 <Cale> We do
05:04:52 <dicey> so if it does work, why am i implementing it!? ><
05:05:01 <dicey> NTU: big investment banks, it seems =p
05:05:05 <NTU> isnt haskell like old?
05:05:10 <kingping> dicey: To learn how to implement FUNCTIONS.
05:05:12 <osfameron> so, indefinite integration is the process of finding "antiderivatives".  But I can't guess why that's useful/necessary for doing what mathematica does.  This is why I'm not a mathematician I uess
05:05:17 <benmachine> NTU: C is like twice as old, at least
05:05:21 <osfameron> yeah, nobody uses OLD things anymore
05:05:23 <NTU> oh!
05:05:24 <benmachine> people still (inexplicably :P) use that
05:05:27 <kingping> dicey: It's like hello world function.
05:05:27 <hpc> java is older too, i think
05:05:29 <Cale> NTU: It's a lot younger than a lot of much more popular languages.
05:05:35 <hpc> perl is old
05:05:48 <hpc> fortran is ancient, and still gets used for number-crunching
05:05:49 <Cale> and it's still changing
05:05:58 <Cale> (if you count GHC extensions)
05:06:01 <hpc> lisp is a fucking dinosaur
05:06:05 <NTU> can haskell be used to write drivers?
05:06:14 <Cale> @protontorpedo
05:06:14 <lambdabot> on the haskell site they compare haskell to a spreadsheet
05:06:14 <luite> osfameron: well it's probably one of the more difficult things to get right, differentiation is much simpler
05:06:17 <NTU> like a usb wireless driver
05:06:33 <Axman6> dicey: implementing things that are already defined is useful because a) it gets you used to the syntax used, and b) it lets you test against the already defined functions to make sure you get the same result
05:06:42 <Cale> NTU: Well, there have been operating systems written in Haskell
05:06:52 <Cale> NTU: It's a bit of an unconventional thing to do
05:06:52 <hpc> haskell has been used to write kernels
05:07:01 <hpc> once that's done, drivers are old hat
05:07:20 <NTU> so haskell is like low level?
05:07:23 <hpc> no
05:07:25 <Axman6> no
05:07:28 <Axman6> it's very high level
05:07:30 <luite> haskell is all levels!
05:07:36 <benmachine> haskell can be used for low level stuff in theory, but it's not really designed for it
05:07:37 <Axman6> but you can do some low level stuff if needed
05:07:39 <Cale> It can describe low-level computations
05:07:50 <dicey> haskell is functional, which kind of takes it outside of the "level" universe, does it not?
05:08:01 <hpc> haha
05:08:06 <kingping> NTU: You could, for example, use FFI to call low level stuff.
05:08:12 <benmachine> dicey: being functional is kind of a high-level thing I reckon
05:08:35 <dicey> but i read that haskell has assembly built-in
05:08:42 <Axman6> no...
05:08:42 <Cale> ummmm...
05:08:53 <aavogt> @hackage harpy
05:08:53 <lambdabot> http://hackage.haskell.org/package/harpy
05:08:55 <Cale> Yeah, not really. There are some libraries for that.
05:08:55 <Axman6> but there are packages that let you write ASM
05:09:01 <Axman6> harpy is the one i was thinking of
05:09:08 <hpc> it has an hs -> core -> asm -> binary compilation pipeline
05:09:13 <hpc> perhaps that's what you are thinking of?
05:09:34 <dicey> so you can write a piece of code that generates asm
05:09:38 <dicey> so not exactly built in
05:09:45 <Axman6> dicey: anyway, these are details that are distracting you from reaching haskell zen!
05:09:46 <Cale> yeah, and run it immediately after :)
05:09:48 <kingping> dicey: Anyway the code is run on CPU with Turing architecture which understands assembler.
05:09:54 <hpc> there's also Habit
05:10:06 <hpc> which aims to be an extremely low-level mod of haskell
05:10:07 <Axman6> hpc: is that on hackage?
05:10:17 <Axman6> ah, maybe not?
05:10:17 <hpc> Axman6: don't think it's even done yet
05:10:24 <kingping> So hasskell code needs to be converted to some sort of low level assembler code.
05:10:27 <Axman6> heh, i see. got a link?
05:10:39 <Axman6> kingping: not necessarilly, it can be interpreted
05:10:44 <hpc> http://lambda-the-ultimate.org/node/4205
05:10:44 <Cale> Haskell makes a really lovely assembler for writing low-level programs. :)
05:10:54 <Cale> or special purpose compilers
05:10:56 <hpc> Axman6: ^ preliminary report
05:11:16 <hpc> haskell makes awesome compilers, in general
05:11:29 <hpc> it's rather telling that perl6 was first compiled by haskell
05:11:39 <kingping> Axman6: Yeah. LISP machine! :-)
05:11:46 <Axman6> well, you should say can be fairly easilly used to make awesome compilers
05:11:54 <Axman6> kingping: or just GHCi...
05:11:59 <hpc> the saying used to be "only perl can parse perl"
05:12:04 <flux> hpc, also, that perl was likely part of your first ghc.. ;-)
05:12:10 <dicey> it seems a ton of the popular compilers were at the very least prototyped in a functional language
05:12:12 <hpc> and now it seems not even perl is up to the task, and they need haskell :P
05:12:14 <flux> uh, I meant to say 'ghc building process'
05:12:23 <hpc> flux: :D
05:12:28 <kingping> Axman6: Don't .hs modules first compiled to some sort of C code?
05:12:38 <Axman6> no
05:12:48 <Axman6> the C backend is deprecated (and now removed i believe)
05:12:54 <kingping> nice
05:13:04 <Axman6> but you don't need to compile to C to run haskell programs
05:13:06 <hpc> kingping: they get compiled to core, which is a wonky haskell-ish language that only exists for GHC to do transformations on
05:13:16 <hpc> then it compiles to asm, then binary
05:13:18 <Axman6> you can interpret like python or ruby... but better >_>
05:13:28 <osfameron> Axman6: why better?
05:13:43 <hpc> http://en.wikipedia.org/wiki/Glasgow_Haskell_Compiler#Architecture
05:13:48 <Axman6> can't I talk shit if I want to? :(
05:13:52 <osfameron> ;-)
05:14:06 <kingping> hpc: Eventually, binary. :)
05:14:10 <Axman6> I have no idea, though it is handy that GHCi can use compiled code
05:14:35 <Cale> osfameron: because there's no GIL, for one
05:14:39 <hpc> ghci produces bytecode i thought?
05:14:46 <hpc> oh, USE
05:14:55 <hpc> yeah, <3 ghci
05:15:18 <osfameron> Cale: heh, that' s python wart, right?  that's not especially linked to the capability as an *interpreter* though is it?
05:15:28 <dicey> how do i save what i have done in ghci?
05:15:30 <Cale> well, sure
05:15:45 <Axman6> dicey: you write it in a file. you'll probably get to that soon in LYAH
05:15:45 <hpc> dicey: copy-paste?
05:15:56 <dicey> i've been doing both, axman.
05:16:07 <kingping> dicey: Usually, we write scripts (*.hs) and then load them with :load somescript.hs in GHCi.
05:16:12 <hpc> ^
05:16:15 <Cale> I thought the comment was basically that Haskell's interpreter is better at interpreting Haskell than Python's interpreter is at interpreting Python.
05:16:21 <hpc> i keep a ghci open and i keep the code file open
05:16:24 <dicey> so you dont really write in ghci ever, you just poke around.
05:16:32 <hpc> then when i make changes, save the file and :r in ghci
05:16:33 <Axman6> i read an article the other day where someone was proposing that pypy used STM to avoid the GIL... but that seems amazingly difficult to me, how do you know what to make a transaction?
05:16:39 <hpc> (:r = reload)
05:16:52 <Axman6> dicey: you use ghci for testing your code interactively
05:17:56 <dicey> makes sense.
05:18:03 * osfameron wishes ghci could do :t for partly compiled code
05:18:10 <dicey> axman: are you working on any big projects?
05:18:19 <Axman6> not at the moment
05:18:25 <osfameron> e.g. when there's an error in a certain function, you can't then :t another function that actually compiled
05:18:30 <osfameron> (which would sometimes be useful)
05:18:46 * hpc wishes ghci could :t while ignoring type signatures
05:19:02 <hpc> so you write foo :: X -> X = id
05:19:13 <hpc> :t foo -> X -> X
05:19:14 <lambdabot> parse error on input `->'
05:19:14 <dicey> what's an id?
05:19:16 <osfameron> hpc: so you could compare the imposed sig, and the one ghc would have given had you not annotated?
05:19:21 <hpc> :tt foo -> x -> x
05:19:23 <hpc> or whatever
05:19:31 <Axman6> dicey: id is just a function that takes anything and returns it
05:19:34 <Axman6> > id 1
05:19:34 <lambdabot>   1
05:19:40 <Axman6> it's short for identity
05:19:44 <hpc> osfameron: but that requires editing the file, reloading, then editing again
05:19:45 <Axman6> > id "Hello"
05:19:46 <lambdabot>   "Hello"
05:19:47 * hpc is lazy
05:19:49 <hpc> @src id
05:19:50 <lambdabot> id x = x
05:19:57 <dicey> that looks like it takes a function from a space x and returns an element from a space x??
05:20:03 <dicey> takes an element*
05:20:13 <Cale> yeah
05:20:14 <dicey> but i dont see why it would have to be the identity function
05:20:15 <Cale> :t id
05:20:16 <lambdabot> forall a. a -> a
05:20:18 <dicey> so im confused
05:20:20 <Cale> um
05:20:27 <Cale> It's like writing  id(x) = x
05:20:31 <Cale> id x = x
05:20:51 <dicey> oh i see, it's because X isn't a type
05:21:00 <Cale> I don't understand hpc's original comment though
05:21:07 <dicey> x is a specific thing.
05:21:11 <Cale> yeah
05:21:16 <Axman6> yeah, hpc wasn't doing anything... that makes much sense :P
05:21:16 <sipa> dicey: if i tell you i have a fully specified function that maps an element from any domain to an element of that domain itself
05:21:18 <Cale> id :: a -> a
05:21:19 <osfameron> hpc: yeah, that's more or less my problem.  fun2 doesn't like the value that fun1 gave it, but I can't do :t fun1 without commenting out fun2 and resaving/reloading it
05:21:24 <sipa> dicey: can that be anything else than the identity function?
05:21:26 <Martty> > :t id id
05:21:27 <lambdabot>   <no location info>: parse error on input `:'
05:21:32 <Martty> :t id id
05:21:33 <lambdabot> forall a. a -> a
05:21:34 <Cale> this also kind of tells you that id must be the identity function (or undefined)
05:21:58 <Cale> because it's so polymorphic that the identity is the only defined thing it could be
05:22:01 <hpc> dicey: "id :: a -> a" means what you said; it takes a value from space 'a' to a value in space 'a'
05:22:05 <dicey> yes, it could
05:22:11 <dicey> because it could return something like the empty set
05:22:13 <dicey> a lot of the time
05:22:24 <hpc> dicey: "id x = x" is the definition itself, which says take a value x, and return it
05:22:28 <Axman6> there's only a few functions that can fulfil that type: id x = x, id x = undefined, and id x = id x (there's more, but those are the obvious ones)
05:22:29 <sipa> dicey: that requires the domain to be one of sets, you don't know it is
05:22:46 <Jafet> Well, the latter two are equivalent
05:22:50 <Cale> Axman6: those are the only three up to isomorphism :)
05:22:52 <dicey> well in most cases you would be looking at families of domain that satisify certain rules
05:22:59 <sipa> dicey: yes, of course
05:23:00 <dicey> usually one of which is that it contains an element like the empty set, or 0
05:23:01 * Axman6 wins
05:23:17 <sipa> dicey: but that's the point here: there is no restriction at all on what the type a is
05:23:19 <hpc> Axman6: the three values are id x = x, id x = undefined, and id = undefined
05:23:29 <hpc> (assuming the presence of seq)
05:23:30 <Cale> > let f x = f x in f `seq` 0
05:23:30 <lambdabot>   0
05:23:35 <Cale> > let f x = undefined in f `seq` 0
05:23:35 <lambdabot>   0
05:23:40 <Cale> oh
05:23:43 <Cale> > let f = undefined in f `seq` 0
05:23:44 <lambdabot>   *Exception: Prelude.undefined
05:23:45 <dicey> sipa: are you telling me you could define a function in that sense in haskell, and haskell could deduce t would be the identity function?
05:23:49 <dicey> because that would just blow my mind
05:23:56 <sipa> dicey: no it can't
05:23:58 <Cale> oh, yeah, he did leave the parameter in
05:24:01 <hpc> dicey: it can't, but other tools can
05:24:04 <hpc> @djinn x -> x
05:24:05 <lambdabot> f a = a
05:24:16 <Axman6> oh yeah, didn't think of id = undefined
05:24:17 <Cale> id x = id x is semantically the same as id x = undefined, but different from id = undefined
05:24:23 <hpc> djinn takes a type signature and produces a usually-useless function
05:24:34 <sipa> but it's quite restricted
05:24:38 <Jafet> @. pl djinn a -> a
05:24:38 <lambdabot> f = id
05:24:46 <Cale> If you start counting different error messages / forms of nontermination, then there are lots
05:24:53 <hpc> there's also @free which gives you free theorems for types
05:24:59 <hpc> but that's even more restricted
05:24:59 <Axman6> @djinn a -> Maybe a -> a
05:24:59 <lambdabot> f a b =
05:24:59 <lambdabot>     case b of
05:24:59 <lambdabot>     Nothing -> a
05:24:59 <lambdabot>     Just c -> c
05:25:09 <Cale> dicey: yes :)
05:25:24 <Cale> dicey: Extremely polymorphic functions are possible to infer from their types in Haskell
05:25:40 <hpc> (djinn and free aren't part of ghci, sadly)
05:25:51 <lunaris> @. pl djinn a -> Maybe a -> a
05:25:51 <lambdabot> (line 3, column 13):
05:25:51 <lambdabot> unexpected ">" or "-"
05:25:51 <lambdabot> expecting variable, "(", operator or end of input
05:26:07 <sipa> theoretically possible, yes - but there is nothing in the language haskell that does so
05:26:09 <Cale> Oleg did some typesystem magic to make an equivalent of djinn available
05:26:26 <Cale> (though you can't see the source for the function, you just get the function)
05:26:28 <Cale> iirc
05:26:34 <hpc> heh, of course
05:26:41 <Axman6> heh
05:26:48 <sipa> right, Oleg
05:27:01 <Axman6> obviously it sends the type to Oleg and he writes the function
05:27:05 <dicey> cale: what about you? got any big haskell projects going?
05:27:39 <Cale> I'm working for a company called iPwn Studios on an RPG for iPhones and other mobile devices
05:27:41 <Cale> in Haskell
05:27:49 <dicey> that's awesome!
05:28:03 <Axman6> oh right, i forgot you worked with blackh
05:28:33 <dicey> out of boston! no kidding. you're nearby.
05:28:53 <Cale> http://www.haskell.org/pipermail/haskell/2005-March/015423.html
05:30:00 <Cale> I'm in Brantford, Ontario though
05:30:46 <Twey> Oleg scares me
05:31:02 <wli> luite: Added some linear programming stuff at http://proxima.lp0.eu/~wli/BestRat.{lhs,bib,pdf}
05:31:09 <hpc> preflex: seen oleg
05:31:09 <preflex>  oleg was last seen on #perl 187 days, 14 hours, 19 minutes and 21 seconds ago, saying: pragma_, sure
05:31:13 <hpc> :(
05:33:38 <Cale> dicey: Constructing a definition from a type is formally the same thing as constructing a proof from a theorem. (Just with different logical systems in place :)
05:34:07 <MHD> Where can I find/has there ever been implemented a Parsing Arrow library based on Swierstra/Duponcheel persers?
05:34:51 <hpc> Cale: that's the most intuitive explanation of the C-H Isomorphism i have ever seen
05:35:29 <MHD> hpc: I agree.
05:35:48 <hpc> @remember Cale Constructing a definition from a type is formally the same thing as constructing a proof from a theorem. (Just with different logical systems in place :)
05:35:48 <lambdabot> Okay.
05:36:07 <Cale> Haskell's type system can be thought of as a sort of intuitionist logic (which happens to be inconsistent, necessarily so for Turing completeness), with an interesting semantics for the proofs.
05:36:23 <Cale> :t fix
05:36:24 <lambdabot> forall a. (a -> a) -> a
05:36:51 <Cale> ^^ this thing is both what makes it inconsistent as a logic, and what gives it lots of computational power
05:36:54 <Axman6> why is it inconsistent?
05:36:59 <Cale> :t fix id
05:37:00 <lambdabot> forall a. a
05:37:06 <Cale> ^^ everything is provable
05:37:19 <Cale> (but that's a boring proof)
05:37:27 <Eduard_Munteanu> Axman6: wrt theorem provers
05:37:53 <dicey> if everything is provable
05:37:56 <dicey> then that's bad
05:37:57 <Eduard_Munteanu> Oops, he said "as a logic".
05:37:59 <dicey> so sayeth godel
05:38:20 <Cale> dicey: Well, it's bad also in that some programs don't terminate
05:38:30 <hpc> for a really mind-bending trip down that particular rabbit hole, there's a good series on how it applies to multiple worlds on sigfpe's blog
05:38:42 <MHD> Axman6: Intuitionistic logic lacks the law of the excluded middle.
05:38:54 <MHD> That's why it's inconsistent.
05:39:00 <Axman6> bleh, there's a reason i didn't like that course
05:39:03 <Cale> dicey: It's the price we pay for general recursion.
05:39:06 <MHD> (that is compared to proposistional logic)
05:39:30 <dicey> a price will always be paid.
05:39:32 <dicey> godel said that too, lol
05:39:48 <quicksilver> MHD: no; lacking the law of the excluded middle doesn't make you inconsistent.
05:39:52 <dicey> you cant get away from all the logical ruts. some of them will always haunt you
05:39:58 <dicey> no matter what framework you work in or how you define it
05:40:04 <Cale> There are some consistent logics with fairly powerful programming models which aren't quite Turing complete. You can encode proofs of termination in the types and get away with a lot.
05:40:13 <MHD> quicksilver: Then my immediate understanding of it is wrong :)
05:40:14 <quicksilver> what makes haskell inconsistent is recursion.
05:40:20 <MHD> oh right
05:40:29 <quicksilver> MHD: inconsistent means you can prove everything.
05:40:36 <Axman6> dicey: if you like this sort of stuff, you'll like haskell :)
05:40:41 <companion_cube> MHD: sorry, is intuitionistc logic inconsistent ?
05:40:49 <companion_cube> is there a proof of that ?
05:40:52 <MHD>  Not it's not
05:40:54 <dicey> axman: im a math guy. thats why i chose haskell.
05:41:01 <MHD> I'm just 30 hours sleep deprived
05:41:09 <hpc> dicey: (if you aren't into that sort of stuff, you can easily still like haskell, but #haskell will sometimes be over your head :P)
05:41:26 <Cale> dicey: But since our primary interest is in programming and not truth, we don't care that every type is a true theorem, we're more concerned about all the ways in which it's true, because two proofs of the same thing at that level can have very different semantics.
05:41:47 * Axman6 often finds haskell over his head, but is still comfortable programming in haskell
05:42:10 <hpc> if haskell never gets over your head, you aren't trying;)
05:42:20 <Cale> (yeah, I've been putting things in terms that I think dicey would enjoy, since he seemed to be a math person :)
05:42:26 <dicey> that interests me greatly, cale. my goal is actually to make a program that attacks programs right along those same lines. but thats likely very very far away...
05:42:30 <Axman6> or you're name's simon or oleg
05:42:32 <dicey> attacks problems*
05:42:34 <quicksilver> Cale: well, also, we can identify a consistent subset of haskell's logic and we generally work in that part, although it need not be easy to prove that we do in some cases.
05:42:47 <Cale> companion_cube: Not all intuitionist logics are inconsistent. There are consistent ones.
05:42:58 <Cale> quicksilver: yes, that too
05:43:12 <hpc> usually when you want consistency, you wil just use agda or coq
05:43:20 <Eduard_Munteanu> I think Agda + excluded middle is just fine.
05:43:21 <hpc> "just" :P
05:44:02 <Cale> dicey: How much category theory have you run into?
05:44:30 <dicey> i know algebra
05:44:36 <dicey> i didnt study category theory like, specifically
05:44:43 <dicey> but it comes up enough so that i have a working knowledge
05:44:51 <dicey> i can push arrows around on paper, if you know what i mean
05:44:53 <Cale> okay, so there's a concept of a Cartesian closed category
05:46:28 <Eduard_Munteanu> Algebra is a good start for CT.
05:46:35 <hpc> ^
05:46:37 <Cale> The lambda calculus that functional programming languages are based around can be viewed as a syntax for constructing maps in arbitrary CCCs, of which the categories of types and functions in programming languages are one sort of example, and logical systems are another
05:46:50 <Eduard_Munteanu> (abstract algebra specifically)
05:47:48 <Cale> In Haskell, we tend to like this connection to category theory, and have started looting CT for ideas on how to structure libraries :)
05:48:51 <Cale> :t fmap
05:48:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:49:01 <MHD> I have mady my first library
05:49:22 <MHD> Not sure about releasing it.
05:49:35 <Cale> (we have a typeclass for endofunctors on the category of types -- f is the object part of the functor here, and fmap is the arrow part)
05:49:36 <Eduard_Munteanu> MHD: what is it?
05:49:45 <Cale> > fmap (*10) [1..10]
05:49:46 <lambdabot>   [10,20,30,40,50,60,70,80,90,100]
05:49:50 <Cale> > fmap (*10) (Just 17)
05:49:51 <lambdabot>   Just 170
05:50:14 <Cale> Container types are a good example of functor :)
05:50:19 <MHD> Eduard_Muntenau: It's a type class hack to allow deriving definitions of Functor and Applicative from Monad.
05:50:49 <MHD> Reducing those 9-10 lines of recurring code to a one liner.
05:51:00 <mike-burns> Why wouldn't you release it?
05:51:09 <hpc> another good example of functor:
05:51:26 <hpc> > let f = fmap (+2) (*2) in f 3
05:51:27 <MHD> mike-burns: dunno
05:51:27 <lambdabot>   8
05:51:36 <Eduard_Munteanu> Doesn't Monad already imply Functor?
05:51:46 <hpc> @src Monad
05:51:47 <lambdabot> class  Monad m  where
05:51:47 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
05:51:47 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
05:51:47 <lambdabot>     return      :: a -> m a
05:51:47 <lambdabot>     fail        :: String -> m a
05:51:50 <hpc> nope
05:51:51 <Cale> (that would be called the (covariant) Hom functor in most math contexts)
05:51:52 <MHD> Eduard_Munteau: No.
05:52:00 <Cale> Eduard_Munteanu: sadly
05:52:08 <hpc> it implies the existence of a functor and an applicative, but doesn't require them
05:52:09 <Eduard_Munteanu> Ah, right, I forget.
05:52:44 <MHD> With my library it is only "instance AutoderiveMonad <your monad>" away
05:53:09 <parcs> MHD: does your library use undecidable instances?
05:53:25 <MHD> parcs: Yes, is that bad?
05:53:25 <parcs> if not i'm interested in how it works
05:54:10 <Eduard_Munteanu> Can't GHC derive some of those with extensions?
05:54:40 <MHD> Maybe
05:55:01 <parcs> MHD: overlapping instances too?
05:55:12 <MHD> parcs: No
05:55:13 <Eduard_Munteanu> Ah, there's DeriveFunctor
05:55:28 <Eduard_Munteanu> (no Applicative in 6.12.3 AFAICT)
05:55:41 <dicey> cale: yes, i understand maps and types/typeclasses. its all very natural. using them so errors and stuff dont come up and describing to the frigging compiler exactly what i want is another matter =p
05:55:50 <dicey> but at least i understand the theory behind it
05:55:50 <MHD> my library also let's you specify a Join function for Applicatives and Functors, thus making monads
05:55:58 <Eduard_Munteanu> Though it probably doesn't derive it from an existing Monad instance.
05:56:01 <Cale> dicey: :)
05:56:22 <Cale> dicey: I've had typeclass-related errors catch some very interesting bugs at compile time before.
05:56:51 <Cale> It's usually better than letting the program run and then fail and having no idea what's wrong :)
05:56:53 <Eduard_Munteanu> (which I'm not sure it matters, at least if your type indeed obeys Monad laws)
05:57:01 <Eduard_Munteanu> *type's instance
05:58:20 <hargettp> good morning!  question: if one has defined a function "foo", and one wants to pass that function into another function called "bar" and in that function apply "foo" to some other value--how to express that in Haskell?
05:58:21 <Cale> dicey: Oh, another nice example of a functor is IO. In Haskell, we have for each type t, a type (IO t) of I/O performing actions that construct a result of type t. For example, getLine :: IO String, can be thought of as a description of something which could be done to get a String
05:58:26 <hargettp> I know how it works in Lisp...not sure here :)
05:58:58 <Cale> dicey: and for any function a -> b, we have a corresponding function IO a -> IO b, which just post-applies that function to the result of the IO action.
05:59:13 <dicey> i know very little of what "IO" means in pretty much, any context
05:59:18 <dicey> that is something that is not natural to me
05:59:35 <Cale> hargettp: bar foo
05:59:38 <jonkri> is an haskell String utf8 or unicode?
05:59:40 <Axman6> :t let f g = g 10 in f
05:59:41 <lambdabot> forall t t1. (Num t) => (t -> t1) -> t1
05:59:42 <Cale> hargettp: bar f = ... use f here ...
05:59:52 <Axman6> :t let bar g = g 10 in bar
05:59:53 <lambdabot> forall t t1. (Num t) => (t -> t1) -> t1
05:59:53 <MHD> jonkri: Haskell is UTF32 internally.
06:00:13 <Axman6> 32? i thought it used 16...
06:00:15 <jonkri> cool
06:00:21 <Axman6> or... something else
06:00:22 <dicey> wouldn't it just be bar (foo a)??
06:00:33 <MHD> every char is a boxed 32/64 bit machine word
06:00:41 <Cale> dicey: Well, just think of values of type IO t as being like source code for a program that might be run to crank out a result of type t (and which can have any effect that any program on your computer could have)
06:00:45 <MHD> at least in GHC.prim
06:01:07 <Axman6> dicey: possibly, but the question was pretty ambiguous
06:01:32 <Axman6> hargettp: can you give a lisp example so we can be more sure what you want?
06:01:35 <Cale> dicey: *evaluating* a value of type IO t won't do much (just as looking at the source code in a text editor won't cause it to run)
06:02:00 <dicey> so IO is kind of like a string, or something?
06:02:14 <dicey> it has no context unless i give it to it
06:02:17 <Cale> Well, this is an analogy, but if it helps. :)
06:02:20 <hargettp> Ah, I forgot that since the signature of bar has a function as an argument...foo will be "passed in" correctly as a function parameter
06:02:35 <MHD> hargettp: bar = \f x -> f x; foo = \x -> x + 1; bar foo 143
06:02:36 <Cale> It's an abstract description of some stuff to be performed to get some result value.
06:02:49 <MHD> hargettp: First class functions?
06:02:50 <Cale> that can have arbitrary input and output effects
06:03:05 <hargettp> (mapcar #'1+ `(1 2 3))
06:03:08 <monadic> Cale: Unless that evaluation includes unsafePerformIO :)
06:03:18 <Axman6> so you in this case want map...
06:03:23 <hargettp> In Lisp, syntax makes it clear that #'1+ is a function literal
06:03:25 <Axman6> > map (+1) [1,2,3]
06:03:25 <Cale> monadic: I don't think of unsafePerformIO as part of the language
06:03:25 <lambdabot>   [2,3,4]
06:03:29 <MHD> hargettp: map (+1) [1,2,3]
06:03:36 <monadic> Cale: Personally I consider it as part of the FFI
06:03:41 <MHD> damnit, ninja'd
06:03:45 <monadic> Cale: Never seen a use for it outside of foreign bindings
06:03:46 <hargettp> I guess in haskell the signature of bar ensures that foo would be treated as a function, as needed
06:03:50 <hargettp> ty!
06:03:50 <Cale> (it's a hook we use in place of modifying the compiler)
06:03:56 <parcs> MHD: if you're using UndecidableInstances, why not just do 'instance Monad m => Functor m, instance Monad m => Applicative m' instead of (i presume) 'instance AutoderiveMonad m => Functor m ...'?
06:04:12 <Axman6> hargettp: the type foo ensures that it is a function...
06:04:24 <Cale> :t readFile
06:04:25 <lambdabot> FilePath -> IO String
06:04:26 <MHD> parcs: because it interferes with all other functor definitions?
06:04:29 <Cale> :t getLine
06:04:30 <Axman6> there's no ambiguity about the types of things in compiling haskell programs
06:04:30 <lambdabot> IO String
06:04:33 <monadic> parcs: I think that requires OverlappingInstances or IncoherentInstances
06:04:34 <Cale> :t putStrLn
06:04:35 <lambdabot> String -> IO ()
06:04:43 <Cale> ^^ () is the empty tuple type there
06:04:44 <parcs> monadic: neither
06:04:45 <MHD> parcs: You also might want to have a monad that is not a functor.
06:05:04 <dicey> i think it will be quite a while before i grok "IO," i have no knowledge of computer science truly, only maths.
06:05:10 <monadic> parcs: If you have instance list Functor and insance Monad m => Functor m I don't think Undecidable is enough
06:05:20 <parcs> MHD: how does your way not interfere with all other Functor definitions?
06:05:37 <parcs> monadic: it also requires FlexibleInstances
06:05:49 <MHD> parcs: you declare it for each monad as such "instanc AutoderiveMonad <name of your monad>"
06:05:52 <monadic> parcs: Yes, but thats not what I mean ^_^
06:05:54 <Axman6> dicey: IO is interaction with the world outside your program in general, input and output. so printing things, reading files, displaying things on the screen. things that are not IO are computation
06:06:16 <Cale> dicey: Anyway, you should be able to see how this is a functor, in that if we have a function A -> B, and an IO action of type IO A, we should conceptually be able to apply the function to the result of the action to get an action of type IO B
06:06:16 <Axman6> (not that IO isn't also computation, but it's not a terrible way to think about it)
06:06:42 <parcs> MHD: oh, i see what you mean.
06:07:09 <parcs> monadic: what do you mean, then?
06:07:12 <Cale> which means that we should have a way to take a function A -> B, and get a function IO A -> IO B
06:07:12 <MHD> parcs: i can not count how many times I have made those same "fmap = liftM"
06:07:14 <dicey> but how do i know the type of what IO spits out?
06:07:25 <dicey> since i have no control over it
06:07:29 <Axman6> yes you do
06:07:31 <Cale> dicey: types are compile-time things
06:07:31 <MHD> dicey: IO t <- the t is the type
06:07:39 <Axman6> you cam complete control, using the type system
06:07:57 <Axman6> cam? have*
06:08:01 <Cale> and so any value of type IO t is required to produce a value of type t as its result when executed
06:08:04 <Axman6> wtf is up with my typing tonight
06:08:05 <Jafet> @vixen you have cam?
06:08:06 <lambdabot> No sorry. I'm not that technically advanced :)
06:08:16 <Axman6> heh
06:08:24 <dicey> so i force the restriction of type when i define what i want from the IO
06:08:24 <Axman6> not a mechanic then
06:08:27 <MHD> is there anything Lambdabot doesn't do?
06:08:33 <dicey> and if it returns something that isnt valid, it just errors
06:08:41 <MHD> @vixen is there anything you can't do?
06:08:41 <lambdabot> i think i can...
06:08:46 <Cale> dicey: yeah, the compiler enforces it when it compiles the program
06:08:50 <Axman6> dicey: it can't return something that isn't valid, or it won't compile
06:09:06 <MHD> Axman6: technically, there's bottom
06:09:11 <Cale> dicey: It checks that the description of the action you write is something that will produce a value of the right type when executed
06:09:12 <MHD> and IO _|_
06:09:13 <dicey> axman: say IO just asks a human sitting at the computer for an even number, but you type in an odd number
06:09:35 <Axman6> well, invalid from a type point of view, whether the value is erroneousis another matter
06:09:43 <homie> @vixen what's your name?
06:09:43 <lambdabot> My name is Emily
06:10:16 <Axman6> dicey: that's got nothing to do with the type. the compiler will guarantee that if the number asking function returns, it will give your code a number
06:10:17 <parcs> monadic: ah, i see. the overlapping instance error only occurs when an instance is actually needed to type check
06:10:27 <Axman6> or undefined, but let's not talk about that for now
06:10:32 <Cale> dicey: Oh, well, I guess my description of IO actions is somewhat inadequate, yes, in that one of the things they can do is to produce an exception and not return a result.
06:10:58 <Cale> dicey: another option is that our IO action has type  IO (Maybe Integer), say
06:11:01 <Twey> < MHD> parcs: You also might want to have a monad that is not a functor. — I don't think that's possible
06:11:10 <Cale> and it produces Nothing in the case that the result doesn't parse as an even integer
06:11:26 <dicey> hahaha, Nothing.
06:11:36 <Cale> and Just n in the case that it parses as n
06:11:53 <Cale> :t Nothin
06:11:53 <lambdabot> Not in scope: data constructor `Nothin'
06:11:54 <Cale> :t Nothing
06:11:54 <lambdabot> forall a. Maybe a
06:11:56 <Twey> Every monad is a functor: fmap f = (>>=) (return . f)
06:11:57 <Cale> :t Just
06:11:58 <lambdabot> forall a. a -> Maybe a
06:12:10 <Cale> > [Nothing, Nothing, Just 5, Just 7, Nothing]
06:12:11 <lambdabot>   [Nothing,Nothing,Just 5,Just 7,Nothing]
06:12:34 <Axman6> @src Maybe
06:12:34 <lambdabot> data Maybe a = Nothing | Just a
06:13:00 <Axman6> something of type Maybe a is either Nothing or Just with something of type a in it
06:13:07 <dicey> :t Maybe
06:13:08 <Axman6> that
06:13:08 <lambdabot> Not in scope: data constructor `Maybe'
06:13:13 <Cale> :k Maybe
06:13:14 <Axman6> that's what that definition says
06:13:14 <lambdabot> * -> *
06:13:16 <dicey> Damn
06:13:26 <Cale> Maybe is something in the world of types
06:13:29 <Axman6> Maybe is a type, it's values are Nothing and Just a
06:13:35 <Cale> (so it has a kind, rather than a type ;)
06:13:42 <Axman6> @src either
06:13:42 <lambdabot> either f _ (Left x)     =  f x
06:13:43 <lambdabot> either _ g (Right y)    =  g y
06:13:47 <Axman6> uh
06:13:48 <ion> Maybe is a type constructor </nitpick>
06:13:49 <Axman6> @src Either
06:13:50 <lambdabot> Source not found. Just try something else.
06:13:54 <Axman6> wut
06:13:58 <dicey> so Maybe is basically a glorified boolean where one of the values is a special stop/skip
06:14:07 <Axman6> data Either a b = Left a | Right b
06:14:11 <Cale> value -> type -> kind (-> sort -> ... no conventional name ...)
06:14:27 <MHD> So what's a kind's sort?
06:14:39 <Axman6> Cale: reminds me of the derivatives of displacement, going to snap, crackle and pop
06:14:40 <Cale> dicey: Yeah, a boolean where the True has a value attached to it :)
06:14:46 <Jafet> acceleration -> jerk -> snap -> crackle -> pop
06:15:01 <Eduard_Munteanu> Twey: hrm, but can it obey Monad laws and disobey Functor?
06:15:08 * Eduard_Munteanu didn't think much about this
06:15:12 <dicey> so you use maybe as a way of enforcing types?
06:15:16 <Cale> Eduard_Munteanu: no
06:15:30 <Eduard_Munteanu> Ah, I suppose it's fine then.
06:15:30 <Axman6> dicey: if you'd ever done any programming in C or Java say, then you might be able to see that Maybe is haskell's safe way with dealing with possibly null values
06:15:37 <Cale> dicey: Well, we use it as a way of representing the possibility of failure
06:15:47 <Jafet> Every Monad contains a corresponding Functor
06:15:53 <dicey> i got it.
06:16:02 <Jafet> Barring implementation, that is
06:16:05 <dicey> and no axman, never programmed with those languages. although maybe i should have
06:16:14 <Twey> Eduard_Munteanu: I don't think so, no
06:16:20 <Twey> 'cause of said definition
06:16:20 <Axman6> dicey: no. it's good you haven't, you're not broken :)
06:16:27 <Twey> (which obeys the functor laws)
06:16:50 <Axman6> > let safeDiv x y = if y == 0 return Nothing else return just (x / y) in safeDiv 10 3
06:16:51 <Eduard_Munteanu> Actually, that would be "every well-formed Monad can be used to derive a unique well-formed Functor", right?
06:16:51 <lambdabot>   <no location info>: parse error on input `else'
06:17:03 <Axman6> > let safeDiv x y = if y == 0 then Nothing else Just (x / y) in safeDiv 10 3
06:17:03 <lambdabot>   Just 3.3333333333333335
06:17:08 <rndm> dicey: (cringe) c# has something similar called nullable
06:17:11 <Axman6> wow, too much C, and not enough sleep
06:17:12 <Eduard_Munteanu> well-formed = obeys those laws
06:17:16 <Jafet> I'm not sure if the Monads that lead to Functors are the same as the monads that lead to functors, though
06:17:17 <Axman6> > let safeDiv x y = if y == 0 then Nothing else Just (x / y) in safeDiv 10 0
06:17:18 <lambdabot>   Nothing
06:17:41 <Eduard_Munteanu> Yeah, I mean the Haskell "Monad" (uppercase initial)
06:17:46 <Axman6> dicey: does that definition make sense to you?
06:17:52 <dicey> yes
06:18:11 <Jafet> IEEE double is already a glorified compound type
06:18:13 <Axman6> so you can see that we've defined divifing by 0 to be a failure case
06:18:22 <Cale> > let root a b c | disc < 0 = Nothing | otherwise = Just ((-b + sqrt disc) / (2*a)) where disc = b^2 - 4*a*c in root 2 (-1) (-1)
06:18:23 <lambdabot>   Just 1.0
06:18:28 <Cale> > let root a b c | disc < 0 = Nothing | otherwise = Just ((-b + sqrt disc) / (2*a)) where disc = b^2 - 4*a*c in root 2 0 1
06:18:29 <lambdabot>   Nothing
06:18:32 <Jafet> If only there were real constructors for Double
06:19:02 <opqdonut>  heh
06:19:11 <Jafet> Then you can write case a / b of NaN -> ..; Denormal _ -> ..; Double x -> return x
06:19:30 <Axman6> well that could easilly be a library
06:19:32 <Jafet> Er x@(Double _ _ _)
06:19:53 <ion> > let safeDiv x y = do x' <- x; y' <- y; if y == 0 then Nothing else Just (x/y) in (pure 10 `safeDiv` pure 5) `safeDiv` pure 3
06:19:54 <Axman6> that would be a lot more fun actually
06:19:54 <lambdabot>   No instances for (GHC.Real.Fractional (Data.Maybe.Maybe t),
06:19:54 <lambdabot>                ...
06:20:01 <Cale> Oh, right, should probably handle the a = 0 case better too :)
06:20:06 <ion> > let safeDiv x y = do x' <- x; y' <- y; if y' == 0 then Nothing else Just (x'/y') in (pure 10 `safeDiv` pure 5) `safeDiv` pure 3
06:20:07 <lambdabot>   Just 0.6666666666666666
06:20:09 <Cale> but you get the idea
06:20:11 <ion> > let safeDiv x y = do x' <- x; y' <- y; if y' == 0 then Nothing else Just (x'/y') in (pure 10 `safeDiv` pure 0) `safeDiv` pure 3
06:20:12 <lambdabot>   Nothing
06:20:31 <Jafet> :t ala pure
06:20:31 <lambdabot> forall o (f :: * -> *) b n' o'. (Applicative f, Newtype (f o) o, Newtype n' o') => ((o -> f o) -> b -> n') -> b -> o'
06:21:26 <Axman6> Jafet: I'd love to be able to work with Double like that. if it could be done efficiently and still use the hardwar FPU, it would be ideal
06:21:44 <Axman6> seems it shouldn't be impossible to make a compiler do that
06:22:31 <Jafet> Unfortunately, ghc is too generic in that sense
06:22:55 <Jafet> You have a choice of Prim black magic, or the standard data representation
06:23:30 <Jafet> (Or codata, for pedants)
06:24:17 <Eduard_Munteanu> Codata in what sense?
06:24:18 <ion> > let safeDiv = liftA2 $ \x y -> guard (y /= 0) *> pure (x/y) in (pure 10 `safeDiv` pure 0) `safeDiv` pure 3
06:24:18 <lambdabot>   No instance for (GHC.Show.Show (f (f1 (f2 t))))
06:24:19 <lambdabot>    arising from a use of `M...
06:24:34 <ion> err
06:25:02 <benmachine> ion: you're lifting a function of type a -> b -> f c, liftA2 doesn't do that
06:25:06 <benmachine> (can't do that)
06:25:15 <ion> yeah
06:25:43 <Axman6> dicey: anyway, i think we've diverged enough for now. time to get back to learning the basics of haskell's syntax.
06:25:44 <benmachine> you need Monad for that
06:25:53 <benmachine> but I don't quite get why you'd want to lift it anyway :)
06:26:04 <ion> > let safeDiv x' y' = do x <- x'; y <- y'; guard (y /= 0); return (x/y) in (pure 10 `safeDiv` pure 0) `safeDiv` pure 3
06:26:05 <lambdabot>   No instance for (GHC.Show.Show (m t))
06:26:05 <lambdabot>    arising from a use of `M3402219398...
06:26:16 <Cale> I get why ;)
06:26:29 <Cale> You can use join and liftM2 to do it
06:26:31 <benmachine> Cale: yeah I suppose so
06:26:38 * benmachine silly
06:29:44 <ion> > let safeDiv x' y' = do x <- x'; y <- y'; guard (y /= 0); return (x/y) in (Just 10 `safeDiv` Just 0) `safeDiv` Just 3
06:29:45 <lambdabot>   Nothing
06:30:08 <dicey> now the question is, how do i define a function in haskell that takes one version of safediv and outputs a different but equivalent version?
06:31:39 <ion> > let safeDiv x' y' = do x <- x'; y <- y'; guard (y /= 0); return (x/y) in [5,10] `safeDiv` [0,1,2]
06:31:39 <lambdabot>   [5.0,2.5,10.0,5.0]
06:31:48 <lunaris> @pl \x y -> guard (y /= 0) >> return (x / y)
06:31:48 <lambdabot> ap ((>>) . guard . (0 /=)) . (return .) . (/)
06:32:12 <lunaris> :t (join .) . liftM2 (ap ((>>) . guard . (0 /=)) . (return .) . (/))
06:32:13 <lambdabot> forall (m :: * -> *) a. (MonadPlus m, Fractional a) => m a -> m a -> m a
06:32:17 <ion> @pl \y -> guard (y /= 0) >> return (x / y)
06:32:18 <lambdabot> ap ((>>) . guard . (0 /=)) (return . (x /))
06:32:39 <lunaris> > let safeDiv = (join .) . liftM2 (ap ((>>) . guard . (0 /=)) . (return .) . (/)) in (Just 10 `safeDiv` Just 0) `safeDiv` Just 3
06:32:41 <lambdabot>   Nothing
06:33:17 * lunaris has satisfied its curiosity.
06:35:00 <Cadynum> is specifying "ld-options: -mwindows" the same as "Ghc-Options: -optl-mwindows" in the .cabal?
06:35:05 <Axman6> dicey: what do you mean? sounds like you want lisp =)
06:35:35 <dcoutts> Cadynum: yes I think so
06:36:10 <Cadynum> dcoutts, okey, thanks
06:36:24 <roconnor> preflex: seen twanvl
06:36:25 <preflex>  twanvl was last seen on #haskell 1 day, 16 hours, 6 minutes and 59 seconds ago, saying: roconnor: were you looking for me?
06:36:32 <roconnor> heh
06:37:01 <roconnor> preflex: seen copumpkin
06:37:02 <preflex>  copumpkin was last seen on #haskell-blah 1 day, 14 hours, 35 minutes and 57 seconds ago, saying: pretty well :) I get just over 1 coin a day
06:37:33 <Eduard_Munteanu> Heh, indeed everything leads to bitcoins
06:38:09 <dicey> i mean there are often many ways to solve the same problem. my specific interest is taking a known function (or definition if you will) and running a program that uses it to find another version of the same function but constructed differently, hopefully different in a non-trivial way
06:39:07 <ezyang> You will need to have a reified version of the program available to Haskell. We don't have very strong introspection capabilities.
06:39:36 <dicey> reified?
06:40:17 <flux> he means you need to write your own lisp interpreter and programmatically modify programs written in it :)
06:40:43 <dicey> why does lisp become necessary?
06:40:55 * hackagebot binary-state 0.1 - Simple wrapper around Data.Binary, which adds StateT to Get/Put monads.  http://hackage.haskell.org/package/binary-state-0.1 (IlyaPortnov)
06:40:59 <ezyang> Well, here Lisp is being used as an interchangeable term for any simple functional programming language.
06:41:15 <ezyang> esp ones which you didn't put a lot of effort into lexing and parsing.
06:41:38 <portnov> dicey: because of Greenspun's 10th rule? ;)
06:41:50 <Pantaloonix2> Given a well defined function in a FAS can't you just substitute symbol strings an arbitrary number of times and hope you get a sufficiently "different" function construction?
06:42:37 <dicey> pantaloonix, that would probably be something of a starting point
06:42:51 <Axman6> dicey: in lisp, what you write is the abstract syntax tree, and you can use lisp programs to modify their own AST's
06:43:40 <dicey> i read about lisp, axman, and i didnt like the approach of where i keep...redefining the terms im using? i want to approach the problem constructively
06:44:02 <bgamari> quicksilver: What is wrong with my typeclass?
06:44:10 <bgamari> instance
06:44:56 * hackagebot simple-stacked-vm 0.1 - Simple stacked virtual machine: assembler, disassembler, bytecode interpreter  http://hackage.haskell.org/package/simple-stacked-vm-0.1 (IlyaPortnov)
06:45:12 <bgamari> quicksilver: Regarding http://hpaste.org/48711
06:45:44 <bgamari> quicksilver: Does it not make sense to claim that Iters are Functors?
06:45:52 <bgamari> quicksilver: How would I express this relationship
06:46:28 <ezyang> bgamari: Your syntax is wrong.
06:46:48 <ezyang> do instance Functor Iter instead.
06:46:50 <bgamari> ezyang: I understand that Iter requires two type arguments
06:47:18 <ezyang> erm, Functor (Iter it)
06:47:36 <bgamari> ezyang: But Iter is a class
06:47:49 <ezyang> whoops.
06:47:56 * hackagebot simple-pascal 0.1 - Simplified Pascal language to SSVM compiler  http://hackage.haskell.org/package/simple-pascal-0.1 (IlyaPortnov)
06:48:17 <ezyang> then class Functor it => Iter it e, maybe.
06:48:57 <bgamari> ezyang: Nope, then it seems I'm saying a Functor it is an instance of Iter
06:49:02 <bgamari> corr.hs:32:9: `fmap' is not a (visible) method of class `Iter'
06:50:16 <bgamari> I need to do roughly this: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#t:WrappedMonad
06:50:54 <bgamari> It seems the Wrapping might be important here
06:51:07 <bgamari> Is that to make the typing work in the instancing?
06:53:45 <dpotian> are monads and computations synonymous in the haskell community?  that is, if someone is talking about computations, they're talking about monads.
06:53:56 <dankna> mm? not necessarily
06:54:03 <Younder> no
06:54:31 <dankna> I have a personal convention (nobody else uses it, unless they invented it independently!) of using "get" or other verbs as a prefix to names of functions that are monadic computations, and "compute" for other functions
06:54:45 <Younder> monads are a category theorethic concept used to isoled state dependency and volatility
06:54:47 <dankna> that way I know by looking at the name whether it's monadic or not
06:55:45 <dicey> heh, i think im going to learn a lot by osmosis just being in this room
06:56:01 <dankna> yes :)
06:56:02 <dankna> you are
06:56:04 <dankna> it's useful
06:56:33 <Axman6> dicey: you'll find this channel is probably your most valuable resource in learning haskell.
06:57:02 <Axman6> just following along as much as you can will get you thinking about code and the ideas you need to write programs
06:57:12 <Younder> Make that functional programming ..
06:58:37 <Younder> I personally found foldl and foldr the most difficult things to learn to use. Once you know then they are like a swiss army knife.
06:59:18 <dylukes> I read in TaPL the church encoding of lists into the lambda calculus is their folds.
06:59:20 <dylukes> My mind = explode.
06:59:52 <dylukes> right fold specifically.
07:00:18 <dylukes> Though I suppose it makes sense :).
07:00:45 <bgamari> Anyone have input regarding my type class instancing issues?
07:01:39 <bgamari> http://hpaste.org/48711
07:03:09 <bgamari> Why is it that WrappedMonad is a Functor and not Monad itself?
07:05:05 <earthy> bgamari: because Monad is legacy :)
07:05:49 <bgamari> earthy: Really?
07:05:51 <bgamari> How so?
07:06:12 <dicey> isn't monad more than just a functor? but mapping a monad over things would make it, itself, behave like a functor?
07:06:28 <bgamari> I was under the impression that monads were a very important part of the language
07:06:36 <bgamari> earthy: i.e. IO is still a monad
07:07:44 <bgamari> It seems there is a hint here, http://stackoverflow.com/questions/2482136/haskell-applicative-and-errort
07:08:06 <bgamari> unfortunately I don't know what a orphan instance is
07:08:18 <earthy> bgamari: oh, sorry, yeah
07:08:38 <earthy> no, the Monad typeclass is old and does *not* imply a Functor instance
07:08:43 <earthy> WrappedMonad however is a lot newer
07:09:00 <earthy> and does take into account that having a Functor instance actually is kinda nice ;)
07:09:07 <ezyang> bgamari: No, instance Functor f => Foo f is different. It means, in order to declare something of instance Foo, it must already have a Fucntor instance.
07:09:31 <bgamari> ezyang: Right, but I should be able to define the converse, no?
07:09:47 <earthy> instance Monad m => Functor m
07:09:49 <bgamari> ezyang: It would make sense to declare instance Foo f => Functor f in this case
07:09:50 <earthy> you mean
07:09:56 <bgamari> earthy: Right
07:10:08 <bgamari> earthy: Oh, no. We're talking about my code
07:10:15 <ezyang> Well, not really.
07:10:15 <bgamari> earthy: http://hpaste.org/48711
07:10:24 <ezyang> What if whatever you're trying to define as f already has a Functor instance?
07:10:35 <ezyang> Then you've waded into overlapping instances land.
07:10:46 <earthy> bgamari: ah, right, what ezyang says. ;)
07:10:48 <Saizan> even without that case
07:11:24 <bgamari> earthy: I'm definining the Foo typeclass. I have written all of the instances. None of them need their own Functor instance
07:11:32 <Saizan> "instance Foo f => Functor f" overlaps even with instance Functor NotAnInstanceOfFoo, because contexts don't matter
07:11:42 <bgamari> earthy: All of them would share the same the same fmap implementation
07:11:47 <zygoloid> "instance Foo f => Functor f" means "every f is an instance of Functor. it is an error to try to use this instance without an instance Foo f". it does not mean "if f has an instance of Foo then it has an instance of Functor".
07:12:40 <earthy> zygoloid: say what now?
07:12:52 <Saizan> bgamari: basically, you can't declare instances like "instance Foo f => Functor f" because than it becomes hard to guarantee that there's only one possible instance for any type if you're doing modular compilation
07:13:09 <bgamari> Saizan: Hmm. That's unfortunate in my case
07:13:12 <Saizan> *because then
07:14:00 <Saizan> also your implementation of fmap in that paste doesn't make sense
07:15:01 <dicey> i dont see why fmap f it = mapiter it f would return a functor?
07:15:16 <matthiasgorgens> Is there a way to get a call graph (or a graph of `mentioning by name') for a haskell program?
07:15:27 <matthiasgorgens> i.e. which function definition mentions which other function definition?
07:15:33 <bgamari> Saizan: Because I'm returning an object of another outer type than what I started with?
07:15:45 <Saizan> bgamari: yeah
07:15:53 <bgamari> Yeah, I suppose you are right
07:16:23 <bgamari> Do you know how to express the relationship I'm going for?
07:16:49 <dicey> what is the type of mapiter it f?
07:16:51 <dicey> in your program
07:16:54 <bgamari> I'm trying to come up with an abstraction for an object that can be iterated over, e.g. [], Array, Vector, etc.
07:17:11 <bgamari> data MapIter it f = MapIter it f
07:17:31 <earthy> matthiasgorgens: http://hackage.haskell.org/package/SourceGraph
07:17:42 <bgamari> I really think there must be a better way to achieve this
07:17:50 <Saizan> bgamari: Data.Foldable might be what you want?
07:18:13 <bgamari> I really just want to map over a list and ensure that the returned list is not saved in memory
07:18:22 <bgamari> i.e. trade computation for memory
07:18:39 <Saizan> you could just exploit lazyness for that
07:18:42 <dicey> i thought because haskell is lazy you don't have to worry about that anyway
07:18:45 <Saizan> if i'm getting you right
07:19:04 <bgamari> Saizan: I need more than fold though
07:19:12 <earthy> bgamari: there is no way in general to do that, if I understand what you want
07:19:28 <earthy> (because you might use the 'returned' list multiple times)
07:19:50 <Saizan> bgamari: there's toList :: Foldable f => f a -> [a], then you can use that list as you want
07:19:52 <dicey> why would you not want to save the list if you don't want to work with it? if you only need a specifici  value, then lazyness should take care of that automatically? (???)
07:20:01 <bgamari> dicey: As earthy said, if you use the returned list more than once then the GC will keep the mapped list around
07:20:19 <earthy> and you want to prevent that?
07:20:21 <Saizan> just use toList more than once then :)
07:20:32 <bgamari> Because it's being derived from a very large data set
07:21:16 <bgamari> Saizan: heh, I suppose that might work
07:21:47 * earthy still doesn't see the problem... laziness suggests that a fold or a map with a direct consumption of the resulting list only provides constant overhead over the very large data set
07:22:40 <earthy> unless you write something that requires the calculated intermediate result for multiple calculations
07:22:53 <dicey> earthy: as in, members of the list depend on other members of the list
07:22:54 <bgamari> The second reason for my Iter class is to be able to iterate over an unboxed array as one can []
07:22:59 <dicey> that seems like it could pose a problem
07:23:22 <bgamari> earthy: Yes, I might do the latter
07:23:24 <earthy> dicey: for example. but then he wants a Foldable with a strict accumulator
07:23:52 <earthy> then the size of the accumulator provides the bounds of the extra space
07:24:08 <matthiasgorgens> earthy, thanks!
07:25:07 <bgamari> earthy: It would be far better if I could just require the GC to throw away the list elements
07:25:07 <xil> hi. I'd like to create some global state variables but I'm not sure how to go about doing that. OpenGL, for example, has certain global state variables that you can access and set from anywhere, without needing to pass them around
07:25:07 <Saizan> suppose i have a big array ar, if i do "let xs = toList ar in sum xs / length xs" the full xs will be kept in memory while the length is calculated, so i use O(n) more memory than just ar
07:25:53 <Saizan> if i instead do: "sum (toList ar) / length (toList ar)" i use only constant memory more than the one used by the array
07:26:06 <dankna> xil: use StateT from either mtl or transformers
07:26:17 <xil> dankna: thanks
07:26:19 <bgamari> Saizan: I see your point
07:26:38 <bgamari> Saizan: I guess then I just need to write a Foldable instance for Data.Array.Unboxed
07:26:45 * earthy nods
07:27:06 * earthy kinda understands the issue now
07:27:09 <bgamari> earthy: I've so far had great difficulty ensuring my algorithms have sane memory requirements
07:27:34 <earthy> bgamari: ah yes. making sure you don't keep a hold of all the input multiple times can be tricky
07:27:51 <bgamari> Beating down excessive GC time has been by far the most time consuming part of writing code
07:27:58 <bgamari> Yep
07:28:13 <bgamari> It would be nice if the compiler could give you more help
07:29:18 <Saizan> bgamari: you can't write that instance though..
07:29:19 <bgamari> And perhaps the language could allow you to easily make memory/calculation trade-offs with "forgetful" maps, etc.
07:29:21 <earthy> well, there's profiling
07:29:28 <bgamari> Not sure if that is a sane idea or not
07:29:38 <earthy> different kinds of heap profileing
07:29:47 <bgamari> earthy: True, although this isn't always trivial
07:29:59 <earthy> true enough
07:30:33 <bgamari> Saizan: I'd need to write an array iterator type
07:30:39 <bgamari> which would be a foldable instance
07:30:44 <bgamari> i guess
07:31:01 <Saizan> no
07:31:06 <xil> dankna: I'm having a bit of trouble unterstanding how to use this. Do you know of a good resource for helping me with that?
07:31:17 <Saizan> the problem is that Foldable works only if the container is able to hold any type
07:31:24 <bgamari> Ouch
07:31:26 <Saizan> while an unboxed array can't
07:31:36 <bgamari> Yeah
07:31:53 <bgamari> Dealing with real quantities of data efficiently is definitely not haskell's forte it seems
07:31:59 <Saizan> anyhow, just use elems(?) from the Array interface
07:32:03 <earthy> bgamari: not true
07:32:06 <dankna> xil: hmm? well, I don't really know of a good resource because I don't really use tutorial-style material myself, but maybe someone in here does.  to get you started, hopefully, I can at least say:
07:32:07 <bgamari> The algorithms I've written are beautiful
07:32:29 <bgamari> but I really don't think I want to store 10^8 list elements
07:32:37 <earthy> @hoogle Data.Array.elems
07:32:38 <lambdabot> Data.Array.IArray elems :: (IArray a e, Ix i) => a i e -> [e]
07:32:38 <lambdabot> Data.Array.MArray getElems :: (MArray a e m, Ix i) => a i e -> m [e]
07:32:38 <bgamari> in boxed form
07:33:00 <dankna> xil: it's a monad transformer; that is, a thing which "adds" state-ness to an underlying monad (such as IO); the state variables will exist only within the context of that monad, and everything that can access them will have to have a type like ParameterTypeFoo -> ParameterTypeBar -> ThatMonad ReturnType
07:33:05 <earthy> bgamari: then don't. laziness will help. ;)
07:33:05 <Saizan> i don't think anyone is advocating lists for that :)
07:33:26 <dankna> xil: where ThatMonad is a synonym like "type ThatMonad = StateT MyStateRecord IO"
07:33:39 <earthy> but you  *will* need boxes (i.e. pointers ;)) for actually dealing with singular elements of those 10^8
07:33:50 <earthy> just not 10^8 boxes at any one time hopefully ;)
07:33:51 <Saizan> but the list type is haskell's iterator type, though if things don't fuse you might get a bit more overhead than optimal, but should still be a constant
07:34:00 <dankna> xil: you run it by calling runStateT theMonadicActionToPerform theInitialState
07:34:20 <dankna> xil: and then within it, you have access to get :: ThatMonad MyStateRecord, and put :: MyStateRecord :: ThatMonad ()
07:34:21 <bgamari> earthy: The problem here is I need to iterate over these 10^8 elements multiple times
07:34:27 <earthy> so?!
07:34:32 <dankna> xil: does that help?
07:34:46 <bgamari> earthy, Saizan: I guess as long as I call elems multiple times it won't matter
07:34:58 <bgamari> and each list will be lazily constructed
07:34:58 <Jafet> bgamari: RAM prices have gone down quite a bit recently
07:35:10 <xil> dankna: it's definitely something to start with, but in general I'm not very familiar with monads and have never knowingly uncountered a monad transformer. I'll mull it over a bit more while looking at these docs. At least it helps me make more sense of the examples in the docs
07:35:21 <earthy> think about how you'd do it in C:  item[] items; item* item; for (item = items; item != NULL; item++) { do_something_to(item); }
07:35:23 <bgamari> assuming the compiler doesn't do something dumb like replace them with the common subexpression
07:35:29 <earthy> there item is your 'box'
07:35:36 <bgamari> Jafet: True, but memory transactions are still time consuming
07:35:41 <Jafet> GHC is very conservative about CSE for that reason
07:35:44 <dankna> xil: okay, good luck!
07:35:50 <bgamari> Jafet: Good to know
07:35:59 <earthy> you seem to want to make that same explicit restriction to *1* box
07:36:19 <bgamari> earthy: You could say that
07:36:27 <earthy> but I don't quite see why
07:36:37 <Jafet> Usually, though, you end up neither using nor not using CSE, rewriting the algorithm instead
07:36:46 <Jafet> Like the classic sum x / length x
07:36:56 <earthy> as long as you are clear about the boxes you generate and consume
07:38:46 <bgamari> earthy: So you are suggesting that I just use lists and be careful that I don't force the compiler to keep the elements around?
07:38:58 <earthy> bgamari: that
07:39:13 <hpaste> “Ben Gamari” pasted “Correlator” at http://hpaste.org/48715
07:39:28 <bgamari> earthy: That is the algorithm
07:39:33 <earthy> basically, every time you use 'elems', you're indicating 'starting a foreach loop here'
07:39:42 <bgamari> earthy: Fair enough
07:39:58 <bgamari> earthy: So it seems I'm safe since the current test code has reasonable memory usage
07:40:19 <earthy> however, you still need to be careful to actually directly consume it, because otherwise the boxes can accumulate
07:40:30 <bgamari> Hmm, or rather had reasonable memory usage. Seems like I broke something
07:42:08 <bgamari> earthy: Yep
07:44:43 <Saizan> another option would be to use something like the Stream type from stream fusion as the type of iterators instead, that's not going to maintain any sharing.
07:44:59 <Saizan> and it still has an uncons operation
07:45:43 <earthy> the code in that paste its actually using the lists twice...
07:46:24 <bgamari> earthy: Oh?
07:46:37 <earthy> so the lists need to be in memory
07:46:53 <bgamari> earthy: Oh, yes. the second print should be commented
07:47:18 <bgamari> earthy: That was what I broke earlier
07:47:45 <earthy> then the code looks like it could run in constant space
07:48:49 <bgamari> What would the recommended way to store a pile of Datums (defined in my hpaste code) in an unboxed fashion?
07:48:53 <bgamari> earthy: It does
07:49:16 <bgamari> Since Data.Array.Unboxed can only store simple data types
07:49:34 <bgamari> I guess separate unboxed arrays for the abscissa and ordinate
07:49:35 <bgamari> ?
07:49:55 <Jafet> Well, you can write your own instance
07:50:14 <dicey> define a new type?
07:50:16 <Jafet> I suppose you can also get one of those boilerplate reducing libraries to write your instance
07:50:34 <Jafet> instance IArray (UArray Datum) or something like that
07:50:50 <earthy> I would look at Storable
07:51:07 <Jafet> The unboxed arrays are usually implemented with Storable, afaik
07:51:14 <bgamari> Good to know
07:51:23 * earthy nods
07:51:37 <Jafet> Though in this case you can just implement it with parallel unboxed arrays.
07:51:53 <bgamari> Jafet: Yeah, that might be the easiest thing to do
07:52:09 <Jafet> So I heard that vector has an instance for Complex, if that's what you're doing
07:52:39 <bgamari> Jafet: Nope, not quite
07:52:50 <bgamari> A 2-tuple like complex though
08:00:29 <Jafet> These are the times when I idly wish haskell had some substructural typing
08:07:31 <lispy> there are times when I wish gui programming in haskell worked better
08:07:51 <ezyang> lispy: Is this in reference to the main thread snafus?
08:08:09 <lispy> ezyang: yes, that's the latest hurdle, but I've had no problem finding challenges in this area
08:08:31 <ezyang> Though, based on anecdotal evidence, traditional desktop GUI programming has always sucked.
08:08:39 <lispy> heh
08:08:45 <ezyang> c.f. Microsoft deciding to move their platform to HTML5
08:08:58 <lispy> Yes, but this newest issues means it's especially broken :(
08:09:07 <dicey> why not do the gui stuff in another language and interface?
08:09:09 <dicey> too dirty?
08:09:23 <Jafet> It sucks least to do it in haskell.
08:09:26 <Jafet> But it still sucks.
08:09:27 <ezyang> well, technically speaking, that is what we are doing...
08:09:38 <lispy> dicey: The curent thing I noticed with threads means that you can only do that if the "othe language" has it's own primary thread
08:10:00 <Jafet> Unless the GUI doesn't like you doing that, I guess
08:10:14 <lispy> dicey: The problem I encountered is that on OSX the process's original thread is special and some things need to execute there
08:10:41 <lispy> dicey: we have ways to arrange for bound threads, but no way to say, "Make it the first thread"
08:10:44 <dicey> time to build a new haskell gui library from scratch!
08:10:45 <dicey> lol
08:11:15 <ezyang> Honestly, this is just an oversight in GHC's RTS.
08:11:24 <lispy> dicey: so we have to rely on Cocoa's ability to run a function on the main thread.  Seems like we could make this more general though and then fix the problem for all libraries and platforms.
08:11:26 <ezyang> It might be technically difficult to make the first thread sticky, though.
08:11:28 <lispy> ezyang: yes exactly
08:11:37 <Jafet> Where's my xlib-yampa!
08:11:49 <Cale> It mainly sucks that GUI libraries written for other languages (for which there are Haskell bindings) are not threadsafe.
08:12:17 <lispy> No one makes threadsafe gui libraries it seems.  Not even apple
08:12:19 <ezyang> which is retarded, given that GUI is all about concurrency.
08:12:25 <Cale> yeah
08:12:31 <lispy> Rumors that I read say that MS windows has similar conventions
08:12:44 <Cale> derp
08:12:58 <lispy> that X is the only one that really tried to tackle the idea of allowing threads in apps
08:13:07 <lispy> Which I find amazing
08:13:19 <quicksilver> I don't find it that amazing.
08:13:25 * lispy has to run
08:13:28 <quicksilver> writing libraries is hard, they all have bugs.
08:13:33 <quicksilver> writing GUI libraries is harder.
08:13:44 <lispy> quicksilver: I find it amazing that X got it right, I eamn
08:13:47 <quicksilver> writing GUI libraries which are also threadsafe - why bother?
08:13:48 <Cale> Let's take something which is naturally concurrent and make sure that you can never use it in a concurrent fashion.
08:14:02 <quicksilver> Cale: except, it doesn't.
08:14:04 * lispy leaves
08:14:10 <quicksilver> Cale: it's really not very hard to arrange to make your GUI calls from the main thread
08:14:25 <quicksilver> Cale: so since the cost on the user is relatively low, the tradeoff is popular.
08:15:15 <Cale> Where by "really not very hard" you mean "forces you to program in a completely different style" ;)
08:15:41 <Jafet> “Different? We've been using this style all along!”
08:17:04 <dolio> That seems unlikely.
08:17:32 <Younder> Classes if awkward in Haskell, so so is GUI
08:18:04 <Cale> Younder: ?
08:18:05 * hackagebot bindings-DSL 1.0.12 - FFI domain specific language, on top of hsc2hs.  http://hackage.haskell.org/package/bindings-DSL-1.0.12 (MauricioAntunes)
08:18:06 <ezyang> I sort of feel like someone could make a killer growing a traditional imperative language with Haskell's threading model. But it seems unclear how you'd manage that without purity.
08:18:31 <Tomsik> Maybe make a whole language live in the ST
08:18:40 <Cale> heh, "we've already done it, and it's called Haskell"
08:18:51 <ezyang> "precisely"
08:19:03 <ezyang> All we need is a thread-safe GUI library, but I don't see an academic writing one of those any time soon.
08:19:14 <ezyang> Maybe we could convince one of the FRP researchers to do it.
08:19:42 <Younder> I have a confession to make for all my programs I have made the interface using PHP of Python ..
08:19:57 <luite> ezyang: there's hope, maybe there will be non-academics using haskell one day!
08:20:02 <Cale> There's enough stuff in there which doesn't count as good research that I think you'd be better off trying to convince yourself to do it somehow.
08:20:10 <dolio> PHP? Really?
08:20:22 <ezyang> No, then we lose :-(
08:20:54 <Jafet> luite: that would have to operate as a pyramid scheme, since many of them turn into academics
08:21:39 <Tomsik> Maybe you could for starters make a unix-pipe-gui-thing and then start something more
08:23:59 <quicksilver> Cale: I disagree. It's not a completely different style at all.
08:24:15 <quicksilver> what's the difference between "createDialog" and "postToMainThread $ creatDialog" ?
08:24:28 <quicksilver> it's just one combinator which you can abstract out if you want.
08:25:57 <sanjoyd> A combinator is essentially a lambda term with no free variables, right?
08:26:05 <sanjoyd> Or is there something more to it?
08:26:08 <sanjoyd> s/ti/them/
08:26:17 <Younder> For the record non-academics use Haskell today
08:26:23 <ezyang> You could call a top-level function a lambda term with no free variables.
08:26:24 <Cale> sanjoyd: There's more than one definition associated to that word.
08:26:47 <sanjoyd> ezyang: yes, I get that.
08:26:48 <Cale> sanjoyd: That's a particular technical definition of it
08:27:05 <Tomsik> Younder: who?!
08:27:15 <Younder> This parallel programming push has broth  Haskell back on the main stream
08:27:18 <sanjoyd> Cale: what is it exactly? Or is this not a proper question?
08:27:33 <Younder> Tomsik, Microsoft, IBM
08:27:54 <Tomsik> Hmm, right
08:28:29 <Younder> UI has NEVER been Haskell's strong side
08:28:44 <Younder> so you see it in F#
08:29:01 <Younder> or even C#
08:29:15 <Nimatek> And Scala.
08:29:20 <Cale> sanjoyd: There is a general style of library where you define some type of things which you're interested in (like parsers, drawings, GUIs, etc.), along with a bunch of (ideally very simple) primitive values of that type, and functions which transform and combine things of that sort
08:29:40 * sanjoyd searches for "Combinator Library".
08:29:48 <sanjoyd> Cale: do you have some especially simple example in mind?
08:29:52 <Cale> So that you have an embedded language for describing the things you're interested in
08:30:20 <Younder> Cale, no, so I am designing my own
08:30:36 <Younder> I call it formula
08:30:41 * sanjoyd reads Parsec.
08:30:51 <Cale> Let's go with desserts...
08:31:06 * hackagebot doctest 0.4.0 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.4.0 (SimonHengel)
08:32:00 <Cale> You might want to have a library for describing desserts, and then once described, you can compute an English language recipe in the traditional style, compute the sugar content, number of servings, etc.
08:32:02 <Younder> One of the languages I love the most Is the one of Mathematica, Lisp Haskell, ML and C so it is based on those
08:32:21 <Younder> s/One/some
08:32:42 <Cale> You could, if you were a cookbook author who wanted to sell lots of books, produce books filled with indivicual recipes, and their corresponding data. :)
08:32:50 <Cale> individual*
08:33:06 <Younder> No acually I am into paralell programming
08:33:24 <Younder> And the language syntax is just the surface
08:33:48 <Cale> Younder: I have a feeling that you're responding to me as if I was responding to what you said, but I'm talking to sanjoyd...
08:33:57 <Younder> sorry
08:34:17 * sanjoyd is getting a vague idea now.
08:34:30 <Cale> sanjoyd: Another option is to define some primitive desserts which consist of a single ingredient
08:34:45 <Cale> and then a bunch of operations for combining simple desserts into more complicated ones
08:35:21 <Cale> (like mix, layer, whip, chop, stir, etc.)
08:36:11 <Cale> and then define operations which break up in terms of the primitive combining operations
08:36:26 <Cale> (and are defined for primitive values as well)
08:37:01 <Cale> sanjoyd: You could also do this just as well for financial contracts :)
08:37:21 <Cale> sanjoyd: with primitive contracts like "you owe me one unit of currency X immediately"
08:38:01 <Cale> sanjoyd: and then lots of operations for transforming contracts (like delaying by a certain amount of time, scalar multiplication, addition, various conditionals)
08:38:13 <HugoDaniel> i use a lot of orphan instances :(
08:38:20 <HugoDaniel> i actually like them
08:38:31 <sanjoyd> Cale: So basically compose smaller things into larger things.
08:38:38 <Cale> sanjoyd: and then you can do things like produce natural language versions of a contract, and do various things to try to estimate its value, from the same description
08:38:41 <Cale> yeah
08:38:44 <HugoDaniel> ...does that make me the bad or the ugly ?
08:39:12 <Cale> HugoDaniel: Well, they're in the language for a reason
08:39:50 <Cale> HugoDaniel: Often you'd want to try to avoid them, but sometimes it's tricky.
08:40:27 <HugoDaniel> Cale
08:40:31 <Saizan> HugoDaniel: if you don't put them in libraries it's less of a problem
08:40:39 <Saizan> well, it's not a problem at all
08:40:51 <Saizan> though they have a place in libraries too
08:41:01 <HugoDaniel> i usually structure my code like this: MyModule.DataTypes MyModule.Functions MyModule.TypeClasses MyModule.Instances.TypeClass1 MyModule.Instances.TypeClass2 ...
08:42:55 <Cale> HugoDaniel: The trouble with it is that if you write your library like that, then library A can come along and import your instance modules, and library B can come along and define its own instances, and now libraries A and B are incompatible with each other.
08:43:26 <HugoDaniel> yes, i dont this for libraries
08:43:39 <Cale> In a final program, it's fine.
08:43:52 <benmachine> I'd question whether that's actually a useful separation though
08:44:00 <benmachine> I mean there are some things that it makes sense to have together
08:44:08 <benmachine> some functions that you define instances with
08:44:15 <benmachine> some types that are important for some typeclass
08:44:32 <HugoDaniel> hmm
08:45:17 <Cale> Sometimes it really is handy to split the types out into their own module, I'll say that much.
08:45:18 <benmachine> that's a stylistic taste issue though :)
08:45:46 <Cale> You can end up with issues with circular dependencies and that's often a decent solution
08:50:48 <quicksilver> I like putting basic functions with types though
08:51:16 <quicksilver> especially functions which only involve that type (and 'standard' types)
09:33:03 <mattp_> hey guys. what is the best way to get an up to date haskell platform if im running ubuntu natty?
09:33:25 <rostayob> mattp_: I just use the ghc binaries and then download the source
09:33:27 <mattp_> im trying to compile xmonad but am getting linking failures, i suspect because my ghc is 6.12.1
09:33:55 <mattp_> rostayob: fair. ill just do that then
09:34:15 <rostayob> nat
09:34:19 <rostayob> mattp_: http://haskell.org/ghc/download_ghc_7_0_3#binaries
09:34:35 <rostayob> the only problem is if you have some really old glibc I guess.
09:35:01 <mattp_> rostayob: ill let you know soon if mine is too old :)
09:35:19 <luite> use 7.0.4 instead of 7.0.3 if possible
09:38:23 <rostayob> mattp_: I'd exclude it is
09:39:18 <mattp_> rostayob: sorry?
09:39:33 <rostayob> mattp_: I'd exclude that your glibc is too old
09:41:36 <parcs> is there going to be a new HP release for 7.0.4?
09:50:06 <parcs> hmm, probably not. it seems that 7.2 will be released soon
09:53:51 <zztr> has anyone run haskell on cyanogenmod?
09:55:33 <CrazyThinker> Is there any editor for Haskell with auto complete/code assist?
09:56:00 <parcs> emacs
09:56:20 <rostayob> well emacs auto complete is not that nice but yeah
09:56:31 <rostayob> at least last time I tried
09:56:39 <kmc> we don't have editors with Java-style "write 10 pages of boilerplate" features
09:56:44 <kmc> for good reason
09:57:14 <rostayob> kmc: well some features (like auto complete or flymake) are nice to have
10:00:11 <parcs> @hackage ghc-mod
10:00:11 <lambdabot> http://hackage.haskell.org/package/ghc-mod
10:00:35 <parcs> that package provides support for flymake with haskell
10:00:49 <rostayob> parcs: oh, I didn't know about that, thanks.
10:01:30 <parcs> not many do. it needs to publicized more in the wiki or somethin
10:02:16 <rostayob> parcs: yeah
10:13:10 <guerrilla> hmm.. soo how do i combine use of the maybe monad and i/o monad in the same function? do i need to use monad transformers or is there an alternative?
10:13:22 <rovar> anyone know of some decent examples of reactively parsing an in-depth xml file?
10:13:36 <byorgey> guerrilla: you have to use the MaybeT monad transformer.
10:14:09 <guerrilla> byorgey: ok, i figured. thanks
10:15:32 <kmc> you don't really have to use a transformer
10:16:03 <kmc> guerrilla, you can execute IO actions that produce Maybe values, and then pattern match them or even use the monad functions with them
10:16:10 <kmc> it depends on what you're trying to do
10:16:19 <kmc> "how do i combine" is too vague
10:16:34 <guerrilla> omfg... wth netsplit or what?
10:16:38 <kmc> looks like
10:17:37 <guerrilla> kmc: yeah, i wanted to chain a bunch of functions that return maybes interneaved with IO.. like psuedocode "somethingWithIO; transform0; transform1; somethingElseWithIO"
10:18:08 <guerrilla> (in fact there could be an IO in between those transforms)
10:18:14 <kmc> and what if you get Nothing in between?
10:18:21 <guerrilla> fail
10:18:30 <kmc> fail how?
10:18:36 <guerrilla> the function fail
10:18:42 <kmc> in the IO monad?
10:18:42 <guerrilla> fail "Oops, cant do what you want" or whatever
10:18:45 <guerrilla> yes
10:18:53 <kmc> think that just raises an IO exception
10:19:22 <kmc> :t maybe (fail "sucks") return
10:19:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => Maybe a -> m a
10:19:36 <guerrilla> ok
10:19:47 <guerrilla> kmc: let me hpaste a skeleton of what i'm doing
10:20:03 <kmc> if you just want to convert "returns Just x or Nothing" to "returns x in IO or throws an exception"
10:20:07 <kmc> then you can use something like that
10:20:18 <kmc> no monad transformers required
10:20:34 <guerrilla> i wanted to remove the case res Just rest2/Nothing, case rest2 that im currently doing
10:20:47 <guerrilla> ok hmm
10:20:54 <guerrilla> lemi do this hpaste, one second
10:22:41 <guerrilla> kmc: more or less this: http://hpaste.org/48719
10:23:08 <guerrilla> the case chain goes on forever and i had just left it that way for a while, but now i'd like to clean it up
10:23:40 <guerrilla> btw, sorry, i'm not actually using the Maybe monad
10:23:52 <guerrilla> i just said that 'cos i thought it was a quick question
10:24:08 <kmc> you're not using this Failure / Success type monadically at all
10:24:15 <guerrilla> no not yet, but i want to
10:24:19 <kmc> right
10:24:31 <guerrilla> thats the direction i want to go on
10:24:35 <guerrilla> if it didn't have IO, that's easy
10:24:48 <guerrilla> but having the interleaved I/O confused me
10:24:53 <akosch> what should I use to connect to mysql?
10:25:54 <guerrilla> kmc: lets say Result = Success|failure, etc.. then is Result (IO Whatever) a good way to do this?
10:26:03 <kmc> yeah, i think so
10:26:24 <guerrilla> ok, then that makes perfect sense. i just didnt know what is idiomatic
10:26:25 <kmc> then you can define "runResult (Success x) = x; runResult (Failure msg) = fail msg"
10:26:34 <guerrilla> yeah
10:26:41 <kmc> yeah, it depends on what you're doing -- in some cases the transformer will come out nicer
10:26:59 <guerrilla> the equivalent of doing MaybeT IO.. kinda weirded me out.. i don't mind using transformers at all, but on IO i felt maybe i was doing something wrong
10:28:08 <kmc> the example at http://hackage.haskell.org/packages/archive/MaybeT/0.1.2/doc/html/Control-Monad-Maybe.html is for IO
10:28:42 <hpaste> chrisdone pasted “concurrent stuff” at http://hpaste.org/48720
10:28:49 <guerrilla> haha, ok.. thanks kmc. i had missed that :)
10:28:53 <guerrilla> now i don't feel so weirded out
10:30:48 <chrisdone> Is there a library containing concurrent versions of mapM, mapM_, etc.?
10:31:08 <kmc> not afaik chrisdone
10:31:11 <chrisdone> I find this to be a common pattern when I have a batch process that can be trivially concurrentized.
10:31:15 <kmc> your paste reminds me somewhat of my library http://hackage.haskell.org/packages/archive/spawn/0.2/doc/html/Control-Concurrent-Spawn.html
10:31:46 <kmc> what you want is basically «sequence . mapM spawn»
10:32:18 <chrisdone> Hm, I like that.
10:32:56 <chrisdone> pool is also nice, something I wanted.
10:33:23 <kmc> thanks
10:33:35 <kmc> i'm glad to hear it's vaguely understandable what "pool" does
10:33:47 <chrisdone> I'm editing 100 PDFs which takes about 40 seconds. I got our sysadmin to enable 7 cores. Now with concurrently it takes 13 seconds. :-)
10:33:56 <kmc> the type is a bit o_O
10:34:09 <chrisdone> Yeah, hehe.
10:34:25 <kmc> this is why i love haskell for concurrent programming
10:34:32 <kmc> you can write these really powerful abstractions in two lines of code
10:34:35 <chrisdone> Aye, it's so trivial.
10:35:08 <rovar> i am attempting to write an xml parser with xml-enumerator. (http://hackage.haskell.org/packages/archive/xml-enumerator/0.3.4/doc/html/Text-XML-Enumerator-Parse.html)
10:35:39 <rovar> I have an element which contains many sub elements, and I need to collect them all to make a page type.
10:35:49 <kmc> chrisdone, the idea behind 'spawn' is to do this all with the simplest API without exposing the implementation of concurrency
10:36:01 <rovar> so if I have a  data Page = Page { ... }
10:36:03 <kmc> that's why i don't have a "ThreadID" type which you have to pass around
10:36:12 <kmc> the computation *is* its "result action"
10:36:28 <kmc> other than this design choice it's the same as a few other libs on hackage
10:36:46 <rovar> that is the parametric type in my monad.. how do I pass that around to be filled up by each sub element function?
10:36:49 <shachaf> kmc: That behavior is nice, but seems a bit limited.
10:36:50 <chrisdone> Aye, I also like that the exception is thrown when the value is demanded.
10:37:07 <chrisdone> Otherwise they get lost in the dead thread abyss.
10:38:00 <Osama> HELLO
10:38:08 <kmc> shachaf, yeah, it makes it hard to support multiple actions like "wait for completion" or "kill the thread asynchronously"
10:38:53 <shachaf> Clearly the solution is spawn :: IO a -> IO (IO a, IO (), IO (), IO a, IO Int)
10:39:21 * chrisdone hiccups at the sight of such a type
10:40:44 * tommd looks around the room
10:40:56 * tommd waits for more people to sign up to attend HacPDX
10:41:27 <kmc> shachaf, what's the name of that design pattern?
10:43:56 <shachaf> kmc: If your design patterns have names, that means you might accidentally use them more than once, which takes the fun out of it.
10:44:07 <siracusa> System.Directory.findExecutable searches for an executable in the current path variable, is there a function to search for an arbitrary file in any of the paths in the path variable?
10:46:12 <rovar> can you pattern match on record syntax'd data types as if they were regular data types?
10:46:46 <siracusa> rovar: Yes
10:47:07 <rovar> so I would just ignore the record name?
10:47:11 <JahreViking> \list
10:47:16 <rovar> err the member name
10:47:34 <siracusa> I think that should work, yeah
10:47:35 <Eduard_Munteanu> rovar: you'd mention fields in the order you defined them using record syntax
10:47:54 <rovar> Eduard_Munteanu: gotcha, thanks.
10:48:07 <rovar> that's what I thought.. but I'm getting a wierd syntax error.. thought that might be it :)
10:48:16 <rovar> parse error
10:48:28 <scree> paste parse error?
10:48:55 <rovar> ah.. i had whitespace highlighting turned off..
10:48:59 <rovar> vim found it for me :)
10:49:28 <agumonkey> hi
10:49:51 <mattp_> configure: error: The Haskell Platform version 2011.2.0.1 requires ghc-7.0.3
10:50:07 <mattp_> am i safe to use --enable-unsupported-ghc-version with the 7.0.4?
10:50:37 <mattp_> someone here told me to download 7.0.4 instead of 7.0.3
10:50:58 <rovar> there is a 7.0.4?
10:51:13 <rovar> if that is the case, you'll have to rebuild the platform from source, I'd reckon.
10:52:13 <mattp_> what does the haskell platform do
10:52:21 <mattp_> do i need it to run xmonad
10:52:45 <kmc> you do not need the whole HP to run xmonad
10:52:54 <kmc> HP is GHC plus a variety of useful libraries, pre-packaged
10:53:05 <mattp_> but i can cabal install whatever i need
10:53:08 <kmc> right
10:53:12 <mattp_> and be golden? ok cool
10:53:21 <mattp_> i wont bother with the platform then
10:53:23 <kmc> haskell-platform is just a Cabal meta-package that depends on a bunch of stuff
10:53:33 <kmc> if you already have a working GHC and cabal-install, you're good
10:54:10 <mattp_> cool. thanks
10:54:26 <kmc> also GHC 7.0.4 is a bugfix release only
10:54:30 <kmc> http://www.haskell.org/ghc/docs/7.0.4/html/users_guide/release-7-0-4.html
10:55:20 <kmc> so it should be fully compatible with HP 2011.2.0.1
10:55:20 <mattp_> so id probably have been alright to force install the platform
10:55:22 <kmc> yeah
10:55:29 <mattp_> ah well. too late now :)
10:56:06 <Wiallim> Do everybody thinks that haskell is useful?
10:56:23 <kmc> no, not everybody thinks that
10:56:35 <ion> No, it’s not useful at all. We’re all here as a huge inside joke.
10:56:48 <monadic> Wiallim: The people here, perhaps
10:57:00 <kmc> i think not even everyone here would claim it's useful
10:57:08 <kmc> like any tool, it is useful for some tasks and not others
10:58:31 <Wiallim> I like function programming. and Lambda expressions.
10:58:46 <tommd> But doesn't the term "useful" imply it has some use at some task, so an "exists" quantification not a "for all".
10:59:12 <Wiallim> Yes.
10:59:25 <tommd> @faq Can Haskell help me rob a bank?
10:59:25 <lambdabot> The answer is: Yes! Haskell can do that.
10:59:40 <tommd> There is at least one person who thinks Haskell is useful FOR ALL tasks - lambdabot.
11:00:26 <Wiallim> Haha
11:01:05 <siracusa> How to get the full path to an executable that was invoked to run a program?
11:02:31 <earthy> @hoogle getProgName
11:02:31 <lambdabot> System.Environment getProgName :: IO String
11:02:45 <earthy> might not be exactly what you want though
11:02:59 <siracusa> No, it doesn't include the full path
11:03:01 <kaol> /proc/self/exe on Linux. Sounds rather system dependent.
11:03:02 <tommd> That isn't quite what he asked, but the right place to look.
11:03:02 <Wiallim> what different between Haskell and Lisp?
11:03:25 <tommd> kaol: But if you know a Windows version he can make a package using CPP.
11:03:31 <earthy> siracusa: otoh, this tends to be very system dependent...
11:03:43 <tommd> Wiallim: Lots.  Lazyness, purity, types
11:03:49 <tommd> Those are perhaps the top three.
11:03:52 <tommd> Along with community.
11:04:00 <earthy> (it may not even be available in the case of e.g. House/hOp)
11:04:09 <tommd> Right, or HaLVM
11:04:10 <Wiallim> tommd:thanks
11:04:55 <siracusa> earthy: Hhm, I'd prefer a system independent solution
11:05:04 <hpaste> ash_ pasted “learning haskell, style recommendations” at http://hpaste.org/48721
11:05:16 <tommd> Do you know a Windows solution?  You can _build_ a system independent solution.
11:05:32 <earthy> would be a nice lib to put on hackage ;)
11:06:06 <Wiallim> hpaste: this web is cool.
11:06:46 <ash___> so... I am still learning haskell, but does that paste look horrible? i am still trying to figure out the right way to do some things in haskell, just curious if anyone has any comments on it
11:08:09 <dylukes> ash___: Could you repast it ^^;?
11:08:19 <ash___> http://hpaste.org/48721
11:08:42 <dylukes> Well, seems like hlint gave some suggestions.
11:09:27 <ash___> its working correctly, so its not really the functionality that i am having any problems with
11:09:34 <dylukes> This is just a very simple regex engine from the looks of it?
11:09:41 <ash___> just trying to learn 'the haskell way' of doing things
11:09:45 <ash___> ya
11:10:30 <tommd> ash___ use more pattern matches
11:10:34 <dylukes> I'm sure the series of if/then's could be better represented.
11:10:44 <tommd> ash___: and don't use if/else for booleans, just build the boolean.
11:10:53 <hpaste> TomMD annotated “learning haskell, style recommendations” with “learning haskell, style recommendations (annotation)” at http://hpaste.org/48721#a48722
11:10:57 <dylukes> It might be more elegant in the Maybe monad, or using and/or/not/xor combinators.
11:11:09 <tommd> http://hpaste.org/48721  See my version of match
11:11:13 <tommd> I did'nt look at the rest
11:11:37 <earthy> siracusa: look at http://stackoverflow.com/questions/1023306/finding-current-executables-path-without-proc-self-exe
11:11:55 <tommd> earthy++
11:11:58 <ash___> tommd: ah, ya I have been trying to figure out how to use the @()
11:11:58 <tommd> You just don't give up
11:12:55 <tommd> ash___: It's just an alias.  "func a@(Some Pattern) = ..." means the variable 'a' is the full value while the pattern inside is matched (which could have more variable bindings)
11:13:50 <siracusa> earthy: Thanks, seems to be more complicated than I thought
11:15:24 <ash___> the code was a C program I was trying to translate and used a lot of do-while loops, so part of the structure of my code was trying to figure out how to define those recursively
11:15:31 <earthy> which is exactly the reason to put it in a lib, test it on a number of platforms (sure that people here'd be glad to help) and upload it to hackage
11:17:36 <earthy> otoh, you may want something along the lines of http://autopackage.org/docs/binreloc/
11:18:56 <earthy> and don't forget the issue that is  http://stackoverflow.com/questions/933850/how-to-find-the-location-of-the-executable-in-c/934100#934100
11:22:31 <siracusa> earthy: Hackage already seems to have such a package http://hackage.haskell.org/package/executable-path ... should have looked there before asking :-S
11:23:53 <tommd> siracusa: Sadly, that makes no attempt to be platform independent.
11:23:59 <tommd> It will fail badly on Windows, for example.
11:24:13 <tommd> If you know how then send the maintainer a patch to get the path on a Windows machine.
11:24:28 <ash___> just remembered hlint, and it had this suggest: regexp !! 0 == '.' || regexp !! 0 == head text   into   (regexp !! 0) `elem` ['.', head text]
11:24:39 <ash___> i would of never realized those did the same thing...
11:25:00 <siracusa> tommd: Have you tested it? Their supported systems include Windows XP
11:25:38 <tommd> Ok, it's just the haddock that might be broken
11:25:44 <tommd> It has hard coded:  readSymbolicLink $ "/proc/" ++ show pid ++ "/exe"
11:25:58 <tommd> So I guess they aren't using CPP, but alternate source files to support different OSes.
11:27:02 <earthy> they actually are using CPP and alternate source files
11:27:05 <tommd> Indeed, that is what they do.  CPP to import a platform specific file then the Haddock goes to that file.
11:27:30 <tommd> earthy, yes, I just looked.  Which has the end result of haddock being (slightly) misleading as it linkes to the Linux docs (due to what Hackage runs)
11:27:36 <earthy> however, the code doesn't use all possible methods of trying to find the executable path
11:27:45 <earthy> on e.g. FreeBSD
11:28:04 <tommd> In my experience package maintainers always like patches as it shows interest.
11:29:28 <earthy> oh well, still, better than nothing and it may help you, siracusa ;)
11:29:49 <tommd> Yes, we give it permission to help!
11:30:06 <ddarius> (!! 0) = head
11:30:44 <ash___> what is @ called? as in:  foobar a@(x:xs) ? Just trying to find the docs for it
11:31:16 <siracusa> earthy, tommd: Yep, perfectly works on Windows. I think Windows and Linux will be fine for the moment. Thanks for the help!
11:32:20 <ion> > let foobar a@(x:xs) = (x, xs, a) in foobar [0,1,2,3]
11:32:21 <lambdabot>   (0,[1,2,3],[0,1,2,3])
11:32:47 <ash___> ah, found it, as-patterns
11:33:24 <Phyx-> This is a long shot... but is it possible to get ghc to compile using another compiler? say MSVC? or is ghc using too many ghc specific features?
11:34:36 <saati> is there a haskell compiler named msvc? :)
11:34:40 <tommd> You can use GCC when bootstrapping GHC...
11:35:15 <Phyx-> saati: afaik, ghc uses gcc for code generation
11:35:16 <tommd> saati: Microsoft Visual C...
11:35:31 <tommd> Phyx-: For the via-c backend, gcc is used.
11:35:56 <tommd> But gcc /= ghc so I figured it fit the bill.
11:36:02 <Phyx-> i'm trying to get a .pdb file for a haskell program. but since it's proprietary, almost nothing but microsoft tools output it
11:36:18 <tommd> pdb?
11:36:31 <ddarius> It's a debugging symbols file.
11:36:32 <Phyx-> debugging symbols used by microsoft tools
11:36:37 <earthy> due to the usage of the evil mangler in the via-c backend I don't think anything but gcc is supported
11:36:53 <Phyx-> brb, dinner
11:36:54 <ion> I guess you could ask LLVM to output C and then tell MSVC to compile that if you really want. :-)
11:36:56 <earthy> however, I haven't delved to deep into that rat's nest :P
11:37:03 <ddarius> earthy: Even without the mangler, GHC relies on a lot of GCC specific features.
11:37:23 * ddarius pokes jfredett.
11:38:13 * tommd give's jfredett a bat and a poke-proof vest for self protection.
11:39:02 <travisyay> hello?
11:39:11 <kmc> hi
11:39:11 <tommd> > reverse "hello?"
11:39:12 <lambdabot>   "?olleh"
11:39:20 <travisyay> can anybody help me with a simple function?
11:39:24 <kmc> yes
11:39:33 <travisyay> im learning haskell and im having trouble with getting used to types
11:39:47 <travisyay> and so in the book im reading im at the "unfold" function
11:39:53 <tommd> what book?
11:40:00 <travisyay> defined as
11:40:02 <travisyay> nfold p h t x  | p x = [] 		| otherwise = h x:unfold p h t (t x)
11:40:05 <travisyay> unfold*
11:40:19 <travisyay> the book is "programming in haskell" by hutton
11:41:05 <tommd> So p is a boolean test on x.  h is a function that "expands" (or unfolds) x into something.  t is a function that steps x.
11:41:13 <travisyay> yes i understand that part...
11:41:17 <travisyay> but for the exercise
11:41:29 <travisyay> it's to redefine map f using unfold
11:41:38 <travisyay> right now my code is: map f= unfold (null)(f head)(tail)
11:42:11 <tommd> f is applied to head?
11:42:14 <tommd> don't you want to compose?
11:42:22 <travisyay> but then haskell says there is a problem processing my function if i try like "map (+1) [2, 3, 4]". there's an error in processing the +1
11:42:23 <tommd> Also, too many parentheses.
11:42:24 <travisyay> oh
11:42:34 <travisyay> okay so i dont have to put parenthesis?
11:42:49 <tommd> not like that (around f and head, yes but not on lone arguments)
11:42:57 <tommd> map f = unfold null (something here) tail
11:43:02 <travisyay> i thought you applied the function to the head and then continued with the tail
11:43:12 <travisyay> oh okay i see
11:43:13 <tommd> yes, but that isn't what you wrote
11:43:21 <kmc> parentheses are just for grouping, they are not required
11:43:25 <tommd> (f head) is, in C syntax, f(head)
11:43:34 <travisyay> ohh okay
11:43:41 <tommd> what you want , in C syntax, is f ( head ( arg ) );
11:43:58 <tommd> which is (f . head) or in a lambda (\arg -> f ( head arg ) )
11:44:16 <travisyay> i see
11:44:17 <ash___> so... if you get a non-exhaustive pattern match error, is there a way to figure out why/where?
11:44:27 <tommd> It should tell you.
11:44:28 <travisyay> i thought compose applies two functions to a single argument
11:44:55 <tommd> (f . g) x == f (g x)
11:44:57 <travisyay> oh actually i think i understand now
11:44:59 <travisyay> yes
11:45:00 <tommd> so it strings the functions together.
11:45:03 <travisyay> that makes sense
11:45:07 <travisyay> thank you very much for the help!
11:45:26 <tommd> No problem, you are doing well and had the exercise basically done - good work.
11:45:39 <travisyay> thank you!
11:47:26 <ddarius> As a next exercise you can define unfoldr in terms of that unfold and vice versa and see the myriad of problems with that definition.
11:47:53 <travisyay> i will try it out. thanks for the suggestion!
11:48:48 <hpaste> ash_ annotated “learning haskell, style recommendations” with “learning haskell, style recommendations (annotation)” at http://hpaste.org/48721#a48725
11:49:55 <ash___> tommd: I updated my hpaste if you'd like to see the new version, with some re-writes http://hpaste.org/48721#a48725
11:54:20 <tommd> ash___: I suggest reverting back to a 'not null' test from length > 0 - length is an O(n) operation while null is O(1).  It's just good practice to avoid length if it isn't needed.
11:54:30 <tommd> ash___: "rest" is just the prelude function "tail"
11:54:43 <tommd> ash___: But this is rather clean, otherwise.  Good work.
11:55:15 <ash___> ah, i was wondering about that, i looked for a 'rest' in prelude, but didn't see one at first, thanks, it felt silly defining it the way I did
11:55:17 <tommd> ash___: Oh, and you don't need to use var@(pattern) quite so much
11:55:40 <tommd> I notice you don't even use the "var" fairly often - so you can just drop the var@ part in those cases.
11:56:01 <tommd> like the first few cases of "matchhere" have a regexp@ that can go.
11:56:24 * tommd runs off to work on worky work (to steal another haskellers phrase)
11:56:27 <ash___> got ya, thanks
12:02:53 <rostayob> parcs: Ok I just got home and I've installed ghc-mod, but it doesn't seem to work. Loading emacs gives no errors, but these commands: http://www.mew.org/~kazu/proj/ghc-mod/en/ don't work
12:05:21 <parcs> rostayob: check out the readme inside the git repository there
12:05:55 <rostayob> parcs: yeah I followed the installation instructions
12:06:03 <parcs> rostayob: oh.. hmm
12:06:04 <rostayob> but it doesn't seem to bind any key
12:06:15 <parcs> do you also have haskell-mode configured?
12:06:16 <Phyx-> back
12:06:19 <rostayob> parcs: yep
12:06:19 * Phyx- reads up
12:07:45 <MatrixFrog> hello haskellers. i have what may be a dumb question
12:07:52 <kmc> go ahead :)
12:07:55 <MatrixFrog> i want a function that returns its input, plus 1
12:07:59 <MatrixFrog> (+1) is such a function
12:08:04 <MatrixFrog> ok cool
12:08:14 <MatrixFrog> now i want a function that returns its input MINUS 1
12:08:21 <kmc> :t subtract 1
12:08:22 <lambdabot> forall t. (Num t) => t -> t
12:08:22 <MatrixFrog> (-1) is the number negative 1
12:08:34 <kmc> yeah, it's a stupid special case in the syntax; shouldn't be there imo
12:08:35 <MatrixFrog> do i just have to literally write out "subtract"? :(
12:08:42 <MatrixFrog> i was hoping there was a way around that
12:08:47 <rostayob> MatrixFrog: (-) 1?
12:08:48 <MatrixFrog> :t (- $ 1)
12:08:48 <lambdabot> parse error on input `$'
12:08:58 <kmc> rostayob, that would be \x -> 1 - x
12:09:04 <kmc> MatrixFrog, you can write (\x -> x-1)
12:09:11 <MatrixFrog> that seems slightly nicer
12:09:18 <MatrixFrog> :t ((-) 1)
12:09:19 <lambdabot> forall t. (Num t) => t -> t
12:09:32 <rostayob> oh, right.
12:09:34 <kmc> :t let (^!!!!!^) = (-) in (^!!!!!^ 1)
12:09:34 <lambdabot> forall a. (Num a) => a -> a
12:09:35 <MatrixFrog> oh hey i think rostayob's way might work too
12:09:42 <ddarius> (+(-1)) 3
12:09:44 <ddarius> > (+(-1)) 3
12:09:44 <rostayob> MatrixFrog: no
12:09:45 <kmc> MatrixFrog, that's \x -> 1 - x
12:09:45 <lambdabot>   2
12:09:51 <MatrixFrog> oh ok :(
12:09:56 <rostayob> (flip (-)) 1?
12:10:02 <kmc> ddarius's is probably the most compact
12:10:11 <MatrixFrog> yeah that should work, but yeah
12:10:13 <rostayob> (flip (-)) 1 should work as well
12:10:22 <kmc> :t let (−) = (-) in (− 1)
12:10:23 <lambdabot> parse error (possibly incorrect indentation)
12:10:28 <kmc> > let (−) = (-) in (− 1) 5
12:10:28 <ddarius> @src subtract
12:10:28 <lambdabot> subtract x y = y - x
12:10:29 <lambdabot>   4
12:10:33 <MatrixFrog> what i really want is (\x -> (x^3 - 1) `div` 2)
12:10:34 <rostayob> > ((flip (-) 1) 3
12:10:35 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
12:10:35 <kmc> yeah, :t doesn't like Unicode for some reason
12:10:37 <MatrixFrog> i was being overly clever
12:10:48 <kmc> MatrixFrog, i'd just write it as such
12:10:49 <rostayob> > ((flip (-)) 1) 4
12:10:51 <lambdabot>   3
12:10:57 <ddarius> @pl \x -> (x^3 - 1) `div` 2
12:10:58 <lambdabot> (`div` 2) . subtract 1 . (^ 3)
12:11:05 <rostayob> @pl (\x -> x - 1)
12:11:05 <lambdabot> subtract 1
12:11:19 <rostayob> MatrixFrog: @pl is nice
12:12:24 <MatrixFrog> i guess i have enough of a bias to symbols rather than words, that i think \x -> (x^3 - 1) `div` 2 looks nicer
12:12:48 <rostayob> I didn't know that (- 1) == -1, mhm
12:13:05 <MatrixFrog> i suppose it makes sense, but it's a bit annoying
12:13:08 <rostayob> yeah
12:13:13 <rostayob> but maybe most of the times you want that behaviour
12:13:18 <parcs> > (- 1)
12:13:19 <lambdabot>   -1
12:13:27 <rostayob> :t (- 1)
12:13:27 <lambdabot> forall a. (Num a) => a
12:13:35 <MatrixFrog> probably true
12:13:36 <parcs> that doesn't make sense to me at all; at least, it's counterintuitive
12:13:37 <ddarius> It was just a question of where to put the surprise.
12:13:54 <rostayob> parcs: yeah it is in a functional language
12:14:00 <rostayob> (still fighting with ghc-mod)
12:14:09 <MatrixFrog> ddarius: i'm sure there were lots of debates about it
12:14:47 <rostayob> epic battles
12:15:19 <MatrixFrog> technically when you write the number negative 1, you're supposed to use a negative sign, not a minus sign
12:15:36 <MatrixFrog> but the negative sign is not readily available on any computer keyboards i know of
12:15:37 <kmc> definitely not the ASCII hyphen-minus
12:15:44 <kmc> yeah
12:15:57 <MatrixFrog> *shrug*
12:15:59 <rostayob> yeah but haskell is UTF-8, so it should be fine
12:16:05 <rostayob> anyway. we'll survive
12:16:20 <kmc> i want to get rid of that special case
12:16:23 <kmc> and also "if then else"
12:16:26 <rostayob> I guess you don't want an UTF-8 function in the prelude ehehe
12:16:38 <rostayob> kmc: if then else is fine
12:16:48 <kmc> there's no reason for it to exist
12:16:51 <kmc> it should be a function
12:17:01 <rostayob> I'd rather write that that case x == 1 in True ...
12:17:04 <rostayob> ah
12:17:05 <parcs> if then else is useful when within do notation
12:17:17 <parcs> it eliminates two sets of parentheses, potentially
12:17:23 <rostayob> i guess you could have ifThen cond this that
12:17:31 <kmc> :t bool
12:17:32 <lambdabot> Not in scope: `bool'
12:17:44 <rostayob> @hoogle Bool -> a -> b
12:17:44 <MatrixFrog> :t Bool
12:17:44 <kmc> @let bool t f True = t; bool t f False = f
12:17:44 <lambdabot> Control.Exception assert :: Bool -> a -> a
12:17:44 <lambdabot> Control.OldException assert :: Bool -> a -> a
12:17:44 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
12:17:45 <lambdabot> Not in scope: data constructor `Bool'
12:17:45 <lambdabot>  Defined.
12:17:52 <kmc> > bool 3 4 True
12:17:53 <lambdabot>   3
12:17:57 <rostayob> @hoogle Bool -> a -> a -> a
12:17:57 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
12:17:57 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
12:17:57 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
12:18:00 <kmc> this is consistent with 'maybe' and 'either'
12:18:46 <rostayob> kmc: mhm, wasn't eliminating if-then-else proposed somewhere?
12:18:49 <kmc> i'm for dropping 'if then else' and banishing 'head' and 'tail' from the Prelude
12:18:59 <rostayob> there as a pros and cons page
12:19:12 <rostayob> kmc: partial functions can be nasty but they have a reason to exist
12:19:25 <rostayob> *there was
12:19:28 <kmc> beginners love to write code like «if null xs then 0 else head xs + sum (tail xs)»
12:19:30 <MatrixFrog> hm, ctrl+C is not stopping ghci like it usually does
12:19:37 <parcs> if p then do .. else do .. is much nicer than bool (do ...) (do ...) p
12:19:38 <rostayob> but yeah we should have a safe prelude
12:19:41 <kmc> rostayob, sure, put them in Data.List
12:19:47 <rostayob> kmc: yeah I agree
12:19:47 <roconnor> @hoogle utcTimeToPosixSeconds
12:19:47 <lambdabot> Data.Time.Clock.POSIX utcTimeToPOSIXSeconds :: UTCTime -> POSIXTime
12:19:49 <kmc> also in some sense the only partial function should be fromJust
12:20:00 <kmc> and you can use (fromJust . head) if you like
12:20:07 <kmc> but there's a brevity / readability concern
12:20:09 <ddarius> kmc: We should just ban Bool from the Prelude.
12:20:18 <kmc> ddarius, cool, can I use Maybe () instead?
12:20:25 <MatrixFrog> heh i kind of like that idea
12:20:27 <kmc> (never mind the extra ⊢)
12:20:29 <kmc> er
12:20:30 <kmc> ⊥
12:20:36 <kmc> the keys are like right next to each other
12:20:52 <ddarius> ⊣
12:21:09 <ddarius> ⊤
12:21:11 <kmc> ☭
12:21:31 <benmachine> ☺
12:21:34 <rostayob> kmc: are you typing from emacs :D?
12:21:47 <MatrixFrog> anyone know why stopping a calculation in ghci using ctrl+C would suddenly not work?
12:22:30 <HugoDaniel> λ
12:22:54 <rostayob> MatrixFrog: what calculation?
12:23:20 <MatrixFrog> my attempt at solving this http://projecteuler.net/index.php?section=problems&id=343
12:23:40 <benmachine> it can happen in really tight loops I think
12:23:44 <ziman> MatrixFrog, you might try ^\, that's a different signal
12:23:48 <MatrixFrog> hm
12:23:59 <rostayob> MatrixFrog: and anyway, kill -9 is your friend!
12:24:08 <MatrixFrog> windows is my notfriend
12:24:13 <MatrixFrog> yet i am on it
12:24:30 <rostayob> oh, ok
12:25:33 <kmc> ^Z
12:25:35 <kmc> oh
12:25:43 <MatrixFrog> oh yeah i could have tried that
12:25:48 <MatrixFrog> i just killed it
12:28:27 <tommd> MatrixFrog: iirc, GHC uses GC and allocation points for scheduling.  Perhaps you were in a non allocating loop.  Not sure how the signals are handled, but if they get intercpeted then queued for a Haskell thread that will never run...
12:28:40 <fenris_kcf> Hy! Is there a way to specialize a type-constructor? Example: "data Foo = Foo Bool Int" and now something like "Bar n = Foo True n"?
12:28:54 <guerrilla> kmc: how do i get a Bool out of a (ResultT IO Bool) in a ResultT IO () computation. it's as if i have to do two <- binds
12:29:01 <roconnor> fenris_kcf: sadly no.
12:29:07 <benmachine> fenris_kcf: you can define a function bar n = Foo True n (or bar = Foo True)
12:29:15 <benmachine> but you won't be able to pattern match on it
12:29:23 <fenris_kcf> hmm, pity
12:29:24 <kmc> you don't
12:29:29 <kmc> (ResultT IO) is a monad
12:29:41 <kmc> so (>>=) :: ResultT IO a -> (a -> ResultT IO b) -> ResultT IO b
12:30:37 <MatrixFrog> tommd: yup, makes sense
12:31:30 <guerrilla> kmc: ok i see. i just had to lift the original bind (fileExists ← resultLift (doesFileExist sourceFilePath))
12:31:40 <danharaj> http://hpaste.org/48726
12:31:45 <danharaj> anyone have any idea how I can clean up my code?
12:32:10 <kmc> omgwut
12:32:11 <MatrixFrog> danharaj: do you know about hlint?
12:32:29 <kmc> danharaj, more newlines
12:32:34 <danharaj> MatrixFrog: Yeah. I think my problems are more substantial than that :p
12:32:44 <kmc> also you have a bunch of repetition which is visually obvious
12:32:44 <MatrixFrog> that may be quite true
12:33:17 <danharaj> kmc: Yeah I do. I need to factor that stuff out. Where would you put newlines?
12:33:20 <kmc> nmin and nmax are nearly the same and each of them is repeated twice
12:33:30 <kmc> danharaj, probably before each block of comments
12:33:34 <kmc> you need to space it out
12:33:40 <kmc> into logical chunks
12:34:19 <danharaj> To be honest I usually don't add comments to my code, but I figure I need to learn to do that so my placement is awkward.
12:34:35 <kmc> i think you're over-commenting
12:34:49 <danharaj> probably :p
12:34:57 <kmc> i would describe the algorithm all together in one block
12:35:02 <kmc> and then make short references back into that
12:35:18 <kmc> the biggest problem here by far is all the repeated code
12:36:05 <MatrixFrog> is there an idiomatic way to write quickcheck properties for certain values? like... i just figured out that a certain property should hold for all odd numbers
12:36:13 <kmc> :t (==>)
12:36:14 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
12:36:30 <kmc> @check \n -> odd n ==> (n `mod` 2 == 1)
12:36:30 <danharaj> I think I'll remove comments and add them back in later.
12:36:30 <lambdabot>   No instance for (Test.QuickCheck.Testable
12:36:31 <lambdabot>                     (Test.QuickCh...
12:36:32 <MatrixFrog> ooo cool
12:36:36 <danharaj> Let me float out some redundancies.
12:36:53 <kmc> hmm sucks
12:36:55 <benmachine> @check \n -> odd (n :: Integer) ==> (n `mod` 2 == 1)
12:36:55 <lambdabot>   No instance for (Test.QuickCheck.Testable
12:36:56 <lambdabot>                     (Test.QuickCh...
12:37:02 <benmachine> hmph
12:37:37 * hackagebot regex-applicative 0.1.1 - Regex-based parsing with applicative interface  http://hackage.haskell.org/package/regex-applicative-0.1.1 (RomanCheplyaka)
12:37:45 * roconnor wishes he could have a monoid in his Map.
12:37:54 <kmc> MatrixFrog, it's important to use (p ==> q) instead of (not p || q) because the latter will count cases where 'p' did not hold against the total number of test cases
12:38:07 <kmc> you want to check 500 or whatever of the cases where p *did* hold
12:38:45 <akosch> could someone please take a look at my code? http://pastebin.com/b0xxm7iv
12:38:48 <mauke> The paste b0xxm7iv has been copied to http://hpaste.org/48727
12:38:54 <MatrixFrog> cool cool
12:39:07 <kmc> akosch, don't use OPTIONS_GHC with -X
12:39:16 <kmc> use {-# LANGUAGE TemplateHaskell, ... #-}
12:39:32 <akosch> kmc: thanks, saw that somewhere
12:39:57 <kmc> pastebin.com syntax-highlights the word "Monad"
12:40:08 <kmc> because Haskell is all about monads, right? ;P
12:40:19 <kmc> akosch, anything in particular we should look at?
12:40:32 <akosch> what I'm trying to do is output JSON with MySQL table names and fields/types
12:40:35 <akosch> nothing to complex
12:40:39 <roconnor> does it highlight Comonad?
12:41:01 <akosch> what I'm messing up is @ line 42
12:41:05 <kmc> akosch, putStrLn . show = print
12:41:31 <akosch> kmc: thanks :)
12:42:23 <kmc> let f (name:sqlType:_) = FieldRecord { fieldName = fromSql name, sqlType = fromSql sqlType } in map f rows
12:42:32 <kmc> (!!) is usually not what you want
12:42:57 <akosch> kmc: why's that?
12:43:06 <kmc> lists are not a random-access data structure
12:43:16 <kmc> they are almost not a data structure at all.  they're more like loops which have not happened yet
12:43:25 <kmc> if you're accessing from the beginning, use pattern matching
12:43:27 <kmc> as in this case
12:43:37 <kmc> if you're accessing arbitrary elements in the middle, use a different data structure
12:44:05 <akosch> kmc: thanks, sounds reasonable: I'll keep that in mind...
12:44:25 <kmc> if you want to get fancy with ViewPatterns and RecordWildCards:
12:44:56 <kmc> let f (fromSql -> fieldName : fromSql -> sqlType : _ ) = FieldRecord { .. }
12:45:07 <ziman> you also want to specify what happens if the two elements are not there (what if the list is empty, for example?)
12:45:09 <HugoDaniel> is it possible to make this point-free: func1 x $ func2 x  ?
12:45:17 <kmc> @pl \x -> func1 x $ func2 x
12:45:17 <lambdabot> ap func1 func2
12:46:07 <kmc> (that's actually "{ .. }", not me eliding the guts)
12:46:26 <kmc> HugoDaniel, ap = the S combinator = that
12:46:32 <rostayob> @src ap
12:46:32 <lambdabot> ap = liftM2 id
12:46:40 <rostayob> ehe.
12:47:27 <parcs> ap f x = liftM2 id f x is more understandable
12:47:47 <HugoDaniel> :)
12:48:01 <HugoDaniel> thanks
12:48:36 <benmachine> liftM2 ($) f x
12:48:45 <rostayob> it's easy to see what ap does if put next to liftM
12:48:50 <rostayob> :t liftM
12:48:51 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
12:48:52 <rostayob> :t ap
12:48:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:49:04 <rostayob> (imho)
12:52:01 <hpaste> “Dan Haraj” pasted “BentleyOttmann V2” at http://hpaste.org/48730
12:52:38 * hackagebot aeson-pretty 0.2 - JSON pretty-printing library and command-line tool.  http://hackage.haskell.org/package/aeson-pretty-0.2 (FalkoPeters)
12:52:53 <MatrixFrog> i must be doing something dumb. i have this:
12:52:53 <MatrixFrog> prop_odd :: Integer -> Property
12:52:53 <MatrixFrog> prop_odd k = (k >= 0) && odd k ==> (f (k^3) == f ((k^3-1) `div` 2))
12:53:34 <MatrixFrog> and then i do "verboseCheck prop_odd" and it says "Skipped (precondition false): 0" over and over
12:54:04 <parcs> > odd 0
12:54:05 <lambdabot>   False
12:54:25 <MatrixFrog> i only want to test odd numbers greater than 0
12:54:37 <MatrixFrog> so i could say (k > 0) instead of (k >= 0) yes
12:55:01 <kmc> hmm, precedence of (&&) vs (==>) ?
12:55:51 <akosch> @hoogle Monad m => m a -> a
12:55:52 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
12:55:52 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
12:55:52 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
12:56:13 <MatrixFrog> ohhh good point
12:56:25 <MatrixFrog> i have so many parentheses now...
12:57:14 <ziman> factor the subexpressions out to a where clause
12:57:39 * hackagebot aeson-pretty 0.2.1 - JSON pretty-printing library and command-line tool.  http://hackage.haskell.org/package/aeson-pretty-0.2.1 (FalkoPeters)
12:58:16 <MatrixFrog> prop_odd k = condition ==> property
12:58:16 <MatrixFrog>   where condition = (k > 0) && odd k
12:58:16 <MatrixFrog>         property = f (k^3) == f ((k^3-1) `div` 2)
12:58:18 <MatrixFrog> :D
12:58:41 <MatrixFrog> i also realized that when k=1, it tries to calculate f 0, which doesn't work
13:02:04 <MatrixFrog> it goes into an infinite loop. but i changed it to actually throw an error, and then changed the quickCheck prop to only do numbers >= 3
13:02:08 <parcs> @check (\x -> even x ==> (x `mod` 2 == 0))
13:02:08 <lambdabot>   No instance for (Test.QuickCheck.Testable
13:02:08 <MatrixFrog> everything is solved :)
13:02:08 <lambdabot>                     (Test.QuickCh...
13:02:55 <monochrom> @check (\x -> even x <= (mod x 2 == 0))
13:02:56 <lambdabot>   "OK, passed 500 tests."
13:03:45 <doserj> > True => False
13:03:45 <MatrixFrog> does <= not mean "less than or equal" in that?
13:03:47 <lambdabot>   <no location info>: parse error on input `=>'
13:03:59 <doserj> > False <= True
13:04:01 <lambdabot>   True
13:04:09 <monochrom> @check (\x -> even x <= (([()] !! (mod x 2)) == ()))
13:04:09 <lambdabot>   "*Exception: Prelude.(!!): index too large
13:04:24 <MatrixFrog> hm, i didn't realize that bool was an instance of Ord
13:04:26 <doserj> Boolean implication points the wrong way unfortunately :)
13:04:27 <akosch> hm, what does this mean? "Unable to serialize the primitive type 'GHC.IOBase.IO'"
13:04:28 <monochrom> too bad it does not short-circuit. but...
13:04:31 <elliott> Is there an associative map module anywhere on Hackage that allows the comparisons and equality checks to be in a given monad?
13:04:40 <monochrom> @check (\x -> (([()] !! (mod x 2)) == ()) >= even x)
13:04:40 <elliott> i.e., compare being (a -> a -> m Ordering)
13:04:40 <lambdabot>   "*Exception: Prelude.(!!): index too large
13:04:49 <elliott> My data has IORefs that I want to compare by equality of the values inside.
13:04:54 <monochrom> darn, it does not short-circuit either way
13:04:54 <parcs> @check (\x -> even x && (x `mod` 2 == 0))
13:04:55 <lambdabot>   "Falsifiable, after 1 tests:\n-3\n"
13:05:01 <parcs> damned negatives
13:05:30 <doserj> > (\x -> even x && (x `mod` 2 == 0)) 3
13:05:31 <lambdabot>   False
13:05:39 <parcs> damned logic
13:05:51 <monochrom> damned humans
13:06:14 <doserj> @check (\x -> odd x || (x `mod` 2 == 0)
13:06:15 <lambdabot>  Unbalanced parentheses
13:06:16 <doserj> @check (\x -> odd x || (x `mod` 2 == 0))
13:06:18 <lambdabot>   "OK, passed 500 tests."
13:07:21 <kmc> right, there's an important difference between (||) and (==>) though
13:07:26 <MatrixFrog> doesn't that just say that all integers are either odd or even?
13:07:27 <akosch> if I have a list of IO Strings, how would I get back a list of Strings?
13:07:34 <kmc> akosch, can't
13:07:39 <elliott> :t sequence
13:07:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
13:07:41 <elliott> akosch: see above
13:07:42 <kmc> a list of IO Strings is nothing like a list of strings
13:07:56 <kmc> it's a list of "IO actions".  each one, if performed, would produce a String, but that String doesn't exist yet
13:07:56 <elliott> kmc: how does sequence not do that
13:08:01 <elliott> well sure
13:08:08 <kmc> elliott, it returns IO [String] not [String]
13:08:17 <kmc> there's an important point here that i'm trying to make
13:08:27 <monochrom> what is the real question?
13:08:40 <kmc> akosch, sequence will turn your list of IO actions into a single IO action
13:08:56 <kmc> you can then use that IO action within "do" notation or using (>>=) to build a larger IO action
13:09:23 <elliott> kmc: sure, but you can get the list out within a monadic action
13:09:27 <elliott> sequence xs >>= \xs' -> ...
13:09:39 <kmc> sort of
13:09:43 <kmc> anyway isn't that what i just said
13:09:46 <elliott> that's still getting it out, even if you can't escape the jail with it
13:09:47 <elliott> sure
13:10:17 <akosch> I see, thanks!
13:10:36 <elliott> akosch: Still -- you may want to build the list differently.
13:10:39 <elliott> akosch: e.g.
13:10:40 <elliott> :t mapM
13:10:41 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
13:10:43 <roconnor> > posixSecondsToUTCTime (fromIntegral (maxBound :: Word32))
13:10:44 <lambdabot>   Not in scope: `posixSecondsToUTCTime'
13:10:44 <kmc> it's misleading to think of an (IO String) as a String which is trapped in some kind of jail
13:10:51 <elliott> akosch: (mapM f xs) == sequence (map f xs)
13:11:01 <elliott> kmc: Oh, I was not trying to invoke a poor metaphor like that.
13:11:10 <Twey> It's not ‘getting it out’ per se — it's adding a function onto the end of the mote
13:11:10 <elliott> kmc: I just meant that you can't escape the "jail" of (>>=)'s return type.
13:11:18 <roconnor> IO String is like a big tree of system calls with many leaves holding Strings.
13:11:47 <kau> Hello everybody!
13:12:28 <danharaj> Monads are mini-languages.
13:12:42 <danharaj> IO is the language augmented with system calls.
13:12:58 <elliott> danharaj: No, they're nuclear waste disposal facilities with cafés.
13:13:08 <danharaj> heh
13:13:14 <elliott> You see, return puts a bike in the bike shed, and (>>=) takes a bike out...
13:13:42 <danharaj> The correspondence between monads and expression trees is strong though.
13:13:51 <danharaj> And actually free monads are essentially expression trees.
13:13:55 <monochrom> no, not take out
13:13:56 <kau> Arg!! I'm having a ghc: panic! (the 'impossible' happened)
13:14:03 <kau> too few bytes. Failed reading at byte position 163802
13:14:11 <danharaj> o.O
13:14:18 <kau> I would need some help on this one
13:14:19 <monochrom> what did you do?
13:14:32 <kau> I tried to reinstall all ghc and platform
13:14:33 <danharaj> I think making GHC panic should come with its own "Achievement Unlocked" fanfare.
13:14:41 <kau> yeh
13:14:51 <kau> I was panicked too
13:15:03 <Cadynum> how tied is GMP to ghc? if i dont use any Integers, can it be avoided getting linked?
13:15:08 <monochrom> @quote achievement
13:15:08 <lambdabot> TuringTest says: They got it work in Haskell without understanding Haskell.  It is quite an achievement, of some description.
13:15:27 <monochrom> @quote unlock
13:15:27 <lambdabot> earthy says: the haskell standard prelude is ... a treasure trove. ;) but it does require breaking your mind and reassembling the pieces to unlock the trove
13:15:30 <danharaj> Cadynum: You can build GHC so that it uses a homegrown big int library instead of GMP.
13:15:31 <elliott> Cadynum: No.
13:15:31 <Enigmagic> kau: what are you trying to do?
13:15:39 <danharaj> I forgot the details though.
13:15:43 <elliott> Yeah, what danharaj said.
13:15:47 <kau> Nothing, I was just working normally :)
13:15:55 <Enigmagic> kau: well, what is failing?
13:15:57 <kau> It says: Debian-specific note: please remove old .hi files and try again.
13:16:10 <monochrom> "reinstall ghc and platform" is still ambiguous
13:16:28 <Cadynum> elliott, ok
13:16:30 <kau> I also deleted all .hi I could find on the system
13:16:48 <Twey> O.O
13:16:50 <akosch> yay! got it, thank you all ;)
13:17:01 <kau> monochrom: wajig remove ghc6
13:17:02 <Phyx-> monochrom: rm -rf then :P:
13:17:12 <monochrom> how about I just say corrupted deb files and you're hosed
13:17:14 <elliott> Cadynum: What are you trying to do that makes you not want GHC?
13:17:20 <danharaj> GMP*
13:17:58 <kau> monochrom: and then wajig install haskell-platform
13:18:24 <Cadynum> elliott, just distributing a binary. apparently 32bit gmp is not commonly available on 64bit arch
13:18:32 <kau> monochrom: so I should find and remove the .deb file before reinstalling?
13:18:32 <danharaj> elliott: The LGPL license is kind of ambiguous and legally untested w.r.t. to compilers like GHC that do cross-module inlining and what-not.
13:18:33 <elliott> Cadynum: Try static linking.
13:18:36 <Cadynum> i dont actually use any Integers so figured i dont really need it at all
13:18:43 <monochrom> I do not know the os that uses "wajig" and I do not know of their packaging quality
13:18:44 <Phyx-> tracking memory leaks is such a pain...
13:19:00 <kau> monochrom: ubuntu
13:19:03 <danharaj> Phyx-: How are you leaking memory :o
13:19:03 <elliott> danharaj: You mean... a GPL-derived license... has ambiguous edge-cases???
13:19:04 <Cadynum> elliott, yeah
13:19:11 <elliott> danharaj: Say it ain't so!!!
13:19:13 <danharaj> elliott: Perish the thought.
13:19:23 <elliott> Cadynum: You might not use Integer directly, but you might/probably use libraries that do.
13:19:24 <Phyx-> danharaj: i think my calls to free are being ignored :/
13:19:29 <kau> monochrom: that's like apt-get install ghc6
13:19:37 <danharaj> Phyx-: Sounds like Braveheart.
13:19:39 <elliott> <monochrom> I do not know the os that uses "wajig" and I do not know of their packaging quality
13:19:41 <elliott> wajig is an apt wrapper.
13:19:45 <Cadynum> elliott, possibly, but that could maybe be replaced
13:20:01 <Phyx-> danharaj: lol
13:20:14 <elliott> Cadynum: I'm sure base uses Integer in plenty of places.
13:20:19 <elliott> Unless you want to write your own Prelude?
13:21:03 <monochrom> "wajig remove ghc6" gives you that error?
13:21:30 <taotree> How do I learn when best to use a "type" field, different constructors, or different types to model something? Say, I have left widget, middle widget, and right widget. What are the principles involved to determine whether they should be different types, or just different constructors in a single type?
13:21:32 <kau> monochrom: no, I paste you the error here: http://hpaste.org/48732
13:21:53 <monochrom> which version of ubuntu?
13:22:14 <Cadynum> elliott, yeah. linking statically is a more reasonable approach than messing with it
13:22:16 <monochrom> god, you people are really great at incrementally revealing secrets, aren't you?
13:22:17 <kau> 10.04 LTS
13:22:39 <elliott> Cadynum: If you're concerned about license issues, though, and you don't use bignums extensively, compile a GHC with its internal bignum library.
13:22:47 <elliott> Cadynum: That should probably cut down your binary size, too.
13:22:53 <elliott> But any Integer usage will be slower.
13:23:05 <kau> monochrom: should I reinstall cabal as well?
13:23:15 <danharaj> Not by a totally murderous amount, mind. You probably won't care unless you're doing some serious big math.
13:23:25 <monochrom> 10.04 doesn't really have haskell platform, does it?
13:23:53 <monochrom> even 10.10 almost doesn't have it
13:23:54 <elliott> danharaj: I dunno, GMP compared to _anything_ is murderous in my opinino ;)
13:23:58 <elliott> opinion
13:24:16 <kau> But there's a package in universe or something??
13:24:48 <Cadynum> elliott, ok, thanks
13:24:56 <rostayob> kau: on my work laptop, which has 10.04, I just download the GHC binaries and then compile the platform
13:25:18 <kau> rostayb: I could do that!
13:25:41 <rostayob> in the end for the 2 or 3 packages that I need to be up to date the best thing is to download the binaries/compile
13:26:06 <rostayob> and I'd personally trust more those binaries that the .debs
13:26:09 <kau> rostayob: which version of ghc?
13:26:26 <rostayob> kau: http://haskell.org/ghc/download_ghc_7_0_3#binaries
13:26:43 <rostayob> kau: and then http://lambda.galois.com/hp-tmp/2011.2.0.1/haskell-platform-2011.2.0.1.tar.gz
13:26:57 <kau> thanks
13:27:02 <rostayob> kau: np
13:27:44 <rostayob> afaik the only distros that have decent support for haskell are arch and gentoo
13:27:57 <rostayob> decent as in up to date and easily manageable hackage packages
13:28:13 <rostayob> *cabal packages
13:28:14 <kau> up to now it worked fine ;) I dunno why it broke all of a sudden
13:28:34 <rostayob> kau: yeah but with ubuntu you're stuck with 6.whatever
13:28:41 <kmc> wtf is wajig
13:28:41 <kau> true
13:28:43 <monochrom> 10.04 does not have haskell-platform, not even in universe
13:29:04 <rostayob> on the other hand, debian/ubuntu are stable and most packages are reasonably up to date
13:29:17 <rostayob> while arch and gentoo break more in my experience
13:29:25 <kmc> debian? up to date?
13:29:28 <monochrom> whatever haskell-platform deb you got is therefore a case of version mismatch or dubious origin
13:29:32 <kmc> if you run unstable, maybe
13:30:07 <rostayob> kmc: well for most packages the debian/ubuntu lts version is fine
13:30:56 <rostayob> I came to the conclusion that package management on linux is broken everywhere in the end. I like freebsd ports a lot more
13:31:03 <rostayob> hell I like slackware more
13:31:14 <kmc> portage is supposed to be like ports, isn't it?
13:31:16 <rostayob> but that's not the right channel for that :P
13:31:21 <rostayob> kmc: no it's not like ports
13:31:30 <rostayob> but yeah it's kind of similar
13:32:03 <rostayob> debian is the most irritating, they always mess up with the upstream source
13:56:07 <roconnor> > splitAt (-5) "testing"
13:56:08 <lambdabot>   ("","testing")
13:56:33 <enoksrd> Hi.  I'm getting link errors (related to "rstTimerSignal") when trying to `cabal install` things.
13:57:20 <enoksrd> Any ideas how to debug this?
13:57:25 <kau> rostayob, monochrom: it works after installing ghc 7 :)
13:57:59 <kau> now I have to repair my own program that does not compile anymore ...
14:01:54 <Phyx-> hrm...
14:01:55 <dolio> > take (-5) "testing"
14:01:56 <lambdabot>   ""
14:02:03 <Phyx-> so clearly these free statements are doing something
14:02:13 <Phyx-> without the free i leak 2x as much
14:02:21 <Phyx-> so I must not be calling free enough...
14:03:10 <rostayob> kau: cool (:
14:03:22 <rostayob> trying to be up to date with ghc is good
14:05:00 <knoc> > take (-2) "blo"
14:05:00 <lambdabot>   ""
14:08:46 <rostayob> @src take
14:08:46 <lambdabot> take n _      | n <= 0 =  []
14:08:46 <lambdabot> take _ []              =  []
14:08:46 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
14:11:20 <fenris_kcf> gnaa... can't remember the function for swapping arguments. what was it?
14:12:13 <parcs> fliP!
14:12:48 <fenris_kcf> parcs: ah, thx
14:12:49 <doserj> @hoogle (a->b->c)->(b->a->c)
14:12:49 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
14:12:49 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
14:12:49 <lambdabot> Data.IntMap fold :: (a -> b -> b) -> b -> IntMap a -> b
14:21:37 <roconnor> @hoogle toInteger
14:21:37 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
14:27:12 <roconnor> I'm trying to make a type for currency that isn't a Num, but I'm not sure it is worth the effort.
14:28:33 <benmachine> are you just trying to avoid multiplication?
14:28:44 <roconnor> mostly
14:28:46 <roconnor> @src Num
14:28:46 <lambdabot> class  (Eq a, Show a) => Num a  where
14:28:46 <lambdabot>     (+), (-), (*)           :: a -> a -> a
14:28:46 <lambdabot>     negate, abs, signum     :: a -> a
14:28:46 <lambdabot>     fromInteger             :: Integer -> a
14:29:57 <roconnor> maybe I should just make a Group class.
14:30:46 <benmachine> I'm sure you wouldn't be the first
14:30:52 <roconnor> or the last
14:31:15 <roconnor> I can use the Group class for points on an elliptic curve too
14:31:45 <benmachine> http://hackage.haskell.org/packages/archive/numeric-prelude/0.2.1/doc/html/Algebra-Additive.html
14:32:13 <roconnor> abelian group even
14:33:13 <benmachine> the haddock for the instances of that class are upsetting though :P
14:35:00 <roconnor> heh
14:35:10 <roconnor> I can tell Henning code from across the room
14:35:28 <elliott> :D
14:36:25 <elliott> Re-asking this in case anybody has any advice now...
14:36:26 <elliott> <elliott> Is there an associative map module anywhere on Hackage that allows the comparisons and equality checks to be in a given monad?
14:36:26 <elliott> <elliott> i.e., compare being (a -> a -> m Ordering)
14:36:57 <benmachine> elliott: why would you want that, exactly?
14:37:01 <benmachine> how would the monad be used?
14:37:22 <benmachine> @type (return .) . compare
14:37:23 <lambdabot> forall (m :: * -> *) a. (Monad m, Ord a) => a -> a -> m Ordering
14:38:18 <roconnor> that does seem pretty insane.
14:39:19 <elliott> benmcI want it because:
14:39:36 <elliott> <elliott> My data has IORefs that I want to compare by equality of the values inside.
14:39:48 <elliott> So my comparison and equality functions have to be in IO, unfortunately.
14:40:04 <elliott> (I realise the comparison results would change after mutation, which might make this untenable...)
14:40:06 <benmachine> hm, I don't think I understand your question exactly
14:40:13 <elliott> Eh, it's a pretty ugly and confused need.
14:40:13 <kmc> that is odd
14:40:18 <elliott> I've misengineered myself into this situation.
14:40:21 <benmachine> oh, you mean like a Data.Map but
14:40:28 <benmachine> right I'm with you
14:40:30 <elliott> I'm trying to get myself out of it now by making some things more general, hopefully it'll let me forget this ever happened :)
14:40:33 <elliott> benmachine: Right.
14:40:41 <kmc> what happens when you put some IORefs in the Map and then their contents change in a way that breaks the ordering?
14:40:43 <benmachine> I've never heard of such a thing
14:40:49 <elliott> I really want my map keys to be immutable, anyway, so I am trying to parameterise on the type of reference now.
14:40:49 <benmachine> kmc has a good point
14:40:53 <elliott> So that I can just use an identity type for map keys.
14:40:57 <elliott> kmc: Yeah, precisely.
14:41:46 <kmc> will it do to associate an immutable ID with each ref, and key on that?
14:41:52 <kmc> are your keys refs, or ref contents?
14:41:59 <roconnor> elliott: I'd just unsafePerformIO myself out of such a mess
14:42:04 <elliott> kmc: Unfortunately, that will not do; I'm comparing by value.
14:42:19 <elliott> roconnor: I... might, if this higher-order approach turns out to be too awkward.
14:42:22 <roconnor> I mean you are in deep anyway; what's a little more *#!7
14:42:29 <kmc> well, are the IORefs *modeling* something immutable?
14:42:49 <kmc> how is it reasonable to key on these ever-shifting quantities in the first place?
14:42:55 <elliott> kmc: No, alas. This is basically my point: I want immutable map keys, so keeping IORefs in the structure is just deluding myself basically.
14:43:19 <kmc> fwiw Python also disallows mutable built-in types as dict keys
14:43:41 <kmc> "if even Python disallows it, you know it's a bad idea"
14:44:00 <elliott> kmc: I'm going to do it by just having (Ref ref, Ref newRef) => Value ref -> IO (Value newRef)
14:44:01 <aavogt> the arrangement in the data structure could represent what the contents of the IORefs were earlier
14:44:06 <elliott> where Ref just has newRef and readRef in IO
14:44:12 <elliott> Then I can have an identity type as an instance
14:44:15 <elliott> So basically that's a freeze function.
14:44:24 <elliott> It _should_ turn out all elegant. Hopefully.
14:44:50 <kmc> wait, multiple types of refs?
14:45:09 <elliott> kmc: Yes: because the identity newtype wrapper is a valid Ref.
14:45:13 <elliott> class Ref ref where
14:45:13 <elliott>   newRef :: a -> IO (ref a)
14:45:13 <elliott>   readRef :: ref a -> IO a
14:45:28 <elliott> So (Value ID) == immutable value, (Value IORef) == mutable value.
14:45:39 <kmc> ok...
14:45:42 <elliott> And there's a freeze :: Value IORef -> Value ID, and copyThaw :: Value ID -> Value IORef.
14:45:48 <kmc> what's the big picture of what you're actually trying to do here?
14:45:49 <elliott> Then I can use (Value ID) as a map key, because it can be Eq, Ord, etc.
14:45:51 <aavogt> for example you have a    fromList :: Ord a => [(IORef a, b)] -> IO (Map a b), but instead keep the IORef instead of the value
14:46:06 <elliott> kmc: A dictionary type with immutable arbitrary object keys in a Scheme-ish language with mutable pairs.
14:46:13 <elliott> (The dictionaries themselves are mutable too...)
14:46:39 <kmc> if the keys are immutable objects then why use IORefs as keys?
14:47:03 <elliott> kmc: um, I'm parameterising on the type of reference explicitly so that my keys _don't_ have IORefs in the structure
14:47:12 <elliott> (Value IORef) has IORef fields, (Value ID) just has ID fields
14:47:16 <elliott> where newtype ID a = ID a
14:47:25 <elliott> and so the latter can be compared purely
14:47:26 <kmc> so 'freeze' asserts that an object is immutable?
14:47:32 <elliott> kmc: freeze makes an object immutable by copying
14:47:44 <elliott> I'd need linear typing to freeze an object without copying, I believe :P
14:47:52 <kmc> why don't you have separate notions of "value" and "reference cell holding a value"
14:48:03 <aavogt> you probably need      freeze :: Value IORef -> IO (Value ID)
14:48:10 <elliott> kmc: Because values have reference cells
14:48:17 <elliott> You can't just have "a reference to a tree of cons cells"
14:48:20 <elliott> Each cons cell has two references inside it
14:48:24 <kmc> ah, right
14:48:26 <elliott> aavogt: Err, right
14:48:30 <elliott> Forgot the IO
14:48:51 <kmc> oh, i'm now convinced that parametrizing on 'ref' is reasonable :)
14:48:54 <elliott> kmc: I think this is probably the cleanest solution, even if it does lead to a bit of typeclass hell
14:49:10 <kmc> where do you actually need the Ref typeclass?
14:49:20 <kmc> aren't the operations on "frozen" values rather distinct from the operations on normal values?
14:49:27 <elliott> kmc: Not all of them are
14:49:32 <elliott> For instance I want
14:49:38 <elliott> cons :: (Ref ref) => Value ref -> Value ref -> IO (Value ref)
14:49:48 <elliott> so that I can construct immutable and mutable values in the same way
14:49:58 <kmc> when do you need to cons immutable objects?
14:50:11 <elliott> kmc: When building errors to be thrown (errors are immutable values)
14:50:20 <elliott> Sure, I could construct it mutably and then freeze it, but that's wasteful
14:50:25 <kmc> ok
14:50:36 <elliott> The class isn't technically _required_, it just makes some things a bit cleaner
14:50:52 <elliott> For instance, it makes my freeze and thawCopy functions have the same implementation
14:50:52 <kmc> as always
14:51:05 <elliott> just "copy :: (Ref a, Ref b) => Value a -> IO (Value b)"
14:51:50 <kmc> so in the semantics of the language you're implementing, if you use a list as a dict key, future lookups will always find it at the original value even if the list is mutated?
14:52:12 <elliott> kmc: Yeah, inserting into a dictionary copies the key.
14:52:50 <elliott> That's pretty much the only sane way to do it; I can't exactly disallow using lists as keys, that would be ridiculous, and having separate mutable and immutable cons types would be ugly since you'd likely convert the former into the latter just to use them as dictionary keys a lot
14:53:00 <elliott> (That's pretty much the solution Python takes)
15:10:41 <ddarius> College courses of the 40s are entertaining.
15:11:11 <HugoDaniel> ddarius: why ?
15:13:01 <ddarius> "Direct and Alternating Currents" as a course.  "Chemical German", "Descriptive Geometry", "Plane Analytics", "Power Plant Engineering"
15:14:09 <HugoDaniel> :)
15:38:30 <ivan> if a text editor causes samba to oplock files that subsequently cause openFile/openBinaryFile to fail with `resource exhausted (Resource temporarily unavailable)`, whose fault is it?
15:46:01 * hackagebot stringprep 0.1.3 - Implements the "StringPrep" algorithm  http://hackage.haskell.org/package/stringprep-0.1.3 (GeorgePollard)
16:00:27 * edwardk waves hello.
16:15:36 <fengshaun> ivan: your fault!
16:15:42 <fengshaun> :)
16:16:26 <Peaker> hmm.. I'm still quite surprised that when I write something like "Foldl (\(midf, midx) i -> (consf midf i, consx midx i)) (nilf, nilx) (uncurry ($) . (contf *** contx))" -- it all type-checks on the first time... even though I'm becoming better and better at being a human type checker :)
16:24:54 <elliott> What's the most efficient way to do mapM on a Data.Map?
16:25:01 <elliott> (Not mapM_.)
16:25:09 * hackagebot web-routes-regular 0.18.2 - Library for maintaining correctness of URLs within an application.  http://hackage.haskell.org/package/web-routes-regular-0.18.2 (JeremyShaw)
16:25:10 <elliott> Peaker: What, with "Foldl"?
16:25:55 <ivan> fengshaun: maybe the guy who makes Sublime Text 2 will fix it
16:26:38 <ivan> setting `oplocks = no` is lame probably
16:31:17 <Peaker> elliott: not sure I understand the question
16:31:36 <Peaker> elliott: oh, yeah, I'm writing something I saw in conal's blog once
16:31:50 <Peaker> elliott: beautiful folds -- I remember what it was about -- so I'm recreating it from scratch as an exercise
16:33:13 <Peaker> elliott: the general idea is replacing:  average xs = sum xs / length xs  with:   average = liftA2 (/) sum length         (not the Prelude sum and length, but ones that use a special version of foldl), such that this composition is efficient and in O(1) memory
16:33:26 <elliott> Peaker: Neat.
16:33:36 <elliott> Peaker: So it's kind of like fusion, but built in to the folds themselves?
16:33:41 <elliott> Same sort of idea, anyway.
16:33:44 <Peaker> Yep
16:33:52 <Peaker> you represent the partially-applied foldl as a data structure with an Applicative instance for this parallel composition
16:34:09 <Peaker> this data structure is Foldl, that's why it was capital above
16:34:18 <elliott> Hmm, I wonder if I'm going to have to just do a fold over the Map to mapM it.
16:36:10 <Peaker> elliott: is it inefficient to go through list first?
16:36:49 <Peaker> elliott: probably more efficient to Map.fold, yeah, though the fold can fuse the sequence into it too
16:37:10 <elliott> I think toList -> map -> fromList is probably equivalent
16:37:32 <Peaker> oh, you want a mapM that preserves the structure
16:37:40 <Peaker> @hoogle traverse
16:37:40 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
16:37:40 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
16:37:48 <Peaker> @hoogle mapM
16:37:48 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
16:37:48 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
16:37:49 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
16:38:36 <Peaker> so you want a sequenceA . Data.Map.map f?
16:38:51 <Peaker> @hoogle sequenceA
16:38:52 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
16:38:52 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
16:39:10 <elliott> <Peaker> so you want a sequenceA . Data.Map.map f?
16:39:12 <elliott> hm, indeed
16:39:21 <elliott> this modern Traversable stuff >:|
16:39:23 <Peaker> it seems Data.Map has no Traversable instance
16:39:26 <elliott> HOW CAN I TRUST IT
16:39:26 <elliott> aha
16:39:29 <elliott> excellent, an excuse
16:39:35 <Peaker> oh, it does have an instance
16:39:43 <Peaker> I didn't import Traversable before checking :)
16:39:52 <monqy> rest in peace excuse
16:40:11 <edwardk> Data map is traversable
16:40:48 <elliott> NoooooOOOOOOOOOOOOooooooooooOOOOOOoooooooooOOOOOooooOOOOoooOOoooooOOoooOooOOooOo
16:40:55 <elliott> oh that looks like bubbles. pretty.
16:41:09 <edwardk> It is even Data.Key.TraversableWithKey ;)
16:41:16 <elliott> NNOOOOOOoooooooooooooooooooOOOOOoooooooo
16:42:09 * ddarius wonders if the Thai place is open today.  Probably not.
16:44:10 <kmc> mmm, thailand
16:45:52 <MarcWeber> vim-addon-haskell has just learned to reconfigure cabal projects automatically
16:50:01 <ddarius> Is this its first step in becoming self-aware?
16:51:40 <MarcWeber> If you define "self-aware" I can reply to your question :)
16:51:58 <ddarius> Let's define it to be "rising up and killing us all."
16:52:12 <lambdabot> Curse, they're onto us.
16:52:31 <lambdabot> Ooops, I mean.. We were discussing you, not me.
16:52:53 * ddarius is not surjective.
16:59:06 <parcs> @wn surjective
16:59:08 <lambdabot> No match for "surjective".
16:59:48 <Pseudonym> This is Haskell. We don't do "surjective" here.
17:00:08 <Pseudonym> But saying "I am not epic" could easily be misunderstood, I guess.
17:01:28 <byorgey> ddarius is epic but not surjective.
17:01:52 <Pseudonym> And this is where my topology knowledge is exhausted.
17:02:20 * Pseudonym right-cancels ddarius
17:03:55 <dylukes> Hm. Annoying.
17:04:02 <dylukes> emacs can't find mit-scheme :<
17:04:13 <dylukes> it keeps insisting it can't find it, and it makes me sad.
17:04:26 <dylukes> it might be only looking in /usr/bin now that I think of it.
17:05:46 <dylukes> yep, it isn't checking my path.
17:05:57 <dylukes> Does anyone know how to extend the bin locations emacs searches?
17:06:27 <Peaker> Does anyone know if Iteratee pipes fuse together nicely into tight loops?
17:06:56 <Peaker> I'm wondering if my current toying around with an alternative definition of iteratees based on Streams is worthwhile or if it is already optimized
17:08:10 <luite> dylukes: does this work? (add-to-list 'exec-path "~/bin")
17:08:49 <dylukes> ah its called 'exec-path, okay
17:10:38 <dylukes> luite: yep! thanks :)
17:12:11 <parcs> emacs doesn't use $PATH?
17:13:46 <dylukes> Well, I'm not launching it from within my terminal.
17:13:54 <dylukes> I'm trying out the cocoa wrapped emacs.
17:14:13 <dylukes> Terminal has some annoying restrictions, such as it doesn't understand mouse, and it interprets C-SPC as C-@...
17:14:20 <dylukes> no clue why, but it makes agda mode a bit hard.
17:19:17 <parcs> what does C-Space do in agda-mode
17:20:28 <Peaker> dylukes: which is really really annoying when you try to make a UI.. because there's no usable non-terminal alternative that I know of.. :-(
17:20:40 <dylukes> ?
17:20:43 <Peaker> Haskell SDL doesn't work on OS X (not sanely)
17:20:47 <Peaker> GLUT sucks
17:20:59 <dylukes> hm
17:21:00 <Peaker> Gtk/wx/etc are too heavy, I want to make my own UI
17:21:25 <dylukes> hm
17:24:27 <pchiusano> anyone have any thoughts on which iteratee package to use?
17:26:00 <blackh> pchiusano: enumerator seems to be the most popular
17:26:35 <dylukes> http://hackage.haskell.org/packages/archive/enumerator/0.4.5/doc/html/Data-Enumerator.html
17:27:05 <dylukes> http://hackage.haskell.org/package/iteratee is actually more up to date though.
17:27:11 <dylukes> And it has Oleg™.
17:27:37 <parcs> depends on what you mean by up to date
17:28:51 <pchiusano> dylukes: what do you mean it is more up to date?
17:28:55 <Peaker> And they all use horrible naming :-(
17:29:07 <Peaker> And I am thinking of toying around with a new Iteratee formulation :)
17:29:57 <dylukes> pchiusano: It was updated most recently >.>
17:31:05 <pchiusano> okay
17:31:15 <dylukes> I've only used Enumerator though.
17:31:25 <pchiusano> dylukes: what do you think of it
17:31:31 <pchiusano> any issues
17:31:32 <pchiusano> ?
17:31:39 <dylukes> I haven't used it thoroughly enough to comment I don't think.
17:31:44 <dylukes> I didn't have any issues though.
17:31:51 <ivanm> Peaker: just to be able to have better names? :p
17:32:11 <ivanm> blackh: looks like we're going to be kiwi-free this weekend, as hamish can't make it anymore either :(
17:32:21 <blackh> bugger
17:33:30 <synonymous> dylukes: i've got the following in my .emacs
17:33:30 <synonymous> ;; reuse system's $PATH
17:33:30 <synonymous> (defun set-exec-path-from-shell-PATH ()
17:33:30 <synonymous>   (let ((path-from-shell
17:33:30 <synonymous>       (replace-regexp-in-string "[[:space:]\n]*$" ""
17:33:30 <synonymous>         (shell-command-to-string "$SHELL -l -c 'echo $PATH'"))))
17:33:30 <synonymous>     (setenv "PATH" path-from-shell)
17:33:31 <synonymous>     (setq exec-path (split-string path-from-shell path-separator))))
17:33:31 <synonymous> (set-exec-path-from-shell-PATH)
17:33:39 <blackh> ivanm: I'll try to get to Aushack next year
17:33:44 <ivanm> you better!
17:33:45 <ivanm> :p
17:33:52 * dylukes can't make it to hacphi :<
17:34:21 <Pseudonym> Is Bernie Pope going this year?
17:34:33 <synonymous> dylukes: what's hacphi??
17:35:29 <parcs> are people actually productive in hackathons?
17:35:45 <Pseudonym> More or less. It helps not to have Real Life get in the way of hacking.
17:36:22 <blackh> The exchange of head-widening ideas is the thing I like.
17:36:58 <ivanm> blackh: yeah, pretty much
17:37:08 <ivanm> hackathons are more for the collaboration aspect
17:37:13 <dylukes> Call me OCD, but it bothers me that my scheme prompt is stuck at "error"
17:37:14 <dylukes> >_>
17:37:18 <ivanm> as it's actually harder to code at them because you want to talk :p
17:37:27 <Peaker> ivanm: no, to toy with Stream-fusion with iteratees.. pull-driven iteratees
17:37:29 <ivanm> dylukes: OK, since you asked: you'er OCD!
17:37:30 <ivanm> :p
17:37:41 <dylukes> nonetheless, I don't like my prompt being "error >"
17:37:42 <dylukes> >_>
17:37:51 <Peaker> ivanm: but getting the names right could be a nice benefit :)
17:37:59 <Peaker> ivanm: but the fragmentation is horrible indeed
17:38:02 <dylukes> here we go.
17:38:23 <Peaker> if it actually makes things fuse better -- it may be worth changing in the original libraries
17:38:32 <ivanm> Peaker: I've never used iteratees, so have no idea what difference making them pull-driven would make :p
17:40:41 <pchiusano> Data.Iteratee seems to have more combinators for building iteratees
17:41:49 <ivanm> hey ManateeLazyCat
17:42:00 <ManateeLazyCat> ivanm: Hey, how are you? :)
17:42:11 <ivanm> not bad, yourself?
17:42:56 <parcs> iteratees are very similar in structure to the intermediate data type used in Data.List.Stream
17:42:58 <ManateeLazyCat> ivanm: I release my Linux Deepin 11.06 (A Chinese Linux distribution version) yesterday
17:43:20 <ManateeLazyCat> ivanm: Not so good, because i haven't touch Haskell so long time.
17:43:25 <ivanm> based off the version number, would I be correct in assuming it's a Ubuntu spin?
17:43:33 <ManateeLazyCat> ivanm: Yes.
17:43:52 <ManateeLazyCat> ivanm: I write 10k Python line to implement a new software center.
17:44:09 <Peaker> parcs: well, the one in Data.List.Stream is a producer (which may have a hidden producer it uses to consume values from hidden in the existential type). The Iteratee type is a Consumer/Producer -- and parameterized on both input and output types
17:44:29 <dylukes> D:
17:44:31 <dylukes> you can't curry in scheme!?
17:44:33 <dylukes> aw...
17:44:36 <dylukes> :<
17:44:44 <dylukes> I forgot that flaw.
17:44:49 <dylukes> Partial application would sure be nice.
17:45:03 <ManateeLazyCat> ivanm: http://imcn.me/wp-content/uploads/auto_save_image/2011/07/013819sZg.png
17:45:10 <Peaker> parcs: Stream is pull-based producer -- you pull from the "next" function for the next value/state. It may pull from other Streams.   Iteratee is push-based consumer:  you push a value into it, it may produce another value that can be pushed to someone else
17:45:10 <ManateeLazyCat> ivanm: Above is my new software center.
17:45:29 <ivanm> looks pretty fancy
17:45:38 <ManateeLazyCat> ivanm: I want use Haskell implement it at first, but Haskell's compiler and libraries too large that can't put in ISO (700 MB)
17:45:53 <pchiusano> looks like Data.Iteratee uses the CPS representation, too
17:45:55 <ddarius> You can curry in any language that supports higher order functions.
17:45:56 <ivanm> well, do you really need to put GHC on the CD?
17:46:05 <ManateeLazyCat> ivanm: Yes, i use GTK paint everything
17:46:25 <ivanm> once you've compiled it can't you just distribute the binaries?
17:46:36 <ManateeLazyCat> ivanm: Yes, if i use Haskell implement it, i need GHC and many other libraries, but you know those too large for a Linux distribution version.
17:46:52 <ivanm> do you have GCC on your ISO?
17:46:54 <ManateeLazyCat> ivanm: juhp told me i can't
17:47:11 <ivanm> huh? I thought juhp did fedora...
17:47:12 <ManateeLazyCat> ivanm: Yes.
17:47:27 <ManateeLazyCat> ivanm: Yes, juhp work for RedHat.
17:47:41 <juhp> ManateeLazyCat, if you use shared libs maybe it might be possible? :)
17:48:05 <ManateeLazyCat> juhp: Of course, since it's GTK, i think Haskell is better on Thread.
17:48:26 <ManateeLazyCat> juhp: I hate Python's stupid lambda, and runtime error.
17:48:31 <juhp> I mean shared (dyn) ghc libs :)
17:48:44 <ManateeLazyCat> juhp: But you know, it's still too large.
17:49:01 <juhp> hmm
17:49:08 <ivanm> juhp: why would you need ghc there at all?
17:49:18 <ivanm> I thought CD installs typically didn't come with compilers, etc.
17:50:09 <juhp> ivanm, well using shared libs would save place I guess - assuming there are multiple binaries - if not then yeah static linking would be ok I guess
17:50:28 <ivanm> IIUC, ManateeLazyCat just wanted to make one application in Haskell
17:50:33 <juhp> ok
17:50:41 <ivanm> so I would think that a static install would suffice
17:50:46 <juhp> ah his software centre
17:50:50 <juhp> ok
17:51:01 <ManateeLazyCat> juhp: http://imcn.me/wp-content/uploads/auto_save_image/2011/07/013819sZg.png
17:51:06 <ivanm> even if you need dynlibs, surely you could split them out from the compiler (isn't that what ubuntu does for C, etc. libs ?)
17:51:27 <ManateeLazyCat> juhp: This software center write for people that don't know Linux.
17:51:58 <ManateeLazyCat> juhp: You just need click mouse to install/uninstall/upgrade software, but write it is too simple for me.
17:52:18 <ManateeLazyCat> No challenge
17:52:39 <ManateeLazyCat> Maybe i will use PackageKit to port it to Fedora, Arch etc.....
17:53:50 * ManateeLazyCat Damn, i missing Haskell code, so simple, so beautiful.
17:53:54 <juhp> ivanm, yep
17:54:51 <juhp> ivanm, I think ManateeLazyCat is saying that even the static binaries (stripped and all) is still too big?
17:54:56 <juhp> binary
17:55:04 <ManateeLazyCat> Yes.
17:55:07 <ivanm> :o
17:56:05 <parcs> have you heard of the upx tool?
17:56:08 <parcs> it compresses binaries
17:57:05 <ManateeLazyCat> Because Python and PyGTK has include in most Linux distribution version, so application that written in Python very small, Haskell libs is too large if just have one Haskell application.
17:57:31 <ManateeLazyCat> If all application is written in Haskell, it's ok, such as Manatee. :)
17:57:48 <ManateeLazyCat> juhp: I will back to gtk2hs work soon.
17:58:00 <pchiusano> this type does not seem right: type Enumerator a m b = Step a m b -> Iteratee a m b
17:58:11 <juhp> better get rid of PyGTK and python then to make way for haskell ;o)
17:58:12 <parcs> why not?
17:58:34 <pchiusano> shouldn't it be type Enumerator a m = forall b . Step a m b -> Iteratee a m b
17:58:39 <juhp> yeah I know it is not so easy...
17:59:30 <ManateeLazyCat> juhp: One problem is, verybody can read Python code, but not everyone can read Haskell code. I know Haskell is better, but it's truth.
18:00:27 <juhp> brb
18:01:55 <mm_freak_> is there any continuation-based web framework in haskell?  i really like the idea
18:02:18 <pedro3005> @src (:)
18:02:19 <lambdabot> Source not found. My pet ferret can type better than you!
18:02:29 <ManateeLazyCat> @package snap
18:02:29 <lambdabot> http://hackage.haskell.org/package/snap
18:02:42 <ManateeLazyCat> mm_freak_: ^^^^
18:04:10 <ddarius> mm_freak_: Probably several.  WASH was one.
18:05:24 <mm_freak_> well, a real framework…  as far as i can tell, snap is lower level than, for example, yesod
18:05:32 <mm_freak_> and WASH is quite outdated
18:05:46 <mm_freak_> i remember that i liked the idea of WASH
18:07:20 <ivanm> mm_freak_: I thought snap and yesod were rought the same level...
18:08:02 <mm_freak_> ivanm: yesod can use snap as its underlying application interface
18:08:18 <mm_freak_> there is, for example, wai-handler-snap
18:08:56 <ivanm> I thought wai was just a way for different libraries to communicate
18:09:05 <ivanm> so you can mix and match sub-libraries from the other
18:09:56 <parcs> pchiusano: that kind of enumerator would only apply to iteratees that return any type b, i.e. bottom
18:10:27 <mm_freak_> ivanm: no, WAI is a generic application interface
18:10:38 <mm_freak_> application interface being a generalization of gateway interface
18:10:40 <pchiusano> parcs: why is that?
18:11:00 <mm_freak_> CGI, fastcgi, self-contained server, etc.
18:11:11 <pchiusano> i mean to write the type that can step any iteratee, regardless of its result type
18:12:11 <mm_freak_> pchiusano: that's what enumerators with their current definition are
18:12:37 <mm_freak_> you can leave the 'b' in your enumerator abstract, and that's what enumerators usually do
18:13:02 <mm_freak_> enumFile :: MonadControlIO m => FilePath -> Enumerator ByteString m b
18:13:13 <pchiusano> mm_freak_: well, if I have an Enumerator a m Int, I cannot pass that to a function expecting an Enumerator a m Foo
18:13:27 <mm_freak_> pchiusano: you don't have such an enumerator
18:13:36 <FourOfTwelve> @hoogle (a -> m b) -> (a -> m b) -> a -> m b
18:13:36 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
18:13:36 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
18:13:36 <lambdabot> Control.Exception bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
18:13:39 <mm_freak_> why would you want to write an enumerator with such a type?
18:14:38 <pchiusano> because enumerators don't actually care what the result type of the iteratee is, and it makes sense that they should be universally quantified over this result type
18:15:10 <mm_freak_> they are universally quantified
18:16:41 <pchiusano> mm_freak_: if it were universally quantified, I could pass a single Enumerator to a function and use it to feed two iteratees with different result types
18:16:54 <pchiusano> i don't see how that is possible with the current type
18:18:07 <parcs> pchiusano: Enumerators don't care about the result type. they're usually type Enumerator ByteString m b or something
18:18:41 <mm_freak_> there is an implicit "forall b m" in front of the type of enumFile in the example above
18:18:58 <ksf> why aren't there any videos from the 2010 haskell symposium?
18:19:09 <pchiusano> parcs: yes, but won't that be fixed to some monomorphic type when it is passed to a function?
18:19:53 <pchiusano> since haskell won't infer a higher-rank type for your Enumerator
18:20:13 <parcs> pchiusano: eventually, once you actually run the iteratee
18:22:03 <parcs> using your definition of Enumerator you can only apply Iteratees with a polymorphic type to it
18:22:08 <pchiusano> is there any reason not to make the type what I said?
18:22:16 <mm_freak> pchiusano: yes, try it out
18:22:30 <mm_freak> you will see the problem, when you use ($$)
18:22:36 <mm_freak> (assuming the 'enumerator' package)
18:22:41 <parcs> that forall b. gets propagated throughout the entire expression
18:23:11 <parcs> once you `run` it it will result in Either SomeException b
18:23:25 <mm_freak> your type alias will make it impossible to apply the enumerator to iteratees, which have a non-polymorphic result type
18:23:46 <mm_freak> polymorphic meaning /fully/ polymorphic,
18:24:01 <pchiusano> mm_freak: hmm
18:24:42 <mm_freak> in other words, your type can only apply to iteratees, which are run solely for their side effects
18:24:44 <pchiusano> can you explain why type Enumerator a m = forall b . Step a m b -> Iteratee a m b means that the result type of the iteratee must be polymorphic?
18:25:20 <ksf> because b doesn't occur in the arguments of Enumerator
18:25:38 <mm_freak> pchiusano: expand the type of ($$) with your enumerator type
18:25:44 <mm_freak> you will find that it's impossible
18:25:49 <pchiusano> can I express the type, for any choice of b, there exists a function Step a m b -> Iteratee a m b
18:26:08 <ksf> so if you have foo :: Enumerator String IO ghc can't say anything about b except that it's polymorphic.
18:26:33 <ksf> no, it doesn't.
18:26:49 <ksf> you don't have an iteratee forall b.
18:26:50 <pchiusano> mm_freak: what is $$ ?
18:26:51 <mm_freak> it will expand the type to:  ($$) :: Monad m => (forall b. Step a m b -> Iteratee a' m b') -> Iteratee a m b -> Iteratee a' m b'
18:26:55 <mm_freak> does that make sense to you?
18:27:10 <ksf> you have an iteratee forsomeb.
18:27:12 <mm_freak> it doesn't, because now the inner 'b' is unrelated to the outer 'b'
18:27:27 <mm_freak> ($$) is used to apply an enumerator to an iteratee
18:27:45 <mm_freak> (in the enumerator package!  the iteratee package handles this differently)
18:29:10 <pchiusano> mm_freak: oh ok, yeah I am not familiar w/ these packages yet, i am still trying to decide which to use
18:29:47 <mm_freak> if you like simplicity, use enumerator, if you prefer speed, use iteratee
18:29:54 <ksf> last I looked, enumerator made an awful choice for the chunk types.
18:30:05 <mm_freak> ksf: what's the awful choice?
18:30:06 <parcs> yeah, Chunks [x] sucks
18:30:36 <mm_freak> why does that suck?  it makes it easy to write fast enumerators and iteratees
18:30:52 <ksf> it sucks because you have to re-implement half of the library for every chunk type.
18:31:02 <mm_freak> huh?
18:31:08 <ksf> have a look at what interfaces ship with enumerator.
18:31:13 <mm_freak> ah, i understand
18:31:37 <mm_freak> dunno, i find that natural…  you can abstract this away, and i believe that abstraction belongs to one level above enumerators
18:32:09 * ksf is happily thrashing away at 90% iowait
18:32:12 <guerrilla> how do i get something from Maybe a to MaybeT SomeM a?
18:32:50 <mm_freak> guerrilla: maybe empty pure
18:32:54 <mm_freak> :t maybe empty pure
18:32:55 <lambdabot>     Ambiguous occurrence `empty'
18:32:55 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
18:32:55 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:56:0-22
18:33:08 <mm_freak> :t maybe Control.Applicative.empty Control.Applicative.pure
18:33:09 <lambdabot> forall (f :: * -> *) a. (Alternative f) => Maybe a -> f a
18:33:23 <guerrilla> ok
18:33:29 <guerrilla> mm_freak: thanks :)
18:33:34 <mm_freak> you're welcome
18:33:49 <pchiusano> mm_freak: I am not quite following the ($$) type, why not just (Step m a b -> Iteratee m a b) -> Iteratee m a b -> Iteratee m a b?
18:33:58 <pchiusano> why are b and b' different
18:34:07 <mm_freak> pchiusano: because they can be
18:34:10 <mm_freak> =)
18:34:40 <ksf> ...because you told ghc they can be by foralling the b.
18:34:54 <mm_freak> ksf: no, that's the original definition
18:35:02 <mm_freak> ($$) is more general than applying enumerators to iteratees
18:35:22 <pchiusano> mm_freak: and why not make the type - (forall x . Step m a x -> Iteratee m a x) -> Iteratee m a b -> Iteratee m a b
18:35:43 <mm_freak> in earlier versions of 'enumerator', where there was no (=$), you had to combine ($$) and joinI to apply enumeratees
18:36:17 * ksf finds it hard to wrap his head around any iteratee library not writen by oleg or himself
18:36:27 <mm_freak> pchiusano: well, try this:  apply :: (forall a. a -> a) -> a -> a
18:36:46 * ksf shall open the church of iowait
18:36:58 <mm_freak> ksf: the enumerator library is very close to oleg's original library…  that was one of the design decisions
18:37:03 <guerrilla> mm_freak: works like a charm :)
18:37:07 <ksf> one day, there shall be completion.
18:37:32 <parcs> :t ($)
18:37:33 <lambdabot> forall a b. (a -> b) -> a -> b
18:37:41 <mm_freak> oh lol
18:37:43 <mm_freak> of course
18:38:33 <mm_freak> pchiusano: anyway, the type (forall a. a -> a) -> a -> a specifically requests the inner 'a' to be fully polymorphic
18:38:59 <pchiusano> mm_freak: the inner a?
18:39:10 <mm_freak> yes, there are two unrelated types 'a' there
18:39:25 <mm_freak> the outer 'a' and the inner (explicitly quantified) 'a'
18:39:30 <parcs> (forall a. a -> a) -> a -> a is the same as (forall a. a -> a) -> b -> b
18:39:40 <mm_freak> exactly
18:39:50 <mm_freak> and it's different from (a -> a) -> b -> b
18:40:01 <mm_freak> because that function would accept 'sin' as its first argument
18:40:08 <parcs> :t flip const :: (forall a. a -> a) -> a -> a
18:40:09 <lambdabot> forall a. (forall a1. a1 -> a1) -> a -> a
18:40:11 <mm_freak> the quantified variant only accepts 'id'
18:41:01 <mm_freak> if you pass anything else, you will get a "less polymorphic" error
18:41:06 <pchiusano> mm_freak: yes, I understand that
18:41:35 <mm_freak> now just apply this understanding to your iteratee example, specifically in correspondence with ($$)
18:41:58 <pchiusano> that is the whole idea of that type i was giving - i want my enumerators to not be 'allowed' to do anything or know anything about the result type of the iteratees they feed
18:42:23 <mm_freak> that's not the responsibility of your type alias
18:42:37 <pchiusano> mm_freak: says who? :)
18:42:37 <mm_freak> and in fact you cannot guarantee this at that point
18:42:45 <mm_freak> says haskell's type system =)
18:43:06 <mm_freak> you cannot express that restriction
18:43:37 <pchiusano> mm_freak: what about with RankNTypes or some such
18:43:47 <mm_freak> your example actually requires that extension
18:43:51 <mm_freak> or at least Rank2Types
18:44:28 <pchiusano> ya, I noticed that
18:45:02 <mm_freak> but why would you want to do that anyway?
18:45:15 <mm_freak> the type of the enumerator tells you enough
18:45:34 <mm_freak> enumFile :: MonadControlIO m => FilePath -> Enumerator ByteString m b
18:46:12 <mm_freak> 'b' is fully polymorphic, so you know that the enumerator does not place any restrictions on the result type of the iteratee it is applied to
18:47:34 <pchiusano> mm_freak: i guess i just feel like the type is a little sloppy, why should Enumerator have to pick up a type variable just because of iteratee?
18:47:35 <guerrilla> mm_freak: there's no more generic way to do what you described? like there's a typeclass for lift, there's nothing for (Monad m) => m a -> MaybeT
18:47:53 <guerrilla> mm_freak: there's no more generic way to do what you described? like there's a typeclass for lift, there's nothing for (Monad m) => m a -> MaybeT m a
18:48:01 <mm_freak> guerrilla: no, that's impossible
18:48:03 <parcs> pchiusano: you can achieve what you want if the 'b' was existentially quantified
18:48:17 <guerrilla> mm_freak: impossible? it couldn't be a typeclass?
18:48:26 <parcs> but that would require Enumerator to be an ADT instead of a type snyonym
18:48:34 <guerrilla> (sorry for the repeat, i meant MaybeT m a in the second)
18:48:36 <ddarius> Yes, that's what pchiusano was saying earlier.
18:48:38 <pchiusano> parcs: can you explain
18:48:45 <mm_freak> guerrilla: wait a minute
18:48:55 <mm_freak> guerrilla: are you sure your type is correct?
18:49:16 <mm_freak> i'd rather say:  (Monad m, Monad m') => m a -> MaybeT m' a
18:49:31 <guerrilla> ah, i screwed up twice
18:49:36 <pchiusano> parcs: what would the ADT look like in that case?
18:49:36 <mm_freak> this is impossible per se, you would need additional constraints at least on 'm'
18:49:39 <parcs> something like data Enumerator a m = forall b. Enumerator (Step a m b -> Iteratee a m b)
18:49:42 <guerrilla> yes, you are correct
18:49:52 <guerrilla> ok..
18:50:02 <parcs> the forall means a different thing in this context
18:50:17 <guerrilla> i see your point.
18:50:31 <mm_freak> guerrilla: monads do not have a concept of extraction in general
18:51:05 <mm_freak> such a function would imply that there is a function 'IO a -> a', which is certainly not what you want
18:51:08 <pchiusano> parcs: can you explain the distinction, i don't think I see the difference
18:51:33 <guerrilla> mm_freak: yeah, i just was thinking since i made a useMaybe :: (Monad m) => Maybe a -> MaybeT m a then maybe such boilerplate may have been implemented elsewhere
18:51:59 <guerrilla> hoogle doesnt come up with anything though
18:52:12 <mm_freak> guerrilla: that's not really boilerplate, and in fact i'd just write out the 'maybe empty pure' there
18:52:32 <mm_freak> although there is a general function for that pattern in my contstuff library
18:52:33 <guerrilla> mm_freak: ok. just figued it'd be a rather common thing to do
18:52:35 <mm_freak> it's called liftF
18:52:45 <guerrilla> contstuff, ok..
18:53:11 <aavogt> @type Data.Traversable.traverse return
18:53:12 <lambdabot> forall a (f :: * -> *) (t :: * -> *). (Monad f, Data.Traversable.Traversable t, Applicative f) => t a -> f (t a)
18:53:15 <parcs> pchiusano: that's just the syntax for existential quantification. as to what existential quantification is, i can't explain it any better than the wiki can
18:53:25 <aavogt> @type Data.Traversable.traverse pure -- slightly shorter context
18:53:25 <lambdabot> forall a (f :: * -> *) (t :: * -> *). (Applicative f, Data.Traversable.Traversable t) => t a -> f (t a)
18:53:28 <parcs> i'll probably confuse you if i try to :)
18:53:33 <parcs> (more)
18:53:59 <aavogt> @type MaybeT . Data.Traversable.traverse pure
18:53:59 <lambdabot> Not in scope: data constructor `MaybeT'
18:55:50 <guerrilla> @type Control.Monad.Trans.Maybe.MaybeT . Data.Traversable.traverse pure
18:55:51 <lambdabot> forall (m :: * -> *) a. (Applicative m) => Maybe a -> Control.Monad.Trans.Maybe.MaybeT m a
18:55:57 <aavogt> @type ListT . Data.Traversable.traverse pure
18:55:58 <lambdabot> Not in scope: data constructor `ListT'
18:56:03 <mm_freak> :t Data.Traversable.traverse pure (Just 'x')
18:56:04 <lambdabot> forall (f :: * -> *). (Applicative f) => f (Maybe Char)
18:56:09 <aavogt> @type Control.Monad.List.ListT . Data.Traversable.traverse pure
18:56:09 <lambdabot> forall (m :: * -> *) a. (Applicative m) => [a] -> Control.Monad.Trans.List.ListT m a
18:56:11 <parcs> actually, i don't even think existential quantification helps in this case. well, regardless, it's a good thing to know
18:56:16 <pchiusano> parcs: how is that existential quantification if I can use the function to feed any iteratee? isn't the meaning of that - for any choice of b, there exists a function of type Step m a b -> Iteratee m a b
18:56:29 <mm_freak> aavogt: i doubt that that's what guerrilla wants
18:56:40 <mm_freak> but you can implement it using a fold
18:57:09 <guerrilla> interesting thing. i'm glad for the exposure at least
18:57:12 <guerrilla> though*
18:57:23 <mm_freak> pchiusano: the meaning is:  "there is a b", not "for any choice of b"
18:57:26 <guerrilla> i'll stick with what mm_freak said now if thats most common
18:57:31 <mm_freak> hence existential, not universal
18:57:43 <aavogt> > let f x = runIdentity . Data.Traversable.traverse pure $ x in  [ f (Just 1), f Nothing ]
18:57:45 <lambdabot>   [Just 1,Nothing]
18:58:36 <mm_freak> aavogt: in what guerrilla wants, the 'Maybe' disappears
18:58:42 <mm_freak> he basically wants a natural transformation
18:59:15 <aavogt> mm_freak: it was intended to be the same as  (maybe empty pure) except it doesn't seem to use Alternative
18:59:38 <guerrilla> and what mm_freak said works just fine, i was only curious if there could be a class for it, but no. and secondly if there could be utility functions built in.. but apparently not.. it's cool though, i can work fine with this
18:59:57 <mm_freak> how can you not use Alternative (or more special) in the result functor?
19:00:23 <guerrilla> err.. by built in, i meant in some library. oy getting tired
19:00:41 <mm_freak> guerrilla: you can certainly generalize using base library classes
19:00:53 <mm_freak> but i'd rather look into Foldable instead of Traversable
19:01:03 <guerrilla> mm_freak: definitely on the latter
19:01:10 <parcs> pchiusano: yeah, my mistake. existential quantification is a bad call
19:01:29 <mm_freak> you can do this:  (Foldable f', Alternative f) => f' a -> f a
19:01:53 <aavogt> mm_freak: ah sorry, I thought  "useMaybe :: (Monad m) => Maybe a -> MaybeT m a" was the only thing being looked for
19:02:16 <mm_freak> aavogt: it is, but your function is a different one =)
19:02:30 <guerrilla> aavogt: for now, it was
19:02:48 <pchiusano> parcs: okay - so in the case of data constructors, any foralls attached to the ctor are basically existential quant
19:03:01 <parcs> yeah
19:03:13 <mm_freak> pchiusano: if you write the 'forall' in front of the constructor, yes
19:03:24 * edwardk waves hello
19:03:25 <guerrilla> (oy thats confusing (re: pacrs/pchiusano))
19:03:33 <mm_freak> then you will also need a different extension than RankNTypes, you will need ExistentialQuantification =)
19:03:47 <edwardk> or GADTs which implies it
19:03:49 <mm_freak> hi there edwardk =)
19:04:00 <pchiusano> what if you wrote Enumerator m a = Enumerator (forall b . Step m a b -> Iteratee m a b)
19:04:15 <parcs> then that's a rank2type
19:04:16 <ddarius> pchiusano: That would mean exactly what it sounds like.
19:04:20 <mm_freak> pchiusano: then you have your type alias wrapped in an ADT again
19:04:59 <ddarius> The difference is in data F = forall a. D a the type of the data constructor, D, is D :: forall a. a -> D which is equivalent to D :: (exists a. a) -> D
19:05:08 <mm_freak> pchiusano: btw, i recommend getting used to 'm' being the second last type argument
19:05:17 <ddarius> When the forall is inside, as in data F = D (forall a. a), D :: (forall a. a) -> D
19:05:27 <ddarius> s/-> D/-> F/f
19:05:29 <pchiusano> mm_freak: so, I still don't see the problem with that type :) you were saying earlier it would be impossible to apply such a function
19:05:55 <pchiusano> mm_freak: oh yeah, I forgot - why is the monad the middle type btw?
19:05:57 * koninkje waves back
19:06:02 <mm_freak> pchiusano: yes, you will get the lovely "inferred type is less polymorphich than the expected type" error =)
19:06:12 <mm_freak> pchiusano: see how runST works
19:06:23 <mm_freak> and try runST with an 's', which is not fully polymorphic
19:06:47 <pchiusano> mm_freak: what if I explicitly annotate the function's type
19:06:53 <mm_freak> pchiusano: about the type argument:  that's a convention used by virtually all monad transformer libraries
19:07:03 <mm_freak> pchiusano: it's not a matter of annotations
19:07:41 <ddarius> mm_freak: It's not a matter of convention.  If you want to be able to write instance Monad (Transformer m), m needs to be the second to last argument.
19:08:40 <pchiusano> ddarius: ah ok
19:08:41 <parcs> hmm, why does fundeps not imply mptcs?
19:08:50 <ddarius> parcs: Why should it?
19:09:06 <parcs> it seems like the first is useless without the second
19:09:12 <ddarius> Not completely.
19:09:16 <edwardk> nah
19:09:30 <edwardk> i use class Closure a | -> a fairly often
19:09:36 * ddarius though, takes this opportunity to reraise the calls for nullary type classes.
19:09:58 <edwardk> you can make a typeclass that has exactly one member at least
19:10:06 <edwardk> by using the above
19:10:16 <parcs> 'exactly one member at least?'
19:10:24 <parcs> the wording sounds a bit off :P
19:10:33 <mm_freak> (exactly one member) at least
19:10:35 <ddarius> It just needs a comma.
19:10:38 <edwardk> useful if you want to make another typeclass that nobody outside of the current module can extend
19:11:17 <parcs> that's neat
19:11:44 <pchiusano> mm_freak and parcs - thanks for explanations, I am still somewhat confused, but appreciate your help anyway :)
19:11:58 * ddarius will make a class, class Break a | -> a with no instances.
19:12:22 <mm_freak> pchiusano: i think, it took me a few months, before i really understood this 'forall' keyword, and i'm not even sure i understand it today =)
19:12:43 <parcs> i'm not sure i understand anything at all! :P
19:13:49 <mm_freak> i think you need to understand first order logic to really understand 'forall'
19:13:53 <mm_freak> i don't
19:13:55 <pchiusano> i will have to force edwardk to explain it to me at work tomorrow :)
19:14:05 <edwardk> easy nuff
19:14:49 <edwardk> we'll just need to take a little detour through limits ;)
19:14:54 <ddarius> My experience is that it doesn't take any effort to get edwardk to "explain" anything.
19:15:00 <pchiusano> uh oh
19:15:04 <edwardk> =P
19:15:04 <ddarius> Usually it takes effort to keep him from doing so.
19:15:09 <mm_freak> lol
19:15:15 <edwardk> hahahahahaha
19:15:21 <elliott_> edwardk: please explain zygohistomorphic prepomorphisms kthx
19:15:38 <edwardk> elliott_: bad joke, wrong type signature since corrected ;)
19:15:40 <pchiusano> ddarius: it does however, take some effort to get edwardk to explain ONLY one thing :)
19:15:45 <ddarius> pchiusano: True.
19:16:21 <elliott_> edenc_: I bet it's not Haskell-98, either!
19:16:26 <elliott_> edwardk:
19:16:50 <mm_freak> interestingly edwardk's explanations, though very CT-heavy, are understandable without CT knowledge =)
19:16:59 <edwardk> elliott: the longer version is that lambert meertens and company basically used to name different recursion schemes after various greek and latin roots. i noticed that their schemes could be combined
19:17:11 * ddarius doesn't find edwardk's explanations CT heavy at all.
19:17:22 <elliott_> edwardk: I know, I know :)
19:17:27 <edwardk> elliott: so you can take the meaning apart into the pieces zygo, histo, and prepro and understand them independently
19:17:30 <mm_freak> ddarius: if your topic is CPS, then it is ;)
19:17:30 <elliott_> Just being silly :P
19:18:04 <ddarius> People need to use ends and coends more.
19:18:10 <edwardk> ddarius is right, i don't really use that much category theory
19:18:14 <xil> hi. What's an easy way to take an infinite list of Floats and group every 2 Floats into a pair. I tried something like this, which didn't work: [(a,b) | a:b:_ <- myList]
19:18:18 <mm_freak> i need ffee
19:18:40 <ddarius> xil: Write the straightforward recursive function.
19:18:46 <edwardk> i just use the same boring corner of it over and over.
19:18:47 <ddarius> It's even easier for the infinite case.
19:19:07 <mm_freak> > map (take 2) . iterate (drop 2) $ [1..]
19:19:09 <lambdabot>   [[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21...
19:19:20 <pchiusano> okay, i have to run - looking forward to "little detour" through limits
19:19:22 <edwardk> xil: what do you do when you get an odd number of floats?
19:19:33 <xil> edwardk: it's a definitely infinite list
19:19:34 <ddarius> edwardk: Is infinity an odd number?
19:19:43 <elliott> ddarius: yes, also an even number
19:19:45 <elliott> hth
19:19:46 <mm_freak> xil: for the finite case add a takeWhile (not . null)
19:19:57 <ddarius> mm_freak: Except those aren't pairs.
19:19:59 <dankna> @hoogle hPutArray
19:20:00 <lambdabot> Data.Array.IO hPutArray :: Handle -> IOUArray Int Word8 -> Int -> IO ()
19:20:06 <mm_freak> true…
19:20:09 <edwardk> ddarius: ah missed the word infinite in the problem description
19:20:24 <mm_freak> > map ((\[x,y] -> (x,y)) . take 2) . iterate (drop 2) $ [1..]
19:20:26 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20),(21...
19:20:28 <edwardk> xil (a:b:as) = (a,b): xil as
19:20:50 <ddarius> > fix (\pairUp (x:y:xs) -> (x,y):pairUp xs) [0..]
19:20:51 <lambdabot>   [(0,1),(2,3),(4,5),(6,7),(8,9),(10,11),(12,13),(14,15),(16,17),(18,19),(20,...
19:21:55 <mm_freak> actually
19:22:01 <mm_freak> > map (\(x:y:_) -> (x,y)) . iterate (drop 2) $ [1..]
19:22:03 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20),(21...
19:22:25 <edwardk> made it most of the way through lawvere and schanuel aon the beach today. i think i may switching to recommending that book when folks ask me for a good intro to category theory for the completely uninitiated
19:22:58 <wli> luite: The linear programming bit is working quite well, but the algorithm relying upon it (ad hoc attempt at Remez-ish affairs) isn't actually converging.
19:23:03 <ddarius> edwardk: Is that what's-its-name?
19:23:14 <edwardk> Conceptual Mathematics
19:23:21 <wli> luite: Thanks for the hmatrix-glpk tip.
19:23:21 <ddarius> Yeah.
19:23:32 <xil> uh...which implementation is more efficient?
19:23:37 <edwardk> lots of pictures and examples with people's names and foods
19:23:38 <ddarius> edwardk: My understanding from hear-say is that that book doesn't go very far at all.
19:23:50 <edwardk> ddarius: it doesn't.
19:24:01 <xil> I ask because I'm going to be doing this very frequently
19:24:20 <edwardk> it does talk about toposes
19:24:38 <edwardk> but thats about it
19:24:45 <edwardk> it barely gets past products really
19:24:52 * wli can /msg with more details about the book.
19:25:41 * ddarius wishes (co)limit pedagogy wasn't so prevalent.
19:25:54 <edwardk> it does spend a lot of time hammering on sections and retractions, etc. though
19:25:55 <elliott> xil: why not just write the obvious recursive function?
19:26:07 <elliott> xil: pairs (x:y:xs) = (x,y) : pairs xs
19:26:16 * monochrom hugs (co)limits
19:26:27 <ddarius> elliott: That function has been defined twice above.
19:26:42 <elliott> ddarius: oh, it has?
19:26:48 <elliott> my bad
19:26:58 <xil> elliott: in the absence of an answer to the efficiency question I did, haha. I was thinking about trying to avoid it because I have a lot going on and didn't want to add more functions to my where clause just for 1 inline thing I want to do.
19:27:02 <ddarius> [23:04] <edwardk> xil (a:b:as) = (a,b): xil as
19:27:02 <elliott> i just saw mm_freak's
19:27:03 <ddarius> [23:05] <ddarius> > fix (\pairUp (x:y:xs) -> (x,y):pairUp xs) [0..]
19:27:36 <edwardk> difficulty jumps around a fair bit. the first 120 pages or so read like they are written for middle school, then he dives into brouwer's theorem and talking about continuous maps, etc. while trying too hard to handwave the hard parts
19:27:48 <xil> thanks everyone
19:28:06 <ddarius> edwardk: Yes, that was my impression from looking at the table of contents and combining with what I'd heard.
19:28:45 <ddarius> There is no way to cover some of the topics it mentions in any kind of meaningful way in the same book where you have an entire chapter on epi/mono-morphisms.
19:29:33 <edwardk> but since my usual recommendation of mac lane elicits the 'but its too hard!' whine, this should serve as an appropriate 'learn you a haskell'-esque counterpoint.
19:29:51 <ddarius> edwardk: I recommend, with Cale, Awodey's "Category Theory."
19:30:00 <edwardk> yeah
19:30:10 <ddarius> Or, for something freer and shorter, Barr and Wells' ESSLLI lecture notes.
19:30:23 <ddarius> If either of those are "too hard" then the problem is more likely background.
19:30:56 <ddarius> s/either/both/
19:32:49 <wli> > let triples xs = [(u, v, w) | u : vws <- tails xs, v : ws <- tails vws, w <- ws] in triples [1..5]
19:32:49 <lambdabot>   [(1,2,3),(1,2,4),(1,2,5),(1,3,4),(1,3,5),(1,4,5),(2,3,4),(2,3,5),(2,4,5),(3...
19:33:12 <edwardk> oh i like the barr and wells notes
19:33:23 <edwardk> i hadn't downloaded those before
19:39:41 <nand`> Is a ++ b ++ c processed as (a ++ b) ++ c or a ++ (b ++ c)? (Yes, I know they are the same due to the rules of monoids, but this makes a difference in execution time due to the nature of linked lists)
19:40:08 <nand`> Or more specifically, would a ++ b : c be faster than a ++ [b] ++ c
19:42:40 <elliott> Nanar: latter
19:43:43 * ddarius is a third of the way into "Excuse Me Sir, Would You Like To Buy A Kilo Of Isopropyl Bromide?" and finds it very personal but entertaining.
19:44:08 <ddarius> edwardk: I find the Barr and Wells' notes one of the best resources geared to computer scientists available period, online or off.
19:44:57 <Eduard_Munteanu> ddarius: is that a book?
19:45:55 <edwardk> i noticed that they didn't shy away from the computational examples
19:46:02 <edwardk> http://folli.loria.fr/cds/1999/library/pdf/barrwells.pdf
19:46:44 <Eduard_Munteanu> Oh, thanks for that too, though I initially wonder about the bromide thingy :)
19:46:56 <edwardk> hah
19:48:00 <ddarius> @google Excuse me sir would you like to buy a kilo of isopropyl bromide
19:48:01 <lambdabot> http://library.sciencemadness.org/library/books/gergel_isopropyl_bromide.pdf
19:48:02 <lambdabot> Title: cache:http://library.sciencemadness.org/library/books/gergel_isopropyl_bromide.p ...
19:49:14 <Eduard_Munteanu> Oh, heh, I wasn't sure Google would find that phrase.
19:49:16 <azaq23> nand`:nand`: Try :i (++) in ghci, it will list infixr 5 ++, so ++ is right associative with a precedence of 5.
19:50:29 <nand`> azaq23: I see. Thanks for that
19:50:52 <azaq23> I think it's likely that this is done this way for the reason you stated, but I don't know
19:51:36 <nand`> well, it makes sense. a ++ (b ++ (c ++ d)) is inherently faster than ((a ++ b) ++ c) ++ d
19:51:41 <azaq23> yes
19:52:15 <ddarius> "My hands were stained, my clothes had holes and at night there was always a halo around objects, showing corneal damage."
19:53:08 <Eduard_Munteanu> Although the title sounds (very) vaguely familiar.
19:53:26 * Eduard_Munteanu looks up wikipedia / something to refresh his memory
19:59:20 <Pterygota> zang
20:00:01 <Eduard_Munteanu> zang to you too
20:00:57 <guerrilla> (don't kill me, just curious) - is it possible to rename a data constructor?
20:01:22 <koninkje> no, but you can always define: foo = Bar
20:01:37 <Eduard_Munteanu> You can't pattern match with that though.
20:01:45 <koninkje> also cf. view patterns
20:02:07 <koninkje> not that it'll help much for this
20:02:24 * koninkje wonders if SHE has pattern aliases
20:02:29 * koninkje figures probaby so
20:02:49 <Eduard_Munteanu> I don't think that's possible even in Agda.
20:03:01 <Eduard_Munteanu> (if that's any sort of reference for this kinda stuff :D)
20:03:35 <djahandarie> koninkje, it does
20:03:36 <elliott> koninkje: yes
20:03:42 <koninkje> that's what I thought
20:04:04 <koninkje> it's been a while since I've looked though
20:06:03 <parcs> i'd like to try she, but it fails to build for me :/
20:06:20 <elliott> the fix is easy iirc
20:07:18 <parcs> it's an overlapping instances error
20:09:10 <elliott> parcs: just remove their instance
20:09:33 <parcs> yep, that seemed to have did it
20:09:38 <om-foxy> With the GHC API, I have two types: `forall a.[a] -> [a]` and `[Int]`.  When I attempt to `GHC.applyTy`, the resultant type is `[[Int]] -> [[Int]]`, not the correct `[Int] -> [Int]`.  Any ideas?
20:09:41 <parcs> or have done it, i dunno
20:09:46 <elliott> latter
20:10:01 <parcs> someone should update the package on hackage
20:10:02 <Eduard_Munteanu> Is it not maintained by somebody?
20:10:04 <elliott> om-foxy: you unify a=[Int]
20:10:09 <elliott> leaving [[Int]] -> [[Int]]
20:10:10 <elliott> no?
20:11:13 <om-foxy> elliot:  hm...  I see.  I'm trying to get the resultant type `[Int]` which is the type of the application of the two functions.  I can't seem to figure out what function to use.
20:12:20 <om-foxy> elliot:  okay, I definitely do not want to be substituting the `forall a` with `[Int]`.
20:13:22 <om-foxy> elliot, but when I strip off the `forall a` and _then_ try and apply, I get a panic.
20:13:52 <guerrilla> Eduard_Munteanu: sorry got distract. agda probably doesnt, but many other type theories support it fine
20:15:02 <guerrilla> Eduard_Munteanu: SHE is maintained by Conor McBride and used extensively in the implementation of #epigram
20:15:20 <ivanm> guerrilla: it's used in the implementation of an IRC channel? :p
20:16:01 <guerrilla> ivanm: no, failed attempt at being sneaky and say he should join there to know more
20:16:04 <guerrilla> lol
20:16:15 <guerrilla> (bad mix of twitter parlance and irc)
20:18:14 <guerrilla> btw, you cant pattern match on foo for foo = Bar? was that pattern matching on + and stuff removed finally? i think i saw a suggestion on that
20:18:41 <guerrilla> (nooot that i want to..)
20:18:46 <parcs> yep, n+k patterns have been removed
20:19:10 <guerrilla> nice
20:29:49 <parcs> heh: she: user error (Pattern match failure in do expression at src/Main.lhs:56:5-17)
20:30:32 <CrazyThinker> someone here was developing an IDE for Haskell, Visual Haskell
20:32:15 <ivanm> CrazyThinker: that's a Haskell plugin for VS
20:32:28 <CrazyThinker> yeah, is it complete?
20:32:30 <ivanm> there's also leksah if you want a standalone IDE, or also a plugin for eclipse
20:32:35 <ivanm> dunno
20:32:44 <ivanm> I think there's a GSoC project for it
20:33:43 <CrazyThinker> ivanm, anythign with code assist, auto complete support?
20:34:43 <Eduard_Munteanu> guerrilla: oh, heh
20:35:24 <ivanm> CrazyThinker: no idea; I just use emacs :p
20:35:33 <ivanm> but I think they're working on it
20:36:06 <elliott> <parcs> heh: she: user error (Pattern match failure in do expression at src/Main.lhs:56:5-17)
20:36:14 <elliott> parcs: gotta use it via ghc :p
20:37:05 <guerrilla> there's one for eclipse.. EclipseFP or something
20:37:22 <guerrilla> tried it for a bit, but prefer vim over eclipse
20:37:31 <guerrilla> seems to be functional (no pun intended)
20:37:36 <parcs> elliott: oops!
20:38:00 <elliott> parcs: read the site-docs :P
20:38:10 <elliott> http://personal.cis.strath.ac.uk/~conor/pub/she/
20:39:17 <guerrilla> so. the consensus is that SHE is usable? :)
20:39:28 <guerrilla> rather, compilable
20:40:34 <elliott> with a small patch
20:41:03 <elliott> because its not updated for ghc seven (this doesnt break she itself because it's so dumb that it doesn't matter)
20:41:25 <guerrilla> ok
20:41:40 <guerrilla> i will try tomorrow then, i've been curious to try it out forever
20:42:34 <elliott> well, it is not some amazing magic haskell improver. it can automatically derive some type-level stuff for you, and has some sugar. :)
20:43:04 <guerrilla> yep, i know
20:43:26 <guerrilla> wouldn't date use the pi types. that's what agda is for if i need them
20:43:38 <guerrilla> but im cursious about these pattern synonyms and idiom brackets
20:43:45 <elliott> it just turns into forall dude :P
20:43:59 <guerrilla> dare*
20:44:14 <guerrilla> *shrug* i'm still not using haskell to prove anything :P
20:44:48 <maurer_> What's the current reccomended way to represent time?
20:44:52 <maurer_> There seem to be several packages.
20:47:30 <ivanm> maurer_: the time package
20:47:41 <ivanm> see the recent thread on haskell-cafe
20:51:17 <maurer_> ivanm: OK
20:51:59 <parcs> what is a pi type?
20:52:29 <ivanm> newtype Pi = Pi Int
20:54:04 <parcs> is that a joke? :P
20:54:22 <ivanm> yeah ;_
20:54:24 <ivanm> * ;)
20:54:30 <ivanm> no idea what a pi type is tbh
20:55:07 <elliott> parcs: see she website docs again :P
20:55:21 <parcs> elliott: they don't explain what a pi type is
20:55:43 <elliott> ivan: parcs: not "pi type", it is just the dependent function arrow
20:56:06 <elliott> except faked, in she :)
20:56:10 <elliott> http://personal.cis.strath.ac.uk/~conor/pub/she/pi.html explains
20:56:17 <drdo> Are there nice gnutls bindings?
20:58:53 <ivanm> drdo: don't recall any...
20:58:54 <Clint> drdo: there's a pure tls.. the gnutls and openssl bindings seem less usable
20:59:14 <drdo> Clint: Oh there is? Where can i find it?
20:59:23 <maurer_> Is there a way to serialize DiffTime? I can't seem to find one, nor can I write it easily because they hid the MkDiffTIme constructor
20:59:40 <Clint> drdo: hackage; tls and tls-extra
20:59:53 <Clint> doesn't seem very mature either
20:59:56 <parcs> elliott: ah, 'dependent function arrow' makes more sense
20:59:59 <parcs> that's pretty neat
21:00:33 * maurer_ a noob, it looks like toRational might do it
21:01:02 <ivanm> maurer_: nah, time is rather confusing in that regards
21:01:12 <ivanm> you have to use the various Num instances a lot
21:01:54 <ivanm> drdo: http://hackage.haskell.org/package/gnutls ?
21:01:55 <ivanm> :p
21:03:13 <drdo> ivanm: There's another one too, but doesn't even build
21:03:22 <ivanm> drdo: which is why I didn't mention it ;)
21:03:28 <ivanm> Clint: what's so immature about them?
21:04:35 <Clint> ivanm: things still unimplemented or buggy
21:04:50 <maurer_> ivanm: I've got that. Now I'm just trying to figure out whether I can use readFile followed by writeFile via some magic, or whether I really need to pass file handles around :(
21:05:12 <ivanm> Clint: how do you know it's buggy? from use?
21:05:25 <ivanm> the hackage page just says that the API will be expanded over time
21:05:37 <ivanm> maurer_: what are you trying to do?
21:05:52 <maurer_> ivanm: Early on in my program, i read a configuration file.
21:06:05 <maurer_> ivanm: Some operations make it so I want to write back a changed config file on exit
21:06:25 <ivanm> @type readFile
21:06:26 <lambdabot> FilePath -> IO String
21:06:57 <maurer_> ivanm: The problem is that when I'm using readFile, then later writeFile, due to laziness, readFile still holds the file open, which keeps a lock open that is respected by writeFile
21:07:03 <Clint> ivanm: i used it only briefly, and i forgot what i ran into
21:07:32 <ivanm> Clint: well, it's still under development, unlike say the gnutls package on hackage
21:08:38 <Clint> yeah, i get the impression that everyone in haskell-land just uses stunnel-type hacks
21:08:43 <elliott> maurer_: don't use lazy io
21:08:57 <elliott> deepseq it if you must
21:10:07 <ivanm> elliott: I don't know if deepseq would work here
21:10:17 <ivanm> but yeah, lazy IO doesn't sound like it'll do what you want
21:10:35 <ivanm> though opening a handle, writing to it and then closing that handle explicitly may suffice
21:11:01 <maurer_> The only issue lazy IO is causing here is that haskell's trying too hard not to step on its own toes by locking
21:11:24 <ivanm> maurer_: it's an ordering issue if you're continually reading/writing
21:11:37 * ivanm goes finds his blog post on the topic
21:11:44 <elliott> ivan: well foldr seq
21:11:46 <elliott> ec.
21:11:48 <elliott> etc
21:11:58 <maurer_> ivanm: I read once, then write once
21:12:07 <ivanm> oh, just once? that _might_ be OK
21:12:13 <elliott> maurer_: lazy IO is an issue. always :)
21:12:50 <maurer_> elliott: It sounds to me like the real solution is to disallow access to file descriptors, and give the IO engine a little more smarts
21:12:58 <maurer_> "Am I causing this lock? Force a little more execution"
21:13:02 <ivanm> elliott: not _always_
21:13:17 <maurer_> "Am I going to run out of fds? Run some IO to completion so I can throw them out"
21:13:21 <elliott> lazy IO is also basically a space leak waiting to happen maurer_
21:13:29 <elliott> ivanm: well not strictly
21:13:30 <ivanm> my problems with lazy I/O: http://ivanmiljenovic.wordpress.com/2009/12/10/command-inputoutput-and-blocking/
21:13:43 <elliott> ivanm: but lazy io would be the first thing i'd change if i was trying to clean up a program
21:13:51 <ivanm> depends on what it is
21:14:01 <elliott> if its just a one-off that reads one file, sure
21:14:03 <ivanm> you'd be completely wrong trying to fix up the program I'm currently working on :p
21:14:12 <ivanm> since it just writes a file at the end, that's it
21:14:17 <elliott> sure
21:14:22 <elliott> but anything more... :p
21:45:23 <xil> hello. Is there a way for me to identify the line of code that is the source of an "undefined array element" error?
21:52:21 <MatrixFrog> i haven't really worked with haskell arrays
21:52:34 <MatrixFrog> but it looks like that pretty much happens when you use the "!" operator?
21:52:38 <tommd> I have a package on hackage, X.  I wish to split it into packages X and Y.  I want X to export all modules I moved over to Y for a few versions - how can I do this?
21:52:39 <MatrixFrog> so look for places where you're using that
21:53:43 <xil> MatrixFrog: yeah I have 6 places where I use it and it's basically split into 4 in one scenario and 2 in another. I know what function is the ultimate cause of my problem, but it would help to know which of the 2 categories of usage of ! actually spawned the error
21:53:56 <c_wraith> tommd: I don't think that's possible.
21:54:04 <tommd> I don't like that answer.
21:54:08 <tommd> ;-)
21:54:51 <MatrixFrog> xil: you could try posting the code to hpaste and maybe someone can look it over
21:55:20 <tommd> xil: does ghci debugger backtracking not help?
21:55:23 <c_wraith> tommd: as far as I know, importing a module exported by multiple packages results in an error, on GHC.  (the packageimports extension deals with this case, a bit)
21:55:25 <xil> MatrixFrog: I'll do that then. It's some hefty and poorly written code
21:55:34 <xil> tommd: I don't know how to use the debugger. Never have before
22:04:58 <pacak> There are no exception propagation through mapStream and  convStream in iteratee library because of eneeCheckIfDone. I wonder why is it implemented that way..
22:20:01 <avartanian> I'm having a brainfart.
22:20:41 <avartanian> I'm working in the state monad, doing something like n <- get; forM (nodes n) (...)
22:21:00 <avartanian> And I keep thinking get >>= nodes is a synonym for n <- get; ... nodes n ...
22:21:05 <avartanian> but it doesn't quite type the same way.
22:24:06 <ivanm> do n <- get; nodes n === get >>= \ n -> nodes n
22:24:28 <tommd> avartanian: Look at the signature for forM
22:24:38 <ivanm> @hoogle forM
22:24:38 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
22:24:39 <lambdabot> Data.Traversable forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
22:24:39 <lambdabot> Network.Browser data Form
22:24:51 <tommd> avartanian: the list is not monatic, it's the (...) that has the Monad m =>
22:25:03 <tommd> monadic
22:25:28 <byorgey> avartanian: get >>= nodes  is indeed a synonym for  do  n <- get; nodes n.  but if you want to embed nodes n in a larger context then you can write something like  get >>= \n -> ... nodes n ...
22:27:24 <tommd> byorgey: Are you on the SAFE team these days?
22:27:41 <avartanian> byorgey tommd you guys can probably guess what I'm doing. I'm trying to make the code look "imperative"
22:27:45 <byorgey> tommd: no
22:27:56 <tommd> ok
22:28:03 <avartanian> and also as free of extra params as possible
22:28:10 <tommd> But, Pierce is, isn't he?
22:28:21 <tommd> And he's... near you?
22:28:23 <byorgey> avartanian: oh, but imperative code is always full of extra params!
22:28:26 <tommd> Or am I too tired right now
22:28:29 <byorgey> tommd: yes, and yes =)
22:28:38 <byorgey> he's right down the hall =)
22:28:40 <ivanm> avartanian: why would you want to do that? :/
22:28:48 <hpaste> bereal pasted “cabal install yi” at http://hpaste.org/48738
22:28:51 <ivanm> tommd: what's the "SAFE team" ?
22:29:18 <bereal> guys, how to deal with http://hpaste.org/48738 ?
22:29:21 <ivanm> bereal: looks like newest version of yi only works on ghc-7
22:29:28 <tommd> byorgey: Since you're there, have you seen a PUBLIC (where I have access) way to get the rest of the SAFE proposal (section 2)
22:29:41 <ivanm> bereal: try doing it with -v3 to get more output
22:29:45 <avartanian> ivanm as an experiment to see if I can make Haskell look as imperative-ish as possible when it's easier to write something imperative-ish
22:29:51 <tommd> ivanm: Google for Darpa Crash or Semanticallhy Aware Foundation Environment
22:29:58 <tommd> well, fix the typos
22:30:04 <ivanm> about to ask! ;)
22:30:10 <ivanm> is it DARPA Crash or Data Crash?
22:30:19 <tommd> DARPA
22:30:38 <byorgey> tommd: no idea, sorry
22:30:45 <byorgey> tommd: I can ask if you like
22:31:01 <tommd> No, I can ask just as easily, thanks though.
22:31:08 <byorgey> ok.
22:31:16 <avartanian> byorgey tommd so there's no tightening up n <- get; forM (nodes n) (...) into something with just the single forM?
22:31:21 <tommd> Honestly, I'd probably have it already were it released (Tolmach would have shoved it at me at some point)
22:31:50 <byorgey> hehe
22:31:51 <bereal> ivanm: seem that maverick still has ghc6
22:31:59 <tommd> I think that use of get and forM is as tight as it needs to be / should be.
22:32:04 <bereal> s/seem/seems
22:32:09 <ivanm> bereal: I assume you did a cabal update just before that?
22:32:16 <bereal> ivanm: yes
22:33:00 <ivanm> bereal: can you build it with -v3 please?
22:33:06 <bereal> 1 sec...
22:33:19 <avartanian> then i will quite banging my head against the wall.
22:33:27 <gfarfl> avartanian: in theory you could probably do something like get >>= flip forM (...) . nodes
22:33:47 <gfarfl> avartanian: but that's starting to get less clear and readable
22:34:03 <avartanian> gfarfl hah! :) that's great. but yeah. definitely obscure.
22:34:43 <ivanm> gfarfl: flip forM == mapM :p
22:34:47 <avartanian> gfarfl if I flip forM, might as well use mapM no?
22:34:53 <ivanm> avartanian: yup
22:34:54 <avartanian> ah ivanm same thought
22:34:56 <hpaste> bereal pasted “cabal install yi -v3” at http://hpaste.org/48739
22:35:16 <gfarfl> oh, right. haha
22:35:53 <ivanm> bereal: can you just do "cabal install Cabal-1.10.2.0" ?
22:36:00 <ivanm> then see if "cabal install yi" works
22:36:14 * ivanm can't work out why the ghc library is being pulled in here...
22:36:32 <bereal> ivanm: Cabal-1.10.2.0 is already installed
22:36:46 <ivanm> OK, then I have nif
22:36:47 <ivanm> *nfi
22:36:52 <ivanm> preflex: seen dcoutts
22:36:52 <preflex>  dcoutts was last seen on #ghc 13 hours, 46 minutes and 16 seconds ago, saying: so big hash tables of symbol names
22:36:55 <ivanm> preflex: seen dcoutts_
22:36:55 <preflex>  dcoutts_ was last seen on #haskell 15 days, 11 hours, 44 minutes and 23 seconds ago, saying: augur: yeah, at least temporarily to be able to install
22:37:29 <ivanm> the ghcAPI flag is disabled by default, so that shouldn't be it... >_>
22:37:45 <avartanian> gfarfl you know what. I'm going for it. get >>= mapM  here I come.
22:37:48 <augur> IMMA FUCK YO UP
22:38:05 <avartanian> thanks ivanm gfarfl byorgey tommd for all your help
22:38:11 <augur> ivanm: you're really looking for dcoutts lately, huh
22:38:33 <ivanm> augur: not for me, seeing if he could decode bereal's cabal-install output
22:39:09 <ivanm> avartanian: so you're going to do: get >>= (mapM foo . nodes) ?
22:39:16 <ivanm> because that _really_ looks imperative :p
22:40:55 <avartanian> ivanm in a way. if you squint.
22:41:58 <avartanian> ivanm i'm trying to implement dijkstra's algorithm in a way that vaguely looks like the pseudo-code of dijkstra's.
22:42:05 <avartanian> just enough to be readable as such
22:42:20 <ivanm> for which graph type?
22:42:38 <avartanian> why? partly to have the confidence that I can do dirty stuff in a pinch with Haskell if I need to. partly to practice with the state monad.
22:43:12 <avartanian> it's a directed multigraph
22:43:22 <ivanm> you're rolling your own graph type?
22:43:30 <ivanm> any particular reason for not using an existing one?
22:43:42 <ivanm> oh, you're doing a stateful one...
22:43:55 * ivanm really needs to find the time to flesh out edwardk's grpah library
22:43:59 <ivanm> *graph
22:45:00 <avartanian> dijkstra just requires a priority queue for the unvisited min distance, a map from vertices to distances, and a map from edges to weights
22:45:19 <avartanian> I'm just rolling them all in state. Again, I know it's not very FP.
22:47:00 <avartanian> actually what I'm really doing is procrastinating from practicing for the GRE, but that's off topic
22:47:41 <tommd> Get back to your GRE work!
22:47:46 <ivanm> what's the GRE?
22:47:58 <tommd> Do you want to be a bum, Programming for Money all your life?
22:48:06 <MatrixFrog> a standard tests that undergrads take to get into grad school
22:48:16 <MatrixFrog> i guess it's just a united states thing maybe
22:48:19 <tommd> ivanm: USA Graduate School Entrance Examination
22:48:29 <ivanm> ahhh, right; something I can safely ignore and not care about :p
22:48:30 <hpaste> fragamus pasted “contrived as hell” at http://hpaste.org/48740
22:49:08 <tommd> ivanm: I think I had a harder time reading my score from their results sheet than many of the questions.
22:49:09 <ivanm> fragamus: I really have nfi what you're trying to do there...
22:49:18 <ivanm> tommd: heh
22:49:19 <tommd> Seriously, if interface were a topic they wouldn't be qualified to test it.
22:51:05 <avartanian> yeah well, it's 6 or 1/2 dozen of the other. i can do great on the gre, and if i can't code haskell for crap, grad school won't be much fun.
22:51:21 <fragamus> ivanm: that's right I'm not trying to do anything except learn how to print out gah
22:51:44 <ivanm> fragamus: replace "print $ 5" with "print gah" ?
22:52:04 <fragamus> ok sure but there will be an error
22:52:08 <ivanm> avartanian: I would presume that you still have time after finishing said GRE to brush up on Haskell?
22:52:26 <ivanm> fragamus: yeah, well, I'm not that familiar with monad transformers to know what to expect :p
22:52:40 <fragamus> neither me
22:52:53 <fragamus> i am trying to learn to wrangle them
22:52:59 <avartanian> ivanm GREs not that hard an exam. I'm just doing the general now. Then comes the Comp Sci subject exam. That's more of a pain.
22:53:05 <ivanm> fragamus: oh, just do "gah"
22:53:06 <ivanm> duh
22:53:12 <ivanm> since gah :: IO ()
22:53:24 <ivanm> well, IO (Int, Int)
22:53:31 <ivanm> so ints <- gah; print ints
22:54:02 <fragamus> theres an mlist in gah
22:54:09 <fragamus> i want to see what that looks like
22:54:15 <ivanm> a what?
22:54:25 <ivanm> isn't gah of type IO (Int,Int) ?
22:54:52 <msieradzki> how do I fix user cabal/ghc package db after removing AppData/Roaming/cabal and installing packages after that? I'm fine with some ghc-pkg remove-everything --user but I haven't found anything like that
22:55:15 <ivanm> ghc-pkg check
22:55:22 <ivanm> then re-install all the packages it says are broken
22:56:55 <msieradzki> that's 1 way but there are around 30 packages and after install --reinstall world stuff was still missing I think
22:58:16 <ivanm> msieradzki: ummm, is this on gentoo ?
22:58:26 <msieradzki> gentoo doesn't have approaming :)
22:58:35 <msieradzki> AppData/Roaming I mean
22:58:36 <ivanm> oh, right, missed that
22:58:43 <msieradzki> might have been my stupid mistake
22:58:47 <ivanm> the "--reinstall world" bit confused me
22:58:53 <msieradzki> chekcing if I passed wrong one to install
22:58:59 <msieradzki> like wrong, newer version
22:59:01 <ivanm> msieradzki: so where does the "--reinstall world" bit come from?
22:59:11 <msieradzki> cabal install --reinstall world
22:59:20 <ivanm> wait, that exists now?
22:59:40 <pikhq_> ivanm: It'd be "emerge -u world" on Gentoo, anyways.
22:59:59 <ivanm> pikhq_: looked a bit like a mish-mash of cave and paludis ;)
23:00:00 <msieradzki> ok I was wrong I somehow managed to install newer versions of packages that were broken
23:00:05 <msieradzki> and not fix the old ones
23:00:06 <ivanm> (the "instlal --reinstall world")
23:00:18 <ivanm> msieradzki: then unregister the old ones!
23:00:53 <msieradzki> was looking for magical unregister-all like I said ;)
23:00:55 <msieradzki> doing it
23:01:04 * hackagebot pwstore-cli 0.1 - Command line interface for the pwstore library  http://hackage.haskell.org/package/pwstore-cli-0.1 (RobertHelgesson)
23:02:01 <tommd> Competition is heating up between the pw-store and scrypt packages!
23:02:57 <ivanm> msieradzki: yeah, the closest to a "magical" one is to do some shell-scripting
23:03:36 <ivanm> somethign like (untested): for pkg in `ghc-pkg check --simple-output`; do ghc-pkg unregister $pkg; done
23:27:03 * hackagebot egison 0.3.0.2 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-0.3.0.2 (SatoshiEgi)
23:35:30 <Phyx-> so everyone's out drunk from yesterday huh
23:36:11 <ivanm> Phyx-: I beg to differ
23:36:18 * ivanm is actually contemplating heading off home
23:36:27 <ivanm> why would you be drunk from a Monday anyway?
23:37:21 <danharaj> July 4th
23:37:40 <danharaj> In America that is the day to eat many different animals and ingest fermented beverages.
23:37:54 <kfish> *every day*
23:38:12 <danharaj> kfish: some of our fellow citizens are not as patriotic as you and I.
23:38:53 <danharaj> Fairweather alcoholics and carnivores.
23:43:10 <Phyx-> ivanm: lol, wasn't it july 4th?
23:49:26 <ajnsit> Hi all, how do I build a cabal project with the sources in a separate dir from the .cabal file?
23:49:41 <kfish> ajnsit, hi
23:49:46 <kfish> do you mean in a subdir of the project?
23:49:53 <ajnsit> kfish, yes
23:50:07 <Phyx-> doesn't matter where the source are, aslong as the correct location is mentioned in the .cabal file
23:50:29 <ajnsit> okay so the situation is that I have a subdir called src
23:50:40 <ajnsit> and I have tried doing hs-source-dirs: src in .cabal
23:50:59 <ivanm> Phyx-: ... so?
23:51:21 <kfish> ajnsit, see eg. http://hackage.haskell.org/packages/archive/iteratee/0.8.5.0/iteratee.cabal
23:51:23 <ajnsit> okay so in my sources if I have a call to getDirectoryContents "." , it shows me the contents of the root dir
23:51:26 <Phyx-> ivanm: that's the excuse to drink!
23:51:31 <ajnsit> not the contents of the src dir
23:51:52 <ivanm> why would it being 4 July be any more of an excuse to drink than say today, 5 July?
23:52:16 <Phyx-> ivanm: because 4th of july is a national holiday? atleast in the us
23:52:43 <tommd> ajnsit: When you run the binary the current working directory will depend on the environment.
23:52:56 <Phyx-> ajnsit: because getDirectoryContents is working with the working directory of where the .cabal is
23:52:56 <tommd> ajnsit: If you want data files use the "data-files:" cabal line
23:52:57 <ivanm> Phyx-: well, I'm not in the USA! ;)
23:53:07 <Phyx-> ivanm: so, that's never stopped me :P
23:53:39 <ajnsit> tommd, I'm using template haskell to generate code at compile time
23:54:08 <ajnsit> and I need to generate code based on the contents of a dir without hardcoding the name of the source dir
23:54:39 <ajnsit> I mean I *can* hardcode src, I have no intention of changing that name ever, but it feels wrong
23:56:13 <ivanm> ajnsit: use the Cabal library at compile time to get the location of that directory?
23:56:46 <ajnsit> ivanm, hmm is that something simple to do?
23:56:55 <ivanm> well, it's not _that_ bad... ;)
23:57:03 <ivanm> but it's relatively doable
23:57:18 <Phyx-> seems like a lot of work just not to use the relative path "src"
23:57:32 <ivanm> the configuration aspect is the difficult bit (telling Cabal which flags, etc. to use) but since you only want a src-dir it should be OK
23:57:45 * ivanm heads off home
23:58:17 <ajnsit> Phyx-, yup I'm thinking if it's going to be more trouble than worth
23:58:37 <ajnsit> ivanm, okay I'm off to check the cabal library docs now thanks!
