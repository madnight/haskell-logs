00:06:48 * hackagebot wai-app-file-cgi 0.3.0 - File/CGI App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.3.0 (KazuYamamoto)
00:07:53 * azaq23 wrote a little bit of test code regarding the covariance / contravariance / functor issue http://hpaste.org/49064
00:08:48 * hackagebot mighttpd2 2.3.0 - A classical web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-2.3.0 (KazuYamamoto)
00:11:58 <ihodes> if someone has a moment, my first line of haskell since i tried it a while ago results in a parse error in GHCI: data TestType a = Vconstest a
00:12:41 <kmc> you can't define new types in ghci
00:12:48 <kmc> put it in a file foo.hs and then run "ghci foo.hs"
00:13:08 <ihodes> kmc: i figured, but a cursory google search didn't say. thanks :)
00:13:31 <ihodes> out of curiosity, what is the reason for not allowing data types to be defined in GHCI?
00:13:41 <c_wraith> just not implemented
00:13:44 <c_wraith> no other reason
00:14:09 <ihodes> c_wraith: fair enough. thanks all
00:14:10 <kmc> it's probably not trivial
00:14:11 <kmc> it's been a wishlist thing for a while
00:14:18 <kmc> do you let people *re*define types?
00:14:29 <kmc> if so, what happens to code that uses the old one?
00:14:49 <c_wraith> I asked all these questions last time.
00:15:08 <c_wraith> I was convinced these questions had good answers in ml REPLS
00:15:13 <kmc> a Haskell file has to be understood all at once; there can be forward and back references
00:15:22 <ihodes> kmc: fair enough, though i suppose you could follow other langs that deal with similar issues
00:15:22 <c_wraith> it's just a matter of being a lot of work to implement
00:15:35 <kmc> GHCi provides something similar to an IO "do" block, which is more unidirectional
00:15:51 <c_wraith> @instances MonadFix
00:15:51 <kmc> right, I don't claim there are no satisfying answers
00:15:52 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
00:16:03 <bastayahijo2> is haskell _the_ functional programming language or are there others that have gained wider acceptance
00:16:15 <kmc> what defines a "functional programming language"?
00:16:17 <ihodes> also, is there a preferred text editor in the haskell community?
00:16:26 <kmc> Haskell is not a *typical* functional programming language
00:16:28 <ihodes> bastayahijo2: haskell is pretty new compared to other functional langs
00:16:41 <kmc> haskell was first standardized in 1990 iirc
00:16:47 <bastayahijo2> I just started reading the " Learn you a Haskell" book and it's pretty sweet, I
00:16:50 <ihodes> kmc: correct :) that much i know
00:17:00 <bastayahijo2> 'd like to use it but want to make sure other people use it too
00:17:13 <kmc> bastayahijo2, what other languages would you compare it to?
00:17:29 <kmc> at this point there are more professional Scala programmers than Haskell programmers
00:17:32 <bastayahijo2> no idea, I'm a junior programmer and haven't seen anything like it, but I've heard of Scala and Erlang
00:18:00 <ihodes> bastayahijo2: scheme/racket is another. ML, too.
00:18:04 <kmc> Scala and Erlang are functional but you can also argue that Javascript, Ruby, Python, C#, and many others are functional
00:18:08 <ihodes> as far as holder ones go
00:18:20 <bastayahijo2> i see
00:18:23 <kmc> it's a particular style of code, not a property of languages
00:18:30 <adrake> Javascript: Scheme for the web =[
00:18:30 <kmc> some languages make that style easier or harder
00:18:32 <c_wraith> Clojure is becoming a reasonably popular lisp, too.  Just because it runs on the JVM
00:18:34 <ihodes> older* newer ones include the above depdning on how you quantify a functional language. clojure is even newer, and functional.
00:18:51 <path[l]> yeah you could do it in java. just build a lot of anonymous inner classes :(
00:18:53 <ihodes> Clojure is superb
00:19:01 <kmc> yes
00:19:06 <ihodes> path[l]: that's a hell i don't want to see again
00:19:11 <bastayahijo2> is there some weird stigma against Haskell-style writing? at my company one ex-developer used to write all our python code as if it were Haskell and he was hated | people seemed to shy away from map, filter, repeat, etc
00:19:26 <bastayahijo2> I dunno what's going on
00:19:31 <kmc> bastayahijo2, Python in particular has some inexplicable community groupthink against FP
00:19:46 <kmc> of course there are modules in the Python standard library which are explicitly Haskell-inspired
00:19:48 <kmc> so ymmv
00:20:07 <kmc> map and filter are seen in most languages; they aren't Haskell style in particular
00:20:07 <ihodes> bastayahijo2: there was talk about removing itertools/other functional tools in python. which is sad, as those are my favorite parts of python. i treat it like a functional language when i use it
00:20:10 <path[l]> it's definetly harder to read for people not used to it. I do this in javascript and I usually argue with my team mates that once they get these idioms everyone benefits. so far, mixed success
00:20:20 <MatrixFrog> javascript actually WAS supposed to be scheme-like. google for any talk by douglas crockford
00:20:42 <kmc> Clojure and Haskell are very different languages on a technical basis, but they're philosophically similar
00:20:45 <ihodes> MatrixFrog: sort of. it was more based on Self, but it does have some scheme in it.
00:20:53 <bastayahijo2> yeah, I wonder if I want to fight that "you should understand what map does regardless of Haskell" battle
00:20:56 <kmc> especially as regards concurrency in Clojure and GHC Haskell
00:21:09 <ihodes> kmc: does Haskell tend toward STM, too?
00:21:17 <path[l]> well javascript might have been intended that way. But right now it can be annoying
00:21:21 <kmc> Haskell is one of two languages I know of with a working STM library
00:21:25 <kmc> the other being Clojure, of course
00:21:30 <kmc> the last chapter in RWH covers it
00:21:45 <kmc> it's not the only option for concurrency, but it's a compelling one
00:21:48 <path[l]> I still only understand fp in the small. All code I write is still modelled using OO. I dont know how to model in fp
00:22:02 <ihodes> kmc: ah, excellent. i've yet to make it that far through RWH. i decided to stop and breeze through LYAH for a lighter overview
00:22:59 <kmc> STM, lightweight threads, automatic async IO, closure over thread primitives, etc. all makes for a very nice concurrent programming language
00:23:17 <kmc> and when you want parallel evaluation without concurrent semantics, there's a whole other mechanism for that
00:23:44 <gienah> there is also erlang like messaging with cloud haskell/remote
00:24:09 <gienah> https://github.com/jepst/CloudHaskell/
00:24:25 <bastayahijo2> is Miran going to write a followup book, on Amazon it seems like there are only 2 haskell books worth reading, and the RWH has mixed reviews
00:35:21 <drbean> I read ml REPLS as "mailing list replies."
01:00:55 * hackagebot cookie 0.3.0 - HTTP cookie parsing and rendering  http://hackage.haskell.org/package/cookie-0.3.0 (MichaelSnoyman)
01:00:57 * hackagebot pool 0.1.0.4 - Thread-safe resource pools.  http://hackage.haskell.org/package/pool-0.1.0.4 (MichaelSnoyman)
01:01:55 * hackagebot wai-test 0.1.0.2 - Unit test framework (built on HUnit) for WAI applications.  http://hackage.haskell.org/package/wai-test-0.1.0.2 (MichaelSnoyman)
01:02:58 * hackagebot yesod-core 0.8.3.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-0.8.3.2 (MichaelSnoyman)
01:04:56 * hackagebot yesod-newsfeed 0.2.0 - Helper functions and data types for producing News feeds.  http://hackage.haskell.org/package/yesod-newsfeed-0.2.0 (MichaelSnoyman)
02:42:07 <abhi_> clear
02:42:30 <abhi_> hi can any one tell me wats so special about haskell
02:42:48 <maurer_> abhi_: What programming languages are you familiar with?
02:43:58 <Twey> @where whyfp
02:43:58 <lambdabot> http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
02:44:02 <erus`> if i want is there a canfail monad of some sort?
02:44:24 <erus`> that link is dead
02:44:38 <Twey> erus`: Several.  Would you like to fail silently, with a message, fatally, or with a failure that magically propagates up the stack?  ☺
02:45:05 <erus`> magical please
02:45:33 <erus`> i just want to report errors, should i need to throw any
02:46:02 <Twey> @where+ whyfp http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html
02:46:02 <lambdabot> Okay.
02:46:20 <Twey> erus`: Then why do you want magical?
02:46:36 <erus`> nah i dont care really
02:46:44 <erus`> i use Maybe at the moement
02:46:49 <maurer_> abhi_: I'm primarily asking because it is easiest to explain things if I know where you're coming from.
02:47:00 <erus`> but there must be something more suited
02:47:00 <Twey> erus`: Reporting errors can be done with the Writer monad.  Reporting a single error and short-circuiting the rest of the computation can be done with the Either monad instance.
02:47:27 <erus`> is there a idiomatic error type?
02:47:42 <Twey> erus`: Either SomeError ReturnValue
02:48:14 <erus`> where someerror is a string?
02:48:25 <Twey> erus`: Where SomeError is any error type you like
02:48:42 <Twey> But if you want to use the monad instance in Control.Monad, it must be an instance of the Error typeclass
02:48:51 <Twey> For historical reasons
02:52:36 <Saizan> i think that changed
02:53:48 <Saizan> now you have Monad (Either e) without any constraint on e
02:54:45 <Saizan> that means fail calls error though
03:02:12 <erus`> @hoogle strip
03:02:12 <lambdabot> Data.List stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
03:02:37 <erus`> @hoogle isPrefix
03:02:37 <lambdabot> Data.ByteString isPrefixOf :: ByteString -> ByteString -> Bool
03:02:37 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
03:02:37 <lambdabot> Data.ByteString.Char8 isPrefixOf :: ByteString -> ByteString -> Bool
03:04:22 <erus`> is Data.String.Utils not in the platform?
03:08:49 <Twey> Saizan: Oh, did it?  Good-ho
03:09:15 <Twey> Mm, yes, that's an issue
03:10:28 * benmachine pokes Twey 
03:12:55 <benmachine> I wanted to talk to you but I forget why
03:13:09 <benmachine> or well I can imagine why but not specifically what about
03:13:18 <erus`> can i match arrays like
03:13:19 <benmachine> hth
03:13:39 <erus`> alltheelements:justthelastone
03:13:55 <erus`> [allofthem,thelastone]
03:14:31 <benmachine> erus`: if you mean the Array type, you can't pattern match them at all
03:14:46 <erus`> i mean list
03:14:49 <benmachine> oh
03:14:50 <erus`> sorry i am parsing json
03:14:54 <benmachine> you can't, no
03:14:55 <erus`> getting mixed up
03:15:09 <benmachine> lists don't necessarily have to have a last element :P
03:15:30 <benmachine> a data structure with fast access with both ends is in Data.Sequence
03:15:42 <benmachine> then you can pattern-match on ViewR
03:15:48 <benmachine> sort of
03:16:52 <benmachine> case viewr sq of EmptyR -> ...; all :> last -> ...;
03:17:53 <Twey> View patterns help here
03:18:31 <benmachine> that they do
03:18:38 <Twey> Also pattern guards
03:19:11 <Twey> f (viewr -> v) | EmptyR <- v = … | xs :> x <- v = …
03:19:51 <Twey> f (viewr -> EmptyR) = …; f (viewr -> (xs :> x)) = …
03:19:56 <Twey> Hah, precisely the same length
03:20:24 <Twey> I guess pattern guards win by having less redundancy?  *shrug*
03:20:41 <Twey> OTOH you have an extra name
03:20:49 <Twey> Well… whatever suits :þ
03:21:42 <k0ral> why is System.Locale referenced as old-locale ? is it deprecated ?
03:21:50 <quicksilver> it was supposed to be deprecated
03:21:55 <quicksilver> but nodody ever wrote a replacement
03:22:10 <quicksilver> so now it's not deprecatd, it's "confusing" instead.
03:22:17 <k0ral> :)
03:22:42 * mauke uploads confusing-locale
03:26:23 <erus`> ok here is my issue: I need try to parse a list of strings, if any of the strings cannot be parse i need to return Nothing
03:26:32 <erus`> otherwise the mapped list
03:26:37 <identity_> erus`: use reads
03:26:49 <erus`> i cant
03:26:50 <maurer_> erus`: Use the maybe monad
03:26:54 <identity_> why?
03:27:13 <earthy> erus`: then re-create reads. :)
03:27:16 <erus`> the strings arnt haskell formatted types
03:27:17 <maurer_> erus`: Write a parser for a single string that does what you want, then do
03:27:22 <maurer_> mapM maybeParser strs
03:27:28 <gienah> if it can run php then maybe flatpress, however configuring flatpress could be finicky
03:27:38 <identity_> erus`: you can create a type and make your own read instance for it
03:27:42 <gienah> oops wrong channel sorry
03:28:11 <maurer_> identity_: ReadS is also not the most wonderful parsing system.
03:28:16 <identity_> maurer_: nope, it isn't
03:28:21 <maurer_> erus`: What are you trying to parse?
03:28:40 <maurer_> (the soltion I gave is just for grafting working subparsers together into one that has the total failure property that you wanted)
03:29:25 <hpaste> erus` pasted “example” at http://hpaste.org/49065
03:29:47 <erus`> errr
03:29:52 <erus`> line 31 should be line 36
03:30:13 <Botje> this is why they invented parsec ;_;
03:30:17 <identity_> ^
03:30:29 <identity_> You should really take a look at parsec
03:31:04 <erus`> is it cheating?
03:31:08 <identity_> (or you could use an alreayd existing json parser)
03:31:14 <identity_> oh, you're doing this for homework?
03:31:19 <erus`> for fun...
03:31:22 <identity_> ah
03:31:23 <erus`> yeah....
03:31:37 <identity_> well, I wouldn't write a parser like that without using parsec or something similar
03:32:24 <identity_> it's pretty declarative and idiomatic. You're basically describing the data you want to parse
03:32:43 <benmachine> parsec is good
03:32:45 <benmachine> use parsec
03:32:46 <maurer_> Ah, so you're already parsing :)
03:33:12 <maurer_> benmachine: Parsec is great, but might be overkill here
03:33:21 <earthy> or attoparsec
03:33:24 <benmachine> maurer_: parsec is pretty lightweight
03:33:28 <benmachine> in terms of dependencies
03:33:39 <maurer_> benmachine: Yes and no. Specifically, you have to unwrap the type at some point
03:33:43 <earthy> or, for that matter, uu-parsing
03:33:48 <maurer_> And it looks like his parser is only one step away from being done
03:33:48 <benmachine> maurer_: hm?
03:33:58 <benmachine> what do you mean by unwrap
03:34:04 <erus`> apart from objects
03:34:09 <erus`> but yeah
03:34:31 <maurer_> benmachine: Invoking the parser is a many argument process, then he'll need to pattern match, then repack into a Maybe
03:34:36 <erus`> i can feed the ',' seperated values striagt into the parser again
03:34:40 <benmachine> uu-parsinglib is very cool in features but it's not as friendly as parsec
03:34:42 <maurer_> benmachine: It's not that it's hard, but rather that he seems super close to being done already
03:34:47 <identity_> maurer_: I don't think he's talking about using parsec for only the last part
03:34:56 <benmachine> maurer_: but learning parsec is a useful skill :P
03:34:59 <identity_> I was implying he should rewrite, anyway
03:35:04 <benmachine> yes
03:35:29 <benmachine> I think I didn't necessarily mean use parsec now
03:35:29 <maurer_> benmachine: True. It's super nice for writing compilers.
03:35:39 <benmachine> but everyone should try parsec because it is lovely
03:35:51 <maurer_> benmachine: But they never accepted my patch that gives them multiple unary operators at the same precedence in the same line :(
03:35:56 <igrekster> Hello, a noob here. I'm looking for an "advanced" level book on Haskell. I've been toying  with OCaml for some time, so I'm looking for a more detailed language description rather than introductions to functional programming. What whould you recommend?
03:36:00 <benmachine> :(
03:36:10 <identity_> @where rwh
03:36:10 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
03:36:15 <identity_> @ igrekster
03:36:20 <maurer_> benmachine: Or my patch that allows their tokenizer generator to use a Parser type for line comments rather than just a string
03:36:39 <benmachine> igrekster: tricky. I think I had the same thing when I tried to learn erlang after knowing haskell, all the tutorials were like "woah recursion"
03:36:43 * maurer_ was making a compiler, and these 2-3 line changes in parsec made it _so_ much easier
03:36:49 <benmachine> and I was all, I KNOW GUYS
03:36:50 <erus`> does the Scottish fellow who wrote real world haskell hang out in here?
03:37:07 <identity_> benmachine: Hahaha
03:37:17 <identity_> erus`: I think he did/does sometimes
03:37:37 <identity_> erus`: Pretty much anyone who has anything to do with haskell come here at least occasionally. If not here, then haskell-cafe
03:37:38 <erus`> what about simon peyton jones?
03:37:40 <maurer_> Argh, scons, you have a complete depgraph, Y U NO PARALLEL
03:37:40 <quicksilver> three people wrote RWH
03:37:44 <quicksilver> and they all come here sometimes.
03:37:45 <earthy> erus`: Don Stewart does at times, Bryan also sometimes, not sure about John Goerzen
03:37:55 <quicksilver> less so recently since they've all got jobs and stuff.
03:38:05 <earthy> Simon PJ I haven't seen here, Simon Marlow I have. ;)
03:38:11 * benmachine is at his job at the moment :<
03:38:16 <maurer_> Marlow is JaffaCake, right?
03:38:16 * earthy as well
03:38:20 <identity_> How many of you guys do haskell for a living?
03:38:20 <maurer_> benmachine: Where do you work?
03:38:22 <earthy> then again, I'm at a uni currently
03:38:23 * erus` too
03:38:30 <benmachine> earthy: me too :P
03:38:32 <maurer_> identity_: Depends on what you mean.
03:38:42 <maurer_> identity_: I don't write exclusively haskell, but it's involved in some things I do.
03:38:43 <earthy> identity: I do. for about 6 weeks more. :)
03:38:44 <identity_> Get $$ for writing haskell
03:38:48 <identity_> Ah
03:38:51 <identity_> Lucky bastards :(
03:39:02 <benmachine> I wrote a haskell script for my job
03:39:04 <benmachine> in about three files
03:39:05 <maurer_> I mean, my main job is as a security research grad student
03:39:09 <benmachine> that sort of counts
03:39:13 <maurer_> And this summer, I'm doing some security work for google.
03:39:24 <earthy> well, it's a matter of 'okay... I'm going to have to write this backend to this Information Retrieval system... say, boss, mind if I use Haskell?'
03:39:34 <maurer_> Our main codebase back at my lab is OCaml, so the boss doesn't really care if I use haskell :P
03:39:41 <identity_> ah
03:39:54 <igrekster> benmachine: yeah same thing, I've read a few chapter of Haskell: The Craft of Functional Programming, then abandoned it for Programming in Haskell by Graham Hutton
03:40:01 <earthy> our main codebase is in two home-grown formalisms, som...
03:40:14 <earthy> so... haskell was an improvement in supportability and documentation ;)
03:40:28 <maurer_> igrekster: Once you know more or less how the language is working, it is probably better to stop reading books and start writing code...
03:41:40 <earthy> maurer: unless you run into a library you don't understand
03:42:06 <maurer_> earthy: Then you read the library docs, not a book...
03:42:10 <igrekster> maurer_: wouldn't that leave me on the same basic level? I'm interested in advanced concepts like existential types
03:42:31 <maurer_> igrekster: Existential types aren't particularly advanced, but even the advanced concepts are harder to understand before you see how to use them.
03:42:39 <maurer_> The way I've learned about most of these things is:
03:42:41 <maurer_> 1.) Write code.
03:42:42 <earthy> maurer_: depends on the lib. see e.g. http://stackoverflow.com/questions/240905/best-asp-net-mvc-2-book :P
03:42:44 <maurer_> 2.) Notice duplication
03:42:54 <maurer_> 3.) Look for how to avoid duplication via use of fancier language features
03:42:56 <maurer_> Repeat.
03:43:10 <identity_> maurer_: Yeah
03:43:11 <sipa> do this until your program is reduced to one line of code
03:43:14 <identity_> that is how it worked for me as well
03:43:17 <earthy> (I'd call ASP.NET MVC a lib. or Ruby on Rails. or... :))
03:43:19 <identity_> and it's how rwh teaches you in some  cases as well
03:43:23 <identity_> 'reducing staircasing'
03:43:28 <maurer_> earthy: So, that's different.
03:43:42 <adrake> sipa, or, publish your program as a library and then just pull it in :P
03:43:49 <earthy> ofcourse, there's quite a bit of domain knowledge that comes into it at that point
03:43:50 <maurer_> earthy: Other languages have tendencies to build large castles, with a few rooms really nice, and a few built shoddily
03:43:59 <maurer_> earthy: We tend to release a few good rooms you can cobble into a castle :P
03:44:12 <earthy> maurer_: okay. then Yesod. :)
03:44:18 <earthy> (or snap for that matter)
03:45:06 <earthy> the point is, once you get into advanced lib land, there's really no good way to learn how to deal with it without also learning the underlying domain knowledge
03:45:14 <earthy> which tends to be not too well documented in the lib docs
03:45:38 <maurer_> earthy: I don't like what Yesod has done for that specific reason.
03:45:55 <maurer_> earthy: They also abuse T-H, which I consider a hack in the first place.
03:46:10 <earthy> well, yeah, that's why I also mentioned snap
03:46:21 <earthy> and honestly, happstack isn't better either
03:46:29 <earthy> in this respect
03:48:04 <maurer_> earthy: Yesod does do some package breakup too though
03:48:12 * earthy nods
03:48:19 <maurer_> earthy: You can certainly pull in some yesod w/o others, but it is very much designed for you to pull the whole thing in
03:48:31 <maurer_> I have seen the horror that is glibc, and want to avoid it :P
03:48:46 * earthy smiles
03:50:36 <igrekster> identity_: rwh looks interesting, thanks. is the online version - a complete book ?
03:50:48 <earthy> it is
03:50:50 <Botje> yes
03:50:53 <identity_> yep
03:50:58 <earthy> it was actually written partly online
03:50:58 <igrekster> awesome
03:51:12 <identity_> better than the printed too, errors don't get fixed in your bought hardcopy :P
03:51:16 <earthy> (and there's been quite a bit of feedback folded into the current book)
03:53:48 <erus`> i need to append an items onto the first list in a nested list :(
03:55:14 <maurer_> erus`: If you don't care about speed, I don't see why this is difficult.
03:55:28 <maurer_> If you do, you need to pick the right datastructure.
03:55:43 <erus`> i designed a crappy algorythm
03:56:32 <maurer_> erus`: ... You don't need anything that could even be vaguely described as an algorithm to do what you described.
04:03:05 <savask> Hello. I'm trying to install LLVM package in cabal, all goes right at the first look, but it throws an error at the end: http://pastebin.com/9xf4MUkh It's the only package which I can't install. How can I fix this problem?
04:03:08 <mauke> The paste 9xf4MUkh has been copied to http://hpaste.org/49066
04:07:19 <maurer_> savask: Do other packages install from cabal?
04:07:48 * hackagebot docidx 1.0.0 - Generate an HTML index of installed Haskell packages and their documentation.  http://hackage.haskell.org/package/docidx-1.0.0 (AndyGimblett)
04:08:08 <savask> Yes.
04:09:49 <maurer_> savask: Dunno then. Just reinstalled here and it worked fine :/
04:11:52 <benmachine> savask: that looks like a bug in Cabal
04:12:01 <benmachine> maybe ask #hackage
04:13:19 <dcoutts> it's a bug in the llvm Setup.hs
04:13:23 <dcoutts> it was fixed recently
04:13:33 <benmachine> oh
04:13:36 <benmachine> good
04:14:09 <savask> dcoutts: So the fixed version isn't in cabal yet?
04:14:26 <dcoutts> on hackage you mean, apparently not
04:14:54 <savask> Uh. Okay, thanks for help.
04:15:08 <dcoutts> (terminology: hackage is the central archive of cabal packages)
04:15:22 <dcoutts> savask: you might try the dev version
04:15:50 <savask> From the git repo, you mean?
04:22:15 <merijn> Speaking of terminology, I wonder how many new people think Hoogle is just someone typo'ing Google, I just noticed the G and H are right next to eachother :p
04:24:03 <hpc> hoogle.com doesn't point to us though
04:26:03 <merijn> heh
04:26:20 <merijn> I wonder how that site is even remotely related to the hoogle URL >.>
04:28:15 <hpc> i would suggest someone buy hoogle.com, but i can't imagine that being even remotely cheap
04:28:17 <merijn> I wonder, has anyone ever tried to get that domain?
04:28:39 <Jester_Racer> It must be really - really expensive
04:29:17 <merijn> I'm tempted to just fire off an e-mail to their administrative contact...can't hurt and I don't see a direct domain squatting "buy this domain here" link
04:30:02 <Jester_Racer> well if you have millions of dollars on your desk, maybe it's worth trying
04:30:08 <Jester_Racer> :D
04:32:14 <erus`> does json "" return null?
04:32:19 <erus`> like empty json?
04:32:40 <hpc> try it
04:32:52 <hpc> use the source, luke
04:33:30 <erus`> eval("") is undefined...
04:34:11 <erus`> typeof(eval("")) i mean
04:34:48 <Botje> erus`: that would make sense, yes
04:37:12 <Tomsik> "" should be id
04:37:20 <Tomsik> Like, whatever you concatenate to it
04:37:24 <Tomsik> it becomes that thing
04:54:02 <cheater_> @src print
04:54:10 <cheater_> uh-oh
04:54:14 <cheater_> why is nothing happening
04:54:19 <cheater_> `src print
04:54:58 <merijn> Nooo :(
04:55:05 <merijn> Lambdabot seems to be dead
04:55:08 <Botje> @vixen Boo!
04:55:14 <cheater_> oh shi-
04:55:15 <Botje> so she is.
04:57:13 <merijn> @vixen w00t!
04:57:21 <lambdabot> you know what? if we'd known it was going to be like this we'd have picked our own goddamn cotton!
04:58:01 * hackagebot hbro 0.6.4 - A suckless minimal KISSy browser  http://hackage.haskell.org/package/hbro-0.6.4 (koral)
05:01:10 <merijn> She's a bit slower then normal it seems
05:04:56 <Younder> At least lambda bot IS there
05:05:18 <Younder> Yesterday it was out completely
05:05:50 <Cale> It never stopped running
05:06:01 <Cale> I just restarted it now
05:06:08 <Younder> but it stopped resonding
05:06:11 <Cale> It'll always be slow when it reconnects
05:06:23 <Cale> because it has to join a ridiculous number of channels
05:07:00 <Younder> Ahh, so it is with us again now?
05:07:06 <Younder> duh
05:07:07 <Cale> yeah
05:07:58 <Younder> Sorry for that dumbass question.
05:08:43 <merijn> Cale: It wasn't in the channel when I looked at the user list
05:08:50 <merijn> Or maybe I'm blind, also an option
05:08:57 <Cale> Yeah, it had just been disconnected by a ping timeout
05:09:21 <Cale> (along with 20 other people)
05:20:36 <merijn> Is Agda's type system based on CoC like Coq's or...?
05:26:00 <Saizan> i'm told it's based on Martin Loef Type Theory, but i wouldn't know how they differ in detail, probably on the existence of the prop sort and (im)predicativity
05:26:02 <Younder> I use Isabelle
05:26:51 <Younder> Type theory is the weakness of modern proof systems
05:27:04 <merijn> bollocks, I mostly ignored Martin Löf in my overview :p
05:27:10 <merijn> Younder: How is it a weakness?
05:27:12 <Younder> You need to base it on  topoloy
05:27:43 <Younder> You need to know it's operators and for that you need the whole tree
05:28:20 * merijn doesn't follow
05:28:22 <Younder> Thus the system knows what operators are allowed
05:29:06 <Younder> Further still.. You should base the topological system on category theory.
05:29:15 <merijn> Saizan: Actually, according to wikipedia (shame on me!) CoC is inspired by Martin-Löf as well
05:29:30 <Younder> A more solid and more practical basis than logic.
05:31:01 <merijn> I like how wikipedia calls Epigram a programming language :D
05:31:17 <Cale> Is it not a programming language?
05:31:27 <merijn> Cale: Depends on your definition :)
05:31:35 <merijn> I'd prefer writing brainfuck to epigram :)
05:32:00 <Cale> epigram has a much nicer type system
05:32:06 <Younder> I would like to know having to re-represent everyting as a set for every black box affects your productivity ;)
05:32:12 <merijn> The type theory is nice and interesting but the syntax is even worse then Coq and renders it completely unusable for "real (TM)" coding
05:32:39 <Younder> Think beyond representation. Think relation
05:33:04 <merijn> Representation matters
05:33:11 <Saizan> well, the current implementation is quite spartan, you can't pretend much of out of its UI
05:33:17 <Younder> Well anyhow that is what I am working on
05:33:21 <merijn> Why do you think we have mathematical notation in the first place
05:33:38 <Saizan> merijn: i don't think Younder is talking about syntax
05:34:51 <Younder> No, I am taking about representing functions in terms of their relation
05:35:19 <Saizan> it's quite doable in type theory too
05:35:30 <merijn> Younder: Meaning...
05:35:32 <Younder> Not describing them as abstract set representational mirrors
05:35:52 <Cale> "mirrors"?
05:36:30 <merijn> I can't tell whether your saying something profound enough for me to not understand or just throwing around random abstract terms
05:36:38 <Younder> The beauty of category theory is that it allows me to see the function as a black box and see the correlations simply in terms as how they affect each other
05:37:53 <Younder> merijn, Yes, you have two languages. A specification language using sets and a programming language
05:39:30 <quicksilver> merijn: epigram's great, it's just nowhere near finished.
05:39:35 <quicksilver> it's a prototype
05:39:42 <quicksilver> it's a prototype of some very interesting things though.
05:39:53 <merijn> quicksilver: That's kinda what I said (or meant to say anyway) :p
05:39:58 * quicksilver nods
05:40:49 <merijn> Automatically deriving elimination functions from data type specifications and (partially) automatic derivation of code from types is awesome
05:41:05 <quicksilver> yes, automatic pruning of case branches
05:41:11 <quicksilver> is a beautiful thing.
05:41:12 <Cale> Even if you formalise set theory in a categorical way though, you still get a quite similar picture from another direction. You have elements of a set X as arrows 1 -> X, and functions will (presumably) still be determined by how they behave when applied to (i.e. composed with) elements.
05:41:48 <merijn> It's a prototype very strongly aimed logicians and theoretical computer scientists and not so much at practical programming which his goal supposedly is
05:42:58 <Younder> I Think we could automatically derive function and inter-function correctness according to some invariants if we has a 'correct' (see above) type system and a category inference engine
05:43:37 <Cale> What is a category inference engine?
05:43:54 <Younder> It will still, of course just be as good as it's specification.
05:44:52 <Younder> Cale, Hasn't been created yet, Though there is a book out there on computational category.
05:45:06 <Younder> But I will try
05:45:17 <Cale> I mean, conceptually, what does that phrase mean?
05:45:52 <Cale> (What would such a program do?)
05:46:13 <merijn> On slightly related note, anyone got a better formulation for this sentence? I'm not happy with it: "Opposite from the simply typed lambda calculus on the lambda cube is the calculus of constructions." (for example is it opposite from or opposite of?)
05:46:27 <quicksilver> opposite to, I think
05:46:33 <Cale> "opposite from" is fine
05:47:48 <Cale> Starting at the STLC, if you go to the diametrically opposite vertex, you arrive at the CoC.
05:49:03 <merijn> diametrically opposite vertex might be overshooting the formality level I was aiming for ;)
05:49:36 <Younder> Cale, Well It is just like when I used to solve the travelling salesman problem. I couldn't so I use transformations and a evaluation function. If it is better I always choose it.  But that leeds to local optimization. So I employ a annealing algorithm exp(-k*t). to slowly and then faster eliminate inferior  answers.
05:50:13 <Cale> Younder: I have no idea how what you just said has anything to do with the question that I asked you.
05:50:21 <Younder> This gives me a soluteion in the top %
05:50:58 <zygoloid> why is 'opposite on the lambda cube' an interesting notion? iiuc those three axes aren't really special compared to the other type system axes
05:51:24 <Cale> It's not interesting.
05:51:42 <Cale> It's just descriptive of the situation at hand.
05:51:58 <Younder> Cale: it is a answer to 'What is a category inference engine?'
05:52:07 <Cale> Younder: No it isn't.
05:52:25 <Cale> I still have no idea what the inputs and outputs of such a program would be.
05:52:28 <merijn> zygoloid: Because I'm going from less expressive to most expressive and skipping the other dialects in between. Considering all three axes add new expressiveness to the STLC the opposite of the least expressive vertex on the cube is the most expressive one
05:52:34 <Younder> Cale YES, A reasoning is a graph
05:52:47 <zygoloid> "CoC is the STLC augmented with {these three properties}, putting it at the opposite corner of the lambda cube"
05:53:24 <zygoloid> merijn: my question was more, why are the axes of the lambda cube special, as opposed to other type system axes (which also add expressiveness)
05:53:24 <Younder> Cale A Categorical graph is a different looking graph but it is still a graph
05:53:39 <Cale> Younder: That again has *nothing* to do with my question.
05:54:23 <Cale> Younder: Let me give you an example. "A type inference engine is a program which takes a program without type signatures, and determines the types of values from their definitions."
05:54:26 <merijn> zygoloid: Because my literature survey was based on dependent typing and the lambda cube axes are the only ones I happened to work with/read about
05:54:52 <Cale> Younder: Now what does it mean to be a category inference engine again?
05:55:01 <Younder> RETE is a graph representation on FOL.. Perhaps you should start there
05:55:29 <merijn> zygoloid: So the only reason they are special compared to the rest is that they influence my story and other type system axes do not
05:55:35 <Cale> Okay, I have no choice but to believe that you have no idea what you're talking about and are just spouting terms at random.
05:56:01 <Cale> One could get similar results from a markov chain generator.
05:56:24 <zygoloid> merijn: in that case, i think you should say what the axes are, and just add that this is the opposite, most expressive, corner of the lambda cube as a parenthetical
05:56:49 <merijn> zygoloid: Well, I listed the properties of the three axes of the cube earlier in the text
05:57:05 <merijn> Maybe I'll just rewrite the paragraph to ditch this sentence
05:57:30 <Younder> Cale you create a graph of objects. You create vertices with properties. You define properties. You define legal transformations. You evoke them in a random manner. (metropolis)
05:57:58 <merijn> Cale: That's how I sometimes answer questions here with remarkable accuracy: "someone asks a question I do not fully understand but recognize some terms from" -> "answer with some things other people mentioned in context of those terms" :p
06:03:41 <Younder> Cale: This is all to complex to be described over IRC I'll write a technical report on xxx.lanl.gov
06:04:28 <Younder> My name there is John Thingstad
06:05:33 <hpaste> erus` pasted “Json parser (without objects)” at http://hpaste.org/49073
06:05:52 <erus`> my code is getting ugly again :(
06:06:14 <ion> cabal install aeson
06:08:06 <merijn> The arXiv url seriously begins with "xxx"? >.>
06:12:16 <erus`> lol
06:40:39 <norm2782> I'm trying to create Haskell bindings for libgit2 using the FFI, but I'm getting some compilation errors I can't seem to solve: https://gist.github.com/1084715
06:40:53 <norm2782> does anyone know how to resolve this?
06:42:32 <quicksilver> norm2782: looks like you need to link it with libgit (or whatever it's called)
06:42:37 <quicksilver> libgit2, you said
06:43:06 <norm2782> I had hoped the FFI would do that automatically
06:43:15 <norm2782> how can I do that?
06:44:40 <quicksilver> the FFI doesn't know which libraries to link :)
06:44:45 <quicksilver> it just generates C linker stubs.
06:44:53 <quicksilver> you need to tell it what libraries to use
06:45:24 <quicksilver> put -lgit2 on the command line.
06:45:52 <norm2782> aah alright
06:46:05 <norm2782> great
06:46:08 <norm2782> that seems to compile
06:46:11 <norm2782> thanks!
06:46:35 <quicksilver> :)
06:48:16 <Jetbeard> Question: what do people here use for editing their Haskell code?
06:48:32 <Jetbeard> I want a nice simple editor with complete Haskell (and Literate Haskell) syntax highlighting
06:49:03 <quicksilver> lots of people use emacs or vim.
06:49:50 <erus`> gedit :)
06:50:05 <norm2782> vim + haskellmode for me
06:50:49 <Jetbeard> I'm trapped in Windowsland and so gVim is my only option if I want to use vim
06:54:04 <internet> whyamihere.hlp
06:54:27 <earthy> it's a bit unfortunate that Visual Haskell hasn't been updated to VS2010, because it actually was quite nice
06:55:24 <mokus> Jetbeard: http://www.haskell.org/haskellwiki/Windows has a section on editors
06:55:55 <mokus> can't speak from experience about which ones are better, thought - I don't use windows
06:56:10 <Cale> gvim is good
06:56:57 <earthy> I don't know about http://mistuke.wordpress.com/author/mistuke/
06:57:18 <earthy> but it might be good as well ;)
07:00:55 <frerich> Is there something like a discussion of common Haskell anti-patterns, "code smells"? I found two articles about different things now and actually one of them was relevant to me. So I wonder whether there is maybe more to discover.
07:01:46 <Martty> haskellton pattern
07:04:23 <mekeor> Does Miranda actaully also use Monads for side-effects?
07:06:05 <Cale> mekeor: No, it was mainly used before people started using monads to describe effects.
07:06:18 <Cale> mekeor: and I don't think it had typeclasses, let alone constructor classes
07:06:49 <mekeor> Cale: ic. thanks.
07:07:11 <Cale> In fact, early versions of Haskell didn't have the IO monad.
07:10:46 <dpratt71> I use Notepad++ for all manner of text editing in Windows; It has syntax highlighting for Haskell
07:11:40 <dpratt71> I've tried to use vim/gvim from time to time, but my brain does not rewire easily
07:11:51 <Jetbeard> dpratt71: unfortunately the colour scheme system in Notepad++ is poorly thought-out
07:11:52 <Phantom_Hoover> Anyone know if there's an implementation of Fortune's algorithm in Haskell?
07:12:08 <Jetbeard> there's a converter from TextMate themes to Notepad++ themes but it's quite broken
07:12:30 * Axman6 just changed textmate themes
07:12:44 <Samuel> So I started learning Python and Haskell and I finding lots of similarities between the two when it comes to List, tuple and other types manipulation. So really which one to choose for production development?
07:13:19 * mekeor emacs + haskell-mode  just works perfectly :P
07:13:28 <Jetbeard> Samuel: they're really nothing alike
07:13:31 <Axman6> they're very, very different languages Samuel
07:13:54 <Axman6> C also has tuples and lists etc
07:14:38 <mekeor> tuples = structures; lists = arrays; - right?
07:14:47 <kowey> hi all! doing cabal configure on the com package, I get a complaint from cc1 that -fenable-stdcall-fixup is not a recognised command
07:14:59 <kowey> and some googling tells me that these are options specific to ld
07:15:01 <Samuel> can you give one hard distinction between the two languages?
07:15:10 <benmachine> the tuple and list syntaces of haskell and python are superficially similar
07:15:18 <Samuel> ok
07:15:25 <benmachine> but not really more than that
07:15:36 <benmachine> Samuel: haskell usually deals with immutable data
07:15:39 <Jetbeard> Samuel: Python's an imperative language, Haskell's purely functional
07:15:40 <Axman6> mekeor: well, i meant lists = linked lists
07:15:40 <benmachine> that's a major difference
07:15:55 <Tomsik> pretty functional, not purely functional :p
07:15:57 <kowey> anybody know where the option is being issued from? eg. is this something baked into Cabal? or more likely, GHC? seems to be not in the package
07:16:05 <Samuel> but you can alwyas make it immutable
07:16:08 <Jetbeard> Tomsik: I've yet to learn about monads ;)
07:16:16 <Jetbeard> Python's dynamically typed, Haskell is strongly-typed with an amazingly powerful type system
07:16:22 <Axman6> can you make things immutable in python?
07:16:35 <benmachine> Axman6: strings and tuples are immutable in python iirc
07:16:36 <Jetbeard> Axman6: you can treat them as if they are
07:16:42 <benmachine> Jetbeard: that doesn't count :P
07:16:49 <kowey> oh, I need to do more googling
07:16:56 <clsmith> Samuel: i write python professionally, and haskell as a hobbyist. i'm not great at haskell yet, so i find writing python easier, but i very often find myself cursing and wishing python had a type system like haskell's -- sometimes python crashes half an hour into a script because of a typo. not in haskell. so .. yeah, if i could choose one aside from how good i am at each, i'd go with haskell
07:17:50 <Samuel> clsmith: thanks for the advice
07:18:06 <clsmith> (also they are so very different) :p
07:18:08 <Tomsik> python is a language bad for anything bigger than a couple dozen lines ofcode
07:18:10 <benmachine> Samuel: you might find that #haskell is made up mostly of people who prefer haskell
07:18:12 <Samuel> I noticed the strongly type aspect Haskell
07:18:23 <Tomsik> Also, Haskell's faster if it matters
07:18:45 <kowey> I think http://hackage.haskell.org/trac/hackage/ticket/532 answers my question
07:18:47 <Samuel> are there any web frameworks for haskell:)
07:18:53 <Axman6> yes
07:18:56 <Samuel> I have written a web app in haskell
07:18:58 <Samuel> really?
07:19:01 <Tomsik> Three, I think
07:19:06 <Axman6> more than three
07:19:10 <Tomsik> Yesod, Snap and um, something
07:19:15 <Nimatek> Happstack
07:19:19 <Axman6> there's snap, happs, happstack, yesod...
07:19:27 <Samuel> can it exchange JSON data too
07:19:29 <Samuel> sweet
07:19:31 <clsmith> Samuel: http://www.haskell.org/haskellwiki/Web/Frameworks
07:19:35 <Samuel> I am in love already :)
07:19:36 <clsmith> lists 9
07:19:50 <clsmith> *8
07:19:56 <Axman6> Samuel: don't try and use any of them without learning the basics of haskell first. you'll get very lost and upset
07:20:20 <earthy> 'can it exchange JSON data' *snicker*
07:20:22 <Samuel> Actually I covered today this http://learnyouahaskell.com/chapters
07:20:39 <Samuel> very informative, do you suggest to do something else before going web
07:20:50 <Axman6> Samuel: did you just read them or did you play around writing haskell as well?
07:20:59 <Axman6> yes, write more haskell
07:21:09 <Samuel> I rewrote the sample and re-wrote mine as well
07:21:15 <earthy> well then
07:21:25 <clsmith> i find haskell is one of those languages which you quickly understand the idea of, and then spend quite some time learning what you just learnt actually means
07:21:27 <Samuel> I know I need more practice
07:21:28 <earthy> go ahead and choose one of the web frameworks and play with it ;)
07:21:36 <Samuel> I will spend next week on Haskell
07:21:58 <earthy> clsmith: um, yes. I still have that after about 8 years of very regular haskell :)
07:21:59 <Samuel> I have to be honest
07:22:06 <Samuel> I got lost with Higher order function
07:22:17 <Samuel> I didn't absorb that far because I really tired
07:22:28 <Samuel> but I am giving another shot tomorrow
07:22:46 <Samuel> space is function and I was lost :)
07:22:57 <Samuel> repeat (+3) "test"
07:24:00 <Axman6> that doesn't make any sense though (because (+3) is a function that adds three to things, not an Int)
07:24:25 <erus`> could one implement datatypes as functions?
07:24:35 <mauke> yes
07:24:40 <Samuel> my bad..I meant applyTwice (++ " HAHA") "HEY"
07:24:48 <Samuel> ++ instead of +
07:24:48 <mauke> you can build a whole language out of functions
07:24:56 <earthy> erus`: yes, and the construction is called the church encoding of a datatype
07:24:56 <erus`> mauke like a list
07:25:03 <mauke> you don't need booleans, numbers, lists, or control structures
07:25:17 * hackagebot http-types 0.6.5.1 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.6.5.1 (AristidBreitkreuz)
07:25:30 <earthy> see http://en.wikipedia.org/wiki/Church_encoding
07:25:46 <Cale> wait, what?  repeat (+3) makes sense
07:25:46 <Samuel> why do we need Http types?
07:25:49 <Axman6> erus`: go read about lambda calculus =)
07:25:54 <Cale> but it's a list of functions rather than a function itself
07:26:01 <Cale> so applying it to "test" makes no sense :)
07:26:09 <Axman6> oh, i always get repeat and replicate mixed up
07:27:15 <Axman6> Samuel: because everything in haskell needs to have a type
07:27:33 <Samuel> I see
07:28:00 <Samuel> from the webstie I see that Haskell comes with lots of packages
07:28:10 <Samuel> JSON, Datamining to name a few
07:28:11 <earthy> err...
07:30:09 <erus`> Axman6: when i define a cons i need a None type or something
07:30:34 <erus`> how can i implement a list without a datatype
07:30:40 <hpaste> Axman6 pasted “future lib” at http://hpaste.org/49074
07:31:01 <erus`> no i dont :D
07:31:46 <Axman6> Cale: would you mind having a look at that last paste of mine? I'm interested to see what people think of it
07:32:48 <erus`> (a, b) = (1, 2)
07:32:50 <Tomsik> :t (***)
07:32:51 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
07:32:52 <erus`> is that calculus
07:33:17 <Tomsik> Is there something like (***) except it uses only one arrow on both components?
07:33:31 <Axman6> join (***)?
07:33:34 <Tomsik> Or more specifically (a,a) -> (a -> b) -> (b, b)
07:33:34 <RichardO> :t (&&&)
07:33:36 <wli> join (***)
07:33:36 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
07:33:45 <Tomsik> :t join (***)
07:33:46 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
07:33:52 <Tomsik> oh
07:33:56 <Tomsik> dammit
07:33:58 <Tomsik> :t join
07:33:59 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
07:34:00 <Axman6> :t join (&&&)
07:34:01 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a b (c, c)
07:34:06 <Axman6> hmm
07:34:12 <Tomsik> Are these two different joins?
07:34:21 <Axman6> no
07:34:22 <cfricke> Hey folks. Is there any way to find out more about a function using ghci than just its type? Maybe some minor notion of help docs built in?
07:34:27 <Tomsik> What is the m there then?
07:34:34 <Axman6> Tomsik: functions are monads
07:34:41 <Axman6> the (->) a monad
07:34:52 <Axman6> (or (a ->) monad)
07:34:55 <RichardO> m = (a ->)
07:35:17 <Tomsik> :t join :: a -> a -> b -> a -> b
07:35:19 <lambdabot>     Occurs check: cannot construct the infinite type:
07:35:19 <lambdabot>       a = a -> a -> b -> a -> b
07:35:19 <lambdabot>     In the expression: join :: a -> a -> b -> a -> b
07:35:20 <RichardO> (b -> c) -> b -> (c, c)
07:35:29 <Axman6> > do {x <- (+5); y <- (*7); return (x+y)} 6
07:35:30 <lambdabot>   <no location info>: parse error on input `6'
07:35:35 <erus`> can i uninclude the prelude somehow
07:35:38 <Axman6> > (do {x <- (+5); y <- (*7); return (x+y)}) 6
07:35:40 <lambdabot>   53
07:35:53 <mauke> erus`: import Prelude ()
07:36:52 <Tomsik> :t join :: (a -> a -> b) -> a -> b
07:36:53 <lambdabot> forall a b. (a -> a -> b) -> a -> b
07:37:37 <Tomsik> Does this monad have a name? Reader or something?
07:37:58 <quicksilver> yes, the (a ->) monad is the same as Reader a
07:38:06 <Tomsik> Kay
07:38:46 <Tomsik> > join (+) 6
07:38:48 <lambdabot>   12
07:39:06 <Axman6> @pl \x -> x*x
07:39:07 <lambdabot> join (*)
07:39:10 <Tomsik> Gosh, I feel kind of dumb right now
07:39:24 <Tomsik> Like, why didn't I know that? That's so basic
07:39:48 <clsmith> what does lambdabot mean by 'forall'? is that just the implicit meaning of a & b in any type declaration which lambdabot is spelling out for some reason?
07:39:58 <Cale> clsmith: yeah
07:40:02 <clsmith> ok :)
07:40:06 <Cale> for all types a, ...
07:40:24 <Cale> It gets displayed when you turn on various ghc extensions
07:40:46 <erus`> shit how do i do minus :P
07:40:49 <erus`> without prelude
07:41:01 <mauke> erus`: how do you do numbers without the prelude?
07:41:08 <erus`> 0 works ok
07:41:27 <mauke> yeah, but that's kind of cheating
07:41:33 <erus`> im trying to implement !! without prelude
07:41:48 <erus`> i have a simple linked list
07:41:57 <mauke> good luck with that, Int and [] are from the prelude
07:42:19 <erus`> i only want int :(
07:42:22 <Jaak> well, you could just implement natural numbers too
07:42:32 <erus`> Jaak: how?
07:42:40 <Jaak> data Int = Z | S Int
07:42:45 <erus`> define 1 2 3 4 etc?
07:42:55 <clsmith> erus`: did you see the link about church numerals?
07:43:01 <Axman6> define one, two, three, four etc. ;)
07:43:18 <erus`> how does haskell do it?
07:43:36 <clsmith> haskell cheats
07:43:46 <Cale> Int is built-in.
07:43:50 <Cale> and Integer too
07:44:00 <Cale> But you can make a data declaration for some type of numbers
07:44:00 <clsmith> some of the prelude can't be written in haskell itself
07:44:21 <erus`> can i just include Int from prelude?
07:44:42 <erus`> i think i can
07:45:02 <clsmith> erus`: sure, import Prelude (Int)
07:45:58 <mauke> erus`: but you said you didn't want to use the prelude
07:46:39 <erus`> yeah but haskell wont let me define numbers in a sane way
07:47:04 <Axman6> erus`: might be useful importing Num(..) too
07:47:14 <Axman6> then you get (+), (-) etc.
07:47:15 <Jaak> you know... if you want to make an apple pie...
07:47:31 <Axman6> you're going to have to break a few apples!
07:48:33 <norm2782> ok, next FFI question... (it's in the gist) : https://gist.github.com/1084844
07:48:36 <erus`> > at n xs = at (tail xs) (n-1)
07:48:38 <lambdabot>   <no location info>: parse error on input `='
07:48:48 <erus`> oh idiot!
07:49:49 <Jaak> ...if you want to make it from scrath you have to first create the universe. it's pretty great exercise in haskell
07:51:00 <mauke> norm2782: repo is a null pointer
07:52:11 <clsmith> are there any experimental branches of ghc or so which map with the gpu?
07:53:07 <norm2782> mauke: yes, I figured it would give me a fresh pointer to the newly create repository instead... but that is exactly where the bulk of my confusion is I think
07:53:20 <hpaste> erus` pasted “Doesnt work :(” at http://hpaste.org/49075
07:53:25 <mauke> norm2782: how can it give you anything? it is a null pointer
07:53:54 <hpaste> erus` annotated “Doesnt work :(” with “Doesnt work :( (annotation)” at http://hpaste.org/49075#a49076
07:54:05 <mauke> norm2782: the equivalent C code would be int res = git_repository_open(NULL, path);
07:55:18 <norm2782> actually, I thought it would be: git_repository r; int res = git_repository_open(r, path);
07:55:51 <mauke> norm2782: that's both a type error and a runtime error
07:58:37 <norm2782> mauke: my C skills are limited, and I just wrote my first C FFI code today, so I'm not at all surprised there are many things wrong with this
07:58:55 <norm2782> do you have any ideas on how I could make things work ?
08:01:59 <mauke> git_repository *p; int res = git_repository_open(&p, path);
08:02:03 <petrus> For a while I am having problems with planet.haskell.org feed. I contains a malformed segment so some feed-readers choke on it. I reported it to planet@community.haskell.org, it bounced. Any idea how that can be fixed?
08:04:01 <erus`> i dont think i can make a list with functions unless im using a dynamic language...
08:04:10 <petrus> Try this link to see what is the problem I am talking about: http://feedvalidator.org/check.cgi?url=http://planet.haskell.org/rss20.xml
08:04:14 <norm2782> mauke: but  now in Haskell ;)
08:04:42 <erus`> i dont think you mean *p there
08:05:04 <mauke> alloca $ \pprepo -> do { res <- {#call git_repository_open#} pprepo pstr; if res == 0 then fmap (Right . Repository) $ peek pprepo else return . Left . fromIntegral $ res
08:07:53 <norm2782> the c code was just a rough illustration of what I though would happen
08:07:59 <norm2782> uh
08:08:00 <norm2782> sorry
08:08:11 <norm2782> that was in a buffer, wanted to refresh my ghc
08:09:03 <norm2782> mauke: it works, thanks :)
08:10:50 <Tomsik> prepo? As in prepomorphism? :p
08:14:05 <erus`> is there a dynamicly typed pure functional language?
08:14:50 <Tomsik> Maybe some dialect of list
08:14:51 <Tomsik> lisp
08:15:00 <Tomsik> But dynamic typing is really weak
08:15:28 <Tomsik> You can have a look at Data.Dynamic :p
08:16:39 <Tomsik> And existential types, they're pretty much what's good in dynamic languges, except statically typed
08:17:26 * erus` googles existential types
08:18:07 <Jetbeard> erus`: lambda calculus? :)
08:18:40 <erus`> Jetbeard: the last time i asked for a lambda calculus compiler people said haskell
08:19:18 <mauke> why do you want to compile it?
08:19:55 <erus`> or interpret
08:20:34 <djahandarie> You can write an LC interpreter in Haskell extremely quickly
08:20:40 <djahandarie> Check out "higher order abstract syntax"
08:21:41 <mauke> you could write an interpreter for it!
08:21:41 <mauke> or program in the LC subset of scheme, perl, or javascript
08:22:09 <Saizan> unless by LC you mean the typed variants
08:23:08 <sully> well, you can embed the untyped lambda calculus in haskell pretty easily
08:24:13 <sully> speaking of typed lambda calculuses
08:24:22 <sully> the simply typed lambda calculus is the lamest language ever
08:24:31 <sully> you can express addition but not subtraction
08:25:02 <djahandarie> sully, huh? Subtraction of what?
08:25:12 <clsmith> sully: what? you can subtract church numerals
08:25:35 <sully> in simply typed I am pretty sure you cannot
08:25:53 <sully> doing predecessor on church numerals requires iterating and producing a pair
08:25:55 <dmwit> In the simply typed lambda calculus, you can't even write the type of a Church numeral.
08:25:58 <sully> and the type system won't let you do that
08:26:09 <sully> like, the best you can do for a church numeral is
08:26:11 <dmwit> Forget subtracting.
08:26:15 <dmwit> You don't even have polymorphism.
08:26:17 <sully> (unit -> unit) -> (unit -> unit)
08:26:25 <sully> which is good enough to add them, but that's about it
08:27:23 <clsmith> hmm, i guess i'll take your word for it :p
08:28:12 <dmwit> sully: So, you're claiming you can't write "pred" in STLC?
08:28:24 <sully> I believe that is the case, yes
08:29:18 <sully> I don't have a proof of this, but I have read it in at least one place in addition to coming to that conclusion when I thought about it
08:29:40 <Saizan> i think you can give a type to pred in STLC but it won't be a very useful one
08:29:51 <erus`> who told me i could write any type with functions?
08:29:56 <erus`> because i am having trouble
08:30:26 <Saizan> erus`: what do you mean by "write any type with functions"?
08:30:47 <erus`> someone said functions can do anything type can do
08:31:05 <dmwit> Are you talking about dynamic typing, or what?
08:31:29 <clsmith> he's talking about using lambda instead of cons, and so on, i think
08:32:07 <Saizan> or type families vs. simple type synonyms ?
08:32:53 <erus`> im trying to implement a single linked list with using data
08:33:17 <Saizan> *without?
08:33:34 <erus`> without yeh
08:34:09 <Saizan> in that case you can use the church encoding: forall b. (a -> b -> b) -> b -> b
08:34:26 <Cale> > (\nil cons -> cons 1 (cons 2 (cons 3 nil))) 0 (+)
08:34:27 <lambdabot>   6
08:34:33 <Cale> > (\nil cons -> cons 1 (cons 2 (cons 3 nil))) [] (:)
08:34:35 <lambdabot>   [1,2,3]
08:35:11 <Saizan> ?type (\nil cons -> cons 1 (cons 2 (cons 3 nil)))
08:35:12 <lambdabot> forall t t1. (Num t) => t1 -> (t -> t1 -> t1) -> t1
08:35:34 <Saizan> a = t; b = t1 and flip the arguments :)
08:36:28 <erus`> my list looked like (head, tail)
08:36:37 <erus`> is that impossible>
08:37:07 <clsmith> without using data = ..., yes
08:37:35 <dmwit> Well, newtype would make it possible. But that sounds like it's outside the spirit of the problem (even though it's inside the letter of the law of the problem).
08:37:53 <dmwit> erus`: Is this you?
08:37:57 <dmwit> http://stackoverflow.com/questions/6709338/creating-a-list-type-using-functions
08:38:00 <erus`> yer
08:38:39 <clsmith> dmwit: yeah, i think that's cheating ;)
08:43:57 <Saizan> "forall b. (Maybe (a,b) -> b) -> b" would also work, and closer to (head,tail)
08:47:10 <FUZxxl> To write something like »data T = T (a -> a)«, which extensions do I need?
08:47:10 <lambdabot> FUZxxl: You have 1 new message. '/msg lambdabot @messages' to read it.
08:47:13 <danharaj> Church encoding looks a lot like CPS transformation.
08:47:16 <dmwit> Aw, nuts, somebody gave the actual answer there.
08:48:50 <travisyay> if i were to import a module (in my case "System.Time") how would i do that?
08:49:18 <quicksilver> you would write
08:49:23 <quicksilver> import System.Time
08:49:29 <quicksilver> at the top of your file.
08:49:35 <quicksilver> (Data.Time is better, though)
08:49:51 <travisyay> so at the top of my script?
08:50:39 <travisyay> okay, thank you!
08:55:27 <ski> FUZxxl : it's not clear what you want ..
08:55:51 <FUZxxl> @ski I want Rank2Types. Fixed for now.
08:55:51 <lambdabot> Maybe you meant: ask src wiki
08:56:01 <FUZxxl> ski I want Rank2Types. Fixed for now.
08:56:41 <ski> FUZxxl : it might be you wanted `data T = MkT (forall a. a -> a)', it might be you wanted `data T = forall a. MkT (a -> a)', it might be you wanted `data T a = MkT (a -> a)', it might be you wanted something else
08:56:53 <edwardk> preflex: xseen dobblego
08:56:53 <preflex>  dobblego was last seen on freenode/#haskell 9 hours, 37 minutes and 57 seconds ago, saying: NemesisD: I would hide the constructors and use whatever makes it easiest to write the API
08:57:03 <edwardk> dobblego: i'm not sure i followed that
09:01:45 <travisyay> how would i compile a parallel program? the book im reading suggests typing "ghc --make -threaded filename.hs" but that's not working..
09:03:19 <chrisdone> evening
09:03:19 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
09:03:32 <luite> travisyay: what's not working? ghc doesn't magically parallellize your code
09:03:37 * chrisdone just got the “My brain just exploded.” message from GHC. excellent
09:05:32 <chrisdone> No context is allowed on a GADT-style data declaration (You can put a context on each contructor, though.)
09:05:36 <chrisdone> any good reason for this?
09:05:36 <travisyay> luite: when i type that command from prelude, it says "unknown command: ghc"
09:06:01 <zygoloid> chrisdone: because contexts on data declarations are dumb? :)
09:06:10 <luite> travisyay: hmm, are you using hugs instead of ghc?
09:06:29 <travisyay> well im using ghci... does that change things?
09:06:32 <zygoloid> chrisdone: since there was no backwards-compatibility issue, and data contexts don't work, i suspect they were deliberately removed
09:06:33 <kmc> norm2782, i recommend using Cabal to build ffi projects
09:06:33 <chrisdone> zygoloid: if i'm putting a context on each constructor is that not equivalent?
09:06:44 <kmc> or really all non-trivial projects
09:06:59 <travisyay> luite: ghci
09:07:38 <zygoloid> chrisdone: no. contexts on constructors store the instance evidence in the constructor. contexts on the data declaration itself just cause code to not compile.
09:07:42 <luite> travisyay: no that's good, but I don't really understand what you're doing. are you saying that if you run ghc --make -threaded program.hs in your shell, it cannot find ghc?
09:07:45 <norm2782> kmc: I agree :) I will probably create a cabal file this weekend
09:07:57 <travisyay> luite: yes
09:08:04 <norm2782> thins kind of started out as a tiny plaything to get familiar with the FFI
09:08:07 <chrisdone> zygoloid: well, the former is how i expected the latter to behave for GADTs, oh well
09:08:21 <luite> travisyay: strange, but it can find ghci? how did you install it?
09:08:37 <zygoloid> chrisdone: it certainly could (since there's no back-compat issue) but it'd differ from how it behaves for non-GADT syntax
09:08:55 <chrisdone> zygoloid: spose
09:09:11 <travisyay> luite: no, the same thing occurs if i use ghci. i installed with instructions from the website.. maybe i should retry?
09:09:45 <luite> travisyay: which operating system?
09:09:50 <zygoloid> chrisdone: also, it'd be weird that you'd have to pattern-match to see the instance
09:09:51 <quicksilver> travisyay: you are typing ghc inside ghci it sounds like?
09:09:58 <quicksilver> you type ghc in the shell, not inside ghci.
09:10:34 <travisyay> quicksilver: shell? sorry im new to haskell
09:10:42 <luite> travisyay: command prompt in windows
09:10:44 <chrisdone> zygoloid: sorry? pattern match where and why? what are you referring to?
09:10:48 <quicksilver> right, command prompt.
09:10:54 <quicksilver> it's not a haskell thing :) It's part of your OS
09:11:56 <travisyay> quicksilver: ohh i see. thanks!
09:12:05 <travisyay> quicksilver: though now it says cant find file...
09:12:36 <zygoloid> chrisdone: hypothetically: data Foo a => T a where C :: a -> T a; f :: T a -> Int; f a = {- no instance Foo a visible here -} case a of C b -> {- instance Foo a visible here, though -} foo b
09:12:54 <zygoloid> assuming that the "Foo a =>" constraint is effectively just moved to the C constructor
09:13:23 <hpaste> chrisdone pasted “gadt messing, zygoloid” at http://hpaste.org/49078
09:13:54 <chrisdone> zygoloid: oh, yeah, that's odd
09:14:58 <arw__> is there still active development on 'House'?
09:17:01 <chrisdone> zygoloid: would you put contexts in that?
09:18:16 <kmc> arw__, not afaik
09:19:35 <blubsala> though the last time I checked (house was inactive even then ) there were some persons still playing with haskell as an operating system language
09:19:41 <chrisdone> i tend to forget why contexts in data constructors is a bad idea
09:19:52 <chrisdone> other than prematurely limiting an api
09:20:08 <quicksilver> contexts in data constructers in haskell98 is bad because it's unexpected
09:20:17 <quicksilver> you don't actually get the benefit of the context when you pattern match.
09:20:22 <quicksilver> GHC GADTs remove this problem
09:20:36 <quicksilver> so for GADTs (even if you don't use any of the GADT features) you do get the context back.
09:20:40 <chrisdone> ahhh
09:20:50 <quicksilver> the first remark is, arguably, a bug in haskell98
09:20:53 <quicksilver> but we're stuck with it.
09:21:11 <quicksilver> however, anecdotally, they are code smell
09:21:18 <Saizan> to be pedant, in haskell98 you simply can't have contexts on single data constructors, only on the whole datatype
09:21:31 <quicksilver> you might *think* you always want that context but it restricts your polymorphism
09:21:33 <arw__> blubsala, kmc: hm, thanks. the idea would be to create a small, secure and statically configured cloud appliance.
09:21:40 <quicksilver> Saizan: I believe you are wrong, actually.
09:22:16 <chrisdone> quicksilver: how do you have contexts on a data constructor in h98?
09:22:30 <Saizan> quicksilver: data Foo a = C a => Foo a is not standard even if ghc accepted it without extensions for a while
09:22:40 <quicksilver> no, I think Saizan is right, and I was confused
09:22:42 <quicksilver> by a GHC bug
09:22:47 <quicksilver> and a bad memory :)
09:22:54 <quicksilver> I think I even reported that bug :P
09:23:06 <Saizan> yeah :)
09:23:13 <arw__> blubsala, kmc: so something like a preconfigured image consisting of an operating system and an application (like e.g. webcache or key-value-store) that could then be deployed to a large number of instances.
09:23:34 <chrisdone> ah, ok
09:23:35 <blubsala> arw__ there is a licensing issue, as haskell uses some lgpl library for Integer, which only allows gpl or lgpl if you staticly bind it
09:23:39 <Saizan> btw, "data C a => Foo a = ..." got removed in haskell2011 (which ended up being an amending of haskell2010)
09:24:09 <arw__> blubsala: that wouldn't be a problem, its for a research project, nothing commercial.
09:24:18 <Tomsik> Why are contexts on data a bad thing?
09:24:35 <quicksilver> Tomsik: because they don't work.
09:24:41 <quicksilver> they don't actually give the context back when you pattern match.
09:24:46 <Tomsik> okay
09:24:52 <quicksilver> except if you use GHC, and GADT syntax, and put them on constructors.
09:25:02 <quicksilver> in which circumstance they are potentially useful.
09:25:07 <Tomsik> It worked pretty well with existentials
09:25:16 <quicksilver> that's entirely different
09:25:19 <quicksilver> they're very useful
09:25:23 <quicksilver> (although massively overused)
09:25:27 <Tomsik> What's the difference?
09:25:44 <Tomsik> Ah, you mean like you don't hide the a in type
09:25:52 <Tomsik> yet restrict it?
09:26:03 <Saizan> data C a => Foo a = Bar a; <- this won't give you C a when you pattern match on Bar
09:26:11 <Tomsik> Okay
09:26:27 <blubsala> arw__ as far as I remember there is also a L4 microkernel implementation in haskell that was proven correct and has a C implementation thta is proven to be the same as the haskell version
09:26:28 <Saizan> data Foo a = C a => Bar a; <- this one(or using gadt syntax)  will
09:26:40 <blubsala> don't know if that helps you
09:27:14 <travisyay> quicksilver: sorry my internet disconnected, but how would you locate a file in command prompt? it says the location couldnt be found
09:27:16 <Tomsik> Ah, here is the difference, where you place the C a =>
09:27:27 <travisyay> quicksilver: or actually it says "no location info"
09:27:28 <Saizan> existentials are a special case of the second, where the 'a' is quantified inside rather than being a parameter of the type
09:28:07 <travisyay> quicksilver: never mind i got it!
09:29:48 * chrisdone loves the MonadWriter class dearly
09:30:52 <chrisdone> a wee bit disappointed hjscript's monad is a concrete type instead of a class
09:31:15 <chrisdone> dear library writers: please make your monads a class and have all your functions implemented in terms of methods on that class
09:31:40 <quicksilver> does it really help?
09:31:47 <quicksilver> I mean, it's not enough
09:31:56 <quicksilver> if you want the class to be useful then they dont' *just* need to expose a class
09:32:07 <quicksilver> they also need to expose enough machinery for you to make your own instances of that class
09:32:29 <quicksilver> (for example, a monad transformer, but that's not the only conceivable kind of machinery)
09:32:33 <chrisdone> in most cases their monad is just a stack of reader/writer/state, yet they make it opaque
09:33:25 <quicksilver> sure. In which case they could expose a transformer, like parsec does.
09:35:12 <chrisdone> MonadCGI and MonadSnap both export a nice simple class, these are examples that work well
09:35:51 <chrisdone> then I can just write
09:35:52 <chrisdone> newtype Controller a = Controller {
09:35:53 <chrisdone>     runController :: ReaderT ControllerState Snap a
09:35:53 <chrisdone>   } deriving (Monad ,Functor ,Applicative ,Alternative ,MonadReader ControllerState ,MonadSnap ,MonadIO ,MonadPlus ,MonadCatchIO)
09:36:01 <chrisdone> and away I go, no lifts or that nonsense
09:37:17 <quicksilver> chrisdone: ah, OK, but that's not *just* because they export a class
09:37:24 <quicksilver> chrisdone: you missed an important part I think.
09:37:35 <quicksilver> they *also* supply lifting instances for that class through ReaderT
09:37:39 <quicksilver> (and, I daresay, other things)
09:38:17 <quicksilver> I do agree with your sentiment, I'm just at pains to point out that a class alone is uselses. You need some machinery to get other instances of that class than the one they provide.
09:38:20 <chrisdone> quicksilver: lifting instances?
09:38:28 <mightybyte> quicksilver: The lifting function is the only thing in MonadSnap.
09:38:53 <jonkri> is there something like "toChunks :: ByteString -> [ByteString]" but that returns one ByteString element instead?
09:38:54 <chrisdone> ah, sorry. lifting method
09:39:07 <jonkri> Data.ByteString.Lazy
09:39:18 <Saizan> you need a "MonadSnap m => MonadSnap (ReaderT r m)" in scope for that deriving of MonadSnap Controller to work
09:39:29 <mightybyte> Oh, right.
09:39:37 <c_wraith> jonkri: that's not necessarily possible.  lazy bytestrings can be infinite.
09:39:56 <c_wraith> jonkri: if you're sure it is possible in your case, just use ByteString.concat on the result
09:40:14 <quicksilver> chrisdone: no, lifting instance.
09:40:16 <chrisdone> quicksilver: I see your point, yeah
09:40:21 <quicksilver> chrisdone: the thing that Saizan pasted.
09:40:26 <quicksilver> "deriving MonadSnap" isn't magic
09:40:33 <chrisdone> i know
09:40:40 <quicksilver> the instance for MonadSnap (ReaderT....) has to be there.
09:40:59 <quicksilver> and this still doesn't let you combine Snap and CGI
09:41:05 <luite> jonkri: like concat.toChunks ? or do you want just a single chunck?
09:41:06 <quicksilver> (although that would be stupid, I guess, but that general idea)
09:41:24 <jonkri> c_wraith, i'm not sure. does it depend on the size? it's a uuid so it should be 16 bytes
09:41:40 <luite> oh c_wraith was faster :)
09:41:50 <c_wraith> jonkri: who would ever make a UUID a lazy bytestring?  eww.  :)
09:41:59 <c_wraith> jonkri: yeah, just concat the pieces
09:42:12 <jonkri> c_wraith: http://hackage.haskell.org/packages/archive/uuid/1.2.2/doc/html/Data-UUID.html#v:toByteString
09:42:15 <jonkri> thanks
09:42:19 <jonkri> :)
09:42:43 <jonkri> how large can a bytestring be?
09:42:50 <jonkri> when is it not safe to concat?
09:42:52 <luite> jonkri: infinite
09:43:03 <luite> a lazy one at least
09:44:07 <luite> practical limits will depend on whether you use 32 or 64 bit :)
09:44:17 <jonkri> ah, i get it
09:44:22 <jonkri> :)
09:45:59 <quicksilver> actually lazy bytestrings are not even limited by your memory model
09:46:15 <quicksilver> as long as you are a 'good consumer'
09:46:42 <quicksilver> it will take a little while to process a bytestring > 2^64 bytes long even on a fast 64-bit machine though.
09:46:54 <jonkri> i see :)
09:47:31 <quicksilver> you can certainly conceive of processing a > 4G one on a 32 bit machine though - streaming a video could easily do that.
09:48:58 <chrisdone> quicksilver: at least in this case I have the option to provide that ReaderT instance myself
09:49:34 <jonkri> interesting. brb
09:52:57 <erus`> anyone got google+ invites please? :)
09:53:32 <shepheb> erus`: heh. I work on Plus. /msg me your email and I'll hook you up.
09:54:11 * chrisdone watches as shepheb is flooded to oblivion
09:54:14 <shepheb> no promises on whether signups are open right now.
09:56:07 <ion> I wouldn’t mind trying +, but Google Apps users are second-class users as usual. :-P
09:56:08 <chrisdone> I thought a nice way to carry state around in hjscript would be to ReaderT transform it but all its functions work on HJScript a, so either I write lift/runReaderT everywhere or rewrite the whole library. neither of which I feel like doing
09:58:15 <chexxor> about how big is the plus team? and how long has it been under development? just curious
10:02:42 <chrisdone> shepheb: i noticed that i added someone to my Friends circle with the top-right notification widget, but going directly to my circles page he wasn't there or to that user it showed the 'add to my circles' (as in this guy isn't in your circles yet) button. i refreshed and it updated. from gmail you expect stuff to update in the UI, i suppose. wouldn't be surprised if you were aware of this. also, 99% of my acquaintanc
10:02:42 <chrisdone> es are haskellers :p
10:03:59 <erus`> ok i need more friends :)
10:04:34 <chrisdone> erus`: add me! you'll never guess what my username is…
10:04:59 <erus`> but what circle do you go in?
10:05:14 <erus`> maybe i will make a lambda circle
10:05:34 <chrisdone> a · circle :-)
10:05:48 * ski . o O ( circles of hell ? )
10:06:42 <erus`> when i follow someone do they see that i added them or whatever?
10:06:45 <chrisdone> the hangout stuff is really cool. the linux plugin Just Works
10:06:46 <c_wraith> chrisdone: yes, I added you to a circle named "haskellers" :)
10:06:52 <Eduard_Munteanu> erus`: like this one? http://uncyclopedia.wikia.com/wiki/File:Halflife-Haskell.jpg
10:06:56 <chrisdone> c_wraith: :D
10:06:58 <Eduard_Munteanu> :P
10:07:25 <chrisdone> c_wraith: what's your real name? I don't have a complete mapping of nick → real name
10:07:33 <chrisdone> (in my head)
10:07:58 <c_wraith> chrisdone: Carl Howells.  (not really a secret, it's been mentioned before, though less directly)
10:08:10 <mercury^> are you talking about g+?
10:08:17 <c_wraith> yeah
10:08:29 <mercury^> is g+ worth it?
10:08:46 <c_wraith> it seems to be relatively low-energy to use.
10:08:48 <chrisdone> c_wraith: ah, i added you to my ‘Haskell’ circle.
10:08:50 <mercury^> I am undecided at the moment on creating yet another account.
10:09:27 <mercury^> creating/maintaining
10:10:39 <chrisdone> i don't have facebook so i'm not well acquainted with this kind of social awareness. tried out g+ and goodness there are a lot of haskellers. g+ tapped into my x years worth of haskell-cafe archive-generated 'contacts', I think
10:11:47 <c_wraith> yeah, that's exactly what it did.
10:12:48 <mercury^> chrisdone: wait, you've been at this for several years now? I still remember you making your baby steps. :o
10:12:59 <mercury^> (as if it was yesterday)
10:14:03 <chrisdone> 2008~
10:14:19 <chrisdone> i feel bad that i don't remember you :<
10:15:04 <chrisdone> mercury^: what's your real name?
10:15:19 <mercury^> Rohan Lean, whois does not lie in my case.
10:16:09 <mercury^> I seem to be really dull. No one from freenode ever remembers me. :>
10:18:23 <chrisdone> haha, i think it's the name. maybe the circumflex disturbs my perception and creates a const False filter
10:22:03 <Saizan> (ski: http://i.imgur.com/CYMP3.png )
10:22:35 <chrisdone> Saizan: hahaha
10:23:52 <Cale> What do we call the world of Google+? Circlesphere! The geometry is out of control.
10:24:58 <olsner> hmm, a circlesphere should be 5-dimensional, right?
10:25:43 <ski> well, a circle is one-dimensional and a sphere is two-dimensional ..
10:26:21 <shepheb> chrisdone: yeah, that's a known issue with the notificaitons bar. it also doesn't update in the other direction (add someone to circles, then open notifications and it's not updated)
10:30:40 <chrisdone> shepheb: ah, yeah, good point. must be pretty fun working on it. most people i've seen really like it
10:33:32 <chrisdone> shepheb: is it written in GWT? i don't know whether you can reveal stuff like that. but i see that the source looks similar to GMail's, outputting these generated classes and JSON-esque data inside the HTML source presumably representing the state of the UI
10:33:51 <c_wraith> chrisdone: important to not that gmail is not written with GWT. :)
10:33:54 <c_wraith> *note
10:34:18 <chrisdone> c_wraith: oh. I just assumed it was some JS abstraction at least similar to GWT. do you know what it's written in?
10:35:26 <chrisdone> googling says gmail is written in java, but i see only mere hearsay at this point
10:36:08 <chrisdone> “At the USENIX annual conference last month, Gmail engineer Adam de Boor surprised the audience by noting that the company's Gmail service was written entirely in JavaScript, and that all of its code, around 443,000 lines worth, was written by hand.”
10:36:09 <chrisdone> oh
10:37:15 <c_wraith> GWT was more of a "this would have been a good idea" sort of thing.
10:37:28 <c_wraith> I'm not sure it's actually used by any google product.
10:38:22 <gigabytes> chrisdone: so it's javascript, not java
10:38:46 <Eduard_Munteanu> Eww.
10:38:51 <chrisdone> gigabytes: that's what it says
10:39:58 <chrisdone> javascript and 500,000 unit tests presumably :-)
10:40:44 <Eduard_Munteanu> That's like voluntarily choosing to write an OS kernel in Postscript, weird programming fetish.
10:41:01 <chrisdone> Eduard_Munteanu: context: http://www.nytimes.com/external/idg/2010/07/22/22idg-google-executive-frustrated-by-java-c-complexity-62392.html
10:41:34 <chrisdone> Eduard_Munteanu: it seems Pike doesn't like java or c++, and clearly, then, the only option was javascript
10:43:04 <Eduard_Munteanu> Yeah, weird.
10:43:59 <chrisdone> (ah, and hence, go)
10:47:36 <ash__> in parsec, what is st? as in function a signature :: CharParser st [(String, String)]
10:48:53 <ion> Huh, that’s a Parsec type?
10:48:57 <Eduard_Munteanu> ash__: it's a type variable, they could've named it 'a'. But its name suggests it's the type of the state.
10:49:03 <pikhq_> ash__: Parsec's parsers are based on the State monad. st is the type of the state variable that Parsec uses, IIRC.
10:49:32 <chrisdone> it's for user state
10:49:40 <ash__> ah
10:49:40 <ash__> okay
10:49:50 <pikhq_> Oh, it's for *user* state? I haven't done much complex with Parsec; sorry.
10:49:51 <chrisdone> you get the state with getState
10:49:57 <ash__> For some reason i thought it was replacing ->
10:50:11 <chrisdone> ion: it's in the old parsec
10:50:22 <pikhq_> Still a State-type monad. Just a different sort. :)
10:50:50 <chrisdone> http://hackage.haskell.org/packages/archive/parsec/2.1.0.0/doc/html/Text-ParserCombinators-Parsec-Prim.html#t:State
10:50:54 <ash__> thanks, that hepls
10:51:50 <Eduard_Munteanu> ash__: nah, CharParser looks like it's of kind * -> * -> *
10:52:02 <chrisdone> it's not so well documented in the haddocks. it's better on the manual: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html#GenParser
10:52:11 <ash__> Eduard_Munteanu: I got that from http://book.realworldhaskell.org/read/using-parsec.html
10:52:55 <chrisdone> RWH has this to say about it: "The st can be ignored for now." :-)
10:53:10 <chrisdone> i guess that's why ash__ was curious
10:53:31 <ash__> ya, they never go back and explain what that st represents
10:55:31 <chrisdone> what's a generic way to write do x <- foo; m; return x
10:55:46 <ash__> I guess parsec is different now? in the RWH tutorial they said hexDigit :: CharParser st Char but in the current parsec docs its hexDigit :: Stream s m Char => ParsecT s u m Char
10:55:53 <chrisdone> @pl \a -> do x <- foo; m; return x
10:55:54 <lambdabot> (line 1, column 18):
10:55:55 <lambdabot> unexpected ";"
10:55:55 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
10:56:54 <chrisdone> ash__: yeah, RWH refers to parsec2. the latest parsec is 3. they changed the API a bit. for you, I'd refer to the parsec2 docs: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
10:57:01 <ion> chrisdone: foo <* m
10:57:21 <chrisdone> ash__: parsec3 requires grokking monad transformers which you may not grok yet?
10:57:37 <chrisdone> ion: ah, of course. lovely
10:57:43 <ash__> ya, I haven't really dealt with monad transforms
10:57:54 <ion> http://heh.fi/haskell/functors/
10:58:39 <chrisdone> ion: i'm aware of applicative, used it lots, but i tend to forget it exists sometimes
11:01:21 <chrisdone> emacs users — paredit functions work great with haskell
11:01:25 <ash__> I ran into The Other Prelude on the haskellwiki, would that reduce the number of varieties of some built in functions, like map (and there is mapM, mapM_)
11:04:32 <chrisdone> local :: MonadWriter w m => m a -> m (a,w)
11:04:32 <chrisdone> local = censor (const mempty) . listen
11:04:39 <chrisdone> nice func :-)
11:08:54 <edwardk> local makes me sad
11:09:08 <edwardk> well, censor and listen do
11:09:10 <chrisdone> :(
11:09:39 <chrisdone> edwardk: why's that?
11:10:30 <chrisdone> because they can be defined with local?
11:11:49 <chrisdone> listen m = (a,w) <- local; tell w; return (a,w); censor f m = (a,w) <- local; tell (f w); return a
11:11:55 <chrisdone> i *think* that's right
11:12:17 <chrisdone> (ah, missing dos, but w/e)
11:14:37 <chrisdone> edwardk: `tell' me why they make you sad please! ;-) I had pondered how well-designed they were when using them, your perspective interests me
11:18:27 <Eduard_Munteanu> Maybe other kinds of MonadWriter make sense too?
11:19:09 <Eduard_Munteanu> (e.g. one that where you can't derive those from 'local')
11:19:57 <edwardk> chrisdone: they don't stack as well as tell does. In particular many monads that could otherwise be a writer, like one that logs to a database or stdout can't implement them
11:20:12 <edwardk> chrisdone: a similar awkward example is local in MonadReader
11:20:29 <edwardk> it precludes some monad transformed stacks from giving you ask
11:21:10 <chrisdone> edwardk: ah, that's a good point. it breaks down with those cases
11:21:11 <edwardk> I'd be happier if MonadReader was split into two classes a MonadReader and a MonadLocal, and writer was similarly split into MonadWriter and MonadListen or some such
11:21:48 <edwardk> one can make an argument that callCC has the wrong type as well, because it is a bad rank-1 comproise
11:21:51 <edwardk> er compromise
11:22:00 <edwardk> and there is a better rank 1 compromise ;)
11:22:06 <Eduard_Munteanu> (would there be any axioms for these monads?)
11:22:27 <Eduard_Munteanu> (erm, invariants)
11:22:32 <edwardk> insofar as there are now
11:23:16 <ski> edwardk : you mean `callCC :: MonadCont m => ((a -> m Void) -> m a) -> m a' ?
11:23:24 <edwardk> callCC has the problem that the type it offers is ((a -> m b) -> m a) -> m a — which is basically Peirce's law
11:23:36 <edwardk> but the b should be quantified
11:23:52 <edwardk> but that takes a rank 3 type
11:24:12 <edwardk> but you can avoid the rank 3 type by noting that a forall b. (b -> r) -> r — is just an r.
11:24:22 <edwardk> and replacingit with
11:24:32 <edwardk> label :: ((a -> r) -> m r) -> m r
11:24:40 <edwardk> and then move the quantifier to the call site
11:24:49 <edwardk> break :: (a -> r) -> a -> m r
11:25:42 <edwardk> then label and break give you the equivalent of the rank-3 callCC, you just 'break' to the right label, using rank-1 types.
11:25:44 <ski> shouldn't it be `m a' in `label' ?
11:25:48 <edwardk> yeah
11:25:55 <edwardk> it should =)
11:26:17 <edwardk> it means that MonadCont would pick up the 'r' as part of the class signature
11:26:20 <ski> i'm not sure about `break' either ..
11:26:31 <edwardk> we can quibble about names later
11:26:32 <chrisdone> edwardk: yeah, that distinction for reader/local and writer/listen would sit fine with my use cases — what about the monoid instance for the w? for writing to stdout and database, that's not really necessary, you don't collect output. I imagine for MonadWriter' it wouldn't need it in the class context
11:26:35 <edwardk> the idea is what matters
11:26:46 <ski> edwardk : i meant about the type signature of `break' :)
11:26:52 <edwardk> the monoid instance for w is also an annoyance that shouldn't be required
11:27:14 <edwardk> ah. break :: (a -> r) ->  a -> m b
11:27:25 <edwardk> i don't have the code for this in front of me ;)
11:28:06 <edwardk> class MonadCont r m where label :: ((a -> r) -> m a) -> m a; break :: (a -> r) -> a -> m b
11:28:26 <edwardk> then you can label $ \exit -> do ….; break exit 12; ...
11:29:02 <edwardk> and the fact that you invoke break in each location lets the continuation type vary
11:29:12 <edwardk> giving you the power of the rank 3 type without one
11:29:42 <ski> an alternative could be `class MonadCont cont m where label :: (cont a -> m a) -> m a; break :: cont a -> a -> m b'
11:30:04 <edwardk> yeah
11:30:47 <ski> does making `cont = (-> r)' transparently make things nicer, in some way ?
11:31:05 <edwardk> it makes it easier to call multiple times locally if you want to
11:31:24 <ski> i'm not sure how you mean
11:31:26 <edwardk> on the other hand the opaque version may admit more instances
11:31:39 <edwardk> well, knowing it is a function lets me call it
11:32:02 <edwardk> and knowing the result type r lets me use the result of it.
11:32:19 <ski> hm .. and construct continuations that you haven't got from `label', as well
11:32:20 <edwardk> so i'm empowered to do more than just break
11:32:26 <edwardk> yeah
11:32:40 <ski> the question is whether being able to do this is good or bad :)
11:33:17 <edwardk> these are the big three changes that i've been unwilling to foist off on the mtl
11:34:00 <ski> (of course, in particular cases, you could still have `instance MonadCont (Flip (->) r) (Cont r)' e.g.)
11:34:07 <edwardk> one could also argue that callCC could have two versions, since we wind up plumbing the abort and commit versions everywhere
11:34:28 <edwardk> the newtype noise is somewhat galling though
11:34:35 <ski> yeah
11:34:46 <edwardk> and might turn away folks who would be otherwise see it as a pure improvement
11:35:48 <ski> one could use a more specific one (i'd call it `Cont r', if `Cont r' wasn't already taken for the monad)
11:37:06 <edwardk> yeah
11:37:38 * ski continues to attempt to hack MetaML
11:37:45 <edwardk> i think the MonadCont r m seems like the most reasonable compromise lest one of the instances doesnt work out
11:38:12 <edwardk> it also seems to remove some questions about committing or ignoring state changes
11:38:29 <edwardk> fewer state monads floating around
11:39:24 * ski never got what the trouble there was exactly
11:41:06 * shepheb returns from a meeting
11:41:30 <chrisdone> shepheb: rolling out the next 10 features of g+ ;-)
11:41:54 <chrisdone> next up: set operations on the circles
11:42:28 <edwardk> see http://hackage.haskell.org/packages/archive/transformers/0.2.2.0/doc/html/Control-Monad-Trans-State-Lazy.html liftCallCC and liftCallCC'
11:42:50 <edwardk> by default we rollback state in state transformed cont
11:42:53 <edwardk> but we could preserve it
11:43:32 <shepheb> now on a Hangout meeting, brb
11:44:45 <ski> "does not satisfy the laws of a monad transformer" sounds like a no-no, to me
11:45:02 <chrisdone> class (MonadState Integer m,MonadWriter [Node m] m) => MonadJi m
11:45:03 <chrisdone> instance (MonadState Integer m,MonadWriter [Node m] m) => MonadJi m
11:45:06 <chrisdone> is there a name for this idiom?
11:45:18 <edwardk> i call them class aliases
11:45:19 <chrisdone> (+ UndecidableInstances)
11:45:27 <chrisdone> ah, good. that makes two of us
11:46:20 <chrisdone> they're so nice!
11:46:29 <edwardk> yeah
11:46:42 <edwardk> if only they didn't take me out of haskell 98 =(
11:47:07 <chrisdone> ah, you have coding standards mandating h98?
11:47:12 <mornfall> You need that instance even if you don't write that "where"?
11:47:16 <mornfall> -that
11:47:37 <ski> yes
11:47:42 <mornfall> Hm.
11:48:00 <edwardk> mornfall: it lets him write the shorter name rather than the composite set of classes
11:48:25 <Igloo> H98, not H2010?
11:48:29 <mornfall> I see.
11:48:56 <edwardk> igloo: well, i tend to code to the intersection of things i get from both, since i don't really get anything new from 2010
11:49:16 <edwardk> at least for 70% or so of my public packages
11:49:36 <edwardk> the stuff down at the bottom of the tower. then i let it get more exotic towards the top.
11:50:37 <chrisdone> mornfall: i have a bunch of library functions i'm writing, rather than opt for a concrete type or a transformer, it's nicer if i can keep it abstract. this practice in general seems good. some functions might only need a reader instance, others writer. it's more descriptive of how the function will behave imho
11:52:05 <chrisdone> e.g. compare x :: Ji (), y :: Ji () vs x' :: MonadIO m => m (), y' :: MonadReader Env m => m ()
11:52:13 <edwardk> i guess i should pick a different name than break because of the prelude conflict
11:52:15 <shepheb> okay, now really back
11:52:16 <chrisdone> the latter's more verbose but it tells you more
11:52:58 * ski does not suggest `throw'
11:53:11 <chrisdone> `bail'?
11:53:21 <c_wraith> longjmp
11:53:27 <mornfall> chrisdone: I tend to agree.
11:53:34 <edwardk> bail =)
11:53:36 <edwardk> i like it
11:53:38 <edwardk> bbiab
11:53:41 <shepheb> chrisdone: we're always rolling out fixes and improvements.
11:53:53 <shepheb> saw some demos of some seriously sexy upcoming features.
11:54:11 <shepheb> as to the languages things are written in, that Googler you quoted may have been referring to the client side Javascript
11:54:42 <chrisdone> shepheb: sure — I didn't expect the server-side would be in JS (maybe that was presumptuous of me)
11:54:56 <shepheb> and we do write in Javascript, by hand. people think it's generated, possibly by GWT, because it looks completely unreadable, two-letter names and so on
11:55:16 <shepheb> there are definitely some Googlers who want to write servers in Node.js, but afaik there's nothing like that currently.
11:55:17 <chrisdone> shepheb: I guess it goes through google closure?
11:55:46 <shepheb> Closure is step one, yeah. there's a more pimped-out internal Closure that has libraries for lots of Google backends and interchange formats and on and on
11:55:55 <chrisdone> makes sense
11:56:00 <shepheb> and then through a compiler that checks types (\o/) and mangles the code completely
11:56:13 <chrisdone> is that official Google™ terminology? 'pimped-out internals'? :-)
11:56:21 <shepheb> haha
11:56:21 <c_wraith> Sounds official
11:56:24 <chrisdone> nice
11:56:40 * hackagebot resource-pool 0.2.0.1 - A high-performance striped resource pooling implementation  http://hackage.haskell.org/package/resource-pool-0.2.0.1 (BryanOSullivan)
11:56:45 <shepheb> surely somewhere in Google's history there's been a "pimp your code" project
11:57:29 <chrisdone> (i have a smallish code base (12k lines) but it takes 15-20 seconds in closure, and about 5 in uglifyjs, so i'm using that, hehe)
11:57:58 <kmc> isn't the client side javascript at least automatically minified?
11:58:02 <chrisdone> Google Summer of Pimping My Code
11:58:20 <chrisdone> kmc: that's what Closure does
11:58:32 <kmc> oh i see
11:58:37 * kmc misread it as Clojure of course
11:58:52 * chrisdone tends to type clojure a lot instead of closure
11:58:54 <shepheb> chrisdone: clearly you need a data centre to compile your Javascript :P
11:59:10 <chrisdone> shepheb: show off! :p
11:59:21 <luite> how often do you compile your javascript?
11:59:40 <shepheb> it's kind of silly, actually. rocking the 6-core Xeon desktops, 12GB RAM... and our compiles run in the datacentres
12:00:05 <chrisdone> i compile it only when i deploy. but if someone's discovered a bug and i want to fix it right away, waiting those extra 10 seconds feels like an hour
12:00:10 <shepheb> luite: all the time, in my case. automatically recompiles on a request when the code has changed, takes ~10 seconds for me.
12:00:37 <shepheb> I don't complain for a second because it means type checking
12:00:43 <luite> ah I tend to develop with non-compiled javascript and compile when deploying
12:00:49 <chrisdone> same here
12:01:10 <chrisdone> shepheb: how do you debug exceptions in that mangled mangleness?
12:01:31 <shepheb> fortunately there's a debug compile mode that only mangles the names a little (turns foo.bar.baz.quux into foo$bar$baz$quux and makes everything global)
12:01:34 <chrisdone> or do they just Not Happen thanks to the type checking?
12:01:38 <chrisdone> ah, I see
12:02:01 <rvn_> :t >=>
12:02:03 <lambdabot> parse error on input `>=>'
12:02:12 <rvn_> :t (>=>)
12:02:13 <luite> I'm trying coffeescript now, but it means having to debug the generated code
12:02:13 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
12:02:15 <shepheb> it is annoying to get a bug only on a build that doesn't accept the debug flags, though. "Array index undefined: this.aB" isn't helpful
12:02:27 * chrisdone has found that 9 times out of 10 his JS exceptions are type errors, things not in scope anymore, stuff that Haskell catches as you code. I must be spoiled by haskell because I hate developing in JS
12:02:47 <shepheb> I thought I would raeg about types, but the type checker is pretty good.
12:02:51 <chrisdone> shepheb: yeah, then I guess it's back to printf debugging
12:03:01 <shepheb> some teams make everything take and return Object, but mine doesn't
12:03:09 <shepheb> alert() debugging go go
12:03:45 <chrisdone> alert(JSON.stringify(…)) ftw
12:04:05 <luite> hehe
12:04:12 <gwern> (so much vandalism on hawiki. the romanian editor writing articles in romanian with a username like 'Ha$kell'does not help me *in the least*.)
12:04:33 * gwern can very close to blocking him out of hand for a nick like that
12:04:44 <luite> I feel that my javascript debugging skills are rather primitive, mostly relying on console.log and the chrome debugger
12:05:12 <chrisdone> shepheb: I used hjscript on hpaste.org. it's only 20 lines but it was pretty nice. type checking for free!
12:05:32 <chrisdone> I've noticed that console.log() will print objects as they are /now/, not as they were at the time of printing. that can trip you up you aren't aware of it
12:06:21 <luite> huh that's strange, it isn't lazy or anything is it?
12:06:34 <chrisdone> var x={};x.y=1;console.log(x);x.y=2;
12:06:44 <chrisdone> have a look at what you get
12:06:47 <ski> (hawiki or haskellwiki ?)
12:07:06 <shepheb> chrisdone: I lost half a day to the console.log behavior of Chrome.
12:07:12 <chrisdone> I think it's because it's more of an inspector than a printer, if you know what I mean. it looks at the contents as you click. could call it lazy but don't think it's analogous
12:07:20 <chrisdone> shepheb: heh, what were you doing?
12:07:47 <shepheb> expecting it to be a snapshot of when it was printed
12:07:50 <luite> chrisdone: hmm, what does clicking have to do with it?
12:08:04 <shepheb> eventually I alerted it so I could check on iPhone, and saw that it was different
12:08:18 <shepheb> luite: when you click the arrow to expand a layer
12:08:29 <shepheb> that's when it samples the actual object's state
12:08:36 <chrisdone> luite: actually, i had a debate with my colleague about the true nature of its behaviour. still don't know
12:08:40 <shepheb> I also triggered a big-ass memory leak by console.logging stuff
12:08:44 <shepheb> counts as a reference!
12:08:53 <chrisdone> eek
12:08:54 <luite> shepheb: what layer?
12:09:26 <shepheb> luite: it prints > Object. you click the > and get Object { > foo: Object, > bar: Function }
12:09:34 <luite> ooh right
12:09:36 <shepheb> I think it samples the state of the object when you click the >
12:09:49 <luite> yes I see what you mean now
12:10:01 <luite> I usually print strings and json
12:10:09 <chrisdone> for a while i thought console.log was asynchronous
12:10:37 <luite> thanks for the warning :)
12:10:47 <shepheb> nobody told me there were breakpoints in Chrome until like last week
12:10:47 <luite> I was planning to do some javascript hacking this weekend
12:10:55 <shepheb> you can just put "debugger;"
12:10:58 <chrisdone> shepheb: i'm still not sure it's not asynchronous
12:10:58 <shepheb> and it'll breakpoint
12:11:01 <chrisdone> var y={};y.a=1;setTimeout(function(){alert(JSON.stringify(y))});y.a=2;
12:11:06 <chrisdone> ^ gives you similar behaviour
12:11:24 <luite> oh I've always set my breakpoints manually in the debugger
12:11:56 <shepheb> using debugger; is awesome in my case because the code gets hacked up, dumped into one file, etc.
12:12:05 <chrisdone> shepheb: ah, no. i updated the object after printing it and then when I clicked i got '3'. yep, myth confirmed
12:12:21 <luite> shepheb: oh doesn't chrome use a mapping file to the original source for that?
12:12:44 <shepheb> chrisdone: the really scary part
12:13:01 <shepheb> is testing what happens if I modify layer N, expand it, modify layer N+1, then expand that
12:13:09 <shepheb> can I get a skewed snapshot of the object?
12:13:20 <shepheb> or does it sample the whole tree when first expanded?
12:13:31 * chrisdone tries
12:13:48 * shepheb bets on "yes, it can be skewed"
12:14:05 <shepheb> partly because I've been doing this web dev thing for a while, and expect to suffer
12:14:06 <chrisdone> yep, lazy all the way down
12:14:19 <luite> would hjscript be suitable to write larger things?
12:14:28 <shepheb> makes sense from an implementation POV, but I wish I'd known before I stumbled across it.
12:15:48 <chrisdone> luite: i tried rewriting my space game in it… i think it will allow a lot of power but i'll probably want to patch HJScript substantially. i'll let you know if i get anywhere with it
12:15:55 <luite> hmm
12:16:12 <luite> chrisdone: but for example have you written anything like jquery-console with it?
12:16:14 <chrisdone> shepheb: yeah it's useful as an inspector i guess
12:16:16 <shepheb> lul Bing advertisement on Gmail.
12:16:42 <mornfall> shepheb: Makes a lot of sense, doesn't it? :)
12:16:57 <chrisdone> luite: no, i thought about that as another smallish-but-big-enough-to-give-insights experiment
12:17:33 <chrisdone> like, er, how do you make global variables in HJScript?
12:18:02 <luite> hehe I was asking because my code actually started with jquery-console, but it kind of diverged because I needed a different interface... :)
12:18:04 <chrisdone> or variables within an object? you have this problem that variables are initialized as a monadic action
12:18:16 <chrisdone> luite: yeah i saw that, the graph stuff right?
12:20:11 <luite> chrisdone: the main difference is how you edit stuff, up/down move to other lines instead of cycling through history. and the editor has been replaced with codemirror
12:20:13 <chrisdone> anyway, i realised that i could initialize my globals like: do x <- varWith …; y <- varWith …; runReaderT … State { x = x, y = y}; and then i've got my JS-level globals, passed around in the reader monad. somehow that seems really nice to me
12:20:26 <chrisdone> luite: ahh, ok
12:20:54 <luite> chrisdone: the way the editor is implemented in jquery-console doesn't really scale to larger multi-line things
12:21:40 <luite> but the code is a huge mess now, so I wanted to try and clean it up this weekend
12:21:49 <chrisdone> yeah it's pretty simple
12:22:18 <chrisdone> maybe you could rewrite it in hjscript :p
12:22:43 <chrisdone> then i can rewrite tryhaskell with blaze-html and hjscript and all the codebase will be haskell! fwuhaha!
12:22:45 <OceanSpray> why do polytypes have the same kind as monotypes?
12:22:51 <luite> yeah I'm not sure... I'm afraid that I'll run into lots of limitations :)
12:23:11 * chrisdone just actually laughed maniacally, after opening both his windows, and feels embarrassed
12:23:16 <luite> since my code is way more javascript-heavy than most sites
12:23:28 <chrisdone> I'd definitely wage that would happen
12:23:46 <OceanSpray> also
12:24:06 <OceanSpray> are type families inhabited?
12:24:09 <chrisdone> it seems hjscript suffers from no real use cases, i guess it's up to us to make them and correct its faults
12:25:16 <chrisdone> luite: here's the js on hpaste: https://github.com/chrisdone/amelie/blob/master/src/Amelie/View/Script.hs not much, but it feels nice for the small case
12:25:51 <luite> ah thanks, still relatively simple
12:25:53 <shepheb> DELICIOUS PROTEIN-LOADED BABY FOOD
12:25:54 <chrisdone> I like that you're not writing (function(){ ... }) all over the place
12:25:55 <shepheb> whoa, mischan
12:26:01 <shepheb> ...
12:26:12 <shepheb> (joking about eggs)
12:26:17 <chrisdone> shepheb: #recentlybecameparents?
12:26:19 <luite> chrisdone: I started trying coffeescript for that :)
12:26:22 <shepheb> haha
12:26:35 <luite> though tht doesn't buy you much else
12:26:44 <chrisdone> luite: indeed. i like CfS for that
12:27:07 <shepheb> someone noted in another channel that we seem to be fans of eating things intended for the offspring of other animals. eggs, milk.
12:27:09 <chrisdone> yeah, the main draw to hjscript is the well-typed aspect
12:27:30 * shepheb rolls out for lunch
12:28:11 <luite> I think I'm going with coffeescript first, I really want ot have things running again soon or I'll lose motivation to work on it :)
12:28:51 <luite> and I've spent too much time working on the backend (safely running unsafe haskell code with IO) for that
12:29:29 <chrisdone> luite: i'll be the hjs guinea pig :-)
12:29:46 <luite> hehe good luck
12:30:22 <luite> I'm trying yesod for tis part of the site, which seems ok, but still has lots of rough edges
12:30:26 <monochrom> wait, egg is intended to be offsprings, not food for offsprings!
12:31:22 <monochrom> but yes we tend to eat other species' baby food as well as babies!
12:32:41 <chrisdone> luite: ah, interesting. i haven't tried yesod yet despite doing the homepage for it. thought i'd let others be the guinea pig for that ;)
12:32:48 <luite> hehe
12:32:50 <chrisdone> luite: where's your repo?
12:32:57 <luite> chrisdone: not public yet
12:33:11 <chrisdone> D:
12:33:21 <luite> you can visit my github, but that code is completely rewritten now
12:33:52 <luite> chrisdone: sorry I'll make it public with the public launch of the site
12:34:27 <chrisdone> luite: http://i.imgur.com/5TrKf.gif
12:34:32 <chrisdone> okay, fair enough :p
12:34:40 <luite> though it will be difficult to install
12:34:58 <chrisdone> haskell project difficult to install? gotta be kidding me
12:36:02 <luite> well it requires a separate virtual machine with a special selinux policy, lots of user accounts and --bind mounts
12:36:55 <chrisdone> unsafePerformSetSpecialSeLinuxPolicy
12:37:06 * chrisdone chuckles at unsafePerform*
12:37:09 <chrisdone> so it's not using mueval?
12:37:09 <luite> something like that ;p
12:37:12 <kmc> reallyUnsafePtrEq#
12:37:41 <chrisdone> kmc: reallyUnsafeAlmostCommonLispLikeAnythingGoesComparison#
12:37:41 <luite> chrisdone: nope, but I stopped using mueval a long time ago
12:37:45 <monochrom> reallyUnsafeUserEq#
12:37:51 <chrisdone> monochrom: hahaha
12:37:59 <chrisdone> luite: ah, ok. thought so
12:38:27 <luite> chrisdone: for example with tryhaskell, if someone evaluates an infinite loop that times out, you have to restart the mueval server, right?
12:38:37 <chrisdone> aye
12:39:32 <luite> chrisdone: yeah, now the problem is that I want to load many packages, for example to make graphics with wumpus or diagrams. just loading the packages and linking them takes 2-3 seconds
12:39:46 <chrisdone> yeah, that's a pain
12:40:10 <chrisdone> so how do you avoid it?
12:41:10 <luite> chrisdone: and besides, since I allow arbitrary IO, the user could overwrite process memory, making the interpreter do naughty things. that's why a new interpreter needs to be started for every client. huge overhead if that takes a few seconds
12:42:06 <chrisdone> ah, I see
12:42:26 <chrisdone> can't you pool them?
12:43:04 <chrisdone> e.g. one dies, no problem, i have another one here piping hot
12:43:13 <luite> chrisdone: I start with a single process that runs as root (in a specific selinux security context, so it cannot really do that much), that process loads all installed hackage packages and forces the linker to link them in. then if a new user visits the site, it is given an interpreter, which forks from this main process
12:43:31 <chrisdone> ahhh, forking
12:43:38 <luite> before it actually serves requests, it chroots, changes its uid and switches to a much more limited selinux security context
12:43:51 <luite> the same interpreter is used again for the same client, but it's not shared between clients
12:44:03 <chrisdone> sounds nice
12:44:22 <chrisdone> how fast is the forking?
12:44:54 <luite> around 0.04 seconds with the packages that I have installed on my development server
12:44:55 <chrisdone> it has to copy the stack plus some big heap for the new process?
12:45:37 <chrisdone> (do dynamic libraries get loaded in the stack or heap?)
12:45:41 <luite> the production server is a bit faster (development = dual core e8400, production quad core i7 950), but will also have more packages, so I'll wait and see
12:45:51 <chrisdone> 40ms ain't bad
12:45:56 <chrisdone> ah, ok
12:46:01 <luite> yeah and it's only for the first request
12:46:17 <luite> since as long as the user doesn't do things like infinite loops, the interpreter will be used again
12:46:33 <luite> for that client
12:46:36 <chrisdone> sure
12:46:46 <chrisdone> it's the restart process that's been re-vamped
12:47:55 <luite> it seems to work ok, though there are still a few issues. In testing I got some problem with the number of file descriptors in use... maybe I need to set the ulimit a bit higher
12:49:32 <chrisdone> ah, yeah
12:50:02 <luite> I guess there might also be problems with lazy IO, incompletely consumed files etc
12:50:14 <luite> since users can do that now
12:50:43 <luite> although they can only write to /tmp, and that directory should be cleaned before every request
12:53:08 <chrisdone> i was testing hulk. someone kinda-challenged me that it could handle thousands of connections. i installed ghc7, recompiled, tested with 10,000 simultaneous connections. fine. :-) had to up the ulimit though, ran out of fds with ghc6
12:53:58 <chrisdone> luite: yeah I guess that's not a big problem
12:54:37 <mekeor> LOL---ROFL hahaha :D searching for "recursion" on google.com, google says 'Did you mean: recursion'
12:55:02 <luite> I kill/restart interpreters after 2 minutes anyway, so it any problem should automagically disappear :p
12:55:29 <chrisdone> mekeor: welcome to years ago. have you heard of facebook? :p /snarky
12:55:38 <luite> chrisdone: oh another think that's different from mueval is that I have a different class for responses, not just Show
12:55:53 <merijn> mekeor: Try googling "ascii art" and see what happens to the logo in the top left :)
12:56:07 <luite> chrisdone: for example some drawing library could build something that is an svg with external fonts and png images
12:56:23 <kmc> 'I'm not a real programmer. I throw together things until it works then I move on. The real programmers will say "Yeah it works but you're leaking memory everywhere. Perhaps we should fix that." I’ll just restart Apache every 10 requests.'
12:56:54 <luite> chrisdone: that's possible with my own result type and corresponding type class, but it had some problems with polymorphism
12:56:57 <chrisdone> luite: yeah, that's what i did with raphael a while ago. if you outputted something of the raphael type it would render it out. it's a nice thing
12:57:28 <mekeor> merijn: WOW! great! cool! thanks wow :D :D haha
12:57:36 <merijn> kmc: Rasmus Lerdorf makes me cry :(
12:57:42 <chrisdone> luite: weird, i just found this in my pictures directory. it seems that you've been working on this for about a year :p http://i.imgur.com/FF0YP.png
12:58:59 <luite> chrisdone: haha well, I've done some experiments with raphael a long time ago, but at that time it was still supposed to be something like tryhaskell with better graphics
12:59:31 <chrisdone> luite: haha, sounds like a movie plug
12:59:50 <luite> now it should still have better graphics, but a lot of things changed, like running arbitrary IO code, or even executing external programs
12:59:51 <chrisdone> “TryHaskell II. Like TryHaskell I, but with better graphics!!”
13:00:26 <kmc> TryHaskell ]|[
13:00:28 <chrisdone> when you're finished we could replace the existing tryhaskell if you want
13:00:49 <luite> chrisdone: nah it's not really a tryhaskell replacement, it's probably not as user friendly
13:00:53 <chrisdone> people don't seem to care about adding all numbers in a list, they wanna see launching many threads and stuff like that
13:01:01 <luite> at least, newbie friendly :)
13:01:04 <merijn> chrisdone: Of course!
13:01:36 <merijn> chrisdone: And how to implement singleton pattern and AbstractConceptFactoryFactories :)
13:01:40 <chrisdone> luite: well if you make it a public service i can probably use it somehow and make the friendly part
13:02:04 <chrisdone> merijn: Control.Factories.AbstractConceptFactoryFactories?
13:03:04 <merijn> chrisdone: I guess to make it more haskelly we could do Control.Factories.AbstractMonadFactoryFactory or Control.Factories.AbstractConceptFactoryFactoryMonad
13:03:05 <chrisdone> runAbstractConceptFactoryFactories :: [Factory] -> Enterprise m -> m BusinessSolution
13:03:42 <kmc> chrisdone, you forgot Leverage
13:03:44 <kmc> and Cloud
13:03:52 <luite> chrisdone: does tryhaskell have lots of visitors?
13:03:58 <wli> luite: I need a doublecheck on interchanging the order of summation...
13:04:02 <kmc> type Leverage a b = a -> b
13:04:04 <chrisdone> luite: about 10,000/month
13:04:15 <kmc> 'show' allows you to leverage an Int into a String solution
13:04:48 <monochrom> type Cloud a = [a]
13:04:52 <luite> chrisdone: hmm, I have to admit that I have no idea what kind of server load that would cause
13:05:19 <chrisdone> data Enterprise a = Leverage a | ScaleInTheCloud a Cloud | NoSQLWebScale -- ^ Nullary data constructor, saving data is a bottleneck.
13:05:36 <wli> luite: http://proxima.lp0.eu/~wli/remez.pdf <-- very last eqnarray needs summation order interchange doublecheck
13:06:10 <luite> wli: ah I see you've added a lot of things :)
13:06:39 <luite> oh I run the stuff on an old fashioned dedicated server, so it's terribly un-enterprise
13:06:52 <chrisdone> luite: welll, not a lot. it averages 300 visits a day. probably one person on it at any one time
13:07:02 <luite> oh that should be no prob :)
13:07:47 <luite> haskell web frameworks seem to be very fast at serving useless requests ;p
13:07:54 <chrisdone> but when we roll out TryHaskell II: The Unification, we're sure to double our profits and Market Penetration
13:08:12 <monochrom> what is that?
13:08:14 <chrisdone> yeah, i love those 1K 10k/s benchmarks
13:09:16 <davean> :/
13:09:30 <chrisdone> monochrom: i don't know, it's business-speak. it's not real words, more like jazz sentences
13:10:04 <cheater_> hahaha "jazz sentences"
13:10:44 <chrisdone> :p
13:10:52 <luite> chrisdone: oh by the way, using multiple system threads (-N2, -N3 ... ) and forking seem to be mutually exclusive in the current ghc version
13:11:16 <luite> so TryHaskell II: The Unification couldn't really show off multicore scaling, since I'm forced to run every request with -N1 because of that
13:11:24 <chrisdone> ah, balls
13:11:43 <chrisdone> well, certainly the ease of threading can be exhibited
13:11:46 <cheater_>  use an older version?
13:12:31 <luite> cheater_: I'd need a future version ;p
13:12:48 <luite> some ghc people seem interested in modifying the -N setting at runtime
13:13:03 <cheater_> wat?
13:13:04 <chrisdone> ah, someone's on tryhaskell right now
13:13:05 <cheater_> nice
13:13:08 * chrisdone watches, creepily
13:13:13 <davean> luite: Haskell is very fast at serving useful requests also, just don't do it with the same server :)
13:13:15 <cheater_> how do you watch?
13:13:24 <luite> chrisdone: hehe you follow all their requests?
13:13:32 <luite> chrisdone: I did that when the demo of my site was on reddit :p
13:13:33 <chrisdone> i just look at the access.log, it's all GET requests
13:13:38 <chrisdone> luite: haha xD
13:13:44 <merijn> cheater_: As far as I can tell chrisdone owns tryhaskell so he can just look on the machine :p
13:15:20 <luite> you should have tryhaskell log its requests to irc ;)
13:15:54 <chrisdone> :D
13:18:49 <cheater_> chrisdone, i wanna stalk too :(
13:19:00 <chrisdone> haha
13:19:05 <merijn> Run your own "popular" website :p
13:19:24 <chrisdone> yeah, Get Yer Own Damn Site! ;D
13:20:34 <luite> I bet most people who work at google just do it for looking at the search query logs ;)
13:21:04 <merijn> Ick
13:21:06 <merijn> Probably not
13:21:13 <merijn> Imagine how gross those must be
13:21:26 <davean> looking at logs gets boring quickly IME
13:21:28 <luite> hehe I guess not that many have access to the raw data anyway
13:21:32 <shepheb> there are some screens up in lobbies showing searches as they roll by
13:21:35 <shepheb> they're heavily filtered
13:21:52 <shepheb> rather, they're carefully filtered for NSFW stuff
13:21:56 <luite> no searches for bing, microsoft, apple, allowed? ;p
13:22:04 <shepheb> pretty much anything else goes, and it's amusing what sometimes happens
13:22:14 <shepheb> there's a surprising number of "URL queries"
13:22:21 <shepheb> people Googling facebook.com, amazon.com and so on
13:22:25 <chrisdone> ah yeah i saw that in the zurich office
13:22:46 <shepheb> Google just shrugs and I'm Feeling Lucky-s them to the site
13:22:52 <luite> shepheb: yeah I've tried to explain to my parents the difference between the url bar and search bar, without success. in the end I just installed chrome
13:23:01 <merijn> On completely unrelated note...is there a de facto standard in the type theory community on which LaTeX style to use for layout?
13:23:14 <c_wraith> Use whatever the simons use.
13:23:14 <shepheb> luite: yeah, basically.
13:23:15 <chrisdone> doesn't it depend on institution?
13:23:23 <c_wraith> holy crap, don't use stuff that prettifies haskell code
13:23:32 <c_wraith> make it look like ascii haskell code.
13:23:39 <c_wraith> 100x more readable that way
13:23:44 <chrisdone> yes, please just write normal haskell code like Oleg Blessed Be His Name does
13:24:16 <c_wraith> I wouldn't call Oleg's code *normal*. :)
13:24:26 <c_wraith> Hence why I pointed at the simons' papers, instead :)
13:24:47 <merijn> c_wraith: You wouldn't happen to know which style that is, right? :p
13:24:53 <c_wraith> merijn: not at all!
13:25:32 <merijn> I'm not including code in the paper anyway. The default LaTeX style gives me to little space per page for the amount I need to write :>
13:25:46 <c_wraith> haha
13:25:55 <c_wraith> length limits are *so* physical media
13:26:10 <c_wraith> now, attention-span limits.  Those are different.
13:26:50 <merijn> c_wraith: There's no hard limit, but for masters' literature studies here you should aim for around 10-20 pages. Only I have about a few hundred pages worth of material :p
13:27:08 <c_wraith> time to find an editor!
13:27:34 <merijn> So with the default single column 80 character layout I won't end anywhere close to an acceptable page number :p
13:28:46 <c_wraith> oh.
13:28:55 <c_wraith> yeah, go to a journal format
13:28:59 <c_wraith> two-column, much smaller font
13:36:24 <chrisdone> no one tries anything interesting, just basic expressions http://i.imgur.com/sxgpw.jpg
13:37:30 <mekeor> how is tree-like recursion called? i mean sth like `fac n = fac (n-1) + fac (n-2)' or so..
13:37:49 <mekeor> do you simply say tree-recursion?
13:37:58 <ion> JPEG for a screenshot? Heresy!
13:38:17 <chrisdone> it's PNG but imgur took the liberty of converting it for me
13:38:57 <ion> I have successfully uploaded a number of PNGs to imgur without format conversion.
13:38:59 <merijn> mekeor: exponential?
13:39:33 <c_wraith> mekeor: are you looking for "structural recursion"?
13:39:35 <mekeor> merijn: hmm.. that rather describes the runtime, doesnt it?
13:39:45 <chrisdone> ion: me too, I made this one not half an hour ago from this very web site: http://i.imgur.com/FF0YP.png
13:39:49 <mekeor> merijn: no, i'm just lookign for the expression
13:39:59 <chrisdone> opqdonut: it seems random. sometimes it converts, sometimes it leaves the bloody thing alone
13:40:01 <mekeor> i mean, there's tail-recusion, e.g.
13:40:13 <merijn> mekeor: Tail recursion means something else entirely
13:40:20 <mekeor> merijn: i know.
13:40:46 <merijn> mekeor: I do not see any relation between what tail recursion is called and the exponential behaviour of that factorial function
13:40:55 <mekeor> merijn: i look for a word, for an expression for such a recursion (like the fib-code above..)..
13:41:11 <dylukes> it's structural recursion.
13:41:24 <mekeor> btw, i meant fib before, not fac x]
13:41:25 <dylukes> you're using a structurally "smaller" part of the argument… n-1 being smaller than n.
13:41:28 <dylukes> oh
13:41:37 <dylukes> where'd you say fib?
13:41:51 <mekeor> "how is tree-like recursion called? i mean sth like `fac n = fac (n-1) + fac (n-2)' or so.."
13:42:02 <mekeor> s/fac/fib/ .
13:42:23 <dylukes> oh, tree-like as in splitting.
13:42:57 <mekeor> Yep.
13:43:08 <merijn> mekeor: SICP uses linear and tree recursion
13:43:22 <monochrom> just call it "recursion"
13:43:28 <dylukes> that's an example of structural (as opposed to generative) recursion nonetheless.
13:43:35 <dylukes> I don't see the value in saying "its tree-like or not"
13:43:44 <dylukes> I mean, a straight list is still a unary tree.
13:43:45 <mekeor> i found http://mitpress.mit.edu/sicp/chapter1/node13.html -- there, the author calls such recursions "tree recursion"s
13:43:55 <dylukes> So, "tree-like" is a bit… I'm not sure what the point of the term is.
13:43:55 <merijn> mekeor: Yeah, I just said that ;)
13:44:02 <mekeor> OK :)
13:44:04 <merijn> dylukes: Well, I think he wants a name for the operational semantics
13:44:14 <dylukes> "tree recursion" sounds fine to me…
13:44:21 <dylukes> it's a recursion producing a tree-shape.
13:44:53 <mekeor> thanks. all right.
13:45:42 <merijn> dylukes: In SICP the distinction made is linear recursion which can be easily rewritten to a form which is tail recursive and thus has linear execution space. Whereas something like the fib definition cannot (easily) be rewritten to be tail recursive and thus consumes exponential space
13:45:59 <dylukes> Ah I see :)
13:46:08 <merijn> Eh
13:46:11 <c_wraith> actually, it consumes linear space
13:46:14 <c_wraith> exponential time
13:46:15 <merijn> linear execution space =constant
13:46:37 <merijn> Of course tail recursion doesn't consume linear space, that is silly >.>
13:46:49 <dylukes> tail recursion is constant space :P.
13:46:58 <dylukes> if it was linear I'd be concerned.
13:47:00 <c_wraith> I was talking about the naive fib definition
13:47:01 <mekeor> i agree.
13:47:05 <c_wraith> that's linear stack space
13:47:14 <c_wraith> well.  linear in n
13:47:19 <c_wraith> exponential time in n
13:47:37 <merijn> c_wraith: Why is it linear in stackspace if you make exponential function calls?
13:47:50 <c_wraith> merijn: because they're not all on the stack at once
13:48:16 <monochrom> lots of exponentia algorithms are pspace
13:48:17 <c_wraith> You're basically doing a depth-first traversal of the call tree.
13:48:18 <merijn> oh, true
13:48:30 <c_wraith> you only need enough memory for any one root -> leaf path at once.
13:54:18 <merijn> Academics of #haskell, how do you cite web pages? misc entry with the howpublished field set to the URL?
13:59:02 <acowley> merijn: I sometimes put URLs in footnotes rather than the bibliography
14:08:03 <ski> mekeor : i've also seen "binary recursion"
14:10:59 <DukeDave> Hey gang, is there any case in which (I'm suspecting GHC extensions) in which this could be valid:
14:11:00 <DukeDave> > map (\(x,5) -> x) [('a',4), ('b', 5)]
14:11:00 <lambdabot>   "*Exception: <interactive>:3:5-15: Non-exhaustive patterns in lambda
14:12:32 <merijn> DukeDave: That would crash on the first element of the list
14:12:37 <DukeDave> Oh wait, no, disregard that, I thought I'd spotted a case similar but it was just a copy paste fail
14:12:47 <DukeDave> merijn: Makes sense, thanks :)
14:12:58 <ski> > [x | (x,5) <- [('a',4), ('b', 5)]]
14:12:59 <lambdabot>   "b"
14:13:11 <DukeDave> I was wondering if there was something clever where it would return mzero
14:13:18 <DukeDave> Ala ski's example
14:13:40 <mekeor> ski: thx
14:16:32 <Watermind> are pure category theory questions welcome here?  I'm always going a bit off-topic these days but can't find a more appropriate channel :S
14:16:43 <Watermind> #math doesn't seem big on category theory
14:16:53 <clsmith> maths is a big place...
14:16:58 <merijn> Watermind: I go off-topic with type theory questions here all the time as well :p
14:17:09 <merijn> So far no one's yelled at me :p
14:17:22 <Watermind> ok so let me try, just tell  me to shut up if you want :p
14:17:59 <Saizan> Watermind: there's also the fairly low traffic ##categorytheory
14:19:01 <Watermind> what I was wondering about is,  if you have a cartesian closed category,  does if follow that you also have a morphism  <,> : (C->A) x (C->B) -> (C-> AxB)  ?
14:19:22 <Watermind> Saizan:oh I thought I had tried that... why the two ## ?
14:21:01 <Saizan> Watermind: single # channels are for the official ones of some project or organization
14:21:24 <acowley> Watermind: I think so
14:22:08 <Watermind> Saizan: ah I see
14:22:47 <Watermind> acowley: I think so too, and I would also expect to have the same for sums of morphisms in cartesian categories with sums... but couldn't find how to construct it
14:23:00 <Tomsik> I remember having problem deriving that
14:23:10 <Tomsik> It was pretty easy when you had that all xC
14:23:19 <Tomsik> that you could use uncurry morphism
14:23:34 <Tomsik> (err, maybe not pretty easy, but still possible)
14:24:06 <acowley> Hm, where do you encounter problems with sums?
14:24:25 <Tomsik> Remember that sum is a co-product
14:24:32 <Tomsik> and you might reverse arrows in some places
14:27:34 <stevebansham> hello - haskell beginner here - haskell doesn't seem to use many of what i'd call interfaces (as in java). I know about typeclasses but they don't seem to be as prolific as in other languages. so, for example, if i wanted to write a function that sorted any linear data structure, how could i do that? i can do it with a list, or with another specific type, but what if i just want to be able to use my new sort function on any line
14:27:34 <stevebansham> structure?
14:28:27 <acowley> We don't have a great story for collection type interfaces
14:28:32 <acowley> There are things like ListLike
14:28:32 <merijn> stevebansham: You'd have to implement a "Sortable" typeclass and then provide instances of that typeclass for each thing you want to sort
14:28:53 <acowley> Foldable and Traversable have quite widespread support at this point
14:28:57 <monadic> merijn: You can implement sort in terms of fold I think
14:29:27 <stevebansham> monadic: yeah sort is just an example - i mean any operation i might want to do just depends on a linear sequence
14:29:30 <merijn> monadic: Possibly, in which case foldable is enough. But I think he wanted an answer for the more general case of these types of problems
14:29:35 <acowley> If your type is a foldable monoid you could probably go to list, sort, then, build it back up
14:29:41 <monochrom> there is an MArray type class. you can write one sorter for it. then it works for IOUArray and STUArray and so on
14:30:07 <monadic> stevebansham: Well usually Functor and Foldable and Traversable can work. Things that fully encapsulate a collection are too large
14:30:21 <monadic> monochrom: But not Vector/MVector
14:30:24 <acowley> (list doesn't *have* to be the intermediate, just whatever you want to do your sorting with)
14:30:27 <monadic> monochrom: So that approach doesn't work that well
14:30:55 <monochrom> clearly, nothing stops you from generalizing it
14:30:57 <merijn> stevebansham: So it boils down to two things: 1) If an an appropriate typeclass does not exist you will have to create your own in these scenario's 2) Fortunately it is possible to provide new typeclasses for existing data types without modifying their original source
14:31:03 <monadic> Also note that typeclasses aren't analogous to interfaces, that would be the existentially qualified type
14:31:09 <monochrom> but nothing forces me to use generalizations either
14:31:26 <acowley> I've not seen a reason why do you need a new typeclass for this?
14:32:02 <stevebansham> sounds like an instance of the 'expression problem'
14:32:32 <merijn> acowley: He said he wanted a way to write a general sort function for any data type which is a linear sequence (or presumably a way to write a general foo function for any data type which has condition bar) which I don't think is possible without just writing a typeclass
14:33:11 <monadic> or template haskell to generate the typeclass instancex
14:33:23 <monadic> or template haskell to generate the functions themselves.
14:33:24 <monochrom> sorting is a moot example. we don't first store things linearly and then sort separately. we store things in a binary search tree to begin with
14:33:56 <dylukes> We use good data structures :). Cheap persistence.
14:34:05 <merijn> stevebansham: Kinda, I think. But like I said the advantage of typeclasses is that you can add them to a data type without modifying the original implementation (which is generally not possible in languages where interfaces are inherited)
14:34:23 <monadic> Lists are pretty persistant, in that you can append to the start with O(1) memory cost
14:34:32 <stevebansham> ok, thanks - an unrelated question: are the ghc haskell library sources in the ghc source distribution? i can't seem to find them. are they in a different repository or are they burried somewhere that i can find them?
14:34:39 <monadic> And with fusion it probably gets buried away anyway
14:35:00 <monadic> stevebansham: You have to look that up, theres some script in the git repository that clones everything for you. Consult docs
14:35:05 <monochrom> so what you should go for is why we don't have one unified interface for Hinze's binary search tree and Bird's binary search tree and Okasaki's binary search tree and Wadler's binary search tree...
14:35:15 <dylukes> stevebansham: Use Haskell Platform.
14:35:29 <monadic> dylukes: What if hes trying to edit ghc?
14:35:31 <dylukes> monochrom: Speaking of which I should finish reading Okasaki.
14:35:32 <merijn> dylukes: That isn't his question, I assume he just wants to browse the code
14:35:37 <stevebansham> i mean for reading the source, not installing it
14:35:40 <dylukes> oh.
14:35:55 <monadic> It takes a while to clone
14:36:04 <monochrom> and the answer is if we had that many binary search trees, they would use same operation names, so you would just change one single "import" line to switch, "interface" is overkill
14:36:07 <merijn> You can query lambdabot for (some code), but not sure where the source can be found online
14:36:09 <merijn> @src map
14:36:10 <lambdabot> map _ []     = []
14:36:10 <lambdabot> map f (x:xs) = f x : map f xs
14:36:59 <luite> lambdabot code is often not the actual implementation
14:37:08 <stevebansham> was hoping to check out a version controlled copy - i've got the ghc sources but i can't see any of the libraries
14:37:44 <merijn> stevebansham: Here http://hackage.haskell.org/package/base-4.2.0.1
14:38:01 <stevebansham> that's exactly what i was after
14:38:02 <stevebansham> thanks
14:40:05 <acowley> here
14:40:17 <acowley> mySort :: (F.Foldable t, Monoid (t a), Ord a, Applicative t) => t a -> t a
14:40:17 <acowley> mySort = F.foldr (mappend . pure) mempty . sort . F.foldr (:) []
14:40:17 <acowley>  
14:40:35 <merijn> stevebansham: Unrelated but useful enough to mention, Hoogle  (http://haskell.org/hoogle/) lets you search Haskell API's by type signature (and the documentation usually links to source as well)
14:40:36 <acowley> something like that is a sort on a lot of different things
14:48:36 <sully> @pl interact (\eat -> "s = " ++ show (s ++ eat) ++ s ++ eat)
14:48:36 <lambdabot> interact (("s = " ++) . ap ((++) . show . (s ++)) (s ++))
14:54:58 <maurer_> (zip`ap`tail) [0..]
14:55:06 <maurer_> > (zip`ap`tail) [0..]
14:55:07 <lambdabot>   [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,1...
14:58:00 <chrisdone> shepheb: I just noticed a bug; in my notification list there's an encoding problem: "Bryan O&839;Sullivan … and 8 others added you on Google+."
14:58:22 <EvanR> so.... haskell platform for windows put a copy of msys in program files, and msys itself installs directly to c:\
14:58:23 <chrisdone> guess you were already aware of that
14:58:32 <EvanR> why are you no combined >_<
14:59:04 <shepheb> chrisdone: I wasn't personally, but I suspect the team was. /me adds bos to circles so I can point the team at that one.
14:59:32 <shepheb> weird, it's encoded properly in the search box autocomplete and profile page.
14:59:36 <chrisdone> yeah
14:59:52 <shepheb> chrisdone: thanks for the heads up
14:59:58 <chrisdone> np :-)
15:01:32 <bos> shepheb: i filed that myself a little bit ago
15:02:42 <shepheb> bos: yeah, I'm testing other apps. it searches fine on mobile web (my part of the project) and displays fine everywhere I've seen except for the notifications pane on desktop
15:02:52 <shepheb> bos: add me to circles so I can see it in my notifications?
15:03:05 <shepheb> Braden Shepherdson, just added you
15:03:45 <chrisdone> oh. it appears to have corrected itself
15:04:01 <chrisdone> ah, no, it's just gone from the top
15:04:14 * chrisdone goes back to coding
15:04:24 <rpglover64> Is there a way to tell Happy (for debugging purposes) to reduce rather than shift on shift/reduce conflicts?
15:05:41 <bos> shepheb: you're encircled!
15:07:20 <merijn> In which situations is a shift/reduce parser preferable to parser combinators like parsec? Or is it just a matter of personal taste?
15:07:55 <rpglover64> I think performance is the biggest advantage
15:07:56 <shepheb> okay, seems to display correctly everywhere except desktop notifications. thanks for the heads up and help testing, chrisdone and bos. I'll make sure that one is filed with the notification guys.
15:08:13 <Tomsik> Just wondering
15:08:14 <bos> cheers!
15:08:16 <chrisdone> teamwork!
15:08:17 <rpglover64> I don't have a choice in the matter anyway.
15:08:23 <merijn> I though parser combinators are only less efficient in some (fairly uncommon) corner cases?
15:08:25 <Tomsik> What is time complexity of sort from Data.List?
15:09:13 <rpglover64> Tomsik: I'd guess O(n log(n)) expected
15:10:08 <rpglover64> merijn: sounds reasonable, but I don't know
15:10:42 <acowley> I think it's nlogn worst case
15:11:09 <Tomsik> @src sort
15:11:10 <lambdabot> sort = sortBy compare
15:11:13 <Tomsik> @src sortBy
15:11:14 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
15:11:17 <rpglover64> acowley: Is it based on mergesort or quicksort?
15:11:22 <Tomsik> That doesn't sound like nlogn
15:11:27 <rpglover64> that's n^2
15:11:32 <Tomsik> Exactly
15:11:33 <acowley> that's not right
15:11:35 <acowley> look at the source
15:11:39 <acowley> it's #ifdef'ed
15:11:48 <Tomsik> And is it nlogn?
15:12:15 * shepheb finds the bug. fixed on daily \o/
15:13:32 <acowley> Well the comments are somewhat confusing. By my reading, in 2002 there was a guaranteed O(nlog(n)) version which was replaced in 2009 by something 2x faster according to benchmarks.
15:16:12 <chrisdone> shepheb: http://musicality.files.wordpress.com/2009/03/go-team-venture.jpg
15:17:42 <shepheb> ahaha I love that show
15:18:10 <shepheb> "It's POWERED BY A FORSAKEN CHILD!?" "I didn't use the whole thing!"
15:18:42 <shepheb> I should perhaps clarify that I didn't find and fix the bug in 90 seconds. someone else fixed it yesterday :P
15:24:52 <chrisdone> shepheb: hahaha. “a what?” “AN… orphanmumble”
15:27:42 <dpratt71> good news, fellow believers, after years of working on him, I believe I have converted a fellow programmer to Haskell
15:28:12 <dpratt71> well...he installed the platform, anyway; this is progress
15:29:12 <chrisdone> dpratt71: guy sounds like a cruise ship
15:29:28 <dpratt71> chrisdone: :)
15:30:23 <dpratt71> he's Canadian, actually
15:31:28 <chrisdone> ah, it all makes sense
15:33:23 <dpratt71> in unrelated news, a man realizes he's been experimenting with Haskell for years now and still considers himself a Haskell newb
15:34:57 <merijn> dpratt71: That's not news :p
15:35:12 <dpratt71> merijn: :)
15:36:12 <merijn> Half the time people come here saying "I'm just a haskell newbie, but I can't get this to work" -> *click link* -> "dear lord, what the hell is this ridiculous abstractness, I have no clue what's happening...."
15:36:40 <dpratt71> somebody should come up with some color/belt rankings for Haskell
15:36:50 <clsmith> lol. that would be very useful indeed
15:37:07 <merijn> I believe Racket actually has difficulty levels for their language :p
15:37:33 <chrisdone> think there used to be belt rankings on the wiki but they got lost in dust and lambdas
15:37:54 <arw__> feeling like a newb in haskell is comparable to feeling small as a 220cm guy in front of godzilla
15:38:06 <dpratt71> chrisdone: seriously? that's too funny
15:39:09 <bos> nice, my new haskell http load tester seems to be able to generate more load than apachebench already.
15:39:38 <kmc> arw__, the great thing is that you never stop feeling like a noob
15:39:51 <kmc> i've been haskelling for 5+ years and i still learn new things here every day
15:40:00 <chrisdone> bos: thanks to the wonders of libev on ghc7?
15:40:29 <bos> chrisdone: we don't use libev in ghc.
15:40:55 <bos> chrisdone: so ... hard to tell exactly why just yet. but i'm still happy!
15:40:57 <chrisdone> ah, I thought the IO manager used that
15:41:01 <chrisdone> heh, yeah
15:43:05 <chrisdone> ahh, it's epoll, kqueue, etc.
15:43:52 <shachaf> Does GHC ever use asynchronous I/O, or always a thread pool?
15:44:13 <shachaf> Er, on files, I mean.
15:44:22 <chrisdone> i guess this notion of libev use is pervaded because libev uses those things as backends
15:44:25 <bos> shachaf: file I/O is synchronous.
15:44:51 <shachaf> chrisdone: Lots of things use those things as backends. :-)
15:45:11 <chrisdone> shachaf: mhm?
15:47:24 <bos> hmm, we get better throughput than both httperf and apachebench now. nice!
15:48:29 <chrisdone> bos: with no special shenanigans in the haskell source? pretty sweet
15:49:00 <bos> chrisdone: yeah, using all standard libraries
15:49:55 <c_wraith> bos: in what tool?
15:50:28 <c_wraith> oh, looks like it's not public yet
15:50:37 <bos> c_wraith: http://github.com/mailrank/http-load-tester
15:50:50 <bos> c_wraith: it's public, it's just not released
15:50:55 <c_wraith> ah, cool
15:51:00 <c_wraith> we might end up using this.
15:51:07 <bos> c_wraith: you should.
15:51:20 <bos> it uses criterion's statistical analysis to give solid statistics.
15:51:55 <bos> also, i want to split it into a library and an executable, so that you can write custom load tests.
15:52:43 <c_wraith> We're currently using jmeter, for reasons of...  I don't know.
15:52:51 <c_wraith> Though it draws pretty pictures.
15:52:53 <monadic> bos: Hmm? I just got got into the channel and now I'm interested (on a sidenote... Are there any #haskell logs for stuff like this)
15:53:20 <bos> c_wraith: i want to use the chart package to produce good charts
15:53:24 <chrisdone> monadic: http://tunes.org/~nef/logs/haskell/
15:53:25 <bos> jmeter is a piece of crap.
15:53:40 <chrisdone> oh that would be cool
15:53:46 <c_wraith> Yeah, I've had nothing to do with the choice to use jmeter, nor actually using it. :)
16:06:23 <chrisdone> 1AM ♪ should go to bed but I can't resist writing mah haskell code ♫
16:07:20 <mwc> I'd +1 that.
16:07:29 <hpc> heh
16:07:51 <mwc> Trying to set up a spark for Haskell sucks
16:08:07 <kmc> spark?
16:08:18 <monadic> mwc: See Data.Parallel.par
16:08:24 <mwc> can't get a decent feed going, it's all "Haskell County this" and "Somebody-not-Curry Haskell tahat"
16:08:25 <hpc> on google+
16:08:45 <Cale> Need -1
16:08:55 <mwc> kmc monadic: sparks are like google+ news feeds
16:09:31 <mwc> Cale: true, if enough haskell people -1'd the crap on the Haskell spark we could probably take it over
16:09:38 <monadic> Haskell language gave me "Changeset 58cc5ed228adce6529eb1e0a849e5d9ca6175524 – GHC"
16:09:49 <hpc> heh
16:10:00 <kmc> i don't remember, when facebook first came out, did people not shut up about it
16:10:38 <hpc> whoa, i started typing "functional programming" with the wrong keyboard layout
16:10:42 <hpc> try searching for "f∪∩⊂∴iΩ∩ℵλ Ωgℵi∩g"
16:10:46 <hpc> you actually get results
16:10:52 <monadic> Is it possible to get planet haskell added to the sparks somehow?
16:11:01 <ts00000> what keyboard layout was that :p
16:11:02 <monadic> and then we could all +1 all the blog posts and take it over
16:11:13 <kmc> guys i'm willing to pay mad bitcoins for a google+ invite
16:11:24 <hpc> ts00000: one i set up for myself
16:11:31 <mwc> kmc: pm me your gmail
16:11:36 <kmc> (not really)
16:11:44 <mwc> ah, well, I'd have given you one for free
16:11:56 <kmc> i already have several unused invites
16:12:18 * shachaf has several used invites.
16:12:23 <shachaf> One account isn't enough for me.
16:12:29 <monadic> Hmm. Searched for "Functional programming" and learned that clojure is good for programs that require correctness
16:12:47 <monadic> Why are 4 of the 5 results about clojure ;(
16:12:47 <kmc> "require correctness" is a fun tautology
16:13:21 <mwc> projects that don't require correctness are very convenient
16:13:40 <kmc> they are maximally convenient
16:13:44 <kmc> in that they are all already finished
16:14:02 <acowley> projects that apparently don't require correctness are the most common kind!
16:14:14 <mwc> main = putStrLn "Guess you shouldn't have paid up front."
16:14:16 <acowley> are there any Haskell-centric lists or whathaveyou on Google+?
16:14:18 <kmc> so these projects have no requirements at all?
16:14:27 <acowley> kmc: it works on my machine!
16:14:30 <kmc> 'cause i'd say whatever it is that you require, that is the meaning of "correctness"
16:14:37 <kmc> even working on your machine ;P
16:14:59 <acowley> I think it's actually a pretty interesting point
16:15:38 <acowley> it gets at the expressiveness of types and related issues
16:15:44 <acowley> at some point we just don't care to be more specific
16:15:50 <acowley> that doesn't mean we *couldn't* be more specific
16:16:53 <mwc> Well, presumably if you have a definition of correctness that implies that you have a mapping from input states to a subset of "correct" output states where correct and the mapping is determined by the problem you're trying to solve
16:17:09 <mwc> you need the subset thing in order to handle nondeterminism, e.g., monte carlo simulations
16:17:29 <kmc> i'm just taking "correct" to mean "meets the requirements, whatever those are"
16:17:40 <kmc> requirements could be input-output pairs or they could be more vague things
16:17:46 <acowley> kmc: there will always be unstated assumptions
16:17:53 <mwc> I think I should ask for the next person who asks me to "write a program" to provide a problem description in that form
16:18:23 <kmc> write a prgram to make me rich, kthx
16:18:34 <kmc> it should be like that movie "the social network"
16:19:00 <Tomsik> Is there a way to do a prolog-like trace in ghci?
16:19:13 <Tomsik> I just want to know on that arguments a recursive function is called
16:19:22 <acowley> we (programmers) use terms like "fault tolerant" but we don't often enumerate the types of faults we can tolerate, and we very seldom emphasize the range of faults we don't tolerate
16:19:33 <acowley> Tomsik: breakpoint then step
16:19:49 <acowley> Tomsik: type :? into GHCi to see available commands
16:20:02 <acowley> I think you want something like ":b myFun" to add a breakpoint
16:20:05 <Tomsik> I've never used an interactive debugger (except prolog) before, halp?
16:20:52 <kmc> Tomsik, Debug.Trace ?
16:21:15 <kmc> acowley, i think it's really important to enumerate the cases you don't care to handle, actually
16:21:22 <kmc> that's where your simplifying assumptions come from
16:21:27 <acowley> Tomsik: After adding the breakpoint, you can issue :step to step
16:21:37 <hpc> ive never seriously used a debugger in any language
16:21:42 <hpc> including C++ and java
16:21:49 <acowley> kmc: well I said "enumerate" to be deliberately unhelpful
16:21:58 <hpc> Debug.Trace would be good to try first
16:22:00 <acowley> kmc: because there are lots of "outside-the-system" faults
16:22:04 <kmc> like in security your train of thought often ends with "... but if they could do that they could own the box three hundred other ways, so whatever"
16:22:16 <acowley> kmc: I think whitelists are better
16:22:31 <acowley> I can't enumerate all the things you might do that cause the program to fail
16:22:55 <acowley> and I've already got my hands full with the ground assumptions ("Assuming the computer is plugged in...")
16:23:25 <Eduard_Munteanu> Doesn't all this stuff boil down to "how do I know what I want?"?
16:23:46 <Eduard_Munteanu> (or equivalently, "what do I want?".)
16:23:53 <clsmith> acowley: i agree, though it's sometimes helpful to work out what faults one might expect the system to tolerate, but which it does not
16:24:25 <acowley> Eduard_Munteanu: right, but you don't want to spend forever writing that specification
16:25:11 <Eduard_Munteanu> http://lambda-the-ultimate.org/node/3858
16:25:18 <acowley> Eduard_Munteanu: the faults where everyone stands there pointing at each other are the worst
16:25:22 <Eduard_Munteanu> Pretty grim perspective.
16:25:51 <acowley> I think it's fair though
16:26:29 <Tomsik> That :step stuff is pretty illegible, showTrace works just like what I'm used to, but I feel dirty
16:27:00 <c_wraith> Trace is great for debugging.  That's what it's there for.
16:27:27 <c_wraith> Please do not use it as your intended IO mechanism. :)
16:27:34 <clsmith> hmm, one Char == one unicode codepoint? does it support every unicode plane?
16:28:01 <c_wraith> I can never remember the terminology
16:28:11 <c_wraith> do codepoints include surrogates?
16:28:15 <hpc> > length ([minBound .. maxBound] :: String)
16:28:16 <lambdabot>   1114112
16:28:29 <hpc> how does that compare to the number of unicode codepoints?
16:28:48 <c_wraith> probably significantly higher.
16:28:55 <c_wraith> There are big undefined regions in unicode
16:29:16 <clsmith> no, that's the exact number of codepoints
16:29:23 <clsmith> some are undefined, yes, but they're still codepoints...
16:29:30 <acowley> Eduard_Munteanu: I think one of the most interesting aspects of that perspective is how types are sometimes held up as great aids in refactoring thanks to the aspect of "lots of simple tests" while proofs are described as too rigid to allow for easy refactoring
16:29:44 <ash__> is there a PEP 8 for haskell? a definitive style guide that the community follows?
16:29:56 <acowley> ash__: no
16:29:57 <hpc> UTF-8 encodes each of the 1,112,064[7] code points in the Unicode character set ... - Wikipedia
16:30:06 <hpc> > 1112064 - 1114112
16:30:07 <lambdabot>   -2048
16:30:22 <Cale> http://urchin.earth.li/~ian/style/haskell.html -- this has some pretty uncontroversial stuff in it
16:30:28 <hpc> so haskell seems to have 2048 MORE characters than UTF-8 specifies?
16:30:53 <clsmith> hpc: that suggests haskell includes the surrogates c_wraith mentioned
16:31:04 <Eduard_Munteanu> acowley: yeah, I hear it's quite usual for formally-verified software to need extensive changes in proof just to accomodate a small change in functionality.
16:31:05 <clsmith> (of which there are 2048)
16:31:08 <acowley> hpc: my hope is that they're all different whitespace chars to encompass function application, applicative <*>, monad `ap`, etc.
16:31:20 <hpc> acowley: lol
16:31:34 <ash__> Cale: what if your function signature is more than 79 chars wide?
16:31:39 <acowley> Eduard_Munteanu: it seems to suggest something about specificity doesn't it?
16:31:50 <hpc> ash__: you can split signatures on several lines
16:31:52 <Cale> ash__: You can break lines anywhere
16:32:04 <hpc> or let it spill over if it's really so necessary
16:32:05 <ash__> ya, but should I put 1 arg per line? or... i duno, group them suomehow
16:32:07 <c_wraith> clsmith: in any case, Char is big enough for everything you typically want to handle.
16:32:08 <acowley> proofs are often more specific than intended by whomever dreamed up the initial "specification"
16:32:19 <Eduard_Munteanu> acowley: yeah, I guess software-related proofs aren't really reusable
16:32:24 <Cale> ash__: Sometimes that's nice, particularly because you can comment on each parameter then
16:32:27 <clsmith> c_wraith: yeah, i was just wondering because some unicode implementations seem to stop at the BMP
16:32:32 <c_wraith> clsmith: of course, it fails with non-unicode character sets, like Big5 or shift-jis
16:32:42 <acowley> Eduard_Munteanu: they should be, though
16:32:44 <Eduard_Munteanu> Or maybe we don't know how, yet.
16:32:58 <Cale> (and haddock might require that style, if you want to comment the parameters for the haddock)
16:33:00 <clsmith> c_wraith: unicode is the one encoding to rule them all <.<
16:33:03 <acowley> I should change a type, and have the checker show me where my code needs changing and my proofs broke
16:33:19 <Cale> ash__: I'll typically line up each -> with the ::
16:33:22 <acowley> and one hopes the changes are intuitive based on the change to the type
16:33:34 <c_wraith> clsmith: except there are things in those two character sets which unicode simply chooses not to represent in any way.  They're *rare* things, but they exist.
16:33:37 <Cale> (if I'm doing that)
16:34:07 <clsmith> c_wraith: really? that seems surprising -- they were perfectly happy to represent snowmen
16:34:11 <Eduard_Munteanu> Yeah, though it doesn't help if a type change results in massive breakage all around.
16:34:24 <c_wraith> clsmith: yeah, it's part of why unicode hasn't *really* caught on in asia.
16:34:28 <Eduard_Munteanu> Presumably we need a method to abstract those things.
16:34:38 <ash__> Cale: got ya, are there any style guides out there for haskell? For instances, does the ghc have a specific style guide or do they just say "be reasonable
16:34:39 <ash__> "
16:34:46 <clsmith> c_wraith: that sounds ridiculous :/ sigh
16:35:04 <Cale> I'm not even sure that GHC is written with one style.
16:35:05 <acowley> One would hope that proofs' conformance to a data structure are no more rigid than any other code
16:35:23 <ash__> alright, just curious
16:35:33 <Cale> Basically, be reasonable, people like camelCase, and never ever use tab characters.
16:35:44 <Eduard_Munteanu> acowley: it may be the case it's just as rigid, only more verbose
16:35:53 <ash__> i think the only time I use tabs are in Makefiles...
16:36:05 <hpc> tabs in GHC are defined as an unconfigurable 8 spaces
16:36:10 <Cale> There's the golden rule of indentation: if something is a part of something else, and starts on a different line, it should start in a deeper column
16:36:23 <c_wraith> clsmith: part of the problem is that in chinese in particular, there's no fixed list of characters.  People can (and do) create arbitrary new ones, still.  Mostly for names.
16:36:30 <Cale> If you follow that, it means that you indent if/then/else like this:
16:36:31 <Cale> if foo
16:36:33 <Cale>    then bar
16:36:35 <Cale>    else quux
16:36:45 <Cale> Or this:
16:36:49 <Cale> if foo then bar
16:36:52 <Cale>        else quux
16:36:53 <Eduard_Munteanu> Anyway, I think he makes a good point that verifying software results in better code mostly because you get to understand the issue better, rather than  as a result of proving stuff.
16:37:02 <Cale> (things which are siblings should also line up)
16:37:04 <acowley> absolutely
16:37:14 <clsmith> c_wraith: so how do the other encodings get around that? they just add a whole bunch of characters?
16:37:22 <c_wraith> clsmith: yep.
16:37:31 <acowley> but I hope we're just in a period where updating proofs is needlessly aggravating
16:37:40 <clsmith> hrm :/ there ought to be a better way
16:37:40 <kmc> c_wraith, the gov't is trying to crack down on that because it's a bureaucratic nightmare
16:38:16 <Eduard_Munteanu> acowley: but that's pretty grim to me, it's like paying 3 different teams to write different implementations of the same thing, then comparing their results. Surely, most of the time they'll make different mistakes and you could draw upon that.
16:38:40 <c_wraith> kmc: I sympathize with the government there.  And I rarely sympathize with the chinese government. :)
16:40:14 <Eduard_Munteanu> (Besides, it doesn't really address getting the requirements right.)
16:40:43 <acowley> I think it's crucially related
16:41:17 * ski typically divides source code into pages with form feed
16:41:20 <acowley> there is a lot of reasonable code that is a pain to prove in Coq or Agda due to totality, for example
16:41:25 <monochrom> both the japanese government and the chinese government publish standards on characters. they have national standard organizations just like the US has ANSI
16:42:22 <pikhq> Japan has it a bit easier, because the list of characters you can use in names is fixed.
16:42:40 <pikhq> So you don't get the severe number of idiosyncratic characters for names.
16:42:57 <pikhq> Probably helps that they have a phonetic script in common use as well, though.
16:43:15 <c_wraith> they have *two* phonetic scripts.  Just for fun. :)
16:43:24 <pikhq> c_wraith: Well aware. :)
16:43:36 <Cale> Well, hey, we have cursive and printing :P
16:43:38 <pikhq> Arguably, three, actually.
16:44:00 <Cale> The difference is that they ascribe some semantic content to it
16:44:10 <c_wraith> that's a pretty significant difference
16:44:16 <pikhq> (Roman alphabet. Though it's really not *commonly* used for things.)
16:44:23 <Cale> But it's not terribly strict
16:44:38 <Cale> People also use katakana just for emphasis, for example
16:45:00 <pikhq> Or to look robotic, or foreign, or whatever else.
16:45:07 <Cale> I guess it can also be compared with italics in that way
16:45:30 <pikhq> Wouldn't be surprised to see it used to make something look like it's somewhat old, too.
16:45:40 <pikhq> (Katakana was the primary phonetic script before ~1950)
16:47:07 <Cale> http://www10.plala.or.jp/koin/koinhentaigana.html btw :)
16:47:39 <pikhq> Yeah, but those are just archaic glyph forms...
16:47:43 <clsmith> hmm, how come not all unicode decimal digits (Nd) are accepted in haskell? titlecase (Lt) are understood to be data constructors, etc..
16:47:48 <pikhq> That I refuse to learn. Just no.
16:48:26 <clsmith> i.e., ǅ is understood to be a data constructor, but ४ is not understood to be a number 4
16:48:36 <monochrom> haha
16:54:02 <hpaste> ash__ pasted “Brushfire map building” at http://hpaste.org/49088
16:54:36 <Cale> pikhq: they are pretty to look at though, and can give some insight into the evolution of hiragana
16:55:18 <ash__> got my brushfire implementation working, it was a kind of translation from a python script, things being pure made this a lot more interesting than I originally expected
16:55:42 <monochrom> omg it's copumpkin!
16:55:47 <copumpkin> yes!
17:02:24 <ash__> is there an easy way to convert a Data.Map.Map (Int, Int) Int -> Data.Array.IArray m Word16 ?
17:09:42 <Jetbeard> hello all -- i'm typesetting my toy code with lhs2tex
17:09:56 <Jetbeard> one thing i've ran into is that one of my operators is called (|>)
17:10:21 <Jetbeard> and I want to say in the text, "This enables us to do neat things like |p |> p|"
17:10:40 <Jetbeard> but the parser sees the pipe in |> as the end of the inline code
17:10:48 <Jetbeard> is there any way to escape it?
17:11:17 <shachaf> Isn't that more of a TeX question than a Haskell question? :-)
17:11:43 <Jetbeard> the | | notation is introduced by lhs2TeX :)
17:11:54 <Jetbeard> but i am also about to ask in #latex
17:11:59 <shachaf> Oh, it is?
17:12:55 * shachaf hasn't used lhs2tex.
17:13:13 <hpc> does tex have a way to escape arbitrary characters?
17:13:27 <hpc> (something similar to &#xxx; in html?)
17:13:51 <bgamari> Any way around this?
17:14:02 <bgamari>     Can't make a derived instance of `VectorSpace R3Vec'
17:14:04 <bgamari>       (even with cunning newtype deriving):
17:14:07 <bgamari>       the class has associated types
17:14:19 <hpc> oh!
17:14:20 <hpc> \vert
17:14:22 <hpc> http://stackoverflow.com/questions/5144862/escape-pipe-character-in-org-mode
17:14:32 <bgamari> Or must I write my own instance, despite one already existing
17:14:45 <hpc> or in this case, \vert{}
17:14:56 <hpc> to get around spacing issues
17:15:01 <Jetbeard> it's not LaTeX that needs escaping, it's lhs2TeX
17:15:39 <hpc> it still works though, as there's no longer a pipe there to escape
17:15:42 <hpc> it draws the same
17:16:01 <Jetbeard> it will draw as a pipe -- but it shouldn't
17:16:14 <Jetbeard> elsewhere in my code i've got %format |> = "\rhd"
17:16:18 <Jetbeard> to make it display nicely
17:16:30 <hpc> ah
17:16:31 <Jetbeard> and in my code blocks it works, just not in the inline code blocks which are delimited by pipes
17:17:45 <Jetbeard> aha, #latex has answered - the operator is written as ||> inside inline code blocks
17:18:17 <hpc> yeah, just found that myself
17:18:27 <hpc> from the lhs2tex pdf guide
17:19:04 <Jetbeard> argh, i'd even searched it for "escape" and missed that :/
17:26:22 <clsmith> does anyone know of a resource which introduces CL really well? i'm trying to write an intro and i don't really know where to start >.>
17:26:43 <dylukes> CL?
17:26:47 <dylukes> OpenCL?
17:26:49 <clsmith> sorry, combinatory logic
17:27:32 <dylukes> no clue :
17:27:49 <hpc> you can start from the wikipedia article on the SKI calculus
17:27:50 <Jafet> There are webpages with combinator tutorials, but they seem to be written mainly to show off the authors' skills at implementing the SK calculus in javascript
17:27:51 <hpc> http://en.wikipedia.org/wiki/SKI_combinator_calculus
17:28:16 <hpc> then go through the see-also links
17:28:56 <clsmith> hpc: thanks, i'll try that
17:29:16 <hpc> it probably won't get you deep, but it will get you at least somewhat into the subject
17:29:24 <hpc> enough that you will have other stuff to google :P
17:30:02 <NihilistDandy> clsmith: There's a book called 'To Mock a Mockingbird'
17:30:21 <clsmith> yeah. basically i'm writing a CL thing for my undergrad course, and i'll need to write a paper on it. but it's difficult to know how to introduce it without losing everyone
17:30:23 <NihilistDandy> http://en.wikipedia.org/wiki/To_Mock_a_Mockingbird
17:31:00 <hpc> clsmith: ooh, that's gonna be tough
17:31:11 <hpc> i couldn't even properly introduce lambda calculus without losing people
17:31:35 <NihilistDandy> I dunno, Smullyan's analogies could help. How math savvy is your audience?
17:31:44 <clsmith> yeah :/ i'm sure there's a trick to it
17:32:07 <clsmith> NihilistDandy: i've been recommended to target "smart final year CS undergrads"
17:32:37 <NihilistDandy> Skim 'To Mock a Mockingbird' and see if you get some inspiration
17:32:46 <NihilistDandy> Smart CS undergrads should grok it
17:32:58 <clsmith> okay, i'll check that out too :)
17:33:20 <ski> @where smullyan
17:33:20 <lambdabot> Raymond Merril Smullyan, "To mock a mockingbird : and other logic puzzles including an amazing adventure in combinatory logic","The riddle of Scheherazade and other amazing puzzles, ancient & modern"
17:33:21 <lambdabot> ,"What is the name of this book : The riddle of dracula and other logical puzzles"
17:33:41 <NihilistDandy> 'What is the Name of This Book' is so great. :D
17:33:48 <hpc> would be nice to have full text links....
17:34:03 <NihilistDandy> I can probably throw them in my dropbox
17:34:09 <NihilistDandy> Not strictly 'legal', mind you
17:34:31 <shepheb> nearly there. time for Mexican food \o/
17:34:31 <clsmith> hm, i do know there's a copy in the library
17:34:34 <hpc> i think the way i would go is explaining the definitions of S,K,I as wikipedia lays them out
17:34:35 <shepheb> fffuuuu mischan
17:34:39 <Jafet> As long as it's consensual
17:34:40 <shepheb> apologies
17:35:03 <hpc> Ix=x, Kxy=x, Sxyz=xz(yz)
17:35:13 <hpc> whoa, i actually remembered the definition of S!
17:35:26 <Jafet> Uh, S is ap
17:35:42 <ski> clsmith : "To Dissect a Mockingbird: A Graphical Notation for the Lambda Calculus with Animated Reduction" by David C. Keenan at <http://dkeenan.com/Lambda/> might be interesting, too
17:35:45 <Jafet> ...a certain ap.
17:35:51 <hpc> Jafet: i can't ever remember that definition either :P
17:36:54 <Jafet> Heh, ski is why I try to use "SK calculus"
17:37:07 <ski> hehe
17:37:10 <hpc> hehe
17:37:39 <hpc> anyhoo, there's enough simple equations you can solve until they get the point
17:37:53 <hpc> then you can blow their mind with SII(SII), the combinatorial quine
17:38:55 <NihilistDandy> MY MIND
17:39:03 * ski . o O ( BCKI-calculus )
17:39:24 <tswett> SBCKWI, please.  :P
17:39:36 <ski> the point was to avoid `S' and `W' :)
17:39:43 <tswett> And while you're at it, add V and the other C.
17:40:02 <ski> (so that we get an affine calculus)
17:40:13 <clsmith> hpc: is it a quine, or just an infinite loop like omega? :p
17:40:17 <tswett> A calculus preserving collinearity?
17:40:21 <ski> clsmith : the latter
17:40:40 <ski> "affine" as in "affine logic"
17:41:27 <hpc> clsmith: it's like "fix id"
17:41:35 <hpc> it evaluates to itself
17:41:40 <Jafet> Not much of a quine you can make, if you don't have putChar
17:42:28 <tswett> I heard in here that the only decent way to evaluate Haskell is... some given thing.
17:42:33 * clsmith looks for a putChar combinator ;)
17:43:31 <tswett> Is there a canonical way to evaluate Haskell, one that's straightforwardly better than any alternatives, or at least really good?
17:43:55 <NihilistDandy> I was just about to ask 'Is there an implementation of the SKI calculus in Haskell?' but then I caught myself. The better question is 'How many Haskell implementations are there?' :D
17:44:08 <ski> clsmith : istr Smullyan talks about combinatory quines in one of his books
17:44:13 <tswett> Aleph_0, of course.  :P
17:44:28 <Jafet> tswett: yes, of course there *** Exception: stack overflow
17:44:40 <hpc> NihilistDandy: haha
17:44:58 <Jafet> > ap id id (ap id id)
17:44:59 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
17:45:18 <NihilistDandy> tswett: I Cantor hear you over the infinite noise
17:45:36 <Jafet> > fix (ap id id . In)
17:45:37 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a1
17:45:58 <Jafet> Okay, that's not an implementation of SK calculus in Haskell.
17:46:43 <hpc> just make a data structure to represent untyped lambda expressions
17:46:45 <hpc> and you're done
17:48:14 <NihilistDandy> hpc: Just
17:48:16 <tswett> data E = A E E | S | K | I; eval (A (A (A S x) y) z) = eval (A (A x z) (A y z)); eval (A (A K x) y) = eval x; eval (A I x) = eval x; eval x = x
17:49:10 <ash__> what causes: Stack space overflow: current size 8388608 bytes. ?
17:49:22 <hpc> ash__: trying to evaluate a huge thunk
17:49:58 <ash__> is there a way around that?
17:50:11 <Jetbeard> more efficient code :)
17:50:24 <ski> tswett : now compile untyped lambda-terms to that
17:50:40 <hpc> ski: "deriving (Show, Read)" :P
17:50:55 <ski> hpc ?
17:51:21 <NihilistDandy> ash__: Strict evaluation could help. Or finding that massive thunk and making it less so.
17:51:43 <hpc> or lazy, if you are being too strict
17:52:24 <NihilistDandy> Or oscillate wildly until you find a happy middle ground
17:53:24 <hpc> or cool to absolute zero and let your waveform oscillate for you
17:55:53 <NihilistDandy> But don't look at it, whatever you do.
17:57:16 <ash__> how do you make it strict?
17:57:39 <hpc> bang patterns, or seq
17:57:45 <hpc> or rnf if you are feeling crazy
17:57:52 <hpc> > 5 `seq` 4
17:57:53 <lambdabot>   4
17:58:07 <hpc> > undefined `seq` 4 -- it evaluates the first argument, then the second
17:58:07 <lambdabot>   *Exception: Prelude.undefined
17:58:34 <Jafet> Shouldn't there be a tutorial for this by now...
17:59:40 <Jafet> Indeed there is http://book.realworldhaskell.org/read/profiling-and-optimization.html
18:00:07 <Jafet> Well, you should be reading the rest of that book anyway
18:00:43 <ash__> ya, i think I need to profile this some, its a lot slower than I would expect it to be
18:01:47 <Jafet> You can also paste code and let the bored people here do some of it for you
18:02:25 <Eduard_Munteanu> Also the wiki...
18:02:30 <hpaste> ash__ pasted “brushfire decomposition” at http://hpaste.org/49090
18:03:14 <NihilistDandy> Mention that you could have written it faster in Java
18:03:27 <NihilistDandy> Don'll be along in a few minutes to optimize it to hell
18:03:37 <Eduard_Munteanu> http://www.haskell.org/haskellwiki/Performance
18:03:45 <ash__> if your curious, thats it, the field size i started with is 10x10, but when you increase that, its becomes exponentially slower
18:06:21 <Eduard_Munteanu> I think cardinalNeighbors could be faster.
18:06:44 <ash__> i am sure most of this is simply my limited understanding of haskell
18:06:46 <Eduard_Munteanu> But yeah, a profile would be useful.
18:07:43 <ash__> 10x10 takes about 0.20s, 13x13 is about 1.49s 15x15 is 1.50m
18:08:04 <Eduard_Munteanu> @where acc
18:08:05 <lambdabot> I know nothing about acc.
18:09:34 <Jafet> Don't optimize yet; profile it
18:09:40 <Eduard_Munteanu> @where+ "Abstract and Concrete Categories (The Joy of Cats)", J. Adámek, H. Herrlich, G. E. Strecker: http://katmat.math.uni-bremen.de/acc/
18:09:40 <lambdabot> I will remember.
18:09:46 <Eduard_Munteanu> Damn
18:09:51 <Eduard_Munteanu> @where+ acc "Abstract and Concrete Categories (The Joy of Cats)", J. Adámek, H. Herrlich, G. E. Strecker: http://katmat.math.uni-bremen.de/acc/
18:09:52 <lambdabot> It is forever etched in my memory.
18:09:57 <Eduard_Munteanu> @where Abstract
18:09:57 <lambdabot> I know nothing about abstract.
18:09:59 <Jafet> @where "Abstract
18:10:00 <lambdabot> and Concrete Categories (The Joy of Cats)", J. Adámek, H. Herrlich, G. E. Strecker: http://katmat.math.uni-bremen.de/acc/
18:10:03 <Eduard_Munteanu> @where+ "Abstract
18:10:04 <lambdabot> Done.
18:10:17 <Eduard_Munteanu> @where "Abstract
18:10:42 <Eduard_Munteanu> @bot
18:10:43 <lambdabot> :)
18:11:02 <Eduard_Munteanu> @where "Abstract
18:11:06 <Eduard_Munteanu> @where acc
18:11:07 <lambdabot> "Abstract and Concrete Categories (The Joy of Cats)", J. Adámek, H. Herrlich, G. E. Strecker: http://katmat.math.uni-bremen.de/acc/
18:11:36 <ash__> NihilistDandy: oh, ya, btw it is faster in python
18:11:39 <ash__> :P
18:11:42 <Eduard_Munteanu> Hrm, so @where+ without a second argument doesn't really delete it.
18:12:37 <Jafet> @list
18:12:38 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
18:13:12 <jmcarthur> ash__: you need to tell dons :P
18:13:42 <jmcarthur> ash__: is this a fairly short program? would it be something to put on hpaste?
18:13:58 <ash__> is there a way to enable --enable-library-profiling by default for cabal installed stuff?
18:14:01 <Jafet> It's already on hpaste
18:14:05 <ash__> http://hpaste.org/49090
18:14:18 <jmcarthur> ah
18:14:26 <Jafet> Edit .cabal/config
18:15:11 <Eduard_Munteanu> Jafet: yeah, I don't think there's a @where- or similar
18:15:25 <Eduard_Munteanu> @where- "Abstract
18:15:25 <lambdabot> Maybe you meant: where where+
18:15:40 <Jafet> Hm yes, the lesson everyone learns for their next (and there is always a next) package world... always enable profiling and source-linked documentation
18:16:41 <jmcarthur> ash__: wavestep looks suspect. your uses of delete and insert aren't going to be evaluated until those components of the result are evaluated
18:17:22 <jmcarthur> ash__: generally, tail calls don't always work the way you might expect in haskell, due to laziness
18:17:56 <jmcarthur> ash__: probably the easiest way to fix that issue is to add some bang patterns to xs and yz
18:18:37 <ash__> can you do that on a Data.Map.Map ?
18:18:50 <jmcarthur> yeah, Data.Map is spine strict
18:19:33 <jmcarthur> you *can* do it to any type of data, it just may not be useful
18:19:43 <jmcarthur> but with Data.Map it's actually useful, too
18:21:21 <ash__> so if I wanted to get a count on the number of times a line was run, i'd do ghc --o test filename.hs -prof   then run it with ./test +RTS -p?
18:21:40 <ash__> it keeps telling me that: Most RTS options are disabled. Link with -rtsopts to enable them.
18:22:00 <Jafet> ...so, link with -rtsopts
18:22:01 <jmcarthur> well, that won't really tell you the number of times a line is run. it will tell you how many times certain expressions are evaluated
18:22:20 <Jafet> GHC profiles based on cost-centers.
18:22:33 <Jafet> For now, perhaps -auto-all would suffice
18:22:39 <jmcarthur> and you can tell it which expressions you want it to count
18:22:45 <jmcarthur> -auto-all being kind of a shotgun approach
18:23:03 <ash__> I added -rtsopts and it prints a list of RTS options when i try to run the program
18:23:14 <jmcarthur> umm
18:23:39 <jmcarthur> ghc -o test filename.hs -prof -auto-all -rtsopts
18:23:46 <jmcarthur> ./test +RTS -p
18:23:48 <ash__> does order of the arguments matter? (I have to add -K100m or I get a stack error)
18:23:59 <jmcarthur> +RTS has to precede RTS args
18:24:21 <jmcarthur> ./test +RTS -p -K100m
18:24:23 <ash__> ah, there, its working now
18:24:45 <jmcarthur> the stack error is due to insufficient strictness
18:24:53 <Eduard_Munteanu> It will be slower (and perhaps stack-overflow easier) with profiling turned on.
18:24:57 <jmcarthur> the bang patterns i suggested should (at least help to) fix it
18:25:57 <ash__> ya, i still got the stack error with -K100m, um... i'll try upping it
18:26:03 <jmcarthur> it won't really help with the algorithmic complexity though
18:26:11 <Jafet> Reduce the program parameters
18:26:25 <ash__> ya, but I just want to see which expressions are being evaluated the most
18:26:26 <Jafet> You probably don't need a massive input to get an idea of what's wrong
18:26:26 <jmcarthur> your cardinalNeighbors function looks really slow
18:26:49 <jmcarthur> i would think about using a different algorithm there
18:27:40 <jmcarthur> looks like brushfire could use some bang patterns too
18:27:51 <ash__> jmcarthur: ya, your right,     cardinalNeighbors    Main                                                 376       69122 100.0   51.5   100.0   51.5
18:28:12 <ash__> thats roughly 100% of the runtime right there
18:29:01 <jmcarthur> brushfire !coords obstacles !n m -- something like this i think
18:29:10 <wli> I just checked in. What's this cardinalNeighbors affair?
18:29:36 <jmcarthur> hmm, at least n, maybe not coords
18:29:47 <jmcarthur> oh, no, coords too
18:29:58 <jmcarthur> they are both being built up without being evaluated
18:30:10 <jmcarthur> wli: data DimHoles sh where
18:30:12 <jmcarthur>   None :: DimHoles Z
18:30:14 <jmcarthur>   Hole :: sh :. All -> DimHoles sh
18:30:16 <jmcarthur> dangit
18:30:18 <ash__> wli: I made a program thats slow and someones helping me with it
18:30:18 <jmcarthur> where did that come from
18:30:23 <jmcarthur> wli: http://hpaste.org/49090
18:30:36 <jmcarthur> excuse the noise
18:30:43 <jmcarthur> shapr!
18:31:42 <jmcarthur> ash__: anyway, if you at least get the strictness stuff worked out you won't need such large stacks. it won't help your overall slowness though, since cardinalNeighbors is just a slow algorithm
18:32:21 <ash__> hmm, well i'll see if I can think of another way of writing it
18:33:20 <jmcarthur> hmm, well, the bang patterns might actually help quite a bit
18:37:26 <RichardO> How do you turn echo off in the terminal from Haskell?
18:37:51 <parcs> @hoogle hSetEcho
18:37:51 <lambdabot> System.IO hSetEcho :: Handle -> Bool -> IO ()
18:38:13 <RichardO> I tried doing "hSetEcho stdin False" but it didn't work.
18:38:33 <parcs> why stdin?
18:38:46 <RichardO> stdout?
18:39:04 <parcs> try it
18:39:18 <Jafet> Strictly speaking, neither stdin nor stdout involves a terminal
18:39:23 <RichardO> no, stdout doesn't work either
18:39:42 <Jafet> Perhaps it expects a handle to the pty or something; see the documentation
18:40:06 <parcs> stdout should work
18:40:13 <parcs> at least it did for me
18:40:17 <RichardO> do you know how to get a handle to the term?
18:41:19 <shachaf> @ECHO OFF
18:41:20 <lambdabot> Unknown command, try @list
18:41:31 <shapr> jmcarthur!
18:43:18 <RichardO> I'm using Mac OS X terminal. Do you think this is a bug?
18:45:44 <Eduard_Munteanu> You could check against xterm.
18:46:24 <Eduard_Munteanu> (for instance I'm not sure you can do that if it's a dumb terminal)
18:47:51 <shachaf> RichardO: Are you testing in ghci?
18:47:56 <kizzx2> noob question: can i "import qualified" in ghci?
18:48:05 <shachaf> kizzx2: As of GHC 7, yes.
18:48:08 <RichardO> I'm using runghc
18:48:44 <kizzx2> shachaf: cool!, i happen to be using ghci6, is the syntax something just like "ghci> import qualified Foo.Bar as FB" ?
18:49:06 <shachaf> kizzx2: Yes. But it won't work in GHC 6. :-)
18:49:20 <kizzx2> shachaf: thanks :)
18:50:12 <Eduard_Munteanu> http://stackoverflow.com/questions/4064378/prompting-for-a-password-in-haskell-command-line-application
18:50:20 <Eduard_Munteanu> So it looks like you need to do it on stdin
18:50:48 <Eduard_Munteanu> (possibly because the terminal itself does the echoing on input and stdout isn't involved)
18:50:57 <shachaf> Yep, and doing it on stdin works for me.
18:51:06 <monochrom> yeah, stdin in linux in gnome-terminal
18:53:10 <RichardO> I can turn echo off when using C's ncurses.
18:53:39 <ski> Eduard_Munteanu : that's an interesting book ..
18:54:59 <Eduard_Munteanu> ski: ACC? Yeah, I've been looking for alternatives to Awodey.
18:55:08 <Eduard_Munteanu> Found it referenced on Wikipedia.
18:55:42 * ski found it in library
18:55:57 <ski> (but i can't borrow it all the time ..)
18:57:19 <Eduard_Munteanu> Oh.
18:57:42 <Eduard_Munteanu> What do you think of it?
18:58:01 <Eduard_Munteanu> It seems to follow a different approach.
18:58:22 <ski> i haven't really looked much in Awodey
19:05:40 <Eduard_Munteanu> Anyway, there are some things I don't grok from Awodey, so it's nice to have alternate expositions.
19:07:30 <edwardk> Eduard_Munteanu: lawvere and schanuel provide a nice very basic introduction
19:09:14 <edwardk> http://www.math.upatras.gr/~cdrossos/Docs/B-W-LectureNotes.pdf is also a nice crash course
19:09:36 <Eduard_Munteanu> Hrm, Lawvere's looks nice, lots of connections to algebra too.
19:11:08 <edwardk> lawvere goes at things pretty slowly, but you definitely get enough examples that way
19:11:10 <Eduard_Munteanu> Nice, thanks.
19:11:21 <edwardk> the concern is that it doesn't go very deep
19:11:33 <Eduard_Munteanu> Also, TTT had some CT in it, I should look there too.
19:11:36 <Eduard_Munteanu> @where ttt
19:11:37 <lambdabot> Toposes, Triples and Theories: http://www.cwru.edu/artsci/math/wells/pub/ttt.html
19:14:34 <edwardk> bookmarked
19:16:08 <gienah> there is this book by some of the same authors: http://www.cwru.edu/artsci/math/wells/pub/ctcs.html
19:17:44 <gienah> its only available by sending lots of pretty please with sugar on top emails to the uni of montreal :-/
19:22:52 <Leftmost> Anyone know why pointed depends on stm < 2.2? It seems to build just fine with the version included in platform.
19:23:59 <ski> Eduard_Munteanu : "Sets for Mathematics" is also interesting
19:26:28 <shachaf> Leftmost: People tend to be conservative with their version requirements.
19:27:05 <Leftmost> Fair enough. Thanks. Not too familiar with conventions hereabouts.
19:27:09 <gienah> which seems to create more work most of the time as we have to sed the cabal file to loosen the requirements
19:39:16 * Eduard_Munteanu thinks textbooks should be open (free) and get public review
19:42:10 <jnhnum1> is there an easy point-free way of writing this function: http://hpaste.org/49094 ?
19:43:17 <gienah> @pl combine hash c = hash * 33 + ord c
19:43:18 <lambdabot> combine = (. ord) . (+) . (33 *)
19:43:29 <Eduard_Munteanu> I don't think there's a nice one though :)
19:44:12 <Eduard_Munteanu> Don't try to pointfree everything.
19:44:22 <jnhnum1> I was wondering because J seems to have this nice construct for forking
19:45:18 <jnhnum1> where you can say something like avg=: +/ % #
19:45:34 <jnhnum1> +/ is a function which sums lists
19:45:36 <jnhnum1> % is division
19:45:40 <jnhnum1> and # counts the list
19:45:42 <jnhnum1> or something
19:45:46 <jnhnum1> and it seemed like a similar pattern
19:47:15 <RichardO> @pl combine hash = hash * 33 + ord c
19:47:15 <lambdabot> combine = (ord c +) . (33 *)
19:48:40 <Eduard_Munteanu> @pl avg xs = sum xs / length xs
19:48:41 <lambdabot> avg = liftM2 (/) sum length
19:49:02 <wli> genericLength
19:49:11 <Eduard_Munteanu> But it's the same argument there.
19:49:33 <wli> try it non-generic and see
19:49:50 <Eduard_Munteanu> Oh, right.
19:55:06 <Eduard_Munteanu> < Eduard_Munteanu> But it's the same argument there.    -- that wasn't for wli, in case it's not clear
20:01:39 <dicey> beer and skittles dont go together very well.
20:02:10 <dicey> but if you have lots of both, what choice do you have?
20:02:54 <luite> are you making skittlebrau?
20:03:17 <dicey> what's a brau?
20:03:40 <droidboi> a brewary
20:03:51 <luite> german word for brew I guess?
20:03:59 <dicey> technically you could ferment skittles, it's all sugar
20:04:05 <droidboi> :)
20:04:05 <luite> Homer: "I'm feelin' low, Apu. You got any of that beer that has candy floating in it, you know, Skittlebrau?"
20:04:06 <dicey> although it would be disgustingly colored
20:04:08 <luite> Apu: "Such a product does not exist, sir! You must have dreamed it."
20:04:11 <luite> Homer: "Oh. Well then just gimme a six-pack and a couple of bags of Skittles."
20:04:35 <dicey> wow, i guess im not the only one to have such a combination
20:04:47 <luite> no the simpsons already did it, of course ;p
20:05:20 <dicey> if somebody solves the riemann hypothesis, it will likely be pointed out that it was already proven on the simpsons.
20:05:57 <luite> I have a proof, but I'm only publishing it after the simpsons does ;)
20:06:28 <luite> it's like the new margin
20:09:11 * hackagebot blakesum 0.0 - The BLAKE SHA-3 candidate hashes, in Haskell  http://hackage.haskell.org/package/blakesum-0.0 (KevinCantu)
20:09:16 <dicey> it wouldn't shock me if somebody involved in the simpsons contributed significantly to science anyway
20:09:26 <dicey> those guys are all extremely intelligent
20:09:46 <kmc> http://www.geekosystem.com/futurama-prisoner-of-benda-theory/
20:10:26 <luite> hehe I was just going to google that one, forgot the name of the episode though
20:10:41 <luite> but the new futurama is less "smart", lower budget
20:11:00 <dicey> math phds are cheap
20:11:05 <luite> hehe
20:11:29 <dicey> you can hire a math phd for like, a case of beer or a bag of weed.
20:12:09 <luite> yeah but they're about as useful as Bender ;)
20:14:59 <dicey> =( mean words
20:19:17 <EvanR> aaahaha
20:19:21 <EvanR> http://www.reddit.com/r/haskell/comments/iqxpx/on_how_haskells_are_just_might_just_be_function/
20:19:24 <EvanR> the comments
20:20:36 <luite> at least he calls byorgey really smart!
20:23:59 <Cale> "Reading that title while 1/4 drunk makes me feel 3/4 drunk."
20:24:39 <monochrom> the title demos buggy blog software doubly
20:25:12 <kmc> has anyone really been far even as decided to use even go want to do look more like?
20:25:20 <EvanR> lol
20:26:13 <monochrom> firstly the blog software fails to take "<strike>are just</strike>" as html
20:27:11 <monochrom> secondly I'm pretty sure it was originally "on haskell's <<< <strike>are just</strike> ..." and the blog software ate the "<<<"
20:27:30 <kmc> nom
20:27:32 <monochrom> err, "on how haskell's <<< <strike>are just</strike> ..."
20:27:38 <EvanR> ahhh
20:27:51 <EvanR> &lt;&lt;&lt;
20:28:27 <monochrom> generally most blog software bombs on < & >
20:29:14 <EvanR> if its going to leave <strike> in there might as well leave all < and >
20:29:35 <EvanR> if its going to try and allow 'only certain' markup well youre screwed
20:32:26 <monochrom> now someone has edited it to "On how Haskell’s Arrows might just ..." :)
20:37:23 <ash__> are list index access O(1)?
20:38:52 <EvanR> definitely not
20:39:09 <ash__> what about Data.Array?
20:39:11 <EvanR> @src (!!)
20:39:11 <lambdabot> xs     !! n | n < 0 = undefined
20:39:11 <lambdabot> []     !! _         = undefined
20:39:12 <lambdabot> (x:_)  !! 0         = x
20:39:12 <lambdabot> (_:xs) !! n         = xs !! (n-1)
20:39:24 <EvanR> Array, definitely
20:39:32 <ash__> kk
20:42:28 <BadLad> what's the coolest way any of you have seen Maybe Monads used?
20:43:27 <kmc> what's the coolest way you've seen integers used
20:44:01 <ash__> I saw a function that returned Nothing once, i was impressed
20:44:28 <BadLad> kmc: the algorithm for counting 1s using binary operations
20:44:44 <Cale> That shouldn't have been plural. Maybe is just one monad.
20:45:15 <BadLad> Cale: granted. I can only think of one way for Maybe to be a Monad
20:45:35 <EvanR> i think theres a few more
20:45:41 <EvanR> fairly boring ways
20:46:08 * EvanR puts some tea on
20:46:09 <Cale> Well, okay, there's more than one way for the Maybe type to be defined as a monad instance, but only one at a time is allowed by the Haskell compiler anyway :P
20:46:12 <BadLad> I was hoping for examples using sequence or something
20:46:45 <Cale> Probably the main thing is where you have a chain of lookups in various Map-like structures, any of which might fail.
20:47:07 <jnhnum1> @pl f x y z = x*y + z
20:47:07 <lambdabot> f = ((+) .) . (*)
20:47:20 <Cale> (and where what you're looking up depends on what was looked up in previous steps)
20:48:21 <EvanR> Cale: using 'early exit' while doing another monad would be nice, whats the standard way to do that these days, MaybeT ?
20:50:22 <dolio> ErrorT could also work, despite the bad name.
20:50:43 <BadLad> Cale: that's a neat idea. Are there any bits of code I can see (e.g. on GitHub) that demonstrate this?
20:50:50 <dolio> The Error e requirement is a little poor, too.
20:51:20 <EvanR> i saw this code called Exit and ExitT, seems weird though
20:59:26 <BadLad> What would be some other ways for Maybe to be a Monad?
21:00:07 <Jafet> Well, fail could be error
21:00:14 <Jafet> But you probably don't want that
21:00:37 <Jafet> @src Monad Maybe
21:00:37 <BadLad> anything that would change the definition of 'return'?
21:00:37 <lambdabot> Source not found.
21:00:39 <EvanR> uhg, fail
21:00:43 <Jafet> @src Maybe Monad
21:00:44 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
21:01:03 <BadLad> hah, I didn't know that lambdabot would apologize
21:01:19 <Jafet> Smirking all the time.
21:01:37 <Jafet> I don't think there's any other valid Maybe monad.
21:01:54 <EvanR> return x = Nothing, x >>= f = Nothing?
21:02:16 <BadLad> hah, I guess that technically satisfies the rules
21:02:35 <Jafet> Hm, good one
21:06:09 <EvanR> > 1
21:06:10 <lambdabot>   1
21:06:17 <EvanR> > () >> ()
21:06:18 <lambdabot>   Couldn't match expected type `m a' against inferred type `()'
21:06:23 <EvanR> er
21:06:31 <EvanR> nevermind, () isnt a burrito
21:07:04 <Jafet> All hot dog buns are indistinguishable
21:29:04 <dicey> everything is a function. does believing that make me religious?
21:29:27 <Jafet> Is your dirty underwear a function?
21:29:45 <Jafet> How many arguments does your girlfriend take?
21:29:48 <BadLad> a function of bad hygeine, which is a constant
21:30:10 <dicey> bad hygeine is anything but a constant.
21:30:51 <dicey> mine, anyway
21:31:17 <Cale> BadLad: If you have return x = Nothing and x >>= f = Nothing, you get a valid Monad instance, it's just dumb.
21:31:36 <Cale> BadLad: I don't know, I could write some one-line sample...
21:31:40 <dicey> cale: not dumb, trivial.
21:32:06 <BadLad> Cale: I'm just on the hunt for some clever code to review
21:32:27 <BadLad> Specifically involving cleverness with monads
21:33:01 <dicey> badland: have you tried deciphering the standard modules? the ones that come with GHC?
21:33:20 <Cale> > let gr = [(0,1),(1,3),(2,2),(3,4)] in do x <- lookup 0 gr; y <- lookup x gr; z <- lookup y gr; return (x,y,z)
21:33:21 <lambdabot>   Just (1,3,4)
21:33:34 <Cale> > let gr = [(0,1),(1,3),(2,2),(3,4)] in do x <- lookup 0 gr; y <- lookup x gr; z <- lookup y gr; w <- lookup z gr; return (x,y,z,w)
21:33:35 <lambdabot>   Nothing
21:34:16 <Cale> ^^ that's the sort of thing I was talking about, only in most real uses, you'd have more than one dictionary, and you probably wouldn't be using lists of pairs
21:38:25 * hackagebot heist-async 0.4.0.0 - Adding support for asynchronous updates ("AJAX") with heist  http://hackage.haskell.org/package/heist-async-0.4.0.0 (DanielPatterson)
21:38:36 <BadLad> Cale: pretty good example for such a quick stab at it
21:45:37 <Jafet> > do let gr = M.fromList [(0,1),(1,3),(2,2),(3,4)]; x <- lookup 0 gr; y <- lookup x gr; z <- lookup y gr; w <- lookup z gr; return (x,y,z,w)
21:45:38 <lambdabot>   <no location info>: parse error on input `<-'
21:45:45 <_Ray_> Hi :) Say I wanted to try Agda, but I didn't like/am not comfortable in Emacs. What should I try?
21:45:45 <Jafet> > do let { gr = M.fromList [(0,1),(1,3),(2,2),(3,4)] }; x <- lookup 0 gr; y <- lookup x gr; z <- lookup y gr; w <- lookup z gr; return (x,y,z,w)
21:45:46 <lambdabot>   Couldn't match expected type `[(t, b)]'
21:45:47 <lambdabot>         against inferred type `Data...
21:46:00 * Jafet stops stabbing
21:47:12 <Jafet> > do let { gr = M.fromList [(0,1),(1,3),(3,2),(2,4)] }; x <- M.lookup 0 gr; y <- M.lookup x gr; z <- M.lookup y gr; w <- M.lookup z gr; return (x,y,z,w)
21:47:13 <lambdabot>   Just (1,3,2,4)
21:48:51 <kmc> _Ray_, try becoming comfortable with Emacs
21:49:01 <wli> I don't suppose people looking at the remez.pdf bit I've been writing up are around.
21:49:18 <kmc> _Ray_, sorry, but i think you're at a serious disadvantage otherwise
21:49:27 <_Ray_> In general or just with Agda?
21:49:30 <kmc> with Agda
21:50:08 * _Ray_ just discovered the Curry-Howard isomorphism and is almost turned on by it.
21:50:13 <kmc> almost?
21:50:37 <kmc> i could be wrong but my impression is that the number of Agda hackers is small enough that the dominant UI is the only usable one
21:50:47 <kmc> i could be wrong, though.  did you try #agda?
21:50:48 <wli> http://proxima.lp0.eu/~wli/remez.pdf <-- my latest core dump or whatever with Bernstein polynomial calculations out the wazoo.
21:51:03 <_Ray_> not yet :) didn't know it existed, should have tried it before. thanks!
21:51:34 <kmc> _Ray_, i think it's not hard to learn enough emacs to kind of bumble along in agda-mode
21:53:13 <wli> I think the best way to describe the update is an explicit calculation of the C^1 continuity conditions for Bernstein form numerators and denominators.
21:54:20 <wli> It would be better to programmatically generate the constraints.
21:55:15 <BadLad> Looked up the Curry-Howard Isomorphism, and found this gem, describing a clever trick in genetic programming: The method indexes sets of genotypes (the program trees evolved by the GP system) by their Curry-Howard isomorphic proof (referred to as a species). (wikipedia)
21:56:45 <_Ray_> so hot :(
21:56:57 <kmc> the proof is the program
21:57:16 <kmc> how is that not trivial
21:57:33 <kmc> also is GP actually good for anything?
21:57:34 <BadLad> I'm guessing the proof-form is easier to distinguish and abstract
21:58:01 <kmc> how do they differ?
21:58:19 <kmc> genetic programming > genetic algorithms > other "machine learning" > simple optimization
21:58:27 <kmc> where ">" is read as "is even more cargo cult than"
21:58:38 <BadLad> hahaha
21:58:57 <Jafet> Or ranked by inscrutability of output
21:59:07 <kmc> don't get me wrong, cargo cult techniques can produce useful results
21:59:12 <kmc> though i don't know of any, in the case of GP
21:59:16 <BadLad> genetic programming is useful when you want an algorithm, and you don't really care what it is, or why it exists, but only that it works better than some standard
21:59:27 <kmc> does it actually work, though
21:59:32 <kmc> for creating new algorithms?
21:59:35 <BadLad> GP works, yes
21:59:43 <kmc> on what scale?
21:59:44 <Jafet> Well, when it succeeds, it works
22:00:08 <hpaste> NemesisD pasted “Declarative Parse” at http://hpaste.org/49099
22:00:28 <Jafet> There's no guarantee of it working better than anything else, or working in any other context
22:00:44 <NemesisD> hi all. i'm trying to define some xml parsers in a declarative fashion to make it easier to read/less like boilerplate. in the paste, i noticed i was passing in the root element to all the calls in the monad. is there a way i can avoid that?
22:01:07 <hpaste> “Garriot Zhang” pasted “BrainFuck intepreter” at http://hpaste.org/49100
22:02:34 <NemesisD> something like inside the monad, all of those function calls are curried with the root already passed in
22:02:45 <hpaste> “Garriot Zhang” annotated “BrainFuck intepreter” with “BrainFuck intepreter” at http://hpaste.org/49100#a49101
22:04:28 <hpaste> “Garriot Zhang” annotated “BrainFuck intepreter” with “BrainFuck intepreter” at http://hpaste.org/49100#a49102
22:06:50 <hpaste> “Garriot Zhang” annotated “BrainFuck intepreter” with “BrainFuck intepreter” at http://hpaste.org/49100#a49103
22:08:14 <Jafet> No optimization? I am dissapoint
22:11:44 <NemesisD> im thinking i could use a monad reader and throw the resulting record in there as well as the root element. then i should be able to map xml fields to values like targetField !<> "tag-name-of-target-field"
22:24:13 <NemesisD> actually, that brings up a question, is it possible to incrementally build a record? i would need some sort of default to not incur a compiler warning
22:24:44 <kmc> MyRec { x = 3, y = error "forgot to define y you jerk" }
22:24:58 <kmc> i've done this but it's not pretty, there are usually better ways
22:25:51 <NemesisD> like what?
22:26:03 <NemesisD> applicative?
22:27:30 <NemesisD> actually using <*> and <$> to create a record always rubbed me the wrong way, since changing the order of the fields in the definition would break it
22:32:32 * hackagebot mwc-random 0.8.0.5 - Fast, high quality pseudo random number generation  http://hackage.haskell.org/package/mwc-random-0.8.0.5 (BryanOSullivan)
23:06:56 * Kreative` is away: Away
23:07:30 <kmc> preflex, seen Kreative`
23:07:30 <preflex>  Kreative` was last seen on #haskell 33 seconds ago, saying: * Kreative` is away: Away
23:08:33 <NemesisD> kmc: are you familiar at all with the Aeson library?
23:08:48 <kmc> no
23:09:38 <NemesisD> oh. i'm trying to work towards a syntax similar to http://hackage.haskell.org/packages/archive/aeson/0.3.2.9/doc/html/Data-Aeson.html#t:FromJSON
23:10:17 <NemesisD> im wondering if you'd be able to point me in the right direction as to that applicative bit in parseJSON
23:11:13 <NemesisD> i can't figure out how they do that
23:18:46 <Rc43> Guys, can you say me main objects about codegeneration and theorem proving?
23:19:33 <Rc43> I have one insane idea, but i think, it has been somehow realized already.
23:20:31 <NihilistDandy> Wut
23:20:49 <Rc43> lol
23:21:13 <NihilistDandy> What's your idea?
23:21:21 <kmc> @quote ubuntu.freebsd
23:21:22 <lambdabot> NIXDAEMON-COOL says: how to uncompile make into java gcc 3.3 under ubuntu freebsd ??
23:21:44 <Rc43> Something about auto programm building.
23:21:57 <NihilistDandy> @quote NihilistDandy
23:21:57 <lambdabot> NihilistDandy says: The best part of Haskell is that 80% of module names can be turned into clever blog titles.
23:22:04 <Rc43> I googled "theorem prooving" and "and auto code generation", but found some articles on wiki and strange hostings.
23:22:09 <NihilistDandy> I am self-absorbed
23:22:33 <Rc43> @quote Rc43
23:22:33 <lambdabot> No quotes match. Do you think like you type?
23:22:35 <NihilistDandy> Rc43: What exactly are you trying to do? Prove theorems? Generate code?
23:23:30 <Rc43> NihilisticDandy, now i didn't started writing code.
23:23:57 <Rc43> NihilisticDandy, I want to look what is created and think better about it.
23:25:00 <Rc43> Hm, i have downloaded some pdfs.
23:48:29 <MatrixFrog> so i found this book about haskell and music on /r/haskell... so i'm trying to install Euterpea so i can kind of play along
23:48:43 <MatrixFrog> getting this: Warning: This package indirectly depends on multiple versions of the same
23:48:43 <MatrixFrog> package. This is highly likely to cause a compile failure.
23:48:57 <MatrixFrog> ... package random-1.0.0.3 requires time-1.2.0.3
23:48:58 <MatrixFrog> package random-1.0.0.3 requires time-1.2.0.5
23:49:01 <NihilistDandy> MatrixFrog: link?
23:49:06 <MatrixFrog> oh yes sorry
23:49:11 <MatrixFrog> http://plucky.cs.yale.edu/cs431/software_resources.htm
23:49:20 <NihilistDandy> Oh, yeah, I saw that on the Cafe
23:49:36 <MatrixFrog> i'm at "cd Euterpea; cabal install" so almost there! i think
23:50:11 <MatrixFrog> when i do "cabal info random" it says "time -any" meaning it should just use the latest version i would think
23:50:54 <MatrixFrog> "cabal info time" says i have both 1.2.0.3 and 1.2.0.5 installed
23:51:21 <NihilistDandy> try ghc-pkg hide time-1.2.0.3
23:51:36 <NihilistDandy> And then see if you get the same error
23:51:41 <NihilistDandy> Which version of GHC are you using/
23:51:44 <NihilistDandy> *
23:51:47 <NihilistDandy> *?
23:52:22 <MatrixFrog> 7.0.3
23:53:10 <MatrixFrog> :-/ same error
23:53:41 <NihilistDandy> Hmm
23:53:53 <NihilistDandy> Can you post the cabal file on hpaste?
23:54:17 <MatrixFrog> of euterpea?
23:54:35 <NihilistDandy> Yeah. I forgot to install darcs on this machine, so it's compiling now
23:54:38 <MatrixFrog> http://code.haskell.org/Euterpea/Euterpea.cabal
23:54:42 <NihilistDandy> In the meantime, I'd like to look at the cabal
23:54:45 <NihilistDandy> Ah, good
23:55:08 <MatrixFrog> afaict you don't really NEED darcs, you could just copy the files from code.haskell.org/Euterpea. but whatever
23:55:26 <MatrixFrog> i'll paste the full error message though
23:55:49 <NihilistDandy> MatrixFrog: Well, true, but I do love to follow directions :D
23:56:14 <hpaste> MatrixFrog pasted “errors when install euterpea” at http://hpaste.org/49105
23:56:43 <NihilistDandy> If you could also paste your `ghc-pkg list`, that would also be helpful
23:56:45 <MatrixFrog> oh me too, especially because if someone asks ME for help, the first thing i'm gonna do is go "well are you SURE you followed the directions EXACTLY right?"
23:57:23 <NihilistDandy> Haha, true
23:57:59 <hpaste> MatrixFrog pasted “ghc-pkg list” at http://hpaste.org/49106
23:58:23 <NihilistDandy> Oh, I see. What happens if you `ghc-pkg expose time-1.2.0.3` and then `ghc-pkg hide time-1.2.0.5`?
23:58:48 <MatrixFrog> so a bunch of stuff is in the haskell platform dir and a bunch is in my user dir. does that matter? it seems like it might be good for it to be more consistent
23:59:12 <MatrixFrog> same error
23:59:33 <NihilistDandy> It shouldn't matter much. It can make some differences depending on whether you're doing a cabal install --global or --user
23:59:43 <NihilistDandy> But that only happens to me occasionally
23:59:59 <MatrixFrog> mmk
