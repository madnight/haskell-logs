00:22:12 <cizra2> How do I consume a word (non-whitespace) with Parsec? something like many (not space)?
00:23:11 <cizra2> Is there something like "many" only consuming _one_ or more items?
00:23:57 <sanjoyd> So seq is basically strict?
00:24:40 <Cale> many1
00:25:17 <Cale> sanjoyd: yeah
00:25:32 <Cale> seq a b is b unless a is undefined in which case it's undefined
00:26:39 <sanjoyd> > seq (\x->undefined) True
00:26:40 <lambdabot>   True
00:26:45 <sanjoyd> > seq undefined True
00:26:46 <lambdabot>   *Exception: Prelude.undefined
00:27:07 <sanjoyd> Can it be used to differentiate \x->undefined and undefined?
00:27:23 <Cale> > (\x -> undefined) `seq` 0
00:27:23 <lambdabot>   0
00:27:28 <Cale> > undefined `seq` 0
00:27:28 <lambdabot>   *Exception: Prelude.undefined
00:27:31 <quicksilver> you just proved it can, sanjoyd :P
00:27:46 <shachaf> seq isn't *exactly* strict.
00:27:49 <Cale> oh, so he did
00:27:51 <sanjoyd> No, I mean without the whole computation being undefined.
00:28:03 <quicksilver> no.
00:28:13 <sanjoyd> shachaf: what am I missing?
00:28:16 <benmachine> sanjoyd: you can't test for undefined
00:28:19 <shachaf> sanjoyd: You can never differentiate between undefined and non-undefined in general.
00:28:21 <quicksilver> the only "observation" of _|_ you can perform in haskell will make everything undefined
00:28:40 <quicksilver> so you can "observe" it by making everything crash or fail to terminate.
00:28:48 <sanjoyd> Oh, okay.
00:28:48 <quicksilver> (but you can never be sure which will happen in general!)
00:28:49 <sanjoyd> Got it.
00:28:58 <shachaf> sanjoyd: Well, seq (seq undefined) x == x.
00:29:09 <shachaf> So technically it's not strict, kind of. The distinction isn't very important. :-)
00:30:11 <Saizan> "\x -> seq x something" is strict :)
00:30:51 <shachaf> sanjoyd: Speaking of strictness, id and const undefined are both considered strict.
00:34:27 * sanjoyd opens the chapter on strictness.
00:37:06 <shachaf> sanjoyd: f is strict iff f _|_ = _|_
00:37:12 <Saizan> which kind of suggests that strictness is the wrong property to focus on..
00:37:43 <shachaf> Saizan: As opposed to what? "Forcingness"?
00:39:19 <Saizan> that's the idea
00:41:16 <ddarius> If you care about semantics, strictness is what you want.  If you only care about operational behavior, than strictness isn't too important, and it is eagerness that's important.
00:41:23 <ddarius> Most uses of seq should be uses of pseq.
00:41:54 <sanjoyd> What is the difference between strictness and eagerness/
00:41:55 <sanjoyd> ?
00:42:12 <ddarius> "We put in large flourescent light fixtures which looked great and worked until we had our first explosion."
00:42:36 <ddarius> Strictness is a semantic property, eagerness is an operational property.
00:45:22 <quicksilver> sanjoyd: eagerness is "I really want you to do this work first"
00:45:32 <quicksilver> strictness is "if you can prove this is not _|_ that's enough for me"
00:46:05 <quicksilver> in practice GHC is very rarely clever enough to do a complex proof in the second case, so it will instead actually do the work, and so the way it *implements* strictness is by being eager.
00:46:18 <quicksilver> however, it's not required to do that and there are some cases in which it can perform simple proofs.
00:48:16 <Saizan> you don't need much of a proof to compute b before a in seq a b
00:49:08 <Saizan> but the optimizer usually doesn't bother
00:49:21 <quicksilver> yes, that's true
00:49:29 <quicksilver> but you do need a proof to not calculate a at all.
01:03:16 <cizra2> Any Parsec users around?
01:03:31 <danharaj> I've used parsec in the past, yeah?
01:03:51 <cizra2> How do I consume a word (non-whitespace) with Parsec? something like many (not space)?
01:04:01 <cizra2> Is there something like "many" only consuming _one_ or more items?
01:04:12 <arcatan> many1
01:04:17 <cizra2> aha! Great
01:04:56 <danharaj> there's also `word'
01:05:07 * quicksilver remarks that Cale answers cizra2 last time he asked that :)
01:05:27 <cizra2> quicksilver: Heh, I didn't notice. Sorry.
01:05:27 <danharaj> word = many1 letter
01:05:41 <cizra2> Indeed! Thanks!
01:12:54 <ddarius> You don't need any proof to computer b before a in seq a b.
01:15:56 <sanjoyd> ddarius: quicksilver thanks!
01:20:09 <quicksilver> §
01:20:12 * quicksilver nods
01:27:18 * hackagebot llvm-extra 0.2 - Utility functions for the llvm interface  http://hackage.haskell.org/package/llvm-extra-0.2 (HenningThielemann)
01:27:20 <danharaj> does anyone know where cabal-dev puts packages it fetches from hackage? I need to manually configure one to make it build.
01:30:12 <zygoloid> danharaj: ~/.cabal/packages
01:30:57 <zygoloid> oh, cabal-dev? then no, i don't know :)
01:31:03 <cizra2> Yay! It parses! It parses stuff!
01:31:07 * cizra2 jumps with excitement.
01:31:51 * earthy is jealous of cizra2
01:32:08 <earthy> wish I still had that naive joy in technology. :)
01:33:32 <Jafet> Spend a week in JEE6 and you'll get it back
01:37:50 <earthy> Jafet: btdt. that's the problem. :)
01:55:12 <jonkri> how can i specify the U+0022 character?
01:55:42 <Botje> isn't that a " ?
01:56:29 <Jafet> > '\x22'
01:56:29 <lambdabot>   '"'
01:56:33 <jonkri> Botje, correct, but i mean an arbitrary unicode character. is \34 the only supported way?
01:57:01 <jonkri> i have a list of hex characters
01:57:12 <jonkri> Jafet, oh, thanks
01:57:14 <Jafet> > chr 0x22
01:57:15 <lambdabot>   '"'
02:00:08 <cizra2> (still about Parsec) I want something like <|> with additional information, _which_ branch was taken. How do I do that?
02:01:12 <quicksilver> encode the information with fmap, normally
02:01:26 <quicksilver> fmap Left firstchoice <|> fmap Right secondchoice
02:01:45 <quicksilver> although I'd normally write that (Left <$> firstchoice) <|> (Right <$> secondchoice)
02:02:14 <cizra2> Hmmm, thanks!
02:23:21 <FUZxxl> Is anybody familiar with the Eclipse plugin for Haskell?
02:23:54 <rostayob> I hope not
02:24:03 <FUZxxl> ha ha ha
02:24:11 <rostayob> :)
02:24:26 <FUZxxl> Oh... Is anybody familiar with the Haskell plugin for Eclipse
02:24:36 <rostayob> FUZxxl: the haskell community doesn't play well with IDEs in my experience. but maybe someone can help you
02:24:36 <FUZxxl> ;)
02:25:17 <rostayob> you might want to try emacs or vim haskell modes in the mean time :D
02:25:21 <FUZxxl> rostayob: Some guys coded a very sophisticated adaption for Haskell, with code completation and everything else.
02:25:33 <arcatan> FUZxxl: as no hands rise, maybe you should just ask your question and see if anyone answers
02:25:39 <FUZxxl> rostayob: I don't know how to use them.
02:26:14 <FUZxxl> (emacs and vivivi)
02:26:16 <rostayob> FUZxxl: that's interesting, but you can get the same functionality in emacs, and probably vim too (never used it but I hear the haskell mode is really good)
02:26:30 <nafur> hi, I'm looking for a solution to integrate xmonad into gnome 3, preserving the "gnome bar" at the top...
02:26:36 <rostayob> FUZxxl: but arcatan is right, just as the question
02:26:46 <FUZxxl> okay.
02:27:08 <rostayob> also, you should learn vi at some point anyway eheh
02:27:21 <nafur> I've found various (in fact identical) solutions to use xmonad with gnome, but none that achieves this. is this even possible?^^
02:27:22 <FUZxxl> When I start the IDE it always complains about "scion" not being found.
02:27:40 <rostayob> nafur: #xmonad might be a better channel
02:28:24 <nafur> I already wondered why the irc-link on xmonad .org pointed to #haskell, I should've read more closely...
02:32:02 <MaskRay> FUZxxl: Do you mean EclipseFP?
02:32:11 <FUZxxl> yes.
02:32:12 <msieradzki> I have just discovered that haskellmode for vim works quite well
02:32:15 <FUZxxl> MaskRay: Yes.
02:32:31 <msieradzki> as in really, really well, far better than I thought it would after last time I misconfigured it and gave up
02:34:04 <rostayob> msieradzki: does it have decent indentation support (decent == emacs haskell mode_
02:34:30 <msieradzki> not that I have noticed
02:34:46 <msieradzki> but it's not like I noticed anything earlier
02:35:10 <rostayob> msieradzki: mhm?
02:35:15 <msieradzki> it might be that preferred way is to just set tab to 2 and expand and do it manually, and yes I saw how it works in emacs
02:35:36 <MaskRay> the indent cycle functionality is indispensable, at least for me.
02:35:42 <rostayob> MaskRay: same
02:36:14 <msieradzki> I bastardized haskell syntax to use tabs everywhere in 1 uniform and ugly way but it kind of works ;)
02:36:18 <rostayob> I've tried vim mode and it seems to be better in some aspects, but the indentation in emacs is too good
02:36:46 <msieradzki> to get emacs quality indentation I'd need to switch to emacs which isn't the best thing in my opinion ;)
02:37:35 <rostayob> msieradzki: emacs is great
02:37:47 <rostayob> well I mean vim is good as well
02:38:11 <Phyx-> ~/quit
02:48:06 <FUZxxl> rostayob: Did you know, that emacs can emulate vi? (viper mode)
02:54:19 <Peaker> @type \x y -> First <$> x <|> Right <$> y
02:54:20 <lambdabot>     Couldn't match expected type `First a'
02:54:20 <lambdabot>            against inferred type `Either a1 a2'
02:54:21 <lambdabot>     In the first argument of `(<$>)', namely `Right'
02:54:30 <Peaker> @type \x y -> Left <$> x <|> Right <$> y
02:54:31 <lambdabot> forall a b (f :: * -> *). (Alternative f) => f a -> f b -> f (Either a b)
02:54:49 <erus`> > 134849 * 50
02:54:50 <lambdabot>   6742450
02:55:06 <shachaf> Peaker: Subtle protest against the LTR assumptions of Haskell? :-)
02:55:17 <erus`> > 6742450 / 40000
02:55:18 <lambdabot>   168.56125
03:02:54 <Peaker> shachaf: My first brainfart you mean? :)
03:03:14 <cizra2> Haskell good style question: I have a case-of expression pattern-matching on Either Left or Right inside a do-block. How do I assign the Left and Right branches to different variable names, so that they'd be visible in the do-block outside case?
03:04:24 <luite> what would the value for the right branch be if you got a Left?
03:04:30 <fabjan> how can you assign both of them when only one will be available?
03:04:36 <Saizan> you can "do x <- case foo of Left y -> y; Right y -> y; ..." if they are the same type
03:05:10 <Saizan> s/-> y/-> return y/g
03:05:14 <ion> :t either
03:05:15 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
03:05:20 <fabjan> but you cannot assign both of the cases to any variable to use outside of the case
03:06:13 <Saizan> another option is to just put the stuff that has to deal with the contents inside the case
03:06:13 <cizra2> Er..
03:06:24 <luite> well you could use to Maybe's.. but I doubt that
03:06:33 <luite> s any better than an Either :)
03:06:36 <Saizan> cizra2: do you have some code?
03:06:40 <luite> two*
03:06:45 <cizra2> Actually yes, but I'd prefer explaining
03:06:50 <cizra2> I'm building a parser.
03:07:01 <cizra2> There can be either an import-block or an export-block in this particular context.
03:07:27 <cizra2> So, using quicksilver's neat trick, I convert it into Either Left import or Right export.
03:07:40 <cizra2> Correction: there are _both_ import and export blocks, but in unspecified order.
03:08:04 <cizra2> Meh. I can just specify the order and have no problems.
03:08:12 <cizra2> Please disregard the question (=
03:08:27 <cizra2> I'll just change my grammar instead.
03:09:09 <Saizan> ?type \x y -> liftM2 (,) x y <|> liftM2 (flip (,)) x y
03:09:10 <lambdabot> forall a1 (f :: * -> *). (Monad f, Alternative f) => f a1 -> f a1 -> f (a1, a1)
03:09:20 <Saizan> ?type \x y -> liftM2 (,) x y <|> liftM2 (flip (,)) y x -- i meant this
03:09:20 <lambdabot> forall a1 a2 (f :: * -> *). (Monad f, Alternative f) => f a1 -> f a2 -> f (a1, a2)
03:53:22 <ciaranm> are sections called sections because of sections in category theory? if so, i can't quite figure out how they relate
03:56:55 <Saizan> i don't think so
03:58:17 <quicksilver> I think it was a general usage in some parts of algebraic maths before haskell adopted the term
03:58:20 <quicksilver> I'm not sure though
03:59:38 <ciaranm> i've seen it used in set theory and topology, but in both cases it's just a specific form of the category theory concept
03:59:42 <Eduard_Munteanu> Sections and retractions? I'm pretty sure I've seen those discussed in algebra.
04:00:26 <ciaranm> yeah, but i can't see how what they mean in algebra relates to what haskell has
04:01:04 <ciaranm> to me sections and retractions are just right and left inverses
04:01:41 <HugoDaniel> is there something like "the best haskell wiki software of them all" ?
04:01:51 <HugoDaniel> im looking at gitit
04:01:57 <HugoDaniel> seems to be great
04:02:04 <Saizan> are there others?
04:02:40 <HugoDaniel> i dont know :)
04:05:06 <aavogt> @hackage orchid
04:05:07 <lambdabot> http://hackage.haskell.org/package/orchid
04:45:57 <lebastr> Hi! How can I distinguish between the directory and symbolic link on the directory?
04:46:19 <Jafet> @hoogle SymbolicLink
04:46:19 <lambdabot> No results found
04:46:46 <Jafet> @index isSymbolicLink
04:46:46 <lambdabot> System.Posix.Files, System.Posix
04:48:01 <lebastr> Jafet: Thanks!
04:48:39 * hackagebot seclib 0.6 - A lightweight library for Information-flow security in Haskell  http://hackage.haskell.org/package/seclib-0.6 (AlejandroRusso)
05:15:14 <Younder> I am having trouble with foldr performance: Is there a better way?
05:15:57 <opqdonut> what are you trying to do?
05:16:00 <Eduard_Munteanu> Depending on what you're using it for, maybe foldr isn't the right thing.
05:16:18 <opqdonut> foldl' is nice if you're producing only a small bit of data from a large list
05:16:25 <Younder> My thought exactly.
05:16:50 <opqdonut> foldr is nice if your combining operation works well lazily
05:17:19 <Younder> Ahh it's the monad.
05:18:25 <opqdonut> ?
05:18:58 <Younder> There is a print in there which is slowing everything down.
05:19:15 <Younder> I removed it and now it is OK.
05:19:42 * hackagebot digestive-functors-blaze 0.1.0.1 - Blaze frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-blaze-0.1.0.1 (JasperVanDerJeugt)
05:20:32 <Eduard_Munteanu> I wonder what funky CT stuff that is ^ :)
05:20:53 <edwardk> Eduard_Munteanu: ? the digestive stuff?
05:20:57 <Eduard_Munteanu> Yeah :)
05:21:12 <edwardk> its not category theoretic at all
05:21:29 <Eduard_Munteanu> Sounds medical.
05:21:29 <Younder> Well Haskell isn't known for it's great debugger..
05:21:50 <edwardk> it is stuff for manipulating html forms =)
05:22:13 <Eduard_Munteanu> Ah. So I guess it's related to "digests" or something like that?
05:22:21 <edwardk> younder: sure it is, it gives you enough tools that you can decompose your program into small enough pieces that you never even need the debugger ;)
05:22:25 <Younder> What I was working on was a pattern matching engine
05:22:25 <edwardk> yeah
05:22:55 <Younder> edwardk, which incidentally is very hard to test in small pieces
05:23:35 <Eduard_Munteanu> Younder: do you know about Debug.Trace?
05:23:43 <Younder> yes
05:23:44 <Eduard_Munteanu> @hoogle trace
05:23:44 <lambdabot> Debug.Trace trace :: String -> a -> a
05:23:44 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
05:23:44 <lambdabot> module Debug.Trace
05:23:46 <Eduard_Munteanu> Ah.
05:24:41 <Younder> But it slows things  down too much to be practical. I have to test 100 000 generated patterns in my test.
05:24:53 <Younder> Hence the print
05:26:18 <Younder> I think I will go with Haskabelle and Isabelle and do a program verification.
05:30:45 <Younder> Actually I have diarrhoea so I would refrain from jokes about my digestive juices.
05:31:07 * Younder is no lnger full of s***
05:37:35 <bgamari> Is there any way to fetch a subset of a Data.Array.IArray?
05:38:05 <bgamari> i.e. return an array with elements ix1..ix2
05:42:38 <Botje> bgamari: create a new one
05:43:40 <bgamari> Botje: Hmmm, there's no way to get a view on the same data just starting at an offset?
05:44:20 <Botje> array (ix1,ix2) $ [ (i, old_array ! i) | i <- range (ix1, ix2) ] -- or something like it
05:44:54 <Younder> ugh
05:45:00 <bgamari> ugh
05:45:03 <bgamari> Fair enough
05:45:15 <bgamari> It looks like Data.Vector can do this
05:45:21 <bgamari> perhaps it would be a better choice
05:45:52 <Younder> A functional programming array makes no sense
05:46:08 <Eduard_Munteanu> I think you can use ixmap too.
05:46:12 <Eduard_Munteanu> :t ixmap
05:46:12 <lambdabot> forall i j e. (Ix i, Ix j) => (i, i) -> (i -> j) -> Array j e -> Array i e
05:46:19 <Younder> You have to copy it each time you alter it
05:46:29 <bgamari> Younder: It's immutable
05:46:39 <bgamari> Younder: I have no need to modify it
05:46:54 <bgamari> Younder: I just need different views of it and it should be unboxed
05:47:11 <Botje> Younder: functional arrays + laziness = dynamic programming made easy
05:47:22 <Younder> ok, shoudn't be a problem
05:47:35 <bgamari> Eduard_Munteanu: I don't think ixmap allows you to drop elements
05:47:38 <Eduard_Munteanu> In fact ixmap might make it share.
05:47:56 <wli> luite: You there?
05:48:14 <luite> wli: yes
05:48:30 <wli> luite: Did you say you had a convex programming lib floating around?
05:49:13 <wli> luite: (In principle, I'm not sure my problem's convex, but it is quadratic.)
05:49:17 <bgamari> Eduard_Munteanu: eh?
05:49:36 <luite> wli: no lib, sorry. Just a solver for my own problem (which isn't convex, but quasiconvex)
05:50:16 <Eduard_Munteanu> > elems . ixmap (0, 1) id . listArray (0, 2) $ [1, 2, 3]
05:50:19 <lambdabot>   [1,2]
05:50:28 <Eduard_Munteanu> > elems . ixmap (0, 2) id . listArray (0, 2) $ [1, 2, 3]
05:50:30 <lambdabot>   [1,2,3]
05:50:42 <wli> luite: I'm basically trying to do Remez garbage, which I'm not sure how it fits into things. My use of linear programming thus far isn't working out too well wrt. convergence.
05:51:06 <Eduard_Munteanu> bgamari: I mean it might share the underlying array, mapping just indices
05:51:13 <Eduard_Munteanu> (instead of copying it)
06:28:17 <quicksilver> yes, it's an annoying defect of the core arrays that they can't do zero-copy slicing
06:28:17 <wli> luite: Part of what goes wrong is that extremizing the deviations isn't working.
06:28:29 <quicksilver> IIRC one of the vector packages can
06:28:32 <bgamari> quicksilver: Yep
06:28:36 <bgamari> Data.Vector it seems
06:28:37 <Eduard_Munteanu> quicksilver: oh so they're not sharing after all
06:28:47 * hackagebot llvm-extra 0.2.0.1 - Utility functions for the llvm interface  http://hackage.haskell.org/package/llvm-extra-0.2.0.1 (HenningThielemann)
06:28:52 <quicksilver> Eduard_Munteanu: well the unboxed ones are sharing the values, of course
06:28:53 * Eduard_Munteanu hasn't looked at how ixmap and that stuff is implemented
06:29:07 <quicksilver> Eduard_Munteanu: but the 'spine' of the array - which is the actual array object - is never shared.
06:29:25 <Eduard_Munteanu> Oh, sure. But that's O(1), no?
06:29:32 <Eduard_Munteanu> space-wise
06:30:23 <Eduard_Munteanu> Still, I get the point, it's not totally zero copy.
06:33:33 <weltensegler> Hello. What is the best way to check whether a system of inequalities has a solution. I don't need the solution, i just need to know whether one exists.
06:33:54 <companion_cube> a smt solver :)
06:33:55 <quicksilver> Eduard_Munteanu: no, it's O(n) space and time.
06:34:11 <wli> weltensegler: What kind of inequalities?
06:34:12 <quicksilver> Eduard_Munteanu: an array of 10,000 items has an 80,000 byte spine.
06:34:22 <Eduard_Munteanu> quicksilver: even the unboxed ones?
06:34:25 <weltensegler> sorry, linear inequalities.
06:34:36 <wli> weltensegler: Fourier-Motzkin elimination.
06:34:51 <quicksilver> Eduard_Munteanu: hmm, 5 minutes ago when I said "the unboxed ones are sharing the valuse of course"
06:34:53 <Jafet> What's the spine of an unboxed array?
06:35:05 <quicksilver> Eduard_Munteanu: I actually mean "the *boxed* ones are sharing the values of course"
06:35:08 <quicksilver> ;)
06:35:10 <Eduard_Munteanu> Jafet: I suspect it contains the bounds and that sort of stuff
06:35:16 <Eduard_Munteanu> o
06:35:19 <Eduard_Munteanu> Oh.
06:35:29 <Eduard_Munteanu> Yeah, trivially so.
06:36:05 <quicksilver> words and their oppposites. So easy to mistype.
06:36:40 <luite> wli: hmm, I don't really know much about that algorithm. my own thing is rather specific, it's a function defined as the maximum of a lot of convex differentiable functions. it computes the gradient of those at a point, then uses linear programming to find the direction to move to that gives the best improvement, within the allowed region, according to the linearization of those functions
06:36:51 <Eduard_Munteanu> I thought an unboxed array would store bounds, a pointer to a storage area and that stuff, so it could share the underlying store.
06:36:56 <weltensegler> wli: Thanks, that's what i was looking for!
06:37:28 <wli> luite: That's a lot like what Remez does, except there's another maximization hidden in there.
06:37:48 <luite> wli: and since the real functions are not linear, it must search along this line to find the real minimum (where it can use convexity)
06:38:08 <luite> and then it repeats of course :)
06:38:28 <Jafet> Well, I don't think Array should have slicing and all that stuff.
06:38:37 <Eduard_Munteanu> (that is, not having the elements inlined into the actual array struct)
06:38:52 <Jafet> It's not trivial to do and it belongs outside base.
06:39:10 <Eduard_Munteanu> Yeah, Vector is nice for other reasons anyway, too.
06:39:10 <Jafet> Oh, Array is from array.
06:39:13 <quicksilver> Eduard_Munteanu: I agree. That's a sensible idea. And it should.
06:39:29 <quicksilver> Eduard_Munteanu: it's hard to do it without imposing an overhead on the simple case.
06:39:34 <quicksilver> however, Array is not exactly fast :P
06:39:44 <quicksilver> so I can't believe zero-copy slicing would have been an issue.
06:39:45 <Jafet> What's faster than Array?
06:40:00 <quicksilver> furthermore the whole "Ix" typeclass business really looks like it was designed with slicing in mind
06:40:10 <quicksilver> ...but the last step wasn't taken.
06:40:20 <Eduard_Munteanu> Unsafe indexing + ABC elimination would be faster :)
06:40:30 <quicksilver> you already have a custom translation between your 'Ix' type and the underlying index
06:40:39 <quicksilver> why not allow that custom translation to be altered.
06:40:48 <quicksilver> Jafet: some of the new vector libraries.
06:40:57 <quicksilver> Jafet: even bytestring is faster than Array for particular uses.
06:42:08 <Eduard_Munteanu> (e.g. (faked?) dependent types)
06:43:06 <Jafet> ByteString and Array both use Storable and pretty much the same underlying operations, though
06:43:34 <Jafet> Unless you disqualify code that uses unsafeIndex and the like
06:44:02 <quicksilver> Jafet: these things you say, they are not true!
06:44:12 <quicksilver> Jafet: neithe ByteString nor Array uses Storable.
06:44:24 <quicksilver> ByteString uses Ptr-type operations onto a ForeignPtr.
06:44:38 <quicksilver> Array use some native GHC magic to a primitive type
06:44:49 <quicksilver> (Array#? ByteArray#? I can't remember)
06:44:56 <opqdonut> quicksilver: what would you recommend instead of UArray Word8 for storing bit data?
06:45:23 <quicksilver> opqdonut: I'd remember digging out don's old blog article and reading it, because I can never remember. I think Data.Vector might be the fastest?
06:46:20 <Jafet> Hm, what used Storable then
06:46:46 <quicksilver> StorableArray?
06:47:07 <quicksilver> Data.Array.Storable.
06:47:26 <quicksilver> also storablevector (hackage)
06:47:40 <quicksilver> but the main focus of storable is storing types in accordance with the C API.
06:47:42 <quicksilver> ABI.
07:12:01 * hackagebot hlint 1.8.13 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.13 (NeilMitchell)
07:15:22 <badboy608> hi
07:30:37 <HugoDaniel> are there any cases where a datatype like: data MyData a = MyData ....  is not a monad ?
07:30:57 <HugoDaniel> besides the typical case "im too lazy to write a bind function"
07:31:11 <Jafet> Which monad?
07:31:24 <Saizan> data MyData a = MyData (a -> a) ?
07:31:40 <HugoDaniel> yes, with functions, sorry
07:32:01 <HugoDaniel> but even without functions
07:32:24 <Saizan> i meant that data MyData a = MyData (a -> a) is not a Monad
07:33:41 <HugoDaniel> oh :)
07:34:47 <benmachine> it's not even a Functor :O
07:34:53 <quicksilver> data MyData a = MyData (IORef a) is also not a functor, nor monad.
07:35:22 <Tomsik> oh u, a -> a is both covariant and contravariant at the same time
07:35:22 <quicksilver> finding examples which are functor but not monad is a little harder.
07:35:50 <Tomsik> There was this example I once sought, a functor that applicative is not
07:36:06 <Tomsik> (Map k) a
07:36:11 <benmachine> (,) w is a Functor but not Monad, if you don't have any constraints on w
07:36:15 <Tomsik> As you cannot pure write
07:36:25 <benmachine> ah, that's also a good example
07:36:37 * benmachine wonders if Monoid k => Map k is Applicative
07:36:41 <Tomsik> It's basically the same
07:36:44 <Saizan> the Store comonad
07:36:54 <Tomsik> benmachine: I think so, you've got mempty then
07:36:58 <Tomsik> though who knows
07:37:18 <benmachine> I'll work it out when I'm not doing more important stuff ;P
07:37:24 <benmachine> *:P
07:42:17 * Saizan wonders what's the important stuff benmachine is doing
07:42:22 <dicey> good morning, lovely haskellites
07:42:34 <lunaris> 15:42 here, but hello :)
07:47:34 <fxr`> dicey: good morning
07:50:01 <djahandarie> ( lunaris, http://www.total-knowledge.com/~ilya/mips/ugt.html )
07:52:04 <lunaris> And once again I've made an ass of myself.
07:52:12 * lunaris goes back to admiring the morning sun.
07:54:34 <ski> HugoDaniel,quicksilver,Tomsik : `CoYoneda IORef'
07:55:15 <quicksilver> ski: really?
07:55:31 <ski> `CoYoneda f' is always a functor
07:55:39 <Tomsik> I never got around the Yoneda stuff
07:56:25 <Tomsik> What is it really and why co-?
07:56:26 <quicksilver> I understood it enoguh to pass my exams.
07:56:36 <quicksilver> which means, I could write proofs involving it but never really grokked it.
07:56:48 <ski>   data CoYoneda f b = forall a. FmapIncl (a -> b) (f a)
07:57:27 <Tomsik> It's turtles all the way down I see
07:57:32 <Tomsik> What's FmapIncl?
07:57:37 <quicksilver> just a constructor name
07:57:40 <ski> the name of the sata constructor
07:57:51 <ski> so a `CoYoneda IORef b' contains an `IORef a', and a function of type `a -> b'
07:57:52 <Tomsik> Yeah, but what is it supposed to mean?
07:58:08 <quicksilver> for some unknown a.
07:58:10 <Tomsik> So it's basically that Store thing?
07:58:23 <quicksilver> and you can make it a functor by post composition on the function part
07:58:31 <ski> i.e. `CoYoneda IORef' might be called `IOReadRef', since it's effectively read-only
07:58:38 <lunaris> I read it as an IORef with some internal representation.
07:59:14 <ski> Tomsik : probably there's some connection with `Store' .. but it's not exactly `Store', no
07:59:34 <Tomsik> because of the existential type?
07:59:51 <ski> well, that. and the `f' part
08:00:01 <Tomsik> okay
08:00:10 <ezyang> It seems that Hughe's insistence on as minimal a set of primitive combinators may be partially causing Yampa's performance problems.
08:00:34 <ski> you could make an `CoYonedaOp' (not sure about naming, yet), such that a `CoYonedaOp IORef' is basically `IOWriteRef'
08:01:58 <ski> Tomsik : re, `FmapIncl', `FmapIncl :: (a -> b) -> (f a -> CoYoneda f b)', so basically `FmapIncl = fmap . incl', where `incl :: f a -> CoYoneda f a'
08:02:32 <ski> (well, s/./.:/, i suppose)
08:04:03 * edwardk waves hello.
08:04:08 <ski> it's also possible to do `CoYoneda (CoYoneda f) a -> CoYoneda f a' and `(forall a. f a -> g a) -> (forall a. CoYoneda f a -> CoYoneda f b)'
08:04:15 <ski> hiya edwardk :)
08:04:17 <Tomsik> What does Yoneda look like then?
08:04:40 <edwardk> newtype Yoneda f a = Yoneda { runYoneda :: forall r. (a -> r) -> f r }
08:04:44 <HugoDaniel> thats too much for me
08:04:47 <ski>   newtype Yoneda f a = ProjPamf (forall b. (a -> b) -> f b)
08:04:55 <HugoDaniel> im actually more of a Java guy
08:05:02 <ski> (or something like that)
08:05:03 <Tomsik> Doesn't look too useful
08:05:14 <edwardk> tomsik: it actually is. it does fmap fusion!
08:05:19 <Tomsik> I mean, forall b . f b
08:05:29 <yrlnry> What does fmap fusion look like?
08:05:37 <edwardk> also Yoneda f is a functor even if f isn't
08:05:41 <ski> yrlnry : `fmap g . fmap f = fmap (g . f)'
08:06:06 <yrlnry> Oh, because you can compute the fused fmap by composing the Yoneda mappings.
08:06:07 <yrlnry> Thanks.
08:06:08 <edwardk> yrlnry: so if you fromYoneda . fmap f . fmap g . toYoneda  — it does the same as fromYoneda . fmap (f . g) . toYoneda
08:06:11 <ski> edwardk : Tomsik wondered whether there was any connection between `CoYoneda' and `Store' .. know anything interesting ?
08:06:21 <yrlnry> Where can I ream more about that?
08:06:34 <yrlnry> s/ream/read/
08:06:53 * ski . o O ( s/ream/scream/ )
08:06:54 <edwardk> there is a connection to indexed store. honestly there is a closer connection between Density and Store.
08:07:22 <edwardk> yrlnry: its something i've rambled on about here but i don't think its ever been written up
08:07:41 <yrlnry> Okay, thanks.
08:07:48 <edwardk> Density f a = exists r. Store (f r) a
08:07:58 <Tomsik> isn't fmap f . fmap g = fmap (f . g) a functor law?
08:08:08 <Tomsik> Why'd you need something else to do that?
08:08:16 <edwardk> tomsik: it is, but enforcing the fusion is really convenient because it can avoid multiple traversals
08:08:27 <edwardk> so while the result is pointwise the same, the execution path is different
08:09:36 <edwardk> tomsik: say you have a bunch of code that evaluates out to an fmap f, and another bunch of code that evaluates out to fmap g. and you apply them in succession. if you apply them to something in Yoneda form, then they'll fuse, otherwise you may construct a whole new Map just to tear it down and build a third, for instance.
08:09:45 <ski> yrlnry : if you look at <http://hpaste.org/1676>, you'll see bad way of ensuring a type (`IOElem') is a functor
08:09:58 <edwardk> also, Yoneda is useful even when f is not a functor.
08:10:05 <yrlnry> ski:  Thanks!
08:10:33 <edwardk> my recent blog posts on free monads for less used Yoneda applied to newtype Rec f a = Rec ((f a -> a) -> a)
08:10:37 <edwardk> which is clearly not a functor!
08:10:38 <Tomsik> Ah, so it's to force it to fuse?
08:10:40 <edwardk> yep
08:10:49 <erus`> is there a state mvar that is resistant to power outs
08:10:55 <erus`> like it will log everything it does
08:11:12 <edwardk> another good example of something you can apply Yoneda to that isn't a functor, and yet obtain a Functor is Endo
08:11:25 <edwardk> Yoneda Endo a ~ forall r. (a -> r) -> r -> r — which is a cps encoded Maybe.
08:11:44 <ski> yrlnry : it's bda because of two things (a) `IOElem' is *not* a functor, (using `fmap = Fmap'), since e.g. `Fmap id GetChar' and `GetChar' can be distinguished. this can be fixed if you export the type abstractly (so conceptually, we make a quotient type)
08:11:45 <edwardk> Codensity Endo a ~ forall r. (a -> r -> r) -> r -> r is a cps encoded list
08:12:01 <ski> yrlnry : the other reason is (b) that it is inefficient, no automatic fusion
08:12:47 <edwardk> tomsik: codensity does the same thing as yoneda (fusing fmaps) while also right associating all binds on the monad.
08:13:16 <ski> edwardk : hm .. `forall a. Yoneda f a  ~=  [a]', what could `f' be ?
08:13:31 <edwardk> [] =)
08:13:43 <ski> yeah .. obviously :)
08:13:47 <Tomsik> "Right associating all binds"? Wha? Is that somehow important?
08:13:49 <ski> but anything more interesting ?
08:14:15 <edwardk> tomsik: yeah, see my free monads for less post. where it talks about free monads, and how left associated binds are more expensive
08:14:31 <edwardk> tomsik: (for free monads, not _necessarily_ in general)
08:14:54 <ezyang> (for example, see the IVar monad :-)
08:14:59 <quicksilver> I think there is somethign very weird about semantic abstractions having desirable operational effects
08:15:02 <ski> Tomsik : as `CoYoneda f' (and `Yoneda f') is always a functor, `CoDensity f' is always a monad
08:15:10 <Tomsik> Heh, I seem never to find enough motivation to read all this stuff, even though it's interesting
08:15:12 <edwardk> ski: nah, can't be anything more interesting i think. the list is recursive so the trick used to make Yoneda Endo into Maybe doesn't apply
08:16:02 <edwardk> tomsik: i just use it to make code run fast
08:17:14 <dylukes> Hey, one quick question.
08:17:16 <edwardk> ski: if you can deconstruct [a] into an adjunction, then you might have something nicer
08:17:20 <dylukes> How would you guys recommend learning scheme?
08:17:23 <dylukes> And, with which dialect?
08:17:45 <dylukes> I'm noticing some differences (i.e define-macro vs define-syntax w/ rsc-macro-transform)
08:18:30 <Tomsik> edwardk: does that kind of tricks work?
08:18:51 <Tomsik> I always thought that this stuff is for amusement
08:20:03 <yrlnry> ski:  Does your Haskell setup understand "»=" as a synonym for ">>=", or is that just a typographical transform applied in the pasting process?
08:20:16 <develhevel> when i want to build a docu. with leksah and haddock i get: "Warning: No documentation was generated as this package does not contain a
08:20:16 <develhevel> library. Perhaps you want to use the --executables flag." but where to set in in leksah?
08:20:39 <dylukes> .___.
08:20:40 <dylukes> Error: No such file or directory - /usr/bin/cc
08:20:44 <dylukes> awwww shit.
08:20:56 <ski> yrlnry : i use `~=' as meta-notation for "isomorphic to"
08:21:36 <yrlnry> ski: http://hpaste.org/1676 contains "»=".
08:21:46 <ski> yrlnry : oh, hm .. right, i just got that you meant the paste
08:21:49 <ski> it's not my paste
08:21:52 <yrlnry> OK
08:22:05 <ski> something that chrisdone dug up -- no idea who's pasted it
08:22:35 <yrlnry> It's probably a trick.  If it were any good, -> would be replaced with →.
08:22:42 <ski> (also, it's not even type-correct, from what i can see (i've not tried to run it))
08:22:44 <parcs> yrlnry: »= is in the base-unicode-symbols package on hackage
08:22:49 <yrlnry> Thanks.
08:24:12 <yrlnry> parcs:  yeah, that's pretty much what I was imagining when I saw that -> was still ->.   You can play tricks to make >>= look lik »=, but tricks won't turn -> into →.
08:24:39 * djahandarie advises against using unicode in Haskell code entirely
08:25:15 <hpc> you can get away with using different alphabets, sometimes
08:25:19 <yrlnry> why?
08:25:49 <hpc> yrlnry: not all fonts can render unicode, and it messes with the programmer's expectations of symbol widths (important in monospace fonts)
08:25:52 <hpc> > π
08:25:53 <lambdabot>   Not in scope: `
08:26:01 <djahandarie> Because I value typing cost over reading cost.
08:26:02 <hpc> @let π = pi
08:26:04 <lambdabot>  Defined.
08:26:07 <hpc> >
08:26:10 <hpc> > π
08:26:11 <djahandarie> (And I also have trouble with remembering new symbols.)
08:26:12 <lambdabot>   3.141592653589793
08:26:30 <parcs> yrlnry: → and whatnot is valid syntax with the UnicodeSymbols language extension
08:26:38 <yrlnry> Okay.
08:27:02 * Jafet kicks monospace fonts.
08:27:25 <djahandarie> With ASCII symbols, I immediately know how to type something when I read it. This is not so with unicode. I prefer sticking in the realm that I've been indocrinated into already.
08:27:43 <copumpkin> Tomsik: yeah, it works
08:28:13 <ski> dylukes : `define-syntax' and `rsc-macro-transform' are not comparable to each other
08:28:20 <dylukes> ski: No no, I mean,
08:28:32 <dylukes> in mit-scheme its possible to "reproduce" define-macro using define-syntax AND rsc-macro-transformer
08:28:40 <dylukes> http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme-Z-H-20.html#node_sec_A.3
08:28:46 <dylukes> as it says here…
08:28:57 <dylukes> anyhow, I'm noticing some dialect differences, and wondering what the right course of action is.
08:29:06 <ezyang> djahandarie: Copypaste!
08:29:12 <erus`> is there a tutorial for getopt?
08:29:19 <erus`> the docs are confusing
08:29:25 <lunaris> ezyang: It's all about Vim digraphs :)
08:29:57 <HalfWayMan> Quick question: What is a good parser library for Data.Text? I'd use attoparsec-text, but I need position information such as that yielded by getPosition from Parsec.
08:29:58 <ski> dylukes : afaik, pick some implementation, and stick with it for a while
08:32:18 <byorgey> djahandarie: TeX input mode!
08:32:33 <parcs> XCompose! :)
08:32:50 <quicksilver> the problem is not the input method.
08:32:54 <Saizan> HalfWayMan: you can use parsec if you write the Stream instance
08:33:00 <quicksilver> the problem is that on reading something you cannot uniquely identify the glyph being used.
08:33:25 <quicksilver> many unicode characters are extremely similar - and if you're reading in a different typeface, it's even worse.
08:33:30 <byorgey> quicksilver: indeed, I was just teasing djahandarie.
08:33:38 * byorgey does not use unicode symbols in Haskell code either.
08:33:44 * djahandarie beats up byorgey
08:33:49 <dolio> How do you type the null character?
08:33:51 <byorgey> ouch ow dang
08:33:53 <parcs> true. hell, even → and ← look almost identical on my font
08:33:57 <quicksilver> dolio: ^Q^@
08:34:00 <dolio> Or form feed?
08:34:00 <quicksilver> dolio: how do you type it? :)
08:34:12 <byorgey> parcs: they look exactly identical in my font.  They both look like ? . ;)
08:34:12 * hackagebot language-c-quote 0.3.0.0 - C/CUDA quasiquoting library.  http://hackage.haskell.org/package/language-c-quote-0.3.0.0 (GeoffreyMainland)
08:34:15 <ski> dolio : `C-q C-l', in emacs ..
08:34:31 * ski uses form feed relatively often, in Haskell source
08:34:36 * Saizan uses C-u C-c = to identify the character
08:34:39 <dolio> Totally.
08:34:42 * byorgey types the null character :: Char
08:35:24 <ski> (dolio : .. why ?)
08:35:50 <dolio> Someone above claimed that they immediately knew how to type every ascii character.
08:36:03 <HalfWayMan> Saizan: Looks like that may be the way to go. Cheers :)
08:36:26 <Cadynum> is there some non-deprecated library/function which works like getClockTime from old-time? specifically returning the current time as an int or integer
08:37:58 <djahandarie> dolio, okay, okay, I meant the subset of ASCII on my keyboard. :p
08:38:11 <arcatan> Cadynum: fromEnum <$> getPOSIXTime
08:39:10 <arcatan> hmm, no, that isn't right
08:40:50 <arcatan> round <$> getPOSIXTime
08:41:02 <Cadynum> it looks like that uses floating precision
08:41:04 <arcatan> i wonder what it is that fromEnum <$> getPOSIXTime is returning?
08:42:42 <roconnor> Is every non-zero element of the field F_p^q a generator?
08:43:42 <Jafet> Only phi(p^q) of them, naturally
08:43:53 <Jafet> Or was it phi.phi $ p^q?
08:44:23 <edwardk> tomsik: was afk, what kind of trick?
08:44:50 <edwardk> tomsik: oh using all this stuff for speed. yes it does.
08:44:51 <roconnor> Jafet: this isn't mod p^q, this is (F_p^q) = (F_p)^q
08:45:12 <edwardk> tomsik: codensity for instance happens to have very nice properties with regards to how it manipulates the stack
08:45:17 <roconnor> does euler's theorem still apply?
08:45:33 <Jafet> Oh
08:45:38 <Jafet> (What's (F_p)^q?)
08:46:21 <roconnor> the field with p^q number of elements which happens to be a q dimensional vector space over F_p
08:46:32 <HugoDaniel> do you guys use ghci with -Wall ?
08:46:52 <parcs> Cadynum: you can go the other way and convert Ints to POSIXTimes and work with their Num instance
08:47:02 <arcatan> Cadynum: getPOSIXTime is internally represented as fixed-precision picoseconds
08:47:13 <arcatan> Cadynum: and round rounds them to seconds
08:47:35 <byorgey> HugoDaniel: I don't usually use ghci with -Wall, but I compile with -Wall
08:47:35 <arcatan> with getPOSIXTime I mean POSIXTime, obviously
08:48:16 <HugoDaniel> oh hmm
08:48:39 <HugoDaniel> im forcing myself to use ghci with -Wall, but its boring most of the time with all the warnings messing up the output
08:49:03 <HugoDaniel> yeah, ill postpone -Wall to compile time
08:49:04 <dicey> what does -Wall do?
08:49:23 <Cadynum> arcatan, i see
08:49:47 <Saizan> turns on a lot of compiler warnings
08:49:51 <geheimdienst> dicey, -Wall (read as -W all) tells the compiler to output all warnings
08:50:01 <dicey> lmao
08:50:10 <dicey> why oh whyu would you do that? proving things, perhaps?
08:50:36 <Saizan> i.e. stuff that's not an error but it's bad style or might be a sign of a bug
08:50:54 <dicey> so it could help you debug
08:50:59 <Jafet> Ah, the mathematica/matlab programmer learns about style
08:51:30 <HugoDaniel> dicey: well, sometimes its nice to be sure everything is completly ok according to the compiler
08:51:37 <byorgey> dicey: it doesn't really help you debug, but it can help prevent some simple bugs in the first place.
08:51:38 <geheimdienst> a compiler warning usually tells you that the code runs, but probably will do something other than what you intended. i usually compile with -Wall, i find it helpful
08:52:15 <Tomsik> Codensity cps-encodes free monads?
08:52:19 <HugoDaniel> yes, in haskell sometimes it means avoiding nasty real-time bugs, because of a missing match
08:52:30 <dicey> seems reasonable
08:52:40 <byorgey> Tomsik: yes, something like that
08:52:41 <HugoDaniel> s/real-time/run-time
08:52:42 <dicey> just more information about your code
08:52:46 <ziman> -Wall will help find obvious (albeit compilable) gotchas in the code and polish the style
08:53:01 <HugoDaniel> dicey: have you tried hlint ?
08:53:05 <arcatan> hey, what is this, toEnum . fromEnum :: POSIXTime -> POSIXTime is broken again
08:53:35 <dicey> nope. im pretty much a noob, still building up a library of basic functions to fiddle with
08:53:39 <Jafet> Is the result in the range of Int?
08:53:39 <Tomsik> Hm, cool stuff. I haven't thought this can do as much
08:53:41 <Jafet> :t fromEnum
08:53:42 <lambdabot> forall a. (Enum a) => a -> Int
08:54:00 <byorgey> Tomsik: were you reading edwardk's recent series of blog posts about it?
08:54:11 <HugoDaniel> try to run hlint on your haskell code, its a great tool to help you out with simplifications and other entanglements
08:54:40 <Tomsik> byorgey: seen yes, actually, carefully read no
08:54:51 <Tomsik> but looks like I'll have to do that
08:55:29 <dicey> so far im just trying to keep my functions as small and separate as possible, and working in all cases so they can all itneract flawlessly. seems thats the key to being able to write larger programs...writing them in terms of a bunch of smaller programs thet you know are guaranteed to work
08:55:30 <geheimdienst> HugoDaniel: entanglements, eh? :)
08:55:45 <byorgey> Tomsik: the paper by Janis Voigtlaender that edwardk references is also a nice starting place
08:56:09 <arcatan> Jafet: yes, yes it is. for me fromEnum <$> getPOSIXTime gives hundred time bigger answer than it should
08:56:15 <geheimdienst> dicey: good approach, keep it up
08:56:40 <Jafet> No idea then, other than “so yes, time is screwed up”
08:56:59 <geheimdienst> :t POSIXTime
08:57:00 <lambdabot> Not in scope: data constructor `POSIXTime'
08:57:43 <arcatan> i emailed about the problem a while ago to the maintainer and i thought it was already fixed at some point, but maybe i'm wrong
08:59:20 <geheimdienst> hm ... in the time handling, there's some types that are aliases for a fixed-point integer with like 8 decimal places. is POSIXTime one of those guys? the enum instances increment it by 1 microsecond or something
08:59:25 <geheimdienst> it's confusing for sure
08:59:54 <dicey> its not a type at all, is it?
09:02:21 <dicey> you'd have to separate via pattern matching and then use a function to give the specific piece of data a type?
09:02:50 <dicey> i still find the whole "data" thing in haskell pretty confusing.
09:02:55 <telephone> With Parsec, is it possible to check if a parser consumed input?
09:06:33 <edwardk> telephone: you can play games with try
09:06:51 <roconnor> geheimdienst: I thought POSIXTime was a Rational like type with 1 represending 1 second.
09:07:00 <edwardk> telephone: (x >> return True) <|> return false
09:07:09 <edwardk> er False
09:07:33 <edwardk> telephone: it won't backtrack and try the other branch if it consumed input
09:07:42 <szab> Hi! Happenin' to be new here'n'searchin' for a little help. ^^
09:07:47 <edwardk> er
09:09:09 <szab> I'm following the book "Learn You a Haskell for Great Good" and I've found out that one of the programs doesn't behave as expected.
09:09:41 <szab> I was wondering if someone could help me understand why and maybe give a little hint on how to fix it.
09:10:08 <arcatan> szab: yes, please just tell what program you're talking about
09:10:33 <szab> I've copied the source here: http://pastie.org/2167953
09:10:40 <edwardk> try ((x >> empty) <|> return True) <|> return False
09:11:07 <jonkri> sorry for the off-topic question, but i'm trying to write a hostname Parsec validator function for the Network package. reading on http://en.wikipedia.org/wiki/Hostname, it says "The full domain name may not exceed a total length of 253 characters in its external dotted-label specification.". any idea what this means? where did they get 253 from?
09:11:10 <edwardk> runs x, then fails, if x consumed input then we skip the return True, and return False.
09:11:41 <edwardk> so i guess consumedInput x = try ((x >> empty) <|> return False) <|> return True
09:11:45 <szab> arctan: The problem is that when I run it it prints the prompt for a number AFTER it gets it.
09:11:46 <edwardk> answers the question you posed
09:11:51 <quicksilver> szab: and, what's the problem with it?
09:12:26 <ziman> szab, you need hFlush stdout
09:12:34 <edwardk> it runs x, then bombs, if x didn't consume input it'll return False, succeeding, otherwise the try will enable it to return True.
09:12:46 <parcs> szab: a quick fix would be to replace putStr with putStrLn
09:12:53 <ziman> szab, stdout is flushed only with newlines; if you use putStr, chances are you need hFlush as well
09:13:29 <edwardk> you could implement it more directly as a ParsecT because you can get direct access to the m (Consumed …)
09:13:39 <szab> Oh, I see.
09:13:54 <szab> Wait a sec, trying it out...
09:14:03 <geheimdienst> jonkri: i can't find the 253 in the wikipedia page you linked. which section do you mean?
09:14:04 <quicksilver> szab: hSetBuffering stdin NoBuffering
09:14:05 <quicksilver> also.
09:14:21 <jonkri> geheimdienst, my bad, it was http://en.wikipedia.org/wiki/DNS_label#Parts_of_a_domain_name
09:14:31 <szab> Ok, understood.
09:14:38 <jonkri> i tried to look in the referenced rfc, but i couldn't find 253 in there either
09:14:55 <szab> Thanks very much, you were veru helpful! :)
09:15:10 <edwardk> telephone: did that do what you needed?
09:15:18 <ziman> szab, you're welcome. :)
09:16:06 <geheimdienst> jonkri: yeah, in section 11 the rfc says 255 bytes max
09:16:19 <geheimdienst> i guess it's a typo in wikipedia
09:16:24 <quicksilver> edwardk: there is also the much less elegant approach of calling getPos (or whatever that thing is called) before and after and comparing :)
09:17:27 <jonkri> geheimdienst, what does "its external dotted-label specification" mean?
09:17:33 <jonkri> "x.y.z"?
09:19:17 <edwardk> quicksilver: assuming that nothing untoward is done to getPos ;)
09:19:29 <geheimdienst> jonkri: i guess "dotted-label" is like when you say the 32-bit IP address is written "dotted-decimal", i.e. 4 decimal numbers with dots
09:20:28 <jonkri> aha
09:20:34 <xil> hi. I have an array with an undefined index. Is there a way to check if a given index is undefined without incurring an exception?
09:20:35 <geheimdienst> external in the wikipedia article is contrasted with "internal binary representation". the rfc says "any binary string whatever can serve as the value of any resource record". so presumably between external and internal there must be some escaping going on, saying "\NUL" or whatever
09:20:38 <geheimdienst> not sure :)
09:20:42 <geheimdienst> my best guess
09:21:13 <kmc> an array xil?
09:21:17 <kmc> what kind
09:21:23 <xil> kmc: Array Int Int
09:21:26 <xil> oh wait
09:21:27 <xil> no
09:21:33 <kmc> :t bounds
09:21:34 <xil> Array Int Neuron
09:21:34 <lambdabot> forall i e. (Ix i) => Array i e -> (i, i)
09:21:36 <edwardk> xil: undefined index? you mean you have an index value that may be out of bounds? or that it may actually be an undefined value?
09:21:40 <edwardk> :t inRange
09:21:41 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
09:21:51 <xil> oh well anything from 0 to some integer less than 20 most likely
09:21:54 <jonkri> geheimdienst, thanks for that :) i got to go now, take care :)
09:22:05 <edwardk> :t inRange . bounds
09:22:06 <xil> it starts with (0,9) but I grow it throughout the program
09:22:06 <lambdabot> forall a e. (Ix a) => Array a e -> a -> Bool
09:22:20 <geheimdienst> jonkri, you're welcome
09:22:20 <kmc> xil, for many cases i would use IntMap not Array.  i find the API nicer
09:22:43 <kmc> plain old Map is also a fine choice
09:22:55 <edwardk> or if you just append to the end, Data.Sequence.Seq
09:22:56 <xil> edwardk: it's not out of bounds, that's the problem. I had out of bounds exceptions but I fixed those
09:23:06 <xil> kmc: I need speed of access
09:23:12 <xil> kmc: I used Map for other things
09:23:26 <edwardk> Data.Sequence.Seq and Data.IntMap both give you logarithmic access time.
09:23:40 <edwardk> but they also grow more cheaply
09:24:21 <edwardk> if you find yourself growing the array, they are usually the better choice.
09:24:52 <edwardk> in part because of gc
09:24:56 <xil> thing is, I kind of need constant access time, and there shouldn't be undefined indecies in the array, so it's a bug I should fix anyway. I don't grow them very often compared to how often I seek within them
09:25:09 <telephone> edwardk: sorry, I was in another workspace.. I shall take a look
09:25:10 <edwardk> fair nuff
09:25:33 <quicksilver> xil: constant access time is a lie.
09:25:50 <quicksilver> xil: all you need to do is compare an actual benchmark and see which is faster for your purposes.
09:25:54 <edwardk> anyways, if your index is truly undefined then you need to play games with forcing it, and catching the exception, which takes you out into IO
09:26:18 <xil> logarithmic access might be an acceptible solution, but even if I change things to Maps or Seqs then there would still be this bug I need to fix. Somewhere I'm not giving an array everything I think and the same would apply to the Maps
09:26:31 <xil> edwardk: ah that's not good
09:26:33 <edwardk> you can then _try_ to hide that behind an unsafePerformIO, but that gets tricky when it interacts with exceptions
09:26:52 <xil> well I don't mind issuing an error
09:27:03 <xil> but the default exception that GHC gives me doesn't tell me where it's happening
09:27:05 <xil> or what the index was
09:27:09 <xil> and I need that information
09:27:42 <edwardk> and, though i'm going to stop trying to convince you to ditch array, IntMap is constant access time as well, though its that sad sort of constant access time caused by the fact that it is a stricture that holds at most 2^64 keys, and doesn't rebalance because it is a patricia trie
09:27:43 <kmc> xil, OMG, log(20) is almost 5!
09:27:58 <edwardk> kmc: =P
09:28:38 <xil> actually, if there's a way to use the debugger to find the problem I wouldn't mind going that route. Thing is, I've never used it and don't know how
09:28:39 <edwardk> kmc: i have plenty of applications where a logarithmic factor is too crippling, so i have some sympathy for him ;)
09:28:55 <kmc> edwardk, but you probably arrived at that conclusion through testing and benchmarking
09:29:02 <Cale> edwardk: Hey, pointer access is the same sad sort of constant access time
09:29:05 <edwardk> xil: you can emit Debug.Trace.trace statements
09:29:14 <kmc> not half-remembered snippets of Algorithms 101 which are then mis-applied
09:29:19 <kmc> which seems to be how most people choose datastructures
09:29:26 <edwardk> kmc: there is that
09:29:32 <xil> kmc: I know that log time is really close to constant for most things, but the approximately constant difference between them matters for me. I'm accessing the array many many MANY times. So that constant 5 will slow my program down, and I can't really afford it
09:30:06 <edwardk> xil: how often do you mutate the array?
09:30:10 <kmc> xil, asymptotic analysis is *worthless* if you care about those constants
09:30:41 <edwardk> cale: true that
09:30:59 <kmc> xil, maybe the constants on the log(n) datastructure are better
09:31:22 <wli> More detailed asymptotic analysis estimates the relevant constants.
09:31:26 <xil> edwardk: insignificantly often compared to how often I access them. It's a simulation. So maybe on average I mutate the array 4 times, maybe 6, but I access it thousands of times, and that number grows over time
09:31:27 <geheimdienst> i don't think pointer deref or memory access is constant. it depends on things like cpu caches
09:31:45 <kmc> geheimdienst, another thing you don't learn in half-remembered Algorithms 101
09:31:45 <monochrom> yeah, if you talk about empirical speed, you can't speculate
09:31:58 <quicksilver> geheimdienst: it is mostly a step function which approximates logarithmic
09:32:02 <Cale> No function for indexing a datastructure with n elements is faster than O(log n) time, because it takes O(log n) bits just to represent the index, and you have to examine each of those in order to do the lookup.
09:32:04 <kmc> xil, anyway, my advice is to write the program in the cleanest "reasonably efficient" way, and then profile and optimize as needed
09:32:17 <telephone> edwardk: (back to the consumed input question) I now saw that the combinator (<|>) tries right only if left did not consumed any input. So that solved my problem naturally. Thanks.
09:32:19 <quicksilver> geheimdienst: with sharp discontinuities as you exhaust L1/2/3 caches and then again when you hit swap.
09:32:22 <edwardk> xil: then your choices are probably reasonable. anyways, good luck tracking down the undefined instances. your best bet would be to sprinke traces.
09:32:25 <monochrom> case in point: empirically, the old hashtable was slower than Data.Map
09:32:40 <edwardk> telephone: happy to help
09:32:54 <Cale> In practice/physical reality, the asymptotic bounds are even worse.
09:33:07 <xil> kmc: if only I had the time, but I'm on a clock to make this just work, even if it only sort of works. After that I might be able to go back and clean it up, change the data structs so that it's more elegant and efficient, but now I don't have time
09:33:19 <Cale> Because the amount of memory you can put in a given volume of space is bounded.
09:33:37 <xil> edwardk: thanks
09:34:06 <Cale> and so as you add more, some of it has to be farther away, and information can only travel so fast
09:34:09 <xil> also, in case I do decide to change data structures, which do you guys recommend given that I'm accessing them a LOT
09:34:49 <kmc> xil, well, which is it?  are you using the fast structure or the simple structure?
09:35:05 <wli> Asymptotic bounds need to include constants. Count various sorts of instructions like integer and floating point addition, multiplication, division, and others, also count cachelines and TLB pages touched, etc.
09:35:23 <xil> kmc: speed is what's important to me, at least at the moment. If I can reduce speed in other areas where I already know there is terrible inefficiency then I might be able to go simple, but for now I need speed
09:35:23 <kmc> i suggested Map because I like its API better, and you think it will be too slow
09:35:23 <monochrom> if you are in a hurry, the right thing to do is to consult someone who has actually benchmarked these things, rather than speculate using conventional wisdom
09:35:31 <wli> Each kind of operation gets its own constant factor to empirically estimate.
09:35:33 <kmc> but now you want it to "sort of work" and don't care about efficiency?
09:35:53 <Cale> Map/IntMap may be faster than using arrays if you have updates to do too.
09:36:05 <xil> kmc: haha, sorry what I mean is that I already have arrays so I'd rather not change the data structure if I can make it work in the short term
09:36:38 <xil> Cale: I update maybe 6 times every frame but access thousands, and I access more and more over time
09:37:16 <Cale> okay, then probably arrays are fine
09:37:33 <Cale> (that sounds like a pretty good use case for them)
09:38:02 <quicksilver> Arrays got quite a lot faster in recent GHC versions too
09:38:04 <ziman> aren't arrays also more cache-friendly? (because of their "density")
09:38:07 <xil> kmc: I like Maps too though. I used them for certain things in this program already. I'll try switching to them when fix inefficiency elsewhere, since the logarithmic factor isn't as bad as the Big O inefficiency I have elsewhere
09:38:39 <quicksilver> ziman: unboxed ones, yes, but then again they're GC unfriendly
09:39:12 <kmc> why?
09:39:40 <quicksilver> because of the way they're implemented, I don't understand the details.
09:40:01 <xil> Cale: yeah that's why I chose them originally, but I was afraid of the errors I'm getting now, haha. But it really might end up being that another struct is acceptable if I fix other issues, like some n^2 algorithms that should be linear
09:40:14 <xil> thanks for all the info everyone
09:40:45 <Cale> xil: yeah, you have to be careful about bounds
09:42:34 <ziman> quicksilver, what exactly does the GC-unfriendliness mean? (is there a recommended paper somewhere on the topic?)
09:42:36 <xil> Cale: well I had out of bounds exceptions before, and fixed those. But for the life of me I can't figure out what is causing this undefined index problem
09:43:09 <quicksilver> ziman: the fact that they are mutable defeats a clever assumption the GC makes
09:43:18 <quicksilver> ziman: that points can only ever point backwards in GC generations.
09:43:26 <quicksilver> ziman: that's the most important point, I believe.
09:44:07 <quicksilver> there could be general minor inefficiencies about large objects
09:44:14 <quicksilver> but a lot of this got fixed in GHC 7
09:44:31 <quicksilver> thanks in no small part to tibbe trying defiantly to build a fast HAMT.
09:45:56 <ziman> i see, thanks.
09:46:19 <identity_> /bin/sh: ghc: command not found
09:46:23 <identity_> .. wat is this.
09:46:31 <identity_> stupid PATH.
09:48:54 <ulfdoz> namd
09:49:24 <kmc> quicksilver, there are no pointers in an unboxed array, though
09:53:44 <bgamari> Should Data.Vector.Unboxed.map be lazy element-wise?
09:54:00 <bgamari> Judging by this profile it seems to be computing an entire new vector on the first access
09:56:06 <dolio> It cannot be element-wise lazy.
09:59:23 <edwardk> data.vector.unboxed only has unboxed values in it how COULD it be lazy element-wise?
09:59:40 <edwardk> bgamari: there is no place to hang the thunks
09:59:51 <edwardk> bgamari: if you need lazy use Data.Vector
10:02:36 * hackagebot mongrel2-handler 0.1.2 - Mongrel2 Handler Library  http://hackage.haskell.org/package/mongrel2-handler-0.1.2 (BardurArantsson)
10:02:47 <bgamari> edwardk: That is true
10:02:51 <bgamari> fair enough
10:06:19 <edwardk> or work with Yoneda Vector ;)
10:14:28 <monochrom> the "box" is to implement laziness. so "unbox" is unlazy
10:14:31 * ddarius wonders if he should start installing Ubuntu Server instead of Ubuntu.
10:14:57 <ddarius> There are other conceivable means of implementing laziness and boxing has many uses beyond laziness.
10:14:57 <monochrom> depends on whether you want a gui
10:16:02 <ddarius> I do want a GUI, but it may well be easier to modify an Ubuntu Server distribution into the laptop system I want, rather than trimming back the desktop Ubuntu.
10:16:20 <kmc> this is the point where you should consider Debian instead
10:16:41 <luite> xubuntu maybe
10:16:47 <monochrom> I suggest Xubuntu as another choice
10:17:07 <luite> monochrom: hey I had already chosen that, you must pick another one!
10:20:15 <monochrom> I know: damn small linux! :)
10:21:11 <rhdoenges> if you're comfortable starting from a command line and installing what you want, I recommend Arch Linux.
10:23:07 <gwern> hipsters use linux from scratch
10:23:24 <benmachine> rhdoenges: if you're also comfortable spending a couple of hours to fix it when it breaks :P
10:23:29 <benmachine> every now and then
10:23:45 <rhdoenges> :)
10:24:15 <rhdoenges> yeah, if you want stability Arch might not be the best. Debian is rock-solid.
10:25:13 * benmachine is totally comfortable doing that, incidentally
10:30:13 <bgamari> Is there any way to get the haskell runtime to spit out a backtrace in the event of a stack overflow?
10:35:36 <byorgey> bgamari: you can compile with -prof -auto-all  and then run with +RTS -xc -RTS  to get a printout of the cost centre stack
10:35:48 <byorgey> see http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/runtime-control.html
10:37:45 <dylukes> So, who are all of the Simons?
10:37:58 <dylukes> I'm aware of PJ and Marlow.
10:39:28 <bgamari> byorgey: Thanks
10:39:50 <byorgey> dylukes: I don't know any other Simons.
10:47:18 <CrazyThinker> I've heard of a new web startup using haskell. Anyone know the name of it?
10:48:13 <mike-burns> I hope they ask that at the trivia contest at the local bar tomorrow night.
10:48:49 <c_wraith> CrazyThinker: silk?
10:53:24 <CrazyThinker> c_wraith, Can you give me a link. Google is showing me photos of young women when I type "silk"
10:53:48 <c_wraith> http://www.silkapp.com/
10:54:11 <c_wraith> CrazyThinker: google search for "silk haskell" gets a lot of relevant results
10:54:25 <CrazyThinker> oh yeah. I'm an idiot
10:54:41 <CrazyThinker> c_wraith, this is the one
10:54:51 <monochrom> haha
10:55:11 <monochrom> also try "michael jackson" and "michael jackson software" :)
10:58:09 <kmc> ddarius, you should switch to Hannah Montana Linux
10:58:10 <kmc> http://hannahmontana.sourceforge.net/Site/Home.html
10:58:35 <companion_cube> too leet
10:59:00 <djahandarie> @remember xplat im in ur Sierpinski space, classifyin' ur subobjects
10:59:00 <lambdabot> Okay.
11:00:28 <rhdoenges> kmc: why does that even exist augh
11:00:37 <Botje> jaspervdj: nice post!
11:00:59 <byorgey> rhdoenges: from the FAQ: "I thought - what would attract young users to Linux? So I created this idea after a lot of reading and work."
11:01:11 <byorgey> oh yeah, I bet it was a ton of work
11:01:23 <kmc> yep
11:01:26 <kmc> i think it's a fine idea though
11:01:31 <Botje> I think lesbian linux would attract more people, then >:)
11:01:53 <kmc> probably exists
11:01:58 <rhdoenges> also, clicking "Truth" gets me a 404.
11:02:05 <kmc> http://www.jewbuntu.com/
11:02:19 <Botje> kmc: it does :)
11:02:56 <identity_> wat
11:02:58 <identity_> this is silly
11:02:59 <Botje> silly osx. why do you convert .ps files to .pdf first :(
11:03:07 <identity_> 2010.1.0.0.1 in ubuntu 11.04
11:03:16 <bgamari> damnit, is Data.Vector.Unboxed.toList not lazy?
11:03:56 <bgamari> Prelude Data.Vector.Unboxed> let test1 = V.generate (10*1000*1000) (id)
11:03:57 <bgamari> Prelude Data.Vector.Unboxed> let test2 = V.toList test1
11:03:57 <bgamari> Prelude Data.Vector.Unboxed> test2 !! 5
11:04:14 <bgamari> causes ghc to chew up 1GB of memory
11:07:39 <davidbe> identity_: were you able to install it? ~> https://bugs.launchpad.net/ubuntu/+source/haskell-platform/+bug/742052
11:08:03 <identity_> davidbe: i didn't try
11:08:07 <ziman> bgamari, it should be lazy. But you force (by inspecting) the fifth value of the list, which in turn forces the whole vector.
11:08:11 <identity_> davidbe: I'm trying to install ghc 7.0.3 right now
11:08:33 <bgamari> ziman: Right, I'm an idiot
11:08:43 <bgamari> Sorry for the noise
11:09:12 <davidbe> identity_: from source? that bug made me move away from ubuntu
11:09:40 <hpaste> “Ben Gamari” pasted “Non-recursive function causing stack overflow?” at http://hpaste.org/48760
11:09:45 <identity_> davidbe: ah
11:09:46 <identity_> yes
11:09:48 <identity_> source
11:09:59 <identity_> or well, using the standalone binary stuff
11:10:18 <bgamari> Can anyone see how packedVecToList might cause a stack overflow?
11:10:38 <bgamari> I'm assuming V.toList must be recursive
11:10:54 <davidbe> identity_: well, I wanted a distro that would take care of haskell-platform & updates. no too much manual intervention :) good luck!
11:11:00 <bgamari> Otherwise I'm just very confused
11:11:07 <identity_> davidbe: What did you decide on?
11:11:47 <Cale> Who just pasted that? I don't get a stack overflow from it.
11:11:55 <Cale> oh, bgamari did
11:12:23 <Cale> oh, I see
11:13:11 <jonkri> am i stupid for not immediately coming up with a function that generates the following (infinite) list: a, b, c, aa, ab, ac, ba, bb, bc, ca, cb, cc, aaa, aab, ...?
11:13:18 <Cale> ah, yeah, it's rather important that this is compiled with optimisations, it seems
11:13:34 <bgamari> Yep, apparently
11:13:37 <bgamari> Another of these issues
11:13:38 * jonkri has long expected his iq is a little too low for haskell :P
11:13:39 <bgamari> bah
11:13:46 <djahandarie> bgamari, there is no point in using Vectors if you are just converting it to a list
11:13:59 * bgamari has to stop compiling with -prof
11:14:07 <bgamari> unless actually needed
11:14:15 <bgamari> djahandarie: Unboxedness doesn't count?
11:14:31 <Cale> well, also, I'm not seeing quite as bad performance as you are
11:14:49 <benmachine> jonkri: you're not stupid. imo the easiest way to do that is concatMap listOfLength [1 ..]
11:15:26 <bgamari> Cale: hmm, compared to what?
11:15:30 <djahandarie> bgamari, I don't think it'll do much. Rewrite dot as a vector function.
11:15:34 <Cale> It just takes a long time without optimisations, and ghci doesn't grow past 100MB
11:15:39 <davidL> > concatMap (flip replicateM "abc") [1..]
11:15:41 <lambdabot>   ["a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aac"...
11:15:53 <bgamari> It's actually doing pretty well
11:16:07 <bgamari> With optimizations it's quite fast
11:16:13 <Cale> Well, running main with n = 10*1000*1000 will eat a few hundred megs.
11:16:16 <djahandarie> Faster than the list version?
11:16:23 <Cale> (unoptimised, bytecode interpreted)
11:16:33 <HugoDaniel> i dont know how to define my datatypes so that they can be easily turned into monads :(
11:16:44 <bgamari> Cale: Indeed, that's expected though
11:16:57 <jaspervdj> Botje: thanks :-)
11:17:00 <bgamari> djahandarie: No, this is still the list version
11:17:02 <Cale> HugoDaniel: Not everything is naturally a monad
11:17:15 <identity_> davidbe: I just installed ghc 7.0.3 without problems on ubuntu 11.04
11:17:19 <Cale> HugoDaniel: Sometimes your library will be a different sort of thing, and that's okay :)
11:17:22 <bgamari> djahandarie: Do you expect that converting dot to a vector function will actually make a difference?
11:17:23 <identity_> it's literally something like 3 commands on ubuntu
11:17:30 <Botje> jaspervdj: how much did the C or C++ users suffer?
11:17:36 <djahandarie> bgamari, yes, avoid lists everywhere and it will certainly do better.
11:17:43 <bgamari> djahandarie: Hmm, alright
11:17:51 <Cale> HugoDaniel: (But what datatype?)
11:17:56 <bgamari> I was hoping that the compiler would be smart enough to elide the intermediate lists
11:17:57 <jaspervdj> Botje: C/C++ wasn't allowed :-) the program had to be at least a bit declarative
11:18:15 <jonkri> davidL, why are you using replicateM?
11:18:23 <bgamari> Wishful thinking I guess
11:18:39 <Cale> The compiler is smart enough to avoid some of the intermediate lists, provided that you use library functions on lists, and not directly recursive functions.
11:18:41 <Botje> aww :P
11:18:59 <Cale> (there are rewrite rules for list fusion)
11:19:03 <HugoDaniel> i tend to break the problem like i used to in Java, but then i write that composition in haskell
11:19:13 <djahandarie> bgamari, you should be able to rewrite this as a fold
11:19:58 <HugoDaniel> the thing is that i feel that most problems should probably be better described as a monad, or a stack of monad transformers, but i can't tackle it from the start
11:20:10 <davidbe> identity_: congrats :) as I wrote, I prefer my distro keep my package up-to-date without too many manual interventions
11:20:13 <Cale> But also note that laziness combined with garbage collection will often ensure that such intermediate lists don't stick around in memory long
11:20:28 <bgamari> Cale, djahandarie: Ahh, the problem with not using lists is that Data.Vector needs to construct an entire new array when I map
11:20:29 <Cale> (though the allocation still costs you time)
11:20:41 <HugoDaniel> and then my datatypes just pile on top of each other as lists of datatypes of datatypes, and typeclasses everywhere... kindof ugly
11:20:43 <identity_> davidbe: Aye, I understand. Did you find a distro that keeps packages more up to date than ubuntu does? I haven't, tbh.
11:20:54 <apfelmus> Hello!
11:20:56 <Cale> HugoDaniel: Monad transformers are kinda overrated.
11:20:58 <davidbe> identity_: Arch Linux
11:21:08 <Cale> HugoDaniel: They're a good way to construct some monads.
11:21:09 <bgamari> Cale, djahandarie: I'd like to be able to map without incurring additional memory cost
11:21:15 <apfelmus> I am in need of help with choosing a name.
11:21:30 <identity_> davidbe: ah
11:21:41 <bgamari> djahandarie: Are you sure this algorithm is a fold?
11:21:47 <Cale> HugoDaniel: But in general, you should usually try to hide the fact that you're using them if you are doing so in anything more than a pretty local context
11:21:48 <bgamari> djahandarie: It's more like a fold over two lists
11:22:03 <Cale> (by using a newtype)
11:22:43 <HugoDaniel> yes, im aware
11:23:02 <apfelmus> What does #haskell like better for a function name? "run" or "actuate"?
11:23:23 <Cale> But yeah, they should be an implementation detail of your library, rather than an external part of its interface usually.
11:23:30 <benmachine> apfelmus: the latter sounds like fun
11:24:06 <bgamari> djahandarie: Note how I need to walk through the list differently depending upon the values
11:24:06 <benmachine> apfelmus: googling it turns up a lot of businesspeople who like making up words though
11:24:15 <HugoDaniel> apfelmus: play
11:24:31 <jaspervdj> Botje: I've thrown it on the Haskell reddit, other people might find it interesting as well :-)
11:24:42 <apfelmus> The context is my FRP (functional reactive programming) library.
11:24:50 <apfelmus> You can create something called an "event network".
11:25:01 <Cale> reactimate ;)
11:25:19 <apfelmus> The function in question will take an event network and register all the event handlers, so that the network starts producing output.
11:25:27 <apfelmus> Cale: Already used that one. ;)
11:25:37 <apfelmus> I previously called it "run".
11:25:53 <benmachine> apfelmus: have TH autogenerate a name from /usr/share/dict/words at runtime
11:25:57 <benmachine> *compiletime
11:26:01 <apfelmus> But this always makes me think that the network now takes control of the control flow.
11:26:26 <apfelmus> benmachine: A most interesting suggestion, but I feel that this would upset Don Knuth.
11:26:42 <Cale> HugoDaniel: So, what is your library about?
11:26:59 <apfelmus> Hence, I would like to change it to "actuate".
11:27:08 <Cale> HugoDaniel: Have you seen SPJ's talk about puddings and financial contracts?
11:27:34 <jonkri> benmachine, what is listOfLength?
11:27:46 <Cale> http://ulf.wiger.net/weblog/2008/02/29/simon-peyton-jones-composing-contracts-an-adventure-in-financial-engineering/
11:28:01 <apfelmus> HugoDaniel: "play" is actually a good suggestion. It usually applies to movies and audio, thouhg, not sure if it's ok to "play an event network".
11:28:05 <Cale> ^^ this is a rather good talk for people wanting some insight into FP design
11:28:09 <apfelmus> Then again, I also have a function named "pause".
11:28:26 <HugoDaniel> apfelmus: doIt is common in where clauses
11:28:36 * ski used `play' and `replay' with CGI ..
11:28:55 <Cale> Or perform if you want to be less playful
11:29:53 <apfelmus> Hmm.
11:30:15 <apfelmus> For reference, here the haddocks:
11:30:16 <apfelmus>  http://hackage.haskell.org/packages/archive/reactive-banana/0.3.0.1/doc/html/Reactive-Banana-Implementation.html#v:run
11:30:58 <benmachine> jonkri: a function which takes n and generates all the strings of length n
11:31:17 <apfelmus> ski: Where did you use that?
11:31:20 <benmachine> jonkri: as it happens that's pretty much what replicateM does when using the list monad, but you could just as well write it yourself
11:31:22 <jonkri> benmachine, aha, thanks
11:31:52 <benmachine> jonkri: the idea was you wrote listOfLength yourself because it sounded easier to write than your original specification
11:32:29 <jonkri> benmachine, it is :)
11:32:44 <jonkri> i was going crazy trying to make a recursive function to do it :)
11:33:06 <benmachine> mm
11:34:07 <bgamari> djahandarie: I would be very curious to know how you would implement dot as a fold
11:34:22 <ski> apfelmus : an old laboration. stored a trace of results of `IO'-actions (which could be pruned), with an `ask' operation which generated a form which send the reply to the program which used `replay' to replay the history, until it reached the "actual point in time"
11:34:51 <djahandarie> bgamari, hey, sorry, I'm at work right now. Might have a chance to do it later.
11:34:58 <ski> apfelmus : the structure was (very roughly) `data Replayable a = R {play :: Foo a , replay :: Bar a}'
11:35:00 <djahandarie> It may not be a fold on lists though
11:35:03 * djahandarie afk
11:35:18 <apfelmus> ski: Ah, so "play" is the continuation while "replay" does the thing again?
11:35:19 <bgamari> djahandarie: Sure. No worries. Whenever you have the time/inclination
11:35:51 <ski> apfelmus : `replay' executes the history, until it's exhausted, at which point it calls `play' recursively instead
11:36:11 <apfelmus> ski: Ah, ok.
11:36:54 <apfelmus> Hrm.
11:37:07 <ski> it was interesting to do a monad which had, so to speak, two separate "parallel" actions internally
11:37:26 * apfelmus nods
11:37:38 <apfelmus> Concerning the name, "play" is a standard word, but carries the wrong connotation.
11:37:49 <apfelmus> "actuate" has just the right connotation, but somehow it creeps me out.
11:38:49 <monochrom> try also: engage, energize, deploy, fire
11:39:26 <apfelmus> "Bananas, energize the event network!"
11:39:33 <ski> "excite" ?
11:39:46 <monochrom> (4 most common words to depict the use of hi-tech weapons in movies and tv)
11:41:47 <apfelmus> Well, "actuate" has the right connotation. It's just that I feel uncomfortable with it, compared to "play" or "run".
11:42:36 <Cale> HugoDaniel: Rather than "how can I make my library define a monad?", you should probably ask how the problems in whatever problem domain your library is trying to model/solve can be composed together from simpler ones, and what a sufficient set of primitive problems are to build things up from. Sometimes the manner in which you can compose things will give you the monad operations, and sometimes it won't.
11:42:44 <monochrom> too bad "do" is a reserved word :)
11:42:54 <apfelmus> Haha :)
11:42:56 <c_wraith> RebindableSyntax!
11:43:28 <monochrom> but "withSocketsDo" may give you ideas
11:44:03 <monochrom> but too bad in practice use cases it goes like "withSocketsDo $ do ..." doo-doo
11:44:17 <monochrom> "with sockets doo-doo"
11:44:42 <apfelmus> I'm going to call it "actuateDo".
11:45:08 * ski thinks that sounds stranger than just `actuate'
11:45:26 <monochrom> Picard: "Mr. Data, actuate doo-doo"
11:45:42 <apfelmus> ski: You're right. Ok, then I'll call it "actuateDoDo". ;)
11:45:58 <byorgey> if you can't beat them, join them!
11:46:03 * ski . o O ( `actuateDoBeDo' )
11:46:14 <Cale> "To be is to do" - Socrates  "To do is to be" - Sartre  "Do Be Do Be Do" - Sinatra
11:46:27 <byorgey> actuateDoBeDo . shooWop $ \bow -> ...
11:46:42 <monochrom> did Sinatra say that?
11:46:58 <apfelmus> :D
11:47:09 * ski . o O ( <http://groups.google.com/group/comp.lang.scheme/msg/60dcac5ea812398> )
11:48:25 <apfelmus> byorgey: Btw, did you manage to find a nice toolkit for making the diagrams user guide?
11:49:06 <byorgey> apfelmus: I'm still exploring options. I'll be sure to publicly explain what I end up choosing and why.
11:50:17 <apfelmus> byorgey: Yay! In case you're dissatisfied with everything and are rolling your own pandoc/Haskell/markdown/reST/LaTeX frankenstein, I'd like to contribute.
11:50:24 <Cale> poucet: Happy birthday, btw! (Skype told me)
11:50:53 <byorgey> apfelmus: hah, ok!  I will keep that in mind -- actually makes that option more attractive =)
11:52:31 <apfelmus> byorgey: I've always been looking for something this. I once considered writing a "pseudo-LaTeX" parser. I.e. the idea is to use LaTeX as a markup language and to dispense with the insane macro system. Similar to how latex2html and similar tools are working.
11:53:00 <apfelmus> byorgey: But it turns out that parsing LaTeX is a rather subtle issue.
11:53:03 <ezyang> I've always thought of LaTeX as a reasonable target language.
11:53:10 <gwern> like assembler
11:53:18 <kosmikus> apfelmus: very subtle
11:53:23 <Cale> It seems a bit too long since I saw a talk by SPJ
11:53:25 <ezyang> Or maybe TeX is the target language, and LaTeX is just weird.
11:53:37 <Cale> Has he given any new ones lately?
11:53:43 <apfelmus> kosmikus: I mean, even when approximating it and forgetting about all the macro stuff.
11:53:51 <ezyang> The last one I saw was "Let should not be generalized"
11:54:03 <ezyang> but that was last year.
11:54:13 <kosmikus> apfelmus: what's left then? :)
11:54:38 <Jafet> The stuff that people actually use
11:55:12 <apfelmus> kosmikus: Well, I wanted to keep verbatim environments and things like that.
11:55:17 <apfelmus> byorgey: XML would probably be the best fit. But it's just plain ugly to use.
11:55:20 <Cale> oh, was that recorded?
11:55:26 <byorgey> apfelmus: yeah.
11:55:36 <kosmikus> XML. brrrrr.
11:55:58 <apfelmus> byorgey: Maybe it's possible to write a small parser combinator library that can be used to assemble markdown-like languages.
11:56:17 <apfelmus> byorgey: Parsec is rather static/unwiedly for quick prototyping.
11:56:26 <byorgey> yeah. that's a nice idea.
11:56:37 <ezyang> You guys should write the parser in Prolog :-)
11:56:44 <ezyang> ^-- facetious remark.
11:57:02 <kosmikus> byorgey, apfelmus: anyway, if you end up writing a new TeX, let me know. I'd like to help in making it fail :)
11:57:12 <byorgey> hahaha
11:57:36 * byorgey is NOT planning to write a new TeX.
11:57:49 <apfelmus> byorgey: Maybe something like this: "Declare * (star) to be a new special character and use it to denote italics". Of course, then the tricky thing is to figure out what to do with two stars "**". But maybe there's a simple semantics for that.
11:57:56 <byorgey> although I suppose the road to TeX is paved with good intentions.
11:58:04 <kosmikus> byorgey: wise decision :)
11:58:28 <kosmikus> it's tempting me all these years, but until now I've been strong enough to stay away.
11:58:38 <byorgey> apfelmus: escaping seems the trickiest part.
11:59:13 <Ke> a new tex really needed to be written
11:59:31 <Ke> perhaps not a new language but a new interpreter
11:59:36 <Ke> !
11:59:54 <kosmikus> Ke: what do you mean: new interpreter but not new language?
12:00:06 <apfelmus> byorgey: Yeah. Certain other languages which shall not be named here would throw a lot of regular expressions at it until it resembles the desired result. Of course, we're not satisfied with anything less than a proper parse tree.
12:00:07 <wli> Call it something that doesn't suggest Texas, please.
12:00:09 <kosmikus> the language is what's broken, not the interpreter
12:00:20 <byorgey> apfelmus: agreed =)
12:00:41 <dicey> don't knock on TeX
12:00:57 <dicey> nothing wrong with good typesetting.
12:01:09 <kosmikus> apfelmus: FWIW, I'd really appreciate a Wiki markup language with proper syntax and parse trees.
12:01:27 <Ke> kosmikus: so you think that being able to include svg files in eps document is an abomination
12:01:35 <kosmikus> dicey: I'm not at all complaining about the results.
12:02:04 <dicey> i think improving on something like latex would take a lot more effort than the result would be worth
12:02:05 <Ke> or the ability to produce a full document on one pass without temp files
12:02:15 <apfelmus> kosmikus: Yeah, me too. It's a pain to migrate anything that doesn't have a parse tree.
12:03:09 <kosmikus> Ke: it's very hard to fix anything fundamental about TeX without fixing the language first.
12:03:25 <monochrom> language semantics ≠ typesetting output
12:03:36 <apfelmus> byorgey: One thing that seems to work very well is the distinction between inline objects and block (paragraph-level) objects. So, one rule for special characters could be that they are inline-only. This way, a forgotten * does not screw the whole document, and the parse tree is somehow "localized to paragraphs".
12:03:44 <Cale> TeX is still popular because 1) The math layout is immaculate (or if not, then at least it's how everyone expects things to look, which is basically the same), 2) The main content of text and formulas are (usually) not awkward to type. (Even if formatting things on a larger scale runs into stupid composability headaches), and 3) Computer Modern.
12:03:50 <monochrom> theorem: smart people invent wacky language semantics
12:03:55 <byorgey> apfelmus: makes sense
12:04:11 <kosmikus> Cale: agreed.
12:04:18 <dicey> i just cant see tex ever going out of style.
12:04:23 <dicey> 20 years from now ppl will still use it
12:04:46 <kosmikus> Cale: it's hard to argue that TeX should be replaced, because unlike programs people see documents as being "write once" programs, so code quality is less of an issue. and since the output is great ...
12:04:54 <monochrom> don't forget that TeX is a write-only language for most of its users
12:05:16 <dicey> that's the thing, once your paper is done and published in tex, the code is just meaningless
12:05:46 <wli> Not how it should be IMHO.
12:05:49 <kosmikus> people still waste a lot of time with subtle incompatibilities of style files and debugging strange errors
12:05:55 <Liskni_si> did you guys see some of the latex3 code?
12:06:07 <cheater_> why
12:06:08 <monochrom> even cobol has a saner semantics because we know that we have to re-read and re-read cobol code for centuries
12:06:09 <cheater_> is it bad
12:06:09 <cheater_> ?
12:06:09 <kosmikus> Liskni_si: latex3 is still TeX
12:06:25 <wli> A module system like Standard ML or OCaml's might help.
12:06:25 <Liskni_si> kosmikus: it is, but it looks quite nice
12:06:45 <apfelmus> byorgey: Anyway. Let me know if you're taking the homebrew route, I'll be happy to contribute. :)
12:06:45 <kosmikus> Liskni_si: right. they're trying to make it more high-level.
12:06:52 <Liskni_si> and combined with luatex, those problems with images will go away as well
12:06:58 <kosmikus> so they're basically making my point for me. a higher-level language is needed.
12:07:01 <Liskni_si> (one day)
12:07:02 <dicey> the real work of something going into tex usually takes place on PAPER, with a PEN. that's the code. everything else is just a haze of caffeine and getting it to look the way you want. once it looks good. DONE.
12:07:06 <hpaste> jonkri pasted “ID generation” at http://hpaste.org/48761
12:07:32 <kosmikus> luatex will probably succeed, but it's somewhat sad for me as a Haskeller to see that happening ...
12:07:35 <jonkri> benmachine, ^^^ if you're curious about what i ended up with :)
12:08:23 <kosmikus> dicey: most people using TeX have not the slightest idea of good style, and are happy with far less than I am.
12:08:39 <dicey> most of the time when ppl are working with something like TeX, its just...a chore. very few people are really interested in typing something akin to "nice TeX code"
12:09:02 <dicey> they would rather spend their time improving the actual proofs or results in the paper they are trying to publish...
12:09:21 <kosmikus> dicey: agreed :) so wouldn't it nice if it would be easier? :)
12:09:22 <jonkri> kosmikus, dicey: i don't know what you are talking about, but i can really recommend lyx. it has increased my productivity with like 1000% :)
12:09:29 <monochrom> mathematicians disdain sane languages and sane notations
12:09:40 <kosmikus> monochrom: some do
12:09:47 <cheater_> only shitty mathematicians do so
12:10:03 <dicey> monochrom: WHAT? do you honestly think that?
12:10:10 <monochrom> yes
12:10:49 <nickela> hello all! I have stunned how get Data.ByteString.Lazy from strict ByteString.Char8
12:10:50 <jonkri> i disagree. in my experience, the opposite is true
12:11:07 <wli> Someone not undergoing extreme hardship should do up some sort of better TeX language.
12:11:09 <dicey> if anything mathematicians have a fetish for clean notations...
12:11:31 <jonkri> dicey, right
12:11:37 <kosmikus> dicey: I'd like to meet your mathematicians. I'm more with cheater_
12:11:49 <dicey> i am a mathematician, in the strict sense that i produce new math.
12:11:59 <dicey> and publish the odd result
12:12:02 <kosmikus> most mathematicians I know say TeX and perl are nice languages, and that Haskell is useless.
12:12:07 <monochrom> see the end of http://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html
12:12:26 <Cale> It's usually the notations that physicists invent or which are outdated and yet still hanging around in undergraduate classes which mathematicians get blamed for here.
12:12:27 <cheater_> i think this argument can be summed up as "mathematicians are like burritos"
12:12:29 <kosmikus> dicey: I'm a mathematician in the sense that I have a degree in maths.
12:12:41 <kosmikus> it's hard to generalize, obviously.
12:12:50 <cheater_> s/hard/stupid to/
12:12:59 <kosmikus> true
12:13:04 <cheater_> or something
12:13:22 <nickela> or other question: how get Data.ByteString.Lazy from Data.Text
12:13:22 <dicey> i have one of those too, but having a degree is neither sufficient or necessary to produce new maths, which is what i would call the benchmark of "mathematician"
12:13:38 <kosmikus> still, I think that if you compare PL researchers to mathematicians, you have the strange situation that PL people care far more about clean semantics than mathematicians do, on average
12:14:19 <cheater_> i quit before i finished my degree and from nearly 100 people who started, and 8 people who finished the course, i am one of 2-3 who are actually still doing mathematics
12:14:22 <danharaj> That's 'cause PL people study semantics :p
12:14:36 <Cale> nickela: http://hackage.haskell.org/packages/archive/text/0.11.1.3/doc/html/Data-Text-Lazy-Encoding.html
12:14:51 <kosmikus> different fields in math also have very different traditions
12:15:07 <Cale> nickela: oh, also...
12:15:39 <Cale> :t fromChunks
12:15:39 <lambdabot> Not in scope: `fromChunks'
12:15:49 <Cale> :t Data.ByteString.Lazy.fromChunks
12:15:49 <lambdabot> [BSC.ByteString] -> BSLC.ByteString
12:15:55 <dicey> it just surprises me that somebody could accuse the people who invented category theory and arrow notation as people who dislike clean notations
12:15:56 <Cale> :t Data.ByteString.Lazy.toChunks
12:15:56 <lambdabot> BSLC.ByteString -> [BSC.ByteString]
12:16:38 <kosmikus> dicey: not those.
12:16:51 * hackagebot test-framework-doctest 0.1 - Test.Framework wrapper for DocTest  http://hackage.haskell.org/package/test-framework-doctest-0.1 (SakariJokinen)
12:16:53 <dicey> i know many mathematicians who pretty much believe that fundamental advancements in math go hand in hand with fundamental improvements in notation.
12:16:53 * hackagebot web-routes 0.25.1 - Library for maintaining correctness and composability of URLs within an application.  http://hackage.haskell.org/package/web-routes-0.25.1 (JeremyShaw)
12:16:56 <kosmikus> dicey: as I said, different fields within math have to be distinguished.
12:17:09 <Cale> Not that there's any shortage of bad notation here and there throughout mathematics. Some people just have bad taste. In general though, I'd say mathematicians do a pretty decent job.
12:17:15 <nickela> but I have Data.Text (not lazy) initial
12:17:29 <kosmikus> dicey: but aren't you surprised how often you read things like "there exists an x such that ... for all y" in regular text books and papers?
12:18:17 <dicey> Cale: in some fields of math, creating new notations can be really really hard, and sometimes not worth the effort. especially if the result is juicy. rather to get it out there first and let the youngins find a better way to write it down
12:18:51 * hackagebot web-routes-wai 0.19.2 - Library for maintaining correctness of URLs within an application.  http://hackage.haskell.org/package/web-routes-wai-0.19.2 (JeremyShaw)
12:18:52 <kosmikus> also, let me name probability theory as a field which I think has really crazy and sloppy notation in general
12:18:55 <nickela> oohhh, thank all, now I undestand :)
12:19:11 <nus-> dicey, such as?
12:19:14 <dicey> notions comes first, good notations come later. gauss is quoted for saying something similar.
12:20:01 <dicey> nus: combinatorics comes to mind. almost none of it is notated well.
12:20:06 <dicey> unless you call a picture a good notation
12:20:33 <nus-> if you think something is wrong with mathematics, try reading laws :-p (-:
12:20:57 <nus-> lawyerese is in utmost need of new notation
12:21:05 <dicey> and, unsurprisingly, combinatorics is one of the newer disciplines as far as these things go. so it follows that the notation would be pretty heavy
12:22:01 <dicey> is lawyerese even based on sound axioms? i mean, it hardly even counts as logical
12:22:19 <nus-> some parts try to.. taxation, etc.
12:22:47 <dicey> anything regarding the constitution just reads like a bunch of fluff, to me. but then again im not an expert
12:23:05 <Botje> I really like dropbox's ToS.
12:23:26 <Cale> dicey: I've occasionally had the thought that some of higher dimensional category theory is the result of one guy drawing a crazy doodle on a blackboard, and the rest of the room trying to find a way to formalise it as a notation for something ;)
12:24:41 <Cale> http://books.google.ca/books?id=VfwaJYETxqIC&pg=PA63&lpg=PA63&dq=swiss+cheese+multicategory&source=bl&ots=k2HIEXtezm&sig=LeK-xYSVNEu3XP6Tra-bK5MwzMU&hl=en&ei=-GQTTpy6B8mKsQLP0tnUDw&sa=X&oi=book_result&ct=result&resnum=1&ved=0CBYQ6AEwAA#v=onepage&q=swiss%20cheese%20multicategory&f=false
12:24:54 <dicey> Cale: I know what you mean. the farther you go in math, the more you see proofs written like this: We proceed by demonstrating that the following diagram commutes.
12:25:04 <dicey> and then there will be this ridiciulously huge, overly complicated diagram
12:25:25 <dicey> and several pages of them showing that each arrow works
12:26:08 <dicey> category theory is believed by some to be a disease.
12:26:17 <monochrom> "good notation comes later" implies never, once you take human herd psychology into account
12:26:24 <Entroacceptor> if using regex-tdfa increases the filesize from 2.9mb to 9.4mb, what's the alternative?
12:26:26 <Cale> I don't mean any offense by that though, often the results really are good notations with nice topological intuition to back algebraic correspondences.
12:27:12 <Cale> (String diagrams in particular are really lovely in a bunch of settings)
12:27:42 <dicey> monochrom: if you dont believe good notation comes later, you should get a decent book on the history of maths...and follow just one subject, say elementary algebra
12:27:55 <dicey> and watch how the notation changes over the centuries
12:27:56 <Cale> monochrom: Nah, notation has changed dramatically and rapidly in the last few decades.
12:28:18 <Cale> Category theory has had a good bit to do with it.
12:28:42 <Cale> "f: X -> Y" in particular wasn't around before CT :)
12:28:54 <dicey> That's a pretty big one ;)
12:28:59 <monochrom> "f(x)" is still around after CT
12:29:03 <Cale> so?
12:29:19 <monochrom> example of bad notation sticking around
12:29:20 <Cale> It's not a particularly bad notation.
12:29:31 <dicey> care to explain why you think f(x) is bad notation?
12:29:43 <Botje> think of it as f (x) instead, where f is applied to a one-tuple >:)
12:29:49 <Cale> Maybe x f would be better
12:30:06 <monochrom> not to mention that "f: X->Y" is inconsisent with "x ∈ ℤ"
12:30:08 <Cale> (so we could compose maps the right way around)
12:30:20 <companion_cube> x.f, object oriented category theory
12:30:32 <Cale> monochrom: ???
12:30:36 <dicey> monochrom: i think you're very confused.
12:31:15 <monochrom> one should write either consistently "f:ℤ→ℤ, 5:Z" or "f∈Z→Z, 5∈ℤ"
12:31:58 <cheater_> yeah, no.
12:32:48 <cheater_> that's like saying if the variable "rounds" is hard-coded to 2, your code should just have a 2 there everywhere.
12:32:50 <dicey> f: X->Y is a generic statement. it says nothing about what X or Y is. how could it be inconsistent unless you add another line, making it so? even then it would be hard, because you have said nothing about X or Y
12:33:09 <dicey> X could equal Y, for instance
12:33:27 <Cale> You could, if you wanted to be particularly arrowy, write 5: 1 -> Z
12:33:28 <monochrom> I am not talking about X,Y being the same or being different.
12:34:06 <ziman> : vs. ∈
12:35:23 <monochrom> I am talking about: if you take set theory as pervasive, you have a set of functions X→Y, you have a member f of that set, so why not f ∈ X→Y
12:35:23 <dicey> if you think f: X -> Y is bad notation, then you pretty much think half of category theory is bad notation and by association...haskell as well!
12:35:47 <Cale> f: X -> Y is like a three-part relation specifying the domain and codomain of the arrow f in some (implicit) category.
12:36:01 <monochrom> I am not talking about arrows
12:36:42 <Cale> If you wanted to express that f belonged to some set of maps, you can certainly do so
12:36:57 <Cale> You can write f in C(X,Y)
12:37:10 <Cale> (or Hom, if you prefer, or you can use Y^X)
12:37:17 <dicey> you would generally only want to do mention that f is a member of some family of functions if you wanted to mention them. it confuses the issue if it's not relevant.
12:37:34 <monochrom> there is no CT in sight in most textbooks on set theory, real analysis...
12:37:40 <Cale> (the latter only being appropriate in Set, if you're going to use element-of)
12:37:47 <dicey> that's because set theory is passe.
12:37:56 <dicey> it's a tiny tiny thing
12:39:07 * wli is quite unclear on how category theory applies to analysis.
12:39:31 <Cale> wli: In a bunch of ways.
12:39:33 <dicey> wli: its pretty much mandatory
12:39:39 <wli> Regardless, a better TeX with actual modern programming language developments would be very nice to have.
12:39:57 <danharaj> I can't get Yesod to work with postgresql :[
12:40:01 <wli> dicey: Mandatory? How is it that I've never seen it used even once?
12:40:11 <monochrom> I'm pretty sure "f:X→Y" is nice notation if you actively use CT
12:40:17 <dicey> wli: you have never written f: X -> Y?
12:40:59 <wli> dicey: Routinely, but I've never seen a commutative diagram employed for analysis purposes.
12:41:01 <monochrom> but let's say in baby Rudin you're pretty much in just set theory and there is no point adding a ":" when it is just special-cased to "∈"
12:42:05 <dicey> wli: well, if you care about geometry at all, for instance, it will come up ALL the time.
12:42:19 <Cale> monochrom: There is a point though. We want to drag as much notation from CT into the picture as we can, and if the reader is unfamiliar, we want to at least start introducing it gradually.
12:43:16 <dicey> if you start doing analysis on topological spaces that aren't the basic ones, like R^N, not using category theory would just be a handicap.
12:43:20 <wli> My diagramming competency is too low (or perhaps incompetency too high) to write effective expositions of much of anything.
12:43:39 <danharaj> CT was motivated by topology.
12:43:47 <danharaj> A lot of the big ideas in CT come directly from topology.
12:43:56 <dicey> and topology was heavily motivated by analysis.
12:44:52 <Cale> It's not much, but right now I'm thinking of the completion functor on metric spaces or normed vector spaces as being pretty relevant here.
12:45:04 <Cale> It also happens to be a monad (though in a somewhat boring fashion)
12:45:04 <byorgey> Hot off the press: http://themonadreader.wordpress.com/2011/07/05/issue-18/
12:46:14 <nickela> which type in Yesod must have hander that return generated png? For example getMyPngR :: String -> Handler [what needed here?]
12:46:59 <frusen> i need some help
12:47:35 <Cale> The unit is just the embedding of each space into its completion, and the multiplication has as its components the isomorphisms C(C(X)) -> C(X)
12:47:38 <byorgey> frusen: if you have a question, just go ahead and ask
12:48:30 <ski> (Cale : .. well, i assume it's a closure operator)
12:48:41 <dicey> Cale: how about the Stone-Cech compactification?
12:48:52 <danharaj> That's an adjoint functor.
12:48:56 <dicey> haven't seen a proof of that in a while without a diagram
12:49:19 <danharaj> so if you compose it with its adjoint, you get a monad and a comonad
12:49:24 <danharaj> depending on which way you compose them.
12:49:33 <Cale> yep, that too, though I'm not sure where we're drawing the line between topology and the rest of analysis
12:49:47 <danharaj> analysis is the topology of metric spaces :p
12:49:57 <wli> My understanding of analysis is very antique, pre-1900 even.
12:50:06 <Eduard_Munteanu> Complete metric spaces in fact, no?
12:50:22 <dicey> i dont even think they should TEACH "analysis" in it's traditional form to math students. maybe some sort of applied version for engineering students.
12:50:29 <dicey> typical case of pedagogy falling behind results.
12:50:32 <danharaj> Eduard_Munteanu: Do you consider the cauchy completion to be analysis proper?
12:50:57 <Eduard_Munteanu> Oh, well I guess so.
12:51:05 <danharaj> I mean it's a fair point.
12:51:06 <Cale> ski: up to isomorphism, yes :)
12:51:18 <dicey> wli: read Topology, by Munkres.
12:51:21 <dicey> open your mind!
12:51:27 <Cale> and of course, closure operators are monads
12:51:35 <Eduard_Munteanu> Wha?
12:51:36 <Eduard_Munteanu> Oh.
12:51:36 <danharaj> argh.
12:51:43 <danharaj> I can get yesod to work with sqlite but not postgresql
12:51:51 <danharaj> I think I am messing up my hdbc-postgresql install.
12:51:51 <Cale> If you have any preorder, it's a category, and closure operators on it are monads. :)
12:52:08 <Eduard_Munteanu> I'm not sure how that goes, though 'join' does look closure-ish
12:52:27 <dicey> every time i hear some math student lauding "baby rudin," i cringe a little =p
12:52:29 <dicey> so outdated.
12:52:38 <wli> I won't have the money for it in the foreseeable future.
12:52:40 <dicey> although his problems are indeed nice
12:52:57 <wli> dicey: Whittaker & Watson ...
12:53:01 <Eduard_Munteanu> (also wondered if there was such a connection)
12:53:02 <kmc> what's my favorite analysis book?  yeah, you probably haven't heard of it.  it's still underground
12:53:06 <Cale> Well, suppose (S,<=) is a preorder. Form a category whose objects are elements of S, and where there is a single arrow x -> y whenever x <= y (and no others)
12:53:13 <kmc> rudin is way too mainstream
12:53:18 <kmc> i liked their early work better
12:53:24 <dicey> real analysis: modern techniques and their applications, by Folland.
12:53:26 <dicey> now there's a good book.
12:53:28 <Cale> Functors between preorder categories correspond to monotone maps
12:53:29 <monochrom> I'm continuing with notations such as "f(x)" in #haskell-blah
12:53:37 <Eduard_Munteanu> Yeah.
12:53:59 <copumpkin> kmc: dude, I was reading it before it was published
12:54:06 <jdhky`> read folland, work problems in rudin (baby, then big)
12:54:23 <kmc> preprints = leaked unmastered tapes
12:54:35 <copumpkin> that's cool, right?
12:54:50 <copumpkin> I have skinny jeans on, I promise!
12:54:50 <kmc> i only read the rudin b-sides
12:54:50 <Cale> and if F,G: C -> D are two functors/monotone maps, then a natural transformation eta: F -> G consists of component arrows eta_X: FX -> GX in D, which says that for each X in C, we have FX <= GX in D, basically saying that F is dominated by G.
12:54:51 <jdhky`> kmc: you've probably never even seen rudin live
12:55:25 <Cale> (we don't have to worry about commutativity, because the arrows are unique where they exist)
12:55:35 <kmc> i saw them in a dive bar in Williamsburgh under the G train tracks
12:55:44 <Eduard_Munteanu> I see...
12:56:58 <Cale> So what is a monad now? Well, if we have some preorder category C, then a monad is a monotone map T: C -> C, together with natural transformations eta: 1 -> T, and mu: T^2 -> T, saying that x <= Tx for all x, and T(Tx) <= Tx for all x.
12:57:12 <Cale> Which is pretty much the definition of a closure operator
12:57:32 <thoughtpolice> byorgey: cute editorial for TMR18 :)
12:57:36 <Eduard_Munteanu> Ah, yeah that looks a lot like the axioms of closure operators.
12:57:45 <Eduard_Munteanu> Nice, thanks.
12:58:04 <Cale> an adjunction, btw, is a Galois connection
12:58:14 <frusen> onlyLowerAndSpace st = [c | c <- st, c `elem` ['a'..'z'] && elem c [' ']]         what am i doing wrong here?
12:58:24 <Eduard_Munteanu> Ah. I'm not familiar with those (yet).
12:58:27 <frusen> it just spits out ""
12:58:59 <Cale> frusen: There are not many characters c which are both lowercase letters and spaces
12:59:02 <byorgey> thoughtpolice: thanks =)
12:59:10 <Cale> (simultaneously ;)
12:59:19 <Eduard_Munteanu> But I suppose I'll keep that in mind in case I need to make a connection between algebra and CT.
12:59:25 <Cale> frusen: perhaps you meant || instead of &&
12:59:52 <frusen> Cale: *facepalm*
13:00:01 <thoughtpolice> byorgey: how frequent is TMR on average these days? once every 6 months or so?
13:00:05 <Cale> Order theory is a specialisation of category theory. (and I always like to look at what happens with orderings when faced with a new categorical concept)
13:00:17 <thoughtpolice> i should probably just look at the release dates of the past 2 or 3 issues :P
13:00:30 <byorgey> thoughtpolice: it varies.  the ideal is once every 4 months or so but not sure what my average has been.
13:01:03 <zmoazeni> Could someone help me figure out how to mentally parse this statement? newtype State s a = State (s -> (a, s)) (from the State monad). I'm slowly picking up on the usefulness of newtype's, and I get that the right hand side wants a function that maps s to a tuple (a,s). But the "State s a" on the left hand side throws me.
13:01:17 <tommd> zmoazeni: Use hpaste.org
13:01:22 <tommd> Oh, nevermind
13:01:33 <tommd> my brain thought all the text was going to be code.
13:01:35 <Cale> zmoazeni: on the left hand side is the name of the type being defined
13:01:48 <Cale> zmoazeni: the = is a little bit misleading perhaps
13:02:08 <Cale> zmoazeni: let's rename one of the "State"s being defined
13:02:15 <zmoazeni> Is it the same as declaring "a -> b" in function definitions? s and a are different types?
13:02:18 <Cale> newtype State s a = S (s -> (a,s))
13:02:28 <frusen> Cale: hehe works fine now. kind of embarrassing but thanks for your help
13:02:29 <Cale> (to clarify things)
13:02:41 <Cale> State is a type constructor, it will appear on the right side of ::
13:03:07 <Cale> S is a data constructor, and is a function of type  (s -> (a,s)) -> State s a
13:03:09 <hpaste> rovar pasted “xml” at http://hpaste.org/48762
13:03:26 <Cale> (they can both have the same name if we like, because they live in separate namespaces)
13:03:35 <Cale> frusen: no problem :)
13:03:53 <dicey> i wonder how hard it would be to make a fractal rendering system in haskell. probably easier than many many other languages
13:04:13 <rovar_> hey all:  hpaste.org/48762
13:04:15 <Cale> dicey: parallelising it will even be fun
13:04:39 <byorgey> dicey: yeah, probably pretty easy
13:04:42 <rovar_> I have some debug trace and i'm hoping to take the first 10 items produced.. but it seems to be processing the entire file whilest producing 0 output.
13:04:53 <dicey> maybe ill try to make that my first "big" project.
13:04:57 * hackagebot git-annex 3.20110705 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20110705 (JoeyHess)
13:04:59 <dicey> but it wont have a frigging GUI.
13:05:11 <kmc> yeah, GHC Haskell supports a nice style of parallelism without explicit threads
13:05:14 <zmoazeni> Cale: I think that's what I need to read up/play with. Data constructors that are function types. I'm used to the simpler examples like on http://www.haskell.org/haskellwiki/Constructor
13:06:18 <sm> cool.. another end-user app on hackage
13:06:43 <Cale> zmoazeni: Well, really we're saying that a value of type State s a is really the same thing as a function s -> (a,s), but we're going to require this wrapper function S to make the type system happy (though any good compiler will boil it away to nothing when compiling)
13:06:52 <kmc> zmoazeni, to first approximation, you can read "newtype" as "data"
13:07:20 <zmoazeni> What's not clicking in my head is why not "newtype State s = ..." why "newtype State s a = ..."
13:07:28 <chrisdone> Anyone tried haskell-emacs?
13:07:35 <kmc> zmoazeni, because it needs two parameters
13:08:09 <Cale> zmoazeni: because the computations we're trying to represent are things which do some work on a "global" state of type s, while producing a result of type a
13:08:37 <Cale> zmoazeni: and we're modelling such things as functions which take the initial state, and produce a final state, together with their result
13:09:44 <Aune> Hello all, Im currently writing a small adventure game in order to learn Haskell better, would appreciate some input. I have an Hpaste up at : http://hpaste.org/48763
13:10:10 <zmoazeni> Something may have just clicked thinking about "data Maybe a = Nothing | Just a"
13:12:16 <HugoDaniel> thanx Cale, i've just finished watching the spj video
13:12:18 <HugoDaniel> yes
13:12:30 <benmachine> Aune: once you've got an Obj, all you can do it get its name and description
13:12:31 <HugoDaniel> denotational semantics is quite the powerfull thingy
13:12:40 <benmachine> Aune: so you might as well just have a pair of strings
13:13:01 <HugoDaniel> kind of redefines what i've learnt about software engineering in univ.
13:14:02 <HugoDaniel> operational semantics are total steroids for most apps
13:14:11 <Aune> benmachine, do you mean that ias soon as I make something an Obj all other properties are lost, so that there is no way to recover the Container part of such an Obj?
13:14:33 <ski> Aune : yes
13:14:41 <Aune> bugger
13:14:54 <benmachine> heh
13:15:39 <ski> i would possibly start with an algebraic type of objects ..
13:15:54 <ski> do you want/need the extensibility of existentials ?
13:16:33 <rovar_> if BZip.decompress returns a lazy bytestring, and I'm using xml-enumerator which takes a lazy bytestring,  I should be mostly assured that it won't read the entire file before processing..
13:16:43 <ski> (btw, obviously you could add `toContainer :: Object o => o -> Maybe Container', if you wanted to)
13:16:56 <rovar_> is there some bit of my code which might lead it to do so?
13:17:13 <Aune> I dont actually know, I wanted to be able to nest containers, and I thought I could do that by separating the Object and the Container properties
13:17:37 <benmachine> Aune: nesting containers isn't hard
13:17:51 <benmachine> Aune: after all, non-empty lists contain smaller lists, in effect
13:18:34 <benmachine> rovar_: there are a few things which might do that, like taking the length of the output, or hanging on to the beginning of the output before processing
13:18:47 <Aune> Yeah, in retrospect it seems like data Object = Trinket | Chest [Object] should have been way better
13:18:52 <benmachine> yep
13:18:59 <ski> maybe, maybe not
13:19:03 <ski> it would be simpler, anyway
13:19:53 <dicey> are you allowing a specific chest to be opened or closed?
13:20:10 <ski> Aune : are your `Room's situated in a rectangular grid or something ?
13:20:12 <Aune> Yes, and possibly lockable
13:20:27 <Aune> shi, Yes
13:21:17 <ski> Aune : i found it somewhat strange that you appear to want to externally specify connections between `Room's; but, otoh, a `Player' *contains* (not *references*) a `Room'
13:21:50 <dicey> ski: maybe Aune is a nihilist.
13:22:20 <Aune> ski, Meant to (x,y) as a key in the Data.Map. And the reference to the room in Player would be the current room the player is in.
13:22:36 <ski> Aune : in a small text-adventure i made, the top-level context contained both the local player data, and the current room (which contained all other rooms) .. just mentioning this as a possibility (with certain disadvantages, at least as i did it)
13:22:55 <dicey> would there be anything wrong with the player containing the room?
13:23:15 <ski> Aune : wouldn't it make more sense to have a coordinate for the room inside `Player', then ?
13:23:27 <ski> dicey : not necessarily
13:24:40 <Aune> ski, it might.
13:24:59 <dicey> it will be interesting to see how you handle a player moving between rooms
13:25:37 <Aune> ski, I have to have the coordinate somewhere, so that might be a better solution
13:26:37 <Aune> dicey, random room?
13:27:58 <ski> Aune : it seems to me that otherwise you'd had duplicated/redundant infomation, the current room both in `Player' and in your world-map
13:28:27 <ski> (dicey : .. in my case, i did pointer-reversal :)
13:29:37 <Aune> ski, how did that work?
13:29:45 <dicey> seems like there are many possibilities. for instance, you could abandon coordinates even, and just describe the connections between the rooms. like say a is a specific room in the set of rooms A, d is an exit in the set of room exits, so the movement function would be a -> d -> a, or something like that. then you wouldn't be restricted at all to being ona plan
13:30:06 <dicey> you could even make a situation where the player enters a room, and from there goes into a circular setup in which he can never escape, or a neverending path, whatever
13:30:44 <benmachine> zippers! zippers solve everything
13:33:20 <edwardk> *zip*
13:33:42 <Aune> How would I use zippers in this case
13:34:23 <edwardk> zippers into rooms is awkward because you typically have cycles in the room graph, etc.
13:34:39 <edwardk> i'd recommend using a map and giving out keys into the map as 'references'
13:34:55 <Aune> Oh, good.
13:38:28 <hpaste> rovar_ pasted “aarg” at http://hpaste.org/48764
13:38:41 <rovar_> benmachine,  I'm fmapping  BZip.decompress over ByteString.readFile  (because of the IO monad)  that wouldn't result in a space leak , would it?
13:39:14 <rovar_> i'm not even getting any "You are here" messages.. nor exceptions..
13:39:55 <benmachine> I wouldn't really expect you to get You are here messages
13:40:22 <rovar_> because I'm not using the resulting value?
13:40:30 <benmachine> right
13:41:01 <ski> Aune : every room contained all rooms reachable from it, except the one it was reached from. so as a (bidirectional) passage between rooms were used, the old current room would become a child of a new current room (with passage reversed), except the new curren room passage was removed from the old current room
13:41:09 <rovar_> I'm facing the prospect that it is just failing to parse the xml and therefore not matching any element tags.. or it's trying to load the whole thing
13:41:34 <Aune> Now, to get back to the question of objects, the reason I placed it in a type class to begin with was that I thought it would be much easier to add objects afterward than if I used an algebraic data type. But obviously that didn't work as I expected. So, hoe does one assure that it is easy to add objects. Algebraic data types seemed wrong to me since it kind of brakes pattern matching to add stuff afterwards.
13:43:37 <benmachine> Aune: well, if you don't update the code that doesn't know about the new object, what is it supposed to do?
13:43:39 <Aune> ski, Does that work well with loops in the graph over the room?
13:44:14 <ski> Aune : it didn't :) that's the caveat i was mentioning
13:44:51 <ski> (Aune : i realized that from the start of course, but doing pointer-reversal sounded fun enough to do it that way anyway)
13:45:00 <benmachine> Aune: if it can do something sensible, you can just use a _ pattern, and pattern matching won't break
13:45:22 <benmachine> Aune: if it can't do something sensible, you'll need to update the code anyway, so it's ok that pattern matching breaks
13:46:39 <ski> Aune : if you want to be able to add new kinds of objects easily, indeed records are better than variants
13:46:55 <Aune> benmachine, that seems reasonable, the stuff I was thinking about was to add keys or edible items later, you should be able to inspect all but other than that their use should be orthogonal.
13:47:21 <ski> Aune : as i mentioned, you could add an `toContainer :: Object o => o -> Maybe Container' operation to your `Object' class
13:48:17 <Aune> ski, yeah, that seems reasonable.
13:49:06 * hackagebot seclib 0.7 - A lightweight library for Information-flow security in Haskell  http://hackage.haskell.org/package/seclib-0.7 (AlejandroRusso)
13:52:24 <zmoazeni> Cale, kmc: Thanks guys. It took a little tinkering with but I think I got it. I get that "State s" is a function and it stays that way until you supply it the param "a".
13:52:50 <zmoazeni> Going through the game example on http://www.haskell.org/haskellwiki/State_Monad helped bring the concept closer home
13:52:51 <roconnor> the param "s".
13:53:38 <zmoazeni> roconnor: Do I have them swapped? From this definition "newtype State s a = State (s -> (a, s))", "a" seems like the param
13:54:10 <roconnor> "a" is part of the result; it is to the right of the arrow
13:54:25 <benmachine> roconnor: it's a parameter of State s though
13:54:31 <roconnor> oh
13:54:32 <roconnor> sorry
13:54:46 <roconnor> zmoazeni: yes "a" is a parameter to (State s)
13:55:08 <zmoazeni> ok whew. You almost broke the fragile grip on had on it :)
13:55:12 <roconnor> sorry
13:55:35 <roconnor> @kind (State s)
13:55:36 <lambdabot> Not in scope: type variable `s'
13:55:41 <roconnor> @kind (State S)
13:55:42 <lambdabot> Not in scope: type constructor or class `S'
13:55:44 <roconnor> bah
13:55:53 <Cale> :k State Int
13:55:53 <lambdabot> * -> *
13:58:12 * hackagebot entropy 0.1 - A platform independent entropy source  http://hackage.haskell.org/package/entropy-0.1 (ThomasDuBuisson)
13:58:37 * roconnor wants a platform independent entropy source
13:59:01 <tommd> good!
13:59:37 <roconnor> tommd: does it give me access to something like /dev/random or /dev/urandom on linux?
14:00:14 * hackagebot crypto-api 0.6.3 - A generic interface for cryptographic operations  http://hackage.haskell.org/package/crypto-api-0.6.3 (ThomasDuBuisson)
14:00:18 <benmachine> A platform independent method to obtain cryptographically strong entropy (devurandom on Linux, CryptAPI on Windows, patches welcome) Users looking for cryptographically strong (number-theoretically sound) PRNGs should see the DRBG package too!
14:00:36 <benmachine> tommd: looks like the weird parsing of the synopsis field is eating your slashes
14:00:58 <benmachine> (it would be useful for it to not do that, maybe I should file a hackage bug)
14:01:30 <roconnor> this is perfect
14:01:45 <tommd> That or if someone could document what is legit syntax in a synopsis, it would be good.
14:02:08 <tommd> roconnor: Yes, it's just the crypto-api's System.Crypto.Random module moved over
14:02:18 <tommd> roconner: So /dev/urandom and windows CryptAPI
14:02:46 <tommd> Some people don't like the deps and build time that comes with crypto-api.  Hence the move.
14:03:22 <roconnor> good
14:03:40 <roconnor> I probably would have been one of those people :)
14:13:03 <erus`> > let meh = (+++ p <<)
14:13:04 <lambdabot>   <no location info>: parse error on input `)'
14:13:38 <erus`> i wanna do  noHtml `meh` "Hello"
14:16:08 <erus`> let meh x y = x +++ paragraph << y
14:16:16 <erus`> i need that as an inline func :)
14:18:26 <erus`> fuck yea im good at haskell
14:18:30 <erus`> im an fp god
14:26:07 <ski> erus` : `(<<) . (+++ paragraph)' or `(. (paragraph <<)) . (+++)' (depending on precedence) ?
14:27:41 <Nisstyre> http://steve-yegge.blogspot.com/2010/12/haskell-researchers-announce-discovery.html
14:27:45 <Nisstyre> lol'd
14:27:57 <benmachine> seven months old :P
14:28:19 <hpaste> untwisted pasted “Trying to walk” at http://hpaste.org/48765
14:28:55 <Nisstyre> benmachine: yeah, I just discovered his blog
14:31:00 <untwisted> Hi, would anyone mind helping me with a function I'm trying to write? I want to do something similar to Python's os.walk, but I'm having some trouble with the last few lines. Code is pasted at http://hpaste.org/48765
14:31:30 <tommd> What is the goal?
14:32:03 <untwisted> To traverse a directory tree and find all files that pass a filter function f
14:33:38 <benmachine> untwisted: what's going wrong?
14:34:10 <benmachine> untwisted: also, you may be interested in the </> operator from System.FilePath
14:34:56 <erus`> how do i do findIn or findFirstOf list?
14:35:12 <untwisted> benmachine: I'm having trouble with the part where I recurse to the subdirectories. I want my return type to be [FilePath] (a list of all the files that pass the filter), so I *thought* I wanted to fold using walk as my function, but I'm getting lots of type errors, and now I'm not even sure that is the correct approach
14:35:41 <untwisted> benmachine: and now I have people outside my office, gotta run. I'd love to chat about this when I get back if you're still here though
14:36:21 <benmachine> untwisted: oh, it'll have to be IO [FilePath]
14:36:46 <benmachine> erus`: it would help if you were more specific, but at a guess try Data.List.find
14:36:50 <benmachine> :t find
14:36:50 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
14:37:02 <erus`> find works
14:37:14 <erus`> this cgi stuff is great
14:37:21 <erus`> better than snap and all that rubbish
14:38:59 <nihtml> > find (<3) [1..10]
14:39:00 <lambdabot>   Just 1
14:39:22 <nihtml> > find (>3) [1..10]
14:39:23 <lambdabot>   Just 4
14:39:43 <nihtml> > find (>9000) [1..10]
14:39:44 <lambdabot>   Nothing
14:39:57 <ski> > find (> 9000) [0 ..]
14:39:58 <lambdabot>   Just 9001
14:40:02 <ski> > find (< 9000) [0 ..]
14:40:03 <lambdabot>   Just 0
14:40:16 <ski> > find (< 0) [0 ..]
14:40:19 <lambdabot>   mueval-core: Time limit exceeded
14:41:07 <erus`> is restful just using blah?something=foo
14:42:46 <parcs> i believe rest 'means' using get put post and delete
14:43:16 <erus`> I used 'get' for my last site and some guy said it should be restful instead
14:44:16 <parcs> @google what exactly is restful programming
14:44:17 <lambdabot> http://stackoverflow.com/questions/671118/what-exactly-is-restful-programming
14:44:17 <lambdabot> Title: http - What exactly is RESTful programming? - Stack Overflow
14:44:53 <monochrom> gosh, "about verbs", bullshit
14:45:10 <gwern> monochrom: is it actually about monoid and referential transparency, then?
14:45:18 <monochrom> how do computers know that you're using a verb vs a swear word
14:45:51 <gwern> run it through nanny software. if it gets filtered...
14:46:36 <erus`> fuck is a very ambiguous word
14:46:42 <monochrom> but it has good concrete examples
14:47:02 <blackh> erus: I found it useful for explaining how I feel about git.
14:47:32 <monochrom> well, "add user, edit user, delete user" example : RESTful :: "circles, squares, triangles" :: OOP
14:50:01 <dropdrive> "ghc --print-libdir" doesn't include $HOME/.cabal --- is this right?
14:54:59 <monochrom> it is right
14:55:19 <gwern> doesn't here either, but my system works fine
14:55:25 <gwern> so monochrom is probably right
14:55:34 <monochrom> ghc does not need to know about $HOME/.cabal
14:56:00 <dropdrive> monochrom: When I "./Setup configure" I get a complaint about a lib not being installed; but I just installed it using cabal install.  Hmm.
14:57:25 <monochrom> "./Setup configure" has implicit --global. "cabal install" has implicit --user. do you see the consequence?
14:58:52 <hpaste> erus` pasted “compile error” at http://hpaste.org/48766
14:59:27 <monochrom> ghc's so-called "libdir" no longer has significance in "where are the libs?". maybe it had that significance many years ago, I forgot
14:59:34 <erus`> any ideas guys?
15:00:26 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml for real facts (not speculations based on how linux c libs do things) on how ghc knows its libs
15:01:55 <monochrom> mismatch between CGIT IO blah vs IO blah. this may be a case of missing a liftIO
15:02:28 <erus`> monochrom: hmm but i dunno where to put it
15:02:42 <monochrom> liftIO (takeMVar blah). liftIO (putMVar blah junk)
15:03:14 <monochrom> liftIO (readMVar blah)
15:03:19 <monochrom> I think that's it
15:04:13 <erus`> thanks monochrom
15:04:27 <erus`> the liftIOs make it a little harder to read tho :|
15:04:52 <monochrom> I agree to disagree
15:07:58 <erus`> ah man
15:08:45 <erus`> forgot to save the state between page loads
15:08:55 <monochrom> haha
15:16:40 <ddarius> How can someone write "\ss -> reducer $ partition k ss" ?
15:17:13 <c_wraith> fear of pointless code
15:17:23 <ddarius> @pl reduceF k reducer ss = reducer $ partition k ss
15:17:23 <lambdabot> reduceF = flip (.) . partition
15:18:09 <ddarius> It gets worse and worse.
15:20:27 <ski> c_wraith : and fear of brackets
15:21:18 * ski doesn't understand why to try to cram `$' into everything ..
15:21:28 <kmc> cash rules everything around me
15:21:43 <monochrom> hahaha
15:22:05 <c_wraith> ski: $ is less annoying to type than ( and )
15:22:20 * ski . o O (define-cash not-my-cash (cash-rules () ...))
15:22:30 <ski> c_wraith : only in some circumstances
15:22:50 <monochrom> someone wrote a style guide that says "use $", then someone else followed it
15:22:51 <ski> i definitely prefer `\ss -> reducer (partition k ss)' to `\ss -> reducer $ partition k ss'
15:23:31 <monochrom> this is why I don't suggest $ to newbies. I just say "take 10 (map f xs)"
15:23:56 <edwardk> bah, reducer . partition k
15:24:55 <edwardk> i was going to say, i like $, but then in the context of the current discussion that might get misinterpreted, on the other hand, under both interpretations it is a true statement, so i like $.
15:25:16 <kmc> haha edwardk
15:25:31 <kmc> > ($) > (♥)
15:25:31 <lambdabot>   Not in scope: `
15:25:58 <edwardk> > "$" > "♥"
15:25:59 <lambdabot>   False
15:26:05 <edwardk> lambdabot disagrees
15:26:17 <c_wraith> @vixen money or love?
15:26:17 <lambdabot> let's don't talk about that
15:26:23 <monochrom> smart
15:26:26 <kmc> yes
15:26:31 <benmachine> @vixen that doesn't even grammar
15:26:31 <lambdabot> Is that a real poncho or is that a Sears poncho?
15:26:35 <benmachine> :<
15:26:45 <kmc> @vixen Let's get down to brass tacks here.  How much for the ape?
15:26:45 <lambdabot> panties and bras are for weaklings. I like to be free.
15:27:06 <c_wraith> that answer confuses me
15:30:05 <xil> hi. Cabal says that I'm missing the C GL library  when I try installing OpenGl and GLUT
15:30:24 <xil> sorry, the question is, what package am I looking for? Or could it just be a config thing?
15:31:08 <danharaj> xil: You'll need to find where your platform puts its opengl library stuff. Alternatively, haskell platform will take care of it for you if you want to install it.
15:31:28 <untwisted> benmachine: I'm back if you're still around.
15:31:49 <benmachine> untwisted: I should probably go to bed soonish but I can afford ten minutes or so
15:31:58 <benmachine> did you get what I said just after you left
15:32:02 <kmc> apt-get install libgl1-mesa-dev
15:32:03 <kmc> or something
15:32:16 <untwisted> benmachine: I got that the return type would be IO [FilePath] which makes sense
15:32:24 <xil> kmc: tried that, repo complains it doesn't have it, I don't know how to fix repo problems
15:32:33 <xil> danharaj: how do I do the haskell platform solution?
15:33:07 <untwisted> benmachine: am I crazy to think that I'd want to do a foldM (`walk` f) subd' acc (or something similar) as my last line?
15:33:24 <benmachine> :t foldM
15:33:25 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
15:33:27 <danharaj> http://hackage.haskell.org/platform/
15:33:32 <erus`> Is there an MVar which is persistant between process liftetimes?
15:33:42 <benmachine> walk doesn't match that typesig
15:33:49 <erus`> reading and writing to the same file is a bit tricky
15:33:53 <erus`> permission issues
15:34:11 <benmachine> erus`: if you want something persistent across invocations, that's what files are *for*
15:34:41 <kmc> that's what SysV shared memory is for!
15:34:47 <kmc> ...except it's actually less convenient than mmap()ing a file
15:35:27 <untwisted> benmachine: Hrm.
15:35:32 <xil> danharaj: ah okay, thanks
15:35:48 <Draconx> kmc, on the other hand, POSIX shared memory is pretty much exactly as convenient as mmaping a file.
15:35:48 <erus`> benmachine: I try to read a file and append something to it afterwords but the actions seem to be in the wrong order
15:35:48 * ddarius recommends just mutating the running OS code to change how it returns data.  That would be persistent across invokations though not restarts.  That's all you need right?
15:36:16 <benmachine> untwisted: oh, and ((foo ++ "/") ++) is better as (foo </>) using </> from System.FilePath
15:36:28 <benmachine> erus`: the joys of lazy IO.
15:36:46 <benmachine> erus`: don't use readFile or hGetContents, use openFile and hGetLine from System.IO
15:36:57 <erus`> i am...
15:37:07 <erus`> then closing and opening as append
15:37:12 <untwisted> benmachine: Oh cool! I'll check out that module, thanks
15:37:12 <benmachine> oh
15:37:14 <erus`> but i get permission error
15:37:14 <ddarius> readFile "foo" >>= writeFile "foo" . (replicate bufferSize '0' ++)
15:37:28 <benmachine> ddarius: eep
15:37:46 <benmachine> untwisted: not terribly important in the grand scheme of things, just makes things a bit neater
15:38:47 <ddarius> File locking spoils my fun.
15:38:53 <untwisted> benmachine: It is less system dependent so it is better :)  Can never be too sure when Windows will get angry about slash directions and whatnot :P
15:38:59 <benmachine> ddarius: heh, I thought it might :(
15:39:07 <benmachine> untwisted: yep
15:39:31 <erus`> @hoogle IOMode
15:39:32 <lambdabot> System.IO data IOMode
15:40:08 * ski ponders declaring local files ..
15:40:19 <benmachine> ski: local to what?
15:40:40 <ski> local to a program executable, e.g.
15:41:04 <benmachine> ski: isn't that more or less a global variable >_>
15:41:20 <benmachine> or would it actually be stored on the filesystem, just not accessible by anyone else
15:41:35 <ski> the point would be that it wouldn't be visible from outside processes running that code
15:41:46 <ski> aye
15:42:21 <ski> (of course, module debugging tools, blah blah)
15:43:12 <benmachine> untwisted: I think mapM (flip walk f) was the right idea, you just have to concat the result afterwards
15:43:32 <benmachine> untwisted: (if you're having to flip walk then maybe that's a sign the arguments should be the other way around?)
15:43:41 * wli generally writes straight-line-program command interpreters to provide some sort of vehicle for unit testing.
15:44:48 <untwisted> benmachine: Hmmm, I'll play with it and see what I come up with :)  thanks for your help!
15:45:54 <wli> e.g. something that lets you do insertion, removal, listing of items of some container implementation at a sort of mini-repl, use -main-is to generate an executable to use for testcases.
15:48:53 <dncr> if apackage-0.1 and apackage-0.2 both depend on bpackage-1.2, is it true that you cannot have apackage-0.1 an apackage-0.2 installed at the same time?  i keep getting: package iteratee-0.8.5.0 is broken due to missing package
15:48:57 <dncr> ListLike-1.1.0-b5bfa0434b0b71f2bf510fabee3ae686
15:49:09 <dncr> package iteratee-0.3.6 is broken due to missing package
15:49:09 <dncr> ListLike-1.1.0-b8223dfd42f2c2962b4ec2e6ab83ffed
15:54:43 <monochrom> having both apackage-0.1 and apackage-0.2 is fine if you're careful
15:55:10 <monochrom> your problem is you rebuilt ListLike
15:55:45 <monochrom> now you have to do: for each package p: if p depends on ListLike, rebuild p
15:55:46 <dncr> monochrom: can i tell cabal install not to rebuild it?
15:56:20 <dncr> why would cabal-install rebuild it if i already have that version
15:56:31 <dcoutts> because of other dependencies
15:56:56 <dcoutts> e.g. because your apackage-0.1 and apackage-0.2 require different versions of something that ListLike uses
15:57:10 <dcoutts> so ListLike has to be built against different versions of its dependencies
15:57:27 <dcoutts> and we can't install two instances of the same version of ListLike built against different deps (at the moment)
15:57:37 <monochrom> if I had complete unabridged history of what you did to your computer since the dawn of man, I could pinpoint it. but clearly, I don't, and you don't either.
15:58:18 <monochrom> but I have some known and tested scenerios in my http://www.vex.net/~trebla/haskell/sicp.xhtml
15:58:26 <dcoutts> dncr: as for asking it not to rebuild, not in current releases. You can see what it's going to do using --dry-run
15:58:56 <dcoutts> dncr: in the dev version you can specifically ask to use the installed instances of specific packages
15:59:08 <monochrom> the only way to win is not to play
15:59:35 <dcoutts> and there's a new solver we're working on which will also try to avoid making install plans that involve rebuilding existing packages (but may just fail instead)
16:00:06 <dcoutts> (or may install other versions rather than rebuilding an existing version)
16:01:03 <dncr> dcoutts: the system has no way of knowing that changing the dependencies which cause ListLike to be rebuilt don't actually matter, does it?
16:01:22 <monochrom> we know that it always hurts
16:01:24 <dcoutts> dncr: exactly, because in other similar looking situations it would matter
16:01:34 <dcoutts> dncr: and it has to be conservative
16:02:06 <dcoutts> dncr: we're working on a 80% solution for that too, adding enough info to see when it will not matter
16:02:09 <dncr> dcoutts: with the new solver, will it ever install two different version of ListLike-1.1.0 at the same time?
16:02:13 <dncr> oh ok
16:02:29 <dcoutts> dncr: there's no problem having multiple versions of the same package installed
16:02:37 <dcoutts> dncr: but it turns out that's not enough
16:02:50 <dcoutts> dncr: you actually need multiple instances of the same version
16:03:02 <dcoutts> and we don't have that at the moment
16:03:56 <dcoutts> dncr: the current solver will never pick a solution that involves using two versions of the same package
16:04:00 <dncr> dcoutts: if a package creates an executable like /usr/bin/lol does cabal-install allow multiple versions to be installed?
16:04:10 <dcoutts> dncr: yes
16:04:18 <dncr> dcoutts: and /usr/bin/lol is clobbered?
16:04:18 <dcoutts> note that it's possible to version the binaries
16:04:24 <dcoutts> dncr: yes, by default
16:04:49 <dncr> hm
16:04:50 <dcoutts> there's a --program-suffix flag to allow a binary versioning scheme
16:04:59 <cmccann> cabal-install has an awkward level of sophistication, it's not clever enough to be a package manager but not as dumb as a plain build system
16:05:18 <dncr> indeed
16:05:53 <dcoutts> dncr: e.g. the sensible thing to do is to use the binddir-symlink feature plus the program suffix thing, so that you get versioned binaries installed and an unversioned symlink to the latest
16:06:40 <dncr> what about treating library packages and executable packages differently
16:07:17 <dcoutts> what are you trying to achieve?
16:07:17 <ddarius> Chewing tobacco spit makes silver electroplating stick.
16:07:25 <dncr> eh idk
16:08:52 * hackagebot network-protocol-xmpp 0.3.3 - Client->Server XMPP  http://hackage.haskell.org/package/network-protocol-xmpp-0.3.3 (JohnMillikin)
16:09:10 <dncr> anyone know what became of Data.Iteratee.WrappedByteString
16:09:26 <dncr> after around iteratee-0.3 i guess i'll go digging
16:09:38 <Peaker_> Dcoutts hey, I read your stream fusion paper, great work! I was wondering if similarities to iteratee and fusion opportunities were considered similarly in that context... And a monday lifted stream like a ListT
16:10:23 <dcoutts> Peaker: I've not considered streams with effects
16:10:28 <dcoutts> though I know Roman has
16:10:45 <dcoutts> but mainly effects where the order doesn't matter, like writing into parallel arrays
16:12:01 <dcoutts> Peaker: but I don't see any particular problem with the implementation
16:12:16 <dcoutts> it's just about using non-recursive state transition functions
16:13:57 <Peaker_> I think Iteratees also stand to gain from the same fusion though they are consumer state machines rather than producer state machines
16:14:01 <Peaker_> It would require inverting their control and adding am explicit close call in the recursive engine at the end of consumption loop (unstream)
16:16:27 <dcoutts> Peaker: hmm, I'd not looked closely enough before to think of them as consumer rather than producer state machines
16:26:00 <bgamari> Man, the number hierarchy can be a real PITA
16:26:54 <bgamari> Is there no way to take an Int to a Real that doesn't fail for integers?
16:27:27 <parcs> yes, fromIntegral
16:27:28 <c_wraith> Real is a typeclass, not a type
16:27:41 <bgamari> c_wraith: Point taken
16:27:57 <bgamari> c_wraith: a Real type
16:28:07 <c_wraith> parcs's answer suffices then
16:28:14 <ClaudiusMaximus> @instances Real
16:28:15 <lambdabot> Double, Float, Int, Integer
16:28:24 <c_wraith> @src Real
16:28:24 <lambdabot> class  (Num a, Ord a) => Real a  where
16:28:24 <lambdabot>     toRational      ::  a -> Rational
16:28:34 <c_wraith> That's a bizarre definition, but ok
16:28:35 <ClaudiusMaximus> lolz
16:28:48 <ClaudiusMaximus> @type approxRational
16:28:49 <lambdabot> forall a. (RealFrac a) => a -> a -> Rational
16:29:07 <ClaudiusMaximus> that's what should be in Real imo
16:29:24 <bgamari> the problem is fromIntegral expects an Integral
16:29:30 <bgamari> typed argument
16:29:40 <c_wraith> > fromIntegral (5 :: Integer) :: Double
16:29:41 <lambdabot>   5.0
16:29:43 <benmachine> ClaudiusMaximus: two arguments?
16:29:56 <c_wraith> bgamari: are you looking for round and friends?
16:29:57 <ClaudiusMaximus> benmachine: yep, one is "how approximate"
16:30:01 <benmachine> oh
16:30:05 <benmachine> weeeird
16:30:06 <benmachine> but k
16:30:06 <bgamari> fromIntegral (3 :: Double) :: Double
16:30:11 <bgamari> > fromIntegral (3 :: Double) :: Double
16:30:12 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
16:30:12 <lambdabot>    arising from a use ...
16:30:27 <c_wraith> bgamari: why are you converting a double to a double? :)
16:30:28 <ClaudiusMaximus> > approxRational 0.12345 0.01 -- but i can never remember which...
16:30:28 <lambdabot>   1 % 8
16:30:54 <parcs> > fromIntegral (floor (3.14 :: Double)) :: Double
16:30:55 <lambdabot>   3.0
16:30:59 <benmachine> @hoogle approxRational
16:30:59 <lambdabot> Data.Ratio approxRational :: RealFrac a => a -> a -> Rational
16:31:09 <benmachine> oh, I never knew that existed
16:31:15 <benmachine> > toRational pi
16:31:16 <lambdabot>   884279719003555 % 281474976710656
16:31:37 <ClaudiusMaximus> the source is a bit weird, it tries to find the "simplest" rational in the range...
16:31:44 <bgamari> c_wraith: My value is just a Num, I know nothing other than that
16:31:51 <bgamari> c_wraith: I want to cast it to something Fractional
16:32:04 <bgamari> Or really something Floating I guess
16:32:17 <c_wraith> bgamari: Num doesn't give you that much power.  You need more power.  Use the Real typeclass.
16:32:38 <c_wraith> bgamari: for instance, how do you convert a 5x5 matrix to a Float?
16:33:52 <dobblego> why is RWS r w s a, which is equivalent to ReaderT r (StateT s (Writer w)) a, called RWS and not RSW?
16:33:59 <bgamari> c_wraith: Alright, I'll use Real in that case
16:34:39 <c_wraith> bgamari: remember that these things generally aren't polymorphic at runtime
16:35:19 <ski> @unmtl ReaderT r (StateT s (Writer w)) a
16:35:19 <lambdabot> r -> s -> (a, s, w)
16:35:20 <ski> @unmtl ReaderT r (WriterT w (State s)) a
16:35:20 <lambdabot> r -> s -> (a, w, s)
16:35:30 <dobblego> oh
16:36:10 <bgamari> c_wraith: Again, it seems fromIntegral wants an Integral type
16:37:31 <c_wraith> :t realToFrac -- bgamari
16:37:32 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
16:37:39 <c_wraith> @instances Fractional
16:37:40 <lambdabot> Double, Float
16:38:08 <bgamari> Ahh, fair enough
16:38:10 <bgamari> Thanks!
16:38:20 <c_wraith> bgamari: basically all the Real constraint gives you is the knowledge you can use realToFrac :)
16:39:15 <dicey> realtofrac???? what would it do to pi?
16:39:28 <bgamari> approximate it I believe
16:39:33 <c_wraith> > realToFrac pi :: Double
16:39:34 <lambdabot>   3.141592653589793
16:39:39 <c_wraith> > realToFrac pi :: Float
16:39:40 <lambdabot>   3.1415927
16:39:58 <c_wraith> > realToFrac pi :: Rational
16:39:58 <lambdabot>   884279719003555 % 281474976710656
16:40:20 <c_wraith> I guess it's defaulting "pi" to Double there
16:40:24 <dicey> lol
16:40:32 <dicey> i find that function insulting!
16:40:34 <c_wraith> > pi :: CReal
16:40:35 <lambdabot>   3.1415926535897932384626433832795028841972
16:40:50 <c_wraith> > realToFrac (pi :: CReal) :: Rational
16:40:50 <lambdabot>   *Exception: CReal.toRational
16:40:54 <c_wraith> haha
16:42:50 <c_wraith> dicey: yeah, the worst part of the haskell number hierarchy is the names.
16:43:08 <ski> > showCReal 100 pi
16:43:09 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
16:43:11 <c_wraith> What's a better name for Real?  Scalar?
16:43:53 <dicey> might as well just call the function thingToThing
16:43:55 <c_wraith> > realToFrac (1 :+ 3) :: Double
16:43:56 <lambdabot>   No instance for (GHC.Real.Real (Data.Complex.Complex t))
16:43:56 <lambdabot>    arising from a ...
16:44:01 <c_wraith> That's what I thought.
16:44:14 <c_wraith> The Real typeclass would have been much better-off if it was named Scalar
16:44:38 <dicey> unless it knows certain things about reals
16:44:40 <arw__> not quite. there are complex scalar values...
16:44:44 * cmccann reads Real as meaning "rational numbers that we're handwaving as being reals"
16:44:46 <ski> why `Scalar' ?
16:45:17 <c_wraith> ski: my understanding of the term was that it involved only a single axis, which would eliminate things like matrices and complex numbers
16:45:22 <parcs> > map (head &&& length) $ group $ sort $ drop 2 $ showCReal 100 pi
16:45:23 <lambdabot>   [('0',8),('1',8),('2',12),('3',11),('4',10),('5',8),('6',9),('7',7),('8',13...
16:45:41 <ski> c_wraith : yeah, but what does that has to do with converting to rationals ?
16:45:43 <parcs> > map length $ group $ sort $ drop 2 $ showCReal 1000 pi
16:45:44 <lambdabot>   [93,116,103,102,93,97,94,95,101,106]
16:45:45 <dobblego> @unmtl ReaderT r (WriterT w (State s)) a
16:45:45 <lambdabot> r -> s -> (a, w, s)
16:45:50 <parcs> > map length $ group $ sort $ drop 2 $ showCReal 10000 pi
16:45:54 <lambdabot>   mueval-core: Time limit exceeded
16:46:22 <parcs> > map length $ group $ sort $ drop 2 $ showCReal 5000 pi
16:46:24 <lambdabot>   [466,531,497,459,508,525,513,488,492,521]
16:46:28 <c_wraith> ski: hmm.  Yes, I guess it's insufficient.
16:47:51 <ski> dobblego : all of `ReaderT r',`StateT s',`WriterT w' commutes
16:48:07 <dobblego> ski: yeah cheers
16:48:22 <ddarius> Complex numbers are often used as "scalars."
16:48:53 <dobblego> ski: just trying to agree with that completely :)
16:49:28 <c_wraith> preflex: seen byorgey
16:49:28 <preflex>  byorgey was last seen on #haskell 3 hours, 44 minutes and 55 seconds ago, saying: dicey: yeah, probably pretty easy
16:49:58 <c_wraith> byorgey: I don't think I understand your editorial :)
16:50:38 <dobblego> @unmtl ReaderT r (WriterT w (StateT f s)) a
16:50:39 <lambdabot> r -> f -> s (a, w, f)
16:50:45 <dobblego> @unmtl ReaderT r (WriterT w (StateT s f)) a
16:50:45 <lambdabot> r -> s -> f (a, w, s)
16:50:57 <dobblego> @unmtl ReaderT r (StateT w (WriterT s f)) a
16:50:57 <lambdabot> r -> w -> f (a, w, s)
16:51:17 <parcs> > sortBy (flip $ comparing snd) $ map (head &&& length) $ group $ drop 2 $ showCReal 5000 pi
16:51:20 <lambdabot>   [('9',6),('7',4),('8',4),('2',4),('1',3),('5',3),('0',3),('0',3),('1',3),('...
16:51:23 <ski> dobblego : .. easier to check pairwise
16:52:09 <dobblego>  @check \w s f a -> StateT w (WriterT s f) a == WriterT w (StateT s f) a -- :)
16:52:46 <ski> hehe, randomfly generated types, eh ?
16:53:13 <dobblego> (r -> s -> f (a, s, w)) -> ReaderT r (StateT s (WriterT w f)) a
16:53:22 <azaq23> ('9', 6) has a name http://en.wikipedia.org/wiki/Feynman_point
16:53:27 <dobblego> probably need Functor f =>
16:58:25 <ski> @djinn (r -> s -> Identity (a, s, w)) -> ReaderT r (StateT s (WriterT w Identity)) a
16:58:25 <lambdabot> f a =
16:58:26 <lambdabot>     MkReaderT (\ b ->
16:58:26 <lambdabot>                MkStateT (\ c ->
16:58:26 <lambdabot>                          case a b c of
16:58:26 <lambdabot>                          MkIdentity (d, e, f) -> MkWriterT (MkIdentity (f, (e, d)))))
16:59:07 <dicey> is template haskell frequently used?
16:59:22 <ddarius> Not really, in my impression.
17:02:13 <parcs> what's the simplest way to make ghc's type checker not terminate?
17:02:35 <parcs> i have 'type instance Foo a = Foo a'
17:02:43 <monochrom> does that work?
17:02:58 <parcs> with undecidable instances
17:02:59 <monochrom> I mean: does that diverge? :)
17:03:00 <ddarius> Turn on undecidable instances and make an instance that depends on itself.
17:03:21 <monochrom> nice. I think that's pretty close to simplest
17:06:38 <dobblego> @type \z -> ReaderT $ \r -> StateT $ \s -> WriterT . fmap (\(a, s, w) -> ((a, s), w)) $ z r s
17:06:39 <lambdabot> forall r s a (m :: * -> *) w. (Functor m) => (r -> s -> m (a, s, w)) -> ReaderT r (StateT s (WriterT w m)) a
17:08:45 <HugoDaniel> where can i learn about denotational semantics and learn about how to use them to design my code ?
17:09:59 <parcs> the haskell wikibook has a nice section on denotational semantics
17:10:40 <HugoDaniel> im reading that one
17:11:04 <dobblego> @djinn (r -> s -> Identity (a, s, w)) -> ReaderT r (WriterT w (StateT s Identity)) a
17:11:05 <lambdabot> f a =
17:11:05 <lambdabot>     MkReaderT (\ b ->
17:11:05 <lambdabot>                MkWriterT (MkStateT (\ c ->
17:11:05 <lambdabot>                                     case a b c of
17:11:05 <lambdabot>                                     MkIdentity (d, e, f) -> MkIdentity (e, (f, d)))))
17:12:06 <thoughtpolice> HugoDaniel: a good book on PLT will cover it. i know spj's "implementing functional languages" covers it in small part, but most of the book is dedicated to compilers
17:12:34 <thoughtpolice> (that's also available for free if interested, just google it)
17:13:23 <ski> @djinn Functor f => (r -> s -> f (a, s, w)) -> ReaderT r (StateT s (WriterT w f)) a
17:13:23 <lambdabot> Error: kind error: (KStar,KVar 2)
17:15:53 <dobblego> @type \z -> ReaderT $ \r -> WriterT $ StateT $ \s -> let z' = z r s in fmap (\(a, s, w) -> ((a, w), s)) z'
17:15:54 <lambdabot> forall r a w s (m :: * -> *). (Functor m) => (r -> s -> m (a, s, w)) -> ReaderT r (WriterT w (StateT s m)) a
17:31:27 <monadic> I have three executables for a project - A actual program, a test harness, and a set of profiling cases. I put all of the common code (which is to say, almost all of it) into a Library using cabal like shown in the users manual, but each executable still builds its own copy of this code. How can I fix this?
17:59:32 <xil> hi, is there a way to see the Monad instance of Either?
18:01:46 <doserj> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Control-Monad-Instances.html
18:03:01 <hpaste> dancor pasted “hexpat runs out of mem despite lazy” at http://hpaste.org/48767
18:03:46 <xil> doserj: so bind acts the same way as for Maybe, but where Left is equivalent to Nothing and Right is Just?
18:04:04 <doserj> yes
18:04:11 <xil> doserj: perfect! Thank you!
18:05:32 <parcs> @src Either (>>=)
18:05:32 <lambdabot> Left  l >>= _ = Left l
18:05:32 <lambdabot> Right r >>= k = k r
18:05:48 <xil> oh look at that
18:05:52 <xil> good to know that exists
18:06:54 * ski recalls using `Either [Integer] Integer' monadically, for something
18:07:11 <xil> okay so I've never actually used monads knowingly as monads except for with IO, so I don't really know what I'm doing. Could someone tell me if this does what I think...
18:08:30 <xil> "f x >>= \ ls -> Right g:ls" does that run the function f on input x and if the output is a Right l, where l is a list, then it sends that to the other side of bind, otherwise it retuns with Left whatever?
18:08:54 <parcs> yep
18:09:43 <parcs> monads do exactly what >>= is defined to do
18:09:49 <xil> thank you very much. I've just really over worked myself trying to understand monads so now I'm too saturated to make sense of it. I would like to have some sort of global state and tried figuring out the State and StateT monads and it just overdid it for me
18:10:28 <parcs> yeah, the State monad is overwhelming at first
18:10:54 <xil> yeah, so now when I see monadic things I'm cautious to think I understand what it does is all
18:11:16 <parcs> @src State (>>=)
18:11:16 <lambdabot> Source not found. It can only be attributed to human error.
18:11:17 <xil> I'm relatively new to Haskell in general and am still figuring out a LOT of syntactic stuff
18:12:24 <ddarius> "When one treats 1,2,3-trichloropropane with alkali and a little water the reaction is violent; there is a tendency to deposit the reaction product, the raw materials and the apparatus on the ceiling and the attending chemist."
18:14:16 <kmc> xil, yeah, don't try to "understand monads".  (>>=) is just a function and its definition is different for every  type
18:14:25 <kmc> don't get bogged down trying to see some unifying idea behind all of them
18:15:10 <kmc> i wonder how pervasive the Monad class would be without the "do" syntax
18:22:55 <kmc> i think without "do" it would be more like Traversable
18:23:19 <kmc> a useful class that some people learn about, but not something mandatory
18:24:20 * ddarius thinks monads would be exactly as pervasive without do-notation.
18:25:10 <ddarius> "The government had me questioned by Dr. Rotariu of Loyola University for there had been a number of cases of methyl bromide poisoning and the victims were either too befuddled or too dead to be questioned."
18:30:44 <kmc> can i tell people "a monad is just some type where someone has assigned an arbitrary but convenient meaning to the 'do' syntax"
18:31:03 <ddarius> No.
18:31:08 * kmc is staunchly anti-Platonist about this monad business
18:31:49 <ddarius> I'm vehemently anti-Platonist in general, but your statement simply isn't true.
18:33:52 <kmc> to which part do you object?
18:33:53 <dobblego> kmc: I once tried similar with C# guys and LINQ, and it backfired big time
18:34:02 <kmc> how so?
18:34:19 <kmc> you were describing LINQ to them? or describing Haskell's "Monad" class in terms of LINQ?
18:35:06 <dobblego> I asked, "what is the type of from aa in a; from bb in b; select f(aa, bb)?" and I could not get an answer that wasn't a specific type constructor, even though I tried to explicitly coach out of it
18:35:15 <ddarius> do-notation has only one meaning.  To the extent that you can vary that by choosing a different instance of Monad, you still can't vary it arbitrarily.
18:35:47 <dobblego> I was hoping for an answer of "Whatever<A> where Whatever has a SelectMany method..."
18:36:11 <jmcarthur> how strange. i have the time package in my build-depends, and it compiles successfully, but then it fails to link saying that the package is hidden
18:36:15 <ddarius> dobblego: If C# people were more familiar with type inference, perhaps that is what they would have said.
18:36:22 <jmcarthur> and if i remove it from the build-depends, it fails to compile at all
18:36:39 <dobblego> there is even a funny article out there of a C# guy accusing "monad people" of "abusing C#" by not using one of the two approved Microsoft type constructors
18:36:44 <jmcarthur> err, maybe i should browse the bug reports before i complain here
18:36:47 <kmc> haha dobblego
18:36:49 <kmc> monad people
18:36:54 <kmc> they're like pod people
18:37:03 <dobblego> in any case, I've not had success with that approach
18:37:15 <kmc> ddarius, does (+) have one meaning?
18:37:22 <dobblego> http://apisuckage.wordpress.com/2009/06/19/on-linq-monads-and-the-blindness-of-power/
18:38:45 <kmc> haha, the article starts by assuming that monads are the "fundamental building block" of Haskell
18:38:50 <kmc> ex falso quodlibet
18:38:53 <cmccann> dobblego, most mainstream programmers have difficulty with higher-order abstractions at some level
18:39:17 <kmc> cmccann, you may be right but i'm wary of that sort of thinking in general
18:39:19 <kmc> that's how you get Java
18:39:19 <dobblego> cmccann: agreed, been teaching them for years -- I find it extremely challenging
18:39:28 <kmc> a language designed by committee for the lowest common denominator
18:39:36 <cmccann> kmc, the funny thing is that OOP is inherently about higher-order abstractions
18:39:40 <kmc> maybe i just have not worked alongside enough "mainstream" / "average" programmers
18:40:20 <ddarius> kmc: It can be given a single meaning, but I'm willing to say, as an explicit method, it can have different meanings.  But if you expand further you start being led to 'id' having different meanings depending on what type it is instantiated at or 'not' having different meanings depending on what is passed to it.
18:41:22 <dobblego> kmc: the author of that article is a renowned idiot, but it's not too far from the common belief among a lot of C# programmers that I meet
18:41:48 <cmccann> kmc, the problem with that is that most people will live down to the expectations of the mainstream, so languages designed for incompetents will create the incompetent programmers to use it
18:41:50 <dicey> isn't the purpose of pretty much any programming to be about abstracting things?
18:42:09 <kmc> cmccann, in some sense that's a good thing -- more programmers overall
18:42:12 <jmcarthur> alright i can't find a ticket for it
18:42:16 <kmc> as long as they aren't designing nuclear reactor control systems
18:42:16 <jmcarthur> has anybody else seen this before?
18:42:40 <kmc> i'm all for making it easier for the Common [Wo]Man to write a shitty blog suite from scratch in PHP
18:42:50 <kmc> i won't give them my credit card number or a non-throwaway password
18:43:15 <jmcarthur> time package is in my build-depends. compiles fine, but fails to link with "Perhaps you need to add `time' to the build-depends in your .cabal file."
18:43:32 <kmc> popular Python and Ruby libraries are based on loads of EDSLs, metaclass magic, dynamic introspection tricks, etc
18:43:46 <jmcarthur> and i know i'm actually using modules from the package
18:43:51 <cmccann> kmc, my assertion is that a significant number of existing PHP programmers, if PHP did not exist and something better was the most common tool, would be better programmers
18:44:00 <kmc> the "average" Python or Ruby programmer may have trouble inventing these abstractions, but they don't seem to have trouble understanding and using them
18:44:41 <kmc> though Ruby in particular seems to have the attitude of "you're not smart enough to understand how Rails is implemented, go scurry about making webapps like a good drone"
18:45:15 <othiym23> kmc: that ultimately leads to my biggest problem with Rails, which is that beyond a certain level, no individual developer understands how all the magic happens
18:45:32 * ddarius will train bees to make web apps thereby eliminating all job creation benefits of making a language "for the masses."
18:45:36 <kmc> othiym23, that's true in any sufficiently complex system, though
18:45:42 <othiym23> Ruby-style metaprogramming can go badly feral, esp. when combined with monkeypatching
18:45:42 <kmc> s/Rails/GHC/
18:45:44 <dobblego> cmccann: teaching people who have not been exposed to Java (any degenerate language) is much, much easier
18:45:47 <kmc> s/Rails/Linux kernel/
18:45:50 <jmcarthur> *sigh* one always solves his own problem after asking others for help
18:45:55 <parcs> jmcarthur: silly question: did you run cabal configure before cabal install?
18:45:57 <kmc> i mean, i agree this *is* a general problem with software
18:46:19 <othiym23> it is, but more rigorous abstractions make it easier to tease out the thread of a system, no matter how complex
18:46:27 <kmc> yeah
18:46:32 <Pseudonym> kmc: I don't understand how a reorder buffer works, but the ISA of a modern CPU is sufficiently well-defined that despite this lack of knowledge, I'm not cargo cult programming.
18:46:49 <kmc> Pseudonym, you're cargo-culting the performance aspects
18:46:49 <Pseudonym> I _do_ feel like I'm cargo cult programming when doing Rails.
18:46:52 <kmc> it just doesn't matter
18:46:53 <Pseudonym> Which admittedly I don't do much.
18:46:58 <ddarius> In my opinion, languages like Haskell are much easier and more empowering to use, so I don't see any point in making a PHP for the masses.
18:47:02 <dicey> it's not just software, its a problem with any complex system
18:47:03 <cmccann> dobblego, I've heard anecdotally a few times that it's often easier to teach Haskell to complete non-programmers than to people with a significant amount of experience in mainstream languages
18:47:22 <dicey> How long did it take Whitehead and Russell to arrive at a definition for addition?
18:47:22 <dobblego> cmccann: this has been my consistent experience
18:47:26 <kmc> othiym23, yeah, the main difference between the Python / Ruby tricks and the Haskell tricks is that the former has zero static guarantees or pretty much any reason to think it works
18:47:29 <dicey> how many pages into their book(s), rather?
18:47:49 <kmc> dicey, http://us.metamath.org/mpegif/mmset.html#trivia
18:48:18 <Iceland_jack> dicey: page 379
18:48:29 <othiym23> I'd separate Python and Ruby, if only because the Python community has paid much more attention to minimizing the number of ways given to solve any given problem
18:48:37 <kmc> true
18:48:41 <kmc> though they've still largely failed
18:48:43 <kmc> but that's to be expected
18:48:46 <dicey> haha, there you go. and how many people have read that far into the book? most people are satisfied just understanding the bits and pieces you need to clunk new pieces into place.
18:48:53 <dicey> its very rare that you have to understand *EVERY* step
18:48:54 <cmccann> kmc, yesod seems to have about as much magic as rails, proportionally, the difference is that when something goes wrong you get incomprehensible errors involving TH splices at compile time :]
18:48:55 * othiym23 still is way more comfortable hacking together webapps in Rails anyway
18:49:17 <othiym23> I'm just grumpy whenever I have to dive into the guts of e.g. ActiveRecord, which happens way too frequently for my liing
18:49:21 <othiym23> *liking
18:49:26 <Pseudonym> Yeah, and that's the problem.
18:49:51 <ddarius> cmccann: Instead of the customer getting meaningless methodNotFound messages at runtime.
18:49:56 <Pseudonym> Writing documents in TeX is pretty easy, too, except for that one table or diagram which won't format properly unless you get your hands really dirty
18:49:57 <BMeph> Am I a snob for being continually annoyed by the LINQ article's incessant (wrong!) use of "other's"? :\
18:50:01 <jmcarthur> parcs: the problem was that i had an executable depending on a library in the same package, but i hadn't put their source files into separate subdirectories, so the executable build was just trying to use the modules from the library directly, which made it depend on some of the same things that the library did. not sure why i thought it was the linker step for the library instead of a compile step
18:50:03 <jmcarthur> for the executable...
18:50:09 <othiym23> BMeph: probably, but so what? ;)
18:50:20 <cmccann> dobblego, I gather you've done a lot of teaching of some sort?
18:50:23 <dobblego> BMeph: if that's all that bothers you in that article, you're doing well :)
18:50:42 <BMeph> othiym23: Nothing, just wanted to be sure. ;)
18:50:45 <dobblego> cmccann: yes, though not formally (I have a diploma in Psychology though, which can be handy occasionally)
18:50:51 <Pseudonym> Actually, even when performance tuning code for a modern CPU, I don't need to know the details of how an instruction is implemented to recognise a branch misprediction.
18:50:54 <dobblego> cmccann: well, I have lectured at university for years too
18:50:58 <Pseudonym> Or a bad cache miss.
18:50:59 <Draconx> BMeph, ye's, that article misuse's apostrophe's quite a few time's.
18:51:09 <othiym23> dobblego, that article is some kind of masterpiece
18:51:18 <dobblego> othiym23: fun innit? :)
18:51:24 <cmccann> dobblego, no doubt the degree will come in handy when you need to self-diagnose all the disorders you've acquired from trying to teach java programmers
18:51:43 <dobblego> cmccann: ha, it's more my armchair interest in the subject that helps
18:51:51 <othiym23> I personally know that almost all of my time spent writing CL has been spent building huge fairy castles out of stacked macros, and almost never with lists or sexps
18:52:23 <othiym23> I'm learning stuff!
18:52:30 <dicey> its all the same in the end. mathematicians teach accountants. engineering profs teach future toaster designers, and computer scientists teach people who will write web apps!
18:52:34 <othiym23> I "can build all [my] object fields in terms of closures"!
18:52:36 <dicey> and yes, this applies even at top 10 universities.
18:52:38 <othiym23> lol wut
18:52:53 <mm_freak_> can i write an empty INSERT statement, i.e. one that does not insert anything?
18:53:00 <BMeph> Draconx: When I saw your'e comment, I lo'led... ;p
18:53:10 <othiym23> dicey: my web apps have ended up being much better written thanks to all that CS crud my long-suffering professors dunned into me
18:53:23 <dicey> yes, fight for the better web app!!
18:53:46 <Pseudonym> Actually, the way it seems to go at the moment is that economics professors half-teach Web 2.0 billionairres.
18:53:56 <Pseudonym> Only half-teach, since they drop out before they're done.
18:54:01 <othiym23> of course, a CS professor's idea of a webapp framework is UrWeb, which says something profound, if somewhat obscure
18:54:22 * Pseudonym has never heard of UrWeb
18:54:47 <dicey> mywb is urweb? we all live togetherweb?
18:55:04 <Pseudonym> i has urweb, but i eated it
18:55:07 * BMeph has heard and seen it, but watched some anime to get over the shock...
18:55:19 <mm_freak_> oh
18:55:22 <mm_freak_> wrong channel lol
18:55:23 <mm_freak_> sorry
18:55:54 <cmccann> if anyone's actually curious, see http://www.impredicative.com/ur/
18:56:00 <othiym23> yeah
18:56:03 <othiym23> it's worth a look
18:56:42 <othiym23> I really like the way it uses dependent / "row" types, but I find the designer's assertion that it's a good framework for general web developers to be amusing
18:56:46 <cmccann> tl;dr version is "specialized ML-family language designed for writing really safe web apps"
18:57:19 <kmc> i know of at least one practical purpose it's been used for
18:57:41 <kmc> a webapp which needed very strong guarantees wrt escaping of output
18:58:05 <monochrom> every webapp should need it
18:58:14 <othiym23> kmc: I have no doubt it can be useful, but it's the sort of thing that people who read Benjamin Pierce for fun think is easy and useful for the average developer, and I think it would go waaaaayyy over most of its target audience's heads
18:58:36 <kmc> yeah
18:58:43 <othiym23> monochrom: "should" is doing some heavy lifting there
18:58:45 <kmc> i'm not claiming it could or should be mainstream
18:58:49 <Pseudonym> I would argue that such a system is _precisely_ the sort of thing that a CS professor should be teaching.
18:58:51 <kmc> just that it's practical in certain niches
18:59:00 <Pseudonym> More so than GWT.
18:59:07 <kmc> these are different statements -- the same distinction is important wrt haskell
18:59:30 <thoughtpolice> cmccann: i've used ur/web a bit, it's quite nice
18:59:32 <dicey> professors should teach whatever helps the students learn how to learn. nothing else really matters, and you can use any number of things for that
18:59:34 <cmccann> a depressing number of web programmers will never be interested in anything that slows down how quickly they can implement security holes that may or may not contain a useful application
18:59:38 <dicey> might depend on the students -- or the professor
19:00:48 <monochrom> http://groups.google.com/group/comp.lang.functional/msg/81756fe3fe07a61a
19:01:31 <synesthesia> suppose a module does not export some function (but I know it's there), is there any way I could force-import it?
19:01:33 <kmc> nice
19:01:48 <othiym23> PHP is pretty hard on C's heels for speed-of-bug-implementation
19:02:25 <thoughtpolice> i think ur/web is pretty easy to use but it starts to get complicated when you use metaprogramming. adam states this is part of his approach, and that metaprograms with strong guarantees only need to be written once by an expert and used liberally by users
19:02:43 <parcs> synesthesia: no. you can edit and reinstall the package with some function exported, though
19:02:48 * ddarius considers becoming a "professional" conman.
19:02:48 <othiym23> but OTOH, PHP is great for throwing together a couple template-driven pages for a quick dynamic site
19:02:58 <thoughtpolice> it seems to have pretty good metaprogramming facilities, but the ecosystem around it is lacking rather sorely, making it hard to do work in it. i think a lot of the principles behind systems like ur or opa are sound, it's just getting it to work in practice
19:03:15 <thoughtpolice> also the fact that ur/web doesn't allow you to put anything in external templates basically makes it a no go for anybody not seriously dedicated to it
19:03:17 <othiym23> thoughtpolice: yeah, I think my specific problem is that I feel like frameworks built on those assumptions are built on sand
19:03:18 <thoughtpolice> i.e. an individual
19:03:26 <cmccann> thoughtpolice, I've not used it but from what I read it sounds like most of the difficulty is front-loaded, in that it'd be tough to get the hang of but probably painless afterwards
19:03:28 <synesthesia> is there any way to force-import a function from some module that the module explicitly does not export?
19:03:46 <thoughtpolice> cmccann: i literally banged my head on like 1 example for an hour and most of the type system made sense after that
19:03:52 <othiym23> I think that eventually you really need to understand how the system is working its magic, and so you're going to have to wrap your head around those abstractions anyway
19:03:53 <thoughtpolice> (after i got it working)
19:05:05 <thoughtpolice> you know people claim there is magic, but i'm not sure how magic it is in principle. i think that those systems don't really have lots of users, and when that is the case, everything is magic, and all issues are deep ones
19:05:32 <thoughtpolice> typed XML trees + syntactic sugar for example, isn't really that "magic" if you ask me. it's rather domain specific, and makes a lot of sense
19:05:43 <thoughtpolice> even frameworks in haskell/ocaml take the approach of typed XML and dom elements, etc
19:05:47 <thoughtpolice> (like ocsigen)
19:06:05 <othiym23> sure, but getting peoples' heads bootstrapped into thinking in terms of the type system seems like a stretch
19:06:27 <othiym23> maybe I'm being condescending in my assumptions, although it also took me a while to get my head in the game when I was trying to understand Ur
19:07:01 <cmccann> most of the "difficulty" with things like this isn't intrinsic to the subject, it's due to unfamiliarity from the perspective of the person learning it
19:07:08 <thoughtpolice> ur is a bit more 'magical' in its design, i'll grant that. opa is another alternative that is not so magic feeling in principle, also using row types, but it doesn't have the metaprogramming facilities
19:07:30 <cmccann> initial difficulty of getting started doesn't necessarily have anything to do with intrinsic difficulty of using something for day-to-day work
19:07:36 <thoughtpolice> i say this because ur is built on specific heuristics for 'reverse engineered type inference' in the compiler, and adam states he has added these roughly 'when they are useful'
19:08:03 <thoughtpolice> but this is also why it's able to do so much for you, in terms of type inference.
19:08:09 <othiym23> cmccann: I guess? The central strength of UrWeb is that it's actually fairly basic (in the sense of foundational) and the same small set of ideas manifests itself in very different-looking syntaxes, but that's also what makes it tricky to get your head around
19:08:16 <thoughtpolice> it really is quite amazing how easy it is to use metaprograms once you write them
19:08:26 <thoughtpolice> writing them however is a bit more of a challenge, i'll grant that.
19:08:51 * ddarius recommends thinking about most problems rather than bombarding them with one's cranium.
19:09:08 <othiym23> ddarius: some of us learn differently ;)
19:09:26 <dicey> im pretty sure making a tool is almost universally harder than using a tool
19:09:42 <dicey> it might even be a theorem
19:10:08 <cmccann> othiym23, yes, that's largely my point. most of the time when people say something like UrWeb is too difficult for the average programmer, what they really mean is that it's too much effort for the average programmer to learn
19:10:14 <ddarius> Making an optically flat lense/mirror is actually quite easy.
19:10:30 <thoughtpolice> anyway, i've been thinking about writing some stuff with ur, because i like it a bunch. i'm thinking of writing a small hackage equivalent, so people could actually have some sort of repo for ur/web code that others have written
19:10:32 <cmccann> on the other hand, C probably is too difficult for the average programmer, including many programmers who have "learned" it
19:11:37 <thoughtpolice> othiym23: if you like ur, i'd advise you try opa - http://opalang.org - it's not as heavy on the type system as much as it is an "ML for the web" like ur. it also has rather nice automatic distribution facilities and whatnot
19:11:48 <ddarius> pk8
19:11:53 <dicey> i guess this all depends on how you define "tool"
19:12:05 <thoughtpolice> (you actually don't need to write any sort of special code in order for things to distribute amongst multiple servers for example, including things like real-time client side updates, etc)
19:12:08 <dicey> and that starts turning into philosophy pretty fast =(
19:12:20 <ddarius> @wn tool
19:12:21 <lambdabot> *** "tool" wn "WordNet (r) 2.0"
19:12:21 <lambdabot> tool
19:12:22 <lambdabot>      n 1: an implement used in the practice of a vocation
19:12:22 <lambdabot>      2: the means whereby some act is accomplished; "my greed was
19:12:22 <lambdabot>         the instrument of my destruction"; "science has given us
19:12:23 <lambdabot> [12 @more lines]
19:12:33 <dicey> oh god, dictionaries.
19:12:44 <thoughtpolice> however, there is a rather large caveat: it's AGPLv3, meaning even apps written in it need to be AGPLv3 - it extends GPL rights to users of networked programs.
19:12:44 <ddarius> @devil god
19:12:45 <lambdabot> No match for "god".
19:12:50 <ddarius> Interesting.
19:13:00 <thoughtpolice> this is because it's a product of MLstate, and they effectively dual license to make money
19:13:33 <ddarius> Do they make money?
19:13:38 * BMeph says: C is hard; let's go shopping!
19:14:00 <thoughtpolice> that's a good question, and they've been around for a while, but i'm not sure how. they do have users apparently, and from what i've heard of people there, ning is an example
19:14:11 <wli> Systems programming could use a bit nicer of a language.
19:14:20 <thoughtpolice> then again, i don't know anything about ning, so i don't know how much that really means to you :P
19:14:45 <ddarius> "ning" looks like a typo to me.
19:17:13 <ddarius> Saponification in oil paintings was first described in 1997 according to Wikipedia.  This strikes me as quite late.
19:18:47 <dicey> lol
19:19:03 <dicey> soap is hard to make
19:21:57 <gwern> dicey: nah it's easy to make if you have some jews to get rid of
19:22:29 <gwern> too soon?
19:22:47 <kmc> o snap
19:28:59 <byorgey> @tell c_wraith http://en.wikipedia.org/wiki/Crossword_puzzle
19:28:59 <lambdabot> Consider it noted.
19:29:31 <byorgey> I guess it's an American thing
21:09:21 <wavewave> what is the package 'ghc'?
21:10:14 <wavewave> I cannot solve a dependency error " ghc-6.12.3 requires bytestring-0.9.1.7 "
21:10:23 <Jafet> I suppose it's GHC.
21:10:25 <tensorpudding> ghc is the compiler
21:10:27 <wavewave> I have some package uses 0.9.1.10
21:10:45 <tensorpudding> it's saying that you have a bytestring library version incompatibility with your ghc
21:10:46 <wavewave> I know it ;-)
21:11:20 <tensorpudding> ghc needs one version and some other package needs another, so you either need to remove the package or upgrade ghc, unfortunately
21:11:32 <wavewave> so my question is why some package complains and some package does not complain it?
21:14:19 <wavewave> how can I print packages which depends on ghc?
21:16:11 <kmc> ghc-pkg describe ghc
21:17:10 <kmc> er, that will print the things ghc depends on
21:17:17 <kmc> i don't know how to do the reverse
21:17:44 <kmc> ghc-pkg dot | grep ghc-6.12.3
21:17:45 <wavewave> I found ghc-pkg dot but it shows too monstrous graph unfortunately.
21:18:08 <kmc> the text output is readable and grep-able
21:18:13 <wavewave> oh... that's great idea..
21:18:15 <wavewave> Thanks!
21:18:26 <kmc> i think there's even some program to find transitive closure of dot graphs but i don't recall the name
21:22:01 <wavewave> no package is currently dependent on ghc.. hmm
21:22:52 <kmc> but you can't upgrade ghc without reinstalling all packages
21:23:43 <kmc> by the way, the reason there's a package named 'ghc' is that GHC exposes much of its functionality as a Haskell library
21:23:45 <kmc> the "GHC API"
21:24:03 <wavewave> I see...
21:24:19 <kmc> though this "library" is composed of formerly internal GHC modules that have been exposed and maybe cleaned up after the fact
21:24:24 <wavewave> unfortunately i cannot upgrade ghc because my server has very old glibc
21:24:41 <kmc> are you stuck on some old distro like RHEL / CentOS?
21:24:47 <wavewave> yes..
21:24:59 <kmc> well, one solution is to install new glibc etc. under a prefi
21:25:00 <kmc> x
21:25:15 <wavewave> this is a cluster server..
21:25:25 <wavewave> can I install glibc locally?
21:26:07 <kmc> think so
21:26:17 <kmc> it's done e.g. for cross-compilation
21:26:40 <kmc> there are questions of libc / kernel version compatibility
21:26:45 <wavewave> hmm.. I don't know whether it's worth that effort though. ;-/
21:27:00 <wavewave> hmm let me check the kernel version.
21:27:06 <kmc> you can't install  bytestring-0.9.1.7 alongside bytestring-0.9.1.10?
21:27:19 <kmc> maybe you can inside cabal-dev
21:27:32 <wavewave> 2.6.18
21:27:37 <kmc> RHEL / CentOS 5
21:28:18 <kmc> do you have root on this machine?
21:28:27 <wavewave> no..
21:28:35 <wavewave> this is a big system server.
21:28:42 <kmc> do you have CAP_SYS_CHROOT?
21:28:46 <kmc> can you make pleas to the admins?
21:28:57 <wavewave> I just install ghc on my local directory.
21:29:07 <kmc> anyway i think you should try cabal-dev
21:29:22 <wavewave> I doubt even the admins know ghc
21:29:42 <wavewave> Yes. that's what I am thinking now..
21:30:01 <wavewave> I just want to understand this problem.. anyway
21:30:18 <wavewave> it seems that there is no package that needs ghc..
21:31:20 <kmc> but you can't upgrade or remove it
21:31:21 <kmc> afaik
21:32:14 <wavewave> Probably removing bytestring-0.9.1.10 is possible with some change of my source code.
21:34:43 <wavewave> aha... I found what causes it... QuickCheck!
21:39:35 <wavewave> ghc-pkg dot |grep xxx is quite useful. ;-)
23:07:40 <QinGW> head' = foldr1 (\x _ -> x)
23:08:01 <QinGW> head' = foldl1 (\x _ -> x)
23:08:19 <mauke> fight!!
23:08:34 <QinGW> Why are their value same?
23:08:48 <mauke> why not?
23:09:18 <QinGW> foldr1 take the last element as its accumulator value, right?
23:09:24 <ddarius> > foldl1 const "abc"
23:09:25 <lambdabot>   'a'
23:09:43 <mauke> > foldr1 const "abc"
23:09:44 <lambdabot>   'a'
23:09:54 <mauke> @src foldr1
23:09:54 <lambdabot> foldr1 _ [x]    = x
23:09:54 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
23:09:54 <lambdabot> foldr1 _ []     = undefined
23:10:08 <mauke> QinGW: yes
23:10:30 <ddarius> > foldl1 const (repeat 1)
23:10:35 <ddarius> > foldr1 const (repeat 1)
23:10:55 <lambdabot>   thread killed
23:10:55 <lambdabot>   thread killed
23:11:16 <ddarius> > foldr1 const (repeat 1)
23:11:19 <lambdabot>   1
23:11:23 <ddarius> > foldl1 const (repeat 1)
23:11:27 <lambdabot>   mueval-core: Time limit exceeded
23:11:29 <ddarius> Not the same function.
23:12:20 <QinGW> thanks, let me think ...
23:14:07 <QinGW> @hoogle foldr1
23:14:08 <lambdabot> Prelude foldr1 :: (a -> a -> a) -> [a] -> a
23:14:08 <lambdabot> Data.ByteString foldr1 :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
23:14:08 <lambdabot> Data.Foldable foldr1 :: Foldable t => (a -> a -> a) -> t a -> a
23:15:02 <QinGW> @src const
23:15:02 <lambdabot> const x _ = x
23:27:48 <QinGW> mauke: to (\x _ -> x), foldr1:   (f 3 (f 4 (f 5 3))) and foldl1:    (f (f (f 3 3) 4) 5)  so the both return 3, right?
23:30:25 <Jonno_FTW> so I was trying to compile lambdabot 4.2.2.1 and it failed and to told me to report a bug, where do I do this
23:30:51 <mauke> QinGW: why do you have two 3's?
23:31:04 <mauke> Jonno_FTW: what's the error message?
23:32:20 <Jonno_FTW> one sec
23:32:47 <Jonno_FTW> mauke: http://pastebin.ws/7xdnzs
23:33:10 <mauke> it told you where
23:33:18 <Jonno_FTW> yeah I saw that after
23:33:41 <Jonno_FTW> but it's an old version, would it still compile if I got the new version of lambdabot?
23:37:02 <CrazyThinker> Is Tamar Chirstina here?
23:37:17 <CrazyThinker> The one who is making Visual Studio extension for haskell?
23:37:39 <scree> Jonno_FTW: you can try if you want; it's likely to be hit and miss given there's a bug in the compiler
23:38:15 <Jafet> It could be triggered by one of the wacky plugins
23:39:20 <Jonno_FTW> probably
23:39:21 <Jafet> I had to remove OPTIONS_GHC -fvia-c from one of them before it would build
23:39:29 <Jonno_FTW> one of them?
23:39:33 <Jafet> And there didn't seem to be any reason for it to be there
23:40:20 <Jonno_FTW> when I darcs get the repo, darcs gives a message about the repo being in an old format, is there a new one I should be getting it from?
23:40:55 <Jafet> That's probably the latest one; I used the hackage snapshot
23:41:55 <Jonno_FTW> Copying patch 614 done, 1307 queued
23:41:58 * Jonno_FTW sigh
23:47:59 * hackagebot regexpr 0.5.4 - regular expression like Perl/Ruby in Haskell  http://hackage.haskell.org/package/regexpr-0.5.4 (YoshikuniJujo)
23:48:20 <ddarius> Who decides to distill ants?
23:49:59 * hackagebot mtlparse 0.1.2 - parse library using mtl package  http://hackage.haskell.org/package/mtlparse-0.1.2 (YoshikuniJujo)
23:50:09 <Saizan> is that a koan?
23:51:46 <ddarius> No, that's how formic acid was made.
23:52:06 <ddarius> Indeed, "formic" comes from "formica" a genus of ants.
