00:28:56 <chrisdone> :t extract -- lambdabot has ce?
00:28:57 <lambdabot> forall source. (Extract source) => (Int, Int) -> source -> source
00:29:17 <chrisdone> o_ o`
00:30:05 <chrisdone> anyone got some interesting uses of the Comonad class?
00:30:52 <elliott> that's not category-extras is it
00:30:57 <elliott> that's the newer stuff
00:31:06 <chrisdone> no, category extras is w a -> a
00:32:02 <chrisdone> oh, i don't think i'm reading the right category-extras docs. extract seems to have been shifted to Copointed
00:32:20 <chrisdone> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Comonad.html
00:32:21 <c_wraith> category-extras, as a package, is sort of deprecated
00:32:38 <elliott> right, what c_wraith said
00:32:45 <elliott> http://hackage.haskell.org/package/comonad
00:32:59 <chrisdone> anyway, i'm not using it. just interested in uses of the Comonad. the instances list is quite a mouthful
00:33:04 <elliott> that's still not the extract though
00:34:47 <chrisdone> extract :: w a -> a seems similar to runX :: X a -> a
00:36:03 <chrisdone> :t Control.Comonad.extract
00:36:04 <lambdabot> Couldn't find qualified module.
00:36:18 <chrisdone> @vixen why u no have comonads?
00:36:19 <lambdabot> no?
00:59:44 <chrisdone> $ cabal-dev install encoding
00:59:44 <chrisdone> Resolving dependencies...
00:59:44 <chrisdone> cabal: Error: some packages failed to install:
00:59:44 <chrisdone> encoding-0.6.6 failed during the configure step. The exception was:
00:59:44 <chrisdone> ExitFailure 127
00:59:44 <chrisdone> $
00:59:50 <chrisdone> gotta love them helpful build messages
01:00:19 * chrisdone yields the sword of -v
01:00:35 <chrisdone> er, wields. yielding it would do nothing
01:01:23 <Ptival> just wondered something, why don't languages use a keyword as a recursive function call to avoid naming the function?
01:01:38 <Ptival> something a little bit like Clojure's "recur"
01:01:54 <shachaf> Ptival: You can always use fix in Haskell.
01:01:57 <Wild_Cat> Ptival: because using the function name is more readable?
01:01:58 <Ptival> or does it exist and I missed it?
01:01:58 <c_wraith> or haskell's fix?
01:02:08 <Ptival> let me take a look at fix :)
01:02:19 <c_wraith> fix will make your brain explode
01:02:21 <shachaf> Ptival: Where's the "function boundary", if you use "recur"?
01:02:39 <chrisdone> fix $ \recur -> …   —- but this is about as long as let recur = … so…
01:02:53 <shachaf> I was under the impression that the point of "recur" in Clojure was that they can't do tail-call elimination otherwise because of JVM limitations.
01:03:04 <chrisdone> that's my impression
01:03:28 <chrisdone> recur is the only non-stack-consuming looping construct in clojure
01:03:40 <Ptival> shachaf: yes that's the point, but I'm not concerned about this particular use
01:04:10 <sipa> Ptival: how would you define "the function" you're in?
01:04:18 <Wild_Cat> is it considered good practice in Haskell to alias existing types in order to make them more meaningful to the program at hand? (e.g. type Name = String, type Influence = Int, etc.)
01:04:21 <sipa> the name of the top-level definition?
01:04:26 <sipa> what about a let binding?
01:05:42 <Ptival> sipa: hum :d I would rather have said sthg like the closest definition/lambda, but I'm probably missing some subtlety here
01:05:46 <shachaf> "We can do you functions and recursion without the naming, or functions and naming without the recursion, and we can do you all three, concurrent or consecutive. But we can't give you recursion and naming without the functions. They're all functions, you see."
01:06:04 <chrisdone> Wild_Cat: generally helpful, yeah
01:06:36 <sipa> Ptival: and would it also work for non-function definitions
01:06:39 <Ptival> so how does one write a recursive lambda? using fix?
01:06:48 <quicksilver> yes
01:07:01 <Ptival> ok
01:07:02 <quicksilver> it's a way to pass recursive functions to higher order functions without naming them
01:07:12 <Wild_Cat> chrisdone: OK, good. Thanks. Also, are records a good thing to use for "object" modeling, or should I, in the general case, use tuples or other constructs instead?
01:07:13 <chrisdone> Wild_Cat: often you end up making a record type anyway Thingie { thingieName :: String, thingieInfluence :: Int } which makes naming the individual types less important
01:07:26 <chrisdone> Wild_Cat: :-)
01:07:33 <sipa> @let fib = fix (\f x -> f (x-1) + f (x-2))
01:07:34 <lambdabot>  Defined.
01:07:37 <Wild_Cat> ...right. Thanks for the precognitive answer, chrisdone ;)
01:07:41 <sipa> @forget
01:07:41 <lambdabot> Incorrect arguments to quote
01:07:43 <sipa> @forget fib
01:07:43 <lambdabot> Incorrect arguments to quote
01:08:00 <quicksilver> > map (fix $ \f x -> case x of 0 -> 1; _ -> x * f (x-1)) [1,2,3,4]
01:08:00 <lambdabot>   [1,2,6,24]
01:08:06 <quicksilver> ^^ lambda-form of factorial
01:08:19 <sipa> @forget> fib 5
01:08:19 <lambdabot> No match.
01:08:22 <sipa> > fib 5
01:08:24 <lambdabot>   *Exception: stack overflow
01:08:27 <sipa> \o/ infinite recursion
01:08:44 <elliott> @undefine
01:08:54 <Ptival> missing some base case ain't we? :)
01:09:30 <chrisdone> i was putting the base case in but i first had to put the base case in
01:09:40 <elliott> base cases are so ugly
01:09:59 <elliott> <Wild_Cat> is it considered good practice in Haskell to alias existing types in order to make them more meaningful to the program at hand? (e.g. type Name = String, type Influence = Int, etc.)
01:10:04 <elliott> Wild_Cat: i would suggest using a newtype when possible
01:10:08 <elliott> to enforce a greater separation
01:10:11 <elliott> but this isn't always practical
01:10:17 <Wild_Cat> elliott: newtype?
01:10:37 <elliott> Wild_Cat: "newtype" is just like "data", but you can only have one constructor, and it must have only one field.
01:10:44 <elliott> Wild_Cat: basically, a newtype does not exist at runtime
01:10:48 <elliott> it has no overhead over the type it contains
01:10:56 <chrisdone> elliott: i've found that to be a pain but at least worth it for numbers
01:10:56 <Wild_Cat> elliott: so, "newtype Name = Name String"
01:10:59 <elliott> Wild_Cat: yep
01:11:05 <elliott> it basically allows you to make an "opaque typedef"
01:11:13 <elliott> chrisdone: yeah, it is a pain sometimes. but ideally...
01:11:30 <chrisdone> with strings you have to constantly pack and unpack unless you have a (++) :: ToString a,ToString b => a -> b -> String operator (which i've done previously)
01:11:55 <elliott> Yes, I wouldn't do it for strings.
01:12:08 <elliott> But I would avoid strings in general anyway...
01:12:16 <elliott> (Of course that's a rather overly generic rule of thumb.)
01:12:24 <elliott> (But I think there are better representations for identifiers a lot of the time.)
01:12:33 <chrisdone> yeah… not using strings precludes, uh, most development activities
01:14:25 <chrisdone> $ cabal install encoding
01:14:25 <chrisdone> Resolving dependencies...
01:14:25 <chrisdone> cabal: Error: some packages failed to install:
01:14:25 <chrisdone> encoding-0.6.6 failed during the configure step. The exception was:
01:14:25 <chrisdone> ExitFailure 127
01:14:28 <chrisdone> does this fail for anyone else?
01:15:44 * chrisdone learns the importance of not using cabal update
01:17:04 <mreh> was your cabal out of date?
01:17:11 <mreh> or cabal database pardon
01:17:49 <gienah> chrisdone: no I haven't tried bumping encoding from 0.6.5 to 0.6.6
01:18:43 <gienah> chrisdone: encoding uses HaXml, the HaXml api changed from 1.20 to 1.22
01:19:24 <chrisdone> yeah, i updated recently. seems like that caused the update gienah describes
01:19:32 <chrisdone> i'll try specifying preferences for the old versions
01:21:36 <mreh> does it rely on C bindings?
01:21:51 <gienah> chrisdone: you could do some edits for HaXml 1.22.2, probably need to change n to (N n) for Text.XML.HaXml.Types.QName with stuff like Text.XML.HaXML.Types.Elem/Element
01:22:05 <mreh> I don't understand where the cabal abstraction leaks from the most
01:22:16 <mreh> but it's always system libraries for me
01:22:24 <mreh> i should read SICP
01:28:02 <mreh> "storage and identification of cabalised packages" if you didn't know
01:29:06 <ion> ca(nni)balized
01:30:30 <mreh> RUN!
01:31:08 <Jafet> HACKAGE IS PEOPLE
01:37:28 <mreh> is hackage supposed to be that construction people are prone to these days
01:37:42 <mreh> <noun>+age
01:37:52 <mreh> i've heard loveage, that almost made me vomit
01:49:18 <Botje> I think it's meant to be H(askell) + (p)ackage
01:51:48 <erus`> ownage
01:51:57 <astor> is there a way to link to a named chunk of documentation in haddock? http://haskell.org/haddock/doc/html/ch03s05.html
01:52:58 <astor> does haddock support using a glossary - that is list uses of a term and the definition of it?
02:23:15 <chrisdone> cabal-dev install --preference=HaXml==1.19 --preference=encoding==0.5
02:23:15 <chrisdone> Resolving dependencies...
02:23:15 <chrisdone> [1 of 8] Compiling Data.Static      ( /tmp/encoding-0.6.215521/encoding-0.6.2/
02:23:22 * chrisdone wonders if --preference does anything
02:24:20 <chrisdone> $ cabal-dev install --preference=HaXml==1.19 --preference=encoding==0.5 --dry-run => In order, the following would be installed (use -v for more details):
02:24:20 <chrisdone> encoding-0.6.2
02:24:23 <chrisdone> maybe it's cabal-dev
02:25:04 <chrisdone> nope. regular cabal does it. what. the. functor
02:26:32 <balor> I have a type "data Foo = {Set include, Set exclude}".  Is there any way to enforce "include \cap exclude = \emptyset" in the type specification?
02:28:25 <chrisdone> balor: you mean with an existential?
02:29:10 <benmachine> balor: sounds tricky. is their union interesting? you could store include and include union exclude, and then exclude is just "not in include"
02:29:32 <benmachine> balor: but then you have to provide the guarantee that include subset other thing
02:29:40 <benmachine> which may or may not be possible
02:29:45 <siracusa> chrisdone: --preference works at least for minor versions, IIRC
02:30:18 <benmachine> chrisdone: did you try --constraint instead?
02:30:29 <benmachine> (I don't understand the difference between then)
02:30:31 <benmachine> *them
02:30:45 <balor> chrisdone, I'm not sure how it could be done, maybe \forall a \in include: a\not\in exclude (and vice-versa)
02:31:25 <balor> benmachine, thanks.  I may do that.
02:31:56 <chrisdone> benmachine: trying --constraint now, seems to do what i want. i have no idea what --preference is supposed to do. :-)
02:32:15 <benmachine> they both do something
02:32:19 <benmachine> but what, I don't know
02:33:52 <kamilyon> is there something i am missing with the tryhaskell.org site? I get an error when i type -> putStrLn "Hi"
02:34:38 <chrisdone> kamilyon: that's a sandboxing/security measure
02:34:56 <chrisdone> just type "Hi"
02:37:00 <chrisdone> balor: possibly this might be interesting: http://groups.google.com/group/comp.lang.functional/msg/22ea87a1cb8abfb8
02:37:10 <kamilyon> okay. the literal values do work and echo there value. is there a place to find all the limits of the sandbox so I don't have to ask too many questions? Or could you annotate the site.
02:37:31 <benmachine> kamilyon: why not just try stuff and see what works?
02:38:03 <chrisdone> balor: it deals with two sets and their exclusivity is enforced— see the -- oops line. sounds vaguely similar to what you want
02:39:14 <chrisdone> benmachine: siracusa: seems to be succeeding with constraint. --constraint forces use of that version, which is what i thought --preference did. i think i tend to confuse them
02:39:16 <kamilyon> benmachine: i did that to start and it is frustrating to start with one tutorial and have it say something is normal to work and not be able to do it in sandbox.
02:39:45 <benmachine> kamilyon: you should probably get your own ghci if you want to do serious haskell
02:39:54 <chrisdone> kamilyon: well the tryhaskell tutorial tells you what you can do in the sandbox
02:41:06 <chrisdone> basically any value that can be printed, i.e. an instance of the Show class, can be typed in there. it's meant more as a vehicle for the tutorial than a stand-alone console
02:43:30 <chrisdone> if i didn't have 55 dependencies i might move them all into a local cabal-dev thingie
02:44:26 <chrisdone> gienah: thanks for the tip
02:45:41 <kamilyon> benmachine/chrisdone: do you not recommend the tryhaskell for a beginner using anything but the built in tutorial and lessons? i did like the thought of analyzing some expressions. but I won't assume that is really like the ruby online interpreter. thank you.
02:48:25 <mietek> When I want to lift an IO operation to the IO monad transformed by ErrorT, I use liftIO
02:49:05 <mietek> I don't see a liftST, though
02:49:54 <mietek> Can I combine ST and Error?
02:50:05 <Saizan> if it's just one layer you can use "lift"
02:50:13 <Saizan> from Control.Monad.Trans
02:51:52 <chrisdone> kamilyon: yeah. it's for an absolute beginner to just do what the tutorial asks and maybe fiddle a bit. after that the idea is you then go to a book (Real World Haskell or Learn You a Haskell these days) and install GHC which has GHCi the interactive Haskell interpreter
02:52:20 <chrisdone> then you can do what you want. even launch missiles
02:56:16 <kamilyon> cool. will do. good day.
02:57:47 <mietek> Saizan: aha! Thanks
03:08:57 <mietek> @djinn (ErrorT String (ST s)) a -> (ErrorT String IO) a
03:08:57 <lambdabot> Error: Undefined type ErrorT
03:09:06 <mornfall> Ah, Cabal dependency hell strikes again. Can't install SHA now, because of a < 0.4 constraint on test-framework, while test-framework-quickcheck2 works with both 0.3.x and 0.4.x, so cabal flip-flops between two different builds of the latter, depending on what I built last.
03:09:10 <mornfall> Cool.
03:09:12 <mietek> @botsmack
03:09:12 <lambdabot> :)
03:09:39 <mietek> Saizan: ping
03:09:52 <ptd> :t length
03:09:52 <lambdabot> forall a. [a] -> Int
03:10:48 <nkpart> mornfall, yeah that sucks. I've moved to building projects with cabal-dev, doesn't really help when I'm installing haskell tools though
03:12:11 <ptd> Shouldn't there be a typeclass for length?
03:12:48 <byorgey> ptd: first of all, it ought to return any Integral type
03:13:13 <byorgey> ptd: you could also imagine making it work for many list-like things instead of just lists, according to some type class
03:13:30 <byorgey> see ListLike, http://hackage.haskell.org/package/ListLike
03:14:04 <quicksilver> ptd: there is a typeclass for length :)
03:14:30 <deggis> i've had some hackage trouble before, but with this error msg i'm not sure where to begin: http://hpaste.org/49616 ideas? :)
03:15:27 <ptd> quicksilver: what's it called?
03:15:45 <quicksilver> Foldable
03:15:49 <quicksilver> getSum . foldMap (const (Sum 1))
03:15:54 <quicksilver> is the generalisation of length.
03:16:11 <gienah> the encoding 0.6.6 package is different from the repo at http://code.haskell.org/encoding/ , it was uploaded by someone other than the maintainer, seems sort of forked to an unknown new repo
03:16:12 <quicksilver> rather less romantically, you can also use "length . toList", using the Foldable version of toList.
03:16:44 <mietek> I am confused by monad transformers
03:16:50 <mietek> foo :: (ErrorT e (ST s)) a -> (ErrorT e IO) a
03:17:28 <mietek> Have type, need body
03:17:32 <mietek> ;)
03:17:58 <byorgey> gienah: hmm, try emailing the listed maintainer and see if they know what is going on
03:18:07 <sipa> :t mapM
03:18:08 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
03:18:11 <sipa> :t fmap
03:18:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:18:18 <gienah> byorgey: thanks, will try this
03:18:35 <ptd> I've been thinking an awful lot of prelude could be redesigned for modern haskell.
03:19:13 <sipa> :t ap
03:19:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
03:22:27 <mietek> sipa: yes, and? :)
03:23:27 <mietek> I think I may need to unwrap and rewrap ErrorT
03:28:32 <balor> Is Extended Static Checking as mentioned here http://www.haskell.org/haskellwiki/Error_vs._Exception and exemplified here http://hpaste.org/49617 still supported in GHC?
03:30:53 <mietek> Oh man
03:30:56 <quicksilver> balor: it was never supported by GHC
03:30:59 <mietek> :t mapErrorT stToIO
03:31:00 <lambdabot> Not in scope: `stToIO'
03:33:02 <balor> quicksilver, thanks.
03:33:16 <quicksilver> balor: it was just a research project. No idea where it is now.
03:33:21 <quicksilver> balor: http://research.microsoft.com/en-us/um/people/simonpj/papers/verify/index.htm
03:35:23 <cwl> newtype NewtypeInt = N Int
03:35:23 <cwl>    deriving (Eq, Ord, Show)
03:35:28 <balor> quicksilver, Is there a reasonably well supported method of writing pre-conditions in Haskell?
03:35:36 <quicksilver> balor: not that I know of
03:35:37 <cwl> case undefined of N _ -> 1
03:35:46 <cwl> ghci> case undefined of N _ -> 1
03:35:49 <cwl> ghci> 1
03:35:50 <balor> quicksilver, thanks again.
03:36:13 <cwl> realworldhaskell says We don’t crash! Because there’s no constructor present at runtime, matching against
03:36:14 <cwl> N _ is in fact equivalent to matching against the plain wild card (_). Since the wild card
03:36:14 <cwl> always matches, the expression does not need to be evaluated.
03:36:38 <cwl> but ghci> case 1 of N _ -> 1 raise an exception
03:36:39 <cwl> why
03:36:54 <quicksilver> because 1 does not have the right type
03:37:09 <byorgey> it does not raise an exception, it fails to typecheck.
03:37:13 <cwl> quicksilver: does undefined have?
03:37:22 <quicksilver> 1 is a Num literal and NewtypeInt is not an instance of Num
03:37:24 <quicksilver> cwl: ues.
03:37:25 <sipa> it fails to compile, it doesn't fail to run
03:37:32 <quicksilver> cwl: undefined has every/any type
03:37:40 <byorgey> if you add Num to the list of derived type classes it will work.
03:38:02 <cwl> quicksilver: ohh
03:38:08 <byorgey> or I suppose even just adding Integral will make it work.
03:38:08 <cwl> I see
03:38:14 <cwl> wrong type
03:40:07 <quicksilver> very important to have clear in your head the different between runtime exception and compile time type error
03:40:12 <quicksilver> as byorgey/sipa point out
03:40:23 <quicksilver> if you're not paying attention that may not be obvious in ghci.
03:41:09 <sipa> if you'd be using ghc, you would realize the difference :)
03:50:42 <newbie|2> mod 3 2
03:51:10 <newbie|2> howto use the haskell interpreter here ?
03:51:54 <Saizan> > mod 3 2
03:51:55 <lambdabot>   1
03:52:11 <Saizan> you need "> " in front
03:52:45 <newbie|2> whats that sign called  in english
03:52:48 <newbie|2> >>
03:52:51 <newbie|2> <<??
03:54:01 <Saizan> greater than sign, maybe, i'm not sure
04:29:53 <TubeSteak> hi
04:30:18 <Botje> yow
04:30:24 <TubeSteak> is there a reason why there's no strict version of foldM?
04:31:13 <Botje> isn't that up to the monad?
04:33:11 * hackagebot xml-hamlet 0.0.0 - Hamlet-style quasiquoter for XML content  http://hackage.haskell.org/package/xml-hamlet-0.0.0 (MichaelSnoyman)
04:34:31 * JuanDaugherty wonders what "TubeSteak" means in Flemish kultur oder.
05:05:44 <chrisdone> deggis: that error message is hilarious
05:06:26 <chrisdone> deggis: i suspect there are different ghc versions at work
05:06:43 <chrisdone> deggis: what does ghc-pkg list ghc give?
05:08:01 <chrisdone> i suspect you have a global one requiring ==1.2.0.0
05:08:13 <chrisdone> and a local one, possibly installed from hackage, requiring filepath ==1.1.0.4
05:09:28 <chrisdone> or vise versa. hard to tell
05:12:44 <mreh> @where os
05:12:44 <lambdabot> I know nothing about os.
05:12:49 <mreh> @where o/s
05:12:50 <lambdabot> I know nothing about o/s.
05:13:31 <chrisdone> mreh: follow the yellow brick road
05:14:44 <mreh> house!
05:14:44 <lambdabot> mreh: You have 1 new message. '/msg lambdabot @messages' to read it.
05:17:06 <nda> hi
05:17:17 <mreh> shit, i closed my terminal before I could read the message
05:17:25 <mreh> hello
05:17:27 <nda> @pl \op f g -> op f `ap` g
05:17:27 <lambdabot> (ap .)
05:18:05 <chrisdone> mreh: it said ‘girugamesh’
05:18:13 <mreh> does @pl assume letters after 'f' are function?
05:18:20 <quicksilver> no.
05:18:36 <mreh> wouldn't that just be op
05:18:46 <mreh> or is that more generic
05:18:50 <quicksilver> @pl \x y z -> z y `ap` z
05:18:50 <lambdabot> const (join . (ap .) . flip id)
05:18:58 <quicksilver> erm
05:19:03 <quicksilver> @pl \x y z -> x y `ap` z
05:19:03 <lambdabot> (ap .)
05:19:08 <quicksilver> helps if you can type :)
05:19:12 <quicksilver> mreh: are you confusing op and ap?
05:19:25 <mreh> no, i;m just being dense
05:19:38 <mreh> look, i'm at work, and I'm bored
05:19:48 <mreh> and my bosses are probably reading this on the firewall logs
05:19:53 <quicksilver> steal someone's stapler and embed it in jelly
05:20:25 <mreh> there's noone called 'Garet' in this office
05:22:47 <mreh> but I do work not far from slough
05:22:51 <mreh> is that why you said it?
05:23:41 <chrisdone> mreh: you should use ssl ;-)
05:24:13 <chrisdone> quicksilver: or steal someone's jelly and embed it in a stapler. smash conventions
05:24:21 <quicksilver> chrisdone: I like it.
05:24:39 <nda> i admit, my pl query was somewhat stupid... and actually not what i had in mind
05:24:59 <quicksilver> chrisdone: mreh's machine has corporate root certificates, their firewall is a man in the middle.
05:25:23 <mreh> stop probing my servers
05:25:43 <mreh> it tickles
05:25:53 <mreh> are you saying I can't ssl
05:26:05 <mreh> googlemail works fine here
05:26:10 <mmjack> How do you define the argument for a  function with no return value? Like Int -> Int -> What?
05:26:28 <mreh> mmjack: that doesn't make sense in haskell
05:26:41 <mreh> mmjack: there are only values in haskell
05:27:39 <mreh> mmjack: it's a big paradigm shift from imperative programming
05:27:44 <mreh> I didn't mean to sound rude btw
05:28:35 <mmjack> Nono you didn't, I'm just confused as hell.  So functions with do such as creating a SDL window don't you don't/can't specify a type for input arguments?
05:29:11 <quicksilver> mmjack: Int -> Int -> IO ()
05:29:14 <quicksilver> mmjack: typically.
05:29:19 <chrisdone> functions that don't return anything meaningful usually return unit ()
05:29:20 <mreh> SDL libraries will typically operate in the domain of IO, which is magic
05:29:24 <quicksilver> that is actually a function which takes two int parameters and returns an IO action
05:29:31 <quicksilver> that IO action, when executed, does the work of making the window.
05:29:40 <mreh> see, magic
05:29:48 <nda> @pl \op f g -> uncurry op . (f &&& g)
05:29:48 <lambdabot> (. (&&&)) . (.) . (.) . uncurry
05:30:00 <nda> hehehe
05:30:11 <quicksilver> it may look like magic but actually it's implemented in perl
05:30:38 <mmjack> Thanks, still trying to get my head around all of this. I'll try that out
05:35:05 <erus`> how would you guys store the state of a game world with multiple entities of different types?
05:35:24 <mreh> :t liftA2 op f g
05:35:25 <lambdabot> forall o b (f :: * -> *). (Newtype b o, SimpleReflect.FromExpr (f (o -> b)), SimpleReflect.FromExpr (f b), Applicative f) => f o
05:35:25 <chrisdone> in a record type
05:35:30 <quicksilver> if the entities need to refer to each other
05:35:39 <quicksilver> then I'd give them some kind of Identifier/Name/Handle
05:35:43 <quicksilver> and I'd store a bunch of
05:35:47 <quicksilver> Map Id ThisThing
05:35:51 <quicksilver> Map Id ThatThing
05:35:56 <mietek> I need advice regarding binding style
05:35:59 <mietek> http://hpaste.org/49619
05:36:23 <erus`> in C++ i would use an array/vector of base entity types that contain derived entities
05:36:26 <mietek> I see two ways of binding a value for use in a loop
05:36:35 <mietek> But both seem ugly to me
05:36:37 <mietek> Any better ideas?
05:36:48 <mreh> :t \op f g -> uncurry op . (f &&& g)
05:36:49 <lambdabot> forall a b c (a1 :: * -> * -> *) b1. (Arrow a1, Functor (a1 b1)) => (a -> b -> c) -> a1 b1 a -> a1 b1 b -> a1 b1 c
05:36:59 <erus`> maybe in haskell i just use function pointers instead
05:37:00 <chrisdone> should i bring hpaste bot back in here?
05:37:12 <mreh> derp
05:37:22 <mreh> :t liftA2 op
05:37:22 <lambdabot> forall o b (f :: * -> *). (Newtype b o, Applicative f) => f (o -> b) -> f b -> f o
05:37:41 <mreh> derp derp
05:37:50 <benmachine> mietek: startLoop is unnecessary, you can call loop directly
05:37:53 <mreh> isn't nda after liftA2
05:37:59 <mreh> :t liftA2
05:37:59 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
05:38:32 <benmachine> chrisdone: why'd you take it away?
05:38:52 <mietek> benmachine: baz will not be in scope
05:38:54 <chrisdone> i didn't. someone kicked it
05:39:03 <benmachine> mietek: you call 'loop baz'
05:39:15 <benmachine> oh
05:39:16 <benmachine> wait
05:39:17 <mietek> You are missing the point
05:39:17 <benmachine> yes
05:39:18 <benmachine> I see
05:39:34 <benmachine> hmm
05:39:39 <mietek> I would like to avoid lugging around arguments in the loop invocation
05:39:48 <benmachine> are you trying to make this particular example better, or loops in general?
05:40:05 <mietek> Well, this is as minimized as I can imagine
05:40:15 <benmachine> replicateM_ 3 (useBaz baz)
05:40:17 <benmachine> ought to do it
05:40:32 <mietek> Hmm
05:40:44 <benmachine> combinators ftw :)
05:40:55 <mietek> That indeed does it for simple iteration
05:41:02 <mietek> But let me think about it some more
05:41:16 <benmachine> for complicated iteration, write more combinators :P
05:41:27 <Kaidelong> Windows Power Shell's cmdlets map very naturally to IO in Haskell, as they are little programs with an attached return type. Anyone exploited this in some kind of a haskell shell?
05:41:31 <benmachine> possibly foldM over a list
05:41:47 <mietek> Thanks, I'll think in this direction
05:42:26 <mreh> Kaidelong: Oleg was doing something with IO monad as unix pipe
05:42:48 <insane> Am I right by saying that, in GHC, before the translation to c-- the compiler generates stack machine code?
05:42:51 <nda> :t liftA2 (+)
05:42:51 <lambdabot> forall a (f :: * -> *). (Num a, Applicative f) => f a -> f a -> f a
05:43:08 <Kaidelong> mreh: Such that incorrect use of a pipe causes a type error to be displayed by the shell?
05:43:24 <mreh> > liftA2 (+) (Just 2) (Just 9)
05:43:24 <lambdabot>   Just 11
05:43:32 <Saizan> Kaidelong: i've been advocating something like that for a while but strangley noone implemented it, in the meantime i just use ghci
05:44:00 <Saizan> insane: no
05:44:15 <mreh> Kaidelong: i think he was just echoing the similarity
05:44:35 <chrisdone> Saizan: i also thought of that idea. doesn't every haskeller?
05:44:41 <Kaidelong> I do find Oleg's stuff to be hard to read
05:44:46 <mreh> so the other way round, the unix pipe is like the IO monad
05:44:55 <insane> Saizan: so you mean that it generates register machine code?
05:45:01 <mreh> i found his perfect shuffle algo to be very readable
05:45:07 <mreh> depends what level he's pitching at
05:45:10 <Saizan> insane: it generates STG-machine code
05:45:11 <Kaidelong> yeah but IO ConcreteType as opposed to IO a
05:45:48 <insane> Saizan: yes i know, but is it a stack or register machine?
05:45:52 <ion> Every function is ByteString -> IO ByteString :-P
05:45:59 <insane> Saizan: (i couldn't find that on wiki)
05:46:10 <benmachine> there is some interesting shell-related stuff in hackage
05:46:11 <benmachine> http://hackage.haskell.org/package/shellish
05:46:29 <mreh> hashell has a nice ring to it, i don't know if it's been taken
05:46:30 <Saizan> insane: i've never seen it called either of that, i wouldn't know
05:46:45 <nda> mreh, you are right about liftA2, thanks
05:46:56 <insane> Saizan: i see
05:47:01 <mreh> nda: I like that particularly use of Applicative
05:47:27 <mreh> it's the Reader Monad
05:47:36 <Saizan> chrisdone: some are quite opposed, iirc
06:04:18 <chrisdone> Error: src/Confy/Model/Submission.hs:1:0: Couldn't match expected type `Database.HaskellDB.HDBRec.RecNil'
06:04:19 <chrisdone>            against inferred type `Database.HaskellDB.HDBRec.RecCons
06:04:32 <chrisdone> … When using functional dependencies to combine arising from a use of `insert'                  at src/Confy/Model/Submission.hs:425:2-18
06:04:50 <chrisdone> in ghc7, do these error messages still appear with the useless line number?
06:05:14 <chrisdone> error on line 1 <loads of text> arising from use at line 425 (actual line number)
06:06:00 <chrisdone> (i'm still on 6.12)
06:16:46 <Kaidelong> what's an example of a Monoid instance where mappend has nothing to do with appending and mempty has nothing to do with being empty?
06:16:48 <benmachine> chrisdone: do you have a source file I can fail to compile and see?
06:17:03 <Kaidelong> the typeclassopedia says there are some but doesn't seem to elaborate on this
06:17:10 <benmachine> Kaidelong: it depends how generous you are with your idea of appending and empty
06:17:37 <benmachine> newtype Endo a = Endo { appEndo :: a -> a }; instance Monoid (Endo a) where mempty = id; mappend f g = f . g
06:17:42 <benmachine> er
06:17:55 <benmachine> newtype Endo a = Endo { appEndo :: a -> a }; instance Monoid (Endo a) where mempty = Endo id; mappend (Endo f) (Endo g) = Endo (f . g)
06:18:10 <benmachine> is id 'empty'? is composition appending?
06:18:13 <benmachine> ...maybe.
06:18:24 <Kaidelong> in the case of Endo it would be, really
06:18:34 <benmachine> how do you mean
06:19:16 <Kaidelong> you can just see composition as arranging the Endo's in order without any special need to have them in one particular order for it to work
06:19:36 <Kaidelong> or putting them on a list
06:19:45 <benmachine> ...
06:19:47 <benmachine> well
06:19:55 <Kaidelong> and id is just the case where you have no Endo operations at all
06:20:14 <benmachine> sure
06:20:15 <benmachine> but
06:20:22 <benmachine> id isn't 'empty' in any real sense itself
06:21:22 <quicksilver> in the multiplication monoid on the integers
06:21:30 <quicksilver> I do not think 1 is empty.
06:22:58 <Kaidelong> oh yeah, I think that's a good point
06:23:09 <Kaidelong> in the multiplication monoid, you work with prime factorizations
06:23:17 <benmachine> huh?
06:23:19 <quicksilver> it is actually the same point :)
06:23:22 <quicksilver> 1 = *1 = id
06:23:35 <quicksilver> but I thought I'd use a different notation for the same monoid to pull the wool over your eyes.
06:23:36 <Kaidelong> but
06:23:42 <benmachine> heh
06:23:46 <Kaidelong> you do not simply append [1, 2, 3] to [1, 5]
06:23:54 <Kaidelong> to get [1, 2, 3, 5]
06:24:02 <benmachine> ...what
06:24:03 <Kaidelong> like you would with the sum monoid
06:24:20 <Ptival> why lists?
06:24:21 <Kaidelong> where you just append the unary representations
06:24:36 <benmachine> who's using unary representations?
06:24:38 <quicksilver> that's not prime factorisations
06:24:44 <quicksilver> 1 isn't prime
06:24:53 <Kaidelong> right
06:24:55 <Ptival> good point ^
06:24:58 <Kaidelong> you can omit 1
06:24:59 <quicksilver> if you take 1 out you actually *do* append
06:25:20 <benmachine> but there are multiplication monoids where primes don't exist
06:25:22 <quicksilver> all memptys are actually id
06:25:22 <Kaidelong> hmm, do you? oh right, because of prime powers
06:25:27 <benmachine> like "integers mod 6"
06:25:31 <joe6> is there an until for monads? i like the forever, but want to add an exit condition to forever..
06:25:32 <quicksilver> because all monoids are function monoids
06:25:39 <benmachine> or they do exist but unique factorisation might not
06:26:04 <benmachine> quicksilver: in what sense
06:26:34 <mreh> isn't empty just an identity
06:26:55 <mreh> they use empty and append in analogy with lists
06:27:06 <benmachine> right
06:27:44 <joe6> found monad-loops.
06:27:52 <Kaidelong> anyway this just had to do with me wondering about the phrasing used in the typeclassopedia
06:28:03 <benmachine> Kaidelong: it all depends what you think of as empty and append
06:28:16 <quicksilver> benmachine: every monoid acts on itself by multiplication
06:28:18 <Kaidelong> I was doubting a bit that there were examples of monoids where the mempty and append operations do not in some fundamental way resemble the ones for lists
06:28:36 <quicksilver> benmachine: so you can represent every monoid as a particular submonoid of the Endo monoid over that same set.
06:28:44 <benmachine> quicksilver: oh, right, like permutation representations of groups?
06:28:46 <Kaidelong> but I think in the case of groups of integers modulo n they really don't
06:28:49 <quicksilver> benmachine: yes.
06:29:02 <quicksilver> benmachine: representation theory - yet another tool to prove that everything is in fact the same.
06:29:06 <benmachine> wooo
06:29:09 * quicksilver watches all of mathematics fade into grey mush.
06:29:43 <benmachine> Kaidelong: do you understand the concept of "free" monoids, or "free" structures in general?
06:29:55 <Kaidelong> No
06:29:58 <benmachine> oh
06:29:59 <benmachine> well
06:30:02 <benmachine> it might interest you
06:30:22 <mercury^> quicksilver: did you just explain the Yoneda embedding?
06:31:04 <quicksilver> mercury^: not deliberately :)
06:31:24 <quicksilver> mercury^: it is, of course a special case of the yoneda embedding but then again *everything* is a special case of the yoneda embedding, isn't it?
06:31:54 <mercury^> Nope, just many things. :)
06:35:01 <mercury^> Kaidelong: start by realising that a structure F(S) on a set S contains S as a set, and a homomorphism from F(S) to any structure G is determined by the images of the elements of S.
06:35:17 <mercury^> a free structure F(S)*
06:36:53 <mreh> could I do a bredth first search as an unfold?
06:37:13 <mreh> better still as a hylomorphism
06:37:38 <mreh> :t unfold
06:37:39 <lambdabot> Not in scope: `unfold'
06:37:40 <mreh> :t unfoldr
06:37:41 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
06:39:42 * hackagebot syntactic 0.5 - Generic abstract syntax, and utilities for embedded languages  http://hackage.haskell.org/package/syntactic-0.5 (EmilAxelsson)
06:41:25 <joe6> whileJust_ :: Monad m => m (Maybe a) -> (a -> m b) -> m ()
06:41:39 <joe6> is there :: Monad m => m (Maybe a) -> (a -> m ()) -> m ()
06:41:51 <joe6> i could add a return something..
06:41:53 <mreh> yes
06:42:00 <mreh> b = ()
06:42:05 <joe6> but, just curious, if there is anything better..
06:43:41 <joe6> mreh, thanks.
06:44:09 <mreh> where does whileJust_ come from?
06:46:47 <ion> :t \f x -> x >>= maybe (return ()) f
06:46:47 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m ()) -> m (Maybe a) -> m ()
06:49:17 <mreh> hole in one!
06:50:07 <joe6> mreh, control.monad.Loops
06:50:25 <joe6> > :t whileJust_
06:50:26 <lambdabot>   <no location info>: parse error on input `:'
06:53:43 * hackagebot time-w3c 0.1.0.1 - Parse, format and convert W3C Date and Time  http://hackage.haskell.org/package/time-w3c-0.1.0.1 (MasatakeDaimon)
06:55:45 <Twey> :t whileJust_
06:55:45 <lambdabot> Not in scope: `whileJust_'
07:02:57 <mreh> like a monadic unfold
07:03:14 <gwern> lambdabot:
07:03:15 <gwern> > (-1 + -2 + 2 + -3 + 10 + 7 + 0 + -4 + -2 + 3) / 10
07:03:16 <lambdabot>   Precedence parsing error
07:03:16 <lambdabot>      cannot mix `GHC.Num.+' [infixl 6] and prefix ...
07:04:01 <gwern> > let x = [-1, -2, 2, -3, 10, 7, 0, -4, -2, 3] in sum x / length x
07:04:01 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
07:04:01 <lambdabot>    arising from a use o...
07:04:33 <gwern> > let x = [-1, -2, 2, -3, 10, 7, 0, -4, -2, 3] in fromIntegral (sum x) / fromIntegral (length x)
07:04:34 <lambdabot>   1.0
07:04:39 <mreh> when does the crazy number system get revamped?
07:04:57 <gwern> mreh: not soon enough
07:05:07 <sipa> @vixen when does the crazy number system get revamped?
07:05:08 <lambdabot> when is a good time?
07:05:09 * gwern wonders if that is even right. 1.0 is suspiciously round
07:05:46 <ion> sum x / genericLength x
07:05:51 <mreh> >sum [-1, -2, 2, -3, 10, 7, 0, -4, -2, 3]
07:05:54 <mreh> > sum [-1, -2, 2, -3, 10, 7, 0, -4, -2, 3]
07:05:54 <lambdabot>   10
07:06:10 <gwern> > let x = [-1, -2, 2, -3, 10, 7, 0, -4, -2, 3] in sum x / genericLength x
07:06:10 <lambdabot>   1.0
07:06:54 <gwern> mreh: good point, I could have just summed andseen for myself that 1.0 was right
07:06:56 <ion> > liftA2 (/) sum genericLength [1..3]
07:06:56 <lambdabot>   2.0
07:30:37 <edenpulse> ptin ya du monde ici
07:56:28 <cpa> what should I read if I want to be convinced that map f . map g doesn't have the same operational behaviour that map (f . g) ?
07:57:15 <ski> maybe GHC source ?
07:57:35 <Eduard_Munteanu> Isn't that a deforestation rule?
07:57:46 <ski> with a graph-rewriting implementation, it's kinda obvious
07:57:55 <dolio> You should work it out by hand.
07:58:10 <Botje> cpa: check the paper 'from lists to streams to nothing at all'
07:58:12 <dolio> Rewriting.
07:58:29 <Botje> that is the basis for GHCs fusion
07:58:31 <ski> Eduard_Munteanu : deforestation would be to automatically replace the former by the latter
07:58:49 <ski> cpa : but do what dolio suggests
07:58:54 <cpa> I know that this kind of deforestation is the idea behind fusion
07:59:07 <Eduard_Munteanu> ski: you mean there's a problem going from   map (f . g)   to    map f . map g?
07:59:08 <thoughtpolice> i don't think cpa mentioned deforestation at all, but by rewriting it like dolio said it should be easy to convince yourself that map (f . g) has different operational behavior than map f . map g
07:59:27 <cpa> dolio: I did tried by hand, but I probably something then
07:59:28 <ski> Eduard_Munteanu : problem ?
07:59:31 <cpa> I'll try again
07:59:55 <Eduard_Munteanu> Ok, maybe I'm misreading this.
08:00:38 <Eduard_Munteanu> Would it just mean small-step operational semantics are different, but the behaviour is essentially the same?
08:00:42 <ski> cpa : the difference isn't *very* big. the difference is just avoiding creating cons cells for the intermediate list
08:00:57 <ski> Eduard_Munteanu : yes
08:01:07 <Eduard_Munteanu> Ah, I see.
08:02:04 <ski> cpa : a more interesting example could be comparing something that traverses the *same* list twice, vs. traversing it only once -- e.g. computing average
08:02:15 <int-e> But if f and g don't allocate you've halved the total number of allocations.
08:02:26 <cpa> ski: like what ?
08:04:10 <thoughtpolice> like computing average. average requires you to have the sum of the elements of the list and divide that by the # of elements in the list. so with something like avg xs = sum xs / length xs or what have you, the list must be traversed twice
08:04:20 <ski> int-e : yeah -- i just meant that the difference in the `map f . map g' vs. `map (f . g)' case isn't of the "unnecessarily keeping hold of long lists for a long time"
08:04:26 <ski> kind
08:04:38 <ski> cpa : like computing average, like i said
08:04:59 <cpa> ski: yeah, I missed it sorry
08:05:44 <cpa> so in the case of map f.g vs map f . map g, I only create one cons cell more
08:06:15 <ski> cpa : one cons cell more for each cons cell in the result list that gets forced
08:07:45 <cpa> ski: otherwise it costs a thunk anyway
08:08:37 <cpa> what happens for the first two elements of: (map f . map g $ [1..10]) !! 3
08:08:55 <saml> lost in abyss
08:09:13 <saml> oh i think they are evaluated
08:09:34 <cpa> why would they be?
08:09:43 <mreh> because of the evaluation order
08:09:43 <saml> maybe not
08:09:53 <mreh> they won't be fully evaled
08:10:01 <saml> is !! strickt?
08:10:04 <mreh> but unconsed
08:10:11 <sipa>  only the trunk will be evaluated
08:10:17 <sipa> not the values
08:10:24 <int-e> ski: fair enough
08:10:36 <sipa> eh, spine, or whatever it is called
08:10:58 <saml> > let f x = trace "asdf" x in (map f [1..10]) !! 3
08:10:59 <lambdabot>   Not in scope: `trace'
08:11:10 <saml> @import Debug.Trace
08:11:10 <lambdabot> Unknown command, try @list
08:11:54 <ski>   \ns -> let s = foldr (+) 0 ns; c = foldr (const (1 +)) 0 ns in s / c
08:11:54 <saml> let f x = trace ("asdf" ++ show x) x in (map f [1..10]) !! 3
08:11:56 <ski> vs.
08:12:02 <ski>   \ns -> let (s,c) = foldr (\n -> ((+) n) *** (const (1 +) n)) (0,0) ns in s / c
08:12:04 <saml> it prints   asdf4
08:12:19 <saml> so f isn't applied to the first three elements
08:13:02 <erus`> anyone know of a markup language like json where the keys can contain spaces etc?
08:13:35 <mreh> erus` build your own
08:13:39 <erus`> i am
08:13:40 <EvanR7> erus`: json isnt a markup language
08:13:47 <erus`> but i didnt wanna re-invent the wheel
08:13:50 <EvanR7> and json objects field names can have spaces
08:14:04 <mreh> always re-invent the wheel, then you learn
08:14:15 <EvanR7> mreh: unless youre trying to do a job
08:14:25 <EvanR7> then i hope you come to your senses
08:14:41 <ski> cpa : re `(map f . map g) [0 .. 9] !! 3', the first two cons cells are of course constructed, but the contents are not evaluated
08:14:46 <saml> is there strict map?
08:15:20 <quicksilver> erus`: { "a b" : "c d" } is valid JSON AFAIK
08:15:25 <EvanR7> it is
08:15:33 <ski> cpa : anyway, i think the two versions above should illustrate the "average" example
08:15:50 <erus`> oh
08:15:52 <ski> hm, though i suppose it's nicer written as
08:15:53 <erus`> Thats easier
08:15:55 <erus`> :P
08:16:12 <ski>   \ns -> let (s,c) = (foldr (+) 0 ns,foldr (const (1 +)) 0 ns) in s / c
08:16:14 <ski> vs.
08:16:16 <EvanR7> erus`: the field names are arbitrary text
08:16:18 <ski>   \ns -> let (s,c) = foldr (\n -> ((+) n) *** (const (1 +) n)) (0,0) ns in s / c
08:16:43 <erus`> EvanR7 i thought they had to be valid js variable names?
08:16:49 <EvanR7> no
08:17:00 <EvanR7> try it and ready the spec
08:17:02 <EvanR7> read*
08:17:40 <ndunn> hi!
08:17:54 <quicksilver> erus`: { "a b" : "c d" } is valid javascript syntax, too
08:17:55 <cpa> ok, I get it
08:17:58 <cpa> thanks
08:18:15 <quicksilver> erus`: try x = { "a b" : "c d" } and then x["a b"]
08:18:34 <erus`> cheers
08:19:12 <erus`> im making a cv generator :I
08:21:03 <erus`> because my word document was a mass of messy tables
08:32:37 <tomh-> hmm is there a function that concats two Maybe lists?
08:32:56 <quicksilver> tomh-: liftA2 (++)
08:33:06 <tomh-> cool thanks
08:33:16 <quicksilver> > liftA2 (++) (Just [1,2,3]) (Just [4,5,6])
08:33:17 <lambdabot>   Just [1,2,3,4,5,6]
08:33:40 <tomh-> > liftA2 (++) Nothing (Just [1,2,3])
08:33:41 <lambdabot>   Nothing
08:33:44 <tomh-> hmm
08:34:14 <Jafet> @hoogle Maybe a => [a]
08:34:14 <lambdabot> Warning: Unknown class Maybe
08:34:14 <lambdabot> Prelude repeat :: a -> [a]
08:34:14 <lambdabot> Data.List repeat :: a -> [a]
08:34:15 <tomh-> I need one that returns the [1,2,3] there, or does that not make sense?
08:34:19 <ion> > Nothing `mappend` Just [4..6]
08:34:19 <lambdabot>   Just [4,5,6]
08:34:21 <Jafet> @hoogle Maybe a -> [a]
08:34:21 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
08:34:21 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
08:34:21 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
08:34:28 <ion> > Just [1..3] `mappend` Just [4..6]
08:34:29 <lambdabot>   Just [1,2,3,4,5,6]
08:34:29 <tomh-> ah mappend thanks :D
08:34:42 <Jafet> Or the monoid, sure...
08:34:59 <pr> > Nothing `mappend` Just [1,2,3]
08:35:00 <lambdabot>   Just [1,2,3]
08:35:43 <Jafet> > (concat `on` maybeToList) Nothing (Just [1..3])
08:35:43 <lambdabot>   Couldn't match expected type `[[a]] -> c'
08:35:43 <lambdabot>         against inferred type `[a]'
08:35:49 <Jafet> > ((++) `on` maybeToList) Nothing (Just [1..3])
08:35:50 <lambdabot>   [[1,2,3]]
08:36:02 <Jafet> Hrm, maybe not.
08:36:55 <ion> > ((++) `on` concat . maybeToList) Nothing (Just [1..3])
08:36:56 <lambdabot>   [1,2,3]
08:37:17 <copumpkin> > Just [1..3] ++ Just [5..7]
08:37:19 <lambdabot>   Just [1,2,3,5,6,7]
08:37:26 <copumpkin> > Nothing ++ Nothing
08:37:27 <lambdabot>   Nothing
08:37:42 <copumpkin> tomh-: what should it do with two Nothings?
08:37:55 <ion> maybe ]
08:37:56 <tomh-> return a Nothing
08:38:07 <ion> > maybe [] id (Nothing `mappend` Nothing)
08:38:07 <lambdabot>   []
08:38:10 <copumpkin> okay, so mappend is what you want
08:38:19 <tomh-> yeah it was exactly what I want :)
08:38:55 <benmachine> :t concatMap maybeToList
08:38:56 <lambdabot> forall b. [Maybe b] -> [b]
08:39:15 <tomh-> > Just [1] ++ Just [1]
08:39:16 <lambdabot>   Just [1,1]
08:39:21 <tomh-> hmm why did that work?
08:39:21 <ion> @pl maybe [] id -- Does pl change that to fromMaybe []?
08:39:21 <lambdabot> maybe [] id
08:39:33 <tomh-> > Just [1] ++ Nothing
08:39:34 <lambdabot>   Just [1]
08:39:35 <benmachine> @pl liftM
08:39:35 <lambdabot> fmap
08:39:44 <ion> tomh: Caleskell has (++) = mappend
08:39:47 <tomh-> you need to import Data.Monoid for ++ to work with maybe?
08:39:47 <PatrickRobotham> >:t ++
08:40:06 <benmachine> tomh-: no, you need to import Prelude hiding ((++)) and then define (++) = mappend
08:40:13 <tomh-> ah ok
08:40:21 <benmachine> or you can just not do that
08:40:23 <Twey> PatrickRobotham: > is a shortcut for @run; :t is a shortcut for @type
08:40:25 <benmachine> up to you :P
08:40:29 <Twey> :t (++)
08:40:29 <lambdabot> forall m. (Monoid m) => m -> m -> m
08:40:30 <tomh-> well I just use mappend
08:43:00 <PatrickRobotham> Twey: How is (++) defined now?
08:44:10 <ion> > let append [] ys = ys; append (x:xs) ys = x:append xs ys in "foo" `append` "bar"
08:44:11 <lambdabot>   "foobar"
08:44:50 <ion> > let append xs ys = foldr (:) ys xs in "foo" `append` "bar"
08:44:51 <lambdabot>   "foobar"
08:44:56 <PatrickRobotham> ion: lambdabot says that it's defined for monoids now though...
08:45:07 <djahandarie> PatrickRobotham, yeah, that's lambdabot-specific stuff
08:45:07 <Twey> PatrickRobotham: In the normal Haskell Prelude, it's: [] ++ ys = ys; xs ++ [] = xs; (x : xs) ++ ys = x : (xs ++ ys)
08:45:14 <PatrickRobotham> djahandarie: Oh.
08:45:19 <ion> patrickrobotham: Caleskell has (++) = mappend
08:45:20 <Twey> PatrickRobotham: In lambdabot it's defined specially, as (++) = mappend
08:45:22 <djahandarie> It's just mappend in lambdabot
08:45:50 <djahandarie> @quote contrapuntal
08:45:50 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
08:46:23 <PatrickRobotham> :)
08:46:28 <companion_cube> someone here has read hofstadter
08:50:16 <kmc> companion_cube, :D
08:51:33 <k0ral> hi, I'm trying to install hpaste on my machine but it complains about no available version of HAppS that satisfies >0.8.4
08:51:54 <k0ral> is the package outdated ?
08:52:39 <k0ral> besides, there are differences between the package on hackage and the package on github
08:53:00 <k0ral> ohhhh
08:53:11 <k0ral> actually it's called amelie ?!
08:53:41 <k0ral> hmmm not even
08:53:51 <kmc> it hasn't been called HAppS in a while
08:54:19 <kmc> the hpaste on hackage is a totally different codebase
08:54:21 <k0ral> I can see several HApps-* packages
08:54:24 <kmc> it's the old hpaste.org
08:54:39 <k0ral> why isn't the current one hosted on hackage ?
08:54:48 <thoughtpolice> yeah, chrisdone basically rewrote it all and took over maintenance from glguy i think it was
08:54:53 <kmc> beats me, ask chrisdone
08:55:17 <kmc> hackage is a great way to distribute libraries; it's less clear what the advantage is for something like a web app
08:55:19 <k0ral> chrisdone: ^
08:56:50 <k0ral> kmc: can't see why hackage wouldn't be as convenient for web apps as for any usual desktop app
08:57:31 <glguy> Yeah, the only place that uses the hold fastcgi hpaste now is here at my job :)
08:57:35 <glguy> old*
08:59:09 <thoughtpolice> k0ral: well, i could see like, a tool that starts an HTTP server and gives you a web app there to do things. that could be useful on hackage. but hpaste? it's already maintained and run by chris, and it's not something one really would run locally generally speaking, considering there's already an 'official' hpaste
08:59:11 <glguy> and the happs hpaste predates that version
08:59:33 <k0ral> still problems with the new one called amelie: It requires pgsql-simple >=0.1.1 and stepeval >=0.2 which aren't available
08:59:39 <glguy> We use a paste bin internally for sharing bits of text. I can see other people wanting that
09:00:47 <k0ral> thoughtpolice: why wouldn't people want to run a hpaste on their own server ?
09:01:08 <kmc> glguy, where do you work?
09:01:19 <glguy> kmc: galois
09:01:27 <kmc> cool
09:02:10 <kmc> i bet galois has an internal pastebin with statically-verified information isolation between classified and unclassified pastes ;)
09:02:26 <copumpkin> lol
09:02:39 <copumpkin> that presburger solver needs to be integrated somewhere, too
09:02:46 <copumpkin> the one that iavor wrote
09:03:02 <copumpkin> so it can statically verify constraints on paste dependencies through that
09:03:17 <kmc> mmm, presburger
09:05:35 <glguy> I was playing with my regular expression type last night. it was kind of cool that the utf8-support function ended up  as:   mkutf8RegExp r = r >>= foldr1 Sequence . map Symbol . encodeChar
09:05:43 <glguy> (good thing I thought to add that monad instance)
09:06:35 <thoughtpolice> k0ral: well, they could, but i don't see much of an advantage to something like just using hpaste.org itself, or even gist.github.com - i'm not saying it shouldn't be uploaded, i just don't actually think it would be of tremendous use to a lot of people
09:06:40 <thoughtpolice> that's all
09:06:48 <copumpkin> glguy: wait, utf-8 in agda?
09:07:08 <thoughtpolice> k0ral: OTOH, i guess glguy just showed that they use their old hpaste internally at galois, so :P
09:07:09 <glguy> copumpkin: that was in haskell so I could write RegExp Chars but use them as RegExp Word8s
09:07:25 <copumpkin> oh I see
09:07:48 <copumpkin> glguy: you gonna prove that regular languages are closed under the operations they're closed under? :P
09:08:04 <glguy> I'm working toward having a haskell implementation of a lexer which I could use in template haskell instead of preprocessing my files with alex
09:09:20 <copumpkin> y u no use agda? :(
09:09:40 <glguy> Sometimes you have to write programs that do something and sometimes you write programs to see them typecheck
09:09:51 <copumpkin> :(
09:10:39 <chrisdone> k0ral: ohai
09:11:57 <chrisdone> k0ral: so stepeval and pgsql-simple are preliminary libraries not yet released: https://github.com/chrisdone/pgsql-simple and https://github.com/chrisdone/stepeval
09:12:34 <chrisdone> k0ral: you have cabal-dev?
09:13:48 <chrisdone> i would put amelie on hackage but yeah these two libraries aren't released so it wouldn't work
09:14:33 <chrisdone> i do want people to be able to build and run it locally though, so people can Send Patches
09:14:51 <copumpkin> chrisdone: by the way, did your IRC search code ever go public?
09:15:07 <Twey> happstack ≠ amelie
09:15:19 <Twey> (er… totally relevantly)
09:16:20 <chrisdone> copumpkin: it always gets passed over for another project. i think 'no one cares anyway only i search old irc logs' and do something else :p
09:16:27 <copumpkin> lol
09:16:37 <copumpkin> I think any op would care :)
09:16:48 <copumpkin> and it's also just good for the sake of keeping a nice history
09:19:01 <chrisdone> alright if cocopops wants it i'll make it higher prio
09:20:08 <copumpkin> :)
09:21:06 <chrisdone> i'll try it tonight. it's friday-1
09:22:24 <chrisdone> what are you working on? do you make anything these days? iirc you fell in a river of CT and dependent types and washed down stream. if i made a graph of your hpaste pastes over time it would be
09:22:28 <chrisdone> obscurity /
09:22:30 <chrisdone>     time
09:22:33 <chrisdone> :-)
09:22:44 <copumpkin> lol
09:22:56 <copumpkin> hmm
09:23:14 <chrisdone> it's fun how you can see Evolution of a Haskell Programmer by looking at their hpastes
09:23:47 <copumpkin> yeah, spent a lot of time on that CT lib, and a bit of time on a repa in agda and a few other assorted agda proofs :P
09:24:12 <quicksilver> agda is an alluring trap for haskell programmers who hope to write better code
09:24:21 <quicksilver> instead they end up writing no code.
09:24:24 <chrisdone> :p
09:24:27 <copumpkin> I write lots of code
09:24:30 <copumpkin> :P
09:24:42 <mokus> how much of it is at the value level? ;)
09:24:49 <copumpkin> oh, most of it!
09:24:56 <chrisdone> i saw webkit in agda and gtk+ in agda on hpaste which was fairly surprising
09:25:00 <copumpkin> those values just happen to have insane types
09:25:21 <chrisdone> http://hpaste.org/43574/webkit_for_agda
09:25:30 <ion> @remember quicksilver agda is an alluring trap for haskell programmers who hope to write better code. instead they end up writing no code.
09:25:31 <lambdabot> Done.
09:25:36 <copumpkin> lol
09:26:06 <chrisdone> gtkEntrySetText uriEntry "http://www.reddit.com" ,,
09:26:15 <chrisdone> hehe. programmers can be so stereotypical
09:26:29 <Saizan> quicksilver: no code that gets run, you meant?:)
09:27:14 <chrisdone> copumpkin: do you have a center of agda proofs online somewhere?
09:27:20 <copumpkin> nope :)
09:27:26 <copumpkin> I suck at having a consistent online presence
09:27:37 <glguy> I'd say you are pretty consistently online
09:29:19 <quicksilver> Saizan: yes, or, well, less and less code.
09:29:21 <chrisdone> copumpkin's last words of his online presence will be: I have discovered a truly marvellous Agda proof of this, which this hpaste annotation is too short to contain.
09:30:17 * chrisdone misses mmorrow again
09:31:08 * chrisdone goes home
10:02:33 <tomh> hmm if you have a set comprehension like {ab | a <- something, b<- something} does that mean a is applied to be?
10:03:02 <tomh> (I don't mean list comprehension from haskell, but the formal set comprehension)
10:04:13 <sipa> i think it means tuples (a,b)
10:04:37 <arcatan> my first guess would have been some kind of product of a and b
10:15:48 <mightybyte> Do type classes have a kind?
10:16:02 <c_wraith> the type variables in them do
10:16:07 <mightybyte> Yeah, I know that.
10:16:10 <monochrom> no
10:16:10 <c_wraith> the classes themselves, not really
10:16:19 <mightybyte> Ok.  That's what I thought.
10:16:22 <mightybyte> Just wanted to check.
10:16:25 <sipa> a type class is a predicate over types
10:16:43 <PatrickRobotham> tomh: xy usually denotes x*y
10:16:53 <monochrom> oh, unless you have mptc and you ask "how many parameters". but you just need a number for that, not a kind
10:17:06 <PatrickRobotham> or ordered pairs, or concatenation.
10:17:09 <mightybyte> monochrom: Yeah, that was the context of my question.
10:17:57 <sipa> well, i guess you could call type classes to be  of "kind" * -> Bool
10:18:14 <monochrom> you just need a number like "5" rather than an elaborate kind expression like "((* -> *) -> *) -> * -> *"
10:18:38 <tomh> PatrickRobotham: so in terms of haskell, that would be a tuple?
10:18:47 <sipa> hmm, the type class Monad would be of kind (* -> *) -> Bool
10:18:54 <mokus> I tend to think of them as having kinds ending in "-> !", and => as an operator with kind "! -> * -> *"
10:19:04 <byorgey> type classes DO have kinds.
10:19:17 <mightybyte> monochrom: But wouldn't an elaborate kind expression also have meaning there?
10:19:23 <monochrom> "ab" in math has a high probability of meaning a*b
10:19:29 <PatrickRobotham> tomh. Haskell would raise a syntax error.
10:19:47 <monochrom> no, there is no type class of kind ((* -> *) -> *) -> * -> *
10:19:53 <byorgey> you cannot ask ghci for the kind.  But internally type classes are just translated to type constructors for a dictionary.
10:19:58 <PatrickRobotham> tomh. (a,b) denotes tuple. a*b denotes multiplication, a b denotes function application.
10:20:05 <mightybyte> byorgey: Ahh
10:20:27 <tomh> PatrickRobotham: what does it mean when two elements of a list multiply, if they are not numbers?
10:20:38 <byorgey> class Foo f where  bar :: f Mu Int -> Int
10:20:42 <ion> There should be a kind-level fix function. fix ((->) *) would be cool.
10:20:48 <byorgey> Foo :: ((* -> *) -> *) -> * -> *
10:20:50 <PatrickRobotham> tomh: Could you give an example?
10:21:04 <tomh> say you have two lists of letters or functions
10:21:15 <tomh> and you have a set comphrehension of the one I wrote above
10:21:18 <monochrom> wait, no, that's implementation detail
10:21:35 <PatrickRobotham> tomh:  In math? I'd read as concatenating strings.
10:21:45 <tomh> how about functions?
10:21:53 <PatrickRobotham> composition
10:22:04 <tomh> right ok, so that was what I was initially thinking too, thanks
10:22:08 <monochrom> no, even "implementation detail" is not quite right. that's an implementation method. you don't have to do it. if you don't do it, you don't give type class a kind.
10:22:25 <byorgey> monochrom: but the kind matters.  For example:
10:22:33 <byorgey> > let f :: Num Maybe => Int; f = 3
10:22:33 <lambdabot>   not an expression: `let f :: Num Maybe => Int; f = 3'
10:22:40 <byorgey> > let f :: Num Maybe => Int; f = 3 in f
10:22:40 <lambdabot>   `Data.Maybe.Maybe' is not applied to enough type arguments
10:22:40 <lambdabot>  The first argum...
10:22:54 <byorgey> you get that kind error because it knows the kind of Num is * -> *
10:23:08 <byorgey> although it doesn't come out and say anything about the kind of Num.
10:23:08 <PatrickRobotham> tomh: It's horribly imprecise though.
10:23:45 <djahandarie> There is a proposition for a typeclass kind
10:23:49 <byorgey> > let f :: (Monad a, Num a) => a -> a; f x = x  in f 2
10:23:49 <lambdabot>   `a' is not applied to enough type arguments
10:23:49 <lambdabot>  The first argument of `GHC.Num...
10:24:10 <byorgey> there we get a kind error because the arguments of Monad and Num have different kinds
10:24:11 <djahandarie> I forget what it's called though...
10:24:32 <tomh> PatrickRobotham: yeah, I guess
10:24:34 <sipa> byorgey: you say the kind of Num is * -> * ?
10:24:36 <djahandarie> Aha: http://hackage.haskell.org/trac/ghc/wiki/KindFact
10:24:41 <byorgey> so even if you don't want to say that type classes have a kind, you at least have to say that they have a list of argument kinds
10:24:46 <sipa> so Num Int represents a type of kind *?
10:25:28 <byorgey> sipa: well, or maybe we could say that it has kind  * -> DICTIONARY
10:25:41 <byorgey> but given GHC's implementation DICTIONARY = *
10:25:45 <sipa> i'd say it has kind * -> Bool :)
10:26:04 <monochrom> screw dictionary
10:26:05 <byorgey> Bool?
10:26:10 <sipa> Num Int evaluates to True, Num (a -> b) evaluates to False :)
10:26:35 <sipa> yeah, i know, i'm mixing type-level and value-level stuff
10:26:46 <kmc> Num :: * -> Prop
10:26:51 <mokus> I'd say more like the sierpinski space
10:26:55 <byorgey> yes, Prop is better =)
10:26:56 <mokus> false-ness isn't observable
10:26:56 <sipa> but it is a predicate over types, and i consider predicates as functions to booleans :)
10:27:04 <kmc> there's a proposal to add the syntax in GHC
10:27:09 <kmc> I think they use "Fact" instead of "Prop"
10:27:11 <kmc> bbl
10:27:20 <byorgey> sipa: functions to booleans is only one (of many) ways to represent predicates.
10:27:26 * hackagebot mime 0.3.3 - Working with MIME types.  http://hackage.haskell.org/package/mime-0.3.3 (IavorDiatchki)
10:27:27 <sipa> byorgey: of course
10:27:46 <mokus> In the absence of an instance, "Num (a -> b)" isn't False, it's just "not known to be True"
10:27:50 <sipa> the most natural representation is as a set, i guess
10:27:55 <sipa> mokus: agree
10:28:11 <monochrom> I'll take list of argument kinds
10:28:31 * sipa proclaims Num to be of kind "Set of *"
10:29:09 <byorgey> monochrom: OK. And I agree now that saying type classes have a kind is not really correct.  I was reacting to the claim that it would suffice to just have a natural representing the number of arguments.
10:29:11 <monochrom> I do this following the no-junk policy
10:29:48 <byorgey> monochrom: right, because  * -> (* -> *) would not be a valid kind for a type class
10:29:57 <mightybyte> Ahhh, I see.
10:30:00 <sipa> monochrom: list of kinds... that is on itself an expression of a type one degree above kinds :)
10:31:04 <mightybyte> But you could view "x -> y -> z" (where x, y, and z are kinds) as a kind.
10:31:23 <mightybyte> ...or at least it might seem that way at first glance.
10:31:45 <mokus> Since type classes can't be quantified over, it doesn't really make much difference whether they have kinds or a list of argument-kinds
10:32:11 <byorgey> mightybyte: if x, y, and z are kinds, then so is  x -> y -> z
10:32:37 <byorgey> mokus: true
10:32:52 <sipa> but a type class taking kinds * and * -> *
10:33:02 <sipa> is not the same as a type class taking kinds *, * and *
10:33:19 <sipa> even though both would "map" to the kind * -> * -> *
10:33:56 <djahandarie> sipa, no, both would not.
10:34:07 <djahandarie> The first would map to * -> (* -> *) -> Fact
10:34:12 <sipa> yes, yes i know
10:34:15 <djahandarie> The second would map to * -> * -> * -> Fact
10:34:20 <sipa> i mean, if you would just use a -> b -> c
10:34:28 <Ke> sizeOF (undefined :: CFloat)
10:34:36 <Ke> > sizeOf (undefined :: CFloat)
10:34:36 <lambdabot>   Not in scope: `sizeOf'Not in scope: type constructor or class `CFloat'
10:35:49 <byorgey> sipa: I fail to see any scheme under which * and (* -> *) would map to  * -> * -> *
10:36:16 <byorgey> remember, * -> * -> * is syntax sugar for  (* -> *) -> *
10:36:33 <byorgey> er, sorry, flip everything I just said around
10:37:03 <byorgey> sigh
10:37:25 * monochrom helps. * -> * -> * is * -> (* -> *)
10:37:44 <shachaf> * <- (* <- *) is sugar for * <- * <- *?
10:37:49 <monochrom> haha
10:37:56 <byorgey> right =)
10:37:58 <monochrom> @slap shachaf
10:37:58 * lambdabot smashes a lamp on shachaf's head
10:38:10 <monochrom> wow, lamp. that's brutal
10:38:17 <sipa> byorgey: i was simply using the "naive" mapping of the "list of kinds" [a,b,c] to a -> b -> c
10:38:21 <djahandarie> lambdabot doesn't fuck around.
10:38:30 * shachaf vanishes in a puff of orange smoke.
10:38:38 <byorgey> right, but that mapping does not make sense (for exactly the reason you stated)
10:38:48 <sipa> my point exactly :)
10:38:58 <byorgey> you have to map  [a,b,c] to  a -> b -> c -> FOO   where FOO is some special "end marker"
10:39:17 <sipa> indeed
10:39:19 <djahandarie> I recommend everyone reads http://hackage.haskell.org/trac/ghc/wiki/KindFact if you didn't already when I linked it earlier
10:39:30 * sipa does so
10:39:32 <byorgey> sipa: sorry for the noise =)
10:40:13 <monochrom> in the old days when ethernet was on a bus topology with coaxial cables (bnc-10?), you needed special "end markers" on both ends of the bus
10:40:31 <monochrom> in lay terms, to kill echoes
10:41:00 <byorgey> djahandarie: oh, I hadn't seen that before.  That's a nice proposal.
10:41:02 <sipa> another analogy: the list type itself; it needs 2 contructors
10:41:16 <sipa> just mapping : to -> isn't enough
10:41:22 <sipa> you need to map [] to something as well
10:41:37 <shachaf> Is there a reason the syntax is (C a, D a) => instead of C a => D a => ?
10:41:43 * shachaf 's orange smoke isn't very effective.
10:41:43 <byorgey> sipa: yes, that's a good way to think of it.
10:41:56 <djahandarie> byorgey, yep, it's Conor's
10:42:10 <byorgey> shachaf: I believe those are equivalent.
10:42:15 <sipa> shachaf: then man goes on to prove that black is white, and gets killed on the next zebra crossing?
10:42:21 <byorgey> shachaf: the former is just syntax sugar for the latter.
10:42:28 <shachaf> Oh, really?
10:42:32 <byorgey> try it =)
10:42:36 <shachaf> I thought I tried it once and the latter didn't work.
10:43:06 <shachaf> Hmm. This wasn't introduced in GHC 7 or anything?
10:43:29 <byorgey> > let f :: Eq a => Show a => a -> a -> String; f x y = if x == y then show x else "boo"  in f 3 3
10:43:29 <lambdabot>   "3"
10:43:39 <byorgey> shachaf: no, I don't think so.
10:43:51 <monochrom> more in the old days: in usenet debates, some people wrote like "foos are bars. (fact!) bars don't use quux. (fact!) those who don't use quux are baz. (fact!) [30 more similar sentences]" it was pretty funny
10:43:56 <byorgey> the syntax of types is  type ::= constraint => type
10:43:57 <Eduard_Munteanu> shachaf: think of    C a => a -> (forall b. B b => b-> a) or stuff like that
10:44:20 <shachaf> Ah.
10:44:26 <bgamari> I'm so very confused
10:44:27 <bgamari> step :: Timestep -> RVarT (State Timestep) (Maybe Time, Maybe Time)
10:44:27 <bgamari> step = do ts <- MTL.lift get
10:44:30 <shachaf> Why is the tuple syntax allowed, then?
10:44:39 <bgamari> which produces,
10:44:39 <bgamari> fret_mc.hs:43:15:
10:44:39 <bgamari>     Kind incompatibility when matching types:
10:44:39 <bgamari>       m0 :: * -> *
10:44:39 <bgamari>       Timestep :: *
10:44:51 <byorgey> shachaf: probably just because it's shorter/more convenient
10:44:58 <byorgey> and easier to read
10:45:02 <bgamari> Yet this code is almost verbatim from http://hackage.haskell.org/packages/archive/random-fu/0.2/doc/html/Data-Random.html
10:45:11 <byorgey> makes it more obvious where the constraints stop and the rest of the type starts
10:45:30 <hpaste> “Ben Gamari” pasted “Monad transformers trouble” at http://hpaste.org/49623
10:46:27 <hpaste> “Ben Gamari” annotated “Monad transformers trouble” with “Monad transformers trouble (Error)” at http://hpaste.org/49623#a49624
10:46:40 <byorgey> bgamari: check your indentation.  the 'let' ought to be lined up right underneath 'ts'
10:46:41 <bgamari> Anyone have some guidance for the lost?
10:46:49 <bgamari> bah
10:47:29 <monochrom> universal guidance for the lost: the scientific method
10:48:07 <bgamari> byorgey: Hmm, seems the spacing got butchered somehow in the pasting process but unfortunately this isn't the issue I'm fairly certain
10:48:42 <monochrom> preliminary evidence that the scientific method is universal: http://www.wired.com/wiredscience/2011/07/kids-scientific-method/
10:48:47 <bgamari> byorgey: Ahh, that was my fault. I tried to condense the code to paste in the channel (which I guess was unnecessary; sorry for the noise everyone)
10:51:50 <byorgey> bgamari: wait, so are you saying you figured out what was causing your error? or just that the indentation is not the problem?
10:53:08 <TubeSteak_> hmm, i wonder why "(Map.size m) `deepseq` (Set.size s) `deepseq` return (m,s)` makes my program consume less memory than "m `deepseq` s `deepseq` return (m,s)"
10:53:24 <TubeSteak_> this in a function passed to foldM over some files
10:54:07 <monochrom> forcing size m is cheaper than forcing all of m. similarly s
10:54:13 <byorgey> TubeSteak_: using deepseq on the sizes will only force the spines of the map and set, whereas m `deepseq` s `deepseq` ...  will also force the contents
10:54:21 <monochrom> no, sorry, I don't know why
10:54:55 <byorgey> but why that might make it take less memory depends on how the resulting map and set are being used later, I suppose
10:55:48 <TubeSteak_> byorgey: i figured that out, but that would suggest that forcing only the spine will take more memory when you're doing a lot of Set.union and Map.union
10:56:49 <monochrom> I see why. what byorgey says but I would s/spine/tree skeleton/ . size m does not care about data stored in the map
10:57:46 <byorgey> monochrom: what's the difference between spine and tree skeleton?
10:58:10 <TubeSteak_> so I guess that in case of Map.union only the keys will be strictly computed and then the values will still be lazy
10:58:19 <TubeSteak_> I guess for Sets it doesn't make a difference
10:58:19 <monochrom> whereas "(NFData k, NFData a) => NFData (Map k a)" likely causes forcing m to force all data stored
10:58:34 <monochrom> sometimes "spine" refers to just one path of the whole tree
10:58:38 <byorgey> TubeSteak_: yes, that makes sense
10:59:34 <monochrom> there is a pathological possibility of <= >= == still cheaper than deepseqing keys
10:59:37 <mokus> bgamari: "step = do ..." is not consistent with "step :: Timestep -> RVarT ..." unless you really meant to use the "TimeStep ->" monad
10:59:55 <TubeSteak_> but in the end the data in the map and set will be printed out (after the foldM is done) so they will be evaluated eventually
11:00:50 <TubeSteak_> so I wonder why fully evaluating them in the intermediate steps will take more memory overall
11:01:38 <monochrom> something else is disowning memory while you print
11:02:58 <TubeSteak_> right, it might be that some of the data used by the function that produce the map and set is not garbage collected
11:03:09 <monochrom> suppose you have "print m >> print s" and that's it, no further use of m after. then m is disowned while you print s
11:03:14 <parcs> @hoogle IORef
11:03:14 <lambdabot> module Data.IORef
11:03:14 <lambdabot> Data.IORef data IORef a
11:03:14 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
11:06:56 <TubeSteak_> so, then I guess they are equivalent in making sure that the memory usage doesn't increase with the size of the list passed to foldM
11:12:38 <kamaji> Does anyone know of a tutorial for LambdaCubeEngine?
11:17:19 <TubeSteak_> but I guess i should prefer the fully strict evaluation since the map values are ByteString and if they are not evaluated then the list form of the string is kept in memory which is less efficient
11:20:59 <erus`> write an AI for this without bruting it :D http://en.wikipedia.org/wiki/Racetrack_%28game%29
11:28:43 <byorgey> preflex: seen edwardk
11:30:12 <djahandarie> preflex_, seen edwardk
11:30:12 <preflex_>  edwardk was last seen on #haskell 18 hours, 50 minutes and 24 seconds ago, saying: keegan had a more traditional one somewhere as well
11:30:29 <djahandarie> (Though he's in the channel right now... he's probably around :p)
11:30:41 <monochrom> oooh, discrete-time tron!
11:35:53 * chrisdone wades through dependency hell
11:37:28 <chrisdone> we are the knights who say ‘cannot configure’ and we demand a sacrifice
11:38:07 <edwardk> here
11:38:31 <byorgey> hey edwardk, was just wondering in which package Yoneda is defined, but I found it (kan-extensions)
11:38:35 * hackagebot ad 1.1.1 - Automatic Differentiation  http://hackage.haskell.org/package/ad-1.1.1 (EdwardKmett)
11:38:50 <byorgey> edwardk: when are you arriving in Philly?
11:39:17 <edwardk> brb
11:39:57 <edwardk> tomorrow around noon or 1pm
11:40:18 <edwardk> and yeah i move a bunch of stuff into kan-extensions
11:40:23 <luite> chrisdone: oh I saw your message about the web ui from yesterday, but I was already asleep
11:40:43 <edwardk> the ad patch there doesn't fix the stack problem in Data.Graph but it does fix the sbounds leak
11:40:57 <acowley> edwardk: yeah I was just checking the diffs
11:41:00 <edwardk> i still need to fix the other problem acowley had
11:42:58 <djahandarie> edwardk, oh, around noon now? :p
11:43:17 <edwardk> djahandarie: yeah i ditched the train for a flight. cheaper and faster
11:43:40 <chrisdone> luite: okies. i need to add controllers and presenters before it gets interesting i guess
11:43:46 <edwardk> copumpkin's suggestion. the boy knows how to travel cheap
11:43:53 <copumpkin> :O
11:44:04 <djahandarie> Right, I remember that. Hmm, I doubt I can get the key for the room if its under your name. Though I think I might just be taking a backpack, might not even need to drop anything off
11:44:17 <chrisdone> who's coming to camhac?
11:44:31 <edwardk> we'll figure it out. you have my # right?
11:44:47 <djahandarie> Yeah
11:44:48 <mercury^> He has your hash? :o
11:44:50 <mercury^> :P
11:45:08 <djahandarie> Yes, I have his hash. Been smoking it all day.
11:45:17 <djahandarie> Now I'm a category theory master.
11:47:50 <acowley> More importantly, you can DOS him by repeated hash collisions leading to O(n) lookup of edwardk everytime he looks in a mirror.
11:48:45 <mauke> if he works like perl that's harder than it seems
11:48:54 <chrisdone> copumpkin: so maybe i'll work on the irc thing on saturday… i like programming. dependency hell is not programming. :p
11:49:00 * chrisdone goes back to his ji thing
11:49:03 <mauke> perl uses a randomized hashing algorithm so it's harder to target
11:49:14 <edwardk> i only gave him one #, since i use a 2 hash table rather than separate chaining I should be okay.
11:49:56 <acowley> paranoia pays off
11:50:04 <edwardk> and if i do what mauke suggests, all i have to do is kill myself and start over and i'll get a new #.
11:50:29 <edwardk> i'm sure that'll work fine
11:53:51 <DukeDave> Does the term 'splitBase' mean anything special in cabal parlance? I've found it in a .cabal file
11:55:40 <dolio> A while ago, base was a lot bigger than it is now.
11:55:46 <dolio> Then it got split into a lot of packages.
11:56:08 <edwardk> basically if you don't want to support ancient versions of ghc you're fine to ignore it
11:56:50 <DukeDave> Aha, so splitBase is True for a newer GHC
11:58:33 <dolio> It's been split since... 6.8 maybe?
11:58:52 <edwardk> thats about right
11:59:00 <edwardk> because it was splitting right when i came into the community
11:59:56 <dolio> Versions 3 and higher are split, I think.
12:00:02 <dolio> Of base.
12:00:11 <dcoutts> DukeDave: the names of flags is not significant to cabal itself
12:00:16 <djahandarie> Heh, 2008, that's awhile back. :(
12:01:56 <DukeDave> dcoutts: Right
12:02:46 <DukeDave> I have this less than fun situation: http://sourceforge.net/mailarchive/message.php?msg_id=27867560
12:03:27 <DukeDave> But the build-depends are deliciously complicated :|
12:07:19 <dcoutts> DukeDave: you've got a package that indirectly depends on multiple versions of a package, that gives cabal-install nightmares
12:07:26 <dcoutts> (it's solver cannot handle that)
12:09:42 * hackagebot roundtrip-xml 0.3.0.2 - Bidirectional (de-)serialization for XML.  http://hackage.haskell.org/package/roundtrip-xml-0.3.0.2 (StefanWehr)
12:11:28 <DukeDave> Hmm, if only someone would fix it...
12:11:33 <DukeDave> Open-source to the rescue!
12:14:09 <DukeDave> dcoutts: I don't understand :'(
12:15:00 <DukeDave> These are the .cabal files:
12:15:05 <DukeDave> http://code.haskell.org/wxhaskell/wxcore/wxcore.cabal
12:15:12 <DukeDave> http://code.haskell.org/wxhaskell/wxdirect/wxdirect.cabal
12:16:07 <DukeDave> As far as I can tell: core requires       containers >= 0.2 && < 0.5, and direct requires        containers >= 0.2   && < 0.5
12:16:15 <DukeDave> So I don't see where the problem is :|
12:16:46 <ByronJohnson> DukeDave: An example of a package that indirectly depends on multiple versions of a package is this: A depends on B and C, and B depends on D-1.0 and C depends on D-2.0.
12:17:03 <ByronJohnson> DukeDave: "(it's solver cannot handle that)" makes sense without the apostrophe
12:18:19 <DukeDave> ByronJohnson: Cool, well that makes sense, but I'm not sure why those two .cabal files give rise to the inconsistency cabal is describing
12:18:47 <mauke> DukeDave: it's not the cabal files
12:18:54 <ByronJohnson> DukeDave: It's not necessarily the problemb of the cabal cfiles
12:18:55 <mauke> it's your installed modules
12:19:02 <DukeDave> Unless one of the things one of those .cabals depends on is forcing the version containers to one, and one to the other
12:19:05 <DukeDave> Aha
12:19:18 <DukeDave> mauke: Let me check ghc-pkg
12:19:36 <ByronJohnson> DukeDave: Perhaps B was registered while you had D-1.0, and C was installed while you had D-2.0.
12:19:46 <DukeDave> Well that's no surprise, I have both versions of containers!
12:19:57 <DukeDave> That makes sense!
12:20:22 <mauke> consider this: you install A-1.0; then B-1.0 (which depends on A and is built against A-1.0); then you upgrade to A-1.5; then you install C-1.0 (which depends on A and is built against A-1.5)
12:20:39 <mauke> then you want to install D (which depends on B and C)
12:20:50 <mauke> and now D indirectly depends on A-1.0 and A-1.5
12:20:55 <DukeDave> mauke: Thanks, that makes everything a lot clearer
12:20:58 <monochrom> which is http://www.vex.net/~trebla/haskell/sicp.xhtml#pigeon
12:21:08 <DukeDave> And maps directly on to my problem
12:21:53 <DukeDave> Trying to unregister each version of the package, one complains about core, and the other about direct; as I would now expect.
12:22:13 <monochrom> nuke all user packages
12:22:18 <DukeDave> Hmm, so is there a way to ditch the old containers, and force a re-build of everything else
12:22:35 <monochrom> don't ditch the old one. ditch the new one
12:22:57 <monochrom> unless you want to re-build ghc
12:22:58 <DukeDave> ghc-pkg: unregistering containers-0.4.0.0 would break the following packages: wxdirect-0.13.1 wxcore-0.13.1 graph-wrapper-0.2.3 template-haskell-2.4.0.0 Cabal-1.10.2.0 fgl-5.4.2.3 (use --force to override)
12:23:17 <DukeDave> and
12:23:17 <monochrom> see my article
12:23:48 <DukeDave> monochrom: Thanks, reading..
12:24:15 <monochrom> I suggest taking some patience and reading the whole article
12:27:32 * DukeDave wants a t-shirt with "promiscuous upgrade whore" written on it
12:28:33 <edwardk> :w
12:28:37 <edwardk> woops =)
12:29:06 <monochrom> !the file is read-only. use :w! to force writing
12:31:39 <edwardk> :w monochrom
12:34:48 <monochrom> E168-32: the monochrom that can be written is not the true monochrom
12:35:14 <edwardk> :w! monochrom
12:36:26 * DukeDave likes this page: http://en.wikipedia.org/wiki/Hylomorphism_(computer_science)
12:36:29 <burbul> I'm having some trouble exporting data constructors...  I can see the type name but not the constructors. do I need to do anything other than put (..) after the type name in the list of exports?
12:37:08 <monochrom> put (..). example: module Data.Maybe(Maybe(..))
12:37:10 <c_wraith> that should suffice
12:37:25 <c_wraith> But you also need to have the (..) in the import, if you're importing things explicitly
12:37:52 <burbul> Thanks
12:43:48 <ari> Hi. Is there a way to find out how many parameters a constructor has in syb-with-class? (or, well, all I really need is to find out if it's nullary)
12:45:29 <c_wraith> ari: how big of a hack are you willing to accept?
12:45:58 <c_wraith> > "->" `isInfixOf` show (typeOf Just)
12:45:59 <lambdabot>   Ambiguous type variable `a' in the constraint:
12:45:59 <lambdabot>    `Data.Typeable.Typeable a...
12:46:19 <c_wraith> > "->" `isInfixOf` show (typeOf (Just :: Int -> Maybe Int))
12:46:19 <lambdabot>   True
12:46:25 <c_wraith> > "->" `isInfixOf` show (typeOf (Nothing :: Int -> Maybe Int))
12:46:26 <lambdabot>   Couldn't match expected type `GHC.Types.Int
12:46:26 <lambdabot>                                ...
12:46:32 <c_wraith> > "->" `isInfixOf` show (typeOf (Nothing :: Maybe Int))
12:46:33 <lambdabot>   False
12:46:55 <ari> c_wraith: That... *is* pretty hacky
12:47:05 <ari> c_wraith: But good enough for me for now
12:47:06 <monochrom> hehe
12:47:09 <ari> c_wraith: Thank you :)
12:50:36 <DukeDave> monochrom: Well now I am sad :|
12:51:12 <ricree> is there any good way to debug FFI segfaults?
12:51:33 * DukeDave wonders how to get out of this dependency corner
12:52:00 <ezyang> ricree: gdb it, see if you're in C land when the segfault occurs.
12:52:12 <ezyang> Otherwise, printf debugging tends to work rather well.
12:52:33 <ezyang> since pointer dereferences and writes are quite obvious in Haskell code. But they're more obnoxious.
12:53:38 <DukeDave> Yey, I've unregistered the new containers (and everything which depended on it)
12:56:46 <ari> Ah, I came up with a less... clever answer
12:56:52 <ari> > length . gmapQ (const ()) $ Just 5
12:56:54 <lambdabot>   1
13:05:47 <ricree> Thanks, ezyang.  Didn't realize I could still load it into gdb with the C debug symbols.  Kinda new to this still.  I found where it's segfaulting at.  just need to track down the cause now.
13:06:55 <ezyang> ricree: GHC compiled Haskell code is kind of special, but C land is all normal.
13:13:36 <guh> are there commercial haskell programming jobs?
13:13:46 <copumpkin> yes, but they're hard to get
13:14:14 <PatrickRobotham> guh: If you learn Erlang, you can probably get a job in the telecommunications industry.
13:14:45 <Twey> Not an answer though :þ  Erlang isn't really a substitute for Haskell.
13:16:20 <guh> alright
13:16:45 <guh> is python perhaps the imperative language that most resembles haskell?
13:16:57 <guh> i know its like comparing apples and oranges
13:16:58 <guh> but still
13:17:05 <ricree> found the error, thanks again ezyang
13:17:22 <Botje> guh: that would be scala
13:17:59 <guh> oh
13:18:00 <guh> never used it
13:18:23 <monochrom> semantically they are antipodal. syntactically they are alike. all ascii files look the same anyway
13:18:37 <byorgey> the imperative language that most resembles Haskell is do-blocks in Haskell ;)
13:20:03 <monochrom> statistically, people want to hear "x is like y"
13:20:30 <Botje> haskell is almost, but not quite, entirely unlike palm trees.
13:20:55 <guh> the program flow cant be the same because the paradigm is quite different but you know lists and tuples are pretty similar
13:21:07 <guh> i was wondering if there was a language other than python that resembled haskell in this way
13:21:46 <byorgey> Haskell lists and tuples aren't really very similar to Python lists and tuples.
13:22:31 <Botje> guh: syntax is the least of your worries :)
13:22:58 <djh_> is there a function in Haskell that allows you to 'round' numbers by a given significant digit. i.e. djhRound 3.456 2 = 3.46
13:23:31 <djh_> i know there's a 'round' function but it just rounds the entire number to the nearest whole number
13:23:42 <olsner> multiply by 10^n, round, divide by 10^n :)
13:24:06 <copumpkin> olsner: that doesn't really give you significant digits
13:24:51 <olsner> copumpkin: hmm, maybe not
13:26:01 <geheimdienst> copumpkin: what's the problem with olsner's approach?
13:26:44 <olsner> I think "significant digits" means that rounding 0.000003456 to a small number of significant digits shouldn't produce 0
13:26:45 <byorgey> "round to two significant digits" means   3.456 -> 3.4,  34.56 -> 34, 345.6 -> 340
13:26:55 <copumpkin> 0.00000252 has three significant digits. 0.000002520 has four significant digits
13:27:15 <copumpkin> say you want to round the four significant digits to three, multiply by 1000, round, divide by 1000
13:27:17 <copumpkin> you get 0
13:27:24 <copumpkin> by that approach
13:27:33 <byorgey> "round to n decimal places" is what multiplying and dividing by 10^n gives you, which is different
13:27:40 <monochrom> > take 5 (repeat ())
13:27:41 <lambdabot>   [(),(),(),(),()]
13:27:57 <djh_> yeah I got my terminology wrong, my bad :(
13:28:00 <geheimdienst> yes yes, but djh_ specifically wanted a function "djhRound 3.456 2 = 3.46". that must mean he wants 2 digits after the decimal point, so not the big solution
13:28:12 <djh_> olsner's solution seems to do the trick
13:28:18 <copumpkin> fair enough
13:28:43 <djh_> (\x -> (fromInteger x)/10^2) $ round $ (3.456 * 10^2)
13:29:23 <byorgey> > (/10^2) . fromInteger . round . (*10^2) $ 3.456
13:29:24 <lambdabot>   3.46
13:30:54 <monochrom> if you want to a specific number of significant digits, you're better off using showEFloat to do the rounding for you, then reading it back
13:31:27 <parcs> > (fromRational . toRpa
13:31:28 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:31:47 <parcs> > (fromRational . toRational) pi :: Fixed E2
13:31:48 <lambdabot>   3.14
13:32:36 <djh_> interesting thanks.
13:32:38 <parcs> @pl fromRational . toRational
13:32:38 <lambdabot> fromRational . toRational
13:32:48 <parcs> is there a name for this?
13:32:49 <monochrom> or else you assume separate out the exponent and the significand, and use multiple-round-divide on the significand, then re-combine
13:33:07 <monochrom> @type fromRational . toRational
13:33:08 <lambdabot> forall a a1. (Fractional a, Real a1) => a1 -> a
13:33:14 <monochrom> @type realToFrac
13:33:15 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
13:33:18 <luite> @src realToFrac
13:33:18 <lambdabot> realToFrac = fromRational . toRational
13:33:25 <monochrom> yeah, that
13:34:20 <monochrom> realToFrac may be more optimized than fromRational . toRational by way of type-casing in rewrite rules in ghc's implementation
13:36:24 <monochrom> actually decodeFloat and encodeFloat may be easier to use for significant digits rounding
13:37:26 <monochrom> err nevermind, that's only easier when you're doing significant digits in base floatRadix (2 in practice)
13:37:54 <djh_> it would have been nice if Prelude included this function as it's kinda handy for me
13:39:59 <monochrom> showEFloat and then reading back is still the easiest and least error-prone way :)
13:40:05 <kamaji> What would be the nicest way to have two ways of Show-ing a data type?
13:40:31 <monochrom> (if decimal)
13:41:05 <monochrom> the nicest is to write two Your'type->String functions and screw the Show class
13:41:42 <monochrom> the 2nd nicest way is to have two newtypes and therefore two Show instances
13:42:02 <kamaji> I was thinking the 2nd way, would you just contain the first type?
13:42:10 <monochrom> the 3rd nicest way is to just have one newtype. it is uglier than the above because of favouritism
13:42:50 <kamaji> wait, is "newtype" a thing?
13:42:57 <monochrom> yes
13:42:59 <kamaji> ohhh
13:43:04 <kamaji> ok, i'm going to look that up, hehe
13:43:12 <kamaji> cheers!
13:48:58 <monochrom> http://www.vex.net/~trebla/haskell/testbed.cgi has an example
13:51:56 <mmjack> Hi, What would the equivilent of a struct in C be in Haskell?
13:52:06 <ddarius> A data type.
13:52:45 <tensorpudding> a record
13:53:16 <tensorpudding> it has named fields which are directly analogous to C structs
13:53:46 <tensorpudding> except the fields are accessor functions
13:54:08 <ash__> data Foo = Foo { a :: Int, b :: Int } is a lot like: struct Foo { int a; int b};
13:54:55 <ash__> it generate accessors like:  a :: Foo -> Int
13:55:03 <ash__> or you can pattern match on it
13:56:48 <k0ral> thoughtpolice: that's a strange way of thinking; I'm very grateful to people that publish code without wondering if it can be useful to many users; you never know how many users can be interested in, and hosting one's own pastebin-like service is something I find useful and I don't think I'm alone
13:58:03 <kamaji> monochrom: oh that's perfect, thank you!
14:01:03 <atoll> Hello, i was wondering, you cannot use array in haskell for algorithm, is it not an enormous flawless ?
14:01:13 <thoughtpolice> k0ral: well, sure. i write code i don't expect anyone to use. that's without question and wasn't my point. my point is that i don't see the clear advantage to installing from hackage or putting hpaste on hackage as opposed to say, just cloning the source. i'm not saying it's a -bad- idea or somehow we would be worse off, i just don't see the main benefits hackage brings applying in this case.
14:01:16 <silver> you can
14:01:53 <silver> atoll, you can use arrays
14:01:57 <silver> if you want too
14:01:58 <atoll> silver, you can but it is too complex compare to other imperativ languages
14:02:09 <ash__> huh?
14:02:23 <atoll> By complexity i mean O(etc)
14:02:51 <silver> oh no, I don't think arrays in haskell have different complexity on different operations
14:02:52 <byorgey> atoll: no, Haskell has real honest-to-goodness O(1) access arrays
14:02:55 <atoll> update an array in haskell is O(n) when it is 0(1) in C.
14:03:07 <byorgey> updating a *list* in HAskell is O(n).
14:03:11 <k0ral> thoughtpolice: dependencies management ?
14:03:15 <thoughtpolice> k0ral: but that's not to stop anyone from uploading a package. be my guest! chris may even support it. i just don't see the advantages hackage offers applying as cleanly to hpaste.org source code as it may to a general library written in haskell, or even a more general library
14:03:27 <silver> atoll, most likely you mean lists, which is [1,2,3,4] stuff
14:03:33 <atoll> no ?
14:03:40 <byorgey> atoll: see http://hackage.haskell.org/package/array
14:04:10 <byorgey> it is a bit more complicated in Haskell than in imperative languages, due to the need to track effects.  but it's not that bad once you get used to it.
14:04:16 <thoughtpolice> k0ral: well, if i clone the hpaste.org source code, cd into it and do 'cabal install' cabal will still figure out the dependencies for me
14:04:29 <silver> atoll, and http://www.haskell.org/ghc/docs/7.0.1/html/libraries/base/Data-List.html
14:04:40 <k0ral> yes but there are 2 missing ones and it needs 2 more cloning
14:04:45 <dmwit> Modifying immutable arrays is O(n), but we also have mutable arrays for O(1) modification.
14:04:46 <atoll> silver, i'm not stupid, i know what is a lit thx u
14:04:53 <atoll> list*
14:04:55 <k0ral> cabal install hpaste would have done it in 1 shot
14:05:07 <thoughtpolice> and download/install all of them. this is why hackage is great for libraries - so cabal can figure out your deps and install them automatically. the benefits are less clear (to me at least) when applied to just hpaste.org, which is already fairly specific in its purpose
14:05:24 <geheimdienst> atoll: haskell is a functional language. in functional languages, arrays are not needed very often. we use lists for nearly everything
14:05:40 <mauke> geheimdienst: I don't
14:05:45 <silver> lol
14:05:59 <atoll> geheimdienst, list are very usefull for some sort of thing, not everything
14:06:08 <dmwit> We even have mutable arrays + a mutability monad that lets you get out an immutable array at the very end with a pure type (after all mutation is don).
14:06:09 <atoll> Using them when not adapted is not smart na ?
14:06:11 <dmwit> Very nice!
14:06:14 <mauke> I use Maps, Sets, and ByteStrings all the time
14:07:04 <thoughtpolice> k0ral: but that's just me. chris may very well feel differently and perhaps the hpaste.org source code should be uploaded. maybe i'm wrong. i just off hand don't see what advantages the hackage/cabal model bring in this case, that's just me
14:07:54 <k0ral> thoughtpolice: no problem, just talking :)
14:08:12 <ash__> i use matrices a lot, but i guess thats just dependent on the kind of programming your doing
14:10:54 <eyu100> I have this function d :: (Num a, Num b) => (D a -> D b) -> a -> b
14:11:08 <mauke> :t deriv
14:11:09 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
14:11:11 <eyu100> d f x = f'(x)
14:11:59 <eyu100> and I'm trying to make a function that evaluates the nth derivative of f at x
14:12:16 <eyu100> the problem is, the type of that function depends on n
14:12:56 <eyu100> so is it possible to make such a function in haskell?
14:13:27 <mauke> Num b => Int -> (forall a. Num a => a -> a) -> b -> b
14:14:50 <eyu100> so you can't give an a and get a b?
14:15:58 <astor> Whenever I try building ghc from source I get some compiler error.  Now for example I am getting """Not in scope: `synopsis'""" when compiling  libraries/bin-package-db/Distribution/InstalledPackageInfo/Binary.hs:62:8:  What's wrong?  Is some part of haskell platform poisoning the build?
14:17:00 <siracusa> > deriv (\x -> x*x) 12
14:17:00 <lambdabot>   24
14:17:17 <siracusa> > deriv (deriv (\x -> x*x)) 12
14:17:18 <lambdabot>   2
14:17:39 <ddarius> > derive (\x -> x*x) x
14:17:40 <lambdabot>   Not in scope: `derive'
14:17:43 <ddarius> > deriv (\x -> x*x) x
14:17:44 <lambdabot>   1 * x + x * 1
14:17:50 <siracusa> This function is black magic! O.o
14:21:08 <Eduard_Munteanu> Why would it depend on n?
14:21:42 <thoughtpolice> astor: #ghc is more appropriate for those questions
14:21:51 <Eduard_Munteanu> (not considering functions which aren't differentiable everywhere, it's not like we have reals anyway)
14:22:17 <thoughtpolice> astor: it also likely has nothing to do with the platform either, but i can only speculate having seen that one line
14:23:23 <conal> eyu100: you can compute an infinite tower of derivatives, where the tower levels have differing types.
14:23:46 <conal> eyu100: see, e.g., http://conal.net/papers/beautiful-differentiation/
14:26:22 <edwardk> conal: have you see the ad package?
14:26:32 <conal> edwardk: no
14:26:53 <_Ray_> Hi. What does a cabal package's Setup.sh configure usually do? There's a package (readline) that I need to manually ./configure for, but when I then runghc Setup build, it tells me "Setup: Run the 'configure' command first.". Clearly if I do that I'll fuck stuff up again :p
14:26:56 <edwardk> conal: i do reverse mode and sparse-on-reverse, etc. modes in there so you can calculate nth derivatives of k-ary functions efficiently
14:27:26 <edwardk> the beautiful differentiation approach is nice, but the asymptotics are much worse for typical workloads
14:28:01 <acowley> anyone know a compact way of creating tridiagonal matrices in hmatrix?
14:28:15 <dcoutts> _Ray_: for packages that use autoconf style ./configure scripts, then runghc Setup.sh configure will run that ./configure script (amongst other things)
14:28:15 <hatds> _Ray_:   the basic invocation order is:    runghc Setup.hs configure, runghc Setup.hs build, runghc Setup.hs install
14:28:24 <edwardk> conal: http://hackage.haskell.org/package/ad-1.1.1
14:28:55 <conal> edwardk: thx. looking.
14:29:18 <_Ray_> hatds, I know, but I can't Setup.hs configure, it won't work in my OS (specifically it'll try to find the wrong readline library in Snow Leopard). Apparently the fix is to manually ./configure, but then I can't build because it wants me to have done Setup.sh configure first.
14:29:29 <conal> edwardk: have you tried deriving a reverse ad implementation from a high-level spec?
14:29:46 <edwardk> that is more your bag than mine =P
14:30:03 <conal> edwardk: ah.
14:30:12 <hatds> _Ray_: ah my misunderstanding.  I don't know the proper solution.
14:30:14 <edwardk> the problem is if you just try and specify what it should do you probably won't get the asymptotics right
14:30:18 <conal> edwardk: i'll get to it someday. been on my to-do list for a long time.
14:30:33 <edwardk> because you really need to capture the need for sharing somehow
14:30:51 <copumpkin> omnom
14:30:54 <edwardk> for a long time i had thought reverse mode ad in haskell with a nice API was impossible. turned out i just needed to observe sharing
14:30:57 <conal> edwardk: i suspect it'll be a fun & nontrivial challenge.
14:32:17 <edwardk> i can get better asymptotics with worse constants and worse interaction with parallelism, i just need to tweak the way my modes work to be more like the ones i use in scala
14:32:27 <edwardk> not sure if its worth it
14:33:01 <edwardk> conal: the other thing is you don't just want reverse and forward mode, you want modes to represent forward-on-reverse for things like hessian calculations
14:33:32 <edwardk> or which calculate multiple derivatives simultaneously like the trie-based sparse mode i have, otherwise you wind up wasting time calculating a huge number of redundant derivatives
14:34:17 <conal> edwardk: mixed mode is what i really have in mind.
14:34:36 <conal> but not today.
14:34:56 <edwardk> for instance, there are only (n + k - 1) choose k distinct nth partial derivatives of a k-ary function, so sparse and sparse-on-reverse calculate just that
14:35:05 <edwardk> rather than k^n
14:35:49 <edwardk> it took some actual examples i needed down from billions of derivatives to thousands
14:35:58 <conal> nice
14:36:30 <edwardk> if i can ever get mpfr working right with haskell that'll let my taylor model code work
14:36:39 * edwardk nudges copumpkin.
14:36:46 <copumpkin> :P
14:36:47 <copumpkin> yep
14:36:49 <copumpkin> hax
14:36:59 <copumpkin> epic l33thax
14:37:14 <copumpkin> (the only kind I am capable of course, mind you)
14:40:04 <hatds> _Ray_: after a little fooling around it seems the answer your original question is that a file "setup-config" is created in a folder "dist".  The contents looks roughly like (show a) for whatever internal datatype Cabal uses.  Maybe this helps http://www.haskell.org/ghc/docs/7.0.4/html/libraries/Cabal-1.10.2.0/Distribution-Simple-Configure.html
14:40:17 <_Ray_> Thanks!
14:42:13 <chrisdone> anyone tried opa?
14:42:27 <chrisdone> claims partly haskell inspired
14:44:19 <edwardk> conal: as a step towards that high level spec stuff, all of the ad modes use the same code to derive all their jacobians. so you just wire up a few methods, and all the sin, cos, etc. stuff works
14:44:58 <ash__> can you extend data types later? So, so I have a data Signal = … then later say data DigitalSignal = Signal…? hmmm maybe I am going about this the wrong way
14:45:36 <dmwit> Data types are closed, but classes are open.
14:45:47 <edwardk> ash: you'd make data DigitalSignal = Base Signal | One | Zero | …  or something like that
14:45:49 <benmachine> ash__: you can't extend datatypes, but you could have a type which contained your other type and some other stuff
14:45:51 <dmwit> So you can't later add constructors to Signal without opening up the source of Signal.
14:45:55 <edwardk> which means to pattern match you'd have to match the 'Base' wrapper
14:46:06 <dmwit> But you could later add new types to some class that Signal implements.
14:46:36 <dmwit> s/new types/new instances/
14:46:51 <ash__> I'll try to work it out as a type class, that sounds like it should be the right way of doing it
14:46:59 <edwardk> you can make a class full of smart constructors for Signal, and then make a subclass full of smart constructors for DigitalSignals, etc. but that is a very different thing, and then you need to invert that relationship to pattern match
14:47:14 <ricree> does hsc2hs have a problem with structs that haven't been typedeffed?  I've had no problems with ones that have been typedeffed, but I'm getting an "invalid use of undefined type" error when I try to use it with a plain struct
14:47:57 <dmwit> Did you remember the "struct" keyword?
14:48:02 <dmwit> <- not an hsc2hs expert
14:48:21 <hatds> ash__:  I don't think a type class is really the ideal solution.  You won't have a function "isDataSignal :: <something> -> Bool" that way
14:48:45 <dmwit> How do you people know what he wants?
14:48:50 <dmwit> His question was soooo open-ended.
14:48:59 <hatds> Yea, I really don't know
14:49:31 <ricree> dmwit:  yes I did
14:49:47 <ash__> I have a simulation program I wrote in C and I have designed a basic interface in python, I was going to write one for haskell kinda as a double check to see if it makes sense and also "just cause"
14:50:32 <ash__> I have different types of signals I want to send (e.g., analog, digital, composite that are made of multiple other signals)
14:51:02 <ash__> in my python one I have a base signal class that does some of the generic heavy lifting, so I was just trying to figure out a way of doing that in haskell
14:52:36 <ash__> i might be approaching this from to much of an OO perspective though
14:52:44 <Wild_Cat> ash__: make your signals composite types, maybe.
14:53:05 <Wild_Cat> as in, you'd have a Signal type, with extra information that can come from the source of the signal.
14:53:20 <hatds> my preference is to avoid thinking about typeclasses vs types or new constructors vs new data types when doing any design.  Think about the basic functions you want to write
14:53:31 <Wild_Cat> so your actual types would be (BaseSignal, DigitalExtras), (BaseSignal, AnalogExtras), etc.
14:54:55 <ash__> The things I get from the signals are a list of time stamps a value changes at, so if its a DigitalSignal when it goes high and low, then a value for each change, so for an AnalogSignal when it changed what did it change to between 0-1023
14:57:11 <Wild_Cat> ash__: so for a digital signal you have [(Timestamp, DigitalValue)] and for an analog signal it's [(Timestamp, AnalogValue)]?
14:58:06 <ash__> well, for those to, ya, but an rs-232 port has [(TimeStamp, String)] although thats all I have now are those 3 types of signals, I'd like to add more later though
14:58:52 <Wild_Cat> ash__: well, your functions that only act on timestamps will work out of the box.
14:59:21 <Wild_Cat> and if you want them to work on signal types, you can have their signature be (Timestamp, a) -> whatever result you want
15:01:56 <ash__> ya, your right, i really don't need a more complicated data structure at this point
15:12:29 <Phyx-> I have a custom preprocessor in my Setup.lhs file, when I use runghc Setup build it works, when i try it with cabal it fails. http://pastebin.com/4RKRCGi7
15:12:31 <mauke> The paste 4RKRCGi7 has been copied to http://hpaste.org/49626
15:12:35 <Phyx-> anyone have any ideas?
15:15:31 <geheimdienst> Phyx-: is your *cabal file saying build type custom or build type simple? if simple, cabal ignores the Setup.lhs file iirc
15:15:50 <geheimdienst> (this would explain why it works with runghc for you)
15:16:34 <Fuco> :t seq
15:16:35 <lambdabot> forall a t. a -> t -> t
15:18:37 <ash__> is there a way to do: type Signal = (Double, a)?
15:19:04 <Phyx-> geheimdienst: ah, thanks!
15:19:51 <Phyx-> geheimdienst: works fine now :)
15:20:23 <gienah> Phyx: I wonder if you need hookedPrograms as well
15:20:37 <geheimdienst> Phyx-: you're welcome. for the record, i find that behavior damn confusing :-) it should really print a big fat warning that it sees a Setup.lhs file but will ignore it
15:20:47 <Phyx-> gienah: don't think so, seems to run fine now, and compile :)
15:21:26 <Phyx-> geheimdienst: yeah, been scratching my head for a while now
15:21:55 <Phyx-> also found several errors in the cabal haddock, wondering where should i report them, on the Trac or the cabal-devel list
15:23:42 <thoughtpolice> ash__: where 'a' is just 'some thing'? i mean, you can, but you need extensions and it probably depends exactly on what you want anyway
15:29:42 <ash__> thoughtpolice: i just made another type with all my expected values for now, i think it will be alright
15:40:58 <dibblego> There is a package on hackage which does not compile (assuming the author messed up the cabal file), does not have a link to the source repo, and has no email address for the author. Does anyone know Marius Eriksen?
15:43:13 <dcoutts> dibblego: if you don't find anything, you can ask Ross Patterson, either for his email address or to forward a message
15:43:36 <Phyx-> is it possible to tell ghc to ignore a directory? I'm having a weird problem, i'm running cabal test, and it keeps picking the files on disk for some tests and for others the ones in the lib (or atleast I think it is) and giving me an error
15:44:03 <dcoutts> Phyx-: -i on its own resets the search path to empty
15:44:03 <dibblego> dcolish: ok cheers
15:44:14 <dibblego> dcoutts: sorry dcolish
15:44:55 <Phyx-> dcoutts: would it still find the packages then?
15:45:18 <Phyx-> dcoutts: also, where should I send haddock corrections for cabal? cabal-devel or trac?
15:45:29 <dcoutts> Phyx-: whichever you prefer
15:45:52 <dcoutts> Phyx-: the flags to control the packages are separate
15:46:10 <Phyx-> dcoutts: ah ok, thanks, i'll try that
15:46:26 <dcoutts> Phyx-: ooi, what's the haddock problem?
15:47:22 <Phyx-> dcoutts: http://hackage.haskell.org/packages/archive/Cabal/latest/doc/html/Distribution-Simple-PreProcess.html#t:PreProcessor ppTestHandler won't compile, runPreProcessor expects an IO () result while the example returns an IO ExitCode
15:50:07 <Phyx-> dcoutts: it would also be nice to note there that custom preprocessors only get run when your build mode is set to Custom, would have saved me quite some time
15:53:41 <djahandarie> preflex_, seen edwardk
15:53:41 <preflex_>  edwardk was last seen on #haskell 1 hour, 6 minutes and 44 seconds ago, saying: you can make a class full of smart constructors for Signal, and then make a subclass full of smart constructors for DigitalSignals, etc. but that is a very different thing, and then you need to invert that relationship to pattern match
15:57:20 <dcoutts> Phyx-: it's more than that, the whole Setup.hs is only looked at if you use build-type custom
16:02:30 <Twey> Is the source for lambdabot's (a -> a) Num instance available somewhere?
16:02:45 <Twey> > sin ^ 2 $ 3
16:02:45 <lambdabot>   1.991485667481699e-2
16:02:53 <Twey> That one
16:03:53 <Melvar> > 2 3
16:03:53 <lambdabot>   2
16:04:07 <mauke> it's probably on hackage somewhere but it works like http://mauke.dyndns.org/stuff/haskell/fun.hs
16:04:12 <mauke> except specialized to (->)
16:04:59 <rpglover64> I'm getting an apparently nonsensical error message in the compilation of a package I'm writing
16:05:19 <rpglover64> Couldn't match expected type Foo with actual type Foo.
16:05:26 <Twey> Hm, okay, thanks
16:05:28 <rpglover64> (Foo not the actual name of the type)
16:05:37 <Twey> rpglover64: Foo's from different modules?
16:05:50 <Twey> Hm, usually it qualifies one of them in error messages, though…
16:05:58 <mauke> rpglover64: what's the actual message?
16:06:30 <hpaste> “Alex R” pasted “nonsensical error” at http://hpaste.org/49627
16:06:30 <Twey> mauke: Does it have to require FlexibleInstances and UndecideableInstances?
16:06:33 <rpglover64> http://hpaste.org/49627
16:06:43 <Twey> s/de/d/
16:06:46 <Twey> Er
16:06:47 <mauke> Twey: my code yes, the (->) instance probably not
16:06:52 <Twey> s/dea/da/
16:06:57 <Twey> mauke: Hmm
16:07:28 <ash__> is there a function that takes a list [Num] -> [Num] where the resulting list is a set of values [n + n - 1 ...]
16:07:43 <ash__> so… [1, 2, 1] -> [ 1, 3, 4 ]
16:08:05 <mauke> :t scanl (+)
16:08:05 <lambdabot> forall a. (Num a) => a -> [a] -> [a]
16:08:13 <mauke> > scanl (+) 0 [1,2,1]
16:08:14 <rpglover64> :t scanl1 (+)
16:08:14 <lambdabot>   [0,1,3,4]
16:08:14 <lambdabot> forall a. (Num a) => [a] -> [a]
16:08:31 <ash__> what if you give that an infinite list?
16:08:41 <mauke> > scanl (+) 0 [1 ..]
16:08:41 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
16:08:48 <rpglover64> > take 10 $ scanl1 (+) [1..]
16:08:49 <lambdabot>   [1,3,6,10,15,21,28,36,45,55]
16:08:52 <ash__> ah, it works that way? neat
16:09:12 <rpglover64> mauke: darn you for typing faster than me :)
16:10:21 <ash__> thanks, I thought I could do something with scanl to get it to work, but I wasn't sure how it would work with an infinite list
16:11:20 <c_wraith> yeah, scanl can produce some output before doing the whole calculation, so it does
16:12:51 <rpglover64> Twey: any idea what causes the error message?
16:13:39 <eyu100_> @hoogle Float -> Float
16:13:39 <lambdabot> Prelude significand :: RealFloat a => a -> a
16:13:39 <lambdabot> Prelude abs :: Num a => a -> a
16:13:39 <lambdabot> Prelude negate :: Num a => a -> a
16:13:45 <Peaker> rpglover64: no idea, but maybe you are compiling two versions of the same package simultaneously somehow?
16:14:09 <eyu100_> > deriv abs 0
16:14:09 <lambdabot>   0
16:14:36 <rpglover64> Peaker: only one version exists; but the package has a library and an executable section; the library section compiles fine, and the executable is the one that breaks
16:14:51 <Peaker> rpglover64: maybe if you import Language.BigBang.Ast in that module -- the error message will use unqualified names -- and give more information?
16:15:23 <Peaker> rpglover64: so it would seem that somehow you're getting the library and the executable to occupy two instances of the same code in the same namespace
16:16:14 <hpaste> “Alex R” annotated “nonsensical error” with “nonsensical error” at http://hpaste.org/49627#a49628
16:16:18 <Peaker> rpglover64: maybe your executable spec in the .cabal file specifies the modules it depends on twice -- once as modules of the exe, and second by having the exe itself depend on the lib in the same .cabal (the new cabal feature allowing self-depends)
16:16:42 <rpglover64> (this is the first cabal package i've built)
16:16:42 <Peaker> rpglover64: yeah, definitely two instances of same code
16:17:01 <Peaker> rpglover64: in the .cabal section describing the exe, try to remove the Language.BigBang.* modules
16:17:08 <Peaker> can you paste the .cabal file?
16:19:14 <hpaste> “Alex R” annotated “nonsensical error” with “cabal file” at http://hpaste.org/49627#a49629
16:21:09 <mauke> what happens if you remove 'big-bang' from build-depends?
16:22:07 <rpglover64> Could not find module `Language.BigBang.Syntax.Parser':
16:22:20 <rpglover64>       It is a member of the hidden package `big-bang-0.1'.
16:22:26 <rpglover64>       Perhaps you need to add `big-bang' to the build-depends in your .cabal file.
16:22:37 <dcoutts> rpglover64: what command are you actually running?
16:22:41 <mauke> and if you add Language.BigBang.Syntax.Parser to other-modules?
16:23:05 <dcoutts> mauke: that won't make any difference
16:23:55 <dcoutts> the thing with having exes depend on libs in the same package is that the source file search dirs need to be separate, otherwise it just picks up the source files rather than using the modules from the package
16:23:57 <rpglover64> mauke: and if it does, it will make me sad, because the whole point of pulling out the library was so that I wouldn't have to duplicate modules across several executables (e.g., interpreter, tests)
16:24:14 <dcoutts> rpglover64: separate the src dir for the exes
16:28:27 <rpglover64> dcoutts: Thank you! It works.
16:30:13 <dcoutts> I'm still confused by the error though, I would have expected it to work before, but to always build the modules twice
16:30:44 <dcoutts> rpglover64: you were just running "cabal build" where you?
16:30:51 <rpglover64> yes
16:33:43 <eyu100> @pl deriv
16:33:44 <lambdabot> deriv
16:34:10 <eyu100> @pl f x y z = z y y z y z z z
16:34:10 <lambdabot> f = const (join . join . join . (flip =<< join . (flip =<< flip id)))
16:34:17 <eyu100> @pl f x y z = z y y z y z z z x x x x
16:34:17 <lambdabot> f = flip =<< (flip .) . (flip =<< (flip .) . (flip =<< (flip .) . flip (flip . join . join . join . (flip =<< join . (flip =<< flip id)))))
16:34:29 <eyu100> @pl f w x y z = z w y w y z y w z z z x x x x
16:34:32 <lambdabot> f = join . ((flip . (flip .)) .) . join . ((flip . (flip .)) .) . join . fmap flip . ((flip .) .) . flip . (flip .) . flip flip id . (ap .) . flip flip id . (ap .) . flip flip id . (ap .) . (flip =<<
16:34:32 <lambdabot>  (flip .) . join . (flip .) . flip flip id . (ap .) . join . (flip .) . join (flip . (flip .) . flip . flip id))
16:34:32 <lambdabot> optimization suspended, use @pl-resume to continue.
16:34:41 <eyu100> @pl-resume
16:34:44 <lambdabot> f = join . ((flip . (flip .)) .) . join . ((flip . (flip .)) .) . join . fmap flip . ((flip .) .) . flip . (flip .) . flip flip id . (ap .) . flip flip id . (ap .) . flip flip id . (ap .) . (flip =<<
16:34:44 <lambdabot>  (flip .) . join . (flip .) . flip flip id . (ap .) . join . (flip .) . (flip =<< (flip .) . flip . flip id))
16:34:45 <djahandarie> eyu100, you can   /msg lambdabot  btw
16:34:50 <eyu100> ah
16:34:51 <eyu100> k
17:06:25 <Ke> > 1 .<<. 65
17:06:26 <lambdabot>   Not in scope: `.<<.'
17:06:44 <mauke> > 1 `shiftL` 65
17:06:44 <lambdabot>   Ambiguous type variable `a' in the constraint:
17:06:45 <lambdabot>    `Data.Bits.Bits a'
17:06:45 <lambdabot>      a...
17:06:49 <mauke> > 1 `shiftL` 65 :: Integer
17:06:50 <lambdabot>   36893488147419103232
17:07:14 <Ke> (1 `shiftL` 65) :: Int
17:07:30 <Ke> > (1 `shiftL` 65) :: Int
17:07:30 <lambdabot>   0
17:07:35 <Ke> thanks
17:08:44 <rvn_> Hey, I have a bit of code using putStr and a getLine right after it, and the getLine seems to evaluate before the putStr, yet, if I change it to a putStrLn then it evaluates afterwards. Can someone explain?
17:09:03 <mauke> rvn_: it doesn't "evaluate" afterwards
17:09:10 <mauke> it doesn't even execute afterwards
17:09:18 <mauke> it's straight up output buffering, same as in C
17:09:34 <rvn_> It seemed to wait until after the input though.
17:09:45 <rvn_> mauke, can you think of any reason why it would?
17:09:52 <mauke> <mauke> it's straight up output buffering, same as in C
17:10:04 <mauke> OUTPUT BUFFERING
17:10:06 <othiym23> it's waiting for the newline before it flushes the output
17:10:16 <hpc> hSetBuffering stdout NoBuffering
17:10:17 <rvn_> Ahhh, I see. Thank you.
17:10:20 <mauke> hpc: no, don't
17:13:15 <hpc> or something like that
17:13:41 <ski> rvn_ : that, or make sure your `putStr' outputs a `\n' last, *or* do `hFlush stdout', after the `putStr'
17:14:38 <ski> rvn_ : i would probably go with either of these latter solutions, if i didn't know for sure i wanted `NoBuffering'
17:15:25 <ski> of course `putStrLn' or `print' would also work, since it outputs a `\n' last
17:15:29 <ski> @src putStrLn
17:15:29 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
17:15:31 <ski> @src print
17:15:31 <lambdabot> print x = putStrLn (show x)
17:15:49 <coppro> @src putChar
17:15:49 <lambdabot> putChar c = hPutChar stdout c
17:15:54 <coppro> @src hPutChar
17:15:54 <lambdabot> Source not found. My pet ferret can type better than you!
17:16:00 <rvn_> ski, yeah, I've sorted it. Thanks.
17:22:20 <mornfall> Something is very wrong with build-depending on the Library in a Test-Suite.
17:25:47 <gienah> mornfall: it seems to work with the new testsuite stuff with Cabal-version: >= 1.10.1
17:26:11 <mornfall> gienah: It seems to force me to repeat all build-depends of the Library in the Test-Suite.
17:26:21 <mornfall> Even if that doesn't make any sense. Or does it?
17:27:14 <mornfall> It can't happen if the library is external.
17:29:23 <gienah> mornfall: i guess it probably does require repeating all build-depends of the Library in the Test-Suite (as in I seem to have most of them in something I'm working on)
17:29:47 <mornfall> Well, that's an awful violation of DRY.
17:30:19 <mornfall> As if it wasn't tedious enough to maintain a single copy of the build-depends list.
17:35:38 <gienah> mornfall: the Test-Suite build-depends: does not seem to require all of the libraries listed in the build-depends for the library, for example my library has build-depends: fgl graphviz, but I guess since I haven't done the tests for that yet the testsuite still builds without fgl graphviz in the the testsuite build-depends
17:37:20 <coppro> :t (a -> Bool) -> (a -> Bool) -> Bool
17:37:21 <lambdabot> parse error on input `->'
17:37:26 <coppro> @hoogle (a -> Bool) -> (a -> Bool) -> Bool
17:37:26 <lambdabot> Data.Graph.Inductive.Query.Monad orP :: (a -> Bool) -> (b -> Bool) -> (a, b) -> Bool
17:37:26 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
17:37:26 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
17:38:02 <coppro> :t (&&) `on` (.)
17:38:02 <lambdabot>     Couldn't match expected type `Bool'
17:38:02 <lambdabot>            against inferred type `f a -> f b'
17:38:02 <lambdabot>     In the second argument of `on', namely `(.)'
17:38:08 <coppro> aww :(
17:38:24 <coppro> :t (&&) `on` ($)
17:38:24 <lambdabot>     Couldn't match expected type `Bool' against inferred type `a -> b'
17:38:24 <lambdabot>     In the second argument of `on', namely `($)'
17:38:24 <lambdabot>     In the expression: (&&) `on` ($)
17:38:46 <gienah> mornfall: it is useful that the Testsuite build-depends can list test libraries (like QuickCheck, HUnit) while as the library does not need to depend on these, so the package can be built without the test libraries (like QuickCheck) if the -enable-tests is not specified to runghc ./Setup.hs configure
17:39:05 <aavogt> @ty on (&&) . flip ($)
17:39:06 <lambdabot> forall a. a -> (a -> Bool) -> (a -> Bool) -> Bool
17:39:47 <coppro> close
17:40:03 <aavogt> the 'a' has to come from somewhere
17:40:07 <coppro> oh right
17:40:10 <coppro> derp
17:40:39 <coppro> !hoogle (a -> Bool) -> (a -> Bool) -> a -> Bool
17:40:44 <coppro> @hoogle (a -> Bool) -> (a -> Bool) -> a -> Bool
17:40:45 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
17:40:45 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
17:40:45 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
17:42:06 <aavogt> @pl \f g x -> (on (&&) . flip ($)) x f g
17:42:06 <lambdabot> flip . flip (on (&&) . flip id)
17:42:27 <coppro> :t flip id
17:42:27 <lambdabot> forall a b. a -> (a -> b) -> b
17:42:45 <coppro> oh, haha
17:43:32 <aavogt> :t [id , ($) ]
17:43:33 <lambdabot> forall a b. [(a -> b) -> a -> b]
17:43:50 <coppro> yeah, I see how that works now
17:44:11 <coppro> @hoogle (a -> a -> b) -> (a -> b)
17:44:12 <lambdabot> Data.Foldable foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
17:44:12 <lambdabot> Data.Foldable foldr1 :: Foldable t => (a -> a -> a) -> t a -> a
17:44:12 <lambdabot> Prelude foldl1 :: (a -> a -> a) -> [a] -> a
17:44:39 <mornfall> gienah: Of course you should be able to specify build-depends. I would just expect that things *not actually used* by the testsuite needn't be there.
17:44:55 <aavogt> as usual, hoogle doesn't put the function you could use for that type there
17:45:01 <mornfall> gienah: Anyway, it turns out that Test-Suite simply recompiles all of the Library anyway.
17:45:02 <coppro> @pl \f x -> f x x
17:45:02 <lambdabot> join
17:45:38 <mornfall> gienah: So we are back to stone age, kind of.
17:46:05 <mornfall> When executables can *finally* be linked to a Library, Test-Suite is introduced which cannot.
17:46:51 <coppro> whee, the -> monad
17:50:41 <eyu100_> > @pl d' n f x = (flip d x) (\x -> d' (n-1) f x)
17:50:41 <lambdabot>   <no location info>: parse error on input `@'
17:50:48 <eyu100_> @pl d' n f x = (flip d x) (\x -> d' (n-1) f x)
17:50:48 <lambdabot> d' = fix (((d .) .) . (. subtract 1))
17:51:10 <gienah> mornfall: I try a test, I do twice: runghc ./Setup.hs build : every time it runs my pre-processor (even though the source has not changed) and compiles the testsuite (but not the library)
17:52:43 <mornfall> gienah: I mean, the source files that constitute the library are compiled again when compiling the testsuite.
17:54:14 <hpaste> gienah pasted “cabal testsuite stuff” at http://hpaste.org/49631
17:55:04 <gienah> mornfall: I pasted my output of the build and my .cabal file, for me it just seems to only build the testsuite each time
17:55:47 <mornfall> gienah: Well, not *each* time. But when you build from clean with cabal build && cabal test, you compile each file twice (or 3 times if profiling is enabled).
17:58:17 <hpaste> gienah annotated “cabal testsuite stuff” with “cabal testsuite stuff (annotation)” at http://hpaste.org/49631#a49632
17:59:32 <mornfall> Something's wrong with my Cabal, then.
17:59:33 <gienah> mornfall: at the very end of the paste is the clean build output, it seemed to only build the library once
18:00:02 <mornfall> gienah: Yeah. I'm wondering how you do that.
18:00:30 <mornfall> I still get 92 files to compile in the testsuite.
18:00:46 <gienah> mornfall: hopefully my cabal file might give some hings comparing to yours
18:00:49 <mornfall> Oh.
18:00:54 <mornfall> I remember now.
18:01:19 <mornfall> Cabal completely fails to take same-library build-depends without hs-source-dirs.
18:01:32 <mornfall> Not saying a word about the problem.
18:02:04 <mornfall> What a nuisance.
18:03:04 <gienah> mornfall: I guess I'm liking the hs-source-dirs option even more
18:03:28 <mornfall> Well, I never really got the point of that one.
18:03:44 <mornfall> It just adds an extra level of directories to all sources.
18:03:48 <ivanm> so I finally upgraded to ghc-7... wtf does this error mean? SpecConstr    Function `$j_sbQi{v} [lid]' has six call patterns, but the limit is 3
18:04:01 <Saizan> not an error
18:04:40 <Saizan> anyhow it means "i won't specialize this function any further and someone forgot to mute this message in the release"
18:04:49 * hackagebot repa 2.1.1.2 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-2.1.1.2 (BenLippmeier)
18:05:05 <ivanm> Saizan: as in the GHC release?
18:05:16 <Saizan> yep
18:05:49 * hackagebot repa-examples 2.1.0.2 - Examples using the Repa array library.  http://hackage.haskell.org/package/repa-examples-2.1.0.2 (BenLippmeier)
18:06:04 <ivanm> does it indicate that there's something I can do in my code to improve it that that message is referring to?
18:07:23 <Saizan> you could increase the limit to allow more specializations, but i don't know how to tell when that'd be a win
18:33:41 <ivanm> OK, looks like GHC-7.0.4 produces code that is slower than 6.12.3 ...
18:35:33 <kmc> in what circumstance ivanm?
18:36:09 <mornfall> *sigh* ... the exitcode-stdio Test-Suite does not report any progress. What a nightmare.
18:37:35 <gienah> mornfall: I guess I just run the test executable from the command line
18:38:02 <mornfall> Well, it seems to make more sense to just make it an Executable, really.
18:38:12 <ivanm> kmc: for my program, same compiler flags... one test which took about 10min with 6.12.3 now takes 12 min
18:38:20 <mornfall> Saves users the trouble of requiring cabal 1.10.
18:38:32 <mornfall> And it actually works.
18:38:34 <geheimdienst> Test-Suite is some new thing, right? (first time i'm seeing it in a cabal file)
18:38:40 <mornfall> Without making my life miserable.
18:38:40 <gienah> mornfall: probably, but it seems to have the marketing tick-box that it includes a test-suite :-)
18:39:07 <mornfall> geheimdienst: Since 1.10.
18:39:08 <parcs> hmm, i wonder whether `x | f x, g x` is more efficient than `x | f x && g x`
18:41:52 <gienah> mornfall geheimdienst: I guess I'm hoping in time that the haskell test frameworks might in future include support for the new cabal testsuite integration
18:42:48 <hatds> I'd guess both forms get desugared into the same code...
18:44:06 <hatds> well && isn't necessarily inlined, so yea maybe a small difference
18:44:30 <ivanm> kmc: admittedly, this is with profiling enabled; maybe it just does more profiling work *shrug*
18:44:56 <hydo> Erf.  I have now copied this to three projects.  How bad would it be for me to upload a simple package to hackage with this?  I don't want to piss the community off for the sake of my own convenience.  (Text.Parsec.Text - parsec on Data.Text) http://snurl.com/sxlm8
18:44:59 <monochrom> look at core to find out
18:45:18 <hydo> Hrm, maybe I should check again to make sure it's not already there since the last time I looked.
18:45:30 <monochrom> I think everyone wants parsec on data.text
18:45:44 <hydo> That's what I thought.
18:45:44 <mornfall> gienah: I'd hope for that as well, but if the detailed-1.0 interface is as bad as the exitcode-stdio-1.0 is, I won't hold my breath.
18:45:57 <hydo> But I just wanted to make sure.  Making the package now..
18:45:59 <ivanm> polyparse has Text support... ;-)
18:46:12 <ivanm> hydo: you sure Text isn't an instance of the Stream class, or whatever aprsec uses?
18:47:30 <ivanm> also, Data.Text.Lazy may be a better idea than Data.Text
18:48:22 <monochrom> I am sure installing parsec and text alone (in fact haskell platform) does not get you "instance Stream Text"
18:48:28 <hydo> or both... not sure about the stream class thing.  Is that new for parsec > 3.0?  I know it works fine for parsec 3... at least I think it does.
18:48:46 <ivanm> monochrom: no, but it'd probably be better to add said instance of parsec
18:48:51 <monochrom> Stream is from parsec >= 3
18:49:24 <monochrom> ok, add it to parsec, so that parsec depends on text? or add it to text, so that text depends on parsec?
18:49:58 <mornfall> Or orphans forever.
18:50:03 <monochrom> imo the best is to let it be an orphaned instance and put it in a separate package
18:50:37 <ivanm> parsec depends on bytestring; why not Text?
18:50:44 <monochrom> @hackage the-happy-marriage-of-parsec-and-text
18:50:44 <lambdabot> http://hackage.haskell.org/package/the-happy-marriage-of-parsec-and-text
18:50:44 <ivanm> AFAIK, the bytestring dep is just for the bytestring parsing
18:50:53 <hatds> it probably shouldn't depend on bytestring
18:50:56 <ivanm> monochrom: heh
18:51:06 <monochrom> bytestring comes with ghc.
18:51:10 <ivanm> admittedly, depping on bytestring isn't that bad since it's a boot library
18:51:12 <ivanm> monochrom: yeah
18:51:22 <hatds> oh yea, good point
18:52:42 <hydo> I've just had this package laying around that I cabal-dev add-source that depends on both.  Seems to work fine, but maybe I'll put it up on github to give people a chance to say "uh, uh, uuuuh! bad idea!"
18:53:05 <hydo> after supper, that is.
18:54:06 <monochrom> oh, btw, how do I get an account on hackage?
18:55:08 <ivanm> monochrom: you have to ask for it
18:55:15 <ivanm> I think Ross is the one that authorises them
18:55:24 <ivanm> but there's a form on Hackage to request an account
18:55:27 <kfish> http://hackage.haskell.org/packages/accounts.html
18:56:15 <monochrom> sweet, thanks
19:03:58 <copumpkin> what's the simplest path from nowhere to a numeric timestamp? :)
19:04:18 <copumpkin> I don't even care about it being correct, as long as it's monotonically increasing even across invocations of the program
19:05:20 <monochrom> across invocations is harder, i.e., IO business
19:05:25 <ivanm> OK, looks like I may have been bitten by GHC-7's new inliner working differently...
19:05:36 <copumpkin> monochrom: yeah, I expect that
19:05:41 <ivanm> I removed an explicit INLINE pragma and it made it faster, but not as fast as before :/
19:05:43 <copumpkin> I really just want IO Integer :P
19:05:44 <kmc> copumpkin, on POSIX that's clock_gettime(CLOCK_MONOTONIC, ...)
19:05:50 <monochrom> "the simplest path" excludes measuring the entropy of the whole universe!
19:06:01 <copumpkin> kmc: got an IO Integer for me?
19:06:04 <copumpkin> or even IO Int
19:06:15 <copumpkin> but probably something a bit more consistently large
19:06:23 <monochrom> Int will fail to be monotonic
19:06:29 <copumpkin> yeah
19:06:32 <copumpkin> Int64 might not
19:06:33 <copumpkin> :)
19:07:04 <monochrom> I would getCurrentTime then combine the two fields of UTCTime. they're both Num blah blah
19:07:11 <kmc> copumpkin, write yr. own library ;P
19:07:19 <copumpkin> kmc: :(
19:07:20 <kmc> realtime clock is not guaranteed monotonic
19:07:28 <copumpkin> I just need something that's mostly monotonic :P
19:07:40 <copumpkin> I have a web service that wants an ever-increasing number
19:07:46 <copumpkin> I just need to feed it something to make requests
19:08:42 <monochrom> another way is to run a daemon for that
19:09:07 <monochrom> hmm is there something in /dev ?
19:10:02 <hatds> how to I resolve an 'undefined reference' error when linking my program with mydll.dll ?  Right now all I'm doing is passing a "-l:mydll.dll" option to the linker
19:10:19 <kmc> what's the undefined reference?
19:10:22 <kmc> the symbol, i mean
19:10:32 <hatds> int hello ()
19:10:50 <hatds> is that what you mean?
19:12:02 <hatds> I suppose I need a header somewhere?
19:12:36 <kmc> not necessarily
19:12:49 <kmc> i'm just asking for the full text of the 'undefined reference' error
19:13:14 <hatds> .\Sys\Windows.o:fake:(.text+0x33b): undefined reference to `hello
19:13:35 <kmc> you're using 'hello' through a foreign import?
19:13:39 <hatds> yes
19:13:51 <kmc> yeah, a header isn't necessary
19:15:13 <kmc> your header would just declare a prototype for 'hello' and your foreign import is already filling that role
19:15:34 <kmc> it's really "-l:mydll.dll" and not "-lmydll" ?
19:15:38 * kmc has not used windows in ages
19:15:46 <gienah> hatds: maybe it might work to list the library in Extra-libraries: mydll
19:15:54 <gienah> in the .cabal file
19:16:07 <hatds> -lfoo actually means the file libfoo.a
19:16:16 <gienah> along with: Extensions:        ForeignFunctionInterface
19:16:42 <hatds> well this project isn't cabalized
19:17:40 <gienah> hatds: then usually on linux it is easier to use ghc to do the link with the ghc --make option, and use -lmydll
19:18:12 <gienah> hatds: I hope ghc --make also knows how to link stuff on windows
19:18:58 <hatds> I am doing ghc --make  with -lwhatever at the end
19:19:25 <gienah> hatds: that's sort of like what I do in a makefile on linux
19:20:27 <gienah> hatds: although my linux program is more crazy as the main is in a .c file, so I need more stuff in the link like:
19:20:53 <gienah> -L/usr/lib64/ghc-7.0.1/pretty-1.0.1.2 -lHSpretty-1.0.1.2 -L/usr/lib64/antlrc-9999/ghc-7.0.1 -lHSantlrc-0.0.2 -L/usr/lib64/ghc-7.0.1/haskell98-1.1.0.0 -lHShaskell98-1.1.0.0
19:20:54 <hatds> main in .c is crazy, I've been there
19:21:46 <gienah> hatds: my crazy example with main in .c : https://github.com/markwright/antlrc-examples/tree/master/src/tapl/arith
19:23:29 <hatds> ok stupid question... do I link "foo.dll" or "foo.dll.a" ?
19:24:40 <dmwit> :t fmap (uncurry (+) . ((*86401) . (*10^12) . toModifiedJulianDay . utctDay) &&& (floor . (*10^12) . toRational . utctDayTime)) getCurrentTime
19:24:41 <lambdabot> Not in scope: `toModifiedJulianDay'
19:24:41 <lambdabot> Not in scope: `utctDay'
19:24:41 <lambdabot> Not in scope: `utctDayTime'
19:24:45 <gienah> hatds: I think ghc might want to try to link things statically by default, and there is a -enable-dynamic link option (but not sure of the exact option)
19:24:59 * hackagebot eddie 0.2 - Command line file filtering with haskell  http://hackage.haskell.org/package/eddie-0.2 (MikeMeyer)
19:26:00 <dmwit> copumpkin: fmap (uncurry (+) . ((*86401) . (*10^12) . toModifiedJulianDay . utctDay &&& floor . (*10^12) . toRational . utctDayTime)) getCurrentTime
19:26:03 <dmwit> :: IO Integer
19:26:10 <gienah> hatds: looking at the ghc docs there is: -dynamic
19:26:13 <copumpkin> hah thanks :)
19:26:31 <copumpkin>   t <- getPOSIXTime
19:26:31 <copumpkin>   let t' = round (t * 1000000)
19:26:33 <copumpkin> that's what I went with
19:26:39 <copumpkin> I could probably use fmap but whatever
19:26:41 <hatds> gienah: isn't that for linking the haskell rts or some such dynamically?
19:26:46 <dmwit> Mine has 10^-12 second precision... ;-)
19:26:48 <hatds> couldn't hurt to try
19:27:18 <gienah> hatds: there is a section in the manual: 4.12. Using shared libraries
19:27:32 <dmwit> Oh, so does getPOSIXTime.
19:27:42 <dmwit> Yeah, that's better.
19:29:04 <hatds> geinah: -dynamic wants me to compile all my packages for shared usage
19:29:05 <copumpkin> :)
19:29:10 <copumpkin> yours probably works on windows too
19:29:26 <hatds> I just want to link to this one .dll of mine...
19:29:45 <monochrom> could you make it a .lib instead of a .dll?
19:30:01 <monochrom> otoh I no longer know windows either
19:30:47 <kmc> copumpkin, POSIX realtime clock is not monotonic
19:31:19 * applicative wonders, is hatds calling Hell from Heaven, or Heaven from Hell?
19:32:11 <hatds> well I am trying to link "hello()"
19:32:13 <hatds> take your pick
19:32:31 <monochrom> I think hell from heaven. haskell main and c callee
19:32:48 <copumpkin> kmc: I'm only issuing commands comparatively rarely
19:32:54 <copumpkin> you talking about leap seconds?
19:33:00 <kmc> and clock adjustments
19:33:21 <monochrom> backward clock adjustments are possible
19:33:30 <copumpkin> yeah, I'm happy to assume they won't
19:33:31 <hatds> it needs to be a .dll since later I want to use the win32 api to install a keyboard hook that requires a .dll
19:33:38 <gienah> hatds: there is a section that mentions windows: 4.12.4. Finding shared libraries at runtime
19:33:38 <copumpkin> this program is just for me anyway
19:33:52 <gienah> but then it seems to be missing the sub-section on windows
19:34:04 <hatds> gienah: I see that, but I can't get to runtime yet :)
19:35:00 <hatds> I'm certain the linker ld has found my .dll or associate .d because it stops complaining it can't find it and instead complains that my .o file has an undefined reference
19:35:18 <hatds> whoops: associated .a
19:35:36 <gienah> hatds: there's another section: 11.6. Building and using Win32 DLLs
19:37:37 <dmwit> copumpkin: readFile "~/.copumpkin's increasing number" >>= writeFile "~/.copumpkin's increasing number" . succ . read
19:38:04 <kmc> use POSIX shared memory
19:38:14 <kmc> no use SysV shared memory because it's more fun
19:38:22 <copumpkin> dmwit: :P
19:40:27 <monochrom> I don't think those sections are relevant. they're all for turning haskell code into dll. here we just have a c code dll
19:41:15 <monochrom> moreover "-dynamic" is just for "don't link ghc libs statically"
19:41:52 <gienah> hatds: I think windows .dll files have a corresponding import libary .lib from memory, so guessing ghc would need to find the .lib import library
19:42:43 <hatds> makes sense, and that agrees with the example at the bottom of the ghc manual page
19:43:20 <hatds> so .a gets fed to ghc, nothing(?) to ld
19:45:17 <gienah> hatds: I'm not sure, I guess it at least wants to see the .lib import library, not sure if it needs the .dll to link as well or not
19:46:43 <hatds> grr, ld is still just as unhappy as ever!
19:46:53 <hatds> y u no link?
19:46:58 <int80_h> which apt command can I use to get a list of installable packages?
19:47:17 <int80_h> this is indirectly haskell related..I'm beta testing yesod .9
19:47:42 <gienah> hatds: this at least mentions haskell and import libraries: http://www.well-typed.com/blog/33
19:49:39 <hatds> gienah: I think the import lib is the .a    it was created using "-Wl,--out-implib=" when compiling the .dll
19:56:22 <hpaste> jake pasted “circular.hs” at http://hpaste.org/49635
19:58:41 <sshc> john pasted your mom at http://hpaste.org/1275401720
20:00:21 <hatds> uh oh:  "COLLECT_GCC_OPTIONS='-o' 'main.exe' '-fno-stack-protector' '-DDONT_WANT_WIN32_DLL_SUPPORT'
20:00:35 <hatds> I *do* want dll support
20:01:31 <kmc> haha
20:01:36 <kmc> stack protectors are for wimps anyway
20:02:30 <hatds> what are 'COLLECT_GCC_OPTIONS=' ?
20:03:08 <sshc> Right.  foldl's in Prelude for a reason.
20:03:30 <copumpkin> you can have an infinite stack in ghc anyway
20:04:00 <kmc> copumpkin, :D
20:07:26 <dainanaki> does anyone know any good resources for how to use data.dynamic?
20:09:20 <kmc> dainanaki, the API is very small and is reasonably well-documented
20:09:23 <kmc> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.1.0/Data-Dynamic.html
20:09:23 <ByronJohnson> dainanaki: The documentation should be sufficient: http://hackage.haskell.org/packages/archive/base/4.3.1.0/doc/html/Data-Dynamic.html
20:09:30 <kmc> or are you looking for more like "why would i want this"?
20:09:48 <dainanaki> Yes.
20:10:01 <dainanaki> I'm trying to figure out how this would really be useful.
20:12:19 <kmc> dainanaki, say you're running a service where a user sends you the name of a function, and some arguments to that function, and you run the function
20:12:28 <kmc> you might store the functions in a (Data.Map String Dynamic)
20:12:46 <kmc> and you'd cast to the type implied by the user's specified arguments, at runtime
20:12:55 <kmc> this is just one possible design for that problem
20:13:04 <dainanaki> so basically remote procedure calls is what you're talking about?
20:13:12 <kmc> sure, just as an example
20:13:16 <dainanaki> I mean, I guess I could see doing something akin to existential types with it too.
20:13:23 <kmc> any time you need to dispatch to functions of different types with a runtime value
20:13:29 <kmc> in my example you can probably get away with ordinary sum types, too
20:13:50 <kmc> and indeed a lot of the supposed advantages of dynamically-typed languages come from using the type system itself as a single, ad-hoc, global sum type
20:14:03 <kmc> and go away if you compare to a language with algebraic data types
20:14:05 <hatds> ordinary sum types won't let you have differing return values, but GADTs would..
20:14:10 <kmc> dynamic typing looks great if you compare to Java ;)
20:14:29 <kmc> dainanaki, yeah, it's like existentials
20:14:58 <hatds> I found the Control.Exception module very compelling as a usage of Typeable, which is the same spirit
20:15:06 <kmc> specifically, Dynamic is very much like  exists a. (Typeable a) *> a
20:15:24 <dainanaki> yes, that's what got me curious.
20:15:50 <kmc> or in GHC's syntax:  data Dynamic = forall a. (Typeable a) => MkDyn a
20:15:51 <hatds> I think xmonad uses dynamic casts for message passing
20:16:06 <kmc> yeah, that's another good example
20:16:17 <kmc> passing messages through a channel which is ignorant of their type
20:16:23 <dainanaki> Hmm, that is an interesting example.
20:16:28 <aavogt> kmc: is there a difference besides no pattern matching?
20:16:48 <aavogt> the xmonad thing is the same thing as Control.Exception
20:16:50 <kmc> aavogt, the 'exists' syntax with type classes is not implemented by any compiler i know of
20:17:07 <kmc> dainanaki, GHC doesn't implement Dynamic as an existential with Typeable, though
20:17:20 <kmc> instead it just uses unsafe casts to/from this Any type
20:17:21 <dainanaki> right, I was just making a conceptual comparison
20:17:22 <kmc> i'm not sure why
20:17:52 <dainanaki> One could ostensibly implement a chain of responder OOP style pattern by passing dynamic values though, that's a neat thought.
20:18:15 <kmc> what is that, and why does it require dynamic typing?
20:18:49 <dainanaki> it's when one object doesn't know what to do with a value, it passes it on to a subcomponent to figure out what to do with it.
20:19:42 <dainanaki> i'm not sure it would actually make any sense to do in haskell anyways, but it was just an interesting idea.
20:19:50 <mauke> isn't that what xmonad does?
20:21:27 <kmc> :t let use f = fmap f (fromDynamic ?x) in msum [use ?f, use ?g, use ?h]
20:21:28 <lambdabot> forall a a1 a2 a3. (?x::Dynamic, Typeable a, Typeable a2, Typeable a3, ?f::a -> a1, ?g::a2 -> a1, ?h::a3 -> a1) => Maybe a1
20:21:59 <kmc> sadly "map use [?f, ?g, ?h]" will not type-check
20:23:12 <kniu> @pl (\x y -> f (g x y))
20:23:12 <lambdabot> (f .) . g
20:23:44 <kniu> @hoogle lift
20:23:44 <lambdabot> Control.Monad.Trans lift :: (MonadTrans t, Monad m) => m a -> t m a
20:23:44 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
20:23:44 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
20:33:10 <ivanm> @type fromDynamic
20:33:11 <lambdabot> forall a. (Typeable a) => Dynamic -> Maybe a
20:33:21 <kmc> :t fromDyn
20:33:21 <lambdabot> forall a. (Typeable a) => Dynamic -> a -> a
20:33:25 <kmc> ^^^ not sure why this one exists
20:33:44 <pumpkin> if you don't know about fromMaybe
20:33:50 <kmc> isn't it better to keep the API smaller and use 'fromMaybe x . fromDynamic' when you want that?
20:34:22 <ivanm> wouldn't that be fromJust . fromDynamic ?
20:34:31 <copumpkin> no
20:35:12 <kmc> @pl \d x -> fromMaybe x $ fromDynamic d
20:35:12 <lambdabot> flip fromMaybe . fromDynamic
20:35:14 <ivanm> oh, mis-read the type of fromDyn
20:45:14 <dmwit> Why shouldn't fromDyn be offered?
20:45:28 <dmwit> If there's a piece of code that a lot of people use, it ought to be available in a library.
20:45:53 <kmc> dmwit, that concern balances against keeping the APIs small and orthogonal
20:46:01 <kmc> so they are easier to learn and think about
20:47:17 <kniu> @pl (\(x, y) -> (x, f y))
20:47:17 <lambdabot> second f
20:47:22 <kniu> @hoogle second
20:47:22 <lambdabot> Control.Arrow second :: Arrow a => a b c -> a (d, b) (d, c)
20:47:22 <lambdabot> Data.Time.Clock secondsToDiffTime :: Integer -> DiffTime
20:47:22 <lambdabot> Data.Time.Clock.TAI type LeapSecondTable = Day -> Integer
20:47:26 <kniu> gah
20:48:05 <kmc> dmwit, I don't think the 'default value' behavior of fromDyn is a primary or even common use of Dynamic
20:48:05 <ivanm> kmc: on the other hand, if a lot of people keep re-defining fromDyn, it's tempting for someone to define a utility library to use, which may eventually get merged upstream
20:48:05 <kmc> it seems pretty artificial
20:48:05 <glguy> kniu: you want the one from Control.Arrow
20:48:26 <ivanm> > second show ('a', 3)
20:48:27 <lambdabot>   ('a',"3")
20:49:02 <kmc> ivanm, but people keep writing (+2) and yet there's no clamor to add a plusTwo function to Prelude
20:49:21 <ivanm> true
20:49:30 <aavogt> plusTwo is longer
20:49:38 <glguy> Who keeps naming +2 ?
20:49:54 <ivanm> but as aavogt and glguy says, there's a reason you don't ;-)
20:50:00 <ivanm> kmc: so do you think that my recent proposal to ad $!! to deepseq was bad?
20:50:10 <ivanm> after all, it's easy to define in your own code, etc.
20:50:13 <kmc> i didn't see that proposal
20:50:28 <kmc> i'm not a huge fan of deepseq to begin with
20:50:32 <kmc> that seems all right to me though
20:51:00 <kmc> conversely, should every function that returns Maybe come with a variation that takes a 'default' argument instead?
20:51:09 <kmc> that seems silly to me.  we have abstractions like Maybe for a reason
20:51:33 <glguy> What was the reason?
20:51:35 <kmc> i'm just not convinced the fromDyn use case is compelling enough
20:51:56 <kmc> (plus, it's poorly named, but that could be fixed separately)
20:52:54 <kmc> there are good reasons to provide only a simple, powerful basis for building functions
20:53:22 <kmc> rather than anticipating every combination of those which someone might possibly want, and giving each one a name
20:53:52 <kmc> (and when you invent that many names, some of them will be arbitrary or just bad, which compounds the issue of making APIs harder to learn)
20:54:25 <glguy> On the other hand if you have to reinvent/name them every time people will have to relearn the new names every time they look at new code
20:54:40 <kmc> right
20:55:04 <kmc> but i think (fromMaybe x . fromDynamic) is unlikely to be named at its use site, much like (+2)
20:55:28 <kmc> if it is named, it'll be some domain-specific name relating to the meaning of the x that's closed over
20:58:17 * kmc thinks 'default' would be a good name for fromMaybe, if it weren't a reserved word
20:58:25 <kmc> another reason to dislike type defaulting...
21:01:36 <dibblego> C# calls it ??
21:11:00 <glguy> dibblego: If I didn't know any better I'd have said you appeared very confused.
21:11:51 <dibblego> oh sorry, I mean C# has a name for fromMaybe, it is a syntax operator, the operate name is double question mark (??)
21:12:14 <kmc> that's special-case syntax?
21:12:29 <dibblego> yes
21:12:31 <glguy> dibblego oh, but I *did* know better ;)
21:12:32 <glguy> 
21:12:35 <kmc> sigh
21:13:10 <kmc> why do so few languages allow users to define new infix operators?
21:13:20 <glguy> ?? is their fromMaybe, not fromDyn
21:13:20 <lambdabot>  is their fromMaybe, not fromDyn
21:13:22 <dibblego> C#/Java et. al. don't permit anything but strict function arguments, unless the language dictatorship hands it down to you specifically
21:13:41 <kmc> overloading existing operators is popular, but leads to terrible contortions
21:13:53 <dibblego> "abc" ?? _|_; // terminates
21:14:47 <kmc> there's a lot of small nice things in Haskell which have nothing to do with "purity" or "good static types" and yet seem just as rare
21:15:38 <coppro> What is [::] ?
21:15:47 <kmc> coppro, parallel array for Data Parallel Haskell
21:15:50 <kmc> a GHC extension
21:16:20 <dmwit> kmc: Why do so few languages allow users to define new mixfix operators?
21:16:40 <kmc> dmwit, i know, right?
21:17:00 <dibblego> because it is accepted to encode effects in function names
21:17:40 * ski . o O ( Prolog allows the declaration of prefix and postfix operators, in addition to infix ones. all of course with both precedence and fixity )
21:17:41 <kmc> i'd believe that generalized mixfix is much harder to implement than prefix + infix, though
21:18:12 * ski . o O ( Haskell doesn't have prefix operators )
21:18:45 <kmc> i meant normal function application syntax
21:18:55 <ski> yeah, but that's a different thing
21:19:14 <ski> function application works as an invisible *infix* operator
21:19:25 <kmc> true
21:19:35 <mm_freak> ski: haskell has one hard-coded prefix operator
21:19:59 <ski> in Prolog, one can declare `not' to be a prefix operator, with "non-strict" fixity, which allows one writing `not not foo' instead of `not (not foo)'
21:20:07 <mm_freak> :t \x -> -x
21:20:08 <lambdabot> forall a. (Num a) => a -> a
21:20:10 <kniu> @hoogle forall k v. Map k v -> Map k v -> Map k v
21:20:11 <lambdabot> Data.Map union :: Ord k => Map k a -> Map k a -> Map k a
21:20:11 <lambdabot> Data.Map unionWithKey :: Ord k => (k -> a -> a -> a) -> Map k a -> Map k a -> Map k a
21:20:11 <lambdabot> Data.Map unionWith :: Ord k => (a -> a -> a) -> Map k a -> Map k a -> Map k a
21:20:27 <ski> mm_freak : yes, arithmetic negation. but it doesn't allow you to declare your own, which is really what i was talking about
21:21:08 <coppro> Due to the presence of juxtaposition as an operator, once cannot necessarily distinguish between a prefix and infix operator
21:21:13 <ski> (Prolog also allows postfix operators, working in essentially the same way as prefix ones, except the other order around)
21:21:21 <coppro> if juxtaposition is syntactically invalid, there is no such ambiguity
21:22:32 <ski> coppro : if `not not foo' is allowed (and parses like `not (not foo)', then that's a sign that a prefix operator is used
21:22:46 <coppro> ski: indeed
21:22:56 <dmwit> Agda parses custom mixfix operators, so it must be a solved problem.
21:23:00 <mm_freak> i wouldn't want 'not not x' to work in haskell
21:23:12 <mm_freak> i like having to write not (not x) or rather (not . not) x
21:23:21 <ski> (also, of course Haskell has distinct syntactic classes/categories for infix operators, and normal identifiers, so the ambiguity you mention wouldn't apply here)
21:23:46 <mm_freak> i find the haskell syntax so simple that you can easily just read a piece of code and know exactly how it is evaluated
21:23:50 <coppro> although one can argue that Haskell does support prefix operators
21:24:01 <kmc> mm_freak, evaluated?
21:24:34 <mm_freak> kmc: i'm referring to associativity as an evaluation effect
21:24:48 <coppro> I sort of wish Haskell hadn't hardocded -
21:25:03 <mm_freak> ditto
21:25:14 <mm_freak> i'd be very comfortable with having to write 'negate x'
21:25:22 <ski> mm_freak : how about `¬ ¬ x' ?
21:25:33 <joe6> need some design advice: I have a microcontroller device with a C compiler. I am wondering if there is any way to program it with haskell..
21:25:47 <mm_freak> ski: doesn't make sense to me
21:25:48 <kmc> joe6, http://hackage.haskell.org/package/atom
21:25:53 <kmc> joe6, why do you want to use Haskell?
21:25:56 <ski> (assuming `¬' is an operator identifier, not a normal identifier)
21:26:04 <joe6> I mean not as a haskell program, obviously, due to space limitations, but as a C program, maybe.
21:26:13 <joe6> kmc, easier to program and test.
21:26:24 <joe6> with the combinators and stuff.
21:26:29 <mm_freak> ski: obviously i know what it means intuitively, but i don't see the great virtue of being able to spell it that way
21:26:47 <ski> mm_freak : many people in logic use `¬ ¬ Foo' also the same thing with the modal operators `[]' and `<>'
21:26:56 <mm_freak> joe6: you can compile haskell down to C, but i doubt that you will get haskell code to work on it in a useful way
21:27:11 <joe6> mm_freak. yes, I understand that.
21:27:11 <mm_freak> joe6: haskell is not well suited for low level microcontroller programming
21:27:32 <joe6> I was more looking for something similar to the llvm high-level wrapper for C.
21:27:32 <kmc> joe6, it sounds like you want a Haskell-embedded domain-specific language for microcontroller programming
21:27:35 <kmc> atom is that
21:27:40 <coppro> hrm... GHC sort of chokes on unary operators
21:27:40 <mm_freak> joe6: you may check where the BitC language went, but i guess they stopped working on it
21:27:50 <kmc> if you just want to output C code, there's language-c
21:28:00 <coppro> it could definitely do better than that
21:28:03 <joe6> kmc, i will check out atom.
21:28:14 <kmc> there are some atom+arduino examples
21:28:17 <joe6> kmc, I think language-c might be a good bet too.
21:28:33 <joe6> mm_freak: thanks, will check out BitC
21:28:39 <coppro> so yes, Haskell has unary operators. They're just all of the form (XX) where XX is some symbol ;)
21:28:49 <mm_freak> a DSL might work, but keep in mind that you don't use haskell in that case…  you use the DSL and hence are restricted to its domain
21:29:29 <ski> coppro : well, in my world, operators have precedences, at least
21:29:31 <joe6> atom, I think, has a different goal.
21:29:38 <coppro> ski: Unary operators need no precedence
21:29:40 <mm_freak> > let (.-.) x = negate x in (.-.) 3
21:29:40 <lambdabot>   -3
21:30:23 <joe6> atom seems to be geared for more realtime goals
21:30:35 <ski> coppro : of course they do. you might want `foo bar baz x quux y' to parse as `foo (bar ((baz x) quux y))' (`quux' being an infix operator, here)
21:31:00 <coppro> ski: you're evil :P
21:31:49 <mm_freak> joe6: the idea of using FRP on a µC is teasing, though
21:31:55 <ski> > - 2 ^ 4  -- `-' binds looser than `^'
21:31:56 <lambdabot>   -16
21:32:00 <mm_freak> so if you have any success, i'd be glad to hear about it
21:32:04 <ski> > - 2 == 3  -- `-' binds tighter than `=='
21:32:05 <lambdabot>   False
21:32:07 <joe6> ofcourse, it is.
21:32:19 <ski> ergo, prefix `-' in Haskell have a precedence in between that of `^' and `=='
21:33:04 <ski> coppro : so even `-' already has a precedence
21:33:23 <mm_freak> i wonder if there is any non-GC functional language around, or at least non-RTS
21:33:52 <ezyang> FP is pretty tough without a GC. Certainly there are typed low level languages, but I don't think you could call them functional.
21:33:58 <ezyang> I'd love to be shown to be wrong though.
21:34:19 <copumpkin> http://mlton.org/Regions helps
21:34:30 <ski> mm_freak : early versions of MLKit didn't have a GC. they added it later to allow more long-running program which would otherwise accumulate garbage in the top region which would never be recovered before the program main loop terminated
21:34:36 <mm_freak> when programming a µC, i'd likely find myself reinventing yampa in C++
21:34:37 <sshc> Non-RTS Haskell sounds interesting
21:35:01 <ski> mm_freak : i assume that it is still possible to write programs which doesn't need the GC (it can possibly be turned off)
21:35:13 <ezyang> Heavy monadic regions, maybe.
21:35:23 <mm_freak> is SML any good?
21:35:39 <mm_freak> sshc: non-RTS haskell doesn't sound very good IMO
21:35:48 <mm_freak> i can't imagine it to be very useful
21:35:49 <ski> mm_freak : pre-Scheme is a language without GC that is used to bootstrap Scheme48. pre-scheme only allows those closures which it can simplify away at compile-time
21:36:39 <mm_freak> ski: well, it may have a GC, but haskell comes with a large RTS, which is not so good for µC
21:37:32 <ski> copumpkin : interesting link, ty
21:39:32 <joe6> BitC seems pretty cool.
21:39:32 <ski> mm_freak : it might also be interesting to investigate uniqueness typing/modes in Clean and Mercury. while those languages have a GC, these features allow you to declare that a value has only one reference to it, so that the implementation can reuse the storage for new values, so that less garbage is created (and if you drop the reference, then the compiler can insert a `free' call, i.e. compile-time GC of the value, in a sense)
21:40:18 <copumpkin> np
21:40:28 <kmc> afaik BitC is aiming at the same niche as Felix and D
21:40:31 <mm_freak> joe6: the last time i checked BitC was terribly outdated, but the idea is great
21:40:44 <kmc> which is like "it would be cool to use C++ in systems programming, if it weren't wretchedly terrible"
21:40:59 <joe6> mm_freak, oh, ok. Do you know of any alternatives?
21:41:11 <joe6> kmc, thanks for the suggestions.
21:41:29 <kniu> so at what point does pointfree golf turn into an abomination?
21:41:29 <kmc> it's really bad that C++ is still the best for *any* niche
21:41:41 <kniu> I just wrote
21:41:41 <kniu>   s <- getMetas [t] >>= (getTypes >>= getMetas >>=) . (return .) . (\\)
21:41:46 <mm_freak> ski: yes, i see the virtues of uniqueness/linear types, but AFAIK clean also comes with an RTS
21:41:49 <kmc> o_O
21:41:59 <mm_freak> joe6: no idea, sorry
21:42:02 <kniu> It astounded me that it compiled on the first try.
21:42:10 <kmc> well done kniu :)
21:42:10 <ville> C++ is fun.
21:42:30 <kmc> ville, yeah, it's a great esolang
21:42:37 <ski> mm_freak : SML is quite nice. it doesn't have type classes, it doesn't have *higher-kinded* types, it doesn't have polymorphic recursion or any of the Haskell extensions, and of course it doesn't have pervasive laziness, it being strict, though you can have a type `susp' of lazy suspensions. on the plus side is its module system which allows you to write "module functions" called "functors" that take other modules as input, improving modularity
21:42:55 <ezyang> Modules are pretty fun.
21:43:04 <Cale> kniu: If you're going to combine (.) and (>>=), use (=<<) instead
21:43:04 <sshc> mm_freak: But technically feasible?
21:43:05 * ezyang has done some module programming recently. 
21:43:08 <kniu> oh wait, I've managed to remove another point:
21:43:09 <kniu>   getMetas [t] >>= (getTypes >>= getMetas >>=) . (return .) . (\\) >>= flip quantify t
21:43:24 <ski> e.g., if you have some code using a priority queue, then you can take an implementation of that as input to your code
21:43:30 <kniu> @hoogle =<<
21:43:30 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
21:43:30 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
21:43:31 <mm_freak> kniu: IMO pointfree code should be quickly understandable for any non-beginner haskell programmer…  if it isn't, you may want to introduce some points
21:43:44 <ski> and then later, in one single place do you actually decide which priority queue implementation that you actually want to use
21:43:47 <ville> esolang? heh, guess I am just too far gone then. I use it every day.
21:44:06 <ski> (and you can instantiate the functor several types, using different pri-queue implementations as input, if you want to)
21:44:16 <ski> (s/types/times/ :)
21:44:26 <sshc> mm_freak: (I'm referring to compiling Haskell code without RTS)
21:44:30 <ion> Erlang has a nice approach to garbage collection: each process (lightweight thread) has separete garbage collection, affecting nothing else.
21:44:45 <mm_freak> ski: i'm not moving away from haskell for regular programming, but i thought perhaps SML can be an alternative for low level microcontroller programming
21:44:53 <kmc> ville, right, it is actually still the best language for certain tasks, but even there you're constantly dodging traps and bizarre corner cases
21:45:01 <mm_freak> although without higher-kinded types it appears to be quite useless to me
21:45:09 <hatds> lately I've found myself using GADTs to express "parametricity over a module".  The idea being all functions  module_func :: a -> b -> c gets turned into a constructor Module_func :: a -> b -> ModAPI c
21:45:16 <kmc> ville, also you have to go *really far* down the C++ rabbit hole to produce good C++ designs
21:45:23 <ski> kniu : `flip quantify t =<< (=<< getMetas =<< getTypes) . (return .) . (\\) =<< getMetas [t]'
21:45:36 <mm_freak> sshc: well, i'm not sure, but the RTS handles quite a lot in haskell
21:45:49 <kniu> lol
21:45:56 <hatds> functions of the form imp :: forall a. (ModAPI a) -> a  correspond to different implementations
21:45:58 <ski> mm_freak : heh, what is the application of higher-kinded types you had in mind ?
21:46:06 <kmc> "C with a few extensions" is bearable, and true idiomatic C++ is bearable, and in between lies a vast wasteland where lies most industrial C++ code and most C++ programmers
21:46:41 <mm_freak> ski: arrows
21:47:00 <ville> kmc: yes for some reason people still choose "C++ with some weird restrictions applied to it" approach.
21:47:03 <mm_freak> sshc: the idea of the RTS is an extension of the idea that the compiler produces better machine code than the average programmer
21:47:04 <ski> mm_freak : btw, you can, sortof, simulate higher-kinded types by using functors, but it's not as nice, and you don't get parametric polymorphism (for each input type to the higher-order type you'll get a new module with separate implementation handling just that input type)
21:47:15 <kmc> ville, you mean versus going whole-hog?
21:47:17 <mm_freak> the RTS produces better I/O and memory behaviour than the average programmer
21:47:21 <ville> kmc: might have been alright in the olden days when there was no standard or poorly implemented.
21:47:29 <ski> mm_freak : well, arrows themselves are not higher-kinded. arrow transformers are, though
21:47:42 <ski> s/arrows/arrow types/
21:47:48 <kmc> ville, I think it's just very hard to put together a team that can use all the high-octane C++ features correctly without going insane
21:47:52 <mm_freak> ski: exactly =)
21:47:55 <kniu> Why hasn't anybody come up with a strict yet purely functional programming language without garbage collection yet?
21:48:06 <mm_freak> ski: also i can't imagine how to write any code in applicative style without higher kinded types
21:48:26 <mm_freak> but i guess you wouldn't want to write in that style in SML anyway
21:48:35 <ski> (mm_freak : also ion's comment above is interesting ..)
21:48:36 <kmc> in my experience you have at least one developer who refuses to learn placement new or virtual inheritance or virtual templated operator subclass exception polymorphism
21:48:39 <mm_freak> kniu: because it's difficult
21:48:45 <kniu> really?
21:48:50 <kmc> and so you end up writing some terrible hax
21:48:51 <joe6> mm_freak, when you mentioned sml, did you mean: uri: http://www.pllab.riec.tohoku.ac.jp/smlsharp/
21:49:03 <mm_freak> kniu: even the esoteric languages lazy K and unlambda absolutely need garbage collection, and they are pretty much the minimum of what you can get
21:49:06 <ion> It of course requires the Erlang approach to processes, which is share-nothing message passing.
21:49:10 <mm_freak> they are the brainfuck of lambda calculus
21:49:30 <kniu> hm
21:49:32 <kmc> ion, GHC is supposed to get per-capability minor GC one of these days
21:49:32 <ski> hatds : do you mean in the style of <http://groups.google.com/group/comp.lang.functional/msg/22ea87a1cb8abfb8> ?
21:49:33 <ville> kmc: now you're just putting buzzwords togehter. heh.
21:49:37 <mm_freak> joe6: no, i meant the language, which mlton compiles
21:49:37 <hatds> hey now, I got a win32 .dll to link with my haskell program!
21:49:41 <kmc> ville, yeah, the last one is fake ;)
21:49:51 <ion> kmc: Cool
21:49:56 <kmc> of course GHC does let you pass heap values between threads, which complicates it
21:49:57 <hatds> and I have no idea why my first example doesn't work! doh
21:50:01 <ion> aye
21:50:10 <kmc> and i think major GC is still going to be stop-the-world, for that reason
21:50:28 <kmc> i guess in minor GC you treat all objects not in the local heap as live
21:51:15 <ion> Perhaps there could be a way to create a thread that doesn’t allow shared values and gets a separate “global” GC.
21:51:22 <ion> So you can choose what model suits you.
21:51:54 <mm_freak> well, you need GC for closures, but C++1x has a weaker form of closures, which gets along without GC
21:52:31 <mm_freak> perhaps C++ is a good functional language for low level stuff, but with an extraordinarily ugly syntax
21:52:41 <ion> ...and semantics :-P
21:52:59 <dolio> And not functional.
21:53:10 <dolio> But other than that.
21:53:13 <hpaste> sutabi pasted “Split?” at http://hpaste.org/49636
21:53:14 <ville> it's sort of silly to try to restrict you to one form of programming if you pick C++.
21:53:24 <mm_freak> dolio: C++1x can well be used in a functional style
21:53:25 <kniu> I can't figure out why closures absolutely need GC
21:53:26 <hatds> ski:  the explicit dictionary approach is not quite what I'm talking about, but I'm not sure if they aren't isomorphic
21:53:56 <ion> :t splitOn
21:53:57 <lambdabot> Not in scope: `splitOn'
21:54:02 <ion> @hoogle splitOn
21:54:02 <lambdabot> No results found
21:54:04 <kniu> since, if one can grit one's teeth and bear the potential inefficiency, just pass closures around by value
21:54:25 <ion> sutabi: splitOn :: Eq a => [a] -> [a] -> [[a]]
21:54:48 <ion> sutabi: splitOn doesn’t return an IO action, thus you don’t use <- to draw a value out of it.
21:55:00 <mm_freak> kniu: because you can pass closures around and they might still be around, even when the scope of the defining function was long left
21:55:23 <mm_freak> in short, you can't determine, when they die
21:55:29 <ion> sutabi: You could use: do input <- getLine; let numbers = splitOn " " input; ..., or: do input <- splitOn " " <$> getLine; ...
21:55:35 <dmwit> sutabi: words
21:55:37 <ski> mm_freak : well, the "Light-weight Threads" library for O'Caml uses a monad to express cooperative threads ..
21:55:42 <ski> joe6 : interesting link, ty
21:55:43 <dmwit> > words "hey there cutie!"
21:55:44 <lambdabot>   ["hey","there","cutie!"]
21:55:45 <kniu> mm_freak, well
21:55:45 <ion> dmwit: That, too. :-)
21:56:01 <ski> hatds : can you elaborate more on how your idea works, then ?
21:56:09 <sutabi> ion gah! I swore I tried let number = ...
21:56:18 <kniu> you can simply not care about when the enclosing scope dies if you manually carry the captured variables around with the closure value
21:56:23 <sutabi> it works fine now thanks ion!
21:56:25 <mm_freak> ski: something like monad-coroutine?
21:56:58 <ski> kniu : closures can work with region management instead, see ML Kit .. but for the top region at least, you probably want GC
21:57:16 <mm_freak> kniu: i suppose you could free closures manually
21:57:22 <sutabi> dmwit, thanks :)
21:57:23 <ski> mm_freak : "C++1x has a weaker form of closures, which gets along without GC" how does that work ? "downward FUNARG only" ?
21:57:48 <kmc> they're not weaker
21:57:56 <kmc> you just have to manage them explicitly, like anything else in C++
21:58:20 <kmc> i expect they'll be most useful with ref-counted smart pointers
21:58:29 <mm_freak> ski: C++1x closures just copy everything, IIRC
21:58:46 <ski> kniu : yeah, but you can't in general know how much space is needed for the captured variables .. and they might reference any other value on the heap
21:58:53 <kmc> right, if you pass them by value, they copy everything, just like any other C++ struct
21:59:12 <kmc> you can pass them by reference or pointer, or by e.g. refcounted smartpointer, or any other construct built out of those
21:59:21 <kmc> also, the closures themselves can close by value, by reference, or by pointer
21:59:57 <kniu> oh right, of course
22:00:06 <kmc> afaik nothing prevents you from closing by pointer over a local variable, returning that closure by value from the function, and calling it later
22:00:12 <kmc> the result is nasty undefined behavior
22:00:16 <kmc> that's life in C and C++
22:00:56 <mm_freak> there should be a really good functional language, which is suitable for microcontrollers
22:00:59 <mm_freak> haskell simply isn't
22:01:04 <kniu> you know what
22:01:08 <kniu> I'm gonna make that language.
22:01:15 <kniu> With blackjack.
22:01:17 <kniu> And hookers.
22:01:20 <kmc> cool
22:01:24 <mm_freak> go ahead, man
22:01:42 <kmc> language design is a depressing field
22:01:55 <kmc> most people don't do their homework and make well-known mistakes
22:02:02 <kmc> even if you do, you will still make well-known mistakes
22:02:12 <kniu> examples?
22:02:21 <notostraca> kmc, maybe there should be a wiki of these common mistakes
22:02:23 <kmc> and no matter how good your language is, people will ignore it and keep using PHP
22:02:57 <kmc> notostraca, it's an entire field of computer science
22:03:03 <kmc> programming language theory
22:03:03 <notostraca> yes
22:03:29 <notostraca> but common major mistakes should be pretty easy to just say "don't do this"
22:03:36 <mm_freak> kmc: as long as a single person uses a language, it's reasonable
22:03:49 <mm_freak> at least if the person wouldn't be better off with a different language
22:03:58 <notostraca> dynamic scoping, global variables...
22:04:09 <notostraca> locking concurrency
22:04:14 <ski> mm_freak : possibly, i haven't seen that library before. fyi `Ltw' (light-weight threads) is at <https://ocsigen.org/lwt/manual/>,<http://caml.inria.fr/cgi-bin/hump.cgi?contrib=709>,<http://docs.camlcity.org/docs/godilib/3.12/lwt>
22:04:17 <mm_freak> funnily i think FRP is well possible in PHP
22:04:20 <kmc> null in every type by default
22:04:54 <mm_freak> ski: i must ask, why are you telling me?
22:05:44 <kniu> locking concurrency is like manual memory management
22:05:52 <kniu> for performance, it's sometimes necessary.
22:06:05 <notostraca> yeah, but there are "wrong ways to do it" aren't there?
22:06:17 <mm_freak> kniu: when?
22:06:21 <notostraca> like python's GIL and OCaml's inability to parallel-GC
22:06:28 <ski> mm_freak : mostly as a "fyi", if you'd care about it. feel free to ignore it if you're not interested :)
22:06:55 <notostraca> I think OCaml is going to get that one fixed though
22:07:02 <mm_freak> didn't want to sound rude…  i am interested, but which problem does it solve?
22:07:16 <kniu> when all your processor has is XCHG and you only got a few K of memory?
22:07:47 <mm_freak> kniu: lockfree concurrency is translated to locking concurrency
22:07:50 <mm_freak> (usually)
22:07:59 <kniu> trying to implement mailboxes in such a case seems... misguided
22:09:39 <ski> "If you already wrote code using preemptive threads, you shall know that doing it right with threads is a hard job. Moreover system threads consume non negligible resources, and so you can only launch a limited number of threads at the same time. Thus this is not a real solution."
22:10:05 <ski> of course, implementing the green threads in the RTS as GHC does is an alternative option
22:10:16 <ivanm> is there a penalty in using Reader as opposed to just passing parameters around all the time?
22:10:26 <ivanm> (there are only two, so it wouldn't be that hard/bad to do so)
22:11:05 <hatds> ski: sure, one sec
22:11:18 <kmc> ivanm, it depends on whether (>>=) is getting inlined
22:11:23 <ski> ivanm : there aren't a penalty to using `Reader' per se, but using it might give the implementation a harder time to perform improvements to your code which would otherwise have been done
22:11:24 <mm_freak> ivanm: usually no, but note that there are two types of reader monads
22:11:36 <ivanm> *nod*
22:11:38 <kmc> i wouldn't expect a big performance difference
22:11:44 <kmc> of course if you really care, you should profile
22:11:46 <ivanm> mm_freak: well, just using the lazy one
22:12:03 <mm_freak> > let tan = do x <- sin; y <- cos; return (x/y); in tan pi
22:12:04 <lambdabot>   -1.2246467991473532e-16
22:12:14 <ivanm> well, profiling didn't reveal it, but making a sub-function explicitly get the value from the reader rather than have it passed in seemed to make it slightly slower
22:12:22 <mm_freak> ivanm: no, i mean there is the reader monad (r ->)
22:12:26 <ivanm> ahhhh
22:12:29 <mm_freak> i use it quite a lot
22:12:32 <ski> (ivanm : the first point is because it's a `newtype')
22:12:41 <ivanm> no, I mean as in Control.Monad.Trans.Reader ;-)
22:12:49 <ivanm> ski: *nod*
22:13:02 <mm_freak> ivanm: yes, but there is semantically no difference between the two reader monads
22:13:11 <mm_freak> except when you're using ReaderT instead of Reader
22:13:27 <ivanm> *nod*
22:13:36 <mm_freak> i find the (r ->) monad easier to work with than the Reader monad
22:13:43 <ski> mm_freak : what's the difference, then ?
22:14:07 <ski> mm_freak : sure, but it also has potential for giving more confusing error messages
22:14:34 <mm_freak> ski: well, good question…  i guess it's a matter of taste
22:14:55 <ski> (because you might not see easily whether the function types it's talking about are ones which you use monadically or ones which you don't)
22:15:01 <mm_freak> one reason to prefer (r ->) is that you may get rid of one of your library dependencies
22:15:06 <mm_freak> and you get somewhat cleaner code
22:15:25 <mm_freak> yes, error messages are a point against (r ->)
22:15:27 <ski> in some kinds of code, it can be really handy, though
22:18:43 <joe6> anyone tried jhc?
22:19:05 <joe6> what is the size of a small program with jhs?
22:22:55 <hpaste> hatds pasted “GADTs as APIs” at http://hpaste.org/49637
22:23:13 <hatds> ski: that won't compile as is, but that's the idea
22:24:00 <Cale> I've used that idiom to good effect quite often.
22:24:21 <hatds> and there's a bunch of silly naming errors in my functions/constructors
22:24:26 <copumpkin> hatds: that's one model people use to model IO (it's also a monad if you add some nice stuff)
22:27:04 <Cale> Or at least, often enough that I really like it. You can flesh out the core of a library and write some code with it without having to actually implement anything to begin with.
22:27:05 <hatds> copumpkin: yea, the prompt monad uses this idea
22:27:05 <copumpkin> yep
22:27:05 <Cale> and yeah, changing implementations is easy
22:27:05 <hatds> the monad part isn't really that critical I find, the key idea is there with the functions on the GADTs
22:28:44 <hatds> for some reason I find doing it that way much nicer than passing around a record of functions
22:28:55 <hatds> even though it just changes selectors to constructors
22:29:42 <joe6> jhc seems to be able to program microcontrollers.
22:29:48 <joe6> anyone tried it?
22:31:47 <kmc> joe6, it outputs portable C; you'll still need a runtime system though
22:31:55 <kmc> not saying this is impossible on microcontrollers
22:32:59 <ski> hatds : ok, so you're doing a shallow embedding of the API, and then provide several semantic functions on that
22:33:17 <ski> hatds : you might be interested in <http://hackage.haskell.org/package/MonadPrompt> which i think is a bit related to what you're doing
22:33:34 <hatds> ski: that's exactly where I learned of the trick originally
22:33:38 <joe6> kmc, oh, really
22:33:40 <ski> aha :)
22:33:57 <joe6> kmc, do you know how big the whole executable size might be?
22:34:04 <kmc> joe6, yeah, it tries to do region inference to eliminate the need for GC, but afaik this was never working 100%
22:34:08 <kmc> joe6, no, why don't you try it out?
22:34:29 <kmc> that will depend on the particular μC and the C compiler you're using
22:34:36 <joe6> kmc, yeah will try it out.
22:34:39 <joe6> gcc
22:34:57 <ski> hatds : one advantage of this is to be able to do interesting analyzes of something using the API
22:35:02 <mm_freak> Cale: sorry for bothering you again about FRP, but i found that it's straightforward to implement ArrowChoice for a naive arrowized FRP implementation…  do you see any reason why yampa doesn't have that instance?
22:35:51 <hatds> ski: analysis of what?
22:36:02 <Cale> I'm not sure. You mean by switching?
22:36:40 <Phyx-> does GHC give a package module or file on it's path preference (if they have the same name)
22:36:52 <ski> hatds : similar to, if one has made a language specification apart from the implementation, then one can do non-standard semantics like a program which determines which modules import and export which things (to be able to jump to definitions easily in an editor), and also other stuff like partial evaluators, binding-time analysis, abstract interpretation, &c.
22:36:54 <mm_freak> Cale: you can interpret that as switching, but in many cases much more convenient than by the switching combinators
22:37:07 <mm_freak> let me paste my code
22:37:50 <Cale> mm_freak: I mean, did you implement the ArrowChoice operations in terms of what Yampa already provided, or using the SF constructors?
22:38:27 <kmc> Phyx-, on the path iirc
22:38:32 <Cale> My guess is that if you do it in terms of what Yampa provides, you'll use an rSwitch or one of the others...
22:39:26 <hpaste> “Ertugrul Söylemez” pasted “Naive arrowized FRP with choice” at http://hpaste.org/49638
22:39:55 <mm_freak> Cale: i made my own toy FRP implementation
22:40:01 <mm_freak> see the paste
22:40:07 <Cale> yeah, I see
22:40:57 <mm_freak> i think, yampa uses the same idea, but i don't understand a bit of the underlying code, so i'd refrain from forking it
22:41:07 <mm_freak> it looks pretty complicated, probably due to optimizations
22:41:11 <Cale> yeah
22:41:44 <Cale> Optimisations which as far as I could tell were half-implemented and don't really exist in most cases?
22:42:01 <Cale> I never ran into an arrow which wasn't a plain SF
22:42:01 <Phyx-> kmc: is there any flags to control that by chance?
22:42:02 <mm_freak> i don't know…  i'm really urged to write my own implementation
22:42:05 <Cale> yeah
22:42:09 <Cale> I would :)
22:42:56 <mm_freak> well, i've read a paper, which suggests that you may want to have some additional constructors for certain arrows like arr, constant, etc.
22:43:20 <kniu> @hoogle bind
22:43:20 <lambdabot> Network.Stream bindE :: Result a -> (a -> Result b) -> Result b
22:43:20 <lambdabot> System.Console.Editline.Readline bindKey :: Char -> Callback -> IO ()
22:43:20 <lambdabot> Language.Haskell.TH.Syntax bindQ :: Q a -> (a -> Q b) -> Q b
22:43:28 <Cale> So an interesting property of your left is that every time you switch from Left to Right in the input, you forget the state of the contained arrow. That's probably acceptable in a lot of cases.
22:44:02 <Cale> (but it is something to be aware of)
22:44:10 <Cale> (oh, or do you?)
22:44:20 <Cale> hmm, maybe not
22:44:35 <Cale> yeah, in this version you don't :)
22:44:41 <mm_freak> i thought so
22:44:56 <mm_freak> because my outer c' should contain the latest version of the left SF in any case
22:45:01 <Cale> er, yeah
22:45:50 <mm_freak> ok, i will write my own implementation now, because it seems that yampa is simply not mature for real world scenarios
22:46:03 <Cale> So when you use a case expression, each branch of the case can have its own state which will be kept independently
22:46:44 <mm_freak> btw, Cale, you told me that continuous time is a modularized away in your implementation…  could you give me a clue as to how that might look like in a pure implementation?  i don't see any way to do it, honestly
22:46:44 <Cale> mm_freak: A nice way to do it is to use a GADT with all the arrow primitives
22:46:51 <mm_freak> except perhaps through a second constructor
22:47:37 <Cale> mm_freak: Well, first imagine that the DTime parameter wasn't there.
22:47:59 <mm_freak> data SF a b = SF (a -> (b, SF a b)) | TimedSF (DTime -> a -> (b, SF a b))
22:48:05 <Cale> The SF becomes basically a Mealy machine
22:48:39 <mm_freak> wait, let me try to figure it out
22:49:11 <Cale> Uh, I don't actually know how to turn this directly into something equivalent to our semantics...
22:49:34 <Cale> But that's one way to remove time
22:49:50 <mm_freak> hmm…  i don't see a way to remove it differently, if SF is pure
22:50:04 <Cale> Well, our implementation doesn't look like SF.
22:50:09 <mm_freak> except perhaps to pass dt as an input parameter, but that would be inconvenient
22:50:23 <mm_freak> yeah, you told me you have an impure implementation
22:50:30 <mm_freak> but i'd like to keep it pure
22:50:48 <Cale> You can turn the arrow type into a GADT of all the arrow and FRP primitives you want, and then implement the whole thing with whatever semantics you'd like.
22:51:15 <mm_freak> yeah, the GADT idea is interesting
22:51:37 <mm_freak> i think yampa does that in fact
22:53:08 <mm_freak> wait, actually why would i want a GADT?
22:54:13 <Cale> Well, you can write an interpreter for that GADT which does arbitrary analysis on the composed values.
22:56:12 <mm_freak> i see
22:56:15 <mm_freak> let me give it a shot
22:56:42 <Cale> The values flowing along the arrow wires in our system we call behaviours (the things bound to variables by proc/do notation), and we also have values of type Event (~>) a. You can think of the behaviours as changing arbitrarily often (but they really only change in response to an occurrence of an event in the system, though it might not be an event that's in scope). The Events have occurrences which don't necessarily
22:56:42 <Cale> have real-numbered times attached to them in the basic system. Events can be tagged with the value of a behaviour, and you can hold the value of an event as a behaviour, which is always delayed.
22:59:01 <Cale> Time can then just be a behaviour, which you can tag events with to obtain the time of occurrence if you want to put explicit time back into the system. There can be multiple sorts of time though (like game time and real world time)
22:59:27 <Cale> But for convenience, we basically pass that in as a reader.
22:59:47 <Cale> (so it's a behaviour which is always "in scope" in a sense)
23:00:12 <Cale> (really, there's an arrow  getTime :: () ~> RealWorldTime)
23:01:37 <Cale> but that's a separate thing -- you could implement it by an arrow transformer
23:06:26 <Cale> We have some interesting switching combinators: forkExec :: (c -> c -> c) -> c -> (b, Event (~>) (b ~> (c, Event (~>) ()))) ~> c -- the first two parameters specify a monoid, and the results of the arrows spawned by the event are collected up to produce the result. Occurrences of the events in their result terminates them.
23:06:42 <Cale> (so each forked arrow has a way to kill itself)
23:07:13 <Cale> there's also  forksExec :: (c -> c -> c) -> c -> (b, Event (~>) [b ~> (c, Event (~>) ())]) ~> c  which allows for multiple arrows to be started simultaneously.
23:08:15 <mm_freak> interesting
23:09:14 <Cale> mealy :: (b -> s -> (c, s)) -> s -> Event (~>) b ~> Event (~>) c
23:09:33 <Cale> This is easy, but one of my favourite ways of incorporating state.
23:10:05 <mm_freak> well, i like the simplicity of the naive approach to arrowized FRP, where Event is just isomorphic to Maybe
23:10:33 <Cale> Yeah, the only problem with that is that you're always recomputing everything.
23:10:46 <mm_freak> ah, i see
23:10:53 <Cale> So even if the events which are input to an arrow don't occur
23:10:58 <Cale> you're computing everything
23:11:54 <Cale> (laziness helps some)
23:11:57 <mm_freak> well, it appears to me that in yampa events are sort of thrown in like patchwork
23:12:11 <mm_freak> it seems to me that you can well have a completely eventless system
23:12:40 <mm_freak> after all all you want to do is to switch based on behaviours
23:13:28 <Cale> in our system, the only way for an arrow to change its state is by one of its input events occurring
23:14:11 <Cale> so the arrow will be some pure function from its inputs to its outputs until an event occurs, and we can recompute what it does at that time
23:14:53 <mm_freak> i understand
23:15:22 <mm_freak> but i think i'll go with the naive way for now, until i have a good understanding of FRP implementation
23:15:26 <Cale> yeah
23:15:30 <ski> hatds : btw `with_my_debugging' reminds me of my <http://hpaste.org/10060/repaste_of_poormandebug?pid=10060> (the annotation that showed an example of how to use it has been lost in time)
23:15:44 <ski> er, s/he left
23:15:52 <ski> @tell hatds btw `with_my_debugging' reminds me of my <http://hpaste.org/10060/repaste_of_poormandebug?pid=10060> (the annotation that showed an example of how to use it has been lost in time)
23:15:52 <lambdabot> Consider it noted.
23:16:05 <mm_freak> Cale: may i /query you for a question?
23:16:23 <Cale> I don't actually understand the implementation of our arrow fully yet, as I was working on other stuff while it was being implemented (I just helped a bit with the overall API)
23:16:25 <Cale> sure
23:19:23 <mm_freak> ok, thanks a lot for your help
23:20:32 <ski> @tell hatds an example of using it would be `fibonacciM :: (Monad m,Num a) => (a -> m a) -> (a -> m a); fibonacciM _    0 = return 0; fibonacciM _    1 = 1; fibonacciM fibM n = do {n1 <- fibM (n - 1); n2 <- fibM (n - 2); return (n1 + n2)}' (of course you can simplify to `liftM2 (+) (fibM (n - 1)) (fibM (n - 2))' in this case)
23:20:32 <lambdabot> Consider it noted.
23:22:51 <ski> @tell hatds and to use this : `pureFib :: Num a => a -> a; pureFib = trivialFix fibonacciM' and `tracedFib :: Num a => a -> (Trace a a,b); tracedFib = traceFix fibonacciM', where `Trace a a' is a tree containing the corresponding input and output values of all recursive calls
23:22:51 <lambdabot> Consider it noted.
23:25:56 <augur> Cale, ski: are there any computational ontologies that organize based on algorithmic structure?
23:26:12 <Cale> augur: I don't understand what that means.
23:26:44 <augur> well, from what i understand, the levels in the chomsky hierarchy can be viewed as being turing machines with different space bounding functions
23:27:14 <augur> i think regular languages are the linearly bounded turing machines, cfgs the polynomially bounded, and so forth
23:27:18 <augur> or something along those lines
23:27:58 <augur> and im curious if there are other hierarchies based on the structure of the state machine, rather than on the memory limitations of the machine
23:28:44 <ski> @tell hatds so the idea is that you write your function is monadic style (maybe one could use applicative functors instead, i haven't pondered that), but making it *polymorphic* so that it can't actually use monadic effects, so must be pure in itself. then `trivialFix' gives you back your pure function, while `tracedFib' weaves in effects for logging argument and result values of recursive calls. note how i use rank-2 polymorphism to hide the d
23:28:44 <lambdabot> Consider it noted.
23:29:52 <arcatan> ski: "hide the d"?
23:30:30 <ski> @tell hatds (cut off) "note how i use rank-2 polymorphism to hide the details of how this is implemented. it might also be possible to extend this to also allow your function to do effects in another monad"
23:30:30 <lambdabot> Consider it noted.
23:31:27 <ski> @tell hatds s/while `tracedFib' weaves in effects/while `traceFix' weaves in effects/
23:31:27 <lambdabot> Consider it noted.
23:31:40 <augur> @tell ski cant you do this in a /msg
23:31:40 <lambdabot> Consider it noted.
23:31:54 <augur> :P
23:32:12 <ski> i could, but then interested bystanders wouldn't see it
23:32:12 <lambdabot> ski: You have 1 new message. '/msg lambdabot @messages' to read it.
23:32:16 <ski> (also i'm done)
23:32:19 <ski> @messages
23:32:20 <lambdabot> augur said 40s ago: cant you do this in a /msg
23:35:14 <coppro> What's the semantic difference between a pattern match failing and diverging?
23:35:54 <glguy> one throws a catchable exception?
23:38:41 <coppro> caught in what sense?
23:39:17 <kmc> Control.Exception.catch
23:39:49 <ski> a pattern-match failing doesn't by itself throw an exception
23:40:11 <ski> only if there's no other branch to try next is an exception thrown
23:41:05 <coppro> kmc, glguy: That's an extension though
23:41:24 <ski> by a pattern-match diverging i assume it means that while attempting to match, which forces some thunks, either an exception is thrown by that thunk, or that thunk hangs, never returning
23:41:27 <vrthra> hello, I am trying to work through the template haskell page in wiki. One of the tutorials in that page mentions the [p| .. |] usage for patterns. However the syntax in the haskell.org page only mentions d and t. So is the syntax for patterns supported?
23:41:44 <ski> (which in unthreaded GHC may actually throw a `BlackHole' exception, in some cases)
23:42:31 <vrthra> Trying this expression seems to work, let y = [p| y |]
23:42:37 <augur> ski, Cale: no? :(
23:42:46 <vrthra> however let $y = 100 does not.
23:43:12 <coppro> ski: Diverging is defined by the report as trying to match against bottom
23:44:54 <glguy> coppro: you'll want to be specific if you are only asking about Haskell98. Extensions are the norm these days
23:45:01 <ski> augur : i don't know. i know there's stuff like <http://en.wikipedia.org/wiki/Arithmetical_hierarchy> and <http://en.wikipedia.org/wiki/Grzegorczyk_hierarchy>, but i'm not sure whether it's related
23:45:16 <augur> ski: ill take a look
23:45:24 <augur> ok, another open ended question!
23:45:43 <ski> vrthra : afaik (which isn't much about TH) splices/unquotes in patterns are not supported. you probably have to build it by "hand" instead
23:45:54 <augur> does anyone know of any new or radically different paradigms for programming?
23:46:12 <coppro> glguy: Why would I care about 98?
23:46:24 <vrthra> ski : thanks,
23:46:27 <Cale> augur: I don't know, on either question :)
23:46:40 <ski> coppro : indeed, and matching on bottom might mean matching on a thunk that hangs, and it might mean matching on a thunk that throws an exception (i.e. is partial)
23:46:44 <glguy> "That's an extension" and "according to the report" made me thing you were only asking about a subset of haskell
23:46:50 <glguy> think*
23:47:06 <Cale> augur: Do dependent type systems count as new? That's probably about as new as you'll get.
23:47:11 <coppro> glguy: Haskell 2010
23:48:10 <coppro> ski: Ok, that makes sense - but why is it considered differently from simple failure?
23:48:39 <ski> augur : i'm not sure about new, but if you haven't checked out logic programming and constraint programming yet, you should do so (also declarative concurrent programming with dataflow variables as described in e.g. CTM, using the language Oz) -- also attribute grammars are cool/interesting as a programming formalism
23:49:35 <ski> augur : oh, also dataflow programming like in Lucid,Lustre,Synchrone .. there's papers by Uustalu and Vene which explains how this is actually comonadic :)
23:50:04 <ski> coppro : why is what considered differently from simple failure ?
23:50:10 <coppro> ski: Divergence
23:51:19 <ski> coppro : semantically, it's treated as the same (i.e. bottom). operationally it's not quite the same, of course. sure the thunk doesn't return a value, but for different reasons, in one case because it doesn't terminate, in another because it wsa partial
23:52:07 <coppro> hrm
23:52:07 <augur> ski: ive actually looked into constraint programming. dont properly understand how its implemented but i get the idea
23:52:21 <augur> but i feel its just a refinement of the typical logical paradigm
23:52:30 <ski> constraint logic programming, or other implementation of constraints ?
23:52:33 <ski> ok
23:52:46 <ski> there are implementations that add to Java &c. as well
23:52:50 <augur> i mean really different -- something requires a completely different perspective on computation
23:53:03 <ski> afaiu, the ones which add to logic programming is the nicest, semantically
23:53:21 <coppro> > (\x = case x of { [a] -> True; _ -> False}) undefined
23:53:21 <lambdabot>   <no location info>: parse error on input `='
23:53:24 <ski> have you understood dataflow programming, yet ?
23:53:28 <coppro> > (\x -> case x of { [a] -> True; _ -> False}) undefined
23:53:28 <lambdabot>   *Exception: Prelude.undefined
23:53:37 <ski> (how different is really different ?)
23:53:50 <augur> ski: you mean the reactive class of languages
23:53:50 <augur> ?
23:53:53 <ski> > (\x -> case x of { [a] -> True; _ -> False}) (fix id)
23:53:57 <lambdabot>   mueval-core: Time limit exceeded
23:54:03 <coppro> that seems like a nice semantic difference
23:54:10 <coppro> hrm
23:54:34 <coppro> > ((\x -> case x of { [a] -> True; _ -> False}) undefined) `seq` ()
23:54:34 <lambdabot>   *Exception: Prelude.undefined
23:54:40 <ski> augur : well, afaiu, languages like Lucid aren't really reactive. but there could well be a connection, still
23:54:56 <coppro> > ((\x -> case x of { [a] -> True; _ -> False}) 3) `seq` ()
23:54:57 <lambdabot>   No instance for (GHC.Num.Num [t])
23:54:57 <lambdabot>    arising from the literal `3' at <inter...
23:55:18 <ski> s/3/[3]/
23:56:13 <coppro> shouldn't 3 match against _?
23:56:31 <ski> it complains about not finding how to interpret `3' as a list
23:56:45 <ski> try `True' instead of `3'
23:56:49 <ski> (`3' is overloaded)
23:56:55 <coppro> > ((\x -> case x of { [a] -> True; _ -> False}) True) `seq` ()
23:56:56 <lambdabot>   Couldn't match expected type `[t]'
23:56:56 <lambdabot>         against inferred type `GHC.Bool....
23:57:33 <coppro> Why is that failing altogether? Shouldn't it move on to the second match?
23:57:36 <glguy> This DFA recognizes all UTF-8 encoded Chars which satisfy Data.Char.isAlpha http://www.galois.com/~emertens/isAlphaUTF8.pdf
23:57:39 <coppro> err second pattern
23:57:43 <ski> it's a type error, `Bool' is not the same type as `[t]', which is the type of the pattern `[a]' there (and therefore also the type of `x' and the `_' pattern)
23:57:49 <coppro> oh right
23:57:52 * glguy is working on optimizing his algorithm for large cases
23:57:58 <coppro> derp
23:58:03 <ski> coppro : type errors are caught at compile-time. no run-time type checking
23:58:13 <ski> (if you want that, use `Dynamic')
23:58:16 <coppro> ski: yeah, yeah, brain fart
23:58:28 <ski> > cast True :: Maybe Bool
23:58:29 <lambdabot>   Just True
23:58:30 <ski> > cast True :: Maybe Int
23:58:31 <lambdabot>   Nothing
23:58:45 <coppro> I'm not so new to this language that I don't know that :)
23:58:51 <ski> @type toDyn
23:58:52 <lambdabot> forall a. (Typeable a) => a -> Dynamic
23:58:54 <ski> @type fromDyn
23:58:55 <lambdabot> forall a. (Typeable a) => Dynamic -> a -> a
23:58:56 <ski> @type fromDynamic
23:58:57 <lambdabot> forall a. (Typeable a) => Dynamic -> Maybe a
23:59:18 <coppro> > ((\x -> case x of { [2] -> True; _ -> False}) 1)
23:59:18 <lambdabot>   No instance for (GHC.Num.Num [t])
23:59:18 <lambdabot>    arising from the literal `1' at <inter...
23:59:19 <ski> @type cast
23:59:20 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
23:59:23 <coppro> > ((\x -> case x of { [2] -> True; _ -> False}) [1])
23:59:24 <lambdabot>   False
23:59:29 <coppro> > ((\x -> case x of { [2] -> True; _ -> False}) undefined)
23:59:30 <lambdabot>   *Exception: Prelude.undefined
23:59:47 <ski> > ((\x -> case x of { [2] -> True; _ -> False}) [undefined])
23:59:47 <lambdabot>   *Exception: Prelude.undefined
23:59:55 <ski> > ((\x -> case x of { [a] -> True; _ -> False}) [undefined])
23:59:56 <lambdabot>   True
