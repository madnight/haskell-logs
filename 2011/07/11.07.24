00:57:20 * hackagebot hbro 0.6.6 - A suckless minimal KISSy browser  http://hackage.haskell.org/package/hbro-0.6.6 (koral)
01:26:24 * hackagebot upskirt 0.0.4 - Binding to upskirt  http://hackage.haskell.org/package/upskirt-0.0.4 (FrancescoMazzoli)
01:57:27 * hackagebot HaXml 1.22.1 - Utilities for manipulating XML documents  http://hackage.haskell.org/package/HaXml-1.22.1 (MalcolmWallace)
01:58:01 <mreh> got an elegant pattern for say... mapping a function to a list that gives the difference of two adjacent numbers
01:58:20 <mreh> concatMap is the best I've got
01:58:43 <mreh> but a monadic map with State
02:00:02 <ion> > let f = zipWith (-) =<< drop 1 in f ([0..9] ++ [0,2..9])
02:00:04 <lambdabot>   [1,1,1,1,1,1,1,1,1,-9,2,2,2,2]
02:06:32 <hydo> Is there a standard map function that provides indexes?  something like ((int,a) -> b) [a] -> [b]?
02:06:45 <hydo> hoogle isn't giving up the goods.
02:06:56 <hydo> Or it is accomplished some other way.
02:06:57 <ion> > zip [0..] ["foo", "bar", "baz"]
02:06:58 <lambdabot>   [(0,"foo"),(1,"bar"),(2,"baz")]
02:07:02 <hvr> hydo: I've only seen that for non-prelude things like Data.Vector
02:07:27 <hydo> ion: Right, but I also.... hrm... I guess I could map it afterward.
02:07:58 <ion> :t \f -> map f . zip [0..]
02:07:59 <lambdabot> forall b t b1. (Num t, Enum t) => ((t, b1) -> b) -> [b1] -> [b]
02:08:19 <hydo> yea, that's what I'll do for now at least until I get up tomorrow and wonder what the hell I was thinking.
02:08:27 <hydo> thanks, ion and hvr!
02:09:01 <hvr> hydo: e.g.  imap :: (Int -> a -> b) -> Vector a -> Vector b
02:09:39 <hvr> and  izipWith :: (Int -> a -> b -> c) -> Vector a -> Vector b -> Vector c
02:12:45 <savask> Hello. Is there a haskell vector library? I mean these arrows which are used in geometry.
02:13:25 <mreh> these are not the arrows you are looking for
02:13:33 <savask> I know.
02:14:03 <mreh> Data.Vector?
02:14:05 <savask> All vector libraries I find, are about arrays.
02:14:26 <savask> And I need a library for mathematical vectors.
02:14:53 <mreh> does it matter what representation the vectors use?
02:15:08 <mreh> i only know of one kind of vector
02:15:31 <hvr> mreh: you mean vectors like linear vector-spaces?
02:15:46 <mreh> hvr: yeah
02:15:57 <mreh> i'm not looking for vectors though
02:17:30 <aninhumer> Hmm, I'm wondering whether a vector type could be a Num instance, primarily the problem I see being what * and / do
02:17:36 <hvr> savask: maybe you should search for matrix libraries... e.g. http://hackage.haskell.org/package/blas/
02:17:47 <azaq23> @hackage vector-space
02:17:47 <lambdabot> http://hackage.haskell.org/package/vector-space
02:17:48 <azaq23> maybe?
02:17:55 <savask> hvr: Okay, I'll look at it.
02:18:02 <mreh> hmatrix too
02:20:01 <savask> Oh, vector-space seems to be fine for me. Thanks, azaq23!
02:20:44 <mreh> that was easier than i first anticipated
02:23:02 <mreh> > zipWith (-) `liftM2` (drop 1) id [1,2,3,4,5]
02:23:03 <lambdabot>   Couldn't match expected type `t -> m [a]'
02:23:03 <lambdabot>         against inferred type `[a...
02:23:44 <mreh> > zipWith (-) `liftM2` (drop 1) id $ [1,2,3,4,5]
02:23:45 <lambdabot>   Couldn't match expected type `[[a]]'
02:23:45 <lambdabot>         against inferred type `a1 -> a1'
02:23:52 <mreh> gad
02:25:06 <mreh> > uncurry (zipWith (-)) . (drop 1 &&& id) $ [1,2,3,4,5]
02:25:07 <lambdabot>   [1,1,1,1]
02:25:27 <azaq23> savask: Though vector is a very general term, it can be anything which matches the mathematical description of what vector space is; for example, you could consider polynomials of degree n to be vector space with the basis [1, x, x^2, ... x^n]. Just because you said "the arrow things from geometry".
02:25:28 <azaq23>   If you just want to calculate with a normal geometry vectors, vector-space should work, but it may not be the best choice.
02:25:34 <ion> That wasn’t what you wanted? su121400 < ion> > let f = zipWith (-) =<< drop 1 in f ([0..9] ++ [0,2..9])
02:25:40 <ion> su121402 < lambdabot>   [1,1,1,1,1,1,1,1,1,-9,2,2,2,2]
02:26:13 <mreh> very elegant however you do it, although I forgot to mention I need n values, not n-1, so the final value is infact just the identity of the last value
02:26:42 <mreh> of course, that's easy, i was just looking for elegance
02:27:00 <savask> azaq23: It was hard for me to explain it in English, so my question were "clumsy" a little. Btw, why vector-space isn't the best choice?
02:27:07 <savask> *was
02:27:47 <mreh> zipWith (-) =<< drop 1 really messes with my head though
02:28:04 <mreh> that's the (-> e) Monad I suppose
02:28:15 <ion> mreh: http://heh.fi/haskell/functors/#function-instance
02:28:16 <mreh> ((->) e)
02:29:09 <mreh> ion, thanks
02:29:55 <ion> When the whole thing is applied to x, drop 1 gets applied to x and then zipWith (-) (drop 1 x) gets applied to x, resulting in zipWith (-) (drop 1 x) x
02:30:59 <ion> @type (=<<)
02:31:00 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
02:31:06 <ion> @djinn (a -> x -> b) -> (x -> a) -> x -> b
02:31:07 <lambdabot> f a b c = a (b c) c
02:31:33 <azaq23> savask: I mean, if you're understanding of what a vector is isn't more sophisticated than "these arrows as used in geometry", vector-space may be too theoretical or abstract for your purposes. Also, if you just want to do some heavy calculations with normal (x, y, z) (where x, y, z are real numbers) vectors
02:31:33 <azaq23> , there may be better packages which were implemented just for this purpose (for example, there may be vector package which uses CReal as a default for each component of a vector, but I don't know)
02:32:03 <savask> Ah.
02:58:37 <coppro> How do I find instance documentation. For instance, Set is a Monoid; how do I see the actual definition of mconcat? (I assume it's just union, but you never know)
02:59:33 <pacak> coppro, http://hackage.haskell.org/packages/archive/containers/latest/doc/html/src/Data-Set.html#Set
02:59:59 <pacak> coppro, just click on "source" link where constructor is defined.
03:02:10 <coppro> ah :/
03:02:13 <coppro> thanks
03:28:55 * hackagebot authenticate 0.9.2.1 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.9.2.1 (MichaelSnoyman)
03:39:07 <coppro> Okay, new fun question
03:39:57 <coppro> What is the preferred way to hack around the lack of dependent types? Ideally I want a constructor Foo x such that Foo 1 and Foo 2 are different types, but I know we don't have that
03:40:21 <Saizan> you can encode naturals at the type level
03:40:39 <coppro> Yeah, but that's pretty ugly
03:40:46 <Saizan> the simplest way is to have data Z; data S a
03:41:05 <coppro> This code is for human consumption
03:41:49 <Saizan> then wait until the type level naturals extension is merged in the main ghc?:)
03:42:23 <coppro> haha
03:42:53 <coppro> lack of type-safety won't kill me here
03:46:10 <Jetbeard> lovely haskell people: does anybody know of a good tutorial-style introduction to functional reactive programming?
03:46:21 <Jetbeard> i'm struggling to get my head around it
03:50:06 <Saizan> don't worry, the proponents are too
03:51:10 * hackagebot udbus 0.1 - Small DBus implementation  http://hackage.haskell.org/package/udbus-0.1 (VincentHanquez)
03:52:19 <Saizan> http://www.haskell.org/haskellwiki/Yampa <- yampa seems to have quite a few introductory resources though
03:53:07 <Jetbeard> oh nice, tyvm Saizan
03:53:15 <Jetbeard> though i hope this doesn't mean i have to go learn arrows :P
03:53:32 <coppro> okay, another question: easy way to check of all elements of a list are equal?
03:54:43 <twanvl> coppro:  all (==head xs) xs
03:55:04 <coppro> twanvl: thanks
03:55:12 <coppro> haven't had to do that one before, oddly
03:55:18 <Jetbeard> isn't Eq a => Eq [a] already defined?
03:55:54 <azaq23> Jetbeard: That proves only elementwise
03:56:00 <azaq23> > [1, 2] == [1, 2]
03:56:01 <lambdabot>   True
03:56:03 <Jetbeard> oh yeah, ignore me
03:56:12 <Jetbeard> i just woke up
03:56:54 <Jetbeard> (also, it's worth noting that twanvl's solution needs to be modified slightly for handling empty lists)
03:57:03 <rtharper> Jetbeard: it's okay, I was thinking exactly as you were
03:57:04 <Saizan> nope
03:57:18 <Saizan> > let xs = [] in all (== head xs) xs
03:57:18 <lambdabot>   True
03:57:24 <Jetbeard> oh yeah, ignore me
03:57:25 <rtharper> Jetbeard: I never thought someone would want to make sure all the elements of a list were the same...but I guess that makes sense? heh
03:57:25 <Jetbeard> i just woke up
03:57:33 <Jetbeard> i'm going to go get some coffee
03:57:36 <Jetbeard> and stop being so wrong
03:57:50 <coppro> rtharper: read up a bit; see if you can guess why
03:58:11 <rtharper> haha my logs don't go that high, I just signed in ;)
03:59:02 <rtharper> coppro: I'm not one of the IRC helpers thatis likely to tell you that something isn't "really what you want to do", though
03:59:12 * rtharper hates it when people do that.
04:03:21 <coppro> rtharper: It isn't what I want to do :P
04:03:36 <rtharper> coppro: haha, then why do you have to do it?
04:05:23 <coppro> rtharper: It's a sanity check on a list of values which ought to all have the same value for one sub-value, as a hack given that I can't enforce list homogeneity with dependent types
04:07:06 <azaq23> rtharper: It is necessary to at least state that a certain question smells fishy in certain situations. If someone asks for a heterogenous list type, asking why he precisely wants such a thing is better than recommending hlist. Or if someone asks for "eval" in dynamic languages and wants to do "eval '$x$i = ...'"
04:07:14 <cfricke> Hey folks. Can someone tell me, where I went wrong with this really simple test? I can see no error on my part but quickCheck can falsify prop_and immediately.
04:07:51 <cfricke> Hm, hang on, hpaste is hanging for me.
04:07:54 <rtharper> azaq23: Fine line, there ;) I find I offer the answer with a caveat
04:08:04 <rtharper> but answering a question with another question because you think you know better is rude
04:08:07 <coppro> rtharper: as a result of this, I will just assume it works out and randomly check to make sure that result is correct in this regard
04:08:08 <rtharper> and people do it in IRC channels all the time
04:08:20 <rtharper> coppro: ahh, I understand =)
04:09:22 <coppro> (for those wondering about the specific use case, I want to model grids on a torus. Obviously you shouldn't be able to mix coordinates from two different sizes of tori, but Haskell cannot express this)
04:09:37 <rtharper> coppro: *eyes glaze over*
04:09:47 <rtharper> coppro: anything to do with topological things completely escapes me
04:09:54 <coppro> rtharper: basically a wrap-around grid
04:09:54 <rtharper> despite being an otherwise extremely visual learner =p
04:10:07 <coppro> go off the top, come off the bottom,
04:10:22 <erus`> mod x height
04:10:24 <erus`> :D
04:10:33 <coppro> so really the size of the grid is a part of the type of a coordinate
04:11:00 <Jetbeard> unless, of course, you just stick to talking about grids on the unit square :)
04:11:20 <coppro> haha
04:12:20 <erus`> can someone point me to that BASIC monad please?
04:12:40 <coppro> what
04:12:42 <rtharper> lol there's a BASIC monad?
04:12:57 <erus`> yeah its like a BASIC dsl in haskell
04:12:58 <accel> there's a monad
04:13:04 <accel> that implements bASIC as a DSL
04:13:05 <accel> iirc
04:13:15 * hackagebot fquery 0.2.1.3 - Installed package query tool for Gentoo Linux  http://hackage.haskell.org/package/fquery-0.2.1.3 (SergeiTrofimovich)
04:13:20 <Jetbeard> some people have no bounds to their depravity
04:13:26 <accel> I think the correct way to ask said question would be.
04:13:39 <accel> Haskell sucks. QBasic is so much better. Can Haskell emulate Basic? No [Waits to be corrected.]
04:13:42 * Eliel wonders how many other languages could be implemented in haskell as monads.
04:13:55 <ion> @vixen Can Haskell emulate Basic?
04:13:55 <lambdabot> Ooh, functional programmers are so hot!
04:13:59 <sipa> answer: all
04:14:12 <Jetbeard> @faq Can Haskell emulate Basic?
04:14:12 <lambdabot> The answer is: Yes! Haskell can do that.
04:14:13 <ion> @faq Can Haskell correct the wrong bot command?
04:14:13 <lambdabot> The answer is: Yes! Haskell can do that.
04:14:16 * accel wonders if any useful software has been written within the BASIC monad
04:14:21 <sipa> just use an x86 emulator monad if necessary? :)
04:14:30 <accel> @faq Can Haskell create a problem Haskell can't solve?
04:14:30 <lambdabot> The answer is: Yes! Haskell can do that.
04:14:44 <ion> > text "P=NP?"
04:14:45 <lambdabot>   P=NP?
04:14:50 <Saizan> erus`: http://augustss.blogspot.com/2009/02/more-basic-not-that-anybody-should-care.html
04:14:55 <sipa> @faw Can Haskell solve that problem anyway?
04:14:55 <lambdabot> The answer is: Yes! Haskell can do that.
04:15:10 <Jetbeard> @faq Can Haskell kill off anybody who doubts the answers that lambdabot@faq gives?
04:15:10 <lambdabot> The answer is: Yes! Haskell can do that.
04:15:13 <ion> > let p = np in True
04:15:14 <lambdabot>   Not in scope: `np'
04:16:08 <Jetbeard> @faq My toaster toasts things slightly unevenly. What's up with that?
04:16:08 <lambdabot> The answer is: Yes! Haskell can do that.
04:16:14 <accel> @faq Can haskell give me ops?
04:16:15 <lambdabot> The answer is: Yes! Haskell can do that.
04:16:50 <Egbert9e9> hi, if i want a way to get keys pressed by the user while in commandline, what module do i want to use?
04:16:55 <erus`> @faq opengl
04:16:56 <lambdabot> The answer is: Yes! Haskell can do that.
04:17:01 <erus`> nope, liar
04:18:51 <Wild_Cat> @faq can Haskell help me fix my Visual Basic 5 application with an Access database backend that is going to take over Facebook in 2 months?
04:18:51 <lambdabot> The answer is: Yes! Haskell can do that.
04:18:56 <Wild_Cat> \m/
04:19:07 <Jetbeard> @faq Can Haskell implement Maxwell's Demon?
04:19:07 <lambdabot> The answer is: Yes! Haskell can do that.
04:19:10 <ion> Access is web scale
04:19:12 <siracusa> @faq Can Haskell also do things Haskell can't do?
04:19:13 <lambdabot> The answer is: Yes! Haskell can do that.
04:19:46 <ArnoVanLumig> Egbert9e9: getChar, take a look at http://www.haskell.org/tutorial/io.html
04:19:50 <Egbert9e9> ah
04:19:51 <Egbert9e9> thanks
04:20:32 <Egbert9e9> ArnoVanLumig: wait, no. getChar needs a return key pressing at the end
04:20:36 <Egbert9e9> or does it?
04:20:44 <Wild_Cat> ion: totally. Access is Enterprise-grade, after all :p
04:20:45 <Egbert9e9> doesn't
04:20:47 <ion> Depends on the buffering mode i assume.
04:21:08 <ion> Seems to work directly, yeah.
04:21:18 <Egbert9e9> getChar will do :)
04:21:24 <Wild_Cat> Enterprise Monad Beans. Rock on.
04:23:23 <ArnoVanLumig> Egbert9e9: Great. If you also want to detect presses of non-character keys (for instance control and alt) I don't know what to do
04:24:04 <erus`> i would love to build a website on vb 6 and access
04:24:25 <erus`> just to be hipster
04:24:47 <ion> “I stopped being hipster when it became cool”
04:25:02 <Egbert9e9> ArnoVanLumig: it's okay. i need the num keys
04:25:22 <siracusa> Egbert9e9: Also note, it won't work on (all) Windows systems
04:25:31 <Egbert9e9> O_o
04:25:41 <Egbert9e9> how come?
04:25:45 <erus`> damn unix elitists
04:25:56 <Wild_Cat> my very first internship was working on a PHP application with Borland Interbase as a DB backend, that had to communicate with a comms server written in VB5 + Access.
04:26:15 <Wild_Cat> there were cron jobs written in PHP that transferred the data between the two databases.
04:26:35 <siracusa> Egbert9e9: I don't know the exact reason but there were buffering issues for a long time, I'm not sure you even did get fixed.
04:26:38 <Wild_Cat> the scars in my brain have yet to fully heal.
04:26:52 <Egbert9e9> that sux :-/
04:27:56 <benmachine> siracusa: are you sure that hasn't been fixed by now?
04:28:32 <siracusa> benmachine: No
04:28:57 <cfricke> Hm, can someone please tell my, why quickCheck can falsify prop_and in this http://hpaste.org/49440 when I use the Prelude (&&) but when I write my own version (which is supposedly the same as in the Prelude) it passes, please?
04:29:44 <siracusa> benmachine: Looks like it's not: http://hackage.haskell.org/trac/ghc/ticket/2189
04:30:08 <benmachine> ah ok
04:30:48 <ion> cfricke: I think your version of (&&) is missing from the paste.
04:31:12 <cfricke> ion: Yep, one moment.
04:31:17 * hackagebot hweblib 0.3 - Haskell Web Library  http://hackage.haskell.org/package/hweblib-0.3 (AycanIrican)
04:31:50 <cfricke> ion: http://hpaste.org/49441
04:37:29 <anandjeyahar> why does :t  (map sqrt [1..])
04:37:38 <anandjeyahar> give me (map sqrt [1..]) :: (Floating b, Enum b) => [b]
04:37:40 <Jetbeard> :t (map sqrt [1..])
04:37:41 <lambdabot> forall a. (Floating a, Enum a) => [a]
04:37:55 <anandjeyahar> i understand Floating because of sqrt
04:37:58 <anandjeyahar> but Enum??
04:37:59 <Jetbeard> :t sqrt
04:37:59 <lambdabot> forall a. (Floating a) => a -> a
04:38:07 <Jetbeard> :t [1..]
04:38:08 <lambdabot> forall t. (Num t, Enum t) => [t]
04:38:13 <ion> creaux: Try adding parentheses around (x && y).
04:38:34 <identity_> :t enumTo
04:38:34 <savask> anandjeyahar: Maybe because it should be Enum to know to know next elements of the list?
04:38:34 <lambdabot> Not in scope: `enumTo'
04:38:41 <identity_> yeah
04:39:15 <ion> Sorry, s/creaux/cfricke/
04:39:18 <anandjeyahar> savask: but :t map is happy without Enum
04:39:28 <savask> anandjeyahar: [1..] needs it
04:40:06 <anandjeyahar> savask: so if i use [1,2,3] it won't need Enum??
04:40:12 <savask> Yes.
04:40:24 <Jetbeard> :t sqrt (1 :: (Enum t, Floating t) => t)
04:40:24 <lambdabot> forall t. (Enum t, Floating t) => t
04:40:27 <anandjeyahar> thanks that's great
04:40:29 <ion> The Enum instance of Float is nasty.
04:40:47 <identity_> :succ (1.1 :: Float)
04:40:49 <cfricke> ion: Still fails for the Prelude (&&). I find that fascinating.
04:40:51 <identity_> eh
04:40:55 <identity_> > succ (1.1 :: Float)
04:40:55 <lambdabot>   2.1
04:40:57 <identity_> why do I keep doing this
04:41:04 <Jetbeard> :t succ (1.1 :: Float)
04:41:04 <lambdabot> Float
04:41:34 <ion> > [1.9 .. 2]
04:41:35 <lambdabot>   [1.9]
04:41:52 <Jetbeard> > [1.9,2.0..2.3]
04:41:52 <lambdabot>   [1.9,2.0,2.1,2.2,2.3000000000000003]
04:41:54 <ion> > [1.1 .. 2]
04:41:55 <lambdabot>   [1.1,2.1]
04:42:24 <Jetbeard> how about we all just stop using floating point numbers
04:42:32 <cfricke> ion: Ha! I think I got it. Lemme check.
04:43:03 <ion> cfricke: I’d use pattern matching in the properties, too, instead of == and nested ifs.
04:44:03 <cfricke> ion: Yeah, I thought it's pretty ugly. Slowly getting the ropes of Haskell.
04:45:55 <ion> jetbeard: I take it you’ve got a better alternative in mind?
04:46:04 <erus`> are constructors just functions?
04:46:30 <cfricke> ion: Hm, works now. But I don't quite understand why.
04:46:36 <ion> Data constructors are functions, but they can additionally be used in patterns.
04:46:48 <ion> Well, type constructors are type-level functions, too.
04:52:06 <cfricke> ion: Now I do. Thanks! Haha
04:52:18 <Jetbeard> ion: fixed-point numbers :)
04:52:47 <Jetbeard> seriously, i do not understand why floating-point numbers are used everywhere when fixed-point numbers would often be more appropriate
04:53:59 <Tomsik> Probably because there's no fixed-point /types/ in most languages
04:54:07 <Tomsik> nor operations on them are built-in
04:55:01 <Jetbeard> fixed-point arithmetic -- between two numbers of the same significand -- is just integer arithmetic
04:55:17 <ion> Floats have constant-ish accuracy at a great range of scale, as opposed to fixed-point numbers.
04:55:31 <ion> s/accuracy/relative accuracy/
04:55:40 <Jetbeard> yeah, i was going to say
04:55:51 <Jetbeard> floats have relative accuracy, fixeds have accuracy
04:56:10 <Tomsik> Jetbeard: How about multiplication?
04:56:19 <Tomsik> That's not just multiplicating two integers
04:56:24 <Tomsik> You need to normalize too
04:56:25 <Jetbeard> integer arithmetic and then some shifts, iirc
04:56:30 <Jetbeard> just one shift in fact
04:56:48 <Jetbeard> ion: however, you'll find that floats are used, for example, to represent the player's position in a 3D game
04:57:06 <ion> Both have their use cases.
04:57:10 <Tomsik> That deserves a Num instance of its own and built-in support in languages, but doesn't get it
04:57:14 <Tomsik> and is tedious to use
04:57:20 <Tomsik> (as a result)
04:57:24 <Jetbeard> yes, i agree, ion: but only floats ever get used
04:57:27 <Egbert9e9> how much cheaper is veggie protein compared to chicken protein?
04:57:33 <Egbert9e9> uh, wrong channel
04:57:42 <Egbert9e9> wrong network, even
04:57:46 <ion> @vixen How much cheaper is veggie protein compared to chicken protein?
04:57:46 <lambdabot> who's to say?
04:57:47 <Tomsik> Egbert9e9: Beans, nuts
04:58:01 <Tomsik> That's dirt-cheap, but you won't get some required proteins that way
04:58:02 <Egbert9e9> Tomsik: yeah, that's what i'm talking about
04:58:20 <Egbert9e9> can i really talk about OT stuff sometimes in here?
04:58:34 <azaq23> I think chickens also lack some specific proteins, causing the same effect as rabbit starvation or what it was called
04:58:41 <azaq23> not sure though
04:58:44 <Egbert9e9> Tomsik: biochem book said i need to eat varried seeds
04:58:57 <Egbert9e9> it's not proteins that they lack, it's aminoacid
04:59:05 <Tomsik> azaq23: I thought the problem with rabbits is that they've got too many proteins and not enough fat in their meat
04:59:16 <Tomsik> and your brain gets poisoned by the excess proteins
04:59:37 <Jetbeard> Egbert9e9: meat subtitute products such as Quorn tend to be quite high in protein
04:59:39 <Tomsik> Egbert9e9: aminoacids you get from proteins and vice versa
04:59:48 <Egbert9e9> Tomsik: i really want to know more about the protein poisoning
05:00:14 <Saizan> OT stuff should go in #haskell-blah :)
05:00:36 <Egbert9e9> Jetbeard: meat subtitute products are insanely pricey due to health aware hippie yuppies
05:00:47 <Egbert9e9> heath/eco
05:00:51 <Jetbeard> Quorn is pricey? Did not know that.
05:01:01 <Jetbeard> My parents are vegetarian; I used to be. We regularly have Quorn at home.
05:01:12 <Tomsik> http://en.wikipedia.org/wiki/Rabbit_starvation
05:01:28 <Egbert9e9> Jetbeard: okay, maybe i'm wrong, but generally speaking, health / environmental food is much more pricier
05:02:27 <Egbert9e9> i'll read about quorn and stuff you've mentioned, thanks!
05:02:30 <mreh> you die of malnutrition
05:02:50 <Jetbeard> s/malnutrition/old age/ ;)
05:03:35 <Egbert9e9> myco! wooo! yeast extract
05:03:52 <mreh> anyway, how can i traverse a list and apply an action post hoc, like when i've looked at the next value?
05:03:53 <Egbert9e9> i've heard the ausies are spets at that
05:04:18 <mreh> marmite?
05:04:21 <benmachine> mreh: that sounds like an odd thing to do
05:04:50 <benmachine> mreh: would it help if you zipped the list with the tail, and then traversed a list of (thiselement, nextelement)?
05:05:10 <mreh> benmachine, yes, but i forgot to mention, it's not a list, it's a tree
05:05:18 <benmachine> oh
05:05:23 <benmachine> hmm
05:05:24 <mreh> because I wanted to represent structure
05:05:32 * benmachine vaguely wonders if trees are comonads
05:05:34 <mreh> they're bars in a melody
05:05:57 <benmachine> what's the tree structure exactly?
05:06:33 <mreh> like [[a]]
05:06:39 <mreh> what's the word I'm looking for
05:06:48 <benmachine> hmm. not a comonad because it can be empty :(
05:07:07 <benmachine> maybe that's irrelevant
05:07:33 <mreh> i need to traverse (preserve structure) but the outcome depends on the next element
05:07:40 <mreh> maybe a tree wasn't the best representation
05:07:42 <benmachine> I'm basically wondering if there's a function Tree a -> Tree (Tree a) so that each value is replaced with the subtree at that point
05:08:09 <mreh> and concatmap?
05:08:19 <benmachine> um
05:08:23 <benmachine> sort of backwards from concatmap
05:08:38 <benmachine> you end up with something like (Tree a -> b) -> Tree a -> Tree b
05:08:53 <benmachine> take a function which takes the "future" of the traversal and produces a value
05:09:05 <wli> What the Hell. The bluetooth headset was charging all night and now it's not working.
05:09:13 <benmachine> and then traverse the structure applying the function at every point
05:09:38 <benmachine> for reference, the [a] -> [[a]] function that's analogous is tails, I think
05:09:38 <Jetbeard> mreh: so each bar has type [a] and then the song has type [[a]]?
05:09:53 <Jetbeard> wli: too much electricity made it sad :(
05:09:57 <mreh> Jetbeard, it's analogous to that
05:10:11 <mreh> i'm using sections and staves
05:10:35 <mreh> it preserves the structure of the song, but it is in all effect a list
05:11:45 <benmachine> oh
05:11:49 <benmachine> tails it, then :)
05:12:20 <benmachine> or zip it with its tail as originally discussed
05:12:34 <benmachine> (but a bit more cleverly to preserve the extra structure)
05:12:45 <ion> mreh: Data.Foldable.toList perhaps.
05:13:00 <Saizan> benmachine: http://patternsinfp.wordpress.com/2011/05/05/horners-rule/ <- see "Tail segments, datatype-generically"
05:13:24 <mreh> and then traverse with State
05:13:37 <mreh> or zip
05:13:47 <mreh> is zip derived from a typeclass?
05:13:52 <Jetbeard> :t zip
05:13:53 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
05:13:59 <mreh> i know :)
05:15:12 <Jetbeard> http://hackage.haskell.org/packages/archive/category-extras/latest/doc/html/Control-Functor-Zip.html
05:16:57 <mreh> mmm, i'm enjoying this, it kills me that this doesn't really make me anymore employable... unless i change my career direction
05:17:19 <benmachine> it makes you more intelligent, and people like hiring intelligent people :P
05:17:42 <mreh> "people" consider programmers to be replaceable units
05:18:11 <mreh> he's compiled the new kernel already?!
05:18:14 <companion_cube> programmers consider people to be replacable units
05:18:33 <ion> replaceable units consider programmers to be people
05:19:19 <companion_cube> consider programmers to be unit replaceable people
05:20:32 <anandj> companion_cube is a nlp bot??
05:20:40 <ion> We all are.
05:21:05 <companion_cube> :)
05:21:10 <benmachine> to consider unit programmers, be replaceable people
05:21:42 <anandj> Phew....
05:21:44 <anandj> :-)
05:25:36 <ion> > (map unwords . permutations . words) "people consider programmers to be replaceable units" !! 42
05:25:37 <lambdabot>   "consider to be programmers people replaceable units"
05:26:13 <knoc> > (map unwords . permutations . words) "people consider programmers to be replaceable  units" ! 23
05:26:14 <lambdabot>   Couldn't match expected type `GHC.Arr.Array i e'
05:26:14 <lambdabot>         against inferred t...
05:26:23 <knoc> > (map unwords . permutations . words) "people consider programmers to be replaceable  units" !! 23
05:26:25 <lambdabot>   "programmers people to consider be replaceable units"
05:26:43 <erus`> haha
05:28:21 <anandj> if i say sqrtSums :: a -> Int
05:28:41 <anandj> does it mean a can be of any type?
05:29:03 <ion> Yes, therefore you can’t do much with it.
05:31:26 <ion> > (map unwords . permutations . words) "people consider programmers to be replaceable units" !! 4005
05:31:27 <lambdabot>   "consider replaceable people units to be programmers"
05:31:30 <anandj> ion: can't do much? i thought i can do everything
05:31:53 <anandj> infact i realize the compiler picks the first inferred type and sticks to it
05:32:18 <anandj> i was using multiple types and it complains..:(
05:33:53 <ion> anandj: I give you a value “x :: a”. What do you suppose you might do with it? x + y? Sorry, it was a string and has no + operator. length x? Sorry, it was an IO action and you can’t apply length to it.
05:34:48 <ion> If you restrict the type the function accepts to, say, Num a => a, you can apply any Num functions to the value because you know (and the compiler knows) it must be a Num.
05:35:18 <brence> when compiling with GHC using the -S flag the produced assembly file does not clearly show the labels corresponding to each function, unlike GCC
05:35:20 <anandj> ion: my rant is not that. I did sqrtSums x = length (takeWhile (<x)(scanl1 (+) (map sqrt [1..]))) +1
05:35:27 <brence> is there a way to make the output more clear ?
05:36:00 <ion> :t \x -> length (takeWhile (<x) (scanl1 (+) (map sqrt [1..]))) + 1
05:36:01 <lambdabot> forall a. (Ord a, Floating a, Enum a) => a -> Int
05:36:05 <anandj> i spent about 30 mins till i figured out i have to ad sqrtSums :: (Ord a,Floating a, Enum a) => a -> Int
05:36:33 <anandj> yeah since am new haskell i did that :t with step by step
05:36:40 <anandj> starting with innermost expression
05:36:42 <anandj> :-)
05:37:18 <brence> any hints about the assembly output thing?
05:38:48 <ion> If you want to pass x to (<), x must be an Ord, therefore your function must not accept a non-Ord x.
05:39:16 <erus`> @hoogle permutations
05:39:17 <lambdabot> Data.List permutations :: [a] -> [[a]]
05:41:22 <identity_> > permutations [1..3]
05:41:23 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
05:42:11 <erus`> > (map unwords . permutations . words) "people consider programmers to be replaceable units" !! 2
05:42:13 <lambdabot>   "programmers consider people to be replaceable units"
05:42:29 <identity_> lol.
05:44:29 <erus`> how do i monad?
05:44:48 <erus`> how i monad formed?
05:56:27 * hackagebot authenticate 0.9.2.2 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.9.2.2 (MichaelSnoyman)
06:00:59 <zmv> @protontorpedo
06:00:59 <lambdabot> evaluation seems ideal for banks who want to know global balances etc.
06:22:16 <kizzx2> hi all
06:23:37 <kizzx2> i wonder how often people actually need to write their own monads? i'm a newb so just looking for real life stories, is it like it's quite common or like the "bread and butter ones" (Reader, State, Cont, Writer and friends) already fulfill most needs?
06:24:13 <Botje> kizzx2: in two years of mostly-solving-project-euler, I haven't needed a custom monad yet.
06:25:07 <Saizan> kizzx2: most of the time you can compose monad transformers to get what you need
06:25:46 <kizzx2> thanks the for input :)
06:26:15 <kizzx2> i'm just writing my first small exercise (graphic processing)
06:26:47 <kizzx2> in many functions, i need to take inputs of pixels in a specific order (RGBA, for example)
06:26:53 <Entroacceptor> kizzx2: you could invent a monad without realizing it ;)
06:26:54 <Codex_> I think it depends on programming style
06:27:09 <Botje> in fact, I need to come up with a monad to implement for an exam in haskell
06:27:16 <Botje> not sure what i'm going to ask this time
06:27:43 <kizzx2> Entroacceptor: thanks :P i'm guessing most of the time when "case of" march off the right margin would be a good time to invent my own ?
06:28:06 <brence> when compiling with GHC using the -S flag the produced assembly file does not clearly show the labels corresponding to each function, unlike GCC
06:28:11 <brence> is there a way to make the output more clear ?
06:29:35 <identity_> So I'm running a happstack server in the same dir as a stylesheet and linking to it in the webpage, but it is not getting applied and viewing it gives me an empty stylesheet. Does the application not run from the current directory?
06:29:40 <norm2782> when dealing with the FFI, can I just replace a regular Ptr with a ForeignPtr if I know that I want one? or is it recommended to wrap the Ptr in a newtype and wrap the newtype n a ForeignPtr, as is suggested here: http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html#id655309
06:30:42 <Saizan> identity_: maybe you need some additional code to serve static files?
06:31:10 <brence> and apparently -S -O3 produces better labelled assembly code than -S alone
06:31:22 <identity_> Saizan: hmm
06:31:44 <Saizan> sounds like a question for #happs if it's alive
06:39:47 <deech> Hi all, as a matter of style when is it better to manually indent do blocks with do {...;...}?
06:40:55 <identity_> As a matter of style you can do whatever you like as long as it matches the indentation rules, that's why it's called 'style'
06:40:58 <identity_> or 'personal style'
06:45:52 <deech> identity_: Fair enough. Only I don't have a personal style so I was looking for guidelines.
06:46:25 <Twey> deech: You mean, using braces and semicolons?
06:46:32 <deech> Twey: Yup
06:46:41 <Twey> deech: Never
06:46:44 <Twey> ☺
06:47:15 <Twey> I'm guilty of occasionally using a one-line do-block to save me a couple of brackets, but you don't need the braces for that
06:47:57 <deech> Twey: I guess the reasoning is that it makes it harder to read?
06:50:09 <Twey> deech: It's just unnecessary — if you're formatting your code nicely anyway then the layout will take care of it for you
06:50:20 <Twey> If you're not, then you should be :þ
06:55:07 <Tomsik> There's problems with text editors
06:55:17 <Tomsik> that do haskell-incompatible tabs-widths
06:55:57 <Tomsik> (Honestly, that's just a huge bleurgh for Haskell, you should be ahamed of yourself)
06:59:41 <linduxed> i'm trying to write a transpose function, and so far i've written this http://paste.pocoo.org/show/445405/
07:00:11 <linduxed> however when i compile it and run it on a sample text file, i get InteractWith: Prelude.head: empty list
07:00:47 <linduxed> so two questions, is that function on the right track to doing what it should, and what can i do about the empty list problem?
07:02:04 <sipa> linduxed: what if the first argument to transpose is [[]] ?
07:02:15 <sipa> (map head) will fail on that
07:03:46 <EvanR> > transpose []
07:03:47 <lambdabot>   []
07:03:50 <EvanR> > transpose [[]]
07:03:51 <lambdabot>   []
07:03:54 <EvanR> > transpose [[],[]]
07:03:55 <lambdabot>   []
07:09:57 <linduxed> sipa: ok so should i safeguard with something like "safeHead" which returns a [] on []?
07:18:39 <linduxed> ok this makes me massively confused
07:19:02 <linduxed> http://paste.pocoo.org/show/445418/ - for some reason i get InteractWith.hs:11:31: Empty 'do' construct
07:19:35 <linduxed> and if i add two spaces to the entire block under do, it works
07:19:47 <linduxed> makes _zero_ sense to me
07:19:51 <linduxed> it's indented
07:21:08 <identity_> linduxed: it has to line up with "mainWith"
07:21:09 <identity_> iirc
07:21:21 <identity_> at any rate, that indentation doesn't seem too consistent
07:22:25 <hpc> @hoogle CReal
07:22:25 <lambdabot> No results found
07:22:27 <identity_> linduxed: http://paste.pocoo.org/show/445420/ that's how I'd do it
07:22:41 <Botje> linduxed: args <- and everything under it should be indented at least to the same level as mainWith
07:23:36 <identity_> linduxed: https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md I really like this guide on indenting haskell
07:23:39 <identity_> most of it, anyway
07:25:32 <EvanR> linduxed: you can use { } and ; instead
07:25:45 <EvanR> and most people will make fun of you. but you dont have to worry about identation
07:27:11 <identity_> The constant ridicule will however destroy your sense of self-worth and eventually drive you to suicide
07:27:15 <identity_> but it's your choice
07:29:21 <EvanR> i guess { } ; is kind of like training wheels ;)
07:29:29 <EvanR> for C family refugees
07:30:21 <aninhumer> Also useful to throw in when you know the indentation was the problem, but you just want to test something
07:31:19 <aninhumer> I still need to work out how to get vim to do this stuff automatically...
07:34:14 <linduxed> EvanR: oh but i don't like that, i just moved up the "where" to the "main =" line
07:34:20 <linduxed> that did the trick
07:34:38 <linduxed> but i'm still none the wiser as to how to make this transpose function work
07:39:08 <Jetbeard> <identity_> https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
07:39:24 <Jetbeard> i like the way guides like this list spaces for indentation as one of their first points
07:39:34 <Jetbeard> so i can disregard it without having to read any further
07:39:38 * hackagebot system-fileio 0.3.1 - High-level filesystem interaction  http://hackage.haskell.org/package/system-fileio-0.3.1 (JohnMillikin)
07:44:26 <aninhumer> Jetbeard: Surely aligning things, as is common in Haskell, relies on space indentation?
07:44:45 <Jetbeard> tabs for indentation, spaces for alignment
07:44:57 <EvanR> no one uses tabs
07:45:08 <EvanR> do not mix spaces and tabs, use one or the other
07:45:16 <EvanR> i.e. spaces
07:45:31 <Jetbeard> "do not mix spaces and tabs"? why not?
07:45:40 <sipa> because you can't see the difference
07:45:43 <sipa> and the compiler does
07:45:45 <EvanR> you will confuse people who dont have the same text editor as you
07:46:04 <Jetbeard> ach, i forgot about that sipa
07:46:18 <Jetbeard> EvanR: tabs for indentation, spaces for alignment gives you nice indentation across all tab sizes
07:46:20 <EvanR> sipa: is space==tab from compiler perspective?
07:46:34 <sipa> EvanR: no
07:46:39 <monadic> EvanR: And you will confuse people who have the same text editor but configure it differently...
07:46:52 <EvanR> monadic: yes, generalized notion of 'different text editor' ;)
07:47:00 <hpc> the general rule is never use tabs in haskell
07:47:21 * finnrobi doesn't use tabs in any language
07:47:33 <finnrobi> except makefiles I guess
07:47:45 <hpc> i use tabs in java, but only by configuring eclipse to use them
07:47:45 <Jetbeard> i guess if the compiler differentiates between tabs and spaces then spaces for indentation is okay
07:48:21 <finnrobi> hpc: all the projects I code for have a "spaces-only" policy :-)
07:48:29 <finnrobi> even the java ones
07:49:02 * hvr has enabled git hooks to reject commits not satisfiying git's whitespace '--check'
07:49:14 <hvr> works like a charm ...
07:49:56 <aninhumer> The other argument is avoiding accidental diffing of course, not that you shouldn't check your diffs
07:50:03 <monadic> Assuming everyone uses the same IDE is evil :\
07:50:19 <hvr> monadic: indeed... that's why the server-side hooks are great :)
07:50:36 <hvr> some use eclipse, some emacs, some vi, some intellij
07:50:57 <monadic> hvr: I hate the projects who expect you to have an IDE to even build the thing
07:50:57 <hvr> but everyone has to teach their IDE the whitespace policy
07:51:03 <hvr> monadic: same here :)
07:51:19 <hvr> but I don't impose anyone which editor to use
07:51:39 <hvr> just to follow the same policy
07:51:47 <hvr> for the checked in content
07:51:51 <monadic> hvr: I don't even have one editor, I can use vi and emacs, whichever I feel is more suited to the job
07:51:58 <monadic> hvr: Although mostly I use vi
07:52:14 <hvr> I'm fluently in both, emacs and vim myself :)
07:52:35 <hvr> (but eclipse I hate)
07:55:34 <monadic> hvr: When I say "project requires IDE" I pretty much mean "project requires Eclipse" :)
07:56:54 <jonkri> how can i convert an Enumeratee to an Iteratee? http://hackage.haskell.org/packages/archive/enumerator/0.4.13.1/doc/html/Data-Enumerator.html#t:Enumeratee
08:06:40 <gwern> > 12650/175
08:06:41 <lambdabot>   72.28571428571429
08:10:57 <Egbert9e9> what's going on in here? http://hpaste.org/49444
08:11:06 <Egbert9e9> sometimes it runs sometimes it doesn't
08:11:15 <Egbert9e9> seems like a huge spaghetti
08:13:33 <Egbert9e9> zahe.hs: Prelude.(!!): index too large
08:13:56 <Egbert9e9> oh
08:13:59 <Egbert9e9> right
08:14:03 <hpc> :P
08:14:23 <Tomsik> Are there GHC optimisations that can change big O behavior of programs?
08:14:24 <hpc> http://en.wikipedia.org/wiki/Rubber_duck_debugging always glad to help
08:14:47 <Egbert9e9> where do i buy such a rubber ducck
08:14:48 <hpc> Tomsik: probably, for some cases
08:14:59 <hpc> don't assume ghc is going to be magic though, and code things fast yourself
08:15:10 <Tomsik> Yeah, but I'm just wondering
08:15:48 <Tomsik> and it would be interesting to see a piece of code that can be changed dramatically by optimisations
08:16:16 <Egbert9e9> > [1] !! 0
08:16:16 <lambdabot>   1
08:16:35 <sipa> it can optimize non-terminating programs into programs that output "<<loop>>" and quit
08:16:45 <sipa> that's an optimization of infinity% !
08:17:01 <Tomsik> But it's not particularly impressive
08:17:04 <hpc> heh
08:17:31 <hpc> @remember sipa it can optimize non-terminating programs into programs that output "<<loop>>" and quit; that's an optimization of infinity% !
08:17:31 <lambdabot> I will remember.
08:18:04 <danharaj> does a Ptr created with new get freed when it gets GC'd?
08:18:05 <Egbert9e9> hpc: okay, thanks! stupid random index
08:18:43 <sipa> actually, i'm not sure whether that's the compiler or the runtime library
08:19:03 <Choko> it seems like using a state monad kills performance when my code relies on lazy lists. It seems the whole list is evaluated even that i'm only interested in testing it for emptyness.
08:19:23 <Egbert9e9> hpc: do you have any comments on the weirdness of the code? like, how can i make it haskellier?
08:19:47 <kizzx2> Choko: you can prove whether the whole list is "really" evaluated by sticking undefined at hte end of the list
08:20:26 <Choko> thanks kizzx2
08:20:31 <kizzx2> Choko: length for list is also O(n)
08:21:01 <kizzx2> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:length
08:21:36 <Choko> yes but I'm testing with  filterM (\g -> liftM ([] == ) (wiresWithGate g))
08:22:23 <Choko> but and wiresWithGate takes 71% of time and allocations
08:23:45 <Tomsik> > [] == [1..]
08:23:45 <lambdabot>   False
08:23:59 <kizzx2> > null [1..]
08:24:00 <lambdabot>   False
08:24:13 <Tomsik> > liftM ([] ==)  [[1..]]
08:24:14 <lambdabot>   [False]
08:24:16 <Tomsik> hm
08:24:26 <yitz> > 100 `elem` [1..]
08:24:27 <lambdabot>   True
08:24:57 <Tomsik> > 10000000 `elem` [1..]
08:24:58 <lambdabot>   True
08:25:01 <Tomsik> > 10000000000 `elem` [1..]
08:25:05 <lambdabot>   mueval-core: Time limit exceeded
08:25:48 <chrisdone> Cale: haha, i just saw your php paste: http://hpaste.org/49429 it reminds me of complaints this year in work's dev channel: http://hpaste.org/raw/49445 needless to say we have animosity towards php >_>
08:25:49 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
08:27:10 <jonkri> lambdabot rules
08:28:27 <chrisdone> sounds like a good t-shirt: ‘lambdabot evals’
08:30:57 <yitz> > null [()| s<-[5..], n<-[2..s-3], x<-[1..s-n-2], y<-[1..s-n-x-1], let z=s-n-x-y, x^n+y^n==z^n]
08:30:57 <lambdabot>   False
08:31:39 <yitz> > null [()| s<-[6..], n<-[3..s-3], x<-[1..s-n-2], y<-[1..s-n-x-1], let z=s-n-x-y, x^n+y^n==z^n]
08:31:43 <lambdabot>   mueval-core: Time limit exceeded
08:31:51 <sipa> evil you
08:32:25 <hpc> whoa
08:32:35 <yitz> @vixen is fermat's last theorem true?
08:32:37 <lambdabot> isn't it obvious?
08:32:46 <yitz> see? lambdabot can actually do it.
08:37:39 <yitz> why are the titles on hpaste.org in klingon now?
08:38:00 <benmachine> what
08:38:26 <copumpkin> because people spam it a lot
08:38:26 <yitz> oh i guess it's just that one post in php
08:38:48 <yitz> http://hpaste.org/49429
08:38:50 <chrisdone> copumpkin: not on my watch! che vietate!
08:38:57 <copumpkin> chrisdone: lol
08:39:03 <copumpkin> there are "dox" on someone on the front page there ;)
08:39:53 <chrisdone> ah, the little blighter's at it again
08:40:09 <copumpkin> it's an annoying practice
08:41:28 * chrisdone writes that spammer's name in his Death Note and throws a pear to his shinigami (yeah i saw that film recently)
08:42:47 <danharaj_> how do you write unicode symbols in strings?
08:43:01 <chrisdone> > "\x1234"
08:43:02 <lambdabot>   "\4660"
08:43:41 <siracusa> > text "\x1234"
08:43:42 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
08:44:42 <kmc> danharaj_, you just do ;P
08:44:49 <kmc> Haskell source is always UTF-8 encoded, iirc
08:45:07 <danharaj_> kmc: fair enough
08:45:31 <danharaj> So I got k-lined last night for using @quote too quickly. It was pretty amusing.
08:45:34 <danharaj> Also slightly embarassing.
08:45:38 <kmc> haha
08:45:42 <kmc> well played
08:52:13 <danharaj> so I have come to the always-wonderful crossroads of writing a library wrapper.
08:52:29 <danharaj> Do I only expose the `95% use case` interface?
08:52:30 <kmc> me too!
08:52:43 <danharaj> Or do I expose the 5% obscure API that no one has ever been recorded to use ever.
08:52:56 <danharaj> For the sake of that *one* user three years from now who needs it.
08:53:22 <kmc> how much effort?
08:53:46 <kmc> danharaj, you have multiple layers, right?  it's reasonable to expose it on low layers and not higher
08:53:56 <arw_> danharaj: don't. that one user of the 5% will write 95% of the annoying bugreports about weird stuff nobody else will care about
08:53:56 <kmc> as long as you expose the stuff needed to plug it into those layers
08:55:01 <danharaj> kmc: There's two layers right now, the raw c binding, and the pure wrapper. I have to expose everything at the pure wrapper level if they want a pure interface.
08:55:29 <kmc> where should i go on freenode to ask questions about software licensing?
08:55:37 <danharaj> #canofworms
08:55:53 <hpc> lol
08:55:55 <companion_cube> #oracle
08:56:00 <kmc> snap
08:56:05 <danharaj> told
09:06:03 <Choko> > or []
09:06:04 <lambdabot>   False
09:06:11 <Choko> > and []
09:06:12 <lambdabot>   True
09:06:47 <Choko> is it consistent?
09:07:02 <Jetbeard> Choko: yes
09:07:16 <Jetbeard> or (x:xs) = x || (or xs)
09:07:31 <Jetbeard> wouldn't hold if (or []) were True
09:08:09 <Jetbeard> (or rather, it would, it's just that everything would evaluate to True)
09:08:18 <kmc> > any (const False) []
09:08:19 <lambdabot>   False
09:08:24 <hpc> incidentally, (or) and (and) are two different definitions of mconcat
09:08:26 <kmc> > all (const False) []
09:08:27 <lambdabot>   True
09:08:58 <kmc> conceptually, "any" is false because there's no example and "all" is true because there's no counterexample
09:09:30 <kmc> you also want laws like «or = not . and . map not»
09:10:00 <kmc> de morgan's laws
09:17:58 <jonkri> can anyone see how can i convert an Enumeratee to an Iteratee? http://hackage.haskell.org/packages/archive/enumerator/0.4.13.1/doc/html/Data-Enumerator.html#t:Enumeratee
09:24:09 <Egbert9e9> how do i track time?
09:24:20 <frode> Newbie question; giving simpleMail a Data.Text.Text makes it complain about expecting Data.Text.Lazy.Internal.Text. Any clues? http://hpaste.org/49447
09:24:23 <Egbert9e9> System.Time?
09:24:42 <Egbert9e9> heh, of course there's a System.Time
09:25:03 <kmc> frode, look at Data.Text.Lazy
09:25:14 <kmc> it's implementing a different type from Data.Text
09:27:31 <frode> kmc: Oh. Many thanks!
09:55:59 <Matt040804> I'm trying to understand an example from Real World Haskell: http://hpaste.org/49449
09:56:20 <Matt040804> What is the purpose of (ord x .&. 0xff)?
09:56:30 <Matt040804> Won't that just give x?
09:56:38 <dmwit> No, it clips the char to the 0-255 range.
09:56:41 <kmc> no, Char is a Unicode codepoint
09:56:43 <dmwit> Char is a Unicode codepoint.
09:56:51 <kmc> this really should be using a byte type to begin with
09:56:57 <kmc> e.g. ByteString or [Word8]
09:57:08 <Matt040804> Oh, I see, that makes sense
09:57:12 <kmc> this 40-year-old attitude "chars are bytes and everyone should speak English" really needs to end
09:57:21 <kmc> but i'm sure the RWH authors have good reasons
09:57:31 <Matt040804> kmc: I think it's just a toy example
09:57:31 <kmc> they are not exactly ignorant of ByteString ;)
09:57:38 <dmwit> lol
09:57:45 <dmwit> That is some understatement.
09:58:05 <Botje> actually, it looks like this is computing a checksum
09:58:14 <Matt040804> Yeah, it is
09:58:44 <hvr> hrm... 'ord' seems a bit redundant btw... given that Char is an instance of Enum
09:58:46 <kmc> Matt040804, also, you need 'ord' because you want to do math on it and Char is not a numeric type
09:58:58 <kmc> hvr, it is, 'tis just a type specialization of fromEnum
09:58:59 <Matt040804> That part made sense to me
09:59:02 <kmc> > fromEnum '☭'
09:59:03 <lambdabot>   9773
09:59:10 <Matt040804> I'm coming from Python
09:59:19 <Botje> then Char is fine, given that it also stuffs the MSB into b
09:59:35 <kmc> does it Botje?
09:59:37 <kmc> it shifts by 16 not 8
09:59:46 <kmc> maybe i'm missing something
10:00:04 <Botje> hmm, wait
10:00:11 <Botje> I thought it was taking x into b somehow, but it's not
10:00:11 <Botje> boo!
10:00:47 <kmc> the point is that if you want to do byte IO and operate on bytes you should do byte IO and operate on bytes
10:00:58 <kmc> reading Chars and then treating them as bytes is common but very wrong
10:01:00 <Botje> yeah, i see now
10:01:20 <Matt040804> kmc: maybe, but that would be quite confusing for me to tackle at this point in the book
10:01:25 <EvanR> characters == bytes
10:01:28 <EvanR> makes total sense
10:01:30 <Matt040804> Just understanding the code as is, is a challenge enough
10:01:42 <hvr> Matt040804: btw, even Python has a distinction between the 'str' and the 'bytes' type
10:01:51 <kmc> yeah, however Python 2's distinction is wrong ;)
10:02:00 <yitz> nowadays String is gradually becoming less important. use text or bytestring.
10:02:07 <hvr> kmc: Python2.x didn't have a clear separation... ;)
10:02:16 <kmc> Matt040804, I'm not sure, honestly... ByteString API is nice, and has more of the properties beginners expect from strings
10:03:57 <lpeterse> Short question: Is it my fault or does it look like an error the bloomfilter library? http://dl.dropbox.com/u/1021691/profiling_leak_bloomfilter.pdf
10:05:04 <Tomsik> > toChar 9773
10:05:05 <lambdabot>   Not in scope: `toChar'
10:05:13 <Tomsik> > toEnum 9773 :: Char
10:05:14 <lambdabot>   '\9773'
10:05:54 <Tomsik> Is there a way to un-escape it in lambdabot?
10:05:59 <lpeterse> as a sidenote: I'm not collecting pure bloomfilters. I'm really trying to override one.
10:08:04 <Cale> lpeterse: Well, this tells us that most of the memory allocated was produced by thawing immutable bloom filters into mutable ones
10:09:11 <lpeterse> As an additional information: I'm not converting, but using the pure api only.
10:09:24 <Cale> okay...
10:09:33 <Cale> hmm, that does seem suspicious then
10:10:00 <Cale> You are compiling with optimisations on?
10:10:32 <lpeterse> no, that compilation was default regarding optimisation
10:15:16 <lpeterse> Cale: Is it worth just to forward this issue to bos? Maybe he can confirm this behaviour with a single look at the library?
10:15:39 <bos> lpeterse: wut?
10:16:04 <lpeterse> bos: hi there. read the last 10 posts :-)
10:16:31 <bos> lpeterse: not enough information there to know what's going on.
10:16:46 <lpeterse> what do you need, I deliver
10:17:15 <bos> what's your actual code?
10:17:49 <lpeterse> bos: wait a moment. I'll assemble a short paste
10:20:18 <paper_cc> is it possible to match Unicode character classes with Alex regular expressions?
10:20:26 <paper_cc> is it possible to match Unicode character classes with Alex regular expressions?
10:24:28 <lpeterse> bos: this is it: https://gist.github.com/1102862. just an acid-state container and an update function
10:25:08 <lpeterse> oh, wait. bloomfilterSpezial is not from you
10:25:50 <bos> lpeterse: looks like you're not forcing the evaluation of the bloom filter
10:26:27 <bos> oh wait, maybe you are
10:27:42 <lpeterse> bos: please refresh. I just added my wrapping type to to the gist.
10:29:41 <bos> lpeterse: i see what's going on, i think.
10:30:19 <lpeterse> bos: tell me. I'm curious ;-)
10:30:22 <bos> firstly, using the pure bloom filter API to actually modify a bloom filter is tremendously expensive, and i wouldn't recommend it.
10:30:38 <bos> it has to make a complete copy of the bloom filter for every insertion.
10:31:55 <lpeterse> bos: I read about that. Wanted to change it anyway. But a library-side spaceleak in the pure part would still be evil. I didn't want to workaround without telling you about this potential bug
10:32:47 <Cale> lpeterse: Make sure you compile with -O2
10:33:10 <bos> lpeterse: i don't think this is due to a bug in the library.
10:33:16 <Cale> as a matter of policy when you care about performance
10:33:59 <lpeterse> bos: Okay, thank you. Then it's okay for me. I'll change to the ST one then.
10:34:14 <bos> lpeterse: i think that because your data structures are too lazy, you're leaking space by holding onto old copies of the bloom filter
10:35:31 <bos> lpeterse: try using strict constructors on the elements of BloomFilterSpezial
10:35:32 <lpeterse> I wonder where this lazyness comes from. As you can see the acid-state container is fairly top.
10:35:42 <bos> uh, strict annotations
10:35:51 <lpeterse> bos: Okay, thanks for this hint
10:37:30 <lpeterse> Cale: also thanks to you. I'll try to introduce more strictness and come back later if that doesn't help.
10:38:03 <Cale> lpeterse: Yeah, just stick in a couple of !'s before the types in the definition of that datastructure and see if it helps.
10:38:57 <lpeterse> sounds like a cooking advice :-) Okay, see you then. I need to go to lunch now.
10:58:09 <siracusa> Is there any advantage of using MonadLib.ContT over Control.Monad.Cont.ContT? I haven't used either of them by now and are unsure with which to start.
11:00:41 <mreh> I think Cont is the only monad I don't really understand
11:00:47 <mreh> sorry for being so unhelpful
11:01:46 <siracusa> Yeah, same for me. This is what I'm trying to change now :-)
11:02:36 <serialhex_> anyone in here knowlegable with math in general?  (probably a dumb Q to ask here... :P )  i'm trying to figure out how/what to learn
11:03:24 <serialhex_> my goal is artificial intelligence type stuff & i'm just unsure what i should learn & would like some suggetions
11:04:42 <mreh> serialhex_: Linear Algebra, Bayesian Inference
11:04:55 <mreh> to start with
11:05:13 <mreh> then hit a good text book
11:05:17 <arw_> generally everything about statistics might be helpful.
11:05:28 <mreh> yeah
11:05:37 <serialhex_> ok, what should i learn pre-bayesian inference... i've heard of it before but don't know how to get there so to speek
11:06:08 <mreh> serialhex_: probability, conditional probability, graph theory
11:07:05 <arw_> usually (imho) its easier to first learn about the AI stuff, and as soon as you know the areas of math used you don't understand, learn that.
11:07:19 <mreh> bayes is honestly the hardest stuff I've ever had to learn... probably the litany of bad stats teachers i had
11:08:27 <serialhex_> cool, thanks!
11:11:38 <gwern> serialhex_: http://oscarbonilla.com/2009/05/visualizing-bayes-theorem/
11:12:20 <mreh> i'm going to read that too
11:12:42 <gwern> how dare you! I linked serialhex_ to it, not you
11:12:59 <mreh> *gwffaws*
11:13:05 <mreh> why are they always about cancer...
11:13:24 <mreh> are statisticians overly worried about it?
11:14:15 <gwern> mreh: well, consider the mortality causes for highly educated Western males...
11:14:49 <mreh> shuttle crashes most of them
11:14:53 <mreh> real tradgedy
11:15:05 <serialhex_> ooh, that looks cool gwern!  thanks!!
11:15:18 <osfameron> yeah, whole communities are devastated by shuttle crashes, it's a growing problem
11:15:29 <mreh> sam roweiss comitted suicide, did you hear?
11:15:38 <cheater_> who's that
11:15:39 <mreh> -s
11:15:48 <mreh> well known ML tutor
11:16:11 <mreh> it was over a year ago, but I didn't hear until 6 months ago
11:16:28 <osfameron> and then tweeted it 6 months later
11:16:32 * osfameron wonders if mreh is an Ent
11:16:54 * osfameron makes a note to check if mreh has replied to him, in another 6 months
11:18:20 <mreh> speaking about bayes brought it all back
11:18:43 <mreh> ....i saw him on youtube.... *sobs*
11:21:35 <mreh> i'm doing alright today, astronaughts dying, now this
11:24:15 <TeachmeHaskell> Hello Folkz
11:27:22 <theorbtwo> a[A
11:27:26 <theorbtwo> Gah.
11:45:48 <benmachine> how does one write an FFI binding to a library that uses errno a lot? is there any sane way to do it?
11:46:07 <kmc> there are some helpers that will execute an IO action and then check errno
11:46:16 <kmc> in one of the Foreign.C.* modules i think
11:46:27 <kmc> dunno how you make this work with concurrency
11:46:54 <kmc> speaking of which, i'm working on a FFI binding
11:46:58 <benmachine> the latter point is exactly what's upsetting me :)
11:47:15 <kmc> i have the foreign import layer and then the "imperative Haskell API" layer
11:47:24 <kmc> but i'm not sure whether to make the latter threadsafe
11:47:50 <kmc> with each call into the C library being atomic
11:47:58 <kmc> i mean, it's what you'd expect from an imperative Haskell API
11:48:15 <benmachine> is the C library genuinely impossible to use concurrently?
11:48:46 <kmc> no, the C-library state is self contained
11:48:51 <kmc> I can put my ForeignPtr in an MVar
11:48:59 <copumpkin> unlike libopcodes :(
11:49:01 <copumpkin> fucking libopcodes
11:49:08 <kmc> my concern is that this prevents the user from building more complex atomic operations
11:49:14 <kmc> copumpkin, I heard libopcodes is the worst thing ever
11:49:21 <copumpkin> it's worse than that
11:49:26 <copumpkin> I tried making a sane haskell interface to it
11:49:38 <copumpkin> but individual decoders store shit in global variables
11:49:45 <kmc> of course they do
11:49:46 <copumpkin> so even my attempts to sanify the interface would fail
11:49:53 <copumpkin> it's annoying
11:50:01 <kmc> you should make a library deglobalizer
11:50:03 <copumpkin> cause they have this big ugly struct that all decoders work off
11:50:07 <copumpkin> of
11:50:13 <copumpkin> so presumably they could store shit in there
11:50:14 <kmc> which lets you load n independent copies of any shared library
11:50:18 <copumpkin> but of course they don't
11:50:31 <benmachine> kmc: it would probably be just as good to mention in the docs "no concurrency plx" like for gtk or whichever it is
11:51:12 <kmc> sigh
11:51:26 <kmc> that makes it really easy to segfault by using my library incorrectly
11:52:29 <kmc> i think i will wrap them
11:52:48 <kmc> you can always throw on another layer of locking
11:53:08 <kmc> i don't expect the overhead would matter to anyone
11:53:08 <derdon> are qualified imports impossible within ghci?
11:53:17 <kmc> derdon, they were added in GHC 7
11:53:21 <benmachine> on my problem, there was some noise in a 2003 mailing list post about making errno haskell-thread-local rather than OS-thread-local
11:53:23 <kmc> you use the same import syntax is in a file
11:53:37 <derdon> kmc: doesn't really answer my question
11:53:41 <benmachine> but I don't know whether that ever actually happened and it doesn't sound fun to test
11:53:45 <kmc> derdon, oh?
11:54:00 <derdon> kmc: I mean ghci, the interactive interpreter
11:54:03 <derdon> kmc: not ghc
11:54:08 <kmc> that's what i meant too
11:54:13 <derdon> aha
11:54:17 <benmachine> ghci == ghc --interactive
11:54:50 <derdon> well, where's the syntax error in the following line?
11:54:50 <derdon> import qualified Data.ByteString as S
11:55:05 <kmc> that works in my ghci 7.0.3
11:55:24 <derdon> in mine, it says: "parse error on input `import'"
11:55:38 <kmc> what's the output of:  ghci --version
11:55:50 <derdon> oh, I have 6.12.3
11:55:59 <kmc> there's your problem
11:56:02 <derdon> yep
11:56:04 <derdon> thanks
11:56:10 <benmachine> you can still write a short file and load it
11:56:28 <benmachine> you could probably write a :command to do it if you were really dedicated :>
11:56:40 <kmc> haha
11:56:47 <kmc> you could also write a :command to upgrade to GHC 7 ;P
11:56:51 <benmachine> :D
11:56:54 <derdon> or I could nail a meatball on my knee
12:03:25 <erus`> qubits can be on off or both... so isnt that just base 3 computing?
12:03:54 <kmc> no
12:04:13 <Eduard_Munteanu> It's not about the number of states you can think of.
12:04:17 <kmc> a qubit is a complex number (i.e. 2D vector) of magnitude 1
12:04:26 <kmc> that gives you more than 3 states, infinitely more in fact
12:04:45 <kmc> and the state of an n-qubit system is described by a 2^n-dimensional complex vector
12:05:12 <kmc> i recommend _Quantum Computation and Quantum Information_ by Nielsen and Chuang
12:05:18 <Eduard_Munteanu> Besides it's non-deterministic.
12:05:25 <copumpkin> Nielsen has a decent set of videos somewhere
12:05:32 <kmc> Eduard_Munteanu, not in the context of what I just said
12:05:49 <kmc> quantum computation is not simple nondeterminism either
12:05:51 <Eduard_Munteanu> Yeah, I mean it's not equivalent to a classical computer.
12:06:01 <kmc> equivalent how?
12:06:18 <kmc> as Scott Aaronson is very adamant about stating, "Quantum computers are not known to be able to solve NP-complete problems in polynomial time"
12:06:21 <erus`> oh wow i didnt know it was a 2d vector :D
12:06:40 <erus`> fuck yeah real time ray tracing
12:06:48 <copumpkin> lol
12:06:52 <kmc> oh actually i was wrong, it's a 2D *complex* vector
12:06:52 <copumpkin> with 14 qubits
12:06:57 <kmc> http://en.wikipedia.org/wiki/Qubit#Qubit_states
12:07:50 <sbahra> Hi
12:08:21 <Eduard_Munteanu> kmc: I don't know much about this, but it seems to me it's a bit unlike a Turing machine.
12:08:21 <sbahra> Cale, any chance we could get lambdabot in #concurrencykit?
12:08:56 <kmc> erus`, the capsule summary of quantum computing is:
12:09:13 <kmc> the state of your n-qubit computer is a 2^n-dimensional complex-valued vector
12:09:20 <kmc> each component corresponds to one of the 2^n classical bit strings
12:09:29 <Eduard_Munteanu> (do qubit have to be binary?)
12:10:15 <kmc> your operations are a) multiply that state by any hermitian matrix, b) take an "observation", meaning you get one of those classical bitstrings with probability proportional to its complex magnitude
12:10:45 <kmc> Eduard_Munteanu, a qubit is, by definition, realized by a quantum system with two states
12:10:47 <erus`> your fading away
12:10:54 <Eduard_Munteanu> Ah.
12:11:10 <danharaj> you could have a quantum trit, if you have three states, etc.
12:11:31 <kmc> indeed there are many quantum systems with infinitely many states
12:11:35 <kmc> quantum harmonic oscillator etc
12:12:49 <Eduard_Munteanu> Would there be anything like a noise margin for quantum stuff? I mean, do you get even like in classical computing when you increase the number of states?
12:12:52 <danharaj> of course, they only behave like that in the low energy limit :p
12:14:04 <Eduard_Munteanu> (e.g. you can use trits, but then voltage levels separation is lower and you usually end up just increasing the complexity)
12:16:36 <danharaj> Well there's decoherence.
12:16:48 <danharaj> The more complicated your quantum state, the more it prefers to decohere into a classical state.
12:19:09 <jmcarthur> why do i always find myself wanting to do things that haskell's type system isn't the most awesome for?
12:19:41 <jmcarthur> it seems like i want dependent types almost every time i sit down to write haskell nowadays
12:19:57 <copumpkin> :)
12:20:03 <copumpkin> proof you belong in #agda
12:20:22 <jmcarthur> this time i'm wanting to take a repa index and turn the nth component of the index into All in order to make a slice
12:20:55 <jmcarthur> i am in #agda :P
12:21:07 <copumpkin> yep
12:21:14 <copumpkin> jmcarthur: clearly you should be using derpa
12:21:47 <jmcarthur> copumpkin: i'm curious why you didn't just put completely static dimensions in derpa ;)
12:21:58 <copumpkin> how do you mean?
12:22:04 <copumpkin> they are completely static
12:22:25 <jmcarthur> i mean where not only is the number of dimensions static but also the width of each dimension
12:22:45 <Tomsik> I think that if you /need/ DT then your code is either needlessly "clever" or something else is wrong with it. Am I wrong or not?
12:22:46 <jmcarthur> or did you do it that way and i just didn't notice?
12:22:52 <mreh> :t fold
12:22:53 <lambdabot> Not in scope: `fold'
12:23:05 <mreh> sry, wrong terminal
12:23:08 <jmcarthur> Tomsik: i disagree. i ran into this case quite honestly :P
12:23:30 <copumpkin> jmcarthur: it is as static as you can imagine it :)
12:23:36 * jmcarthur looks again
12:23:46 <copumpkin> jmcarthur: an array dimension is a fancy list of naturals
12:23:52 <copumpkin> an index into such a dimension is a fancier list of fins
12:23:57 <copumpkin> indexed by the dimension
12:24:08 <copumpkin> slices are even crazier, but I haven't figured out all the details there yet
12:24:09 <jmcarthur> ah i see
12:24:11 <jmcarthur> Shape n
12:24:24 <kmc> Tomsik, people have said the same about polymorphism, static types in general, first-class functions, and everything other than raw machine code ;P
12:24:38 <copumpkin> the flattening and unflattening proofs for the indices are what uses up most of the code in that project
12:24:43 <copumpkin> and proofs that they're inverses of one another
12:24:51 <jmcarthur> brb
12:24:57 <idnar> kmc: I'm sure somebody said it about raw machine code too
12:25:13 <Tomsik> I guess you've got a point, but I would argue that humans are very bad at solving the halting problem
12:25:55 <kmc> Tomsik, yes we are, and that's why we're bad at programming computers
12:26:02 <silver> hehe
12:26:05 <benmachine> let's all give up and write php
12:26:40 <idnar> Tomsik: that's why we invented kill -9!
12:26:43 <kmc> Tomsik, I don't know why you're singling out dependent types; most any attempt to understand what programs do ends up being equivalent to the halting problem
12:28:14 <Tomsik> Yes, but with DT you've got /two layers/ of halting problem
12:28:23 <Tomsik> one for the type system, the other one for the program
12:28:41 <kmc> shrug
12:28:44 <kmc> that's one way to divide it up
12:29:07 <Tomsik> I guess it doesn't matter in the long run
12:29:23 <kmc> since it's normal expressions appearing in types, why shouldn't i think of it as all one thing?
12:29:35 <Tomsik> just the way you rarely use clever recursion/loops in general PLs
12:30:21 <kmc> right, mainstream practice lags established PL theory by 40-80 years
12:30:30 <kmc> that means it *only* matters in the long run
12:31:09 <Tomsik> Hey, they discovered CPS not that long ago
12:31:23 <Tomsik> :p
12:31:31 <idnar> I wish I understood DTs
12:31:36 <kmc> oh Tomsik?
12:31:53 <kmc> oh by "they" you mean the mainstream?
12:31:54 <benmachine> kmc: is PL theory even 80 years old? :o
12:31:56 <Tomsik> I think there is a huge hype around CPS in ruby/javascript or something lately
12:32:00 <kmc> benmachine, the lambda calculus is
12:32:15 <Tomsik> and Turing machines too!
12:32:31 <kmc> if you consider lambda calculus the first language with first-class functions
12:32:31 <benmachine> oh I guess so
12:32:35 <kmc> then yes it lags by about 80 years
12:32:39 <benmachine> :D
12:33:04 <kmc> you can find plenty of contemporary blog posts about how awesome javascript is because it has first-class functions
12:34:31 <mreh> haskell has more than 80 years in it
12:34:57 <NihilistDandy> Probably a thousand man-years, at least
12:35:06 <mreh> relevant nick
12:35:07 <NihilistDandy> Not to mention all the woman years
12:35:18 <kmc> if only we renamed "the IO monad" to "callback-based IO" we could convert all those node.js users ;P
12:35:53 <mreh> we need someone warm and fuzzy doing haskell
12:36:26 <NihilistDandy> Why?
12:37:35 <NihilistDandy> And Edward Kmett is already plenty warm and fuzzy.
12:38:25 <kmc> haha
12:41:50 <mreh> :t (,) =<< (+1)
12:41:51 <lambdabot> forall b. (Num b) => b -> (b, b)
12:41:51 <copumpkin> NihilistDandy: the next bostonhaskell should be august 5th I think
12:41:52 <copumpkin> btw
12:42:23 <NihilistDandy> copumpkin: Hmm. Well, if I can get off work and can get down there, I'll just have to do that. :)
12:44:12 <mreh> :t (,) =<< (toEnum)
12:44:13 <lambdabot> forall a. (Enum a) => Int -> (a, Int)
12:44:18 <mreh> aha
12:55:50 <ski> @typr ((,) =<<)
12:55:51 <lambdabot> forall a b. (b -> a) -> b -> (a, b)
12:55:54 <Tomsik> > ((,) =<< (+1)) 3
12:55:57 <lambdabot>   (4,3)
12:57:04 <ski> @type graph
12:57:05 <lambdabot> forall (ar :: * -> * -> *) a b. (Arrow ar) => ar a b -> ar a (a, b)
12:57:43 <ski> > ((^2) `graph`) `map` [0,1,2,3]
12:57:45 <lambdabot>   [(0,0),(1,1),(2,4),(3,9)]
12:57:48 <parcs> @hoogle [Maybe a] -> Maybe [a]
12:57:49 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
12:57:49 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
12:57:49 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
12:58:08 <ski> @type cograph
12:58:08 <lambdabot> forall (ar :: * -> * -> *) a b. (ArrowChoice ar) => ar a b -> ar (Either a b) b
13:04:05 <NihilistDandy> （╯°□°）╯︵ ┻━┻﻿
13:04:57 <Saizan> there are a lot of thrown tables recently
13:05:30 <NihilistDandy> :D
13:07:49 <siracusa> Is that an emoticon? It's the second time I see it on this channel today.
13:08:17 <kmc> it's a pissed-off guy flipping a table
13:08:37 <siracusa> O.o
13:08:55 <siracusa> Ahhh, I see :-D
13:09:01 <NihilistDandy> Though I think it should be usable in victory, too
13:09:21 <kmc> mm, yeah
13:20:39 * hackagebot certificate 0.9.1 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-0.9.1 (VincentHanquez)
13:43:13 <burbul> We're hitting some headaches trying to convert some Parsec code from accepting String-s to accepting ByteString-s. E.g. if we write whites1 = many1 (oneOf " \t"),  we get a type error.
13:43:42 <benmachine> burbul: specifically?
13:44:13 <burbul> Is it okay to paste it here? Or should I use hpaste?
13:44:19 <identity_> hpaste, plox
13:44:22 <rtharper> plox?
13:44:24 <Saizan> ?hoogle oneOf
13:44:24 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
13:44:24 <lambdabot> Text.ParserCombinators.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
13:44:24 <lambdabot> Test.QuickCheck oneof :: [Gen a] -> Gen a
13:44:32 <identity_> rtharper: internet speak, for advanced users.
13:44:45 <benmachine> burbul: hpaste is required for >3 lines but for less than that it's often still helpful
13:44:50 <burbul> http://hpaste.org/49458
13:44:53 <benmachine> just to make sure we don't lose stuff
13:44:56 <burbul> That's useful to know -- thanks
13:45:11 <rtharper> identity_: ?
13:45:29 <identity_> rtharper: ?
13:45:35 <identity_> rtharper: "please"
13:45:35 <NihilistDandy> rtharper: It means please, ffs
13:45:40 <identity_> ^
13:45:44 <benmachine> burbul: hm. can we see more code?
13:45:45 <rtharper> angry NihilistDandy is angry
13:46:02 <jmcarthur> ffs?
13:46:10 <benmachine> burbul: also, you *are* importing Text.Parsec.ByteString aren't you?
13:46:14 <NihilistDandy> DANDY SMASH
13:46:15 <NihilistDandy> （╯°□°）╯︵ ┻━┻
13:46:20 <benmachine> (or .Lazy if that suits you)
13:46:31 <burbul> importing Text.Parsec sublibraries ByteString.Lazy, Char, Combinator, Prim
13:46:37 <benmachine> mm
13:46:40 <Saizan> burbul: it's just the MR
13:46:44 <benmachine> oh
13:46:50 <Saizan> i.e. the MonomorphismRestriction
13:47:09 <benmachine> seriously?
13:47:26 <benmachine> surely that would only be relevant if you were trying to use it at two different overloadings
13:47:29 <Saizan> it's making it resolve the Stream context by it can't because it doesn't have a clue on which s and m to take
13:47:41 <benmachine> oh
13:47:44 <benmachine> right
13:47:59 <burbul> So we need to add a type annotation?
13:48:10 <benmachine> or turn off the MR
13:48:17 <Saizan> or use {-# LANGUAGE NoMonormorphismRestriction #-}
13:48:57 <burbul> We actually had "whites1 :: Parser B.ByteString"
13:49:08 <burbul> But that was clearly the wrong thing to write -- it was causing errors in itself -- so I commented it out.
13:52:09 <burbul> Is there an easy way to figure out what the type annotation should be?
13:52:14 <ski> burbul : many people consider the monomorphism restriction a bad addition to the language. as long as you understand what it's for and what it does, there should be no problem at all turning it off with e.g. the language-extension Saizan mentioned
13:52:39 <burbul> ok -- thanks! (I suppose because I'm pretty new to Haskell I'm nervous about fiddling with default settings.)
13:52:41 <ski> burbul : remove the type signature (having MR disabled) and ask GHCi for the type ?
13:53:00 <burbul> got it -- thanks
13:53:09 <burbul> [ can I use lambdabot for it? ]
13:53:25 <ski> sure, if it fits
13:53:33 <kmc> monomorphism restriction was added to make it easy for beginners to reason about Haskell performance
13:53:39 <kmc> (pause for laughter)
13:53:47 <ski> (and if it doesn't require the declaration of any new types vel classes, since you can't do that with lambdabot)
13:53:49 <burbul> @type many1 (oneOf " \t")
13:53:50 <lambdabot> Not in scope: `many1'
13:53:50 <lambdabot> Not in scope: `oneOf'
13:54:10 <coppro> the monomorphism restriction is dumb :(
13:54:19 <burbul> @type many1 (Text.Parsec.Char.oneOf " \t")
13:54:20 <lambdabot> Couldn't find qualified module.
13:54:31 <kmc> coppro, are you Copumpkin Pro?
13:54:44 <kmc> probably not
13:55:11 <copumpkin> :O
13:55:18 <copumpkin> coppro philia
13:55:23 <kmc> :(
13:55:45 <zmv> lol
13:55:54 <zmv> @protontorpedo
13:55:54 <lambdabot> oleg?
13:55:56 * copumpkin hugs coppro 
13:56:02 <burbul> anyway, thanks again, all!
13:56:02 * ski . o O ( We retail Copumpkin Lite, Copumpkin, and Copumpkin Pro for affordable prices )
13:56:26 * zmv has a question
13:56:35 <kmc> enterprise copumpkin premier support
13:56:43 <zmv> Does Copumpkin Lite have all the features of Copumpkin Pro?
13:56:49 <ski> (of course the wares themselves might not be affordable. only the prices themselves were said to be)
13:57:18 <osfameron> zmv: yeah, but nobody buys it, because they're worried that their customers might see them using the Lite version, and think they weren't professional enough
13:57:24 <zmv> oic
13:57:26 <ski> zmv : Copumpkin Lite is a suptype of Copumpkin Pro
13:57:38 <zmv> ski: you are lying.
13:57:42 <osfameron> suptype as in sup dog?
13:57:43 <nus> supremum?
13:57:48 <NihilistDandy> Crystal Copumpkin
13:57:49 <zmv> hahaha
13:57:53 <NihilistDandy> Copumpkin Classic
13:58:14 <zmv> yo sup type
13:58:38 <kmc> Copumpkin Ice
13:58:55 <copumpkin> :O
13:59:44 <burbul> Hmm... I got    whites1 :: Stream s m Char => ParsecT s u m [Char]   out of GHCi, but the compiler doesn't like it as an explicit type annotation. (Maybe because of that 'u'? I have an error message about Non type-variable argument.)
13:59:55 <ski> zmv : ah :) s/suptype/subtype/
14:00:04 <benmachine> burbul: you might need to enable FlexibleInstances
14:00:09 <benmachine> er, FlexibleContexts rather
14:00:25 <Tomsik> :t whites
14:00:26 <lambdabot> Not in scope: `whites'
14:01:06 <burbul> Is it possible to get it to work without extensions? (I just talked to my collaborator and we still are a bit nervous about fiddling with extensions.)
14:02:18 <ski> `FlexibleContexts' and `FlexibleInstances' are fine to enable, they only lift some restrictions, in a sensible way
14:02:21 <Saizan> no, Stream as a class is already non-standard, since it has multiple parameters
14:03:41 <burbul> ok -- thanks yet again!
14:04:15 <benmachine> burbul: it *is* possible actually
14:04:24 <benmachine> well
14:04:30 <benmachine> it might be depending on how you use the thing
14:04:37 <benmachine> but you could just use the less general type signature
14:04:53 <benmachine> ParsecT ByteString u m [Char] ought to sort it out
14:05:15 <ski> burbul : it's `OverlappingInstances',`IncoherentInstances' and `UndecidableInstances' you should be thinking very carefully about before enabling
14:06:11 <benmachine> ski: I thought we liked undecidable :P
14:06:37 <ski> well, when you can prove it terminates, sure
14:06:53 <benmachine> well, when you can't, it only goes wrong at compile time, right?
14:07:15 <ski> (so the rationale for being careful is different between the last one and the two former ones)
14:07:56 <ski> yeah, but you probably don't want to allow that in libraries, if you can avoid it
14:09:46 * hackagebot text-format 0.3.0.4 - Text formatting  http://hackage.haskell.org/package/text-format-0.3.0.4 (BryanOSullivan)
14:31:15 <burbul> benmachine: just saw your comment. It does cause errors (http://hpaste.org/49461), but please don't bother looking at unless you're interested -- I think I'm less intimidated by FlexibleInstances than by the monomorphism disabler.
14:31:35 <benmachine> oh right
14:31:39 <benmachine> silly me
14:31:43 <benmachine> Monad m => that
14:31:52 <benmachine> I'm always interested :P
14:31:58 <benmachine> except for sometimes
14:33:33 <burbul> I feel idiotic for not having spotted that myself -- I just assumed it was going to be something complicated!
14:33:35 <burbul> Thanks!
14:33:48 * hackagebot dbus-core 0.9.1 - Low-level D-Bus protocol implementation  http://hackage.haskell.org/package/dbus-core-0.9.1 (JohnMillikin)
14:34:30 <danharaj> how does getArgs interact with ghci?
14:36:30 <benmachine> danharaj: pretty much how you'd expect? see also the :main and :set args commands
14:36:48 <danharaj> oh, ok, yeah I was wondering how to set args.
14:37:01 <benmachine> (see also System.Environment.withArgs)
14:42:54 <dmwit> > 768 / 8
14:42:55 <lambdabot>   96.0
14:43:02 <dmwit> > 96 / 6
14:43:03 <lambdabot>   16.0
14:43:17 <dmwit> > 3 * 2^8
14:43:18 <lambdabot>   768
14:44:03 <Saizan> benmachine: UndecidableInstances also let you break fundeps in its current state
14:47:31 <adimit> Question: given two iteratees i1 :: Iteratee s m [b] and i2 :: Iteratee [b] m (), can I compose i1 & i2 somehow to yield Iteratee s m ()?
14:47:52 <adimit> (I think that enumeratees are kind of the answer, but I don't know how exactly to accomplish it that way)
14:47:57 <dmwit> Depends on the library, but I think the standard answer is to use enumeratees.
14:48:04 <dmwit> ...yep
14:48:10 <adimit> dmwit: the iteratee library by Lato
14:48:24 <adimit> *Lato/Kiselyov
14:48:59 * dmwit has not used any iteratee library
14:49:06 <adimit> ah well, I'll try with enumeratees then. Still haven't wrapped my head around iteratees…
14:49:26 <dmwit> So maybe I'm not the best person to give advice. =P
14:49:27 <adimit> It has obvious benefits — for the obvious drawback of overcomplicating everthing.
14:49:32 <adimit> :-P
14:54:35 <burbul> w.r.t. this: No instance for (Error B.ByteString)
14:54:46 <burbul> Is there an easy way to figure out what the import is needed?
14:54:52 <burbul> [ it's actually working on my machine, but not my collaborators.]
14:55:39 <benmachine> burbul: :info in ghci
14:55:41 <benmachine> ought to help
14:56:14 <burbul> thanks
15:08:55 * hackagebot hweblib 0.4 - Haskell Web Library  http://hackage.haskell.org/package/hweblib-0.4 (AycanIrican)
16:04:50 <dobblego> is this possible? http://paste.pocoo.org/show/445678/
16:09:26 <Saizan> dobblego: bitraverse f g (EitherT m) = fmap EitherT $ traverse (bitraverse f g) m <- typechecks
16:10:27 <dobblego> I think that's him, thanks!
16:17:20 <accel> is it possible to define MyInt
16:17:28 <accel> where MyInt does all +-* modulo p?
16:17:44 <sipa> sure
16:19:03 <sipa> newtype MyInt = MyInt Int; instance Num MyInt where { MyInt a + MyInt b = MyInt (a + b `mod` 5); ... }
16:19:15 <accel> cool; thanks
16:19:48 <Choko> but it isn't mod p, sipa, it's mod 5
16:20:38 <Choko> you can put your numbers into the type system but doing it as mod p seems hard
16:20:39 <sipa> yes i just instanciated it to 5 :)
16:21:59 <sipa> just have a type-level int class Z with to toInt method
16:22:51 <sipa> and then newtype MyInt p = MyInt Int; instance Num (MyInt z) where { MyInt a + MyInt b = MyInt (a + b `mod` (toInt (undefined :: z))); ... }
16:25:43 <ski> accel : i think you can also reify `5' to a type using edwardk's reifying trick
16:27:16 <siracusa> ski: What is this trick?
16:27:50 <ski> i don't understand it fully
16:28:00 <ski> edwardk probably has a blog post or two about it
16:28:47 <ski> afaiu, he (at run-time) converts any value to a stable-pointer, then serializes that to a type, which can then be a type argument of other types
16:29:11 <ski> iiuc, this is quite nice to *use*, actually
16:29:20 * hackagebot tremulous-query 1.0.3 - Library for polling Tremulous servers  http://hackage.haskell.org/package/tremulous-query-1.0.3 (ChristofferOjeling)
16:29:31 <Eduard_Munteanu> Unfortunately that means it doesn't give any static guarantees.
16:31:23 <ski> i think <http://comonad.com/reader/2009/clearer-reflection/> is re this
16:32:00 <ski> Eduard_Munteanu : what kind of static guaranteed did you have in mind ?
16:32:01 <Eduard_Munteanu> So what's this reification thingy for? Any practical use?
16:32:33 <Eduard_Munteanu> ski: well you normally use types to provide static guarantees, like in a dependent Vec
16:33:14 <ski> one use would be what accel wanted : a way to work over the finite field with `p^n' elements for any prime `p' and natural `n'
16:33:16 <Eduard_Munteanu> In fact I'm not even sure this touches types, it rather makes it look like it does, no?
16:33:52 <Eduard_Munteanu> Hm.
16:34:53 <ski> afaiu, it's basically using existentials to make sure "incompatible things" (like numbers from different finite fields, e.g.) can't be combined, e.g. added together
16:39:20 <ski> this is similar to using `data SetOps a = forall s. SO {empty :: s,member :: s -> a -> Bool,singleton :: a -> s,union :: s -> s -> s,...}' and `setOpsFromCompare :: (a -> a -> Ordering) -> SetOps a' to ensure you can't `union' two sets with the same element type but different comparision operations
16:40:43 <ski> you have to open the existential package once, and then work inside it for as long as you want to use the operations on the particular type "generated" by `setOpsFromCompare'
16:41:43 <ski> two calls to `setOpsFromCompare' yield incompatible set types, even if the arguments happened to be the same
16:45:15 <ski> Eduard_Munteanu : so, the static guarantees are that you can never mix sets resulting from different "openings" of such set-ops records, since those two might in general use different orderings
16:45:57 <ski> this is similar to what you get by applying a module functor in the MLs to a module containing your element type and a comparision operation on it
16:47:01 <Eduard_Munteanu> ski: hrm, yeah, but when you reify actual values to types, I'm not sure what sort of guarantees you can expect. I mean, it's certainly less powerful than dependent types.
16:48:06 <fazzone> Is there a better way to write    \x -> print x >> return x   (besides liftM2 (>>) print return) ?
16:48:26 <ski> Eduard_Munteanu : edwardk's reification of valus to types hides the reified type inside an existential, from then on it's mostly like above, i think
16:49:05 <ski> fazzone : you could define a helper for that ..
16:49:16 <geheimdienst> :t ap
16:49:17 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
16:49:19 <kmc> @pl \x -> print x >> return x
16:49:19 <lambdabot> liftM2 (>>) print return
16:49:26 <kmc> fazzone, liftA2 (>>) print return
16:50:02 <ski> Eduard_Munteanu : `reify :: a -> (forall s. Reifies s a => Tagged s w) -> w' reifies the given input of type `a' into the type `s', whose shape is not observable externally
16:50:08 <geheimdienst> :t ***
16:50:08 <lambdabot> parse error on input `***'
16:50:17 <fazzone> yeah, i got liftM2 (>>) print return from lambdabot also, but I consider that to be a bit arcane
16:50:21 <ski> @type (***)
16:50:22 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
16:50:57 <ski> fazzone : i would probably just either write it out, or define a new operation that does just that
16:51:14 <Eduard_Munteanu> ski: in a sense this is like converting numbers to Peanos; you can even apply that to runtime-known values unknowingly. In fact they're more like data Peanos than anything truly typelevel
16:51:35 <geheimdienst> fazzone: do you know trace?
16:51:37 <geheimdienst> @hoogle trace
16:51:38 <lambdabot> Debug.Trace trace :: String -> a -> a
16:51:38 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
16:51:38 <lambdabot> module Debug.Trace
16:51:44 <ski> Eduard_Munteanu : i'm not sure what you have in mind with "converting numbers to Peanos"
16:51:53 <fazzone> geheimdienst: no
16:51:59 <geheimdienst> oh wait, it seems to take a string ... :(
16:52:37 <Cale> trace isn't really very closely related to \x -> print x >> return x
16:52:52 <fazzone> Well anyway, I finally did figure out how to do my running-total-without-IORef
16:53:17 <parcs> return . join trace
16:53:17 <geheimdienst> cale, i misremembered. i thought it would print the value it's passing through
16:53:51 <fazzone> I'm extremely pleased with myself http://hpaste.org/49473
16:53:55 <Cale> It's only really for debugging
16:54:30 <Cale> fazzone: well, that's a fancy way :)
16:54:45 <fazzone> Cale: Is there an easier way?
16:55:40 <Cale> Well, not necessarily "easier", but there's a more basic way, which just uses direct recursion instead of foldM
16:57:18 <fazzone> Cale: Wouldn't the recursion just basically be a specialization of foldM?  Or would you use getLine or something in the reursive bit instead of getContents ?
16:57:20 <ski> Eduard_Munteanu : the thing in `reify :: a -> (forall s. Reifies s a => Tagged s w) -> w' is that it dynamically constructs the instance `Reifies s a' based on the given value of type `a', so that `unTagged (reflect :: Tagged s a)' will evaluate to the original value of type `a', see <http://hackage.haskell.org/packages/archive/reflection/0.2.0/doc/html/Data-Reflection.html>
16:57:29 <Cale> fazzone: either way
16:57:40 <Cale> fazzone: But yeah, it would
16:57:47 <Eduard_Munteanu> ski: writing a function that converts any Int (>= 0) to a type-level Peano number
16:57:53 <Cale> fazzone: in the way I was first thinking of
16:58:04 <ski> .. ok, apparently that's not the last version. <http://hackage.haskell.org/packages/archive/reflection/0.2.0/doc/html/Data-Reflection.html> is
16:58:20 <Cale> You could also write the loop pretty nicely with fix if you don't like helper functions
16:58:21 <fazzone> Cale: I was stuck on trying to write something that could be called iterateM for two days before the foldM solution came to me
16:58:26 <ski> Eduard_Munteanu : with what type ?
16:59:08 <Eduard_Munteanu> ski: I have an older one I wrote sometime ago here... toPeano :: Show b => Int -> (forall a. Peano a => a -> b) -> b
16:59:12 <fazzone> Cale: I'm not familiar with fix, how would you write it that way?
16:59:42 <Eduard_Munteanu> ski: you pass it an integer and a function that uses the result
17:00:02 <ski> fazzone : i would probably change it to say `main = psum . map read . lines =<< getContents'
17:00:52 <fazzone> ski: When is it considered good style to use =<< instead of >>= ?  Just because =<< reads more like normal composition?
17:01:20 <Eduard_Munteanu> ski: but the thing is, if you use that as type-level nats, you don't have any guarantees about the actual value the type is depending on
17:01:39 <Eduard_Munteanu> (you couldn't, that works even with runtime values)
17:02:26 <ski> Eduard_Munteanu : ok. yes that sounds similar. though edwardk has some more fancy way of using it (e.g. to avoid passing around `undefined's), also it works for mostly any value, instead of just `Int's
17:03:47 <ski> fazzone : imo `m >>= f . g' is somewhat bad, since you should either start reading `m', then `g', *then* `f' .. or the opposite order `g',`f',`m'
17:04:09 <Eduard_Munteanu> Actually this is a lot more convoluted than doing the same thing in Agda. Agda is easy there :P
17:04:20 <ski> fazzone : writing `f . g =<< m' allows you to read a straight left-to-right, or a straight right-to-left, without having to jump around
17:04:29 <kmc> yeah, dependent types are simpler than Haskell's type system
17:04:36 <ski> fazzone : of course you could also say instead `m >>= g >>> f'
17:05:03 <ski> fazzone : also compare with the `(>=>)' and `(<=<)' operations
17:05:58 <Cale> fazzone: psum = fix (\loop n xs -> do print n; case xs of [] -> return n; (y:ys) -> loop (n+y) ys) 0
17:06:04 <Cale> fazzone: something like that
17:06:13 <Cale> I think that's a little different from what you have
17:06:18 <Cale> since it prints the initial sum
17:06:30 <Cale> But you could move the print inside the case to stop that.
17:06:56 <Eduard_Munteanu> kmc: Oleg had to jump through some hoops to do all that magic, especially because that *is* magic for Haskell.
17:07:07 <geheimdienst> ski: do you know a good example for (>=>) and (<=<)? their haddock is useless
17:07:09 <Eduard_Munteanu> or edwardk with his stuff
17:07:13 <parcs> anyone know of a library that facilitates conversion from tuples of a single data type ((a, a), (a, a, a), ...) to lists?
17:07:20 <Cale> geheimdienst: The type should tell you everything you need to know
17:07:31 <Cale> (f <=< g) x = f =<< g x
17:07:44 <lewis1711> bit of a silly question but... is there a form in pattern matching that denotes an empty list AND a one element list?
17:07:58 <Cale> lewis1711: no, but you can write a fall-through case
17:08:07 <Eduard_Munteanu> parcs: such a function would need to take an arbitrary tuple type, no?
17:08:15 <Cale> case ... of (x:y:xs) -> ...; _ -> ...
17:08:17 <geheimdienst> cale, thanks
17:08:25 <Eduard_Munteanu> Maybe some TH magic can assist though.
17:08:31 <ski> @type let printReturn x = print x >> return x; pplus x y = printReturn (x+y) in foldr ((=<<) . pplus) (return 0)
17:08:32 <lambdabot> forall b. (Num b) => [b] -> IO b
17:09:01 <lewis1711> alright, thanks
17:09:15 <ski> fazzone : ^ that's a way to do something different from `psum', i think
17:09:17 <Peaker> Eduard_Munteanu: why not a simple type-class?
17:09:26 * hackagebot rex 0.1 - A quasi-quoter for typeful results of regex captures.  http://hackage.haskell.org/package/rex-0.1 (MichaelSloan)
17:10:15 <ski> Eduard_Munteanu : yeah, there is no propagation of the shape of the value passed to the shape of the type generated
17:10:31 <Eduard_Munteanu> Peaker: yeah but you'd need to write instances for every such type
17:10:48 <Peaker> Eduard_Munteanu: as you already do for Show, Read, Eq, and other classes that make sense with tuples
17:10:49 <fazzone> ski: why foldr ?
17:10:56 <parcs> well in this case i'm only working with 2- and 3-ples :P
17:10:57 <ski> Eduard_Munteanu : i would assume you can do something like this in Agda, though .. but it's not the same as "normal" dependent typing, though
17:11:00 <parcs> maybe 4-ples
17:11:23 <ski> fazzone : often when i think i want to use `foldM', a simple `foldr' or `foldl' suffices
17:11:31 <parcs> but i still need that polymorphism
17:11:59 <ski> (i want to "fold with a monad" doesn't necessarily mean that `foldM' should be used. in many cases `foldr' or `foldl' is enough)
17:12:00 <Peaker> parcs: it would be nicer to convert ((a, a), (a, a, a))  via:  concat . (tupleToList *** tupleToList)
17:12:13 <Eduard_Munteanu> Peaker: oh, deriving?
17:12:40 <Peaker> Eduard_Munteanu: ah, no, I didn't mean to invoke only classes that are derived
17:13:05 <parcs> Peaker: that's neat, but then i'd need undecidableinstances no?
17:13:29 <Peaker> parcs: don't think so -- because there's no automagical flattening
17:13:46 <parcs> instance Tuple (a, a) and instance Tuple a => Tuple (a, a)
17:13:58 <parcs> oh
17:14:06 <parcs> no automagicalness
17:14:48 <Peaker> though it wouldn't work on a "1-tuple"
17:15:09 <Peaker> Haskell is a bit inconsistent with there being no 1-tuples
17:16:08 <Peaker> parcs: if you do put the Tuple a =>  constraint on the instance, then you do get flattening but then you need an overlapping instance for the 1-tuple case
17:16:25 <parcs> yeah
17:16:29 <Peaker> can simply do the flattening explicitly with nested calls to tupleToList and concat
17:16:30 <Eduard_Munteanu> Maybe have another typeclass for flattening? instance (Tuple a, Tuple b) => UnflatTuple (a, b)
17:16:43 <fazzone> ski: why not leverage the standard library though?  I think a foldM is much cleaner than a foldr ((=<<) . something) (return somethingElse), personally
17:17:00 <Eduard_Munteanu> Though you need to have different typeclass methods
17:17:07 <Eduard_Munteanu> *names for
17:17:34 <ski> geheimdienst : if you write `f x = g0 . h0 =<< g1 . h1 =<< g2 (h2 x)', you might as well write `f = g0 . h0 <=< g1 . h1 <=< g2 . h2'
17:18:27 <ski> geheimdienst : the `g0',`g1',`g2' there are required to have monadic result type, but `h0',`h1',`h2' aren't
17:18:51 <geheimdienst> i see. thanks
17:19:24 <ski> fazzone : as i said, the code i did above does something *different* from your `psum'
17:20:08 <ski> fazzone : so it's meaningless to compare the `foldM'-version with my version, since they don't achieve the same thing
17:21:07 <ski> fazzone : my only point was to raise awareness of that commonly when you think you need to fold over a list, using monads, you don't really need (and/or want) `foldM'. in some such cases `foldr' or `foldl' are fine
17:21:25 <ski> fazzone : in your particular case, i don't know (partly because i'm not sure what you're after)
17:24:03 <fazzone> ski: I think the foldr makes it not work interactively, but i'm not sure -- I could have been doing it wrong (i'm a bit new)
17:28:15 <fazzone> ski: With your version, how would you write main?  I wrote foldr ((=<<) . pplus) (return 0) . map read . lines =<< getContents and it didn't print the sum after each newline -- it only printed stuff after I ^D-ed it
17:29:22 * ski sighs
17:29:37 <ski> i've already mentioned my `foldr' thing does something *different*
17:30:11 <ski> i suppose in your case, if anything, a `foldl' would be more appropriate
17:30:24 <ski> @src foldM
17:30:24 <lambdabot> foldM _ a []     = return a
17:30:24 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
17:30:26 <ski> @src foldl
17:30:26 <lambdabot> foldl f z []     = z
17:30:26 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
17:30:27 <fazzone> ski: Okay, sorry!  I think my messages sound much more accusatory that I want to
17:30:40 <ski> (hm, or maybe not)
17:31:45 <ion> @hoogle pplus
17:31:45 <lambdabot> No results found
17:32:07 <fazzone> ion: see http://hpaste.org/49473
17:34:39 <geheimdienst> fazzone, ski: i noticed that every function in the program was in IO. i tried to make it a little more pure. here's what i came up with: "main = mapM_ print . scanl1 (+) . map read . lines =<< getContents"
17:34:47 <geheimdienst> seems to work okay. just my 2 cents
17:35:29 <fazzone> Ooh, I like the mapM_ print . scanl1
17:35:51 <fazzone> geheimdienst: I actually like that quite a bit more than my version
17:35:52 <ski> @type let foldM consM nil = foldr (\x fold_xs a -> fold_xs =<< consM a x) return `flip` nil in foldM
17:35:53 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a -> a1 -> m a) -> a -> [a1] -> m a
17:35:56 <ski> @type foldM
17:35:56 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
17:36:22 <geheimdienst> glad to hear it :) thanks
17:37:16 * ski supposes this `foldM' in terms of `foldr' doesn't really help here
17:37:58 <Eduard_Munteanu> Shouldn't there be both foldlM and foldrM?
17:38:03 <ski> (maybe other people have different experience about folding list with monadic operations ..)
17:38:16 <fazzone> they say if you want foldrM you have to reverse the list first
17:38:22 <ski> Eduard_Munteanu : probably
17:38:31 <ski> fazzone : depends on the monad
17:38:40 <Eduard_Munteanu> @src foldr
17:38:40 <lambdabot> foldr f z []     = z
17:38:40 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
17:38:58 <fazzone> "If right-to-left evaluation is required, the input list should be reversed."  -- http://haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Monad.html
17:39:18 <ski> fazzone : that doesn't work with infinite lists and "lazy" monads
17:39:43 <kmc> do they mean "right-to-left execution"?
17:40:27 <ski> @type let foldrM consM nilM = foldr (\x fold_xs a -> fold_xs =<< consM a x) nilM in foldrM
17:40:28 <lambdabot> forall a a1 (m :: * -> *) b. (Monad m) => (a -> a1 -> m a) -> (a -> m b) -> [a1] -> a -> m b
17:40:35 <geheimdienst> i swear, kmc has set his irc client to alert him on the words "kmc", "evaluation", and "execution"
17:40:51 <ski> hm
17:40:56 <ski> @type let foldrM consM nilM [] = nilM; foldrM consM nilM (a:as) = consM a =<< foldrM consM nilM as in foldrM
17:40:57 <lambdabot> forall t b (m :: * -> *). (Monad m) => (t -> b -> m b) -> m b -> [t] -> m b
17:41:03 <geheimdienst> ;-)
17:41:39 <ski> @type let foldrM consM = foldr (\a fold_as -> consM a =<< fold_as) in foldrM
17:41:40 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m b) -> m b -> [a] -> m b
17:41:45 <ski> that's better
17:42:17 <ski> @type let foldrM consM = foldr ((=<<) . consM) in foldrM
17:42:18 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m b) -> m b -> [a] -> m b
17:42:52 <ski> @type let foldrM = foldr . ((=<<) .) in foldrM
17:42:53 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m b) -> m b -> [a] -> m b
17:44:07 <ski> so .. arguably `foldrM' is easy enough to do directly with `foldr'
17:45:28 <lewis1711> http://hpaste.org/49484 I am trying to write a function that takes a list and generates a set from it. however not only is it extremely ugly, it's also incorrect (cannot construct infinite type a = [a]... not sure where i am returning a value). any tips?
17:45:46 <fazzone> I knew that program could be done better, thanks geheimdienst!
17:47:05 <fazzone> Doesn't Data.Set.fromList exist?
17:48:23 <Eduard_Munteanu> Do you want 'nub'?
17:48:27 <Eduard_Munteanu> :t nub
17:48:27 <lambdabot> forall a. (Eq a) => [a] -> [a]
17:48:47 <lewis1711> probably. it's more of a learning exercise than an actual need being filled. trying to get my head around haskell
17:48:52 <ski> lewis1711 : indeed it's ugly .. (too many brackets, for one thing. use of `(!!)' and `length' for another thing. left-associated use of `(++)' for a third thing)
17:49:21 <parcs> lewis1711: (set ++ (xs !! i)) => (set ++ [xs !! i])
17:49:51 <ski> lewis1711 : what parcs said is what's causing the cyclic type error
17:49:55 <lewis1711> oh
17:50:40 <lewis1711> thanks parcs. ski I got rid of the extra brackets, i don't get what's wrong with !! and length though
17:51:40 <Cale> lewis1711: xs !! n takes O(n) time,  length fails if the list is infinite
17:51:49 <Cale> (and also takes O(n) time)
17:52:03 <Cale> (where n is the length of the list)
17:52:37 <Algo> Could someone please explain, why cant you do recursive with anything?
17:53:07 <Eduard_Munteanu> Algo: I don't understand
17:53:07 <lewis1711> haskells lists are singly-linked then?
17:53:08 <monochrom> false question
17:53:15 <ski> lewis1711 : btw, you can replace
17:53:21 <ski>   if xs !! i `elem` set then setBuilder set (i+1) else setBuilder (set ++ [xs !! i]) (i+1)
17:53:27 <ski> by the simpler
17:53:34 <ski>   setBuilder (set ++ if xs !! i `elem` set then [] else [xs !! i]) (i+1)
17:53:35 <Eduard_Munteanu> lewis1711: yes
17:54:02 <ski> Algo : of course you can
17:54:09 <fazzone> Algo: what?
17:54:13 <HugoDaniel> has anyone played with lambdacube ?
17:55:03 <ski> lewis1711 : yes, lists are single-linked, so using `length' and `(!!)' is usually a sign that you either are using a bad algorithm, or that you want to use another data structure than lists
17:55:12 <Algo> Eduard_Munteanu | ski | fazzone isnt there a theorem that you can rephrase any language by recompiling in any other language, as long as there are two or three very basic sorts of instructions?
17:55:28 <fazzone> Algo: Turing-completeness?
17:55:30 <ski> lewis1711 : oh, and the same for `foo ++ [...]', of course
17:56:24 <mapreduce> In the Iteratee paper by Oleg, we have data Stream el = EOF (Maybe ErrMsg) | Chunk [el]
17:56:32 * ski suspects Algo is thinking about the sequencing, iteration and choice things from structured programming
17:56:38 <mapreduce> I'm confused as to how you get more than one chunk out of that.
17:57:15 <lewis1711> what is it with haskell and randomly infixing functions?
17:57:34 <lewis1711> that sounded bitchy...I more meant it is as a "Seems odd" way
17:57:34 <ski> lewis1711 : s/haskell/single-linked lists/
17:58:00 <monochrom> you're right, Stream el does not give you more than one chunk. you need functions that produces one chunk, then one more chunk, etc
17:58:08 <ski> (hum .. apparently i misread "randomly infixing" as "randomly indexing")
17:58:20 <lewis1711> heh :)
17:58:39 <ski> lewis1711 : actually `elem' has a standard fixity and precedence
17:58:52 <Algo> ski: yeah I think an IF and a GOTO in the crudest form
17:58:55 <Eduard_Munteanu> :t elem
17:58:56 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
17:58:56 <ski>   infix 4 `elem`
17:59:11 <Eduard_Munteanu> Maybe because it looks like   x ∈ xs
17:59:18 <Eduard_Munteanu> if you write x `elem` xs
17:59:51 <geheimdienst> lewis1711: it's not so random, functions are infix if their names are only symbols. some examples of infix functions: ++ . &&& !!
17:59:55 <ski> Algo : you still need sequencing in some form, e.g. by having most assembler instructions "GOTO" the next instruction automatically
17:59:57 <Algo> ski: Yes,  I said it confusedly because i learned it from an already confused teacher who had probably heard at the coffeemachine....
18:00:06 <lewis1711> hmm, I guess. it still doesn't look that much like it;) I just find prefix nicer than the backticks
18:00:14 <ski> (s/assembly/machine code/)
18:00:15 <geheimdienst> if you have a function with letters in the name, it's prefix, but it can be made infix with `backticks`
18:00:16 <fazzone> Algo: Aren't you thinking of turing completeness / turing-tarpits though?  Brainfuck, Iota, Jot and al that
18:00:20 <lewis1711> geheimdienst: no i get that bit. just the common practice of `infix` everywhere
18:00:52 <fazzone> Algo: as in, the smallest language that is still 'universal' in that in can compute anything computable (turing complete)_
18:01:02 <dassouki> i have xcode installed but for some reason whe ni try to install haskell, i get a warning that xcode isn't installed
18:01:15 <Eduard_Munteanu> lewis1711: you could use unicode operators with the UnicodeSyntax extension
18:01:16 <geheimdienst> oh i see :) yeah, i guess it's just a few function names that read better that way
18:01:23 <geheimdienst> > "lol" `isPrefixOf` "lolcat"
18:01:24 <lambdabot>   True
18:01:35 <Algo> fazzone | ski turing completeness? that lambda calculus of the first order is complete? (Not in the sense that aritmetic is godel incompleyte of course)
18:01:36 <Eduard_Munteanu> Though you'd have to define ∈ yourself as an alias for elem
18:01:44 <ski> lewis1711 : it's relatively common to "backtick" some operations. if you're not comfortable with it, there's no problem with using them with the normal syntax like `elem x xs'
18:02:12 <monochrom> there was "10 div 3" in pascal. in haskell you can:
18:02:15 <monochrom> > 10 `div` 3
18:02:16 <lambdabot>   3
18:02:26 <ski> Algo : i don't know what you mean by "lambda calculus of the first order is complete"
18:02:34 <monochrom> it is not random. someone has to make a judgement
18:02:56 <ski> > "abc" `stripPrefix` "abcdef"
18:02:56 <lambdabot>   Just "def"
18:02:56 <fazzone> Algo: Lambda calculus is the functional way of thinking about a 'minimal language', and inspired Iota/Jot, a turing machine is the imperative way of thinking about it and inspired Brainfuck and friends
18:03:18 <lewis1711> ski: so it's not considered a heresy in the haskell community, like indenting the non-emacs way in lisp, or indenting with 4 spaces in ruby, or putting multiple closing curly braces on the same line in C-likes?
18:03:24 <ski> Mercury also allows infixing things with backticks
18:04:00 <ski> the Prolog and the MLs allow arbitrary alphanumeric identifiers to be declared infix
18:04:06 * Eduard_Munteanu likes the Agda way there, mixfix stuff
18:04:14 <ski> (Prolog also allows them to be declared prefix, and postfix)
18:04:32 <Eduard_Munteanu> That way you also get to write   x elem xs, if elem is defined as   _elem_
18:04:42 <fazzone> lewis1711: I think it'd be considered strange to use things like elem, on, and isInfixOf without backticks, but I don't think it would be necessarily bad style
18:05:04 * ski has sometimes used `_' as a word-separator in identifiers in Agda -- is that bad ? :)
18:05:22 <Eduard_Munteanu> ski: yes :)
18:05:49 <Eduard_Munteanu> Consider if_then_else_ for instance
18:05:57 <Eduard_Munteanu> (which is a plain function there)
18:06:28 <Eduard_Munteanu> ski: wait, you don't mean some makeshift Unicode '_' that isn't treated like the regular one, no?
18:06:29 * ski considers considering `if_then_else_'
18:06:32 <Eduard_Munteanu> That'd be evil
18:06:44 <ski> i mean the regular plain `_' one
18:06:47 <Eduard_Munteanu> Like I considered using a fake Unicode space in identifiers :)
18:07:11 <Algo> fazzone:  Brainfuck? I have to check this one out...this is not some sort of turing machine? this may be a good introduction to assembler languages....
18:07:15 <geheimdienst> if__then__else__
18:07:18 <ski> would using `-' or em- or en-dash be preferred ?
18:08:00 <Eduard_Munteanu> I think I've seen '-' usually.
18:08:18 <monochrom> haskell isn't quite fooled by unicode whitespace characters
18:08:22 <fazzone> Algo: Brainfuck is a sort of model of a turing machine ... the goal was to write a turing-complete language with the smallest possible compiler.  It's not really useful for anything but entertainment, and I certainly think it bears almost no resemblance to modern assembly -- I'd learn assembly on any non x86 architecture
18:09:05 <fazzone> People generally seem to react the same way to "My first assembly was x86" as "My dog died" -- "Oh my god, I'm so sorry"
18:09:36 <Algo> fazzone: Thank you for your response. I did not say "assembly" which is humane enough...and which is in fact a very good learning ground... it was very beautiful on CISC machines
18:10:10 <geheimdienst> @remember fazzone People generally seem to react the same way to "My first assembly was x86" as "My dog died" -- "Oh my god, I'm so sorry"
18:10:10 <lambdabot> I will never forget.
18:10:28 <kmc> MIPS assembly is just boring ;)
18:10:52 <kmc> i think there's nothing really wrong with learning assembly on x86
18:11:01 <lewis1711> my first (and to date only) assembly is 8051
18:11:03 <kmc> you can ignore all the weird instructions
18:11:08 <kmc> you don't have to deal with segmentation much anymore
18:11:09 <fazzone> kmc: there's nothing *wrong* with it, x86 assembly is just very, very ugly
18:11:18 <mm_freak> assembly on x86 is enlightening…  you get to know how badly you can mess up an architecture
18:11:54 <fazzone> mm_freak: You can hardly blame them, they're stuck having to support backwards-compatibility all the way back to the IBM PC, somehow
18:12:19 <monochrom> I think, rather, that "I had to get work done in x86 assembly" is an "oh my god, I'm sorry"
18:12:45 <mm_freak> sure, and in fact that other architectures are hardly an improvement, when it comes to actually /using/ assembly, not to judging its beauty
18:12:47 <monochrom> I wrote bignum div-mod in x86 assembly. now is your chance...
18:12:56 <kmc> fazzone, i don't see how it's so ugly, at the level of ordinary user code on a sane (read: no segmentation) OS
18:12:57 <mm_freak> +i doubt
18:13:03 <fazzone> monochrom: My sincerest condolences
18:13:09 <monochrom> hee hee!
18:14:11 <trygvis> lewis1711: I'm programming a 8051 right now :)
18:14:20 <trygvis> got damn interrupts!
18:14:25 <trygvis> s,got,god,
18:14:33 <kmc> fazzone, can you provide some examples?
18:15:13 <kmc> it's different if you have to read the output of a compiler
18:15:25 <kmc> but remember that CISC architectures were designed for the benefit of human assembly programmers
18:15:45 * monochrom reads ghc-generated x86 assembly sometimes :)
18:15:54 <kmc> monochrom, i started working on a GHC "decompiler"
18:15:58 <trygvis> kmc: CISC was made because it was the way CPUs where made
18:16:19 <kmc> how so trygvis?
18:16:20 * ski thinks 680x0 is nicer
18:16:20 <trygvis> and then shit evolved into RISC and todays architectures
18:16:31 <Eduard_Munteanu> Weeelll, not to nitpick, but we could've had a reasonably fast app-level JIT translating x86 to an-x86-64-that-didn't-suck-as-much by now
18:16:44 <monochrom> we are such a mutual support group. we keep telling each other our fests that worth "oh my god, I'm sorry" :)
18:17:07 <kmc> i know it's fashionable to hate on x86 but imo the worst properties are really not visible to ordinary userspace code under a sane OS
18:17:19 <kmc> and nobody seems to be arguing with that
18:17:31 <lewis1711> i didn't find assembly that enjoyable tbh. i got far more enlightenment from learning C
18:17:52 <Eduard_Munteanu> I'm mostly arguing there is a huge cost to maintaining all that cruft on the die.
18:18:01 <mm_freak> kmc: i seconded that earlier, if not firsted =)
18:18:19 <mm_freak> x86 assembly is fine, as long as you never change the processor mode
18:18:19 <Eduard_Munteanu> Maybe it's not so huge, but still.
18:18:19 <trygvis> assembly isn't enjoyable, it's s necessity
18:18:23 <Boney> Eduard_Munteanu: Most of x86-ness is maintained in microcode.
18:18:32 * kmc wonders what will happen with Longsoon
18:18:35 <mapreduce> Is there a timer of some kind (something that fires an IO () after n seconds)?
18:18:37 <mm_freak> trygvis: some people enjoy writing assembly
18:18:39 <fazzone> kmc: I suppose you're right -- if you restrict yourself to a small subset of the instructions and use a sane OS, it's not that bad
18:18:46 <kmc> mapreduce, forkIO (threadDelay n >> myAction)
18:18:48 <Boney> the CPU translates x86 into it's own instruction set during the fetch-and-decode stage.
18:18:53 <trygvis> mm_freak: only crazy people :)
18:19:04 <mapreduce> kmc: Thanks.
18:19:13 <mm_freak> trygvis: i would say the same about C, but then most programmers would be crazy
18:19:24 <mm_freak> i think, they just don't see where they are going wrong =)
18:19:24 <kmc> fazzone, and it's even nicer than some RISC architectures, for human assembly programmers
18:19:32 <monochrom> no no, n seconds, forkIO (threadDelay (n*1000000) >> myAction)
18:19:39 <Eduard_Munteanu> I still think it's quite insane to have such a CISCy arch these days.
18:19:42 <fazzone> I think Intel could have certainly done worse, and I'm sure that there's nothing the engineers want more than a complete redesign (though I suppose they've done that, and just stuck a hardware translator on top)
18:19:57 <geheimdienst> kmc, does that need the -threaded switch to work ...?
18:20:00 <kmc> you have more flexibility in addressing modes, you don't have to worry about quirks like shadowing of conditional jumps, etc
18:20:01 <kmc> probably geheimdienst
18:20:03 <Eduard_Munteanu> You could probably save some valuable space and complexity on the die if you redesigned a CPU from scratch.
18:20:25 <kmc> Eduard_Munteanu, look at Loongsoon
18:20:39 <mm_freak> since CISC is a superset of RISC, you can always restrict yourself to the RIS
18:20:39 <Eduard_Munteanu> fazzone: or software, it's not that slow, it's just terribly annoying to write it :)
18:20:43 <kmc> MIPS (the beloved architecture of all RISC zealots) implemented with a bunch of extra instructions to help it execute recompiled x86
18:21:21 <kmc> mm_freak, there are also quirks of RISC architectures that go away in CISC
18:21:24 <Eduard_Munteanu> Hmm, interesting.
18:21:26 <mm_freak> but when i wrote assembly, i was quite glad to have a useful integer division instruction =)
18:21:29 <lewis1711> this room is very distracting with its consistently interesting discussions. I'd better get some more work done, bye
18:21:50 <sheeple> so true
18:21:52 <mapreduce> forkIO looks really smart.
18:21:53 <mm_freak> lol
18:21:57 <Eduard_Munteanu> mm_freak: I'd rather have more cache, smaller instruction words and that sort of stuff
18:22:06 <kmc> mapreduce, yeah, Haskell is a great concurrent imperative language
18:22:29 <Eduard_Munteanu> I concur :P
18:22:32 <mm_freak> Eduard_Munteanu: i don't think that's a problem with today's AI built into CPUs
18:22:39 <monochrom> using a non-tiling window manager helps eliminate irc distraction
18:22:42 <geheimdienst> haskell is a DSL for writing IO actions ...
18:22:57 <fazzone> I'd much rather have an ISA that can fit on one page of A4 and more registers than instructions that make my life slightly easier sometimes
18:23:05 <mm_freak> DSL is an IO for writing action haskells
18:23:59 <kmc> i'd rather have fixed length instructions, for security
18:24:02 <Eduard_Munteanu> monochrom: won't help me, I'm keeping the irssi window full/maximized in xmonad
18:24:05 <geheimdienst> mm_freak: when 900 years of runtime you reach, not as good your program will look
18:24:40 <Eduard_Munteanu> I'd be curious how not having an instruction set at all would play out.
18:24:45 <geheimdienst> Eduard_Munteanu: you must have tons of white space on the right-hand side
18:24:49 <monochrom> you can maximize eclipse to cover irssi
18:24:51 <Eduard_Munteanu> And no branch prediction.
18:25:04 <kmc> Eduard_Munteanu, there are CPUs where the only instruction is "mov"
18:25:06 <monochrom> nice, I have created an eclipse pun
18:25:10 <Eduard_Munteanu> geheimdienst: yeah I kinda do
18:25:12 <mm_freak> geheimdienst: i wouldn't care in 900 years
18:25:16 <kmc> everything is memory-mapped, even the ALU
18:25:41 <Eduard_Munteanu> kmc: I'm talking about this sort of stuff... http://en.wikipedia.org/wiki/NISC
18:26:05 <Eduard_Munteanu> Though I'm afraid you'd end up with huge "instructions"
18:26:22 <kmc> the whole "make the compiler figure it out" thing didn't work very well for Itanium
18:26:24 <Eduard_Munteanu> The upside is the compiler can control lots of stuff.
18:26:27 <geheimdienst> kmc: you mean you mov numbers to some magic address to add them? :-o
18:26:30 <mm_freak> geheimdienst: unless of course within my lifetime a callCC for delimited continuations in spacetime has been developed (aka a time machine)
18:26:34 <kmc> the downside is that the compiler knows much less than the chip
18:26:40 <kmc> because the compiler runs at compile time
18:26:52 <kmc> this is the same reason i'm always on about tracing JIT compilation
18:27:07 <kmc> you get information and assumptions that are just impossible statically
18:27:38 <Eduard_Munteanu> Tho' the sort of algorithms you can fit inside a CPU usually aren't great
18:27:47 <kmc> oh?
18:27:52 <mm_freak> in 1000 years we will have CPLs instead of CPUs and at the highest CP layer the window manager is just an instruction
18:27:57 <geheimdienst> yeah, you can actually watch the program run. in theory, jit is like compilation and profiling rolled into one
18:28:40 <kmc> compilation and profiling and profile-directed optimization including cross-module inlining, constant folding, specialization, dynamic loop unrolling...
18:28:43 <Eduard_Munteanu> kmc: you can't really go about doing hw branch prediction or that sort of stuff like you'd do in a JIT.
18:29:00 <kmc> Eduard_Munteanu, what? are you claiming CPUs don't do branch prediction?
18:29:04 <mm_freak> and guess what, the chips in 1000 years will run at an amazing 3 GHz
18:29:09 <kmc> haha
18:29:33 <geheimdienst> kmc: btw, when i read this, i thought of you and your penchant for jit :) http://wingolog.org/archives/2011/06/10/v8-is-faster-than-gcc
18:29:38 <Eduard_Munteanu> kmc: they do, but you can't afford to design CPUs with overly-complicated algorithms
18:30:43 <kmc> Eduard_Munteanu, ok, can you put together a comparison of hardware vs. software branch prediction algorithms and their relative performance and implementability?
18:31:16 <Eduard_Munteanu> No, it's just a basic principle that you do stuff in software if you can.
18:31:33 <kmc> a basic principle that you pulled out of your ass
18:31:41 <geheimdienst> Eduard_Munteanu: what kind of "stuff"?
18:31:44 <Eduard_Munteanu> Hardware design is expensive.
18:32:05 <kmc> the CPU hardware has access to more information and can do things more quickly
18:32:10 <kmc> sometimes that is worth the design cost
18:32:38 <kmc> Eduard_Munteanu, why did both Intel and AMD add hardware virtualization instructions?
18:32:47 <kmc> after all, you can virtualize in software with dynamic binary translation
18:32:58 <kmc> and your "basic principle" says you should do it that way
18:33:28 <Eduard_Munteanu> kmc: for a long time JIT translation was faster, and I presume it's mostly the same thing now, wrt virtualization instructions.
18:33:49 <Eduard_Munteanu> kmc: OTOH, it's hella convenient for software developers
18:34:00 <kmc> i don't follow
18:34:14 <Eduard_Munteanu> They don't have to emulate each and every quirk.
18:35:49 <kmc> sigh
18:36:38 <Eduard_Munteanu> kmc: also, think why some features are managed in software, like TLBs
18:37:20 <kmc> how do you mean? the degree to which TLBs are software-managed depends on the architecture
18:37:35 <kmc> on MIPS the TLB is filled by the OS and the CPU really has no knowledge of paging beyond the TLB
18:37:58 <kmc> on x86 the CPU reads page tables itself and populates the TLB; the OS is only responsible for flushing the TLB when page table entries change
18:38:43 <kmc> (which modern OSes try to put off as long as possible)
18:39:06 <kmc> so which one do you mean?
18:39:13 <Eduard_Munteanu> Well, my point is
18:39:31 <Eduard_Munteanu> ... CPU design should follow the KISS principle.
18:39:33 <Eduard_Munteanu> And they generally do.
18:39:44 <Eduard_Munteanu> The whole process is so costly.
18:39:46 <kmc> that's meaningless
18:39:53 <kmc> everything should be as simple as possible and no simpler
18:40:07 <kmc> have you looked at the Intel manuals recently?
18:40:07 <geheimdienst> it's costly, but sometimes things are worth the cost
18:40:18 <kmc> how can you not understand that this is a complex tradeoff
18:40:59 <kmc> you can't just say "make the CPU simple", you have to talk about what you lose by doing so
18:41:05 <Eduard_Munteanu> This is a tradeoff, but I wouldn't go about placing stuff like a costly translation layer in the CPU just for programmer convenience.
18:41:14 <kmc> no it's not about programmer convenience
18:41:28 <Eduard_Munteanu> Also, that's what RISC is all about
18:41:39 <Eduard_Munteanu> (and more extreme approaches)
18:41:44 <kmc> is about what?
18:42:01 <kmc> for example, the tradeoff between soft-filled TLBs and hard-filled TLBs is mostly about performance
18:42:15 <Eduard_Munteanu> Reducing complexity and letting software do the work.
18:42:28 <kmc> performance gained from decreasing CPU complexity vs. performance gained from fewer and shorter interrupts into the OS
18:43:04 <kmc> Eduard_Munteanu, right, that is what RISC is about.  what i don't follow is your baseless assertion that everything should be as RISCy as possible, ignoring all other factors
18:43:10 <kmc> like the performance tradeoff i just described
18:44:09 <Tomsik> Remember that CPU clocks don't scale that well
18:44:10 <Eduard_Munteanu> I didn't say everything, I rather ask people not to make the x86 mistake twice.
18:44:29 <kmc> but you're not convincing anyone that it's a mistake
18:44:47 <kmc> you've made zero argument to that effect
18:44:53 <kmc> merely repeating rules you've pulled out of your ass
18:44:59 <Tomsik> I've read that on pentium 4 over half of energy was spent on maintaining the synch clock
18:45:24 <Tomsik> Awaay
18:45:36 <kmc> x86 is getting the last laugh as caches become more important than everything else -- you can fit more code in cache when you have complex and variable-length instructions
18:45:38 <Eduard_Munteanu> kmc: I've already mentioned the instruction set vs say additional caches/registers you could fit on the die.
18:46:23 <Eduard_Munteanu> Hm, that's quite true, clocks are wasting lots of energy.
18:46:33 <kmc> there's lots of research into async CPU designs
18:46:42 <Eduard_Munteanu> Yep.
18:47:03 <kmc> Eduard_Munteanu, yes, I know what the benefits of RISC are -- my point is you're asserting that these benefits dominate the drawbacks in all cases
18:47:11 <kmc> without any evidence
18:47:17 <kmc> which would probably have to be quantitative
18:47:44 <kmc> it's fashionable to hate on x86 and wish we all ran MIPS but the reality of the tradeoff is very much more complex
18:47:49 <Eduard_Munteanu> Heh, no, I was saying one usually shouldn't go about fitting complex algorithms into the CPU. If possible it should be done in software
18:48:01 <kmc> Eduard_Munteanu, but sometimes the cost of doing it in software is tremendous
18:48:21 <kmc> the words "if possible" make your statement meaningless
18:48:22 <Eduard_Munteanu> Do you mean the AMD/Intel virtualization situation?
18:48:30 <kmc> it's always possible, if you are willing to give something up
18:48:51 <Eduard_Munteanu> Yes, because x86 is really quirky and almost nobody managed to get a good JIT on it
18:49:17 <kmc> Eduard_Munteanu, what about soft-filled TLBs, then?
18:49:34 <kmc> i would like to see a chip with a huge soft-filled tagged TLB
18:49:38 <kmc> does this exist?
18:50:09 <Eduard_Munteanu> I'd rather go with soft TLB too if I were to gamble.
18:50:23 <kmc> but you lose a lot of performance
18:50:32 <kmc> you have to make it up with TLB size, cache size, higher clock, whatever
18:51:06 <kmc> i hesitate to guess which one will be better under what circumstances
18:51:09 <Eduard_Munteanu> That's loss is probably arch-dependent
18:51:45 <Eduard_Munteanu> If you design a CPU from scratch with that in mind, you can probably cut that loss a fair amount.
18:52:02 <kmc> well, afaik MIPS was designed from scratch around a soft TLB
18:52:17 <Eduard_Munteanu> Mind the CPU itself *has* to spend resources populating the TLB.
18:52:28 <kmc> not with a soft TLB
18:52:38 <kmc> unless by "spend resources" you mean running the OS code that does so
18:52:45 <Eduard_Munteanu> I'd also like to see how explicit cache fetching works out
18:53:01 <mm_freak> does forcing () on pattern matches have a performance impact?  in other words, should i match with _ or with ()?
18:53:16 <kmc> context mm_freak?
18:53:25 <Eduard_Munteanu> kmc: more like fetch page tables and follow pointers?
18:53:31 <kmc> Eduard_Munteanu, not with a soft TLB
18:53:38 <kmc> that is the entire point
18:53:46 <mm_freak> kmc: i have an arrow computation with () input, and i wonder whether i should write "proc () ->" instead of "proc _ ->"
18:53:53 <Eduard_Munteanu> Ah, we're basically saying the same thing there.
18:54:19 <kmc> i'm not sure we are
18:54:54 <Eduard_Munteanu> kmc: I was saying how the CPU spends time / memory bandwith / other resources managing TLBs itself
18:54:55 <mm_freak> it makes no semantic difference, because the () input is always defined
18:55:01 <Eduard_Munteanu> when it's not software-managed
18:55:02 <kmc> mm_freak, then i'd go with _
18:55:45 * ski would try `()', just because
18:55:47 <eQuiNoX__> hey everyone, this is my first time trying to learn a functional programming language and im curious about the possibilities. ive tried reading stuff but its also a good idea to ask here. for starters, could someone cite some situations where haskell is used for system programming?
18:55:49 <kmc> Eduard_Munteanu, right, but the idea is this takes much fewer resources than a full context switch to the OS and thousands of instructions of user code
18:56:00 <eQuiNoX__> (i just wanna know about the possibilities out there)
18:56:01 <kmc> Eduard_Munteanu, anyway, we can continue this in -blah
18:56:12 <danharaj> eQuiNoX__: House is a prototype OS built in Haskell
18:56:12 <Eduard_Munteanu> Right.
18:56:13 <monochrom> mm_freak: consider my http://article.gmane.org/gmane.comp.lang.haskell.cafe/88120/  major asymptote-changing performance hit if you turn on optimizations :)
18:56:31 <eQuiNoX__> I see...
18:56:44 <danharaj> eQuiNoX__: You might also be interested in this http://halvm.org/wiki/
18:56:53 <kmc> systems programming means more than just writing an OS
18:57:02 <danharaj> kmc: I'm getting there :p
18:57:02 <kmc> for example, Haskell is a great choice for massively concurrent network servers
18:57:15 <kmc> due to GHC's lightweight threads and transparent asynchronous IO manager
18:57:49 <mm_freak> monochrom: so not forcing is better?
18:57:53 <danharaj> Atom is a library for doing hard real-time embedded programming. http://hackage.haskell.org/package/atom
18:58:04 <eQuiNoX__> kmc: yeah i think i can see why concurrent programming/testing etc become a lot easier
18:58:07 <monochrom> yes IMO
18:58:23 <mm_freak> ok, thanks
18:58:25 <danharaj> and, well, there's this lovely chapter
18:58:26 <danharaj> http://book.realworldhaskell.org/read/systems-programming-in-haskell.html
18:59:02 <mm_freak> when a value is constructed but never used, will it exist in memory at all?
18:59:23 <mm_freak> i'd think it's either never allocated or at least garbage-collected immediately after creation
18:59:43 <monochrom> it is at least GCed promptly
18:59:44 <eQuiNoX__> cool
19:01:02 <eQuiNoX__> kmc: yeah i know this question's is rather subjective, but would you write a disassembler in a functional programming language? :)
19:01:26 <mm_freak> eQuiNoX__: a disassembled functional program is probably unintelligible for most people
19:01:39 <danharaj> mm_freak: I think he meant a general disassembler.
19:01:52 <kmc> eQuiNoX__, probably.  Haskell is my favorite language for programs that manipulate programs
19:01:55 <eQuiNoX__> danharaj: +1
19:01:55 <kmc> compilers, disassemblers, debuggers
19:02:00 <mm_freak> in that case, sure, haskell is very strong at domain-specific languages
19:02:08 <eQuiNoX__> hmm i see
19:02:14 <kmc> i wrote Haskell bindings for the udis86 disassembler library so i could do machine code analysis in Haskell
19:02:15 <mm_freak> so an assembler/disassembler is quite natural to write in haskell
19:02:32 <eQuiNoX__> I see, cool
19:02:55 <danharaj> That's another strength of Haskell in terms of low level programming: You can always use C when you have to.
19:03:10 <mm_freak> yes, you can write C in haskell =)
19:04:05 <Nisstyre> mm_freak: semicolons amirite?
19:04:13 <deech> Hi all, I'm trying to start a Haskell group in my town. What's the best way to do that in a place where a language is judged by the quality of it's JVM interop?
19:04:26 <Nisstyre> deech: write JHaskell ?
19:04:40 <kmc> move
19:04:43 <eQuiNoX__> kmc: danharaj mm_freak thanks a lot!
19:05:02 <deech> Nisstyre: Is there any work underway for this?
19:05:02 <danharaj> eQuiNoX__: no problem. Definitely come to this channel if you have more questions. Everyone here is helpful. Or at least tries to be :p
19:05:03 <kmc> :)
19:05:07 <Nisstyre> deech: no clue
19:05:13 <deech> kmc: it's crossed my mind.
19:05:18 <eQuiNoX__> haha :)
19:05:29 <Nisstyre> http://jaskell.codehaus.org/
19:05:35 <mm_freak> Nisstyre: even that, if you insist…  in fact you can write haskell in a style, which looks like C++
19:05:44 <mm_freak> with braces and semicolons everywhere
19:05:55 <Nisstyre> mm_freak: yeah, that would look weird
19:06:09 <kmc> oh, Jaskell is an example of inventing an unrelated language and then namedropping Haskell to sound cool / smart
19:06:12 <Nisstyre> aren't semicolons and braces sometimes used for do blocks and things of that nature though?
19:06:13 <danharaj> deech: If you want to do functional programming on the JVM, have you considered Scala and Clojure?
19:06:25 <mm_freak> i think i've seen that style being seriously used in a hackage library
19:06:49 <monochrom> mm_freak: with optimizations, I tried main = print (const () (sum [0..])) and the sum [0..] does not even exist in code. also tried (\_ -> ()) and using a top-level f _ = ()
19:06:57 <kmc> mm_freak, some of that code is written by blind people using screen readers
19:06:59 <deech> danharaj: I have. Clojure is gaining a lot of momentum here. I do like Haskell though.
19:07:18 <Nisstyre> Clojure isn't very pure though is it?
19:07:19 <kmc> Clojure and Haskell are very different technologically, though similar philosophically
19:07:32 <mm_freak> monochrom: i think that's not really representing my problem
19:07:33 <deech> Nisstyre: In places yes.
19:07:37 <Nisstyre> I mean it encourages purity, but doesn't enforce it right?
19:07:48 <kmc> neither does Haskell enforce purity
19:07:52 <mm_freak> kmc: oh, good point
19:07:52 <kmc> it's just very strongly encouraged
19:08:00 <danharaj> deech: If you're a top notch compiler writer, I don't think it would be impossible for you to make GHC emit code to run on the JVM. Porting the RTS seems like the trickiest part.
19:08:10 <monochrom> right, but the happy possibility is there
19:08:25 <kmc> it's weird that Clojure and Scala are seen as similar because they both have this 80-year-old feature of first-class functions, and Java doesn't
19:08:36 <mm_freak> Nisstyre: actually haskell is 100% pure, but contains a DSL for impure operations
19:08:47 <danharaj> mm_freak: nope. unsafePerformIO is part of the standard.
19:08:47 <monochrom> > 2011 - 80
19:08:47 <kmc> mm_freak, unsafePerformIO is in Haskell 2010
19:08:48 <lambdabot>   1931
19:08:48 <Nisstyre> mm_freak: Monads?
19:08:54 <kmc> and a ratified addendum to Haskell 98
19:08:55 <mm_freak> execution is decoupled from evaluation, but they are interleaved
19:09:05 <mm_freak> oh, ok
19:09:07 <deech> danharaj: Even if I were a top-notch compiler writer I don't think I could get Haskell as it currently exists on GHC with all its extensions on the JVM and have it be performant in finite time.
19:09:08 <kmc> Nisstyre, monads have nothing to do with purity
19:09:19 <Nisstyre> kmc: I know, but he mentioned DSLs
19:09:30 <deech> That's the big advantage of a Lisp I guess. It's easy to port.
19:09:33 <kmc> sure, IO is a DSL for describing effects
19:09:38 <kmc> and IO has a monadic interface
19:09:39 <ski> danharaj,kmc : but which semantic guarantees are made about it ?
19:09:41 <mm_freak> Nisstyre: monads are just a design pattern…  you can well have a DSL for I/O without monads
19:09:44 <kmc> these two facts are not particularly close
19:09:52 <mm_freak> but anyway, my point is, except unsafePerformIO everything is pure
19:10:00 <danharaj> deech: heh. I'm not familiar with the jvm. Is it possible that you could run the GHC RTS and the JVM at the same time, and have the JVM code call into the Haskell-side? That way you could use Haskell as a Java library.
19:10:16 <kmc> and unsafeInterleaveIO
19:10:18 <kmc> and other FFI trickery
19:10:27 <mm_freak> except unsafe* and FFI
19:10:36 <kmc> and Typeable
19:10:57 <_habnabit> Except the parts that are unsafe, it's 100% safe!
19:11:00 <mm_freak> i like the idea of having continuation- and corecursion-based I/O
19:11:03 <kmc> exactly my point _habnabit
19:11:11 <kmc> yeah, Haskell's standard IO type is continuation-based
19:11:16 <danharaj> There's a recently added GHC flag that prohibits unsafePerformWizzardry
19:11:20 <ski> mm_freak : "corecursion-based I/O" being ?
19:11:36 <kmc> danharaj, SafeHaskell?
19:11:37 <deech> danharaj: That's certainly a cool compromise. Using JNI (Java Native Interface) to call into Haskell and vice versa. Great care would have to be taken to not unnecessarily spin the JVM up and down. But certainly more tractable.
19:11:38 <mm_freak> kmc: i think it's opaque?  or does the current standard indeed tell you how to implement IO?
19:11:56 <kmc> mm_freak, i meant the interface.  the right argument to (>>=) is basically a continuation
19:12:03 <mm_freak> ski: there is an infinite input list of responses and a list of output requests
19:12:20 <danharaj> deech: frankly, I doubt it's worth it. Haskell has excellent C interop. Anyone who values that less than JVM interop is no friend of mine :)
19:12:51 <mm_freak> kmc: yes, but that's not what i mean
19:12:58 <deech> danharaj: I hear you but it's Chinatown man.
19:13:03 <ski> kmc : continuation-based I/O would be more like `main :: Answer -> Answer; getChar :: (Char -> Answer) -> Answer; putChar :: Char -> Answer -> Answer'
19:13:07 <mm_freak> anyway, you can write entirely pure real world programs in haskell without using any unsafe stuff
19:13:10 <mm_freak> that's my point
19:13:25 <danharaj> sure, but you can with C as well.
19:13:31 <danharaj> And the static guarantees are the same.
19:13:32 <mm_freak> danharaj: no, you can't
19:13:32 <ski> mm_freak : ok, you mean `Dialogue'-based I/O, then
19:13:52 <mm_freak> ski: yeah, exactly, but you can have continuations instead of a response stream
19:14:16 <ski> mm_freak : yeah, `type Answer = [Response] -> [Request]'
19:14:43 <mm_freak> data Request = GetLine (String -> Request)
19:14:51 <deech> ALthough a PHP <-> Haskell bridge would be popular. I wonder if anyone's working on that.
19:14:57 <danharaj> gross
19:15:15 <mm_freak> deech: try to translate haskell to PHP
19:15:15 <danharaj> Web development in Haskell makes PHP look like QBASIC
19:15:42 <mm_freak> deech: or do you mean an interface?
19:15:44 <Nisstyre> danharaj: Web development in anything that isn't PHP makes PHP look like QBASIC
19:15:48 <danharaj> Hell, it gives Python and Ruby a run for their money, and it won't be too long before the Haskell web frameworks catch up to Django and what-not.
19:15:49 <deech> I mean an interface.
19:16:01 <mm_freak> deech: if you can run haskell, you don't need PHP at all
19:16:05 <Nisstyre> danharaj: also I firmly believe static typing is the way to go for the web
19:16:08 <mm_freak> that combination would be quite stupid
19:16:19 <Nisstyre> static and strong typing that is
19:16:24 <ion> fazzone’s question got me thinking of how to implement an enumeratee for Read a => String -> a conversion. Since i’m still a newbie with Data.Enumerator, could someone please tell me whether this is a sensible implementation?
19:16:32 <kmc> danharaj, i don't have much first-hand experience but among the programmers whose opinion i respect, Django is not that highly regarded
19:16:36 <ion> http://hpaste.org/49490
19:16:38 <danharaj> Nisstyre: I agree. I also think that Haskell is better suited to web programming because it's declarative, like HTML and CSS.
19:16:40 <deech> mm_freak: I think it would be ideal for those who develop on an existing PHP codebase and want to write parts in Haskell.
19:16:47 <mm_freak> danharaj: what exactly is missing in haskell web frameworks, which django provides?
19:16:48 <monochrom> I like the monad interface, especially the do-notation. the internals may be continuations, and that may be nice actually
19:17:12 <Nisstyre> danharaj: I wrote a blog post on the topic http://infocalypse-net.info/blog/?p=22
19:17:14 <monochrom> of course, lately, I should like the applicative interface, too :)
19:17:15 <danharaj> mm_freak: Unfortunately I don't know. I just have gotten this notion from some people that Yesod isn't as easy to use as Django.
19:17:18 <mm_freak> deech: i don't think that would improve things…  haskell is best used without PHP
19:17:45 <deech> mm_freak: Agreed, but certainly a tougher to those already invested in PHP.
19:18:05 <danharaj> kmc: That says a lot about the quality of your friends :) I have the notion that Django is better regarded than Rails though.
19:18:15 <mm_freak> deech: problem is that haskell doesn't buy you much, if thrown into an existing PHP code base
19:18:38 <mm_freak> danharaj: yesod has a steep learning curve
19:18:39 <ski> kmc,danharaj : were you thinking of <http://www.haskell.org/onlinereport/haskell2010/haskellch30.html> ?
19:18:39 <kmc> i think that's mostly about community danharaj
19:18:52 <Nisstyre> danharaj: I don't like Django because it makes things too easy
19:19:01 <Nisstyre> it's too preordained
19:19:05 <deech> mm_freak: Doesn't it get you started though?
19:19:18 <danharaj> Nisstyre: Ah I get it. It's got too many batteries, that's why people like it.
19:19:21 <Nisstyre> as far as python goes CherryPy is a better choice imo
19:19:22 <mm_freak> danharaj: but once you got used to it it's very good…  it doesn't follow design decisions i would have made, if i would have invented it, but it's good for doing rapid development
19:19:41 <deech> mm_freak: And it will be able to interface with Wordpress etc. so it can break into the CMS niche.
19:19:57 <mm_freak> deech: it will be a frustrating start and the interleaving will be in your way for many things
19:19:58 <danharaj> mm_freak: So when will Yesod take over the world, since Yesod + Warp is so fast and Haskell is so great?
19:20:11 <monochrom> tomorrow
19:20:18 <ion> before noon
19:20:23 <mm_freak> seriously i believe that writing an app from scratch in haskell is going to be easier, faster and much more worthwhile than making a PHP interface
19:20:38 <mm_freak> danharaj: hopefully never =)
19:20:44 <deech> mm_freak: Even if a bunch of it is already in PHP?
19:21:10 <mm_freak> deech: i'm just hating PHP =)
19:21:18 <mm_freak> and i love to express that hate =)
19:21:26 <deech> mm_freak: I completely empathize.
19:21:29 <Nisstyre> php deserves the hate
19:21:42 <deech> It's own creator hates it.
19:21:43 <monochrom> if you have existing PHP code but buggy, erasing it may be worthwhile
19:21:58 <mm_freak> deech: well, for someone hating it he defends it very well
19:22:01 <Nisstyre> PHP
19:22:14 <mm_freak> people still use PHP without feeling the asylum smell
19:22:14 <Nisstyre> PHP's worst crime was making everyone and their cat a web developer
19:22:27 <kmc> hey my cat writes good code
19:22:38 <ion> Conversion of working code from a language to another is also easier than writing entirely new code: most of the thoughtwork has already been done and most of the problems have already been solved.
19:22:42 <mm_freak> Nisstyre: if PHP wouldn't have done it, then perl or python would have
19:22:43 <monochrom> generally any language with quite irregular semantics. fixing bugs under such a semantics is painful
19:22:51 <Nisstyre> mm_freak: at least Python has strong typing
19:23:03 <Nisstyre> PHP was a replacement for Perl scripts
19:23:07 <danharaj> duck duck quack
19:23:12 <mm_freak> ion: not so much for haskell, because direct translations from imperative OOP code tend not to work well in haskell
19:23:13 <kmc> ion, but I thought programming was entirely about languages and the actual solving of problems a rote, mechanical task? ;P
19:23:20 <danharaj> If it looks like a duck, quacks like a duck, and segfaults like a du- wait what?
19:23:36 <ski> kmc,danharaj : "`unsafePerformIO :: IO a -> a'  Return the value resulting from executing the `IO' action. This value should be independent of the environment; otherwise, the system behaviour is undefined.". i take that to mean that `unsafePerformIO foo' is only valid Haskell when `foo' is semantically equal to `return x' for some `x'
19:23:53 <ion> mm_freak: I didn’t mean a direct translation. There’s obviously a certain amount of effort.
19:23:56 <monochrom> paradigm shift bars translation
19:23:57 <danharaj> ski: a decent interpretation
19:24:09 <danharaj> ski: If you specify your platform, it becomes more defined, so to speak.
19:24:21 <ski> "platform" ?
19:24:23 <kmc> ski, would you consider (newIORef 3 >>= readIORef) to be semantically equal to (return 3) ?
19:24:28 <danharaj> ski: Your compiler.
19:24:36 <mm_freak> ion: when you use good haskell design patterns, you will likely have to rethink most of those thoughts
19:24:37 <ski> kmc : yes
19:24:37 <Eduard_Munteanu> It makes me wonder how a machine translation from imperative to Haskell code would fare.
19:24:49 <kmc> Eduard_Munteanu, I wager you  get imperative Haskell code
19:24:55 <kmc> which might not be a problem
19:25:00 <Eduard_Munteanu> Nah, I mean performance-wise.
19:25:18 <Nisstyre> Eduard_Munteanu: would you be using the strict versions of most functions?
19:25:33 <Eduard_Munteanu> Hm, good question.
19:25:58 <Eduard_Munteanu> I'm not sure. But I'd want to use unboxed arrays and such to emulate C arrays
19:26:04 <mm_freak> ion: there may be a well thought signal processing implementation in PHP, which takes raw bytes, converts them into waves and analyzes them…  in haskell, you would certainly read and convert using iteratees and feed the signal into an FRP system…  which is so different that likely you'll redo most of the thinking
19:26:07 <kmc> i think we look down on transliterated imperative code because a) we want people to re-solve the problem in a functional way, and b) it's usually done by beginners who make a lot of other mistakes
19:26:21 <deech> mm_freak: Check out http://www.quora.com/What-programming-language-do-people-hate-the-most-and-why. Scroll down to the bottom of the first answer.
19:27:07 <Nisstyre> deech: I've seen a lot of Scheme hate for some reason
19:27:17 <danharaj> Haters gonna hate.
19:27:18 <ski> Scheme is nice ..
19:27:22 <Nisstyre> I have a hunch it's from people who were forced to learn it in school
19:27:38 <kmc> people hate Scheme because they can't look past parentheses
19:27:39 <mm_freak> deech: indeed, but still he defends PHP (of course he does, since he earns money with it)
19:27:58 <deech> mm_freak: I suspect that's true.
19:28:47 <deech> Nisstyre: What reason is that?
19:29:02 <deech> I don't see anything on that link about Scheme.
19:29:18 <Nisstyre> deech: I think a lot of schools have it in the curriculum, and students don't see a "practical" use for it
19:29:22 <Nisstyre> therefore they despise it
19:29:33 <Nisstyre> deech: no I was just discussing hate in general
19:29:50 * monochrom loves parentheses. should go design parentheses for the love
19:29:51 <deech> Nisstyre: Oh you mean, Scheme hate for the same reason as Haskell hate. Thought you were talking about PHP.
19:29:59 <Eduard_Munteanu> LOL, that Labview pic looks silly
19:30:02 <Nisstyre> oh no, of course not
19:30:11 <Eduard_Munteanu> http://d2o7bfz2il9cb7.cloudfront.net/main-qimg-a2e1e13841b01982fcb2ddcda2f958e9
19:30:37 <mm_freak> monochrom++
19:30:44 <ion> mm_freak: I was thinking of a certain project i converted from Ruby to Erlang (since i wanted to learn Erlang and also Erlang fit the project much better with its bitstring awesomeness and process semantics). Even though the conversion resulted in code that used a good Erlang style with appropriate purity, recursion etc, it was barely any work compared to the original work which included implementing a painful PTZ camera protocol based on an utterly lacking
19:30:47 <mm_freak> i hate ($) much more than parentheses
19:30:51 <ion> specification. :-)
19:30:58 <Nisstyre> mm_freak: then use parens
19:31:09 <Nisstyre> Haskell is awesome for giving the choice
19:31:12 <deech> Languages like Scheme and Haskell solve problems before they even come up. This is annoying.
19:31:16 <mm_freak> Nisstyre: i do, just wanted to give monochrom credit =)
19:31:29 <gwern> you know, I don't think I had to deal with any spam at all on hawiki today
19:31:31 <gwern> how pleasant
19:31:34 <Eduard_Munteanu> Actually this is better... http://d2o7bfz2il9cb7.cloudfront.net/main-qimg-012aae85ca1c92ae9b9c8796df0d25f9
19:32:15 <ski> mm_freak : ah, a fellow `$'-frowner :)
19:32:26 <mm_freak> ion: obviously you don't reinvent algorithms or protocols…  i don't count that work, but only the thinking invested in the actual implementation
19:33:13 <Eduard_Munteanu> In some cases, getting to a vaguely functional style amounts to reinventing the algo
19:33:15 <mm_freak> deech: missing problems?  see Foreign.*
19:33:24 <luite> ski: how about $ in something like  a . b . c . d $ e ?
19:33:41 <mm_freak> luite: that's about the only case where i use ($)
19:33:50 <ski> luite : acceptable, though i often do `(a . b . c . d) e' instead
19:34:01 <mm_freak> another case is:  "forever $ do"
19:34:04 <deech> mm_freak: I don't have much exp. with writing FFI code in Haskell.
19:34:13 <ski> mm_freak : or `foo $ \x -> ...'
19:34:29 <Eduard_Munteanu> or   foldl ($) ...
19:34:39 <ski> @type foldl id
19:34:39 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
19:34:39 <lambdabot>     Probable cause: `id' is applied to too many arguments
19:34:39 <lambdabot>     In the first argument of `foldl', namely `id'
19:34:40 <mm_freak> deech: it doesn't take much to learn how to dereference a null pointer using Foreign.Ptr and Foreign.Storable
19:35:13 <mm_freak> there you can also learn how to create your very own buffer overflow in haskell
19:35:19 <mm_freak> general purpose is general purpose =)
19:35:36 <mm_freak> ski: i often use parens there
19:35:51 <mm_freak> if it gets too big i prefer 'let' or 'where'
19:35:53 <ion> Those are the typical cases of $ being useful. What are the wrong places where $ is being used so much that you’ve developed a hatred for it? :-)
19:36:00 <deech> mm_freak: Or I can just use IORef's all over the place and turn Haskell back into a procedural language. I bet that's be fun.
19:36:11 <mm_freak> ion: putStrLn $ f x
19:36:17 <ski> mm_freak : if `...' is short, i often do, if it's long, or has `blah $ \bleh ->' repeatedly, i usually don'e
19:36:21 <Nisstyre> personally I only use $ when I'm calling one function, so no f $ a $ c d
19:36:41 <ion> mm_freak: True, i do like putStrLn (f x) considerably more than that.
19:36:45 <parcs> i prefer parentheses but i _hate_ adjacent parens. therefore i do things like foo (bar $ baz 3) instead of foo (bar (baz 3))
19:37:07 <ion> foo . bar . baz $ 3 or (foo . bar . baz) 3
19:37:15 <Nisstyre> parcs: I do the same thing
19:37:16 <ski> parcs : .. what ion said :)
19:37:22 <mm_freak> ion: i try to avoid that situation =)
19:37:30 <deech> Oh well, I have to wake up and write Java code tomorrow. A man can dream.
19:37:42 <mm_freak> f . g . h $ x  -- strongly suggests that you may want to write a pointfree function and use that one instead
19:37:50 * ski checks to see whether he's awake
19:38:25 * ion checks to see whether shklee’s awake.
19:38:35 <deech> E X C E P T I O N
19:38:53 <parcs> ion: that was contrived example. but i'd prefer foo $ bar $ baz 3 instead. i only do fn composition when binding a name to a composition of functions, not when inlining consecutive fn calls
19:39:00 * mm_freak checks to see whether *** Exception: Prelude.undefined
19:39:49 <ion> ＥＸＣＥＰＴＩＯＮ？
19:40:06 <deech> I N C E P T I O N reference. Sorry that was horrible.
19:40:08 <mm_freak> ⊥
19:40:09 * monochrom puts Stephen Cook to sleep so he can solve the P=NP problem by sleeping for one week (40 years in the deepest dream level)
19:40:25 <parcs> the ghc devs seem to do the same, so i'm not crazy :P
19:42:09 <ion> Relevant: http://robobooga.posterous.com/tab-key
19:42:44 <deech> ion: nice.
19:42:47 <monochrom> hahahaha
19:44:37 <parcs> i never understood why people advocate `a . b . c $ x` over `a $ b $ c x`
19:45:02 <deech> parcs: I've seen this in Oleg's code.
19:45:43 <monochrom> I understand why. more uniform
19:45:45 <ion> Well, when refactoring, you often want to give the a . b . c part a name and apply that to x.
19:46:13 <monochrom> note how "a $ b $ c x" is not uniform because it is not "a $ b $ c $ x"
19:46:14 <ion> a $ b $ c x is the result of thinking in terms of shuffling data around, a . b . c $ x is the result of thinking of terms of function composition.
19:46:48 <monochrom> therefore if you advocate "a $ b $ c $ x" over "a . b . c $ x", I will agree
19:47:15 <Eduard_Munteanu> How about   a(b(c(x)))? :P
19:47:25 <monochrom> hee hee
19:47:38 <deech> Eduard_Munteanu: That's got more parens than Lisp.
19:47:39 <ion> x.c.b.a
19:48:03 <ion> or x.c().b().a() depending on language :-P
19:49:47 <monochrom> certainly, I started as a beginner by thinking of data shuffling. but when I matured I think more of function composition i.e. block connecting
19:53:23 <parcs> deech: which have you seen in oleg's code?
19:53:30 <ski> deech : does not
19:55:30 <ion> Yeah, exactly the same number.
21:17:54 <parcs> > fromInteger 500 :: Word8
21:17:55 <lambdabot>   244
21:18:02 <mauke> > 500 :: Word8
21:18:03 <lambdabot>   244
21:20:53 <parcs> mauke: dealing with the Random class
21:25:34 <parcs> that's how it was intended to be used yes?
21:39:22 <luite> what does this error typically mean? unknown symbol `__stginit_wolfgangzmfrontzm0zi0zi0_WolfgangziAuthziEmail_
21:41:59 <kmc> luite, did you build with ghc --make?
21:42:10 <luite> yes
21:42:31 <luite> well, no, but that's not the problem :p
21:42:47 <kmc> ok
21:42:58 <kmc> preflex_, zdec __stginit_wolfgangzmfrontzm0zi0zi0_WolfgangziAuthziEmail_
21:42:58 <preflex_>  __stginit_wolfgang-front-0.0.0_Wolfgang.Auth.Email_
21:43:14 <kmc> try reinstalling the wolfgang library?
21:43:18 <kmc> or wolfgang-front ?
21:43:33 <luite> oh stupid me
21:44:40 <luite> it's the package I'm working on, I moved some stuff to the Wolfgang.Auth.Email module but forgot to update the .cabal file
21:44:44 <kmc> heh
22:07:59 <sebz> luite: are you the one behind wolfgang lambda?
22:08:44 <luite> yes
22:08:57 <Cale> MAEK DEMO NAO
22:09:13 <sebz> lol what Cale said
22:09:17 <luite> :(
22:09:23 <sebz> I heard it's amazing but I didn't get a chance to try it
22:09:40 <luite> haha it's not that amazing, but I'm working to get it back as soon as possible
22:09:49 <Cale> It is pretty damn cool
22:09:57 <sebz> is it open source?
22:10:04 <luite> unfortunaltey I've been struggling with yesod limitations all weekend
22:11:04 <luite> sebz: not yet, but I'll upload everything to github once it's launched
22:11:11 <luite> and a few things to hackage
22:12:15 <luite> but it's not really suitable for a hackage package, since running the site requires lots of operating system configuration
22:12:44 <luite> it runs IO code for users now
22:14:10 <sebz> cool, I'd love to get a chance to help out when you're ready
22:14:45 <kniu> @ pl f q >>= \g -> g x <$> h p q f
22:14:54 <kniu> @pl f q >>= \g -> g x <$> h p q f
22:14:54 <lambdabot> (<$> h p q f) . ($ x) =<< f q
22:14:58 <kniu> huh
22:14:59 <luite> I already have a server for it and hopefully have some preview within 2 months. Maybe I'll do a closed preview with invites, works for google, right? ;)
22:15:36 <kniu> @pl do {g <- f q; g x <$> h p q f}
22:15:36 <lambdabot> (line 1, column 4):
22:15:36 <lambdabot> unexpected "{"
22:15:36 <lambdabot> expecting variable, "(", operator or end of input
22:18:04 <luite> but I have to fix some important security things first, everything that runs user code should be completely untrusted, with the current version the user can crash one of the two web services because it doesn't check everything
22:20:11 <sebz> luite: ah I see why you shut it down now
22:21:52 <luite> the old version ran a different backend, but that had one huge limitation: if a user did someone that required the interpreter to be killed (infinite loops, computations that take too long etc), the interpreter had to be completely restarted, all packages reloaded
22:22:06 <luite> which itself could take longer than the computation timeout
22:22:26 <luite> it also didn't run IO code
22:28:58 <luite> sebz: if you want to write something that would be useful for it, then a native svg backend for diagrams would be very welcome, especially if it has a way to add basic interactivity with javascript
22:30:47 <luite> and that would also be useful for other projects: it would remove the cairo dependency for diagrams in many cases, and it could be used for other haskell website related things
22:32:18 <dented42> In the GHC build process, it builds an executable called ghc-pwd, which seem to me to do exactly what /bin/pwd does. so why does it exist? why not just use the existing pwd?
22:33:56 <Eduard_Munteanu> I'd guess for compatibility purposes on non-Unix systems, though I could be wrong.
22:36:28 <sebz> luite: to make interactive graphs?
22:36:44 <dented42> Eduard_Munteanu: that makes sense
22:36:54 <kizzx2> dented42: yes, exactly, it's for compatibilty reason
22:37:00 <kizzx2> https://www.google.com/codesearch#jysarkix6sg/utils/ghc-pwd/ghc-pwd.hs&q=ghc%20%22ghc-pwd%22&type=cs
22:37:04 <luite> sebz: yes
22:37:37 <luite> sebz: for wolfgang, I'd like to add callbacks so that results can request new data from the server, but that should be a relatively minor addition if the rest already works
22:38:10 <luite> hmm, I wonder if it would be possible to get a haskell.org subdomain for this
22:58:08 * hackagebot blakesum 0.5 - The BLAKE SHA-3 candidate hashes, in Haskell  http://hackage.haskell.org/package/blakesum-0.5 (KevinCantu)
22:58:10 * hackagebot blakesum-demo 0.5 - The BLAKE SHA-3 candidate hashes, in Haskell  http://hackage.haskell.org/package/blakesum-demo-0.5 (KevinCantu)
23:34:59 <chrisdone> mauke: what is the reason for preventing implementation of PrintfArg in printf-mauke?
