00:01:54 <coppro> > ((\x -> case x of { True -> True; False -> False, _ -> False}) undefined)
00:01:55 <lambdabot>   <no location info>: parse error on input `,'
00:02:01 <coppro> > ((\x -> case x of { True -> True; False -> False; _ -> False}) undefined)
00:02:01 <lambdabot>   *Exception: Prelude.undefined
00:03:03 <coppro> hmm
00:03:26 <coppro> I have to think that per the report, that should actually be False
00:03:44 <coppro> oh wait...
00:03:47 <coppro> :/
00:04:35 <coppro> I'm beginning to not like the report
00:05:00 <ion> Err, why should that be False?
00:06:54 <coppro> so the semantics for 'case' are defined for when the guards succeed and when they fail, but not when they diverge. It's clear to me that divergence of /any/ pattern should result in bottom as the result of the case expression, but this is not made explicit
00:07:49 <coppro> Instead, it says "If no alternative succeeds, the result is _|_", which is highly misleading as implies that if one of them does succeed, the result is not _|_
00:09:37 <coppro> so in my last example, for instance, the last pattern would succeed due to being irrefutable, and the result would be False
00:13:27 <ski> coppro : "\"If no alternative succeeds, the result is _|_\", which is highly misleading as implies that if one of them does succeed, the result is not _|_" -- incorrect. logical implication is not logical equivalence
00:13:30 <arcatan> (your last example didn't have any guards)
00:13:54 <coppro> ski: I know they are different, but the English language takes them to be so
00:13:56 <ski>   no alternative succeeds => the result is _|_
00:14:04 <ski> is what the text said
00:14:09 <coppro> I agree
00:14:13 <coppro> hence my "oh wait..."
00:14:41 <ski>   not no alternative succeeds => not the result is _|_
00:14:48 <ski> is not logically equivalent
00:14:57 <ski> coppro : well, sometimes, but not always
00:15:35 <coppro> still, I think that the distinction between a failure and divergence could be made more clear
00:16:15 <arcatan> what's divergence?
00:16:36 <coppro> arcatan: matching against bottom
00:18:01 <arcatan> ah, okay.
00:33:27 <solistic> Is there some function in spirit of Monad m => Iteratee a m b -> Iteratee a m c -> Iteratee a m (b, c) ?
00:39:39 <mm_freak> solistic: could you be more specific as to how that function would be different from liftA2 (,)?
00:41:03 <mm_freak> if you're looking for parallel stream eaters, there are some variants floating around the net, but the enumerator library doesn't contain such a function, because it would be difficult to implement sanely and the semantics would be ambiguous
00:59:29 <sutabi> Is there a way to use mod on doubles? or at least check of the double is a whole number?
01:00:32 <hpaste> refox pasted “hFlush: illegal operation” at http://hpaste.org/49639
01:01:04 <refox> I'm debugging some code and got the error "<stdout>: hFlush: illegal operation (handle is closed)".  I just posted a small example, where it occurs: http://hpaste.org/49639.
01:03:01 <refox> Is the hClose stdout needed at all, or are those closed by default?
01:05:31 <mm_freak> what's a good technical term for a computer session, i.e. from turning on to turning off?
01:05:41 <mm_freak> i don't want to call my type Session
01:06:18 <mm_freak> 'process' sounds good
01:07:05 <mm_freak> refox: you don't need to close the standard handles
01:08:39 <quicksilver> sutabi: if (abs ( x - fromIntegral ( round x )) < some_small_number )
01:08:55 <quicksilver> sutabi: Doubles are inherently imprecise so you can't really check precisely if they are integral.
01:09:19 <quicksilver> although you can do if (x - fromIntegral (round x)) == 0.0 if you're prepared to take that risk
01:09:25 <quicksilver> < some small_number is safer.
01:10:42 <refox> mm_freak: thx, so they are closed by default somewhere? Because in the System.IO library documentation I just can find, that they are opened by default at start.
01:10:58 <mm_freak> refox: they are taken care of by the RTS
01:11:25 <quicksilver> in fact, by the operating system in most cases.
01:11:38 <quicksilver> when writing a C program you are not expected to close the standard handles
01:12:02 <quicksilver> in fact, you don't need to close anything - posix rules is that all files are closed when the process dies, unless the FD is shared with another process.
01:13:29 <sutabi> quicksilver, gezz ... so some small number would be like 0.00001 or would 1 be suffice?
01:13:48 <quicksilver> sutabi: this is just how floating point works :) it's not a haskell thing.
01:14:06 * mux steps on ieee754's face
01:14:07 <refox> thx
01:14:20 <quicksilver> http://download.oracle.com/docs/cd/E19957-01/806-3568/ncg_goldberg.html
01:14:54 <sipa> quicksilver: technically, some double exactly represent an integer
01:15:01 <quicksilver> sipa: of course, yes.
01:15:05 <solistic> mm_freak: Yes, I think I'm looking for "parallel stream eaters", something like unix `tee`
01:15:26 <quicksilver> sipa: but there is no guarantee that a calculation which, mathemtically, ends in an integer, will get precisely the right answer.
01:15:41 <sipa> indeed
01:15:54 <quicksilver> if you are just comparing constants then it is indeed safe to use ==
01:18:50 <sutabi> quicksilver, so for example 4.000000000000000001 == fromInteger (round 4.000000000000000001) should be false but is true...
01:21:47 <quicksilver> sutabi: right. because 4.000000000000000001 is represented the same as 4.0, in a Double
01:21:52 <quicksilver> that's beyond the limits of precision.
01:23:16 <mm_freak> solistic: there is really no sensible way to define such a function
01:23:29 <quicksilver> > head $ dropWhile (\n -> 4.0 + 10^^(-n) /= 4.0) [1..]
01:23:30 <lambdabot>   16
01:23:35 <mm_freak> i think, you will need to write one yourself for your specific application
01:24:19 <solistic> ok, that is what I'm gone do
01:25:02 <solistic> still, do you remember where some variants are floating around the net, I was not lucky with google
01:33:20 <solistic> mm_freak: I'm also very interested in what the issues with such a function are, do you know some place where I can read about that?
01:34:28 <quicksilver> solistic: have you looked over http://okmij.org/ftp/Streams.html
01:34:40 <quicksilver> solistic: he does have some multiple stream examples
01:36:12 <solistic> quicksilver: thx
01:46:01 <mm_freak> solistic: sorry, i don't remember, but i saw the last reference on the -cafe mailing list about a month ago
01:47:14 <mm_freak> solistic: one simple issue is:  what happens, when the two iteratees don't consume the same amount of data?
01:52:06 <solistic> mm_freak: For my purpose oleg's definition of enum2/enumPair, with "The enumeratee continues for as long as there are stream data and at least one of the iteratees wants them.", is suitable.
01:52:28 <solistic> mm_freak: I'll read up about the topic on haskell-caef, thx
01:55:48 <quicksilver> mm_freak:
01:56:04 <quicksilver> you move their bowls further apart and put one on a diet
02:03:25 <erus`> obviously they have different metabolic rates
02:28:28 <mm_freak> quicksilver: interesting approach
02:28:28 <mm_freak> ;)
02:33:26 <stobix> Is there a haskell function that turns an argument into two arguments? Kinda like dup in stackbased languages or something.
02:34:05 <quicksilver> well there is (id &&& id)
02:34:14 <sipa> so you would want eg. "(+) $ dup x" to be the same as "x + x" ?
02:34:32 <stobix> sipa: yep
02:34:33 <luite> > join (+) 1
02:34:34 <lambdabot>   2
02:34:34 <quicksilver> there are at at least two ways to do that
02:34:42 <luite> that's one ;p
02:34:42 <quicksilver> the one luite gave :)
02:34:44 <quicksilver> and
02:34:59 <quicksilver> > uncurry (+) . (id &&& id) $ 1
02:35:00 <lambdabot>   2
02:35:17 <quicksilver> join is shorter and neater
02:35:28 <quicksilver> but (id &&& id) is more in the spirit of a concatenative language
02:35:31 <sipa> :t join
02:35:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
02:35:35 <quicksilver> however it forces you to uncurry your function.
02:36:25 <stobix> Hm. So either I play around with monads or arrows for this, then?
02:36:55 <quicksilver> not really, no
02:37:03 <quicksilver> neither of those have anything to do with monads or arrows
02:37:16 <quicksilver> they just happen to use combinators which have very general definition :)
02:37:20 <sipa> @pl \x -> (x,x)
02:37:20 <lambdabot> join (,)
02:37:29 <sipa> @let dup = join (,)
02:37:29 <lambdabot>  Defined.
02:37:30 <quicksilver> join on the (->) monad; &&& on the (->) arrow
02:37:47 <sipa> > uncurry (+) $ dup 3
02:37:49 <lambdabot>   6
02:40:29 <chtaube> is there a function which takes two bytes from a bytestring and converts them to a 16-bit unsigned integer?
02:42:59 <stobix> oh, and since (+) and (,) and the likes are monads, that works?
02:43:47 <quicksilver> chtaube: x*256 + y ?
02:43:54 <quicksilver> stobix: no.
02:43:59 <quicksilver> stobix: this has nothign to do with monads.
02:44:01 <quicksilver> absolutely nothing.
02:44:11 <quicksilver> it's a complete red herring that the type of 'join' involves a monad.
02:44:12 <kamilc> Hi, all
02:44:21 <quicksilver> we're using one concrete instance - the (->) instance.
02:44:26 <sipa> well, (->) is a monad
02:44:31 <sipa> so functions are monadic actions
02:45:02 <kamilc> does anyone know how to skip to desired phrase in text using parsec?
02:45:08 <quicksilver> yes, but trying to understand the behaviour of uncurry (+) $ dup 3 in terms of some things being monads is the wrong intuition.
02:45:08 <chrisdone> anyone got a script or way to download .tar.gz's of all packages and dependencies required by a .cabal file?
02:45:19 <quicksilver> dup is just a function a -> (a,a)
02:45:28 <quicksilver> it could have been defined dup x = (x,x)
02:45:42 <chrisdone> i'm getting （╯°□°）╯︵ ┻━┻  with cabal's dependency hell and i'm just going to put all my dependencies in the project directory
02:47:03 <luite> stobix: it has to do with a single instance of monad, specifically, the (b ->) one, now look at the type of join :: m (m a) -> m a , and fill in the concrete type, m = (b ->), so we get join :: (b -> (b -> a)) -> (b -> a) = (b -> b -> a) -> (b -> a)
02:48:35 <luite> stobix: now we feed the result a function (+) :: Num c :: c -> c -> c, so we know that a and b are actually the same type here, so we get join (+) :: Num a => a -> a
02:48:49 <kamilc> I've got an html string with "nicelinks" phrase somewhere in it.. And I want to skip all the beginning text right to this phrase in parsec and then return all the rest... But skipMany (try (string "nicelinks") <|> anyHeadString) just doesn't work, going all the way to the eof.... Can anybody help me?
02:50:43 <stobix> luite: so "forall (m :: * -> *) a. (Monad m)" basically says something in the lines of "for all monads such that they are the (->) monad"?
02:51:12 <luite> stobix: no that's something else, it's the kind of the type m
02:51:23 <luite> stobix: all monads have this kind
02:51:29 <mux> lambdabot only shows this because of extensions that are enabled
02:51:45 <luite> stobix: you can ignore that part for now
02:51:55 * stobix wants to grok
02:52:20 <stobix> could join be used with any monad, not just (b->)?
02:52:25 <luite> stobix: yes
02:52:52 <hpaste> chtaube pasted “getInt” at http://hpaste.org/49644
02:53:49 <chtaube> quicksilver: I wrote a function but it returns Nothing  http://hpaste.org/49644
02:54:08 <kamilc> Or asking a question a bit differently - How can I match in Parsec all chars that aren't head of some phrase ? We have in Parsec 'string' parser that matches given string - how can we match a string that doesn't match it?
02:54:37 <stobix> luite: Ah. Good. Hmm, so join is kinda the opposite of lift, if one can lift from a monad to itself?
02:55:08 <luite> stobix: not quite the opposite of course, you cannot "remove the m"
02:55:45 <quicksilver> chtaube: readInt is for returning numbers encoded as ASCII decimal numbers.
02:55:53 <quicksilver> chtaube: that is not what you want.
02:56:12 <quicksilver> you just want 'head' or 'take 2' with unpack
02:58:54 <chtaube> quicksilver: Ah, thanks!
02:59:12 <quicksilver> welcome.
02:59:22 <stobix> luite: hm, depending on how you define "removing of m", right? a function applied to arguments has some of its "m":s "removed", right?
02:59:26 <quicksilver> Data.Binary.Get is quite good at these kind of things, too, chtaube
02:59:41 <quicksilver> it's designed for going through bytestrings and pulling out fields of various byte lengths.
03:00:53 <luite> stobix: I mean that you cannot use join to do something like  m a -> a  (for any a)
03:01:11 <stobix> ah, yes.
03:05:25 <sebz> I was just reading http://existentialtype.wordpress.com/2011/04/16/modules-matter-most/ and I was hoping someone could explain this sentence to me:
03:05:38 <sebz> "As a consequence, using type classes is, in Greg Morrisett’s term, like steering the Queen Mary: you have to get this hulking mass pointed in the right direction so that the inference mechanism resolves things the way you want it to."
03:05:55 <absence> i'm trying to wrap my head around yampa. is parallel switching roughly similar to coroutines/fibers (cooperative multitasking) in that you can run several tasks in "parallel" (but sequentially) and have state tracked behind your back?
03:06:42 <quicksilver> sebz: that paragraph appears to misunderstand what type classes are for.
03:07:02 <quicksilver> "I tried to cross a river with an umbrellas, and I've concluded that umbrellas are very impractical devices"
03:07:17 <wolverian> I'm getting a big bunch of ld text reloc warnings installing she on osx lion. does anyone know if I can just ignore those warnings?
03:07:36 <quicksilver> certainly typeclasses are not a solution to the module problem
03:07:43 <quicksilver> which is what he's mostly writing about
03:08:08 <sebz> quicksilver: so how does Haskell provide that modularity?
03:08:13 <quicksilver> it doesn't
03:08:17 <quicksilver> as he correctly points out
03:08:33 <quicksilver> the thrust of his argument is right - many successful languages have done very poorly at solving the 'module' problem
03:08:50 <quicksilver> it's just unfair to complain that typeclasses aren't part of the solution - they aren't intended to be.
03:09:14 <sebz> okay
03:09:30 <sebz> so when will Haskell solve it? :) It seems like an important thing to have
03:09:31 <quicksilver> the criticism of a lack of a strong module system has been levelled at haskell by all kinds of smart people. There have been some proposals for how it could be fixed.
03:09:38 <quicksilver> no one has implemented any of the proposals
03:09:46 <sebz> I see
03:09:51 <quicksilver> apparently it doesn't matter enough to anyone capable of doing the work, or something :)
03:10:00 <geheimdienst> by "strong module system" you mean something MLish?
03:10:18 <quicksilver> geheimdienst: I was deliberately using a vague term because I don't mean anything in particular
03:10:35 <quicksilver> geheimdienst: there are a bunch of problems you might hope to solve and any one system probably won't solve them all
03:10:47 <quicksilver> certainly an MLish one would be one :)
03:11:12 <quicksilver> it would be nice to have a way to package a bunch of code as parametric over types and/or values and then instantiate it several times
03:11:12 <sebz> I guess the general requirement is the many-to-many relationship he talks about in the post
03:11:19 <quicksilver> which is what ML gives you.
03:13:57 <sebz> well thanks for the explanation quicksilver
03:26:09 <erus`> can haskell not do that?
03:27:53 <arcatan> @faq Can Haskell not do that?
03:27:53 <lambdabot> The answer is: Yes! Haskell can do that.
03:28:42 <aninhumer> Haskell can solve the halting problem? awesome
03:30:04 <quicksilver> yes, but no one knows how long it will take
03:30:26 <koala_man> since computers are only approximately turing complete, that's not such a big deal
03:31:32 <Nisstyre> koala_man: because they have a finite amount of memory?
03:31:35 <koala_man> yes
03:31:37 <aninhumer> You just need an opcode to ring a bell when it runs out of memory, civilisation develops new memory tech as necessary
03:32:32 <quicksilver> well you need portable code
03:32:39 <quicksilver> so that every 5 years or so you can suspend the running program
03:32:47 <quicksilver> and reawaken it on a more powerful host
03:33:03 <quicksilver> and that gives you infinite memory
03:33:07 <aninhumer> well you could just write layers of emulators
03:33:07 <quicksilver> (if you have enoguh patience)
03:33:28 <koala_man> then you just run your turing completeness app on a similar computer, which will eat the same memory just at an exponentially higher rate
03:33:37 <koala_man> erh, your halting problem app
03:35:18 <koala_man> or you just need 2x the memory if you're willing to rerun the app from the start at every step, to see if that state has been encountered before
03:35:34 <aninhumer> and then billions of years after civilisation dies out aliens land and find the computer
03:35:39 <aninhumer> It says "insert disk 2"
03:35:44 <koala_man> haha
03:37:18 <erus`> and they have no concept of a 'screen' so they dont understand what is going on
03:37:42 <erus`> nor pixels, nor that groups of pixels can make a larger pattern
03:40:49 <koala_man> their vision is based on gravity and they communicate with electric discharges and wait what are we doing again?
03:41:13 <cwl> how to import module SimpleJSON from ../ch05/SimpleJSON.hs
03:41:41 <cwl> import SimpleJSON x
03:41:51 <cwl> import ../ch05/SimpleJSON x
03:43:34 <erus`> is there a cross platform console/text lib
03:45:26 <mm_freak> how do i use ArrowApply in arrow notation?
03:46:24 <mm_freak> i thought, ArrowApply enables me to do this:  proc x -> f x <- someConstant
03:47:11 <TubeSteak> a quick question: suppose that lp is a list of string literals, then would the top level equation "lpBS = map BS.pack lp" be evaluated only once, no matter how many times it's called?
03:47:27 <quicksilver> TubeSteak: almost certainly.
03:47:39 <mm_freak> s/<-/-</
03:47:40 <quicksilver> however, there is a way it might not work like that.
03:47:53 <quicksilver> it might get inlined, and then fused, and then it no longer refers directly to the top level
03:47:56 <_Ray_> (The question would be "why do you care?")
03:48:19 <quicksilver> _Ray_: for example, because you want to be sure that 'lp' can be garbage collected
03:48:25 <quicksilver> that's why I'd care :)
03:48:47 * _Ray_ shrugs, doesn't care about implementation details :)
03:49:35 <TubeSteak> because I don't want it to be evaluated every time an expression containing lpBS is evaluated
03:50:28 <aninhumer> Hmm could GHC not partial evaluate it, and never have to do it at runtime at all?
03:51:02 <mm_freak> got it
03:51:05 <quicksilver> aninhumer: GHC doesn't really do any of that.
03:51:18 <_Ray_> TubeSteak, if there are no side effects to evaluating it, why do you care?
03:51:19 <quicksilver> it does very simplistic constant folding for numbers, I think.
03:53:44 <mm_freak> Cale: do you see a way to enable signal functions to use ArrowApply?
03:54:16 <TubeSteak> because lpBS is used as a parameter to a function passed to a fold over a very large list
03:54:40 <mm_freak> sometimes i would like to have that feature, because it would enable me to adjust the signal network based on signal values
03:54:42 <TubeSteak> so if it has be to be evaluated at each step, it will have a significant impact
03:55:12 <mm_freak> although ArrowChoice already gives me most of what i missed in yampa
03:55:13 <quicksilver> TubeSteak: you should be fine, I think.
03:55:25 <quicksilver> TubeSteak: even if it gets inlined it will get shared at a lower level.
03:56:17 <TubeSteak> i don't see it coming up in profiler, so I guessed it's fine, but wanted to get a general confirmation about it
04:09:40 <kamaji> What is the (($=)) at the end of this line: import Graphics.Rendering.OpenGL (($=))
04:09:52 <kamaji> Does it just say "the $= operator is defined in here"?
04:10:07 <luite> it means that you just import that function from the module
04:10:21 <kamaji> Oh right
04:10:27 <benmachine> and nothing else
04:10:31 <kamaji> Why the double brackets?
04:10:33 <benmachine> apart from instances which are always imported
04:10:38 <luite> kamaji: it's an operator
04:10:43 <kamaji> oh because it's usually (f1, f2, f3)?
04:10:45 <kamaji> right
04:10:46 <luite> yeah
04:10:53 <benmachine> kamaji: import Module (thing1, thing2, (+=))
04:10:55 <benmachine> yes
04:11:00 <kamaji> makey sensey
04:11:01 <kamaji> cheers
04:12:10 <quicksilver> if you do just want ($=) it would make more sense to import it from StateVar which is where it really comes from.
04:12:46 <kamaji> quicksilver: I'm just perusin' the GLFW example code
04:15:56 * quicksilver nods
04:49:25 <kamaji> quicksilver: Do you know of any good opengl tutorials for haskell like this: http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Table-of-Contents.html ?
04:49:33 <kamaji> I can't really figure out how to write that C as haskell
04:51:32 <gienah> kamaji: there are a few opengl haskell games like blozorz, monadius, maybe they might give some inspiration
04:52:07 <gienah> s/blozorz/bloxorz/
04:54:08 <kamaji> awesome names :D
04:54:15 <kamaji> I will take a look! thanks
04:59:46 * cwl hi
05:00:00 * cwl I love haskell
05:00:07 * cwl bye
05:13:56 * hackagebot BiobaseMAF 0.5.0.0 - Multiple Alignment Format  http://hackage.haskell.org/package/BiobaseMAF-0.5.0.0 (ChristianHoener)
05:18:18 <chrisdone> $ cabal-dev install
05:18:18 <chrisdone> Resolving dependencies...
05:18:18 <chrisdone> cabal: cannot configure Confy-0.1. It requires base ==4.1.0.0
05:18:18 <chrisdone> For the dependency on base ==4.1.0.0 there are these packages: base-4.1.0.0.
05:18:18 <chrisdone> However none of them are available.
05:18:18 <chrisdone> base-4.1.0.0 was excluded because of the top level dependency base -any
05:18:24 <chrisdone> can anyone explain this message?
05:18:37 <chrisdone> *what* top level dependency base -any?
05:22:57 <byorgey> chrisdone: what version of ghc are you using?
05:23:03 <benmachine> chrisdone: it's a rubbish error message. iirc it just means base can't be upgraded
05:23:13 <benmachine> (which indeed it can't)
05:23:31 <chrisdone> $ ghc --version => The Glorious Glasgow Haskell Compilation System, version 7.0.4
05:23:43 <benmachine> (or downgraded)
05:24:20 <byorgey> right, 4.1 went with ghc 6.10 or 6.12 or something
05:24:27 <byorgey> 7.0.x comes with base-4.3
05:24:36 <int-e> chrisdone: which comes with base-4.3.something, (ghc-pkg list base) and indeed cabal will refuse to downgrade (or upgrade) base.
05:24:48 <mm_freak> that's the difference between a newtype and a 'data' type with a strict argument?
05:24:54 <mm_freak> s/^that/what/
05:25:08 <chrisdone> i see
05:25:09 <byorgey> chrisdone: try just editing the .cabal file to relax the upper bound on base
05:25:15 <byorgey> probably it still works with 4.3
05:25:16 <int-e> chrisdone: so the ==4.1.0.0 looks very suspicious.
05:26:27 <byorgey> mm_freak: a data type with a strict argument still has to carry around a constructor tag.
05:26:27 <chrisdone> it was initially base > 4 && < 6, but then containers and directory had conflicts on what base they wanted. i set ==4.1 as a middle ground
05:26:47 <sipa> data Foo = Bar !Int
05:27:00 <byorgey> containers and directory had a conflict on what base they wanted!?  that sounds... fishy
05:27:04 <benmachine> it does
05:27:13 <mm_freak> byorgey: ok, but what's the implication?  i found my program to behave differently with 'data'
05:27:28 <byorgey> chrisdone: check to make sure you don't have an extra version of either of those installed in the local package db
05:27:36 <mm_freak> newtype = constant space, data with strict argument = heap overflow
05:27:37 <benmachine> containers and directory both come with ghc, don't they?
05:27:59 <chrisdone> i suppose it's because my project is aimed at 6.12.3 and i'm trying out 7. my project has strict versions to avoid build failures
05:28:11 <chrisdone> i'll try relaxing all versions
05:28:19 <chrisdone> (at least the core ghc ones)
05:28:23 <byorgey> mm_freak: hmm, I don't know, I'd have to see the code (although I don't really have time to look at the moment)
05:28:23 <sipa> mm_freak: are you asking about a semantic difference (i'm not sure there is), or an implementation different (which i am sure there is)
05:28:24 <benmachine> no it has strict versions to *cause* build failures, but nice ones rather than nasty ones :P
05:28:34 <mm_freak> sipa: semantic
05:28:38 <benmachine> well I guess they're configure failures in that case
05:28:51 <byorgey> mm_freak: stack overflow vs. constant space is not a semantic difference.
05:28:54 <benmachine> mm_freak: I wrote a wiki article on this I think
05:29:14 <benmachine> http://haskell.org/haskellwiki/Newtype it isn't actually very good
05:29:18 <mm_freak> byorgey: indeed, it's stack overflow
05:30:59 <mm_freak> benmachine: oh, that article actually helped
05:31:00 <mm_freak> thanks
05:31:15 <chrisdone> heh, now that the core configure failures are over all my dependencies. i'll be a few minutes…
05:31:24 <benmachine> :)
05:31:24 <mm_freak> it didn't solve my problem yet, but i understand the difference now =)
05:37:22 <chrisdone> omigod the configure errors stopped and it started building
05:37:46 * chrisdone waits for the first let generalisation errors
05:38:00 <chrisdone> i should expect that right?
05:39:05 <dmwit> no =)
05:39:44 <chrisdone> good. then the only think i'll expect to break is my haskelldb code
05:44:28 <kamaji> How do I look up what Graphics.Rendering.OpenGL.GL.Lequal is?
05:44:46 <kamaji> I mean I can probably guess, but I can't seem to figure out how to operate documentation~
05:45:04 <dmwit> ?hoogle Lequal
05:45:04 <lambdabot> No results found
05:45:15 <dmwit> Try Hoogle. The web thing works here.
05:45:20 <dmwit> http://haskell.org/hoogle/?q=Lequal
05:45:25 <dmwit> Very first result. =)
05:45:26 <benmachine> kamaji: you can get some information from :info in ghci
05:45:29 <benmachine> or :i for short
05:45:34 * chrisdone got past the mtl obstacle course
05:45:40 <benmachine> including where it's defined, which will help you find the docs
05:45:57 <dmwit> chrisdone: http://www.ihighfive.com/
05:46:11 <chrisdone> hahaha, 'place hand here'
05:46:53 <kamaji> Oh dangit! I needed to go deeper
05:47:00 <kamaji> welp that's helpful :D
05:47:10 <kamaji> thanks chaps
05:49:59 * hackagebot eurofxref 0.1.2 - Free foreign exchange/currency feed from the European Central Bank  http://hackage.haskell.org/package/eurofxref-0.1.2 (StephenBlackheath)
05:50:21 <chrisdone> ah, nice. i've used that feed before. nice service
05:52:59 <chrisdone> pthread_sigmaskerror: undefined reference to 'pthread_sigmask'
05:53:10 <chrisdone> i should specify -lpthread?
05:53:35 <chrisdone> libHSHDBC-mysql-10000.0.6.5.0.a(RTS.o):(.text+0x15): error: undefined reference to 'pthread_sigmask'
05:54:35 <chrisdone> odd
05:55:40 <chrisdone> okay i'm losing the will to live
05:55:43 * chrisdone uninstalls ghc7
05:55:46 <bxc> beer
05:56:01 <ivanm> chrisdone: yeah, I found my code was _slower_ with 7 than 6.12.3
05:56:08 <ivanm> I'm thinking it was an inlining issue...
05:59:24 <chrisdone> ivanm: odd. i did find that 7 was a lot slower at compiling last i tried it, probably got faster by now
06:00:41 <ivanm> I'm uninstalling the non-working llvm support now, to see if that fixes it
06:01:00 <ivanm> then again, my timing comparisons were only when running it with profiling; maybe profiling is just slower? *shrug*
06:01:49 * chrisdone realises that to fight the reddit trolls we ought to leave their comment karma at 1, which means 'neither hated nor liked, no one cares'
06:01:57 <ivanm> heh
06:02:08 <ivanm> anyone in particular?
06:02:15 <chrisdone> http://www.reddit.com/r/haskell/comments/j31f4/is_there_a_haskell_code_formatter/
06:02:26 * ivanm suddenly realises he hasn't seen harrop for a while...
06:02:42 <chrisdone> three comments relevant to the post, 13 feeding the troll
06:03:24 <ivanm> chrisdone: big problem with using hsx: it's _much_ stricter than GHC
06:03:33 <ivanm> so code that compiles will cause your program to crash
06:03:44 <chrisdone> hsx?
06:03:49 <ivanm> s/your program/it being parsed by hsx/
06:03:55 <ivanm> haskell-source-exts
06:04:40 <chrisdone> rephrasing: you mean hsx will not parse some source files that GHC will?
06:04:40 <ivanm> and that's not even including things like "I don't know what all the fixities of these operators are and thus how to parse them!"
06:04:45 <ivanm> chrisdone: yup
06:04:54 <ivanm> simplest example: empty where clauses
06:04:55 <chrisdone> sure. but which?
06:05:08 <chrisdone> not a big deal. anything else?
06:05:21 <ivanm> CPP: need to run cpphs first
06:06:07 <chrisdone> for the operator fixities it just reads them verbatim and the output will be verbatim, afaik
06:06:10 <ivanm> I believe ndm has a workaround for hlint, but when you have a non-standard operator using results from other non-standard operators as arguments, it doesn't know how to parse them
06:06:23 <ivanm> chrisdone: right, but your usage needs to be smart enough
06:06:34 <chrisdone> you mean the formatter?
06:06:45 <ivanm> yeah
06:06:48 <chrisdone> sure
06:07:05 <chrisdone> as long as the formatter doesn't add or remove parens it should be ok as the parens are explicit in hsx
06:07:19 <ivanm> I had a problem with that with SourceGraph; to try and "fix" it I then put in extra parens around the terms in the package it was failing on just so I could run it and then uploaded it to hackage... before realising I did the parens wrong :s
06:07:24 <chrisdone> if you put in x * 2 + (4 - 5) you'll get as output x * 2 + (4 - 5)
06:07:31 <ivanm> right
06:07:49 <ivanm> they were the main points I came across
06:07:50 <chrisdone> yeah cpp's tricky
06:08:10 <ivanm> for dealing with CPP, you need to know which flags to use with cpphs
06:08:17 <chrisdone> $ cabal-dev install encoding
06:08:17 <chrisdone> Resolving dependencies...
06:08:17 <chrisdone> /tmp/encoding-0.6.611325/encoding-0.6.6/dist/setup/setup: 4: Syntax error: ";" unexpected
06:08:17 <chrisdone> cabal: Error: some packages failed to install:
06:08:17 <chrisdone> encoding-0.6.6 failed during the configure step. The exception was:
06:08:18 <chrisdone> ExitFailure 2
06:08:19 <chrisdone> lol what ^
06:08:22 <ivanm> but if you're wanting to do round-tripping, then you don't really want to use cpphs at all
06:08:45 <ivanm> chrisdone: -v3
06:09:34 <chrisdone> does it do the same for you?
06:09:59 <ivanm> I don't use cabal-dev
06:10:06 <ivanm> and don't even have it installed atm actually
06:10:19 <chrisdone> son, i am disappoint
06:10:28 <ivanm> and since I'm currently rebuilding ghc with llvm support disabled, I'm not going to be able to do so for a while ;-)
06:10:32 <chrisdone> well encoding==0.5.2 works at least
06:10:32 <ivanm> chrisdone: O RLY?
06:10:39 <chrisdone> heh
06:10:49 <chrisdone> how long does ghc take to build on your machine?
06:10:57 <chrisdone> takes ~20 mins here
06:11:07 <benmachine> I think formatting cpp nicely is a lost cause :P
06:11:21 <ivanm> I think a tad longer than that here
06:11:32 <ivanm> benmachine: no, the point is how to deal with CPP macros in your haskell code
06:11:50 <benmachine> ivanm: if hsx is stricter than ghc that suggests that one of them doesn't follow the report, which sounds like a bug?
06:11:57 <benmachine> hsx *does* have bugs
06:12:22 <chrisdone> @faq can haskell programs have bugs?
06:12:22 <lambdabot> The answer is: Yes! Haskell can do that.
06:12:43 <ivanm> chrisdone: consider this: the two projects I'm currently working on are a graph-generator which only uses data-clist (which I keep sending sw17ch patches for :p) and planar-graph (which I haven't yet released); and graphviz, which is using libraries that are released (or else I'm writing/hacking on)
06:12:45 <jonkri> i'm thinking about moving my library from using an ugly Session object to start using a monad transformer instead. the problem is, i'm not exactly sure about the type. from the client's perspective, i want it to be like a State monad, holding the client's state. internally though, i want it to have the Reader capability to get a little bit of library-specific state needed by the library to operate (such as an internal event channel). how would you recom
06:12:45 <jonkri> mend that i start implementing this monad?
06:12:52 <ivanm> benmachine: hsx follows the report more strictly I think
06:13:04 <ivanm> jonkri: RWS ?
06:13:25 <benmachine> ivanm: do any programs actually use the greater flexibility of ghc? maybe we'd want to discourage that anyway for portability reasons :)
06:13:35 <ivanm> chrisdone: so cabal-dev is kinda useless to me because if I'm going to hack or patch a library, there's no reason why I shouldn't install it globally
06:13:53 <chrisdone> ivanm: yeah we've had this conversation previously
06:14:09 <ivanm> benmachine: OK, I found the empty where clause issue because I had removed everything from the where clause but left the actual keyword there
06:14:18 <ivanm> ghc is more lenient and just ignores it in cases like that
06:14:27 <ivanm> hsx might do so now as well, dunno
06:14:30 <chrisdone> yeah. that particular thing confused me once
06:14:34 <ivanm> chrisdone: yeah, it does sound vaguely familiar ;-)
06:14:43 <chrisdone> i find random 'where' clauses dangling in my code base and think 'wtf, why does ghc allow it'?
06:14:59 <ivanm> at the very least maybe have a warning in -Wall for it
06:15:02 <benmachine> heh
06:15:17 <chrisdone> yeah, nice idea
06:15:27 <benmachine> oh, the other thing with hsx as a code formatter is comments
06:15:39 <benmachine> they're stored only by source location
06:15:49 <benmachine> so if you're going to be moving stuff around you have to be pretty clever
06:16:06 <ivanm> is there anyone that actually uses hsx for any kind of round-tripping atm?
06:16:16 <benmachine> what exactly do you mean by round-tripping?
06:16:30 <ivanm> parse haskell in -> do stuff with it -> spit haskell back out
06:16:39 <benmachine> oh, isn't that how most people use it?
06:16:44 <chrisdone> benmachine: what do you mean comments are stored by location?
06:16:44 <jonkri> ivanm, first time i ever hear of it. will take a look. thanks :)
06:16:50 <ivanm> IIRC, the hare devs considered switching to it but it doesn't preserve enough semantic info or something (I think they wanted column numbers as well or something)
06:16:59 <benmachine> chrisdone: as in, when you parse a file with comments, what you get is an AST and a list of comments
06:17:06 <ivanm> benmachine: I don't spit Haskell back out again when I use it ;-)
06:17:16 <chrisdone> benmachine: ah, yeah, i see the type
06:17:18 <ivanm> and even hlint only spits out fragments, not the entire file
06:17:35 <benmachine> ivanm: oic. well, it's supposed to nowadays be able to prettyprint a file *exactly* as it appeared
06:17:41 <chrisdone> i love hlint, it's so clever
06:17:50 <ivanm> benmachine: it is
06:18:04 <absence> i'm trying to wrap my head around yampa. is parallel switching roughly similar to coroutines/fibers (cooperative multitasking) in that you can run several tasks in "parallel" (but sequentially) and have state tracked behind your back?
06:18:05 <ivanm> but then you get the problem you pointed out: if you do any kind of manipulation, how do you deal with comments?
06:18:15 <ivanm> I don't think I've seen any program that actually does anything like that
06:18:22 <chrisdone> ghc is churning at 100% on a module of encoding. for the past two minutes. i hope it's not stuck in an infinite loop
06:18:27 <benmachine> ivanm: using technology sufficiently advanced to be indistinguishable from magic
06:18:32 <ivanm> though some of niklas' pre-processers may do so (the embedded xml stuff, etc.)
06:18:36 <chrisdone> Data.Encoding.JISX0208
06:18:41 <ivanm> chrisdone: large data type?
06:18:46 <ivanm> as in heaps of constructors?
06:18:52 <benmachine> mm. my instinct is that preprocessors wouldn't need to keep comments
06:19:01 <benmachine> and that no-one actually uses the exact parser to its full potential
06:19:01 <ivanm> hmmm, true
06:19:30 <chrisdone> it's not even big: http://hackage.haskell.org/packages/archive/encoding/0.6.3/doc/html/src/Data-Encoding-JISX0208.html#JISX0208
06:20:04 <chrisdone> bah i think it's a ghc bug
06:20:17 <ivanm> chrisdone: it's decoding an erray which looks rather big...
06:20:32 <chrisdone> ivanm: which array?
06:20:51 <ivanm> well, that's what the function is called :p
06:20:55 <chrisdone> oh is that a compile-time array?
06:20:57 <chrisdone> heh
06:21:00 <ivanm> but there are two really long Strings in there...
06:21:02 <ivanm> chrisdone: I think so
06:21:12 <chrisdone> well i'll try again and leave it going for 5 minutes
06:21:25 <Phyx-> benmachine: i disagree, I use comments
06:21:27 <chrisdone> for science
06:21:34 <benmachine> Phyx-: oh?
06:21:36 <Phyx-> and their location is rather important
06:21:39 <chrisdone> if it doesn't work after that i'll just remove the module and have a local copy in cabal-dev
06:21:42 <ivanm> Phyx-: what do you use haskell-src-exts for?
06:21:57 <benmachine> Phyx-: their absolute location, rather than their source context?
06:22:27 <Phyx-> ivanm: hs2lib, creating dyn libs from haskell files
06:23:03 <Phyx-> benmachine: i need the function they 'belong' to. I use them as annotation. so I just match to the closest typesig
06:24:51 <jonkri> rws is completely undocumented
06:25:36 <Phyx-> ivanm: the things i grab from it are type sigs, datatypes, type synonyms, FFI statements and instance declarations
06:25:50 <chrisdone> jonkri: the reader/writer/state monad?
06:25:57 <chrisdone> where are you looking?
06:26:58 <joe6> i want to unit test some C code using test.HUnit. I could write FFI to all my C code and test it. Or, Is there a better way?
06:27:13 <jonkri> i guess the type documentation for the type RWS should be enough if i think on it hard enough :P
06:27:14 <jonkri> http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-RWS-Lazy.html
06:27:23 <jonkri> i didn't even get it stood for reader/writer/state :)
06:29:05 <jonkri> ivan: do you think it would be a good idea to newtype the monad transformer on top of RWST? it seems overkill since i don't need any writer functionality...
06:29:44 * jonkri thinks monads are a bit scary still
06:29:49 <ivanm> Phyx-: wait, doesn't ghc produce dynamic libs now?
06:30:34 * benmachine thinks RWS is silly
06:30:42 <int-e> RWST is just an optimisation (in performance and I guess ease of use), there's no new functionality over a stack of ReaderT, WriterT and StateT.
06:31:03 * hackagebot improve 0.4.0 - An imperative, verifiable programming language for high assurance applications.  http://hackage.haskell.org/package/improve-0.4.0 (TomHawkins)
06:32:00 <ivanm> benmachine: oh? why?
06:32:04 <Phyx-> ivanm: it's been stable since 6.10.3 or something afaik. I'm not talking about dynamic haskell libs, rather haskell libs compiled to say a dll
06:33:18 <benmachine> ivanm: because transformers
06:33:22 <benmachine> can do it all anyway
06:33:31 <jonkri> is it possible to have a stack of ReaderT and StateT, only expose the StateT, and make "lift" on the StateT monad go to the monad below the ReaderT monad (in effect, hide the ReaderT monad)?
06:33:41 <dainanaki> How do I use Data.Typeable's mkTyCon? I don't quite understand how to actually use the constructor that is being made from the string…
06:33:58 <Phyx-> :t mkTyCon
06:33:58 <benmachine> jonkri: yes, but then why do you have the ReaderT there?
06:33:58 <lambdabot> String -> TyCon
06:34:19 <ivanm> benmachine: yeah, but isn't it more efficient?
06:34:19 <benmachine> jonkri: if you newtype your monad and don't expose the constructor, you can choose what operations to allow on it or instances to define
06:34:54 <benmachine> ivanm: ...maybe?
06:34:55 <jonkri> benmachine, aha. can i add some extra (hidden) state to it?
06:35:05 <benmachine> jonkri: you can do whatever you like :P
06:35:05 <jonkri> that i can use internally
06:35:33 <benmachine> jonkri: I think what I would do is newtype a State monad and then define custom operations that could be used to fetch or set each part of the state separately
06:35:56 <mietek> @hoogle (Error e, Monad m) => Either e a -> (ErrorT e m) a
06:35:56 <lambdabot> No results found
06:35:59 <int-e> jonkri: right. and the newtype will hide the MonadReader/MonadWriter/MonadState nature of your monad from users.
06:36:09 <mietek> Whyyy
06:36:32 <int-e> (unless you wish to expose it. that's also possible, and quite easy thanks to GeneralizedNewtypeDeriving)
06:36:45 <benmachine> :t ErrorT . return
06:36:46 <lambdabot> forall (m :: * -> *) e a. (Monad m) => Either e a -> ErrorT e m a
06:36:52 <jonkri> ok nice, will give it a try :)
06:36:58 <benmachine> mietek: ^^?
06:37:56 <mietek> Hmm
06:38:03 <mietek> I am also confused by mtl vs transformers
06:38:12 <mietek> What's up with that?
06:38:21 <benmachine> mtl and transformers arose to solve the same problem
06:38:39 <benmachine> nowadays mtl is a re-export of transformers+monads-fd since their API is virtually identical
06:39:01 <benmachine> but all the cool kids use monads-tf anyways right
06:39:43 <mietek> Not helping
06:39:43 <mietek> ;)
06:39:59 <benmachine> these days there's no difference
06:40:11 <Phyx-> dainanaki: I think you should be looking at Data.Data instead
06:40:12 <mokus> transformers = mtl minus the "Monad*" classes
06:40:15 <benmachine> there once was, but then they got merged
06:40:32 <mokus> and with different module names
06:40:32 <Phyx-> dainanaki: that would allow you to synthesize a real type
06:41:44 <dainanaki> Phyx-: then what is data.dynamic useful for? Last night I was told that real types could be synthesized from data.dynamic?
06:41:55 <mietek> throwError :: (Monad m, Error e) => e -> ErrorT e m a
06:42:01 <mietek> (transformers)
06:42:09 <mietek> throwError :: e -> m a
06:42:11 <mietek> (mtl)
06:42:25 <benmachine> pretty sure that latter one isn't complete
06:42:32 <benmachine> there must be a context
06:42:58 <mokus> probably MonadError e m =>
06:42:58 <quicksilver> dainanaki: data.dynamic is for storing variables of "unknown" type along with a representation of their type.
06:42:58 <benmachine> mietek: ok, mtl has more stuff but depends on transformers
06:43:12 <quicksilver> dainanaki: data.typeable is for generating (at compile time) representations of types.
06:43:30 <Phyx-> dainanaki: Dynamic is to do dynamic typing afaik. synthesizing with Data.Data is still statically checked.
06:44:10 <Phyx-> dainanaki: but yes you can, from dynamic, "fromDyn" but not from typeable alone. e.g the Typeclass definition
06:44:40 <Phyx-> does unsafeCourse ever fail?
06:45:02 <mokus> depends what you mean by fail - it will never throw an error, but it can corrupt memory
06:45:04 <quicksilver> no.
06:45:07 <quicksilver> right
06:45:25 <benmachine> sometimes it'll cause the runtime to vomit everywhere, I think
06:45:39 <benmachine> usually it just segfaults :P
06:45:41 <Phyx-> heh
06:45:46 <Phyx-> nasty stuff
06:45:48 <dainanaki> So then, supposing that I had a string "Just", I'm not sure I that I see how to turn that string into a constructor that I can acutally use.
06:45:59 <benmachine> you'll need Data.Data for that
06:46:24 <quicksilver> constructors aren't really first class in haskell.
06:46:28 <benmachine> it's confusing and messy and weird and can't you just use Read?
06:46:36 <quicksilver> can you step back slightly and explain what you're really trying to do?
06:47:10 <quicksilver> the best way to turn the string "Just" into a function "a -> Maybe a" is to embed a haskell interpreter in your program
06:47:14 <quicksilver> Hint / mueval
06:47:45 <Phyx-> benmachine: even with Data.Data he would still need the type too afaik.
06:47:54 <dainanaki> I'm not trying to do anything in particular, I just was playing around.
06:47:56 <benmachine> Phyx-: yes, I expect so
06:48:02 <quicksilver> well everything in haskell is type checked at compile time
06:48:11 <quicksilver> so there are quite strong limits on what you can do.
06:48:30 <dainanaki> Right, I'm aware of normal haskell's limitations on typing.
06:48:31 <dmwit> f "Just" = Just -- a minimal Haskell interpreter
06:48:40 <benmachine> :D
06:49:03 <quicksilver> of course you can write the function: getMaybeConstructor :: (Maybe a) -> (a -> Maybe a); getMaybeConstructor (Just _) = Just; getMaybeConstructor (Nothing) = error "help I can't write this clause the types are wrong"
06:50:04 <Phyx-> dainanaki: given a datatype, and a constructor, you can create a value of that type, A nice excercise is to create a generic producer
06:50:15 <dainanaki> I was just curious if Data.Dynamic was somewhat akin to unsafePerformIO on a type level, where it would just take your word for it, try to pop out the constructor you asked for in a Just value, or else give you a Nothing if things didn't work out.
06:50:29 <Phyx-> e.g. a function that produces all possible values of a type up to a level
06:50:37 <benmachine> dainanaki: if your Typeable instances are sane then Data.Dynamic won't do anything dangerous
06:51:01 <benmachine> or "take your word for it" in any real sense
06:51:23 <Phyx-> Data.Dynamic also takes an actual value
06:51:32 <mokus> you could say it "takes your word for it" at compile time, but checks at runtime
06:51:41 <dainanaki> right.
06:52:13 <dainanaki> Sometimes I just expect these weirder libraries to do black magic.
06:52:15 <Phyx-> the only possible value out of Dynamic for "Just" is a String
06:53:17 <benmachine> Typeable's cast does do black magic, but in theory it needn't
06:53:21 <benmachine> I've heard, anyway
06:53:46 <dainanaki> Right, existential quantification over instances of typeable.
06:55:31 <mokus> one important limitation to keep in mind is that Dynamic only handles monomorphic values - so when you put something like Just in, you have to specify its concrete type
06:55:33 <chrisdone> ivanm: ghc 6.12.3 everything builds like a duck to water. my current theme tune is now http://www.youtube.com/watch?v=AaEmCFiNqP0
06:55:36 <mokus> > fromDynamic (dynApp (toDyn (Just :: Int -> Maybe Int)) (toDyn (pi :: Double))) :: Maybe Double
06:55:37 <lambdabot>   *Exception: Type error in dynamic application.
06:55:37 <lambdabot>  Can't apply function <<Int ...
06:55:46 <mokus> so you can't do things like that
06:55:59 <mokus> well, you can - the compiler accepts it - but it doesn't "work"
06:57:14 <quicksilver> mokus: which is in the reflection into the data.dynamic world of the fact that polymorphism isn't really first class in haskell.
06:57:31 <quicksilver> which is slightly ironic, given that the execution model supports first class polymorphism.
06:57:57 <Phyx-> wait wait, polymorpishm isn't first class in Haskell?
06:58:11 <quicksilver> you can't pass a polymorphic function as a function parameter.
06:58:14 <mokus> quicksilver: I think it would be possible to make a dynamic that tracked polymorphism, although tedious, at it wouldn't support type classes without exponential boilerplate
06:58:26 <mokus> s/at it/and it/
06:58:28 <quicksilver> mokus: there is an oleg trick for it IIRC.
06:58:55 <quicksilver> > (\x -> (x "string",x 3) $ id
06:58:56 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
06:58:56 <mokus> quicksilver: yea, I wouldn't be surprised at all if he's done it
06:58:59 <quicksilver> > (\x -> (x "string",x 3)) $ id
06:59:00 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
06:59:00 <lambdabot>    arising from the literal ...
06:59:14 <quicksilver> Phyx-: ^^ can't pass the polymorphic function id.
06:59:18 <Phyx-> oohh you mean like that
06:59:26 <quicksilver> that would be "first class polymorphism"
06:59:27 <dainanaki> Oleg scares me how smart he is.
06:59:33 <quicksilver> you can, in GHC, using higher rank types.
06:59:33 <Phyx-> riiight
06:59:36 <mokus> you can do it to a limited extent with GADT dependent-type emulation
06:59:38 <quicksilver> although of course that can't be inferred.
06:59:41 <mokus> and impredicative types
06:59:57 <Phyx-> quicksilver: wouldn't the better statement be GHC doesn't support first class polymorphisms?
07:00:08 <quicksilver> Phyx-: no.
07:00:11 <Phyx-> there are haskell typesystems that do support it
07:00:21 <quicksilver> Phyx-: it's the haskell98 / haskell2010 type systems that dont' support it
07:00:26 <quicksilver> GHC *does* support it, mostly.
07:00:32 <mux> isn't that called impredicative polymorphism?
07:00:33 <quicksilver> with higher rank / impredicative extensions.
07:00:44 <quicksilver> although it gets quite fiddly quite quickly
07:00:53 <Phyx-> quicksilver: but GHC still doesn't do impredicativity very well
07:00:58 <quicksilver> true
07:01:42 <mokus> GHC 7 seems to do it a bit better
07:01:52 <mokus> on the whole the "outsideIn(X)" system is pretty cool
07:02:53 <Phyx-> I think the whole flexible type approach is awesome, in type systems like HML. even though they can produce slightly more complicated types
07:04:04 <Phyx-> need to find some time to look at outsoudeIn one of these days
07:04:59 <mokus> it's a fairly long paper but a really interesting read
07:05:28 <Phyx-> well, it's long because it's written rather verbose isn't it?
07:05:48 <mokus> yea, if you already have a lot of type system background you should be able to skim it pretty fast
07:07:09 <Phyx-> wasn't GHC also switching to a dependenly typed core language?
07:08:13 <mokus> not that I recall, but I haven't read everything there is to read about GHC obviously ;)
07:09:26 <mokus> i think the type system is already equivalent in power to one though, so it would make sense to standardize the logic to something more well-studied
07:09:50 <hpaste> CandyClaws pasted “antialias” at http://hpaste.org/49652
07:09:56 <joe6> Phyx-: agda?
07:10:03 <mokus> it would be pretty cool if they did that to then make agda, et al., use ghc core as a backend
07:10:39 <CandyClaws> anyone have experience with opengl? I can't for the life of me get polygons antialiased. http://hpaste.org/49652
07:11:28 <chrisdone> did the -c option become mandatory in cabal-dev recently?
07:11:32 <dainanaki> Does anybody have any good strategies for how to cache things to disk for applications that use lots of memory?
07:11:38 <Phyx-> joe6: I'm not really sure how Agda is implemented. By the time it hits ghc most of the dependent types are gone or encoded in normal haskell is it not?
07:12:19 <jix_> CandyClaws: drawing antialiased polygons isn't supported by most hw opengl implementation... they only support forms of multisampling AFAIK
07:12:57 <mux> dainanaki: yes, let the OS handle it; the vast majority of the time it does it better than you can in userland ;-)
07:13:05 <jix_> CandyClaws: so to get AA you'd have to setup the opengl context with multisampling on instead of using the opengl smooth feature
07:13:40 <CandyClaws> cheers, will look into that.
07:14:13 <mokus> speaking of agda, what's the preferred backend these days?  is there any clear reason to prefer ghc over epic or vice versa?
07:16:04 <Phyx-> :t takeDirectory
07:16:05 <lambdabot> Not in scope: `takeDirectory'
07:17:01 <dainanaki> mux, the issue is that I have an app that has the ability (and sometimes needs to) load up more things than can fit into memory, and I need an explicit way to get data out of memory and onto disk.
07:17:54 <mux> dainanaki: that is precisely the reason why operating systems have a VM; you don't necessarily need to do anything yuorself, whether it fits into RAM or not
07:18:10 <mux> did you read the varnish paper? it's talking about that issue precisely
07:18:26 <mux> and explains how they manage to get something a lot faster than squid by relying on the VM
07:19:28 <gwern> > (3/1000) * 300000000
07:19:29 <lambdabot>   900000.0
07:19:55 <mux> dainanaki: of course, if your application will eat more and more memory with time no matter what, then you have to take the matter into your own hands
07:19:59 <chrisdone> $ cabal-dev ghci -s `pwd`/server/cabal-dev -c/home/chris/Projects/cn/confy/server/confy.cabal
07:19:59 <chrisdone> cabal-dev: user error (cabal: No cabal file found.
07:19:59 <chrisdone> Please create a package description file <pkgname>.cabal
07:19:59 <chrisdone> )
07:20:05 <chrisdone> it's like my whole toolchain is failing today
07:20:10 <chrisdone> i haven't done any programming at all
07:20:26 <gwern> chrisdone: ah, sounds like you have a case of bitrot
07:20:34 <gwern> chrisdone: take 2 reinstalls and call me in the morning
07:20:57 <dainanaki> right, it's largely a matter of me having data that I know needs to be freed that I can get from a database, but db access is too slow, so I need to keep the data locally somewhere, but not in memory.
07:20:59 * chrisdone thinking of calling it a day
07:21:27 <chrisdone> oh, nice. galois made their site look nice http://corp.galois.com/
07:21:46 <gwern> dainanaki: shouldn't you let the OS decide whether to keep it in memory or swap it out? it's pretty good at that
07:22:11 <luite> ooh they're hiring
07:22:42 <Phyx-> lol
07:22:46 <byorgey> mokus: I don't think GHC's type system is equivalent in power to a dependently typed one.
07:23:09 <byorgey> Phyx-: and the core language may eventually pick up some dependency at the kind level but not quite yet.
07:23:34 <Phyx-> byorgey: ah ok
07:24:29 <dainanaki> eh, \
07:24:29 <dainanaki> =
07:27:13 <Phyx-> geez, been trying to find a memory leak for over a month now
07:27:41 <dainanaki> ===========================================================================================================================================================================================================================================================================================================================================================================================================================================================================
07:27:41 <dainanaki> ===========================================================================================================================================================================================================================================================================================================================================================================================================================================================================
07:27:41 <dainanaki> ===========================================================================================================================================================================================================================================================================================================================================================================================================================================================================
07:27:41 <dainanaki> ===========================================================================================================================================================================================================================================================================================================================================================================================================================================================================
07:27:42 <dainanaki> =======================================================================================================================================================================================================================================================================================================================================================================================================================================
07:27:51 * chrisdone golf claps dainanaki's fail
07:27:52 <Phyx-> o.O
07:27:55 <luite> hmm
07:28:00 <dainanaki> cat.
07:28:15 <chrisdone> dainanaki: that's an ascii art of nyan cat?
07:28:34 <luite> it must be abstract
07:28:39 <Phyx-> hahahah
07:29:10 <quicksilver> cats++
07:29:21 <Phyx-> gaaaaaah
07:29:33 <Phyx-> compiling my code normally works
07:29:49 <Phyx-> compiling with --debug which just uses a different include doesn't
07:30:03 <Phyx-> and the error is thrown at an random spot half way in the file
07:30:31 <erus`> Phyx what does it say?
07:31:18 <Phyx-> erus`: it's having a mismatch, ghc is loading one module from the lib, and another from disk
07:31:42 <Phyx-> and I'm not sure why
07:32:14 <Phyx-> it doesn't do it for any other file, except those 4
07:33:03 <applicative> man the webpage for Proof General is ... uh, I don't know  ... http://proofgeneral.inf.ed.ac.uk/
07:33:09 <chrisdone> okay, i downgraded cabal-dev and it's fine now
07:33:19 <chrisdone> it's ten to five and i can start coding :)
07:33:32 <luite> nine to five here
07:33:33 <luite> :p
07:33:36 <quicksilver> chrisdone: nah, POETS!
07:33:54 <byorgey> applicative: ugly?
07:35:30 <chrisdone> quicksilver: are you shouting or acronyming?
07:35:33 <applicative> byorgey: yeah.
07:36:03 <quicksilver> chrisdone: Piss Off Early, Tomorrow's Saturday!
07:36:13 <ion> Pooping on each traversable structure.
07:36:16 * chrisdone beams
07:37:10 <byorgey> Persistently Overestimate Employment Time Slot?
07:37:52 <Phyx-> wtf did you guys drink
07:38:35 <danharaj> Kool-Aid
07:38:44 <benmachine> anyone got a vector haskell logo around?
07:38:45 <danharaj> or perhaps Ol-Aid, its categorical dual.
07:38:48 <Phyx-> oh man, haven't had Kool-Aid in years
07:39:00 * danharaj wacka wacka
07:39:35 <fazzone> benmachine: http://en.wikipedia.org/wiki/File:Haskell-Logo.svg
07:39:49 <Phyx-> benmachine: http://en.wikipedia.org/wiki/File:Haskell-Logo.svg ?
07:40:14 <benmachine> you are both super cool
07:40:30 <Phyx-> lol
07:41:02 <chrisdone> Phyx-: fazzone: dudes please, get out of my face
07:41:58 <Phyx-> oh oh, chrisdone is a nasty Kool-Aid drunk!
07:42:18 <chrisdone> http://chrisdone.com/crap/hpaste-hackage.svg
07:42:24 <chrisdone> now that's a haskell logo svg :D
07:43:05 <Phyx->  heh
07:43:17 <benmachine> pretty
07:43:26 <Phyx-> I don't particularly get why GHC is cherry picking modules...
07:43:52 <chrisdone> (yeah it took longer to upload than i thought so my 'oh please *link*' thing didn't work out and i looked like a guy who just blurts out insults :p)
07:44:19 <Phyx-> lol
07:44:28 <benmachine> :D
07:45:08 <luite> hmm, that h looks strange
07:45:29 <chrisdone> it's coloured slightly differently, a la hpaste: http://hpaste.org/css/hpaste.png
07:45:47 <luite> it looks too narrow somehow
07:46:24 <chrisdone> davidL: asked me about a new hackage logo, i think he's working on the new hackage design or something
07:46:54 <luite> hehe or any design at all ;p
07:47:16 <chrisdone> >_>
07:47:44 <luite> I had to check the site for the current logo, to find out that there was none :)
07:48:28 <Phyx-> i haven't been to the hackage site in a while
07:48:33 <Phyx-> would kill for a changelog though
07:48:39 <Phyx-> on packages
07:49:00 <luite> yes!
07:49:06 <luite> although I probably wouldn't kill for it
07:50:00 <Phyx-> lol
07:50:15 <Phyx-> I'd do whatever I could get away with :p
07:51:39 <mokus> i'd kill -9 for it!
07:57:45 <Phyx-> oh crap.. I broke it
08:04:04 <TubeSteak> finally i got rid of the space leaks in my program it seems: 150 files and still at 1.8GB
08:20:09 <Phyx-> does hackage run preprocessors in the setup file too?
08:22:19 <Phyx-> woooo
08:22:21 <Phyx-> finally
08:22:26 <Phyx-> --debug compiles
08:22:47 <chrisdone> stackoverflow comment: That's a nice GHCi prompt you have there. :]
08:22:57 <chrisdone> heh, people are always complimenting my ghci prompt
08:23:05 <Phyx-> eh?
08:23:17 <chrisdone> λ> 2 * 3
08:23:17 <chrisdone> 6
08:23:34 <c_wraith> chrisdone: you know he hangs out in here now, too? :)
08:23:43 <chrisdone> who?
08:23:45 * Phyx- blinks
08:23:48 <c_wraith> cmccann
08:24:01 <quicksilver> chrisdone's GHCi prompt is actually an ascii rendering of the lulzsec guy
08:24:03 <chrisdone> oki doki
08:24:06 <Phyx-> lol, i never get more then 3 - 4 upvotes on SO
08:25:10 <Phyx-> whoops, looks like I just stole an answer vote from someone
08:25:12 * Phyx- hides
08:35:59 <haskellangel> oh great haskell gods. i seek wisdom.
08:36:19 <Phyx-> they require a sacrifice before they speak
08:36:33 <haskellangel> reverse [1..]
08:36:40 <haskellangel> my cpu is yours
08:36:49 <ion> What did you expect to happen?
08:37:15 <HugoDaniel> haskellangel: do a sum [1..] instead
08:37:25 <haskellangel> :)
08:37:30 <Phyx-> heh
08:37:46 <Phyx-> i'm guessing that wasn't the question
08:38:01 <mokus> the Haskell gods require a type-level proof of Fermat's last theorem
08:38:09 <haskellangel> actually having trouble with  truncate (2345234524352435 /5) works but truncate (functionthatreturnsanInteger /5) doesnt?
08:38:23 <ion> :t truncate
08:38:23 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
08:38:28 <Phyx-> doesn't take an integer
08:38:30 <haskellangel> error: No instance for (RealFrac Integer)
08:38:34 <Phyx-> :t (/)
08:38:35 <lambdabot> forall a. (Fractional a) => a -> a -> a
08:38:45 <ion> > truncate (fromIntegral 2345234524352435 / 5)
08:38:46 <lambdabot>   469046904870487
08:38:55 <Phyx-> (5 :: Integer) / 2
08:39:00 <Phyx-> > (5 :: Integer) / 2
08:39:00 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Type.Integer)
08:39:00 <lambdabot>    arising f...
08:39:05 <HugoDaniel> thou shalt not forget fromIntegral
08:39:11 <Phyx-> :)
08:39:27 <Phyx-> haskellangel: Integer is not a fractional number
08:40:05 <Phyx-> haskellangel: ghc is treating both numbers in the first call as a fractional number (Double i think)
08:40:07 <applicative> haskellangel: in general these operations like / * + are supposed to have the same type on both sides.
08:40:10 <mokus> @check \x -> x `quot` 5 == truncate (fromInteger x / 5)
08:40:11 <lambdabot>   "OK, passed 500 tests."
08:40:48 <applicative> > 2 `quot` 5
08:40:49 <lambdabot>   0
08:42:11 <mokus> @check \x -> x `div` 5 == floor (fromInteger x / 5)
08:42:11 <lambdabot>   "OK, passed 500 tests."
08:42:31 <haskellangel> thankyou wise ones. i will return with more silly questions.
08:42:31 <applicative> > 2 `div` 5
08:42:32 <lambdabot>   0
08:42:56 <applicative> haskellangel: not silly all, it's the Num class...
08:43:09 <mokus> > ((-2) `div` 5, (-2) `quot` 5)
08:43:09 <lambdabot>   (-1,0)
08:43:23 * applicative doesn't pretend to have a better plan for numbers, of course
08:43:44 <Phyx-> Numb3rs
08:44:33 <ion> @check let a ==> b = if a then b else True in \x y -> y == 0 ==> x `quot` y == truncate (on (/) fromInteger x y)
08:44:34 <lambdabot>   Precedence parsing error
08:44:34 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
08:44:41 <ion> @check let a ==> b = if a then b else True in \x y -> (y == 0) ==> (x `quot` y == truncate (on (/) fromInteger x y))
08:44:42 <lambdabot>   "*Exception: divide by zero
08:44:46 <Phyx-> lol
08:44:47 <ion> @check let a ==> b = if a then b else True in \x y -> (y /= 0) ==> (x `quot` y == truncate (on (/) fromInteger x y))
08:44:47 <lambdabot>   "OK, passed 500 tests."
08:44:52 <ion> @check let a ==> b = if a then b else True in \x y -> (y /= 0) ==> (x `div` y == truncate (on (/) fromInteger x y))
08:44:53 <lambdabot>   "Falsifiable, after 4 tests:\n4\n-3\n"
08:45:13 <ion> I wish the real ==> worked with @check
08:45:58 <Axman6> @check y /= 0 ==> x `div` y == x `div` y
08:45:58 <lambdabot>   No instance for (Test.QuickCheck.Testable
08:45:58 <lambdabot>                     Test.QuickChe...
08:46:03 <applicative> @check let a ==> b = if a then b else True in \x y -> (y > 0 && x > 0) ==> (x `div` y == truncate (on (/) fromInteger x y))
08:46:03 <lambdabot>   "OK, passed 500 tests."
08:47:14 <ion> ==> returns a Property, which is potentially IO something, or something like that.
08:47:36 <Phyx-> 2 of 2 test suites (2 of 2 test cases) passed.
08:47:38 <Phyx-> sweet
08:47:48 <Phyx-> it compiles, but does it run
08:58:08 <savask> Hello. I'm messing around with llvm haskell bindings, now I'm trying to turn brainfuck interpreter from llvm examples folder to a compiler. The code I have now: http://hpaste.org/49650 The only problem is that I can't run it :-P lli says: "LLVM ERROR: Program used external function '' which could not be resolved!" Is it because of memset, or it's something else?
09:00:00 <ash__> um… it might be getchar/putchar
09:00:30 <ash__> external functions are functions your not defining, but memset is from the llvm.util library so I imagine that is fairly well tested
09:01:05 <savask> But my other LLVM progs which use external functions (like puts), produce nice and working bytecode.
09:01:23 <ash__> did you link your program with libc?
09:01:46 <savask> No. How can I do that?
09:03:37 <ash__> well, i am not as familiar with the haskell version of llvm, i have worked with the C++ one though,
09:07:39 <ash__> hmm, you could try changing all your linkages to ExternalLinkage or at least the mainf to external
09:08:29 * hackagebot logict 0.5.0 - A backtracking logic-programming monad.  http://hackage.haskell.org/package/logict-0.5.0 (DanDoel)
09:08:32 <ash__> you can only refer to internal linkages from within the module, i think main needs to be external
09:09:04 <savask> Nah, still doesn't work.
09:09:38 <ash__> when does it give that error?
09:09:40 <ash__> when you run it?
09:09:59 <savask> When I run bytecode produced by it.
09:12:25 <ash__> when i try to compile it i get undefined symbol hmm
09:12:53 <savask> To compile what?
09:14:00 <ash__> the haskell part of the code Undefined symbols for architecture x86_64:
09:14:01 <ash__>   "_LLVMAddLoopIndexSplitPass", referenced from:
09:14:01 <ash__>       _sogt_info in libHSllvm-0.9.1.2.a(Scalar.o)
09:14:39 <Axman6> are you using the latest LLVM?
09:15:01 <ash__> I have llvm-2.9, i am reinstalling via cabal now
09:15:01 <Axman6> the LLVM package is pretty version dependant. you should be using LLVM 2.9
09:15:04 <conal> anyone know how to query the running machine's IP address in a haskell program?
09:15:29 <conal> preferably across OSes.
09:15:34 <conal> (i mean portably)
09:15:45 <ash__> still doing it
09:15:57 <ash__> i'll try it on my linux box, i am on OS X
09:16:48 <monochrom> there is a chance Network.BSD.getHostEntry works
09:17:21 <savask> ash__: Oh, I use last LLVM from git, so I'm not really sure if it will work with the version from hackage.
09:17:24 <conal> monochrom: thx. i'll try it.
09:18:23 <conal> hm. on mac os x, getHostEntry gives: HostEntry {hostName = "localhost", hostAliases = [], hostFamily = AF_INET, hostAddresses = [16777343]}
09:18:40 <conal> maybe i have to deconstruct hostAddresses
09:19:34 <conal> i'm messing with the hums package, which is a UPnP server.
09:19:44 <ash__> can you tell cabal to install a specific version of the llvm?
09:19:56 <monochrom> there is also getHostEntries
09:21:56 <mokus> conal: that 'hostAddresses' is just 001 000 000 127 in base 256
09:22:15 <conal> mokus: thx.
09:22:59 <ash__> 127.0.0.1 is not all that useful...
09:24:26 <conal> indeed. and getHostEntries gives a second address, 4294967295, which appears to be 255.255.255.255
09:24:30 <monochrom> should use getHostEntries. getHostEntry is supposed to be called many times to iterate through many entries
09:27:31 <ash__> savask: so, llvm-nm shows there are 2 undefined symbols
09:28:25 <savask> ash__: Emm, does that mean that they are not linked? (sorry, I'm very new to LLVM)
09:28:49 <ash__> no, they were never given names for some reason
09:29:10 <savask> And they should?
09:29:11 <ash__> its an external symbol, so thats like doing: newNamedFunction ExternalLinkage ""
09:29:19 <ash__> notice the ""
09:29:19 <savask> Ah.
09:29:29 <ash__> i am not sure where they are coming from though
09:30:44 <ash__> they could be from newBasicBlock
09:30:50 <conal> so getHostEntries gives me two unhelpful entries (127.0.0.1 and 255.255.255.255). :(  any other ideas about how to get my IP address?
09:31:18 <hatds> anyone know about setting keyboard hooks in windows?
09:31:18 <lambdabot> hatds: You have 6 new messages. '/msg lambdabot @messages' to read them.
09:32:08 <ash__> in the llvm a BasicBlock represents as a chunk of code, so if you have any repeated code in a function you can define it once and say its in there twice
09:32:16 <ash__> they sometimes get turned into functions
09:32:40 <ash__> is there a bf example that doesn't use [ ] ?
09:33:04 <savask> Easy to test.
09:33:37 <quicksilver> conal: I think getHostEntries returns the contents of your hosts file not your own IP addresses
09:34:09 <conal> quicksilver: oh! sure enough. i have those two entries in /etc/hosts
09:34:46 <ash__> you could run a system command like ifconfig
09:35:00 <ash__> does windows have ifconfig? (i don't really develop on windows…)
09:35:45 <luite> ipconfig and netsh
09:36:16 <savask> ash__: If I understood you right, the bf prog without [] should compile into "good" bytecode.
09:36:24 <conal> ash__: apparently windows has ipconfig instead. the uuid package uses ifconfig & ipconfig and doesn't work on mac os x. probably a fixably broken parser, but i'm trying to avoid that route.
09:36:40 <ash__> savask: it might help us track the problem down, so ya
09:37:00 <savask> ash__: Then no, it still fails with the same error :-P
09:37:42 <mokus> conal: I'm pretty sure there is no reliable cross-platform way to do it; it's not really even well defined because systems can have multiple IP addresses and multiple interfaces
09:38:05 <mokus> maybe just Network.Curl to a site like whatismyip.com would be simplest
09:38:06 <conal> mokus: i see. thx.
09:39:04 <mokus> for info on local interfaces, parsing ifconfig/ipconfig or 'netstat -rn' would probably be the best option
09:40:58 <ash__> conal: are you looking for their external IP or their local network IP?
09:41:28 <ash__> eg, 192.168.0.100 vs 74.125.67.106 (google.com)
09:41:42 <conal> ash__: an address like 192.168.1.4 .
09:42:23 <ash__> what if a comp has more than 1 network interface?
09:42:26 <conal> it's to get media from my computer to show up on a TV on the same local network.
09:42:37 <conal> ash__: indeed. hm.
09:42:56 <olsner> on linux there is getifaddrs, I wonder if that exists on mac too
09:43:02 <mokus> is there a haskell library for zeroconf/avahi?
09:43:17 <mokus> registering a service on the server and looking it ip on the client would be nice
09:43:26 <ash__> getifaddrs is on OS X
09:43:33 <ash__> according to my man pages
09:45:44 <mokus> ash__: cool, I was looking for a semi-standard function along those lines - linux appears to have it as well, not sure if it's compatible though
09:46:02 <ash__> its in POSIX 1.2001
09:46:16 <ash__> so… posix compliant OS's should have it… probably
09:46:17 <mokus> ah, good to know
09:47:00 <mokus> if nothing else it means that any OS that has it should have a version that works basically the same as every other
09:47:38 <olsner> ash__: odd, my manpage says "Not  in  POSIX.1-2001."
09:48:51 <ash__> hmm, mine only mentions BSDi, i must of misread that sorry
10:07:39 <ash__> savask: so… doing llvm-dis on the a.bc && cat a.ll | grep 'call' you'll see where its making 2 calls to undefined functions
10:07:44 <ash__> @0 and @1
10:07:44 <lambdabot> Maybe you meant: . ? @ v
10:08:56 <savask> Hmm, really, 0 and 1.
10:09:02 <ash__> @0 is apparently: void* @0(void*, void*); and @1 is void @1(void*)
10:09:02 <lambdabot> Maybe you meant: . ? @ v
10:09:29 <ash__> those are the 2 undefined functions
10:09:35 <ash__> still don't know where they are coming from
10:10:29 <savask> Why running it within main program works then?
10:10:51 <ash__> it appears to be implicitly assuming they are external functions
10:11:17 <ash__> oh
10:11:22 <ash__> i see where they are coming from now
10:11:29 <ash__> 106: ptr_arr <- arrayMalloc wmemtotal
10:11:35 <ash__> and 114         free ptr_arr
10:11:49 <ash__> makes sense, they match the signatures
10:13:33 <savask> Why do they produce "phantom" functions then?
10:13:44 <hatds> anyone know what determines whether or not a windows application appears in the task bar?
10:13:58 <ash__> no idea
10:16:04 <koala_man> hatds: it's not shown if it's owned by another window
10:16:11 <savask> ash__: Thanks for your help. Now this problem is little clearer from me. Bye!
10:16:19 <savask> *for
10:19:52 <roconnor> are term algebras modulo algebraic laws always initial algebras?
10:30:35 <clsmith> hm, is there a way to check that your patterns match all possible variations of the given type?
10:30:51 <kmc> ghc -Wall
10:30:57 <kmc> which is generally a good idea
10:31:12 <kmc> it's not perfect, though
10:31:31 <ion> I use -Wall for toying in ghci, -Wall -Werror in the builds.
10:31:42 <clsmith> cool, thanks
10:32:11 <kmc> GHC keeps adding new warnings, though
10:32:18 <kmc> so a lot of code on Hackage is not -Wall-clean
10:32:47 <kmc> but I always shoot for making my projects -Wall-clean at least with GHC current as of upload date
10:33:23 <kmc> occasionally i'll disable a specific warning for a specific file
10:33:38 <roconnor> isn't clsmith's problem exactly what catch was designed to do?
10:35:03 <kmc> yeah
10:35:35 <clsmith> how so?
10:35:54 <kmc> clsmith, http://community.haskell.org/~ndm/catch/
10:35:55 <hatds> catch is much smarter than checking that your patterns are exhaustive
10:36:18 <kmc> "Unfortunately version incompatiblities mean that currently its very difficult to get Catch to compile. Hopefully at some point Catch can be ported to work on GHC Core, and Catch can be used on any programs which are compiled by GHC."
10:36:21 <hatds> it attempts to determine if your functions are total even though the don't cover all patterns and/or use partial functions
10:36:22 <roconnor> boo
10:36:50 <clsmith> ah! thanks. i was thinking the prelude function 'catch', and thinking, what?
10:37:09 <kmc> there's also a thing that works not by static analysis but by calling your functions
10:37:41 * hackagebot alms 0.6.1 - a practical affine language  http://hackage.haskell.org/package/alms-0.6.1 (JesseTov)
10:37:58 <kmc> forgot the name
10:38:12 <copumpkin> anyone looked at alms?
10:38:18 <copumpkin> alms for the poor
10:41:22 <kmc> gah trying to remember the name of this thing
10:42:24 <drdo> Where can i see what exceptions the network package functions might throw?
10:42:58 <kmc> actually i think i'm confusing it with another thing
10:43:05 <kmc> which was like an extension / alternative to QuickCheck
10:43:33 <kmc> which avoids varying the parts of the input that the function under test will not evaluae
10:44:15 <kmc> which i think is Lazy SmallCheck
10:46:09 <kmc> yes
10:52:12 <hatds> is there a way to tell ghci to load a specific .ghci file?
10:55:09 <Phyx-> is there syntax for qualified renamed import with an explicit import list?
10:55:10 <Phyx-> import qualified WinDll.Debug.Alloc ( free ) as F
10:55:17 <Phyx-> doesn't seem to be valid
10:55:38 <mokus> import qualified Foo as Bar (qux)
10:55:43 <Phyx-> ah
10:55:45 <Phyx-> ty
10:55:47 <mokus> yw
10:57:36 <gwern> > 13.2 * 300
10:57:37 <lambdabot>   3960.0
10:58:07 <ski> clsmith : `-fno-warn-incomplete-patterns' and `-fwarn-overlapping-patterns'. also `-fwarn-missing-methods',`-fwarn-missing-fields',`-fwarn-incomplete-record-updates' can be useful here
11:08:12 <ash__> is there a way to list which cabal packages are out of date?
11:11:55 <fazzone> what's with all the "somebody_ is now known as somebody"s?
11:13:57 * hackagebot mwc-random-monad 0.2 - Monadic interface for mwc-random  http://hackage.haskell.org/package/mwc-random-monad-0.2 (AlexeyKhudyakov)
11:15:23 <kmc> fazzone, various reasons, but often it comes from having your connection drop and coming back before the IRC server has kicked off your old dead connection
11:15:35 <kmc> many clients will use the nick foo_ if foo is taken
11:15:41 <ski> fazzone : network problems. the connection from the IRC client to the IRC server is for some reason broken. the IRC client notices this before the IRC server, so reconnects, but since the server hasn't noticed it yet, the client can't reuse the same nick, so many just add a `_' at the end
11:15:58 * hackagebot histogram-fill 0.5 - Library for histograms creation.  http://hackage.haskell.org/package/histogram-fill-0.5 (AlexeyKhudyakov)
11:15:58 <kmc> glorious surround sound
11:16:52 <ski> fazzone : then later, when the IRC user (or a scipt) notices, either they wait for the IRC server to expire the old nick so they can change back, or they send `/msg NickServ ghost my_nick password' to ask the IRC server to remove the "ghost" nick, so they can renick immediately after that
11:17:15 <fazzone> kmc,ski: ah, thanks!
11:21:03 <ash__> So… anyone in here mind helping me with a homework assignment, I need to interview a instructor/trainer and a novice student or novice learner about software engineering
11:23:01 <monochrom> I don't know how to do that in haskell
11:23:18 <ash__> ya, i know its not related to haskell
11:23:33 <ski> kmc : do you know any link to that alternative/extension to QuickCheck ?
11:23:42 <kmc> ski, it's called Lazy SmallCheck iirc
11:23:43 <monochrom> perhaps I would show them a monad-heavy program and ask them to make it applicative-only?
11:23:46 <kmc> it's on hackage and there's a paper
11:26:36 <joe6> need some design advice, please? I have some C code that I have to test. I want to use haskell for it. Should I just use FFI to the C code and use Test.HUnit to test it? or, is there a better approach?
11:26:57 <kmc> HUnit or QuickCheck
11:27:05 <ski> kmc : hm, ty
11:27:37 <ash__> if its in C there are unit testing frameworks for C
11:27:52 <ash__> unless you want to implement a haskell version of the interface
11:28:36 <ski> roconnor : are you talking about initial `F'-algebras ?
11:28:46 <roconnor> ski: yes
11:29:48 <ski> if they don't have any laws, they're called "anarchic `F'-algebras", i think
11:30:01 <monochrom> haha great name
11:30:04 <ski> so it'd be "archic `F'-algebras", if you have laws
11:30:07 <ski> (:
11:30:18 <monochrom> sherwood forests algebras
11:30:28 <monochrom> err, s/forests/forest/
11:30:38 <ski> i might have seen those names/terms in a paper by Bart Jacobs
11:31:17 <ski> roconnor : and yes, afaiu, they are always initial
11:31:40 <roconnor> ooh
11:31:42 <roconnor> archic
11:35:49 <ski> roconnor : this are all for "algebras" as opposed to "calculi", in the sense of <http://lambda-the-ultimate.org/node/533#comment-7712>
11:36:30 <monochrom> contradistinction? :)
11:36:48 <ski> for calculi, you'd either want to identify terms up to alpha-conversion (and maybe some simple things in some cases, like eta-conversion and beta0-conversion)
11:36:51 <monochrom> yikes, that is a real word :)
11:37:12 <roconnor> I think you can have free variables in combinatory logic
11:37:18 <ski> or you'd be using some variant of Higher-Order Abstract Syntax (HOAS)
11:37:23 <ski> sure
11:37:57 <ski> i'm not sure how to extend `F'-algebras (with or without laws) to handle alpha-conversion or HOAS, though
11:39:44 <orcus> hi, is there a built-in function to calculate binomial coefficients, or should I roll my own?
11:40:26 <roconnor> orcus: afaik you have to roll your own using product
11:40:27 <monochrom> find one on hackage or roll your own
11:41:02 <orcus> roconnor, monochrom: thanks, will do - just wanted to be sure I wasn't missing something obvious!
11:41:03 <monochrom> in some cases pascal triangle is faster than multiplication
11:42:17 <roconnor> monochrom: which cases are thoses?
11:42:20 <tromp> @let pascal  = iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1]
11:42:21 <lambdabot>  Defined.
11:42:33 <tromp> @let choose n k = pascal !! n !! k
11:42:34 <lambdabot>  Defined.
11:42:53 <roconnor> I guess if you are computing lots of different coefficents, using pascal's triange to memoize could be a win.
11:43:28 <roconnor> > choose 4 2
11:43:29 <lambdabot>   6
11:44:45 <tromp> > choose 40 20
11:44:45 <lambdabot>  Terminated
11:51:31 <ski> hm, there was some paper/presentation that i saw, which explained a way to build alpha-conversion into terms, so that you'd not have to manually prove every time that your constructions are extensional wrt alpha-conversion and that your relations respect it
11:52:01 <ski> rather, such properties would follow automatically from the induction principle used, which works upto alpha-conversion
11:52:14 <ski> but i can't seem to find the paper/presentation, now :(
11:54:37 <dolio> Nominal something?
11:54:40 <dolio> Nominal Agda?
11:55:04 <dolio> Nominal sets?
11:55:17 <kmc> this is a distinct idea from HOAS?
11:55:18 * danharaj Omnomnomnomnom
11:55:43 <dolio> Somewhat.
11:55:52 <roconnor> Nominal logic
11:56:02 <dolio> It depends what you mean by HOAS.
11:56:23 <hatds> ski: got your message about trivialFix / traceFix.  It was neat.
11:56:49 <dolio> It's like HOAS in twelf, where you have a 'data' type of lambda terms.
11:57:41 <dolio> At least, I think.
12:01:26 <benford> does anyone code on a mac, I'm having some problems with c liraries
12:01:46 <ash__> i work on a mac
12:03:30 <kmc> dolio, i don't know twelf -- what's the unusual property responsible here?
12:03:43 <ash__> what kind of problem benford ?
12:04:05 <dolio> kmc: The lambda terms in twelf aren't used for computation. They're more like a data structure.
12:04:14 <benford> i had problems linking with the zeromq library a while ago
12:05:12 <ash__> do you have the error messages or anything?
12:07:45 <benford> 2 secs - the wife has just turned up with dinner :-)
12:08:05 <Phyx-> benford: I want some too!
12:09:05 <ski> hatds : actually, i found i had an example usage post for it <http://hpaste.org/10061/example_usage>
12:09:59 <ski> hatds : though i have forgotten to add `type Traced a b = a -> (Trace a b,b)' which is needed to make the example run
12:15:44 <ski> dolio : lambdaProlog also has something similar to that. there's also a paper "An Extension to ML to Handle Bound Variables in Data Structures: Preliminary Report" by Dale Miller in 2002 at <http://www.lix.polytechnique.fr/~dale/papers/mll.ps> which describes an (unimplemented) extension to SML which does this
12:17:25 <dolio> ski: Yeah. Is that the kind of thing you were thinking of?
12:17:26 <benford> ash__:  Phy: given that the wife is a) home and b) has fed me - I might have to take this up another time. :-)
12:17:48 <ski> dolio : no, your comment about HOAS in Twelf made me think about that
12:17:54 <dolio> Oh.
12:18:03 <ski> ("you have a 'data' type of lambda terms")
12:18:09 <dolio> I'm not certain the nominal sets stuff is the same thing.
12:18:19 <dolio> So they may still be what you were thinking of.
12:18:29 <ski> the ML extension paper explains a way in which i think could be applied to Haskell as well
12:18:31 <conal> i'm trying to remember a package name. it contains functor-level product & composition and has instances for Functor, Foldable & Traversable. not functor-combo.
12:19:09 <ski> namely, adding a new datatype of "syntactical lambda-abstractions"
12:19:40 <dolio> Nominal sets may be something more fundamental that whole lambda expressions.
12:19:56 <dolio> Like, just the variables-up-to-alpha-equivalence part.
12:20:35 <ski> e.g. `@\X -> ..X..' would have type `a @-> b', where `X' has type `a' and `..X..' has type `b', and where `X' inside `..X..' works as a fresh constructor for the type `a'
12:21:53 <ski> so probably to do this in Haskell, you'd not allow this for every type `a', but instead insist on `a' having a constraint `Open a' which would mean that the type `a' is allowed to dynamically (temporatily) add scoped constructors to, like the above
12:22:49 <ski> and `f @$ x' would then take `f :: a @-> b' and `x :: a', and substitute the `X' in the body `..X..' of `f' which is `@\X -> ..X..' with `x'
12:23:03 <ski> also, you could pattern-match on `@\X -> ..X..'
12:24:08 <kmc> that pattern-matching is the advantage over straightforward HOAS?
12:24:45 <ski> dolio : hm, i think the paper (corresponding to the slides) i was thinking about was "Alpha-Structural Recursion and Induction" (Extended Abstract) by Andrew M. Pitts at <http://www.cl.cam.ac.uk/~amp12/papers/alpsri/alpsri-ea.pdf>
12:24:53 <conal> is there a collection of laws associated with the Foldable class?
12:25:09 <ski> kmc : yes. note that lambdaProlog also allows this. i'm assume Twelf does as well, but i don't know Twelf much
12:25:39 <ski> dolio : is the "nominal" thing you were thinking of "A nominal axiomatisation of the lambda-calculus" ?
12:25:51 <conal> HOAS works great when combined with quantifiers and implication, as in lambdaProlog
12:26:14 <dolio> ski: No, more like this: http://www.cl.cam.ac.uk/~amp12/talks/MGS2011_nominal_sets_slides.pdf
12:26:38 <dolio> http://www.cs.nott.ac.uk/~vxc/mgs/MGS2011_nominal_sets.pdf
12:27:27 <ski> @tell roconnor i think "Alpha-Structural Recursion and Induction" (Extended Abstract) by Andrew M. Pitts at <http://www.cl.cam.ac.uk/~amp12/papers/alpsri/alpsri-ea.pdf> might be useful in talking about term-algebra (actually term-calculi, then) upto alpha-conversion of bound variables
12:27:27 <lambdabot> Consider it noted.
12:27:33 <ski> dolio : ok, ty
12:28:04 <cheater_> hi does haskell have a library implementing confluence
12:28:13 <cheater_> thanks in advance
12:28:17 <dolio> And someone wrote a paper about doing that stuff in Agda, I think.
12:28:31 <dolio> That is, as a new feature for Agda.
12:29:15 <ski> dolio : if you find the paper, i'd appreciate to get a link to it
12:29:20 <ski> i must leave now, though
12:30:23 <dolio> ski: Oh, I think it's just those slides. They talk about his dream 'nominal Agda.'
12:30:45 <cheater_> hey i was thinking recently about something like a DSL in haskell for designing FPGA's.. and i was wondering.. would it be a good idea to put the clock skew through a part in the type of the function that describes this part?
12:52:54 <dankna> @hoogle random
12:52:55 <lambdabot> package random
12:52:55 <lambdabot> System.Random random :: (Random a, RandomGen g) => g -> (a, g)
12:52:55 <lambdabot> module System.Random
12:53:08 <dankna> @hoogle rand
12:53:08 <lambdabot> Test.QuickCheck rand :: Gen StdGen
12:53:08 <lambdabot> module System.Random
12:53:08 <lambdabot> System.Random class Random a
12:53:31 <copumpkin> @hoogle ayn
12:53:31 <lambdabot> No results found
12:53:36 <geheimdienst> @hoogle randomRIO
12:53:36 <lambdabot> System.Random randomRIO :: Random a => (a, a) -> IO a
12:53:58 <geheimdienst> dankna: that was the only thing i ever needed of all the random stuff :-)
12:53:59 <geheimdienst> ^^
12:54:23 <dankna> haha thanks :)
12:55:53 <ash__> how do you use just random? I tried the other day but I kept getting errors like: No instance for (RandomGen (IO StdGen))
12:56:36 <parcs> @hoogle randomIO
12:56:36 <lambdabot> System.Random randomIO :: Random a => IO a
12:57:41 <geheimdienst> ash__: i just say "x <- randomRIO (5,10)" to get a random number between 5 and 11
12:57:45 <ash__> I ended up using randomRIO
12:57:53 <ash__> ya, thats what I ended up using
12:58:05 <geheimdienst> ah i see :)
12:58:07 <ash__> but it still bugs me I never figured out how to use random
12:58:33 <ash__> s <- newStdGen; random s  -- gives Ambiguous type variable `a0' in the constraint:
12:58:33 <ash__>       (Random a0) arising from a use of `random'
12:59:09 <aninhumer> I'd guess random has a polymorphic return type?
12:59:15 <geheimdienst> i'm getting the feeling some packages (like time and random) are not really difficult to use in the end, but you would never know it from their haddocks
12:59:27 <geheimdienst> i guess we should do something about that somehow
12:59:37 <aninhumer> An examples section?
13:00:00 <ash__> an example would be nice, or test cases
13:00:28 <ash__> I looked for test cases but it was a bit vague (in terms of search terms) so I never found one, i did figure out randomRIO though
13:00:46 <kmc> ash__, you have to fix (one way or another) what type of random value you want
13:01:12 <kmc> s <- newStdGen; print (random s :: (Int, StdGen))
13:01:31 <geheimdienst> yeah, haddocks are absolutely starved of examples
13:01:45 <kmc> ash__, maybe you'd find http://hackage.haskell.org/package/MonadRandom nicer to use
13:02:21 <kmc> also the implementation of Random sucks
13:02:40 <kmc> use mwc-random if you need fast, high-quality random numbers
13:04:07 <ash__> do any implementations use drand48?
13:08:11 <drdo> Is there documentation on what exceptions might be throw by the stuff in Network?
13:12:43 <copumpkin> drdo: I doubt it
13:13:21 <drdo> copumpkin: How does one use it then?
13:13:44 <copumpkin> drdo: with any luck it doesn't use exceptions much in the first place
13:13:45 <copumpkin> I dunno
13:13:47 <copumpkin> haven't played with it much
13:14:00 <drdo> it does
13:15:41 <drdo> I can't find anything about it, i see people just catching every exception type
13:21:27 <zzo38> I made many improvements to the program for typesetting Bird style Haskell programs. Currently this is still the non-prettyprinting version. (If I make prettyprinting, it will be a separate file)
13:21:32 <zzo38> It doesn't work if you have an outer control sequence at the beginning of a paragraph, but now it makes \bye to be not outer.
13:23:32 <zzo38> The updated file is:  http://sprunge.us/YZfh
13:33:41 <stulli> What does ^{pageBody} do in hamlet? I didn't find any good documentation about it.
13:34:00 <stulli> *^{pageBody pc}
13:35:59 <zzo38> Do you think this updated file is better than the old one?
13:36:02 <zzo38> Is it good now?
13:38:30 <parcs> stulli: ^{a} interpolates a template 'a'
13:39:13 <zzo38> What does "hamlet" mean in Haskell?
13:39:37 <parcs> @hackage hamlet
13:39:37 <lambdabot> http://hackage.haskell.org/package/hamlet
13:39:45 <stulli> parcs: That's what i thought, i added ^{newTemplate} and then a newTemplate.hamlet file but it didn't work.
13:45:07 <ski> dolio : ok
13:47:26 <parcs> stulli: the x in ^{x} is a symbol, not a filename. you have to bind `x` in your controller to interpolate it
14:07:44 <roconnor> As far as I can tell kate doesn't make automatic backups, so when the system crashes you lose everything.
14:07:44 <lambdabot> roconnor: You have 2 new messages. '/msg lambdabot @messages' to read them.
14:08:01 <roconnor> So ... after today I won't be using kate to edit Haskell, or anything else.
14:08:28 <roconnor> any recommendations for editors?
14:09:01 <ash__> vim/emacs/gedit ?
14:09:20 <roconnor> vim I guess
14:10:35 <roconnor> IIRC when vim crashes there is some sort of .swp file left around that contains a recent version of your file.
14:11:38 <parcs> yep. it also has a persistent undo feature which can act as local version control
14:12:10 <ash__> you can control that as well, if you don't want swap files left in the same directory as the file you were editing, or changing the extension, or w/e
14:12:16 <roconnor> parcs: what's persistent undo?
14:12:42 <ash__> when you re-open a file you have edited before, you can undo in it from your last edit
14:13:05 <roconnor> neat
14:13:17 <ash__> i like the resume on the same line you last were on feature, if you close a line and your cursor was on line 123 column 4, and you open that file again, it resumes at that position
14:13:18 <parcs> very neat
14:14:32 <mike-burns> You can use :mksession to save your tab and split setup, too.
14:15:56 <mike-burns> Oh, and undo is saved as a tree, so you can traverse your undo branches as needed.
14:16:05 <roconnor> how do I do that?
14:16:35 <shapr> SyntaxNinja: y0
14:17:07 <mike-burns> Details under :h undo-branches
14:17:26 <mike-burns> It's something you have to play with; hard to explain quickly.
14:25:58 <danharaj> does this look like the pope to anyone else?
14:25:59 <danharaj> (x:xs):[]
14:26:30 <roconnor> a pope monkey?
14:26:36 <danharaj> redundant?
14:26:38 * danharaj ZING
14:26:46 * danharaj (forgive me holy father)
14:26:51 * danharaj wait I'm not catholic. ZING
14:28:42 <ville> either terence or philip as the pope?
14:29:00 <\yrlnry> The Pope hasn't actually worn the Papal tiary since (I think)the time of Paul VI.
14:29:15 <\yrlnry> Sorry, pretend i didn;t say that.
14:29:45 <\yrlnry> It looks to me more like a monkey with a beehive hairdo.
14:31:11 <stulli> Finally solved my problem with some help from the haskellers.com source code
14:34:50 <parcs> stulli: the interpolation thing?
14:36:14 <stulli> parcs: yes. i was able to define a hamlet file after all
14:36:55 <DukeDave> Hey gang, has anyone ever wrapped something in wxHaskell?
14:36:57 <parcs> stulli: ah, nice :)
14:38:07 * hackagebot hpuz 1.1.0 - Haskell bindings for libpuz  http://hackage.haskell.org/package/hpuz-1.1.0 (ChrisCasinghino)
14:39:30 * ccasin dances
14:50:32 <\yrlnry> dmwit: ping
14:52:05 <\yrlnry> dmwit:  http://is.gd/qHiYeK
14:54:39 <\yrlnry> dmwit: also:  https://secure.wikimedia.org/wikipedia/en/wiki/Borwein_integral
14:55:13 <\yrlnry> "These integrals are notorious for exhibiting apparent patterns that eventually break down. "
14:58:18 <azaq23> Related to those borwein integrals: http://en.wikipedia.org/wiki/Dirichlet_integral
14:59:17 * hackagebot graph-wrapper 0.2.4 - A wrapper around the standard Data.Graph with a less awkward interface  http://hackage.haskell.org/package/graph-wrapper-0.2.4 (MaxBolingbroke)
15:01:17 * hackagebot Diff 0.1.3 - O(ND) diff algorithm in haskell.  http://hackage.haskell.org/package/Diff-0.1.3 (SterlingClover)
15:20:13 <ddarius> -sM[floor]
15:24:30 * hackagebot jmacro 0.5.2 - QuasiQuotation library for programmatic generation of Javascript code.  http://hackage.haskell.org/package/jmacro-0.5.2 (GershomBazerman)
15:25:54 <MHD> anyone here ever messed around with the LLVM package? I'm having some trouble installing it.
15:26:09 <ash__> I have, whats up?
15:26:43 <MHD> Oh, you're here, I was looking for you. I have strawberry perl and the llvm-config is still messing up.
15:27:30 <ash__> whats it saying now?
15:28:03 <\yrlnry> Is there a Hac Phi IRC channel?
15:28:58 <ash__> well, here's what I would do, I'd do: cabal unpack llvm  or go to the cabal page for the llvm package and download the source
15:29:11 <ash__> then cd to that directory and try to run ./configure
15:29:16 <siracusa> \yrlnry: #haskell-hacphi
15:29:21 <ash__> and see if it returns any errors or not
15:29:29 <MHD> ash__: that's what I'm doing, here's what it says
15:29:45 <MHD> "/opt/local/bin/perl: bad interpreter: No such file or directory"
15:30:16 <\yrlnry> Thanks.
15:32:05 <ash__> MHD: where is perl installed?
15:32:20 <MHD> C:\programs\perl
15:32:23 <ash__> is it in /opt/local?
15:32:25 <ash__> okay
15:32:36 <ash__> look for the llvm-config file, and check the first line of it
15:33:14 <MHD> and the llvm-config file would look like?
15:33:33 <ash__> its a plain text file
15:33:43 <ash__> it should be in your llvmdir/bin/llvm-config
15:33:49 <ash__> its a perl script
15:35:12 <MHD> oh, right, I need to change the shebang, right?
15:36:09 <mdgeorge> hello
15:36:21 <ash__> i guess, but in all honesty I have no idea how shebangs in windows work
15:36:30 <ash__> but thats where that error is coming from
15:36:45 <mdgeorge> I'm trying to implement some geometry data structures, and I'm having some difficulty figuring out a good way to do it
15:37:02 <mdgeorge> let's say I wanted a Graph type
15:37:08 <MHD> ash__: It is the only place where it says opt/local/...
15:37:43 <mdgeorge> and I wanted to support the operations: neighbors :: Graph -> Vertex -> [Vertex]
15:37:44 <ash__> you could try #!c:\Programs\perl\bin\perl
15:37:49 <ash__> it might work
15:37:59 <Cale> mdgeorge: Use a Data.Map
15:38:04 <mdgeorge> and also removeVertex :: Graph -> Vertex -> Graph
15:38:07 <Cale> Map Vertex [Vertex]
15:38:53 <Cale> Or perhaps Map Vertex (Set Vertex)?
15:39:45 <ivanm> mdgeorge: any particular reason for defining another graph type rather than using an existing one?
15:39:47 <mdgeorge> Cale: I see, so the "pointers" would be indirected through the map, and to update the graph, I just change the map
15:39:52 <Cale> yes
15:40:02 <mdgeorge> ivanm: because I'm actually doing something more complex than a graph
15:40:07 <mdgeorge> but I didn't want to go into the details
15:40:12 <ivanm> please do!
15:40:31 <mdgeorge> ivanm: oh, I remember somebody told me to talk to you!
15:40:45 <mdgeorge> I'm trying to implement the doubly-connected edge list data structure
15:40:45 <Cale> (possibly me)
15:40:51 <mdgeorge> yes, I think it was, actually
15:40:59 <ivanm> heh
15:41:06 <Cale> You were interested in planar graphs?
15:41:10 <mdgeorge> yes.
15:41:19 <ivanm> I have a planar graph implemention I'm working on
15:41:31 <mdgeorge> so I heard.  what does it look like?
15:41:33 <ivanm> darcs get http://code.haskell.org/~ivanm/planar-graph
15:41:44 <ivanm> it's based upon the one in plantri
15:41:50 <mdgeorge> I'm trying to emulate cgal (http://cgal.org/), and the Arrangement package in particular
15:42:29 <gnezdo> Hello, anybody knows what's the successor of Data.Array.Diff, it went away in array-0.3.0.0?
15:42:34 <gnezdo> http://hackage.haskell.org/package/array-0.3.0.0
15:42:38 <ivanm> hmmm, hadn't heard of cgal
15:43:04 <ivanm> gnezdo: any particular reason for wanting it? my understanding is that it wasn't very performant
15:43:28 <Cale> I remember someone else trying to implement some stuff from CGAL in Haskell, but I think it was a different part of the library
15:43:40 <Cale> (it was convex hull stuff)
15:43:52 <gnezdo> ivanm: the structure of the computation is such that one element of the array is updated at each step
15:43:55 <ivanm> mdgeorge: the data structure is based upon a Map as Cale suggested, but every edge has an explicit inverse edge and also records which edges are before and after it going clockwise around the node it comes from
15:43:58 <mdgeorge> might have been me actually...I thought I'd play with that as a warm-up exercise :)
15:44:08 <gnezdo> not copying stuff seems like the right thing
15:44:11 <ivanm> Cale: sounds vaguely familiar...
15:44:24 <gnezdo> then again, maybe it's not of a concern, more of a curiousity
15:44:27 <ivanm> gnezdo: yeah, but IIRC Diff didn't perform that well when doing it
15:44:32 <mdgeorge> ivanm: that's the dcel structure pretty much
15:44:47 <gnezdo> another question: there's no such thing as scanM, what do people use it its place?
15:44:55 <mdgeorge> does your code have any kind of overlay operation?
15:44:59 <mdgeorge> or is it just topology?
15:45:02 <gnezdo> is it a pattern that's not common or interesting?
15:45:21 <ivanm> gnezdo: as in a monadic version of scan{l,r} ?
15:45:25 <gnezdo> right
15:45:27 <ivanm> I guess no-one's really needed it
15:45:35 <ivanm> mdgeorge: what do you mean by "overlay" ?
15:45:36 <Cale> When I wrote my naive Sudoku solver DiffUArrays performed best, despite the backtracking. That was back before Vector existed though.
15:45:42 <gnezdo> so people make do with ST instead?
15:46:04 <Cale> gnezdo: ST is a sledgehammer solution. There are lots of other datastructures to try :)
15:46:05 <mdgeorge> ivanm: given two planar graphs, construct a new planar graph that contains their union
15:46:37 <Cale> gnezdo: How big are the arrays you're updating?
15:46:38 <ivanm> how do you define union?
15:46:41 <gnezdo> the carryover state is an array of lists, one of the elements replaced at each step
15:46:57 <gnezdo> probably too small to worry, maybe a few thousand elements
15:47:00 <mdgeorge> http://www.cgal.org/Manual/latest/doc_html/cgal_manual/Arrangement_on_surface_2/Chapter_main.html#Section_30.9
15:47:37 <Cale> gnezdo: Have you considered using Data.Map? Is there a reason it's not appropriate?
15:48:22 <gnezdo> Cale: Map would do too, but a dense range of integer indices suggests an array :)
15:48:23 <ivanm> "geographic maps" ?
15:48:27 <mdgeorge> if the planar graph is actually embedded on the plane, then the union is what you get when you embed both graphs, and then split edges and faces as necessary
15:48:39 <MHD> ash__: Okay, I sic'd the shebang and the script runs. Other problems now.
15:48:41 <ivanm> yeah, still not following from that manual section :p
15:48:51 <mdgeorge> sorry, probably not the best reference
15:48:57 <gnezdo> It maybe a good idea though, because the array is not always dense
15:48:57 <Cale> gnezdo: Yeah, but updating a large array is expensive.
15:49:35 <Cale> gnezdo: Arrays are flat, and so you can't just replace part of them without copying the rest. Of course, the elements themselves don't have to be copied, just the pointers to them.
15:49:42 <ash__> MHD: yes?
15:49:53 <Cale> But still, that'll typically be overhead.
15:49:59 <gnezdo> Cale: yes, I get that. I think Map is a good idea. Data.IntMap especially?
15:50:12 <Cale> IntMap is good if it's appropriate
15:50:15 <ivanm> gnezdo: it usually performs better, yes
15:50:22 <mdgeorge> ivanm: this is what you get when you overlay two squares: http://www.cgal.org/Manual/latest/doc_html/cgal_manual/Arrangement_on_surface_2/fig/ex_22.gif
15:50:29 * ivanm is tempted to try and re-vive sw17ch's EnumMap library
15:50:34 <MHD> ash__: first of all it can't find the LLVM C bindings, is there some way to point the ./configure in the right direction?
15:51:04 <gnezdo> OK, I think Data.IntMap is the answer then. I take it incremental updates of Data.{Int,}Map are cheap?
15:51:09 <ivanm> mdgeorge: my data structure just encodes relative embeddings of the edges (i.e. ordering around nodes), not spatial information
15:51:19 <mdgeorge> I see
15:51:48 <ivanm> it is possible to currently say "merge these two graphs into the same data structure, and then take these pairs of nodes and make them the same"
15:51:59 <ivanm> the latter is done via adding an edge between them and then doing edge contraction
15:52:08 <ivanm> (might not be the best way of doing it but it seemed the most elegant)
15:52:13 <Cale> gnezdo: yeah
15:52:33 <gnezdo> cool, I'll give that a go then.
15:52:38 <mdgeorge> ivanm: I see
15:52:39 <ash__> do cabal configure --configure-option="--with-llvm-prefix=/path/to/llvm"
15:52:50 <ash__> MHD: ^
15:54:34 <ivanm> mdgeorge: hmmm, DCEL does sound similar to what I do, but I don't embed the Face information in the graph; instead I currently have a function that given a graph will return the faces in it and can create a dual from it
15:55:20 <mdgeorge> ivanm: the application I want to use it for is boolean operations on polygons
15:55:29 <mdgeorge> and of course to see what'
15:55:42 <mdgeorge> it's like to port a complex c++ library to haskell
15:55:43 <ivanm> mdgeorge: the distinction is because plantri just had pointers dangling around for face information that might not record anything in it until you actually ran a method on it to get the faces; I couldn't think of a nice way of saying "this either has face information or it doesn't"
15:55:51 <ivanm> mdgeorge: port or have bindings?
15:55:59 <mdgeorge> ivanm: port
15:56:05 <MHD> ash__: all right, that didn't help, but there's another issue that might be causing it, it says that some lines in the configure script are wrong. those lines appear to be polling llvm-config for various attributes such as version.
15:56:08 <ivanm> what do you mean by boolean operations on polygons?
15:56:19 <mdgeorge> like polygon union or intersection or difference
15:56:32 <ivanm> so, intersecting shapes, etc.?
15:56:36 <mdgeorge> yeah
15:56:44 <ivanm> yeah, my library is more at just creating planar graphs
15:56:53 <ash__> MHD: can you do: llvm-config --version ?
15:57:57 <MHD> ash__: no, wait a second, i think i know a fix
15:58:24 <ivanm> dammit, it's rather annoying to have to remember to add -rtsopts to ghc-prof-options in .cabal files
15:58:33 <mdgeorge> ivanm: well, I think I'm going to continue implementing my own thing, but your library looks like it will be a helpful reference
15:58:46 <ivanm> *nod*
15:59:22 <ivanm> stuff I haven't pushed to the repo yet (since I don't like the current hacky implementation I did just to get it working) includes PLANAR_GRAPH serialisation support
15:59:37 <mdgeorge> ah
16:01:26 <MHD> ash__: HA! now the llvm-config works
16:03:45 <MHD> ash__: All right, the "could not find LLVM C bindings" is presisting
16:03:54 <MHD> ash__: but that is the only thing afaik
16:04:09 <ddarius> Have you've gotten your daily allowance of HOD.
16:04:26 <ash__> scroll up, does the configure script say something like: configure: line 2394: error:: command not found
16:04:39 <ash__> or: checking for llvm-config... no
16:07:08 <MHD> ash__: It says "llvm-config-2.7.. no" but "llvm-config.. /yes/here's/a/path/" there's no "line XXXX error"
16:07:54 <ash__> the line after llvm-config what does it say? Mine says: Target platform inferred as: x86_64-apple-darwin
16:08:13 <ash__> after checking for llvm-config... /path/to/llvm i mean
16:08:27 <MHD> ash__: target inferred as i386-unknown-mingw32
16:09:54 <ash__> in the llvm directory do you have include/llvm-c ?
16:10:59 <MHD> ash__: yeah
16:11:37 <MHD> am I the only one to think that tab based file system browsing would be really cool?
16:12:40 <mikeplus64> MHD: what do you mean?
16:14:15 <hatds> a taskbar is quite like a tab bar, although with both you can have nested groups...  OSes usually add virtual desktops to do that though
16:14:16 <MHD> mikeplus64: I am quite the internet addict and I have tonnes of tabs open at any given time. If only the same could be done in file system browsing, i.e. "explorer" if you're on windows.
16:14:51 <hatds> I would agree except my hard drive isn't nearly as interesting as the internet :)
16:14:53 <mikeplus64> MHD: oh, that exists already :)
16:15:04 <ivanm> MHD: you can get file managers with tabs...
16:15:08 <ivanm> e.g. pcmanfm
16:15:18 <mikeplus64> dolphin, thunar, pcmanfm, ranger etc. have tabs
16:15:20 <MHD> all right, I'll look into it.
16:17:28 <\yrlnry> It turns out that although \x@(pattern) -> exp   is legal, \_@(pattern) -> exp  is a syntax error.
16:17:34 <\yrlnry> Is that expected behavior?
16:17:48 <sm__> any quick tips for tracking down the location of "error: Cannot decode byte '\x81': Data.Text.Encoding.decodeUtf8: Invalid UTF-8 stream" within a snap web app ?
16:18:00 <kmc> \yrlnry, yes
16:18:04 <\yrlnry> That's ghc 6.12.3.
16:18:07 <kmc> the lhs of @ is a variable, not a pattern
16:18:13 <kmc> it would be nice to have general union patterns, though
16:18:28 <\yrlnry> Yeah, that makes sense.  Thanks.
16:19:05 <kmc> \_foo@(pattern) should work, and GHC won't warn about unused vars if their names start with underscores
16:20:33 <hatds> I can't stand warnings about unused variables.. I mean it's unused, so what's the problem?
16:21:11 <kmc> hatds, it's a symptom of some other error
16:21:15 <kmc> a typo elsewhere
16:22:31 <kmc> all warnings are "so what's the problem"
16:22:52 <kmc> do you object to warnings in general?
16:23:42 <hatds> no :)
16:24:00 <Peaker> hatds: I caught many errors that way:   consider:   scale sw sh (Vector2 width height) = Vector2 (sw*width) (sh*width)
16:24:16 <MHD> i'm looking forward to the day the compiler let's you write the code just to humour your puny human intelligence
16:24:18 <Peaker> I had a similar error in my code -- "height" is unused -- catch the bug
16:24:41 <\yrlnry> Today I had an error caught by the type checker
16:24:49 <Peaker> hatds: basically, if you define things, typically they are meant to be used. If not then either you have an uncommon case, or a bug. In the uncommon case, you can just be explicit about it
16:25:16 <Peaker> hey, I just had an idea -- I would love to be able to say: "My provided type signature should be the principal HM type"
16:25:21 <hatds> when my functions pattern match on a constructor with several values it can look nicer and more uniform to always name the values
16:25:22 <Peaker> (it's only there as documentation)
16:25:42 <hatds> so I prefer "Constr x y file b" to "Constr x _ file _"
16:25:49 <Peaker> So if I make a buggy function that makes the type generalize too far -- my more specific type would mismatch the HM type
16:25:58 <\yrlnry> But the maintenance programmer prefers Constr x _ file _.
16:26:05 <Peaker> hatds: why not use by-name pattern matching?
16:26:36 <hatds> Peaker: perhaps you mean records?
16:26:47 <hatds> I'm not sure what by-name means
16:26:58 <kmc> hatds, that's why GHC will let you say Constr x _y file _b
16:27:00 <kmc> and not warn
16:27:43 <Peaker> hatds: Yes, if you use records, give names to your fields, then you can use:  myFunc (SomeConstr { fieldName = varName })
16:28:08 <Peaker> the definition is reversed from what you'd expect :-)    a = b   defines *b* to be the value of a, that's a bit ridiculous :-)
16:28:37 <Peaker> But there's an extension to say:  myFunc (Constr { name }) = ... name ...        that just gives the same name
16:28:45 <hatds> yea, and that's fine if you really want to have warnings enabled, but the underscores are less aesthetically pleasing, and it devotes mental attention to something which I want to be routine
16:29:08 <hatds> I don't use records, almost never
16:29:09 <Peaker> hatds: "this value is not meant to be used" sounds like it warrants plenty of attention..
16:29:10 <kmc> hatds, i agree there's a tradeoff here, but I think the bug-catching potential of the warning is worth it
16:29:26 <Peaker> hatds: then if you want to add a new field to a data constructor -- do you go and change a lot of places?
16:29:45 <kmc> i use records a lot but i'm never really happy about it
16:29:54 <hatds> Peaker: search and replace  (another advantage to naming all the fields.. this works seamlessly)
16:30:09 <MHD> why is it that you can't define :- as an operator?
16:30:19 <kmc> MHD, colon is 'upper case'
16:30:31 <kmc> it can be used for infix data constructors but not ordinary operators
16:30:41 <Peaker> hatds: if you use records, and avoid position-based indexing, it's both less error prone (assuming your fields are of same type) and doesn't need that
16:30:46 <MHD> wat
16:31:05 <kmc> data Pair = Int :- Int
16:31:11 <MHD> is colon the only operator char that can?
16:31:12 <kmc> f (x :- y) = x+y
16:31:16 <kmc> yes
16:31:22 <Peaker> MHD: Just like names can start with lower/upper case to denote values or data constructors,  so can "operator" names, start with colon or not to denote data constructors or values
16:31:38 <MHD> okay then
16:31:48 <Peaker> Why is the extension called "NamedFieldPuns"? Isn't a Pun a joke?
16:31:54 <geheimdienst> > let (-:-) = (+) in 1 -:- 2
16:31:55 <lambdabot>   3
16:32:08 <parcs> > filter ((==) <*> toUpper) ['\0'..]
16:32:09 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
16:32:16 <hatds> Peaker: I've thought a lot about records and I disagree. always saying  "Constr x y file b" with the same names x,y file and b is just like having positional independence
16:32:24 <kmc> Peaker, yeah, it's a joke where you use the same word to mean two different things
16:32:53 <Peaker> hatds: imagine merge conflicts
16:32:55 <kmc> Peaker, so as a joke (or a pun), people use "pun" to refer to situations in programming languages where the same name is used in two ways
16:33:09 <Peaker> kmc: Records are sad, not funny :)
16:33:14 <kmc> i.e. the name of a field and the local variable to which that field is to be bound
16:33:17 <kmc> Peaker, true
16:33:43 <cmccann> more like black comedy
16:33:50 <hatds> Peaker: I'm a sole hacker :) But I can see records have distinct benefits despite their much uglier syntax
16:34:02 <MHD> if only records had some good syntax (name somthing) looks stupid compared to (something.name)
16:34:21 <kmc> i really don't think that's the biggest issue
16:34:36 <ash__> i always thought punning in programming was http://en.wikipedia.org/wiki/Type_punning
16:34:37 <MHD> you're right
16:34:39 <mike-burns> Might not be the biggest issue, but it's the one I complain about the most.
16:34:45 <kmc> it "looks stupid" because people are used to generic OOP syntax?
16:34:57 <kmc> then i bet all of Haskell looks stupid
16:35:04 <erus`> we hate change!
16:35:28 <erus`> f x = x * x + x looks beautiful though
16:35:29 <mike-burns> I just think it looks bad.
16:35:35 <MHD> i ran into a problem where I wanted to define additional cases for a record field extractor function
16:35:55 <cmccann> pf, the ugliest part about record syntax is having to use curly braces
16:36:10 <Peaker> Well, languages where you repeat the type of everything everywhere -- can use the types to disambiguate record field names -- which makes them more pleasant.   Haskell not having type-directed name resolution makes type inference great -- but has the cost of record field names being "global" and non-pleasant..
16:36:32 <MHD> I had a data constructor for which there would be a default value of a field and I could not put that in there... it was frustrating.
16:37:22 <kmc> Peaker, GHC has an extension to resolve field names by type when they appear in label (not expression) context
16:37:38 <hatds> that's another reason I almost never use records. If I say "Constr x y file b" everywhere it isn't much different than having the field name be "x" itself, without the field name clashing at module scope
16:37:48 <dolio> Haskell has type-directed name resolution. It's called type classes.
16:38:12 <Peaker> Maybe each field name could auto-create a type-class:   class HasFoo r foo where getFoo :: r -> foo ; setFoo :: foo -> r -> r     and auto-instances for all records with Foo. i.e:  data Rec = Rec { foo :: Int }    would auto-instantiate   HasFoo Rec Int
16:38:24 <kmc> ugh
16:38:33 <ddarius> Schemes like that have been suggested.
16:38:51 <Peaker> ddarius: where does it lead? I haven't deeply thought about it
16:39:06 <kmc> don't use type classes just to reuse names for unrelated things
16:39:17 <kmc> that directly harms the ability of the type checker to detect mistakes
16:39:21 <ddarius> I agree with kmc.
16:39:28 <Peaker> dolio: I consider the choice of a method to be where the name resolution ends.. The implementation choice after that is not really a "name resolution", any more than passing a function as an argument causes the callee to "name-resolve" to the caller's function
16:40:05 <ddarius> I personally think a "local modules" extension would solve this problem in a reasonably elegant way and would have a much better power-to-weight ratio.
16:40:17 <Peaker> kmc, ddarius: But don't most of the fancy record systems allow things like making a function that merely cares about the given type having some field "foo"?  Isn't this essentially the same thing?
16:40:31 * cmccann concurs with the "local modules" idea
16:40:39 <Peaker> I just make normal modules :-)
16:40:50 <kmc> also scoped import / module open / whatever
16:40:55 <MHD> what is a local module?
16:41:04 <Peaker> Would local modules just have access to the module wrapping them, as if it is all auto-imported?
16:41:05 <kmc> Peaker, sure -- I'm not necessarily a fan of those fancy record systems, either
16:41:05 <MHD> and scoped import?
16:41:09 <kmc> it's essentially structural subtyping
16:41:13 <ddarius> Yes.  I agree.  There is no problem here other than modules being somewhat heavy-weight due to their (not Report required) binding to files.
16:41:15 <kmc> MHD, i want an import that scopes over only part of a file
16:41:26 <MHD> okay I get that.
16:42:07 <ddarius> Peaker: That's one design decision.  I don't think it matters too much either way, but it probably makes sense to have the enclosed module implicitly import the enclosing one unless an explicit import is provided.
16:42:12 <kmc> it's worth giving up some syntactic niceness to get better compile-time error checking
16:42:24 <kmc> though this view is a heresy to most of the programming world
16:43:03 <cmccann> a significant amount of the programming world happily gives up both for no apparent benefit
16:43:06 <cmccann> so that's not really saying much
16:43:50 <Peaker> kmc: Yeah, safety over convenience
16:43:56 <parcs> kmc: can you elaborate on how "that directly harms the ability of the type checker to detect mistakes"?
16:44:12 <Peaker> cmccann: not disagreeing -- but do you have some examples?
16:44:28 <mike-burns> I know I'm at HacPhi and all but practically, I'd give up safety for convenience.
16:44:29 <kmc> parcs, overloading a name means there are more contexts where that name typechecks
16:44:59 <kmc> sometimes you meant one use and you typoed as another use
16:45:38 <kmc> i remember writing «f >> g» when i meant «liftM2 (>>) f g» and not getting a type error
16:45:52 <ddarius> Good programming language design makes safety/correctness/performant and convenient the same.
16:45:53 <kmc> because (>>) works on both ((->) r) and IO
16:45:59 <cmccann> Peaker, just the general observation that most mainstream languages aren't really trying to get the best out of either
16:46:13 <Peaker> ddarius: surely sometimes there's a tradeoff between those
16:46:42 <ddarius> Peaker: I didn't say good programming language design was easy.
16:46:56 <kmc> there's a tradeoff, and an "efficient frontier" of that tradeoff
16:46:59 <cmccann> compile-time error checking verges on useless for most "static typed" languages, and few languages are designed with syntax niceness in mind, rather than syntactic familiarity from repeating yesterday's mistakes
16:47:34 <kmc> exactly
16:47:42 <kmc> nobody will take you seriously if your new language doesn't have "C-like syntax"
16:47:58 <kmc> yet oddly 1970's hairstyles and clothing fashions are not still popular
16:48:07 <\yrlnry> It appears that John Hughes' Twitter account has been compromised.
16:48:17 <\yrlnry> Does anyone here know him and can let him know?
16:48:21 <Peaker> ddarius: I believe the trade-off cannot be eliminated with any amount of hard-work, so at some point the language will have to sacrifice some amount of convenience for safety or vice-versa.  Consider also memory-management: The encoding of the most performant programs is probably not going to be using GC. Without GC you may be losing safety..
16:48:29 <ddarius> kmc: Most companies are not relying on 1970s hairstyles for their operation.
16:48:33 <cmccann> languages like Python at least attempt to consciously improve syntax, but abandon any and all static checking
16:48:56 <kmc> cmccann, right, I think Python may actually be close to the 'efficient frontier' at one extreme of the tradeoff
16:49:11 <kmc> Haskell is close in the middle
16:49:21 <kmc> Java is off in the corner ;P
16:49:45 <\yrlnry> Perl is under the table in the trash bin.
16:50:04 <kmc> PHP is out back behind the dumpsters doing unspeakable things for $5
16:50:05 <Phyx-> is there a writeFile version in haskell that also creates the directory is missing?
16:50:33 <kmc> Phyx-, no, but you can use System.Directory.createDirectoryIfMissing True
16:50:42 <Phyx-> ah, thanks kmc
16:51:02 <Phyx-> My profiler seems to be working on my first try
16:51:04 <Phyx-> \o/
16:51:06 <Phyx-> hurray
16:51:14 <kmc>  |
16:51:17 <kmc> /\
16:51:28 <stepkut> :)
16:51:51 <MHD> apropos leading edge in language design
16:51:55 <MHD> or what ever
16:51:58 <MHD> check out Cobra
16:52:18 <MHD> it's statically typed Python with all sorts of extras and it compiles to .NET/Mono
16:53:03 <ddarius> Lambdas -and- closures, plus static -and- dynamic binding.  Such a wealth of riches.
16:53:07 <kmc> they still seem to think of static types as primarily a performance feature
16:53:10 <cmccann> Statically typed in any meaningful way, or in the usual "you have to do extra bookkeeping to state the obvious" way
16:53:52 <monochrom> wait til lambdas and closures and objects and tapes :)
16:55:11 <cmccann> the languages of the future, soon to bring you the features of two decades ago
16:56:04 <monochrom> in a charset of 4 decades ago, too :)
16:56:06 <ddarius> cmccann: Including Hoare's billion dollar mistake.
16:56:06 <ash__> a lot of new languages go for 'minimal' as well, like go, it has very few keywords and a very small set of core features
16:56:41 <cmccann> ddarius, I really cannot fathom how that is not only still perpetuated, but that many people don't even see WHY it's a mistake
16:56:44 <cmccann> or how you can program without it
16:56:46 <kmc> right, for example, it has no polymorphism feature, just magical baked-in polymorphism for a few collection types
16:57:22 <kmc> cause it's inconceivable that people would implement new container types, right
16:57:30 <kmc> and certainly polymorphism is useless beyond simple containers
16:58:05 <niteria> how to use cps in languages that have not tco?
16:58:23 <cmccann> yeah, languages that try to be "minimal" almost never are
16:58:28 <ddarius> niteria: trampoline
16:58:37 <niteria> ddarius: ?
16:58:50 <niteria> I have javascript in mind
16:58:57 <cmccann> niteria, that's what the technique is called
16:59:03 <cmccann> look it up on wikipedia or something.
16:59:10 <cmccann> it's pretty well-established
16:59:25 <Peaker> cmccann: I remember having a hard time seeing how nullability types solve the problem.. These C-like languages have type-products, but no (simple) sums, so that it really cripples the ability to think about type sums
16:59:48 <monochrom> I say that uniform polymorphism is smaller than special-cased polymorphism, i.e., "you are allowed polymorphic functions" is shorter than "you are allowed polymorphic functions of arrays, lists, and hash tables only"
17:00:01 <kmc> niteria, basically, after every n tail calls, raise an exception to unwind the stack
17:00:08 <cmccann> Peaker, implementing tagged unions in C isn't exactly novel. :] Just doesn't type check case analysis.
17:00:15 <Peaker> cmccann: Would you consider Lua to be a minimal language?
17:00:23 <geheimdienst> cmccann: i think one reason for null is that in traditional eager languages, you'd be doing too much. leaving things null and only later initializing them allows you to be a little lazy
17:00:24 <cmccann> I don't know enough about Lua to say.
17:00:27 <Peaker> cmccann: Yeah, so it makes it hard to see how it solves the nullability problem :-)
17:00:48 <niteria> I thought I might just do setTimeout(next, 0) every n tail calls
17:00:52 <geheimdienst> ... but i completely agree that null is a terrible mistake
17:00:58 <Peaker> cmccann: The "trick" that's not obvious and not supported in most C-like languages is that case-analysis brings different variables into scope based on the runtime data
17:01:05 <cmccann> Peaker, also there's a design pattern for "have a special value to stand for a null value instead of a null reference"
17:01:16 <monochrom> my javascript cps trampoline example is at http://www.vex.net/~trebla/tail.html  see sure to see the code and comments
17:01:44 <Peaker> cmccann: Assuming you only have the C language in your thinking arsenal -- how do you have thoughts about fixing the nullability problem?
17:02:02 <cmccann> geheimdienst, I'm pretty sure that 99% of the time that's a syntactic issue, due to having large procedure blocks with stuff being declared before it's needed
17:02:35 <cmccann> Peaker, it's not C I blame, it's that most newer languages have actively gone in the wrong direction
17:02:37 <chipzimmy> join #haskell-hacphi
17:02:38 <Peaker> geheimdienst: but not having null means that you still have nullability, it's just explicit nullability -- so you still get to manually implement suspended computations
17:02:53 <Peaker> cmccann: well, their toolbox is not expanded much -- the thinking is still crippled
17:03:41 <Peaker> cmccann: we shape our tools, and then they shape us.  I remember as a C, C++, Python programmer, that nullability did not seem like an easy problem to solve, and I think my thinking was limited by the languages/idioms I had known
17:04:00 <cmccann> Peaker, agreed, I don't expect most people to solve the problem independently
17:04:16 <cmccann> It's the way that people actively reject the solution and don't see how it would even work
17:04:34 <geheimdienst> cmccann: yeah that's often an issue. i don't think it's quite as much as 99% though. consider that classes (java, obj-c, ...) declare lots of instance variables upfront, to be initialized later
17:04:38 <mike-burns> There's a whole hypothesis for this.
17:04:47 <geheimdienst> peaker: what do you mean by explicit nullability?
17:05:06 <augur> ok peeps, help me get this new haskell platform installed
17:05:20 <cmccann> geheimdienst, in an OO language instance variables would be initialized by the constructor
17:05:24 <augur> 64 bit refuses to install on lion, saying i need to install xcode, but xcode /is/ installed
17:05:33 <mike-burns> Hey let's not go blaming this on OO.
17:05:39 <Peaker> geheimdienst: You still have a "null", it's just called Nothing and marked in the type as "Maybe"
17:05:49 <mike-burns> augur: We at HacPhi were /just/ talking about how you shouldn't upgrade to Lion yet.
17:05:55 <mike-burns> Like, we're mid-discusion.
17:06:06 <augur> mike-burns: well, im talking with dankna
17:06:08 <ash__> i am running line, and everything works fine for me…
17:06:11 <augur> which is why this is coming up XP
17:06:24 <mike-burns> Well there we go.
17:06:35 <ash__> but i re-compiled ghc from scratch
17:06:43 <ash__> and then re-built the haskell platform
17:06:50 <dankna> mike-burns: wave
17:06:55 <dankna> so I can see who you are
17:07:04 <mike-burns> I'm the guy across from you.
17:07:13 <dankna> yes, hahaha
17:07:20 <dankna> I like how you just informed me of that through two separate channels
17:07:29 <mike-burns> yeah.
17:07:30 <Peaker> cmccann: I think people reject things they don't understand -- and people hate risking their time on learning something from "fringes", perhaps because most things from fringes are boring/useless waste of their time.  There's some merit in the approach of "let the mainstream filter filter this before I waste my time on it"
17:07:31 <cmccann> that's the power of technology
17:07:52 <dankna> now the question is, what should the penalty be when we catch people saying "lol" without laughing out loud?
17:07:55 <Peaker> cmccann: so it's really just the language designers to blame.. but those too are afraid of remaining outside the mainstream filter if they bring anything new
17:08:18 <hpc> dankna: three episodes of friends
17:08:19 <cmccann> Peaker, I understand that's why it happens, I just don't accept it as reasonable
17:08:20 <dankna> so anyway, because augur has me to support him
17:08:22 <dankna> hpc: OUCH
17:08:26 <dankna> I think it'll be okay
17:08:35 <dankna> because I am an unwilling expert on the subject :(
17:08:40 <hpc> haha
17:08:47 <Peaker> cmccann: the solution is to make Haskell so awesome that it displaces most mainstream languages :-)
17:08:53 <Dashkal> unwilling expertese.  the best kind
17:09:02 <cmccann> Peaker, yes, I endorse this plan absolutely
17:09:07 <augur> lmfao
17:09:15 <augur> dankna: is he really sitting /right across from you/?
17:09:29 <dankna> no, he's one seat left (from my perspective)
17:09:51 <Peaker> I'm somewhat at awe at how much *career programmers* don't want to learn about the state of the art of their most important tools -- languages
17:10:05 <dankna> I know right!
17:10:13 <dankna> it's an inconceivable attitude to me
17:10:15 <dankna> but it's why people burn out
17:10:26 <augur> this is hilarious, dankna
17:10:27 <dibblego> it's a predictable outcome
17:10:29 <dankna> it's why people fall behind technology
17:10:34 <Dashkal> There is an amazing number of programmers who firmly believe that learning is for university and it ends when they get employed
17:11:19 <dankna> yeah, exactly
17:11:53 <augur> Dashkal: these are people called engineers.
17:11:53 <dankna> but it's crazy.  with the world changing so fast, the person who isn't willing to learn cannot be called fully sane.
17:12:02 <ash__> anyone a teacher in here?
17:12:08 <dankna> former teacher
17:12:15 <dankna> but not of CS, of middle-school math and English :)
17:12:18 <augur> typically spiteful, low-intelligence jerks.
17:12:21 <augur> thats what i say.
17:12:51 <mike-burns> We're all teachers, in a way.
17:13:01 <dankna> true words
17:13:16 * cmccann certainly spends enough time teaching in some sense :P
17:13:34 <ash__> I kinda wish at my school they taught us an ML at some point, but we always ended up with lisp/scheme when we were doing "functional programming"
17:13:39 <dankna> yeah oh well
17:13:43 <cmccann> ash__, better than what I got
17:13:43 <dankna> school isn't for learning anyway
17:13:53 <dankna> school is for getting a piece of paper to make the business world understand your value as a person
17:13:54 <cmccann> all I learned was C++, taught by people who used it to write C
17:14:11 <cmccann> except for one guy, who tried to write Pascal in C++ instead
17:14:11 <augur> i think scheme is a good language for teaching certain aspects of FP
17:14:14 <gnezdo> cmccann: like guys, pascal here ;)
17:14:34 <ash__> my school is big on java most of the time, except for the like 4 old unix guys who always try to make you do stuff in C on Solaris (a very old solaris server)
17:14:53 <cmccann> ash__, do they have large beards?
17:15:00 <mike-burns> It's all good to know, though, right? Like, you can't be upset for learning something.
17:15:06 <Dashkal> dankna: value as a person?  Nah.  Value as a number
17:15:07 <ash__> no, unfortunately
17:15:14 <cmccann> they're probably frauds if they don't have beards. I think it's required for old unix guys who program C.
17:15:26 <clsmith> it is. there's a law.
17:16:03 <dankna> I am not a number!  I am a free man.
17:16:21 <ddarius> dankna: The piece of paper market got flooded due to declining standards and demand, so now the piece of paper indicates little and is little valued in many fields.
17:16:35 <ash__> one of them is a math major, who's been programming since i believe 1820, and once thought the sun went out when he was visiting a university in Tennessee because the temperature dropped like 40 degrees in an afternoon
17:16:50 <cmccann> ash__, hahaha
17:17:23 <dankna> ddarius: yes, and most of the solutions people are proposing to this problem involve moving pieces of green paper around, which is odd because on the whole it's not the pieces of green paper that are unhappy.
17:17:46 <dankna> the sun isn't going to go out anyway
17:17:49 <dankna> we're a main-sequence star
17:17:50 <dankna> it will blow up
17:18:05 <dankna> I don't know how the world will end, but the interesting part of it will end in fire
17:18:17 <dmwit> \yrlnry: pong
17:18:22 <dmwit> \yrlnry: thanks for the links
17:19:02 <dankna> augur: okay so I don't think my build of GHC will fix your problem
17:19:08 <dankna> because xcode isn't working for you
17:19:13 <dankna> oh hey
17:19:18 <augur> xcode is working fine for me
17:19:24 <dankna> well, rather
17:19:31 <dankna> because I can't reproduce your failure
17:19:34 <augur> the installer just refuses to believe its even there!
17:19:45 <dankna> bizarre!
17:19:46 <dmwit> \yrlnry: I can't wait to see the House episode of this. ^_^
17:19:47 <dankna> type "which gcc"
17:19:49 <ddarius> Most of the biomass of the earth may be -in- the crust.
17:19:57 <geheimdienst> augur: stupid question, do you have /Developer/whatever/bin/ in your PATH?
17:20:02 <dankna> the installer is a GUI app
17:20:08 <dankna> $PATH shouldn't matter
17:20:24 <geheimdienst> ... just checking ...
17:20:36 <ash__> on OS X /Developer shouldn't directly be in your path…
17:20:57 <augur> hold on a moment
17:21:20 <augur> aha!
17:21:26 <augur> i think ive found the problem
17:21:32 <dankna> oh good!  what was it?
17:21:34 <augur> when the appstore says that xcode4 was "installed"
17:21:40 <augur> what it really means is xcode4 was downloaded.
17:21:43 <dankna> ohhhhh
17:21:45 <ash__> I have ghc-7.0.4 with the latest haskell platform built (finished building this morning)
17:21:47 * ddarius wants a proton NMR machine.
17:21:50 <augur> it didnt /install/ anything
17:21:59 <ash__> on os x (the only reason I mention it)
17:22:05 <Peaker> I wish CL/Lisp finally got disassociated with FP/LC.  People think using an annoying syntax and having a powerful preprocessor is "functional programming"
17:22:11 <cmccann> ddarius, who doesn't?
17:22:16 <dankna> Peaker: true
17:22:27 <dankna> ash__: I have a build too (of HEAD from Tuesday)
17:22:33 <dankna> ash__: but I think it would fail in the same way
17:22:42 <MHD> Peaker: So true
17:23:04 <ash__> dankna: I am not that brave, to install HEAD, i just have the tagged 7.0.4
17:23:06 <augur> Peaker: i think people need to get over parentheses.
17:23:09 <dankna> gotcha
17:23:19 <Eduard_Munteanu> I could find use for an atomic force microscope :P
17:23:19 <Peaker> augur: sure.. but in what way does CL relate to FP at all?
17:23:26 <augur> oh, i dont know about CL
17:23:28 <dankna> yeah there ought to be MMO-game-style achievements for Haskell usage
17:23:32 * cmccann likes Scheme
17:23:37 <augur> but Scheme dialects are nice for FP
17:23:59 <dankna> and using HEAD for serious work ought to be one of the achievements
17:24:04 <augur> dankna: how about these achievements where like
17:24:09 <dankna> it would reward the title "the Insane" which would appear after your name on IRC
17:24:15 <augur> "New Achievement: You installed Haskell!"
17:24:17 <Peaker> I think Scheme is a nice language, as in, it's spec is elegant. Not sure it's so nice to use
17:24:24 <augur> "New Achievement: You saved your first Haskell source file!"
17:24:34 <ash__> Peaker: have you ever looked at racket?
17:24:36 <dankna> New Achievement: It typechecked!
17:24:37 <augur> "New achievement: You opened someone elses code for the first time!"
17:24:41 <Peaker> ash__: nope
17:24:50 <Peaker> It's called "Achievement unlocked"
17:24:54 <MHD> "New Achievement: You understood Hylomorphisms"
17:24:58 <augur> Peaker: whatever
17:25:00 <dankna> well, easy-to-get achievements give you fewer or no actual rewards
17:25:12 <augur> dankna: i was making fun of stupid achievements
17:25:17 <dankna> awesomely difficult achievements, along with achievements for doing things that are themselves stupid
17:25:32 <ash__> its the current name of PTL Scheme, they renamed it because they were diverging from the scheme standard enough that they wanted to change the name, but it can run in SR6 compliance mode if you want it to
17:25:35 <Peaker> ash__: http://racket-lang.org/  has a decidedly-non-FP example on the front there
17:25:50 <MHD> "Acievement Unlocked: Used more complex category theory than Monads in an actual project"
17:26:00 <ash__> but they have some interesting features to normal scheme, like a statically typed variant
17:26:35 <Dashkal> Achievement Get!
17:26:46 <dankna> Achievement Unlocked: Accidentally reinvented monads
17:26:49 <hpc> MHD: does using a transformer count? :P
17:26:57 <cmccann> I think this remains the top achievement: http://www.haskell.org/pipermail/haskell-cafe/2011-March/090256.html
17:26:58 <MHD> hpc: no
17:27:01 <Peaker> http://docs.racket-lang.org/quick/  <-- shows an imperative-style API for dealing with images, bah
17:27:15 <Dashkal> dankna: That would be most amusing if sprung on unsuspecting OOP programmers
17:27:20 <dankna> Dashkal: wouldn't it!
17:27:36 <Peaker> ash__: doesn't seem to be a very functional language, according to the main examples on the web site there
17:27:44 <dankna> cmccann: yeah that one should award a title AND a mount AND a small cash prize
17:28:08 <MHD> hpc: Come back when you use the deeper parts of Category Extras and then kindly teach me how you did it.
17:28:57 <Dashkal> That reminds me.  This weekend I want to learn wtf a comonad is
17:29:00 <\yrlnry> dmwit:  You are welcome.
17:29:32 <hpc> @where comonad
17:29:32 <lambdabot> http://www.eyrie.org/~zednenem/2004/hsce/Control.Comonad.html
17:30:03 <hpc> you might be able to discern all you need to know from the definition/laws
17:30:14 <ddarius> Dashkal: Consider monads in the 2-category of categories, Cat.  Then a comonad is a monad in Cat^co.
17:30:31 <Eduard_Munteanu> Dashkal: you could also look into sigfpe's blog
17:30:31 <Dashkal> Sadly, that's unlikely.  I have an issue learning either from type sigs or from category desdriptions (sorry, ddarius)
17:30:38 <ddarius> (Not to be confused with Cat^op or Cat^coop)
17:30:47 <ash__> Peaker: they have an experimental variant of scheme thats statically typed: http://docs.racket-lang.org/ts-guide/ its an interested experiment to say the least
17:31:03 <Dashkal> ddarius: Category theory descriptions don't work for me because I have yet to grok a category.  I've read the description a few times but I can't seem to digest it
17:31:27 <ddarius> Dashkal: So why do you even want to learn "wtf a comonad is" and why do you think you will succeed?
17:31:29 <Eduard_Munteanu> Well, then sigfpe's stuff should be palatable.
17:31:54 <Dashkal> ddarius: I want to learn simply because I don't know.  And I don't know I will succeed.
17:32:05 <Dashkal> Eduard_Munteanu: thanks for the pointer, I'll try that
17:32:20 <ddarius> Dashkal: Why do you want to know what a comonad is but not what a category is?
17:32:29 <Dashkal> ddarius: I didn'
17:32:31 <Eduard_Munteanu> http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
17:32:33 <MHD> I like making my monads by hand instead of using Transformers, because they are usually 5 or 6 argument continuations...
17:32:40 <Dashkal> ddarius: I didn't say I didn't want to know what a category is.  I said I can't grok it
17:32:53 <Peaker> ash__: static typing seems kind of orthogonal to FP though
17:33:22 <Dashkal> It didn't help that my math background ends in grade 12.  I never got into advanced concepts.
17:33:27 <ash__> ya, but its one of the only lisp's (and friends) I know thats statically typed
17:33:57 <ddarius> Dashkal: My "formal" math training ended in grade 12 as well.
17:34:09 <imc> I actually "saw" what really a monad is by working with scala's flatMap
17:34:10 <Peaker> I think "I've done FP" should mean "I did some pure FP in Scheme" or "I used some mostly-pure ML" and not "I wrote macros in CL" or used paren-syntax
17:34:33 <hatds> CL?
17:34:40 <ddarius> And comonad is a more advanced concept than category (which isn't advanced at all).  This is an objective statement as the definition of comonad relies on the definition of category.
17:34:43 <imc> as the "for" syntax it's a bit odd in my head, by explicitly writing in terms of flatMap (bind, really) suddenly everything becomes clearer
17:35:23 <Dashkal> ddarius: as does the definition of a monad, though I do grasp monads (after much pain)
17:35:33 <ddarius> (Actually, my formal math training pretty much ended in 11th grade.)
17:35:38 <Dashkal> ddarius: I have a different perspective is all.
17:35:46 <Eduard_Munteanu> *sigh*
17:35:54 <ddarius> Dashkal: How do you know you grasp monads?
17:36:03 <Dashkal> Eduard_Munteanu: thank you for the link, this looks accessible
17:36:11 <cmccann> more to the point, do you grasp the Monad type class in Haskell, or monads as a whole?
17:36:24 <cmccann> they aren't equivalent.
17:36:37 <Dashkal> I can see the pattern formed by bind, pure, and a one arg type constructor
17:36:41 <ddarius> (Incidentally, a [small] category is a monad in the bicategory of spans of Set.)
17:36:49 <Dashkal> and am able to apply it in languages other than haskell
17:37:18 <Eduard_Munteanu> ddarius is indeed an interesting example of how far you can get on your own
17:37:51 <cmccann> Dashkal, type constructors are unnecessarily limited, though
17:38:32 <Dashkal> cmccann: True.  I managed to implement the option and right-handed either monads in php.  They aren't a requirement.
17:40:13 <Dashkal> ddarius: Short form: In a formal sense, I don't claim to understand monads.  In a hey-I-can-use-this-pattern sense, I do.
17:42:07 <avartanian> I don't think there is a royal road to monads. Some combo of theory, practice, and time is what did it for me.
17:42:15 <geheimdienst> what's the public opinion on the haskell test framework and its source preprocessor thingy? harmless useful tool or weird hack?
17:42:27 <kmc> the way people talk about monads encourages you to think there's some deep mystical idea forever out of reach
17:42:33 <ddarius> geheimdienst: I don't know what you are talking about.
17:42:42 <mike-burns> Yeah, it's a type class. There are a bunch of them.
17:42:46 <kmc> it's self-perpetuating
17:42:50 <mike-burns> There's a Haskell test framework?
17:42:54 <kmc> everyone thinks there's some idea they don't get
17:42:54 <copumpkin> kmc: you mean Monads? those described in the scrolls? the scrolls of Monad, written by Lord Monad himself in the first age of Monad?
17:43:02 <ddarius> kmc: Indeed, monads are pretty early category theory.  Their original name was "standard construction."
17:43:06 <Dashkal> kmc: I admit that was part of what I got hung up on.  I felt better about my understanding whenI let go of that and just focused on the pattern
17:43:06 <kmc> so they make disclaimers like Dashkal's
17:43:16 <Phyx-> wow, geez, i'm rather surprised at how many allocations my little program did in such a short amount of time
17:43:19 <Phyx-> o.O
17:43:21 <geheimdienst> ddarius: http://hackage.haskell.org/packages/archive/HTF/0.7.0.1/doc/html/Test-Framework-Tutorial.html talks about a thing called htfpp
17:43:26 <avartanian> I will say though thay once you get them or feel comfortable with them, they seem simple, so people just starting out can feel frustrated that others don't share their pain.
17:43:44 <Dashkal> kmc: I make that disclaimer only when the depth of my understanding is cahllenged :P
17:43:47 <ddarius> Phyx-: It is impressive, but it is just adding to a number.
17:43:56 <Dashkal> wow, typos
17:44:11 <kmc> people also expect the various types implementing this API to have more in common than thy do
17:44:35 <ddarius> kmc: You should promulgate a mystique around a Magma class.
17:44:41 <cmccann> kmc, mostly because people aren't used to working with abstractions that actually abstract things significantly
17:45:03 <kmc> ddarius, yeah, it has a cooler name
17:45:04 * cmccann likes the Magma idea
17:45:19 <kmc> i'll write some magma tutorials with bad magma analogies
17:45:22 <Phyx-> ddarius: yeah, Though i'm only tracking explicit mallocs and frees that i use on my FFI code
17:45:24 <Eduard_Munteanu> Don't make me ponder magmoids
17:45:28 <cmccann> kmc, good plan
17:45:40 <Dashkal> and there goes my brain.  cojoin hurts
17:45:55 <ddarius> Eduard_Munteanu: Technically they would be magmoids.
17:46:12 <Eduard_Munteanu> ddarius: do you know 'join'?
17:46:14 <Eduard_Munteanu> :t join
17:46:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:46:27 * Dashkal assumes that was meant for him
17:46:34 <Eduard_Munteanu> Oh, right, sorry.
17:46:36 <Dashkal> Yes, I do grasp join.
17:46:57 <cmccann> I'm sure ddarius is trying his best to understand join, though
17:46:57 <ddarius> kmc: It would actually be a bit difficult to make a not completely arbitrary analogy for magmas.
17:47:02 <Eduard_Munteanu> :)
17:47:31 * cmccann wishes join was a slightly less overloaded name
17:48:09 <Saizan> you could build a story around glue
17:48:19 <ddarius> > join ["foo","bar"]
17:48:20 <lambdabot>   "foobar"
17:49:43 <Phyx-> @hoogle sizeOf
17:49:43 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
17:49:43 <lambdabot> Network.Socket.Internal sizeOfSockAddr :: SockAddr -> Int
17:49:43 <lambdabot> Network.Socket.Internal sizeOfSockAddrByFamily :: Family -> Int
17:49:51 <Phyx-> @hoogle size
17:49:51 <lambdabot> Data.IntMap size :: IntMap a -> Int
17:49:51 <lambdabot> Data.IntSet size :: IntSet -> Int
17:49:51 <lambdabot> Data.Map size :: Map k a -> Int
17:49:53 <kmc> sometimes i want to tell people that a monad is just any type for which someone has assigned an arbitrary but convenient meaning to the "do" syntax
17:50:06 <cmccann> kmc, problem is it's not entirely arbitrary
17:50:13 <cmccann> also the do syntax doesn't strictly need a monad anyhow
17:50:18 <kmc> this is probably as much a lie as the monad mystery hype, but it's in the opposite direction ;P
17:50:21 <cmccann> note that the desugaring rules never mention "return"
17:50:29 <geheimdienst> kmc: you know, that explanation is better than 80% of those out there, i think
17:50:44 <kmc> cmccann, yeah, good point
17:50:49 <copumpkin> cmccann: monad comprehensions would need it
17:50:53 <ddarius> The world was simpler before the onslaught of the monad tutorials.
17:51:05 <mike-burns> But trolling was slightly less fun.
17:51:16 <Eduard_Munteanu> And we're back to (co)semigroupads :P
17:51:18 <cmccann> copumpkin, plenty of stuff needs it, but do notation alone doesn't!
17:51:34 <ddarius> mike-burns: There were a lot less people in this channel then.
17:51:35 <Eduard_Munteanu> (without (co)return that is)
17:51:43 <kmc> also the do notation also doesn't use fmap
17:51:49 <Eduard_Munteanu> Ah, that's a bit out of context here.
17:51:51 <ddarius> (And presumably a lot less on Haskell-Cafe, and no reddit at all.)
17:51:53 <imc> what's next? "binals"? twice as misterious than "monad"
17:51:57 <cmccann> copumpkin, btw checked reddit recently?
17:52:18 <Eduard_Munteanu> Those would be dyads, IIRC something I gleaned over
17:52:19 <ddarius> copumpkin: You and I should have dinner or lunch some time.
17:52:26 <copumpkin> cmccann: yeah :)
17:52:30 <imc> dyads, right
17:52:32 <ddarius> Eduard_Munteanu: APL?
17:52:38 <copumpkin> ddarius: yeah, gonna be in philly this weekend, but next week sometime?
17:52:43 <imc> arrows aren't enough unfamiliar
17:53:06 <Eduard_Munteanu> ddarius: the language? Nah, I don't remember how I first saw "dyads" spelled out
17:53:22 <Phyx-> @hoogle random
17:53:22 <lambdabot> package random
17:53:22 <lambdabot> System.Random random :: (Random a, RandomGen g) => g -> (a, g)
17:53:22 <lambdabot> module System.Random
17:53:26 <cmccann> monadic and dyadic are terms for function arity used in APL-family languages, fwiw
17:53:35 <Phyx-> :t random
17:53:36 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
17:53:47 <kmc> so i'm once again toying with the idea of writing a Haskell tutorial
17:53:55 <imc> kmc: don't!
17:53:56 <imc> :P
17:53:58 <kmc> why not?
17:54:01 <geheimdienst> Phyx-: i can recommend randomRIO
17:54:08 <Eduard_Munteanu> Wha...
17:54:13 <Phyx-> geheimdienst: thanks
17:54:18 <imc> kmc: just joking
17:54:22 <kmc> ;P
17:54:25 <Eduard_Munteanu> If you just think about it, edwardk already did. (Or Oleg or...)
17:54:28 <Eduard_Munteanu> http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Dyad.html
17:54:31 <kmc> anyway what should i read before I go down this path?
17:54:38 <kmc> i've read parts of RWH and LYAH but neither cover to cover
17:54:44 <Eduard_Munteanu> Comes up if I google 'dyad category theory' :)
17:54:51 <kmc> i'd be aiming for a style much different from either
17:55:01 <cmccann> kmc, whatcha have in mind?
17:55:02 <imc> my tutorial would be.... it's the best language ever, you have plenty of tutorials and books and people, examples and all
17:55:05 <imc> just write
17:55:22 <ddarius> kmc: Except that I don't know if you're the person to do it, something vaguely SICP-ish but with a much stronger bent on typeful programming would be nice.
17:55:31 <kmc> yeah
17:55:37 <ddarius> I've considered doing it, but I doubt I'm the person for it either.
17:55:40 <kmc> though i can't put my finger on what makes SICP good concretely
17:55:44 <cmccann> ddarius, someone else was suggesting that in here a few days ago
17:55:53 <kmc> it might just be that everyone says SICP is good because someone they respect told them it was good
17:56:07 <cmccann> I was also tempted, except for the "probably not qualified" part
17:56:09 <ddarius> I liked SICP quite a lot.
17:56:14 <imc> oh... best tutorial every is the typeclassopedia, imho
17:56:27 <kmc> typeclassopedia is not a Haskell tutorial, though
17:56:46 <imc> it isn't
17:56:47 <hatds> because it's not a "tutorial" or it's not "Haskell"?
17:56:48 <ddarius> Best monad tutorial: Wadler's 1992 "The essence of functional programming."
17:56:54 <imc> not tutorial
17:57:04 <imc> ddarius: interesting ...
17:57:04 <danharaj_> The tutorial I read was "Gentle Introduction to Haskell"
17:57:09 <kmc> you can call it a tutorial in something, but it doesn't claim to teach Haskell as a whole
17:57:13 <danharaj_> (spoilers wasn't gentle)
17:57:25 <hatds> I liked a gentle introduction
17:57:28 <ddarius> I like The Gentle Introduction quite a bit.
17:57:31 <hatds> :)
17:57:35 <imc> kmc: i think that's the best thing i've read that "teaches" the "whole"
17:57:44 * Eduard_Munteanu wonders if Moggi alluded to do syntax and what we use today in Haskell
17:57:47 <imc> other stuff are more about basics and syntax
17:57:48 <Eduard_Munteanu> in his original paper
17:57:51 <hatds> I didn't learn from it exclusively, but it was what I was reading on day zero so to speak
17:57:56 <ddarius> Eduard_Munteanu: Yes, only he used a let-based syntax.
17:57:57 <imc> like the two wiki books
17:58:11 <Peaker> I used a combo of Gentle and Yet-Another-Haskell-Tutorial.. I remember not liking them
17:58:12 <Eduard_Munteanu> I see.
17:58:12 <kmc> cmccann, I wanted to go for a simple, clean style of writing, and particularly avoid describing Haskell features in terms of other languages
17:58:25 <ddarius> Eduard_Munteanu: He knew about ML and monads pretty directly give a semantics for let in an effectful language (which was the point and is why (>>=) is called "bind.")
17:58:26 <cmccann> kmc, I like that idea
17:58:34 <danharaj> To be honest I didn't feel like I got Haskell until I did the implementations in Pierce.
17:58:41 <Eduard_Munteanu> Oh.
17:58:41 <kmc> LYAH puts a lot of effort into being cute / funny / non-threatening, and RWH puts a lot of effort into being "real world" and convincing skeptical "industry programmers"
17:58:42 <danharaj> That was fun.
17:58:52 <kmc> and that's fine for them, but I'd not go down either route myself
17:59:14 <cmccann> kmc, yeah, if nothing else some people are put off by LYAH's style
17:59:25 <kmc> and people are put off by RWH's style too
17:59:34 <cmccann> and RWH is not really an intro to programming so much as a crash course in doing things in Haskell
17:59:51 <Eduard_Munteanu> kmc: that reminds me of Pro Git vs other fluffier Git tutorials
17:59:54 <kmc> yeah, i really like a few of RWH's "topics" chapters even though I already knew Haskell in general when I read them
18:00:03 <kmc> Eduard_Munteanu, how so?
18:00:04 <ddarius> How can you not know that you'd be put off by LYAH's style ahead of time?
18:00:08 <cmccann> well, LYAH seems to provoke stronger reactions because some people find the cutesy style grating
18:00:32 <Eduard_Munteanu> kmc: well, just what you said about aiming for a "professional" audience
18:00:40 <ddarius> cmccann: So why do they read it/continue to read it?  It's not like there aren't alternatives?
18:00:49 <kmc> one question is to what degree you're trying to *convince* people to learn haskell
18:00:50 <ddarius> s/?$/./
18:00:51 <cmccann> ddarius, I think most people who dislike the style don't keep reading it
18:00:51 <Eduard_Munteanu> Oh, don't forget Wikibooks.
18:01:03 <kmc> RWH seems to do a fair amount of that
18:01:05 <hatds> we could use an entry level Haskell tutorial that doesn't punt discussing evaluation order and space usage
18:01:16 <cmccann> they either switch to something else like RWH, or they go on /r/programming and complain about how Haskell sucks
18:01:26 <kmc> hatds, yeah, one place to start would be exercises evaluating in a simple graph-reduction model
18:01:38 <imc> good... found what to read.. the essence of functional programming, thank for the suggestion ddarius
18:01:41 <MHD> hmmm.... generically typed modules,,, how would that work
18:01:46 * imc goes in standby mode
18:02:04 <ddarius> kmc: Just call-by-name reduction is already most of what one needs and, apparently, more than many know coming in.
18:02:11 <Eduard_Munteanu> IMHO, LYAH indeed looks a bit verbose.
18:02:22 <cmccann> kmc, I've been considering the idea of starting with a more lambda-calculus flavor to begin with
18:02:33 <cmccann> specifically a typed lambda calculus
18:02:33 <kmc> "Haskell sucks, the language is about monads but they won't even explain what a monad is until chapter 10"
18:02:45 <Eduard_Munteanu> Maybe a bit too much to use as a reference to come back to, rather than a tutorial.
18:02:46 <imc> oh... and the other enlightening thing, a part the typeclassopedia, was an article about "metaphors" on the Monad.Reader... just great
18:02:58 <kmc> @where burrito
18:02:58 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
18:03:07 <imc> kmc: that's it
18:03:08 <cmccann> yes
18:03:13 <geheimdienst> kmc: with the question "what a monad is" being something of a red herring anyway ...
18:03:18 <kmc> ddarius, if you want to address performance issues, though, you need graph reduction
18:03:20 <cmccann> that's why "burrito" is everyone's favorite monad analogy now
18:03:31 <kmc> and i think it'd be best to introduce the two in quick succession
18:03:42 <imc> no well, i was referring to the actual monad.reader article
18:03:55 <ddarius> kmc: Eventually you need a call-by-need reduction strategy (i.e. someway of notating sharing) but you can already talk about many performance issues with just call-by-name.
18:04:01 <MHD> when I explain monads I prefer to take it from "let's look at this function that returns Maybe"
18:04:22 <cmccann> I'm currently leaning towards telling people to forget about monads as the first step, honestly
18:04:33 <kmc> i think the lambda-calculus approach is impossible if you take the evangelical stance
18:04:34 <geheimdienst> cmccann++
18:04:38 <kmc> but i'd be happy to abandon that
18:04:42 <Eduard_Munteanu> Maybe introducing do-notation desugaring earlier on might make sense.
18:04:46 <cmccann> to just use pattern matching on stuff like Maybe, and to treat do notation as a procedural mini-language with effect tracking
18:05:01 <Eduard_Munteanu> It's not really complicated and it provides a good example from imperative programming.
18:05:18 <cmccann> kmc, I meant in the context of something SICP-like, in a "start from scratch" sort of approach
18:05:19 <kmc> a tutorial does not need to say "no, I promise, Haskell is really great, please keep reading noooo don't leave me" on every page
18:05:21 <kmc> right
18:05:32 <cmccann> I recall SICP doing some stuff with untyped lambda calculus
18:05:53 <kmc> it does a lot of stuff in a pure subset of scheme
18:05:59 <kmc> which is basically an untyped lambda calculus
18:05:59 <cmccann> yeah
18:06:08 <imc> kmc: I've just read "Programming in Scala", not too long, well explained, never boring... pretty good work presenting/teaching/selling the language
18:06:08 <kmc> with data, but they even talk about church-encoding those
18:06:14 <ddarius> kmc: If you can travel back in time and make a series of video lectures in the '70s, that will help too.
18:06:34 <kmc> basically if you take this first-principles approach you abandon the idea of reaching the skeptical audience, who's kind of interested in Haskell but heard that it's hard and "mathy"
18:06:43 <kmc> that's okay, maybe they're better off reading LYAH
18:06:59 <cmccann> kmc, yeah, but you don't have to reach everyone with everything
18:07:05 <kmc> exactly
18:07:19 * ddarius would shorten it to "you don't have to reach everyone."
18:07:23 <cmccann> the first-principles approach is something that neither LYAH or RWH really do
18:07:36 <imc> ddarius: the abstract of the essence of functional programming is just perfect to me :P
18:07:59 <imc> it's about monad. monads are useful for this this this this and this and also this
18:08:02 <Eduard_Munteanu> That mightn't be a good idea... didn't work well here at least: http://www.smbc-comics.com/index.php?db=comics&id=1854#comic
18:09:21 <hatds> I think you would have a refreshing perspective if you went ahead with this tutorial, kmc
18:09:24 <ddarius> Eduard_Munteanu: The goal isn't to provide technology to the past, but to use past technology and benefit from '70s production quality, hairstyles, and clothing.
18:09:35 <danharaj> also drug epidemics and organized crime
18:09:39 <hatds> *have=bring
18:09:53 <Eduard_Munteanu> Oh, heh.
18:10:10 <kmc> maybe the evangelism is best left to self-contained 1-hour talks
18:10:24 <kmc> people like giving 1-hour talks about Haskell, but there's no hope of actually teaching the language that way
18:10:41 <cmccann> I think evangelism is overrated, honestly.
18:10:47 <hatds> what do you think of SPJ's "A Taste of Haskell"?
18:10:58 * ddarius thinks evangelism is worse than overrated.
18:11:07 <kmc> hatds, *shrug* seemed all right
18:11:08 <mdgeorge> hello again
18:11:09 <ddarius> hatds: It's not 1 hour.
18:11:17 <kmc> conversely i think the long-form tutorial is a bad vector for evangelism
18:11:25 <hatds> true, it was like 2 sessions of 1 hour+
18:11:30 <kmc> salesmen make poor teachers
18:11:51 * ddarius thinks SPJ would make an excellent salesman and teacher.
18:12:04 <mdgeorge> is there a reason that imperative languages tend to use external iterators whereas functional languages use internal iterators?
18:12:04 <hatds> but it was completely ground level... walking through type signatures, datatypes/constructors, how bind and return let you form IO computations
18:12:05 <Eduard_Munteanu> kmc: IMHO, that's the thing talks are primarily good for... that is, selling stuff.
18:12:08 <cmccann> SPJ is atypical in many ways
18:12:26 <Eduard_Munteanu> kmc: you'd be in a library if you were interested enough already :)
18:13:25 <mike-burns> mdgeorge: Maybe you mean OO? The answer there is a lack of open classes. Languages like Ruby and Smalltalk use internal iterators.
18:13:51 <mike-burns> But if you're talking about `for', that's because of TCO.
18:13:51 <danharaj> I don't think the internal/external iterator makes sense for a non-OO language? Correct me if I'm wrong.
18:13:53 <Eduard_Munteanu> Iterators? Like Visitor pattern / mapping a function over something?
18:14:34 <Saizan> what do you mean by internal/external iterators?
18:15:08 <danharaj> Saizan: In OO, when you iterate, whether the caller control the iteration (like STL containers), or whether the container being iterated over controls the iteration and you pass it the details.
18:15:13 <danharaj> (As far as I understand)
18:15:52 <cmccann> Just rearrange the argument order to a fold, partially apply it to the list alone
18:15:56 <cmccann> there, an internal iterator
18:16:18 <mdgeorge> yes, I'm more interested in external iterators
18:16:27 <mdgeorge> I understand that an internal iterator is a fold
18:16:38 * ddarius just think internal iteration is underused in mainstream languages and that is very likely due to the lack of a lightweight syntax (or semantics at all) for higher order functions.
18:16:48 <ddarius> Smalltalk has always had internal iteration.
18:17:09 <ddarius> mdgeorge: Consider what an "functional" external iterator would look like.
18:17:37 <mdgeorge> class Iterator i where ...
18:17:46 <mdgeorge> ?
18:17:59 <kmc> why do type classes need to get involved?
18:18:17 <kmc> also they're not a feature of most functional languages
18:18:27 <mdgeorge> kmc: because otherwise it seems you're stuck iterating over a single type of collection, no?
18:18:56 <Eduard_Munteanu> That probably depends on the typing discipline.
18:19:01 <ddarius> mdgeorge: An external iterator is mostly independent, interface-wise, from the "collection" it is iterating over.
18:19:08 <kmc> type classes are not fundamental
18:19:16 <hatds> why is invoking "make" on the command line different than calling make via System.Process.createProcess?  Even if you set the current working directory, make will invoke gcc but gcc won't see the right directory
18:19:28 <kmc> i bet you can re-encode your class-based functional external iterator as a simple data type
18:19:35 <mike-burns> hatds: environment variables.
18:19:40 <danharaj> kmc: Zipper? :p
18:19:48 <hatds> mike-burns: which ones in particular?
18:19:48 <mdgeorge> kmc: oh?  what would it include?
18:19:53 * ddarius thinks kmc knows where he is going.
18:20:02 <ddarius> mdgeorge: You tell us.
18:20:07 <mike-burns> hatds: No idea, but that would be the major difference.
18:20:09 <kmc> Java programmers will invent a new type for every behavior, and a type class as an "interface"
18:20:14 <kmc> but behaviors are just values
18:20:15 <mdgeorge> danharaj: zipper works for iterating over lists
18:20:17 <kmc> (functions or actions)
18:20:28 <danharaj> mdgeorge: You can define a zipper for any reasonable container shape.
18:20:38 <cmccann> and probably some unreasonable ones as well
18:20:42 <Eduard_Munteanu> In a lazy language you could just ask for a map from the particular container/structure to a list, and then work with that.
18:20:58 <kmc> mdgeorge, data Iterator collection elem = Iterator { get :: collection -> elem; next :: collection -> Maybe collection }
18:21:00 <kmc> something like that?
18:21:03 <darrint> What's the idiomatic way to get a list of all the members of a bounded enum?
18:21:13 <hatds> mike-burns: createProcess says that the environment is inherited, but why would gcc no inherit the env from make depending on whether make is called remotely or from the command line?
18:21:20 <ddarius> [minBound .. maxBound]
18:21:23 <kmc> > [minBound .. maxBound] :: [Word8]
18:21:24 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
18:22:05 <mdgeorge> danharaj: but can you then kmc: I see
18:22:11 <mdgeorge> oops
18:22:19 <mdgeorge> started another thought in the middle of the first one :)
18:22:28 <darrint> Ok. I figured I was missing enumAll :: (Bounded => b, Enum => b) -> [b] somwhere.
18:22:59 <ddarius> I don't think I have ever done [minBound .. maxBound] in an actual program.
18:23:04 <geheimdienst> hatds: could the haskell program be running as a different user or something? one that can't access the directory
18:23:34 <Saizan> data Iterator c e = Iterator { toList :: c -> [e] }, btw
18:23:56 <parcs> what about just [minBound..]?
18:24:10 * ddarius will do the reveal now:  lists (particularly lazy lists) are (very simple) external iterators.
18:24:16 * darrint apologizes for the spelling.
18:24:34 <hatds> geheimdienst:  I call createProcess from gchi (in the directory with the make file), and make has no problem accessing the make file and it's directory
18:26:59 <geheimdienst> hatds: sorry, i understood your initial message as meaning gcc can't see some directory :-/
18:27:25 <darrint> For the record it was: enumAll :: (Bounded b, Enum b) => [b]
18:27:31 <hatds> geheimdienst: that's right... gcc probably only sees the directory it resides in
18:28:44 <parcs> :t enumFromThenTo <*> succ
18:28:44 <lambdabot> forall a. (Enum a) => a -> a -> [a]
18:30:04 <Eduard_Munteanu> :t iterate succ minBound
18:30:05 <lambdabot> forall a. (Enum a, Bounded a) => [a]
18:30:20 <ddarius> Incidentally, kmc's type was a (non-empty) list coalgebra.
18:31:37 <Eduard_Munteanu> (though it won't end where it needs to)
18:31:57 <Eduard_Munteanu> > succ maxBound :: Word8
18:31:58 <lambdabot>   *Exception: Enum.succ{Word8}: tried to take `succ' of maxBound
18:32:27 <Eduard_Munteanu> > iterate succ maxBound
18:32:28 <lambdabot>   [(),*Exception: Prelude.Enum.().succ: bad argument
18:32:36 <Eduard_Munteanu> > iterate succ minBound    -- oops
18:32:37 <lambdabot>   [(),*Exception: Prelude.Enum.().succ: bad argument
18:32:54 <Eduard_Munteanu> > iterate succ minBound :: [Word8]   -- oops again
18:32:55 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
18:33:58 * ddarius wonders whose hands wrote 'error "Prelude.Enum.().succ: bad argument"'
18:34:42 <mdgeorge> sorry, keyboard failure.
18:35:04 <MHD> I like how because of the lazyness, the left square bracket get's printe and then the error
18:35:08 <MHD> that has always amused me so
18:35:09 <mdgeorge> I used to like linux because I never had to reboot...now it seems like I have to reboot every 10 minutes
18:35:26 <mdgeorge> but anyway, I get your point kmc about type classes
18:35:34 <cmccann> MHD, have you ever tried this
18:35:36 <cmccann> > fix error
18:35:36 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
18:35:41 <danharaj> haha
18:35:47 <MHD> oh god hahahaha
18:35:51 <ddarius> MHD: It printed the first element, ().
18:36:03 * cmccann is still pretty sure that's the most common use of fix
18:36:12 <geheimdienst> > succ ()
18:36:12 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
18:36:18 <Eduard_Munteanu> I'm not sure why it can print () at all
18:36:27 <geheimdienst> Eduard_Munteanu: my thought exactly
18:36:33 <Eduard_Munteanu> I didn't give it any clue as to the type of the result.
18:36:41 <ddarius> Eduard_Munteanu: Extended defaulting.
18:36:45 <hpc> defaulting
18:36:49 <Eduard_Munteanu> Hm.
18:36:58 <geheimdienst> > pred ()
18:36:58 <lambdabot>   *Exception: Prelude.Enum.().pred: bad argument
18:37:08 <Eduard_Munteanu> [minBound .. maxBound] :: [()]
18:37:13 <Eduard_Munteanu> > [minBound .. maxBound] :: [()]
18:37:13 <lambdabot>   [()]
18:37:40 <ddarius> @check \x -> reverse x == x
18:37:40 <lambdabot>   "OK, passed 500 tests."
18:37:57 <geheimdienst> but for what argument does succ give () ?
18:38:09 <ddarius> geheimdienst: None.
18:38:34 <Eduard_Munteanu> geheimdienst: none.. that goes  [minBound, succ minBound, succ (succ minBound), ...]
18:38:37 <mdgeorge> pred (), presumably :)
18:38:56 <ddarius> mdgeorge: If that were the case, we'd have solved the halting problem.
18:39:02 <Eduard_Munteanu> > (succ . pred) ()
18:39:04 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
18:39:22 <Eduard_Munteanu> > pred ()
18:39:23 <lambdabot>   *Exception: Prelude.Enum.().pred: bad argument
18:39:40 <geheimdienst> ah right. iterate begins the list with the unchanged value
18:40:00 <Eduard_Munteanu> > (pred . succ) ()
18:40:01 <lambdabot>   *Exception: Prelude.Enum.().pred: bad argument
18:40:08 <Eduard_Munteanu> :/
18:40:41 <Eduard_Munteanu> > succ undefined
18:40:42 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
18:40:47 <Eduard_Munteanu> Oh, that explains it.
18:41:07 <ddarius> It's strict, not eager.
18:41:08 <Eduard_Munteanu> (the first one I mean)
18:41:31 <geheimdienst> Eduard_Munteanu: if you compile (pred . succ) with -O17, ghc compiles it away and no exception occurs :)
18:42:16 <monochrom> haha
18:42:37 <Eduard_Munteanu> But maybe I'm using pred . succ as an assert :P
18:42:45 <danharaj> wait
18:42:51 <danharaj> I thought -O only went up to 11
18:43:01 <hpc> no, that's metalica
18:43:17 <geheimdienst> danharaj_: you gotta use HEAD
18:43:33 <mdgeorge> hpc: you mean spinal tap?
18:44:00 <Eduard_Munteanu> -Omg like some Gentoo ricers :P
18:44:10 <parcs> > fix (succ . pred)
18:44:12 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
18:44:25 <parcs> not even fix fixes it
18:44:25 <hpc> er yeah, spinal tap
18:44:31 <mdgeorge> lol
18:44:34 * Eduard_Munteanu remembers this... http://funroll-loops.info/
18:44:38 <mdgeorge> but fix fixes everything!
18:44:49 <hpc> it puts the fun in -funroll
18:50:49 <cmccann> 11? That's ridiculous.
18:50:52 <cmccann> It's not even funny.
18:57:03 <danharaj> God fucking damn.
18:57:03 <danharaj> Apparently all bets are off when rendering fonts.
18:57:04 <danharaj> "Here's a list of font metrics you have access too, by the way, they don't have a consistent meaning so have fun!"
18:57:17 <danharaj> to* lord my grammar has been suffering today.
18:58:04 <cmccann> danharaj, I keep saying that dealing with text is difficult
18:58:08 <cmccann> stick with category theory
18:58:42 <danharaj> I wish the world were an AST
18:59:05 <mustelo> given a product like data Stuff = Stuff a b c, is there an easy way to derive mapping functions mapA, mapB, mapC which are of the form mapX :: (x -> x) -> Stuff Stuff?
18:59:14 <cmccann> just because you've figured out how to capitalize words in Turkey doesn't mean you have text stuff figured out
18:59:22 <mustelo> s/Stuff Stuff/Stuff -> Stuff/
18:59:55 <Eduard_Munteanu> mustelo: you might want to clarify your data declaration too
19:00:01 <cmccann> mustelo, with TH hackery probably
19:00:02 <darrint> Is there a shorthand for failing out in IO with an error message when a function returning Either returns Left?
19:00:03 <danharaj> cmccann: Apparently there's no guarantee that when I'm rasterizing a string of text that the leftmost character will correspond to the leftmost glyph. Madness.
19:00:19 <mustelo> Eduard_Munteanu, what about it?
19:00:29 <danharaj> @hoogle Either a b -> b
19:00:30 <lambdabot> Data.Either rights :: [Either a b] -> [b]
19:00:30 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
19:00:30 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
19:00:47 <mustelo> cmccann, hmm, do you have a pointer?
19:00:59 <Eduard_Munteanu> mustelo: what do you mean? data Stuff a b c = Stuff a b c,   or   data Stuff = forall a b c. Stuff a b c    or    data Stuff = Stuff A B C ?
19:01:00 <cmccann> darrint, Right x' <- x ?
19:01:05 <danharaj> :t either (fail "fail") (\x -> x)
19:01:06 <lambdabot> forall a b. Either a b -> b
19:01:21 <danharaj> darrint: is that short enough? :3
19:01:24 <Eduard_Munteanu> @hoogle from
19:01:24 <lambdabot> Data.IntMap fromAscList :: [(Key, a)] -> IntMap a
19:01:24 <lambdabot> Data.IntSet fromAscList :: [Int] -> IntSet
19:01:24 <lambdabot> Data.Map fromAscList :: Eq k => [(k, a)] -> Map k a
19:01:30 <ddarius> danharaj: What's wrong with id?
19:01:32 <cmccann> mustelo, not to the exact thing, but take a look at the fclabels package
19:01:56 <geheimdienst> @hoogle fromRight
19:01:56 <lambdabot> No results found
19:01:57 <mustelo> Eduard_Munteanu, ah, the last one, Stuff has kind *.
19:02:02 <danharaj> ddarius: nothing, I wanted to give all the arguments as an example.
19:02:04 <mustelo> cmccann, okay, thanks
19:02:05 <darrint> danharaj: I think that's the one I want. Except I bet I want either (fail) blah, since left is my error message. Thanks.
19:02:32 <ddarius> :t either fail return
19:02:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => Either String a -> m a
19:02:59 <danharaj> pff. my type is more general :[
19:03:04 <darrint> thanks all!
19:03:12 <Eduard_Munteanu> @hoogle fromRight
19:03:12 <lambdabot> No results found
19:03:15 * Eduard_Munteanu wondered
19:03:20 <parcs> mustelo: no, you can't do much with the latter
19:03:25 <ddarius> :t Data.Either.fromRight
19:03:25 <lambdabot> Not in scope: `Data.Either.fromRight'
19:04:10 * ddarius wonders if Eduard_Munteanu can define fromRight correctly the first time.
19:04:15 <mustelo> parcs, okay, thanks. I suppose there's always emacs macros
19:04:22 <geheimdienst> oh, fromRight is in missingh. "Take a Right to a value, crashes on a Left"
19:04:23 <danharaj> :t rights . return
19:04:24 <lambdabot> forall a b. Either a b -> [b]
19:04:41 <danharaj> ah what was that function again...
19:04:46 <danharaj> @hoogle [a] -> Maybe a
19:04:46 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
19:04:46 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
19:04:46 <lambdabot> Prelude head :: [a] -> a
19:04:56 <ddarius> danharaj: That's an odd way of writing (:[])
19:05:04 <Eduard_Munteanu> ddarius: fromRight :: Either a b -> b ?
19:05:17 <danharaj> ddarius: The face bothers me. ;)
19:05:45 <Eduard_Munteanu> fromRight (Right x) = x
19:05:56 <monochrom> safeFromJust :: Maybe a -> Maybe a; safeFromJust Nothing = Nothing; safeFromJust (Just x) = Just x
19:06:03 <ddarius> Eduard_Munteanu answers the question negatively.
19:06:27 <Eduard_Munteanu> ddarius: how so?
19:06:43 <ddarius> fromRight ~(Right x) = x
19:07:00 * cmccann is unconvinced that fromRight has a correct implementation
19:07:11 <kmc> ddarius, is fromJust lazy the same way?
19:07:21 <kmc> also, is there a way to do a lazy pattern match with a custom error message?
19:07:23 <ddarius> I don't think so.
19:07:29 <ddarius> @src fromJust
19:07:29 <lambdabot> fromJust Nothing  = undefined
19:07:29 <lambdabot> fromJust (Just x) = x
19:07:36 <Eduard_Munteanu> ddarius: hm, why would I care about the added laziness there?
19:07:37 <danharaj> I don't understand what the ~ does.
19:07:48 <danharaj> I mean I know what it does, but it's like 'so what."
19:07:49 <kmc> danharaj, in general, or why it's needed here?
19:07:56 <danharaj> kmc: in general.
19:07:58 <geheimdienst> i don't see how it's an issue of "correctness"
19:08:09 <ddarius> Eduard_Munteanu: It's very handy for knot-tying instances, which is one of the few times functions like fromRight would be reasonable.
19:08:23 <danharaj> geheimdienst: Maximize the space of programs that don't evaluate to bottom :p
19:08:28 <Eduard_Munteanu> Oh, hm.
19:08:32 <kmc> > fix (\(odds, evens) -> (map succ evens, 0 : map succ odds))
19:08:35 <lambdabot>   mueval-core: Time limit exceeded
19:08:37 <kmc> > fix (\~(odds, evens) -> (map succ evens, 0 : map succ odds))
19:08:37 <lambdabot>   <no location info>: parse error on input `->'
19:08:42 <kmc> > fix (\(~(odds, evens)) -> (map succ evens, 0 : map succ odds))
19:08:43 <lambdabot>   ([1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,...
19:08:52 <danharaj> wait I think I ran into something like that recently
19:09:03 <danharaj> so what does the ~ do?
19:09:13 <coppro> danharaj: It causes the bindings in the pattern to be lazy
19:09:13 <Saizan> ddarius: do you have an example where fromRight (Right x) = x wouldn't work?
19:09:23 <danharaj> coppro: what does that mean?
19:09:28 <kmc> danharaj, puts off forcing the constructors mentioned in the pattern until the variables bound are forced
19:09:38 <danharaj> oh ok
19:09:41 <kmc> that means that it's irrefutable, because you didn't check the constructor
19:09:43 <ddarius> Saizan: Yes, see my use of fromRight on the Tying The Knot wiki page.
19:09:49 <kmc> but on a tuple that's okay because there's only one constructor anyway
19:09:59 <kmc> > fix (\x -let (odds, evens) = x
19:09:59 <lambdabot>   <no location info>: parse error on input `-'
19:10:00 <kmc> bah
19:10:10 <kmc> > fix (\x -> let (odds, evens) = x in (map succ evens, 0 : map succ odds))
19:10:11 <lambdabot>   ([1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,...
19:10:14 <kmc> ^^^ desugared
19:10:20 <danharaj> oh ok
19:10:28 <danharaj> I always understand desugar explanations faster :p
19:10:32 <Eduard_Munteanu> A more common use is in the (lazy) state monad, IIRC
19:10:44 <coppro> let {fromJust' ~(Just x) = x} in fromJust' Nothing `seq` True
19:10:46 * ddarius doesn't think ~ desugars into let.
19:10:49 <Eduard_Munteanu> *monad's implementation
19:10:50 <coppro> > let {fromJust' ~(Just x) = x} in fromJust' Nothing `seq` True
19:10:50 <lambdabot>   *Exception: <interactive>:3:5-27: Irrefutable pattern failed for pattern (D...
19:11:15 <kmc> ⊥ is always a fixed point of «\(x,y) -> ...»
19:11:27 <kmc> ⊥ is always a fixed point of «\(C x y ...) -> ...»
19:11:28 <coppro> I forget; how can I force evaluation of fromJust' but not its result?
19:11:38 <kmc> what do you mean?
19:11:47 <kmc> forcing evaluation of fromJust' itself, the function?
19:11:57 <coppro> yeah
19:12:06 <kmc> > let {fromJust' ~(Just x) = x} in fromJust'  `seq` True
19:12:06 <lambdabot>   True
19:12:08 <Eduard_Munteanu> Maybe he means making it equivalent to the non-~ case?
19:12:13 <kmc> i don't see why that's interesting
19:12:21 <coppro> err, no
19:12:24 <coppro> not what I meant
19:12:31 <ddarius> coppro: What you meant makes no sense.
19:12:46 <coppro> I meant forcing evaluation of fromJust' Nothing |-> undefined without evaluating undefined
19:13:11 <kmc> forcing evaluation of undefined without evaluating undefined?
19:13:18 <ddarius> fromJust' Nothing -is- undefined, forcing it is forcing undefined.
19:13:34 <danharaj> You can't distinguish undefined values.
19:13:36 <danharaj> Any of them.
19:13:44 <danharaj> except when GHC breaks the laws of physics
19:13:50 <kmc> spoon!
19:13:52 <kmc> :D
19:13:59 <Saizan> ddarius: weird, since the ~ and the non-~ versions seem to be extensionally equal to me, fromRight _|_ = _|_; fromRight (Left _) = _|_; fromRight (Right x) = x, the ~ doesn't change any of those
19:14:00 <danharaj> that went over my head ;p
19:14:07 <kmc> @hackage spoon
19:14:07 <lambdabot> http://hackage.haskell.org/package/spoon
19:14:18 <danharaj> ahahaha
19:14:23 <danharaj> I love that synopsis.
19:15:09 <danharaj> So that library I'm guessing runs with unsafePerformIO and catches errors there, then pretends they never happened?
19:15:46 <monochrom> yes
19:15:48 * danharaj reads the source because Hackage is convenient like that. is satisfied that he understands their dark magic
19:16:15 <kmc> it returns Nothing if there was an error
19:16:28 <danharaj> I love 'spoon' and 'teaspoon'
19:16:38 <danharaj> It is the antithesis of enterprise
19:16:45 <danharaj> It should be
19:17:01 <Saizan> ddarius: in fact your example on the wiki works fine with the non-~ fromRight
19:17:02 <cmccann> hm
19:17:16 * cmccann wishes he'd known about that package before implementing his version the other day :T
19:17:22 <danharaj> why?
19:17:39 <danharaj> I think small nothings like these really just make dependency hell all the easier.
19:18:02 <cmccann> the problem with that is the dependency handling, not using libraries
19:18:17 <danharaj> One time I was looking at a library I was considering and it had a dependency on some package for exporting prelude unicode names and I was like "really?"
19:18:18 <cmccann> and also because it would have saved me a bit of time messing around trying to get it right
19:19:04 <danharaj> Eh. I just don't like having dependencies like that.
19:19:46 <ddarius> Saizan: Hmm, your logic seems correct, though I vaguely recall having problems without it.  It was almost a decade ago though.
19:21:38 <coppro> > let {cond True = const; cond False = flip const; contrived b ~(Just x) = cond b x 0 } in contrived False Nothing
19:21:39 <lambdabot>   0
19:21:45 <coppro> > let {cond True = const; cond False = flip const; contrived b (Just x) = cond b x 0 } in contrived False Nothing
19:21:45 <lambdabot>   *Exception: <interactive>:3:49-81: Non-exhaustive patterns in function cont...
19:22:07 <coppro> there's a good example :)
19:22:11 <kmc> http://conal.net/blog/posts/lazier-functional-programming-part-2
19:22:20 <kmc> is relevant to an earlier discussion
19:22:54 <Eduard_Munteanu> Saizan: maybe it matters in other cases where you have an undefined value which isn't really _|_?
19:23:11 <Eduard_Munteanu> Like ddarius said, tying the knot, say around doubly linked lists.
19:24:28 <kmc> Eduard_Munteanu, not sure what you mean by "an undefined value which isn't really _|_"
19:24:45 <Saizan> ddarius: maybe in some earlier version you were pattern matching on env on the spot, with the whole mapM ... on the RHS
19:24:47 <ddarius> It possibly changes the sharing behavior, though I don't think so, but it shouldn't change the semantics.
19:25:02 <ivanm> preflex: seen byorgey
19:25:02 <preflex>  byorgey was last seen on #haskell 11 hours, 48 minutes and 14 seconds ago, saying: Persistently Overestimate Employment Time Slot?
19:25:11 <ivanm> @tell byorgey I just found your multiset-comb package; thanks! I had a permutation function that someone here (forget who) helped me with that was a bottleneck in my program, but your version speeds it up rather nicely!
19:25:11 <lambdabot> Consider it noted.
19:25:29 <Eduard_Munteanu> kmc: Right (Cons _|_ <something>) for example
19:25:36 <Eduard_Munteanu> Though I can see that's not an issue here :/
19:25:37 <kmc> is not ⊥
19:25:40 <coppro> Saizan: would you prefer an example with fromRight?
19:25:49 <kmc> ah, you mean something broader by "undefined"
19:26:07 <Eduard_Munteanu> Yeah, something which you couldn't evaluate to normal form.
19:26:34 <kmc> (identifying that is undecidable, of course)
19:27:30 <Saizan> coppro: i know how ~ works, i'm just saying that it makes no difference in the definition of fromRight, except for the different error message on pattern match failure
19:27:35 <Eduard_Munteanu> With some tricks it might be possible, but that's not the point.
19:27:49 <coppro> Saizan: ah ok
19:27:52 <Eduard_Munteanu> e.g. exception handling
19:27:59 <coppro> Saizan: actually... I think I agree with you
19:28:29 <dufflebunk> Has anyone been able to cabal install unix-compat on a RHEL5 machine?
19:28:41 <ddarius> Who uses Red Hat?
19:29:06 <dufflebunk> Me. Actually, it's centos5.
19:29:37 <ivanm> dufflebunk: what's the error?
19:29:45 <kmc> ddarius, lots of people
19:30:02 <dufflebunk> ivan, The one discussed here: http://www.mail-archive.com/haskell-cafe@haskell.org/msg88108.html
19:30:13 * kmc had great fun last year installing Haskell Platform on RHEL4
19:30:38 <dufflebunk> The solution is something about installing libbsd-dev on ubuntu, but there's no such package on rh5.
19:31:22 <ddarius> kmc: I don't believe in these... "people."  My world consists solely of dogs, and I assure you, they do not use Red Hat.
19:31:36 * ddarius should probably go to sleep.
19:31:42 <dufflebunk> I think that ubuntu package is to get libutil.h. In RH5, libutil.so is provided by the glibc-devel rpm, but there's no libutil.h that comes with it.
19:31:44 <Eduard_Munteanu> dufflebunk: can you run it yourself with -v / -v3 and see what file is missing?
19:31:49 <darrint> Can the hackage ssh library be used as an ssh client?
19:32:00 <Eduard_Munteanu> oh libutil
19:32:13 <dufflebunk> Missing (or bad) header file: HsUnixCompat.h
19:32:37 <ivanm> dufflebunk: do you have any package called something like bsd-dev or libbsd or something?
19:32:51 <ivanm> darrint: as it currently stands, doesn't look like it
19:33:00 <dufflebunk> No, no libbsd or bsd-devel
19:33:05 <monochrom> > fix ( ~(Right x) -> Right (0 : x))
19:33:06 <lambdabot>   Pattern syntax in expression context: ~(Right x) -> Right (0 : x)
19:33:12 <monochrom> > fix (\ ~(Right x) -> Right (0 : x))
19:33:12 <lambdabot>   Right [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
19:33:23 <narain> is there an elegant way to turn a  (Maybe a, b)  to a  Maybe (a, b) ?
19:33:32 <narain> i have  \(ma,b) -> ma >>= \a -> return (a,b)  but it's not very pretty
19:33:38 <dufflebunk> ivan, in fact yum search bsd finds nothing at all
19:33:39 <narain> and the pointless version is worse:
19:33:41 <narain> @pl \(ma,b) -> ma >>= \a -> return (a,b)
19:33:41 <lambdabot> uncurry (flip (fmap . flip (,)))
19:33:42 <Eduard_Munteanu> dufflebunk: how are you installing GHC at all?
19:33:49 <monochrom> that is an example of the utility of ~. however, it still doesn't say what you should do for fromRight
19:33:50 <Eduard_Munteanu> Does Centos 5 support it?
19:34:11 <Eduard_Munteanu> dufflebunk: you might want to install libbsd from source yourself
19:34:21 <dufflebunk> Eduard_Munteanu, I followed the instructions for building from source.
19:34:27 <ddarius> fmap . (,)
19:34:33 <ddarius> :t fmap . (,)
19:34:33 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => a1 -> f a -> f (a1, a)
19:34:35 <Eduard_Munteanu> Strength?
19:34:37 <ivanm> dufflebunk: looks like a debian-specific mish-mash of packages
19:34:46 <ddarius> :t uncurry $ fmap . (,)
19:34:47 <lambdabot> forall a a1 (f :: * -> *). (Functor f) => (a, f a1) -> f (a, a1)
19:34:55 * Eduard_Munteanu remembers somebody telling me that
19:35:07 <ddarius> Yes, it's a strength.
19:35:12 <dufflebunk> Eduard_Munteanu, I guess I'll have to build it. It's just weird that rh has libutil.so but no libutil.h.
19:35:34 <Eduard_Munteanu> dufflebunk: could you use rpm (or whatever there is) to find out the name of the package it belongs to?
19:35:36 <narain> @ddarius: that's not bad, though it's flipped
19:35:36 <lambdabot> Unknown command, try @list
19:35:54 <dufflebunk> Eduard_Munteanu, it blongs to the glibc-devel package.
19:35:56 <narain> i mean, ddarius: that's not bad, though it's flipped
19:35:57 <ivanm> dufflebunk: libbsd.freedesktop.org
19:36:09 <ddarius> A strong monad is a monad with a strong functor.  A functor is strong when it's action on arrows is itself an arrow.  This is illustrated nicely by the fmap as an argument to (.).
19:36:10 <Eduard_Munteanu> Oh hrm, I guess there's no glibc-devel-devel then
19:36:15 <ivanm> Eduard_Munteanu: heh
19:36:16 <chenwl> @type (>>)
19:36:16 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
19:36:53 <dufflebunk> Eduard_Munteanu, sadly, I did check that already
19:37:05 <ivan> dufflebunk: xchat preferences -> interface -> input box -> nick competion sorted: -> last-spoke order
19:37:06 <chenwl> realworldhaskell says the result is the second result
19:37:12 <chenwl> but what is the second result
19:37:20 <Eduard_Munteanu> ddarius: I remember Wikipedia (?) saying Haskell monads are all strong. Is that accurate, and if so, what makes it possible? Exponentials?
19:37:35 <chenwl> for example printStrLn "Line 1" >> printStrLn "Line 2"
19:37:40 * dufflebunk usually uses irssi
19:37:43 <chenwl> what is the second result?
19:37:48 <ivanm> ivan: heh
19:37:58 <cmccann> Haskell monads are strong because they get a lot of exercise
19:37:59 <narain> is something like  fmap . (,)  a common idiom? i'm not used to interpreting the composition a function of one argument with a function of two arguments
19:38:01 <ivanm> chenwl: the m b
19:38:23 <chenwl> ivanm: I mean the result not the type of the result
19:38:26 <mustelo> chenwl, what's the type of printStrLn "Line 1" ?
19:38:27 <ivanm> chenwl: it "runs" the first monadic value and discards its result (the `a') and then runs the second one
19:38:36 <chenwl> mustelo: IO ()
19:38:45 <ivanm> chenwl: well, if you have ma >> mb, the result is the result of the mb
19:38:51 <Eduard_Munteanu> ddarius: I'm just guessing though, because of the 'uncurry' there
19:38:53 <mustelo> chenwl, which is why you don't see a "result" here, just the effects
19:39:02 <chenwl> but what is the result of mb
19:39:08 <Saizan> chenwl: it's ()
19:39:11 <Saizan> > ()
19:39:11 <lambdabot>   ()
19:39:12 <ivanm> chenwl: depends on what you said it is!
19:39:24 <chenwl> @_@
19:39:27 <ivanm> > return 'a' >> return 3 :: Just Int
19:39:28 <lambdabot>   Not in scope: type constructor or class `Just'
19:39:31 <Saizan> ghci doesn't print the () when you run an expression of type IO ()
19:39:33 <ivanm> > return 'a' >> return 3 :: Maybe Int
19:39:33 <lambdabot>   Just 3
19:39:40 <ivanm> chenwl: ^^
19:39:51 <Saizan> ivanm: chenwl was asking about a specific expression though
19:39:57 <ivanm> Saizan: oh, missed that...
19:40:07 <ivanm> I thought he was asking in general
19:40:36 <chenwl> so the result of (IO "hello") is "hello" right?
19:40:42 <mustelo> chenwl, it's a bit confusing in the case of IO (), so maybe consider a different monad like ivanm suggested
19:40:53 <Saizan> IO "hello" is not valid code
19:40:55 <ivanm> well.... you can't say  ` IO "hello" '
19:41:03 <ivanm> let's consider the Maybe monad
19:41:13 <Saizan> return "hello" :: IO String would have "hello" as result
19:41:21 <narain> @type \f g -> f . g
19:41:22 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:41:29 <ivanm> the result of "Just 3" is "Just 3"
19:41:37 <narain> @type (.)
19:41:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:41:47 <ivanm> the result of ` fmap show $ Just 3 ' is ` Just "3" '
19:41:52 <Saizan> chenwl: () is a bit confusing because it uses the same notation for both the type and the only value of that type
19:42:05 <Saizan> ?type ()
19:42:05 <lambdabot> ()
19:42:22 <ivanm> Saizan: at least its kind is different :p
19:42:25 <Eduard_Munteanu> [] is too, kinda
19:42:30 <chenwl> ivanm: the result of (Just 3) is (Just 3) but not 3?
19:42:38 <ddarius> Eduard_Munteanu: Haskell monads are strong because we are using Hask as Set, so Hask is a Hask-enriched category.
19:42:51 <ivanm> chenwl: well, I suppose it depends on how you define "result"
19:43:02 <chenwl> what is the result of (return "hello")
19:43:03 <ivanm> I'm calling result " the resulting value from that expression "
19:43:07 <ddarius> Any category with exponentials can be enriched in itself.
19:43:12 <ivanm> chenwl: depends on the Monad
19:43:14 <Eduard_Munteanu> Oh.
19:43:17 <ivanm> but it's just (return "hello")
19:43:27 <chenwl> ivanm: IO Monad
19:43:27 <Eduard_Munteanu> Yeah, I kinda need to read up on enriched categories.
19:43:35 <Eduard_Munteanu> Thanks.
19:43:40 <ivanm> chenwl: but (return 1 >> return "hello") has a result of just (return "hello")
19:43:59 <ivanm> chenwl: well, you can't construct an IO value directly, so you can't express it better than (return "hello")
19:44:01 <Saizan> heh, then me an ivanm are using a different notion of result, and i think mine is the one RWH is using in the sentence above
19:44:09 <ivanm> quite possibly
19:44:26 <ivanm> I did consider using that notion, but then what is the result of Nothing ? :p
19:44:27 <Saizan> (just making it clear)
19:44:32 <Eduard_Munteanu> chenwl: consider    f :: IO Int; f = putStrLn "Hello" >> return 5
19:44:43 <Saizan> you don't get a result in that case
19:44:47 <hatds> narain: collect2 . (second Just)     --collect2 :: (m a,m b) -> m (a,b),  second from Control.Arrow
19:44:50 <Eduard_Munteanu> You can't use >>= there
19:44:55 <Eduard_Munteanu> Well, you can.
19:45:17 <Eduard_Munteanu> But you have to work around it.
19:45:17 <chenwl> @_@
19:45:25 <ddarius> :t liftM2 (,)
19:45:25 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
19:45:30 <ddarius> :t uncurry (liftM2 (,))
19:45:30 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
19:45:40 <chenwl> RWH doesn't say what is a 'result'
19:45:41 <Eduard_Munteanu> @src (>>)
19:45:41 <lambdabot> m >> k      = m >>= \_ -> k
19:45:52 <Saizan> chenwl: anyhow, this is just terminology, get the types straight and you'll be fine :)
19:46:00 <ivanm> Eduard_Munteanu: and you'd end up with >> again ;-)
19:46:05 <Eduard_Munteanu> Yep.
19:46:21 <ivanm> chenwl: OK, to get us back on the same page, let me retract a bit what I was saying before
19:46:33 <narain> :t uncurry (liftM2 (,)) . second Just
19:46:34 <lambdabot> forall a1 a2. (Maybe a1, a2) -> Maybe (a1, a2)
19:46:37 <ivanm> the result of (return "hello" :: (Monad m) => m String) is "hello"
19:46:52 <ivanm> ^^ for purposes of discussion
19:46:54 <dufflebunk> built and installed libbsd myself, unix-compat now installs
19:47:04 <narain> > uncurry liftM2 (,) . second Just $ (Just 1, 2)
19:47:04 <lambdabot>   Couldn't match expected type `(a1 -> a2 -> r, m a1)'
19:47:05 <lambdabot>         against inferr...
19:47:07 <dufflebunk> and happstack is finally installed
19:47:11 <mustelo> chenwl, it might be helpful for now just to think of (>>) on a monad-by-monad basis. for IO, think of it like "do the first thing, then do the second thing, then return the value that the second thing produced (possibly ())"
19:47:29 <ivanm> mustelo: well, that's true for _all_ monads
19:47:36 <narain> > uncurry (liftM2 (,)) . second Just $ (Just 1, 2)
19:47:37 <lambdabot>   Just (1,2)
19:47:38 <mustelo> ivanm, sssshhh!
19:47:41 <ivanm> though in a lot of cases the first thing won't be of any use ;-)
19:47:42 <kmc> you basically have to think of (>>) on a monad-by-monad basis
19:47:53 <chenwl> mustelo: what is the value an IO monad produced
19:48:04 <kmc> generically, «x >> y» is «x >>= \_ -> y», and that's about all you can say
19:48:09 <chenwl> for instance, (return "hello")
19:48:11 <kmc> because (>>=) is actually defined differently for each monad
19:48:17 <mustelo> chenwl, well for printing, you don't get anything useful back. haskell writes that as (), pronounced "unit"
19:48:20 <kmc> chenwl, that one produces "hello" :: String
19:48:31 <narain> thanks, hatdz and ddarius!
19:48:40 <ddarius> kmc: It nevertheless (should) satisfy some laws, and those laws imply some consequences.
19:48:41 <narain> i mean, hatds
19:48:45 <hatds> ;)
19:48:54 <mustelo> chenwl, but you could also *read* a string, which would give you a string back, so you could say putStrLn "what is your name?" >> getLine
19:49:07 <chenwl> the value produce by an IO b has type b but not IO b
19:49:10 <Eduard_Munteanu> I don't think >> can behave different than >>= since it kinda implies you have a different 'join' operation, no?
19:49:18 <chenwl> am I right?
19:49:29 <kmc> chenwl, yeah
19:49:54 <mustelo> chenwl, comes down to terminology. getLine has type IO String, which means it does some action and produces a string
19:49:54 * Eduard_Munteanu doesn't remember if (>>) is a defaulting class member or separate function
19:49:58 <kmc> :t (>>=)
19:49:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:50:02 <kmc> Eduard_Munteanu, defaulting iirc
19:50:15 <kmc> so yeah, i guess it could be observably different, but the laws forbid it
19:50:27 <ddarius> Sanity forbids it.
19:50:30 <ivanm> kmc: I thought separate...
19:50:33 <ivanm> @src Monad
19:50:33 <lambdabot> class  Monad m  where
19:50:33 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
19:50:33 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
19:50:33 <lambdabot>     return      :: a -> m a
19:50:33 <lambdabot>     fail        :: String -> m a
19:50:37 <ivanm> huh
19:50:52 <cmccann> @src Applicative
19:50:53 <lambdabot> class Functor f => Applicative f where
19:50:53 <lambdabot>     pure  :: a -> f a
19:50:53 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
19:50:56 <chenwl> It's much clearer now, thank you, go ahead learning
19:50:58 <ivanm> I guess there could be some Monad for which a more efficient version could be defined...
19:50:59 <hatds> ha
19:51:15 <Eduard_Munteanu> Ah, yeah.
19:51:29 * cmccann thought Applicative has (*>) and (<*) as well...
19:51:36 <ivanm> not that I can think of one off-hand; a parsing library maybe?
19:51:48 <ivanm> cmccann: it does; might be newer additions
19:51:49 <roconnor> cmccann: if that is the case it is new
19:51:54 <mustelo> chenwl, do you know about do-notation desugaring?
19:51:56 <Eduard_Munteanu> Actually, if anything, 'fail' is the bugger there :)
19:52:01 <ivanm> definitely
19:52:06 <kmc> :t (*>)
19:52:07 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
19:52:09 <hatds> it's 2011, where is my MonadZero?
19:52:19 <roconnor> hatds: it's in your Monad :)
19:52:19 <ivanm> hatds: waiting for you to write it!
19:52:21 <monochrom> cmccann, don't trust @src, it's handwritten
19:52:27 <kmc> hatds, back in the early 90's
19:52:30 <cmccann> monochrom, ah ok
19:52:34 <ivanm> monochrom: well, from the report, isn't it?
19:52:38 <roconnor> kmc: good point
19:52:53 <monochrom> the report doesn't have Applicative
19:52:56 <roconnor> ivanm: I don't think Applicative is in the report
19:52:57 <chenwl> mustelo: what is 'desugaring' ?
19:53:08 <ivanm> @wn syntactic sugar
19:53:10 <lambdabot> *** "syntactic" wn "WordNet (r) 2.0"
19:53:10 <lambdabot> syntactic
19:53:10 <lambdabot>      adj : of or relating to or conforming to the rules of syntax; "the
19:53:10 <lambdabot>            syntactic rules of a language" [syn: {syntactical}]
19:53:10 <lambdabot>  
19:53:12 <lambdabot> [14 @more lines]
19:53:13 <ivanm> bah
19:53:16 <ddarius> "As Δδ approaches J in size..."
19:53:16 <ivanm> @google syntactic sugar
19:53:17 <lambdabot> http://en.wikipedia.org/wiki/Syntactic_sugar
19:53:17 <lambdabot> Title: Syntactic sugar - Wikipedia, the free encyclopedia
19:53:20 <kmc> <div class="hipster">Haskell 1.4 was really the best release...</div>
19:53:23 <ivanm> chenwl: ^^ getting rid of that
19:53:28 <mustelo> chenwl, it's how the compiler makes sense of do notation. it converts it to function calls of (>>=) and (>>)
19:53:40 <hatds> desugaring means explaining syntax by means of a translation into other syntax
19:53:43 <kmc> more to the point, it's how the report defines "do" notation
19:53:45 <kmc> and how you can think of it
19:53:48 <chenwl> I know syntactic sugar
19:53:51 <Eduard_Munteanu> chenwl: in context, it might mean how do-notation translates to >>= and lambdas
19:53:57 <roconnor> we should really start work on the Caleskell report
19:54:05 <chenwl> [ x^2 | x<-[1..10] ] is syntactic sugar
19:54:24 <mustelo> chenwl, if you write a program to ask "what is your name?" and then read a line in, in do notation, what does it look like?
19:54:25 <roconnor> though I'm not all that happy with . being fmap
19:54:45 <Eduard_Munteanu> like   do { y <- f x; g y }   translates to f x >>= (\y -> g y)
19:55:06 <kmc> conceptually i prefer (.) :: (Category (~>)) -> (b ~> c) -> (a ~> b) -> (a ~> c)
19:55:07 <chenwl> do printStrLn "what is your name?"; name<-inputStrLn
19:55:10 <roconnor> @undo do { y <- f x; g y}
19:55:10 <lambdabot> f x >>= \ y -> g y
19:55:12 <kmc> but i guess it's less useful than fmap
19:55:26 <Eduard_Munteanu> :t (>>>)
19:55:27 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
19:55:34 <roconnor> fmap probably deserves a light infix notation
19:55:36 <kmc> (er first (->) should be (=>) natch)
19:55:42 <roconnor> probably even lighter than <$>
19:55:44 <hatds> haskell prime seems to have surprisingly little activity, even though everyone was very eager to change many parts of the language leading up the start of yearly revisions
19:56:00 <mustelo> chenwl, right. so the compiler actually translates that into what I said earlier, which is putStrLn "what is your name?" >> inputStrLn
19:56:04 <roconnor> hatds: no one is eager to do any work I guess.
19:56:08 <mustelo> (minus the variable name)
19:56:40 <hatds> roconnor: maybe we should try to change that
19:57:17 <roconnor> Well maybe it is more like people are eager to do other work
19:57:27 <Saizan> i guess the uncontroversial stuff is boring and the controversial one is hard
19:57:35 <roconnor> since Haskell is good enough.
19:57:35 <hatds> also, the track-wiki for haskell prime is really disorganizied
19:57:40 * monochrom spams haskell-prime with "offers to make import lines 7 inches long"
19:57:43 <kmc> GHC Haskell is good enough
19:57:44 * cmccann thinks opting to be lazy instead of eager is a common choice among Haskell users
19:58:00 <chenwl> mustelo: soga
19:58:55 <bobzhang> hi, I foreget the right syntax for Prelude.(++), anybody can help me? thank you!
19:58:57 <mustelo> chenwl, hmm?
19:59:10 <thoughtpolice> :t Prelude.++
19:59:10 <lambdabot> parse error on input `Prelude.++'
19:59:10 <hatds> Prelude.++ or (Prelude.++)
19:59:11 <roconnor> bobzhang: I think it is Prelude.++
19:59:11 <kmc> bobzhang, (Prelude.++)
19:59:17 <bobzhang> thank you
19:59:19 <thoughtpolice> oh, yeah
19:59:42 <danharaj> Prelude++ sounds enterprise
19:59:55 <roconnor> Mmm, surround sound
20:00:03 <hatds> the file extension would be foo.ppp
20:00:20 <roconnor> #haskell, where you are answered in Dolby 5.1
20:00:32 <bobzhang> hehe
20:00:37 <chenwl> mustelo: so it explains in japanese
20:00:38 <kmc> 5.1 is so last century
20:00:41 <chenwl> ^_^
20:01:26 <mustelo> chenwl, ah. so does it make sense now? it'll get clearer as you become familiar with more monads
20:01:57 <chenwl> mustelo: yes, very clear now
20:03:02 <mustelo> is there are general theory for reasoning about what order my monad stack should be?
20:03:41 <kmc> just unwrap the transformers
20:03:58 <kmc> @unmtl ContT r (State s) a
20:03:58 <lambdabot> (a -> s -> (r, s)) -> s -> (r, s)
20:04:05 <kmc> @unmtl StateT s (Cont r) a
20:04:05 <lambdabot> s -> (a -> s -> r) -> r
20:04:27 <mustelo> oh nice, I didn't know about @unml
20:04:34 <mustelo> s/ml/mtl/
20:05:11 <cmccann> what would unml, translate code from SML to Haskell?
20:05:17 <kmc> alternately, don't use transformers, just write the monad you want
20:05:23 <cmccann> er, what would unml do rather
20:05:37 <mustelo> cmccann, not a bad idea :)
20:05:53 <kmc> i think people have the attitude "oh, I could never *write* a monad myself", but then end up putting in more effort to learn transformers
20:06:46 <ddarius> I think people underuse transformers because they think writing out the definition itself is notable.
20:07:28 <kmc> i've just never been happy with the API you get from a big transformer stack
20:07:41 <kmc> if you're going to newtype-wrap your stack, and provide domain-specific "primitives"
20:08:00 <kmc> then implementing the monad "from scratch" is a viable alternative
20:08:09 <hpaste> dankna pasted “How do I work around this?” at http://hpaste.org/49663
20:08:25 <ddarius> Implementing the monad "from scratch" is a viable alternative either way.
20:08:27 <dankna> copumpkin, or anyone who is familiar with type families: need assistance on that paste
20:08:39 <dankna> willing to pay in firstborn futures
20:08:42 <kmc> dankna, you can't, it's like pattern-matching on a function
20:08:47 <kmc> f (x + y) = x
20:08:48 <dankna> hmm
20:08:55 <ddarius> It would not be much of an exercise to completely rewrite a transformer library.
20:09:05 <dankna> but it's a type function
20:09:11 <dankna> I see what you mean I guess
20:09:28 <dankna> well, I need to write an instance something like that.  there is no provided - operator because it would be partial...
20:09:30 <cmccann> dankna, think about what that would mean with term-level functions
20:09:34 <kmc> it's a type function and not a type constructor
20:09:43 <dankna> hmmm yeah I see
20:09:44 <kmc> data families give you type constructors
20:09:48 <kmc> synonym families dont
20:09:53 <cmccann> you'd be taking a value as input and trying to pattern match on the application that evaluated to it
20:10:33 <dankna> unfortunately I don't see how I can do what I'm trying to do (which is implement a type function which adds my type-level integers, not to be confused with type-level naturals)
20:10:36 <dankna> with a data family
20:10:46 <dankna> it inherently needs to be a synonym family, doesn't it.
20:11:12 <dankna> okay, so I see why I can't do it now
20:11:35 <dankna> but I hope that doesn't mean I'm simply out of luck and there is no way to define addition of type-level integers :)
20:11:56 <cmccann> no, you just need to work from the type-level representation itself
20:12:03 <cmccann> not from the application of type functions
20:12:19 <Saizan> the problem is that these don't have a representation, i think
20:12:38 <Saizan> dankna: you are using the type-nats branch, right?
20:12:41 <dankna> right
20:12:46 <cmccann> oh
20:12:48 <dankna> these are the docs: http://hackage.haskell.org/trac/ghc/wiki/TypeNats/Operations
20:12:56 <dankna> so maybe this is a weakness in the branch
20:12:57 * cmccann was assuming this was was in regular ghc
20:13:04 <dankna> no, I enjoy pain
20:13:11 <dankna> when that pain is caused by someone I love, such as Mr. GHC
20:13:21 <dankna> so yeah
20:13:25 <kmc> yikes
20:13:28 <cmccann> dankna, I'm running some random ghc snapshot because I wanted class context equality constraints
20:13:29 <cmccann> so yeah
20:13:32 <cmccann> I understand
20:13:34 <dankna> haha okay :D
20:13:54 <dankna> I always seem to have some reason for needing the very latest GHC.  this particular build is the first time I've added a branch though.
20:14:13 <dankna> so maybe this is a weakness in type-nats, then
20:14:27 <Saizan> i wonder why - is so much of a problem, it's fine to have type families applied to type they don't have an instance for
20:14:44 <dankna> it's partial
20:14:53 <dankna> because what is the result type of a - b if a < b?
20:15:01 <dankna> remembering that these are nats, not integers
20:15:02 <cmccann> a type error, I imagine
20:15:06 <dankna> hmm
20:15:09 <dankna> well, perhaps.
20:15:24 <cmccann> in the "type class" sense, there's no instance, the end
20:15:31 <dankna> I think I should write an email to the GHC list, cc:ed to the branch author whoever that is, outlining this difficulty
20:15:43 <Saizan> dankna: what is the result type of Foo Int Char when there's not instance for Foo Int Char ?
20:15:51 <Saizan> s/not/no
20:16:12 <dankna> Saizan: okay, yes
20:16:15 <dankna> I see what you mean
20:16:29 <dankna> note that this is also the first time I've used type families
20:16:33 <dankna> but I do understand
20:16:46 <dankna> (I've never felt a need for them up to now? heh)
20:17:07 <dankna> (probably because of that whole type-family/fundep equivalence thing that's being discussed on haskell-prime)
20:17:07 <Saizan> it might be subtler here, given the gadgets associated with the Nat kind
20:17:19 <cmccann> type families really only do one thing of significance that fundeps don't do
20:17:27 <cmccann> and that's have decent syntax to use
20:17:29 <dankna> haha
20:17:35 <dankna> that was someone's position, possibly yours
20:17:41 <dankna> I couldn't follow the debate but I learned a lot from it anyway
20:17:55 <cmccann> no, but my opinions aren't really unique here
20:17:58 <dankna> fair
20:18:06 <Saizan> there's a much more fundamental thing, they interact with gadts
20:19:05 <dankna> hmm
20:19:08 <Saizan> fundeps don't because ghc doesn't really check that the functional dependency is satisfied if you enable enough flags
20:19:09 <dankna> maybe I can work around this by being like
20:19:21 <dankna> (a + b <= c, c <= a + b) in the context
20:19:31 <dankna> wouldn't it be nice if there were an = operator haha
20:19:34 <dankna> can I define my own somehow?
20:19:37 <Saizan> there is
20:19:41 <Saizan> ~
20:19:43 <dankna> oh!
20:19:46 <dankna> a + b ~ c then
20:20:14 <Saizan> i don't think you can use that to make a type family instance though
20:20:42 <dankna> I'll try it and see what the error is, one sec
20:20:59 <cmccann> I think ~ pretty much works as expected in any context
20:21:01 <parcs> cmccann:  it's much easier to write a class Plus m n r | m n -> r, r n -> m, r m -> n than the corresponding type-family-based class
20:21:19 <cmccann> parcs, yes, fundeps are more expressive in some ways
20:21:22 <copumpkin> I think he's trying to squeeze subtraction out of it
20:21:24 * cmccann doesn't deny that
20:21:31 <copumpkin> I don't think it's a type family / fundep issue
20:21:32 <dankna> I am trying to get subtraction, yes
20:22:02 <dankna> hmm
20:22:07 <dankna> do type instances support putting contexts on them at all
20:22:12 <dankna> and if so, what's the syntax?
20:22:21 <copumpkin> I doubt it
20:22:43 <cmccann> copumpkin, hey, we should celebrate new powers by doing something ridiculous to /r/haskell's styling
20:22:52 <cmccann> :P
20:22:57 <copumpkin> lol
20:23:17 * copumpkin flexes his muscles
20:23:58 <cmccann> I kind of want to replace the downvote arrow buttons with a ⊥
20:27:16 <dankna> part of the reason I'm so convinced subtraction must be possible is that the "docs", such as they are, give an example with division!
20:27:43 <dankna> but that's not using a type synonym instance, heh
20:27:57 <cmccann> dankna, where'd you get the build you're using?
20:28:16 <dankna> oh, I made it on Tuesday
20:28:33 <dankna> I packed it up nicely for both OS X Lion and Linux
20:28:44 * cmccann would be tempted to give it a shot himself, but doesn't want to build a GHC
20:28:46 <dankna> and someone asked if they could have it so I wrote a blog post on Google+ about how to install it from my pack
20:28:50 <dankna> what platform are you on?
20:29:11 <dankna> it might be worth my time to build a GHC for you :)
20:29:25 <cmccann> Ubuntu
20:29:29 <cmccann> a non-64-bit version I think
20:29:31 <dankna> x86?
20:29:36 <dankna> okay, the build I have is 32-bit
20:29:39 <dankna> let me upload it
20:29:52 <cmccann> ok. cool.
20:32:01 <dankna> is a stow package an okay form of distriubtion for you?  that is, you would put untar it in /usr/local/stow/, thereby creating /usr/local/stow/ghc-7.3.20110726
20:32:39 <cmccann> I have no idea!
20:32:41 <dankna> then invoke stow ghc-7.3.20110726, and it would create symlinks to make it appear as if you had untarred on top of /usr/local
20:32:52 <dankna> to remove it later you simply stow -D ghc-7.3.20110726
20:32:54 * cmccann has no idea what stow is about
20:33:06 <dankna> well, I just told you what stow is about.  that's?. the entire concept :)
20:33:10 <dankna> lucca: ohai!
20:33:19 <lucca> Stow is a mini package system using symlink farms.  It's worth looking at.
20:33:25 <lucca> dankna: heh, hello you.
20:33:44 <dankna> lucca: I am simultaneously visiting my father outside Philly and attending HacPhi :)
20:33:52 <dankna> it is much fun in both respects
20:33:57 <dankna> how have you been?
20:34:20 <cmccann> dankna, oho! that is a nicely simple concept.
20:34:26 <cmccann> I'll give it a shot because that does sound useful
20:34:33 <dankna> it is, yes
20:34:54 * cmccann installs stow
20:34:58 <dankna> great, that saves me figuring out how to make a bindist (and how you would install/uninstall from one)
20:35:05 <lucca> still alive o/~
20:35:13 <dankna> I'm making a note here? o/~
20:35:33 <dankna> http://dankna.com/himitsu/ghc-7.3.20110726.tar.bz2
20:35:34 <cmccann> dankna, I already have like five GHCs installed so not having more would be nice
20:35:39 <dankna> lol yeah
20:35:41 <dankna> same here
20:36:06 <zzo38> I invented a AWK program that allows any program to use bird style, not only Haskell.
20:36:08 <dankna> what you might want to do is
20:36:12 <zzo38> The program is:       /^> /&&sub(/> /,"")
20:36:23 <dankna> noting that the tarball contains symlinks bin/ghc -> ghc-7.3.20110726
20:36:25 <dankna> and so on
20:36:31 <dankna> delete those internal symlinks before you run stow
20:37:05 <zzo38> I am sure you can make this in Haskell, too, but I think AWK is good for these kind of thing
20:37:14 <dankna> the effect of that will be that you don't have to worry about the order of your bin directories in your PATH because the GHC I am giving you will be accessible only through its full versioned name
20:38:21 <dankna> I also have binaries of some common packages, but you shouldn't need them for this
20:40:33 <dankna> cmccann: okay, once you have that GHC installed, you can get my actual code (one file, no .cabal yet, I've been testing under ghci) by doing darcs get http://dankna.com/software/darcs/direct-dimensions/
20:40:51 <cmccann> hm
20:41:00 * cmccann doesn't see where the ghc is :?
20:41:06 <dankna> where did you untar it?
20:41:20 <dankna> the ghc is in ./ghc-7.3.20110726/bin/ghc
20:41:38 <dankna> after running stow from . it will be in ../bin/ghc (or rather, a symlink to it will)
20:41:40 <cmccann> doesn't seem to be a ghc in /bin :?
20:41:44 <dankna> eh?
20:41:48 <dankna> maybe I prepped the tarball wrong
20:41:49 <dankna> doublechecking
20:41:57 <cmccann> either that or I did something weird untarring it
20:42:33 <dankna> oh
20:42:51 <dankna> I ? somehow tarred the wrong directory?
20:42:58 <dankna> sorry for the inconvenience, fixing that now
20:43:02 <cmccann> haha ok
20:43:11 * cmccann was just confused for a moment 
20:43:18 <dankna> with reason!  haha
20:43:35 <cmccann> should I junk the contents of this one then
20:43:39 <cmccann> or is anything in there useful
20:43:41 <dankna> yes, junk it
20:43:46 <dankna> it's a buncha packages from Hackage
20:43:50 <dankna> built against that GHC
20:43:50 <cmccann> ok.
20:44:05 <cmccann> yeah that's what I figured.
20:44:06 <dankna> but it would be a pain to get them installed, nor are they necessary for what we're doing
20:47:56 <dankna> ghc sure does consist of a lot of files!
20:49:10 <cmccann> yes, those are where it stores the magic
20:49:27 <dankna> ah, I thought that was in the smoke
20:50:28 <kmc> ghc is unquestionably the world's finest compiler for the Cmm language
20:50:58 <cmccann> GHC is quite effective at compiling quite a few languages it seems
20:51:10 <cmccann> how many intermediate representations does it even have, again?
20:51:24 <kmc> Core -> STG -> Cmm iirc
20:51:35 <kmc> $ ghc --supported-languages | wc -l
20:51:38 <kmc> 142
20:51:51 <dankna> cmccann, okay: http://dankna.com/himitsu/ghc-7.3.20110726.tar.bz2 again
20:51:53 <kmc> we may conclude GHC can compile at least 2^71 languages
20:51:54 <dankna> same URL but different contents
20:52:01 <cmccann> kmc, :D
20:52:11 <cmccann> kmc, power set of all extensions I assume
20:52:30 <kmc> yeah -- most of them are listed as Foo and NoFoo both
20:52:41 <cmccann> some imply others as well, but whatever
20:56:37 * hackagebot Lucu 0.7.0.2 - HTTP Daemonic Library  http://hackage.haskell.org/package/Lucu-0.7.0.2 (MasatakeDaimon)
20:57:10 <dankna> I was just telling a friend who's a Perl-er this morning that we are moving away from having them imply each other
20:57:12 <dankna> gradually though
20:58:05 <cmccann> hey at least it's not just -fglasgow-exts
20:58:17 <dankna> no kidding
20:59:43 <Saizan> those were simpler times
21:00:12 <dankna> a more civilized age
21:00:13 <dankna> yes
21:02:19 <kmc> i don't program in Perl, i program in 43f22e7d87ff2f66518143d6b8e446cba856a8c2
21:02:26 <dankna> ><
21:02:28 <kmc> that's the SHA1 of my /usr/bin/perl
21:02:28 <dankna> I see haha
21:02:41 <kmc> only way to be sure what language you're using
21:02:49 <kmc> md5 too weak
21:02:55 <hatds> ha, I like this in ghci ":def! print return . show"  --easy way to get my hands on haskell-ified strings without doing the escaping myself
21:02:55 <dankna> we were discussing something related at HacPhi earlier
21:03:04 <dankna> saying that it would be nice if package version numbers were replaced by the entire .hi file
21:04:13 <lucca> You've never had to install a perl app on a client's machine, scratch your head wondering why -nothing- works, then type perl -v and get back perl4 >_>
21:04:29 <dankna> indeed, I haven't
21:04:43 <lucca> or, in the same vein, I had to CPAN 5 miles through the snow...
21:04:55 <dankna> yes, edwardk was telling us about this nightmare earlier
21:08:35 <cmccann> dankna, hm, gives me an error about not finding libgmp.so.10
21:08:51 <dankna> oh!  right
21:09:05 <dankna> install libgmp (don't need -dev) through Ubuntu's package manager
21:09:16 <kmc> lucca, we get reports back regularly of our software failing due to "Cannot find strict.pm"
21:09:27 <lucca> ....augh
21:09:31 <dankna> ><
21:10:13 <cmccann> dankna, I already have libgmp though :T
21:10:16 <dankna> oh
21:10:17 <dankna> hmmm
21:10:21 <dankna> yeah, I'm on Debian :(
21:10:29 <dankna> depending on how serious you are about being willing to try this
21:10:38 <dankna> I could spend the next X hours making an Ubuntu VM and reproducing my build on it
21:11:21 <cmccann> well I'd be willing but I need to get to sleep sooner than that
21:11:33 <cmccann> and may be busy this weekend
21:11:41 <cmccann> so probably not worth bothering with :[
21:11:47 <hpaste> dankna pasted “Arisia Engine” at http://hpaste.org/49664
21:12:00 <dankna> (unrelated to GHC)
21:12:03 <dankna> that's fine cmccann
21:12:16 <dankna> (that link is for lucca, or anyone who has an interest in games I guess)
21:34:40 <DannoHung> How would you go about keeping the Haskell platform package up to date? I usually just use ports, but the ghc port is seriously out of date
21:35:01 <dankna> I wouldn't use it, I would compile my own :)
21:35:34 <DannoHung> Awww… I like having things managed for me, cuz I'm all lazy and such.
21:35:58 <dankna> well, so do I
21:36:03 <dankna> but that's the tradeoff
21:36:40 <cmccann> I just ignore the Haskell platform, install new GHC binary distributions whenever I want new features, and install lots and lots of stuff from hackage
21:37:11 <dankna> yes, indeed
21:37:20 <dankna> I ignore the platform and use hackage extensively
21:38:45 <cmccann> my impression is that the haskell platform seems mostly aimed at being a quick bootstrap starting point for newcomers and at being a sort of second-tier consensus point for what constitutes reasonably common packages &c.
21:39:06 <dankna> both worthy goals
21:39:11 <cmccann> right
21:39:22 <dankna> but I opt out because it's too hard to build an installer from it, basically
21:39:31 <dankna> I would use it if I could make it work with my custom GHCs
21:40:11 <cmccann> yeah, basically it's for people who want a stable platform that's not on like GHC 5 or whatever you get from the distro repositories ugh
21:40:28 <dankna> right ugh
21:40:30 <cmccann> if you're wanting to keep up with "current" stuff, you do what I do
21:40:50 <cmccann> if you want to live in ~~~ THE FUTURE ~~~ you do what dankna does and build your own GHCs
21:40:59 <dankna> Ia ia ftaghn.
21:41:00 <dankna> indeed.
21:41:12 <kmc> the future is in the future
21:41:13 <DannoHung> I'd need a build machine for that. Friggin' takes hours on a laptop.
21:41:21 <dankna> takes hours on my server too :(
21:41:30 <dankna> kmc: the future is also on my laptop.
21:41:31 <cmccann> yeah
21:41:44 <dankna> the GHC build system doesn't parallelize at all I don't think
21:41:50 <dankna> so there's not much point in a build machine
21:41:57 * cmccann is willing to assert that GHC builds in a finite amount of time but that's about it
21:42:01 <dankna> haha yeah
21:42:02 <DannoHung> Aside from not burning your lap
21:42:06 <dankna> well, yes
21:42:22 <dankna> I actually put the laptop on the nightstand and take a nap when I build GHC ><
21:42:33 <dankna> cause I know my productivity is shot till it finishes anyway haha
21:42:35 <DannoHung> I would literally be afraid of the nightstand catching on fire.
21:42:39 <dankna> yeah, no, I hear you
21:42:40 <cmccann> hahaha
21:43:29 <kmc> dankna, you can parallel build GHC itself
21:43:34 <kmc> it just uses gnu make
21:43:41 <kmc> make -j32 whatever
21:43:48 <dankna> oh
21:43:50 <dankna> good call
21:43:52 <dankna> must remember that :)
21:43:56 <kmc> you can't parallelize ghc --make, though
21:44:03 <dankna> yeah, no, I don't care about that
21:44:07 <dankna> nothing I want to build is as large as GHC
21:44:51 <kmc> last time i built ghc i got 444% CPU on a 6-core machine with -j12
21:45:22 <dankna> wowza
21:45:23 <dankna> nice
21:45:29 <dankna> good to know
21:45:46 <clsmith> how long did it take to build?
21:46:13 <kmc> 17 minutes real time
21:46:23 <dankna> doublewowza
21:46:36 <kmc> yeah, wish i'd had this system back when i was doing GHC development, heh
21:46:40 <kmc> maybe i will get back into that
21:46:48 <kmc> can implement some of these extensions i keep bitching about
21:47:10 <dankna> like which?
21:47:14 <Eduard_Munteanu> Just remember not to 'make clean', at least not too often :)
21:47:25 <dankna> indeed
21:52:49 <kmc> dankna, ACIO
21:52:59 <dankna> gesundheit
21:53:06 <cmccann> heh
21:53:08 <dankna> what is ACIO?
21:53:13 <kmc> IO actions at top level
21:53:18 <kmc> implemented in JHC
21:53:31 <dankna> oh hm
21:53:36 <dankna> that sounds interesting
21:53:42 <cmccann> and easily abused
21:53:47 <cmccann> but also useful
21:54:48 <kmc> yes
21:55:17 <kmc> i see it as "harm reduction" compared to the current {-# NOINLINE foo #-} foo = unsafePerformIO (newIORef 0)  -- whoops my IORef is polymorphic, i accidentally the whole type system
21:55:47 <cmccann> yes
21:56:08 <dankna> yes
21:56:11 <dankna> that's a good perspective
21:56:15 <cmccann> I still contend that most of the time doing that indicates poor program design, of course
21:56:27 <kmc> agreed
21:56:29 <Saizan> in the case of 0 there's the MR :)
21:56:54 <cmccann> but it's not entirely unreasonable either, and having a more controlled sensible way to do it would be nice
21:56:59 <kmc> right
21:57:12 <kmc> in general i don't like the logic of "we want to discourage X, so let's make it difficult and dangerous"
21:57:30 <kmc> i prefer "explicit but easy and safe"
21:57:52 <kmc> i mean call the language pragma TopLevelIOActionsHackDontUseThis for all i care
21:58:15 <kmc> one use case that comes to mind is creating a global MVar to serialize access to a non-threadsafe C library
21:58:16 <cmccann> I mostly care about the explicit part, really
21:58:45 <kmc> the MVar shouldn't leak to users, but it still needs to be available to all your FFI calls
21:58:55 <cmccann> yeah, I can see it being most common in cases like that
21:59:05 <kmc> also "behind the scenes" performance counters and whatever
21:59:17 <kmc> log file
21:59:24 <kmc> ACIO has restrictions on what IO can be done at top level
21:59:27 <dankna> yeah
21:59:40 <kmc> actually log file is probably too dodgy
21:59:50 <kmc> but something like fetching and parsing command-line arguments
21:59:57 <cmccann> cases where something using the FFI is forced into a more imperative program structure anyway, and trying to use a sensibly Haskell-idiomatic design would work at cross-purposes
22:00:12 <kmc> or even reading a config file which you're willing to treat as immutable data
22:00:43 <cmccann> I still think there are usually better designs in that case
22:00:47 <cmccann> but again, sometimes it makes sense
22:00:49 <kmc> ACIO actions have to be irrelevant if result is ignored ("affine") and commute with the rest of IO ("central")
22:01:17 <cmccann> and a controlled, explicit means of doing stuff like that would be good to have
22:01:32 <kmc> so it's pretty much stuff like creating MVars
22:01:41 <kmc> actually i bet the restrictions are similar to what you want for STM
22:01:59 <kmc> STM actions don't commute with each other, of course
22:02:03 <kmc> but i feel like there's some similarity
22:02:05 <cmccann> also, I find dubious hackish workarounds a lot more tolerable if I know that I can use a compiler flag to disable them and know that they're really gone
22:02:16 <kmc> cmccann, yeah
22:02:24 <kmc> GHC 7.2 has SafeHaskell which goes toward that goal
22:02:48 <kmc> ACIO also has an embedding function of type IO a -> ACIO (IO a)
22:03:13 <kmc> which only runs the IO action once
22:03:20 <hpaste> strager pasted “calc” at http://hpaste.org/49665
22:03:29 <kmc> but only once the result is demanded in the stream of normal IO, so it's kosher
22:03:53 <cmccann> yeah, I've occasionally wished for a per-module NoUnsafeFunctions pragma, but SafeHaskell is a more coherent approach
22:03:59 <strager> I'm learning Haskell.  Would someone have time to review my code?  Currently it's a tokenizer for a simple calculator.  http://hpaste.org/49665
22:04:03 <kmc> SafeHaskell is complicated, though
22:04:29 <cmccann> it seemed straightforward enough to me, just with multiple fine-grained distinctions
22:04:32 <kmc> strager, first = msum
22:04:54 <strager> msum?  I get 'not in scope'
22:04:56 <kmc> cmccann, i don't know.  it's a nontrivial trust model; people are bound to mis-apply it
22:05:00 <kmc> strager, import Control.Monad
22:05:06 <cmccann> kmc, hm, true
22:05:35 <kmc> strager, why "where read = readToken str"?
22:05:36 <strager> thanks
22:05:41 <kmc> you can just move that into the "case" head
22:05:58 <strager> oh you're right
22:07:15 <strager> I'm mostly wondering how idiomatic the code is.  "Would a Haskeller write it like this", basically.
22:07:25 <kmc> pretty good
22:07:33 <kmc> i'd probably use the prelude function 'read' instead of digitsToInt
22:08:03 <strager> okay
22:08:10 <kmc> "let c:rest = str in ..." is kinda bad
22:08:17 <kmc> because "what if str = [] and the pattern fails"
22:08:20 <kmc> it can't, in this case
22:08:25 * cmccann finds strager's indentation scheme a bit odd, but opinions differ there
22:08:27 <kmc> but you can move it out and be more explicit about why it can't
22:08:32 <kmc> readToken str@(c:rest) = ...
22:09:22 <kmc> «if isWhitespaceChar c then readToken rest else Nothing»  ≡  «guard (isWhitespaceChar c) >> readToken rest»
22:09:34 <strager> I don't see how I can "move it out"
22:09:41 <kmc> readToken str@(c:rest) = ...
22:09:44 <strager> cmccann: I dunno; I just tried to line stuff up.
22:09:56 <cmccann> strager, yes, I just line up different things :]
22:10:01 <cmccann> I can show you how I'd write it if you like
22:10:06 <strager> cmccann: Sure
22:10:34 <kmc> strager, again in readNumberToken and readOperatorToken you bind a local name "split" and then do "case split of" and don't mention "split" again
22:10:41 <kmc> just move those into the case
22:10:43 <hpaste> strager pasted “calc” at http://hpaste.org/49666
22:10:53 <kmc> also the two functions look pretty similar
22:10:57 <strager> ^ That doesn't work, so I am clearly misunderstanding something
22:11:16 <kmc> you can probably combine the two
22:11:17 <strager> Yeah, I noticed they were similar.  I could probably refactor that.  (Leave that as an exercise for me ;P)
22:11:31 <kmc> strager, your new readToken has three alternative equations instead of two
22:11:48 <kmc> it will never use the third because one of the first two always matches
22:11:55 <strager> I know that.
22:12:09 <strager> I was trying it to rewrite it to what you suggested: 01:27 < kmc> readToken str@(c:rest) = ...
22:12:17 <strager> but I didn't understand what you meant exactly.
22:12:28 <kmc> readToken str@(c:rest) = msum [readOperatorToken str, readNumberToken str, guard (isWhitespaceChar c) >> readToken rest]
22:12:35 <strager> ah
22:13:06 <strager> I don't understand how guard and >> work so I will keep my form for now
22:13:10 <kmc> ok
22:13:24 <kmc> guard and (>>) are very general functions that apply to types other than Maybe
22:13:44 <kmc> but what they do for Maybe is pretty simple
22:14:08 <kmc> guard True = Just (); guard False = Nothing
22:14:33 <kmc> Just _ >> x = x;  Nothing >> _ = Nothing
22:16:23 <kmc> (>>) is general because it's declared in a type class and implemented differently for each type in that class
22:16:26 <kmc> just like (+) is
22:16:33 <kmc> the types implementing (+) are called "numbers"
22:16:38 <kmc> the types implementing (>>) are called "monads"
22:17:05 <kmc> (perhaps "numeric types" not "numbers" -- the numbers are the values themselves)
22:17:41 <strager> So >> has low precedence, and in this case it converts a maybe to a maybe
22:17:53 <kmc> it's a binary operator
22:18:00 <kmc> so it converts two things to one thing, so to speak
22:18:05 <hpaste> “C. McCann” annotated “calc” with “calc (annotation)” at http://hpaste.org/49665#a49667
22:18:12 <kmc> and its precedence doesn't matter
22:18:17 <cmccann> strager, just some trivial reformatting
22:18:24 <cmccann> to show how I'd arrange things
22:18:26 <kmc> all infix operators bind more loosely than function application syntax
22:18:31 <cmccann> mostly a matter of taste though
22:19:55 <strager> oh, okay (re binding)
22:20:39 <strager> cmccann: cool, thanks
22:26:21 <hpaste> strager annotated “calc” with “calc (refactor)” at http://hpaste.org/49665#a49668
22:26:28 <strager> ^ New and improved
22:27:11 <strager> I noticed that line 17 is long and has some repeating parts (Maybe (Token,String) in particular).  Any way I can factor that out?
22:28:54 <hpaste> “C. McCann” pasted “alternate refactoring” at http://hpaste.org/49669
22:29:01 <cmccann> strager, how about something like that
22:30:03 <strager> that's even better
22:30:13 <strager> didn't think of that; thanks
22:31:56 <strager> much better =]
22:32:10 <kmc> strager, type Lexer = String -> Maybe (Token, String)
22:32:29 <kmc> readGenToken :: (String -> Token) -> (Char -> Bool) -> Lexer
22:33:08 <strager> okay
22:33:13 <strager> I don't know about 'type' yet
22:33:22 <kmc> it creates a type synonym
22:33:29 <strager> I figured as much
22:33:40 <kmc> unlike 'data' and 'newtype', which introduce new types with new data constructors
22:33:56 <kmc> also, 'type' can take parameters:
22:34:00 <kmc> type Two a = (a, a)
22:38:11 <strager> Okay, now I am moving onto the expression parser part of the calculator.  I have this, but it gives me Not in scope: type constructor or class `NumberToken':
22:38:15 <strager> data Expression = NumberExpression (NumberToken Int) | BinaryExpression Expression Expression
22:38:58 <kmc> NumberToken isn't a type
22:39:11 <kmc> and it definitely doesn't take a type parameter
22:39:11 <hpaste> “C. McCann” pasted “other possible refactorings” at http://hpaste.org/49670
22:39:16 <cmccann> strager, a few other things
22:39:27 <kmc> i think you want just data Expression = NumberExpression Int | BinaryExpression Expression Expression
22:39:36 <cmccann> mostly to make it more obvious what things are doing
22:39:43 <kmc> you'll pull the Int out of the NumberToken value constructor, and put it into the NumberExpression value constructor
22:39:54 <cmccann> assuming you don't want to just use "read" I think this makes the digitsToInt more obviously correct
22:40:18 <strager> kmc: Oh, you're right
22:40:21 <cmccann> and tokenize was just reimplementing a standard function
22:40:22 <strager> I was thinking about it wrong
22:41:17 <strager> cmccann: I have never seen unfoldr.  I see your method of reading a number, and it's interesting (and probably works better with decimals with modification).  I think I'll stick to read digits :: Int, though.  =]
22:41:39 <cmccann> probably the way to go, yeah
22:42:57 <cmccann> the point with digitsToInt is writing it in a way that makes the algorithm obvious (multiply by place values, sum up results) compared to the fold
22:43:39 <cmccann> makes it easier to see if things are correct
22:44:12 <cmccann> @src unfoldr
22:44:13 <lambdabot> unfoldr f b  = case f b of
22:44:13 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
22:44:13 <lambdabot>    Nothing        -> []
22:44:31 <cmccann> and unfoldr is the generic version of exactly what you wrote, as you can see
22:49:15 <Nisstyre> Is there any way to make this function more efficient? http://codepad.org/FtuPLPJ7
22:49:59 <kmc> use foldl' instead of foldl
22:50:00 <hpaste> sutabi pasted “Is it possible to have widthdraw parse the number or be 0.00 on fail?” at http://hpaste.org/49671
22:50:15 <Nisstyre> kmc: how does strictness make it better?
22:50:47 <kmc> Nisstyre, no need to build a big thunk (1 + (2 + (3 + ...)))
22:50:52 <kmc> that takes time and space
22:50:59 <Nisstyre> kmc: ah, okay
22:51:12 <Nisstyre> it will cause a stack overflow potentially right?
22:51:14 <kmc> yeah
22:51:25 <kmc> generally one should use foldl' if the result is "monolithic" like a Float
22:51:35 <kmc> and foldr if the result is itself produced lazily
22:51:43 <Nisstyre> okay, thanks
22:51:50 <kmc> like:   map f = foldr ((:) . f) []
22:52:08 <kmc> Nisstyre, also, you can avoid traversing the list twice, if you use a more complicated fold
22:52:22 <kmc> that both sums and counts the elements, returning a pair
22:52:47 <kmc> in that case foldl' will not save you; forcing the pair does not force the things inside
22:52:55 <kmc> so you can use bang patterns or a strict-pair datatype
22:52:58 <Nisstyre> kmc: yeah that was my thought, but I didn't know how to implement it
22:53:05 <kmc> i believe RWH's performance chapter uses exactly this example :D
22:53:21 <Nisstyre> kmc: I'm doing the examples from Chapter 3
22:53:29 <Nisstyre> er, exercises that is
22:53:44 <kmc> yeah, it's in chapter 25
22:54:37 <kmc> > foldr (\x (s, n) -> (s+x, n+1)) (0,0) [1..10]
22:54:37 <lambdabot>   (55,10)
22:54:57 <Nisstyre> nice
22:55:09 <kmc> > foldr (\x -> (+x) *** (+1)) (0,0) [1..10]
22:55:10 <lambdabot>   (55,10)
22:55:20 <kmc> @pl (\x -> (+x) *** (+1))
22:55:20 <lambdabot> (*** (1 +)) . (+)
22:55:25 <kmc> ;P
22:57:47 <kmc> > foldl' (\(!s, !n) x -> (s+x, n+1)) (0,0) [1..10]
22:57:48 <lambdabot>   (55,10)
22:58:21 <shachaf> > foldr (((***) `on` (+)) 1) (0,0) [1..10]
22:58:22 <lambdabot>   (10,55)
22:58:51 <shachaf> That just might be over-@pled.
22:59:30 <kmc> heh
22:59:38 <kmc> yeah, i don't think @pl knows about 'on'
22:59:46 <kmc> had an example earlier which was much nicer with it
22:59:58 <shachaf> I mean, over-point-free-styled for readability.
23:00:06 * shachaf uses @pl in the generic sense.
23:00:19 <kmc> right
23:00:49 <pdxleif> Folks know of a nicer idiom for (if elemIsCool then (elem :) else id) list?
23:01:13 <pdxleif> aka if elemIsCool then elem:list else list
23:01:35 <kmc> maybe move things around and use 'filter'?
23:02:05 <pdxleif> Like some applicative functor mumbo-jumbo to only apply the function if it exists?
23:02:14 <kmc> exists?
23:02:40 <pdxleif> Maybe Elem, I guess
23:03:10 <pdxleif> Like if I pulled that elem out of another list, where it might be present. Maybe
23:03:22 <kmc> :t catMaybes
23:03:23 <lambdabot> forall a. [Maybe a] -> [a]
23:03:48 <kmc> pdxleif, why not use filter? because you don't want to build a big list and then throw out some of it?
23:03:55 <shachaf> > maybe id (:) (Just 'a') "abc"
23:03:56 <lambdabot>   "aabc"
23:03:59 <shachaf> > maybe id (:) Nothing "abc"
23:04:00 <lambdabot>   "abc"
23:04:48 <pdxleif> Nice...
23:05:16 <PatrickRobotham> @t maybe
23:05:16 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
23:05:27 <PatrickRobotham> :t maybe
23:05:27 * shachaf doubts it's clearer.
23:05:28 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
23:05:53 <shachaf> @src maybe
23:05:53 <lambdabot> maybe n _ Nothing  = n
23:05:53 <lambdabot> maybe _ f (Just x) = f x
23:06:06 <pdxleif> :t maybe id (:)
23:06:07 <lambdabot> forall a. Maybe a -> [a] -> [a]
23:07:14 <kmc> pdxleif, 'filter' applied to a list that's being produced lazily should have similar performance to a list producer which does the filtering itself
23:07:35 <kmc> GHC may even optimize them to eliminate the intermediate (:)-cells
23:08:07 <kmc> but even if it doesn't, it will filter the list as it goes
23:09:03 <pdxleif> This is actually for Scala code at the moment...
23:09:05 <pdxleif> https://github.com/LeifW/Treeify/blob/regular_json/src/main/scala/Treeify.scala
23:09:47 <kmc> ah, the good old secret scala question ;)
23:09:48 <pdxleif> line #25 adds a uri identifier to a list of tuples if it "exists"
23:10:02 <cmccann> the best idiom for writing stuff this in Scala is probably to write it in Haskell isntead </troll>
23:10:15 <pdxleif> Well, no one wants to type out all that Scala just to ask a question...
23:10:26 <PatrickRobotham> what does "forall" mean in haskell?
23:10:40 <kmc> PatrickRobotham, strictly speaking, nothing special.  it's a GHC extension
23:10:44 <shachaf> It means "for all".
23:10:48 <cmccann> PatrickRobotham, http://en.wikipedia.org/wiki/Universal_quantification
23:10:48 <kmc> (and an extension in some other implementations)
23:11:01 <kmc> PatrickRobotham, it's used to explicitly introduce type variables in a polymorphic type
23:11:07 <kmc> :t map
23:11:07 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
23:11:27 <kmc> in standard Haskell that would be written "(a -> b) -> [a] -> [b]"
23:11:40 <kmc> but GHC allows you to explicitly introduce the variables
23:11:47 <kmc> which serves a couple of distinct purposes
23:12:39 <cmccann> which has the same meaning, but variables in type signatures are implicitly universally quantified at the outermost scope of the signature
23:13:17 <PatrickRobotham> so why go to the trouble of explicitly introducing the variables kmc?
23:13:35 <cmccann> PatrickRobotham, with certain GHC extensions you can introduce them explicitly in ways that mean something else
23:14:05 <cmccann> without that there's no point, e.g. in lambdabot's type signature for map they're superfluous
23:14:33 <kmc> PatrickRobotham, one is the ScopedTypeVariables extension: explicitly-introduced variables can be used in type signatures within the binding for which they were introduced
23:14:55 <kmc> normally if i write «f :: a -> b; f x = .... where { g :: a -> b; ... }»
23:15:05 <kmc> the a,b in g's type signature are unrelated to the ones in f's
23:15:15 * cmccann always thought that the scoped type variables made a lot more sense than the default
23:15:29 <kmc> with ScopedTypeVariables "f :: forall a b. a -> b" will bring them into scope
23:16:28 <kmc> PatrickRobotham, another extension (RankNTypes) lets you write certain types which are not allowed in standard Haskell
23:16:36 <kmc> e.g.:
23:16:37 <kmc> :t runST
23:16:38 <lambdabot> forall a. (forall s. ST s a) -> a
23:17:04 <kmc> there's nothing in standard Haskell corresponding to this use of "forall" on the left argument of (->)
23:17:20 <kmc> in standard Haskell, polymorphism is exclusively used to promise flexibility
23:17:29 <kmc> but runST is a function which *requires* flexibility from its argument
23:18:31 <kmc> yet another extension (ExistentialQuantification) affects data types and uses the "forall" syntax to accomplish "exists" quantification, the logical opposite of "for all"
23:18:39 <kmc> but they use the "forall" keyword for murky reasons
23:19:00 <kmc> (the *constructor* ends up having a corresponding forall in its type)
23:19:13 <cmccann> the reasons aren't that murky
23:19:26 <pdxleif> :t (++) . maybeToList
23:19:27 <lambdabot> forall a. Maybe a -> [a] -> [a]
23:19:29 <cmccann> they're just hard to explain without creating three times as many questions as before the explanation
23:19:36 * kmc thinks H98 data declaration syntax is bordering on broken, and becomes totally wrecked if you add, say, existentials
23:19:58 <shachaf> kmc: What's a less broken syntax?
23:20:03 <kmc> shachaf, GADTs
23:20:08 <kmc> PatrickRobotham, so there are three extensions using "forall"; you can read about each one in the GHC manual
23:20:16 <shachaf> I still think GADT syntax is weird.
23:20:28 <kmc> how so?
23:21:16 <kmc> H98 data syntax has an '=' in it, and that '=' is basically a lie
23:21:37 <kmc> it also juxtaposes value-level and type-level terms
23:21:48 <shachaf> That's true, the syntax is pretty weird.
23:22:14 <kmc> it's not obvious when you're just starting that "data Foo = Bar Int" has a type, a value, and another type
23:22:40 <kmc> GADT syntax is more consistent with the rest of the language
23:22:42 <cmccann> Especially when people go and use the same name for a type in one place, and a constructor somewhere else
23:22:43 <shachaf> Right. But it's not obvious that "Just :: a -> Maybe a" is declaring a data type that "holds" the a in the Maybe a.
23:23:00 <kmc> you give the type of each constructor and you write those types the same way you'd write them elsewhere
23:23:06 <shachaf> It looks like a function without a definition.
23:23:10 <PatrickRobotham> kmc: Thanks!
23:23:19 <kmc> shachaf, it is a function without a definition, of sorts
23:23:20 <shachaf> Also, the pattern-matching syntax makes less sense that way.
23:23:38 <kmc> algebraic data constructors are like free variables
23:23:49 <kmc> i wonder if that's actually a useful way to think about them
23:23:55 * cmccann prefers to think of data types in terms of their church encodings
23:24:21 <shachaf> Also, it's much less concise than the H98 syntax.
23:24:47 <shachaf> It feels like there's extra information there.
23:24:50 <kmc> shachaf, you just have to know that "functions" defined inside "data" have no definition or reduction rules, and that instead you're allowed to pattern-match on their applications
23:25:03 <kmc> that is a thing you have to know, but it's part of the concept of algebraic data anyway
23:25:16 <kmc> whereas the things you have to know about H98 syntax are contingent details
23:25:22 <cmccann> e.g. I look at Just as implying (a -> r) -> r, (:) as implying (a -> [a] -> r) -> r etc.
23:25:36 <kmc> shachaf, yes, it is redundant for non-GADT types
23:25:41 <kmc> that's unfortunate
23:26:05 <kmc> but anyway I think GADT syntax is clearer to such an extent that my hypothetical "haskell from first principles" tutorial would use GADT syntax from the beginning
23:26:08 <cmccann> keeping in mind that the types I gave are the same as the ones in the GADT syntax, except with the CPS-ish bit at the end instead of the data type
23:26:09 <shachaf> I don't think GADT syntax is ideal, though I haven't seen a better proposal that's as expressive.
23:26:23 <kmc> with an appendix on "deviations from Haskell 2010" or whatever
23:26:35 <shachaf> Are GADTs part of H10?
23:26:40 <kmc> nope
23:26:52 <shachaf> Hah.
23:26:54 <kmc> H0A is super conservative
23:27:03 <cmccann> kmc, I actually think the church-encoding way of looking at it that I like justifies the GADT syntax sufficiently
23:27:06 <shachaf> ...0A? Come on.
23:27:09 * kmc can't decide between titles "Haskell From First Principles" and "Oh Fuck, Not Another Haskell Tutorial"
23:27:28 <kmc> shachaf, in solidarity with the poor C++0C folks, of course
23:27:30 <shachaf> Why not HDA?
23:27:50 <kmc> why not H7DA?
23:28:18 <dankna> so yeah
23:28:25 <dankna> I realized that I could reword my what I want as
23:28:28 <dankna> type instance (bc <= a, b + c ~ bc) => MinusNat a bc = b
23:28:47 <dankna> but that isn't possible because type-synonym instances can't have contexts
23:28:51 <kmc> what's "<=" as a constraint?
23:28:56 <dankna> less than or equal to
23:29:03 <shachaf> And +?
23:29:09 <kmc> oh, this is using the new support for type-level naturals?
23:29:11 <dankna> yes
23:29:13 <shachaf> Oh,.
23:29:15 <kmc> shiny!
23:29:20 <dankna> + is what it looks like :)
23:29:23 <dankna> yes, very shiny!
23:29:28 <shachaf> How new is it?
23:29:33 <dankna> but it can't, afaict, be used to implement type-level naturals
23:29:33 <kmc> HEAD new
23:29:39 <dankna> newer than HEAD
23:29:43 <dankna> I had to merge the branch myself
23:29:52 <kmc> it's still underground
23:29:54 <shachaf> So new it doesn't actually compile yet.
23:30:01 <kmc> you have time to get in before it goes all mainstream
23:30:02 <dankna> it actually does compile, if you're me
23:30:22 <dankna> but, as I say, not this particular case
23:30:50 <shachaf> dankna: Are you a sufficiently-advanced compiler?
23:31:19 <dankna> alas I am not!  but I'm very good at turning almost-working code into working code
23:31:31 <dankna> and at staring build systems in the eyes until they back down and do what they're told
23:32:00 <kmc> that's a nice skill
23:32:03 <dankna> it is
23:32:06 <dankna> wish someone would pay me for it
23:32:08 <dankna> but it's a nice skill
23:32:19 <kmc> i think it's a big part of getting paid as a software developer, actually
23:32:23 <dankna> I agree
23:32:33 <dankna> unfortunately the other big part is having a piece of paper with gold embossing
23:32:33 <kmc> it goes in the category of "stuff you need that they don't teach you in school"
23:32:41 <kmc> (actually most of software engineering is that)
23:32:47 * shachaf definitely deals with a build system that needs to be stared in the eyes for a while.
23:32:55 * dankna nods
23:33:13 <kmc> though this may just reflect the resistance of industry to absorb academic concepts, like languages that don't suck
23:33:21 <shachaf> Make is such a lovely language.
23:33:24 * kmc feels another rant coming on
23:33:45 <shachaf> The world probably has enough rants about Makefiles.
23:33:55 <kmc> what's a good make replacement
23:33:57 <dankna> well, in fairness, academia also doesn't absorb industry concepts, like making things that work for someone besides you
23:34:07 <cmccann> the main problem is that computer science degrees don't give people the knowledge they need to be software engineers, and that software engineers don't know as much computer science as they need to be effective
23:34:18 <shachaf> "what"? That's a hard name to search for...
23:34:19 <kmc> i hear SCons is nice and magical for small projects, but too slow on big ones
23:34:30 <kmc> shachaf, do they speak English in what?
23:34:37 <cmccann> you'd think these problems would solve each other but it somehow ends up that they make each other worse instead
23:34:44 <\yrlnry> have you looked at Avery Pennarun's implementation of "redo"?
23:34:47 <kmc> at an old job we used bjam, which was nice as long as somebody other than me wrote the Jamfiles
23:34:55 <coppro> haha
23:34:59 <dankna> cmccann: well, I don't think a four-year program can teach anyone enough computer science to be effective, even in principle
23:35:00 <\yrlnry> It looks like it might be a build system that doesn't suck.
23:35:11 <kmc> cmccann, yep, any idea why?
23:35:11 <coppro> kmc: Reports are SCons is sped up immensely by using hardlinks
23:35:11 <dankna> Cabal is a build system that doesn't suck
23:35:18 <kmc> coppro, where?
23:35:23 <dankna> it needs to grow big and strong and encompass all languages with its Cthulhu-like embrace
23:35:26 <cmccann> dankna, no, but few even do as well as failing after a valiant effort
23:35:32 <coppro> kmc: in its cache
23:35:34 <kmc> dankna, what flag do i pass to cabal to build in parallel?
23:35:36 <dankna> cmccann: true enough
23:36:14 <dankna> kmc: cabal supports building in parallel.  but it's not exposed in the user interface.  to turn it on you have to modify Cabal's source code so that it has that feature.
23:36:30 <kmc> ∴ Cabal sucks. □
23:36:33 <dankna> haha
23:36:47 <dankna> well, anyway, Cabal is my pick
23:36:49 <cmccann> kmc, no, I have no idea why the entire industry has the endemic problems it does. I can see why problems persist, but not where they come from
23:37:05 * kmc is so glad he has a keybinding for □
23:37:24 <luite> hmm, apparently I don't have a glyph for it
23:37:30 <luite> unless it's a square box
23:37:34 <dankna> it is a square box
23:37:37 <luite> oh
23:37:39 <cmccann> haha
23:37:42 <dankna> math-types put square boxes at the end of proofs
23:37:48 <kmc> haha
23:37:57 <luite> oh right
23:37:59 <dankna> hehe
23:38:14 <luite> but what's the one at the beginning?
23:38:17 <dankna> therefore
23:38:18 <kmc> Theorem: Not all characters are square boxes.  Proof: ↯. □
23:38:24 <dankna> lol
23:38:31 <dankna> I would have used the snowman
23:38:35 <cmccann> the square box is pronounced as "so there" I think
23:38:39 <dankna> ?
23:38:41 <kmc> cmccann++
23:38:43 <shachaf> Hmm, perhaps the square-box tradition was started with someone missing a Unicode glyph.
23:38:43 <kmc> dankna, but this way it's proof by contradiction!
23:38:47 <dankna> hahahahaah
23:38:48 <dankna> true
23:39:22 * cmccann needs more reasons to use ☡
23:39:24 <dankna> so yeah
23:39:26 <dankna> I wonder
23:39:29 <kmc> snakes?
23:39:39 <dankna> it is clear, I think, that type-nats cannot do what I wish it to in its present form
23:39:42 <cmccann> http://en.wikipedia.org/wiki/Bourbaki_dangerous_bend_symbol
23:39:45 <dankna> so the question is, how to modify it
23:40:09 <kmc> \begin{danger} ... \end{danger}
23:40:30 <dankna> I can see at least two approaches that would work
23:40:33 <kmc> delimits the danger zone
23:41:00 <shachaf> Except for Oleg, who confuses "danger" with "document".
23:41:13 <dankna> the MORE invasive one would be to add support for writing type instance MinusNat (ab + b) b = a directly
23:41:17 <dankna> shachaf: hah!  yes
23:41:20 <cmccann> I think at one point I suggested using ☡ instead of # to mark scary internal-use-only functions
23:41:25 <kmc> ♫ highway to the DANGER ZONE ♫
23:41:41 <dankna> the less invasive one would be to add a new kind Int, as a superkind of Nat, with - defined on it
23:41:44 <kmc> -XMagicHash -XBendOfDoom
23:41:50 <cmccann> kmc, yes
23:41:59 <dankna> that would not solve the problem for people who need /, though
23:42:03 <dankna> or log, for that matter
23:42:21 <kmc> dankna, seriously, where are my type-level floats? ;P
23:42:31 <Chat5864> هلا
23:42:34 <dankna> kmc: almost considered that once haha
23:42:43 <dankna> but you could implement them on top of type-level ints :)
23:42:43 <kmc> a new, exciting reason for compilation to fail on 32-bit x86
23:42:45 <Chat5864> الوو
23:43:05 <cmccann> I want type-level reals
23:43:08 <kmc> Google detects this language as Portuguese
23:43:11 <cmccann> real reals, not fake reals
23:43:13 <kmc> i feel that's a bit off base
23:43:19 <Chat5864> هردم
23:44:45 <dankna> hmm I think I'll post to this on the list
23:44:45 <kmc> "Expected type 1.0, inferred type 0.99999999963"
23:44:50 <dankna> lol
23:45:34 <cmccann> kmc, yeah, compiling on intel chips might be tricky
