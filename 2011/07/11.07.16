00:00:18 <MatrixFrog> can i just delete 1.2.0.3 entirely? if something really needs it i can always reinstall it right?
00:01:30 <NihilistDandy> What it appears to be is that random in your --global is built with time 1.2.0.3, but the random in your --user is compiled with 1.2.0.5
00:01:48 <MatrixFrog> hm. so can i just delete one or both of them somehow and then rebuild?
00:01:55 <NihilistDandy> That might work, yes
00:02:14 <NihilistDandy> Also try cabal install --global while 1.2.0.3 is exposed
00:03:14 <MatrixFrog> ooo looks like it's working so far
00:03:16 <NihilistDandy> Or --user, for that matter. Anything that forces a particular version of time
00:03:16 <MatrixFrog> fingers crossed
00:03:19 <NihilistDandy> hehe
00:03:27 <MatrixFrog> lots of compiler warnings but ok
00:04:20 <MatrixFrog> i get so twitchy if my code triggers compiler warnings but i guess some people aren't bothered by it as much
00:05:17 <NihilistDandy> I learned to ignore it, usually. Most of them are just deprecated pragmas and so on, so I only get bent out of shape if it's something I think I can fix immediatly
00:05:20 <NihilistDandy> *immediately
00:08:18 <MatrixFrog> ok so it failed because it thought random was installed but i had deleted it
00:08:28 <MatrixFrog> i suppose just deleting the folder is not the proper way of deleting it?
00:08:36 <MatrixFrog> but anyway i did a --reinstall --global on random
00:08:49 <MatrixFrog> and now euterpea is working away at compiling
00:09:12 <Jafet> ghc-pkg unregister to unregister a package
00:09:19 <MatrixFrog> just for the record, is there a haskell equivalent of @SuppressWarnings in java?
00:09:31 <MatrixFrog> ok yeah i should read a bit about what ghc-pkg can do, thanks
00:09:44 <Jafet> Suppress what warnings?
00:09:48 <MatrixFrog> anything
00:09:57 <Jafet> What
00:10:05 <MatrixFrog> so if you have an "unchecked conversion" warning, you go:
00:10:06 <MatrixFrog> @SuppressWarnings("unchecked")
00:10:06 <lambdabot> Unknown command, try @list
00:10:20 <MatrixFrog> i should say, any specific thing, not anything as in everything
00:10:27 <Jafet> Haskell doesn't have warnings
00:11:02 <MatrixFrog> when i install things with cabal, i see all kinds of warnings about things being deprecated or whatever
00:11:03 <Jafet> GHC has warnings, and the manual tells you a few ways to use them
00:11:25 <jaspervdj> MatrixFrog: you could e.g. put {-# OPTIONS_GHC -fno-warn-orphans #-} at the top of your file
00:11:30 <MatrixFrog> asking #haskell is infinitely more fun than reading any sort of manual
00:11:40 <MatrixFrog> :P
00:11:55 <Jafet> If you want those warnings to go away, bug the maintainer of the package you're installing to fix the code to not cause GHC to emit those warnings.
00:12:04 <MatrixFrog> but yes, that's the kind of thing i meant jasper: thanks
00:12:16 <MatrixFrog> Jafet yes of course that would be the ideal
00:12:47 <MatrixFrog> or i could try and fix them myself. that might be a fun way to expand my haskell knowledge :)
00:12:51 <MatrixFrog> submit patches
00:12:57 <NihilistDandy> Or just patch it yourself, of course. Most of the warnings are pretty informative
00:13:02 <MatrixFrog> indeed
00:13:03 <NihilistDandy> Beat me to it
00:13:05 <Jafet> Turning off warnings just because you don't want to see them? That's like the story of the thief who wore earplugs so that he wouldn't hear the building alarm go of
00:13:14 <Jafet> f
00:13:29 <NihilistDandy> Best simile I've heard all dat
00:13:31 <NihilistDandy> *day
00:13:37 <MatrixFrog> oh i agree. my favorite is when eclipse gives you a warning because you used @SuppressWarnings unnecessarily
00:13:38 <Jafet> In other words, it's a little counterproductive
00:13:49 <MatrixFrog> but first i want to get euterpea running. it's at step 25 of 25!
00:13:59 <Jafet> Warnings don't prevent code from compiling
00:14:05 <Jafet> Or running, naturally
00:14:57 <MatrixFrog> though actually now that i think about it, i think the readme said something about it hanging on the last step
00:15:40 <MatrixFrog> aha! indeed so
00:15:42 <NihilistDandy> Surprise, it failed building because I didn't have GLFW installed :D
00:19:01 <jaspervdj> Jafet: it has some good uses though. E.g., I disable orphan instances warnings in my testing code, so I can declare Arbitrary instances there
00:19:50 <Jafet> But it's pretty silly to disable warnings in someone else's code.
00:20:31 <MatrixFrog> no no i wouldn't in someone else's code
00:20:38 <NihilistDandy> I wish more people took warnings as a challenge :D
00:20:57 <MatrixFrog> and i would certainly try to avoid it in my own code too, whenever possible
00:21:12 <MatrixFrog> the code i work with at work (java) has literally thousands of warnings
00:21:16 <NihilistDandy> I've been digging through GHC head rooting out some deprecated material
00:21:26 <MatrixFrog> mainly from 1.4-era code without generics. but anyway
00:21:39 <MatrixFrog> euterpea finished installing! now to see if it works
00:25:46 <NihilistDandy> Also, if you don't follow the mailing lists (and thus haven't heard about it), try out docidx. :D
00:26:22 <MatrixFrog> oh cute
00:27:04 <NihilistDandy> Oh, dear. Looks like no Euterpea for me. My Xcode may be too new for GLFW
00:27:48 <NihilistDandy> A lot of deprecated syntax in the FFI for OS X. Might have to dig around for solutions.
00:28:25 <MatrixFrog> hm, so i'm trying what it says: cd Euterpea/example; ghci
00:28:31 <MatrixFrog> then :load EuterpeaExamples.lhs
00:28:47 <MatrixFrog> "could not find module Euterpea"
00:28:59 <MatrixFrog> so then i invoked ghci with -i../src
00:29:19 <MatrixFrog> and then it says "could not find module IO"
00:29:52 <MatrixFrog> am i crazy, isn't IO one of the built in modules? or is it System.IO?
00:31:46 <NihilistDandy> What about ghci EuterpeaExamples.lhs?
00:33:04 <MatrixFrog> "could not find module Euterpea"
00:33:19 <MatrixFrog> so then: ghci -i../src EuterpeaExamples.lhs ?
00:33:33 <MatrixFrog> and then it can't find IO
00:34:16 <MatrixFrog> i also tried this from the main Euterpea dir:
00:34:17 <MatrixFrog> runhaskell -isrc example/EuterpeaExamples.lhs
00:34:28 <MatrixFrog> and then i got "could not find module Ssf"
00:34:58 <MatrixFrog> it just says "import Ssf" and i have no idea what that is :/
00:35:29 <NihilistDandy> Ssf is in Examples
00:35:58 <MatrixFrog> oh i see
00:36:52 <MatrixFrog> hm, runhaskell -v shows more "missing or recursive dependencies"
00:36:55 <MatrixFrog> so that's fun
00:37:25 <NihilistDandy> lol
00:43:46 <MatrixFrog> is there a good way to unregister pretty much everything all at the same time and then let cabal reinstall them?
00:43:50 <MatrixFrog> or something
00:45:35 <MatrixFrog> oh i see, ghc-pkg list tells you which ones are broken
01:43:24 <MatrixFrog> anyone still up?
01:43:49 <NihilistDandy> Yus
01:43:50 <MatrixFrog> the glfw library wants a particular dll that i apparently need to find somewhere
01:44:07 <MatrixFrog> Loading package GLFW-0.4.2 ... <interactive>: HSGLFW-0.4.2: The specified module could not be found.
01:44:28 <NihilistDandy> Oh, dlls... blah. Google's the only way I've found DLLs that I didn't get through installs
01:45:01 <MatrixFrog> yeah
01:45:48 <MatrixFrog> i'm not finding it though in this case
01:45:52 <NihilistDandy> hmm
01:48:06 <NihilistDandy> Also, damn, Hudak. Comic Sans?
01:48:52 <MatrixFrog> http://www.reddit.com/r/haskell/comments/in1my/the_haskell_school_of_music_new_book_being/c2543o9
01:49:34 <mauke> MatrixFrog: why do you think it's missing a dll?
01:50:11 <MatrixFrog> when i get to "play childSong6" i get this error:
01:50:12 <MatrixFrog> Loading package GLFW-0.4.2 ... <interactive>: HSGLFW-0.4.2: The specified module could not be found.
01:50:25 <mauke> MatrixFrog: why do you think it's missing a dll?
01:50:29 <MatrixFrog> can't load .so/.DLL for: HSGLFW-0.4.2 (addDLL: could not load DLL)
01:50:38 <mauke> ok, that makes more sense
01:50:41 <MatrixFrog> (sorry, missed the second line of it the first time i posted it)
01:54:33 <MatrixFrog> i looked at C:\Program Files\Haskell Platform\2011.2.0.0\lib\package.conf.d\GLFW-0.4.2-113d69952738814088a963c58caec94a.conf
01:54:49 <MatrixFrog> and it has a line that says: hs-libraries: HSGLFW-0.4.2
01:58:18 <MatrixFrog> hm weird
01:58:26 <MatrixFrog> i just unregistered it and now it works
01:59:00 <MatrixFrog> well, the song plays. idk if a window is supposed to come up or whatever
01:59:07 <MatrixFrog> but the music is the important part anyway
01:59:25 <MatrixFrog> thanks for all the help, as always :)
02:14:21 * hackagebot cryptocipher 0.2.13 - Symmetrical Block, Stream and PubKey Ciphers  http://hackage.haskell.org/package/cryptocipher-0.2.13 (VincentHanquez)
02:16:21 <huangyi> how to exit current thread, killThread need to pass a threadid
02:17:34 <huangyi> do i have to do myThreadId >>= killThread, is there a shortcut for that
02:17:38 <mauke> @src killThread
02:17:38 <lambdabot> killThread tid = throwTo tid (AsyncException ThreadKilled)
02:17:51 <mauke> :t throwTo
02:17:52 <lambdabot> Not in scope: `throwTo'
02:18:49 <mauke> throwIO ThreadKilled?
02:19:22 * hackagebot IPv6Addr 0.1 - Library to deal with the IPv6 address's text representation.  http://hackage.haskell.org/package/IPv6Addr-0.1 (MichelBoucey)
02:28:25 <huangyi> it works too
02:42:03 <huangyi> @src epochTime
02:42:04 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
02:52:12 <huangyi> @hoogle Integer->Int
02:52:13 <lambdabot> Data.Time.Calendar gregorianMonthLength :: Integer -> Int -> Int
02:52:13 <lambdabot> Data.Time.Calendar.Julian julianMonthLength :: Integer -> Int -> Int
02:52:13 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
02:54:32 <igrekster> Hello, could anyone who uses VIM to code in Haskell share his .vimrc ? (I've tried EclipseFP and Leksah, but VIM looks like the way to go)
02:55:26 <huangyi> http://projects.haskell.org/haskellmode-vim/
02:55:38 <huangyi> i use this
02:56:14 <adrake> emacs is another option, if you have not looked into it yet (this is not intended to start a flame war -- please don't shoot me!)
02:56:35 <igrekster> huangyi: yep, but is there a way to generate tags or something to do navigation?
02:57:45 <huangyi> the script i just metioned has commands to generate ctags
02:57:54 <igrekster> adrake: I'm a long-time emacs user :-), but I code in C++ on large projects, so navigation is the main feature I need, hence I stick to Eclipse + CDT + Vrapper
02:58:01 <huangyi> which use ghci's :ctags command
02:58:14 <igrekster> huangyi: only for a single file
02:59:09 <igrekster> huangyi: so if I have several modules and want to "jump" to definitions it won't work
03:01:17 <igrekster> huangyi: I was wondering if someone has "integrated" haskellmode into project.vim or something like that.
03:01:17 <huangyi> it will generate tags for all the module imported by current file
03:02:52 <igrekster> huangyi: you are right, so I should use on a "Main" module then.
03:03:53 <huangyi> i guess so,
03:05:17 <huangyi> @hoogle  Integer -> Int
03:05:18 <lambdabot> Data.Time.Calendar gregorianMonthLength :: Integer -> Int -> Int
03:05:18 <lambdabot> Data.Time.Calendar.Julian julianMonthLength :: Integer -> Int -> Int
03:05:18 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
03:06:36 <huangyi> @hoogle Int -> Integer
03:06:37 <lambdabot> Prelude toEnum :: Enum a => Int -> a
03:06:37 <lambdabot> Data.Bits bit :: Bits a => Int -> a
03:06:37 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
03:10:22 <huangyi> igrekster: i've tried hasktags and gasbag before, but they can't parse ghc extension syntax, which make them  not so useful.
03:13:32 <igrekster> huangyi: recursive tag generation from a main module makes sense, the next best thing to do would be to regenerate it if you save a module. could be done, I think
03:19:29 <huangyi> igrekster: that should be easy using vim's autocmd
03:21:43 <huangyi> igrekster: just press three key to regenerate tags is good enough for me ;)
03:21:44 <igrekster> huangyi: well, you have to "define/store" main module path somehow
03:23:22 <igrekster> huangyi: I guess I've got too used to Eclipse comforts :-)
03:23:32 <huangyi> igrekster: best thing is generate tags for all modules specified in cabal file.
03:25:12 <igrekster> huangyi: I'm new to Haskell, so cabal is out of scope ATM.
03:39:50 <huangyi> https://github.com/yihuang/haskell-json-rpc I've created a json rpc library, it's one of my first pieces of haskell code, so i  look forward to some reviews.
03:48:23 <hpaste> huangyi pasted “use do syntax for non monadic code” at http://hpaste.org/49108
03:50:19 <huangyi> i used to believe that do block can only used to create monadic code, i just found out it can also used to layout non-monadic code.
03:50:51 <shachaf> "do" is for monads, but "monadic code" might not mean what you think.
03:51:09 <shachaf> Oh, I see what you mean.
03:51:15 <sanjoyd> huangyi: how is this better than let a = 1 in a + x ?
03:51:21 <shachaf> That didn't use to work, but I guess it does now. What's the point?
03:51:45 <shachaf> Just use let ... in ...
03:52:29 <huangyi> it's feels more like impretive language, e.g. python
03:52:43 <sanjoyd> huangyi: basically, do { let x; y } desugars to let x in do { y } and do { y; } desugars to y
03:52:57 <sanjoyd> So the expression will desugar let a = 1 in a + x.
03:53:11 <huangyi> i find the "in" keyword is unnecessary
03:53:26 <sanjoyd> length "do" == length "in". :D
03:53:31 <sipa> :t (do { let a = 1; a+a })
03:53:32 <lambdabot> parse error on input `}'
03:53:43 <Jetbeard> huangyi: if you're trying to make Haskell feel like an imperative language then you aren't seeing the virtue of Haskell :)
03:53:54 <sanjoyd> :t (do {let a = 1; a + a; } )
03:53:55 <lambdabot> parse error on input `;'
03:54:10 <sanjoyd> :t (do { let a = 1; a + a } )
03:54:10 <lambdabot> parse error on input `}'
03:54:10 <sanjoyd> Weird.
03:54:23 <shachaf> @ty do { let { a = 1}; a + a }
03:54:24 <lambdabot> forall a. (Num a) => a
03:55:47 <sipa> @ty do { let { a = 1}; b <- a + a; b }
03:55:48 <lambdabot> forall (m :: * -> *) b. (Num (m (m b)), Monad m) => m b
03:55:56 <NihilistDandy> What an ugly way to double a number :/
03:56:24 <sipa> what an ugly way to write '2'
03:56:42 <mauke> what a type error
03:56:43 <NihilistDandy> Even worse D:
03:56:50 <Watermind> do { let { a = 1}; let {b = a + a}; return b }
03:56:57 <Watermind> :t do { let { a = 1}; let {b = a + a}; return b }
03:56:58 <lambdabot> forall a (m :: * -> *). (Num a, Monad m) => m a
03:56:59 <shachaf> mauke: Nothing's a type error, given a sufficiently advanced instance of Num!
03:57:18 <Watermind> :t do { let { a = 1}; return (a + a) }
03:57:19 <lambdabot> forall a (m :: * -> *). (Num a, Monad m) => m a
03:57:36 <Watermind> that's what you want
03:57:42 <mauke> > do let { a = 1; b = a + a }; b
03:57:43 <lambdabot>   2
03:58:05 <sipa> Watermind: i was just checking whether the <- was still exclusive to monad usage in do constructs
03:58:13 <Watermind> sipa: ah :)
03:58:52 <sanjoyd> sipa: do { a <- b; c } ==> b >>= (\a -> do { c }); I don't think the desugaring does anything more than that.
04:02:01 <shachaf> > do do do dee... do dah
04:02:03 <lambdabot>   dum
04:02:30 <mauke> :t (...)
04:02:31 <lambdabot> forall t t1. t -> t1 -> t1
04:03:18 <sipa> :t dee
04:03:20 <lambdabot> forall a. a -> a
04:03:55 <sanjoyd> :t dah
04:03:55 <lambdabot> Not in scope: `dah'
04:04:11 <huangyi> "let x in y" is equivalent to "y where x" right? what's the point to use two style. I found haskell code is hard to read, because there so many ways to do a same thing.
04:04:25 <sanjoyd> huangyi: no.
04:04:49 <sanjoyd> AFAIK, where can only be used in function declarations, at the topmost level.
04:05:05 * sanjoyd checks.
04:05:12 <mauke> let is an expression, where is a declaration
04:05:24 <sanjoyd> > a where a = 5
04:05:25 <lambdabot>   <no location info>: parse error on input `where'
04:05:30 <sanjoyd> > let a = 5 in a
04:05:30 <lambdabot>   5
04:05:32 <sanjoyd> etc.
04:05:38 <huangyi> i find myself miss python's clean code ;)
04:05:38 <mauke> > let a = b where b = 1 in a
04:05:39 <lambdabot>   1
04:06:03 <Jetbeard> huangyi: i challenge the notion that Haskell's code isn't clean
04:06:04 <sanjoyd> Then go write Python. :)
04:06:12 <Jetbeard> of course, it's not if you try to write Haskell in an imperative style.
04:06:34 <NihilistDandy> Or in a ridiculous style
04:06:36 <sanjoyd> huangyi: basically, where is more like syntactic sugar, let is a fundamental construct.
04:07:08 <mauke> sanjoyd: disagree
04:07:21 * sanjoyd checks.
04:08:07 <sipa> 13:12:58 < sanjoyd> AFAIK, where can only be used in function declarations, at the topmost level.    <- you seem to think that 'function' is something defined with a name?
04:08:28 <sipa> :t read
04:08:29 <lambdabot> forall a. (Read a) => String -> a
04:08:30 <shachaf> sipa: Didn't you hear? Everything's a function in Haskell. :-)
04:08:42 <sipa> shachaf: haha
04:08:52 <Jetbeard> > (\a -> a + b where b = 1) 1
04:08:53 <lambdabot>   <no location info>: parse error on input `where'
04:09:02 <ketil> Is it possible for a package to reexport a module from a different package under the same name?
04:09:14 <huangyi> thanks, i guess i just need to be more familiar with fp style ;)
04:09:26 <sanjoyd> sipa: what I mean was that like 'do', f X = Y where Z is replaced with f X = let Z in Y. Probably I'm wrong.
04:09:41 <sanjoyd> I'm looking at the specs, let see if I find anything.
04:09:41 <Jetbeard> huangyi: basically every snippet of code that's been said in here is horrible
04:10:07 <shachaf> > nubBy(((>1).).gcd)[2..]
04:10:09 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
04:10:21 <sipa> sanjoyd: i think that's correct, but it's not limited to function definitions
04:10:38 <sanjoyd> Yeah; module declarations come to mind.
04:10:43 <shachaf> It's also not only true at the topmost level. It's true at any name binding (with an = sign, that is).
04:12:17 <sipa> sanjoyd: module declarations?
04:12:22 <Jetbeard> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in take 10 fibs
04:12:23 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
04:12:31 <clsmith> i find it's quite easy to write ugly code in haskell. expressing an elegant definition is really an art
04:12:44 <Jetbeard> (is there a more concise way to get the fibonacci sequence as a list?)
04:12:49 <sanjoyd> sipa: module foo(x, y) where ...
04:13:39 <sipa> sanjoyd: oh, yes, that's true, but it's something entirely different
04:14:40 <shachaf> Jetbeard: Of course there is. Don't get #haskell started.
04:14:58 <Jetbeard> shachaf: a more concise *elegant* way?
04:15:10 <shachaf> Too subjective.
04:15:29 <sipa> sanjoyd: i just mean, i can use a where construct in a top-level definition of eg. type IO Int as well, which is not a function
04:15:30 <Jetbeard> although yes, i have seen what happens when #haskell is asked "is there any other way of writing x"
04:15:35 <shachaf> > fix((1:).scanl(+)1)
04:15:37 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
04:16:39 <shachaf> > fibify 1 1
04:16:41 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
04:17:17 <huangyi> :t fibify
04:17:19 <lambdabot> forall a. (Num a) => a -> a -> [a]
04:17:51 <NihilistDandy> > let f = 0 : 1 : zipWith (+) f (tail f); f
04:17:51 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
04:17:58 <NihilistDandy> > let f = 0 : 1 : zipWith (+) f (tail f)
04:17:59 <lambdabot>   not an expression: `let f = 0 : 1 : zipWith (+) f (tail f)'
04:18:05 <NihilistDandy> @let f = 0 : 1 : zipWith (+) f (tail f)
04:18:05 <lambdabot>  <local>:2:24:
04:18:06 <lambdabot>      Ambiguous occurrence `f'
04:18:06 <lambdabot>      It could refer to either `L...
04:18:13 <NihilistDandy> d'aww
04:18:20 <Jetbeard> <Jetbeard> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in take 10 fibs
04:18:33 <NihilistDandy> Oh, lol
04:18:38 <NihilistDandy> Wasn't paying attention
04:19:00 <simonwu> could someone help with a simple Yesod question?
04:19:45 <shachaf> simonwu: Not if you don't ask it.
04:19:50 <shachaf> (Also, there's #yesod.)
04:19:52 <simonwu> while define a Route, could be /person/#Text PersonR GET in hs file
04:20:18 <simonwu> how i achieve same thing at a plain route file
04:20:46 <simonwu> as yesod auto generate a plain text file route for Routing defination
04:21:33 <simonwu> Im using Yesod 0.8.2.1
04:23:03 <simonwu> any hints? or did I explain my question clearly.
04:23:07 <simonwu> thanks a lot.
04:31:00 <ski> shachaf : you can also attach `where'-clauses to branches of `case' ..
04:36:56 <idivyanshu> :t head
04:36:57 <lambdabot> forall a. [a] -> a
04:37:07 <hpaste> huangyi annotated “use do syntax for non monadic code” with “use do syntax for non monadic code (annotation)” at http://hpaste.org/49108#a49109
05:12:55 <hpaste> huangyi pasted “why threadDeplay don't take effect, the "hello" is printed immediately” at http://hpaste.org/49110
05:13:30 <mauke> what did you expect?
05:13:47 <huangyi> sleep for 5 seconds, then print "hello"
05:13:58 <mauke> you get 5 milliseconds
05:14:33 <cheater_> lol
05:15:06 <huangyi> thanks, i get it.
05:15:16 <cheater_> ;)
05:18:47 <huangyi> so, it this the right way to wait for a thread exit.
05:19:59 <JuanDaugherty> in a word, No.
05:20:39 <huangyi> i can't find anything like joinThread
05:21:07 <Jafet> I suppose you're supposed to use an MVar
05:21:08 <Axman6> what is jointhread supposed to do?>
05:21:22 <mauke> huangyi: yes
05:21:34 <merijn> Axman6: Block until the other thread exits
05:22:24 <merijn> i.e. "joinThread x" would make the executing thread block until x had exited. The easiest way in Haskell would be blocking on reading an MVar or Chan I guess
05:23:59 <merijn> huangyi: This should explain how to do what you want: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Concurrent.html#g:11
05:25:15 <huangyi> merijn: thanks, i get it. i just posted a snippet(http://hpaste.org/49110) using MVar to do this, just need to comfirm this is the right way to do ;-)
05:25:50 <merijn> huangyi: That should work, yes
05:31:28 <roastbird> help help. where can i find help on haskell programming.
05:31:39 <monadic> roastbird: Err, here?
05:32:10 <roastbird> thanks. i hope i'll find it. =)
05:34:34 <merijn> roastbird: I recommend Learn You a Haskell as introduction
05:34:36 <merijn> @where lyah
05:34:37 <lambdabot> http://www.learnyouahaskell.com/
05:35:29 <monadic> And RWH's later chapters after that
05:35:46 <roastbird> the one with the elephant cover?
05:35:55 <monadic> LYaH doesn't cover everything RWH does, but its generally better for the basics from what I've heard
05:36:02 <monadic> roastbird: Yeah
05:36:40 <merijn> monadic: RWH is more of a collection of tutorials for various Haskell libraries in my opinion, LYAH is more of a basics of haskell semantics
05:36:52 <roastbird> Umm... I want to define some functions with variable arity...
05:37:13 <roastbird> I checked the elephant book's content page, and it doesn't seem to have that!
05:37:36 <Axman6> you mean lyah?
05:37:53 <NihilistDandy> Sure it does. I think it discusses it in Chapter 10
05:38:17 <mauke> roastbird: it's nontrivial and involves typeclass hackery
05:39:12 <NihilistDandy> Oh, variable arity. I missed the first half
05:39:25 <roastbird> =x
05:39:51 <NihilistDandy> Unless you mean variable in some other way
05:40:16 <huangyi> i just used this trick in my json rpc library , https://github.com/yihuang/haskell-json-rpc/blob/master/Network/JsonRpc/Internals.hs
05:41:22 <merijn> roastbird: What do you want to do with said variable arity function?
05:43:31 <roastbird> uhh..
05:43:57 <roastbird> i'd like to define a function that takes a first arg of ( Fn ( a -> b -> c -> ... ) )
05:44:31 <roastbird> and a number of additional args of types a -> b -> c -> ...
05:44:37 <roastbird> and returns a string
05:44:43 <mauke> why?
05:44:47 <merijn> roastbird: Sorta like printf?
05:45:02 <merijn> Because that already exists and you could just look at the code :p
05:45:05 <monadic> roastbird: Typeclass recursion
05:45:12 <roastbird> it's like printf, but ( Fn r ) is an instance
05:45:19 <roastbird> of printable or something
05:45:47 <merijn> roastbird: Take a look at the printf code (http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Text-Printf.html#printf) and see if that gives you ideas?
05:45:47 <huangyi> you want something like apply ? takes a function and some arguments, apply the function to the arguments?
05:45:48 <roastbird> mmm. i actually copied from the printf code, and it's okay when i just use type variables
05:46:18 <roastbird> but when i add constraint, and rank2types, (i'm not sure if rank2types is the problem), it just doesn't compile
05:47:04 <roastbird> yes, something like apply =) the first argument is the representation of a function-value in another language.
05:47:28 <roastbird> so after it applies all the appropriate args, it will print out a string like f(x,y,z,...)
05:47:44 <roastbird> (where x y and z are the representation of other values in the other language)
05:48:04 * hackagebot hbro 0.6.5 - A suckless minimal KISSy browser  http://hackage.haskell.org/package/hbro-0.6.5 (koral)
05:48:12 <huangyi> <roastbird>: I just write something like this, you can look at my code : https://github.com/yihuang/haskell-json-rpc/blob/master/Network/JsonRpc/Internals.hs#L23
05:48:22 <merijn> roastbird: Are you trying to encode the type system of another language in haskell's datatypes? :)
05:49:51 <roastbird> @huangyi: thanks! i've been reading it for the paste few minutes. hmm... i think it'll take a bit more than a few minutes though
05:49:52 <lambdabot> Unknown command, try @list
05:50:18 <roastbird> merijn: yup. i'm doing just that! is that a bad idea?
05:51:35 <roastbird> the other language is dynamically typed. i thought it'll be nice if there were some static type checks.
06:02:17 <ketil> Okay, a reformulation: did module grafting ever pan out?
06:02:46 <ketil> I.e. can I import some modules from a package under a different name to avoid name clashes with the current module?
06:05:02 <dmwit> ketil: Do you just mean "import as"?
06:05:17 <dmwit> import qualified Data.Map as Foo
06:05:28 <dmwit> Foo.empty :: Data.Map.Map k a
06:05:34 <hpc> there's also package imports
06:05:53 <hpc> iirc, they go like "import Foo from foopackage"
06:06:09 <dmwit> import package.Foo, actually
06:06:16 <hpc> ah
06:06:33 <dmwit> import package-major.minor.whatever.whateverelse.Foo
06:06:35 <ketil> dmwit, well.. I'm refactoring, so I want my new package foo to provide module Foo.Bar, previously available in package bar.  To avoid code duplication, I'd like package bar to import Foo.Bar from foo, and just reexport it with the same name.  Is that possible?
06:07:38 <ketil> module Foo.Bar (module Zot) where import foo.Foo.Bar as Zot?
06:07:45 <ketil> would it work?
06:08:03 <dmwit> module foo.Foo.Bar where import foo.Foo.Bar
06:08:15 <dmwit> And that means all your users are going to have to use package imports, too.
06:08:27 <dmwit> Why aren't they just importing Foo.Bar from foo, again?
06:08:38 <dmwit> (Why are you trying to provide a clashing name?)
06:09:16 <dmwit> Sorry, the whole file would be "module Foo.Bar (module foo.Foo.Bar) where import foo.Foo.Bar".
06:09:46 <olsner> hrrg, what was the way to fix this again? when I have the .o file in my directory, ghci will load the object file (and hide everything except main) instead of compiling the sources to bytecode
06:10:16 <mauke> :l *foo.hs
06:10:55 <olsner> actually, doing ghci '*'foo.hs on the command line worked too
06:11:48 <roastbird> anyone knows if there's an easier way to do variable arity functions (besides what printf does)? using recursion on the functions of a class... it seems impossible to add in many type constraints with rank2 and still get decidable instances and compile properly... i don't know whether it's possible, but trying to figure it out is o.O
06:12:34 <hpc> possibly with type families?
06:12:56 <roastbird> eh? how? any references for that?
06:13:39 <hpc> no, that was just an educated guess of where to look to find your answer
06:13:54 <hpc> type families are a lot like type classes, so it could work
06:13:56 <hpaste> huangyi pasted “Demo for variable arguments trick” at http://hpaste.org/49111
06:14:00 <ketil> dmwit, I'd like everything to keep working, so backwards compatibility.  import foo.Bar doesn't work.
06:14:26 <dmwit> ketil: You need the version number.
06:14:38 <huangyi> roastbird: it that what you need?
06:15:13 <roastbird> thanks huangyi and hpaste. i looked through your code. it seems like the right approach, but when i tried it, with constraints, it became somewhat hard to solve.
06:15:30 <roastbird> without the constraints, it works fine =)
06:15:39 <dmwit> roastbird: I think these days if somebody was going to write printf, they'd do it with a GADT.
06:15:59 <dmwit> Or rather, if they were going to write a printf-alike that didn't do parsing.
06:16:09 <ketil> dmwit, hm, I still get parse errors.
06:16:16 <dmwit> ketil: ?hpaste
06:16:26 <ketil> I think it really wants an upper case letter for modules...
06:16:51 <dmwit> ketil: Have you enabled the package imports extension?
06:17:01 <ketil> No?
06:17:04 <ketil> :-)
06:17:06 <dmwit> Why not?
06:17:16 * ketil didn't know about it - sorry.
06:17:32 <dmwit> Oh, okay. Then it is I who should be apologizing for not making it clear that it was an extension. =P
06:18:06 <ketil> how do I do it?  The term isn't exactly google-friendly...
06:18:51 <ketil> Ah, language PackageImports.  Easy enough.
06:19:02 <ketil> ghc --supported-languages is your friend.
06:19:12 <dmwit> http://haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#package-imports
06:19:22 <dmwit> Seems I had the syntax wrong, too.
06:21:04 <ketil> Ah, yes found it.
06:21:37 <ketil> Cool, it seems to work, too.
06:21:43 <ketil> Awsum.
06:21:55 * ketil will now return to attending the lecture...
06:25:54 <erus`> check out http://robohash.org/
06:33:07 <huangyi> erus`: what should i use these robots for?
06:33:32 <erus`> like id pictures for a website or something
06:33:38 <rvn_> what's the default buffering mode for a Network.Socket Socket?
06:33:58 <erus`> the idea is that humans can recognise them easier than a hash/string
06:34:16 <huangyi> rvn_: i guess LineBuffering
06:34:44 <rvn_> huangyi, would there be a way to set it to NoBuffering without converting it into a Handle?
06:35:57 <huangyi> rvn_: accept and connectTo both return Handles
06:36:19 <SChalisque> Hi All, just reading learnyouahaskell.com, any thoughts on this book?
06:36:50 <rvn_> Yeah but huangyi I need to use Network.Socket
06:36:59 <dixie> What is the possible way of package removal from hackage I found not worth to be shared?
06:37:35 <Jafet> dixie: email a hackage administrator, perhaps
06:37:44 <huangyi> :hoogle Socket -> BufferMode -> IO ()
06:37:45 <dixie> ok. thanks!
06:38:00 <Jafet> I'm not sure if the cabal-install infrastructure even deals with that
06:38:02 <merijn> SChalisque: It rocks :)
06:38:18 <huangyi> @hoogle Socket -> BufferMode -> IO ()
06:38:19 <lambdabot> Data.HashTable insert :: HashTable key val -> key -> val -> IO ()
06:38:19 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
06:38:19 <lambdabot> Foreign.Storable pokeByteOff :: Storable a => Ptr b -> Int -> a -> IO ()
06:40:00 <rvn_> huangyi, perhaps there isn't a way..
06:41:28 <rvn_> @hoogle Handle -> Socket
06:41:29 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
06:41:29 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
06:41:29 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
06:42:40 <huangyi> rvn_: I guess Socket is a direct interface to posix api, which is unbuffered, only Handle has buffering.
06:43:02 <rvn_> huangyi, possible
06:43:20 <ski> @hoogle fd
06:43:21 <lambdabot> System.Posix.Types newtype Fd
06:43:21 <lambdabot> System.Posix.Types Fd :: CInt -> Fd
06:43:21 <lambdabot> Network.Socket fdSocket :: Socket -> CInt
06:44:09 <rvn_> @hoogle Fd -> Handle
06:44:10 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
06:44:10 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
06:44:10 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
07:10:47 <Feuerbach> Why are simple unbalanced trees so rarely used as data structures? Or I'm just unaware? They seem good if you do many appends and little access.
07:11:58 * zygoloid observes that DList is a simple unbalanced binary tree
07:12:24 <monadic> Feuerbach: How do you reasonably access an unbalanced tree?
07:12:44 <monadic> Feuerbach: You can easily end up with having what is essentially a list
07:13:25 <Feuerbach> monadic: but lists can't be appended in O(1)
07:13:33 <Feuerbach> zygoloid: indeed, but..
07:14:16 <Jafet> (++) is O(1), if used for DLists
07:14:40 <Feuerbach> Jafet: no one argues
07:15:15 <Feuerbach> I wonder, if there's any benefit of the "functional" representation, like in DLists?
07:15:26 <Feuerbach> compared to simple trees
07:15:52 <Jafet> Uh, what's the "functional" representation?
07:15:58 <Feuerbach> [a] -> [a]
07:16:10 <Eliel_> Feuerbach: normal lists you can add an element in O(1) if you're not picky that you start reading from the "end"
07:16:17 <Feuerbach> Jafet: or we're talking about different DLists?
07:16:41 <Jafet> DList is just a name people give to the correct usage of repeated (++)
07:16:49 <Jafet> I wouldn't call it a data structure
07:17:25 <Feuerbach> Jafet: what if you can't control the order of (++)?
07:17:42 <Jafet> Then shit can happen
07:17:47 <zygoloid> Jafet: DList is the name of a newtype provided by the dlist hackage package
07:17:55 <Feuerbach> Jafet: but not with trees
07:18:12 <Jafet> zygoloid: implementing difference lists, right?
07:18:23 <Jafet> Bah, hpaste needs a text search
07:18:24 <Tomsik> Is (++) really O(n) in Haskell? With lazy evaluation and all?
07:18:32 <Tomsik> Won't it amortize?
07:18:43 <zygoloid> Jafet: yeah. just sayin', when i say DList i mean DList not difference lists in general :)
07:18:44 <Jafet> Tomsik: that depends on what n is, and how far you evaluate it
07:19:25 <Feuerbach> Tomsik: kind of. If you have have a sequence of n left-associated (++), then getting each elements costs k evaluations
07:19:32 <Feuerbach> s/k/n/
07:20:03 <Tomsik> So it can have different time results even though in reality (++) is associative?
07:20:13 <Feuerbach> that's right
07:20:18 <Jafet> http://hpaste.org/47434/difference_lists
07:20:34 <Jafet> I still don't really get what Feuerbach's question about tree is
07:20:42 <Jafet> s/tree/trees/
07:21:39 <Feuerbach> Jafet: that's a good visualization
07:21:43 <Jafet> Tomsik: you could say the inherent cause is that the list data structure is asymmetrical
07:21:58 <Jafet> With Sequence, which uses a finger tree, the direction is irrelevant
07:22:42 <Feuerbach> Jafet: As I said, there are cases where you can't control the order
07:22:58 <Feuerbach> In those cases, you can use difference lists (ie. [a]->[a] representation of a list)
07:23:04 <Feuerbach> or unbalanced trees
07:23:19 <Feuerbach> but I don't see any benefit of difference lists, although they seem more popular
07:23:49 <Jafet> I can't see a comparison of trees to difference lists
07:24:07 <Jafet> Unless you're comparing a series of tree updates to a series of difference lists
07:25:02 <Jafet> Actually there's a misnomer there, since difference lists aren't lists, but differences
07:25:28 <Feuerbach> well, (.) corresponds to Branch, (xs ++) corresponds to Leaf
07:25:51 <Jafet> Oh, I kind of see where you're going
07:26:15 <Jafet> It doesn't really matter what order you apply difference lists, I think, up to a Constant Factor
07:26:31 <Jafet> Since it naturally follows the list structure
07:27:50 <Jafet> So they are performance-associative under (.)
07:28:32 <Jafet> ...is that what you wanted to discuss?
07:29:06 <Feuerbach> My question is about the concrete representation. For some reason people prefer functions [a] -> [a] over an algebraic data type Tree a = Branch (Tree a) (Tree a) | Leaf a.
07:29:53 <Jafet> What is the corresponding Tree Char for, say, ("abc"++)?
07:29:57 <Feuerbach> I can see benefits of the latter approach (you can store some additional info in the nodes, such as the number of elements), but I see no benefits in the functional representation
07:30:28 <Feuerbach> ("abc"++) would correspond to Tree [Char]
07:30:34 <Feuerbach> namely, Leaf "abc"
07:30:38 <Jafet> You're comparing them, but they don't seem to have the same kinds of values
07:31:31 <Feuerbach> well, you also could use Tree Char. Depends on the problem, I suppose
07:31:40 <Jafet> Okay, then what function corresponds to Branch (Leaf "abc") (Leaf "def")?
07:31:43 <Feuerbach> the idea is, instead of (++) or (.) you use Branch
07:31:46 * ski . o O ( `treeToDiffList = foldTree (.) (++)' )
07:32:41 * Jafet . o O ( enjoy your stacked thunks of (.)? )
07:32:44 <Feuerbach> Jafet: ("abc" ++) . ("def" ++)
07:33:11 <Feuerbach> Jafet: yes, that's what's happening typically when you use DLists
07:33:41 <Jafet> Feuerbach: okay, but they're not commensurable because eg. there's no Tree for reverse
07:34:25 <Jafet> If you want to outlaw anything except a way to prepend lots of stuff to lists, then you might use Tree
07:35:06 <Jafet> That sounds inflexible to me though
07:35:10 <Feuerbach> Jafet: good point. So, DLists are somewhat more general.
07:35:33 <Feuerbach> again, it depends on your problem. One that I'm solving atm doesn't need reverse
07:35:47 <Jafet> I think the DList instances are written under the assumption that they're all equivalent to (xs++)
07:36:19 <Jafet> So it's a partialness thing
07:41:15 <hpc> Jafet: all you need to do is assume it has the same properties as Endo
07:41:18 <hpc> (which it does)
07:51:30 <roastbird> i like type families
07:55:22 <monadic> k
08:15:02 <copumpkin> @tell edwardk radical idea: change top-level module in algebra to Algebra, rather than Numeric ;)
08:15:03 <lambdabot> Consider it noted.
08:18:43 <Jafet> Algebra.Abstract.Algebra
08:26:52 <kmc> Algebra.Abstract.Nonsense
08:28:05 <copumpkin> the category theory already has its own library
08:28:18 <Jetbeard> i was just about to say that :(
08:28:47 <Jafet> That's where it gets re-exported, I assume
08:29:51 <kizzx22> i am reading Real World Haskell, in one section it says ("a" ++ "b" ++ "c") to append a list has quadratic performance, where as ("a"++) . ("b"++) . ("c"++) $ [] has linear performance... is that true? i can't get it
08:30:11 <kmc> "a" ++ ("b" ++ "c") is fine actually
08:30:14 <Jafet> http://hpaste.org/47434/difference_lists
08:30:17 <kmc> the problem is ("a" ++ "b") ++ "c"
08:30:41 <kmc> because the outer (++) has to walk over the whole left list
08:30:43 <kizzx22> Jafet: thanks, Debug.Trace seems great, that helped a noob
08:30:54 <Jafet> :i (++)
08:30:56 <kmc> so if you append n things in a left-associated way
08:31:00 <Jafet> Bah
08:31:08 <kizzx22> :i (++)             infixr 5 ++
08:31:23 <kizzx22> so i thought  "a" ++ "b" ++ "c"  === "a" ++ ("b" ++ "c")
08:31:26 <kizzx22> ?
08:31:31 <kmc> correct
08:31:49 <kmc> a++b++c is fine
08:31:52 <kizzx22> what i dont understand is how ("a"++) . ("b"++) $ [] helps make it linear performance
08:32:07 <kmc> the point is not to write recursive algorithms which append in a substantially eft-associated way
08:32:07 <kizzx22> even if ++ is infixl, couldn't i have just added parens?
08:32:08 <kmc> left*
08:32:40 <hpc> kizzx22: suppose you were writing a website using Writer String
08:32:42 <kizzx22> kmc: oic, that seems to help
08:32:42 <Jafet> If you evaluate them by hand, using the defining equations for (++), you can see how that traverses each list exactly once
08:32:44 <kmc> they are not concerned about some literal expression in your code
08:32:51 <kmc> those will be short anyway
08:32:58 <hpc> so you write "<html>", then you write "<body>" ...
08:33:17 <hpc> but those get concatenated in (a ++ b) ++ c... order
08:33:34 <kizzx22> hpc: that answers exactly my question, thanks :)
08:34:32 <ski> kizzx2 : assume `frob (Leaf foo) = fooToString foo; frob (Branch left right) = frob left ++ frob right' and consider what happens in `frob (Branch (Branch (Leaf x) (Leaf y)) (Leaf z))'
08:35:00 <parcs> hpc: does Writer String exhibit the fast or slow behavior?
08:35:11 <hpc> parcs: slow
08:36:29 <parcs> is there a fast version of Writer on hackage somewhere?
08:36:41 <hpc> yes
08:36:51 <hpc> it's called Writer :P
08:36:54 <kizzx2> ski: thanks
08:36:59 * ski . o O ( `Writer (Endo String)' ? )
08:37:02 <hpc> (this is what DList is for)
08:37:08 <parcs> hmm
08:37:44 <parcs> it would be nice if a library performed the DList thing trasparently
08:38:16 <ski> kizzx2 : so, the general problem is recursive calls `frob ... = frob (...) ++ ...', and the general solution is to introduce an accumulator (which is what `DList' does)
08:38:54 <parcs> Writer ByteString (strict) must have horrible performance
08:39:04 <parcs> all those allocations..
08:39:35 <kizzx2> ski: it seems like a wide range of recursive functions' performance get improved by doing it foldr
08:39:40 <hpc> i think in those cases you would Writer (DList Word8) and then smoosh them together into a bytestring at the end
08:39:59 <kizzx2> or foldr + helper function, rather
08:40:19 <parcs> what about DList ByteString and just mconcat at the end?
08:40:29 <ski> kizzx2 : i'm not sure what you have in mind ..
08:40:32 <hpc> that too
08:40:41 <kizzx2> ski: yea, me too, i think i lost myself after saying that sentence
08:40:43 <kizzx2> ski: lol, nvm
08:42:15 <Jafet> Congratulations, you're learning overgeneralization
08:42:24 <Jafet> This will be an invaluable skill while you use haskell
08:42:56 * parcs works on writer-dlist
08:43:10 <hpc> you want writer-endo
08:43:17 <ski> @quote premature.generalisation
08:43:17 <lambdabot> ksf says: ...premature generalisation is the root of all procrastination.
08:43:35 <parcs> what is endo?
08:43:39 <hpc> @src Endo
08:43:39 <lambdabot> Source not found. Just try something else.
08:43:52 <hpc> data Endo a = Endo {appEndo :: a -> a}
08:44:00 <hpc> DList a = Endo [a]
08:45:05 <parcs> @hoogle Endo
08:45:06 <lambdabot> Data.Monoid newtype Endo a
08:45:06 <lambdabot> Data.Monoid Endo :: (a -> a) -> Endo a
08:45:06 <lambdabot> Data.Monoid appEndo :: Endo a -> a -> a
08:46:26 <Tomsik> Endomorphisms obviously
08:46:43 <parcs> obviously!
08:50:05 <ski> @type (\f -> f (In (Endo f))) (\g@(In (Endo f)) -> f g)
08:50:06 <lambdabot> Mu Endo
10:25:36 <parcs> @djinn ((a -> b) -> c) -> (d -> a) -> ((d -> b) -> c)
10:25:36 <lambdabot> -- f cannot be realized.
10:26:02 <parcs> is djinn lying?
10:26:55 <dmwit> parcs: nope
10:28:10 <dmwit> parcs: If you've got (f :: (a -> b) -> c), (g :: d -> a), and (h :: d -> b) in hand, what, exactly are you going to do with them?
10:28:30 <dmwit> parcs: You haven't got an (a -> b) to provide to (f), and you haven't got a (d) to provide to either (g) or (h).
10:29:31 <dmwit> however...
10:29:56 <dmwit> ?djinn ((a -> b) -> c) -> (a -> d) -> ((d -> b) -> c)
10:30:29 <copumpkin> poor djinn
10:30:31 <dmwit> f g h i = g (i . h)
10:30:37 <dmwit> Dunno what happened to djinn.
10:32:29 <lolmoneylol> Hey
10:32:29 <lolmoneylol> I have to do a presentation on Haskell.  In what ways do you think it outperforms other languages (What is it best at)
10:32:29 <parcs> makes sense
10:34:11 <ash__> okay, this is a dumb question, but I have an array that I am trying to index, a Data.Array.Repa Array, and I wanted to use !? which is Maybe Int as its result, how do I get to the int part for a comparison?
10:34:13 <dmwit> lolmoneylol: Without actually reading these links, here is what Google says.
10:34:17 <dmwit> http://stackoverflow.com/questions/1604790/what-is-haskell-actually-useful-for
10:34:22 <dmwit> http://haskell.org/haskellwiki/Why_Haskell_matters
10:34:35 <dmwit> http://www.cs.utexas.edu/~shmat/courses/cs345/whyfp.pdf
10:34:36 <parcs> @djinn ((a -> b) -> c) -> (d -> a) -> (d -> b) -> d -> c
10:34:37 <lolmoneylol> anyone
10:34:38 <hpc> that's obviously \_ _ _ _ -> undefined
10:34:38 <parcs> lolmoneylol: that has been covered extensively. google around
10:34:38 <parcs> why didn't lambdabot return anything
10:34:39 <lambdabot> f a _ b c = a (\ _ -> b c)
10:34:39 <lambdabot> f a b c = a (\ d -> c (b d))
10:35:54 <lolmoneylol> thanks
10:36:31 <dmwit> lolmoneylol: Forgive me for not responding more personally, but this looks like a classic troll opening, and your nick isn't helping my opinion.
10:38:04 <kmc> lolmoneylol, knowing your code works before you run it
10:41:03 <lolmoneylol> no i use this nick in bitcoin otc
10:41:04 <Nisstyre> yes
10:41:16 <lolmoneylol> i really have to do a presentation on Monday
10:41:21 <copumpkin> :o
10:41:39 <kmc> haha bitcoin again
10:41:47 <lolmoneylol> I have to show some examples and write some code, but I want to show examples of things haskell is useful for as oposed to stock stuff like factorial
10:42:01 <copumpkin> damn, too many bitcoiners in here
10:42:01 <copumpkin> lolmoneylol: bring up the pure haskell bitcoin client ;)
10:42:02 <ash__> so... if I am getting an error in a library, is there anyway to tell which call caused it?
10:42:03 <kmc> facebook uses it to automate refactoring of their terrible PHP code
10:42:12 <kmc> google used it for some server administration tools
10:42:14 <ash__> its not telling me the line of my program that caused it
10:42:14 <kmc> there's a paper on that
10:42:22 <copumpkin> "turd-massging with haskell: a case study"
10:42:22 <kmc> it's also used by a bunch of investment banks for financial derivatives modeling
10:42:24 <ash__> its just telling me the line in the library that had the error
10:42:32 <kmc> http://www.haskell.org/haskellwiki/Haskell_in_industry
10:42:40 <lolmoneylol> I actually got to do some code though
10:43:05 <lolmoneylol> So haskell would be best for hammering out math, simulation, etc?
10:43:15 <kmc> not really
10:43:22 <monadic> lolmoneylol: Its good for everything ;)
10:43:35 <lolmoneylol> it seems like a "math" based language, considering it is functional
10:43:38 <copumpkin> yeah, I pretty much use it for everything outside of work
10:43:41 <lolmoneylol> f(x) = something...
10:43:50 <monadic> lolmoneylol: Actually, its f x = something
10:43:54 * wli used it for scripting things at work.
10:43:59 <copumpkin> you can write f(x) = something
10:44:00 <lolmoneylol> well in haskell ya
10:44:02 <copumpkin> if you really want to
10:44:05 <wli> f (x :: SomeType)
10:44:09 <copumpkin> > let f(x) = x+ 1 in f(5)
10:44:10 <lambdabot>   6
10:44:13 <hpc> i wrote my website in haskell
10:44:13 * ash__ used it for robotics...
10:44:32 <monadic> and of course its math. All programming is math, since it all reduces down to a Turing-complete language like the lambda calculus
10:44:37 <hpaste> ash__ pasted “Error in a library” at http://hpaste.org/49114
10:44:47 <monadic> unlambda is the best programming language :)
10:45:05 <kmc> right, saying "Haskell has mathematical foundations" or whatever is just a way of saying that the people who designed Haskell paid attention to what they're doing
10:45:22 <kmc> all programming languages are built on math but usually the designers don't pay attention and make a mess of it
10:45:38 <ash__> so, anyone know a better way to figure out which line is causing an error? if its happening in a library
10:45:40 <kmc> which has consequences for getting shit done as well as the theoretical elegance
10:45:42 * wli pompoms kmc
10:46:06 <lolmoneylol> what area would you say it excells at.  I know it can technically be used for everything.  I for one like to write my backend for sites in PHP,  interacting with hardware in C, and doing server administration in bash.  Why, because those languages are good for those things
10:46:24 <kmc> lolmoneylol, i gave you a few examples above and a link to a bunch more
10:46:28 <lolmoneylol> i could write my bash scripts in C
10:46:35 <lolmoneylol> but i don't
10:46:39 <lolmoneylol> ok im going to read
10:46:40 <monadic> lolmoneylol: You use PHP for websites? Run quick~
10:46:42 <luite> haskell is good for all of those!
10:46:49 <hpc> lolmoneylol: one thing haskell is fairly good at is describing what things ARE, rather than what they DO
10:46:56 <hpc> you could make a good talk based on that
10:47:02 <monadic> lolmoneylol: Its good at being on terms with C/C++ in terms of speed
10:47:12 <monadic> (if you know what you are doing)
10:47:28 <lolmoneylol> dosen't all the recursion kill performance?
10:47:35 <wli> monadic: It compiles to native code is the best way to put that.
10:47:40 <monadic> lolmoneylol: Since when does recursion = bad performance?
10:47:50 <monadic> wli: Not true. You can compile a lot of slow stuff to native code.
10:48:10 <hpc> poorly written recursive functions will be slow in any language
10:48:11 <lolmoneylol> overhead, memory allocation, ever increasing stack
10:48:11 <monadic> It certainly _helps_, but its probably not the main reason. You can heavily optimize functional code
10:48:20 <MatrixFrog> lolmoneylol: you can find tons of code at hackage
10:48:24 <monadic> lolmoneylol: Why is your stack everly increasing?
10:48:32 <MatrixFrog> lambdaboth: tell lolmoneylol about hackage
10:48:34 <monadic> lolmoneylol: Optimize it!
10:48:35 <MatrixFrog> lambdabot: tell lolmoneylol about hackage
10:48:43 * MatrixFrog probably did that wrong
10:48:47 <wli> monadic: Well, some sort of appropriate reservation there would be useful to avoid creating unrealistic expectations.
10:48:48 <MatrixFrog> @google hackage
10:48:50 <lambdabot> http://hackage.haskell.org/
10:48:50 <lambdabot> Title: HackageDB: introduction
10:49:11 <lolmoneylol> Stack grows for every functon call.  Thanks
10:49:27 <monadic> wli: Thats why I used the "if you know what you are doing". Things like choosing the right data structure still matter, and they always will. ST monad for example for internal mutability with a functional interface
10:49:28 <MatrixFrog> lolmoneylol: i'm pretty sure haskell can optimize tail recursive functions. or rather, most haskell implementations can
10:49:47 <monadic> The real thing to be careful of is the thunk killing you when you recurse
10:50:18 <lolmoneylol> Thanks for hackage
10:50:24 <monadic> Of course, thats mostly if its O(n). If its O(log n) then you probably don't need to bother with tail recursion anyway
10:51:58 <monadic> lolmoneylol: Also haskell is good for testing. I hate doing all that mocking and unit-testing in other languages, while in Haskell you have the beautiful quickcheck testing via properties
10:52:21 <monadic> Not to mention having to write everything as IOC
10:53:44 <wli> (Well, there's Eiffel...)
10:53:46 <MatrixFrog> monadic: out of curiosity, i checked and there is a Java quickcheck. ugly and verbose of course, but good to know someone tried
10:53:47 <hpc> monadic: not to mention you can just find invariants of functions by hand directly
10:53:57 <hpc> because they are so short and well-defined
10:54:26 <monadic> MatrixFrog: Hmm, interesting. Doubt it would work well with all the unfunctional aspects of the language, though
10:54:44 <akosch> how can I work with C structs in the haskell FFI?
10:55:13 <ash__> akosch: http://www.haskell.org/haskellwiki/FFICookBook#Working_with_structs
10:55:16 <monadic> akosch: Do you need to access the raw data or no?
10:55:29 <monadic> akosch: Do you just need, for instance, to be able to have a pointer to it that you pass around
10:55:42 <akosch> monadic: I need the raw data :(
10:55:52 <monadic> akosch: Then you need a storable instance for an ADT
10:56:11 <monadic> akosch: c2hs and hsc2hs can help you
10:56:11 <ion> lolmoneylol: Do you know about tail call optimization?
10:56:25 <akosch> monadic: thanks, I'll check them out...
10:57:03 <MatrixFrog> monadic: it should work well for functions that take ints or Strings or something, but beyond that, yes it's probably a mess. i didn't actually try it out, just glanced at it
10:57:30 <MatrixFrog> http://java.net/projects/quickcheck/pages/Home
10:58:09 <monadic> MatrixFrog: Its ugly :)
10:59:21 <MatrixFrog> shocking
11:06:35 <copumpkin> @ask edwardk if I want to make functions that work over any monoid
11:06:36 <lambdabot> Consider it noted.
11:07:03 <copumpkin> @ask edwardk if I want to make functions that work over any monoid, which of the two monoids in your package should I use? maybe it'd pay to have a common superclass of both for people who don't care whether it's additive or multiplicative?
11:07:03 <lambdabot> Consider it noted.
11:08:21 <c_wraith> where do you categorize monoids that don't act particularly like addition or multiplication?  like, um... First or Last?
11:09:25 * MatrixFrog just used quickcheck on a function that takes a list of functions. pretty sure that was just pure magic
11:10:33 <danharaj> hey, what replaced the evil mangler?
11:11:36 <copumpkin> c_wraith: they aren't monoids, really
11:11:51 <copumpkin> c_wraith: and I'll add that I'm not really a fan of the additive/multiplicative distinction :)
11:12:09 <parcs> danharaj: nothing, f-viaC is removed
11:12:24 <danharaj> ah
11:16:13 <MatrixFrog> Deﬁne a function applyAll that, given a list of functions
11:16:13 <MatrixFrog> [f1 , f2 , ..., fn ] and a value v, returns the result f1 (f2 (...(fn v)...)).
11:16:27 <hpc> foldr (.) id
11:16:49 <MatrixFrog> i have: applyAll fs x = foldr ($) x fs
11:17:15 <ion> > foldr (.) [f, g, h] a
11:17:16 <lambdabot>   Couldn't match expected type `[b -> b]'
11:17:16 <lambdabot>         against inferred type `Simp...
11:17:24 <ion> > foldr (.) [(f :: Expr -> Expr), g, h] a
11:17:25 <lambdabot>   Couldn't match expected type `[(SimpleReflect.Expr
11:17:26 <lambdabot>                         ...
11:17:31 <parcs> @@ pl djinn (a -> b -> c -> d) -> (e -> c) -> (a -> b -> e -> d)
11:17:31 <lambdabot>  pl djinn (a -> b -> c -> d) -> (e -> c) -> (a -> b -> e -> d)
11:17:36 <hpc> > foldr (.) id [f,g,h] a
11:17:38 <lambdabot>   f (g (h a))
11:17:42 <MatrixFrog> nice
11:17:43 <parcs> @. pl djinn (a -> b -> c -> d) -> (e -> c) -> (a -> b -> e -> d)
11:17:43 <lambdabot> f = flip . ((flip . ((.) .)) .)
11:17:46 <ion> Ah, forgot the id.
11:17:59 <ion> > foldr ($) a [f,g,h]
11:18:01 <lambdabot>   f (g (h a))
11:18:10 <hpc> i believe you can also use mconcat?
11:18:19 <ion> > mconcat [f,g,h] a
11:18:20 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:18:20 <lambdabot>    `GHC.Show.Show a'
11:18:21 <lambdabot>      a...
11:18:22 <MatrixFrog> > foldr (.) id [f,g,h]
11:18:23 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> b)
11:18:23 <hpc> wait nvm
11:18:24 <lambdabot>    arising from a use of `...
11:18:26 <parcs> with Endo maybe
11:18:29 <hpc> functions aren't monoids all by themselves
11:18:31 <hpc> yeah
11:19:14 <hpc> :t foldr (.) id
11:19:15 <lambdabot> forall b. [b -> b] -> b -> b
11:19:34 <ash__> are there mutable repa arrays?
11:20:25 <MatrixFrog> @src foldr
11:20:26 <lambdabot> foldr f z []     = z
11:20:26 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
11:20:33 <ion> > ala Endo foldMap [f,g,h] a
11:20:35 <lambdabot>   Not in scope: `foldMap'
11:20:46 <ion> > ala Endo Data.Foldable.foldMap [f,g,h] a
11:20:47 <lambdabot>   f (g (h a))
11:21:04 <MatrixFrog> you guys lost me, i'm still working on the foldr (.) thing...
11:21:34 <hpc> MatrixFrog: take your list of functions [f, g, h]
11:21:39 <MatrixFrog> i'm working on it
11:21:47 <hpc> MatrixFrog: express the list as (f:g:h:[])
11:22:08 <MatrixFrog> oh yeah the foldr trick where you replace (:) with, in this case (.)
11:22:14 <hpc> yeah
11:22:17 <hpc> and [] with id
11:22:27 <hpc> so you get f . g . h . id = (f . g . h)
11:22:31 <MatrixFrog> whatever the "z" value is
11:23:05 <MatrixFrog> so ok. so the other puzzle is applyEach:
11:23:24 <MatrixFrog> applyEach [(+1),(*2),id] 4 = (5,8,4)
11:23:42 <MatrixFrog> the best i could think of was: applyEach fs x = map ($ x) fs
11:24:00 <ion> map ($ x) is fine.
11:24:03 <parcs> :t map . id
11:24:04 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
11:24:07 <hpc> :t \fs x -> fmap ($ x) fs
11:24:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
11:24:12 <hpc> :t flip
11:24:13 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
11:24:35 <hpc> lambdabot has a freaky definition of flip, which happens to work out to that
11:24:44 <hpc> but yeah, your answer is good
11:24:50 <hpc> it's how i would do it
11:24:51 <MatrixFrog> weird. but ok cool
11:25:03 <MatrixFrog> it seems like there might be some clever way to make it point-free
11:25:17 <MatrixFrog> or point-free-er
11:25:17 <hpc> @pl \fs x -> fmap ($ x) fs
11:25:17 <lambdabot> flip (fmap . flip id)
11:25:31 <hpc> nah, just give it a good name :P
11:25:37 <clsmith> what does @pl do?
11:25:44 <hpc> and use fmap instead of map, so you get that bonus polymorphism :D
11:25:51 <hpc> clsmith: makes things pointless
11:25:54 <ski> @help pl
11:25:55 <lambdabot> pointless <expr>. Play with pointfree code.
11:26:02 <clsmith> ahhh, thanks
11:26:05 <hpc> @pl \x -> x
11:26:05 <MatrixFrog> is that always possible to do?
11:26:05 <lambdabot> id
11:26:17 <ion> Yes, but the results may be abhorrent.
11:26:19 <hpc> MatrixFrog: yes, but you won't always like the result
11:26:20 <MatrixFrog> :D
11:26:20 <hpc> haha
11:26:35 <ski> @pl id
11:26:36 <lambdabot> id
11:26:38 <hpc> @pl \a b c d e f g -> c d f a c g b f
11:26:39 <lambdabot> (((const .) .) .) . flip flip id . ((flip . ((flip . (liftM2 flip .)) .)) .) . flip . ((flip . ((flip . (flip .)) .)) .) . join . ((flip . (flip .)) .) . flip (flip . (flip .))
11:26:42 <MatrixFrog> <3
11:27:02 <ion> @@ @unpl @pl \a b c d e f g -> c d f a c g b
11:27:03 <lambdabot>  (\ an br bu bx _ m p -> ((\ cj u v y -> cj v y an u) >>= \ be -> be) bu bx m p br)
11:27:09 <mauke> > sequence [f, g, h] x
11:27:10 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:27:10 <lambdabot>    `GHC.Show.Show a'
11:27:10 <lambdabot>      a...
11:27:12 <monadic> This is why haskell is so beautiful
11:27:15 <hpc> :t sequence
11:27:16 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
11:27:17 <mauke> > sequence [f, g, h] x :: [Expr]
11:27:18 <lambdabot>   [f x,g x,h x]
11:27:31 <monadic> By the way, what is the liftM2 doing in the \a b c d e f g -> c d f a c g b f
11:27:57 <ion> :t liftM2 Prelude.flip
11:27:57 <mauke> monadic: http://mauke.dyndns.org/tmp/flow.png
11:27:58 <lambdabot> forall a a2 c (m :: * -> *). (Monad m) => m (a -> a2 -> c) -> m a2 -> m (a -> c)
11:28:29 <ion> (z -> a -> a2 -> c) -> (z -> a2) -> (z -> a -> c)
11:28:31 <ski> > [f,g,h] `flip` x :: [Expr]
11:28:33 <lambdabot>   [f x,g x,h x]
11:28:49 <mauke> > liftM2 h f g x :: Expr
11:28:50 <lambdabot>   Ambiguous type variable `a1' in the constraints:
11:28:50 <lambdabot>    `SimpleReflect.FromExpr...
11:28:53 <mauke> :-(
11:28:56 <monadic> Yes, but what is its instance of Monad there?
11:29:04 <mauke> monadic: (->) e
11:29:27 <monadic> mauke: Ah, okay.
11:29:39 <mauke> > liftM2 (h :: Expr -> Expr -> Expr) f g x
11:29:40 <lambdabot>   h (f x) (g x)
11:30:16 <hpc> > ap (h :: Expr -> Expr -> Expr) f x
11:30:17 <lambdabot>   h x (f x)
11:30:25 <hpc> > (=<<) (h :: Expr -> Expr -> Expr) f x
11:30:26 <lambdabot>   h (f x) x
11:30:47 <hpc> mauke: that diagram would be nice with some actual code attached :P
11:31:16 <mauke> or if it wasn't hand drawn in paint
11:32:46 <MatrixFrog> lambdabot doesn't know about efficiency does it?
11:33:20 <MatrixFrog> if i have a list A, length n, and a list B, length m, it can't tell me the big O efficiency of A ++ B can it?
11:33:49 <mauke> no, but it's O(n)
11:34:16 <lambdabot> I wouldn't have guessed that in a million years.
11:34:29 <monadic> Or O(1) if you don't use it :)
11:34:41 <MatrixFrog> heh true
11:34:55 <MatrixFrog> it says so in this book i'm reading but i had to scroll up to find it
11:34:57 <monadic> Or still O(1), I think, if you do take n (A ++ B)
11:35:06 <MatrixFrog> oh nice
11:35:15 <MatrixFrog> this book hasn't talked too much about the laziness aspect yet
11:35:19 <MatrixFrog> i'm sure it will
11:35:25 <monadic> MatrixFrog: Which book?
11:35:29 <MatrixFrog> http://plucky.cs.yale.edu/cs431/reading.htm
11:35:45 <MatrixFrog> i've also read most of lyah and rwh but i like this one too because you get to play music while you learn!
11:36:08 <akosch> how can I remove all packages install with cabal for my local user?
11:36:15 <akosch> *installed
11:37:06 <monadic> akosch: rm -rf .cabal?
11:38:00 <ash__> so... profiling a program, its spending 98.7% of the time in 1 function, is there anyway to break that down further?
11:38:04 <akosch> monadic: I've done that, but somehow the system still lists them as installed
11:38:09 <hpc> MatrixFrog: A ++ B is O(length B), if evaluated to normal form
11:38:16 <hpc> (ie, evaluated entirely)
11:38:34 <akosch> monadic: if I run "ghc-pkg --user check", it gives me a lot of errors about missing files
11:38:44 <parcs> akosch: also ~/.ghc
11:39:01 <akosch> parcs: thanks...
11:39:03 <hpc> also, finding the efficiency of algorithms is running up against the halting problem, yes?
11:39:21 <hpc> because if you know how long it takes to terminate, you know if it terminates
11:39:23 <monadic> akosch: And I think ghc-pkg unregister
11:39:25 <MatrixFrog> you mean if lambdabot were to try and calculate efficiencies programmatically?
11:39:29 <hpc> yeah
11:39:49 <MatrixFrog> more likely a human would calculate them, and then ask lambdabot to remember them
11:39:52 <akosch> monadic: thanks :)
11:39:53 <MatrixFrog> i guess you're right
11:40:25 <mauke> hpc: what what what are you doing?!
11:40:54 <parcs> anyone know of a combinator library for 'modifying' a function's nth argument? e.g. third :: (c' -> c) -> (a -> b -> c -> d) -> (a -> b -> c' -> d)
11:41:15 <hpc> mauke: eh?
11:41:47 <mauke> hpc: it's obviously not O(length B)
11:41:55 <hpc> oh wait, im dumb lol
11:41:58 <hpc> i see
11:42:41 <hpc> well, it is O(length B) if A and B are normal form, but A ++ B isn't
11:42:47 <hpc> technically
11:42:52 <hpc> but yeah, assumptions
11:43:02 <mauke> huh?
11:43:11 <hpc> because it has to scan through B again
11:43:13 <mauke> A = [0 ..], B = []
11:43:30 <mauke> A ++ B is not O(1)
11:43:31 <hpc> heh, ill shut up then :P
11:43:33 <ski> @let arg :: (a1 -> a0) -> ((a0 -> b) -> (a0 -> b)); arg mod f = f . mod
11:43:34 <lambdabot>  <local>:2:63:
11:43:34 <lambdabot>      Couldn't match expected type `a0' against inferred type `...
11:43:39 <ski> @let arg :: (a1 -> a0) -> ((a0 -> b) -> (a1 -> b)); arg mod f = f . mod
11:43:40 <lambdabot>  Defined.
11:43:45 <ski> @let res :: (b0 -> b1) -> ((a -> b0) -> (a -> b1)); res mod f = mod . f
11:43:46 <lambdabot>  Defined.
11:44:25 <ski> @type let third = res . res . arg in third
11:44:26 <lambdabot> forall a1 a0 a a11 b. (a1 -> a0) -> (a -> a11 -> a0 -> b) -> a -> a11 -> a1 -> b
11:45:16 <parcs> neat
11:45:56 <ski> @let (~>) :: (a1 -> a0) -> (b0 -> b1) -> ((a0 -> b0) -> (a1 -> b1)); (modArg ~> modRes) f = modRes . f . modArg
11:45:57 <lambdabot>  Defined.
11:46:28 <ski> @type appEndo ~> Endo
11:46:29 <lambdabot> forall a a1. ((a -> a) -> a1 -> a1) -> Endo a -> Endo a1
11:46:53 <MatrixFrog> :-/
11:46:56 <ski> @type runStateT ~> StateT
11:46:57 <MatrixFrog> appendr = foldr (ﬂip (++)) [ ]
11:46:57 <MatrixFrog> appendl = foldl (ﬂip (++)) [ ]
11:46:57 <lambdabot> forall s (m :: * -> *) a s1 (m1 :: * -> *) a1. ((s -> m (a, s)) -> s1 -> m1 (a1, s1)) -> StateT s m a -> StateT s1 m1 a1
11:47:32 <MatrixFrog> the question is which one is more efficient
11:48:17 <mauke> heh, ﬂip
11:48:28 <MatrixFrog> [a,b,c,d] ends up as a ++ (b ++ (c ++ d)) for appendl
11:48:32 <mauke> good show, old bean
11:48:32 <parcs> ski: is there a library that contains that?
11:48:45 <ski> parcs : istr conal has one
11:48:47 <MatrixFrog> and ((a++b) ++ c) ++ d for appendr
11:49:08 <mauke> @src concat
11:49:08 <lambdabot> concat = foldr (++) []
11:49:10 <MatrixFrog> oh i see, so appendr is much less efficient
11:49:32 <ski> > foldr (flip f) z [a,b,c,d]
11:49:34 <lambdabot>   f (f (f (f z d) c) b) a
11:49:42 <ski> > foldl (flip f) z [a,b,c,d]
11:49:43 <lambdabot>   f d (f c (f b (f a z)))
11:49:45 <MatrixFrog> if it was concat = foldl (++) [] you would get the same result but less efficiently, right?
11:49:56 <ski> MatrixFrog : so no, you got the other order
11:50:05 <mauke> > foldl (++) [] ["a", "b", "c", "d"]
11:50:07 <lambdabot>   "abcd"
11:50:17 <MatrixFrog> > foldr (flip ++) "abcd"
11:50:18 <lambdabot>   Couldn't match expected type `a -> a -> b'
11:50:18 <lambdabot>         against inferred type `[...
11:50:24 <MatrixFrog> > foldr (flip ++) "" "abcd"
11:50:26 <lambdabot>   Couldn't match expected type `a -> a -> b'
11:50:26 <lambdabot>         against inferred type `[...
11:50:35 <ski> > foldl (flip (++)) [] ["a","bc"]
11:50:35 <MatrixFrog> > foldr (flip ++) [] "abcd"
11:50:37 <lambdabot>   Couldn't match expected type `a -> a -> b'
11:50:37 <lambdabot>         against inferred type `[...
11:50:37 <lambdabot>   "bca"
11:50:43 <MatrixFrog> oh right, duh
11:50:59 <ski> > foldr (flip (++)) [] ["a","bc"]
11:51:02 <lambdabot>   "bca"
11:51:09 <MatrixFrog> oh except i don't want it to fully evaluate it. hm
11:51:24 <MatrixFrog> concat is defined with a foldl because it's more efficient that way right?
11:51:24 <ski> you still get the parts in the wrong order
11:51:29 <MatrixFrog> i mean a foldr, sorry
11:51:30 <ski> no
11:51:54 <ski> `concat' is defined with `foldr' so that it will work on infinite lists, e.g.
11:52:06 <ski> > concat (repeat [0,1,2])
11:52:07 <lambdabot>   [0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,1,2,0,...
11:52:16 <ski> > foldl (++) [] (repeat [0,1,2])
11:52:24 <lambdabot>   mueval: ExitFailure 1
11:52:24 <lambdabot>  mueval-core: Time limit exceeded
11:53:15 <MatrixFrog> > foldl f [] [0,1,2,3]
11:53:16 <ski> (also `foldr' can be incremental, while `foldl' is bulky)
11:53:18 <lambdabot>   No instance for (SimpleReflect.FromExpr [a])
11:53:19 <lambdabot>    arising from a use of `e_10...
11:53:28 <ski> > foldl f z [0,1,2,3]
11:53:30 <lambdabot>   f (f (f (f z 0) 1) 2) 3
11:53:31 <MatrixFrog> > foldl f [] ["a","b","c","d"]
11:53:32 <lambdabot>   No instance for (SimpleReflect.FromExpr [a])
11:53:32 <lambdabot>    arising from a use of `e_1'...
11:54:22 <ski> > foldl (+) z [0,1,2,3]
11:54:23 <lambdabot>   z + 0 + 1 + 2 + 3
11:54:29 <ski> > foldr (+) z [0,1,2,3]
11:54:30 <lambdabot>   0 + (1 + (2 + (3 + z)))
11:57:13 <MatrixFrog> i don't see what i'm doing wrong here:
11:57:14 <MatrixFrog> > foldr f [] [[0],[1],[2],[3]]
11:57:15 <lambdabot>   No instance for (SimpleReflect.FromExpr [a])
11:57:15 <lambdabot>    arising from a use of `e_10...
11:57:25 <ash__> how expensive is copying?
11:58:00 <ski> .. copying what ?
11:58:28 <ski> MatrixFrog : the base case `[]'
11:58:48 <ash__> I made a little program that does brushfire decomposition of a playing field, and I have now re-wrote it 3 times changing data structures from built in lists, to Data.Map to Data.Array.Repa and they are all almost the exact same runtime and all are exponentially slow
11:59:25 <ash__> the only thing I can think of is they are all using immutable data structures, so maybe a mutable version might be faster because it would copy the field fewer times?
11:59:27 <MatrixFrog> ski: what about it?
11:59:39 <ski> @type f
11:59:40 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
12:00:08 <ski> MatrixFrog : `[]' forces the result to be a list, but `FromExpr' (from `f') doesn't know how to handle lists
12:00:39 <ski> MatrixFrog : typically, `Expr' is just used as a stand-in for `Int' or `Integer' or `Double' or similar numeric types
12:01:46 <mauke> :t foldr ?f [] [[0],[1],[2],[3]]
12:01:50 <lambdabot> forall a t. (?f::[t] -> [a] -> [a], Num t) => [a]
12:02:06 <thoughtpolice> preflex: seen copumpkin
12:02:06 <preflex>  copumpkin was last seen on #haskell 50 minutes and 17 seconds ago, saying: c_wraith: and I'll add that I'm not really a fan of the additive/multiplicative distinction :)
12:02:16 <ski> MatrixFrog : you might have more fun with
12:02:18 <ski> @where stepeval
12:02:18 <lambdabot> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
12:02:25 <mauke> preflex: seen thoughtpolice
12:02:25 <preflex>  thoughtpolice was last seen on #haskell 19 seconds ago, saying: preflex: seen copumpkin
12:02:43 <MatrixFrog> well i was step-evaling through appendl and appendr by hand
12:02:47 <MatrixFrog> but yeah, good idea
12:05:05 <copumpkin> yo
12:05:06 <copumpkin> thoughtpolice
12:07:48 <MatrixFrog> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=let+f+%3D+flip+%28%2B%2B%29+in+foldr+f+%5B%5D+%5B%5B1%2C2%5D%2C%5B3%2C4%5D%2C%5B5%2C6%2C7%2C8%2C9%2C10%2C11%5D%5D
12:08:06 <thoughtpolice> copumpkin: damnit my brain just context switched and i forgot what i was going to ask.
12:08:10 <copumpkin> lol
12:08:49 <MatrixFrog> not sure what happened at the end there, but in any case, i'm all confused. i think the moral is that sometimes the two folds give the same results, but one is more efficient, and i'll come back to this later
12:09:23 <copumpkin> MatrixFrog: that's the case in many things
12:09:46 <copumpkin> if you foldl (++) [] or foldr (++) [] it's the same end result, but one will be a lot slower than the other
12:09:51 <FUZxxl> dons: Are you here?
12:10:08 <copumpkin> concatenation is associative, but the runtime behavior of doing one order over the other is different
12:10:14 <copumpkin> FUZxxl: not even in this channel
12:10:29 <thoughtpolice> dons has been scarce lately
12:10:36 <copumpkin> he's in singapore
12:11:01 <mauke> preflex: seen dons
12:11:02 <preflex>  dons was last seen on #haskell 15 days, 19 hours, 28 minutes and 35 seconds ago, saying: tommd: i manually ran it a couple of times, after the captcha was added
12:13:01 <MatrixFrog> ok here's a fun one: Rewrite the deﬁnition of length non-recursively.
12:13:14 <MatrixFrog> i assume they mean, using a fold, which is still recursive but not explicitly
12:13:30 <copumpkin> probably
12:13:42 <mauke> I'd use map, not foldr
12:13:43 <MatrixFrog> don't tell me the answer though, i can get it! :)
12:14:08 <copumpkin> map (const ()) -- then treat the resulting [()] as a peano natural
12:14:21 <mauke> copumpkin: too complicated
12:14:29 <MatrixFrog> sounds fancy
12:14:34 <MatrixFrog> @google peano natural
12:14:36 <lambdabot> http://en.wikipedia.org/wiki/Natural_number
12:14:36 <lambdabot> Title: Natural number - Wikipedia, the free encyclopedia
12:14:36 <FUZxxl> hm...
12:14:53 <c_wraith> yes.  it's really hard to write a non-recursive length implementation. :)  (you can do it for lists up to a fixed length, but that's ugly code)
12:15:03 <FUZxxl> Does anybody has further informations about this blog post of him?
12:15:03 <FUZxxl> http://donsbot.wordpress.com/2009/03/09/evolving-faster-haskell-programs/
12:15:13 <MatrixFrog> oh do you mean that [(), (), ()] would represent the number 3?
12:15:18 <FUZxxl> There are some files linked, that are no longer available :(
12:15:21 <copumpkin> MatrixFrog: basically "zero is a natural. if x is a natural, then we define its successor to be a natural"
12:15:25 <c_wraith> len [] = 0; len [_] = 1; len [2, 2] = 2; ....
12:15:30 <c_wraith> err
12:15:36 <c_wraith> change that to [_, _]
12:15:44 <c_wraith> in any case, that's horrible, don't do it :)
12:15:53 <copumpkin> c_wraith: then use template haskell to generate all the clauses!
12:15:56 <mauke> :t sum . map 1
12:15:57 <lambdabot> forall a a1. (Num a) => [a1] -> a
12:16:07 <copumpkin> mauke: but sum is a fold!
12:16:21 <mauke> copumpkin: is that actually part of its spec?
12:16:27 <MatrixFrog> well in any case...
12:16:28 <c_wraith> copumpkin: that will result in crashing the compiler if you make it big enough. :)
12:16:32 <copumpkin> it's effectively a fold :P
12:16:38 <copumpkin> whether or not it's written as one
12:16:39 <MatrixFrog> first of all i love that i can do TDD in haskell by writing: prop_len x = length x == nrLength x
12:16:49 <mauke> copumpkin: and length is effectively recursive
12:16:53 <MatrixFrog> second, this is my solution: nrLength = foldr (\_ x -> x+1) 0
12:17:02 <c_wraith> It's fun how many ways TH can generate code that's too big for GHC to handle.
12:17:17 <copumpkin> mauke: sure
12:17:25 <MatrixFrog> @pl \_ x -> x+1
12:17:26 <lambdabot> const (1 +)
12:17:38 <MatrixFrog> @pl const (+1)
12:17:39 <lambdabot> const (1 +)
12:18:02 <MatrixFrog> interesting that it switched (+1) to (1+) but ok
12:18:11 <copumpkin> yeah, @pl likes doing that
12:18:26 <MatrixFrog> so then i could say nrLength = foldr (const (+1)) 0
12:18:46 <norm2782> I'm trying to make cabal execute c2hs for me and compile & link my library with  a C library, but I'm getting an error: https://gist.github.com/1086661 . what am I doing wrong here?
12:18:52 <mauke> MatrixFrog: or even (const succ)
12:19:01 <MatrixFrog> oh yes much better
12:19:03 <MatrixFrog> :)
12:23:12 <clsmith> @pl \x -> x == reverse x
12:23:12 <lambdabot> ap (==) reverse
12:24:11 <clsmith> and today i discovered ap
12:24:19 <MatrixFrog> nice
12:24:21 <mauke> a.k.a. S
12:24:36 <clsmith> not in the prelude though
12:25:10 <thomas`> Hi, I'm looking to make a 'simple' board game in haskell.  Does anyone have any pointers on how to get started with graphics programming in haskell?  (Not looking for anything fancy, just drawing a 3x3 grid with dots in it would be nice to begin with)
12:25:15 <clsmith> mauke: aka S?
12:25:20 <mauke> yes
12:25:47 <clsmith> mauke: so it is
12:26:00 <clsmith> (i had to think about that one)
12:26:40 <mauke> I = SKK
12:26:45 <mauke> :t ap const const
12:26:46 <lambdabot> forall b. b -> b
12:26:52 * hackagebot blakesum 0.1 - The BLAKE SHA-3 candidate hashes, in Haskell  http://hackage.haskell.org/package/blakesum-0.1 (KevinCantu)
12:27:26 <clsmith> mauke: i was thrown off by the infixing. :$
12:28:24 <MatrixFrog> thomas, i don't know but you could look on hackage for something similar
12:28:30 <MatrixFrog> use that as an example to work from
12:30:37 <clsmith> mauke: i guess C is flip and B is (.)?
12:30:53 <mauke> I'm not familiar with C/B
12:31:08 <akosch> I've been trying hsc2hs and was able to use #enum to handle defined constants (defined with #define or enum in the C header), but I don't understand how I should use the Storable type class for structs
12:31:17 <clsmith> C f x y => f y x; B f g x => f (g x);
12:32:21 <norm2782> clsmith: looks like it :)
12:36:11 <clsmith> :t ap
12:36:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:37:16 <clsmith> okay, so that's something i don't get. (ap const const), for instance, has no monad. so is there an implicit 'normal' monad?
12:37:24 <mauke> it has a monad
12:37:41 <clsmith> in what sense?
12:37:51 <mauke> what
12:38:05 <Tomsik> :t ap const const
12:38:07 <lambdabot> forall b. b -> b
12:38:22 <Tomsik> :t const
12:38:23 <lambdabot> forall a b. a -> b -> a
12:38:32 <Tomsik> m = (a ->) here
12:38:42 <Tomsik> or rather b ->
12:38:43 <Saizan> const :: x -> y -> x; if you solve the equation "m (a -> b) = x -> y -> x" you'll find out what m is
12:38:48 <mauke> ap :: m (a -> b) -> (m a -> m b); const :: c -> (d -> c)
12:38:52 <clsmith> oh! i see
12:39:05 <clsmith> thanks :)
12:49:42 <ash__> anyone know where any examples for Data.Vector.Mutable can be found?
12:53:01 <kyagrd> ash__: vector library?
12:53:49 <ash__> Well, all the test cases use the immutable vector
12:58:44 <clsmith> @ap (\x y -> x . y)
12:58:44 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
12:58:57 <clsmith> whoops
12:59:04 <clsmith> @pl (\x y -> x . y)
12:59:05 <lambdabot> (.)
12:59:31 <clsmith> @pl (\x y z -> x (y z))
12:59:31 <lambdabot> (.)
12:59:34 <clsmith> what. really?
13:00:35 <siracusa> @src (.)
13:00:35 <lambdabot> (f . g) x = f (g x)
13:00:35 <lambdabot> NB: In lambdabot,  (.) = fmap
13:01:45 <clsmith> hm, seems obvious in retrospect :p
13:10:18 <danharaj> what does NB mean
13:10:26 <mauke> nota bene
13:10:30 <clsmith> latin for "note well"
13:10:39 <danharaj> ah
13:11:19 <mauke> while we're at it, e.g. means "exempli gratia", i.e. means "id est", a.m. means "ante meridiem", p.m. means "post meridiem"
13:11:42 <c_wraith> etc
13:11:44 <c_wraith> :)
13:11:47 <mauke> et cetera
13:11:56 <mauke> fax is fac simile
13:14:25 <geheimdienst> sometimes you can switch from the workspace where you've been watching sheldon cooper to  the irc workspace and there's really no difference in tone
13:15:39 <MatrixFrog> i want a function like this...
13:15:40 <MatrixFrog> collect (+) 0 [1,2,3,4] = [0, 0+1, 0+1+2, 0+1+2+3, 0+1+2+3+4]
13:15:56 <MatrixFrog> i feel like i've seen it before but i can't recall
13:16:06 <dobblego> > fold (+) 0 [1,2,3,4]
13:16:07 <lambdabot>   Not in scope: `fold'
13:16:11 <dobblego> > foldl (+) 0 [1,2,3,4]
13:16:11 <MatrixFrog> @hoogle (a -> a) -> a -> [a] -> [a]
13:16:12 <lambdabot>   10
13:16:12 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
13:16:13 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
13:16:13 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
13:16:51 <MatrixFrog> dobblego that's just the last one, i want the "intermediate" results too
13:16:55 <Saizan> > scanl (+) 0 [1,2,3,4]
13:16:56 <lambdabot>   [0,1,3,6,10]
13:17:04 <MatrixFrog> aha, that's it!
13:18:10 <MatrixFrog> @type scanl
13:18:12 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
13:18:39 <MatrixFrog> ah right, the first arg is a function of 2 args
13:18:55 <Twey> Well… :þ
13:19:10 <geheimdienst> > scanl1 (+) [0..4]
13:19:12 <lambdabot>   [0,1,3,6,10]
13:19:12 <copumpkin> MatrixFrog: it'd be rather boring if it weren't
13:19:23 <copumpkin> > scanl1 (+) [1,3..]
13:19:25 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
13:19:26 <geheimdienst> ^^ pretty similar to saizan's solution
13:19:52 <copumpkin> @let figurate n = scanl1 (+) [1,n+1..]
13:19:54 <ash__> so... I have a MVector a Int and a [Int] of updates, how would one write all of those updates? write is: write :: PrimMonad m => MVector (PrimState m) a -> Int -> a -> m ()   I cant use a foldl...
13:19:56 <lambdabot>  Defined.
13:19:57 <MatrixFrog> i just had the type wrong with i hoogled
13:19:58 <copumpkin> > figurate 3
13:20:00 <lambdabot>   [1,5,12,22,35,51,70,92,117,145,176,210,247,287,330,376,425,477,532,590,651,...
13:20:03 <copumpkin> hmm, wrong
13:20:21 <ion> mauke: http://heh.fi/haskell/functors/#function-instance
13:20:23 <copumpkin> @undef
13:32:17 <wli> If I can handle things like max_{x\in[a,b]}(p(x)-(q(x)+E)*f(x)) <= 0, max_{x\in[a,b]}((q(x)-E)*f(x)-p(x)) <= 0 with some on-the-fly instantiation of active constraints for particular x values, then something resembling forward progress may be happening.
13:32:40 <Jeffrey_> @pl (\a -> f a && g a)
13:32:40 <lambdabot> liftM2 (&&) f g
13:32:55 <wli> min_{x\in[a,b]}q(x)=1 is still pretty nasty.
13:41:13 <ski> is there a better name for what <http://www.haskell.org/onlinereport/decls.html#sect4.4.3> calls `funlhs' ?
13:48:37 <ash__> function_left_hand_side?
13:56:11 <ash__> can you have an IO function thats recursive?
13:56:32 <ash__> i dont see why not, i just cant figure out how to write it
13:57:02 <Twey> ash__: Of course
13:57:09 <Twey> They're common, in fact
13:57:16 <luite> can you hpaste what you're trying to do?
13:57:28 <hpaste> ash__ pasted “Recrusive?” at http://hpaste.org/49117
13:57:32 <mikem1127> I'm just getting back into Haskell after a year away, and I need a brief reminder of how to import and export stuff from modules. My first question: is it correct that by default a module does not export any constructors?
13:57:34 <Twey> runProgram = do cmd <- getLine; if cmd == "quit" then return () else runProgram
13:57:55 <Twey> mikem1127: By default a module will export everything
13:58:08 <ash__> I basically want the brushFire program to call brushFire resultingField points (n+1)
13:58:24 <Twey> module ModuleName (name1, name2, DataType (Constructor1, Constructor2)) where …
13:58:31 <sanjoyd> What does (:.) do?
13:58:31 <ion> Is there a nice trick to get a certain specialized type of a polymorphic value, for instance the type of (<*>) when using the (->) a instance?
13:58:34 <sanjoyd> :t (:.)
13:58:35 <lambdabot> Not in scope: data constructor `:.'
13:58:37 <Twey> import ModuleName (name1, DataType (Constructor1))
13:58:56 <ash__> its from Data.Array.Repa for creating mutli-dimensional array indexes
13:59:03 <Twey> sanjoyd: Depends which (:.) you're talking about.  It has the form of an infix data constructor.
13:59:14 <Twey> Oh, that one.  'kay.
13:59:43 <mikem1127> Twey: will the import statement bring in the constructors by default?
13:59:48 <luite> ash__: replace "return resultingField" with "brushFire resultingfield obstacles (n+1) ?
13:59:53 <azaq23> :t (.:)
13:59:54 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
14:00:00 <luite> ash__: though you must make sure that it terminates somewhere
14:00:05 <ash__> Z :. (3 :: Int) is  a[3] in C kinda, Z :. (3 :: Int) :. (2 :: Int)  is a[2][3] in C
14:00:37 <ion> :t (<*>) (undefined :: a -> b -> c)  -- One can read it out of this easily enough.
14:00:38 <lambdabot> forall a a1 b. (a -> a1) -> a -> b
14:00:47 <copumpkin> ash__: omg REPA
14:00:52 <copumpkin> I was working on REPA in agda recently
14:00:56 <copumpkin> but the latest agda broked it :(
14:01:05 <ion> But it would have been nice to get (a -> b -> c) -> (a1 -> a) -> a1 -> b
14:01:43 <azaq23> sanjoyd: Do you mean .: in lambdabot instead of :.?
14:01:54 <Twey> mikem1127: It will if you leave out the bracketed section entirely
14:01:59 <ion> :t \(x :: a -> b -> c) -> (<*>) x
14:02:01 <lambdabot>     A pattern type signature cannot bind scoped type variables `a', `b', `c'
14:02:01 <lambdabot>       unless the pattern has a rigid type context
14:02:01 <lambdabot>     In the pattern: x :: a -> b -> c
14:02:11 <Twey> mikem1127: It's not considered good style to import everything from a module, though, in most cases
14:02:27 <Lymee> What's Twey doing here?
14:02:35 <ion> :t \(x :: forall a b c. a -> b -> c) -> (<*>) x
14:02:36 <lambdabot> forall a a1 b. (forall a2 b1 c. a2 -> b1 -> c) -> (a -> a1) -> a -> b
14:02:43 <dobblego> @type (<*>) :: (a -> b -> c) -> (a -> b) -> a -> c
14:02:44 <Twey> Lymee: The same thing I do every night, Pinky
14:02:44 <lambdabot> forall a b c. (a -> b -> c) -> (a -> b) -> a -> c
14:02:51 <akosch> could someone tell me what I'm doing wrong? http://hpaste.org/49118
14:03:00 <ion> dobblego: Without typing the entire type yourself. :-P
14:03:17 <akosch> hsc2hs tells me that lirc_code is undeclared
14:03:35 <ion> SomeCommand ((->) a) (<*>) would be optimal.
14:03:48 <akosch> there is a struct called lirc_code in the header, so I thought that's all I needed
14:04:06 <mikem1127> What is the syntax for a qualified import: is this right? import qualified ModuleName(name1,name2,DataName(Cons1)) as QualifiedName
14:04:27 <azaq23> @src (->) (<*>)
14:04:28 <lambdabot> (<*>) f g x = f x (g x)
14:04:39 <azaq23> @. djinn src (->) (<*>)
14:04:40 <lambdabot> Cannot parse command
14:04:47 <Peaker> Could be nice if type variables were canonized by lambdabot
14:04:49 <Twey> akosch: ITYM #{size lirc_code}
14:04:55 <Twey> Maybe… I don't really know the FFI very well
14:06:07 <akosch> Twey: thanks, I'll try
14:07:16 <akosch> Twey: still getting "hlirc.hsc:31:5: error: ‘lirc_code’ undeclared (first use in this function)"
14:08:12 <mikem1127> Twey: is it considered good style to import everything from a module is the import is qualified?
14:08:31 <Twey> mikem1127: Yes, that's okay
14:08:54 <Twey> The syntax is ‘import qualified ModuleName as ShortName’ where the ‘as ShortName’ part is optional
14:12:42 <molotir> is there a library of choice for simple geometric 3d vector manipulation?
14:14:31 <Jetbeard> molotir: rolling your own would be practically trivial
14:15:18 <Lymee> Do OpenGL and Haskell mix well?
14:15:23 <molotir> indeed.  just like leaning on libs when i can
14:15:40 <Jetbeard> Lymee: apparently they do (though i haven't any personal experience)
14:15:55 <Lymee> Do shaders, etc work as expected?
14:16:05 <Lymee> i.e. are they supported
14:16:14 <Jetbeard> as far as i'm aware the libraries are quite mature and complete
14:16:17 <Jetbeard> though don't quote me on that
14:16:19 <Lymee> Ok~
14:18:41 * copumpkin is trying to prove that with an associative operator, any reduction order on a non-empty vector is equivalent to foldr1 of the same operator on that vector
14:18:48 <copumpkin> pretty tricky :P
14:19:32 <Myself> hellor
14:19:43 <Myself> is there somebody here?
14:20:15 <Lymee> Can't wait for college and the result of majoring in Mathematics. Maybe I'll understand what people mean-- you know what, maybe I should just canvas Wikipedia.
14:21:03 <Botje> Myself: several somebodies, even
14:21:17 <Myself> yeah
14:21:36 <Myself> Im having some problems in making my first haskell program
14:21:52 <Myself> actually im trying to make a game
14:21:53 <Lymee> How well are people who majored in math usually seen when they try to apply for programming jobs?
14:22:12 <hpaste> “The Unpromised One” pasted “Jonathan C. Herron EXPOSED” at http://hpaste.org/49119
14:22:23 <Myself> i think it depends where
14:22:50 <Myself> probably its different being a mathematician in USA and in Brazil
14:23:33 <Lymee> US, or maybe UK depending on where the government heads in the US.
14:23:47 <Myself> yep
14:23:59 <Myself> Im from Brazil
14:24:00 <Myself> are you from UK?
14:24:20 <Lymee> US.
14:24:29 <Myself> ahh, nice
14:24:32 <Lymee> I might consider moving to the UK if things turn out poorly here.
14:24:42 <ash__> Lymee: if you want to be a programmer, i'd recommend doing computer science
14:24:50 <Myself> I would move to there if I had money
14:25:21 <ash__> although it ultimately depends on what you want to do
14:25:25 <Lymee> ash__, well, I would either major in mathematics or double major in both. I'm not sure if the latter would be too hard/busy for me.
14:25:25 <dmwit> copumpkin: Hm, interesting.
14:25:36 <Myself> but I think I woud prefer living in Taiwan, Cingapure or Hong Kong
14:25:36 <copumpkin> dmwit: it's kind of a nightmare
14:25:40 <dmwit> copumpkin: I guess it's probably easier to show that *any* reduction order is equivalent, then specialize to foldr1.
14:25:50 <copumpkin> dmwit: well, that's what I was doing first
14:25:56 <copumpkin> dmwit: but I think foldr would probably be easier
14:26:05 <copumpkin> foldr is a really easy to define reduction order
14:26:13 <copumpkin> I hav
14:26:14 <copumpkin> data Association : ℕ → Set where
14:26:15 <copumpkin>   leaf : Association 1
14:26:15 <copumpkin>   node : ∀ {m n} → (l : Association m) → (r : Association n) → Association (m + n)
14:26:27 <copumpkin> that represents my reductions
14:26:32 <dmwit> Seems like induction helps a lot more when there's no specific reduction order (a stronger induction hypothesis).
14:27:25 <copumpkin> I dunno, I was going crazy trying to do the more general case, since I had to case-analyze two different arbitrary Association values
14:27:27 <copumpkin>   associative-proof : ∀ {n} → (p q : Association n) → (xs : Vec Carrier n) → fold p _∙_ xs ≈ fold q _∙_ xs
14:27:31 <copumpkin> that's the proof I'm trying to write
14:27:47 <copumpkin> my current approach is to transitively show that both are equivalent to a right fold
14:27:54 <copumpkin> and are thus equivalent
14:27:58 * dmwit nods
14:28:28 <copumpkin> I kind of have to go fairly "deep" into the tree before associativity even comes into play, if you know what I mean
14:28:33 <dmwit> yes
14:28:35 <copumpkin> so doing that over two trees
14:28:44 <copumpkin> was causing me a world of pain in case splitting
14:28:49 <dmwit> My first guess at an Association type would simply have told which multiplication was done first.
14:28:58 <applicative> molotir: maybe http://hackage.haskell.org/package/vector-space or is that too abstract?
14:29:21 <copumpkin> dmwit: oh, so something less abstract?
14:29:50 <dmwit> e.g. (forgive my Agda) data Association where done : Association 1 | node : (m : Nat) -> (n : Nat) -> (m < n) -> Association n
14:29:54 <dmwit> copumpkin: yeah
14:29:59 <copumpkin> hmm
14:30:20 <dmwit> where "m" here is the index of the guy you're about to multiply by his next neighbor
14:30:25 <copumpkin> that seems tricky to work with
14:30:38 <copumpkin> looking stuff up in the list is another operation to throw into my goal
14:30:51 <dmwit> true
14:30:52 <copumpkin> it's also not really inductive
14:30:52 <dmwit> hm
14:31:07 <copumpkin> I can see something that refines based on a function
14:31:36 * copumpkin tries to concoct something like that
14:31:55 <dmwit> Yeah, it's a bit odd, isn't it?
14:32:02 <dmwit> Upside-down trees aren't really a thing.
14:32:44 <dmwit> I was just hoping there would be some kind of diamond property.
14:32:55 <dmwit> That's the usual trick for doing confluence.
14:32:57 <luite> are you proving it with agda?
14:33:38 <dmwit> copumpkin: Actually, yeah, this doesn't seem that bad, does it?
14:34:05 <dmwit> copumpkin: Induction was sort of a red herring. All you really need is that any two particular choices of first multiplication can be reconciled.
14:34:15 <dmwit> Which they can be, by merging all of the guys in between them.
14:34:29 <Myself> I don't know, cause I don't understand what you are speaking about
14:34:40 <Myself> XD
14:35:08 <copumpkin> hmm
14:35:10 <Myself> I'M just a newbie .-.
14:35:39 * copumpkin coughs
14:35:39 <copumpkin> data Association′ {a} {A : Set a} (_∙_ : A → A → A) : A → Set a where
14:35:40 <copumpkin>   leaf′  : ∀ x → Association′ _∙_ x
14:35:40 <copumpkin>   left′  : ∀ x y z → Association′ _∙_ x → Association′ _∙_ y → Association′ _∙_ z → Association′ _∙_ ((x ∙ y) ∙ z)
14:35:40 <copumpkin>   right′ : ∀ x y z → Association′ _∙_ x → Association′ _∙_ y → Association′ _∙_ z → Association′ _∙_ (x ∙ (y ∙ z))
14:35:42 <copumpkin> does that even make sense?
14:35:49 <copumpkin> I should probably not paste in here
14:36:00 <Myself> well
14:36:12 <Myself> i don't know what you mean by association
14:36:24 <Myself> and by the dot
14:36:52 <dmwit> copumpkin: reading
14:37:21 <Saizan> copumpkin: shouldn't you also index by the vector ?
14:37:30 <copumpkin> Saizan: this doesn't mention vectors
14:37:34 <copumpkin> it contains its own tree of values
14:37:59 * copumpkin tries to convert back and forth
14:37:59 <dmwit> Yeah, that looks pretty good, actually.
14:38:11 <copumpkin> actually
14:38:18 <dmwit> A bit odd that it's not inhabited by any two-element trees, though.
14:38:18 <copumpkin> it's tricky to convert back and forth
14:38:24 <copumpkin> yeah
14:38:32 <Saizan> i guess you can just pick the leafs
14:38:45 <Saizan> it's a finger-tree without the fingers
14:38:48 <copumpkin> dmwit: that disturbs me actually
14:38:59 <copumpkin> oh actually
14:39:02 <copumpkin> I can make it more modular
14:39:06 <copumpkin> wait, can I?
14:39:07 <copumpkin> gah!
14:39:09 <copumpkin> thinking is hard
14:39:11 * copumpkin goes shopping
14:39:44 <hpaste> int80_h pasted “data type question” at http://hpaste.org/49120
14:40:11 <copumpkin> dmwit: I'm reluctant to use the natural and < relation because I still think looking stuff up in the vector will require a lot of jumping through hoops
14:40:18 <copumpkin> I guess it's just Fin
14:40:21 <copumpkin> but still
14:40:38 <dmwit> Yes, I understand.
14:41:01 <dmwit> But surely there's some standard library for rewrite systems?
14:41:01 <copumpkin> oh actually
14:41:05 <copumpkin> this is overly complicated
14:41:34 <dmwit> int80_h: Eh, is that even valid?
14:41:49 <dmwit> int80_h: Can you actually make a new constructor named 180?
14:42:06 <copumpkin> I still have the issue of not indexing by the size of the tree
14:42:18 <dmwit> As for parsing, seems pretty straightforward: map (fromEnum . read) . lines
14:42:25 <wli> applicative: Is that vector-space package doing jets?
14:42:44 <int80_h> dmwit: I think I wrote it wrong, brb
14:43:09 <dmwit> int80_h: But don't derive Enum if you want specific Int's to correspond to specific constructors.
14:43:37 <akosch> I solved my issue if anyone is interested: http://hpaste.org/49121
14:43:50 <copumpkin> Saizan: AAAAAAAIIEEE
14:44:18 <Saizan> copumpkin: scream of victory or of pain?:D
14:44:21 <copumpkin> pain
14:44:24 <copumpkin> :(
14:44:35 <akosch> the problem was that in the header file I'm using all the structs are forward-declared (via the struct and not the typedef keyword)
14:44:52 <monochrom> preflex: seen chrisdone
14:44:53 <preflex>  chrisdone was last seen on #haskell 22 hours, 39 minutes and 11 seconds ago, saying: 1AM ♪ should go to bed but I can't resist writing mah haskell code ♫
14:45:05 <copumpkin> to : ∀ {n} {a} {A : Set a} → Association n → (_∙_ : A → A → A) → Vec A n → ∃ (Association′ _∙_ n)
14:45:06 <copumpkin> :(
14:45:18 <akosch> so to refer to the struct lirc_code, I needed "struct lirc_code" instead of just "lirc_code"... :/
14:46:09 <monochrom> @type unfoldr
14:46:10 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
14:47:15 <Lymee> @src unfoldr
14:47:16 <lambdabot> unfoldr f b  = case f b of
14:47:16 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
14:47:16 <lambdabot>    Nothing        -> []
14:48:23 <hpaste> int80_h annotated “data type question” with “data type question (annotation)” at http://hpaste.org/49120#a49122
14:48:47 <deech> Hi all, I noticed that the Haskell/Objective-C bindings (HOC) haven
14:48:52 <deech> 't been updated lately.
14:49:01 <deech> Are they stable enough to use?
14:49:07 <copumpkin> I wrote that function
14:49:11 <copumpkin> I wonder if it'll do me any good
14:49:12 <dmwit> data Step a v1 v2 = nil : a1 : a -> a2 : a -> v : Vec a n -> Step a (a1 :: a2 :: v) (a1 * a2 :: v) | cons : a1 : a -> Step a v1 v2 -> Step a (a1 :: v1) (a2 :: v2)
14:49:25 <monochrom> @tell chrisdone using your haskell json service, I can't load a module that uses intercalate or unfoldr ("not in scope"), even though evaluating an expressing that uses intercalate or unfoldr is fine. but I want to be able to load! :)
14:49:26 <lambdabot> Consider it noted.
14:49:34 <copumpkin> dmwit: good point, you just going to keep the vector in the index?
14:49:38 <wli> What's wrong with using the ordinary mutable arrays for matrices?
14:49:43 <copumpkin> instead of the number
14:49:48 <copumpkin> I guess that's cleaner than my existential
14:49:57 <dmwit> theorem. Step a v1 v2 -> Step a v1 v3 -> exists v4. Step a v2 v4 /\ Step a v3 v4
14:50:04 <int80_h> dmwit: fixed
14:50:06 <copumpkin> that's what Saizan was suggesting, too
14:50:13 <dmwit> ah
14:50:18 * copumpkin sighs
14:50:23 <dmwit> sorry =(
14:50:24 <copumpkin> oh no
14:50:32 <copumpkin> I was sighing at how complicated this all is :)
14:50:38 <copumpkin> BUT I SHALL OVERCOME
14:50:45 <copumpkin> THIS PROOF MUST BE DONE
14:50:53 <copumpkin> I want to move onto the commutative monoid one :P
14:50:58 <Saizan> (was i?)
14:51:04 <dmwit> int80_h: See my answer above, it's still the same answer.
14:51:18 <copumpkin> [05:45:50 PM] <Saizan> copumpkin: shouldn't you also index by the vector ?
14:52:48 <Saizan> ah yes, but i wasn't thinking of something shaped like Step, which looks interesting though
14:53:28 <int80_h> dmwit: don't derive Enum?
14:55:35 <copumpkin> to : ∀ {n} {a} {A : Set a} → Association n → (_∙_ : A → A → A) → (xs : Vec A n) → ∃ (Association′ _∙_ xs)
14:55:49 <int80_h> dmwit: The only way I can think of is pattern matching. I'll try that and see if it's sufficient.
14:55:59 * copumpkin thinks about dmwit's type
14:57:11 <dmwit> int80_h: Correct, define Enum yourself, then use (read . toEnum) for parsing.
14:57:12 <copumpkin> fucking types, how do they work
14:59:51 <copumpkin> so I can write to and from
15:00:20 <copumpkin> I might try working with this type and if I fail, I'll go to step
15:01:59 <NihilistDandy> Types are like magnets
15:02:14 <copumpkin> fucking magnets, how do they work
15:04:36 <NihilistDandy> <3
15:04:36 <copumpkin> amazing
15:04:47 <copumpkin> changing the definition of my fold function to use that type
15:04:49 <copumpkin> didn't break my proofs
15:05:09 <NihilistDandy> Sweet
15:05:36 <MatrixFrog> ok, this is a complete mindfuck
15:05:44 <MatrixFrog> fix f = f (fix f)
15:05:58 <copumpkin> MatrixFrog: yay!
15:06:07 <copumpkin> only works (usefully) in a lazy language :)
15:06:22 <MatrixFrog> i don't see what you would use it for
15:06:45 <copumpkin> all recursive functions can be written in terms of that
15:06:59 <MatrixFrog> @let fix f = f (fix f)
15:07:00 <lambdabot>  <local>:1:11:
15:07:00 <lambdabot>      Ambiguous occurrence `fix'
15:07:00 <lambdabot>      It could refer to either ...
15:07:11 <MatrixFrog> @let fx f = f (fx f)
15:07:12 <lambdabot>  Defined.
15:07:17 <MatrixFrog> @type fx
15:07:18 <lambdabot> forall t. (t -> t) -> t
15:07:48 <MatrixFrog> map fx [(+1), (+2), (+3)]
15:07:57 <MatrixFrog> > map fx [(+1), (+2), (+3)]
15:07:59 <lambdabot>   [*Exception: stack overflow
15:08:11 <MatrixFrog> ok let me stare at it a bit more
15:08:27 <aninhumer> Is that the Y combinator?
15:08:35 <c_wraith> give or take.
15:08:49 <c_wraith> > fix (0:)
15:08:50 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
15:09:47 <Saizan> same behaviour, different implementation
15:10:02 <Cale> It's a fixed point combinator. The Y combinator is a specific implementation of a fixed point combinator.
15:10:18 <NihilistDandy> The Y combinator proper can't be implemented in Haskell, if memory serves
15:10:28 <Cale> It can
15:10:33 <Cale> Just not naively.
15:10:39 <NihilistDandy> Ah, yes, that's it
15:10:41 <Cale> You need a recursive newtype
15:10:56 <c_wraith> infinite types carefully hidden behind newtype walls
15:12:49 <Cale> @type let y = \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x))) in y
15:12:50 <lambdabot> forall a. (a -> a) -> a
15:13:07 <Cale> > let y = \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x))) in y (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
15:13:09 <lambdabot>   3628800
15:15:36 <Cale> Apparently the Y combinator was actually discovered by Haskell Curry.
15:16:16 <Cale> > let y = \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x))) in y (1:)
15:16:18 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
15:16:40 <Cale> > let y = \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x))) in y ((0:) . scanl (+) 1)
15:16:42 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:17:05 <shachaf> > let y = \f -> (\x -> outR x x) (InR (\x -> f (outR x x))) in y (1:)
15:17:07 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
15:17:09 * hackagebot pandoc 1.8.1.2 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.8.1.2 (JohnMacFarlane)
15:18:11 <Cale> :t let y = \f -> (\x -> outR x x) (InR (\x -> f (outR x x))) in y
15:18:13 <lambdabot> forall a. (a -> a) -> a
15:18:32 <Cale> well, that's cute :)
15:19:02 <copumpkin> this type looks like it'll be easier to prove stuff about
15:19:08 <copumpkin> assuming I can massage it the right way
15:19:13 * _Ray_ uses the simpler, dumber fix f = f(fix f) xP
15:19:34 <Cale> fix f = x where x = f x  is more efficient
15:19:38 <_Ray_> right
15:19:57 * _Ray_ uses let x = f x in x, which should be the same?
15:20:04 <Cale> yeah
15:20:30 <Cale> where desugars into let anyway
15:20:32 <_Ray_> it's still pretty mindblowing that it works xD
15:21:01 <Cale> Well, if any recursive definitions work, then it should.
15:21:57 <shachaf> Cale: Even if only primitive recursive definitions work? :-)
15:22:08 <Cale> I guess some languages allow only recursive definitions of functions too.
15:22:20 <Cale> (and not arbitrary values)
15:33:03 <parcs> any way to encode a type-level equality function with type families? the obvious way doesn't work due to conflicting definitions
15:35:48 <MatrixFrog> yeah i'm completely stumped as to how this fix thing ever could be used
15:35:53 <MatrixFrog> the exercise in the book is this:
15:36:09 <MatrixFrog> remainder a b = if a<b then a else remainder (a-b) b
15:36:23 <MatrixFrog> rewrite that using fix so that it's not recursive
15:36:52 <MatrixFrog> so you write, i don't know, remainder a b = fix f where f = (something)
15:37:08 <MatrixFrog> so then remainder a b reduces to fix f, which reduces to f (fix f)
15:37:20 <parcs> with fix just remember the first parameter is always the function to itself
15:37:36 <MatrixFrog> so then f has to be such that you can calculate without evaluating the argument
15:37:51 <parcs> remainder a b = fix (\remainder a b -> ...)
15:38:01 <MatrixFrog> ok...
15:38:06 <parcs> its a fairly mechanical conversion
15:38:37 <hpc> whoa, it never occurred to me that you could do that with fix
15:38:45 <hpc> that's kind of obvious, in retrospect
15:38:56 <MatrixFrog> ok so f should be a function that takes a function as its first arg
15:39:08 <MatrixFrog> i know someone here could just tell me the answer but i'm trying to discover it on my own...
15:39:47 <NihilistDandy> MatrixFrog: What book is that?
15:39:54 <hpc> MatrixFrog: think about what parcs said
15:40:38 <MatrixFrog> http://plucky.cs.yale.edu/cs431/reading.htm
15:40:59 <MatrixFrog> exercise 5.3, page 77 if anyone wants to look at it
15:41:07 <aninhumer> Arrg Comic Sans
15:41:18 <MatrixFrog> i know. the book itself is a nice pdf though
15:42:02 <MatrixFrog> remainder a b = fix f where f :: (a -> a -> a) -> (a -> a -> a)
15:42:20 <MatrixFrog> in other words, if remainder :: T, then f :: T -> T
15:42:21 <NihilistDandy> aninhumer: Yeah, srsly
15:43:16 <aninhumer> MatrixFrog: I was going to give more advice (Having only just grasped it myself), but I'm not sure if you want it now?
15:43:36 <MatrixFrog> no i don't
15:43:50 <MatrixFrog> i'm puzzling away for now :) perhaps soon
15:46:57 <hpc> solved from parcs' advice
15:47:35 <hpc> now to actually understand it :P
15:47:46 <MatrixFrog> yeah i'm just going in circles here
15:48:10 <MatrixFrog> fix f = f (fix f)
15:48:25 <MatrixFrog> in other words fix f = x where x = f x
15:48:45 <Cale> A key to using fix is just to imagine that the -> in the lambda is an equality instead.
15:49:03 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
15:49:04 <lambdabot>   3628800
15:49:23 <Cale> > let fac n = if n == 0 then 1 else n * fac (n-1) in fac 10
15:49:24 <lambdabot>   3628800
15:49:38 <hpc> i see how it works now
15:49:41 <hpc> and it's awesome
15:49:55 <MatrixFrog> that doesn't really seem nonrecursive to me
15:50:08 <Cale> MatrixFrog: what doesn't?
15:50:21 <MatrixFrog> well, this one: let fac n = if n == 0 then 1 else n * fac (n-1) in fac 10
15:50:23 <MatrixFrog> is DEFINITELY not
15:50:29 <Cale> that's recursive
15:50:35 <MatrixFrog> right
15:50:38 <MatrixFrog> and this one: fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
15:50:40 <MatrixFrog> looks kind of the same
15:50:50 <Cale> the function we pass to fix is not recursive
15:51:15 <danharaj> :t fix
15:51:16 <lambdabot> forall a. (a -> a) -> a
15:51:21 <Cale> but we can pretend that it is, because it's the argument of fix
15:51:47 <hpc> MatrixFrog: suppose we define "func = fix $ \f x y -> ..."
15:51:48 <Cale> (and pretend that the function parameter is the name of the function and not a parameter)
15:52:00 <hpc> MatrixFrog: thanks to the magic of fix, f = fix $ \f x y -> ...
15:52:04 <hpc> or, f = func
15:52:12 <aninhumer> Probably depends on your definition of recursive
15:52:19 <hpc> but because it's a lambda parameter, you can use it inside the fix without being recursive
15:52:25 <hpc> sort of
15:53:52 <parcs> @type let fac n = if n == 0 then 1 else n * fac (n - 1) in fac
15:53:53 <lambdabot> forall a. (Num a) => a -> a
15:54:23 <parcs> @type fix :: a ~ (Int -> Int) => (a -> a) -> a
15:54:25 <lambdabot> ((Int -> Int) -> Int -> Int) -> Int -> Int
15:55:19 <parcs> so to define fac in terms of fix, you must match this type. study it :P
16:00:57 <MatrixFrog> ok i step-evaled through it and i see that it works
16:01:13 <MatrixFrog> interestingly enough, http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi can't do it
16:02:36 <MatrixFrog> so i was kind of right, the trick is you have an expression (fix f) that doesn't get fully evaluated
16:02:40 <MatrixFrog> where f is that big lambda
16:03:23 <MatrixFrog> it just turns into (f (fix f)) but then that's in an expression like (f (fix f) 6)
16:03:33 <MatrixFrog> so the (fix f) in the middle doesn't actually get evaluated
16:03:41 <aninhumer> Which only works with lazy semantics (or something else?)
16:04:07 <MatrixFrog> right, if it wasn't lazy you would get f (f (f (f ... f ( fix f ) ... )
16:04:13 <danharaj> You have to define fix differently for strict languages.
16:04:15 <danharaj> But you can define it.
16:04:47 <aninhumer> MatrixFrog: Also it could be defined: fix f x = f (fix f) x   I think?
16:05:25 <MatrixFrog> sure, and you just take away the x to make it (more) point free
16:05:44 <MatrixFrog> @pl fix
16:05:44 <lambdabot> fix
16:05:56 <danharaj> zing
16:06:06 <MatrixFrog> i knew that would happen as soon as i typed it
16:06:11 <aninhumer> what does @pl do?
16:06:18 <MatrixFrog> @pl fix f = f (fix f)
16:06:19 <lambdabot> fix = fix (ap id)
16:06:26 <MatrixFrog> @info ap
16:06:27 <lambdabot> ap
16:06:30 <MatrixFrog> thanks
16:06:34 <MatrixFrog> @type ap
16:06:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
16:06:47 <danharaj> pl gets rid of dummy variables by refactoring the input you give it.
16:06:59 <danharaj> @pl (\x f -> f x)
16:07:00 <lambdabot> flip id
16:07:06 <MatrixFrog> makes the expression "pointless"
16:07:15 <aninhumer> Cool
16:07:21 <MatrixFrog> i don't know what lambdabot means by (m :: * -> *)
16:07:29 <danharaj> That means m is a type constructor.
16:07:38 <mauke> MatrixFrog: ignore everything before "."
16:08:20 <MatrixFrog> @src ap
16:08:20 <lambdabot> ap = liftM2 id
16:08:45 * MatrixFrog wants to go back to making midi music now :-/
16:09:09 <ion> @tell mauke http://heh.fi/haskell/functors/#function-instance
16:09:10 <lambdabot> Consider it noted.
16:09:57 <mauke> @tell ion ok.
16:09:57 <lambdabot> Consider it noted.
16:11:11 <ion> Whoops, i missed your line above and thought you hadn’t spoken for quite a while. :-)
16:11:12 <lambdabot> ion: You have 1 new message. '/msg lambdabot @messages' to read it.
16:12:04 <aperrien> Hello?
16:12:14 <ciaranm> goodbye!
16:12:21 <aperrien> Heh
16:12:51 <ion> hello <|> bye
16:12:59 <aperrien> I'm new at Haskell, and I've run into a wierd problem
16:13:17 <ciaranm> try hitting it with a large stick
16:13:37 <ion> try hitting ciaranm with a large stick
16:13:37 <aperrien> I tried that, it just left dents on my monitor
16:14:48 <aperrien> I'm trying to subtract two expressions, and in one form I get an error, in the other form things just work
16:15:27 <ciaranm> what two expressions?
16:15:48 <aperrien> ( 31.096623610932426 - floor(1))
16:16:04 <aperrien> (sqrt (654^2 -426749) - 1)
16:16:24 <luite> :t floor
16:16:25 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
16:16:29 <mauke> and what's the problem?
16:16:32 <aperrien> The first one fails
16:16:39 <mauke> > 31.096623610932426 - floor(1)
16:16:40 <lambdabot>   Ambiguous type variable `a' in the constraints:
16:16:40 <lambdabot>    `GHC.Real.Fractional a'
16:16:40 <lambdabot> ...
16:16:47 <ion> > 31.096623610932426 - (fromIntegral . floor) 1
16:16:48 <mauke> indeed
16:16:49 <lambdabot>   30.096623610932426
16:16:53 <luite> aperrien: the result of floor is Integral, but that other number you entered isn't
16:16:53 <mauke> aperrien: what's the 'floor' doing there?
16:17:07 <MatrixFrog> @pl flip (.)
16:17:07 <lambdabot> flip (.)
16:17:14 <azaq23> :t (-)
16:17:15 <lambdabot> forall a. (Num a) => a -> a -> a
16:17:27 <mauke> > 31.096623610932426 - 1
16:17:28 <lambdabot>   30.096623610932426
16:17:33 <aperrien> I thought that Floats and Integrals were the same thing
16:17:55 <MatrixFrog> integral means like, integers
16:18:05 <mauke> no, they're pretty much opposites
16:18:21 <aperrien> The floor was part of another problem I was working on. The expression looked like this originally before I tried simplifying it:
16:18:22 <MatrixFrog> doesn't "flip (.)" have a name? I thought I saw that somewhere...
16:18:36 <ion> matrixfrog: (>>>)
16:18:43 <MatrixFrog> cool cool
16:18:44 <aperrien> (sqrt (654^2 -426749) - floor (sqrt(654^2 -426749)))
16:18:56 <ciaranm> one of the old books has flip (.) as <.< iirc
16:19:08 <MatrixFrog> :t (>>>)
16:19:09 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
16:19:26 <ion> > (<*>) (-) (fromIntegral . floor) (sqrt (654^2 - 426749))
16:19:28 <lambdabot>   9.662361093242566e-2
16:19:38 <aperrien> So I have to convert the Integral to a float before attempting the calculation?
16:19:39 <MatrixFrog> so many things, you think you know what type they are, but then it's actually something much fancier
16:19:56 <aperrien> Sorry, used to Python auto conversion, bad habit
16:19:56 <mauke> > properFraction (sqrt (654^2 - 426749))
16:19:57 <lambdabot>   (31,9.662361093242566e-2)
16:20:04 <mauke> why do that calculation at all?
16:20:18 <ion> matrixfrog: In this case, read “cat” as “(→)”.
16:20:47 <MatrixFrog> anyway that explains why i did: "@hoogle (a -> b) -> (b -> c) -> (a -> c)" and got (.) but not (>>>)
16:20:56 <mauke> > properFraction pi
16:20:57 <lambdabot>   (3,0.14159265358979312)
16:21:00 <aperrien> I'm learning Haskell by reading the book "Learn You a Haskell" and doing Project Euler exercises
16:21:35 <ciaranm> aperrien: you might find Real World Haskell useful too
16:21:54 <aperrien> I just ordered that from Amazon today
16:22:42 <aninhumer> aperrien: It's available online, if you can't wait :P
16:22:54 <wli> > let cf x = let (n, x') = properFraction x in if x' == 0 then [n] else n : cf (recip x') in take 10 $ cf pi
16:22:56 <lambdabot>   [3,7,15,1,292,1,1,1,2,1]
16:22:59 <ciaranm> LYAH struck me more as explaining some of how haskell works, whilst RWH expects you to pick it up by seeing stuff. they go fairly well together.
16:23:18 <aperrien> Anyway I'm working on exercise #4, I think. prime factorization
16:25:11 <Axman6> ciaranm: RWH is more aimed at people who have learnt haskell and are now looking for advice on being better haskell programmers imo
16:26:49 <aperrien> Working my way through Fermat Factorization, and that expression was what I was using to tell if an attempt had an integer root
16:27:40 <MatrixFrog> aperrien: the online edition of rwh is nice because of the comments
16:27:47 <aperrien> If you know of a simpler way to accomplish that I'm all ears (or eyes, here) I want to learn to use Haskell efficently
16:28:09 <aninhumer> MatrixFrog: I found them more distracting tbh, which is partly why I bought it
16:28:14 <aperrien> Ill check it out
16:28:34 <ciaranm> aperrien: you want to figure out if an integer is a perfect square?
16:28:50 <MatrixFrog> well i guess i would say, look at the comments if you get confused
16:28:57 <MatrixFrog> because they'll try to clarify.
16:29:05 <aperrien> I like the O'Reilly style, and I'm finding that I like the style in LYaH too
16:29:09 <MatrixFrog> if you're not confused, then the comments may just be filled with people being pedantic :P
16:29:36 <MatrixFrog> aperrien I also just found this on reddit: http://plucky.cs.yale.edu/cs431/reading.htm
16:29:38 <aninhumer> Probably, my problem is that I *like* pedantic discussion :P
16:29:44 <aperrien> ciaranm: Yes, trying to find out weather my test yields a perfect square
16:29:45 <MatrixFrog> still a WIP but it's great so far
16:30:37 <ciaranm> aperrien: http://stackoverflow.com/questions/2807686/whats-the-way-to-determine-if-an-int-is-a-perfect-square-in-haskell although none of the answers there seem to have picked up that you can do it without using fp at all
16:30:48 <aperrien> (sqrt (654^2 -426749) - floor (sqrt(654^2 -426749))) should yield 0 if 654 is a perfect square
16:31:15 <aperrien> What do you suggest?
16:32:25 <ciaranm> i have a sneaking suspicion that if i were awake i'd know a sneaky way of getting the nearest integer to the sqrt of an integer without doing fp
16:32:33 <ciaranm> pretty sure i've seen that somewhere...
16:33:41 <azaq23> aperrien: That strikes me as dangerous due to floating point inaccuracy
16:33:43 <azaq23> > 0.1
16:33:44 <lambdabot>   0.1
16:34:03 <MatrixFrog> well you could go through [1..] and get the lowest one x, such as that x**2 > n
16:34:28 <ciaranm> http://www.azillionmonkeys.com/qed/sqroot.html
16:36:19 <azaq23> > 1.1 + 1.1 + 1.1 == 3.3
16:36:21 <lambdabot>   False
16:37:17 * hackagebot blakesum 0.2 - The BLAKE SHA-3 candidate hashes, in Haskell  http://hackage.haskell.org/package/blakesum-0.2 (KevinCantu)
16:38:06 <aperrien> Looks like I lost connection for a bit
16:38:28 <killerswan> hey, so I have seen an error with Hackage's upload system...
16:38:46 <kyagrd> > 1.1 + 1.1 + 1.1
16:38:47 <lambdabot>   3.3000000000000003
16:38:48 <aperrien> ciaranm: Did you wake up enough to remember your algorithm, by chance?
16:38:57 <kyagrd> > 1.1 * 3
16:38:58 <lambdabot>   3.3000000000000003
16:39:10 <killerswan> when I do an upload, the page displays an error, even though the package is actually uploaded OK
16:39:12 <ciaranm> aperrien: http://www.azillionmonkeys.com/qed/sqroot.html
16:39:27 <kyagrd> floating points or so great :(
16:39:36 <kyagrd> s/or/are
16:39:37 <killerswan> "Internal Server Error"...  some sort of internal error or misconfiguration with Apache
16:40:16 <sbahra> thoughtpolice, I thought your nickname was familiar.
16:40:18 * hackagebot highlighting-kate 0.2.10 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.2.10 (JohnMacFarlane)
16:57:27 <MatrixFrog> there's no way to write a function that takes a list, and returns True if the list is finite, but False if it's infinite, is there?
16:57:38 <copumpkin> no
16:57:39 <MatrixFrog> it seems like it would be impossible
16:57:52 <ciaranm> in general it's not computable
16:58:33 <monochrom> it is possible if you don't impose a time limit
16:59:08 <Eduard_Munteanu> Doesn't it reduce to the halting problem?
16:59:13 <ciaranm> yes
16:59:38 <Eduard_Munteanu> The list could be the output (something) of a test program.
17:00:02 <ciaranm> the list could be the states of a test program
17:00:13 <copumpkin> thanks to self-referential values
17:00:23 <copumpkin> you could write a list that was infinite if the function claimed it was finite
17:00:28 <copumpkin> and finite if the function claimed it was infinite
17:00:56 <copumpkin> let xs = if isInfinite xs then [1] else repeat 1
17:00:59 <copumpkin> >_>
17:01:05 <monochrom> :)
17:01:10 <monochrom> \∩/
17:01:34 <Eduard_Munteanu> Is that a Bender emote? :P
17:01:56 <MatrixFrog> in that case, this is quite a tricky exercise i think
17:02:02 <MatrixFrog> 6.2 if anyone else is reading the same book
17:02:03 <monochrom> whereas \o/ is a human rejoicing, \∩/ is a robot rejoicing
17:02:03 <copumpkin> MatrixFrog: what is it?
17:02:08 <Eduard_Munteanu> Ah, heh.
17:02:16 <MatrixFrog> copumpkin: hard to explain without the context of the
17:02:21 <MatrixFrog> other stuff in the book
17:02:28 <ion> isInfinite is simple. isInfinite :: [a] -> Bool; isInfinite [] = False; isInfinite (_:xs) = isInfinite xs
17:02:34 <Eduard_Munteanu> \∩/ . o O (We did kill all humans!)
17:02:46 <MatrixFrog> you have m1 and m2, think of them as two melodies
17:03:00 <MatrixFrog> then a function cut which cuts off a melody after a certain amount of time
17:03:17 <monochrom> the robot rejoices because it successfully proves that the halting problem is unsolvable by humans \∩/
17:03:20 <MatrixFrog> m1 :=: m2 means the two melodies played in unison
17:03:39 <MatrixFrog> so then you have: m1 /=: m2 = cut (min (dur m1 )(dur m2 )) (m1 :=: m2 )
17:03:58 <MatrixFrog> so /=: means to play them in unison but stop when you get to the end of the shorter one
17:04:15 <MatrixFrog> the problem is, you can apply cut to an infinitely long melody
17:04:30 <MatrixFrog> but not /=: because the "min" expression will run forever
17:04:50 <MatrixFrog> so the exercise is: Deﬁne a version of (/=:) that shortens correctly when either one or the other of its arguments is inﬁnite in duration. Assume that it is not known ahead of time which one is inﬁnite
17:05:04 <copumpkin> MatrixFrog: that seems feasible
17:05:15 <copumpkin> > zip [1..10] [1..]
17:05:16 <lambdabot>   [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
17:05:21 <copumpkin> > zip [1..] [1..10]
17:05:23 <lambdabot>   [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
17:05:34 <copumpkin> no need to ask which is infinite
17:05:36 <MatrixFrog> right, that's what i'm thinking, is you have to go through them note by note
17:05:39 <copumpkin> just traverse them in lockstep
17:05:44 <Eduard_Munteanu> /=: even works when both are infinite
17:05:50 <copumpkin> so does zip
17:05:53 <Eduard_Munteanu> Yeah.
17:06:13 <MatrixFrog> that's tricky because one might have long notes and the other might have short notes
17:06:21 <MatrixFrog> and each of them might themselves be constructed with :=:
17:06:21 <ion> That’s not a problem.
17:06:50 <MatrixFrog> it's not a *problem*, it's just more thinking that i expected to do on a saturday
17:06:52 <MatrixFrog> :P
17:07:01 <monochrom> "as long as the shorter list" does not require a finiteness test
17:07:57 <monochrom> the psuedocode "if x,y are both finite then ... else if x is infinite then ... else ..." is silly
17:07:58 <Eduard_Munteanu> More specifically you don't care about the infinite case.
17:08:03 <ion> Traversing two infinite *ordered* lists with (timestamp, value) pairs, resulting in a merged list of (timestamp, value) pairs is simple.
17:08:21 <monochrom> silly as in unecessary case analysis
17:08:26 <Eduard_Munteanu> You just care if one of them ended.
17:08:39 <MatrixFrog> yeah. interesting
17:09:58 <platzhirsch> Any opinions on the book Real World Haskell?
17:10:18 <hpc> it's a good reference and an okay tutorial
17:11:14 <nus> MatrixFrog, so, your problem is writing 'min' in '(min (dur m1 )(dur m2 ))'?
17:11:40 <Eduard_Munteanu> No, it's writing /=: I guess
17:11:57 <MatrixFrog> you can't really use that min expression, i think
17:12:09 <nus> Eduard_Munteanu, he already seems to have it as a given
17:12:31 <MatrixFrog> the question is to write a new function which is similar to /=:
17:12:44 <MatrixFrog> i'm thinking of (//=:) as a good name
17:12:55 <copumpkin> this sounds fairly similar to merge
17:12:57 <copumpkin> on ordered lists
17:13:02 <monochrom> another example of silly case analysis: "if the MVar x never becomes empty, hang forever; otherwise, when the MVar x becomes empty, put 0 into x". it is equivalent to: "when the MVar x becomes empty, put 0 into x", and therefore one single line of code "putMVar x 0"
17:13:05 <copumpkin> @hackage data-ordlist
17:13:06 <lambdabot> http://hackage.haskell.org/package/data-ordlist
17:14:21 <monochrom> generally, "when X do S" already covers the infinite-never case
17:15:14 <ion> > let merge xs'@(x@(xT,_):xs) ys'@(y@(yT,_):ys) | xT <= yT = x:merge xs ys' | otherwise = y:merge xs' ys; merge xs@(_:_) [] = xs; merge [] ys@(_:_) = ys; merge [] [] = [] in take 20 . merge [(0,"foo"), (1, "bar"), (2, "baz"), (3, "quux")] $ map (flip (,) "y") [0,0.25..]
17:15:15 <monochrom> example: "will you go out with me?" "when hell freezes over"
17:15:16 <lambdabot>   [(0.0,"foo"),(0.0,"y"),(0.25,"y"),(0.5,"y"),(0.75,"y"),(1.0,"bar"),(1.0,"y"...
17:18:35 <ion> And handling durations instead of timestamps is a simple extension to that.
17:25:32 <dmwit> copumpkin: How's Agda treating you?
17:25:46 <copumpkin> dmwit: I'm thinking of killing functions in my indices
17:25:50 <copumpkin> 'sdeath
17:25:59 <copumpkin> might un-GADT it all, basically
17:26:00 <copumpkin> :P
17:26:04 <dmwit> ah
17:26:19 <copumpkin> the refined indices are wonderful in some cases
17:26:32 <copumpkin> but it's often a huge chore just to be able to pattern match on something because of them
17:27:16 <monochrom> http://perl.plover.com/classes/OOPSLA/samples/slide066.html :)
17:27:16 <dmwit> I felt enlightened a few weeks ago when somebody explained in detail the connection between List and Vec (List ~= exists n. Vec n) and how to use that connection to reuse proofs about one for the other.
17:27:35 <copumpkin> ah yes
17:27:45 <copumpkin> do you get how GADTs can be desugared to non-GADTs?
17:27:48 <copumpkin> even in haskell
17:27:53 <copumpkin> I started writing a blog post on it
17:27:56 <copumpkin> but then realized I had no blog
17:28:04 <dmwit> Yep. But you lose the nice connection between values and types.
17:28:09 <copumpkin> yeah :/
17:28:26 <copumpkin> what's amusing
17:28:41 <copumpkin> is that the mechanism for the desugared GADT-alike actually requires GADTs to be turned on in GHC
17:28:44 <copumpkin> even if you aren't using GADTs
17:34:19 <thoughtpolice> sbahra: hi! :)
17:34:27 <dolio> Are you sure?
17:34:40 <dolio> It might only require TypeFamilies and ExistentialQuantification.
17:34:52 <copumpkin> dolio: that's what I expected it to require
17:35:04 <copumpkin> but then when you actually go and try to do something with it, it asks for GADTs unexepctedly
17:35:13 <dolio> Huh.
17:35:13 <copumpkin> I was surprised
17:35:20 <copumpkin> let me throw something together to show it
17:37:44 <dolio> Oh, actually, there's nowhere to put the context without GADTs.
17:38:12 <copumpkin> it lets you stuff contexts in regular datatypes with just existential quantification
17:38:20 <dolio> You can only put one on an existentially quantified variable, maybe, but sometimes you want to put one on a parameter, and you can't do that without GADTs.
17:38:21 <copumpkin> you don't need the data ... where syntax
17:38:44 <dolio> Yes, but stuffing it inside requires GADTs, even without the syntax.
17:38:48 <copumpkin> yeah
17:38:50 <dolio> Because it's not H98 or whatever.
17:41:35 <ski> `data Foo a = a ~= Int => FooInt' ?
17:42:04 <dolio> I forget the exact syntax.
17:42:09 <dolio> It's something like that, though.
17:42:22 <dolio> Well, definitely not ~=
17:42:28 <dolio> But perhaps ~
17:42:32 <ski> er, s/~=/~/
17:42:45 <ski> (my hands auto-completed to `~=')
17:42:51 <dolio> Or 'data Foo a = C a => FooCon'
17:43:15 <dolio> Or, 'C a => FooCon a' maybe.
17:43:50 <dolio> Then when you match, it actually provides the constraint.
17:43:51 <ski> that would be strange if the idea is to get `FooCon :: forall a. C a => Foo a'
17:44:47 <dolio> That would be the first one.
17:45:10 <ski> yea
18:11:41 * edwardk waves hello.
18:11:42 <lambdabot> edwardk: You have 3 new messages. '/msg lambdabot @messages' to read them.
18:11:45 <edwardk> eep
18:12:28 <edwardk> preflex: xseen copumpkin
18:12:29 <preflex>  copumpkin was last seen on freenode/#haskell 33 minutes and 41 seconds ago, saying: yeah
18:12:33 <copumpkin> ohai
18:12:49 <edwardk> copumpkin: i can't make a common superclass since 90% of the time when you define one you define both
18:12:56 <edwardk> use Exp and Log to switch between
18:13:00 <edwardk> in general default to using Additive
18:13:04 <copumpkin> :/
18:13:26 <edwardk> since Additive is what you wind up extending to build a ring structure on top, and when you make a module it starts out as additive
18:13:55 <edwardk> plus Partitionable is defined for all values, but Factorable is considered undefined at zero.
18:14:21 <edwardk> as for Numeric vs. Algebra, Numeric is in the blessed namespaces from the namespace hierarchy plan
18:14:36 <copumpkin> ugh :P
18:14:44 <edwardk> and the other algebra packages have pissed all over algebra, so this way i'm off to one side if i ever want to link with HaskellForMaths, etc.
18:15:18 <edwardk> and the names of a lot of stuff are changing in 0.5.
18:15:34 <edwardk> as soon as i get all this geometric coalgebra machinery in
18:15:49 <edwardk> which should hopefully make ddarius really happy
18:15:54 <copumpkin> :)
18:16:51 <edwardk> i've even gone and implemented it efficiently, using debruijn multiplication for my metric space multiplications for geometric products, etc.
18:17:05 <copumpkin> cool
18:17:17 <copumpkin> so when you rewrite reducers
18:17:24 <copumpkin> they'll build on Additive monoids?
18:17:27 <edwardk> yeah
18:17:55 <copumpkin> would you be interested in rolling in the groupy ones if I find some interesting use cases
18:17:56 <copumpkin> ?
18:18:10 <edwardk> there is still a small chance that i'll make Additive drop the semigroup assumption and just be a magma, and use power associative and alternating as superclasses of a semigroup class
18:18:16 <edwardk> sure
18:18:42 <edwardk> the main reason i might drop the associativity assumption on additive is that that way i can roll in octonions and sedenions
18:18:42 <copumpkin> I'll fiddle with it and see if I can come up with anything
18:18:47 <copumpkin> ah, I see
18:19:03 <edwardk> of course then i have to weaken my algebras as well
18:19:58 <edwardk> but a power associative rig still lets me define fromNatural
18:21:06 <edwardk> i'm limiting my geometric algebra to eigenbases for the moment, which is a little annoying for the conformal case, but otherwise not a problem
18:21:56 <edwardk> one nice intermediate result is that working with geometric coalgebras i can deal with the infinite vector spaces just fine (well, 2^64 dimensional, as i cram it in a Word64)
18:22:11 <edwardk> its only in the geometric algebra case that i need to worry about the dimensionality of my space
18:22:32 <edwardk> so the geometric coalgebras work really nicely when i just want to define one euclidean basis that can be used as an any-dimensional space
18:22:53 <edwardk> and similarly one conformal basis that can be used as a conformal n-dimensional space as well
18:23:27 <edwardk> just pick a vector for a pseudo-scalar and work with left contraction modulo that and everything drops out
18:23:52 <copumpkin> by the way
18:24:35 <copumpkin> would it make sense to have a class Reducer a m => CommutativeReducer a m where um :: a -> m -> m
18:24:50 <copumpkin> where um would basically be one of cons and snoc that is more computationally pleasing
18:24:57 <copumpkin> since you don't care which
18:25:14 <copumpkin> and then you could have a sane reduce on Set using a CommutativeReducer
18:25:22 <edwardk> probably
18:25:39 <edwardk> most of the subclasses of additive make sense to enrich reducers
18:25:47 <edwardk> including all the ring structures
18:26:01 <copumpkin> I was mostly just wondering if it'd be worthwhile to actually add a method to CommutativeReducer
18:26:25 <copumpkin> since it'd be a duplicate of either flip snoc or cons
18:26:30 <edwardk> well, if you have a commutative reducer you could just define your own cons and snoc to both use the fast form
18:26:37 <copumpkin> but it would allow the instance writer to decide which of those two he prefers
18:26:45 <copumpkin> hmm, fair enough
18:27:22 <copumpkin> so class Reducer a m => CommutativeReducer a m -- nothing else
18:27:42 <edwardk> at which point CommutativeReducer if it exists at all is just an (Commutative m, a `Reducer` m)
18:28:07 <edwardk> since i've been avoiding naming anything that doesn't give me anything over its consituent classes
18:28:13 <edwardk> er constituent
18:28:29 <edwardk> e.g. i name Rig because Rig gives me fromNatural
18:28:42 <copumpkin> fair enough
18:28:49 <edwardk> but i may weaken that to PowerRig
18:28:57 <copumpkin> but then GroupReduer would have uncons and unsnoc
18:29:02 <edwardk> yep
18:29:16 <edwardk> since that one adds something, it'd get a name
18:29:51 <edwardk> also the reducers need to start from semigroups this time around, since Foldable1 and Traversable1 exist
18:30:04 * wli just needs to do nonconvex quadratically constrained quadratic programming.
18:30:05 <lambdabot> wli: You have 1 new message. '/msg lambdabot @messages' to read it.
18:30:05 <copumpkin> okay, I see
18:30:05 <copumpkin> ah yes
18:30:08 <copumpkin> that's nice
18:30:16 <copumpkin> so who gets the short name? :P
18:30:21 <edwardk> wli: always fun.
18:30:33 <copumpkin> Reducer a s is semigroups
18:30:33 <edwardk> copumpkin: given precedent that is probably Reducer1 ;)
18:30:38 <copumpkin> ack :P
18:30:52 <edwardk> and then the monoid one is just a Reducer
18:30:57 <wli> edwardk: More fun if I could actually get started.
18:31:14 <copumpkin> edwardk: you come up with any awesome names for group ones then ?:P
18:31:18 <edwardk> wli: only time i ever had to solve a nonconvex quadratic programming problem i cheated
18:31:24 <edwardk> GroupReducer ;)
18:31:28 * copumpkin cries
18:31:41 <edwardk> well, there are SemiringReducers, RigReducers, etc.
18:31:44 <edwardk> it'd get old fast
18:31:48 <edwardk> coming up with names
18:32:07 <edwardk> InvolutiveHopfAlgebraReducer anyone?
18:32:07 <copumpkin> yeah
18:33:32 <copumpkin> :)
18:34:53 <geheimdienst> > let reduce (_:x:xs) = toUpper x : xs in map reduce ["Semiring", "Rig", "InvolutiveHopfAlgebra"]
18:34:55 <lambdabot>   ["Emiring","Ig","NvolutiveHopfAlgebra"]
18:35:12 <wli> I can't get any of the multiple-precision floating point libs going, which is a problem.
18:36:45 <edwardk> i have yet to add Ig's to the library ;)
18:37:04 <edwardk> wli: mpfr and haskell don't work together at all
18:37:22 <wli> edwardk: That's a problem.
18:37:26 <edwardk> wli: with luck copumpkin and i can spend some time reworking my mpfr bindings at hac-phi
18:37:31 <gwern> augh, gitit takes forever to install because of highlighting-kate
18:37:49 <edwardk> wli: its on our todo list, we got half way through defining the custom primops needed for it, but then he went on vacation and we never got back to it
18:37:56 <gwern> just because of compilation time I may not even be able to see whether my patch to add a 'description:' field to the Gitit metadata works
18:38:13 <wli> HERA has issues, as do the rest.
18:38:33 <edwardk> wli: in general anything that builds on top of GMP will break
18:38:56 <dropdrive> If I'm on a page like http://hackage.haskell.org/package/cuda, where are the docs?  Do I need to download and read the sources?
18:39:01 <edwardk> i need to fix mpfr so i can use it for building taylor models which are one of my long term goals
18:39:18 <wli> edwardk: How long-term a project is this?
18:39:34 <copumpkin> the actual bindings should be pretty straightforward once we've worked out the skeleton bindings for a few operations
18:39:51 <copumpkin> it's just working through some Cmm issues and the fact that GHC's errors on cmm compilation are things like
18:39:55 <copumpkin> "There is an error"
18:40:13 <copumpkin> and at runtime, you just get crashes that gdb won't tell you anything about
18:40:45 <wli> Any interoperability things if I write things in anticipation of that eventually showing up?
18:41:13 <edwardk> wli: it has been off and on something i've worked on. until i ran into problems with mpfr it was fairly imminent, then it moved to the background because i didn't want to wrestle with those issues so much as i wanted to play with taylor models
18:41:43 <edwardk> wli: not terribly. there is a Numeric.Fixed module in a package of mine somewhere, one sec.
18:41:52 <copumpkin> I tend to have an "oooh shiny" attitude to programming
18:41:55 <edwardk> http://hackage.haskell.org/packages/archive/fixed-precision/0.3.0/doc/html/Numeric-Fixed.html
18:42:01 <copumpkin> where I go all out on one of my projects for a little while then lose interest for a bit
18:42:02 <edwardk> this is the api i plan to expose more or less
18:42:09 <copumpkin> and go after something else shiny
18:42:42 <edwardk> Fixed Up Double is an MPFR rounded numerical type with the same precision as a Double rounded up.
18:42:49 <geheimdienst> dropdrive: normally you can click the modules listed near the end of that page. this doesn't work if the package is very new (like, uploaded a few hours ago) or if there's build failures, as for the cuda package
18:42:59 <geheimdienst> ... at least that's what i assume
18:43:00 <edwardk> you can make other precisions as well
18:43:38 <edwardk> basically anything that has a Precision instance. hrmm, the precision member of Precision should be exposed
18:44:00 <geheimdienst> you can work around the "very new" issue by just reading docs of a slightly older version, but for cuda, the older versions seem to have build failures too
18:44:10 <edwardk> in the meantime you can use reflection to manually construct other precisions i suppose
18:44:22 <dropdrive> geheimdienst: Thanks!
18:44:52 <geheimdienst> you're welcome
18:45:11 <edwardk> wli: then once that works again, i'll need to rewrite my interval arithmetic library to use corrected rounding
18:45:26 <edwardk> wli: and then i can set taylor models on top of that
18:46:01 <edwardk> if you look far enough back the old intervals library had rounding mode support, but libm is under the thumb of drepper
18:46:10 <edwardk> and doesn't work under any other rounding mode
18:46:22 <edwardk> in fact it gives nigh rando answers
18:46:32 <edwardk> er random
18:49:07 <edwardk> copumpkin: adding power associative, but i think i'm only going to do it multiplicatively
18:49:35 <edwardk> trying to find the right place to slot it
18:50:14 <edwardk> hrmm i guess i need it both places
18:50:33 <edwardk> i need a power associative algebra for octonions
18:50:40 <edwardk> which means i need it multiplicatively
18:51:18 <edwardk> but i could also define a really weak structure over which fromNatural is defined, just not sure anything else interesting is defined there
18:51:32 <edwardk> and if i want to waste the time everywhere defining instances
18:54:11 <thoughtpolice> copumpkin: i think lots of people suffer from the 'ooo shinies'
18:54:39 <copumpkin> ooh shiny
19:02:43 <wli> I missed most of the mpfr discussion. Laptop locked up and I power cycled.
19:03:44 <wli> What do I need to do API-wise etc. to be ready for when mpfr lands?
19:03:48 <edwardk> tunes nef
19:03:51 <edwardk> er one sec
19:04:19 <geheimdienst> wli: here you go http://tunes.org/~nef/logs/haskell/11.07.16
19:04:21 <edwardk> http://tunes.org/~nef/logs/haskell/11.07.16 scroll to the bottom ;)
19:05:00 <edwardk> basically the api to fixed-precision should be more or less what you want
19:05:39 <edwardk> i need to add a bunch of methods, etc. and wire it up to working mpfr bindings basically
19:05:39 <edwardk> wow power associativity is really annoying to plumb through
19:05:48 <edwardk> i think i may give up on that as a side goal
19:05:54 <edwardk> too many classes wind up exploding
19:07:40 <wli> edwardk: Is it basically going to look like Num?
19:08:06 <edwardk> yeah
19:08:36 <edwardk> Fixed Up Double is a multiprecision floating point with the same precision as a double and rounding towards positive infinity
19:08:43 <wli> Okay, that's API enough to roll with, except maybe for the magnitude bits everyone has to add on to work around abs
19:09:20 <edwardk> well, abs and signum are well defined on floating points
19:09:28 <edwardk> so for once they don't get in the way
19:09:40 <edwardk> you can use Floating, etc. as well
19:09:55 <edwardk> it'll even give accurate answers to RealFloat
19:10:44 <wli> Real fields aren't the ones that present problems.
19:11:29 <edwardk> well, for anything else you'll need to use something more like my crazy algebra package on top ;)
19:11:54 <edwardk> complex numbers in there are coming along
19:12:09 <wli> The main thing missing for Complex is a magnitude operation.
19:12:13 <edwardk> i've been working on implementing better support for representable modules
19:12:42 <edwardk> @type Data.Complex.magnitude
19:12:43 <lambdabot> forall a. (RealFloat a) => Complex a -> a
19:12:45 <edwardk> ?
19:12:48 <copumpkin> wli: doesn't abs give that?
19:12:55 <copumpkin> oh no
19:13:13 <wli> The trick is when it has to work on either real or complex numbers.
19:14:06 <wli> Data.Complex.magnitude disallows reals, abs doesn't yield an Ord result on Complex.
19:14:41 <edwardk> yeah
19:14:50 <edwardk> but you can write up a 2 line class that does the right thing
19:15:05 <wli> So I always end up defining some one-method class that defines a magnitude-like method that delivers an Ord result.
19:15:06 <edwardk> in the algebra package both the reals and the complex numbers form a vector space over the reals
19:15:21 <edwardk> and you can use the inner product for that space
19:16:05 <edwardk> since both have eigenbases
19:16:23 <wli> Well, it was just an obvious example of an API I might end up rolling myself that is likely to already exist elsewhere.
19:16:43 <edwardk> another thing that works on both in algebra is conjugation
19:16:48 <edwardk> since both are involutive
19:17:22 <edwardk> Real because it is commutative, and every commutative ring is trivially involutive, and complex under conjugation
19:18:00 <edwardk> i have a long way to go before i start supporting any decent transcendental functions though
19:18:29 <edwardk> i need exp and log for vector spaces to support their use in versor interpolation in geometric algebra though
19:18:44 <edwardk> so i'll make them appear eventually i guess
19:18:53 <wli> Well, algebraic extensions of K(t) are already pretty involved.
19:19:06 <wli> (Rational function fields.)
19:19:18 <wli> edwardk: Is this going toward symbolic integration or something?
19:19:52 <edwardk> wli: exactly =)
19:19:57 <wli> It reminds me of stuff I saw in Bronstein's ISSAC98 survey paper.
19:20:07 <edwardk> wli: i have an automatic differentiation library. i want an automatic integrator as well
19:20:44 <wli> Ah, well...
19:21:30 <edwardk> and chebyshev-pade approximants make good interval approximations for use in integration, and i can use this stuff to generate tight closed forms from the terms of the taylor series my ad lib can spit out
19:22:02 <wli> Um, I mostly hear about subresultant affairs...
19:22:15 <edwardk> not sure i follow
19:22:37 <wli> I'll send the paper along, not that the references are easily traceable.
19:22:50 <edwardk> grabbed the bronstein one
19:22:53 <edwardk> just now
19:23:51 <wli> Yeah, I'm lagging.
19:24:21 <edwardk> yes, this looks almost exactly like what i'm aiming to do
19:24:36 <wli> There you go.
19:24:54 <wli> There are differential algebra ebooks floating around.
19:25:27 <edwardk> i'm relatively new in this space. i started down this road after a conversation with jacques carette
19:26:14 <wli> I never got a good enough grip on it to get an idea of what one has to do in terms of differential field extensions for Jacobian elliptic functions and/or elliptic integrals in terms of them.
19:26:16 <edwardk> i've done a lot of hacking around in the more limited 3-5d projective spaces of graphics, but not much in a more general setting
19:27:49 <edwardk> my knowledge peters out usually once Jacobi's name starts popping up ;)
19:28:02 <wli> Well, my emphasis in the differential algebra and symbolic integration setting was almost entirely around trying to figure out what one has to do to handle Jacobian elliptic functions.
19:28:21 <wli> And yielded no answers.
19:29:28 <edwardk> the current (unrelated) jacobi'ish concern i have is that the chebyshev polynomials are a particular kind of jacobi polynomial, and i don't have any intuition for the larger set of jacobi polynomials
19:36:39 * wli doesn't have very good insight into the Jacobi polynomials apart from the generic orthogonal polynomial affair.
19:37:06 <edwardk> thats all i've got as well ;)
20:12:48 * ski gets unconfused about the difference between a row type and a type record
20:13:16 <edwardk> there isn't much of a difference, a row type is basically a list of fields that are present/absent from a record
20:14:03 <ski> well, a type record can contain types having kinds other than `*'
20:15:38 <edwardk> typically a polymorphic row type is one where we have some class of constraints on the row type to say they exclude certain fields we want to be able to append to them, and we have a cons operation to bolt in a known-excluded field
20:16:00 <edwardk> usually restricted to the * case for the fields we're bolting on because they are going to be concrete
20:16:25 <ski> hm .. or maybe i'm confused anyway
20:16:41 <edwardk> something like: consField :: field name -> * -> rho -> rho — where rho is a kind like *
20:17:24 <edwardk> but that consField carries an implicit constraint that the rho type involved excludes the field in question
20:17:32 <ski>   ProdType : Star * Star -> Star
20:17:46 <ski>   ProdType (Int,Bool) : Star
20:19:20 <Nexxus> hello can someone please help me translate a sentence from dutch to english
20:19:21 <edwardk> here we use row types to describe tuples with named fields, and to describe database schemata, row types with disjoint union let us define joins on table schemata, etc.
20:19:41 <Nexxus> i am learning dutch and would like to understand each part
20:20:12 <ski> Nexxus : is the sentence related to the programming language Haskell ?
20:20:22 <Nexxus> yes
20:20:26 <edwardk> its a bit early for the dutch haskellers to be online no?
20:21:33 <ski>   RecordType {i = Int,b = Bool} : Star
20:21:59 <ski> so `RecordType' takes a record of types, all of which has kind `Star'
20:22:04 <ski> how to express that ?
20:22:59 <ski> (so `{i = 42,b = False}' would be an example value of type `RecordType {i = Int,b = Bool}')
20:25:02 <luite> edwardk: or a bit late to be still online
20:25:17 <luite> (like me)
20:25:28 <ski> (and `RecordType {i = Int,b = Bool}' could possibly be abbreviated as `{i : Int,b : Bool}')
20:25:42 <luite> notostraca: which sentence?
20:25:50 <luite> oh he's already gone
20:26:17 <ski> (s/he's still on the network, though ..)
20:26:30 <alpounet> edwardk, yeah, 5:35am here...
20:27:37 <ski> ok, so it seems i need to replace `rho'/`Row' with a kind of type records (which records which kind each type field in the record must have)
20:32:16 * ski wonders whether closed kind records would suffice ..
20:32:53 <ski> (s/kind records/record kinds/)
20:41:23 <edwardk> we've been kicking around a row type system here with some limited sub-superkinding, because we need to parameterize row types with whether or not they are row types that can be serialized to a database
20:41:45 <edwardk> and since we support disjoint union of row types, we can't just use typeclasses to figure that out
20:42:01 <edwardk> there is a confluence property that would have to be maintained across consing and unioning
20:42:13 <edwardk> that can't nicely be expressed without direct support
20:42:29 <ski> which can't be serialized ?
20:43:35 <edwardk> we use row types for lots of dictionary like purposes. e.g. Functor is a tuple containing a map method
20:43:52 <edwardk> i can't serialize that to a database though, so we have a subkind of * for stuff we can send to the database
20:44:35 <ski> hm .. instead of having a constraint for serializable types ?
20:45:06 <edwardk> lets call that #. then we let * and # have the same superkind, lets say %, and make a more general superkind, lets call it $, so that # is a subkind of * and % is a sub-superkind of $
20:45:22 <edwardk> then * -> * has superkind $, but * has superkind %
20:46:29 <edwardk> then rho :: % -> $ gives us a rho constructor which is parameterized on the subkind.
20:46:36 <ski> i don't follow. if `*' is a superkind of `#', where did `%' come from ?
20:46:54 <edwardk> sorry ambiguous wording
20:47:08 <edwardk> # is a subtype of *, # and * are both kinds
20:47:24 <edwardk> they have superkind %
20:47:32 <ski> i would s/subtype/subkind/ ..
20:47:47 <edwardk> but at that level both % and $ are superkinds, where there is a subsuperkinding relationship between % and $.
20:48:02 <ski>   #  :<  *  :<  %
20:48:04 <ski> ?
20:48:08 <edwardk> rho is only parameterized on the % primitive superkinds
20:49:38 <ski> by "% is a sub-superkind of $" do you mean `%' is a subkind of a superkind of `$' ?
20:49:41 <edwardk> # :< * ,    % :< $,   # : $, * : $, (->) :: $ -> $ -> $ at the kind level
20:50:01 <edwardk> er wait i flipped that
20:50:11 <edwardk> (not used to this notation but the notation we use doesn't paste well into irc)
20:50:37 <ski> (if you prefer, you can give alpha-numeric names to the kinds)
20:50:48 <edwardk> # :< *, both kinds, % :< $, both superkinds, 1 : Int : # : %
20:51:17 <edwardk> id : a -> a : * : %
20:51:52 <ski> i'm sorry, i don't understand what you mean by "both kinds" and "both superkinds" there
20:51:54 <edwardk> Maybe : * -> * : $
20:52:44 <edwardk> Just : a -> Maybe a : * : %
20:53:01 <edwardk> i mean that both # and * are kinds
20:53:08 <edwardk> and % and $ are both superkinds
20:53:15 <ski> ok
20:53:37 <edwardk> ghc has a limited subkinding relationship between #, *, ?, (#) and ??
20:53:44 <edwardk> * and # have a similar relationshio
20:53:45 * ski is tired, so can't as easily decipher informal things
20:53:48 <edwardk> er relationship
20:54:36 <edwardk> the difference is that the kinds both share the same representation in our setting, unlike how * and # have radically different representations in ghc
20:54:59 <ski> so `#' is the kind of types which are serializable ?
20:55:00 <lolmoneylol> Hey
20:55:18 <lolmoneylol> To all who helpped me earlier, I like haskell
20:55:24 <edwardk> we want to parameterize our row types such that rho can only take * or # but not more complex kinds like * -> *, so we need a subsuperkind to capture that distinction
20:55:26 <edwardk> exactly
20:55:29 <lolmoneylol> I can see where it would be usefull
20:55:41 <edwardk> lolmoneylol: happy to hear =)
20:56:04 <drbean> What's the point of: lookupWord db w = [ c | c <- db w ]
20:56:09 * ski got confused by edwardk using "superkind" as in `aValue : aType : aKind : aSuperKind' instead of as in `aSubKind :< aSuperKind'
20:56:27 <lolmoneylol> just gotta wrap my head around it.  Is "Real World Haskell" a good book to get a good grasp on the basics?
20:56:32 <djahandarie> Oh, hah, me too (ski) :p
20:56:39 <edwardk> foo : bar : baz : quux are being used to separate universe levels.
20:56:53 <ski> yeah, i managed to get that :)
20:56:54 <edwardk> the subkinding relationship is between * and # which are both at the level of baz there ;)
20:57:10 <djahandarie> I thought you were using that to say that bar and baz were both types of foo at first :p
20:57:11 <edwardk> any # can be used as a *
20:57:37 <edwardk> lolmoneylol: yeah realworldhaskell and lyah
20:57:39 <edwardk> @where lyah
20:57:39 <lambdabot> http://www.learnyouahaskell.com/
20:58:26 <ski> edwardk : yeah, but when you said "% :< $, both superkinds", you meant the "quux"es, instead of the partial order on the "baz"es)
20:58:32 <edwardk> yeah
20:58:37 <edwardk> i can see how that gets confusing =)
20:59:06 <edwardk> anyways the row types live at the level of * and #
20:59:24 <ski> hum ?
20:59:28 <lolmoneylol> lol
20:59:34 <lolmoneylol> that book looks "happy"
20:59:43 <ski> i thought they lived at the level of `Int', but had kinds at the level of `*'
20:59:44 <edwardk> but need to be parameterized on them, because the relation constructor only takes rows of #'s, but the tuple constructor can take rows of *'s
21:00:01 * ski is presumably still misinterpreting edwardk
21:00:51 <edwardk> the problem with type systems like this is the levels of things are 'off by two' so in a sense both interpretations are right ;)
21:01:14 <ski> drbean : it could just as well be `lookupWord db w = db w', or even `lookupWord = id', yes. the only thing the former versions give are more specific (not as general) types
21:01:51 <edwardk> effectively the type constructors look like: tuple :: rho * -> *, relation :: rho # -> *
21:02:13 <edwardk> though they get sugared a lot more than that
21:02:52 <ski> hm
21:03:24 <edwardk> until the relation case looks kinda like join :: [..a..b] -> [..b..c] -> [..a..b..c]
21:03:49 <ski> so `rho k' is the kind of row types with all field types having kind `k' ?
21:03:54 <edwardk> yep
21:04:47 <edwardk> and the relation constructor can only take rho types that are simple enough to only consist of stuff that can go into a database
21:04:57 <edwardk> ints, nullable doubles, etc.
21:05:12 <ski> but not relations ?
21:05:21 <edwardk> correct, because a relation has kind *
21:05:25 <edwardk> so you can't nest relations
21:05:42 <edwardk> since they model stuff that should be able to live in a database
21:05:49 * ski recalls seeing a paper about nested relations, somewhere
21:06:16 <edwardk> there are plenty of ways to generate them, unfortunately they don't live within our operational requirements of interacting with off the shelf databases ;)
21:06:33 * cmccann wonders why ghc-goals was apparently abandoned...
21:06:35 * ski nods solemnly
21:07:38 <edwardk> the main thing we use tuples for outside of the database plumbing is to model extensible modules. we pass around all our dictionaries as expandable tuples
21:08:12 <edwardk> so a functor is just a tuple that has a map field with the right impredicative type.
21:08:12 <ski> and polymorphic variants ?
21:08:23 <edwardk> we don't touch open variants
21:08:29 <edwardk> not needed to model the problem domain
21:09:12 <edwardk> MLPolyR has a pretty good story for them if we ever need them
21:09:48 <edwardk> heck, we don't even have pattern matching right now, just using scott encoding ;)
21:10:29 <ski> i'm pondering uncurrying things like `(* -> *) -> (* -> * -> *) -> (* -> *) -> *'
21:10:44 <edwardk> ?
21:11:07 <ski>   `data Exp exp pat decl = ...'-like stuff
21:11:30 <lolmoneylol> lol the guy who wrote learnyouahaskell had to be on a meth binge
21:11:37 <ski> i want to pass a record, or at least a tuple, of types, instead of passing them one by one, curried
21:11:49 <edwardk> ah
21:12:23 <edwardk> i suppose a row type could be extended to handle that case
21:12:54 <edwardk> we only limit to # and * now because we have no other consumers
21:13:35 <ski> yeah
21:15:53 <ski> so i was thinking that just like we could say `ProdType : Star * Star -> Star', giving `ProdType (Int,Bool) : Star', we could then maybe say a record type `{foo : Int,bar : Maybe}' really is `RecType {foo = Int,bar = Maybe}' where `{foo = Int,bar = Maybe}' is a type record, with kind `{foo : *,bar : * -> *}'
21:16:10 * wli fails to get anywhere with including multiple lhs2TeX-generated affairs into a single document.
21:16:50 <ski> hm, that got slightly broken, since `{foo : Int,bar : Maybe}' isn't a valid record type
21:17:35 <ski> the record type `{foo : Int,bar : Bool}' would really be `RecType {foo = Int,bar = Bool}' where `{foo = Int,bar = Bool}' has kind `{foo : Star,bar : Star}'
21:18:05 <edwardk> yeah we'd have more or less (| Foo : Int, Bar : Bool |) :: rho #
21:18:13 <ski> but `{foo = Int,bar = Maybe}' would also be a valid type record, with kind `{foo : Star,bar : Star -> Star}'
21:18:32 <edwardk> but (| Foo : Int, Bar: Maybe |)  would be ill-kinded in the system we use here
21:18:33 <ski> in my case `RecType' would require a type record where all the types had kind `Star'
21:18:45 <ski> but i suppose one could make it polymorphic, like your `rho'
21:19:33 * ski is not convinced yet this idea of having `RecType' take a record of types is sane
21:19:44 <edwardk> *nods*
21:20:18 <edwardk> basically the record of types desugars into a consing of fields onto a row type, where the result is associative, which complicates the hell out of unification
21:20:27 <edwardk> er s/associative/commutative
21:20:50 <ski> i need a way to notate the essential diagonal functor .. hm
21:21:42 <copumpkin> has anyone expressed block cipher modes of operation as folds before?
21:21:50 <copumpkin> you basically have a binary operation and a fold
21:22:03 <copumpkin> well, the binary operation is for combining blocks (usually xor)
21:22:39 <copumpkin> there seems to be some connection to recursion schemes
21:22:55 <copumpkin> it'd be interesting to see if you could figure out the inverse of the block mode automatically
21:22:59 <edwardk> copumpkin: not per se, but i have implemented block chaining modes polymorphically
21:23:10 <copumpkin> or if you could come up with a spec that gave you both ways automatically
21:23:29 <copumpkin> ah
21:25:16 <wli> Oh boy. The lhs2TeX docs say that precisely what I need to do is impossible.
21:25:48 <edwardk> what about modes like CTR where you don't really care too much about other blocks?
21:25:58 <copumpkin> zipWith ?
21:26:00 <wli> http://people.cs.uu.nl/andres/lhs2tex/Guide2-1.14.pdf <-- page 13 in the box labeled "WARNING"
21:26:03 <edwardk> wli: at least now you know you can stop beating your head against it
21:26:32 <wli> edwardk: Well, I can't, because the need to do it hasn't gone away.
21:26:47 <copumpkin> zipWith (\x y -> combine x (concat nonce y)) blocks [0..]
21:27:02 <wli> edwardk: Now it's gone into "desperate search for a workaround" mode.
21:27:10 <nihtml> @src combine
21:27:10 <lambdabot> Source not found. The more you drive -- the dumber you get.
21:27:15 <edwardk> lovely
21:27:18 <nihtml> :t combine
21:27:18 <lambdabot> Not in scope: `combine'
21:27:23 <copumpkin> nihtml: I just made it up
21:27:36 <edwardk> copumpkin: fair nuff
21:27:40 <nihtml> oh okay
21:28:21 <copumpkin> edwardk: it seems like most of them require the binary operation (combine, above) to be invertible, but no other requirements on it
21:28:29 <copumpkin> in xor case, I guess it's an involution
21:29:14 <copumpkin> maybe some of the more exotic block modes require associativity or something
21:29:23 * copumpkin thinks
21:30:08 <wli> The lhs2TeX guide is "kind" enough to mention a common need is impossible to satisfy without any hints as to how to work around that.
21:31:09 * wli has bumped into this before and doesn't remember what came of it.
21:36:21 <wli> Someone probably has an answer to this somewhere.
22:09:46 <wli> Okay, don't use a LaTeX file but a LaTeX-style literate Haskell file as the master file, %include the sub-modules like %include ModuleA.lhs into the master literate Haskell file, just run lhs2TeX once on the master literate Haskell file.
22:14:57 <wli> 5 hours before errands hit.
22:32:32 <nyingen> has Parsec been adapted to use Data.Text yet?
22:32:53 <edwardk> it is pretty easy to add a Stream instance for Data.Text
22:33:03 <edwardk> it isn't there because neither package depends on the other
22:33:11 <nyingen> I see
22:33:50 <nyingen> I want to write a quick (as in, quick to write) parser for a relatively simple record format. The inputs are Text objects, but I'm not sure what parsing lib to use
22:34:01 <nyingen> attoparsec-text? but it only supports strict Texts from what I read
22:34:48 <edwardk> import Data.Text (Text); import qualified Data.Text as Text; instance Monad m => Stream Text m Char where uncons = return Text.uncons
22:34:56 <edwardk> then you can use Parsec 3
22:35:01 <nyingen> wow, that is indeed easy
22:35:18 <edwardk> er return . Text.uncons
22:36:07 <nyingen> is that the only function that needs to be defined in the instance?
22:36:09 <edwardk> attoparsec only uses strict bytestrings or text in the case of attoparsec-text, but you drive it differently than parsec, because you supply it a function responsible for getting more text
22:36:11 <edwardk> yeah
22:36:15 <edwardk> http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Prim.html#t:Stream
22:36:20 <nyingen> gotcha
22:36:33 <edwardk> so either one would work
22:37:32 <nyingen> I'll try the Parsec 3 approach, since I've written a lot of Parsec parsers
22:37:41 <nyingen> though, apparently, not enough to know about this Stream trick :)
22:37:55 <edwardk> =)
22:37:59 <edwardk> it came about in parsec 3
22:38:10 <looopy> is Haskell a 'pure' functional language?
22:38:21 <looopy> or rather is there a such thing?
22:38:55 <kmc> sort of
22:38:59 <cmccann> I think you need to clearly define "pure", "functional", and "Haskell" in order to answer that
22:39:04 <nyingen> @protontorpedo
22:39:05 <lambdabot> can haskell be used to develop databases?
22:39:38 <kmc> Haskell is pure functional in the technical sense that function application and evaluation do not cause IO execution
22:39:46 <miyako> not a strictly coding related question, but I'm trying to install the jpeg package through cabal and it's erroring out, does anyone know off hand if there are dependencies or issues with the latest version of ghci that might cause that?
22:39:53 <kmc> (except for various things that break the rules)
22:40:05 <miyako> err ghc, not ghci, sorry
22:40:16 <kmc> this is often misunderstood as "Haskell has no side effects", "Haskell only supports the 'functional' paradigm", or "in Haskell everything is a function"
22:40:16 <cmccann> kmc, is there really anything in Haskell that breaks the rules, though? ;]
22:40:18 <kmc> none of which is true
22:40:50 * sanjoyd thought Haskell had no side effects.
22:41:08 <kmc> there are values in Haskell which represent effects
22:41:11 <kmc> arguably that makes them not "side"
22:41:22 <kmc> because it's their sole purpose
22:41:24 * cmccann quibbles over the difference between "Haskell" and "the language defined by code that GHC compiles"
22:41:38 <kmc> cmccann, which version of GHC? with which flags? ;)
22:41:53 <cmccann> kmc, exactly
22:42:11 <sanjoyd> kmc: yes, but withing Haskell, I can't "cause" any side effects, right? an IO String is just that - an IO String?
22:42:25 <cmccann> if you restrict things to a clearly defined idea of "Haskell" many things are simpler to talk about
22:42:57 <cmccann> i.e. what's specified in the Haskell report and nothing else
22:43:04 <Eduard_Munteanu> Shouldn't that read as "there are values in Haskell which represent transitions to states where 'side-effects' took place"?
22:43:04 <kmc> sanjoyd, yeah
22:43:34 <shachaf> sanjoyd: You can argue that that's true of any language, of course.
22:43:41 <kmc> i mean to contradict claims like "you can't write files from Haskell because it's a pure functional language"
22:43:48 <miyako> isn't it also important to point out that a truly pure functional language wouldn't be all that useful, since most non-trivial programs need to do IO at soem point?
22:43:59 <kmc> or even "if your problem involves writing files, Haskell is a bad choice"
22:44:14 <cmccann> a truly pure functional language would be good for little other than warming your CPU
22:44:33 <kmc> like it's claimed that relevance of Haskell to a problem is inversely proportional to the number of 'IO'-containing types
22:44:35 <sanjoyd> shachaf: no, not really - getchar() in C can return different character every time it is invoked. But getChar in HS will return the same IO Char, right?
22:44:36 <ion> I like a warm CPU in a cold winter morning.
22:44:37 <kmc> which is also wrong
22:44:52 <huangyi> Every language is a pure expression which evaluate to a syntax tree, only interpretation make side effects, haskell IO monad is not different from imperative language.
22:45:03 <shachaf> sanjoyd: &getchar will point to the same value every time you look at it. :-)
22:45:04 <sanjoyd> Of course, how you "chain" the IO Char makes all the difference.
22:45:17 <shachaf> And the string "getchar" will be the same string, too, if you're generating C.
22:45:24 <shachaf> You're relying on the RTS either way.
22:45:52 <sanjoyd> shachaf: but isn't there a difference between the syntactic entity and evaluating the entity semantically?
22:46:16 <sanjoyd> In C, if I evaluate "printf("x");" I get something on the screen.
22:46:35 <sanjoyd> In HS, when I evaluate putStrLn "foo", I get an IO String, and nothing on the screen.
22:46:55 <cmccann> kmc, as a rule of thumb criticisms of Haskell tend to be not even wrong unless coming from people who've already gone through a phase of ridiculous enthusiasm for it and come out the other side
22:47:11 <shachaf> sanjoyd: I don't think that main = do { x <- getChar; putChar x } is all *that* different from the C equivalent.
22:47:15 <Eduard_Munteanu> But execution exactly following evaluation would be feasible, no?
22:47:26 <cmccann> I don't think I've ever seen a complaint about Haskell from someone who'd spent less than a few months using it that wasn't mind-numbingly idiotic
22:47:35 <miyako> cmccann: I'm intrigued by your statement, I'm in the ridiculous enthusiasm phase, how long should I expect that to last? lol
22:47:44 <shachaf> "within C, you can't cause any side effects" is true, until the compiler/"RTS" gets involved.
22:47:53 <sanjoyd> shachaf: practically, no.
22:48:16 <cmccann> miyako, give it 4 months to a year maybe, depending on how much time you spent playing with Haskell :P
22:48:24 <kmc> yes, i do love the ridiculous enthusiasm stage
22:48:25 <Eduard_Munteanu> C's side-effects are implicit, e.g. they just happen.
22:48:29 <kmc> ah, to be young again, and also a robot
22:48:58 * shachaf likes to read that sentence as (ah, to be young again), and also (a robot)
22:49:03 <sanjoyd> shachaf: but I still think there is a difference between evaling "main" in C which returns an int, with the side effects already "done", and evaling "main" in HS, which returns an IO a.
22:49:07 <miyako> cmccann: I am disappoint.  I've been using haskell for about 4 or 5 months now, and maybe a month or so finally started to grok it and get to the point where I can make it do really great things
22:49:10 <Eduard_Munteanu> While in Haskell, they reflect upon the program state explicitly (through >>= and the actual action).
22:49:37 <shachaf> sanjoyd: Sure, there's a difference. Of course, "main" is just a static value until you "execute" it with the () operator. :-)
22:49:44 <cmccann> miyako, eventually you'll reach one of two final states: "familiarity breeds contempt" where Haskell seems like just an everyday tool (though everything else looks terrible in comparison), or the "reaching for the stars" mindset where you start seriously considering moving to Agda
22:50:37 <shachaf> cmccann: There are plenty of other possibilities.
22:50:49 <miyako> cmccann: right now I like to think of myself as a code warrior dual wielding C and haskell, both elegant weapons with different purposes :)
22:50:50 <cmccann> shachaf, yeah, though those seem the most common
22:51:00 <edwardk> cmccann: or you'll embrace it as having a pretty damn good power to weight ratio and stick to it
22:51:01 <ion> such as realizing what an awesome language PHP is and moving to it (and MySQL)
22:51:08 <shachaf> You could just grow tired of Haskell for whatever reason and go back to other languages that are more productive for the sort of thing you want to do.
22:51:36 <edwardk> i use haskell rather than agda because i like running the code i produce. ;)
22:51:38 <cmccann> ion, I was assuming massive cranial trauma wasn't involved, that obviously changes matters
22:52:02 <edwardk> cmccann: *spit take*
22:52:16 <Eduard_Munteanu> edwardk: it's also another kind of challenge I suppose, given the restricted expressivity
22:52:30 <luite> if you need to scale to facebook size you obviously need industrial strength tools like php
22:52:55 <cmccann> edwardk, and yeah, as much as it would be fun to have something Agda-like that was as practical as Haskell I don't know if that's on the horizon at this point :[
22:53:13 <miyako> except facebook had to write their own php->c++ compiler because PHP is terrible
22:53:23 * sanjoyd tries out Agda.
22:53:33 <miyako> you know you're working with a bad language when by comparison you look at C++ and think "well, this looks like a sane alternative"
22:55:19 <luite> miyako: they're only generating C++, not using it. it's not like any haskeller would consider the C output from -fvia-C to be a sane alternative to Haskell :p
22:57:40 * cmccann recalls looking the Haskell output from an Agda compiler at one point and that was definitely not a sane alternative to anything
22:57:48 <copumpkin> yeah, it isn't
22:58:43 <Eduard_Munteanu> *an* Agda compiler? :)
22:59:27 <djahandarie> There are multiple backends for Agda
22:59:32 <cmccann> yeah
22:59:43 <djahandarie> Though I think only one goes to Haskell? Not sure
23:00:25 <Eduard_Munteanu> AFAIK, there are only two backends (and the other one, Epic, doesn't go through Haskell), and one compiler.
23:01:14 <cmccann> ok, it was a while ago that I was looking at it, so don't recall the details
23:01:58 <cmccann> in other news probably have to give up on my mad scheme to use the GHC API to find the expected type for the context around a TH splice
23:02:09 <cmccann> turns out that loading the GHC API from a TH splice doesn't work very well
23:02:19 <cmccann> probably should have seen that coming I guess
23:04:21 <looopy> hmm, ok.  i'm looking for a functional language to start learning in a few more months.  i know some scala but i want to step outside of my comfort zone and go into something completely abnormal to me this winter.
23:05:16 <luite> haskell may be too mainstream for you then ;)
23:05:20 <cmccann> if you know any significant amount of scala I imagine your comfort zone is already pretty large
23:05:57 <copumpkin> looopy: #agda
23:06:23 <looopy> copumpkin: taking a look..that's a new one for me
23:06:47 <cmccann> looopy, it'll definitely be new and challenging :P
23:06:53 <Eduard_Munteanu> What, now if you know Scala, Haskell seems like a perfectly normal, down-to-earth language? :P
23:07:03 <shachaf> If you actually want to run the code you produce, Agda might not be right for you. :-)
23:07:11 <looopy> hah...i see
23:07:15 <looopy> hmm not quite what i'm looking for
23:07:22 <shachaf> (According to edwardk, at least.)
23:07:47 <cmccann> scala seems like kind of a dumping ground for a lot of concepts, enough overlap with Haskell to lose a lot of the novelty
23:07:59 <Eduard_Munteanu> Agda runs code (you can also run much stuff in the typechecker), though I'm not sure how efficient it is.
23:08:02 <looopy> Eduard_Munteanu: not at all...scala allows you to slide right back into OO programming which is what i do for the most part...at some point i want to put it down and choose something more constrictive
23:08:08 <Eduard_Munteanu> I think that's partly the reason for the Epic backend.
23:09:11 <looopy> then possibly take what i've learned and go back into scala..or well who knows...depends on what i want to do.  really i just want to...get my hands on a little of everything to see what's out there (new programmer with a lot of friends that are great coders)
23:09:21 <cmccann> looopy, well, if you're pretty steeped in OO maybe Haskell is a good place to start, since it's very much not OO
23:09:35 <shachaf> looopy: Haskell will probably force you into the FP mindset more than most other languages.
23:09:46 <cmccann> you can treat Haskell as an old-school procedural imperative language pretty easily, but OO not so much
23:10:15 <looopy> cmccann: yeah, what about erlang or...lisp?  i have land of lisp on my shelf to pick up at some point
23:10:22 <shachaf> cmccann: Not *that* easily.
23:11:07 <shachaf> looopy: Neither is as "pure" as Haskell, I'd say. Especially Common Lisp.
23:11:20 <shachaf> Scheme as in _The Little Schemer_ would possibly be good. :-)
23:11:30 <looopy> and erlang is just so damn ugly looking...
23:12:14 <cmccann> shachaf, not in the sense of sitting down and writing C in Haskell without learning anything about it, but there's few obstacles to letting that dominate the overall structure of a program
23:12:41 <shachaf> cmccann: Writing imperative-style code in Haskell tends to get very awkward, I think.
23:13:01 <cmccann> looopy, Scheme is very nice, I would certainly encourage that. I really enjoyed learning it
23:13:25 <cmccann> shachaf, how so?
23:13:40 <looopy> cmccann: isn't that what the knuth books use a lot?
23:14:50 <cmccann> shachaf, you may be picturing something different for what "imperative-style" means here, possibly
23:15:02 <shachaf> cmccann: Possibly. :-) What are you thinking of?
23:15:06 <cmccann> looopy, ...I don't think so?
23:15:35 <looopy> actually you're right.  MIX
23:15:38 <looopy> some assembly
23:15:43 <looopy> no matter..beyond me for now
23:15:53 <Eduard_Munteanu> MMIX?
23:16:20 <looopy> MMIX, yes
23:16:47 <Eduard_Munteanu> Well, I suppose learning x86(-64) assembly might be a bit more productive.
23:17:45 <cmccann> shachaf, just the sort of code that tends to rely heavily on sequential application, often in the IO monad, lots of tail-recursive loops, mixing logic in with the IO, etc.
23:18:28 <shachaf> cmccann: Sure.
23:18:33 <shachaf> I think porting any simple C program to Haskell mostly-verbatim would get ugly quickly, even if you know Haskell fairly well.
23:18:46 <cmccann> the number of expressions with the type "IO ()" is a good rough metric :P
23:18:54 <cmccann> yeah, porting C directly is not at all the same
23:19:10 <cmccann> mostly because C is painfully lacking in good procedural abstractions, ha ha.
23:19:13 <shachaf> do { x <- newIORef 0; whileM ((<10) <$> readIORef x) $ do { ... } } is just more awkward than { int x = 0; while (x < 10) { ... } }
23:19:23 <shachaf> And it doesn't compose well at all.
23:19:34 <looopy> lol i wonder..it's interesting to go back but not productive at all...as a new programmer, everything is so high level...which is great but at the same time it would be nice to know whats going on
23:20:04 <cmccann> yeah, that's more about C being a clumsy imperative language than anything else. Haskell not providing quick ways to write bad imperative code isn't really important :P
23:21:16 <cmccann> using mapM_ over a a list isn't really any less imperative, though
23:22:10 <cmccann> just more elegant
23:22:42 <shachaf> Maybe not, but I saying that Haskell in do-notation-IO-mode isn't awkward as an imperative language seems a stretch. Particularly when you compare to imperative languages more expressive than C.
23:23:09 <sebz> is there an irc channel for programming languages?
23:23:18 <shachaf> #esoteric
23:23:26 <cmccann> it's awkward as anything if you try to translate standard imperative idioms directly, yes
23:23:31 <shachaf> For all the programming languages worth knowing about.
23:23:42 <Eduard_Munteanu> Presumably, that's for esoteric programming languages.
23:23:50 <shachaf> Something like, I don't know, x['a'][0] = f(g(x)) + h(y['a'])
23:24:01 <sebz> shachaf: I mean PL theory, like LtU stuff
23:24:09 <shachaf> There's #ltu.
23:24:19 <Eduard_Munteanu> (so you'll see Brainfuck and LOLCode thrown around more often than C or Haskell, I suppose :D)
23:24:22 <shachaf> Not very busy, though.
23:24:42 <cmccann> Eduard_Munteanu, bah, Lazy K is better :[
23:24:56 * Eduard_Munteanu looks that up
23:25:10 <Eduard_Munteanu> I think there was a ##cs channel too
23:25:10 <shachaf> Strict K. Laziness is impracticval impractical for real-world applications.
23:25:35 <cmccann> Eduard_Munteanu, it's a lazy purely functional esoteric language, give or take :P
23:25:53 <shachaf> Take quite a lot.
23:25:55 <cmccann> where "functional" means "hope you like SK-combinators"
23:26:03 <Eduard_Munteanu> Hopefully it's not as lazy as "Whenever" or whatsitsname.
23:26:04 <shachaf> Give about as little possible.
23:26:21 <cmccann> no, it's pure and lazy in basically the same sense that Haskell is
23:26:30 <Eduard_Munteanu> Oh.
23:26:37 <Eduard_Munteanu> Just SKI calculus :)
23:27:02 <Eduard_Munteanu> In some ways, the functional equivalent of brainfuck, I guess.
23:27:06 <cmccann> I/O is done by treating an input stream as an arguments to the program-as-a-function and only evaluating it "on demand"
23:27:28 <cmccann> Eduard_Munteanu, brainfuck is to C as Lazy K is to Haskell
23:27:39 <cmccann> if you want the impure functional equivalent, that's Unlambda
23:28:33 <sebz> thanks
23:28:45 <cmccann> "Lazy K is a garbage-collected, referentially transparent functional programming language, with a simple stream-based I/O system. What distinguishes Lazy K from other such languages is its almost total lack of other features."
23:28:48 <cmccann> :]
23:28:53 <cmccann> it's entertaining
23:29:26 <shachaf> @where ops
23:29:27 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
23:29:36 <copumpkin> ?
23:29:50 --- mode: ChanServ set +o copumpkin
23:29:59 <shachaf> JigABoot was just kicked out of #math for spamming. I suppose I was being a bit preemptive there. :-)
23:29:59 --- mode: copumpkin set +b *!bddc374e@gateway/web/freenode/ip.189.220.55.78
23:29:59 --- kick: JigABoot was kicked by copumpkin (Your behavior is not conducive to the desired environment.)
23:30:07 <copumpkin> he just PMed me too
23:30:10 <shachaf> Oh.
23:30:11 --- mode: copumpkin set -o copumpkin
23:30:51 <DevHC> what a troll
23:31:24 <copumpkin> like totally
23:31:33 <DevHC> copumpkin, that is
23:34:59 <yitz> copumpkin++
23:36:31 <yitz> cmccann: lazy k doesn't have seq, so it
23:36:43 <yitz> 's a bit more problematic than haskell in its laziness
23:36:57 <Eduard_Munteanu> K-lining might be in order, otherwise he'll go from channel to channel.
23:37:45 <Eduard_Munteanu> marienz: ^
23:37:45 <cmccann> yitz, it is a language designed to be problematic, so yes
23:37:57 <yitz> cmccann: it also doesn't have pattern matching, so you can't even simulate seq
23:39:12 <cmccann> I'm not sure of what use seq would be in lazy K, though
23:39:17 <cmccann> something specific in mind?
23:41:52 <yitz> cmccann: well, for example, if you try to write an interactive program, it gets stuck. you can't force it to evaluate the prompt, so it never even gets close to accepting the input.
23:44:30 <cmccann> yitz, doesn't it have examples of simple interactive programs that work just fine, though?
23:46:39 <cmccann> accepting input shouldn't be a problem anyway, since I don't think there's any necessary relationship between the input and output streams
23:47:12 <cmccann> my impression is that it would just happily product output until something in the output stream depends on the value on something from the input stream
23:48:21 <applicative> It's not difficult to write interactive programs in Lazy K. However, you should be aware that doing so is, technically speaking, a sin.
23:49:21 <cmccann> yes, you're supposed to write non-interactive programs that (coincidentally) happen to be structured in a way that makes them behave usefully in interactive mode
23:55:57 <rprije> Anyone use shime? I was thinking of trying it out but the github repo for it seems to have disappeared.
