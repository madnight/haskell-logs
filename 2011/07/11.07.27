00:06:30 <accel> how do I take two lists A & B and say: "prepend them with 0's until the shorter is the same length as the longer?"
00:06:39 <accel> is it just mashing around with length ?
00:06:43 <accel> or is there something that's like zip
00:06:44 <c_wraith> prepend is harder than append.
00:06:46 <accel> but auto preprends 0
00:06:57 <c_wraith> because prepending requires knowing lengths
00:07:04 <c_wraith> appending is just a simultaneous walk through each.
00:07:08 <accel> prepend is faster than append, no?
00:07:16 <accel> i.e. 0:[1, 2, 3]
00:07:19 <accel> vs [1, 2, 3]:0
00:07:23 <minsa> I want to see foldr for its complete expression. I have seeen somebody uses ::Expr to do this.
00:07:30 <c_wraith> well, modulo the type error in the latter
00:07:35 <minsa> Can somebody show me how do do that ?
00:07:46 <c_wraith> > foldr f 0 [1..10] :: Expr
00:07:47 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 0)))))))))
00:08:01 <accel> alright, is there a way to append 0 until they're the same length?
00:08:17 <minsa> thnx c_wraith
00:09:19 <accel> is there a way to define a class Ring, then say "a class Field = all the operators of Ring + the "/" operator" ?
00:09:55 <minsa> let fib' = 1:1:ZipWith (+) fib' (tail fib')
00:10:03 <minsa> > let fib' = 1:1:ZipWith (+) fib' (tail fib')
00:10:04 <lambdabot>   not an expression: `let fib' = 1:1:ZipWith (+) fib' (tail fib')'
00:10:10 <minsa> > fib' = 1:1:ZipWith (+) fib' (tail fib')
00:10:10 <lambdabot>   <no location info>: parse error on input `='
00:10:24 <c_wraith> lambdabot isn't ghci
00:10:30 <minsa> ok.
00:10:31 <glguy> accel: you can say that     class Ring a => Field a where (/) :: a -> a -> a
00:10:35 <c_wraith> throw an "in" on the let, to get a real expression
00:10:46 <c_wraith> > let fib' = 1:1:ZipWith (+) fib' (tail fib') in fib'
00:10:47 <lambdabot>   Not in scope: data constructor `ZipWith'
00:10:49 <accel> shouldn't it be "class Field a => Ring a where ... " ?
00:10:53 <c_wraith> > let fib' = 1:1:zipWith (+) fib' (tail fib') in fib'
00:10:53 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
00:10:57 <accel> based on: http://www.haskell.org/ghc/docs/6.10.1/html/users_guide/type-class-extensions.html
00:10:58 <minsa> > let fib' = 1:1:ZipWith (+) fib' (tail fib') in take 5 fib'
00:10:58 <lambdabot>   Not in scope: data constructor `ZipWith'
00:11:12 <minsa> > let fib' = 1:1:zipWith (+) fib' (tail fib') in take 5 fib'
00:11:12 <lambdabot>   [1,1,2,3,5]
00:11:38 <minsa> > let fib' = 1:1:zipWith (+) fib' (tail fib') in take 5 fib' :: Expr
00:11:38 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
00:11:38 <lambdabot>         against inferred ...
00:12:03 * hackagebot Lucu 0.7.0.1 - HTTP Daemonic Library  http://hackage.haskell.org/package/Lucu-0.7.0.1 (MasatakeDaimon)
00:12:06 <minsa> c_wraith, I am trying to understand how the adding in that fib' definition happens
00:12:27 <Cale> accel: you don't need extensions for that
00:12:42 <Cale> accel: class (Ring a) => Field a where (/) :: a -> a -> a
00:12:54 <Cale> accel: See Num and Fractional
00:13:21 <c_wraith> minsa: I'm probably not able to help you out with this right now.  Too close to sleep to explain anything clearly
00:16:01 <glguy> > let fib' = 1:1:zipWith (+) fib' (tail fib') in take 5 fib' :: [Expr]
00:16:01 <lambdabot>   [1,1,1 + 1,1 + (1 + 1),1 + 1 + (1 + (1 + 1))]
00:16:08 <Cale> accel: As for your other question, the trouble with zip here is that it stops at the shorter of the two lists. I think I'd start out just doing it recursively.
00:16:16 <glguy> > let fib' = a:b:zipWith (+) fib' (tail fib') in fib' :: [Expr]
00:16:17 <lambdabot>   <no location info>: lexical error at character '\FS'
00:17:20 <Cale> > let f [] [] = []; f (x:xs) [] = (x,0) : f xs []; f [] (y:ys) = (0,y) : f [] ys; f (x:xs) (y:ys) = (x,y) : f xs ys in f [1..10] [11..17]
00:17:21 <lambdabot>   [(1,11),(2,12),(3,13),(4,14),(5,15),(6,16),(7,17),(8,0),(9,0),(10,0)]
00:19:56 <Cale> accel: of course, that can be generalised in various ways, but it's not terribly easy to compose using standard higher order functions (can be done, but I can't think of anything not awkward)
00:20:09 <Cale> of course...
00:20:16 <c_wraith> unfoldr and zip!
00:20:19 <c_wraith> (eww)
00:20:25 <Cale> c_wraith: how?
00:21:01 <c_wraith> oh, not zip
00:21:19 <c_wraith> just doing it with unfoldr would be awful.
00:21:31 <c_wraith> (I've yet to find a case where I felt unfoldr made anything clearer)
00:21:44 <Cale> > let f xs ys = take (max (length xs) (length ys)) (zip (xs ++ repeat 0) (ys ++ repeat 0)) in f [1..10] [11..17]
00:21:45 <lambdabot>   [(1,11),(2,12),(3,13),(4,14),(5,15),(6,16),(7,17),(8,0),(9,0),(10,0)]
00:21:49 <Cale> ^^ eww
00:22:07 <Cale> But maybe clearer than direct recursion.
00:22:14 <Cale> It's less lazy though
00:23:07 <minsa> thnx c_wraith and glguy
00:24:02 <Cale> hmm
00:24:26 <accel> import Data.Vector hiding (++) <-- how do I change so this so I can get Data.Vector.++ as V.++ ?
00:24:40 <Cale> hiding ((++)) surely
00:24:52 <edwardk> import qualified Data.Vector as V
00:25:11 <edwardk> then V.generate V.++ etc. all work
00:26:06 <accel> Cale: do you have some mutation in your eyeballs where syntatically invalid haskell code appear in blinking red?
00:26:14 <accel> if so, how did you acquire such a mutation?
00:26:16 <Cale> lol
00:26:26 <Cale> 10 years programming Haskell will do it
00:26:41 <Cale> Though I still miss things, to be honest
00:27:45 <c_wraith> the error message you get when you accidentally capitalize "module" at the start of a file is terrifyingly useless, by the way.
00:28:02 <c_wraith> And that's a mistake that's harder for me to see initially
00:28:18 <c_wraith> especially in someone else's code.
00:28:22 <Cale> Nobody expects the module declaration!
00:28:47 <c_wraith> GHC reports the error as "the module name did not match the expected module name"
00:29:00 <Cale> oh really? Awesome
00:29:07 <c_wraith> rather than something useful like "`Module' not expected there"
00:29:41 <mreh> "deleting source code"
00:29:46 <Cale> report bug
00:32:21 <aninhumer> hehe maybe you need a GHC hardmode, if there's a syntax error, it deletes the file :P
00:33:04 <aninhumer> extreme mode: deletes the directory, insane mode: deletes /
00:33:14 <accel> I recommend ghc brutal mode. If hlint complains, it does dd if=/dev/random of=/dev/sda1
00:33:36 <aninhumer> ooh that's even worse
00:34:05 <accel> after a "import qualified Prelude as P", how do I do a $ = P.$, Int = P.int ?
00:34:25 <frerich> ghc insanity mode could play "Dragosta din tei" by O-Zone everytime the compile fails.
00:34:55 <Cale> ($) = (P.$)
00:35:00 <Cale> type Int = P.Int
00:35:10 <Cale> Or just
00:35:17 <Cale> import Prelude (($), Int)
00:35:21 <Cale> separately
00:35:48 <accel> i can import more than once?
00:35:51 <Cale> yes
00:41:11 <accel> lol
00:41:16 <accel> I just made the module -> Module error
00:41:25 <accel> thankfully someone was just complainign about it here :-)
00:42:54 <mysteriouslight> I've just noted that Monad definition is "class Monad m where", it means that m might not be a functor. I am interested if monad can be implemented without fmap.
00:46:45 <Cale> mysteriouslight: That's a mistake
00:46:48 <Cale> mysteriouslight: but yes
00:47:12 <Cale> mysteriouslight: however, whenever there's an instance of Monad, you can write  instance Functor MyMonad where fmap = liftM
00:56:35 <accel> are imports required to form a directed acyclic graph? are loops not allowed?
00:56:38 <chenwl> SET autolog on
00:56:55 <accel> autolog turned on
00:57:07 <shachaf> SET accel off
00:57:22 <accel> acceleration set to 0; maintaining current velocity
00:57:29 <c_wraith> loops in imports are not allowed.
00:57:30 <mreh> > (,1) 2
00:57:31 <lambdabot>   Illegal tuple section: use -XTupleSections
00:57:39 <glguy> accel: http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/separate-compilation.html see 4.7.9. How to compile mutually recursive modules
00:57:41 <mreh> 6.12 ay
00:58:09 <mreh> > flip (,) 1 2
00:58:11 <lambdabot>   (2,1)
00:58:12 <Cale> accel: The standard allows an arbitrary graph, but it's awkward in GHC if you have cycles, you have to construct hs-boot files
00:58:27 <erus`> :type flip
00:58:27 <ion> accel: http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/separate-compilation.html#mutual-recursion
00:58:35 <mreh> :t flip
00:58:35 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
00:58:35 <ion> Whoops, glguy was faster.
00:58:37 <mreh> @type flip
00:58:38 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
00:58:51 <accel> glguy, Cale, ion : thanks
00:58:53 <azaq23> mysteriouslight: Additionally to Cale's comments, any monad can also be reformulated to use fmap and a function join :: Monad m => m (m a) -> m a so that x >>= f = join $ fmap f x
00:59:23 <erus`> :t (,)
00:59:24 <lambdabot> forall a b. a -> b -> (a, b)
00:59:44 <erus`> > (,) 1 2
00:59:44 <lambdabot>   (1,2)
00:59:51 <erus`> wow who knew...
01:00:02 <azaq23> :t (,,)
01:00:03 <lambdabot> forall a b c. a -> b -> c -> (a, b, c)
01:00:12 <mreh> i never worked out if that was sugar or a real operator
01:00:21 <mreh> > 1 , 2
01:00:21 <lambdabot>   <no location info>: parse error on input `,'
01:00:23 <erus`> > 1, 2
01:00:24 <lambdabot>   <no location info>: parse error on input `,'
01:00:25 <mreh> sugar
01:00:37 <erus`> why does it need the brackets?
01:00:38 <ion> Yeah, the Monad class should probably be: class Pointed f => Monad f where { x >>= f = join (f <$> m); join x = x >>= id }
01:00:44 <Cale> http://static.springsource.org/spring/docs/2.5.x/api/org/springframework/aop/framework/AbstractSingletonProxyFactoryBean.html -- ROFL
01:00:53 <erus`> i guess so it knows its a tuple not a list
01:01:06 <shachaf> ion: Why Pointed and not Applicative?
01:01:13 <aninhumer> maybe it's a normal function, but the lexer pulls it out of the way?
01:01:15 <erus`> Cale: reddit?
01:01:15 <mreh> erus`: haskell operators can be turned into a prefix function by putting them in brackets
01:01:18 <Cale> "Convenient proxy factory bean superclass for proxy factory beans that create only singletons."
01:01:18 <Cale> yeah
01:01:25 <aninhumer> referring to (,)
01:01:36 <quicksilver> omg it's a glguy!
01:01:38 <erus`> mreh: no i mean why cant i init a list like 1,2,3
01:01:46 <shachaf> preflex_: seen emertens
01:01:46 <preflex_>  Sorry, I haven't seen emertens
01:02:09 <aninhumer> > 1 ,, 2 3
01:02:09 <lambdabot>   <no location info>: parse error on input `,'
01:02:22 <ion> shachaf: Perhaps you want to implement Applicative in terms of Monad for your type, and anything in the Monad class doesn’t implicitly depend on Applicative, whereas it does on Functor and Pointed.
01:02:29 <quicksilver> erus`: there isn't really a sensible type you could give to , to make 1,2,3,4,5,6 work with a binop ,
01:03:16 <erus`> true
01:03:19 <mreh> the problem is that use of , makes tuples and lists overlap
01:03:53 <quicksilver> I'm not sure that's the *only* problem, but it's certainly one of them ;)
01:04:01 <shachaf> ion: You can implement Applicative in terms of Monad even if Applicative is a superclass, no?
01:04:10 <quicksilver> ,,,,,,,,, is an n-ary operator, it's not a composition of binary operators in any systematic way
01:04:47 <shachaf> ion: Anyway, putting both Applicative and Monad constraints on something is annoying.
01:05:18 <mreh> @pl (\c -> flip (,) id c <$> return c)
01:05:18 <lambdabot> ap ((<$>) . flip (,) id) return
01:05:22 <mreh> nice
01:05:36 <shachaf> mreh: ?
01:05:39 <aninhumer> I just did let (,,) a b c = (a,b,c) in ghci and it worked, perhaps the lexer sees "(," and parses a function?
01:06:00 <Cale> erus`: you end up with the problem of whether [1,2] has 1 or 2 elements
01:06:02 <shachaf> > let (,,) a b c = 5 in (,,) 1 2 3
01:06:03 <lambdabot>   (1,2,3)
01:06:09 <drbean> :t (,,,,,,,,,)
01:06:10 <lambdabot> forall a b c d e f g h i j. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> (a, b, c, d, e, f, g, h, i, j)
01:06:15 <mreh> shachaf: i'm just practicing my golf
01:06:30 <quicksilver> aninhumer: (,,) is the constructor for 3-tuples
01:06:34 <mreh> on a compiler that doesn't do tuple sections
01:06:35 <shachaf> mreh: I don't see how "flip (,) id c" could ever be considered golf.
01:06:45 <mreh> shachaf: it's a placeholder function
01:06:46 <azaq23> aninhumer: (,) is just a function, and the normal characters that may appear in a operator can be in there
01:06:53 <mreh> a pure function in place of another
01:07:04 <shachaf> azaq23: No, (,) is a special case.
01:07:35 <quicksilver> in the syntax aninhumer used it's critical that it's a constructor, not a function name
01:07:44 <mreh> give up a use scheme :)
01:07:49 <quicksilver> that wasn't defining (,,), it was defining a b and c
01:07:56 <aninhumer> oh I see
01:07:57 <Cale> commas and parens aren't normally allowed in the names of functions, except in tuple constructors
01:08:15 <azaq23> > let (,) x = x in (,) 42
01:08:16 <lambdabot>   Constructor `(,)' should have 2 arguments, but has been given 1
01:08:26 <azaq23> shachaf: Totally didn't expect that
01:08:40 <aninhumer> yeah just tried (>,,)
01:08:45 <aninhumer> doesn't work
01:08:46 <quicksilver> azaq23: it's a constructor, as I keep saying.
01:08:55 <shachaf> You should listen to quicksilver.
01:09:01 <quicksilver> that's the same error you'd get from any binary constructor
01:09:23 <quicksilver> data Pair a b = Pair a b; -- and then try "let Pair x = x in Pair 42"
01:09:39 <erus`> i want a language with no syntactical sugar :)
01:09:45 <erus`> not lisp though
01:09:45 <quicksilver> it's special only in a lexical sense.
01:09:57 <quicksilver> it's special because it contains () and , which is not normal from a constructor
01:09:58 <mreh> > sequence (Just 1, Just 2)
01:09:59 <lambdabot>   Couldn't match expected type `[m a]'
01:09:59 <lambdabot>         against inferred type `(Data.M...
01:10:08 <quicksilver> btu once you look pass the lexical syntax, it's regular.
01:10:08 <mreh> what?
01:10:09 <aninhumer> erus`: machine code
01:10:16 <quicksilver> > sequence [Just 1, Just 2]
01:10:17 <lambdabot>   Just [1,2]
01:10:20 <erus`> functional machine code
01:10:34 <aninhumer> lisp machine machine code?
01:10:45 <aninhumer> I don't know how those worked differently
01:12:09 <azaq23> quicksilver: Ah, I see - I thought (,) would be just another operator name, which happened to be defined in Prelude as (,) a b = (a, b), but now I get it thanks
01:12:12 <mreh> > sequenceA (Just 1, Just2)
01:12:12 <lambdabot>   Not in scope: `sequenceA'Not in scope: data constructor `Just2'
01:12:18 <mreh> fail
01:12:25 <aninhumer> Oh just a stack machine, everything else was OS by the sound of it
01:12:37 <mysteriouslight> azaq23: monad is a functor equipped with two natural transformation. First one is return, second one is join. (x >>= f = join $ fmap f x) can be used as definition of (>>=). I'm confused that Monad requires natural transformation but does not requir to be a functor.
01:14:28 <aninhumer> quicksilver: how does (,,) being a constructor make it work though? something like let Just a = 5 obviously doesn't
01:14:46 <ion> shachaf: Sorry, brainfart. You can indeed use >>= in the implementation of <*> even if the Monad class depends on Applicative.
01:14:46 <quicksilver> > let Just a = Just 5 in a
01:14:47 <lambdabot>   5
01:15:08 <Cale> mysteriouslight: Well,  fmap f x = x >>= (return . f)
01:15:10 <mreh> screwy
01:15:16 <Cale> mysteriouslight: So you can go either way
01:15:18 <quicksilver> aninhumer: not entirely sure I understand you :) This is a fundamental way of unpacking structures; using let or case.
01:15:45 <erus`> how can i read stdin line by line until EOF?
01:15:48 <azaq23> mysteriouslight: Apparently it is a mistake that the monad typeclass doesn't require a Functor constraint; any monad is trivially a functor if you define fmap f x = do { x0 <- x; return $ f x }. There are alternative preludes which try to rectify this mistake and which do have a functor constraint. But any monad is a functor yes
01:15:49 <quicksilver> let (a,b) = function_returning_tuple in ... do stuff with a and b ....
01:15:57 <mreh> erus' getContents
01:16:09 <aninhumer> quicksilver: Ah yes, I was thinking of it as a function def
01:16:47 <quicksilver> aninhumer: and that it precisely the different between a constructor and a function, on the left of a pattern.
01:16:54 <erus`> mreh i need like getLine but i need to know if its eof
01:17:03 <hirsch__> I'm experimenting with Data.Array.Repa, what's the correct way to access elements of Shapes? There's a listOfShape function, but it reverses the dimensions and looks like a hack to access the elements with !!
01:17:15 <quicksilver> aninhumer: a normal name on the left defines a value (including possibly a function); a constructor on the left matches and then defines the fields.
01:17:51 <quicksilver> aninhumer: you can of course do both - let Just f = Just (\x -> x + 1) - is an obscure way to define the function f.
01:18:08 <aninhumer> so let (,,) a b c = (a,b,c) === a=a b=b c=c
01:22:52 <mreh> @hoogle eof
01:22:52 <lambdabot> Text.Parsec.Combinator eof :: (Stream s m t, Show t) => ParsecT s u m ()
01:22:52 <lambdabot> Text.ParserCombinators.Parsec.Combinator eof :: (Stream s m t, Show t) => ParsecT s u m ()
01:22:52 <lambdabot> Text.Read EOF :: Lexeme
01:23:02 <mreh> http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#v:isEOF
01:24:50 <azaq23> > let (,,) a b c = 52 + 42; (x, y, z) = 42 + 8 in ((a, b, c), (x, y, z))
01:24:50 <lambdabot>   ((94,94,94),(50,50,50))
01:26:52 <accel> how do I recommend that my code (http://hpaste.org/49572) be included in Prelude?
01:27:03 <accel> I am wiling to release it under the GPL license for the sake of the rest of the ahskell community
01:27:17 <Cale> GPL would preclude it from going in ;)
01:27:34 <Cale> GHC and most other Haskell compilers are BSD licensed
01:27:38 <maurer_> accel: What you're looking for is BSD3
01:27:41 <accel> okay; I will release it BSD3
01:28:01 <maurer_> accel: Also, you might want to try putting it in Data.List instead.
01:28:16 <maurer_> The Prelude itself is governed by the Haskell Report, so you'd need to submit to Haskell' to get it in there.
01:28:16 <luite> whoah 6 hlint warnings. 4 is the maximum for new Prelude proposals ;)
01:28:24 <Cale> also, put the id argument next to op
01:28:25 <ion> luite: :-)
01:28:34 <ion> Also, id shadows, well, id.
01:28:37 <maurer_> And Haskell' will likely ask you why not just put it in Data.List (as that's really where it goes)
01:29:21 <maurer_> Perhaps even Data.List.Extras
01:30:01 <maurer_> e.g. submitting it to these guys: http://hackage.haskell.org/package/list-extras may be your best move
01:30:40 <accel> http://hpaste.org/49574 <-- here we go, any more changes ?
01:31:07 <arcatan> what does it do?
01:31:35 <mreh> > liftA2 (liftM2 (flip (,))) (return) (return) 1
01:31:36 <lambdabot>   No instance for (GHC.Show.Show (m (a2, a2)))
01:31:36 <lambdabot>    arising from a use of `M285...
01:31:36 <maurer_> accel: You are still binding over id
01:31:54 <mreh> any easier way of expressing that pattern?
01:31:57 <maurer_> arcatan: It does the same thing a zip, except if one list is shorter, it continues.
01:32:12 <mreh> i want to improve my handicap
01:32:38 <ion> accel: I’d use xs and ys instead of lst1 and lst2. I’d also use ‘where’ instead of ‘let...in’ in this specific case.
01:33:07 <accel> maurer_: what do you mean "binding over id" ?
01:33:37 <maurer_> @let longZip f i xs ys = take (min (length xs) (length ys)) $ zip f (xs ++ (repeat i)) (ys ++ (repeat i))
01:33:37 <lambdabot>  <local>:1:57:
01:33:37 <lambdabot>      Couldn't match expected type `[a] -> [a1]'
01:33:37 <lambdabot>             ag...
01:33:45 <maurer_> accel: id is a function in prelude
01:33:57 <maurer_> Therefor binding it as one of your artuments is considered poor form
01:34:35 <ion> accel: longZip op z = go where { go xs@[] [] = xs; go xs@[] (y:ys) = op z y : go xs ys; go (x:xs) ys@[] = op x z : go xs ys; go (x:xs) (y:ys) = op x y : go xs ys }
01:34:37 <accel> http://hpaste.org/49575 <-- any more suggestions?
01:34:46 <maurer_> @let longZip f i xs ys = take (max (length xs) (length ys)) $ zipWith f xs ys
01:34:47 <lambdabot>  Defined.
01:34:58 <maurer_> In case anyone feels like playing with it to see what it does, there it is in lambdabot
01:34:59 <accel> damnit
01:35:07 <ion> maurer: length is strict.
01:35:19 <Cale> maurer_: you messed up a bit though
01:35:23 <maurer_> ion: True.
01:35:24 <accel> ya, zipWith
01:35:33 <accel> it ends with the shorter, no?
01:35:39 <Cale> zipWith will chop the lists off at the shorter, yes
01:35:39 <maurer_> Oh, yeah, I made a mistake there.
01:35:48 <maurer_> I accidently dropped part of it, other than the strictness issue
01:35:52 <maurer_> @undefine
01:35:54 <maurer_> I meant to write
01:36:08 <maurer_> @let longZip f i xs ys = take (max (length xs) (length ys)) $ zipWith f (xs ++ (repeat i)) (ys ++ (repeat i))
01:36:09 <lambdabot>  Defined.
01:36:21 <accel> I'm impressed.
01:36:23 <accel> I'm stealing that
01:36:26 <maurer_> longZip (+) 1 [1, 2, 3] [4, 5]
01:36:31 <accel> and retracting my Data.List.Extras submission
01:36:33 <maurer_> accel: Mine is less lazy than yours, which may be bad.
01:36:35 <Cale> accel: But that version has a strictness problem
01:36:41 <accel> how so?
01:36:46 <maurer_> > longZip (+) 1 [1, 2, 3] [4, 5]
01:36:46 <accel> if xs or ys is infinite
01:36:47 <lambdabot>   [5,7,4]
01:36:48 <Cale> > longZip (+) 0 [1..] [1..]
01:36:50 <accel> it does not terminate?
01:36:59 <maurer_> So that works fine, but what Cale has produces no output
01:37:06 <maurer_> As it needs to compute the length to work
01:37:09 <accel> hmm, in this case, it's okay
01:37:13 <ion> > let longZip op z = go where { go xs@[] [] = xs; go xs@[] (y:ys) = op z y : go xs ys; go (x:xs) ys@[] = op x z : go xs ys; go (x:xs) (y:ys) = op x y : go xs ys } in longZip (+) 0 [1..] [1..]
01:37:19 <lambdabot>   mueval-core: Time limit exceeded
01:38:14 <ion> > let longZip op z = go where { go xs@[] [] = xs; go xs@[] (y:ys) = op z y : go xs ys; go (x:xs) ys@[] = op x z : go xs ys; go (x:xs) (y:ys) = op x y : go xs ys } in longZip (+) 0 [100,100,100] [1..]
01:38:15 <lambdabot>   [101,102,103,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26...
01:38:16 <maurer_> @let trunc xs = (map snd) . (zip xs)
01:38:19 <lambdabot>  Defined.
01:38:47 <maurer_> @let longZip f i xs ys = trunc ys $ trunc xs $ zipWith f (xs ++ (repeat i)) (ys ++ (repeat i))
01:38:47 <lambdabot>  <local>:3:0:
01:38:47 <lambdabot>      Multiple declarations of `L.longZip'
01:38:47 <lambdabot>      Declared at: <lo...
01:39:00 <maurer_> @undefine longZip
01:39:10 <maurer_> @let longZip f i xs ys = trunc ys $ trunc xs $ zipWith f (xs ++ (repeat i)) (ys ++ (repeat i))
01:39:11 <lambdabot>  <local>:1:20: Not in scope: `trunc'
01:39:11 <lambdabot>  
01:39:11 <lambdabot>  <local>:1:31: Not in scope: `trunc'
01:39:28 <maurer_> trunc [10] [20]
01:39:35 <benmachine> I like
01:39:36 <maurer_> > trunc [10] [20]
01:39:36 <benmachine> zipEx :: [a] -> [b] -> ([(a,b)], Either [a] [b])
01:39:36 <lambdabot>   Not in scope: `trunc'
01:40:05 <maurer_> @let trunc xs = (map snd) . (zip xs)
01:40:05 <lambdabot>  Defined.
01:40:11 <maurer_> @let longZip f i xs ys = trunc ys $ trunc xs $ zipWith f (xs ++ (repeat i)) (ys ++ (repeat i))
01:40:12 <lambdabot>  Defined.
01:40:22 <maurer_> > longZip (+) 0 [1..] [1..]
01:40:25 <lambdabot>   mueval-core: Time limit exceeded
01:40:34 <maurer_> Hm, guess that one doesn't work either.
01:40:40 <maurer_> > take 10 $ longZip (+) 0 [1..] [1..]
01:40:41 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
01:40:44 <maurer_> Nope, it works
01:40:44 <maurer_> :)
01:40:52 <maurer_> Not super cool, but w/e
01:41:00 <erus`> @hoogle [Maybe a] -> [a]
01:41:00 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
01:41:00 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
01:41:00 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
01:41:27 <benmachine> @let zipEx xs [] = ([], Left xs); zipEx [] ys = ([], Right ys); zipEx (x:xs) (y:ys) = ((x,y):a,b) where (a,b) = zipEx xs ys
01:41:28 <lambdabot>  Defined.
01:41:43 <benmachine> maurer_: I don't think that's right
01:41:52 <maurer_> benmachine: No?
01:41:54 <benmachine> > longZip (+) 0 [1,2,3] [1,2,3,4,5]
01:41:56 <lambdabot>   [2,4,6]
01:42:03 <maurer_> Oh, yeah, you're right
01:42:07 <maurer_> Oops
01:42:10 <maurer_> My bad
01:42:58 <accel> someone should put this question
01:43:01 <accel> on as freshmen haskell exam
01:43:40 <ion> > let longZip :: (a -> b -> c) -> (Either a b -> c) -> [a] -> [b] -> [c]; longZip op f = go where { go xs@[] [] = xs; go xs@[] (y:ys) = f (Right y) : go xs ys; go (x:xs) ys@[] = f (Left x) : go xs ys; go (x:xs) (y:ys) = op x y : go xs ys } in longZip (,) (either (\c -> (c,0)) (\n -> ('!',n)) "hello" [1..]
01:43:40 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
01:44:13 <ion> > let longZip :: (a -> b -> c) -> (Either a b -> c) -> [a] -> [b] -> [c]; longZip op f = go where { go xs@[] [] = xs; go xs@[] (y:ys) = f (Right y) : go xs ys; go (x:xs) ys@[] = f (Left x) : go xs ys; go (x:xs) (y:ys) = op x y : go xs ys } in longZip (,) (either (\c -> (c,0) (\n -> ('!',n)) "hello" [1..]
01:44:14 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
01:44:24 <ion> fdasadfs
01:44:25 <ion> > let longZip :: (a -> b -> c) -> (Either a b -> c) -> [a] -> [b] -> [c]; longZip op f = go where { go xs@[] [] = xs; go xs@[] (y:ys) = f (Right y) : go xs ys; go (x:xs) ys@[] = f (Left x) : go xs ys; go (x:xs) (y:ys) = op x y : go xs ys } in longZip (,) (either (\c -> (c,0)) (\n -> ('!',n))) "hello" [1..]
01:44:26 <lambdabot>   Couldn't match expected type `a' against inferred type `c'
01:44:26 <lambdabot>    `a' is a rigi...
01:44:40 <ion> Note to self: don’t test on channel
01:44:43 <Cale> data Or a b = OrLeft a | OrRight b | OrBoth a b;  coalesce :: (Or a b -> c) -> [a] -> [b] -> [c]
01:45:20 <Cale> Of course, we can Church encode that datatype...
01:46:03 <Cale> coalesce :: ((a -> c) -> (b -> c) -> (a -> b -> c)) -> [a] -> [b] -> [c]
01:46:20 <identity_> http://ycombinator.com/ideas.html
01:46:36 <quicksilver> Cale: I don't think that's quite right
01:46:49 <Cale> yeah, I missed...
01:46:58 <Cale> coalesce :: ((a -> c) -> (b -> c) -> (a -> b -> c) -> c) -> [a] -> [b] -> [c]
01:48:13 * quicksilver was thinking of (a -> c) -> (b -> c) -> (a -> b -> c) -> [a] -> [b] -> [c]
01:48:22 <pedro3005> what's a good tutorial/book on haskell that is more about the mathematical / rigorous exposition of it?
01:48:42 <Cale> and, that works too :)
01:49:23 <Cale> pedro3005: there's a lecture series by Giesl which is good in that regard... it's a little dry, but you might like it
01:49:26 <anincog> In the context of http://hpaste.org/49576 , I'm struggling to see why   parity (fromInt 1)   should make GHC complain about overlapping instances (from lines 15 and 21). I mean, Nat isn't an instances of Integral. Does anybody see where I'm thinking incorrectly? (Is this related to UndecidableInstances? I was under the impression that using it to say "every type that's an instance of Foo is automatically and instance of Bar" was
01:49:26 <anincog> safe)
01:49:34 <quicksilver> Cale: don't see how to use your CPS version. Suppose I have just an 'a' (that is , my [a] has one element and my [b] is empty) - how do I use that big function on that a?
01:49:50 <quicksilver> coalesce f [a0] [] = ???
01:49:56 <pedro3005> Cale, got a link?
01:50:17 <quicksilver> anincog: instance (Integral a) => Par a
01:50:29 <quicksilver> anincog: this instance definition makes *all* types 'a' an instance of Par.
01:50:39 <quicksilver> so it overlaps with all other definitions including instance Par Nat.
01:50:46 <quicksilver> contexts are not part of instance resolution.
01:51:01 <anincog> quicksilver: Oooooooooh.. well that's something I've had confused in my head for quite some time then
01:51:18 <anincog> quicksilver: I'm certainly glad that's cleared up - thank you :)
01:51:23 <quicksilver> it's the mistake almost everyone makes about instances ;)
01:51:56 <ion> > let coalesce :: (a -> c) -> (b -> c) -> (a -> b -> c) -> [a] -> [b] -> [c]; coalesce l r both = go where { go (x:xs) (y:ys) = both x y : go xs ys; go (x:xs) ys@[] = l x : go xs ys; go xs@[] (y:ys) = r y : go xs ys; go [] [] = [] } in coalesce (\c -> (c,0)) (\n -> ('!',n)) (,) "hello" [0..]
01:51:56 <lambdabot>   [('h',0),('e',1),('l',2),('l',3),('o',4),('!',5),('!',6),('!',7),('!',8),('...
01:52:01 <Cale> http://video.s-inf.de/#FP.2005-SS-Giesl.(COt).HD_Videoaufzeichnung
01:52:07 <anincog> Is there some technical reason why one can't say "everything that's a Foo is automatically also a Bar", or is it just a design choice?
01:52:15 <Cale> (The lectures are in English)
01:52:39 <ion> or: coalesce (,0) ('!',) (,) "hello" [0..] with TupleSections
01:52:40 <quicksilver> anincog: there is a reason, yes. Or several connected reasons.
01:52:58 <benmachine> anincog: well, suppose you had Foo a => Bar a, and you also had Baz a => Bar a, then what happens if something is both Foo and Baz?
01:53:00 <quicksilver> ion: yes, that's my version of the type.
01:53:04 <ion> quicksilver: yes
01:53:29 <quicksilver> anincog: also, how does the compiler compile polymorphic code?
01:53:32 <ion> accel: See above.
01:53:48 <anincog> benmachine: Ah yes, I see. That's also something my head has wanted before, actually: A way for something to "be an instance of a single typeclass in 'multiple ways'"
01:53:54 <pedro3005> thanks Cale . But I was really looking for something in book form. namely since 1) my internet is slow and it'd be a pain downloading these, and 2) I don't have much patience to watch them
01:54:04 <quicksilver> anincog: with the current scheme, if you try to apply parity to an unspecified type it will generate an Integral contrains
01:54:04 <benmachine> anincog: newtypes! newtypes actually solve both problems, albeit rather clumsily
01:54:06 <Cale> pedro3005: yeah
01:54:21 <quicksilver> anincog: because with an integral constraint it gets a polymorphic instance.
01:54:23 <anincog> benmachine: Yep, I've ended up doing it like that :)
01:54:24 <Cale> pedro3005: I think your best bet is something like Types and Programming Languages
01:54:29 <Cale> Though it's not about Haskell
01:54:30 <quicksilver> anincog: but then suppose someone later passes a 'Nat' to it
01:54:38 <quicksilver> anincog: ... it will be using hte wrong instance.
01:54:41 <nus> the gentle introduction + the report?
01:54:53 <quicksilver> the way we handle + compile polymorphic code motivates a lot of the design of the typeclass system.
01:54:56 <nus> not much of a tutorial, though
01:55:07 <anincog> quicksilver: Yeah I think I see what you mean... thanks for clearing that up for me :)
01:55:23 <quicksilver> anincog, benmachine : if you think you need mlutiple instances of the same typeclass (For the same type) that may be a sign you shouldn't be using typeclasses at all.
01:55:29 <Cale> pedro3005: Or yeah, the report if what you're looking for is specifically a treatment of Haskell which is semi-rigorous.
01:55:35 <benmachine> anincog: one way to support multiple instances of sorts is to pass a record of functions
01:55:36 <quicksilver> typeclasses are not a general / allpurpose abstraction tool
01:55:50 <quicksilver> there are much more general techniques just using plain higher-order programming
01:55:56 <Cale> quicksilver: hrm, do I need a higher-rank type?
01:55:57 <quicksilver> passing functions around (like benmachine just said)
01:56:16 <ion> accel: coalesce above is a generalization of longZip: longZip op z = coalesce (`op` z) (z `op`) op
01:56:17 <Cale> quicksilver: It's 5am and I should be sleeping :)
01:56:20 <quicksilver> Cale: :)
01:56:21 <pedro3005> Cale, well I wanted something still didactic in some sense I guess. I'll look into thatbook
01:56:43 <pedro3005> maybe I should get a book on pure category theory? is that advised?
01:56:45 <anincog> quicksilver: Yeah, I see... I guess I have in general been too drawn towards typeclasses for certain things that they're not really the best tool for.
01:57:10 <Cale> quicksilver: The idea is that you can encode a value like (\left right both -> left 4) or (\left right both -> both 4 "hello")
01:57:16 <anincog> quicksilver: I do find it hard at times though to figure out when it's "right" to just pass around functions and when to use typeclasses.
01:57:25 <anincog> quicksilver: But I guess it's all about experience
01:57:45 <benmachine> coalesce l r both xs ys = map (uncurry both) zs ++ either (map l) (map r) rs where (zs,rs) = zipEx xs ys
01:57:58 <benmachine> just sayin'
01:58:05 <sanjoyd> @ty coalesce
01:58:05 <lambdabot> Not in scope: `coalesce'
02:00:54 <ion> “org.springframework.aop.framework.AbstractSingletonProxyFactoryBean” http://static.springsource.org/spring/docs/2.5.x/api/org/springframework/aop/framework/AbstractSingletonProxyFactoryBean.html
02:01:15 <accel> is there a short hand for: take x $ repeat y ?
02:01:18 <quicksilver> cale: (((a -> c) -> (b -> c) -> (a -> b -> c) -> c) -> c) -> [a] -> [b] -> [c] then?
02:01:45 <sanjoyd> ion: huh?
02:01:53 <quicksilver> Cale: then you can write coalesce f [a] [] = f (\l r b -> l a)
02:02:07 <sanjoyd> @hoogle a -> Int -> [a]
02:02:08 <lambdabot> Prelude replicate :: Int -> a -> [a]
02:02:08 <lambdabot> Data.List replicate :: Int -> a -> [a]
02:02:08 <lambdabot> Data.List genericReplicate :: Integral i => i -> a -> [a]
02:02:15 <sanjoyd> accel: ^
02:02:22 <quicksilver> Cale: coalesce f [a] [b] = [f (\l r bth -> bth a b)]
02:02:22 <sanjoyd> > replicate 5 'a'
02:02:23 <lambdabot>   "aaaaa"
02:02:24 <ion> @check \n x -> take n (repeat x) == replicate n x
02:02:24 <lambdabot>   "OK, passed 500 tests."
02:02:26 <quicksilver> Cale: and other cases similarly.
02:02:51 * sanjoyd needs to learn QuickCheck.
02:02:51 <benmachine> @check \n x -> take n (repeat x) = reverse (replicate n x)
02:02:52 <lambdabot>   Parse error at "=" (column 27)
02:02:58 <benmachine> @check \n x -> take n (repeat x) == reverse (replicate n x)
02:02:58 <lambdabot>   "OK, passed 500 tests."
02:03:27 * benmachine wishes the defaulting wouldn't do that
02:03:27 <ion> Yeah, it defaults x to (), which was enough for the first property, though. :-)
02:03:43 <accel> repliacte
02:03:44 <accel> ah
02:03:45 <accel> nice; thanks
02:03:57 <benmachine> ion: I guess the fact that the elements are all the same is a free theorem
02:03:59 <erus`> :t iterate
02:04:00 <lambdabot> forall a. (a -> a) -> a -> [a]
02:04:06 <benmachine> so you just needed to check the lists were of the same length?
02:04:30 <benmachine> well, and possibly that they were total values
02:05:01 <erus`> i have a function like [token] -> ([token] -> instruction)
02:05:15 <erus`> i want to get [instruction]
02:05:35 <erus`> so i want to keep calling the function until it returns ([], _)
02:05:49 <erus`> whats the prelude function todo this please
02:05:53 <sanjoyd> Unfold?
02:05:58 <sanjoyd> Thought that is a little different.
02:06:03 <benmachine> erus`: you mean [token] -> ([token],instruction)?
02:06:15 <benmachine> unfold will do it with enough coercion
02:06:41 <erus`> yes i do mean that
02:07:07 <erus`> unfoldr or unfoldl?
02:07:25 <benmachine> I don't think there is an unfoldl
02:11:02 <accel> zipWith
02:11:03 <accel> :t zipWith
02:11:04 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
02:12:22 <accel> :t foldr
02:12:23 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
02:12:45 <accel> :t foldr1
02:12:45 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
02:16:49 <erus`> does unfoldr work left to right?
02:18:12 <Jafet> How could it work from right to left?
02:18:32 <benmachine> Jafet: an accumulator, perhaps
02:18:42 <benmachine> it couldn't work from right to left *and* be lazy, which it is
02:18:51 <erus`> maybe i should just use parsec
02:19:02 <erus`> this would be so much easier in an imperative language
02:19:12 <benmachine> > unfoldr (\n -> Just (chr n, n+1)) 65
02:19:13 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\12...
02:20:00 <ion> > unfoldr (Just . (id &&& succ)) 'A'
02:20:02 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\12...
02:20:24 <benmachine> hmm
02:20:38 <benmachine> > unfoldr (runKleisli (id &&& arr succ)) 'A'
02:20:38 <lambdabot>   Couldn't match expected type `Control.Arrow.Kleisli
02:20:39 <lambdabot>                        ...
02:20:41 <benmachine> aw
02:20:47 <identity_> :t (&&&)
02:20:47 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
02:20:50 <benmachine> > unfoldr (runKleisli (Control.Category.id &&& arr succ)) 'A'
02:20:50 <lambdabot>   Not in scope: `Control.Category.id'
02:20:53 <benmachine> :<
02:23:47 <mm_freak> what's a good ByteString building library?  i find that blaze-builder is used a lot
02:25:12 <_Ray_> Hi. In defining an "instance Eq MyClass", I know I can skip the type signature for ==, but how could I write it? (==) :: MyClass -> MyClass -> Bool fails, as well as just ==.
02:25:21 <Jafet> I wonder if ByteString should be efficiently buildable by default
02:25:22 <cpa> :t (<*>)
02:25:23 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
02:25:57 <Jafet> Ray: you need to define (==) or (/=).
02:26:11 <Jafet> Oh, you want to write the type signature.
02:26:20 <_Ray_> Jafet, yeah :) I already defined it.
02:26:47 <Jafet> (==) is the correct name for the function, so perhaps it is you that's failing
02:26:52 <Jafet> What have you written so far?
02:27:35 <_Ray_> http://hpaste.org/49577
02:27:59 <accel> this is really really weird question. Is it posible to define a function "f :: a -> Int -> Int", where "f x p" means "take x; take all the Ints in x, replace them with their value `mod` p" ?
02:28:09 <accel> we don't know the type of x
02:28:20 <accel> I wnat this to work for arbitrary types; to just take every Int in the structure
02:28:23 <accel> and produce it's value mod p
02:28:32 <_Ray_> accel: Well, whatever p is, it must be "mod"-able.
02:28:45 <mm_freak> accel: a function with exactly that type signature will not work
02:28:54 <_Ray_> If you make a typeclass that represents "Things that can be mod-ed over", then you can make it work.
02:28:59 <accel> we know p, p is an Int
02:29:06 <accel> err, the function would be "f :: a -> Int -> a"
02:29:25 <mm_freak> accel: first try to get your type signature straight
02:29:27 <_Ray_> Then what do you mean by "take all the Ints in x"? x is a list of Int?
02:29:30 <aninhumer> accel: You need a constraint over that a
02:29:39 <accel> x = some objet ot type a
02:29:46 <accel> a = some representation
02:29:54 <accel> I just want all the ints in the representation of x to be modded by p
02:29:58 <mm_freak> accel: but don't you essentially want map (`mod` n)?
02:30:02 <aninhumer> accel: so what if a is Bool?
02:30:16 <mm_freak> > map (`mod` 5) [0..]
02:30:17 <lambdabot>   [0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,...
02:30:28 <Jafet> Hm, I thought you're allowed to put type signatures in instance methods, but it seems that you're not
02:30:33 <Jafet> Can someone else confirm this?
02:30:36 <accel> it ignore all the non Int parts of "a"
02:30:39 <mm_freak> Jafet: you're not
02:30:47 <Jafet> There you go, Ray
02:30:50 <_Ray_> Thanks :)
02:31:03 <_Ray_> accel: What is a "non Int part" of a type?
02:31:11 <accel> so "a" might have type [ Foo(Int [String] Bar(Cat Dog Int)) ]
02:31:20 <accel> and "foO" magically runs through it, and for every Int, does a mod
02:31:24 <accel> and for the non Int parts, ignores it
02:31:29 <mm_freak> accel: new to haskell? =)
02:31:48 <mm_freak> that function is not really expressable in haskell, at least not straightforwardly
02:31:55 <mm_freak> you will need to write a typeclass for it
02:32:13 <mm_freak> class MapOverInts a where mapOverInts :: (Int -> Int) -> a -> a
02:32:15 <benmachine> Data is a typeclass for that
02:32:20 <Guest48631> i'm getting linker errors against base
02:32:28 <Jafet> I expect accel appreciates the difficulty of writing its type in haskell
02:32:34 <mreh> i'm getting linker errors against base*
02:32:38 <mreh> is that bad?
02:33:03 <Jafet> Well, did you expect to get one?
02:33:09 <mreh> no
02:33:12 <aninhumer> could you do something like, make a new class for the function, define an instance for (Num a) => a and then define one for a?
02:33:14 <Jafet> Then it's bad, eh!
02:33:26 <mreh> i was hoping GHC would abstract linking away for me :(
02:33:40 <aninhumer> Or (Num a) => Functor a rather
02:33:58 <Jafet> GHC is supposed to
02:34:00 <aninhumer> so the first is fmap mod and the second is id?
02:34:07 <mm_freak> aninhumer: i think he means to apply a function to all Ints of a type, whose shape you don't know
02:34:10 <Jafet> Why not actually describe your problem mreh
02:34:12 <mreh> Jafet, yeah, she was doing okay until now
02:34:16 <mm_freak> so it will magically work for all kinds of record types
02:34:49 <mreh> i get a mass of linker errors against base-4.1.0.0 and unix-2.4.0.0
02:35:13 <quicksilver> mreh: did you forget --make?
02:35:21 <mreh> i'm using cabal build
02:35:36 <quicksilver> did you forget to add all the dependencies you're using?
02:35:50 <identity_> quicksilver: Haha. "Did you forget *everything*?"
02:36:21 <mreh> no, cabal doesn't complain
02:36:23 <quicksilver> accel: uniplate is neater than Data for that simple case
02:36:28 <quicksilver> mapOverInts.
02:36:29 <mekeor> hehe, or rather: "didnt you forget anything?"
02:37:34 <_Ray_> Quick question. Why is this wrong? "n <- toInt . getLine" I'd like to run getLine, and apply toInt to that.
02:38:16 <Jafet> getLine is IO String, so it produces a String inside IO
02:38:27 <Jafet> If you want to move toInt into that IO, use liftM toInt
02:38:32 <mekeor> n <- getLine; m= toInt n;
02:38:35 <aninhumer> _Ray_: line <- getLine; let n = toInt line
02:38:37 <identity_> _Ray_: Use liftM or fmap
02:38:43 <_Ray_> Oh, 'variables are auto-lifted', but functions are not?
02:38:55 <Jafet> There is no such thing as auto-lifting; the types must always match
02:39:16 <Jafet> In your case, the <- notation "un-lifts" the computation into your variable
02:39:18 <_Ray_> Well, inside a do block, n <- getLine, n is of type String there, correct? Even though it's really IO String?
02:39:38 <aninhumer> _Ray_: x <- m means take the value out of the Monad m and place it in x
02:39:59 <identity_> _Ray_: In reality it is just syntactic sugar for a chain of (>>=)s and (>>)s
02:40:00 <aninhumer> _Ray_: so the value on the right has to be a Monad
02:40:01 <Jafet> A better way to see it is that x <- m produces a monadic action whose result is called x
02:40:02 <_Ray_> Right, so since getLine :: IO String, x <- getLine would make x :: String, ne?
02:40:07 <Jafet> But you're still in the monad
02:40:15 <mreh> strangely enough my errors are almost identical to this http://hackage.haskell.org/packages/archive/Cabal/1.8.0.2/logs/failure/ghc-6.10
02:40:26 <identity_> { n <- getLine; foo n } is 'converted into' getLine >>= \n -> foo n
02:40:35 <_Ray_> Right, yeah, bind and return.
02:40:39 <aninhumer> _Ray_: yep, but toInt . getLine doesn't typecheck
02:40:46 <aninhumer> and also isn't a Monad
02:41:00 <erus`> what do i call the proess of shrinking multiple items like [A, A, A, A, A, B, B] = [T A 5, T B 2]
02:41:09 <_Ray_> Ok, so the issue would be that the one who does the "unboxing" is <-, not being in a do block itself.
02:41:15 <mreh> are these most likely related to C bindings?
02:41:15 <identity_> erus`: run length encoding?
02:42:07 <Cale> > map (\xs -> (head xs, length xs)) . group $ "AAAAABB"
02:42:09 <lambdabot>   [('A',5),('B',2)]
02:42:20 <mreh> fixed by reverting back to unix-2.3.2.0
02:42:25 <Cale> > map (head &&& length) . group $ "AAAAABB"
02:42:27 <lambdabot>   [('A',5),('B',2)]
02:42:33 <identity_> Cale: o.o
02:42:35 <identity_> damn arrows
02:42:38 <mreh> that'll teach me to reinstall a library to distributed with my GHC
02:42:50 <Jafet> mreh: sounds like your packages are mixed up, perhaps you should read SICP
02:43:03 <benmachine> Jafet: that's not a good acronym to use :P
02:43:09 <Jafet> http://www.vex.net/~trebla/haskell/sicp.xhtml
02:43:21 <mreh> Structure and Interpretation of Computer Programs?
02:43:28 <Jafet> Why don't you tell the author of that document
02:43:46 <Jafet> Chances are that you're doing something described in there as wrong
02:44:13 <mreh> oh, right haha
02:44:41 <mreh> thanks
02:45:14 <_Ray_> Similarly, if p and q are Ints, what is wrong with this in a do block?  map (putStrLn . show) [p, q]
02:45:44 <identity_> _Ray_: You basically create a list of unevaluated IO computations
02:45:54 <identity_> you can either use: sequence $ map ..
02:45:59 <_Ray_> Is that evil?
02:46:01 <identity_> or just mapM(or mapM_)
02:46:03 <identity_> not realy
02:46:14 <identity_> not really, but mapM is the monadic map which you should use instead
02:46:18 <identity_> @src mapM
02:46:18 <lambdabot> mapM f as = sequence (map f as)
02:46:22 <Jafet> Your value has type [IO ()], which is not an IO action
02:46:32 <Jafet> Because it's not of the form IO a
02:46:34 <identity_> mapM is actually defined in terms of sequence and map
02:46:47 <identity_> :t sequence $ map f l
02:46:48 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Expr'
02:46:48 <lambdabot>     In the second argument of `map', namely `l'
02:46:48 <lambdabot>     In the second argument of `($)', namely `map f l'
02:46:51 <identity_> meh
02:46:52 <Jafet> sequence (or its equivalents) will join those little IO ()'s into one IO a
02:46:55 <mreh> depends which sequence you're talking about
02:47:05 <_Ray_> Right, so sequence is sort of like the 'join' for IO?
02:47:20 <mreh> :t join
02:47:21 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
02:47:24 <mreh> not quite
02:47:28 <_Ray_> Oh, no. :(
02:47:40 <aninhumer> _Ray_: we'd say concat in Haskell, join is something else
02:47:44 <_Ray_> Yeah, join would join multiple computations but in another sense.
02:47:52 <aninhumer> Are you thinking of join in python for example?
02:47:59 <_Ray_> Nah, like the kleisli triple
02:48:11 <_Ray_> But that'd be if I had IO (IO o) -> IO o
02:49:05 <aninhumer> bah I never know what level to pitch help in here :P
02:50:15 <azaq231> join = x >>= id, sequence [] = return []; sequence (x : xs) = do { x0 <- x; xs0 <- sequence xs; return $ x0 : xs0 }
02:52:07 <_Ray_> Hrmph. Well if xs0 :: M a, but x0 :: a, how can I return $ x0 : xs0?
02:53:15 <_Ray_> Hrmph, actually, I'd have to wonder what x0 : xs0 even means when x0 :: a, xs0 :: M a.
02:53:22 <benmachine> what makes you think xs0 :: M a?
02:53:34 <azaq231> xs0 is [a]
02:53:38 <_Ray_> Poor induction abilities maybe.
02:53:40 <identity_> _Ray_: Well, list is a monad too :P
02:53:50 <benmachine> identity_: shh
02:53:57 <benmachine> the list monad is a secret
02:54:01 <identity_> oh, shit
02:54:06 <_Ray_> Heh, it's my go-to example of a monad tbh :)
02:54:11 <identity_> Rules of the List monad: 1. You do not talk about the list monad.
02:54:31 * Jafet hides the list monads in a nearby burrito
02:55:05 <_Ray_> Oh alright, sequence xs is of type M [a], but by saying xs0 <- sequence xs you get a [a]
02:55:36 <identity_> _Ray_: you can look at it like that is
02:55:37 <azaq231> _Ray_: You can also view sequence as foldr (liftM2(:)) (return []) if you want to
02:55:39 <identity_> yes*
02:56:05 <_Ray_> Oh, pretty.
02:58:04 <_Ray_> What's the general opinion on SecLib and SafeHaskell?
03:02:13 <erus`> @hoogle A b -> A
03:02:13 <lambdabot> Warning: Unknown type A
03:02:14 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
03:02:14 <lambdabot> Prelude id :: a -> a
03:02:35 <benmachine> erus`: that's not a valid type signature
03:03:12 <erus`> ok i have a type data Inst = DP Int | DV Int
03:03:25 <erus`> i have two Inst's
03:03:36 <erus`> i need to check whether they are both DP or DV
03:03:41 <erus`> regardless of there Int value
03:03:52 <sipa> they can't be anything but DP or DV
03:04:13 <sipa> and the only way to know which of both they are, is a pattern match
03:04:20 <quicksilver> sameD (DP _) (DP _) = True; sameD (DV _) (DV _) = True; sameD _ _ = False;
03:04:30 <erus`> so just create a sameType function?
03:04:35 <quicksilver> yes.
03:04:36 <sipa> what quicksilver said :)
03:04:52 <quicksilver> it is occasionally useful to duplicate a type with a 'constructor only version'
03:05:04 <quicksilver> data InstCons = DPC | DVC
03:05:19 <quicksilver> deriving Show,Eq,Ord,Enum,Etc
03:05:34 <quicksilver> some of the metaprogramming tools can do this for you
03:05:40 <quicksilver> but it's only worth it if it's worth it.
03:10:48 <mm_freak> in blaze-builder, what's the difference between Builder and Write?
03:11:50 <erus`> arg my brain isnt working today
03:13:26 <quicksilver> mm_freak: a Builder is multiple Writes, so far as I understand it
03:16:13 <erus`> i need to write my own group
03:17:30 <mm_freak> quicksilver: well, there is a Write version of every builder, and Write is also a Monoid
03:17:44 <mm_freak> the only difference seems to be that you have to convert Write to Builder
03:23:52 <erus`> i have a list like this [DP 1, DP 1, DP 1, DV 1, DV 1, DP 1] and i want to turn it into [DP 3, DV 2, DP 1]
03:24:08 <erus`> but i cant find an elegant way
03:24:42 <benmachine> squidge (DP n : DP m : ds) = squidge (DP (n+m) : ds)
03:24:43 <benmachine> etc.
03:24:55 <benmachine> or is that not elegant?
03:27:24 <erus`> groupInstructions gis (Just (DP x)) ((DP y):is) = groupInstructions ((DP (x+y):gis) Nothing is
03:27:46 <erus`> ah yours is nices
03:27:59 <aninhumer> erus`: Potentially make the type D (P | V) Int?
03:29:10 <azaq231> > let p = [Left 1, Left 1, Left 1, Right 1, Right 1, Left 1] in groupBy (==) p
03:29:10 <lambdabot>   [[Left 1,Left 1,Left 1],[Right 1,Right 1],[Left 1]]
03:29:25 <aninhumer> then f ((D a n) : (D b m) : ds) | a == b = D a (n+m) : ds ?
03:29:50 <erus`> > let p = [Left 3, Left 1, Left 2, Right 1, Right 2, Left 1] in groupBy (==) p
03:29:50 <lambdabot>   [[Left 3],[Left 1],[Left 2],[Right 1],[Right 2],[Left 1]]
03:30:13 <azaq231> you can supply your own function instead of using (==)
03:30:40 <erus`> ah
03:34:55 <azaq231> > let p = [Left 3, Left 1, Left 2, Right 1, Right 2, Left 1] in map (sum . (map ((\x -> case x of { Left p -> p; Right p -> p })))) $ groupBy (\x y -> case (x, y) of { (Left _, Left _) -> True; (Right _, Right _) -> True; _ -> False}) p
03:34:57 <lambdabot>   [6,3,1]
03:35:05 <mercury^> erus`: map sum . sequence . group, if you provide trivial monad instances for DP, DV, etc.
03:35:31 <coppro> would't it be fun to match on constructors :D
03:36:11 <mercury^> Err, map that liftM sum . sequence . group
03:41:12 <coppro> @hoogle map
03:41:13 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
03:41:13 <lambdabot> Data.ByteString map :: (Word8 -> Word8) -> ByteString -> ByteString
03:41:13 <lambdabot> Data.IntMap map :: (a -> b) -> IntMap a -> IntMap b
03:41:33 <coppro> How do I search by type again?
03:41:50 <azaq231> @hoogle Functor f => (a -> b) -> (f a -> f b)
03:41:50 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
03:41:50 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
03:41:50 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
03:42:03 <coppro> thanks
03:42:27 <erus`> how do i do the f (i:is) @ins  thing again?
03:42:56 <coppro> @hoogle Data.Foldable f => (a -> b) -> f a -> [b]
03:42:56 <lambdabot> Parse error:
03:42:56 <lambdabot>   --count=20 "Data.Foldable f => (a -> b) -> f a -> [b]"
03:42:56 <lambdabot>                  ^
03:42:57 <azaq231> > let f xs @ (x : xss) = (xs, x, xss) in f [1, 2, 3]
03:42:57 <lambdabot>   ([1,2,3],1,[2,3])
03:43:10 <coppro> @hoogle Foldable f => (a -> b) -> f a -> [b]
03:43:10 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
03:43:10 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
03:43:10 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
03:47:18 <_Ray_> Is there a cleaner way of writing "return $ (boolToInt y) + (2 * res)"?
03:47:54 <coppro> what are y and res in this case?
03:48:37 <ion> return (boolToInt y + 2 * res)
03:48:39 <erus`> http://hpaste.org/49578 could someone look at that please
03:48:40 <_Ray_> y is Bool, res is Int
03:48:57 <_Ray_> ah, ok :) still not comfortable with precedence
03:48:59 <coppro> _Ray_: Yeah, but where are you getting themf rom?
03:49:00 <coppro> *from
03:49:08 <coppro> Are they from binds?
03:49:13 <_Ray_> Yup
03:50:10 <quicksilver> erus`: contains one typo (comrpess) and doesn't go further down than the top of the list.
03:50:26 <coppro> liftM $ (flip $ (+) . boolToInt) . (*2)
03:50:38 <coppro> apply liberally to the expressions you bound to res and y
03:51:14 <coppro> (notwiststanding that I got them the other way around)
03:51:14 <ion> coppro: That’s clean?
03:51:27 <erus`> quicksilver: i just fixed that and it stil doesnt like it
03:51:32 <coppro> :t liftM $ (flip $ (+) . (*2)) . boolToInt
03:51:32 <lambdabot> Not in scope: `boolToInt'
03:51:56 <coppro> :t liftM $ (flip $ (+) . (*2)) . cond x 1 0
03:51:56 <lambdabot> Not in scope: `cond'
03:52:03 <coppro> derp
03:52:07 <quicksilver> erus`: are you going to paste the error message? or would you like us all to guess? ;)
03:53:10 <erus`> its in the title: not in scope 'ins'
03:53:33 <coppro> :t liftM $ (flip $ (+) . (*2)) . cond x 1 0 where { cond True = const; cond False = flip const; }
03:53:33 <ion> That seems like a subset of an error message.
03:53:34 <lambdabot> parse error on input `where'
03:53:57 <_Ray_> you derped when you should've herped
03:54:09 <quicksilver> > let foo ins @ (i:_) = ins in foo [1,2]
03:54:09 <coppro> :t (liftM $ (flip $ (+) . (*2)) . cond x 1 0 where { cond True = const; cond False = flip const; })
03:54:10 <lambdabot>   [1,2]
03:54:10 <lambdabot> parse error on input `where'
03:54:20 <coppro> :/
03:54:36 <quicksilver> erus`: what you pasted seems fine.
03:54:42 <quicksilver> erus`: paste more code and complete error.
03:54:50 <coppro> :t let { cond True = const; cond False = flip const } in liftM $ (flip $ (+) . (*2)) . cond x 1 0 where
03:54:51 <lambdabot> parse error on input `where'
03:54:54 <coppro> :t let { cond True = const; cond False = flip const } in liftM $ (flip $ (+) . (*2)) . cond x 1 0
03:54:55 <lambdabot>     Couldn't match expected type `Bool' against inferred type `Expr'
03:54:55 <lambdabot>     In the first argument of `cond', namely `x'
03:54:55 <lambdabot>     In the second argument of `(.)', namely `cond x 1 0'
03:55:06 <benmachine> > toEnum 1 :: Bool
03:55:06 <lambdabot>   True
03:55:10 <benmachine> > toEnum 0 :: Bool
03:55:10 <lambdabot>   False
03:55:19 <ion> > fromEnum True :: Integer
03:55:19 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
03:55:19 <lambdabot>         against inf...
03:55:28 <benmachine> Int, I'm afraid
03:55:29 <ion> :t fromEnum
03:55:29 <lambdabot> forall a. (Enum a) => a -> Int
03:55:45 <coppro> :t liftM $ (flip $ (+) . (*2)) . fromEnum
03:55:46 <lambdabot> forall a1 (m :: * -> *). (Monad m, Enum a1) => m a1 -> m (Int -> Int)
03:55:51 <coppro> there we go
03:56:05 <azaq231> coppro: where is not an expression, you may only use where beneath a function definition
03:56:13 <coppro> azaq231: oh
03:56:20 <coppro> :t liftM2 $ (flip $ (+) . (*2)) . fromEnum
03:56:20 <azaq231> > let { f x = p where p = 4 } in f undefined
03:56:21 <lambdabot> forall a1 (m :: * -> *). (Monad m, Enum a1) => m a1 -> m Int -> m Int
03:56:21 <lambdabot>   4
03:56:25 <coppro> that's the one you want
03:56:35 <coppro> _Ray_: ^
03:56:41 <benmachine> you can also use it beneath case branches
03:56:52 <_Ray_> :) Thanks.
03:56:57 <erus`> http://hpaste.org/49579 quicksilver
03:57:01 <benmachine> > case () of () -> () where () = ()
03:57:02 <lambdabot>   ()
03:57:02 <ion> coppro: You still maintain that’s readable code? :-)
03:57:22 <ion> Compared to return (fromEnum y + 2 * res)
03:57:24 <coppro> ion: it's point-free, so yes :P
03:57:43 <benmachine> @pl \a b c d e f g -> c a b b a g e
03:57:43 <lambdabot> (((const . (const .) . flip) .) .) . (flip =<< (flip .) . join . (flip .) . flip . flip id)
03:57:50 <benmachine> it's point-free and therefore readable
03:57:54 <ion> yes
03:58:12 <coppro> ion: If I was doing that as part of a larger sequence of computations, I would use the explicit form since I'd probably be in a do block anyways
03:58:20 <quicksilver> erus`: surely it's the "ins" in "print $ compress ins" which is out of scope?
03:58:51 <erus`> oh yeh :)
03:59:03 <erus`> thanks *slits wrists*
03:59:07 <quicksilver> erus`: there are line numbers in error messages for a reason :)
03:59:20 <erus`> i thought it was 42 :/
03:59:23 <erus`> idiot
04:04:22 <erus`> after all that i could have just grouped the chars
04:04:35 <erus`> i dont know why i bother sometimes
04:06:04 <erus`> @pl \a b c d e f g -> d e a d b e e f
04:06:05 <lambdabot> ((const . (((const .) .) .)) .) . flip flip id . ((flip . (ap .)) .) . flip flip id . ((flip . (ap .)) .) . flip . (flip .) . join . (flip .) . flip flip
04:40:23 <kizzx2> any haskellmode-vim users around?
04:41:32 <kizzx2> when using hasellmode, it "expands" the bottom command line to a 3-line high pane, is there a way i can slim it back down?
04:43:34 <kizzx2> well i guess i'll just do set cmdheight=1, silly me /=
04:43:43 <earthy> :)
05:26:43 <EvanR> so what about applicative transformers? ;)
05:29:06 <quicksilver> EvanR: you don't need them, because Applicatives simply compose.
05:30:11 <EvanR> oh
05:45:41 <clsmith> hey all. does anyone know any links to research about analysing haskell programs to make them concurrent automatically? i'm looking around and all i can find is 'par', etc. i know it's not likely to be efficient, it just interests me :p
05:47:27 <quicksilver> clsmith: read the Eden stuff, and the things they cite
05:47:30 <quicksilver> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.47.2948
05:48:32 <clsmith> ah, thanks :)
06:03:35 <augur> you know
06:03:57 <augur> i remember reading about the Functional JS library in about late 2006
06:04:10 <augur> and it was so hard to understand
06:04:32 <augur> and looking at it now, its so clear and simple
06:04:39 <augur> its just some basic higher order stuff
06:04:43 <augur> the usual stuff
06:04:56 <dpratt71> @seen Cale
06:04:56 <lambdabot> Unknown command, try @list
06:04:56 <preflex_>  Cale was last seen on #haskell 3 hours, 22 minutes and 37 seconds ago, saying: > map (head &&& length) . group $ "AAAAABB"
06:05:03 <Guest15873> i don't remember reading about that in 2006
06:05:18 <mreh> goddamn
06:05:21 <augur> oh how things have changed
06:06:31 <mreh> they have higher order stuff in the abomination that is secha
06:06:34 <mreh> sencha*
06:07:18 <MasseR> augur: What library are you talking about? Functional javascript? Underscore?
06:07:28 <MasseR> Or even jquery
06:07:31 <augur> http://osteele.com/sources/javascript/functional/
06:08:03 <MasseR> augur: I might perhaps recommend underscore instead. It seems to be more widely used and provides functional higher order functions also
06:08:14 <augur> i have no need for functional js, MasseR
06:08:16 <augur> im just reflecting
06:08:20 <MasseR> Ah ok :D
06:08:49 <mreh> i played with flapjax not long ago, but it made me T_T
06:09:26 <augur> flapjax was my first introduction to the idea of reactive programming
06:09:41 <augur> didnt really use it at all, but it was an interesting thing to see
06:09:55 <augur> i STILL dont get how frp works XD
06:10:26 <MasseR> augur: Hah, me too. I'm trying to learn it but as I don't have a need for guis, I haven't got the chance yet
06:11:51 <accel> I have a very important question. You are allowed to use four (repetition allowed) characters from Shift-{0,1,...,8,9}. What is the most ANGRY looking combination you can do? For example, *!*! looks cute, where as #$&* looks more angry -- but I want the MOST ANGRY looking combiantion [This is for a comment in my haskell code]
06:12:36 <sipa> @#$&
06:12:36 <lambdabot> Unknown command, try @list
06:13:02 <dpratt71> #$&!
06:13:18 <dpratt71> or maybe $#&!
06:13:39 <sipa> "fatter" characters seem more angry
06:13:48 <sipa> but the exclamation mark may be an exception :)
06:14:01 <dpratt71> I feel like it needs to have an exclamation at the end
06:14:23 <quicksilver> @&#!
06:14:23 <lambdabot> Unknown command, try @list
06:14:42 <mokus> is angriness a font-invariant?
06:14:49 <mokus> i suspect not
06:14:50 <accel> good call, we need a ! at the end
06:14:58 <accel> it's monospace font for sure
06:15:04 <accel> but besides that, not sure
06:15:09 <sipa> @#&!
06:15:09 <lambdabot> Unknown command, try @list
06:15:21 <wjt> hmm. is there a good way to say "derive Ord, but ignore this one record field which doesn't have an Ord instance"?
06:15:58 <mokus> wjt: I don't think so
06:16:12 <sipa> wjt: put all but that one field in a separate ADT, derive an ord instance for that, and then define your real ADT as a combination of the intermediate one and the unordable field, with a manual Ord instance
06:16:53 <wjt> sipa: neat.
06:21:55 <mreh> @instances Pointed
06:21:55 <lambdabot> Couldn't find class `Pointed'. Try @instances-importing
06:23:40 <cpa> :src (<=<)
06:23:47 <cpa> t (<=<)
06:23:50 <cpa> :t (<=<)
06:23:50 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
06:24:00 <mreh> "This package is obsolete" category-extras
06:24:05 <mreh> :(
06:24:11 <mreh> :<
06:24:23 <benmachine> mreh: it got split up into a million pieces
06:24:33 <benmachine> http://hackage.haskell.org/package/pointed
06:24:43 <benmachine> (but Pointed is mostly a silly class anyways)
06:25:04 <mreh> useful
06:25:51 <mreh> looook at the depency list!
06:26:07 <quicksilver> edwardk had this brilliant idea of how he could stress-test our package architecture
06:26:36 <ion> Pointed would be more useful if it depended on Functor, and Applicative and Monad depended on it. :-P
06:26:44 <quicksilver> by splitting category-extras into a million pieces which all depend on each other, he has simultaneously constructed a worst-case scenario for hackage, a worst-case scenario for cabal, *and* give dcoutts_ bad dreams for a month.
06:27:04 <mreh> i'm going to define it myself
06:27:27 <mreh> i have functors that I can't be bothered to define Applicative/Monad for
06:27:51 <edwardk> hahahaha
06:27:59 <ion> Amusing
06:28:15 <luite> he's going to make millions selling a new cabal-install enterprise edition with a new SMT solver
06:28:15 <benmachine> quicksilver: well, it is the right direction to go in, kinda
06:28:17 <edwardk> @remember quicksilver edwardk had this brilliant idea of how he could stress-test our package architecture
06:28:17 <lambdabot> I will remember.
06:28:36 <benmachine> it's just a shame that haskell doesn't have a good solution to the orphan instance problem
06:28:54 <quicksilver> I'm not thinking of the orphan instances actually
06:29:06 <quicksilver> I'm thinking of upgrade issues and diamond dependences
06:29:17 <benmachine> but the orphan instances are why there are so many dependencies
06:29:22 <edwardk> i only have one package full of orphans, and 2 in another package at the moment
06:29:25 <quicksilver> if other libraries start depending on specific versions of what part of the edwardk net.
06:29:41 <benmachine> i.e. avoiding orphan instances means adding dependencies to stuff you don't really actually technically depend on
06:29:50 <mokus> I do like the recent version-synchronization to 1.8 of several of the packages
06:29:54 <mokus> makes it more mentally tractable
06:30:03 <mreh> oh my god, his packages have become sentient!
06:30:36 <mreh> open up a haskell' ticket to include these in the standard distribution
06:30:36 <edwardk> mokus: yeah they'll all probably jump again in the 2.1 area, they broke back up again when i needed to make a breaking version change for something that sat on 1.8
06:31:06 <edwardk> my main focus at the moment is on getting the algebra package right
06:31:15 <edwardk> which is well on its way to being larger than category-extras was
06:32:34 <mokus> personally I didn't mind the size of category-extras, although I can see benefit in the split packages too
06:32:48 <edwardk> well, most of my new content isn't categorical
06:33:08 <edwardk> and i had a flood of complaints over the years about needing to import 130+ modules to use 'comonad' or 'pointed'
06:33:34 <edwardk> the new set of packages came about from breaking out the small haskell 98 core and then layering on top
06:34:55 <mokus> having a haskell 98 core is a very nice thing
06:35:04 <edwardk> those complaints have stopped and now i only get a small trickle complaining about why something near the bottom depends on something else, which are usually mollified by the orphan instance avoidance concern
06:35:19 <mokus> especially for "basic" but historically overlooked abstractions like comonads
06:35:24 <mreh> a flood of complaints over years... isn't that more a glacier
06:35:40 <edwardk> my response to them may have been glacial at least =)
06:35:50 <edwardk> it took me something like 2 years to bring myself to break it up
06:36:44 <edwardk> it is probably the largest pile of interdependent packages on hackage though
06:37:29 <mokus> it would be interesting to see a connectedness analysis of hackage
06:37:31 <djahandarie> edwardk, all you need right now is a giant list of all your packages.
06:37:45 <mreh> mokus, there are visualisations out there
06:37:59 <quicksilver> the visualations are dramatic but not really readable
06:38:11 <edwardk> djahandarie: i'm hoping to work on a new typeclassopaedia with byorgey at hac phi, that should emerge as a consequence ;)
06:38:18 <quicksilver> converting large highly connected graphs into something actually readable is quite hard.
06:38:21 <quicksilver> an open problem, even.
06:38:46 <edwardk> @hpaste
06:38:47 <lambdabot> Haskell pastebin: http://hpaste.org/
06:38:48 <djahandarie> edwardk, sounds good
06:38:56 <luite> when's hac phi again?
06:39:15 <mokus> I would think a live visualization tool would be the way to go - click on a node, that node moves to center and the layout drifts to something focused on that node
06:40:38 <edwardk> http://hpaste.org/49583 has the contents of my local haskell directory if it helps
06:41:07 <edwardk> i redacted a few unreleased items, so i think everything there except the kata and thc folders are publicly available
06:41:19 <edwardk> oh at the quant tools
06:41:28 <djahandarie> I usually use your github for a list but this is easier
06:41:37 <mreh> thc...
06:41:42 <mbuf> Trying to insert three text fields in a database, how to best do it? http://hpaste.org/49584
06:42:01 <edwardk> mreh: my toy 'turbo haskell' compiler
06:42:13 <edwardk> yes i'm aware of the silly acronym =)
06:42:18 <luite> a tracing jit?
06:42:39 <edwardk> eventually. right now its just trying to compile quick and dirty
06:42:54 <edwardk> with an eye towards supporting my various tracing schemes
06:42:57 <Botje> mbuf: your statements parse as (toSql r) !! 0
06:43:09 <Botje> mbuf: why not use "map toSql r" ?
06:43:14 <luite> ah interesting :) just haskell 98 for now?
06:44:01 <edwardk> luite: 2010 plus some obvious extensions when i last hacked on it
06:44:01 <mietek> Question
06:44:03 <mietek> http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/Control-Monad-Error.html
06:44:29 <mietek> In the first example, isn't using catchError in the calculateLength function a no-op?
06:44:37 <edwardk> luite: i may go the way of lhc and let ghc parse the surface syntax down to core for me first though
06:44:40 <parcs> :t ala reader
06:44:41 <lambdabot> forall r a b n' o'. (Newtype (Reader r a) (r -> a), Newtype n' o') => (((r -> a) -> Reader r a) -> b -> n') -> b -> o'
06:44:50 <edwardk> luite: but it isn't clear that that is more expensive than its worth
06:45:20 <mbuf> Botje, if I use [map toSql r], i get Couldn't match expected type 'SqlValue' against inferred type [SqlValue]
06:45:33 <Botje> mbuf: without the []
06:45:34 <edwardk> mietek: how so?
06:45:35 <Botje> just map toSql r
06:45:36 <luite> edwardk: are you just using haskell-src-exts in the current version?
06:45:48 <Botje> mietek: calculateLengthOrFail can, well, fial
06:45:59 <mietek> So?
06:46:03 <edwardk> luite: nah, a small handrolled parser
06:46:11 <mietek> It fails by returning an error wrapped in Left
06:46:13 <edwardk> luite: it has a long way to go
06:46:22 <mietek> If I understand correctly
06:46:24 <hatds> what's the story on exceptions in ffi code?  Can a C function called from haskell throw an exception back to haskell?
06:46:26 <mietek> And calculateLength does the same
06:46:31 <edwardk> luite: was using it to test my layout combinators, etc.
06:47:20 <mbuf> Botje, like this? run conn "INSERT INTO entries VALUES (?, ?, ?)" map toSql r, gives me Couldn't match expected type '[SqlValue'] against inferred type '(a -> b) -> [a] -> [b]'
06:47:36 <edwardk> one is using the OtherError, and its getting promoted to a StringTooLong error
06:47:51 <Botje> mbuf: yes, because you are giving 5 parameters to run
06:47:59 <edwardk> mietek: so its a fairly silly set of changes to the error, but they do change =)
06:48:00 <Botje> mbuf: run conn "..." (map toSql r)
06:48:00 <Botje> or
06:48:05 <Botje> mbuf: run conn "..." $ map toSql r
06:48:07 <luite> I think it's really interesting though, to see what a jit can do for haskell. I wonder if you'd still end up using something similar to stg
06:48:10 <mietek> edwardk: what? which line is this?
06:48:21 <mietek> edwardk: the entire definition of calculateLength is "calculateLength s = (calculateLengthOrFail s) `catchError` Left
06:48:24 <mietek> "
06:48:38 <edwardk> hrmm, perhaps you are right
06:48:41 <edwardk> that is silly
06:48:52 <mietek> Botje: ping
06:49:07 <mbuf> Botje, both don't work giving me errors
06:49:28 <Botje> mbuf: then what is the type of run?
06:49:50 <Botje> I assumed it was Connection->String->[SqlValue]->IO ()
06:50:11 <edwardk> calculateLength is pointless =)
06:50:11 <edwardk> guessing ross or andy wanted to show that you could use catchError
06:50:15 <mietek> Mhm
06:50:16 <edwardk> kinda silly
06:50:17 <mietek> Thanks
06:50:19 <mbuf> Botje, run  :: (IConnection conn) => conn -> String -> [SqlValue] -> IO Integer
06:51:18 <edwardk> i'll check my current repository to see if that issue still stands when i get a chance
06:51:51 <edwardk> it may be over in transformers though now
06:51:52 <Botje> mbuf: and toSql :: String -> SqlValue?
06:52:03 <Botje> mbuf: why does process accept a [[String]] ?
06:52:18 <cpa> :t (<=<)
06:52:18 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
06:52:21 <Botje> if it was [String] (which I thought it was) my code should work
06:53:21 <edwardk> ah nope, the bad example is still in the current mtl http://hackage.haskell.org/packages/archive/mtl/2.0.1.0/doc/html/Control-Monad-Error.html
06:53:27 <mbuf> Botje, toSql  :: (Data.Convertible.Base.Convertible a SqlValue) => a -> SqlValue
06:53:47 <Botje> mbuf: yes. okay. good
06:53:49 <mbuf> Botje, it is passed to it from another function, possible value of r is ["a", "b", "c"]
06:53:57 <Botje> mbuf: not according to your type.
06:54:12 <Botje> mbuf: your type says its [[String]], so [["a"], ["b"], ["c]] or something
06:54:28 <mbuf> Botje, let me paste the whole code
06:55:31 <mbuf> Botje, http://hpaste.org/49585
06:57:29 <Botje> ping :: [[String]] -> IO ()
06:57:31 <Botje> ping r = process [ [ x | x <-xs ] | xs <- r]
06:57:42 <Botje> this will pass a [[String]] to process, not a [String]
06:57:48 <mbuf> Botje, I see
06:58:00 <Botje> I think you want mapM_ process r
06:58:20 <Botje> which will take each of the [String] in r and pass it to process in turn
06:58:24 <Botje> and then execute the lot.
07:00:11 <mbuf> Botje, that is causing an error as well
07:01:38 <Botje> did you change the type of process?
07:22:16 <dmwit> [ [ x | x <- xs ] | xs <- r ] === [ xs | xs <- r ] === r
07:22:48 <DrSyzygy> dmwit: ... yes?
07:22:55 <Jafet> Lovely, isn't it.
07:23:03 <DrSyzygy> *pages up* Oh right. Now I see context.
07:23:18 <Jafet> You don't need context to appreciate that
07:23:32 <DrSyzygy> Jafet: It looked trivially obvious until I saw the context.
07:23:48 <Jafet> Try stating that for C!
07:23:51 <DrSyzygy> It's twice applying the monad laws.
07:24:06 <DrSyzygy> Jafet: I'd prefer not to.
07:24:11 <Jafet> I don't think he was invoking the monad comprehension
07:24:29 <DrSyzygy> Jafet: You don't need to. He was invoking list comprehension, which is a special case, using the monadic structure on []/
07:24:36 <DrSyzygy> s:/:.:
07:25:27 <DrSyzygy> In particular, he was using xs === [x | x <- xs] === do {x <- xs; return x} === xs >>= return
07:25:31 <dmwit> For C? Oh my.
07:25:52 <Ke> so there is no other haskell wrapper for opencl than opencl war
07:25:55 <Ke> raw
07:26:27 <Ke> it's actually worse than the original C interface
07:26:31 <Jafet> (Yeah, raw war is an apt description for opencl)
07:27:49 <mbuf> Botje, changed and compiles
07:27:51 <mbuf> Botje, thanks
07:28:07 <mbuf> Botje, just one error, that table entries has 4 columns but 3 values were supplied
07:32:17 <sm> th                   $-3.00       $-3.00
07:32:17 <sm>                                 assets:bank:7th               $3.00            0
07:32:17 <sm>                                 income:GSR                  $-15.25      $-15.25
07:32:17 <sm>                                 assets:bank:GSR              $15.25            0
07:32:19 <sm> 2011/01/03 nov collections de.. income:7th                 $-123.55     $-123.55
07:32:54 <roconnor> sm: wrong chan. :)
07:34:52 <sm_> lord! my ircs are going crazy!
07:35:48 * sm_ just accidentally apple-v'd a random data dump into a terminal window containing erc.. sorry
07:36:19 <roconnor> :)
07:36:47 <cpa> old school data leak :)
07:36:49 <mokus> i hate it when that happens, almost as much as i hate it when i tab over to GHCi and type :r, only to find that I tabbed to IRC instead
07:37:34 <sm> it has been happening a lot since I started using erc. I need some kind of safety belt, or will have to drop it
07:39:02 <sm> anyway, good morning everyone :)
07:39:09 <DrSyzygy> irssi has a confirm-this-paste if you exceed 5 or so lines of paste.
07:39:10 <roconnor> good morning
07:39:11 <Botje> mbuf: uh, then you need to specify only the columns you want, i guess.
07:39:12 <Ke> even openclraw homepage is broken
07:39:24 <Botje> alternatively you could pass 0 in the id's position
07:39:34 <sm> DrSyzygy: +1
07:39:57 <roconnor> sm: I used a trading account for the first time!  I withdrew some British Pounds from my French Euro account.
07:40:28 <sm> roconnor: very cool.. I wondered what that was about ? a transaction accounting for exchange rate change ?
07:40:47 <sm> or.. what ?
07:40:51 <roconnor> sm: up until now I've avoided doing this by paying things with a credit card and just writing down the price and currency that ended charged to my credit card or bank card.
07:42:11 <roconnor> sm: I'm following http://www.mscs.dal.ca/~selinger/accounting/tutorial.html#4
07:42:20 <sm> ah nice
07:42:38 <sm> that's some good writing
07:42:43 <sm> docs
07:43:16 <roconnor> It is really easy.  When you do a foregn exchange you buy and sell the two currencies from a trading account (you can have more than one if you like)
07:43:41 <roconnor> it can be used automatically keep track of capital gains and capital losses
07:44:17 <sm> and this is useful if you're holding the currency over time - but if you're just doing a transaction, where the money is converted on that day, you don't need it, right ?
07:44:37 <roconnor> Although I'm not using it for that.  I'm not sure how taxes on gains and losses for currency trading works if you are not actually trying to trade currency, but just are just traveling around buying things and getting paid.
07:45:23 <roconnor> sm: Right. That's why I've never used it before.  Because purchaces on a debit card or a credit card can be just valued at the date of the purchase.
07:45:33 <roconnor> sm: but this time I withdrew cash from an ATM
07:45:44 <roconnor> so that is means I'm holding currency over time.
07:46:25 <sm> you're.. tracking the fluctuation in value of the foreign currency in your wallet ?
07:46:51 <roconnor> no not exactly.
07:47:23 <roconnor> 2011/07/16 Barclay's Bank
07:47:24 <roconnor>     accounts:bank:lcl                              -57.80 EUR
07:47:26 <roconnor>     trading
07:47:27 <roconnor>     accounts:cash:russell                           50.00 GBP
07:47:50 <roconnor> Here I withdrew 50 Pounds from my Euro account
07:48:11 <roconnor> so 57.80 EUR was debited from my Euro account.
07:48:20 <roconnor> but those two transactions by themselfs don't balace.
07:48:27 * benmachine remembers wistfully the days when a euro was about 60p
07:48:31 <sm> they would.. it would infer the coversion rate.
07:48:51 <roconnor> so the trading account holds the other half to balance the tranactions.
07:49:34 <roconnor> but I don't store an exchange rate explicitly anywhere.
07:49:54 <roconnor> though you can infer the effective exchange rate on the tranasction.
07:50:09 <sm> I seee..
07:50:35 <roconnor> sm: as you put more transactions into the trading account you can end up with strictly positive or strictly negative balances in the tranding account.
07:51:11 <roconnor> these values correspond to capital gains or capital loses incurred from currency trading.
07:51:25 <DrSyzygy> roconnor: Which correspond to how screwed you got by the cross-currency transactions?
07:51:41 <sm> roconnor: interesting
07:51:55 <roconnor> DrSyzygy: ya, I guess you are more likely to incur captial losses :D
07:52:09 <sm> I'll have to ponder that some more
07:52:20 <roconnor> DrSyzygy: but there is some possiblity you can use this to offest some capital gains on your taxes.
07:52:33 <roconnor> sm: the article does a pretty good job explaining it.
07:52:49 <sm> I've read it twice, time for #3 :)
07:52:57 <roconnor> sm: but if don't do a lot of stock trading or currency trading, then you don't need to know this.
07:53:03 <roconnor> sm: :D
07:53:12 <sm> but that's pretty cool. Unplanned feature! :)
07:54:14 <roconnor> sm: BTW, this method isn't the offical SSAP 20 method; it is much better :D
07:54:23 <sm> debconf is tracking multi-currency expenses, maybe this will be of interest to Clint
07:58:49 <BlankVerse> how do i set darcs send to use mutt instead
08:03:24 <sm> BlankVerse:  --sendmail-command
08:05:27 <fragamus_> dmwit: hey man
08:05:54 <dmwit> fragamus_: how
08:06:28 <fragamus> i enjoyed your type driven development
08:06:50 <fragamus> it was good training
08:07:03 <mornfall> Hm. The Cabal 1.10 "detailed-1.0" interface is not compatible with any of the existing testing packages that Hackage has?
08:07:13 <mornfall> Ideally test-framework.
08:07:15 <dmwit> great!
08:08:14 <roconnor> Ooh, I like this term TDD, Type Driven Development.
08:08:16 <Enigmagic> mornfall: i don't think so... i looked at this the other day :\
08:08:20 <roconnor> this is great!
08:08:36 <mornfall> That's seriously not cool.
08:09:18 <mornfall> Well, stdio-exitcode-1.0 it is, then.
08:09:22 <Enigmagic> mornfall: exitcode-stdio-1.0 works fine though.
08:09:28 <mornfall> Yeah.
08:09:48 <mornfall> Although that's just a syntactic shortcut for what we've been using for half a decade. ;P
08:11:00 <Jafet> roconnor, let's keep this channel clean and agda/coq free
08:11:41 <fragamus> let's not
08:11:52 <roconnor> Jafet: Epigram?
08:13:54 <fragamus> dmwit I have been struggling to use the function we made
08:14:51 <fragamus> I would like to paste an example program associated with the ListT done right, and modify it to use the function we made
08:15:03 <fragamus> does that work for you?
08:15:45 <fragamus> I am on the verge of being able to really use Haskell for real work
08:17:10 <fragamus> dmwit: are you there
08:18:51 <erus`> it would be foolish for me to use haskell todo REAL work, i am far more productive in other languages
08:19:02 <erus`> but i love haskell, i use it for my hobby projects
08:19:20 <dmwit> fragamus: I'm here.
08:19:26 <dmwit> fragamus: Hit me.
08:19:30 <fragamus> kk
08:19:40 <benmachine> @slap dmwit
08:19:40 * lambdabot places her fist firmly on dmwit's jaw
08:19:48 <benmachine> hth
08:20:49 <dmwit> thx lol
08:20:51 <kmc> erus`, you'll get there
08:20:53 <kmc> it may take years though
08:22:19 <fragamus> http://hpaste.org/49589
08:22:53 <fragamus> i am going to use Haskell for real work FOR THE LOVE OF GOD
08:23:04 <benmachine> I used haskell to script database queries
08:23:12 <benmachine> everyone else was just like "sure whatever"
08:24:12 <quicksilver> I used haskell to translate the nonsense that MS Word things is HTML into something we could actually include in our website / CSS
08:24:19 <quicksilver> s/things/thinks/
08:25:01 <dmwit> fragamus: Do you have a specific question...?
08:25:01 <danharaj> My openGL code is so buggy, it's displaying patterns that look like a Mondrian painting.
08:25:52 <quicksilver> danharaj: call it a feature!
08:26:45 <fragamus> dmwit: yes... I want to transform the example into one that produces many outputs.  I dont care if they have the mathematical properties that the current answer has. I dont care what these multiple answers mean. it is only an example.  I then want to print out these answers
08:27:35 <danharaj> http://i.imgur.com/XuDpe.png
08:27:38 <danharaj> Uncanny, I think.
08:28:04 <benmachine> the intersections screw with my eyes :(
08:28:14 <danharaj> It's also a psych weapon
08:28:15 <quicksilver> danharaj: you should put that on one of those "sell your own art" websites
08:28:21 <quicksilver> danharaj: I bet you would make a few $ in prints.
08:28:22 <danharaj> let me call up the DoD
08:28:38 <dmwit> fragamus: Well... what's the type of "force" again?
08:28:39 <danharaj> quicksilver: I will start a new trend. Accidental programmer art.
08:29:02 * benmachine has seen accidental programmer art before
08:29:05 <benmachine> (admittedly not for sale)
08:29:09 <danharaj> By the way, that's supposed to be the letter 'A'
08:29:17 <benmachine> hah
08:29:24 <Guest90868> hi all..i have been reading real world haskell as well as paging through learn you a haskell for great good and came across lines that start with {-- snippet somename --}
08:29:30 <Guest90868> what is this? is it just a comment?
08:29:33 <quicksilver> yes.
08:29:36 <fragamus> force :: (Functor m, Monad m) => m (MList' m a) -> m [a]
08:29:39 <Guest90868> or some sematics of haskell?
08:29:47 <Eelis> if l::[Int] and m::Maybe Int, what's a better way to write  [x + y | Just x <- [m], y <- l]  ? i dislike putting m in a list only to pull it out again immediately
08:29:48 * sipa once created a weird fractal by making a sign error in the implementation of the "jurassic park" fractal
08:30:02 <rekahsoft> ugh sorry for the nick change btw..idk what happened but irssi didn't autoset it :S
08:30:14 <danharaj> ... and I change a single token and I see the A on the screen. But it's rotated. Yay! Progress.
08:30:16 <benmachine> http://www.chiark.greenend.org.uk/~sgtatham/filigram/
08:30:26 <ion> > {- this is a comment -} 42
08:30:26 <lambdabot>   42
08:30:54 <rekahsoft> ion: aww..multiline comment in haskell i presume?
08:31:00 <quicksilver> > (:[{- monkeys eat comments -}]) 42
08:31:01 <lambdabot>   [42]
08:31:20 <ion> rekahsoft: yes
08:31:24 <ion> But also inline commen
08:31:25 <ion> t
08:31:39 <danharaj> It always throws me off that if you put a symbol right after {-, GHC interprets that as an operator instead of a comment block.
08:31:49 <dmwit> > {- comments can be {- did you know that comments can be nested? -} nested in Haskell -} 42
08:31:50 <lambdabot>   42
08:32:10 <danharaj> > {- If we all talk like this, lambdabot can't spy on us. -} 1
08:32:10 <lambdabot>   1
08:32:18 <rekahsoft> ion: alright simple enough lol..
08:32:24 <ion> > let {-* = --*; --* = 42 in {-*
08:32:25 <lambdabot>   <no location info>: unterminated `{-'
08:32:27 <rekahsoft> ion: thanks
08:32:44 <ion> > let --* = 42 in --*
08:32:44 <lambdabot>   <no location info>: parse error on input `--*'
08:32:48 <danharaj> > {-+ test test +-}
08:32:48 <lambdabot>   not an expression: `{-+ test test +-}'
08:32:49 <ion> err, whatever
08:33:02 <danharaj> > {-+ test test +-} 1
08:33:02 <lambdabot>   1
08:33:04 <danharaj> huh
08:33:07 <fragamus> > {- I love you lambdabot. If you love me too, say 42 -} 42
08:33:07 <lambdabot>   42
08:33:10 <danharaj> I guess it was something else that threw me off.
08:33:21 <ion> Oh, i was brainfarting. Of course operators can’t be used like that.
08:33:31 <danharaj> All we know in the end is, I am a confused person.
08:33:43 <ion> > let --* = (+) in 42 --* 1
08:33:43 <lambdabot>   <no location info>: parse error on input `--*'
08:34:06 <ion> > let (--*) = (+) in 42 --* 1
08:34:06 <lambdabot>   43
08:34:38 <saml> hello
08:34:52 <dmwit> how
08:35:04 <saml> how do you express gates?  a gate have multiple input ports and output ports.. and wires connect gates
08:35:12 <saml> data Gate = ?
08:36:48 <dmwit> type Gate = [Input] -> [Output]?
08:37:00 <ion> data Gate = Gate { gateInputs :: [Port], gateOutputs :: [Port] }; newtype Wire = Wire [Port]
08:37:42 <JuanDaugherty> prolly some package for circuit stuffs
08:37:55 <saati> what is newtype and how it differs from data?
08:38:22 <dmwit> It only allows one constructor, but that constructor never actually resides in memory.
08:38:29 <saml> hrm.. [Port] not good
08:38:37 <c_wraith> the constructor also can only have one argument.
08:38:42 <Jafet> It's a free type!
08:38:47 <dmwit> So "newtype Foo a b c = Bar baz" is much like "data Foo a b c = Bar !baz"
08:39:04 <c_wraith> basically, newtype creates a compile-time alias for a type, that's not interchangeable.  But it's only compile-time
08:39:19 <c_wraith> so alias is the wrong word.
08:39:22 <dainanaki> is there any printf type thing for use with bytestrings?
08:39:30 <c_wraith> it really does create a *new* type with the exact same implementation
08:39:47 <c_wraith> dainanaki: not really.  bytestrings aren't really designed to be printable
08:39:57 <c_wraith> dainanaki: there is a printf-like library for text, though
08:39:57 <JuanDaugherty> the hardware section at hackage
08:40:33 <hirsch__> Can you give me some feedback to my image polar-coordinate transformation with repa? https://gist.github.com/1109668
08:40:38 <dmwit> saml: You really didn't give nearly enough context to nail down the answer to such an open-ended design question.
08:41:12 <hirsch__> I'm a newbie and some parts seem kind of hacky
08:41:16 <saml> yah i r sorri
08:41:36 <acfoltzer> saml: you may want to give Kansas Lava (http://www.ittc.ku.edu/csdl/fpg/Tools/KansasLava) or Cryptol (www.cryptol.net) a look if you're serious about hardware
08:42:02 <saml> it's not about hard ware.. data flow programming
08:42:35 <edwardk> saml: kansas lava uses what is probably the nicest approach. observable sharing makes for nice dsls
08:42:53 <saml> let me check it out thanks
08:42:54 <fragamus> dmwit: so im still trying to see exactly how to apply this function
08:43:33 <dainanaki> c_wraith, is there a way to get blaze builders to output to data.text?
08:44:34 <edwardk> saml: the data-reify package provides the guts of it
08:44:44 <edwardk> saml: i use it down in the bowels of my ad package as well
08:44:57 <dmwit> fragamus: Do you remember its type?
08:45:14 <fragamus> force :: (Functor m, Monad m) => m (MList' m a) -> m [a]
08:45:27 <fragamus> to be honest I dont understand its type
08:45:55 <dmwit> fragamus: That's the type ghci will probably give you, but you should read it as this type instead:
08:46:06 <fragamus> why does the m appear twice on the left of the arrow
08:46:10 <dmwit> force :: (Functor m, Monad m) => MList m a -> m [a]
08:46:15 <ion> I don’t understand why one would need a Functor constraint in addition to the Monad constraint, as Monad depends on Functor. ...oh, wait. Prelude wasn’t fixed yet.
08:46:21 <fragamus> ok that i can understand
08:46:40 <fragamus> wait lemme try it...
08:46:48 <dmwit> fragamus: Expanding the definition "type MList m a  = m (MList' m a)" one step gets back to the type you said. =)
08:47:03 <edwardk> MList' is an intermediate cell in the MList. you wrap it in m to give it a monadic side-effect giving an MList.
08:47:41 <edwardk> the MList' m a indicates that to get to the subsequent cons cells there is a monadic action associated.
08:50:13 <accel> God chose what is weak in the world to shame the strong
08:50:18 <accel> wrong channel
08:50:23 <accel> data ModRing a = ModRing a !Int deriving (Show, Eq)
08:50:25 <accel> in the code above
08:50:30 <accel> how do I need to modify it
08:50:39 <accel> to say: type a needs to also support Show/Eq ?
08:50:47 <dmwit> You don't.
08:51:01 <dmwit> You change the type signatures of the users to demand those types as necessary.
08:51:10 <Jafet> Be ashamed; be very ashamed
08:51:11 <dmwit> s/types/constraints/
08:51:13 <edwardk> accel: you don't. you put those constraints on the instances or methods
08:51:24 <accel> hmm, I misread my ghc error message
08:51:33 <edwardk> accel: also note that your types aren't going to enforce that you only try to add two values with the same modulus
08:51:36 <accel> damn you guys are sharp
08:51:50 <accel> edwardk: ya, that has to be checked dynamically
08:51:55 <accel> unless you have some brilliant idea
08:51:58 <edwardk> accel: you can do better actually
08:52:08 <accel> how?
08:52:16 <edwardk> accel: http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf
08:52:24 <edwardk> which i turned into a package on hackage, reflection
08:52:52 <edwardk> http://comonad.com/reader/2009/clearer-reflection/ describes the use (using an older version of the API)
08:52:56 <accel> none of those guys are at rutgers
08:53:00 <accel> why is the paper hosted on their server?
08:53:13 <edwardk> ken shan used to be
08:53:29 <Jafet> It's in Shan's directory, apparently...
08:53:38 <accel> this sounds interesting
08:53:47 <accel> but I thikn it's premature optimization before I get my irreducible polynoi al library up
08:53:57 <accel> I will look back at this, and bother you once I get the basics working
08:54:01 <accel> thanks for the link though :-)
08:54:04 <edwardk> accel: i'm putting one of those up soon too =)
08:54:11 <edwardk> accel: it'll be part of the algebra package
08:54:24 <edwardk> accel: i need them for talking about pade approximants
08:56:40 <accel> I would totally use your packages
08:56:42 <accel> except
08:56:48 <accel> I'm implementing mine purely to Reinvent the Wheel
08:56:53 <edwardk> sure
08:56:55 <accel> to convince myself these fucking abstract algorithmsa ctually work
08:57:01 <edwardk> just thought i'd mention it =)
08:57:19 <accel> there's only so many hours I'm willing ot read something before it's "time to fucking implement it now"
08:57:35 <edwardk> =) what material are you building off of?
08:57:42 <arcatan> glxblt
08:57:51 <fragamus> dmwit: i need help
08:58:22 <edwardk> there is an alarming shortage of vowels in that name ;)
08:59:30 <dmwit> fragamus: Alright.
08:59:45 <accel> none ... Victor Shoup's online book on computational number theory
08:59:56 <fragamus> runMyTest = force . myTest
09:00:04 <fragamus> i tried that ^^^^
09:00:27 <dmwit> fragamus: Close.
09:00:34 <dmwit> fragamus: You need a bit of runListT in there, though.
09:00:44 <chrisdone> evening chaps
09:00:56 <dmwit> runListT :: ListT m a -> MList m a
09:01:24 <dmwit> (Which is only in there because H98 doesn't let you declare typeclass instances on type aliases.)
09:01:43 <ski> preflex: xseen Eduard_Munteanu
09:01:43 <preflex>  Eduard_Munteanu was last seen on freenode/#haskell 11 hours, 24 minutes and 54 seconds ago, saying: And you get a few things for free.
09:01:54 <kmc> silly H98
09:02:03 <accel> op :: (Show a), (ModInt a) => (a -> a -> a) -> (ModRing a) -> (ModRing a) -> (ModRing a)
09:02:06 <accel> the , is a syntax error
09:02:17 <accel> how do I say, the type a is of class Show and also of class ModInt ?
09:02:23 <ski> siracusa : if you wondered about edwardk's reflection, he's here now ..
09:02:24 <kmc> (Show a, ModInt a)
09:03:12 <siracusa> ski: ?
09:03:29 <edwardk> op :: (Show a, ModInt a) => (a -> a -> a) -> ModRing a -> ModRing a -> ModRing a
09:03:39 <edwardk> (note the ()'s around ModRing a were also redundant
09:03:50 <acowley> edwardk: I've gotten myself confused using ad
09:03:54 <edwardk> application binds tighter than (almost) anything
09:03:58 <edwardk> acowley: how so?
09:04:01 <acowley> edwardk: One issue is that the existentials make it hard to write types
09:04:16 <ski> siracusa : "<ski> accel : i think you can also reify `5' to a type using edwardk's reifying trick" , "<siracusa> ski: What is this trick?"
09:04:18 <accel> kmc: nice; thanks
09:04:19 <acowley> edwardk: I wanted to optimize an energy function over a weighted graph laplacian
09:04:24 <fragamus> runMyTest = force . runListT . myTest
09:04:28 <edwardk> yes, but they also keep you from accidentally confusing perturbations if you differentiate a function that uses differentiation
09:04:29 <fragamus> that^^^?
09:04:29 <accel> edwardk: understood
09:04:40 <hatds> does anyone know what (Typeable =>) or (Data =>) function would let me write "showConstructorName :: a -> String"
09:05:02 <accel> kmc, edwardk : what is the (Show a, ModInt a) part of the type signature called?
09:05:07 <kmc> accel, context
09:05:09 <acowley> edwardk: I appreciate (at least part of) their utility, but it makes it hard to see what's going on. My usual approach when things aren't working is to make darn sure I can write the types
09:05:12 <edwardk> accel: context
09:05:19 <kmc> > toConstr (Just 3) -- hatds
09:05:20 <lambdabot>   Just
09:05:29 <hatds> :t toConstr
09:05:30 <lambdabot> forall a. (Data a) => a -> Constr
09:05:38 <edwardk> acowley: you can. just get rd of the UU nonsense and program with the quantifiers visible
09:05:40 <quicksilver> > let showConstructorName = takeWhile (/= ' ') . show in showConstructorName (Just 3)
09:05:43 <lambdabot>   "Just"
09:05:46 <quicksilver> ^^ ;)
09:05:48 <ski> > fix toConstr
09:05:49 <lambdabot>   No instance for (Data.Data.Data Data.Data.Constr)
09:05:49 <lambdabot>    arising from a use of ...
09:05:56 <ski> :/
09:05:59 <ski> > toConstr not
09:06:00 <lambdabot>   *Exception: toConstr
09:06:05 <hatds> thank you
09:06:06 <siracusa> ski: Ah, thanks but after looking at the code I lost interest :-P
09:06:17 <ski> siracusa : i see
09:06:21 <kmc> heh, (Bool -> Bool) is an instance of Data?
09:06:27 <ski> apparently
09:06:33 <edwardk> grad' :: (Traversable f, Num a) => (forall s. Mode s => f (AD s a) -> AD s a) -> f a -> (a, f a)
09:06:41 <acowley> In any case, I have a vector of labels that are passed to an energy function, and I wanted partial derivatives with respect to the labels
09:06:57 <taotree> The example on this link for eval returns Nothing... why?: http://hackage.haskell.org/packages/archive/plugins/1.5.1.4/doc/html/System-Eval-Haskell.html
09:06:59 <edwardk> then call grad
09:07:03 <edwardk> or grad'
09:07:08 <acowley> that's what I'm doing
09:07:14 <dmwit> fragamus: Looks pretty good to me, what does GHC say?
09:07:19 <acowley> but I keep getting zero gradient
09:07:22 <accel> http://hpaste.org/49590 <-- how do I add "context" to the : instance Ring (ModRing a) where .... declaration? I want to add in the context that "type a" is Show, ModInt, Ring
09:07:28 <kmc> taotree, 'Nothing indicates typechecking failed'
09:07:33 <acowley> which strongly suggests I've done something horrifically stupid
09:07:40 <fragamus> seems to work
09:07:45 <acowley> I'll try to write up a simpler version
09:07:45 <edwardk> probably. have you got code you can hpaste?
09:07:46 <taotree> kmc, fair enough, but... it is the example for the library, shouldn't it work?
09:07:49 <fragamus> dmwit: THANK YOU!!!!!!!!
09:08:05 <kmc> taotree, yeah, I don't know why it's not working
09:08:07 <edwardk> instance (Show a, ModInt a, Ring a) => Ring (ModRing a)
09:08:16 <fragamus> I don't understand haskell, but with your guidance, I can use it now
09:08:20 <kmc> taotree, maybe you can get 'hint' to work instead
09:08:36 <accel> edwardk: worked. Thanks!
09:08:44 <taotree> kmc, would rather have compiled and not interpreted
09:08:44 <fragamus> and after several years of using it, I can understand it
09:08:59 <kmc> ah
09:09:04 <edwardk> accel: you read instances right to left.  to get Ring (ModRing a) you need Show a, ModInt a, Ring a.
09:11:01 <parcs> i really wish libraries did the fromIntegral/liftIO stuff for us
09:11:30 <fragamus> dmwit: thanks
09:11:51 <dmwit> cheers
09:12:36 <kmc> taotree, hmm, it doesn't work in my ghci 7.0.3 either
09:12:39 <kmc> i get an internal error
09:12:59 <taotree> kmc, bug then?
09:13:04 <kmc> don't know
09:13:08 <accel> Given: "data ModRing = ModRing !Int !Int". Question: "Is there a way to define PrimeField" so that for type: "PrimeField :: ModRing Int" , and for constructor: "PrimeField a b = ModRing a b"
09:13:09 <kmc> my bug is different from yours i guess
09:13:12 <kmc> were you using ghci?
09:13:21 <taotree> yes... I'll try ghc
09:13:25 <parcs> :t fmap (join (***) fromIntegral)
09:13:26 <lambdabot> forall b c (f :: * -> *). (Integral b, Num c, Functor f) => f (b, b) -> f (c, c)
09:13:28 <accel> kmc does not write bugs; there are only times where ghc fails to understand kmc
09:13:40 <fragamus> dmwit: if I wanted to pay you for in person training would that be possible?
09:13:54 <accel> can you pay in bitcoins?
09:14:24 <kmc> accel, "PrimeField :: ModRing Int" is impossible because PrimeField is not one of the ModRing constructors
09:14:35 <hatds> shoot, you can't 'derive Data' for GADTs
09:14:38 <accel> http://www.haskell.org/haskellwiki/Type <-- wtf, according to this, data decalrations can have context
09:14:41 <kmc> also ModRing doesn't take a type parameter
09:14:49 <kmc> hatds, even with StandaloneDeriving ?
09:14:55 <parcs> accel: not in ghc 7.2
09:15:10 <hatds> kmc: I didn't try that, why would it help?
09:15:25 <taotree> kmc, ghc, I get same thing. However... I may be using a slightly different version of 7.0.3 than you are that has a certain bug fixed
09:15:31 <kmc> hatds, i think it's the only way to derive stuff for GADTs
09:15:37 <kmc> i'm not sure
09:15:44 <kmc> but i'd believe that Data is disallowed either way
09:16:53 <edwardk> accel: that was removed from the language because they don't actually help at all
09:17:02 <edwardk> accel: they don't do what you expect and cause you lots of problems
09:17:15 <edwardk> accel: they don't give you access to those instances, they just create overhead
09:17:15 <accel> parcs , edwardk : understood.
09:17:20 <kmc> is that contexts on data types, and/or contexts on (non-GADT) constructors?
09:17:38 <edwardk> hatds: yeah you can't derive most anything for a GADT
09:17:45 <accel> I don't know. I just found a link, and it looked like what I was asking for.
09:17:53 <thoughtpolice> kmc: context on the data types, i believe
09:17:53 <kmc> also is this by default in GHC 7.2 (making it less standards-compliant) or just something to switch it off?
09:18:34 <thoughtpolice> people wanted it for HList for example, because it has things of the nature 'data Constraint x => FooBar x' or whatever, while 'FooBar' was uninhabited. that's just a simple example
09:18:42 <thoughtpolice> i remember people complaining when this broke things though.
09:18:46 <hatds> there should be a separate class for showConstr that is derivable for GADTs
09:19:20 <kmc> i mean the GHC devs can't just say "Haskell doesn't have this feature any more"
09:20:06 <edwardk> kmc: haskell 2011 or was it 2010 removed them
09:20:10 <kmc> really?
09:20:11 <quicksilver> there was a discussion about permitting standalone deriving for GADTs
09:20:16 <accel> they don't need to; the need only say "we believe in purity; all haskell developers who want that feature are imperative spies"
09:20:17 <kmc> i thought there was no Haskell 2011
09:20:30 <edwardk> accel: it was what you were asking for, but it doesn't do what you want it to do.
09:20:36 <quicksilver> with the proviso that, if it doesn't work, you'll get a completely incomprehensible error message.
09:20:50 <thoughtpolice> hatds: http://hackage.haskell.org/trac/ghc/ticket/3012
09:20:55 <kmc> oh, this is the one thing they did in Haskell 2011
09:20:57 <kmc> :D
09:20:59 <d7> :(
09:21:00 <thoughtpolice> hatds: tl;dr GHC should be able to 'derive show' for simple GADTs
09:21:02 <Igloo> datatype contexts have been removed from the standard, but there hasn't been a new versino of the standard released since then
09:21:11 <d7> GHC is so broken under mac osx lion.
09:21:13 <kmc> so it's only in Haskell HEAD :D
09:21:18 <d7> And GHCI is even more so.
09:21:20 <Igloo> Right  :-)
09:21:25 <edwardk> kmc: yeah
09:21:26 <thoughtpolice> oh wow
09:21:32 <thoughtpolice> that was changed a looooooooooong time ago actually
09:21:39 <thoughtpolice> "Changed 2 years ago by simonpj"
09:21:44 <edwardk> kmc: basically it lets you start to talk about possibly using Complex Int as gaussian integers, etc ;)
09:21:56 <chrisdone> derive show for gadts worked a while ago
09:22:18 <kmc> i'm impressed by what GHC can derive with StandaloneDeriving
09:22:28 <thoughtpolice> d7: yea, there have been fixes made in GHC HEAD to accomodate Lion/XCode changes
09:22:29 <kmc> deriving instance (Show (f (Mu f))) => Show (Mu f)
09:22:46 <d7> thoughtpolice: I'd try and contribute but some of these are genuinely weird linker problems.
09:22:56 <d7> thoughtpolice: So the current suggestion is to build HEAD and use that
09:22:58 <d7> ?
09:23:56 <thoughtpolice> d7: it has to do with the fact that A) gcc on lion is no longer 'really' GCC and partially that Lion now uses PIE-style executables for everything. also, there are other obscure linker things relating to the fact libffi doesn't know about compact mach-o exceptions, etc
09:24:05 <kmc> mmm, pie
09:24:06 <hatds> I really need showConstr and not show, there isn't a reasonable show instance even doing it by hand
09:24:14 <thoughtpolice> most of the error messages should be fairly harmless I think honestly
09:24:19 <kmc> hatds, and you can't derive Data even stand-alone?
09:24:33 <thoughtpolice> d7: you can build GHC 7.0.4 with the xcode from lion
09:24:35 <thoughtpolice> but you have to do
09:24:36 <kmc> maybe you can use http://hackage.haskell.org/packages/archive/derive/2.5.2/doc/html/Data-Derive-Data.html
09:24:39 <ion> > groupBy ((==) `on` toConstr) [Just 0, Just 1, Nothing, Nothing, Just 2, Just 3]
09:24:40 <lambdabot>   [[Just 0,Just 1],[Nothing,Nothing],[Just 2,Just 3]]
09:24:40 <hatds> kmc: I'm stuck trying to get typeable to derive stand-alone at the moment
09:24:42 <thoughtpolice> ./configure --use-gcc=gcc-4.2
09:24:46 <ski> accel : you can have contexts on `GADT'-style constructors, and it's useful
09:24:52 <d7> thoughtpolice: I see.
09:25:01 <thoughtpolice> d7: the thing is in xcode 4.1 or whatever they made 'gcc' a symlink to 'llvm-gcc' and relegated real gcc to 'gcc-4.2'
09:25:06 <thoughtpolice> llvm-gcc doesn't work with GHC atm
09:25:26 <kmc> GCC 4.3 (compatible; Microsoft Internet Explorer)
09:25:30 <d7> thoughtpolice: Okay. My old binary from 10.6 is clearly broken.
09:25:36 <d7> Esp ghci
09:25:42 <thoughtpolice> youch :(
09:25:46 <thoughtpolice> people have had varying results with this
09:25:47 <d7> which is sort of like holding a lit firecracker with a fuse of indeterminate length.
09:25:57 <thoughtpolice> some people have claimed its worked fine, others have had lots of issues
09:25:58 <thoughtpolice> *sigh*
09:26:16 <d7> Have you ever seen ghci run out of memory and crash when you have left it alone for 5m? :)
09:26:30 <ski> accel : what is not really very useful is having a context on a non-GADT-style `data' declaration .. i *might* have been useful, if it did the same as for GADTs, but that's not what it does, according to the standard, so it's not very useful
09:26:37 <d7> It's still responsive, but clearly something bad is happening in the background. :)
09:26:47 <thoughtpolice> it took 5 minutes to crash? like a segfault? see kids, that's why memory corruption is scary
09:27:02 <thoughtpolice> oh, just broked really badly, not a segfault
09:27:35 <edwardk> ski: occasionally, just not for his use case.
09:28:19 <ski> edwardk : well, i didn't say "completely useless" :)
09:28:46 <edwardk> accel: it seems a little foreign at first to move all the classes away from the data you're manipulating, but it'll become second nature eventually =)
09:28:54 <ski> (iirc, someone wanted a context on a type with zero constructors)
09:30:19 * ski got MetaML to compile :)
09:30:58 <thoughtpolice> ski: is that like metaocaml?
09:31:14 <ski> it's more like MetaOcaml is like MetaML :)
09:31:35 <ski> the source i compiled is roughly ten years old
09:32:18 <thoughtpolice> oh, wow haha. i think at one point someone here was getting an old version of cayenne working a while back.
09:33:03 <ski> (and i had to fix fewer incompatibilities between the old Standard Basis Library of then, and the current one than one might expect)
09:33:39 <ski> thoughtpolice : you don't remember who that was, by any chance
09:33:54 * ski would like to play some with LazyML and HBC, as well
09:34:16 <ski> thoughtpolice : .. ?
09:35:57 <thoughtpolice> ski: oh, no
09:36:04 <thoughtpolice> actually, was it copumpkin perhaps?
09:36:12 <copumpkin> wat
09:36:15 <copumpkin> noes
09:36:18 <thoughtpolice> :(
09:36:34 <thoughtpolice> ski: oh! it was mmorrow! i remember now
09:36:44 <copumpkin> the mmissing mmorrow
09:36:52 <thoughtpolice> but unfortunately mmorrow has vanished, so we're not much better off anyway :(
09:36:53 <djahandarie> preflex, seen mmorrow
09:36:53 <preflex>  mmorrow was last seen on #ghc 1 year, 190 days, 13 hours, 55 minutes and 55 seconds ago, saying: * mmorrow is rtfm'ing
09:37:02 * chrisdone misses om nom nommorrow
09:37:32 <chrisdone> maybe he's reading The Never Ending Story and got to a good bit
09:41:07 <wuseldusel> hey all :D
09:41:16 <Egbert9e9> will everything i write on hpaste be there when i die?
09:41:37 <chrisdone> was hpaste bot kicked?
09:41:49 * ski . o O ( Remembering brings on sorrow -- considering jolly good mmorrow -- is there anyone we could borrow ? )
09:42:04 <thoughtpolice> chrisdone: it's on vacation, edwardk came by and made his life really hard
09:42:19 <chrisdone> ah, i guess it was being abused by spammers
09:42:33 <copumpkin> chrisdone: yeah, I did that, sorry
09:42:36 <thoughtpolice> chrisdone: how much traffic does hpaste get?
09:42:37 --- mode: ChanServ set +o copumpkin
09:42:47 --- mode: copumpkin set -b *!~hpaste@unaffiliated/chrisdone
09:42:57 <edwardk> man i would have figured hackagebot would have gotten the axe before hpaste given my antics ;)
09:43:00 <ski> (now it's your to turn reminisce on TheHunter ..)
09:43:13 <thoughtpolice> chrisdone: like in a month, sorry, should have given that a scope
09:43:35 <sm> edwardk: don't shoot the messenger!
09:43:40 <copumpkin> did that work?
09:43:40 <copumpkin> my client didn't show me a mode change, but claims the ban list no longer contains it
09:43:47 <djahandarie> Yes
09:43:51 <Taslem> Would there be any real advantage of, for instance, making the global random function completely pure?
09:44:12 <Rednael> wuseldusel
09:44:17 <erus`> yeah it will scare away any newbies
09:44:18 <ski> Taslem : how do you mean ? it is pure.
09:44:22 --- mode: copumpkin set -o copumpkin
09:44:25 <wuseldusel> :D
09:44:40 <chrisdone> thoughtpolice: it gets queried by search engine crawlers more or less constantly. in may it had 19,000 page views according to g analytics
09:44:48 <sm> edwardk: has the shelling stopped ?
09:44:58 <edwardk> sm: for the nonce
09:44:59 <djahandarie> copumpkin, search engine crawlers support javascript?
09:45:04 <copumpkin> ?
09:45:09 <edwardk> sm: i'll probably resume bombardment tonight
09:45:14 <djahandarie> Stop that copumpkin
09:45:20 <djahandarie> chrisdone, search engine crawlers support javascript?
09:45:24 <sm> it kept going far longer than I thought possible :)
09:45:25 * copumpkin is confused
09:45:37 <edwardk> sm: i only have about 80 packages =P
09:45:40 <erus`> djahandarie: yeh the spam bots are clever now
09:45:44 <erus`> skynet
09:45:50 <edwardk> sm: well 60 or so haskell-side
09:46:05 <erus`> the post haskell snippits that display viagra ads
09:46:08 <chrisdone> djahandarie: no. those are two orthogonal facts. search engines are on it constantly. human-wise, there were 19k visits in may. well, i don't know if search engine crawlers support js, i doubt it
09:46:16 <djahandarie> Ah, alright :p
09:48:14 * sm has a sudden visual: the attack on hogwards in latest harry potter movie
09:48:19 <chrisdone> messing about with this idea http://hpaste.org/49593
09:48:54 <chrisdone> i don't think there are existing haskell web gui libraries like this
09:49:11 <copumpkin> ooh a web monad
09:49:26 * ski wants a `Bew' monad
09:49:43 <chrisdone> haha
09:49:52 <djahandarie> ski, that would have to be a comonad
09:50:08 <ski> hm, yeah, i was just starting to recall that
09:50:10 <edwardk> ski: sounds effectful
09:50:31 <chrisdone> ``Bew! Bew! Bew!'', said little Jimmy.
09:50:33 <ski> or, hm
09:50:54 <ski> no, it's not copointed, so can't be a comonad
09:51:09 <edwardk> a Bew extend then
09:51:11 <edwardk> =)
09:51:18 <chrisdone> you define the UI as a tree. you wrap up nodes in the tree with predicates that say when it needs to be updated
09:51:23 <ski> `scaffold' is perfectly fine, though
09:51:38 <edwardk> ski: it usually is
09:51:51 <chrisdone> after interaction with the GUI the library goes through the tree asking it what needs to be updated, and, in the case of a web site, sends updates to those nodes in the tree that changed
09:53:01 * chrisdone is going to implement a bit of JS to do the updating to try this
09:53:53 * chrisdone is a little disturbed that most of Snap's functions are in Snap.Types
09:54:54 <copumpkin> lol
09:55:45 <sm> chrisdone: sounds nifty
09:59:02 <luite> chrisdone: have you seen the 0.6 code on github?
09:59:28 <chrisdone> luite: 0.6 of quoi?
09:59:32 <luite> snap
09:59:43 <chrisdone> ah, nope
09:59:45 * chrisdone looks
09:59:47 <luite> it has a lot of changes in the extension framework
10:00:12 <chrisdone> what like? :o
10:00:47 <luite> don't know exactly, it's based on something called snaplets
10:00:50 <chrisdone> looks the same to me
10:00:55 <chrisdone> oh, snaplets. sounds neat
10:01:31 <luite> I'm mainly writing coffeescript these days, trying to finish a site instead of learning new and interesting things ;)
10:02:13 <chrisdone> what app are you using coffeescript on?
10:02:20 <luite> wolfgang
10:02:20 <chrisdone> the console/learning environment?
10:02:24 <luite> yarr
10:02:31 <chrisdone> ah,ok
10:02:41 <luite> well more worksheet than console
10:03:33 <luite> it has neat syntax, but almost every typo results in syntactically valid code that does the wrong thing :p
10:03:59 <chrisdone> what innovation! :p
10:04:19 <luite> hehe when I mentioned it in #coffeescript they said that it was a design goal :)
10:05:25 <chrisdone> i noticed that when i was looking through the coffeescript syntax it reminded me of haskell, but the semantics seemed unpredictable comparatively, like a bunch of special cases. i guess my impression was mildly accurate
10:05:44 <luite> I don't really feel like working on it now, because I'm not very happy with the user interface design that I have... and I'm not good at designing
10:06:24 <luite> chrisdone: yeah probably, but it works better than javascript, at least you have things like multiline strings
10:06:40 <luite> which is useful in my application because I have many html snippets in javascript
10:06:52 * chrisdone nodnod
10:09:29 <chrisdone> the current tact i'm taking is avoiding JS-dependence altogether… my colleague came up with this CLIM-like way of doing the UI in common lisp, a way that i really like. he has this dynamic application but the only JS is one that consults the server on what to update and sends commands to the server. it means most actions have a roundtrip to the server, but it's sooo much nicer to stay in lispland (or in our case haskell-land) that it's worth p
10:09:29 <chrisdone> utting up with the overhead (and there are many clever optimisations that can be done)
10:10:14 <kmc> chrisdone, yes, it's much harder to copy semantics than to copy syntax
10:10:36 <chrisdone> kmc: elaborate a bit?
10:10:44 <kmc> shrug
10:10:52 <chrisdone> ah, you're talking about coffescript?
10:10:54 <kmc> yes
10:10:55 <chrisdone> yeah
10:11:18 <kmc> besides isn't it explicitly just an alternate syntax for javascript?
10:11:27 <luite> chrisdone: hehe I already have some hacks to be able to use more of the yesod form validation stuff, but it's mostly client driven
10:11:34 <kmc> so i imagine their semantic decisions are very constrained
10:11:39 <chrisdone> kmc: yeah
10:12:04 <luite> yeah it does offer some small bits of sugar, but it's all fairly close to javascript
10:12:17 <chrisdone> luite: how much of the client-driven part needs to be JS-side?
10:13:17 <luite> chrisdone: well I can't really refresh the whole page for almost anything, so most user input at least needs to be handled by js
10:13:32 * hackagebot happstack-server 6.2.1 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-6.2.1 (JeremyShaw)
10:14:32 * hackagebot happstack-hamlet 6.1.1 - Support for Hamlet HTML templates in Happstack  http://hackage.haskell.org/package/happstack-hamlet-6.1.1 (JeremyShaw)
10:15:21 <sm> go stepkut
10:15:30 <stepkut> :p
10:15:33 * hackagebot happstack-heist 6.0.3 - Support for using Heist templates in Happstack  http://hackage.haskell.org/package/happstack-heist-6.0.3 (JeremyShaw)
10:15:35 <luite> chrisdone: for example the goal is to have interactive graphics, for example a plot that can be zoomed. now the initial state of the plot is stored in the document, but the user may have changed something. that can't be saved (at least not without explicit support for each interactive thing), so I don't want page reloads for things like logging in, viewing history of the document etc
10:15:35 * hackagebot happstack-hsp 6.2.1 - Support for using HSP templates in Happstack  http://hackage.haskell.org/package/happstack-hsp-6.2.1 (JeremyShaw)
10:16:04 <stepkut> sm: only the happstack-server update is interesting.. the rest are just changes in the .cabal build-depends range on happstack-server
10:16:56 <chrisdone> luite: right
10:17:14 <accel> class Invertible a where invert :: a -> a ;; class Ring a where * :: a -> a -> a ;; Instead of just saying "class (Ring a, Invertible a) => Field a where (/) :: a -> a -> a", is there a way to say ... and x / y = x * (invert y) ?
10:17:24 <accel> i.e. when I define the typelcass Field, I also give a definitno for (/)
10:18:33 * hackagebot happstack 6.0.3 - The haskell application server stack + code generation  http://hackage.haskell.org/package/happstack-6.0.3 (JeremyShaw)
10:19:22 <chrisdone> luite: that's the kind of app i'm aiming at supporting with this lib
10:19:27 * chrisdone continues fiddling
10:19:28 <accel> class Invertible a where invert :: a -> a ;; class Ring a where * :: a -> a -> a ;; Instead of just saying "class (Ring a, Invertible a) => Field a where (/) :: a -> a -> a", is there a way to say ... and x / y = x * (invert y) ?
10:19:47 <luite> chrisdone: sounds good. can you have it done by tomorrow? ;p
10:19:49 <ski> accel : yes, that's called a default class member
10:19:59 * accel pulls up google
10:20:04 <chrisdone> luite: haha. but that's my holiday, mr burns!
10:20:23 <accel> http://www.haskell.org/tutorial/classes.html
10:20:25 <ski> just write `x / y = x * (invert y)' under the type signature inside the `class' declaration
10:20:26 <accel> cool; thanks ski
10:20:55 <ski> accel : any instances of `Field' can replace the default implementation of `(/)' if they want to
10:20:58 <luite> nah I think I'll try to launch a version with ugly code first, and improve it later
10:21:24 <chrisdone> the old rule; make it work, make it work right, make it work fast or small
10:22:11 <accel> wait wait
10:22:14 <ski> accel : but you'd probably still (informally) requiring them to satisfy the default implementation as a *law*, even if the actual implementation works different operationally
10:22:14 <accel> where is make it pretty?
10:22:17 <luite> I'm quite unhappy with my progress... spent half the weekend hacking on the yesod-form library, because it apparently has no validation :(
10:22:26 <chrisdone> O_ o
10:22:31 <accel> ski: is there a way to enforce that?
10:22:41 <ash__> document should be in there too :P
10:23:11 <chrisdone> luite: would you consider yesod generally complete?
10:23:19 <luite> chrisdone: well it does have some, for example you can have a field type for integers or for dates, and then you have a parser for that field :: Text -> Either Message a
10:23:30 <ski> accel : sadly no, just as you can't enforce that the argument given to `sortBy' is a total ordering, or that the argument to `nubBy' and `unionBy', &c. is an equality
10:23:31 <luite> but that's pure
10:23:36 <luite> and not really a validator
10:24:04 <accel> ski: okay, so basically I can only enforce it with chocolates & threats of torture
10:24:11 <ski> accel : and just as if you're writing a function which expects a sorted list, you can only state that as an information precondition, at best checked at run-time
10:24:13 <luite> say you want a field where only future dates can be entered, then you cannot validate that within a field parser in yesod, and consequently, you cannot have the forms library insert the proper error in the html
10:24:39 <accel> ski: whether a list is sorted can be checked in linear time .... as for whether a law is satisfied ... that could be expensive
10:25:00 <mightybyte> luite: Have you looked at digestive-functors?  It has some stuff for validation.
10:25:14 <luite> mightybyte: yep it does have monadic validation stuffs
10:25:27 <ski> accel : yeah, you can say, "if you don't satify my preconditions, anything can happen" .. usually that anything shouldn't include things which will corrupt the run-time system, or which would violate purity
10:25:34 <luite> but now my own version of yesod-form has that too ;p
10:25:41 <mightybyte> heh
10:25:52 <ski> accel : yeah, i meant that you can't really check it statically
10:25:54 <luite> digestive-functors is probably not ideal in a yesod site
10:25:58 <chrisdone> i was using formlets before using formlets was cool
10:26:10 * chrisdone throws back hipster quiff
10:26:30 <mightybyte> chrisdone: Heh.  One of these days I'll officially deprecate formlets and point people to digestive-functors.
10:26:35 <kmc> chrisdone, can you validate that claim using hipcoins?
10:26:38 <ski> accel : of course you can do an abstract type, converting a `[a]' to a `SortedList a' by sorting or checking whether it is sorted
10:27:20 <chrisdone> http://hackage.haskell.org/packages/archive/named-formlet/0.1/doc/html/Text-Formlet.html
10:27:33 <chrisdone> i think everyone ends up writing their own formlets library when they should be using digestive-functors :p
10:27:35 <luite> chrisdone: well, it really feels like just the things for simple sites work... the sample sites they have built with it so far (yesodweb, haskellers)
10:28:09 <ski> accel : but this relies on that your code behind the abstraction barrier preserves sortedness of sorted lists, which still can't be checked statically, so the problem is only delimited to a narrow space (which isn't bad)
10:28:16 <chrisdone> luite: nod
10:28:20 <mightybyte> chrisdone: Ahh, I thought you were talking about http://hackage.haskell.org/package/formlets
10:28:32 <luite> maybe my site is weird enough that it cannot really be expected to work with their supplied components
10:28:37 <chrisdone> mightybyte: yeah, i was. but neither that nor digestive-functors supports naming inputs afaik
10:28:50 <mightybyte> Yeah, that's kind of the whole point.
10:28:58 <chrisdone> indeed. not composable with names
10:29:01 <luite> but I had to hack quite a bit to get a custom login form working for example, with the yesod-auth library
10:29:12 <chrisdone> but Real World™ forms have named inputs
10:29:29 <luite> even had to use some text urls instead of the yesod type safe urls :)
10:29:38 <chrisdone> heh
10:29:48 <mightybyte> shame shame
10:30:05 <chrisdone> that's why i've avoided yesod thus far, just expecting that i'd hit a 'oh it doesn't support this' roadblock more or less immediately
10:30:25 <dainanaki> Still a work in progress.
10:30:26 <luite> hehe I'm not saying that yesod is bad, but they're talking about an 1.0 release with a more stable api.... I don't think it's ready
10:30:27 <chrisdone> mightybyte: don't you think named inputs are important?
10:30:51 <mightybyte> chrisdone: Not in the cases where I've wanted to use formlets/d-f
10:31:00 <chrisdone> ah, ok
10:31:07 <luite> yesod-form does have named fields :p
10:31:08 <luite> yay
10:31:24 <ski> i suppose you could have `empty :: SortedList a; insert :: Ord a => a -> SortedList a -> SortedList a; merge :: Ord a => SortedList a -> SortedList a -> SortedList a; toSorted :: Ord a => [a] -> Sorted a; fromSorted :: Ord a => Sorted a -> [a]; trySorted :: Ord a => [a] -> Maybe (Sorted a)' .. any more operations ?
10:31:34 <luite> and I've added my own remote-validate field that uses javascript to call back to the server to validate a field, with type safe urls
10:31:34 <chrisdone> mightybyte: for example, hpaste.org, the inputs are named so that people can use it as an API and browsers can remember things
10:31:38 <luite> very ajaxy etc
10:31:42 <mightybyte> yeah
10:31:42 <chrisdone> oh, nice
10:32:11 <mightybyte> I'm not saying named inputs aren't useful.  I'm saying that if you want them, then you almost don't need formlets.
10:32:21 <luite> nah I don't agree
10:32:37 <luite> with formlets you knwo what each field is used for
10:32:40 <mightybyte> ...which is why I inserted the word "almost"
10:32:42 <chrisdone> you want the validation and nice applicative way of writing forms, but, yeah, not the composability so much
10:32:46 <luite> and you may not need to name every one of them
10:33:16 <luite> yesod-form also has a more flexible monadic way to write forms
10:33:25 <luite> does digestive-functors have that?
10:33:40 <chrisdone> mightybyte: have you had a real use for the composability aspect? i wrote a long blog post a while ago about why it's so awesome to be composable but never got a use-case myself for a big-ass form, it would be nice to see
10:33:58 <mightybyte> The non-formlets forms I've done with Snap seemed like they didn't really need anything extra.
10:34:17 <mightybyte> chrisdone: Oh yes, big time.
10:34:18 <chrisdone> i think you can write monadically or applicatively with digestive-functors. iirc it's basically formlets but generalized
10:34:29 <mightybyte> yes
10:34:32 <chrisdone> mightybyte: what was the use case?
10:34:45 <mightybyte> http://noscrolls.com
10:34:52 <luite> mightybyte: with yesod-form you still get the field parsers and easy date field (with jquery datepicker) with the non-formlet forms for example
10:35:01 <accel> why are classes only allowed to take 1 argument
10:35:13 <luite> and every field type you define can be used in both
10:35:41 <chrisdone> accel: with MultiParamTypeClasses the sky is the limit
10:35:50 <accel> why by default is it not allowed
10:35:53 <accel> I suspect there is a reason
10:36:21 <mdmkolbe> This is off topic, but I don't know where to ask.  What does "es" in the issue number ("4es") mean at <http://portal.acm.org/citation.cfm?id=242324>.  I thought it was "et sequentes" but that appears to be abrivated "et seq.".  (If there is a better channel to ask, let me know.)
10:36:39 <chrisdone> mightybyte: where do i go to see an example of heavy formlet usage?
10:37:57 <chrisdone> ah, i registered and went to the post my results page
10:38:15 <chrisdone> yeah, that's a good example
10:38:26 <luite> but I don't really know what to think of the frameworks. it looks like yesod is more ambitious with more safety things, but also has more problems because of that, and expects you to conform much more to its ways than snap does
10:39:27 <chrisdone> yeah i guess it's easier to do the safety thing if all aspects of the project cohere
10:39:30 <luite> but I haven't really looked at the snaplets thing by the way
10:39:36 * hackagebot happstack-hamlet 6.1.2 - Support for Hamlet HTML templates in Happstack  http://hackage.haskell.org/package/happstack-hamlet-6.1.2 (JeremyShaw)
10:40:06 <ski> accel : the reason is probably that only one argument was needed for the initial examples
10:40:12 <mightybyte> I think there are two main differences.
10:40:22 <mightybyte> Type safe URLs -vs- not
10:40:35 <mightybyte> ...and sense of code style
10:40:53 <chrisdone> technically snap can do type safe urls with something like web-routes, no?
10:40:57 <ski> accel : if you have a good use for a MPTC, go on and enable the extension (and also consider whether you want any FDs .. or if you maybe want ATs or TFs instead)
10:41:07 <luite> unfortunately most yesod code is totally uncommented :(
10:41:22 <luite> and you can only look up incomplete documentation on the wiki or blog posts
10:41:32 <dmwit> psh
10:41:35 <dmwit> The types tell you everything.
10:41:39 <dmwit> Isn't that the party line? ;-)
10:41:40 <luite> which often have a few very basic examples but for the rest you're on your own
10:41:42 <ski> ("MPTC" being "Multi-Parameter Type Class","FD" being "Functional Dependency","AT" being "Associated Type" and "TF" being "Type Family")
10:42:07 <luite> dmwit: yes but with yesod you need a 30" monitor to fit a type error on your screen
10:42:22 <chrisdone> ski: heh, i like your let ircmessage = … where term1 = …; …
10:42:37 <mightybyte> chrisdone: Yes, it should be doable.  We just don't think type safe urls are the best solution.
10:42:44 <chrisdone> luite: LOL
10:43:13 <accel> ski: noted
10:43:39 <chrisdone> luite: wanna see a haskelldb error? http://hpaste.org/raw/44696
10:43:42 <luite> chrisdone: it's true! and some people in #yesod were talking about making a site where you'd paste your type error, and the site would guess what the problem is
10:43:50 <chrisdone> mightybyte: why so?
10:43:56 <mightybyte> chrisdone: Here's an image of the composable form.  http://i.imgur.com/Xgsvg.png
10:43:56 <chrisdone> luite: haha xD
10:43:58 <luite> because the errors are too intimidating for beginners
10:44:24 <mightybyte> chrisdone: Well, luite's last few comments are one of the reasons.
10:44:41 <chrisdone> mightybyte: yeah, that's the one i looked at. but the one on the site i looked at had more repeated elements which seems like a perfect example of formlets/df
10:44:57 <chrisdone> luite: mightybyte: ah, right. that's true enough
10:45:55 <mightybyte> chrisdone: Yeah, in the image I just pasted, when you click "Add Item" you'll get another row in the table with a whole new set of fields.
10:46:01 * chrisdone nods
10:46:35 <mightybyte> And I wanted to be able to easily have all that info available in nice Haskell data types.
10:46:43 <luite> mightybyte: oh by the way, with heist, if you want to output a tree data structure where all internal nodes are styled according to some template, and all leaves to a different one. is there an example of that somewhere?
10:46:48 <chrisdone> hm. i might actually use this web site. i have a workout routine
10:46:54 <mightybyte> But back to the type safe URL question...
10:47:10 <mightybyte> luite: Not that I konw of.
10:47:49 <mightybyte> We tend to think that markup/css should be treated as data, not code.
10:48:27 <mightybyte> ...because that facilitates the real world phenomenon of the coder and the designer being different people.
10:48:49 <chrisdone> yeah, the concessions we make for the sake of designers are many and unfortunate
10:50:04 <mightybyte> And that's not just a concession for designers.
10:50:14 <ion> > fix ("code is data is " ++)
10:50:15 <lambdabot>   "code is data is code is data is code is data is code is data is code is da...
10:50:16 <luite> mightybyte: hmm, some of the yesod guys claim that their designers actually like the hamlet and cassius templates. and from their point of view, there is not that much difference, is there?
10:50:17 <mightybyte> It's really nice to be able to change markup on the fly without recompiling the whole application.
10:51:00 <chrisdone> (otoh a gui framework like WPF lets developers not care what designers do to the presentation aspect by giving them something far more powerful than the broken html/css model)
10:51:03 <luite> admittedly they have to learn the typed url syntax
10:51:51 <luite> mightybyte: well yesod has a development mode that automatically recompiles when a tempalte file has changed
10:51:55 <mightybyte> Not using the industry standard markup language also has a whole set of disadvantages.
10:52:16 <mightybyte> luite: Yes, but you'd never run a production site like that.
10:52:42 <mightybyte> Without type safe URLs, you can run a production site and still easily make tweaks to your markup on the fly.
10:53:05 <chrisdone> mightybyte: that argument has a lot of weight (for e.g. hiring and code review) but we're using haskell so we have a bit more flexibility in that regard.
10:54:08 <luite> mightybyte: I think that with the right infrastructure set up, for example the development server on a different port, even if it's on the same machine, then that's should hardly be a problem
10:54:49 <chrisdone> fwiw you shouldn't make changes to production like that
10:54:51 <mightybyte> luite: That infrastructure is expensive
10:54:55 <luite> mightybyte: ?
10:55:21 <mightybyte> For example, we're probably just not going to invest in that for snapframework.com
10:55:27 <mightybyte> ...at least not at this stage.
10:55:38 <luite> hmm, not sure what you mean?
10:55:42 <chrisdone> we have local machine, dev machine, staging machine and production machine. there isn't even a development environment and no shell or database access whatsoever for staging and production
10:56:40 <mightybyte> chrisdone: Of course Google would never want it to be so easy to change their home page.  But I think there are a lot of organizations out there that won't have that level of process.
10:56:51 <luite> the yesod devel server is far from perfect, it takes way too long to recompile if you make a small change to a template (basically needs to cabal build every time)
10:57:09 <mightybyte> right, that is also part of my point.
10:57:27 <luite> but I think that once that has been fixed, the recompilation requirement should hardly be an issue
10:57:42 <mightybyte> Doesn't change my above point though.
10:57:45 <chrisdone> (if i make a change i do it locally, commit and push to dev and rebuild and test, then push to staging, run the selenium tests, then depending on the publicity of the change get third party approval, then push to production. then merge the change into master. the whole thing can take five minutes)
10:58:08 <chrisdone> yeah, the point that dev'ing locally should be fast still stands
10:58:22 <mightybyte> chrisdone: It would take 30 seconds for me to make a small change to my bio on snapframework.com
10:58:40 <chrisdone> mightybyte: so?
10:58:54 <luite> yes the current yesod devel server uses cabal to rebuild, while it should use the ghc api and reload modules when required. that saves enormous amounts of time
10:58:59 <chrisdone> write it in php and you can do it in a second
10:59:00 <mightybyte> Depending on your style of development, that 4.5 minutes can be a big deal over time.
10:59:07 <chrisdone> we're assuming an industry style of development, no?
10:59:16 <mightybyte> chrisdone: No
10:59:30 <chrisdone> seems a bit odd
10:59:35 <mightybyte> I don't think so.
11:00:01 <mightybyte> It's the ease of RoR/PHP without all the ugliness.
11:00:01 <chrisdone> aren't you essentially catering to ickle projects?
11:00:10 <mightybyte> No
11:00:15 <dcoutts> luite: or better, some nicely done combination of the two so that we get both pre-processors and fast module rebuilds
11:00:31 <sm> I don't quite get why non-typesafe urls enables rapid template reloading, why is that ?
11:00:36 <dcoutts> luite: the same kind of library interface to cabal that an IDE would want
11:00:36 <mightybyte> Just because something gives you an advantage that is useful for small projects doesn't mean you've sold out and started ignoring production quality stuff.
11:00:36 <chrisdone> tbh rebuilding my whole project takes maybe 5 seconds
11:00:48 <mightybyte> sm: Because they don't have to be type checked.
11:00:49 <chrisdone> that's about as fast as developing with C# and .NET
11:01:00 <sm> yees, ok
11:01:03 <sm> thx
11:01:15 <doc_what> hello
11:01:38 <chrisdone> (—i mean, rebuilding when i've changed a couple modules only. rebuilding the whole project takes a couple minutes)
11:02:12 <luite> dcoutts: yeah good point, that was one of the things that I still wanted to find out. does cabal already have the appropriate api for that?
11:02:22 <doc_what> what does this error mean: "Malformed head of type or class declaration" ?
11:02:33 <doc_what> ill paste the code that goes with it
11:02:34 <dcoutts> luite: not nicely
11:02:51 <dcoutts> luite: but we're getting a bit closer with the two GSoC projects this summer
11:02:58 <ash__> whats the most common way configure/build a large project? with cabal? or writing custom make files? (cmake even?)
11:03:13 <dcoutts> luite: also, I have the design for what it should do in my head, but not the time to implement it :-)
11:03:48 <doc_what> here's the code thats giving me the "malformed type" error - http://pastebin.com/LFdBR7my
11:03:48 <luite> ah
11:03:50 <mauke> The paste LFdBR7my has been copied to http://hpaste.org/49597
11:04:17 <monochrom> s/boolExp/BoolExp/
11:04:32 <chrisdone> mightybyte: sure, it's a trade-off. the nice thing about snap is it doesn't force that stuff but trivially allows layering it ontop :-)
11:04:32 <epdtry> doc_what: boolExp is not a valid type name, because the first letter must be capitalized
11:04:42 <doc_what> oh is that it?
11:04:44 <doc_what> hmm
11:05:04 <kmc> boolExp would be a type variable
11:05:12 <kmc> and a type variable is not allowed in that position
11:05:34 <doc_what> ah thanks that fixed it
11:05:34 <kmc> also False and True are already defined
11:05:58 <kmc> you can import Prelude hiding those, but it's probably not what you want
11:07:08 <mightybyte> chrisdone: There's also some ways we can explore getting checked URLs with Heist that would give you starup-time errors, which are almost as good as compile-time errors without the downsides I've mentioned.
11:07:11 <doc_what> yeah i wanted something like "data BoolExp = Boolean | Not BoolExp | ..." but didnt know if that was legal/would work how I expect
11:07:37 <ion> data Bool = False | True | FileNotFound
11:07:41 * hackagebot happstack-server 6.2.2 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-6.2.2 (JeremyShaw)
11:07:52 <luite> anyway I might help the yesod guys rewrite their devel server, but actually I had planned to just build a website, without fixing lots of nontrivial things along the way, but apparently it just doesn't work that way :p
11:07:55 <kmc> doc_what, data BoolExp = Lit Bool | Not BoolExp | ...
11:09:10 <chrisdone> luite: Haskell Life \m/
11:09:31 <chrisdone> mightybyte: yeah, start-up errors are about as good
11:09:44 <ash__> has anyone ever seen a functional language without a garbage collector?
11:10:08 * chrisdone . o O ( meanwhile, all the lispers laugh their way to their steel bank … )
11:10:17 <doc_what> kmc: thanks
11:10:20 <dolio> ash__: Yes.
11:10:39 <kmc> ash__, garbage collector is (usually) an implementation property, not a language property
11:11:02 <chrisdone> in lisp, just change a definition and press C-M-x. it's live. done. basta
11:11:14 <sm> mightybyte: more of a lint than a compiler check approach ? sounds handy
11:11:27 <ash__> I just ask because I do a lot of work on embedded systems (atmels and pics) and its always seemed odd how those platforms seem to stick to imperative languages
11:12:09 <Chewie[]> i am looking for an "all minimum" function, something like allMins :: (Ord a) => [a] -> [a]
11:12:10 <luite> mightybyte: would you be able to check types for handlers that way? for example /path/to/handler/arg1/arg2 where arg1 :: Integer, art2 :: Text ?
11:12:19 <Chewie[]> allMins [1,2,3,4,3,2,1,2,1] == [1,1,1]
11:12:59 <ash__> i know with the low memory constraints and the lack of an os, I imagine would be a reason they stick with assembly and c a lot, but it would be interesting to see something like haskell on an atmel
11:14:39 <mightybyte> Chewie[]: Heh, I had that as an interview question once.
11:15:04 <Chewie[]> nice.
11:15:32 <Cale> ash__: Probably the reasonable thing to do if you want to use Haskell in programming embedded systems is to use it as a metalanguage, rather than compiling Haskell directly to microcontroller code.
11:15:34 <mightybyte> luite: I guess the simplest approach might not give you that, but it could probably be done.
11:16:16 <Cale> http://hackage.haskell.org/package/atom
11:16:21 <Cale> for example
11:16:27 <copumpkin> Chewie[]:
11:16:33 <ash__> Cale: ya, I have seen atom before, but it doesn't really play well with avr's although I haven't tried that hard in all honesty
11:16:42 <copumpkin> > head . group . sort $ [1,2,3,4,3,2,1,2,1]
11:16:43 <lambdabot>   [1,1,1]
11:17:02 <copumpkin> not as efficient as it can be though
11:17:07 <copumpkin> but not as bad as it looks, either
11:17:23 <mightybyte> chrisdone: The other argument is that all the TH and quasiquoting used to get type safe URLs is much more intimidating for newcomers.
11:17:29 <kmc> ash__, it's not really about imperative vs. functional
11:17:31 * chrisdone nods
11:17:36 <kmc> Haskell is an imperative language too
11:17:37 <chrisdone> intimidates me
11:17:37 <luite> mightybyte: it would be interesting to see what you can still do while not requiring everything to be typed like yesod. yesod does have the advantage that you can really easily move things around in your site
11:17:37 <ski> ash__ : the initial MlKit implementation didn't have GC, it uses Region Management as a generalized stack allocation
11:17:43 <kmc> ash__, it's about low abstraction power vs. high abstraction power
11:17:45 <Evious> Doable in one pass with a fold over a 2-tuple containing the lowest number seen thus far, and how many times it's been seen.
11:17:45 <Cale> ash__: Yeah, I haven't used it myself even, but I'm just using it to illustrate the sort of approach that I mean. :)
11:17:53 <kmc> you can have abstraction power in functional or imperative styles; Haskell has both
11:17:55 <mightybyte> Not to mention violates the principle of least surprise with another new syntax to learn.
11:18:22 <ski> ash__ : they added GC later since it was needed in general for long-running programs which would otherwise just accumulate garbage in the top region which would never get allocated
11:18:47 <mightybyte> luite: Yeah.  Here, it starts to get into the static-vs-dynamic-typing arguments.
11:18:57 <ski> ash__ : but possibly, if you're careful, you can get by with just region management
11:19:22 <acowley> atom works fine with avr. What's the problem?
11:19:57 <ski> ash__ : Scheme48 is bootstrapped by a language called pre-Scheme, which is like a Scheme with no closures allowed except those that it can eliminate at run-time
11:20:07 <sm> what I find tedious with typed urls is having to deal with the url-rendering function all the time
11:20:25 <luite> mightybyte: I'm not convinced that learning new syntax is always bad
11:20:32 <ski> ash__ : another approach which could be interesting is to look into (soft- and hard-) real-time GCs
11:20:52 <mightybyte> luite: In the perfect world where I'm cleanrooming all web infrastructure and there was no existing syntax and mentalities, type safe URLs would probably be more appealing
11:21:12 <Chewie[]> copumpkin: elegant.
11:21:20 <luite> mightybyte: now hamlet deliberately deviates from html, so it's probably not a good example
11:21:34 <ash__> acowley: I don't recall off the top of my head, It was a few months ago that I looked into atom, I can look into it again though and try to get back to you
11:21:45 <Chewie[]> copumpkin: that will work, thanks!
11:21:50 <mightybyte> luite: I don't disagree with you there.  But that's what Haskell is so good at.  And all the quasiquoting not only abandons the HTML syntax, it abandons the Haskell syntax too!
11:22:24 <ash__> ski: I wonder what manual memory management would look like in say haskell or would you forgo that entirely and try to design a better GC / memory management scheme
11:22:37 <ski> mightybyte : how about using OCaml, with quasi-quoted syntax more or less standard per Camlp4 ?
11:22:42 <sm> wait now, hamlet is pretty close to HTML. Are you comparing hamlet to the even-more-HTML-like hsp ?
11:22:54 <mightybyte> ski: I'm not familiar enough with OCaml to know.
11:23:19 <ski> ash__ : Region Management Inference, as well as Real-Time GCs, are attempts to do those latter things
11:23:44 <fasta> But... we already have real-time GCs since the 60s.
11:23:46 <ski> ash__ : also, there's stack allocation in Haskell
11:23:47 <ski> @hoogle alloca
11:23:47 <lambdabot> Foreign.Marshal.Alloc alloca :: Storable a => (Ptr a -> IO b) -> IO b
11:23:47 <lambdabot> Foreign.Marshal.Array allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
11:23:47 <lambdabot> Foreign.Marshal.Array allocaArray0 :: Storable a => Int -> (Ptr a -> IO b) -> IO b
11:23:58 <ash__> the attiny13 only has 64 bytes of ram and a 20 MHz processor, I wonder how far you could go with that those as your constraints
11:24:16 <kmc> haha
11:24:28 <ski> @hoogle Foreign.Marshal.new
11:24:29 <lambdabot> Foreign.Marshal.Utils new :: Storable a => a -> IO (Ptr a)
11:24:29 <lambdabot> Foreign.Marshal.Array newArray :: Storable a => [a] -> IO (Ptr a)
11:24:29 <lambdabot> Foreign.Marshal.Array newArray0 :: Storable a => a -> [a] -> IO (Ptr a)
11:24:29 <fasta> ash__: you would use Atom or Forth.
11:24:30 <kmc> you can get much more powerful chips for not much more money
11:24:30 <ski> @hoogle free
11:24:31 <lambdabot> Foreign.Marshal.Alloc free :: Ptr a -> IO ()
11:24:31 <lambdabot> Foreign.Ptr freeHaskellFunPtr :: FunPtr a -> IO ()
11:24:31 <lambdabot> Foreign.Marshal.Pool freePool :: Pool -> IO ()
11:24:58 <ski> ash__ : and manual heap allocation .. ^
11:25:29 <luite> mightybyte: for simple things, inserting a single text variable or an already constructed piece of html, hamlet is very close to html (or one could easily supply a template type that didn't automatically close tags etc)
11:25:35 <fasta> ash__: Haskell is for the application space, not for anything which has to go ultra-fast or within ultra-small space.
11:25:40 <mightybyte> luite: I actually used to be in the type safe URL camp.
11:26:01 <ash__> i know, but thats not really the point, the atmel atmega329 has 2K bytes of ram and is up to 20Mhz, so if ram was to tight you can go to that
11:26:30 <luite> mightybyte: oh I'm not arguing type safe urls now anymore, just quasiquoted templates vs external files
11:26:36 <ash__> fasta: i know, I am more just thinking about a functional-ish language for that kind of a system
11:26:40 <mightybyte> luite: Oh, ok.
11:26:47 <kmc> again, it's not about 'functional'
11:26:57 <kmc> it's about powerful vs. weak abstraction
11:27:00 <fasta> ash__: 'functional' doesn't even have any meaning.
11:27:00 <ski> ash__ : Region-Based Memory Management in MLKit <http://www.it-c.dk/research/mlkit/index.php/Main_Page>
11:27:17 <ash__> maybe I should say an ml language then?
11:27:31 <kmc> 'functional' basically means "not C, C++, or Java"
11:27:46 <kmc> basically every other general-purpose language has first-class functions
11:28:01 <kmc> and people fake them in those languages too
11:28:26 <fasta> kmc: function pointers are common in C, you just need to define types for them.
11:28:27 <acowley> ash_: I kicked the tires with atom on an arduino before and it seemed fine, but probably not worth the headache for most embedded jiggery pokery
11:28:34 <acowley> Chewie[]: allMins = ($) <$> (. (==)) . flip filter <*> minimum
11:28:38 <kmc> fasta, function pointers aren't by themselves first-class functions
11:28:41 <chrisdone> functional seems to only have meaning if you take it to mean statically pure functions
11:29:06 <chrisdone> (pity 'function' means 'procedure' in programming to most people)
11:29:19 <ski> mightybyte : with Camlp4 you can extend the syntax of OCaml to e.g. allow a new construction `let try <name> = <expr> in <expr> with <exception-handler>' <http://martin.jambon.free.fr/extend-ocaml-syntax.html#lettry>
11:29:23 * kmc does embedded programming in C++ and finds it vastly more pleasant than applications programming in C++
11:29:24 <luite> mightybyte: I'm not firmly in any camp at the moment, but there don't seem to be any other people willing to defend yesod here ;)
11:29:26 <mightybyte> luite: So I think it's a good thing that someone is pursuing the type safe URL approach.  It's very different from the other approach and worth exploring.
11:29:48 <fasta> kmc: it depends on what you mean by 'first-class', I suppose. Well, we could just stop this discussion, since we are both old enough to know how the world spins around.
11:29:49 * acowley never does embedded programming in C++ to avoid insane proprietary compiler support for C++ :(
11:29:54 <sm> luite: I like yesod, but nobody's saying it's the best/only approach
11:30:03 <chrisdone> mightybyte: luite: at any rate, we all agree that *checked* urls are important
11:30:16 <ski> mightybyte : istr you can also do quotation and quasiquotation, i suppose somewhat similarly to Template Haskell (i'm not sure how they compare in this regard with each other)
11:30:29 <sm> it's very interesting to see the pros and cons of the different approaches
11:30:33 <kmc> fasta, yes, I'll just point out the popularity of the "pointer to callback + void* that gets passed to the callback" pattern as a way to fake first-class functions in C
11:30:42 <ash__> acowley: avr-gcc and avr-g++ are open source for the atmegas
11:30:47 <luite> chrisdone: yeah... but checking can be expensive... I can't serve part of my application from yesod itself because it has too many files, which would make recompilation way too slow
11:30:56 <luite> so I use apache for that part...
11:30:57 <luite> ugh
11:31:23 <chrisdone> luite: by checking i mean either compile-time or runtime. just making sure *someone* (i.e. the computer) is keeping an eye on their consistency
11:31:31 <kmc> you can't do «\x -> \y -> x+y» in C with function pointers alone.  you have no way to capture and save x
11:31:32 <sm> luite: why can't you just serve those as static files (from yesod) ?
11:31:39 <kmc> and that's the point at which you need non-trivial allocation behavior
11:31:46 <acowley> ash__: yeah I've never had the good fortune to do large-scale dev with avr. I've only done big tings with PICs and Analog Devices stuff
11:31:58 <luite> sm: because it makes recompiling the StaticFiles module take a few minutes
11:32:07 <kmc> ARM microcontrollers also have free toolchains
11:32:12 <luite> actually I don't know how long it takes because I've never waited for it to finish
11:32:13 <kmc> and are shockingly cheap these days
11:32:17 <dolio> > let f m x ~(ys, e) = (if m == x then x:ys else ys, x `min` e) ; allMins l = let (xs, m) = foldr (f m) ([], maxBound) l in xs in allMins [1,2,3,4,3,2,1,2,1] :: [Int]
11:32:18 <lambdabot>   [1,1,1]
11:32:19 <hatds> anyone know about hs-plugin? there doesn't seem to be much info on it
11:32:25 <sm> oh. It should allow serving files without that
11:32:27 <ash__> ya, the mbed is pretty nice if your looking for an arm
11:32:35 <luite> sm: yes but then the locations are unchecked
11:33:05 <ski> fasta : functions as in C corresponds to Lewis' Strict Implication, which is basically `[] (a -> b)' where `[]' is a modality that means "necessary", in this case it should be interpreted as "global extent", i.e. something which is not transient
11:33:11 <luite> sm: or at least they used to be, it might have already been fixed by now, there have been some updates to the static files server
11:33:15 <sm> sure, but in this case you're preferring that; it would be the same as you've got with apache
11:33:20 * kmc has only programmed AVR and a little bit of 80186 (not good times)
11:33:27 <hatds> I wondering how hs-plugins presents dynamically loaded code to the host program
11:33:36 <sm> sometimes typechecked urls are worth the cost and sometimes not
11:33:37 <chrisdone> hatds: dons published a paper about it… there are plenty of docs
11:33:37 <luite> sm: yesod reads all static files on recompilation, and computes the md5sum for every one of them, and then generates a name
11:33:48 <reiners> I know I can do the following from a command prompt:
11:33:48 <kmc> hatds, the library is just called 'plugins' now
11:33:48 <reiners>     $ runghc WC < quux.txt
11:33:58 <reiners> How do I do this in WinGHCi?
11:34:00 <ski> fasta : so a function of type `[] (a -> b)' can only use its argument of type `a', and things of type `[] c' (which would be anything defined at top-level)
11:34:08 <reiners> I know I have to first load the file like this:
11:34:09 <reiners>     Prelude> :load WC
11:34:15 <reiners> But then what?
11:34:20 <chrisdone> hatds: okay, so it appears to be a dead link. http://webcache.googleusercontent.com/search?q=cache:agGqBosAAzYJ:www.cse.unsw.edu.au/~dons/hs-plugins/+hs-plugins&cd=1&hl=en&ct=clnk&source=www.google.com
11:34:31 * ash__ has to go to class now bye
11:34:33 <sm> luite: oh so it's not just about the urls but caching. Anyway, it should allow stuff like that to be done more cheaply. I expect you could do it by calling warp or wai or something
11:34:46 <acowley> dolio: I thought we cared about points more than perf? :P
11:34:58 * ski has sometimes written `[] (a -> b)' as `a #-> b' in pseudo-code haskell ..
11:35:00 <sm> if all else fails, run a little snap server as well :)
11:35:08 <mightybyte> Another reason we chose against type checked URLs is that we have a strong desire for things to be very simple even for people new to Haskell/FP.
11:35:37 <dolio> acowley: Can you write that with fewer points and still have it look nice?
11:35:52 <dolio> I don't know if that's even better performing. I just wanted to tie knots.
11:35:53 <hatds> I think I have that paper by don, but I couldn't find a clear picture of how the type system of the dynamically compiled program relates to the type system of the host program... can the dynamically compiled program refer to values and types of the host program?
11:35:58 <sm> mightybyte: how well does heist fit with that goal ? It didn't entice me too much
11:36:20 <mightybyte> sm: I think it fits perfectly.
11:36:24 <chrisdone> hatds: yeah, by both the host and the plugin importing the same module of types
11:36:33 <mightybyte> We've gotten a lot of positive comments about it.
11:36:43 <mightybyte> sm: What wasn't enticing about it?
11:36:46 <sm> it seemed more complicated than the familiar "html file with variables interpolated"
11:36:56 <chrisdone> hatds: roughly speaking A and B import MyTypesModule then they can both share values of the types in that module
11:36:56 <sm> it reminded me of zope page templates a little
11:36:58 <acowley> dolio: I'm just being silly. My version does two passes over the list while yours does just the one.
11:37:10 <mightybyte> sm: Yes, but the advantage is that templates are valid HTML
11:37:12 <luite> sm: well I do think that yesods approach should have some good advantages, if they can really make it work... but it's a lot trickier than the snap approach
11:37:15 <thoughtpolice> hatds: if you want the whole story on runtime compilation etc of statically typed languages, you should read dons phd thesis
11:37:16 * chrisdone prefers blaze-html above all
11:37:19 <thoughtpolice> which was about exactly this topic
11:37:43 <sm> mightybyte: same argument page templates made, and that's nice, I'm just saying it can seem a little more complicated for a newbie
11:37:45 <thoughtpolice> hatds: if you want just an example of what hs-plugins allowed, you should also be able to find his paper about the idea behind yi
11:37:55 <thoughtpolice> which i've actually pulled off before with hs-plugins, but years ago (like ghc 6.6)
11:38:02 <thoughtpolice> (in my own IRC bot)
11:38:11 <hatds> chrisdone: does the source code of the module need to be available, or can it work by importing the module as it already exists in the host program?
11:38:20 <mightybyte> sm: Well, compared to a totally new syntax I think it's still pretty easy.
11:38:33 <mreh> how do I bind to a monadic value returned as a continuation in a monadic expression
11:38:47 <luite> mightybyte: yesod also aims to be easy to use for beginners, but they use the "you don't need this" approach, which annoyed me...
11:38:50 <luite> err
11:38:56 <luite> the "you don't need to know this yet"
11:38:57 <luite> approach
11:38:58 <kmc> can you elaborate mreh?
11:39:23 <chrisdone> hatds: i don't quite recall — iirc you compile object files which both refer to the same module (set of objects) and thus when you link the objects 'dynamically' it just works
11:39:41 <luite> mightybyte: and yesod probably looks more familiar for people coming from ruby on rails
11:40:39 <hatds> chrisdone: sounds like you probably don't need the source to be available dynamically then, probably just during the compile phase
11:40:47 <mreh> kmc: a switch parser that returns the parser that defines the argument required by that switch
11:41:21 <kmc> mreh, I still don't get it; do you have example code?
11:41:22 <chrisdone> hatds: sounds about right. the paper does have an example that you can basically copypaste to try. that worked for me. i tried using it for a reloadable IRC server
11:41:31 <luite> sm: I already have a snap server, my web app has two parts, the front end is yesod (serves web pages, wiki), back end is snap (handles all haskell code evaluation stuff, dispatches requests to interpreters)
11:41:38 <kmc> it sounds kind of like you need join :: (Monad m) => m (m a) -> m a
11:41:46 <luite> which is great, since now I can complain about both frameworks!
11:42:14 <monochrom> > do { a <- [0,1,2]; b <- a; return (b-1) }
11:42:15 <lambdabot>   No instance for (GHC.Num.Num [b])
11:42:15 <lambdabot>    arising from a use of `e_10121' at <in...
11:42:19 <chrisdone> hatds: maybe this is marginally useful, the commit of my attempts to use hs-plugins to make the server reloadable: https://github.com/chrisdone/hulk/commit/c01b63f466d0d4b603a71e2f61bbe60d5aa01412
11:42:40 <monochrom> > do { a <- return [0,1,2]; b <- a; return (b-1) }
11:42:41 <lambdabot>   [-1,0,1]
11:42:42 <chrisdone> hatds: i actually failed at doing it because it fails with some ghc internal error, but i think the general idea is correct
11:42:42 <ski> reiners : `:main' ?
11:42:48 <ski> dolio : nice knot :)
11:42:48 * hackagebot happstack-state 6.1.1 - Event-based distributed state.  http://hackage.haskell.org/package/happstack-state-6.1.1 (JeremyShaw)
11:43:18 <chrisdone> hatds: (StringProcAPI is the proxy module)
11:43:41 <dolio> ski: Took me longer than expected because I started defining f by guards.
11:43:45 <dolio> But that's too strict.
11:44:10 <chrisdone> hatds: another approach is using hint: https://github.com/chrisdone/hulk/commit/caab555cefb48fad04a239ba5b1e39ff022d494b https://github.com/chrisdone/hulk/commit/fa3c4024b09fab352cba02f7c57f396118c86546
11:44:16 <ski> dolio : was there any comment before which triggered you ?
11:44:34 <dolio> Someone wanted the allMins function.
11:44:42 <ski> @tell ash__ with an ML, like the SML implementation MLKit it could be easier to keep a tight bound on space, i think ..
11:44:42 <lambdabot> Consider it noted.
11:45:08 <chrisdone> hatds: but as you can see from my not-so-cheerful commit messages, i got segfaults with hint. i have the general feeling that reloadable/pluggable haskell is a nontrivial project in and of itself
11:46:15 <hatds> chrisdone: yea, but it'd be amazing when you can get it to work
11:46:31 <hatds> editing your text editor on the fly sounds pretty neat
11:46:32 <chrisdone> heh. i have like four branches of that project trying to use various libraries and each of them have a final commit of "segfault ~_~ i give up"
11:46:37 <chrisdone> sure
11:46:57 <hatds> ha
11:47:01 <EvanR7> also we need reloadable kernels
11:47:07 <EvanR7> without rebooting
11:47:07 <chrisdone> tried adding openssh to the ircd. guess what? segfault
11:47:24 <luite> why did you write your own ircd?
11:47:27 <chrisdone> if i want segfaults i'll use C
11:47:37 <EvanR7> chrisdone: or bindings
11:47:44 <EvanR7> both work pretty well for that purpose
11:47:45 <chrisdone> luite: NIH
11:48:05 <luite> ah :)
11:48:15 <chrisdone> well, we use irc at work and wanted extra features/removing typical IRC limitations
11:48:37 <chrisdone> modifying some 15 year old C/C++ ircd, versus spending an evening writing one in Haskell — choice was easy ;)
11:49:11 <luite> yeah obviously writing haskell is much more pleasant, and you'd never get segfaults :p
11:49:29 <mightybyte> sm: I think the things that are complex about Heist can be nicely placed as the sole responsibility of the developer writing splices.  The designer writing HTML gets to use the same syntax he's already familiar with and gets whatever power the splice author bestows on him.
11:49:38 <monochrom> server written in c takes forever to stamp out all vulnerabilities
11:49:50 <luite> hehe
11:49:54 <chrisdone> the beauty of haskell. we were using it the day after i wrote it and it's been stable as hell
11:50:13 <ski> @tell Chewie[] dolio came up with  allMins l = xs where (xs, m) = foldr f ([], maxBound) l; f x ~(ys, e) = (if m == x then x:ys else ys, x `min` e)  just before you left
11:50:14 <lambdabot> Consider it noted.
11:50:18 <monochrom> whereas in haskell you have to deliberately sabotage the code base to add vulnerabilities
11:50:44 <chrisdone> it does that kind of ircbouncer/skype thing when you reconnect, so we don't miss eachother's messages. and we can also connect lots of development-related bots to the main channel (similar to hackagebot)
11:50:46 <chrisdone> monochrom: haha, yeah
11:51:37 <luite> monochrom: I discovered this error earlier this week when entering a wrong url for yesod-auth: SqlError {seState = "22P02", seNativeError = 7, seErrorMsg = "execute: PGRES_FATAL_ERROR: ERROR: invalid input syntax for integer: \"a\"\n"}
11:51:54 <chrisdone> luite:  ~______ ~
11:53:04 <chrisdone> initially with the haskelldb + hdbc + postgres combo, i had "unexpected keyword user" with a field name of "user". step 1) rage, step 2) patch
11:53:08 <monochrom> report it on reddit with "server written in haskell has vulnerabilities" :)
11:53:18 <luite>  hehe
11:53:24 <luite> guess I should report the bug though
11:53:40 <luite> or sell it to russian hackers
11:53:57 <monochrom> will buy us another 5 years of avoiding success
11:54:12 <chrisdone> i like your style
11:54:12 <EvanR7> lol
11:54:19 <monochrom> hehe
11:54:32 <EvanR7> reverse PR
11:55:00 <monochrom> look at it on the bright side, in these 5 years you can feel better with making incompatible changes to the language
11:55:25 <EvanR7> welcome to digital mars d then
11:55:46 <monochrom> such as revamping the record system and removing the monochromism restriction
11:56:06 <EvanR7> whats the monochromism restriction
11:56:08 <chrisdone> :P
11:56:21 <monochrom> monomorphism :)
11:56:24 <chrisdone> type directed name resolution ­— is this awesome(y/n)?
11:56:25 <EvanR7> k
11:56:42 <EvanR7> like c++?
11:56:44 <EvanR7> not awesome
11:56:55 <luite> but I should stop complaining about everything and get backt o work, now that I ahve a halfway decent UI design for the site
11:57:13 <ski> chrisdone : you mean ad-hoc overloading ?
11:57:29 <chrisdone> ski: what do you mean by ad-hoc overloading?
11:57:44 <monochrom> it means type-directed name resolution
11:57:44 <EvanR7> like type classes
11:57:59 <monochrom> and I'm serious this time
11:58:01 <Cale> chrisdone: ad-hoc overloading is deciding which definition to use based on the local type context at the point of usage alone.
11:58:09 <ski> chrisdone : having one function `foo :: String -> String' and another `foo :: (String,Int) -> String' in the same scopr
11:58:16 <ski> s/scopr/scope/
11:58:17 <chrisdone> i mean that X.foo :: Int -> (); and Y.foo :: Char -> (); import X; import Y; foo (undefined :: Char) compiles
11:58:34 <chrisdone> ski: yeah, that
11:59:35 <chrisdone> i just find qualified names on my record names inconvenient to type and read and the prefixFieldName verbose to read
11:59:47 <chrisdone> s/record names/field names
11:59:50 <EvanR7> N.field
11:59:55 <chrisdone> yeah, that. ugh
11:59:58 <EvanR7> use single letter qualifiers ;)
12:00:29 <ski> in some cases, it could be alleviated by allowing `import' declarations inside `let' and `where'
12:00:31 <chrisdone> most other languages can just do it
12:00:34 <monochrom> http://www.mail-archive.com/haskell-cafe@haskell.org/msg84162.html \∩/
12:00:37 <Cale> chrisdone: Normally I'll make those prefixes a one or two letter abbreviation of the type name.
12:00:54 <ski> or maybe that should be `module F = Foo' synonym declarations ..
12:01:03 <chrisdone> monochrom: haha
12:01:18 <ski> (since actually importing from another compilation unit is more complicated)
12:01:40 <chrisdone> Cale: yeah — for haskelldb I have F.foo for all my field names. it's workable, but it is line-noise
12:02:08 <ski> hm, no i'm thinking of `open Foo'
12:02:14 <Cale> chrisdone: Oh, I suppose you can't really control what haskelldb generates for field names too carefully.
12:02:33 <Cale> (or does it have that option?)
12:02:36 <ski> in SML one can write `Foo.f x + let open Foo in f y end'
12:02:38 <chrisdone> Cale: you can control it more or less completely if you write them yourself
12:02:45 <Cale> yeah
12:02:46 <chrisdone> Cale: (which i do)
12:03:03 <chrisdone>   update T.submission (\sub -> sub!F.id .==. val sid') $ \_ ->
12:03:03 <chrisdone>       F.copyrightSigned <<- True
12:03:03 <chrisdone>     # F.state <<- showEnum CameraReady
12:03:05 <Cale> I don't like qualified names when I can avoid them.
12:03:05 <chrisdone> ^ for example
12:03:38 <Cale> The configurability of the prefixes is nice, but I hate the choice of . as module path separator.
12:03:42 <chrisdone> (the F. has become silent to me after a year of coding this project, but every so often i notice how butt-ugly it is)
12:03:50 <ski> OCaml also has an extension in which one can write `Foo.(f x + f y)'
12:03:52 <Cale> It looks like function composition
12:04:07 <EvanR7> F,foo
12:04:15 <ski> chrisdone : would any of those two help ?
12:04:16 <Cale> and it's absolutely terrible in the case of infix operators
12:04:17 <chrisdone> Cale: yeah… very often I'll write something like map (Just.x) and get a compile error
12:04:18 <EvanR7> now the websters will hate haskell
12:04:35 <Cale> F|foo would be better, I think.
12:04:50 <chrisdone> ski: that's quite nice, yeah. I think in my model functions I would write DB.( … ) and be very happy, yeah. the local import one, too
12:04:54 <EvanR7> | isnt available as an operator?
12:04:55 <ski> Cale : yeah, the look-alike composition confused me initially when i saw them too
12:05:26 <EvanR7> anyway more shift keys makes it harder to type
12:05:32 <Cale> ski: It's not so much that it's confusing, but that it visually makes composites harder to parse
12:05:33 <ville> As a C++ programmer . makes perfect sense
12:05:39 <chrisdone> :t let x = 1 in Just.x
12:05:39 <lambdabot> Couldn't find qualified module.
12:05:43 <ski> chrisdone : yeah, except i realized i meant local *open* (you'd still probably `import' the modules at the top, i think)
12:05:47 <EvanR7> ville: i think thats part of the problem ;)
12:06:03 <EvanR7> haskell is antic++
12:06:08 <ski> Cale : yeah, it's confusing to the eye :)
12:06:09 <Cale> F.foo . G.bar . H.quux
12:06:12 <chrisdone> ski: sure — i know what you mean. that would be fine as long as you could do a kind of lexical specialisation
12:06:26 <ski> Cale : also `F.g.h'
12:06:27 <ville> F:x ?
12:06:34 <Cale> ski: yeah
12:06:42 <chrisdone> F:x is nice in lisp but conflicts with (:) :: a -> [a] -> [a]
12:06:52 <Cale> ville: : would be okay if we weren't already using it for cons
12:07:13 <EvanR7> /F/foo
12:07:26 <ski> Cale : don't you think `x Foo.+ y' is semi-ok ?
12:07:27 <ville> probably quite difficult to comeup with something that wouldn't have context sensitive meaning and also not look but ugly this late in the game
12:07:50 <Cale> ski: I mean, there's not much you can do about it. It's good that it's possible to write that.
12:07:58 <EvanR7> ville: its unfortunate that issues like this is what causes 9 out of 10 garage cs students to 'write their own language'
12:08:09 <Cale> ski: But I hate doing it and will always try to avoid it by importing things unqualified.
12:08:36 <chrisdone> ski's solutions would make me very happy. it has lots of other use cases
12:08:59 <chrisdone> think of blaze-html/esdls — Html.( head $ div $ … )
12:09:16 <ski> (and given that `Foo.+' is used infix, the expressionified version naturally becomes `(Foo.+)' .. though with the above `Foo.(f + g)' idea, i suppose one could allow `Foo.(+)' as well)
12:09:31 <EvanR7> html combinators are trivial monads
12:09:45 <EvanR7> no need for syntax
12:10:18 <ski> chrisdone : well, OCaml has it. complain to devs why only ocamlers should have this shiny thing ? ;)
12:10:59 <kmc> EvanR7, well, inventing your own language and implementing it is a fun exercise
12:11:03 <chrisdone> ski: :P
12:11:12 <kmc> you just shouldn't think that you've done anything new, without doing a fuckload of research
12:11:19 <EvanR7> kmc: yes but 8/10 of those end up being attempts at 'serious languages'
12:11:46 <EvanR7> and thats why we have php
12:11:52 <Saizan> pulling statistics out of nowhere, or?
12:11:53 <chrisdone> EvanR7: what i demonstrated isn't syntax. just normal monadic functions. the point was normally you have to either import Prelude hiding ((div,head)) or qualify your html use H.div H.head
12:12:14 <dolio> These nulls in Java are a problem. I'll invent a totally new language to solve it!
12:12:19 <monochrom> 7/10 of statistics are fun exercises
12:12:25 <EvanR7> chrisdone: use flag for no implicit prelude
12:12:37 <chrisdone> EvanR7: again you're missing the point — on purpose?
12:12:40 <kmc> the problem is that sometimes they escape the garage and then it's like "damnit guido, why couldn't you have read about Scheme's scoping rules first"
12:12:43 <dolio> It'll be like Java + some nullable type shenanigans.
12:13:04 <chrisdone> dolio: C#? /trollface
12:13:04 <kmc> dolio, sounds like Ceylon
12:13:05 * ski . o O ( "A recent study shows eight out of ten people will pull statistics out of nowhere, when feeling pressed." )
12:13:19 <EvanR7> chrisdone: i dont see how you will avoid typing either div (what i would recommend) or using a qualifier
12:13:36 <dolio> kmc: Joke's on you. It's kotlin.
12:13:59 <chrisdone> EvanR7: … by the proposal above
12:14:15 <chrisdone> (but seriously C# has nullable types since recently)
12:14:25 <chrisdone> http://msdn.microsoft.com/en-us/library/1t3y8s4s(v=vs.80).aspx
12:14:41 <ski> EvanR7 : local opening of modules
12:14:42 <dpratt71> Cale?
12:14:50 <thoughtpolice> dolio: that's what i thought you were referring to. neither exist at the moment at any rate :)
12:15:03 <dolio> I thought kotlin actually existed.
12:15:04 <EvanR7> ski: ive been trying to do this sort of thing in javascript with 'with'
12:15:10 <EvanR7> it doesnt turn out well
12:15:17 <Cale> dpratt71: hi
12:15:21 <dpratt71> hi
12:15:23 <copumpkin> I thought kotlin existed, too
12:15:24 <dolio> It's remarkable how many of the same bad ideas they have.
12:15:31 <dpratt71> you know anything about tiny magnets?
12:15:44 <kmc> dpratt71, i know not to eat more than one of them
12:15:46 <EvanR7> like electrons?
12:15:47 <ski> EvanR7 : `let open Html in head $ div $ ...' vel `Html.(head $ div $ ...)'
12:15:57 <dolio> Like, they both do case analysis as something like 'if(x != null) ... else ...'.
12:16:00 <dpratt71> kmc: heh, yeah I've heard that :)
12:16:04 <dolio> Where the true branch lets you treat x as non-null.
12:16:20 <Cale> dpratt71: What's up?
12:16:34 <EvanR7> ski: yeah...
12:16:54 <dainanaki> I hate time datatype conversions with a passion
12:16:57 <EvanR7> ski: the same could be accomplished by using smaller modules
12:16:57 <dpratt71> Cale: for some reason I have it in my mind that you might have some experience with tiny magnets. No?
12:17:01 <Cale> Yes
12:17:04 <thoughtpolice> dolio: no, it's just a spec at this point. there is no download or anything. ceylon apparently has like a timer or something
12:17:09 <chrisdone> dainanaki: converting from time-old to the new time library?
12:17:10 <monochrom> 3 kotlin exists. the island, the warship class, and the programming language
12:17:17 <dainanaki> chrisdone, exactly
12:17:17 <ski> EvanR7 : what doesn't work well in ECMAScript ? i don't know how `with' works
12:17:25 <Cale> I have a lot of experience with 5mm neodymium ball magnets :)
12:17:28 <dolio> It's like calculus.
12:17:49 <EvanR7> ski: with(obj){ statements }, statements now has all members of obj in its environment. but its for executing statements
12:17:50 <dolio> Two people working independently to come up with almost identical mediocre Java successors.
12:17:51 <chrisdone> dainanaki: might be useful… http://hpaste.org/49598
12:18:07 <Cale> http://www.flickr.com/photos/cgibbard/
12:18:07 <thoughtpolice> dolio: "The compiler is being developed alongside with an IntelliJ IDEA integration, so the users will get IDE support as soon as they get the compiler (first public version is planned for the end of 2011)."
12:18:09 <EvanR7> ski: needs a 'with expression'
12:18:16 <dpratt71> Cale: I got some as a gift from the wife; I need to know: 1. what I can do with them and 2. where I can get more without mortgaging the house
12:18:17 <ski> EvanR7 : "the same could be accomplished by using smaller modules" -- i'm not convinced this is always sensible
12:18:18 <dolio> Ah, okay.
12:18:21 <Cale> http://www.youtube.com/user/cgibbard
12:18:21 <chrisdone> dainanaki: if you make something nicer… give it to me :-)
12:18:43 <Cale> dpratt71: How many do you have?
12:18:46 <dpratt71> Cale: ah, that's why I thought of you :)
12:18:51 <dainanaki> chrisdone, thanks, but the performance of strings is prohibitively bad for my current project.
12:18:55 <dpratt71> 1 pkg, 216
12:18:56 <chrisdone> the with(…) we already have in Haskell somewhat
12:18:58 <EvanR7> ski: the question of sensible is trumped in my mind by existence of technology ;)
12:19:05 <chrisdone> f (MyModule{..}) = …
12:19:14 <chrisdone> (which i use A LOT)
12:19:20 <Cale> dpratt71: Okay, so that's enough for lots of little things :)
12:19:36 <Cale> dpratt71: Start with little loops of 5 or 6
12:19:41 <ski> EvanR7 : hehe
12:20:11 <Cale> um, or even 2-layer hexagons, you can make 12 of those
12:20:25 <chrisdone> ski: what do you think of the MyModule{..} approach? it means you have to shove everything in a data type but it's a cute trick to get local modules, i suppose
12:20:33 <ski> > let Node {..} = Node () [] in (rootLabel,subForest)
12:20:33 <lambdabot>   Illegal `..' in record pattern
12:20:33 <lambdabot>  Use -XRecordWildCards to permit this
12:20:36 <Cale> (a loop of 6, and then continue wrapping to put 6*2 magnets in a second layer)
12:20:47 * chrisdone slaps lambdabot about the haid
12:21:10 <dpratt71> besides your YouTube channel, any other good places to look for inspiration/instruction?
12:21:13 <Cale> http://www.flickr.com/photos/cgibbard/5168792854/in/photostream
12:21:15 <Cale> um
12:21:40 <Cale> There's a lot of people on YouTube making more stuff (probably more accessible stuff too :)
12:21:52 <Cale> http://www.youtube.com/watch?v=wOv0AkphLhE&feature=player_embedded
12:21:55 <luite> hehe is that a decay diagram? ;)
12:22:12 <ski> chrisdone : doesn't work with (concrete) type declarations now with classes and instances. still, yes it can be quite useful (e.g. when combined with existentials)
12:22:14 <Cale> Is a little demo by the zen magnets guy with exactly your set of magnets :)
12:22:27 <chrisdone> ski: good point
12:22:39 <dpratt71> Cale: oh, cool
12:22:49 <chrisdone> ah, yeah. existentials in this way has some nice uses
12:23:45 <Cale> luite: sort of :)
12:24:12 <dpratt71> nah, I don't think those are the magnets I have; mine are far less cooperative
12:24:19 <ski> chrisdone : like `data QueueOps a = forall q. QOps {empty :: q; queue :: a -> q -> q; dequeue :: q -> Maybe (q,a)}' together with `mkInefficientStackOps,mkEfficientStackOps :: StackOps a'
12:24:22 <Cale> luite: if there was a category of magnet constructions, this would be a part of it :)
12:24:56 <chrisdone> (the really nice thing about haskelldb's query monad is that it's, well, monadic. you can do nice things like: do x <- table foo; when … (restrict …); return x. composing queries is really easy)
12:25:28 <Cale> dpratt71: huh... :)
12:25:49 <Cale> dpratt71: the video is sped up a little in places
12:26:06 <dpratt71> Cale: joking :)
12:26:11 <ski> chrisdone : or `data SetOps a = forall s. SOps {empty :: s; union :: s -> s -> s; singleton :: s -> s; member :: s -> a -> Bool; toList :: s -> NonDet [a]}' with `mkSetOps :: (a -> a -> Ordering) -> SetOps a' which nicely avoid the problem of taking union of two sets with different orderings, but still allows arbitrary orderings
12:26:57 <chrisdone> ski: keeps the q inside the 'module' right?
12:27:02 <ski> nod
12:27:09 <Cale> dpratt71: One thing you have to develop strategies for immediately is keeping track of the polarity of the magnets, because you can't see it (though you can feel it if you're careful), and it matters to how they stick together.
12:27:30 <ski> chrisdone : this is quite similar to how module functors in the MLs work
12:27:39 <dpratt71> Cale: I have definitely notice that, but I have no good sense of how to do that
12:27:41 <Cale> dpratt71: A good way is to start with them all in a chain, and build subcomponents in *exactly* the same way, being careful not to flip them over.
12:27:59 <Cale> Things which are symmetrical can have one less symmetry than you think :)
12:28:09 <ski> chrisdone : except that there the modules (and module functors) exist at a level of their own, instead of being simulated by types as above
12:28:13 <Cale> If you make a loop, clockwise/counterclockwise matters.
12:28:57 <ski> chrisdone : ah, and sorry, s/Stack/Queue/ :)
12:29:07 <chrisdone> ski: that's nice.
12:29:09 <chrisdone> heh, sure
12:29:43 <ski> so, you'd generally open the existential record once, then do your work inside it until you're done
12:29:44 <dpratt71> I've noticed if I stack loops in one manner, the balls line up lengthwise, otherwise they interlock (or line up in spirals); strange and fascinating! :)
12:29:44 <Cale> dpratt71: But if you're careful, you can feel the polarity out without letting your components touch.
12:29:44 <chrisdone> ski: can you make class exports optional with ml modules?
12:29:51 <chrisdone> right
12:29:57 <Cale> yes
12:30:00 <ski> (though it would be possible to make a new existential with the ops and some partial results)
12:30:52 <chrisdone> hm— do existentials allow GHC to garbage more effectively?
12:30:57 <ski> chrisdone : no type classes in the MLs .. however i think you can make type classes non-exported in Mercury (i'm not sure how they hande the potential problems, if at all)
12:31:02 <Cale> If two chains are in the same direction, they will enmesh (forming a triangle strip), and in opposite directions, they will attach loosely (forming a square strip)
12:31:02 <chrisdone> (and rank N types)
12:31:14 <dpratt71> Cale: a bit of skill is involved, I can see that; I keep trying a particular design and end up destroying it by accidentally letting a magnet make contact with the wrong polarity
12:31:19 <chrisdone> ski: oh, i see
12:31:20 <Cale> Which means that two loops of the same orientation will attach loosely.
12:31:35 <Cale> and loops of opposite orientation will enmesh (which is annoying)
12:31:49 <Cale> yeah, especially small things are hard
12:32:09 <ski> chrisdone : i'm not sure whether GHC GCs more efficiently with existentials, but it could possibly be done ..
12:32:23 <ski> chrisdone : well, at least ignoring `seq', it could be done :)
12:32:23 <Cale> I have 3240 magnets now, and so I can get away with working with bigger components which only attach in nice easy to manipulate ways :)
12:32:35 <dpratt71> Cale: !!
12:32:43 <Cale> But at that level, you have to be extremely careful
12:33:12 <dpratt71> Cale: yeah, getting a cascade effect on a design almost done would really suck
12:33:17 <ski> chrisdone : there's special support for projections wrt GC in GHC, though
12:33:42 <chrisdone> ski: that set operations example is nice indeed
12:34:08 <chrisdone> ski: projections? google's not helping
12:35:13 <ski> chrisdone : see <http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects?redirectedfrom=Commentary/Rts/HeapObjects#Selectorthunks>
12:36:13 <ski> chrisdone : btw, this `QueueOps' and `SetOps' i think i saw Adrian Hey explain in a thread on comp.lang.functional, some years ago
12:36:35 <ski> s/i think/idea i think/
12:36:41 <Cale> dpratt71: One nice thing about zenmagnets is that they give away lots of free magnets to people who submit photos to their gallery.
12:36:47 <Cale> dpratt71: (on flickr)
12:37:13 <Cale> dpratt71: I started out with the set of 1728, and all the rest of my magnets were free
12:37:19 <ski> chrisdone : hm, i suppose <http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects#Selectorthunks> is a better working link to it
12:37:20 <Cale> dpratt71: You should come to #magnets
12:37:25 <dpratt71> Cale: nice :)
12:37:35 <chrisdone> ski: they both worked thanks ;)
12:37:39 <Cale> I've been trying to get the channel going, but it's hard to get a critical mass
12:37:53 <ski> chrisdone : the former didn't seem to jump to the achor correctly, here
12:37:55 <dpratt71> Cale: heh, I shoulda known there was a #magnets; I didn't even look
12:38:07 <chrisdone> ski: are you using opera?
12:38:09 <Cale> One other guy still hangs around there, for a while, we had the founder of zenmagnets, but he hasn't been on
12:38:14 <ski> chrisdone : i'm using w3m
12:38:18 <chrisdone> ah, ok
12:39:28 <dpratt71> well, I gotta go do something productive, but I'll def. check it out later
12:39:42 <dpratt71> Cale: thanks for the links
12:39:55 * hackagebot aeson-pretty 0.3.1 - JSON pretty-printing library and command-line tool.  http://hackage.haskell.org/package/aeson-pretty-0.3.1 (FalkoPeters)
12:40:11 <Cale> http://farm5.static.flickr.com/4106/5168792854_33fc043e0b_b.jpg -- here's the big version of that diagram... flickr likes to make things smaller than they need to be
12:40:45 <chrisdone> cool — re reclaiming the unreachable b
12:41:32 <c_wraith> Cale, is there a live presentation that goes with this somewhere?
12:41:58 <Cale> c_wraith: that's a good idea
12:42:06 <Cale> (but not yet)
12:49:12 <drdo> What happens if you kill a thread reading/writing from/to a Chan?
12:49:48 <kmc> it either reads/writes or doesn't, depending on timing
12:49:56 <kmc> i don't think anything special / weird happens
12:50:07 <drdo> oh, alright
12:50:14 <c_wraith> and it shouldn't corrupt the state of the chan.
12:50:17 <kmc> are you seeing weird behavior?
12:50:24 <drdo> No, i was just asking
12:50:37 <drdo> If it was safe to do so
12:50:41 <kmc> in GHC Chan is implemented with MVar, but it should have the appropriate exception handling to leave those MVars in a usable state
12:52:36 <peddie> @slap kovach
12:52:36 * lambdabot hits kovach with an assortment of kitchen utensils
12:53:13 <chrisdone> i think readMVar if interrupted half way through can leave the var empty
12:53:36 <chrisdone> whereas withMVar and modifyMVar have a finally-esque clause to handle exceptions and put the var back in there on exceptions
12:54:15 <chrisdone> oh, you're talking about chans
12:54:19 * chrisdone goes back to coding
12:54:19 <kmc> readMVar masks asynchronous exceptions
12:54:48 <kmc> i guess that is cheaper than using an exception handler, or something?
12:54:50 <chrisdone> readMVar = takeMVar + putMVar
12:54:54 <chrisdone> what do you mean by mask?
12:54:59 <kmc> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.1.0/src/Control-Concurrent-MVar.html#readMVar
12:55:11 <kmc> :t Control.Exception.mask
12:55:12 <lambdabot> Not in scope: `Control.Exception.mask'
12:55:22 <kmc> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.1.0/Control-Exception.html#g:11
12:55:26 <chrisdone> hum, mask_
12:55:53 <kmc> hot damn, a rank-3 type
12:56:07 <chrisdone> interesting
12:56:15 <copumpkin> there's that paper on rank-6 types in parser combinators
12:56:33 <kmc> hahaha
12:56:35 <kmc> had not seen that
12:56:38 <dainanaki> chrisdone: about time stuff, you can use Data.Time.Clock.POSIX to turn things into UTC times. I realized that since NominalDiffs are instances of Num and Fractional, you just use either realToFrac or fromInteger to turn seconds into UTCTimes
12:57:12 <pitaspita> wow
12:57:15 <pitaspita> lots of people
12:57:16 <djahandarie> The mask function looks somewhat like the standard rank-2 CPS transform thingy, but now really
12:57:19 <djahandarie> not*
13:01:22 <shapr> Anyone in or near Portland Oregon wants to hang out in the next five days? I'll be in Portland!
13:01:43 <c_wraith> shapr: I responded on G+
13:02:10 <shachaf> shapr: Is the Bay area near enough?
13:02:21 <shapr> shachaf: Er, that's quite a drive :-)
13:02:28 <shapr> c_wraith: oh so you're the OpenID guy :-)
13:02:34 <ski> chrisdone : found the thread ! :) "Re: Is overloading a good thing?" by Adrian Hey in 2002-07-17 at <http://groups.google.com/group/comp.lang.functional/msg/22ea87a1cb8abfb8> .. the rest of the thread is also interesting, if you like that sort of thing
13:02:43 <c_wraith> shapr: indeed.  That's something I've done. :)
13:03:09 <chrisdone> ski: hey thanks :-)
13:03:39 <shapr> shachaf: Looks like a twelve hour drive from the Bay Area to Portland OR
13:03:56 <shachaf> shapr: Yep. I've done that.
13:04:09 <shachaf> (Well, from Washington.)
13:04:28 <shapr> Whoa, I completely misread that Google Maps result as "This route has trolls."
13:04:45 <shachaf> shapr: You should come visit sometime!
13:04:52 <shachaf> What are you doing in Portland?
13:04:57 <monochrom> oh, this route has tolls :)
13:04:58 <c_wraith> OSCON, probably
13:04:58 <chrisdone> shapr: `(D_  D)/ 'oo goes there?
13:05:07 <c_wraith> or else the knitting convention
13:05:09 <shapr> shachaf: knitting conference
13:05:11 <c_wraith> that's this weekend
13:05:12 <c_wraith> hah
13:05:13 <shapr> c_wraith: ha!
13:05:40 <kmc> haha shapr
13:06:19 <shapr> c_wraith: do you knit?
13:06:47 <c_wraith> shapr: no.  One of my friends is going to be in from california because his wife does, though.  That's the only reason I know about it.
13:06:51 <monochrom> abstract type (hidden by module) is existential type, yeah
13:08:55 <chrisdone> ski: that code's nice to read --- so the oops line would yield 'couldn't match expected type set against set1' or some such?
13:09:25 <chrisdone> and (asList set) ++ (asList' set') is allowed because asList produces only [a]
13:09:33 * chrisdone 's brain melts in the beauty
13:10:06 <chrisdone> http://catmacros.files.wordpress.com/2009/06/its_beautiful.jpg
13:12:14 * chrisdone bookmarks
13:20:13 <lda> is HUnit known to require a ton of ram to compile? it's been stuck at the linking stage for a while and my system is swapping like crazy
13:20:51 <shachaf> Are you accidentally using JHC?
13:21:23 <Saizan> object code produced by GHC tends to make ld use a lot of ram in general
13:21:29 <lda> GHC 7.0.3, installing with cabal
13:21:38 <Saizan> the gold linker is better at it
13:22:32 <chrisdone> be aware gold linker doesn't support some parameters that gnu ld does, likely to cause a bunch of build failures, at least ime
13:23:27 <Saizan> worked fine for me in the past
13:23:32 <lda> thanks, i'll wait some more and give gold a whirl if necessary
13:23:50 <lda> Saizan: any tips on how to tell ghc to use gold?
13:24:49 <Saizan> "-pgml cmd" is the flag
13:25:22 <Saizan> (though i just had ld point to gold)
13:25:38 <lda> sweet
13:30:58 <Cale> chrisdone: and it could be made more beautiful today because GHC does support record syntax with existentials now
13:31:07 <Cale> (that was from 2002 :)
13:32:21 <Cale> also, you could use RecordWildCards (though I've been a little suspicious about the quality of interaction of this extension with others such as Arrows, lately)
13:32:52 <dolio> Am I going to have to add r/haskell to my list of reddits that aren't really worth looking at anymore?
13:32:53 <Cale> makeSet comp = Set {..} where ... definitions of Set methods ...
13:33:20 <Cale> dolio: I just have it in my subscription list so that it's mixed into my front page
13:33:29 <Cale> But I don't actually visit it explicitly.
13:33:50 <Cale> (but why do you say that?)
13:34:27 <dolio> Because I'm tired of, "most programmers are incapable of understanding what monoids are, so Haskell is flawed."
13:34:35 <dolio> And the like.
13:36:53 <thoughtpolice> dolio: oh, is this the recent thing on the top of /r/haskell? yeah, those irritate me too sometimes
13:37:14 * Phyx- concurs, even though he doesn't know what monoids are :p
13:37:36 <dolio> Or going back a little further, there was someone writing 8 page posts in response to 'laziness covers a lot of use for generators' by saying, "You have to choose between foldr and foldl!! QED!!"
13:37:50 <thoughtpolice> oh, that crazy ralfn guy?
13:37:54 <thoughtpolice> yeah, i remember that one.
13:38:38 <thoughtpolice> dolio: in the current case i can't exactly take someone very seriously who's so dismissive. it's like "I want to learn haskell, but all these THINGS ARE HERE I DO NOT UNDERSTAND. MAKE IT EASY YOU WEIRDOS. PROGRAMS ARE NOT PROOFS" yada yada
13:39:03 <thoughtpolice> well, yes, things typically do not make a whole lot of sense when you first engage them. this is not so surprising for the most part
13:39:09 <ski> chrisdone : yeah :)
13:39:16 <msieradzki> how do I make unboxed vector for custom type?
13:39:34 <Botje> thoughtpolice: things will cool down once september starts :)
13:40:00 <thoughtpolice> msieradzki: you need to make your datatype an instance of Data.Vector.Unboxed.Unbox
13:40:04 <msieradzki> how
13:40:17 <msieradzki> http://hackage.haskell.org/packages/archive/vector/0.7.1/doc/html/Data-Vector-Unboxed.html this confused em
13:40:19 <copumpkin> and write a suitable data family instance and make a bunch of instances
13:40:26 <thoughtpolice> oh wait, good point. the documentation doesn't even have the associated instances?!
13:40:27 <copumpkin> and don't forget to make a mutable instance too
13:40:35 <thoughtpolice> ooooohhh
13:40:37 <thoughtpolice> nvm
13:40:41 <thoughtpolice> msieradzki: look at the example at the top
13:40:46 <thoughtpolice> not Data.Vector.Unboxed.Unboxed
13:40:56 <thoughtpolice> make instances of Data.Vector.Generic.Mutable.MVector
13:41:07 <thoughtpolice> and an instance of Data.Vector.Generic.Vector
13:41:17 <Saizan> Botje: so reddit's august is usenet's september ?
13:41:36 <dolio> thoughtpolice: I just can't take seriously people who are in effect saying, "programming shouldn't require math that isn't really any more difficult the stuff an average high school student knows."
13:42:24 <msieradzki> thoughtpolice, I understand how to make instance for some type and some class however I don't understand what you said at all
13:42:32 <msieradzki> what class what instance
13:42:41 <Botje> s/reddit's august/school holiday/ :)
13:43:17 <dolio> Not that you learn what a monoid is in most high schools. But there's nothing difficult about the definition.
13:43:26 <copumpkin> dolio: the name scares me
13:43:32 * copumpkin huddles in the corner
13:43:55 <thoughtpolice> msieradzki: sorry if i'm confusing :P. to make an instance, you basically should look at the example at the top of Data.Vector.Unboxed - it's a simple example of what you would need to do to implement, for example, an instance for 'Complex a'
13:43:56 <copumpkin> the name sounds like something a mathematician would use, and everyone knows mathematicians don't do anything practical
13:44:22 <copumpkin> AbstractSingletonProxyFactoryBean on the other hand
13:44:25 <copumpkin> that makes perfect sense
13:44:28 <thoughtpolice> copumpkin: AbstractSingletonProxyFactoryBean
13:44:30 <monochrom> nice, existential type allows higher kinds too, data C a = forall f. C{blah :: a -> f a}
13:44:34 <thoughtpolice> DAMNIT
13:44:37 <thoughtpolice> i got beaten to the punch
13:44:48 * copumpkin punches thoughtpolice to the beat
13:44:55 <thoughtpolice> fffuuuuuuuuuu
13:45:09 <chrisdone> monoid sounds like a name for a hairless alien species that communicates telepathically from star trek
13:45:11 <msieradzki> this example has 2 newtype instances
13:45:31 <msieradzki> and then instance with 30-50 vector functions is that what you said?
13:45:35 <monochrom> @remember chrisdone monoid sounds like a name for a hairless alien species that communicates telepathically from star trek
13:45:35 <lambdabot> Okay.
13:45:54 <thoughtpolice> msieradzki: yes, you have to make those two newtype instances. you have to make a newtype instance for both MVector and Vector, and a class instance for the Vector and MVector classes
13:46:24 <thoughtpolice> msieradzki: i don't think all of those are required
13:46:37 <thoughtpolice> (the type class instance functions, that is)
13:46:58 <thoughtpolice> msieradzki:
13:46:59 <msieradzki> is there any example in the wild not in vector package
13:46:59 <thoughtpolice> http://hackage.haskell.org/packages/archive/vector/0.7.1/doc/html/src/Data-Vector-Unboxed-Base.html#Unbox
13:47:00 <msieradzki> that does it
13:47:08 <thoughtpolice> look at the bottom, there is a very simple definition for 'Complex a'
13:47:20 <msieradzki> ok I'm reading
13:47:38 <thoughtpolice> notably the 'instance (RealFloat a, Unbox a) => G.Vector Vector (Complex a) where' line - as for packages that do it in the wild, i honestly am not sure
13:48:38 <thoughtpolice> dolio: yeah, i think that's at the heart of a lot of complaints
13:48:47 <thoughtpolice> (re: high school maths thing)
13:48:49 <chrisdone_> Rob Schneider was just an ordinary guy with a job who liked programming, until one day, everything was about to change… derp derp de der, de durp de der! Rob Schneider is… a monoid! Rated PG-13.
13:49:22 <thoughtpolice> chrisdone_++
13:50:58 <ski> monochrom : of course
13:51:10 * monochrom ♥ haskell
13:51:58 * monochrom is ... derp derp derp... a monoid!
13:52:28 <copumpkin> is ♥ associative?
13:52:45 * copumpkin tries to get everyone excited about his derpa project
13:53:24 <kmc> copumpkin, omg i'm so pumped up
13:53:26 <kmc> srsly what is it
13:53:35 <monochrom> that's like "is > associative?". I say it's "type error: couldn't match a0 with Bool"
13:53:37 <thoughtpolice> bro it's all over twitter already, #derap ftw
13:53:39 <kmc> repa + dph = derpa?
13:53:49 <thoughtpolice> #derpa
13:53:51 <thoughtpolice> kmc: yep
13:53:53 <geheimdienst> kmc: you're copumped up?
13:53:57 <kmc> more like #derpwned
13:53:59 <copumpkin> kmc: it's dependent repa :P
13:54:02 <kmc> ah
13:54:03 <copumpkin> misspelled a bit
13:54:07 <kmc> "dependent"?
13:54:07 <copumpkin> hence, derpa!
13:54:11 <kmc> or are you using Agda ;P
13:54:18 <copumpkin> I basically translated repa to agda and made it all safe n shit
13:54:24 <copumpkin> also
13:54:26 <copumpkin> all slow n shit
13:54:30 <thoughtpolice> safe n shit
13:54:33 <thoughtpolice> like, type systems yo
13:54:39 * ski . o O ( `a -> exists w. Comonad w *> (w b,w b -> a)' )
13:55:26 * chrisdone isn't sure what's going on but smiles in case he gets hurt by a leaking higher rank type
13:55:43 <monochrom> is that a formalization of "safe n shit"? i.e., "w b" is "safe", "w b -> a" is "shit"
13:55:58 <monochrom> and btw why is b a free variable?
13:56:15 <chrisdone> hehe, variable fascist
13:56:51 <geheimdienst> @remember thoughtpolice <copumpkin> I basically translated repa to agda and made it all safe n shit. also all slow n shit <thoughtpolice> safe n shit, like, type systems yo
13:56:51 <lambdabot> It is forever etched in my memory.
13:57:31 <dolio> Not to be confused with drepa, the bot that will automatically respond to reports on your bug tracker with insults and invective.
13:58:12 <monochrom> bots these days show no respect to hard-working programmers
13:58:13 <chrisdone> hmm, we have a human doing that a work. sounds like an investment
13:58:36 <kmc> dolio++
13:58:53 <kmc> type systems? i heard those are more trouble than they're worth
13:59:03 <kmc> if i tell the computer what i mean, who is it to question me
13:59:52 <monochrom> it can automatically insult you, remember? :)
14:00:56 <theorbtwo> Well, that's one way to respond to ghc having overly-long error messages.  Just replace all error messges with "that's the stupidist shit I've ever heard".
14:01:00 <theorbtwo> See, not too long!
14:01:15 <monochrom> hahaha
14:01:25 <kubrat> 22:29 < monochrom> hahaha
14:01:30 <monochrom> @remember theorbtwo Well, that's one way to respond to ghc having overly-long error messages.  Just replace all error messges with "that's the stupidist shit I've ever heard".
14:01:30 <lambdabot> Done.
14:02:15 <theorbtwo> Yey!  I'm in #haskell's quote DB, I can die happy now.
14:02:18 <sipa> kubrat: your clock seem wrong
14:02:26 <monochrom> my sentiment too
14:02:40 <theorbtwo> Indeed.  I make that line at 22:17.
14:03:15 <kmc> @quote skolems
14:03:15 <lambdabot> chrisdone says: anyone got a fixed version of the split library for ghc7? some Tolkienesque error messages about skolems escaping
14:03:17 <geheimdienst> we could make hackagebot more insulty. "abstract-nonsense 0.4.2 http://hackage.haskell.org/... (EdwardKmett). Man, what on Earth is that thing good for?"
14:03:28 <monochrom> haha
14:03:32 <sipa> hahaha
14:03:41 <sipa> ha(ha)+
14:04:00 <kmc> > iterate ("ha"++) ""
14:04:01 <lambdabot>   ["","ha","haha","hahaha","hahahaha","hahahahaha","hahahahahaha","hahahahaha...
14:04:23 <mreh> > cycle "lo"
14:04:23 <lambdabot>   "lololololololololololololololololololololololololololololololololololololo...
14:04:26 <chrisdone> nice evil genius function
14:04:28 <monochrom> (ha)ω
14:04:48 <chrisdone> unsafeDemand100MillionDollars
14:04:49 <copumpkin> > iterate ("ha" ++) "muahaha"
14:04:50 <lambdabot>   ["muahaha","hamuahaha","hahamuahaha","hahahamuahaha","hahahahamuahaha","hah...
14:04:54 <copumpkin> dammit
14:05:00 <copumpkin> > iterate (++ "ha") "muahaha"
14:05:01 <lambdabot>   ["muahaha","muahahaha","muahahahaha","muahahahahaha","muahahahahahaha","mua...
14:05:24 <copumpkin> (failed evil mastermind)
14:05:30 <ddarius> copumpkin: No cookie for you.
14:05:41 <mreh> what's repa?
14:06:10 <copumpkin> > "mua" ++ cycle "ha"
14:06:12 <lambdabot>   "muahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahah...
14:06:34 <geheimdienst> not failed, you just had it the other way round. so be sure to doublecheck which way it's pointing when you fire your evil mastermind doomsday cannon
14:08:26 <Cale> dolio: There pretty much always has been stuff written about Haskell by people who don't know what they're talking about, and there basically always will be, as long as Haskell exists.
14:08:40 <Cale> dolio: It's unfortunate, but it's nothing really new.
14:09:05 * ddarius causes Haskell to cease to exist to solve the problem.
14:09:20 * ddarius alternatively causes people to cease to exist.
14:09:20 <mreh> correct them
14:09:36 <ddarius> Poor, poor naive mreh.
14:09:42 <dolio> Cale: yes. I don't care that it exists. But I don't need it interleaved with the content I actually want to read.
14:09:48 <mreh> :D~
14:10:31 <mreh> who's writing this?
14:10:44 <mreh> not that F# evangelist?
14:11:22 * ski . o O ( <http://i.imgur.com/pZtus.jpg> )
14:11:59 <kmc> my one-week experience failing to write a prime number sieve in Haskell qualifies me to write a blog post debunking the hype
14:12:25 <ddarius> How do you fail to write a prime number sieve in Haskell?
14:12:41 <kmc> ddarius, usually by writing something you think is a prime number sieve but isn't
14:12:41 <mreh> mashing the keyboard repeatedly
14:12:54 <kmc> the standard prime number sieves are not prime number sieves, the same way the standard quicksort is not quicksort
14:12:56 * ddarius should write a post debunking the J hype due to my inability to write a prime number generator.
14:12:57 <Saizan> dolio should be made the new implacable moderator of /r/haskell
14:13:15 <kmc> ddarius, have you been writing J?
14:13:25 <chrisdone> now *that* i could believe [mashing hands on keyboard could produce a sieve program in J]
14:13:30 <monochrom> > let { mh (p:ps) = "mua" ++ concat (replicate (p-1) "ha") ++ mh ps; work (p:xs) = p : work (filter (\x -> x `mod` p /= 0) xs) } in mh (work [2..])
14:13:30 <kmc> heh
14:13:31 <ddarius> kmc: I've written J, but I'm not currently writing J.
14:13:31 <lambdabot>   "muahamuahahamuahahahahamuahahahahahahamuahahahahahahahahahahamuahahahahaha...
14:13:36 <mreh> upvote haskell stickers
14:14:13 <kmc> one day /r/haskell will go the way of /r/programming :(
14:14:17 <ddarius> p:i.10  first 10 primes
14:14:17 <mreh> was parsing command line arguments in parsec overkill?
14:14:44 <Philonous> Cale:  But that's not specific to haskell, is it?
14:14:51 <ddarius> mreh: Depends on the syntax of the command line arguments.
14:15:18 <mreh> ddarius: the grammar was quite simple
14:15:22 <mreh> it was fun though
14:15:27 <ddarius> mreh: Was it regular though?
14:15:31 <dolio> Anyhow, this approximately sums up my feelings on the matter: http://www.reddit.com/r/haskell/comments/j0say/my_humble_rant_about_the_haskell_learning_curve/c28cnzy
14:15:44 <mreh> ddarius: yes
14:16:14 <dolio> What people who complain about not being super-genius mathematicians don't understand is that most Haskell folks aren't super-genius mathematicians. They're just people who bothered to struggle and learn instead of complaining about it.
14:17:02 <mreh> start a new thread and I'll testify that I'm not a super genius and program haskell
14:17:03 <c_wraith> huh.  I am currently reading that thread.
14:17:17 <mreh> why isn't everyone else?!
14:17:22 <c_wraith> I think the thing is, most people get very uncomfortable facing the fact that there are things they don't know.
14:17:52 <c_wraith> I know there's a ton of work I don't understand, and I'm perfectly comfortable not understanding it for now.  Maybe I'll get to it later.
14:18:15 <mreh> what's your day job c_wraith
14:18:20 <mreh> if you don't mind me asking
14:18:34 <c_wraith> web software.  Some in haskell, some in ruby.
14:18:53 <chrisdone> i was once a super-genius mathematician but i traded it in for brad pit good looks and excellent literecy
14:19:03 <c_wraith> My company often gets mentioned in regards to haskell doing real public-facing stuff.  I'm at Janrain.
14:19:25 <ddarius> chrisdone: Looks like you got a raw deal on the literecy.
14:19:32 <alxbl> dolio: it's not the "haskell" learning curve, it's the "functional programming curve", which isn't a curve as much as it is a paradigm shift
14:19:59 <monochrom> haha chrisdone
14:20:31 <Botje> it's only a curve in that you have to go back on all the imperative stuff you've learned
14:20:42 <Botje> after that it's a nice straight line.
14:20:50 <Cale> Philonous: right
14:21:05 <geheimdienst> dolio: i agree if the complaining outshadows everything else. but some small amount of complaining is valid, if only as a pointer where teaching could be improved
14:21:11 <Cale> Philonous: but, there seems to be a lot of it when it comes to Haskell
14:21:12 <yitz> alxbl: you mean it has singularities?
14:21:18 <chrisdone> i was thinking about this topic today because Ur the language is quite challenging to me and around it there is the 'it's too hard/must be genius to understand' aura around it, but then i remembered that's what learning something new is
14:21:31 <monochrom> in any case it's the arrogance of "I don't get it, therefore those who get it are abnormal"
14:21:33 <Cale> dolio: In any case, the recent rant has seemed to spark *some* useful discussion
14:22:00 <geheimdienst> the "you need to be a super-genius mathematician" notion imho comes from haskell indeed being difficult to learn. one thing is the needlessly complicated terminology (starting with the word "monad"). another thing is that haddocks are seldom well-written and almost never contain example code ...
14:22:01 <chrisdone> Cale: don't those rants appear like once a month?
14:22:13 <monochrom> and plus what I always say: people write-protect their brains after they graduate or turn 21
14:22:21 <Cale> dolio: I think we could *maybe* do more to encourage beginners to speak up rather than waiting for their questions to be automatically answered in language they understand while lurking.
14:22:39 <Cale> (That's what I see the problem to be in this case)
14:23:16 <monochrom> I disagree that "monad" is complicated terminology. it's even easier to spell than "maintainability". I can't even be sure that I spell "maintainability" right
14:23:42 <dolio> Yeah, we need simple terminology like AbstractSingletonProxyFactoryBean.
14:23:47 <monochrom> and for pete's sake, count the syllables too!
14:23:48 <kmc> monochrom, the pros spell it "m13y"
14:23:53 <mreh> dolio++
14:24:03 <osfameron> the question is, can you still spell "maintainability" after a good refactoring
14:24:19 <yitz> Cale: that's the point about our famous friendly community. we try very, very hard to make it comfortable for newcomers to speak up with their questions.
14:24:23 <Philonous> geheimdienst:  We don't have any good analogies for Monads, so what should we call them (rather than what they actually are)
14:24:39 <yitz> Cale: yet some people *still* manage to lurk. then later on, they complain.
14:24:54 <Cale> yitz: I think so too, but maybe the sign-up pages for the mailing lists could come with a disclaimer :)
14:24:58 <Cale> yeah
14:25:11 <Cale> I don't knwo
14:25:11 <yitz> [ok lurkers, you heard it. where are you? come on!]
14:25:12 <Cale> know*
14:25:18 <Cale> hehe
14:25:20 * zellio lurks
14:25:24 <mreh> it's okay to ask stupid questions
14:25:28 <mreh> how's that?
14:25:31 <kmc> we ♥ beginners
14:25:34 <yitz> zellio++
14:25:53 <yitz> @karma zellio
14:25:53 <lambdabot> zellio has a karma of 1
14:26:00 <geheimdienst> re "maintainability": well i don't mean spelling. and i don't think AbstractSingletonProxyFactoryBean is as central to java as monads are to haskell
14:26:02 <chrisdone> the nice thing about Ur is that i can thing about this topic as a genuine newbie again and apply my experience to what newbies might feel towards haskell. one thing i've noticed is that it's hard to know whether from what is written you are expected to understand it as is. so a haskell newbie reads a bad explanation, is completely baffled, and then says it's too hard (and is right, in the specific context of that expl
14:26:03 <chrisdone> anation)
14:26:05 * Jafet researches Burrow first
14:26:34 <dolio> No, it's not as central.
14:26:39 <Cale> EXCEPT WHEN WE DON'T (╯°□°）╯︵sɹǝuuıƃǝq
14:26:49 <dolio> In the first chapter of a Java book, you get "encapsulation" and "polymorphism."
14:26:52 <thoughtpolice> chrisdone: i'm actually doing some work right now in ur. it's very mind opening
14:27:19 <Cale> j/k beginners ♥
14:27:28 <monochrom> "real world" terminologies are as unfamiliar to me as math words. I had to look up "synergy" and "leverage". IMO "monad" is no worse than "synergy"
14:27:37 <thoughtpolice> chrisdone: truthfully, i understood the type system literally like, a trillion times better after I spent an hour banging my head on a very simple, 10 line example :)
14:27:47 <thoughtpolice> it was very similar to when i started to learn haskell, honestly!
14:27:49 <yitz> chrisdone: for me at least some of the difficulty with Ur is all the ML terminology and syntax.
14:27:54 <Cale> geheimdienst: I don't think monads are as central to Haskell as a lot of people seem to think.
14:27:57 <chrisdone> well, monad means something proper for a new concept. synergy is bullshit made up to replace perfectly good words
14:28:07 <thoughtpolice> yitz: definite -1 due to the ML syntax for me.
14:28:09 <mreh> chrisdone: took the words out of my mouth
14:28:15 <mreh> i suppose people don't like to think
14:28:21 <thoughtpolice> yitz: but at least type application isn't backwards, and you don't need quotes for variables :)
14:28:31 <kmc> what's a good non-bizspeak synonym for "synergy"?
14:28:49 <kmc> it's a real thing and you need a way to talk about it
14:28:49 <ricree> I have a question about FFI.  The C api I'm trying to work with has a function to initialize a somewhat large struct, but not one to allocate a new one.  Is there any easy way to manage that in Haskell?
14:28:53 <Cale> geheimdienst: Sure there are a lot of libraries which define instances of Monad and code which uses the monad interface, *but* it's not important to understand the abstraction so much as it is to understand how to use those libraries.
14:28:54 <yitz> thoughtpolice: does it look a lot easier than agda?
14:29:03 <Philonous> kmc:  What do you mean, thay actually intend to convey meaning with the word?
14:29:06 <kmc> ricree, http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.1.0/Foreign-Marshal-Alloc.html
14:29:11 * chrisdone is also pondering Learn Ur or Learn Agda
14:29:15 <kmc> Philonous, not always.  but one *can* convey meaning with the word "synergy"
14:29:16 <zellio> Wait, why not just learn lisp? I mean, everything Haskell does, it did first.
14:29:21 <mcsquiggedy> Lisp? That's madness!
14:29:24 <kmc> it means when two things work together in a way that's better than the sum of their parts
14:29:29 <thoughtpolice> yitz: oh it's a *lot* easier than agda, trust me
14:29:36 <kmc> zellio, static types?
14:29:45 <kmc> zellio, also s/Haskell/any other language/
14:29:46 <alxbl> Madness?
14:29:46 <mreh> synergy is a term from pharmacology ain't it?
14:29:47 <yitz> zellio: indeed. haskell is lazy, it defers everything until later.
14:29:49 <Cale> ricree: you can define an instance of Storable for the struct (tools like C2hs can help with this), and then malloc will do it.
14:29:50 <thoughtpolice> yitz: i say this as someone who tried agda a few times and failed
14:29:58 <dolio> Dude, static typing is just a special case of macros, so Lisp did it first.
14:30:00 <thoughtpolice> but now maybe that copumpkin has cheered me to do it a little more, i'll be more serious :P
14:30:02 <zellio> yitz: lisp is just as lazy
14:30:10 <Cale> dolio: lol
14:30:11 <thoughtpolice> dolio: that can be done as a macro. not interesting. duh
14:30:14 <kmc> ricree, if you want GHC's runtime system to handle garbage collection for you, look at ForeignPtr
14:30:45 <ricree> Thank you cale and kmc.  I'll look at those
14:30:49 <thoughtpolice> chrisdone: i think ur is a lot easier if you have no background in lots of theory, personally. agda is still very intimidating to me (also, i'm not a super genius mathematician, i'm a 21 year old college drop out :P)
14:31:15 <thoughtpolice> chrisdone: one thing worth noting is that ur does not even really have dependent types. :P you can't make types depend on a runtime value. ur just has really good type level computation facilities
14:31:21 <yitz> zellio: then why did it do everything first?
14:31:44 <zellio> yark yark yark
14:31:50 <yitz> hehe
14:32:13 <chrisdone> thoughtpolice: i thought the opposite, agda looked more accessible. maybe because Ur has three pages of type theory notation that goes over my head
14:32:28 <chrisdone> well that's good to know. i'll try it on the weekend
14:32:28 <zellio> But seriously. outside of the dubious benefit of immutable types, why not learn a lisp
14:32:38 <thoughtpolice> chrisdone: well, actually writing proofs in agda seems very hard to me at least.
14:32:39 <kmc> "immutable types"?
14:32:41 <alxbl> learn you a lisp today
14:32:45 <alxbl> sounds less catchy
14:32:55 <mcsquiggedy> feels like it should end with "for great justice"
14:33:00 <thoughtpolice> chrisdone: try adam's tutorial! the type level computation chapter is really mind opening, even if you don't want to use ur/web for actual web programming
14:33:00 <alxbl> probably
14:33:10 <mreh> for great eval
14:33:29 <zellio> kmc: s/immutable/static/
14:33:44 <kmc> zellio, the dubious benefit of having some reason to think your program is correct before you run it?
14:33:51 <geheimdienst> cale: yes, i think that's the point. there's a widespread belief that monads are terribly scary and terribly important to haskell: tons of tutorials, "you're a seasoned haskell programmer when you've written your own tutorial", "oh it all comes from an obscure math branch called CT", the haskell logo being a lambda in front of >>=, etc. this belief imho is not proportional to reality
14:33:52 <ddarius> chrisdone: The fact that Agda is lacking three pages of type theory notation does not make it simpler.  Quite the opposite.
14:33:52 <thoughtpolice> in particular, the ability to have closed type classes through functors and the way type inference works for type class instances is rather slick
14:33:56 <thoughtpolice> imo
14:33:56 <chrisdone> thoughtpolice: if i learn ur it'll be only for the mind opening, i don't want to write HTML like some SGML slave labourer mixing with SQL and crap. but the type level stuff is interesting
14:34:10 <kmc> zellio, it's quite common that Haskell code works correctly once it passes the type checker
14:34:13 <kmc> can you say the same for Lisp?
14:34:24 <kmc> anyway, we're not here to convince you to learn Haskell
14:34:35 <Eelis> we're not? :D
14:34:45 <kmc> i try not to be, because it's too easy to get trolled otherwise
14:34:49 <ddarius> Category theory is not an obscure branch of mathematics.
14:34:50 <Eelis> true, true
14:34:50 <mauke> zellio: outside of the dubious benefit of ladders, why not climb walls with your bare hands?
14:34:51 <geheimdienst> in soviet russia, haskell convinces you ... uh wait
14:34:59 <thoughtpolice> chrisdone: i'm somewhat inclined to agree. like I said i'm actually writing it right now (for $, seriously,) and that can be very offputting IMO. and i'm not even really a web developer!
14:35:24 <monochrom> you shouldn't learn haskell. you should wait for it to learn you
14:35:33 <thoughtpolice> chrisdone: you can abstract over it with a module at least, but no, it's not very satisfactory. code splicing things with 'sed' or autoconf replacement is equally as terrible
14:35:33 <zellio> kmc: that's assuming you have your logic right. You shouldn't be trust your compiler to be what is validating the correctness of your code. You should have an understanding of what is going on that allows you to see the correcness
14:35:42 * ddarius is here to convince people to learn another language.
14:35:44 <kmc> zellio, both is surely better than one alone
14:35:59 <thoughtpolice> chrisdone: also, while most people also don't want to write raw SQL, you can write a type safe ORM that abstracts over it. i've also see some people want other data stores, maybe that could happen in the future
14:36:00 <chrisdone> thoughtpolice: code splicing?
14:36:06 <Philonous> monochrom: In soviet haskell, monads bind you?
14:36:06 <Cale> ddarius: weeellll, it's also not something which even every undergrad mathematics student learns
14:36:11 <monochrom> yeah!
14:36:17 <kmc> zellio, what a static type system checks is consistency.  of course you still need to know what you're doing, but the compiler will make sure you didn't change your mind halfway through
14:36:20 <thoughtpolice> chrisdone: oh, i just mean like literally splicing XHTML etc into a code file then compiling that, as opposed to putting your XHTML directly in the file
14:36:21 <mauke> zellio: I don't use types for correctness, I use them to program
14:36:25 <dolio> ddarius: Every branch of mathematics that isn't calculus or discrete math is obviously obscure.
14:36:28 <Cale> ddarius: (at least, as a topic in its own right)
14:36:35 <ddarius> Cale: Undergraduate education, in general, is a joke.
14:36:43 <kmc> zellio, how much Haskell do you know?
14:36:44 <dolio> Or high-school algebra and geometry, I guess.
14:36:46 <thoughtpolice> chrisdone: but yeah, putting the XML directly inside is kind of off putting. like I said a module is the only real way to abstract it
14:36:57 <Cale> ddarius: I don't know. My undergrad in mathematics had a good deal of decent material in it.
14:37:03 <Cale> ddarius: (from Waterloo)
14:37:04 <zellio> kmc: not much, my experience is more in Common Lisp and SML
14:37:08 <kmc> zellio, ok
14:37:12 <thoughtpolice> chrisdone: part of this is actually because in ur, the standard HTML tags you use are actually identifiers in the standard library. the whole < > for XML literals is actually all the syntax sugar there is
14:37:24 <kmc> well, if you want to learn Haskell, you have to give a little benefit of the doubt that it's worthwhile
14:37:25 <Cale> ddarius: But it didn't have category theory specifically (though I learned a little from algebraic topology and other courses)
14:37:27 <chrisdone> thoughtpolice: sure. i might try to implement a library i'm working on in haskell presently that abstracts from the presentation (web/gtk/etc)
14:37:30 <dolio> I don't think Waterloo is representative of "in general."
14:37:37 <kmc> and if you don't want to learn Haskell then we're not going to spend all day convincing you otherwise
14:37:49 <thoughtpolice> chrisdone: so when you say <form> or what have you, that 'form' actually represents a 'form' function in the basis library. that's how it does type checking of XML fragments
14:37:51 <Cale> dolio: I guess, okay.
14:37:53 <thoughtpolice> and makes sure things are nested correctly
14:37:55 <dolio> :)
14:37:58 <Jafet> kmc: sure we are; watch us
14:38:04 <zellio> I'm not here to be convinced or not, I'm just trying to figure out if you have a good reason out side of typesystem
14:38:24 <Cale> But if even Waterloo doesn't have an undergrad course on CT, it must be a *little* obscure.
14:38:40 <dolio> Oh, okay.
14:38:41 <chrisdone> thoughtpolice: what application are you writing?
14:38:46 <thoughtpolice> chrisdone: the metaprogramming makes a LOT more sense after some simple examples, really. if you have any questions don't hesitate to ping me :P i like the core language a lot
14:38:47 <Cale> and I think that's okay, it's becoming less obscure, but it's not treated as absolutely central yet.
14:38:54 <thoughtpolice> chrisdone: i can't give details :P
14:39:08 <Cale> It's more blended into the notation of everything else, and not treated as its own thing
14:39:14 <ddarius> Cale: I suspect some of the topics you were taught in undergraduate mathematics are not treated as absolutely central.
14:39:48 <Cale> ddarius: "Absolutely central" is maybe the wrong term.
14:41:09 <chrisdone> thoughtpolice: working for the enemy? ;-)
14:41:31 <thoughtpolice> chrisdone: but yes it's a lot of fun. there are definite downsides though too. A) using modules to abstract your different HTML layouts/what have you isn't optimal. B) the compiler has absolutely awful error messages, B) there isn't much infrastructure support, although i'm trying to fix this
14:41:38 <thoughtpolice> chrisdone: hahaha
14:41:54 <Jafet> Enemy lines (of code)
14:41:57 <Cale> The content of my undergrad at least was pretty much all introductions to general areas of modern mathematics.
14:42:33 <ddarius> The -actually- obscure branches of math are really fucking out there.
14:42:48 <Cale> ddarius: I do agree with you to a fair extent, yes.
14:42:57 <thoughtpolice> chrisdone: also, you're probably really going to want a proxy/reverse proxy sitting in front of the ur/web app, since you're probably going to need things like static file serving, which the main language doesn't do, etc
14:43:17 <thoughtpolice> (so you can serve your CSS/images easily for example)
14:43:35 <Cale> ddarius: A lot of CT is really fucking out there too though.
14:43:37 <chrisdone> alright, i'll let you know when i look into it
14:43:56 <dainanaki> O
14:44:20 <Cale> ddarius: but there's a core bit of it which is not so obscure which I think every mathematician should know, and it's a little sad that it's still obscure in the sense of not every mathematician being familiar with it
14:44:24 <dainanaki> I've noticed that there is an old-locale package, but no new locale package that I can see. Does anyone know where that would be?
14:45:11 <Saizan> there isn't one
14:45:13 <Cale> Like, there are a fair number who would struggle to recall the definition of a natural transformation, which is kinda sad.
14:45:13 <thoughtpolice> chrisdone: cool! like i said feel free to bug me. you can also come hang out in #ur with like 5 other people if you want. :P me/gian/doublec are active there sometimes
14:45:34 <Cale> (depending on field of course)
14:45:34 <thoughtpolice> even if it's just mind bending metaprogramming, no web stuff. the type system is my favorite part :3
14:46:01 <chrisdone> i can tell you're excited by it :p
14:46:17 <geheimdienst> dainanaki: i think there is no replacement. the name "old-locale" was an accident i think. it should really be "locale". sorry for the confusion
14:46:43 <dainanaki> Heh, that's what I figured, seeing as how it's used by the new time libs.
14:47:26 <ddarius> Cale: A lot of set theory is really fucking out there.
14:47:34 <Cale> ddarius: Totally agree
14:47:54 <Cale> ddarius: and a lot of undergrad programs don't have a course in that either
14:48:02 <dainanaki> Sadly
14:48:26 <acowley> edwardk: ad is not happy computing gradients of functions with 4k parameters or more
14:48:46 <Cale> acowley: haha
14:49:03 <acowley> Cale: it works fine for 1000 parameters
14:49:05 <Cale> acowley: that's pretty cool, what are you working on?
14:49:16 <acowley> Cale: and it seems like a memory issue
14:49:18 <edwardk> acowley: how so?
14:49:37 <edwardk> acowley: sounds like you're building up one hell of a tape
14:49:52 <acowley> edwardk: I'm using grad', and the values for my first two gradients come out quickly, then nothing
14:50:02 <edwardk> keep in mind reverse mode ad turns your time complexity into your space complexity
14:50:10 <acowley> edwardk: with the smaller example, the first two come out quickly, then the third takes some time
14:50:27 <ddarius> edwardk: Wouldn't that mean it keeps your time complexity the same?
14:50:29 <acowley> edwardk: and it just so happens the value of the function converges at that point
14:50:49 <edwardk> ddarius: yes, but if he's blowing up because of space...
14:50:56 <acowley> Cale: I'm trying out a bunch of computer vision things I've been meaning to follow up on
14:51:04 <acowley> edwardk: yes I get stack overflows with really big problems
14:51:20 <acowley> edwardk: increasing stack size avoids the exception, but it's not productive
14:51:36 <edwardk> interesting. i'll admit the 4k variable case you're running is probably the biggest problems it has been fed
14:51:43 <acowley> so in this case I'm working with graph induced by image data
14:51:51 <edwardk> *nods*
14:51:57 <acowley> edwardk: well, good news, it works for 1024 variables! :)
14:52:07 <edwardk> heh
14:52:09 <acowley> the slow down is bothering me, though
14:52:15 <copumpkin> acowley: where does it break?
14:52:21 <copumpkin> somewhere between 1000 and 4000? :)
14:52:30 <acowley> copumpkin: I'm a slave to powers of two
14:52:34 <edwardk> curious what part of it is using the stack so heavily
14:52:41 <mm_freak> 'concat [[a, b], rest]' vs. '[a, b] ++ rest', which one will be faster in general?
14:52:44 <ddarius> 2048 is between 1000 and 4000.
14:52:44 <acowley> copumpkin: the wasteland in between probably doesn't exist
14:52:46 <mm_freak> @src concat
14:52:46 <lambdabot> concat = foldr (++) []
14:52:50 <mm_freak> ok, answered
14:52:59 <acowley> ddarius: that's not a power of 2 I care for
14:53:08 <acowley> I'm very discerning
14:53:09 <ddarius> acowley: You have a problem with 11?
14:53:22 <acowley> edwardk: is there anything I can do to help?
14:53:28 <edwardk> guessing he cares about powers of 4
14:53:32 <ddarius> Quick!  What's 2^14?
14:53:38 <edwardk> image quadrature?
14:53:44 <acowley> Yeah, I'm doing powers of two on each image dimension
14:54:43 <monochrom> 16384
14:54:46 <edwardk> acowley: well, you could throw me the huge example that it craps out on if you can send me code. otherwise you can go and drop a bunch of debug statements into  Numeric.AD.Internal.Reverse and see what craps out
14:54:50 * ddarius considers (re?)making ad into a generating extension.
14:55:20 <edwardk> ddarius: thought about it. but that is a lot of compiler to write
14:55:42 <edwardk> the other thought i had was to go through and write it as a th quasiquoter
14:56:42 <edwardk> acowley: most likely its something silly that isn't productively producing a list down in the bowels of it and is sitting there spinning up stack frames just to walk back down them
14:56:47 <acowley> edwardk: Here's something kind of strange: I've been tracing the first component of the pair returned by grad' since the vector is so big. For a big problem I get two traced values, then no response. However, if I trace the vector as well, I only see the original value and vector
14:57:13 <chrisdone> luite: thoughtpolice: here we go. it took me all night because i was preoccupied, but a trivial example of the start of my gui lib: http://hpaste.org/49602 i haven't implemented controllers yet, this is just the view. triggering the controllers would happen when you, e.g. click a button, focus an input, change a tab, etc. the Update button simulates that
14:57:27 <acowley> edwardk: and tracing the values with the smaller example, the first two really do pop out quickly while the third takes time
14:57:28 <ddarius> edwardk: Also, MDX + RDL = sadness
14:57:37 <edwardk> well, keep in mind the trace combinator may be costing you observable sharing
14:57:50 <acowley> edwardk: ah!
14:57:57 <edwardk> so you could be worsening your asymptotics considerably
14:57:59 <acowley> edwardk: so I should put the blindfold back on
14:58:04 <edwardk> yeah
14:58:35 <edwardk> you might have better luck tracing down in the backProp method in Numeric.AD.Internal.Reverse or the driver that calls it
14:58:51 <edwardk> coz that is probably where i destroy the stack
14:59:32 <edwardk> http://hackage.haskell.org/packages/archive/ad/1.1.0/doc/html/src/Numeric-AD-Internal-Reverse.html#partials is the real workhorse here
14:59:54 <acowley> edwardk: on the big data, other than the stack overflow, it's not obviously leaking memory
15:00:18 <edwardk> hrmm
15:00:34 <edwardk> can you drop some trace statements into partials and see if its making it all the way through?
15:00:35 <acowley> and it really is conspicuous how quickly it returns the first value
15:00:37 <acowley> yeah
15:00:42 <chrisdone> luite: thoughtpolice: idea being, you might have, e.g. modelUpdated User $ \user -> text (userName user). which is a wrapper that only triggers when the User model is updated, and then elsewhere a controller which updates the user name. when that's triggered, automatically this part of the view is re-drawn. kinda spreadsheety. anyhoo, it's not that interesting without controllers atm
15:00:48 <edwardk> the first value isn't surprising at all actually
15:00:55 <edwardk> its just the naive forward evaluation
15:01:09 <edwardk> the 'f a' part of grad' requires calculating partials
15:01:23 <acowley> got it
15:01:29 <edwardk> i need to compute the first part in order to get all the partials i need to have a tape to backpropagate
15:01:46 <edwardk> rather i should say, all of the local sensitivities
15:03:18 <edwardk> annotating partials will tell us if its the graph reification from gill, the topSort from king and launchbury or my backPropagate method that blows us up. =)
15:04:07 <ddarius> I blame Launcbury!
15:04:12 <ddarius> +h
15:04:44 <edwardk> =)
15:05:07 <edwardk> ultimately its my fault for stringing these things together, i just need to know what component of it is failing
15:05:27 <edwardk> see what happens when i lean on other people's code?
15:05:28 <edwardk> =)
15:05:53 <edwardk> time to write data-graph-nih and data-reify-nih ;)
15:17:38 <acowley> edwardk: one problem found and addressed: sbounds is not strict enough and caused the initial stack blowup
15:17:49 <acowley> edwardk: some seqs or bangs fixes it
15:19:37 <acowley> also, I'm not sure about naming packages foo-nih. That sounds like you're passing the buck in case you doesn't work when instead you're encoding the motivation in the package name.
15:20:02 <acowley> oh and reifyGraph takes a long time for big data
15:20:30 <acowley> reifyGraph is slow, but finishes. I seem to be sticking at topSort
15:22:29 <acowley> and if I run with +RTS -s and kill the process when it seems to have lost the will to be helpful, the RTS reports that virtually all of its time was spent GC'ing
15:24:29 <acowley> so I'm going to point at topSort for the moment and chalk this up as a loss, though I'm pretty certain it is a practical approach with a bit less magic in between the pretty code and the CPU
15:25:04 <ddarius> edwardk: Told ya
15:25:14 <acowley> yeah, you called it
15:26:43 <roconnor> cdsmith thinks thatit suddenly seems like the community consensus is that we should choose a package for lenses based on comonad identities.
15:26:55 <roconnor> I'm so happy!
15:28:03 <edwardk> acowley: what did you bang to fix sbounds?
15:28:15 <acowley> edwardk: I actually seq'd lo and hi
15:28:23 <edwardk> k
15:29:28 <dainanaki> how can I profile a particular function in depth to see what internal function calls are causing issues?
15:30:23 <acowley> dainanaki: issues?
15:30:28 <edwardk> acowley: i welcome a replacement topSort, but i'll see if i can port the one we use in the typechecker here from scala
15:30:35 <acowley> I don't know what topSort is
15:30:43 <edwardk> topological sort
15:31:18 <edwardk> the one i use is in Data.Graph
15:31:19 <acowley> I actually don't really have much of an idea how your rad mode works
15:31:28 <dainanaki> acowley, I have an enumerator that I'm trying to speed up, and I'm not sure what aspect of this particular enumerator function is causing it to be slow. It doesn't hog memory, but it runs slowly.
15:31:34 <edwardk> i've been meaning to submit a bunch of Data.Graph patches anyways
15:31:42 <acowley> edwardk: it's doing a topSort on an expression graph?
15:31:48 <edwardk> yeah
15:32:04 <edwardk> hence why i said i give up a log factor over a single-threaded traditional tape
15:32:17 <acowley> edwardk: one thing about my problem that is bugging me is that my graph is exceedlingly sparse
15:32:27 <edwardk> the topsort is more expensive than just assigning new ids in sequence
15:32:44 <acowley> edwardk: it would be nice if I could help out some of the machinery
15:32:51 <acowley> by letting it know something about what I'm doing
15:32:57 <edwardk> then the topSort shouldn't be problematic, but i'm guessing its just  a strictness annotation somewhere in Data.Graph
15:33:17 <acowley> dainanaki: I would hope that regular profiling would help in that case. You can use SCC pragmas to annotate pieces of expressions
15:33:21 <edwardk> and sparsity is good, the system here is designed to be fast given a sparse graph
15:33:26 <hatds> @pl \x y -> ((x,y):)
15:33:26 <lambdabot> ((:) .) . (,)
15:33:44 <ash__> did lambdabot just wink at me?...
15:33:44 <lambdabot> ash__: You have 1 new message. '/msg lambdabot @messages' to read it.
15:34:16 <edwardk> acowley: can you distill an example for me so i'll know if i've solved it?
15:36:26 <acowley> edwardk: I'll work on that
15:37:06 <edwardk> once i get that i'll make sure to get you a fixed topSort. if nothing else it'll get done on the trip to hac phi ;)
15:37:21 <edwardk> it behooves me to fix your problem before you can confront me in person ;)
15:42:46 <edenpuls1> exit
15:42:47 <edenpuls1> exit
15:42:53 <acowley> edwardk: an annoyance is that I'm using some of my code that's still experimental
15:43:07 <edwardk> *nods*
15:43:37 <acowley> edwardk: your life would be simpler if I extracted some problematic data
15:43:45 <acowley> I'm really just using the library for data loading purposes
15:43:50 <acowley> I'll work it out
15:44:03 <edwardk> k
15:45:04 <acowley> I'm using OpenCV and there was a GHC issue that simonmar fixed, but isn't in a released compiler yet. The work around requires either a Mac, the use of OpenCV 2.1, or a recompile of OpenCV 2.2 or 2.3
15:45:04 <int80_h> Could someone help me re-write my yesod function that now breaks since the changes in Yesod.Form.Fields>?
15:45:37 <edwardk> i have a mac
15:45:51 <int80_h> it's a three line function, I'm having difficulty making sense of the new interface to selectField, and multiSelectField has been removed.
15:45:58 <edwardk> i don't have openCV on this one though
15:46:05 <acowley> oh, well then you can install my OpenCV bindings
15:46:28 <acowley> the problem was stack alignment on FFI calls, and the Mac ABI has apparently demanded 16 byte alignment forever
15:46:46 <acowley> and GCC now assumes it so it can use more XMM
15:46:59 <acowley> so things worked on OS X, but segfaulted elsewhere
15:47:13 <edwardk> but ghc goes off and  does its own thing with 8 byte aligned frames?
15:47:40 <acowley> yes
15:47:54 <acowley> I was getting segfaults deep in OpenCV, and GDB led me precisely nowhere
15:48:12 <acowley> I was told all hope was lost, then simonmar swung in on his web shooters and figured it out
15:48:15 <acowley> it was amazing
15:48:23 <kmc> nice
15:48:39 <acowley> I'm 101% sure I never would have figured it out
15:48:54 <yitz> int80_h: did you try #yesod?
15:49:47 <edwardk> he does that sort of thing =)
15:50:22 <geheimdienst> @remember acowley I'm 101% sure I never would have figured it out. I was told all hope was lost, then simonmar swung in on his web shooters and figured it out
15:50:22 <lambdabot> Done.
15:50:51 <int80_h> yitz: yeah, they are all a bunch of idling idlers
15:50:59 * geheimdienst wonders what SPJ's superpower is
15:51:08 <kmc> comic sans
15:52:22 <subleq> i have sort xs = merge (sort a) (sort b) where (a,b) = split xs
15:52:31 <subleq> it seems like there should be a better way to write that
15:52:32 <ash__> goo.gl/JU3aC has the full docs on the OS X ABI if your interested
15:52:58 <ash__> err http://goo.gl/JU3aC (its shortened because the docs urls are long and nasty)
15:55:31 <parcs> :t split
15:55:32 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
15:56:10 <subleq> parcs: split :: [a] -> ([a],[a])
15:56:25 <parcs> :t uncurry (join ((fmap ?merge .) . ap)) . split
15:56:25 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a1
15:56:25 <lambdabot>     Probable cause: `ap' is applied to too many arguments
15:56:25 <lambdabot>     In the second argument of `(.)', namely `ap'
15:56:37 <kmc> o_O
15:57:31 <parcs> :t uncurry (join (((fmap ?merge .) .) . ap)) . split
15:57:31 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> f a1
15:57:31 <lambdabot>     Probable cause: `ap' is applied to too many arguments
15:57:31 <lambdabot>     In the second argument of `(.)', namely `ap'
15:57:45 <parcs> subleq: you're on your own :P
15:58:47 <kmc> subleq, it looks pretty good to me
15:59:00 <subleq> hm, ok
15:59:15 <subleq> i just looked at merge (sort a) (sort b) and thought there was a combinator for that
15:59:15 <kmc> there are various small changes you could make
15:59:35 <kmc> :t ?merge `on` sort
15:59:36 <lambdabot> forall c a. (?merge::[a] -> [a] -> c, Ord a) => [a] -> [a] -> c
15:59:41 <kmc> ah, that's the one
16:00:23 <kmc> sort = uncurry (merge `on` sort) . split
16:00:37 <parcs> that's much simpler..
16:00:44 <parcs> @pl \t f x y -> f x `t` f y
16:00:44 <lambdabot> join . ((flip . ((.) .)) .) . (.)
16:01:02 <kmc> subleq, i don't think it's clearer, rough
16:01:04 <kmc> though*
16:01:10 <parcs> @pl \f x y -> f x `t` f y
16:01:10 <lambdabot> flip =<< (((.) . t) .)
16:01:24 <parcs> @pl \x y -> f x `t` f y
16:01:24 <lambdabot> (. f) . t . f
16:01:26 <kmc> i do enjoy pointsfree recursion though
16:01:57 <kmc> also i guess you needed a base case for 'sort' and that makes it not points-free anymore?
16:01:59 <subleq> kmc: aha
16:02:12 <aavogt> if you re-write split to take a continuation you can avoid the uncurry
16:02:14 <subleq> yeah, needs the base case anyways
16:02:24 <kmc> i like that aavogt
16:02:46 <kmc> sort = splitAnd (merge `on` sort)
16:02:52 <kmc> you can almost read that...
16:03:22 <subleq> splitAnd :: [a] -> ([a] -> [a] -> [a]) -> [a]?
16:04:10 <parcs> [a] -> ([a] -> [a] -> b) -> b
16:04:22 <kmc> right
16:04:24 <subleq> ah, yeah
16:04:29 <kmc> either will work here, but the latter is "more correct"
16:04:30 <aavogt> but for kmc's version the function is the first argument
16:04:36 <kmc> right, that too
16:04:39 <subleq> that's uglier to write than split
16:05:04 <kmc> yeah, it is kind of an arbitrary and unexpected use of CPS
16:05:16 <aavogt> subleq: instead of     (a,b), you write   \k -> k a b
16:05:31 <kmc> it depends on to what degree you're golfing vs. writing clear code someone else might read
16:07:02 <Saizan> andThen = \f g -> uncurry g . f;  sort = split `andThen` (merge `on` sort)
16:07:18 <kmc> @pl \f g -> uncurry g . f
16:07:18 <lambdabot> flip ((.) . uncurry)
16:07:57 <subleq> Saizan: that's almost english!
16:08:18 <kmc> yeah i wrote three versions of a minimal s-expr parser: one returning tuples, one with continuations, and one defining and using an Applicative parser combinator library
16:08:40 <kmc> continuations were the shortest, but I'm still not sure which I like the best
16:08:41 <Saizan> not so impressive since andThen is completely ad-hoc
16:08:57 <aavogt> how about a:      class AndThen tuple fun | tuple -> fun where andThen :: tuple -> (fun -> b) -> b
16:09:06 <kmc> gaaaah
16:09:18 <aavogt> that's probably not exactly right
16:09:31 <Saizan> no
16:09:42 <kmc> that's Not Okay ™
16:09:52 <Saizan> andThen :: tuple -> (fun b) -> b -- could work
16:11:12 <subleq> well that was fun
16:11:14 <subleq> gotta go
16:12:52 <Saizan> ?type let andThen :: tuple -> (fun b) -> b; andThen = undefined in [andThen, undefined :: (Int,Int) -> (Int -> Int -> Int) -> Int]
16:12:53 <lambdabot>     Couldn't match expected type `Int -> Int'
16:12:53 <lambdabot>            against inferred type `Int'
16:12:53 <lambdabot>     In the expression:
16:13:04 <Saizan> seems not
16:13:21 <Saizan> but you can if you make b an argument of the typeclass
16:23:12 <aavogt> Saizan: that works: http://hpaste.org/49606
16:24:00 <sral> how is Array implemented? I can not figure out how Array.of_list is implemented in pure haskell, or maybe it's done by GHC?
16:24:41 <kmc> yes, Array can't be implemented in pure Haskell with the desired performance guarantees
16:25:12 <aavogt> @hoogle of_list
16:25:12 <lambdabot> No results found
16:25:40 <aavogt> that of_list is what another language calls  fromList?
16:26:01 <aavogt> or maybe listArray
16:26:11 <kmc> sral, there's no way to write a Haskell datatype which is guaranteed to be implemented by a big block of contiguous memory
16:26:21 <sral> aavogt: or just made it up. i switched to ocaml recently
16:26:44 <kmc> (though you can maybe implement Array using the FFI stuff in Haskell 2010, sort of how ByteString is implemented)
16:26:51 <kmc> the Array API is in standard Haskell, though
16:27:00 <acowley> edwardk: I extractded an AD stress test and some data
16:27:37 <aavogt> kmc: with ghc won't this work:   data Array5 a = Array5 !a !a !a !a !a, possibly with {-# UNPACK #-}
16:28:04 <edwardk> acowley: sweet! ekmett@gmail.com
16:28:08 <kmc> {-# UNPACK #-} isn't in Haskell
16:28:21 <kmc> and i don't think there's any guarantee about how strict data is implemented
16:28:26 <kmc> my point was not about what works or doesn't work in GHC
16:28:32 <Saizan> {-# UNPACK #-} doesn't do anything on type variables
16:28:36 <c_wraith> haskell provides no guarantee that constructor fields are contiguous in memory, either
16:28:39 <sral> i found physical equality is usually very important for performance tuning in ocaml. do you think we need it in haskell?
16:28:49 <kmc> physical equality?
16:28:57 <c_wraith> same pointer
16:28:59 <kmc> you mean like pointer equality?
16:29:03 <sral> yeah.
16:29:03 <Axman6> as in unsafePointerEquality?
16:29:05 <kmc> sral, it's useful in some circumstances
16:29:09 <edwardk> sral: rarely. you can use stablenames when you need to check for pointer equality, but it is in io
16:29:12 <kmc> you can do it in GHC, with appropriate caveats
16:29:18 <acowley> edwardk: sent!
16:29:18 <benmachine> isn't that called reallyUnsafePointerEquality?
16:29:19 <kmc> StableName guarantees are weak
16:29:32 <Axman6> > let x = [1..] in x `reallyUnsafePointerEquality` x
16:29:33 <lambdabot>   Not in scope: `reallyUnsafePointerEquality'
16:29:35 <kmc> reallyUnsafePointerEq#
16:29:44 <Axman6> > let x = [1..] in x `reallyUnsafePointerEq#` x
16:29:44 <edwardk> well, stablename guarantees are better than reallyUnsafePointerEq# guarantees
16:29:44 <lambdabot>   Not in scope: `reallyUnsafePointerEq#'
16:29:46 * hackagebot x-dsp 0.2 - A embedded DSL for manipulating DSP languages in Haskell  http://hackage.haskell.org/package/x-dsp-0.2 (JohnLato)
16:29:50 <aavogt> > cycle "really" ++ "UnsafePointerEquality"
16:29:52 <lambdabot>   "reallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyreallyre...
16:29:54 <Axman6> @hoogle unsafePointer
16:29:54 <lambdabot> No results found
16:30:04 <sral> like giantTree1 == giantTree2 would kill your app
16:30:18 <kmc> sral, well, why are you comparing giant trees in the first place
16:30:28 <kmc> if the pointers aren't equal, you still have to traverse them
16:30:39 <sral> kmc: sometimes it is ok to compare only once.
16:31:07 <edwardk> sral: typically for that we move to some kind of hashcons table anyways, and replace the literal pointers with some index into a table
16:31:17 <sral> then merge them to the same object. then physical euqality applies in the future.
16:31:38 <edwardk> sral: but in general you can't use reference equality to imply (==)
16:31:39 <Axman6> i'd argue it's much better to have a Map or something that contains your trees
16:31:55 <edwardk> sral: this is an unfortunate consequence of the fact that NaN /= NaN
16:32:03 <kmc> sral, the "merge it into the same object" part is the trickier half of that, in Haskell
16:32:08 <edwardk> sral: so be careful when using it.
16:32:13 <kmc> that's where the explicit approach Axman6 / edwardk are describing will be useful
16:32:41 <kmc> sral, you can do mutable reference cells in Haskell, when you need them
16:32:44 <kmc> so it's not impossible
16:32:50 <Axman6> i don't think my nick and edwardk's have ever been mentioned in the same sentense before, let alone with the word useful :P
16:33:13 <mm_freak> very large pattern lists seem to be hard bread for GHC
16:33:54 <sral> edwardk: how to define the index?
16:33:57 * Axman6 goes back to writing Ada
16:35:32 <argiopeweb> I'd like to write a small server with two main goals: Listening for clients to connect and adding sockets to a list, and listening to a network feed for periodic messages and re-sending those messages to the clients via their socket handles (in the list). Is there a better way to go about this than 2 threads and some manner of shared memory?
16:35:40 <edwardk> sral: i'd usually just assign integer ids in sequence and stuff them into an IntMap, then check to see if i've seen a node i'm inserting by hashing the node type and the ids of the children into lookup table
16:36:07 <yitz> @quote unsafe
16:36:07 <lambdabot> shepheb says: unsafePerformIO :: IO a -> Madness
16:36:14 <edwardk> sral: the problems with that approach of course are that the tables don't get garbage collected. for that i turn to things likee stablenames
16:36:16 <kmc> argiopeweb, no, that sounds fine -- perhaps a Chan as your inter-thread communication
16:36:24 <kmc> threads in GHC are cheap, spawn as many of them as you need
16:36:26 <sral> edwardk: i often found dealing such artificial IDs is tricky.
16:36:33 <edwardk> data-reify gives a nice combinator for extracting a graph of how some tree structure connects
16:36:36 <edwardk> sral: i agree
16:36:47 <kmc> and threads are also the basic way of doing async I/O... the call to epoll() / kqueue() / whatever is done for you behind the scenes
16:37:00 <argiopeweb> kmc: Ah, thanks. Chan was the "it's in the back of my mind but I can't think of it" shared memory I was wanting to look into.
16:37:09 <edwardk> sral: this is why i tend to use observable sharing via stablenames
16:37:14 <kmc> it's not really like shared memory; it's a message channel
16:37:26 <kmc> where "message" is any Haskell type, including functions and IO actions
16:37:26 <sral> what is stablename?
16:37:33 <kmc> so you can do some very powerful stuff in few lines of code
16:37:43 <acowley> I actually think Haskell makes dealing with out-of-band Ints impressively easy compared to most languages
16:37:48 <argiopeweb> Interesting.
16:38:02 <edwardk> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Mem-StableName.html which was defined in a paper, one sec
16:38:04 <argiopeweb> I'll go check it out.
16:38:07 * kmc recalls fondly using Mu Chan
16:38:17 <c_wraith> that sounds exciting
16:38:24 <kmc> π calculus!
16:38:28 <kmc> i brought pie too
16:38:31 <edwardk> http://research.microsoft.com/apps/pubs/default.aspx?id=67497
16:38:34 <kmc> (to the talk)
16:38:36 <c_wraith> what did you do with the extra e?
16:38:54 <edwardk> that is where all the dirty imperative seeming pointer comparison-like stuff lies
16:39:00 <copumpkin> Mu Chan? o.O
16:39:17 <edwardk> copumpkin: works well
16:39:29 <yitz> c_wraith: e ** (i * pi) == -1
16:39:50 <kmc> copumpkin, yep, Mu Chan is what processes in the π calculus send / receive
16:39:58 <copumpkin> ah :)
16:40:09 <edwardk> copumpkin: http://www.haskell.org/pipermail/haskell-cafe/2010-June/078750.html is a finally tagless version
16:40:12 <Saizan> no turtles, sadly
16:40:20 <acowley> I'm really enjoying the pushback on Ur/Web on the cafe
16:40:22 <edwardk> keegan had a more traditional one somewhere as well
16:40:24 <c_wraith> A fun thing about Mu Chan is:  c2 <- readChan c1 ; writeChan c2 c1
16:40:45 <c_wraith> I don't think it's *useful*
16:40:47 <c_wraith> but it's fun!
16:40:56 <Twey> acowley: Pushback?
16:41:09 <kmc> in π calculus you basically have forkIO, newChan, readChan and writeChan on Mu Chan, forever, and return ()
16:41:19 <ddarius> c1(c2).c2!c1
16:41:28 <felher> hey folks. I know that i can pattern match the first two elements of a list with (a:b:list). But how do i match against the last two elements. I tried (list ++ (a:b:[])) but that didn't work. What am i doing wrong?
16:41:29 <kmc> i could never get used to their syntax though
16:41:40 <kmc> felher, can't.  lists are defined inductively from the left direction
16:41:44 <ddarius> kmc: Look at the (deep) blue calculus.
16:41:46 <kmc> the best you can do is reverse and then pattern-match that
16:42:03 <acowley> Twey: I mean the questioning of what it offers. We very often don't make particularly compelling cases for dependent typing in general, and it's nice to see people who have embraced static typing well beyond most programmers asking for more evidence
16:42:15 * ddarius made the pi calculus as an embedded language in Haskell many years ago.
16:42:22 <felher> kmc: Oh, thats a surprise. But thanks a lot :)
16:42:28 <ddarius> Complete with variadic receive.
16:42:42 <kmc> felher, it's less surprising if you look at how lists are implemented
16:42:49 <kmc> data List a = Nil | Cons a (List a)
16:42:53 <kmc> aside from special syntax, that's all
16:43:03 <kmc> and you can only pattern-match on the constructors of a type, not on arbitrary functions
16:43:12 <kmc> so you can pattern match on (:) (i.e. Cons) but not on (++)
16:43:13 <Twey> Unless you use view-patterns!
16:43:16 <ddarius> unsnoc
16:43:30 <kmc> felher, lists are not a random-access data structure in general
16:43:36 <Twey> acowley: Ah, I see.  *reads*
16:43:43 <monochrom> it is useful. tower 1 tells cell phone to talk to tower 2 "c2 <- readChan c1". then cell phone tells tower 2 that it was talking to tower 1 "writeChan c2 c1". in addition to "tell" it may also be "deallocate"
16:43:45 <felher> kmc: Ah, i see. That does make sense :) ty
16:44:01 <kmc> if you think of them as singly-linked lists, the restrictions make more sense
16:44:03 <Twey> felher: If you're doing it a lot, consider a different data-structure, like Seq from Data.Sequence
16:44:17 <acowley> Twey: it hits home for me as I am making a career of struggling to convince unbelievers about the value of static checking :P
16:44:27 <Twey> acowley: Oh, what do you do?
16:44:34 <acowley> Professional student
16:44:40 <acowley> I'm awesome at it
16:44:48 <c_wraith> monochrom: interesting.  and cool
16:45:01 <Twey> acowley: Haha :þ
16:45:08 * benmachine pokes Twey 
16:45:18 <argiopeweb> kmc: Using dupChan I believe that instead of a single thread holding a list of handles I could instead have a thread for every handle each with a duplicated chan (to which I would push data), which could then all readChan and send the appropriate data, correct?
16:45:18 <acowley> Twey: I research robotics and computer vision and am always looking to improve my tools and convince others they should improve theirs, too
16:46:09 <felher> kmc: yeah, i guess the analogy with singly-linked-list is quite nice.
16:46:19 <ddarius> felher: It's not an analogy.
16:46:32 <acowley> it's like an analogy
16:46:33 <felher> Twey: thanks. i'll look at them.
16:46:39 <kmc> it is basically how every Haskell implementation would implement lists
16:46:51 <kmc> an actual implementation is an analogy for the spec
16:47:04 <felher> ddarius: it isn't? What is it then? Guess my english ist just to bad?
16:48:02 <kmc> felher, it's not explicitly specified how Haskell data types are to be implemented in terms of structs and pointers between them
16:48:12 <kmc> which is what one typically thinks of as a "linked list"
16:48:31 <kmc> but Haskell's lists are defined such that virtually every Haskell implementation will implement them very much like a C linked list
16:48:42 <monochrom> an analogy is a lax natural transformation
16:49:34 <felher> kmc: k, thnx. :)
16:49:42 <ddarius> kmc: You could give a more abstract characterization of "singly-linked list" that's less implementation oriented.  In particular, one approach would be an algebraic semantics which would lead to exactly Haskell lists.
16:51:03 <ddarius> I do agree, though, that technically the Report says absolutely nothing about operational concerns and thus it's perfectly allowable to make an implementation that doesn't do TCO and uses call-by-name and is generally completely useless.
16:51:48 <ski> acowley : "pushback on Ur/Web on the cafe" ? where ?
16:51:51 <ddarius> "I don't actually define an enriched category or functor, but otherwise the level is appropriate for someone whose knowledge of the subject is more-or-less contained in the first three pages of Max Kelly's Basic Concepts of Enriched Category Theory."
16:53:26 <acowley> ski: thread starting here http://www.haskell.org/pipermail/haskell-cafe/2011-July/094096.html
16:53:59 <acowley> it's just people honestly asking "why?"
16:54:23 <acowley> which is the same question you get if you suggest someone use Haskell
16:56:10 <acowley> I think people are a bit wary due to the existing, healthy web framework debate.
16:56:34 <sral> what's the point of PI calculus, what can it do?
16:57:16 <ddarius> sral: It's not a matter of what it can do.
16:58:41 <sral> so it's used to define a concurrency algorithm, and do some reduction and optimization?
17:00:02 <ddarius> sral: It's used to model and -study- concurrency (or at least that was its original purpose.)
17:00:48 <sral> can it help solve race conditions?
17:01:13 <sral> i found it very annoying
17:01:17 <mm_freak> argiopeweb: in haskell you'll usually want to create one or more threads for every client
17:01:40 <mm_freak> if you don't know why, read about concurrent programming and lightweight threads
17:01:43 <monochrom> it can model part of mobile phone protocols, in particular how to tell a phone to roam from one tower to another, do you screw up when you do that (e.g., does the phone talk to two towers simultaneously? does it acquire a handle and forgets to release?). this is in addition to all the concurrency stuff, since the pi calculus includes a process calculus like csp
17:01:51 <mm_freak> another search term is "cheap concurrency"
17:02:21 <dmwit> What good is the lambda calculus? It's way too annoying to actually use for programming.
17:02:36 <benmachine> I wrote a factorial function in the lambda calculus
17:02:44 <benmachine> I think it took something like 500 reduction steps to calculate 3
17:02:45 <monochrom> it can model your brain, which is just as annoying :)
17:02:47 <benmachine> er 3!
17:02:48 <ddarius> It takes -very- little to make the lambda calculus reasonably usable.
17:04:13 <benmachine> (λg.(λx.g(xx))(λx.g(xx)))(λfn.n(λp.(λsz.n(f(λsz.n(λt.t(λxyp.py(sy)))(λp.pzz)(λxy.x))s)z))(λsz.sz))
17:04:27 <benmachine> the hardest bit was decrementing a number
17:04:30 <mm_freak> dmwit: lambda calculus is the functional equivalent of the turing machine…  and i'd say you wouldn't want to write real programs using a turing machine either
17:04:38 <mm_freak> it's the assembly language of functional programming
17:04:40 <ddarius> benmachine: Use a Scott encoding.
17:04:48 <benmachine> ddarius: do I have to
17:05:02 <ddarius> benmachine: No, but it makes pred much easier than a Church encoding.
17:05:03 * dmwit is well aware of the theoretical underpinnings and practical uses of lambda calculus
17:05:16 <mm_freak> dmwit: then why are you asking? ;)
17:05:21 * dmwit feels that his parallel between pi calculus and lambda calculus was perhaps too subtle
17:05:43 <acowley> dmwit has lambdad a few pis in his day
17:06:07 <acowley> at least I think that's what he was doing
17:06:15 <dmwit> haha
17:06:50 * ddarius boils a steak.
17:07:00 <copumpkin> ddarius: sous vide?
17:07:12 <copumpkin> or should I not be pretentious and just say in a vaccuum?
17:08:12 <ddarius> It's not in a vacuum.
17:08:14 <copumpkin> ah
17:08:28 <dainanaki> I just made an hc profile that looks like batman.
17:08:50 * monochrom knows dmwit's parallel. but do you see mine? :)
17:11:03 <sral> Yi-Editor looks dead, but is always being updated
17:11:05 <ddarius> copumpkin: The "vacuum" aspect is not really necessary if you aren't going to be storing the food for any extended period.
17:11:26 <copumpkin> some people swear by cooking steak in a vacuum
17:11:27 <ddarius> sral looks dead, but is always talking.
17:12:03 <centrinia> Do they also use alcohol on the steak?
17:12:09 <ddarius> copumpkin: Well, oxygen leads to rancidity, but, again, this takes time.
17:12:39 * ddarius is incidentally not "boiling" the steak, though he did douse it in boiling water very briefly.
17:12:54 <sral> or should say YI-Editor is alway being updated, but has not presence to the public at all
17:13:18 <centrinia> You could have lowered the boiling point of water below room temperature with the vacuum.
17:13:28 <hatds> does Yi have many users?
17:14:04 <sral> don't think so
17:14:16 <sral> but its activity is high: http://code.google.com/p/yi-editor/
17:14:21 <ddarius> centrinia: I considered that.
17:15:01 <argiopeweb> Is it preferable to explicitly type a Chan generated by newChan (either via function return of the "::" notation on the line), or is it kosher to leave it to type inference?
17:15:11 * ddarius has other uses for vacuums.
17:15:33 <ddarius> argiopeweb: Why would Chans be special?
17:15:50 * benmachine keeps his perfect vacuums in the cupboard next to his frictionless surfaces and point masses
17:15:56 <argiopeweb> ddarius: Because if you try to use one in GHCI without explicity typing it, it bitches at you.
17:16:36 <benmachine> well, ghci doesn't tend to have as much information for inference as a file
17:16:49 <argiopeweb> benmachine: You have frictionless surfaces? In my day we had to make do with ice!
17:17:13 <hatds> I provide a type sig for concurrency primitives if I don't use it in the same block
17:17:25 <argiopeweb> <insert clever segue into Yorkshiremen sketch here>
17:17:47 <hatds> I don't like type inference to suddenly fail when I delete something far away from the creation of the Chan / MVar etc
17:17:50 * centrinia introduces some point masses to benmachine's perfect vacuums.
17:18:00 <benmachine> centrinia: noooo :(
17:18:08 <argiopeweb> hatds: Seems reasonable.
17:18:38 <_habnabit> is there a simpler way of writing: \f a -> a, f a
17:18:55 <benmachine> hatds: you would have to barely use the thing in question at all
17:19:13 <ddarius> centrinia: They would evaporate instantaneously.
17:19:15 <benmachine> in my experience it doesn't come up a lot
17:19:26 <centrinia> :t \f a -> a
17:19:27 <lambdabot> forall t t1. t -> t1 -> t1
17:19:28 <benmachine> ddarius: no they wouldn't, they're point masses
17:19:30 <ski> @let graph :: Arrow ar => ar a b -> ar a (a,b); graph f = arr id &&& f
17:19:31 <lambdabot>  Defined.
17:19:35 <benmachine> they're not composed of atoms
17:19:42 <centrinia> :t flip const
17:19:43 <lambdabot> forall b a. a -> b -> b
17:19:44 <alpounet> @type &&&
17:19:45 <lambdabot> parse error on input `&&&'
17:19:46 <BMeph> Is that "(id ***)" ?
17:19:49 <alpounet> @type (&&&)
17:19:50 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
17:19:57 <ski> > ((^2) `graph`) `map` [0,1,2,3]  -- _habnabit
17:19:58 <ddarius> benmachine: Which would be blackholes which would instantaneously evaporate a la Hawking radiation.
17:19:59 <lambdabot>   [(0,0),(1,1),(2,4),(3,9)]
17:20:10 <BMeph> Ah, yes, (id&&&).
17:20:20 <benmachine> ddarius: my cupboard obeys newtonian physics
17:20:29 <alpounet> @pl \f a -> id &&& f $ a
17:20:29 <lambdabot> (id &&&)
17:20:43 <alpounet> _habnabit, ^^^
17:20:51 <_habnabit> heh, &&&.
17:21:02 <alpounet> it's in Control.Arrow
17:21:02 <ski> @type ((,) =<< (^2)) `map` [0,1,2,3]  -- _habnabit, more or less the same
17:21:03 <lambdabot> forall a. (Num a) => [(a, a)]
17:21:08 <ski> > ((,) =<< (^2)) `map` [0,1,2,3]  -- _habnabit, more or less the same
17:21:09 <lambdabot>   [(0,0),(1,1),(4,2),(9,3)]
17:21:40 <ski> @let cograph :: ArrowChoice ar => ar a b -> ar (Either a b); cograph f = f ||| arr id
17:21:40 <lambdabot>  <local>:5:39:
17:21:40 <lambdabot>      `ar (Either a b)' is not applied to enough type arguments...
17:21:47 <ski> @let cograph :: ArrowChoice ar => ar a b -> ar (Either a b) b; cograph f = f ||| arr id
17:21:48 <lambdabot>  Defined.
17:22:46 <ski> > (show `cograph`) `map` [Left 2,Right "three",Left 4,Left 5,Right "six"]
17:22:47 <lambdabot>   ["2","three","4","5","six"]
17:28:59 <parcs> @djinn (r -> a) -> (a -> r -> b) -> r -> b
17:28:59 <lambdabot> f a b c = b (a c) c
17:31:24 <parcs> :t [(flip . flip) ap, (=<<) . flip]
17:31:24 <lambdabot> forall a (m :: * -> *) b. (Monad m, Functor m) => [m (a -> b) -> m a -> m b]
17:31:51 <aristid_> :t flip
17:31:52 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
17:32:14 <aristid_> :t [(Prelude.flip . Prelude.flip) ap, (=<<) . Prelude.flip]
17:32:14 <lambdabot> forall a b a1. [(a1 -> a -> b) -> (a1 -> a) -> a1 -> b]
17:32:44 <aristid_> @djinn (a1 -> a -> b) -> (a1 -> a) -> a1 -> b
17:32:44 <lambdabot> f a b c = a c (b c)
17:33:38 <aristid_> :t [ap, (=<<)]
17:33:39 <lambdabot> forall a b. [(a -> a -> b) -> (a -> a) -> a -> b]
17:37:45 <parcs> :t [ap . flip, (=<<)]
17:37:46 <lambdabot> forall a b a1. [(a -> a1 -> b) -> (a1 -> a) -> a1 -> b]
17:38:37 <copumpkin> preflex: seen vincenthz
17:38:37 <preflex>  Sorry, I haven't seen vincenthz
17:38:50 <parcs> loses its genericity though
17:46:28 <copumpkin> is there a way, given a handle, to ask how many bytes I can request without blocking?
17:47:08 <shachaf> copumpkin: Without actually reading them from the handle?
17:47:16 <copumpkin> yeah, I don't want it to block
17:47:29 <mauke> that's orthogonal
17:47:31 <copumpkin> I just want to know how many I can omnom without it blocking
17:47:34 <mauke> you can read without blocking
17:47:45 <shachaf> copumpkin: Do you want to subsequently omnom that many?
17:47:58 <copumpkin> shachaf: possibly, but I'm mostly trying to debug someone else's library
17:48:01 <copumpkin> that blocks infinitely on a read
17:48:08 <copumpkin> and I'm not sure what it's trying to read and if that's correct
17:48:17 <shachaf> Oh. I don't think you can do that in general.
17:50:04 <copumpkin> this TLS library seems nice apart from this minor issue :P
17:50:23 <benmachine> I'm writing an introductory article to lambda calculus
17:50:35 <benmachine> I would appreciate it if anyone could fact-check this paragraph for me: http://www.srcf.ucam.org/~bm380/snippet.txt
17:51:19 <benmachine> (it's aimed at pre-university students, and more supposed to be "ooh look interesting" than a serious treatment of the subject, but I don't want to say anything outright wrong)
17:51:39 <confound> copumpkin: there's no way to do that; if there were, it would probably require reading kernal internal memory structures
17:51:44 <SOwhoisntme> Hello haskell people. I want to call haskell code from python. The method I'm trying to use is to create a shared library (.so) and import this into ctypes. However this isn't working too well gcc complains about issues relocating symbols. I've successful built the executable examples. Does anyone have any relevant experience (google doesnt' seem too helpful)?
17:53:22 <confound> if I want to parse email messages, for the purpose of storing the parsed structures in a database, what library should I use? it doesn't need to be able to construct or modify messages.
17:55:12 <DevHC> benmachine: i have no idea what the previous paragraphs r, but if i were a pre-university student reading that one paragraph, i'd say: WTF?
17:55:27 <Cale> SOwhoisntme: hrm
17:55:43 <benmachine> DevHC: could you be more specific with your criticism perhaps?
17:55:49 <Cale> SOwhoisntme: the only Haskell/Python interop project I know of is MissingPy, and that goes in the opposite direction
17:56:40 <SOwhoisntme> So, I'm pretty sure one can get one working by using c interop.
17:56:52 <SOwhoisntme> (via ctypes)
17:56:54 <Cale> SOwhoisntme: -shared is supposed to exist, but I've never tried it
17:57:11 <DevHC> benmachine: too much new data thrown at a mind far from knowledgable in the discussed areas
17:57:14 <Cale> (GHC option)
17:57:21 <SOwhoisntme> The issue I'm having is building any shared option.
17:57:49 <SOwhoisntme> *any shared library
17:57:58 <Cale> -fPIC -shared ?
17:58:16 <benmachine> DevHC: like I said, I'm not really trying to teach them anything particularly useful, just trying to illustrate that there's interesting things in the field
17:58:17 <Cale> No luck with those? I don't really know.
17:58:23 <SOwhoisntme> Yep.
17:58:34 <ddarius> benmachine: Looping programs are not incorrect.
17:59:55 <benmachine> ddarius: I was uncomfortable about that wording too but I couldn't think of a better one
18:01:15 <SOwhoisntme> So I'm getting errors talking about 'Nonrepresentable section on output' and stginit_Safe (module name safe). This symbol is created as part of the C foreign function interface (it's the thing you feed into hs_add_root).
18:01:50 <yitz> Cale: no there's a more recent package with similar goals to MissingPy. forget the name.
18:02:14 <yitz> Cale: more recent Python versions, better API coverage.
18:02:20 <benmachine> ddarius: tbh I'm pleased you got that far through without finding anything else wrong with it :P
18:02:49 <ddarius> benmachine: Most of it is nontechnical.
18:03:00 <Cale> http://wiki.python.org/moin/PythonVsHaskell
18:03:07 <Cale> has a commandline which is supposed to work
18:03:13 <ddarius> That this meat was intended for braising is evident.
18:03:17 <benmachine> ddarius: fair enough
18:04:00 <SOwhoisntme> Aha... that looks informative.
18:04:02 <SOwhoisntme> Thanks for the link
18:04:16 <DevHC> benmachine: about "various theoretically equivalent": instead of equivalent, i'd write Turing-equivalent (if i understood well)
18:04:57 <Cale> also, don't miss this link: http://weblog.haskell.cz/pivnik/building-a-shared-library-in-haskell/
18:05:16 <benmachine> DevHC: that sounds more like a stylistic comment than a factual one
18:05:44 <DevHC> yes, but it helps understanding imo
18:06:40 <yitz> benmachine: without seeing the rest of your article, just a reminder that for that audience you may get some smiles if you reference "alligator eggs".
18:06:47 <DevHC> benmachine: instead of "nonsensical", i'd use "sometimes (unintendedly) useless" or something like that
18:07:06 <yitz> DevHC: how about "problematic"
18:09:05 <benmachine> yitz: http://worrydream.com/AlligatorEggs/ ? cute :D
18:10:31 <yitz> benmachine: yeah that's the one :)
18:10:32 <DevHC> yitz: hmm.
18:13:16 <DevHC> benmachine: replace "we cannot in general be sure" with "we cannot in general find out, in an automated way,"
18:13:51 <benmachine> DevHC: stylistic comment again
18:14:15 <DevHC> benmachine: problem?
18:14:31 <benmachine> DevHC: well, it's not what I asked for; I like my style
18:15:00 <benmachine> my specific original request was fact-checking
18:15:20 <drbean> benmachine: Yeh, some indication that looping programs should not be excluded, but are with STLC.
18:16:11 <Cale> DevHC: We also can't in general be sure.
18:17:47 <elliott> how painful is it to use the exported C API of a shared Haskell library from the haskell ffi?
18:18:16 <Cale> (there will always be programs which we can't prove they don't terminate)
18:18:46 <Cale> elliott: You have to call hs_init to initialise the runtime system
18:18:55 <Cale> elliott: and then you just call them normally
18:19:23 <DevHC> Cale: ORLY
18:21:05 <Draconx> Cale, unfortunately, the author of that blog post only "hopes" that it will work on other systems, and the method desrcibed in it is doomed to failure on just about anything other than a 386 running GNU/Linux.
18:22:29 <Cale> Draconx: ?
18:22:48 <Draconx> Cale, re: "Building a shared library in Haskell".
18:23:01 <Cale> okay
18:23:07 <Cale> I haven't tried any of it
18:23:44 <Draconx> Cale, on an x86_64, GHC tries to link base into the shared object, which fails because base was not built as position independent code.
18:24:22 <elliott> Cale: haha, initialise the runtime system from inside haskell
18:26:02 <Cale> Draconx: what about with -dynamic?
18:28:16 <Cale> elliott: Perhaps I misunderstood what you were talking about
18:28:49 <Cale> elliott: You probably don't have to hs_init in the case that you're re-importing exported Haskell code.
18:28:56 <elliott> Cale: Right.
18:29:01 <Cale> (but Y U DO THIS THINGS?!)
18:29:13 <elliott> Cale: I'm not sure myself. But it might be nicer than using the GHC API in this case.
18:29:24 <elliott> Also it's amusing.
18:29:36 * danharaj_ grumbles
18:30:01 <danharaj_> The OpenGL docs never mentioned assumptions about alignment for texture data.
18:35:50 <SOwhoisntme> Cool. Bed becons. Thanks for your help. I think I've found the cause of my problem (I was attempting to call hs_add_root(blah)) with "blah" coming for a shared library, this didn't work becuase "blah" had no size so we couldn't load this. The work around is to only call add_root from within the shared library itself (I think). I'll see if I can get this working and inform the internet of any findings. I believe that the need for hs_ad
18:35:50 <SOwhoisntme> d_root disappears in later versions of ghc. Goodnight!
18:40:20 <ndunn> evening all
18:49:47 <dobblego> are there any papers or precedent on writing type-safe relational database queries?
18:51:40 <aavogt> haskelldb
18:52:34 <dobblego> yeah just looking at that, cheers
19:02:31 <dainanaki> If I'm using multiple haskell dlls in a C program, do each of them need their own runtime?
19:17:41 <eyu100> what is the (->) type constr. called?
19:19:48 <dmwit> "function" or "arrow"
19:19:59 <dmwit> Though you can pronounce it "to" if you're reading it in-line.
19:19:59 <Cale> Or read as "to"
19:20:02 <Cale> yeah
19:20:33 <eyu100> is there documentation on the weird type constructors like [] (->) and [::]?
19:20:38 <eyu100> I still can't figure out what [::] does
19:20:50 <Cale> [: :] is part of the parallel array extension
19:20:52 <dmwit> [::] is for data-parallel lists, I think.
19:20:54 <eyu100> and I can't search them on google because they're symbols =\
19:21:07 <dmwit> Look up "data-parallel haskell" or DPH.
19:21:23 <marv> I was reading http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Maybe and I don't understand where "id" comes from in the function "fromMaybe"
19:21:27 <Cale> http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
19:21:29 <dmwit> As for online resources that handle symbols, try hoogle.
19:21:32 <dmwit> ?hoogle []
19:21:32 <lambdabot> Did you mean: [a] /count=20
19:21:32 <lambdabot> Prelude undefined :: a
19:21:32 <lambdabot> Test.QuickCheck.Batch bottom :: a
19:21:47 <Cale> marv: id is a function in the Prelude defined as  id x = x
19:21:56 <eyu100> ?hoogle (->)
19:21:56 <lambdabot> Text.Html (<->) :: (HTMLTABLE ht1, HTMLTABLE ht2) => ht1 -> ht2 -> HtmlTable
19:21:56 <lambdabot> Text.XHtml.Table (<->) :: (HTMLTABLE ht1, HTMLTABLE ht2) => ht1 -> ht2 -> HtmlTable
19:22:10 <Cale> marv: (the identity function)
19:23:45 <marv> ah ok, that makes sense. i wanted to read it as a parameter, but it wasn't declared, so i wanted to read it as a syntax error, but i figured i was just missing something. thanks.
19:23:57 <Cale> eyu100: [] is the type constructor for lists (as well as the empty list, at the value level), so, in the language of types, [] a = [a] is the type of lists of elements of type a
19:25:31 <parcs> great idea or greatest idea? `instance MonadIO m => IsString (m CString)`
19:26:51 <Cale> parcs: so you'd have... x <- "hello"
19:29:39 <parcs> ok what about instance Integral n => IsString (CString, n)
19:31:04 <parcs> hmm in that case it might as well have the monadio constraint as i'm going to pattern match it regardless
19:33:37 <parcs> @hoogle unsafePerformIO
19:33:37 <lambdabot> Foreign unsafePerformIO :: IO a -> a
19:33:37 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
19:38:19 <danharaj> ugh
19:38:26 <danharaj> does anyone have any experience with making fonts look good in openGL?
19:38:59 <danharaj> I get catastrophic loss of detail at small sizes.
19:39:10 <danharaj> I guess this is not the place to ask :p
19:42:26 <Cale> danharaj: It seems like it might make more sense to render the text into a texture...
19:42:54 <Cale> (but I don't have any experience with it)
19:43:37 <Jafet> > fix (>>= return)
19:43:37 <lambdabot>   No instance for (GHC.Show.Show (m a))
19:43:38 <lambdabot>    arising from a use of `M2112568030...
19:47:02 <monochrom> choose a monad!
19:47:26 <ion> > runIdentity $ fix (>>= return (42:)
19:47:27 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
19:47:29 <ion> > runIdentity $ fix (>>= return (42:))
19:47:30 <lambdabot>   Couldn't match expected type `Data.Functor.Identity.Identity a'
19:47:30 <lambdabot>         aga...
19:48:23 <ion> duh
19:48:24 <ion> > runIdentity $ fix (>>= return . (42:))
19:48:25 <lambdabot>   [42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42...
19:54:57 <pizzaplane> noob question: I have a few types that are a members of Enum and Bounded, and I would like to create a function that returns a value of one of those types when given an offset Int from the lower bound.  I have tried this: http://hpaste.org/49610 and it failed to compile.
19:55:51 <pizzaplane> I assume I am way off on type parameters
19:56:21 <Jafet> > runIdentity $ fix (>>= return . ((0:) . map succ))
19:56:23 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
19:56:53 <Jafet> And they say that monads are useful...
19:57:23 <drdo> If i set a Handle's NewlineMode for input to CRLF, shouldn't hGetLine only return lines actually ended by CRLF?
19:57:54 <aavogt> pizzaplane: you need an extension of ghc's to get the  'a' in the expression to be equal to the 'a' in the type signature
19:58:08 <dolio> Monads are just the thinnest veneer over the gaping fundamental flaws in Haskell's design, clearly.
19:58:20 <Jafet> More pertinently, pizzaplane needs to use Num to be able to add stuff
19:58:28 <Jafet> Oh, he doesn't
19:58:46 <Jafet> Well, you could just leave out the type signatures in this case
19:59:27 <aavogt> > let fromOffset o = let r = toEnum (o + fromEnum (minBound `asTypeOf` r)) in map r [0,1] :: [Bool]
19:59:28 <lambdabot>   not an expression: `let fromOffset o = let r = toEnum (o + fromEnum (minBou...
19:59:35 <aavogt> > let fromOffset o = let r = toEnum (o + fromEnum (minBound `asTypeOf` r)) in r in map r [0,1] :: [Bool]
19:59:36 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
19:59:36 <lambdabot>         against inferred ...
20:00:18 <Jafet> Oh, hm
20:00:43 <Jafet> > let fromOffset o = let r = toEnum (o + fromEnum (minBound `asTypeOf` r)) in r in fromOffset <$> [0,1] :: [Bool]
20:00:43 <lambdabot>   [False,True]
20:01:02 <Jafet> > let fromOffset o = let r = toEnum (o + fromEnum (minBound `asTypeOf` r)) in r in fromOffset 1000 :: [Bool]
20:01:02 <lambdabot>   No instances for (GHC.Enum.Enum [GHC.Bool.Bool],
20:01:03 <lambdabot>                    GHC.Enu...
20:01:03 <aavogt> > r -- tricky
20:01:04 <lambdabot>   r
20:01:07 <Jafet> > let fromOffset o = let r = toEnum (o + fromEnum (minBound `asTypeOf` r)) in r in fromOffset 1000 :: Bool
20:01:08 <lambdabot>   *Exception: Prelude.Enum.Bool.toEnum: bad argument
20:01:45 <aavogt> pizzaplane: the extension is called  -XScopedTypeVariables
20:02:13 <pizzaplane> hmm
20:03:23 <aavogt> pizzaplane: so you can either use asTypeOf as above, or the much clearer http://hpaste.org/49610
20:03:56 <pizzaplane> does asTypeOf require the extension?
20:04:48 <parcs> no
20:04:50 <aavogt> nope, but it means you have to contort the code to get a variable with type 'a' (above is r)
20:04:57 <parcs> @src asTypeOf
20:04:57 <lambdabot> asTypeOf = const
20:05:03 <parcs> :t asTypeOf
20:05:04 <lambdabot> forall a. a -> a -> a
20:05:14 <parcs> it's a specialized const
20:06:01 <parcs> :t let fromOffset o = toEnum (o + fromEnum minBound) in fromOffset
20:06:01 <lambdabot>     Ambiguous type variable `a' in the constraints:
20:06:02 <lambdabot>       `Bounded a'
20:06:02 <lambdabot>         arising from a use of `minBound' at <interactive>:1:40-47
20:07:02 <parcs> :t let fromOffset o = toEnum (o + fromEnum (minBound `asTypeOf` fromOffset o)) in fromOffset
20:07:03 <lambdabot> forall a. (Enum a, Bounded a) => Int -> a
20:14:10 <monochrom> drdo: interesting. apparently, all the newline mode can do is: should \r\n be simplified to \n? note that \n is preserved, no one is asking existing \n's to be corrupted
20:15:39 <aavogt> :t let fromOffset :: (Enum a, Bounded a) => Int -> a; fromOffset o = toEnum (o + fromEnum (minBound `asTypeOf` fromOffset o)) in fromOffset
20:15:40 <lambdabot>     Ambiguous type variable `a' in the constraints:
20:15:40 <lambdabot>       `Enum a'
20:15:40 <lambdabot>         arising from a use of `fromOffset' at <interactive>:1:108-119
20:15:47 <monochrom> and then all hGetLine does is scan for \n after the above simplification. and why shouldn't it? it does not know where the \n came from
20:16:17 <drdo> monochrom: Meh, so all it does is discard the last character if it's a CR?
20:16:37 <aavogt> parcs: I'm surprised that without the type signature your version works (related to when you're allowed polymorphic recursion I think)
20:17:42 <monochrom> it is also a haskell 98 requirement. inside String, newline is \n only, regardless of platform. how String's \n map to bytes in files is another matter
20:18:35 <drdo> monochrom: I don't see how this is incompatible with that requirement
20:20:39 <monochrom> ok, screw hGetLine for the moment. the file has the bytes 'a', '\r', '\n', 'b', '\n'. you turn on window's newline mode. then you hGetBuf or a lot of hGetChar's. what Chars should you see?
20:21:27 <DevHC> @src lines
20:21:28 <lambdabot> Source not found.
20:21:29 <DevHC> eh?
20:21:44 <monochrom> you should see a', '\n', 'b', '\n'. and that makes sense to me at least. I wouldn't want the last \n to be mutated just because it does come with a \r
20:23:03 <monochrom> ok, now, hGetLine also sees that, and that's two newlines
20:23:18 <drdo> monochrom: I see the point you're making
20:24:25 <drdo> but no, not for hGetBuf
20:24:58 <drdo> I don't agree at all with that for hGetBuf, it specifically says 8-bit characters
20:25:06 <Cale> If you want to read bytes, you should have newline mode off
20:25:17 <Cale> and you should use Data.ByteString, anyway :)
20:25:38 <monochrom> oh nevermind, hGetBuf ignores newline mode altogether
20:25:47 <drdo> Eh, i just wanted to read IRC messages
20:38:14 <ivanm> dammit, I cut large chunks out of a program to try and get a minimal test case... and forgot to make a backup, so I can't get back to what the original version was :s
20:38:41 <dobblego> git reset --hard
20:41:00 <ivanm> well, it's darcs; and I thought I recorded a patch but I didn't :s
20:51:15 <Jafet> But if you fix the problem, is it progress?
20:51:43 <mm_freak> prototype of my FRP-based IRC library is almost finished =)
20:53:15 <vicvicvic> is there an environment variable for changing the location of the .cabal directory?
20:53:27 <vicvicvic> (or some other way)
20:53:37 <mm_freak> vicvicvic: see the cabal-dev package
20:54:27 <mm_freak> it allows you to have project-local .cabal and .ghc directories, but also allows you to specify the directory locations explicitly
20:54:46 <vicvicvic> right but I'm specifically interested in not having a .cabal directory in $HOME
20:55:33 <vicvicvic> but maybe i can just use this completely instead of cabal then
20:55:39 <mm_freak> yes, you can
20:55:42 <vicvicvic> ah thanks!
20:55:48 <mm_freak> that's actually the idea
20:56:11 <vicvicvic> sorry i thought it was just an "extra" for virtual environments :p
20:56:20 <dmwit> vicvicvic: Eh, do you want to use global installs?
20:56:34 <dmwit> Just set user-install: False in ~/.cabal/config.
20:56:59 <vicvicvic> dmwit: well i don't really care if they're global or not right now, i just don't want dotfiles cluttering my $HOME
20:57:31 <dmwit> ok =)
21:01:09 <ivanm> Jafet: was that comment aimed at me?
21:04:08 <zzo38> I made a program supporting Bird style directly in TeX, although without prettyprinting. The \begin{code} \end{code} style I didn't do yet, and I also didn't do prettyprinting and index yet either.      http://sprunge.us/SKPf
21:04:15 <zzo38> Does this program work to you?
21:05:32 <ivanm> zzo38: sorry, what is it meant to do?
21:05:38 <ivanm> and how are you meant to use it?
21:06:55 <zzo38> ivanm: Well, it isn't perfect because it should probably add extra vertical space before and after the code, and change vertical penalties, etc; but what it does, is allow TeX to read a .lhs file using Bird-style and print it out. How you use it, is if the program I wrote is called "birdstyle.tex" then at the top of the program you type:     \input birdstyle
21:07:04 <zzo38> That is how you use it. OK? Can you understand?
21:07:44 <ivanm> oh, so it pretty-prints a bird file?
21:07:52 <zzo38> No, it is non-pretty-printing.
21:07:53 <ivanm> or just makes it so that TeX doesn't bitch at bird tracks?
21:08:04 <zzo38> Later I might make pretty-printing but this one is non-pretty-printing.
21:08:43 <zzo38> ivanm: It makes it so that when TeX reads it, it formats the code in monospace text in a Bird-style program, with line breaks and stuff.
21:08:51 <ivanm> *nod*
21:09:04 <ivanm> might be an idea to use the listings package for that
21:09:37 <zzo38> If the program is called "program.lhs" then you might type the following command in your system shell to run it (but you have you change depending on your system):    tex program.lhs; dvilj4 - < program.dvi | lp
21:10:03 <zzo38> ivanm: What is a listings package?
21:10:22 <ivanm> @google listings latex
21:10:23 <lambdabot> http://en.wikibooks.org/wiki/LaTeX/Packages/Listings
21:10:23 <lambdabot> Title: LaTeX/Packages/Listings - Wikibooks, open books for an open world
21:10:44 <ivanm> OK, I still need \begin{document}, etc.
21:11:17 <zzo38> My program is for Plain TeX, it is not meant for LaTeX. You don't need \begin{document} etc
21:11:24 <ivanm> oh
21:11:29 <ivanm> that might be why it didn't work :p
21:11:35 <ivanm> wait, you mean people still use plain TeX? :o
21:12:02 <ivanm> zzo38: well, it doesn't like my usage of $ :p
21:12:24 <zzo38> Yes, a few people do. I still use Plain TeX. In fact I don't have LaTeX, I uninstalled LaTeX and pdfTeX and that stuff
21:12:29 <zzo38> ivanm: Can you explain better?
21:12:35 <ivanm> wait, I'm not using $ ...
21:13:18 <ivanm> I had a line of ========== as a heading title in my code; it didn't like that ;-)
21:13:41 <mm_freak> djahandarie, Eduard_Munteanu: i remember you two being interested in a new IRC library…  well, it's almost there…  i hope to upload the first beta today =)
21:13:49 <mm_freak> as promised it uses FRP
21:13:52 <zzo38> OK. Can you show what you did? If there is in fact a bug in my program I will fix it
21:14:13 <zzo38> I don't know much about Haskell, actually
21:14:24 <ivanm> then again, it wasn't designed to be TeX
21:14:36 <ivanm> zzo38: I had a vaguely markdown-ish syntax in my code ;-)
21:14:42 <ivanm> s/code/document/
21:14:54 <zzo38> Then that is why it doesn't work. This program is for TeX, not markdown.
21:15:32 <ivanm> yeah, I just grabbed the first lhs file on my system I could find :)
21:15:49 <ivanm> zzo38: may I ask _why_ you don't use LaTeX or some similar macro system?
21:16:01 <zzo38> But be careful in case you use blank lines or \par inside of macros. It probably won't work very well. Use \endgraf instead in those cases.
21:16:23 <zzo38> ivanm: I have tried LaTeX once. I find I prefer Plain TeX is better.
21:17:09 <zzo38> I have actually written a lot of stuff using Plain TeX.
21:17:50 <zzo38> (But it seems CTAN won't accept any of my files, for some reason...)
21:18:22 <mm_freak> i'm finding more and more uses for FRP…  finally found a new design pattern, which amazes me =)
21:18:39 <ivanm> mm_freak: but, in Haskell we don't use design patterns!
21:18:40 <ivanm> :p
21:19:01 <mm_freak> ivanm: we don't use java "design patterns" =P
21:19:04 <dainanaki> In Haskell, we use them all without thinking.
21:19:31 <zzo38> Is \end{code} ever a valid Haskell code? And is it the case that \end{code} in a string literal in a .lhs file is not the end of the code?
21:19:44 <mm_freak> java design pattern = the way you name your classes
21:19:51 <ivanm> zzo38: not if it's in a string literal
21:20:36 <zzo38> But still, I don't think the \begin{code} style ought to have been in the standard, anyways
21:20:44 <zzo38> (It is just my opinion)
21:20:46 <mm_freak> haskell design pattern = the branch of CT you use to make your types
21:20:54 <ivanm> zzo38: why not?
21:21:11 <ivanm> it tends to work better for people that like to embed their code in LaTeX than birdtracks
21:21:14 <mm_freak> PHP design pattern = the way you suppress interpreter warnings
21:21:40 <ivanm> mm_freak: heh
21:21:56 <mm_freak> assembly design pattern = the way you catch SIGSEGV and SIGILL
21:22:24 <mm_freak> lazy k design pattern = the way you make others' head explode
21:22:34 <cmccann> lazy k isn't that difficult
21:22:45 <cmccann> just painfully tedious to write in directly
21:22:49 <mm_freak> cmccann: wait, /writing/ lazy k isn't difficult
21:22:51 <zzo38> ivanm: I just think it doesn't make any sense at all to include that in the standard! Maybe if you wanted surround style you could use something a bit more sensible perhaps, I wouldn't know what because I don't know of Haskell much, though. But I don't really care much either.
21:24:07 <cmccann> mm_freak, the only sane way to write in it amounts to in-place macro-expansion of more useful combinators. Not too hard to "decompile" the same
21:24:10 <ivanm> well, it looks LaTeX-ish, which is the main point
21:24:18 <zzo38> But I just wrote this "birdstyle.tex" program so that now TeX can read .lhs file
21:24:30 <Cale> zzo38: Well, it's in the standard so that .lhs files in that format will work in any compiler. Theoretically it could also be a preprocessor that's separate, and practically speaking those exist anyway
21:24:56 <Cale> zzo38: But Haskell was developed around a culture of people mainly writing papers about programming languages, so LaTeX is in common use :)
21:25:15 <cmccann> I've said before that Lazy K + the C preprocessor would actually be pretty tolerable as a programming language
21:25:47 <Cale> Yeah, the only thing making Lazy K bad is the complete lack of naming mechanisms
21:25:48 <zzo38> cmccann: Yes maybe even on #esoteric channel they can discuss such thing
21:26:24 <cmccann> Cale, it's like the output of @pl except not quite as obfuscated :D
21:27:22 <zzo38> You could make after the C preprocessor, can remove " and remove lines with # so that it won't do #line and so that the Lazy-K codes can be inside of strings in order to not be processed in case they happen to make up a name or something else
21:28:14 <mm_freak> cmccann: indeed…  actually a program for abstraction elimination is easy to write in haskell
21:29:02 <cmccann> but lazy k has the same compositional advantages that pure functions in Haskell do, so given macro expansions, bolt on a standard library, and find some way to make keeping IO straight less painful and you're good to go
21:30:00 <zzo38> Now there is Plain TeX program for Bird-style programming. Yet it could probably be improved, in case you want a bar on the left or change space surrounding it in output, or to affect the vertical penalties, my program could be corrected. I wrote this program it is public domain so use as you want to.
21:30:14 <cmccann> would probably even be simple to automatically port most of the haskell prelude to Lazy K, given appropriate church-encoded types to work with
21:32:53 <zzo38> Maybe you can even use not only C preprocessor for Lazy K, but maybe even m4, or even TeX can be used to produce plain ASCII text output file.
21:36:24 * hackagebot HsHyperEstraier 0.4 - HyperEstraier binding for Haskell  http://hackage.haskell.org/package/HsHyperEstraier-0.4 (MasatakeDaimon)
21:46:56 <drdo> Hmm, hGetLine for ByteString doesn't work as i expected with CRLF NewlineMode either
22:03:48 <mm_freak> drdo: if you don't mind iteratees, you can use my netlines library, which lets you split the stream according to certain rules and also limits line length for safe text protocol implementations
22:05:35 <drdo> mm_freak: I'm new to haskell, let me read up on iteratees :)
22:05:48 <mm_freak> oh, if you're new to haskell, don't bother yet =)
22:06:06 <mm_freak> iteratees take some experience with monads and monad transformers
22:07:06 <drdo> mm_freak: No problem, i'll just read as i go
22:07:18 <mm_freak> drdo: btw, if your handles are sockets, the default buffering mode is BlockBuffering…  you may want to change that to NoBuffering
22:07:30 <mm_freak> see hSetBuffering
22:07:47 <drdo> mm_freak: I had changed it to LineBuffering, excepting CRLF NewlineMode to do the right thing
22:07:53 <drdo> No luck
22:07:56 <drdo> *expecting
22:08:19 <kniu> @pl (x -> y -> z -> f (g (h x) y) z)
22:08:19 <lambdabot> (line 1, column 4):
22:08:19 <lambdabot> unexpected ">"
22:08:19 <lambdabot> expecting variable, "(", operator or ")"
22:08:36 <kniu> @pl (\ x -> y -> z -> f (g (h x) y) z)
22:08:36 <lambdabot> (line 1, column 11):
22:08:36 <lambdabot> unexpected ">"
22:08:36 <lambdabot> expecting variable, "(", operator or ")"
22:08:45 <kniu> @pl (\ x y z -> f (g (h x) y) z)
22:08:45 <lambdabot> (f .) . g . h
22:10:25 <drdo> Actually now that i think about it, i don't know what input line buffering means
22:16:51 <mm_freak> drdo: LineBuffering is not what you may think it is
22:17:05 <mm_freak> it doesn't change /what/ hGetLine returns, just /when/ it does
22:17:41 <drdo> mm_freak: Buffering never affects what you get obviously
22:18:49 <drdo> I guess i should have phrased better what I said earlier
22:19:35 <kniu> @pl (\f x y -> g (f x) y)
22:19:35 <lambdabot> (g .)
22:20:51 <mm_freak> drdo: perhaps, yes…  you want to read lines terminated by CRLF instead of LF?
22:21:34 <drdo> mm_freak: yes
22:21:46 <mm_freak> drdo: if yes, until you reach iteratees you may want to use a parser instead of the low level functions
22:21:56 <mm_freak> attoparsec is a nice and very fast ByteString parsers
22:21:57 <mm_freak> -s
22:23:42 <drdo> mm_freak: Also, i know that lines can't be bigger than 512 bytes
22:24:06 <mm_freak> drdo: can't be or shouldn't be?
22:24:15 <drdo> As in, if they are, it's a protocol error
22:24:52 <mm_freak> IRC? =)
22:25:30 <drdo> mm_freak: yes, i mentioned that earlier
22:26:24 <drdo> Just writing a quick bouncer since the existing ones don't do what i want
22:27:28 <mm_freak> drdo: do you want to make your own IRC library?
22:27:34 <mm_freak> if not, there are some ready-made ones
22:27:48 <mm_freak> funnily i'm writing one just right now =)
22:27:53 <drdo> mm_freak: You don't need to parse much, mostly just PING
22:28:16 <drdo> You just send raw data back to the attached user
22:28:27 <drdo> Just need the PING to PONG back
22:28:46 <mm_freak> for PING and PONG you already need a full protocol parser
22:29:06 <drdo> mm_freak: why is that?
22:29:55 <drdo> You just need to check if the message has the format "PING <whatever>"
22:30:02 <drdo> and reply with "PONG <whatever>"
22:30:16 <drdo> which is basically just checking if the first 5 characters are those
22:30:24 <Cale> mm_freak: maybe to do it right... I ran an IRC bot for a few years which was a single shell commandline tied together into a fixed point with netcat and a fifo
22:30:44 <Cale> mm_freak: needless to say, it didn't have a full protocol parser ;)
22:31:57 <mm_freak> drdo: the IRC protocol is simple, yet PING utilizies all of it…  a simple parser like that will succeed on some servers and fail on others
22:32:07 <mm_freak> same @ Cale
22:32:22 <drdo> mm_freak: PING can't even have a prefix, can it?
22:32:30 <mm_freak> sure it can
22:33:03 <mm_freak> all IRC messages have the same format
22:33:10 <mm_freak> but anyway, writing an IRC parser is very easy
22:33:25 <mm_freak> if you don't want to do it, just use one of the ready-made libraries
22:33:40 <mm_freak> my old fastirc library contains a very fast ByteString IRC parser
22:33:51 <drdo> Why are you writing a new one?
22:34:16 <mm_freak> because the new library uses an entirely different concept to handling IRC
22:34:28 <mm_freak> i basically had to rewrite everything
22:36:24 <drdo> How different can it be? Unless you're doing higher level stuff and not just parsing
22:41:23 <mm_freak> drdo: it's a complete client library just like fastirc
22:41:47 <mm_freak> the old library uses a monadic concept…  the new one uses FRP
22:50:23 <markspezzano> Hi, I have a dumb question…I have some trouble doing an import using structured Haskell directories. Specifically, I have a folder Queue containing a file First.hs with module name Queue.First and folder Queue also contains a second file called Second.hs with module name Queue.Second. Question is how do I tell Second.hs that module Queue.First exists. I've tried all combinations of import including import Queue.First and also
22:50:23 <markspezzano> import First but nothing seems to work. I keep getting errors about "saw xyz" "expected "abc" etc. Thanks!
22:58:18 <mm_freak> markspezzano: if you use GHC, just use GHC --make
22:58:24 <mm_freak> also remember that you have to use full module paths
22:58:36 <markspezzano> I'm using GHCi
22:59:01 <mm_freak> in GHCi you should be able to write:  :m Queue.First
22:59:13 <mm_freak> as long as you are one level /above/ the Queue directory
23:15:36 * hackagebot HsSVN 0.4.3.2 - Partial Subversion (SVN) binding for Haskell  http://hackage.haskell.org/package/HsSVN-0.4.3.2 (MasatakeDaimon)
23:19:19 <ivanm> wait, people still use SVN? :o
23:20:15 <c_wraith> I know someone who does.  I taught her how SVN handles things like tagging and branching recently.  She almost puked. :)
23:20:45 <kmc> heh, "handles"
23:21:04 <kmc> you can use git as a frontend to svn
23:29:27 <ivanm> c_wraith: heh
23:29:38 <ivanm> kmc: not quite sure if that's better or not tbh :/
23:40:12 <mm_freak> does anyone know an elegant way to create identities in yampa?  that is:  i'd like to be able to request from the system to do something and receive the result
23:40:36 <mm_freak> the general idea is this:  IO a -> SF Response Request
23:40:39 <mm_freak> uhm
23:40:45 <mm_freak> the general idea is this:  IO a -> SF Response (Event a, Request)
23:41:10 <mm_freak> in fact right now i have no idea how to do this at all, let alone an elegant way to do it
