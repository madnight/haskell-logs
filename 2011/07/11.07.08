00:01:18 <tigerpaw> hello fellow geniuses; in dealing with abstract terms, what would be ideal for the set describing the 2 verbs of persisting state, and observing state
00:01:24 <tigerpaw> write/read? store/load?
00:02:56 <m3ga> tigerpaw: set/get?
00:03:00 <tigerpaw> or that too
00:03:10 <m3ga> thats what the ST monad uses
00:04:03 <shachaf> m3ga: No, ST uses read/write.
00:04:06 <shachaf> State uses get/set.
00:04:21 <m3ga> yeah, shachaf is right
00:04:46 <tigerpaw> what's the difference?
00:05:17 <tigerpaw> is get/set about properties, and read/write about pure state instruction?
00:05:23 <tigerpaw> like, a getter would implement a read
00:05:23 <c_wraith> no
00:05:31 <edwardk> tigerpaw: honestly, its more about who wrote the library
00:05:43 <c_wraith> yeah, there's no real semantic difference
00:05:48 <c_wraith> It's just whatever names you like most
00:05:50 <tigerpaw> these concept doesn't have a spec attached to it?
00:05:57 <tigerpaw> this
00:06:13 <shachaf> Nope.
00:06:22 <shachaf> Well, the class MonadState does. But words are just words. :-)
00:06:52 <tigerpaw> weak
00:06:56 <tigerpaw> i wonder which set of terms is best
00:07:05 <tigerpaw> well right there to me excludes get/set
00:07:13 <tigerpaw> set is also "group"
00:07:20 <tigerpaw> so we're down to load/store and read/write
00:07:27 <tigerpaw> hrm
00:08:35 <shachaf> Just use whichever name you like the best. Variety is good. :-)
00:09:29 <tigerpaw> damnit
00:12:50 <earthy> actually, there *is* something to be set for choosing the 'right' names
00:12:54 <earthy> s/set/said/
00:13:46 <earthy> but, I'd use read/write in your case, tigerpaw
00:14:46 <earthy> oh, and Control.Monad.State uses 'get' and 'put'
00:17:23 <earthy> the difference between the ST monad and the State monad being that ST allows an arbitrary amount of *different* state containers under 1 monad whereas State allows exactly 1
00:17:45 <roconnor> HTTP uses get and put?
00:18:52 <roconnor> BASIC uses peek and poke
00:20:38 <earthy> HTTP uses GET, POST and PUT
00:20:47 <earthy> where POST is akin to State's modify
00:21:35 <earthy> Java uses get and set, C# too
00:22:37 <tigerpaw> earthy, thank you for your great response
00:22:38 <shachaf> Computer games use Save and Load/Restore.
00:22:40 <tigerpaw> alike mind
00:23:28 <roconnor> I'd like to see a pure impelementation of the denotational semantics of ST. ... It should be possible right?
00:24:50 <shachaf> roconnor: I thought I saw one mentioned once.
00:28:23 <sipa> roconnor what will you define a satoshi as?
00:28:51 <roconnor> sipa: the smallest unit of currency
00:29:09 <sipa> ok yes, that's one of the names used for it
00:29:11 <roconnor> satoshi :: BTC
00:29:12 <roconnor> satoshi = Ƀ (succ 0)
00:29:20 <roconnor> newtype BTC = Ƀ (Fixed E8) deriving (Eq, Ord, Show)
00:29:26 <sipa> nice
00:29:48 <sipa> in the c++ source code, it's called UNIT
00:29:55 <roconnor> ah
00:30:09 <roconnor> it was probably written before satoshi was the pet name for this value.
00:30:43 <roconnor> BTW, Ƀ is an awesome name for a constructor ;)
00:30:50 <sipa> agree :)
00:32:24 <roconnor> But I also define btc = Ƀ for those people who cannot find their Ƀ key
00:32:46 <shachaf> roconnor: Where is your Ƀ key?
00:33:15 <roconnor> when it is in my cut and paste buffer it is one of my mouse buttons.
00:34:20 <shachaf> And otherwise?
00:34:58 <roconnor> btc
00:36:57 <sipa> that seems wrong for a constructor :)
00:39:26 <ddarius> @tell roconnor The only difficulty with the semantics of ST is due to types.  If you don't worry about typing, then it's just a state monad with a map and a counter.
00:39:26 <lambdabot> Consider it noted.
00:46:13 <shachaf> ddarius: Typing?
00:49:16 <c_wraith> shachaf: you need to use something like Data.Dynamic
00:49:26 <c_wraith> shachaf: meaning unsafeCoerce
00:53:28 <c_wraith> shachaf: actually, I guess you'd avoid Data.Dynamic because of its Typeable constraints.  Since the references contain the types, and aren't allowed to change, just using unsafeCoerce and Any would work.
00:53:54 <c_wraith> shachaf: but the main point is that you need something able to store polymorphic keys.
00:53:59 <c_wraith> err, not keys, values.
00:54:09 <shachaf> Yes, I see.
00:54:14 <shachaf> Is it really impossible without unsafeCoerce?
00:55:14 <c_wraith> Possibly not.
00:55:26 <c_wraith> But it's *hard* :)
01:15:05 <fasta> Is there a pure Haskell webserver implementation which contains zero unsafe operations?
01:16:41 <JuanDaugherty> pure zero unsafe
01:17:37 <shachaf> @context fasta
01:17:37 <lambdabot> Unknown command, try @list
01:24:19 <earthy> fasta: I'd guess not
01:24:34 <earthy> as for performance they tend to use Text and ByteString
01:25:06 <earthy> and those provide a safe wrapper around unsafePerformIO'd thingies
01:25:51 * MatrixFrog1 did not know that
01:25:56 <MatrixFrog1> i feel so impure now! :P
01:26:26 <fasta> earthy: and nobody proved that they are used in a safe way in those libraries yet?
01:26:50 <fasta> earthy: (As I can imagine Galois using it in basically everything. )
01:27:02 <Cale> fasta: Of course, nobody's proved that GHC is correct either
01:27:15 <shachaf> MatrixFrog1: When GHC executes your code, it actually uses machine instructions that mutate registers and memory and everything.
01:27:23 <shachaf> I'd recommend that you stop using it at once.
01:27:36 <MatrixFrog1> :-o
01:27:37 <fasta> Cale: it is certainly within the realm of the possible to do this now.
01:28:27 <MatrixFrog1> shachaf i see your point. but i somehow thought bytestring was implemented in terms of regular old prelude stuff like chars and lists. though now that i think about it, that seems pretty unlikely
01:28:49 <fasta> MatrixFrog1: it is basically pointer arithmetic ;)
01:28:59 <MatrixFrog1> gah! pointers! noooooo!
01:32:38 <ari> So there's apparently about a billion serialization libraries on Hackage
01:32:44 * JuanDaugherty puts his finger in Galois's dirty crack, though it's not a dyke.
01:34:19 <ari> Could anyone recommend a package for serializing into a human-readable, commentable format? Better yet if it uses generics so I won't have to write picklers for everything... as long as it doesn't choke on the Data instances for Array and Set and others that are deliberately impoverished for some reason
01:35:26 <Saizan> there's a json library that uses syb with class
01:36:54 <Saizan> RJson
01:38:15 <ari> json doesn't "officially" support comments but I suppose if the library can deal with them it won't be a problem (I'm after human-editable files here and I want to put in only minimal work :p)
01:38:26 * ari has a look at RJson
01:40:25 <Saizan> i was wondering if it did :)
01:41:03 <Jafet> What's human-readable and commentable, XML?
01:42:29 <JuanDaugherty> a client's bitch ass spec
01:42:37 <Saizan> haml?
01:43:29 <Saizan> ah, no, that's a templating language
01:47:03 * JuanDaugherty misread that on first reading taking it as a spec for a usage of XML.
01:57:20 <ari> Okay, RJson seems to choke on Array as well
02:04:05 <Saizan> it chokes on Array?
02:04:21 <Saizan> s/Array/fromJson for Array/ ?
02:05:20 <Saizan> in that case you can make a specialized instance FromJson (Array i a) to solve that
02:05:49 <Saizan> it'll get used by the generics too
02:05:51 <hpaste> ari pasted “RJson choking on Array” at http://hpaste.org/48838
02:09:19 <ari> I think I'll have to write a ToJson as well since it seems to forget the array's shape
02:09:34 <ari> *Foo Text.RJson> toJson $ listArray ((0, 0), (1, 1)) [1, 2, 3, 4]
02:09:34 <ari> [1,2,3,4]
02:10:46 <Saizan> ah, there's already an instance of ToJson though
02:12:18 <trygvis> N
02:12:23 <trygvis> O.o
02:12:49 <ari> Well, it's moot anyway since RJson doesn't ignore /*comments*/ (or any other block comment syntax I tried for that matter, not that I tried more than {- -})
02:17:39 <Cale> instance (ToJson a, TranslateField a, Typeable a, Typeable i, Ix i) => ToJson (Array i a) where
02:17:39 <Cale>     toJson a = toJson (elems a)
02:17:42 <Cale> ^^ derp
02:18:08 <Cale> Well, that's easy enough to fix and submit a patch for anyway.
02:26:06 <Saizan> i guess the simplest answer should have been Read/Show :)
02:27:56 <ari> Read/Show are almost fine, but they're not exactly the greatest for human-editability
02:29:51 <ari> As in, derived Read instances don't allow comments and the error messages they produce when you get something wrong aren't exactly helpful
02:33:56 <Saizan> > read "{- foo -} 1" :: Int
02:33:57 <lambdabot>   *Exception: Prelude.read: no parse
02:34:04 <Saizan> i thought they did
02:36:29 <ari> I could try stripping comments out myself, but I'm not sure I'll get it right (wrt. comment sequences inside string literals, etc.)
02:39:03 <Cale> It'd be a little perverse, but you could use Haskell source files, and load them with something like hint.
02:41:13 <Baughn> > 95.25 / 161.84
02:41:14 <lambdabot>   0.5885442412259021
02:41:51 <ari> What would be nice is a XML serializer/deserializer using the same approach as json and RJson (i.e. a typeclass with a generics-based instance). There's text-xml-generic but it's too simple, generic-xml which seems bitrotted, and a bunch of parser/renderers
02:41:54 <benmachine> strip the comments manually beforehand?
02:42:13 <benmachine> oh you said that
02:42:21 <ski> you'd need to lex for that
02:42:23 <benmachine> strip the comments and get it right? :P
02:42:37 <quicksilver> XML is such a dire way to represent typical data structures though :(
02:43:12 <ski> > lex "(1,2)"  -- hm
02:43:13 <lambdabot>   [("(","1,2)")]
02:43:19 <Baughn> Yes, let's just use JSON.
02:43:30 <ari> :i lex
02:43:50 <ari> @index lex
02:43:50 <lambdabot> Text.Read, Prelude, Text.Read.Lex
02:44:24 <ski> > lex "{- foo -} (1,2)"  -- hrm
02:44:24 <lambdabot>   [("{","- foo -} (1,2)")]
02:44:31 <ski> that's probably bad
02:44:41 <ari> :D
02:46:23 <ari> Cale: Yeah, I don't really want to drag along eval just to read in data
02:48:18 <quicksilver> ari: considered yaml?
02:48:30 <quicksilver> at least it permits comments (IIRC)
02:48:37 <quicksilver> although there are things about it which aren't very nice.
02:48:45 <shachaf> quicksilver: JSON doesn't?
02:48:48 <shachaf> quicksilver: Which things?
02:49:45 <quicksilver> I don't remember. I just parrot accepted wisdom
02:49:58 <quicksilver> the pedantic way it uses whitespaces annoys some people I believe.
02:50:07 <quicksilver> we use YAML at work and it seems OK to us ;)
02:50:16 <shachaf> Pedantic how? Not permitting tabs? :-)
02:51:01 <quicksilver> requiring exactly one space after the colon?
02:51:53 <shachaf> I thought it allowed one-or-more.
02:52:06 <shachaf> Anyway, that's too off-topic here. :-)
02:58:55 <ari> quicksilver: I looked at the YAML libraries on Hackage and couldn't find a reflective one. I really really don't want to have to write picklers to convert several records with half a dozen fields into Data.ObjectS and back. (well, it's not the conversion into Data.Object or similar that's annoying, but the conversion back into a Haskell value)
03:01:13 * ari decides to ponder this over lunch
03:09:32 <Jigboot> Why is it that when I say "nigger" in a channel that no bot autokicks me?
03:09:38 <Jigboot> Is Freenode racist or something
03:09:44 <Jigboot> I thought that hate speech was illegal!
03:12:12 <Baughn> @slap Jigboot
03:12:12 * lambdabot clobbers Jigboot with an untyped language
03:21:09 <wvl_> Hi, I'm having some problems with bracket and hGetContents. Could anyone explain the following output? (Probably has something to do with lazy IO I guess) http://pastebin.com/jbdsvgfL
03:21:11 <mauke> The paste jbdsvgfL has been copied to http://hpaste.org/48839
03:21:56 <shachaf> wvl_: Yep, lazy IO.
03:23:11 <ski> wvl_ : never `hClose' a handle you pass to `hGetContents'
03:24:39 <ski> wvl_ : `hGetContents' will close the handle itself, when you reach the end of the string (or when garbage-collecting)
03:25:40 <ski> (i don't recall what it does in case of read error, though i'd be surprised if it didn't close it then as well)
03:28:51 <wvl_> ski: Ah I see. So never close it, or just not before the last use of the content?
03:29:04 <ski> never
03:29:21 <ski> `hGetContents' will handle things itself
03:29:39 <ski> a handle can be in three states
03:29:55 <ski>  (a) open, you will need to close it later in some way
03:30:19 <ski>   (b) closed, iirc you should not try to close it again (though i might be wrong)
03:31:16 <ski>   (c) semi-closed, it's still open, but `hGetContents' (or any other similar type of operation) is already taking care of closing it later for you, when appropriate, so you should not try to close it
03:32:22 <ski> it would probably be nicer if attempting to close a semi-closed handle generated an error (in that case, you'd got that error instead of the empty string in your testing in the paste)
03:36:01 <wvl_> Ah ok, the documentation of hGetContents seem to make sense now. It says that a semi-closed handle goes to closed handle if hClose is applied to it, if an error occurs or whether the _entire_ contents are read.
03:36:24 <wvl_> Does this mean if you want to stop processing somewhere in the middle, that you should use hClose?
03:38:30 <ketil> Hm, not if it gets garbage collected?
03:41:37 <wvl_> I'm not sure, the documentation only talks about if the entire contents are read but maybe garbage collection falls under that event.
03:42:25 <wvl_> Anyways, thanks for all the explanations. :)
03:42:33 <ketil> wvl_, I think it only matters if a) you run out of file handles (i.e. work on thousands of files) or b) if you want to write or otherwise manipulate the file
03:43:35 <ketil> wvl_, I'd *expect* the handle to be closed (resources be released) if the handle is no longer accessible from live data.  But I'm not sure - I usually tend to work with at most a few files, and not care about handle lifetimes.
03:44:11 <ketil> I usually use readFile rather than handles anyway.
03:44:13 <quicksilver> mostly you should never ever use hGetContents ;)
03:44:48 <shaun> Has anyone had experience with the MsgPack project?
03:44:51 * wli somehow remembers Ketil Z. Malde.
03:45:02 <ketil> wli, from where?
03:45:37 <wli> ketil: There was an old flamewar where the Subject: line got turned into "A Reply to Ketil Z. Malde" instead of its original topic.
03:46:06 <ketil> Ah.  And here I thought it was something *I* said that was notable :-).
03:46:33 <wli> ketil: I actually think you decided the flamewar was lame and stopped posting to it very shortly after it began.
03:46:55 <ketil> Really?  Mustave been some other Ketil Z. Malde.
03:47:18 <ketil> Anyway, the Z was sorta a joke once upon a time, so it must have been some time ago.
03:47:44 <wli> Not an abbreviation for Zacharias or some such?
03:48:14 <ketil> No - I think it started when I needed a "middle initial" for the green form you fill in when travelling to the US.
03:48:48 <kstt> hello
03:51:20 <kstt> I work with a dependency graph that I want to reduce to its canonical form. Indeed, some dependencies expressed are redundant (because of transitivity). Topological sorting is not what I need, because I don't want to strictly linearise execution order. That would be a loss of information about parallelisable tasks. Do you have readings to recommand please ?
03:57:16 <ski> ketil : hm, istr you've been on usenet ..
03:57:49 <ski> (probably `comp.lang.functional' or `comp.lang.ml')
03:57:54 <dmead> hello channel
03:57:57 <dmead> how are you doing?
03:58:26 <ketil> ski: not implausible.  Used to spend more time there than was good for me.  Much like IRC and mailing lists nowadays.
03:58:47 <ketil> Ah.  Good times.
03:58:54 * ski grins
03:59:35 <hpaste> “Mukesh Tiwari” pasted “Pollard Rho” at http://hpaste.org/48840
04:02:31 <hpaste> “Mukesh Tiwari” annotated “Pollard Rho” with “Pollard Rho (annotation)” at http://hpaste.org/48840#a48841
04:15:13 <keep_learning> could some one please tell me why this code is giving compiling error. http://hpaste.org/48840
04:15:25 <keep_learning> *compiler error
04:16:57 <gwern> > 1++1
04:16:58 <lambdabot>   Ambiguous type variable `a' in the constraints:
04:16:58 <lambdabot>    `Data.Monoid.Monoid a'
04:16:58 <lambdabot>  ...
04:17:27 <mekeor> > 1+1
04:17:28 <lambdabot>   2
04:17:33 <mekeor> > [1]++[1]
04:17:37 <lambdabot>   mueval-core: Time limit exceeded
04:17:48 <gwern> > [1] ++ [1]
04:17:50 <lambdabot>   [1,1]
04:18:08 <mekeor> ??
04:18:36 <nicoo> wat ?
04:18:53 <nicoo> @slap lambdabot
04:18:53 * lambdabot beats up lambdabot
04:19:38 <nicoo> > (++)
04:19:39 <lambdabot>   Overlapping instances for GHC.Show.Show (m -> m -> m)
04:19:39 <lambdabot>    arising from a use...
04:20:19 <ari> keep_learning: There's a couple of bits in factor that need changing
04:20:59 <ari> keep_learning: I assume it's meant to be an IO action returning a list of integers? [IO Integer] is a list of IO actions returning integers
04:21:10 <nicoo> @bf +[]
04:21:15 <lambdabot>  Done.
04:21:23 <nicoo> ?
04:21:47 <nicoo> @bf +[>+]
04:21:48 <lambdabot>  Done.
04:23:03 <Baughn> keep_learning: Additionally, your indentation needs work. In particular the proper style for if is "if foo\n  then bar\n  else baz"
04:23:15 <Baughn> (Assuming it doesn't fit on a single line)
04:23:38 <gwern> keep_learning: you realize the last line is the problem, yes?
04:23:50 <gwern> or... not
04:23:52 <gwern> shoot
04:24:01 <keep_learning> gwern:  nop
04:24:16 <keep_learning> ari : yes
04:24:26 <jsaacmk> is the recommended tab length 2 spaces for haskell?
04:24:42 <Baughn> In the sense that it's what haskell-mode does, yes
04:25:05 <keep_learning> ari: although  i changed it a bit and its working but now IO [Integer] not [IO Integer ]
04:25:20 <keep_learning> gwern: could you tell more about last  line
04:25:26 <gwern> ok, that's a pretty subtle error. no wonder you always have IO on the outside
04:25:55 <keep_learning> actually i tried [ return 3 ] ++ [return 5 ] on ghci
04:26:06 <keep_learning> [return 5 ] + [return 3 ]
04:26:12 <Baughn> > [return 3] :: [[Int]]
04:26:13 <lambdabot>   [[3]]
04:26:25 <Baughn> Keep in mind, there's more than one 'return'. The one there isn't IO.
04:26:55 <keep_learning> gwern: ok , now i got it
04:27:01 <keep_learning> gwern: last line is problem
04:27:01 <gwern> Baughn: yes, only after some pondering did it occur to me that it was objecting to the perfectly sensible IO Integer value because that was only *one* monad wrapper...
04:27:11 <nicoo> > [return 5 ] + [return 3 ]
04:27:12 <lambdabot>   No instance for (GHC.Num.Num [m t])
04:27:12 <lambdabot>    arising from a use of `e_153' at <in...
04:27:16 <nicoo> > [return 5 ] ++ [return 3 ]
04:27:17 <lambdabot>   No instance for (GHC.Show.Show (m t))
04:27:17 <lambdabot>    arising from a use of `M5516780046...
04:27:28 <gwern> (for a few minutes there I thought I had gone stupid since I couldn't isolate the problem)
04:27:30 <keep_learning> <interactive>:1:1:     Ambiguous type variable `m' in the constraint:       `Monad m' arising from a use of `return' at <interactive>:1:1-8     Probable fix: add a type signature that fixes these type variable(s)
04:27:32 <Baughn> > [return 5] ++ [return 3] :: [[Int]]
04:27:33 <lambdabot>   [[5],[3]]
04:27:37 <ion> pure 5 ++ pure 3 :: Maybe Integer
04:27:39 <ion> > pure 5 ++ pure 3 :: Maybe Integer
04:27:40 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Integer.Type.Integer)
04:27:40 <lambdabot>    arising fr...
04:33:51 <sannysanoff> hello gentlemen
04:34:46 <sannysanoff> I am trying to enable -hr (retainer profiling, part of heap profiling), and get .prof file with 0 bytes size. Manual says, that the file must contain retainer graph information.
04:35:08 <sannysanoff> I compile my program like that: ghc --make A.hs -prof -auto-all -caf-all
04:35:22 <sannysanoff> and run like that: ./A +RTS -hr
04:35:42 <sannysanoff> after program runs (10 seconds), I receive almost empty .hp file and zero-size .prof file.
04:35:45 <sannysanoff> why could that be?
04:36:37 <Baughn> sannysanoff: For giggles, try adding -fforce-recomp to the ghc command line
04:37:08 <Baughn> It doesn't recompile just because you change compilation flags, without that one
04:37:42 <sannysanoff> no difference, I accounted that already.
04:38:46 <sannysanoff> ghc 6.12.3, 7.0.4 the same. I suspect, I missing something very important ;)
04:40:05 <sannysanoff> time and allocation profile work ok, i receive .prof file filled with statistics.
04:46:41 <sannysanoff> is .hp file filled during program execution or after?
04:49:49 <quicksilver> during, if I remember correctly.
04:51:57 <hpaste> chrisdone pasted “xmonad” at http://hpaste.org/48842
04:53:16 <merijn> dankna: Ping?
05:01:17 <dankna> merijn: hi!
05:02:42 <merijn> Did you ever manage to solve the compile issue with Te?
05:03:23 <dankna> ah, no, not yet, but I reproduce it fine.  I've been working on the other project the past couple days.
05:03:35 <dankna> so it's a real bug, bitrot in my Cabal patches, and I need to fix it
05:06:38 <merijn> ok. Well, let me know if you do fix it or need some help got some spare time again now. (Or rather, the stuff I should be working on is also broken and I need something to do during the eternally lasting compile runs :p)
05:07:02 <dankna> absolutely!  hahah
05:07:12 <dankna> I'll hopefully get to it today and ping you when it's fixed
05:09:13 <dankna> and thanks again for your interest!  it's great to know that people are watching what I'm doing
05:19:23 <harlekin> Hi. I'm trying to get happstack, happstack-heist and happstack-auth working. But I cannot find versions of all three packages which are compatible.
05:19:43 <harlekin> I am using Gentoo with the Haskell overlay enabled. Could you recommend which versions I should try?
05:19:52 <Lemmih> harlekin: Try cabal-install.
05:20:20 <harlekin> That'd be an option. But I don't find cabal-install and the haskell overlay work well together.
05:20:30 <mekeor> harlekin: also join #gentoo-haskell :)
05:21:01 <harlekin> Should one use emerge + cabal-install or should I remove all packages I installed with emerge and use cabal-install alone?
05:21:36 <mekeor> again, guys in #gentoo-haskell know better :) they are more familar with the emerge-package-manager, for sure :)
05:21:47 <harlekin> Okay. I'll try there. Thanks.
05:40:35 <parcs> harlekin: use the package manager to install the HP and cabal-install to locally install everything else
05:45:01 <parcs> oh and the package manager for actual applications and their dependencies
05:45:44 <parcs> e.g xmonad
05:48:58 <harlekin> parcs: Isn't that unclean? I fear of having duplicate packages hanging around with that approach.
05:49:06 <harlekin> However, I'll try this in case I don't get it working with emerge.
05:54:51 <parcs> no, ghc recognizes global and local packages the same
05:55:45 <Jafet> SICP recommends doing the latter before ever using cabal-install
05:55:55 <Jafet> Perhaps emerge is better-behaved than apt, though
05:56:16 <Twey> SICP mentions cabal-install?
05:56:24 <Jafet> At least, the jen2-ers claim it is.
05:56:32 <Jafet> @where sicp
05:56:32 <lambdabot> The Wizard book : "Structure and Interpretation of Computer Programs" at <http://mitpress.mit.edu/sicp/> by Hal Abelson,Gerald Jay Sussman with Julie Sussman, videos at <http://swiss.csail.mit.edu/
05:56:32 <lambdabot> classes/6.001/abelson-sussman-lectures/>
05:56:39 <Jafet> Nope
05:57:01 <Jafet> http://www.vex.net/~trebla/haskell/sicp.xhtml
05:57:33 <Twey> Oh.
05:57:34 <Twey> Heh.
05:57:53 <Twey> Irritating :þ
06:10:56 * hackagebot yesod-core 0.8.3 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-0.8.3 (MichaelSnoyman)
07:07:28 <harlekin> @pl (\n s -> show n ++ ":" ++ s)
07:07:28 <lambdabot> (. (':' :)) . (++) . show
07:07:46 <harlekin> yikes! Looks friendly though...
07:07:50 <Ke> are there proper specs for hIsEof in use with sockets
07:08:01 <harlekin> @pl (\n s -> n ++ ":" ++ s)
07:08:01 <lambdabot> (. (':' :)) . (++)
07:13:35 <djahandarie> harlekin, there is a generalized version of that
07:13:49 <djahandarie> > intercalate ":" ["n", "s"]
07:13:50 <lambdabot>   "n:s"
07:16:53 <sm> morning all
07:17:14 <sm> how *do* you get ghc 7.x for mac osx 10.5 ? build from source ?
07:17:43 <nicoo> sm: you use a _real_ OS </troll>
07:17:50 * nicoo hides
07:18:02 <trygvis> sm: let me know if you figure it out
07:18:11 <merijn> You have to build from source, yes
07:18:23 <sm> ok, thanks
07:18:30 <merijn> I don't know if it compiles as-is, though
07:20:33 <quicksilver> in principle it should be routine if you have a working GHC 6.12
07:20:39 <quicksilver> I've not done it though.
07:22:53 <harlekin> djahandarie: thanks. That's better. :)
07:35:05 <Tomsik> It's funny how nicely-suited Haskell is for writing software synths
07:35:18 <Tomsik> without any DSL stuff at all
07:41:37 <trygvis> what is "software synth"?
07:43:05 <nicoo> trygvis: software synthesis, I would say
07:43:33 <zygoloid> possibly a software (possibly MIDI) synthesizer
07:43:58 <trygvis> zygoloid: that's what I would guess, but it didn't make much sense in #haskell :)
07:51:06 <sm> I'm playing with cabal install --reinstall --upgrade-dependencies world --dry . It says "cannot configure hint-0.3.3.2. It requires ghc >6.6". I have ghc-6.12.3 installed, no broken packages, and -v3 doesn't explain further. Any ideas ?
07:51:33 <sm> I mean, as to why it does that ?
07:52:15 <dcoutts> sm: is the ghc package registered? ghc-pkg list ghc
07:52:31 <sm> dcoutts: yes, ghc-6.12.3 is listed
07:54:09 <sm> details: https://gist.github.com/3332d9218e0b2665a119
07:56:15 <dcoutts> sm: I'm afraid I don't know, cabal looks like it thinks that the ghc package is not registered or is broken
07:56:21 <dcoutts> but ghc-pkg doesn't seem to think it's broken
07:56:44 <sm> dcoutts: first time I've stumped you! 8-)
07:56:45 <monochrom> --user Cabal-1.10.2.0 shadows --global Cabal-1.8.0.6, therefore ghc is unusable. type in "ghc -v" to see and be horrified, be very horrified
07:56:58 <monochrom> err, sorry, no
07:57:42 <sm> monochrom: hmm, but you're right, ghc -v is a bit horrifying
07:57:57 <dcoutts> sm: oh, one possibility actually, you've got template-haskell-2.4.0.1 registered in the user db
07:58:00 <monochrom> but "ghc -v" is a good check anyway. supersedes all your "ghc-pkg check" and "cabal blah -vvvvv" and whatnot
07:58:05 <copumpkin> preflex: seen dons
07:58:06 <preflex>  dons was last seen on #haskell 7 days, 15 hours, 9 minutes and 39 seconds ago, saying: tommd: i manually ran it a couple of times, after the captcha was added
07:58:09 <copumpkin> wow
07:58:20 <copumpkin> is that a donsless record?
07:58:36 <dcoutts> sm: ghc-pkg knows that's a different instance from the global template-haskell-2.4.0.1 that the ghc package depends on, however cabal does not know that (it doesn't grok multiple instances of the same version)
07:59:41 <sm> interesting, interesting.. I didn't know ghc -v was a more thorough check than ghc-pkg check, or the above.. I'll try removing that duplicate template-haskell
07:59:51 <monochrom> yeah, template-haskell in both --user and --global kills it. --user shadows --global
08:00:46 <sm> wow, that was painless and now ghc -v is much happier. Still prints a bunch of stuff but it doesn't seem angry
08:01:07 * hackagebot yesod-form 0.2.0.1 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-0.2.0.1 (MichaelSnoyman)
08:01:20 <sm> same result with the cabal install command though
08:02:17 <sm> https://gist.github.com/3332d9218e0b2665a119#gistcomment-39451
08:02:17 <monochrom> it all began with --user pretty-1.0.1.2
08:03:21 <Lemon> is there a relationship between implicit parameters and typeclass instances?
08:03:45 <monochrom> this is a pigeon drop con in my http://www.vex.net/~trebla/haskell/sicp.xhtml#pigeon
08:04:08 * hackagebot yesod-auth 0.6.1 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.6.1 (MichaelSnoyman)
08:04:14 <sm> monochrom: what makes you pinpoint pretty ?
08:04:32 <Lemon> because the former seems like a way to implement the latter if you make the implicit parameter somehow "choose" among a set of dictionaries and use the one that implements the typeclass with the required types.
08:05:15 <quicksilver> Lemon: yes.
08:05:36 <Lemon> quiccker, wait what really?
08:05:37 <quicksilver> Lemon: implicit parameters were implemented because they could share the same machinery as GHC's type class mechanism.
08:05:38 <monochrom> template-haskell depends on pretty
08:05:56 <quicksilver> so yes, they do have something in common in terms of compiler operations.
08:06:28 <quicksilver> however, typeclasses have stood the test of time as a useful idea, whilst implicit parameters are a tangled bloody mess which no rightminded person should use.
08:06:37 <sm> I'd love it if cabal could just explain some of these situations more clearly
08:06:53 <sm> that would be quite a valuable feature
08:07:03 <monochrom> and see my article on why cabal-install would build you a --user template-haskell-2.4.0.1 when you already have it in --global
08:07:50 <sm> will do. Thanks dcoutts & monochrom, back in a bit
08:31:51 <identity> Two days till my trip of enlightenment, from which I expect to return a zen master of haskell.
08:31:57 <identity> 4 days in the sun with beer in hand
08:33:48 <Tomsik> Beer? Rum is the new beer.
08:34:24 <identity> Tomsik: 50 liters of beer for .. eh
08:34:34 <identity> > 250 / 7.5
08:34:34 <iratsu> what is a more idiomatic way to write map (\x -> let Left y = x in y) . (filter (either (\x -> True) (\x -> False)))?
08:34:35 <lambdabot>   33.333333333333336
08:34:39 <identity> 33 euros
08:35:17 <Tomsik> Well, personally I find beer bad for the digestive system
08:35:30 <Tomsik> The day after, I mean
08:36:29 <copumpkin> iratsu: hum
08:36:31 <sipa> @pl (\x -> let Left y = x in y) . (filter (either (\x -> True) (\x -> False___
08:36:31 <lambdabot> (line 1, column 75):
08:36:31 <lambdabot> unexpected end of input
08:36:31 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
08:36:37 <ion> concatMap (either (:[]) (const []))
08:36:46 <copumpkin> does that even typecheck?
08:36:48 <copumpkin> :t  (\x -> let Left y = x in y) . (filter (either (\x -> True) (\x -> False)))
08:36:49 <sipa> @pl (\x -> let Left y = x in y) . (filter (either (\x -> True) (\x -> False)))
08:36:49 <lambdabot> const y
08:36:49 <lambdabot>     Couldn't match expected type `Either t t1'
08:36:49 <lambdabot>            against inferred type `[Either a b]'
08:36:49 <lambdabot>       Expected type: [Either a b] -> Either t t1
08:36:50 <identity> Tomsik: Ah, yes. The post-stupor shits. The hangover indigestion.
08:36:50 <quicksilver> iratsu: [x | Left x <- list]
08:36:51 <identity> etc
08:36:54 <quicksilver> iratsu: I think.
08:37:09 <quicksilver> if I understood your intent.
08:37:15 <Jafet> @undo [x | Left x <- xs]
08:37:15 <lambdabot> concatMap (\ a -> case a of { Left x -> [x]; _ -> []}) xs
08:37:37 <copumpkin> :t lefts
08:37:38 <lambdabot> forall a b. [Either a b] -> [a]
08:37:44 <quicksilver> or that, indeed.
08:37:52 <quicksilver> but the lift comprehension syntax is a good one to know
08:37:58 <quicksilver> for pattern matching through lists.
08:37:58 <copumpkin> yeah
08:38:31 <ion> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-Either.html#lefts
08:39:03 <Jafet> :t \xs -> concat $ do Left x <- xs; return x
08:39:04 <lambdabot> forall a t. [Either [a] t] -> [a]
08:39:28 <Jafet> :t concatMap (\a -> do Left x <- a; return x)
08:39:29 <lambdabot> forall b t. [[Either b t]] -> [b]
08:39:36 <ion> :t concatMap (either (:[]) (const []))
08:39:37 <lambdabot> forall a b. [Either a b] -> [a]
08:40:04 <Jafet> Now I'm wondering what my code actually means
08:40:15 <copumpkin> :t concatMap (either pure (pure []))
08:40:16 <lambdabot> forall a b. [Either a b] -> [a]
08:40:21 <copumpkin> embrace purity!
08:40:55 <ion> Nice use of two separate implementations of pure. :-)
08:41:00 <sipa> :t pure
08:41:00 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
09:02:38 <quicksilver> monochrom++ # careful deconstruction of complex cabal situations.
09:02:52 <quicksilver> dcoutts: why is it so incredibly hard to write a package installation tool? ;)
09:02:58 <monochrom> thanks
09:03:12 <dcoutts> quicksilver: because it's NP complete :-)
09:04:25 <quicksilver> dcoutts: not quite the aspect of it I was talking about, though.
09:04:35 <dcoutts> no you're right
09:04:36 <Jafet> Probabilistic NP: breaking with a certain probability each time you try to install something else
09:04:41 <quicksilver> it's more the horrific battle between distro versions and global versions and local versions
09:04:51 <quicksilver> not that other languages do particularly better.
09:05:18 <dcoutts> quicksilver: it's because it was not recognised early enough that to handle multiple versions of a package properly you actually need to handle multiple instances of the same package
09:05:20 <quicksilver> but often with languages which install as source you can use a network of overlapping versions and not have errors.
09:05:27 <dcoutts> otherwise there are some pretty bad corner cases
09:05:47 <quicksilver> e.g. perl has the same corner cases *in theory* but in practice your code will run and you may well be fine.
09:05:52 <arw__> some do, in combination with certain distributions. e.g. debian and dh-make-perl --cpan works very well.
09:05:53 <dcoutts> quicksilver: and we're currently half way to supporting multiple instances
09:06:03 <monochrom> the problem is harder with ghc because of unusual ABI sensitivity
09:06:16 <quicksilver> monochrom: which is partly simply because it's compiled.
09:06:27 <dcoutts> quicksilver: we do have a new solver in the works that understands multiple instances (the current solver does not)
09:06:35 <quicksilver> monochrom: so that problem ruby gems and cpan don't really suffer.
09:06:38 <quicksilver> dcoutts: that's great to hear.
09:06:46 <quicksilver> arw__: yes, agreed.
09:06:51 <dcoutts> quicksilver: http://darcs.haskell.org/cabal-branches/cabal-modular-solver/
09:07:07 <dcoutts> and it's generally smarter in various ways
09:07:33 <dcoutts> we'll write about it in more detail in upcomming blog posts
09:07:40 <monochrom> compiled c doesn't suffer either because tradition doesn't do cross-module optimization. ghc does
09:08:32 <arw__> quicksilver: but of course even that neither solves the multiple-instance problem nor the compilation problem, because it usually just doesn't do those
09:09:19 <monochrom> so, for example, libc.so.6.0.2 is a fine drop-in replacement for libc.so.6.0.1, but base-4.2.0.2 is not a drop-in replacement for base-4.2.0.1. pain ensues
09:09:21 <quicksilver> monochrom: compiled C libraries try very hard not to change their ABI, basically.
09:09:28 <monochrom> yes
09:09:44 <quicksilver> monochrom: also, compiled C libraries have an established mechanism for simultaneous install.
09:09:47 <quicksilver> HOWEVER
09:09:54 <monochrom> basically that rules out much of cross-module optimizations, inlining, fusion...
09:09:56 <quicksilver> compiled C is, in fact, just as broken when it comes to diamond dependencies.
09:10:36 <monochrom> c programmers don't care about inlining fusion etc because they fuse and deforest by hand already.
09:10:58 <quicksilver> but diamond dependencies aren't very common in C libraries
09:11:06 <quicksilver> as C library authors do not trust other C library authors.
09:11:08 <monochrom> bytestring compiled the traditional c way will never fly
09:11:11 <quicksilver> however, gnome suffers from it badly.
09:11:56 <quicksilver> i helped debian with the first ever big GNOME library transition (10+ years ago) and that was a nightmare of segfaults because of diamond dependencies and similar.
09:12:59 <monochrom> why does diamond dependency still hurt, despite pinned ABI?
09:13:40 <quicksilver> monochrom: because the pinned ABI doesn't include subordinate ABIs.
09:14:03 <quicksilver> if foo.so.3 and bar.so.3 both link to baz.so
09:14:10 <quicksilver> but different versions of baz.so
09:14:14 <quicksilver> then you get a segfault
09:14:23 <quicksilver> unless they use private symbols
09:14:45 <quicksilver> ...but if they use private symbols then they can't so easily share stuff that involves things from baz
09:16:12 <monochrom> alright, but one should just have a unique baz.so
09:16:39 <quicksilver> that was shorthand
09:16:43 <quicksilver> I mean if foo.so.3 links to baz.so.2
09:16:52 <quicksilver> and bar.so.3 links to baz.so.3
09:16:58 <quicksilver> that's a segfault.
09:17:14 <quicksilver> or, it was back then. I know that there are new linker modes and things.
09:17:16 * hackagebot bitstream 0.2 - Fast, packed, strict and lazy bit streams with stream fusion  http://hackage.haskell.org/package/bitstream-0.2 (MasatakeDaimon)
09:17:55 <monochrom> I guess distro people just try to avoid that these days
09:19:03 <quicksilver> right. that's what we were doing. We were distro people ;)
09:19:13 <quicksilver> I just point out that naming your own ABI isn't enough
09:19:24 <quicksilver> typically your ABI is the sum of the ABIs of every library you link to.
09:19:37 <quicksilver> for an extreme but important example
09:19:54 <quicksilver> you certainly cannot load one library which links to libc.so.5 and another which links to libc.so.6 into the same executable.
09:19:56 <dylukes> hey btw
09:19:57 <zygoloid> "this abstraction leaks". :(
09:20:02 <dylukes> does anyone still want google+ invites?
09:20:19 <ion> I want to be able to use it with a Google Apps account.
09:20:24 <quicksilver> so, haskell and JaffaCake in particular recognise this and the ABI hash does account for all your dependents.
09:20:37 <quicksilver> but that makes it seem like haskell has invented a problem, since other people just ignore it :P
09:22:53 <monochrom> well, my practice with ghc packages is to have unique versions too
09:23:00 <copumpkin> dylukes: I think it's public now
09:24:05 <dylukes> invites are public it seesm
09:27:10 <Peaker> I was getting myself confused with ListT for a while, until I realized I just needed ParsecT of [] and no ListT anywhere
09:29:20 <Peaker> What's the nicest way of doing a non-deterministic/ambiguous parse of the syntax   EXPR = EXPR op EXPR ; op = * | +     such that op is left/right associative, ambiguously?
09:29:40 <dylukes> How do you even do ambiguous parsing?
09:29:43 <Peaker> oops,  EXPR may also be  TERM(digits)
09:29:59 <Peaker> dylukes: I use ParsecT [], then I can lift list actions (non-determinism)
09:30:11 <Peaker> and my parsing "splits" into different possibilities
09:30:19 <dylukes> Ah I see.
09:30:36 <dylukes> So what do you do in the end with all of the possibilities?
09:31:04 <Peaker> I nub the duplicates (since l/r-assoc is same for a+b)
09:31:13 <Peaker> It's not for real-world use -- just as a riddle from a friend
09:31:42 <Peaker> Basically he's messing with Earley parse algorithms -- and was wondering how to represent ambiguous parsing recursions
09:32:04 <dylukes> you should do it in c++ instead *troll face*
09:32:12 <dylukes> Haskell's not well suited to these things.
09:49:06 <monochrom> parsec discourages ambiguity. readp (comes with ghc) is designed for multiple parsing answers
09:52:20 * hackagebot llvm-extra 0.2.0.2 - Utility functions for the llvm interface  http://hackage.haskell.org/package/llvm-extra-0.2.0.2 (HenningThielemann)
10:00:49 * edwardk waves hello.
10:04:21 <saml> hi edwardk lonely?
10:04:37 <edwardk> terribly ;)
10:05:33 <saml> open up emacs and code more. wash thy loneliness away into the type system abyss
10:05:56 <copumpkin> if edwardk coded anymore I think github would collapse
10:05:59 <edwardk> with you up to the emacs part. ;)
10:06:06 <edwardk> copumpkin: rings are coming along nicely
10:06:12 <copumpkin> excellent
10:06:15 <copumpkin> I like what I see so far
10:06:31 <edwardk> went through with dolio and decided to refactor some bits
10:06:36 <copumpkin> (except maybe for the additive/multiplicative distinction, but I can see why you want that)
10:06:55 <copumpkin> ah
10:07:02 <edwardk> you need it or you can't build enough of the structures without repeating yourself over and over
10:07:17 <edwardk> that way lies the hell of the numerical prelude
10:07:19 <copumpkin> edwardk: I demand that you put something like fail into random algebraic structures
10:07:27 <copumpkin> maybe a fromString :: String -> a
10:07:29 <edwardk> =)
10:08:06 <edwardk> the most controversial thing is the use of semiring over just semigroups
10:08:17 <edwardk> but otherwise the nomenclature in it is pretty standard
10:08:39 <copumpkin> class Semiring a where (+) :: a -> a -> a; (*) :: a -> a -> a; zero :: a; one :: a; fromStringCombineJustToPissYouOff :: String -> a -> a
10:08:59 <edwardk> the alternatives are all worse, coz that would become a ringoid
10:09:08 <copumpkin> ah
10:09:29 <edwardk> also because i'm playing around with such weak structures, i have to talk about things like OrderedRig rather than OrderedIntegralDomain ;)
10:09:52 <djahandarie> We get rigs?
10:09:57 <edwardk> so some classes youd expect wind up never getting names
10:10:05 <edwardk> Rigs and Rngs
10:13:22 * hackagebot illuminate 0.1 - A fast syntax highlighting library built with alex.  http://hackage.haskell.org/package/illuminate-0.1 (JohnMacFarlane)
10:15:33 <brett> I'm trying to compile a pretty simple hsc file, but getting an error that my filename doesn't match the module name, which it does
10:15:42 <brett> https://gist.github.com/1072265
10:19:19 <Vic> Hello
10:20:35 <Saizan> brett: you should show the file too
10:21:12 <djahandarie> :O A fast syntax highlighter?!
10:21:33 <djahandarie> Syntax highlighting speed has been a problem for me in the past so this is cool :o
10:21:42 <Saizan> really?
10:21:56 <Vic> Hello what does everyone here use for programming in haskell
10:22:19 <Nimatek> A laptop.
10:22:22 <djahandarie> Saizan, well, yes, for an application where I wanted to syntax highlight a bunch of stuff :p
10:22:41 <djahandarie> Vic, if you're asking about coding environments, I use emacs with haskell-mode.
10:23:26 <Vic> Oh nice dj, i'm new to haskell, so I was just wondering what most people use and why
10:23:59 <dbpatterson> trying to install the  current platform from source because the bug that was fixed in ghc 7.0.4 made the binary platform (based on 7.0.3) not work and I'm getting an error that happy cannot install because it needs the execuable happy.
10:23:59 <dbpatterson> someone (http://web.archiveorange.com/archive/v/2Kx35xoXFrBVPjF2ghtQ ) made it seem like this is a problem with happy, but I can't believe that given that this is the platform
10:24:04 <dbpatterson> any ideas?
10:24:23 * ziman uses vim + edwardk's haskell cuteness (for displaying -> as → etc.)
10:29:10 <Saizan> dbpatterson: in principle you need happy to preprocess some of happy's sources, but the source tarball should contain the already preprocessed files so that you can bootstrap it
10:30:49 <dbpatterson> Saizan: ahh. so my make clean messed everything up. thanks!
10:47:26 <lpsmith> Doh, unsafePerformIO really is unsafe.
10:47:40 <ion> REALLY?
10:49:16 <lpsmith> Yeah, I just happened to spot a bug relating to one of my few uses of it when I was mucking around in the same module with unrelated code.   It hadn't manifested itself in testing until then.
10:51:09 <lpsmith> I was using the Json package to read in some records from a file,  and the records have a field that is an MVar,  so I was using unsafePerformIO to create the MVar,  as otherwise I couldn't use the Json package
10:52:00 <lpsmith> and I saw that and thought "I bet GHC is let-floating that out so that all records share one MVar"
10:52:02 <identity> lpsmith: You could've used it in an IO computation, could you not?
10:52:41 <lpsmith> and sure enough it was.   But we hadn't been testing with files with more than one record :-P
10:53:34 <lpsmith> identity: you'd have to clarify what you mean
10:53:53 <lpsmith> I'm using the MVar in an honest-to-goodness IO computation,  always
10:54:09 <lpsmith> just the creation I had to get around because the parsing package didn't support IO effects
10:55:26 <identity> lpsmith: Aah, I understand
10:55:35 <identity> don't know the pacakage etc
10:56:11 <lpsmith> So I suppose the "correct" answer is to either roll a Json parser that allows you to thread a monadic computation through the parser,  or create an intermediate data structure that doesn't have the MVar that gets transformed into one that does
10:56:41 <lpsmith> (with the transformation happening in the IO monad outside the parser,  of course.)
10:56:48 <identity> lpsmith: what library is this?
10:56:56 <saml> public library
10:56:56 <lpsmith> a private library
10:57:01 <identity> aah
10:57:15 <lpsmith> oh, the json library?
10:57:24 <lpsmith> http://hackage.haskell.org/package/json
10:57:33 <identity> saml: package in the local vernacular :P
10:57:34 <identity> ah
10:59:22 <lpsmith> So basically I ended writing    unsafePerformIO (newMVar (if x == x then val else undefined))  to create an artificial bit of work that has to be performed so GHC can't go about let-floating the expression
11:00:03 <lpsmith> (val is a constant,  x is another part of the record,  and thus input dependent,  just to be extra "safe")
11:00:10 <d7> I've been struggling to understand iteratees lately
11:00:13 <d7> but man is it paying off.
11:00:23 <d7> This code was really easy to write once I had the enumerator done: https://github.com/KirinDave/redis-conduit/blob/master/Tap/Redis.hs
11:00:24 <lpsmith> d7: how so?
11:00:33 <d7> Very happy with how that's shaping up.
11:00:35 <copumpkin> what if x is an IEEE float/double? :D
11:00:50 <identity> d7: Yeah, I started reading about them recently and rewrote some stuff to use them
11:00:54 <identity> good shizzle
11:01:17 <d7> identity: Data.Enumerator's docs really need help tho. Understanding what's now the expected style for writing iteratees and enumerators was not easy.
11:01:32 <identity> d7: True. I found some tutorial, though
11:01:35 <d7> Reading the code is an absolute must.
11:01:37 <identity> which helped me along
11:01:41 <d7> Which one?
11:01:43 <lpsmith> most IEEE floats equal themselves :)
11:01:48 <identity> let me see, sec
11:02:00 <identity> I was on another computer, in a country far far away
11:02:03 <copumpkin> lpsmith: yeah, but not all!
11:02:13 <lpsmith> yeah, but that was a mistake :)
11:02:27 <copumpkin> I agree, but that's how it is :(
11:03:00 <lpsmith> is there anything other than NaN that doesn't equal itself?
11:03:27 <copumpkin> nope
11:03:31 <copumpkin> but there's a lot of NaNs :)
11:03:44 <identity> d7: I can't find it, but http://cdsmith.wordpress.com/2010/05/23/iteratees-step-by-step-part-1/ looks like a better one, step by step etc
11:03:53 <lpsmith> that is true,  probably one of the most common floats outside of 0 and 1
11:04:34 <identity> oh, d7, http://www.mew.org/~kazu/proj/enumerator/ this is the one, actually
11:04:37 <identity> on Data.Enumerator
11:05:05 <d7> identity: Ty
11:05:13 <lpsmith> although you do have -0 == 0
11:05:30 <d7> I feel like once I get this I want to share it with everyone. Seriously; this model is fantastic for most types of IO I do.
11:05:35 <lpsmith> but 1 / -0 /=  1 / 0
11:05:53 <ion> The yesod book has a nice enumerators tutorial. Note that the sections are *still* in the wrong order. :-P
11:05:56 <identity> When I discovered them I was writing some server application using lazy I/O and need a better way to do error handling.. Found iteratees and so on, and then when I read something by Oleg that basically said "writing a server application using lazy I/O is unprofessional"
11:06:25 <identity> Having the Chuck Norris of functional programming (in haskell, anyway) indirectly judge your application like that made me a sad panda
11:07:04 <d7> identity: Although truth be told, many professionals do terrible things int he scope of their work
11:07:18 <identity> d7: indeed
11:07:37 <identity> But the term "professional" is .. well, abused
11:07:47 <identity> 1. get degree 2. write shitty code 3. hide behind degree
11:08:39 <d7> True Story.
11:08:58 <d7> Epilogue: Call anyone who tries to get better at their job "overly academic"
11:09:11 <kmc> yep
11:09:26 <kmc> "practical programmers" can be strongly anti-intellectual
11:10:40 <identity> That's why I'm trying to avoid just going for some "software development" education personally. That and because I hate writing requirement specs and making diagrams and whatever else
11:10:40 <sm__> d7: you saw http://okmij.org/ftp/Streams.html of course ?
11:11:42 <kmc> well "requirement specs" and "diagrams" are often bullshit management boilerplate
11:11:44 <copumpkin> kmc: here in the trenches we use java and love it
11:11:48 <copumpkin> kmc: and c++
11:11:55 <kmc> but it is legit useful to write down what you're going to do before you do it
11:11:55 <copumpkin> none of that newfangled bullcrap
11:11:58 <kmc> and maybe to use some pictures
11:12:02 <d7> sm__: Yeah, but Data.Enumerator is subtly different.
11:12:03 <kmc> copumpkin, Java is webscale
11:12:11 <identity> kmc: Of course
11:12:28 <kmc> the problem is when some non-developer says "you must write it down X way"
11:12:37 <kmc> probably because nobody was writing anything down before
11:12:53 <thoughtpolice> @faq can haskell webscale as good as java
11:12:53 <lambdabot> The answer is: Yes! Haskell can do that.
11:13:27 <kmc> @vixen Is Haskell webscale?!?
11:13:28 <lambdabot> Ooh, functional programmers are so hot!
11:13:33 * geheimdienst broadly agrees but still thinks rigid boilerplate documentation is better than no documentation
11:13:34 <kmc> @nixon Is Haskell webscale?!?
11:13:34 <lambdabot> I don't want to see this country to go that way.  You know what happened to the Greeks.  Homosexuality destroyed them. Sure, Aristotle was a homo, we all know that, so was Socrates.
11:13:44 <thoughtpolice> @protontorpedo haskell. webscale. what do you think?
11:13:44 <lambdabot> treid comon lisp. ansi common lisp bok by graham. it sucked
11:14:02 <identity> kmc: In general, a person not educated in X telling workers that are educated in X how to do their job is always bad. They tend to know so little about the stuff they're talking about they can't possibly grasp how little they know and thus don't understand the workers when they tell them that doing some things will be impractical/difficult/impossible
11:14:10 <identity> afaik there's even a fallacy for that whole concept
11:14:14 <identity> not knowing how little you know
11:14:22 <kmc> dunning-kruger effect?
11:14:35 <identity> I think so
11:14:44 <identity> yes
11:14:44 <d7> Ha, that's not a logical fallacy. "_
11:14:55 <d7> That's just a set of experiments. Were they even replicated?
11:14:58 <copumpkin> > let 2 + 2 = 5 in 2 + 2 -- high thoughtpolice
11:14:59 <lambdabot>   5
11:15:10 <identity> d7: I guess "fallacy" was the wrong term
11:15:13 <thoughtpolice> > let freedom = "slavery" in freedom
11:15:14 <lambdabot>   "slavery"
11:15:17 <identity> but yeah, there's a 'known effect'
11:15:18 <thoughtpolice> WELL THAT SETTLES IT
11:15:24 <identity> I was pleased to find out
11:15:25 <kmc> there's an associated cognitive bias
11:15:31 <kmc> which are often named "fallacies"
11:15:31 <copumpkin> wow, I spelled "hi" as "high"
11:15:35 <kmc> gambler's fallacy, sunk costs fallacy, etc
11:15:36 <d7> Did the DK experiments ever get replicated tho?
11:15:40 <kmc> the usage is totes legit
11:15:55 <geheimdienst> copumpkin: i read it as playing on "high 5" ...
11:15:57 <thoughtpolice> copumpkin: hi copumpkin :>
11:16:04 <geheimdienst> ... but yeah, didn't make much sense :)
11:16:13 <d7> I'm sorta thrice burned nine times shy on any sort of psy experiments these days unless they've been replicated >2
11:16:16 <copumpkin> thoughtpolice: hi thoughtpolice
11:16:19 <copumpkin> geheimdienst: hi geheimdienst
11:16:35 <asdf_> hello world
11:16:41 <geheimdienst> copumpkin: ohai copumpkin
11:16:58 <_habnabit> is there a simpler way of writing `map (\_ -> x) y` ?
11:17:07 <asdf_> who is actually listening atm?
11:17:10 <identity> hammi: map (const x) y
11:17:11 <thoughtpolice> _habnabit: map (const x)
11:17:15 <identity> eh
11:17:15 <geheimdienst> > map (const 42) [3..5]
11:17:16 <lambdabot>   [42,42,42]
11:17:21 <_habnabit> ah, const.
11:17:27 <copumpkin> you could replicate length times
11:17:29 <copumpkin> but that's not much nicer
11:17:39 <geheimdienst> not sure if that's really simpler ... matter of taste, i guess
11:17:52 <thoughtpolice> i prefer 'const' to the anonymous lambda term, i feel it's clearer
11:17:56 <thoughtpolice> that's taste though :)
11:18:10 <_habnabit> well, with the lambda, you get \_. it looks like a deck chair.
11:18:15 <copumpkin> > [3..5] >> [1]
11:18:16 <lambdabot>   [1,1,1]
11:18:16 <_habnabit> you can pretend you're relaxing instead of writing code.
11:18:16 <identity> True
11:18:18 <copumpkin> :)
11:18:27 <identity> _habnabit: It invites anyone who is reading your code to sit down and relax
11:18:35 <copumpkin> clearly >> is the way to go
11:18:40 <kmc> copumpkin++
11:18:42 <geheimdienst> funny, i think the opposite. i feel "_" more clearly indicates that an arg is being ignored
11:18:44 <identity> "Relax, bruda. Sit down and enjoy the monadic landscape. It is beautiful"
11:18:45 <copumpkin> > [1..10] *> [42]
11:18:46 <lambdabot>   [42,42,42,42,42,42,42,42,42,42]
11:18:51 <copumpkin> w00t!
11:18:52 <identity> but I still like const
11:18:56 <thoughtpolice> kHEY,
11:19:02 <copumpkin> const is too concrete
11:19:03 <thoughtpolice> damn enter key
11:19:03 <copumpkin> use pure
11:19:04 <identity> :t (>*)
11:19:04 <lambdabot> Not in scope: `>*'
11:19:06 <identity> eh
11:19:07 <copumpkin> > map (pure 42) [1..10]
11:19:08 <lambdabot>   [42,42,42,42,42,42,42,42,42,42]
11:19:09 <identity> :t (*>)
11:19:10 <copumpkin> > fmap (pure 42) [1..10]
11:19:11 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
11:19:11 <lambdabot>   [42,42,42,42,42,42,42,42,42,42]
11:19:30 <copumpkin> :t fmap (pure 42)
11:19:31 <lambdabot> forall t a (f :: * -> *). (Num t, Functor f) => f a -> f t
11:19:31 <thoughtpolice> > cycle [42]
11:19:32 <lambdabot>   [42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42...
11:19:34 <ziman> > pure 42 . [1..10]
11:19:36 <lambdabot>   [42,42,42,42,42,42,42,42,42,42]
11:19:36 <thoughtpolice> it's 42 all the way down
11:19:43 <copumpkin> > 42 . [1..10]
11:19:44 <lambdabot>   [42,42,42,42,42,42,42,42,42,42]
11:19:45 <copumpkin> :D
11:19:48 <ziman> :))
11:19:59 <thoughtpolice> control.category i assume? :P
11:20:01 <opqdonut> :D
11:20:04 <ski> no
11:20:04 <thoughtpolice> I WOULD EXPECT NOTHING LESS FROM COPUMPKIN
11:20:05 <copumpkin> caleskell
11:20:08 <thoughtpolice> oh
11:20:09 <kmc> (.) = fmap
11:20:16 <geheimdienst> thoughtpolice: i thought it's because of fmap = (.)
11:20:17 <identity> > zipWith const (cycle 42) [1..10]
11:20:17 <opqdonut> and 42 = const 42
11:20:18 <lambdabot>   No instance for (GHC.Num.Num [a])
11:20:18 <lambdabot>    arising from a use of `e_142110' at <i...
11:20:20 <identity> eh
11:20:20 <geheimdienst> er yeah ...
11:20:21 <ziman> abuse of fmap and Num :)
11:20:22 <ski> thoughtpolice : `instance Num a => Num (rho -> a)'
11:20:24 <kmc> instance (Num b) => Num (a -> b) where { fromIntegral = const . fromIntegral }
11:20:26 <ion> > (42 <$ [0..3], const 42 <$> [0..3], pure (const 42) <*> [0..3], pure 42 <* [0..3])
11:20:27 <lambdabot>   ([42,42,42,42],[42,42,42,42],[42,42,42,42],[42,42,42,42])
11:20:28 <copumpkin> ski: ooh, nice variable
11:20:29 <copumpkin> ski++
11:20:39 <thoughtpolice> ski: ah
11:20:49 <ski> copumpkin : er .. you mean `rho' ?
11:20:51 <copumpkin> > flip [1..10] 42
11:20:51 <lambdabot>   No instance for (GHC.Enum.Enum (a -> b))
11:20:52 <lambdabot>    arising from a use of `e_111042...
11:21:03 <ion> Or to obfuscate a bit:
11:21:11 <ion> > (42 <$ [0..3], pure 42 <$> [0..3], pure (pure 42) <*> [0..3], pure 42 <* [0..3]) -- :-P
11:21:12 <lambdabot>   ([42,42,42,42],[42,42,42,42],[42,42,42,42],[42,42,42,42])
11:21:12 <ski> > "foo" `flip` ($ 42)
11:21:13 <lambdabot>   Couldn't match expected type `a -> b'
11:21:13 <lambdabot>         against inferred type `GHC.Ty...
11:21:20 <identity> One question = avalanche of answers
11:21:21 <identity> lol
11:21:33 <identity> It's like farting on a very instable mountain top
11:21:37 <ziman> @quote contrapuntal
11:21:38 <identity> asking a question here.
11:21:40 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
11:21:46 * copumpkin farts back at identity 
11:22:28 <dpratt71> is there a built in function that given a list, will return True if any two consecutive elements of the list are equal?
11:22:32 <monochrom> please don't use = that way
11:22:39 <ion> habnabit: Did no-one mention <$? Perhaps i’m just not noticing. x <$ y
11:23:44 <laar> dpratt71, not that I know, but it can be easily implemented with any
11:23:50 * monochrom doesn't like the common habit of using "=" for cause-effect and using "->" for equality
11:24:13 <dpratt71> laar: ok, thanks; happy to figure it out myself if there isn't a built in function :)
11:24:16 <monochrom> it's like someone pranked you by swapping two wires in your brain
11:24:18 <_habnabit> ion, hah, nice
11:24:29 <geheimdienst> > let f xs = any (uncurry (==)) $ zip xs $ drop 1 xs in f [1,2,3,3,4]
11:24:30 <lambdabot>   True
11:24:45 <ziman> :t any .: ap (zipWith(==)) tail
11:24:45 <lambdabot>     Couldn't match expected type `a -> Bool'
11:24:46 <lambdabot>            against inferred type `Bool'
11:24:46 <lambdabot>     In the first argument of `zipWith', namely `(==)'
11:24:46 <geheimdienst> first thing that came to mind ...
11:24:51 <ion> If one question = avalanche of answers, then avalanche of answers = one question.
11:25:03 <geheimdienst> ion: avalanche jeopardy?
11:25:06 <monochrom> right, precisely the problem
11:25:23 <ion> (One reads that “one question is equal to an avalanche of answers”)
11:25:44 <ski> @type or . (zipWith (==) `ap` tail)
11:25:45 <lambdabot> forall a. (Eq a) => [a] -> Bool
11:26:41 <ski> monochrom : *nod*
11:27:22 <ski> presumably part of the problem is teaching kids that "equals" should be interpreted as "becomes"
11:27:58 <monochrom> that only explains that part of the problem
11:28:24 <ski> how "is" is used in natural language is another part
11:29:02 <monochrom> the full problem is writing "x^2 = 2x -> x+x" to mean that differentiating x^2 gives 2x, and 2x rewrites to x+x
11:29:24 <ski> hehe
11:29:34 <ion> Huh, who writes it like that?
11:29:38 <dpratt71> does this look like a reasonable definition?
11:29:39 <dpratt71> anyRepeated xs = let ys = xs `zip` (tail xs) in any (\(a,b) -> a == b) ys
11:29:53 <monochrom> some newbies in math channels wrote that
11:29:54 <ski> dpratt71 : i'd use `where' ..
11:30:17 <ski> dpratt71 :  the brackets around the `tail' call are redundant
11:30:43 <ski> dpratt71 : it is possible to rewrite `\(a,b) -> a == b' as `uncurry (==)'
11:31:14 <kmc> use 'or' and 'zipWith', not 'any' and 'zip'
11:31:27 <geheimdienst> @src or
11:31:27 <lambdabot> or    =  foldr (||) False
11:31:29 <ski> yeah, then you don't need to `uncurry'
11:31:40 <ski> @src any
11:31:41 <lambdabot> any p =  or . map p
11:31:56 <dpratt71> ski: thanks; funny,
11:32:02 <geheimdienst> i'm a little unclear why you wrote "let ys = ... in any (\...) ys"
11:32:03 <kmc> zipWith2 could also be reasonably named map2
11:32:19 <geheimdienst> map2.0
11:32:20 <kmc> er, it's just zipWith
11:32:26 <dpratt71> funny, I was wondering if uncurry would help here; maybe I'm starting to get this Haskell thing
11:32:27 <ski>   map (uncurry f) (zip as0 as1) = zipWith f as0 as1
11:32:40 <ski> (dpratt71 : funny, how ?)
11:33:05 <kmc> ski, it would be cool if lambdabot had a thing to prove identities like that
11:33:09 <dpratt71> funny how I hit enter before I meant to
11:33:10 <kmc> you'd probably have to tell it what to do induction over
11:34:17 <ski> @check \f as0 as1 -> map (uncurry f) (zip as0 as1 :: [(Bool,Bool)]) == (zipWith f as0 as1 :: [Bool])
11:34:18 <lambdabot>   Overlapping instances for GHC.Show.Show
11:34:18 <lambdabot>                              (GHC.B...
11:34:21 <ski> bah
11:36:06 <triliyn> When GHC says "can't match type 'a' with 'b'", which is the type it inferred and which is the type it expects?
11:36:50 <ski> > not ()
11:36:51 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
11:36:51 <lambdabot>         against inferred type ...
11:37:06 <ski>         against inferred type `()'
11:37:10 <dpratt71> kmc: I can't quite see how to put it together with 'or' and 'zipWith' (almost, but not quite)
11:37:21 <ski> "expected" is the one the context expected
11:37:31 <ski> "inferred" is the type computed for the expression
11:37:34 <dpratt71> kmc: oh, wait, maybe I do
11:37:42 <triliyn> Hm, that's not what mine's saying D:
11:37:42 <dpratt71> kmc: don't tell me! :)
11:38:00 <ski> triliyn : what's your saying ?
11:38:03 <triliyn> "Couldn't match type '[a0]' with '[[a0]]'"
11:38:26 <triliyn> This is GHCi if that makes a difference
11:38:32 <triliyn> Doesn't seem like it would...
11:38:54 <parcs> ski: ghc 7 uses "actual" now i think
11:38:57 <monochrom> I don't think it's useful to distinguish "inferred" and "expected"
11:39:05 <ski> (dpratt71 : hint : don't look up, the solution has already been mentioned)
11:39:17 <parcs> triliyn: is that all of it?
11:39:18 <dpratt71> ski: k, won't :)
11:39:24 <ski> monochrom : not in general, no, i think
11:39:54 <triliyn> parcs: Well, it's also telling me where the error occurs
11:40:29 <Saizan> can you paste the whole error?
11:40:36 <dpratt71> ok, now I have: or $ zipWith (==) xs (tail xs)
11:40:39 <monochrom> > let f [x] = f x in ()
11:40:40 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
11:40:42 <ski> ERROR - Type error in application
11:40:43 <ski> *** Expression     : not ()
11:40:43 <ski> *** Term           : ()
11:40:43 <ski> *** Type           : ()
11:40:43 <ski> *** Does not match : Bool
11:40:46 <ski> is what hugs says
11:41:07 <ski> (sometimes i think Hugs' error messages are more readable)
11:41:45 <monochrom> because it gives less information, and you likely don't need the omitted information
11:42:03 <parcs> triliyn: i think the first is expected, the second actual/inferred
11:42:19 <ski> monochrom : say in `not ()', we could either complain that the context demands that `() :: Bool', or we could complain that the context demands `not :: () -> _'
11:42:31 <triliyn> "Couldn't match type '[a0]' with '[[a0]]' in the first argument of 'tail', namely 'all' in the first argument of 'bracketSearch', namely '(tail all)' in the expression: bracketSearch (tail all) open close"
11:43:08 <triliyn> bracketSearch::(Eq a, Num b) => [a] -> a -> a -> b is the function I'm trying to define
11:43:30 <copumpkin> that type doesn't really tell me much
11:43:40 <copumpkin> :)
11:44:07 <triliyn> I am not sure what other information is relevant :$
11:44:10 <fryguybob> > or . (zipWith (==) <*> tail) $ [1,2,3,3,4,5]
11:44:12 <lambdabot>   True
11:44:29 <ski> triliyn : is `all' a local variable of list type ?
11:45:00 <ski> triliyn : i think we probably need to see the context of this call to `bracketSearch'
11:45:46 <parcs> yeah, i think my assumption is correct
11:45:57 <triliyn> bracketSearch (all@thing:_) open close
11:45:57 <triliyn>    | thing == open = let num = calc (tail all) in
11:45:57 <triliyn>                           (num + bracketSearch (drop num all) open close)
11:46:00 <triliyn>    | thing == close = 0
11:46:02 <triliyn>    | otherwise = 1 + (bracketSearch (tail all) open close)
11:46:04 <triliyn>    where calc xs = bracketSearch (tail all) open close
11:46:23 <monochrom> all@thing:_ ? all@(thing:_) ? are they the same?
11:46:33 <triliyn> Oh, that might be it
11:46:56 <kmc> triliyn, paste code on hpaste.org
11:47:03 <triliyn> Oh, okay
11:47:07 <triliyn> Sorry
11:47:08 <kmc> easier for us to follow, plus you get free style suggestions
11:47:17 <monochrom> > let f [x] = f (tail x) in ()
11:47:18 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
11:48:31 <geheimdienst> so ap is the same as <*>, modulo some abstract nonsense?
11:48:32 <monochrom> > let {f [x] = f (tail x); f :: [a] -> ()} in ()
11:48:32 <lambdabot>   Couldn't match expected type `[a]' against inferred type `a1'
11:48:33 <lambdabot>    `a1' is a ...
11:49:18 <kmc> triliyn> I am not sure what other information is relevant  <--- a description of what the function should do, which is not obvious from its type
11:49:46 <kmc> geheimdienst, yep
11:49:51 <monochrom> well, actual code is 99% of the necessary information
11:49:53 <geheimdienst> kmc, thanks
11:50:35 <triliyn> Oh. It's supposed to search a list and treat open and close as delimiters
11:51:13 <monochrom> the idea of "reproducible experiment" ought to be self-evident a priori intrinsic
11:51:13 <triliyn> And finds the index of the first instance of close that doesn't have a matching open
11:53:16 <ski> triliyn : `calc xs' doesn't use `xs'
11:53:37 <triliyn> ...oh, right
11:53:48 <triliyn> hehe, wow. How did I not see that? :$
11:54:36 <ski> @type (:$)
11:54:36 <lambdabot> Not in scope: data constructor `:$'
11:55:15 <triliyn> Thanks ski
11:55:47 <monochrom> :$ is the infix constructor for complex-valued money
11:56:21 <ion> I have 5 + 20i euros. How much candy can i get with it?
11:56:35 <monochrom> 5 + 20i candies
11:56:42 <kmc> ion, depends on the phase of the candy
11:56:50 <ion> Indeed, 5 real and 20 imaginary pieces.
11:57:38 <monochrom> http://xkcd.com/816/  somewhat related but tangential
11:59:34 <monochrom> how many candies can you buy with 5 euros + 60 monopoly dollars? answer: 5 candies and 1 mediterranean avenue title deed
12:02:06 <triliyn> Ah, it seems like I did want all@(thing:_) too
12:03:38 <monochrom> you can write "f all@(thing:_) = ..." without further parentheses
12:04:08 * ski always find that aspect of concrete syntax odd
12:04:59 <monochrom> presumably because @ is reserved that that purpose and plays no other roles so there is no ambiguity in "f x@blah"
12:05:13 <monochrom> s/that that/for that/
12:06:14 <ion> @ is not an operator, it’s part of the syntax. It makes sense that it doesn’t need extra parens.
12:06:47 <ski> it's a syntactic operator
12:06:54 <ski> just like function application is
12:07:35 <triliyn> Aha! Got it to load!
12:10:16 <monochrom> heh, you probably like sml syntax i.e. "f (all as thing::_)"
12:10:18 <OceanSpray> theoretically, one could implement the core parts of Haskell without garbage collection, right?
12:10:32 <kmc> JHC does (or did)
12:10:50 <kmc> i don't think the Haskell Report forbids you from leaking memory like a sieve
12:10:50 <OceanSpray> I mean, just pass by value EVERYWHERE and don't care about how big the datastructure is
12:10:55 <OceanSpray> oh
12:11:01 <kmc> "pass by value" is not really compatible with lazy evaluation
12:11:02 <monochrom> but jhc did that by letting garbage stick around forever
12:11:08 <tonkman> Im trying to write some kind of type to represent parametric equations, but im not sure how to implement it
12:11:10 <OceanSpray> I meant implementing it without leaking memory
12:11:12 <kmc> the Haskell Report does not require lazy evaluation either
12:11:18 <tonkman> have someone done something like this before?
12:11:26 <kmc> OceanSpray, you could get pretty far with reference counting
12:11:35 <OceanSpray> hm
12:11:42 <OceanSpray> this might be more of an ML question
12:11:56 <OceanSpray> but what about an eager pass-by-value language?
12:12:05 <OceanSpray> Would that need garbage collection?
12:12:21 <ski> (you could always use the trivial GC : never deallocate)
12:12:32 <kmc> one of the best features of Haskell is that you get sharing between "versions" of an immutable data structure
12:13:12 <ion> Erlang’s GC is neat. Every process (lightweight share-nothing thread) has independent GC. GC in one process can affect another process.
12:13:13 <OceanSpray> yes, but say you don't care about efficiency.
12:13:15 <kmc> for free, with the most naive data structure code
12:13:16 <kmc> that is, Haskell as widely implemented -- I don't think the Report requires that, either
12:13:24 <OceanSpray> all I'm saking
12:13:31 <ski> OceanSpray : the initial ML Kit versions didn't use a GC
12:13:47 <kmc> OceanSpray, you can implement Haskell's non-strict semantics with call-by-name rather than lazy evaluation
12:13:53 <kmc> in that case passing thunks by value would work fine
12:13:53 <ski> OceanSpray : pre-Scheme in Scheme48 doesn't use a GC
12:14:20 <OceanSpray> kmc, and it won't leak memory?
12:14:37 <OceanSpray> I'm trying to imagine a very VERY naive implementation here
12:14:42 <kmc> don't see why it wuold
12:14:53 <OceanSpray> where you push thunks onto a stack and pop them back out when the function finishes
12:14:53 <ski> (ML Kit uses region management for allocating and deallocating stuff)
12:15:04 <kmc> Haskell implemented without laziness would be a vastly different experience, even if it technically conforms to the Report
12:15:36 * ski recalls reading about speculative eagerness
12:15:41 <OceanSpray> and there is no heap-allocation ANYWHERE
12:16:23 * ski wonders what counts as "heap"
12:16:34 <iratsu> how can one convert a ByteString into an Int?
12:16:50 <kmc> iratsu, \_ -> 42
12:16:59 <kmc> iratsu, seriously, there's more than one function of type ByteString -> Int
12:17:02 <kmc> which one do you want?
12:17:03 <monochrom> length converts a ByteString into an Int or Int64 or something
12:17:06 <ion> I think \_ -> 43 is better.
12:17:30 <ski> @hoogle Read a => ByteString -> Maybe (a,ByteString)
12:17:30 <lambdabot> Data.ByteString.Char8 uncons :: ByteString -> Maybe (Char, ByteString)
12:17:31 <lambdabot> Data.ByteString.Lazy.Char8 uncons :: ByteString -> Maybe (Char, ByteString)
12:17:31 <lambdabot> Data.ByteString.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
12:17:37 <iratsu> kmc: well in particular i'd like "44" to map to 44
12:17:46 <kmc> "44" does not correspond to a ByteString
12:17:57 <kmc> "44" is a String and it's composed of characters, not bytes
12:18:04 <iratsu> well with OverloadedStrings
12:18:28 <kmc> but i assume you mean ASCII / Latin-1 / UTF8 (since they all coincide here)
12:18:41 <iratsu> yea
12:18:47 <ion> \_ -> unsafePerformIO randomIO
12:18:47 * ski demands PETSCII
12:18:53 <kmc> ByteString.Char8 and the IsString instance for ByteString are so awful
12:18:56 <kmc> don't even get me started
12:19:29 <monochrom> you saw hoogle listing readInt, I think we're done
12:19:55 <monochrom> despite being awful
12:19:56 <tgeeky> has anyone else here used regex-genex?
12:20:05 <tgeeky> or is willing to try it, just to 'time' it real fast?
12:20:06 <OceanSpray> just do a (read (byteStringToString_or_whatever_that_function's_called str) :: Int)
12:20:28 <kmc> ByteString to String is called "character decoding" and there are many ways to do it
12:20:45 <kmc> ASCII, Latin-1, UTF8, UTF16LE, UTF16BE, UTF32LE, UTF32BE, and a bunch of legacy codepage stuff
12:20:52 <kmc> also UCS-2 and UCS-4
12:21:04 <kmc> EBCDIC
12:21:04 <monochrom> please include latin-1 as legacy junk
12:21:16 <kmc> monochrom, done
12:21:30 <monochrom> thank you!
12:22:13 <OceanSpray> who is mason donahue
12:22:20 <OceanSpray> whoops wrong chqnnel
12:22:25 <shapr> Is that a Jeopardy answer?
12:22:26 <shapr> ok then..
12:22:30 <monochrom> haha
12:22:34 <tgeeky> shapr: my thoughts exactly
12:23:46 <hpaste> “Mukesh Tiwari” pasted “SPOJ DIV SUM ” at http://hpaste.org/48848
12:24:07 <monochrom> dim sum? :P
12:25:19 <Kron> What is the meaning of life? D:
12:25:23 <Kron> whoops wrong channel
12:25:39 <Nimatek> I think it was the right channel.
12:25:45 <monochrom> ok, finally someone who factors numbers by a slightly better method than "hi I need help re-inventing trial division"
12:25:50 <joe6> learning agda?
12:26:31 <monochrom> @remember joe6 <Kron> What is the meaning of life? D: <joe6> learning agda?
12:26:31 <lambdabot> I will remember.
12:27:31 <keep_learning> hello all
12:27:46 <keep_learning> could some one please tell me why this code http://hpaste.org/48848
12:28:22 <keep_learning> is not running when i am taking input from file using ./divsum < t.in
12:29:10 <saml> keep_learning, it doesn't even compile
12:29:16 <keep_learning> [user@localhost Haskell]$ ./Divsum_hard < t.in
12:29:16 <keep_learning> Divsum_hard: Maybe.fromJust: Nothing
12:29:35 <keep_learning> saml, seems like indentation problem
12:29:40 <keep_learning> or some thing else
12:29:59 <saml> y not compilable testcase please?
12:30:27 <monochrom> I'm a bit suprised that fst.fromJust.BS.readInteger parses to what humans intend
12:30:51 <kmc> groupBy (\x y -> x == y )  ≡  groupBy (==)  ≡ group
12:31:22 <saml> how do you do three equal signs?
12:31:36 <kmc> X compose key
12:31:43 <keep_learning> kmc, haskell beginner
12:31:49 <monochrom> I can get it to compile, no compile-time error
12:32:08 <monochrom> what input file should I give? just enter a number?
12:32:28 <keep_learning> 4
12:32:28 <keep_learning> 2
12:32:29 <keep_learning> 10
12:32:29 <keep_learning> 20
12:32:29 <keep_learning> 123456789123456789
12:32:36 <kmc> don't spam
12:32:49 <keep_learning> kmc, sorry
12:33:08 <monochrom> oh, I see. I'm going to try 1\n55699
12:33:13 <keep_learning> https://www.spoj.pl/problems/DIVSUM2/
12:33:39 * ski reads `SPOJ' as "Simon Peyton of Jones"
12:34:02 <hpaste> “Mukesh Tiwari” annotated “SPOJ DIV SUM ” with “SPOJ DIV SUM  (annotation)” at http://hpaste.org/48848#a48849
12:34:23 * kmc too ski
12:35:40 <keep_learning> when i am running it as ./DivSum
12:35:44 * djahandarie also did, but he has a good excuse because he's reading a paper by SPJ right now
12:35:49 <keep_learning> and giving inputs
12:35:54 <keep_learning> its running normal
12:36:01 <keep_learning> and giving output
12:36:04 <keep_learning> but from file
12:36:29 <keep_learning> its not running
12:38:54 <keep_learning> any one ?
12:41:57 <keep_learning> monochrom, could you tell me what is problem ?
12:43:49 <saml> let me install ghc  so  that i can compile your program
12:44:28 <keep_learning> saml, thank you
12:44:58 <saml> no thank you . i wanted to learn haskell for some time
12:46:59 <saml> haskell platform  does not do anygood for  make -j 4
12:47:06 <saml> i think it still comiples with single core
12:48:14 <monochrom> I see, you use BS.getContents twice, that's why. it may or may not stand for unconsumed data. in fact, you are seeing it to stand for uncomsumed data in one usage, and for no more data in another usage
12:49:12 <keep_learning> monochrom, yes , first one read the number of test cases
12:49:21 <keep_learning> and rest are reading test inputs
12:49:31 <keep_learning> this is first time i am using getContents
12:49:41 <keep_learning> so i don't have any idea about this.
12:51:05 <saml> how do you get divisors of a number?
12:51:37 <saml> keep_learning, why are you using ByteString? not String?
12:51:40 <hpaste> monochrom annotated “SPOJ DIV SUM ” with “the essence of the problem” at http://hpaste.org/48848#a48851
12:51:53 <keep_learning> i use the formula given on http://en.wikipedia.org/wiki/Divisor_function
12:52:28 <monochrom> keep_learning, grok my paste and be convinced that using any getContents twice is very bad
12:52:30 <keep_learning> i solve the problem using string but ByteString is faster
12:52:33 <keep_learning> so i am learning
12:55:38 <monochrom> essentially the second call will get you no data
12:56:30 <keep_learning> monochrom, second getContents is not taking anything
12:56:43 <monochrom> don't argue with me. argue with your computer.
12:57:03 <monochrom> oh, you mean you're agreeing with me.
12:57:08 <keep_learning> monochrom, yes
12:57:29 <monochrom> conclusion: don't call getContents more than once
12:57:47 <keep_learning> monochrom, so how to take other inputs
12:57:49 <keep_learning> ?
12:57:59 <monochrom> there is a reason readInteger gives you a ByteString and you just throw that out of the window
12:58:58 <keep_learning> monochrom, i never thought about it
12:59:11 <keep_learning> monochrom, most of times  i use Integer part
12:59:29 * ddarius recommends thinking.
12:59:41 <monochrom> did you read the doc of readInteger?
12:59:52 <monochrom> "otherwise it just returns the int read, and the rest of the string"
12:59:54 <ddarius> monochrom: You're funny monochrom.
12:59:57 <monochrom> did you read that?
13:00:12 <keep_learning> monochrom, no
13:00:20 <monochrom> that's redundant with two "monochrom"s
13:00:22 <saml> it's hard to read your code
13:00:50 <monochrom> read the doc of every library thingy you use
13:00:57 <ddarius> monochrom: I will include as many "monochrom"s as I like, monochrom.
13:01:12 <keep_learning> monochrom, from now onwards  i will
13:01:42 * ddarius interprets keep_learning's statement as a statement asserting that he will no longer use libraries.
13:01:47 <keep_learning> monochrom, you seems to be very tough teacher ;)
13:01:50 <saml> integer factorization is np-complete, right?
13:02:10 <keep_learning> saml, yes
13:02:14 <monochrom> not proved or disproved to be np-complete
13:02:40 <saml> keep_learning, so you are trying to solve np-complemete-ish problem?
13:02:43 <monochrom> only known to be np and subexponential
13:02:44 <copumpkin> it's in np
13:02:46 <saml> and ByteString will help you there?
13:03:09 <copumpkin> I always use ByteString to factor my integers
13:03:10 <keep_learning> saml, its nothing like that. I am solving just a problem given on SPOJ
13:03:12 <monochrom> it's fine to use bytestring just for getting used to it
13:03:37 <saml> oh divisors are different from factors
13:03:47 <monochrom> in fact if not for this exercise we would not debug this misconception about getContents
13:04:41 <monochrom> well I think the fastest way to do sum-of-divisors is still through factorization or equivalent
13:05:16 <monochrom> and I commend you for going pollard's rho, actually.
13:05:16 <saml> oh the wiki you gave me has the function  omg(1,12)  is what you want to implement
13:06:10 <keep_learning> saml, sigma x
13:06:24 <saml> yah. the wiki doesn't give algorithm for sigma, does it?
13:06:36 <keep_learning> saml, http://upload.wikimedia.org/math/c/2/6/c26afb595961f0e8a57a55b43817420a.png
13:06:45 <saml> ah thanks
13:06:46 * ski . o ( `12496' )
13:06:53 <saml> wait.. you already have solution for String
13:07:36 <saml> waht's that big Pi symbol?  that's product  (instead of Sum, Signma) ?
13:07:58 <Cale> yes
13:09:14 * ddarius hugs Euler, because one just can't love Euler enough.
13:09:37 <keep_learning> saml, yes i have solution using string
13:09:55 <keep_learning> saml, multiplication
13:10:32 <keep_learning> saml, you can get accepted using the same code
13:10:50 <keep_learning> just change the bytestring to string
13:25:08 <joe6> saml, how is the xml implementation of ghc coming along?
13:40:11 <edwardk> xhc? implemented in xslt, it will be rocking fast ;)
13:40:18 <marens> gwern: may i pm you?
13:40:53 <joe6> it will do everything that ghc currently does in one instruction cycle.
13:43:41 <ddarius> edwardk: executed in a browser
13:46:03 <nicoo> edwardk: is that xml/xslt Haskell compiler/interpret a joke ? I hope so ...
13:46:51 <joe6> nicoo, saml is implementing it.
13:47:06 <merijn> nicoo: Most jokes in #haskell tend to end up as implementations :p
13:47:35 <nicoo> indeed ^^
13:47:36 <ddarius> XSLT actually could be used as the target language of the compiler which means we could make a Haskell->XSLT translator and then use that to turn GHC into an XSLT-based compiler.
13:51:03 <gwern> marens: if there's no compelling security or privacy reason, why not just ask me here?
13:51:08 * gwern lives in public
13:53:28 <marens> gwern: ok, i just reverted the haskell.org frontpage to the last good version and think you should remove http://goo.gl/Yid0H and the other site he created from the wiki (assuming you are the gwern from the wiki)
13:56:43 <dbpatterson> what's the best place to look for a short synopsis of how to use (atto)parsec?
13:57:38 <ddarius> Parsec and attoparsec are unrelated libraries.
13:58:06 <ddarius> The Parsec letter is probably the best overview of Parsec, though the module names and some other minor details are out of date.
14:02:36 <dbpatterson> ddarius: I thought attoparsec had a similar interface? wasn't it supposed to be a faster, if slightly less user friendly, version of the same thing? Thanks for the paper reference
14:03:01 <marens> gwern: thanks
14:04:07 <ion> I find the Haddock documentation of Parsec very useful.
14:04:23 <osfameron> ion: really?
14:04:32 <ion> yes
14:04:55 <osfameron> ah, I suppose it's useful once you already know how to use parsec
14:05:44 <ion> Well, parse foo "" "input" where foo is a parser.
14:06:31 <ivant> are Word32/64 types as fast (or faster) as Int type when using ghc7?
14:07:11 <osfameron> ion: I ended up googling for a blog post on parsec that showed an example of how to use it ;-)
14:07:28 <osfameron> I don't think there was any way at all that the haddock would let you know how to call it to do something useful
14:07:44 <kmc> ivant, whichever is native for your machine should be roughly as fast as Int
14:07:51 <kmc> Word64 may be slow on a 32-bit machine
14:08:09 <FUZxxl> ezyang: Are you here?
14:08:26 <dbpatterson> osfameron: do you have a link to the post?
14:09:12 <ivant> kmc, well, sure, I meant the same-sized Word, of course. I vaguely remember writing some numerical calculations which were sped up by switching from Word64 to Int (on x64)
14:09:24 <kmc> oh, i'd be interested to know more
14:09:43 <osfameron> dbpatterson: hmmm, actually, no.  But googling for "parsec haskell" gives me some links, the only one of which is highlighted-as-read comes from RWH Chapter 16
14:09:51 <ivant> kmc, unfortunately, I don't remember, what these were, hence the question
14:09:53 <osfameron> so maybe it was that, and not a blog
14:15:49 <ocharles> Hi, I'm having a problem with scoping when compiling
14:15:51 <ocharles> I'm sure it's really simple
14:16:00 <ocharles> https://gist.github.com/1072845 is my 2 source code files, and the compile error
14:16:12 <ocharles> what am I missing? To me I'm sure PersonId and it's constructor are exported...
14:17:44 <osfameron> ocharles: musicbrainz is branching out into books?
14:18:05 <ocharles> osfameron: hmm, unofficially :) the community today started discussing it, so I thought I'd head the project in my free time
14:18:13 <ocharles> and figured I'd do it in haskell
14:18:21 <osfameron> heh, cool
14:18:30 <ocharles> though as you can see, it's proving very slow at the beginning :)
14:20:03 <kmc> import BookBrainz.Types.Newtypes (PersonId(..))
14:20:07 <kmc> or import BookBrainz.Types.Newtypes (PersonId(PersonID))
14:20:15 <kmc> you're just importing the type, not the value constructor
14:20:30 <ocharles> ooohhhh
14:20:44 <ocharles> I thought it was an export problem, I didn't think to look the other way
14:20:45 <ocharles> doh
14:20:47 <ocharles> thanks kmc
14:20:51 <kmc> :)
14:20:58 * ocharles adds more oil to his rusty Haskell gears
14:21:03 * ski prefers not naming type and data constructors the same
14:21:16 <kmc> ski, i think it's a good idea iff there's one constructor
14:21:32 <kmc> and no chance you'd add new ones
14:21:53 <kmc> fewer names to choose and remember is a good thing
14:22:14 * ski uses `MkFoo' in that case (and `unFoo' for deconstructor, if it's a `newtype')
14:22:24 <kmc> that's okay too
14:22:27 <kmc> but it does add some noise
14:22:31 <kmc> i use that in examples for clarity
14:22:37 <kmc> but in "real code" i prefer the other style
14:22:39 <int80_h> :t flip
14:22:40 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
14:22:47 <kmc> :t Prelude.flip
14:22:48 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
14:22:55 <int80_h> could someone explain what flip does?
14:23:08 <int80_h> In terms of the type signature, as I don't understand it.
14:23:11 <kmc> makes a "2-argument" function take its args in the opposite order
14:23:14 <ski> > flip (++) "foo" "bar"
14:23:16 <lambdabot>   "barfoo"
14:23:17 <kmc> or do you mean Caleskell's generalized version?
14:23:23 <ski> > flip (+) 3 4 :: Expr
14:23:25 <lambdabot>   4 + 3
14:23:37 <ski> > flip f 3 4 :: Expr
14:23:38 <lambdabot>   f 4 3
14:23:39 <kmc> > flip (:) [2..5] 10
14:23:41 <lambdabot>   [10,2,3,4,5]
14:23:41 <int80_h> ah
14:23:46 <kmc> @src flip
14:23:46 <lambdabot> flip f x y = f y x
14:23:54 <kmc> @pl \f x y -> f y x
14:23:54 <lambdabot> flip
14:24:04 <int80_h> kmc: could you tell me what the type signature says. I'd like to get better at reading them.
14:24:12 <kmc> the Prelude one or the Caleskell one?
14:24:28 <ski> int80_h : given a function of type `a -> b -> c', return a function of type `b -> a -> c'
14:24:31 <int80_h> Prelude
14:24:39 <kmc> right,  (a -> b -> c) -> (b -> a -> c)
14:24:53 <kmc> (a -> b -> c -> d) means (a -> (b -> (c -> d)))
14:24:54 <ocharles> what do i do about this error: Loading package double-conversion-0.2.0.0 ... linking ... <interactive>: /home/ollie/.cabal/lib/double-conversion-0.2.0.0/ghc-6.12.3/HSdouble-conversion-0.2.0.0.o: unknown symbol `_ZNK17double_conversion6Double5valueEv'
14:24:59 <ocharles> rebuild double-conversion?
14:25:08 <ski> alternatively, given a function of type `a -> b -> c', and (successively), an argument of type `b' and an argument of type `a', return a result of type `c'
14:25:16 <ion> (a -> b -> c) -> (b -> a -> c)
14:25:34 <kmc> int80_h, this is because a "multi-argument" function is actually a single-argument function which returns a function that takes the second argument
14:25:36 <ion> Whoops, had scrolled up and missed a bunch of messages.
14:25:46 <kmc> so (a -> b -> c) is shorthand for (a -> (b -> c))
14:25:48 <int80_h> ah, I get it :)
14:25:50 <kmc> cool :)
14:26:07 <kmc> the "forall" stuff is a GHC extension
14:26:09 <int80_h> kmc: I'm having a lifting problem. DO you have time to discuss it with me?
14:26:21 <kmc> in this case it just means that a, b, c are all type variables which can take on any type
14:26:25 <int80_h> kmc: At least, I think it's a lifting problem
14:26:34 <kmc> if forall appears within the left hand arg to (->), that's where the fun non-standard stuff appears
14:26:57 <kmc> int80_h, you should ask and someone will help
14:27:14 <int80_h> kmc: I think I'm using the wrong lifting function, and my inability to read type signatures is hindering my ability to decide what the right one is. I could be totally off as to what the actual problem is.
14:27:26 <kmc> what's a "lifting function"?
14:27:28 <int80_h> alrighty. I'll post what I think is relevant
14:27:32 <kmc> cool
14:28:04 <int80_h> a function that lifts types from one monad to another, or from a pure type into a monad.
14:28:08 <int80_h> is that right?
14:28:15 <ski> > case [] :: [forall a. a] of [] -> ()
14:28:16 <lambdabot>   ()
14:28:28 <kmc> the term doesn't have one specific meaning
14:28:42 <kmc> it's used in lots of contexts
14:28:54 <ski> @type liftM
14:28:54 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
14:28:58 <int80_h> brb, hpasting
14:28:58 <ski> @type lift
14:28:59 <lambdabot>     Ambiguous occurrence `lift'
14:28:59 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
14:28:59 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
14:29:03 <kmc> int80_h, also there's no such thing as a "pure type"
14:29:10 <ski> @type Control.Monad.Trans.lift
14:29:10 <rvn_> @typee liftIO
14:29:11 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Control.Monad.Error.MonadTrans t, Monad m) => m a -> t m a
14:29:11 <lambdabot>     Ambiguous occurrence `liftIO'
14:29:11 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
14:29:11 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
14:29:12 <kmc> values of monadic type are pure values like any other
14:29:19 <ski> @type Control.Monad.Trans.liftIO
14:29:20 <lambdabot> forall a (m :: * -> *). (Control.Monad.Error.MonadIO m) => IO a -> m a
14:29:23 <kmc> int80_h, [] is a monad but that doesn't make [1,2,3] somehow "impure"
14:29:26 <kmc> it's just a list
14:29:47 <ski> `getLine' is just as pure as `[1,2,3]' is
14:30:14 <ski> `getLine' is just an action that sits there, just being
14:39:04 <rvn_> @type return
14:39:05 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
14:39:22 <hpaste> int80_h pasted “problem with types (is there any other kind?)” at http://hpaste.org/48855
14:39:50 <monochrom> yes, the other kind is problem with costs
14:40:01 <int80_h> monochrom: costs?
14:40:18 <int80_h> monochrom: oh how expensive an operation is?
14:40:43 <monochrom> yes
14:40:56 <kmc> int80_h, "couldn't match expected type T with actual type M T" indicates that you're missing 'return', maybe
14:41:04 <int80_h> I haven't got that far yet. I'm still playing "matche the types".
14:41:05 <kmc> what's the type of screenScraping ?
14:41:11 <Botje> int80_h: can you give a bit more types?
14:41:32 <monochrom> liftIO does not get from from X to IO X
14:41:34 <kmc> also you have double parens around that call for some reason
14:41:36 <monochrom> err
14:41:38 <kmc> :t return :: Int -> IO Int
14:41:39 <lambdabot> Int -> IO Int
14:41:41 <monochrom> liftIO does not get you from X to IO X
14:41:49 <int80_h> monochrom: I need to get from IO X to X
14:41:54 <kmc> you can't do that
14:41:59 <monochrom> liftIO doesn't do that either
14:42:09 <kmc> an IO Int is nothing like an Int
14:42:23 <kmc> an Int is an integer.  an IO Int is a description of how you *could* perform some IO to get an integer
14:42:27 <Enigmagic> :t (>>=)
14:42:27 <monochrom> "IO X" does not mean "I have an X hidden and you try wrangle it from me"
14:42:28 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:42:31 <kmc> the IO has not yet occurred and may never occur, or it might happen more than once
14:42:33 <Botje> int80_h: it looks like screenScraping returns an IO [URLString]
14:42:38 <int80_h>     Couldn't match expected type `[URLString]'
14:42:40 <int80_h>                 with actual type `IO [URLString]'
14:42:52 <Botje> int80_h: if so, you need to bind it to a variable like you do with cookieState
14:42:55 <kmc> foo <- screenScraping responseBody ipFile; mapM_ (flip (curlResp curl) resourceOpts) foo
14:42:55 <int80_h> yes screenScraping returns an IO [URLString]
14:43:16 <Botje> this variable will have typ [URLString], which you can pass to mapM
14:43:18 <kmc> :t join . fmap (mapM_ ?f)
14:43:18 <lambdabot> forall (m :: * -> *) a b. (Monad m, ?f::a -> m b, Functor m) => m [a] -> m ()
14:43:41 <int80_h> kmc: thanks, I need to grab that before it scrolls away :)
14:43:50 <Botje> int80_h: liftIO is for when you are working with monad transformers, you probably don't need that right away
14:44:06 <kmc> an IO action is not an IO result, any more than a recipe is a cake
14:44:19 <monochrom> there is no monad transformer in sight in this code
14:45:25 <int80_h> okay I'm going to go apply what you suggested
14:46:24 <Botje> good luck1
14:46:26 <Botje> 1
14:46:28 <Botje> argh
14:46:29 <Botje> ! :)
14:47:28 * hackagebot tremulous-query 1.0 - Library for polling Tremulous servers  http://hackage.haskell.org/package/tremulous-query-1.0 (ChristofferOjeling)
15:23:36 <carlocci> Hello. I read "why functional programming matters" up to "map f = foldr (cons . f) Nil". It's amazing, I'm _definitely_ sold: what should I do next?
15:23:40 <ocharles> Hey, looking for a quick bit of design advice on this project, which interfaces with a database
15:24:01 <ocharles> Say I have 2 tables: books and editions, and the relationship: book has many editions
15:24:23 <ocharles> How should I model that in Haskell land? At the moment I have: data Book = Book { bookEditions :: Maybe [Edition] }
15:24:46 <parcs> @where lyah
15:24:47 <lambdabot> http://www.learnyouahaskell.com/
15:24:50 <ocharles> And then a function loadEditions :: Book -> Book, which simply copies the book and fills in bookEditions with Just [Edition], instead of Nothing
15:25:18 <ocharles> does this seem like a sensible approach?
15:25:34 <carlocci> parcs, thank you
15:25:59 <parcs> carlocci: :)
15:26:47 <ski> ocharles : why `Maybe' ?
15:27:05 <ocharles> ski: because I'd like to be able to load a book without loading it's editions (saving a JOIN)
15:27:22 <ski> hm
15:27:26 <ocharles> but using [] for that seems incorrect, because that would imply a book has no editions, but I simply don't know if it does or doesn't have editions at this stage
15:27:52 <ski> ocharles : using that `Book' type, you can't do anything interesting with a `Book' *except* loading the editions, i think
15:27:56 <dpratt71> what's a good name for something that's a potential solution to a problem, but possibly not a solution? I can only think of 'candidate', but I'd prefer something more 'noun'y
15:28:02 <ocharles> ski: oh, I was hand waving
15:28:08 <ocharles> books also have an author, and a name
15:28:31 <monochrom> I suppose you use Nothing for "uninitialized" and Just [] for "initialized, now we know it's empty"
15:28:47 <ocharles> monochrom: exactly
15:28:51 <monochrom> candidate is a noun
15:29:11 <ski> dpratt71 : hm, will these candidates always include all correct solutions ?
15:29:14 <dpratt71> monochrom: it can be, yes
15:29:49 <dpratt71> ski: I hope so :)
15:30:29 <ocharles> ski, monochrom : A trickier problem is representing a FK that could be null. For example, editions have a country, but the country could be null. That feels like it would be Maybe (Maybe Country). yuck!
15:30:53 <ocharles> though... if the FK is null, then country is Nothing, so I think it's actually just Maybe Country
15:30:58 <monochrom> yes, basically most sql columns are Maybe's
15:31:19 <ocharles> though if you haven't joined country onto edition, you don't have enough to construct the Just
15:31:50 <ski> ocharles : i might do `bookEditions :: Cache [Edition]', where you get get the contents of the cache and if it's not there, it will be fetched and stored in the cache ..
15:32:59 <ocharles> hrm, I don't think caching belongs in the data types
15:34:37 <ocharles> Well consider these tables: edition(name NOT NULL, language_iso_code TEXT NOT NULL REFERENCES language (iso_code)) and language(iso_code TEXT NOT NULL, name TEXT NOT NULL)
15:35:17 <ocharles> I'm thinking maybe: data Edition = Edition { name :: Text, language :: LanguageLike } and LanguageLike is a type class, with 2 instances: Language and LanguageFK
15:35:40 <kmc> if "x :: T" then T is not a type class
15:35:40 <ocharles> meh, not sure that's much good actually.
15:35:50 <ocharles> oh
15:35:53 <kmc> resist the urge to use type classes everywhere ;)
15:35:59 <ocharles> :)
15:36:15 <kmc> it is powerful
15:36:34 <ocharles> well data Edition = Edition { name :: Text, languageIsoCode :: Maybe ISOCode, language :: Maybe Language } seems to be the only way to model this
15:36:49 <ocharles> but I don't like that duplication of the isoCode in Edition and Language :(
15:37:18 <ocharles> but Edition somehow has to track the isocode, in order to be able to load it's Language in the future (as that's the FK)
15:37:44 <kmc> if you have want a type class but know ahead of time there will be only two instances, it's likely there will be a simpler way
15:39:01 <ocharles> indeed, there are only 2 instances here - a 'partial' language (tracking just the primary key) and a full language
15:39:21 <kmc> data LanguageLike = PartialLanguage ... | FullLanguage ... ?
15:39:33 <ocharles> oh yea
15:39:35 <ocharles> lol
15:39:48 <ocharles> what if something needs to use the iso code, but doesn't care if it's a full or partial language?
15:40:00 <ocharles> it would have to type match twice, no?
15:40:05 <ocharles> maybe designing for a non-existant case there
15:40:11 <kmc> getISO (PartialLanguage x) = x; getISO (FullLanguage x whatever) = x
15:40:19 <ocharles> works for me
15:40:22 <kmc> or you can cheat a bit and make both of the constructors use record syntax, with a shared label
15:40:24 <kmc> but that's kind of ugly
15:41:00 <ocharles> so now edition has editionLanguage :: Maybe Language
15:41:38 <ocharles> I think I like that now, and it will fail to run if a language isn't fully loaded and it should be. though that failure will be runtime
15:41:44 <ocharles> right?
15:42:16 <kmc> what do you mean?
15:43:23 <ocharles> say I have an edition object 'edition'
15:43:27 <ocharles> value*
15:43:54 <ocharles> and I want to display the editions language name. that's only part of FullLanguage, but I might not have an Edition that has a FullLanguage, but only has a PartialLanguage
15:44:16 <ocharles> is Haskell able to know that my Edition only has a PartialLanguage in at compile time?
15:44:31 <ocharles> loadLanguage :: Edition -> Edition -- would turn the PartialLanguage to a FullLanguage
15:46:06 <dpratt71> does this look reasonable: anyRepeated (x:xs) = (x `elem` xs) || anyRepeated xs
15:46:14 <dpratt71> base case is False
15:46:34 <cmccann> I really don't know why I ever bother looking at /r/programming on reddit anymore
15:46:46 <cmccann> most conversations end up carrying negative informational value
15:46:46 <int80_h> i unsubscribed long ago
15:47:05 <ocharles> cmccann: I don't bother with /r full stop anymore
15:47:17 <int80_h> I like r/haskell
15:47:39 <cmccann> int80_h, I was never subscribed, I just occasionally make the mistake of clicking on "other discussions" from announcements on /r/haskell
15:47:51 <cmccann> and then remember why I never subscribed to /r/programming
15:48:26 <kmc> Real Hackers use Agile SCRUM Javascript to startup
15:48:30 <kmc> because it has first class functions
15:48:35 <cmccann> and yeah, /r/haskell is usually okay
15:48:45 <kmc> here's a picture i drew with a computer in it
15:49:21 <kmc>  /r/haskell is a nice link feed, yeah
15:49:25 <int80_h> 333 upvotes if it has a kitten
15:49:31 <kmc> the comments are not a huge draw
15:49:41 <kmc> not that it's bad but there's enough other forums i prefer (IRC, SO)
15:49:52 <cmccann> I dunno, /r/haskell occasionally has useful conversations
15:50:05 <cmccann> admittedly it's mostly the same people who hang out in here
15:50:10 <int80_h> I learn about yesod updates via /r/haskell
15:50:56 <cmccann> generally I spend most of my time on Stack Overflow though
15:51:46 <cmccann> there's terrible content on SO as well, but unlike /r/programming I can vote to close and delete it, which is oddly soothing
15:51:48 <ski> ocharles : well, how about `data Book maybe = MkBook {bookEditions :: maybe [Edition]}' with `loadEditions :: Book (Const ()) -> Book Identity' ?
15:52:39 * hackagebot gps 0.6.2 - For manipulating GPS coordinates and trails.  http://hackage.haskell.org/package/gps-0.6.2 (ThomasDuBuisson)
15:52:53 <ocharles> ski: what does that give me over just using Maybe?
15:53:13 <ocharles> I don't know what Const () means either, yet
15:53:23 <ski> dpratt71 : that won't work on infinite lists, i think
15:53:40 <ski> ocharles : `newtype Const k a = MkConst k'
15:53:52 <ski> ocharles : it gives you more static guarantees
15:53:57 <dpratt71> ski: interesting
15:54:22 <c_wraith> ski: that's a boring functor :)
15:54:22 <ski> either you have not loaded editions yes, so the type is `Book (Const ())', or you have, so the type is `Book Identity'
15:54:27 <dpratt71> ski: I don't really need it to, but I'd like it to be as general as possible
15:54:52 <ocharles> ski: what happens if something could have 2 lists of different types?
15:55:04 <ocharles> ie, a book with a list of authors and a list of editions
15:55:18 <ocharles> would that be data Book maybeEditions maybeAuthors ?
15:55:19 <ski> ocharles : i'm not sure whether this idea is appropriate for what you want to do .. it might be too inflexible -- i'm just mentioning it
15:55:42 <ocharles> ski: i can't comment on flexibility, but it's a bit out of my mental scope :)
15:55:57 <ocharles> but I will make a note of it to come back to for sure!
15:58:22 <ski> dpratt71 : i suppose one way is `anyRepeated = loop (const False) where loop p [] = False; loop p (a:as) = p a || loop (liftM2 (||) p (a ==)) as' (de-`pl' as much as required)
15:59:32 <dpratt71> de-`pl == pointy ?
15:59:41 <ski> > let anyRepeated = loop (const False) where loop p [] = False; loop p (a:as) = p a || loop (liftM2 (||) p (a ==)) as in anyRepeated (cycle [0,1,2])
15:59:41 <lambdabot>   True
15:59:52 <ski> > let anyRepeated = loop (const False) where loop p [] = False; loop p (a:as) = p a || loop (liftM2 (||) p (a ==)) as in anyRepeated [0 ..]
15:59:54 <dpratt71> ski: ah, cool
15:59:56 <lambdabot>   mueval-core: Time limit exceeded
15:59:56 <ski> > let anyRepeated = loop (const False) where loop p [] = False; loop p (a:as) = p a || loop (liftM2 (||) p (a ==)) as in anyRepeated [0]
15:59:57 <lambdabot>   False
16:00:00 <ski> > let anyRepeated = loop (const False) where loop p [] = False; loop p (a:as) = p a || loop (liftM2 (||) p (a ==)) as in anyRepeated [0,0]
16:00:00 <lambdabot>   True
16:00:03 <ski> dpratt71 : yeah
16:00:16 <dpratt71> ski: very nice, thanks :)
16:02:31 <ski> > let anyRepeated = foldr (\a recur p -> p a || recur (liftM2 (||) p (a ==))) (const False) `flip` const False in anyRepeated (cycle [0,1,2])  -- more obfuscated version
16:02:33 <lambdabot>   True
16:03:30 <c_wraith> @src unzip
16:03:31 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
16:07:22 <dpratt71> it's funny to me how often functions that at first seemed pointless to me, like id and const, actually get used a lot
16:08:58 <parcs> @pl id
16:08:59 <lambdabot> id
16:09:04 <dpratt71> heh
16:09:14 <djahandarie> @pl anything
16:09:14 <lambdabot> anything
16:09:20 <dpratt71> you see what I mean, then :)
16:09:32 <parcs> @pl life
16:09:32 <lambdabot> life
16:09:39 <parcs> :(
16:09:43 <nus> @unpl const id
16:09:43 <lambdabot> (\ _ b -> b)
16:11:14 * ski . o O ( `type Bool = forall a. a -> a -> a' )
16:12:29 <cmccann> @unpl fmap fix return
16:12:29 <lambdabot> fmap fix return
16:12:33 <cmccann> pf
16:13:01 <parcs> ski: that's cool
16:14:40 <ddarius> dpratt71: When you start designing in a combinatorial manner, then these "trivial" functions become more valuable as they will often be the starting points of a more complex construction.
16:15:56 <ddarius> Also designing in that manner leads to a drive to factor things as much as possible, which leads to producing more of these "trivial" cases.
16:16:20 <ski> @. pl . djinn type fmap fix return
16:16:20 <lambdabot> f = id
16:16:24 <dpratt71> ddarius: yes, I've noticed that; I've also noticed I'm not very good at thinking combinatorially
16:17:02 <cmccann> the only reason id and const seem useless is that you need ap as well
16:17:09 <cmccann> though id is kinda superfluous, I'll grant
16:17:13 <dpratt71> ski: what the heck is that incantation supposed to do?
16:17:39 <erus`> lets write a haskell compiler in haskell
16:17:39 <ski> dpratt71 : compose the lambdabot commands `pl',`djinn' and `type'
16:17:52 <ski> @type fmap fix return
16:17:53 <lambdabot> forall a. a -> a
16:17:57 <ski> @djinn forall a. a -> a
16:17:57 <lambdabot> f a = a
16:18:02 <ski> @pl f a = a
16:18:03 <lambdabot> f = id
16:18:06 <dpratt71> ski: oh...to what end?
16:18:20 <cmccann> trying to figure out how "fmap fix return" makes sense, I expect
16:18:25 <ion> @@ @pl @djinn @type fix . const
16:18:26 <lambdabot>  f = id
16:18:28 <ski> to rewrite cmccann's attempt to something other than itself
16:18:36 <dpratt71> oh
16:18:42 <cmccann> or trying to get lambdabot to do so, rather
16:18:56 <cmccann> since I'm pretty sure ski has seen that expression before
16:18:59 <c_wraith> cmccann: return is "const" in that case
16:19:10 <ski> cmccann : well, i didn't recall seeing it ..
16:19:22 <c_wraith> cmccann: making the expression fix . const
16:19:29 <c_wraith> :t fix . const
16:19:29 <cmccann> c_wraith, yeah, I know what it does :P
16:19:29 <lambdabot> forall a. a -> a
16:19:46 <ddarius> @quote fmap.fix.return
16:19:46 <lambdabot> mauke says: fmap fix return is the e^(i*pi)+1 of haskell
16:19:51 <cmccann> it's just a silly bit of obfuscation that I like to confuse people with, forget where I first saw it
16:20:00 <cmccann> haha
16:20:21 <djahandarie> There is a blog with that title, maybe there.
16:20:24 * ski wonders what the `e^(i*tau) - 1' of Haskell is then ..
16:20:44 <cmccann> djahandarie, could be, sounds familiar but don't recall if that was the first time I saw it
16:21:51 <nus> ski, ditto (-:
16:23:01 <ion> ski: http://www.thepimanifesto.com/ deals with that expression among others.
16:23:18 * cmccann mostly just enjoys anything that uses the ((->) e) functor as the SK combinator basis
16:25:24 <ski> ion : not <http://tauday.com>, then ?
16:26:38 * ddarius should write "Transcendental numbers are wrong."
16:28:17 <cmccann> ddarius, that sounds like it'd be an interesting read
16:29:16 * ski . o O ( Wildberger )
16:29:26 <c_wraith> I'm pretty sure non-computable numbers are wrong.
16:30:50 <doserj> non-definable ones for sure are wrong
16:31:17 * cmccann thinks non-computable numbers are interesting, in a spooky ghost story sort of way, the sort of thing you tell children to scare them, but not relevant to real life
16:32:27 <ion> > undefined :: Integer
16:32:28 <lambdabot>   *Exception: Prelude.undefined
16:32:32 <ski> hm .. one could consider semi-computable ones, in some sense
16:32:56 * cmccann isn't sure what semi-computable means in this context
16:32:56 <ion> > fix id :: Integer
16:32:59 <ski> (e.g. ones which are computable, assuming Markov's Principle for natural numbers)
16:33:00 <lambdabot>   mueval-core: Time limit exceeded
16:33:24 <SirFrancisDrake> cmccann: computable up to any given digit?
16:33:42 <cmccann> @quote fix.not
16:33:42 <lambdabot> syntaxglitch says: <Kleene> hey al check this out <Kleene> > fix not <lambdabot> mueval-core: Time limit exceeded <Church> well crap
16:34:02 <cmccann> SirFrancisDrake, I thought computable included computable to arbitrary finite approximation
16:34:53 <ski> one can consider cauchy sequences which converge, but where you don't have any bound on how fast they converge
16:35:33 <SirFrancisDrake> cmccann: you're right
16:39:49 <Peaker> Just used my Haskell foo to CPS-transform a guy's Python code so that I can add non-determinism effects to it easily --- it worked pretty quickly, and now he's more likely to learn Haskell soon :)
16:40:20 <triliyn> Isn't that spelled "fu"?
16:40:24 <Peaker> :-)
16:40:38 <Peaker> If you have, say, a for loop in Python, and you want to throw a non-determinism fork point in the middle somewhere -- you just can't.. you're stuck in IO, can't get (ListT IO)... sucky.. So have to resort to the mother of all monads
16:40:38 <triliyn> That threw me off for a couple seconds
16:40:53 <Peaker> yeah, I think it's my first time typing that expression down, ever :)
16:41:00 <triliyn> hehe
16:41:38 <Peaker> but once everything is CPS'd, you can just throw any effect you want in between there
16:41:52 <Peaker> at least non-determinism becomes easy
16:41:53 <shachaf> Peaker: Hmm, can you @paste the code?
16:42:11 <ddarius> Peaker: All monads become easy.
16:42:12 <Peaker> hmm.. good pastebin for Python?
16:42:15 <Peaker> ddarius: Yeah
16:42:29 <SirFrancisDrake> are non-computable numbers related to strange functions on polytopes, that we can prove exist with Zorn's lemma, but we can't actually construct?
16:42:38 <SirFrancisDrake> I suck at maths :(
16:42:46 <shachaf> If it's relevant enough for #haskell, surely it's relevant enough for hpaste. :-)
16:42:49 * cmccann is dubious about Zorn's lemma as well
16:43:01 <c_wraith> zorn's lemma is clearly false, being equivalent to the axiom of choice. :)
16:43:28 <shachaf> @quote axiom.of.choice
16:43:28 <lambdabot> No quotes match. Maybe you made a typo?
16:43:30 <SirFrancisDrake> come on, zorn's lemma is cool
16:43:41 <c_wraith> But...  no one complains about countable choice.  And you don't get uncountable until you start dealing with non-computable sets
16:45:26 <Peaker> shachaf: http://pastebin.com/De7yca1j  -- I just changed the BEFORE CPS part to the AFTER CPS part
16:45:29 <mauke> The paste De7yca1j has been copied to http://hpaste.org/48856
16:45:42 <shachaf> Hah, it went on hpaste anyway
16:46:12 <Peaker> shachaf: well it has highlighting in pastebin
16:46:31 <Peaker> shachaf: the outer loop in build_trees becomes the foo recursion in the CPS'd
16:47:42 <Peaker> oh, I just realized that if I want to convert the ListT IO   there into   ListT (t IO)        there, I'd have to CPS-transform the flattening iteration of the non-determinism loop.  Heh
16:47:44 <mjo> Is there really no factorial function defined in a library? Or would that obsolete too many blog posts? =)
16:47:53 <Peaker> CPS upon CPS upon CPS...
16:48:00 <shachaf> mjo: product [1..n]
16:48:26 <mjo> Yeah, I can figure out how to write one heh.
16:48:28 <c_wraith> mjo: what libraries *do* have factorial functions?
16:48:36 <c_wraith> mjo: even in other languages?
16:49:03 <shachaf> @hoogle gamma
16:49:03 <lambdabot> Test.QuickCheck.Poly type GAMMA = Poly GAMMA_
16:49:03 <lambdabot> Test.QuickCheck.Poly type OrdGAMMA = Poly OrdGAMMA_
16:49:10 <cmccann> factorial as a function isn't really very useful
16:49:35 <cmccann> doing anything nontrivial involving factorials pretty much requires not computing the entire thing
16:49:56 <mjo> math.factorial(x) in python, the first place I checked
16:50:43 <olsner> Peaker: you mean like a fixpoint of the cps transform?
16:50:52 <mjo> I don't need anything non-trivial, I just want some function definitions to match those in a paper exactly. I've already got my own, I just feel silly documenting it and writing tests.
16:51:18 <olsner> "It is of note that CPS transform is conceptually a Yoneda embedding." <-- from wikipedia, but that does sounds so much #haskell
16:52:17 <Peaker> olsner: well, when you add non-determinism to a CPS transform, you might use for loops to flatten the result lists.. then if you want an effect in between the list elements, you have to cps transform these loops too
16:53:13 <ski> olsner : probably not fixpoint, just some iterations
16:53:16 <ski> c_wraith : the set of (computable) reals is not countable
16:53:26 <olsner> ski: I know... how boring :/
16:54:04 <olsner> I mean, iterating but not going all the way unto a fixpoint... that's just a job half done
16:54:06 <c_wraith> ski: sure it is.  it's not computable, which is an amusing contradiction, but it's certain possible to enumerate all possible programs
16:54:07 <ski> olsner : i have used an unboundedly deep stack of `ContT o's, though
16:54:27 <ski> olsner : with `IO' (or `ST s') in the bottom
16:54:43 <c_wraith> ski: rather, the isomorphism from N to computable reals isn't computable
16:54:44 <olsner> ski: nice :>
16:55:04 <c_wraith> ski: but it's really trivial to show that such an isomorphism must exist.
16:55:26 <ski> olsner : each user of it would decide how many levels deep it would like the stack to be this time (so `PolymorphicComponents')
16:56:37 <ddarius> olsner: That comment was added a week ago.
16:57:23 <ski> olsner : `newtype Foo m a = MkFoo (forall n. MonadStack m n => ..n..)' where `instance Monad m => MonadStack m (IdentityT m)' and `instance MonadStack m n => MonadStack m (ContT o n)' -- something like that
16:57:24 <olsner> ddarius: the one about yoneda embeddings?
16:58:06 <ski> c_wraith : if you can't compute it, then you haven't shown it to exist :)
16:58:40 <ski> (relatedly, subsets of finite sets are not necessarily finite)
16:59:01 <c_wraith> ski: the problem is "isomorphism" is overly restrictive.  All you really *need* to prove a set is countable is to show that it's no larger than N.  And that's trivial.
16:59:40 <ski> c_wraith : i'm not sure "larger" is well-defined (as a total order) for sets
17:01:19 <erus`> @hoogle lex
17:01:19 <lambdabot> Prelude lex :: ReadS String
17:01:19 <lambdabot> Text.Read lex :: ReadS String
17:01:19 <lambdabot> Text.Read.Lex lex :: ReadP Lexeme
17:07:06 <hpc> > lex "5+6-3"
17:07:07 <lambdabot>   [("5","+6-3")]
17:09:49 <c_wraith> > iterate (lex . snd) ("", "5+6-3")
17:09:50 <lambdabot>   Couldn't match expected type `[(GHC.Base.String, GHC.Base.String)]'
17:09:50 <lambdabot>        ...
17:10:00 <c_wraith> oh.
17:10:28 <shachaf> > lex "+6-3"
17:10:28 <lambdabot>   [("+","6-3")]
17:10:34 <c_wraith> > iterate (lex . snd. head) [("", "5+6-3")]
17:10:35 <lambdabot>   [[("","5+6-3")],[("5","+6-3")],[("+","6-3")],[("6","-3")],[("-","3")],[("3"...
17:11:34 <shachaf> > takeWhile (not . null) . map (snd . head) . iterate (lex . snd . head) $ [("","5+6-3")]
17:11:35 <lambdabot>   ["5+6-3","+6-3","6-3","-3","3"]
17:11:45 <djahandarie> Useful.
17:12:27 <Peaker_> What's the MonadStack class?
17:12:38 <djahandarie> Got monads in monads in monads
17:12:56 <cmccann> mo' monads
17:12:59 <Peaker> how is it different from the MonadTrans class?
17:13:24 <Peaker> What's the point is what I'm asking :)
17:13:25 <hpc> @hoogle MonadStack
17:13:25 <lambdabot> No results found
17:13:26 * djahandarie hasn't seen MonadStack
17:13:41 <Peaker> Ah, ski mentioned it
17:14:17 <Peaker> oh, I see, I think it's meant to let you nest type-level-numbered levels of a monad
17:16:23 <erus`> why does lex return a [(String, String)] rather than a (String, String)
17:16:40 <ski> Peaker : yeah, the idea was to have a type that was simultaneously `ContT o IO a',`ContT () (ContT o IO) a',`ContT () (ContT () (ContT o IO)) a',`ContT () (ContT () (ContT () (ContT o IO))) a',&c.
17:16:40 <saml> because it can be more than one (String,String)
17:16:45 <Twey> To account for ambiguous parses
17:16:52 <ion> MonadStack is basically like http://www.youtube.com/watch?v=CJQU22Ttpwc
17:17:28 <Peaker> ski: What do extra layers of ContT give you?
17:17:46 <ski> Peaker : `MonadStack' was a custom class only used internally in that project, no exported operation had `MonadStack' in its signature
17:17:55 <Peaker> ContT already stretches my mind -- nesting them multiple times is something I've not yet comprehended properly :)
17:17:57 <ski> Peaker : multiple levels of backtracking
17:18:12 <ski> Peaker : with two levels, you get basically Prolog backtracking
17:18:25 <ski> with three levels, you can backtrack the first level of backtracking
17:18:35 <Peaker> ski: if it's just for back-tracking, and not arbitrary jumping around -- isn't it enough to have EitherT?
17:18:37 <ski> with four, you can backtrack the second backtracking level
17:18:40 <ski> &c.
17:18:55 <saml> snap is the simplest web server in haskell? or warp?
17:19:00 <ski> Peaker : it's for backtracking backtracking itself, iteratively
17:19:15 <Peaker> ski: I understand, I think..
17:20:08 <ski> Peaker : i needed this to implement my idea for goals like `( ( ( ... => ... ) => ... ) => ... )'
17:20:17 <Peaker> ski: why is there a gap there?  If you have ContT wrapping it twice -- can't you backtrack the backtracks of the first layer?
17:20:51 <Peaker> (why did you say: 3 levels->1st backtrackable, 4 levels->2nd backtrackable?)
17:21:09 <ski> Peaker : you might be able to fold the final failure continuation into non-CPS, i'm not sure
17:21:31 <ski> i did it this way, because i could understand better what i was doing then
17:21:57 <erus`> > lex "123 123 123 + 123"
17:21:58 <lambdabot>   [("123"," 123 123 + 123")]
17:22:13 <erus`> saml: when is it more than one pair?
17:22:40 <ocharles> Sigh, anyone able to help with some more Haskell toolchain infrastructure stuff? I just installed uuid from cabal, but I can't get it to actually work: https://gist.github.com/1073130
17:22:41 <ski> erus` : when you define a function returning `ReadS a' that gives more than one pair
17:23:38 <Peaker> ski: if you're not confused by type-class hackery that duplicates ContT wrappers arbitrarily, you're in good shape :-)
17:23:41 <ski> > let foo :: ReadS Bool; foo s = map (flip (,) s) [False,True] in foo "bar"
17:23:42 <lambdabot>   [(False,"bar"),(True,"bar")]
17:23:46 <ski> erus` : there you go
17:23:50 <ocharles> https://gist.github.com/1073131 may also be of use
17:24:22 <ocharles> I seem to have all sorts of conflicts and stuff, but I dunno how to fix them
17:24:32 <rvn_> hey, is there any 'null' state for a Socket in Network.Socket?
17:24:42 <ski> Peaker : well, the `MonadStack' itself wasn't that confusing, i think. it was thinking about all the indefinite number of continuations levels that was confusing :)
17:25:01 <dpratt71> so my friend has this puzzle...
17:25:04 <Peaker> ski: I'm slightly confused by a composition of ParsecT and the list monad!  Though I think I'd be a whole lot better if I had better integration of a type-inference engine and my editor
17:25:07 <dpratt71> it's 4 blocks, each with 1 of 4 symbols on each side
17:25:21 <dpratt71> objective is to arrange the blocks in a row, so that each set of faces has unique symbols
17:25:33 <Peaker> ski: I have to spend a while to figure out if I want ParsecT []  or ListT Parsec ...
17:25:49 <dpratt71> I've coded a working solution in Haskell, but the code is pretty ugly
17:25:53 <ski> Peaker : hehe
17:26:03 <hpaste> dpratt71 pasted “ugly code” at http://hpaste.org/48858
17:26:25 <ivanm> preflex: seen chrisdone
17:26:26 <preflex>  chrisdone was last seen on #haskell 1 day, 15 hours, 20 minutes and 28 seconds ago, saying: shachaf: How would you do it without a map?
17:26:29 <saml> I did cabal install warp..  what's next?
17:26:39 <dpratt71> that's only part of the code (putting it all in seemed cruel)
17:26:39 <Peaker> ski: I wonder if the "average programmer" could grok all of these things.. If they are complicated -- or just too outside of the mainstream
17:27:16 <Peaker> (if you give the average programmer a good teacher and a year, at least)
17:28:03 <dpratt71> so if you're so inclined (and you aren't overwhelmed with horror), I would love some constructive...uh...feedback :)
17:28:42 <ski> Peaker : well .. there's a difference between *using* a library that uses some advanced typology (either internally, or (more advanced for user) in interfaces); and *writing* such a library
17:29:49 <ski> Peaker : i suspect that less people will be able to / bother to learn how to create things using advanced typology than those who will be able to use it
17:30:20 <ski> Peaker : still, a simple existential, or even a simple GADT shouldn't be that hard to manage, i think
17:30:32 <Peaker> Yeah, it's a bit troubling when mainstream programmers refuse to learn about that
17:31:01 * ski wonders whether "typology" sounds right
17:31:13 <ski> (cf. "advanced macrology" in Lisps)
17:31:37 <Peaker> Guido(Python fame) about Scala's "immense complexity":   "which contains such esoteric concepts as type erasures, variance annotations, existential types, polymorphic method types, and many more "
17:32:00 <Peaker> Bah, you're a freaking PL designer.. Take a day or two to learn what these things mean!
17:32:33 <ocharles> I'm pretty sure he knows what they mean
17:32:35 <ski> hehe, polymorphism and existentials aren't esoteric, imo .. but maybe that's just because i (think i) understand them
17:32:36 <hpc> polymorphic method types? esoteric?
17:32:56 <Peaker> ocharles: I really doubt he'd know what they mean and still call them "incredibly complex" or "obscure"
17:32:57 <hpc> even java has those
17:33:09 <ski> variance is slightly more advanced, maybe, but not much, i think
17:33:10 <ocharles> why? just because you know what something means doesn't mean they can't be complex
17:33:12 <hpc> (sort of, with ".." in method arguments)
17:33:25 <ocharles> the esoteric comment may be heavy handed, yes
17:33:26 <ski> i'm not sure what is meant by "type erasure", here
17:33:31 <Peaker> I think Guido is sort of "deliberately ignorant" about advanced types -- he's got a prejudice that they're useless/overly-complex, and so has no incentive/motivation to learn about them
17:33:36 <Peaker> (like many others)
17:34:00 <Peaker> ocharles: Which of these things is complex?
17:34:01 <ocharles> sigh, 90 minutes of battling with cabal and I still can't get this all to play nicely
17:34:07 * ski . o O ( "Blub" )
17:34:09 <Axman6> So I've been looking at the haskell entry for one of the shootout problems, and i can't seem to reproduce the results. when i run the haskell program, it's about three times faster than they're getting, while the go program is about the same speed, just a little slower: http://shootout.alioth.debian.org/u64q/benchmark.php?test=fannkuchredux&lang=all
17:34:19 <ocharles> Peaker: i'm not getting into this discussion
17:34:23 <Axman6> the haskell one is actually faster than the go implementation on my machine
17:34:34 <Peaker> ocharles: you already got into it.. maybe you mean you're getting out of it :-)
17:34:42 <dpratt71> I think Java uses type erasure to deal with generics (polymorphic types) in the JVM; probably Scala as well?
17:35:00 * ocharles compiles Crypto for the nth time
17:35:01 <dpratt71> i.e. the JVM doesn't know about generic types, I think
17:35:03 <ski> ah, ok, that
17:35:07 <lucian> dpratt71: uh, sort of
17:35:11 <lucian> i think
17:35:45 <lucian> scala tries to be java, if you squint a little
17:35:49 <Peaker> what does Scala do with variance declarations?
17:36:06 <Peaker> oh, right, subtyping stuff -- does it verify you don't mess up your variance declarations?
17:36:22 * ski doesn't know Scala, but imagines it's more or less similar to variance annotations in O'Caml
17:36:48 <ski> Peaker : well, it ought to, otherwise it's pretty useless
17:36:53 <lucian> ski: afaict, it's like java's actual specification of types in generics
17:37:13 <lucian> so saying List<Integer>, the Integer there is the variance declaration
17:37:18 <ski> lucian : i'm not sure what "java's actual specification of types in generics" is :)
17:37:22 * lucian dislikes scala
17:37:33 <ski> `Integer' is a type, not a variance
17:37:54 <lucian> right, but putting it there is a variance declaration, afaict. in java, anyway
17:37:55 <ski> the variance here is that `List' is covariant (i assume) in it's argument
17:37:59 <dpratt71> variance annotations, is that anything like in/out modifiers on generic parameters in C#?
17:38:18 <ski> so if `tau_0' is a subtype of `tau_1', then `List<tau_0>' is a subtype of `List<tau_1>'
17:38:25 <dpratt71> ski: I think you may have just answered my question
17:38:54 <ski> in O'Caml, you'd annotate this like  type +'a list = ...
17:39:12 <ski> the `+' meaning "covariant" and `-' meaning "contravariant"
17:39:16 * lucian is just learning haskell
17:39:16 <Peaker> in Haskell you make a Functor instance :)
17:39:27 <Peaker> (or a CoFunctor instance)
17:39:48 <ski> Peaker : yeah, but variance declarations work for type constructors with multiple arguments, as well
17:40:57 <ski> (but you can't pass a type constructor to another type constructor in O'Caml (or SML) .. otherwise i suppose one'd need some higher variant of variances as well)
17:41:25 <ski> hm, i suppose we could put this info in the kind
17:41:45 <Peaker> ski: you can have a Functor instance, and a CoFunctor instance on the Flip of...
17:42:01 <ski> so `+ * -> *' would be the kind of covariant type constructors, and `- * -> *' the kind of contravariant type constructors
17:42:27 <Peaker> Not having higher-kinded type params in SML/O'Caml sounds like a severe limitation
17:42:32 <ski> both of those would be subkinds of `* -> *', which guarantees no variance in the argument
17:42:38 <Peaker> Are they less powerful due to this, or is there some Functor-related workaround?
17:43:04 <ski> you can use module functors, to some extent, yes
17:43:26 <ski> (which are not related to haskell `Functor's)
17:43:32 <Peaker> man, *ML sucks :-)
17:43:43 <ski> well, module functors are great :)
17:43:59 <ski> now, if only we had those *and* the other nice type things in Haskell ..
17:44:10 <Peaker> I think I'd much rather emulate them with type-classes, than emulate higher-kinded polymorphism and type-classes with module functors :)
17:44:27 <ski> with module functors you can create types which (in an abstract-type-sense) depends on values
17:44:27 <Peaker> given that they're all of equivalent expressive power?
17:44:39 <Peaker> (well, compile-time type-checking power, if there's a term for that)
17:44:54 <sully> they aren't, really
17:44:57 <Peaker> ski: sort of like templates?
17:45:04 <Peaker> ski: with non-type args?
17:46:20 <ski> Peaker : i mean a module functor taking a module containing an "element" type, and an order function on that, and creating a new module containing a "container" type, which has elements of the previous type, and which is internally sorted wrt the given order
17:46:58 <ski> Peaker : so you can make two modules for strings, one using the usual lexicographic ordering, the other first case-folding, using case only for ties
17:48:05 <dpratt71> my instinct would be that variance annotations would not be very useful in Haskell, but I can't quite reason about why
17:48:09 <ski> Peaker : and the module functor will create two different (incompatible) container types (and operations on them) .. internally they are structured the same, but they rely on different orders, so it would not be good if it was possible to merge two collections which had been constructed using different orders
17:48:21 <Peaker> dpratt71: no sub-typing, and we already have Functor/CoFunctor type-classes
17:48:24 <dpratt71> I think maybe it has something to do with the lack of sub-typing
17:48:28 <ski> Peaker : in that sense the two new container types depend on values (the ordering functions)
17:48:40 <Peaker> ski: similarly to depending on an Ord instance?
17:48:58 <dpratt71> Peaker: :)
17:49:00 <ski> Peaker : no, similar to depending on an `a -> a -> Ordering' function
17:49:13 <Peaker> ski: well, you give that function as an argument to the module functor?
17:49:30 <ski> Peaker : you can simulate this in Haskell (at least in some cases), using existential quantified records of operations
17:49:42 <ski> Peaker : yeah, that's what you do
17:49:46 <dpratt71> Peaker: I really was typing that before you answered me :) I'm just a slow typer :)
17:49:54 <ski> (sully : which aren't really what ?)
17:50:07 <Peaker> dpratt71: ah.. I type ~115 WPM when I try :-)
17:50:29 <ski> Peaker : but it's a bit painful to use this encoding in Haskell -- it would be better with direct support
17:50:34 <Peaker> ski: Well, preventing the merge you were talking about is easy if you just use type-associated Ord instances?
17:50:46 <dpratt71> Peaker: !! I've never wanted to depress myself by measuring my WPM :)
17:50:59 <ski> Peaker : yeah, the point here was that the same element type `String' was used in both cases
17:51:09 <Peaker> dpratt71: I've just recently been shown a site (I think "type-racer") which measures the WPM and lets you race others
17:51:24 <dpratt71> I'm not even sure I could type random letters at 115 WPM :)
17:51:31 <Peaker> ski: well, that's what newtypes are for -- sounds that in this case they are a pure-win because they disallow incorrect merges
17:51:55 <ski> (Peaker : and with some extensions, you can even apply module functors at run-time, letting the comparision function be a run-time value)
17:52:30 <ski> Peaker : well, the module functor approach also disallows incorrect merges .. only in a different way
17:52:59 <Peaker> ski: by associating the two container types with different comparison functions -- but still have two different types?
17:53:16 <dpratt71> I took a typing class in HS...
17:53:48 <dpratt71> ...I told the teacher that in the future nobody would need to type because of computer voice recognition...
17:54:06 <dpratt71> ...extremely ironic, given my eventual profession
17:54:30 <ski> Peaker : from `String' with two different comparision functions, you'll get two new types `A.StringContainer' and `B.StringContainer' (`A' and `B' being the name you've given to the modules resulting from the module functor applications)
17:54:31 <cafesofie> you mean you don't write your haskell in the google voice search box?
17:54:41 <cafesofie> maybe i'm just too hip
17:54:48 <dpratt71> cafesofie: :)
17:54:49 <Peaker> ski: ah..
17:55:00 <ski> basically something like (pseudo-Haskell)
17:55:18 <dpratt71> as hard as Haskell might be to dicate, C# would be many times worse, I am sure
17:55:27 <Peaker> ski: Can you write functions that are polymorphic to both of these, as you can write functions polymorphic to   Map String   and Map DiffOrdString  ?
17:55:29 <dpratt71> (C# is what I get paid to code in)
17:55:57 <ski>   import (MakeSet (module where type T = String; cmp = compare)) as A
17:55:57 <ski>   import (MakeSet (module where type T = String; cmp = otherCompare)) as B
17:56:29 <Peaker> ski: How do I write a function that's portable to any MakeSet result type?
17:56:45 <ski> Peaker : what do you mean by "polymorphic to both of these" ?
17:57:00 <Peaker> ski: myFunc :: Map k v -> ...
17:57:20 <Peaker> ski: would be applicable on both Map String Int   and Map NewTypedString Int
17:57:33 <ski> Peaker : you don't. each application of `MakeSet' will essentially create a new type (it's basically an existential semantically, so this shouldn't be surprising)
17:58:02 <ski> Peaker : also, the resulting modules *won't* contain parametric types, they will contain types of kind `*'
17:58:08 <Peaker> ski: so there's no way to write functions outside the MakeSet module that work with any container type made by MakeSet?
17:58:25 <ski> (well, you could add type parameters, but that's orthogonal to this)
17:58:47 <Peaker> Or do I place my code in a module functor and then take the made Set module as an argument?
17:58:51 <ski> Peaker : right. so these behave differently from `Set Foo'
17:58:58 <Peaker> This sounds clumsy?
17:59:42 <Peaker> It might be because I'm so used to Haskell's approach, but at least for this -- Data.Set, Ord and newtype seem simpler/cleaner
18:00:05 <ski> (Peaker : hm, sully just said type classes and module functors are not equivalent in power .. he's afk now, though)
18:00:31 <Peaker> I read that type-classes + type/data indices/families  are equivalent to first class modules/functors
18:00:53 <ski> Peaker : yeah, i think probably each approach have strengths and weaknesses (at least in terms of how easy it is to do a certain thing)
18:01:16 <ski> yeah, it might be, if you add families
18:01:48 <ski> (but i wonder how nice / non-nice the encoding would be .. even if it's only a manual encoding for each case)
18:02:14 <ddarius> You don't need type families though they do make some things quite a bit nicer.
18:02:38 <Peaker> It *feels* (unsubstantiated intuition, may be wrong) to me that module functors are work arounds, and not fundamental solutions to the problem --  instead of addressing the weakness in the type-system,  it seems like an addition of a meta-programming layer to generate programs of the weaker types that they can represent
18:02:50 <ddarius> The encoding isn't too bad, encoding ML into Haskell.  The other way is bad, for, what should be, obviously reasons.
18:03:10 <ski> Peaker : which problem are you considering, now ?
18:03:25 <Peaker> ski: ad-hoc polymorphism
18:03:35 * ski isn't really sure they are meant to address the same problem
18:04:02 <Peaker> my semi-ignorant knowledge of module functors suggests they're a syntactic solution for a semantic problem
18:04:30 <ddarius> They don't operate syntactically.
18:04:35 <ski> well, you can use module functors to abstract, at a module level
18:04:54 <ski> say that you're writing a bunch of modules which uses priority queues
18:04:57 <Peaker> I would love to see some comparisons:  "Things that are nice with module functors" (I already know of "nice with type-classes" examples)
18:05:13 <Peaker> I've not seen anything convincing yet -- that wasn't just-as-nice with type-classes or otherwise
18:05:19 <ski> now, you might not want to hard-code into the modules which implementation of priority queues you want to use
18:05:40 <ski> to you make a module functor that takes a priority queue implementation, and generates the module you wanted
18:05:42 <Peaker> ski: Why is a module signature better than a PQ type-class?
18:06:08 <ski> then at a single place, you connect together all the functors, specifying only there which implementation you want to use
18:07:05 <Peaker> Can you do the equivalent of a "sub-class" of a PQ type-class with module functors?
18:07:07 <ski> Peaker : if you want to define `data Foo = F (..(PriorityQueue Blah)..)', then to abstract here, you must make `PriorityQueue' an explicit argument of `Foo'
18:07:28 <ddarius> The problem with type classes is that they are, obviously, determining semantics based on type.  Often times there is not a unique semantics for a given type, in which case type classes become awkward.
18:07:31 * edwardk bounces up and down excitedly
18:07:42 <ddarius> Shae has replaced edwardk!
18:08:29 <Peaker> ski: I see -- the type-parameter pollutes more declarations
18:09:08 <Peaker> how do module functors not work syntactically then?  How is a module arg represented at runtime if it is not macro-expanded?
18:09:09 * ski idly wonders where edwardk found the mind-swapping device, and what he's done with Edward
18:09:44 <edwardk> i built a monad out of covectors in terms of linear functionals from contravariant vectors, which basically winds up looking like Cont with a couple of funny restrictions on it, and it let me encode the monoid ring of a ring perfectly without needing to lean on that hackish Partitionable class.
18:09:46 <dmead> edwardk, coming to haci phi this year?
18:09:54 <edwardk> dmead: definitely
18:09:56 <ddarius> Peaker: The same way types are (which is not surprising as functors are extensions to the type system.)
18:10:02 <ivanm> edwardk: sorry, was anyone meant to understand that? :p
18:10:02 <ddarius> s/functors/modules/
18:10:23 <Peaker> ddarius: so they're erased, like types?
18:10:36 <djahandarie> edwardk, hey, let's figure out this hotel thing
18:10:52 <edwardk> ivanm: the monoid ring of a ring is basically where your polynomials come from, so it working is a very good thing ;)
18:11:01 <edwardk> djahandarie: sure thing.
18:11:03 <ivanm> heh
18:11:12 <ivanm> but _understanding_ how it works would also be nice!
18:11:37 <ski> Peaker : "Can you do the equivalent of a \"sub-class\" of a PQ type-class with module functors?" -- you can make a module signature (think "type/interface of modules") which extends another one
18:11:44 <ddarius> Peaker: More or less.
18:11:45 * ivanm wonders if it's possible to make a chatbot that would make statements that can't be distinguished from edwardk-speak :p
18:12:19 <ddarius> ivanm: Just copy edwardk's source code.
18:12:35 <Peaker> ski, ddarius: Ok, thanks for the explanations
18:12:35 <edwardk> ddarius: and paste links to my blog from time to time
18:12:36 <ivanm> heh
18:12:37 <Peaker> good night!
18:13:01 <ski> Peaker : in case you're generating modules at run-time (with extensions, the basic system doesn't allow that), i assume it's basically represented as a record of operations (and maybe type-layouts for GC or something)
18:13:03 <ivanm> g'night Peaker
18:13:05 <int80_h> have a good evening #haskell! Thanks for the help, things are moving along.
18:13:15 <edwardk> https://github.com/ekmett/algebra/blob/master/Numeric/Functional/Linear.hs lines 64-72 made me very happy
18:13:50 <ski> edwardk : "monoid ring of a ring" ?
18:13:51 <cmccann> aw, did I miss a conversation about subtyping?
18:14:03 <ski> cmccann : more about module functors, really
18:14:15 <cmccann> saw some stuff about variance in backscroll
18:14:19 <edwardk> http://en.wikipedia.org/wiki/Group_ring http://en.wikipedia.org/wiki/Monoid_ring
18:14:41 <cmccann> I enjoy variance in type systems with subtype polymorphism because nobody seems to understand it
18:14:51 <cmccann> subtyping is too difficult for average programmers I'm pretty sure
18:15:44 <dmead> edwardk, mm quite. *monocle*
18:16:22 <edwardk> so to use it as a ring of polynomials you define newtype P x = P Int; instance Multiplicative (P x) where P n * P m = P (n + m) to represent the power basis for polynomials, and you can use the representation of covectors as linear functionals from the vector space to directly encode your polynomial
18:16:33 <sshc> > length $ take 9 $ repeat ()
18:16:34 <lambdabot>   9
18:16:37 <sshc> > length $ take 9223372036854775808 $ repeat ()
18:16:38 <lambdabot>   0
18:16:59 <ddarius> cmccann: Subtyping, to me, is just implicit insertion of (injective) coercions.  Why subtyping behaves the way it does follows readily from that.
18:17:45 <dpratt71> I like how MS has been explaining the new variance annotations added to the CLR, which goes something like: some things that you thought should work before, but didn't, will now work
18:17:56 <cmccann> ddarius, yeah basically but for some reason people find it confusing because sometimes stuff is covariant and sometimes contravariant
18:18:15 <mee> :t 9223372036854775808 :: Int
18:18:16 <lambdabot> Int
18:18:25 <edwardk> dpratt71: sok they are still stupid enough to let you covariantly subtype arrays
18:18:33 <ddarius> Sometimes coercions are precomposed and sometimes postcomposed.
18:18:35 <cmccann> hahaha
18:18:47 <dmead> Cale, starcraft tonight?
18:18:49 <dpratt71> edwardk: yeah, that's pretty bizzarre
18:19:07 <edwardk> dpratt71: it is an infelicity they picked up from java. =/
18:19:15 <cmccann> edwardk, they can't remove that for backcompat reasons I guess
18:19:26 <cmccann> nevermind that it's an obvious bug and any code relying on it is buggy
18:19:26 * dpratt71 looks up infelicity
18:19:32 <edwardk> cmccann: sure
18:19:44 <ddarius> @wn infelicity
18:19:45 <lambdabot> *** "infelicity" wn "WordNet (r) 2.0"
18:19:45 <lambdabot> infelicity
18:19:46 <lambdabot>      n : inappropriate and unpleasing manner or style (especially
18:19:46 <lambdabot>          manner or style of expression) [ant: {felicity}]
18:20:06 <cmccann> does scala have a similar problem? or did they ignore java and do it properly?
18:20:17 * ddarius has no idea why they couldn't just limit that to a read-only view (and contravariance to a write-only view).
18:20:22 <Cale> dmead: I woke up at something like 3am and am already quite sleepy, but I could try :)
18:20:25 <dpratt71> is there anything lambdabot can't do?
18:20:29 <edwardk> they basically ignored java on this one ;)
18:20:40 <edwardk> scala covariance works as expected with arrays
18:20:41 <cmccann> edwardk, good, that's what I thought
18:21:02 <ddarius> I can't see Odersky allowing that.
18:21:20 <edwardk> they have some hacks in the compiler that let them make some dirty subtyng relationships between things in their collections api
18:21:29 <edwardk> unfortunately those hacks don't generalize to higher kinds
18:21:48 <Cale> Are there any other SC2 playing Haskellers? :)
18:21:51 <edwardk> so they are useless for me when i go to make things like Mu into a subtype of Nu but only in the covariant case
18:21:57 <cmccann> getting arrays right already puts them ahead of basically everyone else I think
18:22:20 <cmccann> since Haskell sorta loses by default due to not really having a notion of subtyping
18:22:21 <ddarius> Cale: I doubt you and dmead are the only ones.
18:22:32 <ddarius> That said, I've never actually seen SC2 played.
18:22:39 <ddarius> Let alone played it myself.
18:22:44 <Cale> Well, sure. Just wondering if there are more among the people who are here right now :)
18:22:58 <ddarius> dmead: Cale is trying to pawn you off.
18:23:04 <Cale> It's a decent game. If you like RTS, you should try it. :)
18:23:23 <ddarius> I don't play video games.
18:23:42 <ddarius> The most I do is every once in a while play Stepmania for a bit.
18:24:00 <Cale> Well, I need the practice partners. :)  I prefer playing with people I know to playing random people on the ladder.
18:24:15 <dpratt71> Cale: I researched it, would like to play it, but Haskell and my family get all my free time :)
18:24:17 <pr> Cale: do you play on NA?
18:24:27 <Cale> yeah
18:24:50 <pr> ah, that's unfortunate then, heh
18:25:01 <pr> (playing on EU myself from time to time)
18:25:25 <dpratt71> it seems like one of those games where you could have huge differences of skill level
18:25:35 <Cale> It is one of those games
18:26:22 <Cale> There are comparisons with chess and go, as well as games like poker, because of the partial information aspect.
18:26:45 <dpratt71> Cale: interesting
18:27:08 <dpratt71> now I know what all the games that scare me have in common :)
18:27:20 <ddarius> They are like each other?
18:28:05 <cmccann> ddarius, what things that have something in common have in common, is sharing a common element
18:29:52 <Cale> What things that have something in common have in common, is a pullback square.
18:30:05 <cmccann> heh
18:30:29 <edwardk> haha
18:30:31 <dpratt71> hey, I was just reading about pullbacks, pushouts, etc.; it almost made sense, too :)
18:30:57 <dpratt71> or should I say: ha ha, good one Cale
18:31:17 <edwardk> yo dawg, i hear you like pullbacks
18:32:33 <dpratt71> what's the other things that are like pullbacks, pushouts, but more...general?
18:32:43 <Cale> limit/colimit
18:32:46 <dpratt71> right!
18:33:04 <Cale> (antirespectively)
18:33:04 <djahandarie> I like ends because they let me use integral signs
18:33:10 <dpratt71> (or at least, that sounds right)
18:33:32 <dpratt71> you mean pushbacks, pullouts are the more general thing, probably
18:34:24 <ddarius> Down with (co)limits, up with (co)ends.
18:34:55 <dpratt71> oh dear, there are things called 'ends'?
18:34:59 <Cale> I mean that pullbacks are examples of colimits and pushouts are examples of limits (so when I said limit/colimit, the order was swapped)
18:35:08 <ddarius> Cale: You have that backwards.
18:35:10 <dpratt71> I haven't figured out limits yet!
18:35:19 <Cale> errrr
18:35:20 <dpratt71> Cale: oh
18:35:35 <Cale> Yes I do.
18:35:48 <dpratt71> so...respectively after all?
18:35:54 <ddarius> Yep.
18:35:54 <Cale> yeah
18:35:58 <dpratt71> ok
18:36:20 <dpratt71> I was looking at some slides the other day about all that. I'll have to find them again
18:36:24 <Cale> yeah, pushouts are like glued together disjoint unions
18:36:47 <ddarius> dpratt71: (Co)ends are at a nice level and have very nice manipulations.
18:36:49 <edwardk> great now well get pushout tutorials all over the internet. thanks cale
18:37:01 <Cale> lol
18:37:06 <ddarius> Gluing is a pushout, or colimit more generally.
18:37:42 <cmccann> edwardk, sometimes I get tempted to write monad tutorial-style-tutorials for mundane concepts in mainstream programming languages
18:37:56 <cmccann> see how hard it would be to convince people that everything is difficult
18:38:10 <ivanm> cmccann: zomg that sounds hard!
18:38:12 <ivanm> :p
18:38:47 <edwardk> hah. give them the strict knot tying version of object oriented programming semantics, then afterwards the haskell stuff won't seem so bad
18:39:03 <cmccann> the challenge would be finding things that are as simple as monads to abuse that way, most mainstream stuff is actually crazy complicated if you take it seriously, so oh well
18:39:20 * dpratt71 is starting a blog post titled 'Pushouts are Like Double-Shelled Tacos'
18:39:34 <Cale> and pullbacks are like graphs of equations
18:39:44 * ddarius recommends comparing the pushout of the two graph homomorphisms * -> [* -> *] to their coequalizer.
18:39:58 <edwardk> 'categories are like categories
18:40:06 <cmccann> somewhere around here I have a half-baked explanation of dependency injection frameworks that describes them in terms of CPS transforms and existential types
18:40:10 <djahandarie> @quote dolio monad
18:40:10 <lambdabot> dolio says: Monad are just monads in the 2-category of categories.
18:40:17 <cmccann> heh
18:40:52 <dpratt71> cmccann: I understand DI frameworks, maybe I should read that explanation backwards
18:41:04 <ddarius> @quote copumpkin lax.functor
18:41:04 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
18:41:38 <cmccann> dpratt71, probably not, it was not written with the goal of promoting understanding of anything
18:42:14 <saml> what's a good html template?
18:42:18 <dpratt71> cmccann: an explanation not written to promote understanding? interesting
18:42:41 <cmccann> saml, try <html>{ stuff goes here }</html>
18:42:44 <cmccann> that's a pretty good template
18:42:49 <cmccann> very versatile
18:42:59 <saml> cmccann, which libarry does that?
18:43:16 <cmccann> dpratt71, read as "it was an overelaborate joke I got sick of, not a real explanation" :]
18:43:25 <cmccann> saml, sorry, I'm making dumb jokes, ignore that :P
18:43:28 <ddarius> Another fun exercise from TTT is calculating the coequalizer of the two functors 1 -> 2.
18:43:29 <dpratt71> cmccann: I see
18:43:47 <dpratt71> cmccann: at least it was not an overly elaborate joke
18:43:47 * djahandarie notes that he should really read TTT
18:43:52 <Cale> <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"> <html>{ stuff goes here }</html>
18:43:57 <parcs> saml: <!DOCTYPE html><title>bare minimum for a valid html5 document</title>
18:44:13 <cmccann> Cale, oh, that's a nice one, mind if I use it?
18:44:18 <saml> so i should write a parser that replaces  ${some markers} ..
18:44:27 <saml> then i would need to call..
18:44:34 <dpratt71> oh dear
18:44:35 <saml> haskell functions? or Data.Map ?
18:44:38 <Cale> saml: Probably better just to write a function whose result is some HTML
18:44:46 <pikhq> saml: Then you'd have about a tenth of a Tcl interpreter.
18:44:46 <saml> no.. i don't like that
18:44:47 * cmccann assumes TTT = Toposes, Triples, and Theories or whatever the exact title was
18:44:49 <Cale> saml: and whose parameters say how to fill in the bits :)
18:45:07 <saml> yah i don't like that..
18:45:11 <Cale> why not?
18:45:15 <djahandarie> cmccann, yep
18:45:36 <saml> that's easy to implement.. but it is for html output only
18:45:37 <Cale> saml: You can use an HTML-generating combinator library which will ensure that the end result is always valid HTML
18:45:48 <cmccann> djahandarie, I bought a copy of that from a used bookstore a while back :]
18:45:49 <Cale> (or XML or whatever)
18:45:53 <saml> with parsing + rendering.. it can be used for many different things
18:46:04 <cmccann> I think it's available online, but eh, books
18:46:04 <ddarius> djahandarie: Have fun.
18:46:09 <mee> saml: check out http://www.haskell.org/haskellwiki/Web/Libraries/Templating
18:46:13 <ddarius> It is readily available online.
18:46:13 <Cale> Sure, but you asked for an HTML template.
18:46:15 <saml> mee, thanks
18:46:52 <Cale> If you just want to generate arbitrary strings, Haskell has lots of operations on a variety of types of those :)
18:47:04 <ocharles> I apparently have network-2.2.1.7 and network-2.3.04 installed (ghc-pkg list), but when I run my code it says it can't find network-2.3.0.2
18:47:05 <cmccann> it's sitting on my shelf next to The Lambda Calculus: Its Syntax and Semantics, in the section of "things I really should read"
18:47:15 <ocharles> does anyone know why that could be?
18:47:57 <Cale> ocharles: well... that is neither of those versions
18:48:06 <ocharles> exactly.
18:48:15 <ocharles> and thus it doesn't work and errors
18:48:32 <ocharles> i don't get where it's getting this 2.3.0.2 from though
18:48:48 <Cale> ocharles: what do you mean by "run my code"... in ghci? Are you building a cabal package?
18:48:51 <monochrom> sounds really messed up
18:48:57 <ocharles> ghc --make
18:49:17 <ocharles> paste coming up
18:49:19 <Cale> ghc-pkg check
18:49:22 <ocharles> with -v
18:49:24 <luite> saml: there's also heist, popular with snap websites. hamlet is ok, but it isn't really html syntax, and some people don't like it because it uses quasiquoting
18:49:46 <saml> yah i don't like heist because it does stuff like <bind/>
18:49:54 <saml> i think i'll write my own
18:49:56 <Cale> Probably one of the packages you're trying to use depends on network-2.3.0.2, but then something uninstalled that
18:49:59 <ocharles> http://gist.github.com/1073208
18:50:09 <ocharles> I like blaze html
18:50:51 <luite> saml: hamlet has its own indentation based syntax, a bit less verbose, but different
18:51:00 <ocharles> Cale: sounds likely, but I wouldn't know how to debug that
18:51:10 <ocharles> should I just start recompiling things?
18:51:22 <Cale> ocharles: you're using your distribution's package for ghc?
18:51:37 <ocharles> yea
18:52:16 <Cale> Probably what happened is that it went and updated all your libraries on you and deleted the old ones that your locally installed packages relied on
18:52:26 <saml> i may just use html combinator like blaze
18:52:33 <monochrom> 6.12.1 is buggy. see my http://www.vex.net/~trebla/haskell/sicp.xhtml#ghc6121 for the 6.12.1-only bug
18:52:43 <ocharles> I haven't updated my distro for ages
18:52:56 <luite> saml: yeah I guess the higher level template things are based on that
18:52:58 <monochrom> the bug affects everyone who tries to have both --global and --user
18:53:01 <Cale> I see
18:53:11 <ocharles> but it's possible
18:53:17 <cmccann> ddarius, been meaning to ask you, know of any geometric algebra implemention in Haskell? since that seems to be a topic you're fond of.
18:53:18 <ocharles> so how should I fix it?
18:53:21 <Cale> ocharles: It's probably what monochrom is suggesting
18:53:33 <Cale> Update to a current version of GHC is probably best.
18:53:45 <Cale> 6.12.1 is pretty old
18:53:55 <ocharles> ok, running a distribution upgrade now
18:53:57 <monochrom> of course, this bug doesn't explain your current phantom-package-out-of-the-blue problem, but I say why bother bearing the time bomb with you
18:54:14 <monochrom> if it is broken, don't fix it
18:54:16 * ocharles nods
18:54:50 <luite> is there any news on the improved cabal dependency solver?
18:55:00 <Cale> I usually don't trust my distribution to get anything related to Haskell right, and just install the generic linux binary of GHC along with cabal-install. I install ghc to /usr/local and then all packages from that point on as user
18:55:08 <iratsu> is there a more idiomatic way to write the following? foldr1 (\x y -> x ++ " " ++ y) (map (\o -> let (p, q) = o in (show p ++ show q)) l)
18:55:29 <ocharles> cale: that sounds like what I do with perl
18:55:38 <cmccann> I'm running Ubuntu and do exactly the same thing Cale does
18:55:43 <saml> is there Everything monad that i can run any monad?
18:55:44 <saml> IO ?
18:55:50 <cmccann> well, not exactly, I'm not installing them on his machine
18:55:50 <Cale> saml: no
18:55:51 <monochrom> there isn't
18:56:03 <saml> it'll be so nice.. then it'd be like C
18:56:05 <Cale> saml: and you're thinking of monads in the wrong way
18:56:13 <cmccann> that would be the opposite of nice
18:56:18 <ocharles> Cale: what do you mean by generic linux binary? does GHC have binaries for download?
18:56:28 <Cale> Monad is a shape that part of a library's API might fit into
18:56:45 <Cale> and where it does, we have some polymorphic functions which will work together with that library
18:56:53 <saml> what if you want to use multiple libraries together?
18:57:03 <saml> monad transformer is the only option?
18:57:08 * hackagebot buildbox 1.5.1.1 - Rehackable components for writing buildbots and test harnesses.  http://hackage.haskell.org/package/buildbox-1.5.1.1 (BenLippmeier)
18:57:09 <Cale> What if you want to use multiple libraries together without monads?
18:57:13 <Cale> It's the same thing.
18:57:32 <saml> yah.. in Java,i can import libraries and use them
18:57:35 <Cale> mhm
18:57:47 * cmccann imports libraries in Haskell and uses them all the time
18:57:52 <Cale> But they have different classes in them?
18:58:01 <Cale> How do you ever manage to use them together?
18:58:11 <saml> so, i have multiple monads.. but i want to pipe values in a monad A  to monad B  to mand C back to monad A
18:58:48 <cmccann> not all monads have a sensible concept of "a value in them"
18:58:52 <saml> in java, i don't worry about those. i just  do  a.f();  b.f(); c.f(); d.f();
18:58:52 <Cale> saml: That doesn't make sense.
18:58:59 <saml> in one code block
18:59:03 <cmccann> and the ones that do, usually have some sort of "run" function that gets the value out
18:59:24 <Cale> saml: I'll pick your monads for you
18:59:29 <Cale> A = [] (list)
18:59:32 <Cale> B = Maybe
18:59:43 <Cale> C = IO
18:59:52 <Cale> what does piping values mean now?
19:00:23 <ivanm> preflex: seen bos
19:00:24 <preflex>  bos was last seen on #ghc 1 day, 5 hours, 4 minutes and 59 seconds ago, saying: yay! https://jenkins.serpentine.com//
19:00:33 <monochrom> I don't think "a.f();  b.f(); c.f(); d.f();" represents any interaction at all between them
19:00:45 <saml> I want to:   let t = currentTime; openDatabase.. do something..    log.info(currentTime - t);   do other things.
19:01:19 <luite> those are usually all in the IO monad
19:01:20 <Cale> saml: currentTime sounds like something which is an IO action?
19:01:26 <monochrom> well getCurrentTime and openDatabase and log-whatever are all happily in the same IO
19:01:34 <saml> currentTime would be  Sys Float   or IO Int
19:01:47 <saml> openDatabase  would be WebScale monad
19:01:49 <Cale> Sys?
19:01:57 <saml> IO
19:02:14 <Cale> Where's the WebScale monad defined?
19:02:19 <Cale> (haddock?)
19:02:25 <saml> no.. i'm making stuff up
19:02:42 <saml> to explain what I am trying to achieve .
19:02:43 <monochrom> be careful not to make stuff up that happens to not work
19:03:22 <cmccann> maybe it would help if you explain what you are actually trying to achieve, instead of making up things that aren't what you're trying to achieve?
19:03:36 <saml> I have a Java method that does different kinds of IO.. how would I write in Haskell?
19:04:13 <saml> there's exception, logging, databse interaction, http communication... in one method (code block)
19:04:15 <monochrom> well there is only one "IO"
19:04:22 <Cale> Okay, then what is the purpose of the WebScale monad and how does it differ from IO? What computations belong to it?
19:04:29 <ocharles> cmccann: I don't think he even knows that, in all honesty
19:04:37 <saml> so all these are in IO monad in haskell
19:04:42 <Cale> (All I know about it right now is that it's supposed to be a monad, which doesn't tell me much about what it is)
19:04:56 <cmccann> Cale, it tells you it's like a burrito, I suppose
19:05:00 <Cale> rofl
19:05:37 <cmccann> "I have a pork burrito in a flour tortilla and a chicken burrito in a corn tortilla, how do I eat both"
19:05:59 <bgamari> I have a recursive function which iterates through a list and takes lots of state parameters, few of which will be changed in any given iteration
19:06:10 <bgamari> What is the best way to reduce the amount of boilerplate necessary
19:06:19 <saml> bgamari, monad
19:06:32 <saml> threaded arguments can be part of monad
19:06:34 <bgamari> I was afraid someone would say that ;)
19:06:45 <saml> look at StateMonad
19:06:48 <cmccann> bgamari, depends on how the state values are being updated
19:06:49 <bgamari> Looks like I'll finally have to actually understand them
19:06:56 <bgamari> cmccann: Oh?
19:06:59 <monochrom> using StateT may or may not reduce boilerplate
19:07:04 <cmccann> in a lot of cases all you really need is a fold
19:07:15 <bgamari> saml: I've used StateMonad before actually
19:07:24 <monochrom> yes, just do foldl' or something
19:07:42 <cmccann> if the result of the state changes are mostly localized to consecutive iterations, a foldl is probably simpler
19:07:48 <bgamari> saml: But it didn't really help with the superfluous argument passing
19:07:50 <saml> so, you can't do that in haskell, right?
19:07:55 <saml> logging and stuff
19:08:09 <cmccann> @faq can haskell do logging and stuff?
19:08:09 <lambdabot> The answer is: Yes! Haskell can do that.
19:08:17 <cmccann> looks like you can
19:08:20 <mjo> bgamari: Define a Parameters type, then recurse with, let newparams = oldparams { x = y... } in f newparams
19:08:39 <bgamari> monochrom: Hmm, I'm also failing to see how foldl' will reduce the argument passing
19:08:43 <Cale> bgamari: I agree with mjo and cmccann
19:08:54 <saml> logging is in IO?
19:08:55 <luite> saml: often, applications have some kind of application monad, built on top of IO
19:08:55 <Cale> foldl' won't reduce the argument passing
19:09:09 <bgamari> mjo: ahh
19:09:13 <Cale> it (possibly) gets rid of the other boilerplate, the recursion
19:09:35 <cmccann> bgamari, you're passing the state values one way or another, the question is what's the syntactically and conceptually simplest way to do so
19:09:36 <bgamari> mjo: I didn't realize you could do incremental updates with the record syntax
19:09:41 <Cale> saml: logging is a kind of I/O, since it's output to disk
19:09:46 <mjo> Yep
19:09:54 <luite> saml: the application specific monad can simplify lots of things, it could provide logging for example... but logging still needs to be IO
19:10:02 <bgamari> that makes things much easier
19:10:08 <mjo> It prevents suicide when you have a type with like 35 fields
19:10:31 <bgamari> I would believe that
19:10:37 <saml> how do you use logging in pure function?
19:10:48 <saml> elevate pure function into monadic action?
19:10:51 <cmccann> saml, logging a pure function is a mostly incoherent concept
19:10:57 <monochrom> @type foldl
19:10:58 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
19:11:00 <Cale> btw, I just thought I'd drag this up from the past and put it here http://www.xtranormal.com/watch/6995033/mongo-db-is-web-scale
19:11:34 <saml> cmccann, why do you think it's incoherent?
19:11:42 <saml> when the function is purely for logging?
19:11:48 <bgamari> Is there any way to pattern match on a field of a record?
19:11:56 <cmccann> saml, because logging implies things about evaluation that don't apply to pure functions in Haskell
19:11:57 <bgamari> a guard I guess?
19:12:14 <ocharles> ok, haskell platform 2011 and ghc 7.0.3 3 setup!
19:12:16 <saml> a record is just product?
19:12:17 <Cale> saml: Tuple the result with additional results?
19:12:29 <Cale> (a log of how the result was computed, perhaps?)
19:12:38 <monochrom> bgamari: I have an example at http://www.vex.net/~trebla/haskell/testbed.cgi
19:13:23 <saml> it would be helpful if people actually guides through examples
19:13:28 <cmccann> logging in most languages tends to encompass several things, including a record of intermediate values and a record of steps in evaluation
19:13:36 <bgamari> monochrom: Awesome. I think I have it
19:13:45 <saml> how do you log in haskell?
19:13:58 <saml> http://hackage.haskell.org/packages/archive/hslogger/latest/doc/html/System-Log-Logger.html   ??
19:14:10 <monochrom> it would help if questions were not general
19:14:11 <Cale> saml: That's kind of a general question... what are you trying to log?
19:14:20 <cmccann> saml, your questions make no sense
19:14:24 <saml> ...
19:14:29 <saml> that's the problem of haskell
19:14:34 <Cale> How would you answer the same question for Java?
19:14:44 <saml> slf4j
19:14:48 <saml> in python, logging
19:14:58 <saml> how do you log in haskell?
19:15:03 <cmccann> saml, you are asking very general questions that don't have a single, direct answer without more context
19:15:22 <monochrom> I would try hPutStrLn stderr first
19:15:42 <saml> what if I want to hPutStrLn  in my monad that is not IO?
19:15:43 <monochrom> but I have other cards to play depending on specific scenerios
19:16:03 <Cale> saml: Then you don't.
19:16:06 <monochrom> fully specify your "my monad" first
19:16:07 <cmccann> saml, you should probably read some introductory tutorials before worrying about logging
19:16:09 <Cale> That question doesn't make sense.
19:16:09 <saml> this is not a game...
19:16:15 <saml> it's problem of haskell, i think
19:16:19 <monochrom> you are making it a guessing game. you.
19:16:21 <Cale> What if I want to hPutStrLn in my list?
19:16:30 <Cale> What if I want to hPutStrLn in my Maybe Integer?
19:16:54 <saml> so, you use TH?
19:16:57 <Cale> (Maybe Integer isn't a monad, Maybe is, but I'm changing your question a bit)
19:17:09 <mjo> bgamari: http://en.wikibooks.org/wiki/Haskell/Pattern_matching#Introduction_to_records
19:17:24 <luite> saml: many applications have their own monad something built on top of IO, then you'd typically use liftIO (hPutStrLn sdterr msg), but for monads like Maybe or State, this doesn't make sense
19:17:26 <bgamari> mjo: Thanks
19:17:27 <mjo> Pattern matching with record syntax (I didn't know this, glad you asked)
19:17:51 <saml> luite, on top of IO.. means monad transformer ? since you mention liftIO
19:17:57 <Cale> saml: Find me a computation in some monad which is not IO that you'd like to do logging in. We can figure out what you mean from there, and show you how to do what you're trying to do.
19:18:08 <saml> List
19:18:22 <Cale> Okay, so suppose the list in question is [1,2,3]
19:18:28 <Cale> what is there to log there?
19:18:31 <saml> i want to log 3rd value of List  if List has 3rd value.. whenever someone folds or iterates the list
19:18:32 <Cale> I don't get it
19:18:42 <Cale> ???
19:18:48 <cmccann> saml, that's not a sensible thing to do
19:18:50 <saml> I want to extend  List monad to log 3rd item
19:18:53 <monochrom> that is not "doing logging in the [] monad"
19:18:55 <luite> saml: yes
19:19:11 <cmccann> the third item is a 3, just stick a 3 in your log and be done with it
19:19:15 <cmccann> there's nothing there to log
19:19:30 <saml> List is List a
19:19:34 <saml> a can be anything..
19:19:50 <Cale> sure...
19:19:59 <saml> it can be seriously useful to log 3rd item of List
19:20:05 <cmccann> saml, I'm pretty sure you need to step back from this and learn the basics of Haskell better
19:20:18 <Cale> saml: Um, I don't know what you mean by "log 3rd item of list"
19:20:30 <monochrom> log to where?
19:20:45 <saml> somewhere that i can inspect later
19:20:52 <Cale> hPutStrLn stderr (show (xs !! 2))
19:21:02 <Cale> Is that what you mean?
19:21:06 <saml> no..
19:21:15 <monochrom> you're being vague again
19:21:15 <saml> foldr (+1) 0 l
19:21:24 * cmccann concludes that saml doesn't know what he means any more than we do
19:21:31 <saml> it should output something  if l has 3rd item
19:21:32 <Cale> That's a type error
19:21:46 <Cale> foldr (+) 0 l
19:21:56 <Cale> will be the sum of the elements of l
19:22:15 <saml> yes.
19:22:20 <saml> do you konw what logging is?
19:22:22 <Cale> It can't output anything
19:22:25 <monochrom> foldr doesn't log. write a different function that can log, if you want
19:22:26 <parcs> :t foldr (+1) 0
19:22:27 <Cale> It's just a number
19:22:27 <lambdabot> forall b. (Num b) => [b -> b] -> b
19:22:37 <Cale> It just *is*
19:22:41 <Cale> there's nothing to log
19:22:47 <Cale> It's specifically the number 6
19:22:49 <saml> that's the meaning of log
19:22:52 <Cale> if the list was [1,2,3]
19:23:13 <cmccann> :t log
19:23:13 <lambdabot> forall a. (Floating a) => a -> a
19:23:17 <cmccann> there we go, that's how to log
19:23:17 <saml> plus output 3
19:23:19 <Cale> Do you want integer values to have arbitrary effects whenever you look at them?
19:23:35 <saml> not integer values
19:23:41 <saml> 3rd item of list
19:23:46 <Cale> foldr (+) 0 [1,2,3] is an Integer
19:23:54 <saml> not arbitrary, logging in this case.
19:23:57 <Cale> So is 3
19:24:17 <saml> so, i'm talking about TH
19:24:27 <bgamari> I can't imagine there's a way to both pattern match on, i.e. a record, and get the original, unmatched value
19:24:27 <Cale> I don't think you're talking about TH either
19:24:29 <luite> you could use foldM if you want to output stuff along the way
19:24:34 <Cale> But I don't know what you're talking about
19:24:40 <monochrom> I'm pretty sure C's stdlib qsort doesn't log either. if you want a logging sort, you have to write your own or find another lib. I don't see why haskell stdlib's foldr is any different
19:24:53 <parcs> is there a monad transformer for ((->) e)?
19:25:00 <Cale> parcs: ReaderT
19:25:01 <cmccann> parcs, not directly
19:25:08 <cmccann> ReaderT is equivalent though, yes
19:25:23 <monochrom> but why am I trying to reason with you? you have already made up your mind
19:25:36 <cmccann> pretty sure you can't define a ((->) e)T without a newtype in there
19:25:39 <saml> what's equivalent to logging in haskell?
19:25:44 <saml> that might be a better question
19:26:00 <luite> up to isomorphism?
19:26:08 <saml> logging as in... you compile your program with some flag.. then log instructions won't be there..
19:26:28 <saml> logging as in imperative languages..
19:26:37 <Cale> Oh, why the heck were you talking about monads?
19:26:50 <saml> what is equivalent in hasekll.. or how do you debug large multi threaded programs?
19:26:52 <cmccann> everything you do in an imperative language is equivalent to doing stuff in IO in Haskell
19:27:01 <parcs> cmccann: that makes sense. thanks.
19:27:13 <monochrom> Debug.Trace
19:27:26 <cmccann> monochrom, unsafePerformPrintfDebugging
19:27:46 <monochrom> not sure which flag turns off the Debug.Trace commands though
19:27:46 <Cale> If you want conditional compilation of code, you can use either if expressions with constant Bool values or the C preprocessor via {-# LANGUAGE CPP #-}
19:27:48 <Jafet> You use logging to debug large multi-threaded programs?
19:27:52 <saml> is there something that prints Source:LineNo , too?
19:28:20 <cmccann> personally I find the best way to debug multi-threaded code in Haskell is to not write bugs in the first place, which turns out to be pretty easy in many cases
19:28:25 <monochrom> but you're right that we didn't know the meaning of your "logging"
19:29:09 <luite> monochrom: use a function that's either trace or const, depending on some preprocessor thingie
19:29:27 <monochrom> yeah, I guess it can be hacked up
19:30:20 <monochrom> Control.Exception.assert does enjoy compiler flag on/off, but it is usually quiet if everything goes right
19:30:22 <Cale> I *guess* you could use TH if you really wanted
19:30:29 <cmccann> it's also pretty easy to wrap logging stuff around various IO actions
19:30:36 <Cale> (to do conditional compilation stuff)
19:31:06 <monochrom> on the plus side, when assert does speak out, you do get line numbers
19:31:51 <monochrom> on the minus side, when assert does speak up, it also ends the program
19:32:33 <monochrom> how do I debug haskell programs? I don't. I build small units and unit-test like crazy. then there is nothing to debug
19:33:16 <luite> what do you use for multithreaded unit testing?
19:33:42 <monochrom> how do I debug concurrency bugs? god, it's hard to have concurrency bugs in the first place with judicious use of mvars...
19:34:03 <luite> hehe probably does depend on the complexity of your system :p
19:34:20 <dankna> I've noted many cases where I could have deadlock, actually
19:34:30 <dankna> I think I avoid them by always acquiring mvars in the same order, but I don't really know
19:34:42 <monochrom> I mean, I can see that if you conceive a tree data structure as a tree of many mvars, I can see you have race conditions left right and centre. but who would do that?
19:35:18 <luite> I have a multithreaded worker pool thingie for my website, but I still need to test it some more
19:35:38 <monochrom> me, I just have one single mvar for an immutable tree. I incur some costs for updates, yes, but I get atomicity for free. there is only one mvar, how could you possibly race
19:36:12 * cmccann just uses STM unless given reason to consider otherwise
19:36:37 <monochrom> if you write idiomatic haskell, you have to work very hard and sabotage yourself if you want concurrency bugs, you know
19:37:09 <monochrom> that is the problem with you imperative programmers. you just assume bugs are everywhere
19:37:45 <saml> @quote monochrom
19:37:45 <lambdabot> monochrom says: <$> is pronounced Jacquelin von Brionée
19:37:49 <saml> @grab monochrom
19:37:49 <lambdabot> Unknown command, try @list
19:37:53 <luite> oh that reminds me that I should still switch some chan to TChan becasue Chan doesn't support checking whether the chan is empty without blocking
19:38:07 <saml> we need a twitter application that tweets stuff said here
19:38:11 <luite> on the other hand, TChan doesn't have fairness
19:38:44 <monochrom> oh good, so you're reading afterall
19:39:13 <saml> so there is Debug.Trace.. what if I want to mix different monadic actions?
19:39:23 <saml> advice would be DONT' ?
19:39:23 <monochrom> but you have made up your mind, you disbelieve everything I said, even though what I said is exactly what I do in my programs
19:39:49 <cmccann> saml, please define your use of "mix different monadic actions"
19:39:50 <saml> you mean your programs are bug free coz you are functional programmer?
19:39:54 <cmccann> I do not think those words mean what you think they mean
19:40:20 <monochrom> not bug free in the absolute sense. I still have to unit-test things, remember?
19:40:28 <Jafet> This must be one of those folks who couldn't learn lisp in one day.
19:40:35 <cmccann> and no, they're mostly bug free because of purity, not being functional
19:41:00 <monochrom> but one class of bugs becomes highly unlikely. I just have to watch out for another class of bugs, but you haven't seen it
19:41:19 <ddarius> cmccann: There have been a few GA implementations in Haskell, but I think they were all pre-Hackage.  I'm not aware of one on Hackage though there are a couple of ways of getting a geometric algebra quickly.
19:41:22 <cmccann> an imperative language with effect tracking and purity as strict as Haskell would be much easier to write bug-free code in as well
19:41:47 <monochrom> if you haven't finished a substantial haskell program, you just don't know what kind of bugs is likely and what other kind is not worth worrying about
19:42:04 <cmccann> ddarius, yes, I've implemented at least two very bad ones, I was hoping for one suitable to do useful things with
19:42:18 <saml> do { a <- runSQL "SELECT * from foo where id = 3";  putStrLn $ show a; save a {countOf :: countOf a + 1} }      with exception handling
19:42:40 <cmccann> ddarius, but I'm guessing that pre-hackage also means pretty antique code and potentially bit-rotted anyhow
19:43:33 <cmccann> saml, stick a liftIO before putStrLn and that could plausibly be in a monad transformer stack with exception handling
19:43:55 <monochrom> IO already has exception catch-throw
19:44:00 <Cale> IO is already a monad with exception handling
19:44:06 <cmccann> well, true
19:44:11 <cmccann> but I don't like those :[
19:44:21 <Cale> Control.Exception is cool
19:44:23 <monochrom> yes you could add your own if you like
19:44:25 <luite> yeah IO for exceptions is a bit annoying
19:44:27 <Cale> (the new one is, anyway)
19:44:30 * cmccann prefers exceptions that can't escape all the way up to main
19:44:33 <Cale> It's nicely extensible
19:44:52 <saml> so the answer is monad transformer
19:45:08 <monochrom> in retrospect Control.Monad.Error could benefit from SomeException as opposed to falling back to String
19:45:17 <cmccann> saml, in the same sense that the answer to "what should I have for dinner" is "matter", yes
19:45:32 <Cale> saml: It's a matter of taste, but I would say don't bother ever transforming the IO monad unless your monad transformer is something strange like a nondeterminism monad transformer or a parser.
19:45:51 <monochrom> "the" answer, like there is only one
19:45:52 <Cale> (In particular, don't transform IO to add features that IO already has)
19:45:59 * cmccann disagrees with Cale but, yes, it's a matter of taste
19:46:15 <cmccann> then again, I also try to avoid IO, so eh
19:46:23 <saml> what's other way to "mix in" monads ?
19:46:26 <saml> or compose monads?
19:46:35 <Cale> saml: Mixing monads together is a weird idea to begin with
19:46:46 <Cale> saml: It's not something you normally want to do
19:46:55 <saml> what's monad transformer then?
19:47:01 <cmccann> saml, by not doing anything special and keeping them independent
19:47:09 <Cale> It's something which turns one monad into a new, different monad.
19:47:20 <saml> so.. composing
19:47:27 <Cale> It is not itself a monad.
19:47:29 <saml> what's other way of composing monads ?
19:47:33 <saml> oh fuck
19:47:50 <cmccann> monad transformers turn monads into different monads
19:48:10 <cmccann> they're usually named after the monad you get if you transform the Identity monad, which is the monad that does nothing
19:48:41 <cmccann> e.g., newtype Identity a = Identity a or whatever the definition is, just a value in a wrapper
19:48:41 <Cale> Monad transformers can be a handy way to construct the start of a new library quickly, if the library you're writing happens to centre around a transformed version of an existing monad.
19:48:47 <ivanm> cmccann: well, it has to do _something_ ...
19:48:50 <monochrom> how much haskell have you learned? how much existing haskell code from good libs or programs have you read? have you read xmonad's code? it answers all your vague questions. at least as one approach
19:49:09 <saml> none.. that's why i'm asking.. guidance.
19:49:23 <Cale> But in general, you probably should come to the realisation that you can write your monad that way, or even that your library *is* a monad in the first place, *after* designing its API
19:49:25 <monochrom> learn haskell and read xmonad's code
19:49:27 <saml> but all i'm getting is "you're wrong."
19:49:30 <saml> what's the right way?
19:49:33 <cmccann> ivanm, assuming that the Identity monad is defined as a newtype it pretty literally does nothing because it won't even exist at runtime :P
19:49:52 <ivanm> cmccann: heh, true
19:50:07 <Cale> saml: The right way to compose monads is not to compose monads because in general it doesn't make sense to do it, or the ways in which it does make sense are not what you mean anyway.
19:50:08 <saml> monochrom, thanks
19:50:17 <cmccann> saml, we're not telling you you're wrong so much as confused. the questions you're asking are three steps down the wrong path and are only confusing you and us both
19:50:31 <Cale> ^^ this
19:50:40 <cmccann> saml, which is why you'd be better served to start with some sort of introduction and learn the basics
19:50:48 <cmccann> then come back and ask about the stuff you're trying to figure out now
19:51:05 <saml> alrighty. thanks
19:51:23 <cmccann> saml, and I apologize for being rude earlier
19:51:29 <saml> so, next time someone asks similar question, just direct him/her to a good source of learning
19:51:30 <Cale> saml: Suppose I have a library for describing drawings, and I have a library for parsing strings. How do I compose them?
19:51:38 <saml> instead of ... chatting a lot
19:52:01 <Cale> saml: I mean, that's sort of what your question sounds like...
19:52:05 <cmccann> saml, I tried to suggest you do that earlier but I guess it got lost in the noise :|
19:52:23 <Cale> saml: You can obviously use the two together in various ways, but *composing* them...
19:52:39 <monochrom> the third time a statement is made is the clearest time
19:53:16 <saml> it could be useful if description can be serialized to string.. and have it parsed
19:53:30 <Cale> We're talking about putting parsers in our drawings or something
19:53:33 <cmccann> ivanm, on the other hand the Cont monad doesn't really do anything either, since it's trivially isomorphic to Identity :D
19:53:45 <Cale> Or constructing something which is both a parser and a drawing in some odd way
19:53:55 <Cale> It doesn't necessarily make sense.
19:54:38 <cmccann> saml, "parsing a description" would be equivalent to just using the monads separately
19:54:58 <Cale> Yes
19:55:02 <cmccann> it's not mixing them, just using both normally
19:55:27 <monochrom> no one will ask similar questions
19:55:37 <saml> i want a repl that takes description as string, parses, and draws.
19:55:51 <Cale> You don't have to compose monads to use two libraries alongside each other. You just import both and use the stuff that's defined in those modules, and maybe take advantage of the fact that there are some monad instances hanging about if it suits you.
19:56:03 <cmccann> whereas if you had a "DescribeDrawingsT" transformer applied to a "ParseStrings" you'd get I dunno, something that describes using OCR to build a parser from hand-written BNF
19:56:16 <Cale> lol
19:56:25 <Cale> This is getting a little weird
19:56:33 <cmccann> that's the kind of deep mixing of functionality that monad transformers are for
19:57:13 <Cale> (but monad transformers are usually not so impressive)
19:57:20 <monochrom> analogies and made-up examples are dangerous businesses
19:57:49 <Cale> saml: But let's say you want to do that
19:58:00 <cmccann> Cale, maybe, but I still can't make sense of CC-delcont :T
19:58:10 <Cale> saml: You'd use the IO monad for reading the user input and drawing images to the screen.
19:58:42 <saml> thinking of it.  main :: IO ()
19:58:53 <Cale> saml: you might use a parsing monad to parse the input syntax into some description of a drawing, and the language of drawing values itself *may* be a monad too
19:59:05 <saml> so drawing library and parsing library will somehow run in IO
19:59:07 <Cale> saml: but it requires nothing special to use things together in that way
19:59:18 <Cale> Parsing library probably won't be written in IO
19:59:29 <Cale> but you can use any sort of values from IO that you like
19:59:55 <Cale> Just as if I write:  main = do xs <- getLine; putStrLn (reverse xs)
20:00:02 <Cale> reverse doesn't have anything to do with IO
20:00:21 <saml> but parsing library would have to provide a function ... -> IO a
20:00:25 <Cale> nope
20:00:26 <saml> same with drawing
20:00:28 <Cale> it doesn't have to
20:00:42 <Cale> drawing would have to in order to draw onto the screen
20:00:55 <Cale> or write to an image file
20:01:06 <cmccann> but actually constructing the image need not be
20:01:09 <Cale> but not if it just produced a ByteString containing a PNG image, say.
20:01:10 <cmccann> depending on the library
20:01:26 <saml> so, there is  f :: Parsing a . how would I use it in main ?
20:01:43 <cmccann> saml, parsing libraries usually have a "runParser" function of some sort
20:01:56 <saml> yah.. that's  the function :: ... -> IO a
20:02:01 <saml> or..
20:02:07 <luite> saml: something like runParser :: Parser a -> String -> Either ParseError a
20:02:08 <saml> no doesn't have to be IO a
20:02:12 <saml> yah
20:02:16 <Cale> main = do input <- getLine; let imageDesc = runParser f input; drawToScreen imageDesc
20:02:36 <saml> i see. thanks for your patience
20:02:39 <cmccann> saml, then you pattern match on the Either value to handle errors or get the result
20:02:40 <Cale> Note that runParser f input is not an IO action
20:03:04 <Cale> So we use let to declare that value locally as imageDesc
20:03:13 <Cale> oh, yes, I'm ignoring failure
20:03:16 <cmccann> (assuming it returns errors like luite's example, Cale seems to be assuming it won't)
20:03:24 <cmccann> but that doesn't really change much
20:03:29 <cmccann> just complicates the examples
20:03:53 <Cale> main = do input <- getLine; case runParser f input of Left e -> print e; Right imageDesc -> drawToScreen imageDesc
20:04:16 <Cale> something like that
20:04:23 <Cale> (it's just a sketch anyway)
20:05:18 <saml> does cabal install html doc somewhere, too?
20:05:31 <cmccann> if you tell it to, not sure if that's enabled by default
20:05:53 <saml> how do you navigate through api?  clicking through hackage?
20:06:26 <cmccann> depends on what you're looking for, can also view some information in GHCi or use some library API search engines that people have made
20:06:27 <Cale> in ~/.cabal/config you can make sure there's a line:  documentation: True
20:06:29 <saml> i mean.. I have this function,   f :: Foo -> Bar ...  and Foo is from some package apple... Bar is from some other..
20:06:31 <Cale> and it'll generate documentation
20:06:53 <Cale> The docs on hackage are all linked together
20:07:07 <saml> yah so that's what i've been doing.. and i was wondering if there's a local tool
20:07:13 <Cale> as will the docs be if you generate them locally
20:07:37 <Cale> library-profiling: True
20:07:41 <Cale> is another thing I'd recommend
20:07:57 <Cale> and then rebuild all your local packages
20:09:22 <Bfv9000> is there an analogue to haskell's map in C#?
20:09:30 <Bfv9000> :D
20:09:33 <cmccann> Select()
20:09:39 <cmccann> on IEnumerable
20:09:42 <Cale> LINQ has a lot of that
20:09:49 <cmccann> and SelectMany is concatMap BTW
20:09:55 <saml> what does library-profiling option do?
20:09:56 <Bfv9000> i want to use them on string[]
20:10:25 <cmccann> Bfv9000, that implements the interfaces needed, doesn't it? Just try the LINQ syntax and see if it works :P
20:10:33 <Cale> saml: Turns on building of profiling versions of the libraries when you install them, so that you don't have to go back and reinstall them all later when you want to profile a program which uses them
20:10:41 <cmccann> also, at some point they added a Zip method as well, which is nice
20:10:49 <cmccann> and I think fold is called Aggregate or something
20:11:01 <saml> Cale, ah thanks
20:12:06 <cmccann> a bunch of other functions from Data.List are stuck on the Enumerable stuff here and there, too
20:12:07 <saml> to rebuild local packages, do I run cabal install list of local packages ?
20:12:41 <Bfv9000> cmccann, arey ou camccann in SO?:
20:12:49 <cmccann> Bfv9000, I'm afraid so
20:12:59 <Cale> saml: I think you also need to include the --reinstall flag
20:13:10 <Bfv9000> what a coincidence i just saw you answering a question about this same topic on SO :D
20:13:11 <ivanm> which extension do I need for the variables type sig within a where clause to be the same as the ones in the type sig for the main function? ScopedTypeVariables ?
20:13:19 <Cale> saml: you can blow away ~/.ghc if you want to make sure you've got them all
20:13:26 <cmccann> Bfv9000, what can I say, C# is my day job
20:13:35 <Cale> (initially, not at the end of course ;)
20:13:55 <saml> ah nice
20:14:27 <Bfv9000> cmccann, it is a fine enough language i think :p. of course i love haskell too :)
20:14:59 <cmccann> C# is remarkably tolerable for a mainstream language of its style
20:15:24 <cmccann> the C# team at MS are pretty awesome and they've done a lot to make it better given the baseline they had to work with
20:15:42 <ivanm> aren't the examples here missing Rank2Types or RankNTypes? http://www.haskell.org/haskellwiki/ScopedTypeVariables
20:15:53 <cmccann> if you're poking around on Stack Overflow for C# stuff, make sure to keep an eye for Eric Lippert, he's basically awesome in every way possible
20:16:40 <ivanm> oh, nvm; I can't spell LANGUAGE ;s
20:17:09 <Bfv9000> he is sitting right there with you in the same question :p
20:17:33 <cmccann> Bfv9000, he answers a lot of questions ;]
20:17:53 <Bfv9000> what about john skeet?
20:17:54 <Bfv9000> :D
20:17:57 <mjo> Is there a way to use e.g. a let or where clause over an entire instance declaration? Motivating example: a Num instance for points. I'd like to let x1 = x_coord p1, x2 = x_coord p2 etc. in p1+p2=...
20:18:04 <Bfv9000> that guy sure has a lot of rep :P
20:18:20 <cmccann> Bfv9000, Skeet is just a very helpful guy who became an SO in-joke because of how many questions he answers :P
20:18:52 <cmccann> Lippert is on the C# language team at MS and as well and is amazingly knowledgeable and very good at explaining things
20:19:04 <cmccann> wow I mangled the grammar in that sentence
20:19:19 <Jafet> mjo: uh, p1 and p2 aren't in scope in the instance declaration
20:19:32 <Jafet> They're part of the methods
20:19:35 <Bfv9000> i'm gonna have the opportunity to work with MS next semester, on a project involving office 365
20:20:22 <cmccann> Bfv9000, anyway, quality over quantity, if you analyze the SO data Lippert has one of the highest ratios of upvotes per question on the site, and has answered about 10x as many questions as anyone else with similar ratios
20:20:24 <Bfv9000> i'm just a university student and to be honest i don't know much about anything. hope i get the MS project and do good
20:21:04 <mjo> Jafet: what I wind up doing is, p1+p2 = (x1+x2, y1+y2, z1+z2) where x1 = x_coord p1... and so on. p1+p2 is the definition of plus, for two points.
20:21:14 <Jafet> You could use view patterns (coords -> (x1, y1)) + (coords -> (x2, y2)) = ..; where coords p = (x_coord p, y_coord p)
20:21:16 <cmccann> there's actually a surprising number of language implementors hanging around on SO, it's pretty cool
20:21:43 <Jafet> But since they're separate methods, you have to repeat whatever deconstruction you used
20:22:00 <xil> hi. Is there a way to do something akin to "mapM forkIO list" where list is a list of IO operations, but you want the results of the operations. Right now I created a channel that I monitor to recieve the results from each thread
20:22:01 <mjo> Yeah, that's what I'm trying to avoid =)
20:22:18 <Jafet> Then go to the land of TH, where the shadows lie
20:22:30 <mjo> I don't care *that* much.
20:22:55 <mjo> It just seems like a problem that somebody would have solved already.
20:23:02 <Jafet> xil: mergeIO?
20:23:36 <Bfv9000> cmccann, there is an incredible amount of knowledgeable people there, it incredible. hope some day i'll be as helpful to next gen devs as you all now with me :)
20:23:54 <xil> Jafet: okay so I saw that, but I'm not sure I quite get what it's doing. By the description it looks to me like it forks a thread to process each list, not each element of the list. Is that wrong?
20:24:05 <cmccann> Bfv9000, I've learned a lot about Haskell by attempting to explain it to other people on SO :P
20:24:10 <Jafet> Okay, not mergeIO
20:24:31 <cmccann> I suspect a few of my early answers have some very silly things in them but I've been afraid to go back and look, heh
20:25:44 <Jafet> I must be thinking of parMap, in parallel
20:25:54 <Bfv9000> cmccann, this question might be a little biased but would you recommend taking another course in functional programming? http://www.fing.edu.uy/inco/cursos/pfa/wiki/field.php?n=Main.Programa
20:26:44 <xil> Jafet: okay I didn't know about the Parallel stuff. Looking at it now, thanks
20:26:45 <cmccann> Bfv9000, I certainly can't argue with the bibliography :]
20:26:53 <Jafet> Hm, what you want is to execute IO in parallel. I don't think you want par, then
20:27:40 <cmccann> xil, have you tried just creating a list of MVars, having each IO action write to the MVar, then mapM readMVar over those to get the answers?
20:28:00 <cmccann> I'm not sure what the performance characteristics on that would look like though
20:28:02 <Bfv9000> cmccann, but would you say it would enrich me as a programmer, compared to a different course? http://www.fing.edu.uy/inco/cursos/electivas/semestre2.htm
20:28:39 <cmccann> but it would be pretty easy to implement a function to create the MVar, stick a writeMVar onto the action, fork it, and return the MVar reference
20:29:21 <xil> cmccann: I hadn't thought of that. That should work. But I have a question then. Is creating MVars costly? I ask just because I'm going to do this whole process often, so instead of creating one every time I can bundle it with my data structure
20:29:46 <cmccann> Bfv9000, I dunno, kinda hard to advise. I'm very much inclined to learning on my own, so probably not a good person to ask
20:29:52 <cmccann> since it's not how I tend to do things myself
20:30:17 <luite> xil: hmm, I believe this question was asked here earlier, the answer was doing something like sequence . mapM spawn with the spawn package
20:30:24 <Jafet> Creating them probably isn't as expensive as scheduling them
20:30:29 <cmccann> xil: that falls under the performance characteristics I'm unsure of, heh. but it's simple to implement, so you could always just try and see how well it works
20:30:31 <c_wraith> creating an MVar is an allocation and a couple initializations.  No huge deal.
20:30:46 <cmccann> it's the waiting to read all of them I'm more concerned about
20:31:02 <luite> xil: (which does the same, it creates an MVar for each action, and it rethrows exceptions)
20:31:02 <Bfv9000> i usually research by myself when i'm interested in something that is not being taught, but since university consumes a lot of my time i tend to prefer mixing both
20:31:17 <xil> cmccann: waiting to read them all I'm doing already with the channel. I'm not worried about that because this is already a HUGE speedup compared to what I was doing before
20:31:40 <xil> luite: I wouldn't mind creating the MVars myself then
20:31:43 <luite> using one MVar per action will use fewer MVars than a channel
20:31:43 <cmccann> Bfv9000, which is a good plan, but I was a terrible student, I didn't start really learning things until years after I graduated :[
20:32:09 <xil> luite: oh, I didn't know the Chan used MVars. Then I'll definitely just do MVars. It's much easier anyway
20:32:41 <xil> and you all recommend that over Control.Parallel.Strategies?
20:32:50 <cmccann> xil, I think Chan is a linked list of nested MVars
20:32:57 <ddarius> MVars aren't expensive at all.
20:33:03 <c_wraith> the Parallel stuff is very different
20:33:04 <cmccann> with two "pointers", for the "head" and "tail"
20:33:32 <xil> yeah I'll just do the MVars then. Much easier and simpler
20:33:37 <xil> and I don't need to learn about Parallel
20:33:40 <xil> thanks everyone!
20:34:09 <cmccann> xil, imagine a list where each tail has an MVar around it, reading moves the head pointer forward and writing replaces the final empty list tail with a new list
20:34:55 <cmccann> at least I think that's how it works :T
20:35:08 <cmccann> anyway, yeah, glad to help :]
20:36:22 <Bfv9000> cmccann, i feel i know a lot of nothing and i run into problems every time i want to do something even remotely useful :|. I blamed it on the API designers. Over time i've found that both windows and linux have good APIs, and that i'm a lousy programmer :p
20:36:46 <Bfv9000> (and other WS apis, ie, YT)
20:37:14 <cmccann> well, most APIs are terrible, but they're often terrible for very specific and important reasons that aren't obvious unless you know what you're doing
20:37:16 <Jafet> Or perhaps you've become as crazy as them.
20:38:31 <cmccann> Bfv9000, anyway, that course described in that first link you gave seems pretty thorough, if it covers everything it says in an effective way you'll learn a lot
20:40:00 <cmccann> though I'm a little dubious, that's a LOT of stuff to cover in a short amount of time... if it's what it claims to be I'd expect it to be very demanding :T
20:41:54 <cmccann> on the other hand it's all stuff you can probably get lots of help with if you ask in here or on SO
20:42:46 <cmccann> Bfv9000, if it helps, I can say that I really wish I'd taken a course like that when I was a student :P
20:43:56 <Bfv9000> cmccann, it demands about 14 hours per week, plus a 30 hour lab for a whole semester
20:44:28 <Bfv9000> i'd say it's one of the heaviest optional subjects available. i'm gonna take it, hell.
20:45:39 <cmccann> Bfv9000, yes, I saw that, and it strikes me as a bit optimistic. Then again, that amount of concentrated effort should make it easier than spreading it out in small bits like I end up doing because of other demands on my time.
20:46:19 <Bfv9000> the first course was pretty cool... i almost fail, then i 'got it', and learned a lot
20:46:42 <Bfv9000> i passed it with a pretty good grade... would've been better if not for the stupid grading methodology
20:47:54 <cmccann> Bfv9000, yeah, you'll definitely learn a lot in this course too
20:48:21 <xil> small question. Is there a way to represent numeral literals in non-decimal bases? I'd prefer hex if possible. Can I do something like "0x20" itstead of "32"?
20:48:22 <Bfv9000> you know, i've tried to crack monads up a couple times... they just don't feel right... guess i'll have to put my neck on the line for it to work.
20:49:01 <cmccann> Bfv9000, and again, don't hesitate to ask for assistance, most people in here or on SO, etc. are happy to help explain if you make it clear you're after understanding, rather than an immediate solution
20:49:34 <cmccann> > print 0x10
20:49:35 <lambdabot>   <IO ()>
20:49:40 <cmccann> > show 0x10
20:49:41 <lambdabot>   "16"
20:50:01 <cmccann> xil, looks like "yes"
20:50:01 <xil> cmccann: I keep forgetting there's that bot in here. Thanks
20:50:06 <cmccann> :]
20:50:11 <Jafet> :t readInt
20:50:12 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
20:50:49 <xil> cmccann: actually I realize now I could have tried that in the interpreter too =[
20:50:59 <cmccann> xil, heh
20:51:18 <cmccann> lambdabot can actually be nicer in some cases, though obviously that would have worked either way
20:52:11 <cmccann> xil, you can also send private messages to lambdabot to avoid spamming the channel
20:52:44 <cmccann> you can also run a local copy of lambdabot but I gather it's awkward to install some dependencies, if memory serves me. not sure.
20:53:15 <xil> cmccann: oh that is very good to know. I've been wondering about that actually because every time I think about it I feel like I would be embarassed to spam the channel
20:54:19 <cmccann> nobody really minds a bit of lambdabot spam in here, but a /msg is better for large amounts
20:54:47 <xil> cmccann: yeah, I'm using Pidgin so I just put it on my buddy list, haha
20:55:05 <cmccann> though keep in mind that lambdabot has a few quirks in how some stuff is handled
20:55:08 <cmccann> :t (.)
20:55:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:55:12 <cmccann> :t (++)
20:55:13 <lambdabot> forall m. (Monoid m) => m -> m -> m
20:55:50 * cmccann still thinks the (.) one is kinda silly
20:56:26 <xil> I still don't understand quite how forall works. The wikibook actually confused me a bit
20:56:45 <cmccann> xil, familiar with quantifiers in formal logic at all?
20:56:54 <xil> cmccann: yes
20:57:07 <cmccann> well, that's most of what it means
20:57:19 <shachaf> Yes. It means "for all". :-)
20:57:39 <drbean> What is the . doing after (f :: * -> *) ?
20:57:49 <shachaf> It's part of the forall.
20:57:59 <cmccann> "for all types a, b, f, such that f is an instance of Functor, (type signature here)"
20:58:05 <shachaf> "forall x y z. rest_of_type"
20:58:36 <shachaf> "(f :: * -> *)" is a more specific version of just "f" -- it specifies a kind.
20:58:36 <cmccann> not sure why it uses a period, actually
20:58:57 <cmccann> it just marks the end of the binding where new type variables are introduced by the quantifier
20:58:59 <xil> cmccann: right, but it's the way it integrates with Haskell's semantics that tricks me. Like the type "data T = forall a. Show a => T a". With that you can make a list of any type that inherits show. I get that, but it's not necessarily obvious from the forall alone
20:59:07 <shachaf> cmccann: Borrowed from mathematical notation, I guess. It's a bit awkward with the other meanings of "." in Haskell.'
20:59:08 <Cale> The period is traditional notation
20:59:29 <Cale> from formal logic and type theory
20:59:43 <xil> cmccann: I mean, a list of mixed types that inherit show
20:59:43 <djahandarie> The period is also traditional notation for lambda bindings
20:59:57 <cmccann> xil, yeah, it gets a little confusing at that point
21:00:07 <djahandarie> s/bindings/abstractions/
21:00:10 <xil> cmccann: what confuses me is that in the wikibook it says that the type "forall a. a" is actually nothing at all, well except for bottom
21:00:11 <cmccann> djahandarie, that's actually how I read it
21:00:44 <djahandarie> Well, it isn't really a type-level lambda so that might not be the best way to read it
21:00:44 <xil> cmccann: it talks about how forall is like an intersection of data types, and I didn't find that helpful. I would have understood without that, I think
21:00:45 <cmccann> xil, "forall a. a" is any type you ask it to be
21:00:47 <shachaf> xil: "is an instance of" isn't the same as "inherits". :-)
21:01:05 <parcs> xil: can a value be any type?
21:01:12 <xil> shachaf: I was looking for "is an instance of" but couldn't think of it, haha
21:01:37 <parcs> or rather, can a value be every type?
21:01:37 <xil> cmccann: ah, but it's just useless because you can't do anything with it, so it might as well be bottom? Is that what the wikibook was getting at?
21:01:47 <xil> parcs: I'm not sure I understand
21:02:15 <cmccann> xil, more that there are no defined values that can be given that type, so the only thing that can be assigned to a term with that type is bottom
21:02:24 <cmccann> at least if we're talking top-level bindings
21:03:06 <cmccann> xil, hm, are you familiar with typed lambda calculus?
21:03:13 <BMeph> Any type == "no" value (or rather, undefinable, so "undefined")
21:03:15 <xil> cmccann: no
21:04:00 <Jafet> forall a. Default a => a
21:04:44 <cmccann> xil, with the caveat that Haskell doesn't exactly match up to standard typed lambda calculi in obvious ways, looking at something like System F can help clarify some aspects of what polymorphic types mean
21:05:31 <cmccann> from that perspective, you can read "forall" as being sort of a lambda abstraction, in the sense that djahandarie meant when saying "might not be the best way to read it" :P
21:05:47 <xil> cmccann: here's the thing. Take this, "data T = forall a. T a". I would think I can make the following list: [T 5, T "elephant", T 'q', T (newMVar 7)]. Is that not true? Can I only do [_|_, _|_, _|_]?
21:05:58 <xil> cmccann: I'll look that up then
21:06:19 <cmccann> xil, the data declaration means something different than a top-level term with the type forall a. a, that's the tricky bit
21:06:45 <xil> cmccann: okay. Then I'll do a bit more reading. See if it can clear things up a bit more
21:06:51 <shachaf> xil: You can have the former list, but it'll be equivalent to the latter.
21:07:29 <xil> shachaf: what I was thinking is that I could have the former list, but I couldn't do anything with the data inside because I don't know why types they are, so for all intents and purposes they might as well be the latter.
21:07:41 <xil> s/why/what/
21:07:44 <shachaf> Exactly.
21:07:51 <xil> aha!
21:08:02 <xil> okay. Well that clears up one thing. And I'll do more reading to get the rest, haha
21:08:06 <xil> thanks
21:08:11 <cmccann> yeah, but the reason why it's useless is kinda different
21:08:23 <cmccann> though it still boils down to not being able to do anything with a polymorphic type
21:08:26 <shachaf> On the other hand, "data T a = forall a. (Show a) => T a" is a bit more useful.
21:08:31 <ddarius> cmccann: data T = forall a. T a is equivalent to exists a. a
21:08:38 <ddarius> Which is equivalent to ().
21:08:55 <xil> ddarius: that's what's in the wikibook and what confused me
21:08:57 <shachaf> Though [T] is about as useful as [String] in that case.
21:09:05 <cmccann> ddarius, which is not equivalent to x :: forall a. a as a top-level binding, which was the comparison in question
21:09:18 <ddarius> Yes, forall a. a is different to exists a. a
21:10:43 <cmccann> ddarius, unfortunately GHC's use of just forall combined with awkward explanations tend to make people confused about the distinction
21:11:17 <parcs> why is exists a. a equivalent to ()?
21:11:23 <ddarius> GHC isn't technically using forall incorrectly.
21:11:59 <ddarius> Though it would be a lot nicer just to have exists, and then you would have data T = T (exists a. a) (of course, then you wouldn't make T in the first place.)
21:12:15 <cmccann> it's correct, just prone to confusing people trying to learn how it works in GHC without already knowing the underlying concepts
21:13:15 <shachaf> Is there a particular reason GHC doesn't have exists?
21:13:39 <ddarius> Since Haskell has at least one inhabited type, exists a. a is inhabited, but you can't do anything with exists a. a.
21:13:42 <cmccann> parcs, data T = forall a. T a lets you inspect the T constructor, just not do anything with the argument
21:14:44 <cmccann> so a value of type T can be either _|_ (like anything), or T applied to something that you can't inspect
21:15:02 <cmccann> whereas () can be either _|_ or ()
21:15:53 <parcs> yes but () has a bunch of instances attached to it
21:16:03 <cmccann> meh, equivalent up to isomorphism
21:16:12 <cmccann> just like Bool is equivalent to Either () ()
21:16:24 <cmccann> 1 + 1 = 2, what more do you want?!
21:16:33 * cmccann waves his hands
21:16:53 <shachaf> cmccann: Either () () can be undefined or Left undefined or Left (). :-)
21:16:54 <parcs> oh okay, sorry for the pedantry :)
21:17:06 <cmccann> actually I'm not sure if data T = forall a. T a has the same number of bottoms as (), thinking it doesn't
21:17:12 <Eduard_Munteanu> 1 + 1 = 4 ? :P
21:17:18 <cmccann> but it's too late for me to be thinking about bottoms right now, blah
21:17:23 * cmccann needs sleep
21:17:45 <cmccann> things are so much simpler when you pretend that Haskell is total, dammit
21:17:49 <shachaf> cmccann == syntaxglitch?
21:17:51 * cmccann switches to Agda
21:18:04 <cmccann> shachaf, yes, up to isomorphism :]
21:18:19 <shachaf> That explains it.
21:18:24 <cmccann> shachaf, why do you ask?
21:18:25 <Jafet> syntaxglitch has nicer bottoms
21:19:26 <shachaf> cmccann: Because I wondered.
21:20:02 <cmccann> I'm also "camccann" on Stack Overflow and reddit, or "Casey McCann" on Lambda the Ultimate and elsewhere. improving consistency seemed to be in order.
21:20:26 <ddarius> cmccann: How has consistency been improved?
21:21:13 <cmccann> ddarius, by switching to inconsistent renderings of my real name, rather than including a superfluous IRC nick I used years ago. eh, it's progress
21:21:57 <Eduard_Munteanu> @seen syntaxglitch
21:21:58 <lambdabot> Unknown command, try @list
21:21:58 <preflex>  syntaxglitch was last seen on #haskell 210 days, 24 minutes and 50 seconds ago, saying: not to mention that GHC /= Haskell
21:22:11 <cmccann> @quote syntaxglitch
21:22:11 <lambdabot> syntaxglitch says: copumpkin, remember, there's no "I" in "haSKell"
21:22:15 <cmccann> @quote syntaxglitch
21:22:16 <lambdabot> syntaxglitch says: SPJ is actually an infinite list of papers, if you read all he has so far it'll force the next thunk and he'll have a new one
21:22:48 <dankna> hah!
21:22:57 <cmccann> @quote syntaxglitch
21:22:57 <lambdabot> syntaxglitch says: copumpkin, remember, there's no "I" in "haSKell"
21:22:59 <cmccann> @quote syntaxglitch
21:22:59 <lambdabot> syntaxglitch says: copumpkin, remember, there's no "I" in "haSKell"
21:23:03 <cmccann> dammit lambdabot
21:23:05 <cmccann> dammit lambdabot
21:23:07 <cmccann> @quote syntaxglitch
21:23:07 <lambdabot> syntaxglitch says: a monad is an endospacesuit on a burrito category
21:23:16 <cmccann> there, that's better
21:23:23 <Eduard_Munteanu> Heh.
21:24:58 <cmccann> anyway, I figured nobody would remember my old nick anyway, since it'd been so long and I didn't spend all that much time in here before :T
21:25:25 <shachaf> cmccann: Is your domain supposed to be .net or .com?
21:25:36 <cmccann> shachaf, yes
21:26:11 <shachaf> Oh, never mind.
21:26:32 <cmccann> shachaf, I'm guessing you mean the domain I use for email these days?
21:26:49 <shachaf> I guess.
21:27:30 * cmccann doesn't really use any domains for anything useful otherwise
21:27:40 <cmccann> should make a website or something one of these days.
21:28:04 <shachaf> preflex: seen syntaxfree
21:28:04 <preflex>  syntaxfree was last seen on #haskell 10 days, 21 hours, 9 minutes and 46 seconds ago, saying: I get pinged every time someone says "syntax".
21:28:07 <shachaf> I suppose that's not you.
21:28:15 <cmccann> nope
21:28:15 <ddarius> cmccann: I remember you.
21:28:36 <cmccann> though I recall the joy of having my client ping on "syntax". It's tiresome.
21:28:59 <dankna> why, what was your old nick?
21:29:05 <ivanm> cmccann: oh, was that you?
21:29:24 * shachaf certainly remembered syntaxglitch.
21:29:26 <cmccann> now I think you're all being sarcastic :T
21:29:26 <dankna> one time we got into a conversation in -blah about rare earths and someone named "vanadium" spoke up and was like, you have pinged me two dozen times, please stop!
21:29:35 <cmccann> dankna, hahahahaha
21:29:44 <dankna> yeah :D it was priceless.
21:29:54 <shachaf> preflex: seen vanadium
21:29:55 <preflex>  vanadium was last seen on #haskell-blah 239 days, 7 hours, 50 minutes and 13 seconds ago, saying: I change my nickname like, all the time
21:29:59 <ivanm> well, ivan keeps getting pinged when people see me... :p
21:30:02 <djahandarie> dankna, shachaf, vanadium == ben
21:30:08 <dankna> oh, okay
21:30:24 * cmccann remembers a conversation in here about that, I complained about "syntax", someone else was using "applicative" and complained as well
21:30:37 <cmccann> I think I suggested they change their nick to "monad"
21:30:42 <dankna> hah!
21:31:16 <shachaf> You can't call yourself "applicative" and complain about people using your name.
21:31:33 <shachaf> /nick >>=
21:32:53 <cmccann> ah, here we go: http://irclogs.ls-themes.org/freenode/haskell/logs/2010-04-29
21:33:54 <ivan> ivanm: people in #haskell are actually pretty good about using IRC clients that complete last-spoke
21:34:04 <ivan> I'm only annoyed once or twice a week
21:34:09 <ivanm> ivan: heh
21:34:19 <ivanm> I've noticed a fair number of times that people seem to just type it in
21:35:13 <dankna> I just type it in
21:35:23 * ddarius doesn't use a client that does that (or at least is configured to do that.)  He just reads what he writes.
21:36:16 <cmccann> yeah, I usually just try to pay attention to what I'm typing
21:36:25 <cmccann> the degree to which I succeed varies
21:36:27 <cmccann> but still
21:41:16 <hpaste> “Jordan Danford” pasted “Size-indexed lists” at http://hpaste.org/48859
21:41:55 <hpaste> “Jordan Danford” pasted “Size-indexed lists” at http://hpaste.org/48860
21:43:06 <jordandanford> I have some experience in Haskell but nothing fancy, and I'm trying to make a List-like datatype where the length of the list is part of the type
21:43:40 <dankna> jordandanford, I don't quite get why you're using a class for it.
21:43:41 <cmccann> jordandanford, that's easy as long as you don't try to do difficult things with them
21:44:19 <jordandanford> the problem I have is in the natCons function
21:45:44 <dankna> I'm not totally sure how I'd do this, having given up the one time I tried, but
21:45:54 <jordandanford> wait, I may have figured out my problem
21:46:07 <dankna> if you could somehow have it as a type instead of a class, NatList size, where the size is a type parameter
21:46:26 <cmccann> jordandanford, you can't pattern match against two different types like that
21:46:29 <dankna> er, obviously, it has to be NatList size element rather
21:46:48 <dankna> then you could have natCons :: element -> NatList size element -> NatList (Successor size) element
21:47:07 <jordandanford> cmccann: yeah, I just realized that was my problem – I feel a bit dumb, but I'm fixing stuff now
21:47:54 <dankna> alternatively, there might be something to be done using multiple-parameter type-classes, but.
21:51:28 <flonum> Say I write two definitions for bind in terms of Kleisli (>=>) - does "naturality" guarantee they'll be the same even if I'm too silly to prove their equivalence by hand?
21:54:39 <hpaste> “C. McCann” annotated “Size-indexed lists” with “Size-indexed lists (annotation)” at http://hpaste.org/48860#a48861
21:55:00 <cmccann> one alternate approach
21:55:10 <cmccann> though not one that I particularly like
21:55:57 <cmccann> jordandanford, I suspect you'll eventually want some GHC extensions to do anything significant with lists like these, at which point better representations can be used in the first place as well
21:56:27 <jordandanford> cmccann: Yeah, this is just an experiment
21:57:17 <cmccann> sensible pattern matching would probably be improved by GADTs, and you'll probably need type families or fundeps to write a concat function
21:57:46 <cmccann> though I'm not certain
22:01:58 <jordandanford> cmccann: okay, I'll see what's out there – thanks!
22:03:50 <cmccann> jordandanford, among other concerns that version doesn't enforce homogeneous types... which may be what you want, but I'm guessing not
22:04:48 <shachaf> cmccann: "cmccann" vs. "camccann" only causes more confusion, I think. :-)
22:04:59 <jordandanford> cmccann: homogeneous types would be ideal, but this is all more complicated than I initially imagined – faking dependent types doesn't seem to be very easy
22:05:23 <cmccann> shachaf, I take no responsibility for the existence of middle names, they're kind of silly really
22:05:33 * ddarius recommends cmccann create more and more permutation of the letters in his nick as other handles.
22:05:52 * ddarius is going to name his kid with a UUID.
22:06:09 <cmccann> ddarius, my email address is just "cam@...", how's that?
22:06:27 <cmccann> and I'm pretty sure I've got a couple variations with my first name spelled out here and there
22:06:42 <shachaf> cmccann: You should have a first name like "shachaf".
22:07:42 * cmccann wonders if his first and middle initials being letters that occur early in his last name is part of what obfuscates matters
22:08:05 <cmccann> shachaf, you'd be surprised how many people are unable to spell my first or last name as it is
22:08:32 <ddarius> How hard is KC to spell?
22:09:06 <cmccann> yeah, that's a common one
22:09:37 <shachaf> Everyone should be called "shachaf".
22:09:43 <shachaf> It would simplify matters.
22:09:51 <cmccann> shachaf, a persuasive argument indeed
22:10:07 <cmccann> though really, I think names are overrated
22:10:12 <shachaf> That's true.
22:10:16 <shachaf> /nick ""
22:10:30 * cmccann resolves to conduct all communication in pointless style, and thus avoid assigning names to people
22:10:47 <shachaf> Weren't you going to sleep?
22:11:18 <cmccann> I believe I said I needed sleep
22:11:24 <shachaf> Oh, yes.
22:11:47 <cmccann> that something needs to be true is not the same as demonstrating it to be so
22:12:18 <dankna> pointfree style.  pointless style is when you talk about the weather.
22:12:28 <shachaf> @help pl
22:12:28 <lambdabot> pointless <expr>. Play with pointfree code.
22:12:49 <dankna> yes, lambdabot doesn't provide guidance on terminology really, this is my own, er, style rule.
22:13:27 <azaq23> @help pointfull
22:13:27 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:14:10 <shachaf> @yhjulwwiefzojcbxybbruweejw
22:14:10 <lambdabot> "\"#$%&'()*+,\""
22:14:17 <azaq23> @pointful f . g
22:14:17 <lambdabot> (\ c -> f (g c))
22:14:44 <cmccann> speaking of pointless style, I wonder why the answer I posted on SO recently showing some pointfree refactoring was so popular :?
22:14:55 <triliyn> bracketSearch [] _ _ = error "Can't search empty list."
22:14:55 <triliyn> bracketSearch all@(thing:_) open close
22:14:55 <triliyn>    | thing == open = let num = calc all in
22:14:55 <triliyn>                           num + bracketSearch (drop num all) open close
22:14:55 <triliyn>    | thing == close = 0
22:14:57 <triliyn>    | otherwise = 1 + bracketSearch (tail all) open close
22:14:59 <triliyn>    where calc xs = 2 + bracketSearch (tail xs) open close
22:15:07 <shachaf> triliyn: Please don't paste more than a few lines of code into this channel.
22:15:10 <triliyn> Wait did I just do that in here? :$
22:15:11 <triliyn> Sorry
22:15:16 <shachaf> @paste instead.
22:15:16 <lambdabot> Haskell pastebin: http://hpaste.org/
22:15:20 <triliyn> That was supposed to be a msg
22:15:26 <triliyn> But there were newlines in it and I was stupid. :$
22:20:38 <russruss> hey, haven't used haskell in a while and never really was too familiar with it.  When you're writing an instance definition, where's the proper place to put auxiliary functions?
22:20:52 <cmccann> define "auxiliary"
22:21:20 <cmccann> in an instance declaration, you put functions that belong to the type class in there, and everything else you don't
22:21:22 <russruss> like, things I would normally put in a "where" block were I defining a normal function
22:21:39 <Jafet> You put them in a where block, as usual
22:21:46 <cmccann> can't you just stick a where block on any of the functions?
22:21:51 <russruss> oh hrm... maybe I've got the syntax wrong then
22:21:51 <cmccann> shouldn't be any different
22:22:04 <cmccann> maybe your indentation is weird?
22:22:41 <cmccann> and where blocks are per-binding, so you can't share between multiple definitions or anything, though that would be kinda convenient
22:22:51 <azaq23> though you can't easily have an another function which is used in all functions definitions of the instance declaration IIRC
22:23:38 <azaq23> well at least in some kind of "instance scope" which, I think, is the point you're inquiring on
22:23:50 <Jafet> Those just go outside of the instance definition.
22:24:17 <Jafet> There isn't any difference whether you're writing methods or other definitions
22:25:25 <cmccann> I think the idea is local definitions without cluttering up the top-level.
22:25:30 <cmccann> can always just not export them, though
22:30:59 <hpaste> russruss pasted “indenting is wrong?” at http://hpaste.org/48862
22:31:22 <russruss> hrm yeah I'm afraid I must have the indenting or something wrong... As I said it's been a while since I've done anything with haskell
22:31:50 <cmccann> the "where" for the function needs to be indented further
22:32:07 <Jafet> I usually indent “where” a half-tab.
22:32:22 <russruss> aha, yeah that was easy huh
22:32:38 <hpaste> “C. McCann” annotated “indenting is wrong?” with “indenting is wrong? (annotation)” at http://hpaste.org/48862#a48863
22:32:43 * cmccann would write it that way
22:33:16 <Jafet> I would too; but sometimes you need all the horizontal space you can get
22:33:45 <russruss> also, before I forget - is there anything I have to do to enable the pattern guards from ghc?
22:34:01 <russruss> or is that like that part of the language yet?
22:35:19 <cmccann> russruss, no, I think that's -XPatternGuards
22:35:31 <cmccann> or {-# LANGUAGE PatternGuards #-}
22:35:54 <cmccann> assuming you really mean the pattern guards extension, not regular guards on patterns
22:36:02 <russruss> right
22:36:25 <russruss> yeah is there like a new standard coming up ever?  there's some great stuff that seems like its just languishing in ghc extensions
22:36:37 <cmccann> russruss, standards are a slow process
22:36:54 <Jafet> @where haskell2010
22:36:54 <lambdabot> I know nothing about haskell2010.
22:36:59 <Jafet> @where haskell'
22:36:59 <lambdabot> http://hackage.haskell.org/trac/haskell-prime
22:37:10 <cmccann> if you're just coding for fun, I say learn to stop worrying and love the GHC extensions
22:37:22 <Jafet> Yeee-haa
22:37:36 <cmccann> riding an undecidable instance into the abyss while wearing a cowboy hat is optional
22:37:47 <russruss> hehe nice
22:38:46 <cmccann> but even within "serious" code there's a fair amount of GHC extensions that get used
22:39:20 <cmccann> any non-standard extensions that have close equivalents in other Haskell compilers are probably pretty safe
22:40:23 <russruss> yeah I mean I guess I don't really care enough to check which features other compilers have, so I shouldn't complain about there not being standards I suppose ;-)
22:40:44 <russruss> hard to imagine coding something real without like MultiParamTypeClasses
22:41:03 <djahandarie> By using TypeFamilies!
22:41:04 <cmccann> actually TypeFamilies tends to make that unnecessary
22:41:06 <cmccann> heh
22:41:24 <cmccann> which really goes to show just how useless MPTCs tended to be without fundeps
22:41:38 <ivanm> IIRC, there are a few cases you still need MPTCs
22:41:41 <cmccann> there are
22:41:46 <ivanm> and I've used MPTCs _with_ TypeFamilies!!!
22:41:53 <djahandarie> Not with superclass equalities afaik
22:41:56 <russruss> don't know that TypeFamilies :-).  Ah, the joys of being a beginner
22:42:01 <ivanm> djahandarie: yeah, but we don't have them yet :s
22:42:15 <djahandarie> We do now
22:42:28 <cmccann> superclass equalities obviate fundeps, but MPTCs in general?
22:42:41 <ivanm> djahandarie: not in a _released_ ghc
22:42:48 <cmccann> "we have them" in, what, snapshots of GHC HEAD? :P
22:42:58 <djahandarie> Yes. As of 2 weeks ago! :p
22:43:09 * cmccann is tempted...
22:43:12 <ivanm> cmccann: the only times I've used MPTCs with fundeps was when I was simulation superclass equalities
22:43:32 <ivanm> but MPTCs are also handy in cases of kind * -> * (but I don't use fundeps with it)
22:44:25 <cmccann> I expect there are cases where you legitimately want ad-hoc polymorphism with multiple dispatch on type paramters
22:44:43 <cmccann> but not as often as wanting a single parameter to dictate others, via fundeps or associated types
22:46:02 <cmccann> djahandarie, say, do you know which snapshots include the superclass equalities?
22:47:33 <djahandarie> I'm not sure.
22:48:16 <djahandarie> 940d1309e58382c889c2665227863fd790bdb21c is the commit
22:48:36 * cmccann doesn't think he can use the x86_64 versions on this machine, and doesn't feel like downloading an extra GHC if it doesn't have the change in question
22:49:01 <cmccann> and compiling GHC is :[
22:54:57 <cmccann> okay, time to call it a night I think
22:55:20 <djahandarie> The nice thing about superclass equalities is that you can get rid of GADTs. Entirely I think, or at least a large portion of them
22:56:00 <cmccann> djahandarie, it would be nice to have more orthogonality in some GHC extensions :T
22:56:28 <russruss> do people not like gadts?
22:56:34 <djahandarie> Nope, GADTs are great.
22:56:38 * cmccann is fine with GADTs
22:56:40 <djahandarie> I'd probably still use them anyways
22:56:53 <russruss> yeah the syntax is pretty usable
22:57:07 <cmccann> it's just the general situation of unrelated extensions that can be used to partially/completely reimplement each other that bugs me
22:57:29 <djahandarie> cmccann, http://blog.ezyang.com/2011/03/type-tech-tree/
22:57:43 <russruss> I mean haskell the language has a lot of non-orthogonality too, yeah?
23:00:07 <cmccann> djahandarie, heh, that's a fun blog post
23:00:20 <cmccann> anyway, sleep for seriously now, g'night folks
23:00:25 <djahandarie> Later
23:47:07 <ivanm> is there a pre-defined init function for Sequence?
23:49:56 <ivanm> (the alternative would be either using viewl or S.take (S.length s - 1) s ?
