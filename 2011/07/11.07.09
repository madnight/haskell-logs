00:01:21 <ddarius> Using viewl seems like it would be the right thing to do.
00:04:13 <ivanm> yeah, it's just not an inline definition :/
00:04:39 <ivanm> no, wait, it'd be viewr, not viewl
00:04:44 <ivanm> viewl would be fore tail
00:08:23 <ddarius> :t viewr
00:08:24 <lambdabot> Not in scope: `viewr'
00:08:27 <ddarius> @hoogle viewr
00:08:28 <lambdabot> Data.Sequence viewr :: Seq a -> ViewR a
00:08:28 <lambdabot> Data.Sequence data ViewR a
00:46:39 <iratsu> anyone here have experience with pcap
00:46:39 <iratsu> ?
01:01:20 <potato> Hello, all.
01:02:07 <potato> I was here a while ago, and I asked whether Haskell has an analogue of ML's signatures.
01:02:11 * ivanm waves idly in potato's general direction
01:02:15 <ivanm> potato: what are they?
01:02:25 <potato> Someone answered that Haskell unfortunately does not have a very mature module system.
01:03:14 <ceii_> potato: yes, modules in Haskell have no signatures, only an export list and import list. They also can't be parameterised by other modules
01:03:15 <potato> ivanm: With signatures, one can describe an interface to a module without giving away its implementation.
01:03:33 <potato> ceii_: Isn't that a pretty severe weakness?
01:03:44 <ivanm> potato: we have type classes instead
01:03:54 <ivanm> there are advantages and disadvantages to both type classes and ML-style Functors
01:04:33 <ceii_> "instead" might not be the right word, but since type classes, which were developed for a different purpose, can be put to some of the same uses as ML functors
01:04:41 <potato> Hm...
01:04:49 <ceii_> no-one ever bothered to improve Haskell's module system
01:05:14 <potato> So there is a way to describe an interface and easily switch between multiple implementations of the interface?
01:05:40 <ceii_> yes, you'd define a class that contains the operations in your interface
01:06:00 <ceii_> and client code can call your code which any instance of that class
01:06:31 <potato> When you say "class", is that analogous to Java's classes?
01:06:31 <ceii_> the main annoyance is that a given type can only be an instance of a class in one way, so some newtype use can be necessary
01:06:42 <ceii_> no, think a better Java interface
01:07:12 <potato> Please describe to me what you mean by "instance of [a] class".
01:07:16 <ceii_> a Haskell class is a set of operations that can be supported by a type
01:07:42 <ceii_> then, I can make a particular type an instance of a class by providing an implementation for these operations
01:08:14 <ceii_> for example, Haskell has a class Eq for equality defined like this:
01:08:19 <ceii_> class Eq a where
01:08:28 <ceii_>   (==) : a -> a -> Bool
01:08:45 <ceii_> and I could make booleans support equality with
01:08:50 <ceii_> instance Eq Bool where
01:09:01 <ceii_>   (==) True True = True
01:09:08 <ceii_>   (==) False False = False
01:09:14 <ceii_> (==) _ _ = False
01:09:25 <ceii_> oops, (==) False False should be True
01:09:31 <potato> :-)
01:10:14 <ceii_> then, a function that requires its arguments to support equality would have a type like
01:10:26 <ceii_> deleteElem :: Eq a => a -> [a] -> [a]
01:10:42 <ceii_> where the "Eq a" part is a constraint on the type variable a
01:12:16 <ceii_> so all in all, you can define a class (say Foo) with the operations you want, write your functions using the operations in Foo, and client code can define these operations later by instantiating Foo for a particular type
01:14:10 <ceii_> I have no idea if that was clear.
01:14:14 <potato> Hm...
01:14:29 <potato> Perhaps a concrete example of what I am getting at will illuminate things.
01:14:45 <potato> So a fairly common exercise is to implement a stack.
01:15:00 <potato> There are two basic operations, of course: push and pop.
01:15:17 <potato> One could conceivably use a single list to do this.
01:15:20 <potato> Or one could use two.
01:15:53 <ceii_> ah, you meant using signatures to implement abstract types
01:16:09 <potato> I suppose so.
01:16:12 <ceii_> you don't need type classes to do that, module export lists are enough
01:16:38 <ceii_> you'd define something like "newtype Stack a = MkStack [a]"
01:17:05 <ceii_> after which you can export the type itself (Stack) without its constructor (MkStack)
01:17:08 <potato> I am hoping there is some way for a client to be able to use the stack library and not notice at all if I replace the implementation with another correct one that provides an identical interface.
01:18:09 <Nereid> yeah you could do that with typeclasses.
01:18:11 <ceii_> well, if your module only has put, pop and Stack() in its export list
01:18:26 <Nereid> or
01:18:27 <ceii_> (where Stack() means the type Stack sith none of its constructors)
01:18:36 <Nereid> you don't have to.
01:18:47 <ceii_> then client code will only be able to manipulate your stacks using put and pop
01:19:08 <potato> ceii_: That sounds like exactly what I am looking for.
01:19:09 <Nereid> as long as you only expose stuff like
01:19:23 <Nereid> a type Stack :: * -> *, and functions such as push :: a -> Stack a -> Stack a
01:19:31 <Nereid> who cares what the internals of Stack are.
01:20:55 <potato> I started to teach myself Haskell a while back...  I dropped the project when I was told (perhaps incorrectly) that such things would be impossible with Haskell.
01:21:04 <potato> Perhaps it will be worth revisiting...
01:21:49 <Nereid> yeah, I wouldn't use typeclasses for something like this.
01:24:46 <potato> How much use does Haskell see commercially?
01:25:59 <Nereid> there's a wiki page for that too ;o
01:26:00 <Nereid> http://www.haskell.org/haskellwiki/Haskell_in_industry
01:27:14 <potato> Fascinating.
01:27:49 <potato> I work in aerospace, and I think functional languages would offer many benefits.
01:29:08 <ceii_> I think Haskell can be considered an established player in the "high assurance, high performance" niche
01:29:15 <ceii_> but I might be too optimistic
01:29:35 <potato> Of course, we won't be able to completely get away from C and assembly, but for the application flight code, it would be a lot easier to reason about Haskell code than C++ code, for example.
01:31:59 <potato> How does garbage collection work under Haskell?  Does computation completely cease for the garbage collector?
01:32:57 <ceii_> for now, yes. An independent per-core garbage collector is under development, which will alleviate this.
01:33:37 <ceii_> But I haven't heard of hard real-time-friendly garbage collection for Haskell
01:34:21 <maurer_> ceii_: I could see it being possible, if thunks under collection were switched out for a pause thunk that waited on a message from the gc
01:34:29 <maurer_> But I'm pretty sure we don't have one
01:34:30 <potato> Well, we cannot have that flying rockets!  ;-)
01:34:39 <ceii_> no :)
01:35:08 <ceii_> what some people do is use EDSLs embedded in Haskell to generate code suitable for embedded devices
01:36:16 <ivant> ceii_, http://research.microsoft.com/en-us/um/people/simonpj/papers/inc-gc.htm
01:36:56 <ceii_> ivant: oh, nice. Thanks
01:43:54 <potato> Thank you, all.  You have reinvigorated my interest in Haskell.
01:43:56 <potato> Good night.
01:57:20 <roconnor> isn't there some sort of parallel garbage collector already in GHC?
01:57:21 <lambdabot> roconnor: You have 2 new messages. '/msg lambdabot @messages' to read them.
01:58:32 <roconnor> @tell ddarius ya, I want type safety for my ST implementation.
01:58:32 <lambdabot> Consider it noted.
02:27:19 <xshay> hello
02:27:53 <xshay> I am trying to get a stack trace on an error. I tried adding "GHC-Options: -prof -auto-all" to my .cabal file.
02:28:35 <xshay> but then "cabal configure" complains that -prof is not required, but when I run my program with +RTS -xc I get an error saying it needs "-prof" (even when it is sent in GHC-Options)
02:28:54 <xshay> any ideas? I tried `cabal build --verbose` and it doesn't look like my options are even getting passed through to ghc :S
02:31:12 <shachaf> "group" is an actual keyword in the new fancy list comprehensions? :-(
02:31:25 <shachaf> I thought it was just using the function which happens to have the same name.
02:31:32 * shachaf should probably actually read about them.
02:50:58 <gfarfl> ux32pos
02:59:06 <akosch> is there an SMTP server implementation in haskell?
03:03:44 <akosch> i'm trying to build a little app, which acts as a SMTP proxy server; removes the recipients from emails which are not in a whitelist and (if any recipients are left) forwards the mail to a real SMTP server (as a SMTP client)
03:05:36 <akosch> I already did this using python and its built-in smtpd class (where I only needed to override the process_message function)
03:05:45 <akosch> but I want to do it with haskell too
03:05:49 <akosch> any ideas?
03:07:57 <merijn> akosch: There doesn't seem to be an smtpd library on Hackage yet, so you'd have to write one yourself. Which shouldn't be that difficult I think
03:08:13 <merijn> akosch: Especially if you only want to support functioning as a proxy
03:11:09 <akosch> merijn: thanks! I could use this for forwarding mail though, right? http://hackage.haskell.org/packages/archive/SMTPClient/1.0.1/doc/html/Network-SMTP-Client.html
03:11:41 <merijn> akosch: For sending it on one of the 3 SMTP client libraries should work
03:11:54 <akosch> merijn: which one are those?
03:12:32 <merijn> http://haskell.org/hoogle/?hoogle=smtp
03:15:13 <shachaf> akosch: http://hackage.haskell.org/package/postmaster seems to be an SMTP server?
03:15:46 <merijn> shachaf: I wants an MTA, not mail server, though
03:15:50 <merijn> err
03:15:52 <merijn> he, even
03:17:12 <shachaf> merijn: What do you mean?
03:17:42 <merijn> shachaf: postmaster says it does local delivery, he wanted to write a proxy which just sends e-mail on to an eventual actual mail server
03:18:16 <merijn> Now you could maybe hack procmail/whatever local delivery program to send it on for you, but that is not as nice
03:18:24 <merijn> Network.SMTP.Client seems to have the nicest/most complete data type for e-mail, btw
03:19:41 <shachaf> Ah, I suppose.
03:19:53 <shachaf> Still, it presumably has the code to parse SMTP requests and such?
03:20:16 <merijn> Worth taking a look at, yeah.
03:20:32 <merijn> On the other hand, SMTP is a fairly straightforward protocol to parse anyway :)
03:56:03 <saml> hey,   f (Foo "/foo/(.+)")  = ...    can I "overload" pattern matching so that the strings are matched using regex?
03:56:37 <merijn> saml: No, I do believe there is some work being done to create regex pattern matching but it isn't done yet
03:56:56 <saml> merijn, thanks
03:57:02 <merijn> saml: You could use guards and regex match in there to do it?
03:57:26 <saml> yes. i just wanted to look cleaner
04:14:08 <FUZxxl> Hello
04:45:11 <w3rs> Hi all. When building a project with cabal, I get "Unexpected semi-colons in conditional: ...Perhaps you meant to use -XDoAndIfThenElse?" error
04:45:50 <w3rs> With ghc 7.0.4 . Haven't they remove it in the 2010 report?
04:47:24 <w3rs> with ghci all compiles without this flag
04:47:42 <fasta> Is there a database library which is not contrived and which does not export all kinds of pointless stuff?
04:49:29 <w3rs> fasta: will SQLite suite? There are at least 2 bindings
04:49:51 <fasta> w3rs: mysql in this case.
04:50:16 <fasta> w3rs: I checked out 3 libraries now, of which two likely work, but are contrived and the third one doesn't compile according to hackage.
04:52:00 <w3rs> fasta: I used HDBC with SQLite, haven't notice much of pointless stuff :)
04:52:21 <fasta> w3rs: have you looked at the HDBC API?
04:52:33 <fasta> w3rs: it is huge for what it does.
04:54:42 <fasta> w3rs: ah, the drivers document usage.
04:57:54 <w3rs> fasta: sorry, I'm not a DB expert, I don't know how much is huge for generic DB API
04:58:31 <w3rs> db-specific libraries must be lighter
05:09:17 <saml> Couldn't match expected type `Data.ByteString.Lazy.Internal.ByteString' with actual type `Data.ByteString.Internal.ByteString'
05:10:32 <rostayob> saml: ghc is expecting a lazy bs and you're using a strict one
05:10:45 <saml> so, do I have to use .pack ?
05:11:01 <rostayob> saml: I didn't get your previous message, I just logged in
05:11:29 <rostayob> where is the problem arising?
05:12:22 <rostayob> but yes, the pack from Text.ByteString.Lazy.Char8 will work if you're converting a string
05:13:04 <rostayob> if you're converting a strict bytestring to a lazy one, you have to unpack to and pack again
05:13:17 <saml> http://hpaste.org/48866
05:14:28 <rostayob> where is the error? I mean what line
05:14:52 <saml>     return (responseLBS statusOK [("Content-Type", "text/plain")] path)
05:14:59 <saml> path is Interal.ByteString
05:15:12 <saml> responseLBS expects Lazy.Internal.ByteString
05:15:26 <rostayob> yes, you have to unpack and pack again
05:15:38 <akosch> how can I pass a type to a function? http://hpaste.org/48867
05:16:16 <saml> rostayob, which unpack and pack do I use?  from what module?
05:16:31 <saml> how do I find out which pack/unpack to use next time?
05:16:39 <rostayob> import Data.ByteString.ByteString as BS; import Data.ByteString.Lazy as LBS; let path = LBS.pack . BS.pack . rawPathInfo $ req
05:16:43 <rostayob> something like this
05:16:59 <rostayob> saml: what do you mean which pack/unpack to use?
05:17:13 <rostayob> if you're using a lazy bs and you're given strict bs, you have to convert them
05:17:41 <rostayob> sorry, let path = LBS.pack . BS.unpack . rawPathInfo $ req
05:17:44 <ion> akosch: You can’t use a type as a value and vice versa. Make getOption’s type the rights one and let type inference handle the type of the expression within.
05:17:45 <rostayob> not BS.pack :P
05:17:52 <saml> oh okay. so there are two kinds of bytestrings. lazy and strict.  i was confused with Char8 and Word8..etc
05:18:29 <akosch> ion: thanks, it should have been obvious :)
05:18:50 <rostayob> saml: yes there are two kind of bytestrings. the .Char8 stuff it's just an utility module to have functions operating on Char instead that on Word8
05:19:05 <ion> akosch: ‘let listenPort = getOption "SERVER" "listen_port" :: Integer’, ‘listenPort :: String -> String -> a’
05:19:24 <ion> akosch: Sorry, the last one should have been ‘getOption :: String -> String -> a’
05:20:02 <akosch> ion: thanks again, it's already working
05:23:44 <akosch> ion: could I compose my getOption function out of read, forceEither and get?
05:24:50 <fasta> w3rs: hmm, I got hdbc to work and got rid of my real-world problem. :)
05:26:37 <ClaudiusMaximus> wow, i must suck somewhere along the line - my peek/poke histogram code runs at 24fps (with negligible cpu load), but my attempt using Repa barely manages 2fps while pegging both cores :(
05:28:02 <ion> akosch: Using forceEither seems a bit nasty to me.
05:28:22 <saml> > foldr (',':) "" ["a", "b"]
05:28:23 <lambdabot>   Couldn't match expected type `b -> b'
05:28:23 <lambdabot>         against inferred type `[GHC.T...
05:30:10 <saml> > foldr (\a b -> a++ ',':b) "" ["a", "b"]
05:30:11 <lambdabot>   "a,b,"
05:30:56 <ClaudiusMaximus> ...heh, posting that made i realize it was doing on average 256 times more work (adding 255x 0 and 1x 1 for each bin, instead of finding the bin and incrementing it..)
05:30:57 <akosch> ion: yeah, I'm going to fix that to use the error monad
05:31:25 <saml> what is proper way to construct a String out of [String]  by deliminting with a String?
05:31:42 <saml> f ["a", "b"]  "," ==>  "a,b"
05:31:56 <ClaudiusMaximus> > intercalate " hello " ["why", "there"]
05:31:56 <lambdabot>   "why hello there"
05:32:40 <saml> that's Data.List ?
05:32:47 <saml> it is
05:33:33 <erus`> http://hpaste.org/48868 json scripting language :)
05:49:54 <erus`> do infix functions have to take 2 args?
05:50:13 <erus`> > let f x y z = x + y + z in 1 `f` 2 3
05:50:14 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
05:50:14 <lambdabot>    arising from a use of `...
05:50:20 <erus`> > let f x y z = x + y + z in 1 `f` 2
05:50:21 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
05:50:21 <lambdabot>    arising from a use of `...
05:50:32 <erus`> > let f x y z = x + y in 1 `f` 2
05:50:33 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t1)
05:50:33 <lambdabot>    arising from a use of ...
05:51:26 <nlogax> > let f x y z = x + y + z in (1 `f` 2) 3
05:51:27 <lambdabot>   6
05:52:29 <erus`> why does 1 `f` 2 3 not work?
05:52:52 <Saizan> erus`: because that's  1 `f` (2 3)
05:53:17 <erus`> what type is (2 3)
05:53:34 <erus`> its just two args?
05:53:42 <Saizan> it's 2 applied to 3
05:54:14 <erus`> in f 1 2 3 f is applied to 1 2 3 no 1 and (2 3)
05:54:38 <erus`> i guess its so you can chain them together?
05:54:40 <sipa> f 1 2 3 = ((f 1) 2) 3
05:54:56 <Saizan> what sipa said
05:55:15 <erus`> ah ok
05:56:33 <Saizan> so, the point is that prefix application is left associative and has greater precendence than the infix one
05:57:56 <Saizan> (higher, i guess)
06:00:41 <saml> how can I see loaded modules in ghci?  :show modules is empty
06:02:08 <parcs> there're enumerated in the prompt
06:02:19 <saml> in ghci, I do:    import Text.Regex     then,  :show modules  but it's empty
06:02:29 <saml> i also did  :set prompt "> "
06:02:40 <saml> I did not want to clutter prompt.. but see loaded or imported modules
06:08:40 <erus`> is let f x = x + x and expression or a statement?
06:08:53 <saml> erus`, expression
06:09:16 <erus`> so i can use this inside another expression right?
06:09:25 <saml> erus`, yes.
06:09:35 <exlevan> saml: if it's expression, what does it return?
06:09:55 <saml> :t let f x = x + x  in f
06:09:56 <lambdabot> forall a. (Num a) => a -> a
06:10:08 <exlevan> so, part of expression
06:10:17 <erus`> :t let f x = 123
06:10:17 <lambdabot> <no location info>: not an expression: `let f x = 123'
06:10:41 <Botje> exlevan: a let expression returns whatever its body returns.
06:10:47 <saml> i'm not sure.. in do notation, you can have let f x ..
06:10:58 <Botje> let in do notation is a different beast.
06:11:29 <Botje> do { ...; let f x = 123; ... } compiles to ... >> let f x = 123 in ...
06:11:31 <saml> erus`, ghci> prompt is do
06:11:50 <Botje> so there, the 'return' of the let is the rest of the do block
06:11:55 <erus`> ah ok
06:17:13 <erus`> how can i see where the interpretter ads brackets?
06:17:26 <erus`> > (+) 1 2 + 3
06:17:26 <lambdabot>   6
06:17:39 <merijn> > (+) 1 2 + 3 :: Expr
06:17:40 <lambdabot>   1 + 2 + 3
06:17:54 <merijn> Expr is a lambdabot extension I think, though
06:18:28 <Saizan> it's just a library
06:19:30 <erus`> i swear i have seen someone do the brackets thing on here
06:19:57 <merijn> It depends on the expression I think? You probably saw something like:
06:20:05 <merijn> > foldr f [1..10]
06:20:06 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [t])
06:20:06 <lambdabot>    arising from a use ...
06:20:08 <merijn> hmm
06:20:12 <merijn> > foldr f 0 [1..10]
06:20:13 <lambdabot>   Ambiguous type variable `b' in the constraints:
06:20:13 <lambdabot>    `GHC.Num.Num b'
06:20:13 <lambdabot>      ari...
06:20:17 <erus`> > (+) 1 2 + 3 -- this will work
06:20:18 <lambdabot>   6
06:20:27 <Saizan> > foldr f z [1..10]
06:20:27 <merijn> > foldr f 0 [1..10] :: Expr
06:20:27 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 z)))))))))
06:20:28 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 0)))))))))
06:20:29 <erus`> > (+) 1 + 2 3 -- this will not
06:20:29 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
06:20:30 <lambdabot>    arising from a use of `...
06:20:38 <merijn> erus`: Of course
06:20:51 <merijn> erus`: The second argument to (+) is + which is nonsense
06:21:18 <merijn> (+) 1 + 2 3 == ((((+) 1) +) 2) 3)
06:21:21 <Saizan> no
06:21:40 <Saizan> (+) 1 + 2 3 = ((+) 1) + (2 3)
06:21:42 <opqdonut> that means (+) ((+) 1) 2 3
06:21:52 <merijn> oh, right
06:21:59 <merijn> Ignore me >.>
06:22:05 <Saizan> (+) ((+) 1) (2 3)
06:22:06 <opqdonut> which actually does make sense with the Num a => Num (r -> a) instance :)
06:22:13 <Jafet> (+ 1 + 2 3)
06:22:29 <erus`> ok i think i get it
06:22:31 <erus`> :D
06:22:40 <opqdonut> > (+) 1 + 2 3 $ 9000
06:22:40 <lambdabot>   9003
06:22:42 <opqdonut> :)
06:22:52 <opqdonut> think a bout that for a second!
06:23:13 <Botje> it's over 9000?
06:23:25 <Jafet> > 2 3
06:23:26 <lambdabot>   2
06:24:35 <erus`> but i still dont understand why this wont work f x y z = 1 in 1 `f` 2 3
06:24:44 <erus`> (((f 1) 2) 3
06:24:54 <merijn> No
06:25:01 <merijn> infix has lowest priority
06:25:31 <merijn> Example: "f 1 + f 2" is "(f 1) + (f 2)"
06:25:51 <nicoo> (1 `f` 2) 3 could/should work
06:26:06 <nicoo> > f x y z = 1
06:26:07 <lambdabot>   <no location info>: parse error on input `='
06:26:15 <merijn> So "1 `f` 2 3" is seen as "1 `f` (g 3)"
06:26:21 * nicoo facepalms
06:26:22 <merijn> And of course applying 2 to 3 is nonsense
06:26:35 <merijn> (Well, not in lambdabot, but still)
06:26:45 <nicoo> ghci
06:26:57 <nicoo> er, wrong term, sorry
06:27:08 <erus`> 1 `f` (2 3)
06:27:15 <erus`> thats what it sees then?
06:27:19 <nicoo> yep
06:27:46 <merijn> Yes
06:27:53 <erus`> > (+) 1 2 + (+) 3 4
06:27:54 <lambdabot>   10
06:28:06 <erus`> i think shes got it!
06:28:12 <sipa> that's the same as + ((+) 1 2) ((+) 3 4)
06:28:14 <nicoo> (in fact, it sees an AST, but it's far more bothersome to do over IRC)
06:28:15 <sipa> eh
06:29:00 <Jafet> Guys, stop failing to type Lisp code in Haskell!
06:30:03 <merijn> Jafet: It's part of my plan for the new language "Hathkell" :D
06:30:35 * sipa invokes xkcd 297
06:31:42 <mornfall> Is there a two-index splice operation on bytestrings? :-) I can't see it.
06:31:55 <mornfall> (Other than drop . take or vice versa...)
06:31:56 <hpc> sipa: haha, well played
06:32:06 <merijn> @hoogle Int -> Int -> [a]
06:32:06 <lambdabot> Prelude replicate :: Int -> a -> [a]
06:32:06 <lambdabot> Data.List replicate :: Int -> a -> [a]
06:32:06 <lambdabot> Data.Graph.Inductive.Internal.FiniteMap rangeFM :: Ord a => FiniteMap a b -> a -> a -> [b]
06:32:10 <Jafet> take/drop should work
06:32:30 <mornfall> Jafet: I know it works. It just isn't as convenient in this usecase.
06:32:36 <parcs> it should be fast too
06:32:49 <mornfall> Probably fused, I know. But still!
06:32:51 <Jafet> I don't think you can really splice them, since they're represented as [Chunk].
06:33:02 <mornfall> Jafet: I have the strict ones.
06:33:14 <Jafet> Well then, perhaps you can
06:36:22 <parcs> mornfall: take/drop is O(1), simple integer manipulation
06:36:34 <mornfall> Hey, I'm not stupid! :-)
06:36:47 <mornfall>   where splice bs x y = drop x bs $ take (x + y) bs
06:36:47 <ion> drop is O(n)
06:37:03 <mornfall> ion: With strict bytestring? It definitely shouldn't.
06:37:10 <Jafet> Not sure fusion is relevant to strict bytestrings
06:37:14 <mornfall> As long as it shares the data, which it probably always does.
06:37:25 <ion> Was about to say “Whoops, take also. Misread that as head for some reason” but okay, i thought we were talking about lists.
06:38:03 <Jafet> It's still O(n/chunksize) for Lazy, though. Perhaps that could be improved
06:38:04 <mornfall> One extra bs, too.
06:38:20 <mornfall> Jafet: Unlikely.
06:39:13 <Jafet> Using something like a right-lazy tree (which I made up for this sentence)
06:39:45 <Jafet> take also allocates n chunks (sharing buffers)
06:39:54 <Jafet> Er, ~n/chunksize chunks
06:40:41 <akosch> is there a function like unwords where I can specify the delimiter?
06:40:53 <hpc> @src unwords
06:40:53 <lambdabot> unwords [] = ""
06:40:53 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
06:40:55 <mornfall> akosch: You could use concatmap.
06:41:01 <mornfall> concatMap, whatever.
06:41:05 <akosch> mornfall: thx
06:41:07 <Jafet> :t intercalate
06:41:08 <lambdabot> forall a. [a] -> [[a]] -> [a]
06:41:10 <melle> akosh, intercalate
06:41:18 <mornfall> Right, that's the right one too. :-)
06:41:27 <hpc> @hoogle intercalate
06:41:27 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
06:41:27 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
06:41:27 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
06:41:38 <hpc> (mind your imports)
06:41:48 <akosch> thank you, I'll check it out
06:41:52 <mornfall> Yeah intercalate's better. You probably don't want your delimiter repeated once too many times.
06:42:08 <mornfall> one
06:42:17 <mornfall> Give me food, and maybe sleep, and I'll stop talking nonsense.
06:47:00 * nicoo feeds mornfall 
06:47:22 <erus`> > (+) 3 (if 1 == 1 then 1 else 2) -- this works
06:47:23 <lambdabot>   4
06:47:31 <erus`> > (+) 3 if 1 == 1 then 1 else 2 -- this does not
06:47:32 <lambdabot>   <no location info>: parse error on input `if'
06:48:04 <erus`> if has to be at the top level?
06:48:12 <erus`> what is the correct terminology?
06:48:56 <c_wraith> > (+) 3 $ if 1 == 1 then 1 else 2 -- this does
06:48:57 <lambdabot>   4
06:49:14 <c_wraith> It's got to do with the grammar rules for haskell
06:49:15 * roconnor fails at proving p(X) and q(X-Y) are coprime.
06:49:46 <c_wraith> if and do have pretty similar rules for where they can be used.
06:49:58 <c_wraith> same as lambda expressions, and a few other things
06:50:37 <c_wraith> There are terms for the grammar definitions in the haskell report.  I don't find the terms especially enlightening.
06:50:57 <c_wraith> I mentally think of them as "places I could use do"
06:51:14 <erus`> oh ok
06:51:26 <erus`> whats the term for a function that takes no arguements?
06:51:33 <c_wraith> value :)
06:51:43 <c_wraith> haskell doesn't have 0-arg functions
06:51:49 <c_wraith> in other languages, nullary
06:51:49 <ousado> c_wraith: thinking mentally is a big risk you should consider carefully :)
06:51:53 <wli> CAF's?
06:52:12 <c_wraith> ousado: I can handle the risk! :)
06:53:33 <erus`> values and functions are both ____?
06:53:51 <ion> values
06:54:04 <erus`> hmm
06:54:56 <ousado> pure functions that is
06:55:17 <merijn> ousado: Haskell doesn't have non-pure functions
06:55:21 <ousado> or is functions and pure functions both pure functions
06:55:49 <parcs> > if if True then 1 else 0 else 7
06:55:50 <lambdabot>   <no location info>: parse error on input `else'
06:56:33 <parcs> > if if True then True else False then 5 else 7
06:56:34 <lambdabot>   5
07:00:21 <parcs> > let if' t f p = if p then t else f in fix (\
07:00:22 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:00:53 <parcs> damn you dvorak
07:04:51 <dbpatterson> is there a way to ghc-pkg hide a package when using cabal-dev? Trying to load something interactively and getting the monads-fd vs mtl error (I know I can do package qualified imports, but would prefer the simpler)
07:11:29 <akosch> I have this little code here: http://pastebin.com/vDzyzFjn
07:11:33 <mauke> The paste vDzyzFjn has been copied to http://hpaste.org/48869
07:11:57 <akosch> and I want to parse my configuration using Data.ConfigFile
07:12:42 <akosch> I want parseConfig to return the default configuration if it fails to read the one from the file
07:12:59 <akosch> how would I do this properly?
07:15:16 <akosch> I already hacked something together, but it was unreadable and convoluted so I decided to ask instead :)
07:24:24 <erus`> everything after the = is a value?
07:24:29 <erus`> a list of values i mean
07:28:57 <Saizan> akosch: Cabal deals with similar problems for its configuration files, and there's a nice sublibrary for this hidden in the sources
07:29:43 <akosch> Saizan: thx, I'll check on the cabal sources then
07:30:32 <gigabytes> \msg lambdabot
07:30:36 <gigabytes> hm.. :(
07:30:43 <merijn> erus`: Mostly, yes.
07:31:36 <erus`> then we just step through applying a value to the function before it
07:33:20 <erus`> leaving a curried function or a value
07:35:24 <merijn> erus`: A curried functions is a value
07:35:37 <Saizan> akosch: cmdargs is also dealing with something similar, i think
07:35:42 <merijn> All functions are values in haskell
07:44:41 <monochrom> you are speaking of eg "x+x" in "f x = x+x". I am not sure whether you want "expression" or "value"
07:46:04 <monochrom> strictly, "x+x" as a piece of code is expression, when you run the program you eventually get values out of it. but it's also ok to consider them the same
07:46:47 <dbpatterson> in GHCi, I run into this problem: Loading package double-conversion-0.2.0.0 ... can't load .so/.DLL for: stdc++ (libstdc++.so: cannot open shared object file: No such file or directory)
07:47:09 <dbpatterson> I have that .so file, but where would GHCi be looking for it, so I can symlink it?
07:47:40 <merijn> monochrom: Well, in Haskell expressions are values just as much as functions are, no?
07:48:31 <sipa> i'd say expressions evaluate to values
07:48:37 <sipa> but the line is fuzzy
07:48:48 <Jafet> Expressions are syntactic units.
07:49:45 <merijn> Hmm, yeah. I guess I don't really think that expressions as values now that I think of it
07:49:59 <Jafet> As monochrom said, you can equate them with their values, given some semantics
07:50:10 <monochrom> that is the same question again. depend on whether you think "this piece of code \x->blah is function" or "when you run the program you get a function out of that piece of code" or "who cares, same difference"
07:50:43 <Jafet> I think it's important to keep the distinction in mind
07:51:00 <monochrom> IOW "program syntax" vs "mathematical function" vs "same"
07:51:25 <Jafet> Eg. “undefined” is one expression, but its “value” depends on whether you're using the simple denotational semantics or something else
07:51:43 <Jafet> (something else, that distinguishes one bottom from another)
07:51:55 <merijn> *insert lame sexist pun*
07:52:38 <monochrom> after the lesson of unicode, it is more general to draw a line, so you can swap in something else
07:53:07 <Jafet> > let _⟂_=undefined in (⟂) (.)(.)
07:53:08 <lambdabot>   Ambiguous type variable `f' in the constraint:
07:53:08 <lambdabot>    `GHC.Base.Functor f'
07:53:08 <lambdabot>     ...
07:53:14 <monochrom> "the bytes that convey characters" vs "characters"
07:56:04 <Jafet> (code points *cough*)
07:57:11 <monochrom> in fact, even without unicode. the symbols "31" vs the idea of thirty one vs the words "thirty one"
07:58:01 <Jafet> That's okay, english is untyped
07:58:10 <monochrom> equating all three works for a while. but when you want to be more general --- base-N notation, or replace english by chinese --- you have to separate them
07:58:36 <monochrom> otoh if you don't need the generality, why bother
07:59:05 <ziman> is it? Are "verbs" vs. "nouns" vs. "adjectives" not kind-of types required to form a "well-typed sentence"? :)
07:59:19 <Jafet> As Russell etc. amply demonstrated
07:59:32 <monochrom> Piaget's theory says concrete before abstract, special before general, so I don't mind beginning with no separation
08:01:20 <comonade> monochrome before polychrome?
08:01:48 <Jafet> @quote all.procrastination
08:01:48 <lambdabot> ksf says: ...premature generalisation is the root of all procrastination.
08:02:15 <akosch> based on the example here: http://hackage.haskell.org/packages/archive/ConfigFile/1.0.5/doc/html/Data-ConfigFile.html I've gone this far: http://pastebin.com/dNqk0VF7 The problem is that I'm stuck: I can't figure out how to assign my configuration parameters in parseConfig to my AppConfig type
08:02:18 <mauke> The paste dNqk0VF7 has been copied to http://hpaste.org/48870
08:03:25 <akosch> any ideas?
08:12:26 <akosch> the main problem is, that I don't know how to specify what type 'get' should return. I can print the values easily using liftIO, but don't know how to create my own AppConfig from the results
08:14:57 <Saizan> akosch: it's like read, you just use it at the type you want and type inference does the rest
08:16:33 <akosch> Saizan: ok, but how do I lift my creation of AppConfig into the monad?
08:18:36 * hackagebot hxmppc 0.2 - Haskell XMPP (Jabber Client) Command Line Interface (CLI)  http://hackage.haskell.org/package/hxmppc-0.2 (NicolasPouillard)
08:20:34 <Saizan> akosch: instead of return "done" you could return $ AppConfig { .... }
08:21:52 <ski> (`$' is not needed)
08:22:00 <ski> ddarius : i thought subtyping is both implicit injections and implicit projections
08:22:33 <akosch> Saizan: thanks, I'll try :)
08:22:37 <ski> > Just Node {rootLabel = (),subForest = []}
08:22:38 <lambdabot>   Just (Node {rootLabel = (), subForest = []})
08:24:19 <parcs> > Nothing {}
08:24:19 <lambdabot>   Nothing
08:24:30 <parcs> > Nothing {} {} {} {}
08:24:30 <lambdabot>   <no location info>: Empty record update
08:24:32 <akosch> Saizan: hey, this really works... thanks again! ;)
08:24:55 <parcs> > (Nothing {}) {}
08:24:56 <lambdabot>   <no location info>: Empty record update
08:25:13 <parcs> hmmm
08:25:46 <monochrom> heh, that is not nice
08:26:27 <parcs> > (Nothing) {}
08:26:28 <lambdabot>   <no location info>: Empty record update
08:27:02 <parcs> oh i see
08:27:25 <Saizan> akosch: http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/syntax-extns.html#record-wildcards <- might be handy here
08:30:30 <ski> > (Node () []) {rootLabel = False,subForest = []}  -- nice, type-changing updates work
08:30:31 <lambdabot>   Node {rootLabel = False, subForest = []}
08:32:02 <monochrom> this is because:
08:32:09 <monochrom> @type \ Nothing -> Nothing
08:32:10 <lambdabot> forall t a. Maybe t -> Maybe a
08:33:50 <monochrom> hrm, maybe not so related afterall
08:34:32 <ski> @undo (Node () []) {rootLabel = False,subForest = []}
08:34:32 <lambdabot> (Node () []){rootLabel = False, subForest = []}
08:34:57 <ski> "Any fields that are not in scope are not filled in." -- sounds a bit dangeruous
08:35:09 <orifichu> i can't install unix-compat....i have some errors
08:35:16 <ski> (re record wildcards, i.e.
08:35:17 <ski> )
08:36:18 <parcs> > fromJust Just {}
08:36:19 <lambdabot>   *Exception: <interactive>:3:9-15: Missing field in record construction
08:36:45 <parcs> > const () Just {}
08:36:46 <lambdabot>   ()
08:36:56 <hpaste> orifichu pasted “unix-compat install error” at http://hpaste.org/48872
08:37:09 <ski> > let rootLabel = (); subForest = [] in Node {..}
08:37:10 <lambdabot>   Illegal `..' in record construction
08:37:10 <lambdabot>  Use -XRecordWildCards to permit this
08:37:12 <ski> vs.
08:37:15 <ski> > let rootLabel = () in Node {..}
08:37:16 <lambdabot>   Illegal `..' in record construction
08:37:16 <lambdabot>  Use -XRecordWildCards to permit this
08:37:25 <parcs> runtime exceptions make me sad
08:37:37 <ski> both are allowed, but the latter will not set the `subForest' field
08:38:18 <ski> > seq () Just {}
08:38:19 <lambdabot>   Just *Exception: <interactive>:3:7-13: Missing field in record construction
08:38:29 <ski> > seq Just {} ()
08:38:30 <lambdabot>   ()
08:40:14 <orifichu> that's the log....in the log there is some packages not found....which of those are necessary?
08:40:29 <orifichu> orifichu pasted “unix-compat install error” at http://hpaste.org/48872
08:44:44 <parcs> -Wall doesn't even warn about Just {}
08:47:00 <Tomsik> What is the reason for records not being first-class in haskell like they are in ocaml?
08:48:16 <gwern> Tomsik: no one can decide which records to use
08:48:22 <gwern> there are an awful lot of record systems?
08:48:46 <Tomsik> Like in type-systems or like libraries?
08:49:20 <monochrom> like in type systems
08:49:48 <Tomsik> Okay, so is this just lack of an implementation or is there a different problem?
08:50:49 <akosch> I think I'm quite satisfied with the result of this config parsing (thanks Saizan): http://pastebin.com/8MzWmThR The last thing that I want to do is print a warning that the default configuration has been used because of a parsing error; how would I do this most elegantly?
08:50:52 <mauke> The paste 8MzWmThR has been copied to http://hpaste.org/48873
08:51:21 <monochrom> orifichu: all the not-found's do not matter. and I don't know why hsc2hs fails
08:51:29 <dogbert> I keep getting "Not in scope: 'Char.isSpace' in GHCi even though i'm importing Data.Char.. any idea why?
08:52:10 <orifichu> monochrom: mmm...i will try installing unix-compat manually
08:53:12 <Saizan> dogbert: use Data.Char.isSpace
08:53:36 <monochrom> installing manually should be just as failing
08:53:47 <parcs> or import Data.Char as Char
08:53:57 <dogbert> hmm thanks Saizan, that seems to work
08:54:09 <dogbert> why doesn't the import take care of that?
08:54:29 <monochrom> at this point I would suspect corrupted files
08:55:11 <parcs> dogbert: take care of what?
08:55:45 <dogbert> the Char reference.. shouldn't importing the module make Char.isSpace in scope?
08:55:52 <parcs> no
08:56:11 <orifichu> monochrom: how can i install an unix-compat old version package with cabal?
08:56:31 <parcs> they're two different namespaces
08:56:45 <dogbert> I don't have to specify Control.Monad.liftM
08:56:58 <Saizan> if you import Data.Char
08:57:05 <Saizan> you can use isSpace
08:57:11 <Saizan> but not Char.isSpace
08:57:31 <dogbert> so if I import Data, I can use Char.isSpace?
08:58:05 <monochrom> it installs fine for me. no tricks. I don't know what's wrong.
08:59:48 <parcs> dogbert: no. Data and Data.Char don't know or care about each other
08:59:55 <orifichu> monochrom: yes but which is the command to install an old version package with cabal? because with "cabal install unix-compat" the last unix-compat version will be installed
09:09:31 <orifichu> monochrom: when i try installing manually with the same code of the log it creates a "Extensions.hs" file in "/unix-compat-0.2/dist/build/System/PosixCompat" directory but the next line in the log is "running dist/build/System/PosixCompat/Extensions_hsc_make failed".....some idea why?
09:11:18 <flonum> Question: the definition
09:11:19 <flonum> x `bind'` f = ((\_ -> x) >=> f) ()
09:11:19 <flonum> isn't obviously the same as the usual
09:11:19 <flonum>  x >>= f = (id >=> f) x
09:11:19 <flonum> - i.e., I can't find a proof of equality unless you assume >=> is defined in terms of (>>=), in which case both sides reduce to x (>>=) f, but for the same reason I can't find a counterexample ... so is bind' an acceptable bind ?
09:15:16 <Tomsik> @src (>=>)
09:15:17 <lambdabot> Source not found. Take a stress pill and think things over.
09:16:18 <Tomsik> :t liftM (. id)
09:16:19 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> m (a -> b)
09:16:34 <Tomsik> :t (id >=>)
09:16:34 <lambdabot> forall (m :: * -> *) b c. (Monad m) => (b -> m c) -> m b -> m c
09:17:29 <Tomsik> You're basically asking if x >>= f == (const x >=> f) (), right?
09:18:04 <orifichu> i need some help installing unix-compat-0.2
09:18:06 <orifichu> orifichu pasted “unix-compat install error” at http://hpaste.org/48872
09:18:51 <flonum> Either that or if there's a proof that the right hand side satisfies the monad laws for (>=>) -- but I suspect if the latter is true then there's a canonical isomorphism ?
09:26:29 <flonum> If you assume you have >=> written in terms of a "canonical" bind operator then they both reduce to that ...
09:26:37 <flonum> i.e. x >>= f
09:27:27 <monochrom> orifichu, do you have gcc?
09:27:34 <orifichu> yes
09:27:52 <monochrom> I don't know why hsc2hs fails for you
09:28:18 <monochrom> hsc2hs is a program as part of ghc
09:28:35 <monochrom> I just hope your ghc installation is not corrupted
09:29:20 <orifichu> monochrom: tell me something, the line "running dist/build/System/PosixCompat/Extensions_hsc_make failed" means that the error occurred executing the "extensions.hsc" file?
09:30:11 <monochrom> no, look at the lines just before and just after
09:31:58 <edwardk> hrmm. i'm starting to reach the limit where my algebra library can be haskell 98. now im torn between adding the other stuff directly to it, in the style of category-extras, or splitting it into a haskell 98 package and stuff layered on top
09:32:31 <orifichu> monochrom: because when i run the previous line(the large one) manually, it runs without problems...it line creates a "Extensions.hs" file in "/unix-compat-0.2/dist/build/System/PosixCompat" directory
09:32:46 <monochrom> ok I see
09:33:16 <edwardk> i have lots of things that want to be modules or algebras, etc but to do that i need mptcs and/or type families
09:33:57 <orifichu> monochrom: but i dont know wich is the next line to execute to finish the unix-compat install because there is no more lines in the log
09:34:33 <monochrom> well, I can't reproduce the error here
09:34:46 <erus`> how do i define functions with symbols?
09:35:13 <edwardk> another option would be to split the package slightly differently, making an 'algebra' package, which provides the haskell 98 classes but only the data types used by the classes, an algebra-fd which offers the fundep stuff, and 'algebras' which provides the actual instances, but would require both most likely
09:35:13 <monochrom> @define x ♥ y = x ++ " loves " ++ y
09:35:19 <ousado> edwardk: hey, watched your talk on lenses, very nice
09:35:24 <monochrom> @bots
09:35:24 <lambdabot> :)
09:35:31 <edwardk> ousado: thanks =)
09:35:32 <monochrom> oh, not @define
09:35:38 <monochrom> @let x ♥ y = x ++ " loves " ++ y
09:35:39 <lambdabot>  Defined.
09:35:43 <monochrom> that's how
09:36:01 <monochrom> > "haskell" ♥ "me"
09:36:03 <lambdabot>   "haskell loves me"
09:36:14 <erus`> > let # = +
09:36:15 <lambdabot>   <no location info>: parse error on input `#'
09:36:22 <erus`> > let # = + in 2 # 3
09:36:22 <monochrom> no, not like that
09:36:22 <lambdabot>   <no location info>: parse error on input `#'
09:36:35 <edwardk> > "monochrom" ♥ "haskell"
09:36:37 <lambdabot>   "monochrom loves haskell"
09:36:47 <monochrom> did you see the "x" and the "y" on the left and right of "♥"?
09:37:06 <erus`> > let x # y = x + y
09:37:06 <lambdabot>   not an expression: `let x # y = x + y'
09:37:11 <erus`> > let x # y = x + y in 2 # 3
09:37:12 <lambdabot>   5
09:37:13 <edwardk> > let (#) = (+) in 2 # 3
09:37:14 <lambdabot>   <no location info>: parse error on input `)'
09:37:48 <erus`> > let x # y z = x + y + z in 1 # 3 4
09:37:49 <lambdabot>   <no location info>: Parse error in pattern
09:37:50 * monochrom doesn't understand why when people mutate working examples they mutate all the wrong sites
09:37:57 <edwardk> infix operators by default need to be applied to both arguments, if you want to apply them to fewer you need to 'section' them. wrapping an operator in parentheses makes a prefix function out of it, but you can also section it by peeling off one or the other of its arguments
09:38:55 <erus`> how does it know what is the operator and what it the arguement ...
09:39:11 <monochrom> alphanumeric vs punctuations
09:39:24 <ziman> is the lenses talk available to watch somewhere online? :)
09:39:33 <edwardk> erus: the latter can;t work because juxtaposition binds tighter than any operator
09:40:01 <edwardk> (#), (2 #), (# 3), (2 # 3) all work. the # has to be made up of symbol characters or be a normal identifier in backticks (`foo`) = foo,    ([1,2,3,4] `zip` [5,6,7,8]), etc.
09:40:09 <edwardk> ziman: yeah
09:40:29 <erus`> ah ok
09:40:34 <edwardk> http://www.youtube.com/watch?v=efv0SQNde5Q&list=PLEDE5BE0C69AF6CCE
09:40:58 <ziman> edwardk, thanks
09:44:14 <cheater_> hey guys
09:44:22 <cheater_> what's the best way to write an interactive application with haskell
09:44:42 <cheater_> in linux
09:44:47 <cheater_> either windowing or console
09:44:51 <edwardk> with a text editor, of course ;)
09:46:37 <monochrom> gtk2hs for windowing, one of the ncurses bindings or vty for console
09:48:15 <cheater_> monochrom: ok, say i wanted to do gtk2hs. i want to write an app which takes digits as input and as soon as i press a digit key it multiplies and then divides a value by it.
09:48:20 <cheater_> starting by 1.
09:48:26 <cheater_> and displays it.
09:48:27 <cheater_> what do?
09:48:45 <cheater_> say input is 2 3 4 5 then i get 1*2/3*4/5
09:49:26 <cheater_> monochrom, would you be able to sorta walk me through it?
09:49:39 <monochrom> I haven't done that
09:49:57 <monochrom> I am unable to walk through
09:51:19 <cheater_> tbh i want something with vi-style input
09:52:06 <cheater_> monochrom, why would you do gtk2hs? and not something else?
09:52:26 <monochrom> because it's the easiest to install
09:52:27 <cheater_> monochrom: for example i don't want to bother with things like, say, double buffering.. i want stuff to "just work"
09:52:28 <cheater_> ok
09:52:33 <cheater_> well that's not a bad reason
09:52:42 <monochrom> also most recent
09:52:58 <cheater_> what about phooey and wxhaskell? have you tried those?
09:53:42 <cheater_> Since Reactive is currently broken (as of February 2010), Phooey is also broken.
09:53:47 <cheater_> ok, scratch that
09:53:50 <edwardk> cheater_: in general gtk2hs just works, the others have, well all of the associated issues that come with frp
09:54:01 <monochrom> I haven't tried wxhaskell because I have heard enough about failure to install it. also I'm already in ubuntu gnome, I don't want more underlying lib than I have
09:54:23 <edwardk> never tried wxhaskell
09:54:25 <cheater_> The wrapping is, unfortunately, generated by hand, so there is some (mainly tedious boilerplate) work involved in porting a new set of widgets to wxHaskell. Some work has been done into automating this aspect, but we are far from being able to replicate the approach reliably over then entire API as yet.
09:54:25 <cheater_> From the perspective of the user (rather than the developer) about 90% of the core wxWidgets functionality is already supported, excluding more "exotic" widgets like dockable windows. The library supports Windows, GTK (Linux) and MacOS X.
09:54:29 <cheater_> ok, scratch wxhaskell
09:54:45 <cheater_> let's try gtk2hs then!
09:55:30 <monochrom> gtk2hs has its problems but the least problem compared to other routes
09:55:33 <akosch> how would I choose a random element from a list?
09:56:12 <monochrom> install gtk2hs-buildtools first, then gtk. actually, install the necessary c libs first
09:56:53 <monochrom> the biggest problem with gtk2hs is its website has vanished, so now the instruction of "install gtk2hs-buildtools first" is word-of-mouth
10:01:13 <cheater_> monochrom: i was just gonna ask
10:01:46 * hackagebot HaskellForMaths 0.3.3 - Combinatorics, group theory, commutative algebra, non-commutative algebra  http://hackage.haskell.org/package/HaskellForMaths-0.3.3 (DavidAmos)
10:07:00 <orifichu> there is some snap version which works with ghc 6.12?
10:08:26 <cheater_> try asking in #snapframework
10:08:35 <cheater_> i'm telling you guys, ubuntu is sabotaging haskell
10:08:36 <cheater_> The following packages have unmet dependencies:
10:08:36 <cheater_>   haskell-platform: Depends: ghc6 (< 6.12.1+) but 6.12.3-1ubuntu7 is to be installed.
10:08:52 <cheater_> wtf do i do with this??
10:09:00 <cheater_> this OS is ridiculous
10:09:16 <identity> cheater_: not sure what is up
10:09:23 <identity> but I didn't try installing it from the repo since it's so old in there
10:09:35 <identity> however, it's easy as pie to install the ghc 7.0.3 binary
10:09:43 <identity> cheater_: and then the haskell platform
10:10:10 <cheater_> identity, will that mean i need to build something?
10:10:13 <identity> cheater_: yep
10:10:14 <cheater_> because my pc isn't a supercomputer
10:10:22 <cheater_> how long would a build on a core 2 duo be
10:10:25 <cheater_> days?
10:10:25 <identity> lol
10:10:26 <identity> no
10:10:27 <cheater_> weeks?
10:10:28 <identity> it takes minutes
10:10:29 <cheater_> hours?
10:10:30 <identity> at most
10:10:32 <cheater_> ok
10:10:34 <identity> I did it on a shell
10:10:34 <cheater_> let's give it a go
10:10:37 <identity> with very limited resources
10:10:40 <identity> cheater_: 64 bit?
10:10:44 <cheater_> 32
10:10:52 <identity> download this
10:11:03 <identity> http://haskell.org/ghc/dist/7.0.3/ghc-7.0.3-i386-unknown-linux.tar.bz2
10:11:14 <cheater_> what is the web page that recommends this download?
10:11:23 <cheater_> haskell.org/platform ?
10:11:29 <ClaudiusMaximus> installing binary takes minutes, recompiling ghc takes an hour or so on a core2duo (just don't use make -j thinking it's like +RTS -N ...)
10:11:32 <identity> yep
10:11:41 <identity> ClaudiusMaximus: recompiling?
10:11:43 <ClaudiusMaximus> isn't there 7.0.4 ?
10:11:45 <identity> oh
10:11:46 <identity> nvm
10:11:49 <identity> ClaudiusMaximus: not sure
10:11:49 <Cale> cheater_: Don't compile the compiler, just get the GHC generic linux binary
10:12:11 <Cale> and install that (to /usr/local which is default)
10:12:23 <Cale> and then grab cabal-install and run the bootstrap.sh
10:12:28 <Cale> and then you're all set :)
10:12:37 <identity> cheater_: http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
10:12:45 <identity> a guide on how to install it
10:12:58 <roconnor> edwardk: Here is paper that might intrest you: http://portal.acm.org/citation.cfm?id=1705636
10:13:05 <roconnor> edwardk: I can't really understand it myself
10:13:09 <cheater_> great! you guys are so cool
10:13:12 <cheater_> let me try it
10:13:17 <cheater_> but first i need to go to the bathroom.
10:14:11 <identity> basically you just need to wget binaryURL && untar binarytar && cd binarydir && ./configure && sudo make install && cd .. && wget platformURL && untar platformtar && cd platformdir && ./configure && make && make install
10:14:16 <identity> eh, sudo make install the last one
10:14:23 <identity> but the guide tells you all of those
10:14:31 <identity> and you'll need the libraries mentioned at the beginning
10:14:38 <edwardk> roconnor: pulling it up
10:16:39 <parcs> identity: reminds me of this: http://bash.org/?464385
10:18:17 <identity> parcs: hhehe
10:18:49 <edwardk> roconnor: i can't seem to obtain a copy
10:19:24 <roconnor> one sec
10:19:26 <monochrom> gtk2hs 0.12 works fine with ghc 6.12.3, actually
10:19:50 <edwardk> roconnor: heh, i found a nice use for a variation on Cont to represent linear functionals. i wonder if there is a similar use for Store ;)
10:20:10 <cheater_> ok trying to install
10:20:22 <cheater_> btw
10:20:27 <cheater_> will gtk2hs work with ghc7?
10:20:41 <parcs> yep
10:20:41 <monochrom> also yes
10:20:58 <cheater_> ok cool
10:21:00 <cheater_> let's go
10:21:49 <monochrom> my only gripe with ubuntu is ubuntu 10.10 dared to adopt ghc 6.12.1 when it had ample time to go for 6.12.3
10:22:20 <monochrom> and this is not an upgrade whore's gripe. 6.12.1 has a fatal bug regarding --user vs --global
10:23:23 <monochrom> also this is not a gripe on ubuntu 10.04 going for ghc 6.12.1. that one couldn't be helped
10:44:12 <gdoteof> I am trying to understand maximumBy and comparison functions:  maxcollatzlength n = fst (maximumBy (compare `on` snd) (take n collatztuples))
10:44:34 <gdoteof> ^^ this seems to say take the first in a list, ordered by the second item in a list of tuples
10:45:02 <gdoteof> but i don't quite get what is going on with the (compare `on` snd)
10:46:12 <ski> @src on
10:46:12 <lambdabot> (*) `on` f = \x y -> f x * f y
10:46:33 <ski>   compare `on` snd = \x y -> compare (snd x) (snd y)
10:47:00 <ski>                    = \ ~(_,x) ~(_,y) -> compare x y
10:47:23 <gdoteof> what is the ' \ ' ?
10:47:40 <ski> "lambda", starting a function value
10:47:49 <ski> > (\x -> x^2) 5
10:47:50 <lambdabot>   25
10:47:54 <hpc> gdoteof: say you have a function "f x = y"
10:47:55 <gdoteof> ah
10:47:56 <ski> > map (\x -> x^2) [0,1,2,3,4,5]
10:47:57 <lambdabot>   [0,1,4,9,16,25]
10:47:57 <akosch> how do I get a random integer between two boundaries?
10:48:04 <hpc> gdoteof: a similar definition of f would be "f = \x -> y"
10:48:06 <ski> > let f \x -> x^2 = in map f [0,1,2,3,4,5]
10:48:06 <lambdabot>   <no location info>: parse error on input `\'
10:48:09 <ski> > let f = \x -> x^2 = in map f [0,1,2,3,4,5]
10:48:09 <lambdabot>   <no location info>: parse error on input `='
10:48:14 <ski> argh
10:48:17 <ski> > let f = \x -> x^2 in map f [0,1,2,3,4,5]
10:48:17 <lambdabot>   [0,1,4,9,16,25]
10:48:22 <ski> > let f x = x^2 in map f [0,1,2,3,4,5]
10:48:23 <lambdabot>   [0,1,4,9,16,25]
10:48:58 <nicoo> akosch: randBound x y = rand (y-x) + x
10:49:11 <nicoo> (in pseudo-code ^^)
10:49:17 <ski> gdoteof : so `\x y -> compare (snd x) (snd y)' is the function that given any inputs (pairs) `x' and `y' will `compare' the second parts of them
10:49:31 <gdoteof> ohh
10:49:42 <gdoteof> ok
10:49:47 <ski> so it's a custom comparision function
10:49:54 <ski> btw, instead of saying
10:49:54 <akosch> nicoo: thanks, I thought there was a function for that
10:50:07 <ski>   maxcollatzlength n = fst (maximumBy (compare `on` snd) (take n collatztuples))
10:50:10 <nicoo> akosch: if there is one, I don't know it
10:50:17 <ski>   maxcollatzlength n = fst (maximumBy (comparing snd) (take n collatztuples))
10:51:05 <ski> (also, i'd rename to `maxCollatzLength' and `collatzPairs')
10:55:46 <gdoteof> so if i wanted to compare the third item it would be    compare `on` \x y -> compare [x !! 2] [y !! 2]
10:56:09 <mm_freak> is there a package list for the current haskell platform?
10:57:37 <alpounet> mm_freak, http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/index.html on the right column?
10:57:42 <ski> gdoteof : well, rather replacing `[',`]' by `(',`)'
10:57:56 <ski> gdoteof : and of course, that will compare lists
10:58:32 <gdoteof> oh right.    compare `on`\x y -> compare (x !! 2) (y !! 2)
10:58:38 <gdoteof> sexy.  okay thanks a lot
10:59:07 <ski> the version with `[',`]' will actually work as well, but will needlessy create singleton lists
10:59:19 <cheater_> ok HP is installing
10:59:22 <cheater_> let's see what happens
10:59:34 <ski> gdoteof : anyway, it can be written shorter as `comparing (!! 2)'
11:00:04 <ski> hum
11:00:33 <ski> gdoteof : actually, the inital part  compare `on`  there is nonsense
11:01:03 <ski> @type compare `on` \x y -> compare (x !! 2) (y !! 2)
11:01:03 <lambdabot> forall a. (Ord a) => [a] -> [a] -> Ordering
11:01:55 * ski ponders what that actually will do
11:06:08 <hpaste> orifichu pasted “snap install error” at http://hpaste.org/48879
11:09:38 * ski is confused by this ..
11:10:15 <ski> > comparing compare () ()  -- why does this even type-check ?
11:10:15 <lambdabot>   *Exception: (==): No overloading for function
11:10:30 <hpc> :t comparing compare () ()
11:10:31 <lambdabot> Ordering
11:10:33 <hpc> oh god
11:10:44 <Saizan> ?type comparing
11:10:45 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
11:10:50 <EEVIAC> > compare () `compare` compare ()
11:10:51 <lambdabot>   *Exception: (==): No overloading for function
11:10:57 <EEVIAC> wtf
11:11:21 <Saizan> i guess there's an Ord instance for functions
11:11:29 <Saizan> which is needed for the Num instance
11:11:38 <hpc> :t comparing compare
11:11:38 <lambdabot> forall b. (Ord b) => b -> b -> Ordering
11:11:47 <ski> @src Num
11:11:47 <lambdabot> class  (Eq a, Show a) => Num a  where
11:11:47 <lambdabot>     (+), (-), (*)           :: a -> a -> a
11:11:47 <lambdabot>     negate, abs, signum     :: a -> a
11:11:47 <lambdabot>     fromInteger             :: Integer -> a
11:12:03 <ski> @src Real
11:12:04 <lambdabot> class  (Num a, Ord a) => Real a  where
11:12:04 <lambdabot>     toRational      ::  a -> Rational
11:14:31 <ski> ah
11:14:41 <ski> @type \a b -> compare (\y -> compare a y) (\y -> compare b y)
11:14:42 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
11:14:45 <ski> @type \f g -> compare (\y -> f y :: Ordering) (\y -> g y :: Ordering)
11:14:46 <lambdabot> forall t. (Ord (t -> Ordering)) => (t -> Ordering) -> (t -> Ordering) -> Ordering
11:15:09 <ski> i wondered why i got `Ord (t -> Ordering)' constraints in the latter, but not in the former
11:15:12 <ski> but
11:15:19 <ski> @type \f g -> compare (\y -> f (max y y) :: Ordering) (\y -> g (max y y) :: Ordering)
11:15:19 <lambdabot> forall a. (Ord a) => (a -> Ordering) -> (a -> Ordering) -> Ordering
11:16:33 <ski> so i suspect there's an `instance (Ord a,Ord b) => Ord (a -> b)', or something like that ..
11:17:04 <nicoo> Saizan: it's doubtful that there is a comparison function (as a total order) over functions in Haskell, since functionnal equility is equivalent to the Halting problem
11:17:21 <ski> @type \f g -> compare (\y -> f (join max y)) (\y -> g (join max y))
11:17:22 <lambdabot> forall t a. (Ord a, Ord (a -> t)) => (a -> t) -> (a -> t) -> Ordering
11:17:25 <FUZxxl> Hello!
11:17:36 <ski> @type \f g -> compare (\y -> max `join` f (join max y)) (\y -> max `join` g (join max y))
11:17:36 <lambdabot> forall a a1. (Ord a, Ord a1) => (a1 -> a) -> (a1 -> a) -> Ordering
11:17:38 <FUZxxl> Where can I find good documentation about type families?
11:17:41 <ski> *nod*
11:17:59 <Saizan> FUZxxl: the ghc manual or the haskell wiki
11:18:20 <ski> nicoo : yeah, it's just to allow `instance Num a => Num (rho -> a)' and `instance Real a => Real (rho -> a)', i think
11:18:54 <nicoo> ski: if I understand your example correctly, it creates another order on points, using two functions over you starting set
11:19:08 <nicoo> ski: ah, ok
11:19:18 <ski> nicoo : hm .. which example ?
11:19:36 <mm_freak> alpounet: that's useful, if you're looking for a specific package
11:20:03 <ski> nicoo : the above things were just dummy tests to try to figure out where the constraint came from -- ignore what they actually do
11:21:40 <ski> gdoteof : in any case,  compare `on` \x y -> compare (x !! 2) (y !! 2)  is not what you want
11:22:30 <ski> gdoteof : you want  compare `on` \x -> x !! 2  or  comparing (\x -> x !! 2)  or  comapre `on` (!! 2)  or  comparing (!! 2)
11:23:16 <gdoteof>  ski  i see
11:23:44 <ski> (s/comapre/compare/)
11:23:59 * hackagebot tremulous-query 1.0.1 - Library for polling Tremulous servers  http://hackage.haskell.org/package/tremulous-query-1.0.1 (ChristofferOjeling)
11:24:01 * hackagebot apelsin 1.0 - Server and community browser for the game Tremulous  http://hackage.haskell.org/package/apelsin-1.0 (ChristofferOjeling)
11:27:12 <SirFrancisDrake> > try (read <$> getLine) :: IO (Either SomeException Int)
11:27:13 <lambdabot>   Not in scope: type constructor or class `SomeException'Not in scope: `try'
11:27:50 <SirFrancisDrake> > Control.Exception.try (read <$> getLine) :: IO (Either Control.Exception.SomeException Int)
11:27:50 <lambdabot>   Not in scope:
11:27:50 <lambdabot>    type constructor or class `Control.Exception.SomeException...
11:28:09 <hpc> you can't run IO-y stuff in λbot
11:28:11 <ski> @type Control.Exception.try (read <$> getLine) :: IO (Either Control.Exception.SomeException Int)
11:28:11 <lambdabot> IO (Either GHC.Exception.SomeException Int)
11:28:40 <ezyang> Any people with write access to http://hackage.haskell.org/platform//linux.html here?
11:28:40 <lambdabot> ezyang: You have 1 new message. '/msg lambdabot @messages' to read it.
11:28:48 <ezyang> the HP 2011.2.0.0 link is broken.
11:30:15 <SirFrancisDrake> passing an invalid string (like "a") to this action results in "Right *** Exception (etc.)". That's weird
11:30:21 <hpaste> orifichu pasted “haskell platform install error” at http://hpaste.org/48881
11:32:00 * hackagebot entropy 0.2.1 - A platform independent entropy source  http://hackage.haskell.org/package/entropy-0.2.1 (ThomasDuBuisson)
11:33:21 <ion> Isn’t that a platform-dependent entropy source?
11:38:35 <hpc> ion: if you can find a non-windows OS that can run GHC but doesn't have /dev/urandom, i suppose
11:39:21 <Nimatek> People still use Windows?
11:40:47 <Rotaerk> Nimatek, you mean there are people who still DONT use windows?
11:41:53 <Nimatek> Rotaerk: Well, I know some that use it for gaming, but otherwise..
11:43:59 <Stephan_> trying out the haskell chat
11:44:11 <Rotaerk> there are some things about Windows that annoy me (such as the fact that it's even possible for a window to steal focus)
11:44:43 <Stephan_> whoami
11:44:55 <Rotaerk> but the majority of top-quality applications seem to target windows, and it's the OS to use for PC gaming
11:45:46 <Stephan_> back
11:46:43 <Stephan_> pretty neat
11:49:16 <hpaste> orifichu pasted “haskell platform install error” at http://hpaste.org/48882
11:49:37 <Stephan_> does haskell have a special keyboard setting
11:50:08 <Rotaerk> a what?
11:50:15 <ion> Yeah, like APL
11:50:54 <ion> You need the → key and ∷ key etc.
11:54:25 <orifichu> how can i resolve a "accepted by the compiler, rejected by the preprocessor!" erro?
11:55:08 <ski> Stephan_ : i haven't heard of a special keyboard setting for Haskell
11:55:14 <ski> Saizan : @join #constructive-math
11:55:41 <Cale> orifichu: wat
11:55:58 <Cale> orifichu: Can you hpaste more details about it?
11:56:17 <orifichu> Cale: http://hpaste.org/48882
11:56:30 <Clint> read config.log
11:58:10 <Cale> orifichu: ummmm... do you have your heart set on installing HP, or is the goal to just get a Haskell implementation installed? You might just try installing the GHC generic linux binary package, and then cabal-install, as from there, you can get all the rest of the libraries easily as you need them.
11:58:26 <Cale> Also, 6.12.3 is kinda old
11:59:03 <Cale> (given that 7.0.4 is out)
11:59:34 <orifichu> Cale: im trying install all these things in a shared server (a bluehost hosting)
11:59:54 <laar> Cale, he probably has some 'slower' releasing OS version, (Ubuntu 10.10 is stuck at 6.12.1)
12:00:02 <orifichu> Cale: i tried with 7.0.4 but with problems....all ok with 6.12
12:00:16 <Cale> orifichu: huh...
12:00:37 <Cale> laar: Well, he's trying to install Haskell Platform with 6.12.3
12:00:57 <Cale> (and it comes with whatever version it comes with)
12:03:29 <orifichu> Cale: the installation requires the glut c library...so i have installed freeglut library and then i did: "./configure --prefix=$HOME/hp --with-ghc=$HOME/ghc/bin/ghc   --with-ghc-pkg=$HOME/ghc/bin/ghc-pkg --with-hsc2hs=$HOME/ghc/bin/hsc2hs CFLAGS=-I$HOME/freeglut/include" and get the log error that i showed
12:04:05 <Clint> did you read config.log?
12:04:29 <orifichu> Cale: some of help?
12:09:00 <orifichu> Cale: nothing?
12:09:03 * hackagebot GenericPretty 0.1.0 - A generic, derivable, haskell pretty printer.  http://hackage.haskell.org/package/GenericPretty-0.1.0 (RazvanRanca)
12:15:20 <cheater_> ok, woop@ got haskell platform installed.
12:15:29 <cheater_> now how do i get gtk2hs ? bit confused :X
12:15:37 <ion> cabal install
12:16:49 <cheater_> ah yes
12:16:55 <cheater_> cabal install gtk2hs-buildtools
12:45:59 <cheater_> hi
12:46:06 <cheater_> i'm trying to install gtk2hs but it's not working
12:46:22 <cheater_> i've installed the build tools and they're in my path but now doing cabal install gtk i get the following errors:
12:46:24 <cheater_> setup: The pkg-config package cairo-pdf is required but it could not be found.
12:46:33 <cheater_> setup: The pkg-config package glib-2.0 is required but it could not be found.
12:46:41 <cheater_> what do i do here?
12:47:51 <geheimdienst> cheater_: do you have the dev variants of glib-2.0 and cairo-pdf installed? i guess your system package manager (not cabal) has to do that
12:48:43 <cheater_> mp
12:48:46 <cheater_> no
12:48:49 <cheater_> let me do that
12:50:20 <cheater_> i don't think there's a cairo pdf dev pkg?
12:52:04 <geheimdienst> the instructions say you need these 4 libraries http://www.haskell.org/haskellwiki/Gtk2Hs#Ubuntu i guess the cairo-pdf stuff that the installer misses is part of cairo2-dev
12:52:12 <cheater_> ah yes ok
12:53:03 <cheater_> perfect, thanks
12:53:17 <geheimdienst> you're welcome
13:04:25 <hpaste> mee pasted “'cabal install snap' failure on debian sid” at http://hpaste.org/48883
13:05:06 <mee> the "impossible" is happening, but somehow I doubt this is actually a compiler bug
13:05:18 <c_wraith> actually, it might be
13:05:24 <melle> wow
13:05:25 <c_wraith> I think one of the fixes in 7.0.4 was related to that.
13:05:38 <mee> oh, I'll look on trac
13:16:30 <mee> ah, here we go: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=622731  --  thanks for the pointer
13:17:32 <sshc> Are there any implementations of Haskell that support Haskell2010 besides GHC 7?
13:35:09 <nicoo> sshc: what's wrong with ghc ?
13:40:16 <dAnjou> hi, i'm very new to haskell and for some homework i have to work on text in a file with some \n in it. i don't want to do the file handling yet. so i need a variable that holds the text like if it was in the file. how can i assign text with \n in it to a variable?
13:40:31 <dAnjou> please don't tell me how easy it is to read files ;)
13:41:14 <fasta> dAnjou: I don't think you quite understand the meaning of home _work_.
13:41:39 <monochrom> not sure you mean what you say, but you can openBinary to obtain file content verbatim
13:41:43 <cmccann> dAnjou, you want a way to put the file contents into your program as a string literal?
13:41:51 <dAnjou> weeell, assigning text to a variable is not the homework
13:41:57 <fasta> To me it is obvious what he wants.
13:42:00 <Twey> dAnjou: You can just write it with \n's in it.
13:42:29 <Twey> Or make a list and ‘unlines’ it, if that's syntactically nicer (means you can put each line on a separate line, as a separate element)
13:42:31 <dAnjou> Twey: -.- that obviously makes sense, thanks
13:42:35 <geheimdienst> > "lol\ncat"
13:42:36 <lambdabot>   "lol\ncat"
13:42:39 <fasta> dAnjou: I assume your teacher told you how to read a file.
13:42:46 <monochrom> oops, it's called openBinaryFile
13:42:49 * cmccann is assuming the question to be "how can I put the file contents directly into the code so that I can write the main algorithm without implementing file input first"
13:42:56 <fasta> dAnjou: if you don't actually need to read a file, don't.
13:43:09 <Nimatek> > unlines ["line1","line2"]
13:43:10 <lambdabot>   "line1\nline2\n"
13:43:17 <cmccann> implying that file input is a trivial detail of the assignment, which sounds reasonable
13:43:30 <geheimdienst> > lines "lol\ncat\nmeow"
13:43:30 <lambdabot>   ["lol","cat","meow"]
13:43:43 <Twey> Yeah, you get an extra \n.  You can do ‘intercalate "\n"’ instead if that's a problem.
13:43:51 <dAnjou> fasta: he did, but i wasn't listening BUT i didn't asked that here ;)
13:43:53 <monochrom> if it's homework, I suggest posting the homework question verbatim. none of this "rephrase in my own words to show how much I understand none of it" business
13:44:15 <Twey> > intercalate "\n" &&& unlines $ lines "foo\nbar\nbaz"
13:44:15 <lambdabot>   ("foo\nbar\nbaz","foo\nbar\nbaz\n")
13:44:16 <fasta> dAnjou: so, don't you have like slides?
13:44:25 <fasta> dAnjou: or just google: read file haskell
13:44:25 <melle> monochrom: and fix the exercise for him? :)
13:44:42 <monochrom> I hope the original question doesn't need fixing
13:44:52 <melle> s/fixing/answering
13:45:06 <dAnjou> fasta: like i said, i don't want to do it yet ;)
13:45:08 <monochrom> then again statistically haskell homework questions are of low quality
13:45:26 <cmccann> monochrom, though I've actually seen a depressing number of cases where the assignment itself seemed to be badly ill-conceived
13:45:42 <fasta> monochrom: hmm, the questions I got were well-defined.
13:45:43 <monochrom> yes absolutely, I've seen it too
13:46:16 <Nimatek> Badly defined programming assignments are a great basis for exploration.
13:46:23 <dAnjou> shit, i'm lagging so hard
13:46:34 <fasta> Nimatek: they are great on exams.
13:46:46 <fasta> You got it all wrong! Next question.
13:47:14 <fasta> Or just taking the assumptions from the question and deriving a contradiction.
13:47:19 <dAnjou> maybe i also wanted to know how to write multi line strings in the code but i already figured it out
13:47:41 <Nimatek> fasta: They are even better on exams, because you can interpret it the way you like and then argue that the question allows for that interpretation.
13:48:29 <cmccann> monochrom, there were at least a couple occasions where homework questions ended up on Stack Overflow and I really, really wanted to ask for a copy of the assignment so that I could mark it up, give it a failing grade, and tell them to send it to the instructor with my regards
13:48:53 <cmccann> but that would probably not have been constructive, or helpful to the poor student
13:49:15 <melle> cmccann: only after that specific course has finished :)
13:49:42 <monochrom> I don't know. if you know how to talk to the instructor's superior, impeaching the incompetent instructor is a great service to the sufferring students
13:50:30 <iratsu> hmm so I have 2 functions  g :: a -> StateT b IO ()  and  f :: (a -> IO ()) -> IO ()  . f takes a function as argument and applies it to multiple arguments. Is there a way I can modify this function to apply it to g to maybe yield a  StateT b IO ()?
13:51:01 <monochrom> I know the value of open-ended questions, but there are well-designed open-ended questions and there are fiasco open-ended questions
13:51:08 <Twey> iratsu: No it doesn't
13:51:35 <Twey> f takes a function as its argument and… does something with it in IO
13:51:48 <cmccann> monochrom, my favorite open-ended questions are the ones that reduce to well-known open problems :D
13:51:54 <Twey> There are no other arguments…
13:52:01 <iratsu> Twey: yea sorry that was badly phrased
13:52:51 <Twey> I *think* what you want to do is modify f so that f :: MonadIO m -> (a -> m ()) -> m ()
13:52:56 <Twey> Errr
13:53:01 <Twey> f :: MonadIO m => (a -> m ()) -> m ()
13:53:32 <Twey> Which can basically be done by changing the type and scattering ‘liftIO’ all over the place ☺
13:53:43 <Twey> (or just applying it to the whole thing, I guess)
13:53:54 <Twey> Then m can be StateT b IO
13:54:18 <Twey> And you can pass ‘f g’
13:54:24 * ddarius will ask "Enumerate the cardinalities between N and 2^N" and see what comes out of it.
13:54:25 <lambdabot> ddarius: You have 1 new message. '/msg lambdabot @messages' to read it.
13:55:06 <roconnor> w_0, w_1, w_2, w_3 ...
13:58:04 <iratsu> Twey: hmm well my issue is not really with the IO but rather with the State monad. Let's say that  g :: a -> State b  and  f :: (a -> ()) -> ()  instead... how would you change f's type to fit g's?
13:58:57 <Twey> That's a silly question
13:59:00 <iratsu> Twey: sorry g :: a -> State b ()
13:59:09 <Twey> Ah
13:59:42 <Twey> Still a silly question, because you have const () :: State b () -> ()
13:59:58 <Twey> () holds no information, unlike IO (), so it's not really analogous
14:00:08 <Twey> But I think perhaps you're looking for:
14:00:15 <iratsu> hmm true
14:00:17 <Twey> :t evalState
14:00:18 <lambdabot> forall s a. State s a -> s -> a
14:05:15 * hackagebot numeric-prelude 0.2.2 - An experimental alternative hierarchy of numeric type classes  http://hackage.haskell.org/package/numeric-prelude-0.2.2 (HenningThielemann)
14:05:18 <iratsu> Twey: well f applies "g" to multiple values in its body and i'd like to "maintain the state" across invocations if you see what I mean
14:05:45 <iratsu> Twey: so I'd like something that "lifts" f to State rather than the other way around
14:08:12 <Twey> Ah, I see what you mean
14:08:40 <iratsu> yea, sorry, wasn't sure how to express the idea clearly =\
14:09:02 <Twey> That's what the State monad is *for*: f h = evalState $ do h 1; h 2; h 3
14:09:11 <Twey> Er, plus a state
14:09:17 <Twey> Obviously :þ
14:10:40 <iratsu> Twey: oh but f is a library function so I was hoping to not have to define it
14:11:59 <romildo> Hi.
14:12:00 <Twey> iratsu: If it doesn't thread the state through already, you can't make it do so but by redefining it
14:12:08 <Twey> Hello
14:13:14 <romildo> I want to compile nanocurses on my system, but it fails with the message: cbits/utils.h:7:20: fatal error: config.h: No such file or directory
14:13:14 <iratsu> Twey: ah ok I was hoping that that would sort of be the functorial thing to do
14:13:35 <ion> the functorial thing to do?
14:13:37 <romildo> Maybe someone has a clue on how to fix this problem with nanocurses.
14:13:42 <Twey> iratsu: It's drastically changing the behaviour of the function, since it has to take each return value and do something new with it
14:14:51 <romildo> There is cbits/config.h.in, but no config.h
14:14:58 <Saizan> you can embed State into IO though, by an IORef and some wrapping code
14:15:06 <Twey> gwern might be able to help…
14:16:24 <Saizan> iratsu: http://www.haskell.org/pipermail/haskell-cafe/2007-July/028501.html
14:16:26 <iratsu> Saizan: yea that's what I was going to try next
14:16:42 <iratsu> thanks
14:18:10 <cheater_> i find that the haskell platform source package is broken
14:18:20 <cheater_> if i do make clean and then try to make it breaks
14:19:06 <cheater_> mind you, i did the following: 1. boot up ubuntu 11.04 livecd 2. do make && make install 3. reboot 4. make clean 5. ./configure 6. make
14:19:15 <cheater_> it broke saying it can't find "happy"
14:19:31 <cheater_> on the other hand if i unpack the tarball anew it works
14:19:38 <cheater_> so it's just junk that make clean didn't get rid of
14:19:55 <Saizan> no, it's that make clean got rid of too much stuff
14:20:48 <cheater_> might be
14:21:16 <_Ray_> Hi :) How should I interpret "(String -> String) -> IO ()"? I know it is taking a function f: String -> String, and returning an IO (), but IO is a Monad, hence a type constructor, so what is IO ()? In general, for a functor F, what is F ()?
14:21:16 * cheater_ leaves the bug in Saizan's competent hands. :)
14:22:23 <shachaf> _Ray_: What do you mean by "what is"?
14:22:41 <ben> _Ray_: () is the type whose only values are () or undefined, so the idea for IO () is that it is a computation that returns nothing interesting.
14:22:44 <Saizan> i don't have much to do with the platform, though
14:22:55 <_Ray_> Well, I know the syntax F X for a functor F is the type which F takes X to.
14:23:02 <_Ray_> Oh, OK.
14:23:18 <ben> @type interact
14:23:19 <lambdabot> (String -> String) -> IO ()
14:23:26 <_Ray_> Yeah, that's where I found it :)
14:23:49 <_Ray_> So interact must end with a "return;" or something, ne?
14:23:56 <ben> return ()
14:23:57 <shachaf> @src interact
14:23:57 <lambdabot> interact f = do s <- getContents; putStr (f s)
14:24:07 <ben> @type putStr
14:24:08 <lambdabot> String -> IO ()
14:24:57 <_Ray_> Thanks :)
14:25:05 <shachaf> _Ray_: In general, you can think of "F T" as a computation that's interesting both for its effects and its value. When T is (), it's interesting only for its effects.
14:28:45 <cmccann> _Ray_, consider the list monad. The equivalent there would be something of type [()], which provides no useful information other than its length
14:29:08 <cmccann> considering the list monad as representing non-determinism, that makes [()] a measure of how many options a computation considered
14:29:17 <ddarius> roconnor: Denotational semantics are usually given in, essentially, the untyped lambda calculus.  Also, it's not difficult to make a ST if you have some constraints on the value type, e.g. Typeable, but there doesn't seem to be a way to do it with no constraints without unsafeCoerce.
14:29:18 <_Ray_> right. that is pretty :)
14:29:42 <cmccann> (not that this is very useful, but using something more sensible than IO helps to illuminate matters)
14:31:00 <roconnor> ddarius: If we can't do it with typed programming then I'll throw away my type system!
14:31:43 <Melvar> I just wrote “filter ((&&) <$> pred1 <*> pred2)”. Do I get slapped for that?
14:31:53 <ddarius> Melvar: No.
14:32:06 <cmccann> Melvar, no, it's perfectly sensible
14:32:11 <roconnor> ST has such a nice interface.  If we can't build ST in Haskell because of the type system, then our type system is a failure.
14:32:15 <Twey> Looks nice to me.
14:32:31 <ddarius> roconnor: Well the unsafeCoerce is likely related to why SML has the value restriction.
14:33:00 <roconnor> what was the value restriction again?
14:33:20 <parcs> Melvar: you _might_ want to use liftA2
14:33:36 <ddarius> roconnor: Basically, a requirement for monomorphic variables in reference types for exactly the same reason that you can implement unsafeCoerce with unsafePerformIO and an IORef.
14:33:54 * cmccann finds the infix combinators more readable than liftA2 if you're fully applying the function right away
14:33:55 <ddarius> filter (liftA2 (&&) pred1 pred2)
14:34:23 * Twey prefers the <$> and <*>
14:34:38 <roconnor> ddarius: that behaviour is specific to GHC
14:34:41 <Twey> Anything suffixed with a number of arguments will always feel like a hack to me :þ
14:34:49 <cmccann> whereas "liftA2 foo" is definitely better than "\x y -> foo <$> x <*> y"
14:35:05 <ddarius> roconnor: No it isn't.
14:35:26 <roconnor> IIRC in JHC (or YHC) polymorphic values are functions and you don't get unsafeCoerce when you write that code.
14:36:14 <Twey> cmccann: ‘(<*>) . (<$>) foo’ isn't too bad
14:36:42 <Melvar> I’m just going to go with cmccann and Twey on liftA2 in this case.
14:36:59 <cmccann> Twey, eh, it's tolerable, but I still prefer liftA2 in that situation
14:39:29 <_Ray_> Hrm. I had a polynomial function f which had a numerical fixed point. I tried saying fix f = f(fix f) and using fix to find its fixed point, but it returned undefined. The answer here was that it was a fixed point, but "with respect to a different order". Does this have to do with the concept of a _least_ fixed point?
14:40:23 <_Ray_> Where, for instance, undef <= x forall x.
14:40:24 <cheater_> okay
14:40:24 <cheater_> i've got gtk2hs running and compiling things!
14:40:24 <cheater_> now, how do i make it display a bitmap which i generate myself?
14:40:59 <dAnjou> is there a smarter way of doing this? "q" == filter (=='q') "qwerty"
14:41:35 <parcs> (==1) . length
14:41:54 <cmccann> :t any (== 'q')
14:41:55 <lambdabot> [Char] -> Bool
14:41:56 <geheimdienst> dAnjou: you want to extract the first character of a string?
14:42:02 <cmccann> > any (== 'q') "qwerty"
14:42:03 <lambdabot>   True
14:42:05 <cmccann> > any (== 'q') "asdf"
14:42:06 <lambdabot>   False
14:42:25 <dAnjou> ok, that wasn't clear. i want to check the presence of a char
14:42:38 <cmccann> dAnjou, or are you deliberately looking for only a single match, not just any number of matches?
14:42:39 <ion> > 'q' `elem` "qwerty"
14:42:40 <lambdabot>   True
14:43:04 <dAnjou> DAMN
14:43:26 <dAnjou> i tried 'q' elem "qwrty" and got an error
14:43:27 <monadic> Are there any resources on using Data.Vector.*.Mutable with the ST monad? I can't for the life of me figure out how to use it with runST; I'm just trying to create a vector at the moment as a test.
14:43:33 <dAnjou> which i didn't unterstand
14:43:44 <c_wraith> dAnjou: the ``s are important
14:43:45 <cmccann> dAnjou, yeah, you need backticks to use an alphanumeric identifier infix
14:43:59 <dAnjou> c_wraith: yeah. learned that but forgot it
14:44:01 <geheimdienst> > elem 'a' "lolcat"
14:44:02 <lambdabot>   True
14:44:02 <cmccann> just like you use parentheses to write a symbol identifier prefix
14:44:10 <geheimdienst> > 'a' `elem` "lolcat"
14:44:11 <lambdabot>   True
14:44:23 * cmccann notes you can still use operator sections
14:44:25 <dAnjou> thanks
14:44:26 <geheimdienst> ^^ these are the same. pick whatever you find more readable
14:44:34 <cmccann> :t (`elem` "lolcat")
14:44:34 <lambdabot> Char -> Bool
14:44:45 <cmccann> > (`elem` "lolcat") 'a'
14:44:46 <lambdabot>   True
14:44:47 <cmccann> > (`elem` "lolcat") 'q'
14:44:48 <lambdabot>   False
14:44:53 <cmccann> sometimes that's useful
14:44:57 <dAnjou> yeah, i got it :D
14:44:58 <Saizan> monadic: are you trying to return that vector out of runST? i'm guessing that's the problem
14:45:16 <Saizan> monadic: what's the type of the expression you're passing to runST?
14:46:43 <monadic> Saizan: As my test I'm rewriting the Bloom API from RWH, so I have the following
14:46:46 <monadic> new :: V.Unbox a => (a -> [Word32]) -- * Hashes -> Int -- * Size of vector -> ST s (Bloom s a)
14:47:00 <monadic> data Bloom s a = Bloom (a -> [Word32]) (V.MVector (PrimState (ST s)) a)
14:47:25 * Melvar finds emself writing pipe-shaped code.
14:48:16 <monadic> Oh, the error is:     Couldn't match type `a' with `Bloom s a0'
14:48:32 <Saizan> monadic: yeah, you can't runST (new ...) because the result type of new, i.e. (Bloom s a), contains the 's' type variable that's connected with the 's' argument of ST
14:48:48 <parcs> horizontal, vertical or diagonal pipes?
14:49:16 <_Ray_> Oh awesome, I get it. undef is also a fixed point of, say, sqrt(2+x). 2 is a fixed point, but undef is lower than any value. And per Kleene's theorem, iterating f (starting with undef) will give me the least fixed point, which is undef, not 2.
14:49:43 <cmccann> parcs, or super mario pipes... code goes in one place, pops out somewhere else entirely
14:49:57 <Saizan> monadic: if it's similar to other mutable array libs MVector should have a "freeze" function to convert it to an array which can be taken out of ST
14:50:39 <monadic> Saizan: I tried freeze, it gave a much larger type error. Also tried runSt . freeze. The main problem for me is the whole PrimMonad/PrimState stuff.
14:51:17 <Saizan> well, you can't freeze Bloom directly
14:51:34 <Saizan> and (.) is probably not going to work when runST is involved
14:51:50 <hpc> (<=<) will work though
14:52:25 <Saizan> runST is not a kleisli arrow
14:52:55 <hpc> :t (<=<)
14:52:55 <Melvar> parcs: shell pipes.
14:52:56 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
14:53:06 <Saizan> my point was that given the higher-rank type of runST it doesn't play well with HOFs at all
14:53:10 <hpc> ah
14:53:22 <hpc> oh right, forgot about that tricky forall
15:01:42 <Melvar> Is it bad that I make chains of (>|), where (>|) = flip ($) ?
15:02:49 <doserj> it's equally bas as making chains of $
15:03:15 <parcs> doserj: why?
15:03:23 <orifichu> can i install the last cabal version using ghc 6.12?
15:04:02 <doserj> parcs: because it't the same, just written in a different order?
15:04:04 <cmccann> Melvar, why not use function composition to make the chain, then apply at the end?
15:04:39 <cmccann> also, I'd call it (|>) instead, but that's a minor quibble
15:04:53 <roconnor> @hoogle fromList
15:04:53 <lambdabot> Data.HashTable fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
15:04:53 <lambdabot> Data.IntMap fromList :: [(Key, a)] -> IntMap a
15:04:53 <lambdabot> Data.IntSet fromList :: [Int] -> IntSet
15:06:03 <Melvar> I use (|>) for flip (.) .
15:06:15 <cmccann> :t (>>>)
15:06:16 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
15:06:28 <cmccann> just use that instead
15:06:42 <cheater_> trying to follow the gtk2hs tutorial, but the code seems to have a problem
15:06:46 <Melvar> The reason is the direction: this reads from left to right and, in particular, top to bottom when I break lines.
15:08:18 <cmccann> Melvar, I actually gave an example of something similar recently: http://stackoverflow.com/questions/6494443/is-point-free-code-more-efficient-or-just-terser/6494763#6494763
15:08:45 <cmccann> Note that you can do blah >>> foo >>> bar $ x to apply the argument afterwards
15:08:53 <cmccann> rather than starting with the application
15:09:16 <doserj> that's just confusing
15:09:27 <cheater_> http://pastebin.com/1jy3LEyy  << why is this gtk2hs code broken?
15:09:32 <Peaker> Melvar: in a lazy language -- the most determining part of the expression w.r.t its result, is the final applied function.  Thus, it makes sense to have that appear first, so:  f (g (h 5))   'f' is most important so should be first.  f . g . h $ 5    should have same order for same reason
15:10:21 <orifichu> can i install the last cabal version using ghc 6.12?
15:10:21 <cmccann> also, I recommend |> because that's what it's called in F# and it's visually suggestive of what it does
15:10:25 <c_wraith> yeah, in a lazy language, f is actually applied *first*
15:10:38 <c_wraith> g isn't even applied unless f needs it to be
15:13:12 <cmccann> at any rate, the main thing is that a flipped composition operator exists in the standard libraries, so I strongly encourage using that rather than defining your own
15:13:19 <Melvar> cmccann: “visually suggestive” is subjective.
15:13:45 <cmccann> what you call a flipped application operator is a matter of taste
15:14:03 <cheater_> it depends on what wavelengths your "eyes" "see"
15:14:15 <cmccann> Melvar, visually suggestive in that it points things in the direction they go... which is also true of your use, so I wasn't criticizing or anything
15:14:25 <cmccann> note that (>>>) points in the same direction
15:14:38 <cheater_> it might be invisible to your naked "eye" if you're say a gas-being
15:15:57 <cmccann> stuff like (>=>) vs. (<=<) follows the same quasi-convention
15:16:38 <Peaker> English tends to write in outer-in order too:  Take the first 5 elements of the sorted set of primes under 100.. And not:  Take the set of primes under 100, sort them, take the first 5, ...
15:17:03 <Peaker> as well as function application order in most languages
15:17:18 <Peaker> it may sound weird, but the standard "data-flow order" is right-to-left :-)
15:17:35 <cmccann> Peaker, except OO languages, where the first argument of the function is written first, the function second, and other arguments after ;]
15:18:07 <geheimdienst> "Take the set of primes under 100, sort them, take the first 5" sounds like a very normal way of talking to me
15:18:11 <cheater_> why is this not working? http://pastebin.com/1jy3LEyy
15:18:33 <Peaker> cmccann: single-dispatch is a weird animal indeed :)
15:18:48 <c_wraith> geheimdienst: it is.  and it's fundamentally imperative rather then declarative :)
15:19:20 <geheimdienst> yeah, that sounds about right
15:19:29 * cmccann doesn't think English phrasing is a very good guide for how code should be structured, really
15:19:49 <orifichu> can i install the last cabal version using ghc 6.12?
15:20:06 <Peaker> cmccann: Wasn't trying to suggest that -- just that it sounds like data should flow left-to-right, but virtually all conventions have it backwards (English is just one of many)
15:20:10 <c_wraith> orifichu: I believe so.
15:20:39 <Nimatek> I think we should be able to program using interpretative dance.
15:20:41 <Melvar> Peaker: Starting at some length, I would take the latter order.
15:20:59 <geheimdienst> cheater_: eventSent is not a function, it doesn't take an argument, yet you're giving it one
15:21:29 <Melvar> (That is, dataflow left-to-right.)
15:21:29 <cheater_> b-but
15:21:37 <cheater_> that's what the examples say over and over i should be doing
15:21:53 <geheimdienst> Nimatek: i second that, but i hope we also can do compilative dance
15:21:58 <ddarius> @google labanotation
15:22:01 <lambdabot> http://www.uni-frankfurt.de/~griesbec/LABANE.HTML
15:22:01 <lambdabot> Title: Introduction to Labanotation
15:22:40 <Nimatek> geheimdienst: Sure, one just has to be a real pro for the dance to compile without any mistakes.
15:22:48 <geheimdienst> cheater_: do you have a link to the examples?
15:22:51 <cheater_> i mean if i get rid of the argument it's broken anyways
15:23:00 <roconnor> @src showString
15:23:01 <lambdabot> Source not found. Where did you learn to type?
15:23:07 <cheater_> it then does this:     Couldn't match expected type `Bool'                with actual type `Control.Monad.Trans.Reader.ReaderT                                    (GHC.Ptr.Ptr any0) IO Bool'
15:23:13 <cheater_> yeah i do just a sec
15:23:13 <hpaste> orifichu pasted “cabal update error” at http://hpaste.org/48887
15:23:22 <orifichu> c_wraith: when i try to do "cabal install Cabal" to update Cabal (because i have 1.8 version) i have some problem: http://hpaste.org/48887
15:23:32 <Peaker> Melvar: well, then you have 2 types of function application orders (>|) and ($)/normal apply  --  and thus two orders to read code by, rather than one uniform order
15:24:03 <cheater_> here you go geheimdienst http://www.muitovar.com/gtk2hs/app1.html
15:24:19 <cheater_> this is where eventSent is introduced: http://www.muitovar.com/gtk2hs/chap6-2.html
15:24:20 <c_wraith> orifichu: I've never seen that before.  does "ghc-pkg check" produce any output on your system?
15:25:06 <orifichu> c_wraith: nop...that line not produces nothing at all
15:25:13 <cmccann> Peaker, good thing we use (=<<) for monad application, then, eh? ;]
15:26:03 <Peaker> cmccann: indeed I do :-)
15:26:18 <Peaker> cmccann: though I may use >>= when the main thing is the effects, and not the data
15:26:29 <c_wraith> orifichu: I've never seen that before.  It's failing on the *install*, not the build or link.  is it some sort of permissions error?
15:26:40 <Peaker> cmccann: I stick to right-to-left as much as I can exactly for the uniform-order-to-read-by reason
15:27:05 <cmccann> Peaker, as do I, just noting that things really aren't that consistent in general :[
15:27:24 <cmccann> though I still find reading bottom-to-top kinda awkward
15:27:38 <orifichu> c_wraith: dont know
15:28:01 <c_wraith> orifichu: does it have permission to write to the directories and files it needs to?
15:28:02 <Peaker> cmccann: well, (>>=) and (>>) are for statement lists, like (;) in other languages.. (=<<) and ($) and (.) and application are for [lifted] expressions
15:28:15 <Peaker> cmccann: rationalization is a powerful drug :-)
15:28:21 <cmccann> not sure why, since it's really not any different than right-to-left on the line, which I don't actually READ from the right, so meh
15:28:27 <geheimdienst> cheater_: looks like that you're using the wrong kind of "eventSent" ... http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=eventSent note how one has the type that ghc complains about, but the other one is not
15:28:46 <cheater_>  erm... so what do i do about it?
15:28:51 <cheater_> i'm confused
15:29:01 <Peaker> cmccann: My guess is that end-of-line is a clearer place to start reading from, than some bit of vertical spacing
15:29:02 <orifichu> c_wraith: oh yeah...i have permission to change the permissions of all directories whitin $HOME
15:29:07 <geheimdienst> ... but it sure is confusing. i wonder why there's two different same-named eventSent thingies in gtk
15:29:22 <cmccann> Peaker, oh, good point. it is a nice visual cue.
15:29:36 <Peaker> also less eye travel, probably
15:29:44 <cheater_> hmm
15:29:57 <Peaker> Haskell's laziness lets us write definitions in any order -- and that means you can't rely on any aspect of the order :-(
15:30:01 <cheater_> so how do i use the right one?
15:32:06 * cmccann installs a GHC build snapshot in order to play with superclass equalities :D
15:34:25 <geheimdienst> cheater_: i'd first find out if line 1 or 2 is responsible for importing the wrong eventSent. i'd fire up ghci, do "import Graphics.UI.Gtk" and check :t eventSent if it imported the wrong one
15:34:55 <dogbert> what's the best way to translate sigma notation into haskell, for example if it sums (-1)^i * everything else ?
15:34:56 <geheimdienst> once you know which package, you can append "hiding (eventSent)" to the import line
15:35:25 <cheater_> the type there is EventM any Bool
15:36:08 <cheater_> i mean in the Graphics.UI.Gtk
15:36:33 <geheimdienst> note that i have not used gtk. this is just generic advice. maybe a gtk guy would say "oh yes, that one recent version changed something, the normal fix is just to do X"
15:37:20 <cmccann> dogbert, not sure what you're looking for exactly, is "i" the summation index?
15:38:02 <dogbert> yes
15:39:55 <cmccann> dogbert, and what's "everything else"? A list of things being indexed by i? Some constant expression?
15:40:30 <cheater_> geheimdienst, that was great help, it works now
15:40:35 <cheater_> import Graphics.UI.Gtk hiding (eventSent)
15:40:36 <cheater_> import Graphics.UI.Gtk.Gdk.Events
15:40:36 <kmc> cmccann, lots of cool new features :)
15:40:44 <kmc> Safe Haskell, compiler plugins
15:40:52 <dogbert> I was trying to represent this function: http://upload.wikimedia.org/math/0/b/4/0b4b9c33237b3321b0272e78e697d74b.png
15:40:56 <geheimdienst> great to hear :) happy to help
15:41:02 <ddarius> > (0.05)^10
15:41:03 <lambdabot>   9.76562500000001e-14
15:41:03 <cheater_> :)
15:41:04 <cmccann> kmc, superclass equalities are what I'm most enthusiastic about, but yeah
15:41:07 <ddarius> > (1.05)^10
15:41:08 <lambdabot>   1.6288946267774416
15:41:09 <kmc> what will you use them for?
15:41:25 <cmccann> kmc, replacing fundeps mostly
15:41:40 <c_wraith> > sum . zipwith (*) (cycle [1, -1]) $ [1..10]
15:41:40 <lambdabot>   Not in scope: `zipwith'
15:41:44 <geheimdienst> > 1 . 05
15:41:44 <lambdabot>   No instance for (GHC.Show.Show (f b))
15:41:45 <lambdabot>    arising from a use of `M8544581070...
15:41:48 <c_wraith> > sum . zipWith (*) (cycle [1, -1]) $ [1..10]
15:41:49 <lambdabot>   -5
15:42:37 <kmc> dogbert, maybe a list comprehension like [ ... | (i,x) <- zip [0..] xs ]
15:43:57 <dogbert> hmm I will  look into that
15:45:13 <orifichu> i have installed manually the last cabal version in ".cabal/lib/Cabal-1.10.2.0" but in ".cabal/bin" i have the cabal 1.8 version....how can i use the last version?
15:48:20 <Melvar> Əɣ, I finished the single-use script I was writing, now it fails on invalid input encoding.
15:51:10 <dschoepe> Melvar: iconv might help if you just want a quick-and-dirty workaround
15:52:53 <Melvar> dschoepe: iconv also fails on invalid input encoding.
15:53:49 <Melvar> But it reports where.
16:01:41 <chrisdone> orifichu: It's possible that your cabal update error was that linking took too much memory and died. I've had that before.
16:02:38 <chrisdone> The solution was to run it again and unsafePerformPrayerForThatWhichPreviouslyFailedOughtToNowWork.
16:03:33 <djahandarie> Hey chrisdone
16:04:09 <djahandarie> Is the reason you can't get line numbers on hpaste becuase you switched libraries?
16:04:28 <djahandarie> Someone just came out with a new highlighting library, maybe it does it
16:04:31 <monadic> Returning to my question about freezing vectors: How do I get from ST s (Bloom s a), where Bloom contains a V.MVector (PrimState (ST s)) a, to a V.MVector (PrimState (ST s) a). I can't run the ST...?
16:04:50 <monadic> I think I need the equivalent of runSTUArray.
16:05:31 <c_wraith> monadic: runSTUArray is just based unsafeFreezeArray.  There should be some operation to freeze a vector you can use?
16:05:59 <chrisdone> djahandarie: Yeah, the old library used pcre which causes segfaults. What is the new highlighting library you mention, and does it use libpcre (deal breaker)?
16:06:19 <int80_h> I want to parse a test file replacing every "foo" with "bar. I do not want to use regular expressions. What are my options?
16:06:23 <djahandarie> Right, I've had similar issues with highlighting
16:06:30 <int80_h> text file, not test file
16:06:30 <djahandarie> Let me see if I can remember the new one
16:06:40 <c_wraith> int80_h: the text library includes string replacement functions.
16:06:57 <c_wraith> int80_h: if you don't want to fit the whole thing in memory, you can use lazy text
16:07:04 <ddarius> What difference does it make to you whether regular expressions are used or not?
16:07:06 <int80_h> cool!
16:07:07 <chrisdone> djahandarie: highlighting-kate and highlighter — both exhibited this problem, FWIW.
16:07:32 <djahandarie> The new one uses alex
16:07:38 <chrisdone> ddarius: It makes no difference whether regular expressions are used.
16:07:49 <djahandarie> Aha
16:07:52 <djahandarie> @hackage illuminate
16:07:52 <lambdabot> http://hackage.haskell.org/package/illuminate
16:08:22 <orifichu> is necessary install "ghc-paths-0.1.0.8" to install snap?
16:08:25 <chrisdone> Looks good, I might trial it tomorrow.
16:08:40 <djahandarie> Also is pretty much right off the press too though, who knows what will happen. :p
16:09:13 <ddarius> chrisdone: I was directing that to int80_h.
16:09:15 <chrisdone> djahandarie: I'll stick with hscolour for Haskell, at any rate. There're no line numbers because I keep getting side-tracked when I go to add them.
16:09:37 <djahandarie> lol
16:11:44 <int80_h> :t replace
16:11:44 <lambdabot> Not in scope: `replace'
16:13:03 <chrisdone> int80_h: http://hackage.haskell.org/packages/archive/MissingH/0.18.6/doc/html/Data-List-Utils.html#v%3Areplace
16:14:01 <int80_h> chrisdone: thanks. All I could find was Data.Text, and I was hoping for a Prelude version, or something that didn't require a Text.
16:15:16 <c_wraith> Why would you rather not use Text?  That confuses me a bit.
16:16:14 <AlbertE> ,
16:16:53 <dAnjou> my brain hurts when i try thinking the haskell way. maybe you can give me a hint. i want to iterate over a string and write the incoming characters in one string but only as long as the meet a certain condition AND i want to keep the rest in another string and want to return something like ["This"," is a sentence"]. i thought about using takeWhile. then i get "This" but how can i keep the rest as well?
16:17:12 <kmc> :t break
16:17:13 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
16:17:23 <kmc> > break isSpace "This is a sentence"
16:17:24 <lambdabot>   ("This"," is a sentence")
16:17:28 <dAnjou> nice
16:17:36 <dAnjou> thanks
16:18:21 <kmc> :)
16:19:30 <dAnjou> i already love haskell because of "batteries included"
16:19:39 <dAnjou> it's like python
16:20:34 <monadic> I think I figured out how to get the equivalent of runSTUArray, but it gives an infinite type error (will paste code/error in a sec)
16:20:43 <ivanm> how can a programming language have batteries inside of it?
16:21:04 <c_wraith> ivanm: data Batteries = Batteries
16:21:12 <c_wraith> ivanm: just need to slip that into the prelude
16:21:17 <ivanm> heh
16:21:28 <monadic> https://gist.github.com/3c39f73c3ced43e6e34f
16:21:32 <kmc> there are some weird gaps in the standard library
16:21:46 <c_wraith> like a lack of a data type for batteries :)
16:21:58 <kmc> type Battery = [Cell]
16:22:57 <monadic> I have no idea where I can be getting an infinite type error, since I'm not even recursing :\
16:23:39 <c_wraith> monadic: you can get infinite type errors by treating an element of a list as if it was the whole list, for instance.  same must be true of vectors
16:23:52 <monadic> c_wraith: Yes, but I can't see where I'm doing that...
16:24:12 <c_wraith> well, the code you pasted is clearly truncated, so I can't either :)
16:24:13 <monadic> I think that the let vec' should have been a monad bind, though.
16:24:15 <Axman6> if you write something like foo (x:xs) = xs ++ x, then you'll get an infinite type error
16:24:34 <monadic> c_wraith: Its not truncated :\
16:24:37 <Axman6> > let foo (x:xs) = xs ++ x in foo ["hello","world"]
16:24:38 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
16:24:53 <c_wraith> monadic: you can't end a do block with a let, so...  that can't be right.
16:24:59 <monadic> Hmm
16:25:03 <monadic> Haha
16:25:11 <monadic> Missed a line, sorry. Updating.
16:26:05 <monadic> c_wraith: I changed to a monadic bind, and it gives me an error about it not being able to equate types.
16:26:09 <Cale> monadic: Infinite type errors are usually caused by inintentional recursion (like getting a name wrong and referring to something else by accident)
16:26:44 <Tomsik> Well, at least it's not an error that you notice in the runtime. ;]
16:26:53 <Tomsik> at*
16:27:42 <monadic> Uncommenting my type gives another error.
16:27:50 <c_wraith> well, the type you have there is wrong.
16:27:51 <c_wraith> :)
16:28:25 <c_wraith> The type should be runSTBloom :: (forall s. ST s (Bloom s a)) -> IBloom a
16:28:30 <monadic> I'm way in over my head here because I don't understand type families, which primitive relies on
16:28:45 <monadic> Oh so its not the type family thing
16:28:52 <Axman6> monadic: on a less relevant note, why does the vector store the a's? usually bloom filters are a bit field that just tell you whether something has hashed to each value or not
16:28:53 <monadic> I've been convinced that it was that :\
16:28:53 <c_wraith> You'll need Rank2Types or RankNTypes to make that type work
16:29:31 <monadic> Axman6: Oops, thanks.
16:30:16 <Tomsik> Why don't we have more high-rank fancy stuff in Haskell anyway?
16:30:29 <c_wraith> because it's not H98
16:30:32 <c_wraith> so some people avoid it
16:31:16 <c_wraith> And many others just never bothered to learn about higher-rank types
16:31:17 <monadic> Is it candidate for HS2012?
16:31:27 <c_wraith> not so far as I know.
16:31:42 <monadic> Oh wow. That whole a to Bool fixed it. I'm in awe over how stupid I am.
16:31:49 <Axman6> i think the type of runSTBloom should be Unbox a => (forall s. ST s (Bloom s a)) -> IBloom a
16:31:50 * cmccann prefers to code in Hω
16:32:00 <cmccann> it's Haskell from the future
16:32:25 <monadic> Axman6: Thats what I have now.
16:32:26 <Cale> The infinite future
16:32:30 <monadic> Wait no
16:32:33 <monadic> I don't have the Unbox
16:32:34 <cmccann> Cale, the best kind of future
16:32:43 <monadic> Doesn't seem to be needed, which is odd...
16:32:47 <cmccann> because it never stops being the future
16:33:54 <monadic> Well, thanks for the help. Can't beleive that was the thing that was stumping me - guess I shouldn't assume its the complicated thing I don't quite understand.
16:34:27 <Axman6> monadic: if you're after a bloom filter, then you probably don't need the
16:34:39 <Axman6> Unbox a, because the vectors will just contain Bools
16:34:55 <monadic> Axman6: Oh, thats right.
16:35:03 <Axman6> which I believe is implemented as a bit vector for Vector
16:35:16 <monadic> Axman6: I'm basically transitioning the RWH bloom filter to Vector for an exercise
16:36:21 <dented42> I'm on emacs trying to get speedbar to work with haskell-mode. The haskell wiki says it should work more or less automatically, but for whatever reason it seems unable to make an index of my source files. any thoughts?
16:36:41 <shapr> dented42: any errors?
16:37:14 <Axman6> monadic: sounds like a good project
16:37:56 <dented42> shapr: not really, the speedbar loads, and gives an empty index for the files. Something that might be related, when haskell-mode loads it displays "No items suitable for an index found in this buffer"
16:42:06 <chrisdone> djahandarie: Added line numbers.
16:43:15 <chrisdone> djahandarie: http://hpaste.org/48871#line10
16:44:00 * chrisdone goes to bed
16:44:08 * monochrom tries to hack it. what if #line10000 ?
16:44:39 <monochrom> ok, doesn't crash :)
16:48:25 <ddarius> > maxBound :: Int
16:48:26 <lambdabot>   9223372036854775807
16:49:06 <ddarius> > maxBound :: Word64
16:49:07 <lambdabot>   18446744073709551615
16:49:31 <ddarius> > maxBound :: Int32
16:49:32 <lambdabot>   2147483647
16:50:36 <killerswan> so, how can I install the profiling libraries for package `vector-0.7.1`?
16:52:44 <Cale> cabal install --reinstall -p vector-0.7.1
16:52:45 <killerswan> when I'm not trying to profile the heap of my program, I can compile and run it
16:53:42 <Cale> library-profiling: True -- add this line to ~/.cabal/config to enable library profiling by default for newly-installed packages
16:54:03 <Axman6> killerswan: it's a good idea to turn on profiling for all your cabal installed packages. edit the ~/.cabal/config file
16:54:10 <Axman6> bah, beaten
16:56:10 <roconnor> is tempted to use callCC to exit his function early
16:57:34 <roconnor> @type callCC
16:57:35 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
16:58:45 <Cale> I often think that IO should be a MonadCont just because.
16:59:49 <roconnor> but maybe I'll just use Maybe instead
17:00:16 <ddarius> Cale: You can't implement a full callCC (or at least not efficiently) on top of IO.
17:00:31 <ddarius> You can, though, easily implement a one-shot one.
17:02:33 <Cale> I'm thinking of it as a new primitive
17:03:28 <kmc> i like the idea of implementing continuations in C with fork()
17:04:08 <roconnor> so my experiment with defining data NEList a = NENil a | NECons a (NEList a) is not as successful as I was hoping.
17:04:11 <ddarius> Lycopene is interesting in how uninteresting it is.
17:04:17 <killerswan> Cale & Axman6: thanks!
17:04:19 <ddarius> type NEList a = (a, [a])
17:04:19 <roconnor> It really seems that (a , [a]) is better
17:18:49 <stephenjudkins> suppose I've written a Okasaki-style binary tree; i'd like to extend it to be (1) persistent and (2) use lazy I/O to load nodes from disk. can anyone recommend a general approach I should take?
17:27:40 <ivanm> stephenjudkins: well, if it's okasaki style then wouldn't already be persistent? (unless you're using a different meaning of the word)
17:27:57 <ivanm> and as for using lazy I/O ... using what kind of encoding?
17:28:10 <stephenjudkins> ivanm: by persistent I mean saving to disk
17:28:30 <stephenjudkins> ivanm: let's ignore the encoding for now
17:28:42 <ivanm> well, you can't
17:28:52 <stephenjudkins> ivanm: i'm curious why not?
17:28:54 <ivanm> are you wanting to use Show/Read ? a binary format?
17:29:10 <ivanm> depending on the kind of encoding you want will require using different I/O methods
17:29:27 <ivanm> the former you'd just use normal in-built I/O; the latter would probably use Bytestrings
17:30:11 <monadic> For binary IO you should use the autoderivable Binary typeclass provided by Data.Binary in the binary package
17:30:19 <ivanm> or maybe acid-state
17:30:24 <monadic> by binary IO, I mean serialization to bytestring
17:30:31 <ivanm> monadic: Binary is auto-derivable? since when?
17:30:45 <monadic> ivanm: There is a script available somewhere, let me dig up the link
17:31:00 <stephenjudkins> i'm more interested in implementing it myself than using something in the standard library
17:31:16 <ivanm> monadic: a script yes; I thought you meant just doing "deriving (Binary)" and ghc would do it ;-)
17:31:26 <ivanm> stephenjudkins: more specifics required as to what you want
17:31:36 <monadic> ivanm: No, I mean its a TH
17:31:43 <ivanm> *nod*
17:31:43 <monadic> ivanm: If I recall.
17:31:53 <siracusa> What is an Okasaki style tree, btw?
17:31:54 <monadic> ivanm: Unfortunately, the user who posted the answer on SO has 162 answers
17:31:54 <ivanm> there's also Data.Derive, etc.
17:32:00 <monadic> ivanm: It might use that
17:32:00 <ivanm> heh
17:32:50 <Axman6> stephenjudkins: if you want to implement that efficiently, using something like Binary wouldn't be a great idea. what you need is to be able to store the offsets to the subtrees, so they can be read in when needed. if you do it the way Binary does it, if you want to access the right subtree of the root, you'll need to load in the entire left subtree before you know where the right begins
17:33:05 <stephenjudkins> ivanm: fair enough, i'll get back to you with something nice
17:33:26 <monadic> ivanm: Using my ninja skills I guessed the location :D - http://code.haskell.org/binary/tools/derive/
17:33:33 <stephenjudkins> siracusa: http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf. i'd recommend the actual book based on that
17:33:55 <ivanm> stephenjudkins: I think siracusa meant "what do _you_ mean by okasaki style"
17:34:05 <monadic> Unfortunately it looks like its a code generator rather than template haskell :(
17:34:10 <ivanm> stephenjudkins: any particular reason for you re-inventing the wheel btw?
17:34:27 <ivanm> monadic: which makes more sense IMHO: it's a one-off generation, so why re-generate it at each compile?
17:34:28 <Axman6> stephenjudkins: 404
17:34:43 <stephenjudkins> ivanm: curiosity
17:34:53 <stephenjudkins> Axman6: maybe drop the "." from the end?
17:35:08 <Axman6> ah right =)
17:35:19 <monadic> ivanm: Eh, you only regenerate each change to the module. You'd have to regenerate the instance every time you change the data decl, which is a pain.
17:35:37 <stephenjudkins> i just don't have a great understanding of how monadic I/O really works
17:36:13 <ivanm> monadic: would you really be changing your data structure that often compared to how many times it may theoretically get used?
17:36:26 <ivanm> Axman6: where's that I/O tutorial of yours?
17:36:33 <ivanm> might help stephenjudkins
17:36:38 <Axman6> @google axman's haskell io tutorial
17:36:40 <lambdabot> http://random.axman6.com/blog/?page_id=70
17:36:40 <lambdabot> Title: Data.Random » Axman’s Haskell IO tutorial
17:36:44 <Axman6> yay
17:37:10 <monadic> ivanm: If its abstract, theres a chance. But you never know if you might forget to update it when you update the data structure...
17:37:16 <Axman6> hmmmmm, i think I may have just thought of a nice way to do what you're after stephenjudkins
17:37:20 <monadic> ivanm: If its not automatable, its not good, imo.
17:37:25 <stephenjudkins> Axman6: wow that looks great. thanks. ivanm : thanks also
17:37:27 <ivanm> monadic: true
17:37:53 <ivanm> monadic: but wouldn't the compile _fail_ if it didn't match your data structure?
17:37:56 <Axman6> the main problem is figuring out what offsets things will have when encoded...
17:38:39 <conal> stephenjudkins: the crucial idea of haskell's IO is that it's an abstract data type representing (possibly infinite) imperative computations. the whole "monad" aspect is just to match a somewhat common pattern and is inessential to understanding.
17:38:42 <monadic> ivanm: Probably.
17:39:26 <stephenjudkins> Axman6: i was thinking to start of just having a directory full of files, with the filename being an arbitrary string; the file is [left child, right child, value] \n delimited
17:39:50 <stephenjudkins> something very simple, slow, but impractical
17:40:01 <Axman6> heh
17:40:23 <Axman6> I'll see if I can come up with something for you. I'm at a haskell hackathon right now anyway, and needing something to work on =)
17:52:47 <dAnjou> can i paste 4 lines here?
17:53:34 <hpc> @where hpaste
17:53:35 <lambdabot> http://hpaste.org/
17:54:54 <hpaste> dAnjou pasted “infinite” at http://hpaste.org/48889
17:55:22 <dAnjou> i finally got this
17:55:55 <dAnjou> don't laugh at me, it was hard for me to get this
17:55:56 <mm_freak> dAnjou: are you exercising?  if not, just a quick note: there is already a function in Data.List for breaking things into words
17:56:10 <dAnjou> mm_freak: i am
17:56:17 <mm_freak> ok, alright then =)
17:56:33 <dAnjou> ok, you got already what i want to do
17:56:36 <hpaste> orifichu pasted “netstat log” at http://hpaste.org/48890
17:56:47 <mm_freak> dAnjou: next step:  try to implement the same function only using takeWhile, dropWhile and recursion
17:56:49 <dAnjou> unfortunatly this runs to infinity
17:56:50 <mm_freak> it's pretty simple
17:56:56 <edwardk> i just loaded a haddock page for one of my libraries. The vocabulary used confused google chrome to the point where it said "This page is in Spanish, would you like to translate it?"
18:00:16 <dAnjou> mm_freak: well, my problem right now is: how do i stop the recursion i have?
18:01:13 <mm_freak> dAnjou: by a base clause
18:01:31 <mm_freak> usually a finite recursion would have two clauses:  a base clause and a recursive clause
18:02:10 <luite> edwardk: hehe interesting. I wonder what it uses to determine the language... common words? n-gram frequencies?
18:02:31 <mm_freak> example:  factorial 0 = 1;  factorial n = n * factorial (pred n)
18:02:35 <edwardk> luite: no idea. its just the decidable zero module in my current algebra package, the others don't complain ;)
18:02:40 <mm_freak> the former is the base clause, the latter is the recursive clause
18:02:56 <SirFrancisDrake> dAnjou: every iteration of your recursive fn should reduce the input somehow. So, a finite input, being cut down on every steps, eventually gets to a base clause
18:03:15 <Axman6> does anyone know of a serialisation library, preferably like Binary, that lets you find out how many bytes have been written so far?
18:03:28 <_Ray_> foldl (\xs -> (\x -> (f x):xs)) [] == map f, correct?
18:03:30 <dAnjou> SirFrancisDrake: i got it
18:03:58 <dAnjou> getWords [] = []
18:04:06 <mm_freak> dAnjou: as said, try again with only dropWhile and takeWhile…  it's really easy
18:04:14 <ivanm> Axman6: binary and cereal are the only maintained serialisation libraries that I know of :s
18:04:27 <dAnjou> mm_freak: now that it stops, i'll try that :)
18:04:27 <Axman6> there's also Blaze-builder
18:04:42 <Axman6> but nothing lets you find out how many bytes have been written so far
18:09:43 <SirFrancisDrake> _Ray_: looks weird.
18:10:25 <Axman6> ok, this problem is too hard to accomplish with not enough sleep -_-
18:10:40 <SirFrancisDrake> > foldl (\xs -> (\x -> (x * 2):xs)) [] [1,2,3]
18:10:41 <lambdabot>   [6,4,2]
18:12:19 <SirFrancisDrake> :t \xs -> (\x -> (x * 2):xs))
18:12:20 <lambdabot> parse error on input `)'
18:13:00 <SirFrancisDrake> :t \xs -> (\x -> (x * 2):xs)
18:13:01 <lambdabot> forall a. (Num a) => [a] -> a -> [a]
18:14:53 <hpaste> orifichu pasted “wget localhost:6000” at http://hpaste.org/48892
18:16:35 <SirFrancisDrake> foldl (\acc x -> acc ++ [2*x] ) [] [1,2,3]
18:16:39 <SirFrancisDrake> > foldl (\acc x -> acc ++ [2*x] ) [] [1,2,3]
18:16:40 <lambdabot>   [2,4,6]
18:19:14 <dAnjou> mm_freak: i don't see it. when i use takeWhile and take characters from the string how can i keep the rest of the string?
18:22:30 <Jafet> :t span -- danjou
18:22:31 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
18:26:18 <dAnjou> Jafet: i'm practising ;)
18:31:22 <nand`> A quick question: From what I understand of things, am I right in assuming that I can make *any* Functor an instance of the Monad class?
18:31:33 <kmc> no
18:32:00 <nand`> But can't I just fmap and encapsulate the result inside the type?
18:32:00 <kmc> Monad is a strictly more powerful API
18:32:20 <kmc> i don't know what that means
18:32:25 <Axman6> you can't implement >>= for some Functors
18:32:27 <kmc> but, how would you implement 'return' with 'fmap'?
18:32:39 <Axman6> it's the same reason why not all Applicatives can be Monads
18:32:45 <aculich> when I'm writing a monadic loop, like this: loop foo = do { ...; loop bar }, does it get optimized properly into a tail-recursion?
18:32:53 <shachaf> nand`: The reverse is true -- you can make any Monad into a Functor with fmap = liftM.
18:32:54 <ivanm> Monad implies Applicative implies Functor
18:33:05 <ivanm> aculich: Haskell doesn't do tail call optimisation as such
18:33:08 <Axman6> aculich: entirerly depends on the Monad
18:33:08 <ivanm> well, GHC doesn't
18:33:09 <kmc> aculich, maybe.  very little you can say about all monadic code, because (>>=) has a completely different implementation for every type
18:33:27 <nand`> Well, since fmap has a type of (a -> b) -> f a -> f b, I thought that I could easily turn it into f a -> (a -> f b) -> fb
18:33:35 <nand`> which is the type of >>=
18:33:36 <kmc> how / why?
18:34:01 <kmc> 'return' is more obviously impossible, I think
18:34:33 <nand`> instance Monad Maybe where return a = Just a <- something like this?
18:34:45 <kmc> sure, Maybe is a monad
18:34:46 <aculich> what's the best way to determine whether the implementation of >>= in a
18:34:47 <aculich> monad I'm using will produce a stack overflow (short of writing a test)?
18:34:55 <Axman6> what about this: data Foo a = Foo Int. that's easily turned into a Functor: instance Functor Foo where fmap x = x, but when you try and implement Monad, there's no way to get the in (>>=) :: Foo a -> (a -> Foo b) -> Foo b
18:34:59 <kmc> but you said *all* functors are monads
18:35:06 <aculich> \
18:35:11 <dAnjou> mm_freak: got it :D but it look kind of stupid
18:35:18 <blackdog> anyone got a linux box, ghc 7.0.3, and a couple of minutes to help me test something?
18:35:22 <Jafet> nand`: you want to fill in this instance? instance Functor f => Monad f where ..
18:35:23 <blackdog> getting a really weird error in hint
18:35:23 <kmc> so you should be able to implement 'return' with *only* fmap
18:35:29 <kmc> but you definitely can't
18:35:40 <kmc> because 'return ()' creates a value of type (F ()) from nowhere
18:35:41 <Jafet> blackdog: yes
18:35:49 <mm_freak> dAnjou: paste?
18:35:50 <jmcarthur> blackdog: how many couple of minutes? :P
18:35:59 <hpaste> dAnjou pasted “getWords” at http://hpaste.org/48895
18:36:01 <Axman6> kmc: am i right in saying that data Foo a = Foo Int is a Functor, but not a Monad?
18:36:06 <kmc> but the Functor API gives you no way to create values like that
18:36:26 <kmc> Axman6, it sounds like the Const monad
18:36:49 <nand`> Jafet: fmap f a = return (f a)?
18:36:57 <mm_freak> dAnjou: good, now as a further improvement try to get rid of the explicit recursion
18:37:00 <cmccann> Axman6, return _ = Foo 0, join = id
18:37:01 <jmcarthur> :t Const
18:37:02 <lambdabot> forall a b. a -> Const a b
18:37:08 <jmcarthur> the const monad is different
18:37:12 <mm_freak> dAnjou: one way to do it:  use the 'iterate' function in Data.List
18:37:20 <kmc> nand`, you can implement Functor for every Monad
18:37:23 <kmc> maybe that's what you mean
18:37:25 <Axman6> cmccann: hmm
18:37:27 <blackdog> jmcarthur: should honestly be 2 minutes, if you have hint and --enable-shared on
18:37:29 <kmc> you can't implement Monad for every Functor
18:37:37 <blackdog> import Language.Haskell.Interpreter
18:37:38 <blackdog> main = runInterpreter (return ()) >>= print
18:37:38 <cmccann> (id doesn't actually work directly because you have to fudge the types)
18:37:39 <mm_freak> dAnjou: you will now need takeWhile, dropWhile, iterate and map
18:38:00 <ManateeLazyCat> gtk2hs-0.13.0 is developing, the aim of gtk2hs-0.13.0 is complete all new APIs in GTK-3.0
18:38:06 <jmcarthur> i'm not certain about enable-shared
18:38:06 <mm_freak> dAnjou: this is a bit tricky, but it will get you closer to the right thinking, when it comes to writing list functions
18:38:13 <Jafet> nand`: with Functor f => Monad f, you need to define return and (>>=) using fmap.
18:38:14 <nand`> kmc: Just because of return, though? The only thing I looked at was (>>=)
18:38:17 <nand`> I hadn't considered return
18:38:29 <kmc> nand`, pretty sure (>>=) is also not possible
18:38:39 <kmc> but i don't have a proof offhand
18:38:54 <shachaf> Not possible without join, yes.
18:39:02 <mm_freak> dAnjou: as a hint on how to do it, look at this:
18:39:03 <kmc> try to implement (>>=) using only fmap and i think you'll run into trouble
18:39:18 <mm_freak> > map (take 2) . iterate (drop 2) $ [0..]
18:39:19 <Jafet> @src Applicative
18:39:19 <lambdabot> class Functor f => Applicative f where
18:39:19 <lambdabot>     pure  :: a -> f a
18:39:19 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
18:39:20 <lambdabot>   [[0,1],[2,3],[4,5],[6,7],[8,9],[10,11],[12,13],[14,15],[16,17],[18,19],[20,...
18:39:23 <kmc> there's no way to 'extract' stuff
18:39:32 <nand`> instance (Functor f) => Monad f where return a = f a -- Is this not possible?
18:39:40 <kmc> why don't you write it and see
18:39:57 <shachaf> nand`: What does that last f mean?
18:40:03 <jmcarthur> you are using f inconsistently
18:40:04 <shachaf> You're probably confusing types and values.
18:40:14 <kmc> you can test this code
18:40:17 <Jafet> Indeed, nand` is very confused
18:40:33 <nand`> shachaf: the f would be the type constructor for the type f
18:41:06 <shachaf> nand`: What if f has more than one type constructor, or none?
18:41:09 <nand`> For example; type Foo f = Foo f; then instance Monad foo where return a = foo a
18:41:10 <kmc> nand`, that's... not how it works
18:41:10 <jmcarthur> f can't be both a type and a type constructor, and you also are using it at the value level on the right hand side there
18:41:38 <cmccann> nand`, and for Maybe, return x = Maybe x ...er, wait
18:41:44 <dAnjou> mm_freak: there are two things i don't know yet (. and $) and it's almost 4 a.m. here. i will go to bed but thanks a lot for your time and assistance :)
18:41:45 <shachaf> nand`: The type-level Foo and value-level Foo are completely different entities.
18:41:53 <kmc> data Foo a = Bar [a] (Int -> a)
18:42:10 <kmc> that's a functor
18:42:17 <_Ray_> nand`: But a isn't a type, it's a value. "return a = f a". Left side is treating a as a value, but if f is a functor, then a must be a type.
18:42:26 <kmc> but the translation of your pseudocode generic instance would be
18:42:35 <kmc> return a = Bar a
18:42:41 <kmc> which is a type error
18:42:51 <kmc> you'd need something like (Bar [a] (const a))
18:42:52 <ddarius> Type constructors and data constructors are different things.
18:42:58 <kmc> which is why it's different for each type
18:42:59 <kmc> bbl
18:43:03 <ddarius> f can be instantiated to a type constructor.
18:43:43 <ddarius> Also, type Foo f = Foo f is illegal.
18:43:44 <mm_freak> dAnjou: you're welcome, but next time you have some time to learn, try it out
18:43:56 <mm_freak> ddarius: it's really essential that you learn the basics of composition
18:44:09 <mm_freak> (.) forms a composition and ($) applies it
18:44:28 <shachaf> Yes, ddarius, you really ought to learn the basics sometime.
18:44:32 <cmccann> haha
18:48:50 <ddarius> shachaf: I'm trying.
18:50:02 <dbpatterson> anyone care to check out some code and give feedback? This is the first parser I've written: http://hpaste.org/48896
18:50:31 <dbpatterson> it parses times / time ranges that are relatively unsanitized
18:51:05 <dbpatterson> ie, 7-5, 7:00-17:00, 8:30am-6, etc
18:52:10 <ddarius> dbpatterson: Step one: name Just . digitToInt <$> digit so you can reduce repetition and capture the concept.
18:55:01 <ddarius> You can also likely simplify ampm quite a bit.
18:55:21 <ddarius> @hoogle optional
18:55:21 <lambdabot> Control.Applicative optional :: Alternative f => f a -> f (Maybe a)
18:55:21 <lambdabot> Text.Parsec.Combinator optional :: Stream s m t => ParsecT s u m a -> ParsecT s u m ()
18:55:21 <lambdabot> Text.ParserCombinators.ReadP optional :: ReadP a -> ReadP ()
18:55:30 <ddarius> @hoogle optionMaybe
18:55:30 <lambdabot> Text.Parsec.Combinator optionMaybe :: Stream s m t => ParsecT s u m a -> ParsecT s u m (Maybe a)
18:55:30 <lambdabot> Text.ParserCombinators.Parsec.Combinator optionMaybe :: Stream s m t => ParsecT s u m a -> ParsecT s u m (Maybe a)
18:55:33 <hpaste> nand pasted “Infix Math Parser” at http://hpaste.org/48899
18:55:53 <ddarius> optionMaybe is option Nothing
18:56:01 <dbpatterson> ddarius: oh cool, thanks!
18:56:08 <nand`> While we're on the topic of parser commentary, anybody want to give some feedback on my basic infix math parser (hpaste just showed thel ink)
18:56:23 <nand`> It supports some basic operations, performs floating point math, and allows parentheses
18:58:26 <ddarius> Oh god, don't do fromInteger . toInteger.
18:58:29 <ddarius> @src fromIntegral
18:58:29 <lambdabot> fromIntegral = fromInteger . toInteger
18:58:39 <ddarius> Use fromIntegral for any integral conversion needs.
18:59:05 <dbpatterson> ddarius: thanks :)
18:59:58 <ddarius> nand`: If you are going to only use Double, then use (**).
19:00:03 <ddarius> for (^)
19:00:19 <ddarius> And there are better was of implementing a floating point mod.
19:00:44 <nand`> It's the first that came to mind which didn't involve rounding down
19:01:38 <nand`> ddarius: But can you give an example?
19:02:19 <azaq23> nand`: You should be able to use forever in your main function instead doing it that way, seems cleaner
19:02:22 <azaq23> @src forever
19:02:22 <lambdabot> Source not found. I feel much better now.
19:02:53 <nand`> @src interact
19:02:53 <lambdabot> interact f = do s <- getContents; putStr (f s)
19:03:14 <nand`> @src getContents
19:03:14 <lambdabot> getContents = hGetContents stdin
19:03:35 <azaq23> @type let forever m = m >>  forever m in forever
19:03:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
19:03:41 <azaq23> it's in Control.Monad
19:03:48 <ddarius> nand`: In general, your code isn't very clear.  Part of that is due to combining parsing and evaluating and part is that you don't make it clear what syntax you are following.
19:04:26 <ddarius> nand`: I'd recommend separating parsing from evaluation (by making an abstract syntax tree type) and explicitly writing out the EBNF you are working from and try to have your code follow that EBNF.
19:05:29 <ddarius> In addition to that, you could, use a parsing library.
19:05:51 <nand`> ddarius: Well, the approach I took was to just separate all operators, parentheses and numbers in step one (implemented by mathstr), and then have math just take a list of tokens
19:06:00 <nand`> for example ["5", "+", "5"]
19:06:14 <ddarius> nand`: Yes, that's separating lexing from parsing.
19:06:22 <nand`> I see
19:06:22 <ddarius> Which is usually a good idea.
19:07:11 <nand`> So you're suggesting I should separate the parentheses and ordering parser from the actual math, and use some abstract type (a tree in this case) to pass the data between the two functions?
19:08:14 <ddarius> The usual structure for an evaluator like this would be: lex -> parse -> eval.  lex :: String -> [Token]; parse :: [Token] -> AST; eval :: AST -> Value
19:08:28 <nand`> eg 2 * (3 + 4) would become Node "*" (Node "+" (Node "3" Empty Empty) (Node "4" Empty Empty) (Node "2" Empty Empty)
19:08:46 <ddarius> nand`: You'd want to use a more specialized tree most likely.
19:09:14 <nand`> ddarius: What do you mean by specialized? A plain tree is sufficient, no?
19:09:56 <dbpatterson> nand`: probably Mult (Add (N 3) (N 4)) or something like that
19:09:58 <ddarius> nand`: You want to make a data type that only represents valid expressions and includes relevant information.
19:10:17 <dbpatterson> Mult (N 2) (Add (N 3) (N 4)) I mean
19:10:32 <nand`> oh, yeah, I see what you mean now
19:10:37 <ddarius> nand`: A binary tree of strings allows things like Node "3" (Node "3" Empty Empty) (Node "3" Empty Empty")
19:11:28 <nand`> data (Num n) => Math n = Add (Math n) (Math n) | Mul (Math n) (Math n) | Factorial (n) | Value n -- something like this?
19:11:34 <nand`> err
19:11:36 <nand`> Factorial (Math n)
19:11:43 <ddarius> nand`: Don't ever put contexts on data type like that.
19:12:12 <ddarius> nand`: You can congeal some constructors to capture regularities.
19:12:29 <nand`> Well, wouldn't it make no difference in this example since every single function that works with Math will logically only accept numbers at some level
19:12:33 <ddarius> But otherwise, something like that would be fine.
19:12:47 <ddarius> nand`: That's not true.
19:13:36 <nand`> Well, I'm going to define something like evaluate Add a b = (evaluate a) + (evaluate b)
19:13:55 <ddarius> That would be evaluate (Add a b) = evaluate a + evaluate b
19:14:22 <nand`> so evaluate automatically gets the type of (Num t) => Math t -> t
19:14:25 <ddarius> The point is that you can also define -other- things, and not all of them require the type parameter to be an instance of Num.
19:14:53 <nand`> But the thing is, now suppose I write a function that uses evaluate internally. Since evaluate has a constraint of Num, and this function uses evaluate, doesn't it also get the constraint for that particular data type?
19:15:19 <nand`> I can see what you mean if I was going to write something that is completely unrelated to calculation, like “length” to report the number of operations
19:15:25 <ddarius> nand`: Yes, that's fine.  If you use eval on the Math type, the type parameter n will need to be an instance of Num.
19:15:26 <SirFrancisDrake> It does, but why should you?
19:15:46 <nand`> But in this case, I wouldn't have to deviate from the calculation
19:15:53 <ddarius> nand`: You don't need to do anything to have that happen.  Adding it to the constructors is superfluous and limiting.
19:16:04 <nand`> I suppose
19:16:35 <ddarius> For example, you can't make a Functor instance with that Num constraint even though it may well be useful to fmap show as an intermediate in pretty-printing expressions (which doesn't require a Num constraint to do.)
19:16:40 <nand`> Well, it served as an example in this case so the type definition was more obvious in its execution (ie. I was making clear that n is a number and not a string or something else)
19:16:44 <nand`> that's why I added it, in particular
19:16:58 <nand`> I do remember reading to keep type definitions clear of constraints
19:17:02 <nand`> I'll try to remember it while coding
19:17:20 <ddarius> nand`: It shouldn't be something you need to "remember."  Just forget that you can do that at all.
19:18:25 <ddarius> That "feature" was added when seq was in a class and so using strict data constructors required adding that to the context of the constructors.
19:18:30 <ddarius> Now it serves no purpose at all.
19:20:25 <nand`> By the way, is there a reason the data constructors for Infinity and NaN are not made public?
19:21:02 <ddarius> There are no data constructors for those.
19:21:13 <nand`> well, the value itslef
19:21:43 <ddarius> Double's aren't required to be IEEE754 floating point.  Also 0/0 is the standard way to get a NaN.
19:24:47 <ccc> cd /var/log
19:35:02 <danharaj> Hey, lispy, are you there? I'm getting a bizarre error with the opengl library and it doesn't make sense. I rebuilt a library and now it fails because at some point an unsafeCoerce raises a type error.
19:36:49 <hpaste> “Dan Haraj” pasted “opengl error” at http://hpaste.org/48902
19:37:14 <hpaste> “Dan Haraj” pasted “opengl error” at http://hpaste.org/48903
19:37:23 <danharaj> ...
19:37:28 <danharaj> hpaste is truncating my paste.
19:38:07 <danharaj> ah well that's the gist of it.
19:38:40 <luite> whoah it has line numbers now :p
19:39:27 <ozataman> is there a line one can add to the .cabal config file to --hyperlink-source when generating documentation automatically during cabal-install?
19:40:10 <danharaj> That error doesn't make any sense to me. It practically contradicts itself.
19:40:21 <danharaj> It arises from an unsafeCoerce. How can unsafeCoerce fail to type check!
19:42:37 <Jafet> ozataman: to print source code with HsColour and then hyperlink the documentation to it?
19:43:02 <ozataman> Jafet: well, you know you can set Documentation:True in your .cabal, which is great. but by default, it doesn't hyperlink-source
19:43:28 <Jafet> It doesn't print source, either
19:43:59 <Jafet> What I ended up doing was to write a shell script to do it retroactively
19:46:01 <Jafet> Perhaps dcoutts knows a better way to do it.
19:46:53 <Jafet> ozataman: http://hpaste.org/47364/kludge_what_kludge
19:47:36 <luite> whoah
19:47:44 <luite> I'd expected 1 or 2 lines
19:47:51 <ozataman> Jafet: cool, thanks :)
19:48:50 <danharaj> It seems that my error only occurs with cabal-dev
19:48:54 <danharaj> I must have messed something up with it.
19:49:15 <luite> danharaj: I've had similar errors when packages depended on different versions of a package indirectly
19:49:52 <danharaj> luite: Hmm, that seems plausible. I installed these packages all at once though. That's confusing.
19:49:54 <parcs> alias ci='cabal install --hyperlink-source'
19:50:54 <kmc> danharaj, maybe unboxed types?
19:50:57 <Jafet> Oh boy, a secret button
19:51:20 <kmc> iirc there's unsafeCoerce and unsafeCoerce#
19:52:40 <kmc> @hoogle unsafeCoerce
19:52:40 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
19:52:59 <Jafet> :t unsafeCoerce
19:52:59 <lambdabot> Not in scope: `unsafeCoerce'
19:53:21 <Jafet> Er, :t doesn't show kinds anyway
19:54:00 <luite> unsafeCoerce = unsafeCoerce#
19:54:22 <danharaj> kmc: I think it's version mismatching, but that's still strange.
19:54:28 <danharaj> I probably messed up my build environment somewhere.
19:54:32 <kmc> well there's no type syntax for 'type variables which are required to be instantiated at unboxed types'
19:55:02 <kmc> polymorphism and unboxed types don't generally work together
19:55:15 <kmc> but i think some of GHC's primitives break that rule
19:56:15 <monokrome> msieradzki: Ohai.
19:56:31 <monokrome> BetchadidntknowIwasinhere.
19:56:47 <luite> monochrom / monokrome ?
19:57:22 <monokrome> Nope.
19:57:26 * monokrome gets that a lot in #haskell
19:57:55 <luite> hehe what did you expect, stealing someones name ;p
19:58:45 * monokrome tries to count how many years he's been using this one, and makes note that he owns the domain http://monokro.me
19:59:04 <Jafet> @quote monokrome
19:59:05 <lambdabot> No quotes match. Just try something else.
19:59:05 * monokrome goes to Google, types monokrome, and sees a bunch of his stuff...
19:59:14 <monokrome> Pretty sure I didn't steal anyone's name :)
19:59:19 <Jafet> @quote monochrom
19:59:19 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
20:00:13 * monokrome doesn't get it.
20:00:50 <dmwit> It's from the famous musical, The Von Trapp Family Singers, I think.
20:01:20 <dmwit> http://www.youtube.com/watch?v=qbMcEbJ9J8Q
20:02:02 <dylukes> Wheres monochrom when you need him. it'll be lulzy to see the two conflict.
20:02:11 <dylukes> Besides, it's funny when monochrom chastises all the dans.
20:02:14 <dylukes> Now he has his own duplicate.
20:03:03 <Jafet> Just do an unamb monochrom monokrome
20:03:03 * monokrome was confused because he had thought that this had provided some sort of insight regarding how he'd "stolen" monochrom's name
20:03:16 <kmc> Jafet, :)
20:03:23 <monokrome> ha
20:08:01 * hackagebot husk-scheme 3.1 - R5RS Scheme interpreter program and library.  http://hackage.haskell.org/package/husk-scheme-3.1 (JustinEthier)
20:08:03 * hackagebot GenericPretty 0.1.1 - A generic, derivable, haskell pretty printer.  http://hackage.haskell.org/package/GenericPretty-0.1.1 (RazvanRanca)
20:08:32 <dankna> the English title is "The Sound of Music"
20:16:19 <SirFrancisDrake> an amazing movie
20:16:31 <dankna> yes
20:22:27 <bobzhang> hi, how could i write `getContents`(*lazy* io) api in haskell itself?
20:22:29 <bobzhang> thanks :)
20:25:27 <Jafet> I don't think you can; GHC implements it with unsafeInterleaveIO
20:26:35 <bobzhang> Jafet: thanks, en,but I can do this very easy, in ocaml or f#, right?
20:27:04 <Jafet> I don't know about OCaml or F#.
20:37:51 <kmc> bobzhang, do ocaml and f# support lazy lists at all?
20:38:14 <kmc> i mean implicit laziness like Haskell has
20:39:50 <kmc> you can always pass around [() -> Char] but you can do that in Haskell too
20:41:27 <kmc> bobzhang, anyway, you can implement unsafeInterleaveIO with unsafePerformIO and that's in Haskell 2010 (and in a ratified addendum to Haskell 98)
20:41:39 <cmccann> bobzhang, no, impure languages let you drop side effects everywhere and make as much of a mess as you want. unsafeInterleaveIO is still more constrained and tractable than that.
20:42:20 <kmc> cmccann, I don't agree; I think unsafeInterleaveIO is nearly as bad
20:43:06 <kmc> at least from a "restricting side effects" perspective
20:43:07 <cmccann> kmc, I'm not a fan of it personally but it's still much better than arbitrary side effects :T
20:45:32 <kmc> unsafePerformIO is also type-unsafe due to polymorphic references
20:45:50 <kmc> i don't think unsafeInterleaveIO has that problem
20:45:53 <cmccann> you still have the benefits of effect tracking in the interleaved portion, you just end up with ostensibly pure functions being able to influence when things happen, which is not the same as causing arbitrary effects
20:46:03 <cmccann> at least, as far as I understand it
20:46:25 <kmc> they can influence *whether* things happen
20:46:39 <kmc> and the relative ordering
20:46:48 <kmc> and therefore the results
20:46:58 <cmccann> yes, but not the internal ordering or which things happen
20:47:12 <kmc> unsafeInterleaveIO used the wrong way will make your program bizarrely nondeterministic
20:47:55 <kmc> it seems not a lot better to me
20:47:55 <cmccann> kmc, but not in a way observable from pure code, I believe
20:48:13 <kmc> well in a sense there is no "pure code"
20:48:21 <kmc> your program is 'main'; main is an IO action
20:48:45 <ivanm> any suggestions for operators that would look like actual Dot edge symbols ("->" and "--") ? Axman6 said ==> and ===, and I thought of --> and <-> ...
20:49:00 <kmc> but i can use unsafeInterleaveIO to make a function of type Int -> Int which acts like (+1) unless you seq some 'unrelated' variable first, in which case it acts like (+2)
20:51:59 <kmc> you have to make your poisonous side-effect-hiding thunks in IO
20:52:05 <cmccann> kmc, yeah, but it's convoluted to do that if I remember correctly, and I don't think there's any way to make the different visible without using IO
20:52:07 <kmc> but you can pass them anywhere and there are no other restrictions
20:52:19 <cmccann> I dunno, I never use it so I don't really recall :P
20:52:23 <kmc> there is no way to use unsafeInterleaveIO without involving IO
20:52:27 <kmc> that much is clear from its type
20:52:34 <Axman6> kolmodin: are you around?
20:54:16 <ivanm> preflex: seen kolmodin
20:54:17 <preflex>  kolmodin was last seen on #haskell 84 days, 18 hours, 31 minutes and 10 seconds ago, saying: :)
20:54:20 <ivanm> :o
20:54:21 <cmccann> kmc, the main thing I'm getting at is that I don't think you can do anything to get a function like (\f x -> f x == f x) :: (Int -> Int) -> Int -> Bool to return False no matter what you do with unsafeInterleaveIO
20:54:28 <ivanm> he's been on #gentoo-haskell more recently
20:54:40 <kmc> hmm
20:54:44 <ivanm> Axman6: it's about 6 in the morning for him IIRC
20:54:48 <kmc> i'll think about that cmccann and let you know if i think of a way :)
20:54:48 <kmc> bbl
20:55:07 <Axman6> :\
20:55:19 <cmccann> kmc, if you can find a way that'd be a very interesting result! so have fun.
20:55:24 <ivanm> Axman6: nickserv says he was last online 4 days ago though
20:55:42 * cmccann would be happy to have more reasons to frown on unsafeInterleaveIO
20:56:36 <bobzhang> kmc: lazy list is very easy to implement in ocaml. I found in haskell, it's hard to traverse a directory lazily while very easy in ocaml
20:57:52 <bobzhang> i know there are some work around, but not beautiful
20:57:52 <ivanm> bobzhang: uhhh, how is it hard? lazy I/O + lazy lists should make it _very_ easy...
21:00:13 <bobzhang> ivanm, am i wrong? can you show a tiny program
21:00:28 <bobzhang> maybe you misunderstand my point
21:00:30 <ivanm> don't have one floating around
21:00:43 <ivanm> RWH has a chapter that includes filesystem traversal IIRC
21:00:49 <ivanm> and there's a library that deals with it
21:00:53 <bobzhang> i read it
21:01:00 <bobzhang> it's a walk around
21:01:29 <bobzhang> sorry *work around*
21:02:03 <ivanm> work  around for what?
21:02:18 <ivanm> get the directory contents (returns IO [FilePath] IIRC)
21:02:31 <cmccann> bobzhang, lazy IO isn't really the best thing to be using anyway
21:02:32 <ivanm> get the actual values from there that you want
21:02:34 <ivanm> recurse
21:02:43 <bobzhang> yeap, getDirectoryContents is lazy?
21:02:53 <ivanm> pretty sure it i
21:03:03 <ivanm> well, it returns a list which is lazy...
21:03:26 <ivanm> but I don't think it's lazy in the sense that "I can add a file later on and it will magically appear in the results of getDirectoryContents that I called earlier"
21:05:56 <bobzhang> wow, I don't think it is lazy, otherwise the later _Iterator_ example is unnecessary, right
21:06:04 <bobzhang> ?
21:07:50 <SirFrancisDrake> if I want to change show declaration on Array, is there a valid way that would work with print / show equally, aside from making a data A = Array, instance Show A etc.?
21:08:32 <Axman6> make a new function, showArray
21:08:48 <SirFrancisDrake> and when I want to say print, I can't
21:09:55 <Axman6> printArray = putStrLn . showArray
21:11:22 <SirFrancisDrake> hey, I didn't mean I can't print it on screen. I meant, if I make a showArray fn, I have to care every time I'd like to show an array and mind the custom showing function. Instead of just printing it, like any other data
21:12:08 <SirFrancisDrake> I'm not saying making a new data type sucks, just curious whether there's a more elegant way of not caring
21:12:12 <Axman6> is adding Array to print really that much of a change though?
21:12:28 <SirFrancisDrake> every time?
21:12:35 <ddarius> SirFrancisDrake: What's wrong with the existing instance?
21:12:45 <cmccann> keep in mind that the Show class really isn't supposed to be used for pretty printing and such
21:13:28 <cmccann> if you want "nice" display that doesn't produce output that looks basically like Haskell code to construct the value, you should probably use something else
21:13:43 <cmccann> not that people don't misuse show all the time, but eh
21:14:11 <SirFrancisDrake> cmccann: like, make a FancyShow typeclass?
21:14:40 <cmccann> "pretty print" is the standard term. I think Ppr is an abbreviation I've seen?
21:14:42 <parcs> is there a case for having a show instance but no read instance or vice versa
21:15:46 <ddarius> There are plenty of Show instances without Read instances.
21:16:45 <SirFrancisDrake> ddarius: I'm writing a small text game. The game field happens to be an array, and standard show isn't fancy enough
21:17:02 <SirFrancisDrake> cmccann: thanks
21:17:23 <parcs> @instances Show
21:17:24 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
21:17:26 <parcs> @instances Read
21:17:27 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
21:17:44 <shachaf> Is there a reasonable way to download all of (the latest versions of packages on) Hackage? How big would it be?
21:18:04 <luite> 150MB
21:18:11 <luite> there's a tar file
21:18:24 <shachaf> Oh.
21:18:34 <shachaf> Oh, so there is.
21:18:43 * shachaf missed it for some reason.
21:19:04 <parcs> hackage should be rsyncable
21:21:37 <ddarius> Make a user filesystem that presents a web site as a file tree.
21:22:01 <shachaf> ddarius: ls is a bit tricky.
21:22:19 <shachaf> Well, depending on what sense that was meant in.
21:30:59 <shachaf> luite: Well, it's not 150MB, though. :-)
21:31:42 <luite> how big is it? send some mail to the maintainer of that page :)
21:32:11 <shachaf> Clearly page should compute the size dynamically on every load.
21:45:07 * edwardk waves hello.
21:45:13 <edwardk> preflex: xseen roconnor
21:45:14 <preflex>  roconnor was last seen on freenode/#haskell 4 hours, 41 minutes and 2 seconds ago, saying: It really seems that (a , [a]) is better
21:46:10 <edwardk> i've been having a lot of fun encoding linearity in terms of the continuation passing style monad, but i wonder if i could so something better.
21:47:36 <edwardk> what i've been doing is encoding linear functionals as functions of the form (a -> r) -> r, being linear functions from a free module over a ring to the ring itself, and linear maps as (a -> r) -> b -> r, using linear mappings between free modules
21:47:49 <edwardk> but the types are too big
21:48:05 <edwardk> i was trying to figure out how to capture the linearity constraint
21:48:15 <kmc> what do the types look like?
21:48:53 <kmc> is this "linear" as in linear types or as in linear algebra?
21:48:58 <edwardk> i'm thinking i might be able to get away with forall m. LeftModule r m => (a -> m) -> b -> m — for linear maps from the vector space r^a -> r^b
21:49:01 <kmc> (or are the two somehow the same for a cool deep reason)
21:49:03 <edwardk> linear as in algebra
21:49:07 <kmc> ok
21:49:20 <etiainen0>  /help
21:49:49 <edwardk> the latter type recovers the original type in the special case that you use the module of a ring over itself
21:50:33 <edwardk> let me point you to code =)
21:51:43 <edwardk> https://github.com/ekmett/algebra/blob/master/Numeric/Map/Linear.hs
21:51:53 <ivanm> is there any way of telling ghc that every line in a do block is of type m () ?
21:52:04 <edwardk> it might be easier to start with https://github.com/ekmett/algebra/blob/master/Numeric/Functional/Linear.hs
21:52:06 <ivanm> my attempt at fancy type-class stuff keeps running into type-checking errors :s
21:52:21 <edwardk> which is similar but doesn't contain the b ->
21:53:37 <edwardk> kmc: does that code make sense?
21:54:06 <edwardk> its just Cont, subject to the condition that the second arrow is linear
21:54:27 * cmccann wonders if it's reasonable to document an associative algebra type class with "sup dawg, herd you like rings so i put a ring over your ring so you can multiply while you multiply"
21:54:35 <edwardk> (a -> r) is a vector space r^a., then we take a vector space over that subject to the restriction of linearity
21:55:48 <edwardk> cmccann: i started playing with hopf algebras, so we may get a chance soon ;)
21:55:48 <edwardk> https://github.com/ekmett/algebra/blob/master/Numeric/Algebra.hs
21:56:12 <cmccann> edwardk, :D
21:56:21 <edwardk> in particular, up until now i've been trying to model just the monoid ring or the group ring, but i need more structure to my coalgebras
21:56:42 <edwardk> in order to be able to encode chebyshev polynomial multiplication using the same plumbing
21:57:34 <cmccann> edwardk, so when are you going to wrap all this stuff you've written up with a bow and make a replacement Prelude out of it?
21:57:54 <edwardk> cmccann: not likely to try again =)
21:59:40 <kmc> edwardk, are you working on a new numeric Prelude?
21:59:46 <kmc> oh, cmccann just asked that
21:59:52 <edwardk> i really do like this way of programing with covectors though
21:59:52 * kmc kicks scroll bar
21:59:57 <kmc> which one did you try before?
22:00:06 <edwardk> nah, just want a crapton of numerical classes for something else i'm working on
22:00:42 <cmccann> oh well, heh. one of these days I'm going to end up turning my pile of poorly-thought-out personal utility libraries into a Prelude replacement and then nobody else will ever want to use my code
22:00:48 <edwardk> i had a little toy package i was working on called Abstract for a while. i never packaged it, this was about 4-5 years ago
22:00:56 <cmccann> I keep hoping someone will make a sane alternate prelude before then and save me the headache :P
22:01:14 <edwardk> i figured the Abstract sits somewhere around the area of the Prelude, but is er.. a bit more abstract
22:01:43 <edwardk> it did help me learn a lot of ghc internals though
22:02:59 <cmccann> in other news, I think that with superclass equalities I could theoretically do whatever type hackery I want using only a single fundep
22:03:37 <kmc> what did you need internals for edwardk?
22:04:10 <edwardk> kmc: well, it didn't build on any of the prelude classes ;)
22:05:09 <edwardk> kmc: so i spent a fair bit of time hunting around trying to figure out where the implicit glue was for some classes like the enum plumbing for [1,3..5]
22:05:21 <kmc> ah
22:05:24 <edwardk> which don't yield to rebindable syntax (or didn't at the time)
22:05:34 <kmc> really?
22:05:44 <edwardk> it wasn't in the explicit list
22:06:19 <edwardk> cmccann: there was a paper on that topic actually
22:06:28 <kmc> cmccann, which fundep do you still need?
22:06:28 <cmccann> edwardk, ooh, which?
22:06:52 <edwardk> cmccann: its been a while, but it was probably Hinze, something on a Sat class
22:07:11 <edwardk> cmccann: i read it years ago
22:07:16 <edwardk> so its a bit fuzzy
22:07:19 <cmccann> kmc, the one on the delayed-resolution overlapped instance in the middle of Oleg's TypeEq
22:07:42 <cmccann> the other TypeEq classes can be replaced with type families, and TypeCast can be thrown out entirely
22:07:48 <edwardk> does that still compile?
22:08:08 <cmccann> edwardk, which "that"?
22:08:13 <edwardk> TypeEq
22:08:23 <kmc> cmccann, oh, that hack ;)
22:08:26 <cmccann> yeah, I was just messing with it earlier today
22:08:28 <edwardk> haven't used it in a long time
22:08:47 <edwardk> ah k
22:09:02 <cmccann> the TypeCast class is no longer necessary, can remove it and replace (TypeCast a b) with (a ~ b), which is all it ever was in the first place
22:09:50 <cmccann> but there's obviously no way around overlapping instances/fundeps for TypeEq :[
22:10:42 <cmccann> But given TypeEq, everything seems to still work, including sticking stuff using TypeEq into the context of type family stuff
22:11:19 <cmccann> though there seemed to be some peculiarities about when it would pick up the context and thus coerce the type bool to what it should be
22:13:28 <cmccann> didn't spend enough time on it to be sure whether the peculiarities mattered, or if it was an artifact of testing code that wasn't actually using the type for anything
22:15:46 <ivanm> how can I have a type class "Foo a b | a -> b" which would let me have the two instances "Foo (Bar c) c" and "Foo d d" ?
22:16:25 <ivanm> (or else using TFs)
22:16:45 <cmccann> doesn't that violate the fundep?
22:17:03 <ivanm> yeah :s
22:17:32 <cmccann> anyway, definitely not allowed with type families, which cut out all the nonsense with overlapping entirely
22:18:05 <cmccann> might be able to coax it out of GHC using delayed resolution of instances, as in a lot of Oleg's type hackery
22:18:16 <ivanm> but I'm trying to work out some way of having "a -> b -> c" represent [(a,b), (b,c)] and I thought that using a type class like this
22:18:35 <ivanm> specifically, the class has a method: foo :: a -> Bar b
22:19:14 <Axman6> would a function that allocates memory, uses it, then frees it still be considered pure?
22:19:51 <shachaf> Axman6: That's pretty common behavior for functions. :-)
22:19:54 <cmccann> Axman6, pretty sure pure functions cause allocation all the time :P
22:20:13 <Axman6> sure, but i mean ones that say explicitly use malloc and free
22:20:30 <shachaf> Sure, I suppose, if you can prove that it is.
22:20:51 <cmccann> Axman6, pretty close to the sort of thing ST does, isn't it?
22:20:56 <Axman6> yeah
22:21:13 <Axman6> I've been talking in #llvm about it, and they seem to think it's not (well one person does)
22:21:52 <ivanm> cmccann: any suggestions which bit of Oleg's hackery?
22:22:12 <shachaf> Axman6: Why not?
22:22:31 <Axman6> well he said not unless it's a stack allocation
22:22:36 <cmccann> ivanm, my suggestion would be to not try and do that, honestly. why not make the type be foo :: a -> b and put the Bar output into the type function?
22:23:32 <ivanm> lemme paste up my code
22:23:35 <cmccann> Axman6, pure functions cause allocation via the runtime, ergo it's possible for a pure function to allocate and free memory and still be pure. If it did the exact same things the runtime would do, it would still be as pure as otherwise.
22:23:55 <Axman6> yeah, that's my thinking too
22:24:08 <cmccann> proving that it does in fact behave appropriately may or may not be feasible, but that's another question
22:25:02 <hpaste> ivanm pasted “An attempt at type-class hackery” at http://hpaste.org/48904
22:25:16 <ivanm> cmccann: ^^
22:25:37 <ivanm> specifically, Bar == EdgePairs and Foo == FromRight
22:25:46 <cmccann> hm
22:25:52 <Axman6> cmccann: the argument is that malloc and free have global state, that would be modified
22:26:05 <ivanm> "error: use better pragmas" <-- what does hlint have against my pragmas?
22:26:06 <Axman6> free(malloc(5)) changes the world basically
22:27:12 <ivanm> @tell chrisdone when using stepeval on hpaste, before you enter an expression to evaluate it says: "Error: Parse error: EOF"
22:27:13 <lambdabot> Consider it noted.
22:27:27 <cmccann> Axman6, evaluating pure functions draws power, generates heat, consumes processor resources, etc.
22:27:44 <cmccann> those all change the world, too
22:28:01 <Axman6> yeah... but the point about the internal state of malloc and free is kind of relevant
22:28:16 <ziman> GC has its state as well.
22:28:17 <Axman6> but, even stack allocations change a global state, the stack pointer
22:29:43 <cmccann> a function being "pure" has nothing to do with the ways in which evaluating it affects the outside world, although many ways of being impure do involve affecting the world
22:32:25 <Jafet> sum [1..10^12] is rather impure
22:32:51 <cmccann> ivanm, I'm leaning toward "probably not going to work with type families", for what that's worth
22:33:16 <ivanm> yeah, I had just switched to that from MPTCs+FDs just to see if it magically worked :/
22:33:28 <kmc> Axman6, that's why unsafePerformIO is in FFI
22:33:48 <Axman6> yeah
22:33:49 <kmc> unsafePerformIO . alloca $ \ptr -> do ...
22:33:52 <cmccann> ivanm, you're basically writing a default fallthrough instance, which is the classic example of using overlapping instances
22:33:58 <cmccann> which aren't allowed with TFs, full stop
22:34:03 <ivanm> *nod*
22:34:16 <ivanm> but it didn't work with MPTCs+FDs, and by all accounts shouldn't
22:34:37 <ivanm> (found an email by SPJ saying that module superclass equalities, MPTCs+FDs == TFs)
22:34:46 <ivanm> *modulo
22:35:06 <cmccann> ivanm, TF = MPTC+FD, but overlapping instances are another issue
22:35:12 <cmccann> which can only be used with the latter
22:35:20 <ivanm> no, this said you shouldn't be able to do them either
22:35:36 <ivanm> http://lambda-the-ultimate.org/node/4031
22:36:15 <cmccann> well, there has been some talk of getting them under control and preventing some of the more questionable behavior they had, including some of the stuff Oleg used to do fancy tricks
22:36:28 <Axman6> cmccann: in #llvm, we've come to the conclusion that it highly depends on the implementation of malloc and free.
22:37:28 <cmccann> Axman6, that's a reasonable conclusion, since proving that a function doing allocation is pure entails proving that malloc and free are also pure used in that way, which clearly depends on their implementation to some extent
22:37:48 <cmccann> if your implementation of malloc beeps the PC speaker everytime it's called, well, your allocating function is never going to be pure
22:38:57 <Axman6> cmccann: and obviously malloc can't be pure, it needs some global state to know what it can allocate next
22:39:44 <Jafet> …and the GHC allocator doesn't use any global state!
22:40:16 <Jafet> It allocates blocks from a P2P network
22:40:41 <Axman6> i thought it allocated space in Oleg's brain
22:40:48 <Axman6> for efficient execution
22:42:10 <cmccann> ivanm, anyway, I think a lot of that discussion is about theoretical concerns that may or may not apply to GHC at any point in time, including now
22:42:51 <Jafet> oleg doesn't actually execute any programs. He compiles them and his work is done
22:43:02 <ivanm> cmccann: well, I had a quick skim through oleg's site and didn't see anything that looked relevant (unless you mean something like http://haskell.org/haskellwiki/GHC/AdvancedOverlap )
22:43:46 <cmccann> seeing as how I just verified earlier today that overlaps can still be abused to write TypeEq, which also violates the strictest interpretation of the fundep, you might want to try it
22:44:16 <pen16> Has there been any news in the haskell-records-can't-have-conflicting-names front in the past 2 yrs?
22:44:20 <cmccann> your case should actually be a pretty simple example of overlapping
22:44:46 <kmc> pen16, http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#disambiguate-fields helps a little
22:44:57 <ivanm> cmccann: I take it back, it _does_ work... but I can't just do "9 --> 3 $$ [A]", I need to specify the type of 9 and 3 :/
22:45:02 <pen16> how recent is that kmc?
22:45:32 <cmccann> ivanm, yeah, overlapping with fallthrough instances tend to stumble with polymorphic types
22:45:55 <ivanm> *sigh*
22:45:58 <cmccann> in practice the type inferencer will catch constraints so you don't need to nail down the types everywhere
22:46:04 <ivanm> which kind of gets rid of part of what I was hoping for :/
22:46:59 <cmccann> it should still work well for the most part, it can just be a bit touchy about polymorphic types depending on how it's used
22:47:22 <ivanm> since the _real_ version of this goes to a Writer-based Monad, and I abused the Num typeclass so that "0 [A]" would create a node in the graph :/
22:47:51 <kmc> don't know pen16
22:48:33 <kmc> cmccann, i don't think you can violate f x == f x using unsafeInterleaveIO
22:48:47 <cmccann> ivanm, you're firmly in the territory of things that aren't really supported well, so yeah, sometimes it works, sometimes it doesn't, sometimes you can trick it into working with some weird gymnastics, hard to say
22:48:54 <kmc> but you can violate (x == y `seq` x), which is arguably more fundamental
22:48:56 <ivanm> cmccann: it's bad enough that I need to define that $$ operator :/
22:49:15 <cmccann> ivanm, point is, here there be dragons, so grab your type-level sword and have at if it's important
22:49:26 <ivanm> heh
22:49:30 <cmccann> but it's always going to be a headache, I suspect
22:50:16 <cmccann> kmc, oho, really? Do you have a working example of that expression evaluating to False?
22:50:35 <kmc> and you can write your own seq for individual data types, so you aren't relying on magicality of seq
22:51:32 <kmc> i will try to write one
22:52:01 * cmccann would be interested to see it
22:52:16 <kmc> you definitely lose the ability to treat those expressions as denotationally equivalent
22:52:41 <kmc> you lose equational reasoning and that's the important part imo
22:52:56 <cmccann> probably heading out shortly, though. want to email me any particularly interesting tricky examples you find?
22:53:04 <kmc> i'll see you on IRC later
22:53:13 <cmccann> 'k
22:53:29 <cmccann> I'd love to have some nice snappy examples of unsafeInterleaveIO doing weird things
22:54:49 <cmccann> to go with my example adapted from someone else's code on -cafe, where inserting an element into a Data.Set.Set causes another, non-equal element to seemingly vanish :D
22:55:24 <cmccann> (which is about type class laws, not unsafeInterleaveIO, that is)
22:55:41 <kmc> http://hpaste.org/48905
22:56:08 <kmc> that code prints (0,2) but switching to the other print statement makes it print (2,1)
22:58:26 <kmc> er you don't need to import 'evaluate' either, that's left over from previous hacking :)
22:58:55 <cmccann> kmc, hm, each thunk is still only forced once though, so while you can different results by switching them, you'll get consistent results in any single run of the program
22:59:11 <kmc> define "consistent"
22:59:23 <cmccann> which is the same sort of dodgy behavior Oleg demonstrated a while back, though I think this is simpler than I recall his example being
22:59:35 <kmc> oh, do you have a link?
23:01:14 <kmc> anyway it's bad that switching "show (x,y)" to "show (y,x)" in one part of your program can make a completely different part misbehave
23:01:57 <kmc> if you can't use equals-for-equals reasoning then you've already lost much of the point of using Haskell
23:02:17 <cmccann> kmc, agreed, but it's not as bad as having the value of x or y change while the program is running
23:03:22 <cmccann> kmc, here: http://www.haskell.org/pipermail/haskell/2009-March/021064.html
23:03:55 <cmccann> Oleg's is more convoluted, but he's also doing it with IORefs and using just hGetContents
23:04:54 <cmccann> er, without IORefs, rather
23:07:19 <cmccann> anyway, I'd still love to see an example that shows misbehavior without needing to switch a line of code around and recompile, but I'm not sure if that's possible
23:10:50 <kmc> oleg's example is more compelling overall
23:11:07 <kmc> "We conclude that extolling the purity of Haskell and advertising lazy IO is inconsistent."
23:11:37 <cmccann> I think Oleg was engaging in a bit of showmanship with that :]
23:11:45 <cmccann> though I obviously tend to agree
23:11:55 <kmc> i'd say the last line is the showmanship :)
23:13:19 <cmccann> anyway, as far as I know there's still a limit to what unsafeInterleaveIO can mess up, i.e. what I said about switching lines and recompiling.
23:13:25 <kmc> yeah
23:13:31 <kmc> this is an interesting distinction to notice
23:14:18 <cmccann> if it misbehaves reliably given a particular binary and particular run of the program, that's strictly more tolerable than misbehaving in ways that are obvious at run-time
23:17:49 <cmccann> so I put unsafeInterleaveIO in the same category as stuff like overlapping instances; sorta sketchy, can definitely cause unintuitive nonlocal effects when doing what should be trivial refactoring, but once you've compiled the program probably no longer a concern
23:18:35 <cmccann> I would be very, very interested to see either of those demonstrated to be a bigger problem than that, and I suspect the GHC team would be interested as well :]
23:23:04 <cmccann> kmc, while I personally tend to agree with some of the more hardline stances about disreputable denotational shenanigans, I do have to acknowledge that there are different degrees of severity here
23:23:05 <kmc> cmccann, recompiling is not necessary to get bad behavior
23:23:13 <kmc> a simple conditional will do
23:23:44 <cmccann> kmc, yeah, though I expect that a dependence on external input is required
23:23:53 <args0> guys how do you compare F# to Haskell? seems similar to me(?)
23:23:54 <cmccann> which is another significant boundary
23:24:18 <ivanm> cmccann: OK, turns out that another bit of type hackery I was hoping to have working (being able to have "0 [...]" be parsed as a node) doesn't work, due to not being able to determine which type you're using for the number :/
23:24:42 <kmc> cmccann, so i can accidentally write a program where passing "--verbose" changes the output
23:24:46 <kmc> seems pretty bad
23:24:48 <cmccann> ivanm, type hackery and polymorphic types really don't play well together, this is pretty universal I'm afraid
23:24:56 <ivanm> yeah :s
23:25:22 <cmccann> kmc, but better than it changing its output for no reason at all!
23:25:43 <ivanm> and even with this stuff that _is_ working... I might end up scrapping it, as the only reason it's there is for multi-edges
23:26:08 <kmc> cmccann, I agree there are degrees here, but I'd put both degrees in the "actually quite bad" category and not the "sorta sketchy" category you described
23:26:10 <ivanm> if I just leave it as only working with singleton edges, then there's none of this defaulting stuff needed...
23:26:38 <kmc> cmccann, that is, I think the degree of care needed to use unsafeInterleaveIO and Not Fuck It Up is close to the degree of care needed to use unsafePerformIO correctly
23:27:21 <kmc> the technical distinction you noticed is real (and interesting, thanks for pointing it out :) but does not have much effect on the "safety" in that sense
23:27:40 <cmccann> kmc, well, giving a program different input is a perfectly reasonable excuse for it to give different output, so that doesn't inherently bother me that much alone. It's the way it impacts restructuring the program that concerns me.
23:28:50 <kmc> it bothers me a lot, as a programmer, not a user
23:28:52 <cmccann> kmc, again, you don't need to persuade me that it's unwise. I'm being picky because I want to delineate exactly how it causes problems
23:29:44 <cmccann> and I was encouraging you to play with it because I'd really LOVE to have more examples of how it can cause problems
23:29:46 <kmc> if i import a library which uses unsafeInterleaveIO it may break my perfectly reasonable implementation of --verbose, introducing heisenbugs
23:30:30 <kmc> (the standard IO library is an example of such a library)
23:30:31 <kmc> i don't have to do any restructuring in my code to get bit by this
23:30:35 <cmccann> ooh, that's a good idea. I wonder what kind of interactions could be obscured behind imports? can you make two modules look and behave sensible alone, but create issues when used together?
23:31:19 <cmccann> stuff like the lazy IO functions are misleading in some ways, but they are what they are.
23:32:13 <cmccann> ivanm, yeah, I honestly suspect that the type hackery route you're on right now is going to stay impractical
23:33:30 <cmccann> ivanm, so it might be a good idea to take a few steps back and reconsider the design that led to trying it :I
23:34:08 <kmc> Haskell is not a great language for playing tricks like that with concrete syntax
23:34:08 <ivanm> oh, I know the design I've done
23:34:24 <ivanm> I'm trying to emulate Dot code for graphs as much as possible in Haskell as a DSL
23:34:31 <kmc> your users will hate you
23:34:42 <ivanm> if I drop support for multi-edges, I can drop that
23:34:51 <kmc> writing "f 0 [1,2,3]" is not worse than writing "0 [1,2,3]"
23:35:10 <cmccann> ivanm, almost hate to say it, but have you considered switching to TH for your metaprogramming hackery?
23:35:16 <cmccann> that's really the sort of thing it's there for
23:35:20 <ivanm> not really
23:35:35 <kmc> at best writing "0 [1,2,3]" will piss me off every time
23:35:39 <ivanm> kmc: the point is to have it look as identical as actual Dot code as possible
23:35:45 <kmc> at worst it gives me some incomprehensible type error
23:35:52 <ivanm> but yeah, that bit fails completely
23:35:54 <kmc> ivanm, i know that's the point.  but it's a bad idea.
23:36:23 <kmc> that is Not How Haskell Works
23:36:44 <cmccann> ivanm, I'd recommend either sticking some infix combinators here and there to avoid the type hackery, or just use TH and go wild
23:36:52 <kmc> ivanm, do you know any of the Lisps? how do you feel about that language family?
23:37:00 <cmccann> parse actual real Dot code in a quasiquoter if you want
23:37:18 <kmc> yeah, that would be nice
23:37:42 <cmccann> I think it's worth noting that people use <$> and <*> a lot, but not McBride's terrifying type hackery to fake idiom brackets
23:38:20 <hpaste> ivanm pasted “Sample Dot monad interface” at http://hpaste.org/48906
23:38:24 <ddarius> At any rate, trying to get "as close as possible" just creates confusion for everyone.
23:38:25 * hackagebot fresh 0.1.0 - Introduce fresh variables into Haskell source code  http://hackage.haskell.org/package/fresh-0.1.0 (DavidLazar)
23:38:47 <ddarius> This is why language implementations should -really- provide their parser as a library.
23:38:53 <kmc> ivanm, with a quasiquoter you can make it work in both pattern and expression context, and you can allow "holes" for arbitrary Haskell expressions
23:39:11 <ivanm> I don't know if I'll get it to that stage...
23:39:19 <kmc> so I can say [dot| LR_0 -> LR_1 [ label = $x ] |] if x :: String is in scope
23:39:27 * hackagebot operational 0.2.0.2 - Implement monads by specifying operational semantics.  http://hackage.haskell.org/package/operational-0.2.0.2 (HeinrichApfelmus)
23:39:53 <ivanm> ddarius: well, graphviz _has_ a parser... but I inherited this one, and writing C bindings has license implications
23:40:19 <cmccann> ivanm, have you ever done anything with yesod? it's got a bit of a TH overdose, but it's pretty effective for demonstrating some practical value you can get by doing things that way
23:40:25 <kmc> i'm really not okay with allowing both "a --> b" and "a --> b --> c"
23:40:29 <ivanm> kmc: heh, I'll put it on my TODO list as something to consider at some future point :p
23:40:36 <ivanm> cmccann: nope, don't really do web stuff
23:40:38 <danharaj> I think the Yesod approach is
23:40:41 <danharaj> "Embed all languages!"
23:40:45 <ivanm> danharaj: heh
23:40:52 <ivanm> kmc: yeah, I think I'm going to drop that
23:41:41 <kmc> my three objections are a) your syntax is not actually dot syntax, b) dot syntax is not actually fabulous, c) your syntax is bad if you drop "look vaguely like dot syntax" as a constraint
23:42:13 * cmccann is kinda ambivalent about some of the design of yesod, but the error-checking benefits of the egregious TH abuse are pretty clear-cut
23:42:28 <ivanm> kmc: well, I'm trying to embed something like dotgen into graphviz
23:42:53 <kmc> if TH were less clunky we might not classify any library which makes heavy use of it as "egregious TH abuse"
23:43:10 <kmc> ivanm, what's dotgen?
23:43:24 <cmccann> on the bright side, it's less horrifying than augustss's BASIC monad :D
23:43:29 <kmc> yes
23:43:36 <ivanm> @hackage dotgen
23:43:36 <lambdabot> http://hackage.haskell.org/package/dotgen
23:43:38 <kmc> i assume this one is not a joke, though
23:43:41 <ivanm> @hackage graphviz
23:43:41 <lambdabot> http://hackage.haskell.org/package/graphviz
23:43:44 <ivanm> ^^ my library
23:44:15 <kmc> yeah
23:44:27 <kmc> dotgen looks like a reasonable API
23:44:29 <danharaj> Your version numbers are idiosyncratic.
23:44:31 <kmc> from a quick skim of the haddock
23:44:33 <cmccann> kmc, I gather TH is going to get some love in the foreseeable future, to the tune of making it not as much an unhappy medium between different goals
23:44:40 <ivanm> kmc: note that witih my syntax: the =:= is optional; braces and semi-colons are optional (I put both of them there just to make it look more like Dot)
23:44:47 <ivanm> danharaj: the README has an explanation
23:45:01 <ivanm> kmc: the $$ is a requirement for having multi-edges
23:45:08 <kmc> no it's not
23:45:14 <ivanm> yes it is
23:45:17 <kmc> for example you could have a function named 'edge' and another function named 'multiedge'
23:45:18 <ivanm> I wrote it!
23:45:18 <ivanm> ;-)
23:45:20 <danharaj> ivanm: I don't want to spoil the mystique :p
23:45:36 <ivanm> kmc: OK, let me re-phrase: my usage of $$ there is a direct result of how I tried to do multi-edges
23:45:51 <ivanm> if I remove multi-edges, then I can just do "lr_5 --> lr_6 [ ... ]"
23:46:07 <kmc> seems unlikely to work, precedence-wise
23:46:24 <ivanm> isn't that how (.) works?
23:46:30 <ivanm> oh, right, I see what you mean...
23:46:32 <ivanm> *sigh*
23:46:38 <kmc> anyway, you've not justified your premise here
23:46:38 <ivanm> dammit!
23:46:53 <ivanm> which premise?
23:47:05 <kmc> why is it good to have a library with bad syntax that looks kind of like dot's bad syntax but not really
23:47:33 <cmccann> ivanm, you'd probably also need some of the variadic function style type hackery to make that sort of thing work
23:47:44 <cmccann> which is also a pain and leads to things being touchy and giving strange errors
23:47:55 <ivanm> I currently have two implementations of Dot (Canonical and Generic); Canonical is good for bulk conversions from existing data, Generic is good for parsing random Dot code and importing it
23:48:06 <ivanm> I also have a Graph-like one in the works for manipulating Dot graphs
23:48:38 <ivanm> this was an attempt at cloning dotgen's interface and having something relatively similar to actual Dot code for people to use to embed relatively static Dot code in their Haskell programs
23:48:44 <cmccann> I still say that, if you want dot syntax, a dot-parsing quasiquoter is the only sane approach
23:48:52 <ddarius> Indeed.
23:48:54 <ivanm> cmccann: yeah, which is what I was trying to do
23:49:05 <kmc> ivanm, once again, I understand what you were attempting; I do not understand why
23:49:12 <cmccann> if you're doing it in Haskell directly, make an API that's sensible for Haskell
23:49:25 <ddarius> Otherwise you enter the business of guessing what your users guessed that you might have done.
23:49:39 <kmc> why is "relatively similar to actual Dot code" a design goal?
23:49:48 <ivanm> kmc: you say that dotgen's API looks reasonable; yet it isn't that different from what I have here
23:49:52 <ddarius> Yes, if you want dot syntax, use it exactly.  Otherwise, make a nice interface for specifying graphs in Haskell.
23:50:12 <ivanm> ddarius: this is what I'm trying to do
23:50:30 <ivanm> you don't _have_ to make it look directly like Dot code, but the option is there if you so wish
23:50:37 <kmc> no, it's not
23:50:42 <cmccann> ivanm, doing the sort of weird faux-syntactic magic involved in faking something like dot that really doesn't resemble haskell will almost always lead to fragile code and bizarre errors
23:50:45 <kmc> the option is there to make it look somewhat sort of like Dot code
23:51:56 <kmc> ivanm, dotgen doesn't have any type class hackery
23:51:57 <ivanm> kmc: so how is that different from what I've got?
23:51:57 <cmccann> I recall someone asking augustss about how reliably code using his BASIC monad worked, and he said something to the effect of "it's very good at generating useless errors, much like actual BASIC"
23:52:03 <ddarius> ivanm: A "nice interface for specifying graphs" is a strictly larger set than a "nice interface for specifying graphs that also can look roughly like Dot."  This would be particularly true if the latter set is empty.
23:52:05 <ivanm> kmc: I've already said I'm going to be droping that
23:52:11 <kmc> oh, all of it?
23:52:16 <ivanm> yes
23:52:22 <kmc> you said multi-edges are "some of the type-class hackery"
23:52:36 <ivanm> kmc: the other type is to try and do "0 [...]", but it doesn't work
23:52:37 <kmc> also they don't have any binary infix operators which aren't actually binary
23:52:43 <ivanm> that's all the type-class hackery
23:52:49 <kmc> "x --> y [a, b]" is not going to work
23:52:52 <ivanm> kmc: I'm going to have edge functions as well
23:52:59 <kmc> without your ($$) operator (extra noise)
23:53:14 <ivanm> I'll leave in --> so you can do "x --> y $ [...]" if you so wish
23:53:23 <ivanm> but currently the $$ is needed because of the hackery
23:53:30 <kmc> personally i would write (x --> y) [...]
23:53:33 <kmc> but anyway i think that's fine
23:53:34 <ivanm> this was all done in the past few hours, the API is still really rough
23:53:54 <kmc> also, why 'do' syntax?
23:54:15 <kmc> do you expect anyone to make an action in your monad with result type other than () ?
23:54:34 <ivanm> well, the other option that I can see would be to use a list
23:54:57 <kmc> or any other monoid
23:55:04 <ivanm> right
23:55:07 <kmc> but yeah, lists probably give the best syntax
23:55:27 <kmc> note that I said "best" not "most vaguely resembling Dot's antiquated braces-and-semicolons syntax" ;)
23:55:30 <cmccann> I require sleep now. it's been fun, seeya, folks :]
23:55:34 <kmc> ttyl cmccann
23:55:59 <kmc> ivanm, the main benefit of a monad is that you can carry some state, e.g. for generating fresh names
23:56:15 <kmc> that would be a useful action of non-() result type
23:56:22 <kmc> if you aren't implementing things like that, then i wouldn't bother
23:57:22 <danharaj> So, I have this idea, someone tell me if it's useful.  A free monad is the expression trees of some language determined by the monad. If you have a free monad (Free f) and some other monad m, a function interpret :: (Free f) a -> m a can be seen as an interpreter for the language, where the computation takes place in the m monad.
23:57:40 <ivanm> kmc: I would think that lists would make it more verbose
23:58:15 <ivanm> I did have some vague notion of making it a monad transformer so you could wrap it around IO to gradually build up the Dot graph
23:58:21 <ivanm> but that's not likely
