00:30:55 <sanjoyd> How fast is creating a new array from an old one using // ?
00:31:40 <shachaf> Takes 3 seconds.
00:32:24 <sanjoyd> Seriously; is it O(1) or O(n) or O(Totient(n)) ?
00:33:29 <sanjoyd> Ah, got it.
00:33:33 <sanjoyd> Never mind.
00:33:38 <kmc> it's none of those because asymptotic notation is nearly meaningless on real machines
00:33:42 <kmc> it's not fast, though
00:33:48 <kmc> usually requires a full copy
00:33:53 <kmc> try IntMap instead
00:33:55 <sanjoyd> Yeah, just saw that.
00:34:09 * sanjoyd is looking at DiffArray now.
00:34:18 <kmc> DiffArray is widely regarded to suck
00:34:26 <sanjoyd> Oh, okay.
00:34:27 <sanjoyd> Thanks.
00:34:29 <kmc> it's a nice idea, though!
00:34:39 <kmc> i think Map or IntMap will have more the properties you desire
00:34:49 <sanjoyd> Yes, I'll have a look.
00:35:21 <sanjoyd> Actually, I was trying to implement the traditional chained hashtable in Haskell (as an exercise); seems like it'll be a good idea to directly use a Map.
00:35:51 <jnhnum1> blargh why is it not possible to make something like a list which contains values of different types, but all of which are an instance of a particular type class
00:36:03 <jnhnum1> like how in java you can have an array of some interface
00:36:10 <sanjoyd> :t [(Eq a=>a)]
00:36:11 <lambdabot> parse error on input `=>'
00:36:20 <sanjoyd> :t [(Eq a)=>a)]
00:36:20 <lambdabot> parse error on input `=>'
00:36:23 <sanjoyd> Come one.
00:36:28 <kmc> it is in GHC Haskell
00:36:34 <kmc> using the ExistentialTypes extension
00:36:42 <kmc> but there is probably a simpler solution
00:36:47 <shachaf> sanjoyd: You're trying to take the type of a type.
00:37:04 <sanjoyd> shachaf: yes; screwed up.
00:37:07 <jnhnum1> kmc: like for example say I want to have a list of things implementing Show
00:37:07 <kmc> data Thing = TInt Int | TBool Bool
00:37:10 <kmc> now [Thing]
00:37:14 <kmc> jnhnum1, then you should use [String]
00:37:16 <shachaf> jnhnum1: Which type class do you want?
00:37:30 <shachaf> Right, what kmc said.
00:37:37 * shachaf will leave the anti-type-classery to kmc.
00:37:37 <kmc> existentials are useful when you need an *open, extensible* set of types
00:37:45 <kmc> which people usually don't
00:37:47 <jnhnum1> oh ok
00:37:56 <jnhnum1> yes I was thinking of the open, extensible use case
00:38:04 <kmc> then maybe existentials
00:38:09 <kmc> or maybe just a record of functions
00:38:15 <jnhnum1> i.e. in a web framework where I would want to have different request handlers or something
00:38:25 <kmc> why would their types differ, though?
00:38:45 <kmc> there are several ways to do OOP in Haskell but the nicest one involves no type classes
00:38:53 <kmc> interfaces are types, probably records of functions
00:39:16 <jnhnum1> ah I see
00:39:26 <kmc> data Handler = Handler { pathPrefix :: String, handle :: Request -> IO Response }
00:39:29 <kmc> handlers :: [Handler]
00:39:42 <jnhnum1> yeah I was asking because typeclasses were the first solution that came to mind
00:39:47 <kmc> right
00:39:47 <jnhnum1> but that does seem more elegant
00:39:59 <kmc> Java has poisoned everyone's minds
00:40:15 <kmc> to think that new behavior => new type
00:40:26 <jnhnum1> :(
00:40:53 <kmc> sometimes you do want some hidden implementation type in that record
00:40:59 <kmc> for which existentials are useful
00:41:04 <kmc> but you still don't need type classes
00:41:22 <kmc> type classes are closer to mere syntactic sugar than you might think
00:41:30 <kmc> they are basically just a way to pass certain values implicitly
00:41:52 <jnhnum1> yeah I see that now
00:42:45 <jnhnum1> kmc: thanks for your help - I've gotta run now
00:44:27 <kmc> ok, good luck :)
00:45:46 <quicksilver> kmc: or, a way to get the type inference engine to select certain values at compile time for you.
00:53:50 <Peaker> kmc: I think existentials can almost always be replaced by a non-existential representation -- so the most notable uses of existentials I know about are for efficiency purposes
00:54:40 <Peaker> (e.g: The Stream type)
00:59:45 <kmc> you can replace them with higher-rank universal quantification
01:11:49 <Saizan> not the "select certain values for me" part
01:13:03 <mreh> I cry every time i have to write fmap (fmap f)
01:13:27 <mreh> would it be worth wrapping the nested functor in a newtype and creating a nice traversable isntance for it?
01:14:21 <Saizan> Functor you mean?
01:15:16 <mreh> oh sorry, i was doing mapM too
01:16:10 <mreh> the question is, is that saved typing not obliterated by wrapping and un-wrapping
01:16:28 <mreh> valuable time saved comprehending it mind
01:16:53 <Saizan> check the newtype package, maybe
01:17:31 <opqdonut> real men just say "fmap fmap fmap f"
01:18:04 <mreh> :t ala
01:18:06 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
01:18:16 <mreh> T_T
01:18:29 <mreh> looks like CPS
01:18:34 <mreh> high order CPS
01:19:08 <mreh> on closer inspection though...
01:19:13 <Saizan> > ala Sum foldMap [1..10]
01:19:14 <lambdabot>   Not in scope: `foldMap'
01:19:49 <Saizan> booh
01:20:06 <mreh> :t Data.Monoid.foldMap
01:20:07 <lambdabot> Not in scope: `Data.Monoid.foldMap'
01:20:31 <Saizan> > ala Sum (mconcat . map) [1..10]
01:20:33 <lambdabot>   Couldn't match expected type `[b -> n']'
01:20:33 <lambdabot>         against inferred type `[o]...
01:20:49 <PatrickRobotham> Is there a typeclass that supports a generalized fold the same way functors support generalized map?
01:21:01 <_Ray_> foldable?
01:21:28 <mreh> Foldable indeed
01:21:36 <mreh> foldMap is in Foldable
01:21:47 <PatrickRobotham> _Ray_: Cheers :)
01:21:53 <mreh> i don't know why I thought it was in monoid, probably because it involves one
01:21:54 <Saizan> > ala Sum (\f -> mconcat . map f) [1..10]
01:21:56 <lambdabot>   55
01:22:29 <mreh> is this function named after the french idiom?
01:22:42 <Saizan> yep
01:22:55 <_Ray_> @src ala
01:22:56 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
01:23:00 <_Ray_> :(
01:23:21 <osfameron> @src oolalalalalah
01:23:22 <lambdabot> Source not found. Wrong!  You cheating scum!
01:23:44 <Saizan> Foldable provides a fairly list-centrict generalization of a fold, btw
01:31:19 <quicksilver> Dear Galois, the character ` is not a quotation mark. kthxbye.
01:32:41 <kalven> k
01:33:48 <osfameron> quicksilver: and ` doesn't balance with ' in any font I've ever seen </broken record>
01:35:21 <burbul> is Data.Array suitable for memoising the return value of a function?
01:36:18 <burbul> (It looks sensible, but I'm really new to Haskell)
01:37:29 <quicksilver> osfameron: it does in LaTeX and troff IIRC, which I imagine is where that convention came from.
01:37:44 <quicksilver> burbul: sure.
01:37:51 <Botje> burbul: it's very nice if your array is dense
01:38:06 <quicksilver> burbul: as long as you're only planning to memoize a fixed chunk which starts at 0
01:38:10 <quicksilver> (or, at least, is linear)
01:38:20 <quicksilver> and you know in advance how many.
01:38:23 <b_jonas> well, Data.Array arrays don't always start with 0
01:38:25 <b_jonas> sadly
01:38:25 <quicksilver> s/linear/contiguous/
01:38:33 <b_jonas> but that doesn't matter too much
01:39:02 <burbul> yup -- actually I'm memoising something that is defined on an infinite set of trees, but I'm only ever going to use it on a finite enumerable subset
01:39:30 <burbul> so the plan is to set up an explicit bijection between that set and [0..N] (which will probably involve using a data.Map)
01:39:44 <burbul> and then use Data.Array to memoize
01:39:49 <burbul> Anyway, thanks!
01:42:06 <develhevel> when i have a data type like: data Test = Test{i1 :: CInt, i2 :: CInt, i3 :: CFloat}, howto generate one object of it in ghci by using let ... ?
01:42:12 <burbul> oh, wait, one other question -- is !! on lists O(n) time?  I.e. if you want constant speed look up, do you need to convert the list to an Array?
01:42:33 <develhevel> let a = 1 2 3 :: Test, dont work
01:42:54 <burbul> Don't you need to put the constructor name before the arguments?
01:42:57 <burbul> Test 1 2 3
01:42:58 <burbul> ?
01:42:59 <benmachine> you do
01:43:11 <benmachine> let a = Test 1 2 3
01:43:20 <benmachine> then the type annotation is not necessary
01:44:12 <develhevel> benmachine: thx
01:47:25 <quicksilver> burbul: yes, !! on lists is O(n) time. Constant speed lookup does not exist. Array, IntMap, and Map are all asymptotically comparable but have different constant factors.
01:47:35 <burbul> oh
01:47:59 <burbul> I assumed it Array was using some low-level hackery. thanks!
01:48:46 <develhevel> i have a problem with the FFI, i generated a struct and made a storable of it, but when i have it in the type signature i get: Unacceptable argument type in foreign declaration, how to resolve this?
01:49:32 <benmachine> develhevel: what does your foreign import look like?
01:49:49 <develhevel> i post it just a second
01:51:11 <quicksilver> burbul: Array gives constant time lookup in the same sense as array in all other programming languages, yes.
01:51:16 <quicksilver> burbul: (which is to say, it doesn't).
01:52:19 <hpaste> bamski pasted “struct in ffi” at http://hpaste.org/49257
01:52:32 <develhevel> benmachine: http://hpaste.org/49257
01:53:15 <osfameron> quicksilver: arrays *don't* give constant time lookup?
01:53:50 <quicksilver> osfameron: no. Consider caches.
01:53:58 <quicksilver> arrays which fit in your cache are very fast.
01:54:01 <quicksilver> bigger ones are not.
01:54:20 <_Ray_> however this doesn't grow as n does, or any function of n
01:54:25 * osfameron doesn't know anything about caches
01:54:41 <quicksilver> also, pointer dereference on a 32 bit architecture only works on N up to 2^32
01:54:44 <_Ray_> it is dominated by above by a constant
01:54:48 <quicksilver> if we are content to restrict to 2^32...
01:54:55 <quicksilver> then IntMap is also constant time
01:55:00 <quicksilver> and so is Map.
01:55:02 <Samuel> quick quesiton, I am learning Haskell using the ghci so I am getting to the point when I created a simple Geometry.hs that I can't import from whithin another .hs file but if I load directly from ghci it works fine
01:55:05 <osfameron> > 2^32
01:55:07 <lambdabot>   4294967296
01:55:10 <_Ray_> even if you didn't, we're considering that addition of word size elements is constant (that's part of our model)
01:55:16 <_Ray_> so array lookup would still be constant
01:55:16 * quicksilver nods
01:55:28 <benmachine> Samuel: what happens when you try to import it?
01:55:36 <quicksilver> you can construct theoretical models in which Array is constant time and IntMap is not.
01:55:51 <benmachine> develhevel: sorry I don't actually know the details of passing structs in the FFI, or even if it's possible -- I think passing pointers to structs is more common
01:55:51 <quicksilver> however those models don't model real computers well
01:56:07 <_Ray_> of course, but we use them anyway :)
01:56:21 <Samuel> :load Geometry.hs from ghci is good but when I type "import Geometry.hs" in another file that I upload the system throws an error "Can't find module"
01:56:29 <develhevel> benmachine: ok thx
01:56:36 <Samuel> or even "import Geometry"
01:56:49 <benmachine> Samuel: it has to be called Geometry.hs and it has to be in the same directory
01:57:02 <Samuel> yep it is in the same directory
01:57:12 <Samuel> test.hs and Geometry.hs
01:57:31 <benmachine> what does it say *exactly*
01:58:17 <burbul> heh -- I've just come back, having spent 5 minutes googling the details of Data.Array --- I thought you were saying that it took O(log n) machine operations for lookup, and that seemed a little implausible!
01:58:23 <Samuel> C:\Users\bmbayad\Downloads\baby.hs:1:8:
01:58:23 <Samuel>     Could not find module `Geometry':
01:58:23 <Samuel>       Use -v to see a list of the files searched for.
01:58:23 <Samuel> Failed, modules loaded: none.
01:58:37 <benmachine> have you tried using -v?
01:59:40 <benmachine> burbul: well, it takes log n time to add numbers of size n together, which you need to do to make a lookup, no?
02:00:06 <develhevel> does anybody know, if i use the ffi and want to use a function which gets a Ptr CInt, how to create a Ptr in ghci?
02:00:52 <benmachine> develhevel: do you want it pointing to some data, or does it get filled in by the function?
02:00:57 <Samuel> how do I use the -v
02:01:12 <Samuel> I tried :l module -v is not recognized
02:01:36 <benmachine> :Set -v
02:01:37 <benmachine> er
02:01:38 <benmachine> :set -v
02:01:41 <Samuel> ok
02:01:49 <benmachine> or just start with ghci -v
02:01:49 <develhevel> it get filled in, e.g. i have a 2::Int, how to get the Ptr adress of it?
02:02:06 <benmachine> @hoogle with
02:02:07 <lambdabot> Foreign.Marshal.Utils with :: Storable a => a -> (Ptr a -> IO b) -> IO b
02:02:07 <lambdabot> System.Environment withArgs :: [String] -> IO a -> IO a
02:02:07 <lambdabot> Foreign.Marshal.Array withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
02:02:26 <benmachine> Foreign.Marshal.with is probably what you want
02:05:07 <Samuel>  Could not find module `Geometry':
02:05:07 <Samuel>    locations searched:
02:05:07 <Samuel>      Geometry.hs
02:05:07 <Samuel>      Geometry.lhs
02:05:43 <Botje> Samuel: does your file have a 'module Geometry where' at the top?
02:05:45 <benmachine> Samuel: hmm. how and where do you start ghci?
02:05:57 <Samuel> in Geometry.hs
02:06:23 <Samuel> lol I click on it from start menu
02:06:34 <benmachine> oh
02:06:39 <benmachine> I don't really know how that works, sorry
02:06:45 <benmachine> maybe you can do
02:06:59 <benmachine> :set -iC:\Users\bmbayad\Downloads
02:07:04 <benmachine> maybe that would help
02:07:13 <benmachine> (or whatever directory Geometry is in)
02:07:13 <quicksilver> burbul: it's a kind of annoying argument, sorry for derailing you.
02:07:47 <quicksilver> burbul: Array lookup may be a constant number of pointer dereferences (it is) but pointer dereferences take multiple cycles on modern CPUs; depending where memory is located (L1/2 cache, swapfile, etc)
02:08:09 <quicksilver> burbul: conversely, IntMap takes a bounded number of pointer dereferences
02:08:30 <quicksilver> burbul: so really it's hard to argue that there is an asymptotic difference - it's just about practicalities. Which has the lowest constant factor?
02:10:31 <Samuel> ok it works now
02:11:01 <Samuel> I shutdown the ghci and reopened from the same directory from where I am trying to load it
02:11:46 <quicksilver> you can just :cd inside ghci
02:11:50 <quicksilver> but glad you got it sorted!
02:12:00 <Samuel> oh I should try that as well
02:12:55 <vrthra> Hi, I am trying to decode a binary flie containing some headers followed by zlib compressed portion, followed by the headers.. repeating this way. The zlib library in haskell does not give me any indication of the number of bytes consumed. How do I get this information? so as to find the location of next header?
02:13:51 <quicksilver> the headers dont' specify how long the compressed portions are?
02:13:57 <vrthra> no
02:14:04 <quicksilver> that's unfortunate design :(
02:14:07 <vrthra> it is git,
02:14:10 <Samuel> weird what the ghci is running from command prompt?
02:14:21 <vrthra> it has the inflated length :(
02:14:23 <burbul> benmachine, quicksilver: I'm not really trying to argue about what happens as things get infinitely large.  Array lookup is still in practice *much* faster than tree-based algorithms, so I wanted to be sure that the Haskell Array translated to a low-level array lookup.
02:14:24 <quicksilver> ah yes. Git is a good example of unfortunate design :)
02:14:25 <vrthra> but no deflated length
02:14:50 <Samuel> :set i has to do anything with this/
02:14:52 <quicksilver> burbul: sure, 'constant time' is a trigger phrase but yes, agreed ;)
02:15:00 <quicksilver> burbul: IntMap isn't exactly a Tree, though.
02:15:13 <burbul> I've never heard of it!
02:15:39 <quicksilver> burbul: IntMap is faster than mutable arrays in many cases (when you are needing mutation) but, yes, a simple Array should be the fastest for write once read-many.
02:15:56 <burbul> I'm just looking it up...
02:16:07 <quicksilver> vrthra: looks to me like you can't with the haskell zlib library :( annoying.
02:16:25 <vrthra> oh :(
02:16:30 <burbul> Is the point that it's domain is sparse?
02:17:10 <quicksilver> burbul: the domain can be sparse, and large chunks can be shared between copies.
02:17:10 <burbul> (oh, wait, i missed your 'mutable' point)
02:17:13 * quicksilver nods
02:17:45 <burbul> Is there an index of/guide to all the standard library containers somewhere?
02:18:19 <quicksilver> don't think so :(
02:18:29 <burbul> ah well. thanks for all the help!
02:18:30 <benmachine> someone should write a haskellwiki article (not it)
02:43:13 <burbul> How do you attach a type annotation to a polymorphic nested function?
02:45:22 <kosmikus> burbul: huh? why would it make a difference that it's polymorphic?
02:46:40 <burbul> I thought the compiler was getting confused because the type variable from the outer function wasn't getting bound --- i.e.
02:46:56 <burbul> It thought the 'a' in the outer function signature and the 'a' in the inner function signature were different things
02:47:02 <burbul> I may have misinterpreted that, though
02:47:06 <benmachine> they are, in general
02:47:17 <benmachine> there is an extension ScopedTypeVariables which fixes this
02:47:26 <benmachine> well, lets you fix this if you want to
02:47:32 <burbul> I suppose it doesn't hurt too much if they are allowed to be different
02:48:02 <roconnor> if you don't want to use extensions, there are often hacks you can do using asTypeOf and undefined.
02:48:24 <burbul> Don't worry, it's probably not worth it -- I just assumed that I was missing something easy
02:48:41 <roconnor> burbul: :)  It is a moderate problem with the haskell standard.
02:54:15 <wuxingbo> some bad guy just hijacked the haskell main page?? :(
02:55:49 <earthy> looks like it
02:57:07 * benmachine restores it
02:58:22 <benmachine> gwern: http://haskell.org/haskellwiki/Special:Contributions/Eirhek perhaps you could do something about this chap
03:00:06 <mreh> wait, what this guy says makes a lot of sense
03:00:34 <mreh> :t ala
03:00:36 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
03:01:01 <benmachine> :t ala Endo foldMap
03:01:03 <lambdabot> Not in scope: `foldMap'
03:01:05 <benmachine> ff
03:01:15 <benmachine> :t ala Endo (mconcat . map)
03:01:16 <lambdabot>     Couldn't match expected type `[b -> n']'
03:01:16 <lambdabot>            against inferred type `[a -> a] -> [Endo a]'
03:01:16 <lambdabot>     In the second argument of `(.)', namely `map'
03:01:19 <benmachine> ffff
03:01:34 <benmachine> whatevs
03:02:17 <s7s> Why is the naive fibonacci algorithm 2 times faster in C than in haskell ?
03:03:13 <identity_> s7s: which one?
03:03:18 <benmachine> s7s: languages don't have speed, implementations do
03:03:31 <identity_> I strongly doubt that the naive haskell algorithm is algorithmically equivalent to the naive C algorithm
03:03:38 <identity_> and what he said
03:03:40 <s7s> comparing ghc -O3 and gcc -O3
03:03:50 <benmachine> (does ghc -O3 even exist?)
03:04:03 <benmachine> it's probably equivalent to -O2
03:04:21 <s7s> maybe
03:04:40 <benmachine> s7s: it could be for a number of reasons, e.g. are you using Integer instead of Int
03:05:02 <benmachine> are you being more space-efficient in one version as compared with the other
03:05:22 <benmachine> (using space => using GC => slow)
03:06:14 <s7s> check these benchmarks http://goo.gl/58pVh
03:09:07 <s7s> (benmachine , identity_): any ideas ?
03:09:49 <benmachine> s7s: sounds like that link covers it pretty well
03:10:31 <s7s> benmachine: there's no clarification there for why this is the difference
03:11:00 <benmachine> *shrug*
03:11:02 <benmachine> I don't know any better
03:12:39 <s7s> benmachine: ok thanks
03:13:05 <identity_> s7s: there is, actually
03:13:16 <identity_> http://stackoverflow.com/questions/6716315/on-improving-haskells-performance-compared-to-c-in-fibonacci-micro-benchmark/6716915#6716915
03:13:44 <identity_> it seems the nifty zipWith version is very fast compared to the naive one
03:14:15 <s7s> identity_: yes, but the point here is we actually one to compare the performance of the naive versions
03:14:22 <identity_> yes
03:14:37 <s7s> identity_: the zipWith version is memoised and ofcourse outperforms the other one
03:14:56 <identity_> The naive algorithm in Haskell is not comparable to the naive one in C
03:14:58 <identity_> different paradigms
03:15:01 <identity_> data immutability
03:15:22 <benmachine> identity_: in principle it should be
03:15:25 <identity_> you're comparing 'similar' algorithms in different languages
03:15:32 <identity_> benmachine: really?
03:15:39 <benmachine> the C algorithm is not using mutability
03:15:48 <s7s> i agree with benmachine
03:15:58 <identity_> well, then I still argue that different paradigm requires you to think differently
03:16:03 <identity_> I still think it's a strange thing to ask
03:16:08 <benmachine> identity_: it is a strange thing to ask
03:16:18 <benmachine> such specific benchmarks are rarely that enlightening
03:16:23 <identity_> exactly
03:16:30 <benmachine> but there's no *fundamental* reason why haskell should be slower in this case
03:16:37 <s7s> i also agree
03:16:44 <s7s> but the difference is a bit surprising
03:16:51 <benmachine> it is a little bit surprising
03:17:01 <benmachine> it's probably to do with the extra bookkeeping done by GHC?
03:17:08 <benmachine> the overhead of starting the RTS, that sort of thing
03:17:19 <identity_> The question shouldn't "why does haskell(yes, yes, implementation of) perform worse than C with a similar algorithm" but rather "Can haskell perform similarly with AN algorithm to solve the same problem?"
03:17:24 <benmachine> it might be interesting to see if it's still twice as slow when the runtime goes into minutes
03:17:30 <identity_> benmachine: that's what the stackoverflow thread seems to suggest
03:17:34 <identity_> stack space check and so on
03:17:49 <benmachine> identity_: both questions are interesting to some extent, but one is more practical than the other
03:18:15 <s7s> my question is a compiler issue not an algorithmic issue, got it ?
03:18:23 <s7s> actually not my question
03:18:29 <s7s> what I'm trying to understand
03:19:09 <benmachine> s7s: I would be interested to see how the two programs behaved as the input grew larger
03:20:03 <s7s> benmachine: in C you'll have to use something other than int, since an int variable will not handle fib > 40 I think
03:20:30 <Ke> libgmp
03:21:04 <s7s> benmachine: I'll try them anyways
03:21:44 <benmachine> s7s: ah, right, tricky.
03:21:51 <quicksilver> the C one is using int but the haskell one is using Integer?
03:21:56 <benmachine> s7s: you could always just calculate fib 40 about twenty times
03:21:58 * hackagebot base-unicode-symbols 0.2.2 - Unicode alternatives for common functions and operators  http://hackage.haskell.org/package/base-unicode-symbols-0.2.2 (RoelVanDijk)
03:22:00 <benmachine> quicksilver: no it uses Int too
03:22:20 <benmachine> (otherwise managing just a 2x slowdown would be quite impressive :P)
03:22:21 <quicksilver> oh, no, it's not.
03:22:33 <benmachine> (I... think? maybe?)
03:22:43 <quicksilver> you're right
03:22:51 <quicksilver> I don't think 2x slowdown is very much.
03:23:10 <quicksilver> this is exactly the kind of microbenchmark into which entire programmer-centuries of effort have been put
03:23:11 <mreh> it is if it's a million years
03:23:18 <quicksilver> for gcc and llvm
03:23:23 <s7s> I think if we enforced strictness on the (n-1) and (n-2) arguments will this make a good difference ?
03:23:24 <quicksilver> ghc just hasn't had that kind of attention.
03:23:36 <quicksilver> s7s: I doubt it; ghc should infer that. Try it and see though.
03:24:29 <benmachine> mreh: psh. I'm not terribly interested in the difference between an algorithm that takes a million years or one that takes two million :P
03:25:06 <mreh> what if it takes place inside a dream inside a dream inside a dream?
03:25:20 <quicksilver> mreh: sure. GHC compiled haskell is slower than C
03:25:24 <quicksilver> this is not news to any body :)
03:25:31 <quicksilver> I'm actually *impressed* that the slowdown is only 2x
03:25:35 <mreh> i was just trollin'
03:25:38 <quicksilver> it used to be more like 6x-10x for code like that.
03:26:12 <s7s> quicksilver: such slowness is unjustified :D
03:27:38 <s7s> quicksilver: even the 2x slowdown is unjustified
03:27:52 <quicksilver> it's entirely justified.
03:28:00 <quicksilver> it's a completely different language, a completely different compiler
03:28:09 <quicksilver> with many orders of magnitude less time and effort put into it
03:28:36 <benmachine> quicksilver: I think we have different meanings of "justified" going on here
03:28:38 <quicksilver> gcc/clang/llvm are better codegens.
03:28:51 <quicksilver> perhaps.
03:28:55 <quicksilver> :)
03:29:14 <s7s> This naive algorithm has not any fancy (let's say) functional techniques. It should be just interpreted like the C code
03:29:20 <benmachine> what the benchmark shows us is that there is room for improvement
03:29:35 <benmachine> whether it's enough room to care about is a different issue
03:29:55 <quicksilver> s7s: sure. It is.
03:30:02 <quicksilver> s7s: compiling that C code is actually quite difficult.
03:30:30 <quicksilver> the C compilers being used are clever compilers into which a lot of work has been put on microbenchmarks like this.
03:30:57 <quicksilver> I would expect a naive C compiler would produce slower code than GHC
03:31:02 <mreh> ala's arguments are sooo the wrong way round
03:31:13 <mreh> foldMap `ala` Sum
03:32:26 <quicksilver> according to Peter Wortmann (I haven't checked the assembly myself) GHC actually does a pretty good job of the codegen here, it's just GCC does better.
03:32:41 <quicksilver> I'd be interested in a detailed analysis by someone qualified to understand of the assembly GCC produces.
03:34:33 <mietek> Has anyone tried using Emscripten to compile Haskell to JavaScript through LLVM?
03:35:36 <luite> hmm that question was asked before :)
03:36:09 <mietek> I saw a thread on cafe in April
03:36:13 <mietek> Which didn't really go anywhere
03:36:24 <mreh> that sounds great
03:36:35 <mreh> Javascript is the new aseembler
03:36:44 <luite> I think a real javascript codegenerator is a better idea, with proper ffi to call other javascript
03:36:49 <quicksilver> mietek: I think no one has tried properly.
03:36:53 <luite> there are a few projects
03:36:55 <quicksilver> luite: isn't that what ghcjs is?
03:37:07 <luite> yeah, and I believe there's one for uhc as well
03:37:10 <mietek> luite: Yes
03:37:18 <mietek> Unfortunately, they seem to suffer from lack-of-timeitis
03:37:20 <quicksilver> luite: and for nhc and/or yhc
03:37:44 <mreh> there has to be research money out there for this
03:37:46 <quicksilver> yhc has had some cool features which haven't been widely adopted. It had mobile code too IIRC.
03:37:49 <luite> I don't think you'd save much time with emscripten if you have to port the rts first
03:37:51 <mreh> how does Links do it?
03:38:15 <luite> better use that javascript x86 emulator
03:38:16 <luite> :)
03:38:56 <mietek> mreh: Links; do you mean the browser?
03:39:20 <mreh> Nah, Links by Wadler
03:41:39 <mreh> i only read about it yesterday
03:41:45 <mietek> That's pretty cool
03:41:52 <mietek> I didn't know about it
03:42:50 <mreh> my vision is FRP superimposed over the connection between server and client
03:44:38 <mreh> which is completely restorable from the point where it last left off
03:44:51 <quicksilver> there have been continuation-based web frameworks before.
03:45:04 <mreh> you make it sound like they failed
03:45:13 <quicksilver> I think they succeeded
03:45:21 <quicksilver> they're common enough that google guessed my search too :)
03:45:22 <mreh> failure is the hardest part I suppose
03:45:31 <quicksilver> http://www.google.co.uk/search?aq=0&oq=continuation+based&sourceid=chrome&ie=UTF-8&q=continuation+based+web+frameworks
03:46:12 <quicksilver> that search also brings up a fair criticism that it might be a leaky abstraction.
03:46:21 <quicksilver> FRP in general seems to be a leaky abstraction :(
03:46:28 <quicksilver> but hopefully we can solve that problem.
03:46:38 <mreh> leaky?
03:47:17 <quicksilver> leaky meaning, the details they attempt to abstract over you actually need to keep thinking about
03:47:22 <quicksilver> so they fail at 'abstracting' them.
03:47:44 <quicksilver> FRP leaks in the sense that you still have to worry about space leaks and performance problems
03:47:59 <mreh> did you read Conal's paper?
03:48:03 <quicksilver> but unfortunately (in current frameworks) you don't really have the tools to analyze them because the problems are hidden.
03:48:07 <quicksilver> mreh: which one?
03:48:15 <mreh> simply efficient FRP (?)
03:48:19 <mreh> push pull FRP
03:48:28 <mreh> it goes by two names
03:49:00 <quicksilver> I read the one that introduces 'Reactive'
03:49:04 <quicksilver> which was a year or two back.
03:49:29 <mreh> i think performance wise he's plugged the leaks
03:49:39 <mreh> but his implementation doesn't work yet :(
03:49:55 <quicksilver> "
03:49:57 <quicksilver> "Simply efficient functional reactivity"
03:50:04 <quicksilver> I don't think he's plugged the abstraction leaks.
03:50:09 <quicksilver> I don't think he's even tried to.
03:50:16 <quicksilver> there are ways to used those combinators which lead to space leaks
03:50:26 <quicksilver> but it's not obvious that it will, from the abstract description.
03:50:38 <quicksilver> I have written my own independent implementation of most of conal's API.
03:50:49 <quicksilver> I think this is a hard problem.
03:50:52 <quicksilver> (an interesting one, too)
03:50:58 <sebz> see http://conal.net/blog/posts/garbage-collecting-the-semantics-of-frp
03:51:50 <mreh> i've not had the time to really get to know those combinators inside out
03:52:09 <quicksilver> sebz: I don't think that's quite relevant.
03:52:14 <quicksilver> that's about the semantics. It's an interesting post.
03:52:27 <quicksilver> I'm talking about the implementation - and how there are implementation details which you need, unfortunately, to be aware of.
03:52:39 <mreh> that's no the end of the world
03:52:43 <quicksilver> to be honest, most high-level libraries have abstraction leaks like this; it doesn't make them useless but it is annoying.
03:52:43 <mreh> RTFP
03:52:46 <quicksilver> of course.
03:52:58 <mreh> Parsec has a big abstraction leak i'd say
03:53:04 <quicksilver> sure
03:53:13 <mreh> but it's useful once you know what it is
03:53:27 <mreh> sure you need to learn what an LL grammar is, and about lookaheads
03:53:59 <mreh> or you could just left factor everything :)
03:54:29 <mreh> anyway, interesting discussion
03:54:33 <sebz> quicksilver: oh, sorry then. I thought the point was that the semantic model being too broad was the source of the implementation headache
03:54:37 <mreh> does you implementation of his API work?
03:54:48 <sebz> "arbitrary past access is also problematic to implement in its semantically simple generality"
03:54:51 <quicksilver> mreh: partly.
03:55:01 <quicksilver> mreh: and it works in different parts to Conal's ;)
03:55:09 <quicksilver> I have a joinE implementation which works, for example.
03:55:15 <mreh> quicksilver: you two should talk
03:55:20 <quicksilver> we have done, quite often.
03:55:26 <quicksilver> particularly back when I was writing that
03:55:31 <quicksilver> but I haven't had time to work on it recently.
03:56:17 <mreh> shame
03:56:38 <mreh> personally, i think FRP is a hell of a lot better than maintaining data dependencies in my own head
03:56:44 <quicksilver> I agree.
04:02:49 <burbul> @pf do { s <- symbol ; return (s, Nothing) }
04:02:50 <lambdabot> Maybe you meant: bf pl
04:02:58 <burbul> @pl do { s <- symbol ; return (s, Nothing) }
04:02:59 <lambdabot> (line 1, column 4):
04:02:59 <lambdabot> unexpected "{"
04:02:59 <lambdabot> expecting variable, "(", operator or end of input
04:03:28 <burbul> @pl x = do { s <- symbol ; return (s, Nothing) }
04:03:28 <lambdabot> (line 1, column 8):
04:03:29 <lambdabot> unexpected "{"
04:03:29 <lambdabot> expecting variable, "(", operator or end of input
04:04:19 <burbul> @pl symbol >>= (\s -> return (s, Nothing))
04:04:20 <lambdabot> flip (,) Nothing `fmap` symbol
04:04:42 <quicksilver> burbul: fmap (\x -> (x,Nothing))
04:04:51 <quicksilver> burbul: or ... (\x -> (x,Nothing)) <$>
04:04:59 <quicksilver> hmm
04:05:06 <quicksilver> or...
04:05:14 <burbul> I was trying to see if , was an operator
04:05:22 <quicksilver> it is, it's called (,)
04:05:23 <burbul> So that I could write
04:05:25 <quicksilver> well it's a constructor.
04:05:26 <burbul> (,Nothing)
04:05:28 <burbul> Or something like that
04:05:33 <quicksilver> there is a GHC extension for that
04:05:47 <quicksilver> standard haskell doesn't permit you to section ,
04:06:00 <burbul> ok -- then don't worry.
04:06:26 <burbul> [ if I have to use lambdas then I might as well use do notation, no?]
04:06:33 <quicksilver> http://www.haskell.org/ghc/docs/6.12.3/html/users_guide/syntax-extns.html#tuple-sections
04:06:52 <quicksilver> (,) <$> symbol <*> pure Nothing
04:06:56 <quicksilver> is another option
04:07:00 <burbul> whoa
04:07:06 <burbul> ok, I'm going to look up the bits of that
04:07:10 <burbul> Thanks
04:07:10 <opqdonut> flip (,) Nothing <$> symbol
04:07:11 <opqdonut> ?
04:08:02 <quicksilver> opqdonut: I really don't like flip.
04:08:08 <quicksilver> can't quite explain why :)
04:08:36 <quicksilver> burbul: would you have understood (liftM2 (,) symbol (pure Nothing)) ?
04:08:37 <opqdonut> I don't like <*> with pure, that should have some other name
04:08:51 <burbul> So it looks like <*> is ap and
04:08:51 <quicksilver> opqdonut: I think there is a problem with associativity to do it generally and correctly.
04:08:54 <burbul> pure is return
04:08:57 <burbul> right?
04:09:00 <opqdonut> yeah
04:09:06 <opqdonut> (on both counts)
04:09:29 <burbul> and <$> is liftM
04:09:37 <burbul> sorry
04:09:39 <opqdonut> also known as fmap
04:09:41 <burbul> `liftM`
04:09:43 <opqdonut> yeah :)
04:10:07 <burbul> I'm still getting used to monads. is there a reason to use fmap instead of liftM ?
04:10:31 <quicksilver> no.
04:10:39 <burbul> good
04:10:42 <quicksilver> it just indicates that you understand it would work even if it was 'only' a functor
04:10:51 <quicksilver> if you happen to know it's a monad there is no difference.
04:11:04 <quicksilver> although liftM looks uglier to me becuase of the capital M
04:11:08 <quicksilver> which is just being irrational.
04:11:13 <quicksilver> (why isn't it called mapF? ;)
04:11:33 <opqdonut> :)
04:25:58 <Philonous> I think pure should have some syntactic sugar. [val] could be generalized to mean (pure val)
04:26:40 <opqdonut> haskell clearly needs mixfix :)
04:34:28 <Philonous> [] could be mzero (or mempty1), [a,b] then becomes (pure a) `mplus` (pure b). That would actually make sense
04:35:25 <hpc> that would also be stupefyingly slow for lists
04:36:07 <opqdonut> well [a,b] could desugar into something like a `build` b `build` empty'
04:36:08 <Philonous> hpc:  Since it's already magic, you could just have a special case for lists. It would still be the same semantically.
04:36:36 <opqdonut> and then one could have a default implementation of build and empty' using pure, mplus and mzero
04:37:06 <opqdonut> ISTR an extension like this actually, a List type class maybe?
04:39:49 <quicksilver> Philonous is certainly not the first to suggest [] as syntax for return
04:40:00 <quicksilver> in fact, I have a memory that SPJ suggested it once.
04:40:21 <quicksilver> SPJ is very keen for syntax which allows you to use effects in an "applicative syntax".
04:40:37 <quicksilver> but it's quite hard to do so in a way which feels unambigously right
04:40:55 <quicksilver> (you have to correct deal with all the little instances of 'join' and 'return')
04:41:15 <b_jonas> isn't that a part of extended comprehensions?
04:41:46 <quicksilver> you mean monad comprehensions?
04:42:03 <b_jonas> yes, something like that
04:42:08 <quicksilver> it contains bits of it - it is certainly overloading [] in a sense
04:42:17 <quicksilver> but only in the specific case of a comprehension [ foo | bar ]
04:42:24 <quicksilver> not in the "simple" case of [a]
04:43:07 <quicksilver> the question of whether haskell should have more generally overridable mixfix syntax is of course disjoint from questions about better syntax for effectful programming
04:43:14 <quicksilver> although one might be helpful for the other
04:43:55 <yitz> If . can be an alias for fmap, then surely : can be an alias for mplus . pure, or mappend . pure, or some such. </joke>
04:44:32 <hpc> shirley you can't be serious!
04:44:50 <yitz> hpc: indeed not :)
04:45:14 <yitz> hpc: btw who is shirley?
04:45:27 <b_jonas> it can't, because a colon starts a constructor just like capital letters
04:45:46 <hpc> :P
04:45:48 <yitz> b_jonas: among other reasons
04:46:02 <theorbtwo> Surely, you don't want more hardcoded syntax.
04:47:00 <yitz> theorbtwo: those who advocate those kinds of changes claim that it would be less type-specific and so *less* syntax.
04:49:07 <Tomsik> <hpc> that would also be stupefyingly slow for lists
04:49:14 <Tomsik> That's what rewrite rules are for
04:49:18 <opqdonut> true, dat
04:49:59 <Philonous> Btw. I want to propose `( _ ) ` as syntax to "infixise" whole expressions (for example: [1,2,3] `(zipWith (+))` [4,5,6] )
04:50:34 <opqdonut> there's something a bit like that in the haskell' trac
04:50:49 <osfameron> why couldn't `_` work ?
04:51:19 <osfameron> after all `foo` is just making the expression 'foo' infix isn't it?
04:51:30 <b_jonas> osfameron: you couldn't parse a`b`c`d`e uniquely
04:51:48 <osfameron> ah, fair enough
04:52:12 <b_jonas> that brings up the problem of how their fixity is set though
04:52:25 <aninhumer> b_jonas: pick one and make people use brackets for the other?
04:52:46 <b_jonas> we've already picked one: it's interpreted as a `b` c `d` e currently
04:53:12 <b_jonas> maybe instead of such small patches to the current syntax there should be whole new syntaxes for haskell
04:53:18 <aninhumer> so then if you want the other a `(b `c` d)` e
04:53:19 <b_jonas> completely different from the current one
04:53:27 <b_jonas> that you choose with some pragma
04:54:24 <aninhumer> Perhaps, but I don't think it's necessary for this
04:54:34 <b_jonas> not for this
04:54:42 <b_jonas> but for making a better syntax in general
04:55:10 <aninhumer> I need to look into template Haskell (I think it's called), how much power does that have?
04:56:05 <Philonous> b_jonas:  If you are going to the trouble of declaring fixity for you expression you might as well write a new function and use that instead.
04:56:46 <aninhumer> Also you can just use brackets to override any fixity problems
04:57:19 <Phantom_Hoover> lambdabot request: @messsages shouldn't mark messages as read if lambdabot cuts out while reading them.
04:57:34 <b_jonas> there's also that you can just use two new infixes instead of `( and )`
04:57:39 <b_jonas> though they have to be spelt differently
04:57:51 <Phantom_Hoover> It's very annoying when you get 15 or so (long story) and you only get the first 7 or so.
04:58:12 <Eduard_Munteanu> Phantom_Hoover: use @more?
04:58:16 <quicksilver> b_jonas: yes, someone - beelsebob or conal - wrote them once
04:58:21 <quicksilver> b_jonas: but they don't nest, of course.
04:58:32 <quicksilver> the advantage of 'true brackets' is that they nest correctly.
04:58:41 <Phantom_Hoover> Eduard_Munteanu, didn't work.
04:58:42 <b_jonas> they nest if you add extra parenthesis
04:58:48 <quicksilver> I think they were called <: and :> don't remember what module they were in
04:58:50 <quicksilver> yes.
04:58:53 <b_jonas> then the brackets are three character long
04:59:04 <b_jonas> isn't :> used for something else
04:59:05 <b_jonas> ?
04:59:28 <Saizan> <^ and ^<
04:59:36 <b_jonas> yep, :> is for Data.Sequence
04:59:38 <Saizan> ^>, i meant
04:59:46 <Saizan> @hackage InfixApplicative
04:59:47 <lambdabot> http://hackage.haskell.org/package/InfixApplicative
05:00:25 <Phantom_Hoover> Eduard_Munteanu, it errors out with "<lambdabot> Plugin `tell' failed with: thread killed" and then @messages tells me I have no new messages.
05:00:33 <Phantom_Hoover> Nothing in the buffer, either.
05:01:44 <Eduard_Munteanu> Hm, maybe you should ask Cale.
05:02:02 <b_jonas> that's not the one...
05:02:09 <b_jonas> but I too remember it exists somewhere
05:02:12 <Philonous> Mixfix operators would actually fix that, too.
05:02:51 <Tomsik> :t \a b c d e - > a `(b c d)` e
05:02:52 <lambdabot> parse error on input `-'
05:03:00 <Tomsik> :t \a b c d e -> a `(b c d)` e
05:03:01 <lambdabot> parse error on input `('
05:03:07 <Tomsik> huh
05:03:15 <Tomsik> :t \a b c d e -> a `b c d` e
05:03:16 <lambdabot> parse error on input `c'
05:03:23 <Tomsik> :t \a b c d e -> a ` (b c d) ` e
05:03:25 <lambdabot> parse error on input `('
05:03:29 <Tomsik> Why doesn't that work?
05:03:34 <Philonous> Tomsik:  That's why we are proposing it
05:03:57 <Tomsik> But why? Why is it not working in the first place?
05:04:10 <aninhumer> Tomsik: It isn't part of the syntax
05:04:16 <Tomsik> I thought that stuff between `s has to just be an expression
05:04:29 <Tomsik> like (b c d)
05:04:29 <aninhumer> Nope, has to be a function name
05:04:48 <Tomsik> Is there a reason for it to be so?
05:05:30 <aninhumer> As was said above a`b`c`d`e is ambiguous
05:07:38 <Tomsik> Yes, but it's just about same problem as left/right associative subexpressions of the same precedence
05:07:53 <Tomsik> Why is a `(expression)` b a problem?
05:08:11 <quicksilver> it isn't, as far as I know
05:08:13 <Philonous> Tomsik:  It isn't. It's just not haskell.
05:08:16 <Phantom_Hoover> Oi, Cale.
05:08:22 <quicksilver> it just needs to be implemented
05:08:25 <quicksilver> and then proposed.
05:21:34 <identity_> if an application uses forkIO, how do I use profiling to report how many threads it launched?
05:21:43 <identity_> Does it just happen automatically? can't seem to see it on the output
05:23:25 <Axman6> what sort of threads are you talking about?
05:25:05 <quicksilver> I don't recally any of the standard profiling tools reporting how many threads you fork
05:25:13 <quicksilver> threadscope presumably does
05:38:12 <insomniaSalt> one thing I keep forgetting about "package management" (I know it is not) with cabal,- just to make sure: "updating" something is done with cabal install <package>?
05:38:30 <insomniaSalt> just did it an it seems to have worked
05:39:34 <insomniaSalt> aah, nvm, the warning message of cabal upgrade answered: Use the 'cabal install' command instead of 'cabal upgrade'
05:42:05 <Kaidelong> @instances-importing Ord
05:42:06 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
05:43:07 <joe6> > concat . take 6 . repeat $ " "
05:43:09 <lambdabot>   "      "
05:46:31 <magicman> @info Dual
05:46:32 <lambdabot> Dual
05:46:37 <magicman> @src Dual
05:46:37 <lambdabot> Source not found.
05:46:48 <magicman> > Dual 5 < Dual 7
05:46:49 <lambdabot>   True
05:47:02 <magicman> Darn. I'd hoped that would be reversed as well >_<
05:47:11 <saati> > Dual 5
05:47:13 <lambdabot>   Dual {getDual = 5}
05:47:24 <saati> what is this?
05:47:42 <magicman> > ("a" `mappend` "b", Dual "a" `mappend` Dual "b")
05:47:44 <lambdabot>   ("ab",Dual {getDual = "ba"})
05:48:33 <magicman> It's used for its Monoid instance, which uses the underlying Monoid instance, but with arguments swapped.
05:59:05 <Kaidelong> @ty pred
05:59:06 <lambdabot> forall a. (Enum a) => a -> a
05:59:15 <Kaidelong> @hoogle pred
05:59:16 <lambdabot> Prelude pred :: Enum a => a -> a
05:59:16 <lambdabot> Data.Graph.Inductive.Internal.FiniteMap predFM :: Ord a => FiniteMap a b -> a -> Maybe (a, b)
05:59:16 <lambdabot> Test.HUnit.Base class AssertionPredicable t
05:59:46 <saml> > pred 1.1
05:59:47 <lambdabot>   0.10000000000000009
05:59:54 <Kaidelong> does Ord imply Enum?
06:00:13 <quicksilver> no.
06:00:21 <saml> no Ord implies Eq, i think
06:00:27 <quicksilver> yes
06:00:30 <saml> class Eq a => Ord a where
06:00:42 <Kaidelong> kay, so I need both Ix and Enum
06:00:48 <quicksilver> Enum is a bit of a mess.
06:00:55 <quicksilver> > pred 7.0
06:00:56 <lambdabot>   6.0
06:01:54 <clsmith> floating point errors like lambdabot just did make me cry
06:03:12 <Kaidelong> why does Ix not imply Enum?
06:03:18 <Kaidelong> it seems like it should
06:03:29 <Kaidelong> is Integer not Enum?
06:03:43 <Kaidelong> wait no that wouldn't make any sense
06:03:50 <Kaidelong> > succ 1 :: Integer
06:03:52 <lambdabot>   2
06:03:54 <Kaidelong> of course
06:04:13 <fenris_kcf> hy. how can i call a constant function of defined class? for example: "class Foo where bar :: Int"
06:04:24 <fenris_kcf> how to call "bar"?
06:04:28 <sipa> you can't
06:04:42 <fenris_kcf> only functions with at least one argument?
06:04:46 <saml> typeclass needs type variable, i think
06:04:52 <sipa> its type needs to be polymorphic in a way to relate it to the type the typeclass is on
06:04:52 <Kaidelong> > mzero :: []
06:04:54 <lambdabot>   Expecting an ordinary type, but found a type of kind * -> *
06:04:58 <Kaidelong> > mzero :: [()]
06:04:59 <lambdabot>   []
06:05:05 <Kaidelong> > mzero :: Just ()
06:05:07 <lambdabot>   Not in scope: type constructor or class `Just'
06:05:14 <Kaidelong> > mzero :: Maybe ()
06:05:16 <lambdabot>   Nothing
06:05:17 <saml> fenris_kcf, you can do  let bar = 3
06:05:29 <Axman6> :t \x -> mzero `asTypeOf` [x]
06:05:30 <lambdabot> forall a. a -> [a]
06:05:43 <Kaidelong> fenris_kcf: You would just write "bar" and the value of bar depends on its type
06:05:46 <opqdonut> fenris_kcf: a type class needs to have a parameter (the type to include in the class) and the parameter must appear in the type signatures of the class methods
06:05:48 <fenris_kcf> class Foo a where
06:05:49 <fenris_kcf> bar :: a
06:05:52 <Kaidelong> it is like mempty or mappend
06:05:57 <saml> or    class Foo a where  bar :: a ;    instance Foo Int
06:06:00 <opqdonut> fenris_kcf: that's okay
06:06:03 <int-e> fenris_kcf: you don't need an argument - it's enough to mention the type (class Foo a where bar :: a  is perfectly ok;  class Foo a where bar :: Mark a Int  with newtype Mark a b = Mark b  is a bit inconvenient to work with, but also does the trick.)
06:06:06 <Kaidelong> err
06:06:10 <Kaidelong> mempty or mzero I mean
06:06:21 <saml> everybody, calm down
06:07:11 <fenris_kcf> so how to call the constant? with "Foo.bar"?
06:07:21 <opqdonut> no, just bar
06:07:36 <opqdonut> just like you don't call return Monad.return
06:07:39 <fenris_kcf> but if "bar" is also defined in other instances?
06:07:55 <Kaidelong> you get a conflict unless you use qualified imports
06:07:56 <fenris_kcf> how should haskell know which one is meant?
06:07:58 <saml> class Foo a where bar :: a;    instance Foo Int where bar = 3;     bar :: Int
06:08:13 <opqdonut> fenris_kcf: by the type. that's the whole point of type classes
06:08:30 <Kaidelong> oh he said instances
06:08:39 <fenris_kcf> ok, maybe i should give a real example...
06:08:40 <Kaidelong> listen to opqdonut
06:08:47 <opqdonut> yes, give a real example
06:08:55 <saml> fenris_kcf, Foo is a module, then
06:08:55 <opqdonut> you've probably misunderstood what type classes are for :)
06:09:01 <saml> module Foo where bar = 3
06:09:26 <saml> then you can do,  import Foo;   Foo.bar
06:09:41 <Kaidelong> wouldn't that be import qualified Foo?
06:09:42 <int-e> > (0 :: Int, 0 :: Float) -- 0 is really  fromInteger (0 :: Integer), which is a function of the Num class.
06:09:44 <lambdabot>   (0,0.0)
06:09:52 <saml> Kaidelong, no. don't import qualified
06:09:57 <saml> but qualify anyways
06:10:08 <saml> but that's just my coding style. :P
06:10:12 <int-e> sorry, fromInteger is a function. fromInteger 0 calls that with the integer 0.
06:11:15 <aninhumer> Does a function in a typeclass conflict with a plain function definition even if there are no instances of the typeclass?
06:11:34 <saml> you mean fromIntegral int-e ?
06:11:43 <kmc> aninhumer, yes
06:11:55 <aninhumer> Thought so
06:12:29 * ivanst sighs
06:12:31 <saml> can you qualify it so that they wont' conflict?
06:12:43 <int-e> saml: no. fromIntegral = fromInteger . toInteger
06:12:53 <saml> yes
06:12:56 <ivanst> thank you #haskell for making this possible: my first ever haskell web app is now online.
06:13:01 <int-e> saml: I really meant fromInteger
06:13:06 <saml> ivanst, url
06:13:10 <Axman6> int-e: what's it do?
06:13:19 <int-e> Axman6: which?
06:13:30 <int-e> @type fromIntegral
06:13:30 <Axman6> i meant ivanst
06:13:31 <lambdabot> forall a b. (Integral a, Num b) => a -> b
06:13:38 <ivanst> saml: http://test.whenroute.com/ - it's basically a routing thingamajigger that optimizes your google calendar events
06:13:49 <frerich> Is anybody aware of Haskell people "blogging" on Google+?
06:13:52 <ivanst> it's broken in so many ways i'm ashamed, but hey, it's v0.1 and it's public
06:13:57 <quicksilver> frerich: yes, quiet a few
06:13:59 <saml> ivanst, you are the best haskell programmer i've known
06:14:12 <quicksilver> frerich: start with Dons and look at his public circles, say.
06:14:20 <frerich> quicksilver: Ah, sounds like a plan, thanks.
06:14:21 <ivanst> saml: i'm sure that's nowhere near truth
06:14:38 <saml> ivanst, it crashed my browser
06:14:53 <aninhumer> Oh yes, mine too
06:14:55 <ivanst> O.o ?!
06:15:01 <ivanst> browser info?
06:15:06 <saml> no way. u haxor
06:15:07 <zygoloid> ivanst: how do i pronounce whenroute? :)
06:15:21 <aninhumer> And it's spinlocked by the look of it, Firefox 5 I think
06:15:24 <Axman6> ivanst: looks very sexy for me =)
06:15:32 <ivanst> damn, fx5 wasn't tested...
06:15:42 <ivanst> zygoloid: when-route
06:15:49 <saml> when root
06:16:06 <ivanst> saml: are you using firefox5 as well?
06:16:11 <saml> ivanst, give us libraries you used
06:16:17 <saml> ivanst, yes
06:16:29 <saml> did you use warp?
06:17:06 <saml> and what html template library did you use? any data persistence?
06:17:19 <ivanst> saml: snap, heist, authenticate...
06:17:26 <saml> thanks
06:17:37 <ivanst> we're still not doing any server-side data storage
06:17:44 <fenris_kcf> opqdonut: saml: int-e: Kaidelong: http://codepad.org/4uI3wWDY
06:17:56 <ivanst> the only thing persistent really is the google oauth cookie which we encrypt and pass it on to the visitor as a browser cookie
06:18:12 <fenris_kcf> sorry, little mistake...
06:18:15 <quicksilver> fenris_kcf: yes. It's ambiguous on its own
06:18:25 <ivanst> egads
06:18:30 <ivanst> fx5 dies so nicely
06:18:33 <quicksilver> fenris_kcf: however, neutral_element :: IntegerAddition would work
06:18:34 <fenris_kcf> meant: http://codepad.org/gxY7p01T
06:18:49 <opqdonut> yeah, what quicksilver said
06:18:50 <quicksilver> fenris_kcf: and in a wider context, the correct type can often be inferred from context.
06:18:52 <fenris_kcf> oh, i try that
06:19:00 <saml> fenris_kcf, that's too advanced for me
06:19:08 <opqdonut> or you can also say "test :: Monoid a => a"
06:19:10 <deech> Hi all, this is a rather odd question that I wouldn't ask of any other language but Haskell. But is there some way to do compile-time debugging with GHC? Specifically step through the type-checker to see how it got to the error.
06:19:15 <int-e> fenris_kcf: you're running into the monomorphism restriction, I think
06:19:33 <opqdonut> deech: no, not really
06:19:42 <quicksilver> int-e: he is but I don't think it's the *root* of his problem. It merely affects how the symptom presents :)
06:19:43 <opqdonut> deech: add more type declarations, that'll usually help
06:19:55 <saml> maybe run debugger on ghc source?
06:20:06 <opqdonut> saml: that most probably will not be helpful
06:20:09 <fenris_kcf> ok, :: TYPE works
06:20:13 <fenris_kcf> thank you, guys
06:21:09 <saml> can i undo +1 ?
06:22:03 <deech> If not a debugger, is there a way to get the compiler to give me a "stack trace"?
06:22:06 <Kaidelong> @instances-importing Enum
06:22:07 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
06:22:13 <int-e> quicksilver: I guess you're right. Still, the symptom is very confusing in itself.
06:22:19 <quicksilver> agree.
06:22:27 <saml> deech, what are you trying to accomplish ?
06:22:41 <quicksilver> deech: I generally try smaller/simpler examples in ghci until I get one that type checks
06:22:45 <quicksilver> deech: and work back.
06:22:52 <quicksilver> I appreciate that's not what you're asking for but...
06:22:57 <ivanst> saml: that spinlock on FX5 should be gone now... feel free to go see the app :D
06:23:02 <b_jonas> I agree, add more type annotations, that usually makes errors easier to understand
06:23:18 <deech> quicksilver: Sure, that's what I do now.
06:23:34 <b_jonas> also, getting higher-order types right is difficult
06:23:56 <saml> ivanst, u the best haskell programmer in the planet
06:24:05 <deech> saml: I am trying to understand some tricky delimited continuation source code and I'd like to know how the types resolve.
06:24:25 <saml> deech, test case?
06:24:55 <b_jonas> deech: assign stuff to global variables, load the module in ghci, use the :type command on them
06:25:20 <deech> saml: Are you asking me to write test cases or give you an example of one?
06:26:03 <b_jonas> you could also try printing types with Typeable
06:26:11 <saml> deech, either or both
06:26:24 <saml> yah what b_jonas said
06:26:28 <deech> b_jonas: Yup, that's what I've been doing. The compiler debugger/stacktrace thing was a longshot.
06:27:11 <b_jonas> also maybe there's some template haskell magic?
06:27:14 <deech> b_jonas: But you got to admit, it would have been nice :)
06:27:15 <b_jonas> no, probably no
06:27:42 <b_jonas> dunno, I like debugging with printfs
06:28:03 <joe6> how about trace?
06:28:26 <deech> b_jonas: So do I, but I'd like to do it at the type level.
06:40:06 <Kaidelong> I just wrote a comment "the redundant bounds checks are done to prevent pred or succ from failing"
06:40:46 <Kaidelong> although I will refactor the code a bit to avoid that
06:40:55 <Eduard_Munteanu> > pred 0
06:40:56 <lambdabot>   -1
06:41:00 <Kaidelong> > pred ()
06:41:02 <lambdabot>   *Exception: Prelude.Enum.().pred: bad argument
06:41:22 <Eduard_Munteanu> Ah, I see.
06:42:02 <Kaidelong> I wrote this neat little fill algorithm
06:42:03 <Eduard_Munteanu> Wouldn't something like Ix make more sense though?
06:42:09 <Kaidelong> then thought of all the ways it could fail
06:42:15 <Kaidelong> and now it has ballooned
06:42:21 <Kaidelong> the only thing that Ix implies is Ord
06:42:36 <EvanR> Ix also implies consecutive?
06:42:54 <Kaidelong> class Ord a => Ix a where
06:43:07 <EvanR> an unwritten rule
06:43:33 <Kaidelong> but yeah for the algorithm I need a context (Ix index, Enum index, ..)
06:44:02 <Kaidelong> it is being written to test dungeons for an as yet unimplemented roguelike
06:44:16 <Kaidelong> so it really has to be polymorphic
06:44:50 <quicksilver> Kaidelong: I would not worry unduly about a few contexts.
06:44:59 <quicksilver> Kaidelong: Ix index,Enum index isn't going to hurt you.
06:45:32 <Kaidelong> yeah but the fact that pred and succ are partial functions has caused me to add a lot of complexity to the algorithm
06:46:34 <mreh> :t succ
06:46:35 <lambdabot> forall a. (Enum a) => a -> a
06:47:50 <EvanR> might want a different representation of grid squares
06:47:54 * Kaidelong removes one bounds check entirely when he realizes he doesn't need it
06:48:53 <Kaidelong> fill' is always called from fill which will never call fill' with an out of bounds index.
06:51:47 <hpaste> “Mukesh Tiwari” pasted “Convex Hull ” at http://hpaste.org/49265
06:52:10 <bobzhang> hi, when you use quickCheck to find some errors, however, your randomized data is very complex, how do you guys re-cover the occassion? I am new to quickcheck, thank you
06:52:56 <hpaste> “Mukesh Tiwari” annotated “Convex Hull ” with “Convex Hull  (annotation)” at http://hpaste.org/49265#a49266
06:55:13 <keep_learning> Could some one please tell me if I pass some thing as instance of Num to sqrt function , why it  is giving error.  http://zvon.org/other/haskell/Outputprelude/Num_c.html looking at  here shows that Double is also instance of Num
06:55:41 <Kaidelong> @ty sqrt
06:55:42 <lambdabot> forall a. (Floating a) => a -> a
06:55:45 <keep_learning> Basically my code is complaining some thing which i am not able to understand http://hpaste.org/49265
06:56:05 <Kaidelong> keep_learning: sqrt needs a Floating. Num isn't strong enough.
06:56:12 <keep_learning> Kaidelong: so Floating is not part of Num
06:56:19 <Kaidelong> Floating implies Num
06:56:25 <Kaidelong> and Double is an instance of Floating
06:56:32 <keep_learning> Kaidelong: pardon me if this question is stupid
06:56:35 <quicksilver> ...but Num does not imply Floating.
06:56:43 <Kaidelong> it doesn't?
06:56:45 <quicksilver> so the point is that not *all* Nums are floating.
06:56:53 <Kaidelong> oh
06:56:55 <Kaidelong> I misread
06:56:59 <Kaidelong> yes, Num doesn't imply Floating
06:57:11 <Kaidelong> basically, keep_learning, just swap out Num for Floating
06:57:12 <EvanR> id like an integer square root
06:57:14 <quicksilver> so your type can't be helpSqrt :: ( Num a , Ord a ) => Point a -> Point a ->  a
06:57:25 <quicksilver> because that doesn't work for *all* Nums - only floating ones.
06:57:47 <Kaidelong> it does strike me strange that sqrt takes Floating rather than Num
06:57:58 <Kaidelong> perhaps it is a machine related consideration
06:58:12 <EvanR> Kaidelong: algorithms to do square root will require division, Num doesnt do division
06:58:25 <quicksilver> Kaidelong: what would you like sqrt of a rational to be?
06:58:36 <Kaidelong> oh hmm, I didn't think of rationals
06:58:39 <keep_learning> quicksilver: so should i need to write helpSqrt :: (Num a , RealFloat a ) -
06:58:41 <Kaidelong> yeah good point
06:59:00 <Kaidelong> but an integer square root would be nice
06:59:04 <quicksilver> keep_learning: (Floating a) should be sufficient
06:59:11 <quicksilver> Floating implies Num anyway.
06:59:29 <quicksilver> Kaidelong: it would, and there should be one, but it should probably have another name.
06:59:37 <Kaidelong> yeah
06:59:38 <EvanR> you might say integer square root doesnt give you a real square root, since (isqrt n)^2 isnt n, but the same can be said of Floating
06:59:59 <EvanR> ;)
07:00:03 <Kaidelong> yeah but in the case of Floating it is n within the error of your machine's calculations
07:00:05 <quicksilver> EvanR: isqrt might be an acceptable instance of square root but there really isn't a good answer for Rational.
07:00:18 <EvanR> quicksilver: right
07:00:28 * JuanDaugherty doesn't see how integer root makes sense, floor or ciel of maybe
07:00:30 <Kaidelong> so a separate isqrt would be nice
07:00:31 <EvanR> im only talking about integer square roots, it doesnt make sense for rational
07:00:45 <Kaidelong> JuanDaugherty: you use the floor
07:00:50 <EvanR> JuanDaugherty: thats the implication
07:01:00 <EvanR> Kaidelong: and an imlpementation hopefully wouldnt use floor
07:01:07 <Kaidelong> yeah
07:01:09 <EvanR> implying that you switch to double in the middle
07:01:21 <quicksilver> JuanDaugherty: "integer square root" is fairly conventional to mean the largest integer less than the real square root
07:01:21 <EvanR> implying you cant sqrt numbers bigger than N
07:01:25 <JuanDaugherty> actually there should be somekina interval about the real root generalization
07:01:27 <quicksilver> JuanDaugherty: (i.e. what you meant by 'floor')
07:01:34 <JuanDaugherty> that would seem to be the haskell way
07:02:05 <Kaidelong> but integer square roots are a conventional term for mathy people like quicksilver said
07:02:28 <EvanR> conventional term for me who wants to do planar math on a fixed point grid
07:03:23 <keep_learning> quicksilver: now its complaning about truncate function which i used for taking only integer value in solve function
07:03:56 <quicksilver> keep_learning: well, truncate always returns an integer.
07:03:57 <Ptival> bobzhang: didn't understand your question :\
07:04:17 <quicksilver> if you want to upgrade that back to another Num type you can use fromIntegral
07:04:21 <quicksilver> > truncate 4.37
07:04:22 <lambdabot>   4
07:04:27 <quicksilver> > fromIntegral (truncate 4.37)
07:04:28 <lambdabot>   4
07:04:32 <quicksilver> > fromIntegral (truncate 4.37) :: Double
07:04:33 <lambdabot>   4.0
07:05:01 <EvanR> floatTrunc = fromIntegral . truncate
07:05:12 * quicksilver nods
07:05:38 * hackagebot fsmActions 0.4.3 - Finite state machines and FSM actions  http://hackage.haskell.org/package/fsmActions-0.4.3 (AndyGimblett)
07:06:20 <Kaidelong> quicksilver: isn't that just a fancy way of saying "floor"?
07:06:23 <Kaidelong> @ty floor
07:06:24 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
07:06:28 <Kaidelong> oh
07:06:30 <Kaidelong> no it isn't
07:06:37 <EvanR> :t truncate
07:06:39 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
07:06:49 <Kaidelong> lovely
07:06:57 <quicksilver> Kaidelong: well, floor and truncate are different for negaitve numbers
07:07:00 <EvanR> :t round
07:07:01 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
07:07:08 <Kaidelong> @check \x -> truncate x == floor x
07:07:10 <lambdabot>   "Falsifiable, after 2 tests:\n-2.6666666666666665\n"
07:07:18 <EvanR> i dont want to know what round means
07:07:18 <Kaidelong> ooooh
07:07:20 <quicksilver> > truncate && &floor $ -3.5
07:07:20 <Kaidelong> that's the difference
07:07:21 <lambdabot>   <no location info>: parse error on input `&'
07:07:25 <quicksilver> > truncate  &&& floor $ -3.5
07:07:27 <lambdabot>   (-3,-4)
07:07:39 <Kaidelong> thanks quickcheck
07:07:46 <quicksilver> banker's rounding, IIRC.
07:07:55 <EvanR> what does bankers rounding mean for floating point
07:08:07 <quicksilver> > map round [-2.5,-1.5,-0.5,0.5,1.5,2.5,3.5]
07:08:08 <lambdabot>   [-2,-2,0,0,2,2,4]
07:08:10 <keep_learning> quicksilver: thank you all for the great help
07:08:11 <EvanR> (the answer really depends on the configuration of the floating point environment)
07:08:12 <quicksilver> yes, banker's rounding.
07:08:24 <quicksilver> EvanR: well, 0.5 is perfectly representable in base 2 floating point.
07:08:37 <quicksilver> EvanR: so it's not really ambiguos unless there is something fairly exotic about your setup.
07:08:50 <EvanR> quicksilver: k well here we had this statistical task: round to nearest hundreth
07:09:03 <EvanR> and javascript uses floats
07:09:05 <EvanR> so
07:09:06 <quicksilver> ah, well, hundredths aren't representable!
07:09:15 <EvanR> they are in String form
07:09:20 <EvanR> which was the desired result
07:09:33 <EvanR> the world sucks
07:09:40 * quicksilver nods.
07:10:00 <quicksilver> anyhow I thikn banker's rounding is a precise notion in all the common ways of formulating floating point
07:10:10 <quicksilver> in which the mantissa will always be either base 10 or base 2
07:10:17 <quicksilver> and 0.5 will be precisely representable.
07:10:30 <EvanR> it makes sense to me if were in base 10
07:10:41 <EvanR> and the critical threshold is 0.005
07:11:31 <EvanR> i guess you can multiply by 100, round, then divide by 100, then encode into base10
07:11:34 <Kaidelong> @hoogle (Enum a) => a -> Bool
07:11:35 <lambdabot> Test.QuickCheck.Batch isBottom :: a -> Bool
07:11:35 <lambdabot> Prelude pred :: Enum a => a -> a
07:11:35 <lambdabot> Prelude succ :: Enum a => a -> a
07:12:15 <EvanR> but considering the higher ups didnt have a clue about bankers rounding, we couldnt explain it to them, so they couldnt say 'ok sounds great'
07:12:27 <EvanR> so much for 'agile development'
07:12:59 <EvanR> lol isBottom ?
07:13:18 <Kaidelong> for non-bottoms, it returns false
07:13:41 <zygoloid> presumably, for bottoms it does not return false :)
07:13:41 <EvanR> for bottoms, it solves the halting problem
07:13:43 <Kaidelong> for bottoms, it returns either true or bottom, but you can't tell which one ahead of time, in general
07:13:54 <keep_learning> :t read
07:13:55 <lambdabot> forall a. (Read a) => String -> a
07:14:36 <EvanR> why did they forget an error condition for Read :(
07:14:55 <Kaidelong> you're supposed to use reads
07:14:59 <Kaidelong> or so I'm told
07:15:03 <Kaidelong> @ty reads
07:15:04 <EvanR> then whats the point
07:15:04 <lambdabot> forall a. (Read a) => String -> [(a, String)]
07:15:08 <EvanR> of read
07:15:10 <keep_learning> why defining a function  readF :: ( Num a , Read a ) => String -> a is giving error
07:15:15 <zygoloid> read is for quick-n-dirty scripting
07:15:24 <zygoloid> like head :)
07:16:24 <Kaidelong> @hoogle [a] -> Maybe a
07:16:25 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
07:16:26 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
07:16:26 <lambdabot> Prelude head :: [a] -> a
07:16:30 <EvanR> is Pointed popular? (im reading typeclassopedia)
07:17:04 <keep_learning> EvanR: i did not get you
07:17:17 <keep_learning> EvanR: did i do some thing wrong
07:17:28 <EvanR> what
07:18:01 <keep_learning> i am trying to map read over  list of string and trying to get which is instance of Num class [ Double , Float , Int , Integer ]
07:18:36 <EvanR> thats weird
07:18:39 <keep_learning> EvanR: readF :: ( Num a , Read a ) => String -> a is giving error
07:18:50 <EvanR> isInstance ?
07:18:56 <mauke> keep_learning: no, it isn't
07:20:19 <keep_learning> mauke: so how to solve this problem ?
07:20:28 <mauke> what problem?
07:20:41 <ryant5000> is there a reason that cycles are disallowed in superclasses when they go through associated types?
07:21:15 <ryant5000> i have: class (C (A x)) => C x where type A x :: *
07:21:30 <quicksilver> ryant5000: BZZZT. You have asked a level 12 question in a level 9 forum. You will not receive a useful answer. Please advance to a higher plane.
07:21:35 <hpaste> “Mukesh Tiwari” annotated “Convex Hull ” with “Convex Hull  (annotation)” at http://hpaste.org/49265#a49268
07:21:37 <ryant5000> quicksilver: lol
07:22:09 <hpaste> “Mukesh Tiwari” annotated “Convex Hull ” with “Convex Hull  (annotation) (annotation)” at http://hpaste.org/49265#a49269
07:22:18 <quicksilver> ryant5000: I have no idea :) I've never even formulated that question before - but I know that SPJ rewrote the superclass constraints code in the latest GHC HEAD.
07:22:30 <ryant5000> ah
07:22:33 <keep_learning> mauke: http://hpaste.org/49265
07:22:36 <quicksilver> ryant5000: perhaps you can break the loop with a superclass equality?
07:22:42 <ryant5000> hm
07:22:44 <ryant5000> that might do it
07:22:46 <keep_learning> mauke: my main function is giving me error
07:23:00 <quicksilver> ryant5000: but superclass equalities only work properly in the latest and greatest.
07:23:07 <ryant5000> hm
07:23:11 <ryant5000> well, i guess i'll try head
07:23:26 <quicksilver> ryant5000: otherwise I guess post to glasgow-haskell-users.
07:23:30 <keep_learning> i am reading input from stdin and trying to get a   list of instance Num but its not working
07:23:42 <ryant5000> it would be a great shame to have to get rid of all my polymorphism for these things :-/
07:23:44 <mauke> keep_learning: that's a straight up type error
07:23:59 <EvanR> quicksilver: is that higher plane thing a quote?
07:24:07 <quicksilver> ryant5000: (http://www.haskell.org/pipermail/glasgow-haskell-users/2011-June/020522.html)
07:24:11 <quicksilver> EvanR: nope
07:24:14 <mauke> keep_learning: format takes [[a]]; you're giving it [a]
07:24:19 <EvanR> quicksilver: well it should be
07:24:53 <ryant5000> quicksilver: yeah, i saw that post; hopefully  his change will also magically let me have my cycle :)
07:25:22 <keep_learning> mauke: ohhh ,
07:25:27 <keep_learning> mauke: thank you
07:27:43 <Saizan> i guess they forgot to special case type families, for type constructors it makes sense: class C (Maybe x) => C x where {} is not really usable
07:30:50 <ryant5000> Saizan: yeah; it's a kind of weird thing that i'm doing
07:30:55 <ryant5000> possibly what i'm doing isn't actually sensible
07:30:59 <ryant5000> but it seems sensible to me right now
07:45:39 <fenris_kcf> another question: is it possible to use values as type-parameters? example (not working):
07:45:39 <fenris_kcf> data Tuple t Int = Tupel [t]
07:45:51 <mauke> no
07:45:53 <fenris_kcf> *Tuple*
07:46:04 <fenris_kcf> hmm, some kind of workaround?
07:46:31 <mauke> data Tuple t = Tuple [t]
07:46:47 <fenris_kcf> :? yes, thx
07:47:04 <fenris_kcf> maybe this wasn't a very good example...
07:47:33 <fenris_kcf> data Galoisfield Int = Galoisfield Int
07:47:44 <fenris_kcf> where the left Int determines the modulus
07:47:50 <fenris_kcf> and the right Int the value
07:48:01 <fenris_kcf> for example [5] in F_7
07:48:14 <mauke> define your own numbers in types
07:48:16 <EvanR> if >>= is called 'bind' then what is <*> called
07:48:27 <mauke> EvanR: ap
07:48:34 <EvanR> :t ap
07:48:35 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
07:48:46 <EvanR> :t (<*>)
07:48:48 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
07:48:52 <EvanR> interesting
07:49:21 <Kaidelong> ghci doesn't like "runST . freeze . doStuff . thaw"
07:49:36 <Kaidelong> what language extension do I need to make that work?
07:50:24 <Kaidelong> it complains that I'm not using s in my type signature, I think
07:50:30 <Kaidelong> which is the point entirely
07:50:47 <Kaidelong> Quantified type variable `s' escapes
07:50:50 <Kaidelong> is the error
07:51:11 <b_jonas> wli: try rewriting it without the dots
07:51:14 <b_jonas> um
07:51:21 <b_jonas> ->Kaidelong
07:52:32 <fenris_kcf> mauke: what do you mean by that?
07:52:54 <Kaidelong> @unpl (runST . freeze . doStuff . thaw)
07:52:55 <lambdabot> (\ c -> runST (freeze (doStuff (thaw c))))
07:54:09 <mauke> fenris_kcf: http://okmij.org/ftp/Haskell/number-parameterized-types.html  http://okmij.org/ftp/Haskell/types.html#Prepose
07:56:36 <fenris_kcf> thank you, mauke
07:56:55 <EvanR> Writer uses Monoid mappend to accumulate a log. isnt this inefficient for that purpose?
07:57:18 <EvanR> especially with [a]
07:57:33 <b_jonas> EvanR: no
07:58:06 <EvanR> [5,3,5,2,3,4,5,6] `mappend` [0]
07:58:11 <b_jonas> EvanR: it folds to the right direction
07:58:26 <b_jonas> so it prepends stuff instead of appending
07:58:29 <b_jonas> that also makes it lazy
07:58:55 <EvanR> ok
07:59:09 <EvanR> [5] `mappend` [3] `mappend` [5] `mappend` ...
07:59:36 <b_jonas> it would be inefficient if you used State to keep a log and append to it, and it would alos be non-lazy
07:59:51 <b_jonas> you couldn't read the start of the log without running everything that way
08:00:02 <b_jonas> but with Writer you can
08:00:04 <EvanR> i didnt think of the lazy
08:00:07 <EvanR> thats the key
08:00:25 <aninhumer> Essentially Haskell laziness makes append work like an amortised queue?
08:01:46 <EvanR> if you 'force evaluation' of the entire log though, seems like it will get slower and slower for a long list
08:02:54 <b_jonas> EvanR: would it now? I don't think so
08:03:10 <gpampara> Would there be a "limit" of sorts on how much is logged? Or would the writer's list be infinite in a way?
08:03:21 * EvanR tries to play computer to evaluate [0]++[1]++[2]++[3]...
08:03:29 <EvanR> [0,1]++[2]
08:03:36 <EvanR> [0,1,2]++[3]++...
08:03:43 <aninhumer> It's right associative iirc?
08:04:15 <EvanR> then you cant read the beginning
08:04:29 <EvanR> er
08:04:31 <EvanR> confused
08:04:40 <c_wraith> EvanR: I think doing it that way is a good way to confuse yourself
08:06:25 <aninhumer> you end up with a lazy (++) [1] $ (++) [2] $ (++) [3] thunk I think
08:06:48 <aninhumer> So performance is O(n+m) where m is the number of appends?
08:07:33 <aninhumer> Actually I guess m < n so O(n)
08:07:34 <EvanR> i think i got it, but i dont think id be able to explain it
08:07:53 <c_wraith> @src concat
08:07:54 <lambdabot> concat = foldr (++) []
08:08:05 <c_wraith> concat is O(output size)
08:08:21 <EvanR> [0]++([1]++([2]++([3]++...
08:08:42 <c_wraith> yes, that breakdown is correct, because ++ is right-associative
08:09:32 <dainanaki> For those of you that have written enumerator libraries, how do you test them?
08:09:34 <benmachine> EvanR: I think Writer *is* inefficient
08:09:38 <benmachine> EvanR: with [a]
08:09:39 <aninhumer> And because Haskell is lazy, you don't need to do the O(n) append until you're doing an O(n) lookup or whatever
08:09:57 <benmachine> EvanR: you can get around this by using the DList representation
08:10:08 <EvanR> in view 1, i can imagine a pacman evaluator eating the left hand side of starting from the top most tree
08:10:19 <EvanR> or in view 2 i imagine grade school where we evaluate inside parentheses first
08:10:41 <benmachine> EvanR: it's called "outermost-first" for a reason :P
08:10:43 <c_wraith> yeah, writer ends up being ((([0] ++ [1]) ++ [2]) ++ [3])
08:10:46 <EvanR> benmachine: so i was somehow right frmo the beginning?
08:10:56 <benmachine> EvanR: yes
08:10:58 <EvanR> lol
08:11:01 <benmachine> well
08:11:05 <benmachine> not completely
08:11:08 <benmachine> it's inefficient for [a]
08:11:10 <benmachine> but not in general
08:11:21 <EvanR> sucks
08:11:27 <benmachine> the efficiency depends on what monoid type you use
08:11:31 <c_wraith> writer is essentially a left-fold.
08:11:35 <EvanR> something like this could bite a noob
08:11:43 <EvanR> stack over flow
08:12:06 <c_wraith> There are reasons there are warnings *everywhere* about using [a] with writer
08:12:15 <EvanR> havent seen any
08:12:17 <benmachine> c_wraith: I'm not sure that's right - you can have a writer that 'tell's infinitely many times
08:12:21 <benmachine> and still produces a result
08:12:33 <c_wraith> Hmm.  That's true
08:12:41 <EvanR> benmachine: now im confused
08:12:47 <benmachine> EvanR: tbh so am I
08:12:49 <c_wraith> In fact, you can do infinite tells with a DList and it works.
08:12:50 <benmachine> hth
08:12:55 <EvanR> no one knows how Writer works! ;)
08:13:05 <c_wraith> or even list
08:13:10 <benmachine> no I know exactly how it's defined but I haven't thought much about what happens then
08:13:26 <benmachine> it *does* produce results lazily, I know that because I've relied on it in the past
08:13:34 <c_wraith> > runWriter (forever $ tell [0])
08:13:37 <lambdabot>  Terminated
08:13:41 <benmachine> but I'm sure I've heard of it being inefficient
08:13:50 <EvanR> [0]++([1]++([2]++([3]++...
08:13:53 <c_wraith> heh.  well, that one fails
08:14:05 <benmachine> > take 30 . execWriter . forever . tell $ [0]
08:14:06 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
08:14:38 <c_wraith> oh.  it failed because I used runWriter
08:14:42 <benmachine> yep
08:14:48 <c_wraith> it would have been fine with execWriter
08:14:51 <benmachine> yep
08:14:55 <c_wraith> > execWriter (forever $ tell [0])
08:14:57 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
08:15:26 <EvanR> so if i have a writer that never ends and tells forever, the rest of my program can continue without it and read the log on demand?
08:15:32 <EvanR> without threads?
08:15:48 <benmachine> it depends on what monoid you're using
08:15:53 <benmachine> but yes
08:15:53 <EvanR> []
08:16:04 <benmachine> oh, then as demonstrated above, yes
08:16:14 <EvanR> k then were saved, i like things simple
08:16:25 <EvanR> also, wtf, how many other things can i do like this without threads
08:16:30 <benmachine> (I still reckon I've heard about writer being inefficient on lists though)
08:16:46 <Kaidelong> still having trouble getting runST to typecheck
08:16:52 <EvanR> maybe that was some pedant talking about the efficiency of ++ [single element]
08:17:17 <c_wraith> Kaidelong: hpaste the code
08:17:19 <Eduard_Munteanu> AFAIK it uses (++) the right way for efficiency
08:17:32 <benmachine> Eduard_Munteanu: how can it? it receives elements from left to right
08:18:00 <benmachine> oh or does it
08:18:06 <benmachine> I think I am thinking about it the wrong way
08:18:08 <benmachine> and it's actually fine
08:18:15 <c_wraith> Well.
08:18:16 <clsmith> :t tell
08:18:17 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
08:18:30 <c_wraith> I think it would fail utterly for strict Writer
08:18:33 <hpaste> Kaidelong pasted “runST type error” at http://hpaste.org/49273
08:18:40 <c_wraith> but it's ok for lazy Writer
08:18:51 <Kaidelong> I'm thinking I am missing a LANGUAGE
08:18:56 <Kaidelong> that I need to be able to use runST
08:19:14 <c_wraith> Kaidelong: GHC would need to infer impredicative types for that to work
08:19:20 <aristid> heh, http://www.cynic.net/tsac.html
08:19:26 <EvanR> m >>= k = Writer (b, w `mappend` w') where
08:19:30 <c_wraith> Kaidelong: and that's never going to happen.  So....
08:19:47 <Kaidelong> well where do I put the type annotation then?
08:19:51 <EvanR> so theres two kinds of writer strict and lazy?
08:20:05 <benmachine> ah, it depends how you use the thing
08:20:07 <c_wraith> Kaidelong: you can't fix that with a type annotation.
08:20:19 <Eduard_Munteanu> EvanR: yeah, just like Strict / Lazy State
08:20:35 <c_wraith> Kaidelong: you fix that by making it not point-free.  The problem is that (.) doesn't have an impredicative type.
08:21:00 <EvanR> looking at Lazy vs Strict implementation of >>= i dont see how its different
08:21:14 <benmachine> EvanR: the difference is subtle, and it's let vs. case on the tuple
08:21:16 <EvanR> in terms of strictness
08:21:23 <benmachine> irrefutable or refutable matching
08:21:33 <EvanR> gah
08:21:35 <benmachine> http://learnyouahaskell.com/for-a-few-monads-more#writer this has some stuff about how writer can be inefficent
08:21:36 <EvanR> this is black magic
08:21:40 <benmachine> it's not intrinsic it's just how you use it
08:21:46 <Kaidelong> okay
08:21:46 <Eduard_Munteanu> IIRC State used ~ to get it lazier
08:21:48 <parcs> how does (a `mappend` b) `mappend` c get changed to a `mappend` (b `mappend` c) ?
08:21:55 <benmachine> Eduard_Munteanu: equivalent to using let
08:21:55 <Kaidelong> now it wants me to add extra contexts
08:21:57 <parcs> and why would it?
08:22:02 <benmachine> parcs: it doesn't
08:22:09 <EvanR> parcs: it doesnt put parentheses
08:22:16 <EvanR> it looks like a `mappend` b `mappend` c
08:22:22 <EvanR> so its right assoc
08:22:56 <Fuco> Data.IORef is stored inside IO monad, something like a state in State monad? Do I get it right?
08:23:03 <parcs> EvanR: why?
08:23:08 <benmachine> EvanR: don't worry about the difference between lazy/strict writer or state. if the strict one loops forever, use lazy, if the lazy one is slow, use strict
08:23:20 <EvanR> benmachine: why is the lazy one slow?
08:23:34 <benmachine> EvanR: it isn't necessarily, but unnecessary laziness is usually bad for performance
08:24:03 <benmachine> EvanR: because it means holding on to computations to do them later, which wastes memory if they're definitely going to be done anyway
08:24:11 <albertid> whats the preferred way to connect a Control.Concurrent.Chan.Chan with gtk2hs? I want to update the window everytime something is read on the chan.
08:24:17 <EvanR> on a related matter, this is exactly the sort of thing that noobs will point at when they say its incomprehensible, whats strict, whats lazy
08:24:30 <benmachine> EvanR: in this particular case you can do pretty well by ignoring it
08:24:52 <benmachine> the libraries don't make you choose in general
08:24:56 <EvanR> well ive been writing custom monads instead of going through the transformer hoops
08:25:02 <benmachine> there's a "default" one which is the lazy one
08:25:08 <EvanR> and now im wondering if they are accidentally lazy or strict when i didnt want them to be
08:25:09 <c_wraith> Kaidelong: so (.) strips out the (forall s.), meaning the argument to runST isn't polymorphic enough
08:25:09 <parcs> so is `tell` quadratic wrt lists?
08:25:09 <c_wraith> Kaidelong: also, you could use unsafeFreeze there.  (You need to still use the safe thaw, though)
08:25:09 <c_wraith> Kaidelong: actually, you could just make it runSTArray, which does the unsafeFreeze and runST together
08:25:24 <Kaidelong> @hoogle runSTArray
08:25:25 <lambdabot> Data.Array.ST runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
08:25:36 <benmachine> parcs: depends which order you do it in, I think
08:26:01 <benmachine> parcs: see http://learnyouahaskell.com/for-a-few-monads-more#writer (scroll down a bit, to the section on inefficient list construction)
08:26:03 <clsmith> EvanR: seems to me like there just needs to be an easy tool for checking
08:26:28 <EvanR> clsmith: might as well be a tool to write code for you too ;)
08:26:51 <Kaidelong> @hoogle freeze
08:26:51 <lambdabot> Data.Array.MArray freeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
08:26:51 <lambdabot> Data.Array.MArray unsafeFreeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
08:26:53 <clsmith> EvanR: once AI can write my code for me, i will be a happier man
08:27:03 <Kaidelong> runSTArray isn't quite the same thing
08:27:05 <EvanR> hahaha clint eastwood
08:27:22 <aninhumer> gotta love LYAH
08:27:31 <c_wraith> Kaidelong: err.  there's also runSTUArray
08:27:43 <Kaidelong> @hoogle runSTUArray
08:27:44 <lambdabot> Data.Array.ST runSTUArray :: Ix i => ST s (STUArray s i e) -> UArray i e
08:27:45 <dcoutts> albertid: remember that the control flow for drawing to the screen is reversed, you draw when the window system asks, via an expose event
08:27:48 <Kaidelong> hmm
08:28:10 <c_wraith> Kaidelong: since I assume you're using an unboxed array
08:28:11 <dcoutts> albertid: what you really need is an MVar or IORef containing the current state used as the source info for the drawing, and to read from that when you get an expose event
08:28:39 <Kaidelong> c_wraith: Not known at that point in the code
08:28:40 <dcoutts> albertid: then when you want to change the display, you set the new state, invalidate the widget and wait for the expose event
08:28:41 <albertid> dcoutts, ok, but I still have to trigger the expose event
08:28:53 <dcoutts> albertid: exactly, that's what the invalidate does
08:28:59 <albertid> dcoutts, ah ok
08:29:03 <Kaidelong> do I have to choose?
08:29:52 <c_wraith> Kaidelong: I guess not, if you stick with thaw and freeze/unsafeFreeze.  (if the unsafeFreeze is the last thing before runST returns, it's never unsafe)
08:31:07 <albertid> dcoutts, so would it be the best to 1) use a thread with a blocking reader and invalidate the display from another thread or 2) use timeoutAdd to poll the chan within the same thread?
08:31:50 <EvanR> benmachine: k i completely dont understand lyah explanation on this
08:31:52 <dcoutts> albertid: assuming you're using threads already, I'd have a thread blocking reading the chan, it'd update the current state and invalidate
08:32:27 <parcs> benmachine: that doesn't explain why 'the list appending ends up [being fast]'
08:32:29 <albertid> dcoutts, ok thanks, I'll try that
08:32:32 <EvanR> benmachine: its confusing my by using ++ for mappend and list ++
08:32:34 <dcoutts> albertid: note that the nice thing about this invalidate malarkey is that you can invalidate several times in quick succession and only pay for one render
08:32:58 <dcoutts> albertid: because the expose event happens slightly later when the GUI event loop is otherwise idle
08:33:13 <albertid> dcoutts, I see
08:33:57 <benmachine> parcs: that's just how the calls are associated if you do things that way
08:34:09 <benmachine> EvanR: I'm pretty sure it only uses ++ when it's talking about lists
08:34:12 <parcs> benmachine: oh, i see why. but that's only relevant when recursing
08:34:34 <benmachine> parcs: pretty much. not exactly a rare thing to do :)
08:34:36 <parcs> what about do { tell "foo"; tell "foo"; tell "foo" } ?
08:35:09 <benmachine> I think it depends on how the >>=s are associated
08:35:25 <EvanR> i dont get why recursing should matter, if the 'order' of the tells are the same
08:35:35 <parcs> >>= is left-associated
08:35:42 <benmachine> parcs: in do-notation it isn't
08:35:42 <EvanR> doesnt >>= associate to the right just like mappend
08:35:57 <benmachine> >>= is infixl 1
08:36:04 <benmachine> but in practice it associates right because
08:36:21 <benmachine> do p <- x; f p translates to x >>= \p -> f p
08:36:33 <benmachine> and then the lambda means that it associates how you want it to
08:36:38 <parcs> ah right
08:36:39 <benmachine> (to the right)
08:36:51 <EvanR> wh
08:36:54 <EvanR> eh
08:36:57 <benmachine> and recursive calls usually appear at the end of your blocks
08:36:59 <EvanR> lambda does what?
08:37:23 <benmachine> EvanR: the translation of do leads to right-association
08:37:36 <EvanR> why?
08:37:53 <EvanR> because it cant evaluate the lambda further?
08:37:57 <parcs> EvanR: a >>= \b -> f b   is a >>= (\b -> f b)
08:38:07 <parcs> lambdas are greedf
08:38:07 <benmachine> well, no, just because the lambda syntactically extends over the rest of the block
08:38:09 <parcs> y*
08:38:27 <EvanR> obviously i didnt think (a >>= \b) -> f b
08:38:50 <benmachine> @undo do p <- x; q <- y; r <- z; return (f p q r)
08:38:50 <lambdabot> x >>= \ p -> y >>= \ q -> z >>= \ r -> return (f p q r)
08:39:01 <parcs> well the point is lambdas extend all the way to the right
08:39:12 <benmachine> yeah
08:39:14 * Kaidelong spots his problem
08:39:14 <EvanR> interesting
08:39:20 <benmachine> maybe associativity is the wrong word to use in this case
08:39:33 <EvanR> so its not x >>= (\p -> y) >>= (\q -> z) >>=
08:39:36 <Kaidelong> doSomething is ST s ()
08:39:38 <benmachine> no
08:39:44 <Kaidelong> oh wait no
08:39:47 <EvanR> but its not an associativity thing
08:39:52 <Kaidelong> doSomething indeed gives me back an array
08:39:56 <benmachine> EvanR: it sorta is a bit
08:40:01 <benmachine> maybe
08:40:04 <EvanR> lol
08:40:13 <EvanR> ok and recursion affects this how
08:40:19 <Kaidelong> whoops no it doesn't
08:40:23 <Kaidelong> I was right the first time
08:40:26 <EvanR> (including forM_ and forever?)
08:40:30 <benmachine> EvanR: if you have gcd' x = tell somthing; gcd' (f x)
08:40:32 <benmachine> then that's fine
08:40:43 <benmachine> the mappends associate the right way
08:40:55 <benmachine> if you have gcd' x = do gcd' (f x); tell something
08:40:59 <benmachine> then that's bad
08:41:07 <benmachine> the mappends associate the wrong way
08:41:11 <EvanR> now thats tricky
08:41:27 <benmachine> if you use dlist it's all fine
08:41:32 <EvanR> and if forM and forever do not do tell inside themselves, were ok?
08:41:33 <benmachine> ish.
08:41:49 <benmachine> EvanR: we're ok either way because they recurse the nice way
08:42:02 <benmachine> but if you try to tell something "after" a forever, obviously that's not going to work :P
08:42:11 <benmachine> (this is all assuming we use the list monoid)
08:42:37 <benmachine> or a mappend with the same laziness properties as ++ anyway
08:42:46 <EvanR> always tell before a recursive call
08:42:54 <EvanR> with []
08:43:01 <benmachine> EvanR: or use dlist
08:43:05 <benmachine> or don't worry
08:43:08 <benmachine> those are your options
08:43:18 <benmachine> it will only affect performance, not correctness
08:43:18 <EvanR> not worrying led me to stack overflow before
08:43:22 <benmachine> ah
08:43:25 <benmachine> well worry then :P
08:43:30 <EvanR> which is not easy to debug!
08:44:00 * benmachine hasn't ever really had to debug something like tht
08:44:18 <benmachine> I think the ways I use haskell mean I only ever get to see the nice bits
08:44:32 <mercury^> :>
08:44:40 <EvanR> in that case i loaded a very large String and tried to 'parse' it with basic [Char] functions
08:44:40 <mercury^> benmachine: are you still working on tremulous by the way?
08:45:04 <EvanR> in another case the ffi lib i was using segfaulted
08:45:06 <EvanR> :(
08:45:14 <benmachine> mercury^: I don't have time at the moment but in the long term yes
08:45:25 <EvanR> what do you do for tremulous?
08:45:31 <benmachine> write C
08:45:34 <benmachine> more fool me
08:46:12 <benmachine> oh and I also wrote the master server, which is python
08:46:32 <benmachine> which if it annoys me again by being too python I may have to bin it and replace it with a haskell one :>
08:46:36 <parcs> why is >>= left-associative?
08:46:42 <EvanR> seems like servers are a good application for haskell
08:46:57 <Vaerros> tremulous was awesome when I played it. that is all.
08:47:04 <benmachine> EvanR: the only thing that worries me is memory leaks, but I think the python master has one of those anyway
08:47:05 <alpounet> parcs, there was a discussion about this on Google+ iirc
08:47:39 <EvanR> benmachine: memory leak from what?
08:48:15 <benmachine> EvanR: hanging on to things too much? I don't know
08:48:20 <EvanR> hmmm
08:48:34 <EvanR> i wish i understood the gc to know that it will behave ;)
08:48:39 <benmachine> heh
08:48:50 <benmachine> it might well do
08:48:59 <mercury^> parcs: I guess it is so that the >>= \x -> ... style works
08:49:02 <benmachine> but I've not done long-running processes before, so I've not worried about it in the past
08:49:07 <EvanR> 'hanging onto' and 'not hanging onto' is pretty operational reasoning, and doesnt make sense in haskell :(
08:49:14 <benmachine> mercury^: hmm? surely it makes no difference there
08:49:50 <benmachine> more interesting is something like foo >>= bar >>= baz
08:49:57 <parcs> hmm
08:50:10 <benmachine> in that case (foo >>= bar) >>= baz makes more sense
08:50:14 <parcs> alpounet: link?
08:50:16 <benmachine> because (bar >>= baz) is probably not a function
08:50:18 <scooty-puff> :t everywhere
08:50:19 <lambdabot> forall a. (Data a) => (forall a1. (Data a1) => a1 -> a1) -> a -> a
08:50:26 <scooty-puff> is there a way to go from a b -> a c?
08:50:32 <scooty-puff> in my case:
08:50:32 <parcs> >> is also infixl
08:50:38 <scooty-puff> Exp String -> Exp Name
08:51:11 <benmachine> scooty-puff: everywhere in a structure? you'd have to change the type of the structure
08:51:11 <EvanR> left assoc, so that means in a >> b >> c >> d, it evaluates d c b before a?
08:51:36 <benmachine> EvanR: no, it just means that you get ((a >> b) >> c) >> d
08:51:55 <benmachine> EvanR: which means the last >> is the "root" of the expression tree
08:52:01 <scooty-puff> benmachine: i'm not sure if i follow - what i have now is nameExp, nameStmt, nameDec, etc., that deconstruct each type, when only a few cases do i care about it
08:52:10 <scooty-puff> o, forgot, its:
08:52:19 <scooty-puff> Exp String -> Namer (Exp Name)
08:52:25 <EvanR> benmachine: ah so if d is Nothing, the whole thing is Nothing and you didnt even have to check the preceeding values
08:52:29 <benmachine> scooty-puff: I'm going to go home now so someone else can talk to you
08:52:34 <scooty-puff> benmachine: k
08:52:41 <benmachine> EvanR: yeah, basically
08:52:44 <EvanR> nice
08:52:58 <EvanR> in my mine it had to check a, then b, then c...
08:53:02 <EvanR> until it found nothing
08:53:47 <benmachine> EvanR: actually I'm not sure if that example works exactly
08:53:55 <EvanR> :S
08:53:55 <benmachine> with the way >>= is defined
08:54:04 <benmachine> I'll think about it more later
08:54:12 * EvanR looks up >>
08:54:15 <benmachine> but >> checks its left argument first
08:54:19 <benmachine> in the case of Maybe
08:55:21 <EvanR> (Just _) >> k = k
08:55:26 <EvanR> Nothing >> _ = Nothing
08:56:03 <EvanR> left argument is always checked first?
08:57:50 <parcs> oh
08:57:50 <EvanR> or just in this case since its a constructor pattern match
08:57:57 <alpounet> parcs, can't find it sorry
09:00:07 <parcs> duh, it's left-associative to preserve the order of computation
09:01:54 <EvanR> parcs: i dont get it
09:02:21 <EvanR> it doesnt matter how you associate >>, its associative
09:03:27 <EvanR> er.. up to bottom....
09:03:36 <EvanR> confused again
09:04:58 <Eduard_Munteanu> Up to sequencing an infinite list of actions I suppose
09:05:44 <EvanR> > sequence (cycle [Just (), Just (), Just (), Nothing])
09:05:46 <lambdabot>   Nothing
09:06:17 <EvanR> it saw the Nothing at the end of the infinite list ;)
09:06:52 <EvanR> left assoc my ass
09:07:36 <EvanR> hm. sequence is defined as foldr here
09:08:05 <parcs> > Nothing >> (Just () >> (undefined :: Maybe ()))
09:08:06 <lambdabot>   Nothing
09:08:30 <EvanR> > Nothing >> Just () >> undefined
09:08:31 <lambdabot>   Nothing
09:08:32 <parcs> oh damn
09:08:41 <EvanR> > (Nothing >> Just ()) >> undefined
09:08:43 <lambdabot>   Nothing
09:08:55 <EvanR> so its like these left assoc rules never matter because you never literally type strings of >>
09:09:10 <parcs> well if >> were right-associative, it would evaluate to bottom, i think
09:09:10 <EvanR> much less very long or infinite strings of >>
09:09:19 <parcs> let me try locally
09:09:20 <EvanR> no it wouldnt
09:10:27 <EvanR> > Nothing >> undefined
09:10:29 <lambdabot>   Nothing
09:10:40 <EvanR> > Just () >> undefined
09:10:41 <lambdabot>   *Exception: Prelude.undefined
09:10:59 <EvanR> > undefined >> Just ()
09:11:01 <lambdabot>   *Exception: Prelude.undefined
09:11:08 <EvanR> > undefined >> Nothing
09:11:09 <lambdabot>   *Exception: Prelude.undefined
09:11:30 <parcs> fffff
09:12:21 <EvanR> i think the left assoc never makes a diff in reality since it only applies to literal sequences of >>
09:12:22 <insane> i'm looking for templating language for haskell (something like StringTemplate for Java). I will be using it to generate LLVM IR code. Do you have any suggestions which haskell templating engine would be best for my needs?
09:12:58 <EvanR> haskell is a great templating language already
09:13:09 <EvanR> use a writer ;)
09:14:00 <EvanR> or a string cat endomorphism
09:15:39 <EvanR> insane: if by template you mean some text you can efficiently substitute into many times with different data, i looked at the template package recently
09:19:44 <parcs> EvanR: print "" >>> undefined >>> undefined where >>> is a right-associative >> evaluates to bottom
09:19:54 <parcs> wait
09:20:10 <EvanR> >>> ?
09:20:14 <parcs> hahahahaha, i really can't think today
09:20:22 <parcs> never mind
09:20:35 <EvanR> that evaluates to undefined no matter what
09:20:46 <EvanR> assuming you did >>
09:20:57 <parcs> yeah
09:21:07 <EvanR> > print "" >> undefined >> getChar
09:21:09 <lambdabot>   <IO Char>
09:21:18 <EvanR> ...
09:21:39 <EvanR> > (print "" >> undefined) >> getChar
09:21:40 <lambdabot>   <IO Char>
09:21:49 <parcs> i just didn't see "" being printed at first glance
09:21:51 <EvanR> > print "" >> (undefined >> getChar)
09:21:53 <lambdabot>   <IO Char>
09:22:03 <EvanR> ok im wrong, but the parens still dont matter
09:22:27 <parcs> EvanR: lambdabot isn't actually evaluating (>>) there
09:22:45 <EvanR> i disagree
09:23:17 <EvanR> and i dont think we should be trying to generalize any rules based on IO
09:32:18 * hackagebot happstack-state 6.1.0 - Event-based distributed state.  http://hackage.haskell.org/package/happstack-state-6.1.0 (JeremyShaw)
09:33:08 <aninhumer> What's the best way to work with a fixed nonstandard (20bytes) sized bitfield? I think I only need bit testing and xor, so making a custom Bits instance seems overkill
09:33:14 <parcs> :t ?a >>= ?b >>= ?c
09:33:16 <lambdabot> forall (m :: * -> *) a a1 b. (?a::m a, ?b::a -> m a1, Monad m, ?c::a1 -> m b) => m b
09:33:21 <parcs> :t ?a >>= (?b >>= ?c)
09:33:23 <lambdabot> forall (m :: * -> *) a a1 b. (?a::m a, ?b::a -> a1, ?c::a1 -> a -> m b, Monad m) => m b
09:34:22 * hackagebot happstack 6.0.2 - The haskell application server stack + code generation  http://hackage.haskell.org/package/happstack-6.0.2 (JeremyShaw)
09:34:53 <EvanR> aninhumer: make your own abstract data type
09:34:55 <hpaste> Kaidelong pasted “Lost some polymorphism, still doesn't work” at http://hpaste.org/49274
09:35:39 <aninhumer> EvanR: something like Int32 * 5 ?
09:35:43 <EvanR> parcs: o_O
09:35:56 <EvanR> aninhumer: times five? you only need 20 bits
09:36:12 <aninhumer> 20bytes of bits
09:36:16 <EvanR> oh
09:36:21 <EvanR> so 100 bits
09:36:23 <EvanR> er
09:36:25 <EvanR> > 20 * 8
09:36:27 <lambdabot>   160
09:36:31 <EvanR> 160 bits
09:36:40 <Kaidelong> anyone able to help me with that?
09:36:40 <EvanR> there is a Word160 type already in existence
09:36:42 <Kaidelong> I'm stumped
09:36:46 <ClaudiusMaximus> aninhumer: {-# LANGUAGE GeneralizedNewtypeDeriving #-} newtype Int100 = Int100 Integer deriving Bits  -- don't export constructor, maybe
09:36:57 <EvanR> http://hackage.haskell.org/packages/archive/Crypto/4.2.0/doc/html/Data-Digest-SHA1.html
09:37:36 * ClaudiusMaximus sucks at mental arithmetic too it seems
09:37:45 <aninhumer> ClaudiusMaximus: Oh cool
09:38:10 <EvanR> Word160 !Word32 !Word32 !Word32 !Word32 !Word32
09:38:23 <ClaudiusMaximus> @hoogle LargeWord
09:38:23 <lambdabot> No results found
09:38:47 <aninhumer> What does the pragma do here exactly?
09:39:54 <ryant5000> quicksilver: i was able to obtain what i wanted using the GHC HEAD, but not directly
09:39:55 <c_wraith> aninhumer: It lets you derive any instance for a newtype that the type you're wrapping has.
09:40:10 <c_wraith> aninhumer: by just using the wrapped type's implementation for that instance
09:40:23 * hackagebot happstack-plugins 6.0.2 - The haskell application server stack + reload  http://hackage.haskell.org/package/happstack-plugins-6.0.2 (JeremyShaw)
09:40:24 <parcs> okay so >>= is probably left-associative to allow composition like m >>= f >>= g, and >> is too since it's a simple wrapper on >>=
09:40:26 <ryant5000> quicksilver: i had to make another class that used type equality constraints to build the cycle without including the classes in the cycle
09:40:48 <ryant5000> quicksilver: (i basically made a cycle of types instead of a cycle of classes via types)
09:40:50 <ClaudiusMaximus> aninhumer: http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html
09:41:41 <EvanR> parcs: >>= is left associative because m >>= (f >>= g) isnt well typed (according to the original expression)
09:41:57 <EvanR> according to the left associative rule, so nevermind
09:42:19 <ClaudiusMaximus> but thinking about it, deriving Bits might not be the easiest way really, becuase shiftL on Integer won't truncate to 160bits
09:42:57 <EvanR> a >>= b >>= c >>= d with right assoc would mean b and c were not functions
09:43:16 <EvanR> but m a
09:43:40 <aninhumer> ClaudiusMaximus: as I said, I only need a tiny subset of bitfield features, so that shouldn't be a problem
09:44:21 <ClaudiusMaximus> aninhumer: well, http://hackage.haskell.org/packages/archive/largeword/1.0.0/doc/html/Data-LargeWord.html might do what you want more directly
09:44:24 * hackagebot enumerator 0.4.13 - Reliable, high-performance processing with left-fold enumerators  http://hackage.haskell.org/package/enumerator-0.4.13 (JohnMillikin)
09:44:39 <edwardk> @karma c/c
09:44:39 <lambdabot> c/c has a karma of 620
09:45:01 <parcs> :t ?a >>= ?b >>= ?c >>= >d
09:45:02 <lambdabot> parse error on input `>'
09:45:08 <parcs> :t ?a >>= ?b >>= ?c >>= ?d
09:45:09 <lambdabot> forall (m :: * -> *) a a1 a2 b. (?a::m a, ?b::a -> m a1, Monad m, ?c::a1 -> m a2, ?d::a2 -> m b) => m b
09:45:12 <edwardk> we need to talk about how we use c/c— as a backend for ghc more often
09:45:17 <parcs> :t ?a >>= (?b >>= (?c >>= ?d))
09:45:18 <lambdabot> forall (m :: * -> *) a a1 a2 b. (?a::m a, ?b::a -> a1, ?c::a1 -> a2, ?d::a2 -> a1 -> a -> m b, Monad m) => m b
09:45:37 <edwardk> @karma c
09:45:37 <lambdabot> c has a karma of 4
09:45:45 <copumpkin> I dunno, I'm a big fan of C/C++ myself
09:45:47 <parcs> EvanR: it's well-typed, just less useful
09:46:06 <edwardk> but c— is so… easy to debug
09:46:24 <copumpkin> c----
09:46:28 <copumpkin> @karma c--
09:46:28 <lambdabot> c-- has a karma of 3
09:46:32 <edwardk> @karma c
09:46:32 <lambdabot> c has a karma of 4
09:47:23 <EvanR> parcs: with right assoc the actions would need to be more wtf to work out right
09:47:40 <parcs> yeah
09:47:41 <edwardk> @karma copumpkin
09:47:42 <lambdabot> copumpkin has a karma of 17
09:47:44 <EvanR> instead of returning the answer, it returns a function
09:47:55 <copumpkin> :O
09:47:58 <copumpkin> copumpkin--
09:48:09 <edwardk> but you need to subtract out the pumpkin karma
09:48:13 <edwardk> @karma pumpkin
09:48:13 <lambdabot> pumpkin has a karma of 6
09:48:22 <copumpkin> pumpkin++
09:48:26 <roconnor> edwardk: do you have a type of natural transformations?
09:48:32 <dolio> @karma copumpkin
09:48:33 <roconnor> somewhere
09:48:33 <lambdabot> copumpkin has a karma of 17
09:48:34 <copumpkin> I've seen one!
09:48:40 <edwardk> roconnor: not any more
09:48:43 <roconnor> forall a. f a -> g a
09:48:46 * glguy used to have karma before lambdabot was reset
09:48:52 <glguy> those were the days :)
09:48:53 <copumpkin> @karma glguy
09:48:54 <lambdabot> glguy has a karma of 2
09:48:56 <copumpkin> glguy++
09:48:58 <copumpkin> thanks glguy
09:49:01 <copumpkin> glguy: thanks
09:49:03 <copumpkin> @karma glguy
09:49:03 <lambdabot> glguy has a karma of 3
09:49:11 <copumpkin> oh, it's not very clever
09:49:57 <edwardk> roconnor: i found that writing code with some ~> type made someone go dig up my definition before reading the type signatures
09:50:07 <edwardk> roconnor: so i just write them pointfully now adays
09:50:28 <roconnor> I know ... but all the quantifies are distracting from the underlying type.
09:50:32 <roconnor> f ~> g
09:50:44 <edwardk> yes, but the ~> is sending someone off to the definition and takes me out of haskell 98 ;)
09:50:58 <roconnor> well, if you are using natural transformations you are not haskell 98 anyways
09:51:22 <edwardk> well, lots of things that i write that are witnesses to natural transformations are still 98.
09:51:30 <roconnor> :O
09:51:32 <edwardk> the transformations are, the code that consumes them is not
09:51:52 <edwardk> @type maybeToList
09:51:53 <lambdabot> forall a. Maybe a -> [a]
09:52:00 <edwardk> natural transformation, haskell 98 =P
09:52:17 <roconnor> sure
09:52:28 <roconnor> but functions taking natural transformations are not H98
09:52:35 <edwardk> sure
09:53:12 <collin_> hi all :)
09:53:14 <edwardk> i just haven't felt a pressing enough need to duplicate the http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Extras.html module in any particular package
09:53:23 <collin_> ghc works on arm right?
09:53:27 <EvanR> 'Alternative type class is for Applicative functors which also have a monoid structure' ... oh.
09:53:33 <EvanR> but why not just use Monoid?
09:53:44 <c_wraith> different kind
09:53:57 <c_wraith> Monoid has kind *, Alternative has kind * -> *
09:54:05 <edwardk> evanr: because the alternative instance has laws for how that interoperates with the applicative, and the monoid would be an instance for each particular argument
09:54:19 <EvanR> oh
09:54:36 <EvanR> so Alternative is basically Functor Monoid
09:54:43 <edwardk> alternative says you have both a left-seminearring like structure with regards to <*> and that no matter what argument you have you can <|>
09:54:47 <c_wraith> well, applicative.  But yes. :)
09:54:47 <edwardk> not quite
09:55:02 <edwardk> because there are distributive/catch laws with regards to how it works with applicative
09:55:11 <EvanR> gah
09:55:27 * hackagebot warp 0.4.3 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-0.4.3 (MichaelSnoyman)
09:55:37 <EvanR> im guessing its the same story for MonadPlus
09:55:55 <c_wraith> many types have the same implementation for MonadPlus and Alternative
09:56:06 <edwardk> ideally: a <|> (b <*> c) = (a <*> b) <|> (a <*> c)
09:56:25 <edwardk> c_wraith: the 2-3 that don't make me very sad
09:56:27 <EvanR> edwardk: is that really the law? or what
09:56:37 <edwardk> evanr: its unfortunately not that simple
09:57:06 <edwardk> alternative is really two classes that get conflated
09:57:11 <edwardk> one has a distributive law
09:57:21 <edwardk> one has a catch law
09:57:34 <copumpkin> edwardk--
09:57:38 <edwardk> and i got the <*> and <|> backwards in the distributive law
09:57:38 <EvanR> grumble
09:57:39 <edwardk> =P
09:57:43 <copumpkin> edwardk++
09:58:45 <edwardk> the distributive version, which is nicely behaved, says that in addition to (<|>,empty) forming a monoid, (a <|> b) <*> c = (a <*> c) <|> (b <*> c)
09:58:50 <EvanR> 'in general a MonadPlus instance for a type need not be  the same as its Monoid instance'
09:58:53 <EvanR> er
09:58:57 <EvanR> that seems impossible anyway?
09:58:58 <edwardk> the catch version says return a <|> b = return a
09:59:18 <edwardk> Maybe, IO, Either, all obey that later definition
09:59:29 <dolio> The monoid instance for Maybe is different than the MonadPlus instance.
09:59:33 <edwardk> evanr: nah, the monoid for Maybe is different from the MonadPlus
09:59:38 <edwardk> hah
09:59:43 <edwardk> @quote stereo
09:59:43 <lambdabot> geheimdienst says: data Stereoloid = BanachTyvski | CoBanachTyvski
09:59:48 <edwardk> or something
09:59:58 <c_wraith> @quote glorious.stereo
09:59:58 <EvanR> i thought they had the wrong kinds
09:59:59 <lambdabot> Cale says: Welcome to #haskell, where your questions are answered in glorious stereo!
10:00:11 <glguy> dankna: Now that OS X 10.7 is released I'm curious if it is still the case that GHC disagrees with the linker
10:00:14 <EvanR> and it thought there were several instances for Monoid Maybe
10:00:14 <edwardk> well, the instance for Monoid (m a) and MonadPlus m
10:00:26 <EvanR> oh
10:00:40 <EvanR> im beginning to get lost
10:00:55 <EvanR> again
10:00:57 <dolio> > Just [5] `mappend` Just [6]
10:00:58 <lambdabot>   Just [5,6]
10:01:02 <edwardk> short answer, Alternative says that <|> and <*> interact in some way
10:01:06 <dolio> > Just [5] `mplus` Just [6]
10:01:07 <lambdabot>   Just [5]
10:01:44 <edwardk> MonadPlus should agree with Alternative if both are defined, but Monoid may be something completely unrelated.
10:01:57 <EvanR> 'if we are lucky, someday MonadZero will be restored, and fail will be banished to the bit bucket where it belongs'
10:02:04 <edwardk> @type liftM2 mappend
10:02:05 <lambdabot> forall a1 (m :: * -> *). (Monoid a1, Monad m) => m a1 -> m a1 -> m a1
10:02:38 <edwardk> that would be a valid definition for Monoid (m a) for any Monad m, Monoid a, but obviously wouldn't be a valid definition for MonadPlus
10:06:10 <EvanR> hmm. well it seems Monoid is a ridiculously general idea
10:06:21 <EvanR> everythings a monoid
10:06:33 <EvanR> if you look at it right
10:06:45 <Tomsik> Well, you can add an artificial unity to a semigroup
10:06:53 <Tomsik> but there are plenty of things that are not associative
10:07:11 <EvanR> whats artificial unity
10:07:35 <EvanR> adding an extra element would seem to go too far
10:07:41 <Tomsik> Like adding an element
10:08:24 <Tomsik> It's like it's trivial to make monoid from a semigroup S by just doing Maybe S
10:08:41 <EvanR> yeah
10:08:44 <EvanR> boring ;)
10:09:01 <Tomsik> But things that are not associative lie far away from any monoids, I guess
10:09:17 <EvanR> whats not associative?
10:11:51 <Tomsik> Z with (-) for example. 1-(2-3) != (1-2)-3
10:12:53 <EvanR> heh, that
10:13:38 <EvanR> subtract [1, 2, 3] ;)
10:13:40 <EvanR> there
10:14:34 <Tomsik> That just orders parenthesis in a specific way
10:14:56 <EvanR> what an abhorent operation!
10:22:11 <EvanR> ~> is annoying, in my xterm i can forgive it, but in typeclassopedia's font it looks the same!
10:44:47 <develhevel> is it possible, when i call write file with a very long string, i get: prelude.read: no parse? how to avoid this?
10:46:19 <Cale> develhevel: That sounds like an unrelated error
10:46:35 <Cale> develhevel: Can you put your code on hpaste.org?
10:48:00 <Cale> develhevel: Prelude.read: no parse is what you get when you use 'read' to parse a string into one of various types (say Integer, for example), but the string doesn't actually have an Integer in it.
10:49:05 <develhevel> could concat cause this?
10:50:49 <ari> develhevel: No. But it's possible if some part of the data came in from something you were trying to read with the 'read' function and you just never happened to try to evaluate it.
10:57:55 <develhevel> ari: how to check these evaluation? or how to make it
11:00:55 <cpa> is there a canonical example of type for which it makes sense for it to be instance of functor but not applicative ?
11:02:01 <ari> develhevel: It depends on the structure of your program. You could try debugging by printing out values close to where they are read in so you don't have to track them down over your code's internals.
11:03:22 <ari> develhevel: And consider replacing your uses of 'read' with something with better error handling
11:03:24 <ion> cpa: Data.Map
11:04:26 <ion> (.Map)
11:05:33 <cpa> ion: thx, give me 10 minutes to think about it, now
11:05:36 <cpa> :)
11:06:06 <ion> cpa: How would you implement pure for Map?
11:06:21 <ion> pure :: a -> Map k a
11:06:37 <cpa> I see
11:06:41 <companion_cube> that would require to populate any type k, right ?
11:08:14 <ion> Also, what would be the semantics of Map.fromList [(0, ("foo"++)), (1, ("bar"++)), (2, ("baz"++))] <*> Map.fromList [(3, "a"), (4, "b"), (5, "c")]?
11:08:34 <ClaudiusMaximus> companion_cube: not as far as i can tell, the instances would be for (Map k), so k is known and fixed in the instance
11:09:53 <companion_cube> > [(+1), (+2)] <*> [4,6,8]
11:09:54 <lambdabot>   [5,7,9,6,8,10]
11:10:04 <cpa> ok, I think I get it, thanks
11:10:16 <ion> companion_cube: Yes, a cartesian product for the values makes sense. How about the keys?
11:10:25 <ClaudiusMaximus> > ZipList [(+1), (+2)] <*> ZipList [4,6,8]
11:10:26 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList a))
11:10:27 <lambdabot>    arising ...
11:10:31 <companion_cube> yeah, i agree with you, ion
11:10:59 <cpa> but what we're saying holds for any type of several parameters, no?
11:12:06 <ion> ParsecT s u m a is an Applicative.
11:19:14 <Polarina> What's everyone up to?
11:20:08 <ClaudiusMaximus> hmm,  (Map () a) is isomorphic to (Maybe a), right? so you could have Applicative (Map ()) just as Applicative Maybe
11:21:57 <ClaudiusMaximus> Polarina: wondering whether i'm doing something wrong when profiling or if the haskell cairo bindings add a vast amount of overhead to raw cairo
11:22:55 <ClaudiusMaximus> with +RTS -P it tells me 95% of my runtime and allocation is in the calls to cairo functions...
11:23:28 <Polarina> Could it be that the bindings are bad?
11:23:38 <pnken> Hello
11:24:48 <msieradzki> I have 1 game thread that has a loop that renders frames in each iteration and calls tick every 0.03 s and 1 send thread busy waiting on STM chans which when running totally stalls render thread
11:25:03 <pnken> I just started taking a course in functional programming and we have to learn haskell. I don't have any prior knowledge with programming. I want to write a function that I can give a list and an element and it checks if the element is in the list. I already came up with the function. The problem is that for some reason its not working for a polymorphic signature (not sure if this is the right term)
11:25:18 <msieradzki> game thread doesn't use STM at all (yet) but it's throttled by separate one somehow, I tried forkOS for send thread and it still happens
11:25:35 <msieradzki> I get like 1000 frames per second without send thread running and maybe 0.1 with it
11:26:01 <Polarina> pnken: What do you have?
11:26:03 <msieradzki> are there any hidden dependencies that might cause this throttling?
11:26:14 <scooty-puff> is there a version of:
11:26:16 <scooty-puff> :t everything
11:26:17 <lambdabot> forall r a. (Data a) => (r -> r -> r) -> GenericQ r -> a -> r
11:26:18 <pnken> elemlist::[a]->a->Bool
11:26:19 <scooty-puff> or
11:26:20 <pnken> is the signature
11:26:22 <scooty-puff> :t everywhere
11:26:24 <lambdabot> forall a. (Data a) => (forall a1. (Data a1) => a1 -> a1) -> a -> a
11:26:25 <pnken> or wait, Ima put it in pastebin
11:26:30 <scooty-puff> that takes t a -> t b?
11:26:32 <scooty-puff> or could?
11:26:44 <Polarina> pnken: (Eq a) => [a] -> a -> Bool
11:26:55 <msieradzki> http://hpaste.org/49276 that's send thread code, it quite stupid but still
11:27:21 <pnken> http://pastebin.com/upzBG9wG
11:27:23 <mauke> The paste upzBG9wG has been copied to http://hpaste.org/49277
11:27:28 <pnken> this is what I have so far
11:27:47 <pnken> it works fine when I put in [Int] - > Int -> Bool
11:27:49 <pnken> or Char
11:27:54 <ari> pnken: Your function's type claims it can act on lists of any kind of element at all. Haskell doesn't guarantee that you can compare things for equality, so you'll have to limit the types the function acts on to those in the Eq class as Polarina noted
11:27:55 <Polarina> pnken: If you need to use comparison, the Eq typeclass, you need to restrict the type of a to a type with an Eq instance.
11:28:19 <pnken> hm
11:28:22 <pnken> we didnt cover that yet :[
11:28:34 <pnken> So I want to declare that a is of the same typ as the list [a], right?
11:28:56 <Polarina> (Eq a) => [a] -> a -> Bool
11:29:21 <Polarina> pnken: http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101
11:29:28 <pnken> it works
11:29:31 <pnken> thanks so much
11:29:58 <gwern> Baughn: btw, whatever happened with your ever17 project? I just downloaded the english release (I think( and noticed you had mentioned it
11:29:58 <Polarina> pnken: You're welcome. Check out the link I gave you as well. It explains what's happening and how it works.
11:29:58 <pnken> I think we are going to cover classes in the next lecture
11:30:16 <pnken> Thanks Polarina and ari
11:31:50 <Eduard_Munteanu> pnken: not just the same type, but it should be a type whose elements are comparable for equality
11:32:36 <pnken> does that mean not all types can be compared
11:32:44 <pnken> I mean the elements of those type
11:32:48 <Eduard_Munteanu> Yeah.
11:32:49 <Polarina> pnken: No. Some types can not be compared.
11:32:56 <pnken> oh
11:33:12 <Polarina> s/No/Yes/
11:33:29 <EvanR> > id == id
11:33:30 <lambdabot>   *Exception: (==): No overloading for function
11:33:36 <Baughn> gwern: Sort of stalled waiting for JHC to officially support android
11:33:59 <gwern> huh. why does JHC need explicit support? just compiles down to C, iirc
11:35:13 <k0ral> how would you fetch first line from a file while removing it from the file ? I'm thinking about reading all the file and rewriting it without its first line but I'm not sure this is the shortest way to do it
11:35:14 <gwern> (oh well. wine can probably run mine)
11:35:29 <Baughn> gwern: Well, there's still some tuning to be done
11:35:40 <gwern> k0ral: that's pretty much how. I tried to do this for my archiver bot and that's how I wound up doing it
11:35:58 <Baughn> gwern: More to the point, I don't want to be debugging opengl ffi bindings on android while simultaneously wondering if it's really the compiler
11:36:07 <k0ral> gwern: thank you
11:36:23 <gwern> k0ral: there's also no clean shell way either; it's fundamentally a hard thing to do, unlike appending
11:42:47 <EvanR> a blog about comonads
11:42:51 <EvanR> http://gelisam.blogspot.com/2007/04/i-understand-comonads.html
11:42:58 <EvanR> 'A spacesuit example should follow soon.'
11:43:02 <Eduard_Munteanu> k0ral: maybe something like hGetContents i >>= hPutStr o . unlines . tail . lines
11:43:22 <Eduard_Munteanu> Heh.
11:44:35 <k0ral> Eduard_Munteanu: I ended up doing almost exactly the same
11:45:03 <k0ral> just using readFile and writeFile instead
11:45:13 <EvanR> k0ral: from ByteString i hope
11:45:37 <k0ral> EvanR: I'm afraid not; you're suggesting String would be slow right ?
11:46:01 <EvanR> doing any extensive computation on a large file loaded into a String will probably result in stack overflow
11:46:09 <k0ral> oh
11:46:42 <k0ral> looking at how to use readFile and writeFile with ByteString
11:46:48 <EvanR> or Text
11:47:03 <EvanR> if you will be looking at characters rather than bytes
11:47:57 <k0ral> what do you mean ? I'm working on characters strings
11:48:17 <EvanR> then use Text
11:49:22 * k0ral is now looking at how to use readFile and writeFile with *Text*
11:49:30 <roelof> hello,  I have a exercise problem
11:50:09 <roelof> I have a function replicate with this defenition : replicate :: Int -> a -> [a]
11:50:32 <roelof> and I have to use list comprehension
11:50:57 <byorgey> roelof: what have you tried so far?
11:51:01 <EvanR> k0ral: looks like you cant directly. basically, a file is a ByteString.
11:51:32 <roelof> So I did replicate = [[xs] | x >= a <- xs]
11:51:35 <EvanR> you can read the file, encode into Text, drop 1 . lines it
11:51:42 <roelof> but that one did not work
11:51:44 <copumpkin> roelof: whoa
11:52:00 <roelof> how can I declare the counter for the replicate
11:52:46 <byorgey> roelof: well, first of all, replicate needs some arguments
11:52:57 <roelof> in C I would use a for next loop
11:53:02 <byorgey> replicate n x = ...
11:53:08 <k0ral> EvanR: but I've just found Data.Text.IO which defines readFile and writeFile ?!
11:53:22 <copumpkin> replicate n x = [x | somethingHereThatIWon'tGiveAwayCauseI'mGood]
11:53:26 <roelof> yep, the string and the times the loop should work
11:53:27 <EvanR> k0ral: wut... *checks*
11:53:31 <copumpkin> > [1..5]
11:53:32 <lambdabot>   [1,2,3,4,5]
11:53:37 <copumpkin> > [5..10]
11:53:38 <lambdabot>   [5,6,7,8,9,10]
11:53:59 <copumpkin> roelof: do you understand how list comprehensions work in general?
11:54:09 <copumpkin> > [x + 1 | x <- [3,5,6]]
11:54:11 <lambdabot>   [4,6,7]
11:54:13 <EvanR> k0ral: alright. readFile :: FilePath -> IO Text, it will use your locale to determine decoding
11:54:14 <msieradzki> is stm (simply readTVar in  infite loop) especially costly when called in ghci? or maybe code using several threads is?
11:54:25 <roelof> That part I understand
11:54:29 <k0ral> EvanR: thank you :)
11:54:54 <copumpkin> roelof: so what do you want to be on the left of the | ?
11:54:58 <roelof> but now I don't know what the end is of [1..]
11:55:13 <byorgey> [1..] does not have an end
11:55:25 <EvanR> > length [1..]
11:55:27 <byorgey> you need to give it one
11:55:29 <lambdabot>   mueval-core: Time limit exceeded
11:55:29 <roelof> a sort of loop which ends on the number the user enters
11:55:41 <byorgey> right, so how would you write that?
11:55:42 <copumpkin> > length [1..10]
11:55:44 <lambdabot>   10
11:55:45 <byorgey> assuming the number is called n
11:55:56 <roelof>  [ 1..n]
11:55:58 <EvanR> > length [-1..]
11:56:00 <byorgey> exactly
11:56:03 <lambdabot>   mueval-core: Time limit exceeded
11:56:04 <EvanR> infinite + 2
11:56:14 <copumpkin> :k Natural
11:56:15 <lambdabot>     Not in scope: type constructor or class `Natural'
11:56:20 <copumpkin> that used to be in lambdabot :(
11:56:22 <copumpkin> Cale!!
11:56:27 <byorgey> :k Nat
11:56:28 <lambdabot> Not in scope: type constructor or class `Nat'
11:56:28 <Eduard_Munteanu> @index Natural
11:56:29 <lambdabot> bzzt
11:56:53 <byorgey> roelof: ok, so we are going to be using the list [1..n] somehow
11:58:17 * hackagebot enumerator 0.4.13.1 - Reliable, high-performance processing with left-fold enumerators  http://hackage.haskell.org/package/enumerator-0.4.13.1 (JohnMillikin)
11:58:57 <roelof> oke, then I will be  replicate n x = [[x] |     <- [1..n]
11:59:21 <EvanR> is there special notation for comonads
11:59:32 <roelof> wait , I think I understand it
11:59:45 <copumpkin> roelof: why [x]?
12:00:00 <roelof> because the outcome must be a list
12:00:06 <copumpkin> > [[x] | x <- [1..5]]
12:00:07 <lambdabot>   [[1],[2],[3],[4],[5]]
12:00:12 <copumpkin> > [x | x <- [1..5]]
12:00:13 <lambdabot>   [1,2,3,4,5]
12:00:16 <EvanR> [....] <- its a list
12:00:29 <copumpkin> roelof: you're describing _elements_ of a list
12:00:32 <roelof> so replicate 3 true must be [true, true, true]
12:00:33 <copumpkin> individually
12:01:01 <EvanR> > [x | y <- [1..5]]
12:01:03 <lambdabot>   [x,x,x,x,x]
12:01:06 <EvanR> o_O
12:01:58 <roelof> so the answer is  [[x] | y <- [1..n]]
12:02:11 <EvanR> > [[x] | y <- [1..5]]
12:02:13 <lambdabot>   [[x],[x],[x],[x],[x]]
12:02:30 <copumpkin> roelof: no
12:02:55 <copumpkin> as I said, the list comprehension is describing _elements_ of an output list
12:02:57 <roelof> oke, second attemp [x | y <- [1..n]]
12:03:03 <copumpkin> if you make each element of the output list a list, you'll get a list of lists
12:03:23 <quicksilver> ryant5000: glad you got something working; it's probably worth a g-h-u post to explain the use case. Might make SPJ think.
12:03:28 <roelof> pfff, I think I need a lot of practice on this matter
12:03:34 <copumpkin> roelof: that's it
12:03:48 <EvanR> @src replicate
12:03:49 <lambdabot> replicate n x = take n (repeat x)
12:03:53 <EvanR> \o/
12:04:03 <roelof> I tried c and c++ and also get stuck on this subject
12:04:30 <EvanR> @pl \n x -> take n (repeat x)
12:04:31 <lambdabot> (. repeat) . take
12:04:36 <roelof> oke, on that last one you don't use list compreshion
12:04:39 <k0ral> I know nothing about the optimisations used by the compiler, but for example if I use the same (lines myString) in several places of my code, will it be computed several times or just once for all ?
12:05:04 <EvanR> roelof: head [(. repeat) . take | x <- [0]]
12:05:23 * hackagebot reactive-banana 0.4.1.1 - Small but solid library for  functional reactive programming (FRP).  http://hackage.haskell.org/package/reactive-banana-0.4.1.1 (HeinrichApfelmus)
12:05:46 <EvanR> k0ral: youre better off moving that expression into its own variable
12:05:53 <roelof> pfff, a lot of ways to solve this
12:05:56 <Eduard_Munteanu> > let x = 1; n = 10 in do { y <- [1..n]; return x }
12:05:57 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
12:06:23 * hackagebot reactive-banana-wx 0.4.1.1 - Examples for the reactive-banana library, using wxHaskell.  http://hackage.haskell.org/package/reactive-banana-wx-0.4.1.1 (HeinrichApfelmus)
12:06:57 <roelof> oke, but in that one you also don't use list compreshion and that subject is the chapter Im reading and try to understand
12:07:13 <EvanR> roelof: i did in mine ;)
12:07:29 <k0ral> EvanR: but what if I don't ?
12:07:31 <byorgey> EvanR: cheater ;)
12:07:42 <roelof> the one with head repeat ??
12:08:03 <EvanR> head [answer | _ <- [()]] \o/
12:08:19 <byorgey> roelof: ignore that, EvanR was being silly =)
12:08:29 <EvanR> now the real answer uses a list comprehension
12:08:41 <roelof> oke
12:08:50 <EvanR> show that to your professor and see what happens
12:09:00 <dainanaki> I just wrote an enumerator wrapper for the pcap library. How do I get the ability to put a package on hack age?
12:09:06 <EvanR> bonus points i think
12:09:12 <roelof> but can you make everything in haskell what you can make in for example C
12:09:42 <roelof> I don't have a proffessor , Im soimng  a self study with the book programming in haskell
12:09:43 <EvanR> forM_ [0..n-1] $ \i -> do
12:10:31 <roelof> but everyone thanks for the help
12:10:51 <EvanR> theres also a BASIC monad so you can do everything you can do in for example BASIC
12:10:57 <roelof> Im going to study on with this difficult subject
12:11:36 <Eduard_Munteanu> roelof: http://www.haskell.org/haskellwiki/List_comprehension#List_monad
12:11:58 <erus`> there is a BASIC monad :O
12:12:05 <Eduard_Munteanu> Might help if you want to make some connections.
12:12:54 <erus`> is there a C monad?
12:13:24 <erus`> then we could write a bootstrap self hosting ghc?
12:14:31 <EvanR> k its not a monad
12:14:34 <Eduard_Munteanu> That'd be some sort of Literate C, where the "documentation" is Haskell code.
12:14:34 <EvanR> http://hackage.haskell.org/packages/archive/BASIC/0.1.5.0/doc/html/Language-BASIC.html
12:15:42 <Eduard_Munteanu> But anyway a C monad won't get GHC rid of C code I suppose.
12:15:56 <ClaudiusMaximus> ouch - my naive test suggests that the hackage 'cairo' package adds 6.6x overhead on top of 'foreign import'
12:19:25 <EvanR> haha, in this blog post he runs a benchmark in haskell BASIC versus C
12:19:30 <EvanR> http://augustss.blogspot.com/2009/02/is-haskell-fast-lets-do-simple.html
12:20:04 <EvanR> haskell wins, fatality
12:24:01 <Eduard_Munteanu> EvanR: yeah, and Hurd is about as fast as Linux :P
12:25:49 <Eduard_Munteanu> (ok, context:  http://www.phoronix.com/scan.php?page=article&item=debian_gnu_hurd&num=1  )
12:26:24 <EvanR> oh
12:26:38 <EvanR> tab obliterated
12:26:40 <EvanR> could see through the ads
12:26:42 <EvanR> coudnt
12:27:23 <Axman6> you mean a kernel that has only been worked on be a small team of developers with no real world use is slower than a highly popular kernel with thousands of developers that's had years of optimisation for real world use? I'm shocked!
12:28:01 * Eduard_Munteanu ponders Real World Hurd
12:29:32 <Eliel_> are there any other languages out there that significantly resemble haskell?
12:29:39 <EvanR> miranda
12:29:54 <Axman6> Agda, to some extent?
12:29:54 <nostrand> Eliel_: Clean
12:29:59 <EvanR> clean
12:30:08 <EvanR> both of which dont have do notation
12:30:37 <EvanR> but haskell has do AND dont notation
12:31:07 <mauke> if we're going by that, Perl
12:32:08 <ion> > dont $ do "o hai"
12:32:08 <Eliel_> looking at miranda examples on wikipedia... Those look like Haskell to me :)
12:32:10 <lambdabot>   ()
12:32:50 <mauke> > let don't = return () in don't $ do "o hai"
12:32:52 <lambdabot>   ()
12:34:09 <Eduard_Munteanu> Maybe Cayenne? And Idris?
12:34:13 <Eliel_> is haskell developed with miranda as the base?
12:34:25 <EvanR> Eliel_: yes, miranda style languages led to the development of haskell and free software ghc
12:34:40 <EvanR> Oberon?
12:35:00 <EvanR> er no
12:35:29 <EvanR> obscure PL of the week
12:37:23 <hpaste> argiopeweb pasted “Time Hack” at http://hpaste.org/49279
12:38:15 <argiopeweb> The optimizer eats the code in the above post and completely removes its purpose in life. Anyone have a recommendation for keeping this from happening?
12:38:31 <EvanR> http://hackage.haskell.org/package/acme-now
12:38:45 <EvanR> now :: UTCTime
12:38:50 <hpaste> argiopeweb annotated “Time Hack” with “Time Hack (annotation)” at http://hpaste.org/49279#a49280
12:39:03 <mauke> argiopeweb: what did you expect?
12:39:14 <mauke> and now it doesn't compile anymore
12:39:27 <argiopeweb> ...
12:39:35 <argiopeweb> Well, hold on and I'll just stick the whole file in there.
12:39:35 <EvanR> argiopeweb: check out the acme-now package
12:39:38 <EvanR> it does what you want
12:39:43 <argiopeweb> EvanR: No, it does what I don't wan.t
12:39:45 <argiopeweb> want*
12:39:51 <mauke> argiopeweb: what do you want?
12:39:53 <ion> Why would you want to get the current time with unsafePerformIO?
12:39:56 <argiopeweb> I want to call epochTime from pure code.
12:39:57 <EvanR> i think your idea of time and space is off
12:40:10 <mauke> argiopeweb: no
12:40:12 <argiopeweb> Without encountering the "evaluate once" issue.
12:40:19 <mauke> argiopeweb: just no
12:40:22 <EvanR> lol
12:40:35 <EvanR> theres only one 'now', it never changes
12:40:39 <argiopeweb> mauke: It's evil, but it's essential.
12:40:43 <ion> It’s not a pure function if you call epochTime from it.
12:40:43 <mauke> argiopeweb: why?
12:41:21 <argiopeweb> mauke: Creating a unique identifier to fit into some legacy C++ code which requires a time stamp.
12:41:40 <mauke> argiopeweb: where does the "pure code" come in?
12:41:47 <EvanR> use IO or a source of unique identifiers
12:42:12 <EvanR> but not unsafePerformIO
12:42:38 <argiopeweb> EvanR: Can't use source of unique ID's because it doesn't fit with the legacy system.
12:42:47 <EvanR> why not?
12:43:36 <argiopeweb> mauke: I'd prefer not to drop into IO from 5 levels into pure functions. I'm clearly going to need to reconsider my design since I can't seem to avoid it.
12:44:24 <ion> You *are* dropping into IO, but in a very wrong way.
12:44:25 <argiopeweb> EvanR: Because I can't change the legacy system. Believe me, I've tried to get them to use one of the standards-compliant sources of unique ids.
12:44:28 <Eduard_Munteanu> argiopeweb: http://www.haskell.org/haskellwiki/Top_level_mutable_state
12:44:40 <EvanR> argiopeweb: you can choose your unique ids
12:44:44 <argiopeweb> ion: Indeed. I'm just (attempting unsuccessfully) to hide it.
12:44:47 <EvanR> nothing stops you from choosing compatible ones
12:45:54 <argiopeweb> Eduard_Munteanu: Thanks. I'll give it a read through. I'm fully aware that it's a painfully unsatisfactory hack, I just have not yet found a satisfactory way around it.
12:45:57 <erizawa> a
12:45:57 <erizawa> a
12:45:57 <erizawa> a
12:45:57 <erizawa> a
12:45:59 <ion> Hiding side-effectful computation is EBW.
12:46:34 <Eduard_Munteanu> argiopeweb: just the unsafePerformIO parts
12:46:43 <mauke> あ
12:46:52 <Cale> argiopeweb: If some pure function depends on the current time, that should be a parameter
12:46:55 <Eduard_Munteanu> Notice the NOINLINE pragma
12:47:01 <Cale> argiopeweb: It's not hard, just do it :)
12:47:07 <argiopeweb> mauke: That's a different pronunciation. :P
12:47:11 <djahandarie> あ－あ－ありがとう！！！！
12:47:14 <Cale> The explicit dependence on time will make it clearer what's going on
12:47:16 <ion> α
12:47:23 <Cale> ア
12:47:31 <Eduard_Munteanu> That doesn't make it safe though.
12:47:31 <EvanR> Cale: you make it sound so simple ;)
12:47:39 <Cale> It *is* simple
12:47:42 <EvanR> heh
12:47:48 <Cale> You add a parameter
12:47:52 <EvanR> yes, but the world doesnt realize it
12:47:53 <Cale> and you supply the parameter
12:47:58 <mauke> argiopeweb: not in german
12:48:10 <Cale> and at the top level, you get the current time in your IO action and you pass that in
12:48:17 <Cale> EZPZ
12:48:18 <ion> ａ
12:48:19 <argiopeweb> mauke: French either, as I remember. I stand corrected.
12:48:44 <mauke> djahandarie: gesundheit
12:48:49 <byorgey> you can also use the Acme.Time.Now module ;)
12:49:03 <Cale> Acme.Time.Now doesn't do what you want, most likely
12:49:15 <EvanR> byorgey: i mentioned that already ;)
12:49:15 * byorgey was joking =)
12:49:19 <ion> What you say? An Acme module might not be useful?
12:49:29 <Cale> lol
12:49:33 <argiopeweb> Negative. What I have currently is a roundabout way of writing Acme.Time.Now (should be the same after optimizing)
12:49:40 <EvanR> lol
12:49:52 <Cale> argiopeweb: Don't use unsafePerformIO, it's completely unnecessary here
12:50:00 <argiopeweb> Though it works prior to optimization.
12:50:01 <EvanR> unnecessary and insufficient
12:50:05 <Cale> Just run epochTime at the top level, and pass it in
12:50:13 <Cale> Or pass the result of it in, rather
12:50:16 <Cale> as a parameter
12:50:28 <Cale> Pass it down to wherever it's needed
12:50:47 <Cale> You'll thank yourself later that you did it that way, I guarantee.
12:51:18 <Cale> Debugging code that has weird time-dependent unsafePerformIOs in it is not fun.
12:51:46 <argiopeweb> Cale: More than likely. There's a mildly finite number of places that I actually need to create these unique identifiers, so it shouldn't be too much hassle if I work it right.
12:52:01 <EvanR> mildly finite
12:52:08 <Cale> If you need a unique supply, try...
12:52:08 <argiopeweb> Mildly.
12:52:21 <EvanR> 'not that bad' == 'bad'
12:52:23 <Cale> http://hackage.haskell.org/package/value-supply
12:52:30 <argiopeweb> As in "seems infinite".
12:52:51 <monochrom> "Though it works prior to optimization" is the last straw
12:52:52 <Cale> That library has some evil in it, but the evil is safely encapsulated.
12:52:57 <EvanR> i suggested that, and he said theres no way to provide a supply of identifiers in the correct format
12:53:09 <Cale> orly
12:53:11 <Cale> okay
12:53:28 <EvanR> apparently it has to be based on the current time
12:53:51 <worker_thread> err, what's a good reading material for Petri Nets?  I mean, no fancy stuff, but something that would go over most stuff one would expect to know when talkin 'bout Petri nets ?
12:55:30 * hackagebot snap-core 0.5.2 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.5.2 (GregoryCollins)
12:55:32 * hackagebot snap-server 0.5.2 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.5.2 (GregoryCollins)
12:55:34 * hackagebot snap 0.5.2 - Snap: A Haskell Web Framework: project starter executable and glue code library  http://hackage.haskell.org/package/snap-0.5.2 (GregoryCollins)
12:58:35 <EvanR> monochrom: last straw? did you silence him?
13:02:03 <chridi> hi
13:02:45 <monochrom> last straw for proving that unsafePerformIO is used wrong there
13:03:18 <monochrom> every correct use of unsafePerformIO survives optimizations
13:03:35 <chridi> i want to do dynamic programming in haskell... this is a recursive approach with a table to store the results of a recursive function...
13:03:56 <chridi> i thought i dont need to worry about this, because haskell does something like that anyway
13:03:59 <monochrom> http://www.haskell.org/haskellwiki/Dynamic_programming_example
13:04:03 <chridi> oh
13:04:04 <chridi> thanks :)
13:04:12 <monochrom> haskell does not do something like that
13:05:00 <chridi> but isnt that lazy evaluation?
13:05:10 <chridi> i'll read the article
13:05:25 <EvanR> dynamic programming? recursion? lazy evaluation
13:05:27 <EvanR> ?
13:05:38 <monochrom> lazy evaluation helps, but you still have work to do
13:06:58 * EvanR reads
13:16:22 <k0ral> aren't there System.Process functions that would work with Data.Text instead of String ?
13:16:39 <monochrom> are there?
13:16:49 <EvanR> i thought you just wanted to drop the first line
13:17:19 <k0ral> I've just turned all my String into Text and now I realize I'm using readProcess which expects a String so that I must unpack my Text so what's the point ?
13:17:31 <EvanR> all the text?
13:17:34 <k0ral> EvanR: yes but I also send the file content to dmenu
13:18:08 <EvanR> how much content?
13:18:19 <k0ral> hundred lines file
13:18:33 <k0ral> each line is a URI
13:19:29 <EvanR> you can unpack individual lines right before sending via the commands that dont expect megabytes of [Char]
13:19:59 <EvanR> or use String for the entire thing, with the assumption that youll never have more than a 100 or so lines
13:21:01 <EvanR> that being said this System.Process lib seems like a weird way to send a lot of data to another program
13:21:16 <k0ral> well, how would you send data to dmenu ?
13:21:42 <EvanR> which function are you talking about
13:22:22 <k0ral> I'm talking about the dmenu software (http://tools.suckless.org/dmenu/)
13:22:31 <EvanR> in System.Process
13:22:35 <k0ral> ah
13:22:54 <k0ral> well, all functions that make it possible to spawn a new process with a given input
13:22:59 <EvanR> unpacking Text to a String as late as absolutely necessary is better than doing all of the processing on the String
13:23:02 <k0ral> they all require a String
13:23:10 <EvanR> unless its a small amount of data anyway
13:23:34 <k0ral> but it doesn't make sense here: I have to send ALL data to the external process
13:23:43 <k0ral> the whole file
13:23:47 <EvanR> ALL data, directly from the file?
13:23:55 <EvanR> i thought you were doing processing
13:23:55 <k0ral> without the first line -_-
13:24:05 <monochrom> use Handle rather than String. then you can do whatever you want
13:24:38 <EvanR> hGetLine
13:24:46 <monochrom> for example createProcess :: CreateProcess -> IO (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle)
13:25:06 <monochrom> with a Handle you can pump it String or Text or Iteratee or whatever
13:25:21 <k0ral> I like that
13:25:48 <EvanR> monochrom: could you give it the handle to the open file as-is ?
13:27:13 <monochrom> not with createProcess. but apparently runProcess can take it
13:27:50 <k0ral> hmmm how would I get stdout back from the handle ?
13:27:57 <monochrom> sorry, createProcess can take it too
13:28:20 <EvanR> stdout, different handle
13:28:39 <k0ral> hGetLine ?
13:29:00 <monochrom> or hGetBuf or Iteratee or whatever
13:29:12 <k0ral> is this a blocking function ?
13:29:18 <monochrom> it's a Handle, do you already know how to read from a Handle?
13:29:44 <k0ral> I'm reading at the f****** manual, yes
13:29:57 <monochrom> Handle is not a function. I don't know whether Handle is a blocking function or a non-blocking function
13:30:12 <k0ral> I'm talking about hGetLine
13:30:26 <monochrom> hGetLine is blocking
13:30:36 <EvanR> it will block if nothing ready to read yet
13:30:48 <EvanR> or not complete line
13:30:57 <EvanR> except for EOF
13:31:09 <k0ral> if the process never sends anything, it will block forever then, which is bad
13:31:28 <EvanR> use a forkIO thread to wait for output
13:31:58 <monochrom> then don't use hGetLine
13:32:08 <k0ral> monochrom: what are my options ?
13:32:26 <monochrom> everything in System.IO
13:32:56 <k0ral> isn't hGetLine from System.IO ?!
13:33:07 <k0ral> ah you mean everything except hGetLine ?
13:33:13 <monochrom> I did not bring up RTFM. I just asked do you already know how to read from a Handle.
13:33:23 <EvanR> hIsReadable :: Handle -> IO Bool
13:33:35 <EvanR> now you can poll!
13:34:42 <monochrom> this is the problem with dive-in projects. dive in, and have the water surface way over. great plan to get stuck
13:35:35 <k0ral> don't understand what you mean monochrom
13:35:51 <k0ral> EvanR: fin, I'll hack this one
13:35:53 <k0ral> fine*
13:36:00 <EvanR> i already suggested a forkIO
13:36:10 <EvanR> i also dont really know the scope of your project
13:36:21 <k0ral> yes but having tons of zombies forks doesn't seem a pretty thing, does it ?
13:36:40 <EvanR> zombies?
13:36:53 <EvanR> you plan to have tons of zombie processes?
13:36:55 <k0ral> "undead" ?
13:37:14 <monochrom> forkIO is not a ton of zombies
13:37:17 <k0ral> if I spawn dmenu without selecting an entry, the fork will wait forever
13:37:23 <k0ral> I call this an undead fork
13:37:32 <EvanR> hGetLine blocks until theres a line or EOF
13:37:58 <monochrom> frankly, you know too little about the libs to finish this project, that's what I mean
13:37:59 <OceanSpray> has there ever been a need for RAII in Haskell?
13:38:13 <EvanR> no
13:38:18 <PhillipA> :t bracket
13:38:20 <lambdabot> Not in scope: `bracket'
13:38:24 <k0ral> monochrom: oO
13:38:35 <c_wraith> Sort of.  Lightweight monadic regions are basically like RAII
13:38:47 <kmc> :psyduck:
13:38:47 <c_wraith> as is bracket, and a few other ideas
13:38:51 <k0ral> monochrom: then maybe you should ignore me from now
13:39:11 <monochrom> my recommended strategy would be to do no projects. just learn the ropes of the language and the libs with toy examples. get familiar with what's available in the libs. before diving into any "useful" projects
13:39:21 <kmc> i'm not convinced any analogy between Haskell and C++ is useful
13:39:32 <c_wraith> OceanSpray: the thing is, this is haskell.  control flow is just functions.  If you want a particular flow, write a function that does it.
13:39:43 <OceanSpray> right
13:40:19 <k0ral> monochrom: well, you seem too much self-convinced so I won't even try to discuss why I disagree with this
13:40:52 <monochrom> do you agree that you are not familiar with System.IO and Control.Concurrent?
13:41:28 <k0ral> of course
13:41:37 <monochrom> then we're in perfect agreement
13:42:19 <k0ral> full stop
13:42:26 <k0ral> :)
13:43:48 <monadic> There's never a need for anything beyond lambda calculus
13:43:49 * edwardk frowns. i have 3 thinks that want to be a newtype called Dual in my algebra package
13:44:17 <EvanR> k0ral: well theres ways of doing this in a non blocking manner, and you will end up writing something 1.7 times as bad as equivalent C code if you use them
13:44:21 <edwardk> well i guess two of them are related
13:44:21 <monochrom> DualJohn, DualMary, DualZackery
13:45:20 <edwardk> i want an algebra for dual numbers, but i also need dual bases so i can talk about the dual complex numbers using the trigonometric coalgebra and dual quaternions, because they are nicer to compute with than quaternions over covectors.
13:45:22 <EvanR> and this doc says hGetBufNonBlocking doesnt work in windows, so i say avoid it like the plague
13:45:36 <monadic> EvanR: Doesn't sound like a setback to me...
13:45:51 <k0ral> EvanR: I'll make my way with the blocking one, thank you for guiding me :)
13:45:56 <edwardk> but then there is also the 'dual quaternions' which are not the dual basis of the quaternions, but instead are dual numbers built out of quaternions
13:46:06 <EvanR> monadic: well were developing windows software here...
13:46:10 <monadic> EvanR: Really it depends on the target, if you are aiming at something that you don't care about user base, ie something internal or a server, then its fine :)
13:49:44 <EvanR> edwardk: i know a guy whos doing some gnarly numerical shit with dual quaternions
13:49:59 <bobbens> unit dual quaternions
13:49:59 <edwardk> the dual number kind?
13:50:12 <edwardk> screw coordinate work?
13:50:24 <bobbens> yes, infinitessimal and finite screw systems
13:50:29 <edwardk> that was where i first encountered them
13:50:39 <bobbens> theoretical kinematics :)
13:51:29 <edwardk> i used to tackle lots of visibility probems, so i usually didn't need the freedom to insert the screw motion, but i did use the screw coordinates for some inverse kinematic calculations
13:51:52 <bobbens> well I do kinematic synthesis, of which inverse kinematics is a "trivial problem" :)
13:52:33 <edwardk> most of the time i could just dumb down to the grassmanian manifold f2,4 to represent the space of lines
13:53:01 <bobbens> well, inverse kinematics considers the joint axes known
13:53:02 <edwardk> fair nuff =)
13:53:05 <bobbens> kinematic synthesis does not :)
13:53:18 <bobbens> and that changes the problem a fair amount :)
13:53:25 <edwardk> yeah. i just had to get feet to stick to floors =P
13:54:04 <bobbens> http://www.youtube.com/watch?v=czF4vBmNiH0
13:54:13 <bobbens> presenting that at a conference late august
13:54:18 <bobbens> silly results of kinematic synthesis :P
13:54:34 <edwardk> cool stuff
13:54:35 <bobbens> also wrote a "minimal" C lib on dual quaternions
13:54:40 <bobbens> wanted to get around to messing with haskell
13:54:52 <bobbens> but if my solver takes up to 30 hours on some datasets, I decided against it :P
13:55:37 <EvanR> bobbens: theres got to be another way...
13:55:45 <edwardk> i'm adding dual numbers as an algebra in my algebra library, and since i work with arbitrary free vector spaces and can do tensor products of them, the dual quaternions in this setting are just literally memoized functions from (DualBasis, QuaternionBasis)
13:56:08 <bobbens> well if you work with screw systems you can do much more
13:56:12 <edwardk> the best result i've had so far is that i can get a really really nice encoding of geometric algebra
13:56:13 <bobbens> not only sticking to clifford algebra
13:56:18 <bobbens> but the fun stuff is in using Lie algebra
13:56:26 <edwardk> by encoding the geometric algebra as a coalgebra instead
13:56:27 <bobbens> it's much nicer, but it's extremely problematic with finite screw systems
13:56:50 <edwardk> because i have a very efficient encoding of linear functionals
13:57:34 <edwardk> well, i'm working in a geometric algebra built as a coalgebra, so i have infinite dimensional spaces, i just have covectors that can only inspect a finite number of terms in them that pushes the infinities into different places than usual
13:57:51 <shapr> I have a Coal Gebra.
13:57:51 <bobbens> I know pretty little about maths :)
13:58:01 * shapr wanders off to write Python code...
13:58:10 <bobbens> I just know a bit about clifford algebras and Lie algebras and their application to screw systems :P
13:58:36 <bobbens> j.m. selig also recently published the laws of motions using the clifford algebra Cl(0,6,2) iirc, was pretty awesome
13:58:42 <bobbens> but I don't think it's really usable :)
13:59:24 <EvanR> bobbens: inspiring video
13:59:36 <bobbens> the dataset in it sucks, I have onethr with a better one
13:59:42 <edwardk> yeah i always have to work out from the Cl(x,y,z) nonsense what the description of the basis is to think about them. ;)
13:59:50 <bobbens> which actually does a grasping motion
14:00:26 <bobbens> the problem is my solver is really dependent on input data
14:00:50 <bobbens> but I have an idea to solve it using special constraints using the Lie algebra of the infinitessimal screw system formed by the model
14:01:08 <bobbens> clifford algebras are too clunky to work with :)
14:01:10 <edwardk> your stuff does build some creepy alien armatures =)
14:01:16 <edwardk> agreed
14:01:18 <bobbens> I select only the best :P
14:01:24 <bobbens> so imagine what the rest look like :P
14:01:29 <edwardk> haha
14:01:44 <EvanR> bobbens: do you have to account for robot arms hitting each other as they rotate into place?
14:02:05 <shapr> What's an abelian group with an associative, distributive, secondary operator and the power to corrupt mortals?
14:02:09 <edwardk> i prefer more direct geometric algebra encodings than the clifford algebras, because its too hard to read the coefficients you need out of clifford algebras
14:02:17 <bobbens> http://www.youtube.com/watch?v=6oEBksGzeOo
14:02:21 <bobbens> check at 0:40
14:02:28 <bobbens> it shows a proper grasping motion
14:02:32 <bobbens> that is index, middle and thumb
14:02:49 <bobbens> EvanR: theoretically no, since I'm representing the joint axes
14:02:53 <edwardk> shapr: an infernal semiring?
14:02:55 <bobbens> and their common normals
14:03:01 <bobbens> so it's not actually what the robot looks like
14:03:05 <bobbens> it's just a way of representing it
14:03:06 <shapr> edwardk: The One Ring
14:03:11 <edwardk> ah
14:03:15 <bobbens> as long as the joint axes are the same, anything works :)
14:03:25 <shapr> edwardk: stolen from http://www.irregularwebcomic.net/470.html
14:03:25 <bobbens> so actually creating a robot from the screw axes is a whole 'nother problem :P
14:03:49 <EvanR> bobbens: yeah so if you directly translate it into a robot it might get tangled up ;)
14:04:13 <bobbens> well that's another problem, solving and selecting best solution from a set of solutions
14:04:22 <bobbens> but I think with my new constraints I have in mind it'll be much sexier
14:04:29 <bobbens> because of the nature of the constraints
14:05:03 <EvanR> also whats wrong with human hands ;)
14:05:24 <bobbens> complicated :P
14:05:39 <bobbens> actually the original goal was recovering the hand model from input data obtained through computer vision
14:05:45 <bobbens> but that failed epically
14:05:53 <bobbens> because the bezout bound is 10^{1058}
14:06:03 <bobbens> real amount of solutions probably around 10^{30}
14:06:07 <bobbens> or maybe even less :P
14:06:34 <EvanR> i bet a defense contractor would pay more than the government for this kind of research
14:06:39 <kmc> robots?!?
14:06:41 <kmc> in my #haskell
14:06:53 <shapr> Highly theoretical discussion on robots...?
14:07:30 <EvanR> we need a robot haskell lib
14:07:44 <bobbens> there's machine learning ones
14:07:53 <shapr> Um, there's already the Dance lib by ... Hudak
14:08:20 <kmc> 'atom' and 'copilot' would be useful for robots
14:08:48 <shapr> Hudak's Dance is more for choreography, it's roughly Labonotation.
14:09:13 <EvanR> atom looks amazing
14:09:23 <shapr> I keep thinking there's gotta be a good DSL for knitting ... something like juggling's site-swap notation, and Labonotation for dance. Or perhaps there's a generalization for 3D motion capture?
14:10:14 <shapr> Hudak's Dance is here btw: http://haskell.cs.yale.edu/?post_type=publication&p=168
14:10:18 <shapr> I have a copy of the source code somewhere.
14:10:28 <luite> knitting is trivial, everyhing is equal to the unknot!
14:10:42 <bobbens> I got an argument with someone today about this, is it possible to do full code verification from a theoretical point of view of a piece of 100% haskell code?
14:11:01 <kmc> what does that mean
14:11:08 <kmc> you have to start with some assumption
14:11:19 <kmc> maybe your CPU is hit by cosmic rays or invaded by canadian spies
14:11:25 <EvanR> lol
14:11:36 <bobbens> well let's assume computer can't fail :)
14:11:49 <EvanR> and infinite memory
14:11:51 <monadic> bobbens: Doesn't that imply solving the halting problem?
14:12:03 <kmc> you can implement Haskell in Coq or Agda and prove things about your program wrt your implementation
14:12:08 <kmc> the same is true of C and x86 machine code, and has been done
14:12:09 <bobbens> that's what they were telling me, don't know, I'm not a CS person :)
14:12:10 <Nimatek> That does sound like the halting problem to me.
14:12:26 <kmc> yes, proving the program correct is as hard as proving a turing machine doesn't halt
14:12:30 <monadic> For it to be verified it would have to produce the right answer, hence it has to halt
14:12:34 <kmc> which is something you can do
14:12:45 <Nimatek> Which means you can verify some pieces of code, but not all.
14:12:54 <kmc> it means *you* can verify some pieces of code but not all
14:13:02 <kmc> and that someone else can verify other pieces of code you can't
14:13:12 <Nimatek> Well yes.
14:13:14 <kmc> and superintelligent aliens from the future can verify yet more pieces of code
14:13:18 <bobbens> mmm, computer science is hard
14:13:19 <kmc> but nobody can verify all of it
14:13:24 <bobbens> I should stick to theoretical robotics :P
14:14:05 <EvanR> have you solved the positronic brain theory yet?
14:14:11 <kjslag> Is there a graph data structure that supports equality on the graph, and not just equality on the representation of the graph? eg, Data.Graph says 2 graphs from Data.Graph.graphFromEdges are unequal even if you only relabel the keys.
14:14:48 <kmc> graph isomorphism is hard
14:15:41 <luite> kjslag: it's usually based on a canonical relabeling
14:16:15 <kjslag> luite: are there any examples of canonical relabeling that you know of?
14:16:48 * hackagebot lzma-enumerator 0.1.1 - Enumerator interface for lzma/xz compression.  http://hackage.haskell.org/package/lzma-enumerator-0.1.1 (NathanHowell)
14:18:14 <kjslag> luite: nvm, thx. google found some :)
14:18:23 <shapr> kjslag: What did you find?
14:18:48 <kjslag> shapr: looking at http://en.wikipedia.org/wiki/Graph_canonization to start with
14:19:28 <kmc> canonization? really?
14:19:33 <kmc> that's great
14:19:42 <EvanR> lol
14:19:43 <kmc> i would expect "canonicalization"
14:19:56 <kjslag> lol, i didn't even notice
14:20:24 <EvanR> graph canonization was accelerated, pope ratzinger said
14:20:51 <luite> kjslag: a practical implementation is nauty
14:21:32 <luite> that does the standard orderly algorithm but with some cleverness, vertex invariants, to make it more efficient
14:22:09 <luite> but it's rather low-level C code with lots of bit manipulation
14:22:11 <kjslag> luite: nice, thx
14:22:55 <Enigmagic>  
14:33:01 <OceanSpray> okay
14:33:09 <OceanSpray> has anyone read this paper?
14:33:10 <OceanSpray> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.136.3606&rep=rep1&type=pdf
14:33:26 <OceanSpray> What in the nine hells is a substructural type system?
14:33:44 <EvanR> might be related to structural types
14:33:55 <EvanR> like in scala?
14:41:09 <dibblego> preflex: xseen ndm
14:41:09 <preflex>  ndm was last seen on freenode/#haskell 213 days, 2 hours, 36 minutes and 46 seconds ago, saying: if you don't, then there was a parse error
14:42:48 <EvanR> any libraries for reading word, excel, powerpoint?
14:43:39 <b_jonas> EvanR: openoffice, save as rtf, or something from cpan
14:44:08 <EvanR> cpan?
14:44:13 <EvanR> perl?
14:44:21 <b_jonas> also possibly save as csv or one of these new xml format, or do part of the extracting in excel/winword macros or win32 automation of excel.
14:44:24 <b_jonas> EvanR: yes
14:45:21 <EvanR> what about haskell
14:45:31 <EvanR> specifically word, excel native files
14:45:47 <EvanR> or basically nothing can interface with that
14:46:25 <shapr> EvanR: I converted a bunch of ms.doc files to xml via openoffice, and then processed the resulting xml. But I was turning the ms.doc files into a custom flavor of xml for a client.
14:47:02 <b_jonas> EvanR: the problem is, they weren't designed to be read by other programs
14:47:14 <EvanR> yeah
14:47:16 <b_jonas> EvanR: that's why they winword can save as rtf, and lately this xml format
14:47:34 <b_jonas> still, some of these perl modules reputedly do nice work on reading them
14:47:37 <b_jonas> without using winword
14:47:41 <b_jonas> or excel
14:48:00 <EvanR> shapr said he used open office
14:48:07 <shapr> EvanR: I read the openoffice xml standard (microsoft standard == much pain) and used HXml Toolbox to convert.
14:48:28 <EvanR> sounds valuable
14:48:31 <EvanR> $_$
14:48:54 <b_jonas> I have sometimes used winword and excel macros to extract stuff hidden in winword and excel documents
14:48:56 <shapr> I got paid to convert the documents, nobody cared that I wrote Haskell.
14:49:08 <b_jonas> though in at least one case I decided afterwards it wasn't worth it
14:49:19 <b_jonas> and I should just have parsed the rtf with perl or something
14:49:46 <shapr> Ok, who here is not in my Google Plus Haskell circle? I must add you!
14:49:47 <EvanR> shapr: interesting that the client knew what they wanted
14:49:54 <EvanR> shapr: im not in your circle
14:50:05 <shapr> EvanR: last name?
14:50:09 <EvanR> R
14:50:28 <EvanR> also i dont have google+
14:50:31 <shapr> ok then
14:51:38 <jonkri> anyone knows how i can find the packages depending on this package: http://hackage.haskell.org/package/crypto-api ? i would like to find some hash implementations :P
14:52:18 <EvanR> http://hackage.haskell.org/package/digest
14:52:29 <EvanR> hmm not many there
14:52:45 <EvanR> http://hackage.haskell.org/package/cryptohash-0.7.0
14:53:19 <benmachine> there used to be a revdeps hackage but I think it's down now :(
14:57:43 <msieradzki> how do I debug a crash that happens only when I use ghci (I enabled core dumps in OS)?
15:02:26 <jonkri> EvanR, i need sha-1, and i already have crypto-api as a dependency :)
15:03:54 <jonkri> EvanR, great, how did you find that? :)
15:04:06 <jonkri> benmachine, aha
15:04:11 <EvanR> uh
15:04:12 <EvanR> what
15:05:10 <benmachine> presumably referring to the conversation of twelve minutes ago
15:05:22 <benmachine> which has become two pages ago because everyone having flaky connections
15:05:55 <EvanR> my memory was indeed cleared
15:07:09 <jonkri> how you found the cryptohash package
15:07:12 <EvanR> is there another quantum lib besides quantum-arrow
15:07:20 <EvanR> jonkri: i dont remember
15:07:26 <jonkri> no problem :)
15:07:35 <EvanR> also apparently it uses C code
15:07:38 <EvanR> so its boring
15:07:47 <jonkri> how can i get the 4-octet encoding of the integer 1 with most significant octet first?
15:08:11 <EvanR> use Data.Bits
15:08:12 <jonkri> i mean, how do i generally solve that kind of problem? :)
15:08:28 <kmc> using Data.Bits
15:08:29 <jonkri> i agree it would be more exciting if it was a pure library :)
15:08:33 <jonkri> obliged
15:08:41 <kmc> what kind of problem is that?
15:09:14 <monochrom> a bit of a problem :)
15:09:32 <msieradzki> is there any reason why 2 threads doing putStrLn would crash other than some weird interaction with one of C libraries I have loaded?
15:09:46 <jonkri> kmc: solving what Data.Bits solves :)
15:12:19 <benmachine> msieradzki: I don't think so
15:12:33 <benmachine> *Reading* text sometimes crashes with encoding errors
15:12:36 <benmachine> don't think writing can do that
15:12:56 <EvanR> benmachine: interesting
15:13:16 <msieradzki> well I went back to stone age methods I commented call to C library and it stopped crashing
15:13:18 <benmachine> EvanR: if by interesting you mean kinda annoying then yes :P
15:14:49 <msieradzki> hmm would starting ghci from gdb catch crashes like I think it would?
15:16:22 <EvanR> benmachine: is that a problem in general or with ghc
15:16:29 <monadic> msieradzki: I don't see anything special about ghci as opposed to any other program...
15:16:44 <monadic> msieradzki: Although I doubt that would give you any useful information
15:16:59 <EvanR> haskell is immune to debuggers
15:17:05 <EvanR> 100% resistance
15:17:09 <benmachine> EvanR: it's intentional, inasmuch as string IO throws an exception when your input is improperly encoded
15:17:17 <benmachine> it's an exception you can catch
15:17:27 <thoughtpolice> msieradzki: actually in this case it might. if it's a call to a foreign function that's crashing it, it *may* be possible that it'll crash inside the foreign function, and you could look at a stack trace
15:17:33 <EvanR> benmachine: ok so not segfault
15:17:38 <msieradzki> well I crash instantly in glClear
15:17:43 <benmachine> EvanR: oh, no
15:17:45 <thoughtpolice> but generally speaking haskell compiled executables have a very different execution model than C, so GDB otherwise doesn't know what it's really doing
15:18:00 <msieradzki> only if I have 2nd background thread doing threadDelay+putStrLn (but that might be matter of "luck")
15:18:04 <thoughtpolice> and if you crash and do *not* land in C code, but in haskell-land, well, that's a bit more complicated
15:18:06 <monadic> thoughtpolice: You could use haskell's C backend
15:18:13 <kmc> s/haskell/GHC/
15:18:17 <kmc> or maybe JHC or something
15:18:17 <thoughtpolice> monadic: it doesn't matter anyway
15:18:31 <kmc> but the C code output by GHC is barely better than assembly
15:18:32 <thoughtpolice> the C it generates is highly non idiomatic and furthermore it undergoes post-generation preprocessing to properly optimize things like tail calls
15:18:34 <kmc> all of the variables have type W_
15:18:38 <thoughtpolice> yes, what kmc said
15:18:53 <kmc> speaking as someone who's spent a fair amount of time staring at GHC-produced C code in GDB, it's not that useful ;P
15:18:56 <thoughtpolice> monadic: gdb would have no better luck with it than native generated code i'm afraid
15:19:05 <monadic> thoughtpolice: Ahh, okay
15:19:06 <kmc> it's useful if you are chasing bugs in GHC's codegen or RTS but it's not easy then either
15:19:07 <thoughtpolice> kmc: you were using -fvia-c? heretic!
15:19:17 <kmc> thoughtpolice, i was using *unregisterized* fvia-C
15:19:23 <thoughtpolice> oh
15:19:27 <kmc> even worse
15:19:52 <jonkri> i need a four-octet encoding of the integer 1 with the most significant octet first. with Data.Bits, bit 0 is the least significant bit. is the significance of bits and bytes always the same? i'm confused :)
15:20:13 <thoughtpolice> yeah, but that's the only case where you can possibly use -fvia-C now I think. flogging/pitchforks avoided
15:20:40 <EvanR> jonkri: ... extract the four octets in whatever order you want
15:20:50 <EvanR> let them be called a b c and d, now write [a,b,c,d]
15:20:52 <EvanR> done
15:21:07 <benmachine> jonkri: what exactly do you need the encoding for? if you're doing serialisation, maybe the binary package can help
15:21:21 <benmachine> (or cereal)
15:22:40 <jonkri> benmachine, i need to concatinate two octet strings for use with hmac (i'm implementing scram for an xmpp library)
15:22:56 <jonkri> where the second string is the int i mentioned above
15:23:15 <benmachine> jonkri: what output type do you want?
15:23:15 <jonkri> so i want to get a four-byte bytestring i guess :)
15:23:19 <benmachine> ah
15:23:23 <benmachine> try binary or cereal
15:23:26 <benmachine> I believe they have functions for this
15:23:28 <benmachine> not sure though
15:23:34 <jonkri> looking at binary now
15:24:01 <jonkri> thanks benmachine
15:24:20 <benmachine> putWord32be
15:24:21 <benmachine> or le
15:24:26 <benmachine> I can never remember which is which :P
15:24:38 <benmachine> http://hackage.haskell.org/packages/archive/cereal/0.3.3.0/doc/html/Data-Serialize-Put.html#v:putWord32le
15:25:12 <msieradzki> OT: how do I get gdb to start debugging whole tree of processes started by a script, in other words how do I tell gdb to debug ghci :)
15:25:42 <ion> I’d like Data.Serialize’s get side to be more Parsec-ish. I wonder if one could integrate Data.Serialize for putting with Attoparsec for getting?
15:25:57 <jonkri> ah, so i want big-endian. i see :)
15:27:43 <ByronJohnson> The disadvantages of using "binary" include the inability to purely handle errors.  The disadvantegs of using "cereal" include the inability to serialize directly to lazy bytestrings.  I consider the former to be a worse disadvantage in most cases, so I prefer to use "cereal", although I usually provide instances for both.
15:28:45 <jonkri> ByronJohnson, you answered my question before i could ask it :)
15:28:53 <ion> Something like this is annoying (if i have missed a good way to do this kind of stuff with Data.Serialize, i’ll appreciate correction). do tag <- getBytes 2; Protocol1 <$ guard (tag == protocol1Tag) `mplus` Protocol2 <$ guard (tag == protocol2Tag) `mplus` fail "Expected a protocol tag, got " ++ show tag
15:30:11 <ion> Too much boilerplate that Parsec-style libraries handle implicitly.
15:30:31 <Saizan> how do parsec-style libs handle that?
15:30:36 <ion> (Getting the proper amount of bytes, generating informative error messages.)
15:31:13 <msieradzki> I think I found the cause, it seems that OpenGL calls kind of work when there's single thread but if there are many I need to run OGL code within runInBoundThread
15:31:58 <msieradzki> isn't main :: IO () supposed to be running inside bound thread already?
15:31:58 <ion> Something along the lines of: Protocol1 <$ string protocol1Tag <|> protocol2 <$ string protocol2Tag
15:32:27 <kmc> msieradzki, i didn't think so
15:32:41 <ion> Where, as i said, getting the proper amount of bytes and the generation of an error message like “expected <this> or <this>, got <that>” happens implicitly.
15:32:43 <kmc> you can also send all your OpenGL IO actions through a Chan and have one bound thread that executes them
15:32:49 <msieradzki> "Also, the main action of every Haskell program is run in a bound thread. "
15:32:54 <msieradzki> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
15:32:56 <kmc> oh, hmm
15:34:27 <msieradzki> or maybe ghci doesn't know that my Client.main is main? :)
15:36:11 <Saizan> that's most likely
15:46:17 <identity_> Hmm
15:46:19 <identity_> Trying out happstack
15:46:25 <identity_> but I can't kill my server with ctrl+c
15:46:32 <identity_> it's kind of annoying to kill it with task manager every time
15:46:35 <identity_> I'm on windows, by the way
15:46:40 <identity_> Any hints? etc
15:47:12 <hpc> you should be able to ^C twice...
15:47:13 <ion> There’s a pain that comes and goes in my eye. I’m poking myself in the eye with a stick, by the way.
15:47:29 <identity_> ion: :(
15:47:32 <hpc> iirc, GHC will read the second one, and kill the program
15:47:39 <hpc> well, the runtime
15:47:44 <identity_> I would prefer to be using linux except I'm too lazy to reboot
15:47:48 <c_wraith> hpc: unless the handler has been overridden
15:53:46 <greenland> apparently logging into IRC allows me to immediately find the answer in LYAHFGG
15:53:48 <msieradzki> identity_, snap framework is quite similar and has autoreloading as far as I know
15:54:50 <c_wraith> greenland: handy feature of IRC.  not to be underestimated.
15:55:03 <Eduard_Munteanu> Yeah, that guy pretends to have written a book on Haskell, and HE is asking question? :P
16:04:14 <mmphosis> hi
16:04:58 <mmphosis> spinning beachball
16:05:54 <zmv_> !protontorpedoo
16:06:54 <zmv> oh
16:06:59 <zmv> @protontorpedo
16:06:59 <lambdabot> Im wondering if there are uncharted business waters that haskell can enable, even if it is simply by not accepting norms
16:07:12 <zmv> (damn you other bots)
16:10:19 <jonkri_> how would you xor two bytestrings?
16:11:29 <kmc> BS.pack . BS.zipWith Bits.xor
16:11:33 <fxr> jonkri_: zipwith?
16:11:51 <kmc> you can do something more efficient if you need extreme performance
16:11:57 <fxr> kmc: you're fast :)
16:12:06 <jonkri_> nice :) it's good
16:12:08 <kmc> thanks
16:12:19 <fxr> @karma+ kmc
16:12:20 <lambdabot> kmc's karma raised to 21.
16:13:10 <Eduard_Munteanu> Well, you should avoid packing and unpacking
16:13:20 <kmc> yes, but how to do it in this case Eduard_Munteanu?
16:14:18 <shachaf> Why isn't there a version of zipWith that returns a ByteString?
16:14:19 <c_wraith> I'm kind of surprised there isn't a bytestring zipWith that results in a bytestring.
16:14:38 <shachaf> It shouldn't be very difficult to implement, should it?2
16:14:53 <c_wraith> No, it's relatively easy to implement.
16:15:10 <c_wraith> :t B.map
16:15:11 <lambdabot> Couldn't find qualified module.
16:15:16 <c_wraith> :t BS.map
16:15:17 <Eduard_Munteanu> kmc: hrm, you got me there
16:15:18 <lambdabot> (Word8 -> Word8) -> BSC.ByteString -> BSC.ByteString
16:15:30 <c_wraith> zipWith is just map2
16:15:42 <Eduard_Munteanu> It's problematic since one would expect better performance xoring whole Word32/64s
16:16:20 <kmc> right, but zipWith is not going to do well there
16:16:35 <kmc> I think if you need extreme performance on this operation, today, you should drop down to the mutable ByteString interface
16:16:50 <Eduard_Munteanu> c_wraith: there also isn't a mapM_ for bytestrings, which I found useful on a few occasions
16:16:57 <kmc> Eduard_Munteanu, are they Traversable?
16:17:03 <kmc> no, because not functors
16:17:10 <Eduard_Munteanu> No, say a bsMapM_
16:17:13 <c_wraith> they're not functors because they don't have a type variable
16:18:53 <Eduard_Munteanu> I wonder why there isn't any way to get Words efficiently, that'd seem like a common pattern.
16:19:10 <shachaf> It would be nice if ByteStrings had WordN views for N > 8.
16:19:15 <fxr> nope
16:19:26 <fxr> it's called *Byte*String
16:19:38 <Eduard_Munteanu> I'd call it a RawString :)
16:19:59 <fxr> you better use Stream instead of WordNString
16:20:06 <kmc> Eduard_Munteanu, well, that is byte-order dependent
16:20:10 <kmc> it's probably not the hugest issue though
16:20:19 <kmc> you can convert between ByteString and Vector.Storable without a copy
16:20:22 <shachaf> kmc: Not for zipWith xor. :-)
16:20:35 <Eduard_Munteanu> Yeah, you'd still have to use something like 'binary' to handle it
16:21:31 <Eduard_Munteanu> But yeah, I suppose one could just use Storable and play around with pointers, or mmap files or that sort of stuff.
16:21:47 <fxr> one can use enumerators
16:21:59 <kmc> some can
16:22:02 <kmc> i can't ;P
16:22:18 <Eduard_Munteanu> I should look into those sometime.
16:22:33 * shachaf distrusts enumerators.
16:22:38 <fxr> why not?
16:23:26 <Eduard_Munteanu> Lazy I/O is convenient at times I suppose.
16:23:59 <fxr> just change the enumerator from enumWord8 to enumWord16 and you can use the same iterator.
16:26:36 <parcs> so does anyone know how to coerce cabal into using another linker that's not /usr/bin/ld?
16:26:50 <dcoutts> parcs: --with-ld=...
16:27:13 <dcoutts> parcs: but you may also want to tell ghc to use a different ld or gcc
16:27:30 <dcoutts> parcs: depends what you really want to do
16:28:34 <DukeDave> Has anyone here worked on wxHaskell?
16:28:37 <DukeDave> I just: darcs get http://code.haskell.org/wxhaskell/
16:28:45 <DukeDave> And: ./configure
16:29:10 <DukeDave> Which tells me to "type 'make' to build wxhaskell.", but there's no makefile :|
16:29:30 <c_wraith> DukeDave: did you try installing it from hackage?
16:32:01 <dcoutts> DukeDave: if you're getting it from sources you might need to run autoreconf or something like that
16:32:05 * dcoutts is only guessing
16:34:26 <DukeDave> c_wraith: You mean, getting it with a cabal fetch?
16:34:40 <DukeDave> (is fetch the command which gets the source without building?)
16:34:48 <c_wraith> cabal unpack is what gets source
16:34:55 <c_wraith> but I mean "why not cabal install"?
16:35:39 <ByronJohnson> DukeDave: "cabal update && cabal install wx" should be simpler.
16:35:49 <dcoutts> DukeDave: yes, fetch gets the source without building
16:37:42 <DukeDave> ByronJohnson: I actually want to do some hacking on wxHaskell though, so I need to build it myself...
16:37:46 <DukeDave> dcoutts: Thanks
16:39:17 <parcs> dcoutts: i would like to use a more efficient linker (gold) (due to memory constraints) when installing packages
16:39:50 <parcs> --with-ld seems to have not changed what linker gets called
16:40:02 <ByronJohnson> DukeDave: Since 0.12.1.1, only building using Cabal is supported
16:40:22 <ByronJohnson> DukeDave: You can cd into wxcore, "cabal configure" and  "cabal build && cabal install"
16:41:07 <parcs> i.e. `strace -f -e execve -- cabal --with-ld=ld.gold install --reinstall safe 2&>1 | grep gold` outputs nothing
16:42:03 <HugoDaniel> :D
16:42:29 <dcoutts> parcs: you need to tell gcc to use the other linker
16:42:42 <dcoutts> parcs: cabal calls ghc, ghc calls gcc and gcc calls ld
16:43:09 <DukeDave> ByronJohnson: Thanks!
16:43:16 <DukeDave> ByronJohnson++
16:43:20 <dcoutts> parcs: cabal calls ld directly in some rare situations, but not for most things
16:45:18 <parcs> dcoutts: well i'm able to have ghc use ld.gold by doing something like `PATH="/path/to/gold/aliased/as/ld:$PATH" ghc ...' but that doesn't work through cabal for some reason
16:45:57 <dcoutts> parcs: really? it should do
16:46:13 <dcoutts> we don't do anything funny to alter the $PATH before calling ghc
16:51:13 <parcs> i just attempted it again and can affirm that it still calls /usr/bin/ld
16:56:16 <thoughtpolice> parcs: what system? AFAIK, on several systems that allow you to install gold from package managers they normally alias 'ld' to point to 'ld.gold' and you can configure it. or is this your own build?
16:56:37 <thoughtpolice> (i did this on my debian system, so i effectively had gold linking my GHC produced binaries, etc)
16:57:20 <parcs> thoughtpolice: there is no such thing for arch (for better or for worse)
16:57:23 <thoughtpolice> i'm just wondering because i thought the way most distros were going with it was to try and make gold as a linker as transparent as possible.
16:57:28 <thoughtpolice> parcs: ah, that explains it then
16:57:44 <DukeDave> Hmm, I did a "cabal configure", but I'm getting "Missing C libraries: wx_baseu-2.8 ....." even though I have "libwx_baseu-2.8.so" in /usr/lib    :(
16:58:03 <DukeDave> Why cabal hate me :(
16:58:16 <thoughtpolice> DukeDave: do you have the development libraries? like, headers for wx in /usr/include ?
16:58:19 <parcs> arch installs gold into bin/ld.gold
16:58:34 <monochrom> libwx_baseu-2.8.so is not enough
16:59:03 <DukeDave> thoughtpolice: I thought I did, but now I can't see them :|
16:59:27 <thoughtpolice> DukeDave: yeah, cabal checks all that when it tries. if you do 'cabal install -v' i bet you can see the failing line, and it's probably related to headers, not linking
16:59:41 <monochrom> you need "development headers and library"
16:59:56 <thoughtpolice> right, on debian systems the package for that is normally '<pkgname>-dev'
17:00:04 <thoughtpolice> (as an example)
17:00:24 <DukeDave> thoughtpolice: Mmm, I've got all the -dev packages
17:01:14 <thoughtpolice> hm... try 'cabal install -v' and check what it says
17:01:42 <DukeDave> thoughtpolice: Well I'm just doing cabal configure at the moment, configure's -v doesn't help :
17:01:47 <thoughtpolice> you can also do 'cabal install -v3' to get a *lot* of output and see pretty much everything
17:02:12 <thoughtpolice> DukeDave: yes, try -v3
17:02:21 <DukeDave> I have "/usr/include/wx-2.8/wx/", but I don't think that's what it's looking for :|
17:02:42 <thoughtpolice> trying to install wxcore?
17:02:42 <DukeDave> Damn that's verbose
17:02:52 <DukeDave> thoughtpolice: I am
17:03:34 <DukeDave> "/usr/bin/ld: cannot find -lwxmsw28ud_media"
17:03:39 * DukeDave is slightly out of his depth now
17:03:49 <jonkri_> how come i get an "No instance for Data.Serialize.Serialize SHA1" error when i have imported http://hackage.haskell.org/packages/archive/cryptohash/0.7.0/doc/html/Crypto-Hash-SHA1.html#t:SHA1 ?
17:04:33 <thoughtpolice> DukeDave: oi, and googling that does not give very helpful results :/
17:04:43 <thoughtpolice> except the vague notion "it is related to wxWindows"
17:04:45 <Polarina> jonkri_: Are your versions equivalent to those documented?
17:05:02 <DukeDave> Grr
17:05:10 <jonkri_> Polarina, yes, cryptohash ==0.7.0 specified in cabal file
17:05:48 <DukeDave> There's a bunch of them: "-lwxmsw28ud_media","-lwxmsw28ud_richtext","-lwxmsw28ud_aui","-lwxmsw28ud_xrc"
17:06:01 <Polarina> jonkri_: Do you have code that shows the issue?
17:06:42 <parcs> hmm wait no
17:07:36 <parcs> why is gcc used during cabal's build process
17:08:01 <dcoutts> parcs: because it needs to compile c code
17:08:21 <dcoutts> parcs: and also, it's used at configure time to check if libs are present on the system
17:08:30 <dcoutts> and header files
17:08:55 <hpaste> jonkri pasted “Serialize problem” at http://hpaste.org/49291
17:09:15 <jonkri_> Polarina, ^
17:09:26 <Lemonator> So I wrote a simple IRC bot
17:09:36 <Lemonator> it crashes on average once every 12 hours
17:10:00 <Lemonator> due to some really really weird error about Broken Pipes
17:10:27 <identity_> buy sturdier pipes
17:10:47 <identity_> Lemonator: Sounds like it's getting disconnected
17:11:08 <parcs> i was wrong: there are calls to both ld.gold and ld
17:11:10 <Lemonator> well
17:11:14 <jonkri_> i think i should sleep and continue tomorrow :)
17:11:20 <Lemonator> is that normal?
17:11:31 <Lemonator> I mean, it's running on a VPS
17:11:47 <identity_> Lemonator: It shouldn't be getting disconnected, obviously, but the irc server might just have an unstable connection
17:11:47 <Lemonator> and I don't experience a disconnect on my client every 12 hours.
17:11:51 <identity_> ah
17:12:22 <identity_> Lemonator: At any rate, a good idea would probably be to add a logging mechanism to your bot
17:12:34 <identity_> Depending on how you designed it, it can be easy
17:12:47 <PhillipA> Lemonator: are you ignoring SIGPIPE?
17:12:53 <Lemonator> Philippa, probably.
17:13:04 <PhillipA> wat
17:13:12 <identity_> if it's running over StateT/ReaderT or something like that you can just add a Chan to your state and write to it every time etc
17:13:21 <identity_> hve a thread on the other side writing to to file
17:13:54 <hpc> or just a Handle, and do your writes at the same time
17:14:16 <identity_> works too
17:14:55 <hpc> just don't set the log handle to unbuffered
17:15:02 <identity_> hpc: why not?
17:15:02 <hpc> i got some pretty bad disk thrashing ;)
17:15:10 <identity_> ah, like that
17:15:24 <hpc> imagine writing a 10mb log file 30 times a minute :P
17:15:39 <greenland> unbuffered is 1 byte per read, no?
17:15:41 <Lemonator> it's been a while, so I'm trying to dig up the error message the last time the crash happened.
17:16:26 <identity_> Lemonator: I seem to remember my ircbot complaining about broken pipe when it got disonnected
17:16:30 <identity_> but it's a while ago
17:17:33 <Lemonator> okay hre
17:17:35 <Lemonator> Bot: fd:7: hGetContents: invalid argument (Invalid or incomplete multibyte or wide character)
17:17:44 <identity_> ah, that
17:17:48 <identity_> I got that as well
17:18:01 <identity_> I could crash my bot using unicode characters iirc
17:18:08 <identity_> I had to go to bytestring
17:18:20 <PhillipA> that's what you get for using Handles and hGetContents
17:18:32 <hpc> my bot is cool with unicode, and i just used Handle and String
17:18:47 <jonkri_> Polarina, you were right, i needed a new version of a depending package :)
17:18:59 <Lemonator> dang
17:19:01 <Polarina> jonkri_: :)
17:19:02 <identity_> Lemonator: Search for NumberSix on github if you want to change to bytestring. jasper does some nifty stuff
17:19:03 <Lemonator> ByteString, really?
17:19:06 <identity_> overloaded strings etc
17:19:08 <Lemonator> okay
17:19:19 <identity_> hpc: Mine was fine with most. There were certain characters that would crash it and I have no idea why
17:19:46 <identity_> at any rate, I'm off to bed. good luck.
17:19:48 <PhillipA> you can avoid all of that by using sockets and bytestrings
17:20:00 <identity_> or iterators
17:20:06 <Lemonator> well thanks
17:20:08 <identity_> iteratees*
17:20:35 <identity_> Lemonator: In general, numbersix is a pretty fucking good example of a well designed bot, if you need inspiration
17:20:50 <monochrom> if you write an irc bot, you can be almost sure that someone will feed it bytes that lead to decoding errors. you should just disable decoding by using hSetBinaryMode, or going ByteString
17:21:42 * hackagebot algebra 0.7.0 - Constructive abstract algebra  http://hackage.haskell.org/package/algebra-0.7.0 (EdwardKmett)
17:21:49 <monochrom> even if you expect utf-8, you should do the decoding as a separate stage so you can error-handle
17:21:59 <Lemonator> alright
17:25:44 * hackagebot algebra 0.7.1 - Constructive abstract algebra  http://hackage.haskell.org/package/algebra-0.7.1 (EdwardKmett)
17:26:26 <bobzhang> hi, is there anyway to suppress the ghci warnings and other noise messages?
17:27:33 <greenland> is there a shorthand way to square a value more concise than multiplying by itself?
17:27:40 <kmc> bobzhang, yes, fix your code
17:28:16 <monochrom> "x^2" may be more concise but also may be slower
17:28:25 <bobzhang> kmc: i have other ways to know the warnings without using ghci, so I wanna turn it off
17:28:49 <kmc> i don't actually know the opposite of -Wall
17:28:55 <shachaf> @src ^
17:28:56 <lambdabot> x ^ 0            =  1
17:28:58 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
17:29:00 <lambdabot>   where f _ 0 y = y
17:29:02 <lambdabot>         f x n y = g x n
17:29:04 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
17:29:06 <lambdabot>                       | otherwise = f x (n-1) (x*y)
17:29:08 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
17:29:11 <monochrom> you may like to define your own "compute_the_square_of_the_argument x = x*x" if you use it at several places
17:29:14 <kmc> pointsfree (^2) looks nicer than (join (*))
17:29:58 <c_wraith> isn't -wall supposed to be the opposite of -Wall ?
17:30:25 <bobzhang> kmc: and how to turn off the load package information?
17:30:34 <bobzhang> thank you
17:30:41 <kmc> don't know
17:33:04 <ion> > x^2
17:33:06 <lambdabot>   x * x
17:33:18 <ion> See? It gets optimized to a multiplication.
17:33:21 <Lemonator> I am trying to install number-six
17:33:22 <ion> > x^42
17:33:24 <lambdabot>   x * x * (x * x) * (x * x * (x * x)) * (x * x * (x * x) * (x * x * (x * x)))...
17:33:31 <Lemonator> and apparently mime is a dependency
17:33:52 <Lemonator> but mime depends on base 3-4
17:33:59 <ion> bobzhang: Rather turn on -Wall, too.
17:34:07 <Lemonator> which can't be fulfilled because other packages need >4
17:34:30 <Lemonator> so I edited mime's cabal file and installed it manually
17:34:43 <Lemonator> yet number-six is still trying to configure and install mime
17:34:47 <Lemonator> what is going on?
17:35:01 <dankna> @tell glguy yes it's still the case - they didn't change anything from the gold master
17:35:01 <lambdabot> Consider it noted.
17:41:19 <bobzhang> ion: actually i just want to suppress the messages when loading different modules
17:50:13 <clsmith> hey. if the xlib bindings have a Dimension type, and i want to multiply the dimension by a fraction, but then end up with an integer dimension, how do i do it? :/ ghc keeps whining that there's no "fractional dimension", but i can't find a way to convert it. </noob>
17:51:08 <kmc> :t (floor, ceil, round)
17:51:09 <lambdabot> Not in scope: `ceil'
17:51:13 <kmc> :t (floor, ceiling, round)
17:51:14 <lambdabot> forall a b a1 b1 a2 b2. (RealFrac a, Integral b, RealFrac a1, Integral b1, RealFrac a2, Integral b2) => (a -> b, a1 -> b1, a2 -> b2)
17:51:19 <parcs> :t div
17:51:21 <lambdabot> forall a. (Integral a) => a -> a -> a
17:51:36 <kmc> :t [floor, ceiling, round]
17:51:37 <lambdabot> forall a b. (RealFrac a, Integral b) => [a -> b]
17:52:08 <shachaf> I wish GHC didn't do the a a1 a2 thing.
17:52:10 <parcs> clsmith: is the fraction < 1 ?
17:52:10 <clsmith> see, atm i'm doing (sw * mfact), where sw is a dimension and mfact is 0.618. rounding doesn't do anything
17:52:28 <clsmith> yeah ^
17:52:45 <clsmith> (well, rounding just comes up with a realfrac error iirc)
17:52:46 <Cale> round (fromIntegral sw * mfact)
17:53:07 <kmc> @quote monochrom fromIntegral
17:53:08 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
17:53:36 <clsmith> Cale: ah! thanks
17:53:48 <clsmith> i find haskell's numerics really confusing :/
17:54:09 <Cale> clsmith: You basically just need to be aware of which numeric type you'd like the calculations to occur in.
17:54:24 <Cale> In order to multiply two numbers they have to have the same type
17:54:46 <Cale> Since you probably don't want to round/ceil/floor mfact, as that throws away too much precision
17:55:03 <PhillipA> clsmith: there's two types of numbers, integers and floats
17:55:08 <Cale> you instead probably want to convert the integer you're working with to whatever floating point type mfact is
17:55:21 <Cale> and then round the result
17:55:46 <Cale> fromIntegral will convert a value of any integer-like type to any numeric type you'd like
17:56:03 <clsmith> Dimensions (which seem to be Word32?) seem to act differently to integers, as well :|
17:56:04 <Cale> (and in particular, it can convert it to the type that mfact is, whatever that is)
17:56:20 <Cale> Yeah, that's okay
17:56:34 <Cale> They're almost certainly in the Integral class
17:56:37 <Cale> :t round
17:56:38 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
17:56:48 <Cale> and round will produce anything Integral that you want
17:57:02 <clsmith> hmm, ok
17:57:03 <clsmith> thanks :)
17:57:35 <PhillipA> Word32 is integers
18:01:03 <kmc> well, it's a 32-bit unsigned integer type
18:01:12 <kmc> which is not the same as Int or Integer
18:01:24 <PhillipA> even Int is not the same as Integer
18:01:26 <dilinger> i really want to like RWH
18:01:40 <kmc> clsmith, Haskell has no implicit type conversions or promotions
18:01:41 <dilinger> but this writing style is incredibly frustrating
18:01:46 <kmc> that's why you have to use fromIntegral etc.
18:02:06 <copumpkin> oh man, it's mauke
18:03:33 <dpratt71> is there a tool or technique to convert .lhs to plain old .hs?
18:04:22 <shachaf> dpratt71: http://www.haskell.org/haskellwiki/Literate_programming#Transformation_of_.lhs-files
18:04:58 <shachaf> Wait, that's not what you want.
18:05:00 <shachaf> Never mind.
18:05:24 <Lemonator> I got this weird idea.
18:05:53 <Lemonator> Has anyone ever tried to implement Lambda calculus "bare-to-the-metal" ?
18:06:22 <Lemonator> And I don't mean those cute little interpreters they put into sardine cans.
18:07:04 <kmc> not actually that but http://www.cs.york.ac.uk/fp/reduceron/
18:07:05 <Lemonator> Like, something that compiles call-by-value System F to something that uses the processor's native calling convention and doesn't do any garbage collection.
18:07:12 <kmc> oh
18:08:10 <Lemonator> Like, are closures REALLY needed?
18:08:29 <PhillipA> well, you could do refcounting
18:08:30 <Lemonator> How about, instead of heap allocation, we just push everything onto the stack?
18:08:32 <kmc> how do you propose to implement function values instead?
18:08:37 <Lemonator> call and return by value.
18:08:46 <PhillipA> value of what?
18:08:53 <PhillipA> all values are 32 bit integers
18:08:55 <Lemonator> store the captured values into a struct and call that.
18:08:57 <kmc> how do you compile \x -> \y -> x+y
18:09:01 <kmc> that's called a closure
18:09:04 <Lemonator> okay
18:09:05 <kmc> that struct
18:09:09 <PhillipA> my processor doesn't support "structs"
18:09:17 <Lemonator> you want to compile \x -> \y -> x + y, eh?
18:10:16 <Lemonator> assuming we're dealing with 32bit integers, in C that would just be
18:10:32 <PhillipA> no, it wouldn't
18:11:35 <kmc> if i say "f = \x -> \y -> x + y" then i'm allowed to call (f 3) and stash away that function value and use it arbitrarily far in the future
18:11:40 <kmc> and somewhere you have to remember that x=3 in this particular case
18:12:00 <kmc> that is the problem which closures solve
18:12:06 <kmc> a closure is any data structure which solves that problem
18:12:13 <Lemonator> okay then
18:12:15 <Lemonator> we need closures.
18:12:28 <Lemonator> I really should have said instead
18:12:29 <kmc> now, there are ways to have closures without garbage collection
18:12:38 <Lemonator> "are HEAP-ALLOCATED closures really needed?"
18:12:46 <kmc> no, they are not
18:12:53 <Lemonator> so yeah
18:12:55 <kmc> if your programs are short-lived you never need to free memory
18:13:35 <Lemonator> well let's assume that the programs are long-lived too.
18:13:46 <kmc> maybe you can do refcounting or region inference
18:13:54 <kmc> these would still count as "heap-allocated", afaik
18:14:03 <Lemonator> no refcounting, no region inference.
18:14:14 <kmc> ok
18:14:25 <PhillipA> Lemonator: so ... what am I allowed to do?
18:14:30 <PhillipA> there's not much left
18:14:30 <kmc> well, do you propose another way to manage these things?
18:14:48 <Lemonator> you can move around a stack pointer and copy stuff.
18:14:51 <kmc> the whole point is that a closure represents a value that has outlived the function activation in which it was created
18:15:04 <kmc> hmm that sounds a lot like a copying garbage collector
18:15:08 <PhillipA> Lemonator: but I can't do region inference to see when I need to move the stack pointer
18:18:13 <Lemonator> surely you have enough imagination to implement 'closures' in C without using malloc.
18:18:35 <PhillipA> not really
18:18:45 <PhillipA> it would be extremely impractical
18:18:50 <kmc> haha, is this a troll?
18:19:04 <kmc> surely you have enough imagination to implement an algorithm for deciding whether diophantine equations have solutions
18:19:30 <copumpkin> lol
18:19:54 <kmc> i think the burden is on you to provide code or at least explain your implementation strategy so we can continue to discuss it
18:20:13 <Lemonator> okay
18:20:29 <PhillipA> I can think of a way
18:20:46 <PhillipA> step 1: analyze program to determine maximum function+bindings size
18:20:58 <PhillipA> step 2: generate custom "struct" for that
18:21:06 <PhillipA> this is your virtual machine word
18:21:23 <PhillipA> step 3: copy things around all over the place
18:22:10 <Lemonator> Yeah, basically.
18:22:12 <Lemonator> That.
18:23:15 <PhillipA> how is this practical and/or efficient?
18:23:33 <Lemonator> now hold on
18:23:57 <Lemonator> we got some assumptions here we can take advantage of in order to get some semblance of efficiency.
18:24:29 <Lemonator> first, there's no such thing as mutability.
18:24:43 <Lemonator> thus, if the pass by "value" value is too big to fit in a register or whatever,
18:24:58 <Lemonator> we can pass by pointer and get the same thing.
18:24:59 <PhillipA> everything is too big for a register, by definition
18:25:23 <PhillipA> if there's no mutability, there is no reason to copy anything ever
18:25:37 <PhillipA> so forget your "pass by value"
18:25:59 <Lemonator> what
18:26:04 <Lemonator> that's a ridiculous notion.
18:26:14 <Lemonator> of course you still need copying even if everything is immutable.
18:26:31 <Cale> Lemonator: Why would you need to copy things?
18:27:14 <Lemonator> you call a function F, and that function calls another function G with one of F's arguments unchanged.
18:27:30 <Lemonator> You need to copy at least one pointer from lower on the stack to a higher point.
18:27:36 <Cale> stack?
18:28:10 <Cale> I guess, if you're using a stack
18:28:14 <Lemonator> You know, the data structure we use to implement procedure calls?
18:28:21 <PhillipA> you mean a heap?
18:28:43 <kmc> stacks are just one way to implement procedure calls
18:28:54 <PhillipA> I want my gc'd chain of continuations
18:29:24 <Lemonator> okay, so instead of a stack what do you use?
18:31:36 <Cale> Everything is updates to a graph. I suppose you copy references to parts of the graph, but it shouldn't normally be necessary to copy parts of the graph structure itself, since you can make an arc to whatever vertex representing the expression you need.
18:32:56 <Lemonator> well there you go
18:33:10 <Lemonator> all that "copying" has been eliminated, so where's the inefficiency?
18:33:32 <ski> (also, it's when arguments are *reused* that you'd really have to copy the pointers. the calls themselves probably wouldn't need to incur any copying)
18:33:48 <Lemonator> Look, I really have no intention of trolling.
18:34:13 <Lemonator> Just describing this idea, which is very simple.
18:35:28 <Lemonator> since everything's immutable, when you push args onto the stack you push pointers if the value is too big, otherwise you push the value itself
18:36:05 <Lemonator> and when the procedure returns, use return value optimization to "copy" the result into the allocated place.
18:36:12 <dpratt71> any vim users? should I put this lhaskell.vim file in the ftplugin folder?
18:37:00 <Lemonator> Assuming that there are no graph-like datastructures, what would be the downside of this approach to implementing lambda calculus?
18:38:17 <Cale> Lemonator: are you saying, if the args are already evaluated? The args are usually going to be expressions.
18:38:31 <Lemonator> hm
18:38:50 <Lemonator> I specified "call-by-value" earlier on.
18:38:53 <Cale> oh
18:39:05 <Cale> I'm assuming we're talking about a Haskell-like language
18:39:18 <Lemonator> ah, there's the misunderstanding.
18:39:27 <Cale> Call-by-value = innermost-first?
18:39:27 <Lemonator> Sorry about that, should have been more explicit with that.
18:39:37 <Cale> I always forget what call-by-X means
18:39:41 <Lemonator> well, everything is strict.
18:39:46 <Cale> okay
18:39:53 <PhillipA> call-by-X doesn't mean much for any X
18:40:01 <Lemonator> So no thunks, no laziness, just the bog-standard calling method used for 99% of PLs out there.
18:40:16 <Cale> (so the downside of this approach is that programs that are supposed to terminate don't ;)
18:40:40 <Lemonator> well yeah, but people have learned to live with that for half a century (god knows how)
18:40:42 * cmccann implements a language that uses call-by-telephone
18:40:45 <Cale> But that's common
18:41:19 * PhillipA lifts up the receiver
18:41:20 <Lemonator> the only gross inefficiency I see in the stack-only-no-heap approach
18:41:33 <Lemonator> is when return value optimization cannot be applied.
18:42:03 <PhillipA> Lemonator: isn't RVO a special case of region inference and therefore disallowed?
18:42:03 <Lemonator> Like, when two or more giant tuple-like things are built up in a function, and it has to return one of them.
18:42:46 <Lemonator> PhillipA, technically, C-style stack usage is also region inference.
18:43:09 <PhillipA> oh shi-
18:45:11 <ski> Lemonator : er .. how is it *inference* !?
18:45:50 <Lemonator> ski, the compiler "infers" that local variables will never be used after the function returns, and so deallocates them.
18:46:04 <ski> which C compiler does this ?
18:46:20 <Lemonator> It's very crude, it's not foolproof, it's not sound or complete, but one COULD view it as a primitive sort of region inference.
18:46:26 <Lemonator> ski, all of them?
18:47:48 <PhillipA> it's not much of an inference. the compiler kills your variables no matter who might be using them
18:48:41 <cmccann> I think the main reason I prefer Stack Overflow to reddit these days is that, on SO, I can vote to close and delete utter rubbish, while on reddit nonsense gets upvoted like crazy and sparks hundred-comment-long threads of inane bickering.
18:52:26 <kmc> yep cmccann
18:52:31 <kmc> have you been on /r/programming by chance?
18:52:44 <edwardk> reddit seems a lot slower these days than it used to be. stuff winds up stuck to the top of the list for seemingly days
18:52:47 <cmccann> kmc, my therapist says I shouldn't talk about it
18:52:50 <kmc> yep
18:52:59 <kmc> you probably shouldn't
18:53:03 <cmccann> at least /r/haskell is usually pretty decent
18:53:03 <djahandarie> Speaking of which, major props to Peaker for actually responding to all that stuff in a level-headed manner
18:53:06 <ski> Lemonator : imo, it's not region inference if the system can't (automatically) allocate local variables created by a call in an activition frame which is longer-lived than the activition frame of the call in question
18:53:14 <cmccann> except for the occasional raving lunatic. sigh.
18:53:29 <kmc>  /r/haskell is a decent linkdump, yeah
18:53:37 <kmc> the comments are not terrible but i prefer this venue for discussion
18:53:38 <kmc> or SO
18:53:41 <cmccann> I kind of wish Peaker wouldn't, actually. it's a waste of his time, and is unlikely to help :T
18:53:47 <ski> Lemonator : *obviously* stack allocation is a subset of region allocation. the point was to have *proper* region allocation
18:53:50 <Axman6> Lemonator: that's not inference, that's just how stacks work...
18:54:23 <cmccann> djahandarie, gee, how'd you guess what was making me grumpy :P
18:54:45 <kmc> all of which stuff?
18:54:55 <djahandarie> There is a new thread on /r/prog about Haskell.
18:55:41 <djahandarie> I think it's safe to put a "BEWARE" sign on top of it unless you feel like raging for most of the night.
18:55:54 <Lemonator> ski, Axman6, PhillipA, I really don't see what your points are.
18:56:17 <kmc> "Freedom is the ability to say x = x + 1. If that is granted, all else will follow.
18:56:17 <kmc> "
18:56:23 <djahandarie> kmc, yeah.
18:56:28 <kmc> sorry i won't try to paste more gibberish here
18:56:32 <kmc> but, yeah
18:56:47 <kmc> i daresay though that this is at least more interesting than the usual proggit wankfests
18:56:58 * cmccann didn't think the article in question was all that interesting
18:56:58 <kmc> agile scrum javascript for Real Programmers
18:57:00 <ski> Lemonator : you're basically saying something similar to "never freeing stuff is a form of garbage collection". it's true, but only trivially/vacuously so
18:57:42 <ski> Lemonator : similarly, stack allocation is, in the trivial sense only, a form of region allocation
18:58:01 <Lemonator> only in response to PhillipA's inane objection to using RVO.
18:58:11 <kmc> Lemonator, still not trolling?
18:58:59 <Lemonator> nowhere was I proclaiming "STACKS IS REGION INFERENCE HOW DARE YOU QUESTION IT"
18:59:10 <Lemonator> christ, people
18:59:18 * cmccann goes back to closing terrible questions on SO
18:59:19 <Lemonator> why are you all so damn ornery?
18:59:41 <kmc> clearly you came here to pick a fight
18:59:54 <Lemonator> what
18:59:55 <Lemonator> how
19:02:56 * cmccann was tempted to reply to that "if x = x + 1 is granted blah blah all else follows" comment with something along the lines of "no, just integers"
19:03:19 <ion> > let x = x + 1 in x
19:03:24 <lambdabot>   mueval-core: Time limit exceeded
19:03:54 <cmccann> ion, oh, good point
19:04:05 <cmccann> x = x + 1 gives _|_, which proves everything
19:04:06 <cmccann> qed
19:04:11 <cmccann> it's so obvious
19:06:55 <cmccann> so, on the subject of blatant trolling, I was at the bookstore today
19:07:05 <cmccann> looked through the programming section, out of morbid curiosity
19:07:18 <cmccann> no sign of any books on scala
19:07:22 <cmccann> but two copies of LYAH
19:09:58 <smop> nice
19:10:03 <Axman6> > let x = x + 1 in x - x
19:10:07 <lambdabot>   mueval-core: Time limit exceeded
19:10:11 <cmccann> which means absolutely nothing, of course, and I wouldn't really want to antagonize scala folks anyway, but it amused me
19:10:20 <nyingen> cmccann: join #scala and tell them about it
19:10:30 <nyingen> you know you want to
19:10:39 <cmccann> nah
19:10:44 <Axman6> cmccann: it means people are buying the scala books and not the haskell ones :(
19:11:10 <cmccann> Axman6, no, the shelves were clearly being kept full and stocked. would've noticed if there was an extra space
19:11:35 <cmccann> and there was one book each about F#, Erlang, and Scheme also
19:11:40 <cmccann> scala was definitely being left out
19:11:54 <cmccann> kinda weird, actually
19:12:41 <nyingen> personally I prefer all of those languages (except maybe F#) to Scala
19:14:10 <cmccann> pretty much looked like someone decided to stick in a token book for niche languages among the countless shelves of Java Enterprisey Kopi Luwak Framework Tier B Certification Level 2.6 Study Guides or whatever
19:15:06 <nyingen> heh, kopi luwak
19:15:34 <aninhumer> I read Tier as Tiser also
19:15:52 <cmccann> nyingen, what, it's coffee, totally a valid Java framework name
19:15:54 <aninhumer> I prefer it that way
19:16:15 <nyingen> nice.
19:16:29 <nyingen> a particularly good choice, since kopi luwak is way overrated
19:16:44 <luite> have you ever drunk it?
19:17:26 <nyingen> friend of mine lives in Singapore, and he's had it a couple of times
19:17:43 <nyingen> he reports that it's nothing special and certainly not worth the price or stories
19:18:26 <cmccann> even if it is better, it's certainly not THAT much better
19:18:44 <luite> hmm interesting...
19:18:55 <nyingen> right.
19:19:09 <luite> cmccann: I don't think that's really the point, I don't think anyone would see it as a replacement for their daily regular coffee :)
19:19:19 <cmccann> it's a pretty common pattern with goods stratified by price vs. quality that price goes up more than linearly and quality sublinear
19:19:43 <nyingen> in the context of Java, though, it sounds exotic, but won't change your life
19:19:45 <cmccann> most expensive luxuries are a waste of money by almost any sensible definition
19:50:27 <shachaf> If I have two cabal executables with similar dependencies, do I have to give the full list of dependencies for both of them?
19:50:29 <monochrom> "x = x + 1" works fine with non-strict peano naturals. there are a few implementations on hackage
19:50:51 <monochrom> or rather "x = 1 + x"
19:51:20 <monochrom> yes
19:52:09 <parcs> monochrom: why does the order of operands matter?
19:53:05 <glguy> dankna: What aspect of GHC 7.0.3 doesn't work on OS X 10.7? I seem to be able to compile a HelloWorld on it
19:54:06 <dankna> the compiler itself cannot be compiled
19:54:14 <monochrom> because why does the order of "s = [()] ++ s" vs "s = s ++ [()]" matter
19:54:18 <dankna> existing binaries are fine
19:54:29 <glguy> OH, well that's great news :)
19:54:36 <dankna> seriously haha
19:56:19 <parcs> monochrom: what if S m + S n = S (S (m + n)); Z + n = n; m + Z = m
19:57:23 <monochrom> haskell is just a programming language. it is not a mathematician. all your math theorems are all very well
19:58:20 <parcs> if (+) were defined as that, the order of operands wouldn't matter, no?
19:58:38 <monochrom> as another example, you can prove "([0..] = [0..]) = True" all you want but haskell won't give you True
19:59:18 <glguy> Prove it where?
19:59:30 <monochrom> in human heads
20:01:17 <aavogt> parcs: then    1 + undefined > 0   won't be True
20:03:26 <eternalmatt> Would anyone happen to be a magician at currying?
20:03:48 <eternalmatt> I'm trying to have a function that performs like x^(y^z) for three variables
20:04:13 <eternalmatt> only curry all the inputs away. so the spirit would be like function = (^ (^))
20:04:30 <monochrom> interesting, with your definition, both x=x+1 and x=1+x diverge. so they're the same afterall
20:04:43 <glguy> eternalmatt: what definition of "curry" are you using?
20:05:05 <eternalmatt> as in, sum = foldr (+) 0
20:05:05 * hackagebot anansi 0.3.1 - Simple literate programming preprocessor  http://hackage.haskell.org/package/anansi-0.3.1 (JohnMillikin)
20:05:12 <eternalmatt> so you don't see the input of the function
20:05:16 <glguy> ?pl \ a b c -> a ^ (b^c)
20:05:17 <lambdabot> (. (^)) . (.) . (^)
20:05:19 <parcs> aavogt: yeah..
20:05:34 <glguy> eternalmatt: this is "currying"
20:05:38 <glguy> :t curry
20:05:39 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
20:06:07 <eternalmatt> wow glguy
20:06:21 <eternalmatt> can ghci do that type of analysis for me?
20:06:55 <glguy> eternalmatt: not on its own
20:07:15 <glguy> eternalmatt: the only time you should ever see "(. (^)) . (.) . (^)" written is when lambdabot does it to show you what not to do
20:07:25 <eternalmatt> ?pl \ a b c d e f -> a ^ (b ^ c) > d ^ (e ^ f)
20:07:26 <lambdabot> flip flip ((. (^)) . (.) . (^)) . ((flip . (((.) . (.) . (.) . (>)) .)) .) . (. (^)) . (.) . (^)
20:07:29 <eternalmatt> lmao......
20:07:41 <eternalmatt> this is for a problem on codegolf.stackexchange.com
20:08:13 <monochrom> you should just say "point-free"
20:10:19 <hpaste> int80_h pasted “Parse error, problem?” at http://hpaste.org/49292
20:11:53 <glguy> keepMaybes x:xs =
20:11:54 <glguy> missing ()
20:12:13 <int80_h> x is head of list, xs is the rest right?
20:12:28 <hpaste> glguy annotated “Parse error, problem?” with “try this” at http://hpaste.org/49292#a49293
20:12:31 <int80_h> x:xs is itself not a tuple
20:13:08 <int80_h> okay I will try, if it works I will have questions
20:13:39 <monochrom> you need to write like "f (x:xs) = ..." and it does not mean tuple either
20:15:37 <int80_h> monochrom: f (x:xs) makes me think I am passing a function as an arguement
20:15:52 <int80_h> monochrom: what would f be?
20:16:02 <greenland> does prefixing a variable with a single quote denote anything special?
20:16:07 <int80_h> nevermind, I get it
20:16:17 <greenland> ex: a'
20:16:17 <monochrom> "keepMaybes (x:xs) = ..."
20:16:57 <int80_h> okay new error, perplexing
20:17:13 <aavogt> greenland: a'  is just a regular name
20:17:33 <glguy> greenland: a' is "suffixed"
20:18:02 <aavogt>  'A  (and ''A) mean things in template haskell
20:18:03 <ion> greenland: It’s an ASCII approximation of the prime sign (′). http://en.wikipedia.org/wiki/Prime_(symbol)#Use_in_mathematics.2C_statistics.2C_and_science
20:19:04 <monochrom> I infer the type of keepMaybes to be [(a, Maybe b)] -> [(a,b)]
20:19:07 <monochrom> err sorry
20:19:11 <monochrom> I infer the type of keepMaybes to be [(a, Maybe b)] -> [(a, Maybe b)]
20:20:07 <hpaste> int80_h annotated “Parse error, problem?” with “Parse error, problem? (annotation)” at http://hpaste.org/49292#a49294
20:20:34 <cmccann> edwardk, so I figure by next week we'll be getting "jQuery is a locally discrete 2-category"
20:20:44 <monochrom> your logic does not match your type
20:20:56 <glguy>         (ip, Just server) -> x : keepMaybes xs  -- did you mean -- (ip, Just server) -> (ip,server) : keepMaybes xs
20:21:23 <monochrom> x's type is (a, Maybe b). by doing "x : keepMaybe xs", you cannot suddenly turn x's type to (a,b)
20:24:39 <int80_h> glguy: that appears to be right, I'm going to run some test data
20:28:19 <int80_h> works!
20:28:27 <int80_h> thanks once again
20:30:08 <int80_h> okay is it possible to write this function without using explicit recursion?
20:30:25 <int80_h> I only wrote it this way to express exactly what I wanted.
20:31:23 <int80_h> I tried to model this after catMaybes but I couldn't get the list comprehension correct. And I imagined that if I did manage to get it right, it would lok hideous.
20:32:51 <monochrom> > [ (x,y) | (x, Just y) <- [(0, Nothing), (1, Just ())] ]
20:32:52 <lambdabot>   [(1,())]
20:33:01 <glguy> int80_h: the closest library function for what you are doing is
20:33:04 <glguy> :t mapMaybes
20:33:05 <lambdabot> Not in scope: `mapMaybes'
20:33:24 <glguy> Prelude Data.Maybe> :t mapMaybe
20:33:24 <glguy> mapMaybe :: (a -> Maybe b) -> [a] -> [b]
20:34:02 <monochrom> there is a foldr solution too
20:34:24 <int80_h> I would have prefered a mapping function, I'll study mapMaybe.
20:34:38 * edwardk stops grinding his jquery-is-not-a-monad ax.
20:34:58 <kmc> edwardk, it's a comonad, right?
20:35:04 <edwardk> kmc: =)
20:35:06 <edwardk> exctly
20:35:14 <monochrom> > foldr (\(x,my) r -> case my of { Nothing -> r; Just y -> (x,y):r) [] [(0, Nothing), (1, Just ())]
20:35:15 <lambdabot>   <no location info>: parse error on input `)'
20:35:18 <int80_h> it's a nomonad
20:35:22 * int80_h ducks
20:35:26 <monochrom> > foldr (\(x,my) r -> case my of { Nothing -> r; Just y -> (x,y):r }) [] [(0, Nothing), (1, Just ())]
20:35:26 <lambdabot>   [(1,())]
20:35:47 <edwardk> kmc: just another post popping up on r/haskell purporting to show it as something like an applicative.
20:35:56 <edwardk> using weasel words to avoid claiming anything
20:36:13 <kmc> i love weasel words
20:37:32 <monochrom> my understanding is that our monad-comonad is the other way round of what some math books define
20:37:45 <eternalmatt> ?pl \a b c -> if a then b else c
20:37:45 <lambdabot> if'
20:37:47 <kmc> little endians!
20:37:55 <edwardk> monochrom: ?
20:37:58 <shachaf> edwardk: jQuery is a functor, though, right?
20:38:12 * edwardk headdesks.
20:38:31 <djahandarie> Pointed at least!!!
20:38:32 <int80_h> is that like facepalming?
20:38:35 <monochrom> we have join :: T (T a) -> T a etc. we call that monad. some math books call that comonad
20:38:47 <edwardk> int80_h: yeah
20:38:47 <copumpkin> monochrom: I've never seen that :o
20:38:51 <djahandarie> monochrom, what calls that a comonad?
20:38:51 <monochrom> and their monad is T a -> T (T a)
20:38:57 <copumpkin> maybe I've been reading the wrong books!
20:38:59 * cmccann still expects "jQuery is a locally discrete 2-category" next week
20:39:04 <edwardk> monochrom: not that i've ever seen, the standard construction goes back a long ways
20:39:05 <shachaf> At least jQuery has kind * -> *, I hope?
20:39:07 <copumpkin> but it is a comonad on the op-op-category
20:39:14 <copumpkin> or on the op-category, I mean
20:39:18 <copumpkin> :P
20:39:26 <djahandarie> copumpkin, no, you are already co, so it is the op-op-category
20:39:30 <copumpkin> oh okay
20:39:42 <cmccann> monochrom, I've never seen that either
20:39:43 <edwardk> they've been T (T a) -> T a since the days when they were called triples or standard constructions.
20:40:10 * cmccann has TTT in arm's reach, can look it up if necessary :P
20:40:12 <kmc> is op cat anything like nyan cat
20:40:14 <edwardk> so i can't think of any place since the word monad was introduced that would invert them
20:41:23 <djahandarie> kmc, it also shits rainbows in certain conditions
20:41:42 <edwardk> now vectors and covectors folks get mixed up all the time ;)
20:42:19 * djahandarie always mixes up covariant and contravariant types after talking about them for a month
20:42:30 <djahandarie> not talking*
20:43:00 <monochrom> use "contra" to help you. it is pretty unambiguous
20:43:33 <cmccann> djahandarie, I stand by my claim that keeping variance straight in languages with subtyping is too difficult to be practical in real-world use :T
20:43:35 <monochrom> I understand that "co" is ambiguous because "colinear" vs "coalgebra"
20:44:13 <monochrom> but seriously no one ever use "contra-x" to mean "like x"!
20:44:44 <shachaf> preflex: seen contrapumpkin
20:44:44 <preflex>  contrapumpkin was last seen on #haskell 122 days, 5 hours, 4 minutes and 10 seconds ago, saying: TheZimm: compared to these guys, not at all :P
20:44:59 <djahandarie> preflex, seen codolio
20:44:59 <preflex>  codolio was last seen on #haskell 8 days, 7 hours, 52 minutes and 37 seconds ago, saying: Hence why claims of "one combinator bases" are incorrect.
20:45:00 <cmccann> also, when using "contra-" if you get stuck, you can enter the konami code to get 30 extra lives
20:45:03 <djahandarie> preflex, seen coedwardk
20:45:04 <preflex>  coedwardk was last seen on #haskell 2 years, 98 days, 8 hours, 5 minutes and 27 seconds ago, saying: dammit
20:45:27 <monochrom> omg, it's a contrapumpkin!
20:45:36 <contradjahandari> Damnit!
20:45:38 <contrapumpkin> monochrom hello
20:45:42 <contrapumpkin> like yoda, I speak now
20:45:57 <monochrom> @remember contrapumpkin like yoda, I speak now
20:45:58 <lambdabot> It is stored.
20:46:13 <contrapumpkin> :)
20:46:29 <coedwardk> is that word ordering contra-diction?
20:46:54 <contrapumpkin> very frustrating, this https download issue is
20:47:17 <contrapumpkin> more options, I need
20:47:50 <shachaf> coedwardk: I read that jQuery article and now I'm upset like you.
20:48:12 <monochrom> @remember coedwardk <contrapumpkin> like yoda, I speak now <coedwardk> is that word ordering contra-diction?
20:48:13 <lambdabot> I will remember.
20:48:32 <contrapumpkin> shachaf: until you read the comments about "what haskell does not have", just wait. Very pissed, you will be
20:48:51 <monochrom> if you're upset, rename yourself to coshachaf as protest :)
20:48:57 <contrapumpkin> full of fucking idiots, reddit is
20:49:05 <monochrom> or contrashachaf if you like
20:49:11 * shachaf is in ~90 IRC channels, so he tries to minimize nick changes.
20:49:16 <coedwardk> shachaf: it is just a recurring theme. i find it more sad than upsetting
20:49:27 <dolio> And yet, you read it regularly.
20:49:37 <contrapumpkin> like a monad, I hear jquery is
20:49:38 <shachaf> contrapumpkin: Why do you read it?
20:49:46 <Chewie[]> kmc: ping
20:49:55 <monochrom> like idiots very much he doth
20:49:56 <shachaf> There should be a website that's like Reddit except good.
20:49:59 <contrapumpkin> shachaf: occasionally interesting, it is
20:50:00 * shachaf should patent that.
20:50:27 <contrapumpkin> shachaf: follow, the idiots will.
20:51:12 <djahandarie> yoda programs haskell?
20:51:14 <monochrom> yomg, coyoda is it!
20:51:24 <Eduard_Munteanu> Yonoda
20:51:43 <confab> i'm more surprised that nobody on freenode had the nick yoda
20:51:51 <dolio> shachaf: It's called lambda the ultimate. Except it's getting stupider, too.
20:51:55 <confab> at least, at the time
20:51:56 * Eduard_Munteanu wondered that too !
20:52:05 <monochrom> "the coyoda futurama projection theorem"
20:52:15 * shachaf knows that coyoda really reads Reddit for the comics.
20:52:31 <coyoda> shachaf: it's actually for /r/f5u7
20:52:58 <coedwardk> i keep reading coyoda as coyoneda
20:53:15 <monochrom> I read it as toyota
20:53:18 <Eduard_Munteanu> Mmm, the monad is strong in this one...
20:53:35 <cmccann> LtU mostly just seems to end up with a bunch of cluelessly enthusiastic wannabe language designers and a handful of erudite cranks
20:53:41 <shachaf> YodaLemma: YodaAlpeca is better.
20:53:48 <monochrom> rumours actually say that it should be toyoda but the japaneses want it easier on americans, so toyota
20:54:44 <djahandarie> It is トヨタ (toyota) in Japanese too, but the guy who owns it is indeed Toyoda.
20:54:55 <kmc> hi Chewie[]
20:55:03 <monochrom> perhaps he wants it easy on everyone :)
20:55:26 <monochrom> hey YodaLemma, is Toyoda your friend? :)
20:55:42 <YodaLemma> never of him, I have heard
21:00:43 <Chewie[]> kmc: remember that bisect function? turns out it is extremely expensive.
21:01:02 <Chewie[]> trying to find a way to optimize space. considering Data.Set but not sure how to implement.
21:01:22 <Chewie[]> if you don't remember then i may as well ask anyone, but i figured you may recall.
21:02:12 <Cale> Chewie[]: what does the bisect function do?
21:02:13 <kmc> i remember the problem but i don't have any clever ideas
21:02:20 <kmc> fundamentally you are trying to search a very large space here
21:02:35 <kmc> you might be better off with more sophisticated optimization techniques, or more explicitly heuristic approaches
21:03:14 <kmc> Cale, bisect :: [a] -> [[[a]]]; bisect xs returns all ways of splitting xs into non-empty lists
21:03:16 <Chewie[]> Cale: given a set (currently an array), generate as pairs every possible way to bisect it.
21:03:22 <kmc> er actually, that was a different function, using bisect
21:03:23 <kmc> right
21:03:38 <kmc> bisect :: [a] -> [([a], [a])]
21:03:42 <kmc> splitting into 2 only
21:03:50 <kmc> just power set but you get the other half too
21:03:51 <Cale> okay
21:03:54 <kmc> Chewie[], i think you mean "list" not "array"
21:04:05 <Cale> I think a key to it will be not sharing
21:04:06 <Chewie[]> yes.
21:04:13 <Cale> similarly with powerset
21:04:36 <Cale> combinations (x:xs) = combinations xs ++ map (x:) (combinations xs)
21:04:39 <Cale> is more efficient than
21:04:50 <Cale> combinations (x:xs) = let cs = combinations xs in cs ++ map (x:) cs
21:04:56 <Cale> in terms of space
21:05:26 <Chewie[]> bisect (x:xs) = nub $ concat [ [(x:a, b), (x:b, a)] | (a, b) <- bisect xs ]
21:05:42 <Chewie[]> for kmc's memory, Cale's info
21:07:02 <Chewie[]> isn't tail-recursive either, that is actually causing the biggest problem now that i remember
21:09:24 <augur> copumpkin: that shouldve been "heard of him i have not"
21:09:45 <copumpkin> augur: I thought of that, but my way sounded more stunted
21:09:57 <ColonelJ> Hi how do I make a () value to do nothing but make it happen in IO
21:10:00 <augur> copumpkin: yoda's syntax isnt stunted
21:10:08 <augur> he just does a great deal of VP fronting
21:10:12 <ColonelJ> return () doesn't seem to work
21:10:16 <augur> and some other complement fronting as well
21:10:35 <kmc> return () has type IO ()
21:10:49 <_Ray_> Hi :) map generalizes to fmap, and fmap is formalized as a Functor. I know fold generalizes to Foldable... but what are the theoretical foundations of this "Foldable" thing? Functor clearly has them
21:10:51 <ColonelJ> yea but when I do let x = that it doesn't work
21:10:51 <kmc> a value of type () can't "do" anything (including nothing)
21:10:53 <kmc> it just is
21:10:58 <kmc> define "work"
21:11:02 <kmc> what are you trying to accomplish
21:11:07 <glguy> ColonelJ: your question doesn't really make sense. Could you explain what you are doing in another way?
21:11:09 <kmc> main = do { let x = return (); x }
21:11:26 <coedwardk> ray: foldable is far less fundamental than functor. functor is unique given the laws and a type
21:11:36 <ColonelJ> well the problem is that it couldn't match IO () to ()
21:11:42 <kmc> right
21:11:43 <coedwardk> ray: foldable on the other hand admits many different distinguishable implementations
21:11:46 <kmc> because "return ()" has type IO ()
21:11:51 <augur> copumpkin: http://itre.cis.upenn.edu/~myl/languagelog/archives/002182.html
21:11:52 <kmc> it's a description of how to perform IO
21:12:01 <ColonelJ> right
21:12:05 <kmc> if you want something of type () you just write ()
21:12:10 <_Ray_> oh, alright. and on the other side, edwardk, what is the haskell notion of a natural transformation?
21:12:10 <kmc> :t ()
21:12:11 <lambdabot> ()
21:12:17 <edwardk> but in general foldable is about enumerability
21:12:25 <ColonelJ> I want something of type IO ()
21:12:31 <kmc> then "return ()" is correct
21:12:38 <ColonelJ> so why can't I do let x = return ()
21:12:41 <kmc> you can
21:12:45 <kmc> :t let x = return () in x
21:12:46 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
21:12:50 <_Ray_> (I just had my mind blown by the fact the determinant is a natural transformation from Ring to Group...)
21:13:03 <edwardk> type f :~> g = forall a. f a ~> g a
21:13:21 <_Ray_> hrm, never seen that syntax
21:13:24 <kmc> ColonelJ, what's the actual problem here?
21:13:47 <ColonelJ> it's well... hard to describe
21:14:01 <djahandarie> ColonelJ, fold generalizes to something more general than Foldable
21:14:08 <_Ray_> it also should be interesting considering all functors in haskell are just endofunctors in Hask
21:14:45 <djahandarie> ColonelJ, you can get a 'fold'-type thing from any fixed point of an F-algebra
21:14:48 <kmc> http://mainisusuallyafunction.blogspot.com/2010/12/type-level-fix-and-generic-folds.html
21:14:59 <edwardk> ray: that covers natural transformations even between contravariant or discrete functors
21:15:01 <djahandarie> Yes, read that article, it's a good one
21:15:07 <kmc> thanks djahandarie
21:15:12 <djahandarie> You're welcome kmc
21:15:39 <ColonelJ> I'm doing F algebra now I just find the IO thing a bit confusing atm
21:15:44 <edwardk> it just doesn't handle functors that can't be represented by kind * -> *
21:16:02 <edwardk> _ray_ we have other functors, we just don't call them Functor.
21:16:09 <_Ray_> such as?
21:16:42 <edwardk> http://hackage.haskell.org/packages/archive/contravariant/0.1.2/doc/html/Data-Functor-Contravariant.html
21:17:13 <ColonelJ> kmc if I do 'let asdf = print "asdf"' that gives me what I need except with a side effect
21:17:17 <edwardk> or even worse http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/src/Control-Functor-Categorical.html#CFunctor
21:17:20 <kmc> no there are no side effects
21:17:25 <kmc> "asdf" is now the name of an "IO action"
21:17:32 <kmc> an IO action is a value which describes how IO could be performed
21:17:38 <djahandarie> edwardk, you could have at least linked to your new one :p
21:17:39 <ColonelJ> I want such a definition that makes an IO action that does no IO
21:17:45 <kmc> let foo = return ()
21:17:51 <edwardk> _ray_ http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-HigherOrder.html as well
21:17:52 <ColonelJ> it gives an error on the console
21:18:02 <ColonelJ> Ambiguous type variable m
21:18:02 <_Ray_> edwardk: Thanks!
21:18:05 <edwardk> djahandarie: i don't have generalized functors around any more do i?
21:18:15 <djahandarie> edwardk, you do
21:18:17 <kmc> oh, see, that's a specific thing we can work with :)
21:18:23 <kmc> let foo :: IO (); foo = return ()
21:18:27 <edwardk> http://hackage.haskell.org/packages/archive/categories/0.58.0/doc/html/Control-Categorical-Functor.html
21:18:28 <edwardk> ah
21:18:30 <kmc> or:  let foo = (return () :: IO ())
21:18:35 <ColonelJ> ok kmc
21:18:35 <edwardk> i thought i'd just left it with bifunctors
21:18:38 <edwardk> =)
21:18:42 <kmc> anyway got to go, back later
21:18:48 <ColonelJ> I think I tried something similar but missed the () on the IO
21:19:39 <edwardk> just goes to show i only write this stuff. i don't actually remember what i wrote
21:27:08 <edwardk> trying to figure out how i can port all my AD machinery into my algebra package =/
21:29:34 <cmccann> wow, this just keeps getting more ridiculous: http://www.reddit.com/r/haskell/comments/iuhc0/what_haskell_doesnt_have/c26ybid
21:29:42 <cmccann> I think I need to stop feeding the troll at this point
21:29:44 <cmccann> :T
21:30:02 <mightybyte> Yeah, I'm reading that right now.
21:31:08 <geheimdienst> cmccann: here is an instructional video on not feeding trolls http://icanhascheezburger.com/2011/07/18/funny-pictures-videos-bird-attacks-cat/
21:32:15 <cmccann> geheimdienst, hahahaha
21:32:23 <cmccann> I think that cat is my new role model :I
21:33:32 <geheimdienst> ;)
21:33:32 <dolio> Until you have written commercial Haskell software, all your points are invalid.
21:33:40 <dolio> But mine are not, even though I haven't.
21:35:24 <cmccann> dolio, as it happens I've received money for writing software in Haskell, which is still being used in a commercial environment to solve business problems
21:35:33 <cmccann> ergo all my opinions are valid forever, qed
21:35:39 <cmccann> I can live with this
21:36:38 <dolio> Irrefutable.
21:37:16 <cmccann> copumpkin, thanks for the support on that ridiculous thread BTW :P
21:37:24 <cmccann> even if it ended up being completely useless
21:37:43 <copumpkin> yeah, I gave up, then ungave up, then gave up again
21:37:56 * copumpkin sighs
21:39:06 <cmccann> copumpkin, did you see the part where he claimed that offering evidence of my knowledge about Haskell was an "argument from authority" fallacy?
21:39:08 <dolio> I'm a big Haskell fan, but I feel compelled to point out several cliche misconceptions that make it unsuitable for 'real world' use.
21:39:29 <copumpkin> cmccann: I love people who go quoting names of standard fallacies at you in arguments :)
21:39:36 <blbrown_win3> anyone know a good book on type theory
21:39:46 <copumpkin> blbrown_win3: I quite like
21:39:48 <copumpkin> @where TTFP
21:39:48 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
21:40:01 <copumpkin> depends what are you're after though
21:40:06 <copumpkin> most people will recommend TAPL
21:40:27 <dolio> Read Proofs and Types.
21:40:40 <dolio> If it's not too elementary.
21:41:24 <blbrown_win3> copumpkin, I think that was the book I was looking for.  Just couldn't remember the name.
21:41:39 <blbrown_win3> copumpkin, freenode is a type of hivemind in that way
21:44:11 <ColonelJ> http://pastebin.com/cB1ErJaC   amidoinitrite?
21:44:14 <mauke> The paste cB1ErJaC has been copied to http://hpaste.org/49295
21:44:50 <dolio> Is mauke a paste bot now?
21:44:58 <copumpkin> yeah
21:45:03 <cmccann> I thought mauke was multiple bots
21:45:06 <luite> he seems to dislike pastebin :p
21:45:31 <geheimdienst> i think mauke just has some perl scripts hooked into his irc client
21:46:12 <copumpkin> knowing mauke, they're probably perl scripts that do the same thing when passed through the ruby interpreter, the python interpreter, runhaskell, and APL
21:46:19 <cmccann> I think the perl scripts are using irc and occasionally hook mauke into their irc client
21:47:07 <geheimdienst> copumpkin: ... while being quines
21:48:06 <copumpkin> :)
21:48:06 <ion> A quine with useful side effects would be cool.
21:48:15 <ion> FSVO useful
21:49:36 <edwardk> i wrote one that bumped a counter each time through in its source code and then compiled and exec'd the next version. does that count?
21:49:59 <ion> Nice
21:50:17 <geheimdienst> can it overflow or something?
21:50:33 <edwardk> yeah. i never let it run that long, but theoretically
21:50:34 <cmccann> how about a contravariant quine, that produces itself backwards
21:51:10 * cmccann is aware that doesn't really even make sense
21:51:12 <edwardk> cmccann: i forgot to mention that that was in the form of a palindrome, so it _was_ a contravariant quine ;)
21:51:21 <cmccann> edwardk, ha, nice
21:51:33 * cmccann tips his hat. well played, indeed
21:51:50 <rndm> yeah that was clever
21:52:30 <copumpkin> a contravariant quine, it was?
21:52:45 <edwardk> basically i stole some cheesy palindromic c quine and adapted it.
21:52:52 <copumpkin> in factor/forth, you should have written it
22:12:20 * hackagebot svm-simple 0.2.2 - Medium level, simplified, bindings to libsvm  http://hackage.haskell.org/package/svm-simple-0.2.2 (VilleTirronen)
22:28:22 * hackagebot CV 0.3.1.2 - OpenCV based machine vision library  http://hackage.haskell.org/package/CV-0.3.1.2 (VilleTirronen)
22:50:24 <QinGW> @src mapM
22:50:25 <lambdabot> mapM f as = sequence (map f as)
22:50:48 <QinGW> @src sequence
22:50:49 <lambdabot> sequence []     = return []
22:50:49 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
22:50:49 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
22:52:52 <QinGW> @src liftM2
22:52:53 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
23:38:34 * hackagebot visual-prof 0.2 - Create a visual profile of a program's source code  http://hackage.haskell.org/package/visual-prof-0.2 (DanielVelkov)
23:39:18 <dobblego> why do :type and :info give different results? http://paste.pocoo.org/show/443350/
23:40:27 <dobblego> (even though one is a type alias of the other)
23:41:14 <shachaf> dobblego: GHC magic.
23:41:24 <dobblego> makes total sense, thanks!
23:41:36 <shachaf> You can expect that sort of behavior from type synonyms. :-)
23:41:59 <dobblego> I might, but I wouldn't expect the disparity between :t and :i
23:42:22 <shachaf> I've had GHC infer different types for the same expression with/without parentheses.
23:42:28 <shachaf> Differently-named type variables, I mean.
23:42:37 <dobblego> you win
23:42:50 <shachaf> Type synonyms are evil anyway.
23:42:58 <shachaf> Maybe not in that particular case, though.
23:42:59 <dobblego> orly?
23:43:21 <dobblego> type State s a = StateT s Identity a -- is this one?
23:43:30 <shachaf> Maybe not that one either.
23:43:38 <shachaf> type FooId = String -- This one is, though.
23:43:41 <dobblego> I know the ones you mean
23:43:57 <shachaf> xmonad has an actual type error that wasn't caught because of that sort of type synonym.
23:44:10 <dobblego> you mean, it still has it?
23:44:16 <shachaf> Yes.
23:44:35 <dobblego> awesome
23:44:56 <shachaf> It doesn't come up very often, though. :-)
23:45:08 <dobblego> they're my favourite kind of type errors
23:45:40 <Chewie[]> so for anyone who was keeping track of my wood project... i have bisect implemented using sets/multisets. it is AMAZINGLY fast.
23:45:54 <Chewie[]> more updates to come unless i decide to sleep...
23:49:01 <_Ray_> question. if a Functor represents an endofunctor of Hask, what does a Monad's return represent? where are 'values', in the haskell language? (types are in Hask)
23:51:23 * hackagebot simple-firewire 0.1 - Simplified interface for firewire cameras  http://hackage.haskell.org/package/simple-firewire-0.1 (VilleTirronen)
23:52:06 <ziman> Values are in the objects of Hask. (But CT per se does not deal with the "elements of objects" in any way.)
23:52:28 <ziman> return is just an arrow within Hask.
23:53:09 <_Ray_> ziman, aren't the objects in Hask the types?
23:53:46 <_Ray_> (Meaning, Int and [Int] are objects in Hask, 4 and [4] aren't.)
23:54:05 <ziman> a natural transformation Identity -> m
23:54:37 <ziman> yes, they're kind of "elements of objects", not the objects themselves.
23:54:45 <_Ray_> oh ok
23:54:57 <ziman> Objects of Set are sets and those sets have elements, too.
23:55:08 <_Ray_> right
23:55:14 <sanjoyd> _Ray_: return is a natural transformation.
23:55:31 * _Ray_ just recently grasped that the determinant is a natural transformation, is still getting used to the idea
23:56:44 <aleator> My ongoing quest to fill hackage with half baked stuff has lead me to conquer firewire cameras. What would be a nice-and-haskelly interface for a webcam?
