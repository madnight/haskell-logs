00:58:13 <erus`> @hoogle a -> Ptr a
00:58:13 <lambdabot> Foreign.ForeignPtr unsafeForeignPtrToPtr :: ForeignPtr a -> Ptr a
00:58:14 <lambdabot> Prelude id :: a -> a
00:58:14 <lambdabot> Data.Function id :: a -> a
00:58:46 <erus`> glGenTextures :: GLsizei -> Ptr GLuint -> IO ()
00:58:52 <erus`> how do i use this?
00:59:10 <c_wraith> generally, Ptr is for a foreign data structure
00:59:11 <erus`> how can i get a pointer to my GLuint?
00:59:17 <c_wraith> so you use malloc or alloca
00:59:30 <c_wraith> @hoogle malloc
00:59:31 <lambdabot> Foreign.Marshal.Alloc malloc :: Storable a => IO (Ptr a)
00:59:31 <lambdabot> Foreign.Marshal.Array mallocArray :: Storable a => Int -> IO (Ptr a)
00:59:31 <lambdabot> Foreign.Marshal.Array mallocArray0 :: Storable a => Int -> IO (Ptr a)
00:59:40 <benmachine> @hoogle with
00:59:40 <erus`> c_wraith: no i dont have to malloc in C
00:59:40 <lambdabot> Foreign.Marshal.Utils with :: Storable a => a -> (Ptr a -> IO b) -> IO b
00:59:41 <lambdabot> System.Environment withArgs :: [String] -> IO a -> IO a
00:59:41 <lambdabot> Foreign.Marshal.Array withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
00:59:49 <c_wraith> erus`: who said anything about C?
00:59:58 <c_wraith> @hoogle alloca
00:59:59 <lambdabot> Foreign.Marshal.Alloc alloca :: Storable a => (Ptr a -> IO b) -> IO b
00:59:59 <lambdabot> Foreign.Marshal.Array allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
00:59:59 <lambdabot> Foreign.Marshal.Array allocaArray0 :: Storable a => Int -> (Ptr a -> IO b) -> IO b
01:00:34 <benmachine> if you have a GLuint already and you want a ptr to it, use Foreign.Marshal.with
01:00:49 <benmachine> or alternatively, alloca and poke
01:00:57 <c_wraith> It almost certainly wants an array of CLuint, though
01:01:08 <c_wraith> otherwise it wouldn't be using a Ptr
01:01:21 <c_wraith> err, GLuint
01:01:26 <benmachine> ("with" actually copies the thing and gives you a pointer to the copy, but still)
01:02:30 <erus`> c_wraith:
01:03:00 <erus`> in C its like:       GLuint a; glGenTextures(1, &a);
01:03:27 <c_wraith> ...  Why is it a pointer if it's not an array?  That makes no sense.
01:03:36 <c_wraith> Unless it modifies it in place?
01:03:47 <erus`> because it returns an error i think
01:04:01 <c_wraith> ah, the fun of C multiple return values.
01:04:11 <c_wraith> just use alloca
01:04:40 <c_wraith> assuming GLuint is an instance of Storable
01:08:58 <erus`> c_wraith: how do i use it?
01:09:51 <c_wraith> erus`: hmm.  I can't tell you anything the type signature doesn't right now.  I'm too tired.  In fact, I'm about to go to bed. :(
01:10:02 <juhp> Can binaries using TH be dynamically linked on Linux?
01:18:37 <mreh> awww, I can't derive nice type classes for my multi dimensional list type
01:19:45 <mreh> it's got the same structure as: NestedListType a = [[a]]
01:20:11 <ben__> hi folks can anyone give me a hand with loading modules into ghci? i'm having "no instance for xxx" problems
01:21:26 <mreh> ben__ what's the precise instance missing?
01:21:54 <mreh> type class instances are imported always (afaik)
01:22:20 <mreh> import Control.Monad () -- for e.g. imports instances only
01:25:42 <ben__> i'm adding a module to the protocol-buffers package. I :load it into ghci and :module + <another package>
01:27:01 <ben__> :show module shows that all of the Text.ProtocolBuffers modules are loaded interpreted and my other module has an "instance Default MyClass where ..."
01:27:37 <ben__> Default is in Text.ProtocolBuffers.Basic (but also exported by Text.ProtocolBuffers)
01:28:16 <benmachine> ben__: there may be a bug here, try doing :i on one of the types in question
01:28:21 <benmachine> or classes
01:28:25 <benmachine> or I forget what exactly
01:28:36 <ben__> however when I try to call defaultValue (which is Default a => a) i get the not instance error
01:28:51 <benmachine> try :i Default and then do it again
01:29:11 <ben__> :i tells me that my data class doesn't have an instance for Default
01:29:49 <ben__> however if i build and install both packages with cabal install and then do ghci :m + <..., ...> it works fine
01:30:34 <ben__> :i Default also doesn't mention and instance for MyClass
01:33:00 <_Ray_> Hi :) In a list comprehension, how could I take two consecutive items from a list? Specifically, given [a,b,c,d], I want to walk the list as (a, b), (b, c), (c, d).
01:33:38 <quicksilver> > let l = [1,2,3,4] in zip l (tail l)
01:33:40 <lambdabot>   [(1,2),(2,3),(3,4)]
01:34:32 <_Ray_> nice, I'll try to understand it. thanks!
01:35:15 <benmachine> @quote aztec
01:35:16 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
01:36:58 <_Ray_> oh right I get it
01:37:22 <erus`> what is the difference between agda and haskell?
01:37:33 <benmachine> agda has dependent types
01:37:53 <benmachine> and is a total language
01:38:06 <benmachine> so (I believe) isn't Turing-complete
01:38:16 <benmachine> (but can still do quite a lot)
01:40:01 <erus`> whats the difference between dependent types and haskell's (inferred?) types
01:40:41 <mreh> my type-fu is weak
01:41:01 <mreh> class (Pointed l, Monoid (l a) => FromList l where
01:41:16 <mreh> is that possible?
01:41:33 * hackagebot blakesum 0.4 - The BLAKE SHA-3 candidate hashes, in Haskell  http://hackage.haskell.org/package/blakesum-0.4 (KevinCantu)
01:42:35 <benmachine> mreh: possible? why wouldn't it be?
01:42:41 <quicksilver> mreh: it is, by why bother making it a class?
01:42:48 <quicksilver> mreh: there is only one sensible implementation.
01:42:59 <benmachine> erus`: dependent types depend on values, as the name suggests
01:43:09 <quicksilver> why not just write fromList :: Pointed l, Monoid (l a) => [a] -> l a
01:43:34 <mreh> quicksilver: touche
01:43:41 <benmachine> erus`: you can have e.g. type constructors that take values and produce types
01:44:01 <benmachine> erus`: so you can easily form a type of 'natural numbers less than n' in agda
01:44:16 <benmachine> where n may be an argument to your function
01:44:42 <_Ray_> can you have something like "matrices of primes"?
01:45:29 <benmachine> _Ray_: that's beyond my ability (not that it's hard to be so) but I suspect it's possible
01:45:41 <benmachine> I only dabbled in agda a bit, I never really got good at it
01:46:03 <_Ray_> I hope to play with it during this year, so far I have to admit what's stopping me is my ignorance of emacs :)
01:46:52 <benmachine> yeah, I was sad to have to give up vim :P
01:47:32 <burbul> When you have to do a number of non-monadic computations inside a do-block (e.g. computations that can't fail inside a do-block for some error-representing monad), what's the appropriate idiom to use? Do you just use 'return' liberally, or nest a let block inside the do block or ...?
01:48:28 <benmachine> burbul: sometimes it's nice to put the whole thing in a where
01:48:34 <benmachine> after the block entirely
01:48:52 <benmachine> sometimes that's less straightforward if the computations depend on earlier bindings (which won't be in scope)
01:49:03 <benmachine> in which case, let is fine, or you could make a function and pass them as parameters
01:49:15 <burbul> got it -- thanks
01:49:16 <juhp> has anyone built Euterpea?
01:49:59 <benmachine> burbul: you're aware that you can put lets in do-blocks without ins, right?
01:50:25 <benmachine> > do return (); let n = 5; Just n
01:50:26 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
01:50:35 <benmachine> umm
01:51:02 <benmachine> oh
01:51:05 <quicksilver> > do { return (); let {n=5}; Just n }
01:51:06 <lambdabot>   Just 5
01:51:11 <benmachine> right, yes
01:51:21 <quicksilver> benmachine: ambigously nested implicit {}, bad benmachine.
01:51:29 <benmachine> :<
01:51:51 <burbul> "lets in do-blocks without ins"  -- no, I didn't know; that's fantastic... thanks!
01:52:12 <burbul> does it scope over the rest of the do block?
01:52:15 <benmachine> yes
01:52:19 <burbul> Perfect
01:52:28 <benmachine> do let foo = bar; baz translates to let foo = bar in do baz
01:52:41 <burbul> Thank you!
01:52:46 <juhp> in's
01:52:56 <benmachine> @undo do { return (); let {n=5}; Just n }
01:52:57 <lambdabot> return () >> let { n = 5} in Just n
01:53:32 <benmachine> juhp: in do-block's?
01:54:06 <juhp> I meant I couldn't parse ins :)
01:54:14 <benmachine> mm
01:55:12 <juhp> the idioms of computer stretch English beyond its design a bit sometimes...
01:55:30 <juhp> programming ^
01:55:33 <benmachine> hence programming languages :P
01:55:37 <benmachine> yes
01:55:59 <juhp> (I think I intended computers)
01:56:15 <juhp> I had argument recently about "archs" vs "arches"
01:56:19 <juhp> for example
02:02:55 <hpaste> blueonyx pasted “exclueded dependency” at http://hpaste.org/49205
02:03:25 <blueonyx> ^ how should i put this dependency into my .cabal?
02:05:49 <gienah> blueonyx: I think that is an obscure way of saying that it wants ghc 7.0.4
02:06:17 <blueonyx> okay :/
02:06:30 <benmachine> I don't think it is
02:06:44 <benmachine> blueonyx: try cabal isntall -v3 and see if it provides anything more useful
02:10:27 <blueonyx> benmachine: just says that it found my ghc 6.12.1
02:14:50 <gienah> blueonyx benmachine: I never use cabal install, I install everything as system packages, so I'm not really sure (when installing as a system package it is not possible to bump base)
02:17:45 <benmachine> blueonyx: really? it doesn't say more stuff about dependency resolution?
02:19:22 <hpaste> blueonyx pasted “excluded dependency” at http://hpaste.org/49206
02:20:07 <benmachine> blueonyx: what does ghc-pkg list base say?
02:20:48 <benmachine> (by my reckoning you shouldn't have base 4.3 if you have ghc 6.12)
02:21:21 <benmachine> hmm, gienah might have been right actually
02:21:40 <blueonyx> oh it says 3.... and 4.2....
02:21:49 <benmachine> it's saying those versions of base are on hackage
02:21:51 <benmachine> but can't be installed
02:21:57 <benmachine> because base can't be upgraded
02:21:58 <benmachine> how silly
02:22:49 <blueonyx> oh yea. thank you :)
02:23:22 <benmachine> blueonyx: cabal sometimes isn't very good at error messages, I don't blame you for not working it out :P
02:23:44 <jeetu> i am also facing the same problem when installing grapefruit
02:24:42 <jeetu> it requires some  base >=3.0 && <4.1 and i have GHCi, version 7.0.3
02:25:18 <jeetu> May be thats why sometimes distribution package manager excells :(
02:26:02 <siracusa> jeetu: You can download the package and modify the cabal file by hand, at least the base dependency shouldn't be a problem
02:26:03 <gienah> jeetu: just try hacking the cabal file with sed to loosen the dependency, something like: sed -e 's@base                >= 3.0 && < 4.1@base                >= 3.0 \&\& < 4.1@' -i something.cabal
02:26:26 <gienah> oops, need to actually increment the number at the end to something like 4.4
02:26:47 <benmachine> :P
02:26:53 <benmachine> hack it with a text editor
02:26:55 <benmachine> it's much easier
02:27:11 <benmachine> (what if base isn't listed as the first dependency?)
02:27:28 <gienah> benmachine: it does not matter
02:27:55 <benmachine> gienah: I don't follow
02:28:16 <benmachine> gienah: I can't imagine a (reasonably concise) sed script that can catch all and only the cases you're interested in
02:28:59 <gienah> benmachine: right, different sed scripts for different packages, I do this all the time creating gentoo ebuilds
02:29:07 <benmachine> oh
02:29:19 <gienah> then of course you hope it compiles, if not, more patching is necessary
02:29:23 <benmachine> that's great if you need automation
02:29:40 <benmachine> but if you don't then don't use sed
02:30:43 <jeetu> :gienah: will try
02:43:06 <Younder> Has anyone doe a Haskell version of Calendrical calulations by Dershowitz and Reingold?
02:43:20 <Younder> done
02:43:54 <Younder> that is s/doe/done/
02:45:46 <roconnor> Was there a name for functors with pure but not ap?
02:46:28 <shachaf> roconnor: Pointed functors?
02:46:48 <roconnor> ah
03:04:16 <mreh> did someone point me towards dimensional list types not long ago
03:04:17 <Younder> what is ap? what is a pointed functor?
03:04:33 <mreh> :t ap
03:04:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
03:04:44 <mreh> it's <*> for Monads
03:04:54 <mreh> if you know Applicative already that would make sense
03:05:22 <mreh> :t pure
03:05:22 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
03:05:39 <mreh> if a functor implements pure, then it's also pointed
03:06:04 <Younder> ahh
03:06:14 <Younder> thanks mrd
03:06:27 <Younder> mreh
03:06:31 <mreh> there is no Pointed type class in haskell as it is yet, but you can make it/import it from another library
03:07:01 <shachaf> It won't be a superclass of Applicative, though. :-)
03:07:20 <mreh> how much Haskell will break if they corrected that
03:07:23 * shachaf wonders whether a bad hierarchy like Num or an absence of a hierarchy like Monad is preferable.
03:07:33 <mreh> about this much I reckon _____________________
03:07:47 <shachaf> That's a lot of Haskell.
03:09:03 <wvl_> Does anyone know if there already exists a graphical summary of the definitions and laws in the typeclassopedia?
03:09:26 <mreh> http://www.haskell.org/haskellwiki/Foldable_and_Traversable#Traversable
03:09:31 <mreh> there's a partial one there
03:09:35 <mreh> i just happened to be reading that
03:09:51 <mreh> hang on, there is a graph in the typeclassopedia
03:10:23 <wvl_> yup but then with all the defs and laws in the graph
03:10:33 <wvl_> since I'm constantly scrolling now
03:10:45 <mreh> commit it to memory
03:11:18 <frerich> What's a good way to express things like "This function must not be called with non-positive values" in Haskell? I'd like the compiler to bail out if it can determine that some function is called with an invalid value. Should I introduce a dedicated type?
03:11:33 <shachaf> Pretty much.
03:11:41 <shachaf> You could use Word but that's a hack. :-)
03:11:45 <frerich> I tried to do something like "div' a b | b > 0 = a `div` b", hoping that something like "a `div'` 0" would make ghc break - but it only fails at runtime, too.
03:11:49 <shachaf> (And doesn't capture what you want anyway.)
03:12:00 <shachaf> frerich: Well, how can GHC catch it at compile-time?
03:12:06 <quicksilver> > -1 :: Word
03:12:07 <lambdabot>   18446744073709551615
03:12:15 <frerich> shachaf: Because I passed a literal zero as b
03:12:15 <mreh> lol
03:12:38 <mreh> make a positive integer type wrapper
03:12:43 <shachaf> frerich: So? It can't detect it in general. do { x <- readLn; print (a `div'` x) }
03:12:48 <mreh> and hide the constructor
03:12:57 <frerich> shachaf: Of course that's not always possible, it might need to execute some monad. That's why I'm saying "if it can determine..."
03:13:20 <frerich> shachaf: I wonder whether I could at least handle the stuff which can be caught simply by evaluating expressions
03:13:36 <shachaf> frerich: Well, that's not really how types work. :-)
03:13:49 <shachaf> A function stands alone with its type.
03:13:52 <frerich> shachaf: Right, so I was wondering whether Haskell has something like 'annotations' or so.
03:14:11 <shachaf> Make a positive integer type.
03:14:28 <frerich> shachaf: Okay, how about I only want to allow values between 1 and 100?
03:14:28 <erus`> i got to about page 6 of an agda tutorial before i lost it
03:14:34 <shachaf> Make a type for it.
03:15:00 <quicksilver> essentially the answer to "how can I _X_ at compile time?" will always be "Make a type for it".
03:15:00 <mreh> that still causes a run time error though, so it's not really what you were looking for
03:15:14 <quicksilver> types are the only things which are considered at compile time.
03:15:20 <frerich> quicksilver: Okay.
03:15:28 <quicksilver> you can encode really quite complex stuff in types but it's quite unpleasant.
03:15:28 <mreh> the compiler will still accept "makePositiveInteger -1"
03:16:04 <shachaf> mreh: No, it'll require parentheses. :-)
03:16:14 <mreh> yeah yeah yeah!
03:16:24 <shachaf> But, yes, that's true. You could use type-level numbers if you really wanted it to be caught at compile time.
03:16:32 <frerich> quicksilver: I wondered whether there's a different way since I'd like to a) have the type signatures communicate the constraints (a good reason for types) and b) be able to quickly whip up new contraints (so that I can easily create one type for values [1..10] and another for [2..20]).
03:16:52 <frerich> Maybe templates could help here ,so that I can have an 'Interval' type template?
03:16:53 <quicksilver> frerich: well, any way you attempt will involve a type.
03:16:59 <quicksilver> that doesn't mean it's only one way.
03:17:01 <frerich> quicksilver: I see.
03:17:13 <quicksilver> there are as many different ways to program with types as there are to do anything else
03:17:18 <quicksilver> but the majority of them are unpleasant :)
03:17:43 <quicksilver> TH lets you do arbitrary computation at compile time, yes.
03:18:02 <quicksilver> so you could do $( makePositiveInteger (-1) ) and get an error at compile time.
03:18:15 <frerich> quicksilver: One thing I wondered is - I personally really like to make the type system really strong, so I tend to introduce dedicated types to make passing invalid values impossible. However, for primitives like numbers it's a bit annoying and I wondered whether it would maybe confuse clients of my library if they can't just use "Int" or so but always have my strange custom types everywhere.
03:18:44 <frerich> quicksilver: TH would be 'Template Haskell', I guess? I only heard about that, but sounds interesting, I'll have a look - thanks! :-)
03:26:44 <jeetu> I was reading throug repa and hmatrix, the matrix libraries. Does any one of them support sparse matrices?
03:31:55 <jeetu> or if someone can suggest any other library which supports sparse as well as dense matrices and basic matrix functions
03:32:39 <jeetu> I found hmatrix and repa as the best when it comes to basic functionality but both seems to lack the sparse matrix capability. Correct me if i am wrong.
03:33:35 <benmachine> jeetu: if I were modelling a sparse matrix I'd use Data.Map
03:33:38 <benmachine> or something similar
03:34:20 <siracusa> jeetu: sized-types supports sparse matrices
03:36:13 <jeetu> I have used boost ublas in c++. It supports sparse matrices as well as blas functionality. I was searching for something similar in haskell.
03:38:52 <jeetu> Or if any idea, that repa or hmatrix is going to support sparse matrix. As both contains good functionality and I can use hmatrix-repa for my code.
03:41:26 <jeetu> Otherwise I will choose sized-types or Data.Map
03:49:31 <klapaucius> afaik sized-types use Data.Map and its far too slow
03:49:52 <jeetu> Speed is crucial for me
03:50:49 <benmachine> maybe this http://hackage.haskell.org/package/unordered-containers
03:53:53 <klapaucius> then all you can, probably, do - implement CRS sparse-matrices all by yourself e.g. https://gist.github.com/906853
03:57:32 <jeetu> thats tough for me at the moment, as i have started learning haskell few weeks ago
03:57:58 <jeetu> May be in future I will.
04:01:24 <Samuel> learning haskell as we speak :)
04:01:32 <Samuel> pretty interesting stuff so far
04:04:29 <jeetu> Is there any website for unordered-containers which gives some tutorials etc
04:04:36 <jeetu> i am unable to find it :(
04:05:06 <benmachine> I think it's quite a new package, so perhaps not
04:05:20 <benmachine> what's difficult about it?
04:06:50 <jeetu> Not yet d/l so cant say anything. Just wanted to see how to use it before actually d/l-ing it.
04:07:29 <Twey> jeetu: http://hackage.haskell.org/packages/archive/unordered-containers/0.1.4.0/doc/html/Data-HashMap-Strict.html
04:07:40 <Twey> The API docs are pretty self-explanatory
04:10:41 <klapaucius> implementing sparse matrix on top of patricia tree or hashtable - its pure madness. CRS and Data.Vector.Unboxed you one and only hope.
04:11:46 <cheater_> klapaucius, why are you doing this?
04:11:52 <cheater_> what is the usage of such a structrue?
04:11:57 <cheater_> structure
04:12:27 <ari> unordered-containers's Hashmap Seems pretty similar to EnumMap aside the choice of typeclass and having only a subset of the interface, btw
04:15:34 <klapaucius> compressed row storage is a textbook implementation technique for sparse matrices
04:20:43 * hackagebot bindings-dc1394 0.1 - Library for using firewire (iidc-1394) cameras  http://hackage.haskell.org/package/bindings-dc1394-0.1 (VilleTirronen)
04:21:11 <aleator> Iteratee-newbie question: Would it make sense to model web cameras as enumerators? What good would that do if anything?
05:31:00 <Jester_Racer> loadImage fileName = SDL.load fileName >>= SDL.displayFormat
05:31:17 <Jester_Racer> Will this line cause memory leak?
05:31:56 <Jester_Racer> I should use SDL.freeSurface on the loaded image, right?
05:35:04 <hpaste> Jester_Racer pasted “loadImage” at http://hpaste.org/49214
05:36:04 <Jester_Racer> so I think my solution is the correct, pasted to hpaste, but I'm not sure. Anyone?
06:08:01 <Knarf> Hey
06:08:16 <Knarf> I'm comming from a PHP background
06:08:24 <Knarf> but recently got tired of PHP
06:08:35 <MasseR> Welcome
06:08:48 <Knarf> Are there anyone here that could tell me why I should choose Haskell?
06:08:53 <MasseR> I'm kinda the opposite. Going to php from haskell background. It's more painful this way
06:09:32 <MasseR> Knarf: Depends. Are you expecting to get a job from any run of the mill it-company
06:09:45 <MasseR> or do you want to increase your skills and abilities
06:09:54 <Knarf> skills and abilities
06:10:10 <MasseR> Haskell is different enough to broaden your ways
06:10:29 <MasseR> Actually, there was just a similar question on stackoverflow
06:10:31 <MasseR> Two seconds
06:11:47 <MasseR> http://stackoverflow.com/questions/775726/whats-the-fuss-about-haskell
06:11:59 <roconnor> @type (>=>)
06:12:00 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
06:12:51 <Jester_Racer> anyone good in sdl here?
06:13:29 <aninhumer> I think Haskell especially has a *lot* of new ways to think about programming
06:14:12 <aninhumer> You obviously have functional style, but then there are Monads, Arrows etc.
06:14:24 <djahandarie> Those are functional style.
06:14:39 <Knarf> How about OOP in Haskell?
06:14:56 <djahandarie> You can do OOPish things in Haskell but normally you don't.
06:15:05 <Knarf> Oh
06:15:06 <roconnor> > ((\x -> [x,x]) `mappend` (\x -> [x])) 7
06:15:07 <lambdabot>   [7,7,7]
06:15:15 <aninhumer> djahandarie: Yes, but you won't necessarily learn them from lisp say
06:15:34 <djahandarie> aninhumer, correct. That doesn't mean they aren't functional though.
06:15:51 <roconnor> interesting
06:16:01 <djahandarie> "Functional" is pretty vague anyways though.
06:16:05 <aninhumer> I didn't mean to imply that
06:16:09 <djahandarie> "Denotational" is slightly more specific.
06:16:20 <Knarf> So Haskell is more like Perls "one line to rule them all"?
06:17:15 <djahandarie> Most people don't golf things into one-line expressions.
06:18:22 <frode> Does anyone have some examples for sending emails with Haskell?
06:19:03 <MasseR> frode: The uhm.. mime-mail package has examples
06:19:08 <MasseR> @hackage mime-mail
06:19:09 <lambdabot> http://hackage.haskell.org/package/mime-mail
06:19:36 <djahandarie> frode, in the sense of writing an email library or using one?
06:19:43 <djahandarie> And yeah, that's the package you want if you want a library.
06:20:09 <frode> Oh, thanks. Yeah, just using one. I was too set on HaskellNet, I guess.
06:20:27 <roconnor> @type (.)
06:20:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:20:33 <roconnor> @type (<=<)
06:20:35 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
06:20:36 <MasseR> frode: One caveat with mime-mail, the examples use sendmail executable; if you don't have it, it doesn't work
06:20:41 <roconnor> @type (`mappend`)
06:20:42 <lambdabot> parse error on input `)'
06:20:46 <roconnor> @type (mappend)
06:20:47 <lambdabot> forall a. (Monoid a) => a -> a -> a
06:20:53 <MasseR> IIRC haskellnet uses mime-mail internally, and there was some examples on mailing list a while ago
06:21:06 <MasseR> (IIRC; I have a horrible memory, don't count on it)
06:22:07 <frode> Okay, many thanks, I'll look into mime-mail first then. Sendmail is fine.
06:22:19 <frerich> Does a curried function qualify as a closure?
06:23:15 <MasseR> frerich: As far as I see it, a curried function per se does not qualify as a closure
06:23:29 <MasseR> mapM_ print ["foo", "bar"]
06:23:39 * roconnor wishes the types (Const o a) and (Const o b) unified.
06:23:54 <MasseR> However there the print is curried and closes over the list items
06:24:40 <EvanR> about the jargon mappend making more sense because append isnt commutative... some monoids are commutative so might confuse people ;)
06:26:03 <roconnor> Is there a kleisli endo monoid?
06:30:02 <copumpkin> not that I know of
06:30:11 <copumpkin> write one!
06:31:02 <EvanR> Monoid (Endo a)
06:31:06 <roconnor> I will call it: Klendo!
06:31:26 <EvanR> does that not cover all endomorphisms
06:31:30 <roconnor> mmmm, klendomorphisms
06:32:11 <roconnor> EvanR: newtype Klendo m a = Klendo {unKlendo :: a -> m a}
06:32:19 <EvanR> interesting
06:32:56 <roconnor> though maybe there is an arrow endomorphism already that in theory I could reuse.
06:33:21 <copumpkin> instance Monad m => Monoid (Klendo m) where mempty = Klendo return; mappend (Klendo f) (Klendo g) = Klendo (f >>> g)
06:33:34 <roconnor> f <=< g
06:33:41 <copumpkin> yeah, sorry
06:33:48 <copumpkin> but >=> would work to
06:33:49 <copumpkin> too
06:33:52 <roconnor> Which way is endo?
06:33:57 <copumpkin> beats me :P
06:34:02 <roconnor> function composition or categorical composition?
06:34:12 <roconnor> granted function composition is backwards
06:34:13 <Samuel> a bit confused about ("++ HAHA") "HEY" gives "HEY HAHA" but ("HAHA ++") "HEY" gives "HEY HAHA" I understand the first part but not the second
06:34:14 <benmachine> instance Monad m => Monoid (Kleisli m a a)?
06:34:16 <roconnor> still, it is more common.
06:34:34 <benmachine> since when is function composition backwards
06:34:43 <copumpkin>         Endo f `mappend` Endo g = Endo (f . g)
06:34:48 <roconnor> boo
06:34:49 <copumpkin> WE HAVE OUR ANSWER
06:35:12 <benmachine> Samuel: just take away the brackets :P
06:35:12 <EvanR> > ("++ HAHA") "HEY"
06:35:14 <lambdabot>   Couldn't match expected type `t1 -> t'
06:35:14 <lambdabot>         against inferred type `[GHC....
06:35:20 <benmachine> *parentheses
06:35:27 <benmachine> (also, you have your quotation marks in the wrong place)
06:35:45 <EvanR> > ("HAHA" ++) "HEY"
06:35:47 <lambdabot>   "HAHAHEY"
06:36:11 <EvanR> not hey haha
06:36:41 <EvanR> and for the love of god and all that is holy use foo and bar rather than 'lol' 'whatever' 'hey' ;)
06:36:44 <Samuel> yes you are right sorry, but how did get the result
06:37:28 <EvanR> (x ++) y == x ++ y
06:38:10 <Samuel> x ++ is a function that take a y and return x++y
06:38:27 <Samuel> how about (++ x) then?
06:38:51 <Samuel> (++ x) is a function that takes a y and returns ++x y??
06:38:52 <EvanR> \y -> y ++ x
06:39:18 <Samuel> what is \y?
06:39:21 <Samuel> partial function?
06:39:26 <MasseR> Samuel: It's just an infix function (++). If written like (++ x) it means that the left side of the function is empty, and therefore (++ x) y turns into y ++ x
06:39:30 <EvanR> \ is lambda, sounds like you need to read a guide first
06:40:04 <Samuel> I am reading but I was lost when I got to higer order function
06:40:10 <MasseR> Samuel: \ is an anonymous function. \y -> foo y; foo is a function takes (at least) one argument
06:40:27 <EvanR> all functions take exactly one argument
06:40:47 <Samuel> a->a->a is really a->(a->a)
06:41:13 <Samuel> is there a way to know the intermediary function?
06:41:14 <MasseR> EvanR: I wanted to say that in that case you can't say whether foo is foo :: a -> b or a -> b -> c, or ..
06:41:49 <EvanR> MasseR: if its 'really' a->b->c then a->d still works
06:41:57 <EvanR> d can be anything even a function
06:42:10 <MasseR> EvanR: True. Didn't think that far
06:42:55 <frerich> Samuel: Sure, you can pass one argument to a function a -> a -> a and you get back a function a -> a which you can even associate with a name. Like 'addTwo = (2+)' makes 'addTwo' a function which takes one argument and returns the same plus two.
06:43:07 <EvanR> @src succ
06:43:08 <lambdabot> Source not found. Wrong!  You cheating scum!
06:43:17 <EvanR> succ = (+1) ;)
06:43:36 <MasseR> Does lambdabot find any sources nowadays?
06:43:52 <Samuel> thanks frerich
06:43:53 <EvanR> > succ 0
06:43:55 <lambdabot>   1
06:43:58 <EvanR> > pred 0
06:43:59 <lambdabot>   -1
06:44:01 <EvanR> o_O
06:44:02 <benmachine> > succ 'o'
06:44:03 <lambdabot>   'p'
06:44:11 <benmachine> er, is that surprising
06:44:16 <MasseR> > (succ . pred) 0
06:44:17 <lambdabot>   0
06:44:24 <djahandarie> Why is it surprising?
06:44:27 <quicksilver> MasseR: it finds the same number of @src it always did, pretty much.
06:44:29 <EvanR> > succ . pred == id
06:44:30 <lambdabot>   Ambiguous type variable `a' in the constraint:
06:44:31 <lambdabot>    `GHC.Enum.Enum a'
06:44:31 <lambdabot>      ar...
06:44:44 <zygoloid> > succ . pred $ True
06:44:46 <lambdabot>   True
06:44:46 <quicksilver> succ is a method, though.
06:44:49 <benmachine> > succ . pred == (id :: Integer -> Integer)
06:44:49 <zygoloid> > succ . pred $ False
06:44:52 <benmachine> er
06:44:52 <lambdabot>   *Exception: (==): No overloading for function
06:44:52 <lambdabot>   *Exception: Prelude.Enum.Bool.pred: bad argument
06:44:57 <benmachine> @check succ . pred == (id :: Integer -> Integer)
06:44:58 <lambdabot>   No instance for (GHC.Classes.Eq
06:44:59 <lambdabot>                     (GHC.Integer.Type.Integ...
06:45:01 <benmachine> :<
06:45:01 <MasseR> quicksilver: Which is? I have never succeeded in finding sources with it
06:45:18 <quicksilver> MasseR: a few selected functions from the Prelude.
06:45:20 <benmachine> @check liftA2 (==) (succ . pred) (id :: Integer -> Integer)
06:45:22 <lambdabot>   "OK, passed 500 tests."
06:45:26 <quicksilver> @src mapM
06:45:26 * frerich thinks it's amazing what happens if you take a group of experts and throw a little something into the middle.
06:45:26 <Kaidelong> @src Integer.succ
06:45:26 <lambdabot> mapM f as = sequence (map f as)
06:45:27 <lambdabot> Source not found. I am sorry.
06:45:27 <EvanR> @src (!!)
06:45:28 <lambdabot> xs     !! n | n < 0 = undefined
06:45:28 <lambdabot> []     !! _         = undefined
06:45:29 <lambdabot> (x:_)  !! 0         = x
06:45:29 <lambdabot> (_:xs) !! n         = xs !! (n-1)
06:45:55 <Kaidelong> how do you get lambdabot to give you sources for methods again?
06:45:58 <quicksilver> MasseR: is is, essentially, a feature that does more harm than good and should be removed.
06:46:10 <quicksilver> Kaidelong: it's not particularly consistent and that one isn't in there I don't think.
06:46:19 <MasseR> quicksilver: how come?
06:46:28 <benmachine> @src [] (==)
06:46:29 <lambdabot> []     == []     = True
06:46:29 <lambdabot> (x:xs) == (y:ys) = x == y && xs == ys
06:46:29 <lambdabot> _      == _        = False
06:46:34 <Kaidelong> hmm I thought Integer was Enum, just not Bounded
06:46:37 <quicksilver> MasseR: because it's partial, and wrong, and contains no pointers to further information.
06:46:43 <benmachine> Kaidelong: it is
06:46:51 <MasseR> quicksilver: Thanks
06:46:55 <quicksilver> Kaidelong: Integer is indeed Enum, I just don't think the source is in @src.
06:46:59 <Kaidelong> @ty succ
06:47:01 <lambdabot> forall a. (Enum a) => a -> a
06:47:03 <Kaidelong> hmm
06:47:11 <Kaidelong> oh!
06:47:20 <quicksilver> MasseR: a command which linked to the online sources would be much more useful
06:47:22 <benmachine> Kaidelong: what were you expecting, case n of 1 -> 2; 2 -> 3; 3 -> 4; ... :P
06:47:36 <Kaidelong> benmachine: (1+)
06:47:54 <stobix> hm. Am I unable to use mathematical unicode operators as data constructors?
06:47:56 <benmachine> true.
06:47:57 <MasseR> quicksilver: Agreed
06:47:58 <EvanR> benmachine: good idea we need 'and so on' support
06:48:02 <benmachine> :D
06:48:08 <quicksilver> http://www.haskell.org/ghc/docs/7.0.1/html/libraries/base/src/GHC-Enum.html#Enum for example.
06:48:18 <benmachine> stobix: operators that are constructors need to start with a colon
06:48:30 <stobix> benmachine: ah. Thanks.
06:48:38 <benmachine> stobix: it's a bit like how identifier constructors have to start with a capital letter
06:48:52 <benmachine> you can use unicode after that
06:49:05 <EvanR> :snowman
06:49:19 <EvanR> Head -> Body -> Snowman
06:49:20 * stobix defines the somewhat strange constructor :⨁
06:49:53 <frerich> I thought my font has most of unicode, but apparently your constructor is even stranger than that.
06:50:06 <EvanR> it shows up in unifont in xterm
06:50:12 <EvanR> its circle with a cross through it
06:50:37 <benmachine> my font doesn't have it either
06:50:51 <benmachine> but my font is missing quite a lot iirc
06:51:04 <stobix> code2000 is a nice font to install
06:51:10 <stobix> maybe code2001 as well
06:51:13 <EvanR> barf
06:52:46 <identity_> :succ ()
06:52:51 <identity_> eh
06:52:53 <identity_> > succ ()
06:52:54 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
06:53:30 <EvanR> () not instance of Enum
06:53:36 <benmachine> it is
06:53:37 <quicksilver> EvanR: yes it is.
06:53:39 <EvanR> oh
06:53:40 <benmachine> > fromEnum ()
06:53:41 <identity_> it is, I just saw it
06:53:42 <lambdabot>   0
06:53:45 <quicksilver> otherwise the error message would say so ;)
06:53:45 <benmachine> > toEnum 0
06:53:46 <lambdabot>   ()
06:53:49 <identity_> which is why I tested it
06:53:50 <EvanR> > pred ()
06:53:52 <lambdabot>   *Exception: Prelude.Enum.().pred: bad argument
06:53:57 <quicksilver> "Exception: Prelude.Enum.().succ" is an interesting error format
06:54:00 <identity_> :t toEnum
06:54:01 <lambdabot> forall a. (Enum a) => Int -> a
06:54:02 <benmachine> it's not a very *useful*
06:54:09 <benmachine> > [() ..]
06:54:10 <lambdabot>   [()]
06:54:10 <EvanR> i get the same error in ghci
06:54:21 <quicksilver> > [minBound .. maxBound] :: [()]
06:54:23 <lambdabot>   [()]
06:54:25 <benmachine> > [()..()]
06:54:26 <quicksilver> benmachine: very useful :)
06:54:26 <lambdabot>   [()]
06:54:32 <benmachine> :P
06:54:33 <frerich> Why is it an instance of Enum?
06:54:37 <quicksilver> because it is.
06:54:40 <benmachine> frerich: because it can be enumerated
06:54:41 <identity_> > succ UppercaseLetter
06:54:42 <lambdabot>   LowercaseLetter
06:54:46 <quicksilver> it's an obvious example of a finite enumerable type :)
06:54:59 <quicksilver> it's just as good an instance as Bool
06:55:00 <EvanR> should it be its own succ?
06:55:05 <quicksilver> no.
06:55:09 <quicksilver> it is correctly implemented.
06:55:16 <identity_> :succ SeekFromEnd
06:55:23 <identity_> ff
06:55:23 <EvanR> ok Bool acts the same way
06:55:25 <frerich> Yes, but - is there a practical use of it? Like, a function requiring some instance of Enum which makes sense when called with () ?
06:55:26 <identity_> brainfart
06:55:30 <identity_> > succ SeekFromEnd
06:55:31 <lambdabot>   Not in scope: data constructor `SeekFromEnd'
06:55:38 <EvanR> > [()..()]
06:55:40 <lambdabot>   [()]
06:55:47 <EvanR> > [()..]
06:55:48 <lambdabot>   [()]
06:55:50 <identity_> > succ NotAssigned
06:55:51 <lambdabot>   *Exception: succ{GeneralCategory}: tried to take `succ' of last tag in enum...
06:55:56 <identity_> ah.
06:56:00 <benmachine> frerich: I sort of view Enum as "bijection with Int" ish
06:56:19 <benmachine> er subset of Int
06:56:25 <benmachine> so you can eg. generate random values of an Enum/Bounded type
06:56:56 <frerich> benmachine: Yes, I actually have a (fairly magical) piece of code from you which gets a random value for any instance of Enum. However, for (), I see little use.
06:57:08 <benmachine> frerich: I remember that bit of code, I helped write it :P
06:57:17 <benmachine> I think I realised an easier way to do it later
06:57:40 <frerich> I wonder whether there's a useful function which works on Enum types, and which does have a use when invoked with ().
06:57:48 <frerich> ...that would be a good reason for () being an instance of Enum.
06:58:13 <EvanR> i think () could be useful as an enum. situations always come up when you need 'zero like' things and you wish they existed. like id, zero itself, identity monad
06:58:52 <frerich> EvanR: Yes, I also have a feeling that this is useful in a similiar sense as 'id'.
06:58:52 <roconnor> > [()..()
06:58:54 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
06:58:55 <roconnor> > [()..()]
06:58:56 <lambdabot>   [()]
06:59:30 <geheimdienst> > 1..1
06:59:32 <lambdabot>   <no location info>: parse error on input `..'
06:59:38 <geheimdienst> > [1..1]
06:59:39 <lambdabot>   [1]
06:59:40 <EvanR> fromEnum . head $ [()..()]
06:59:43 <EvanR> > fromEnum . head $ [()..()]
06:59:45 <lambdabot>   0
06:59:52 <geheimdienst> > fromEnum ()
06:59:53 <lambdabot>   0
06:59:59 * zygoloid . o O ( instance Enum Void where {} )
07:00:12 <EvanR> lol
07:00:18 <benmachine> zygoloid: :P
07:00:37 <benmachine> there are quite a lot of instances for Void you can define like that actually
07:00:48 <benmachine> the laws tend to assume your type has any values in it for some reason :O
07:01:02 <EvanR> wheres Void defined
07:01:08 <benmachine> nowhere standard
07:01:13 <benmachine> somewhere on hackage that I forget
07:01:25 <benmachine> the definition is data Void; or if you're h98 newtype Void = Void Void
07:01:43 <Kaidelong> that newtype looks mighty dangerous
07:02:00 <shachaf> Not really. It's more or less equivalent.
07:02:03 <Kaidelong> oh yes
07:02:05 <EvanR> Void has one inhabitant
07:02:05 <Kaidelong> you are right
07:02:06 <shachaf> Though the derived Show instance is better. :-)
07:02:10 <EvanR> _|_
07:02:30 <Kaidelong> I was thinking it might stop the compiler from halting
07:02:32 <Kaidelong> but
07:02:40 <Kaidelong> you'd need an instance of Void other than bottom
07:02:45 <Kaidelong> of which there are none
07:03:19 <benmachine> it's interesting to think about where the value of newtype Void = Void Void "comes from"
07:03:29 <benmachine> newtypes are not supposed to have their "own" bottom value
07:03:46 <benmachine> or I think so anyway
07:03:49 <EvanR> arent all bottoms equivalent
07:03:50 <benmachine> I don't know how it works :P
07:03:52 <aninhumer> x = Void x :: Void?
07:04:04 <benmachine> aninhumer: yeah, basically
07:04:16 <zygoloid> EvanR: all bottoms of the same type are indistinguishable in pure code
07:04:24 <benmachine> EvanR: yes, but e.g. _|_ /= Just _|_
07:05:23 <Kaidelong> _|_ is a valid value for any newtype
07:05:38 <Kaidelong> even if it doesn't introduce a partial version of it
07:05:39 <EvanR> how is Just related to Void
07:05:52 <benmachine> EvanR: I just mean that
07:05:53 <benmachine> well
07:06:01 <benmachine> data Void = Void Void -- has lots of values
07:06:19 <Kaidelong> _|_ inhabits Void but Void _|_ is just _|_ and isn't a separate concept
07:06:44 <Kaidelong> you can't tell Void _|_ apart from _|_
07:06:53 <EvanR> Void (Void (Void (Void ...
07:07:00 <zygoloid> the Void newtype has only one value (which is denotationally _|_). it just so happens that that value has a name and can be pattern-matched :)
07:07:02 <Kaidelong> you can tell Just _|_ apart from _|_
07:07:22 <benmachine> zygoloid: can be pattern-matched?
07:07:56 <Kaidelong> Void _ I guess
07:07:56 <zygoloid> benmachine: "case undefined of Void a -> ()" :)
07:08:45 <benmachine> zygoloid: well sure, but it doesn't actually *do* anything as compared with, say, case undefined of _ -> () or case undefined of Void (Void _) -> ()
07:08:51 <Kaidelong> would that work with EmptyDataDecls?
07:09:09 <benmachine> Kaidelong: newtype Void = Void Void doesn't need EmptyDataDecls
07:09:13 <benmachine> data Void
07:09:13 <benmachine> does
07:09:19 <Kaidelong> yeah but
07:09:28 <joe6> this is the data: http://pastebin.com/XxK2b4YL , this works: http://pastebin.com/v4wF1KHP http://pastebin.com/QzGAVqHd , this does not: http://pastebin.com/Uiu4dxRz http://pastebin.com/UP5F3HAK and the only difference is the array here: http://pastebin.com/q1kENJic
07:09:30 <Kaidelong> I mean, could you pattern match on the latter with any pattern other than a wildcard
07:09:33 <joe6> any thoughts, please?
07:09:39 <mauke> The pastes XxK2b4YL v4wF1KHP QzGAVqHd Uiu4dxRz UP5F3HAK q1kENJic have been copied to http://hpaste.org/49217 http://hpaste.org/49218 http://hpaste.org/49219 http://hpaste.org/49220 http://hpaste.org/49221 http://hpaste.org/49222
07:09:56 <benmachine> Kaidelong: oh, no, it has no constructors
07:10:05 <benmachine> it would probably be clearer to define
07:10:29 <benmachine> newtype Abyss = Stare Abyss
07:10:55 <benmachine> and then you can do case undefined of Stare (Stare (Stare _)) -> ()
07:11:04 <benmachine> but in the case of data Void there's no Stare
07:11:18 <quicksilver> newtype TheWayDown = TurtlesAll TheWayDown
07:11:46 <EvanR> infinity is boring ;)
07:12:06 * benmachine hugs quicksilver 
07:12:09 <Twey> Hehe
07:12:15 <joe6> better representation of the data: http://pastebin.com/YJ4UtRHc
07:12:37 <EvanR> please stop using pastebin
07:12:50 <EvanR> i do not want to type in a captcha to see your paste
07:13:01 <Twey> What's the GADT syntax for Void?
07:13:08 <Twey> ‘data Void where’?
07:13:17 <joe6> EvanR, I would love to. Do you still see the captcha?
07:13:24 <joe6> i just entered it.
07:13:24 <EvanR> yes
07:13:28 <joe6> oh, ok.
07:13:32 <EvanR> use Aeson
07:13:34 <Twey> @where hpaste
07:13:34 <lambdabot> http://hpaste.org/
07:13:38 <parcs> Void :: Void -> Void ?
07:14:02 <Kaidelong> my thoughts on it is that that JSON library seems really cool
07:14:09 <EvanR> the JSValue equivalent in Aeson sucks less
07:14:20 <joe6> i would love to use hpaste, but I have a macro defined  ((mod1Mask, xK_p), spawn " TMPFILE=`mktemp` && xclip -o >> $TMPFILE && pastebinit $TMPFILE | tr -d \"\n\" | xclip ")
07:14:26 <EvanR> and it has better verification tools
07:14:29 <joe6> and I could not do that with hpaste.
07:14:53 <joe6> EvanR, ok. will checkout Aeson.
07:15:10 <joe6> EvanR, or, go back to Aeson.
07:15:11 <Twey> What's the deal with Aeson's DotNetTime?
07:15:39 <EvanR> no idea, ignore it
07:16:10 <joe6> Evanr, I am so close with hpaste.
07:16:12 <Twey> joe6: http://code.google.com/p/pastepipe/
07:17:11 <joe6> pastepipe was broken. Is it working now?
07:17:19 <joe6> will check it out.
07:18:33 <EvanR> also i figured out how to use that function i gave you yesterday with Aeson
07:18:35 <Twey> Maybe
07:18:40 <Twey> You could also just use curl
07:19:10 <EvanR> parse :: (a -> Parser b) -> a -> Result b
07:19:49 <joe6> EvanR, ok.
07:20:21 <aninhumer> What's the argument against pastebin?
07:20:31 <EvanR> its hell on earth
07:20:34 <quicksilver> it makes EvanR type a captche to see pastes.
07:20:35 <joe6> Twey, pastebin was the lowest hanging fruit and it worked without any hassle..
07:20:41 <quicksilver> I don't know why it victimises EvanR
07:20:45 <quicksilver> it works for everyone else.
07:20:45 <Twey> But it's horrible
07:20:58 <EvanR> it says the paste trigger a spam filter
07:20:59 <Twey> Slow, ad-ridden, requires JS (!)
07:21:08 <EvanR> i use codepad haskell
07:21:14 <EvanR> theres also hpaste
07:21:20 <Twey> I have not encountered a CAPTCHA but the fact that someone else does is another mark against it
07:21:44 <EvanR> Twey: twice, last night at home, and today at work, because of joe6's paste
07:23:36 <joe6> or, maybe, it is the data that I am pasting.
07:23:57 <Kaidelong> what was the handle of the guy who develops Manatee?
07:24:08 <geheimdienst> Kaidelong: manateelazycat?
07:24:13 <benmachine> that sounds familiar
07:24:15 <Kaidelong> yes that was it, thank you
07:24:24 <joe6> btw, how do I get a JSRational to Haskell?
07:24:24 <Kaidelong> does anyone here use Manatee other than him?
07:24:37 <EvanR> joe6: pattern matching
07:24:39 <joe6> using JSON?
07:24:43 <EvanR> then use Aeson
07:24:48 <joe6> EvanR, haha..
07:24:54 <quicksilver> Kaidelong: yes, but they're all called ManateeUser so we can't tell them apart :)
07:25:42 <EvanR> manatee is pretty awesome
07:30:27 <Kaidelong> so the difference between unamb and lub is that if you have f(x) = (undefined,y), g(x) = (z,undefined), f(x) `lub` g(x) is always going to be (z,y) as opposed to being a race condition?
07:30:43 <Kaidelong> I'm wondering how you would get that to work
07:31:06 <EvanR> joe6: class FromJSON is what you want to use to get JSON functionality from Text.JSON. parseJSON is the method and is almost identical to the code i pasted last night to 'parseRunner'
07:31:30 <EvanR> that will let you decode lists or objects of runners, even if deeply nested
07:34:07 <EvanR> what is another name for <$> ?
07:34:16 <sipa> @pl <$>
07:34:16 <lambdabot> (line 1, column 1):
07:34:17 <lambdabot> unexpected "<"
07:34:17 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
07:34:22 <sipa> bad lambdabot
07:34:25 <sipa> @pl (<$>)
07:34:26 <lambdabot> (<$>)
07:34:28 <sipa> meh
07:34:31 <Kaidelong> EvanR: fmap?
07:34:40 <EvanR> yep, thanks
07:34:44 <EvanR> i get all this confused
07:36:49 <EvanR> joe6: parseJSON (Object v) = Runner <$> v .: "id" <*> v .: "name" <*> v .: "market"
07:37:08 <EvanR> i guess pattern matching failure is handled automatically but ...
07:37:12 <EvanR> seems like magic
07:39:00 <EvanR> ah no
07:39:05 <EvanR> parseJSON _ = mzero
07:44:00 <joe6> what am I doing wrong with this json stuff: http://pastebin.com/zrxw1ZtU
07:44:01 <mauke> The paste zrxw1ZtU has been copied to http://hpaste.org/49223
07:44:27 <EvanR> joe6: wheres the error
07:44:30 <EvanR> oh
07:44:47 <joe6> http://pastebin.com/Q7k9wma2
07:44:49 <mauke> The paste Q7k9wma2 has been copied to http://hpaste.org/49224
07:45:53 <joe6> EvanR, I know you want me to use Aeson, but I am just wrapping my head around json and json seems simpler than aeson.
07:46:01 <EvanR> its not
07:46:48 <EvanR> i still dont know what your goal is
07:47:02 <EvanR> youve decoded the data at least twice and you still say you 'cant read it'
07:47:20 <EvanR> can you name a function signature youre trying to realize?
07:47:34 <joe6> i am trying to read RunnerPrices
07:47:43 <EvanR> thats too operational
07:48:01 <joe6> getting through this error: http://pastebin.com/wf8hfcn5
07:48:02 <mauke> The paste wf8hfcn5 has been copied to http://hpaste.org/49225
07:48:05 <EvanR> sigh
07:48:23 <joe6> EvanR, to read this json data: http://pastebin.com/0FqAL7Jn
07:48:24 <mauke> The paste 0FqAL7Jn has been copied to http://hpaste.org/49226
07:48:36 <joe6> nothing fancy. i just want to read that data into haskell.
07:48:46 <EvanR> its already in haskell
07:48:58 <joe6> but, not in my data structure.
07:48:58 <EvanR> at what point will you be satisfied
07:49:28 <EvanR> you want String -> [Int] ?
07:49:31 <joe6> i want to put the data into the structure RunnerPrices: http://pastebin.com/tDhX0tRa
07:49:33 <mauke> The paste tDhX0tRa has been copied to http://hpaste.org/49227
07:49:34 <EvanR> String -> [Runner] ?
07:49:52 <joe6> EvanR, yes, actually. String -> RunnerPrices
07:49:59 <EvanR> RunnerPrices seems wrong, maybe you want a list of numbers? or a map from runner id to numbers?
07:50:31 <EvanR> String -> Map RunnerId Int
07:51:12 <joe6> no. that is not it.
07:51:48 <joe6> EvanR, can you please look at line 40 of http://hpaste.org/49227
07:52:25 <EvanR> so basically
07:53:16 <EvanR> your data is very deeply nested
07:53:45 <EvanR> and theres a lot of unnecssary levels
07:53:56 <EvanR> like data MarketId = MarketId { marketId :: Integer }
07:54:05 <EvanR> just do type MarketId = Integer
07:54:22 <joe6> EvanR, I just used that as Json requires it to parse it.
07:54:28 <shachaf> EvanR: :-(
07:54:40 <EvanR> i doubt it does
07:54:47 <shachaf> EvanR: More types are good. Type synonyms are evil, just convenient.
07:54:57 <joe6> It needs the string "marketId"
07:55:05 <shachaf> Recently I found a type error in xmonad that was caused by type WorkspaceId = String instead of a newtype.
07:55:24 <joe6> and the string "marketId" is used in more than one record structure.
07:55:25 <EvanR> fine, but it doesnt need to be fully formalized like that
07:55:35 <EvanR> data MarketId = MarketId Integer
07:55:48 <jlaire> newtype MarketId = MarketId Integer
07:55:52 <joe6> EvanR, yes, but json.generic needs that.
07:55:58 <EvanR> jlaire: thats what i meant
07:56:00 <shachaf> Well, sure, unless you want an accessor.
07:56:09 <joe6> to match up the string with json data
07:56:27 <EvanR> joe6: the field name doesnt need to match the json data
07:56:35 <EvanR> json data is going to be more verbose than necessary
07:56:38 <joe6> oh, really. it dos not.
07:56:39 <EvanR> if you want to keep it in json form
07:56:42 <EvanR> just keep it in json form
07:56:44 <EvanR> JSValue
07:56:54 <EvanR> no point to converting to something with the names in a different place
07:57:42 <EvanR> if you want to verify the data, then you need to write about 1000 case expressions, or use Aeson
07:57:42 <hpaste> ari pasted “to json and back for joe6” at http://hpaste.org/49228
07:57:47 <joe6> EvanR, come on, man. I am stuck with something simpler.
07:58:19 <joe6> ari, that is what I want.
07:58:23 <joe6> ari, thanks a lot.
07:58:59 <ari> joe6: The json library isn't quite making the structure you expect, it turns tuples into sequences
07:59:38 <EvanR> i never got around to commenting on that
07:59:47 <joe6> ari, haha..
07:59:52 <EvanR> the RunnerPrices has a single field with a 4tuple
07:59:55 <joe6> ari, something like that is messing things up..
07:59:59 <EvanR> it should just be four fields
08:00:26 <EvanR> a common antipattern when people encode stuff into json
08:01:15 <joe6> ok, thanks.
08:01:34 <EvanR> or php arrays
08:01:53 <Jester_Racer> Is there a command line option in cabal to specify where to look for libraries in the system?
08:02:20 <mauke> Jester_Racer: no, ghc knows where all libraries are
08:03:15 <Jester_Racer> mauke: I want to install SDL-ttf, but I can't because cabal don't find the SDL_ttf library, but it's installed on my system
08:03:30 <EvanR> try ldconfig
08:03:32 <mauke> oh, you mean C libraries?
08:03:42 <Jester_Racer> yes, external libraries
08:05:04 <alpounet> Jester_Racer, --extra-include-dirs[=dir] and --extra-lib-dirs[=dir]
08:05:17 <alpounet> see http://www.haskell.org/cabal/users-guide/#miscellaneous-options
08:06:12 <dsilva> hi
08:06:42 <EvanR> does anyone actually use the Monad fail pattern matching mechanism
08:07:46 <Jester_Racer> alpounet: thanks, I'll try it
08:07:53 <Jester_Racer> hope it helps
08:08:52 <parcs> EvanR: it's useful in list comprehensions
08:09:31 <EvanR> like, list monad?
08:09:40 <parcs> yep
08:10:00 <EvanR> im sure its 'useful' in a lot of ways
08:10:09 <EvanR> but do people use it and like it
08:10:36 <parcs> nope, not a single person :)
08:10:53 <EvanR> great lets remove it
08:11:25 * mokus uses it and likes it, but would definitely support separating it from the Monad class
08:11:32 <parcs> the fail mechanism can greatly condense code
08:11:33 <Nibble> uses what
08:11:47 <mokus> irrefutable pattern bindings
08:12:00 <EvanR> no
08:12:13 <mokus> eg, "Right x <- foo"
08:12:20 <EvanR> im talking about the mechanism where its irrefutable, doesnt match anything, and then doesnt crash because you reprogrammed it
08:12:50 <parcs> it's not irrefutable
08:12:55 <EvanR> er
08:12:57 <EvanR> refutable
08:12:59 <mokus> yea, so am I - I use that sort of an idiom for implicit filtering
08:13:09 <EvanR> i hates implicit!
08:13:16 <EvanR> evil
08:13:28 <mauke> I love implicit
08:13:32 <joe6> ari, thanks. your insight was invaluable. I am able to understand how to debug it, now. having encodeJson to see how the data is encoded is invaluable.
08:13:41 <mokus> monads are all about implicit
08:13:54 <mauke> I wouldn't want to pass types around manually
08:14:16 <EvanR> joe6: i mentioned that last night, using the basic commands in the interpreter to see how basic stuff worked before trying to manipulate your giant data structure
08:14:24 <parcs> do { Just x <- foo; return x } desugars into foo >>= \m -> case m of Just x -> return x; _ -> fail "..."
08:14:29 <benmachine> EvanR: it's very useful but it shouldn't be in Monad
08:14:30 <EvanR> that being said Data.Aeson is better
08:14:36 <benmachine> and fail shouldn't take a String
08:14:56 <benmachine> I believe it used to be the case that there was a MonadZero class explicitly for do-blocks with failable pattersn
08:15:07 <benmachine> but it was removed for being overcomplicated or something
08:15:17 <mokus> benmachine: agreed - IMO pattern bind failure should map to mzero
08:15:18 <EvanR> benmachine: where to put the method is one thing, but what about the idea that its a special behavior of pattern matching. not something you can just cut and paste
08:15:42 <benmachine> EvanR: just cut and paste? where would you cut or paste it to?
08:15:47 <benmachine> it's similar to pattern guards and view patterns
08:15:50 <benmachine> in some sense
08:15:53 <EvanR> ok
08:16:04 <parcs> a MonadFail class would require two separate meanings of do notation
08:16:19 <EvanR> well good
08:16:23 <parcs> in the way it's desugared
08:16:29 <mokus> yea, i think that was the original problem - the rules become very complicated to determine whether a do block uses that feature or not
08:16:36 <EvanR> different things should be different
08:17:30 <parcs> its not worth the added complexity
08:17:40 <EvanR> do is simpler, no fail
08:17:44 <EvanR> then theres dof
08:17:45 <EvanR> ;)
08:17:58 <benmachine> mokus: they're not that complex imo
08:18:13 <mokus> benmachine: I tend to agree, but I seem to recall that was the reasoning
08:18:52 <Jester_Racer> ok, so I've tried --extra-lib-dir option, but cabal still don't find SDL_ttf lib, but I'm absolutely sure that it's installed
08:19:00 <Jester_Racer> any suggestions? :S
08:19:40 <mokus> in any case, the question was whether anyone uses and likes failable pattern bindings, and my answer is "yes, but i don't care whether it continues to be implemented the same way"
08:20:11 <EvanR> ok
08:20:19 <EvanR> at least it shouldnt take a string
08:22:05 <EvanR> for error handling purposes theres countless other ways, some better imo
08:22:24 <benmachine> yeah I'd say no parameter at all
08:22:30 <benmachine> the information isn't that useful
08:22:46 <EvanR> and worst of all it hurts the haskell soul!
08:24:37 <mokus> A simple solution, IMO, would be to introduce a new type of pattern binding syntax - no need to introduce a new 'do' entirely
08:24:48 <applicative> Jester_Racer what platform are you using?
08:24:49 <mokus> for example, "Just x <-? foo"
08:25:10 <benmachine> mokus: it always annoys me how many good operator names are syntax though
08:25:13 <EvanR> ?<-
08:25:14 <lambdabot> Maybe you meant: . ? @ bf do ft id pl rc v wn
08:25:16 <benmachine> would be nice if we could avoid eating another one
08:25:29 <Nibble> You know what the haskell community needs? Video tutorials
08:25:31 <mokus> benmachine: true - maybe could find one that's not currently valid
08:25:46 <Jester_Racer> applicative: FreeBSD
08:28:44 <EvanR> what lib uses ? ?
08:29:14 <EvanR> > 3 ? 5
08:29:16 <lambdabot>   Not in scope: `?'
08:29:34 <dainanaki> Has anyone used the Network.Pcap library much?
08:31:20 <shapr> dainanaki: I haven't but would like to hear if it works for you.
08:31:44 <dainanaki> Mostly? :)
08:31:52 <shapr> What doesn't work?
08:32:42 <dainanaki> I'm unclear on how to detect if I've reached the end of the file if I'm using on offline pcap dump.
08:33:17 <applicative> Jester_Racer: What is the error, are you using --verbose=3  by the way.  It seems to check for " sdl-config " first, is it finding that?
08:33:52 <dainanaki> I can use the dispatch function telling it to process all packets at once, but that doesn't work for what I'm trying to do because I just want to get chunks of packets instead of all of them at one time.
08:35:39 <dainanaki> If I use next, once I hit the end of the file it hangs.
08:36:38 <EvanR> hIsEOF ?
08:37:21 <Jester_Racer> applicative: http://hpaste.org/49229  <- This is the error
08:37:38 <Jester_Racer> applicative: I've tried verbose=3 but there was no additional information
08:37:39 <dainanaki> EvanR: Nope, these are PcapHandles, not standard handles.
08:39:04 <Jester_Racer> applicative: Oh, and yes, it is finding sdl-config
08:39:31 <EvanR> dainanaki: what about getNonBlock :: PcapHandle -> IO Bool
08:40:01 <EvanR> might be like E_WOULDBLOCK
08:40:17 <w3rs> hi. what lib is better for Map-like typeclass: gmap or Edison ?
08:40:21 <dainanaki> Guess I'll give that a shot. I got the impression it was geared towards live captures, but it's worth trying.
08:40:40 <EvanR> dainanaki: well when used on a dump handle, its always false, so that would seem useless
08:41:17 <w3rs> really, both don't seem nice to me, maybe there is something else
08:41:34 <copumpkin> holy shit, so much algebra around me
08:41:45 <copumpkin> I'm surrounded by algebra
08:41:56 <EvanR> y = mx + b
08:42:08 <applicative> Jester_Racer: I see that, strange.  you can see the header file if you do locate SDL_ttf.h
08:42:12 <dainanaki> EvanR: yeah, it says that setNonBlock only works for packet capture descriptors obtained from openLive
08:43:11 <EvanR> how do you get this handle?
08:43:13 <applicative> Jester_Racer: maybe you should add --extra-include-dirs=/usr.../include  for the place where that is
08:43:25 <applicative> Jester_Racer: even if your
08:43:32 <joe6> this is what i ended up with: Runners: http://pastebin.com/7HU6kSvj , RunnerPrices: http://pastebin.com/FTKEB9Cg, usage: http://pastebin.com/zMXLH4hn
08:43:37 <mauke> The pastes 7HU6kSvj FTKEB9Cg zMXLH4hn have been copied to http://hpaste.org/49230 http://hpaste.org/49231 http://hpaste.org/49232
08:43:39 <joe6> any suggestions to improve it?
08:43:40 <applicative> having trouble, I seem to have got it working myself for once...
08:44:34 <Jester_Racer> applicative: I've already tried --extra-lib-dirs, it does not help
08:44:41 <applicative> Jester_Racer: (there is an extra layer of nonsense on OS X)
08:44:52 <HugoDaniel> :D
08:45:37 <applicative> Jester_Racer: do you have the source?  do (cabal unpack SDL cabal unpack SDL-ttf )
08:45:55 <EvanR> dainanaki: i didnt find anything. i guess make sure you dont use finite files
08:46:32 <dainanaki> EvanR: indeed. unfortunately, finite files are crucial to what I''m doing.
08:46:50 <EvanR> dainanaki: if next is failing, try dispatch with count of 1?
08:46:57 <applicative> Jester_Racer: then cd SDL and do cabal install --extra-lib-dirs=/usr/wherelibSDLis --extra-include-dirs=/usr/whereSDL.his
08:47:15 <applicative> Jester_Racer: I mean with both flags.
08:48:13 <Jester_Racer> applicative: but I've already installes SDL bindings succesfully, only SDL-ttf is not working
08:48:27 <Jester_Racer> but I'll try it if you want :D
08:50:31 <dainanaki> EvanR, never mind, I figured it out.
08:50:33 <applicative> Jester_Racer: then go into SDL-ttf and do the same, I just meant you might need both pieces of info, the lib dir and include dir
08:50:44 <EvanR> SDL_ttf kinda sucks
08:51:41 <dainanaki> I ended up using replicateM with finite dispatch window size and it gave me proper behavior.
08:52:20 <Jester_Racer> applicative: I did it, with both flags set correctly: SDL installs fine, but SDL-ttf returns with the same error, though I can locate SDL_ttf.h and SDL_ttf.so in my system :(
08:52:36 <EvanR> dainanaki: glad i could help ;)
08:52:43 <applicative> Jester_Racer: did you see that libSDL_ttf is a different C library too? not included with SDL .  Or so it is with me.
08:53:02 <Jester_Racer> applicative: yes of course, and I've installed that too
08:53:24 <applicative> Jester_Racer: grrrrr, ...
08:53:28 <Jester_Racer> :D
08:54:52 <applicative> well my dubious wisdom has been exhausted.  I suspect it's simple.
08:55:31 <EvanR> Jester_Racer: try a C program first
08:55:54 <EvanR> if that doesnt work, at least you wont be trying to solve it through the warped glass of ghc ;)
08:57:24 <Jester_Racer> EvanR: I've just tried that, compiles without any problem
08:57:41 <Jester_Racer> and links w/o problems too
08:57:53 <Jester_Racer> so I'm getting mad :D
08:58:19 <applicative> and you can use the haskell SDL lib without SDL-ttf okay?
08:58:57 <EvanR> Jester_Racer: ok, and now you try ghc --make Foo.hs, and it cant find ttf. try -lSDL_ttf
08:59:24 <EvanR> if not, -L/path/to/freakin/libs
09:00:01 <applicative> EvanR, I think the installation of (hs-) SDL-ttf didnt complete
09:00:13 <Jester_Racer> applicative: yes, I can use SDL, I've already tried to create window, load images etc. SDL-image library works well too
09:00:21 <Jester_Racer> EvanR: I'll try it
09:01:00 <Jester_Racer> EvanR: oh well yes, SDL-ttf installation not complete, it makes no sense to try that
09:01:10 <EvanR> ok so somethings wrong with the bindings for ttf
09:01:17 <Jester_Racer> I think so
09:02:25 <applicative> is there another place doing the hackage dependencies as http://bifunctor.homelinux.net/~roel/hackage/packages/archive/pkg-list.html did?
09:02:32 <applicative> its been down for many days now
09:12:44 <saati> what is the f g a b = g b a functions name?
09:13:03 <EvanR> flip
09:13:05 <ziman> @pl f g a b = g b a
09:13:06 <lambdabot> f = flip
09:13:18 <saati> thanks
09:18:19 <EEVIAC> if i have a 64-bit processor, what are the smallest and largest Int values?
09:18:35 <erus`> 8, 64
09:18:51 <EEVIAC> im pretty sure that's wrong
09:19:13 <EvanR> > minBound :: Int
09:19:14 <lambdabot>   -9223372036854775808
09:19:23 <EEVIAC> > (minBound,maxBound) :: Int
09:19:24 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
09:19:24 <lambdabot>         against inferred type ...
09:19:37 <EvanR> where smallest means least
09:19:44 <EEVIAC> yeah
09:19:48 <copumpkin> > [minBound,maxBound] :: [Int64]
09:19:49 <lambdabot>   [-9223372036854775808,9223372036854775807]
09:19:53 <copumpkin> > [minBound,maxBound] :: [Word64]
09:19:54 <lambdabot>   [0,18446744073709551615]
09:19:57 <copumpkin> > [minBound,maxBound] :: [Int]
09:19:58 <lambdabot>   [-9223372036854775808,9223372036854775807]
09:20:07 <EEVIAC> hmm hmm i see
09:20:07 <erus`> oh i thought you ment datatypes :)
09:20:09 <parcs> > 2^64 / 2
09:20:11 <lambdabot>   9.223372036854776e18
09:20:15 <EvanR> that proves it
09:20:21 <EvanR> Int == Int64 ;)
09:20:21 <EEVIAC> ah there we go
09:20:48 <EvanR> > 2^64 / 2 :: CReal
09:20:50 <lambdabot>   9223372036854775808.0
09:20:51 <erus`> you talked about processors so i though you meant instructions
09:21:01 <EEVIAC> oh
09:22:36 <erus`> but you said values not sizes
09:22:46 <erus`> i concede
09:22:55 <EvanR> > maxBound :: Integer
09:22:56 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
09:22:57 <lambdabot>    arising from...
09:22:59 <EEVIAC> it's cool though :D we all understand each other
09:23:04 <EvanR> INFINITY
09:23:06 <EEVIAC> what the hell is that though, with lambdabot
09:24:16 <zygoloid> benmachine: (apologies, got called away) it's equivalent to case undefined of Void (Void _) -> ()
09:24:16 <Cale> Integer isn't an instance of Bounded, so maxBound doesn't apply
09:24:17 <erus`> it would take megatons of TNT to produce the energy to cycle through all values of a int128
09:24:40 <EvanR> erus`: lol
09:24:58 <erus`> its true i think :)
09:25:06 <erus`> i heard it from some random on irc
09:25:21 <EvanR> it would take like..
09:25:26 <EvanR> a MILLION megatons
09:25:33 <EvanR> maybe more!
09:26:12 <parcs> > 2^128
09:26:14 <lambdabot>   340282366920938463463374607431768211456
09:26:31 <EvanR> > 10^10
09:26:32 <lambdabot>   10000000000
09:26:35 <EvanR> > 10^10^100
09:26:49 <lambdabot>   *Exception: mueval-core: signal: 15
09:26:56 <EvanR> > 10^100
09:27:00 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
09:27:15 <EvanR> ok so 2^128 is relatively tame
09:28:59 <copumpkin> > length . show $ 2^12345
09:29:03 <lambdabot>   mueval-core: Time limit exceeded
09:29:05 <copumpkin> > length . show $ 2^1234
09:29:08 <lambdabot>   372
09:29:41 <EvanR> > length . show $ 10^100
09:29:43 <lambdabot>   101
09:29:48 <EvanR> o_O
09:29:55 <ziman> > 1234 * log 2 / log 10
09:29:56 <lambdabot>   371.47101464935275
09:30:00 <EvanR> ah 100 zeros and one 1
09:30:35 <EvanR> whats the biggest number haskell can handle
09:31:51 <parcs> 17
09:32:04 <EvanR> 17 zillion?
09:33:41 <zygoloid> EvanR: the biggest number haskell can handle is ()
09:33:43 <zygoloid> > succ ()
09:33:44 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
09:33:48 <EvanR> lol
09:34:21 <parcs> > fix succ :: Integer -- let that run for a while
09:34:25 <lambdabot>   mueval-core: Time limit exceeded
09:35:08 <zygoloid> EvanR: the language defines Integer to be unBounded :) your implementation will probably eventually hit some kind of limit
09:35:45 <EvanR> gmp has some limit/
09:36:56 <parcs> @src Integer
09:36:56 <lambdabot> data Integer = S# Int#
09:36:57 <lambdabot>              | J# Int# ByteArray#
09:37:27 <EvanR> \o/
09:38:58 <Tomsik> Actually, basic FFT prime-based integer-multiplication with always-the-same primes has a limit
09:39:06 <Tomsik> I don't know if gmp does that
09:39:17 <Tomsik> (like 30-40 MB for example)
09:39:20 <Tomsik> (for a number)
09:39:35 <EvanR> what sort of limit?
09:39:48 <EvanR> takes too much space, or some theoretical problem
09:40:58 <zygoloid> > let up 0 a b = a * b; up n a b = foldr1 (up (n-1)) (replicate b a); g 0 = 4; g n = up (g (n-1)) 3 3 in g 64 -- graham's number
09:40:59 <lambdabot>   *Exception: stack overflow
09:41:09 <Tomsik> I'd expect a problem when the integer is longer than 2^32 times a small constant
09:43:26 <dainanaki> learning how to write enumerators / iteratees is kind of bending my brain. It reminds me of what it felt like to learn monads
09:43:26 <EvanR> im reading Data.ByteString.Char8
09:43:48 <EvanR> pack :: String -> ByteString uses c2w from internals
09:43:52 <EvanR> wtf does that do
09:44:10 <EvanR> doesnt say if it assumes utf8, or only works with ascii chars, or what
09:44:17 <joe6> @hoogle sleep
09:44:18 <lambdabot> No results found
09:44:28 <monochrom> that's right, it doesn't say, so you shouldn't use it
09:44:34 <EvanR> alright
09:44:41 <EvanR> just wondering what it did
09:45:29 <EvanR> also, the world would be a totally different place if people didnt use stuff that was poorly documented, ill defined, and or they didnt understand
09:45:33 <parcs> c2w :: Char -> Word8
09:45:52 <monochrom> "Manipulate ByteStrings using Char operations. All Chars will be truncated to 8 bits. It can be expected that these functions will run at identical speeds to their Word8 equivalents in Data.ByteString.
09:45:52 <monochrom> More specifically these byte strings are taken to be in the subset of Unicode covered by code points 0-255. This covers Unicode Basic Latin, Latin-1 Supplement and C0+C1 Controls."
09:45:53 <EvanR> > c2w 'x'
09:45:54 <lambdabot>   Not in scope: `c2w'
09:46:02 <copumpkin> parcs: why Word8?
09:46:07 <copumpkin> do you love throwing information away?! :(
09:46:10 <monochrom> that's from the doc page at the top
09:46:14 <EvanR> oh
09:46:33 <EvanR> Char8, now i get it
09:46:37 <joe6> I use this version of read: http://pastebin.com/PmLEUaR0 , as the default version does not have a good error message
09:46:38 <mauke> The paste PmLEUaR0 has been copied to http://hpaste.org/49233
09:46:48 <joe6> is there a better version available in the standard library.
09:47:06 <EvanR> joe6: so you want a parser?
09:47:09 <joe6> i do not want to carry around my version of read, if there is a better version available in the library.
09:47:47 <joe6> EvanR, something that will show a better error message, than just failing with an error message which has no context.
09:47:51 <copumpkin> joe6: if you stopped using pastebin, mauke would stop transferring it to hpaste
09:47:53 <EvanR> joe6: really you want a more robust parser which doesnt crash the entire program
09:47:59 <copumpkin> people don't like pastebin around here :P
09:48:15 <monochrom> there is no better version of read in the standard library
09:48:56 <EvanR> i think people dont like Read much either ;)
09:49:06 <joe6> EvanR, I do not mind the crashing, but just need more context when it crashes.
09:49:15 <zygoloid> > replicate (2^70) "is this a bug?"
09:49:16 <lambdabot>   []
09:49:16 <monochrom> indeed, people don't like to read
09:49:30 <joe6> read has it's uses...
09:49:32 <copumpkin> zygoloid: no
09:49:37 <joe6> it is quick and simple.
09:49:41 <parcs> > 2^70 :: Int
09:49:42 <lambdabot>   0
09:49:54 <EvanR> joe6: well if you wanted quick simple and broken, youd be using php
09:50:12 <joe6> copumpkin, I need to figure out how the pastepipe works. the last i checked, it was broken
09:50:15 <EvanR> but it also supports slow, and complex
09:50:18 <monochrom> it's a hardware bug to have machine word shorter than 70 bits
09:50:20 <joe6> i use a macro to paste to pastebin.
09:50:27 <copumpkin> ah
09:51:01 <gwern> so much vandalism on hawiki
09:51:02 <EvanR> joe6: also the speed that you can pastebin stuff is irritating ;)
09:51:14 <parcs> joe6: see wgetpaste. it pastes to pocoo.org which is a little better than pastebin
09:52:30 <mauke> joe6: I can code it up for. what interface do you want?
09:52:32 <monochrom> vandalism on hawiki?
09:52:39 <Tomsik> I doubt anyone will have computers capable of storing lists of length about 2^60 anytime soon
09:52:45 <zygoloid> copumpkin: d'oh :) of course not
09:52:50 <cheater_> i just select a range of text in vim and do :!pastebinit
09:52:57 <mauke> wat
09:52:58 <Tomsik> and 2^32 is fine for most uses
09:53:01 <mauke> s/for/for you/
09:53:02 <EvanR> Tomsik: 64k will be enough for everybody!
09:53:06 <cheater_> and it gets replaced with the link, which then i copy, and press u to get old text back
09:53:18 <Tomsik> EvanR: c'mon
09:53:38 <Tomsik> 2^32~ bytes is 3-4 GB of RAM
09:53:41 <mauke> cheater_: I use :Paste
09:53:41 <EvanR> Tomsik: actually i usually suggest 32 bit ints too, and people think im insane
09:53:46 <Tomsik> 2^64 is much more
09:53:52 <mauke> cheater_: which outputs the link and also copies it to the clipboard
09:54:15 <EvanR> mauke: your vim connects to the xclip board?
09:54:26 <EvanR> i still havent gotten that to work
09:54:27 <mauke> no, xclip does
09:54:30 <EvanR> oh
09:55:01 <mauke> ... | xclip -f
09:55:34 <EvanR> not -i ?
09:56:06 <mauke> -i ... (default)
09:56:06 <Fuco> :t liftm2
09:56:07 <lambdabot> Not in scope: `liftm2'
09:56:11 <Fuco> :t liftM2
09:56:12 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:59:53 <EvanR> > some Nothing
09:59:55 <lambdabot>   Nothing
10:00:04 <EvanR> > some (Just 0)
10:00:07 <ion> :t some
10:00:08 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
10:00:08 <lambdabot>   mueval-core: Time limit exceeded
10:00:29 <EvanR> why is that a non terminating thingy
10:00:31 <ion> > some (Just 0)
10:00:36 <lambdabot>   mueval-core: Time limit exceeded
10:00:52 <c_wraith> it's generating an infinite list
10:00:53 <benmachine> > some [0]
10:00:57 <lambdabot>   mueval-core: Time limit exceeded
10:01:03 <parcs> > many []
10:01:04 <lambdabot>   [[]]
10:01:35 <EvanR> > take 5 (some (Just 0))
10:01:37 <lambdabot>   Couldn't match expected type `[a]'
10:01:37 <lambdabot>         against inferred type `Data.Mayb...
10:01:51 <EvanR> > liftM (take 5) (some (Just 0))
10:01:56 <lambdabot>   mueval-core: Time limit exceeded
10:01:56 <djahandarie> Won't work when you do it correctly either :p
10:01:57 <djahandarie> Yeah
10:02:21 * djahandarie cringes when people use 'liftM'
10:02:26 <EvanR> haha
10:02:30 <Botje> i rather like liftM.
10:02:40 <Fuco> what's wrong with liftM?
10:02:45 <EvanR> i use liftM when doing monads, but i dont remember the other name now ;)
10:02:49 <copumpkin> it's fmap
10:02:57 <EvanR> > fmap (take 5) (some (Just 0))
10:02:57 <joe6> mauke, can you please give me the command that you use to hpaste/
10:03:02 <lambdabot>   mueval-core: Time limit exceeded
10:03:04 <ion> some (Just 0) expands to basically fix (\f -> (:) <$> Just 0 <*> f)
10:03:04 <copumpkin> with a different name cause of dumb historical reasons
10:03:06 <djahandarie> Fuco, it requires too much structure for what it's actually doing.
10:03:10 <s7s> Does the function insert in Data.Map create a new Map ?! is mempry copied ?!
10:03:15 <ion> > fix (\f -> (:) <$> Just 0 <*> f)
10:03:19 <lambdabot>   mueval-core: Time limit exceeded
10:03:27 <copumpkin> s7s: yes, it does
10:03:37 <copumpkin> s7s: most of the structure is shared though
10:03:46 <copumpkin> so you pay a logarithmic price
10:03:50 <mauke> joe6: I don't use a command
10:04:06 <joe6> mauke, this is the macro I use to paste to pastebin: , ((mod1Mask, xK_p), spawn " TMPFILE=`mktemp` && xclip -o >> $TMPFILE && pastebinit $TMPFILE | tr -d \"\n\" | xclip ")
10:04:27 <EvanR> ion: so why cant i take 5 ?
10:04:32 <s7s> copumpkin: could you please elaborate more what do you mean by the structure is shared  ?!
10:04:38 <copumpkin> s7s: it's a tree-based map
10:04:39 <djahandarie> Yes. ?!
10:04:55 <joe6> mauke, how do I repace the pastebinit with the hpaste util that you use?
10:04:56 <copumpkin> s7s: if you add something to a map, you can rearrange it and keep huge subtrees
10:05:01 <joe6> do you use pastepipe?
10:05:06 <mauke> joe6: I don't use a hpaste util
10:05:06 <ion> evanr: Because (:) <$> Just 0 <*> x needs to know whether x is Nothing before returning a value.
10:05:14 <copumpkin> s7s: so most of the tree didn't change, and that stuff will stay the same
10:05:21 <copumpkin> and be shared between the old map and the new one
10:05:21 <joe6> mauke, then how do you paste to hpaste?
10:05:25 <ion> I.e. it’s too strict for take to work like that.
10:05:37 <EvanR> ion: ok. so wtf is the point of Alternative ;)
10:05:40 <dainanaki> I'm writing an iterate currently where the input is of type (ByteString a), and I want to feed the bytestring portion of the tuple into an iterate over type ByteString. How do I do this?
10:05:46 <mauke> joe6: I don't paste to hpaste?
10:05:46 <s7s> copumpkin: ohh I see
10:06:11 <joe6> mauke, you do paste from pastebin to hpaste? or, your bot, I mean.
10:06:18 <mauke> that's an irssi script
10:06:20 <s7s> copumpkin: So storing the Map in an IORef for example is not a "mutable map" correct ?!
10:06:33 <joe6> can you please share how it pastes to hpaste?
10:06:37 <EvanR> s7s: effectively it is
10:06:59 <EvanR> s7s: you can use modifyIORef to update it
10:07:04 <ion> evanr: With Maybe? <|> is rather useful. With other instances, some and many are, too.
10:07:24 <Younder> Does anyone have any experience with the Haskell interface to Isabelle?
10:07:50 <EvanR> ion: so this behavior is just an artifact of Maybe. and so i cant understand by example how it works with a simple case ;)
10:08:02 <s7s> EvanR: Will the old one be thrown away ?!
10:08:08 <s7s> EvanR: by the GC
10:08:13 <monochrom> "some" and "many" work great for parser Monads. err, parser Alternatives
10:08:20 <EvanR> s7s: the old branches you overwrote yes
10:08:26 <Younder> +I have written a version of Calendrical Calculations and would like to verify some properties.
10:08:58 <ion> ghci> parse (Control.Applicative.many (char 'a')) "" "aaaab"
10:08:58 <ion> Right "aaaa"
10:09:19 <c_wraith> > runST (return 5)
10:09:20 <lambdabot>   5
10:09:26 <s7s> EvanR: can this be generalized to other data structures as well ?
10:09:29 <EvanR> im not sure i understand the Maybe instance
10:09:34 <s7s> EvanR: lists, vectors and so on
10:09:47 <EvanR> s7s: normal data yes, vectors no
10:09:50 <ion> > Nothing <|> Nothing <|> Just 42 <|> Just 43 <|> Nothing <|> Just 44
10:09:51 <lambdabot>   Just 42
10:10:14 <monochrom> if you understand mplus, you understand <|>
10:10:22 <EvanR> ok <|>
10:10:30 <EvanR> and some / many?
10:10:30 <s7s> EvanR: Why not vectors ?
10:10:53 <EvanR> s7s: they are implemented in the backend and behave differently
10:11:17 <benmachine> some / many are only interesting when <|> is lazy
10:11:19 <EvanR> same with Array, Text, etc
10:11:22 <EvanR> ByteString
10:11:31 <benmachine> or
10:11:44 <benmachine> possibly when some combination of <*> and <|> are lazy in a particular way
10:11:50 <c_wraith> > let {f r = do { x <- readSTRef r ; if x > 0 then writeSTRef r (x - 1) >> return x else retry } } in runST (do { x <- newSTRef 5 ; some (f x) } )
10:11:51 <lambdabot>   Not in scope: `retry'
10:11:54 <EvanR> lazy <|>...
10:11:58 <s7s> EvanR: there's no use of Storing them in an IORef  ?
10:12:05 <c_wraith> oh, I confused STM and ST.  nice
10:12:09 <c_wraith> *sigh*
10:12:18 <EvanR> s7s: especially not if they are manipulated with IO actions directly like mutable arrays
10:12:26 <c_wraith> and of course, STM doesn't work in lambdabot
10:13:09 <s7s> EvanR: this is true for all static memory structures ?!
10:13:09 <benmachine> @instances Alternative
10:13:10 <lambdabot> Couldn't find class `Alternative'. Try @instances-importing
10:14:00 <EvanR> s7s: if you want mutable structures like in C, use IO based arrays. often you dont want that
10:15:31 <EvanR> Array is nice if you want a read-only table, altering it would require a full copy though
10:15:34 <benmachine> s7s: I think there's been some miscommunication here
10:15:58 <benmachine> you can write vectors to IORefs if you like
10:16:15 <EvanR> benmachine: i think he got disconnected
10:16:23 <benmachine> hm
10:16:29 <benmachine> oh well
10:16:31 * benmachine loses interest :P
10:16:35 <EvanR> lol
10:17:32 <Tomsik> You can use ST instead of IO too
10:17:36 <Tomsik> for most arrays
10:17:56 <EvanR> meh who needs IO
10:19:38 <EvanR> ah i thought some and many were methods of Alternative
10:19:52 <EvanR> just <|> and empty
10:20:16 <benmachine> actually they are but they have default definitions
10:20:18 <benmachine> for efficiency
10:20:22 <EvanR> hmm
10:20:30 <benmachine> (this is as of base version x for some x)
10:20:34 <EvanR> i hate googling and getting random out of date docs
10:21:13 <Eduard_Munteanu> Yeah ST is a bit more painful but a better idea, if you can use it.
10:21:16 <EvanR> so whats the idea behind alternative? is there some law <|> has to follow besides being associative?
10:22:18 <benmachine> EvanR: um, possibly. I think it's a bit like MonadPlus in that everyone agrees there should be laws but can't agree what exactly
10:22:21 <Eduard_Munteanu> (you can also extract the end result from it, which you can't from IO, so that kinda compensates depending on case)
10:23:00 <Tomsik> ST painful?
10:23:10 <Tomsik> I think it's less painful than IO
10:23:30 <Tomsik> you get a pure result, it's a very good thing to have
10:23:45 <Tomsik> no need to thread IO around
10:24:13 <benmachine> Tomsik: pure algorithms are even better though
10:25:11 <Tomsik> Well, they sure are great, but sometimes they a little bit too slow in comparision
10:25:12 <Tomsik> or complicated
10:26:16 <dainanaki> What am I supposed to do in an enumerator if I get Nothing from head and I don't have a simple way to provide an 'mzero' of the type that I'm producing?
10:28:31 * hackagebot boomerang 1.0.0 - Library for invertible parsing and printing  http://hackage.haskell.org/package/boomerang-1.0.0 (JeremyShaw)
10:29:05 <hpaste> mauke pasted “hpaste” at http://hpaste.org/49234
10:30:02 <mauke> joe6: http://hpaste.org/49234 - barely tested
10:30:18 <luite> what, perl?
10:31:11 <mauke> of course
10:32:04 <Kestas> lol
10:32:11 <benmachine> lol
10:32:14 <Kestas> this chat is do dam old
10:32:44 <Kestas> People those have @ before their name are admins right?
10:32:45 <luite> mauke: dunno, using perl to move pastes to a haskell pastebin seems wrong ;p
10:32:51 <mauke> the only test I did with this code was to use it to hpaste itself
10:33:10 <mauke> luite: that's something I just wrote; it's not the actual code running in my irc client
10:33:27 <luite> oh ok
10:33:29 <mauke> luite: and hpaste is not the only possible target
10:34:00 <mauke> that script is running in a few other channels ... most of which I forgot to join, so they're fucked. hah.
10:34:38 <nyingen> is there a way I can find out which packages on hackage use Arrows?
10:35:04 <dmwit> Yes, there's a reverse-dependencies Hackage server out in the ether somewhere.
10:35:06 <luite> mauke: what's the reason for copying those pastes?
10:35:08 <dmwit> Google will tell you where.
10:35:15 <mauke> luite: pastebin.com sucks
10:35:48 <luite> because of the ads?
10:36:23 <mauke> among other things
10:42:12 <dpratt71> there's probably some very good technical reason, why it couldn't work, but would it not be nice/convenient for Haskell to automatically 'widen
10:42:15 <dpratt71> oops
10:42:17 <dpratt71> '
10:42:34 <dpratt71> automatically 'widen' numeric types in certain circumstances?
10:43:04 <dpratt71> e.g. when there's a type conflict between Int and Double?
10:45:50 <ion> > (fromIntegral :: Int -> Float) maxBound == (fromIntegral :: Int -> Float) (maxBound - 1)
10:45:51 <lambdabot>   True
10:47:24 <identity_> :t maxBound
10:47:25 <lambdabot> forall a. (Bounded a) => a
10:47:41 <identity_> > maxBound :: Float
10:47:42 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Float)
10:47:43 <lambdabot>    arising from a use of...
10:47:58 <identity_> > (fromIntegral :: Int -> Float) maxBound
10:47:59 <lambdabot>   9.2233721e18
10:48:10 <identity_> > maxBound :: Int
10:48:11 <lambdabot>   9223372036854775807
10:48:14 <identity_> ah
10:50:33 * hackagebot web-routes-boomerang 0.25.0 - Library for maintaining correctness and composability of URLs within an application.  http://hackage.haskell.org/package/web-routes-boomerang-0.25.0 (JeremyShaw)
10:53:10 <dpratt71> is it true (as I have heard it said) that you should *never* compare two floating point values for equality? if so, why is (==) defined for floating point numbers?
10:53:28 <EvanR> theres a lot of weird stuff defined for floats
10:53:41 <azaq23> > 3 * (1.1) == 3.3
10:53:42 <lambdabot>   False
10:53:45 <monochrom> I think "never" is always an overstatement
10:54:03 <dainanaki> usually
10:54:18 <int-e> "never" is never not an overstatement?
10:54:37 <dainanaki> usually never is always an overstatement… sometimes.
10:54:42 <danharaj> > 3 * (1.1)
10:54:43 <lambdabot>   3.3000000000000003
10:54:45 <azaq23> Num t needs a Eq t qualification, so == had to implemented in some way for it to be a num
10:54:53 <danharaj> > 3 * (1.1) :: Double
10:54:55 <lambdabot>   3.3000000000000003
10:55:01 <monochrom> floating point equality is of limited use, yes, but not absolutely useless
10:55:05 <azaq23> that's what I would see as a possible explanation, anyways
10:55:17 <dpratt71> azaq23: why not (==) = undefined?
10:55:22 <int-e> > 3 * (1.1) == 3.3 :: Rational
10:55:23 <zygoloid> dpratt71: no, it is not true that you should never compare two floating point values for equality
10:55:24 <lambdabot>   Couldn't match expected type `GHC.Real.Rational'
10:55:24 <lambdabot>         against inferred t...
10:55:40 <int-e> > 3 * (1.1) == (3.3 :: Rational)
10:55:42 <lambdabot>   True
10:55:46 <Eduard_Munteanu> dpratt71: depending on how you do your calculations, you might want to account for limited precision / errors
10:56:26 <danharaj> > 3 * (1.1) :: Float == 3.3
10:56:27 <lambdabot>   <no location info>: parse error on input `3.3'
10:57:12 <Eduard_Munteanu> Mathematically speaking, what one usually wants is    | x - x_ref | < some_small_epsilon    , not x == x_ref
10:57:20 <danharaj> not really
10:57:22 <azaq23> dpratt71: That is a possibility today, but, as is often said in this channel, the Num hierarchy is a little bit messed up due to historic reasons, and maybe that didn't exist back then. Also, even if == for floats is weird, it would still be more weird to just not have it implemented. But I don't know why it was done that way, so don't take my word for this.
10:57:33 <monochrom> if you write down your problem specification carefully, you know whether floating point equality solves your problem or not
10:57:38 <danharaj> epsilon equality is pretty sketchy
10:57:47 <dpratt71> so in summary, (==) as defined for floating point numbers may make sense in certain circumstances?
10:57:54 <monochrom> if you don't write down your problem specification carefully, you know nothing
10:57:56 <Eduard_Munteanu> danharaj: yeah, it depends on the problem
10:58:12 <danharaj> http://download.oracle.com/docs/cd/E19957-01/806-3568/ncg_goldberg.html
10:58:34 <monochrom> so in summary, you know nothing
10:58:40 <kmc> there is a broad range of integers for which IEEE double-precision floating point gives exact results
10:59:28 <mokus> the short version is that unless you know exactly how floating point numbers work, you should regard them as dangerous voodoo, because that's what they are.
10:59:33 <kmc> as i've said before, the real numbers are such a thoroughly ridiculous construct that it's not surprising that attempting to implement them in a computer produces something monstrous
10:59:40 <int-e> > length $ takeWhile (/= 0) $ iterate (/2) 1
10:59:42 <lambdabot>   1075
11:00:04 <Eduard_Munteanu> (This (what I said) isn't actually specific to FP, just any limited precision calculation)
11:04:27 <int-e> fun with floating point: http://int-e.home.tlink.de/sin2.png :-)
11:04:55 <monochrom> it applies to all computations too. "should == never be used?" "should recursion never be used?" same question
11:06:59 <ziman> int-e, whoa, cool, i've just reproduced it successfully here :)
11:07:28 <ziman> int-e, how did you come up with this formula and xrange?
11:08:52 <int-e> ziman: well the formula was on a whim (sin(pi/2+x) - cos(x) is 0, formally); as for the range, well it turns out that interesting things happen near powers of 2, because then the pi/2 + x calculation causes a change in the exponent of the floating point number.
11:10:39 <taotree> is this single precision float or double?
11:10:48 <int-e> (not all powers of 2 work, it depends on the corresponding bit in pi ... it's fun to analyze this, under the assumption that the FPU calculates sin and cos exactly (which the x86 ones do quite well))
11:10:58 <copumpkin> zomg
11:11:02 <int-e> taotree: double. the program is gnuplot.
11:11:07 <Eduard_Munteanu> Hm, interesting.
11:11:08 <copumpkin> function composition is not general enough for python http://bugs.python.org/issue1506122
11:11:09 <ziman> very interesting!
11:12:34 <osfameron> istr it's hard to write a haskell-like compose for Perl too, because of things like vararg functions, and context
11:12:34 <Eduard_Munteanu> > sin $ pi / 6
11:12:35 <lambdabot>   0.49999999999999994
11:12:41 * EvanR applies a gun-nut style argument again == = undefined for floats
11:12:53 <taotree> looking at the y-scale, though... one wonders if that jittering matters. I would not expect it to be that precise anyway for floating point
11:12:58 <EvanR> i cant use ==? fine. not > && not < ;)
11:13:04 <EvanR> EAT THAT
11:13:13 <Eduard_Munteanu> taotree: yeah, only the shape is annoying
11:13:20 <EvanR> gonna outlaw Ord too?!
11:13:26 <EvanR> or not
11:13:29 <EvanR> or and
11:14:42 <int-e> EvanR: be careful, that should be >= && <=, otherwise you get into trouble with NaNs (which are another floating point mine field)
11:15:11 <EvanR> cool
11:15:41 <int-e> (and are very annoying because they don't satisfy a == a. thanks, IEEE)
11:18:51 <azaq23> If a is a subtype of b, there exists a unique conversion function a -> b which preserves all important information. For any functor, the fmapped conversion function is of type f a -> f b, which, due to uniqueness and the information preserving property, can also be seen as a conversion function.
11:18:56 <azaq23> Apparently I can conclude from this, that f a is a subtype of f b necessarily, where f is the functor. Is this correct? In other words, can I say that if I've got a unique function which could be seen as a conversion function, does this imply that there exists a subtype relation?
11:19:00 <azaq23> Also, the same goes for contravariant functors; would that mean there there cannot be a contravariant typing relation between, say, [a] and [b], where a is a subtype of b, because there isn't a sensible function cmap :: (a -> b) -> [b] -> [a]? Such a relation of course doesn't make sense intuitively.
11:19:44 <int-e> taotree: sure, the precision is ok, and in the range you'd expect, perhaps better (because the implementation of sin and cos is quite a bit more precise than I had expected at least)
11:20:11 <stobix> heh. Today marks the day that I, after using Haskell to and fro for 7 years in a number of projects, stumbled upon the fact that Haskell has records...
11:20:27 <int-e> taotree: it's still a funny effect, especially when it jumps between two curves depending on the least significant bit of the mantissa.
11:21:05 <kmc> stobix, maybe you haven't used them before because they suck
11:22:18 <taotree> int-e, yes, it is curious
11:23:38 <taotree> curious again, though... I'm outputting the results of that in Java and I don't see that effect
11:24:35 <monochrom> java may use its own sin and cos algorithms
11:25:23 <monochrom> but I don't know
11:25:43 <int-e> oh for portability. :/
11:26:04 <monochrom> ah, then it should use its own code
11:26:22 <mokus> iirc, that's the difference between Math and StrictMath - Math uses native, StrictMath uses portable
11:27:05 <Eduard_Munteanu> azaq23: must f be injective?
11:27:15 <monochrom> I see. but people tend to just use Math.sin
11:27:31 <taotree> Math.sin delegates to StrictMath.sin which is a native call
11:29:14 <Eduard_Munteanu> Wait, I kinda see your problem now.
11:29:34 <schugschug> Hello I have a question regarding State monads
11:29:36 <azaq23> Eduard_Munteanu: I don't really know what it means to call a functor (Functor f => ...) injective
11:29:44 <scooty-puff> if i have a data type FunD Int ComplexType, and I want to memoize freeVars :: FunD -> [Int], is it possible to use the first Int argument to the FunD data constructor as lookup?
11:29:46 <scooty-puff> other than with a state monad
11:30:28 <kmc> the smartass answer is "yes, because State monads are just syntactic sugar"
11:30:49 <schugschug> Using the standard State monad there are two functions evalState and execState if I call them separately is that like running the monad code twice?
11:30:54 <aperrien> Hello again
11:31:02 <azaq23> Eduard_Munteanu: The basic problem is the question, if I can conclude from the existence of a conversion function that there exists a subtype relation
11:31:13 <kmc> scooty-puff, but maybe look at http://hackage.haskell.org/package/data-memocombinators and http://hackage.haskell.org/package/MemoTrie
11:31:33 <kmc> lazy evaluation is secretly mutation behind the scenes
11:31:35 <azaq23> Eduard_Munteanu: That would mean that for every existing functor, if a is a subtype of b, then f a is also a subtype of f b
11:31:40 <kmc> and is already close to memoization
11:31:45 <kmc> and these libraries exploit that fact
11:32:03 <kmc> schugschug, it is exactly like calling a function of type (s -> (a, s)) twice, because that's what it is
11:32:06 <kmc> @unmtl State s a
11:32:06 <lambdabot> s -> (a, s)
11:32:20 <Eduard_Munteanu> azaq23: yeah, nevermind injectivity, I'm not really sure if you can treat f a -> f b as a subtyping relation
11:32:36 <Eduard_Munteanu> *as implying a subtyping relation
11:32:36 <scooty-puff> kmc, thank you
11:32:42 <kmc> schugschug, "runState" gives you both a and s
11:32:48 <schugschug> so Is there a way to to go from State a b -> (a, b) ?
11:32:51 <Eduard_Munteanu> aperrien: hi
11:33:00 <kmc> evalState and execState just call runState and then throw out one or the other
11:33:02 <kmc> :t runState
11:33:03 <lambdabot> forall s a. State s a -> s -> (a, s)
11:33:13 <EvanR> schugschug: not without some initial state
11:33:14 <kmc> in fact runState is just the destructor for the State datatype
11:33:14 <schugschug> Ok thanks.
11:33:25 <kmc> newtype State s a = State { runState :: s -> (a, s) }
11:33:42 <kmc> State really is just sugar for functions
11:33:55 <EvanR> s/State/_/
11:34:09 <kmc> IO and ST and STM are not
11:34:11 <kmc> this causes much confusion
11:34:19 <EvanR> yeah they dont count ;)
11:34:23 <kmc> the IO monad is atypical among monads but it's often the one people approach first
11:34:32 <EvanR> should be removed from the language, impure!
11:34:35 <kmc> and then they attribute a lot of properties of IO to monads in general
11:34:40 <kmc> haha
11:34:44 <kmc> Safe Haskell,man
11:35:03 <azaq23> Eduard_Munteanu: Yes, me neither :) This came up a few days ago and apparently, you can; but I wasn't sure if I really can argue in "both directions" (between subtyping relation and conversion function)
11:36:29 <azaq23> s/you can/you can at least see the connection between the subtype relation, the conversion function and from that there of course exists a fmapped conversion function/
11:43:56 * aperrien is attemting to solve his own problem, without pestering the group
11:45:22 <kmc> aww we like being pestered
11:49:37 <aperrien> Ok.... I think I need an in-depth study of Haskell types...
11:50:16 <kmc> which aspect?
11:50:39 <aperrien> I'm  trying this: assessSquare :: Float -> Float -> Bool
11:51:04 <aperrien> assessSquare i n = isSquare(fromIntegral((ceiling (sqrt n)+ i ) ^2) - n )
11:51:48 <c_wraith> wow.  that's ugly. :)
11:52:11 <mauke> creative placement of parens
11:52:42 <mauke> aperrien: ceiling (...) + i looks like a type error
11:52:45 <scooty-puff> kmc, i was wondering if this might be more straightforward to do with explicit State (via a Map, etc.): a result is the same for multiple input sets, but each result will be looked up using only a single one of those input sets
11:52:47 <mauke> :t ceiling
11:52:48 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
11:52:49 <aperrien> I keep getting errors when I try to compile it
11:52:59 <mauke> aperrien: ceiling returns an integer. i is a float.
11:53:06 <mauke> you can't add them
11:53:31 <scooty-puff> kmc, it seems like i would need an InputSet -> FakeParameter or some such
11:53:36 <aperrien> How do I change a float to an integer, or vice versa?
11:54:06 <aperrien> Or is there a better way to think about the problem?
11:54:10 <mauke> aperrien: integer -> float (or really: integer -> anything): fromIntegral
11:54:20 <mauke> aperrien: float -> integer: floor, ceiling, round
11:54:33 <kmc> scooty-puff, ?
11:54:43 <kmc> *scrolls up*
11:54:51 <kmc> hmm
11:55:01 <kmc> yeah, that's not as easy to do with data-memocombinators or whatever
11:55:02 <aperrien> I tried wrapping the ceiling call in a fromIntegral, and still got an error
11:56:07 <scooty-puff> kmc, so basically, give some standard Exp and Stmt types, i want to get the extra sets (for lambda lifting), at some part, the free vars, call sets of strongly connected functions are merged, but when modifying the call sites and definitions, the lookup of the extra set will be per function, not per strongly connected function
11:56:52 <aperrien> mauke: And you're right it is getting ugly
11:56:54 <scooty-puff> even though the extra sets were calculated using data per strongly connected set of functions
11:57:16 <aperrien> mauke: That's why I'm wondering if there is a better way to do it
11:57:22 <mauke> aperrien: do what?
11:57:28 <kmc> scooty-puff, ah, can you just build a map from each function to its strongly-connected set?
11:57:31 <scooty-puff> so it seems i would need a mapping from function to strongly connection function set identifier, to find the extra set
11:57:34 <kmc> yeah
11:58:30 <aperrien> mauke: I'm trying to implement Fermat Factoring, as given by the algorithim on this site:http://www.math.ksu.edu/math511/notes/925.html
11:58:51 <copumpkin> aperrien: you're doing it wrong
11:59:03 <copumpkin> aperrien: you're using floats
11:59:06 <copumpkin> you should be using integers
11:59:20 <mauke> what is Ö(r)?
11:59:36 <aperrien> mauke: sqrt r
11:59:41 <mauke> wtf
11:59:50 <copumpkin> an encoding error
12:00:28 <copumpkin> oh actually not
12:00:38 <copumpkin> it's actually &#214; in the html
12:00:47 <copumpkin> wtf indeed
12:00:53 <mauke> microsoft--
12:00:58 <mauke> I bet this works in IE
12:01:03 <copumpkin> there are plenty of badly encoded characters in there, too
12:01:49 <copumpkin> yeah, it works in IE
12:01:51 * copumpkin sighs
12:02:00 <copumpkin> the encoding issues with the 103 ??? 97 are still present though
12:02:03 <aperrien> Ok I'm basically trying to compute n^2 - 654, as in the example
12:02:15 <mauke> aperrien: you should never ever use Float
12:02:26 <copumpkin> you want an integer square root
12:02:55 <aperrien> I understand that, I'm doing this as an exercise to learn Haskell
12:03:02 <copumpkin> steal the example from here
12:03:02 <copumpkin> http://www.haskell.org/haskellwiki/Lambda_lifting
12:03:06 <monochrom> no, not windows-1252 either
12:03:12 <cheater_> does haskell have a concept of docstrings like python does? and does ghci have a sort of help() ?
12:03:13 <copumpkin> monochrom: the issue isn't the encoding as much as the font
12:03:14 <aperrien> I keep beating my head on type, which is good and bad
12:03:25 <copumpkin> aperrien: you can only do math on things of the same type
12:03:37 <mauke> cheater_: no
12:03:41 <cheater_> why not?
12:03:54 <copumpkin> monochrom, mauke : it uses the "symbol" font, that none of us has
12:04:00 <aperrien> as it means that I'm learning (the hard way, I think) about the type system in Haskell
12:04:04 <copumpkin> and of course symbol font happily ignores what the glyphs should look like
12:04:06 <cheater_> mauke: i'm betting it was brought up at least once
12:04:07 <copumpkin> and uses other random shit
12:04:12 <mauke> copumpkin: font isn't really relevant
12:04:20 <copumpkin> mauke: how is it not?
12:04:37 <cheater_> copumpkin, you're talking about times before utf
12:04:43 <copumpkin> I know
12:04:44 <monochrom> copumpkin: I understand your point. in modern terms
12:04:45 <cheater_> copumpkin, you're even talking about times before unicode
12:04:46 <copumpkin> it's represented in html
12:04:47 <monochrom> err
12:04:49 <copumpkin> &#214;
12:04:55 <copumpkin> that's the html entity for that sqrt function
12:04:59 <copumpkin> it's not an encoding issue
12:05:07 <mauke> &#214; is LATIN CAPITAL LETTER O WITH DIAERESIS
12:05:15 <mauke> the font Symbol doesn't contain that letter
12:05:19 <copumpkin> it's wrapped in <FONT FACE="Symbol">&#214;</FONT>
12:05:24 <mauke> therefore a browser should switch to a substitute font
12:05:26 <copumpkin> mauke: the font Symbol remaps that shit to random shit
12:05:30 <mauke> no
12:05:33 <mauke> the font Symbol doesn't contain that letter
12:05:37 <copumpkin> it shows up just fine in windows
12:05:39 <copumpkin> I just tried
12:05:43 <monochrom> copumpkin: I understand your point. in 1990 terms your wording is right. in 2011 terms it is an encoding problem, since we have refactored what belongs to font, what belongs to code point, and what belongs to encoding
12:05:45 <mauke> because IE is broken
12:05:55 <copumpkin> mauke: because the Symbol font maps letters to random symbols
12:06:32 <monochrom> the 1990 "symbol font" is a merge of today's encoding and glyph. like all 1990 "font"s
12:06:44 * hackagebot pretty 1.1.0.0 - Pretty-printing library  http://hackage.haskell.org/package/pretty-1.1.0.0 (DavidTerei)
12:06:58 <copumpkin> open the Symbol font in a font browser
12:07:02 <copumpkin> none of the letters are mapped to letters
12:07:11 <copumpkin> it's a font that lies
12:07:19 <aperrien> mauke: So basically, I should implemnt an integer square root first before attempting the algorithm?
12:07:21 <mauke> http://blogs.msdn.com/b/oldnewthing/archive/2006/05/23/604741.aspx
12:07:29 <monochrom> a font that lies is not a true font  XD
12:08:48 <copumpkin> anyway
12:08:50 <copumpkin> it isn't IE
12:08:52 <copumpkin> it's the symbol font
12:09:10 <mauke> copumpkin: https://developer.mozilla.org/en/Mozilla_Web_Developer_FAQ#Why_aren.e2.80.99t_symbol.2fdingbat_fonts_working.3f
12:09:30 <kmc> i mean you can "implement" integer square root as isqrt = floor . sqrt . fromIntegral
12:09:38 <kmc> :t floor . sqrt . fromIntegral
12:09:40 <lambdabot> forall b a. (Integral b, Integral a) => a -> b
12:09:55 <kmc> > (floor . sqrt . fromIntegral) 85
12:09:55 <int-e> taotree: the effect should be visible in java, too; I tried 511, 511.0000001, 511.0000002 etc, which alternates nicely between negative and positive difference between sin(x+pi/2) and cos(x). (not using java though, I looked at the implementations of those native functions, and have a small C program to test this.)
12:09:57 <lambdabot>   9
12:10:11 <aperrien> kmc: I'm guessing that's it
12:10:39 <kmc> or ceil if that's what you need
12:11:15 <copumpkin> mauke: what are you saying?
12:11:22 <aperrien> kmc: out of curiosity, why is the fromIntegral needed in that statemedt?
12:11:50 <kmc> aperrien, because the input is an Int or Integer and sqrt needs something in the Floating type class, which neither of those is
12:11:50 <mauke> copumpkin: that apparently firefox knows that Symbol doesn't have a glyph for "a" or whatever
12:12:01 <copumpkin> mauke: Word does not
12:12:04 <monochrom> however, √(123) is still funky notation :)
12:12:11 <copumpkin> it isn't IE
12:12:12 <kmc> aperrien, there are no implicit type conversions or promotions in Haskell
12:12:13 <copumpkin> is my point
12:12:26 <mauke> it totally is IE
12:12:29 <mauke> Word isn't a browser
12:12:34 <monochrom> I agree it isn't IE. it is 1990 mindset.
12:12:38 * copumpkin sighs
12:12:51 <aperrien> kmc: Ah.... i didn't think throug the impications of that
12:13:00 <monochrom> 1990 netscape would do the same thing
12:13:20 <copumpkin> mauke: chrome does it just fine
12:13:23 <monochrom> but sorry, there were no IE or netscape in the year 1990 :)
12:13:29 <copumpkin> with a fucking sqrt symbol
12:13:30 <copumpkin> in windows
12:13:39 <kmc> mosaic!
12:13:44 <copumpkin> it's windows font rendering, how about that
12:13:47 <mauke> copumpkin: I'd say that's a bug
12:13:55 <copumpkin> firefox probably implements its own
12:14:00 <copumpkin> chrome uses standard windows stuff
12:14:05 * copumpkin shrugs
12:14:11 <aperrien> kmc: I thought that fromIntegral only returned an integral
12:14:11 <copumpkin> anyway, my point is just that IT IS NOT JUST IE
12:14:18 <copumpkin> :P
12:14:20 <kmc> :t fromIntegral -- aperrien
12:14:22 <lambdabot> forall a b. (Integral a, Num b) => a -> b
12:14:29 <aperrien> kmc: Guess I had that backwards
12:14:31 <taotree> int-e, Ah, I see it now. I hadn't been doing it at a small enough increment
12:14:38 <kmc> :t toInteger
12:14:39 <lambdabot> forall a. (Integral a) => a -> Integer
12:14:45 <kmc> :t fromInteger
12:14:47 <lambdabot> forall a. (Num a) => Integer -> a
12:14:47 <copumpkin> I have the sqrt symbol in about five different programs open on my work windows machine
12:14:48 <kmc> @src fromIntegral
12:14:49 <lambdabot> fromIntegral = fromInteger . toInteger
12:15:00 * copumpkin fights mauke
12:16:04 <monochrom> the whole idea of obtaining non-ascii characters by font-switching is ill-conceived
12:16:20 * copumpkin fights monochrom 
12:16:23 * copumpkin fights EVERYONE
12:16:28 <mauke> copumpkin: how many of those programs use <font face=Symbol>?
12:16:58 <copumpkin> mauke: are you seriously arguing that chrome is using IE's rendering engine?
12:17:11 <mauke> no, they probably reimplemented that bug for compatibility
12:17:19 <aperrien> copumpkin: Sorry for inciting Chaos
12:17:20 <copumpkin> only on windows?
12:17:25 <mauke> dunno
12:17:29 <copumpkin> I copied the font to my mac
12:17:31 <copumpkin> no bug
12:17:58 <monochrom> please don't say "no bug" yet. please say "same observation" for now
12:18:00 <copumpkin> :P
12:18:09 * copumpkin fights monochrom 
12:18:58 <aperrien> Thanks again mauke, copumpkin , kmc! I learn a lot each time I come here.
12:19:04 <kmc> me too :D
12:19:12 * copumpkin fights aperrien 
12:19:28 <copumpkin> I hereby conclude
12:19:28 <aperrien> And I really need to beat the Haskell type system into my thick skull
12:19:35 <dpratt71> <copumkin>: I will be the one!
12:19:39 * aperrien dodges copumpkin 
12:19:44 <kmc> aperrien, i think this is a fiddly detail of the Haskell type system
12:19:53 <copumpkin> that the symbol font does not always lie, and that mac OS treats it correctly
12:19:57 <copumpkin> and the windows renderer does not
12:19:59 <mauke> aperrien: so far all you need to do is understand the difference between integers and floating-point numbers
12:20:43 <aperrien> mauke: And the fact that in Haskell, they never cross directly
12:20:53 <EvanR> they never cross in C either
12:20:57 <mauke> that's a separate issue
12:21:05 <EvanR> but there is implicit conversion on your behalf
12:21:22 <monochrom> let's debate what's "direct" too
12:21:34 * aperrien has to get used to life without implicit conversion
12:21:37 <monochrom> it is not the conversion. it is the syntax
12:21:47 <kmc> implicit conversions are the worst language feature
12:21:51 <kmc> they are more trouble than they're worth
12:22:05 <sob7y> pl \f g = g (f g)
12:22:09 <EvanR> lol in js you cant write an invalid expression
12:22:13 <EvanR> everything can be everythinged
12:22:20 <kmc> yep
12:22:30 <aperrien> kmc: Yes, but they are a crutch that you can end up leaning on.
12:22:33 <kmc> javascript and perl belong to the school of "express yourself poorly and i will guess what you mean"
12:22:33 <monochrom> if the syntax doesn't make you insert a token to indicate conversion, it is direct
12:22:35 <dpratt71> kmc: C# has implicit 'widening' conversions; I don't hear a lot of negative comments about that
12:22:39 <EvanR> they paid some poor sap big bucks to come up with wtf should happen in every case
12:22:48 <kmc> dpratt71, widening i.e. superclasses?
12:22:59 <mauke> kmc: I disagree!
12:23:01 <_Ray_> EvanR, not really, the rules for type conversion were done by Eich when first creating JS.
12:23:05 <aperrien> Anyway, I need to be off. Thanks again all
12:23:08 <_Ray_> It was mostly whatever he wanted to happen.
12:23:18 <EvanR> thats what i mean
12:23:25 <dpratt71> kmc: strictly numeric conversions (if that doesn't answer the question, I don't know how to)
12:23:26 <_Ray_> They didn't pay him "big bucks" :s
12:23:30 <_Ray_> It was just a toy.
12:23:34 <aperrien> And sorry for the Chaos
12:23:40 <kmc> dpratt71, but neither Int nor Double is functionally a superclass of the other
12:23:47 <kmc> whoever's substitutability criterion
12:23:57 <dpratt71> i.e. Int -> Double, ok, Double -> Int bad (loss of information)
12:23:57 <EvanR> ok so they didnt pay someone for the work he did to come up with arbitrary conversions
12:24:04 <EvanR> even worse
12:24:20 <mauke> I hate numeric towers
12:24:21 <monochrom> Dilbert's substitutability criterion
12:24:28 <monochrom> @quote monochrom Dilbert
12:24:28 <lambdabot> monochrom says: Dilbert's substitutability principle.  A subclass's programmer should work as a drop-in replacement of his/her predecessor.
12:24:43 <EvanR> lol
12:24:52 <dpratt71> kmc: because of issues like equality?
12:25:42 <monochrom> actually, Int64 -> Double loses bits too
12:26:26 <kmc> yeah, some integer arithmetic on Int64 becomes inexact on Double
12:26:30 <mokus> > let i2d :: Int -> Double; i2d = fromIntegral in i2d maxBound == i2d (maxBound-1)
12:26:31 <lambdabot>   True
12:26:32 <kmc> and obviously some Double arithmetic can't be represented on Int
12:27:03 <dpratt71> I am hardly an expert on issues relating to numeric representation, but in practice the fact that ints get promoted to doubles (and other similar conversions) has never really presented a problem for me
12:27:37 <monochrom> because you had int32 so far
12:27:41 <kmc> it seems bad that some exact integer math could become inexact if a "+ 0.0" sneaks in somewhere
12:28:03 <int-e> don't do that then ;)
12:28:26 <monochrom> or you had int64 but you used them as int54 or int53 I forgot which
12:28:27 <dpratt71> kmc: I see your point, but that's always been my expectation
12:28:28 <mauke> kmc: just use perl!
12:28:30 <kmc> yeah, C is a fine language, just don't dereference NULL or overflow a buffer or double-free anything or...
12:28:45 <mauke> (perl will keep it as an int)
12:28:48 <mokus> C is great for an assembly language ;)
12:29:01 <int-e> perl has a saner behaviour for 1/3 than C :)
12:29:12 <mauke> (or python)
12:29:16 <kmc> the point is "don't do that" is not a valid response to the lack of a safety check
12:29:38 <int-e> kmc: Oh but in C it is.
12:29:41 <cheater_> why does haskell not have docstrings?
12:29:50 <monochrom> safety checks stall pipelines and confounds caches and ...
12:29:56 <mauke> cheater_: what's the point?
12:29:58 <kmc> int-e, right, well if there's anything I've learned on IRC, it's that not using C means i have a small penis
12:30:00 <EvanR> haskell makes you explicitly say what youre doing. so basically, COBOL is 100 times better? ;)
12:30:06 <cheater_> mauke, i find docstrings super-helpful
12:30:22 <cheater_> if i'm prototyping something in an interpreter, i can quickly check the usage of a function without switching context
12:30:26 <int-e> kmc: Oh, I hope you didn't learn that here. And I wonder how all the female programmers feel about that.
12:30:26 <kmc> (even though I use C all the time, even acknowledging that other languages have benefits is enough)
12:30:33 <kmc> not in #haskell no
12:30:43 <cheater_> docstrings are the one single reason why i decided to learn python
12:30:44 <monochrom> please propose docstrings to the haskell committees. maybe haskell 2058 will have docstrings
12:30:50 <mauke> cheater_: well, don't prototype in an interpreter then
12:30:51 <kmc> and yes somehow i doubt many of the C macho assholes are female
12:30:54 <cheater_> why not mauke
12:30:57 <cheater_> what's wrong with that
12:31:03 <EvanR> kmc: i know at least one. in ##c
12:31:05 <kmc> cheater_, Haddock?
12:31:10 <EvanR> shes a real bitch ;)
12:31:15 <cheater_> i should be prototyping in haddock?
12:31:18 <cheater_> what does that mean?
12:31:36 <mauke> no, you should be using the documentation provided by haddock
12:31:40 <mokus> ":t" gives me 80% of the documentation I need, usually, and it's never out of sync with the implementation
12:31:58 <mokus> haddock gives the rest, and yea - it'd be very nice to have haddock in ghci
12:32:01 <cheater_> :t gives you the documentation only if you're using dead-simple functions
12:32:02 <lambdabot> parse error on input `if'
12:32:13 <djahandarie> cheater_, types can be fairly expressive.
12:32:20 <cheater_> types are types.
12:32:28 <cheater_> they're not actually doing anything.
12:32:34 <EvanR> neither are functions
12:32:38 <mauke> cheater_: I'd disagree with that
12:32:41 <houeland_> (I've found that a lot of libraries aren't documented much beyond :t)
12:32:42 <djahandarie> With GADTs and type families you can encode a lot of what you're actually 'doing' in the type system.
12:32:42 <cheater_> they just tell you what things are not being done
12:32:49 <monochrom> haskell 2058 will have docstrings
12:33:03 <EvanR> Parser Foo <- expressive ;)
12:33:24 <kmc> it's not that they don't do anything, it's that the *do nothing*
12:33:41 <monochrom> but I do wonder if by 2058 people will still stick to ghci in a dumb terminal
12:34:10 <cheater_> well people have been using terminals for the last, what, 50 years
12:34:14 <EvanR> i was thinking about security verification of the computer recently
12:34:36 <EvanR> and came to the conclusion that its possible to build a dumb terminal, but not much more, in such a way that you can physically verify its security
12:34:51 <EvanR> work continues
12:35:02 <EvanR> if youre the CIA please hire me
12:35:10 <kmc> yeah, you can build a dumb terminal using only discrete analog components
12:35:13 <monochrom> java people don't brag or beg for "docstring" a la python because whatever is in javadoc is already easily shown in their IDEs in super-convenient ways, e.g., mouse-over and in a side panel
12:35:21 <kmc> though you might have to hand-roll your capacitors to be sure
12:35:27 <EvanR> lol
12:35:28 <djahandarie> CIA here, you've been put on the national terrorist watch list
12:35:31 <cheater_> yeah, ides can kiss my butt
12:35:39 <kmc> anything more is trouble
12:35:44 <EvanR> djahandarie: ive been there for several months now due to bitcoins
12:35:47 <monochrom> in principle the same can be said about haddock
12:36:00 <kmc> easy to make something that looks like a TO-92 transistor but actually takes secret government commands
12:36:27 <kmc> some bitcoin guy gave a talk at the CIA
12:36:27 <EvanR> kmc: to do what, show lude ascii art on your screen? xD
12:36:34 <EvanR> yeah, gavin
12:36:37 <kmc> or steal ur keystrokes
12:36:40 <EvanR> we havent heard from him since
12:36:52 <EvanR> j/k
12:37:10 <cheater_> mauke, i know that when i was working on web stuff, php has extensive documentation online, with comments and stuff, but the python docs are still a thousand times better, because they're right there
12:37:22 <cheater_> and that was so much better
12:37:38 <mauke> php's online documentation sucks
12:37:52 <EvanR> kmc: you should be able to spot side channels on your wire with an oscilliscope
12:37:54 <dpratt71> let me try to make a bad analogy: Haskell could require exhaustive patterns, but it appears to have made a trade-off of convenience and brevity over safety; I feel that same trade-off could be made in the case of expressions involving ints and floating points
12:37:55 <monochrom> I agree, "right there" is best
12:37:56 <cheater_> well, it was as fast as online documentation could be
12:38:15 <cheater_> but it's a fact that anything related to php sucks butt
12:38:25 <monochrom> this is why I bring up the java people because they also have their docs "right there".
12:38:29 <mauke> dpratt71: what's the point?
12:38:35 <monochrom> where "there" is IDE not dumb terminal
12:38:52 <EvanR> cheater_: considering ive been doing php for money for a few years now, i can say that the php extensive documentation does more harm than good usually
12:38:56 <EvanR> compared to haskell docs
12:38:56 <mauke> cheater_: ok, how would you actually implement this in haskell?
12:39:22 <cheater_> monochrom, right there, just right after those 100 megabytes of libraries load.. wait let me right click.. ok let's wait for the context menu to pop up. it's right there! just right after it pops up
12:39:50 * EvanR waits for php doc site to not be down
12:39:54 <cheater_> mauke, how would i know? i know how i would like to be able to *use* it
12:40:10 <mauke> cheater_: and how would you use it?
12:40:19 <monochrom> the whole idea of "I type in :help fmap into the terminal and it scrolls up fmap's doc" is bunk because next you try a few examples and the doc is scrolled out of sight
12:40:41 <kmc> i would like "i type :help fmap and it opens haddock in the nearest browser"
12:40:50 <kmc> this is probably a one-day hack
12:40:53 <monochrom> whereas in a java IDE one panel keeps the doc shown and another panel has your trials and tests
12:41:01 <mokus> monochrom: the same argument applies to :type and :info, but they are still useful
12:41:05 <kmc> :i will give you the originating module name, then you can construct the haddock url
12:41:17 <dpratt71> mauke: what's the point of what, exactly?
12:41:20 <kmc> i already have an xmonad shortcut to take me to a hackage package
12:41:24 <EvanR> monochrom: nah. once you see the doc once, its burned permanently into your brain
12:41:25 <cheater_> mauke, i would expect a function's source code to be able to contain a comment string, e.g. the first comment in the body of the function, and then in the interpreter i could do :help stuff or help(stuff)
12:41:34 <mauke> dpratt71: implicit conversions between integers and floats
12:41:49 <EvanR> cheater_: exists
12:41:51 <cheater_> it would bring up the comment
12:41:52 <mauke> cheater_: what would the type of 'help' be?
12:42:02 <cheater_> mauke, no idea.
12:42:19 <cheater_> EvanR, wait, i just asked and everyone told me it doesn't. can you give me an example?
12:42:25 <mauke> cheater_: should help (id stuff) work?
12:42:30 <monochrom> mokus, I don't need the type of fmap for more than a few seconds, so yes. but I disagree with for example ":info Num", I need to keep re-reading it again and again for more than a few minutes while I concurrently write things
12:42:45 <EvanR> cheater_: the hackage packages all show that scraped content from the source code
12:42:49 <cheater_> mauke, nah, probably not
12:42:50 <EvanR> haddock
12:42:55 <mokus> monocrom: so ctrl-R hel<enter>
12:43:11 <cheater_> EvanR, we're talking in the interpreter
12:43:12 <mauke> cheater_: then I don't see the point of "docstrings"
12:43:14 <monochrom> well that scrolls away something else I need
12:43:18 <mauke> cheater_: this is just normal documentation
12:43:26 <cheater_> mauke, yes, it is.
12:43:33 <EvanR> cheater_: use the interpreter as an interpreter, use your browser as a colorful anti aliased doc fest
12:43:43 <mokus> monochrom: most haddock docs aren't more than 1 or 2 lines anyway, it's not like there's a whole lot to refer back to
12:44:00 <monochrom> I disagree
12:44:06 <cheater_> EvanR, please don't force non-text-mode on me, i can choose on my own
12:44:10 <dpratt71> mauke: I guess the point is less friction
12:44:13 <mokus> monochrom: and typically, when I pull up haddock it's to check a fairly small detail that wasnt in the type, such as order of 2 args that are the same type
12:44:21 <EvanR> cheater_: you can disable your style sheets
12:44:30 <EvanR> just because its not integrated doesnt make it useless
12:44:31 <monochrom> properly written docs for haskell lib things are each at least 5 lines
12:44:32 <mauke> dpratt71: why is that a good thing?
12:44:42 <mokus> monochrom: sure, :help doesn't get you everything a separate window/panel gets you, but that doesn't mean it's not at all useful
12:45:11 <Saizan> :! hoogle --info foo
12:45:23 <dpratt71> mauke: it isn't in all cases; in other languages that I use regularly, this friction doesn't exist and I don't miss it
12:45:51 <cheater_> monochrom, just because you don't understand why others like something doesn't mean it's useless. after all i'm not asking people to remove haddock, i'm asking them to add something similar in the interpreter.
12:46:12 <EvanR> cheater_: you want people to provide two sets of docs?
12:46:13 <monochrom> I do understand
12:46:23 <cheater_> EvanR, who said two sets?
12:46:23 <mauke> EvanR: no, you can render haddock to plain text
12:46:28 <cheater_> why would there be two sets?
12:46:31 <EvanR> 'something similar in the interpreter'
12:46:36 <cheater_> also, you could use .lhs and stuff to render the help
12:46:42 <monochrom> I perfectly understand why others like something, such as 1970s terminals, too
12:46:47 <monochrom> @quote ray 1970s
12:46:48 <lambdabot> ray says: when you're dealing with programmers you are often dealing with people who voluntarily use 1970s terminals. they cannot be reasoned with
12:47:02 <cheater_> EvanR, that's not necessarily a second set
12:47:07 <cheater_> that's just a different medium.
12:47:11 <monochrom> yet this is still consisent with it being pretty useless
12:47:16 <EvanR> my screen in covered in xterms, half of which are in vm's
12:47:22 <mauke> heh. I use 1970s terminals because they haven't made anything better yet
12:47:29 <cheater_> monochrom, plz stop trolling
12:47:30 <monochrom> people like a lot of useless things, I understand perfectly
12:47:44 <kmc> cheater_, first sign of a troll is that they tell other people to stop trolling
12:47:50 <mauke> actually, I'd love better terminals
12:47:54 <monochrom> well you made a wrong accusation of me and I just refute
12:48:00 <mauke> something with graphics integration and without "escape sequences"
12:48:01 <kmc> using a terminal is not a throwback to 1970 AD, it's a throwback to 4000 BC
12:48:03 <cheater_> kmc, i remember monochrom telling me that a few months back
12:48:08 <kmc> perhaps this makes it clearer why it's actually a good idea
12:48:11 <EvanR> mauke: ive designed a few ... what sort of features are you thinking of?
12:48:12 <cheater_> mauke, and rgb colors?
12:48:20 <djahandarie> I would like better terminals too, I don't think I've seen anyone actually even try to improve them.
12:48:32 <kmc> GUIs are point-and-grunt
12:48:32 <cheater_> mauke, rgb colors would be really nice to have.
12:48:43 <kmc> which is more advanced, point-and-grunt or the written word?
12:48:58 <EvanR> more colors doesnt sound very much more advanced than current technology
12:49:02 <EvanR> lol
12:49:06 <cheater_> kmc, i like that analogy
12:49:24 <kmc> also i think we slice these things the wrong way
12:49:28 <cheater_> EvanR, xterm doesn't have all possible colors
12:49:28 <EvanR> manatee has revolutionized the gui, and no one noticed ;)
12:49:32 <kmc> text input, gui output
12:49:38 <kmc> is really the way to go
12:49:44 <kmc> but few programs do this right
12:49:46 <EvanR> cheater_: number of colors has got to be the least significant complaint about terms
12:49:48 * djahandarie agrees with kmc
12:49:51 <cheater_> i hate guis because they're invariably slow and klunky
12:49:56 <ion> http://acko.net/blog/on-termkit
12:49:57 <cheater_> and i can't use them over ssh
12:49:59 <kmc> somehow if you want to display pictures this also means you should require the user to meander over a field of buttons instead of just saying what they want
12:50:37 <kmc> cheater_, ssh -X ?
12:50:44 <EvanR> latin letters are slow and klunky
12:50:48 <cheater_> kmc, never
12:51:03 <kmc> a big problem with X in general is that it has no analogue of 'screen'
12:51:08 <cheater_> much rather rip my spleen out
12:51:16 <djahandarie> ion, that is damn cool.
12:51:17 <kmc> though a lot of things effectively give you this
12:51:19 <cheater_> yea among other things
12:51:24 <kmc> you can use VNC this way
12:53:10 <cheater_> i hate graphics, browsers, etc because they're superslow compared to things in my terminal
12:53:29 <EvanR> kmc: i agree
12:53:38 <EvanR> kmc: but you do need a mouse for paint ;)
12:53:50 <cheater_> even if my ping to the server is 500 msec, and i can't see the output of what i'm typing, the terminal is still magnitudes more responsive than anything graphical ever
12:56:14 <mauke> have you ever played a computer game?
12:56:29 <cheater_> EvanR, i think you mean Sketchpad
12:56:32 <monochrom> perhaps nethack
12:56:39 <cheater_> mauke, you mean ADVENT ?
12:56:41 <kmc> EvanR, right, it just seems like the mouse should be specialized input in the same sense as an arcade controller or a microphone
12:56:43 <mokus> hunt the wumpus!
12:56:46 <kmc> or a drawing tablet
12:56:54 <cheater_> i also played Zork, Zork II and Zork III
12:56:54 <kmc> (in fact, it's unclear that a drawing tablet is not strictly superior)
12:57:00 <EvanR> zork was the shit
12:57:10 <kmc> (i know some people who use one as their primary pointing device, for ergonomic reasons)
12:57:32 <EvanR> kmc: well, i dont know if you paint, but for pixel painting you need to know where the pixel will appear before you press down
12:57:42 <EvanR> and holding buttons while painting is annoying
12:57:48 <EvanR> (even on a mouse)
12:57:55 <cheater_> that's why tablets have separate buttons on the side
12:58:01 <EvanR> and holding buttons while painting is annoying
12:58:02 <kmc> and pressure sensing
12:58:20 <luite> hmm, I think a tablet is more useful for freehand painting than pixel coloring
12:58:27 <EvanR> right
12:58:43 <EvanR> you need keyboard and mouse for that sort of painting
12:58:51 <mokus> most tablets also track the pen with the cursor when the pen is near but not touching the tablet
12:58:58 <luite> at least I always switch to tablet when I do the former, but almost never for doing things like small icons and other pixel thingies
13:01:11 <EvanR> left click right click for two colors is great
13:01:29 <EvanR> control click to color pick
13:01:33 <luite> hmm, which program has that?
13:01:39 <EvanR> good question
13:01:45 <EvanR> i havent found a good paint program
13:01:52 <EvanR> gimp is really bad
13:02:11 <luite> I always use x to switch foreground and background
13:02:30 <EvanR> yes, but in gimp the right click context menu is useless
13:02:45 <EvanR> also it sucks for low color management
13:02:54 <EvanR> they are even deleting support for indexed color mode
13:03:07 <luite> this is in photoshop by the way, I don't really know how to use gimp, I only use it for converting some obscure graphics formats that photoshop can't handle
13:03:22 <EvanR> thats the same shortcut in gimp i think
13:03:39 <EvanR> (for converting images use imagemagick)
13:04:05 <luite> I always have one hand on the keyboard and the other on the mouse/stylus, seems to work ok
13:05:21 <pedro3005> @src repeat
13:05:22 <lambdabot> repeat x = xs where xs = x : xs
13:05:24 <EvanR> using both mouse buttons really helps, not just in paint
13:06:23 <luite> EvanR: I'm quite happy having the right mouse button a context menu for tool settings
13:06:33 <EvanR> lol settings
13:06:37 <ion> > fix (x:)
13:06:39 <lambdabot>   [x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,...
13:06:54 <luite> EvanR: err? don't you ever change them?
13:07:04 <EvanR> not on a pixel-by-pixel basis
13:07:05 <luite> for things like brush size, shape, hardness
13:07:16 <luite> oh right, you're still talking about pixel stuff
13:07:17 <EvanR> no i cant paint for real
13:07:47 <luite> me neither ;p
13:18:06 <gwern> > (30 / 800) * 100
13:18:07 <lambdabot>   3.75
13:19:21 <pedro3005> hmm
13:19:29 <pedro3005> I could swear there used to be a Matrix module
13:19:49 <kmc> in the standard lib?
13:20:01 <pedro3005> well, not sure
13:20:02 <mwc> Is there any plan to add some sort of autoconf like functionality to Cabal? What's the recommended way to set a flag based on the presense of some function in shared lib/DLL?
13:21:34 <monochrom> there are several Matrix modules on hackage
13:22:54 <pedro3005> I think it used @@> to extract a specific element
13:22:59 <pedro3005> anyone remember what that was?
13:23:20 <joe6> any thoughts on making this better, please? http://pastebin.com/jSyGBSvz
13:23:23 <mauke> The paste jSyGBSvz has been copied to http://hpaste.org/49236
13:23:44 <EvanR> joe6: gonna go out on a limb and say Aeson
13:26:20 <Chat7664>  (b)
13:26:50 <joe6> EvanR, let me try Aeson, now.
13:27:10 <joe6> EvanR, now that I have a hang on what is happening, let me make it better, as you say.
13:28:17 <pedro3005> oh this thing just vanished from the internet
13:38:07 * hackagebot vector-strategies 0.2 - A parallel evaluation strategy for boxed vectors  http://hackage.haskell.org/package/vector-strategies-0.2 (ThomasDuBuisson)
13:39:10 <elchileno2060> hi guys
13:41:31 <kmc> hi elchileno2060
13:59:55 <gwern> more hawiki spam!
14:00:56 <benmachine> gasp
14:03:33 <joe6> EvanR: using json: http://pastebin.com/zyuz4rec , using Aeson: http://pastebin.com/Lp8rYwvH, and I am still just able to parse the runner and not the runners array.
14:03:37 <mauke> The pastes zyuz4rec Lp8rYwvH have been copied to http://hpaste.org/49237 http://hpaste.org/49238
14:04:37 <joe6> usage of the aeson parseAll: http://pastebin.com/VEJXei4t
14:04:38 <mauke> The paste VEJXei4t has been copied to http://hpaste.org/49239
14:04:46 <mauke> joe6: did you get my script?
14:07:34 <joe6> EvanR, this ? uri: http://codepad.org/vH7Q8TCd
14:07:47 <joe6> i can parse the runner
14:08:14 <joe6> but, it is a lot more code, than doing it the json way.
14:08:21 <joe6> with aeson, I mean.
14:08:37 <bobzhang> hi, is there anyway to control the maximum_depth of recursive data generated by quickCheck?
14:08:58 <FUZxxl> ofo
14:09:01 <bobzhang> like data A =  A [A] | String
14:10:30 <joe6> applicative: the libstdc++ error is due to the libstdc++.so . What I do when that happens is to "sudo stow llvm-gcc-4.2" and when cabal fails as it looks for the other libstdc++, I just remove it using sudo stow -D llvm-gcc-4.2
14:10:39 <c_wraith> bobzhang: nothing built in.  you just need to build the recursive data types less naively.
14:10:50 <EvanR> joe6: you can also do this
14:10:51 <joe6> applicative, sucks, I know. but, that is the only way to get them to work.
14:11:16 <joe6> applicative, I think with the coming version of llvm, it does not have the libstdc++ file.
14:11:26 <EvanR> parseRunner obj = Runner <$> obj .: "id" <*> obj .: "market" <*> obj .: "name"
14:11:28 <joe6> applicative, until then, I guess this is the workaround.
14:11:57 <joe6> EvanR, let me try that.
14:12:22 <ion> bobzhang: instance Arbitrary Foo where { arbitrary = sized (\n -> arb (min n 3)) where { arb :: Int -> Gen Foo; arb (pred -> depth) | depth >= 0 = somethingRecursive depth | otherwise = somethingNonRecursive } }
14:12:45 <ion> bobzhang: Where the somethingRecursive refers to arb n instead of arbitrary.
14:13:18 <bobzhang> ion: thank you, let me have a try
14:13:38 <joe6> EvanR, how do i use it.
14:13:47 <joe6> EvanR, sorry, if you had said that befor.
14:13:52 <joe6> s/befor/before/
14:13:56 <EvanR> use it?
14:14:08 <EvanR> look at all the methods in that module
14:14:11 <EvanR> one of them is parse
14:14:16 <EvanR> perhaps use that
14:14:29 <EvanR> i suggested also to use that function as a base for FromJSON instance
14:14:32 <bobzhang> ion: what's foo?
14:14:48 <ion> bobzhang: Your type, for which you’re writing the Arbitrary instance.
14:15:37 <joe6> EvanR, like this:
14:15:39 <joe6> instance FromJSON JsonRunner where parseJSON = parseRunner
14:15:47 <EvanR> almost
14:15:50 <ion> bobzhang: “A” in your example. somethingRecursive would generate both As and Strings and somethingNonRecursive would only generate Strings.
14:16:19 <ion> bobzhang: The “3” is the limit on recursion.
14:16:34 <EvanR> parseJSON (Object obj) = parseRunner obj
14:16:43 <EvanR> parseJSON _ = mzero
14:19:23 <Fuco> I can't remember what's the function to use instead of - in operator section, anybody? :P
14:19:23 <joe6> EvanR, got the runner working
14:19:38 <joe6> EvanR, now I am trying to figure out the runners: http://pastebin.com/4AjBtTas
14:19:38 <Fuco> minus and subtract doesn't work heh
14:19:40 <mauke> The paste 4AjBtTas has been copied to http://hpaste.org/49240
14:19:45 <ion> bobzhang: As for shrink, you’ll probably want something like shrink (A _) = String ""; shrink (String s) = String <$> shrink s
14:19:46 <parcs> Fuco: negate
14:20:10 <Fuco> parcs, will that subract the numbers tho? I want something like (-1) 2 to return 1
14:20:14 <mauke> joe6: hello?
14:20:23 <joe6> mauke, yes
14:21:03 <ion> (-1) is negate 1, for (\n -> n - 1) use subtract 1.
14:21:29 <EvanR> joe6: i wish youd stop speaking in pastebins
14:21:36 <joe6> EvanR, not that I do not want to learn. but, the json interface is a lot simpler than the aeson interface.
14:21:54 <joe6> EvanR, need to fight one battle at a time.
14:22:10 <joe6> EvanR, let me finish up the aeson and then I fight the hpaste battle.
14:22:25 <EvanR> im not telling you paste somewhere else
14:22:36 <EvanR> im telling you to explain what you mean / want in words rather than loads of wrong code
14:22:46 <joe6> EvanR, ok, not paste that much.
14:22:58 <joe6> EvanR, oh, ok. thanks.
14:23:27 <bla123> Which package should I choose? iteratee or enumerator?
14:23:29 <joe6> EvanR, need to step out for some time. I will continue on the quest later.
14:24:22 <shapr> @yow
14:24:23 <lambdabot> Couldn't find fortune file
14:24:41 <bobzhang> ion: would you plz show somethingRecursive or NotRecursive?
14:24:45 <bobzhang> it seems not work
14:25:07 <bobzhang> data A = A[A] |B String deriving Show
14:26:20 <bobzhang> besides, i wanna the length of [A] is not too short
14:26:44 <Peaker> bobzhang: data Tree = Branch { children :: [Tree] }  |  Tip         ---  A tree with no contents
14:26:58 <Peaker> bobzhang: (your data type with slightly more suggestive names)
14:27:30 <bobzhang> Peaker: then?
14:27:43 <Peaker> bobzhang: then what? What's your question?
14:27:57 <kmc> :k Mu []
14:27:58 <lambdabot> *
14:28:07 <bobzhang> i wanna generate the data using quckcheck with a limit on the depth, but not on the width
14:28:13 <kmc> > In [In [], In [ In [] ]]
14:28:15 <lambdabot>   In [In [],In [In []]]
14:28:17 <ion> bobzhang: arb (pred -> depth) | depth >= 0 = frequency [ (1, A <$> arb depth), (2, B <$> arbitrary) ] | otherwise = B <$> arbitrary
14:28:28 <Peaker> kmc: isn't it  Mu (Maybe :. [])  ?
14:28:40 <kmc> i'm just playing
14:29:19 <kmc> > let z = In []; s n = In [n, In [n]] in iterate s z
14:29:21 <lambdabot>   [In [],In [In [],In [In []]],In [In [In [],In [In []]],In [In [In [],In [In...
14:29:59 <Peaker> bobzhang: if you don't limit the width -- how do you want it to go deeper? First go deep, then go wide?
14:30:14 <kmc> > let z = []; s n = In n : n in iterate s z
14:30:16 <lambdabot>   [[],[In []],[In [In []],In []],[In [In [In []],In []],In [In []],In []],[In...
14:31:01 <kmc> @pl s n = In n : n
14:31:02 <lambdabot> s = (:) =<< In
14:31:21 <finnomenon> did any of you start out with "an introduction to functional programming through lambda calculus" ?
14:31:41 <kmc> @let ω = iterate (In >>= (:)) []
14:31:43 <lambdabot>  Defined.
14:31:45 <kmc> > ω
14:31:47 <lambdabot>   [[],[In []],[In [In []],In []],[In [In [In []],In []],In [In []],In []],[In...
14:31:57 <bobzhang> ion: it does not type check
14:32:09 <kmc> > ω !! 5
14:32:11 <lambdabot>   [In [In [In [In [In []],In []],In [In []],In []],In [In [In []],In []],In [...
14:32:27 <bobzhang> Peaker: i wanna a flat tree
14:33:13 <cmccann> finnomenon, why do you ask?
14:33:30 <finnomenon> I was thinking about it being my introduction to functional programming book
14:33:52 <finnomenon> that or "learn you a haskell" would be my choices so far
14:34:07 <Peaker> bobzhang: then make all the trees in your A be B's
14:34:28 <Peaker> bobzhang: a depth0 (completely flat) tree is just a B.  A depth1 is an A with a list of B's in it
14:34:34 <Peaker> bobzhang: is this what you're after?
14:34:57 <Peaker> bobzhang: A (replicate 10000 B)
14:35:11 <kmc> finnomenon, learning FP is a quite different goal from learning Haskell
14:35:18 <kmc> finnomenon, Haskell is not a simple or typical functional language
14:35:32 * cmccann was about to say what kmc just said
14:35:51 <kmc> for many people learning Haskell means learning about FP, static types that don't suck, lazy evaluation, higher-order polymorphism, and a pile of other stuff all at once
14:35:58 <Nimatek> kmc: It is the functional language though nowdays.
14:36:05 <kmc> Nimatek, no, Javascript is the functional language
14:36:07 <accel> what people don't realize about learning ahskell
14:36:11 <bobzhang> Peaker: right, a little randomize
14:36:11 <Nimatek> Heh.
14:36:14 <accel> is that you're supposed ot read Serge Lang's Algebra first
14:36:17 <accel> to understand the thoery behind it
14:36:20 <kmc> haha
14:36:20 <Peaker> kmc: Javascript isn't very functional, with its horrid "this" stuff
14:36:25 <ion> bobzhang: Ah, forgot about the list. I’ll paste something, a moment.
14:36:30 <cmccann> kmc, the book finnomenon mentions does covered typed lambda calculi looks like
14:36:39 <kmc> Peaker, right, well in #haskell no other language is "functional enough"
14:36:48 <c_wraith> agda is!
14:36:49 <Peaker> kmc: Agda is fine :-)
14:36:53 <cmccann> heh
14:37:05 <kmc> people in #haskell have a tendency to define "functional language" as "any language which is exactly like Haskell in every way"
14:37:18 <kmc> i've heard people argue that static types and laziness are essential to the meaning of "functional"!
14:37:25 <olsner_> kmc: everything else is dysfunctional :D
14:37:29 <kmc> yep
14:37:37 <cmccann> kmc, I'd say they mostly tend to define it as languages that are essentially a pure typed lambda calculus
14:37:37 <Peaker> There's the "denotative" definition
14:37:45 <cmccann> which incidentally rules out most everything else, yes
14:38:05 <bobzhang> ion: thank you
14:38:21 <kmc> anyway Haskell is the poster child for FP for unknown reasons
14:38:40 <Peaker> well, it's a *nice* functional language.. I don't know many of those :)
14:38:48 <cmccann> finnomenon, anyway now that the channel has launched into a discussion of what constitutes functional programming, that book is probably better for a general intro to FP
14:38:54 <kmc> people hear it's "pure functional" and think that means it's the best place to start
14:38:58 <cmccann> whereas LYAH is, surprisingly, a better intro to Haskell
14:39:26 <finnomenon> would you recommend reading it first and then moving on to lyah?
14:39:39 <finnomenon> or going directly to lyah?
14:39:39 <kmc> maybe someone should write a Haskell tutorial that actually starts out with imperative programming
14:39:52 <kmc> hello world, what is your name
14:39:56 <kmc> sorting a file
14:40:17 <kmc> go light on the ideology and present IO as just another tool in the toolbox
14:40:21 <shachaf> kmc: YAHT kind of did that, and I seem to remember that it was terribly confusing.
14:40:25 <kmc> probably
14:40:33 <kmc> not many people recommend YAHT now, i have not read it and i don't know why
14:40:44 * shachaf does not tend to recommend it.
14:40:55 <dainanaki> Back in my day, we had to read YAHT to learn Haskell!
14:41:03 <kmc> back in my day we had to read the gentle introduction
14:41:12 <dainanaki> That too.
14:41:21 <shachaf> Back in my day we had to learn Miranda to learn Haskell.
14:41:21 <smop> what is yaht
14:41:22 <kmc> "If this is the Gentle Introduction, I imagine the Difficult Introduction dispatches a team of ninjas to smack me across the head"
14:41:26 <kmc> @where YAHT
14:41:27 <lambdabot> "Yet Another Haskell Tutorial", Hal Daume III, <http://www.cs.utah.edu/~hal/htut/>,<http://en.wikibooks.org/wiki/Haskell/YAHT>,<http://darcs.haskell.org/yaht/yaht.pdf>
14:41:38 <dainanaki> Actually, that's what I meant in the first place, the gentle introduction
14:41:46 <kmc> maybe my tutorial should be called OFNAHT
14:42:34 <dainanaki> I've been working on one I'm tentatively calling CTHULHU.
14:43:08 <smop> oic
14:43:18 <smop> i've been working through lyah and rwh
14:43:23 <smop> i guess i'll add this one to the list too
14:43:37 <kmc> smop, in general it is not as well regarded
14:43:42 <smop> oh good
14:43:43 <kmc> i don't know why
14:43:44 <burbul> What's the easiest way to memoise a f :: A -> B, where A is a member of Ord?
14:44:02 <kmc> burbul, do you not have any other structure on A?
14:44:23 <kmc> data-memocombinators has bits :: (Ord a, Bits a) => Memo a
14:44:27 <burbul> no; I could define a hash function on it, but it would be a lot of work
14:44:57 <kmc> are there tons of possible "A" values?
14:45:13 <b_jonas> burbul: balanced trees work on any Ord and there are nice ones defined in the libraries
14:45:19 <kmc> yeah Data.Map
14:45:20 <b_jonas> search trees that is
14:45:20 <burbul> It's something like a datatype of trees
14:45:26 <b_jonas> yes, Data.Map or similar
14:45:29 <kmc> and it's basically memoized, because the values at the leaves can be thunks
14:45:36 <kmc> unevaluated
14:45:44 <acowley> Modules like this are remarkably frustrating: http://hackage.haskell.org/packages/archive/gnuplot/0.4.2/doc/html/Graphics-Gnuplot-Graph-TwoDimensional.html
14:45:45 <burbul> I looked at Data.Map, but I couldn't see which constructor to use...
14:45:46 <kmc> but you'll still end up evaluating the tree structure ahead of time
14:46:00 <kmc> burbul, it doesn't export its data constructors
14:46:06 <c_wraith> yeah, Data.Map is unfortunately strict for this use case
14:46:08 <kmc> you build maps with fromList, singleton, union, etc.
14:46:15 <hpaste> ion pasted “limited recursive Arbitrary” at http://hpaste.org/49241
14:46:22 <kmc> you might have to resort to functional state-passing or "actual" state
14:46:22 <copumpkin> acowley: yeah
14:46:26 <kmc> with the state a Data.Map
14:46:44 <ion> bobzhang: See above. Try sample (arbitrary :: Gen Foo) in ghci.
14:46:45 <burbul> ah... that's a little messy because A has infinitely many members. I suppose I can pass an infinite list to fromList...
14:46:47 <b_jonas> oh wait
14:46:52 <b_jonas> so is your function pure or impure?
14:46:53 <kmc> burbul, it won't work right
14:46:54 <copumpkin> acowley: note that without knowing anything about that package, I can tell who wrote it
14:46:58 <acowley> No text, just T and C everywhere. It feels intentionally cruel.
14:47:02 <acowley> copumpkin: I know it's his thing
14:47:07 <burbul> pure. (How do you write an impure function in Haskell?)
14:47:09 <acowley> I just don't get it at all
14:47:10 <kmc> burbul, what's the use pattern for this function?  do you make a bunch of queries all at once?
14:47:16 <kmc> burbul, unsafePerformIO
14:47:22 <b_jonas> with State or something
14:47:26 <burbul> ah
14:47:26 <b_jonas> you make an impure version of it
14:47:27 <kmc> no no no no no no
14:47:31 <kmc> "State" is not impure at all
14:47:36 <b_jonas> which inserts stuff to a map
14:47:39 <kmc> (State s a) is just a thin wrapper on (s -> (a, s))
14:47:46 <kmc> i think b_jonas was probably asking "does your function return IO actions"
14:47:49 <b_jonas> and call the function only statefully
14:47:49 <acowley> I age a year everytime I use the library. But, to his credit, he included an extensive demo of various functionality.
14:48:03 <c_wraith> I've had someone tell me he used one of my packages with an unsafePerformIO hack to implement IO-based memoization.  That was kind of wacky.
14:48:03 <b_jonas> kmc: yes, something like that, only it's not IO but some other monad stuff
14:48:04 <burbul> The datatype A in fact represent a packed forest of parse trees (using structural sharing, so you have something a little like a dag).
14:48:10 <kmc> b_jonas, but monads in general are not "impure"
14:48:18 <burbul> The function I'm writing filters this forest by removing any trees which have subtrees of a particular shape
14:48:20 <b_jonas> sure, it depends on how you call the function
14:48:21 <kmc> a monad is any type which happens to implement a certain generic API
14:48:22 <burbul> It's intrinsically recursive
14:48:38 <b_jonas> if you call it state-like so it always gets the state from all previous calls
14:48:41 <kmc> burbul, one suggestion is to use Data.Map inside STRef
14:48:51 <b_jonas> then you can have it insert stuff to the map
14:48:54 <kmc> then you can have real mutable state locally
14:49:01 <burbul> So (because of the structural sharing) you will end up applying a particular filter to multiple isomorphic subtrees
14:49:07 <burbul> Does that make sense?
14:49:24 <kmc> and you still have the ability to execute in a "closed universe" and get back a simple result value
14:49:32 <burbul> yes
14:49:46 <burbul> The whole thing looks like
14:49:47 <burbul> apply_filter :: Filter -> PackedForest -> PackedForest
14:50:08 <burbul> I'm just looking up STRef. (Am very new to Haskell)
14:50:26 <kmc> burbul, oh, they are like IORef (which you can also read about)
14:50:40 <kmc> IORefs are mutable cells you can read or update with an IO action
14:50:54 <burbul> oh, I see. this is the thing that lets you more or less write a stateful algorithm but extract a pure function at the end of the day
14:50:54 <kmc> STRefs are similar except you use ST actions, which are more restricted (you can't do actual IO, for example)
14:50:59 <kmc> yes
14:51:19 <b_jonas> burbul: exactly
14:51:21 <c_wraith> ST is special because it uses actual mutation behind the scenes.
14:51:21 <kmc> and unlike "State", your stateful algorithm runs with real in-place state updates
14:51:29 <kmc> you get the actual same performance as IORef
14:51:41 <kmc> in fact the way GHC implements them, there is no difference between IORef and STRef at runtime
14:51:50 <kmc> the safety checking is entirely at compile time
14:52:02 <b_jonas> but they're guaranteed to be pure, which is achieved by some nice type magic
14:52:04 <burbul> Hmmm... isn't there some way of using a lazy infinite structure that memorises all possible values of the function, without using STRef?
14:52:17 <hpaste> ion annotated “limited recursive Arbitrary” with “Better shrink” at http://hpaste.org/49241#a49242
14:52:24 <burbul> [So e.g. if I had a function Int -> X, I could memoise it using a list]
14:52:26 <kmc> burbul, yes, that's what data-memocombinators and MemoTrie do
14:52:28 <c_wraith> yes, there is.  But we don't have those handily available.
14:52:30 <b_jonas> burbul: there may be, depending on what keys you have
14:52:31 <burbul> Some sort of lazy infinite tree?
14:52:36 <kmc> but it's hard to do with arbitrary Ord
14:52:41 <kmc> your tree might get unbalanced
14:52:44 <burbul> c_wraith: meaning no one has written such a thing yet?
14:52:55 <kmc> if you actually have a priori ordering knowledge, it might be workable
14:52:59 <jonkri> can someone please tell me what's going on with b1 in http://hackage.haskell.org/packages/archive/stringprep/0.1.4/doc/html/src/Text-StringPrep.html#b1 ?
14:53:04 <burbul> kmc -- ah, I see the problem
14:53:18 <c_wraith> burbul: it's *really* hard to see how to do it with *only* an Ord constraint.
14:53:28 <burbul> What kind of constraints do you need ?
14:53:31 <jonkri> how can it be of type Map and still take an argument?
14:53:33 <jonkri> and how is it a Map? :)
14:53:37 <c_wraith> MemoTrie gets by by on Bits
14:53:45 <kmc> jonkri, type Map = Char -> Text
14:53:48 <kmc> look up 2 lines
14:53:53 <jonkri> zomg
14:53:55 <burbul> I'm just looking up Bits...
14:53:56 <jonkri> i was thinking it was Data.Map
14:53:57 <jonkri> thanks
14:54:07 <kmc> right, that's why it's a trie
14:54:57 <kmc> you could build an Ord-based memoizer with, say, Data.MemoCombinators.switch
14:55:08 <kmc> but in the worst case your performance would be no better than an assoc list
14:55:11 <kmc> (which might be okay!)
14:55:24 <burbul> no, once you pointed out the thing about trees becoming unbalanced (because rebalancing is stateful) I became unhappy with that approach
14:55:32 <burbul> Worst-case performance: exactly
14:55:49 <kmc> i mean, you're still saving the cost of recomputing the function
14:55:54 <burbul> yes
14:56:15 <kmc> i wonder if someone should just write an Ord-generic memoizer that uses backdoor state tricks like unsafePerformIO and presents a clean pure API
14:56:25 <burbul> But I think I'm going to look for something that is that most O(log n). I'm actually porting Python code which is O(1).
14:56:32 <b_jonas> it's not just that the tree can be unbalanced, also Ord isn't enough because you also have to be able to choose a new key between two keys (in such a way that every key occurs in finite depth)
14:56:35 <kmc> oh, Python's dict has O(1) lookups does it?
14:56:38 <ion> Backdoor state tricks sound dirty.
14:56:40 <kmc> that would seem to contradict basic physics
14:56:41 <burbul> [ It's pretty easy there because Python has built-in hashing for just about everything.]
14:56:46 <kmc> hashes are not O(1)
14:56:50 <kmc> memory access is not O(1)
14:56:57 <kmc> if it were, we wouldn't need all this caching shit
14:57:00 <burbul> amortized O(1)
14:57:01 <c_wraith> ion: dirty like DiffArray. :)
14:57:16 <c_wraith> ion: and yes, DiffArray is plenty dirty.
14:57:18 <burbul> "memory access is not O(1)"  ?
14:57:18 <kmc> ah, yes, DiffArray
14:57:34 <monochrom> yeah, to be precise, you should say you're porting python code which is O(0.01 log n) and so you hope you can write O(0.1 log n) haskell code
14:57:38 <burbul> If you mean that a O(log n) algorithm might be faster than a O(1) one in practice, I'll agree with that.
14:57:47 <kmc> burbul, yep, you have O(log n) hardware to translate addresses etc
14:57:57 <kmc> actually DRAM structure is O(sqrt n) iirc
14:58:07 <EvanR> everything is O(1)
14:58:15 <kmc> caches exist because it's hard to make a bunch of RAM which is fast
14:58:16 <EvanR> just choose your constant appropriately
14:58:22 <kmc> so you make a little fast RAM and a lot of slow RAM
14:58:30 <kmc> this should indicate that it's not in fact O(1)
14:58:32 <burbul> caches: I know
14:58:50 <kmc> i mean this is also all "per unit cost"
14:58:51 <burbul> Where did you get the sqrt(n) figure from?
14:58:52 <EvanR> O(1) where the 1 = lag between you and the cloud
14:59:06 <kmc> O(l)
14:59:13 <kmc> burbul, as of whatever computer systems textbook i read whenever long ago, DRAM is organized into columns and rows
14:59:20 <burbul> I'm used to thinking of memory access as O(1) -- with a large constant if it's not cached, but still O(1)
14:59:24 <kmc> you load a column address and a row address
14:59:37 <kmc> burbul, right, but that's meaningless
14:59:44 <burbul> And loading a column address takes time proportional to the number of columns?
14:59:45 <EvanR> yes, no matter what column and row you choose lookup speed is the same
14:59:48 <kmc> "my algorithm is O(1), but the constant factor grows quadratically as the problem size increases"
14:59:57 <clsmith> lol
15:00:01 <ion> :-D
15:00:02 <dainanaki> hehehehe
15:00:18 <kmc> the moral of the story is that asymptotic complexity is just not a very good way to think about real machines, even in approximation
15:00:19 <cmccann> all algorithms are O(1) where 1 indicates the total time the computer is operating
15:00:21 <monochrom> if you are aware of large constants getting into the way, you stop using O(whatever).
15:00:28 <EvanR> its like a hashtable of a fixed size
15:00:32 <EvanR> with no collisions
15:00:33 <kmc> it's arguably worse than nothing.  it gives every CS sophomore an easy, wrong way to make decisions
15:00:39 <clsmith> big O is too often misunderstood. i keep having people tell me that it's okay to do something because it's O(logn). but the constant!
15:00:39 <kmc> "i must use a hash because hashing is O(1)"
15:00:48 * cmccann tends to assume that these days a lot of algorithms are basically O(cache misses)
15:00:53 <ion> @remember kmc "my algorithm is O(1), but the constant factor grows quadratically as the problem size increases"
15:00:54 <lambdabot> I will never forget.
15:01:09 <dainanaki> you better not
15:01:12 <burbul> I don't have a strong preference between hashing and balanced trees.
15:01:21 <shachaf> @forget kmc "my algorithm is O(1), but the constant factor grows quadratically as the problem size increases"
15:01:21 <lambdabot> Done.
15:01:22 <burbul> Hashing is very conveniently available in Python, so I use it.
15:01:22 <cmccann> hashing is harder to understand correctly
15:01:31 <shachaf> @remember kmc my algorithm is O(1), but the constant factor grows quadratically as the problem size increases
15:01:31 <lambdabot> Done.
15:01:41 <shachaf> Er.
15:01:43 <cmccann> it's a lot easier to shoot yourself in the foot with a hash table and not realize how or why
15:01:45 <monochrom> I think the numerical analysis people have the right balance between simplifying their statements and keeping it real. they say "4n^3 + O(n^2) multiplications". we should all do that
15:01:45 <shachaf> That was completely wrong.
15:01:53 <shachaf> @forget kmc my algorithm is O(1), but the constant factor grows quadratically as the problem size increases
15:01:53 <lambdabot> Done.
15:02:00 <shachaf> @remember kmc "my algorithm is O(1), but the constant factor grows quadratically as the problem size increases"
15:02:00 <lambdabot> I will remember.
15:02:10 <kmc> these days i quite favor hash tries
15:02:31 <kmc> ideally fat hash tries, not binary
15:02:31 <b_jonas> shachaf: you're late, ion ha already told that to lambdabot
15:02:31 <companion_cube> kmc: sounds interesting!
15:02:32 <clsmith> trees are basically a universal data structure. they can pretty much do *anything*.
15:02:48 <companion_cube> tries are a nice structure
15:03:10 <kmc> they have the nice properties of hash tables ("O(1)", few cache misses) and the nice properties of trees (persistence, lock-free concurrency)
15:03:34 <kmc> clsmith, it's often said that computer science is the study of boxes and arrows
15:03:35 <companion_cube> they must take few memory, right ?
15:03:37 * EvanR makes his pet data structure more popular by calling it something cutesy like dancing trees
15:03:43 <clsmith> kmc: lol
15:04:12 <clsmith> ofc, tries only work with list structures, whereas hashes work for anything
15:04:16 <cmccann> or you can be oleg, and implement all your data structures as knotted masses of inter-related delimited continuations
15:04:21 <clsmith> (but so do other trees)
15:04:32 <cmccann> tries work for anything that can be serialized uniquely
15:04:39 <companion_cube> hash-tries work for anything
15:04:41 <cmccann> which is a lot of things
15:04:44 <clsmith> ohhh i see, yeah
15:04:49 <dainanaki> oleg's code freaks me out.
15:04:57 <kmc> well, anything hashable
15:05:00 <shachaf> "twenty seven eight-by-ten colour glossy pictures with circles and arrows and a paragraph on the back of each one"
15:05:11 <clsmith> huh.. i'd not considered just hashing and using that for the trie. that's cool
15:05:12 <kmc> shachaf++
15:05:12 <companion_cube> that's as good as hashtables anyway
15:05:29 <companion_cube> clsmith: you too just read it for the first time and find it cool ? :)
15:05:41 <kmc> hash tries are Clojure's solution to concurrent mutable dicts
15:05:51 <kmc> and there's some recent work in good hash tries for Haskell
15:06:02 <kmc> Clojure's are 32-ary packed-node tries
15:06:11 <kmc> which is much better than the binary tries of e.g. Data.IntMap
15:06:15 <kmc> see also judy arrays
15:06:20 <kmc> and the extensive technical document about their design
15:06:31 <kmc> binary trees are popular but essentially terrible for cache performance
15:06:39 <burbul> Anyway -- for memoising, it looks like using the ST monad and Data.Map might be the way forward. Thanks for the advice!
15:06:50 <cmccann> judy arrays are an interesting study in strategically horrible code
15:07:11 <b_jonas> I for one think hashed tries can't ever be better than both balanced trees and hashes.
15:07:24 <kmc> i like that they lovingly cache-optimized it for PA-RISC and then everyone uses x86 and they're like "welp"
15:07:26 <kmc> but it's good enough
15:07:44 <cmccann> kmc, cache-oblivious algorithms and a data structures are the way to go
15:07:50 <kmc> i can believe that
15:07:53 <kmc> i really don't know enough about that field
15:08:23 <cmccann> kmc, mostly just amounts to designing things so that locality is scale-invariant to some degree
15:08:29 <kmc> b_jonas, you can't use a flat hash table concurrently without great pain
15:08:42 <kmc> or fork it into multiple versions, which is convenient outside concurrency, too
15:08:49 <cmccann> which is not really "mostly just" anything, which is why it's a research area
15:08:57 <kmc> right
15:09:00 <b_jonas> kmc: but can you use a trie concurrently more easily?
15:09:11 <kmc> b_jonas, yes, if it's immutable
15:09:20 <kmc> you copy the nodes from the root to the point you're modifying
15:09:23 * EvanR prefers to keep project definitely on one side or the other of 'almost too slow'
15:09:28 <b_jonas> if it's immutable you can also use a hash concurrently
15:09:31 <cmccann> but the end result is that you get passable, notably better-than-naive performance on any sort of hierarchical caching
15:09:36 <EvanR> so constant factor speed bosts dont matter ;)
15:10:08 <companion_cube> b_jonas: hashtables are not supposed to be immutable
15:10:11 <kmc> b_jonas, on a hash trie you can do a functional update (getting a new trie back) without much copying
15:10:19 <kmc> and then atomic pointer-swap that into a reference cell
15:10:27 <kmc> you can't do that on a flat hash table without copying the whole thing
15:10:37 <kmc> on a tree you only have to copy the nodes from the root to the point you modify
15:10:48 <EvanR> if youre think is becoming too slow, you did something wrong. rewriting in C++ or clojure shouldnt be your next strategy
15:10:50 <kmc> which is "O(log n)" for a balanced binary search tree and "O(1)" for a hash trie
15:11:06 <monochrom> there is only one pointer to atomic-swap. that is all of the critical section
15:11:12 <cmccann> kmc, there's also delayed copy-on-update trickery you can do behind the scenes with stuff but that's headache-inducing and easy to screw up
15:11:14 <kmc> monochrom, well, watch out for ABA problems
15:11:16 <kmc> but yes
15:11:17 <ion> Exactly what is a fat hash trie? The trie keys are n-bit chunks of the hash for some n?
15:11:28 <companion_cube> like patricia tries ?
15:11:32 <kmc> ion, yeah, picture a 32-ary tree with 5 bits of hash at each step
15:11:51 <kmc> ion, and Clojure uses some "Hacker's Delight" type tricks to store those nodes more efficiently (on average) than 32 words
15:11:52 <monochrom> fatter is better :)
15:11:55 <kmc> (which would blow out your cache)
15:12:05 <ion> alright
15:12:17 <monochrom> Hacker's Delight? is that some kind of jelly candy dessert? I want that!
15:12:26 <c_wraith> tibbe's work on porting these to haskell is going well, last I heard.
15:12:28 <kmc> most nodes do not have 32 children, so you can store a bitmap and only non-NULL words
15:12:29 * monochrom likes Turkish Delight and Greek Delight
15:12:33 <kmc> om nom
15:12:45 * ion likes Rapper’s Delight
15:12:47 <b_jonas> kmc: I see
15:12:48 * Clint likes loukom
15:13:09 <dainanaki> monochrom, No, don't join the White Queen of low-level programming!
15:13:44 <ion> kmc: Any implementations of that for Haskell?
15:13:46 <shachaf> preflex: seen ddarius
15:13:46 <preflex>  ddarius was last seen on #haskell 5 days, 17 hours, 10 minutes and 48 seconds ago, saying: @free beer
15:13:54 <kmc> tibbe is working on it i hear
15:13:54 <ion> @free beer
15:13:55 * shachaf wonders where he's gone.
15:13:55 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `beer'\n\n"
15:14:00 <c_wraith> ion: tibbe's working on it for a future version of unordered-containers
15:14:07 <b_jonas> yes, that could be useful for editors and such complicated things
15:14:07 <ion> c_wraith: Ok, cool.
15:14:15 <c_wraith> ion: but a proper implementation is waiting on a couple extra GHC primops being added. :)
15:14:19 <ion> heh
15:14:19 <b_jonas> but in that case I'd rather use a balanced tree than a trie
15:14:23 <dainanaki> it was a trap
15:14:23 <olsner> @free a
15:14:24 <lambdabot> a = a
15:14:32 <olsner> @free beer
15:14:32 <dainanaki> @free beer
15:14:33 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `beer'\n\n"
15:14:34 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `beer'\n\n"
15:14:46 <olsner> it only does single-letter type variables?
15:14:47 <monochrom> @let beer x = x
15:14:48 <lambdabot>  Defined.
15:14:52 <monochrom> @free beer
15:14:53 <lambdabot> f . beer = beer . f
15:14:58 <EvanR> balanced binary trap
15:14:58 <monochrom> \∩/
15:15:12 <b_jonas> olsner: a is predefined for free I think
15:15:20 <ion> @free g
15:15:21 <b_jonas> and a few other single letter vairables too
15:15:22 <lambdabot> Plugin `free' failed with: Plugin/Free/Type.hs:(152,16)-(160,44): Non-exhaustive patterns in case
15:15:22 <b_jonas> not all
15:15:31 <monochrom> @type a
15:15:32 <lambdabot> Expr
15:15:36 <monochrom> there
15:15:38 <c_wraith> > a * 5
15:15:38 <b_jonas> yep
15:15:39 <lambdabot>   a * 5
15:15:42 <kmc> b_jonas, i think an associative data structure with free snapshots and lockfree atomic updates is a very generally useful thing
15:15:47 <monochrom> @free True || False
15:15:47 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
15:15:52 <monochrom> @free True
15:15:52 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
15:16:00 <kmc> and i think fat tries have enough of a performance advantage over binary trees to be worth it
15:16:06 <monochrom> @free ()
15:16:07 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
15:16:08 <kmc> see the benchmarks of Map vs IntMap, which isn't even fat
15:16:20 <b_jonas> though wait, my example is wrong
15:16:22 <copumpkin> what makes a trie fat? A higher branching factor?
15:16:29 <kmc> copumpkin, yes
15:16:33 <kmc> that's how i'm using the term anyway
15:16:34 <olsner> hmm, what's @free supposed to do?
15:16:43 <b_jonas> because for an editor you'll need an ordered (not hashed) search tree anyway, so you can cut and paste intervals
15:16:47 <olsner> (and does it take a type? I may have confused it with @djinn)
15:16:48 <copumpkin> olsner: tells you things about functions
15:16:50 <shachaf> @help free
15:16:51 <lambdabot> free <ident>. Generate theorems for free
15:16:57 <copumpkin> @free myFunction :: a -> b
15:16:58 <lambdabot> g . myFunction = myFunction . f
15:17:04 <copumpkin> @free fix :: (a -> a) -> a
15:17:05 <lambdabot> f . g = h . f => f (fix g) = fix h
15:17:07 <kmc> b_jonas, sure, the ordering helps there
15:17:10 <dainanaki> @free id
15:17:12 <lambdabot> f . id = id . f
15:17:14 <b_jonas> though maybe that's not the only data structure you need, only one of them...
15:17:19 <kmc> it's not something you need always
15:17:34 <b_jonas> in fact, I was thinking on what data structure an editor would need to implement everything efficiently
15:17:43 <b_jonas> and I couldn't figure out one that worked for everything
15:17:44 <monochrom> @let beer = True
15:17:45 <lambdabot>  <local>:4:0:
15:17:45 <lambdabot>      Equations for `beer' have different numbers of arguments
15:17:45 <lambdabot>  ...
15:17:46 <kmc> ask edwardk about finger tree ropes
15:17:52 <monochrom> @undefine
15:17:55 <monochrom> @let beer = True
15:17:55 <kmc> http://hackage.haskell.org/package/rope
15:17:56 <lambdabot>  Defined.
15:17:59 <monochrom> @free beer
15:18:00 <lambdabot> beer = beer
15:18:04 <monochrom> \∩/
15:18:10 <c_wraith> now lambdabot is understanding beer
15:18:11 <cmccann> heh
15:18:18 <dainanaki> @let wine = False
15:18:19 <lambdabot>  Defined.
15:18:30 <b_jonas> I can do structures that would work fast for all _practical_ things you do with an editor
15:18:30 <monochrom> @free wine
15:18:31 <lambdabot> wine = wine
15:18:39 <kmc> lambdabot is seeing the world through the ⊥ of a beer stein
15:18:42 <cmccann> @vixen do you understand beer?
15:18:43 <lambdabot> yes i do
15:18:45 <olsner> @djinn nTonic
15:18:45 <b_jonas> but not one that satisfies the crazy theoretical requirements I invented
15:18:46 <lambdabot> -- f cannot be realized.
15:18:46 <shachaf> @free undefined
15:18:47 <lambdabot> f undefined = undefined
15:18:49 <kmc> @vixen wanna get high?
15:18:50 <lambdabot> nevermind about that
15:19:13 <monochrom> crazy theoretical requirements are hard to satisfy :)
15:19:33 <b_jonas> I think I still learned from it
15:19:44 <b_jonas> and would learn more if I figured it out completely
15:30:17 <hpaste> killasmurf86 pasted “2nd try” at http://hpaste.org/49244
15:35:56 <HugoDaniel> hi
15:36:06 <HugoDaniel> can i use haskell to code for the android phone ?
15:36:23 <cmccann> @faq can haskell run on android?
15:36:23 <lambdabot> The answer is: Yes! Haskell can do that.
15:36:26 <cmccann> ok
15:37:19 <HugoDaniel> :D
15:37:45 <cmccann> HugoDaniel, the serious answer is there's no reason why not, but you may have to do a lot of tinkering and hackery to get it working well
15:37:52 <cmccann> I'm not sure what the current state of affairs is
15:38:15 <cmccann> but other people are interested in it so you can probably find some material out there
15:41:45 <benmachine> ghc-android is a thing that exists but I'm not sure how complete or current it is
15:42:06 <cmccann> there's also the issue of library bindings
15:43:06 <HugoDaniel> hmm i see
15:43:52 <HugoDaniel> ill code lots of the android sdk functions as part of a writer monad, and do it in haskel instead
15:44:28 <HugoDaniel> in the end i have some fugly java code that works with android :/
15:47:37 <HugoDaniel> thats my lame approach to android coding in haskell :/
15:47:58 <cmccann> HugoDaniel, not sure if that would really be less hassle than the alternatives
15:48:15 <HugoDaniel> maybe even use the Data.Data to provide some hacked up automation for haskell datatypes along the way
15:48:20 <cmccann> should probably ask around a bit more, see if you can find other people who've worked on it
15:48:30 <HugoDaniel> yes
15:48:33 <HugoDaniel> thanks :=
15:48:34 <HugoDaniel> :)
15:48:49 <cies> new to haskell alert :)     ...can someone tell me what im doing wrong here?
15:48:53 <cies> getSeedScript :: (Monad m) => FilePath -> m String
15:48:53 <cies> getSeedScript initSqlFile = do return $ liftIO $ readFile initSqlFile
15:49:21 <monochrom> liftIO requires (MonadIO m) =>
15:49:22 <cies> expected String,  inferred [String]      is the error
15:49:28 <HugoDaniel> liftIO is wrong there
15:49:49 <cmccann> cies, misunderstanding how do notation works a bit, also
15:49:54 <monochrom> also delete "return"
15:49:56 <cies> how would it explain the error msg?
15:49:57 <HugoDaniel> also "do return" is not that good
15:50:11 <cmccann> you don't need "do" if it's just a single expression
15:50:25 <cmccann> that's only necessary for doing binding, e.g. x <- foobar
15:50:35 <monochrom> there is a flawed logic, the conclusion of which is "return $ return $ return $ return $ 0"
15:51:08 <ion> > return $ return $ return $ return $ 0 :: [[[[Integer]]]]
15:51:09 <lambdabot>   [[[[0]]]]
15:51:30 <cies> thanks a lot!
15:51:45 <aavogt> > do do 3
15:51:47 <lambdabot>   3
15:52:07 <monochrom> I won't explain why "expected String,  inferred [String]". it is a sane computer confused by an insane human
15:52:39 <cies> sorry for the disconnect.
15:52:58 <cmccann> cies, I figured that we'd just solved all your problems completely
15:53:09 <HugoDaniel> ahah nice one
15:53:17 <HugoDaniel> > do do do do 3
15:53:18 <lambdabot>   3
15:53:33 <blbrown_win3> There was a good book/older that was on type theory, anyone know what I am talking about?
15:53:44 <HugoDaniel> thats completely out of the box notation abuse :)
15:53:57 <ion> > pure $ pure $ pure $ pure $ 0 :: Maybe [Either String ([String],Integer)]]
15:53:58 <lambdabot>   <no location info>: parse error on input `]'
15:54:02 <ion> > pure $ pure $ pure $ pure $ 0 :: Maybe [Either String ([String],Integer)]
15:54:04 <lambdabot>   Just [Right ([],0)]
15:54:50 <monochrom> @let deep x = x
15:54:51 <lambdabot>  Defined.
15:54:56 <monochrom> > deep (do do 3)
15:54:58 <lambdabot>   3
15:55:20 <monochrom> @undefine
15:55:30 <monochrom> now she doesn't know beer either
15:55:41 <ion> > do do do do do do do do do do do do do do do do batman
15:55:42 <lambdabot>   Not in scope: `batman'
15:55:48 <monochrom> hahaha
15:55:53 <ion> > do do do do do do do do do do do do do do do do batman
15:55:55 <lambdabot>   batman
15:55:59 <HugoDaniel> :D
15:56:38 <monochrom> @type batman
15:56:39 <lambdabot> Not in scope: `batman'
15:56:46 <monochrom> gone
15:56:56 <monochrom> it is hard to catch batman!
15:57:05 <HugoDaniel> :)
15:57:11 <HugoDaniel> even in haskell
15:57:23 <aavogt> > text "batman"
15:57:24 <lambdabot>   batman
15:57:40 <monochrom> @quote bat.*sign
15:57:40 <lambdabot> Phyx- says: is @where ops the equivalent of displaying a bat signal in the sky?
15:57:46 <monochrom> @quote bat.*sign
15:57:46 <lambdabot> Phyx- says: is @where ops the equivalent of displaying a bat signal in the sky?
15:59:56 <monochrom> http://www.mail-archive.com/haskell-cafe@haskell.org/msg91872.html
16:00:41 <cies> cmccann: it seems im just moving the type error arround :)  now it is somewhere else!
16:01:05 <monochrom> yes, you should hide your code
16:03:34 <ion> Why is there no instance (Monoid a) => Monad ((,) a)? Not that i have ever needed one, but i had to use pure instead of return for my stupid “too many returns” code above. :-P
16:08:16 <burbul> Is there a efficient (i.e. O(n log n)) alternative to 'nub . sort' ?
16:08:45 <Saizan> map head . group . sort
16:08:50 <burbul> Thanks
16:09:05 <ion> > nub . sort $ [2,2,1,1,0,0]
16:09:07 <lambdabot>   [0,1,2]
16:09:17 <ion> > Data.Set.toList . Data.Set.fromList $ [2,2,1,1,0,0]
16:09:19 <lambdabot>   Not in scope: `Data.Set.toList'Not in scope: `Data.Set.fromList'
16:09:29 <c_wraith> nub doesn't benefit from sorting the list first
16:09:37 <c_wraith> in fact, nub works fine on infinite lists, but sort doesn't
16:09:43 <c_wraith> so...  that's something.
16:10:02 <c_wraith> err.  ok, nub works fine on *some* infinite lists. Not all of them. :)
16:11:11 <Peaker> @type map head . group . sort
16:11:12 <lambdabot> forall a. (Ord a) => [a] -> [a]
16:12:18 <Peaker> HugoDaniel: Writer monad to generate Android Java code would suck -- you get Haskell as a mere preprocessor for Java
16:13:49 <ClaudiusMaximus> ion: there's class (Monoid w, Monad m) => MonadWriter w m | m -> w
16:15:21 <ion> instance Monoid a => Monad ((,) a) where { return = pure; f >>= k = tupleJoin (k <$> f) where { tupleJoin (a, (b, x)) = (a `mappend` b, x) } }
16:15:25 <ion> ghci> (["foo"],42) >>= (,) ["bar"] . succ
16:15:27 <ion> (["foo","bar"],43)
16:17:25 <hpc> @unmtl Writer w a
16:17:25 <lambdabot> (a, w)
16:25:14 <HugoDaniel> True Peaker, what other quick n dirty approaches are there ?
16:25:40 <Peaker> HugoDaniel: why not the NDK?
16:27:51 <HugoDaniel> NDK ? let me google it :)
16:29:05 <Peaker> Native code interfaces for Android
16:29:30 <HugoDaniel> does it support llvm ?
16:29:40 <HugoDaniel> maybe through llvm it is possible to work out something like that
16:30:07 <HugoDaniel> what about... code that can be compiled to work in the android sdk and in the iphone sdk ?
16:30:10 <HugoDaniel> that would be killer
16:30:20 <Peaker> HugoDaniel: why not FFI to the NDK directly?
16:30:33 <Peaker> (missing compilers?)
16:30:47 <gwern> auuugh why is there more hawiki spam
16:30:52 <gwern> haven't I suffered enough today
16:32:56 <HugoDaniel> ok hmm
16:32:57 <HugoDaniel> i see
16:39:38 <burbul> Is there a guide for lambdabot? (I once saw someone invoke a 'simplify' command, but I can't remember what it was)
16:39:50 <kmc> @help
16:39:51 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:39:52 <kmc> @list
16:39:53 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
16:39:54 <burbul> thanks
16:39:55 <djahandarie> burbul, probably @pl
16:40:09 <kmc> i think @pl could only charitably be called "simplify"
16:40:25 <burbul> pl topological_order children = reverse . reverse_postorder children
16:40:30 <burbul> @pl topological_order children = reverse . reverse_postorder children
16:40:30 <lambdabot> topological_order = (reverse .) . reverse_postorder
16:41:10 <burbul> Hmmm... I can't decide whether that's better or not
16:42:46 <djahandarie> burbul, that's definitely one of the better things pl will output to you
16:42:51 <djahandarie> @pl \a b c d -> d c b a
16:42:52 <lambdabot> flip (flip . (flip .) . flip (flip . flip id))
16:43:17 <burbul> I'm still very new to Haskell, and it's hard to decide what's genuinely cryptic and what's just me not being used to the language.
16:43:58 <burbul> "(reverse .) . " is messing with my head a little
16:44:23 <djahandarie> Personally I don't even think that one though
16:44:26 <djahandarie> I just know what it means
16:44:26 <burbul> @type (reverse .)
16:44:28 <lambdabot> forall a (f :: * -> *). (Functor f) => f [a] -> f [a]
16:44:31 <djahandarie> Heh
16:44:50 <djahandarie> @type (reverse Prelude..)
16:44:51 <lambdabot> forall a a1. (a1 -> [a]) -> a1 -> [a]
16:45:02 <djahandarie> (Ignore lambdabot's special .)
16:45:03 <burbul> ah, thanks
16:45:25 <burbul> Why is it using a1 rather than b ?
16:45:59 <burbul> @type (reverse Prelude.)
16:46:00 <lambdabot> Not in scope: data constructor `Prelude'
16:46:04 <burbul> @type (reverse Prelude.. .)
16:46:05 <lambdabot> parse error on input `.'
16:46:15 * BMeph wonders if it's because A-1 is an awesome (steak) sauce... ;þ
16:46:26 <burbul> @type (reverse Prelude. .)
16:46:28 <lambdabot> parse error on input `.'
16:47:28 <copumpkin> does the HTTP library not support HTTPS? :(
16:47:50 <burbul> @help pretty
16:47:50 <lambdabot> pretty <expr>. Display haskell code in a pretty-printed manner
16:47:53 <doserj> @type (Prelude..)
16:47:53 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
16:47:59 <gwern> copumpkin: well, it's not named the HTTP*S* library
16:48:05 <gwern> truth in advertising, you ask me
16:48:07 <copumpkin> :(
16:48:15 <gwern> go use curl
16:48:18 <burbul> Ah -- prelude.DOT ... I see
16:48:21 * hackagebot representable-functors 2.0 - Representable functors  http://hackage.haskell.org/package/representable-functors-2.0 (EdwardKmett)
16:48:57 <doserj> burbul: the type-inference needs to invent a name for the return type of reverse. [b] is not possible because that is take by the type of (.) (although that variable disappears later)
16:49:25 <burbul> Then why not c?
16:50:04 <burbul> Actually, never mind -- it's not important
16:50:22 * hackagebot adjunctions 2.0.0 - Adjunctions  http://hackage.haskell.org/package/adjunctions-2.0.0 (EdwardKmett)
17:09:26 * hackagebot representable-tries 2.0 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-2.0 (EdwardKmett)
17:22:28 * hackagebot algebra 0.6.0 - Constructive abstract algebra  http://hackage.haskell.org/package/algebra-0.6.0 (EdwardKmett)
17:25:34 <dobblego> for Data.Enumerator, is there any value to type-aliasing Iteratee and Step for where m=Identity and provide additional combinators to wrap/unwrap Identityness?
17:26:02 <dobblego> similar to type State s a = StateT s Identity a
17:26:35 <cmccann> isn't most of the value of iteratees interleaving the steps through the monadic bind?
17:26:48 <cmccann> if you're using Identity, seems like operating on lazy lists would be easier in many cases
17:27:23 <cmccann> other than wanting to use existing iteratee stuff, of course
17:27:52 <cmccann> I don't know the details of any of the iteratee implementations though so not sure
17:27:55 <dobblego> yeah that's why I ask, except I'm using a language where unsafePerformIO is an implicit function
17:28:01 <cmccann> oh
17:28:08 <dobblego> yeah great innit
17:28:26 <cmccann> what, an iteratee implementation in scala?
17:28:45 <dobblego> yeah, we already have one not in transformer version and we are using it successfully in production
17:28:55 <dobblego> but we just unsafe that IO bro
17:29:01 <cmccann> heh
17:30:53 <cmccann> actually, I'm curious what the major benefit of iteratees is in an environment where the implicit monad is something like m >>= k = k . unsafePerformIO . fromJust $ m
17:31:09 * gwern has no idea what you are talking about so here are 2 cute girls dancing instead: http://www.youtube.com/watch?v=3bLopjyA_Eg
17:31:28 <hpaste> bobzhang pasted “mkA” at http://hpaste.org/49251
17:31:35 <dobblego> the benefit is composition without the bugs
17:31:38 <clsmith> gwern: \o/
17:31:44 <bobzhang> ion: mkA is exactly what i want
17:31:52 <bobzhang> ion: thank you
17:32:03 <cmccann> dobblego, in the sense of not introducing bugs in the composition itself?
17:32:10 <dobblego> right
17:32:11 <cmccann> since it doesn't seem like it would help with bugs in the things being composed
17:32:12 <cmccann> ok
17:32:25 <bobzhang> ion: in your code, why do you need take 20?
17:32:30 <dobblego> we unsafe that IO bro *and* cross our fingers and make big promises
17:33:00 <dobblego> I propose we don't unsafe that IO bro and use the pure functional language subset
17:33:27 <gwern> let's not unsafePerformIO and say we did
17:33:28 <dobblego> we have functioning IO and ST data types
17:33:53 <cmccann> at any rate if you're shoving impure stuff through an iteratee I'd say there's value to making "identity" a special case
17:34:01 <cmccann> in that your "identity" is actually "IO"
17:34:13 <cmccann> well, not special case, but using a shorthand
17:34:24 <dobblego> I may make both in fact, so that you may decline my proposal should you choose
17:36:33 <cmccann> hm, I wonder if using iteratee-ish stuff for all your sequential IO in an impure language would let you recover something more well-behaved akin to unsafeInterleaveIO
17:37:07 <dobblego> yeah that's more like what we are currently doing
17:37:30 <cmccann> dobblego, sounds like a laugh a minute
17:37:55 <dobblego> "doing better than the next guy" is the objective
17:38:09 <dobblego> I think we have achieved that
17:38:47 <cmccann> dobblego, yes, when such matters are involved it's always good to look on the bright side of life
17:38:53 <ion> bobzhang: It was just an example to limit the maximum length of the lists. Otherwise sample (arbitrary :: Gen Foo) would have printed insanely long results. :-)
17:40:15 <dobblego> cmccann: in saving, scala has access modifiers that you can use to prevent access to your unsafeness, so you can be assured that there are no potential breakages outside of your own sin
17:40:45 <cmccann> hm, interesting
17:41:12 <cmccann> the "if we slap enough duct tape on this we can look sort of like Haskell" approach, I gather
17:41:26 <monochrom> heh
17:41:50 <dobblego> actually, it was an excursion away from haskell
17:42:22 <monochrom> you mean "if we slap enough duct tape on haskell, we get scala"? :)
17:42:33 <dobblego> that's more like it!
17:42:38 <monochrom> haha
17:42:42 <Peaker> sometimes when I am mad at laziness I forget its awesomeness: http://augustss.blogspot.com/2011/05/more-points-for-lazy-evaluation-in.html
17:42:50 <dobblego> the scala guys get *very* upset if you say things like that by the way
17:42:56 <Peaker> in languages without laziness you can't even mechanically refactor expressions out into names...
17:43:12 <copumpkin> bos: why does Text.Read.rational take a RealFloat?
17:43:15 <dobblego> just warning
17:43:18 <copumpkin> or return one, that is
17:43:55 <cmccann> dobblego, my impression is that scala is basically all the abstract complexity of Haskell plus all the broken, accidental complexity of java glued together with clumsy heavyweight syntax
17:44:05 <cmccann> which still puts it ahead of many other languages I note
17:45:00 <dobblego> cmccann: that's roughly mine too -- there is also a magnificent display of cognitive dissonance from its designers and users when you try to point out potential improvements
17:46:00 <Peaker> dobblego: I think that's typical of almost all (opensource?) projects out there.. "improvements" assume something is wrong -- but it can't be wrong, the implementation matches the specification, so what do you want? :)
17:46:25 <dobblego> http://stackoverflow.com/questions/5099585/what-kind-of-things-are-easy-in-haskell-and-hard-in-scala-and-vice-versa
17:46:38 <cmccann> dobblego, I've not really done much with scala so I can only go on second-hand info and a few discussions I've seen online
17:46:42 <Peaker> Every time I remember trying to suggest improvements to OSS projects, I remember replies like "It behaves exactly like the spec, nothing is wrong" -- even when my complaint is *about* the spec
17:46:59 <cmccann> and I think the most cutting criticisms I've seen were... mostly from you, so I can't really add much :P
17:47:10 <dobblego> cmccann: I've been using it in production since 2007. I authored scala.Either in the standard libraries around 2008, which was a debacle, then resigned to the joke that is scala
17:47:20 <dobblego> ha
17:47:40 <dobblego> let's just say, "it pisses me off more than once per day"
17:48:47 * cmccann nods
17:49:05 <cmccann> even so I'm pretty sure I'd prefer scala to a lot of other things out there
17:49:13 <dobblego> me too
17:50:24 <cmccann> but some stuff--the post you linked to above in particular, in fact--was pretty persuasive in killing any enthusiasm I'd have for trying scala
17:50:32 <Peaker> dobblego: it may (rightfully) annoy people if you make a claim like "Scala's stdlib is a disaster" but then refuse to give examples/back it up..  Even if it is true -- the norm is not to make an allegation if you're not willing to give it at least some sort of backing up
17:50:59 <dobblego> Peaker: sure, I have a backup -- I've spent years repairing it
17:51:03 <Peaker> (and that is a good norm, in terms of removing noisy/wrong allegations -- at the cost of making truthful ones a bit more expensive)
17:51:11 <ion> Haskell’s stdlib is a disaster.
17:51:26 <cmccann> most stdlibs are disastrous
17:51:41 <Peaker> dobblego: Well, when someone asked you about it -- you just said "I'd rather move on" -- why not give a couple of examples in a couple of minutes, and explain that you've spent years on it?
17:51:52 <joe6> remove head and tail  from Haskell Prelude, please?
17:51:58 <cmccann> Haskell's is also less so than many, being mostly full of dumb oversights and inconveniences, rather than fundamentally broken everywhere
17:51:59 <dobblego> Peaker: there are cases where I'd rather move on, sure
17:52:19 <dobblego> Peaker: there are cases where I've bothered to answer the query and had to deal with lots of nonsense -- I'm just optimising
17:52:23 <cmccann> there are only a few things in the Haskell standard libraries I would go so far as to call "broken" rather than just annoying
17:52:39 <Peaker> cmccann: Haskell's stdlib names are pretty horrible too... perhaps because so many functions are too general to have meaningful names -- even the ones that could have meaningful names get stupid names like "init"
17:53:26 <ion> I never remember “init”, but that’s probably just because i *almost* never need it.
17:53:30 <cmccann> really? what names do you dislike? I've never had much of a problem with that.
17:53:30 <Peaker> dobblego: well, you don't have to expand on everything that you write -- but I think it is fair that you'd have to expand on things that are interpreted as allegations (or just disclaim it as not-going-to-back-this-up beforehand)
17:53:38 <Cale> init is an okay name, it has the advantage of having the same number of letters as head, tail, and last ;)
17:53:51 <Eduard_Munteanu> I mostly dislike it pollutes the namespace unnecessarily by not using typeclasses.
17:54:02 <Peaker> init is used as short for "initialize" in every other context :)
17:54:07 <cmccann> Cale, yes, lining things up neatly in columns is an important part of good programming
17:54:11 <aavogt> I like the monomorphism.
17:54:13 <dobblego> Peaker: every time someone suffers the penalty of scala's libraries, I tap that person on the shoulder. Daniel has witnessed me do this enough times
17:54:34 <aavogt> otherwise you'd need a more fancy 'default' mechanism
17:54:53 <Eduard_Munteanu> And it doesn't make much sense to have all those functions work on lists only, since typeclasses have been around for so long
17:55:19 <Peaker> dobblego: I've seen enough of what you wrote to believe your allegations have merit -- I'm merely saying that people expect allegations to be backed up in the same forum where they are made, and IMO rightfully so
17:55:20 <cmccann> Peaker, eh, but "initialize" makes sense in fewer contexts in Haskell, and the base meaning from "initial" is the same
17:55:37 <Peaker> cmccann: "initial" does not imply "all elements except the last one" at all
17:55:44 <dobblego> Peaker: I can't please them all
17:56:13 <dobblego> I see no reason to emphasise one particular point, especially one that is much more obvious than others -- simply because it is undesirable to some does not sway this
17:56:56 <cmccann> Peaker, it implies some prefix of the list, and given that and its type signature "all but the last" is the only thing that really makes sense
17:57:14 <dobblego> recently, someone bothered to write a critique of scala's "flagship" web programming library and copped a lambasting -- I just have no more patience for this nonsense\
17:57:18 <clsmith> hmm, is foldl more efficient than foldr? i forget.
17:57:38 <cmccann> clsmith, "more efficient" is not well-defined in that comparison
17:57:42 <dobblego> clsmith: it is neither more nor less efficient for the general case
17:57:44 <Peaker> cmccann: I think "withoutLast" would be nicer
17:57:46 <Eduard_Munteanu> clsmith: there isn't a general answer to that
17:57:53 <aavogt> > foldr (\x _ -> [x]) [] "this could be a sensible init"
17:57:55 <lambdabot>   "t"
17:58:04 <aavogt> > foldr (\x _ -> [x]) [] "this could be a sensible init function"
17:58:06 <lambdabot>   "t"
17:58:22 <Eduard_Munteanu> For strict operations foldl' is always better, I think.
17:58:47 <cmccann> Peaker, eh, seems clumsier. but it's an uncommonly used function, so it doesn't really matter that much
17:58:58 <copumpkin> man, this RealFloat constraint on the rational parser for Text is annoying
17:59:00 <Eduard_Munteanu> While if your fold produces its result piecewise / lazily, then foldr is better.
17:59:49 <mdgeorge> hello
17:59:50 <aavogt> clsmith: foldr doesn't have to consume the whole list either (see that foldr above)
17:59:56 <Eduard_Munteanu> mdgeorge: hi
18:00:13 <Peaker> cmccann: I think long "clumsy" names are better overall, despite the clumsiness penalty
18:00:29 <mdgeorge> what's the best approach to implementing cyclical, pointer-based data structures that support updates?
18:00:32 * hackagebot kan-extensions 2.0.0 - Kan extensions, the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-2.0.0 (EdwardKmett)
18:00:33 <Peaker> cmccann: In terms of learning curve, mental effort to memorize, etc.
18:00:53 <aavogt> > let plusInteger x y = x + y :: Integer in  plusInteger 1 2
18:00:54 <lambdabot>   3
18:01:09 <cmccann> Peaker, time spent learning is the least significant part if you actually use it afterwards
18:01:10 <mauke> mdgeorge: IORef
18:01:34 <mdgeorge> mauke: does that mean any programs that use that data structure have to be in IO?
18:01:34 <cmccann> optimizing for easier learning at the expense of convenience in using for what you know is how you end up with things like java
18:01:41 <Peaker> cmccann: it's a big barrier that adds up when you have many such functions
18:01:52 <Cale> I think names' length should vary proportionally with the size of their scope, and inversely with their frequency of use.
18:01:57 <aavogt> mdgeorge: IntMap might be better if you want to use old versions of that data
18:02:02 <mauke> mdgeorge: no, all programs have to be in IO
18:02:12 <Cale> Functions which you use *all the damn time* need short names
18:02:18 <cmccann> I still don't see how init is confusing anyway, though, so it seems wasteful
18:02:42 <cmccann> also, I like Cale's proportionality rule a great deal
18:02:46 <dobblego> reverseTailReverse
18:02:51 <Eduard_Munteanu> mdgeorge: or STRef
18:03:14 <Cale> init you don't necessarily use all the time, but I don't think it's a terrible name somehow. It's reasonably easy to remember.
18:03:36 <cmccann> it's also self-explanatory given the type, which counts for quite a bit
18:03:50 <Cale> yeah, from the type and name
18:03:51 <mauke> :t take 1
18:03:53 <lambdabot> forall a. [a] -> [a]
18:03:55 <mauke> really?
18:04:08 <aavogt> which function in base throws an exception that doesn't name the function correctly?
18:04:27 <cmccann> mauke, that's arbitrary. it's reasonable to assume that a generic function does the most generic thing possible given its type and the meaning of its name
18:04:33 <aavogt> @index foldr1
18:04:34 <lambdabot> Data.List, Prelude
18:04:47 <mauke> cmccann: not more arbitrary than head
18:05:16 <cmccann> head is a bad idea anyway, but it's not arbitrary either
18:05:47 <EvanR> head is great
18:05:59 <cmccann> lists are homogeneous sequences, so in some hand-waving sense the only thing you can do without caring about the length is mess with the ends
18:06:54 <EvanR> > delete 3 [1,2,3,4,5,6]
18:06:55 <lambdabot>   [1,2,4,5,6]
18:07:13 <cmccann> it's a matter of naming things such that there's an obvious most sensible interpretation, which is what the function actually does
18:07:19 <Cale> :t delete
18:07:20 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
18:07:35 <Peaker> cmccann: why would init not be (take 1) according to the genericness/types?
18:07:45 <Peaker> > delete 3 [3,3,3]
18:07:46 <lambdabot>   [3,3]
18:07:51 <dobblego> length is non-total like head
18:08:08 <EvanR> eh?
18:08:08 <Peaker> "deleteFirst" would be nicer..
18:08:15 <aavogt> @src length
18:08:16 <lambdabot> Source not found. Just try something else.
18:08:41 <dobblego> > head []
18:08:43 <lambdabot>   *Exception: Prelude.head: empty list
18:08:46 <dobblego> > length [1..]
18:08:50 <lambdabot>   mueval-core: Time limit exceeded
18:08:56 <cmccann> because that would be largely redundant with head, which is just a broken half-implementation of a function to deconstruct the type non-recursively
18:08:56 <aavogt> dobblego: non-total means strict to you?
18:09:16 <cmccann> and yes, delete is a good example of a function that's not actually clear from just the name and type
18:09:20 <dobblego> no, it fails to produce a result for a given element of the domain
18:09:28 <mauke> cmccann: but take 1 is total
18:09:42 <Eduard_Munteanu> That's not really an "element of the domain" I suppose
18:09:57 <EvanR> haha
18:10:07 <EvanR> no bottomless data allowed
18:10:10 <Eduard_Munteanu> e.g. infinite input doesn't constitute valid input.
18:10:35 <EvanR> valid or not, its still used and useful
18:10:37 <cmccann> mauke, so?
18:10:41 <mauke> is (repeat 0) infinite?
18:10:46 <Eduard_Munteanu> (you simply wouldn't be able to write that in a total language)
18:10:49 <cmccann> head being non-total is why it is dumb and shouldn't be there at all
18:11:25 <dobblego> or perhaps in Unsafe.List
18:11:26 <EvanR> head is fine for a non empty list type, which you can emulate with current list technology. in your head ;)
18:11:27 <cmccann> also, take 1 is misleading because it returns a type that is too general for the actual values produced
18:11:27 <Eduard_Munteanu> cmccann: well, that's like fromJust
18:11:40 <cmccann> fromJust is even more terrible and needs to be taken out back and shot
18:12:23 <cmccann> take 1 always gives you either [] or a single element list, so it's exactly equivalent to a "safe" version of head with type ([a] -> Maybe a)
18:12:29 <EvanR> i guess you dont like error or undefined much either
18:12:32 <Peaker> cmccann: but head's  type does not match its semantics, so why would one expect init's type to accurately match its semantics?
18:12:55 <Eduard_Munteanu> 'head' violates parametricity, no?
18:12:59 <cmccann> EvanR, they're more tolerable because at least they announce what's going on rather than pretending to be a sane function
18:13:07 <aavogt> @let totalLength = length . take maxBound
18:13:08 <lambdabot>  Defined.
18:13:26 <EvanR> cmccann: so basically you want the programmer to expand the definition of head or fromJust if thats what they wanted
18:13:32 <aavogt> no sense in having it wrap around
18:13:37 <EvanR> [] -> undefined
18:13:41 <EvanR> Nothing -> undefined
18:13:45 <Peaker> cmccann: also, sometimes it makes sense to have convenience or DRY-purposed functions that have a type more general than what they do (basically lifted functions) -- and then their name is all you have
18:13:52 <cmccann> EvanR mostly I want them to realize that it's not what they wanted and find a better design
18:14:23 <EvanR> non empty list type seems unrealistic for normal purposes
18:14:25 <mdgeorge> so you guys would use StRef to implement, e.g. a circular doubly-linked list?
18:14:40 <mauke> mdgeorge: when would I ever need that?
18:14:47 <cmccann> Peaker, only when really useful, which is often too contextual for standard library functions
18:15:03 <cmccann> if I really need to use take 1 often enough that I want to save a couple keystrokes, I can write it myself
18:15:21 <cmccann> whereas a version of head with the correct type would make more sense generally
18:15:27 <mauke> see also: concatMap
18:15:38 <mdgeorge> mauke: I'm trying to implement some geometric algorithms that operate on a doubly-connected edge list, which is basically a doubly-linked circular list on steroids
18:15:57 <cmccann> mauke, I think you misspelled (=<<) there ;]
18:16:04 <EvanR> mdgeorge: maybe you want C ? :)
18:16:46 * cmccann mostly just thinks that types should be as explicit and self-documenting as the type system allows unless there's very, very good reason to do otherwise
18:16:50 <mdgeorge> EvanR: perhaps, but I'm trying to port a library from C++ because the type hackery was so painful that I thought haskell could do it better
18:16:57 <Eduard_Munteanu> I suppose it's a bit tricky to do with STRefs, but doable.
18:17:09 <EvanR> porting a c++ lib to haskell
18:17:11 <cmccann> Haskell is expressive enough that it's really not hard to use correct things in the correct way
18:17:11 * EvanR hmms
18:17:41 <mdgeorge> EvanR: for fun
18:17:51 <mdgeorge> but not profit
18:17:53 <mdgeorge> unfortunately
18:18:04 <EvanR> youre a sick man
18:19:10 <Eduard_Munteanu> You might want to rework your approach, it's not like there has to be a 1-to-1 correspondence between C++ stuff and Haskell stuff in the resulting code
18:19:40 <mdgeorge> I agree, and I'm trying to find the best fit
18:20:07 <mdgeorge> but if I can't implement the basic data structures I don't see how I'll implement the algorithms that use them
18:20:13 <cmccann> Eduard_Munteanu, yeah, it's not worth the effort to imitate a C++ codebase, implementing segfaults reliably in haskell is awkward
18:20:17 <Eduard_Munteanu> You're not looking where you should then; first, why do you think you need a doubly-linked list?
18:20:33 <Eduard_Munteanu> cmccann: heh
18:20:56 <hpc> cmccann: now now, there's still some GHC bugs out there you can exploit, i think
18:20:57 <Eduard_Munteanu> I understand the particular algorithm might be expressed as such, but maybe there's another way to approach it.
18:20:57 <EvanR> c++ is like the antithesis of haskell
18:21:30 <kmc> sort of
18:21:32 <aavogt> segfaults are easy with the FFI or unsafe*
18:21:50 <kmc> you can draw some parallels
18:21:56 <kmc> programming languages occupy a high dimensional space
18:22:03 <kmc> so any two languages will be close in at least one way
18:22:12 <cmccann> C++ is dual to Haskell in a sense: it's much too hard for the average programmer to use safely, but they do anyway with disastrous results; whereas Haskell isn't actually that difficult to use but people don't even try
18:22:35 <Eduard_Munteanu> Secondly, a mixed C/C++ + Haskell approach is not out of the question either.
18:22:41 <EvanR> they both support ascii-only source code
18:22:43 <Eduard_Munteanu> Damn I did that again.
18:22:54 <Cale> @remember cmccann C++ is dual to Haskell in a sense: it's much too hard for the average programmer to use safely, but they do anyway with disastrous results; whereas Haskell isn't actually that difficult to use but people don't even try
18:22:54 <luite> hehe C/C++
18:22:55 <lambdabot> It is forever etched in my memory.
18:23:07 <mdgeorge> Eduard_Munteanu: here are some of the operations I'd like to support.  Given a face, enumerate the vertices and edges around the face.  Given a face and an edge, find the face on the other side of the edge
18:23:15 <hpc> it's funny seeing people try to lump C and C++ into one language
18:23:34 <cmccann> hpc, standing over here in Haskell-land the differences seem pretty irrelevant
18:23:59 <mdgeorge> Eduard_Munteanu: creating a binding to the C++ library is not feasible, because it makes heavy use of template metaprogramming, and I'd need to basically choose the types that I want to operate on
18:24:15 <EvanR> cmccann: yes, every non-haskell-like language is irrelevant
18:24:19 <EvanR> doesnt mean they are all the same ;)
18:24:21 <hpc> cmccann: indeed; zoom out far enough and the picture becomes "math" and "everything else" :P
18:24:35 <kmc> and Haskell is way in the "everything else" category
18:24:39 <mdgeorge> besides, part of the point of the project is to get some practice programming in a functional style
18:24:45 <cmccann> for the most part C and C++ are different in ways that nobody besides C and C++ programmers actually care about
18:24:53 <kmc> what
18:25:01 <kmc> C and C++ are vastly different languages
18:25:02 <mdgeorge> cmccann: I disagree
18:25:06 <kmc> if you are interested in PL theory you should study C++
18:25:10 <kmc> it is a fascinating example
18:25:13 <Eduard_Munteanu> mdgeorge: instead of a doubly linked list you might want to investigate zippers
18:25:21 <kmc> mostly it is an example of what not to do
18:25:28 <kmc> but the goal they were aiming for is an interesting one
18:25:34 <kmc> and it certainly has many interesting unusual features
18:25:41 <kmc> it is basically the world's most successful esolang
18:25:51 <mdgeorge> kmc: I've found that there are programs that I can just barely express in C++ that I can't express in any other language
18:25:54 <Eduard_Munteanu> mdgeorge: they're really similar when you have a zipper on a list
18:26:10 <PatrickRobotham> mdgeorge: Become a better programmer! :P
18:26:41 <mdgeorge> PatrickRobotham: always working on that
18:26:58 <EvanR> if you want to 'practice functional style' then run rm on that c++ lib
18:27:00 <Eduard_Munteanu> Basically a zipper on a list looks like    [a] a [a]   , in a way you can slide it either way
18:27:15 <mdgeorge> Eduard_Munteanu: thanks, I understand zippers
18:27:33 <mdgeorge> EvanR: I'm planning to, but I have to figure out how to implement it in haskell first
18:27:58 <EvanR> well are you trying to keep the same interface, or reproduce the internal algorithm, or both
18:28:01 <Cale> mdgeorge: You should talk to ivanm
18:28:25 <Eduard_Munteanu> IME they're usually a good replacement for doubly linked lists or similar structures, as long as you don't need to keep multiple references / shortcuts into your data structure
18:28:30 <mdgeorge> Cale: oh?
18:28:31 <Cale> mdgeorge: (he has a library for planar graphs which sounds vaguely relevant to you, though I haven't been following the discussion closely)
18:29:00 <mdgeorge> Cale: that sounds very relevant.  Can you point me in the right direction?
18:29:19 <Cale> I can't remember what the library was called and he's not around, I'll try and dig it up
18:29:32 <mdgeorge> Cale: thanks, that will be a big help
18:29:57 <Eduard_Munteanu> (shortcuts are messy with zippers :/)
18:30:28 <Cale> http://code.haskell.org/~ivanm/planar-graph/ -- might be it
18:30:34 <Cale> I'm not sure if that's current or not
18:32:57 <mdgeorge> Cale: that looks very helpful, thanks
18:33:30 <mdgeorge> it looks like the approach taken there is to simulate pointers by storing everything in an array and using integers to refer to other nodes.
18:33:38 <mdgeorge> or a map anyway
18:33:51 <Cale> mdgeorge: sure
18:33:55 <Cale> mdgeorge: that's standard
18:34:05 <Cale> Map or IntMap is the usual answer
18:34:20 <Cale> pointers are just indexes into a giant unsafe map which is all of memory
18:35:33 <ion> Pointers are just parameters to a giant unsafe function which is all of memory
18:36:46 <kmc> they're both, which is the best part
18:36:47 <Eduard_Munteanu> Doesn't sound like idiomatic FP :/
18:37:08 <Eduard_Munteanu> Actually it sounds worse than imperative pointer-based approaches.
18:37:59 <EvanR> if you just need to read from the array then it seems just as good as an IntMap
18:38:18 <EvanR> and you can write your graph algo on it
18:39:38 * Eduard_Munteanu thinks STRef s (STRef s a) might be a better / easier way to translate that sort of stuff
18:40:04 <Eduard_Munteanu> (that is, mutable pointers)
18:40:20 <kmc> snap
18:42:46 <cmccann> didn't oleg have something about simulating mutable references by nesting delimited continuations? that's obviously the way to do it
18:43:12 <hpc> Mu (STRef s)?
18:43:23 <mdgeorge> that's the other thing that I'm having trouble translating from the C++ lib.  All of the algorithms there are parameterized on the type of data structure that they use.  The code is agnostic as to whether you use an IntMap or an Array or a Vector or whatever.  I don't see an easy way to do that in Haskell
18:43:24 <Eduard_Munteanu> Considering some of Oleg's stuff, that might be the obvious way if you're a postdoc :P
18:43:34 <mdgeorge> I actually will be a postdoc soon
18:43:39 <Eduard_Munteanu> Heh.
18:43:41 <mdgeorge> doesn't make it obvious
18:44:08 <cmccann> yeah, I don't think oleg's stuff is obvious to anyone
18:44:20 <cmccann> that's kind of his whole routine :]
18:44:52 <mdgeorge> well if he wants to change anything, it will have to be his coroutine
18:45:06 <cmccann> (most of it's not actually that complicated, just really weird and he doesn't go out of his way to make it sound approachable)
18:45:07 <mdgeorge> at least if delimited continuations are the way to handle state
18:45:27 <mdgeorge> cmccann: sounds like a very haskelly approach to me.
18:45:34 <Eduard_Munteanu> mdgeorge: yeah, but they're all mutable in C++, though not in Haskell
18:45:58 <Eduard_Munteanu> It doesn't sound like a good idea to mix those.
18:46:05 <mdgeorge> to mix which?
18:46:36 <Eduard_Munteanu> Say, IntMap with STArray
18:47:10 <cmccann> mdgeorge, nah, the haskell way is to do complicated things in simple ways while explaining simple things in complicated ways
18:47:27 <Eduard_Munteanu> If you settle with either mutable or immutable stuff, then maybe you could define a unified interface to them.
18:47:39 <mdgeorge> Eduard_Munteanu: but Map, IntMap, and Array all have basically the same interface, I don't see why my code should care one way or the other
18:47:39 <cmccann> oleg does complex things in complex ways and then explains them in a matter-of-fact style
18:47:49 <mdgeorge> I see
18:48:00 <mdgeorge> but you just said they weren't really all that complex
18:48:08 <monochrom> you can cook up a type class for IntMap, Array, and Vector
18:48:23 <cmccann> not as complex as they seem at first, is what I meant
18:48:43 <mdgeorge> monochrom: yes.  I wish that the standard libraries worked more in this fashion
18:48:45 <monochrom> in fact, Array already has a type class, you can fit other types into it
18:48:51 <mdgeorge> ah
18:48:58 <mdgeorge> ok, maybe I should just rtfm then :)
18:49:14 <Eduard_Munteanu> Yeah, making an instance of IArray (?) might be a nice idea.
18:49:29 <cmccann> given a clear explanation and/or some time spent figuring it out, most of oleg's stuff isn't that hard to grasp. but it is more complex than a lot of day-to-day stuff, sure
18:49:42 <Eduard_Munteanu> *instance for IntMap
18:49:47 <monochrom> actually, that type class is kind of closed up, so nevermind, cook your own
18:50:15 <monochrom> but any time you exploit operator overloading in c++, use type class in haskell
18:51:51 <mdgeorge> speaking of type classes, I've been using the type families extension, and I was wondering if there's any way to constrain the types within a type class
18:52:28 <mdgeorge> for example, I'd like to have something like
18:52:28 <mdgeorge> class (Eq (Point2 a)) => Traits a where
18:52:29 <mdgeorge>  type Point2 a
18:52:29 <kmc> mdgeorge, you want to associate your type family with a class?
18:52:31 <kmc> yes
18:52:32 <cmccann> constrain in what sense?
18:52:33 <kmc> do that exactly
18:52:43 <cmccann> yeah, just put a context on it like that
18:52:48 <mdgeorge> oh.
18:52:51 <kmc> you still need -XTypeFamilies
18:52:52 <mdgeorge> well that was easy :)
18:52:53 <cmccann> you can do that on class definitions as well as individual instances
18:52:56 <kmc> also i think that bit did not work before GHC 7
18:53:03 <cmccann> it worked fine
18:53:04 <kmc> hehe, traits
18:53:11 <cmccann> you just couldn't use equality constraints on classes
18:53:32 <cmccann> until some version that's not actually released yet
18:53:43 <mdgeorge> is there a good reference that discusses these features?
18:53:47 <kmc> the GHC manual
18:53:52 <mdgeorge> ok
18:53:56 <cmccann> mdgeorge, the GHC manual really is pretty approachable
18:54:00 <monochrom> the GHC manual has good examples too
18:54:16 <cmccann> it's not just an "RTFM" thing here, it really is useful
18:54:25 <mdgeorge> ok, I'll have to read that then.  google keeps sending me off to bizarre research papers
18:54:28 <monochrom> everything I needed to know about existential types I learn from the GHC manual
18:54:51 <cmccann> mdgeorge, here's the toy shop: http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html
18:56:11 <mdgeorge> that just goes to show I should always ask twice, since last time I asked on here everyone said it was impossible
18:56:36 <cmccann> mdgeorge, probably a misunderstanding of what you were asking about
18:56:43 <mdgeorge> could well be
18:56:49 <monochrom> come again tomorrow for the halting problem :)
18:57:03 <mdgeorge> :)
18:57:06 <aavogt> even if -XTypeFamilies didn't support that, you probably could achieve the same with -XFunctionalDependencies
18:57:07 <kmc> mdgeorge, maybe you asked if it was possible in "Haskell" and people pedantically assumed you meant standard Haskell and not GHC extended Haskell
18:57:10 * kmc would be one of those people
18:57:28 <mdgeorge> I'm not complaining though, I really appreciate all the help you guys give me
18:58:50 <mdgeorge> kmc: why the chuckle about traits?  Is that a design pattern that is subsumed by something better in haskell land?
18:59:01 <aavogt> so if you redefined   class Point2 a eq | a -> eq where ..., then where you had   type Eq a = X, you instead have   instance Point2 a X
18:59:58 <mdgeorge> aavogt: I'll probably have to read about functional dependencies before I can make any sense of that
19:00:02 <kmc> mdgeorge, no, i'm not sure it's the wrong thing or anything
19:00:17 <kmc> just amused because it's a C++ thing and reminded me of that whole world
19:00:27 <aavogt> mdgeorge: it means the same thing what you seem to have for Point2
19:00:59 <cmccann> kmc, in practice most languages tend to be defined by "the set of programs accepted by most commonly-used compilers" rather than any sort of spec
19:01:15 <aavogt> oh, I forgot:    class Point2 a b => Traits b where
19:01:19 <kmc> cmccann, right, but i think that's dumb and we should make at least a token effort to distinguish
19:01:26 <kmc> diversity of implementations is important
19:01:43 <cmccann> kmc, not disagreeing, just saying
19:01:48 <kmc> even if one implementation is the de facto standard for getting work done, the others can provide useful ideas or be applicable in specific niches
19:01:50 <cmccann> feel free to keep fighting the good fight
19:01:58 <kmc> UHC, JHC, and Hugs all have interesting extensions that GHC lacks
19:02:05 <kmc> Hugs and JHC are usable on platforms where GHC is not
19:02:14 <kmc> UHC can produce Javascript
19:03:03 <monochrom> to date GHC still doesn't have TREX or better
19:03:14 <mdgeorge> how portable are the ghc extensions?  Is there cross pollination, or will using them confine me to GHC?
19:03:23 <cmccann> depends on the extension
19:03:26 <kmc> the more popular ones are widely accepted
19:03:35 <cmccann> also, some are more easy to ditch than others
19:03:41 <kmc> being confined to GHC is not a problem in most cases
19:03:42 <Axman6> though you're pretty unlikely to want to use any other compiler really
19:03:49 <_habnabit> is there a better way to write, in the general case: flip ((flip f) . g)
19:03:57 <mdgeorge> I agree with cmccann and kmc: I think the appropriate answer is "not in haskell per se, but it is possible with the ... extension"
19:03:59 <kmc> not afaik
19:04:02 <kmc> @pl flip ((flip f) . g)
19:04:03 <lambdabot> (. g) . f
19:04:06 <kmc> :O
19:04:11 <kmc> :t (. ?g) . ?f
19:04:13 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (?g::f a, Functor f, ?f::f1 (a -> b), Functor f1) => f1 (f b)
19:04:15 <_habnabit> oho.
19:04:18 <kmc> caaaaaaaale!
19:04:22 <cmccann> hahahahahaha
19:04:25 <kmc> :t (. ?g) Prelude.. ?f
19:04:26 <cmccann> caleskell strikes again
19:04:26 <lambdabot> forall a b (f :: * -> *) a1. (?g::f a, Functor f, ?f::a1 -> a -> b) => a1 -> f b
19:04:30 <kmc> :t (Prelude.. ?g) Prelude.. ?f
19:04:32 <lambdabot> forall b c a a1. (?f::a1 -> b -> c, ?g::a -> b) => a1 -> a -> c
19:05:03 <Cale> :t let (.) = (Prelude..) in (. ?g) . ?f
19:05:04 <lambdabot> forall b c a a1. (?f::a1 -> b -> c, ?g::a -> b) => a1 -> a -> c
19:05:09 <_habnabit> sadly, I'm writing for ocaml, not haskell. can't partially-apply the rhs.
19:05:31 <monochrom> ocaml lacks sections too
19:05:46 <Cale> But honestly, if you're partially applying (.), thinking in terms of fmap is almost always more comfortable.
19:05:50 <cmccann> @unpl (. g) . f
19:05:51 <lambdabot> (\ d i -> f d (g i))
19:05:57 <_habnabit> sections?
19:06:01 <Cale> yeah
19:06:05 <mdgeorge> ok, well I'm off to bed.  Thanks again for your help guys!
19:06:12 <Eduard_Munteanu> Maybe you can just use the unpl-ed version :/
19:06:14 <monochrom> section means (f .) and (. f)
19:06:24 <kmc> or any other infix operator
19:06:27 <kmc> > map (+3) [1,2,5]
19:06:28 <lambdabot>   [4,5,8]
19:06:31 <Cale> _habnabit: Lambda exists for a reason ;)
19:06:34 <cmccann> ocaml has some sort of moral opposition to infix operators being pleasant, I think
19:06:41 <Axman6> > (f >>= g) x
19:06:42 <lambdabot>   Ambiguous type variable `a' in the constraints:
19:06:42 <lambdabot>    `GHC.Show.Show a'
19:06:42 <lambdabot>      a...
19:06:45 * Eduard_Munteanu thought about sections and retractions
19:06:46 <_habnabit> monochrom, right, that's what I meant.
19:06:51 <Axman6> > (f >>= g) x :: Expr
19:06:52 <lambdabot>   Ambiguous type variable `a' in the constraints:
19:06:52 <lambdabot>    `GHC.Show.Show a'
19:06:53 <lambdabot>      a...
19:07:00 <Axman6> -_-
19:07:10 <_habnabit> Cale, doing this in code is how I stay sane writing ocaml
19:07:21 <_habnabit> (i.e. avoiding anonymous functions as much as possible.)
19:07:42 * monochrom hugs his anonymous functions
19:08:13 <aavogt> > (f >>= g::Expr->Expr) x :: Expr
19:08:15 <lambdabot>   Ambiguous type variable `a' in the constraints:
19:08:16 <lambdabot>    `SimpleReflect.FromExpr ...
19:08:20 <_habnabit> well, writing anonymous functions would be /easier/. I'm just trying to keep my mind busy.
19:08:37 <Axman6> > (f >>= g :: Expr -> Expr -> Expr) x :: Expr
19:08:38 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
19:08:38 <lambdabot>         against inferred ...
19:08:40 <Eduard_Munteanu> :) ... and the code unreadable
19:08:48 <_habnabit> Eduard_Munteanu, an added bonus!
19:09:03 <Eduard_Munteanu> Why should THEY have an easy time reading it? :)
19:09:19 <_habnabit> well, I'm basically the only one writing ocaml, so.
19:09:58 <Eduard_Munteanu> ... so it's best if you don't remember the details later on :P
19:10:02 <ion> > (f :: Expr -> Expr -> Expr) =<< g $ x
19:10:04 <lambdabot>   f (g x) x
19:10:16 <kmc> this channel actually gets a fair number of ocaml, scala, and erlang questions
19:10:16 <_habnabit> well, /I/ can figure it out again.
19:10:20 <kmc> i guess we have a reputation for being helpful
19:10:25 <kmc> (hooray us, etc)
19:11:00 <cmccann> ion, if you're trying to imitate the (. g) . f thing that won't work
19:11:00 <Eduard_Munteanu> Let's not forget confluence and lambda calculus questions.
19:11:02 <_habnabit> well, I typically ask very general questions about functional programming, and this is the largest channel out of any of the language channels in that regard.
19:11:15 <ion> cmccann: I’m not.
19:11:17 <kmc> Eduard_Munteanu, any confluence experts here ??
19:11:20 <cmccann> ion, ok
19:11:24 <Eduard_Munteanu> :)
19:11:37 <ion> I don’t know what the others above were trying, but i made their expression work. :-P
19:11:49 <kmc> it's also the second-largest language channel, period
19:11:50 <cmccann> oh, it was Axman6 doing it before
19:12:09 <Eduard_Munteanu> Hm, that's odd, I didn't know that.
19:12:16 <Eduard_Munteanu> kmc: which comes first?
19:12:16 <_habnabit> python still has haskell edged out.
19:12:31 <Polarina> Is there any difference in using reactimate instead of reactInit and react?
19:12:34 <kmc> and Haskell certainly has the highest ratio of language users to IRC users ever
19:12:44 <kmc> er
19:12:46 <kmc> the other one
19:12:47 <kmc> whatever
19:12:54 <kmc> figure it out, nerds
19:12:58 <djahandarie> Despite having a ton of people, I can count all the people who have said over 100 lines in here on a few hands :p
19:13:17 <kmc> djahandarie, really, over all its history?
19:13:29 <djahandarie> In the past 3 years or so!
19:13:29 <PatrickRobotham> djahandarie: The problem is we're all scared
19:13:41 <djahandarie> PatrickRobotham, boo!
19:14:00 <PatrickRobotham> djahandarie: There's people using 19 fmaps in an expression and I can't compete with that.
19:14:24 <djahandarie> Not sure you'd want to compete with that. :p
19:14:24 <ion> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
19:14:26 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f1, Functor f, Functor f2) => f1 (a -> b) -> f1 (f (f2 a) -> f (f2 b))
19:14:30 <luite> the lurkers are just learning and planning to take over the world with their newly acquired haskell knowledge
19:14:43 <cmccann> long strings of fmap are just nesting them  :I
19:14:47 <Eduard_Munteanu> ion: I don't remember the ugly one
19:14:50 <cmccann> it's fmap . fmap . fmap etc.
19:15:11 <Eduard_Munteanu> But there was one that made lambdabot spew lots of pseudo-garbage
19:15:49 <Eduard_Munteanu> :t fmap . fmap . fmap . fmap . fmap . fmap . fmap . fmap . fmap . fmap . fmap . fmap
19:15:50 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) (f3 :: * -> *) (f4 :: * -> *) (f5 :: * -> *) (f6 :: * -> *) (f7 :: * -> *) (f8 :: * -> *) (f9 :: * -> *) (f10 :: * -> *) a b (f11 :: * -> *). (
19:15:50 <lambdabot> Functor f, Functor f1, Functor f2, Functor f3, Functor f4, Functor f5, Functor f6, Functor f7, Functor f8, Functor f9, Functor f10, Functor f11) => (a -> b) -> f (f1 (f2 (f3 (f4 (f5 (f6 (f7 (f8 (f9 (
19:15:50 <lambdabot> f10 (f11 a))))))))))) -> f (f1 (f2 (f3 (f4 (f5 (f6 (f7 (f8 (f9 (f10 (f11 b)))))))))))
19:15:53 <djahandarie> cmccann, the interesting part is that the type doesn't get bigger.
19:15:57 <Eduard_Munteanu> Oh, this one
19:16:54 <Axman6> :t let a = ((),()); b = (a,a); c = (b,b); d = (c,c); e = (d,d) in e
19:16:56 <lambdabot> ((((((), ()), ((), ())), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ())))), (((((), ()), ((), ())), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ())))))
19:17:01 <cmccann> oh yeah, it's not simple nesting, nevermind
19:17:12 <djahandarie> Axman6, trying to take out lambdabot? :p
19:17:40 <Axman6> yeah... there's a simple way making a massive type like that, but i can't remember what it is
19:18:36 <Eduard_Munteanu> > let f = fmap . fmap; g = f . f . f . f in g . g . g . g      -- maybe this?
19:18:38 <lambdabot>   Overlapping instances for GHC.Show.Show
19:18:39 <lambdabot>                              ((a ->...
19:18:48 <Eduard_Munteanu> :t let f = fmap . fmap; g = f . f . f . f in g . g . g . g      -- maybe this?
19:18:49 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) (f3 :: * -> *) (f4 :: * -> *) (f5 :: * -> *) (f6 :: * -> *) (f7 :: * -> *) (f8 :: * -> *) (f9 :: * -> *) (f10 :: * -> *) (f11 :: * -> *) (f12 :: * -
19:18:49 <lambdabot> > *) (f13 :: * -> *) (f14 :: * -> *) (f15 :: * -> *) (f16 :: * -> *) (f17 :: * -> *) (f18 :: * -> *) (f19 :: * -> *) (f20 :: * -> *) (f21 :: * -> *) (f22 :: * -> *) (f23 :: * -> *) a b (f24 :: * -> *
19:18:49 <lambdabot> ) (f25 :: * -> *) (f26 :: * -> *) (f27 :: * -> *) (f28 :: * -> *) (f29 :: * -> *) (f30 :: * -> *) (f31 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3, Functor f4, Functor f5, Functor f6,
19:18:49 <lambdabot> Functor f7, Functor f8, Functor f9, Functor f10, Functor f11, Functor f12, Functor f13, Functor f14, Functor f15, Functor f16, Functor f17, Functor f18, Functor f19, Functor f20, Functor f21,
19:18:49 <lambdabot> Functor f22, Functor f23, Functor f24, Functor f25, Functor f26, Functor f27, Functor f28, Functor f29, Functor f30, Functor f31) => (a -> b) -> f (f1 (f2 (f3 (f4 (f5 (f6 (f7 (f8 (f9 (f10 (f11 (f12 (
19:18:51 <lambdabot> f13 (f14 (f15 (f16 (f17 (f18 (f19 (f20 (f21 (f22 (f23 (f24 (f25 (f26 (f27 (f28 (f29 (f30 (f31 a))))))))))))))))))))))))))))))) -> f (f1 (f2 (f3 (f4 (f5 (f6 (f7 (f8 (f9 (f10 (f11 (f12 (f13 (f14 (f15 (
19:18:53 <lambdabot> f16 (f17 (f18 (f19 (f20 (f21 (f22 (f23 (f24 (f25 (f26 (f27 (f28 (f29 (f30 (f31 b)))))))))))))))))))))))))))))))
19:19:06 <Eduard_Munteanu> Sorry, that was a bit excessive.
19:19:16 <Axman6> heh
19:19:39 <ion> :t let a=fmap.fmap;b=a.a;c=b.b;d=c.c;e=d.d;f=e.e;g=f.f in g
19:19:41 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) (f3 :: * -> *) (f4 :: * -> *) (f5 :: * -> *) (f6 :: * -> *) (f7 :: * -> *) (f8 :: * -> *) (f9 :: * -> *) (f10 :: * -> *) (f11 :: * -> *) (f12 ::
19:19:41 <lambdabot>  * -> *) (f13 :: * -> *) (f14 :: * -> *) (f15 :: * -> *) (f16 :: * -> *) (f17 :: * -> *) (f18 :: * -> *) (f19 :: * -> *) (f20 :: * -> *) (f21 :: * -> *) (f22 :: * -> *) (f23 :: * -> *) (f24 :: * -> *
19:19:41 <lambdabot> ) (f25 :: * -> *) (f26 :: * -> *) (f27 :: * -> *) (f28 :: * -> *) (f29 :: * -> *) (f30 :: * -> *) (f31 :: * -> *) (f32 :: * -> *) (f33 :: * -> *) (f34 :: * -> *) (f35 :: * -> *) (f36 :: * -> *) (f37
19:19:41 <lambdabot> :: * -> *) (f38 :: * -> *) (f39 :: * -> *) (f40 :: * -> *) (f41 :: * -> *) (f42 :: * -> *) (f43 :: * -> *) (f44 :: * -> *) (f45 :: * -> *) (f46 :: * -> *) (f47 :: * -> *) (f48 :: * -> *) (f49 :: * ->
19:19:41 <lambdabot>  *) (f50 :: * -> *) (f51 :: * -> *) (f52 :: * -> *) (f53 :: * -> *) (f54 :: * -> *) (f55 :: * -> *) (f56 :: * -> *) (f57 :: * -> *) (f58 :: * -> *) (f59 :: * -> *) (f60 :: * -> *) (f61 :: * -> *) (
19:19:43 <lambdabot> [23 @more lines]
19:19:55 <Eduard_Munteanu> Oh, so it stops after all.
19:20:37 <neophyte> Is anyone here familiar with lamdba calculus? I am trying to understand a definition, which uses lamdba calculus but I don't know it and was hoping someone could explain what the definition is saying in english
19:21:05 <PatrickRobotham> neophyte: Well, I think I can explain the general idea.
19:21:09 <Polarina> Who here uses Yampa or Animas?
19:21:22 <neophyte> Pathin: Definition 1 found here - http://oi56.tinypic.com/20qhm5c.jpg
19:21:25 <PatrickRobotham> neophyte: The lambda calculus is a way to define functions inline.
19:21:56 <neophyte> ah, i see
19:22:04 <djahandarie> As opposed to? :p
19:22:07 <PatrickRobotham> neophyte: (\x -> x*2) has the same meaning as f(x) = x*2
19:22:20 <neophyte> ok that makes sense
19:22:21 <PatrickRobotham> neophyte: But you don't have to give a name to the lambda expression.
19:22:23 <cmccann> hm
19:22:27 <djahandarie> I'd say the later is just syntax for f = \x -> x*2
19:22:35 <PatrickRobotham> djahandarie: Yes.
19:22:47 <djahandarie> At which point you could just say "The lambda calculus is a way to define functions."
19:22:54 <cmccann> :t let f x y = x . y x; g x y = flip y $ flip x in f.f.f.g.g.g
19:22:56 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b (f3 :: * -> *) b1 a1 b2 (f4 :: * -> *) a2 b3. (Functor f3, Functor f4, Functor f, Functor f1, Functor f2) => f4 (a2 -> b3) -> ((((((f3 ((a -> (
19:22:56 <lambdabot> a -> (a1 -> (a1 -> (a2 -> f4 b3) -> b2) -> b2) -> b) -> b) -> b1) -> f3 b1) -> f2 (f3 ((a -> (a -> (a1 -> (a1 -> (a2 -> f4 b3) -> b2) -> b2) -> b) -> b) -> b1))) -> f2 (f3 b1)) -> f1 ((f3 ((a -> (a -
19:22:56 <lambdabot> > (a1 -> (a1 -> (a2 -> f4 b3) -> b2) -> b2) -> b) -> b) -> b1) -> f3 b1) -> f2 (f3 ((a -> (a -> (a1 -> (a1 -> (a2 -> f4 b3) -> b2) -> b2) -> b) -> b) -> b1)))) -> f1 (f2 (f3 b1))) -> f ((((f3 ((a ->
19:22:56 <lambdabot> (a -> (a1 -> (a1 -> (a2 -> f4 b3) -> b2) -> b2) -> b) -> b) -> b1) -> f3 b1) -> f2 (f3 ((a -> (a -> (a1 -> (a1 -> (a2 -> f4 b3) -> b2) -> b2) -> b) -> b) -> b1))) -> f2 (f3 b1)) -> f1 ((f3 ((a -> (a
19:22:56 <lambdabot> -> (a1 -> (a1 -> (a2 -> f4 b3) -> b2) -> b2) -> b) -> b) -> b1) -> f3 b1) -> f2 (f3 ((a -> (a -> (a1 -> (a1 -> (a2 -> f4 b3) -> b2) -> b2) -> b) -> b) -> b1))))) -> f (f1 (f2 (f3 b1)))
19:23:06 <cmccann> :t let f x y = x . y x; g x y = flip y $ flip x in f.f.f.g.g.g $ ()
19:23:07 <lambdabot>     Couldn't match expected type `f (a -> b)'
19:23:07 <lambdabot>            against inferred type `()'
19:23:07 <lambdabot>     In the second argument of `($)', namely `()'
19:23:09 <copumpkin> so what do people use for http requests with https?
19:23:23 <cmccann> :t \z -> let f x y = x . y x; g x y = flip y $ flip x in f.f.f.g.g.g $ z
19:23:24 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b (f3 :: * -> *) b1 a1 b2 (f4 :: * -> *) a2 b3. (Functor f3, Functor f4, Functor f, Functor f1, Functor f2) => f4 (a2 -> b3) -> ((((((f3 ((a -> (
19:23:24 <lambdabot> a -> (a1 -> (a1 -> (a2 -> f4 b3) -> b2) -> b2) -> b) -> b) -> b1) -> f3 b1) -> f2 (f3 ((a -> (a -> (a1 -> (a1 -> (a2 -> f4 b3) -> b2) -> b2) -> b) -> b) -> b1))) -> f2 (f3 b1)) -> f1 ((f3 ((a -> (a -
19:23:24 <lambdabot> > (a1 -> (a1 -> (a2 -> f4 b3) -> b2) -> b2) -> b) -> b) -> b1) -> f3 b1) -> f2 (f3 ((a -> (a -> (a1 -> (a1 -> (a2 -> f4 b3) -> b2) -> b2) -> b) -> b) -> b1)))) -> f1 (f2 (f3 b1))) -> f ((((f3 ((a ->
19:23:24 <lambdabot> (a -> (a1 -> (a1 -> (a2 -> f4 b3) -> b2) -> b2) -> b) -> b) -> b1) -> f3 b1) -> f2 (f3 ((a -> (a -> (a1 -> (a1 -> (a2 -> f4 b3) -> b2) -> b2) -> b) -> b) -> b1))) -> f2 (f3 b1)) -> f1 ((f3 ((a -> (a
19:23:24 <lambdabot> -> (a1 -> (a1 -> (a2 -> f4 b3) -> b2) -> b2) -> b) -> b) -> b1) -> f3 b1) -> f2 (f3 ((a -> (a -> (a1 -> (a1 -> (a2 -> f4 b3) -> b2) -> b2) -> b) -> b) -> b1))))) -> f (f1 (f2 (f3 b1)))
19:23:29 <neophyte> So, "Lamdax.phi(i,x)" mean "a function that takes x and returns phi(i,x)" So, it takes x as an input and returns the value of a function evaulated with two parameters?
19:23:32 <cmccann> bah, thought that would blow up worse :[
19:23:33 * djahandarie shows cmccann how to pm lambdabot
19:23:33 <alpounet> copumpkin, doesn't the http package handle this ?
19:23:36 <copumpkin> no
19:23:41 <cmccann> djahandarie, sorry :P
19:23:46 <copumpkin> I'll use download-curl
19:23:46 <Eduard_Munteanu> cmccann: /clear might do better
19:23:49 <Eduard_Munteanu> :)
19:23:56 <PatrickRobotham> neophyte: Yeah
19:24:11 <ion> There was some way to generate a type that took an insane amount of time to compute, but i don’t remember it.
19:24:12 * cmccann was just a bit late to the lambdabot abuse party
19:24:40 <Eduard_Munteanu> @vixen I guess you like it rough.
19:24:40 <lambdabot> yeah, i like
19:25:20 <PatrickRobotham> What's the @vixen command?
19:25:36 <kmc> neophyte, lambda is just a literal syntax for function-values, the way "3.0" is literal syntax for a floating point value
19:25:46 <alpounet> copumpkin, Network.Curl seems to handle this indeed
19:25:47 <Eduard_Munteanu> PatrickRobotham: you can talk to her
19:25:55 * kmc kind of wants to make a language where functions are first-class but all floats must be named at global scope
19:25:56 <copumpkin> alpounet: yeah, but Network.Curl has a fugly API :(
19:26:01 <alpounet> yup
19:26:01 <Eduard_Munteanu> @vixen Say hi to PatrickRobotham
19:26:02 <lambdabot> hiya
19:26:03 <PatrickRobotham> @vixen how do you do?
19:26:04 <lambdabot> how? it depends...
19:26:09 <alpounet> you could write a thin wrapper with a nicer API
19:26:24 <PatrickRobotham> @vixen Salutations!
19:26:25 <lambdabot> wait, back up
19:26:34 <shachaf> PatrickRobotham: There's also #haskell-blah for more extended conversations. :-)
19:27:05 <Eduard_Munteanu> She holds private sessions too :)
19:27:24 <hpaste> “C. McCann” pasted “i accidentally the whole type” at http://hpaste.org/49252
19:27:36 <cmccann> ion, there's an example
19:27:43 <cmccann> I recommend not loading that in GHCi
19:27:57 <cmccann> (though it's not too horrendous)
19:28:10 <dainanaki> I managed this evening to get a friend with no programming experience interested in trying out Haskell. Does anyone know of resources geared towards *total* beginners to programming?
19:28:23 <neophyte> Okay, so I think I understand that part now. Looking at definition 1 (found here: http://oi56.tinypic.com/20qhm5c.jpg) what does it mean when it says "if for all n in P_{2} there is a recursive function t such that n_{i} =Phi_{t(i)}"
19:28:24 <cmccann> dainanaki, LYAH is probably the obvious one
19:28:37 <cmccann> I don't think it assumes much, relatively
19:28:40 <Eduard_Munteanu> @where lyah
19:28:41 <lambdabot> http://www.learnyouahaskell.com/
19:28:44 <dainanaki> cmccann, it's still not quite low-level enough, I'm thinking
19:29:02 <dainanaki> it talks about variables, mutable state, etc. in the introduction
19:29:09 <neophyte> i take it "recursive function
19:29:18 <neophyte>  means computable function
19:29:48 <cmccann> dainanaki, just start with raw lambda calculus then, that's pretty low-level :P
19:30:48 <dainanaki> lol, well I know that some universities start their students out with haskell, so I figured there must be something out there for extra nooby noobs.
19:31:21 <djahandarie> dainanaki, there isn't anything good at that level, imo
19:31:26 <djahandarie> Been meaning to write something like that though
19:31:28 <kmc> neophyte, yeah, that's often what it means
19:31:31 <kmc> particularly in older literature
19:31:32 <cmccann> dainanaki, I think universities assume that the class itself will pick up the slack on any very basic things
19:31:40 <cmccann> rather than expecting the textbook to handle it all
19:31:42 <djahandarie> But I've been meaning to do that for awhile so that means it probably isn't going to happen
19:31:55 <alpounet> dainanaki, there isn't anything lower than LYAH
19:31:56 <dainanaki> actually, it looks like the Haskell wikibook might be the intro that I'm looking for
19:32:03 <alpounet> LYAH + some help from you should be good for your friend
19:32:12 <dainanaki> http://en.wikibooks.org/wiki/Haskell/Beginning
19:32:15 <dainanaki> even simpler than haskell
19:32:22 <dainanaki> * learn you a haskell
19:33:15 <cmccann> djahandarie, I've been tempted to start writing another introduction to Haskell myself but I'm not sure it'd be worthwhile :T
19:33:54 <shachaf> fix simplifyHaskellIntroduction
19:34:43 <djahandarie> cmccann, it definitely would be.
19:34:44 * hackagebot libxml-sax 0.7.1 - Bindings for the libXML2 SAX interface  http://hackage.haskell.org/package/libxml-sax-0.7.1 (JohnMillikin)
19:34:58 <djahandarie> It is the only barrier stopping Haskell from being a very first language to someone
19:35:10 <djahandarie> Someone who has never heard of programming or anything related to it before
19:35:11 <Eduard_Munteanu> Well, Wikibooks isn't all that newbie-friendly, or so I hear, on topics pertaining to Haskell
19:35:21 <cmccann> djahandarie, mostly not sure what sort of useful niche I could aim for, since there's no point in rehashing what's already out there
19:35:27 <dainanaki> actually untrue apparently
19:35:35 <bobzhang> does anybody try to let ghci pretty print the ADT?
19:35:45 <dainanaki> the beginner portions assume far less prior knowledge than I expected
19:36:11 <bobzhang> I learn haskell from YAHT :-)
19:36:22 <djahandarie> dainanaki, I don't like how it goes about it, also it's unfinished.
19:36:53 <dainanaki> it is indeed unfinished, but I don't have time to tutor my friend that much, and he's never programmed in his life.
19:37:02 <Eduard_Munteanu> bobzhang: you need to derive Show to be able to 'show' datatypes.
19:37:21 <bobzhang> Eduard_Munteanu: i know, the derived show is ugly
19:37:30 <alpounet> copumpkin, what have you been working on lately ?
19:37:57 <Eduard_Munteanu> bobzhang: ah. In that case, you might want to define your own Show instance
19:38:04 <copumpkin> alpounet: random proofs about things, the category theory library, bitcoins, fast array/stream processing, a few other projects
19:38:07 <copumpkin> alpounet: you?
19:38:46 <bobzhang> Eduard_Munteanu: there is a package pretty-show works well, Pretty.ppShow :: Show a => a -> String
19:38:53 <cmccann> djahandarie, if you have any thoughts on what's missing in the general domain of "introductions to Haskell" I'd be interested to hear it, though
19:39:01 <copumpkin> the Network.Curl API is wtf
19:39:13 <bobzhang> i wanna know anybody try to replace it with the derived show?
19:39:27 <edwardk> haskell for the working theoretician?
19:39:33 <djahandarie> cmccann, an introduction to the concept of computation from the Haskell angle. SICP is close to that but not on the money. (Also, it's in scheme of course.)
19:39:38 <alpounet> mostly partying... since my last exam :P but before that some hyperbolic geometry + continued fractions code, with graphics and all. I even attached the haskell code to the appendix of my thesis, that was fun to see my professors looking at it haha
19:39:49 <Eduard_Munteanu> edwardk: that'd be nice
19:40:08 <cmccann> edwardk, hahaha I don't know if I'd be qualified to write that myself but it sounds fun :P
19:40:17 <copumpkin> alpounet: cool
19:41:05 <djahandarie> cmccann, also, I think types should be introduced extremely earlier on.
19:41:06 <alpounet> copumpkin, however, i've been looking around for new stuffs in order to start working on a brand new version of hnn
19:41:41 <djahandarie> Which even LYAH doesn't really do.
19:41:47 <cmccann> djahandarie, hm, that is kind of an interesting thought.
19:41:57 <alpounet> copumpkin, what are you doing with bitcoins btw ?
19:42:13 <copumpkin> alpounet: everything!
19:42:29 <copumpkin> I got my company to pay my salary in them
19:42:42 <Eduard_Munteanu> Really?
19:42:45 <copumpkin> no
19:42:47 <Eduard_Munteanu> :)
19:42:58 <alpounet> yeah yeah
19:43:08 <alpounet> you can pay rents with bitcoins now
19:43:11 <shachaf> copumpkin: What's the dola-to-bitcoin exchange rate?
19:43:18 <copumpkin> shachaf: unknown
19:43:26 <shachaf> Ooh.
19:43:27 <copumpkin> alpounet: someone's actually selling an apartment in japan for bitcoins
19:43:37 <copumpkin> 3500 or something
19:43:43 <copumpkin> anyway
19:43:47 <copumpkin> as I was saying
19:43:49 <copumpkin> WTF
19:43:50 <cmccann> djahandarie, you thinking something roughly equivalent to SICP but from a more Haskell-flavored perspective? or something a bit further removed?
19:43:52 <alpounet> wow
19:43:53 <copumpkin> is the API for Network.Curl
19:44:09 <copumpkin> do people just not make https requests in haskell?
19:44:24 <djahandarie> cmccann, yes, something 'roughly equivalent' to it. I think it'd be very different as a result of adding the Haskell spice though. :)
19:44:27 <copumpkin> http://www.haskell.org/pipermail/beginners/2011-May/006966.html
19:44:49 <dmwit> shachaf: What's a "dola"?
19:44:57 <shachaf> dmwit: I'm not quite sure.
19:44:57 <cmccann> djahandarie, yeah, I'm thinking in the very general sense, the presentation would be wildly different
19:45:03 <shachaf> copumpkin pays in them, though.
19:45:41 <cmccann> djahandarie, I'm thinking it might be interesting to introduce system F as the starting point rather than untyped lambda calculus
19:45:55 <djahandarie> I'm not sure I'd do that
19:45:57 <alpounet> copumpkin, good luck seriously
19:46:01 <alpounet> i used it once
19:46:05 <copumpkin> Network.Curl?
19:46:07 <alpounet> yeah
19:46:09 <copumpkin> yeah
19:46:11 <alpounet> for simpler stuffs though
19:46:16 <copumpkin> I'm going to have to take a shower after this
19:46:26 <djahandarie> cmccann, I'd probably start directly with Haskell. In fact, Haskell with GADTs and such.
19:46:45 <shachaf> Caleskell.
19:46:51 <Eduard_Munteanu> Heh, because you just used Network.Curl or Haskell in general? :)
19:47:21 <cmccann> djahandarie, hm. I dunno, I kind of prefer starting with something more minimal and building from there, especially in an introduction to the concept of computation
19:47:25 <Eduard_Munteanu> You should totally write that binding in Agda :P
19:47:45 <djahandarie> cmccann, Haskell is as minimal as you want it to be, no?
19:47:50 <djahandarie> They won't know anything you don't tell them about
19:47:51 <Eduard_Munteanu> (pun intended)
19:48:52 <djahandarie> I wouldn't use System F to teach Haskell for the same reason I wouldn't use System F_C to teach Haskell
19:49:10 <Eduard_Munteanu> Indeed, the untyped lambda calculus might be a waste of time
19:49:46 <cmccann> I dunno, a lot of things in Haskell make more sense to me if I think of them as pragmatic approximations to something that could be expressed directly in a more powerful typed lambda calculus
19:50:59 <cmccann> the problem is that there's no good way to model that stuff directly in Haskell, which makes it awkward for teaching. :[
19:51:06 <Eduard_Munteanu> Like "oh, monads, those are like indexed monads, no?"? That's a bit weird :)
19:51:16 <kmc> a category is just a 1-category
19:51:23 <Eduard_Munteanu> Yeah, or that :)
19:52:44 <cmccann> meh, any lambda calculus still gives a concrete representation of computation, the general abstract nonsense is another matter
19:53:46 <cmccann> but I dunno, it's hard to judge what would actually work well and what's just me projecting my own idiosyncratic tastes onto others :T
19:54:27 <kmc> the lambda calculus is just one elementary example of a topos
19:54:37 <kmc> ;P
19:54:52 * kmc does not know anything else about topoi
19:55:12 <djahandarie> I wouldn't say it's a particularly good example
19:55:33 <djahandarie> Not even really an example
19:55:43 <kmc> i thought it was supposed to generalize that
19:55:46 <kmc> i guess it generalizes set theory?
19:56:26 <djahandarie> Well, an 'example' would be a category. The stlc isn't a category, but it can be used for reasoning about cartesian closed categories
19:58:08 <Eduard_Munteanu> Maybe the other way around? Using CCCs for reasoning about STLC?
19:58:23 <djahandarie> It goes both ways.
19:58:47 <djahandarie> Anyways, toposes are cartesian closed, but they have other stuff which makes the proper programming equiv. for them not the STLC
19:58:48 <Eduard_Munteanu> Hm, I guess so.
19:59:05 * cmccann would like to see an introduction to Haskell aimed at category theorists who don't know the first thing about programming
19:59:18 <djahandarie> I don't remember what it is, but they are at least locally certesian clsoed, so it'd be something closer to dependent types
19:59:21 <cmccann> not because it would be useful for me, but because it would be really interesting to see how it went about things
20:00:17 <djahandarie> It would be the programming dual of higher order intuitionistic logic
20:01:09 <Eduard_Munteanu> @where ttt
20:01:10 <lambdabot> Toposes, Triples and Theories: http://www.cwru.edu/artsci/math/wells/pub/ttt.html
20:01:19 * Eduard_Munteanu should look through it sometime ^
20:01:20 <copumpkin> so now I need to construct this post request
20:01:27 <copumpkin> I can't believe people don't need this :P
20:01:28 * cmccann actually has a dead tree edition of TTT :]
20:01:58 <copumpkin> oh wow
20:04:21 <cmccann> copumpkin, what are you trying to do :?
20:04:47 <copumpkin> cmccann: a simple https post request :(
20:05:53 <cmccann> which library are you using?
20:05:56 <kfish> copumpkin, you need the form encoding?
20:06:07 <copumpkin> yeah
20:06:25 <copumpkin> cmccann: looking at http-enumerator now, but was trying to brave the rainforest of Network.Curl before
20:06:42 <copumpkin> I'm about to run away screaming though
20:06:51 <cmccann> copumpkin, was gonna say, I thought http-enumerator handled that, but I guess not as well as you'd like
20:06:59 <copumpkin> no, it might
20:07:06 <copumpkin> but does it do form encoding?
20:07:14 <copumpkin> I guess even without form encoding it's better than curl
20:07:16 * copumpkin shudders
20:07:49 <cmccann> if it doesn't maybe there's another package that uses it that does?
20:08:20 <cmccann> I mean, its author has like five hundred packages or something :P
20:08:38 <copumpkin> :P
20:10:35 <copumpkin> kfish: any ideas about form encoding?
20:12:03 <copumpkin> oh wait
20:12:07 <copumpkin> looks like http-enumerator might support it
20:12:47 <kfish> copumpkin, nah sorry i guess i'd have just hacked it up before :(
20:12:55 <copumpkin> well, they call it urlEncodedBody :: Monad m => [(ByteString, ByteString)] -> Request m' -> Request m
20:13:01 <kfish> i don't know any libs off the top of my head
20:13:03 <copumpkin> not sure if that's actually the same thing, but I don't see what else they'd put in there
20:20:21 <copumpkin> and of course, it hangs
20:24:35 <parcs> any way to have cabal pass its PATH envvar to its calls to ghc?
20:26:14 <copumpkin> what's the easiest way to get a numerical representation of time?
20:26:24 <copumpkin> I really just need an IO call that returns a monotonically increasing number
20:26:40 <monochrom> all envvars are automatically copied to all spawned processes, no? therefore if cabal spawns ghc, PATH is copied, no?
20:26:44 <kmc> http://hackage.haskell.org/package/rdtsc -- copumpkin
20:26:49 <copumpkin> kmc: portable? :P
20:26:52 <kmc> :D
20:27:01 <kmc> but it's sooooooo fast
20:27:29 <fazzone> Does something like iterateM exist?  As in: fill in the blank: forever is to _ as iterate is to repeat
20:29:04 <kmc> :t sequence . repeat
20:29:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
20:29:25 <copumpkin> that won't work
20:29:28 <kmc> whether this is possibly useful depends on the monad
20:29:31 <parcs> copumpkin: Data.Time.Clock.POSIK and uh truncate
20:29:42 <copumpkin> won't always work
20:29:46 <HullNb> i dont understand divides d n = rem n d == 0
20:29:55 <fazzone> (Monad m) => (m a -> m b) -> a -> m [b]
20:29:59 <kmc> HullNb, okay, which part do you not understand
20:30:10 <kmc> read as:  divides d n = (rem n d == 0)
20:30:11 <copumpkin> fazzone: that doesn't really make sense
20:30:15 <fazzone> Maybe?  or maybe it should return [m b]
20:30:23 <copumpkin> (a -> m a) -> a -> m [a] maybe
20:30:27 <parcs> truncate, round, ceiling or whatever to convert to an integral
20:30:29 <monochrom> getCurrentTime gives UTCTime, which has a Day field and a DiffTime field. Day is Enum, DiffTime is Num, Real, blahblah
20:30:35 <HullNb> i can identify what is what? the only thing i have known is divides is a function
20:30:47 <kmc> divides is the function being defined
20:30:47 <copumpkin> but that would probably involve lazy IO
20:30:54 <HullNb> what is rem
20:30:54 <kmc> it's defined in terms of other functions "rem" and (==)
20:30:58 <kmc> remainder probably
20:31:04 <kmc> > rem 29 5
20:31:05 <lambdabot>   4
20:31:06 <HullNb> is it inbuilt
20:31:06 <fazzone> compumkin: That works also
20:31:08 <kmc> yes
20:31:22 <HullNb> poor guide didn't state that
20:31:31 <kmc> which guide?
20:31:34 <monochrom> so I would say, fromIntegral (fromEnum Day * 86401) + realToFrac DiffTime
20:32:01 <HullNb> The Haskell Road to Logic, Math and Programming Kees Doets and Jan van Eijck
20:32:01 <HullNb>  
20:32:05 <kmc> ok
20:32:17 <HullNb> is this right book
20:32:54 <kmc> that depends on your goals
20:33:18 <HullNb> kmc: my goal is to learn this language
20:33:20 <fazzone> Perhaps some context would help: I'm trying to do a running-sum sort of thing without IORef... I have updatePrintTotal x = ((+x) <$> read <$> getLine) >>= liftM2 (>>) print return
20:33:21 <kmc> Haskell?
20:33:29 <kmc> HullNb, see also LYAH and RWH
20:33:30 <kmc> @where LYAH
20:33:31 <lambdabot> http://www.learnyouahaskell.com/
20:33:32 <kmc> @where RWH
20:33:32 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
20:33:34 <kmc> pick the one you like the best
20:33:44 <HullNb> kmc: what is that?
20:33:48 <kmc> what is what
20:33:53 <kmc> see links above
20:33:57 <HullNb> ok i got it
20:34:19 <Axman6> fazzone: that's... horrible :(
20:34:36 <HullNb> should i remember the inuilt function first so that when they appear in program it will be easy to understand
20:34:39 <parcs> monochrom: the proper linker (wrt my PATH var) isn't being used through cabal for some reason
20:34:45 <fazzone> Axman6: Is it really that bad :( ?
20:35:02 <parcs> it instead uses /usr/bin/ld
20:35:09 <monochrom> I once tested controlling which linker to use by PATH and it worked
20:35:24 <parcs> it worked with cabal?
20:35:34 <Axman6> fazzone: clarity should always be preferred over cleaverness/conciseness imo
20:35:47 <monochrom> it worked with calling ghc directly
20:35:59 <parcs> oh same here
20:36:18 <parcs> but i'm looking to have it work through cabal
20:36:28 <monochrom> I have no reason to believe cabal calls linker independently. don't give too much credit to cabal
20:36:32 <fazzone> Axman6: I'll concede that liftM2 (>>) print return is rather opaque and cleverness-for-the-same-of-cleverness
20:36:49 <monochrom> it doesn't even bloody understand "import" lines in *.hs files
20:37:17 <Axman6> fazzone: also (+x) <$> read can be replaced with (+x)  . read
20:37:46 <ion> > (length "\\x -> x <$ print x", length "liftM2 (>>) print return")
20:37:47 <lambdabot>   (18,24)
20:38:28 <fazzone> I've never seen <$ before
20:38:58 <Axman6> :t \x -> x <$ print x
20:38:59 <lambdabot> forall a. (Show a) => a -> IO a
20:39:07 <ion> fazzone: http://heh.fi/haskell/functors/
20:39:08 <Axman6> :t (<$)
20:39:09 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
20:39:25 <Axman6> huh
20:39:31 <Axman6> :t ($>)
20:39:32 <lambdabot> Not in scope: `$>'
20:41:43 <ion> How would purevalue $> functorvalue even work? :-)
20:41:45 <kmc> ($>) would not be useful
20:41:47 <kmc> @src (<$)
20:41:48 <lambdabot> (<$) = (<$>) . const
20:43:52 <HullNb> can u share the links to haskell books again i got a system crash
20:43:58 <HullNb> the three links
20:44:05 <fazzone> So if you wanted to write iterateM :: (a -> m a) -> a -> m [a], how would you do it?  I feel like it should be simple, if questionably useful
20:44:23 <Eduard_Munteanu> @where lyah
20:44:23 <lambdabot> http://www.learnyouahaskell.com/
20:44:25 <Eduard_Munteanu> @where rwh
20:44:26 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
20:44:29 <Eduard_Munteanu> HullNb: ^
20:44:32 <HullNb> thank you
20:44:36 <HullNb> Eduard_Munteanu: tx
20:45:37 <aavogt> fazzone: you probably need a Int argument too
20:45:53 <fazzone> aavogt: what for?
20:46:25 <aavogt> suppose you supply a function like    (\x -> do print x; return x)
20:47:26 <aavogt> by saying the type is   IO [a], you're saying that all the printing has to happen before you can access the list
20:47:28 <Eduard_Munteanu> Presumably the underlying monad is lazy enough to admit a sane iterateM like that.
20:48:09 <fazzone> That's what I want to happen.  In this case, I don't even care about the lists, so I guess I actually want iterateM_ :: (a -> m a) -> a -> m ()
20:49:25 <aavogt> @type \f a0 -> do r <- newIORef a0; forever $ do a1 <- readIORef r; a2 <- f a1; writeIORef r a2
20:49:26 <lambdabot> Not in scope: `newIORef'
20:49:27 <lambdabot> Not in scope: `readIORef'
20:49:27 <lambdabot> Not in scope: `writeIORef'
20:51:26 <fazzone> aavogt: the whole point is to not use IORef!
20:51:48 <joe6> is there something like a concat . mapM ?
20:52:03 <joe6> i have some list of lists that I build using mapM
20:52:12 <joe6> and I want to concatenate that to a list
20:52:26 <parcs> is there anything useful to be done with newtype Foo a b = Foo (b -> a)
20:52:27 <joe6> I am currently doing x <- mapM ...; concat x
20:52:40 <fazzone> fmap concat ?
20:52:53 <joe6> fazzone: ok, thanks.
20:53:22 <joe6> fazzone: exactly what I need. thanks
20:53:29 <fazzone> I mean, it's exactly the same thing, just (imo) slightly slicker than using <- everywhere
20:56:03 <Eduard_Munteanu> :t join
20:56:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
20:56:44 <aavogt> @ty \a0 -> foldr (\f p -> do p1 <- p; f p1) (return a0) . repeat
20:56:46 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> (a -> m a) -> m a
20:57:04 <aavogt> fazzone: ^^
20:57:09 <dmwit> joe6: x <- mapM ...; y <- x; y
20:57:30 <Eduard_Munteanu> parcs: mm, exponential notation for function types?
20:58:28 <Eduard_Munteanu> b ^ a   =   a -> b
21:02:03 <fazzone> aavogt: brb, comprehending
21:10:48 <kmc> parcs, well, (Foo a) is a contravariant functor
21:10:56 <kmc> dunno if that's useful
21:11:26 <kmc> also Foo is a Category, no?
21:11:32 <kmc> backwards composition
21:11:46 <kmc> in fact
21:11:59 <kmc> newtype Op (~>) a b = Op (b ~> a)
21:12:25 <kmc> instance (Category c) => Category (Op c) where { id = Op id; Op f . Op g = Op (g . f) }
21:12:30 <kmc> type Foo = Op (->)
21:13:45 <ion> > let iterateM f x = liftM (x:) . iterateM f =<< f x in runIdentity . iterateM (Identity . succ) $ 0
21:13:50 <lambdabot>   mueval-core: Time limit exceeded
21:14:42 <ion> > let iterateM f x = liftM (x:) . iterateM f =<< f x in runIdentity . iterateM (Identity . succ) $ 0
21:14:45 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
21:14:58 <kurtosis> Haskell newbie; this tutorial has as an exercise for me to count the number of lowercase letters in a string, using two of the functions discussed (which are basically foldr, filter, head, map, and Char.isLower). my attempt was foldr (+) (filter Char.isLower "abCDe") but that didn't work. I guess that doesn't make much sense but I can't figure out how to convert the True/False to ints, or how else they want me to do this
21:15:13 <kmc> did they give you "length"?
21:15:36 <kmc> you should avoid using "head" by the way; pattern matching is usually better
21:16:03 <kmc> (+) is also a function, i guess it's in the list you can use
21:16:12 <kmc> anyway maybe you should try to write length using foldr, (+), and 0
21:17:09 <ion> Of course, that iterateM doesn’t work if the (>>=) does pretty much anything. :-)
21:17:17 <kurtosis> kmc: oh yeah, I didn't notice that I had length, thanks :D I'm not sure how I would write length using foldr, (+) and 0, as the best thing I can think of is foldr (+) 0 list but I suppose that would try to add the list elements, not count them
21:17:49 <kmc> right
21:17:51 <kmc> foldr (+) 0 = sum
21:18:01 <kmc> :t foldr
21:18:02 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
21:18:07 <kmc> :t foldr (\_ n -> n+1) 0
21:18:08 <lambdabot> forall a b. (Num b) => [a] -> b
21:18:18 <kmc> :t foldr (const (+1)) 0
21:18:19 <lambdabot> forall a a1. (Num a) => [a1] -> a
21:18:27 <kmc> like so kurtosis
21:18:54 <kmc> > (foldr (\_ n -> n+1) 0) "hello world"
21:18:55 <lambdabot>   11
21:19:12 <dmwit> foldr (+) 0 . map (const 1)
21:19:32 <kmc> :t sum . (. 1)
21:19:34 <lambdabot> forall a b. (Num b, Num [a]) => (a -> b) -> b
21:19:37 <kmc> ;P
21:19:39 <kurtosis> kmc: ah, thanks for your help. I haven't learned that syntax yet
21:19:41 <kmc> not a reasonable suggestion
21:19:54 <kmc> kurtosis, which syntax? the lambda expression (\_ n -> n+1) ?
21:19:59 <kurtosis> yeah
21:20:02 <kmc> ok
21:20:17 <ion> Wouldn’t foldl' actually be more appropriate here, since the expression uses the accumulator strictly?
21:20:21 <kmc> it evaluates to a function which takes one arg, throws it away, takes another arg n, and returns n+1
21:20:36 <kmc> ion, yes
21:20:58 <kurtosis> kmc: ah, i see, cool
21:21:31 <kmc> kurtosis, you can instead write "length = foldr f 0 where f _ n = n+1"
21:21:48 <kmc> but we tend to avoid naming things that don't need names
21:22:36 <applicative> > let characteristic x = if isLower x then 1 else 0; kurtosis xs = foldr (+) 0 (map characteristic xs ) in kurtosis "ABC abc"
21:22:37 <lambdabot>   3
21:23:08 <kmc> :t foldMap
21:23:09 <lambdabot> Not in scope: `foldMap'
21:23:11 <kmc> skewness++
21:23:26 <kmc> :t foldMapR
21:23:27 <lambdabot> Not in scope: `foldMapR'
21:23:31 <kmc> oh right
21:23:33 <kmc> :t mapAccumR
21:23:34 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
21:23:42 <ion> :t Data.Foldable.foldMap
21:23:43 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
21:24:44 <skewness> that's basically a mealy machine isn't it
21:25:02 <skewness> or a function that runs one
21:25:42 <om-foxy> How does one obtain a `UniqSupply` from the GHC API?  `HscEnv` does not have unique supply.
21:28:19 <ion> > ala Sum Data.Foldable.foldMap $ 1 <$ "o hai"
21:28:20 <lambdabot>   5
21:35:39 <ion> > unpack . Data.Foldable.foldMap (Sum . const 1) $ "o hai"
21:35:41 <lambdabot>   5
21:35:56 <feste> Hi. I was wondering if anyone here had advice on using C types in Haskell.  Ideally I'd like to use a [CDouble] and a function f :: [Double] -> Double together.  Is there any way to make this happen?  :)
21:36:20 <skewness> man
21:36:32 <skewness> I fucking hate the lazy/strict bytestring distinction
21:36:48 <kmc> :t realToFrac -- feste
21:36:48 * skewness complains aimlessly some more
21:36:49 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
21:37:23 <ion> > (realToFrac :: CDouble -> Double) 42
21:37:24 <lambdabot>   Not in scope: type constructor or class `CDouble'
21:37:37 <feste> aaah thank you!!
21:41:12 <HullNb> hello i want to ask is haskell worth learning
21:41:32 <sully> no.
21:41:33 <HullNb> what experiences i would get by learning haskell
21:41:43 <kmc> @faq Can Haskell cause experiences?
21:41:43 <sully> all of us hate haskell, which is why we are here :P
21:41:44 <lambdabot> The answer is: Yes! Haskell can do that.
21:42:04 <kmc> HullNb, the experience of code that works right the first time it compiles
21:43:07 <kmc> HullNb, why are you interested in the first place?
21:43:19 <ion> @vixen Is Haskell worth learning?
21:43:20 <lambdabot> Ooh, functional programmers are so hot!
21:44:05 <HullNb> kmc: interested in functional programming
21:44:08 <kmc> why?
21:44:43 <kmc> Haskell is not a simple or typical functional language, but it is where a lot of cool things in that general space happen
21:46:12 <HullNb> kmc: funtional programming is unqiue than other one
21:46:32 <kmc> the thing about FP is that it's only been "mainstream" for a few years, but is older than computers themselves
21:47:11 <HullNb> kmc: im greatly impressed by its style of programming and very short code,less prone for human error
21:47:12 <kmc> so imagine a lineage of people who decided FP was cool back in 1950 and have been off in their own world doing other things in that general vein ever since
21:47:59 <HullNb> kmc: is lisp and haskell same?
21:48:01 <kmc> no
21:48:04 <kmc> they are very different
21:48:09 <kmc> > "lisp" == "haskell"
21:48:11 <lambdabot>   False
21:48:12 <variants> hmm
21:48:23 <variants> anyone have any ideas what it could mean if my http-enumerator request just hangs?
21:48:30 <kmc> HullNb, I think you should read more about lisp and haskell, rather than asking here
21:48:36 <ion> > lisp == haskell
21:48:38 <lambdabot>   True
21:48:51 <kmc> @smack lambdabot
21:48:51 * lambdabot smacks lambdabot about with a large trout
21:49:23 <HullNb> kmc: yeah that im looking wiki
21:54:13 <prashant_> hi good morning every one
21:55:24 <Eduard_Munteanu> Hi.
21:55:28 <HullNb> ane thing that i should keep in mind while learning haskell
21:56:09 <prashant_> nothing !!
21:58:33 <prashant_> ( just joking !!)
21:59:19 <kmc> HullNb, keep in mind that we're always here to help with specific questions
21:59:32 <prashant_> I am an erlang programmer. How much time will i need to start coding in haskell?
21:59:40 <kmc> a lot
21:59:42 <applicative> minutes
21:59:53 <applicative> > 1 + 2 * 3
21:59:53 <lambdabot>   7
22:00:08 <prashant_> you mean steep learning curve !
22:00:09 <kmc> it's a really vague question
22:00:12 <applicative> > map (1+) [1,2,3]
22:00:13 <lambdabot>   [2,3,4]
22:00:38 <applicative> > zip [1..] ['a'..'z']
22:00:38 * Eduard_Munteanu looks up something with "Yoneda" and "Codensity" to paste in here... :P
22:00:39 <lambdabot>   [(1,'a'),(2,'b'),(3,'c'),(4,'d'),(5,'e'),(6,'f'),(7,'g'),(8,'h'),(9,'i'),(1...
22:00:46 <HullNb|3> kmc: yeah i got it
22:00:46 <kmc> what do you use Erlang for now? how well do you know it? what other languages do you know, and how well? what's your general experience learning programming languages in the past?
22:00:53 <kmc> what do you want to use Haskell for?
22:01:09 <kmc> how much time do you have for studying Haskell? how motivated are you?
22:01:11 <prashant_> so many questions!
22:01:28 <prashant_> i am an enthusiast! not bothered much about what to use it for
22:01:37 <HullNb|3> kmc: lambdabot:  thx for help guys really appreciate
22:01:47 <codensity> prashant_: just learn it, its strange and wonderful.  Life is not worth living if you don't have the ghc in your backpack
22:01:58 <prashant_> erlang I am building an high availability Zookeper equivalent
22:02:29 <bos31337> does anyone know how to pass an argument containing embedded spaces to ghc in a .cabal file?
22:03:57 <Eduard_Munteanu> @where lyah
22:03:57 <lambdabot> http://www.learnyouahaskell.com/
22:15:05 <Axman6> prashant_: haskell is quite different to erlang. the main advantage of erlang, easy distributed concurrency is pretty easy to implement in haskell for the most part, and the rest is a current research topic (replicating most of what you can do with erlang has been implemented in the cloud haskell project). the advantages haskell gives you are things like a proper type system (one of the best of any language tht currently exists), fast code, v
22:15:24 <kmc> distributed concurrency is not easy in Haskell
22:15:39 <kmc> concurrency on a single node is very nice
22:15:46 <kmc> i may be behind on that research though
22:15:58 <Axman6> check out the cloud haskell stuff, it's pretty cool
22:16:14 <prashant_> alright
22:16:30 <Axman6> prashant_: to get started, check out LYAH, linked above
22:16:53 <kmc> also check out RWH
22:16:55 <kmc> @where RWH
22:16:55 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
22:17:03 <feste> kmc lambdabot and ion: you are all awesome! :)
22:17:15 <Axman6> check out RWH once you've learnt the basics from LYAH imo ;)
22:17:29 <Axman6> @vixen you're awesome!
22:17:30 <lambdabot> yeah, pretty spectacular, huh?
22:17:44 <Eduard_Munteanu> What's distributed concurrency exactly? Something more NUMA-ish / cluster-ish?
22:18:04 <prashant_> interesting thing erlang in haskell.  :)
22:18:07 <Axman6> anything more than a single machine
22:18:29 <Eduard_Munteanu> I see.
22:18:52 <gienah> haskell has software transactional memory, strong typing, in addition to the erlang like messaging in cloud haskell/remote
22:18:54 <ion> axman6: exists), fast code, v$
22:19:13 <Axman6> ion?
22:19:26 <ion> Your IRC client didn’t split the line when it reached the maximum length.
22:19:44 <Axman6> bleh
22:19:47 <gienah> the other process monitoring like stuff in the erland OTP is currently missing, I think we can implement some of these in time
22:19:53 <kmc> NUMA i would not consider "distributed" at the level of high-level languages
22:19:54 <Axman6> there must be a setting for that in irssi...
22:20:03 <Axman6> "very high performance concurrency and parallelism on an SMP machine and... lots more"
22:20:07 <kmc> of course it is distributed at the hardware level, but the point of NUMA is for the OS to handle that for you as much as possible
22:20:18 <Axman6> yeah
22:20:37 <kmc> to me "distributed" primarily means "not shared memory"
22:20:38 <Eduard_Munteanu> Ah, I kinda wanted to cover the distributed software that's intended to run on the same machine aspect.
22:20:50 <kmc> though sufficiently slow shared memory schemes (swap over NFS anyone?) might count
22:20:51 <ion> axman6: Irssi comes with splitlong.pl. Debian or its derivative? /usr/share/irssi/scripts/splitlong.pl. mkdir ~/.irssi/scripts && cd ~/.irssi/scripts && ln -fs . autorun && ln -s /usr/share/irssi/scripts/splitlong.pl . and /script load splitlong
22:20:55 <Eduard_Munteanu> (like monolithic vs micro)
22:21:11 <Eduard_Munteanu> I suppose distributed concurrency covers that as well.
22:21:52 <gienah> cloud haskell/remote is messaging passing, it does not have distributed memory
22:23:37 <prashant_> somebody just mentioned about transactional memory here! is there in haskell VM ? ( one stupid question is it distributed?)
22:23:51 <prashant_> *is it there
22:23:55 <Axman6> no to both...
22:24:27 <Eduard_Munteanu> Haskell VM?
22:24:29 <Axman6> haskell has software transactional memory which is used between concurrent haskell threads
22:24:30 <gienah> prashant_: http://book.realworldhaskell.org/read/software-transactional-memory.html
22:26:06 <prashant_> thanks gienah :) Also I was broswing through GHC trac.. how far before we have cloud haskell in production
22:26:25 <gienah> stm is really neat, this chapter in beautiful code describes how the stm implementation in haskell allows functions to compose: http://research.microsoft.com/~simonpj/papers/stm/#beautiful
22:26:59 <gienah> prashant_: 12 to 15 months
22:30:33 <Eduard_Munteanu> Oh, Haskell in Beautiful Code?
22:30:34 <kmc> the RWH chapter on STM is also good
22:30:43 <Eduard_Munteanu> I suppose I missed it back then.
22:31:02 <Axman6> prashant_: there's a hell of a lot more cool stuff in haskell than stuff like cloud haskell, i just thought I'd mention it since you said you were oming from an erlang background
22:31:02 * Eduard_Munteanu needs to get it back from a friend
22:31:08 <gienah> Eduard_Munteanu: its a really cool chapter, it is what got me originally interested in Haskell
22:31:23 <prashant_> gienah: thats really nice. I am just introduced to this. I would look forward to , If there is something I can contribute. I was trying to find a mailing list for Erlang in haskell project
22:32:27 <gienah> prashant_: maybe the parallel haskell mailing list (even though cloud haskell is a concurrency thing)
22:32:37 <prashant_> yeah Thanks Axman, I found it interesting
22:34:07 <gienah> prashant_: it would be neat if there were more things from the Erlang OTP that used cloud haskell
22:35:01 <cspell> hello?
22:35:06 <Eduard_Munteanu> I lent it to a friend quite some time ago and forgot to get it back :)
22:35:12 <Eduard_Munteanu> cspell: hi
22:35:31 <cspell> what's this chat room for?
22:35:48 <Eduard_Munteanu> A programming language. See /topic
22:35:49 <luite> for the amazing, one and only, haskell programming language!
22:36:03 <cspell> hi thanks
22:36:09 <Eduard_Munteanu> I guess my answer wasn't as enthusiastic.
22:36:15 <cspell> what are some of the benifits to this language?
22:36:46 <cspell> it seems a lot like ruby or python
22:36:50 <prashant_> gienah: as in?
22:37:01 <cspell> this is my first time checking it out
22:37:26 <cspell> well it's a command interpreter right?
22:37:54 <cspell> so far I have only tried the basic mathmatics string entry and sort function
22:37:57 <luite> there's a compiler. the interpreter is usually only used for debugging and development
22:37:58 <Eduard_Munteanu> It's not really a lot like Ruby or Python, though some aspects might leave you that impression.
22:38:24 <cspell> so are there type defs
22:38:26 <gienah> prashant_: the process monitoring stuff in erlang OTP would be obviously useful, cloud haskell is really neat, so whatever you are interested in programming I'm sure would be useful
22:38:33 <Eduard_Munteanu> cspell: did you come from tryhaskell?
22:39:02 <cspell> yeah I am trying the html trial
22:39:16 <cspell> by Chris Done
22:39:40 <luite> unfortunately tryhaskell is rather limited
22:40:05 <cspell> so I can program in real time to debug and then compile the source?
22:40:20 <cspell> or is that just the html version?
22:40:23 <luite> yeah, but you need to install the haskell platform on your own pc for that
22:40:47 <Eduard_Munteanu> @where platform
22:40:47 <lambdabot> http://hackage.haskell.org/platform/
22:40:50 <luite> you get an interpreter with a REPL
22:40:53 <luite> ghci
22:41:46 <cspell> ok thanks I'll check it out
22:41:52 <prashant_> gienah:As you said, I was thinking of process monitoring in erlang. Would be good if you could mention a use case. :)
22:43:35 <gienah> prashant_: the process monitoring can ping nodes in a distributed application, if the node fails to respond within a timeout then the processing monitoring framework can log errors
22:43:48 <gienah> with distributed logging, and restart the failed node
22:44:08 <prashant_> you can build a ring of message passing for this
22:44:25 <prashant_> again I am not sure
22:44:25 <gienah> prashant_: ok, sounds neat
22:44:45 <ion> The OTP stack can even automatically restart processes on remaining nodes if a computer disappears. And of course, only the parts of the supervision tree that depend on those processes are restarted along with them.
22:44:53 <gienah> prashant_: of course we can steal good ideas from the erlang OTP
22:45:11 <prashant_> yeah !!
22:45:51 <gienah> imitation is the sincerest form of flattery
22:46:11 <prashant_> nice !!
22:46:19 <ion> Erlang also has a brilliant implementation of runtime code upgrades.
22:46:35 <ion> Brilliant in its utter simplicity.
22:46:46 <gienah> ion: hmm, that might be difficult to implement in haskell
22:47:07 <feste> Is there a way to get a Double instead of an IO(Doulbe)?  Or is that a silly question?
22:47:09 <ion> gienah: Indeed. Erlang’s dynamic typing helps in this case.
22:47:31 <shachaf> feste: Sure, here's a Double for you: 4.4
22:47:49 <prashant_> tell me does haskell have same style of immutable objects as erlang?
22:47:52 <kmc> feste, you can't convert IO Double to Double, because they mean fundamentally different things
22:47:56 <Eduard_Munteanu> feste: a bit :), if you mean how to get a Double from an IO Double
22:48:10 <kmc> an IO Double is not a number, it's a description of how you could perform some IO to produce a number
22:48:18 <ion> feste: (ioAction >>= \n -> use n here) generates a new IO action that, when executed, gives your code the double.
22:48:22 <kmc> the IO has not yet happened; it might never happen, or it might happen more than once with different results
22:48:30 <kmc> read "introduction to IO" on the haskell wiki
22:48:31 <Eduard_Munteanu> As in, that's not what you want to do.
22:48:31 <ion> :t (>>=)
22:48:33 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
22:49:02 <ion> IO action resulting in a -> (a function that takes an a and returns an IO action resulting in b) -> IO action resulting in b
22:49:03 <feste> hmm. so if i have a storable array with some values, is there any way i can give those values to a pure function?
22:49:03 <gienah> prashant_: the cloud haskell thesis mentions some stuff on process monitoringn on p34: http://www.cl.cam.ac.uk/~jee36/thesis.pdf
22:49:13 <kmc> feste, yes, but the result of doing so is still an IO action
22:49:20 <kmc> fmap :: (a -> b) -> IO a -> IO b
22:49:33 <kmc> fmap pureFunction ( readArray whatever )
22:49:50 <kmc> read "introduction to IO" on the haskell wiki
22:50:36 <prashant_> gienah: I will check it out. :)
22:50:38 <feste> so i turn my pure function into one that is not pure?
22:50:56 <kmc> well, they're all pure functions really
22:51:01 <feste> :)
22:51:02 <kmc> some pure functions return descriptions of how to do IO
22:51:07 <kmc> they don't perform the IO
22:51:12 <kmc> read "introduction to IO" on the haskell wiki
22:51:19 <feste> ooooh ok. thank you!
22:51:38 <feste> will do.  sorry about the silly questions.
22:51:56 <kmc> no it's not silly, quite common in fact :)
22:52:56 <feste> :) thanks kmc
22:53:20 <ion> > 42 `const` putStrLn "o hai"  -- Completely safe and side-effect free because the IO action (which is just a value) never gets assigned (directly or via IO combinators) to “main”.
22:53:22 <lambdabot>   42
22:53:54 <ion> > putStrLn "o hai"  -- Will not be executed (i.e. assigned to “main”) by lambdabot
22:53:56 <lambdabot>   <IO ()>
22:54:59 <ion> lambdabot just says “this is an IO action that, if executed, would result in ()”
22:55:12 <kmc> that's not a standard Show instance, though
22:55:23 <kmc> the point is that evaluation and execution are distinct processes
22:57:12 <ion> If you run putStrLn "foo" in ghci, on the other hand, it will have a chain of IO actions from its “main” that will end up executing your IO action. 42 `const` putStrLn "foo" will not execute the IO action because const just discards the second value.
23:28:40 <feste> So my problem is a little stranger than I thought.  If I have [IO Double], how can I interact with a function with parameter [Double]?
23:29:05 <Axman6> sequence
23:29:12 <Axman6> :t sequence (undefined :: [IO Double])
23:29:13 <lambdabot> IO [Double]
23:29:32 <feste> cool!
23:30:02 <luite> don't try that with infinite lists though
23:30:25 <feste> thanks for the tip luite
23:30:28 <kmc> right, not with IO
23:30:34 <kmc> it works in some monads, though
23:31:06 <kmc> i mean technically there are a whole bunch of ways to use that [IO Double]
23:31:17 <kmc> it's a list of actions which have not yet been performed
23:31:20 <ion> runIdentity . sequence . repeat . Identity $ 1
23:31:23 <ion> > runIdentity . sequence . repeat . Identity $ 1
23:31:25 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
23:31:28 <kmc> you have the freedom to reorder the actions or perform some more than once or drop others
23:31:40 <kmc> but usually people just want to perform them in order, once each
23:31:53 <kmc> it's important to understand why you have that freedom, though.  and why you don't have it with IO [Double]
23:33:16 <feste> coool
23:33:54 <feste> hopefully this is my last issue:  now I want to get a CDouble from the Double I returned.  Any tips?
23:34:06 <kmc> :t realToFrac
23:34:07 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
23:34:18 <kmc> and i promise that won't be your last question ever about Haskell :)
23:34:23 <feste> oh wow that works the other way round.  cool!  i guess that makes sense
23:34:25 <kmc> but you're welcome to keep asking them as long as you like
23:34:28 <feste> haha no, just for this program
23:34:31 <kmc> :D
23:34:40 <kmc> yep, afaik both CDouble and Double are in both the Real and Fractional type classes
23:34:42 <luite> feste: the other one you'll want to know about for converting numbers is fromIntegral
23:34:49 <feste> definitely the best channel experience i've had so far though.
23:35:05 <feste> luite: i actually used that one earlier in my program!
23:35:09 <kmc> @quote monochrom fromIntegral
23:35:09 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
23:35:15 <luite> feste: ah good :)
23:35:27 <feste> :)
