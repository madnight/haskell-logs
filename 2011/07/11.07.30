00:15:17 <flamingspinach> kelvie_: google tells me you were writing Haskell bindings for Qt Declarative - anything come of it?
01:03:51 <MHD> Isnt there some simple concurrent lock
01:04:02 <MHD> like just a boolean semaphore
01:05:32 <copumpkin> MVar ()?
01:08:02 <MHD> yeah I was thinking that
01:08:09 <MHD> but it feels hacky
01:13:04 * copumpkin shrugs
01:30:02 <drbean> let m = flip elem [0..10]
01:30:12 <drbean> let f = flip elem [11..20]
01:30:16 <coppro> do you want >
01:30:36 <drbean> > let f = flip elem [11..20]
01:30:37 <lambdabot>   not an expression: `let f = flip elem [11..20]'
01:31:00 <Cale> > let f = flip elem [11..20] in f 4
01:31:01 <lambdabot>   False
01:31:05 <Cale> > let f = flip elem [11..20] in f 15
01:31:07 <lambdabot>   True
01:31:47 <drbean> @pl f x
01:31:47 <lambdabot> f x
01:33:17 <Cale> @pl \a b c -> a b (a b c)
01:33:17 <lambdabot> ap =<< ((.) .)
01:34:46 <drbean> @pl x -> f x
01:34:46 <lambdabot> (line 1, column 3):
01:34:46 <lambdabot> unexpected ">" or "-"
01:34:46 <lambdabot> expecting variable, "(", operator or end of input
01:35:06 <drbean> @pl \x -> f x
01:35:06 <lambdabot> f
01:36:21 <Cale> @pl \x -> f (g x)
01:36:21 <lambdabot> f . g
01:36:50 <Cale> @pl \x -> f x (g x)
01:36:50 <lambdabot> ap f g
01:38:09 <Cale> @pl \e -> f (x e) e
01:38:09 <lambdabot> f =<< x
01:39:09 <Cale> @pl \e -> f (x e) (y e)
01:39:09 <lambdabot> liftM2 f x y
01:39:31 <ion> @pl \a b c d e f g -> g a f b e d c
01:39:31 <lambdabot> ((flip . ((flip . ((flip . (flip .)) .)) .) . flip . ((flip . (flip .)) .) . flip . (flip .)) .) . flip . (flip .) . flip . flip id
01:41:45 <coppro> Define a permutation lambda as a lambda on n arguments, the result of which is some permutation of those arguments.
01:42:12 <Cale> @pl \a b c d e f g h i j k l m n o p q r s t u v w x y z -> w h y h e l l o t h e r e w o r l d
01:42:12 <coppro> What is the maximum number of uses of `flip` in the minimal point-free definition of a permutation lambda?
01:42:15 <lambdabot> const (const (const ((const .) . (const .) . ((const .) .) . ((const .) .) . ((const .) .) . (((const .) .) .) . (((const .) .) .) . ((((const .) .) .) .) . ((((const .) .) .) .) . (((((const .) .) .
01:42:15 <lambdabot> ) .) .) . ((((((const .) .) .) .) .) .) . ((((((const .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . ((((((((const .) .) .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .)
01:42:15 <lambdabot>  .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . flip flip id . (ap .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . (
01:42:15 <lambdabot> (((((flip .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((ap .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . flip (flip . (flip .) . ((ap .)
01:42:15 <lambdabot> .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((ap .) .)
01:42:17 <lambdabot> [4 @more lines]
01:42:19 <lambdabot> optimization suspended, use @pl-resume to continue.
01:42:23 <ion> @pl-resume
01:42:29 <lambdabot> const (const (const ((const .) . (const .) . ((const .) .) . ((const .) .) . ((const .) .) . (((const .) .) .) . (((const .) .) .) . ((((const .) .) .) .) . ((((const .) .) .) .) . (((((const .) .) .
01:42:29 <lambdabot> ) .) .) . ((((((const .) .) .) .) .) .) . ((((((const .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . ((((((((const .) .) .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .)
01:42:29 <lambdabot>  .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . flip flip id . (ap .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . (
01:42:29 <lambdabot> (((((flip .) .) .) .) .) .) . flip flip id . (flip .) . ((flip .) .) . (((ap .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . flip flip id . (flip .) . ((
01:42:31 <lambdabot> ap .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((
01:42:33 <lambdabot> [4 @more lines]
01:42:35 <lambdabot> optimization suspended, use @pl-resume to continue.
01:42:44 <Cale> (please don't ;)
01:42:47 <ion> :-D
01:42:54 <shachaf> You mean that wasn't a command?
01:43:31 <ion> What’s the difference between @more and @pl-resume in that case?
01:45:30 <ClaudiusMaximus> @type \a b c d e f g h i j k l m n o p q r s t u v w x y z -> w h y h e l l o t h e r e w o r l d
01:45:31 <lambdabot>     Occurs check: cannot construct the infinite type:
01:45:31 <lambdabot>       t
01:45:31 <lambdabot>       =
01:46:19 <Cale> coppro: Well, the number of flips in the response by @pl there was exactly the number of transpositions required to sort the list
01:46:39 <coppro> Cale: well done
01:48:24 <ClaudiusMaximus> could @pl potentially give infinite output for mal-typed terms?
01:48:36 <coppro> they're type-checked first
01:48:56 <Cale> they aren't
01:48:59 <coppro> @hoogle a -> (a -> b) -> b
01:48:59 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
01:49:00 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
01:49:00 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
01:49:08 <coppro> ...
01:49:10 <Cale> @pl \x -> x x
01:49:10 <lambdabot> join id
01:49:23 <coppro> huh
01:49:27 <Cale> @pl (\x -> x x)(\x -> x x)
01:49:27 <coppro> cool
01:49:30 <lambdabot> ap id id (ap id id)
01:49:30 <lambdabot> optimization suspended, use @pl-resume to continue.
01:49:30 <coppro> > join id
01:49:31 <lambdabot>   Occurs check: cannot construct the infinite type: m = (->) (m a)
01:49:59 <coppro> task for this weekend to myself: work through the (-> r) monad
01:50:28 <coppro> flip id is such a useful function
01:50:29 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "have fun"
01:50:30 <lambdabot>   ("have fun","nuf evah","HAVE FUN")
01:51:22 <ion> coppro: The types, when specialized, dictate only one sensible behavior for each function.
01:51:54 <coppro> ion: I imagine
01:51:55 <ion> coppro: I’ve written the specialized version of the types for a few of the functions here: http://heh.fi/haskell/functors/#function-instance
01:52:01 <coppro> hence I will attempt to go understand it
01:53:56 <coppro> although why in particular @pl prefers flip id to flip ($) I may not know.
01:53:58 <ion> @djinn (a -> x -> b) -> (x -> a) -> x -> b
01:53:58 <lambdabot> f a b c = a (b c) c
01:54:08 <ion> :t (=<<)
01:54:09 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
01:54:11 <coppro> @src ($)
01:54:11 <lambdabot> f $ x = f x
01:54:14 <coppro> boo
01:54:30 <ClaudiusMaximus> @src ($!)
01:54:30 <lambdabot> f $! x = x `seq` f x
01:54:34 <coppro> that should totally be ($) :: (a -> b) -> a -> b; ($) = id
01:55:36 <ClaudiusMaximus> that should be f $! !x = f $ x for symmetry or something
01:56:36 <ClaudiusMaximus> woe, doesn't work
01:56:49 <ion> :t \($!) f x -> f $! !x
01:56:50 <lambdabot> parse error on input `!'
01:56:52 <ion> :t \($!) f x -> f $! (!x)
01:56:53 <lambdabot> forall t i e t1. (Ix i) => (t -> (Array i e -> e) -> t1) -> t -> i -> t1
01:57:11 <ion> Err, brainfart.
01:57:46 <ion> :t \f !x -> f x
01:57:46 <coppro> @pl \f x = x `seq` f x
01:57:46 <lambdabot> (line 1, column 6):
01:57:46 <lambdabot> unexpected "="
01:57:46 <lambdabot> expecting pattern or "->"
01:57:47 <lambdabot> Illegal bang-pattern (use -XBangPatterns)
01:57:57 <coppro> @pl \f x -> x `seq` f x
01:57:57 <lambdabot> ap seq
01:58:56 <coppro> :t seq
01:58:57 <lambdabot> forall a t. a -> t -> t
01:59:00 <coppro> oh god
02:00:20 <coppro> :t ap seq
02:00:20 <lambdabot> forall a a1. (a -> a1) -> a -> a1
02:00:43 <coppro> hrm
02:01:12 <coppro> I don't quite follow
02:01:50 <coppro> seq is a -> t -> t. ap in the (-> r) monad is (a -> b -> r) -> (a -> r) -> b -> r
02:02:04 <coppro> so shouldn't you get (a -> t) -> t -> t?
02:04:04 <coppro> @src ap
02:04:04 <lambdabot> ap = liftM2 id
02:04:23 <ClaudiusMaximus> did you want ((->) r) = (r ->) instead of (-> r) ?
02:04:28 <dibblego> @type ap :: (a -> b -> c) -> (a -> b) -> a -> c
02:04:29 <lambdabot> forall a b c. (a -> b -> c) -> (a -> b) -> a -> c
02:04:43 <coppro> ClaudiusMaximus: wow, brainfart day today
02:04:58 <ClaudiusMaximus> or am i confused too
02:05:07 <coppro> no, you're quite correct
02:05:19 <dibblego> "ap in the (-> r) monad is (a -> b -> r) -> (a -> r) -> b -> r" -- no, this is the mistake
02:05:26 <coppro> (-> r) is not a monad
02:05:39 <copumpkin> (-> r) isn't a valid haskell type, either
02:05:56 <copumpkin> if it were, it'd at least be a contravariant functor
02:06:16 <copumpkin> in other news, I'm up way too early
02:06:42 <coppro> @src Monad ((->) r)
02:06:43 <lambdabot> Source not found. The more you drive -- the dumber you get.
02:06:47 <coppro> aww
02:07:15 <shachaf> @src (->) (>>=)
02:07:15 <lambdabot> f >>= k = \ r -> k (f r) r
02:07:17 <shachaf> @src (->) return
02:07:17 <lambdabot> return = const
02:07:53 <dibblego> @src (->) (<*>)
02:07:53 <lambdabot> (<*>) f g x = f x (g x)
02:11:35 <coppro> where is Monad ((->) r) defined?
02:12:50 <dibblego> Control.Monad.Instances iirc
02:13:04 <copumpkin> (i.e., the worst possible place)
02:13:11 <copumpkin> that module should be abolished
02:13:22 <coppro> ah, yup
02:13:23 <dibblego> why?
02:13:40 <dibblego> is that an orphanage?
02:13:49 <copumpkin> why keep it separate from Monad? it's an orphan, and if any of your dependencies ever imports it even by mistake, you get the instance anyway
02:13:58 <copumpkin> so you might as well just get it all the time
02:14:05 <ion> Applicative ((->) r) is defined in Control.Applicative IIRC.
02:14:18 <dibblego> http://haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Monad-Instances.html
02:21:09 * hackagebot collections 0.3.1.1 - Useful standard collections types and related functions.  http://hackage.haskell.org/package/collections-0.3.1.1 (JeanPhilippeBernardy)
02:51:24 <solistic> Anybody else gets an unknown symbol for "echo -e 'import Graphics.UI.GLUT.Begin\nmainLoop' |ghci" with the latest haskell platform?
02:51:55 <solistic> I built it from source, so I guess all required libs should be in place.
03:35:27 <markspezzano> Can anyone give me advice on the following topic: I'm going _painfully slowly_ through every exercise in Richard Bird's IFPH. It's a good book but many of the questions have me "show that" or "prove that" etc. Should I be worried if I can't do half of these? I'm finding the inductions relatively easy, but some of the ones involving the Fusion Laws for foldr and the Duality Theorems very hard to solve. I don't know if I wasting my
03:35:28 <markspezzano> time trying and trying and trying so solve these. If someone could give me advice then that would be great. I'm gradually building up a complete set of solutions for the entire book.
03:36:12 <ivanm> IFPH == Introduction fo Functional Programming in Haskell?
03:36:18 <ivanm> haven't seen that book for a while...
03:36:20 <markspezzano> yes
03:37:45 <ivanm> OK, in terms of whether to do the exercises or not... if you just want to program, then there isn't really a need to do so
03:38:27 <gienah> markspezzano: one masochistic approach is to use a proof assistant, there is lots of stuff on learning coq: http://www.seas.upenn.edu/~cis500/current/sf/html/index.html
03:39:23 <gienah> markspezzano: then you have the proof assistant acting as a tutor on the proofs, but of course you can still get stuck trying to prove things :-)
03:40:32 <markspezzano> thanks for the link… gienah
03:41:32 <gienah> markspezzano: 4 videos on coq (then more on coq and type theory) http://vimeo.com/18138042
03:42:52 <ivanm> @where lyah
03:42:52 <lambdabot> http://www.learnyouahaskell.com/
03:42:54 <ivanm> markspezzano: ^^
03:43:38 <gienah> ivanm: that seems too easy, I think he's looking for something more hardcore like algebra of programming :-)
03:43:48 <ivanm> heh
03:44:28 <gienah> by the same author, bird
03:44:50 <ivanm> isn't that hard to find nowadays?
03:45:06 <ivanm> Pearls of Functional Programming was a pretty good book, but definitely not a Haskell tutorial
03:45:27 <ivanm> and many of its examples don't use "real" Haskell (e.g. re-defining \\ and delete)
03:45:29 <gienah> no, you can order it new from amazon.co.uk it is a print on demand book, also the co-author is de moor
03:45:40 <lewis1711> learn you a haskell is great. I also like hutton
03:46:28 <lewis1711> though I'm a noob, so take that as a grain of salt (went through most of LYAH earlier this year, now doing a course that uses hutton - good revision :))
03:46:35 <ivanm> I quite liked Craft; interested to see what the new edition is like
03:47:14 <gienah> lewis1711: algebra of programming is a very challenging text
03:47:18 <ivanm> as coming back from learning from it about 5 years back to tutoring a course that uses it, it frustrated me that the lecturer got students to use Float just because Craft did ;-)
03:48:28 <gienah> ivanm: I like the craft too (its a very easy intro), the new edition looks great, like how it uses quickcheck and has a chapter on DSL and EDSL
03:48:36 <ivanm> gienah: ouch, it's about AUD$83 for algebra of programming; in comparison I got LYAH for around $40!
03:48:53 <ivanm> there's also a new version of SoE coming out, but just using Music
03:49:16 <gienah> ivanm: hmm that does seem pricey :-/
03:53:58 <lewis1711> gienah: so covering LYAH and Hutton wouldn't be enough preparation? I might leave it. actually my next FP text will be Okasaki I think
03:56:43 <gienah> lewis1711: yes LYAH is a great book, I haven't read Hutton's text, algebra of programming is not a haskell tutorial, its mind bending maths/functional programming text
03:58:05 <gienah> in bird's text "Introduction to Functional Programming" there are some sections on deriving programs from their specifications, that is what algebra of programming and pearls of functional algorithm design are about
04:02:46 * hackagebot generic-deriving 1.0.2 - Generic programming library for generalized deriving.  http://hackage.haskell.org/package/generic-deriving-1.0.2 (JosePedroMagalhaes)
04:07:49 <lewis1711> gienah: that sounds cool actually, I'm just getting into mathsy compsci at university
04:08:07 <Ke> is there a way to handle data Parameter = ParA A | ParB B | ParInt Int | ParStorable1 Storable1 | ParStorable2 Storable2 so that all storables are handled with different constructors but using only storable functions
04:09:23 <gienah> lewis1711: yes its a mind bending concept, I really like those sections in intro to functional programming in haskell
04:09:52 <dmwit> Ke: No, but there is a way to handle all Storables with *one* constructor.
04:10:15 <dmwit> data Parameter = ParA A | ParB B | ParStorable (forall a. Storable a => a)
04:10:57 <dmwit> You should read that "forall" as "exists", though.
04:11:11 <Ke> heh
04:11:12 <dmwit> It's only called "forall" to avoid snagging another keyword.
04:11:22 <Ke> I'll look into it, thanks
04:11:47 <dmwit> Also I screwed up the syntax.
04:12:01 <dmwit> It would actually be "forall a. Storable a => ParStorable a".
04:12:04 <dmwit> More info here:
04:12:09 <dmwit> http://www.haskell.org/haskellwiki/Existential_type
04:13:37 <dmwit> GADT's provide another syntax: data Parameter where { ParA :: A -> Parameter; ParB :: B -> Parameter; ParStorable :: Storable a => a -> Parameter }
04:14:39 <ion> Are the semantics exactly the same, btw? Looks like they probably are, but i’m not familiar enough with either existential types or GADTs to tell.
04:16:22 <dmwit> I think they're pretty much the same.
04:16:44 <dmwit> I'm told there is no semantics for Haskell.
04:16:54 <dmwit> So I can't say they're exactly the same. =P
04:20:41 <darrint> @hoogle Monad m => (b -> m a) -> Either String b -> m a
04:20:41 <lambdabot> No results found
04:21:19 <darrint> @hoogle Monad m => (b -> m a) -> Either String b -> m a
04:21:19 <lambdabot> No results found
04:22:29 <ion> darrint: How do you expect to get an «a» from «Either String b»?
04:23:09 <darrint> ion: The a comes from the first argument.
04:23:43 <sipa> also, what do you want it to do when the second argument is (Left "blaah") ?
04:23:48 <ion> «Right 42» → apply the (b → m a) to 42. «Left "foo"» → what do you do?
04:23:49 <shachaf> fail?
04:23:57 <shachaf> Maybe you want MonadZero/MonadPlus.
04:24:19 <darrint> ion: the type is of either fail.
04:24:31 <darrint> > either fail
04:24:31 <lambdabot>   Overlapping instances for GHC.Show.Show
04:24:31 <lambdabot>                              ((b ->...
04:24:34 <ion> :t \f -> either fail f
04:24:35 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (b -> m a) -> Either String b -> m a
04:24:54 <darrint> :t either fail return
04:24:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => Either String a -> m a
04:25:41 <darrint> That's the ticket. Except ghci doesn't show type with the existential part.
04:26:10 <ion> :set -fprint-explicit-foralls
04:26:25 <darrint> ion: Do I _want_ that?
04:28:26 <darrint> Or are those teh teh foralls that are implied by the type variables being "free"?
04:28:26 <ion> I don’t know. Do you?
04:29:05 <ion> Yeah, they’re the implicit foralls.
04:36:20 <kizzx2> do people usually use Int or Integer in real world haskell projects?
04:37:12 <olsner> kizzx2: they do different things, so many projects would use both
04:38:31 <kizzx2> i'm really suspicious as when Int is better than Integer, the thought of things susceptible to overflow doesn't feel right
04:39:15 <kizzx2> however most built-in functions use Int.... fromInteger is basically as unsafe as it is
04:40:02 <kizzx2> olsner: so do you mean most of the time pepole use Int but if they expect large numbers they use Integer?
04:40:41 <olsner> kizzx2: yeah
04:41:15 <kizzx2> OK :P kind of expected, just wanted to check i'm not missing something fundamental :P
04:41:28 <luite> Integer would be a better default imho, and Int where you expect performance issues
04:41:47 <kizzx2> i agree
04:41:58 <kizzx2> and fromInteger should use the dreaded `error` when it detects overflow
04:42:02 <luite> unfortunately many Prelude and base things make this more difficult
04:42:16 <kizzx2> i can't imagine a useful scenario where overflow getting clipped is what is intended by teh programmer
04:43:53 <darrint> :t (!!)
04:43:54 <lambdabot> forall a. [a] -> Int -> a
04:44:12 <olsner> I wonder if overflows on Ints are even specified, maybe you must use Int32 or Word32 if you want well-defined overflows in haskell
04:45:08 <luite> I think the only thing that's specified is that it's at least 29 bits plus sign
04:45:26 <ion> The Prelude functions using Int is just a historical wart. No reason to prefer Int to Integer before profiling actually shows you Integer has too much overhead.
04:45:30 <kizzx2> that leaves the size of a list unspecified
04:45:59 <nomeata> Hi. I’m trying to "cabal install" a package. One dependency has a version constraint that I do not want to fulfill. I have locally downloaded, unpacked that package, relaxed the constraint and installed it.
04:46:03 <kizzx2> i think Prelude using Int is unfortunate, because it presents a big obstacle to liberal use of Integer
04:46:13 <nomeata> But cabal install still wants to use the constraint as given on hackage
04:46:18 <nomeata> What should I do?
04:46:58 <luite> increase the version number
04:47:08 <Ke> in openclraw where should I get sizeof(clmem)
04:47:15 <nomeata> ok, that works. thx.
04:47:19 <kizzx2> i wonder if there is a safer (myList !! (fromInteger x)) ?? (yeah i can write my one-liner, just wondering)
04:47:33 <ion> @hoogle [a] -> Integer -> a
04:47:33 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
04:47:33 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
04:47:33 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
04:47:57 <ion> genericIndex. There is a number of generic variants of Prelude functions as a workaround.
04:48:03 <darrint> kizzx2: How is using a >65 bit integer for !! safer?
04:48:16 <gienah> kizzx2: atMay in safe?
04:49:38 <kizzx2> darrint: i guess i get what you mean, but the (myList !! (fromInteger x)) will wrap and give me an unspecified element
04:49:43 <kizzx2> which is worse than `error` IMHO
04:49:48 <ion> See above.
04:49:54 <kizzx2> ion: thanks
04:51:59 <kizzx2> gienah: pardon? (what's "atMay in safe"?)
04:52:06 <ion> @hackage safe
04:52:06 <lambdabot> http://hackage.haskell.org/package/safe
04:52:14 <kizzx2> @hoogle atMay
04:52:14 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
04:52:18 <darrint> > (fromInteger 2 ^ 10000000)::Int
04:52:19 <lambdabot>   0
04:52:23 <darrint> Not what I expected.
04:53:15 <dafis> darrint: why not?
04:53:18 <ion> @hackage isThisARealHackageLookupOrJustAStringPrepend
04:53:18 <lambdabot> http://hackage.haskell.org/package/isThisARealHackageLookupOrJustAStringPrepend
04:53:21 <gienah> kizzx2: http://hackage.haskell.org/packages/archive/safe/0.3/doc/html/src/Safe.html#atMay
04:53:39 <kizzx2> @hayoo atMay
04:53:40 <lambdabot> Unknown command, try @list
04:53:43 <kizzx2> oops :P
04:53:54 <darrint> dafis: I thought it would error.
04:54:09 <dafis> darrint: why should it?
04:54:50 <kizzx2> atMay doesn't seem to deal with Integer, so i still need fromIntegral which means wrapping
04:54:55 <kizzx2> s/tegral/teger/
04:55:24 <darrint> dafis: One could argue principle of least surprise.
04:55:49 <kizzx2> i second darrint, though from a C programmer's perspective wrapping may be least surprise :P
04:56:08 <dafis> darrint: since almost every language wraps on overflow, that could be argued to be 'least surprise'
04:57:12 <darrint> forall (Behavior b) => someoneLikesIt b will return true.
04:57:57 <dafis> darrint: as well as someoneHatesIt
04:58:24 <ousado> it's just a question of how many cycles you want to waste
04:58:51 <kizzx2> imho Integer vs Int is really *not* performance related
04:58:55 <darrint> Not that it matters of course, but my view is: Failing to wrap is something you'll discover in testing your own code. Wrapping  is the kind of thing that shows up in the field on the customers system. And their boss won't let them share logs with you.
04:59:12 <kizzx2> if that matters the program's probably written wrong, or you're using the wrong language
04:59:12 <ousado> you could also make your app take a survey on every integer operations ..
04:59:42 <kizzx2> ousado: i'm a haskell newbie, is there a way to do that?
05:00:27 <ousado> throwing errors instead of using what the CPU gives you is not performance related?
05:00:56 <kizzx2> one could use that argument `head`
05:01:07 <kizzx2> `head` gives you error on empty list, but the CPU could actually give you undefined memory
05:01:14 <dafis> kizzx2: a factor of 2 or so when all computations actually fit into an Int may be important (doesn't mean that Int should be the default, just that it's important to have the option)
05:01:23 <ousado> pfft
05:02:23 <ousado> one is defining constraints on what happens on certain operations on a type
05:02:26 <darrint> Surely there's a better example out there than (!!)
05:04:02 <kizzx2> i wonder if integer wrapping is really well undefined to begin with
05:04:26 <dafis> "well undefined"?
05:04:31 <kizzx2> lol
05:04:39 <kizzx2> s/und/d/
05:07:02 <dafis> kizzx2: modular arithmetic, I'd say
05:07:35 <kizzx2> since the size of Int is not specified in Haskell the value can change from implementation to implementation
05:08:10 <dafis> Oh, that. Yes, it's platform dependent
05:08:21 <kizzx2> yeah but that probably misses the point :P
05:08:40 <kizzx2> i was just wondering how ppl deal with this in the real field
05:09:03 <kizzx2> (misses the point as in getting into these theoretical debates)
05:09:16 <ourfrank> Is there any way I could achieve something like the following: data Truths = Truths { a :: Bool, b :: Bool }; let setTrue truths which = truths { which = True }. So, the record field changed depends on the accessor function passed to setTrue.
05:09:37 <ion> ourfrank: Use something like fclabels
05:10:28 <dafis> kizzx2: either you get correct results by calculating modulo (2^bitwidth) no matter whether bitwidth is 32, 64, 29 or whatever, or you use Integer
05:11:22 <ion> setTrue acc = setL acc True  -- fclabels
05:12:03 <ourfrank> ion: I checked fclabels out, it appears to do the trick! Thanks!
05:13:40 <gienah> kizzx2: I wonder if you need to do lots of index lookups that maybe Data.Sequence might be more useful, or there is Data.Array.IArray but its interface seems very limited (performance on index looksup probably better though)
05:14:31 <ion> Yeah, don’t use a linked list for that.
05:14:34 <kizzx2> gienah: not that it's particularly related to index lookup... i'm just feeling uncomfortable about the overflowing
05:14:57 <gienah> kizzx2: right, ok :-)
05:16:17 <ion> > maxBound :: Int
05:16:17 <lambdabot>   9223372036854775807
05:16:36 <ion> If you’re using a linked list longer than that, your design might need some changes. :-)
05:16:53 <ion> > 2^29-1
05:16:54 <lambdabot>   536870911
05:16:57 <ion> or even that.
05:17:25 <ion> > {- Actually, -} 2^28-1 {- since it’s signed. -}
05:17:26 <lambdabot>   268435455
05:18:35 <kizzx2> @hoogle Data.ByteString.index
05:18:35 <lambdabot> Data.ByteString index :: ByteString -> Int -> Word8
05:18:35 <lambdabot> Data.ByteString.Char8 index :: ByteString -> Int -> Char
05:18:35 <lambdabot> Data.ByteString.Lazy index :: ByteString -> Int64 -> Word8
05:40:44 <Heraklit> hi
05:41:28 <Heraklit> I executed the following commands in ghci and received an error. Whats the reason?
05:41:37 <Heraklit> a <- openFile "/tmp/Hallo" ReadWriteMode
05:41:42 <Heraklit> contents <- hGetContents a
05:41:48 <Heraklit> hPutStrLn a "bla"
05:41:55 <Heraklit> Exception: /tmp/Hallo: hPutStr: illegal operation (handle is closed)
05:42:07 <Heraklit> If I switch the last 2 commands, everything works fine
05:42:07 <shachaf> Heraklit: hGetContents is a magic evil lazy IO function.
05:42:18 <Heraklit> what shall I do, so that this works
05:42:32 <Heraklit> I want to read the whole file and then write an entry
05:43:12 <shachaf> Heraklit: Read the whole file some other way. hGetContents shouldn't be mixed with any other sort of I/O, and it'll automatically close the handle.
05:43:40 <Heraklit> how about hGetLine and check whether EOF is reached? Or do you know a better alternative?
05:47:46 <Axman6> @hoogle Handle -> IO String
05:47:46 <lambdabot> System.IO hGetContents :: Handle -> IO String
05:47:46 <lambdabot> System.IO hGetLine :: Handle -> IO String
05:47:46 <lambdabot> System.IO hShow :: Handle -> IO String
05:47:55 <Axman6> @more
05:47:57 <Axman6> :(
05:48:16 <benmachine> what are you looking for?
05:50:33 <Axman6> hGetContents without closing the file
05:51:53 <benmachine> that would be kind of dangerous
05:52:24 <benmachine> makes hGetContents even less deterministic if you can do things like edit the file position before all the IO has been done
05:52:49 <Axman6> foiled by lazy IO once again
05:52:58 <benmachine> uh-huh
05:53:20 <Axman6> @hoogle Handle -> IO ByteString
05:53:20 <lambdabot> Data.ByteString hGetContents :: Handle -> IO ByteString
05:53:20 <lambdabot> Data.ByteString hGetLine :: Handle -> IO ByteString
05:53:21 <lambdabot> Data.ByteString.Char8 hGetContents :: Handle -> IO ByteString
05:55:30 <Heraklit> I am trying to read the file recursively by using hGetLine now
05:55:30 <ion> ghci> withFile "/etc/motd" ReadMode $ \h -> liftA2 (,) (run_ (Data.Enumerator.Binary.enumHandle 4096 h $$ Data.Enumerator.List.consume)) (hIsReadable h)
05:55:36 <ion> (["Welcome to Ubuntu oneiric (development branch) (GNU/Linux 3.0.0-7-generic-pae i686)\n\n * Documentation:  https://help.ubuntu.com/\n\n"],True)
05:55:41 <ion> :-P
05:55:48 <Heraklit> ok, I will check this
05:56:17 <ion> (Don’t do that, really. Rather replace consume with an iteratee that does what you want.)
05:58:14 <Heraklit> where can I find run_
05:58:24 <ion> Data.Enumerator
05:58:29 <Heraklit> thanks
05:58:58 <ion> (Disclaimer: enumerator may or may not fit your needs.)
05:59:05 <benmachine> Heraklit: I would stick to hGetLine for now
05:59:08 <benmachine> it's much much simpler
05:59:23 <Heraklit> probably yes
06:00:04 <ion> attoparsec-enumerator is really nice for parsing files.
06:02:23 <karlicoss> hi. Is there a complete list of haskell type classes? I know only few from different tutorials.
06:02:50 <Axman6> technically there's an infinite number of them...
06:03:34 <Axman6> check out the typeclassopedia
06:05:09 <karlicoss> Axman6: cool, thanks. Actually i'm searching for something like Addable type class, but it might be useful too.
06:05:21 <Axman6> @src Num
06:05:21 <lambdabot> class  (Eq a, Show a) => Num a  where
06:05:21 <lambdabot>     (+), (-), (*)           :: a -> a -> a
06:05:21 <lambdabot>     negate, abs, signum     :: a -> a
06:05:21 <lambdabot>     fromInteger             :: Integer -> a
06:05:22 <Axman6> ?
06:06:58 <karlicoss> Axman6: yep, i know about Num. But I'm coding 2D geometry modul(for educational) and in 2D multiplying vectors makes no sense. The same for abs  and fromInteger
06:07:14 <Axman6> then leave them undefined
06:07:41 <ion> That’s a bit hacky.
06:07:44 <aninhumer> abs for vector could be magnitude? or are there rules about what abs is
06:07:46 <Axman6> also (*) could easilly be a vector multiply: zipWith (*)
06:07:57 <karlicoss> Axman6: really? i've thought i should define all of them.
06:08:26 <Axman6> you can just say abs = undefined, or better yet, abs = error "abs not defined for vector"
06:08:37 <Axman6> aninhumer: abs being magnitude wouldn't match the type
06:08:45 <aninhumer> Oh right
06:08:56 <karlicoss> is magnitude == vector length?
06:09:03 <ion> abs :: a → a, but one would expect magnitude to be something like :: Vector a → a
06:09:35 <Ptival> abs = id :D
06:09:51 <ion> hah
06:09:58 <Axman6> magnitude is the square root of the sum of the elements squared
06:10:19 <aninhumer> or the radius for polar vectors!
06:10:20 <Axman6> mag = sqrt . sum . map (^2)
06:10:22 <Ptival> I guess the "error" solution is okay
06:10:35 <ion> It’s nasty.
06:12:08 <benmachine> monoid?
06:12:23 <aninhumer> Was going to say that
06:12:33 <benmachine> but monoid doesn't get you negate or subtract
06:13:10 <ClaudiusMaximus> > abs (4 :+ 3)
06:13:11 <lambdabot>   5.0 :+ 0.0
06:13:11 <karlicoss> it should be Group :)
06:13:12 <Axman6> there's no reason you can't define class Add a where add a -> a -> a
06:13:44 <Ptival> I was going to say tht
06:14:31 <Axman6> i think the rule that each type class should only have a single function isn't a bad one...
06:15:28 <aninhumer> Axman6: even something like Eq?
06:15:35 <Axman6> sure
06:15:47 <Axman6> there's no need for Eq to have both (==) and (/=)
06:17:23 <aninhumer> Perhaps a typeclass shouldn't have any independent rules is a better rule?
06:17:38 <aninhumer> In the sense of rules that can't be defined in terms of existing ones
06:17:38 <hatds> independent rules?
06:18:08 <aninhumer> hatds: < Axman6> i think the rule that each type class should only have a single function  isn't a bad one...
06:18:09 <ivanm> Axman6: I beg to differ
06:18:18 <benmachine> Axman6: sometimes the rules of a typeclass don't make sense unless the functions are given together
06:18:28 <Axman6> sure
06:18:29 <ivanm> by "rules" are we meaning "class methods" ?
06:18:30 <benmachine> plus, syntactic overhead would be large
06:18:39 <Axman6> but in general, it causes a lot of unforseen problems.
06:18:46 <benmachine> I think you're really asking for a completely new overloading system
06:18:53 <Axman6> not really
06:19:09 <benmachine> well
06:19:13 <benmachine> a somewhat different one anyway
06:20:40 <Axman6> all the Monad mess could be fixed by having class Pointed m where return :: a -> m a, class Applicative ... class Monad m where (>>=) :: m a -> (a -> m b) -> m b, class MonadFail where ...
06:21:17 <ivanm> Axman6: so, for the specific classes in base, this would be nice maybe...
06:21:22 <ivanm> but for other classes?
06:23:53 <benmachine> it would make instance declarations longer and harder to read
06:23:59 <ivanm> definitely
06:24:03 <ivanm> and type sigs in general
06:24:21 <benmachine> well, type sigs are ok if we have all the superclasses set up correctly
06:24:24 <aninhumer> Hmm, what about allowing you to partially define a typeclass, and it introduces essentially a new typeclass behind scenes, which fails typechecking for functions using undefined class methods
06:24:39 <ivanm> benmachine: I meant for other typeclasses
06:24:58 <benmachine> aninhumer: not simple. then typeclass-polymorphic functions need to know what methods of the class they use
06:25:06 <benmachine> in fact, that becomes part of their interface
06:25:48 <aninhumer> well isn't that easily determined from the source?
06:26:03 <benmachine> aninhumer: but it makes APIs more complex and easier to break
06:27:07 <benmachine> what really bugs me is *implicit filling* of unspecified instance methods (and record fields, as well)
06:27:14 <benmachine> it feels quite unhaskelly
06:27:51 <hatds> aren't record fields left undefined?
06:27:57 <benmachine> yes
06:28:04 <benmachine> implicitly filled with error calls
06:28:39 <hatds> partial functions aren't unhaskelly, it's only liberal usage of such functions that is unhaskelly
06:32:28 <benmachine> hatds: partial functions that aren't explicitly checked as such
06:37:49 <ion> axman6: class Monad f where { x >>= f = join (f <$> x); join x = x >>= id }
06:38:05 <ion> (and the types, of course)
06:38:17 <Axman6> yeah
06:39:38 <shachaf> There should be a way to enforce constraints on the minimum valid definition of a type class.
06:40:09 <ion> With that class definition, instance Monad MyType where { } is a completely valid definition. ;-)
06:40:42 <ion> (Just joking, i hear you)
06:41:34 <aninhumer> can the minimum definition(s) not be determined?
06:42:37 <aninhumer> seems like a pretty simple dependency problem to me?
06:43:19 <aninhumer> certainly at the size of any sanely scoped typeclass
06:44:42 <parcs> you mean automatically determined?
06:46:52 <aninhumer> parcs: yeah
06:47:24 <aninhumer> I could see there being weird edgecases though
06:47:58 <parcs> there exist multiple valid monad definitions for many types
06:50:40 <parcs> but the next version of ghc will have something called generics that can automatically make a make valid class instances of arbitrary data types
06:51:55 <benmachine> aninhumer: there are weird edge cases, yes
06:52:06 <benmachine> two functions can be mutually recursive and non-bottom
06:53:40 <aninhumer> benmachine: so all we have to do is solve the halting problem, pff :P
06:53:50 <benmachine> :)
06:54:07 <benmachine> the halting problem isn't as big a deal as everyone says
06:54:17 <benmachine> it just means the problem can never be completely solved
06:54:23 <benmachine> doesn't mean you can't make a good stab at parts of it
06:55:58 <aninhumer> "Error: Could not solve halting problem for function foo"
06:56:32 <benmachine> there are a lot of problems that you *can* prove halt!
06:56:35 <benmachine> and a lot that you can prove don't
06:57:41 <aninhumer> I was just meaning requiring your code to be within a certain class of halting problem seems like it would make for fun debugging :P
06:58:00 <karlicoss> So, I've defined AddGroup type class and have a problem: http://pastebin.com/5sm6fu01
06:58:03 <mauke> The paste 5sm6fu01 has been copied to http://hpaste.org/49675
06:58:08 <karlicoss> could anyone help?
06:58:26 <aninhumer> karlicoss: check the hpaste
06:59:36 <karlicoss> aninhumer: wow, cool
07:00:03 <hpaste> karlicoss pasted “Defining typeclass problem” at http://hpaste.org/49676
07:01:36 <karlicoss> oh, it've been copied automatically :)
07:01:55 <aninhumer> karlicoss: putStrLn already returns IO () so you don't need to put it in a do block for main
07:02:04 <aninhumer> not sure about "Use print" though
07:03:39 <aninhumer> Oh it's just a suggestion, print is equivalent to putStrLn . show, roughly anyway
07:03:50 <hpc> @src print
07:03:50 <lambdabot> print x = putStrLn (show x)
07:04:01 <aninhumer> oh exactly I guess
07:04:20 <karlicoss> aninhumer: thanks, but the problem is in multiple + operator definition :)
07:04:58 <aninhumer> Hmm, why is that (and redundant do) listed as an error though?
07:08:00 <benmachine> aninhumer: hlint thinks you'd never want to do that
07:08:09 <benmachine> whereas warnings are sometimes like that for legitimate reasons
07:08:20 <benmachine> karlicoss: you could try importing Prelude hiding the relevant things
07:08:27 <benmachine> import Prelude hiding (negate, (+), whatever)
07:10:21 <karlicoss> benmachine: it will solve multiple definitions problem, but I won't be able to use apply "+" for Double without writing Prelude.+
07:10:53 <benmachine> karlicoss: that's unfortunate, yes. I think I'd recommend not using + for your addition class
07:10:59 <benmachine> use .+. or something
07:12:40 <karlicoss> benmachine: then, i wonder why instance Eq Vector where (Vector dx1 dy1) == (Vector dx2 dy2) = (dx1 == dy1) && (dx2 == dy2) doesn't cause such a problem.
07:13:39 <benmachine> karlicoss: well, you're using the same typeclass there
07:13:50 <klugez> karlicoss: Because it's the same (==) from class Eq. Now you (+) from classes Addgroup and Num.
07:13:57 <benmachine> karlicoss: you could define instance Addable Double and so for every member of Num
07:14:02 <benmachine> but it would be tedious
07:14:13 <karlicoss> benmachine: klugez: oh, i see
07:15:25 <karlicoss> then, it's a little wierd that the compiler tries to link Vector addition operator with + defined in Prelude only for Num typeclass
07:15:27 <karlicoss> or not?
07:16:04 <benmachine> karlicoss: huh? the problem in your paste is that the name + could refer to one of two things
07:16:11 <benmachine> either the thing in Num or the thing in Addable
07:16:23 <benmachine> this doesn't manifest itself with the Eq, because it must be talking about the == in Eq
07:16:26 <benmachine> that's th eonly one
07:17:39 <karlicoss> benmachine: but Double is not in Addable
07:17:57 <Saizan> karlicoss: name resolution doesn't care about instances
07:18:08 <benmachine> karlicoss: it *could* be
07:18:13 <benmachine> later on, or somewhere else
07:18:23 <benmachine> plus what Saizan said
07:20:02 <karlicoss> benmachine: Saizan ok, thanks :)
07:24:51 <applicative> karlicoss here's one ugly way to add requisite boilerplate: http://hpaste.org/raw/49677
07:26:34 <karlicoss> applicative: yeah, it's really ugly :)
07:27:56 <applicative> usually, I think, people would make the operations corresponding to something like AddGroup look like so: (.+.) (.-.) or whatever
07:28:40 <applicative> I'm not sure what is done in the various attempts to chuck Num and start over.
07:30:50 <roconnor> I use <+> for add group and .-. for torsors
07:31:20 <applicative> http://hackage.haskell.org/package/numeric-prelude is presumably not to be imitated
07:31:28 <applicative> roconnor is to be imitated :)
07:32:06 * roconnor finds the dots in .-. reminds him of points in a euclidian space.
07:33:12 <roconnor> and then I would use .+> and <+. for right/left group actions on the torsor.
07:33:30 <roconnor> um
07:33:54 <roconnor> ... I can restate this is less abstract terms if people find what I'm saying obtuse.
07:35:30 <roconnor> torsors are resonably common.  Positions in space form a torsor (and actually have more structure making it a euclidian space).
07:35:53 <roconnor> orientations of objects also form a torsor
07:36:46 <roconnor> you can even cross positions and orientations to get a nice big torsor for ... well posititioning and orienting objects in computer graphics.
07:36:53 <dafis> a torsor is a space with a group action?
07:37:23 <roconnor> dafis: yep, plus the group action is free and transitive.
07:37:35 <dafis> thx
07:37:59 <roconnor> but it is common to think of it as a group where you forget the identity.
07:38:10 * dafis just did
07:45:00 <applicative> if Haskell had some simple form of 'first class modules' would all these difficulties with alternative 'hierarchies' for numbers be simpler?
07:46:28 <applicative> Not a very clear question, I think
07:47:53 <roconnor> applicative: what are the difficulties?
07:48:29 <applicative> that's what I was finding hard to make clear to myself
07:49:07 <roconnor> I think network effects cause the difficulties
07:49:22 <roconnor> these classes are used to interface between different packages.
07:49:38 <applicative> like ListLike so to say
07:49:54 <roconnor> and you cannot change them unless both sides of the interface change together.
07:50:15 <roconnor> not that I really know what I'm talking about
07:50:50 * applicative should return to studying sml so he can figure out what problem modules are supposed to solve
07:51:46 <applicative> roconnor, speaking of mlish things, I made my first attempt at Coq + "Proof General" yesterday.
07:51:56 <roconnor> :D
07:52:28 <applicative> I was following the video tutorials of Andrej Bauer which are well judged.
07:53:08 <roconnor> :)
07:55:47 <applicative> the text that proof general generates as you move through the steps is surprisingly readable.
07:56:15 <applicative> or I assume its Proof General that's generating them, I don't know how to use Coq in emacs without it.
07:56:42 <roconnor> you mean the hypothesis + Goal?
07:56:54 <applicative> yeah, it works out quite well somehow
07:57:04 <roconnor> that's generated by coq
07:57:08 <applicative> maybe it just suits my dubious background.
07:57:18 <applicative> yeah I figure it had to be on reflection
07:57:33 <roconnor> it's how we have always looked at things :D
07:57:52 <applicative> yeah.  Is such a thing impossible in Agda?
07:57:54 <roconnor> http://en.wikipedia.org/wiki/File:CoqProofOfDecidablityOfEqualityOnNaturalNumbers.png
07:58:03 <roconnor> I'm not sure
07:58:56 <applicative> yes, the text you write as you move along in Coq (split. intros. ...) is completely unreadable, as is the 'real' definition of the function.
07:59:26 <applicative> but the stage by stage view works out fine
07:59:30 <roconnor> yes
08:00:07 <roconnor> I have a vauge project to harness coq to produce HTML/javascript files that let you scroll through a coq proof and see the goal state change.
08:00:39 <applicative> that sounds like an excellent project, if certainly thankless.
08:00:55 <roconnor> it really shouldn't be that hard.
08:01:10 <applicative> the html for something like Voevodsky's files is perfectly worthless as it stands.
08:01:19 <roconnor> ya
08:01:21 <applicative> but if you could cursor along it might make sense
08:01:25 <Saizan> you have a pretty similar view in agda while you interactively build your function, after that there isn't a script to replay so you'd better make your proof's code readable :)
08:02:03 <applicative> yeah that's what I mean. but also, the layout is somehow more human with coq
08:02:41 <applicative> though maybe this depends on the fact that the Proposition view of the types is more prevalent in Cog
08:02:41 <roconnor> This all started because Jeremy Gibbons said that I hadn't proved the equivalence of the get/put laws and the coalgebra laws when in fact I had given a coq proof that he simply scrolled over. :)
08:06:49 <applicative> Saizan, no complex proof is readable in Agda.
08:07:01 <plmday> hi, guys, I wonder how to make a copy of some data wrapped in `IORef'? Does `do { a <- readIORef aRef; aRef <- newIORef a }', do I make a new copy of `a' and then created a new IORef around it?
08:07:08 <applicative> the 'equational reasoning' technique is not so bad, I should say
08:08:04 <roconnor> plmday: the your second use of aRef shadows the first.
08:09:50 <plmday> roconnor: thanks for pointing out that, I should have written aRef', so do I get a new copy the data wrapped in aRef?
08:10:06 <roconnor> yes
08:10:39 <applicative> plmday, the second use of newIORef makes an IORef (IORef a) rather than an IORef a, no?
08:10:57 <plmday> but you see, the new IORef I created is around the same `a'?
08:11:10 <applicative> you should put a line in the middle to extract the 'real value' from a  -- or am I wrong?
08:11:29 <ezyang> plmday: Think of IORef as * (pointer, in C land)
08:11:51 <ezyang> So IORef (IORef a) is a pointer to a pointer to a.
08:11:54 <roconnor> plmday: okay, operationally speeking the a will be shared
08:12:07 <roconnor> *speaking
08:12:28 <applicative> do { io_a <- readIORef aref; a_value <- io_a ; newref <- newIORef a_value ; ... }
08:12:45 <applicative> something like that ? ^^^
08:13:05 <hpc> :t readIORef
08:13:05 <plmday> then what happens if I later make any change to the data in aRef, will it affect that in aRef'?
08:13:06 <lambdabot> Not in scope: `readIORef'
08:13:09 <roconnor> applicative: I don't think you get an io_a from readIORef
08:13:20 <monochrom> newtype Whee = Whee (IORef Whee)
08:13:27 <applicative> sorry, let me think again then
08:13:30 <roconnor> plmday: nope; because it will be unshared at that point.
08:13:52 <hpc> i would just write newref <- newIORef =<< readIORef oldref
08:14:10 <conal> or "readIORef aRef >>= newIORef".  or "readIORef >=> newIORef"
08:14:19 <plmday> roconnor: ah, so the runtime system of Haskell automatically detect it and do that?
08:14:29 <roconnor> plmday: it's not so magical
08:14:36 <roconnor> plmday: IORef is a pointer
08:14:45 <applicative> right, i renamed variables badly, but the interpolated step was what plmday was missing?
08:14:49 <roconnor> plmday: what you've done is make two pointers pointing to the same value
08:15:06 <roconnor> plmday: so when you update one of the pointers, then naturally they will no longer point to the same value.
08:15:34 * applicative immediately goes into a muddle with pointers
08:15:42 <monochrom> p = &x; q = &x; p = malloc(...);  what is there to detect?
08:16:27 <plmday> ok, so newIORef actually allocate a new cell for the data?
08:16:47 <conal> plmday: a new cell for the pointer, not for the data.
08:17:06 <monochrom> ok, my c analogy breaks there
08:19:09 <roconnor> plmday: newIORef allocates a new cell for a pointer and then points to the data you pass it.
08:19:20 <monochrom> f x = do { v <- newIORef x; writeIORef v (x+1); print x }  see what is printed
08:19:46 <roconnor> plmday: so newIORef allocation is proprotional to the size of a pointer, not propotional to the size of the object being pointed to.
08:19:56 <plmday> conal: oh yeah, so aRef and aRef' both points the same data, then I made changes the data via aRef, according to C, then when I access via aRef', I will get the altered one.
08:20:18 <roconnor> plmday: nope, you never make changes to data in haskell
08:20:25 <ion> http://minnie.tuhs.org/cgi-bin/utree.pl?file=V7/usr/src/cmd/sh/mac.h
08:20:28 <roconnor> plmday: all you can do is move the pointer to new objects.
08:20:49 <conal> plmday: what do you mean that you "made changes [to] the data"? data is immutable.
08:21:12 <plmday> conal: but IORef simulates that? doesn't it?
08:21:37 <hpc> the data doesn't change, the IORef changes where it points
08:21:49 <plmday> after a writeIORef aRef a', I "set" aRef to a'
08:21:51 <monochrom> don't simulate
08:21:55 <roconnor> I guess one may want to see an IORef as a pointer to a pointer to data.
08:22:23 <conal> plmday: are you talking about IORefs pointing to other IORefs? that sort of thing? (foo :: IORef (IORef a)) ?
08:22:39 <applicative> plmday: I think I finally figured out what I thought you wanted, for what it's worth
08:22:54 <applicative> do {newioref_a <- readIORef ioref_a >>= newIORef; ...}
08:23:11 <roconnor> conal: well really when you get an IORef back from newIORef it is really a pointer to the new IO ref, since (almost) everything in Haskell is passed by reference.
08:23:21 <applicative> this makes a new IORef with the same content that you can mutate independently, no?
08:23:41 <plmday> applicative: yes, that's what I meant to write, hoping to have a copy of the contents in newioref_a.
08:23:55 <monochrom> you can mutate the second IORef, yes
08:24:16 <monochrom> but it's just a lot of pointing fingers with no data change
08:24:29 <monochrom> just like the US Congress right now
08:24:48 <roconnor> plmday: I think you are looking at this way to operationally.
08:24:57 <roconnor> *way too
08:24:58 <conal> roconnor: i bet that explanation will confuse plmday even more, since now (operationally only), we have mutable and immutable pointers.
08:25:17 <monochrom> operationally is fine. just do it correctly
08:25:52 <applicative> monochrom: but i think plmday's trouble was just the general one, how to make a new independently mutable 'variable' given an old one, the value of the second will be bound to the value of the first, at the time of binding
08:26:00 <roconnor> monochrom: well it depends, is plmday interested in getting his code correct, or interested in the space usage of his program?
08:26:02 <applicative> to use unpleasant language
08:26:22 <roconnor> monochrom: because if he just wants is program to work properly, thinking operationally will just be an unecessary burden.
08:26:39 * applicative brazenly claims that plmday is interested in correctness first
08:26:51 <monochrom> we need his/her brain uploaded somewhere for a free analysis of his/her interest
08:27:22 <roconnor> right, and plmday's first code was fine.  It creates a new IORef whose contents are the same as the old IORef.
08:27:47 <monochrom> moreover I wonder if we have a non-operational semantics of newIORef etc at all
08:27:54 <roconnor> whether the two pieces of data are shared in memory or copied is an implementation detail that is irrelevent to correctness.
08:28:04 <applicative> is that right, doesnt the IORef (IORef a) track whatever is in the ur-ioref as it changes?
08:28:47 <roconnor> plmday: sorry this is all my fault.  I shouldn't have talked about sharing.
08:29:13 <plmday> roconnor: I am not interested in the implementation details of Haskell (for my problem at hand of course), I am implementing some imperative features using IORef, I want to simulate making-new-copy of data
08:29:30 <roconnor> plmday: okay, then your first code is fine.
08:29:51 <roconnor> plmday: it makes a new copy of a.
08:30:04 <monochrom> "let y = x" already simulates making new copy
08:30:15 <plmday> roconnor: and then create a new IORef around the new copy?
08:30:39 <roconnor> yes
08:30:42 <plmday> monochrom: thanks for that.
08:31:00 <plmday> OK, thank you all very much
08:31:18 <roconnor> plmday: to futher monocrom's point, reading from an IORef makes a "copy" of the contents of the IORef.
08:31:23 <conal> but not a new "copy" of data.
08:32:13 <conal> unless you're thinking operationally or have IORef-rich structures, any talk of copying is probably confusion.
08:32:24 <roconnor> indeed
08:32:49 <plmday> i know internally a haskell implementation may do it as real sharing
08:33:19 <roconnor> plmday: I think conal is right, it probably isn't good to think of anything going on here as copying, which is an operational notion.
08:33:47 <roconnor> what you are doing is making a newIORef whose initial contents are the value read from the old IORef
08:33:54 <roconnor> and that is all.
08:34:01 <plmday> but i want to be sure I simulate the imperative features I a implementing using IORef faithfully, otherwise the semantics of the object imperative language would be wrong
08:34:36 <conal> plmday: it's not that a haskell implementation implements copying as sharing. more like that understanding the language doesn't require a notion of copying.
08:34:56 <conal> plmday: so if you're thinking in terms of copying, you're probably not understanding the language model.
08:35:17 <conal> plmday: and trying to make it more complex than it is.
08:36:15 <conal> plmday: by "language model", i mean its denotation rather than some particular operational perspective.
08:36:31 <plmday> conal: could you talk more about it?
08:36:52 <conal> plmday: about what (in particular)?
08:37:19 <plmday> the language model?
08:37:42 <plmday> of haskell
08:38:49 <conal> plmday: sure. aside from things like IO, haskell is a "denotative" language. meaning that for every type of expressions there is a corresponding type of values. the meaning of an expression of type A is a value whose type is the meaning of A.
08:40:06 <conal> for instance, the semantic types are things like integers, sequences, and functions. and in haskell these semantic types (sometimes called "domains") all have a "bottom" element.
08:40:53 <applicative> or maybe: the meaning of an expression of (syntactic) type A is a value whose type is the semantic type expressed by the syntactic type A?
08:41:12 <conal> plmday: these semantic values are mathematical values, so there's no notion of mutability. and so "copying" isn't meaningful.
08:41:26 <plmday> applicative: that's clearer, ;)
08:42:17 <applicative> just to make clear conal is using expression : value :: syntactic (Haskell) type : semantic (more or less regular mathematical) type -- I think
08:42:24 <plmday> conal: so an implementation of haskell tries to simulate this model on real machines, using pointer?
08:42:26 <conal> expressions have meanings, and types have meanings. if u :: t then meaning u :: meaning t .
08:43:01 <conal> where the first :: is syntactic and the second :: is semantic
08:43:35 <amindfv> can someone explain what transitive inlining is?
08:43:54 <applicative> plmday: it may develop that conal has unusually radical views on this subject.  some of us will support him all down the line though :)
08:44:32 <conal> plmday: moreover, meaning is defined *compositionally*, i.e., the meaning of an expression is defined entirely in terms of the meanings of the direct sub-components of the expression.
08:45:01 <monochrom> it is not radical to give a denotational semantics to everything. Dana Scott etc have been doing that for decades
08:45:13 <conal> peter landin suggested the name "denotative" for languages having this property.
08:45:39 <conal> in the seminal paper "the next 700 programming languages". which is the grand-daddy of Haskell.
08:46:02 <conal> he proposed "denotative" as a substantive replacement for the fuzzy term "functional".
08:46:28 <monochrom> however, it is a tall order because some things have very difficult denotational semantics. for example IO
08:46:54 <conal> to distinguish "genuinely functional" languages from ones that merely have functional-looking notation.
08:47:52 <plmday> conal: any example languages that falls into the latter?
08:48:03 <plmday> scheme?
08:48:05 <conal> the arguments about whose language is functional and whose isn't could be eliminated if people would drop the fuzzy notion of "functional" and use "denotative" instead.
08:48:11 <ptd> conal: What is the definition of "genuinely functional"?
08:48:46 <conal> ptd: "genuinely functional" == "denotative" and is defined simply & precisely in that paper.
08:48:55 <conal> i have a pointer i'll dig up now...
08:49:07 <conal> start here: http://conal.net/blog/posts/is-haskell-a-purely-functional-language/#comment-35882
08:49:33 <plmday> conal: thanks for the link
08:49:39 <plmday> and the explanation
08:50:02 <conal> plmday: examples of the merely functional-looking: scheme and hasksell-with-IO
08:50:28 <conal> plmday: you're welcome.
08:50:45 <roconnor> conal: still not happy with the free monad model of IO I see :)
08:51:41 <applicative> is there a simple pure of way of representing some of the structure of IORef so that one can think of the way something like newRef and readRef work
08:51:45 <plmday> conal: but isn't IO a monad thing, which seems widely spread as an evidence that haskell is pure (I will go for the link soon)?
08:51:55 <conal> roconnor: right. it's closer to the syntactic end of the syntax/semantics spectrum than what i'm looking for. doesn't capture important aspects of meaning.
08:52:33 <conal> plmday: "pure" is another such fuzzy notion that people confuse themselves with.
08:52:50 <conal> plmday: see, e.g., http://conal.net/blog/posts/notions-of-purity-in-haskell/
08:53:19 <Saizan> it worth noting that you produce and manipulate IO values in a completely referentially transparent way
08:53:33 <Rotaerk> I prefer "ubiquitously functional" or "pervasively functional" rather than "purely functional"
08:53:42 <Saizan> which has practical consequences like the ease with which you can build your own control structure
08:53:52 <Saizan> *structures
08:53:52 <conal> Saizan: that's the party line. however, i don't know whether the claim is even well-defined.
08:54:08 <Saizan> that's a matter of fact
08:54:11 <conal> Saizan: (referring to the claim that IO values are treated in a RT way)
08:54:34 <monochrom> applicative: a Data.Map from IDs to values, e.g., "readIORef x" looks up x in the map
08:54:38 <ion> I prefer the distance from PHP in kilocurries.
08:54:50 <Rotaerk> conal, how isn't it well-defined?
08:54:51 <ptd> conal: With haskell with the State monad (but not the IO monad) be considered denotional?
08:55:12 <conal> Rotaerk: in that it's missing a precise definition.
08:55:14 <Saizan> conal: if you're worrying about the notion of equality for IO actions you can take the very conservative one that intensional type theories take
08:55:16 <roconnor> conal: it is pretty well defined using the free monad model of IO.
08:55:23 <conal> ptd: yes.
08:55:38 <roconnor> conal: and modding out the free monad model with additional semantics won't change this fact.
08:55:40 <conal> roconnor: since you have equality for that model?
08:56:00 <Rotaerk> oh i see..
08:56:19 <roconnor> conal: I have the most conservative equality model for it.
08:56:33 <monochrom> use set-of-traces for the denotational semantics of IO, or generally any interaction
08:57:04 <monochrom> the process algebra people have known that for years, maybe two decades
08:57:52 <conal> roconnor: i'm skeptical that we can cover IO with any precise model. simply because the the way that IO has grown. see my "toxic avenger" comment at http://conal.net/blog/posts/notions-of-purity-in-haskell/#comment-22829
08:58:24 <roconnor> Graham taught me last week that this IOTree of mine is isomorphic to (dependent) contractive maps from response streams to request streams
08:59:33 <Saizan> you can put anything you like in IO, the free monad will always give you a quite useful, yet most conservative, notion of equality to use your referential transparecy with :)
08:59:58 <roconnor> exactly
09:00:00 <sipa> the free monad?
09:01:43 <roconnor> sipa: given a Functor f, the free monad for f over a is data Free f a = Unit a | f (Free f a)
09:01:48 <roconnor> (did I get that right?)
09:01:55 <Saizan> (yep)
09:02:10 <Saizan> well, you forgot a constructor
09:02:17 <sipa> and return a = Unit a
09:02:17 <conal> which is a generalization of leaf trees.
09:02:19 <roconnor> sipa: in this case our functor f is a big sum type that basically gives all the commands supported by IO.
09:02:29 <roconnor> oh right
09:02:35 <roconnor> sipa: given a Functor f, the free monad for f over a is data Free f a = Unit a | Node (f (Free f a))
09:03:48 <roconnor> sipa: in the case of IO, Saizan is saying we can freely add new commands to our functor IOF used to generate the free IO monad, so the sin-bin approach is fine.
09:04:07 <ion> Free Free (Free Free a)
09:04:11 <dankna> okay so!
09:04:29 <ion> Whoops, kind mismatch.
09:04:32 <dankna> Subtraction of type-level naturals: type family (m :: Nat) - (m :: Nat) :: (Maybe maybe) => Nat
09:04:42 <dankna> I want to make it return a type-level maybe containing a Nat
09:04:50 <dankna> but I can't, because there's no way to write that signature
09:04:55 <dankna> I can't put a context there because Nat is a kind, not a type
09:05:00 <dankna> and kinds don't have contexts, obviously
09:05:05 <ptd> conal: You should speak with kmc
09:05:07 <dankna> do I need to add a new kind Maybe?
09:05:24 <conal> ptd: oh?
09:05:49 <Saizan> dankna: you'd have to, but you can't, though you can just use *
09:05:51 <roconnor> sipa: for example for teletype IO the functor data IOTeleType a = PutChar Char a | GetChar (Char -> a) works well.
09:05:53 <ptd> conal: Who argues that the term "functional" is meaningless
09:06:17 <Saizan> dankna: once you've defined data TNothing; data TJust (n :: Nat)
09:06:30 <ptd> and that functional and imperative are merely programing styles
09:06:41 <sipa> roconnor: i see
09:06:48 <dankna> Saizan: well I'm modifying GHC so yes I can :)
09:06:50 <conal> ptd: ah. i'd also like to stamp out the term "functional". so much wasted energy debating over fuzzy notions.
09:06:50 <ptd> you can write functional python programs and imperative haskell ones
09:07:16 <Saizan> dankna: ah, ok :)
09:07:32 <dankna> the reason I don't want to do TJust is that it then can only contain a type of kind Nat
09:07:40 <conal> ptd: in the "next 700" paper, landin suggests contrasting imperative with denotative, not with functional.
09:07:41 <dankna> and not a type of kind *
09:07:47 <dankna> because Nat is not a subtype of *
09:07:48 <Saizan> not sure how nice to use a subtraction that returns Maybe would be though
09:08:08 <dankna> well, it might not be nice at all, but it's a lot simpler than adding a CSP solver
09:08:08 <roconnor> sipa: if we write this out then IO a = Free IOTeleType a ~~ Unit a | PutChar Char (IO a) | GetChar (Char -> IO a)
09:08:18 <dankna> or than making the function partial without a type-level maybe
09:08:48 <Saizan> ah, how are you going to make a Maybe datakind that can contain both * and Nat, then?
09:08:53 <roconnor> sipa: you may want to read http://r6.ca/blog/20110520T220201Z.html
09:09:02 <dankna> it'll be the first kind to have a parameter, I guess
09:09:06 <dankna> that could be complicated
09:09:11 <Saizan> mh, i see
09:09:23 <Saizan> Maybe Nat vs. Maybe *
09:09:34 <dankna> yes, exactly so
09:09:40 <ion> roconnor: Thanks for the explanation.
09:09:47 <conal> ptd: for instance, distinguishing between the denotative and nondenotative parts of haskell, with IO being in the latter. even though people often refer to haskell-with-IO as entirely "functional".
09:10:00 <danharaj> I have a problem with thaw to turn a UArray into an STUArray
09:10:33 <danharaj> The type is too general.
09:10:51 <danharaj> "No instance for (MArray a0 Word8 (ST s))" etc.
09:10:58 <dankna> you need to specify a type signature
09:11:08 <danharaj> I can't specify the (ST s) part.
09:11:11 <dankna> oh hm
09:11:17 <dankna> well, rather
09:11:23 <dankna> I think the signature is :: STUArray something
09:11:36 <dankna> I think the signature is :: STUArray <whatever-your-index-type-is> Word8
09:11:45 <danharaj> STUArray takes the s variable as well.
09:11:48 <dankna> oh
09:11:51 <dankna> then yes, that's a problem
09:11:57 <dankna> not familiar with ST myself
09:12:06 <ptd> conal: Could you perform IO in a denotational language at all?
09:12:23 <Saizan> danharaj: why can't you? you need that constraint on a function that doesn't return an ST action?
09:12:50 <danharaj> Saizan: my function is runST $ do ...
09:12:56 <conal> ptd: yes, if you have a precise model and useful for what that I/O means.
09:13:01 <sipa> roconnor: interesting
09:13:16 <dmwit> amindfv_: /join #haskell-hacphi ;-)
09:13:30 <roconnor> ptd: for example if IO was restricted to serial teletype IO, there wouldn't be any issues I don't think.
09:13:48 <Saizan> danharaj: can you paste the code? i think there should be a way to add the right type annotation
09:14:54 <Saizan> it might be as simple as adding a asSTUArray :: STUArray s a -> STUArray s a; asSTUArray = id on one use of the array
09:14:57 <conal> ptd: in the 80s, functional programming researchers were pursuing denotative (genuinely functional) I/O. afaict, that investigation was dropped when wadler et al instead came up with a way to avoid solving that problem, which is what Haskellers mainly use now (misleadingly named "monadic IO").
09:15:23 <danharaj> http://hpaste.org/49681
09:16:03 <roconnor> conal: I think that is grossly unfair
09:16:10 <ptd> conal: I once considered the following approach for formally describing the IO monad
09:16:21 <conal> ptd: and so we're doing imperative programming in haskell. inheriting the fundamental shortcomings of imperative programming that largely motivated (genuinely) functional programming in the first place. like the ones john backus described in his turing award lecture/paper.
09:16:31 <Saizan> ?hoogle unsafeThaw
09:16:31 <lambdabot> Data.Array.MArray unsafeThaw :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)
09:16:31 <lambdabot> Data.Array.IO.Internals unsafeThawIOUArray :: Ix ix => UArray ix e -> IO (IOUArray ix e)
09:16:40 <conal> roconnor: oh? which part(s)?
09:17:12 <roconnor> conal: that monaic IO isn't denotative.
09:18:19 <ptd> You could formally describe a simplified IO monad in terms of World values passing
09:18:30 <Saizan> danharaj: yeah, define asSTUArray as in my previous line and have  "bmp <- fmap asSTUArray . unsafeThaw . bmpBuffer $ s"  on line 6
09:18:31 <conal> ptd: can you?
09:18:37 <conal> roconnor: in that you're satisfied with your free/syntactic model?
09:18:54 <roconnor> conal: actually, better, I wouldn't even say wadler had anything to do with "monaic IO"
09:19:03 <danharaj> Saizan: Ok. What's going on and why do I have to resort to something like this :p
09:19:29 <conal> roconnor: i'm talking about the "imperative functional programming" paper.
09:19:37 <roconnor> conal: his work showed how one could directly implement moggie's monadic semantics as a datatype for all sorts of programming in Haskell, reader, writer, error, state, etc.
09:19:37 <conal> roconnor: and its follow-ons.
09:19:47 * hackagebot hbro 0.6.7 - A suckless minimal KISSy browser  http://hackage.haskell.org/package/hbro-0.6.7 (koral)
09:20:08 <applicative> Is there some way to get the @check machinery in my ghci?
09:20:20 <shapr> You could write full on QuickCheck tests.
09:20:21 <ptd> The world -> world functions in the IO monad have the following behaviour
09:20:31 <ion> :m + Test.QuickCheck, quickCheck ...
09:20:37 <roconnor> the fact is that people had been using monadic combinators for writing code doing IO for some time before monads appeared in the langauge.
09:20:39 <Saizan> danharaj: i guess you are confused on why you can't mention 's' in a type annotation on bmp?
09:20:41 <applicative> shapr, I was thinking of getting myself accustomed to that...
09:20:58 <shapr> applicative: QuickCheck is quite nifty.
09:21:26 <conal> roconnor: right. that's part of what i mean when i say that "monadic IO" is misleadingly named.
09:21:33 <roconnor> they did this because monads are a natural way to build tree structures, and as I showed in my blog post, contractive maps from response streams to request streams are nicely captured by a tree type.
09:21:34 <danharaj> Saizan: Yeah, or why GHC can't figure out which one I'm talking about :\
09:21:35 <kmc> morning
09:21:46 <shapr> good morning kmc!
09:22:03 <parcs> applicative: put what ion said in your ~/.ghci
09:22:20 <ptd> They take a state of the world, simulate the passing of a unspecified amount of time, probe the resulting state for values and perform other modifications.
09:22:57 <applicative> parcs, ion, I see, for some reason I figured I would be missing all the obvious instances, but no.
09:23:07 <conal> ptd: are you referring to the model of IO a = World -> (World, a) ?
09:23:23 <conal> ptd: which is a persistent myth about haskell's IO .
09:24:32 <ptd> What's wrong with it?
09:24:41 <danharaj> ptd: concurrency doesn't make sense with it
09:24:43 <Saizan> danharaj: have you tried "bmp <- unsafeThaw . bmpBuffer $ s :: ST s (STUArray s YourIndex Word8)" ?
09:25:04 <danharaj> Saizan: Yeah. At some point it said that the s I gave was different from another s it inferred.
09:25:13 <roconnor> ptd: forever (print "a") and undefined are equivalent according ot the IO a = World -> (World, a) model.
09:25:17 <conal> ptd: what danharaj said. if IO is explainable in that model, then *every* operation on IO must be explainable in those terms.
09:25:29 <Saizan> danharaj: with that exact code?
09:25:32 <conal> ptd: in order to have "compositional semantics".
09:25:48 <roconnor> you don't even have to bring in concurency for it to be a bad model.
09:25:49 <Saizan> danharaj: if you tried something like that on bmp directly it'd fail
09:26:14 <danharaj> Saizan: huh... I guess I made a type when I tried that :o
09:26:40 <kmc> "concurrency" includes things as mundane as "reading a file someone else is writing" or "any network IO"
09:26:45 <ptd> roconnor: What else is wrong with it?
09:26:48 <conal> sadly, this "IO == State World" myth seems to spread more rapidly than it can be cured.
09:26:50 <monochrom> well, the myth was still there in 2000 in the much celebrated "the awkward squad" article and slides
09:26:55 <roconnor> ptd: forever (print "a") and undefined are equivalent according to the IO a = World -> (World, a) model.
09:27:16 <danharaj> Saizan: I get another error though, No instance for (MArray a0 Word8 (ST s)) arising from a use of `unsafeFreeze'. (Last Line)
09:27:19 <conal> monochrom: simon pj points out that the denotational model doesn't work.
09:27:27 <conal> monochrom: in that paper (iirc).
09:27:42 <monochrom> yeah
09:27:58 <conal> monochrom: he makes a half-hearted attempt at a denotational model, expresses soem difficulty and then gives up.
09:28:00 <kmc> conal, it is a useful analogy for learning IO, to a point.  i think there are more useful, less misleading analogies though
09:28:16 <danharaj> saizan: Ah, I have to annotate image <- ... too.
09:28:19 <Saizan> danharaj: do the same to line 3
09:28:23 <Saizan> yeah
09:28:49 <monochrom> well, it also has the forever(print"a") vs undefined counterexample :)
09:29:19 <monochrom> but understandably many readers skip the section against World -> (World, a)
09:29:22 <conal> kmc: and there's the usefulness of knowing that we don't have an accurate model.
09:29:38 <ptd> roconnor: The fact that forever (print "a") never returns doesn't make any difference to us, we are in the World value?
09:29:57 <conal> kmc: for when one wants more than analogies
09:30:43 <roconnor> ptd: that argument doesn't help.  The point is that you can deduce that forever (print "a") and undefined are equal in that type, and clearly these are not supposed to be equal programs.
09:30:46 <conal> kmc: "A thought is harmless unless we believe it." - Byron Katie
09:31:29 <Saizan> danharaj: keep in mind that an annotation like ":: ST s (STUArray s YourIndex Word8)" actually means ":: forall s. ST s (STUArray s YourIndex Word8)" which is fine for line 3 and line 6 since the expressions there are polymorphic on 's', but STUArray s Index Word8 wouldn't be fine for bmp because bmp is already using the 's' that runST (implicitly) gives to the whole st action
09:31:29 <ezyang> I've always been impressed at the fact that IO has been able to support asynchronous exceptions.
09:31:32 <roconnor> ptd: any intenstional perspective you might have on the -> doesn't help.  Scott has told us what -> means and we don't have much of a choice in the matter.
09:31:32 <monochrom> actually, since we're talking about ⊥ and the denotational semantics of World->(World,a) etc, we don't even talk about "return" and termination. forever (print "a") = ⊥, that is bad news.
09:31:42 <BlankVerse> what is last . init?
09:31:48 <BlankVerse> specifically . and init
09:31:57 <kmc> BlankVerse, (.) is function composition
09:31:58 <roconnor> > init [1,2,3]
09:31:58 <lambdabot>   [1,2]
09:31:59 <hpc> > init [1..5]
09:31:59 <kmc> @src (.)
09:31:59 <lambdabot> (f . g) x = f (g x)
09:31:59 <lambdabot> NB: In lambdabot,  (.) = fmap
09:31:59 <lambdabot>   [1,2,3,4]
09:32:42 <kmc> further confusion arises from the fact that GHC's actual implementation of (IO a) looks kind of like World -> (a, World), but is actually totally different
09:33:40 <conal> kmc: yeah. i've often seen that "definition" used to support the claim that IO = State World .
09:33:46 <BlankVerse> @src last
09:33:46 <lambdabot> last [x]    = x
09:33:46 <lambdabot> last (_:xs) = last xs
09:33:46 <lambdabot> last []     = undefined
09:34:16 <conal> kmc: i guess what breaks that argument is that GHC treats IO magically, not compositionally.
09:34:20 <BlankVerse> kmc,roconnor and hpc thanks
09:34:30 <roconnor> ptd: but never fear.  Maybe people (other than conal) enjoy the free monad model of IO.  We grant it might not capture every law about IO, but it is a good starting point that has a clear model and is denotative.
09:34:42 <monochrom> World->(World,a) is there to fix execution order only
09:35:08 <kmc> yep.  implementing execution order by evaluation order
09:36:50 <conal> a benefit of denotative programming is that it leads to useful correct & tractable reasoning. good for equational reasoning. the haskell approach to IO isn't so much good for (correct) equational reasoning, as it is bad for incorrect equational reasoning. which is better than nothing.
09:36:58 <roconnor> > tails [1..3]
09:36:58 <lambdabot>   [[1,2,3],[2,3],[3],[]]
09:37:02 <parcs> @src IO
09:37:02 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
09:37:26 <ptd> What is the free monad model?
09:37:29 <kmc> yeah, they removed it
09:37:46 <monochrom>  @src is handwritten
09:37:49 <kmc> ptd, an IO action is simply a data structure built out of constructors 'return', (>>=), etc.
09:38:11 <BlankVerse> why is _ better than say y : secondLast [x,y] = x vrs secondLast [x,_] = x
09:38:32 <hatds> I've *never* seen someone claim IO a = World -> (a, World) as being purely denotive '='.  It's always in the context of being a tool for understanding.  Sometimes that's followed by "And a solid understanding of IO is elusive" and sometimes not.
09:38:48 <monochrom> "secondLast [x,y] = x" generates a warning when you -Wall
09:38:51 <kmc> but a solid understanding of IO isn't elusive
09:38:53 <Saizan> BlankVerse: it's clearer that you're not using that part
09:39:15 <roconnor> BlankVerse: also using lists for pairs is usually bad.
09:39:19 <danharaj> I like to think of IO actions as lambda terms where some terms are reduced by making system calls.
09:39:26 <kmc> maybe the real barrier is that people aren't used to programs that manipulate programs
09:39:33 <danharaj> and substitution is explicitly done.
09:39:36 <kmc> which is sad if true
09:39:53 <BlankVerse> Saizan: thanks , myButLast'' [x,_]  = x and myButLast''' (x:(_:[])) = x ? any difference with the way _ is used?
09:40:03 <kmc> i think of IO actions as programs in some imperative language
09:40:06 <conal> i tried to shed some light on this program-manipulating-program view in http://conal.net/blog/posts/the-c-language-is-purely-functional/ "blog post"
09:40:10 <BlankVerse> roconnor: tuples are better for pairs i guess
09:40:12 <kmc> yeah
09:40:36 <conal> (oops -- ignore the accidentally pasted "blog post")
09:40:36 <danharaj> kmc: Like augmenting plain old beta reduction with system calls?
09:41:04 <kmc> ptd, free monad of IO in GADT syntax:  data IO a where { Return :: a -> IO a; Bind ::  IO a -> (a -> IO b) -> IO b; GetChar :: IO Char; PutChar :: Char -> IO (); ... }
09:41:17 <hpaste> sutabi pasted “Parse Error on line 17,  what am I doing wrong?” at http://hpaste.org/49684
09:41:20 <hatds> kmc: you can say IO isn't elusive, but I'm talking about what people say
09:41:21 <Saizan> BlankVerse: those two are the same, [a,b] is just syntactic sugar for (a:b:[])
09:41:29 <kmc> ptd, point is that your Haskell program just builds up terms in this data type
09:41:36 <kmc> the terms are inert data; they don't "do" anything
09:41:53 <kmc> but a separate component outside your Haskell program can inspect those terms and perform the actions so described
09:41:53 <Armaoin> Hi all
09:41:56 <hatds> the context is never that IO a = State World, it's always a context where the '=' is an analogy
09:41:57 <kmc> hi Armaoin
09:42:00 <sutabi> hellov:)
09:42:00 <ptd> kmc: I understand the definition exactly
09:42:00 <BlankVerse> Saizan: ahh got it , thanks
09:42:06 <conal> danharaj: sometimes we tweak our IO code to generate a different sequence of system calls that perform the same function. it's this notion of sameness that's missing for me.
09:42:08 <roconnor> ptd: non GADT syntax for free model of IO: http://www.haskell.org/haskellwiki/IO_Semantics
09:42:22 <kmc> ah, that one's continuation-based
09:42:23 <kmc> i like that
09:42:27 <danharaj> conal: that reasoning is OS and concurrency model specific though.
09:42:33 <roconnor> kmc: nope, not continuation based either.
09:42:38 <kmc> well, hmm
09:42:53 <kmc> i think of the RHS arg to (>>=) as a continuation
09:42:57 * monochrom likes the continuation story too
09:43:23 <conal> danharaj: in that it depends on the meaning of "forkIO" and the meanings of the syscalls. and we imperative haskell programmers do care what those things mean. if we didn't, then we wouldn't mind when the meanings changed arbitrarily.
09:43:27 <Saizan> and you can read "free monads for less part 3" to get a version of IO where the command/response structure is better factored out than in the above forms :)
09:43:28 <roconnor> ya, you can presumably codensity transform thingy it and get a continuation story.
09:43:53 <kmc> roconnor, i like this article, thanks for pasting it
09:44:27 <danharaj> conal: do you agree that things like IORef and its body of functions has a good model of algebraic reasoning?
09:44:46 <applicative> parcs ion shapr thanks ..., i now have a :check enabled ghci.
09:45:13 * applicative cant seem to get a space after the prompt if he specifies :set prompt blah
09:45:14 <sutabi> Anyone know what I am doing wrong here? http://hpaste.org/49684
09:45:16 <hatds> here is a related link (to roconnor's) on IO I came across recently: http://r6.ca/blog/20110520T220201Z.html
09:45:20 <conal> danharaj: with a particular semantic model? in the context of concurrency? ??
09:45:25 <ion> :set prompt "blah "
09:45:32 <danharaj> conal: well, maybe just for single-threaded use
09:45:33 <kmc> danharaj, seems like at least ST actions can be given a denotation as functions transforming a state store
09:46:02 <kmc> that's how one usually does mechanized metatheory about imperative programs, anyway
09:46:09 <roconnor> danharaj: they have a good modle of algebraic reasoning so long as concurrency isn't brought into the picture ;)
09:46:16 <kmc> sutabi, what's the error / misbehavior?
09:46:23 <roconnor> though I kinda think that IORef should be disallowed if you are going to use forkIO.
09:46:34 <kmc> sutabi, don't use 'length' and 'head'; use pattern-matching
09:46:35 <conal> danharaj: if you eliminate IO and replace it with a tiny sliver (not one used in practice), then you can give a semantics and do some reasoning.
09:46:40 <sutabi> kmc, parse error line 17, right after the if
09:46:56 <kmc> sutabi, every "if" needs a "then" and an "else"
09:47:11 <jmcarthur-hacphi> roconnor: disallowed?
09:47:13 <kmc> if you need a trivial do-nothing IO action, use "return ()"
09:47:19 <hatds> sutabi: off hand it looks like you trying to use "let x = y" as assignments
09:47:26 <kmc> sutabi, but there's more problems here; one of your branches is just a bare "let"
09:47:29 <applicative> suitabi there is a missing else
09:47:29 <kmc> that means nothing by itself
09:47:44 <kmc> sutabi, you're trying to use "withdraw" as a mutable variable that gets updated
09:47:45 <BlankVerse> the lambdabot is really cool , how can i find detailed info about the name of the function also?? @src (!!) is enuf to know what it does ... but anything for searching the official source code?
09:47:47 <kmc> that's not how "let" works
09:47:50 <danharaj> let makes a new definition, it's not an assignment
09:47:53 <roconnor> jmcarthur-hacphi: disallowed!
09:47:55 <Saizan> i don't think it's that hard to make a model of IORef + forkIO
09:47:58 <kmc> BlankVerse, in GHCi, :i will tell you which module it came from
09:48:13 <roconnor> Saizan: I don't think it will have nice algebraic properties though.
09:48:38 <BlankVerse> kmc: awesome .. any online browser for haskell modules source code?
09:48:42 <kmc> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/index.html
09:49:00 <hpaste> ezyang pasted “First results” at http://hpaste.org/49685
09:49:05 <ezyang> \o/
09:49:20 <ezyang> Except some of the results are negative. Which is weird.
09:49:20 <ion> The Haddock documentation linked from Hackage has links to sauce.
09:49:21 <hatds> sutabi: let's in do block scope over the following do-statements, but "if bool then m1 else m2  encapsulate blocks m1 and m2.  Think of if/then/else as a 3 variable function  Bool -> m a -> m a -> m a
09:49:22 <sutabi> kmc, sorry im just started learning haskell yesterday,  so all this is new to me
09:49:22 <kmc> sutabi, also, you're invoking 'reads' twice, once in 'isDouble' and once in 'read'
09:49:27 <BlankVerse> kmc: thanks a lot
09:49:30 <kmc> sutabi, instead make isDouble return Maybe Double
09:49:34 <Saizan> roconnor: heh, probably not, if you mean ones that talk about a single thread at a time :)
09:49:35 <conal> A quote from Backus's Turing award paper: "Denotational semantics and its foundations provide an extremely helpful mathematical understanding of the domain and function spaces implicit in programs. When applied to an applicative language (...), its foundations provide powerful tools for describing the language and for proving properties of programs. When applied to a von Neumann language, on the other hand, it provides a precise semantic
09:49:35 <conal> description and is helpful in identifying trouble spots in the language. But the complexity of the language is mirrored in the complexity of the description, which is a bewildering collection of productions, domains, functions, and equations that is only slightly more helpful in proving facts about programs than the reference manual of the language, since it is less ambiguous."
09:49:35 <kmc> and pattern-match on the result
09:49:47 <kmc> sutabi, "if then else" is not nearly as ubiquitous in Haskell
09:49:56 <kmc> we prefer data types richer than Bool
09:50:03 <conal> and another: "Thus denotational and axiomatic semantics are descriptive formalisms whose foundations embody elegant and powerful concepts; but using them to describe a von Neumann language can not produce an elegant and powerful language any more than the use of elegant and modern machines to build an Edsel can produce an elegant and modern car."
09:50:43 <roconnor> conal: yes, but IO is not nearly as bad as C++
09:50:59 <danharaj> IO is the nicest imperative language I know.
09:51:13 <applicative> sutabi: I'm worried you excellent question got lost in there...
09:51:29 <conal> roconnor: would an adequate and descriptive (not conservative) denotational model for haskell's IO be any simpler than C++'s ?
09:51:41 <roconnor> conal: yes
09:52:06 <BlankVerse> kmc: where are the ghc modules actually on my system?
09:52:10 <conal> roconnor: and yes, haskell-with-IO is a better fortran (imperative language) than fortran or java or c++ .
09:52:56 <BlankVerse> kmc: i like poking into the source on my system
09:53:07 <conal> roconnor: i don't know what you could omit from a c++ denotational model and still be expressive enough for haskell IO.
09:53:52 <conal> roconnor: assuming you don't take a free monad approach. which you could take in c++ as well. or more simply, a free monoid model, which was one of the points of my c-is-functional post.
09:53:55 <danharaj> Half of C++'s definition is 'undefined'
09:53:59 <applicative> BlankVerse it might depend what platform, I can get mine in a browser with file:///usr/share/doc/ghc/html/libraries/doc-index.html
09:54:00 <roconnor> conal: all the implicit stack manpulation done when entering and leaving a c++ funciton.
09:54:13 <conal> danharaj: ditto for io, don't you think?
09:54:16 <sutabi> applicative,  kmc gave me some starting points.
09:54:31 <BlankVerse> applicative: linux ... source instead of docs?
09:54:37 <danharaj> conal: Maybe the library that comes with IO :p. I mean, there's basic language primitives in C++ that are undefined.
09:55:14 <roconnor> conal: I don't even know how goto between functions in C++ works.
09:55:15 <applicative> BlankVerse note that with haddocked docs you can click through to the highlighed source
09:55:18 <monochrom> undefined's make the specification simpler!
09:55:32 <roconnor> conal: but however it works, we can leave that bit out
09:56:01 <conal> danharaj: for me, understanding a type includes understanding all of the primitives of the type. i'd guess that the IO type has tens of thousands of primitives. which is a lot to take on.
09:56:04 <hpaste> “Chris Smith” pasted “Weird stuff with Category, Applicative, and Arrow” at http://hpaste.org/49686
09:56:08 <BlankVerse> applicative: i cant find the source of say reverse in Data.List
09:56:20 <cdsmithus> SO, ANYONE WANT TO LOOK AT MY QUESTION IN THE PASTE?
09:56:21 <roconnor> conal: haskell 98 doesn't have that many primitives.
09:56:22 <cdsmithus> Oops
09:56:26 <cdsmithus> Sorry about caps lock
09:56:57 <BlankVerse> applicative: do i need to install something for reaching the source?? where are the haskell modules say Prelude installed ?
09:56:58 <applicative> BlankVerse: hm, mine is at file:///usr/share/doc/ghc/html/libraries/base-4.3.1.0/src/GHC-List.html#reverse
09:57:01 <roconnor> cdsmithus: the dual of applicative is applicative
09:57:09 <roconnor> cdsmithus: (flipping the order of effects)
09:57:12 <conal> roconnor: i'm talking about all uses of FFI, which is the bulk of IO primitives.
09:57:25 <BlankVerse> applicative: i have this as page not found .. i am missing the full docs?
09:57:28 <cdsmithus> Ah, okay, so getting the effects backward still gives a valid Applicative instance?
09:57:35 <applicative> BlankVerse, I think some linux distributions have a separate "ghc-docs" of "Haskell-Platform-docs" type thing, I am using the OS X haskell platform
09:58:22 <roconnor> conal: oh. in that case then maybe it is the same size as a hypothetical C++ standard that includes all the inline assembly.
09:58:28 <roconnor> that is used in practice.
09:58:29 <conal> as opposed to a library of non-primitives (defined via primitives and other non-primitives).
09:58:36 <applicative> BlankVerse: but maybe something like  "locate html/libraries/base-4.3.1.0/ " will tell you if they're there
09:59:14 <roconnor> cdsmithus: somewhere I have a newtype wrapper called Backwards that makes this backwards applicative instance.
09:59:28 <conal> roconnor: who knows. however, do you really want to defend Haskell by saying it's better than c++? i'd like to aim much higher than that.
09:59:40 <roconnor> cdsmithus: so ya, if you get all your effect backwards you will still get an applicative instance.
09:59:57 <cdsmithus> roconnor: that makes sense, then.  I always thought the left to right order of effects was somehow fundamental in applicative
10:00:38 <roconnor> conal: I don' think the problem likes in enumareting the primitives of IO.
10:00:40 <conal> roconnor: i wouldn't want to claim that imperative haskell-with-io is as unpleasant as c++. i'd much rather do my imperative programming in haskell-with-io. until we know how to program denotatively.
10:00:50 <conal> roconnor: which problem?
10:01:16 <roconnor> conal: the problem of giving denotative and precise semantics to I/O.
10:01:17 <cmccann> nothing forces an order on an Applicative because the structure of the computation is independent of the functions being lifted
10:01:35 <cmccann> cdsmithus, this is also why you can't do control flow with Applicatives
10:01:57 <conal> roconnor: meaning problems arise even before you face those zillion primitives?
10:02:10 <applicative> BlankVerse: see, for example here with debian http://packages.debian.org/sid/haskell-platform-doc
10:02:34 <cdsmithus> cmccann: Right, that makes sense then.  Thanks!
10:02:37 <conal> roconnor: (wondering what you mean by "*the* problem" (emphasis mine))
10:03:33 <roconnor> conal: knowing how to (1) create a (modular) specification of a piece if I/O, and (2) know how to combine those pieces are the hard bits.
10:03:40 <kmc> so i'm signed up to give a ~1 hour talk on why haskell is good and why you should bother learning it, to an audience of intelligent programmers / CS people
10:03:55 <kmc> what topics / examples should i cover?
10:03:55 <roconnor> (3) enumarating all the modular specificaitons of bits of I/O should be easy after that.
10:04:04 <cmccann> kmc, tell them about zygohistomorphic prepromorphisms
10:04:32 <conal> roconnor: i suspect you're right about 1 & 2 being hard bits, though probably not "the hard bits" (not the only ones).
10:05:20 <conal> roconnor: do you have in mind assembling enough semantic modules to compose into all of IO?
10:05:30 <cmccann> kmc, what sort of background do you expect the audience to have, and what kind of interests
10:05:32 <roconnor> conal: the free monad model creates partial modular specifications of pieces of IO by enumarating the types of groups of operations, but not the laws between the operations, and 2 combines them by taking the sum of the functors describing (1), and doesn't have to think about how the various commands from different modules interact since we are not enforcing any laws.
10:05:41 <cdsmithus> kmc:  Even though it's shallow and shouldn't be impressive, find a way to work in list comprehensions early on.  I've found that they impress people and buy you the attention to introduce more complex topics
10:05:47 <roconnor> *modular partial specifications.
10:05:59 <kmc> cmccann, MIT students, probably most of them studying CS
10:06:13 <kmc> cmccann, which sadly does not anymore mean they've had the SICP course
10:06:17 * kmc pours one out for 6.001
10:06:17 <ezyang> Ooooh.
10:06:28 <kmc> ezyang, SIPB cluedump
10:06:39 <shapr> SICM?
10:06:42 <conal> roconnor: more than not enforcing laws, doesn't the free model enforce not-laws?
10:06:50 <applicative> kmc, is 'sequencing' more primitive than control flow, certainly (++) <$> readFile "regweb.hs" <*> readFile "regyy.hs" does what you'd think
10:06:59 <shapr> kmc: http://mitpress.mit.edu/sicm/ ?
10:07:00 <mike-burns> Great exception message: *** Exception: getUserEntryForID: failed (Success)
10:07:05 <kmc> haha
10:07:06 <ezyang> Yeah, I'm not a 100% sure how to properly cater to the MIT crowd, though I have helped out on a Haskell IAP class in the past.
10:07:12 <kmc> ezyang, how did that go?
10:07:19 <conal> roconnor: specifically not-laws in the form of A /= B ?
10:07:27 <shapr> IAP is fun!
10:07:30 <kmc> i don't expect to actually teach anyone Haskell in an hour
10:07:38 <kmc> just to show them enough stuff that they'll want to learn more
10:07:47 <kmc> i was talking yesterday about explicitly separating evangelism from education this way
10:07:49 <cmccann> kmc, hm, maybe the "expressive power" angle would be more productive, rather than emphasizing pragmatics or formalisms
10:07:59 <kmc> in fact, i think the evangelism gets in the way of education
10:08:15 <roconnor> conal: well, the free monad says that two unequal trees are unequal.
10:08:25 <kmc> when your Haskell text stops every three paragraphs to say "no i promise it'll be really good and totally real world nooooo don't leave me"
10:08:54 <roconnor> conal: the missing bit is that two unequal trees might actually be equivalent.
10:08:57 <conal> roconnor: that's what i mean. and many of those statements are false in a more descriptive model.
10:09:01 <kmc> cmccann, yeah, I was going to go light on the formalism angle
10:09:11 <ezyang> kmc: So... are you doing evangelism or education?
10:09:15 <kmc> evangelism
10:09:22 <kmc> in a one hour talk, it's the only option
10:09:25 <roconnor> conal: right, we simply need to mod out by an appropriate equivalence relation.
10:09:26 <conal> roconnor: equivalent == semantically equal in "a more descriptive model".
10:09:28 <kmc> you can't teach Haskell in one hour
10:09:33 <roconnor> conal: yes.
10:09:47 <kmc> i figure people who are super interested in PL theory will end up learning Haskell anyway
10:09:49 <cdsmithus> kmc: Sure, but you do want to show them some code.  Expecting them to be able to produce it is a different matter
10:09:56 <kmc> cdsmithus, of course
10:10:03 <kmc> i want to show them lots of code that does cool things cleverly
10:10:09 <ezyang> You should probably talk a little bit about asynchronous exceptions, and how purity makes this actually work properly.
10:10:15 <cmccann> kmc, and I don't think pragmatics will have as much impact on students, they're probably more easily enthused by "doing neat things" instead of "not doing stupid things"
10:10:17 <conal> roconnor: which requires coming up with a semantic semantics instead of a syntactic "semantics".
10:10:18 <ezyang> (well, imprecise exceptions really)
10:11:05 <kmc> this is more like "I use programming languages as a tool for solving problems; why should I add haskell to the toolbox"
10:11:12 <cdsmithus> kmc: my only concrete idea is to throw something up using list comprehensions early on, because they are unreasonably impressive to most non-Haskell folks I've introduced to the language
10:11:16 <roconnor> conal: but this denoative module is still a good start becuase there are still lots of syntatically distict haskell programs that produce equal IOTree, and we know that no matter what sematics we end up give IO, it will be the case that two programs producing the same IOTree are equal.
10:11:28 <cmccann> doesn't MIT use python these days?
10:11:30 <kmc> cdsmithus, I suspect most of this crowd will know Python reasonably well
10:11:34 <cmccann> so list comprehensions may not be too inspiring
10:11:34 <kmc> yes, for 6.011
10:11:36 <kmc> er
10:11:37 <kmc> 6.001
10:11:44 <cdsmithus> ah, ok
10:11:45 <ezyang> Also talk about how you can write "async" code in blocking style
10:11:51 <kmc> ezyang, yes
10:12:00 <cmccann> saying something about STM might be fun
10:12:03 <roconnor> cmccann: as opposed to the crap World -> (World,a) which already identifies two programs as equal which we know to be unequal.
10:12:05 <roconnor> er
10:12:10 <roconnor> conal: as opposed to the crap World -> (World,a) which already identifies two programs as equal which we know to be unequal.
10:12:12 <conal> roconnor: (required, for a denotational approach). iiuc, you've taken all of what's interesting to me (denotation) and calleld it "simply need to mod out by an appropriate equivalence relation."
10:12:13 <ezyang> I feel like the grungy, RTS bits would appeal to an MIT crowd. Or maybe it would just appeal to me :^)
10:12:15 <roconnor> cmccann: sorry.
10:12:15 <cdsmithus> DSL stuff was impressive to me early on, too... parsec might make a good example
10:12:26 <cmccann> roconnor, no worries
10:12:28 <ezyang> yes yes, ways to write complicated code really quickly and clearly.
10:12:52 <roconnor> conal: No, not *all* of what is interesting to you.
10:13:05 <ezyang> Ooh, you could also demonstrate the "unwinding" process that happens when you change some type definitions and then propagate it through the program.
10:13:06 <conal> roconnor: i think i see what you're saying: your model doesn't make many equivalences on IO, which is better than making some wrong equivalences.
10:13:08 <roconnor> conal: before you were not even sure that the monad laws hold.
10:13:25 <conal> roconnor: what i call "bad for incorrect equational reasoning".
10:13:25 <roconnor> conal: but the IOTree model implies the monad laws hold
10:13:29 <kmc> i'm definitely going to cover pure parallelism too
10:13:57 <cmccann> kmc, another fun thing might be to give a tangible demonstration of fusion optimizations, or even just constant space lazy list stuff
10:14:09 <roconnor> conal: ya, it is hard to do correct equational reasoning when you equations tell you unequal things are equal.
10:14:09 <kmc> yeah
10:14:12 <kmc> i think the first big-picture concept will be denotative programing
10:14:17 <conal> roconnor: sure. and the monad laws are a *tiny* subset of the properties we care about.
10:14:30 <kmc> "in Haskell you say what the result is, not how to get it"
10:14:33 <conal> roconnor: no. it's easy to do incorrect equational reasonong.
10:14:41 <ezyang> I think you will have no end of interesting things to talk about; the problem will be unifying them up. Maybe you could model your talk off the awkward squad paper.
10:14:45 <conal> roconnor: do you get the distinction?
10:14:50 <roconnor> conal: however, all your equational reasoning will be correct if all your equalties are sound, even if it isn't complete.
10:15:09 <kmc> ezyang, awkward squad is more like "Haskell can do these things as well as any other language", no?
10:15:13 <conal> roconnor: agreed. you can to a tiny bit of correct equational reasoning.
10:15:13 <cmccann> kmc, the compositionality benefits of purity + laziness might be a good unifying theme
10:15:19 <roconnor> conal: yes, you are right, it is easy to do incoreect reasoning when ...
10:15:20 <kmc> that's not compelling as a reason to learn it
10:15:23 * applicative thinks he saw incorrect equational reasoning in "Factorizing Folds for Faster Functions"
10:15:24 <conal> roconnor: just as you can do in C.
10:15:24 <kmc> cmccann, yeah
10:15:36 <conal> roconnor: since C satisfies the monoid laws.
10:15:38 <ezyang> oh, sure.
10:15:38 <cmccann> kmc, since that covers stuff like the fusion optimizations, why STM works easily in Haskell, etc.
10:15:46 <kmc> yeah
10:15:48 <roconnor> conal: I think the bit isn't as tiny as you think
10:15:59 <roconnor> conal: teletype IO is essentially lawless
10:16:05 <kmc> i can claim Haskell is the most compositional programming language, and tie everything back to that
10:16:07 <kmc> i like that cmccann
10:16:10 <roconnor> conal: at anypoint you could read any character from any stream.
10:16:12 <cmccann> kmc, oh, and laziness letting you make "control structures" fits in neatly with the EDSLs too
10:16:24 <conal> roconnor: tiny compared to the useful properties of the zillion IO primitives.
10:16:52 <roconnor> conal: most of my programs use teletype IO and network IO and file IO
10:16:57 <roconnor> which are all pretty much lawless.
10:17:18 <conal> roconnor: if they were lawless, then you wouldn't mind my replacing your primitives with others of the same type.
10:17:38 <conal> roconnor: so i don't believe your claim of lawlessness.
10:17:50 <conal> roconnor: i do believe that you don't know what the laws are.
10:18:14 <conal> roconnor: and that no one else knows what they are either.
10:18:40 <monochrom> unlimited lambda may be attractive to people who know python
10:18:59 <ion> kmc: It would be nice if you made a video of that talk.
10:19:05 <kmc> i'll see about it ion
10:19:23 <cmccann> kmc, also might be good to touch on (if only implcitly) some of the ease of refactoring that comes from the same compositionality
10:19:44 <cmccann> the way equational reasoning makes a lot of mindless syntactic shuffling valid
10:19:50 <roconnor> conal: I find it plausible that alpha-renaming my primitive doesn't really change my program.
10:19:51 * applicative give up on claim about  incorrect equational reasoning in "Factorizing Folds for Faster Functions", he failed to see it wasn't all equational
10:19:52 <kmc> yes
10:20:03 <cmccann> which we take for granted in Haskell but fails horribly without both laziness and purity
10:20:22 <kmc> it's also a good angle for talking about higher-order functions, pointsfree style, operator sections, etc.
10:20:30 <kmc> at an earlier point in the talk
10:20:33 <conal> roconnor: that's not a property of IO
10:20:34 <dankna> okay so according to the type-nats docs, "[Nat] is completely separate from GHC's hierarchy of sub-kinds, so Nat is only a sub-kind of itself."
10:20:43 <kmc> so how do you work the "static typing that doesn't suck" theme into this?
10:20:58 <conal> roconnor: and i'd hope so too
10:20:59 <dankna> I'm wondering if it might make sense to add a new kind which has both Nat and * as its immediate sub-kinds
10:21:04 <roconnor> conal: then I don't understand what you mean by replacing my functions with another of the same type.
10:21:06 <cmccann> kmc, I'd say leave that somewhat implicit
10:21:42 <cmccann> kmc, mention it early and then just conspicuously don't bother with types after that, other than occasionally showing what an inferred type would be
10:21:51 <cmccann> I think that would make the point better than anything you'd say directly
10:22:00 <monochrom> if your sample code doesn't show a lot of types, and yet there are compile-time checks, then static type doesn't suck
10:22:05 <kmc> true
10:22:18 <kmc> but it doesn't demonstrate the "your program will work the first time it passes the typechecker" property
10:22:26 <kmc> which i think is really compelling
10:22:33 <cmccann> kmc, true, but I don't think that fits in well with the rest of what you're doing here
10:22:38 <cmccann> can't get everything in at once
10:22:43 <kmc> i can just make that claim and move on; i'm not sure how i could convince anyone, anyway
10:22:57 <cmccann> are you going to be doing this with a live REPL on a projector or something like that?
10:23:07 <conal> roconnor: i mean something like "noop" vs "exit" (or worse).
10:23:10 <monochrom> the property's truth varies wildly with tasks
10:23:10 <kmc> right now i'm just thinking normal slidse
10:23:17 <Nariman> Hi, guys! I am new to Haskell! In how many days I can learn to program on it
10:23:23 <kmc> Nariman, over 9000
10:23:26 <cmccann> kmc, then I don't think there's any good way to get that part across, honestly
10:23:33 <monochrom> a number-crunching program "Int -> Int -> Int -> Int" is not going to benefit from it
10:23:43 <kmc> Nariman, that is a broken question and there is no good answer
10:24:05 <kmc> monochrom, indeed. i guess i could talk about newtype at that point
10:24:09 <kmc> but it's not central to the theme
10:24:10 <cmccann> Nariman, read this: http://norvig.com/21-days.html
10:24:12 <Nariman> No, I mean by sitting around 4-5 hours a day
10:24:28 <Nariman> Thank u all
10:24:37 <applicative> Nariman, you learn a lot in a week, then you cry.  then you recover and make a lot of progress for a few months, then you cry again. then etc...
10:25:05 <kmc> or, depending on attitude: you try to learn for a week, get frustrated, write a blog post "debunking the haskell hype", and move on
10:25:19 <cmccann> kmc, anyway, the "type checking often means correct" thing is hard to communicate without actually demonstrating it
10:25:21 <applicative> Nariman: The elements are pretty straightforward, have you looked at standard tutorials like "Learn You a Haskell"?
10:25:50 <Nariman> Not yet, I am just trying it on my web
10:25:53 <Nariman> browser
10:25:53 <conal> roconnor: off the top of my head. more generally, we sometimes change our imperative programs into equivalent ones that a free monad/monoid view says is not equivalent. if we only cared about the free view, then we wouldn't mind changing to genuinely inequivalent ones (like noop --> armageddon).
10:26:45 <kmc> Nariman, why do you want an a priori cost/time estimate?
10:28:00 <monochrom> "type-checked program is correct" works best for either user-defined types or polymorphic types. "f (a,b) = a" after type-checking is not going to return the second element. "g :: MyAST -> IO ()" cannot have string injection vulnerabilities.
10:28:27 <Nariman> I am always asking this question, just to know! Its easier to plan
10:28:28 <roconnor> conal: swaping noop and armageddon produces an isomorphism between programs but not equivalence.
10:28:51 <applicative> Nariman, there is little to be said against learning the ABCs of Haskell, almost everyone agrees it helps them think in other languages.
10:28:52 <roconnor> conal: same as swapping /\ and \/ in a lattice.
10:28:56 <cmccann> kmc, anyway, I think it's more important to have a focused theme than to get everything you can in
10:29:01 <kmc> yeah
10:29:07 <kmc> but i think static types fit the compositionality theme
10:29:18 <kmc> the types are what guide your compositions
10:29:28 <cmccann> kmc, yeah, that much works in nicely
10:29:39 <monochrom> Nariman, you need to upload your brain for a free estimate
10:29:44 <roconnor> conal: but this is a good example to think of.
10:29:44 <cmccann> if you had a live REPL there would be some benefit to making sure you goof up a couple times to show how the compiler catches your mistakes
10:30:08 <cmccann> but with it all written out and static I think that would just distract
10:30:23 <monochrom> the free estimate will take 3 months
10:30:37 <kmc> Nariman, don't expect learning Haskell to be fast or easy.  for most people it involves learning a totally new way to think
10:30:47 <kmc> while other programming languages are just new syntax for old concepts
10:31:28 <Nariman> Ok, thank u for help
10:31:33 <kmc> :)
10:31:36 <Nariman> ))
10:32:10 <kmc> cmccann, i also want to work in algebraic data types; I guess the angle there is that pattern-matching is more compositional than conditional-based spaghetti code
10:32:33 <kmc> polymorphism and compositionality is another obvious fit
10:32:42 <cmccann> kmc, yeah
10:32:56 <cmccann> maybe work in some custom, very polymorphic combinators
10:33:15 <cmccann> the kind of thing where there's very few implementations with that type and the most obvious one is correct
10:33:16 <kmc> pattern-matching + polymorphism gives you a precise limit as to how far you can look in a data structure
10:33:26 <kmc> like löb's theorem ;)
10:33:34 <applicative> Nariman, install the "haskell platform" with ghc and ghci.  read
10:33:38 <applicative> @where LYAH
10:33:38 <lambdabot> http://www.learnyouahaskell.com/
10:33:51 <kmc> i wonder if i should talk about type classes at any length
10:34:01 <kmc> as you may have gleaned, i'm not a huge fan of the feature ;)
10:34:03 <applicative> make modules and post them on hpaste.org and our friends here will help you.
10:34:15 <kmc> and i don't think it's that interesting/novel
10:34:29 <cmccann> kmc, no, type classes would mostly distract
10:34:34 <kmc> maybe i'll show sortBy as an example of polymorphism, and then mention Ord as an aside
10:34:37 <kmc> presenting it just as sugar
10:34:56 <cmccann> I'd say just present them as a more structured way of overloading functions and move on
10:35:13 <applicative> Nariman, and dont worry at all that our friends are often talking about various forms of esoterica like Loeb's theorem, everyone is anxious to help beginners
10:35:23 <cmccann> i.e. it lets you have a type constraint that says "an overload of foobar exists for this type"
10:35:50 <applicative> Nariman, they are just passing the type waiting for a really good type error statement to parse for you :)
10:35:51 <Nariman> Oh, I already noticed!!!:)
10:36:23 <roconnor> conal: so what sort of reasoning do we want to do with IO?  We want to prove that if in our IO Tree below certain inputs that an InsertNuclearReactorControlRods node appears right?
10:36:24 <monochrom> s/passing the type/passing the time/
10:36:25 <applicative> Nariman, don't worry about it *at all*, it happens all the time
10:36:46 <monochrom> or, "type error: type cannot be passed"
10:36:49 <applicative> Nariman, but the principal purpose of the channel is for people like you
10:37:01 <ciaranm> any recommendations for a less heavy category theory book i can read alongside Mac Lane?
10:37:10 <conal> roconnor: brb (on the phone)
10:37:19 <roconnor> conal: I think it is out of scope to consider whether or not InsertNuclearReactorControlRods actually inserts control rods into a nuclear reactor.
10:37:20 <cdsmithus> kmc: I wouldn't introduce type classes as just themselves... but I wouldn't shy away from stuff that uses them either.
10:37:28 <applicative> ciaranm: awodey?  there's an online version somewhere
10:37:51 <applicative> @where awodey
10:37:52 <lambdabot> http://www.math.uchicago.edu/~may/VIGRE/VIGRE2009/Awodey.pdf
10:37:54 <applicative> figures
10:38:09 <ciaranm> ta. i can get any book for free from the library anyway, so online or not isn't a huge deal.
10:38:17 <monochrom> when to mention type classes? when you need operator overloading.
10:38:31 <Nariman> Ok, I'll contnue trying hakell, thank u all!!:)
10:38:40 <monochrom> or when you need to justify operator overloading
10:38:42 <cmccann> Nariman, have fun :]
10:38:49 <applicative> awodey is less mathematically intense, his principal 'example' categories can be a little dull, e.g. partiallly ordered sets
10:38:55 <Nariman> ;)
10:38:57 <skchrko> @where Lawvere
10:38:57 <lambdabot> I know nothing about lawvere.
10:39:01 <skchrko> :(
10:39:07 <applicative> Nariman, excellent!
10:39:15 <monochrom> Lawvere's is too light
10:39:36 <ciaranm> applicative: well... i only did half maths for my undergrad degree, and i managed to avoid most of topology, so examples i can understand are good...
10:40:05 <monochrom> but perhaps mixing Lawvere's with MacLane's is just right
10:40:15 <ciaranm> hrm, the link to awodey 404s
10:40:24 <applicative> there is also the lawvere et all textbook. I read it some time ago. At first I thought monochrom was joking for forgot his primer
10:40:42 <applicative> ciaranm: sorry should have checked.
10:41:05 <ciaranm> 'sok, the library has it
10:41:32 <ciaranm> i looked at lawvere... seemed to be very convoluted to avoid using examples from anything other than basic set theory
10:43:22 <applicative> ciaranm: it sounds right from memory that sets are the basic examples -- they also have a textbook on set theory from a category perspective -- certainly all sorts of things come in by the end.
10:43:56 <applicative> the most hilarious part is the communist use of dialogue from politically-correctly-named students.
10:44:26 <ciaranm> i hate that in exam questions... got to remember how to spell silly names instead of alice, bob etc
10:44:45 <conal> roconnor: i'm back. reading the scrollback, i don't think i got across what i was trying to say about noop --> armageddon.
10:45:37 <ciaranm> some of the things in lawvere left me thinking "this is really obvious if it's about monoids or groups, but it just doesn't apply to sets"
10:45:45 <applicative> Fatima: But where's the adjunction; Juan: I know, hit it with Yoneda....
10:45:59 <DrSyzygy> ciaranm: Such as?
10:46:53 <conal> roconnor: it's that i want a basis (precise explanation) for why we're happy making some changes to our imperative programs and not making other changes. and specifically for changes that equivalent w.r.t the missing meaning function but are inequivalent w.r.t a free monad/monoid model.
10:48:07 <conal> roconnor: vs making changes like noop --> aramegeddon, which i'd usually not want.
10:48:14 <roconnor> well if I swapp InsertControlRods with ExtractControlRods, then my proof that under certain conditions (ie, certain points in the IOTree) there exists a node (ie a command produced) for InsertControlRod doen't hold anymore.
10:50:04 <ciaranm> DrSyzygy: as i recall it was something involving permutations. i must admit the writing style put me off enough that i switched to the harder stuff part way through
10:50:28 <ciaranm> i seem to recall there being somewhere where he was trying very hard not to say "group action"...
10:50:32 <DrSyzygy> Heh
10:50:42 <DrSyzygy> Yeah, that sounds like something Lawvere'd do.
10:50:45 <conal> roconnor: ah. you want to reason in terms of your trees. really?
10:52:15 <roconnor> conal: well, I think it is a little more natural to reseaon in terms of a (contractive) map from a response stream to a request stream, but they are naturally isomorphic structures so questions about one can be translated to questions about the other.
10:52:36 <roconnor> conal: so easy to translate that I simply do it in my head.
10:52:37 <ciaranm> mm, are there any books covering linear algebra with category theory?
10:52:49 <conal> roconnor: do you have a pointer to this contractive map business?
10:53:17 <roconnor> No.  Graham was telling me about it.  I think he wanted to write a paper on the topic or was writing a paper on the topic.
10:54:29 <roconnor> acutally contractive maps from Stream A to Stream B are also isomorphic to List A -> B.
10:54:35 <conal> roconnor: i'd like to check it out. the tree stuff is distastefully syntactic for me. (a kind of non-semantics.) i'm intrigued with the contractive maps angle. would you let me know if/when graham writes something? i like his work.
10:55:02 <roconnor> conal: sure
10:55:19 <Saizan> what does contractive mean here?
10:55:19 <conal> roconnor: thx.
10:56:27 <roconnor> Venanzio Capretta's goal is to remove all functions an replace them by inductive/coinductive trees :D
10:57:06 <roconnor> that's a bit of an exageration.
10:57:11 <Saizan> oh, i've been having that same goal for a few weeks :O
10:57:44 <roconnor> but trees are nicer in the sense that we can do structural recursion over them, rather than relying on the fan theorem to do things like compute the modulus of continutity of stream transformers.
11:02:21 <roconnor> conal: ya, I'm now thinking of trees as simply a way to represents contractive stream transformers.
11:03:09 <roconnor> conal: so the contractive stream transformer is the semantics of the tree.
11:04:01 <roconnor> conal: btw, you might like constractive stream transformers from a FRP point of view because they disallow future events influencing past behaviours.
11:04:15 <roconnor> (or so I'm told)
11:04:23 <skchrko> ciaranm, P. Aluffi's "Algebra. Chapter 0"
11:04:47 <conal> roconnor: interesting. i'm looking forward to learning about them.
11:05:06 <Saizan> roconnor: what is the definition of contractive here?
11:05:15 <roconnor> topoligical
11:05:16 <roconnor> let me see
11:05:54 <roconnor> whatever is needed for Banach's fixed point theorem :D
11:06:03 <ciaranm> skchrko: thanks
11:06:38 <roconnor> hmm, contractions seem to be defined using a metric.
11:06:58 <roconnor> So I guess I'm not entirely sure what definition that Graham was using.
11:09:47 <Saizan> i guess it's something like "it needs only n responses to produce n+k requests"
11:10:17 <roconnor> well he was specifically doing n responses to produces n+1 requests.
11:21:02 <roconnor> I guess n responses to produce n+k requests is a special case of n responses produces n+1 requests in some sense.
11:21:45 <roconnor> so n responses to produce n+1 requests covers all types of contractive maps.
11:21:55 <roconnor> (whatever the definition of contractive map is)
11:22:09 <danharaj> what the hell kind of topology is this :[
11:24:08 <roconnor> streams have the standard infinite product topology.
11:25:09 <roconnor> oh wait, is that true?
11:25:56 <roconnor> streams have the topology where things with longer and longer initial segments are closer and closer together.
11:26:08 <danharaj> oh
11:26:13 <danharaj> Yeah I'm familiar with that. It's used in dynamics.
11:26:29 <roconnor> for each list there is an basic open set containing all the streams with that list as the inital segement.
11:26:34 <danharaj> Uhhh what was it call again?
11:29:49 <dafis> the topology roconnor described? product topology of discrete spaces
11:30:33 <singpolyma> Looking for help using Data.Binary and runGet.  The trouble I'm having is shown in: http://pastie.org/2295557 -- it expects an extra Get monad layer and I'm not sure what I'm doing wrong (I'm very new to haskell)
11:30:50 <danharaj> dafis: It's not.
11:31:19 <dafis> danharaj: if the lists he mentioned are finite, it is
11:31:36 <danharaj> Still not :[
11:33:16 <dafis> danharaj: I'm pretty sure, finitely many prescribed coordinates and arbitrary other coordinates is the product topology of discrete spaces
11:34:08 <danharaj> dafis: Yes. But in this case we're restricting to initial segments, not arbitrary coordinates.
11:34:36 <Saizan> singpolyma: it's a bit weird to use runGet inside a Get action, anyhow i think you just miss a return
11:34:42 <danharaj> It's a metric space.
11:34:42 <dafis> danharaj: any finite set of specific coordinates is a subset of an initial segment
11:34:56 <Saizan> singpolyma: return $ runGet (parse_packet (tag .&. 63)) packet
11:35:21 <danharaj> dafis: But is not an initial segment itself.
11:35:47 <danharaj> Nor is it the union/intersection etc. of initial segments.
11:36:08 <singpolyma> Saizan: oh.  thanks!  Why does it expect that?  I thought that since the function returns Get Packet, that would be enough...
11:36:11 <Saizan> ?hoogle runGet
11:36:11 <lambdabot> No results found
11:36:22 <cdsmithus> danharaj: if you restruiict any finite set of coordinates, then there are finitely many prefixes that fix those coordinates
11:36:51 <cdsmithus> foir some sufficiently long porefix klength
11:36:57 <cdsmithus> ugh, I can't type
11:37:05 <cdsmithus> prefix length is what I meant
11:37:41 <Saizan> singpolyma: parse_packet returns a Get Packet, but you're using it with runGet which strips the "Get" away
11:37:59 <dafis> danharaj: the set {x_1 = 3 /\ x_3 = 5} is the union of {{x_1 = 3 /\ x_2 = a /\ x_3 = 5} : a \in X_2}, so the sets roconnor described are a basis for the product topology
11:38:09 <singpolyma> Saizan: Oh, I see.  cool.  Thanks!
11:38:42 <danharaj> dafis: yeah. Derp. I was thinking of something else.
11:38:51 <dafis> np
11:39:05 <danharaj> I was thinking of shift spaces :p
11:40:04 <dafis> what were those? (I tend to forget, it's been a looong time)
11:40:34 <danharaj> Closed sets are closed w.r.t. product topology, but also have to be invariant onder the left shift operator.
11:40:48 <danharaj> Which is tail, on lists.
11:41:13 <applicative> skchrko: this Aluffi book does look good.
11:53:46 <k0ral> I have error "cabal: Can't find transitive deps for haddock" when trying to "cabal haddock" my project
11:53:54 <k0ral> can't find much information about it on the net
11:53:57 <k0ral> any clue ?
11:55:33 * shapr yawns
12:06:06 <sutabi> when your using a case how do you return the same value that the case is using?
12:06:35 <sipa> case foo of x@(Constructor bar) -> x
12:10:14 <sutabi> sipa, thanks!
12:10:50 <mike-burns> Big picture: I want to know if a file's modification date is older than six months.
12:11:45 <mike-burns> Using System.Posix.File I can get an EpochTime. I can convert this to a DateTime.
12:12:07 <mike-burns> And using getZonedTime I can get a ZonedTime.
12:12:13 <mike-burns> (For right now.)
12:12:38 <mike-burns> I'm sorta unclear on what do to with these data structures.
12:13:40 <mike-burns> I know this isn't category theory but perhaps someone knows how I'm supposed to be able to do this.
12:14:27 <ciaranm> mike-burns: first you need to define "six months"
12:15:01 <dankna> yeah, it's a slippery notion.  60*60*24*30*6 seconds is one option that comes to mind.
12:15:18 <mike-burns> Figuring out what I mean by "six months" really isn't my issue.
12:15:22 <applicative> k0ral: http://hackage.haskell.org/trac/hackage/ticket/656 ?
12:15:28 <dankna> older than the same time of day on the same day of the month six months back is another option
12:15:42 <ciaranm> mike-burns: no, really, it's central to your problem
12:15:58 <ciaranm> a long long time ago i got burned by lawyers using a different definition of "eighteen months" than some archival software...
12:16:07 <dankna> ouch
12:16:28 <mike-burns> OK so let's say "six months" is 100 seconds. What's my solution?
12:16:30 <dankna> what happened?
12:16:47 <dafis> ciaranm: I'd think to get burned, the judge was relevant, not the lawyers
12:16:48 <dankna> yeah, if it's some fixed number of seconds, you want to convert the ZonedTime to an EpochTime
12:16:53 <ciaranm> mike-burns: if it's 100 seconds (and you don't need to care about clock changes) then you just get the time in seconds and subtract
12:17:31 <mike-burns> How do I convert a ZonedTime to an EpochTime?
12:17:54 <ezrakilty> If you want to use a certain number of seconds, you can do it purely with EpochTime
12:18:13 <dankna> not sure actually, I'd have to look at the API docs
12:18:20 <kmc> nice "category theory" burn, by the way ;P
12:18:24 <mike-burns> Thanks!
12:18:44 <mike-burns> I don't need to get a ZonedTime, either.
12:18:51 <mike-burns> Open to alternatives.
12:18:56 <ciaranm> dankna: the software did it by "same day of the month, but if you go from, say, the 30th of a month with 30 days to the same day in a month with 28 days then go back to the 28th". the lawyers said that legally it should've gone to the 2nd of the next month instead, and thus we nearly got ISO9000-slapped...
12:18:56 <ezrakilty> let fileAge filename = do t <- epochTime; t' <- modificationTime <$> getFileStatus filename; return (t-t')
12:18:57 <sutabi> if I have (RealFrac [(Double, String)]) how do I get access to the Double? I tried "head" but doesn't seem to work as expected
12:19:07 <clsmith> sutabi: fst
12:19:08 <dankna> ciaranm: ouch!
12:19:14 <kmc> sutabi, that's not a type
12:19:28 <kmc> the type is just [(Double, String)]
12:19:45 <kmc> you can use (fst . head) but you *should* use pattern-matching instead
12:19:54 <kmc> case foo of ((d,_):_) -> ...
12:20:07 <incluye> why should you use pattern matching instead?
12:20:08 <clsmith> kmc: wy 'should'?
12:20:09 <mike-burns> Aha, `epochTime'.
12:20:12 <clsmith> *why
12:20:12 <mike-burns> Thanks, ezrakilty !
12:20:21 <ezrakilty> no prob!
12:20:42 <kmc> one reason is that using 'head' hides the question of what happens if the list is empty
12:20:44 <ciaranm> mike-burns: seriously, you need to define six months. what's six months before 31 august?
12:20:55 <clsmith> true
12:21:02 <kmc> ciaranm, sorry, defining six months is category theory
12:21:06 <mike-burns> Hah.
12:21:08 <clsmith> lol
12:21:34 <kmc> another more general reason is that beginners over-use functions like 'head' and under-use pattern-matching
12:21:39 <mike-burns> 15552000 seconds is good enough.
12:21:45 <ciaranm> don't be silly. category theory doesn't concern itself with concrete notions like time and date!
12:21:53 <ciaranm> mike-burns: if you just need seconds, subtract the timestamps
12:22:04 <kmc> pattern-matching is far more powerful but less familiar
12:22:11 <kmc> and so it's probably beneficial to force yourself to use it more
12:22:55 <mike-burns> ciaranm: That's what I'm now doing, thanks to ezrakilty pointing out the `epochTime' function.
12:23:05 * applicative dimly remembers tons of Lawvere papers on classical mechanics, thinking, "There must have been time in there, maybe not dates"
12:23:27 <k0ral> applicative: that's it, yes
12:23:35 <k0ral> applicative: (talking about my haddock problem)
12:25:08 <sutabi> This is probably a dumb question, what does "_" mean?
12:25:21 <kmc> sutabi, it's a pattern that matches anything and binds no variables
12:25:34 <kmc> "wildcard" pattern
12:25:41 <applicative> k0ral: Oh good.
12:25:51 <dafis> sutabi: it means "whatever, I don't care and won't use it"
12:26:15 <sutabi> ah thanks
12:26:39 <applicative> sutabi, like if I define const x y = x  I don't use y again, so I can just do const x _ = x
12:29:04 <applicative> sutabi: but whats to be said against const x whatever = x
12:29:38 <monochrom> const not'used used = not'used :)
12:30:19 <monochrom> const now'you'see'me now'you'don't = now'you'see'me :)
12:31:15 <applicative> I guess it's genuine syntax, unlike
12:31:17 <applicative> > otherwise
12:31:18 <lambdabot>   True
12:31:37 <applicative> since you can use _ more than once on the 'left hand side'
12:32:30 <kmc> and you can't use it in expressions
12:32:33 <kmc> :t _
12:32:33 <lambdabot> Pattern syntax in expression context: _
12:33:20 <applicative> yes, a clearer sign it's syntax.  I was imagining a kind of whatever = undefined :: a
12:33:33 <applicative> but that is nonsense
12:33:38 <ezyang> Oy #haskell. I have a module for getting GC statistics. Where should I put it? GHC.Mem? System.Mem?
12:34:23 <ezyang> GHC.Stats?
12:35:51 <dankna> System.Mem is the most appealing of those to me
12:36:27 <mauke> GC.Stats or GHCx.Something
12:37:35 <applicative> System.Mem is clearly supposed to work in diverse implementations
12:38:17 <sutabi> I feel like everything I learned in c++, java, pascal, and php is just out the window. ~_~
12:38:26 <kmc> yep sutabi
12:38:32 <kmc> best to start with a clean slate
12:39:11 <mauke> that's what you get for learning the wrong languages
12:39:15 <kmc> haha
12:39:22 <applicative> ezyang, eg. there is a jhc System.Mem
12:39:29 <ezyang> Oh, I see. Sure.
12:39:40 <kmc> it's often stated (I think without hard evidence) that Haskell is easier to learn as a first language, for this reason
12:39:41 <ezyang> I don't think GC is a toplevel namespace yet, so I'd feel better putting it in GHC.
12:39:57 <mauke> I'd expect GHC to be reserved for ... ghc
12:40:10 <kmc> sutabi, also, watch out, learning Haskell will make you hate programming in Java and PHP
12:40:29 <monochrom> that's what you get for learning the right language :)
12:40:31 <ezyang> Well, this is a GHC patch for base...
12:40:45 <kmc> if you're planning to make a career programming in Java and PHP then learning Haskell is bad for your job satisfaction
12:41:09 <mauke> hey, who killed ocaml?
12:41:11 <kmc> i'm not kidding about this...
12:41:22 <applicative> sutabi: I think it is possible to have a different attitude than kmc is expressing!
12:41:22 <ezyang> mauke: Last I checked (Friday), OCaml was still alive...
12:41:24 <danharaj> I have trouble programming in C anymore because of Haskell.
12:41:29 <mauke> ezyang: check again
12:41:37 <applicative> i just re-installed ocaml with homebrew
12:41:45 <monochrom> yes, someone's blog article says he's miserable at his work place now
12:41:54 <ezyang> wut
12:42:26 <kmc> is it french april fools day or something
12:42:34 <luite> hmm, can any of the random number generators be run backwards?
12:42:36 * applicative notices a lot of people on #ocaml  . he wasn't familiar with mauke being so obscure.
12:42:46 <luite> +on hackage
12:43:16 <applicative> luite, isn't it random backwards too, though?
12:43:20 <monochrom> I don't think hackage has random number generators that can be run backwards
12:44:32 <luite> applicative: yes, but the difference is that it should give the same numbers again when running it in the usual direction after that :)
12:48:18 <kmc> applicative, which attitude would you prefer?
12:49:00 <applicative> kmc, not sure. many people think they do better writing in other languages knowing haskell, this is the point that pleases me.
12:50:04 <monochrom> it depends on your EQ. you have to use an inferior language at work. perhaps you feel sad. perhaps you're agnostic. perhaps you're cheerful
12:50:04 <kmc> applicative, yeah, I would not generalize my statement to all languages
12:50:37 <ciaranm> haskell's certainly worth knowing, but it's not the only source of interesting ideas out there
12:50:38 <applicative> kmc, admittedly I haven't heard anyone say, man my php is so tight now that I've learned Haskell
12:50:57 <kmc> the problem with Java is that, even if you know all the clever Haskelly tricks, using them in Java is just too cumbersome
12:51:27 <ciaranm> scala comes close to allowing haskell in java
12:51:34 <\yrlnry> I once made an ordered-pair type in Java.  It was really handy.
12:51:42 <kmc> ciaranm, except for being a totally different language, that is
12:52:30 <ciaranm> well yes, but a lot of the clever haskelly tricks can be used in scala with only a small amount of enturdment...
12:52:39 <ciaranm> beats programming in actual java, at any rate
12:52:58 <kmc> right, which is why I would not say "if you're planning to make a career programming in Scala then learning Haskell is bad for your job satisfaction"
12:53:11 <kmc> probably the opposite holds there
12:53:37 <ciaranm> i dislike how they pretend that their for loops are OO monads, though
12:54:19 <kmc> and yes, it depends on attitude.  lots of people have shit jobs, work to pay the bills and come home and don't worry about it
12:54:32 <kmc> programming in Java beats shoveling coal or flipping burgers at McDonalds
12:54:51 <ciaranm> i'm not so sure...
12:54:57 <monochrom> haha
12:55:01 <ciaranm> programming in java feels a lot like prostitution
12:55:09 <ciaranm> flipping burgers is at least an honest career
12:55:19 <kmc> prostitution is an honest career, too
12:55:32 <monochrom> shoveling coal poses health risks and life risks
12:55:35 * applicative has a romantic attachment to the idea of shovelling coal in the basement like disgrace communist bloc intellectuals in the old days.
12:55:36 <kmc> at least it would be, if not arbitrarily illegal
12:56:13 <applicative> disgraced, rather
12:56:14 * ciaranm writes to his MP to get PHP criminalised
12:56:33 <kmc> ciaranm, it does sound like a dangerous designer drug
12:56:40 <monochrom> prostitution is not an honest business. 45-year-olds pose as 18-year-old. both vendors and customers.
12:57:03 <applicative> monochrom, we mean the honest prostitutes!
12:57:05 <ciaranm> i'm sure there's one of those really old school "hot grits" era trolls about php being a drug
12:57:11 <kmc> yes
12:57:51 * applicative had assumed php was best discounted as a mossad plot or something like that
12:58:06 * applicative supposes javascript is a cia plot
12:58:10 <kmc> at my school the Haskell interest group overlapped significantly with the psychedelic drugs interest group
12:58:29 <ciaranm> is that why LYAH is full of monsters?
12:58:35 <applicative> an each the same as singleton kmc?
12:58:41 <kmc> haha, not quite
12:58:50 <kmc> but we did graduate about 25 CS people per year, total
12:58:54 <kmc> so it was pretty small ;P
12:59:56 <kmc> but yeah, we tell people that Haskell will expand their minds, make them notice hidden patterns in mundane things
13:00:17 <kmc> new perspective and new abilities you can apply elsewhere and various other vague poorly-justified psychological benefits
13:00:20 <kmc> so yeah it seems similar to me
13:01:34 <peteriserins> what does haskell offer over clojure?
13:01:47 <ciaranm> about five decades
13:01:55 <kmc> static typing with type inference
13:02:00 <kmc> i.e. programs that work once they compile
13:02:16 <kmc> pure functions with referential transparency and equational reasoning
13:02:17 <peteriserins> ciaranm: lisp came before haskell
13:02:21 <kmc> laziness by default
13:02:31 <kmc> a sophisticated native-code compiler
13:02:32 <ciaranm> peteriserins: yes, and hasn't gained anything new since!
13:02:50 <kmc> peteriserins, I like Clojure, and I think it's philosophically close to Haskell, but technologically quite different
13:03:15 <ciaranm> curry-howard: any bug in your program can be transformed into a bug in your type system
13:04:29 <Dashkal> I'm a fan of the philosophy that an invalid value means your types aren't sufficiently defined
13:04:43 <peteriserins> kmc: am I right to assume you could actually implement most these features on top of Clojure except the native-code compiler?
13:05:07 <kmc> peteriserins, you can implement anything on anything
13:05:12 <kmc> Turing complete blah blah
13:05:28 <Dashkal> mmm, haskell over brainfuck
13:05:31 <kmc> peteriserins, working Haskell's static type system into Clojure would be a huge undertaking
13:05:31 <peteriserins> kmc: right, but in Clojure, you could do it in a way that would not harm runtime performance, right?
13:05:38 <peteriserins> kmc: meaning via macros
13:05:45 <kmc> i'd like to see someone do this
13:05:58 <kmc> but afaik it's not been done, and the result would be worthy of being called a new langugae
13:06:25 <kmc> peteriserins, I'm not sure... a lot of effort in GHC goes toward implementing laziness efficiently, at the low level
13:06:36 <kmc> i.e. individual registers and machine instructions
13:06:59 <kmc> i'm not sure your implementation of pervasive laziness on top of normal Clojure semantics on top of JVM would perform acceptably
13:07:01 <kmc> i honestly don't know
13:07:12 <kmc> of course you can use lazy evaluation "here and there" in Clojure, or in almost any other language
13:07:21 <kmc> at the cost of some extra syntactic noise
13:07:57 <ciaranm> lazy in scala is sloooooooooow
13:08:19 <ciaranm> dunno if that's a quirk of scala or a limitation in the jvm, of course
13:09:06 <peteriserins> kmc: and the type system helps in writing correct/fast programs?
13:09:38 <kmc> mostly on the correct side, yes
13:09:52 <kmc> it's hard to imagine this if you're only used to type systems like Java's
13:10:02 <kmc> but Haskell's types are both less cumbersome (due to inference) and a lot more valuable
13:10:18 <drdo`> kmc: It mostly helps with the trivial human errors
13:10:50 <kmc> right, it moves a lot of typos etc. to compile time
13:10:56 <drdo> yes
13:11:00 <kmc> where in Python or Clojure they might lurk for a long time until you hit some rare code path
13:11:06 <peteriserins> kmc: but is there a more sohpisticated reason for types?
13:11:12 <kmc> peteriserins, what do you mean?
13:11:28 <peteriserins> kmc: anything coming from research rather than practice of programming
13:11:56 <Saizan> you also infer part of your program from types, as you can do with e.g. typeclasses
13:12:04 <kmc> yes, there's a whole story about the correspondence between types and properties, programs and proofs
13:12:07 <kmc> the Curry-Howard Isomorphism
13:12:22 <cmccann> yeah, the research behind types is older than programming :P
13:12:29 <kmc> Haskell's type system is based on decades of theory which has mostly been ignored by "mainstream" languages
13:12:46 <kmc> it's almost unrelated to their toy "x is int, x is bool" type systems
13:13:33 <kmc> which is part of why Haskell is hard to sell
13:13:42 <kmc> people learn Java and they learn that static types suck
13:13:45 <cmccann> kmc, in some cases entirely unrelated, runtime metadata tags aren't the same sort of "types", neither are annotations on how to interpret opaque chunks of bits
13:14:15 <drdo> kmc: I think forcing static types sucks, there's no reason you can't have both
13:14:44 <kmc> yeah, and GHC Haskell supports dynamic typing as well
13:14:47 <drdo> i know
13:14:57 <kmc> but most use cases of dynamic types are really looking for something else
13:15:04 <kmc> like a sum type
13:15:11 <cmccann> I would disqualify any language that assumes reflection or access to memory representation being possible for all "types" as being a statically-typed language at all, honestly
13:15:34 <kmc> http://hackage.haskell.org/package/vacuum ;)
13:16:27 <aninhumer> cmccann: if we're talking C, you could argue that's not really a feature of the language
13:16:31 <cmccann> kmc, Haskell is not "whatever GHC lets you do" ;]
13:16:45 <kmc> cmccann, but GHC Haskell is not statically typed?
13:16:58 <cmccann> aninhumer, I would say that C's only type system is the honor system
13:17:28 <kmc> i dunno, having done a lot of C and Python programming recently, even C does a far better job with catching trivial typos etc
13:17:29 <ciaranm> perhaps the term "statically typed" should be replaced by "helpfully typed", and java reclassified as "annoyingly typed"
13:18:07 <drdo> cmccann: Haskell really is "Whatever GHC lets you do"
13:18:16 <cmccann> kmc, quibbling over whether vacuum counts doesn't really mean much in the presence of stuff like unsafeCoerce
13:18:43 <mauke> ghc lets you run arbitrary machine code
13:19:02 <cmccann> GHC letting you subvert the type system is just a fact, but because these aren't part of the standard it's easier to talk about subsets of GHC Haskell that don't include those
13:19:24 <aninhumer> cmccann: C doesn't define what anything does if you break the honor system though
13:19:44 <aninhumer> as far as I know anyway
13:19:47 <mauke> some things require diagnostics
13:19:51 <cmccann> aninhumer, hm, true
13:20:22 <kmc> cmccann, yeah, I'm sure we agree on the substantive points
13:20:26 * cmccann wonders what percentage of C programs have absolutely no undefined behavior at all
13:20:26 <aninhumer> Or in other words C is not what x86 lets you do ;P
13:20:34 <kmc> for the record, I really *like* that GHC lets you break the rules when you really want to
13:20:49 <cmccann> aninhumer, yes, point granted. I'm not giving standard C enough credit.
13:21:04 <cmccann> kmc, I do too, but I like more that there's a well-defined subset that doesn't break the rules
13:21:41 <aninhumer> I seem to remember it's hard to detect undefined behaviour in C
13:21:43 <cmccann> it's harder to do the same in many other languages, and even when you manage to it often carries a much higher penalty on usability
13:22:28 <ciaranm> it's not hard, it's impossible
13:23:25 <cmccann> ciaranm, you mean impossible as in intractable, or impossible as in "requires solving the halting problem"
13:23:31 <Eliel> hmm... I found a way to consistently get ghci to crash with Floating Point Exception through Data.Aeson library.
13:23:46 <Eliel> 1. start ghci 2. import Data.Aeson 3. encode 5.0
13:23:51 <ciaranm> cmccann: the latter... think char c[10]; c[some_function(1234)];
13:24:15 <ciaranm> cmccann: you'd need to be able to prove that some_function(1234) gives you something in 0..9
13:24:23 <cmccann> Eliel, what kind of crash?
13:24:37 <Eliel> it prints Floating Point Exception and exits
13:25:09 <Eliel> seems to work on another system
13:26:21 <cmccann> Eliel, interesting
13:26:30 <Eliel> yes, works on another system... I wonder what's the difference. They both have GHCi 7.0.3 ... ah, except Data.Aeson version differs
13:26:38 <Eliel> works with 0.3.2.7 but doesn't with 0.3.2.9
13:27:06 <cmccann> that sounds like it may be something worth contacting the maintainer over or filing an issue if there's a tracker for it
13:27:34 <Eliel> I'll first test if using an older version fixes the problem on the first system
13:27:44 * cmccann nods
13:31:19 <Eliel> ok, seems to happen with Aeson 0.3.2.7 too
13:32:34 <Eliel> and works on the other system with Aeson 0.3.2.9 ... ok, I'm a bit at a loss on how to debug this.
13:33:12 <cmccann> Eliel, I'm not really sure either :T
13:36:56 <hpaste> fragamus pasted “this guard is not happy” at http://hpaste.org/49694
13:37:24 <fragamus> yeah ^^^
13:38:14 <kmc> well, «RandT g (ListT IO)» is not a MonadPlus
13:38:16 <fragamus> I have somehow miraculously added RandT to this monad transformer stack, but I'm having trouble understanding this error
13:38:39 <kmc> MonadPlus is the type class that covers monadic actions with "failure" and "alternatives"
13:38:49 <cmccann> what's using that? guard, right?
13:38:54 <kmc> yeah
13:39:08 <kmc> basically it doesn't know what you mean to do in the case where the guard returns false
13:39:18 <kmc> fragamus, why not do your randomness inside IO?
13:39:39 <fragamus> i have reasons
13:39:42 <Saizan> i think it makes sense to have a MonadPlus m => MonadPlus (RandT g m) instance, though
13:39:54 <Saizan> but you've to write it
13:39:57 <kmc> it probably does
13:40:01 <fragamus> but mainly, I need to stack a whole shitload of monad transformers
13:40:22 <fragamus> and I need to learn how
13:40:25 <kmc> Saizan, do you use the same randomness on both branches?
13:40:41 <kmc> does StateT have MonadPlus?
13:40:45 <Saizan> kmc: i'd do that, yes
13:40:56 <dankna> so I just had a conversation with edwardk1 wherein I learned that he has already solved my problem, without modifying GHC.  heh!
13:41:17 <Saizan> subtraction for type nats is the problem?
13:41:23 <dankna> yes
13:41:31 <dankna> he did it by defining type ints first and defining type nats in terms of them
13:41:38 <fragamus> i use the same randomness throughout
13:41:39 <cmccann> could always modify GHC anyway
13:41:41 <cmccann> y'know, for fun
13:41:43 <dankna> I'm looking at his implementation now (well in a few seconds)
13:41:53 <dankna> yeah, but if it's not necessary, the fun is taken out of it :)
13:42:10 <Saizan> ah, but type ints defined how?
13:42:18 <fragamus> I feel so lame
13:42:18 <fragamus> trying to code in this language
13:42:37 <dankna> ah, well, he has sixteen types which he uses as four bits of information
13:42:41 <kmc> yes, StateT has MonadPlus, and yes it drops the state transformations on the "failed" branch
13:42:42 <dankna> and type-level lists of those
13:42:53 <fragamus> I feel like I'm coding like a girl
13:43:02 <thoughtpolice> edwardk1 solves a problem in ways you didn't think were possible. news at 11
13:43:07 <dankna> indeed
13:43:30 <kmc> nice sexism fragamus
13:43:32 <Saizan> well, it solves it by changing the whole problem :)
13:44:12 <dankna> well, yes, as you say
13:46:02 <kmc> ...seriously, nobody else has a problem with that?
13:46:12 <lucca> yes, some of us do.
13:46:13 <dankna> well, no, kmc, you're right
13:46:46 <aninhumer> kmc: yes but you already said it
13:46:51 <cmccann> kmc, I agree fully but didn't have anything to add :P
13:47:07 <thoughtpolice> kmc++ # my feelings should be apparent
13:47:36 <dankna> when trying to pull embedded assumptions out by the root, it is definitely useful to voice redundant support, so I apologize for not doing so immediately
13:47:50 <kmc> ah, thanks for backing me up :)
13:48:05 <cmccann> besides, I have empirical evidence that it's not only sexist but inaccurate. I see lots of really, really terrible stuff on Stack Overflow in the moderator tools and most of those are clearly male programmers :D
13:48:29 <thoughtpolice> lol
13:48:45 <aninhumer> cmccann: empirical or anecdotal?
13:48:59 <kmc> yeah, it's important to establish a community consensus on these things
13:49:06 <cmccann> aninhumer, empirical is a fancy way of saying "lots and lots of anecdotes combined"
13:49:17 <aninhumer> cmccann: with MATHS! :)
13:49:22 <danharaj> kmc: My policy is to ignore trolls unless I have something to gain from it (like amusement, or a reason to procrastinate).
13:49:41 <ciaranm> cmccann: isn't your empirical evidence against the converse?
13:49:46 <lucca> I always liked the phrase "In a holistic sense..." ...meaning no.
13:49:48 <dankna> that said, I am sitting in a room with 29.5 male Haskell programmers and it's remarkably difficult to believe that female ones exist at the moment :)
13:50:03 <dankna> despite knowing at least one excellent counterexample *nods to lucca*
13:50:16 <kmc> danharaj, this doesn't seem like trolling, just a carelessly insensitive remark from someone otherwise well-meaning
13:50:18 <kmc> shrug
13:50:18 <Saizan> the .5 is someone at the door?
13:50:25 <danharaj> kmc: YOUR FACE IS CARELESS
13:50:50 <cmccann> ciaranm, yes well, that's the part where I was being somewhat tongue in cheek with "because of SCIENCE!" phrasing :P
13:51:06 <dankna> no, the .5 is me cause I'm too hip for integral gender
13:51:10 <aninhumer> kmc: which was part of the reason I didn't say anything
13:51:33 <cmccann> anyway
13:52:11 <kmc> aninhumer, i think that makes it more important.  the chimpout trolls and the like just get kicked, no point trying to convince them
13:52:16 <cmccann> I was in the middle of doing laundry and am running late to start cooking dinner, so I hope you appreciate the support kmc :P
13:52:21 <pumpkin> cmccann: what's your old nick?
13:52:24 <kmc> cmccann, enjoy your dinner :)
13:52:34 <cmccann> pumpkin, syntaxglitch?
13:52:35 <kmc> people who are actually participating in the community set the tone of the community
13:52:37 <pumpkin> aha!
13:52:44 <ciaranm> besides, you can prove it by induction. the empty set of girls clearly can't program anything, so they're obviously bad programmers, and if you have n bad programmers then adding one more won't give you a good program, thus all girls are bad programmers.
13:52:45 <cmccann> pumpkin, why
13:52:54 <danharaj> Isn't lambdabot a girl? I mean she's the best haskeller I've ever seen. She can do beta reduction in her head!
13:53:14 <aninhumer> ciaranm: also proves there are no good programmers, this is probably accurate
13:53:36 <kmc> i heard that good programmers don't make mistakes
13:53:43 <aninhumer> *I
13:53:47 <kmc> so i agree that there are no good programmers
13:53:57 <danharaj> I heard good programmers pontificate on their blog using gardening and burrito metaphors.
13:54:36 <dankna> the inductive step in your proof fails a pattern match on going from zero to 1
13:54:40 <dankna> you don't have n bad programmers
13:54:47 <dankna> you have no bad programmers
13:55:02 <aninhumer> dankna: why can't n be zero?
13:55:45 <lucca> proof by subduction
13:55:46 <pumpkin> cmccann: was trying to remember what your old nick was :)
13:56:11 <Saizan> people changing nicks? that's outrageous
13:56:29 <Eliel> Ah, finally, found the library that causes the error. error doesn't happen with blaze-textual-0.1.0.0 but does happen with blaze-textual.0.2.0.0. The newer version adds a dependency called double-conversion which looks a bit fishy. Especially since I had to add symlink libstdc++.so for it to even load.
13:56:32 <cmccann> pumpkin, ok. I had some decent quotes saved in lambdabot under that nick, I think.
13:56:38 <cmccann> @quote syntaxglitch
13:56:38 <lambdabot> syntaxglitch says: copumpkin, remember, there's no "I" in "haSKell"
13:56:45 <cmccann> @quote syntaxglitch
13:56:45 <lambdabot> syntaxglitch says: writing DRM isn't possible in Haskell, since it doesn't actually do anything useful GHC simply optimizes it away
13:56:50 <cmccann> meh
13:56:51 <ciaranm> Eliel: you can't just add a symlink to a .so like that
13:56:59 <cmccann> anyway, dinnertime
13:57:28 <dankna> aninhumer, I will have to refer you to that age-old argument technique, "proof by I know it goes something like that".
13:57:32 <Eliel> ciaranm: it tries to load libstdc++.so, but it didn't exist anywhere. However. libstdc++.so.6 did exist so I symlinked to that.
13:58:06 <ciaranm> Eliel: yeah, you can't safely do that
13:58:24 <Eliel> strange, though, that the it compiles fine. Only fails runtime.
13:58:44 <ciaranm> it's not in the least bit strange that it fails at runtime if you're giving it a different libstdc++ to the one it expects
13:59:10 <Eliel> true, I wonder which one it expects though
13:59:20 <ciaranm> it expects the one it was built against
13:59:21 <lucca> while you can't do it safely in-general, in practice you can often get away with it for specific programs.  It's a bad idea but a useful last-resort.
13:59:34 <Eliel> the one I linked is the only one installed on this system
13:59:39 <Eliel> nothing else it could've gotten built against
13:59:55 <ciaranm> depending upon your distribution, that's not exactly the case
14:00:00 <lucca> if you're needing to add symlinks in that case, something has gone terribly wrong.
14:03:01 <Eliel> well, I found a workaround. Use blaze-textual-0.1.0.0
14:04:30 <ciaranm> now remove that .so symlink you created before the universe explodes
14:05:04 <Eliel> yes, removed :)
14:05:48 <Eliel> although, I doubt there's another piece of software installed on this system that would use it anyhow :) But still, it might cause very weird bugs in the future.
14:15:13 <Eliel> oh, interesting, this double-conversion package depends on similarly named package that I don't have installed. I wonder why that doesn't show up until runtime.
14:16:26 <Eliel> oh, the c++ library comes with the cabal package.
14:17:15 <hatds> huh, so :m in ghci will retarget a different ghci command if you have your own which start with 'm' ?
14:17:33 <hatds> is there any way to make :m = :module again without undef'ing my other command?
14:20:58 <hatds> ah, I see: it's not so bad to manually fix it by :def'ing :m to be \_ -> return ":module"
14:21:25 <parcs> hatds: that will be fixed in ghc 7.2. built-in commands will have higher priority when calling by a prefix
14:21:55 <parcs> are you aware that of ghci's import command
14:22:13 <parcs> s/that //
14:25:20 * hackagebot halipeto 2.4 - Haskell Static Web Page Generator  http://hackage.haskell.org/package/halipeto-2.4 (PeterSimons)
14:26:35 <hatds> parcs: thanks, that helps although it won't let me ":module + *mod"
14:26:43 <hatds> with import I mean
14:37:37 <dented42> the GHC configure script checks for ghc-pkg, which makes sense unless there isn't a working ghc on the system. I'm trying to make an unregistered build by bootstrapping .hc files from another system. my question is, is it safe to skip the checks for ghc-pkg?
14:38:06 <kmc> probably
14:40:00 <kmc> dented42, my experience bootstrapping from .hc is that it doesn't actually work
14:40:17 <kmc> and you'll need loads of dirty hacks to bootstrap from .hc, build GHC as a cross-compiler, or anything else in that space
14:40:31 <dented42> ah, thats a pity
14:41:29 <dented42> the reason is, I'm trying to get a working GHC on Alpine Linux, which uses uclibc instead of glibc.
14:41:54 <dented42> but the binary builds all link against glibc
14:42:10 <kmc> oh, that's an interesting project
14:43:15 <monochrom> perhaps first you get hold of glibc and a binary ghc, then use it to build ghc against uclibc, assuming uclibc has what ghc wants
14:43:53 <dented42> I thought of that, but it appears that uclibc and glibc occupy the same location
14:44:14 <dented42>  /lib/libc
14:44:33 <dented42> so as far as I can tell they cannot coexist in the same location
14:44:47 <dented42> er, in the same system that is
14:48:14 <snorble> dented42: you could build GHC on another system and statically link in glibc
14:49:32 <dented42> snorble: would that allow me to substitute uclibc in place of glibc? how would I go about doing such a thing?
14:50:17 <monochrom> have you actually tried running an existing binary ghc on a uclibc system? a casual look at ldd's output doesn't seem to show any glibc-specific requirement
14:50:22 <snorble> deavid: link it statically with glibc move it to your uclibc system and build a new one there
14:50:49 <snorble> dented42: oops autocomplete failure ^
14:51:14 <Guest85794> Is there a GHC extension, which prints filename and location instead of Prelude.undefined, when using undefined?
14:51:44 <monochrom> no, but Control.Exception.assert prints line number
14:51:56 <monochrom> alternatively, this may be useful:
14:51:59 <monochrom> @where stack
14:51:59 <lambdabot> ghc --make -fforce-recomp -prof -auto-all -rtsopts foo.hs && ./foo +RTS -xc
14:52:26 <ryant5000> Guest85794: check out the package error-location: http://hackage.haskell.org/package/error-location
14:53:39 * JuanDaugherty will be impressed if HP slips its announced next release.
14:54:04 <cmccann> Guest85794, also, see http://hackage.haskell.org/package/placeholders
14:55:42 <Guest85794> 'placeholders' looks good.
14:56:27 * cmccann thinks placeholders is actually quite cute
14:56:36 <cmccann> TH really should get more use
14:56:44 <koninkje_away> edwardk: Correction, from working on Dyna. Dana is Luke Palmer's baby
14:56:45 <lambdabot> koninkje_away: You have 1 new message. '/msg lambdabot @messages' to read it.
14:56:47 <cmccann> as hideous as it is, there's useful stuff you can do that way
14:57:38 <Guest85794> cmcann: so TemplateHaskell is a GHC extension, making possible to write libraries as 'placeholders'?
14:58:23 <Guest85794> cmcann: well, The wikipage has a lot of info about TH
14:58:25 <cmccann> Guest85794, Template Haskell is a metaprogramming system, that lets you embed almost any Haskell code you want to be run at compile-time
14:59:34 <cmccann> Guest85794, and you can use it to generate code to do things that you can't really write directly
15:00:02 <cmccann> or to auto-generate a lot of repetitive stuff
15:00:59 <cmccann> but some people don't care for it because TH itself is kinda ugly and clumsy to use, and it pulls in a lot of dependencies
15:01:15 <danharaj> and it's ghc only.
15:01:33 <cmccann> well yeah, but lots of stuff is GHC only that people use more than TH
15:01:47 <danharaj> true.
15:01:58 <koninkje> rather, TH is so complex that it will probably always be GHC-only
15:02:33 <koninkje> whereas other features are currently GHC-only, but could be ported within reason
15:02:44 * cmccann also doesn't really care for how TH works, but eh, it's useful
15:05:02 <Guest85794> thank you, I want to sleep now :)
15:09:58 <mdgeorge> hello
15:13:15 <imc> the "tartelettes au citron" experiment was really a success.... mmmm
15:20:53 <erus`> node.hs
15:21:03 <erus`> Imagine that
15:21:15 <hpc> can't tell if typo or good idea :P
15:24:01 <andybot> hey whats up
15:24:18 <andybot> back
16:01:40 <koning_robot> if I have an enumeration type "data X = A | B | ...", how do I get the list "[A,B,...]"?  I know I can use Enum and then literally do "[A,B,...]", but I don't want to have to mention any of the constructors explicitly.
16:02:55 <dmwit> Why is cabal-install trying to configure "sgf-0.1.1" even though "sgf-0.1.1" is already installed? http://hpaste.org/49697
16:03:01 <hpc> > [minBound .. maxBound] :: [Bool]
16:03:02 <lambdabot>   [False,True]
16:03:10 <hpc> > [minBound .. maxBound] :: [Maybe ()]
16:03:11 <\yrlnry> I want to install haskell-platorm on my Ubuntu box.  When I rnu "apt-get install haskell-platform", it fails with "The following packages have unmet dependencies:
16:03:11 <\yrlnry>  haskell-platform : Depends: ghc6 (< 6.12.1+) but 6.12.3-1ubuntu7 is to be installed
16:03:11 <\yrlnry> "
16:03:11 <lambdabot>   No instance for (GHC.Enum.Enum (Data.Maybe.Maybe ()))
16:03:11 <lambdabot>    arising from the a...
16:03:13 <parcs> koning_robot: make it an instance of Bounded and do what kmc said
16:03:20 <dmwit> I've worked around this using Setup.hs manually about a million times by now today, but I really want to know what the correct fix is.
16:03:23 <hpc> balls, that should be an instance
16:03:26 <\yrlnry> What's that supposed to mean?
16:04:03 <dmwit> \yrlnry: yuck
16:04:05 <parcs> @src Enum
16:04:05 <lambdabot> class  Enum a   where
16:04:05 <lambdabot>     succ                     :: a -> a
16:04:05 <lambdabot>     pred                     :: a -> a
16:04:05 <lambdabot>     toEnum                   :: Int -> a
16:04:05 <lambdabot>     fromEnum                 :: a -> Int
16:04:07 <lambdabot> [3 @more lines]
16:04:07 <parcs> @src Bounded
16:04:09 <lambdabot> class  Bounded a  where
16:04:11 <lambdabot>     minBound, maxBound :: a
16:04:19 <parcs> @more
16:05:01 <parcs> wait
16:05:03 <dmwit> \yrlnry: I mean, I can't tell you what it means other than exactly what the error says: the haskell-platform demands 6.12.1 or older, but the repository only has 6.12.3 or newer.
16:05:05 <parcs> > [toEnum 0..] :: [Bool]
16:05:06 <lambdabot>   [False,True]
16:05:09 <dmwit> which sucks
16:05:11 <\yrlnry> @!!!*&!@
16:05:11 <lambdabot> Unknown command, try @list
16:05:22 <parcs> koning_robot: there, no bounded instance needed
16:05:31 <thoughtpolice> dmwit: 'ghc-pkg check' say anything relevant?
16:05:52 <thoughtpolice> dmwit: sounds like the constraint solver is confused somehow and thinks it needs to rebuild sgf. is dcoutts_ around?
16:05:59 <Saizan> dmwit: because it finds it has to use different dependencies for it than the ones your installed version have used
16:06:00 <parcs> > enumFrom (toEnum 0) :: [Word8]
16:06:01 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
16:06:17 <Saizan> dmwit: IOW, if you change a package bump the version number
16:06:32 <Saizan> dmwit: otherwise cabal-install assumes it's the same as the one on hackage
16:06:52 <dmwit> aha
16:07:08 <dmwit> How can I discover what dependencies it would build it with, so I can build it with those myself?
16:07:14 <dmwit> ...oh, I can just bump the version number.
16:07:16 <dmwit> That's fine.
16:07:25 <dmwit> trying
16:08:39 <koning_robot> Thanks, I am fine with either solution, though I find it strange to use these verbs that have to do with ordered collections on the conceptually unordered collection of constructors I have.
16:12:53 <dmwit> Seems to be making a bit more progress than before.
16:12:55 <dmwit> Thanks!
16:24:20 <fragamus> dmwit: I added RandT to the transformer stack
16:24:47 <fragamus> now i need MonadPlus m => MonadPlus (RandT g m) instance
17:17:21 <mdgeorge> I'm using ints and a map to emulate pointers for a data structure...should I use Map or IntMap?
17:17:49 <hpc> if your keys are Int, use IntMap
17:19:26 <mm_freak> what do you guys do, when cabal annoys you with the age of your package database?  right now i delete ~/.cabal and ~/.ghc, update and reinstall everything from 'world'
17:25:31 <mdgeorge> hpc: okay, thanks
17:25:45 <mdgeorge> is there an easy way to get the largest key from an intmap?
17:25:53 <mdgeorge> or the smalles
17:26:00 <mdgeorge> or really any key that's not present?
17:26:21 <mdgeorge> or do I have to search and/or keep track of it myself?
17:26:21 <Lemmih> mdgeorge: minViewWithKey.
17:26:24 <hpc> @hoogle keys
17:26:24 <lambdabot> Data.IntMap keys :: IntMap a -> [Key]
17:26:24 <lambdabot> Data.Map keys :: Map k a -> [k]
17:26:24 <lambdabot> Data.IntMap keysSet :: IntMap a -> IntSet
17:26:31 <shachaf> findMax and findMin
17:26:47 <hpc> or those
17:27:03 <shachaf> :browse Data.IntMap
17:27:24 <mdgeorge> I'm looking there.  I'd like to do it in faster than linear time...
17:27:31 <mdgeorge> and IntMap doesn't have findMax or findMin
17:28:04 <shachaf> mdgeorge: When you say "linear time", do you mean scanning the output of :browse?
17:28:07 <shachaf> There's always grep.
17:28:12 <shachaf> Or `cabal unpack containers`
17:28:18 <shachaf> My IntMap does hs them.
17:29:22 <mdgeorge> shachaf: no, I was responding to hpc's comment that I could just fold over keys
17:29:29 <mdgeorge> or at least that's what I think he was suggesting
17:29:35 <mdgeorge> hard to tell without words
17:29:55 <shachaf> mdgeorge: Well, keys returns the keys in ascending order.
17:30:03 <shachaf> So you'd get the minimum easily enough. :-)
17:30:07 <mdgeorge> I see.
17:30:19 <hpc> oh neat
17:30:34 <mdgeorge> ok, I will do this, thanks
17:30:39 <Saizan> mm_freak: the age of your package database?
17:30:44 <hpc> doesnt help for max though
17:30:52 <mdgeorge> no, it doesn't
17:30:53 <shachaf> Well, there's findMax.
17:31:02 <mdgeorge> not in IntMap there isn't
17:31:18 <hpc> you should update, methinks
17:31:24 <hpc> @hoogle findMax
17:31:24 <lambdabot> Data.IntMap findMax :: IntMap a -> a
17:31:24 <lambdabot> Data.IntSet findMax :: IntSet -> Int
17:31:24 <lambdabot> Data.Map findMax :: Map k a -> (k, a)
17:31:31 <shachaf> My IntMap has it.
17:31:41 <mdgeorge> ah.  google IntMap leads to something old I guess
17:32:09 * shachaf repeats the suggestion of :browse and/or cabal unpack.
17:32:23 <mdgeorge> what is :browse?
17:32:52 <shachaf> ghci command.
17:33:11 <cmccann> try :browse Data.IntMap
17:33:24 <mdgeorge> I see
17:33:31 <mdgeorge> that's helpful
17:33:38 <mdgeorge> thanks
17:34:06 <mdgeorge> is there a more reliable way to find up-to-date documentation than google?
17:34:13 <danharaj> hoogle
17:34:15 <danharaj> @where hoogle
17:34:16 <lambdabot> http://haskell.org/hoogle
17:34:23 <danharaj> also looking up the package on hackage
17:34:26 <danharaj> @where hackage
17:34:26 <lambdabot> http://hackage.haskell.org/package/
17:34:49 <mdgeorge> thanks
17:34:59 <shachaf> @where cabal-unpack
17:34:59 <lambdabot> A command line near you
17:36:02 <cmccann> @where lambdabot
17:36:02 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
17:36:18 <shachaf> @where #haskell
17:36:18 <lambdabot> Right here, silly!
17:36:21 <shachaf> Huh, that worked.
17:36:25 <cmccann> haha
17:36:31 * cmccann was expecting something like that for "lambdabot"
17:36:37 <shachaf> @version
17:36:37 <lambdabot> lambdabot 4.2.2.1
17:36:37 <lambdabot> darcs get http://code.haskell.org/lambdabot
17:38:29 <doc_who> join #ruby
17:38:31 <doc_who> oops
17:39:07 <shachaf> Don't you mean #ruby-lang?
17:39:16 <danharaj> don't you mean #python?
17:39:32 <danharaj> Seriously why would anyone use Ruby over Python :p
17:39:32 <cmccann> doc_who, couldn't match expected type m (m a) with actual type IRCChannel
17:40:12 <doc_who> shachaf, is #ruby-lang the official one? i had assumed it was #ruby
17:40:35 <doc_who> danharaj, i really don't like python
17:40:37 <shachaf> danharaj: Because they like semi-sane lambdas and FP-style in general?
17:40:53 <danharaj> shachaf: Comes with too much baggage with Ruby.
17:40:55 <shachaf> doc_who: Hmm. I was under the impression #ruby-lang was the official channel and #ruby was the evil rogue channel everybody hated.
17:41:12 <doc_who> i thought ruby would be more popular here though since it borrowed alot from Lisp/functional programming
17:41:25 <shachaf> Haskell is even more popular here.
17:41:27 <shachaf> join #haskell
17:41:27 <shachaf> oops
17:41:34 <doc_who> haha
17:41:36 <danharaj> doc_who: Well don't take my opinion to be representative of the 731 people idling right now.
17:41:57 <shachaf> Don't listen to danharaj. He pretty much *is* #haskell.
17:42:17 <danharaj> No, #haskell is a monad analogy.
17:42:21 * shachaf looks in #-blah.
17:42:22 * cmccann doesn't see any appreciable difference between python and ruby
17:43:19 <danharaj> cmccann: It's my understanding that in most cases Python is either as fast as or faster than Ruby and almost always uses less memory.
17:43:28 <danharaj> But that's an implementation detail.
17:43:38 <doc_who> shachaf, you're right, #ruby-lang is the official one
17:43:40 <shachaf> danharaj: Oh, come on. If you care about efficiency you use neither.
17:43:59 <danharaj> shachaf: Well it's not a yes/no question when it comes to caring about efficiency. It's a priority queue. :p
17:44:04 <dibblego> if you don't care about correctness you use either
17:44:29 <doc_who> haskells nice though
17:44:38 <doc_who> i only recently started using it though
17:44:39 <shachaf> danharaj: Right, it's a priority queue. But the answer for either in still "no", somehow.
17:44:49 <doc_who> my mind hasnt been fucked enough yet by it
17:45:05 <danharaj> shachaf: I disagree. I know some guys who do numerical stuff with Python, and that wouldn't fly with Ruby.
17:46:00 * shachaf would be a bit surprised if you can get a serious-enough-to-matter-where-it-matters difference.
17:46:09 <shachaf> But this is probably a pointless subject.
17:46:13 <cmccann> doesn't numerical stuff in python basically translate to "thin python layer over highly-optimized C libraries"
17:46:28 <danharaj> cmccann: There's no such thing as a thin ruby layer :p
17:46:56 <cmccann> it's kind of disingenuous to compare two slow languages and say one is faster because it uses more C in certain places
17:47:17 <cmccann> if nothing else, I suspect that line of argument quickly leads to using Lua instead
17:47:42 <cmccann> or just using C alone
17:47:42 <shachaf> danharaj: Now look what you've started.
17:47:50 <cmccann> or yknow C through Haskell's FFI
17:47:58 <cmccann> in fact that's probably the best plan
17:48:12 <danharaj> Well you know, Lua is a fine language.
17:48:34 <danharaj> It'd only take a couple of beers before I messed around with Lua.
17:49:01 <danharaj> It'd take a bottle of tequila to get me to touch Ruby. :p
17:49:09 <cmccann> :D
17:55:38 <Dashkal> Careful, Lua is a gateway language
17:56:21 <sohum> @pl \a x -> (x,f a x)
17:56:21 <lambdabot> ap (,) . f
17:57:03 <sohum> @pl \a x -> (x,f x a)
17:57:03 <lambdabot> ap (,) . flip f
17:57:44 <sohum> @pl \x -> (x,f a x)
17:57:44 <lambdabot> ap (,) (f a)
18:10:59 * hackagebot embroidery 0.1 - support for embroidery formats in haskell  http://hackage.haskell.org/package/embroidery-0.1 (JimSnavely)
18:25:40 <cmccann> cdsmithus, congratulations on slogging through that last proof for the Arrow/Category+Applicative thing
18:48:48 <cdsmithus> cmccann: Thanks!  It did get rather long...
18:49:08 <cmccann> cdsmithus, I made a short attempt at the same proofs myself a while back.
18:49:36 <cmccann> And by short I mean "shorter than that particular proof", a comparison that is highly relevant to why I did not complete the task.
18:50:12 <roconnor> link!
18:50:37 <cdsmithus> Umm, it's on Reddit.  I don't have it offhand
18:50:41 <cmccann> http://www.reddit.com/r/haskell/comments/j4h6a/arrow_category_applicative_part_i/
18:50:48 * ddarius suspects that the proofs may be shorter using the alternate presentation of the Applicative class.
18:51:17 * cmccann thinks ddarius may be right
18:51:33 <ddarius> cdsmithus: It's also currently the first article on Planet Haskell.
18:51:56 <cdsmithus> roconnor: sadly, that's only the easy direction, though.  Next comes figuring out the best way to sum up what else is needed to get to Arrow.  I'm working on that still
18:52:16 <cmccann> ddarius, I'm guessing you mean giving Applicative as something like "unit :: f ()" and "fzip :: f a -> f b -> f (a, b)"
18:52:30 <ddarius> Yes.
18:52:43 <ddarius> liftA0 and liftA2 (,)
18:53:37 <cmccann> i.e., dealing with Applicative as lifting tuples, which is roughly what Arrow is doing, which might remove some of the awkward disconnect
18:53:38 <roconnor> cdsmithus: ya, proving applicative laws is such a pain.
18:53:56 <roconnor> cdsmithus: I wonder if it would be easier to prove the monoidial natural transformation laws instead.
18:54:16 <cdsmithus> roconnor: First, I'd have to figure out what that means. :)
18:54:23 <roconnor> ya me too
18:54:25 <roconnor> let me think
18:54:28 <cmccann> heh
18:54:55 <roconnor> let me not think and look it up in wikipedia instead
18:57:14 <cdsmithus> Well, that's done in any case... I'm now trying to figure out if parametricity is any help to closing the distance getting from Applicative back to Arrow..., so, back to poring over the details of free theorems.
18:57:32 <roconnor> cdsmithus: oh oops, you want to show that it is a lax monoidal functor.
18:57:34 <Saizan> well, proving Category+Applicative => Arrow is hard because you've no laws relating the combinators of the source two classes
18:57:54 <cdsmithus> Right... so you'll need *something* else.  I just don't know what
18:58:37 <cdsmithus> My hope is that it turns out to be something that's minor, and that looks pretty obvious for types that have both instances.
18:58:37 <roconnor> cdsmithus: ugh, it doens't look much easier
18:58:45 <roconnor> if anything it looks harder
18:59:35 <cdsmithus> Ah... ddarius and cmccann probably have a point about the liftA0 and liftA2 versions... but I hate the tuple garbage in Arrow, so I wanted to start with what I consider the cleaner presentation for Applicative
19:00:00 <ddarius> It would be using the alternate formulation I mentioned above, and the laws of lax monoidal functors when expressed in not-a-point-free form, probably readily reduce to very similar laws as are usually stated.
19:00:09 <cmccann> then again, Arrow has always seemed kind of ad hoc to me, and I think it's possible that Applicative + Category simply gives you all the "obviously sensible" laws for Arrow, with the missing ones being anything bolted on to demand particular properties
19:01:11 <cmccann> cdsmithus, Arrows alone don't give you higher-order "functions", so you necessarily lose currying in the translation
19:01:19 <cmccann> doing that ahead of time may be tidier
19:01:39 <ddarius> Arrows are related to kappa categories which formulate a notion of first order abstraction.
19:02:04 <shapr> I thought they were weak Freyd categories?
19:02:19 <ddarius> Kappa categories and Freyd categories are equivalent.
19:02:28 <shapr> oh, right.
19:02:53 <ddarius> shapr: Your quit message said something about knitting the other day.
19:03:01 <shapr> ddarius: Yup, I'm at SockSummit right now!
19:03:07 <shapr> Though trying to write Haskell...
19:03:38 <ddarius> I've never made a sock...
19:03:55 <shapr> Nor have I, but I bought some yarn for a moebius cowl yesterday.
19:04:07 <cdsmithus> I noticed someone just released a Haskell package for something about embroidery!  Is that related to knitting at all, or not really?
19:04:11 <shapr> One of my sidelines at the moment is trying to come up with a DSL for knitting.
19:04:17 <shapr> cdsmithus: wait what? Where?
19:04:24 <cmccann> cdsmithus, anyway, point is that the "tuple garbage" is actually fundamental to Arrow, so might as well get used to it :P
19:04:30 <cdsmithus> lambdabot announced it a second ago
19:04:38 <cdsmithus> Or, an hour more like...
19:04:38 <ddarius> I have the start of a Mbius scarf somewhere.
19:04:42 * shapr looks on hackage
19:04:43 <cmccann> http://hackage.haskell.org/package/embroidery-0.1
19:04:56 * cmccann uses scrollback power
19:05:01 <shapr> ddarius: were you knitting in the round? or knit a strip and then half-twist it?
19:05:17 <ddarius> shapr: It was crochet in the round.
19:05:22 <shapr> ah, I see.
19:06:36 <ddarius> shapr: There are quite a few knitting notations, the basics seem fairly standard.
19:06:52 <ddarius> Fairly recently there were some programs that can render presumably from such a notation.
19:07:11 <shapr> It does seem easy to go from a knitting chart to text instructions.
19:08:27 <cdsmithus> cmccann: Well, my current exercise is helping to give me a feel for how to use arrows.  But it's still ugly.
19:08:56 <shapr> Today's basic Haskell question.. why can't I load an .hs module that imports Test.QuickCheck when I'm certain QuickCheck is correctly installed?
19:10:05 <shapr> Just to be sure, I deleted ~/.ghc and did cabal update && cabal install quickcheck
19:10:08 <cdsmithus> shapr: Is it hidden?  try ghc-pkg expose QuickCheck
19:10:11 <ddarius> The Fleece-to-Foot challenge looks interesting.
19:10:37 <shapr> cdsmithus: doesn't make a difference
19:10:46 <shapr> oh, I see the problem :-(
19:11:15 <shapr> I have ghci 7.0 something installed, but I'm using ghc-pkg 6.12.3
19:11:23 <shapr> When will ubuntu get ghc 7? :-/
19:11:50 <cdsmithus> Oh... in October, I think.
19:12:17 <cmccann> cdsmithus, that is why the proc notation exists, after all
19:12:27 <cmccann> because of how horrendous the tuple wrangling is otherwise
19:14:21 <cdsmithus> That's one thing about Ubuntu, any question starting "When will Ubuntu..." has either April or October as an answer!
19:14:51 <cmccann> cdsmithus, of some unspecified year, I assume? ;]
19:15:16 <cdsmithus> Well, in this case, I'm pretty sure it's this October
19:15:56 <shapr> yay, ghci is happy now!
19:16:54 <cdsmithus> Yes, I double checked.  GHC 7.0.3 was accepted for Ubuntu 11.10 in June, so it'll be there
19:16:55 <shapr> I used to think Debian got new packages on a slow schedule... now I have Ubuntu :-|
19:18:05 <cdsmithus> The Haskell Platform installation goes pretty smoothly though... I'm had GHC 7 since February or March.  Just make sure /usr/local/bin is first in your path
19:22:11 * hackagebot husk-scheme 3.2 - R5RS Scheme interpreter program and library.  http://hackage.haskell.org/package/husk-scheme-3.2 (JustinEthier)
19:35:16 <dibblego> is there a better description that the word "stronger" in the statement, "monad is a stronger interface than functor"?
19:35:20 <dibblego> s/that/than
19:36:01 <cdsmithus> Hmm... more specific?
19:36:05 <shapr> I like that.
19:36:08 <cmccann> depends on what you mean by "stronger" there
19:36:28 <dibblego> I suppose, stronger, has more derived operations, less implementations
19:37:16 <cdsmithus> Yeah, I'd go with "more specific"
19:37:22 <dibblego> ok cheers
19:38:13 <cmccann> dibblego, "more specialized" might also work
19:38:17 <cmccann> or variations on such
19:39:01 <cmccann> to express that it's not just a limited subset of Functor, but rather a subset that supports particular extra operations
20:03:10 <shapr> yay, my Haskell code actually compiles!
20:03:14 <shapr> it's been too long :-(
20:03:36 <cmccann> compiler errors build character.
20:03:37 <shapr> I totally forgot that QuickCheck uses shrink instead of coarbitrary these days.
20:03:48 <shapr> cmccann: c'mon, you get paid to write scala, amirite?
20:04:02 <shapr> Aren't you working for clarifi or something?
20:04:02 <cmccann> no. perhaps you're thinking of someone else?
20:04:04 <shapr> oh, nm
20:04:09 * shapr fails totally
20:04:29 <shachaf> cmccann: Do you get paid to write Haskell?
20:04:40 <cmccann> no, I write web apps in C# at my day job.
20:04:44 <cmccann> it's as exciting as it sounds.
20:04:47 <shapr> Oh, I've done that before!
20:04:57 <cmccann> C# is, at least, remarkably tolerable for a mainstream technology.
20:05:34 <shachaf> Why don't you write Haskell instead? :-)
20:06:17 <cmccann> actually, I wrote a couple one-off Haskell scripts that are floating around in use at work.
20:06:17 <dolio> Yeah, no one will notice.
20:06:30 <cmccann> simple things that would have been much less convenient to do in C# that someone needed quickly.
20:06:34 <bss03> So, anyone think of a reason that the arrow transformer library doesn't have ArrowIO or IOArrow = Kleisli IO?
20:07:56 <bss03> Seems like you should be able to thread the IO through just like you can thread State through...
20:08:14 <cmccann> very simple I/O and data munging is much more straightforward in Haskell than in C#, I think
20:09:04 <bss03> I'm doing something simplar at work.  We use PowerBuilder 11.2, which I am starting to really lothe as a language.
20:09:28 <bss03> At the beginning of the week I needed to so some screen scrapping, so I learned HXT and wrote the script in that.
20:10:17 <ddarius> Screen scraping would be far more interesting if one actually used what was on the screen as the input.
20:10:44 <bss03> Luckily, I didn't have to do that. :P
20:11:46 <cmccann> ddarius, especially if by "screen" you mean the physical display, using a webcam or something pointed at it
20:11:51 <cmccann> that would be especially interesting
20:33:21 * hackagebot pandoc 1.8.2 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.8.2 (JohnMacFarlane)
20:36:08 <handonson> is it possible to write a function that takes a parser and returns a list of characters that the parser is expecting? for example, f digit == "0123456789"
20:40:10 <copumpkin> not really, since it isn't guaranteed to only want one character
20:40:14 <copumpkin> you could enumerate all strings
20:40:26 <copumpkin> and test them :)
20:41:34 <kmc> that might be possible in some parser libraries
20:41:41 <kmc> it's probably not possible in the common ones
20:41:55 <copumpkin> if the parser only supports an applicative interface
20:42:00 <copumpkin> then it's possible to do more efficiently
20:42:23 <copumpkin> actually even if it supports more, as long as it does something special for applicative vs. monad, it should be possible if you don't actually use the monad instance
20:43:43 * cmccann wonders how to test what is expected by a parser that accepts anything satisfying the predicate "p x = not $ p x"
20:44:09 <ezyang> "nothing"
20:46:13 <cmccann> copumpkin, hey, feel like weighing in on the moderation discussion on /r/haskell? :P
20:46:28 <copumpkin> sure, sorry, haven't had much time to check it yet
20:46:37 <cmccann> copumpkin, no worries
20:46:55 <cmccann> mostly just that I've done a lot of pontificating without any idea about what other people think is reasonable
20:47:35 <copumpkin> the moderation one or the moderators one?
20:47:40 <cmccann> and I'd rather know if I'm the odd one out here so that I can not bother arguing for something that's not gonna happen :P
20:47:43 <copumpkin> oh I see
20:47:45 <cmccann> the moderation one
20:47:50 <handonson> copumpkin: how with applicative interface?
20:47:59 <cmccann> the "new moderators" one doesn't have much going on in the comments
20:48:41 <copumpkin> handonson: applicative parsers (with certain primitives) more or less correspond to context-free languages, so you can enumerate all strings in them
20:49:13 <handonson> yes that's what i guessed
20:49:14 <handonson> and how?
20:49:42 * cmccann notes that a monad-based interface allows the result of a parser to choose the next parser, which is why things get more awkward
20:49:43 <copumpkin> it can be tricky :) you'd probably want your parser to construct an intermediate representation of the language
20:49:58 <copumpkin> then you'd either "interpret" that representation to a parser
20:50:00 <copumpkin> or to a generator
20:50:11 <copumpkin> a crucial part of that would be some fair infinite enumerator
20:50:18 <copumpkin> like logict or control-monad-omega
20:51:20 <handonson> i see, thanks
20:52:04 <cmccann> hm, turning a parser into a language representation sounds almost like some sort of inverse zipper, trying to turn implicit control flow into a concrete data structure
20:52:24 <cmccann> not really the same thing though
20:53:26 <handonson> i asked because i found out that my code may gain a free performance boost by replacing some manyTills with takeWhiles (I'm working with attoparsec)
20:56:02 <handonson> as manyTill takes parsers while takeWhile takes Word8 -> Bool functions, I thought the additional work should be minimized if it were possible to write such function
20:59:22 <bj0> i grabbed a powerset implementation from the mailing list that doesn't use up all my memory, but when I try to use a minimumBy on it, the memory gets all used up anyway
20:59:25 <bj0> http://pastebin.com/csGy5Z33
20:59:28 <mauke> The paste csGy5Z33 has been copied to http://hpaste.org/49698
21:11:43 <bss03> So, I might need to write a Haskel GUI that works well on windows.
21:12:05 <bss03> I figured I might delve into some FRP.
21:13:17 <bss03> I'm thinking of using Phooey.  It seems to be the most well-maintained FRP on top of WxWidgets, which will actually use native widgets instead of GTK/Qt.
21:13:28 <bss03> Any opinions?
21:13:38 * cmccann issues bss03 a machete, three weeks' worth dried food rations, and a map marked only with "Here there be dragons"
21:14:15 <bss03> Crap.  I sense YASD coming up.  I've yet to ascend. :(
21:15:20 <bss03> Using Win32/GDI directly seems like madness... should maybe I just use the WxWidgets binding directly?
21:15:45 <cmccann> bss03, I'm not sure if there really is a pre-existing good solution.
21:16:41 <cmccann> as far as I know most FRP stuff is still a matter of "active research" at best, and a lot of GUI libraries are kinda painful in various ways
21:17:06 <cmccann> you should probably start with the assumption that you'll need to dig down to whatever the underlying library is at some point anyway
21:17:17 <handonson> Haskell deserves a good GUI library of its own that is cross-platform and not dependent on an external non-Haskell library... but there isn't, yet
21:17:57 <lucca> part of the problem is you can't do that on macos, for example.
21:18:19 <cmccann> bss03, so it's a matter of do you want to start with something higher-level and possibly have to hack on it and mess whatever it uses under the hood, or start with a low-level binding and build your own
21:18:34 <cmccann> you can obviously take inspiration from existing stuff instead of reinventing everything
21:18:44 <bss03> Well, at some point you have to bind to the X Monad (resitrcted), or the IO Monad to commuicate with the OS.
21:18:47 <handonson> absolutely true, we don't have anything close to macos nativeness
21:19:09 <bss03> So, I don't know that you'd really get much out of having something hakell-native vs. FRP built on something like WxWidgets.
21:19:11 <handonson> Win32 is minimal and solid, but coding with shall involve A LOT of trial and error
21:19:32 <handonson> as... almost no good Haskeller cares about it
21:19:51 <handonson> gtk on hackage is probably the most mature and well-tested for now
21:19:57 <cmccann> bss03, the problem with wxwidgets is that its design meshes very, very poorly with Haskell
21:20:52 <bss03> I've heard the same thing about Qt.
21:20:52 <cmccann> that said, I've gotten decent results from using it directly, even if not trying to build FRP stuff on top of it, so it's certainly usable
21:21:32 <cmccann> the thign with wx is that it actually uses OO-style design meaningfully and is extremely imperative
21:21:35 <bss03> Phooey doesn't look like it has successfully compiled since 2007. :(
21:22:20 <cmccann> so there's hoop-jumping to deal with the OO-ish API, and lots of mutable references and IO () callback functions and meh.
21:23:22 <cmccann> to build something sanely Haskell-idiomatic on top of wx pretty much requires abstracting over the whole thing completely and starting fresh
21:23:41 <cmccann> with whatever terrifying translation layer you have to implement making the bridge
21:24:05 <bss03> Well, I come from C/C++ and Qt as a GUI, so I don't think dealing with the IO will be a problem, but...
21:24:55 <bss03> I succesfully learned Arrows and HXT recently and FRP looked like a nice set of combinators for building GUIs sort of the way HXT has great combinators for dealing with XML.
21:24:56 <cmccann> bss03, it's not that it's a problem to use, it's that it works at cross-purposes with anything like FRP or just a sensible, functional-idiomatic design
21:25:26 <cmccann> bss03, if you want to use Haskell as an imperative language, which it's not half bad at being, then wx is just fine
21:25:56 <handonson> the more painful truth is that wxhaskell is actually one of nicer graphics alternatives for haskellers
21:26:04 <bss03> Okay, I get you there.
21:26:12 <handonson> for example, Graphics.Rendering.OpenGL doesn't even look like Haskell anymore
21:26:13 <cmccann> handonson, yes, like I said I've gotten good results from it
21:26:37 <cmccann> yes, GL has the same sort of issues as wx but the GL bindings barely try to hide it
21:26:43 <bss03> I can just restrict the functional nature from things that are isolated from the GUI.
21:26:54 <cmccann> wx at least has a pretty decent set of imperative-style Haskell bindings
21:27:44 <bss03> I certainly don't want to even attempt writing and FRP adapter for wx!  With Phooey not being available, I might try wxFruit, but it doesn't seem to be well maintainer.
21:27:58 <bss03> *maintained
21:28:29 <cmccann> bss03, one option would be to go multithreaded, with a very stripped-down main UI thread that communicates via whatever concurrency abstractions with a more functional-style backend
21:28:54 <bss03> This is actually going to be a really simple GUI, at least for now.
21:29:30 <bss03> Basically, I just need to get username / password / ODBC Connection name so I can connect and dump data parsed from the XML into a database.
21:29:52 <cmccann> if it's a pretty simple UI and you want to get something working reasonably soon, what I'd probably do is just use wx and stick to the imperative style and be done with it
21:30:07 <bss03> IMO, It doesn't really need a GUI, but I'm a UNIX head working in a Windows shop, so everyone around me seems obsessed with having a GUI for everything.
21:30:27 <cmccann> all the processing stuff can very easily be done in more functional-style code
21:30:59 <cmccann> ugh, I hate the fascination people have with GUIs for simple tools like that
21:31:06 <cmccann> it makes things way more complicated for no good reason
21:32:25 <bss03> Glad I got your input.  I'll do a first pass in wx directly.  Then, if I still want to play with FRP, I'll look at forking and re-writing in WxFruit or something like it.
21:33:01 <cmccann> bss03, glad to help :]
21:33:31 <cmccann> as far as FRP goes just remember there's not really any canonical implementations or anything yet, so you're likely to be breaking new ground no matter what you do, if only in minor ways
21:35:59 <cmccann> also, remember that daggers are for throwing, watch out for the floating eyes, and be nice to the lighting shop owner
21:36:13 <cmccann> ;]
21:40:20 <OceanSpray> so I'm trying to follow SPJ's tutorial paper on implementing rank-n types
21:40:33 <OceanSpray> anybody here read that?
21:40:57 <dolio> Doesn't he have several?
21:41:49 <OceanSpray> Then I meant this one:
21:41:50 <OceanSpray> http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/putting.pdf
21:42:22 <OceanSpray> In it there's this notion of "rho-types"
21:42:34 <OceanSpray> which, in plain damas-milner are just monotypes
21:43:08 <OceanSpray> but, in a rank-n system, can be both monotypes AND "sigma -> sigma"
21:43:32 <OceanSpray> where a "sigma type" is a rank-n type where n > 0
21:43:42 <OceanSpray> so I'm just wondering
21:44:06 <OceanSpray> why did they define " rho ::= tau | sigma -> sigma' "
21:44:23 <OceanSpray> instead of just " rho ::= sigma "?
21:44:47 <sohum> :t id id id id id id id id id
21:44:47 <lambdabot> forall a. a -> a
21:44:53 <sohum> :}
21:45:12 <sohum> sorry, do continue
21:45:28 <OceanSpray> that's my question.
21:45:33 <OceanSpray> I feel like
21:45:41 <OceanSpray> I'm missing some crucial piece of knowledge
21:46:52 <OceanSpray> does defining " rho ::= sigma " imply impredicativity or something?
21:49:03 <hatds> what is tau?
21:49:21 <OceanSpray> a "tau-type" is a monotype
21:53:47 <hatds> I don't think I'll be able answer this question, although I wish I could :) have fun reading the paper
21:56:32 <OceanSpray> Does SPJ himself ever visit this channel?
21:56:47 <cmccann> don't think so
21:56:51 <cmccann> probably too busy writing papers
21:57:05 <cmccann> considering how prolific he is
21:58:48 <cmccann> OceanSpray, anyway, if I had to guess I'd say that maybe it's something involving the ability to float out quantifiers
21:59:30 <cmccann> there's a major difference between a higher-rank type as a function argument rather than as a standalone type or function result
21:59:59 <OceanSpray> right
22:01:28 <cmccann> I don't immediately see how that would make ρ ::= σ superfluous but maybe it does
22:03:41 <mexifries> hey guys
22:03:58 <mexifries> checking out tryhaskell.org
22:04:21 <cmccann> it's pretty neat
22:04:51 <mexifries> seems so! already know the easy stuff, php js mysql etc... trying to branch out
22:05:18 <cmccann> haskell is definitely branching away from those, agreed
22:05:51 <cmccann> that's quite a leap to make, heh
22:06:05 <mexifries> wanted a cool new scripting lang to accompany mongo/couch.. thinking py but.. then i read on slashdot haskell is highly sought after
22:07:06 <cmccann> well, I wouldn't take that sort of thing too seriously. it's certainly something that can make you stand out a bit, though.
22:08:02 <mexifries> hm! interesting. ok well i'm gonna mess with the tute a bit more. thanks for the chat cmccann!
22:08:10 <cmccann> haskell has a fairly steep learning curve, and its reputation tends to precede it a bit, I've heard plenty of people say they got more attention just by virtue of knowing it
22:08:10 <mexifries> see ya around maybe!
22:08:16 <cmccann> ok.
22:08:19 <cmccann> have fun!
22:08:19 <bss03> Haskell is better than Python. :P
22:08:24 <mexifries> noted
22:08:35 <mexifries> lol thanks bss i already like it.. sounds like a challenge
22:08:42 <cmccann> yes, definitely take the word of people in #haskell that haskell is the best language
22:08:43 <cmccann> ;]
22:08:44 <mexifries> exit
22:08:52 <mexifries> lol
22:08:52 <Rotaerk> bss03, the appropriate way to say that is "haskell > python".  the "better than" operator
22:08:59 <mexifries> how do i close this?
22:09:00 <kmc> > "haskell" > "python"
22:09:00 <lambdabot>   False
22:09:05 <bss03> :t haskell > python
22:09:05 <Rotaerk> :o
22:09:05 <lambdabot> Not in scope: `haskell'
22:09:05 <lambdabot> Not in scope: `python'
22:09:24 <bss03> /quit, I think.
22:09:57 <kmc> :t ?haskell > ?python
22:09:58 <lambdabot> forall a. (?haskell::a, ?python::a, Ord a) => Bool
22:10:35 <bss03> Dynamically scoped variables aren't part of Haskell2010. :P
22:12:49 <kmc> indeed they are not
22:13:23 <cwl> "aa bb uu ii oo" =~ "(uu|ii)" :: [String] error
22:13:43 <cwl> ghci complains No instance for (RegexContext Regex [Char] [String])
22:13:58 <kmc> hate the regex lib so much
22:14:10 <cwl> I'm using Text.Regex.Posix module
22:14:17 <kmc> that (=~) operator is so un-Haskelly
22:14:41 <cwl> kmc: why it is un-haskelly
22:15:12 <kmc> cwl, it's a bunch of totally different functions, disambiguated only by type
22:15:20 <cmccann> someone should get augustss to implement perl as a Haskell DSL, to go with his Python and BASIC implementations
22:15:45 <shachaf> He did a Python DSL?
22:15:47 <kmc> cwl, the more you overload things willy-nilly, the less the type checker can help you
22:16:17 <cmccann> shachaf, very loosely
22:16:27 <cmccann> mostly just python-inspired imperative style
22:16:35 <cmccann> it's the most recent post on his blog
22:16:39 <cwl> kmc: so what's the better way to implement the regex operator
22:16:42 <kmc> "count the number of matches" and "get the matches as an Array" are totally different functions
22:16:51 <kmc> they should have different names
22:17:07 <cwl> kmc: I agree
22:17:17 <cmccann> "do completely different things based on calling context" is a perl-ish thing to do, isn't it?
22:17:28 <kmc> yep
22:17:56 <cwl> so... could anyone help me with that problem
22:18:05 <cwl> (=~) :: [String]
22:18:16 <cmccann> it's amusing that perl as a dynamically-typed language supports overloading functions based on return type, which most statically typed languages don't do
22:18:17 <kmc> let's just write «class F t where f :: t»
22:18:20 <cwl> example from RWH, I cannot run it
22:18:23 <kmc> and every function can be named f
22:18:37 <kmc> and our programs will look like «f (f (f f) f) f»
22:18:42 <cmccann> kmc, kinda like oleg's "only one type class" thing :P
22:19:07 <cmccann> don't even need type classes for that, though
22:19:12 <cmccann> just define f as the iota combinator
22:19:28 <kmc> which is?
22:19:44 <bss03> cwl: You are using TExt.Regex.Psic?
22:19:47 <andares> hey, ghc question. can you define functions from inside ghci?
22:19:57 <cwl> bss03: Text.Regex.Posix
22:20:06 <kmc> andares, the ghci prompt functions much like an IO "do"-block
22:20:15 <kmc> so you can say "let f 0 = 1; f n = n * f (n-1)"
22:20:54 <andares> kmc: ah, so I need a let inside of ghci but not in a .hs file? (sorry, newbie but I'm trying)
22:21:00 <cmccann> kmc, I think it's ιf=fSK
22:21:06 <cmccann> where S and K are the usual combinators
22:21:09 <bss03> I don't see a RegexContext instance that ends in [String].
22:21:19 <kmc> andares, right.  syntactically, the ghci prompt is like an IO "do"-block
22:21:26 <kmc> you need "let" to define a function there, as well
22:21:33 <bss03> cwl: Try using ":: String" instead of ":: [String]"
22:21:37 <cmccann> the end result being that ι is a complete combinator basis on its own
22:21:50 <kmc> the base let syntax is "let <definitions> in <expression>", but you can leave off the second part inside "do"
22:22:02 <cwl> bss03: :: String is ok but not the result I want
22:22:12 <cwl> bss03: ::String returns the first match
22:22:19 <cwl> bss03: I want all matches
22:22:20 <kmc> :t \f -> f ap const
22:22:20 <lambdabot> forall (m :: * -> *) a b a1 b1 t. (Monad m) => ((m (a -> b) -> m a -> m b) -> (a1 -> b1 -> a1) -> t) -> t
22:22:21 <andares> kmc: what is an IO "do" block? can you provide a link?
22:22:33 <kmc> http://www.haskell.org/haskellwiki/Introduction_to_IO
22:22:38 <andares> thanks.
22:22:39 <kmc> you will get there in any tutorial
22:22:43 <cmccann> wow, that's a really nice type
22:23:03 <bss03> cwl: I think (=~) can only return one match... maybe that has changed since RWH was written?
22:23:20 <hatds> andares: It's not really asymmetric.  Every declaration in a .hs file in inside a where or let block.  The top scope of a module is inside the 'where' from the "module Main where" on the first line
22:23:38 <cmccann> > :t let iota f = f ap const in iota iota
22:23:39 <lambdabot>   <no location info>: parse error on input `:'
22:23:44 <cmccann> :t let iota f = f ap const in iota iota
22:23:45 <lambdabot>     Occurs check: cannot construct the infinite type: a = b1 -> a -> b
22:23:45 <lambdabot>       Expected type: ((b1 -> a -> b) -> (b1 -> a) -> b1 -> b)
22:23:45 <lambdabot>                      -> ((b1 -> a -> b) -> b1 -> a)
22:23:48 <cmccann> pf
22:24:10 <cwl> bss03: (=~) has many return types
22:24:21 <kmc> but the module 'where' allows things not allowed in other 'where's
22:24:27 <kmc> and its layout rules are different
22:24:30 <cwl>  ::Int, ::String, ::(String,String,String)
22:24:37 <cwl> @t (=~)
22:24:37 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
22:24:45 <cwl> @type (=~)
22:24:46 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
22:24:54 * kmc pukes
22:25:12 <andares> hatds: so the "module Main where" is implicit?
22:25:17 <kmc> forall arg result. (IsFunction arg result) => arg -> result
22:25:21 <hatds> optionally
22:25:24 <kmc> andares, in Main, yes
22:25:32 <kmc> if you're writing a module to be imported, you need it
22:25:47 <andares> kmc: and the :l command to ghci loads whatever .hs file as "Main?"
22:25:53 <bss03> cwl: Hrm, you may just be missing an visible instance.
22:25:58 <kmc> think so
22:26:06 <bss03> cwl: Can you try importing Text.Regex.Base.RexexLike ?
22:27:02 <kmc> it's like someone started with the design constraint "all regex operations should be done with (=~) because that's how Perl works"
22:27:06 <cwl> bss03: let me c
22:28:53 <cwl> bss03: not in scope (=~)
22:29:41 <kmc> i think "emulate Perl at all costs" is a poor design requirement and really a poor life choice in general
22:30:11 <bss03> cwl: Are you doing this from GHCi?
22:30:52 <cwl> bss03: yes
22:31:12 <cwl> bss03: The Glorious Glasgow Haskell Compilation System, version 6.12.1
22:31:39 <cwl> on ubuntu 10.04
22:32:30 <bss03> Did you just use ":m stuff" to load another module?  That makes the previous module(s) go out of scope (or become qualified or something).
22:32:50 <bss03> Use ":m + stuff and more stuff" to have multiple modules active at once.
22:34:04 <cwl> bss03: I tried 2 ways, if I load 2 modules, the original problem comes
22:34:12 <cwl> no instance ...
22:35:56 <andares> hey, I tried to define the Fibonacci sequence recursively as a test, and it took a long time. does ghc/Haskell in general optimize recursive functions?
22:36:16 <kmc> you probably wrote the exponentially-slow version
22:36:24 <cwl> "aa bb cc dd" =~ "(aa|dd)" :: [[String]]
22:36:24 <kmc> fib n = fib (n-1) + fib (n-2) -- ?
22:36:34 <applicative> andares, there is a ton of optimization, but it is easy to avoid miss them :)
22:36:35 <andares> kmc: yep. I thought Haskell would auto-cache or something.
22:36:35 <cwl> [["aa","aa"],["dd","dd"]]
22:36:43 <kmc> andares, no, that's not done automatically
22:36:46 <cwl> strange result
22:36:58 <cwl> whay appear twice?
22:36:59 <kmc> but see http://hackage.haskell.org/package/data-memocombinators and http://hackage.haskell.org/package/MemoTrie
22:37:14 <andares> kmc: hm. is there a concise way to describe it so that it doesn't do it exponentially slow, without those?
22:37:15 <kmc> it's not automatic because it's a space/time tradeoff that the compiler can't decide for you
22:37:27 <kmc> > fix ((0:) . scanl (+) 1)
22:37:28 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
22:37:49 <kmc> andares, build an infinite list of fibonacci numbers
22:37:49 <bss03> cwl: *shrug* I think it might have something to do with caputring groups.
22:37:55 <kmc> the list is data and sticks around
22:38:04 <kmc> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
22:38:04 <applicative> andares, you need to arrange that fib (n -1) and fib (n -2) arent calculated independently then it will fast as lightning
22:38:04 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
22:38:16 <andares> him, I don't seem to have fix.
22:38:22 <applicative> kmc's way is a bit fancy ^^^
22:38:23 <kmc> Data.Function
22:38:25 <bss03> cwl: First element = whole match, second element = 1st parenthesized expression, etc.
22:38:27 <applicative> import Data.Function
22:38:40 <kmc> but it's probably best to use explicit recursion with "let", instead of the 'fix' combinator
22:38:43 <kmc> at least as a beginner
22:38:47 <applicative> yes!
22:38:58 <kmc> my first code was a bit of "golf", i.e. writing the shortest possible version for fun
22:39:00 <cwl> bss03: but "aa bb cc dd" =~ "(aa|dd|c)" :: [[String]]
22:39:05 <kmc> different from what's actually most readable
22:39:12 <andares> hehe, that's okay.
22:39:15 <cwl> bss03: the result repeat twice not 3 times
22:39:17 <andares> is there a built-in help?
22:39:18 <applicative> also the plan of making the list of fibs rather than fib n might help get a rational definition
22:39:24 <applicative> :?
22:39:24 <kmc> "fibs = 0 : 1 : zipWith (+) fibs (tail fibs)" should be understandable
22:39:32 <kmc> if mind-bending
22:39:52 <bss03> cwl: 2 times is right.
22:40:01 <andares> I mean, something that provides documentation on functions.
22:40:06 <andares> kind of like Python's help thing.
22:40:13 <kmc> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/index.html
22:40:20 <bss03> cwl: Frist = whole expression, Second = 1st open-paren, Second = nothing, since you only have 1 open paren.
22:40:23 <andares> nothing baked into ghc though? okay.
22:40:28 <kmc> > let xs@(_:ys) = 0 : 1 : zipWith (+) xs ys in xs
22:40:29 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
22:40:38 <kmc> andares, not as such.  ghci's ":i" will give you a litlle info
22:40:39 <applicative> andares, or maybe start with fibStep (n,m) = (m, n+m) you cant go wrong with that
22:41:51 <kmc> > iterate (\(n,m) -> (m, n+m)) (0,1)
22:41:51 <lambdabot>   [(0,1),(1,1),(1,2),(2,3),(3,5),(5,8),(8,13),(13,21),(21,34),(34,55),(55,89)...
22:41:55 <kmc> cool
22:41:57 <cwl> bss03: i'll try other situations
22:42:02 <kmc> > map fst . iterate (\(n,m) -> (m, n+m)) (0,1)
22:42:03 <lambdabot>   Couldn't match expected type `[(a, b)]'
22:42:03 <lambdabot>         against inferred type `(a1,...
22:42:08 <kmc> > map fst $ iterate (\(n,m) -> (m, n+m)) (0,1)
22:42:09 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
22:42:13 <kmc> @pl \(n,m) -> (m, n+m)
22:42:13 <lambdabot> uncurry (ap (,) . (+))
22:42:21 <kmc> nice party tricks
22:42:33 <kmc> :t ap (,)
22:42:34 <cwl> bss03: you are right
22:42:34 <lambdabot> forall a a1. (a -> a1) -> a -> (a, a1)
22:42:43 <bss03> > "abc" =~ "a" :: http://en.wikipedia.org/wiki/Special:Search?go=Go&search=String
22:42:44 <lambdabot>   <no location info>:
22:42:44 <lambdabot>      Illegal symbol '.' in type
22:42:44 <lambdabot>      Perhaps you intend...
22:42:51 <bss03> > "abc" =~ "a" :: [\[String]]
22:42:52 <lambdabot>   <no location info>: parse error on input `\'
22:42:54 <cwl> for (aa|bb|(cc|dd)) three elements
22:43:10 <bss03> > "abc" =~ "a" :: [ [String] ]
22:43:11 <lambdabot>   [["a"]]
22:43:18 <bss03> > "abc" =~ "a|b" :: [ [String] ]
22:43:19 <lambdabot>   [["a"],["b"]]
22:45:59 <bss03> Anyone got a good implementation of the "s" operator in sed implemented in Haskell?
22:46:01 <applicative> andares, by the way, the ghci doesn't do too much optimization anyway, for best results do ghc --make -O2 Fib.hs or the like.
22:46:41 * kmc wonders where the "Haskell memoizes everything" myth comes from
22:47:15 <bss03> kmc Probably because its actually pretty safe in Haskell, referential transparency and all that.
22:47:35 <hpaste> applicative pasted “print fib” at http://hpaste.org/49700
22:47:56 <cwl> bss03: the last question is, why it's different from the RWH, where can i find the documentation
22:48:09 <applicative> andares: here's a clutzy version of kmc's zippy version ^^^
22:48:22 <kmc> bss03, yeah, I think it's a combination of careless descriptions of the benefits of laziness and careless reading of same
22:48:26 <kmc> er, of purity i mean
22:48:33 <bss03> cwl: I use hackage for reading the documentation of packages I don't have installed.
22:48:40 <andares> that zipWith is pretty crazy.
22:48:41 <kmc> laziness actually *is* memoization, in a specific limited sense
22:48:48 <andares> I'm trying to figure it out from the type signature.
22:48:49 <kmc> that's how data-memocombinators and MemoTrie manage
22:48:59 <kmc> without having explicit mutable state
22:49:02 <kmc> andares, zipWith itself?
22:49:03 <applicative> @type zipWith
22:49:04 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
22:49:14 <andares> what's the forall?
22:49:16 <kmc> 'zipWith' generalizes 'map'; you could call it map2
22:49:21 <kmc> andares, don't worry about forall for now
22:49:25 <kmc> it's a GHC extension
22:49:25 <bss03> cwl: I just point my browser at /usr/share/doc/ghc6-doc/html/libraries/index.html for stuff I have installed.
22:49:30 <andares> hm, okay.
22:49:34 <kmc> in standard Haskell you would just write "(a -> b -> c) -> [a] -> [b] -> [c]"
22:49:35 <mauke> andares: you can ignore everything before '.'
22:49:50 <kmc> certain types can be written with explicit forall that can't be written in standard Haskell
22:49:53 <kmc> but this is not oneof them
22:50:01 <applicative> > zipWith take [1,2,3] (repeat 'a')
22:50:02 <lambdabot>   Couldn't match expected type `[a]'
22:50:02 <lambdabot>         against inferred type `GHC.Types...
22:50:12 <applicative> that was stupid
22:50:20 <andares> so it takes in a function of type (a -> b -> c), and returns a function which given two arrays returns a third?
22:50:20 <kmc> zipWith takes a "two-argument function" and applies it to elements drawn by traversing two lists at once
22:50:24 <kmc> lists not arrays
22:50:27 <kmc> and yeah
22:50:27 <applicative> > zipWith take [1,2,3] (repeat "aaaaaa")
22:50:28 <lambdabot>   ["a","aa","aaa"]
22:50:38 <bss03> Rank-N types, in particular, like the relatively useless [forall a. a]
22:50:39 <mauke> applicative: that's just 'map'
22:50:40 <kmc> or you can say it takes a function and two lists, and returns a list
22:50:50 <applicative> mauke yes
22:51:09 <kmc> bss03, that one requires ImpredicativeTypes too
22:51:21 <coppro> zipWith + [1..3] [4..6]
22:51:21 <mauke> > zipWith f [a,b,c] [1,2,3]  :: [Expr]
22:51:22 <lambdabot>   [f a 1,f b 2,f c 3]
22:51:28 <coppro> ? zipWith + [1..3] [4..6]
22:51:34 <coppro> I give up
22:51:36 <bss03> kmc: Kk, I avoid higher rank types, so far.
22:51:44 <applicative> andares: there are exactly similar function for arrays of various types.  Lists are the ABC container type around here...
22:51:46 <mauke> > zipWith (+) [1..3] [4..6]  :: [Expr]
22:51:47 <lambdabot>   [1 + 4,2 + 5,3 + 6]
22:51:56 <kmc> bss03, actually [forall a. a] isn't a higher-rank type, afaik
22:52:03 <kmc> but it's not a H98 type either
22:52:27 <applicative> its higher rank if its in the antecendent of a -> , no?
22:52:32 <kmc> yeah
22:52:54 <coppro> What's Expr?
22:52:55 <kmc> a rank-n type has a rank-(n-1) type as the left-hand arg to the (->) type constructor
22:53:05 <andares> applicative: ABC container type?
22:53:09 <kmc> coppro, http://hackage.haskell.org/package/simple-reflect
22:53:26 <applicative> > let foo :: (forall a . a) -> String; foo x = "Hi" in foo _
22:53:27 <lambdabot>   Pattern syntax in expression context: _
22:53:27 <andares> does the :: [Expr] make it return it as an expression type, so it won't directly evaluate?
22:53:47 <mauke> andares: effectively, yes
22:53:52 <kmc> andares, it's a small hack to approximate that
22:53:55 <mauke> in reality it's cheating
22:53:59 * applicative apologizes for not visiting lambabot privately
22:54:05 <applicative> > let foo :: (forall a . a) -> String; foo x = "Hi" in foo undefined
22:54:05 <lambdabot>   "Hi"
22:54:29 <coppro> :t f
22:54:30 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
22:54:52 <applicative> :t x
22:54:53 <lambdabot> Expr
22:55:07 <andares> ah, cool.
22:55:09 <applicative> lambdabot is wonderful, but it kind of a perversion
22:55:51 <andares> so when you see a type signature, do you think of it in terms of [everything before ->] -> [return value] or in terms of currying?
22:55:58 <andares> it seems to take a long time to think of it as currying.
22:56:19 <mauke> both
22:56:28 <bss03> andares: It's still a mixture for me.
22:56:31 <mauke> it's fluid
22:56:54 <applicative> andares, there are zipWith-like functions for all sorts of things, e.g. http://hackage.haskell.org/packages/archive/vector/0.7.1/doc/html/Data-Vector.html#g:23
22:57:36 <andares> cool.
22:57:42 <andares> oh, also what do I need to import for Expr to work?
22:58:00 <mauke> andares: http://hackage.haskell.org/package/simple-reflect
22:58:34 <applicative> andares and e.g. http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Sequence.html#g:15
22:59:36 <kmc> andares, i think of it in whichever form fits what i'm doing
22:59:58 <applicative> andares, the same type signature, e.g.  map :: (a -> b) -> [a] -> [b] can be looked at both ways, somehow each gives a different picture.
23:00:10 <andares> hm, okay.
23:00:19 <kmc> map :: (a -> b) -> ([a] -> [b])  -- this is a nice view
23:01:11 <applicative> viewing it as taking a function and a list is more straightforward, but viewing it as 'lifting' an a->b function so it acts on lists, is a bit more exalted (ie as kmc brackets it)
23:01:12 <kmc> why even talk about data values? just talk about functions and functions for transforming functions
23:01:19 <Mathnerd314> @type fmap `asTypeOf` map
23:01:20 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
23:01:30 <andares> kmc: sorry, still new to this. :p
23:01:46 <kmc> maybe this view is not the more useful one
23:01:53 <kmc> but it's the one that connects in with a lot of deep theory
23:02:00 <kmc> the theory is kinda optional, though
23:02:00 <andares> wait, where is forall defined? more importantly, how do I find where thnigs are defined in general?
23:02:03 <Mathnerd314> hmm, I wonder if you can get an arrow from a functor
23:02:04 <kmc> *shrug*
23:02:06 <hpaste> sutabi pasted “I just want to reverse this string” at http://hpaste.org/49701
23:02:10 <mauke> :t [map, fmap, liftA, liftM, (.)]
23:02:10 <kmc> andares, forall is syntax
23:02:11 <lambdabot> forall a b. [(a -> b) -> [a] -> [b]]
23:02:21 <kmc> it's a GHC extension to the Haskell language
23:02:22 <applicative> andares: our friends are forever talking over each others heads, don't worry about it; focussed questions always get sound answers
23:02:25 <kmc> you can read about it in the GHC manual
23:02:48 <mauke> sutabi: what's the type of T.decodeUtf8?
23:03:26 <sutabi> mauke, Data.Text.Internal.Text
23:03:33 <kmc> andares, the way polymorphism works in standard Haskell, you just use type variables and they're implicitly allowed to take on any type
23:03:39 <mauke> sutabi: impossible
23:03:41 <kmc> but GHC lets you explicitly introduce type variables
23:04:02 <kmc> explicitly-introduced type variables are used for three or four distinct GHC extensions
23:04:03 <sutabi> mauke, is there a way I can convert it or something?
23:04:10 <mauke> sutabi: convert what to what?
23:04:13 <andares> kmc: so explicit type variables aren't a non-GHC thing? then how do you implement monads outside of ghc?
23:04:16 <applicative> andares, the appearance of forall in all kinds of type signatures is fairly recent,
23:04:17 <sutabi> mauke, a String?
23:04:19 <applicative> @type map
23:04:20 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
23:04:24 <kmc> andares, what? where did monads come in?
23:04:28 <sutabi> ermm convert Data.Text.Internal.Text to String
23:04:29 <mauke> sutabi: what?
23:04:35 <mauke> sutabi: what's the type of T.decodeUtf8?
23:05:09 <andares> kmc: to implement a type constructor you have to define the type variables explicitly, right?
23:05:17 <kmc> you don't "implement monads" at all -- "Monad" is the name of an interface only
23:05:26 <mauke> I totally implement interfaces
23:05:29 <applicative> this would just have been (a -> b) -> [a] -> [b] , which means the same, the forall is necessary for fancier types, but in order to have them we have to have ghci giving these fancy signatures for elementary things.  (I think thats more or less right.)
23:05:48 <kmc> andares, ah, you're right that type variables are introduced in e.g. "data Foo a b = ..."
23:05:52 <sutabi> mauke, decodeUtf8 :: ByteString -> Text
23:05:59 <kmc> that's a different mechanism, though
23:06:02 <andares> kmc: yeah, sorry. I read ahead a little.
23:06:04 <andares> okay.
23:06:13 <kmc> "forall" is for explicitly introducing type variables inside a type signature
23:06:23 <kmc> anyway, don't worry too much about it
23:06:26 <mauke> sutabi: ok, then why are you trying to reverse the input to that function?
23:06:27 * applicative is totally implementing an interface
23:06:39 <kmc> also don't focus on monads as *the* example of polymorphic types
23:07:36 <kmc> we see a lot of people who are having trouble with higher-order functions, polymorphism, or type classes, but express it as "can't understand monads"
23:07:40 <sutabi> mauke, no reason in general just trying to learn haskell. It is a bytestring which has reverse itself, but that doesn't even work for me
23:07:57 <mauke> sutabi: what do you mean by "has reverse itself"?
23:08:04 <kmc> because Monad is a type class with polymorphic higher-order functions
23:08:09 <kmc> and an over-hyped one at that
23:08:31 <applicative> @type return
23:08:32 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
23:08:44 <kmc> easy to attribute difficulty to the wrong concept when you're learning so many at once
23:09:10 <sutabi> mauke, Data.ByteString has: reverse :: ByteString -> ByteString
23:09:12 <applicative> ^^^ all the stuff before the . is fancy post Haskell98 nonsense.  (Very desirable though)
23:09:15 <andares> kmc: well actually I just heard about monads, and so I read a Haskell tutorial on monads, and now I'm going back and trying to learn Haskell. =/
23:09:20 <NihilistDandy> @hoogle permutations
23:09:20 <lambdabot> Data.List permutations :: [a] -> [[a]]
23:09:22 <mauke> sutabi: yes
23:09:30 <kmc> andares, "monad tutorials" are notorious
23:09:32 <NihilistDandy> @src permutations
23:09:32 <lambdabot> Source not found. The more you drive -- the dumber you get.
23:09:32 <kmc> @where burrito
23:09:32 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
23:09:41 <NihilistDandy> @src Data.List.permutations
23:09:41 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
23:09:44 <sutabi> so when I try (reverse message) it just gives a type error... uhh unless I have to import the reverse?
23:09:59 <mauke> sutabi: no, why are you trying to reverse a bytestring?
23:10:12 <mauke> sutabi: why? why? why? why? why? WHY? WHY? WHY? WHY?
23:10:13 <applicative> andares, forget about monads for the moment, there are several abstractions that precede it, it's wonderful and strong but shouldnt be over emphasized.
23:10:31 <applicative> andares, the really deep bridge that needs to be crossed is
23:10:33 <applicative> @type fmap
23:10:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:10:47 <applicative> @type map
23:10:47 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
23:10:50 <sutabi> mauke, to make a word like "hello" turn into "olleh"
23:10:56 <kmc> "Monad" is just the name of a simple generic API implemented by lots of different types in different ways
23:11:01 <mauke> sutabi: bytestrings aren't text (or words)
23:11:13 <andares> applicative: ah, okay. how should I go about learning then?
23:11:16 <applicative> > fmap (+1) [0..10]
23:11:17 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11]
23:11:21 <mauke> sutabi: I don't think what you're trying to do makes sense
23:11:26 <applicative> > fmap (+1) (Just 2)
23:11:27 <lambdabot>   Just 3
23:11:40 <kmc> andares, just learn Haskell, don't get hung up on the feature with the weird name
23:11:59 <kmc> when you reach the point of learning about Functor / Applicative / Monad in more detail, read Typeclassopedia
23:12:03 <coppro> is learnyouahaskell still considered a good learning source?
23:12:08 <applicative> andares have you seen "Learn you a Haskell" ?  It follows what I think most people think is the right learning order.
23:12:09 <kmc> but there's a lot of prerequisites
23:12:24 <shachaf> kmc: When's "Haskell From First Principles" coming out?
23:12:32 <kmc> shachaf, 20XX
23:12:44 <sutabi> mauke, i am using "snap" web framework. When I get input from decodedParam its a bytestring. I want to alter the byte string an some way. So I wanted to test reverse on it.
23:12:54 <applicative> @where LYAH
23:12:54 <lambdabot> http://www.learnyouahaskell.com/
23:12:56 <mauke> sutabi: don't alter the bytestring
23:13:04 <kmc> Monad is a type class with polymorphic higher-order functions, so you should understand polymorphism, type classes, and higher-order functions before you get to monads
23:13:12 <andares> lambdabot: it seemed a little slow tgouh.
23:13:32 <kmc> andares, by the way, "not understanding monads" is no reason not to do IO.  the fact that IO is a monad is mostly incidental to how it's used
23:13:33 <andares> although entertaining!
23:13:33 <NihilistDandy> andares: lambdabot is a robot :/
23:13:45 <kmc> see http://www.haskell.org/haskellwiki/Introduction_to_IO
23:13:49 <kmc> NihilistDandy, we're all robots
23:14:09 <applicative> > fmap (+1) ("Hello",3)
23:14:09 <NihilistDandy> beep blorp
23:14:09 <lambdabot>   ("Hello",4)
23:14:25 <sutabi> mauke, what would I do then?
23:14:42 <applicative> > ( fmap (+1) (+2) ) 0
23:14:43 <lambdabot>   3
23:15:02 <bss03> sutabi: You probably want to convert to a "normal" String, maybe then reverse it.
23:15:03 <mauke> sutabi: probably decode it first, then work on the text
23:15:23 <applicative> andares, check out all those fmaps ^^^ once you see they are all like 'map', you are basically ready for anything our friends here can throw at you.
23:15:44 <sutabi> mauke, ok then thats when decodeUtf8 was there
23:15:55 <mauke> sutabi: yes
23:15:56 <sutabi> mauke, but it decodes to internal Text :\
23:16:01 <mauke> sutabi: no, to Text
23:16:06 <bss03> sutabi: Basically, mauke doesn't want you to fall into the ASCII trap.  Bytestrings only hold 8-bit values, so they can only represent a few of the characters Haskell supports.
23:16:45 <applicative> andares, I think Learn You a Haskell explains fmap and the "Functor" class pretty skillfully.
23:17:09 <kmc> ByteStrings do not represent characters at all
23:17:22 <kmc> they hold bytes
23:17:27 <bss03> sutabi: Much of the time a Bytestring will be UTF-8 or Latin1 or even UTF-16 encoded.  In 2 of those cases, reversing the bytestring won't give you the characters you expect.
23:17:38 <applicative> bytes which might represent characters?
23:17:41 <kmc> there are many different standards for how to represent a character as a sequence of bytes
23:17:52 <shachaf> kmc: EBCDIC is the only true standard.
23:18:41 <sutabi> mauke, ok how would I reverse Text then? when I call reverse (T.decodeUtf8 message) I get this error Couldn't match expected type `[a0]' with actual type `Data.Text.Internal.Text'
23:18:55 <mauke> sutabi: T.reverse
23:19:13 <mauke> but maybe you should look at how modules work in general
23:19:39 <bss03> sutabi: The Text module should export a reverse method and you can use that.
23:19:48 <sutabi> import qualified Data.Text.Encoding as T which isn't in encoding its in text. So I just need to import Data.Text?
23:20:01 <mauke> oh, right
23:20:07 <kmc> sutabi, you can import both of them as T
23:20:37 <sutabi> kmc, oh!
23:20:53 <sutabi> >.< mauke bs338 kmc thanks so much sorry for the big circle
23:20:58 <applicative> sutabi, check it out, "subject to fusion"  http://hackage.haskell.org/packages/archive/text/latest/doc/html/Data-Text.html#v:reverse
23:22:21 <sutabi> what is Subject to fusion?
23:22:45 <kmc> fusion is a class of optimizations where you eliminate intermediate data structures
23:22:57 <kmc> a simple example is «map f . map g ≡ map (f . g)»
23:23:02 <kmc> eliminating an intermediate list
23:23:06 <applicative> sutabi, its the form of optimization Data.Text uses.  long sequences of functions from Text to Text are compiled with no new Text built in the middle
23:23:10 <applicative> what kmc said
23:23:14 <mauke> meh, ignore fusion
23:23:48 <sutabi> oh...
23:24:48 <cdsmithus> I agree.  Ignore fusion unless you're reasoning about performance, which from what I've read of your question, it doesn't sound like you're doing.
23:24:51 <applicative> sutabi the point is that you don't have to think about it, the library author is a speed freak who has taken care of all this for us
23:25:06 <andares> applicative: okay. =) I will just take it kinda slow and learn me a haskell then. thanks!
23:26:08 <applicative> andares, excellent.  I think everyone agrees its a good starting point.  Also Real World Haskell.  It is best to stick to quite recent things, as view about how to explain have advance considerably.
23:26:28 <applicative> sorry, dropping a lot of letters there
23:27:14 <applicative> @where RWH
23:27:14 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
23:27:18 <cdsmithus> sutabi: did you get what you need?  Basically, you want to get the ByteString, use decodeUtf8 to turn it into Text (unless you're doing weird non-text stuff, which is allowed, but rare), then use stuff from Data.Text to work with it.
23:27:47 <kmc> binary protocols are rare?
23:27:54 <applicative> how is sutabi 'getting the ByteString'?
23:28:08 <cdsmithus> Binary data in HTTP URL-encoded parameters
23:29:04 <cdsmithus> applicative: he said earlier he's getting it from a parameter in Snap, from an HTTP request
23:29:38 <cwl> bss03: what package do you use for regex expression?
23:29:51 <applicative> oh i see now, yes Snap is very ByteStringy
23:30:27 <sutabi> cdsmithus, i got it working :)
23:31:01 <cdsmithus> Snap has to be ByteString-y at that level, because the HTTP spec doesn't specify an interpretation of those things as text...
23:31:37 <bss03> cwl: I've not needed RegEx in Haskell, yet.  I'd probably just use whatever is in the haskell-platform.
23:37:39 <andares> whee I made zip!
23:45:16 <applicative> > zip [1..] (sort ["California", "Alabama", "Kansas", "Pennsylvania", "Alaska"])
23:45:17 <lambdabot>   [(1,"Alabama"),(2,"Alaska"),(3,"California"),(4,"Kansas"),(5,"Pennsylvania")]
23:45:56 * applicative wonders where Data.State where data State = Alaska | Arkansas ... is
23:46:29 * kmc learned the other day that the mapping from ISO country codes to countries is copyright ISO under a restrictive license
23:47:14 * applicative recommends a slight permutation to the copyright wary.
23:48:36 <shachaf> applicative: That doesn't sound flexible enough.
23:48:58 * applicative demands that the LPGL licence be removed from http://hackage.haskell.org/package/iso3166-country-codes-0.20101223.3
23:49:15 <shachaf> applicative: You need to make it a monad.
23:49:15 <NihilistDandy> GPL? In MY Hackage?~
23:49:21 <shachaf> (The State monad.)
23:49:40 <NihilistDandy> I wish I could @quote that sufficiently
23:49:46 <NihilistDandy> I just don't know which lines to leave out
23:50:25 <applicative> instance Monad CountryCode where return x = Albania;
23:51:16 <NihilistDandy> Any type wizards about?
23:51:30 * kmc puts on his robe and wizard hat
23:51:40 <NihilistDandy> kmc: I'm a rhinoceros
23:51:44 <NihilistDandy> Also, a robot
23:52:09 <applicative> kmc, make Albania polymorphic for us
23:52:17 <NihilistDandy> Okay. Context. Scribbled a very simple, very ugly idea about permutations of finite sets (as they're easy to work with in the near term)
23:52:32 <NihilistDandy> This is the math way to write it: http://mathbin.net/64558
23:52:37 <kmc> united states canada mexico panama haiti jamaica peru
23:52:42 <NihilistDandy> And the Haskell-ish way: http://hpaste.org/49703
23:53:08 <NihilistDandy> Direct from napkin to screen, so forgibe the ugliness
23:53:13 <NihilistDandy> *forgive
23:53:22 <applicative> whoa, stylin' mathbin.net, hadn't seen it.
23:53:39 <NihilistDandy> applicative: It's nice
23:54:25 <NihilistDandy> If you need any details (i.e., something I've made dreadfully unclear) just let me know
23:54:41 <NihilistDandy> I'm curious if a more general version of this is even describable in the type system
23:55:14 <NihilistDandy> e.g., arbitrary cycle size
23:55:39 <kmc> the type generalizes well enough
23:55:52 <kmc> any permutation can be written as a function (a -> a), no matter the cycle size
23:55:59 <kmc> the problem is that other things that aren't permutations also can be
23:56:25 <NihilistDandy> Right
23:58:38 <kmc> aren't f and f_rec the same function?
23:58:43 <NihilistDandy> They are
23:58:56 <NihilistDandy> I was scribbling the first and realized the second was better
