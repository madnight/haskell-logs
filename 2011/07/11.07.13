01:02:07 <wli> I'm getting bad interactions with haddock and LaTeX-style literate code.
02:10:40 <fenris_kcf> hy. what is the recommended way for modularisation? just splitting in separate files and import?
02:19:46 <k0ral> fenris_kcf: hmmm... yes ?
02:20:00 <fenris_kcf> ok, so how to do that?
02:20:14 <fenris_kcf> just writing "import module.hs" yields an error
02:20:21 <k0ral> oh
02:20:43 <k0ral> you have a "module YourModule where" top line
02:20:53 <fenris_kcf> »Syntax error in import declaration (unexpected symbol "module")«
02:20:54 <k0ral> you must write "import YourModule"
02:21:00 <fenris_kcf> ah
02:21:01 <fenris_kcf> ok
02:21:42 <k0ral> it's case sensitive and doesn't wear the ".hs" suffix
02:25:20 <fenris_kcf> k0ral: hmm... the first line of "example.hs" is now "module Module_example where". if i use "import Module_example" in another file contained in the same folder, it says "Can't find imported module"
02:26:05 <k0ral> ah I forgot to tell you the filename has to match the module name
02:26:33 <k0ral> I think there is a way to tell explicitly which file to use but I don't remember
02:26:41 <quicksilver> http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/separate-compilation.html
02:27:35 <fenris_kcf> does this also work with hugs?
02:28:17 <quicksilver> yes, hugs has similar naming conventions
02:33:30 <tigerpaw> re
02:33:45 <tigerpaw> do arrays/indexes in haskell start at 0 or 1?
02:50:56 --- topic: '["Paste code/errors: http://hpaste.org/new/haskell ", "Haskell Platform 2011.2: http://is.gd/dCGPn", "GHC 7: http://is.gd/hb8vE", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/", "admin and spam issues: #haskell-ops"]'
02:50:56 --- topic: set by mauke!~mauke@p3m/member/mauke on [Sat Jun 11 05:12:20 2011]
02:50:56 --- names: list (clog_ fusion5_ mpiechotka jdhky` lsthemes cheater__ magicman adimit_away Muad_Dibber_ Eduard_Munteanu tigerpaw Chaze DustyDingo _zhang Evious [[zz]] hydo jutaro fusion5 dfeuer_ ormaaj_ gbeshers_ Draconxx twanvl_ FUZxxl aculich fxr` `0660 rgrinberg_ kaini_ tomh- bo0ts__ sagex_ alpounet waterlaz_ nightdenial copumpkin kolmodin phyrex1an iago joachifm masklinn path[l] owst fenris_kcf roconnor jrib qz dschoepe ior3k raichoo azaq23 StepanKuzmin julmuri gfarfl)
02:50:56 --- names: list (twanvl Jetbeard wolfpython mv--_ jeltsch simonmellor edon jejansse ramkrsna Jeanne-Kamikaze notostraca Nimatek tromp gpampara Snufsen insomniaSalt djl gusto agundry mrtimuk ahihi2 preflex Pathin perspectival jaspervdj Beetny iFire boegel negaduck rtharper_ hammi Darkflux Veid gehmehgeh Itkovian sshc k0ral vmil86 A1kmm ChongLi novas0x2a SmashLampjaw pikhq_ Palmik adimit dreixel dleslie wtw zul_netbsd The_third_man RayNbow`TU jsgf mustelo xcombelle ousado)
02:50:56 --- names: list (JaffaCake1 sShintah BMeph kish araujo Nisstyre yitz Nshag Bfv9000 k3yb1n wilmoore kyagrd_ kluge otto_s vili ps-auxw EEVIAC neurocyte noblethrasher MaskRay iratsu Lajla kaito_ neaer gienah d2biG kqnr jorgeb juhp Volt_ siracusa msieradzki Niedar theorbtwo peterhil drbean brushbox Axman6 cubi mauke bl4ck rtharper yip uu1101 Eelis eno kelvie_ mwc doughsay shachaf noam till_t sp3ctum dankna cebewee Harbinger Modius clsmith rekahsoft kytibe tgeeky_ Megant jdhky)
02:50:56 --- names: list (wormphlegm confab Philippa drdo Favonia pi8027 yell0 brixen wto mafs b52 taruti anonymo3 EvanR ]OLI[ trez denebola matthew-_ ToRA zaero sanjoyd pen16 lusory_ Amadiro joe6 DustyDin1o jonafan augur psychicist_ mattp_ jssanders ibid fall_ hamishmack Zeiris_ Draggor Muad_Dibber FalkoPeters parcs thorkilnaur__ erk_ QtPlatypus cynick tswett_ almostsix etpace_ mrd gdsx_ CindyLinz peddie cyanoacry blackrain sunfun xinming deggis milli ddarius fcr gwern tsanhwa minsa)
02:50:56 --- names: list (jcp hiredman Cthulhon nyingen ahf sonnym dkasak subpy _1amzave orbitz derrida bbee2 Nalo helgikrs2 saiam janne ion opqdonut perlite tsuraan xenocryst nus sajkr hargettp_ anders^^ alios dbpatterson norm2782 vold dropdrive Zephyrus trygvis zorkon olsner RSchulzM poucet clog dogmaT_ X-Scale jimmy1980 saurik bradwright liesen gdoteof electrogeek sordina2 jmcarthur Draconx tensorpudding kniu mjo ngochai Raku^ gniourf_gniourf ivan devn Raynes elliottcable tessier_)
02:50:56 --- names: list (Yahovah_ Masse^^ pingveno Gracenotes kaol mike1703 mattam [mth]_ int-e fihi09`` luite_ dmwit amiri_ rakete_ Sunhay_ ziman_ MacCoast- plat0 stuartmackie ray descender nowhereman monochrom eyu100 PreciousMetals Cadynum fumbles takamoron towynlin osfameron Vulpyne Dunearhp mxweas liyang DigitalKiwi jbauman Maxdamantus Cerise profmakx ville tafryn pesco wisemanby digicyc flamingspinach DrSyzygy helino rothwell obiwahn scsibug mrdomino accel jlewis jrk_ ve sidek)
02:50:56 --- names: list (cap10morgan Dashkal monokrome jrick bqf xarch_ Younder drmegahertz naota alfa_y_omega Nereid proq mee gentz yahooooo pyrtsa geoffhotchkiss dsouza stepnem nihtml eyck fasta Martty idoru kakazza Somix blomqvist geekounet willb jix xiphiasx Starfire Vorpal TylerE tomku serialhex cpa sm__ neurogeek ido appamatto _habnabit wyfrn felher alip obcode nlogax Obfuscate dcoutts_ Astro Khisanth Baughn alek_br Botje micahjohnston frode Boney robinbb Nanar comak eZet)
02:50:56 --- names: list (SimonRC mm_freak angstrom ClaudiusMaximus Will| reacocard dju wagle Nightwolf ricky gereedy ski twofish thetallguy Iceland_jack samek Veinor palmje frerich stroan OnionKnight pettter incandenza MK_FG tew88 copton CosmicRay _mpu byorgey cjay pastorn whoops akahn sirpengi chaoflow pantski davean maurer_ arkx snr_ nominolo_ savy_ Eliel_ absence Totramon^ ts00000 aristid hyko Choko ttvd edenc ben djanatyn jcapper_ houeland_ burp_ JHoglund_ burp` adnam xplat)
02:50:56 --- names: list (verement Enigmagic quaestor levitation[A] cizra2 Vq finnrobi Ke nazgjunk SonicvanaJr noddy raxas jayne boris`` __class__ alexsdutton arcatan froztbyte Fuco And[y] quicksilver jrockway ixzkn lebastr tamiko rby Bassetts edwtjo dionoea zomg akosch ocharles snorble minecraftfan rndm fds drosophyllum dumael brisbin saati Belgarion_ lomeo Liskni_si manawy wolverian hzh Counter-Strike sully untwisted armence lpsmith dino- d7 welterde ciaranm cheshire-cat_ Igloo)
02:50:56 --- names: list (jabirali djahandarie geekosaur Boxo flux plimsoll sgronblo yottis Ornedan ixchel StoneToad McManiaC Arnar aleator lunaris mornfall joni6128 Hunner R28 waqf marchdown solidsnack idnar kalivha thoughtpolice hanDerPeder comex hvr ttblrs brett rfgpfeiffer lambdabot edwinb HalfWayMan Runar bremner` earthy hpc shutdown_-h_now dilinger scree snarkyboojum maloi finnomenon benmachine tridactyla inr majoh Lemmih rntz Bleadof andersk zmoazeni Laney ezyang drhodes sbok)
02:50:56 --- names: list (Intensity audunska aspect theclaw jd10 Gilly AnAdorableNick BrianHV rattboi cncl sunnavy Utkarsh robinsmidsrod LeNsTR freeformz smly- mlh chitragupt dom96 sohum skaar_ Clint arw__ twn EvanCarroll ccasin flazz etabot nimred kalven jyyou xale marienz caligula tommd liw Derander kbar felipe_ dcoutts spetrea robbert politik naneau lispy carrbs1 dcolish daed koninkje_away milkpost smop mietek companion_cube deavid lukish_ gbacon_ confound aiko suiside avocado)
02:50:56 --- names: list (jlouis zaphar_ps ernst lokydor gf3 hpaste srcerer gds jlaire petanqk ehamberg bs338 dqd solarus henr_k mortberg ptrf tomaw emias sipa Innominate _main_ fabjan hhulkko Mitar Aestas c1de0x kloeri inimino davidL PHO_ erg andrewsw noj bezik ozzloy zenzike szbalint impl hellige EpsilonDur periodic ian_mi johs legov osoleve kosmikus Zol freiksenet integral jml Twey mokus guerrilla shepheb seats karld @ChanServ _erik_ KitB scsibug_ Aisling zakwilson koala_man)
02:50:56 --- names: list (dorkitude rwbarton vinc Saizan absentia bd_ mrshoe silex mux dixie pr zygoloid ibt klugez)
02:50:56 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
02:51:07 <tigerpaw> why would a robust language like haskell have an old school numbering scheme?
02:51:27 <maurer_> tigerpaw: Numbering from 0 is not "oldschool"
02:51:36 * shachaf wonders what a new-school numbering scheme would be like.
02:51:36 <Eduard_Munteanu> > let arr = listArray (3,6) [1,2,3,4] in arr ! 4
02:51:37 <lambdabot>   2
02:51:45 <shachaf> Maybe a postmodern numbering scheme.
02:52:02 <tigerpaw> i just don't see how the first item in a list can be at position 0
02:53:13 <shachaf> Where would you want it to start?
02:53:17 <tigerpaw> 1
02:53:18 <osfameron> tigerpaw: it's the offset from the beginning
02:53:23 <tigerpaw> the 2nd item at position 2, etc
02:53:30 <tigerpaw> hmm
02:53:51 <osfameron> you find yourself having to do +1/-1 less if you do 0-based numbering
02:54:05 <tigerpaw> but does it make natural sense is what i wonder...
02:54:06 <shachaf> Think of a sequence ("abc") like this: |a|b|c|
02:54:14 <tigerpaw> if we're talking about offset from the beginning, i can see that
02:54:21 <shachaf> The posts are clearly labeled 0,1,2,3.
02:54:22 <tigerpaw> shachaf, ok
02:54:45 <shachaf> The question is whether you index an item by the post to its left or to its right.
02:54:52 <tigerpaw> yes
02:54:56 <tigerpaw> i follow this so far
02:55:08 <tigerpaw> i look at the a and see 1
02:55:13 <Eduard_Munteanu> base, base + offset, base + 2 * offset ...
02:55:17 <shachaf> You can argue both ways, but in practice (at least so I claim), labeling from the left works out more nicely. :-)
02:55:19 <tigerpaw> i personally number by entity, not boundary post
02:55:33 <shachaf> Right, it's entity 0. :-)
02:55:41 <tigerpaw> 1
02:55:47 <tigerpaw> appears to me anyway
02:55:52 <osfameron> IT'S BEHIND YOU!
02:55:56 <tigerpaw> i want to believe in the 0
02:55:56 <quicksilver> it's for arithmetic mostly I think.
02:56:00 <tigerpaw> it's just unusual
02:56:10 <quicksilver> it's not unusual, tigerpaw, it's very usual
02:56:15 <quicksilver> almost all languages index from 0.
02:56:19 <shachaf> Most programming languages nowadays use 0.
02:56:21 <Eduard_Munteanu> Anyway, in C it's quite common to say    for (i = 0; i < n; i++)
02:56:21 <osfameron> except Visual Basic!
02:56:40 <quicksilver> for example if you concatenate two lists
02:56:50 <quicksilver> the index into the second part is "length (first) + i"
02:56:58 <quicksilver> if it was one based you'd need a (-1) in there.
02:56:59 <shachaf> tigerpaw: Do you know C? The argument for indexing from 0 there is completely obvious. :-)
02:57:06 <tigerpaw> im learning C now actually
02:57:09 <tigerpaw> yea...
02:57:14 <tigerpaw> the address is the location of item 1
02:57:23 <quicksilver> if you have a 2D matrix represented as a 1D list, y*w + x works.
02:57:39 <Eduard_Munteanu> Yeah, that's a nice one too.
02:57:40 <shachaf> But in Haskell it makes sense too -- e.g. what quicksilver is saying.
02:57:40 <quicksilver> if it was 1-based youd have one or two (+1) or (-1)
02:57:57 <quicksilver> IMO it's all about the arithmetical properties of the number.
02:58:46 <tigerpaw> hm
02:59:20 <Eduard_Munteanu> If you have some   int arr[10]   in C, you can define   int *p = arr - 1   and use p[1] ... p[10]
02:59:41 <shachaf> Eduard_Munteanu: That's undefined if p == 0. :-)
02:59:46 <osfameron> in zero-based numbering, do you say "oneth", "twoth", "treeth" instead of "first", "second", "third" ?
03:00:02 <Eduard_Munteanu> But anyway considering how one usually uses lists in Haskell, you don't really need to ever mention the index.
03:00:08 <Eduard_Munteanu> Yeah.
03:00:23 <tigerpaw> weird
03:00:29 <shachaf> That's true.
03:00:29 * quicksilver smacks osfameron in the treeth.
03:00:45 <shachaf> To be fair, tigerpaw asked about arrays originally.
03:00:51 <shachaf> To be fair, tigerpaw probably didn't mean arrays.
03:01:05 <Eduard_Munteanu> osfameron: I usually say first, second etc., I got used to transparently converting those to actual indices in my head
03:02:12 <osfameron> Eduard_Munteanu: I think I say "zeroth", "element 1", ...
03:02:35 <shachaf> English is broken.
03:02:35 <quicksilver> I say first.
03:02:42 <quicksilver> (a !! 0) is the first element of a.
03:02:55 <benmachine> I just stay quiet?
03:02:58 <quicksilver> I don't feel the need to say if often, but that's what I say nonetheless.
03:03:06 <tigerpaw> hm
03:04:18 <osfameron> hmm, you're probably right, I guess I say first/second/etc. too
03:04:31 <osfameron> it's hard to observe your own language usage ;-)
03:05:01 <tigerpaw> yea everyone does, it's natural
03:05:16 <tigerpaw> hence why 0 index, even if mathematically convenient, just doesn't feel right
03:05:29 <tigerpaw> |a|b|c| post example was a good one
03:05:36 <tigerpaw> but i look at it and don't care about the posts, i look at the values
03:05:37 <tigerpaw> a b c
03:05:42 <tigerpaw> and i see first 2nd third
03:06:49 <benmachine> tigerpaw: what's natural in terms of language isn't always what's sensible
03:07:04 <benmachine> but if you really wanted to in haskell you could avoid zero-indexing, I think
03:07:05 <Eduard_Munteanu> (Even in C one rarely defines primitives for accessing linked lists by element index)
03:08:32 <lysgaard> I have a module that compiles. Now i want to change the name of a function. Is there some way to do this automatically. Since it compiles it should be possible, but does there exist such software for haskell? I'm looking for something smarter than search and replace.
03:08:51 <quicksilver> lysgaard: various people have started to write things which do this. I'm not sure which of them is closed to working.
03:09:22 <quicksilver> lysgaard: http://www.cs.kent.ac.uk/projects/refactor-fp/hare.html http://hackage.haskell.org/package/scion are two which spring to mind.
03:09:23 <Eduard_Munteanu> Qualified import and reexport under a different name?
03:09:26 <quicksilver> I think there have been others.
03:09:49 <Phyx-> Is ghc now able to derive Show instances for function types now? I'm getting a weird error. http://pastebin.com/9wCaRYNK but the module which supposedly exposes both instances compiles fine
03:09:52 <mauke> The paste 9wCaRYNK has been copied to http://hpaste.org/48986
03:10:44 <sipa> what would a Show instance for a function type do?
03:11:45 <benmachine> sipa: nothing useful, usually
03:12:12 <benmachine> sipa: on some specialised domains it can actually return a string representing a lambda
03:13:01 <Phyx-> sipa: nothing really, I just need it to get the rest of the type to be showable
03:13:40 <quicksilver> Phyx-: yes. modules can define illegal instances without causing complaint.
03:13:52 <quicksilver> Phyx-: it is the *usage* of illegal instances which causes an error.
03:13:53 <sipa> but show is intended to be a representation in haskell syntax that can be used to reconstruct the value
03:14:03 <Phyx-> since the function is Bool -> [(String)] I just show the value of f True and f False
03:14:05 <sipa> that seems hard for function types
03:14:27 <quicksilver> Phyx-: a fix might be to add OverlappingInstances to WinDll.Structs.Types although that suggests something more serious is wrong.
03:14:54 <Phyx-> quicksilver: what's confusing me is that it was working just fine till yesterday. I don't see how/why there's more than one instance
03:15:15 <quicksilver> well nobody is going to be able to help you without seeing the code :)
03:15:53 <Phyx-> the code seems rather irrelevant but I'll paste
03:16:49 <benmachine> Phyx-: maybe there's a bad interface file around, make clean?
03:18:37 <Phyx-> could be, it started when i changed the library's version number
03:18:57 * Phyx- deletes sdist
03:19:19 <Phyx-> dist*
03:19:58 <quicksilver> hmm yes
03:20:03 <quicksilver> like it's finding the module twice
03:20:08 <quicksilver> odd that if so.
03:20:28 <shachaf> What non-bottom values can a Word8 be other than 0-255?
03:21:08 <shachaf> I made a function that takes a Word8 and matches all 256 cases, and GHC still complains about non-exhaustive patterns.
03:21:27 <Saizan> i don't think ghc is that smart
03:21:31 <Phyx-> i deleted dist and the same error . the code that are conflicting is http://pastebin.com/u1a8TwzJ
03:21:33 <mauke> The paste u1a8TwzJ has been copied to http://hpaste.org/48987
03:21:36 <geheimdienst> > (-1) :: Word8
03:21:36 <lambdabot>   255
03:22:54 <geheimdienst> > let f x :: Word8 -> a ; f x = x in f (-1)
03:22:55 <lambdabot>   <no location info>: Invalid type signature
03:23:09 <geheimdienst> > let f :: Word8 -> a ; f x = x in f (-1)
03:23:10 <Phyx-> also for some strange reason, cabal suddenly requires me to mention the package i'm building in the dependency list. I think there's something screwed up
03:23:10 <lambdabot>   Couldn't match expected type `a'
03:23:10 <lambdabot>         against inferred type `GHC.Word.Wo...
03:23:18 <geheimdienst> bah
03:23:37 <geheimdienst> ... but in theory, i think it should work, shachaf
03:23:37 <Saizan> Phyx-: loads fine
03:23:52 <geheimdienst> i imagined a Word8 like a "data" that has 255 constructors ...
03:24:20 <Saizan> i mean, it loads fine here in ghc-7.0.3 after i've commented out the things not in scope
03:24:32 <Phyx-> hmm
03:24:43 <Phyx-> i'm on 7.0.3 too
03:25:00 <Saizan> Phyx-: is this while building an exe?
03:25:51 <Saizan> anyhow, i support quicksilver's idea that ghc is somehow loading the module twice
03:25:53 <Phyx-> Saizan: yes, the exe shares code with a lib that's also build from the cabal file. I think I accidently screwed up the dependencies
03:26:05 <Phyx-> yeah, I think quicksilver's right too
03:26:30 * Phyx- looks at his cabal file
03:26:53 <Saizan> in recent cabal the exe can depend on the lib in the same package (by mentioning the lib in the build-depends, but make sure you're not excluding the current version)
03:26:57 <ketil> I'm trying to install "bio", using cabal-install.  It complains about QuickCheck >= 2 not being installable, but after 'cabal-install QuickCheck', 'cabal install bio' works OK.  Any ideas why?
03:27:09 <Saizan> and you also have to use separate hs-source-dirs then
03:27:55 <Phyx-> Saizan: right, I think that's the problem. Suddently cabal requires me to mention my lib when building the exe. but they share the hs-source-dirs
03:28:18 <Phyx-> It can't seem to find a module that's build after preprocessing
03:28:47 <Saizan> ketil: cabal install bio --dry-run -v before installing QuickCheck would have given you more details
03:29:04 <Saizan> Phyx-: it's not meant to require you to mention the lib, so there's something weird there
03:29:38 <Phyx-> Saizan: I think when building the exe cabal doesn't run the preprocessors, or doesn't look in the right folders
03:29:46 <Phyx-> previously, I had the file as Foo.hs
03:29:52 <Phyx-> now it's Foo.cpphs
03:30:10 <Saizan> is that the main of the exe?
03:30:13 <Phyx-> no
03:31:09 <Saizan> i'm pretty sure it runs the preprocessors for exes
03:31:42 <Phyx-> somethings rather odd
03:31:59 <ketil> Hm. dry-run doesn't mention QuickCheck in the output!?
03:32:01 <Phyx-> ok
03:32:24 <Phyx-> Saizan: I managed to fix it by mentioning the module in the Other-Modules field of the exe
03:33:38 <Saizan> Phyx-: ah, yeah, it only preprocesses listed modules
03:33:51 <Saizan> ketil: that's because you already have it installed
03:33:56 <Phyx-> ah ok, that explains it :)
03:34:29 <ketil> Saizan, no, I removed it.  But it is only a dependency of some executables, not of the package.  This could be a cabal versioning issue, I think.
03:35:08 <Phyx-> also having a weird error with the test suite. http://pastebin.com/CGt3qkKQ at the end, I always get 'permission denied'
03:35:10 <mauke> The paste CGt3qkKQ has been copied to http://hpaste.org/48988
03:36:42 <ketil> Saizan, yup, I added QC to the library dependencies, and now it compiled.  Could also be that there are real deps in there, but AFAICT, it didn't get to actually compiling anything.
03:37:11 <ketil> Ideally, I'd want it to be possible to compile the library without QC, and only depend on QC if the test flag is set (and test executables are to be built).
03:42:48 <lysgaard> quicksilver: So there is no do it all refactoring in Haskell?
03:43:55 <quicksilver> lysgaard: a number of projects have been developed, I've not tried any of them so I can't speak for how far they got.
03:45:04 <Phyx-> HaRe seems pretty advanced though
03:46:46 <phuc> I downloaded Supero and compiled it, but don't know how to use it to compile my source code. It looks like Supero only supports a subset of Haskell syntax recognized by GHC. How do I generate the kind of Haskell code that Supero understands?
03:47:15 <phuc> by Supero, I mean this http://community.haskell.org/~ndm/supero/
03:51:24 * hackagebot data-cycle 0.1.0 - a cyclic doubly linked list  http://hackage.haskell.org/package/data-cycle-0.1.0 (TobiasBrandt)
03:55:32 <Saizan> yeah, it think it's meant to work on GHC's external core now, or maybe still yhc's one
03:56:24 <lysgaard> quicksilver: I see, anyways thanks.
04:05:26 * hackagebot regexdot 0.10.2.1 - A /polymorphic/, POSIX, extended regular-expression engine.  http://hackage.haskell.org/package/regexdot-0.10.2.1 (AlistairWard)
04:06:26 * hackagebot regexchar 0.9.0.7 - A POSIX extended regular-expression engine.  http://hackage.haskell.org/package/regexchar-0.9.0.7 (AlistairWard)
04:11:05 <Phyx-> lol, cabal says registering my lib
04:11:10 <Phyx-> but ghc-pkg doesn't have it
04:11:11 <Phyx-> :S
04:11:53 <Phyx-> wth is going on today
04:12:33 <dcoutts> Phyx-: note that it says that during building, because it's registering into a local package db
04:12:50 <dcoutts> it only gets registered in the usual place during install
04:12:57 <Phyx-> oh
04:13:26 <Phyx-> dcoutts: thanks :)
04:14:03 <dcoutts> we should suppress that message, it's confusing
04:14:35 <Phyx-> dcoutts: might you also know why i'm getting permission denied errors at the end of every test run?
04:14:56 <Phyx-> the test suites finishes and then just says permission denied
04:16:46 <dcoutts> Phyx-: that's interesting, no I don't know, file a ticket with as much info as you have
04:18:58 <Phyx-> dcoutts: ok, I'll see what I can find
04:21:42 <Phyx-> Bizzare... now it suddenly works. Think something might have been wrong in dist, it used to do this http://pastebin.com/CGt3qkKQ
04:21:43 <mauke> The paste CGt3qkKQ has been copied to http://hpaste.org/48988
04:25:36 <lysgaard> Is there a way to convert a lazy bytestring to a strict one?
04:26:33 <Saizan> concat . toChunks but it's quite expensive
04:28:01 <lysgaard> Actually my real problem is that i can't find a encode from the Binary that converts to a strict bytestring, maybe there's a good reason for that?
04:28:24 <parcs> using binary-strict
04:28:36 <parcs> use*
04:32:27 <lysgaard> parcs: How do i use it?
04:32:53 <lysgaard> parcs: Seems like it's not a drop in replacement
04:34:32 <lysgaard> parcs: As far as I see it only implements the Get monad strict
04:34:47 <parcs> hmmm yeah
04:34:55 <parcs> see cereal instead
04:44:53 <lysgaard> parcs: Thanks
04:56:52 <lysgaard> How can I evaluate: length [1..] < 10 wich ofcource is true?
04:57:31 <shachaf> lysgaard: Lazy naturals with genericLength.
04:57:41 <shachaf> It of course isn't True, with Ints.
04:59:16 <arw__> > length $ takeWhile (< 10) [1..]
04:59:17 <lambdabot>   9
04:59:39 <shachaf> arw__: That's a completely different query. :-)
05:00:21 <shachaf> > (null . drop 9) [1..] -- Closer.
05:00:23 <lambdabot>   False
05:00:31 <parcs> length [1..] < 10 is true?
05:00:43 <shachaf> lysgaard: By the way, it's not even true for lazy naturals; presumably you mean >.
05:01:07 <arw__> shachaf: maybe, but i didn't quite understand the question...
05:01:38 <lysgaard> Ah, my example should read isn't true ;)
05:02:39 <hpc> parcs: technically, bottom is the minimum element of the set of haskell values, so yes? :P
05:03:04 <shachaf> hpc: The question was about (<), which is a strict Haskell function.
05:03:21 <hpc> i know, just being obnoxious
05:03:36 <shachaf> Right, but if you're being pedantic, at least be correct about it.
05:03:46 <hpc> heh
05:04:07 <lysgaard> To be more specific. I have a bytestring of unknown length, maybe infinite. Then i want to know if it's longer than a set length.
05:04:39 <lysgaard> Maybe: null $ (drop 20 [1..])
05:04:40 <shachaf> That's not more specific -- that's yet another different question.
05:04:56 <shachaf> Anyway, yes, (null . drop) will probably do what you want.
05:05:44 <shachaf> Wow, this is a great Unicode symbol! ⋚
05:06:06 <lysgaard> shachaf: now how to understand that?
05:06:13 <shachaf> Which?
05:06:40 <arw__> lysgaard: drop n removes the first n elements from a list, possibly returning an empty list.
05:06:55 <arw__> lysgaard: null tells you if a list is empty by returning a Bool.
05:07:27 <arw__> > (null . drop 20) [1..30]
05:07:29 <lambdabot>   False
05:07:32 <arw__> > (null . drop 20) [1..15]
05:07:33 <lambdabot>   True
05:07:43 <lysgaard> arw__: Oh, thanks, I understood the example, i just wondered about that strange unicode symbol ;)
05:07:57 <shachaf> 22DA            LESS-THAN EQUAL TO OR GREATER-THAN      [⋚]
05:07:58 <arw__> ah, okay :)
05:08:19 <arw__> they should have named it 'WHATEVER SYMBOL'
05:08:23 <Phyx-> lol, wtf
05:08:35 <flux> that's the sign for 'equal to or not equal to'?
05:08:45 <shachaf> It might make sense with some partial orderings, I guess.
05:08:50 <geheimdienst> Unicode 22DA [⋚] NOBODY CARES
05:09:11 <shachaf> Of course, this symbol is even better: ⋛
05:09:25 <geheimdienst> Unicode 22DA [⋚] HOW DO I KNOW
05:10:07 <geheimdienst> Unicode 22DA [⋚] YOU'RE UP AND YOU'RE DOWN, YOU'RE HOT AND YOU'RE COLD, YOU'RE IN AND YOU'RE OUT, ...
05:10:10 <lysgaard> This should be in the haskell weekly
05:10:51 <Phyx-> geheimdienst: lol, I was just listening to that song
05:11:00 * Phyx- is watching masterchef australia
05:11:03 <shachaf> They're missing the same sign except with a big / through it.
05:11:19 <shachaf> How can you express it when it's not true!
05:11:20 <geheimdienst> phyx-, check the polka version on youtube sometime. it's great
05:11:22 <magicman> > let x ⋚ y = True in 5 ⋚ 7
05:11:23 <lambdabot>   True
05:11:27 <magicman> Whoa.
05:11:38 <Phyx-> geheimdienst: lol, there's a polka version?
05:11:43 <shachaf> > let x ⋚ y = True in 5 ⋚ "norway"
05:11:43 <lambdabot>   True
05:11:52 <arw__> shachaf: you could add a combining /...
05:12:57 <Phyx-> > let x ⋚ y = datatypeOf x == datatypeOf y in 5 ⋚ "norway"
05:12:58 <lambdabot>   Not in scope: `datatypeOf'Not in scope: `datatypeOf'
05:13:01 <geheimdienst> phyx-, yeah sure. something like 3 polish dudes with heavy accents. it's hilarious, especially when the singer goes "like a bitch, i would know ..."
05:13:09 <Phyx-> @hoogle datatype
05:13:09 <lambdabot> Data.Data data DataType
05:13:10 <lambdabot> Data.Data dataTypeConstrs :: DataType -> [Constr]
05:13:10 <lambdabot> Data.Data dataTypeName :: DataType -> String
05:13:21 <Phyx-> > let x ⋚ y = datatypeName x == datatypeName y in 5 ⋚ "norway"
05:13:22 <lambdabot>   Not in scope: `datatypeName'Not in scope: `datatypeName'
05:13:33 <Phyx-> > let x ⋚ y = dataTypeName x == dataTypeName y in 5 ⋚ "norway"
05:13:34 <lambdabot>   Couldn't match expected type `Data.Data.DataType'
05:13:34 <lambdabot>         against inferred ...
05:13:36 <Phyx-> fail..
05:13:37 <arw__> ⋚̷
05:13:47 <arw__> almost invisible in my font.
05:13:47 <shachaf> > let x ⋚ y = const (const True) `asTypeOf` (<=) in 5 ⋚ "norway"
05:13:48 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> b -> GHC.Bool.Bool)
05:13:48 <lambdabot>    arisin...
05:14:02 <magicman> @hoogle Data a => a -> DataType
05:14:03 <lambdabot> Data.Data dataTypeOf :: Data a => a -> DataType
05:14:03 <lambdabot> Data.Data gmapT :: Data a => (b -> b) -> a -> a
05:14:03 <lambdabot> Prelude id :: a -> a
05:14:14 <magicman> @info DataType
05:14:15 <Phyx-> > let x ⋚ y = dataTypeName x == dataTypeName y in (5 :: Int) ⋚ "norway"
05:14:15 <lambdabot> DataType
05:14:16 <lambdabot>   Couldn't match expected type `Data.Data.DataType'
05:14:16 <lambdabot>         against inferred ...
05:14:27 <Phyx-> @hoogle typeOf
05:14:28 <lambdabot> Data.Typeable typeOf :: Typeable a => a -> TypeRep
05:14:28 <lambdabot> Data.Typeable typeOf1 :: Typeable1 t => t a -> TypeRep
05:14:28 <lambdabot> Data.Typeable typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
05:14:47 <Phyx-> > let x ⋚ y = typeOf x == typeOf y in 5 ⋚ "norway"
05:14:48 <lambdabot>   False
05:14:51 <Phyx-> there
05:14:57 <magicman> *grin*
05:15:14 <Phyx-> > let x ⋚ y = typeOf x == typeOf y in 5 ⋚ 8
05:15:15 <lambdabot>   True
05:16:44 <parcs> @check \a b -> a <= b || a > b
05:16:44 <lambdabot>   "OK, passed 500 tests."
05:17:17 <parcs> > let x = 0/0 in x <= x || x > x
05:17:17 <lambdabot>   False
05:23:28 <fenris_kcf> how can i make an operator "abstract"? i get a problem, when defining:
05:23:28 <fenris_kcf> example :: t -> [t] -> [t]
05:23:28 <fenris_kcf> example value components = map (value *) components
05:23:43 <fenris_kcf> it says, that the infered type is not general enough
05:23:49 <shachaf> fenris_kcf: Well, that won't work for any type t.
05:24:00 <shachaf> Only types that you can multiply by things. What does it mean to say (True *)?
05:24:04 <fenris_kcf> just for the ones, that instanciate Num?
05:24:11 <shachaf> Yes.
05:24:14 <Jetbeard> yes, indeed
05:24:20 <shachaf> In Haskell you express this constraint by saying example :: (Num t) => t -> [t] -> [t]
05:24:31 <fenris_kcf> ah, of course
05:24:38 <fenris_kcf> i forget that somehow...
05:24:40 <shachaf> Or you can just not write out the type and let GHC infer it for you, then ask ghci. :-)
05:25:01 <fenris_kcf> yes, first i left the type out
05:25:18 <fenris_kcf> but i wanted to add it, so i can avoid some errors later
05:25:52 <shachaf> Right. So you could've asked GHC -- it's even better at simple type inference #haskell. :-)
05:26:25 <dpratt71> supposing that I have a function defined like `filter someCondition someList`, it seems that it should be easy to parallelize. True? What's the quickest/easiest way to do that?
05:26:42 <Jetbeard> :t (\v c -> map (v *) c)
05:26:42 <lambdabot> forall a. (Num a) => a -> [a] -> [a]
05:27:16 <shachaf> dpratt71: Look up par/pseq.
05:27:26 <notostraca> who was it who wanted a strongly typed scripting language?
05:27:33 <notostraca> Opa is pretty slick so far
05:27:55 <notostraca> http://opalang.org/ for reference
05:27:59 <shachaf> dpratt71: There's also http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/monad-par.pdf :-)
05:28:07 <notostraca> it fills a very different niche to haskell :-)
05:28:40 <dpratt71> shachaf: ok, thanks; I was hoping for something at a bit higher level of abstraction
05:28:58 <shachaf> dpratt71: Well, you can always write pfilter in terms of those.
05:29:07 <shachaf> dpratt71: What sort of thing were you hoping for?
05:29:29 <dpratt71> shachaf: pfilter :) not immediately obvious how to render that, though
05:30:27 <shachaf> dpratt71: Well, see also that PDF.
05:30:46 <dpratt71> shachaf: ok, will do, thanks
05:31:13 <fenris_kcf> can i create assertions like "(Num t) => " myself? i want to make sure, that a specific type has a certain function implemented
05:31:29 <shachaf> fenris_kcf: Sure, if you define your own type class.
05:31:35 <shachaf> Read about type classes. :-)
05:31:43 <fenris_kcf> ok, i'll do that. thy
05:31:44 <shachaf> Are you reading some Haskell book?
05:31:48 <fenris_kcf> no
05:32:10 <shachaf> @where lyah is often recommended in here. It talk about them.
05:32:10 <lambdabot> http://www.learnyouahaskell.com/
05:32:57 <parcs> what about parList rpar (filter ...) ?
05:34:15 <shachaf> That would work, I think.
05:34:52 <erus`> lexCode code = map fromJust $ filter isJust $  map lexLine $ lines code
05:34:59 <erus`> can i reduce that line?
05:35:21 <shachaf> erus`: Don't fromJust, it's evil.
05:35:59 <quicksilver> erus`: map fromJust . filter isJust ===> catMaybes
05:36:35 <copumpkin> [x | Just x <- xs] is almost as short, too
05:36:44 <shachaf> Yep.
05:36:57 <quicksilver> copumpkin: but less pointfree ;)
05:37:11 <quicksilver> gets a bit longer when you have to wrap it in (\xs -> ... )
05:37:20 <erus`> @type catMaybees
05:37:21 <lambdabot> Not in scope: `catMaybees'
05:37:29 <erus`> @type catMaybes
05:37:30 <lambdabot> forall a. [Maybe a] -> [a]
05:37:48 <shachaf> quicksilver: Right, but that's not necessary in erus`'s expression, I think.
05:37:54 <shachaf> @ty [x | Just x <- map ?lexLine (lines ?code)]
05:37:54 <lambdabot> forall t. (?code::String, ?lexLine::String -> Maybe t) => [t]
05:37:58 <Jetbeard> :t mapMaybe
05:37:58 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
05:38:08 <shachaf> And then there's also that.
05:38:11 <quicksilver> nod
05:38:49 <magicman> mapMaybe pretty much wins when it comes to shortness.
05:39:29 <shachaf> Not if you include import Data.Maybe. :-)
05:39:57 <magicman> True :p
05:40:57 <Jetbeard> Am I correct in thinking that erus`' initial definition could be shortened to: lexCode = (mapMaybe lexLine) . lines
05:41:14 <magicman> Parentheses not needed, but yes.
05:41:45 <Jetbeard> parentheses for me are a method for me not to have to think about precedence :)
05:42:38 <shachaf> Jetbeard: Learning Haskell precedence will prove more helpful. :-)
05:42:38 <zygoloid> Jetbeard: the key rule is that prefix function application always binds tightest. so when reading code, start by splitting it on parens and operators
05:42:45 <shachaf> Jetbeard: Functional application always -- yes.
05:43:00 <Jetbeard> shachaf: i'm not a fan of things with precedence
05:43:03 <zygoloid> Jetbeard: you bascially need to internalize that rule to be able to read haskell
05:43:16 <magicman> And learning how to read chains of (.) and ($) is useful, too.
05:43:40 <shachaf> Jetbeard: Well, application is a special-case. It's not customizable like operators.
05:44:05 <Jetbeard> if Scheme weren't so scary I'd prefer it over Haskell, methinks :)
05:44:42 <zygoloid> (dislike self (filter ugly languages))
05:46:33 <mokus> (agree mokus zygoloid)
05:47:04 <Jetbeard> (agree Jetbeard mokus)
05:47:08 <quicksilver> Jetbeard: I'm not a fan of precedence in general. I tend to put parens into operator expressions.
05:47:20 <Jetbeard> but my standard libraries have a different definition of the 'ugly' funciton
05:47:22 <quicksilver> Jetbeard: however in the *specific* case of haskell function application, you must learn it.
05:47:35 <quicksilver> otherwise you can't read f x + y.
05:48:14 <Jetbeard> i know the rule, it's just that a little part of me reads `f x+y` as `f (x+y)`
05:48:28 <Jetbeard> sometimes i wish i hadn't taught myself how to code before coming to uni
05:48:47 <shachaf> Jetbeard: You'd be best off retraining that part of you for Haskell purposes. :-)
05:48:58 <Cale> It helps if you basically always put spaces around infix operators
05:49:07 <flux> is there a language where lack of whitespace binds tightly?-)
05:49:24 <Jetbeard> flux: common sense :)
05:49:32 <Jetbeard> (not at all the same as 'logic', mind you)
05:49:32 <flux> jetbeard, a computer language that is ;)
05:49:32 <mokus> Jetbeard: over the course of your life you'll have to relearn syntax dozens of times, doesn't hurt to start in uni
05:49:57 <shachaf> Jetbeard: At any rate, learning Haskell before going to university would only have made it easier, no? :-)
05:50:15 <Jetbeard> yes, but learning PHP before probably didn't :)
05:50:37 <quicksilver> flux: in agda lack of whitespace means it is a compound operator, as I understand it.
05:50:38 <Eduard_Munteanu> zygoloid: that looks like faked OO
05:50:50 <shachaf> Oh, when you said "code" I thought you meant a real language. :-)
05:51:10 * shachaf is joking, of course. Only PHP is unclear enough to be called "code".
05:51:20 <Jetbeard> hehe
05:51:38 <insane> is there a nice way to pass additional arguments to show function. I need it because I have "instance Eq T" and show defined there, but I need additional information from environment to correctly show objects of type T
05:51:55 <insane> I meant "instance Show T"
05:52:06 <shachaf> insane: No, you can't use Show in that case. It has to have type (Show a) => a -> String.
05:52:19 <quicksilver> insane: well you can add a constraint.
05:52:31 <quicksilver> instance (Foo x) => show (T x)
05:52:54 <shachaf> That's on the type, though.
05:53:05 <shachaf> Show ⋚ Foo
05:53:11 * shachaf enjoys that operator.
05:53:32 <quicksilver> I'm not sure what you mean by "that's on the type"
05:53:36 <quicksilver> that is a constraint on the instance.
05:53:56 <Jetbeard> It's the 'is in the same connected component as on the graph of the order' operator, shachaf
05:54:00 <shachaf> quicksilver: I think insane meant something along the lines of show :: ExtraInfo -> MyType -> String.
05:54:33 * shachaf may have misinterpreted.
05:54:37 <Jetbeard> insane: clarifying what you mean in this particular circumstance may help
05:54:45 <quicksilver> shachaf: I think he meant that too.
05:54:49 <insane> exactly what shachaf said
05:54:56 <insane> show :: Env -> MyType -> String
05:54:57 <quicksilver> shachaf: the extra constraint on the instance is as close as you can get, though.
05:55:01 <mm_freak> comparing haskell to PHP is like comparing a carriage driven by dead horses to a space shuttle sent to us through a wormhole from the future
05:55:04 <quicksilver> shachaf: and it does give you *some* extra information.
05:55:13 <quicksilver> insane: no. If you have that type, it isn't Show.
05:55:21 <shachaf> quicksilver: Right, but it doesn't do what insane asked for. :-)
05:55:27 <azaq23> Show shouldn't be used for some fancy printing, but only for an accurate and minimal representation of the value in question (ideally one for which there's also an Read instance, so that read . show = id), making this request a misuse of the Show typeclass, not?
05:55:37 <mm_freak> it's not exactly that PHP is bad…  you just can't get it to do something useful easily
05:55:58 <shachaf> azaq23: Yep.
05:56:13 <shachaf> mm_freak: Isn't the whole *point* of PHP that you can get it to do somethin useful easily?
05:56:41 * shachaf didn't mean to pick on PHP there, by the way, just to engage in some general-purpose IRC irrationality.
05:56:57 <mm_freak> that's not at all irrational
05:57:06 <insane> so what do you suggest to do in this case?
05:57:14 <insane> what would be the proper solution?
05:57:26 <quicksilver> insane: don't use Show.
05:57:34 <quicksilver> insane: just call it whatever you like to call it
05:57:41 <shachaf> The type class Show doesn't describe the behavior you want.
05:57:47 <quicksilver> insanes_really_insane_printing_function :: Env -> MyType -> String
05:57:53 <quicksilver> I tend to call it 'pp'.
05:58:08 <insane> :)
05:58:09 <shachaf> You're allowed to use apostrophes in Haskell identifiers. :-)
05:58:09 <insane> ok
05:59:18 <dpratt71> is the parallel package still relevant?
05:59:38 <Jetbeard> shachaf: if there's one language that needs picking on it's PHP
05:59:43 <shachaf> dpratt71: Of course. Why wouldn't it be?
05:59:48 <shachaf> Jetbeard: Nah, enough people pick on it.
05:59:59 <Jetbeard> It still exists: not enough people pick on it.
06:00:00 <saml> PHP is a good language if you use it correctly..
06:00:10 <saml> just like haskell
06:00:28 <Jetbeard> saml: PHP is messy and illogical in many places
06:00:47 <saml> like any software...
06:00:48 <dpratt71> shachaf: I was considering perhaps it hae been fully superseded by something else
06:01:01 <saml> haskell libraries are illogical too
06:01:14 <saml> not coherent at all
06:01:29 <saml> stop complaining and write some quality software
06:02:04 <Jetbeard> i would but i never can be bothered
06:02:35 <Jetbeard> (and besides i don't have a <my language du jour> compiler on this machine ;) )
06:02:35 <dpratt71> based on the definition of parMap from the parallel library, I have defined this: parFilter strat f = (`using` parList strat) . filter f
06:02:36 <saml> then just write some quality software for web scale.
06:02:47 <dpratt71> does that make sense?
06:03:15 <dpratt71> will it do what I want? filter the items of the list (potentially) in parallel?
06:03:38 <saml> parMap strat f = (`using` parList strat) . map f
06:04:54 <boegel> how do I wrap a value inside the Maybe monad so it returns Nothing is the expression fails to evaluate?
06:05:02 <shachaf> dpratt71: I don't believe it will.
06:05:06 <boegel> > return (init []) :: (Maybe [Int])
06:05:07 <lambdabot>   Just *Exception: Prelude.init: empty list
06:05:08 <saml> boegel, Nothing
06:05:14 <shachaf> boegel: You can't do that.
06:05:29 <boegel> shachaf: but, there is a way to use Maybe/return like that, no?
06:05:30 <shachaf> Well, depending on what you mean by "fails to evaluate".
06:05:33 <saml> if success then Just val else Nothing
06:05:33 * boegel was pretty sure
06:05:34 <shachaf> You can't detect _|_.
06:05:35 <dpratt71> shachaf: hmm, ok
06:05:37 <aavogt> @hackage spoon
06:05:37 <lambdabot> http://hackage.haskell.org/package/spoon
06:06:01 <boegel> shachaf: there's no way around it?
06:06:03 <shachaf> dpratt71: The behavior that you want from filter is in the spine of the list in this case, isn't it?
06:06:11 <shachaf> boegel: That's the whole point of _|_. :-)
06:06:19 <shachaf> boegel: You can detect that particular thing in IO.
06:06:26 <saml> boegel, what is meaning of "fails to evaluate" ?
06:06:27 <shachaf> But in general just don't use unsafe functions like init.
06:06:31 <saml> do you mean bottom?
06:06:41 <dpratt71> shachaf: I don't know how to answer that question
06:06:47 <saml> or it evaluates to error condition?
06:07:18 <quicksilver> boegel: the answer to your question is spoon or teaspoon, but the real answer is don't do that.
06:07:36 <Jetbeard> boegel: as a simple compromise you can just define your own wrappers around the functions that you want to use
06:07:58 <Jetbeard> maybeHead :: [a] -> Just a
06:08:02 <Jetbeard> maybeHead [] = Nothing
06:08:11 <boegel> saml: well, just like using init on an empty list
06:08:21 <saml> > init []
06:08:22 <lambdabot>   *Exception: Prelude.init: empty list
06:08:22 <Jetbeard> maybeHead x = Just (head x)
06:08:23 <shachaf> saml: init is an evil function.
06:08:34 <boegel> ok, so let me explain why I want something like this
06:08:43 <boegel> I'm writing a Haskell to that evolves Haskell programs
06:08:53 <boegel> and sometimes, it generates stuff that fails at runtime
06:09:17 <boegel> I'd like to come up with a way to make the function return Nothing if it fails, and a Double otherwise
06:09:21 <saml> can't you use error or something?
06:09:53 <aavogt> boegel: use spoon, or catch the exception more reasonably in IO
06:11:34 <saml> > let f [] = Nothing; f l = Just (init l)  in f []    -- boegel
06:11:35 <lambdabot>   Nothing
06:12:15 <boegel> saml: I'm afraid it's more complex than that, I can't handle eveyr possible case of failure manually
06:12:19 <boegel> @hoogle spoon
06:12:20 <lambdabot> No results found
06:12:26 <saml> what's failing condition?
06:12:39 <aavogt> @hackage spoon boegel
06:12:39 <lambdabot> http://hackage.haskell.org/package/spoon boegel
06:12:54 <saml> you can make your functions total. if you can't, maybe use Monad
06:12:59 <dpratt71> a bit disappointed; perhaps I'm headed in the wrong direction, but adding parallelism to a Haskell program is harder than I thought it would be :(
06:13:00 <quicksilver> boegel: generating haskell at runtime does, unfortunately, hit these little issues
06:13:04 <boegel> aavogt: yeah, that seems like what I want
06:13:04 <quicksilver> saml: no, he can't.
06:13:11 <quicksilver> saml: not if he doesn't have control over the code.
06:13:24 <saml> i see. boegel you can't.
06:13:35 <boegel> saml: well, with spoon I can
06:13:40 <quicksilver> boegel: to solve it properly you need to be like GHCi and have full control of the execution envionrment.
06:13:44 <saml> okay. do it
06:13:44 <quicksilver> but spoon may be an acceptable hack.
06:13:53 <quicksilver> boegel: beware of non-termination
06:13:59 <boegel> saml: I just need it to (safely) evaluate the code I generate, it won't actually be part of the code
06:14:07 <shachaf> quicksilver: What! Spoon doesn't handle non-termination?
06:14:12 <saml> maybe look at how lambdabot does
06:14:14 <boegel> quicksilver: yeah, I'm trying to avoid that by disallowing stuff like repeat and cycle
06:14:25 <saml> i think lambdabot executes in a sandbox
06:14:37 <saml> in Java terminology, you need WhiteboardPattern
06:14:41 <quicksilver> lamdbabot executes in a fresh process
06:14:49 <quicksilver> and uses OS facilities to kill it if it runs too long.
06:15:09 <shachaf> boegel: That's not going to save you from non-termination in arbitrary Haskell programs. :-)
06:15:35 <saml> boegel, make your program generate always terminating programs
06:15:42 <saml> generated program doesn't have to be turing complete, right?
06:15:43 <boegel> shachaf: I know
06:16:03 <boegel> saml: that's what I'm trying now, i.e. disallow function like cycle, repeat, ...
06:16:08 <shachaf> Or just run a termination checker on them.
06:16:16 <boegel> saml: for now, I'm only handling one-line programs
06:16:17 <shachaf> @hackage halting-solution
06:16:17 <lambdabot> http://hackage.haskell.org/package/halting-solution
06:16:21 <boegel> shachaf: oh, nice
06:16:34 * shachaf feels bad now. :-(
06:16:36 <saml> 404 is so nice
06:17:17 <boegel> shachaf: meh, should have known :)
06:17:30 <saml> yah i'm a troll
06:17:33 * boegel smacks himself in the head
06:17:34 <mokus> @faq can Haskell solve the halting problem?
06:17:35 <lambdabot> The answer is: Yes! Haskell can do that.
06:17:56 <geheimdienst> @faq can haskell solve the halting problem through use of missiles?
06:17:57 <lambdabot> The answer is: Yes! Haskell can do that.
06:18:38 <shachaf> @faq Can Haskell solve the halting and catching fire problem?
06:18:38 <lambdabot> The answer is: Yes! Haskell can do that.
06:18:38 <boegel> anyway, spoon/teaspoon will be useful for me, thx
06:19:06 <Jetbeard> @faq can Haskell go fetch me a pair of socks?
06:19:06 <lambdabot> The answer is: Yes! Haskell can do that.
06:19:08 <shachaf> @ty unsafeHaltAndCatchFire
06:19:09 <lambdabot> IO ()
06:19:28 <mokus> @src unsafeHaltAndCatchFire
06:19:29 <lambdabot> Source not found. Where did you learn to type?
06:19:36 <Jetbeard> @faq can Haskell go fetch me a pair of socks?
06:19:37 <lambdabot> The answer is: Yes! Haskell can do that.
06:20:04 <shachaf> Silly Haskell people, calling it "unsafe". It's in IO, so there's nothing unsafe about it.
06:20:06 <arcatan> I wonder if there are many Haskell programmers called Haskell
06:20:43 <erus`> > data a = b | c b
06:20:44 <lambdabot>   <no location info>: parse error on input `data'
06:22:09 <erus`> guys is there a way todo that?
06:22:32 <Jetbeard> what are you trying to do?
06:22:42 <Jetbeard> > data A = B | C A
06:22:42 <lambdabot>   <no location info>: parse error on input `data'
06:22:55 <aavogt> you need to capitalize a,b,c at least
06:22:56 <Jetbeard> uh, lambdabot is no longer our friend
06:23:41 <erus`> data Statement = Expression | Function Bool Var [Var] Expression deriving (Show)
06:23:48 <erus`> it says expression not in scope
06:24:03 <shachaf> erus`: It would also say that True is not in scope, if you'd said "True".
06:24:11 <shachaf> But you said Bool. Expression isn't a type.
06:24:19 <Jetbeard> data Statement = Expression | Function Bool Var [Var] Statement deriving Show
06:24:23 <shachaf> Also that's a pretty weird AST you've got there.
06:24:27 <erus`> ah ok
06:24:40 <erus`> i just have to make sure its an expression somehow
06:24:42 <kstt> can lambdabot usually evaluate data declarations ?
06:25:16 <Jetbeard> > data Nat = Zero | Succ Nat
06:25:17 <lambdabot>   <no location info>: parse error on input `data'
06:25:23 <shachaf> kstt: Only when the moon is full.
06:25:26 <erus`> shachaf: its exported (name, type) [arguements name , type]
06:25:42 <erus`> where export is like public
06:25:46 <kstt> @faq can haskell fill the moon ?
06:25:47 <lambdabot> The answer is: Yes! Haskell can do that.
06:25:56 <Jetbeard> > let data Nat = Zero | Succ Nat deriving Show in Succ Zero
06:25:57 <lambdabot>   <no location info>: parse error on input `data'
06:26:03 <shachaf> kstt: But only Haskell-including-data-declarations.
06:26:06 <shachaf> So you're kind of stuck.
06:26:29 <kstt> I see
06:26:45 <Jetbeard> @faq can Haskell give a bijection between the natural numbers and the real numbers?
06:26:45 <lambdabot> The answer is: Yes! Haskell can do that.
06:27:09 <kstt> lazily, I'm sure it can
06:27:13 <shachaf> At least it can give a bijection between Int and Float. :-)
06:27:16 <Jetbeard> (One of my functional programming exam paper questions essentially asked you to do exactly that in Haskell)
06:27:37 <Jetbeard> it wanted you to generate a list containing all lists of integers
06:28:07 <kstt> Given that one set is discrete and the other is continuous aleph0, that would be a real performance ;)
06:28:18 <shachaf> Finite and infinite lists?
06:28:28 <Jetbeard> yes
06:28:31 <aavogt> erus`: http://hpaste.org/48993 ?
06:28:38 <Jetbeard> hmmm actually, no
06:28:54 <EvanR> a list of all lists of integers, including infinite ones ;)
06:28:54 <aavogt> oops, the part that  C (C B)  doesn't typecheck got cut off
06:29:02 <Jetbeard> the specification was 'all lists of integers'
06:29:14 <Jetbeard> but the model solution was indeed 'all finite lists of integers'
06:29:15 <aavogt> you can add other parameters to B and C
06:29:19 * shachaf wonders what they had in mind there.
06:29:28 <shachaf> Oh, I know:
06:29:32 <shachaf> > permutations [1..]
06:29:33 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
06:29:36 * aavogt isn't sure how this data A b differs from just using two data types
06:29:37 <shachaf> Tada!
06:29:42 <Jetbeard> hahahahahaha shachaf
06:29:53 <mokus> that doesn't contain [1]
06:29:57 <EvanR> doesnt that miss finite lists
06:29:58 <shachaf> Oh, yes.
06:30:18 <EvanR> and repeat 1
06:30:19 <shachaf> > concatMap permutations . subsequences $ [1..]
06:30:24 <lambdabot>   [[],[1],[2],[1,2],[2,1],[3],[1,3],[3,1],[2,3],[3,2],[1,2,3],[2,1,3],[3,2,1]...
06:30:29 <shachaf> Oh, yes, I guess it's a little more complicated than that.
06:30:51 <Jetbeard> Let me find the paper.
06:32:34 <EvanR> shachaf: zero is not an integer anymore? ;)
06:32:57 <earthy> integer, yes
06:33:03 <shachaf> EvanR: OK, OK, I get it!
06:33:04 <Jetbeard> EvanR: no, it was voted out
06:33:09 <earthy> natural number? depends. ;)
06:33:22 <shachaf> EvanR: I promise you that if you walk far enough down the list, you'll get a 0.
06:33:25 <shachaf> In practie.
06:33:25 <earthy> http://en.wikipedia.org/wiki/Natural_number :)
06:33:31 <EvanR> 1000BC called they want their fear of zero back
06:33:55 <shachaf> > :([0]) 0
06:33:56 <lambdabot>   <no location info>: parse error on input `:'
06:34:00 <EvanR> lol
06:34:03 <shachaf> > (:[0]) 0
06:34:04 <lambdabot>   [0,0]
06:34:49 <EvanR> the zero eater operator
06:35:51 <Phyx-> when ghc sees {-# LANGUAGE CPP #-} it fills in __LINE__ and __FILE__ right?
06:36:06 <earthy> it should, phyx-
06:36:14 <Igloo> cpp fills them in
06:36:21 <Phyx-> good, thanks :)
06:36:29 <earthy> well, to be more exact, ghc should call cpp to have them filled in ;)
06:37:01 <Phyx-> Igloo: does it use cpphs or the cpp in its distribution? or are they the same?
06:37:13 <Igloo> It uses cpp by default
06:38:05 <Phyx-> ah ok, :) Adding a fake stack and using __LINE__ and __FILE__ to keep track
06:45:56 <erus`> guys can you help me with some theory :)
06:46:15 <erus`> i need to parse some sourcecode with indents for scoping
06:46:49 <erus`> i have parsed all the individual lines and got their indent and tokens
06:47:30 <erus`> now how do i recursively parse the parents and children...
06:48:17 <erus`> ooo maybe i just needed to vocalize it :)
06:48:26 <quicksilver> #haskell is the best teddybear
06:50:27 <Botje> ... in stereo!
06:52:45 <hpaste> erus` pasted “long winded?” at http://hpaste.org/48995
06:53:11 <erus`> is that function allready implemented in the platform?
06:53:17 <Phyx-> if #haskell was a teddybear, no one would hug it
06:54:37 <luite_> trapped in hugging monad
06:54:40 <frerich> erus`: I think your function is basically 'map parseStatement'
06:54:48 <Botje> erus`: uh, isn't that just map parseStatement?
06:55:08 <erus`> a statement may be more than 1 line
06:55:40 <erus`> whoops
06:55:41 <frerich> erus`: Do you account for that already? It seems you hardcoded one line there ("drop 1 ls")
06:55:59 <erus`> no just adding that
07:05:52 * hackagebot dependent-sum 0.1 - Dependent sum type  http://hackage.haskell.org/package/dependent-sum-0.1 (JamesCook)
07:06:53 * hackagebot dependent-map 0.1 - Dependent finite maps (partial dependent products)  http://hackage.haskell.org/package/dependent-map-0.1 (JamesCook)
07:07:24 <ocharles> If I have something that is Model (Maybe Book), and something that is (Book -> Model Book), how can I compose them? At first I thought >>=, but that doesn't work because my function would have to take Maybe Book. My instinct says there should be something that can lift that function into the Maybe monad, but I'm not sure how to do it
07:08:18 <ocharles> Maybe this is something like (fmap . fmap)
07:08:27 <shachaf> ocharles: Is Model just a newtype over Maybe?
07:08:28 <ocharles> but I admit, I'm playing guessing games a bit :)
07:08:31 <Cale> You have to pattern match away the Nothing case
07:08:53 <ocharles> Cale: but the maybe monad can handle that for me (because if it's Nothing, I just want it to stay as Nothing)
07:08:55 <ocharles> shachaf: nope
07:09:01 <Cale> uhhh
07:09:12 <Cale> But the result of Book -> Model Book doesn't have a Maybe in it
07:09:20 <Cale> So "staying as Nothing" isn't an option
07:09:23 <ocharles> Right
07:09:26 <quicksilver> I presume he's happy if the final result is Model (Maybe Book)
07:09:33 <ocharles> quicksilver: correct
07:09:34 <Cale> You want to get Model (Maybe Book), oka
07:09:40 <shachaf> Oh, I misunderstood.
07:10:12 <quicksilver> but you still need not_quite_join :: Model (Maybe (Model x)) -> Model (Maybe x)
07:11:19 <Cale> do mb <- x; case x of Nothing -> return Nothing; Just b -> f b
07:11:53 * hackagebot prim-uniq 0.1 - Opaque unique identifiers in primitive state monads  http://hackage.haskell.org/package/prim-uniq-0.1 (JamesCook)
07:12:26 <ocharles> hmm
07:12:37 <ocharles> Cale: well I'd probably use the maybe function for that
07:12:50 <ocharles> but I was hoping that I could avoid that
07:16:03 <Phyx-> ah, mauke is gone, now i can paste my pastebin links :)
07:18:24 <sanjoyd> System F is strongly normalizing, right?
07:18:58 <fenris_kcf> what am I doing wrong here? http://codepad.org/4VotCEHi
07:19:32 <zygoloid> sanjoyd: haskell is turing-complete, so i suspect not
07:19:36 <sipa> sanjoyd: i doubt that, strongly normalizing implies not turing complete
07:19:52 <hpaste> ocharles pasted “Loading books” at http://hpaste.org/48996
07:20:00 <sanjoyd> sipa: zygoloid that /is/ my doubt. http://en.wikipedia.org/wiki/System_F
07:20:03 <ocharles> ok, Cale/quicksilver - that's what I've ended up with
07:20:06 <ocharles> feels a bit messy though!
07:20:14 <zygoloid> although i'm not sure whether haskell (without ghc extensions) can actually be compiled to System F
07:20:14 <sanjoyd> The page says that it is strongly normalizing.
07:20:28 <sanjoyd> zygoloid: that is the only explanation.
07:20:40 <Axman6> fenris_kcf: what error are you getting?
07:20:41 <sanjoyd> Which brings me to my question: what does Haskell have that System F does not?
07:20:41 <zygoloid> System FC presumably isn't strongly-normalizing
07:20:52 <fenris_kcf> the same one that is shown on codepad
07:21:01 <Axman6> fenris_kcf: oh i know, foo isn't a fiunction from the class Derivated
07:21:11 <Axman6> you need to define bar, not foo
07:21:12 <fenris_kcf> not directly
07:21:23 <Axman6> no, it's not a part of Derivated at all
07:21:23 <sipa> sanjoyd: hmm, maybe System F does not include a fix primitive
07:21:25 <tgeeky_> any new Functional Pearls published in the last month or so that anyone knows about?
07:21:29 <fenris_kcf> but since Derivated is inherited from Base
07:21:37 <sipa> can you type the Y combinator in System F?
07:21:41 <Axman6> to define foo, you need to make an instance for Base Concrete
07:22:11 <fenris_kcf> hmm, ok. i'll try that
07:22:13 <Axman6> fenris_kcf: no, instance Foo a => Bar a where... says that to be in Bar, the type must first implement Foo
07:22:23 <sanjoyd> sipa: that could be it; since I don't think you can write a fix with just lambdas.
07:22:36 <Axman6> @src Num
07:22:36 <lambdabot> class  (Eq a, Show a) => Num a  where
07:22:36 <lambdabot>     (+), (-), (*)           :: a -> a -> a
07:22:37 <lambdabot>     negate, abs, signum     :: a -> a
07:22:37 <lambdabot>     fromInteger             :: Integer -> a
07:22:41 <Cale> ocharles: Well, your 'helper' is the same as Data.Traversable.traverse
07:22:50 <Cale> So, we can do that
07:22:52 <Axman6> to be a member of the Num class, the type must irst implement Eq and Show
07:22:57 <sipa> sanjoyd: sure you can, the Y combinator does just that in untyped lambda calculus
07:23:06 <fenris_kcf> ah
07:23:06 <sipa> sanjoyd: the problem is that it cannot be typed
07:23:15 <sanjoyd> sipa: you can't have a non-recursive fixed pt. combinator.
07:23:24 <sanjoyd> AFAIK.
07:23:24 <ocharles> Cale: yay! I knew there must be something that I was replicating :)
07:23:41 <sanjoyd> s/non-recursive/non-recursive typed/
07:23:47 <Axman6> fenris_kcf: there's no inheritance in Haskell btw
07:23:55 <Cale> sure you can
07:24:18 <Cale> The Y combinator can be typed if you have fancy enough types
07:24:32 <quicksilver> zygoloid, sanjoyd : System F being strongly normalising just means that *type-checking* terminates.
07:24:32 <sanjoyd> Cale: how?
07:24:48 <sipa> quicksilver: no
07:24:55 <quicksilver> it doesn't mean that all programs in a language which use System F-types must terminate.
07:24:57 <Cale> one sec, I'll write it
07:25:03 <fenris_kcf> thank you, Axman6. it works
07:25:24 <sipa> quicksilver: from wikipedia, "As a term rewriting system, System F is strongly normalizing."
07:25:29 <quicksilver> yes.
07:25:30 <sipa> that is definitely about the value level
07:25:37 <sipa> not the type level
07:25:44 <quicksilver> of a different system :P
07:25:52 <quicksilver> those terms are haskell types.
07:26:06 <sipa> Various systems of typed lambda calculus including the simply typed lambda calculus, Jean-Yves Girard's System F, and Thierry Coquand's calculus of constructions are strongly normalizing.
07:26:10 <sipa> A lambda calculus system with the normalization property can be viewed as a programming language with the property that every program terminates.
07:26:11 <quicksilver> (ignoring the the details that haskell types aren't exactly system F)
07:26:19 <zygoloid> quicksilver: d'oh :)
07:26:20 <sanjoyd> I thought System F's type system was undecidable.
07:26:34 <quicksilver> the term rewriting you're talking about there is the production and elimination of types.
07:26:40 <quicksilver> not the evaluation of programs.
07:26:45 <sipa> quicksilver: i doubt that
07:27:10 <Saizan> sanjoyd: only type inference of curry-style terms is undecidable
07:27:19 <joe6>  have a frustrating issue: i am opening up a bunch of files, reading some data and working on it. i get this error: *** Exception: Prelude.read: no parse
07:27:29 <sipa> Cale: can a Y combinator be typed in pure System F?
07:27:32 <quicksilver> sipa: I'm sorry that you have doubts.
07:27:34 <joe6> and I have no idea what is causing it or where it is coming from.
07:27:42 <joe6> due, to haskell's laziness.
07:27:55 <Cale> newtype Rec a = In { out :: Rec a -> a }
07:28:00 <Cale> y :: (a -> a) -> a
07:28:00 <Cale> y = \f -> (\x -> f (out x x)) (In (\x -> f (out x x)))
07:28:02 <Saizan> quicksilver: i think sipa is right, you can't have general recursion in System F unless you add fix as a primitive
07:28:04 <joe6> When I printed the data with a putStrLn, no errors.
07:28:05 <erus`> joe6: the line with read?
07:28:23 <joe6> i have no idea which line it is failing.
07:28:25 <joe6> on
07:28:33 <erus`> joe6:  paste all of your code
07:28:50 * sanjoyd tries to see what Cale did.
07:28:52 <joe6> erus`: is there an overloaded read with a better error message?
07:29:09 <joe6> atleast, the context on where it is failing.
07:29:12 <erus`> theres reads
07:29:16 <Saizan> and i'm pretty sure you can't encode Rec in System F
07:29:16 <erus`> which is safe read
07:29:37 <joe6> erus`, thanks that is what I need.
07:29:42 <joe6> @hoogle reads
07:29:42 <lambdabot> Prelude reads :: Read a => ReadS a
07:29:43 <lambdabot> Text.Read reads :: Read a => ReadS a
07:29:43 <lambdabot> Prelude type ReadS a = String -> [(a, String)]
07:29:55 <joe6> > :t reads
07:29:57 <lambdabot>   <no location info>: parse error on input `:'
07:29:57 <quicksilver> I think I must be using some words differently to everyone else then.
07:30:09 <Cale> Of course, this relies on type-level recursion to re-claim value-level recursion.
07:30:47 <ocharles> Is there anything that is: (a -> m b) -> m [a] -> m [b] ?
07:30:56 <ocharles> hoogle doesn't seem to show anything that has that
07:31:05 <magicman> @hoogle (a -> m b) -> m [a] -> m [b]
07:31:06 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
07:31:06 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
07:31:06 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
07:31:17 <magicman> It gets close with mapM, though.
07:31:20 <Saizan> ?type \ f xs -> mapM f =<< xs
07:31:21 <ocharles> it does, yea
07:31:21 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m [a] -> m [b]
07:31:31 <ziman_> :t ap mapM
07:31:32 <lambdabot> forall a (m :: * -> *) b. (Monad m) => ((a -> m b) -> [a]) -> (a -> m b) -> m [b]
07:31:32 <ocharles> ?type (=<<)
07:31:33 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
07:31:35 <djahandarie> You can have recursive types and still have strong normalization in System F.
07:32:22 <Cale> let y = \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x))) in y (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
07:32:24 <Cale> > let y = \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x))) in y (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
07:32:26 <lambdabot>   3628800
07:32:27 <Saizan> sure, some of them
07:32:43 <Saizan> (they are encodable afterall)
07:32:45 <sipa> so, to summarize: pure System F is strongly normalizing, and thus turing complete. The addition of either recursive types or a fix operator (both present in Haskell) change that.
07:32:50 <Cale> :t let y = \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x))) in y
07:32:50 <lambdabot> forall a. (a -> a) -> a
07:32:55 <shachaf> Cale: Did you just cheat?
07:33:04 <Cale> cheat?
07:33:06 <Saizan> sipa: you meant "and thus _not_ turing complete"?
07:33:08 <shachaf> With lambdabot.
07:33:11 <shachaf> Or was that there all along?
07:33:15 <sipa> Saizan: indeed, not turing complete
07:33:20 <Cale> I put InR and outR in L.hs a long long time ago
07:33:24 <shachaf> Oh.
07:33:51 * shachaf wonders what else is lurking in there.
07:33:55 <Cale> :t Branch
07:33:56 <lambdabot> forall a. a -> Bin a -> Bin a -> Bin a
07:33:59 <Cale> :t Tip
07:34:00 <lambdabot> forall a. Bin a
07:34:07 <Cale> :t In
07:34:08 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
07:34:17 * sanjoyd gets it now.
07:34:24 <Cale> > describeSequence [1,1,2,3,5,8]
07:34:27 <djahandarie> Saizan, you can have /unrestricted/ recursive types in System F and still be strongly normalizing.
07:34:28 <lambdabot>   mueval-core: Time limit exceeded
07:34:30 <Cale> aww
07:34:38 <Cale> right, oeis is brokened
07:34:40 <djahandarie> It's just a matter of tweaking the elimination rules.
07:34:46 <djahandarie> Rather than the introduction rules.
07:34:52 <Cale> cake
07:34:54 <Cale> > cake
07:34:56 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
07:35:04 <shachaf> Oh, L.hs is public.
07:35:05 <Saizan> djahandarie: link?
07:35:11 <shachaf> Well, a version of it.
07:35:16 <djahandarie> @google Supporting Unrestricted Recursive Types
07:35:19 <lambdabot> http://zhaozhong.home.comcast.net/~zhaozhong/mu.pdf
07:35:19 <lambdabot> Title: Supporting Unrestricted Recursive Types
07:36:07 <shachaf> > fromChurch 5 ('x':) "a"
07:36:08 <lambdabot>   Not in scope: `fromChurch'
07:36:16 <shachaf> > fromChuch 5 ('x':) "a"
07:36:17 <lambdabot>   Not in scope: `fromChuch'
07:36:27 <Saizan> but i guess if you have to somehow separately prove that your recusions over them is terminating it's fine
07:36:37 <shachaf> Oh, wait, those are just @lets that were checked into darcs.
07:36:55 <shachaf> lambdabot is such a huge kludge.
07:37:51 <Cale> Indeed
07:38:29 <fryguybob> @vixen are you a kludge?
07:38:30 <lambdabot> i truely am
07:38:32 <Axman6> would be nice to see a rewrite of lambdabot to make it much nicer
07:38:55 * shachaf joined #haskell not that long after the big lambdabot writing effort.
07:39:10 <shachaf> At least, so I'm guessing. Because everything worked back then. :-)
07:40:14 <erus`> yeah and put it on git :)
07:41:42 --- topic: '["Paste code/errors: http://hpaste.org/new/haskell ", "Haskell Platform 2011.2: http://is.gd/dCGPn", "GHC 7: http://is.gd/hb8vE", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/", "admin and spam issues: #haskell-ops"]'
07:41:42 --- topic: set by mauke!~mauke@p3m/member/mauke on [Sat Jun 11 05:12:19 2011]
07:41:42 --- names: list (clog colbseton` DevHC zztr mpiechotka vjn melle frederick jonkri preflex mauke flonum iratsu SyntaxNinja gemelen sonnym Chaze archone aninhumer dolio joseph_ path[l] syoyo_ Lemon geheimdienst ramusara perspectival tibbe simonmellor Shammah raichoo wli BigBlackDog julmuri dylukes edon macUzer jlaire msieradzki BlankVerse sritchie copumpkin elliotstern Younder poisonarms rovar_ jaspervdj DanC_ PhilRod_ gbeshers orbital_fox nightdenial X-Scale Peaker)
07:41:42 --- names: list (mbernstein erg0t Dahak ukd1_b xkb soiamso zmv jmreardon fryguybob dpratt71 rprije empity lokydor lucian tncardoso petermw Itkovian erus` HugoDaniel Argue erikde kakos kstt laar stobix stianhj jem777 linduxed ]OLI[ sheeple lysgaard mekeor araujo geoffhotchkiss ixzkn balor Phyx- littlebobby setmeaway Nisstyre neurogeek||m Draconx mjo Cale Octal_ ketil lopex hydo hackagebot FalkoPeters hrehf joeytwiddle ceii fusion5_ lsthemes cheater__ magicman adimit_away)
07:41:42 --- names: list (Muad_Dibber_ Eduard_Munteanu DustyDingo Evious [[zz]] dfeuer_ ormaaj_ Draconxx twanvl_ FUZxxl aculich fxr `0660 rgrinberg_ kaini tomh- bo0ts__ sagex_ alpounet waterlaz_ kolmodin iago owst fenris_kcf qz dschoepe ior3k azaq23 gfarfl Jetbeard jeltsch mv--_ jejansse notostraca Nimatek tromp Snufsen insomniaSalt djl agundry mrtimuk ahihi2 Pathin iFire boegel negaduck rtharper_ hammi Veid sshc k0ral vmil86 A1kmm ChongLi novas0x2a SmashLampjaw pikhq_ Palmik)
07:41:42 --- names: list (dreixel dleslie zul_netbsd The_third_man jsgf mustelo ousado JaffaCake sShintah kish yitz Bfv9000 k3yb1n otto_s vili ps-auxw EEVIAC neurocyte noblethrasher MaskRay Lajla kaito_ neaer gienah d2biG kqnr siracusa Niedar theorbtwo peterhil Axman6 cubi bl4ck rtharper yip uu1101 Eelis eno kelvie_ mwc shachaf noam sp3ctum dankna cebewee Harbinger Modius clsmith rekahsoft kytibe tgeeky_ Megant wormphlegm Philippa drdo Favonia pi8027 yell0 brixen wto mafs b52)
07:41:42 --- names: list (taruti anonymo3 EvanR trez matthew-_ ToRA zaero sanjoyd pen16 lusory_ Amadiro joe6 jonafan augur psychicist_ mattp_ jssanders ibid fall_ Zeiris_ Draggor parcs thorkilnaur__ erk_ QtPlatypus cynick tswett_ almostsix etpace_ mrd gdsx_ CindyLinz peddie cyanoacry blackrain sunfun xinming deggis milli ddarius gwern tsanhwa minsa jcp hiredman Cthulhon nyingen ahf dkasak _1amzave orbitz derrida bbee2 Nalo helgikrs2 saiam janne ion opqdonut perlite xenocryst nus)
07:41:42 --- names: list (sajkr hargettp_ anders^^ alios dbpatterson norm2782 vold dropdrive Zephyrus trygvis zorkon olsner RSchulzM poucet dogmaT_ jimmy1980 saurik bradwright liesen gdoteof electrogeek sordina2 jmcarthur tensorpudding kniu ngochai Raku^ ivan devn Raynes elliottcable tessier_ Yahovah_ MasseR pingveno Gracenotes kaol mike1703 mattam [mth]_ int-e fihi09`` luite_ dmwit amiri_ rakete_ Sunhay_ ziman_ MacCoast- plat0 stuartmackie ray descender nowhereman monochrom)
07:41:42 --- names: list (PreciousMetals Cadynum fumbles takamoron towynlin Vulpyne osfameron Dunearhp mxweas liyang DigitalKiwi jbauman Maxdamantus Cerise profmakx ville tafryn pesco wisemanby digicyc flamingspinach DrSyzygy helino rothwell obiwahn scsibug mrdomino accel jlewis jrk_ ve sidek cap10morgan Dashkal monokrome jrick bqf xarch drmegahertz naota alfa_y_omega Nereid proq mee gentz yahooooo pyrtsa dsouza stepnem nihtml eyck fasta Martty idoru Somix blomqvist geekounet willb)
07:41:42 --- names: list (jix xiphiasx Starfire Vorpal TylerE tomku serialhex cpa sm__ neurogeek ido appamatto _habnabit wyfrn felher alip obcode nlogax Obfuscate dcoutts_ Astro Khisanth Baughn alek_br Botje micahjohnston frode Boney robinbb Nanar comak eZet SimonRC mm_freak angstrom ClaudiusMaximus Will| reacocard dju wagle Nightwolf ricky gereedy ski twofish thetallguy Iceland_jack samek Veinor palmje frerich stroan OnionKnight pettter incandenza MK_FG tew88 copton CosmicRay _mpu)
07:41:42 --- names: list (byorgey cjay pastorn whoops akahn sirpengi chaoflow pantski davean maurer_ arkx snr_ nominolo savy_ Eliel_ absence Totramon^ ts00000 aristid hyko Choko ttvd edenc ben djanatyn jcapper_ houeland_ burp_ JHoglund_ burp` adnam xplat verement quaestor levitation[A] cizra2 Vq finnrobi Ke nazgjunk SonicvanaJr noddy raxas jayne boris`` __class__ alexsdutton arcatan froztbyte Fuco And[y] quicksilver jrockway lebastr tamiko rby Bassetts edwtjo dionoea zomg akosch)
07:41:42 --- names: list (ocharles snorble minecraftfan rndm fds drosophyllum dumael brisbin saati Belgarion_ lomeo Liskni_si manawy wolverian hzh Counter-Strike sully untwisted armence lpsmith dino- d7 welterde ciaranm cheshire-cat_ Igloo jabirali djahandarie geekosaur Boxo flux plimsoll sgronblo yottis Ornedan ixchel StoneToad McManiaC Arnar aleator lunaris mornfall joni6128 Hunner R28 waqf marchdown solidsnack idnar kalivha thoughtpolice hanDerPeder comex hvr ttblrs brett)
07:41:42 --- names: list (rfgpfeiffer lambdabot edwinb HalfWayMan Runar bremner` earthy hpc shutdown_-h_now dilinger scree snarkyboojum maloi finnomenon benmachine tridactyla inr majoh Lemmih rntz Bleadof andersk zmoazeni Laney drhodes sbok Intensity audunska aspect theclaw jd10 Gilly AnAdorableNick BrianHV rattboi cncl sunnavy Utkarsh robinsmidsrod LeNsTR freeformz smly- mlh chitragupt dom96 sohum skaar_ Clint arw__ twn EvanCarroll ccasin flazz etabot nimred kalven jyyou xale)
07:41:42 --- names: list (marienz caligula tommd liw Derander kbar felipe_ dcoutts spetrea robbert politik naneau lispy carrbs1 dcolish daed koninkje_away milkpost smop mietek companion_cube deavid lukish_ gbacon_ confound aiko suiside avocado jlouis zaphar_ps ernst gf3 hpaste srcerer gds petanqk ehamberg bs338 dqd solarus henr_k mortberg ptrf tomaw emias sipa Innominate _main_ fabjan hhulkko Mitar Aestas c1de0x @ChanServ _erik_ KitB scsibug_ Aisling zakwilson koala_man dorkitude)
07:41:42 --- names: list (rwbarton vinc Saizan absentia bd_ mrshoe silex mux dixie pr zygoloid ibt klugez karld seats shepheb guerrilla mokus Twey jml integral freiksenet Zol kosmikus osoleve legov johs ian_mi periodic EpsilonDur hellige impl szbalint zenzike ozzloy kloeri inimino davidL PHO_ erg andrewsw bezik noj)
07:49:30 <joe6> any suggestions on how I can fix this, please: http://pastebin.com/XDHfyKWa
07:49:32 <mauke> The paste XDHfyKWa has been copied to http://hpaste.org/49000
07:49:49 <joe6> this is the error: http://pastebin.com/h36FR4Gs
07:49:51 <mauke> The paste h36FR4Gs has been copied to http://hpaste.org/49001
07:51:37 <saml> hey, how can I make lambdabot echo to a channel that it's in?
07:51:45 <Cale> joe6: You want ScopedTypeVariables
07:51:55 <Cale> joe6: If you want to specify the type of reads there
07:51:57 <joe6> i am trying to add some context to the error of prelude.read : no parse
07:52:10 <joe6> is this the best way of doing it.
07:52:15 <joe6> or, is there a better way?
07:52:25 <Cale> But I don't think is should be necessary to have that local type signature?
07:52:39 <Cale> Delete the expression type signature on reads x and see if it compiles then
07:53:06 <joe6> > :t reads
07:53:07 <lambdabot>   <no location info>: parse error on input `:'
07:53:11 <joe6> this is what i get if I do not have that : http://pastebin.com/H77ynFQH
07:53:12 <mauke> The paste H77ynFQH has been copied to http://hpaste.org/49002
07:53:22 <joe6> http://pastebin.com/enr2HE4J
07:53:24 <mauke> The paste enr2HE4J has been copied to http://hpaste.org/49003
07:53:28 * djahandarie wonders why joe6 doesn't just paste to hpaste
07:53:54 <joe6> maybe I just need to add Eq?
07:56:20 <joe6> djahandarie: i have a shell function using pastebinit: alias cpc=' TMPFILE=`mktemp` && xclip -o >> $TMPFILE && pastebinit $TMPFILE | tr -d "\n" | xclip '
07:56:47 <joe6> djahandarie: if there is a utility to paste to hpaste like that, I would definitely paste to hpaste.
07:56:49 <djahandarie> Ah.
07:57:44 <joe6> djahandarie: and this in my xmonad config:  , ((mod1Mask, xK_p), spawn " TMPFILE=`mktemp` && xclip -o >> $TMPFILE && pastebinit $TMPFILE | tr -d \"\n\" | xclip ")
07:58:07 <joe6> Cale, does the error make sense to you?
07:58:17 <joe6> http://pastebin.com/Q3q9q61j
07:58:19 <djahandarie> Should poke mauke to figure out how he is automatically posting to hpaste
07:58:19 <mauke> The paste Q3q9q61j has been copied to http://hpaste.org/49004
07:58:33 <joe6> djahandarie: that would be good to know.
08:00:24 <Saizan> post requests are easy :)
08:01:18 <mm_freak> ok, i really like the approach racket and ur/web are taking to web stuff:  continuations
08:01:26 <joe6> or, do i need a Eq typeclass instance for [(a,String)]? code: http://pastebin.com/QviV2M41, error: http://pastebin.com/tVEYjwQv
08:01:30 <mauke> The pastes QviV2M41 tVEYjwQv have been copied to http://hpaste.org/49007 http://hpaste.org/49008
08:01:32 <mm_freak> isn't there any framework for haskell, which uses the same concept?
08:01:58 * hackagebot libltdl 0.1 - FFI interface to libltdl  http://hackage.haskell.org/package/libltdl-0.1 (GeoffreyMainland)
08:02:00 * hackagebot dependent-sum 0.2 - Dependent sum type  http://hackage.haskell.org/package/dependent-sum-0.2 (JamesCook)
08:02:13 <mm_freak> i like yesod, but i would give it up for the first pratically useful continuation-based web framework i find
08:03:34 <joe6> @src read
08:03:35 <lambdabot> read s = either error id (readEither s)
08:03:53 <ion> I wish
08:04:08 <joe6> @readEither
08:04:08 <lambdabot> Unknown command, try @list
08:04:13 <joe6> @src readEither
08:04:13 <lambdabot> Source not found. Just what do you think you're doing Dave?
08:04:29 <ion> Are there any Yesod developers here?
08:04:37 <benmachine> joe6: read is a method of the Read class, so it's defined differently per type
08:05:09 <joe6> benmachine, code: http://pastebin.com/QviV2M41, error: http://pastebin.com/tVEYjwQv . any suggestions, please?
08:05:09 <mauke> The pastes QviV2M41 tVEYjwQv have been copied to http://hpaste.org/49007 http://hpaste.org/49008
08:05:27 <joe6> i am trying to define my version of read which outputs some context on error.
08:05:57 <ion> readEither would be something like readEither = case reads of (a,""):_ -> Right a; _ -> Left "no parse"
08:05:59 <benmachine> joe6: use case-matching rather than ==
08:06:24 <benmachine> you will probably find it helps
08:06:24 <joe6> benmachine: ok, thanks. will try that.
08:06:31 <joe6> ion, thanks.
08:06:45 <benmachine> joe6: the problem that you're having at the moment is that in reads x == [], the behaviour of reads depends on its type
08:06:48 <benmachine> because it comes from a typeclass
08:06:53 <benmachine> but you can't tell from that expression what type it is
08:07:15 <ion> Whoops, i left the argument out of the example.
08:07:19 <benmachine> reads x could be [(Int,String)] or [(Bool,String)] or anything
08:07:43 <benmachine> well, anything Read a => [(a,String)]
08:07:43 <joe6> benmachine: that worked. thanks. http://pastebin.com/iC5BkJ4C
08:07:45 <mauke> The paste iC5BkJ4C has been copied to http://hpaste.org/49009
08:08:02 <benmachine> joe6: use pattern-matching instead of fst and head
08:08:06 <benmachine> I mean, fst and head work
08:08:11 <benmachine> but pattern-matching is usually considered nicer
08:08:18 <joe6> ok, will do. thanks
08:08:20 <benmachine> also, you don't need Eq a anymore
08:08:28 <joe6> yes, will clean it up.
08:08:40 <ion> joe6: That doesn’t work correctly for e.g. myRead "42foo" :: Integer
08:08:56 <benmachine> ion: depends what behaviour you want :P
08:09:07 <ion> joe6: You might want to do this: case reads x of (a,""):_ -> a; _ -> error ..
08:09:15 <benmachine> you mgiht do
08:09:21 <ion> And why is my compose key broken? :-P
08:09:34 <benmachine> you might want to do case reads x of [(a,s)] | all isSpace s -> a; _ -> error ...
08:10:29 <joe6> benmachine: better? http://pastebin.com/FsAVzp7B
08:10:30 <mauke> The paste FsAVzp7B has been copied to http://hpaste.org/49010
08:10:52 <benmachine> joe6: I think so, yes
08:11:02 <ion> That doesn’t handle a non-empty remaining string in the tuple at all.
08:11:02 <joe6> ion, ok, thanks. will follow your idea.
08:11:41 <benmachine> joe6: there are lots of different ways of handling the remaining string in the tuple, you have to decide what you think is best
08:11:47 <joe6> ion, i like your idea. thanks will follow that.
08:13:26 <ion> There are also two main ways to handle multiple alternative matches (which aren’t seen with any Prelude types, i think). Often you can just ignore them, ‘(a,""):_’, but in some cases you might want a unique match, ‘(a,""):[]’ or ‘[(a,"")]’.
08:17:24 <joe6> ion, this is what I ended up with: http://pastebin.com/quA53ph3
08:17:25 <mauke> The paste quA53ph3 has been copied to http://hpaste.org/49011
08:19:16 <Lemon> what does "impredicative" mean?
08:27:37 <mekeor> what do you think about Erlang compared to Haskell?
08:28:51 <Tomsik> Dynamically typed, horrible syntax
08:29:01 <mekeor> :)
08:29:02 <Tomsik> but seems that it works for some people pretty well
08:29:28 <mekeor> i think Erlang's garbage-collector and concurrency is a very big advantage.
08:29:32 <Tomsik> It does its job well, being distributed and concurrent that is
08:29:43 <Axman6> Tomsik: the main benefit it has over haskell is easy distribution over a network, and work is being done to make that work in haskell too
08:29:58 <mekeor> but Erlang is too much focused on network-stuff, afaik, and the syntax is, as you said, horrible, yep :)
08:30:06 <Axman6> haskell's threading is more efficient than erlang's anyway in my experience
08:30:30 <Tomsik> I heard that there is a huge issue with Haskell GC when it comes to being distributed
08:30:36 <Axman6> one feature i like a lot in erlang is the bit syntax
08:30:53 <Axman6> Tomsik: why would that be?
08:30:55 <Tomsik> That it's like HALT! Now one GC thread does /anything/.
08:30:58 <mekeor> Axman6: well, i dunno erlang yet, but afaik concurrency is very simple in erlang, isnt it?
08:31:10 <Axman6> mekeor: yes, but it
08:31:17 <Axman6> it's just as simple in haskell
08:31:24 <Axman6> and much nicer imo
08:32:13 <mekeor> so, in your eyes, Axman6, erlang has no significant advantages over haskell?? rly?
08:32:31 <mekeor> actually, that'd be good for me, since i already started to learn haskell :D
08:32:32 <Axman6> only easy distribution and bit syntax
08:32:47 <mekeor> whats "bit syntax"?
08:32:50 <Axman6> the lack of types makes is a non-starter for me
08:33:18 <mekeor> and btw, does erlang use monades, too?
08:33:24 <Axman6> it lets you inspect bitstreams at the bit level, making ti extremely easy and efficient to write low level code for things like decoding codecs
08:33:29 <Axman6> no
08:33:33 <Axman6> well, maybe
08:33:34 <mekeor> instead?
08:34:07 <Axman6> monads aren't something specific to haskell, we're just the only ones who use their proper name
08:34:16 <Axman6> erlang lets you do things like IO anywhere
08:34:50 <mekeor> ic
08:35:25 <EvanR> haskell has syntactic sugar for monads and the culture is to actually use monads for stuff, writing more than zero lines of code with them. thats a big difference between haskell and other systems
08:35:59 <EvanR> turning the glass 720 degrees to say that everything in C is monadic doesnt count
08:35:59 <Axman6> well, things like LINQ in C# is a monad...
08:36:30 <Axman6> and plenty of other languages use similar practices i believe
08:36:51 <EvanR> i need to look into linq
08:37:01 <ocharles> bah, there is system-uuid and uuid packages
08:37:07 <ocharles> both providing an incomplete set of uuids
08:37:16 <ocharles> and both providing different types
08:37:34 <mekeor> Axman6: thanks
08:37:50 <joe6> which is better: http://pastebin.com/v0ZEuj7x
08:37:52 <mauke> The paste v0ZEuj7x has been copied to http://hpaste.org/49012
08:38:08 * hackagebot libltdl 0.1.0.1 - FFI interface to libltdl  http://hackage.haskell.org/package/libltdl-0.1.0.1 (GeoffreyMainland)
08:38:10 <joe6> head . tail . reverse . splitOneOf ",\n" $ contents (or) head . reverse . splitOneOf ",\n" . last . endBy "\n" $ contents
08:38:21 <Axman6> mekeor: if you need to make highly fault tolerant distributed programs, then erlang may be the way to go. but there's a lot that you give up by using erlang that you get when using haskell
08:38:32 <joe6> in the second option, I can use splitOn instead of splitOneOf
08:39:41 <C00kiemonst3r> hello
08:39:48 <ocharles> joe6: I'd probably put where penultimate = head . tail . reverse
08:40:04 <joe6> ocharles, good idea. thanks.
08:40:41 <ion> joe6: You might also want to use show in the error message: "cannot read " ++ show x
08:40:47 <ion> joe6: You might also want to avoid ‘error’. :-P
08:41:08 * hackagebot libltdl 0.1.0.2 - FFI interface to libltdl  http://hackage.haskell.org/package/libltdl-0.1.0.2 (GeoffreyMainland)
08:41:15 <C00kiemonst3r> can you guys help me on a newbie question?
08:41:29 <Axman6> C00kiemonst3r: not if you don't ask the question =)
08:41:30 <ocharles> C00kiemonst3r: ask away
08:41:34 <C00kiemonst3r> http://codepad.org/JoqAtcTU
08:41:36 <sshc> luite_: Is hint sufficient for carefully analyzing the interpreted code or its AST?  Is it sufficient to run untrusted code in a sandboxed / safe environment?  Is GHC sufficient for either of these?
08:41:39 <joe6> ion: why should I avoid error?
08:41:49 <joe6> ion, any specific reason for that?
08:42:00 <C00kiemonst3r> I need to find pii' number aproximated n-times
08:42:04 <ocharles> joe6: using Either tends to be a better way to handle errors
08:42:11 <ocharles> as you then have explicit type checking of error conditions
08:42:12 <joe6> ion, this is what I have: http://pastebin.com/74hPrqVC
08:42:12 <C00kiemonst3r> and im getting a type error
08:42:14 <mauke> The paste 74hPrqVC has been copied to http://hpaste.org/49013
08:42:25 <joe6> ocharles: oh, ok. makes sense.
08:43:44 <Axman6> C00kiemonst3r: n isn't in scope inside p. I'd use sum [(-1^n') `div` (2*n' + 1) | n' <- [1..n]]
08:44:09 * hackagebot xmms2-client 0.0.7.0 - An XMMS2 client library.  http://hackage.haskell.org/package/xmms2-client-0.0.7.0 (OlegBelozeorov)
08:44:11 * hackagebot xmms2-client-glib 0.0.7.0 - An XMMS2 client library  GLib integration.  http://hackage.haskell.org/package/xmms2-client-glib-0.0.7.0 (OlegBelozeorov)
08:44:14 <C00kiemonst3r> I will try that Axman6
08:44:16 <C00kiemonst3r> thank you
08:45:07 <Axman6> C00kiemonst3r: also, that code is almost certainly not doing what you want. firstly there's no implicit type conversion in haskell, so saying that the function will return Double doesn't make it return a double
08:46:03 <Axman6> and I'm not sure the code i gave is what you want, because p may be defined as a function of the input n, or you may have wanted to use the n from inside the list comprehension
08:46:11 <Peaker> Lemon: did you get your answer about impredicative?
08:46:23 <Lemon> Peaker, no.
08:46:32 <Axman6> C00kiemonst3r: it would make life a lot easier if you explained what the code is supposed to do
08:47:05 <C00kiemonst3r> I need to find number of pii , computed n-times
08:47:13 <mdmkolbe> Who was it that made the comment about it being better for a compiler to have lots of little bullets in its gun?  I thought it was Simon PJ but my google-fu isn't good enough to find the citation.
08:47:25 <Peaker> Lemon: well, I'm not an expert -- but I think it means that type variables can scope over polymorphic types, which are type-variables too..   Without it, a type variable "a" will always substitute for a "monotype"(not-polymorphic) like "Maybe" or "Int".  With it, the type variable "a" can be substituted for "forall b. b" or other polymorphic types
08:47:51 <Lemon> oh okay
08:48:05 <Axman6> mdmkolbe: i remember hearing that in a video talk... check out malcolm wallace's videos on vimeo
08:48:26 <Peaker> Lemon: in GHC context, I think the impred. extension means that in the context of specific type variables -- type parameters to data declarations, and not elsewhere (e.g not in (->) params)
08:48:41 <mdmkolbe> Peaker: yes, that is what it means.  Basically "forall ..." isn't allows as an argument to a type constructor with a predicative system.
08:49:07 <Axman6> C00kiemonst3r: so, do you want something like: approx n = sum (map (\x -> (-1^n) `div` (2*n+1)) [1..n]?
08:49:19 <Axman6> > let approx n = sum (map (\x -> (-1^n) `div` (2*n+1)) [1..n] in approx 10
08:49:19 <lambdabot>   <no location info>: parse error on input `in'
08:49:29 <Axman6> > let approx n = sum (map (\x -> (-1^n) `div` (2*n+1))) [1..n] in approx 10
08:49:30 <lambdabot>   Couldn't match expected type `[a]'
08:49:30 <lambdabot>         against inferred type `[a1] -> [...
08:49:33 <Axman6> :\
08:49:48 <C00kiemonst3r> yes Axman6
08:49:49 <Axman6> > let approx n = sum (map (\x -> (-1^x) `div` (2*x+1))) [1..n] in approx 10
08:49:50 <lambdabot>   Couldn't match expected type `[a]'
08:49:50 <lambdabot>         against inferred type `[a1] -> [...
08:50:03 <Peaker> Axman6: why not some (.) or ($) to avoid so many ()  ? :-)
08:50:20 <Axman6> > let approx n = sum . map (\x -> (-1^x) `div` (2*x+1)) $ [1..n] in approx 10
08:50:21 <lambdabot>   -10
08:50:32 <Axman6> > let approx n = sum . map (\x -> (-1^x) / (2*x+1)) $ [1..n] in approx 10
08:50:33 <lambdabot>   Ambiguous type variable `a' in the constraints:
08:50:33 <lambdabot>    `GHC.Real.Integral a'
08:50:33 <lambdabot>   ...
08:50:39 <Axman6> bleh
08:50:57 <Axman6> > let approx n = sum . map (\x -> (-1^(toIntegral x)) / (2*x+1)) $ [1..n] in approx 10
08:50:57 <lambdabot>   Not in scope: `toIntegral'
08:51:05 <Axman6> > let approx n = sum . map (\x -> (-1^(toInteger x)) / (2*x+1)) $ [1..n] in approx 10
08:51:06 <lambdabot>   Ambiguous type variable `a' in the constraints:
08:51:06 <lambdabot>    `GHC.Real.Integral a'
08:51:06 <lambdabot>   ...
08:51:19 <Axman6> @src Num
08:51:19 <lambdabot> class  (Eq a, Show a) => Num a  where
08:51:19 <lambdabot>     (+), (-), (*)           :: a -> a -> a
08:51:20 <lambdabot>     negate, abs, signum     :: a -> a
08:51:20 <lambdabot>     fromInteger             :: Integer -> a
08:51:38 <Axman6> > let approx n = sum . map (\x -> (-1**x) / (2*x+1)) $ [1..n] in approx 10
08:51:39 <lambdabot>   -1.1808745777786027
08:51:47 <Axman6> > let approx n = sum . map (\x -> (-1**x) / (2*x+1)) $ [1..n] in approx 100
08:51:48 <lambdabot>   -2.2893173136797422
08:52:10 * hackagebot dependent-map 0.1.1 - Dependent finite maps (partial dependent products)  http://hackage.haskell.org/package/dependent-map-0.1.1 (JamesCook)
08:55:43 <C00kiemonst3r> Axman6: i.imgur.com/bAkcX.png
08:58:12 <kmill> Axman6: let approx n = sum . map (\x -> ((-1)**x) / (2*x+1)) $ [0..n] in approx 100
08:59:11 * hackagebot vision 0.0.5.0 - An XMMS2 client.  http://hackage.haskell.org/package/vision-0.0.5.0 (OlegBelozeorov)
08:59:32 <Saizan> another oleg :O
09:00:31 <Peaker> Saizan: where?
09:00:34 <Peaker> oh
09:05:25 * geheimdienst will start releasing terrible haskell code under the name "oleg kriselyuv". i'll keep you posted how many downloads it got
09:07:30 <arw__> try adding a rootkit to the installer :)
09:08:18 <mokus> all your base-4.3.1.0 are belong to us?
09:10:35 <C00kiemonst3r> hmm
09:10:37 <C00kiemonst3r> http://codepad.org/elhjbOJQ
09:10:44 <C00kiemonst3r> gave the same error :|
09:13:34 <luite_> sshc: sorry I was away
09:13:53 <luite_> sshc: you can't get the AST with hint, you can with GHC, but it's really hairy
09:14:54 <luite_> sshc: many nodes throw exceptions (error "don't evaluate this node you stupid you!"), because they contain information that can only be filled in a later stage
09:15:42 <luite_> sshc: as for untrusted code, both hint and ghc directly need additional measures to be safe
09:17:05 <luite_> sshc: you can look at how lambdabot does it with mueval though that is relatively limited, you must rely on the type system and you must know that none of the modules you use does anything unsafe
09:18:03 <luite_> so you can't use arrays unless they're bounds checked for example, and of course no unsafePerformIO
09:19:11 <luite_> sshc: once you allow things like that, ghc/hint basically give you no security whatsoever, so you need to do something else to secure things, like a limited user account, a sandboxing tool etc
09:21:37 <luite_> sshc: there will be a new extension for trusted modules in a new ghc version, that makes the mueval approach a bit more workable, but it will not remove any of its limitations
09:25:35 <tswett_> I'm looking for a Haskell database library.  It looks like the three big ones are Takusen, HDBC, and HaskellDB.  How can I choose between them?
09:26:19 <tswett_> I'm looking for something like SQLite.  A nice and simple database server.
09:27:02 <Clint> do you want to write the sql queries yourself or have a layer that generates them for you?
09:27:22 <JuanDaugherty> haskell and sqllite: cognitve dissonance
09:27:51 <JuanDaugherty> why stop there, you want nosql
09:28:05 <saati> it's web scale!
09:29:22 <erus`> whats the prettiest way to report errors down the call chain?
09:29:52 <erus`> wrap everything in a CouldFail monad or similar ?
09:30:14 <tswett_> Clint: I'd rather not deal with SQL at all.
09:30:49 <Clint> haskelldb will abstract that for you, mostly
09:31:02 <ion> Updated. http://heh.fi/haskell/functors/
09:31:03 <JuanDaugherty> *cognitive
09:31:04 <tswett_> I guess I'd prefer something that *is* a database server.
09:31:34 <tswett_> But I won't be too picky.
09:32:04 <sshc> luite_: Excellent; thanks for the information
09:33:21 <luite_> sshc: I have something that should run untrusted code from users, but it's not released yet. the code runs in a separate linux virtual machine with selinux and a special policy for the evaluator
09:34:51 <luite_> though you might be able to use something more simple if you know what files you need in advance, like seccomp
09:36:23 <sshc> luite_: Would be interesting to look at, but it's important for what I'm doing to be portable across different platforms
09:37:35 <luite_> sshc: there are things in-between, like seccomp with some helper process that runs syscalls, or intercepting syscalls with ptrace (like geordi, the C++ eval irc bot, written in haskel, does), but those are still very operating system dependent
09:38:47 <EvanR> geordi is likely a majority of the force behind new interest in haskell
09:44:17 <d7> Ugh.
09:44:25 <d7> Data.Enumerator vs. Data.Iteratee :(
09:44:32 <d7> Got 2 libraries, both want to use it.
09:44:41 <d7> Err, both want to use different ones.
09:45:33 <luite_> EvanR: might be, but I think it uses the wrong approach for securing code :)
09:49:23 <C00kiemonst3r> aprox :: Int -> Double
09:49:24 <C00kiemonst3r> aprox n = sum [ map (\x -> ((-1^x) `div` (2*x +1)))  | x<-[0..n]]
09:49:29 <C00kiemonst3r> oops
09:49:32 <C00kiemonst3r> : \
09:49:49 <C00kiemonst3r> http://codepad.org/UXiKJKo0
09:50:23 <mm_freak> is there a ready-made mapM equivalent for arrows?
09:50:32 <C00kiemonst3r> why it gave that error?
09:50:35 <C00kiemonst3r> :|
09:50:56 * tswett_ looks at that error.
09:50:57 <zygoloid> mm_freak: like \f -> (>>> arr f) ?
09:51:09 <tswett_> @type sum [ map (\x -> ((-1^x) `div` (2*x +1)))  | x<-[0..n]]
09:51:10 <lambdabot> forall a. (Integral a, Num [a]) => [a] -> [a]
09:51:26 <byorgey> C00kiemonst3r: you must explicitly convert between Int and Double, Haskell does not do automatic conversion
09:51:27 <mm_freak> :t \f -> (>>> arr f)
09:51:28 <lambdabot> forall (cat :: * -> * -> *) a b c. (Arrow cat) => (b -> c) -> cat a b -> cat a c
09:51:28 <zygoloid> @type (^<<)
09:51:29 <lambdabot> forall c d (a :: * -> * -> *) b. (Arrow a) => (c -> d) -> a b c -> a b d
09:51:41 <mm_freak> zygoloid: no, not fmap, but mapM
09:51:46 <zygoloid> ah
09:52:01 <C00kiemonst3r> byorgey: how i do that? is there any cast function?
09:52:03 <byorgey> C00kiemonst3r: also, I don't think you need the call to 'map'
09:52:08 <byorgey> C00kiemonst3r: fromIntegral
09:52:18 <tswett_> @type sum [ (-1^x) `div` (2*x +1) | x<-[0..n]]
09:52:19 <lambdabot> Expr
09:52:20 <mm_freak> i have an 'a [X] [X]' and would like to apply an arrow computation to every list element
09:52:25 <djahandarie> byorgey, you see my message earlier btw?
09:52:26 <zygoloid> mm_freak: is that possible for a general arrow?
09:52:28 <tswett_> @type \n -> sum [ (-1^x) `div` (2*x +1) | x<-[0..n]]
09:52:29 <lambdabot> forall a. (Integral a) => a -> a
09:52:30 <C00kiemonst3r> ok thank you
09:52:37 <mm_freak> zygoloid: that function seems easy to write at least
09:52:59 <micahjohnston> how do I load two files at once in ghci? when I say :l twice, the first one goes away
09:53:01 <byorgey> djahandarie: oh, something about subtyping in the kind level?
09:53:13 <byorgey> I saw it but forgot to respond
09:53:14 <zygoloid> mm_freak: do you want: a b c -> a [b] [c]?
09:53:19 <djahandarie> Ah yeah, that one. (I had actually forgotten what it was about myself)
09:53:22 <byorgey> djahandarie: but I don't think I understand the question
09:53:23 <zygoloid> i think that'd be the natural generalization of mapM
09:53:28 <mm_freak> zygoloid: yeah
09:53:38 <dylukes> micahjohnston: :m+ and :m- are your friends
09:53:41 <parcs> micahjohnston: import MyModule
09:53:43 <lysgaard> micahjohnston: If your files are modules you can do ":m + MyModule"
09:53:53 <djahandarie> byorgey, you need to deal with the boxing hierarchy somehow right?
09:53:57 <dylukes> :m switches to a specific one.
09:54:01 <dylukes> :m+ and :m- load/unload.
09:54:07 <byorgey> djahandarie: yeah
09:54:08 <zygoloid> mm_freak: that feels like it'd be unpossible without ArrowApply
09:54:20 <byorgey> djahandarie: so what's the problem?
09:54:22 <mm_freak> ok, i'll try it
09:55:29 <byorgey> djahandarie: or, I should say, what is the worry?
09:55:37 <micahjohnston> thanks guys, that worked
09:56:24 <djahandarie> byorgey, how does it interact with other stuff now that everything is collapsed? Is it entirely seperated?
09:56:26 <Saizan> zygoloid: or ArrowChoice
09:56:50 <zygoloid> Saizan: is ArrowChoice enough for an unbounded dynamic sequence of choices?
09:56:54 <micahjohnston> doesn't ArrowApply kind of take away the point of arrows?
09:57:05 <byorgey> djahandarie: I think the idea would just be to keep it separated
09:57:14 <byorgey> djahandarie: it wouldn't be extended to some kind of general subtyping mechanism
09:57:39 <byorgey> djahandarie: however, the most recent version of things is that (for now) we are not actually collapsing everything after all
09:57:44 <mm_freak> zygoloid: i think i've done it, but it needed ArrowChoice instead of ArrowApply
09:57:52 <djahandarie> lol, okay
09:57:53 <zygoloid> mm_freak: cool! :)
09:57:54 <wli> Oh, I should ask now that people are awake. Have people done polymorphic numerical linear algebra affairs that might be able to have the multiple-precision floating point arithmetic plugged into it?
09:58:01 <byorgey> it turns out that collapsing everything really complicates the equational theory
09:58:22 <mm_freak> zygoloid: let me try it first
09:58:35 <zygoloid> ah, of course, you just build an infinte graph :)
09:58:38 <mm_freak> damn
09:58:51 <mm_freak> SF is not an ArrowChoice instance =/
09:58:58 <luite_> wli: wasn't edwardk talking about that yesterday?
09:59:16 <luite_> well not the polymorphic bit
09:59:20 <luite_> but knowing him ;p
10:00:18 <mm_freak> zygoloid: do you see any way to write mapA without ArrowChoice or ArrowApply?
10:00:24 <mm_freak> i got only Arrow and ArrowLoop
10:00:35 <wli> luite_: It was only tangentially touched upon. It turns out that to get Remez results that are meaningful the intermediate calculations (i.e. Remez itself) have to be done in multiple precision, but once they're done, it can all be normal floating point.
10:01:08 <zygoloid> mm_freak: you need to have different processes for the [] and (:) case, so you need something like ArrowChoice
10:02:08 <mm_freak> hmm, bad
10:02:28 <mm_freak> i can imagine that implementing ArrowChoice for SF would make it really complicated
10:03:18 <mm_freak> ArrowChoice would allow singularities, i guess
10:06:51 <tibbe> I'm going to run another State of Haskell survey. Any suggestions for questions?
10:07:48 <larskinn> does anyone know how to solve exercise 1.14 (on page 15) in "Haskell Road" using only the material presented thus far? I have an (I think) elegant solution, but it uses functions that haven't been introduced yet
10:08:34 <mm_freak> tibbe: i'd love to see some questions with practical relevance
10:09:00 <mm_freak> GUIs, web frameworks, networking, communication with other applications, etc.
10:09:15 <mm_freak> also i'd be interested in the state of things of haskell under windows
10:09:25 <mm_freak> since i have no windows system, i have absolutely no idea
10:09:46 <mm_freak> larskinn: haskell road to logic?
10:09:47 <EvanR> we set up haskell on window vm yesterday, was bumpy
10:10:03 <mm_freak> EvanR: i'm interested specifically in the points i mentioned
10:10:05 <larskinn> mm_freak: yeah, Doets & Eijck
10:10:13 <mm_freak> (except the web framework part)
10:11:51 <mm_freak> larskinn: well, with the material you have thus far you would perform explicit recursion
10:12:07 <mm_freak> blowUp' :: Int -> [a] -> [a]
10:12:12 <mm_freak> combined with 'replicate'
10:12:24 <mm_freak> and 'concat' i guess
10:12:41 <larskinn> current solution: blowup = concat . (zipWith replicate [1..])
10:13:03 <mm_freak> yeah, that's what i would write
10:13:04 <larskinn> but neither blowup, zipWith or replicate have been used in the text
10:13:45 <larskinn> mm_freak: yay :)
10:15:47 <larskinn> I thought of using an Int -> String -> String signature too, and accumulate the int values, but the exercise implies that the signature should be String -> String
10:16:07 <mm_freak> yes, but you can write an auxilliary function
10:16:17 <tibbe> mm_freak, have a look at the last year's survey and tell me what you think is missing: http://blog.johantibell.com/2010/08/results-from-state-of-haskell-2010.html
10:16:17 <mm_freak> actually that one would have Int -> Int -> String -> String
10:16:18 <larskinn> true.
10:17:34 <ion> :t State Haskell
10:17:34 <lambdabot> Not in scope: data constructor `State'
10:17:35 <lambdabot> Not in scope: data constructor `Haskell'
10:17:53 <ion> (:i, that is)
10:18:50 <mm_freak> tibbe: i think you could ask more specific questions and address specific topics
10:19:07 <larskinn> mm_freak: I'll try with an aux. function, thanks
10:19:13 <tibbe> mm_freak, me too, that's why I'm asking
10:19:25 <scooty-puff> is it common for GADTs to be used with phantom types?
10:19:25 <tibbe> mm_freak, I think I will have one question about libraries
10:19:50 <tibbe> mm_freak, what kind of libraries are people missing, what are the biggest quality problems with the current library set
10:20:29 <mm_freak> tibbe: and experiences…  preferably real world experiences, not just some quick tests
10:21:00 <tibbe> mm_freak, it's kinda hard in a survey form, what do you have in mind?
10:24:05 <tibbe> gotta run I'm afraid
10:24:43 <mm_freak> tibbe: well, it's really only what i've already mentioned
10:24:51 <mm_freak> that would be my personal points of interest
10:24:57 <tibbe> k
10:26:29 <joe6> is there a smarter way of writing this: http://pastebin.com/DwA29uSG
10:26:31 <mauke> The paste DwA29uSG has been copied to http://hpaste.org/49015
10:27:23 <benmachine> joe6: you could derive Show instead, and then define a custom function
10:27:26 <benmachine> which did that
10:28:12 <joe6> ok, was just curious, if there was a simple way of getting the first letter of the constructor without resorting to TH or syb
10:28:57 * wli is quite loath to reimplement the whole of linear algebra just to get a lib polymorphic enough to work on multiple-precision floating point numbers.
10:30:34 <ion> joe6: You could get the first letter from calling the derived show.
10:32:41 <obiwahn> is there a good and short tutorial on monads? something to just get the idea. the haskell wiki offers so much taht i do not know what to read.
10:33:24 <EvanR> a monad is like a burrito
10:33:24 <byorgey> obiwahn: good, short: pick one.
10:33:34 <EvanR> QED
10:33:47 <obiwahn> good then
10:34:24 <byorgey> obiwahn: I am obviously biased but I recommend reading the Typeclassopedia, which builds from the ground up rather than jumping right into monads
10:34:30 <byorgey> @where typeclassopedia
10:34:30 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
10:35:02 <ion> Seconded
10:35:13 <mm_freak> obiwahn: you learn monads best by just using them and not bothering too much
10:35:43 <mm_freak> the more you bother, the more they may confuse you
10:35:49 <byorgey> I agree you learn best by using them, but it's not really possible to just "not bother"
10:35:57 <byorgey> you have to start by learning *something*.
10:36:15 <EvanR> start with Maybe
10:36:31 <mm_freak> byorgey: the understanding comes by itself in my experience
10:36:36 * byorgey does not really buy this whole Zen approach, "the key to learning about X is to not think about it too hard"
10:36:46 <joe6> ion, yes. i was just trying to be more haskell'ish..
10:37:11 <mm_freak> byorgey: that's the way humans learn, and as far as i remember that were your own words =)
10:37:15 <byorgey> mm_freak: experience builds understanding, yes.  But that's not the same as saying "don't bother trying to understand".
10:37:16 <joe6> ion, just wanted to see if there were other ways of doing it.
10:37:27 <mm_freak> ok, true
10:37:35 <byorgey> mm_freak: the problem is when people try to completely understand before they try writing some code.
10:37:44 <wli> Hmm, hmatrix may very well be polymorphic enough in most of its affairs, it's hmatrix-glpk that's missing polymorphism
10:38:22 <luite_> wli: possibly because glpk itself isn't?
10:38:42 <ion> obiwahn: LYAH does functors, applicative functors and monads, too.
10:38:51 <joe6> is this possible: http://pastebin.com/F2LsTAz1
10:38:53 <mauke> The paste F2LsTAz1 has been copied to http://hpaste.org/49016
10:39:25 <byorgey> joe6: sure, if you make a Num instance for Month
10:39:25 <Cale> make an instance of Num for Month and it is
10:39:38 <byorgey> joe6: not sure whether that's a good idea or not but it's certainly possible =)
10:40:41 <Cale> April^2 == December
10:40:55 <wli> luite_: LAPACK isn't either, but somehow hmatrix managed to reimplement or otherwise export polymorphic interfaces.
10:41:05 <joe6> i was trying to do something like this: http://pastebin.com/LNZZxmRc
10:41:06 <mauke> The paste LNZZxmRc has been copied to http://hpaste.org/49017
10:41:16 <mm_freak> ok, if i understand this right, then without ArrowChoice you cannot build a computation, whose structure depends on the input value
10:41:19 <mm_freak> right?
10:41:29 <Cale> joe6: yeah, you'll need to mod by 12
10:41:39 <obiwahn> byorgey: thank you .. i guess ill use them a bit first as mm_freak recommended and then return to your work to gain deeper understanding ... my profs script is just not good for me on this topic:)
10:41:58 <byorgey> obiwahn: sounds like a good plan
10:42:10 <byorgey> obiwahn: out of curiosity, where are you studying?
10:42:19 <mm_freak> so there is kind of a correspondence between applicative functors/monads and general arrows/ArrowChoice-arrows
10:42:40 <joe6> Cale, thanks. this worked. (toEnum $ mod ((fromEnum January) - 2) 12) :: Month
10:42:45 <mm_freak> obiwahn: you can do both
10:42:49 <mm_freak> at the same time
10:42:51 <joe6> > (toEnum $ mod ((fromEnum January) - 2) 12) :: Month
10:42:52 <lambdabot>   Not in scope: type constructor or class `Month'Not in scope: data construct...
10:42:52 <mm_freak> but never forget to write code
10:43:05 <joe6> > (toEnum $ mod ((fromEnum January) - 2) 12) :: System.Time.Month
10:43:05 <lambdabot>   Not in scope: type constructor or class `System.Time.Month'Not in scope: da...
10:43:46 <wli> luite_: So it looks like I have to redo linear programming, or maybe forget about using linear programming as a subroutine and go for the more direct Remez affairs, except the whole concept I had for getting an initial feasible point (or making attempts at doing so) was using linear programming for minimax regression on some point set etc.
10:43:51 <obiwahn> mm_freak:  i read the last 2 days and to prepare for an exam on functional programming:) and i just had that feeling that i have to code something now:)
10:43:56 <byorgey> mm_freak: er, not quite, it's more like  arrows/ArrowApply-arrows
10:44:27 <obiwahn> is there a snippet collection or code where i could steal some io code
10:44:27 <byorgey> mm_freak: ArrowChoice corresponds to a typeclass in between Applicative and Monad
10:44:56 <obiwahn> i would like to print a matrix or something like that and have no clue
10:45:07 <byorgey> mm_freak: but yes, without ArrowChoice the structure of an Arrow computation is static, just like Applicative computations are static
10:45:20 <mm_freak> byorgey: thanks
10:45:34 <luite_> wli: you can't use it at all, even if you use some preprocessing to normalize data or something?
10:45:45 <byorgey> ArrowChoice lets you do finite branching; ArrowApply lets you do infinite branching
10:46:06 <mm_freak> infinite in what sense?
10:46:07 <byorgey> mm_freak: Monad lets you do infinite branching; there is currently no corresponding type class for Applicative + finite branching
10:46:41 <byorgey> mm_freak: infinite in the sense that you can have an infinite number of possible continuations based on the result of a previous step
10:47:15 <wli> luite_: Not sure. Since it is merely bootstrapping the iterations, it's probably possible to get a not-sufficiently-precise starting point from glpk, convert all the numbers to multiple-precision, and proceed with the iteration from there.
10:47:20 <mm_freak> given ArrowChoice can't you always get to infinite of them via recursion?
10:47:43 <mm_freak> for example i've just written an ArrowChoice-based mapA :: ArrowChoice a => a b c -> a [b] [c]
10:47:51 <mm_freak> the input list could well be infinite
10:48:15 <byorgey> well, you can get an infinite number of choices if you are willing to let it run for an infinite amount of time =)
10:48:26 <mm_freak> ah, i see
10:48:34 <byorgey> ArrowApply/Monad give you infinite choice all in one shot by applying a function to the intermediate result
10:48:45 <mm_freak> so with ArrowApply you can have infinite choices instantly?
10:48:49 <byorgey> yes
10:48:53 <mm_freak> ok, got it
10:49:01 <wli> luite_: There's a more general problem that I have no idea how to cope with.
10:49:15 <mm_freak> then what is ArrowLoop?
10:49:30 <luite_> wli: I hope it doesn't have to do with the government? ;)
10:49:35 <mm_freak> because the arrow in question doesn't have ArrowChoice or ArrowApply instances, but does have ArrowLoop
10:49:47 <byorgey> mm_freak: that gives you recursive computations
10:49:51 <mm_freak> (it's the SF arrow in the Animas library, fork of yampa)
10:49:53 <wli> luite_: The real way it's going about things is min with respect to parameters of max with respect to functional argument as it ranges over an interval...
10:50:06 <byorgey> mm_freak: I've never thought much about how that corresponds to this notion of choice.
10:50:12 <wli> luite_: That max within the min is non-analytic and killing me.
10:50:29 <luite_> hmm hmm
10:50:38 <wli> luite_: It's not just a finite choice max but a continuous optimization.
10:50:40 <mm_freak> byorgey: but recursion without choice would mean that you recurse forever (whatever that means for the particular arrow), right?
10:51:18 <mm_freak> the SF arrow has no notion of termination, so it would make sense
10:51:23 <byorgey> mm_freak: yes, I guess you're right
10:51:38 <byorgey> mm_freak: due to lazy evaluation this is still useful, of course
10:52:26 <mm_freak> i guess you don't even need laziness for that
10:52:33 <mm_freak> just a CPS-based arrow of some sort
10:53:02 <byorgey> well, you're right, you can always simulate laziness =)
10:53:36 <mm_freak> well, yeah, but i don't necessarily view this as simulating laziness =)
10:54:13 <byorgey> no, I see what you mean.
10:55:02 <mm_freak> otherwise all coroutines would do that, even python's generators
10:55:25 <joe6> this is what I ended up with: http://pastebin.com/4j4TdUxD
10:55:27 <mauke> The paste 4j4TdUxD has been copied to http://hpaste.org/49018
10:55:34 <joe6> to subtract int from month
10:55:54 <joe6> where the month Int is not zero-indexed.
10:59:30 <argiopeweb> I'm in a bit of a quandary. I have to recreate a unique identifier system from some legacy software which uses (among other things) a time and sequence number to create a UID. My problem is that I need to call it from pure code, and getting system time is inherently impure. unsafePerformIO doesn't work because then time only gets evaluated once. Does anyone know of a possible solution for this problem?
11:00:35 <luite_> argiopeweb: it will evaluate it again if you add a bogus parameter so that it's not a value but a function
11:00:47 <luite_> there might be better solutions though :)
11:01:31 <byorgey> I was going to suggest using the acme-now package, but I guess that would have the problem with only getting evaluated once =)
11:01:42 <argiopeweb> luite_: Hmm, good point. Hadn't even thought of that.
11:02:04 <mm_freak> i'm failing to figure out how to use that 'loop' function from ArrowLoop
11:02:27 <argiopeweb> byorgey: I'm in stitches over the acme-now documentation...
11:02:28 <mm_freak> as soon as i evaluate the second argument of the tuple, i get an infinite loop
11:02:48 <Saizan> mm_freak: loop is an arrowy version of fix
11:03:54 <mm_freak> Saizan: is it really useful or can it always be replaced by explicit recursion conveniently?
11:03:57 <byorgey> > loop (\(b, d) -> (d, b:d)) 1
11:03:58 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
11:05:10 <byorgey> mm_freak: explicit recursion introduces recursion in your Haskell program.  loop introduces recursion in an Arrow program.  I don't think you can replace loop with Haskell-level recursion.
11:05:28 <mm_freak> ah, i see
11:05:33 <mm_freak> oh
11:05:34 <byorgey> maybe you can if you are using the (->) instance of Arrow.
11:05:38 <mm_freak> your example was actually very helpful
11:05:44 <byorgey> oh good =)
11:05:53 <mm_freak> thanks =)
11:07:14 <Shammah> ehm
11:07:16 <obiwahn> where do i find the/a haskell class reference?
11:07:32 <Shammah> why does ['a'..'Z'] equal to [ ]?
11:07:56 <Shammah> i would expect it to be like ['a'..'z'] ++ ['A'..'Z']
11:08:14 <luite_> > 'Z' < 'a'
11:08:15 <lambdabot>   True
11:08:16 <obiwahn> got it:)
11:08:48 <luite_> Shammah: capital letters have lower ascii values
11:08:53 <Shammah> ... oh
11:09:01 <Shammah> well that's.. .awkward, but explains it well
11:09:08 <obiwahn> sweet:)
11:09:50 <ion> Why *should* it be the other way around? What’s your intuition about the implicit order between capital and small letters?
11:09:58 <obiwahn> on the first glance it the ghc doc looks as good as the python doc:)
11:10:08 <mm_freak> ok, i can see the least fixed point pattern in 'loop'
11:10:10 <parcs> capital letters are bigger so they should have bigger ascii values
11:10:14 <Shammah> ^
11:10:15 <Shammah> hah
11:10:19 <Shammah> pretty much :)
11:10:36 <mm_freak> obiwahn: the haddock docs are usually very good and easily generated out of the source code
11:10:50 <mm_freak> they are so useful, because haddock actually understands the types =)
11:11:32 <luite_> they're so useless because no one bothers to write actual documentation ;)
11:12:13 <mm_freak> luite_: wrong…  compared to projects in other languages haskell libraries tend to be very well documented
11:12:41 <argiopeweb> luite_: Something along the lines of "x = \_ -> unsafePerformIO getClockTime" works fine, though you have to pass something to it on every call..
11:13:00 * wli is trying to get LaTeX-style literate Haskell and haddock to work together without excessive awkwardness.
11:13:01 <luite_> mm_freak: hmm, I'm not sure if I agree, but it all depends on the language you compare it to :p
11:14:16 <mm_freak> luite_: ever tried to read those awful phpdoc docs?  they are bad even for well known packages =)
11:14:18 * wli is also trying to remember how multiple LaTeX-style literate Haskell source files got put together into a single LaTeX document.
11:14:53 <obiwahn> maybe the pythons howtos are missing:) but it is sill good to have a referencs with some short expanation:)
11:14:56 <joe6> @hoogle dateDiff
11:14:56 <lambdabot> No results found
11:15:27 <wli> One may see in a few days what I consider to be well-documented.
11:15:30 <obiwahn> python scapy followed by twisted are a documentation nightmare:)
11:15:57 <luite_> mm_freak: hmm, dunno. haskell is probably better because you can infer much more from the types... on the other hand, haskell libraries often have lots of small combinator functions where it's not immediately clear from the types how they're supposed to be used together
11:15:58 <sully> mm_freak: look, being proud that your language is better than php in basically any regard is like being happy that you can outrun a parapalegic
11:17:19 <sully> there are a lot of places where haskell has pretty useless docs
11:17:35 <sully> like, the documentation for Alternative, for example
11:17:41 <sully> some is documented as "One or more."
11:17:48 <sully> that is not a reasonable explanation!
11:17:57 <mm_freak> it is
11:17:57 <JuanDaugherty> i think it's supposed to be self documenting
11:18:02 <luite_> it is if you already know how to use it ;)
11:18:20 <mm_freak> sully: what would be your documentation?
11:18:27 <mm_freak> Alternative is Alternative, not any specific instance
11:18:32 <mm_freak> so "one or more" is quite reasonable
11:18:34 <sully> right, and you find out how to use it by reading the typeclassopedia or something
11:19:03 <mm_freak> the real problem is that haddock doesn't support instance documentations
11:19:29 <sully> mm_freak: I don't know what my documentation would be; I don't understand what it is supposed to do :P
11:19:45 * hackagebot unbound 0.2.4 - Generic support for programming with names and binders  http://hackage.haskell.org/package/unbound-0.2.4 (BrentYorgey)
11:19:58 <mm_freak> exactly what it says:  "one or more" in the sense of the particular instance ;)
11:20:16 <mm_freak> i really see no way how to be more specific here
11:20:29 <mm_freak> you could add:  "in the sense of the particular instance"
11:22:07 <mm_freak> the meaning quickly becomes apparent, as soon as you look at, for example, parser functors
11:22:11 <mm_freak> like parsec
11:23:29 <obiwahn> mm_freak: because the magic in good documentation is that people like me have it easy to understand the syntax and concepts of the language and not people who already know everything of haskel understand everything in the docs:)
11:24:05 <mm_freak> obiwahn: i agree, but in this particular case i really see no way to improve the documentation
11:24:23 <mm_freak> it is as precise as one can get for a concept as abstract as 'many1'
11:25:42 <mm_freak> i think, 'fix' is also a good example…  it is the function, which applies its argument to itself infinitely many times…  but what does that tell you?
11:26:03 <mm_freak> > fix (1:)
11:26:04 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
11:26:15 <sully> the documentation should try to provide some intuition, then
11:26:26 <mm_freak> sully: that's dangerous
11:27:15 <sully> it's not! it just saves people time, since they'll have to go looking for some intuition about it anyways
11:27:36 <conal> sully: often these "intuitions" are incorrect.
11:27:40 <joe6> is there a fst, snd and tpl for a (x,y,z) -- triple?
11:27:47 <mm_freak> an obvious intuition for many1 is a parser, which succeeds one or more times…  reading this intuition may well totally screw up many1 for any other functor for the reader
11:27:50 <joe6> standard library functions, I eamn.
11:27:55 <joe6> @hoogle triple
11:27:55 <lambdabot> Control.Parallel.Strategies parTriple :: Strategy a -> Strategy b -> Strategy c -> Strategy (a, b, c)
11:27:55 <lambdabot> Control.Parallel.Strategies seqTriple :: Strategy a -> Strategy b -> Strategy c -> Strategy (a, b, c)
11:28:09 <mm_freak> just look at all the people claiming that monads are an abstraction for doing I/O =)
11:28:13 <conal> sully: maybe the documentation you're missing is simply the class laws. everything else may be incorrect.
11:29:26 <Cale> It's not missing the laws
11:29:30 <conal> if someone hasn't had any abstract math class, they may be mystified about type classes.
11:29:34 <mm_freak> sully: by giving intuitions you rewire the readers brain to that intuition…  he may have problems fitting other uses of the thing in question with that wiring
11:29:36 <Cale> some v = (:) <$> v <*> many v
11:29:45 <Cale> many v = some v <|> pure []
11:30:00 <conal> Cale: perhaps sully (et al) is missing the laws (perhaps by ignoring them).
11:30:15 <mm_freak> i think, giving intutitions is not the task of the documentation, but of external tutorials
11:30:25 <Cale> and it says that <|> should be an associative binary operation with identity empty
11:30:34 <Cale> Other than that, everything is instance dependent
11:31:03 <Cale> Good intuition might be obtained by looking at the instance for a parser library
11:31:24 <conal> Cale: good intuition about what?
11:31:29 <Cale> Alternative
11:31:49 <conal> Cale: i mean: good intuition about what about Alternative?
11:32:14 <conal> i ask because i suspect that most of these quests for intuition are misguided.
11:32:28 <conal> i.e., a confused question rather than a clear question needing an answer.
11:32:31 <Cale> why 'some' and 'many' have those names, for one
11:33:03 <conal> does it matter why those names were chosen?
11:33:18 <conal> often the names are misleading.
11:33:22 <conal> e.g., "mappend"
11:33:34 <mm_freak> conal: what *morphism would you call them?
11:33:37 <conal> and worst of all, "do"
11:33:38 <Cale> I don't think mappend is that misleading. It's a bad name because it's too long.
11:33:50 <conal> mm_freak: i'd call then a *morphism?
11:33:51 <mm_freak> i find mappend indeed misleading
11:34:28 <mm_freak> conal: that was a joke, but there is one thing in haskell, about what i would totally agree with sully
11:34:34 <mm_freak> sometimes too much category theory =)
11:34:40 <conal> my impression is that "mappend" came from a spoken name for list (or more generally sequence) append
11:35:31 <Cale> The free/forgetful adjunction between monoid and set is monadic, and so every monoid can be looked at as a free monoid (under appending) with an evaluation map.
11:35:50 <conal> mm_freak: meaning, some of the building blocks are too abstract for many programmers?
11:36:03 <conal> mm_freak: e.g., the type classes
11:36:40 <mm_freak> conal: i'm not talking about the base library…  i couldn't come up with a better name than "Monad" or "Functor"
11:36:52 <EvanR> im trying to make a reorderable gtk2hs treeview, i got it to allow me to drag but i cant get the data received and data delete event handlers to occur
11:36:56 <EvanR> http://codepad.org/Ri04ykyo
11:37:00 <conal> mm_freak: oh -- it's the names that worry you?
11:37:08 <mm_freak> Cale: that's exactly my point =)
11:37:22 <EvanR> coloring http://codepad.org/nbsEP2FH
11:37:30 <Cale> mm_freak: What is?
11:37:38 <mm_freak> conal: nevermind
11:37:41 <Cale> mm_freak: That monoids can be looked at as appendy-things?
11:37:56 <EvanR> wheres that manatee guy
11:38:15 <mm_freak> Cale: you have to know that in order to understand why that function is called 'mappend'
11:38:16 <conal> mm_freak: ah, okay. sry i didn't manage to understand what you were getting at.
11:38:30 <ziman_> i quite like mappend because it implies associativity but not commutativity
11:39:08 <mm_freak> conal: well, just read the docs of category-extras and try to imagine you would know only the basics of CT
11:39:29 <Cale> mm_freak: nah, I'm just giving a highbrow explanation to satisfy the sort of person who would be uncomfortable with the name mappend because it seems too much based on one instance.
11:39:30 <conal> ziman_: in the same way, doesn't "mappend" imply non-commutativity?
11:39:46 <argiopeweb> Is there no library for units of measure?
11:39:57 <mm_freak> even though the library would be extremely useful in general, through the docs and the names you can't make use of it without first spending weeks learning CT
11:40:13 <Cale> conal: It's more that it *does* imply associativity
11:41:31 <ziman> conal, well, probably it does.
11:41:47 * hackagebot ixset 1.0.0 - Efficient relational queries on Haskell sets.  http://hackage.haskell.org/package/ixset-1.0.0 (JeremyShaw)
11:42:42 <EvanR> wow, i need to look at ixset
11:43:47 <msieradzki> can I assume that ghc will only use sse for floating-point computations with -msse2 or x64? let's say that I'm building software that requires SSE2 and I care about getting same results on every machine
11:43:51 <ziman> which I'd say is okay if you work at that level of abstraction; I read it more as "merge"
11:44:48 * hackagebot data-cycle 0.1.1 - a cyclic doubly linked list  http://hackage.haskell.org/package/data-cycle-0.1.1 (TobiasBrandt)
11:46:17 <argiopeweb> msieradzki: Does SSE2 guarantee cross-platform identical floating point computation?
11:49:04 * conal 's internet connection is particularly flaky lately.
11:50:20 <msieradzki> I don't know :) but issuing just sse reg ops would be a start
11:51:28 <conal> i guess what bothers me about "mappend" is that it's not clear about *which* properties of append hold, so the reader is left to guess. one might get lucky and guess associativity, but one also might get unlucky and guess non-commutativity.
11:52:12 <Cale> I *guess*, though it's rather perverse to guess the opposite of something equational :)
11:53:10 <conal> nonperverse to guess equational properties and perverse to guess inequational properties?
11:53:20 <conal> i guess everyone has a different take on perversity.
11:53:39 <EvanR> heres the 'minimal' version of the test case for my previous question about reorderable treeview gtk2hs widgets
11:53:42 <EvanR> http://codepad.org/snLpPXfq
11:53:49 * hackagebot unbound 0.2.5 - Generic support for programming with names and binders  http://hackage.haskell.org/package/unbound-0.2.5 (BrentYorgey)
11:54:19 <Cale> Well, most of the theories we care about have a bunch of operations and the laws for those operations are strictly equational things.
11:54:23 <EvanR> i never get 3 or 5
11:54:51 <Cale> There are only a few decent exceptions to this, fields being the most important, probably.
11:55:48 <Cale> (not equational because not every element has an inverse)
11:56:10 <conal> Cale: ah, so you develop a habit of equationally-biased assumptions. makes sense to me. i don't seem to have as strong a bias. and i couldn't say about others.
11:57:06 * byorgey also has a habit of equationally-biased assumptions
11:57:08 <conal> Cale: and now i'm curious, for which i thank you.
11:57:30 <Cale> Equations are usually useful things to assume, while negations of equalities are usually not that useful for reasoning about things, especially if you're being constructive.
11:57:40 <byorgey> also because equality has many more nice properties than inequality.
11:57:52 <Cale> Because they tell you that certain counterexamples exist, but don't tell you what they are.
11:58:08 <byorgey> if I know that a /= b and b /= c it doesn't tell me much about a and c, for example.
11:58:40 <conal> byorgey: just to be clear, are you saying that if a specific name (e.g., "append") is used in a more general context, you'd tend to assume exactly the equational properties of the more specific case (and no others)?
11:59:15 <byorgey> I'm just saying I'd be much quicker to assume equational properties than inequational ones
11:59:22 <conal> i also tend to wonder whether such justifications are reasons or rationalizations, and i don't know how to find out.
11:59:55 <byorgey> I don't think those are mutually exclusive.
12:00:10 <conal> (where a reason is a means of arriving at a belief, and a rationalization is a way to remain at a belief.)
12:00:20 <Cale> I think it's a bit of both.
12:01:20 <Cale> But it has turned out to be successful, and so we like it. It's infrequently the case that we want something inequational to be true, or that the objects that such a thing excludes from a theory are problematic.
12:09:53 <daggity> Hello! A while ago, I remember seeing a very well designed tutorial for Haskell on reddit. I had saved it (Or thought I did), but I can't find it. Do any of you know what I'm talking about?
12:10:08 <ion> @where lyah
12:10:09 <lambdabot> http://www.learnyouahaskell.com/
12:10:37 * Kreative` is away: Away
12:10:40 <daggity> That might be it, thanks. : D
12:18:00 <skemuel007> my first haskell connection
12:19:23 <byorgey> skemuel007: welcome =)
12:19:44 <skemuel007> hey thanks man
12:20:09 <byorgey> skemuel007: feel free to ask questions in here
12:23:12 <argiopeweb> Anyone know why Data.Int recommends fromIntegral instead of fromInteger for type coersion?
12:24:39 <byorgey> argiopeweb: fromInteger only works on values of type Integer
12:25:30 * argiopeweb rereads function type
12:25:44 <argiopeweb> Yep, I'm officially dense.
12:25:56 <argiopeweb> Thank byorgey.
12:26:07 <byorgey> hehe, no problem =)
12:28:38 <EvanR> dcoutts_: had any success with reorderbale treeviews?
12:28:46 <EvanR> reorderable
12:31:57 <hpaste> boegel pasted “Haskell runtime error” at http://hpaste.org/49024
12:32:14 <boegel> has anyone ever seen an error message like this? ^
12:32:39 <byorgey> eek
12:32:42 <boegel> this is shown by a Haskell program that's running another Haskell program through "system"
12:32:53 <boegel> but the system I'm seeing this on has 4G RAM
12:33:05 <boegel> and both Haskell programs are run with +RTS -M1G
12:33:08 <boegel> wtf is going on?
12:33:49 <boegel> also, I'm seeing this on x86-64 Linux, but not on OS X (which is doing 32-bit Haskell binaries)
12:33:58 <boegel> I bet it's related to that somehow...
12:46:59 <monadic> Is there a good way to check whether code is being correctly optimized by stream fusion?
12:47:08 <monadic> short of looking closely at ugly core
12:47:17 * hackagebot pwstore-fast 2.2 - Secure password storage.  http://hackage.haskell.org/package/pwstore-fast-2.2 (PeterScott)
12:48:37 <Cale> monadic: Well, there's some flag you can use which prints out how many times each rewrite rule fired
12:50:04 <Cale> -ddump-simpl-stats I think
12:50:45 <Cale> It was definitely -ddump-something
12:59:47 <obiwahn> is there a tabcompletion in hugs like in ghci? and which one do you prefer? I don't mean to start a war ...
13:00:28 <kosmikus> obiwahn: I don't think there are many people who still use hugs ...
13:00:32 <byorgey> obiwahn: hugs has not been worked on or supported for several years now.  ghci is still under active development.
13:01:08 <arw__> obiwahn: most people prefer ghci since ghc is the canonical implementation almost everybody uses.
13:01:37 <obiwahn> thanks
13:01:47 <byorgey> hugs used to be better for learning because it had better error messages, but I don't think that's even true any more.
13:04:26 <obiwahn> and what is wrong with: olistprint (h:t) = putStr(show(h) ++ " " ++ olistprint(t))
13:05:11 <sm__> does pandoc have a problem with multiple tables in a single markdown document ? I always end up with one rendered table
13:06:09 <kosmikus> obiwahn: it's not type correct
13:06:45 <kosmikus> obiwahn: putStr produces something of type IO ()
13:07:07 <kosmikus> obiwahn: but you use olistprint(t) recursively as an argument to ++, which expects a list
13:07:56 <kosmikus> obiwahn: apart from the type error ... in Haskell, we write  show h  rather than  show(h)
13:08:01 <obiwahn> kosmikus: ok - don#t tell me the solution
13:08:25 <kosmikus> obiwahn: but that's just style, not a question of correctness
13:09:41 <monadic> obiwahn: Haskell is not C, show(h) is better written as show h
13:09:59 <monadic> Oh apparantly someone already said that ;)
13:10:00 <ion> > (((((show)))))((((("o hai")))))
13:10:00 <lambdabot>   "\"o hai\""
13:11:23 <Eduard_Munteanu> It ithn't Lithp eitheh!
13:12:13 <dylukes> Eduard_Munteanu: Despite your clever guile, your schemes to cause a racket aren't getting anywhere.
13:13:18 <erus`> > sum show(123)
13:13:19 <lambdabot>   Couldn't match expected type `[a]'
13:13:19 <lambdabot>         against inferred type `a1 -> GHC...
13:13:37 <Eduard_Munteanu> My Schemes? :P
13:13:46 <burbul> Can I ask a (pretty basic) stylistic question?
13:13:58 <kmc> yes
13:14:01 <Eduard_Munteanu> burbul: sure, you don't need to ask to ask
13:14:11 <kmc> you are allowed to ask but not allowed to ask to ask
13:14:23 <byorgey> dylukes: groan
13:14:24 <monadic> burbul: Unless you are asking to ask to ask, in which case you can ask to ask something
13:14:32 <burbul> Well, it seems a bit rude to just turn up and break into a discussion!
13:14:34 <burbul> Which would you say should be preferred out of the following (and why)?
13:14:34 <burbul>     node_from_id1 id = fromJust $ Map.lookup id node_from_id_map
13:14:34 <burbul>     node_from_id2 = fromJust . flip Map.lookup node_from_id_map
13:14:34 <burbul>     node_from_id3 = fromJust . (`Map.lookup` node_from_id_map)
13:14:58 <byorgey> burbul: it isn't rude, actually.  There are often several conversations going on concurrently.
13:15:08 <burbul> [ I'm learning Haskell,  and I'm managing to figure out how to do things, but there's much less guidance on style than for some other languages.]
13:15:19 <EvanR> burbul: style guide
13:15:21 <monadic> burbul: Second
13:15:36 * byorgey prefers the third
13:15:42 <monadic> The first is the worst really
13:15:47 <monadic> second and third is just taste
13:15:47 <Eduard_Munteanu> The first one isn't bad either, yeah.
13:15:57 <monadic> pointfree is better
13:16:06 <byorgey> pointfree is better up to a point
13:16:28 <kosmikus> the first is bad because you use id as the identifier
13:16:36 <kosmikus> and that's misleading
13:16:39 <byorgey> yeah, that's confusing =)
13:16:46 <kosmikus> apart from that, I see no major differences between the three
13:16:49 <monadic> byorgey: And as long as you aren't doing something insane like ((.) . (.)) map, its fine
13:16:49 <kosmikus> they are all ok
13:16:51 <byorgey> > let id = const 5 in id 3
13:16:52 <lambdabot>   5
13:17:09 <burbul> EvanR: do you mean something specific? (I've found various things by search, but none that useful.)
13:17:48 <burbul> kosmikus: is 'id' a reserved word or a standard library function?
13:17:57 <Eduard_Munteanu> :t id
13:17:57 <lambdabot> forall a. a -> a
13:18:03 <burbul> ah!
13:18:13 <Eduard_Munteanu> @index id
13:18:13 <lambdabot> Prelude
13:18:14 <monadic> :t ((.) . (.)) map
13:18:15 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b. (Functor f, Functor f1) => f (f1 (a -> b)) -> f (f1 ([a] -> [b]))
13:18:27 <burbul> Thanks, all.
13:18:28 <monadic> Which is why its useful not to always be point free ;)
13:18:36 <Eduard_Munteanu> burbul: well, you can define it yourself too
13:18:46 <obiwahn> kosmikus: replace the second ++ with ) >> to get the types right, this way the action is followed by another action.
13:18:53 <monadic> Although interestingly lambdabot is generalizing map...
13:18:54 <monadic> :t map
13:18:55 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
13:18:57 <monadic> hmm
13:19:01 <kmc> :t (.)
13:19:01 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:19:08 <monadic> Ahh.
13:19:11 <ion> burbul: You were afraid to break into a discussion, but you asked a question *anyway*. Might as well have been the one really on your mind. :-P
13:19:20 <burbul> :)
13:19:29 <kosmikus> obiwahn: yes, that's one option
13:19:33 <Eduard_Munteanu> :t ((Prelude..) Prelude.. (Prelude..)) map
13:19:34 <lambdabot> forall a a1 a2 b. (a -> a1 -> a2 -> b) -> a -> a1 -> [a2] -> [b]
13:19:47 <obiwahn> kosmikus: what are the other options?
13:19:49 <ion> > fromJust Nothing
13:19:50 <lambdabot>   *Exception: Maybe.fromJust: Nothing
13:19:56 <ion> fromJust is evil.
13:20:05 <kosmikus> obiwahn: you can convert the complete list to a string and apply putStr only once in the end
13:20:05 <monadic> Bet you couldn't figure out the type of ((.) . (.)) map by hand in any nice amount of time ;
13:20:23 <kosmikus> obiwahn: (for example)
13:20:24 <burbul> ion: in the context where I'm using it it's provably safe
13:20:39 <monadic> burbul: Then why the Maybe
13:20:42 <kosmikus> obiwahn: in general, even simple programming problems have thousands of solutions
13:20:46 <obiwahn> kosmikus: will i get spaces?
13:20:59 <Eduard_Munteanu> :t maybe
13:20:59 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:21:00 <kosmikus> obiwahn: if you insert them
13:21:02 <burbul> monadic: because it was part of the signature of Map.lookup?
13:21:10 <monadic> burbul: Oh, didn't see the code
13:21:56 <kosmikus> obiwahn: if you are willing/allowed to use standard functions, you can map show over the list, then use "unwords" to insert spaces, then apply putStr or putStrLn (and compose all of these steps using function composition)
13:22:04 <monadic> burbul: But why not use !
13:22:28 <monadic> Or you can use mapM_ on each individual one
13:22:49 <burbul> What does ! do?
13:22:51 <burbul> :t !
13:22:51 <lambdabot> parse error (possibly incorrect indentation)
13:22:59 <burbul> :t (!)
13:23:00 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
13:23:01 <monadic> burbul: :t (Data.Map.!)
13:23:07 <monadic> :t (Data.Map.!)
13:23:08 <lambdabot> forall k a. (Ord k) => M.Map k a -> k -> a
13:23:29 <burbul> ah! thanks. (I was getting very annoyed by having to use fromJust.)
13:23:31 <Eduard_Munteanu> cowworker: are you in a competing/different line of work than Conor now? :P
13:23:56 <Eduard_Munteanu> Crap, I remember!
13:23:59 <ski> burbul : it's (a) the name used for the operation to index an array (and maps, and possibly other things), and (b) the syntax used for strictness annotations in `data' type declarations and in bindings
13:24:04 <obiwahn> kosmikus: would you please write the exact line for me so i can take it apart bit for bit.
13:24:25 <Eduard_Munteanu> (You know, I couldn't remember whose name had a missing letter, it wasn't Russel, it was Conor I think :D)
13:24:30 <monadic> (b) would be bang patterns, needs -XBangPatterns
13:24:48 <ski> monadic : well, the latter part of (b) :)
13:24:49 <monadic> so it doesn't count. Not haskell98 :)
13:24:53 <burbul> ski: thanks
13:24:55 <kosmikus> obiwahn: I thought you want to figure out things on your own :)
13:25:20 <burbul> Does anyone know what EvanR meant by 'style guide'? is it a specific document?
13:25:33 <monadic> burbul: I think he means per project.
13:25:46 <burbul> ah
13:25:56 <monadic> burbul: The GHC one is at http://hackage.haskell.org/trac/ghc/wiki/Commentary/CodingStyle
13:26:10 <burbul> hey, ! even has its arguments the natural way around (unlike lookup)... this is great .
13:26:27 <C00kiemonst3r> hi
13:26:34 <EvanR> monadic: theres a popular style guide
13:26:45 <monadic> burbul: Putting the Data.Map second is nicer, don't have to flip as much
13:26:49 <C00kiemonst3r> http://codepad.org/wxHyywDq
13:27:02 <ski> monadic : `!' in `data' declarations in Haskell98
13:27:12 <ski> s/in Haskell98/is Haskell98/
13:27:19 <monadic> I don't get why GHC style uses braces + semicolons
13:27:22 <C00kiemonst3r> how I print the first n rows of pascal triangle
13:27:22 <monadic> ski: Ooh, really?
13:27:27 <kosmikus> burbul: I have some stylistic things at http://www.cs.uu.nl/wiki/pub/USCS2010/CourseMaterials/C4.pdf
13:27:31 <C00kiemonst3r> I think it overrides the previous
13:27:34 <Eduard_Munteanu> Well, Haskell's style guide would have to cover lots of things, considering the language features and the standard lib.
13:27:34 <kosmikus> burbul: (but a lot of that is my personal opinion)
13:27:39 <ski> monadic : yes
13:27:59 <burbul> monadic: that's what I meant by "the natural way round"
13:28:27 <cowworker> joe6: can you avoid spamming hpaste please? I can't find my stuff anymore :P
13:28:39 <monadic> burbul: ! puts Data.Map.Map first, which is rarely what you want for composition.
13:29:28 <burbul> kosmikus: thanks! ... just skimming it. Do you have a preference between 'let' and 'where'?
13:30:16 <monadic> burbul: If you are using monads use let
13:30:17 <ski> monadic : see `const' at <http://haskell.org/onlinereport/decls.html#sect4.2.1>
13:30:37 <burbul> i see
13:30:39 <ski> s/const/constr/
13:30:47 <burbul> And if you aren't using monads use where?
13:30:53 <ski> (darn auto-completion ..)
13:30:56 <monadic> burbul: No, just use let if you are using monads.
13:31:31 <monadic> burbul: My personal opinion is that if the "in ____" is complicated (not just like g 0 n or something), then use let..in, otherwise use where
13:32:04 <burbul> got it
13:32:09 <EvanR> it works.... finally
13:32:18 <EvanR> i looked at the demo that came with the code
13:32:43 * hackagebot ixset 1.0.1 - Efficient relational queries on Haskell sets.  http://hackage.haskell.org/package/ixset-1.0.1 (JeremyShaw)
13:34:29 <kosmikus> burbul: let/where: no, not in general. I think I prefer "let" is the local binding really scopes over an expression, and "where" if it scopes over a declaration (e.g. multiple guards)
13:40:10 <edwardk> preflex: xseen dcoutts
13:40:10 <preflex>  dcoutts was last seen on freenode/#ghc 44 minutes and 28 seconds ago, saying: yes
13:45:43 <dcoutts> edwardk: were you after something?
13:45:57 <djahandarie> Fame and riches.
13:55:58 * hackagebot regex-applicative 0.1.3 - Regex-based parsing with applicative interface  http://hackage.haskell.org/package/regex-applicative-0.1.3 (RomanCheplyaka)
13:57:06 <edwardk> dcoutts: just chasing after GSoC midterm evaluations, you're the last one I have outstanding ;)
13:57:18 <dcoutts> edwardk: ah right yes
13:57:26 <edwardk> and fame and riches would be good as well
13:57:32 <dcoutts> edwardk: things are all fine, I'll send it in
13:57:57 <edwardk> sweet. just trying to make sure i don't have t scramble around tomorrow =)
13:57:59 <monadic> I wish I could do GSoC :(
13:58:09 <edwardk> monadic: not a student?
13:58:19 <monadic> edwardk: Too young of a student ;)
13:58:32 <edwardk> highschoolish?
13:58:36 <monadic> edwardk: Yeah
13:58:52 <monadic> edwardk: Have the experience without the age :P
13:58:54 <edwardk> google has another program for students of that age range, but we haven't participated
13:59:19 <edwardk> partly because we were having trouble trying to figure out appropriate projects
14:00:28 <hpaste> deggis pasted “Membereistä” at http://hpaste.org/49025
14:00:59 <dolio> Something futu-postpromorphism-based would be a good high school project.
14:01:08 <edwardk> sounds perfect.
14:01:26 <edwardk> it'll help them with their latin and greek ;)
14:01:35 <monadic> hey there, high school students are perfectly capable of the same work as college students :P
14:02:18 <edwardk> well, i don't think such a project would be accepted even into the normal summer of code
14:02:37 <EvanR> middle school students are capable of same work as high school students
14:02:44 <dolio> As far as Haskell projects go, that's probably true.
14:02:47 <monadic> EvanR: Precisely
14:02:57 <dolio> Nothing in university is going to get you very Haskell-ready.
14:03:00 <monadic> EvanR: Thats why you see all middle school kids in math contests
14:03:05 <EvanR> but when i was in middle school, we were doing same work as college students, and it made me cry
14:03:13 <dolio> Unless you're at a few particular universities.
14:03:45 <EvanR> so its not transitive ;)
14:03:58 <edwardk> monadic anyways, last year there was "Google Code-in". not sure if they are doing it again this year
14:04:45 <beastaugh> dolio: yeah, I've had Barendregt's lambda calculus book out of the university library for six months, no one else has tried to take it out during that time, which tells you something
14:05:19 <monadic> I wish my high school's library had books on lambda calculus
14:05:59 <dolio> Yes, well, most high schools don't have very impressive libraries, I expect.
14:06:13 <monadic> I tried to look for some good books at MIT while I was there but they didn't have any educational books in the store for some reason
14:06:19 <dolio> I almost never went to my college's library, really. Probably a mistake in retrospect.
14:06:21 <monadic> Very sad
14:06:31 <dolio> Which store?
14:06:36 <monadic> The Coop
14:06:43 <edwardk> monadic: i seem to recall that the grand prize was a trip to google. if they run it again, follow up with me ;)
14:06:47 <dolio> The MIT Press store has an awesome comp-sci section.
14:06:55 <monadic> edwardk: Will do ;)
14:07:01 <dolio> The Coop's comp-sci section is weak, though.
14:07:09 <monadic> edwardk: If I'm not too busy with college apps and AP-summer coursework
14:07:15 <edwardk> yeah
14:07:20 <edwardk> well its a winter thing iirc
14:07:32 <edwardk> this last one was done over the christmas break or so
14:07:38 <dolio> The Coop's math section is way better than the MIT Press', though.
14:07:38 <monadic> edwardk: Oh, that should be nice. Exam time is always relaxing, teachers don't give homework because they think you are studying
14:08:02 <monadic> dolio: I looked for math too. They had the whole area closed!
14:08:28 <monadic> dolio: I guess they were restocking.
14:08:31 <edwardk> dolio: both are kinda meh in the math department though
14:08:34 <dolio> Actually I think the Harvard coop is better than the MIT coop, though.
14:09:04 <dolio> They've got Higher Topos Theory. What else do you need?
14:09:09 <edwardk> i miss quantum books, which used to be across the street from the mit coop.
14:09:25 <edwardk> apparently their financial waveform collapsed
14:09:33 <kmc> *rimshot*
14:09:43 <monadic> edwardk: Aww, MR < MC.
14:10:41 <monadic> I was looking forward to getting my brothers textbooks but he was cheap and never bought them...
14:12:35 <beastaugh> ironically, going back to university meant I bought far fewer books, since I could no longer afford them
14:13:31 <monadic> I do like how you can find most haskell stuff online as research papers
14:29:21 <burbul> @kosmikus... if you're there, I'm curious as to why you say "avoid local functions if they need not be local" ...
14:29:22 <lambdabot> Unknown command, try @list
14:32:37 <Eduard_Munteanu> burbul: well you wouldn't write every helper function in a let/where block in 'main'.
14:35:49 <EvanR> Eduard_Munteanu: why not!
14:36:51 <Eduard_Munteanu> The additional indentation would suck I guess. ;)
14:40:19 <burbul> My usual reason not to would be that I was writing something which didn't really make sense as a top-level function -- i.e. it doesn't really stand on its own.
14:40:52 <burbul> And another advantage of making it local is that I can give it a fairly short name without worrying
14:48:30 * hackagebot mongoDB 1.0.0 - Driver (client) for MongoDB, a free, scalable, fast, document DBMS  http://hackage.haskell.org/package/mongoDB-1.0.0 (TonyHannan)
15:14:23 <dpratt71> anyone know anything about Barrelfish (experimental OS from MS Research)? I know next to nothing about it, but I was interested to see that GHC is part of the tool chain
16:02:35 <rvn_> :t print
16:02:35 <lambdabot> forall a. (Show a) => a -> IO ()
16:58:03 <ocharles> Hi, looking for a bit more design advice. I currently have: data Book = Book { name :: String, gid :: UUID } (hand waving). I want to be able to insert new books into the database, which feels like it should be something like insertBook :: Book -> IO Book. The problem is, the caller of this function should never have to specify the gid of the book.
16:58:15 <ocharles> So I feel like I want to be able to create an "incomplete" Book, but I'm not sure how to do that
16:58:52 <ocharles> newBook = Book { name = error "Unitialized", gid = error "Uninitialized" } -- feels like one option, and not exporting the Book constructor
16:59:05 <ocharles> but that doesn't feel at all like the right solution
17:00:07 <Peaker> ocharles: why not split it into the non-gid and with-gid parts?
17:00:18 <Peaker> ocharles: data BookInfo = BookInfo { name, author, ... }
17:00:32 <ocharles> Peaker: because then it gets hard to work with books that are served from the DB
17:00:41 <ocharles> it's more common to work with complete books, rather than creating new books
17:00:53 <Peaker> ocharles: in what sense? You can write field accessors that give you all the fields of the BookInfo directly from Book
17:01:07 <ocharles> I could add a new constructor to the Book type too, that doesn't have gid
17:01:10 <Peaker> ocharles: also, why not work with BookInfo most of the time?
17:01:26 <Peaker> ocharles: oh that would make most of your functions partial, I wouldn't go there :)
17:01:27 <ocharles> Peaker: because gid is pretty important for linking between books
17:01:36 <Peaker> also the error case would introduce lots of unnecessary partiality
17:01:36 <ocharles> Peaker: what does that mean?
17:01:50 <ocharles> I think I have a bunch of "partial" functions atm... which I don't like either :)
17:02:29 <Peaker> ocharles: a partial function is a function that's not defined for certain inputs. total is the opposite.  if you use a sum type (two constructors) then you will have to ignore one of them in many cases, so your functions will be partial and you get less static guarantees about not crashing
17:02:43 <ocharles> yep, I definitely have that atm
17:02:55 <ocharles> here's why...
17:03:31 <Peaker> ocharles: I'm not sure why you think having an extra record layer there is significantly harder to work with
17:03:33 <ocharles> A book can have a publisher, but in the database the book row only stores the primary key of the publisher. So I have data Publisher = Publisher { id :: Int, ... } | PublisherReference { id :: Int }
17:03:48 <Peaker> also you can export a book constructor in IO, btw
17:04:10 <ocharles> so a book is now data Book = Book { publisher :: Publisher }, and starts out as a PublisherReference, and later gets "loaded" into a Publisher, if I happen to need all that info
17:04:17 <Peaker> Is Publisher sort of a cached-derefed PublisherReference?
17:04:40 <Peaker> aha.. you could probably generalize that notion
17:04:49 <ocharles> well at the moment, I have loadPublisher :: Book -> Book, which does a DB lookup for a publisher with the pk stored in the book
17:04:55 <ocharles> and stuffs the publisher back into a new book
17:05:13 <Peaker> something like:   Cached ref data = (ref, Maybe data)
17:05:54 <Peaker> ocharles: isn't it:  loadPublisher :: Book -> IO Book?
17:05:59 <ocharles> yea, sorry
17:06:10 <ocharles> How does that stop my functions being partial though? Surely now they are just partial over Just data?
17:06:16 <Peaker> ocharles: IMO you're underusing types..   Your types should distinguish "loaded" and "not-loaded"
17:06:31 <ocharles> oh I definitely agree, I just don't know enough to be able to express want I want :)
17:06:40 <ocharles> I really want type checking to say "hey buddy, you didn't even load the publisher!"
17:06:50 <Peaker> ocharles: well, for loadPublisher I would use a type like:    Book -> IO Publisher   why return a Book?
17:07:26 <Peaker> hmm. you obviously have a lower-level function   loadPublisherId :: PublisherId -> IO Publisher      right?
17:07:28 <ocharles> well, loadPublisher :: Book -> IO Book is implemented in terms of getPublisher :: PublisherId -> IO Publisher
17:07:37 <ocharles> it's just convenience atm
17:07:37 <Peaker> and Book -> PublisherId   is a trivial record accessor
17:07:42 <ocharles> yea
17:07:57 <Peaker> so   getPublisher . bookPublisher      is pretty convenient :)
17:08:18 <ocharles> well, I usually want to put it into a Book object again
17:08:22 <Peaker> why?
17:08:28 <Peaker> why not pass (Book, Publisher) around for that?
17:08:31 <ocharles> because my templates take Book -> Html
17:08:50 <Peaker> if they need both the Book info and the publisher info -- why not have both as input?
17:09:04 <Peaker> IOW, if they want a "loaded book" value, why not represent it as a (Book, Publisher) ?
17:09:07 <ocharles> dunno, felt easier to keep everything together
17:09:16 <Peaker> keep it together, in a tuple :-)
17:10:23 <ocharles> well, in practice I have more references between objects
17:10:54 <ocharles> an edition has 3 author credits (illustrator, translator, author), a language, a country, and a publisher. author credits consist of multiple person references
17:11:08 <Peaker> ocharles: Maybe you can make a reference lookup monad -- and compose your Html in that monad?  that way you can work without pre-loading all of the id's
17:11:19 <ocharles> it just felt like using tuples stuff would start to get pretty complicated
17:11:29 <Peaker> ocharles: hmm.. I see another interesting option
17:11:44 <ocharles> Peaker: my views (templates) don't have any IO access at all, and I'd kinda like to keep it that way
17:11:51 <Peaker> Imagine this:  data Book ref = Book { info here ... ; publisher :: ref Publisher }
17:12:09 <Peaker> ocharles: I'm suggesting a different monad, not IO, one that can only do lookups of id's
17:12:16 <ocharles> i see
17:12:24 <Peaker> ocharles: (implemented in terms of IO, but that's invisible to its users/readers)
17:12:30 <ocharles> but a lookup of ID is still hitting caches and databases, right?
17:12:47 <ocharles> do continue, maybe I can be persuaded :)
17:13:03 <Peaker> ocharles: Yeah, you can use a local cache -- your Book sum type is a sort of local cache anyway :)
17:13:19 <Peaker> but all that was idea #1..  idea #2 involves the parameteric ref type
17:14:19 <Peaker> data Book ref = Book { ... info ... ; publisher :: ref Publisher }        then you can have   ref = DBRef         so DBRef a   is basically an Id that finds an "a" in the database
17:14:39 <Peaker> ocharles: but you can also do a conversion of Book DBRef -> Book Identity
17:14:46 <Peaker> ocharles: so all these "refs" disappear
17:14:59 <Peaker> oh wait, that was wrong
17:15:02 <ocharles> is Identinty in prelude?
17:15:13 <Peaker> no it's in Control.Monad.Trans.Identity in transformers
17:15:17 <Peaker> or somewhere else in mtl, iirc
17:15:18 <Peaker> data Book ref = Book { ... info ... ; publisher :: ref (Publisher ref) }
17:15:24 <ocharles> ok, I use mtl anyway, that's fine
17:15:29 <Peaker> actually this is problematic -- it would dereference the *entire* graph :)
17:16:53 <Peaker> I think the "right" thing to do is find a data-type that truly encodes the subset of the data that your Html wants.  If you really can't do that (don't want to restrict the Html from arbitrary db traversal), then you can use the IO monad wrapper -- so Html rendering can traverse the DB, but only traverse
17:17:15 <Peaker> (and not do IO in general)
17:17:52 <Peaker> ocharles: what do you think? Is there a way to describe the actual data needed by your html generators as a type? or is that too restrictive and they should have free access to the Db?
17:18:05 * ocharles parses questions
17:18:31 <ocharles> well I don't tend to like letting my views do anything where I can, so I'd *like* to go down the type path, for sure
17:18:58 <ocharles> it may help if you see the schema I have atm
17:19:01 <Peaker> Maybe your Html generating function just needs a Book, publisher, and 3 other things, regardless of references?
17:19:55 <ocharles> yea, but then when I need a list of books, then I'm suddenly passing [(Book, Publisher)] - and what if Book's need something else? Then I have to fix my list function, and my individual book function
17:20:10 <ocharles> I guess that's my concern for using separate stuff - the repetition
17:20:35 <Peaker> well, you can make a type (or synonym) for the "Book + associated data" if that makes sense
17:20:38 <drbean> scfp
17:20:40 <ocharles> https://github.com/ocharles/BookBrainz/tree/master/src/BookBrainz/Types types and such are here - Edition is the most "complex" so far
17:20:46 <ocharles> yep, that makes perfect sense
17:21:39 <rekahsoft> hi all..just looking for a explanation to the code on http://rosettacode.org/wiki/Sorting_algorithms/Bubble_sort#Haskell
17:22:04 <Peaker> ocharles: do you dereference the whole reference graph of a book before generating html? or would that fetch the entire db?
17:22:19 <rekahsoft> specifically on the 3rd line "t | t == s    -> t"
17:22:42 <ocharles> hrm, not the whole DB, but it could be quite a chunk
17:22:57 <rekahsoft> what is the first t doing there? i don't see it anywhere else and i did not know that case expressions could take that form?
17:23:25 <ocharles> Peaker: I wonder if I'm just worrying too much atm, and should do as you suggest (not link entities in data types and pass them in tuples), and see if it's *actually* a problem
17:23:30 <ocharles> and if so, I can always hit up the cafe
17:23:33 <rekahsoft> would i read it like in math? t such-that t == s
17:24:03 <fazzone> Is there an easier way to drop elements off the end of a list than \xs n -> take (length xs - n) xs ?
17:24:31 <jmcarthur> fazzone: reverse . take n . reverse
17:24:49 <jmcarthur> fazzone: but i'd question why i'm dropping things from the *end* of a linked list, unless it's known to be a short list
17:24:52 <Peaker> ocharles: I think fundamental correctness should always precede convenience.. convenience is almost always possible with correctness -- but if you strive for it first, it's hard to also get correctness
17:25:04 <jmcarthur> fazzone: i meant drop, not take
17:25:08 <ocharles> a very fair pov
17:25:09 <jmcarthur> reverse . drop n . reverse
17:25:39 <fazzone> Hm, interesting
17:25:41 <ocharles> Peaker: so, onto the gid problem again. you'd suggest leaving that out the main Book data type?
17:25:49 <ocharles> how would I sum the data together later?
17:26:06 <jmcarthur> > reverse . drop 5 . reverse $ "hello world!"
17:26:07 <lambdabot>   "hello w"
17:26:11 <ocharles> say I have a UUID, and the rest of the Book, from my getBookById function or something
17:26:24 <Peaker> ocharles: Maybe it would make more sense to have a:  data WithGid a = WithGid { gid :: Gid, info :: a } ?
17:27:10 <hpc> (Gid, a)?
17:27:18 <Peaker> ocharles: then you can have a:   getInfo :: WithGid a -> a     and maybe even:  fromGid :: InDatabase a => Gid -> WithGid a
17:27:24 <ocharles> hrm, then I'm passing a WithGid Book to my templates... so to display the majority of information I'm always going to have to compose info at the start
17:27:40 <Peaker> hpc: that's an option too :-) but you might want to make it an instance of classes or what not
17:28:00 <Peaker> ocharles: if your templates don't do db access, why do they need the gids?
17:28:07 <ocharles> (Gid, a) and WithGid a feel isomorphic, with info == snd
17:28:11 <ocharles> if my terms are right :)
17:28:14 <Peaker> ocharles: yeah
17:28:29 <ocharles> Peaker: gid's are how books are linked together
17:28:30 <Peaker> ocharles: a new data type is nice in terms of documentation, potential instances of type-classes, etc
17:28:40 <Peaker> ocharles: but gid's are only useful in the context of db access, aren't they?
17:28:46 <Peaker> ocharles: a context you're trying to avoid for your templates?
17:28:46 <ocharles>  /book/{gid} forms the basis of all urls
17:28:53 <Peaker> Oh, for URLs
17:28:58 <ocharles> Peaker: not at all, most db access is done by id, not gid
17:29:05 <Peaker> ocharles: I see
17:29:26 <ocharles> but yea, gid's are mainly used in urls, otherwise they are hidden
17:29:44 <Peaker> ocharles: So maybe you might want to throw the "type" (like "book") into the WithGid as well, so you can do:  withGidToUrl :: WithGid a -> URL
17:29:49 <rekahsoft> also just to be complete i was correct with my assummtion above..
17:30:35 <ocharles> Peaker: don't we already have that?
17:30:48 <Peaker> rekahsoft: you can read it like that -- yeah
17:30:49 <ocharles> I mean it was "WithGid a" before anyway
17:31:18 <Peaker> rekahsoft: the pattern match "t" matches anything and puts it in "t".  The | t == s   is called a "guard" and only if true it evaluates to the right side of that
17:31:29 <Peaker> rekahsoft: otherwise=True,  so the | otherwise   is always taken
17:31:45 <Peaker> ocharles: no no, I mean something like:
17:32:06 <Peaker> data WithGid a = WithGid { urlPrefix :: String, gid :: Gid, info :: a }
17:32:32 <Peaker> ocharles: so for Books urlPrefix would be "book" so it can generate /book/{gid} and you don't need a URL generation function for each type of thing, just re-use this one
17:32:54 <ocharles> I was hoping to move to web-routes for url generation in the future, so I haven't really given that stuff much thought
17:32:57 <Peaker> Or, you can have the previous WithGid (without urlPrefix) and have:
17:33:16 <Peaker> toURL :: URLPrefix a => WithGid a -> URL
17:33:27 <ocharles> that's quite nice, yea
17:34:05 <ocharles> but, still, all over my templates I now have: H.h1 $ toHtml $ (bookTitle . info) book
17:34:14 <Peaker> ocharles: so a bunch of lists/tuples into the template with WithGid'd Books/Publishers/etc works?
17:34:40 <ocharles> but I guess I could just let book' = info book, but all templates would have that, so again - repetition leaving me uneasy
17:34:42 <Peaker> Also makes it nice to have a single:   generateGid :: a -> IO (WithGid a)
17:35:06 <ocharles> Peaker: I think we're getting there, for sure :)
17:35:38 <Peaker> ocharles: or you could have:  data Book = Book { field1 :: ... , field2 :: .. }   infoField1 = field1 . info
17:35:47 <Peaker> ocharles: and a boilerplate accessor for each record field
17:36:02 <Peaker> ocharles: that way the Book fields are as easy to use as   WithGid Book   fields
17:37:02 <ocharles> mmm, I know it's perfectly doable. but it feels like my code would be much easier to read if bookTitle always got a book title, no matter if it had a gid or not
17:37:30 <Peaker> ocharles: why not *always* use WithGid Book, so bookTitle is  WithGid Book -> Title ?
17:37:43 <ocharles> hrm
17:37:51 <ocharles> yes, I don't suppose I'd ever have a book *without* a gid
17:38:14 <Peaker> ocharles: the only place you'd have a Book is when you're constructing a new one, and then there's little point to calling bookTitle
17:38:42 <ocharles> well, it could be quite nice to have the create form move to a confirmation page, which has a Book to preview, but not a WithGid Book
17:39:05 <Peaker> what URL would you generate for such a preview book?
17:39:08 <ocharles> and being able to a generic "summariseBook" function would be a good way for users to see how it will appear when they submit
17:39:43 <ocharles> I guess /book/add submits to /book/preview which submits to /books and redirects to /book/{gid}
17:39:54 <Peaker> If your only use of the gid is to generate url's, you might as well use   WithURL in place of WithGID, then you can have a WithURL Book even before you have a gid
17:40:41 <ocharles> I like WithGID more, because it keeps that code separate from the idea of a website
17:41:09 <Peaker> if it has more uses, you can make a WithGID and a WithPreview as two separate data-types, and have a ToURL/Unwrap type-classes for both so none of the access assumes its a WithGID specifically.
17:41:40 <Peaker> Unwrap=Copointed actually :)
17:42:23 <ocharles> heh, haven't got to copointed in the typeclassopedia yet
17:42:25 <Peaker> The types may become a bit annoying:  (Copointed f, URLGenerator f) => f Book -> ...         (instead of WithGID Book)
17:42:38 <Peaker> do you know Applicative?
17:42:42 <ocharles> yea
17:42:46 <Peaker> If you split it into    "pure"   and   <*>
17:42:59 <Peaker> then pure  is alone in its own type-class called "Pointed"
17:43:24 <Peaker> and copure or extract :: f a -> a    is in a typeclass called "Copointed"
17:43:31 <Peaker> (opposite of pure)
17:43:33 <ocharles> ah
17:43:43 <Peaker> so WithGID would be an instance of Copointed
17:43:51 * ocharles nods
17:44:08 <ocharles> where extra = info
17:44:16 <ocharles> extract*
17:44:19 <Peaker> yeah
17:44:39 <Peaker> anyway, if you wanted to have both   WithGID Book   and work with that,   and  Preview Book       then you'd need some type-classes
17:44:55 <Peaker> (CoPointed and URLGenerator  sound like all you need from both)
17:45:17 <ocharles> so far I think I just need a instance Copointed WithGID
17:45:23 <ocharles> I'm leaving the URL stuff because I want to think about that more
17:45:24 <Peaker> btw: Why are DB id's and URL GID's different?
17:46:05 <Peaker> why not have a single id type?
17:46:07 <ocharles> mostly because GID is a stable identifier to talk about a book. say a user submits Harry Potter, and someone else later submits it again. They have 2 gids. But they are the same book, so they get merged, and the latter GID redirects to the former
17:46:33 <ocharles> I have been considering dropping id in this schema entirely though
17:46:48 <ocharles> but it means working in views in the database more (inorder to resolve the merged gid into the final gid)
17:47:00 <Peaker> ah.. but maybe the right thing to do is have an extra layer of indirection -- without an extra type?
17:47:16 <ocharles> right thing to do where?
17:47:26 <Peaker> in your schema
17:48:05 <Peaker> have a db entity BookRef that has its own id, and refers to a Book.. Users make Books and BookRefs.. When you "join" two books, you delete a Book, but keep the BookRefs, and adjust them to point to the same book
17:49:14 <ocharles> that's basically what we have now, except your moving the gid to a separate table I think
17:49:41 <ocharles> when 2 books are merged, it adds a row in book_gid_redirect, which is old_gid -> book_id
17:50:07 <ocharles> except you are proposing book_gid_redirect exists for all books, with merges or not
17:50:28 <Peaker> well, it also means there are no "ids" and "gids", just "ids"
17:51:33 <Peaker> And then you can have simpler types:  Ref a    can contain an "id" in it (usable as a URL or as DB key), that leads to an "a"
17:52:22 <ocharles> ok so far... but it sounds the same as WithGID a
17:52:36 <Peaker> it's just a pure reference (has only an id in it)
17:53:04 <Peaker> then   WithId a    is like a    Ref a     except it also has the dereferenced "a" in it.. Though maybe that's not useful anymore, if you have Ref
17:53:27 <Peaker> ocharles: if you have WithGID Book,  you still have the pesky "Id" in there to identify publishers/etc
17:53:37 <Peaker> ocharles: and these Ids are unsafe -- what if you look them up in the wrong table?
17:53:41 <joe6> > unwords $ sepBy "," "test,test1,test2\ntest3,test4"
17:53:42 <lambdabot>   Not in scope: `sepBy'
17:53:53 <Peaker> ocharles: Better wrap the Id with:  data Ref a = Ref { id :: Id }  -- a is a phantom type
17:53:56 <joe6> is there a better way of doing this? I am replacing the commas with spaces
17:53:58 <ocharles> they are typed by table, PublisherId vs CountryId
17:54:10 <joe6> > unwords $ Data.List.Split.sepBy "," "test,test1,test2\ntest3,test4"
17:54:11 <lambdabot>   Not in scope: `Data.List.Split.sepBy'
17:54:12 <ocharles> so you can't do getCountry $ bookPublisher book
17:54:33 <ddarius> map (\c -> if c == ',' then ' ' else c)
17:55:12 <Peaker> ocharles: well, that requires a db lookup in the general case anyway
17:55:33 <ocharles> Peaker: oh, I'd forgotten about phantom types... must remember that in my arsenal of haskell trickery :)
17:56:06 <Peaker> ocharles: Using phantom types to tag your id's as Book ids, Publisher ids, etc can give you perfect type-safety in your db access
17:56:26 <ocharles> i thought I had that with BookId, PublisherId and such anyway though?
17:56:26 <Peaker> ocharles: especially if you make the phantom type an instance of a type-class that decides which Db table to go to
17:56:42 <ocharles> that's pretty nice..
17:56:42 <joe6> ddarius, thanks. that is definitely simpler
17:56:42 <Peaker> ocharles: oh, didn't know yo uhad those
17:56:55 <ocharles> so Peaker, I have to sleep soon, I'm going to type up how things change with WithGID, maybe you want to review that if you have time?
17:56:59 <ocharles> will take me a few mins to type up
17:57:12 <Peaker> ocharles: but if you have those, you have the problem of accidentally using a BookId to get a Publisher, whereas with   Ref a   you have:  getRef :: Ref a -> IO a    so no such danger
17:57:34 <ocharles> Peaker: BookId is a newtype, not just a type, so I don't think that's possible?
17:57:39 <Peaker> ocharles: I am way past my bed time too, gonna go to sleep now, I think.. maybe tomorrow you can come again?
17:57:49 <BMeph> ddarius: Now, can you rewrite that function so it doesn't use those Horrible binary comparisons? ;)
17:57:51 <ocharles> sure, I'm here all the time, we have #bookbrainz too
17:57:56 <ocharles> (same network)
17:58:03 <ocharles> #bookbrainz-devel, sorry
17:58:04 <Peaker> ocharles: BookId is safe -- but the association of it with Book is not spelled out in the type system
17:58:11 * ocharles nods
17:58:18 <Peaker> ocharles: whereas   Ref Book   is associated with Book
17:58:24 <Peaker> (and also distinguished from Ref Publisher/etc)
17:58:31 <ocharles> nice, that's pretty cool
17:58:49 <ocharles> Ohhhh, I see. so my get function is actually using the type to decide what it should return
17:58:58 <ddarius> Phantom types have a high power-to-weight ratio.
17:58:58 <Peaker> ocharles: also, you probably have a lot of duplicate code with BookId, PublishedId, etc that can be de-dup'd
17:59:06 <ocharles> I sure as hell do, and hate it
17:59:13 <ocharles> massive penny dropping here, I'm sold on this idea :)
17:59:22 <Peaker> ocharles: :-)
17:59:31 <Peaker> ocharles: btw: I had very similar problems in my project
17:59:35 <ocharles> I think I *might* expand to Ref a b = Ref { key :: a } too
17:59:49 <ocharles> so I could Ref (Int, Int) Book, if Book has multiple columns for a key
18:00:22 <ocharles> but that's not needed yet, but it seems like it may be useful in the future
18:00:29 <Peaker> ocharles: I'm not inventing all these ideas on the spot... :-)  https://github.com/Peaker/datastore   is a transactional key/typed-value DB.. My   IRef a   type is basically the Ref type
18:00:46 <ocharles> sweet, more code to read too :)
18:00:46 <Peaker> ocharles: Then YAGNI it for now :)
18:00:51 <ocharles> yea, sure
18:00:58 <ocharles> I'm just poking it to see how it will scale
18:01:07 <ocharles> I'm trying to design my db's these days without surrogate keys, where I can
18:01:27 <Peaker> datastore is mostly about revision control, btw
18:01:53 <ocharles> interesting, this projcet will have revision control...
18:01:57 <ddarius> ocharles: Why?
18:02:00 <ocharles> (books need a history of changes)
18:02:21 <Peaker> ocharles: datastore is very experimental and cannot merge yet.. I was planning on reading more about darcs before getting to that
18:02:35 <ocharles> ddarius: much truer to the relational model, plays better with duplicate rows, lots of reasons
18:02:48 <ocharles> ddarius: search "keyvil" on google, there's some good slides there
18:02:56 <Peaker> It's part of a structural-versioned editor I started working on, the github packages are: https://github.com/Peaker/datastore  https://github.com/Peaker/datastore-vtywidgets https://github.com/Peaker/vtywidgets https://github.com/Peaker/treeedit
18:03:36 <ocharles> nice, brain certainly saturated with ideas for today, but will have a look when I get some free time, maybe the weekend
18:04:05 <Peaker> every little UI gesture you do in the editor is translated to an immediate DB transaction that's committed
18:04:28 <Peaker> and if you're willing to commit asynchronously (and at worst lose a few seconds of work) then there's no performance issue with this
18:04:35 <Peaker> but it's fun -- no "save" button, it's always "saved"
18:04:38 <ocharles> i'm gonna have to have a look at this, because it's *very* similar to some research I've been doing myself
18:04:58 <ocharles> my work has been more looking into seeing if I can model a persistent graph in the db, but I haven't quite worked it all out yet
18:05:02 <Peaker> Silly "save" buttons are one of my pet peeves with current day computing
18:05:19 <Peaker> ocharles: well, using a Ref type like above, it's a piece of cake
18:06:06 <ocharles> Peaker: it's more the actual db schema I fell down on
18:06:33 <Peaker> ah, I've never really done any serious db work
18:06:58 <Peaker> I don't know much about db's (in terms of relational stuff, acid properties, eventual consistency, nosql).. just the general terms
18:08:15 <Peaker> in the age of the scaling web application -- db work seems an important hole in my experience...  But sql has never appealed to me.   I also dislike the approach of other db's of having an ad-hoc/arbitrary set of data types to use
18:08:35 <ocharles> I recommend reading the Third Manifesto
18:09:00 <ocharles> I dunno how much you know about the real theory behind db's, but the proper actual stuff is quite different to how SQL actually turned out
18:09:03 <Peaker> I think if there's a problem ping-ponging between db client and db backend, then ideally, the computing environment would migrate the code to the backend side
18:09:47 <Peaker> http://www.thethirdmanifesto.com/  looks terrible :)
18:09:56 <ocharles> academia 101 :P
18:10:20 <ocharles> C.J. Date's books are good though
18:10:30 <Peaker> well, good night, good luck!
18:10:39 <ocharles> thanks a bunch! you too :)
18:11:58 <ddarius> ocharles: Reading the first and third article, I see only "don't be an idiot."
18:22:57 <gwern> @quote
18:22:57 <lambdabot> pjdelport says: qwe1234, boldly defining where no man has defined before!
18:23:09 <zmv> @protontorpedo
18:23:09 <lambdabot>  and is haskell ez to debug?
18:23:15 <ion> @quote
18:23:15 <lambdabot> Ferdirand says: I was TA for a C++ programming course aimed at 1st year physics once. Some girl asked for help "i wrote pseudo-code but I cannot translate it to C++". Her pseudo-code was valid
18:23:15 <lambdabot> haskell. I cried.
18:23:55 <cafesofie> i don't believe it
18:30:53 <Cale> for simple enough code, that's almost believable
18:31:33 <Cale> (though probably the translation into C++ wouldn't be hard in those cases, if you ignore the fact that most C++ implementations suck wrt recursion)
18:36:52 <ddarius> But was it correct Haskell code?
19:31:33 <bobzhang> hi, how to set up hoogle to show only the first 10 items? thanks
19:35:59 <parcs> hoogle | head
19:44:06 <russruss> so, I'm trying to learn some web programming with haskell for fun - I'm wondering if a lot of what seems clunky to me about haskell vs the un-type-checked languages often used for this stuff is a lack of support for dependent types - i.e. a path that makes a lot of sense for web programming is getting a complex, nested value encoded as a string, unpacking that into a native type, performing some check on that native type such that yo
19:44:06 <russruss> it's acceptable, and then checking the value and performing whatever logic on it.  The step of going from an encoded string to a native type, in a type-checked language, seems like it wants dependent types.  Does this make sense to anyone?  Am I missing something?
19:46:07 <Axman6> russruss: read "12345" :: Int works just fine, so it seems obvious to me that dependant types aren’t necessary
19:46:29 <russruss> well, Int isn't a nested type, right?
19:47:00 <Axman6> I'm not sure why that matters
19:47:11 <russruss> like take any of the Json libraries for haskell, these go from string -> JSValue or whatever
19:47:12 <russruss> bu
19:48:17 <russruss> t then if the JSValue is supposed to represent say, ((String, [(String,Int)], (String, Int), (String, String))
19:48:47 <russruss> there's no simple mapping from that JSValue to the type it really is supposed to represent
19:49:12 <Axman6> but no one wants anything of that type
19:49:25 <Axman6> JSValue is a much easier way to work with things
19:50:46 <ddarius> You can also just have a class: ParseJson with a method JSValue -> a.
19:51:04 <russruss> yeah but you have to make that for each type
19:51:04 <Axman6> or, more safely Maybe a
19:51:13 <Axman6> not really
19:52:01 <ddarius> russruss: If you have a generic scheme, you can easily encode that as well.  Otherwise there is no way to avoid making that for each type, or maybe you meant for things other than JSValue.
19:52:31 <russruss> well, can you easily encode it?  I'm not sure how :-P.  I'm definitely a beginner
19:52:35 <ddarius> Though you still have to say how you want to parse out a whatever one way or another.  The computer can't read your mind.
19:53:12 <ddarius> (Actually, I should say -your- computer -probably- can't read your mind.)
19:53:32 <russruss> I mean, so Json has this concept called a "Map" which maps from a string to some other type of JSValue, or maybe another map
19:54:08 <Axman6> sure, which is easily represented as Map String JSValue
19:54:10 <russruss> so I mean I'm not sure of an easy way in haskell to correctly parse a map into a generic list of pairs of strings to whatever the Json encoded
19:54:26 <russruss> Well, that's not really what you want because you've only parsed one layer
19:54:39 <russruss> it's still not a "native type" if you ask me
19:55:23 <russruss> or, heterogenous list I suppose I should say
19:55:32 <Axman6> but it should be pretty trivial to do things like define a function: getInt :: String -> JSValue -> Maybe Int, where the String is a path to the selected Int
19:56:06 <Axman6> or [String] if you prefer
19:56:59 <russruss> yeah, I mean it's not hard it's just clunky compared to the un-type-checked languages that are usually used for web programming
19:57:10 <ddarius> russruss: JSValue is more "native" than a bunch of nested maps and strings.  Well, it is a bunch of nested maps and strings.
19:57:43 <pcavs> so what's the current workaround, if any, for install haskell-platform on ubuntu natty?
19:58:02 <ddarius> pcavs: Just cabal-install everything.
19:58:39 <pcavs> cabal-install?
19:58:53 <pcavs> ddarius: excuse my noobhood =D
19:59:06 <Axman6> russruss: by using JSValue, you get much better type safety
19:59:17 <Axman6> @google cabal-install
19:59:19 <lambdabot> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
19:59:19 <lambdabot> Title: CabalInstall – Hackage
19:59:35 <Axman6> your distribution should have a package for it
20:00:12 <russruss> well, I wasn't saying anything bad about type safety :-)
20:00:31 <amsl> What do people usually mean when they say they're "inside" a monad?
20:00:54 <kmc> that they have a bunch of functions returning type M T for M a monad
20:00:58 <kmc> but it might be a sign they're confused
20:01:00 <russruss> but it's still less convenient I think than without the type safety
20:01:13 <ddarius> Also, since json values (and JSValue) are essentially untyped, it's not very surprising that there is an impedance mismatch getting it into a typed setting.
20:01:21 <Axman6> russruss: sure, but crashy webapps aren't cool
20:01:23 <kmc> yes, static types make writing programs less convenient
20:01:30 <russruss> well, if you had dependent types I think it would be just as easy
20:01:30 <kmc> in particular, they make writing incorrect programs less convenient
20:01:36 <ddarius> Axman6: The evidence is against you my friend.
20:01:42 <russruss> haha
20:01:46 <Axman6> russruss: how would dependant types help?
20:01:54 <Axman6> ddarius: yeah :(
20:01:54 <kmc> type system goodness is measured by the degree to which they make incorrect programs proportionally /more/ inconvenient
20:02:10 <ddarius> kmc: s/type system/language/
20:02:54 <kmc> i think there is more room for disagreement about what makes a language good
20:03:27 <russruss> right well then you just have the json return what it actually encodes, and then you perform verification that its type is acceptable for your operation and then you do your operation
20:03:29 <kmc> also there are in fact other things that make a type system good
20:04:07 <ddarius> russruss: The computer doesn't know what the json "actually encodes."  You have to tell it somewhere, someway.
20:04:40 <russruss> well, no, I mean it actually is encoding a heterogenous list of pairs of strings and other values
20:04:42 <ddarius> The getting the json from a string and then an untyped tree to "what it actually encodes" is where the type mismatch is.
20:04:45 <russruss> what that encodes is another story
20:04:54 <ddarius> russruss: That's what the json library does.
20:04:57 <ddarius> JSValue is that.
20:05:48 <russruss> well, fair enough
20:06:25 <russruss> I mean it seems a bit pedantic to use JSValue for that rather than a full heterogenous list
20:06:49 <russruss> because if you have utilities that work on heterogenous lists, now you have to rewrite them from scratch to work with JSValue trees
20:07:19 <russruss> but I can see why that would be considered a plus I suppose
20:07:42 <Axman6> in haskell, you don't have utilities that work on heterogeneous lists
20:08:11 <russruss> well, for typeable there is right
20:08:48 <Axman6> well, sort of. but that should not be considered as much more than a hack.
20:09:02 <pcavs> ddarius: What would I need to cabal-install ?
20:09:08 <Axman6> sure there are some places where it's useful, but it's not something you should be using in everyday programs
20:09:15 <pcavs> ddarius: to replicate haskell-platform package?
20:10:26 <russruss> and I mean I do still take issue with the assertion that [(String, JSValue)] is really what the json encodes
20:11:03 <russruss> like depending one the value of the json it might encode ((String, Int), (String, String)) or ((String, Bool), (String, Int))
20:11:03 <liyang> Map String JSValue?
20:11:25 <russruss> and whether or not that's a convenient type to represent in Haskell doesn't change the fact that there are actual heterogenous types encoded into json
20:11:57 <russruss> so I guess like if you checked type equality of the two types I mentioned above, if you represented them as Map String JSValue, their type would be identical
20:12:07 <russruss> even though the type that's encoded in the json is definitely not identical
20:12:18 <Axman6> i disagree. they're not heterogeneous, they're restructed to strings, numbers, lists, and maps. and that is nicely encoded in JSValue
20:12:22 <russruss> so in a real sense I think it is a dependent type
20:12:39 <Axman6> restricted*
20:12:44 <russruss> I totally agree that in haskell JSValue is a convenient way of encoding them
20:12:59 <russruss> but like in some platonic ideal sense they aren't MapString JSValue
20:13:14 <Axman6> how are they not?
20:13:28 <Axman6> maps in json are maps from strings to other pieces of json
20:13:41 <russruss> like {"hello" : false, "john" : 7} is *not* the same type as {"hello" : 8, "john" {"bob: 2}}
20:13:53 <russruss> those are values of different types to me
20:14:27 <russruss> one is ((String, False), (String, Int)) and the other is ((String, Int), (String, (String, Int)))
20:15:03 <russruss> and the fact that it's inconvenient to represent them as those types in haskell to me doesn't mean that somehow that's not what they represent
20:15:34 <Axman6> so you think the type should depend on the structure you get back? because, especially in web programming, you cannot guarantee you'll get the data you're expecting. then what should happen?
20:15:54 <russruss> well, right so if it's not valid JSON it's a TypeError
20:16:21 <Axman6> but that relies on runtime type checking
20:16:31 <russruss> or dependent types ;-)
20:16:46 <Axman6> i believe dependant types don't exist at runtime either
20:17:49 <copumpkin> they can
20:17:53 <copumpkin> there's not a clear separation
20:18:10 <russruss> well, I mean the problem is that there's not a lot of practical dependently typed languages as I understand it
20:18:41 <russruss> I've never used one but I have to imagine there's a good reason why
20:18:57 <copumpkin> a good reason why what?
20:19:00 <Axman6> i honestly do not think that dependant types are at all the right tool for this job. there's a much easier and clearer way to accomplish the task without them
20:19:10 <russruss> why I've never heard of a practical dependently typed language
20:19:33 <copumpkin> agda's quite usable, but I guess it depends what you want it for :)
20:19:35 <Axman6> there's Agda
20:19:37 <russruss> Axman6: I'm not sure.  I mean is some philosophical sense like you're receiving a value of an unknown type from the Json
20:19:41 <wli> Finally got a chance to sit down and ... got to get up first thing in the morning, no time to think about code.
20:20:03 <russruss> so it would be nice to encode it as such
20:20:07 <Axman6> russruss: but it's not an unknown type, it's a piece of json, and that is easily well typed
20:20:09 <wli> I don't think Cayenne made it. Agda I've never tried.
20:20:18 <copumpkin> russruss: it's not like you can control what you get fed any more in a DT language though
20:21:10 <copumpkin> you'd have something like ExternalInput -> Maybe SomeCleanTypeThatILikeToDealWIth
20:21:21 <russruss> well, sure - but it would be nice to represent these type verifications as what they are
20:21:23 <copumpkin> which you can do in haskell too
20:21:55 <wli> Dimensionality conformance or whatever for linear algebra would be a nice thing to do with the limited dependent type affairs going around. Unclear whatever happened to those efforts, since I thought they were going somewhere.
20:21:57 <russruss> because often you're in a situation where you want to check that the type you receive is compatible with a type that you are expecting
20:22:22 <copumpkin> do you have a specific situation in mind?
20:22:42 <russruss> well, not that specific :-P
20:22:58 <russruss> I mean a situation that comes up a lot in web programming is you have a schema for types that you will receive
20:23:01 <russruss> and then you receive a value
20:23:17 <russruss> and you want to know if it matches your schema or not, and if it does fit it into your schema
20:23:33 <nus> russruss, the question is what you want to do when the expectation doesn't match reality, bail out or rearrange your expectations?
20:23:44 <monochrom> from arbitrary string to checked structured data - that's just parsing
20:23:45 <Axman6> it wouldn't exactly be hard to write a matchesShape :: JSValue -> JSValue -> Book function
20:23:49 <Axman6> Bool(
20:23:50 <russruss> in haskell you generally encode the schema as a Maybe or Either monad, which is really a style that feels clunky to me because it's not declarative
20:24:23 <Axman6> eh?
20:24:40 <russruss> in a non-typed language you'd have a schema object (which in some sense is a type object), and then you have a function that takes the value you receive and the schema object and fills in the schema
20:24:41 <copumpkin> russruss: you'd do the same kind of thing in a DT language
20:25:06 <copumpkin> what the DT gives you is the ability to provide a more precise type for the kind of structure you want to process
20:25:15 <copumpkin> so something like "this list must be ordered"
20:25:25 <russruss> well, right, or "this much match this schema"
20:25:26 <russruss> or nothing
20:25:28 <copumpkin> (although even stating something like that is a bit of a pain)
20:25:34 <monochrom> no, I don't encode the schema as Maybe or Either. the parser is like ByteString -> Maybe MyData, sure. my schema is MyData, not Maybe MyData. Maybe MyData is just for the parser
20:25:37 <russruss> and then by the time you match it you know it's in your schema
20:25:42 <copumpkin> well, many typical schemas (schemata?) can be expressed easily in haskell
20:25:55 <copumpkin> you only need DT for odd interactions
20:25:55 <russruss> I'm not saying mine aren't
20:26:11 <russruss> it's just that you're expressing them functionally when it feels like really they are types
20:26:16 <russruss> or at least could be types in a DT language
20:26:25 <monochrom> in a non-typed language I just raise an exception
20:26:29 <russruss> I guess really I don't know what I'm talking about :-P
20:26:38 <copumpkin> I guess what I'm saying
20:26:42 <monochrom> you also haven't coded up anything
20:26:59 <copumpkin> is that in haskell, I'd write "data MyJSONRep" and a function Input -> Maybe MyJSONRep
20:27:16 <copumpkin> in agda I'd write a more precise data MyJSONRep and a function Input -> Maybe MyJSONRep
20:27:26 <copumpkin> :P
20:27:35 <russruss> fair enough
20:27:37 <monochrom> yeah, the parser has the Maybe. that's it
20:27:38 <russruss> is agda good?
20:27:44 <copumpkin> I use it all the time
20:27:49 <copumpkin> that doesn't necessarily mean much though
20:28:05 <monochrom> people philosophize too much
20:28:06 <copumpkin> some people are snobby about it
20:28:08 <russruss> well, I mean what I really want is something where you have a Maybe (MatchesJSONSchema Schema)
20:28:41 <copumpkin> okay, yeah, if you have an abstract representation of schemas
20:28:43 <copumpkin> you could write that in agda
20:28:45 <copumpkin> and not in haskell
20:28:52 <russruss> right that's what I'm talking about
20:29:02 <russruss> that seems super useful to me
20:29:04 <copumpkin> at least not easily in haskel :)
20:30:06 <monochrom> the Maybe is still just for the parser
20:32:02 <Axman6> i still don't see any reason why this needs to be a the type level, it's purely about data
20:32:27 <copumpkin> well, you want to statically prevent any invalid data from being passed to later stages
20:32:37 <copumpkin> then you can avoid threading maybes through your entire program and so on
20:32:42 <copumpkin> or evil runtime errors
20:33:09 <wli> I think I may have what may just be a non-convex quadratically-constrained quadratic program.
20:33:27 <Axman6> but checking that the schema matches what you expect is trivial
20:34:08 <monochrom> the "case" expression already eliminates threading maybes through my entire program
20:34:08 <nus> russruss, in 'Maybe (MatchesJSONSchema Schema)' what is 'Schema' supposed to be?
20:35:58 <Axman6> i believe something like ((String, Int),(String, (String, Int)))
20:38:10 <nus> how is that different from Maybe Schema?
20:38:55 <copumpkin> YOU CAN LOAD THE SCHEMA FROM A FILE :P
20:39:23 <copumpkin> note that you could still do something similar (probably in a more limited fashion) in haskell
20:39:32 <copumpkin> but you could do it
20:39:46 <monochrom> a static type obtained from runtime input?
20:39:55 <copumpkin> GADTs
20:40:54 <russruss> nus: how would you write an x -> Maybe Schema in haskell?
20:40:58 <russruss> that's exactly my question
20:41:07 <copumpkin> it's called a parser :P
20:41:13 <nus> russruss, ^^^
20:41:21 <ddarius> Types like ((String, Int), (String, (String, Int))) are, again, an encoding from the json.  The compiler doesn't know you want that encoding or what that encoding is until you tell it.  If you have a generic type-directed scheme, you can easily implement that with type classes.
20:41:35 <monochrom> it is a parser in any language
20:42:13 <EvanR> x -> Either ParserErrorMessage Schema ;)
20:42:22 <russruss> ddarius: you could do that with undecidable instances I think, sure
20:42:44 <EvanR> ParserErrorMessageWhichIsEasyToUnderstand
20:42:53 <russruss> but I'm talking about not a type-directed schema
20:42:59 <ddarius> Why do you think you need undecidable instances.
20:43:16 <ddarius> russruss: I'm responding to the earlier conversation.
20:44:02 <ddarius> Also, I didn't say "schema."
20:44:12 <russruss> hehe oops
20:44:13 <russruss> sorry
20:44:43 <russruss> yeah, I mean I'm not trying to say that there's not a way to do it functionally where you write a parser to determine the structure of the data that you want
20:44:58 <ddarius> russruss: Define "parser."
20:45:40 <russruss> well, okay, I mean something that goes from a string into a representation that you want
20:46:09 <ddarius> Is that your definition of "parser"?
20:47:06 <russruss> well, now I feel like you're trying to make me look silly, that's what I meant when I said it in that instance
20:47:23 <russruss> I believe that's at least a subset of the meaning of parser :-P
20:47:40 <ddarius> russruss: I didn't ask you to explain that instance.  I have only asked (in the imperative mood) that you provide your definition of "parser."
20:47:49 <ddarius> russruss: I agree with your last statement.
20:49:11 <russruss> well, this has suddenly become way more philosophical
20:49:20 <ddarius> russruss: How so?
20:49:57 <russruss> I mean, I'm not sure what a good complete definition of parser is
20:49:59 <russruss> what do you think
20:50:21 <EvanR> a function from strings to x
20:50:47 <ddarius> EvanR: I disagree with that definition vehemently.
20:51:39 <ddarius> russruss: You said "that goes from a string into a representation that you want" is a subset of what you think "parser" means.  What is something that is less of a subset?
20:52:16 <EvanR> ddarius: are you even going to elaborate
20:52:53 <ddarius> EvanR: I wasn't planning on doing so directly.
20:53:09 <russruss> well, I mean I think you can definitely expand the string side
20:53:10 <EvanR> well it must be vehement for a reason
20:53:20 <ddarius> russruss: Agreed.
20:54:03 <russruss> you're going from something with a meaning that's not encoded in a way that's directly usable to something that's encoded in a way that's at least more usable
20:54:28 <ddarius> russruss: There you go.  I might put that as: A parser is a function from a less structured representation to a more structured representation.
20:54:59 <russruss> yeah I mean one could argue that structuredness in that sense is relative
20:55:29 <EvanR> structuredness in that sense is relative
20:56:21 <ddarius> It's not just relative, it's vague.  Nevertheless, I think in virtually all cases in practice, a reasonable notion of "structuredness" is clear.
20:56:39 <EvanR> what a parser is is clear too
20:57:03 <ddarius> EvanR: Is it?
20:57:23 * EvanR replaces the entire paper with 'it is obviously clear that <theorem>'
20:57:41 <EvanR> wow research just got cheaper
20:58:14 <ddarius> EvanR: That statement assumes that that isn't how it already works.
20:59:12 <EvanR> i was trying to upgrade the absurdity
21:00:25 <EvanR> seems like a parser assumes a sequence of tokens as input, this would make more clear what unstructured means
21:00:44 <ddarius> EvanR: It would also limit the notion of parser to excluding, for example, tree parsers.
21:00:54 <russruss> I mean I'm still curious how you would make a parser in haskell that goes from json to Maybe ((String, Int), (String, Bool))
21:01:12 <ddarius> Also, it doesn't clarify what unstructured means at all, it just avoids needing a meaning.
21:01:28 <EvanR> its a sequence rather than some other structure
21:01:29 <ddarius> russruss: You just write such a function.
21:01:31 <russruss> it seems like you're advocating making a parser just for that type, which is fine
21:01:38 <EvanR> russruss: use Text.JSON
21:01:43 <copumpkin> or Aeson
21:02:00 <copumpkin> I'd probably make a parser parser layer on top of one of those
21:02:10 <EvanR> ((String,Int),(String,Bool)) may have a JSON instance already
21:02:33 <russruss> right but I was saying subjectively "wouldn't it be nice" if you could do write a function forall a. String -> Maybe (MyMatchingRules a)
21:02:34 <EvanR> and Maybe that would also, if that Maybe is part of your data and not the parser result
21:02:51 <EvanR> if im correct you dont even need to write a function
21:02:51 <russruss> I wasn't commenting on the difficultly of actually implementing one particular case
21:02:56 <ddarius> russruss: Again, if you have a generic scheme you can certainly implement in a way that allows significant reuse and, if it's type-directed, you can use a type-class to even put the pieces together.
21:03:12 <ddarius> russruss: But yes, you do, somewhere, need to say what the encoding actually is.
21:03:25 <russruss> right, I'm totally not disagreeing with that
21:04:08 <EvanR> the Text.JSON encoding of Maybe is interesting, but kind of flamebaiting to use in javascript
21:04:27 <EvanR> i have seen it though in the wild, not in haskell context
21:04:36 <russruss> I had the feeling that sort of what you want is a way of performing checking operations on that actual type tree might be convenient, which of course you can only get with dependent types
21:04:53 <russruss> that was not really a sentence
21:05:09 <EvanR> i dont see where dependent types are needed for this?
21:05:25 <copumpkin> russruss: I'd play with some DTs and get a feel for them, if I were you :)
21:05:38 <russruss> copumpkin: yeah, sounds like fun
21:05:45 <copumpkin> it's amazing
21:05:48 <copumpkin> I'm an addict
21:06:10 * ddarius uses DT languages all the time, like Javascript, and ... well, okay, I don't actually use them that much.
21:06:19 <EvanR> haha
21:06:22 <russruss> right, well, that's exactly why I brought this up
21:06:26 <copumpkin> :)
21:06:39 <russruss> because that's actually what you do in javascript or other non-type-checked languages
21:06:55 <EvanR> i use C's data type, a 8*2^32 array of bits
21:07:22 <copumpkin> some parts of it are off-limits though
21:07:24 <russruss> you don't write the input verification for types in a functional style but rather a declarative style or often just using introspection
21:07:30 <copumpkin> you should encode which, in the (dependent) type
21:07:44 <copumpkin> of course, which ones are valid is a function of where you are in the program
21:08:06 <ddarius> russruss: My impression is that in those languages you usually don't write input verification at all.
21:08:17 <ddarius> If you do, then it tends to be a parser just like anything else.
21:08:39 <EvanR> ddarius: at least when switching on a string code, default case should throw an error
21:08:42 <russruss> well, in javascript the standard trope for json or xml is to parse into the javascript representation
21:09:01 <russruss> and then you have a "prototype" object, which encodes the type of data that will be accepted
21:09:20 <russruss> and then you pass that into a function that checks to make sure the input has the same fields with the same type
21:09:50 <russruss> so in a way it's a little more declarative than writing a custom parser for each type you want to match
21:10:16 <ddarius> russruss: Yes, it's "generating" a parser from a declarative description.  You can do that in a typed-language just as well.
21:10:17 <russruss> but right, I mean there's nothing forcing you to verify your input
21:10:48 <jdhky> does anyone know the status of class aliases? is there a roadmap to getting something like this implemented in ghc?
21:11:03 <russruss> sorry, nothing forces you to verify your input in javascript, I meant, which is super lame
21:11:47 <russruss> fundamentally the parsing is done by the time you get to the declarative description, you're generating a verifier
21:12:32 <ddarius> russruss: Yes, that's why I did the quotes.  The "parser" is the whole string->json->verifier chain.
21:12:53 <ddarius> We also already have a string->json parser.  And it is trivial to write something that generates a verifier from a declarative description.
21:13:34 <russruss> the string-> json parser is not well typed in the sense that ((String, Bool) (String, Int)) has the same type as ((String Int), (String, Bool))
21:13:54 <ddarius> russruss: Neither is it in javascript.
21:14:14 <russruss> well, as far as javascript typing goes it is well typed ;-)
21:14:27 <nus> russruss, "those" types aren't "these" types
21:15:15 <ddarius> russruss: The point of the string->json parser in both cases is to turn a string into a structure that can represent arbitrary JSON.  The JSON to X part is handled by the "verifier" post-process.
21:15:21 <EvanR> theres basically one type in javascript
21:15:37 <ddarius> That's why I said the whole thing string->json->verifier is the parser.
21:15:55 <russruss> ddarius: okay, that makes sense.  I didn't quite get that before
21:16:17 <ddarius> You have a string->json parser.  This turns a less structured representation to a more structured one, but one still not completely "structured" as we'd like.
21:16:52 <ddarius> The "verifier" (though also likely a transformation, e.g. 1 -> true) goes from the more structured representation to the desired representation.
21:17:03 <ddarius> This is just like lexing then parsing.
21:18:09 <russruss> yeah, these are really valid points.  to me, given that there are so many json parsing libraries in haskell, none focus on declaratively going from the JSValue tree to types you actually want
21:18:20 <russruss> that seems weird
21:18:54 <ddarius> That's not the purpose of a JSON library.
21:19:33 <russruss> I mean, at this point I think I should start messing with dependent types to see if the problems I hope they solve in this sphere are worth the downsides :-)
21:19:50 <ddarius> Also, often the most convenient way to represent such declarative specifications is as embedded languages in Haskell.  In which case, your declarative specifications are just code.
21:21:08 <ddarius> russruss: As far as I can tell, dependent types have no relevance to this other than that they could be used to enforce some more guarantees (but even then, a specification of correct behavior would require you to write the parser anyway, you'd just end up writing it twice.)
21:22:43 <russruss> well, I guess the advantage in my mind which may be imaginary is that you could encode these declarative specifications as types
21:22:52 <russruss> and maybe that's something you couldn't do
21:23:39 <russruss> but yeah you'd have to write the equivalent "parser generator" or "verifier generator" or whatever
21:24:28 <russruss> you'd need type functions too of course
21:24:34 <ddarius> russruss: Dependent types give you the ability to have -types- depend on -values-.  What you want is something that takes a type and -produces- a value, i.e. values depending on types.  This is what type classes do.
21:25:32 <EvanR> @hoogle [[a]] -> a -> [a]
21:25:33 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
21:25:33 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
21:25:33 <lambdabot> Data.Graph.Inductive.Internal.RootPath getPath :: Node -> RTree -> Path
21:26:01 <EvanR> no no no
21:26:33 <russruss> but you have your (value -> value) parser that generates your json tree in the same way that haskell does, then you have a (value -> (type -> type) -> value) that would be your "verifier"
21:27:47 <FusionGyro> quick iteratees question: is there an analog of the iteratees package function `enumWith` in the enumerator package?
21:28:12 <ddarius> russruss: You need more than the latter.  You need to be able to produce a value, specifically a function to do the JSValue -> X transformation.  I also don't know what types the type -> type parameter is supposed to be provided.
21:29:00 <russruss> that's the verifier - if your concept of type matches the philosophical concept of type, you only have to verify the type of the input
21:29:45 <russruss> so to implement a function that with a signature value -> (type -> type) -> value I think you need dependent types, right?
21:30:45 <ddarius> russruss: That "type" doesn't make sense with or without dependent types.
21:31:17 <russruss> well surely there's some type system in which it does, right?
21:31:32 <ddarius> And again, what you seem to be talking about involves lowering types down to values which is the opposite direction that dependent types go.
21:31:43 <russruss> I mean curried it's value -> (type -> type -> value)
21:32:08 <russruss> right so like I suppose that isn't exactly dependent types but it's a type function that depends on a value
21:32:48 <russruss> yeah maybe it's utter nonsense now that I think about it ;-)
21:33:10 <ddarius> russruss: value -> (type -> type) -> value is value -> ((type -> type) -> value) which is different from value -> (type -> type -> value) which would just be value -> type -> type -> value, which does fit what you seem to be wanting to say better.
21:33:32 <dobblego> does instance satisfy laws? Monad [] where return = const []; _ >>= _ = []
21:34:00 <_Ray_> Hi :) I know that, say, a Functor, must obey some laws. However these laws aren't checked by the compiler. Suffering a lot in performance, is there anything that _could_ check whether a set of laws, or invariants, hold for an element of a type?
21:34:08 <ddarius> dobblego: Does return x >>= f ~> f x?
21:35:08 <ddarius> _Ray_: Performance (at least at run-time) isn't the problem.  The answer is "no" if you want a definite and correct "Yay" or "Nay" everytime.  The answer is "yes" if are okay with a "Maybe" sometimes.
21:35:19 <russruss> well, no, the kind signature of the function I want is closer to value -> (type -> (type, value -> value)) -> value now that I'm thinking about it
21:35:39 <_Ray_> The no is because of halting, and the maybe is because of heuristics?
21:35:49 <ddarius> _Ray_: More or less.
21:36:51 <dobblego> ddarius: thanks
21:38:08 <russruss> anyways, so on the list of DT languages to try, anything other than agda?
21:39:40 <danharaj_> Coq
21:39:40 <Axman6> i believe ATS is a dependantly typed language
21:39:59 <ddarius> Coq is probably the best.  It likely would be the best if it wasn't hampered by ML-inspired syntax.
21:40:03 <ddarius> And Ltac.
21:40:24 <ddarius> (Or rather Ltac being an allegedly horrible language.)
21:40:31 <danharaj_> is Ltac horrible?
21:40:36 <ddarius> I don't know.
21:40:55 <danharaj_> I've heard testimony that it's brittle and the pieces don't compose together very well, but I wouldn't know.
21:41:12 <copumpkin> it's kind of imperative :)
21:41:32 <copumpkin> and you're supposed to have a knee-jerk reaction against that
21:41:39 <eyu100> @free id
21:41:39 <lambdabot> f . id = id . f
21:42:03 <eyu100> @free (+1)
21:42:03 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
21:42:17 <eyu100> @free g :: a -> a
21:42:17 <lambdabot> f . g = g . f
21:42:17 <danharaj_> @free flip
21:42:18 <ddarius> copumpkin: What do you mean?  Coq is the language I go for all my imperative programming needs?  I mean YNot?
21:42:18 <lambdabot> Expected variable or '.'
21:42:29 <danharaj_> uhhh
21:42:52 <danharaj> @free flip
21:42:52 <lambdabot> Expected variable or '.'
21:42:56 <danharaj> shut up lambda bot.
21:42:58 <danharaj> :t flip
21:42:59 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
21:43:10 <danharaj> Caleskell...
21:43:14 * ddarius should have been more subtle.
21:43:21 <copumpkin> @free flip :: (a -> b -> c) -> b -> a -> c
21:43:21 <lambdabot> (forall x. h . k x = p (f x) . g) => h . flip k y = flip p (g y) . f
21:43:46 <copumpkin> :)
21:45:20 <danharaj> @free f :: a -> (a -> r) -> r
21:45:21 <lambdabot> h . k = p . g => h (f x k) = f (g x) p
21:57:52 <eyu100> @free f :: a -> b
21:57:53 <lambdabot> h . f = f . g
21:58:26 <eyu100> @free f :: a
21:58:27 <lambdabot> g f = f
21:58:34 <eyu100> @free f :: Int
21:58:35 <lambdabot> f = f
21:58:54 <eyu100> @free f :: Int -> a
21:58:54 <lambdabot> g . f = f
21:59:10 <drbean> The search path for modules doesn't include the directory of the module which imports those modules.
22:00:06 <eyu100> @free f :: [a] -> [a]
22:00:06 <lambdabot> $map g . f = f . $map g
22:04:38 <eyu100> @free f :: (a, b) -> (a', b')
22:04:38 <lambdabot> $map_Pair k p . f = f . $map_Pair g h
22:05:43 <eyu100> @free fix
22:05:44 <lambdabot> f . g = h . f => f (fix g) = fix h
22:07:09 <ddarius> @free beer
22:07:10 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `beer'\n\n"
22:07:40 <eyu100> @free sort
22:07:40 <lambdabot> Extra stuff at end of line in retrieved type "forall a. (Ord a) => [a] -> [a]\n"
22:08:00 <eyu100> @free (a -> a -> Bool) -> [a] -> [a]
22:08:00 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
22:08:07 <eyu100> @free sort :: (a -> a -> Bool) -> [a] -> [a]
22:08:07 <lambdabot> (forall x. g x = h (f x) . f) => $map f . sort g = sort h . $map f
22:09:59 <kosmikus> @tell burbul if a function doesn't depend on anything that's available only locally, you can as well make it top-level; has the advantage that you can test it independently. and if it isn't intended to be part of the interface, you can still decide not to export it from the module.
22:09:59 <lambdabot> Consider it noted.
22:14:21 <kovach> :t flip
22:14:22 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
22:14:31 <kovach> can anyone explain where that comes from?
22:14:58 <kmc> which module? it's something loaded into lambdabot; I don't know if it's on Hackage
22:15:14 <kmc> you can get Prelude.flip if you take (f t) = (r -> t)
22:15:36 <kmc> :t fmap Prelude.. ($)
22:15:37 <lambdabot> forall a (f :: * -> *) b. (Functor f) => (a -> b) -> f a -> f b
22:15:46 <kmc> :t fmap Prelude.. (Prelude.flip ($))
22:15:47 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
22:15:54 <kmc> :t Prelude.flip (fmap Prelude.. (Prelude.flip ($)))
22:15:55 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
22:15:58 <kovach> yeah, I just couldn't figure out where that funny signature was coming from
22:16:40 <kovach> hmmm
22:26:52 <ClaudiusMaximus> @oeis 1,1,2,112
22:26:55 <lambdabot>  Number of equivalence classes of Hamiltonian cycles (or Gray codes) in the b...
22:26:55 <lambdabot>  [1,1,2,112,15109096,40985184745373425696]
22:27:21 * ClaudiusMaximus gives up trying to find the most symmetric one for five bits
22:28:18 <ClaudiusMaximus> not even sure how to measure symmetry..
22:30:40 <mwc> Oh great sages of PLs, please enlighten this humble supplicant on what exactly "right assosciativity" means for a ternary operator...
22:39:28 <d7> When I make a new cabal file with cabal init, it's Build-depends is empty even of things that I'd obviously want, like containers.
22:39:44 <d7> Is there a good default list? Am I missing an option when I call cabal init?
22:48:39 <ketil> d7: add Build-Depends as and when the build fails?
22:48:58 <d7> ketil: Yeah, I guess. :)
22:49:44 <ketil> I don't think you should have default dependencies that your program doesn't really depend on.  Kinda defeats the meaning of the word :-)
22:57:26 <d7> ketil: Containers. A rare dependency. :)
22:58:17 <ketil> I think the only consistent dependency in my stuff is 'base', and I still need to decide on version limits.
23:01:20 <drbean> I used the -i flag to ghci to set search path for modules, but now it is not finding pre-compiled package functions.
23:17:21 <elliott> hi, I know someone who thinks it's a good idea to use -XOverloadedStrings so that strings can act as a DSL for any data structure whatsoever. please give me appropriate threats to use in response. thanks
23:18:08 <c_wraith> "go write perl" seems like an appropriate dismissal
23:18:16 <elliott> c_wraith: they're a perl programmer.
23:18:30 <c_wraith> well, that seemed obvious :)
23:18:33 <elliott> :D
23:25:16 <mwc> if only there was a way to make an operator higher precedence than application, so that together with GHC's postfix operator extension you could define your own literal syntax like "foo"@ to inject literals into your DSL
23:25:48 <Cale> elliott: Show him GADTs.
23:26:26 <elliott> Cale: e is aware of their existence... for better or for worse
