03:16:23 --- topic: '["Paste code/errors: http://hpaste.org/new/haskell ", "Haskell Platform 2011.2: http://is.gd/dCGPn", "GHC 7: http://is.gd/hb8vE", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/", "admin and spam issues: #haskell-ops"]'
03:16:23 --- topic: set by mauke!~mauke@p3m/member/mauke on [Sat Jun 11 05:12:20 2011]
03:16:23 --- names: list (clog mpiechotka derdon miclorb_ OscarZ azaq23 accel FireFly takuan mac_wooster delta1 kmels__ Peaker_ dschoepe QtPlatypus Cthulhon rtharper MayDaniel gpampara hrehf sebz Jetbeard knoc ab3 sjanssen kaf3ii mxweas MrFahrenheit wouters bragh Axman6 frerich jeltsch ivanm jrib yitz erus` dimmy phyrex1an Y_Less owst HugoDaniel merijn gehmehgeh ChilliX MaskRay jejansse fall_ magicman jcapper nomeata agocorona kish` nominolo ArnoVanLumig nightdenial Nisstyre tibbe)
03:16:23 --- names: list (JaffaCake1 plat0 vili Egbert9e9 pizzaplane Wild_Cat synesthesia mreh erikde jmad980 brisbin Ptival insomniaSalt Beetny illissius_ cyanoacry ejackson Palmik mrtimuk stobix hackagebot araujo perlite perspectival copumpkin BigBlackDog nighty^ Blekel hammi davidbe DasIch moshee juhp Gilly wtw mhweaver alc pantski k0ral zul_netbsd vmil86 StoneToad incluye yell0 RayNbow`TU scm hgolden Obfuscate TML jeetu pikhq RSchulzM mgsloan mustelo Philonous fcr dmwit_ kniu)
03:16:23 --- names: list (McManiaC otto_s_ micahjohnston cheater_ _habnabit lsthemes xinming sirvaliance jcp|other MetaMucil blackdog amiller kaito_ mattp_ isionous guampa elliottcable jsgf bogner chtaube_ ghorn OnionKnight pettter Lajla augur cubi amiri_ sonnym baguasquirrel gienah theorbtwo Draggor malkomalko mtrlt levitation[A] tsuraan synonymous [[zz]] kmc doc_who iratsu burbul sm__ Lymee joe6 drbean confab Belgarion0 nus Cobra bgamari julmuri ricky dixie Ziphilt Evious idnar)
03:16:23 --- names: list (nyingen zax proq mwc Nies kakos geoffhotchkiss da-x drdo andrewsw Niedar dMazz Saizan jssanders siracusa gwern sunfun pi8027 ketil treyka hirsch__ paczesiowa hellige Zephyrus comak jrk_ fxr xplat swarmer_ab descender demolithion bqf Choko Innominate styx_ [mth]_ The_Ice[home] `0660 bremner` ddarius noam alexsdutton jonno Boney ngochai rby lyn A1kmm alyx igrekster anders^^ BMeph [mth] snorble ps-auxw mlh mapreduce iFire sanjoyd mauke ormaaj xenocryst gerard0)
03:16:23 --- names: list (Starfire ByronJohnson alip emma tauntaun preflex_ Draconx Amadiro almostsix fsntation Cerise neurogeek npoektop Matt040804 EyesIsMine ClaudiusMaximus shutdown_-h_now coppro jayne sidke Muad_Dibber monochrom Cale Intensity mafs stchang_ Twey Dashkal bradwright hydo dual flippo Bwild milli saati kakazza ChongLi maurer_ alxbl uber_mort mortberg_ betta_y_omega samedhi qz Philippa dogmaT stepkut FalkoPeters taruti jonafan kluge finnomenon ville hanDerPeder Vorpal)
03:16:23 --- names: list (Raku^ lambdabot tgeeky opqdonut yahooooo ousado adnam tomaw kelvie_ akosch psychicist_ shhgs Urchin anonymo3 wto Snusfen tafryn jml tomku kolmodin_ shachaf aninhumer adxp ivan wormphlegm inimino Maxdamantus davidL eno jb55 jrick brandonw c1de0x zmoazeni Megant hzh stepnem arw_ solarus Entroacceptor freeformz nihtml helino geekounet nniro bs338 EEVIAC felher benmachine etpace smop EvanR Utkarsh flamingspinach dibblego xarch stuartmackie tessier Veinor uu1101)
03:16:23 --- names: list (nazgjunk tswett jmcarthur elliottt DukeDave mee exobit MK_FG aculich aristid _1amzave__ peterhil twofish hpc rgrinberg_ linduxed tomh- dju alexsuraci MacCoaster_ vinc_ alpounet Nereid serialhex gbeshers_ Guest34074 Harbinger bobbens olsner marienz dRbiG thetallguy armence dsmith rakete kaol cebewee Luke whoops PHO_ pingveno __class__ inr drmegahertz kurtosis det Vulpyne Gracenotes Khisanth masterzora enolan lokydor bbee wagle sully jbalint zorkon ibid Younder)
03:16:23 --- names: list (epdtry fds comex_ cheshire-cat_ burp_ nowhere_man noblethrasher novas0x2a flazz rwbarton dcoutts_ aszlig jesse99 chaoflow maloi pr loupgaroublond lusory @ChanServ _erik_ KitB scsibug_ zakwilson koala_man dorkitude absentia bd_ mrshoe zygoloid seats guerrilla mokus integral freiksenet Zol kosmikus osoleve ian_mi periodic EpsilonDur impl zenzike bezik noj erg kloeri Aestas Mitar hhulkko fabjan sipa emias ptrf henr_k dqd ehamberg gf3 ernst zaphar_ps jlouis)
03:16:23 --- names: list (avocado suiside aiko lukish_ deavid companion_cube mietek milkpost koninkje_away daed carrbs1 naneau robbert dcoutts felipe_ Derander liw xale kalven nimred etabot ccasin EvanCarroll twn Clint dom96 smly- cncl BrianHV jd10 theclaw aspect audunska sbok drhodes Laney Bleadof rntz Lemmih majoh tridactyla snarkyboojum dilinger Runar HalfWayMan edwinb rfgpfeiffer brett ttblrs thoughtpolice marchdown Hunner joni6128 Arnar Ornedan yottis sgronblo flux geekosaur)
03:16:23 --- names: list (djahandarie Igloo ciaranm welterde d7 dino- wolverian Liskni_si lomeo dumael rndm zomg dionoea edwtjo lebastr jrockway quicksilver arcatan noddy SonicvanaJr finnrobi cizra2 quaestor houeland ben edenc ttvd ts00000 Totramon^ Eliel savy snr_ arkx davean sirpengi cjay byorgey _mpu CosmicRay copton tew88 incandenza stroan samek Iceland_jack Will| mm_freak SimonRC eZet Nanar Botje alek_br Baughn Astro nlogax appamatto ido cpa willb blomqvist Somix Martty fasta)
03:16:23 --- names: list (dsouza ve jlewis mrdomino obiwahn digicyc pesco profmakx osfameron takamoron ssbasi luite fihi09`` int-e Yahovah_ devn sordina2 poucet dropdrive alios sajkr ion saiam helgikrs SirNaloZ^ dkasak hiredman peddie CindyLinz gdsx_ mrd cynick thorkilnaur__ ToRA matthew-_ trez sp3ctum neaer The_third_man dreixel tromp joeytwiddle Octal_ ixzkn jlaire kmill Nshag mornfall ski R496 djoyner amsl tamiko jix Boxo yaarg hyko DrSyzygy Enigmagic frode klugez pyrtsa ray Gunni)
03:16:23 --- names: list (adnap Taggnostr2 sunnavy lispy janne aleator vold ocharles akahn sainthuc1 dcolish tommd rvncerr Silex- srcerer schroedinbug Eelis mercury^ ozzloy liesen Raynes Bassetts mike1703 chitragupt kalivha jaj zaero koeskoes confound electrogeek skaar __main__ brixen PreciousMetals Fuco ziman Pathin orbitz Vq norm2782 jyyou mux progrock reacocard solidsnack kshannon bxc ivanst identity_ jbauman burp` obcode hvr earthy tildedave Zeiris sohum thetallguy1 gentz hampusw)
03:16:24 --- names: list (karld_ froztbyte liyang arnihermann dankna miloshadzic robinsmidsrod DustyDingo clsmith deggis ahf saurik MasseR towynlin wyfrn robinbb palmje absence Ke And[y] lpsmith plimsoll rattboi gds szbalint johs)
03:26:30 <yitz> Egbert9e9: if you are doing random using IO, might as well use something like replicateM n (randomRIO rng) instead of randList and randLine.
03:27:25 <yitz> Egbert9e9: the problem with that whole approach is that you re-initialize the random generator each time using the system time, so that's not a very good way to generate random numbers.
03:27:53 <yitz> Egbert9e9: besides the fact that you are forcing a lot of pure calculation into IO.
05:28:47 --- topic: '["Paste code/errors: http://hpaste.org/new/haskell ", "Haskell Platform 2011.2: http://is.gd/dCGPn", "GHC 7: http://is.gd/hb8vE", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/", "admin and spam issues: #haskell-ops"]'
05:28:47 --- topic: set by mauke!~mauke@p3m/member/mauke on [Sat Jun 11 05:12:19 2011]
05:28:47 --- names: list (clog setmeaway alip erg0t iFire dfjkdfjkl MaskRay sniperliu hrehf dschoepe fragamus gpampara owst Axman6 sanjoyd betta_y_omega bgs100 cwl sebz aLgEBrA perspectival djahandarie Tomsik cies PhilRod lpeterse rprije _chaos huangyi jem777 vold nus parcs Cthulhon Athas kevinqcs bo0ts__ nightdenial Icewing Argue The_Ice[home] rtharper ]OLI[ Nimatek smarter tsurutom samek lopex OscarZ azaq23 accel FireFly mac_wooster kmels__ QtPlatypus Jetbeard knoc sjanssen kaf3ii)
05:28:47 --- names: list (mxweas wouters bragh frerich jeltsch yitz erus` dimmy phyrex1an Y_Less gehmehgeh ChilliX fall_ magicman jcapper agocorona kish` nominolo Nisstyre tibbe JaffaCake1 plat0 vili Egbert9e9 pizzaplane Wild_Cat synesthesia mreh erikde jmad980 brisbin Ptival insomniaSalt illissius_ cyanoacry ejackson Palmik mrtimuk stobix hackagebot araujo perlite copumpkin BigBlackDog nighty^ Blekel hammi davidbe DasIch moshee juhp Gilly wtw mhweaver alc pantski k0ral zul_netbsd)
05:28:47 --- names: list (vmil86 StoneToad incluye yell0 RayNbow`TU scm hgolden Obfuscate TML jeetu pikhq RSchulzM mgsloan mustelo Philonous fcr dmwit_ kniu McManiaC otto_s_ micahjohnston cheater_ _habnabit lsthemes xinming sirvaliance jcp|other MetaMucil blackdog amiller kaito_ mattp_ isionous guampa elliottcable jsgf chtaube_ ghorn OnionKnight pettter Lajla augur cubi amiri_ baguasquirrel gienah theorbtwo Draggor mtrlt levitation[A] tsuraan [[zz]] doc_who iratsu burbul sm__ Lymee)
05:28:47 --- names: list (joe6 drbean confab Belgarion0 Cobra bgamari julmuri ricky dixie Ziphilt Evious idnar nyingen proq mwc Nies kakos geoffhotchkiss da-x drdo andrewsw Niedar dMazz Saizan jssanders siracusa gwern sunfun pi8027 ketil treyka hirsch__ paczesiowa hellige Zephyrus comak jrk_ fxr xplat swarmer_ab descender demolithion bqf Choko Innominate styx_ `0660 bremner` noam alexsdutton jonno Boney ngochai rby lyn A1kmm alyx igrekster anders^^ BMeph [mth] snorble ps-auxw mlh)
05:28:47 --- names: list (mapreduce mauke ormaaj xenocryst gerard0 Starfire ByronJohnson emma tauntaun preflex_ Draconx Amadiro almostsix fsntation Cerise neurogeek npoektop Matt040804 EyesIsMine ClaudiusMaximus shutdown_-h_now coppro jayne sidke Muad_Dibber monochrom Cale Intensity mafs stchang_ Twey Dashkal bradwright hydo dual flippo Bwild milli saati kakazza ChongLi maurer_ alxbl uber_mort mortberg_ samedhi qz Philippa dogmaT stepkut FalkoPeters taruti jonafan kluge finnomenon)
05:28:47 --- names: list (ville hanDerPeder Vorpal Raku^ lambdabot tgeeky opqdonut yahooooo ousado adnam tomaw kelvie_ akosch psychicist_ shhgs Urchin anonymo3 wto Snusfen tafryn jml tomku kolmodin_ shachaf aninhumer adxp ivan wormphlegm inimino Maxdamantus davidL eno jb55 jrick brandonw c1de0x zmoazeni Megant hzh stepnem arw_ solarus Entroacceptor freeformz nihtml helino geekounet nniro bs338 EEVIAC felher benmachine etpace smop EvanR Utkarsh flamingspinach dibblego xarch)
05:28:47 --- names: list (stuartmackie tessier Veinor uu1101 nazgjunk tswett jmcarthur elliottt DukeDave mee exobit MK_FG aculich aristid _1amzave__ peterhil twofish hpc rgrinberg_ linduxed tomh- dju alexsuraci MacCoaster_ vinc_ alpounet Nereid serialhex gbeshers_ Guest34074 Harbinger bobbens olsner marienz dRbiG thetallguy armence dsmith rakete kaol cebewee Luke whoops PHO_ pingveno __class__ inr drmegahertz kurtosis det Vulpyne Gracenotes Khisanth masterzora enolan lokydor bbee)
05:28:47 --- names: list (wagle sully jbalint zorkon ibid Younder epdtry fds comex_ cheshire-cat_ burp_ nowhere_man noblethrasher novas0x2a flazz rwbarton dcoutts_ aszlig jesse99 chaoflow maloi pr loupgaroublond lusory johs szbalint gds rattboi plimsoll lpsmith And[y] Ke absence palmje robinbb wyfrn towynlin MasseR saurik ahf deggis clsmith DustyDingo robinsmidsrod miloshadzic dankna arnihermann liyang froztbyte karld_ hampusw gentz thetallguy1 sohum Zeiris tildedave earthy hvr)
05:28:47 --- names: list (obcode burp` jbauman identity_ ivanst bxc kshannon solidsnack reacocard progrock mux jyyou norm2782 Vq orbitz Pathin ziman Fuco PreciousMetals brixen __main__ skaar electrogeek confound koeskoes zaero jaj kalivha chitragupt mike1703 Bassetts Raynes liesen ozzloy mercury^ Eelis schroedinbug srcerer Silex- rvncerr tommd dcolish sainthuc1 akahn ocharles aleator janne lispy sunnavy Taggnostr2 adnap Gunni ray pyrtsa klugez frode Enigmagic DrSyzygy hyko yaarg Boxo)
05:28:47 --- names: list (jix tamiko amsl djoyner R496 ski mornfall Nshag kmill jlaire ixzkn Octal_ joeytwiddle tromp dreixel The_third_man neaer sp3ctum trez matthew-_ ToRA thorkilnaur__ cynick mrd gdsx_ CindyLinz peddie hiredman dkasak SirNaloZ^ helgikrs saiam ion sajkr alios dropdrive poucet sordina2 devn Yahovah_ int-e fihi09`` luite ssbasi takamoron osfameron profmakx pesco digicyc obiwahn mrdomino jlewis ve dsouza fasta Martty Somix blomqvist willb cpa ido appamatto nlogax)
05:28:47 --- names: list (Astro Baughn alek_br Botje Nanar eZet SimonRC mm_freak Will| Iceland_jack stroan incandenza tew88 copton CosmicRay _mpu byorgey cjay sirpengi davean arkx snr_ savy Eliel Totramon^ ts00000 ttvd edenc ben houeland quaestor cizra2 finnrobi SonicvanaJr noddy arcatan quicksilver jrockway lebastr edwtjo dionoea zomg rndm dumael lomeo Liskni_si wolverian dino- d7 welterde ciaranm Igloo @ChanServ _erik_ KitB scsibug_ zakwilson koala_man dorkitude absentia bd_ mrshoe)
05:28:47 --- names: list (zygoloid seats guerrilla mokus integral freiksenet Zol kosmikus osoleve ian_mi periodic EpsilonDur impl zenzike bezik noj erg kloeri Aestas Mitar hhulkko fabjan sipa emias ptrf henr_k dqd ehamberg gf3 ernst zaphar_ps jlouis avocado suiside aiko lukish_ deavid companion_cube mietek milkpost koninkje_away daed carrbs1 naneau robbert dcoutts felipe_ Derander liw xale kalven nimred etabot ccasin EvanCarroll twn Clint dom96 smly- cncl BrianHV jd10 theclaw aspect)
05:28:47 --- names: list (audunska sbok drhodes Laney Bleadof rntz Lemmih majoh tridactyla snarkyboojum dilinger Runar HalfWayMan edwinb rfgpfeiffer brett ttblrs thoughtpolice marchdown Hunner joni6128 Arnar Ornedan yottis sgronblo flux geekosaur)
05:29:00 <frerich> Sorry, I don't know, sometimes I have these odd brain faults when I cannot understand stuff anymore which seemed straightforward before.
05:29:07 <frerich> So I wonder whether I ever understood them. :-}
05:32:24 <cwl> @src .
05:32:24 <lambdabot> (f . g) x = f (g x)
05:32:24 <lambdabot> NB: In lambdabot,  (.) = fmap
05:33:32 <cwl> @src truncate
05:33:32 <lambdabot> Source not found. Wrong!  You cheating scum!
05:34:28 <cwl> @type truncate
05:34:31 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
05:34:38 <azaq23> cwl: You can /msg lambdabot, it will answer you personally
05:34:39 <cwl> @src truncate
05:34:39 <lambdabot> Source not found. Just try something else.
05:34:50 <cwl> azaq23: ok
05:35:52 <benmachine> > truncate (-0.5)
05:35:53 <lambdabot>   0
05:35:56 <azaq23> cwl: Also, truncate is part of the RealFrac class, so there is no canonical source to show - and certainly no src to show for the implementations, Float and Double, actually
05:36:40 <benmachine> you could probably at least show an implementation in terms of floor
05:41:13 <azaq23> benmachine: That's a good point, the docs say that the minimum complete definition of RealFrac has to define only properFraction, so there are standard definitions in terms of other functions and ultimately properFraction in the RealFrac class
05:43:04 <quicksilver> azaq23, benmachine : but the main point is that @src is incomplete and misleading
05:43:08 <quicksilver> it's best just not to use it.
05:43:20 <quicksilver> all the standard library source is browsable online and links can be pasted in the channel.
05:43:37 <quicksilver> although actually definitions are occasionally harder to find than you'd like.
05:43:56 <Jafet> Clearly @src should link to all that browsable online library source...
05:44:25 <quicksilver> yes, that would be much better than the current think
05:45:16 * Jafet kicks in Cale's general direction
05:46:24 <quicksilver> cale only maintains the running instance
05:46:29 <quicksilver> anyone can write patches
05:46:36 <quicksilver> although in practice nobody does.
05:46:53 <Jafet> Yeah, but the running instance pretty much defines lambdabot
05:47:05 <Jafet> Even the packages are just snapshots of it
05:49:43 <quicksilver> Jafet: cale would happily upgrade the running instance
05:49:52 <fragamus> dmwit_: yo dude
05:49:52 <quicksilver> if somebody got some good changes committed.
05:52:18 <Jafet> Hrm
05:52:37 <Jafet> Personally, I've had enough fun just getting some of those plugins to compile
05:53:33 <quicksilver> agreed. I've not tried.
05:53:39 <Jafet> And if I had my way with @src, it'd grab the source code and dump it directly into my ghci, which is usually a bit unsuitable for irc.
05:55:26 <Botje> is anyone aware of a book that teaches functional programming using haskell? As opposed to teaching haskell itself
05:55:54 <mauke> heh. I want a book that teaches imperative programming using haskell
05:56:02 <Jafet> A book that teaches programming while assuming knowledge of haskell?
05:56:50 <Botje> it's hard to explain, obviously :)
05:56:55 <Jafet> I don't think haskell is the New ML yet
05:57:11 <Botje> for example, LYAH explores a few different functors, but never explains functors in general
05:57:56 <Jafet> Well, there are tutorials for agda based on haskell, but that isn't very subtle
05:58:02 <Botje> a book that goes beyond the syntax and the examples and really explains why those constructions are helpful
05:58:14 <Botje> like the typeclassopedia, but .. well .. bigger :)
05:58:37 <Jafet> Blogs seem to be where that's at
05:58:59 <Botje> thought so.
05:59:01 <Botje> okay, thanks
05:59:11 <Botje> i'll relay that to my professor :)
05:59:22 <aninhumer> Is there an integer log2 function anywhere in the standard libs?
05:59:52 <Jafet> Not in base
06:00:03 <Jafet> At least, not exported anywhere
06:00:11 <Botje> integer log2 .. so basically the index of the left-most bit?
06:00:31 <aninhumer> yeah
06:00:57 <Botje> data.bits doesn't have it. boo
06:01:18 <Botje> you could write it yourself in a pinch
06:01:32 <Botje> keep integer-dividing by 2 until you hit zero
06:01:50 <Jafet> I assume he's asking because it's a bottleneck in his program
06:02:09 <aninhumer> Oh no, just didn't want to go off and implement if it was already there
06:02:33 <Jafet> Ok.
06:02:53 <mauke> http://www-graphics.stanford.edu/~seander/bithacks.html#IntegerLogObvious
06:03:00 <mercury^> Most processors can do it in a single instruction. But I am not sure whether GHC notices that.
06:03:14 <kizzx2> i have a function         calculateMagic :: ByteString -> Int    the ByteString is the result of an image processing. when i run it from ghci, it completes in fraction of second but in real life that function needs to process GBs of data. i only have a few images lying around, how can i stress the function 99999 times?
06:03:38 <kizzx2> i tried `print $ last $ replicate 99999 result` but referential transparency seems to have cached the result
06:04:10 <Jafet> kizzx2: use the criterion package.
06:04:11 <kizzx2> ^ i want to benchmark it
06:04:15 <quicksilver> try criterion
06:04:22 <kizzx2> thanks
06:16:32 <verdelyi> hi, can someone explain why I get an error message for this code? http://fpaste.org/FZka/
06:17:39 <mauke> what error?
06:18:59 <verdelyi> mauke: Overlapping instances for C (a0 -> a0)
06:19:18 <verdelyi> mauke: I don't understand how "id" can be "m (a->b)"
06:19:47 <copumpkin> id can have the type (x -> y) -> (x -> y)
06:19:58 <copumpkin> m can be instantiated to ((->) (a -> b))
06:20:09 <copumpkin> although I guess in this case that's less relevant
06:20:24 <mauke> verdelyi: m = (->) a
06:20:25 <copumpkin> oh, not really
06:20:37 <mauke> verdelyi: m b = a -> b
06:22:08 <verdelyi> and: m (a->b) = (->) a  (a->b)  ========> a-> (a->b)
06:22:36 <verdelyi> but it's still not id
06:23:18 <siracusa> it can be (->) c (a -> b) with c = a -> b
06:24:36 <mauke> verdelyi: what does 'id' have to do with this?
06:24:50 <mauke> you have two instances
06:24:57 <mauke> instance C ((->) a b)
06:25:17 <verdelyi> I think copumpkin's one works: m = ((->) (a -> b))              m (a->b) = (->) (a->b) (a->b)
06:25:29 <mauke> instance C (m x) with x = (a -> b)
06:25:38 <mauke> bah, let's use completely different letters
06:26:00 <copumpkin> well, that's specifically what you'd instantiate it to to make it overlap, but the fact that the variable can be made to overlap is what GHC is complaining about
06:26:11 <mauke> instance C (c y) with c = (->) a, y = b
06:26:24 <mauke> instance C (c y) with c = m, y = a -> b
06:26:34 <mauke> there's your overlap
06:28:17 <verdelyi> mauke: copumpkin: OK, I think I see the possible overlap now, thanks for showing me!
06:41:26 <Egbert9e9> just found myself :t-ing instead of maning on bash -_-
06:42:05 <merijn> Egbert9e9: Rite of passage ;)
06:42:10 <koala_man> don't fight it. just alias :t=man
06:42:23 <ksf> http://www.reddit.com/r/programming/comments/iuk5e/what_haskell_doesnt_have/c27zlza
06:42:35 <djahandarie> Man, don't link that article in here please
06:42:49 <Egbert9e9> lol
06:43:11 <ksf> shall I link directly to the code, instead? here you go: http://pastie.org/private/h4m5i6ba9hhwrmydhtk0g
06:43:51 <ksf> hmm. haskell is using Integers there, isn't it?
06:44:44 <Jafet> For correctness
06:45:55 <Egbert9e9> hey, maxBound :: Int vs. maxBound :: Integer
06:46:02 <Egbert9e9> also, minBound
06:46:04 <Egbert9e9> what gives?
06:46:32 <ksf> > maxBound (1::Integer)
06:46:33 <lambdabot>   No instance for (GHC.Enum.Bounded (GHC.Integer.Type.Integer -> a))
06:46:33 <lambdabot>    arisi...
06:46:33 <merijn> Egbert9e9: What do you mean what gives?
06:46:45 <Egbert9e9> merijn: what's going on?
06:46:46 <ksf> > maxBound ::Integer
06:46:47 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
06:46:47 <lambdabot>    arising from...
06:46:52 <merijn> Egbert9e9: Integer is infinite
06:46:57 <ksf> nope.
06:46:58 <Egbert9e9> merijn: O_o how
06:47:04 <merijn> Egbert9e9: (well, up to the amount of memory your machine has)
06:47:19 <ksf> 2^ptrdiff_t^ptrdiff_t iirc
06:47:35 <ksf> merijn, network attached swap.
06:47:52 <Egbert9e9> memory in the cloud
06:47:57 <merijn> Egbert9e9: Integer refers to a bignum implementation which can go as big as your machine will allow (with some technical but completely irrelevant restriction like pointer size)
06:47:58 <ksf> it's a) about the size of virtual memory and b) the fact that gmp doesn't care to expand that.
06:48:02 <Egbert9e9> cloud swap
06:48:12 <Jafet> I think one of the pages on their website still says something like "GMP 5 will be able to compute with operands on disk"
06:48:35 <merijn> Egbert9e9: Anyhoo, that means that semantically Integer is unbounded (although in practice it might be if your doing insane things, but usually not even then)
06:48:39 <Jafet> gmp5 was a bit underwhelming.
06:48:46 <parcs> @src Integer
06:48:46 <lambdabot> data Integer = S# Int#
06:48:46 <lambdabot>              | J# Int# ByteArray#
06:48:59 <ksf> swapping to other boxes' ram is way faster than any disk you could get.
06:49:11 <ksf> and probably cheaper than pcie ram extension cards.
06:49:14 <merijn> Egbert9e9: Int on the other hand refers to machine integers, so the usual 32/64 bit integers (which are bounded by definition)
06:49:14 <fragamus> dmwit_: yo dude
06:49:17 <ksf> *way* cheaper.
06:49:17 <parcs> what's the theoretical max size of an Integer given that Int=Int64 ?
06:49:27 <Jafet> But with somewhat less bandwidth, of course.
06:49:32 <merijn> Egbert9e9: And minBound/maxBound obviously only make sense for bounded datatypes :)
06:49:38 <ksf> parcs, if in doubt, look it up in the gmp manual.
06:49:45 <Jafet> Unless you plugged an infiniband into that pcie slot instead
06:50:06 <Egbert9e9> @faq gmp
06:50:06 <lambdabot> The answer is: Yes! Haskell can do that.
06:50:08 <Egbert9e9> err
06:50:12 <ksf> > negate (-1) :: Integer
06:50:12 <lambdabot>   1
06:50:18 <Egbert9e9> @help
06:50:18 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:50:32 * ksf is failing bits right now.
06:50:53 <mux> > complement (-1) :: Integer
06:50:54 <lambdabot>   0
06:51:22 <ksf> so much for two's complement.
06:51:26 <ksf> I think it worked once, though.
06:51:40 <mux> > complement 0 :: Integer
06:51:40 <lambdabot>   -1
06:51:45 * mux screams
06:51:47 <Egbert9e9> the complement system sticks pores into bacteria
06:52:05 <Jafet> Um, that is twos' complement
06:52:16 <mux> > complementBit (-1) :: Integer
06:52:17 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
06:52:17 <lambdabot>         against inf...
06:52:48 <mux> I admit defeat.
06:53:16 <ski> > complementBit (-1) 1024 :: Integer
06:53:17 <ksf> > (-1) :: Integer .|. 0
06:53:17 <lambdabot>   -17976931348623159077293051907890247336179769789423065727343008115773267580...
06:53:17 <lambdabot>   Only unit numeric type pattern is valid
06:53:42 <ksf> > (-1) .|. 0 :: Integer
06:53:43 <lambdabot>   -1
06:53:52 <ksf> > (-1) .|. 1 :: Integer
06:53:53 <lambdabot>   -1
06:53:54 <ski> @type complementBit  -- bah, it ought to use `Integer' (or `Natural'), not `Int' !
06:53:55 <lambdabot> forall a. (Bits a) => a -> Int -> a
06:54:13 <parcs> > 2^(2^64*8)
06:54:14 <ksf> > (-1) `xor` 1 :: Integer
06:54:14 <lambdabot>   -2
06:54:21 <ksf> msb.
06:54:28 <lambdabot>   thread killed
06:54:37 <Jafet> ski: it ought to use turtles
06:54:53 <ski> why not tortoises ?
06:55:01 <Jafet> Same. thing.
06:59:28 <fragamus> force :: (Functor m, Monad m) => m (MList' m a) -> m [a]
07:00:16 <fragamus> can you guys help me understand this
07:00:32 * ski thinks that looks odd
07:01:13 <ski> have you written that operation ?
07:01:29 <fragamus> dmwit wrote it
07:01:44 <fragamus> well
07:02:03 <fragamus> using socratic method he helped me
07:02:13 <ski> you should replace `fmap' (and `<$>') with the corresponding monadic operations, to avoid the extraneous `Functor f' constraint
07:02:27 <ski> also, how's  MList'  defined ?
07:02:33 <fragamus> force mlist = mlist >>= \mlist' -> case mlist' of MNil -> return []; MCons x mxs -> fmap (x:) (force mxs)
07:02:34 <ski> (i can guess, but want to make sure)
07:03:11 <fragamus> data MList' m a = MNil | a `MCons` MList m a
07:03:11 <fragamus> type MList m a  = m (MList' m a)
07:03:44 <ski> ok (you could also use `newtype' instead of `type' for the latter .. depends on which you prefer)
07:04:09 <ski> so `fmap' there could be replaced by `liftM'
07:04:11 <Jafet> So, built-in sequence? I don't get it
07:04:50 <ski> it's the same thing, but given that `Functor' is unfortunately not (yet) a superclass of `Monad', it's better to use `liftM' in polymorphic situations like these
07:05:15 <ski> Jafet : hmm ?
07:05:35 <ski> fragamus : so, what do you want to understand about it ?
07:05:47 <ski> or, s/understand/do/, in general
07:06:06 <Jafet> force looks like sequence
07:06:21 <ski> not quite
07:06:35 <fragamus> I need to use it in a program
07:06:40 <ski> `sequence' is essentially using applicative functor things
07:06:51 <ski> this needs to have a monad
07:07:07 <fragamus> I am trying to get comfortable using monad stacks of arbitrary size
07:07:50 <fragamus> and I have a *very* contrived example using IO, StateT, ListT and RandomT
07:07:58 <ski> so for what do you want to use this thing ?
07:08:42 <fragamus> I have an application in mind but right now I just want to see a simple program run using all of this crap
07:08:42 * ski is trying to understand what fragamus wants help with ..
07:08:59 <fragamus> lemmme paste...
07:09:54 <ski> i suppose one use of `MList' is as a substitute (in some cases) for lazy I/O things like `hGetContents'
07:10:04 <dschoepe> fragamus: you can apply the various runFooT functions in the right order to get an IO () value
07:10:24 <ski> (hm, though maybe one'd want caching then as well ?)
07:11:20 <fragamus> this program prints 5    <--- not so useful
07:11:40 <fragamus> i want to see a list of states get printed
07:13:33 <fragamus> i need to use force to cause the stuff to get evaluated
07:16:27 <ski> hm, this reminds me of the `STREAM_IO' module (for e.g reading files) in the Standard ML Basis Library <http://www.standardml.org/Basis/stream-io.html> -- input streams here are caching data so that if you read twice, you always get the same answer, each read instead yeilds a new stream which you can continue reading the rest from
07:18:13 <ski> there's some amount of nondeterminism in that `input' will generally return a vector of however many elements was available on the stream at the time (but subsequent calls on the same stream will yield the same number of elements in the vector)
07:18:41 <ski> (and there's also non-blocking operations)
07:19:45 <ski> in all, this is not fully pure, but often it's enough to be used in a more or less pure way, e.g. with backtracking parsers
07:20:24 <ski> fragamus : still waiting for the paste link ..
07:20:40 <fragamus> http://hpaste.org/49539
07:21:01 <Jafet> It
07:21:09 <fragamus> sorry i thought it got posted automatically
07:21:33 <Jafet> ^WIt's pure if the input stream and the program semantics are time- and chunk-independent
07:24:44 <ski> Jafet : by "time-independent" you mean that it's independent of whether a non-blocking operation decided to yield a result or not at the moment ?
07:25:05 <Jafet> Well, I didn't say iff
07:25:57 <ski> fragamus : the link would normally get pasted by the `hpaste' bot in here, in case you specified `#haskell' as the IRC channel (which you did) -- but apparently that bot's dead atm
07:25:57 <w3rs> how are variant data types implemented in GHC? are they something like unions in C/C++ with type information?
07:26:07 <Jafet> But yeah, saying it that way might make it an iff
07:26:26 <ski> w3rs : Haskell has "Algebraic Data Types", not "Variant Types" per se -- but they're related, yes
07:26:45 <Jafet> w3rs: GHC currently uses the STG machine; see the paper(s) on it
07:26:57 <Jafet> (They may not be very enlightening to you.)
07:26:57 <w3rs> ski: ok, I mean sum types
07:27:22 <ski> fragamus : i think you should probably rewrite `schlock :: Int -> (RandomGen g) => ...' into `schlock :: RandomGen g => Int -> ...' -- GHC *might* accept the former, but the latter is the standard way (and you don't even need to use an extension here)
07:27:52 <ski> w3rs : Haskell's algebraic datatypes are a combinations of sum types and product types into one construction
07:28:17 <ski> w3rs : it's sometimes called sum-of-product types
07:28:32 <Jafet> Fused multiply-add
07:28:50 <w3rs> I'm interested mainly in how much space will take list of [Maybe a] with all Nothing's
07:29:25 <w3rs> length * size of pointer, something like that?
07:29:33 <merijn> Depends on how the list is generated
07:29:53 <merijn> It might not ever be completely in memory or ever be generated at all
07:29:57 <mauke> and how evaluated the Nothings are
07:30:08 <Jafet> In normal form, each cons uses 2 words; each Nothing uses another 2 I think
07:30:24 <sipa> so the spine of the list is 2*length*ptrsize
07:30:24 <Jafet> Assuming there's a normal form
07:30:39 <sipa> and the values are another 2*length*ptrsize - when entirely evaluated
07:31:01 <w3rs> yeah, I mean, head normal form, like after deepseq
07:31:30 <Jafet> Head normal form is entirely different
07:32:05 <ski> w3rs : anywway, you can think of `data Foo = A | B Int | C Double Foo' *roughly* as a variant record in Pascal or Ada, or as that could be simulated in C : `typedef struct foo_ foo; struct foo_ { enum {a,b,c} tag; union { int b; struct { double c0; foo *c1; } c; } };'
07:32:27 <mauke> ski: that doesn't tell you much about memory usage
07:33:00 <Jafet> That's not correct anyway, because it's a strict datatype in those languages
07:33:22 <ski> mauke : sorry, hadn't caught up with that turn of the discussion yet. i was mostly talking about the structure, yes
07:33:36 <w3rs> ski, thank you, I do know semantic meaning of algebraic data types, I'm interested in low-level details
07:33:49 <ski> Jafet : hence, the "roughly" :) (i was to next have remarked about that)
07:34:16 <ski> w3rs : note that the above is only a very rough picture. if you want to see how its actually done, go look at an actual implementation
07:34:20 <Jafet> GHC's representation has a lot more indirection to facilitate non-strictness
07:34:32 <ski> *nod*
07:34:38 <Jafet> Again, the STG paper(s) should explain the gory details
07:35:03 <Jafet> Pointers to thunks, oh my
07:35:29 <Jafet> I still don't understand how closures are represented exactly, either
07:36:04 <ski> w3rs : "head normal form" means that only the top constructor has (necessarily) been forced. `deepseq' would put it into *normal form* (or at least a close approximation of that)
07:36:26 <Jafet> Well, the typeclass is very carefully named `NFData'
07:36:34 <Jafet> Normal form, but only for data types
07:36:53 <Jafet> Haskell doesn't reduce under lambdas
07:36:57 <ski> indeed
07:37:16 <Jafet> Which is why you can't really have head normal form in haskell either, iirc
07:37:33 <ski> (i forget for what the appropriate term is wrt call-by-[name,need], as opposed to wrt normal-order)
07:37:46 <w3rs> ski, jafet: thanks, I messed up with normal forms
07:38:21 <Jafet> In haskell, the two relevant forms are usually whnf and nf
07:41:09 <ski> fragamus : `(RandT g (ListT (StateT Float IO))) Float' can be written as `RandT g (ListT (StateT Float IO)) Float'
07:41:27 <ski> fragamus : it's always printing five since that's what you told it to always print
07:41:45 <ski> fragamus : maybe you want to print `gah' instead ?
07:42:02 <ski> fragamus : also, you're not using `MList', you're using `ListT' instead
07:42:46 <ski> fragamus : what's the type of `liftList' and `runListT' ?
07:43:28 <ski> fragamus : instead of `lift $ lift $ lift $ ...', i think you can use `liftIO (...)'
07:44:16 <fragamus> I want to print gah
07:44:30 <fragamus> but I don't know how
07:44:48 <ski> what happens if you try `print gah' ?
07:45:04 <ski> (also, `print $ 5' is simpler written as `print 5')
07:45:36 <ski> i think you can simplify `lift $ guard $ x + y /= 77' to just `guard (x + y /= 77)'
07:45:36 <fragamus> i get a compile error with print gah
07:45:42 <ski> which compile error ?
07:45:49 <fragamus> 1 sec
07:46:07 <Jafet> @quote monochrom 007
07:46:07 <lambdabot> monochrom says: 007 titles for haskellers.  fromForeignPtr withCString.  You Only lift Twice. Bottoms Are Forever.  The Monad with the Pure Function.  For Your Types Only.  A view to A seq.  Licence
07:46:07 <lambdabot> to killThread.  iterate Never Dies.  unsafePerformIO Is Not Enough.
07:46:39 <ski> oh, right, hlint is already telling you about redundant brackets .. heed those suggestions
07:48:11 <fragamus> http://hpaste.org/49540
07:48:46 <ski> next time, annotate the original paste (see the "Annotate" button ?)
07:52:11 <ski> fragamus : i don't see where the `MList' is constructed
07:53:34 <fragamus> i need to use force
07:54:12 <fragamus> you are quite right, the Mlist isn't constructed yet
07:54:32 <ski> so how is the `MList' getting into the type error ?
07:54:41 <dainanaki> I'm using Blaze.ByteString.Builder, and I have a question about toByteStringIO: Suppose that I used bytestring's putStr as the IO action. When the buffer gets full and the bytestring gets printed, what happens to the builder? Is the builder emptied, or will subsequent appending to the builder print successively larger bytestrings that have the first portion that got printed too?
07:56:23 <fragamus> http://www.haskell.org/haskellwiki/ListT_done_right
07:56:32 <fragamus> I use that ^^^
07:57:07 * hackagebot pwstore-cli 0.2 - Command line interface for the pwstore library  http://hackage.haskell.org/package/pwstore-cli-0.2 (RobertHelgesson)
08:06:23 <hatds> is there is standard haskell abstraction for dealing with "level resources" ?  (things that are acquired in a linear order and released in reverse order)
08:06:34 <Jafet> :t bracket
08:06:34 <lambdabot> Not in scope: `bracket'
08:06:38 <ski> fragamus : ah ok, so that `ListT' is related to your 'MList' there
08:06:41 <Jafet> :t Control.Exception.bracket
08:06:42 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
08:08:06 <quicksilver> hatds: withFoo $ withBar $ withBaz $ do ... stuff ....
08:08:12 <quicksilver> hatds: is a fairly common style
08:08:28 <hatds> yea
08:08:43 <quicksilver> (or withFoo $ \foohandle -> ..... ) if the resource has an explicit handle
08:09:03 <hatds> I suppose I was thinking where release and acquisition aren't tied together by the abstraction
08:09:32 <Saizan> or "release $ do foo <- getFoo; bar <- getBar; ...." with ContT :)
08:09:49 <hatds> but it makes me rethink whether not tying them is worth it
08:09:53 <ski> fragamus : if you're implementing this yourself, i would probably have renamed  MList'  to  MListCell  or something like that ..
08:10:32 <cpa> is there a way to define the state monad such that fac2 is optimised to fac1 in this code? http://hpaste.org/49543
08:11:16 <cpa> more generally to rewrite function using the state monad to functions using an extra parameter?
08:11:19 <Jafet> Hm? There's only one (nontrivial) state monad
08:11:56 <Saizan> there are two at least
08:12:05 <cpa> From the semantics yes, but one could give several implementations I guess
08:12:12 <ski> cpa : if you replace `s*n' with `n*s', then `fac2' could possible get partially evaluated into `fac1'
08:12:47 <rks> hi!
08:13:06 <rks> Has someone ever used Happy here?
08:14:31 <ski> fragamus : you can change `instance (Functor m, Monad m) => Monad (ListT m)' to `instance Monad m => Monad (ListT m)' and `m >>= f = joinListT $ fmap f m' to `m >>= f = joinListT $ liftM f m'
08:15:02 <ski> fragamus : also removing `Functor m' similarly where there's already `Monad m'
08:15:03 <cpa> ski: why so? is it magic?
08:15:13 <ski> cpa : why what ?
08:15:19 <cpa> 17:27 < ski> cpa : if you replace `s*n' with `n*s', then `fac2' could possible get partially evaluated into `fac1'
08:16:12 <Jafet> Because it then expands into the same product into which fac1 expands
08:16:24 <Jafet> Which is product [n,n-1..1]
08:17:00 <cpa> ok, I think I get it
08:17:12 <Jafet> Or more precisely foldr1 (*) [n,n-1..1]
08:17:35 <ski> try unfolding `(>>=)',`return',`get',`put' yourself into the definition of `fac2', and simplify
08:17:51 <Jafet> @src product
08:17:51 <lambdabot> product = foldl (*) 1
08:19:11 <cpa> but does that mean that if in fac1 I replace go (n-1) (n*acc) by go (n-1) (acc*n) then fac1 and fac2 will have the same performance?
08:19:14 <cpa> I don'tthink so
08:19:58 <ski> (rather `foldr (*) 1 [n,n-1 .. 1]' .. or `foldl (flip (*)) 1 [1 .. n]' if you prefer)
08:20:23 <Jafet> Uh, right
08:20:28 <Saizan> btw, both fac1 and fac2 are lazy in the accumulator, which is bad, though GHC might be able to optimize that away for fac1
08:20:39 <ski> cpa : *if* it would get (sufficiently) partially evaluated, then they'd get the same performance
08:20:49 <Jafet> Sure, they're bad, but to answer cpa's question, they should be equally bad
08:20:53 <ski> afaik GHC does no (nontrivial) partial evaluation
08:21:04 <saati> how can i get the current time in microseconds?
08:21:22 <Jafet> Practically, though, you won't get very different numbers from doing the product [1..n] compared to [n,n-1..1]
08:21:24 <Saizan> Jafet: fac1 is sufficiently simpler that the strictness analyzer might kick in only for that one
08:22:10 <Jafet> *cough* What strictness analyzer?
08:22:34 <cpa> so if write a function using the state monad or the same function carrying an extra parameter around, will I have the same performance ?
08:22:54 <Jafet> Look at the definition of State... it comes to about the same thing
08:23:25 <cpa> indeed, but there's a lot lambda abstractions in the way
08:23:45 <cpa> are they remove by some optimisation pass?
08:23:49 <cpa> +d
08:24:05 <mreh> for State?
08:24:11 <cpa> yes
08:24:22 <mreh> State is just a newtype wrapper for (s -> (s,a)) really
08:24:40 <mreh> it took me a while to see past the newtypes
08:25:28 <ski> but `fac1' being easier to analyze, might get more optimization than `fac2' (unless a partial evaluation thing kicks in and removes the `State' things)
08:25:56 <mreh> sorry, are we talking about something else
08:26:10 <ptd> cpa: Premature optimization is the root of all evil
08:26:39 <danharaj> That tautological.
08:26:44 <danharaj> It's premature optimization.
08:26:51 <mreh> conal, what's the state of reactive these days?
08:27:09 <conal> mreh: nothing new, afaik
08:27:13 <Iceland_jack> danharaj: pleonastic?
08:27:26 <danharaj> Iceland_jack: good word.
08:27:27 <Iceland_jack> http://stackoverflow.com/questions/312003/what-is-the-most-ridiculous-pessimization-youve-seen
08:27:29 <cpa> ptd: it was just out of curiosity
08:27:35 <Iceland_jack> another good one: pessimization
08:27:48 <mreh> i might apply for a PhD
08:27:55 <mreh> wondered if there was room for a project
08:28:56 <mreh> failing that, i'd love to help
08:28:58 <Iceland_jack> danharaj: #haskell won't burn me alive if I mention that I don't really use Haskell?
08:29:06 * copumpkin burns Iceland_jack alive
08:29:11 <conal> mreh: :)
08:29:11 <Iceland_jack> drats
08:29:29 <ski> hm, what's the antonym to "improvement" ?
08:29:42 <danharaj> Republican-majority congress.
08:29:51 <Iceland_jack> diminishing?
08:29:54 <mreh> woohoo
08:30:06 <Iceland_jack> possibly ‘deterioration’
08:30:12 <ski> i mean, some people are suggesting using "improvement" instead of "optimization"
08:30:24 <ski> so what to use for "pessimization", then ?
08:31:09 <Iceland_jack> malification
08:31:19 <Iceland_jack> conferring the Latin roots of optimization
08:31:29 <Jafet> > let fac 0 = 0; fac n = bf (*) [1..n] where bf _ [x] = x; bf f xs = let (x1s,x2s) = splitAt (length xs `div` 2) xs in f (bf f x1s) (bf f x2s); in length $ show $ fac 100000
08:31:29 <copumpkin> pessimization
08:31:30 <lambdabot>   456574
08:31:34 <ski> @wn malification
08:31:37 <lambdabot> No match for "malification".
08:31:42 <mreh> @wn malefactor
08:31:42 <lambdabot> *** "malefactor" wn "WordNet (r) 2.0"
08:31:42 <lambdabot> malefactor
08:31:42 <lambdabot>      n : someone who has committed (or been legally convicted of) a
08:31:42 <lambdabot>          crime [syn: {criminal}, {felon}, {crook}, {outlaw}]
08:31:49 <Iceland_jack> ski: It's not a real term
08:31:50 <mreh> definitely heard that word on HalfLife2
08:32:02 <ski> Iceland_jack : it is, if you start using it ..
08:32:11 <Iceland_jack> but I haven't used it
08:32:13 <Iceland_jack> so it's not a real term
08:32:16 <Iceland_jack> pessimus: worst
08:32:18 <Iceland_jack> malus: bad
08:32:25 <Iceland_jack> optimus: best, bonus: good
08:32:29 <Iceland_jack> there's a nice symmetry there
08:32:33 <mreh> melior
08:32:35 <mreh> better
08:32:40 <Iceland_jack> pelior: worse
08:32:44 <mreh> ah
08:32:45 <Iceland_jack> pelificatio?
08:32:49 <Iceland_jack> +n
08:32:57 <mreh> perfect
08:33:05 <Iceland_jack> melification: “It's not worse.. but, meh”
08:33:06 <mreh> you sound clever and pompous
08:33:14 * ski . o O ( apelioration )
08:33:19 <Iceland_jack> mreh: thank you
08:33:27 <mreh> Iceland_jack: none taken
08:33:32 * Iceland_jack scoffs
08:33:51 <mreh> ;)
08:34:10 <Iceland_jack> I'm more of a Lisp user, but I do enjoy some aspects of Haskell very much
08:34:41 <danharaj> What's the least painful way to convert a UArray into a StorableArray?
08:36:34 <mreh> latin easy, haskell we're not so hot on
08:38:54 <dmwit_> hah
08:39:01 <dmwit_> oy, what's that ugly hanger-on?
08:41:47 <mreh> who you calling ugly?
08:41:51 <dmwit> danharaj: dunno
08:42:00 <dmwit> danharaj: Maybe go via "assocs"?
08:42:13 <dmwit> mreh: I'm calling the "_" in "dmwit_" ugly.
08:45:04 <danharaj> dmwit: thaw, actually :D
08:45:09 <danharaj> Didn't occur to me.
08:48:45 <conal> mreh: project idea: getting unamb & lub to work robustly & efficiently, and explore applications (including reactive)
08:50:52 <ski> @quote scuff
08:50:52 <lambdabot> minion says: BOOLE is the crowning jewel perched precariously upon the perfect peak of programmer prowess, casting its limitless limpid light over the lands of those who scuff and wallow in the
08:50:52 <lambdabot> dreary dust of digital depravity and unbounded wilful ignorance of the testament of Our Lord God as channeled through the X3J13 committee.
08:51:44 <mreh> so much alliteration
08:52:26 <mreh> conal: cool
08:53:14 <mreh> nottingham have some PhDs going
08:53:17 <mreh> i've said too much already
08:54:07 <lundstrj> Hi!
08:54:12 <mreh> \0
08:54:51 <lundstrj> I have a questioan regardig the difference between: a lambda function, let and where. Mainly, what is the difference?
08:55:12 <ski> > text "\0"
08:55:17 <mreh> syntax mostly
08:55:42 <ski> lundstrj : a lambda expression is just that, an expression, which expresses a function
08:56:01 <lundstrj> @mreh: It seem very un haskell like to have three different ways of doing the same thing.
08:56:01 <lambdabot> Unknown command, try @list
08:56:04 <edwardk> > let and where both bind names in local scope. where is attached to the statement, while let is an expression level thing, this means you can use let inside lambdas, but not where
08:56:05 <lambdabot>   <no location info>: parse error on input `where'
08:56:14 <ski> lundstrj : `let <decls> in <expr>' is also an expression which provides locally bound variable from `<decls>' in `<expr>'
08:56:19 <lundstrj> mreh: It seem very un haskell like to have three different ways of doing the same thing.
08:56:21 <edwardk> lambdas define small anonymous functions
08:56:32 <edwardk> lundstrj: actually it is very much haskell-like
08:56:44 <edwardk> internally they all desugar down to similar things, but they give a rich surface syntax
08:56:51 <lundstrj> edwardk: Cool
08:56:53 <ski> lundstrj : `where <decls>' attaches to defining clauses (and to branches in `case'), otherwise it's similar to `let'-`in'
08:57:03 <edwardk> and while let and where are similar, lambdas serve a very different purpose.
08:57:13 * mreh is not a fan of let
08:57:30 <danharaj> lambdas are how you define functions.
08:57:32 <edwardk> i find myself rewriting code in combinator fashion to avoid using lets
08:57:44 <lundstrj> =)
08:57:48 <danharaj> I like long let clauses :[
08:58:07 <mreh> edwardk: combinator fashion?
08:58:30 <dolio> Haskell isn't Python.
08:58:38 <lundstrj> As you all might have guessed, I am no veteran. I am trying to make the jump from Python to Haskell. I can get stuff working but I find my self reinventing the wheel a lot of the time because I don't know the standard functions very well.
08:58:53 <danharaj> lundstrj: Use hoogle :)
08:59:03 <lundstrj> I recently ventured into the unholy land of IO and that is where i stumbled on these things.
08:59:05 <danharaj> http://www.haskell.org/hoogle/
08:59:14 <edwardk> mreh foo x y z = State foo' where foo' s = …
08:59:30 <edwardk> rather than foo x y z = State $ \s -> ...
08:59:48 <edwardk> when i need to do non-trivial binding inside of the lambda
08:59:50 <dmwit> let and where are more polymorphic than lambda.
09:00:13 <lundstrj> heh, I am trying to follow an introductory course given at Chalmers. So far i have two labs down and two to go.
09:00:14 <dmwit> Well... not in recent GHC's, actually, but they're *allowed* to be more polymorphic than lambda, anyway.
09:00:26 <edwardk> dmwit: yeah was going to say =)
09:01:05 <ski> dmwit : hm ?
09:01:15 <dmwit> So, there's three constructs: polymorphic expression (let), polymorphic non-expression (where), and monomorphic expression (lambda).
09:01:29 <edwardk> ski: http://research.microsoft.com/en-us/um/people/simonpj/papers/constraints/let-gen.pdf
09:01:35 <dmwit> ski: (\f -> (f "hey", f False)) is not well typed, but let f = id in (f "hey", f False) is fine.
09:01:48 <danharaj> wait is it anymore?
09:02:01 <dolio> Depends what extensions are on, probably.
09:02:07 <dmwit> However, it was recently discovered that the latter makes type inference a bit tricky in the presence of GADTs, so it was eliminated (without an explicitly polymorphic type signature).
09:02:13 <ski> dmwit : yeah i know, i wondered about the "allowed" part -- but maybe that's what edwardk linked to
09:02:19 <BMeph> lundstrj: Is there a social stigma you have about reinventing the wheel? Many people do this deliberately to learn the language. You could just...pretend that you're doing that on purpose. ;)
09:02:26 <danharaj> > (\f -> (f "hey", f false)) id
09:02:27 <lambdabot>   Not in scope: `false'
09:02:33 <dmwit> ski: The following is allowed even now: let f :: a -> a; f = id in (f "hey", f False)
09:02:46 <danharaj> > (\f -> (f "hey", f False)) id
09:02:47 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
09:02:47 <lambdabot>         against inferred type ...
09:02:53 <mreh> there's nothing more deadly than an adequately working existing codebase
09:03:03 <ski> dmwit : are you talking about Core, or surface Haskell with some extension/restriction ?
09:03:12 <danharaj> > (\(f :: forall a. a -> a) -> (f "hey", f false)) id
09:03:12 <dmwit> Surface Haskell.
09:03:13 <lambdabot>   Not in scope: `false'
09:03:16 <dmwit> No extensions that I know of.
09:03:17 * danharaj hits self
09:03:32 <danharaj> > (\(f :: forall a. a -> a) -> (f "hey", f False)) id
09:03:33 <ski> > let f = id in (f "hey", f False)  -- also allowed even now
09:03:33 <lambdabot>   ("hey",False)
09:03:33 <lundstrj> BMeph: Well, it's just that I never seem to get that clean haskell code since I have a gazillion helper functions to do the most basic things. Someone more skilled would just use map, foldr, words or some other very useful function
09:03:34 <lambdabot>   ("hey",False)
09:04:36 <ski> lundstrj : heh, is that course page online ?
09:04:51 <Saizan> it's {-# LANGUAGE GADTs #-} that implies MonoLocalBinds
09:04:56 <lundstrj> ski: Yeah, want the link?
09:05:01 <BMeph> lundstrj: Well, a nice thing about Haskell is that it isn't "read-only"; you can go back to your code and rework it for more learning. :)
09:05:21 <dmwit> ski: Oh, I understand your question now. Yes, there's an extension to make let-binding monomorphic, though I don't know what it is.
09:05:30 <ski> lundstrj : sure, could be fun to look at
09:05:41 <edwardk> ghci -XGADTs   > let f x = x in (f "hey", f False)   Couldn't match expected type `[Char]' with actual type `Bool'
09:05:47 <lundstrj> BMeph: Yeah, I guess so =) But when it comes to labs and such, I've never really found my self going back after it has been passed
09:05:56 <edwardk> but without the MonoLocalBinds it works fine
09:05:56 <lundstrj> ski: hang on, one sec
09:05:58 <ski> edwardk,Saizan : i see, interesting
09:07:12 <Tomsik> :t (\f :: Bool -> f)
09:07:13 <lambdabot>     Illegal result type signature `Bool'
09:07:13 <lambdabot>       Result signatures are no longer supported in pattern matches
09:07:13 <lambdabot>     In a lambda abstraction: \ f :: Bool -> f
09:07:26 <Tomsik> no Church-likes?
09:07:34 <ski> @type \(f :: Bool) -> f
09:07:34 <lambdabot> Bool -> Bool
09:07:41 <Tomsik> okay
09:08:19 <lundstrj> ski: http://www.cse.chalmers.se/edu/year/2010/course/TDA555/
09:09:18 <lundstrj> ski: There is also a slightly different flavor of the same course here: http://www.cse.chalmers.se/edu/year/2010/course/TDA451_Functional_Programming/
09:09:42 <lundstrj> ski: Basically the same thing but still every so slightly different.
09:10:18 * hackagebot filesystem-enumerator 0.1 - Enumerator-based API for manipulating the filesystem.  http://hackage.haskell.org/package/filesystem-enumerator-0.1 (JohnMillikin)
09:10:31 <ski> so i assume you're looking at this to prepare before actually taking the course in the autumn ?
09:10:43 <lundstrj> well
09:10:45 <ski> (or is it running as a summer course as well ?)
09:10:50 <lundstrj> truth to be told
09:11:02 <lundstrj> I was supposed to pass this course about 7 years ago
09:11:03 * ski imagines what's to come
09:11:24 <ski> ok
09:11:27 <lundstrj> It was the first one they threw at us when we started at the university
09:11:32 <lundstrj> I failed pretty hard
09:11:47 <lundstrj> passed everything else after that though but just never really got around to it
09:11:49 <lundstrj> you know?
09:12:01 <ski> *nod*
09:12:08 <lundstrj> If I don't do it now, I fear I will never do it
09:12:54 <lundstrj> so this vacation has been reserved for Haskell. I am better than I have ever been and did almost pass it that time 7 years ago. Almost wasn't quite enough though
09:13:28 <lundstrj> but as I sit here and hack, it is dawning on me that I could be a lot better at my job if I would actually master this language
09:13:49 <lundstrj> Python is great and all. I love it. But this is cleaner
09:14:18 <lundstrj> A good functional programmer can just churn out so much functionality per time unit
09:14:20 <Tomsik> For me reading code on the wiki (about ST and such) and actually browsing through the library seems to help a lot
09:14:29 <ski> lundstrj : if you have code you want comments / suggestions for improvement on, this channel is usually happy to look at it
09:14:33 <lundstrj> I have yet to meet the imperative or object oriented hacker than can compete
09:14:53 <Tomsik> (and obsessing about compactness and pointfreeness too)
09:14:55 <lundstrj> ski: Thanks! I just might do that.
09:15:28 * ski imagines Tomsik doing topology in Haskell
09:15:34 <lundstrj> I have everything prepared in a dropbox so that I can share it easily once it is good enough to share =)
09:15:41 <mreh> @where paste
09:15:41 <lambdabot> <http://hpaste.org/>, <http://paste.lisp.org/new>, <http://codepad.org/>
09:16:00 <mreh> don't go to too much trouble for small snippets
09:16:08 <lundstrj> =)
09:16:24 <danharaj> lundstrj: I know some that are pretty prolific hackers in object oriented languages.
09:17:09 <lundstrj> danharaj
09:17:18 <lundstrj> danharaj: Yeah, there are some real good ones out there
09:17:45 <lundstrj> It's just hard to compete with someone who has tools that are a magnitue better than yours.
09:17:45 <mreh> with haskell you can load up brain with more
09:18:41 <lundstrj> Well guys and gals, this has been a real pleasure. Thanks a lot for the help and the suggestions. I fear that I have to get back to my code now. It apparently wont write it self =) I'll keep idling though. I'll talk to you later.
09:18:49 <kmc> anyone who thinks of themselves as a "functional hacker" or an "OOP hacker" is crippling themselves
09:19:30 <kmc> learn as many techniques as possible
09:19:33 <danharaj> kmc: true. The particular person I have in mind is hardly aware of these so-called paradigms. I had to explain to them what multiple dispatch is even though they knew how to use it.
09:19:50 <kmc> use whatever language allows you to solve problems, regardless of what label some bureaucrat has applied to it
09:19:55 <danharaj> But they are the most productive Objective C hacker I've seen.
09:19:58 <kmc> heh
09:20:10 <kmc> iow "i don't use Haskell because it's functional, I use Haskell because it's good"
09:20:17 <monochrom> "hacker" is also pretty narrow
09:20:27 <danharaj> http://opetopic.com/ <-- this is them :D
09:34:38 <yitz> kmc: "I don't use Haskell because it's functional, and I don't use Haskell because it's good. I just don't use Haskell."
09:34:58 <kmc> haha
09:35:32 <edwardk> i use haskell because it makes me feel better than everyone else.
09:35:44 <edwardk> quite literally. i feel better when using haskell.
09:36:23 <yitz> edwardk: no you don't. you use it because Haskell is applied category theory.
09:37:00 <yitz> edwardk: that's one of the main reasons i use it too.
09:37:06 <edwardk> i started using haskell before i even looked at category theory =)
09:37:24 <edwardk> i like category theory because it is an excuse to play with fun formalisms in haskell
09:37:25 <Saizan> haskell is a gateway drug to category theory
09:37:25 <kmc> i use Haskell because it has the best support for nested multi-line comments
09:37:46 <edwardk> kmc: bah, ocaml actually parses the contents of the comments ;)
09:37:52 <Tomsik> "Interests: applied category theory"
09:38:07 <kmc> Haskell is to category theory as Pink Floyd is to marijuana
09:38:41 <djahandarie> In reality completed disconnected but always given a bad name because of it?
09:38:47 <Tomsik> What is the LSD of the Haskell world then?
09:39:29 <yitz> edwardk: i learned category theory when even most mathematicians called it "abstract nonsense" and didn't believe it would ever be really useful for anything.
09:39:45 <Wantstolearn> Hi.Which language to learn before Haskell like you learn latin before other romanic languages
09:39:45 <yitz> edwardk: now we build web sites with it
09:40:02 <kmc> Wantstolearn, silly analogy.  plus who really learns Latin before French?
09:40:08 <Wantstolearn> i do
09:40:23 <copumpkin> most people don't
09:40:26 <edwardk> wantstolearn: i'd learn haskell before learning haskell, but maybe you might want to tackle haskell before that
09:40:28 <copumpkin> I learned latin after french
09:40:38 <yitz> Wantstolearn: learn Miranda
09:40:40 <Wantstolearn> lol
09:40:42 <applicative> I learned latin after french
09:40:44 <copumpkin> you should learn x86 assembly before french
09:40:44 <kmc> and Standard ML
09:40:45 <Wantstolearn> ml ocaml
09:40:47 <smop> esperanto
09:40:47 <mauke> Wantstolearn: OCaml and javascript
09:40:49 <byorgey> yes, I was going to say Miranda too
09:40:54 <kmc> and Lazy ML if you can find an implementation that still works
09:40:54 <mauke> possibly Perl
09:40:55 <copumpkin> also, lojban after haskell
09:41:03 <byorgey> it is a dead precursor to Haskell
09:41:04 <danharaj> Difference Engine instructions
09:41:08 <copumpkin> I hear latin helps with C as ewell
09:41:11 <Wantstolearn> that is simplifes concept of haskell
09:41:17 <mauke> Wantstolearn: lambda calculus
09:41:18 <edwardk> Wantstolearn: in seriousness, perhaps i should have annotated those. haskell 98, before haskell 2010, before haskell as used by ghc ;)
09:41:19 <copumpkin> or might I Say
09:41:21 <copumpkin> C/C++
09:41:28 <kmc> learn Haskell 1.4
09:41:29 <applicative> nothing helps with C
09:41:31 <Eduard_Munteanu> copumpkin: especially when reading the standard
09:41:38 <Wantstolearn> lambda calculus
09:41:49 <edwardk> wantstolearn: ml and ocaml mostly give you habits to unlearn when picking up haskell
09:41:50 <Wantstolearn> good sugestion
09:41:57 <Wantstolearn> what after that
09:42:09 <mauke> Wantstolearn: OCaml and javascript
09:42:22 <mauke> OCaml for the type system, javascript for the I/O
09:42:37 <edwardk> in practice Haskell isn't all that terrifying, just dive in
09:42:41 <edwardk> when you get stuck, ask
09:42:51 <Eduard_Munteanu> @where lyah
09:42:51 <lambdabot> http://www.learnyouahaskell.com/
09:43:05 <Wantstolearn> Thank you mauke
09:43:10 <gwern> whoo, another day on hawiki sans vandalism
09:43:19 <ski> copumpkin : maybe you're thinking of <http://www.csse.monash.edu.au/~damian/papers/HTML/Perligata.html> ?
09:43:35 <yitz> gwern: why didn't you vandalize it today? are you tired?
09:43:44 <gwern> yeah, I just flew in
09:43:51 <copumpkin> ski: excellent!
09:43:56 <luite> don't do web programming though, even in haskell, web programming will make you hate the language, programming, and everything!
09:44:11 <danharaj> I find web programming to be refreshing actually.
09:44:14 <danharaj> A nice change of pace.
09:45:07 <ski> Wantstolearn : do you know any other programming language ?
09:45:22 * hackagebot toolshed 0.12.0.0 - Utilities used by other packages.  http://hackage.haskell.org/package/toolshed-0.12.0.0 (AlistairWard)
09:46:23 * hackagebot factory 0.1.0.0 - Rational arithmetic in an irrational world.  http://hackage.haskell.org/package/factory-0.1.0.0 (AlistairWard)
09:47:08 <luite> danharaj: hehe, well I'm probably biased because I'm a bit frustrated because I still have no working version of my (haskell based) website after many hours of work :p
09:47:25 * hackagebot squeeze 1.0.2.0 - A file-packing application.  http://hackage.haskell.org/package/squeeze-1.0.2.0 (AlistairWard)
09:47:27 * hackagebot regexdot 0.10.2.2 - A polymorphic, POSIX, extended regex-engine.  http://hackage.haskell.org/package/regexdot-0.10.2.2 (AlistairWard)
09:48:23 * hackagebot regexchar 0.9.0.8 - A POSIX, extended regex-engine.  http://hackage.haskell.org/package/regexchar-0.9.0.8 (AlistairWard)
09:48:59 <luite> and because web never just works..
09:50:04 <luite> oh and what's a good free monospace font with a lower x-height than dejavu sans mono that doesn't look as blurry as inconsolata on windows?
09:51:20 <luite> the combination of palatino and dejavu sans mono just doesn't look right
09:52:13 <Eduard_Munteanu> Will Windows even have Inconsolata usually?
09:52:24 * Eduard_Munteanu thinks Inconsolata looks a bit too gothic
09:52:26 <luite> no but if it's free you can use a css @font-face
09:52:39 <luite> and provide the .ot
09:52:41 <luite> .otf
09:52:48 <applicative> wow javascript V8 whatever is trashing gcc in the goofy shootout.
09:53:04 * applicative looks for his Javascript in !0 minutes book again
09:53:28 <luite> Eduard_Munteanu: which mono font do you prefer instead?
09:53:48 <Eduard_Munteanu> I use DejaVu Sans Mono usually
09:53:52 <nlogax> applicative: in js, that would be javascript in true minutes
09:53:55 * applicative gives up on javascript again; it's just 'regex-dna'
09:54:57 <applicative> some of the Haskell programs are broken with ghc 7.*, should I send in a repaired regex-dna, for example?
09:55:46 * applicative thinks, of course, it's so ugly it would be hard to resist rewriting it in accordance with higher counsels of style
09:56:08 <ByronJohnson> applicative: I'd contact the maintainer first.
09:57:55 <ByronJohnson> applicative: You could follow the steps listed on http://www.haskell.org/pipermail/haskell-cafe/2011-May/092331.html
09:58:22 <applicative> that means the one who last submitted it? L Wasserman, the mad genius speed freak
09:58:33 <luite> Eduard_Munteanu: here, doesn't look right, http://jabberwock.xs4all.nl/exp/wolfgang/fonts1.png
09:59:53 <applicative> Oh I see, ByronJohnson I didn't make clear I was still talking about a shootout entry, regex-dna http://shootout.alioth.debian.org/u64/benchmark.php?test=regexdna&lang=all
10:00:32 <applicative> It just needs {-#LANGUAGE BangPatterns#-} and a clarifying signature for the new type inferencer
10:01:31 <Eduard_Munteanu> luite: you mean it doesn't blend well with your non-mono font?
10:01:40 <Eduard_Munteanu> That one looks a bit "wide"
10:01:47 <luite> huge difference in x-height
10:03:18 <luite> the serif font is book antiqua / palatino / tex gyre pagella
10:05:41 <roconnor> what is generic programming?
10:06:28 <c_wraith> whatever degree of polymorphism your language makes hard to do easily :)
10:06:31 <silver> synonym for metaprogramming?
10:06:50 <c_wraith> in haskell, that means syb/uniplate/multiplate/etc stuff
10:07:12 <c_wraith> basically, generic traversals to modify only specific types of elements.
10:07:24 <c_wraith> :t gmap
10:07:24 <lambdabot> Not in scope: `gmap'
10:07:32 <sm__> woohoo, another regex lib
10:07:32 <c_wraith> evidently not in scope in lambdabot
10:07:46 <silver> oh I was wrong
10:08:24 <silver> can type classes be considered as a tool for generic programming?
10:08:42 <incluye> :t map
10:08:43 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
10:08:44 <roconnor> okay
10:08:57 <incluye> :t Int
10:08:58 <lambdabot> Not in scope: data constructor `Int'
10:09:03 <c_wraith> silver: in haskell, yes.  That's what Data.Data is, for instance
10:09:08 <roconnor> I thought generic programming might have had to something to do with reflecting syntax
10:09:17 <mauke> :t Left
10:09:18 <lambdabot> forall a b. a -> Either a b
10:09:21 <c_wraith> roconnor: in other languages, it might.
10:11:32 <HanselVanKansel> :?
10:34:30 <yitz> silver: not really. they are one tool that you might use, together with others, in some approaches to generic programming.
10:37:28 <kmc> type classes, reflection, and metaprogramming are all useful tools for *implementing* a generic-programming scheme
10:38:04 <kmc> the idea is that users of the scheme don't need to worry about such things
10:38:44 <kmc> they just say "here is a function of type Foo -> Foo.  now traverse this other algebraic type which has Foos buried somewhere within"
10:41:37 <danharaj> GHC just told me its brain just exploded.
10:41:44 <Saizan> generic programming includes other stuff like [de]serialization and equality checking too
10:41:44 <Eduard_Munteanu> GADTs?
10:41:49 <danharaj> yeah
10:42:30 <silver> > equality checking
10:42:31 <lambdabot>   Not in scope: `equality'Not in scope: `checking'
10:42:37 <silver> sounds like Eq type class
10:42:40 <mauke> don't make me define ===
10:43:46 <Saizan> yeah, the point is to not have to implement such things from scratch for every datatype
10:44:34 <Eduard_Munteanu> Do you mean some sort of extensional equality 'deriving Eq' doesn't cover?
11:04:48 <doskey> hello, bit of a haskell noob here
11:05:03 <doskey> I have a quick question regarding monad transforms
11:05:28 <edwardk> shoot
11:05:36 <doskey> how can I turn a [Maybe Int] into a MaybeT [] Int?
11:05:53 <doskey> I know I can turn a [Int] into one using lift
11:06:05 <doskey> but then I can't have a Nothing in the list
11:07:51 <edwardk> :t MaybeT
11:07:52 <lambdabot> Not in scope: data constructor `MaybeT'
11:08:02 <edwardk> doskey: use the MaybeT constructor
11:08:03 <mustelo> doskey, you could use catMaybes
11:08:07 <mustelo> :t catMaybes
11:08:08 <lambdabot> forall a. [Maybe a] -> [a]
11:08:10 <edwardk> :t Control.Monad.Maybe.MaybeT
11:08:10 <lambdabot> Couldn't find qualified module.
11:08:35 <edwardk> newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }
11:08:47 <edwardk> MaybeT :: m (Maybe a) -> MaybeT m a
11:09:09 <edwardk> mustelo: different result type
11:09:31 <mustelo> edwardk, yeah, he said he knew what to do with an [Int] though :)
11:10:07 <edwardk> doskey: that help?
11:10:19 <doskey> just a sec trying :)
11:11:17 <edwardk> trying to find anything else interesting to bolt into those little profunctor packages
11:11:30 <doskey> just edwardk that worked great!
11:11:34 <danharaj> I hate myself
11:11:37 <edwardk> happy to help
11:11:45 <Tomsik> I looked at that profunctor post
11:11:45 <doskey> thanks a lot, should of thought of the data constructor
11:11:46 <edwardk> and its always the obvious things that get you =)
11:11:47 <danharaj> I had a viciously subtle opengl bug a couple of months ago
11:11:54 <Tomsik> I have a feeling that Pierce called them difunctors
11:11:57 <danharaj> and now I have it again, but I don't remember how I fixed it.
11:12:05 <mustelo> instant replay: <danharaj> I hate myself <edwardk> happy to help
11:12:12 <doskey> preflex: edwardk++
11:12:13 <edwardk> mustelo: hahahaha
11:12:14 <kmc> haha
11:13:09 <edwardk> tomsik: i don't have pierce's little category theory book here, but profunctors are by far the dominant term
11:13:15 <doskey> mustelo, thanks for your help as well
11:13:57 <mustelo> no worries. as edwardk pointed out, I wasn't actually correct, but blindly connecting the types
11:14:45 <OceanSpray> Say I want to write a compiler for a toy language.
11:14:56 <OceanSpray> For the parser, I can use Parsec.
11:15:02 <OceanSpray> For the backend, I can use LLVM.
11:15:11 <OceanSpray> For the typechecker, I can use _ ?
11:15:23 <kmc> i don't know of a generic typechecking library
11:15:38 <mustelo> OceanSpray, agda-mode in emacs :p?
11:15:38 <kmc> there's a lot of variation between different languages' type systems
11:15:43 <OceanSpray> well
11:15:46 <kmc> what does yours look like?
11:15:53 <edwardk> oceanspray: http://hackage.haskell.org/package/unification-fd can help write a type inference algorithm
11:16:01 <OceanSpray> plain HM
11:16:07 <OceanSpray> nothing fancy.
11:16:12 <edwardk> oceanspray: at least it helps deal with the unification issues
11:16:14 <kmc> you might enjoy the paper "Typing Haskell in Haskell"
11:17:05 <mustelo> does anyone have some high level advice for what the right tradeoff is in how much semantics to try to do in Parsec versus later? (in the context of an interpreter for a simple language)
11:17:20 <monochrom> yes, try out unification-fd
11:17:41 <monochrom> and yes, "nothing fancy" HM already requires at least unification
11:17:59 <OceanSpray> dang.
11:18:01 <OceanSpray> alright
11:18:23 <HanselVanKansel> :t "hello"
11:18:23 <lambdabot> [Char]
11:18:30 <monochrom> though, unification is pretty "duh"
11:18:31 <kmc> mustelo, I think it's cleaner not to do any interpretation in the parser
11:18:56 <edwardk> mustelo: do as little as you can in the parser
11:19:07 <mustelo> okay, that's what I was hoping people would say
11:19:16 <OceanSpray> what about desugaring?
11:19:18 <ski> @remember <danharaj> I hate myself <edwardk> happy to help
11:19:18 <lambdabot> I will never forget.
11:19:28 <OceanSpray> should that use a separate pass?
11:19:35 <edwardk> it'll wind up with you having a jumbled mess of a compiler where you wind up with ml style syntax directed recursion, or a bunch of hacks to dodge it
11:19:44 <kmc> OceanSpray, it depends on your goals and how the sugar looks
11:19:54 * shapr gets a suger hih
11:19:56 <kmc> in a toy language i'd desugar wherever is most convenient
11:19:57 <shapr> high * :-(
11:20:04 <edwardk> heya shapr
11:20:15 <kmc> toy implementation*
11:20:18 <kmc> in a "real" implementation you want to at least remember the sugar on the side, so you can report better error messages
11:20:24 <edwardk> shapr: in your case i would think that would do nothing but slow you down
11:21:20 <OceanSpray> alrighty
11:22:15 <monochrom> it's also pretty easy to write a slow algorithm for unification yourself
11:22:38 <OceanSpray> well
11:22:49 <OceanSpray> I could just copy the algorithm from TaPL
11:22:49 <copumpkin> that -fd suffix on the package bothers me
11:22:55 <ski> (edwardk : by "ml style syntax directed recursion" you mean explicit `rec' ?)
11:23:04 <OceanSpray> except my copy of that book is on the other side of the continent right now.
11:23:37 <edwardk> i threatened to do a tiny haskell 98 unification library, but wren wanted to do the bigger release of the huge pile of code he had lying around from hacking on dana.
11:23:49 <edwardk> so the -fd stuff is indicating that it isn't the 98 version =)
11:24:02 <mustelo> I'm trying to parse a simple risc assembly language. there are about 30 opcodes, and 5 or so categories of how many operands each takes. my current parsec implementation is quite non-DRY; littered with stuff distinctions between these categories. is there are clean way to address this?
11:24:08 <OceanSpray> what's the -fd stand for?
11:24:20 <edwardk> fundeps
11:24:24 <mav> beginner here: what feature of Haskell is used to define =~ (in Text.Regex)? as far as I can tell it is overloaded on the result type and I wouldn't know how to define such a thing myself.
11:24:31 <kmc> mustelo, factor out the repetition as function?
11:24:34 <kmc> mav, type classes
11:24:36 <pikhq> :t (=~)
11:24:37 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
11:24:38 <OceanSpray> ah
11:24:41 <kmc> but (=~) is terrible, terrible, terrible
11:24:42 <pikhq> Yup, typeclass.
11:24:45 <kmc> the Regex API is so un-haskelly
11:25:07 <kmc> "let's give all the functions in the world the same name, and count on the type system to sort it out!"
11:25:07 <kmc> no
11:25:40 <kmc> mustelo, since parsers are first-class values you can make functions that take parsers and return parsers
11:25:54 <HanselVanKansel> why can't `fst' be defined as: fst' :: (a, _) -> a? what's wrong with the `_' type variable?
11:26:07 <kmc> it's not part of the syntax of types
11:26:38 <mustelo> kmc, I can only factor out so much. for example, some ops take two (eg cmp) registers and some take three (eg add), and it seems like there's no way to generically parse those under one roof
11:26:49 <kmc> mustelo, ok
11:27:00 <kmc> but you can write one function for all 2-reg instructions
11:27:07 <mustelo> yeah, that's what I have
11:27:09 <HanselVanKansel> then, why is the `_' part of variable syntax, but not of type syntax, or no specific reason?
11:27:10 <mav> kmc: thx. I guess I've some more reading to do. I couldn't really understand the type constraints in the type of =~.
11:27:30 <kmc> mustelo, maybe you should hpaste your code and we'll see if there's a way to improve it
11:27:40 <kmc> HanselVanKansel, it's not part of variable syntax, it's part of pattern syntax
11:27:46 <kmc> there are no patterns at the type level
11:27:50 <HanselVanKansel> ah!
11:27:54 <HanselVanKansel> thanks :D
11:28:12 <kmc> it wouldn't be crazy to allow this one case, but I think there's not much need
11:29:38 <HanselVanKansel> i'm reading a tutorial on Haskell now, but coming from Erlang, patterns allow functions to have multiple "definitions", right? then pattern syntax in type syntax would mean multiple "definitions" of types
11:29:59 <kmc> HanselVanKansel, not necessarily. there are places in expression syntax where only one pattern is allowed
11:30:03 <Saizan> partial type signatures would be nice when you are forced to give part them to use some advanced feature but the rest of the type could be inferred
11:30:28 <kmc> mav, type classes let you overload names according to parts of their types
11:30:30 <monochrom> I don't want multiple types
11:30:42 <HanselVanKansel> well okay, i'll continue the tutorial. thanks kmc
11:30:50 <kmc> the type class feature doesn't care whether those types are functions, let alone whether the overloaded part appears in argument or result position
11:30:57 <kmc> class Bounded a where { maxBound :: a }
11:31:09 <kmc> > maxBound :: Word8
11:31:10 <lambdabot>   255
11:31:12 <kmc> > maxBound :: Int
11:31:13 <lambdabot>   9223372036854775807
11:31:20 <dainanaki> Is there any way to cut down on System.Locale calls when manipulating lots of bytestrings?
11:31:30 <kmc> you don't even need this (:: t) annotation when it's inferrable from context
11:31:39 <kmc> dainanaki, why do you need System.Locale at all?
11:31:44 <dainanaki> Beats me.
11:31:52 <dainanaki> I'm trying to figure out where it's coming from.
11:31:52 <kmc> then... don't use it?
11:31:57 <kmc> oh, is this from profiling?
11:32:01 <dainanaki> Yes.
11:32:05 <kmc> idk then, sorry
11:32:29 <monochrom> what bytestring manipulation generates System.Locale calls?
11:32:34 <mustelo> here's some nasty parsec code for the assembly thing I was mentioning. all comments welcome. http://hpaste.org/49548
11:32:48 <kmc> mav, probably you can't understand the constraints on (=~) because it's a ridiculous operator implemented in an unreasonable way
11:32:50 <danharaj> huh...
11:33:00 <danharaj> what could cause a program to crash while running in ghci but not when compiled?
11:33:11 <dainanaki> linker issues?
11:33:36 <dainanaki> are you doing something graphicsy?
11:33:40 <danharaj> yeah
11:33:49 <dainanaki> probably what it is.
11:33:53 <kmc> mustelo, you can factor out  try (string x >> return y)
11:33:53 <monochrom> an unsafePerformIO that is optimized away when compiled
11:34:11 <kmc> that's also:  try (y <$ string x)
11:34:23 <mustelo> kmc, good call. naming suggestions?
11:34:27 <kmc> shrug
11:35:14 <Saizan> danharaj: ghci uses the threaded runtime, and doesn't necessarily run your expressions in the main thread
11:35:24 <monochrom> to understand =~, you must first understand multiple parameter type class
11:35:51 <kmc> more generally you can replace «try x <|> try y <|> ...»  with  «asum . map try $ [x, y, ...]»
11:35:53 <danharaj> dainanaki: It just started doing this because I changed a definition. Very subtly.
11:36:03 <danharaj> Saizan: I think it might be a threading issue.
11:36:17 <monochrom> actually, default ghci behaviour for now is to always use a new thread. but there are now calls for change
11:36:59 <mustelo> kmc, hmm, okay.
11:37:08 <danharaj> Does ghci have problems with finalizers?
11:38:04 <dmwit> So... i18n in Haskell.
11:38:34 <pikhq> dmwit: Step one: the only encoding is UTF-8.
11:38:42 <dmwit> Obviously.
11:39:40 <dmwit> I guess hgettext is the only thing out there.
11:40:38 <dmwit> ...which actually surprises me a bit, I think. No pure solutions?
11:41:08 <pikhq> I'm not entirely sure there's any "pure" solution, outside of like a Reader monad...
11:41:57 <dmwit> string1 :: Language -> String
11:42:01 <dmwit> string2 :: Language -> String
11:42:04 <dmwit> etc.
11:42:19 <pikhq> The Language there is generally coming from an external file.
11:42:26 <dmwit> So, yeah, something like a Reader. Why not?
11:42:36 <pikhq> No idea.
11:42:40 <dmwit> external file?
11:42:46 <dmwit> data Language = English | German
11:42:51 <dmwit> Totally not coming from an external file.
11:42:54 <pikhq> Well, if you want the translation to be editable without recompilation.
11:43:03 <dmwit> Why would I want that?
11:43:08 <klugez> dmwit: http://www.yesodweb.com/blog/2011/01/i18n-in-haskell - Not sure if that has been developed further, but you might want to check.
11:43:31 <pikhq> Windows users don't compile things, and distros *like* being able to package translations seperately.
11:43:59 <dmwit> Oh, you and your deployment.
11:44:05 <dmwit> Fine, I agree that's a good feature to have.
11:44:39 <pikhq> Still, I do agree that having all of the gettext stuff in IO seems a bit wrong.
11:45:22 <pikhq> Since the only IO should be something like "lang <- get-language foo" at the start.
11:45:28 <dainanaki> Yesod has done more work on internationalization
11:45:40 <kmc> depending on how your app is structured, this seems like a fine use case for unsafePerformIO
11:45:42 <dainanaki> You want to read up on Messages
11:45:56 <dainanaki> If I recall correctly
11:47:19 <dmwit> Okay, I'll poke around in Yesod.
11:48:25 <dainanaki> Fair warning though, it may be overkill for what you're looking for.
11:48:51 <dainanaki> Is there any way in profiling to inspect a function more in depth?
11:48:57 <luite> pikhq: yesod requires recompilation for most things, for example if you modify templates
12:03:45 <ptd> :t build
12:03:45 <lambdabot> Not in scope: `build'
12:04:19 <ptd> :t GHC.Exts.build
12:04:19 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
12:05:32 <ptd> (\g -> g (:) [])
12:06:15 <dmwit> :t buildr
12:06:15 <lambdabot> Not in scope: `buildr'
12:06:43 <dmwit> ?hoogle ((a -> b -> b) -> b -> b) -> [a]
12:06:43 <lambdabot> No results found
12:07:39 <ptd2> what does build do?
12:08:36 <dmwit> You pasted the source, what more could you want than that?
12:08:40 <kmc> http://www.haskell.org/haskellwiki/GHC/Using_rules#Example:_map
12:11:07 <ptd2> I can't think what I should pass as g
12:11:19 <dmwit> Pass a closure over a list.
12:11:21 <kmc> a church-encoded list
12:11:26 <Cale> ptd2: It turns a fold over a list back into a list
12:11:52 <Cale> > (\cons nil -> cons 1 (cons 2 (cons 3 nil))) (+) 0
12:11:53 <lambdabot>   6
12:11:57 <Cale> > (\cons nil -> cons 1 (cons 2 (cons 3 nil))) (:) []
12:11:57 <lambdabot>   [1,2,3]
12:13:02 <kmc> the inverse of 'build' is (\xs f z -> foldr f z xs)
12:13:16 <Cale> > (\cons nil -> cons 1 (cons 2 (cons 3 nil))) (\x xs -> concat ["(",show x, ":", xs, ")"]) "[]"
12:13:16 <lambdabot>   "(1:(2:(3:[])))"
12:13:51 <Cale> > (\cons nil -> cons 1 (cons 2 (cons 3 nil))) (\x xs -> concat ["(cons ",show x, " ", xs, ")"]) "nil"
12:13:52 <lambdabot>   "(cons 1 (cons 2 (cons 3 nil)))"
12:14:20 <dmwit> "build" is just the implementation of (one direction of) the Yoneda lemma for a particular functor. ;-)
12:15:25 <dainanaki> In my local docs it says that Data.Time.Clock.UTCTime has a show instance, but when I try to use it, I'm told that there's no show instance for it. What gives?
12:16:04 <monochrom> import Data.Time, then :info UTCTime, that will tell you where is the instance
12:16:40 <monochrom> you will probably also see that there is no chance you could have guessed it
12:16:46 <dainanaki> Ah, indeed.
12:16:55 <dainanaki> That's rather dumb.
12:17:01 <edwardk> dmwit: well, build is technically specifying the list in terms of an initial algebra
12:17:17 <edwardk> dmwit: yoneda'd lists are kinda boring =)
12:17:39 <ptd> :t (\a b -> foldl a b [1,2,3])
12:17:40 <lambdabot> forall a b. (Num b) => (a -> b -> a) -> a -> a
12:18:00 <edwardk> :t build
12:18:00 <lambdabot> Not in scope: `build'
12:18:29 <Cale> For whatever reason, build isn't an exposed function of the list library
12:18:44 <kmc> maybe because it has a rank-2 type?
12:18:55 <edwardk> probably
12:19:25 <djahandarie> Rank-2 types are scary~
12:19:29 <kmc> nah
12:19:38 <kmc> what do you gain from having that rank-2 type, versus the type it actually needs
12:19:41 <Cale> foldl doesn't quite give the right type for build
12:19:48 <edwardk> kmc: parametricity
12:20:03 <kmc> ((a -> [a] -> [a]) -> [a] -> [a]) -> [a]
12:20:16 <ptd> what is a rank-2 type?
12:20:19 <kmc> limits on the implementation of build  given its type
12:20:22 <edwardk> then you know nothing about how it shuffles together all those lists
12:20:32 <kmc> ptd, a type where a "forall" appears in function-argument position
12:21:00 <monochrom> (forall a. a->a) -> blahblah is a rank-2 type
12:21:24 <monochrom> that is a boring example
12:21:30 <edwardk> ptd: it lets you pass functions like 'id' as an argument and still use them at multiple types.
12:21:40 <kmc> «forall a. ((T a -> B) -> C)» is a function that promises to be polymorphic, whereas «(forall a. T a -> B) -> C» is a function that demands a polymorphic argument
12:21:43 <edwardk> but they are also used to make things like the ST monad safe, my AD library safe, etc.
12:21:47 <monochrom> runST :: (forall s. ST s a) -> a is a magical example
12:22:20 <ptd> oh
12:22:53 <Saizan> is there a formal proof of how this makes ST safe?
12:23:10 <kmc> ptd, it's basically a question of whether the caller or the callee chooses that type variable
12:23:14 <monochrom> yes, "who is being required to be polymorphic" is my favourite way to look at it, too
12:23:25 <ski> @type GHC.Base.build  -- edwardk,Cale
12:23:25 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
12:23:26 <edwardk> saizan: in the original ST paper, no?
12:23:37 <edwardk> ski: thanks =)
12:23:38 <ptd> :t (\ f -> (f 1, f True))
12:23:38 <lambdabot>     No instance for (Num Bool)
12:23:38 <lambdabot>       arising from the literal `1' at <interactive>:1:11
12:23:38 <lambdabot>     Possible fix: add an instance declaration for (Num Bool)
12:23:46 <Saizan> edwardk: it doesn't even try, afaict
12:24:12 <ptd> but logically id would work as f
12:24:30 <edwardk> ptd: type inference can't figure out rank-n types in general
12:24:37 <edwardk> ptd: so you need explicit type annotations
12:25:09 <edwardk> ptd: (there do exist crazy type systems that handle rank-2 types, but there is provably none for rank-n > 2)
12:25:33 <edwardk> so haskell uses the nice compromise that if you want crazy exotic types you provide an annotation and we'll try to make them work with other types
12:25:41 <djahandarie> GHC's current inference engine doesn't do rank-2 types? I vaguely recall that it did
12:25:47 <kmc> well, GHC uses that compromise ;)
12:26:04 <edwardk> that way we get the flexibility of higher rank types, and the convenience of type inference
12:26:09 <djahandarie> Hm, I'm probably misremembering then
12:26:28 <edwardk> djahandarie: there is some voodoo that makes runST $ foo work these days
12:26:35 <edwardk> but it doesn't do rank 2 types in general
12:26:38 <kmc> and you get a situation where runST (do { ... }) works but (runST $ do { ... }) does not :(
12:26:47 <kmc> heh
12:26:48 <edwardk> kmc: try it post 7.0
12:27:00 <kmc> not sure how to feel about hacks such as these
12:27:06 <Saizan> is the vodoo still there?
12:27:10 <edwardk> kmc: lots of code where i used to have to put the ()'s rather than $ works now
12:28:02 <edwardk> personally i'd almost just as soon have $ as syntax rather than a function, that way i could use it on types ;)
12:28:04 <bos> it's ok, the number of people who grok rank-K types is inversely proportional to ackermann(K)
12:28:05 <ptd> presumably rank-3 is where you have a forall in the argument to an argument
12:28:18 <edwardk> ptd: yep
12:28:25 <edwardk> ptd: the correct type for callCC would be rank-3
12:28:31 <kmc> VC-dimension!
12:28:34 <monochrom> "runST $ do" has been working since 6.something. there was a kludge to do it back then. not sure whether it's the same kludge since 7, but I bet not, 7 solves all problems
12:28:48 <kmc> "we rewrote the typechecker and now it works for some reason"
12:29:01 <edwardk> monochrom: i missed the window in 6.x when it started working
12:29:02 <Saizan> http://augustss.blogspot.com/2011/07/impredicative-polymorphism-use-case-in.html <- weird that runST $ is working but this example isn't.
12:29:13 <edwardk> monochrom: or maybe the fix didn't help my strange yonedaish uses
12:29:52 <monochrom> @remember the number of people who grok rank-K types is inversely proportional to ackermann(K)
12:29:52 <lambdabot> It is stored.
12:29:58 <monochrom> yikes
12:30:05 <monochrom> @forget the number of people who grok rank-K types is inversely proportional to ackermann(K)
12:30:05 <lambdabot> Done.
12:30:10 <monochrom> @remember bos the number of people who grok rank-K types is inversely proportional to ackermann(K)
12:30:10 <lambdabot> I will remember.
12:30:57 <HanselVanKansel> @remember me
12:30:57 <lambdabot> Incorrect arguments to quote
12:33:06 <edwardk> @remember remember the fifth of November — gunpower, treason and plot. I see no reason why gunpowder, treason should ever be forgot.
12:33:07 <lambdabot> Nice!
12:34:31 <siracusa> Heh
12:35:34 <Botje> is that the original? I only know it from V for Vendetta
12:36:21 <edwardk> to my knowledge. i was born on the wrong side of the pond to do it justice ;)
12:36:31 <edwardk> i had to google it
12:37:05 <shapr> Botje: http://en.wikipedia.org/wiki/Guy_Fawkes_Night
12:38:20 <shapr> Botje: The quote is mentioned in this section: http://en.wikipedia.org/wiki/Gunpowder_Plot#Bonfire_Night
12:39:30 <Evious> Wow, so that's the root of the word "guy".
12:41:11 <Tomsik> build :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
12:41:16 <Tomsik> build g = g (:) []
12:41:24 <Tomsik> That's kind of an overkill, isn't it?
12:41:54 <c_wraith> you mean the rank-2 type?
12:42:04 <burbul> Is there an easy way to ask GHC to produce code to use multiple cores? (I remember being told automatic parallelisation was one of the selling points of Haskell... unfortunately I can't remember where.)
12:42:10 <edwardk> tomsik: it ensures that the type is safe
12:42:15 <kmc> burbul, it's not fully automatic
12:42:20 <c_wraith> burbul: it's not automatic.
12:42:23 <burbul> ah
12:42:26 <kmc> but much closer than most other languages
12:42:35 <c_wraith> burbul: but the compilation flag is -threaded
12:42:38 <kmc> you should read about the "par" and "pseq" functions
12:42:39 <edwardk> burbul: use 'par' when you have expensive computations you want to run at the same time
12:42:46 <kmc> and the libraries built around them, like Control.Parallel.Strategies
12:42:53 <kmc> RHW has a chapter, which I think is a bit dated now
12:43:06 <Botje> shapr: cool, thanks
12:43:10 <burbul> Real-world Haskell? I have it on my shelf... I'll look into it. Thanks!
12:43:15 <kmc> ghc --make -rtsopts -threaded foo.hs && ./foo +RTS -N
12:43:40 <kmc> burbul, the nice thing is that par and pseq have nothing to do with application-level threads
12:43:49 <kmc> you're just saying "evaluate this in parallel, speculatively"
12:44:10 <kmc> and unless you're breaking the rules (unsafePerformIO, etc), adding "par" can't change the semantics of your program
12:44:26 <burbul> I was going to say, it's feels to me as if everything can be evaluated in parallel.
12:44:33 <burbul> I hadn't thought about unsafePerformIO
12:44:34 <kmc> it can be, but there's a cost
12:44:36 <c_wraith> can be, sure.
12:44:42 <burbul> Presumably the scheduling is difficult
12:44:51 <kmc> par is very cheap because it doesn't even create a GHC lightweight thread
12:45:02 <kmc> it just pushes its argument onto a queue
12:45:10 <kmc> of things to be evaluated when the system is otherwise not busy
12:45:23 <c_wraith> But it's basically intractable to automatically find places to parallelize.
12:45:30 <c_wraith> profitably, that is.
12:45:31 <kmc> but even a single push to a lock-free queue is too much overhead if you're going to do it at *every expression*
12:45:36 <kmc> which is why at present you need these "par" annotations
12:45:55 <burbul> right
12:46:17 <burbul> What kind of speed gains would you typically see on, say, a 4-core machine?
12:46:24 <kmc> It Depends ™
12:46:29 <burbul> lol
12:46:35 <kmc> benchmark and find out
12:46:39 <c_wraith> depends on the algorithm, how well you parallelize it, and a bunch of other things.
12:46:43 <kmc> there's just no way to answer that question generically
12:46:47 <burbul> Fair enough
12:46:53 <burbul> And thanks
12:46:53 <kmc> you can go read articles and posts about particular examples
12:46:59 <c_wraith> Some problems have shown near-linear speedup in the number of cores.
12:47:02 <c_wraith> Most aren't that good
12:47:51 <Tomsik> On 4 cores the speedup is at most four times :p
12:48:04 <Tomsik> That's what you can say in full generality, basically
12:48:18 <c_wraith> heh.  That's not *quite* true.
12:49:10 <c_wraith> I seem to recall that some benchmark showed slightly better speedups than the number of cores present, because the problem set fit nicely into all the caches, where it didn't for a single processor.
12:49:24 <Tomsik> heh
12:49:29 <c_wraith> That's a silly case, but it does go to show you, sometimes things can be surprising.
12:50:23 <burbul> I hit a similar (if less weird) quirk recently because I didn't realise pairs of processors were sharing cache...
12:50:37 <burbul> Sorry, pairs of cores
12:51:07 <burbul> The timings I was taking  on the thing on the first core were going nuts because the other call was interfering with the cache (in a deterministic but very unpredictable way).
12:51:09 <edwardk> "but even a single push to a lock-free queue is too much overhead" — this is one reason why i keep playing with using the stack normally, then pushing them out to a work-stealing deque during gc
12:52:00 <edwardk> it increases the latency until when sparks are available to other threads, but shouldn't be too bad
12:52:18 <kmc> nice idea edwardk
12:52:24 <edwardk> in exchange most stack frames are cheaper than cilk's
12:53:38 <edwardk> the main overhead i've found is that you wind up paying for the code several times, the fastest-path on-stack implementation, the fast path for walking the deque as the local core, the slower path for dealing with rendezvous with stolen frames
12:53:44 * hackagebot aeson-pretty 0.3 - JSON pretty-printing library and command-line tool.  http://hackage.haskell.org/package/aeson-pretty-0.3 (FalkoPeters)
12:53:59 <edwardk> and the model to copy out from the c-stack to the deque
12:54:10 <edwardk> which means that i wind up repeating code 4x
12:54:54 <edwardk> so the code cache overhead may be prohibitive
12:55:04 <davidt_> Hi all. I'm looking through a .cabal file atm and noticed it uses a 'Default-Extensions:'  property. I can't find any information in the user guide as to what this property does. Can someone tell me please.
12:55:30 <dcoutts> davidL: it's the new name for the field extensions as of Cabal-1.10
12:55:34 <tgeeky> davidt_: it specifies the {# LANGUAGE ...}
12:55:37 <tgeeky> things
12:55:40 <tgeeky> but in the cabal file
12:55:45 <dcoutts> it's been split into default-extensions and other-extensions
12:56:22 <dcoutts> davidt_: the difference is whether you're saying that the package uses it, or whether to compile all the modules in the component with that language extension enabled.
12:57:43 <edwardk> dcoutts: which should i use when i just want to say that the package needs a set of extensions to compile, but not to turn them on because i want to turn them on module by module?
12:57:53 <davidt_> OK thanks everyone
12:58:07 <dcoutts> edwardk: other-extensions
12:58:17 <tgeeky> though I wouldn't do that either
12:58:22 <edwardk> right now i just let them lurk like bombs in the {-# LANGUAGE pragmas of each module
12:58:26 <edwardk> k
12:58:35 <dcoutts> edwardk: and that's exactly the reason that we split the meaning of the old extensions field into two
12:58:37 <edwardk> what cabal version does that field depend on?
12:58:46 <tgeeky> I specify them in each file, and then aggregate them into the default-extensions
12:58:50 <dcoutts> edwardk: 1.10, but cabal will let you know if you do it wrong
12:59:16 <edwardk> tgeeky: the problem there is i risk getting them wrong
12:59:17 <dcoutts> tgeeky: I think you want to aggregate them into the other-extensions
12:59:38 <edwardk> dcoutts: is there a way to have it check if you use one in a LANGUAGE pragma that isn't in the other-extensions list?
12:59:44 <dcoutts> edwardk: one day we'll enforce it
13:00:04 <tgeeky> edwardk: some sort of awk-ing or grep-ing?
13:00:09 <edwardk> i would love a flag to use as part of a sanity check
13:00:13 <edwardk> like -Wall
13:00:41 <edwardk> tgeeky: my LANGUAGE pragmas usually run 5-10 lines, so that would be awk-ward ;)
13:00:51 <edwardk> yes i know you can do ranges in grep
13:00:58 <tgeeky> i can't
13:00:59 <tgeeky> lol
13:01:04 <tgeeky> i stumble with tools like that every time
13:01:34 <edwardk> dcoutts: i'll start using it then
13:01:37 <dcoutts> edwardk: what we'll do eventually is parse the header of each .hs module and check (along with doing import chasing)
13:02:49 <tgeeky> dcoutts: are you one of them behind cabal?
13:03:06 <dcoutts> tgeeky: yup
13:03:41 <tgeeky> dcoutts: I had (what I thought was) an interesting idea - though this might source level
13:03:51 <HanselVanKansel> let's say you want to use: `zipWith joinSpace ["foo", "bar"] ["bar", "foo"]` where `joinSpace x y = x ++ " " ++ y`, how can I write `joinSpace` inside the `zipWith`? I've tried (++" "++) but that's actually not working
13:04:20 <edwardk> dcoutts; what version of cabal is in the current platform?
13:04:32 <Saizan> HanselVanKansel: (\ x y -> x ++ " " ++ y)
13:04:59 <tgeeky> I was just observing that there are many packages out there which provide (or replace) the Prelude, sometimes on a large scale. I wondered if it would be appropriate to have something like differential specification of imports in haskell files.
13:05:00 <dcoutts> edwardk: 1.10.x
13:05:10 <dainanaki> does attoparsec have a drop-like function, or do I just have to take the values and not bind them?
13:05:26 <HanselVanKansel> Saizan, thanks!
13:05:36 <tgeeky> dcoutts: nevermind, this is certainly in source and not cabal
13:05:41 <Saizan> dainanaki: it might be called skip
13:05:57 <edwardk> hrmm, for some reason i'm on 1.8, blech
13:06:05 <dainanaki> Saizan, skip actually has a different meaning
13:08:07 <Yacoby> As my first serious program I have written some basic irc client which when it recives some text from the server, it calls a user specified callback:
13:08:10 <Yacoby> ircOutput :: String -> ReaderT Network IO ()
13:08:15 <Yacoby> However, if I wanted to do something involving another monad (lets say with a database in that function) how would I do it? Or could I do it? Or have I designed something totally     wrong?
13:09:07 <Yacoby> (Network is just data that contains a Handle)
13:09:24 <Peaker> Yacoby: Usually a good design is to indirect the monad transformers you use into a custom "stack" hidden behind your own newtype. Then, you can make named lifters for every "transformer" you have in there, so you can address them by name and not via "lift . lift . ..."
13:10:46 <Peaker> Yacoby: something like:   newtype IRC a = IRC { unIRC :: FooT (ReaderT Network IO) a }  ; liftFoo = IRC ; liftNetwork = liftFoo . lift
13:11:05 <Peaker> Yacoby: the newtype will probably use GeneralizedNewtypeDeriving to auto-derive Functor, Applicative, Monad, too
13:11:14 <Yacoby> Peaker: Ah ok
13:11:23 <Yacoby> that makes sense
13:11:34 <Yacoby> (and the example was really help full)
13:11:37 <Peaker> Yacoby: then all your program types are  IRC a  so it's easy to add another layer
13:11:56 <Peaker> (without breaking anything, of course)
13:12:06 <Yacoby> Peaker: :D Many thanks for the pointers in the right direction
13:12:08 <kmc> once you do that, using transformers at all is less compelling
13:12:33 <djh_> I want to write a Haskell program that watches a directory and reacts to the event of a file being placed in said directory
13:12:36 <Peaker> kmc: well, the benefit becomes local rather than global, but it is still a benefit to compose existing transformers than write it all?
13:12:43 <djh_> does anyone know of any libraries that would aid me in this process?
13:13:02 <edwardk> another option is to just declare a type IRC = ReaderT Foo (StateT s IO)
13:13:04 <kmc> Peaker, sometimes.  and sometimes they introduce more cruft than they save
13:13:06 <Peaker> djh_: hinotify / system-inotify
13:13:16 <edwardk> then you can avoid having to fiddle with newtypes, and have only one place to mutate your code
13:13:20 <Peaker> kmc: elaborate? I'm not sure what you mean
13:14:11 <djh_> Peaker: excellent thanks!
13:14:20 <Peaker> djh_: not sure how portable those are
13:14:23 <Peaker> (or how complete)
13:14:49 <Peaker> edwardk: I dislike the O(N^2) monad transformer instances, so a newtype helps by hiding those so the atrocity isn't used :-)
13:15:57 <edwardk> i'm neutral. the 'type' version lets you exploit the mtl and in exchange for one line lets you use all the combinators. the newtype means you need to at least using generalized newtype deriving to copy all the instances down to your type
13:16:33 <Peaker> edwardk: well, you explicitly don't want the MonadTrans instance, and I also don't want the MonadState/MonadRead/etc instances
13:16:35 <kmc> Peaker, i mean that, when implementing the "primitive" operations of your stack, it can be nicer to just work with functions and arguments (you know, that quaint FP stuff) rather than lift lift lift lift
13:16:47 <edwardk> found my problem i was a version of the platform behind. downloading 2011.2.0.1
13:17:22 <Peaker> kmc: well, it's just a bunch of named lifters boilerplate... Much less code/complexity/error-prone than implementing the various monads you can throw in there
13:17:39 <Peaker> Could be nice to have a TH thing auto-generate the named lifters
13:18:16 <edwardk> otoh, that helps when you decide you're sick of the mtl and want to roll a custom monad which has been carefully cps'd to serve your needs
13:18:53 <kmc> i think for Reader especially, the sugar provided is of dubious value
13:19:15 <edwardk> if you don't want MonadState/MonadReader, etc then why use the mtl in the first place?
13:19:43 <kmc> i don't really think named lifters are the solution
13:22:52 <Peaker> edwardk: because I want the monads that were already implemented, and various combinators
13:22:59 <Peaker> edwardk: there's more to transformers/mtl than these instances
13:23:40 <dainanaki> woot, I managed to get my packet parser down to a constant heap allocation rate of about 3,000 bytes at any given moment.
13:25:45 <edwardk> well, the monads are all over in transformers, mtl doesn't seem to buy you anything ;)
13:30:25 <edwardk> what does default-language: Haskell2010 do in cabal 1.10?
13:31:16 <edwardk> just toggle on the right language features?
13:31:28 <dainanaki> it enables the xygzzcatahylomonomonads
13:31:51 <edwardk> my main concern is makingsure it doesn't lock me out of using anything sane ;)
13:33:04 <HanselVanKansel> I'm reading a Haskell tutorial right now, and several functions are "implemented" different each time: what are the differences of these, besides notation and syntax?
13:33:29 <dainanaki> what functions are you referring to in particular?
13:33:32 <Botje> HanselVanKansel: can you give an example?
13:33:47 <HanselVanKansel> map, sum, flip
13:34:14 <dainanaki> flip only probably differs in notation
13:34:37 <parcs> HanselVanKansel: some implementations are more efficient faster than others
13:34:37 <dainanaki> map and sum can have large differences in performance depending on how they are written.
13:34:40 <monochrom> http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg18923.html  so apparently, before 7 (but somewhere since 6.10 or before) "boxy types" got "runST $ return ()" to work, and also "runST & return ()" if you define your own "a & b = a b". but in 7, $ is special, your own & won't work
13:35:13 <ddarius> What?
13:35:23 <edwardk> monochrom: ah
13:35:29 <edwardk> monochrom: thanks =)
13:36:16 <HanselVanKansel> why are these performance differences? what knowledge do I need to program more efficient functions (after seeing they are slow)?
13:36:51 * hackagebot representable-profunctors 0.4.0.1 - Representable profunctors  http://hackage.haskell.org/package/representable-profunctors-0.4.0.1 (EdwardKmett)
13:38:19 <dcoutts> edwardk: default-language: Haskell2010  does what you'd expect. It says all your modules are in the language Haskell2010, as opposed to Haskell98
13:38:30 <edwardk> dcoutts: if i have a package that doesn't care about any of the differences between haskell 98 and haskell 2010 what is the best practice for how to enter the default-language field ?
13:38:44 <ddarius> representable-profunctors being just parameterized representability?
13:38:46 <dcoutts> edwardk: again, if you're mixing languages then use other-languages:
13:38:49 <dainanaki> HanselVanKansel, tuning functions is largely about making sure that you aren't lazily accumulating values when you will have to evaluate all of the values anyways
13:38:51 * hackagebot profunctor-extras 0.3.1.3 - Profunctor extras  http://hackage.haskell.org/package/profunctor-extras-0.3.1.3 (EdwardKmett)
13:39:02 <edwardk> ddarius: representable and corepresentable profunctors, yeah
13:39:24 <HanselVanKansel> ok, has it to do with tail-recursion?
13:39:25 <dcoutts> edwardk: there's no way to state that you're using the common subset of haskell 98 and haskell 2010 (because there's no reasonable way to check that)
13:39:58 <Saizan> dainanaki: or making sure you're not filling your memory by forcing stuff you won't need until later :)
13:40:26 <edwardk> dcoutts: basically i'm just writing good old fashioned ghc-friendly code, i'm not linking in the craptastic haskell98 or haskell2010 packages, etc. but using cabal 1.10 now wants me to specify one or the other
13:40:36 * ddarius would not say that "tuning functions" is "largely" about making sure you aren't "lazyily accumulating values."
13:40:50 <dainanaki> I'm just giving an answer that occurs more for beginners
13:40:51 <monochrom> tail recursion vs non-tail recursion is pretty irrelevant here
13:41:09 <dcoutts> edwardk: you're definitely using one or the other, because ghc is using one or the other
13:41:19 <edwardk> dcoutts: my main concern is ensuring that my core portable code continues to run on as many compilers as possible.
13:41:24 <monadic> edwardk: Whats wrong with haskell2010 package?
13:41:25 <dcoutts> edwardk: if you say nothing in the .cabal file, cabal tells ghc to use haskell98
13:41:41 <dainanaki> I've not seen many people that are overly strict with foldl for example...
13:42:16 <ddarius> dainanaki: Plenty of beginners and not-so-beginners, write overly strict code.
13:42:24 <dcoutts> edwardk: you can get close to a common subset if you use haskell98 and no n+k patterns
13:42:32 <edwardk> dcoutts: sure, thats basically what i do
13:42:45 <ddarius> Often because they are told that "making things strict is how you make them fast."
13:42:55 <dcoutts> edwardk: but I mean using extensions: NoNPlusKPatterns
13:43:09 <edwardk> dcoutts: just trying to figure out the right thing to say to appease cabal. i went and upgraded the cabal file to 1.10 and now it needs to  be told =)
13:43:34 <HanselVanKansel> thanks all :)
13:43:40 <dcoutts> edwardk: it's not necessary to specify the default language as far as I know
13:43:51 * monochrom knows a way out of this debate. when a beginner uses the advice of making things eager, he/she loses the beginner chastity!
13:44:03 <edwardk> Warning: Packages using 'cabal-version: >= 1.10' must specify the
13:44:03 <edwardk> 'default-language' field for each component (e.g. Haskell98 or Haskell2010).
13:44:08 <dainanaki> ddarius: could you provide an example of overly strict code that a beginner has written? I'd attribute that more to lower-intermediate haskeller...
13:44:24 <ddarius> dainanaki: Writing things like map in tail recursive form.
13:44:40 <dcoutts> edwardk: oh ok :-)
13:44:44 <edwardk> dcoutts: i presume the NoNPlusKPatterns should live in default-extensions rather than other-extensions?
13:44:48 <dcoutts> edwardk: yep
13:45:22 <dcoutts> edwardk: I guess we decided that people should start being aware of what language they're using
13:45:31 <dcoutts> edwardk: since ghc now defaults to Haskell 2010
13:45:45 <dcoutts> but cabal defaults to Haskell 98
13:45:58 <edwardk> well, i'm more than willing to switch everything up to 2010, i've just been programming defensively to the intersection
13:46:07 <dcoutts> you can do that, that's fine
13:46:54 <edwardk> and trying to figure out what incantation i have to say to not have some guy ping me by email and complain that my packages don't compile on some obscure cabal supported compiler, when they could with some small tweak ;)
13:47:42 <ddarius> dainanaki: I've also seen plenty of code that is littered with seqs or, now, bangs in vain attempts to fix performance problems, or occasionally "just to make things faster."
13:48:04 <roconnor> this paper on modularising inductive definitions is a bit difficult.
13:49:04 <dainanaki> ddarius, so have I, I think we just differ about at what point someone is no longer a beginner.
13:49:05 <edwardk> Warning: Unknown extensions: NoNPlusKPatterns — did i miss something?
13:49:21 <MHD> hey guys, I'm having real trouble installing the LLVM package
13:49:51 <ddarius> dainanaki: I'm talking about cases where this is someones first program or first "real" program.  I've also seen plenty of cases by others as well.
13:49:55 <MHD> edwardk: havent that been removed entirely?
13:49:58 <monadic> MHD: Is llvm itself and llvm-devel/llvm-dev installed
13:50:11 <monadic> edwardk: Isn't NoNPlusKPatterns the default
13:50:20 <ddarius> dainanaki: Plenty of beginners assume that their performance problems are due to laziness and then assume that "getting rid of it" will solve them.
13:50:20 <edwardk> monadic: in Haskell2010
13:50:20 <MHD> monadic: Yes, I have 2.9 LLVM
13:50:21 <monadic> edwardk: Hence the extension would be NPlusKPatterns
13:50:29 <monadic> MHD: With headers?
13:50:45 <edwardk> monadic: i was trying to code to Haskell98 in the cabal file and turn ON NoNPlusKPatterns to model the intersection of Haskell98 and Haskell2010
13:50:45 <ddarius> Others just have come from Scheme or other functional languages and apply habits from them without thinking.
13:50:46 * shachaf has seen someone %s/\$/$!/g in an attempt to speed up a slow program.
13:50:46 <MHD> monadic: I have both include files and linker files
13:50:58 <edwardk> but it seems i'm currently constrained to lie
13:51:32 <edwardk> since i have code that will compile in either case
13:51:33 <monadic> MHD: Are you installing with a package manager or cabal-install?
13:51:41 <MHD> monadic: cabal install
13:51:55 <monadic> MHD: Any error messages on the build?
13:51:58 <MHD> monadic: It says I lack linker libs that don't exist in LLVM
13:52:16 <monadic> MHD: Whats a linker lib? Are you on Windows by some chance?
13:52:22 <MHD> monadic: yes
13:52:23 <HanselVanKansel> ddarius: what habits should (and shouldn't) a Haskell programmer have?
13:52:25 <dainanaki> lately, my goto for improving performance is to strictify my constructors and to make judicious use of enumerators.
13:52:25 <edwardk> dcoutts: seems i have to just say Haskell2010 and give up on 98 support completely, unless i can say it somehow with this 'other-languages' thing you mentioned.
13:52:29 <monadic> MHD: Sorry, can't help you there
13:52:42 <MHD> monadic: okay then
13:53:07 <MHD> monadic: is it really that much different on whatever you're good at?
13:53:30 <ddarius> HanselVanKansel: That question is wrong headed.
13:53:43 <dcoutts> edwardk: I don't follow, why not just say default-language: Haskell98 ?
13:54:04 <edwardk> dcoutts: then i risk a compiler coming along that was never written to support n+k patterns ;)
13:54:51 <monochrom> a haskell programmer should have the habit of proving correctness, and should not have the habit of blind guessing
13:54:57 <edwardk> dcoutts: part of my secret motivation is that my toy 'turbo haskell' compiler doesn't have any plans to support them =)
13:54:58 <dcoutts> edwardk: oh all the ones that do that just lie and claim to support Haskell98
13:55:13 <monochrom> the habit of intelligent design, and not the habit of random mutation
13:55:13 <edwardk> fair nuff
13:55:16 <HanselVanKansel> ddarius: well, let me say it differently. A Haskell programmer going to some other functional language will also have habits it will apply, without thinking: what are those? (and if not, why?)
13:55:16 <dcoutts> edwardk: there's no other reasonable way for cabal to support them
13:55:35 <monochrom> turbo haskell?!! :)
13:55:38 <dcoutts> edwardk: because the presumably technically support neither 98 nor 2010
13:55:39 <edwardk> defaulting to extensions relative to 98 it is then
13:56:01 * monochrom improves "turbo haskell" into "boring haskell" :)
13:56:36 <edwardk> monochrom: =P
13:58:49 <ddarius> edwardk: No one uses n+k patterns anyway.
13:59:12 <EvanR7> > [1..] == take 1 [1..]
13:59:12 <lambdabot>   False
13:59:20 <EvanR7> o_O
13:59:32 <EvanR7> oh
13:59:35 <edwardk> ddarius: agreed, thats why its not so bad for me to ignore them, just wanted to try to ensure i was saying it correctly
13:59:38 <EvanR7> > [1..] == drop 1 [1..]
13:59:38 <lambdabot>   False
13:59:43 <EvanR7> o_O
13:59:51 <parcs> > 1 == 2
13:59:52 <lambdabot>   False
13:59:57 <Axman6> > [1..] == drop 1 [0..]
13:59:59 <parcs> o_O
14:00:01 <lambdabot>   mueval-core: Time limit exceeded
14:00:11 <EvanR7> oh
14:00:30 <EvanR7> > let ones = repeat 1 in ones == drop 1 ones
14:00:33 <lambdabot>   mueval-core: Time limit exceeded
14:00:37 <EvanR7> True
14:01:29 <monochrom> equality is hard
14:01:53 <EvanR7> another similar thing is sum of 1/2^i
14:01:55 * hackagebot profunctor-extras 0.3.1.4 - Profunctor extras  http://hackage.haskell.org/package/profunctor-extras-0.3.1.4 (EdwardKmett)
14:01:59 <ddarius> Not in discrete Hausdorff spaces.
14:02:19 <HanselVanKansel> > [1..] == [1..]
14:02:22 <lambdabot>   mueval-core: Time limit exceeded
14:02:27 <EvanR7> True
14:02:33 <Axman6> > let x = [1..] in x == x
14:02:37 <lambdabot>   mueval-core: Time limit exceeded
14:02:39 <monochrom> > P == NP
14:02:40 <lambdabot>   Not in scope: data constructor `P'Not in scope: data constructor `NP'
14:02:43 <EvanR7> lol
14:02:45 <HanselVanKansel> lol
14:02:56 <edwardk> Axman6: you need to use stablenames ;)
14:02:58 <monochrom> wait, EvanR7 is supposed to answer "True" or "False"
14:03:00 <EvanR7> True, True, lol
14:03:07 <monochrom> \∩/
14:03:13 <Axman6> edwardk: aye
14:03:17 <incluye> it times out when evaluating [1..] == [1..] ?
14:03:28 <monochrom> yes. you would, too
14:03:29 <Axman6> incluye: of course
14:03:30 <EvanR7> @src [] ==
14:03:30 <lambdabot> Source not found. Maybe if you used more than just two fingers...
14:03:40 <incluye> well okay
14:03:46 * incluye was beginning to think Haskell was actual magic
14:03:52 <mav> >/join #emacs
14:03:55 * hackagebot representable-profunctors 0.4.0.2 - Representable profunctors  http://hackage.haskell.org/package/representable-profunctors-0.4.0.2 (EdwardKmett)
14:03:59 <monochrom> not magical enough for P == NP
14:04:00 <edwardk> incluye: it is magic, thats just a silly spell ;)
14:04:08 <Axman6> [] == [] = True; (x:xs) == (y:ys) = x == y && xs == ys
14:04:16 <incluye> anyway I want to break into the haskell scene
14:04:18 <companion_cube> monochrom: just wait for quantum-haskell
14:04:21 <incluye> should I start with LYAH
14:04:22 <monadic> I saw some cool pseudo-proof for P/NP
14:04:27 <monadic> trying to remember it
14:04:28 <shachaf> @google seemingly impossible functional programs
14:04:29 <lambdabot> http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
14:04:29 <lambdabot> Title: Seemingly impossible functional programs « Mathematics and Computation
14:04:39 <Axman6> incluye: indeed you should. and you should ask questions here too
14:04:43 <monochrom> like N*(P-1) = 0?
14:04:46 <edwardk> incluye: turns out solving that in general requires an oracle for the halting problem. http://fsl.cs.uiuc.edu/index.php/Equality_of_Streams_is_a_Pi_2%5E0-Complete_Problem
14:04:53 <monochrom> err, (N-1)*P = 0
14:05:18 <EvanR7> one real root, two complex
14:06:25 <monochrom> humans should try fix ((1:) . scanl (+) 1) == fix (scanl (+) 1 . (0:)) before expecting computers to do so
14:06:47 <EvanR7> need hypercomputers
14:06:58 <monochrom> and that one is already a solved problem
14:06:58 <edwardk> P = NP, so NP - P = 0, so (N - 1)P = 0, so either P = 0 or N = 1, P = 0 is silly, so as long as you pick N = 1, we're good.
14:08:53 <edwardk> dcoutts: is there a doc somewhere describing what else is new in 1.10?
14:09:11 <monochrom> I got to P=0 or N=1 as well. but P is poly, can't be 0. N is nondeterminism, can't be 1. contradiction. P /= NP
14:09:12 <dcoutts> edwardk: apart from the changelog, no not really
14:09:34 <dcoutts> edwardk: I'll try and indicate in the new user guide when things were introduced
14:09:53 <dcoutts> could have a what's new I suppose for major versions too
14:10:10 <EvanR7> monochrom: you should publish
14:10:30 <dainanaki> P = NP, so P * 1 = P * N. therefore N = 1
14:10:31 <EvanR7> probably a better job than that dude last year who supposedly solved it
14:10:32 <dainanaki> problem sled
14:10:35 <dainanaki> *solved
14:10:46 <incluye> > [()..()]
14:10:47 <lambdabot>   [()]
14:10:57 <edwardk> dcoutts: would be great. just trying to figure out if i get anything out of 1.10 that is worth breaking older users for
14:11:26 <HanselVanKansel> EvanR7 that scribd document?
14:11:26 <edwardk> dainanaki: or P = 0
14:11:48 <EvanR7> dont remember
14:11:53 <monochrom> cabal-install 2.0 will have a polynomial-time satisfiability solver :)
14:11:55 <dcoutts> edwardk: notice that you can use the new fields with older cabal versions, they just ignore it
14:11:58 <edwardk> dainanaki: which leads to the unsettling result that there are two results for P = NP ;)
14:12:13 <dcoutts> monochrom: yup! (it just will not be complete)
14:12:17 <dainanaki> I'm not that unsettled… it's like imaginary numbers
14:12:20 <edwardk> dcoutts: ahh. those warnings aren't critical then?
14:13:17 <dcoutts> edwardk: if you specify cabal-version: >=1.10 then you must specify default-language, but if you specify cabal-version: >=1.8 then you can still use default-language
14:13:27 <edwardk> dcoutts: no way to use them without getting a Warning: To use the 'default-language' field the package needs to specify at
14:13:27 <edwardk> least 'cabal-version: >= 1.10'. ?
14:13:29 <HanselVanKansel> is it possible to have [1..] == [1..] to be at the same time True and False?
14:13:48 <kmc> no
14:14:01 <dcoutts> edwardk: oh, I'm proved wrong again. I thought it didn't care about that.
14:14:11 <kmc> HanselVanKansel, a function always returns the same value on the same inputs
14:14:14 <EvanR7> data Trool = True | False | TrueFalse
14:14:23 <HanselVanKansel> oh wow, wrote a blog about that, EvanR7
14:14:30 <EvanR7> o_O
14:14:37 <kmc> :k Maybe Bool
14:14:37 <lambdabot> *
14:14:50 <edwardk> dcoutts: sadly right now it seems my best option is to do nothing, and leave my cabal file down at 1.6 and ignore these until something else drags me kicking and screaming into 1.10
14:15:00 <dcoutts> edwardk: perhaps my logic was that it changes the meaning so it can't be ignored. It'd only be ok to ignore default-language: Haskell98
14:15:10 <edwardk> dcoutts: in the interest of maximizing the avaiability of the packages
14:15:42 <edwardk> dcoutts: hrmm, so i can state other-extensions, but not a default-language
14:15:45 <dcoutts> edwardk: yep, it's more or less always ok to stick to old versions, only bumping when you need new stuff
14:15:52 <edwardk> that seems like a reasonable compromise
14:15:58 <insane> is there a limit on writeFile function, that causes it to effectively write up to 2047 bytes to the file?
14:16:22 <insane> i mean all further bytes are not present in file
14:16:27 <dcoutts> insane: no
14:16:51 <dcoutts> insane: it just means you've got a bug in your code
14:16:55 <edwardk> k. so >= 1.6, with other-extensions seems to maximize my audience
14:17:35 <insane> dcoutts: when I use putStrLn it prints the whole content correctly, but when using writeFile it writes only 2047 bytes
14:17:57 * hackagebot representable-profunctors 0.4.0.3 - Representable profunctors  http://hackage.haskell.org/package/representable-profunctors-0.4.0.3 (EdwardKmett)
14:18:22 <dcoutts> insane: is your program terminating abnormally? the buffering on stdout will be different from the buffering on a file
14:18:49 <dcoutts> insane: that is, writing to stdout will flush more actively (defaults to flushing on '\n')
14:18:57 * hackagebot profunctor-extras 0.3.1.5 - Profunctor extras  http://hackage.haskell.org/package/profunctor-extras-0.3.1.5 (EdwardKmett)
14:19:01 <dcoutts> for a file it will do block buffering
14:19:24 <insane> dcoutts: ok that must be it
14:19:32 <dcoutts> insane: are you using threads?
14:19:37 <monadic> Especially considering it is 2^11-1
14:19:51 <HanselVanKansel> EvanR7 http://cplang.wordpress.com/2009/12/19/binop-and-or/ never actually finished the idea, it was too complicated
14:20:25 <dcoutts> edwardk: btw, what was your rationale for splitting up category-extras?
14:20:49 <HanselVanKansel> perhaps I can implement it in Haskell, as a learning exercise!
14:20:54 <edwardk> dcoutts: i had a million external dependencies, so i broke when any of them changed, and the package required a ton of extensions even though large parts of it were haskell 98
14:21:26 <dcoutts> edwardk: really? it's just array, base and mtl
14:21:26 <edwardk> many of the new packages have one or two dependencies and are completely 98, making them potentially standardizable
14:21:50 <edwardk> they were stripped down to that, but that meant i left off a lot of instances
14:21:58 * hackagebot comonads-fd 1.8.0.2 - Comonad transformers using functional dependencies  http://hackage.haskell.org/package/comonads-fd-1.8.0.2 (EdwardKmett)
14:22:28 <edwardk> but it basically used every extension under the sun, so to get comonads you had to accept that you could only use ghc and compile 120+ modules
14:22:52 <dcoutts> edwardk: I asked because I've heard people grumbling that the new ones take all the good names, and they can't find the new ones
14:22:54 <edwardk> now it just uses haskell 98, and is in a relatively small package
14:23:26 <dcoutts> edwardk: I wonder if it'd have been possible to split into just two, e.g. the haskell98 parts and the extra part with slightly more deps
14:23:31 <edwardk> not being able to find them is awkward
14:23:56 <edwardk> it might have, but then you'd still have an enormous pile of dependencies that wouldn't be very satisfying
14:24:14 <dcoutts> I'm not sure I understand the enormous pile of dependencies
14:24:37 <dcoutts> three doesn't strike me as enormous, though I can see it's nice to have parts be H98
14:24:41 <edwardk> most of my current packages aren't 'categorical' in nature
14:24:59 <edwardk> some of them only require one or two extensions easily ported
14:25:12 <edwardk> others need fundeps and mptcs, a couple use type families
14:25:30 <dcoutts> edwardk: so when you say dependencies, you mean language extensions
14:25:40 <Peaker> edwardk: about transformers above -- I didn't realize you meant the technical distinction between the contemporary mtl/transformers packages.. Yeah, I may not need the mtl if it just adds the instances. I haven't been following the changes in these packages, and have just been using transformers, making sure the imports work :-)
14:25:43 <edwardk> i leverage containers, transformers, mtl, some build on memotrie, which means dragging in every one of conal's packages
14:26:04 <edwardk> i mean both the language extensions and packages
14:26:53 <edwardk> anyways the packages that i have that use short names are almost all haskell 98, designed to be possibly standardized
14:27:27 <monadic> edwardk: mtl vs transformers...
14:27:57 <edwardk> and if i went and wasted another 6 months piling all the crap back into 2-3 uber-packages i'd be back wheere i started, with people complaining they don't want to use some little thing because it drags in 200 modules they don't need
14:28:36 <edwardk> my current algebra package is taking the monolithic route
14:28:59 <edwardk> but then it builds on top of the top of my categorical tower, since it uses representable functors for vector spaces
14:29:07 <edwardk> so it already needs all the extensions
14:29:54 <monochrom> achievement unlocked: 100-deep dependency chain
14:30:18 <edwardk> as for using a lot of names, not sure what i could do. i really don't like the prospect of mangling all my package names, and most have little to nothing to do with one another.
14:30:53 <edwardk> and i grab good names because they are good names for the package in question =P
14:31:11 <edwardk> if there was an author search or something on hackage it might make it easier to find them all
14:31:15 <danharaj> as someone who uses edwardk's new packages, I say they're great when they come in handy.
14:31:18 <Peaker> large dependency graphs are a testament to good software: composability.. But people hate it :-)
14:31:23 <kmc> i'm glad we got past the era where every Haskell library must have a name starting with 'h'
14:31:28 <danharaj> If there's a problem with package names, then it's a problem with hackage's organization.
14:31:51 <Peaker> kmc: I thought the "h" prefix was mostly for bindings, to distinguish them from the original names
14:32:02 <nyingen> how do I get the call stack for a runtime exception? possible?
14:32:41 <olsner> Peaker: but... with bindings there is no ambiguity except if it's bindings for a different haskell package :)
14:32:44 <kmc> @where RTS-xc
14:32:44 <lambdabot> ghc --make -fforce-recomp -prof -auto-all -rtsopts foo.hs && ./foo +RTS -xc
14:32:47 <kmc> nyingen, ^^
14:32:57 <nyingen> kmc: ok I'll try that
14:32:58 * monochrom uploads hunification :)
14:33:00 <kmc> GHC Haskell doesn't have a "call stack" per se
14:33:17 <kmc> it has a stack of thunk forcings that set off other thunk forcings
14:33:21 <nyingen> yeah, I'm not sure myself what I mean by that, but I'm getting a failed pattern match in a library I'm using
14:33:28 <nyingen> i'd like to know more about what caused that to happen
14:33:35 <kmc> but the profiling cost-center stack is closer to a traditional call stack, which is what that gives you
14:33:39 <monochrom> nice, I will try to remember "RTS-xc" next time
14:33:41 <nyingen> ok
14:34:03 <kmc> monochrom, yeah, I hope to teach all of my speeches to lambdabot
14:34:19 <Peaker> olsner: no ambiguity on hackage, perhaps.. still ambiguous when talking about it in other contexts.. may get annoying to say: <some-name> (the c lib) all the time :-)
14:34:33 <monochrom> actually may also help to have "@where call stack" for that
14:34:49 <kmc> including such classics as "evaluation and execution are distinct processes" and "Text.Regex is a crime against nature"
14:34:58 <kmc> and "ByteString.Char8 is racist"
14:35:04 <monochrom> @where Text.Regex is a crime against nature
14:35:04 <lambdabot> I know nothing about text.regex.
14:35:16 <monochrom> oh, it has to be one token
14:35:17 <olsner> Peaker: true :)
14:35:21 <nyingen> kmc: ghc says -rtsopts is unrecognized
14:35:25 <nyingen> typo? or version problem?
14:35:28 <kmc> nyingen, drop that for ghc < 7
14:35:31 <nyingen> ok
14:35:51 <monochrom> @where+ call-stack ghc --make -fforce-recomp -prof -auto-all -rtsopts foo.hs && ./foo +RTS -xc
14:35:51 <lambdabot> Done.
14:35:57 <monochrom> @where call-stack
14:35:58 <lambdabot> ghc --make -fforce-recomp -prof -auto-all -rtsopts foo.hs && ./foo +RTS -xc
14:37:29 <parcs> @where+ foo @where foo
14:37:29 <lambdabot> Nice!
14:37:34 <parcs> @where foo
14:37:34 <lambdabot>  @where foo
14:37:43 <parcs> smart lambdabot..
14:37:47 <monochrom> you're better off doing it just for "recursion"
14:37:59 <monochrom> @where fix
14:37:59 <lambdabot> I know nothing about fix.
14:38:15 <monochrom> @where+ fix try: @where fix
14:38:15 <lambdabot> Okay.
14:38:15 <HanselVanKansel> @where you
14:38:15 <lambdabot> I'm right here, silly.
14:38:15 <shachaf> ?where+ foo ?where foo
14:38:15 <lambdabot> I will never forget.
14:38:18 <shachaf> ?where foo
14:38:18 <lambdabot> ?where foo
14:38:28 <shachaf> ?where ?where
14:38:28 <lambdabot> ?where ?where
14:38:42 <monochrom> @where fix
14:38:43 <lambdabot> try: @where fix
14:38:53 <HanselVanKansel> lol
14:38:55 <ben> heh
14:39:50 <ddarius> lambdabot just doesn't listen to herself at all.
14:40:39 <shachaf> Right, because you don't get your own messages sent to you by the IRC server.
14:40:56 <erus`> yes you do :D:D:D:P
14:41:35 <monochrom> but it still has to avoid triggering other bots, who will trigger lambdabot back...
14:42:12 <shachaf> monochrom: lambdabot doesn't avoid that very well.
14:42:25 <Peaker> I've recently encountered another reason to hate lazy I/O... it supposedly hides the malicious-side-effecting-code behind memoization.. But it's all exposed when I try to run a background thread doing "getContents" and implement a timeout via: "threadDelay blah >> killThread theGetContentsThread"
14:42:33 <parcs> @where+ foo /query parcs hello!
14:42:33 <lambdabot> Nice!
14:42:36 <parcs> @where foo
14:42:36 <lambdabot> /query parcs hello!
14:42:36 <monochrom> yeah, we assume all bots listen to @ only
14:42:42 <HanselVanKansel> is there any Haskell source code editor that neatens your parenthesis, dots and dollars?
14:42:42 <Peaker> The side-effect-is-in-pure code is exposed in so many ways in practice
14:42:55 <kmc> hlint will give suggestions
14:43:18 <kmc> note that (.) and ($) are both ordinary infix functions
14:43:27 <kmc> so that problem generalizes quite a bit
14:43:40 <HanselVanKansel> great
14:43:42 <Peaker> hlint integration in the editor would be awesome
14:43:44 <kmc> i keep asking people how @pl works and they're like "lol, it's just an optimizing compiler, what's the problem"
14:43:52 <Peaker> mark the suggestions as red, hit a key to "accept" them
14:44:27 <shachaf> kmc: ?
14:44:39 <ddarius> kmc: No they aren't.
14:44:56 <monochrom> I only know that @pl is a lot of heuristics
14:45:06 <ddarius> kmc: The only person that describes pl as an optimizing compiler (unless people are copying me) is me, and I -never- say "lol."
14:45:16 <monochrom> hahaha
14:45:35 <ddarius> And that really all pl is.
14:45:45 <ddarius> (Implemented rather poorly.)
14:45:57 <shachaf> ddarius: Implemented poorly?
14:46:00 <kmc> so what, it just has a bunch of rewrite rules?
14:46:36 <ddarius> kmc: I believe that's the majority of it, though it has changed over time, and I don't know exactly what it looks like now.
14:46:38 <zmv> @protontorpedo
14:46:38 <lambdabot> wil I make mroe $$ than learning java or APL or smalltalk or plt scheme or ruby or perl or clisp?
14:46:53 <ddarius> I imagine there is a first pass that's a bit more systematically bracket abstraction.
14:47:08 <zmv> hahahahaha
14:47:16 <ddarius> Also, I specifically say it's an optimizing compiler to combinators a la Turner's work.
14:47:35 <nyingen> kmc: re call-stack: is there any quick way to recompile all the libs my program depends on with profiling enabled?
14:48:07 <kmc> notreally
14:48:26 <ddarius> @tell shapr Yay knitting!
14:48:26 <lambdabot> Consider it noted.
14:48:27 <burbul> Is there a type of computations which can read from files but not write to them? (I.e. computations which don't perturb the OS state?)
14:48:35 <kmc> if you're doing development you should set cabal to install profiling libraries by default
14:48:39 <kmc> but you still have to reinstall the exsiting ones
14:48:45 <ddarius> burbul: Reading from a file perturbs the OS state.
14:48:50 <nus> "module Plugin.Pl.Optimize"
14:48:59 <nyingen> kmc: ok
14:49:24 <burbul> Yes, in that it potentially fiddles with a timestamp (and maybe locks the file for other things), but in practice there still seems to be a big difference between reading and writing...
14:49:28 <burbul> Anyway, never mind.
14:49:53 <kmc> burbul, there's nothing standard that i know of
14:50:00 <kmc> it would be nice
14:50:04 <kmc> it would be nice in general to split up IO
14:50:09 <kmc> anyway you can implement it yourself
14:50:29 <ddarius> Actually, there is a paper describing an output system that's less constrained than monadic IO since it is output that is less significant to the functional program.
14:50:30 <burbul> Don't worry -- it's not that important, it's just that I had to use IO somewhere and it felt a bit over-powerful.
14:50:46 <burbul> I felt like I might be doing something wrong.
14:52:12 <kmc> you probably aren't
14:52:21 <bowabos> Hi, not a developer (at work), just passionate about dev languages... which book would you recomand (existing knowledge on Java (Spring/AOP), Scala)... Real World Haskell, Learn your Haskell for great good, Programming in Haskell? Thanks...
14:52:35 <Peaker> burbul: you can make your own monad/transformer that can do whatever subset of IO you'd like
14:53:05 * hackagebot comonad-extras 0.4.0.2 - Comonad transformers requiring extensions to Haskell 98  http://hackage.haskell.org/package/comonad-extras-0.4.0.2 (EdwardKmett)
14:53:23 <burbul> right -- thanks.
14:53:38 <kmc> bowabos, RWH and LYAH are both good
14:53:41 <kmc> and they're both free online
14:53:49 <kmc> read both and see which you like better
14:54:34 <Axman6> if you want to learn Haskell, i'd recomment LYAH followed by RWH
14:56:05 <HanselVanKansel> What real world problems are solved by Haskell, by the way?
14:56:08 <HanselVanKansel> any grand examples?
14:56:17 <hpc> @where industry
14:56:17 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_industry
14:56:31 <hpc> (there's a lot missing from that list)
14:57:06 <kmc> yeah, from the list you can see that it's used for a lot of custom internal tools and such
14:57:06 * hackagebot data-lens-template 1.8.0.2 - Utilities for Data.Lens  http://hackage.haskell.org/package/data-lens-template-1.8.0.2 (EdwardKmett)
14:57:11 <kmc> so presumably there's a lot more we don't hear about
14:57:17 <hpc> there's also xmonad
14:57:22 <bowabos> kmc, Axman6: Thanks... I've got my bed side reading list...
14:57:24 <kmc> especially because it's popular in finance and defense contracting ;P
14:57:35 <HanselVanKansel> ahh okay
14:58:00 <kmc> HanselVanKansel, the other real-world problem it solves is getting you a job, even if that job doesn't involve programming any Haskell
14:58:00 <HanselVanKansel> i'll take a look ;) should've Googled it first
14:58:02 <nyingen> hm, 'impossible' error from cabal upgrade
14:58:19 <monochrom> you are not supposed to "cabal upgrade"
14:58:42 <HanselVanKansel> kmc, please explain?
14:58:47 <nyingen> specifically cabal upgrade --reinstall --global -p base
14:58:49 <monochrom> this is a good chance to nuke your packages and start over
14:58:58 <Peaker> Haskell really could use more visible OSS if it is to fail to avoid success
14:58:58 <nyingen> yeah, been there
14:59:01 <kmc> HanselVanKansel, employers love people who know Haskell; it means you learned something hard for fun, not just to get a job
14:59:06 * hackagebot roundtrip-xml 0.3.0.1 - Bidirectional (de-)serialization for XML.  http://hackage.haskell.org/package/roundtrip-xml-0.3.0.1 (StefanWehr)
14:59:08 * hackagebot graphs 0.3.2.2 - A simple monadic graph library  http://hackage.haskell.org/package/graphs-0.3.2.2 (EdwardKmett)
14:59:09 <kmc> paradoxically this makes it easier to get a job
14:59:18 <HanselVanKansel> interesting!
14:59:45 <hpc> kmc: not that paradoxical, since you won't actually be using what you learned ;)
14:59:50 <kmc> note that this has nothing to do with properties of Haskell as a language
14:59:54 <kmc> http://www.paulgraham.com/pypar.html
15:00:08 <hpc> also, when you interview, be careful how you pronounce it
15:00:11 <monochrom> even if you don't love it (I couldn't care less about motivation), after learning haskell your knowledge is broadened, you can solve more problems more ways
15:00:21 <hpc> or they will think you said "pascal" and laugh you out of the room
15:00:22 <hpc> :P
15:00:28 <HanselVanKansel> are there any (OSS) projects a beginner Haskell programmer can work on, without being killed?
15:00:31 <kmc> similarly employers love people with college degrees because it certifies that you did a ton of work for a vague promise of future gain
15:00:35 <HanselVanKansel> haha! @hpc
15:00:47 <kmc> HanselVanKansel, xmonad-contrib
15:00:56 <hpc> what kmc said
15:01:04 <kmc> xmonad is configured in Haskell
15:01:13 <hpc> there's a lot of small places to do things in xmonad, which gets you very visible results
15:01:18 <kmc> so there's little barrier between making a cool config for your own use, to contributing it
15:01:26 <HanselVanKansel> great!
15:01:53 <edwardk> kmc: hahaha
15:02:01 <kmc> i think in general, though, more people learn Haskell initially by doing a bunch of toy projects on their own, than by contributing to something big
15:03:06 * hackagebot intervals 0.2.0.3 - Interval Arithmetic  http://hackage.haskell.org/package/intervals-0.2.0.3 (EdwardKmett)
15:04:02 <Peaker> monochrom: I've actually added church encodings as a trick to my C programming arsenal :-)  They're actually a less cumbersome representation of ADTs in C than enums+unions of structs
15:04:05 <HanselVanKansel> well, sure, but generally I start on huge monstrous hobby-projects, failing hard, learnt a great deal, without actually able to show anyone `hey this is what I made,´ and I'd like to do it differently this time with Haskell
15:04:48 <Peaker> And recently, a talented Python programmer thought I was superman when I easily CPS'd his code and added non-determinism effects to it
15:04:54 <sm_> HanselVanKansel: heh, quite right
15:04:54 <aninhumer> HanselVanKansel: consider working through the exercises in RWH
15:05:01 <Peaker> (I'm pretty sure I wouldn't be able to do it [as easily, at least] before I knew Haskell)
15:06:10 * hackagebot kan-extensions 2.0.0.2 - Kan extensions, the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-2.0.0.2 (EdwardKmett)
15:06:18 <Peaker> So I think that Haskell has indeed made me a better programmer at least in some aspects.. Though it has made me less motivated in other languages, and made it harder to learn OCaml and other languages, too :-(
15:06:40 <aninhumer> HanselVanKansel: Or if you fail, look at what you have done and see if you can refactor a module out of it
15:06:59 <kmc> Peaker, CPS without TCO? :/
15:07:22 <monochrom> (just add trampolining)
15:07:35 <kmc> continuation-throwing style
15:07:42 <monochrom> hahaha
15:07:44 <kmc> passing is a kind of throwing, right?
15:07:56 <monochrom> each is a kind of the other, yes
15:08:09 <Peaker> kmc: Well, I don't think any of his recursions were very deep :-)
15:08:43 <sm_> HanselVanKansel: hledger & shelltestrunner are beginner friendly and can always use help
15:08:59 <monochrom> what nondeterminism effect did you add?
15:09:22 <edwardk> kmc: i wrote a whole javascript compiler that used that 'throw the current continuation when the stack gets too full' chicken-scheme-ish approach
15:09:41 <HanselVanKansel> thanks all! great stuff!
15:10:11 * hackagebot representable-functors 2.0.0.3 - Representable functors  http://hackage.haskell.org/package/representable-functors-2.0.0.3 (EdwardKmett)
15:10:24 <Peaker> monochrom: he had a 2 for loops (one nested in other).  He had a "break" in the inner one. He said he wanted the code to continue both as if "break" in the inner loop happened, and as if it just passed through
15:10:40 <Peaker> monochrom: so non-determinism over that -- both exit the inner loop to continue the outer loop, and continue the inner loop
15:11:36 <Peaker> monochrom: it's an implementation of Earley parsing
15:11:45 <monochrom> oh, no wonder
15:15:13 * hackagebot representable-tries 2.0.0.2 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-2.0.0.2 (EdwardKmett)
15:16:12 * ddarius wonders who doesn't consider the Yoneda lemma as part of "very basic familiarity with category theory."
15:17:48 <adimit> … stupid question: how can it be that ghci *can* derive the type of something, but ghc cannot, and complains about ambiguous type variables?
15:18:10 <monochrom> ghci has more defaults than ghc
15:18:11 <ddarius> adimit: Read the user guide.
15:18:15 * hackagebot reflection 0.4.0.1 - Functional Pearl: Implicit Configurations  http://hackage.haskell.org/package/reflection-0.4.0.1 (EdwardKmett)
15:18:17 <adimit> (I'm guessing that ghci has monomorphism restrictions disabled per defualt?)
15:18:29 <adimit> ddarius: ok…
15:18:31 <monochrom> and lambdabot has more defaults than ghci, so don't trust lambdabot either
15:18:57 <monochrom> no, unrelated to monomorphism restriction
15:19:45 <adimit> monochrom: well, in my case, adding a language pragma nomonomorph… was sufficient. My best guess is that ghci evaluates terms *with* that pragma, and ghc doesn't. I was aware of lambdabot being special, but not ghci…
15:20:57 <kmc> adimit, you may have run into ghci's extended defaulting rules
15:21:04 <ddarius> adimit: Read the user guide.
15:21:20 <kmc> oh, they already said that
15:21:30 <adimit> ddarius: thanks, got it the first time. I shall, later.
15:21:33 <kmc> http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html#extended-default-rules
15:22:08 <adimit> kmc: thanks very much!
15:22:43 <kmc> "defaulting" is this ugly ad-hoc rule bolted onto the type class system
15:23:00 <kmc> it is somewhat related to the monomorphism restriction
15:23:02 <edwardk> yes but it avoids scaring the piss out of newbies when they type in 1 + 1
15:23:05 <Peaker> I wondered why the default spec was related to Num (was it?) and not generalized to any type-class
15:23:26 <ddarius> edwardk: Don't worry.  We added the monomorphism restriction to cover that gap.
15:23:43 <kmc> edwardk, yeah, it's funny that Haskell makes like three random concessions to beginners, and elsewhere is like "NO."
15:23:59 <kmc> MMR was supposed to be a concession to make it easier for beginners to reason about performance!
15:24:27 <edwardk> kmc: there are plenty of other concessions. witness Num
15:24:33 <monochrom> type class scares beginners either way
15:24:41 <edwardk> and the monomorphic type of map, and (++), etc.
15:24:45 <kmc> true
15:24:50 <edwardk> lots of haskell 98 design decisions were to make things less scary
15:25:01 <edwardk> the great monomorphism revolution
15:25:55 <monochrom> in Java, abstract class scares just as much. "why can't I new List()?"
15:26:16 <identity_> edwardk: What would happen without said defaulting when someone typed 1 + 1?
15:26:32 <kmc> it's ambiguous -- did you mean Int or Double or ...
15:26:38 <identity_> ah, yeah
15:26:41 <monochrom> @type 1+1
15:26:42 <lambdabot> forall t. (Num t) => t
15:27:07 <monochrom> you will get chastised for "what would you like for t?"
15:27:09 <shachaf> Defaulting is handy when you use ghci as a calculator.
15:27:16 * hackagebot streams 0.8.0.2 - Various Haskell 2010 stream comonads  http://hackage.haskell.org/package/streams-0.8.0.2 (EdwardKmett)
15:27:21 <aninhumer> edwardk: perhaps it would be better to have that as a separate "easy" type display feature?
15:27:40 <ddarius> [n] → [m] ↦ [n-1] → [n] → [m] is perhaps not the best choice of notation.
15:28:02 <aninhumer> so map is fmap, but if you :easytype map you get the monomorphic type?
15:28:12 <aninhumer> or something similar
15:28:13 <kmc> i'd rather have a BeginnerPrelude
15:28:21 <aninhumer> Also a thought
15:28:22 <ddarius> aninhumer: That would create massive confusion.
15:28:29 <kmc> lying about types is not a good idea
15:28:38 <kmc> if you want an analogy read a tutorial ;)
15:28:41 <ddarius> On the other hand, if you want a beginner-friendly Haskell, look at Helium.
15:28:43 <monochrom> in BeginnerPrelude, you will need at least two symbols for addition
15:28:53 <monochrom> and a million symbols for ==
15:28:59 <kmc> what about disabling defaulting outside ghci?
15:29:12 <kmc> if i put "default ()" in each of my haskell modules, how will my life change?
15:29:16 * hackagebot adjunctions 2.0.0.2 - Adjunctions  http://hackage.haskell.org/package/adjunctions-2.0.0.2 (EdwardKmett)
15:29:20 <Peaker> if we had a good IDE for Haskell, you could have defaulting in the IDE
15:29:40 <ddarius> kmc: It will change fairly little.
15:29:45 <monochrom> oh, nevermind, BeginnerPrelude probably has more defaults, Prelude has fewer. I agree
15:29:46 <aninhumer> Or perhaps an (e.g. <monomorphic>) after the sig? Perhaps just confusing again though
15:30:39 * ddarius needs a torch.
15:31:12 <monochrom> overall, I prefer interpreter prompt and compiler to use the same rules. so I don't have to keep warning "don't trust ghci"
15:31:17 <Peaker> Trying to cater to beginners and advanced alike seems to piss off the advanced and confuse beginners anyway :P
15:31:33 * ddarius agrees with both monochrom and Peaker.
15:32:05 <kmc> yeah, it's a delicate balance
15:32:29 <kmc> when you ask how to do something weird in #python they say "you don't actually want to do that, go away"
15:32:46 <HanselVanKansel> wait... so technically, I'm not programming Haskell now, in ghci?
15:32:47 <kmc> when you ask how to do something weird in #haskell they say "you don't actually want to do that, oh, but if you really do, here's how, no this way is better... [20 minutes of this]"
15:33:00 <kmc> yes HanselVanKansel
15:33:14 <Peaker> kmc: And #python says "We're not here to answer your Python questions, we're here to get you to write better code"
15:33:16 <MHD> all right, this is frustrating
15:33:26 <monochrom> in the next 50 decades, people will still be prototyping at the interpreter prompt and cross-interrogating that with the compiler command line, so you'd better make sure they agree
15:33:51 <kmc> HanselVanKansel, if you import a module with a dot in its name, you're technically not programming Haskell (98, they finally added it in H2010)
15:34:17 * hackagebot iteratee 0.8.6.2 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.8.6.2 (JohnLato)
15:34:19 <HanselVanKansel> ok. interesting
15:34:50 <kmc> but a lot of ghci examples will work under standard defaulting rules
15:35:06 <dolio> monochrom: I hope not.
15:35:17 <monochrom> hope is hopeless
15:35:57 <dolio> REPLs are clown shoes compared to agda mode.
15:36:02 <dolio> And that's a hacky emacs mode.
15:36:02 * ddarius has lost all hope in losing hope.
15:36:04 <Peaker> MHD: frustration is the mother of some invention
15:36:23 <MHD> Peaker: and broken computers.
15:36:42 <MHD> Peaker: Anger management issues and bad documentation is a bad mix
15:36:57 <Peaker> MHD: pfft. you read documentation? :-)
15:37:44 <MHD> Peaker: when shit doesn't work, yes
15:38:03 <ash__> I'd rather read docs than source code… but… well, sometimes you have to take it a step further
15:38:34 <kmc> i'd rather read machine code
15:38:37 <stobix> rtfb?
15:38:39 * kmc so h4rdc0re
15:38:52 <dainanaki> NERDS
15:39:05 <dainanaki> :D
15:39:07 <monochrom> I listen to the power supply tones
15:39:29 <sipa> dainanaki: dude, you're on IRC, what do you expect here?
15:39:42 <ash__> is that a compliment?
15:39:46 <monochrom> my old laptop's power adaptor makes small tones depending on what the laptop is doing!
15:39:47 <kmc> nerds all the way down
15:39:54 <aninhumer> I just examine the effect the magnetic states on the harddrive affect nearby butterflies
15:40:06 <HanselVanKansel> I just ask on IRC
15:40:08 <ash__> kmc: that just makes me think of a lot of candy...
15:40:25 <aninhumer> only in a sentence that starts the same as it ends
15:40:26 <monochrom> I ate nerd candies!
15:40:32 <Peaker> some blind people manage to "see" quite a bit sonar-wise by making sounds with their mouths and listening for the sound's reflections
15:42:45 <ash__> so… anyone in here a software engineering student? I have an assignment to interview a student, i thought i'd be difficult and try to interview a student not from my school
15:43:31 <MHD> I have a major problem with installing the LLVM, everybody, described in detail here: http://hpaste.org/49555
15:43:58 <HanselVanKansel> Computer Science also applies?
15:44:03 <MHD> Please help, I have been at it for hours on end and the frustration is unbearable
15:44:04 <monochrom> @where call-stack
15:44:05 <lambdabot> ghc --make -fforce-recomp -prof -auto-all -rtsopts foo.hs && ./foo +RTS -xc
15:44:08 <monochrom> @where- call-stack
15:44:08 <lambdabot> Maybe you meant: where where+
15:44:28 <monochrom> hmm how to erase it? because I want to change that to:
15:44:37 <monochrom> @where+ stack ghc --make -fforce-recomp -prof -auto-all -rtsopts foo.hs && ./foo +RTS -xc
15:44:38 <lambdabot> Done.
15:44:47 <ash__> MHD: your linker doesn't know which directory the llvm libs are in… do you know where they are? Specifically? you can specify it with -L/path
15:45:16 <MHD> ash__: No, listen. Those linker files dont even exist in the first place!
15:45:17 <ash__> oops, thats cabal, use --extra-lib-dirs
15:45:21 * hackagebot categories 0.58.0.3 - categories from category-extras  http://hackage.haskell.org/package/categories-0.58.0.3 (EdwardKmett)
15:45:23 <aninhumer> ash__: First year CompSci, if that helps
15:46:07 <HanselVanKansel> aninhumer same here, now ash__ can choose
15:46:40 <aninhumer> HanselVanKansel: Where at?
15:46:52 <HanselVanKansel> Leiden University
15:46:55 <HanselVanKansel> Netherlands
15:47:11 <ash__> okay comp sic people, this isn't one of my interview questions, but do you think there is a difference between comp sci and software engineering? I am a grad student taking a class on teaching and thats been a little debate we have been having, its interesting the different perspectives on it
15:47:36 <benmachine> ash__: I have an opinion on that even though I'm doing maths, does that count
15:47:44 <aninhumer> ash__: That probably depends a lot on the course
15:47:45 <Axman6> MHD: try using --extra-include-dirs and --extra-lib-dirs
15:48:22 * hackagebot eq 0.3.3.1 - Leibnizian equality  http://hackage.haskell.org/package/eq-0.3.3.1 (EdwardKmett)
15:48:24 <aninhumer> ash__: Or did you mean more abstractly
15:48:29 <Axman6> (as in, --extra-include-dirs=<llvm path>/include --extra-lib-dirs=<llvm path>/lib
15:48:33 <benmachine> I suspect some courses are called compsci when they should be called sweng
15:48:40 <ash__> according the the IEEE (who are trying to make a professional engineering cert for software people) http://www.computer.org/portal/web/swebok/htmlformat is what you should know if your a SWE
15:49:22 <aninhumer> HanselVanKansel: Cambridge, UK here
15:49:25 <HanselVanKansel> software engineering is, in The Netherlands, Softw. Engin. requires completion of Comp. Sci. bachelor degree: it builds on-top of theoretical principles
15:49:37 <benmachine> aninhumer: :O waaat
15:49:56 <ash__> in the US, where I am anyway, we view them as 2 separate degrees with a lot of overlap
15:50:15 <benmachine> aninhumer: I'd look up your name in the hermes directory but that would be creepy
15:50:19 <ash__> I got an undergrad in SWE, but I am about to finish my masters in CompSci
15:50:29 <benmachine> unless you meant location and not actual university
15:51:34 <coppro> ash__: Really? In my experience they were extremely persistenly confused (Canadian, here, where there is slightly more distinction due to the existence of professional engineering degrees, but still not a ton)
15:51:38 <MHD> Axman6: that doesn't help, my problem is still that all those libraries do not exist in the LLVM distribution
15:52:31 <ash__> MHD: where is the libLLVMSystem.so located? or .dll
15:53:07 <ash__> coppro: IEEE is still trying to get people to agree and certify SWE as a PE
15:53:24 * hackagebot free 1.8.0.3 - Monads for free  http://hackage.haskell.org/package/free-1.8.0.3 (EdwardKmett)
15:54:07 <ash__> so far though, they haven't been successful although they are the main guys behind the SWEBOK which is what they ultimately want to make the PE tests for SWE about
15:54:21 <MHD> ash__: libLLVMSystem is not located anywhere, it doesn't exist. Google turns up no results, and it isn't in the LLVM distribution.
15:54:54 <edwardk> oh goody, more certifications to add to the bin
15:54:59 <benmachine> :P
15:55:15 <ddarius> edwardk: To what end?
15:55:25 * hackagebot unboxed-containers 0.0.2.3 - Self-optimizing unboxed sets using view patterns and data families  http://hackage.haskell.org/package/unboxed-containers-0.0.2.3 (EdwardKmett)
15:55:26 <edwardk> sarcasm mostly
15:56:33 <MHD> Are there anyone here who has successfully installed the haskell LLVM?
15:57:29 <ash__> MHD: what about a libllvm.so? there should be some runtime library, they are required...
15:58:12 <ash__> I haven't ever used the llvm on windows, so I am not sure how its laid out on that system
16:00:22 <ash__> on os x when I installed the llvm I got a whole bunch of libraries under /lib, such as libLLVMCore.a libLLVMSupport.a etc… They might be .so or .dll though, (or whatever windows uses for static libraries, i don't think its .dll)
16:00:22 <acowley> edwardk: how would you expect your unboxed set to work for a use case that made lots of modifications to an ordered collection? I spent quite some time on such a program and never did better than list.
16:00:33 <MHD> ash__: is there some big list of all the static and dynamic linker libs in LLVM?
16:00:48 <edwardk> acowley: it is an old package. i mostly keep it up so that it builds
16:00:59 <ash__> MHD: I can make one if you want
16:01:07 <edwardk> acowley: and you need a big set for the asymptotics to pay out
16:01:21 <MHD> ash__: would be nice, I am at the frayed ends of sanity right now.
16:02:21 <ash__> MHD: http://hpaste.org/49556 is a list of the ones that came with my install of 2.9
16:02:41 <ash__> the clang ones are in there as well, but you can ignore those, they all start with libclang
16:02:43 <acowley> edwardk: Yeah, I was really disappointed with my efforts at optimizing this code
16:02:49 <acowley> it was some Delaunay triangulation code
16:02:54 <acowley> but I wanted to try a non quad-edge approach
16:03:08 <acowley> I ended up with a UArray of lists of neighbors for each vertex
16:03:29 <acowley> but I couldn't get close enough to the fastest C code
16:03:42 <edwardk> ah
16:03:53 <acowley> one thing that bugged me is that I was dealing with these ordered lists of ints
16:03:58 <edwardk> hard, with the overhead of dereferencing a uarray
16:04:02 <acowley> and doing a lot of insertions
16:04:07 <edwardk> yeah
16:04:23 <acowley> I was hoping I could unpack more and cut away at constant factors
16:04:44 <acowley> despite the drastic change in data structures, I could get to about half the speed of the fastest pointer-chasing C version
16:04:51 <acowley> but no faster than that
16:05:17 <acowley> I suppose it was a pleasant surprise how well GHC deals with regular lists
16:05:24 <acowley> there is not a lot of fat on that bone
16:05:28 * hackagebot recursion-schemes 1.8.0.2 - Generalized bananas, lenses and barbed wire  http://hackage.haskell.org/package/recursion-schemes-1.8.0.2 (EdwardKmett)
16:06:01 <ddarius> There is very little that is special about lists in GHC.
16:06:29 <kmc> aren't there lots of rewrite rules?
16:06:50 <edwardk> that would be the little ;)
16:07:00 <c_wraith> well, the syntax is also special :)
16:07:21 <dmwit> halp! cabal error: http://hpaste.org/49558
16:07:27 <ddarius> There are the foldr/build fusion rules, but those are a) library things, and b) mostly deal with common, but special cases.
16:07:29 * hackagebot categories 0.58.0.4 - categories from category-extras  http://hackage.haskell.org/package/categories-0.58.0.4 (EdwardKmett)
16:07:37 <dmwit> Also, the cabal file: http://hpaste.org/49557
16:08:56 <dmwit> (Trying to build an executable and a library from the same cabal file, following these instructions: http://stackoverflow.com/questions/6711151/how-to-avoid-recompiling-in-this-cabal-file )
16:09:08 <MHD> ash__: All right, now I have cut down the immensely long list a bit by fiddling with the paths. Sill missing 14 static linker libraries
16:09:19 <dcoutts> dmwit: what cabal --version ?
16:09:52 <dmwit> cabal-install 0.8.2, Cabal library 1.8.0.2
16:10:14 <dmwit> I see there's a new cabal-install, let me try it.
16:10:23 <dcoutts> dmwit: try a 0.10 version, 0.8 didn't properly support internal package dependencies
16:10:30 * hackagebot void 0.5.4.1 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.5.4.1 (EdwardKmett)
16:10:47 <dmwit> Will do.
16:10:52 <dmwit> Should have thought of upgrading. =P
16:12:33 * hackagebot monad-st 0.2.0.2 - Provides a MonadST class  http://hackage.haskell.org/package/monad-st-0.2.0.2 (EdwardKmett)
16:14:34 * hackagebot numeric-extras 0.0.2.2 - Useful tools from the C standard library  http://hackage.haskell.org/package/numeric-extras-0.0.2.2 (EdwardKmett)
16:15:39 * siracusa feels like having a deja-vu when looking at hackagebot's announcements
16:15:58 <edwardk> =P
16:16:12 <edwardk> the numbers have bumped, and there are about 12 other packages in here today that weren't in yesterday's wave
16:17:13 <ash__> MHD: do you have llvm-config in your path?
16:17:35 <Saizan> maybe we should build a tower defense game around this
16:17:38 <MHD> ash__: umm... what path, the LLVM path?
16:17:43 <dmwit> edwardk: Still no category-extras meta-package that depends on the split-up packages?
16:17:57 * dmwit mutters things at HTTP-4000
16:18:11 <edwardk> dmwit: 70% of the packages bear no real genesis from the contents of category-extras
16:18:15 <MHD> ash__: yes, i do have llvm-config in LLVM\bin
16:19:43 <ash__> MHD: go to a temp directory and do "cabal unpack llvm"
16:19:52 <ash__> then go in to that folder and run the configure script
16:20:18 <kmc> meta-packages aren't that useful with cabal
16:20:33 <kmc> because depending on a package doesn't make visible the modules of its dependencies
16:21:06 <parcs> ghc alloca > c alloca
16:21:24 <monochrom> or < if you measure cost :)
16:22:08 <parcs> who cares about cost, we have polymorphism!
16:22:35 <MHD> ash__: run the configure script? with llvm-config?
16:22:45 <parcs> :t ala
16:22:45 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
16:22:48 <ash__> no, it should just be called 'configure'
16:23:15 <MHD> ash__: oh, right
16:23:28 <parcs> :t ala reader runReader
16:23:28 <lambdabot>     Couldn't match expected type `(r -> a) -> Reader r a'
16:23:28 <lambdabot>            against inferred type `ReaderT r1 Identity a1'
16:23:28 <lambdabot>     Probable cause: `runReader' is applied to too many arguments
16:23:32 <ash__> it should automatically find the llvm-config, if it doesn't then you need to probably adjust your PATH, that would be the easiest solution
16:23:36 * hackagebot ad 1.1.0.1 - Automatic Differentiation  http://hackage.haskell.org/package/ad-1.1.0.1 (EdwardKmett)
16:25:27 <MHD> ash__: first of all it says something about me not having perl, and then that it can't find the LLVM C bindings
16:25:54 <ash__> okay, then add LLVM_DIR\bin to your path
16:26:05 <parcs> :t ala reader i
16:26:06 <lambdabot>     Couldn't match expected type `((r -> a) -> Reader r a) -> b -> n''
16:26:06 <lambdabot>            against inferred type `Expr'
16:26:06 <lambdabot>     In the second argument of `ala', namely `i'
16:26:26 <ash__> hmm wait...
16:26:29 <parcs> hmm didn't know C-M meant enter
16:26:43 <ash__> you don't have perl, thats means your llvm-config won't run, its a perl script
16:27:43 <MHD> ash__: fscking hell
16:29:53 <MHD> ash__: looks like it'll be easier to just wait till I install linux
16:30:06 <ash__> so… the easiest way would be to install something like Strawberry Perl, but if you don't want to do that just to be able to run the config scripts, then you can do it with cabal install llvm --configure-option="--with-llvm-bindir=/path/to/llvm/lib"
16:31:37 * hackagebot algebra 0.9.0.1 - Constructive abstract algebra  http://hackage.haskell.org/package/algebra-0.9.0.1 (EdwardKmett)
16:32:13 <MHD> ash__: I still need those 14 libs, which are apparently not avalable for download any fscing where on the internet
16:32:33 <acowley> edwardk: why is argminNaiveGradient in your rad package not generalized to a traversable for the domain of the function?
16:32:58 <edwardk> rad or ad?
16:33:08 <edwardk> rad is deprecated, ad is the future =P
16:33:13 <ash__> MHD: which llvm distribution did you download?
16:33:33 <acowley> edwardk: a note saying so much should be featured prominently :)
16:33:34 <MHD> ash__: The 2.9 binaries for mingw32/x86 one
16:33:50 <edwardk> acowley: i need to ping ross or someone and get it marked as such on hackage
16:33:50 <acowley> also, cmd-f ad is not helpful
16:34:10 <edwardk> ad is a MUCH stronger package, with reverse mode, forward mode, various dense higher derivative calculations, etc.
16:34:25 <acowley> edwardk: does the use of stable names hurt perf. much?
16:34:37 <dmwit> dcoutts: Works perfectly. Thank you.
16:34:48 <dcoutts> great
16:35:13 <edwardk> log factor-ish, but you get the ability to not have to build the tape single-threaded in exchange
16:35:27 <ash__> MHD: I just downloaded that library and it contains all of the ones that my other install has, weird… still seems to require perl though to run the llvm-config script, which is kinda annoying
16:35:29 <edwardk> my scala-ad package has the single threaded tape restriction
16:35:35 <edwardk> the log factor is much cheaper than the locks!
16:35:48 <MHD> ash__: tomorrow...
16:36:16 <acowley> oh beautiful! gradientDescent is just what I wanted
16:36:21 <edwardk> =)
16:36:34 <acowley> I'd really like to understand your implementation at some point
16:36:40 <acowley> forward is so elegant
16:36:54 <edwardk> you have a bunch of different modes in here
16:36:59 <edwardk> so you can compare and contrast them
16:37:15 <edwardk> forward is elegant but way too slow for any real workload
16:38:06 <edwardk> the sparse-on-reverse is pretty amazingly efficient though
16:38:20 <edwardk> especially when you need LOTS of derivatives
16:38:22 <acowley> well, I really value elegance, so I will make great efforts to accomodate its demands :)
16:38:40 <acowley> I was just toying with a function that's R^HugeNumber -> R
16:38:47 <edwardk> well, nicely they ugliness is encapsulated behind the facade
16:39:00 <edwardk> yeah, reverse mode will kick butt at that =)
16:39:09 <edwardk> er the ugliness
16:39:49 <edwardk> basically just use the combinators from http://hackage.haskell.org/packages/archive/ad/1.1.0/doc/html/Numeric-AD-Mode-Mixed.html and they'll use the right mode for anything
16:40:37 <edwardk> if you get bored and want to write a halley's or higher householder gradient descent, feel free. there is a gap in the api there.
16:41:54 <edwardk> i'll probably need to rebuild ad once i get the algebra machinery built in order to be able to use them together. not sure how i want to handle that
16:42:21 <acowley> edwardk: I just remembered that I forgot to send you a note about vector-instances, the monoid instance now overlaps with the vector package
16:42:37 <edwardk> yeah, i should fix that one. one sec.
16:42:54 <acowley> everything else with it is fine
16:43:49 <fxr> sorry, is that profunctor stuff just a union of a functor and a cofunctor?
16:44:30 <edwardk> fxr: nah, (also cofunctors = functors, contravariant functors are something else entirely)
16:45:39 <edwardk> they are a kind of not-quite-arrow-like thing
16:45:39 <fxr> ok, thanks
16:46:28 <edwardk> acowley: i wrote that package out of sheer sadness one day when i couldn't get roman to add the instances directly =(
16:47:07 <acowley> edwardk: well it made me happy to find it one day when I was being really enthusiastic about classes
16:47:20 <fxr> hmm a contravarianfunctor looks like a reversed arrow
16:47:28 <edwardk> acowley: i apologize in advance but i'll probably add a bunch of dependencies on my other packages to it
16:47:34 <fxr> hence contra.
16:47:46 <acowley> edwardk: why?
16:47:52 <edwardk> fxr: in this category its true
16:48:02 <edwardk> acowley: so the instances for my other classes for vector have some place to live
16:48:09 <edwardk> without me making a vector-instances-2
16:48:10 <edwardk> ;)
16:49:10 <mustelo> is there any way to "partially apply" a parser? parsec provides a charLiteral parser, but I don't want it to be surrounded by quotes...
16:49:39 <monochrom> no
16:49:42 <benmachine> mustelo: I don't think so, can't you just use a simpler parser?
16:49:46 <edwardk> mustelo: sadly no
16:50:09 <edwardk> mustelo: parsec's token parsers are a bit unfortunate. many of them should be broken up more or made capable of running with arbitrary user state
16:50:14 <mustelo> benmachine, if you know of one, sure. I don't want to reimplement it...
16:50:40 * hackagebot vector-instances 0.0.2 - Orphan Instances for 'Data.Vector'  http://hackage.haskell.org/package/vector-instances-0.0.2 (EdwardKmett)
16:51:04 <acowley> what other classes? You mean things like keyed, etc.?
16:51:10 <edwardk> acowley: yeah
16:51:24 <acowley> edwardk: you're going to suck me in to your vortex :(
16:51:25 <edwardk> acowley: all told it'll probably be about 20 classes
16:51:39 <edwardk> thats the plan. muahahaha
16:51:44 <danharaj> I hate GLSL and I hate how every resource on the internet is like 3 versions old.
16:51:57 <acowley> GLSL isn't so bad, what's the problem?
16:53:00 <Draconx> danharaj, *every* resource?  Even the GLSL specification?
16:53:36 <parcs> compiling shaders in haskell is a pain in the ass
16:53:47 <parcs> with the raw bindings, anyway
16:54:02 <parcs> damned Ptr GLchars!
16:54:12 <danharaj> acowley: I have a shader that takes a sampler, position, and texture coordinates, but it seems like the texture coordinates are not being loaded properly.
16:54:28 <danharaj> Draconx: Angry hyperbole from an incompetent programmer.
16:55:12 * monochrom pirates Angry Bird and calls it Angry Programmer! perhaps iPwn will like it too!
16:55:26 <acowley> danharaj: do you have any debugging tools to inspect resources?
16:56:25 <danharaj> acowley: I just fired up gdebugger, but it looks like I also am leaking buffer objects. I have several hundred where I should only have two. I am definitely calling deleteObjectNames too. :[
16:56:35 <Tomsik> Aren't Angry Birds like for free in the browser?
16:56:41 * hackagebot vector-instances 0.0.2.1 - Orphan Instances for 'Data.Vector'  http://hackage.haskell.org/package/vector-instances-0.0.2.1 (EdwardKmett)
16:58:30 <acowley> danharaj: I usually try to debug these things with a single frame to avoid an animation spewing all over the evidence of the crime
16:59:15 <danharaj> acowley: single static rectangle with a texture drawn on it. This was supposed to be a test, especially since I've done it already, just lost that bit of code. :\
16:59:29 <danharaj> you did solve my first problem, though. On stack overflow. Thanks :p
16:59:59 <danharaj> Ok, looks like the coordinates are getting where they ought to be.
17:00:03 <acowley> danharaj: I do agree that getting the ball rolling with OpenGL is pretty brutal
17:00:10 <danharaj> I think the shaders I wrote are just wrong.
17:01:31 <danharaj> http://hpaste.org/49561
17:02:05 <danharaj> acowley: I agree it is pretty tough. I was supposed to have done this already though :\ I really need to stop cleaning out my code folders.
17:03:03 <danharaj> oh, I pasted the wrong fragment shader.
17:03:17 <danharaj> That one I was using to see if the texture coordinates were getting to the fragment shader >.>
17:04:05 <kmc> ♥ debugging shader programs
17:05:01 <kmc> it's like "let's render intermediate results as color values and hope we can figure out what it should look like"
17:05:12 <danharaj> wait you mean people actually do that
17:05:23 <danharaj> I thought I was being supremely incompetent when I thought that up.
17:05:27 <kmc> that's how i debugged my shader programs back in the day
17:05:34 <kmc> i may also be supremely incompetent
17:05:51 <kmc> i generally use low-tech debugging techniques
17:06:05 <acowley> experts port printf to their shader programs
17:06:06 <danharaj> I debug my haskell code by sprinkling traces around.
17:06:14 <kmc> like my threshold for whipping out gdb is probably too high
17:07:04 <mustelo> solution to all library problems: copy the source off hoogle directly into module; modify to heart's content. (I now have a working characterLiteral parser without the quotes)
17:07:11 <kmc> haha
17:07:16 * ddarius almost never uses gdb.
17:07:25 <danharaj> so I have a proliferation of buffers because I create and destroy them every frame when I look at gdebugger. But I'm calling destroyObjectNames. Is that not enough, or is my driver being lazy about it?
17:07:33 <ddarius> I did use Turbo Debugger a lot back in the day, but that was for assembly.
17:08:21 <shachaf> ddarius: Do you ever make mistakes?
17:08:28 <kmc> good programmers don't
17:08:35 <kmc> so i've heard
17:08:42 <acowley> gdb is for finding bugs in other people's code
17:08:52 <kmc> gdb is for writing exploits for other people's code
17:08:57 <acowley> or at least that's how I usually use it
17:09:07 <acowley> kmc: that too
17:09:12 <danharaj> This black triangle will haunt me forever.
17:09:25 * shachaf has the uncanny ability of finding bugs in other people's code just by using it.
17:09:43 <monochrom> what acowley says
17:09:44 <shachaf> At least, most programs I use seem to be buggy.
17:09:54 <danharaj> My super power is going on hackage and saying "This is exactly what I needed!" and then using the library and saying "This is not at all what I needed!"
17:10:18 <kmc> shachaf, you can get paid good money for that
17:10:47 <ddarius> shachaf: When I make a mistake, I sit and ponder for a bit, and then I fix the error.
17:11:19 <kmc> > fix error
17:11:20 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
17:11:32 <ddarius> kmc: He can't be that good.  He said only "most programs" whereas it is axiomatic that -all- programs are buggy.
17:11:37 <shachaf> kmc: Unfortunately it only happens at "the most inopportune times".
17:11:46 <Eduard_Munteanu> That's a variant of "real men don't use debuggers"?
17:11:51 <Eduard_Munteanu> Or erm, s/men/programmers/
17:11:55 <ion> > fix (error . show)
17:11:56 <lambdabot>   *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
17:12:09 <kmc> real programmers don't write code, they just post on reddit
17:12:16 <monochrom> hahaha
17:12:22 <monochrom> kmc++
17:13:03 <shachaf> ddarius: I note that you don't say that that's ever actually happened.
17:13:22 <parcs> danharaj: why version 1.3?
17:14:28 <fxr> "In general, value producers such as Parser are covariant functors, while value consumers such as Printer are contravariant functors." interesting...
17:14:28 <fxr>  
17:14:36 <danharaj> parcs: Why not :3
17:16:13 <accel_> is there something like parsec's sepBy ... but also returns the separators?
17:17:23 <parcs> danharaj: are you using mesa? it only supports GLSL up to 1.2
17:17:31 <danharaj> parcs: what's a mesa
17:17:44 <Eduard_Munteanu> Ntz ntz ntz
17:17:57 <parcs> an open source graphics library implementing opengl
17:18:02 <danharaj> I am not.
17:18:19 <parcs> ah, then never mind
17:18:24 <Eduard_Munteanu> It's actually *the* implementation for that for FOSS drivers in Linux
17:18:37 <danharaj> sigh
17:18:46 <danharaj> I'm going to give up and play video games for today.
17:18:49 <Eduard_Munteanu> If you're using proprietary drivers then you're not using Mesa.
17:19:01 <parcs> danharaj: ask on ##OpenGL
17:19:03 <danharaj> Tomorrow hopefully I'll be able to fix this nonsense without rewriting my entire program.
17:19:21 <danharaj> parcs: Most def it's a problem on the Haskell end. Like maybe I'm marshalling the texture wrong.
17:21:11 <danharaj> I find that hard to believe though. It's a storable array of Word8's. That should be fine.
17:21:26 <danharaj> Really I'm at a loss, and I'll have to go over everything with a fine toothed comb.
17:21:39 <ddarius> fxr: The only primitive contravariant functor is the input position of the function type.
17:27:20 <edwardk> acowley: uploaded vector-instances with the huge pile of dependencies
17:27:36 <edwardk> acowley: now you can foldMapWithKey, etc.
17:27:51 * hackagebot vector-instances 0.1.0 - Orphan Instances for 'Data.Vector'  http://hackage.haskell.org/package/vector-instances-0.1.0 (EdwardKmett)
17:39:12 <HanselVanKansel> What happend? ghc.exe: panic! (the 'impossible' happened)   (GHC version 7.0.3 for i386-unknown-mingw32):         thread blocked indefinitely in an MVar operation
17:39:21 <HanselVanKansel> "the 'impossible' happend" sounds not so nice
17:40:54 <gienah> HanselVanKansel: maybe try upgrading to 7.0.4
17:40:54 <lambdabot> gienah: You have 1 new message. '/msg lambdabot @messages' to read it.
17:42:52 <HanselVanKansel> How can I upgrade to 7.0.4?
17:44:00 <HanselVanKansel> hmm it seems i can reproduce it quite easily in ghci
17:45:51 <gienah> on windows I'm not really sure, there is ghc here: http://www.haskell.org/ghc/download_ghc_7_0_4 but then i'm not sure about the haskell platform
17:46:36 <gienah> the impossible happened sounds like it might be a ghc bug, which is why I wonder about ghc 7.0.4, but whether the bug is fixed in ghc 7.0.4 I'm not sure
17:48:36 <aavogt> HanselVanKansel: what do you do to make it happen?
17:48:59 <gienah> HanselVanKansel: maybe ghc 7.0.4 will not help, googling for the error message finds:  http://hackage.haskell.org/trac/ghc/ticket/4245
17:49:14 <benmachine> impossible happened is always a bug
17:49:28 <benmachine> but sometimes it's a known bug
17:49:42 <HanselVanKansel> i confirm it on Windows 7
17:49:45 <HanselVanKansel> precisely that
17:49:52 <HanselVanKansel> Ctrl+C stuff
17:51:43 <HanselVanKansel> ok no more Ctrl+C solves it...
18:05:27 <Tomsik> Why is it "impossible happened" and not "invariant broken"? :(
18:05:52 <copumpkin> cause it's cuter
18:13:33 <benmachine> cute is all too rare these days
18:16:47 <iratsu> =o
18:19:07 <PersonA> /notify BONUS
18:22:39 <kmc> everything is either too cute or too mathy or too enterprisey
18:24:44 <danharaj> it could be offensive
18:24:50 <danharaj> "What the fuck did you do!?"
18:28:34 <Tomsik> It should display a picture of a kitten to console the poor user perhaps
18:29:02 <kmc> ascii cat?
18:29:16 <Tomsik> ascii /kitten/
18:29:20 <Tomsik> That's a difference
18:39:14 <parcs> hmmo, can anyone help with this strange type error: http://paste.pocoo.org/show/447166/
18:40:11 <parcs> it only occurs when i use the equality constraint  b ~ BaseType a and replace instances of BaseType a with b
18:41:07 <parcs> if i totally remove `b` and inline the type `BaseType a` it typechecks just fine
18:41:09 <mkscrg> So what is the defacto library for HTML/XML parsing?
18:41:39 <monochrom> there are several
18:41:42 <mkscrg> I'm looking for functionality more or less akin to Nokogiri (a Ruby library)
18:42:26 <kmc> woah, i've not seen this "untouchable" error
18:42:29 <Eduard_Munteanu> HXT is quite a common choice.
18:43:42 <Cale> parcs: Yeah, I have no idea what the new 'untouchable' stuff is about.
18:44:12 <monochrom> tagsoup, hxt, and more recently the xml-* ones. http://hackage.haskell.org/packages/archive/pkg-list.html#cat:xml
18:44:20 <Eduard_Munteanu> http://www.haskell.org/haskellwiki/HXT#Selection_examples
18:44:41 <monochrom> I don't know what is nokogiri or ruby, and I don't want to know
18:44:53 <parcs> Cale: this is new?
18:45:56 <Eduard_Munteanu> So which is goatse? Cute, mathy or enterprisey? :P
18:45:58 <Cale> parcs: seems to be, I don't recall ever seeing anything about untouchable type variables before
18:45:59 <tsuraan> stupid question, but what's the haskell function to split a string at a character?  e.g, I have "host:port", and I want the pair ("host", "port"), so split at ':'
18:46:13 <Cale> parcs: It may mean that b0 must remain polymorphic
18:46:25 <Cale> (which used to be called 'rigid' iirc.)
18:46:41 <mustelo> @type Data.Text.split
18:46:42 <lambdabot> Couldn't find qualified module.
18:46:57 <Cale> But then you have the weirdness that b0 isn't mentioned among those constraints
18:48:06 <tsuraan> mustelo: ok, so wrap in Data.Text.pack/unpack to work with strings...  seems like the Data.List module would have something like that, but I guess not
18:48:28 <mustelo> tsuraan, you can also write your own, of course
18:48:30 <shachaf> tsuraan: Data.List.Split
18:48:32 <shachaf> @hackage split
18:48:32 <lambdabot> http://hackage.haskell.org/package/split
18:49:05 <dolio> I thought they changed "rigid" to something involving the word "skolem".
18:49:14 <tsuraan> shachaf: awesome.  thanks!
18:51:35 <mkscrg> Thanks monochrom. I'll keep my mouth shut about those unmentionables :P
18:52:32 <monochrom> Data.Text.break may help
18:53:04 <monochrom> it also has splitOn and split
18:53:20 <monochrom> there is no need to pack and unpack
18:53:56 <monochrom> this is from a user who has never read the Data.Text doc before
18:53:58 <tsuraan> monochrome: how would I get around pack/unpack?
18:54:19 <monochrom> eh? see my two sentences just before
18:54:46 <tsuraan> but those only work on Text
18:55:13 <monochrom> sorry, String? what shachaf says
18:55:13 <tsuraan> so if I need to work with Strings, I do need to convert to Text, do the work, and then go back, right?
18:55:22 <tsuraan> ok :)
18:55:29 <tsuraan> I was wondering if I was missing something ;)
18:57:38 <kmc> @quote skolems
18:57:38 <lambdabot> No quotes match. You untyped fool!
19:12:11 <HanselVanKansel> is it weird that I find System.IO ugly?
19:12:51 <Eduard_Munteanu> The API or its code?
19:12:57 <coppro> yes. you are a failure. you should forever cry.
19:13:44 <HanselVanKansel> api, with it's exceptions and `h` prefix for files, etc.
19:14:59 <kmc> yeah, exceptions are ugly
19:15:46 <ezyang> Anyone know off-hand when mask got added to GHC?
19:16:15 <copumpkin> mask?
19:16:21 <Eduard_Munteanu> The Mask.
19:16:28 <copumpkin> oh
19:16:32 <copumpkin> never!
19:17:32 <kmc> ezyang!
19:17:33 <kmc> hi ezyang
19:18:08 <ezyang> Hello!
19:18:13 <ezyang> copumpkin: Seriously?
19:18:20 <copumpkin> ?
19:18:29 <ezyang> copumpkin: "never!"
19:18:40 <copumpkin> oh, if you mean the green thing
19:18:42 <kmc> ezyang, you should analyze historical emails to the MIT 'Reuse' list and determine the historical value-weighted centroid of all items
19:18:43 <copumpkin> then yes, never
19:19:23 <kmc> then I can camp at that exact point
19:19:36 <ezyang> kmc: Heehee
19:19:57 <ezyang> copumpkin: still no idea what you're talking about :^)
19:20:09 <ezyang> mask is apparently a function in Control.Exception, except it's not in 6.12.
19:20:58 <ezyang> Eee this is so evil! "takeMVar complete `catch` \(_ :: BlockedIndefinitelyOnMVar) -> takeMVar complete"
19:22:13 * hackagebot AspectAG 0.3.3 - Attribute Grammars in the form of an EDSL  http://hackage.haskell.org/package/AspectAG-0.3.3 (MarcosViera)
19:22:14 <copumpkin> ezyang: oh, I thought you were talking about the dumb jim carrey movie
19:22:17 <copumpkin> involving a green mask
19:22:23 <ezyang> Aha.
19:22:26 * copumpkin blames Eduard_Munteanu 
19:22:38 <kmc> haha
19:22:56 <kmc> how is that ever what you want
19:29:22 <monochrom> exceptions are not ugly. exceptions are just fine
19:29:39 <looopy> is haskell that big of a language?  i keep seeing that mentioned in various blogs
19:29:47 <monochrom> http://www.vex.net/~trebla/haskell/exception.xhtml
19:31:13 <ion> Haskell the language is rather small. A lot of stuff for which you need syntactic constructs in other languages can be implemented as functions in Haskell.
19:31:28 <applicative> looopy, in haskell you can define countably many distinct functions!
19:31:49 <applicative> looopy, and thats just Integer -> Integer!
19:32:19 <ion> @vixen Is Haskell that big of a language?
19:32:19 <lambdabot> church is my favourite computer scientist.
19:32:22 <looopy> applicative: you lost me o_O;
19:32:35 <kmc> "bigness" is not just about syntax, though
19:32:38 <monochrom> haskell (the language) is bigger than scheme but smaller than python
19:32:44 <looopy> it's as big as you want it to be?
19:33:11 <kmc> Haskell is a lot "bigger" than a simple typed lambda calculus
19:33:33 <kmc> looopy, anyway, what sense of "big" were you after?
19:33:50 <Eduard_Munteanu> There's a fair amount of extensions.
19:34:02 <aavogt> monochrom: how about if you include the various -X that ghc accepts?
19:34:04 <monochrom> a small language needs a big library to get things done sanely in practice, certainly
19:34:06 <ion> The “that’s what she said” sense.
19:34:27 <looopy> syntax and amount of libraries needed to make something work in general
19:34:51 <kmc> yeah, i agree with monochrom that library size and language size are at odds
19:34:56 <looopy> the amount needed to get even basic stuff done basically
19:35:02 <applicative> > let countablyManyFunctions n = (+ n) in take 50 $ zipWith ($) (map countablyManyFunctions [1..]) [1..]
19:35:03 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
19:35:04 <looopy> more so language size
19:35:12 <Axman6> looopy: haskell is imo quite 'small', but very powerful, so it can seem like there's a hell of a lot to learn, though really it almost always just comes down to simple functions, which are built upon and built upon
19:35:14 <kmc> looopy, ah, so like the amount of stuff you need to know?
19:35:27 <kmc> or the amount of behind-the-scenes details that are specified but you don't really need to know?
19:35:39 <looopy> good questions =)
19:35:46 <applicative> Well, looopy we can start with Hello World. Unfortunately, lambdabot doesn't do IO.
19:35:48 * kmc thinks the FP spirit of building everything from simple functions has been lost in Haskell, to some degree
19:36:03 <looopy> well yeah i saw that...and well that's less code than java/c++
19:36:15 <lispy> kmc: really?
19:36:15 <Axman6> it's pretty easy to get far in haskell if you understand a few simple things, like being able to define your own data types, functions, and how to use monads (you don't even need to really 'understand' monads to use them)
19:36:21 <monochrom> some extensions are tiny additions in size. some extensions actually subtractions in size, since they unify things so you have fewer cases and few exceptions
19:37:02 <kmc> there are a lot of things in Haskell you can't abstract over with functions
19:37:15 <looopy> hmm, well i'll give it a whirl.  i'm looking to force myself to how to program functionally..then i'll most likely use haskell but also bring what i know back to scala
19:37:31 <looopy> it's so easy to cheat and 'do what i want to' in scala...so this'll be my culture shock
19:37:33 <kmc> you can definitely write non-functional code in Haskell
19:38:13 <kmc> lispy, for example there's almost nothing for controlling or abstracting over instances and classes
19:38:23 <monochrom> for example, FlexibleContext may be a subtraction extension. with FlexibleContext, it is easier and shorter to describe what's legal in contexts
19:38:31 <applicative> > text "Hello" $$ text "World" -- kinda like a hello world program.
19:38:32 <lambdabot>   Hello
19:38:32 <lambdabot>  World
19:38:52 <looopy> well...i'll give it a whirl
19:39:00 <kmc> yay :)
19:39:09 <monochrom> NoMonomorphismRestriction is undisputably a subtraction extension. it removes an exception, period
19:39:13 <looopy> learn you a haskell or real world?
19:39:15 <applicative> have you found a decent text, primer, tutorial loopy?
19:39:16 <looopy> learn you a haskell...
19:39:21 <applicative> oh I see.
19:39:25 <looopy> ordering
19:39:26 <ion> Haskell also has the benefit of the existence of this channel, which many find one of the more friendly ones for learners[citation needed]. :-P
19:39:49 <looopy> seems so...you guys and #scala seem to like to teach/explain
19:40:05 <monochrom> that is, haskell 2010 + NoMonomorphismRestriction is smaller than haskell 2010
19:40:20 <ion> NoMonochromismRestriction
19:40:24 <looopy> iphonedev, rubyonrails(though they have some great people in there)....python...azzholes
19:40:31 <looopy> or "read a book then come back"
19:40:44 <Eduard_Munteanu> @quote friendly
19:40:44 <lambdabot> Twey says: Friendly error messages are a myth ☺
19:40:45 <applicative> LYAH is quite sound, looopy, it is a bit preliminary maybe, but maybe you can interleave with RWH.  Our friends here are always ready to help.
19:40:47 <Eduard_Munteanu> @quote friendly
19:40:47 <lambdabot> Twey says: Friendly error messages are a myth ☺
19:40:51 <Eduard_Munteanu> Bah. :)
19:41:21 <looopy> ehh...maybe i'll use both.
19:41:24 <Eduard_Munteanu> unsafeInterleaveRWH
19:41:24 <applicative> > 'a' + 1 -- doesn't this seem friendly?
19:41:25 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
19:41:25 <lambdabot>    arising from the literal `1...
19:41:34 <ion> @quote ^.*friendly[^☺]*$
19:41:34 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
19:41:45 <looopy> doesn't learn you a haskell have a website too?
19:41:51 <ion> @where lyah
19:41:51 <lambdabot> http://www.learnyouahaskell.com/
19:41:54 <ion> @where rwh
19:41:54 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
19:41:56 <aavogt> @ty (undefined :: 1)
19:41:57 <lambdabot> Unit
19:42:12 <applicative> @where sigfpe
19:42:12 <lambdabot> http://sigfpe.blogspot.com/
19:42:14 <ion> Wait, what, :: 1?
19:42:15 <looopy> ooh they both do.  i want to buy real world though. i read a chapter at the bookstore.  seems like it would be THE reference book later?
19:42:46 <Eduard_Munteanu> @where wikibooks
19:42:46 <lambdabot> I know nothing about wikibooks.
19:42:47 <ezyang> Huh, setUncaughtExceptionHandler doesn't have any docs. I wonder if it's thread or program global. Looks program global.
19:43:46 <applicative> @where typeclassopedia -- a little bit advanced maybe, but keep it in mind
19:43:46 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
19:43:50 <monochrom> it may be easy to test
19:44:37 <applicative> looopy, also a little advanced, but never too early, http://www.slideshare.net/tibbe/highperformance-haskell
19:45:28 <Eduard_Munteanu> http://en.wikibooks.org/wiki/Haskell       -- also has some nice stuff
19:45:46 <kmc> "never too early for optimization?" ;P
19:45:57 <monochrom> hahaha
19:46:04 <looopy> ok bookmarked
19:46:10 <ion> Yeah, when you’ve learned enough to move to the scary-sounding functors, applicative functors and monads, look at Typeclassopedia. This graph also tries to show their relationship by a simple example. http://heh.fi/haskell/functors/
19:46:11 <applicative> kmc, never to early to know what it would be, maybe?
19:47:03 <doc_who> applicative, why'd you need the double dollar signs in "text "hello" $$ text "world""? (sorry im a haskell noob)
19:47:06 <applicative> isn't there somewhere a picture of the way the basic number types get sorted by Num, Floating etc.?
19:47:08 <doc_who> wouldnt one suffice?
19:47:24 <ion> applicative: The Report has one.
19:47:40 <applicative> doc_who: it was just nonsense, in Text.PrettyPrint you use $$ for vertical composition or whatever its called
19:48:02 <doc_who> oh ok
19:48:48 <applicative> > text "Hello" <> space <> text "World" $$ text "Leaders!"
19:48:49 <lambdabot>   Hello World
19:48:49 <lambdabot>  Leaders!
19:48:49 <aavogt> monochrom: I was thinking about heavier extensions like MPTCs, FDs and TH
19:48:50 <ion> http://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1270006.3
19:49:33 <copumpkin> http://willowbend.cx/2011/07/22/whats-wrong-with-learning-haskell/
19:49:50 <Eduard_Munteanu> Fundeps are pretty slim in comparison to TH
19:50:00 <d7> Man
19:50:06 <d7> Ghc is not doing so well under Lion.
19:50:41 <looopy> hmm learn you a haskell seems like it can be knocked out in a day or two?
19:50:46 <applicative> doc_who have you looked at Text.PrettyPrint . It has amusing support inside ghci and hugs.  I think I learned a bit about what it's doing with IO vs regular evaluation when I noticed it.
19:51:14 <looopy> does haskell have something like REPL for scala or IRB for ruby?
19:51:17 <looopy> an interpreter?
19:51:17 <Eduard_Munteanu> Learn yourself a Haskell in 48 hours? Dunno, maybe not.
19:51:22 <d7> looopy: Of course. Ghci
19:51:24 <doc_who> looopy, ghci?
19:51:28 <applicative> omigod as they say
19:51:36 <looopy> does that come automatically?
19:51:40 <applicative> yes
19:51:41 <d7> looopy: Although like scala, it's not a perfect repl seituation.
19:51:49 <doc_who> applicative, no i havent
19:51:56 <looopy> gotcha, i'll take a look
19:52:11 <applicative> with the Haskell Platform.  There is an older interpreter Hugs as well, but it's harder to get new libraries hooked up to it.
19:52:26 <doc_who> so far all ive done with haskell is the first half of LYAH and the first 10 or so of the 99 haskell problems
19:52:36 <Eduard_Munteanu> That belongs to a museum.
19:52:51 <Eduard_Munteanu> @where platform
19:52:51 <lambdabot> http://hackage.haskell.org/platform/
19:52:57 <Eduard_Munteanu> Better get this. ^
19:53:08 <applicative> doc_who: sounds good, so far you are liking it?
19:54:18 <doc_who> its interesting
19:54:26 <doc_who> so far im still getting used to the syntax
19:55:13 <doc_who> the only other functional language i had used before was scheme
19:56:22 <kmc> "functional language" doesn't mean much
19:56:31 <applicative> the syntax is in a way simple, getting used to the predecences for standard issue operators is a bit of a pain...
19:57:02 <kmc> every modern language has first-class functions
19:57:26 <applicative> kmc, isn't there anything that scheme and haskell both are that, e.g. python isn't?
19:57:40 <kmc> applicative, sure, "useless academic languages"
19:57:45 * applicative suggests 'lambda mad'
19:58:12 <kmc> if you want your language to catch on you avoid calling it "functional", you just take those features and give them different names
19:58:21 <kmc> that seems to have flipped in the past few years, though
19:58:46 <applicative> Haskell is an Evaluative language.
19:58:49 <Eduard_Munteanu> Maybe some name it "functional" to avoid it catching on.
19:58:50 <shachaf> In the case of Python you take a crippled version of those features and use it three different ways.
19:59:02 <ezyang> Purity still has a long way to go.
19:59:16 <applicative> Haskell is an unusually Pure language
19:59:20 <monochrom> someone said "value-oriented language" and we all agreed it would be a manager magnet
19:59:26 <Eduard_Munteanu> Sometimes, even naming it functional isn't enough.
20:00:05 <kmc> FP is cool now
20:00:05 <Eduard_Munteanu> These days you have to go "total purely functional" to avoid popularity.
20:01:17 <ion> applicative: Scheme and Haskell have non-crippled lambdas, Python doesn’t. :-P
20:01:49 <kmc> that's only a syntactic issue
20:02:00 <kmc> Ruby and C# and Javascript have non-crippled lambdas
20:02:02 <applicative> there you are then, doc_who is familiar with uncrippled lambdas.
20:02:14 <doc_who> haha
20:02:26 <doc_who> now im curious what these crippled lambdas look like
20:02:28 <kmc> C#'s lambda syntax is more concise than Haskell's
20:02:44 <kmc> i guess I'm not sure they're not restricted to expressions, though
20:02:46 <applicative> kmc, but the only have very many types to make lambdas over; i call that cripplement.  but it applies to scheme...
20:02:47 <shachaf> What's C#'s lambda syntax?
20:02:52 <kmc> x => x+1
20:03:05 <kmc> applicative, ?
20:03:12 <applicative> { x => x +1 ;}
20:03:20 <shachaf> Some languages use (x){x + 1}, I think.
20:03:31 <kmc> Clojure has that #(% + 1) shorthand
20:03:34 <kmc> though it also has real lambda
20:03:40 <kmc> applicative, what's that about types?
20:04:02 <shachaf> Then if you have "def n 5", you can say "def f(x){x + 1}" and have it look like a function definition. :-)
20:04:06 <applicative> kmc, I was thinking Ruby and co. don't have as many types, so they cant do the lambdas haskellers can, thats all.
20:04:40 <shachaf> You can't do *half* the lambdas I can.
20:05:02 <kmc> applicative, still don't see the connection
20:05:27 <Eduard_Munteanu> '\' pretty much looks like a lambda missing a leg :P
20:05:41 <monochrom> heh heh heh
20:05:50 <shachaf> Maybe Haskell's lambdas should just support one variable, and use no arrow.
20:05:55 <shachaf> \x x + 1
20:05:59 <shachaf> \x\y\z x + y * z
20:06:17 <kmc> are we doing the thing where we conclude that a language can't really be considered functional unless it's pure and has static typing and algebraic data types and non-strict semantics and uses '{- -}' for multi-line comments and has a name starting with H?
20:06:31 <applicative> kmc, it doesn't matter.  But you could say that we have a lambda for each type, thus more lambdas.
20:06:37 <kmc> heh
20:07:45 <monochrom> Helium may fit the bill, too
20:07:52 <applicative> i wouldnt mind that shachaf, the arrow is kind of tacky.  \x (x + x) or \x . x + x is standard typewritten logic for lambdas
20:08:15 <kmc> monochrom, good point
20:08:19 <kmc> i forgot "has type classes"
20:08:35 <kmc> we should use â a+1
20:08:54 <applicative> class abstraction, no way
20:08:59 <Eduard_Munteanu> λx.λy.x+y might be nice
20:09:00 <ion> ಠ_ಠ http://en.wikipedia.org/wiki/Helium_(Haskell) “It also includes Hint, an interpreter written in Java with a graphical user interface.”
20:09:14 <applicative> Eduard_Munteanu: that's lovely, yes
20:09:16 <dolio> . has too many uses already.
20:09:24 <kmc> Eduard_Munteanu, λ is a letter
20:09:31 <kmc> λλ.λ+1
20:09:47 <d7> I think I'm coming to the conclusion that Hakyll is an abusive lover.
20:10:09 <coppro>  Hakyll?
20:10:17 <d7> Yeah.
20:10:25 <d7> The haskell version of jekyll.
20:10:27 <doc_who> Eduard_Munteanu, yes that is very pretty
20:11:15 <kmc> i want λ-case already
20:11:49 <Eduard_Munteanu> Pattern matching in lambdas with multiple cases?
20:12:16 <kmc> yeah
20:12:33 <applicative> how do you write it, more or less, this 'lambda case'?
20:12:39 <kmc> the usual proposal is for «\ case of { alts }» to desugar to «\x -> case x of { alts }»
20:12:40 <monochrom> > let f λ = 299,792,458 / λ = f 0.001
20:12:40 <lambdabot>   <no location info>: parse error on input `,'
20:12:42 <kmc> where x is a fresh variable
20:12:47 <monochrom> > let f λ = 299,792,458 / λ in f 0.001
20:12:48 <lambdabot>   <no location info>: parse error on input `,'
20:13:09 <ion> The pointless ‘case’ wouldn’t really need the \, i think.
20:13:23 <coppro> not strictly, no
20:13:24 <kmc> you think it should just be "case of" ?
20:13:26 <coppro> but it would lead to sanity
20:13:30 <looopy> hmm the warnings/errors given seem more clear than most languages
20:13:37 <ion> foo >>= case of { True -> ...; False -> ... }
20:13:43 <coppro> could this be extended to multipoint?
20:13:46 <kmc> looopy, error message quality is an implementation property
20:13:55 <coppro> >:D
20:14:07 <looopy> looks like they may just have put a lot of thought into haskell
20:14:39 <kmc> looopy, yes, it's a language designed by people who have actually studied programming language design
20:14:39 <Eduard_Munteanu> Meh, some things could be better.
20:14:46 <kmc> which is unfortunately a rare thing
20:14:46 <monochrom> well, for a break, I am happy to hear a "errors are clear" comment, be it language or compiler
20:15:12 <looopy> Eduard_Munteanu: do not spoil my honeymoon!
20:15:18 <looopy> =P
20:15:21 <kmc> haha
20:15:28 <Eduard_Munteanu> looopy: you'll see if you get a "cannot construct infinite type a = f a" error :)
20:15:49 <looopy> lol i know i will.  i'm good at running into things that 'dont work for me...and only me'
20:15:56 <monochrom> (try "f x = f [x]")
20:16:05 <coppro> the pet topic I want to look at more is better handling of cases where there are multiple reasonable instances of a typeclass on an ADT
20:16:13 <coppro> such as Monoid on Number
20:16:15 <looopy> the only kid in class who got two teardrops in class when everyone else got a heart
20:16:25 <aavogt> > f (x:xs) = x++xs
20:16:25 <lambdabot>   <no location info>: parse error on input `='
20:16:29 <ion> > let f g x = g (g x) in f show 42
20:16:30 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
20:16:30 <lambdabot>    arising from the literal `...
20:16:36 <aavogt> > let f (x:xs) = x++xs in f "123"
20:16:37 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
20:16:57 <monochrom> there is also "\x -> x x" of course
20:17:22 <Eduard_Munteanu> > (\x -> x x) 1
20:17:23 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
20:17:32 <doc_who> i do enjoy (\x -> x x) (\x -> x x)
20:17:37 <monochrom> isn't haskell fun!
20:17:49 <Eduard_Munteanu> I don't think that works in Haskell.
20:18:09 <coppro> I have a sort of pet idea that I want to investigate
20:18:09 <Eduard_Munteanu> Neither do Y or Z.
20:18:21 <kmc> right
20:18:22 <monochrom> right, (\x -> x x) (\x -> x x) needs untyped or advanced type
20:18:28 <kmc> though you can encode them all with appropriate wrapper types
20:18:41 <coppro> but the Hedley-Milner papers are kind of bad :(
20:18:45 <Eduard_Munteanu> monochrom: I'm at loss what such a type system would look like
20:19:23 <Eduard_Munteanu> Maybe you need equirecursive types and other scifi stuff?
20:19:29 <monochrom> yeah
20:19:53 <monochrom> I originally wanted to say "wacky type" for "advanced type"
20:20:01 <Eduard_Munteanu> Heh.
20:20:20 <Eduard_Munteanu> I thought it had to be wackier than Agda's or stuff like it.
20:21:59 <looopy> hmm just playing around... why is it when you do     min "four" "eight" it returns the longer string?
20:22:25 <kmc> looopy, which comes first in the dictionary?
20:22:33 <looopy> ahh!
20:22:36 <ezyang> \o/ just finished a nice post about BlockedIndefinitelyOnMVar. More about MVars than you ever wanted to know about!
20:22:42 <kmc> ordering on lists is lexicographic
20:22:43 <looopy> it it goes by the first letter
20:22:43 <d7> looopy: Try min "aaa" "b"
20:22:43 <looopy> nice
20:22:46 <kmc> strings are just lists of characters
20:22:54 <kmc> > min [1,2,3] [0]
20:22:54 <lambdabot>   [0]
20:23:11 <Eduard_Munteanu> > "Haskell" > "any other language"
20:23:11 <lambdabot>   False
20:23:12 <kmc> > min "aac" "abb"
20:23:13 <lambdabot>   "aac"
20:23:17 <Eduard_Munteanu> Damn, I spoiled it :(
20:23:20 <looopy> gotcha..ok  simple enough
20:23:24 <ion> > sort ["foo", "bar", "baz", "quux"]
20:23:25 <lambdabot>   ["bar","baz","foo","quux"]
20:25:08 <looopy> hmm when i try sort with integers i get an out of scope error?
20:25:25 <looopy> > sort [5, 22, 454, 2]
20:25:25 <lambdabot>   [2,5,22,454]
20:25:26 <ion> What’s your code and what’s the error?
20:25:37 <aavogt> import Data.List
20:25:50 <looopy> Prelude> sort [5, 2, 5,2, 35,6]
20:25:50 <looopy> <interactive>:1:1: Not in scope: `sort'
20:25:57 <ion> @hoogle sort
20:25:57 <lambdabot> Data.ByteString sort :: ByteString -> ByteString
20:25:57 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
20:25:57 <lambdabot> Data.ByteString.Char8 sort :: ByteString -> ByteString
20:26:00 <looopy> ahh i see
20:27:52 <looopy> ok time to follow the lesson again
20:28:58 <ion> In ghci you can also use Data.List.sort without importing it explicitly (:m + Data.Sort), but for compiled code, you need to import everything outside Prelude you use.
20:33:28 <looopy> ok one more...wth is a backtick?  92 ‘div‘ 10
20:33:41 <looopy> it's neither ` or '
20:33:57 <_habnabit> It's `
20:33:58 <fragamus> http://hpaste.org/49568
20:34:05 <doc_who> its the first char you typed
20:34:10 <doc_who> under the tilde (~)
20:34:13 <looopy> hmm doesn't work for me
20:34:19 <shachaf> Eduard_Munteanu: Wasn't the . originally used like Haskell uses $?
20:34:21 <kmc> looopy, for using normal function names as infix operators
20:34:28 <looopy> nm it does
20:34:50 <fragamus> Gentlemen,
20:34:56 <fragamus> http://www.haskell.org/haskellwiki/ListT_done_right
20:35:00 <fragamus> I want to mess with this and learn something in the process
20:35:03 <looopy> yeah.  i did 92 'div` 10 on accident
20:35:06 <fragamus> I want to mess with this and learn something in the process
20:35:12 <fragamus> It doesn't have to be a sum of squares anymore, just an example of something that does some computation with multiple outcomes the way one would expect with ListT
20:35:43 <fragamus> Here's the example code:
20:35:46 <fragamus> http://hpaste.org/49568
20:36:02 <Eduard_Munteanu> shachaf: how do you mean?
20:36:02 <monochrom> > 9 `div` 10
20:36:03 <lambdabot>   0
20:36:07 <monochrom> copy and paste that
20:36:43 <shachaf> Eduard_Munteanu: The dot in λx.something of x, or in ∀x.something of x
20:37:00 <shachaf> To reduce the need for parentheses.
20:37:43 <Eduard_Munteanu> Hm, dunno.
20:41:39 <accel> how do I define the field GF(p)? Do I define my type as an instance of Num (getting +-*), or Fractional (to also get /) ?
20:43:35 <ash__> instance Num TypeName where (*) = … ?
20:46:17 <shachaf> accel: All Fractionals must also be Nums.
20:49:21 <accel> another dumb question
20:49:27 <accel> suppose I want to define general fields
20:49:33 <accel> so I can have GF(7) and GF(13)
20:49:38 <accel> is there a way to have them be different types?
20:49:48 <shachaf> Yes.
20:49:49 <accel> since otherwise, I currently have in mind : data GF = GF !Int !Int
20:49:57 <Eduard_Munteanu> How do you do static assertions in Haskell?
20:50:02 <accel> where it's GF _num_ _prime base_
20:50:05 <shachaf> Define the type 7 and the type 13, and then parameterize GF on a number.
20:50:10 <kmc> Eduard_Munteanu, Template Haskell?
20:50:18 <kmc> not "in Haskell" per se
20:50:19 <accel> shachaf: is there a googleable name for this technqiue?
20:50:46 <Eduard_Munteanu> Hm. I don't know much about it, but does it know that much about the underlying code?
20:50:47 <shachaf> Maybe?
20:50:48 <shachaf> @google type level numbers
20:50:49 <lambdabot> http://www.haskell.org/haskellwiki/Type_arithmetic
20:50:49 <lambdabot> Title: Type arithmetic - HaskellWiki
20:51:10 <kmc> Eduard_Munteanu, well, what are you trying to assert?
20:51:31 <kmc> accel, you might want something like "Implicit configurations" ?
20:51:47 <kmc> Eduard_Munteanu, in C it's usually things like "this struct has this size"
20:51:52 <Eduard_Munteanu> kmc: a simple example would be taking a pure value and asserting it's equal to something
20:52:07 <kmc> there's no direct analogue in Haskell but you can introspect on data types
20:52:10 <kmc> in TH
20:52:20 <kmc> Eduard_Munteanu, your TH splice can import the module defining that value
20:52:31 <Eduard_Munteanu> Well, it would need to fold computations at compile time, can TH do that?
20:52:38 <kmc> fold?
20:52:51 <kmc> TH involves running arbitrary Haskell code at compile time, yes
20:52:52 <Eduard_Munteanu> Compute stuff. For example....
20:53:06 <Eduard_Munteanu> Can I assert   sum [1,2,3] == 6?
20:53:09 <kmc> yes
20:53:22 <Eduard_Munteanu> Ah, I see, thanks.
20:53:31 <kmc> you should read about Template Haskell
20:53:42 <kmc> start with the paper of that name, and then read the GHC manual to see all the details that differ
20:53:43 <aavogt> it might be difficult to get those values to compare
20:54:11 <kmc> Eduard_Munteanu, TH can even do IO to external files during compilation
20:54:15 <shachaf> > assert $ sum [1,2,3] == 6
20:54:16 <lambdabot>   yes
20:54:18 <Eduard_Munteanu> Oh, heh.
20:54:21 <kmc> you can abuse this for all kinds of entertainment
20:54:28 <Eduard_Munteanu> shachaf: that one's not static
20:54:39 <shachaf> Of course. :-)
20:54:51 <kmc> i mean, you can also put your static asserts in a file and call "runhaskell" on them
20:54:54 <kmc> what's the difference really
20:54:56 <GlandeGrande> I was at my surburban grocery store today, buying some powdered drink mix and this she rilla approached me and opened her rubber lips and axed me " what flavor of dis Kool Ade does these chrillrens like dese dayz"?
20:54:56 <GlandeGrande> I looked right at her and said " I understand niglets still perfer grape drank" and started to walk away.
20:54:56 <GlandeGrande> Her jaw hit the floor, her lips were flapping ( she was so mad no words were coming out! ) and her head started bobbin up and down like she was giving a $5 blow job.
20:54:56 <GlandeGrande> I was in the next aisle when I heard her go into her Stage 5 chimpout about "honkey muffafuckka done dissed me " and she went on and on.
20:54:58 <GlandeGrande> I bet she doesn't get that kind of special treatment in her local hood likka store
20:55:01 <kmc> @where ops
20:55:01 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
20:55:02 <shachaf> @where ops
20:55:02 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
20:55:06 <GlandeGrande> I was at my surburban grocery store today, buying some powdered drink mix and this she rilla approached me and opened her rubber lips and axed me " what flavor of dis Kool Ade does these chrillrens like dese dayz"?
20:55:06 <GlandeGrande> I looked right at her and said " I understand niglets still perfer grape drank" and started to walk away.
20:55:06 <GlandeGrande> Her jaw hit the floor, her lips were flapping ( she was so mad no words were coming out! ) and her head started bobbin up and down like she was giving a $5 blow job.
20:55:08 <GlandeGrande> I was in the next aisle when I heard her go into her Stage 5 chimpout about "honkey muffafuckka done dissed me " and she went on and on.
20:55:10 --- mode: ChanServ set +o copumpkin
20:55:12 --- mode: copumpkin set +b *!~usuario@189.220.55.78.cable.dyn.cableonline.com.mx
20:55:12 --- kick: GlandeGrande was kicked by copumpkin (Your behavior is not conducive to the desired environment.)
20:55:50 <kmc> if i put my asserts in "asserts.hs" and then make my build script call "runhaskell asserts.hs" is that not "static asserts"?
20:55:54 <shachaf> I wonder if mauke's trick would work in here too.
20:56:03 <accel> crap, I can't define an abs
20:56:07 <accel> on GFNum
20:56:21 <accel> grr, all I want is to use +-*/
20:56:21 <shachaf> kmc: That can only refer to globally-exposed values, though.
20:56:26 <kmc> true
20:56:29 <Eduard_Munteanu> Yup ^
20:56:39 <aavogt> then you CPP your exports
20:56:51 <shachaf> accel: import Prelude hiding ((+),(-),(*),(/))
20:56:51 <accel> also, fromInteger and signnum makes no sense
20:56:55 <kmc> this is one of those situations where i want "import Foo (no really give me everything, ignore their export list)"
20:56:56 <accel> hmm
20:57:05 <kmc> protection like exports should be advisory
20:57:25 <kmc> of course you might get "sorry, we inlined that function everywhere"
20:57:44 <kmc> accel, yep, the numeric classes kinda suck :/
20:57:47 <aavogt> in which case you conditionally change the exports to:            module Foo (module Foo,   ... real exports ) where
20:58:26 <accel> are these names .- .+ .* ./ already used by haskell for other uses?
20:58:27 <Eduard_Munteanu> kmc: that'd imply the module would need to have special, non-inlined definitions for each function.
20:58:36 <accel> I'm thinking of using them for my general field arithmetric symbols
20:58:41 <kmc> Eduard_Munteanu, oh?
20:58:56 <kmc> accel, i'm sure they're in some module on hackage, but what isn't
20:59:03 <accel> yeah; fuck those modules
20:59:06 <kmc> go for it
20:59:06 <accel> mine is more important
20:59:10 <kmc> you're the man now dog
20:59:15 <accel> lol
20:59:28 <Eduard_Munteanu> A non-exported function could be inlined into its same-module callers without emitting a separate definition.
20:59:41 <kmc> right; that's what i meant by '<kmc> of course you might get "sorry, we inlined that function everywhere"'
20:59:44 <ash__> accel: what doesn't make since about fromInteger? and signum?
20:59:51 <kmc> the "overriding imports" could fail in such circumstances
20:59:57 <kmc> this is what you get when you mess with us
20:59:58 <Eduard_Munteanu> Also, it could be specialized to just its use cases.
21:00:24 <accel> ash__: it doesn't make sense for general fields Z_p
21:00:35 <accel> since -1 = p-1
21:00:49 <ash__> oh, okay, i thought you meant the functionality didn't make sense
21:00:50 <accel> and fromInteger 4 <-- is this 4 in GF(7) or 4 in GF(13) ?
21:01:55 <kmc> accel, (fromInteger 4 :: GF Seven) is in GF(7)
21:02:01 <kmc> (fromInteger 4 :: GF Thirteen) is in GF(13)
21:02:09 <aavogt> you could also force the files to be loaded like ghci
21:02:16 <accel> Seven/Thirteen isn't known at compile time
21:02:17 <kmc> where type Seven = S (S (S (S (S (S (S Z))))))
21:02:21 <aavogt>  module M( a ) where a = 1; b = 2; c = 3
21:02:22 <kmc> sure it is
21:02:28 <shachaf> accel: ...Didn't you ask for it to be part of the type?
21:02:36 <accel> shachaf: I did
21:02:37 <shachaf> kmc: But what about (fromInteger 4 :: GF (fromInteger 4))?!
21:02:38 <accel> i screwed up
21:02:40 <accel> here's the situation
21:02:43 <aavogt>  ghc -e ':l *Exp.hs' -e 'print (a,b,c)' -- bypasses export lists
21:02:48 <accel> I'm writing a library where given a prime p, and an integer n,
21:02:53 <accel> it generates GF(p^n)
21:02:56 <kmc> aavogt, you're my hero :D
21:02:57 <accel> by fniding an irredicuble polynomial
21:03:08 <accel> so the prime p isn't known until run time
21:03:10 <kmc> ok, let's do our static asserts that way
21:04:18 <shachaf> kmc: You still can't have them for something defined e.g. in a where block.
21:04:26 <kmc> right
21:04:28 <accel> is there a way to have a functionc alled f*; but not have to type `f*` everywhere when I want to use it as an infix? is there a way to tell haskell: "in the context of this file, always great f+ as infix?"
21:04:47 <mauke> you can't have a function called f*
21:04:51 <shachaf> @faq Can Haskell always great f+?
21:04:51 <lambdabot> The answer is: Yes! Haskell can do that.
21:05:31 * Eduard_Munteanu wonders how painful it'd be to add mixfix operators to Haskell
21:05:41 <aavogt> accel: you could use a preprocessor to convert the f* to some letters that are acceptable
21:06:02 <ash__> Eduard_Munteanu: look at perl6… you can add any type of operator since the entire language has a mutable syntax
21:06:33 <Eduard_Munteanu> Oh heh... I was thinking more like a restricted version of Agda's mixfix
21:06:34 <mauke> s/perl6/lisp/
21:07:49 <accel> s/lisp/factor/
21:07:55 <ash__> mauke: have you seen the perl6 parser for rakudo? its pretty interesting how flexible it is, but also complicated
21:08:23 <mauke> no
21:09:39 <ash__> accel: do you mean like:  (f') :: a -> a -> b ? doing   a `f'` a'
21:11:10 <ash__> this might sound like an odd question, but has there been many attempts at making the ghci parse the same as a haskell file? e.g., being able to just write functions without for instance using let?
21:11:51 <dolio> I think there are hacks for it.
21:12:12 <ash__> is there any reason not to have it that way by default?
21:12:55 <shachaf> What's the standard way of writing a simple web-servery-thing in Haskell nowadays?
21:13:24 <kmc> braided comonoidal profunctors
21:13:28 <dolio> It's just an arbitrary decision, as far as I know.
21:18:36 <edwardk> kmc: they help, but aren't strictly necessary
21:18:53 <stepkut> shachaf: happstack?
21:19:10 <stepkut> shachaf: that's my standard atleast
21:19:30 <stepkut> shachaf: http://happstack.com/docs/crashcourse/index.html
21:19:34 <shachaf> Last I looked at happstack it seemed very strange.
21:19:57 <accel> ```  abs x = x
21:19:58 <accel>   abs x = x
21:20:27 <shachaf> What's people's problem with all-on-one-page documents?
21:20:50 <shachaf> Documents split across multiple web pages should be illegal.
21:21:11 <stepkut> shachaf: strange in what way?
21:21:11 <copumpkin> fewer page impressions for ads
21:21:17 --- mode: copumpkin set -o copumpkin
21:21:27 <stepkut> shachaf: and when did you last look ?
21:21:53 <shachaf> stepkut: I think it was called HAppS. :-)
21:22:00 <mustelo> shachaf, sometimes, if the docs are really huge, it is actually better to split them just so shitty browsers don't die
21:22:01 <stepkut> shachaf: :)
21:22:05 <edwardk> shachaf: there are browser plugins that automatically expand content inline from those multipage monstrosities
21:22:29 <aavogt> ash__: how would you go about defining in ghci if it worked that way:      let print12 = do print 1; print 2
21:23:17 <kmc> maybe it's better to punish the people with shitty browsers?
21:23:28 <kmc> i guess a lot of that is "old computers", though
21:23:33 <mustelo> kmc, I didn't say I was opposed to it :)
21:23:45 <stepkut> shachaf: well, it is somewhat the same, and a lot different now :) Much better organized and documented
21:24:39 <aavogt> well maybe that's not going to be a problem
21:24:57 <ash__> aavogt: print2 = do <enter> <tab> print 1<enter><tab>print 2 <enter> (not unlike the python interactive mode
21:25:28 <mustelo> ash__, my take on this is that having that kind of interactive mode teaches bad habits
21:25:46 <mustelo> 99% of the time, if you want to define anything complicated, it's better to just open an emacs buffer
21:25:52 <stepkut> shachaf: turns out writing a tutorial is a good way to fix a lot of strangeness. Once you try to document something stupid, you suddenly realize how stupid it is and decide it would be better to fix it first, and then document it ;)
21:25:58 <mustelo> (or vim, if you're into that)
21:26:08 <ash__> i suppose, its just odd that you have to define things differently in ghci compared to how I wrote my file.hs stuff
21:26:34 <kmc> stepkut, yeah, that's one of the benefits of encouraging documentation in an organization
21:26:35 <aavogt> it's the same syntax as being in a do-block, if that simplifies thinking about it
21:26:38 <mustelo> ash__, yeah, but it's just not part of anyone's workflow, so it doesn't matter
21:27:21 <shachaf> mustelo: As aavogt mentioned, ghci's syntax is very similar to the syntax in a do block.
21:27:30 <shachaf> It's not just invented from nothing.
21:27:58 * shachaf vaguely wishes cabal and/or GHC did parallel compilation.
21:28:10 <mustelo> shachaf, sure. I have nothing against it. I might even consider it a Good Thing
21:28:13 <kmc> my wish is more than vague :)
21:28:25 <shachaf> mustelo: That was meant to be ash__. :-)
21:28:25 <kmc> GHC itself is built with 'make', though, so building GHC parallelizes
21:28:30 <kmc> way to dogfood guys ;)
21:28:42 <shachaf> kmc: GHC /= Cabal.
21:28:58 <shachaf> You can use GHC with make, after all. As GHC demonstrates. :-)
21:29:10 <kmc> Cabal uses ghc --make, iirc
21:29:23 <shachaf> And GHC's build system doesn't?
21:29:29 <kmc> correct
21:29:33 <shachaf> Ah.
21:29:41 <shachaf> ghc --make should support Makefile syntax.
21:29:42 <kmc> at least, it doesn't feed all of the compiler into one huge ghc --make invocation
21:29:48 <shachaf> Makefile syntax is great.
21:29:54 <kmc> it may use it on individual files / small pieces
21:30:02 <kmc> (for example, GHC builds some libraries with cabal)
21:30:11 <shachaf> kmc: I don't know if ghc --make was ever intended to build an entire project.
21:30:26 <kmc> it builds nearly all cabal projects, afaik
21:30:47 <kmc> "ghc --make" gives a speed improvement even when you don't need its dependency tracking
21:32:43 <aavogt> mustelo: what kind of bad habits?
21:33:32 <mustelo> aavogt, I just notice myself using python interactively even when I know I should be using a file. a lot of "oh, fuck, messed something up in the previous line. have to start from the top of the loop again"
21:34:53 <dmwit> "Makefile syntax is great."
21:34:57 <dmwit> bwuh, what?
21:35:23 <kmc> i assume sarcasm / temporary insanity
21:35:39 <dmwit> haha
21:35:48 <dmwit> My sarcasm meter is so broken.
21:36:01 <looopy> what's the purpose of infinite lists?
21:36:16 <dmwit> looopy: It allows you to separate the concerns of producing a list and deciding how much of the list to consume.
21:36:36 <kmc> looopy, they can be a convenient way to "memoize" functions
21:36:54 <kmc> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
21:36:55 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
21:37:03 <Eduard_Munteanu> Dunno, but autotools are usually enough.
21:37:10 <Eduard_Munteanu> And you get a few things for free.
21:37:22 <mustelo> looopy, I sometimes think of it like "well, we added laziness, might as well have infinite lists"
21:37:22 <dmwit> autotools are usually too much. =P
21:37:31 <looopy> oh like if there's a pattern...skip figuring it out each time..just go ahead and repeat the pattern?
21:37:35 <ash__> mustelo: I gotta admit one of my favorite features of python is being able to open ipython -pylab then saying plot(…) right there and see the result, it is probably the biggest reason I fall back to python more often than not
21:37:39 <kmc> asking for the nth element of "fibs" is exponentially faster than asking for the nth value of the function "fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-1)"
21:38:03 <aavogt> mustelo: there's no way to recall the whole loop for editing there?
21:38:16 <looopy> ok i think i got it
21:38:16 <kmc> looopy, lists in Haskell are more like control-flow structures than data-flow structures
21:38:23 <kmc> they are loops, as first-class values
21:38:29 <looopy> ugh...i really need to learn about that notation stuff/speed
21:38:32 <ion> It’s very often useful for functions generating data not to care about how much of it the end user wants.
21:38:56 <mustelo> aavogt, depends on how you're using python. that type of editing is not built in to the interpreter itself afaik. my point is that it needn't be built into ghci either.
21:39:00 <looopy> o_O;
21:39:08 <looopy> i'll have to 'get that' later
21:39:21 <dmwit> looopy: What are you confused about?
21:39:23 <kmc> looopy, are you familiar with generators in python?
21:39:25 <ash__> s/aavogt/ash__/
21:39:29 <dmwit> (Why not "get it" now? =)
21:39:30 <kmc> infinite lists are kind of like that
21:39:36 <ion> Instead of every single list-generating function taking a “number” parameter and counting when to end the list, just generate lists of arbitrary length and have the caller take the number of elements she wants.
21:39:37 <kmc> (subject to my caveats that you can't really learn haskell by analogy)
21:39:39 <looopy> nope
21:39:49 <looopy> the not carting about how much data a end user wants
21:39:56 <looopy> though...if it's a function then that makes sense
21:40:08 <kmc> yeah, there's no reason to have a "get first n fibonacci numbers" function
21:40:15 <kmc> just have a "all fibonacci numbers" list
21:40:15 <looopy> if it's an infinite # that's simply what's created..you just have to cut it somewhere
21:40:17 <mustelo> kmc, but monads are just like burritos, I'm sure you'll agree
21:40:22 <kmc> om nom nom
21:40:25 <dmwit> looopy: ion was saying the same thing I was: you can separate the problem of producing a list and deciding how much of it to consume.
21:40:34 <shachaf> Burritos are just an abstract API, mustelo.
21:40:39 <kmc> laziness is more composable
21:40:48 <looopy> i see
21:40:48 <dmwit> looopy: For example, here's an implementation of maximum that might interest you (even though it doesn't actually use *infinite* lists):
21:40:56 <dmwit> maximum = head . sort
21:41:05 <ion> Isn’t that minimum? :-)
21:41:11 <dmwit> looopy: In a strict language, sort would *definitely* take O(n * log n) time.
21:41:15 <dmwit> ion: Oops, yes, minimum.
21:41:19 <ash__> mustelo: I can open ghci and import Numeric.Container and Graphics.Rendering.Plot and get the same effect as an python shell, its just more finger cramps, I can understand why ghci is implemented the way it is, I just personally think its odd thats all, anyway...
21:41:22 <copumpkin> last . sort!
21:41:40 <dmwit> looopy: But because we have laziness, the user gets to decide how much of the list to examine, and therefore how much of the computation to perform.
21:41:43 * kmc complain that you can sort faster than O(n log n)
21:41:55 <dmwit> kmc: Not with a mere Ord constraint, you can't.
21:41:59 <kmc> true
21:42:03 <shachaf> head . sortBy (compare EQ .: compare)
21:42:05 <looopy> hmm where can i learn about the different speeds?
21:42:12 <shachaf> Or, well, (flip compare), I guess.
21:42:15 <looopy> i opened a data structure book LONG ago..in HS and i put it back.
21:42:16 <looopy> -_-
21:42:27 <dmwit> What do you mean by "different speeds"?
21:42:38 <looopy> 0(n log n)
21:42:44 <mustelo> ash__, I think I agree with you there. (although the imports issue is largely orthogonal, IMO)
21:42:45 <ash__> looopy: http://www.amazon.com/Introduction-Algorithms-Thomas-H-Cormen/dp/0262033844/ref=sr_1_1?ie=UTF8&qid=1311742716&sr=8-1
21:42:45 <looopy> not sure what the term is
21:42:53 <dmwit> I guess wikipedia?
21:43:01 <looopy> LOL!  that's the book!
21:43:04 <dmwit> http://en.wikipedia.org/wiki/Big_oh_notation
21:43:18 <looopy> big o notation...yes...infamous logarithms and such
21:43:22 <ash__> looopy: http://en.wikipedia.org/wiki/Big_O_notation
21:43:26 <looopy> scary...
21:43:26 <azaq23> looopy: Time and Space complexity of some algorithm
21:43:28 <kmc> looopy, yes, that is *the* book
21:43:35 <ash__> oh, oops dmwit beat me to it
21:43:39 <dmwit> Asymptotic analysis is pretty basic stuff...
21:43:42 <kmc> asymptotic complexity is kind of worse than nothing, though
21:43:54 <kmc> it's a great way to decide which algorithm to use if you're lazy and don't want to think about the real machine
21:43:57 <shachaf> kmc: What's better than nothing?
21:43:58 <kmc> it frequently gives wrong answers
21:44:13 <mustelo> kmc, "wrong"?
21:44:28 <ash__> if your even slightly into programming I'd highly recommend the algorithms book, its a great reference and its something that is definitely work your while to know
21:44:55 <kmc> mustelo, yes -- the theoretically asymptotically fastest algorithm might be worse with your particular problem size, on your particular hardware
21:45:20 <looopy> yeah i'll grab it.  part of me picking haskell up is when i go back to school i'm going to 'hit math' instead of running from it...so this seems like a good language to toy with what i learn
21:45:40 <mustelo> kmc, true, indeed I think *the* fastest asymptotically is often quite bad in practice. I would disagree that knowing about asymptotic behavior is worse than not knowing
21:45:47 <shachaf> looopy: That book is not necessarily the best introduction to algorithms you can get, despite the title. :-)
21:45:53 <kmc> mustelo, it's better if you know when to apply it and when not to
21:45:57 <ash__> i am horrible at math, I am so lazy I have my computer do it all for me
21:46:00 <mustelo> kmc, agreed :)
21:46:09 <kmc> it's worse if you teach all the CS sophomores "here is how you pick the best algorithm"
21:46:13 <kmc> and leave it at that
21:46:19 <ash__> it shows too, if my laptop isn't near by I can't figure out how to calculate a tip at a restaurant o.0
21:46:25 <kmc> ash__, computers aren't very good at math
21:46:30 <looopy> shachaf: yeah, definitely math intensive.  well in the next 4-5 years i wouldn't mind working in the finance world
21:46:32 <kmc> they're good at computation
21:46:48 <mustelo> kmc, "omg guys, I can multiply matrices in O(n^(2.whatever))"
21:46:49 <kmc> often the only numbers in a maths paper are the page numbers
21:47:07 <ash__> kmc: ya, but they do what I ask, which is better than me with a piece of paper and a pencil
21:47:23 <shachaf> looopy: Why would you want to work in the finance world?
21:47:42 <shachaf> kmc: You're right, there usually isn't a date. :-(
21:47:56 * shachaf thinks people who put the date in papers they publish should get an award or something.
21:48:52 <looopy> either that or something science based...AI of the sort.   finance wise... $$$?  pretty sure i'll change my mind in a week.  i'm in a manic period
21:49:21 <looopy> don't hold much weight to me going into the finance world though
21:49:24 <drbean> There doesn't seem to be any way of dumping command history to a file in ghci.
21:50:16 <ash__> drbean: cat ~/.ghc/ghci_history
21:50:33 <ash__> but that is a lot more than your last session (or current)
21:51:05 <kmc> hmm, i bet readline has a way to do it, but ghci doesn't use readline anymore does it?
21:52:20 <aavogt> kmc haskelline is the current one
21:52:37 <drbean> ghci_history is good enough. I can just end the ghci session.
21:53:05 * shachaf has $ ln -s /dev/null ~/.ghc/ghci_history
21:53:27 <ash__> shachaf: just curious, why?
21:53:44 <shachaf> WAR IS PEACE
21:54:05 <dmwit> FREEDOM IS SLAVERY
21:54:13 <mustelo> shachaf looks at ascii pr0nz in ghci
21:54:18 <aavogt> mustelo: there's a way to get multi-line editing done properly in ghci (or at least similar to bash)?
21:54:45 * shachaf has the same thing for .irb-history, .lesshst, .pythonhist, and so on.
21:54:48 <mustelo> (in my head, aavogt said that in response to me...)
21:54:49 <dmwit> Actually, "FREEDOM IS SLAVERY" seems backwards compared to the other two.
21:55:14 <mustelo> aavogt, no, not that I know of.
21:55:30 <aavogt> there's rlwrap which might do something
21:55:48 <aavogt> or this bug/feature request http://hackage.haskell.org/trac/ghc/ticket/3984
21:55:49 <mustelo> or emacs :)
21:57:16 <ion> How many fingers am I holding up?
21:57:43 <copumpkin> three
21:58:06 <shachaf> @agree copumpkin
21:58:07 <lambdabot> g . copumpkin = copumpkin . f
21:58:23 <shachaf> Uh-oh.
21:58:27 <dmwit> THERE ARE FOUR LIGHTS!
21:58:42 <aavogt> @free const
21:58:42 <lambdabot> f . const x = const (f x) . g
21:58:53 <shachaf> @free nst
21:58:54 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `nst'\n\n"
21:59:12 <copumpkin> holy shit, I'm unsafeCoerce
21:59:31 <kmc> copumpkin took the brown acid
21:59:39 <kmc> @remember copumpkin holy shit, I'm unsafeCoerce
21:59:39 <lambdabot> Good to know.
22:00:03 <dmwit> ?free is weird
22:00:03 <lambdabot> Extra stuff at end of line
22:00:12 <kmc> ?free love
22:00:13 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `love'\n\n"
22:00:18 <kmc> :(
22:00:39 <kmc> @. elite free copumpkin
22:00:39 <lambdabot> 3Xtra STUfF A+ EnD of lIN3 in RE+RiEV3D TYPe "no+ in ScoPe: `copumPkin'\N\n"
22:00:54 <kmc> @agree foo
22:00:55 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `foo'\n\n"
22:01:07 <dmwit> ?list
22:01:07 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
22:01:26 <kmc> @. elite ghc
22:01:26 <lambdabot> 9|-|C s4Y5: non-+YP3 \/4rI4b1Ez0rz in c0ns+raInT
22:01:44 <kmc> @@ @elite @elite @elite @elite @elite @ghc
22:01:45 <lambdabot>  9|-|c 54Yz: caN'7 5p|i(3 +|-|3 p0|y/\/\0Rp|-|I( |0(41 \/ARi4813
22:02:32 <aavogt> @elite has a fixed point?
22:02:32 <lambdabot> has 4 fIxeD POiN+?
22:02:36 <dmwit> There are still some letters, it must need more @elite's.
22:02:57 <kmc> @@elite @elite has a fixed point?
22:03:01 <kmc> @@ @elite @elite has a fixed point?
22:03:02 <lambdabot> Plugin `compose' failed with: Unknown command: ""
22:03:05 <dmwit> ?elite pppppppppppppppppppppppppppppppppppppppp
22:03:05 <lambdabot> pppppPPPppPpPPPPPpPpPPpPPPpppppPPPppPPPP
22:03:18 <dmwit> Hm, it may not be able to eliminate *all* letters. =P
22:03:58 <dmwit> |⊃
22:03:58 <kmc> @. run run (text . map succ) "ehw''/9(-rb`mk'*(0("
22:04:01 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
22:04:20 <shachaf> dmwit: þ?
22:04:50 <shachaf> kmc: Everyone knows the Fibonacci sequence starts with 1.
22:04:58 <dmwit> > map succ "ehw''/9(-rb`mk'*(0("
22:04:58 <lambdabot>   "fix((0:).scanl(+)1)"
22:05:02 <kmc> shachaf, everyone knows PHP is the best language
22:05:28 <shachaf> @agree kmc
22:05:29 <lambdabot> f kmc = kmc
22:05:44 <aavogt> @elite ffffffffphp
22:05:44 <lambdabot> phFFphfFffp|-|p
22:06:03 <shachaf> @elite PHP is the best language
22:06:03 <lambdabot> P|-|p I$ TH3 8ES+ |4NGu4gE
22:06:58 <kmc> what is @agree
22:07:12 <kmc> @elite ffffffffffffffffffffffffff
22:07:12 <lambdabot> FphFphffphfphFFphphFFFphphFfffphFFF
22:07:16 <kmc> @. elite elite ffffffffffffffffffffffffff
22:07:16 <lambdabot> PhFfphfFfffphfFffphfphfpHphfffphFPh
22:07:30 <kmc> @. . elite elite elite ffffffffffffffffffffffffff
22:07:31 <lambdabot> Plugin `compose' failed with: Unknown command: "3Li+3"
22:07:32 <shachaf> @@ @elite @elite @elite ffffffffffffffffffffffffff
22:07:32 <lambdabot>  FFphphp|-|P|-|FphFFp|-|fFp|-|PHfphfFp|-|fphphFphP|-|
22:07:57 <kmc> that looks like all we need for a new esoteric language
22:07:57 <shachaf> @. elite . elite elite ffffffffffffffffffffffffff
22:07:57 <lambdabot> P|-|p|-|PhFfFFPhphFfp|-|phPHP|-|fphfFphfFfPhff
22:08:06 <kmc> and by "new esoteric language" i mean "trivial remapping of brainfuck"
22:08:31 <shachaf> kmc: Brilliant!
22:08:36 <shachaf> @kmcsnack
22:08:36 <lambdabot> Unknown command, try @list
22:08:39 <kmc> @elite Brilliant!
22:08:39 <lambdabot> 8RILlIant!
22:08:56 <DevHC> @1337 spam
22:08:56 <lambdabot> Unknown command, try @list
22:21:14 <ash__> is there a way to disable fPIC?
22:21:16 <ash__> in ghc
22:21:57 <ash__> Warning: -fllvm is incompatible with -fPIC and -dynamic on this platform; I get this warning anytime I try to use -fllvm
22:22:01 <ash__> thats why I ask
22:27:42 <QinGW> @elite elite
22:27:42 <lambdabot> 1337
22:45:34 <hydo> So I have a dsl that I wrote (in haskell) for translating data and I want to be able to use it over the web.  I've spent most of the day trying to shoehorn evaluation of a script that can grow rather large into hint, but I'm wondering:  is there a better way?  Right now I'm writing the input out to a file, loading it with hint, and then 'interpret'ing a predefined function to kick it off.
22:46:08 <hydo> writing out to a file = bad, yes, but I'm in the 'get this damn thing to work' phase.
22:46:41 <luite> hint can only load files, if you use the ghc api directly, you can run it from a memory buffer
22:47:30 <hydo> I..... I didn't know ghc had an api.  I know about ghc-paths but... ok, awesome.  To the wiki!
22:48:05 <luite> it's not as easy to use as hint
22:53:20 <hydo> Well, looky there.  Thank you jgm for Network.Gitit.Plugins.hs :)
22:58:14 <luite> yes, that still loads files though, I think you have to change the guessTarget to setTarget or something like that
23:13:38 <accel> how do I hide haskell's builtin gcd from prelude (because mine is so much better)
23:13:54 <accel> I want the rest of prelude
23:13:55 <accel> just not gcd
23:13:56 <c_wraith> import Prelude hiding (gcd)
23:14:05 <c_wraith> same as any other import
23:14:38 <c_wraith> there's an implicit import of Prelude if it's absent.  But if you explicitly import the Prelude (in any way), it's no longer imported implicitly
23:15:24 <ash__> or you can use long names, So if you want to access Prelude's gcd you do: Prelude.gcd and your YourModule.gdc
23:15:26 <ash__> err
23:15:34 <ash__> YourModule.gcd
23:15:46 * hackagebot pontarius-xmpp 0.0.7.0 - A prototyped and incomplete implementation of RFC 6120:  XMPP: Core  http://hackage.haskell.org/package/pontarius-xmpp-0.0.7.0 (JonKristensen)
23:15:55 <kmc> or "import Prelude as P"
23:16:00 <kmc> then you can say "P.gcd"
23:16:09 <kmc> but there's no way i know of to say "<this module>.gcd"
23:16:21 <ash__> i thought you had to say qualified
23:16:31 <kmc> no
23:16:42 <kmc> qualified and as are independent
23:16:54 <kmc> they do different things
23:17:06 <kmc> also worth noting: you can import several things "as" the same shortname
23:17:15 <ash__> ah, I guess I always saw them used in conjunction
23:17:25 <kmc> or import the same module twice under two "as" names
23:17:32 <kmc> or import some things qualified and others not
23:17:55 <kmc> a lot of arbitrary restrictions you might expect don't exist
23:18:04 <kmc> although fundamentally Haskell's module system is very primitive
23:18:47 * hackagebot time-http 0.1.0.1 - Parse and format HTTP/1.1 Date and Time strings  http://hackage.haskell.org/package/time-http-0.1.0.1 (MasatakeDaimon)
23:21:33 <accel> c_wraith: worked nicely; thanks!
23:28:19 <glguy> If anyone wants to toy with graphing (via graphviz) regular expressions as DFAs or NFAs or compile them down to transition Arrays http://www.galois.com/~emertens/RegExp.hs
23:36:48 * hackagebot alms 0.6.0 - a practical affine language  http://hackage.haskell.org/package/alms-0.6.0 (JesseTov)
23:50:29 <accel> someone explained this ot me once, and beause I'm an idiot, I forgot. Why is "data Poly = Poly ![Int]" acceptable, but "data Poly = Poly ![!Int]" not ?
23:50:56 <c_wraith> because you can only enforce strictness in your own constructor
23:51:30 <accel> data Poly = Poly ! (List Int) <-- Poly is my constructor. data Poly = Poly ! (List !Int) <-- I do not control List. Is that correct?
23:51:39 <c_wraith> yes
23:51:49 <accel> cool; thanks, this brings back the memories.
23:51:55 <accel> Question 2: is there a standard "strict list" ?
23:52:02 <c_wraith> no.
23:52:15 <c_wraith> generally if you want strictness, you also want something more memory-efficient
23:52:17 <Cale> accel: ! isn't part of the syntax of types, it's part of the syntax of data declarations
23:52:26 <Cale> would be another way to explain it
23:52:42 <accel> c_wraith: what should I use? I want to store an array of interegers, representing coefficients of polynomials?
23:52:49 <c_wraith> probably a bit clearer, too.  but yes, that's the same thing I was attempting to convey.
23:52:53 <kmc> look at 'vector'
23:53:05 <Cale> accel: Often lists are just fine for that
23:53:44 <Cale> But if they're not performing well enough, then sure, go ahead and use something like vector
23:54:40 <Cale> You could also possibly use UArray
23:54:51 <accel> good sugestions
23:55:00 <accel> in pre retrospect, this is premature optimization
23:55:05 <accel> I should code this up with lists first :-)
23:55:23 <kmc> lists are still lousy for random access
23:55:29 <kmc> (the API is, too)
23:55:45 <kmc> you can use IntMap; that'd be particularly good if your polynomials are sparse
23:55:49 <Cale> You're *usually* not usually going to randomly access the coefficients of a polynomial
23:55:54 <kmc> yeah i guess not
23:56:07 <kmc> going to sleep now, 'night all
23:56:09 <Cale> er, lol
23:56:20 <Cale> two "usually"s
23:56:26 <Cale> I'm probably tired as well
23:58:29 <accel> Data.Vector does not come with the platform?
23:59:16 <accel> ignore me; i'm not using ahskell platform
