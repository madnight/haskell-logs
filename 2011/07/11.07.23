00:07:29 <huangyi> x `par` (y `pseq` x + y)    if y is evaluated faster then x, will main process wait for the parallel evaluating x ?
00:08:59 <ezyang> I don't see why it wouldn't, since + is strict in both arguments.
00:09:05 <c_wraith> hmm.  I'm never really sure here.  If the spark to evaluate x fired during the evaluation of y, it should have blackholed x.  In which case, it will wait.
00:09:57 * c_wraith may figure this out eventually, working his way up from the most primitive implementation details.
00:12:23 <huangyi> ezyang: if it will wait for parallel sparks, then pseq seems useless, "x `par` (x + y)" should  works too, right?
00:12:59 * hackagebot th-sccs 0.0.0.20110723 - Binding group analysis in Template Haskell  http://hackage.haskell.org/package/th-sccs-0.0.0.20110723 (NicolasFrisby)
00:13:17 <c_wraith> huangyi: not at all.
00:13:52 <c_wraith> huangyi: in that case, the originating thread could start evaluating x before the spark ever starts executing.  that would lead to no parallel speedup.
00:14:23 <c_wraith> huangyi: pseq is there to enforce ordering of evaluation in the originating thread, so that you know there's time for sparks to start in parallel.
00:16:30 <huangyi> buy some time for evaluation of x to start?
00:17:11 <c_wraith> give or take.
00:17:49 <c_wraith> really, to enforce that the current thread evaluates something else *before* x, so that if the spark fires, it can actually do some useful work in parallel.
00:19:36 <huangyi> if y is evaluated fast enough, there's still a change that originating thread start evaluating x before the spark start?
00:19:40 <c_wraith> yes
00:19:46 <c_wraith> there's also a chance the spark will never start
00:20:00 <c_wraith> depends on how many sparks are in the spark pool, etc
00:20:38 <c_wraith> like, if you're running a single GHC capability, you'll never execute a spark.
00:21:37 <huangyi> i see, thanks.
00:47:06 * hackagebot djinn 2011.7.23 - Generate Haskell code from a type  http://hackage.haskell.org/package/djinn-2011.7.23 (LennartAugustsson)
00:56:15 <glguy> Anyone know how to draw a graph using Data.Graph.Inductive.Graphviz? I've tried opening the resulting string in with dot and I get a blank page
00:56:24 <glguy> The string has reasonable data in it, however
01:00:45 <glguy> ahh, it was the header that was bad, deleting about the first 4 lines from the output fixed my problem
01:14:10 * hackagebot unix-compat 0.2.2 - Portable POSIX-compatibility layer.  http://hackage.haskell.org/package/unix-compat-0.2.2 (JacobStanley)
01:14:41 <c_wraith> Huh.  I have a case where I have a type with the right kind to be a functor, but the type has additional contracts that implementing Functor would allow you to break.
01:16:02 <c_wraith> This is...  unfortunate.
02:38:34 <anuj919> Hello
02:38:44 <anuj919> anyone there?
02:39:14 <Clint> no
03:05:42 <ezyang> When I write 'data Foo = Bar | Baz', what am I writing? A data specification? A type specification?
03:06:26 <Eliel> both?
03:06:47 <ezyang> Focus on the rhs.
03:06:56 <ezyang> Is it actually called a data specification?
03:07:17 <ezyang> I feel like there's a precise name, but I can't put my finger on it.
03:07:26 <Eliel> what is rhs short for?
03:08:02 <ezyang> right hand side, as in, right hand side of the equals sign.
03:09:03 <Eliel> well, on the right hand side, those are data constructors, left hand side is a type name that stands for all of the constructors on the right side
03:09:30 <Eliel> so, I would say, yes, that is like data specification
03:09:32 <mokus> algebraic data type declaration?
03:10:38 <Eliel> ah yes, they're called Algebraic Data Types, ADT for short.
03:10:45 <ezyang> mokus: Too restrictive.
03:11:02 <ezyang> For example, I would also like to call C struct { int foo; int bar; } the same.
03:11:44 <mokus> constructor declarations then?
03:12:00 <ezyang> "Well, there's only one constructor there."
03:12:07 <mokus> oh, missed the C part
03:12:11 <Eliel> ezyang: you're writing about data types and need a general term to refer to them?
03:12:25 <mokus> thought you were focusing in on the RHS of Haskell with record syntax
03:12:38 <ezyang> Yeah.
03:12:48 <ezyang> Well, I wasn't originally planning on generalizing, but I realized I could generalize.
03:12:58 <mokus> in that case just a type declaration is what i'd call it
03:13:32 <mokus> but not sure that's restrictive enough for your meaning
03:13:48 <mokus> because 'type Foo = Bar' and C's 'typedef foo bar' would also qualify I think
03:14:03 <ezyang> Yeah, that's not as interesting, though I could probably let it slide.
03:14:41 <ski> ezyang : data type definition
03:16:14 <ezyang> Hmm I guess that works.
03:47:35 <erus`> can i print without evaluating somehow?
03:47:51 <dibblego> eh?
03:47:59 <erus`> eg. let x = 3 in x * 4 = "3 * 4" or "(*) 3 4"
03:48:10 <Sebasti0n> I have a problem with a type class: http://hpaste.org/49400
03:48:32 <dibblego> erus`: try prolog
03:48:50 <Sebasti0n> the instance declaration won't work as the type of elems does not match the type of elements
03:49:36 <Sebasti0n> I do not understand why it does not match as both type parameters are not restricted
03:50:46 <dibblego> Sebasti0n: it's because of the position of the "forall" for the type parameter
03:51:02 <dibblego> elems expects Cluster a -> [b]
03:51:28 <Eelis> erus`: you can make an expression tree type with a Num instance that just builds the tree. i'm pretty sure there are Hackage packages already that do this
03:53:06 <Sebasti0n> dibblego: is there a way to fix it? class Clu (c a) where... does not work either
04:00:50 <Sebasti0n> anybody else know a solution to the problem?
04:05:35 <Eelis> Sebasti0n: make Clu a type class with two parameters
04:06:03 <Eelis> with a functional dependency from one to the other
04:07:12 <Eelis> like so: http://codepad.org/Cf4QElqt
04:07:32 <Eelis> alternative, restrict Clu to things of kind *->*
04:07:34 <Eelis> *alternatively
04:08:28 <Eelis> like so: http://codepad.org/EPpfqtYx
04:11:52 <Sebasti0n> Eelis: thank you a lot for your help!
04:12:05 <Eelis> np
04:12:40 <Sebasti0n> is one of the solutions a better approach
04:12:55 <Sebasti0n> or would you consider both to be equally good?
04:16:21 <Eelis> Sebasti0n: depends on how much genericity you need for the type class. the second option is cleaner in that it requires fewer language extensions, but the restriction to things of kind *->* may be annoying
04:17:14 <Eelis> for instance, suppose you can naturally represent a cluster of Ints using an IntSet. then this works fine with the first option, but not at all with the second
04:17:26 <Eelis> because IntSet it not of kind *->*
04:18:37 <Eelis> i'm told "associated types" (or something like that) are another extension that might do the job, but i've never used them myself.
04:20:05 <Sebasti0n> intset is just of type * as it has no type param, right?
04:20:10 <Eelis> yeah
04:20:35 <Eelis> (or more accurately, it is of /kind/ *)
04:21:47 <Sebasti0n> I think for my problem the second option is fine, but I'll have a look at functional dependencies and flexible instances, thanks for bringing those up
04:22:25 <Sebasti0n> one last question, in your first exable (class Clu c a | c -> a where), what does the c -> a mean?
04:22:32 <Sebasti0n> *example
04:22:37 <Eelis> that's the functional dependency
04:22:47 <Eelis> it means "c always uniquely determines a"
04:23:01 <Eelis> which helps the type checker figure things out
04:23:18 <Lemmih> @seen xerox
04:23:18 <preflex_>  xerox was last seen on #irssi 99 days, 18 hours, 27 minutes and 13 seconds ago, saying: anybody knows how to make irssiproxy respect the /ignores
04:23:18 <lambdabot> Unknown command, try @list
04:23:33 <Sebasti0n> ok, cool
04:23:45 <Sebasti0n> thanks again for the help.
04:23:51 <Eelis> np
04:24:07 <Lemmih> Anyone remember Paolo's last name? He went by the IRC handle 'xerox'.
04:26:46 <Lemmih> Ah, got it. Paolo Martini.
04:26:49 <luite> is this him? http://undecidable.org.uk/edwin/photo/anglohaskell.php?photo=IMG_0367.jpg
04:26:52 <luite> oh
04:26:53 <luite> too late
04:31:12 <Lemmih> That is indeed him. Hah, that hackathon was fun. Weird that it has been five years already.
04:37:54 <erus`> juggling a splif?
04:45:57 <aninhumer> Who's going to this year's Hackathon? First time for me
04:53:31 <identity_> where is it being held?
04:53:33 <erus`> where is it?
04:53:38 <identity_> I'm not going, but I wish I could
04:59:56 <finn> ImportError: No module named PyQt4  < which port do I need to have installed for this error to not show up?
05:04:25 <Saizan> finn: wrong channel?
05:04:33 <finn> yes, sorry
05:14:32 <aninhumer> identity_, erus`: Cambridge, mid-August, but it's booked up now
05:14:46 <erus`> aninhumer: ah i think i remember
05:14:52 <erus`> it was like £300 aswell
05:14:58 <erus`> or something ridiculous
05:15:02 <erus`> as well as a hotel room
05:15:19 <aninhumer> Umm, it's free afair
05:15:40 <erus`> ok that must have been something else :P
05:15:53 <aninhumer> http://www.haskell.org/haskellwiki/CamHac
05:17:11 <aninhumer> It was kind of weird, nearly the first time I came in this channel, someone mentioned it and I found out it was being held at my College
05:46:11 <jkramer> Hi
05:46:47 <jkramer> I'm looking for a Bounded Double-like type
05:47:28 <jkramer> Or: What's the smallest possible (negative) value of double?
05:48:49 <jkramer> On a 32bit architecture to be specific
05:52:06 <aninhumer> Hmm, I'd guess the reason Double isn't a Bounded instance is due to weird float errors?
05:53:26 <jkramer> Probably
05:53:38 <jkramer> I'm going with -1.79769E+308 for now, found here: http://db.apache.org/derby/docs/10.1/ref/rrefsqljdoubleprecision.html
05:53:55 <aninhumer> jkramer: I found this: http://stackoverflow.com/questions/1780489/haskell-minimum-maximum-double-constant
05:53:55 <Saizan> > - (1/0)
05:53:56 <lambdabot>   -Infinity
05:54:47 <aninhumer> Oh right, I suppose you can't really call that a bound
05:55:50 <wli> You can do various sorts of searches for the bound given the "normalcy" of the number as a test.
05:56:04 <jkramer> Saizan: I can't really use Infinity in my code, or can I? :)
05:56:11 <jkramer> I wanna sort by the value later
05:56:12 <wli> Keep doubling until it flunks, then bisect it.
05:56:50 <wli> (It's going to fall on a power-of-two boundary anyway, so bisection isn't going to mean much. The search strategy can probably use that fact.)
05:57:03 <aninhumer> jkramer: Double is an Ord instance, so I'd assume it will sort Infinity properly
05:58:09 * wli is foggy on the fpclassify/etc. support in Haskell standard libs.
05:58:22 <Saizan> NaN's are the ones that don't sort well
05:58:49 <jkramer> Sweet, Infinity works great, thanks :)
06:17:55 <jkramer> Can I use guard syntax in case pattern matching?
06:18:09 <jkramer> Like case foo of \ 123 -> | ... | ...
06:19:03 <Saizan> it goes before the ->
06:20:15 <jkramer> I don't get, do you have an example?
06:20:18 <jkramer> *it
06:22:56 <Saizan> > let foo = Just 4 in case foo of Nothing -> "no"; Just x | x >= 0 -> "positive" | otherwise -> "negative"
06:22:57 <lambdabot>   "positive"
06:23:30 <jkramer> Ah, ok
06:24:20 <aninhumer> I might consider moving the guard to a where clause depending on what's being done
06:26:12 <jkramer> http://hpaste.org/49405 - I just wanted to get rid of the if-then-else
06:47:20 <saati> hi, is there any random number generator in the libs that gives me a normal distribution?
06:48:57 <Saizan> http://hackage.haskell.org/packages/archive/statistics/0.9.0.0/doc/html/Statistics-Distribution-Normal.html
06:51:00 <saati> thanks
06:51:03 <saati> how do i use this?
06:53:56 <Saizan> though the typeclass methods i guess, (never used the lib myself), it's an instance of Variance, Mean, ContDistr and Distribution
06:55:31 <arghhdeb> hi
06:55:35 <arghhdeb>     Couldn't match expected type `GL.GLdouble'                 with actual type `Double'
06:55:41 <arghhdeb> I'm getting crazy
06:56:03 <arghhdeb> the definition of GLdouble is : type GLdouble = double
06:56:25 <arghhdeb> please, how to convert a type to itself o_O
06:56:31 <mreh> @pl foldl1 (flip const)
06:56:32 <lambdabot> foldl1 (const id)
06:56:46 <mreh> wurt
06:56:48 <mreh> :t const id
06:56:49 <lambdabot> forall a b. b -> a -> a
06:56:54 <saati> arghhdeb: realToFrac(dobulevalue) :: GLdouble
06:57:05 <saati> this gives you a GLdouble
06:57:16 <arghhdeb> thanks you very much
06:58:13 <copumpkin> why write functions like that?
06:58:36 <mreh> copumpkin: it's a generic last function
06:58:44 <copumpkin> [10:10:17 AM] <saati> arghhdeb: realToFrac(dobulevalue) :: GLdouble
06:58:55 <mreh> oh
06:59:03 <saati> cargo cult programming?
06:59:10 <saati> i have found this to work
06:59:24 <copumpkin> o.O
06:59:27 <mreh> that's a politically loaded term
06:59:47 <copumpkin> realToFrac doublevalue :: GLDouble
06:59:53 <copumpkin> or even without the annotation, probably
07:00:14 <saati> ah, way too much c like laguage programming
07:00:20 <saati> that's why
07:00:26 <hpc> GLDouble isn't a Frac, is it?
07:00:34 <hpc> :t realToFrac
07:00:35 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
07:00:40 <hpc> er, Fractional
07:00:58 * Saizan wears a GLDouble for the party
07:01:11 <Saizan> why wouldn't it?
07:02:28 <jkramer> Is there an easy way/tool to find out how many CPUs/cores are actually used by a haskell process and how big the load is?
07:02:52 <jkramer> I'm playing with Control.Parallel.Strategies and I'd like to see if it actually makes things faster by using several threads/cores
07:02:53 <mreh> top
07:03:01 <jkramer> That's a little wonky
07:03:03 <mreh> if you're on *nix
07:03:28 <jkramer> Yeah, but I'd like to have more precise numbers
07:03:54 <jkramer> Maybe some kind of profiler that also tracks threads or something
07:03:56 <Saizan> jkramer: ThreadScope
07:04:22 <jkramer> lol whut, by M$?
07:04:34 <Saizan> jkramer: +RTS -s also gives some per-capabilities statistics
07:05:13 <Saizan> GHC main developers work at MSR :)
07:05:17 <Twey> What was the reason we don't want dependent typing in Haskell, again?
07:05:36 <jkramer> I guess ThreadScope is not available for linux then? :)
07:05:52 <Saizan> i'd be surprised if it isn't
07:06:07 <Twey> Sure it is
07:06:13 <aninhumer>     For non-Windows operating systems install Threadscope:
07:06:14 <identity_> i think it's easier to install on linux than windows afaik
07:06:15 <aninhumer>   cabal install threadscope
07:06:23 <jkramer> Nice
07:06:31 <jkramer> Huh
07:06:37 <jkramer> SPARKS: 1099890 (0 converted, 1099890 pruned) - is that good or bad? :)
07:07:05 <identity_> neither, but it basically means your parallel actions didn't get executed in parallel
07:07:09 <identity_> or something like that
07:07:11 <Twey> Means it all ran in one thread
07:07:12 <identity_> read his paper on parallel haskell
07:07:16 <identity_> ^^
07:07:24 <Twey> jkramer: MS Research is heavily invested in Haskell: they fund the Haskell people, the Haskell people make Haskell better, then they take the features from Haskell that they like and think won't rock the boat too much and incorporate them into their proprietary technologies like F# or C#
07:07:32 <Twey> Everyone wins
07:07:46 <jkramer> Nice :)
07:07:59 <jkramer> At least someone gets paid for working on Haskell :)
07:08:07 <Twey> Indeed
07:08:27 <Twey> Well, I say ‘heavily invested’
07:08:49 <jkramer> Is there a good read on how GHC decides when to spark or not?
07:08:50 <Twey> Better to say that Haskell is heavily aided by MS Research
07:09:05 <Eelis> how about "heavily dependent on"?
07:09:20 <identity_> jkramer: Yep, marlow's parallel/concurrent haskell paper
07:09:37 <Twey> Oh, I don't think that's true — I imagine it would keep going if MS pulled out
07:09:37 <identity_> http://community.haskell.org/~simonmar/par-tutorial.pdf
07:09:45 <identity_> @where par-tutorial
07:09:45 <lambdabot> I know nothing about par-tutorial.
07:09:48 <identity_> can you add to those?
07:09:53 <identity_> to @where entries, that is
07:09:58 <Twey> @where+ par-tutorial http://community.haskell.org/~simonmar/par-tutorial.pdf
07:09:58 <lambdabot> Done.
07:10:10 <identity_> Twey: cool
07:11:02 <aninhumer> I would have thought Glasgow pays at least some people who are working on it?
07:11:30 <levkin> Hi
07:12:18 <aninhumer> Oh I see, they moved
07:13:01 <aninhumer> Heh Haskell developed in Cambridge, Cambridge teaches ML, Oxford teaches Haskell...
07:13:02 <Twey> Yeah, I think they're based in the MS Research labs at Cambridge now
07:13:44 <levkin> QuickCheck . Given x : Instance of Attribute and g :: x -> Gen x. How can I convert  ( arbitrary x >>= g ) to be part of Testable expression
07:13:58 <levkin> QuickCheck . Given x : Instance of Arbitrary and g :: x -> Gen x. How can I convert  ( arbitrary x >>= g ) to be part of Testable expression
07:52:17 * hackagebot dclabel-eci11 0.3 - The Disjunction Category Label Format.  http://hackage.haskell.org/package/dclabel-eci11-0.3 (AlejandroRusso)
08:09:52 <sam1> in haskell, is there a division method that works with Num type?
08:10:44 <wto> sam1: integer division or "regular" one?
08:10:52 <Saizan> ?type div
08:10:53 <lambdabot> forall a. (Integral a) => a -> a -> a
08:10:55 <wto> there is the / operator for division
08:10:58 <sam1> integer division
08:11:02 <wto> and div for integer division
08:11:16 <Saizan> neither work with just Num though
08:11:22 <wto> > 8 `div` 3
08:11:23 <lambdabot>   2
08:11:28 <sam1> I defined a type as instance of Num
08:11:32 <sam1> and trying to define division
08:11:40 <sam1> but there doesn't seem to be division with num
08:12:48 <monochrom> there is none
08:13:07 <sam1> I see... I guess I'll have to figure something out a different wa
08:13:09 <sam1> y
08:13:22 <monochrom> yes, such as Integral or Fractional
08:13:43 <monochrom> in fact, do both: http://www.vex.net/~trebla/haskell/testbed.cgi
08:16:22 <rvn_> > 8 / 3
08:16:23 <lambdabot>   2.6666666666666665
08:17:44 <jkramer> Does -Nx have any effect when I'm not explicitly using any par* functions in my code?
08:28:01 <monochrom> it has effects on forkIO too
08:30:12 <_KY_> I like the LHS way of literate programming, is there something like it for Lisp? the *web styles are so ugly and complicated
08:31:13 <gwern> _KY_: I'm sure there is. that is the magic of macros...
08:31:48 <_KY_> I can't find any... the options are very limited...
08:32:03 <_KY_> For Lisp
08:33:17 <monochrom> noweb is simple IMO
08:34:22 <parcs> @hoogle (Word8 -> a) -> ByteString -> [a]
08:34:23 <lambdabot> Data.Data gmapQ :: Data a => (d -> u) -> a -> [u]
08:34:23 <lambdabot> Data.ByteString all :: (Word8 -> Bool) -> ByteString -> Bool
08:34:23 <lambdabot> Data.ByteString any :: (Word8 -> Bool) -> ByteString -> Bool
08:35:02 <ski> @hoogle ByteString -> [Word8]
08:35:02 <lambdabot> Data.ByteString unpack :: ByteString -> [Word8]
08:35:02 <lambdabot> Data.ByteString.Lazy unpack :: ByteString -> [Word8]
08:35:02 <lambdabot> Data.ByteString head :: ByteString -> Word8
08:35:44 <Cale> (As a general rule of thumb, there probably shouldn't exist both instances of Integral and Fractional for the same type.)
08:35:54 <parcs> ski: forgot about that :P
08:35:54 <monochrom> heh
08:36:15 <Twey> Cale: Is there a type for which it would make sense?
08:37:30 <ski> @type argument Data.ByteString.unpack . map
08:37:31 <lambdabot> forall b. (Word8 -> b) -> BSC.ByteString -> [b]
08:38:19 <Cale> Well... if you were using integers modulo a large prime as a finite approximation of Integer, you could use / for field division and `div` for the approximate integer division.
08:38:29 <Cale> But that's already pretty weird.
08:40:54 <Twey> Cale: Haha, indeed
08:44:28 <Eduard_Munteanu> @bot
08:44:29 <lambdabot> :)
08:44:41 <Eduard_Munteanu> @vixen Where have you been?
08:44:41 <lambdabot> let me answer that later, okay?
09:07:18 <identity_> Huh. BlazeHtml is so many times much more intuitive than I thought
09:07:48 <identity_> And happstack looks quite grok-able as well
09:12:05 <hpc> both are awesome
09:24:50 <The_Ice[home]> hi, i'm trying to use enumerator library and a little confused: i want to have 3 functions: one for input, one for processing data and one for output - as i suppose, input must be Enumerator, processing must be Iteratee, but what type must have output function?
09:34:01 <jkramer> https://github.com/jkramer/tictactoe/blob/master/TicTacToe.hs
09:34:14 <jkramer> Any suggestions on improvements or bugs? :)
09:34:57 <jkramer> Regarding the code of course, I know the AI is pretty naive :)
09:35:11 <Rotaerk> jkramer, use C++
09:35:12 * Rotaerk ducks.
09:35:20 <jkramer> :D
09:35:34 <Twey> Hahaha.
09:35:52 <cmccann> yes, using C++ is an excellent suggestion for implementing bugs
09:36:16 <Twey> :-D
09:42:20 <danharaj> Let's say I have a ForeignPtr I need to keep track of, and make sure it doesn't go out of scope too soon.
09:42:30 <danharaj> So I can use 'withForeignPtr' or 'touchForeignPtr' for that.
09:42:52 <The_Ice[home]> with*
09:43:16 <danharaj> Let's say I put the ForeignPtr in an MVar, and use it as a lock, without touching it. Will it not go out of because of the 'takeMVar' and 'putMVar' calls?
09:44:40 <Twey> danharaj: It will be freed when your function returns, and you'll have a dangling pointer in the MVar.
09:45:18 <danharaj> ah, ok. So the GC doesn't see what's in MVars.
09:45:47 <Twey> danharaj: A value that you can still access will never be garbage-collected
09:46:03 <danharaj> Twey, I'm not sure that's true.
09:46:23 <Twey> Thunks aside, I'm pretty sure it is
09:46:31 <Twey> That would result in undefined behaviour, which would be Bad
09:47:03 <danharaj> I have been told that even if I keep the ForeignPtr in the values I pass around, it can be GC'd if it's never used again.
09:47:20 <danharaj> and I never really use it except to tell the GC when to run a finalizer.
09:47:25 <Twey> Potentially, I guess
09:49:24 <danharaj> ah well, I can just keep an MVar () around for locking and a ForeignPtr for controlling the finalizer.
09:49:26 <int-e> danharaj: GC certainly sees the contents of MVars. As long as you keep the ForeignPtr value around, you're fine. The point of 'touchForeignPtr' is that it constitutes a "use" of the ForeignPtr, so it won't be GCed before that call.
09:49:45 <danharaj> int-e: Oh, ok. Now I'm confused.
09:50:00 <danharaj> So the GC won't garbage collect a ForeignPtr that has no references to it except in an MVar?
09:50:07 <int-e> right
09:50:29 <danharaj> ah ok.
09:50:44 <danharaj> Is there anything I need to be worried about in the interaction of unsafePerformIO, MVar's, and forkIO?
09:50:58 <danharaj> I'm writing a pure interface to a C library, to explain this madness.
09:51:02 <int-e> yeah, be wary about unsafePerformIO
09:52:02 <int-e> (it really depends on what exactly you're doing with it. needless to say, most uses are indeed unsafe.)
09:52:42 <danharaj> The library is basically a state machine that produces referentially transparent values. I use ForeignPtr's and their finalizers to control memory management on the library end via the GC. When I use the state machine, I use unsafePerformIO, fiddle the state, get the value, and then restore the state. All referentially transparent this way.
09:53:12 <monochrom> The_Ice[home]: input is Enumerator, middle processing is Enumeratee, output is Iteratee that happens to do IO
09:53:27 <monochrom> input is Enumerator that happens to do IO, too
09:53:39 <int-e> is the state fiddling thread safe?
09:54:22 <danharaj_> ach, my internet is unstable, did you get all of that?
09:54:36 <int-e> up to "All referentially transparent this way."
09:54:43 <danharaj_> ah ok
09:55:04 <int-e> And I wondered whether the state fiddling is thread safe
09:55:12 <danharaj_> I need to make sure that the calls to unsafePerformIO are executed without interleaving with each other, because they might mess up the intermediate state of a call.
09:55:16 <danharaj_> It isn't.
09:55:36 <monochrom> it comes down to whether "unsafePerformIO (... takeMVar ... putMVar ...)" behaves as expected. I assume you don't have forkIO inside there
09:55:40 <danharaj_> That's why I use forkIO in the unsafePerformIO calls and use an MVar to lock the library while a computation occurs.
09:55:41 <int-e> ok, then you need a lock, and I guess that's where you want to use the MVar. Which seems fine.
09:55:51 <burbul> Does anyone have any opinions on which of these is nicer? http://hpaste.org/49411
09:56:01 <int-e> (use withMVar rather than takeMVar/putMVar for a bit extra exception safety_
09:56:03 <monochrom> and I believe it behaves as expected
09:56:03 <burbul> [ I'm not using camelcase because it's a pain to get using dictation software]
09:56:26 <danharaj_> int-e: could you elaborate? This is my first foray into unsafePerformWizzardry and concurrency.
09:57:19 <monochrom> I think you are better advised to ask on the glasgow-haskell-users mailing list
09:57:33 <danharaj> monochrom: good point.
09:57:42 <The_Ice[home]> monochrom: hm) looks like i've misunderstood enumerators' abstraction, thanks :-[
09:57:58 <monochrom> at least because there is not even any folklore about "unsafePerformIO (... forkIO ...)"
09:58:12 <ski> burbul : either version is fine, imo
09:58:47 * ski might omit the type ascription
09:59:43 <int-e> danharaj: if your state machine is represented by an MVar holding a ForeignPtr to some state, operations could be implemented as  foo mvar = unsafePerformIO $ withMVar mvar $ \fp -> withForeignPtr fp $ \rawpointer -> do whatever
10:01:06 <int-e> danharaj: ensuring mutual exclusion of the various uses of the state machine, and keeping the corresponding memory alive as long as required. (and GC will collect the ForeignPtr when the MVar is collected, assuming that's the only reference to it)
10:02:51 <Eduard_Munteanu> @tell joe6 Yes. :)
10:02:51 <lambdabot> Consider it noted.
10:03:15 <ski> @type flip (flip Control.Concurrent.MVar.withMVar . flip Foreign.ForeignPtr.withForeignPtr)
10:03:16 <lambdabot> forall b a. GHC.MVar.MVar (GHC.ForeignPtr.ForeignPtr a) -> (GHC.Ptr.Ptr a -> IO b) -> IO b
10:03:51 <danharaj> int-e: my concern is that two calls to unsafePerformIO in the same thread can have their constituent actions performed in an unspecified order. So the thread could use the MVar in one action, but before that action finishes, another call to unsafePerformIO occurs and the MVar is taken again, resulting in a deadlock.
10:03:56 <int-e> ski: but that's almost unreadable ;)
10:04:11 <Wild_Cat> is there an Ubuntu (Natty) PPA with the latest version of the Haskell platform?
10:04:13 <danharaj> I'm not sure if unsafePerformIO has this behavior, but the docs don't specify.
10:04:32 <ski> @type (. flip Foreign.ForeignPtr.withForeignPtr) . Control.Concurrent.MVar.withMVar
10:04:33 <lambdabot> forall a b. GHC.MVar.MVar (GHC.ForeignPtr.ForeignPtr a) -> (GHC.Ptr.Ptr a -> IO b) -> IO b
10:04:56 <ski> int-e : yeah .. it feels like doing this kind of "quantifier composition" ought to be simpler
10:05:10 <parcs> @hoogle [[a]] -> Ptr (Ptr a)
10:05:10 <lambdabot> Prelude fail :: Monad m => String -> m a
10:05:10 <lambdabot> Control.Monad fail :: Monad m => String -> m a
10:05:10 <lambdabot> Control.Monad.Instances fail :: Monad m => String -> m a
10:06:26 <clsmith> huh. why is Data.HashTable.new IO monadic?
10:06:27 <int-e> danharaj: You're right, this may happen if some argument to 'foo' uses another operation on the state. To avoid this, you should fully evaluate the arguments of 'foo' (the operation) before taking the MVar.
10:06:41 <ski> @type Foreign.Marshal.Array.newArray <=< mapM Foreign.Marshal.Array.newArray
10:06:41 <lambdabot> forall a. (Foreign.Storable.Storable a) => [[a]] -> IO (GHC.Ptr.Ptr (GHC.Ptr.Ptr a))
10:06:58 <ski> (or maybe `newArray0', depending on what you want)
10:07:00 <parcs> are `Ptr (Ptr a)`s even safe?
10:07:45 <danharaj> int-e: I'll keep that in mind as a solution. I'll test the forkIO strategy, and if that doesn't work put something on the mailing list and try that.
10:09:55 <int-e> danharaj: Oh and I hope there's some non-trivial external library involved in all this. Otherwise I'd question the design :)
10:10:33 <int-e> parcs: if the pointers are static pointers, not to the heap but to, say, C-allocated (using C's malloc) dynamic memory, why not?
10:10:55 <danharaj> int-e: oh of course.
10:10:57 <int-e> parcs: also the pointers might point to pinned bytearrays.
10:11:32 <Fezzler> just search lists by # of users and saw haskell.  in an effort to learn something new.  why haskell over ruby?
10:11:54 <danharaj> Fezzler: They're completely different. That's a hard question to answer. What are you looking to do?
10:13:08 <Fezzler> danharaj> Just curious.  What is the major use for haskell?
10:13:09 <Wild_Cat> Fezzler: Ruby and Haskell are completely different. What languages do you already know, and what do you plan to do with the language you'd like to learn now?
10:14:29 <Fezzler> Pure learning and intellectual curiosity on a 105-degree day.  Downloaded channel list and saw haskell so high on list and really know nothing about it.
10:14:49 <Fezzler> I guess I'll Google it.
10:14:50 <monochrom> learn both haskell and ruby. learn everything
10:14:58 <danharaj> Fezzler: start at haskell.org :)
10:15:11 <Eduard_Munteanu> clsmith: probably because it uses an underlying array to achieve mutation
10:15:20 <Wild_Cat> Fezzler: one thing that'll probably help: if you already know Python, go for Haskell.
10:15:27 <monochrom> for a better answer, upload your complete brain content for a free analysis
10:15:37 <danharaj> Fezzler: For a general look at how it's used in big projects: http://www.haskell.org/haskellwiki/Haskell_in_industry
10:15:38 <Wild_Cat> (Ruby is too similar to Python for learning it to be an enlightening experience)
10:15:45 <danharaj> It's also being used in web servers and other apps.
10:15:50 <Fezzler> I like ruby as a hobby programmer because of its Pascal-like ease
10:16:14 <monochrom> if you like ruby, like ruby
10:16:27 <Wild_Cat> (and if you don't know Python, my devil's advocate suggestion would be to forget about Ruby and Haskell for now and go learn Python instead :p )
10:16:43 <danharaj> C, Python, Haskell is a good repertoire to have.
10:17:02 <Fezzler> Cool.  I know some programs I use rely on Python scripting
10:17:02 <Wild_Cat> danharaj: very much agreed. Maybe add a JVM language to that while you're at it
10:17:04 <int-e> Aww, but Python is too simple ;) (deceptively so, sometimes)
10:17:21 <Wild_Cat> (although once you know the 3 you mentioned, learning Java is trivial)
10:17:33 <jmcarthur> too simple? what?
10:17:35 <sanjoyd> Java was designed to be easy to learn.
10:17:38 <monochrom> I know some programs I rely on that bombs out just because of python non-static typing
10:17:49 <Fezzler> Well, I have disrupted you all enough.  Thanks for the response.
10:17:52 <jmcarthur> what about python is simple?
10:17:56 <jmcarthur> *too simple
10:17:59 <int-e> jmcarthur: The language. Getting to know the libraries is a bit harder.
10:18:13 <danharaj> Python is not simple.
10:18:17 <Fezzler> PS - interested in programming sound.
10:18:26 <copumpkin> http://web.mit.edu/rwbarton/www/python.html
10:18:33 <copumpkin> for anyone who thinks they know python well
10:18:43 <Wild_Cat> monochrom: After a few attempts at learning Haskell (and getting further every time -- maybe this one is the one :p ), I've come to realize that the single best thing about Haskell (and related languages) is type inference. I miss it dearly in Python.
10:19:07 <clsmith> i think python is easier for beginners who are doing trivial things
10:19:17 <clsmith> once you create a big codebase, you start to cry
10:19:21 <danharaj> Fezzler: Feel free to ask question in here as they arise.
10:20:01 <Fezzler> Will do haskell fanatics!  Friendly group/
10:20:15 <Wild_Cat> clsmith: not true. My day job is working on a big Python codebase, and all in all, I rarely run into a problem that's caused by the language or its type system. They're almost all architecture issues.
10:20:34 <clsmith> Wild_Cat: my day job is also working on a python codebase. most f t
10:20:55 <clsmith> .. of the time it's fine. but about once every month, the type system shoots me in the foot
10:21:16 <Wild_Cat> the one part of that codebase that's a nightmare to maintain was written by a guy who didn't know Python and came from Windows C++/Java.
10:21:24 <clsmith> (putting backspace next to enter is the worst thing about every keyboard)
10:21:36 <jmcarthur> admittedly i am no python expert, but i find that i spend a lot of my time working around python's intentional limitations
10:21:57 <copumpkin> jmcarthur: chances are what you wanted to do was unpythonic
10:21:58 <Wild_Cat> (and even it remains pretty robust compared to a lot of our C++ middleware)
10:22:00 <copumpkin> and we can't allow that
10:22:01 <adrake_> clsmith: mine's a key away :P
10:22:05 <jmcarthur> e.g. no switch/case feature because it was decided that if you want it then you should be using a bunch of classes instead
10:22:10 <monochrom> heh heh heh
10:22:14 <jmcarthur> come on, can't i just save a few lines?
10:22:21 <Wild_Cat> jmcarthur: no, Python's answer to switch/case is a dispatch dict.
10:22:44 <Wild_Cat> if you're using a bunch of classes instead, you're doing it wrong.
10:22:46 <jmcarthur> Wild_Cat: that's just a workaround. it's not the *intended* substitute when they decided to leave the feature out
10:22:47 <copumpkin> Wild_Cat: why isn't that its answer to if statements?
10:23:04 <Wild_Cat> copumpkin: what?
10:23:13 <copumpkin> if and case are not fundamentally different
10:23:14 <jmcarthur> dispatch on booleans
10:23:15 <osfameron> it is, in Smalltalk, isn't it?
10:23:21 <clsmith> Wild_Cat: i have things like str complaining that __str__ returns a non-string. why? why?! turns out in one bit of my code i made a once character typo. it took me some time to find it. haskell would just say, "uh, hey, that's not a string."
10:23:31 <Wild_Cat> jmcarthur: I don't know, for a workaround it works nicely and is surprisingly readable.
10:23:46 <clsmith> Wild_Cat: that is, at the cause, not at the symptom
10:24:02 <Wild_Cat> clsmith: I remain convinced that Python with Haskell's type inference would be the best thing ever.
10:24:20 <danharaj> it wouldn't work
10:24:36 <clsmith> Wild_Cat: it would be much better, yes. there are other things i prefer in haskell. all in all, i'm just planning to switch to haskell entirely.
10:24:46 <Wild_Cat> copumpkin: you mean using dispatch dicts instead of if? Come on now. As the zen of Python itself says, "practicality beats purity."
10:24:59 <copumpkin> Wild_Cat: wait, but writing a quick and dirty case statement is practical
10:25:13 <copumpkin> why did they decide to force me into purity there
10:25:15 <jmcarthur> Dr. Haskell observes that you have a puncture wound near your shoulder. Dr. Python observes that there is blood all over your leg.
10:25:16 <copumpkin> and not for if statements?
10:25:18 <arw_> Wild_Cat: just having type inference wouldn't change anything. you would also need to replace the type system of python.
10:25:29 <copumpkin> python has a monoidal type system
10:25:30 <copumpkin> >_>
10:25:37 <arw_> jmcarthur: if it bleeds like a duck...
10:25:42 <Wild_Cat> clsmith: well, I'm planning to use Haskell for my night projects and keep using Python for my day job. All in all, there's a few things I feel map better to an OO paradigm than functional (UIs are a prime example), and other wilder stuff I plan to explore that I think will work better in functional.
10:25:52 <clsmith> jmcarthur, arw_: rofl
10:26:30 <danharaj> Wild_Cat: The functional structure for UI's is something a lot of people are working on. I think many people like FRP for it. You should check out the reactive-banana library.
10:26:34 <jmcarthur> Wild_Cat: functional and OO are not at all at odds with each other
10:26:37 <danharaj> It's being hooked into wx right now.
10:26:49 <Wild_Cat> danharaj: I will, thanks for the pointers.
10:26:58 <jmcarthur> Wild_Cat: OO style is not completely uncommon in haskell
10:27:05 <jmcarthur> Wild_Cat: although it's not reached for as often
10:27:17 <Wild_Cat> jmcarthur: type classes enable it, right?
10:27:28 <clsmith> Wild_Cat: well, no one has a job doing haskell. (no one.) but for everything outside work.. maybe i can do research. (which isn't a job, guys. no one has a job doing haskell.)
10:27:37 <jmcarthur> Wild_Cat: nah. i'm thinking things like existential quantification or poor man's objects
10:27:42 <Wild_Cat> (and with that, AFK dinner, back in a while -- this discussion is very interesting, thanks guys)
10:27:43 * ski would more say that existentials enable (some aspects of) OO
10:27:45 <danharaj> Wild_Cat: type classes and existential types let you do dynamic dispatch. you can use a GHC library to do dynamic casting.
10:27:49 <jmcarthur> clsmith: no one?
10:27:55 <clsmith> jmcarthur: no one. :)
10:28:08 <jmcarthur> that claim is very suspect to me
10:28:25 <jmcarthur> unless by that you mean "not only one" ;)
10:28:28 <danharaj> There's a bunch of people in this very channel who work doing Haskell.
10:28:30 <copumpkin> clsmith: I know several people who do haskell for their jobs
10:28:38 <copumpkin> full-time
10:28:53 <int-e> print "word" in [] == False  is cute.
10:29:02 <clsmith> no they don't. haskell is a research programming language, designed by crazy PhDs. ;)
10:29:10 <monochrom> ?
10:29:11 <copumpkin> oh I see
10:29:20 <jmcarthur> i don't
10:29:27 <identity_> Ah, thank you #haskell, staying true.
10:29:27 * copumpkin goes back to working on his Ph.D. in category theory! I really want to be able to finally write that Hello World in haskell
10:29:52 <clsmith> copumpkin: lol
10:30:01 <mercury^> int-e: I don't understand. How is that valid?
10:30:02 <identity_> copumpkin: Good luck
10:30:02 <int-e> (it's equivalent to ("word in []) && ([] == False) in Python. Which, I admit, I had to look up in the syntax reference)
10:30:17 <mercury^> int-e: Oh, is it not Haskell?
10:30:40 <copumpkin> int-e: I thought the other ones were more WTF-worthy
10:30:44 <monochrom> clearly, haskell is not cute :)
10:30:46 <int-e> sorry, && --> and. mercury^: yes.
10:31:02 <copumpkin> int-e: in particular, #3 was completely unexpected
10:31:16 <int-e> copumpkin: they are. which makes them less cute though, since they're artifacts of poor implementation, poor scoping.
10:31:30 <copumpkin> :)
10:32:26 <mercury^> Is there some web resource you are referencing right now?
10:32:31 <copumpkin> http://web.mit.edu/rwbarton/www/python.html
10:32:36 <copumpkin> mercury^: enjoy #3 :
10:32:37 <mercury^> Thanks.
10:32:37 <copumpkin> :)
10:33:46 <ski> is #3 printing `33' ?
10:33:50 <copumpkin> no
10:34:00 <copumpkin> :P
10:34:12 <copumpkin> that was my guess at first, too
10:34:18 <copumpkin> "oh, python has shit scoping, so it must be 33"
10:34:19 <ski> .. i assume it's not printing `11', either
10:34:23 <copumpkin> yeah, not that either
10:34:38 <clsmith> oh dear, #3 breaks my mind
10:35:12 <int-e> #2 is explained by the fact that 'exit' used to be a variable containing the string 'Use Ctrl-D (i.e. EOF) to exit.'
10:35:15 <ski> (it would be `33', if it had relatively sane scoping like Scheme, the latter `units = [...]' mutating the location that `units' in bound it)
10:35:44 <copumpkin> ski: it's actually 31 :P
10:36:09 <ski> that's interesting
10:36:28 <clsmith> i don't understand why 'units' and 'tens' aren't just closed over when the list comp is made. in fact, i don't understand where it gets the answer '31' from.
10:36:30 <mercury^> How is #1 explained?
10:37:02 <copumpkin> mercury^: I can't remember :/
10:37:10 <int-e> mercury^: dynamic binding - i refers to the global variable i, and after the loop that's 99.
10:37:10 <ski> hm, it might be that it dereferences `units' when assigning to `nums', but the dereference of `tens' is delayed
10:37:26 <mercury^> Haha.
10:37:31 <copumpkin> ski: yeah, in a for comprehension, the first variable being iterated over is captured, the others are referenced dynamically
10:37:33 <copumpkin> it's pretty wtf
10:37:46 <clsmith> oh dear lord
10:37:49 <clsmith> that is so broken
10:38:18 <ski> copumpkin : i would say that the first is dereferenced, and references to the others are captured
10:39:10 <int-e> [(lambda i: lambda x: x + i)(i) for i in range(100)][17](42) prints 59 :)
10:39:45 <monochrom> programming language is hard
10:39:51 <arcatan> let's go shopping
10:40:03 <monochrom> (let's go trolling #python? :) )
10:40:06 <arcatan> yes!
10:40:33 <olsner> just paste everything from when copumpkin sends the link to now :)
10:40:39 <int-e> copumpkin: anyway thanks for the entertaining link :)
10:40:51 <copumpkin> no problem, but thank rwbarton really :)
10:40:54 <copumpkin> he wrote it
10:41:29 <olsner> or maybe you could get freenode to pipe everything that happens in #haskell into #python, that'd be amusing
10:49:07 * sm__ needs an editor on windows & tried cabal install yi
10:49:28 <sm__> am I sensible or mad ?
10:49:35 <monochrom> both
10:50:05 <sm__> so far so good, I have great hopes
10:50:40 <osfameron> python scoping seemed like rather weak sauce
10:52:41 <sm__> fails due to missing happy.. ok
10:52:58 <sm__> and that requires perl. rats.
10:53:03 <silver> python is hard
10:57:21 <monochrom> in windows I use notepad++
10:57:43 <silver> there is vim
10:59:05 <smop> i use sublimetext
11:00:20 <Twey> http://www.ergoemacs.org/ has a handy Windows bundle including haskell-mode ☺
11:00:26 <monochrom> but interesting that yi wants happy
11:01:03 <Wild_Cat> isn't happy included in the Haskell platform?
11:01:08 <fryguybob> The platform includes happy
11:01:12 <Wild_Cat> it shows up as a haskell-platform dep here.
11:01:40 <Wild_Cat> also, is there a PPA for Ubuntu 11.04 with the latest version of haskell-platform and its deps?
11:01:55 <monochrom> no, there isn't
11:02:07 <Wild_Cat> the base system only offers 2010.1.xxxxx and to add insult to injury, its dependencies are broken.
11:02:16 <monochrom> verily
11:02:35 <Wild_Cat> hrmm.
11:02:37 <bgamari> :t (***)
11:02:38 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
11:03:09 <Wild_Cat> that's sort of sucky.
11:03:38 <monochrom> I suggest http://www.vex.net/~trebla/haskell/haskell-platform.xhtml because that's what I wrote and that's what I do to myself
11:04:50 <Wild_Cat> yeah, building from source should work.
11:05:58 <Wild_Cat> (that, or I'll just be lazy and work on a theoretical level until I get back to my Windows box where I'll download binaries)
11:12:12 * sm__ is trying to install emacs.. what a massive yak-shave this is turning into
11:12:58 <monochrom> I thought it was a massive gnu-shave :)
11:13:59 <Wild_Cat> Is Leksah usable, by the way?
11:14:07 <Wild_Cat> (followup: is it *good*?)
11:14:30 <sm__> monochrom: the yaks have brought in their cousins, the gnus
11:16:31 <sm__> victory!
11:16:51 * sm__ dives into the safe emacs world
11:26:44 <sm__> ha ha, not so fast. I rashly renamed runemacs.exe to emacs.exe and now its looping unkillably
11:27:27 <luite> why? to get rid of the pinned taskbar icon issue?
11:27:28 <cmccann> sm__, taking the least fixed point I see
11:28:14 <mwc> Can anybody help me with this prototype? http://hpaste.org/49414 I get a conflicting family instance declaration error on lines 10 and 13
11:28:31 <mwc> I'm trying to create an idempotent type-level function where it can only be applied once
11:31:56 <mwc> The instance declarations of a data family used in a single program may not overlap at all, independent of whether they are associated or not. In contrast to type class instances, this is not only a matter of consistency, but one of type safety.
11:32:00 <mwc> darn
11:32:17 <mwc> Anybody have any other suggestions for how to create an idempotent type-level functions?
11:32:20 <hcube> hi
11:32:51 <hcube> is any haskeller from bristol?
11:33:54 * ski recalls reading about "Brisk", a Haskell implementation made at Bristol
11:35:00 <mwc> I'm trying to decorate a witness type, but I need to collapse repeated decorations like X (X (X (X Foo))) back down to X Foo
11:35:53 <cmccann> mwc, pretty sure that's impossible in full generality
11:36:15 <cmccann> mwc, essentially what you want is a type family that does one thing for a specific set of types, and something else for all others
11:36:19 <mwc> Hmm, I thought it could maybe be done with type families and overlapping instances since X a is more specific instance than a
11:36:34 <mwc> cmccann: precisely what I attempted in http://hpaste.org/49414
11:36:39 <Saizan> should work with fundeps
11:36:41 <cmccann> you could if overlapping was allowed, but it isn't, so you can't :T
11:36:53 <mwc> Saizan: hmmm, I'll give that a shot
11:37:10 <Saizan> not in a straightforward way though
11:37:22 <cmccann> this sort of "catch-all default instance" behavior is why people want closed type families, and the one case where fundeps can still do more than TFs
11:38:09 <Cale> If you have a class with only an associated type in it, you might as well turn that into a type family.
11:38:26 <cmccann> be warned that with the fundeps approach you're still likely to have problems if you try to use it on polymorphic types
11:38:45 <danharaj> am I a bad person if I've used fundeps and associated type families in the same type class.
11:39:19 <cmccann> danharaj, yes, that's a mortal sin, sorry
11:39:21 <cmccann> I'm not sure why you would do that anyway
11:39:22 <Saizan> mwc: take a look at IsFunction http://okmij.org/ftp/Haskell/isFunction.lhs, and remember that TypeCast can be replaced with ~ now
11:39:58 <ski> (hm, is `class C a b | a -> b , b -> a' more or less equivalent to `class C a where data B a' ?)
11:40:53 <cmccann> ski, not if you need instances of C for types that already exist independently of the class
11:40:57 <Cale> danharaj: Rather than that, you could usually use just associated types, along with type equality constraints for conveniently referring to applications of the associated types. However, it's still broken in the released GHC, fixed in HEAD apparently.
11:41:05 <danharaj> cmccann: I find that associated types can make type signatures cleaner, but some types you want in the typeclass signature.
11:41:40 <cmccann> ski, but it is equivalent to class (A b ~ a, B a ~ b) => C a b where type A b :: *; type B a :: * etc. etc.
11:42:06 <Cale> cmccann: Except that can start hitting GHC bugs ;)
11:42:08 <cmccann> danharaj, yes, that's what the equality constraints like I just used are for
11:42:11 <ski> cmccann : hm. so is third-party code an argument to use MPTCs with FDs, then ?
11:42:29 <cmccann> Cale, oh? seemed to work fine last time I tried it
11:43:18 <cmccann> ski, I think the only real argument for using fundeps is oleg's TypeEq or equivalent hackery, e.g. the default instance stuff
11:45:40 <shaunlippy> Complete noob here - to IRC, that is, not just #haskell.  Feel free to scold me if I do something inappropriate - it's the only way I'll learn!
11:45:41 <Saizan> i don't see how  class (A b ~ a, B a ~ b) => C a b where type A b :: *; type B a :: * would be nicer than class C a b | a -> b , b -> a even if it worked properly :)
11:45:59 <Cale> shaunlippy: Feel free to ask any questions you might have
11:46:07 <shaunlippy> Thanks!
11:47:31 <shaunlippy> I actually have a question about lambda-calculus - I'm working my way through a book and came upon something...is this an appropriate forum for this?  (BTW, I'm reading the lambda-calculus book to help me really learn haskell!)
11:47:37 <Cale> http://hackage.haskell.org/trac/ghc/ticket/2715#comment:18
11:47:48 <ski> yeah, asking about LC here is fine
11:48:00 <Cale> ^^ it's fixed in HEAD :)
11:49:12 <cmccann> Cale, oh, thought you meant bugs other than the "this is horribly broken, it's removed until we fix it" deal
11:49:21 <cmccann> should have mentioned I'm using a snapshot build :P
11:49:40 <Saizan> i guess it's currently nicer because it interacts sanely with gadts
11:49:48 <Cale> Yeah, if you're using 7.0.3 or 7.0.4, it's not going to work, at least :)
11:49:59 <cmccann> Saizan, I think it's mostly that type families are in general nicer
11:50:05 <Cale> We ran into this problem in one of our libraries at iPwn :)
11:50:22 <Saizan> cmccann: that seems circular
11:50:29 <Cale> Though, it's easy enough to work around, it can make the type signatures a bit ugly to not have those equalities.
11:51:14 <shaunlippy> So I'm asked to show that the composition operation is associative.  The compose combinator is defined as Lf.Lg.Lx.(f)(g)x.  So I need to show that ((compose)((compose)f)g)h = ((compose)f)((compose)g)h.  [NOTE:  Using 'L' instead of the greek 'lambda' because I don't know how to type 'lambda' here!]
11:51:25 <Twey> Cale: http://spl.smugmug.com/Humor/Lambdacats/simon/965006902_kWLvY-O.jpg
11:51:26 <cmccann> Saizan, I mean that in general TFs are nicer to use that fundeps, so even if the double equality constraint isn't any nicer than the bidirectional fundep it's nicer by virtue of interacting better with TFs as a whole
11:51:49 <geheimdienst> Twey: gimme five, i was gonna link to exactly that :-D
11:51:56 <Cale> Twey: yeah, thanks for linking that, I was thinking about it as I typed that :)
11:52:03 <Twey> geheimdienst: ⁵
11:52:05 <cmccann> shaunlippy, just use \ for lambda in here, since that's how it's written in Haskell
11:52:18 <Twey> Cale: I figured you were but couldn't be bothered to look it up
11:52:21 <crappygonzales> hi
11:52:26 <Twey> So I helped :þ
11:52:35 <shaunlippy> Thanks, cmccann.
11:52:39 <Twey> shaunlippy: λ
11:52:39 <cmccann> shaunlippy, or just copy+paste λ ;]
11:52:42 <ski> shaunlippy : and the question is ?
11:52:42 <crappygonzales> dumbass question... what's the difference between currying and partial application?
11:52:43 <cmccann> oh pf
11:52:46 <Twey> Heh
11:52:55 <Saizan> i always thought of that cat as being S. Marlow though, not sure why
11:52:56 <Cale> shaunlippy: Just expand out the definition of compose on either side
11:52:57 <danharaj> :t curry
11:52:57 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
11:53:00 <Twey> crappygonzales: Partial application is a technique enabled by currying
11:53:13 <cmccann> crappygonzales, the difference is that people confuse one for the other all the time, but only the confuse them the other way around sometimes
11:53:15 <ski> cmccann : if you say `f x y = ..x..y..', then `f' is a curried function. `f 42' is a partial application of the curried function
11:53:29 * cmccann doesn't think that was meant to be directed at him
11:53:30 <crappygonzales> uh, how
11:53:31 <danharaj> currying is turning a function that takes a tuple of arguments into a function that takes a single argument and returns a function.
11:53:32 <crappygonzales> Twey: yes, but why isn't currying just partial application?
11:53:34 <ski> s/cmccann/crappygonzales/
11:53:47 <Twey> crappygonzales: Currying is the conversion of a function into a curried form: it's not any kind of application
11:53:55 <Twey> (from a non-curried form)
11:53:56 <geheimdienst> ski: how is that function curried? because it has 2 arguments?
11:54:01 <Twey> :t curry
11:54:01 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
11:54:06 <Twey> ^ this function performs currying
11:54:16 <mercury^> :t curry curry
11:54:17 <lambdabot>     Couldn't match expected type `(a, b)'
11:54:17 <lambdabot>            against inferred type `(a1, b1) -> c'
11:54:17 <lambdabot>     In the first argument of `curry', namely `curry'
11:54:17 <ski> geheimdienst : because it has a type like `... -> (... -> ...)'
11:54:24 <crappygonzales> Twey: but i read that partial application also returns a function for applying the rest of the args
11:54:27 <mercury^> :t uncurry curry
11:54:27 <lambdabot> forall b b1 c. ((b, b1) -> c, b) -> b1 -> c
11:54:31 <Cale> So, compose (compose f g) h = \x -> compose f g (h x) = \x -> (\y -> f (g y)) (h x) = \x -> f (g (h x))
11:54:35 <Twey> I.E. it takes a function that takes both its arguments at once (in the form of a tuple) and converts it into a function that takes them one at a time, returning intermediate functions (a curried function)
11:54:38 <mercury^> :t uncurry uncurry
11:54:39 <lambdabot> forall a b c. (a -> b -> c, (a, b)) -> c
11:54:41 <geheimdienst> ski: yeah ok. that's what i suspected. thanks
11:54:51 <ski> crappygonzales : no, the curried function returns a new function, if you partially apply it
11:55:17 <crappygonzales> i never liked curry - my tongue hurts
11:55:18 <ponken> Hey, can someone explain to me why I get an error here? : http://pastebin.com/VESd4A9g
11:55:19 <crappygonzales> fuck Haskell
11:55:20 <mauke> I have copied your paste VESd4A9g to http://hpaste.org/49416 - pray I don't copy it any further.
11:55:34 <Cale> and, compose f (compose g h) = \x -> f (compose g h x) = \x -> f ((\y -> g (h y)) x) = \x -> f (g (h x))
11:55:39 <ski> crappygonzales : sometimes one stretches the terminology to say that if you have `g (x,y) = ..x..y..', then `\y -> g (17,y)' is a partial application of `g'
11:56:01 <crappygonzales> ski, from wikipedia: "In computer science, partial application (or partial function application) refers to the process of fixing a number of arguments to a function, producing another function of smaller arity."
11:56:03 <geheimdienst> crappygonzales: i feel your pain. it's never been really clear to me, and the haddock documentation for curry and uncurry is ridiculous
11:56:11 <Cale> shaunlippy: and so both compose f (compose g h) and compose (compose f g) h are equal to \x -> f (g (h x)) and so they are equal to each other
11:56:15 <ski> crappygonzales : similarly with `\x -> f x 945' (which can be written as  (`f` 945)  in haskell)
11:56:25 <crappygonzales> so wikipedia seems to think that partial application produces a function
11:56:31 <crappygonzales> which currying is supposed to do
11:56:34 <crappygonzales> i'm fekking confuzzled
11:56:45 <danharaj> You have a function (a, b) -> c
11:56:49 <cmccann> crappygonzales, currying converts a function taking arguments in one way to a function taking the same arguments in a different way
11:56:50 <danharaj> currying it gives you a function a -> b -> c
11:56:58 <shaunlippy> Cale: thanks - I'll go work that out on paper, but I think I get it.
11:57:02 <danharaj> partial application is applying the curried function to only the first argument
11:57:05 <danharaj> giving you a function b -> c
11:57:08 <ski> crappygonzales : well, maybe you're prefer saying "schnfinkel" instead of "curry" ? :)
11:57:10 <shaunlippy> crappygonzales: sorry for the 'dumbass question'
11:57:12 <cmccann> crappygonzales, partial application applies a function to some but not all of its arguments, and returns a function that takes the remaining arguments
11:57:14 <crappygonzales> it's sbahra !
11:57:28 <Cale> crappygonzales: Currying takes a function acting on tuples, and turns it into a function which produces another function. Partial application takes a function of multiple parameters, and applies it to some of those parameters to get a function of the rest.
11:57:30 <mauke> ponken: you can't pattern match like that
11:57:31 <crappygonzales> ski, haha
11:57:37 <sbahra> Hi crappygonzales
11:57:42 <ponken> What do you mean, mauke?
11:57:43 <crappygonzales> i don't like schonfinkeling either
11:57:50 <crappygonzales> sbahra: gr00ber here
11:57:52 <crappygonzales> wassup
11:57:53 <sbahra> Ah. <3
11:57:55 <mauke> ponken: zsimplify isn't a constructor
11:57:57 <sbahra> Glad to see you're well.
11:58:01 * cmccann points out that you can partially apply an uncurried function in some sense by putting a lambda around it, e.g. \(x, y) -> f (x, True, y)
11:58:03 <sbahra> Not much, lots of work. I have to get back to it.
11:58:12 <ponken> oh
11:58:17 <crappygonzales> kewl
11:58:32 <mercury^> :t let uncursy = (uncurry, uncursy) in uncurry uncurry uncursy
11:58:32 <lambdabot>     Occurs check: cannot construct the infinite type:
11:58:33 <lambdabot>       t = ((a -> b -> c) -> (a, b) -> c, t)
11:58:33 <lambdabot>       Expected type: t
11:58:36 <mauke> ponken: in a pattern, you either have a constructor (starting with an uppercase letter) or a variable (starting with a lowercase letter)
11:58:46 <crappygonzales> cmccann: yes, it returns a function, uh, like currying
11:58:52 <crappygonzales> fekkin aye
11:58:59 <Cale> crappygonzales: partial application involves specifying some of the inputs to the function, currying doesn't, it just transforms a function of tupled parameters into a function producing another function.
11:59:01 <ponken> How can I use the zsimplify output as a variable for absZ?
11:59:04 <mauke> ponken: constructors must match with the value; variables are bound to whatever is in that value
11:59:18 <crappygonzales> Cale: right
11:59:28 <Cale> crappygonzales: One way to partially apply a function is to first curry it and then apply it to one parameter.
11:59:29 <cmccann> crappygonzales, no, it returns a function taking fewer arguments. Currying just changes how the same arguments are provided.
11:59:36 <crappygonzales> yes
11:59:36 <crappygonzales> no
11:59:38 <crappygonzales> maybe
11:59:39 <mauke> ponken: do you mean something like: absZ x = realAbsZ (zsimplify x)?
11:59:41 <crappygonzales> *poof*
11:59:45 <Cale> :3
12:00:02 <ponken> I don't know, what is realAbsZ here?
12:00:18 <crappygonzales> a real mess
12:00:26 <mauke> ponken: a function you'd have to write
12:00:28 <mercury^> > fix (curry . uncurry) uncurry uncurry ((+), (3,4))
12:00:30 <ponken> I just wanted to give the output of zsimplify to absZ and then patter match
12:00:31 <lambdabot>   mueval-core: Time limit exceeded
12:00:33 <ski> crappygonzales : Currying : given a function turning `A',`B',`C' into `X', return a function taking `A' into a function taking `B' into a function taking `C' into `X'
12:00:38 <ski>   crappygonzales : Partial application : given a function turning `A',`B',`C' into `X', *and* a `B', return a function taking `A',`C' into `X'
12:00:40 <cmccann> crappygonzales, also, note that currying can be reversed, if you curry and then uncurry you get your same function back. Partial application can't be undone.
12:01:11 <mauke> ponken: well, my code gives the output of zsimplify to realAbsZ
12:01:20 <mauke> ponken: and you can use pattern matching in the definition of realAbsZ
12:01:32 <danharaj> crappygonzales: Try examples, it'll make you get it faster.
12:01:41 <Cale> :t curry
12:01:42 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
12:01:45 <ski> crappygonzales : one could say the first as `curry3 :: ((a,b,c) -> x) -> (a -> (b -> (c -> x)))' in haskell and the latter as `partiallyApply3_1 :: ((a,b,c) -> x,b) -> ((a,b) -> x)'
12:01:47 <crappygonzales> danharaj: nah
12:01:58 <Twey> crappygonzales: http://hpaste.org/49417
12:02:11 <ponken> I will see if I can do it mauke, thanks!
12:02:21 <geheimdienst> ski: i'm not sure how the signature of curry (curry :: ((a, b) -> c) -> a -> b -> c) fits together with the first part of your explanation ("given a function turning `A',`B',`C' into `X'")
12:02:35 <Twey> Aw, looks like hpaste doesn't do highlighting for literate Haskell?
12:02:35 <ski> crappygonzales : but one could also say `partiallyApply3_1 :: (a -> b -> c -> x,b) -> (a -> b -> x)' for the latter
12:02:41 <Cale> Partial application can be done for uncurried functions, it just requires a lambda
12:03:15 <shaunlippy> 3
12:03:35 <danharaj> I just noticed that windows in Windows have shadows :3
12:04:07 <crappygonzales> I FINALLY GET IT
12:04:09 <ski> crappygonzales : afaiu, the important difference is that with partial application, you're taking one function (curried or non-curried) *and* one (or more) inputs for it, and returning a (curried or non-curried) function
12:04:10 <Twey> Cale: Hm, true
12:04:11 <crappygonzales> http://hpaste.org/49419
12:04:21 <crappygonzales> ^ currying, my interpretation of what was said
12:04:33 <danharaj> @ops
12:04:33 <lambdabot> Maybe you meant: docs oeis pl
12:04:38 <Twey> Those people have very strange faces.
12:04:39 <ski> crappygonzales : while with currying, you're taking a *non-curried* function as input, and returning a *curried* function as output
12:04:44 <crappygonzales> i see
12:04:45 <ski> @type curry
12:04:45 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
12:05:04 <danharaj> ski: yhbt
12:05:32 <ski> crappygonzales : now note that `curry' can both be used to curry a (non-curried) function `f' : `curry f', and to partially apply a (non-curried) function `f' to `x' : `curry f x'
12:06:07 <crappygonzales> conclusion: i don't care about the distinction anymore, and just curries on
12:06:30 <crappygonzales> cuz' i'm the crappy gonazales
12:06:35 <crappygonzales> oh yeah baby
12:06:40 <Cale> :t uncurry
12:06:41 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
12:06:49 * ski eyes danharaj confusedly
12:06:56 <crappygonzales> also, i'm drunk so i'm taking a snapshot of the logs for later reading
12:07:01 <crappygonzales> ha
12:07:44 <ski> crappygonzales : <http://tunes.org/~nef/logs/haskell/11.07.23>
12:07:51 <crappygonzales> aye
12:08:05 * crappygonzales pops another carlsberg
12:08:52 <cmccann> @where ops
12:08:53 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
12:09:02 <cmccann> danharaj, that's what you wanted I think
12:09:05 <danharaj> @where Carmen_San_Diego
12:09:05 <glguy> ?
12:09:05 <lambdabot> I know nothing about carmen_san_diego.
12:09:13 --- mode: ChanServ set +o glguy
12:09:14 <mauke> cmccann: yes?
12:09:21 <danharaj> @interrogate lambdabot
12:09:21 <lambdabot> Unknown command, try @list
12:09:31 <danharaj> Not talking eh?
12:09:41 <danharaj> We'll see how uncooperative you are when we use THIS
12:09:48 * danharaj brandishes unsafeCoerce
12:09:55 <glguy> What are we responding to?
12:10:11 <mauke> nothing
12:10:12 <cmccann> mauke, eh? not sure what you're responding to
12:10:20 <mauke> can I kick cmccann?
12:10:29 --- mode: glguy set +o mauke
12:10:31 <glguy> why not?
12:10:32 <danharaj> someone linked to ASCII lesbian porn.
12:10:33 --- mode: glguy set -o glguy
12:10:37 <danharaj> Does that count? :p
12:10:48 * cmccann isn't sure what he has to do with this :?
12:10:51 <Twey> mauke: Why kick cmccann?
12:10:58 <mauke> cmccann: you highlighted me
12:11:02 <mauke> cmccann: well, all the ops
12:11:14 <glguy> crappygonzales: please don't link ascii porn
12:11:17 <cmccann> mauke, yes, because of crappygonzales trolling above
12:11:26 <cmccann> cf. ascii porn etc.
12:11:28 <Twey> crappygonzales made a joke involving ASCII porn.  cmccann thinks this is deserving of a kick.
12:11:51 <danharaj> It was rather non-sequitur for a joke.
12:12:51 <cmccann> actually danharaj was trying to get attention from an op, was just trying to help :\
12:13:10 <cmccann> which I assumed was because of the disruptive user
12:13:23 <danharaj> yeah, my bad. I pm'd one after I failed and they said they were ok with it, so I decided to let it go.
12:13:31 <cmccann> ah, ok
12:13:34 <cmccann> sorry about that then
12:15:22 * cmccann didn't mean to annoy people :[
12:15:42 <danharaj> pff everyone needs to be annoyed once in a while
12:22:25 <taotree> In this declaration, what does the "a b -> c , b c -> a" mean?
12:22:26 <taotree> class Upd1 a b c | a b -> c , b c -> a where upd1 :: a -> b -> c
12:22:51 <ski> those are two functional dependencies on the class
12:23:32 <ski> they mean that `forall a b. unique c. Upd1 a b c' and `forall b c. unique a. Upd1 a b c'
12:24:17 <taotree> so -> can read "implies". "Given a b there is a c. Given b c, there is an a"
12:24:28 <ski> while means that `forall a b c0 c1. (Upd1 a b c0,Upd1 a b c1) => c0 ~ c1' and `forall a0 a1 b c. (Upd1 a0 b c,Upd1 a1 b c) => a0 ~ a1' for the other one
12:25:00 <jonkri> is there a way to use parsec to apply a parsec function one to eight times, depending on how much is available?
12:25:05 <gwern> whoo. finally, a visit to my rss reader with no vandalism on hawiki!
12:25:13 <ski> so, for any two given types `A' and `B', there can be at most one type `C' with `instance Upd1 A B C'
12:25:16 <gwern> maybe the spammers have given up or I just blocked all their IPs
12:25:24 <ski> and, for any two given types `B' and `C', there can be at most one type `A' with `instance Upd1 A B C'
12:25:34 <ski> taotree : ok ?
12:25:41 * cmccann is briefly tempted to go add "hi gwern!" to random pages on hawiki
12:26:24 <gwern> cmccann: do that and I'll have the ops ban you here
12:26:46 <cmccann> gwern, yes, that's firmly in the category of things that are much funnier to imagine than actually do
12:27:20 <geheimdienst1> what's hawiki?
12:28:37 <gwern> geheimdienst: that haskell.org thingy some people use
12:28:45 <cmccann> geheimdienst, the haskell wiki which gwern spends a great deal of time keeping clean
12:29:14 <geheimdienst> oh i see ... *the* haskell wiki
12:29:33 <ski> hawiki is the old wiki. haskellwiki is the new wiki
12:31:20 <taotree> ski, thanks... that gets me started on the road to understanding :)
12:32:26 <gwern> ski: I've been trying to make the nomeclature a little more uniform by using hawiki for both, since most of hawiki was copied over to haskellwiki. and hawiki is much shorter
12:33:17 <cmccann> gwern, are you the only one on janitor duty there, or are other people helping? seems like you end up having to deal with a lot of crap :T
12:34:22 <gwern> cmccann: I'm pretty much the only one. sometimes people will revert an edit they notice or blank a page
12:34:52 <ski> taotree : btw, the term "functional dependency" is borrowed from database theory. to have a functional dependency from `a' and `b' to `c' for `Upd1 a b c' means that if you phrase `Upd1' as a relation from `a * b' to `c', then that relation is actually a partial function (the input determines the output, but there doesn't have to be an output for each input)
12:35:11 <taotree> ok
12:35:43 <cmccann> gwern, well, thanks for all the effort you put into it, then! kind of a thankless chore most of the time, I expect :[
12:36:19 <ski> (the old) hawiki has a special place in my heart ..
12:36:20 <gwern> cmccann: deeply frustrating, sometimes. the part that drives me nut is that the RSS feed shows every item *twice*. so I see each spam page twice and they're so similar I need to open up each lest I miss a page
12:36:42 <geheimdienst> gwern: thanks a great deal for your work. i'll drop by more often on http://haskell.org/haskellwiki/Special:Recentchanges , knowing that you're short-staffed
12:36:59 <gwern> geheimdienst: unless you're an admin, it's not actually that helpful
12:37:18 <gwern> other people vandal-fighting obscure what needs to be done and actually cost me time
12:37:23 <gwern> of course, I never tell them this
12:37:45 <gwern> what I need is another admin, but no one is willing to commit to *that* much
12:38:11 <cmccann> kinda surprising that nobody is willing to step up
12:38:28 <cmccann> there's a lot of people in the haskell community
12:38:59 <geheimdienst> i'm not an admin ... so it works differently than on wikipedia? normal users (even unregistered ones iirc) revert stuff on WP
12:39:16 <gwern> cmccann: a lot of people, but no one wants to do something so boring continuously for months and years. they'd rather code
12:39:54 <gwern> geheimdienst: true, but on en WP, vandalism takes the form of edits to existing pages. on hawiki, the vandalism takes teh form of new accounts creating new pages.
12:40:26 <cmccann> gwern, isn't there anything that can be done to make it harder to create new accounts? :T
12:40:29 <gwern> geheimdienst: all a regular user could do is blank the spam pages, which just clutters RC for me and makes it harder to see what to do (and as I said, I see everything twice so I'll see the clutter twice)
12:41:04 <gwern> cmccann: yes, but that requires mediawiki plugins and root on the box - ashley rarely ever has time for anything to do with hawiki, so I don't ask
12:42:03 <taotree> help with error: http://hpaste.org/49422
12:42:59 <monochrom> I don't understand how "value" can be both "a" and "Int"
12:43:02 <cmccann> taotree, your types don't match
12:43:09 <monochrom> and moreover "String"
12:43:14 <geheimdienst> so, suppose for non-admins there was a button "flag this for gwern" on wiki pages, or possibly on the "recent edits" page. would this be a step in the right direction?
12:43:16 <taotree> yeah... I think I'm trying to do something impossible
12:43:39 <gwern> geheimdienst: no. I know spam instantly when I see it, and as I said, I review all edits
12:43:44 <monochrom> it is like its author has 3 personalities
12:43:45 <gwern> geheimdienst: so what would the flag do?
12:43:47 <cmccann> you're probably trying to do something possible at the high level with an implementation that's completely impossible
12:44:09 <gwern> geheimdienst: what would be useful would be someone who says oh this is spam! and then deletes the page and indef blocks the user
12:44:18 <gwern> an admin
12:44:26 <cmccann> gwern, it would add it to your rss feed a third time, probably, since that seems to be the running theme :P
12:44:32 <gwern> indeed
12:44:56 <monochrom> perhaps firstly fix the rss duplication bug
12:50:45 <taotree> not impossible... type class solved it
12:52:36 <geheimdienst> among the options on http://haskell.org/haskellwiki/index.php?title=Special:Recentchanges is "Hide patrolled edits". anyone know what a patrolled edit is?
12:54:39 <Cale> http://www.google.ca/search?q=patrolled+edit+mediawiki&ie=utf-8&oe=utf-8&aq=t&rls=org.mozilla:en-US:official&client=firefox-a
13:02:35 <nomeata> Hi. I have a C library that I want to interface to using FFI, but I only have a static library (.a). How can I link to it?
13:03:28 <mauke> by using its name?
13:15:39 <copumpkin> cmccann: IMA KICK U
13:16:48 <cmccann> oh noes
13:17:35 <copumpkin> you'll be in boston soon, right?
13:18:17 <cmccann> most likely, but details are still undetermined
13:18:35 <cmccann> not in the next couple weeks if that's what you're thinking
13:18:52 <jonkri> how can i disable a pattern match overlapped warning? there is a guard in the first one, causing it to not always execute
13:23:11 <copumpkin> preflex_: seen dbelange
13:23:11 <preflex_>  dbelange was last seen on ##logic 9 minutes and 50 seconds ago, saying: > Butt
13:33:37 <erus`> whats the idiomatic way to represent a string/array of bytes?
13:33:45 <erus`> rather than chars
13:33:46 <kmc> ByteString
13:33:47 <lambdabot> kmc: You have 1 new message. '/msg lambdabot @messages' to read it.
13:34:11 <kmc> String = [Char] so the direct analogue is [Word8]
13:34:14 <Twey> erus`: (from the bytestring package)
13:34:23 <erus`> cheers
13:34:24 <kmc> but ByteString is a lot more efficient
13:34:32 <kmc> the text analogue of ByteString is Data.Text from the 'text' package
13:34:53 <Twey> I try to use Text instead of String these days
13:35:30 <monochrom> Text is suitable for Unicode text, yes
13:35:33 <kmc> yeah, i go back and forth between "premature optimization is the root of all evil" and "linked lists are soooo inefficient"
13:36:00 <kmc> the mission of Unicode is to make "Unicode text" a redundant phrase
13:36:02 <monochrom> otoh ByteString is fine if you're agnostic to what the bytes mean, even if they mean text
13:36:13 <Eliel> if I want to use the types to guarantee that a list will never be empty, is my only option to define my own list type?
13:36:25 <kmc> Eliel, or use (a,[a])
13:36:35 <kmc> defining your own type is probably better
13:37:00 <monochrom> an irc logger is probably better off using ByteString and not try to decode-encode the bytes, for example
13:37:16 <cmccann> kmc, linked lists are fine if they're used lazily enough
13:37:20 <kmc> yeah
13:37:33 <cmccann> it's just that it's pretty rare to actually want a lazy list of characters
13:37:42 <cmccann> doesn't fit most uses of text strings
13:37:42 <kmc> lists are control-flow structures, not data structures :)
13:38:02 <kmc> laziness unifies control and data the way relativity unifies energy and mass
13:38:12 <erus`> importing ByteString is fucking up all my IO code
13:38:17 <cmccann> yes, lazy lists are basically reified for loops
13:38:20 <kmc> erus`, import qualified ByteString as B
13:38:23 <Lymee> I didn't end up posting my password in here, did I? The graphics driver died, and I flailed around blindly trying to "sudo /etc/init.d/gdm restart"
13:38:30 <erus`> ah i missed the qualified bit
13:38:33 <kmc> Lymee, check the logs
13:38:34 <kmc> see /topic
13:38:44 <kmc> erus`, or you can import not-qualified
13:38:47 <kmc> and import Prelude as P
13:38:56 <kmc> and say P.putStr vs B.putStr
13:39:03 <kmc> i prefer uniform qualification though
13:39:24 <monochrom> "hi, my program processes lists and it's using 100 GeV of memory, is that normal? can I reduce it?"
13:39:40 <gwern> Lymee: looking through my IRC logs, I don't see anything
13:39:47 <Lymee> Okey.
13:39:52 <kmc> physicists just like eV because it makes what they do sound impressive ;)
13:39:52 <gwern> monochrom: 100 what?
13:40:01 <monadic> monochrom: Well, it depends on how many items are in that list...
13:40:23 <monochrom> heh gwern, see kmc's relativity comment :)
13:41:46 <cmccann> monochrom, I don't think GeV is a valid unit of memory, you probably wanted GeV/K
13:42:12 <kmc> cmccann++
13:42:38 * cmccann thinks kmc got the joke
13:43:59 <sheeple> is there some straight forward way to create some kind of inequality constraint? I have some class Foo x y t and I need some instance when (x ~ y) en some (specific other) instance when x not equal to y
13:44:17 * hackagebot lio-eci11 0.1 - Labeled IO library  http://hackage.haskell.org/package/lio-eci11-0.1 (AlejandroRusso)
13:44:31 <copumpkin> cmccann: ah, damn
13:44:33 <sheeple> but I get some undecidable instances that I can't seem to fix with throwing in some random functional dependencies and type constraints
13:44:38 <copumpkin> cmccann: boston haskell should be coming up soon
13:44:44 <kmc> sheeple, that's not really how type classes work
13:45:07 <kmc> there's no backtracking
13:45:14 <sheeple> hhm
13:45:17 <cmccann> copumpkin, yes, edwardk was going to try to get things lined up to match but ended up not being viable
13:45:31 <kmc> with OverlappingInstances you can have «instance Foo x x» and also «instance Foo x y»
13:45:41 <kmc> sheeple, what are you trying to do?
13:45:51 <copumpkin> sheeple: wake up!
13:46:12 <cmccann> sheeple, depending on what you're trying to do it might be possible using lots of scary hacks that nobody likes and may break in future versions of GHC
13:46:17 * hackagebot lio-eci11 0.2 - Labeled IO library  http://hackage.haskell.org/package/lio-eci11-0.2 (AlejandroRusso)
13:46:49 <Cale> mol eV
13:47:06 <sm__> I'm using cmdargs' explicit annotation.. now how do I specify the one-letter flag ?
13:47:32 <cmccann> sheeple, are you sure that what you're doing really needs to select an instance that way?
13:47:46 <sheeple> as an excersise I was trying to define a class with a compose function (>>>) that composes (a -> b) and (d -> c) if (b ~ d) but also composes them if b ~ m d for some monad m
13:47:58 <kmc> :(
13:48:05 <sheeple> trying to merge kleisli and normal composition ;P
13:48:12 <kmc> i think that will not end well
13:48:16 <sheeple> thought so
13:48:17 <cmccann> sheeple, I suspect that won't work
13:48:24 <Cale> sheeple: That won't work because they overlap.
13:48:38 <kmc> ultimately, those are two different functions that do different things
13:48:39 <sheeple> it works for some specific type annotations
13:48:43 <kmc> they should have different names
13:48:59 <kmc> type classes are a way of resolving such things but only in narrow circumstances
13:49:21 <sheeple> but I was hoping for the additional constraint c /~ d to seperate the two cases
13:49:22 <cmccann> Cale, it would work if only applied to sufficiently non-polymorphic types
13:49:27 <sm__> let me rephrase that: I have several options beginning with the same letter, so cmdargs doesn't create a single-letter version for any of them. Can I explicitly do that ?
13:50:18 <sheeple> kmc: yeah, probably true, but just figuring out stuff what I can and can't do, nothing for use in Real Life
13:50:28 <kmc> cool :)
13:51:03 <sm__> woah, I use name, and it keeps the long version as before (based on the record definition ?). cmdargs is magic
13:51:13 <sheeple> but when one instance is only generated when b ~ d and the other only when b /~ d then they shouldn't overlap, right?
13:51:16 <kmc> cmdargs is magic, yes
13:51:23 <kmc> the "implicit" mode is a bit too magic for my taste
13:51:23 <erus`> @hoogle a -> Int
13:51:24 <lambdabot> Data.Generics.Schemes gdepth :: GenericQ Int
13:51:24 <lambdabot> Data.Generics.Schemes glength :: GenericQ Int
13:51:24 <lambdabot> Data.Generics.Schemes gnodecount :: GenericQ Int
13:51:25 <copumpkin> dark magic
13:51:26 <sheeple> then I just need to figure out how to express b /~ d
13:51:29 <cmccann> sheeple, the problem is when you have polymorphic types floating around
13:51:29 <kmc> sheeple, instances don't work that way
13:51:52 <kmc> sheeple, an instance is found based *only* on the head, not the context
13:51:52 <sm__> I'm fine with the magic for now; I'd like to know how it's going to bite me though
13:51:58 <erus`> @hoogle Char -> Int
13:51:58 <lambdabot> Data.Char digitToInt :: Char -> Int
13:51:59 <lambdabot> Data.Char ord :: Char -> Int
13:51:59 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
13:52:08 <cmccann> sheeple, what you want would probably work if everything was a monomorphic type but you'd be surprised how often that's not the case
13:52:18 <erus`> @hoogle fromEnum
13:52:19 <lambdabot> Prelude fromEnum :: Enum a => a -> Int
13:52:25 <kmc> sheeple, then you check the context.  if it can't be resolved then you fail.  no backtracking
13:52:47 <sheeple> hhm ok
13:52:51 <erus`> @hoogle Char -> Integer
13:52:52 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
13:52:52 <lambdabot> Prelude floatRadix :: RealFloat a => a -> Integer
13:52:52 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
13:52:52 <kmc> so «instance (a ~ b) => Foo a b» and «instance (a /~ b) => Foo a b» would overlap in 100% of cases and one or the other would never get used
13:52:59 <kmc> in fact GHC may reject that even with OverlappingInstances
13:53:17 <cmccann> sheeple, type equality can sorta-kinda be checked for monomorphic types, but only with the horrible hacks I mentioned
13:53:27 <kmc> oleg-level hacks?
13:53:34 <erus`> No instance for (Integral Char) ????
13:53:39 <kmc> type classes look like a relational / logic programming system, and much is said to encourage the comparison, but at the end of the day they aren't at all
13:53:47 <erus`> how do i coerc Char to Integer?
13:53:49 <cmccann> not so much oleg-level hacks as oleg's code, full stop
13:53:50 <sheeple> ok
13:53:57 <kmc> erus`, fromIntegral . fromEnum
13:54:01 <kmc> or Data.Char.ord
13:54:09 <kmc> erus`, assuming you want the Unicode codepoint value
13:54:14 <kmc> also, "coerce" is not the right term
13:54:15 <cmccann> kmc, fundeps : prolog :: brainfuck : C
13:54:17 <kmc> you're converting
13:54:20 <sheeple> so equality is only semi decidable (in the implementation)?
13:54:21 <kmc> heh cmccann
13:54:27 <kmc> i would like to see a backtracking classes extension for GHC
13:54:31 <erus`> kmc i want the  byte value so 'a' = 47 or whatever
13:54:31 <kmc> i don't know what other implications this would have
13:54:41 <kmc> erus`, most characters do not have a "byte value"
13:54:46 <kmc> in that their Unicode codepoints are greater than 255
13:54:47 <cmccann> kmc, I'd rather just see better support for sensible type-level computation
13:55:04 <kmc> yeah
13:55:06 <cmccann> most uses for backtracking are hacks that could be written more sensible in a direct fashion
13:55:07 <sheeple> kmc: is there a fundamental reason why it couldn't work in the general case? or is this just a problem of how ghc performs resolution?
13:55:11 <kmc> or more sensible metaprogramming
13:55:15 <monadic> erus`: If you want that you might as well use ByteString's Word8 interface.
13:55:16 <kmc> sheeple, well, it's in the spec that it works this way
13:55:23 <erus`> errrr im only dealing with chars 0-9 ++ a-Z
13:55:29 * ski wonders how much more like an LPL type classes could be made, in a useful fashion
13:55:34 <kmc> erus`, okay
13:55:47 <kmc> so the values you get will always be under 256
13:55:55 <sheeple> kmc: sure, but just dreaming here... might a relaxing extension be possible?
13:55:56 <cmccann> sheeple, I vaguely recall there being pragmatic but not fundamental reasons
13:55:58 <kmc> but yeah, if you're doing binary IO you should not go through Char
13:56:11 <kmc> sheeple, right, I was just speculating about that.  i don't know if it's possible or what the other implications would be
13:56:21 <kmc> i will ask #ghc
13:56:22 <cmccann> sheeple, adding backtracking would be much more than a "relaxing" I think
13:57:36 <cmccann> sheeple, but really you're firmly in territory that's not well supported, so the question is do you want to learn how to use scary hacks, or just find some other approach
13:58:15 <cmccann> sheeple, if you're really interested to know what the limits are and how things interact, I encourage (in all seriousness) jumping in the deep end and looking at how oleg's trickery works
13:58:22 <sheeple> cmccann: I want to understand the problem and then decide weither I find it a hack or wether I want to unhack it ;)
13:58:39 <cmccann> sheeple, cf. http://okmij.org/ftp/
13:59:05 <cmccann> he's pretty much the grand master of type-level metaprogramming hackery
14:00:04 <sheeple> cmccann: ok, thanks, I will look into that
14:00:23 <sheeple> but I guess I'd better start on some general type theory book first
14:00:29 <sheeple> so I'll be back in a few month ;)
14:00:33 <cmccann> sheeple, nah, don't bother
14:00:38 <cmccann> I mean, if you want to, sure
14:00:59 <cmccann> but this is mostly hackish workarounds based on quirks of GHC
14:01:15 <cmccann> the type theory solution would be "just have a type system that supports this stuff properly"
14:01:29 <cmccann> which in practical terms here probably translates to "use agda"
14:02:06 <sm__> I'm fine with the magic for now; I'd like to know how it's going to bite me though
14:02:13 <sm__> oops
14:02:25 <sm__> drat you erc
14:02:30 <sheeple> ok
14:03:09 <Saizan> agda's version of typeclasses (quite experimental) has an "instance resolution" which doesn't even allow contexts for instances :)
14:03:35 <cmccann> :r
14:03:37 <cmccann> errrrgh
14:03:41 <cmccann> wrong window, this isn't ghci
14:03:53 <sheeple> atleast it wasn't your password
14:04:03 <cmccann> already did that once
14:04:06 <aninhumer> unless errrrgh is his password
14:05:00 <erus`> wake up sheeple!
14:05:11 <aninhumer> *their (just making sure to be gender neutral)
14:05:25 <sheeple> erus`: hhm?
14:05:33 <erus`> :P
14:05:48 <sheeple> why does everybody seem to be thinking I'm sleeping? ;p
14:06:03 <cmccann> sheeple, how do you know you aren't
14:06:26 <sheeple> I've been known to have had microsleep moments ;P
14:06:38 <homie> cause i wear pyjamas on the streets!
14:06:44 <homie> lol
14:07:29 <homie> and greet my bankers in that suit!
14:07:30 <homie> lol
14:07:56 <sheeple> ah well
14:07:58 <sheeple> I'm afk
14:08:05 <sheeple> thanks for your input, everyone!
14:15:28 <flonum> How can I discover a fusion law for foldr1?  Just replacing foldr by foldr1 in (f . foldr g = foldr h) fails in the base case (x:[]) unless f x = x, which seems pointless ...
14:16:10 <kmc> foldr1 f [x] = ⊥ no?
14:16:30 <kmc> > foldr1 (+) [3]
14:16:31 <lambdabot>   3
14:16:33 <kmc> oh, right
14:16:51 <kmc> > foldr1 (+) [x,y,z]
14:16:52 <lambdabot>   x + (y + z)
14:16:53 <flonum> off-by-one ...
14:16:53 <Twey> foldr1 f [] = ⊥
14:17:14 <kmc> foldr1 f xs = foldr f (last xs) (init xs)
14:18:36 <dolio> Thankfully that isn't the definition.
14:19:46 <Twey> Heh
14:19:59 <Twey> @src foldr1
14:19:59 <lambdabot> foldr1 _ [x]    = x
14:19:59 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
14:19:59 <lambdabot> foldr1 _ []     = undefined
14:23:36 <erus`> whatsa a cross platform way to write a progress percentage to the console, that writes over itself? will using \b work?
14:25:36 <kmc> erus`, I've never seen a platform where that doesn't work
14:25:52 <kmc> i'm sure there are non-default tty modes on unix where it doesn't
14:26:07 <kmc> the only alternatives i can think of are very heavy (curses / vty)
14:26:18 <erus`> yeah but curses is posic
14:26:20 <erus`> x*
14:26:39 <kmc> you can get curses for windows
14:26:50 <cmccann> how to do Task X in a cross platform way: install Platform A. Do Task X in the way that works on Platform A.
14:26:52 <cmccann> never fails
14:26:54 * ski . o O ( pozic )
14:29:41 <parcs> ansi-terminal
14:31:23 <mietek> ld: warning: PIE disabled.
14:31:57 <cmccann> mmm, pie
14:32:10 <mietek> Precisely
14:32:24 * ski hates weebl-'n-bob
14:35:06 <wli> Headphones beeped. I presume that means the battery's dying.
14:40:22 * hackagebot csv-enumerator 0.9.2 - A flexible, fast, enumerator-based CSV parser library for Haskell.  http://hackage.haskell.org/package/csv-enumerator-0.9.2 (OzgunAtaman)
14:44:49 <JoshTriplett> I'd like to write something similar to git's "go up directories until you find a .git directory".  How do I know when to stop, portably?
14:44:59 <JoshTriplett> I don't know a portable way to say "I've hit /"
14:45:36 <JoshTriplett> Not that I know if this code will work on Windows at all, but I'd like to not *intentionally* write non-portable code...
14:47:42 <parcs> JoshTriplett: check whether the directory changed after a cd ".." ?
14:48:13 <JoshTriplett> parcs: 1) I don't actually want to chdir here, just build up a string of the form "../../..", and 2) how would I check if the directory changed? ;)
14:48:28 <Saizan> JoshTriplett: http://www.haskell.org/ghc/docs/latest/html/libraries/filepath-1.2.0.0/System-FilePath-Posix.html#v:splitPath
14:48:35 <JoshTriplett> I guess I could check if canonicalizePath foo == canonicalizePath (foo </> "..")
14:49:02 <ski> @hoogle canonicalizePath
14:49:03 <lambdabot> System.Directory canonicalizePath :: FilePath -> IO FilePath
14:49:10 <JoshTriplett> Saizan: Are you suggesting isRoot path = splitPath path == [] ?
14:50:32 <siracusa> When trying to build package network-fancy I get the following error: http://hpaste.org/49426  Any ideas?
14:50:42 <Saizan> JoshTriplett: more like pathsToTry currentPath = reverse . map (</> ".git") . map joinPath . inits . splitPath $ currentPath
14:51:53 <JoshTriplett> Saizan: That sounds promising.
14:53:08 <Eelis> > let _ = () where { foo = id; (foo -> _) = () } in () -- what's wrong with this? why isn't foo in scope?
14:53:09 <lambdabot>   Not in scope: `foo'
14:53:51 <Saizan> i guess map f . inits can be rewritten with scanl
14:54:11 <ben> is that a view pattern?
14:54:14 <Eelis> yes
14:55:00 <parcs> Eelis: what is (foo -> _) = () ?
14:55:02 <ski> Eelis : complain on the ghc list
14:55:08 <Eelis> parcs: a view pattern
14:55:13 <Eelis> ski: hmm
14:55:32 <ski> parcs : match `()' with `(foo -> _)', which passed `()' to `foo' and matches the result with `_'
14:55:43 <parcs> > let _ = () where { foo = id; f (foo -> _) = () } in ()
14:55:43 <lambdabot>   ()
14:55:48 <parcs> :)
14:56:08 <parcs> Eelis: what is (foo -> _) = () ?
14:56:12 <Eelis> oh, it's a documented restriction. they say "We may lift this restriction in the future; the only cost is that type checking patterns would get a little more complicated."
14:56:13 <parcs> oops
14:56:25 <ski> > let foo = id where (foo -> _) = () in ()
14:56:26 <lambdabot>   ()
14:56:26 <kmc> x matches (f -> p)  iff  (f x) matches p
14:56:26 <Eelis> bah
14:56:56 <ski> Eelis : how is the restriction phrased ?
14:57:34 <Eelis> ski: oh, the restriction actually only seems to apply to mutually recursive bindings, so i'm at a loss again
14:57:38 <Eelis> ( http://www.haskell.org/ghc/docs/6.10.1/html/users_guide/syntax-extns.html )
14:58:56 <parcs> ski: yeah i was first looking at it as a function binding, which confused me
15:00:19 <ion> > let f (map toUpper -> xs) = xs in f "foo"
15:00:20 <lambdabot>   "FOO"
15:00:37 * parcs will think a little more before he speaks
15:00:39 <ski> parcs : it can be useful like e.g. `(memo -> fib) = \n -> case n of 0 -> 0; 1 -> 1; n -> fib (n-1) + fib (n-2)'
15:01:09 <Eelis> i guess i'll ask in #ghc whether it's a bug or a feature
15:01:45 <ski> Eelis : i would expect that that view patterns work in non-function-bindings at all is an implementations artefact, and not planned :)
15:01:53 <ski> it can still be useful, though :)
15:03:40 <Eelis> not planned? it's just a context for patterns. it would be stupid if for no good reason view patterns didn't work for these patterns
15:04:17 <ski> i agree
15:04:35 <ski> but i would expect `(memo -> fib) n = ..n..' to work, which it doesn't
15:04:51 <ski> so i still assume it's not really planned
15:05:03 <Eelis> that's just because you can't have a pattern there. doesn't have anything to do with view patterns
15:05:37 <ski> why can't you have a pattern there ?
15:05:51 <Eelis> i didn't make the rules :) look at the language grammar
15:06:07 <ski> you can say `f x y = ...', where `f x' is compound, so it could reasonably include things like `(memo -> fib)' as well
15:06:25 * hackagebot shpider 0.2 - Web automation library in Haskell.  http://hackage.haskell.org/package/shpider-0.2 (OzgunAtaman)
15:07:03 <monochrom> (memo -> fib) = blah is a special case of "pattern = expression"
15:07:05 <Eelis> ski: i think f in `f x y = ...' is simply not a context where the language grammar permits patterns, in which case view patterns don't even come into it
15:07:22 <Eelis> monochrom: exactly
15:07:50 <monochrom> whereas (memo -> fib) n = blah looks like "pattern pattern = expression" which is nowhere to be found in standard haskell or ghc haskell
15:07:50 <Eelis> but once you commit to defining a function with parameters, the function name itself cannot then be a pattern again
15:08:40 <ski> i.e. `funlhs' in <http://www.haskell.org/onlinereport/decls.html#sect4.4.3> could reasonably (imho) allow view patterns (and `@'-patterns)
15:09:05 <ski> there's two difference senses of patterns, here
15:09:07 <Eelis> that would be a way bigger language change that goes far beyond view patterns
15:09:48 <monochrom> oh sure, funlhs -> var apat -> var viewpattern. but not funlhs -> var apat -> viewpattern apat
15:11:46 <monochrom> I am not even sure what "pattern pattern = blah" is supposed to mean, much less "viewpattern pattern = blah"
15:11:47 <ski> `of course in the `<funlhs>' case it would be `( <exp> -> <funlhs> )' instead of `( <exp> -> <pat> )'
15:13:21 <monochrom> so like "f (g -> h x) = y"?
15:13:43 <mm_freak> is it just me, or has hackage really become very slow?
15:14:43 <monochrom> not slow here, but I'm just viewing individual pages, not doing "cabal update"
15:14:56 <ski> monochrom : no, like `(g -> h x) y = ...'
15:15:27 <mm_freak> monochrom: i mean the webpage
15:15:27 <ski> (that would be equivalent to `h x = g (\y -> ...)', naturally)
15:16:15 <monochrom> not naturally
15:18:30 <ski>        (g -> h x) y = ...
15:18:34 <ski>   <=>  (g -> h x) = \y -> ...
15:18:39 <ski>   <=>  h x = g (\y -> ...)
15:18:41 <ski>   <=>  h = \x -> g (\y -> ...)
15:18:47 <ski> what's not natural about that ?
15:19:29 <ski> (that middle step is how i understand view patterns in general)
15:23:23 <hatds> can cabal auto install all your old packages after installing a new version of ghc?
15:24:18 <monochrom> "cabal install world" may do that. or may install too many packages and become a breakage
15:24:55 <monochrom> it is really history rather than world
15:26:23 <hatds> hmm, so I take it I have to ghc-pkg dump from the old ghc first?
15:27:34 <Philippa> signs you may be a little crazy: you attempt to give an intro to haskell in 20 minutes in a barcamp slot
15:27:51 <Philippa> aimed at people who have a background of "have done a little basic algebra"
15:27:51 <hpc> haha, like that will ever go well :P
15:28:09 <hpc> i can't introduce haskell in two hours to CS majors
15:28:09 <kmc> i don't imagine such a thing teaching anyone Haskell, but i could imagine it getting them interested enough to learn on their own
15:28:12 <Philippa> signs you're not /that/ crazy: 10 minutes after the end of the slot you're kicked off the projector by the organiser and people want to hear more
15:28:41 <Philippa> unhappy thing: I'll probably not be at the second half of the barcamp tomorrow. Oh well.
15:29:07 <monochrom> 20 minutes is better off with a whirlwind tour rather than an intro. but perhaps you did that.
15:29:07 <hpc> heh, i tried teaching a guy who does mostly C programming
15:29:23 <hpc> and started by showing off with the fixed-point implementation of the fibonacci sequence
15:29:30 <hpc> the look on his face was priceless
15:30:01 * geheimdienst goes for the 20-month intro to haskell
15:30:12 <kmc> teach yourself programming in 10 years
15:30:34 <hpc> man, even 10 years from now, i don't think i will ever feel like i really learned haskell
15:30:45 <dolio> Really?
15:33:44 <Saizan> depends what you consider Haskell, in 10 years i'm sure they are going to add new extensions
15:34:04 <siracusa> Is there a way to get the GHC minor version from a cpp macro like __GLASGOW_HASKELL__?
15:34:14 <mm_freak> hpc: write a complete networking application
15:34:59 <Philippa> monochrom: I did an "intro" with a very strong "haskell is just algebra" theme
15:35:30 <Philippa> having titled it "Functional Programming for people with GCSE maths aka Haskell for everyone"
15:35:39 <mm_freak> hpc: seriously, do it…  haskell is no magic, once you start /really/ using it, not just experimenting with it
15:35:43 <Philippa> it was also an asspull notepad-and-ghci-on-the-fly session
15:35:57 <ion> Haskell is unjust algebra
15:36:09 <mm_freak> cojust coalgebra
15:36:26 <Philippa> I got a philosophy student show up
15:36:33 <Philippa> ooops, er, psychology
15:36:38 <Philippa> he was actually pretty interested
15:37:24 <Jetbeard> Philippa: where was this?
15:37:27 <Jetbeard> it sounds pretty awesome
15:37:35 <Philippa> Jetbeard: barcamp nottingham
15:37:45 <Philippa> no slides and I didn't log the typing :-)
15:37:45 <hpc> mm_freak: i don't mean the language, so much as understanding everything i can do with it
15:37:56 <ski> you should have pointed him to this channel -- though i'd assume he's never heard of IRC
15:38:02 <mm_freak> hpc: that's what i mean, too
15:38:02 <hpc> in java, you learn for about a year, then everything from then on is "design patterns"
15:38:24 <kmc> hpc, right, well, "everything you can do with it" is "all computable functions"
15:38:25 <kmc> same as Java
15:38:28 <geheimdienst> hpc: what is that fixpoint fibonacci thingy you mentioned earlier?
15:38:33 <hpc> kmc: you know what i mean ;)
15:38:56 <kmc> the reason Haskell seems to have all this depth is that people get excited about the things you can do and talk about it here
15:39:15 <mm_freak> hpc: you can use it for all sorts of things…  i have written web sites, all kinds of networking applications and right now i'm starting to write simulations
15:39:30 <hpc> geheimdienst: just a definition of fibs in terms of fix
15:39:31 <Philippa> whereas in haskell we don't use the term so we abstract the patterns out as individuals with less group effort to name and codify anything you can't do so formally
15:39:32 <kmc> you can do lots of things in Java too but people don't find it as interesting to just go on IRC and talk about Java applications all day
15:39:43 <Philippa> that's not always a good thing
15:39:52 <hpc> mm_freak: i know, i have a haskell website, written from scratch with no dependencies outside base
15:39:54 <mm_freak> problem with haskell is that a lot of people love to talk about it, but only few of them actually do something with it
15:40:09 <mm_freak> hpc: what i'm talking about is rapid web development
15:40:11 <kmc> mm_freak, yep.  the more time i spend on #haskell the less Haskell i do
15:40:13 <Philippa> mm_freak: eh, I have an excuse. I don't do much of anything :p
15:40:21 <mm_freak> Philippa: ;)
15:42:09 <mm_freak> hpc: haskell is actually very good at rapid web development…  try one of the existing web frameworks instead of doing everything by yourself
15:42:26 <mm_freak> doing everything yourself you cannot learn much more than the language syntax and semantics
15:42:30 <hpc> mm_freak: i will when doing it myself stops being fun :D
15:42:40 <siracusa> Or maybe someone knows another solution, I want a module only being included with a certain GHC (minor) version.
15:43:00 <kmc> siracusa, presumably major,minor pair?
15:43:06 <monochrom> who knows, perhaps hpc has an existing framework too
15:43:12 <siracusa> kmc: Yes
15:43:16 <hpc> ive been building html in a compositional style so far
15:43:29 <hpc> so a document with header would be "html . body . h1 $ "title""
15:43:30 <kmc> #if __GLASGOW_HASKELL__ >= 605
15:43:39 <kmc> (from ByteString.Internal source)
15:43:50 <hpc> thinking of jumping straight off the deep end and using Cont
15:43:57 <siracusa> What version would that be?
15:44:05 <kmc> 6.5 i think
15:44:12 <kmc> this should be in the GHC manual
15:44:14 <yitz> hpc: so you're using the classic Text.Html?
15:44:14 <kmc> (doesn't mean it is)
15:44:29 <mm_freak> hpc: that's all great, but still i really recommend trying to do something /fast/ by using available tools
15:44:50 <yitz> hpc: or you're re-inventing that wheel too?
15:45:00 <mm_freak> that way you learn your tools and their value
15:45:19 <hpc> yitz: more, learning why that wheel was invented the way it was
15:45:21 <siracusa> kmc: Oh, then I want the sub-minor version, like in GHC 6.10.4 but not in previous versions and not in GHC 6.12
15:45:30 <mm_freak> be it language extensions, design patterns (iteratees, concurrency, FRP, etc.) or simply libraries
15:45:33 <hpc> for a while, i had accidentally written blazehtml
15:45:37 <kmc> oh, idk then
15:45:45 <yitz> hpc: ok that's sounds worthwhile.
15:45:58 <yitz> s/'s//
15:47:34 <monochrom> http://www.haskell.org/ghc/docs/7.0-latest/html/users_guide/options-phases.html#c-pre-processor
15:47:58 <hpc> mm_freak: i do rapid web dev at work, with perl, and it's fun but not something i want to do with my spare time
15:48:00 <yitz> hpc: the ShowS style is a great way to see the power of combinators
15:48:38 <yitz> hpc: although it isn't as important as it used to be as a pretty-printer, as we move away from String.
15:48:50 <monochrom> the 4 in 6.10.4 may be unavailable altogether
15:49:32 <monochrom> but then, this is when you start looking at the version number of base!
15:50:13 <geheimdienst> couldn't you use the *.cabal file to detect the version and pass it to the code via some define?
15:50:30 <yitz> write perl while employed or die "unemployed";
15:50:43 <hpc> haha
15:51:40 <monochrom> I forgot whether cabal tells you ghc version, but it certainly tells you package versions, though indirectly, i.e., inequality macros "\x -> is base bigger than x?"
15:51:50 * ski ponders making a wiki page for how to write `showsPrec' implementations properly, using precedences
15:52:04 <Jetbeard> please do, ski
15:52:06 <ion> That would be cool.
15:52:28 <ski> (which would entail me finding out exactly what the proper way is, of course)
15:52:40 <ion> Haven’t needed that so far, but i’m sure that would be useful some day.
15:53:05 <mm_freak> hpc: yes, but to a haskell programmer, rapid web dev in perl is not 'interesting' ;)
15:53:12 <geheimdienst> i have a signed statement from haskell curry himself that says he has no clue what the readsPrec and showsPrec stuff even is
15:53:35 <hpc> mm_freak: some of it is
15:53:44 <ski> modulo precedences, it's not that hard
15:53:49 <hpc> as hacky as perl is, the type system has some interesting consequences
15:53:57 <hpc> especially how arrays and hashes interact
15:54:03 <dolio> ski: It's pretty easy.
15:54:11 <kmc> i feel perl is actually untyped
15:54:18 <yitz> geheimdienst: yeah those have got to go in some forthcoming version of Haskell'
15:54:20 <kmc> because it will do its damndest to make any pair of types "compatible"
15:54:25 <hpc> it's barely-typed
15:54:49 <siracusa> monochrom: Unfortunately, the base version doesn't seem to have changed from 6.10.3 to 6.10.4
15:54:50 <hpc> it has issues with some things, and it is really obnoxious about the difference between strings and numbers
15:54:51 <ski> dolio : yeah. the problem is i can never remember where i should increment precedences -- i have to rediscover how the derived implementations does it every time
15:55:07 <mm_freak> kmc: PHP is much worse in that regard
15:55:30 <kmc> really?
15:55:38 <mm_freak> one of its worst weaknesses is that '==' in PHP will compare anything to anything…  i remember perl not being that bad
15:55:42 <kmc> yeah
15:55:55 <hpc> in perl, (==) is numeric equality only
15:55:59 <yitz> kmc: it's definitely typed, because internally it is, and there is no way to do any serious perl programming without understanding that.
15:56:02 <hpc> and eq is for stringy equality
15:56:03 <Wild_Cat> PHP also has that issue where you can use undefined variables and constants, too.
15:56:20 <kmc> Haskell is actually one of few languages where  true == "true"  is a type error
15:56:22 <yitz> kmc: which makes all those automatic coersions even more annoying than if it were untyped.
15:56:32 <kmc> even many "statically typed" languages allow it via some kind of implicit conversion
15:56:36 <kmc> yitz, yeah
15:56:44 <Wild_Cat> and where undefined constants evaluate to their name as a string. Leading to the very fun bug of "for($i = 0; i < 10; $i++)" being an infinite loop;
15:57:14 * cmccann thinks some languages should be categorized as "anti-typed", in that they will use available type information to deliberately screw you over
15:57:33 <ion> heh
15:57:39 <kmc> haha
15:57:49 <parcs> Wild_Cat: and also an infinite stream of warnings
15:57:52 <kmc> Wild_Cat, ....what?
15:57:56 <hpc> haha
15:57:57 <kmc> how... what? why?
15:58:02 <kmc> why would they?... what?
15:58:05 <yitz> > let true == "true" in true -- hey kmc, this is not a type error
15:58:06 <lambdabot>   <no location info>: parse error on input `in'
15:58:06 * kmc head explode
15:58:09 <dolio> ski: You need to parenthesize if you're in a context with higher precedence, so you should increment the side against your fixity, I think.
15:58:16 <hpc> cmccann: python!
15:58:20 <ion> I’m sure any decent PHP programmer knows how to silence the annoying warnings.
15:58:25 <hpc> try sending information over python sockets
15:58:31 <geheimdienst> @remember cmccann some languages should be categorized as "anti-typed", in that they will use available type information to deliberately screw you over
15:58:32 <lambdabot> Nice!
15:58:35 <dolio> If you're infixl, you increment on the right.
15:58:37 <yitz> > let true = False in true == "true" -- hey kmc, this is not a type error
15:58:37 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
15:58:37 <lambdabot>         against inferred type ...
15:58:44 <ion> @tell lambdabot welcome back
15:58:44 <kmc> yeah yitz you got me
15:58:44 <lambdabot> Nice try ;)
15:58:48 <yitz> oops, type error :)
15:58:50 <kmc> i meant True in the case of languages where it's spelled that way
15:58:56 <Wild_Cat> kmc: there's a missing $ in the $i < 10 test. So, i < 10 compares the constant i to 10. Since i is undefined, it evaluates to "i", and for some reason, in PHP, "i" < 10 is not only not an error, but it's also always false.
15:59:03 <ski> dolio : yeah, but should i use `>' or `>=' ? and should i use `10' or `11' for operators resp. operands ?
15:59:10 <kmc> Wild_Cat, yeah, I understand the rule, but...
15:59:13 <yitz> @vixen welcome back
15:59:13 <lambdabot> where can I a see a picture of you?? URL??
15:59:25 <kmc> 'Since i is undefined, it evaluates to "i"'
15:59:27 <mm_freak> anyway, i think any kind of application is easier and more fun to write than in PHP…  and that's also true for perl, though not to that extent
15:59:47 <kmc> i don't understand languages that detect mistakes and nonsense code and then make a wild guess about what you mean
15:59:49 <dolio> > showsPrec 10 (Just Nothing) ""
15:59:50 <lambdabot>   "Just Nothing"
15:59:52 <ski> dolio : actually i would expect `infixl' to increment on the right ..
15:59:58 <kmc> that is the Perl and the PHP philosophy
15:59:58 <Wild_Cat> kmc: yeah, it's made of dumb.
16:00:01 <kmc> it seems profoundly backwards
16:00:02 <monadic> Wild_Cat: Nothing is an error on PHP :)
16:00:08 <kmc> the machine should not second-guess me, it should call me on my bullshit
16:00:09 <ski> (and `infix' to increment both)
16:00:15 <dolio> ski: I think that's what I said.
16:00:15 <kmc> but then people get angry because they hate errors
16:00:19 <Jetbeard> mm_freak: i'm kind of sleepy at the moment and i read that as "any kind of application is easier and more fun to write in PHP"
16:00:30 <ski> dolio : so you did. i must be tired
16:00:35 <Wild_Cat> kmc: and there are people who will argue to death that autovivification is a *good* thing.
16:00:35 <monadic> In perl you can treat a string as a function like "func"(5) is the same as func(5)
16:00:45 <monadic> Although under use strict it isn't allowed
16:00:48 <Wild_Cat> and that PHP's array type is not the most moronic thing ever.
16:00:55 <mm_freak> Jetbeard: such a statement from…  well…  me?
16:00:56 <ion> jetbeard: Haha, ditto
16:00:58 <mm_freak> i hate PHP
16:01:11 <mm_freak> PHP is from stupid people for stupid people (for people being forced to be stupid)…  i see absolutely no value in that language
16:01:14 <dolio> ski: infixl calls with its precedence on the left, and its precedence+1 on the right.
16:01:18 <Jetbeard> implying that i keep track of who's who
16:01:20 <kmc> autovivification?
16:01:24 <mm_freak> +or
16:01:29 <Jetbeard> i can barely remember who i am these days
16:01:30 <ski> dolio : *nod*
16:01:33 <dolio> And you use > to check if you need to parenthesize.
16:01:36 <cmccann> the difference is that perl is actually surprisingly good at guessing what you mean, assuming you meant roughly what Larry Wall would have meant if he'd typed the same thing
16:01:41 <monadic> People who hate waiting for a big failure because it auto-casted every thing in the program are just too egotistical to want an error shoved up their face
16:01:52 <mm_freak> Jetbeard: i'm known for being more anti-PHP than anyone could be =)
16:02:09 <cmccann> whereas PHP usually just guesses that you meant "please insert a security hole in my website here"
16:02:11 <parcs> is it already time for #haskell's weekly language-bashing?
16:02:14 <ski> > showsPrec 11 (Just Nothing) ""
16:02:15 <lambdabot>   "(Just Nothing)"
16:02:17 <kmc> the 2 Minutes Hate
16:02:18 <hpc> the nice thing about perl is that forgetting a <%php> tag doesn't leak your website
16:02:19 <Cale> http://hpaste.org/49429
16:02:21 <Cale> lol
16:02:33 <Wild_Cat> kmc: that thing in Perl and PHP where you can do $i[10] = 1, where $i is currently undefined, and it automatically becomes an array with 11 elements, the 11th being assigned 1.
16:02:36 <yitz> > showsPrec undefined (Just Nothing) ""
16:02:37 <lambdabot>   "*Exception: Prelude.undefined
16:02:41 <monadic> cmccann: Yeah, I don't mind perl that much. Although it can be ugly to read, its nice for quick scripts (although nowadays I would use haskell instead, of course)
16:02:44 <yitz> well that's not fair
16:02:53 <Wild_Cat> (also works if $i exists and is an array with less than 11 elements)
16:02:54 <ski> > showsPrec 10 not ""
16:02:55 <lambdabot>   Overlapping instances for GHC.Show.Show
16:02:55 <lambdabot>                              (GHC.B...
16:02:59 <monadic> I don't get why PHP uses meaningless sigils. At least Perl has meaning to theirs
16:03:04 <hpc> Wild_Cat: i personally use $i{10}
16:03:27 <hpc> for sparse arrays, it's way easier
16:03:37 <Wild_Cat> kmc: as usual, Wikipedia explains it better than I: http://en.wikipedia.org/wiki/Autovivification
16:03:41 <arw_> Wild_Cat: depends. the saner variant of perl is the one you get with 'use strict;'
16:03:52 <Wild_Cat> hpc: what does $i{10} even mean? Is that a dict key?
16:03:57 <hpc> yep
16:03:59 <mm_freak> Wild_Cat: actually in PHP $i becomes an array with only one element
16:04:18 <hpc> and %i instead of @i
16:04:20 <mm_freak> Wild_Cat: PHP arrays are not real arrays…  they are more like dictionaries
16:04:33 * cmccann tries to figure out why mm_freak is using … instead of ...
16:04:40 <Wild_Cat> mm_freak: does it? I thought it worked as in Perl. It's been a while since I last did PHP.
16:04:50 <hpc> also, cool thing about perl hashes, is when you pass them to a function, you can overwrite parts of them
16:04:54 <Wild_Cat> mm_freak: well, from what I recall they're a bizarre hybrid between lists and dicts.
16:05:05 <hpc> &func(%hash, key=>$overwrite_value);
16:05:15 <monadic> PHP arrays are hashes?
16:05:26 <mm_freak> Wild_Cat: i'm forced to do a lot of PHP…  i can't find proper words to describe how bad i hate it
16:05:34 <Wild_Cat> mm_freak: you have my sympathy.
16:05:48 <monadic> mm_freak: Make a Haskell -> PHP compiler
16:06:09 <mm_freak> monadic: i have to write PHP, otherwise i would write haxe and compile to PHP
16:06:12 <kmc> then sell it to facebook
16:06:31 <mm_freak> haxe is a statically, strongly typed language based on ECMA
16:06:48 <mm_freak> with some features borrowed from ML-style languages like ADTs
16:06:50 <monadic> Facebook would want a Haskell compiler -> PHP? Don't they write in PHP and compile to C with hiphop?
16:07:05 <kmc> these are not incompatible monadic
16:07:06 <monadic> mm_freak: Why can't you compile haxe and say you wrote the PHP?
16:07:12 <kmc> they have used Haskell for projects before
16:07:20 <monadic> kmc: Ahh, neat.
16:07:21 <mm_freak> monadic: because it doesn't adhere to the coding standard ;)
16:07:26 <kmc> monadic, for refactoring PHP in fact
16:07:27 <ski> Wild_Cat : hm, couldn't `f Nothing = ...; f (Just x) = ..x..' be seen as autovivification of `f', in some sense ? :)
16:07:48 <mm_freak> monadic: also most of the code i write is not original…  i have to change existing code a lot
16:08:03 <mm_freak> and that's much worse
16:08:34 <Wild_Cat> ski: not really -- I don't see how it would? I mean, you're defining f there, the compiler doesn't make it up for you.
16:09:03 <monadic> ski: Except theres no implicit cast a -> Maybe a... or ("String" :: Int) -> Nothing
16:09:33 <ski> Wild_Cat : the compiler makes up `f' out from you telling it how `f' behaves when you "access/dereference" (i.e. apply) it
16:09:48 <Wild_Cat> autovivification would be you calling f at some point, where f isn't defined anywhere, and the compiler filling it the gaps with what it thinks you'd like f to do based on... er... Something.
16:09:51 <ski> monadic : that's a separate thing
16:11:10 <ski> well, if you say `nth0(5,List,42)' in Prolog with `List' uninstantiated, that will make `List' be a list of at least six elements, the fifth being instantiated to `42'
16:11:41 <Wild_Cat> ski: yeah, but what f is and how it behaves is entirely defined by you, the user. Autovivification is the exact opposite of that. It's mutating a data structure that you haven't even instantiated before.
16:12:48 <ski> no, it's not entirely defined by me (iiuc what you mean). that `f' will be a function is determined by me trying to apply `f' to patterns in the defining clauses
16:13:18 <cmccann> Haskell should have a feature where any undefined identifiers that are used have their types inferred and implementations generated by feeding the type to djinn
16:13:35 <Wild_Cat> ski: yeah, but if you try to apply f to something that doesn't match the patterns you explicitly defined, it'll fail. At compile-time, even.
16:13:36 <ski> just like hash-indexing a variable in Perl apparently makes that variable into a hash table
16:14:05 <Wild_Cat> I'm not good at Haskell, but I don't think it's even possible to express a Haskell equivalent to Perl's autovivification.
16:14:06 <mauke> ski: you can't hash-index a variable that's not already a hash
16:14:46 <ion> wild_cat: % perl -Mstrict -lwe '$i[10] = 1'
16:14:47 <ion> Global symbol "@i" requires explicit package name at -e line 1.
16:14:47 <ion> Execution of -e aborted due to compilation errors.
16:14:49 <ski> cmccann : sometimes it would be nice to be able to write type signatures with no implementation, pass a `--stub-definitions' flag, and have them all get a default implementation that basically says they're not implemented yet
16:14:56 <arw_> na, its not quite like that. you can take any scalar as a reference and dereference it as an array, hash or scalar which is automatically created on dereferencing.
16:15:10 <cmccann> ski, "undefined"?
16:15:20 <Wild_Cat> ion: yeah, use strict makes a lot of Perl's insanity go away.
16:15:21 <ski> mauke : <http://en.wikipedia.org/wiki/Autovivification> appeared to me to be saying that you could (i don't know Perl, though)
16:15:31 <mauke> ski: I'm not going to click on that
16:15:34 <Wild_Cat> ion: what saddens me is that it's not the default.
16:15:45 <ski> cmccann : e.g. that -- or a more informative error message including the file and line the type signature was at
16:15:52 <cmccann> ski, something like http://hackage.haskell.org/package/placeholders ?
16:15:59 <ion> To me Perl is the language with use strict; use warnings, and the language without them doesn’t exist. ;-)
16:16:14 <arw_> you can do "my @a; @a[1] = 5; @a[9]->{foobar} = "schnitzel";"
16:16:15 <Wild_Cat> the flag should have been "use horrible_shortcuts_that_you_should_be_ashamed_of_we_will_tell_your_mother_young_man"
16:16:17 <ski> mauke : hm, why ?
16:16:22 <mauke> arw_: that's terrible code
16:16:48 <ski> cmccann : i suppose more or less like that, yes
16:16:53 <arw_> ion: that would also work with strict and warnings :)
16:17:04 <mauke> ski: either it agrees with me and I've wasted my time, or it doesn't and I'll be depressed by seeing more false information in wikipedia
16:17:16 <mauke> arw_: and generate at least 2 warnings
16:17:47 <arw_> mauke: three. "foobar", $a[1] and $a[9].
16:17:49 <ski> the example used is `$h{A}{B}{C}{D}=1'
16:17:57 <mauke> arw_: how is "foobar" a warning?
16:18:00 <monadic> I've occasionally turned off use strict to do some crazy metaprogramming that made for really beautiful code (the code that managed the beautiful code was _terrible_, though)
16:18:10 <mauke> ski: yes, that's three dereference ops
16:18:15 <arw_> mauke: barewords as hash-keys are obsolete nowadays.
16:18:18 <mauke> which will automatically create a reference
16:18:21 <mauke> arw_: no, they aren't
16:18:43 <arw_> mauke: really? i thought so.
16:18:53 <mauke> well, you're wrong
16:19:52 <ski> mauke : so you're saying that snippet requires `$h' to already reference an existing hash map ?
16:20:06 <mauke> ski: no, that code doesn't use $h
16:20:38 <cwl> where can I find the source of Data.List
16:20:39 <ski> .. well, it mentions `$h' at least
16:21:08 <ski> @source Data.List
16:21:08 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
16:21:09 <mauke> ski: that's like saying map (:[]) [1,2,3] mentions (:[
16:21:12 <Eduard_Munteanu> cwl: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html   and click the "Source" link?
16:21:21 <mauke> ski: (:[ is not a "thing"
16:21:33 <ion> monadic: Sounds like TH. ;-)
16:21:48 <cwl> Eduard_Munteanu: thanks
16:21:53 <ski> mauke : hm, the hash table dereferences bind more tightly than the `$' ?
16:22:01 <mauke> ski: no
16:22:07 <ion> > (length "pure", length "(:[])")
16:22:08 <lambdabot>   (4,5)
16:23:36 <hpc> > (length "pure x", length "x:[]")
16:23:37 <lambdabot>   (6,4)
16:24:11 <ion> > map x:[] [1,2,3]
16:24:12 <lambdabot>   Couldn't match expected type `a -> b'
16:24:12 <lambdabot>         against inferred type `Simple...
16:24:16 <monochrom> ski: in showsPrec, the Int parameter is the operator precedence of the "context", to help you decide whether to add parentheses, e.g., the parameter says 5, you're showing a precedence-4 thing, you should add parentheses. as well, if you call showsPrec recursively, you pass it the precedence of the current thing, such as 4 in the above example
16:24:24 <monadic> > (length $ pure x, length $ x:[])
16:24:25 <lambdabot>   (1,1)
16:24:36 <ski> mauke : i was assuming it (conceptually) parsed as `((((($h){A}){B}){C}){D})=(1)' (as an AST, regardless of whether that concrete syntax is allowed or not. .. though maybe one problem could be that Perl doesn't specify a grammar even for the basic constructions ?)
16:24:52 <companion_cube> only perl can parse perl
16:25:04 <mauke> companion_cube: cool story, bro
16:25:23 <monadic> companion_cube: Except pugs was written in haskell...
16:25:25 <mauke> ski: no, $ { } are one "thing"
16:25:40 <dolio> monochrom: You don't necessarily pass the precedence of the current thing.
16:25:43 <mauke> monadic: pugs doesn't parse Perl. you can write perl in Haskell.
16:25:53 <companion_cube> ok, only perl5 can parse perl5 ;)
16:25:58 <ski> monochrom : yes, i know that. what i repeatedly forget is exactly which precedences i should pass, and how i should check for them in `showParen' and `readParen' (and also the `10' and `11' precedences)
16:25:58 <ion> I love the "@{[ ... ]}" syntax for prettyprinting array-ish values.
16:26:16 <mauke> ski: $h{A} is an element of %h
16:26:22 <mauke> ski: %h is a hash by syntax
16:26:31 <dolio> For instance, juxtaposition has precedence 10, and it passes 10 to the right, and 11 to the left.
16:26:41 <dolio> Er, that's backwards.
16:26:45 <dolio> 10 to the left, 11 to the right.
16:26:52 <dolio> Because it's left-associative.
16:28:00 <dolio> That's technically inadequate, I think, of course.
16:28:13 <dolio> But the problem doesn't come up much.
16:29:38 <ski> mauke : ok. i assume then that you can't replace `$h{A}' with another "l-value" (other that a direct variable reference) in `$h{A}{B} = 1', is that right ?
16:29:39 <dolio> If you have (x % y) # z, where # is infixl N and % is infixr N, then that will print as x % y # z.
16:29:42 <dolio> But that's illegal.
16:30:01 <mauke> ski: that depends on what exactly you mean
16:30:18 <mauke> ski: first off, $h{A}{B} is syntactic sugar for $h{A}->{B}
16:30:31 <mauke> ski: ->{ } is a normal postcircumfix operator
16:30:32 <ski> e.g., let's say i want to make `not' show as `\x -> case x of {False -> True; True -> False}', how would i make this be wrapped in brackets if it occurs to the left of an operator, but not if it occurs on the right of an operator ?
16:31:03 <mauke> ski: so you can plug pretty much any expression in there
16:31:09 <ion> Perl even has postcircumcision operators.
16:31:44 <ski> dolio : hm, i don't think i've noticed any such. istr noticing getting more brackets than i expected in some cases, though
16:32:07 <ski> mauke : ok. that's strange, i suppose
16:32:14 <mauke> why?
16:33:28 <ski> well, if `->{ }' took a reference/location/pointer as left argument, it wouldn't be strange
16:33:40 <mauke> I don't see why
16:33:49 <mauke> unary * in C doesn't take an lvalue either
16:33:49 <copumpkin> dmwit: I proved the associativity thing we were talking about the other day :)
16:33:51 <copumpkin> it's fairly clean
16:34:20 <ski> unary `*' in C converts from an lvalue to an rvalue
16:34:40 <mauke> yes
16:34:46 <mauke> so does ->{ }
16:34:50 <mauke> no, wait
16:34:55 <Jetbeard> does anybody know of any good books that teach functional reactive programming from the bottom up?
16:34:56 <sm__> come on hackage
16:34:57 <ski> `->{ }' being allowed to take a non-reference-valued expression as left argument would be the strange part
16:34:58 <mauke> * goes from rvalue to lvalue
16:35:05 <ski> or, sorry, yes
16:35:24 <mauke> well, now it depends on your definition of "allowed"
16:35:35 <ski> well, yes
16:35:36 <mauke> it'll throw an exception if you try to dereference a non-reference
16:36:01 <dolio> ski: It looks like the deriving machinery might not take precedence declarations into account.
16:36:03 <ski> ok, that sounds better then
16:36:10 <dolio> Which isn't really surprising.
16:36:23 <ski> dolio : *nod* :/
16:36:25 <mauke> ski: with one exception: autovivification :-)
16:36:35 * hackagebot shelltestrunner 1.0 - A tool for testing command-line programs.  http://hackage.haskell.org/package/shelltestrunner-1.0 (SimonMichael)
16:36:52 <mauke> if you try to dereference an uninitialized lvalue, perl will create an appropriate ... referee? for you
16:37:09 <ski> mauke : well, in that case, it patches things up so that it *becomes* a reference, iiuc
16:37:21 <ski> yea
16:37:26 <sm__> hurrah
16:38:01 <ski> mauke : ok. ty for clearing the confusion up some bit. it seems more reasonable to me, now
16:38:10 <mauke> also, using non-existent array/hash elements in an lvalue context creates them
16:39:20 <ski> (in Prolog/Mercury terminology, whether it's unitialized/uninstantiated or not is a part of the instantiate state, not a part of the (statically known or not) type)
16:39:35 * hackagebot iteratee 0.8.6.0 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.8.6.0 (JohnLato)
16:39:56 <mauke> perl has syntactic typing in a sense
16:40:55 <ski> but no parametric type constructors, no ?
16:41:26 <d7> Is there a clear winner between the enumerator library and the iteratee library? They seem to overlap?
16:41:37 <c_wraith> So, um.  I have a data type which could be made an instance of Functor.  But it has an additional contract on its contents, that a use of fmap could violate in some cases.  In most common cases, it would be fine.  Is it sane to provide a Functor instance, given this?  Is it sane to make it partial if I do, such that it explodes if fmap is used in a way that would violate the other contracts?
16:41:46 <mauke> ski: hah. that would require types
16:42:18 <brad_> Can someone provide an example of using Data.Fixed for use in ghci?
16:42:37 <kmc> c_wraith, that depends on context
16:42:44 <kmc> how contrived is an example which violates the contract?
16:42:47 <dolio> c_wraith: It sounds like I'd be against it. But maybe you could be more specific.
16:43:30 <ski> (hm, i suppose having a "get-type" operation return a structured type wouldn't be much different from just using the value as its own type)
16:44:07 <ski> (having type predicates/contracts which properly assign blame also in higher-order cases would of course be useful)
16:44:22 <c_wraith> This is for an upgrade to my lrucache package.  I'm going to include the ability to put custom cost metrics in it.  The contract fmap could violate is that the size of the contents are below the overflow threshold, when using a custom size metric.
16:45:28 <benmachine> d7: they essentially solve the same problem; I think enumerator was invented because iteratee was considered difficult to use
16:45:44 <d7> benmachine: Both are not easy to use. :)
16:45:50 <benmachine> d7: iteratee places a high priority on performance, aiui
16:45:56 <benmachine> d7: relative term :P
16:46:36 <d7> I may have mentioned 100 times that I think the iteratee pattern is like, the best thing I've ever seen.
16:46:56 <dolio> One of them uses a representation of iteratees that is asymptotically less efficient for some usages, as I recall.
16:47:04 <d7> Of all the things I've come across in Haskell, few make me go, "Oh wow, that's incredible"
16:47:11 <benmachine> I imagine that's enumerator
16:47:15 <d7> Yeah
16:47:21 <benmachine> a few people think that iteratees are a nice idea but "not finished yet"
16:47:32 <d7> Well, that may be the case.
16:47:37 <d7> As they stand they're still pretty impressive.
16:47:53 <benmachine> inasmuch as they need some more innovation to be really semantically robust
16:47:57 <benmachine> I might be making this up
16:47:59 <benmachine> I don't really remember
16:48:26 <aninhumer> Right guess I'll take another stab at reading through that Iteratee explanation tomorrow then
16:49:19 <benmachine> oh there's a new version of iteratee as of a few minutes ago
16:49:58 <aninhumer> Or if anyone has any suggestions of good explanations, I currently just have Monad.Reader issue 16
16:56:13 * ski wants to say something like `data Foo f a = ..fa.. where type fa = f a'
16:56:14 <yitz> i think iteratee is a good idea for certain cases, but a bad idea for most real applications
16:57:15 <yitz> it's much, much more complicated than lazy io. it's schemey CPS bolted onto haskell - lazy io is so much more natural in haskell.
16:57:31 <dolio> ski: Presumably with a right hand side more complicated than 'f a'.
16:57:34 <mwc> lazy IO is also a horrible dirty sin
16:57:35 <yitz> the usual way to do io in haskell is still lazy io.
16:57:51 <conal> yitz: i'm glad to hear someone else say so.
16:57:58 <yitz> mwc: yes but but not nearly as horrible a dirty sin as iteratees
16:58:15 <mwc> Well, at least with iteratees you get the advantage of deterministic resource finalization
16:58:16 <yitz> conal: thanks :)
16:58:50 <mauke> I don't know what iteratees are but nothing is worse than lazy io
16:58:58 <yitz> mwc: also with lazy io - when your semantics fit the criteria for their use. which is usually.
16:59:18 <mauke> s/usually/never/
16:59:26 <ski> dolio : well in general, yes. in this case, actually no -- i just think it would read less cluttered with `exp_u' (or something) instead of `(exp u)'
16:59:34 <mauke> exceptions: throwaway programs where you don't care if they succeed
16:59:36 <yitz> mauke (who is currently an op): there is something worse than lazy io - iteratees.
16:59:41 <conal> my main worries about iteratee come from my understandings that (a) it's an implementation without a specification, and (b) it encourages one to *compose* with IO, which lacks compositional properties.
16:59:42 <dolio> Oh, parens.
16:59:42 <mauke> yitz: unpossible
17:00:16 <brad_> Has anyone used Data.Fixed?
17:00:32 <yitz> conal: you are basically re-writing part of the runtime system in userland code.
17:00:43 <hvr> brad_: I tried to...
17:01:20 <dolio> My main problem with iteratees is that you can write nice lazy algorithms that work incrementally over data structures, but to get them to work incrementally with I/O using iteratees, you have to rewrite your algorithm to use iteratees.
17:01:38 <brad_> okay thanks hvr, maybe i'm not crazy
17:01:53 <linduxed> how do i find the implementation of a function like "words"?
17:02:01 <yitz> conal: do you think there might be a way to simplify reactive in a way that will work for file io apps? perhaps ui is shooting too high for a first attempt.
17:02:03 <ion> Hoogle it
17:02:05 <mauke> you click on the "Source" link
17:02:06 <conal> yitz: and i'd much rather see those imperative (non-denotative/functional) mechanisms disappear from the programming model into an *implementation* of a (denotative) programming model.
17:02:07 <ion> @src words
17:02:08 <lambdabot> words s = case dropWhile isSpace s of
17:02:08 <lambdabot>     "" -> []
17:02:08 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
17:02:12 <ion> or lambdabot it
17:02:25 <mauke> ion: that tells you nothing
17:02:43 <conal> yitz: yes, if we can tame/hide the visibly imperative nature of file io.
17:02:47 <linduxed> ion: thx
17:03:13 <yitz> conal: i mean while keeping the current operating systems :)
17:03:24 <hvr> brad_: but alas, the Data.Fixed type aren't unboxable
17:03:30 <conal> yitz: e.g., use file i/o as a non-observable implementation of something with precise & simple semantics.
17:03:55 <aninhumer> Hmm what's this "{-partain:Char.-}" in the actual source?
17:03:56 <conal> yitz: e.g., time functions. where we want time-varying contents.
17:03:57 <hvr> brad_: they are based on the 'Integer' type, but I wanted an 'Int'-backed fixed-type
17:04:28 <yitz> conal: well for file io perhaps we don't have to be as general as time functions
17:04:33 * ski . o O ( `Exp :: ((* -> *) -> (* -> *) -> (* -> *) -> (* -> *) -> (* -> *)) -> (* -> *)' )
17:04:34 <brad_> hvr_ how do you construct one?
17:04:40 <tommd> hydo: where are you?
17:05:02 <hvr> brad_: well, you can basically just take the source-code of Data.Fixed and replace Integer by Int :-)
17:05:04 <conal> yitz: perhaps not. maybe we can find another simple model.
17:05:06 <hvr> brad_: http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base/src/Data-Fixed.html
17:05:19 <yitz> conal: in fact, reactive is actually *more* general than time-varying functions, and i think file io is a simple special case that doesn't exactly overlap with time-varying functions.
17:05:59 <yitz> conal: reactive is really functions that vary over posets, where time is only one kind of poset
17:06:13 <hvr> brad_: using 'Integer' makes operations like multiplication easier, as you don't have to take special care w.r.t. overflows
17:06:25 <brad_> yeah but I am a newbie, I meant one backed by Integer
17:06:34 <yitz> conal: ie we don't always care about time-ordering, and that needs to appear in the semantics
17:06:37 <conal> yitz: afaict, fully ordered, not just partially ordered. and a very few operations need a bit more about "time"
17:06:43 <hvr> brad_: are you asking how to use Data.Fixed?
17:06:53 <brad_> Yes, please
17:06:53 <yitz> conal: no partially ordered
17:07:28 <conal> yitz: and i wasn't suggesting fran/frp/reactive. rather that we look for a precise & simple model. time functions is just one possibility.
17:07:37 <yitz> conal: one of the beutiful things about laziness is that i'm not forced to specify the ordering of calculations when that doesn't matter
17:07:59 <hvr> brad_: the trick to using Data.Fixed is taking advantage of the Num instances
17:08:20 <conal> yitz: different topic, iiuc. i'm not talking about evaluation order at all.
17:08:29 <hvr> brad_: i.e. you can write literals "1234.1 :: Fixed E3"
17:08:37 <yitz> conal: no not evaluation order, the order in which things happen
17:08:56 <brad_> okay, that's what I needed.  I'll try it in ghci.
17:08:57 <yitz> conal: evaluation order sometimes implies that
17:09:05 <hvr> brad_: once you have a fixed-typed value, you can apply the usual arithmetic operations to it, *, +, - and so on
17:09:38 <hvr> brad_: but you can't mix a fixed-type with a plain Int or float
17:09:43 <hvr> in operation
17:10:04 <hvr> in arithmetic operations... you have to convert between the number types (as usual)
17:10:15 <conal> yitz: perhaps i misunderstood you. i thought you meant to say that the "classic frp" semantics implemented in fran or reactive does not require that "time" is fully ordered.
17:10:27 <brad_> with the usual coercision functions
17:10:31 <brad_> ?
17:10:34 <hvr> yes
17:10:58 <yitz> conal: no i'm thinking of generalizing time functions to poset functions, to make things simpler
17:11:03 <int80_h> is there a function that can test to see if a list is empty? I searched Prelude and Data.List. It has to be easier than I am imagining.
17:11:09 <brad_> Okay, thank you.  That was exactly what I needed to know.
17:11:14 <nomeata> int80_h: null
17:11:14 <int80_h> I was looking for something like isEmpty
17:11:35 <int80_h> cool
17:12:12 <conal> yitz: if you follow that line of thought to a precise semantics, please let me know. i'm intrigued.
17:12:15 <ski> @hoogle [a] -> Bool
17:12:15 <lambdabot> Prelude null :: [a] -> Bool
17:12:15 <lambdabot> Data.List null :: [a] -> Bool
17:12:15 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
17:12:22 <dmwit> copumpkin: Nice, what final data type did you decide on?
17:12:36 <copumpkin> dmwit: the original one :)
17:12:39 <yitz> conal: don't think i'll be able to do it on my own :)
17:12:44 <copumpkin> it was fairly clean
17:12:56 <int80_h> ski: you just showed me a new way to look :)
17:12:58 <dmwit> huh, great!
17:13:28 <ski> int80_h : there's also `@hoogle+', to get the next three results (if any)
17:13:29 <copumpkin> dmwit: http://hpaste.org/49430
17:13:32 <copumpkin> most of that isn't the actual proof
17:13:43 * hackagebot iteratee 0.8.6.1 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.8.6.1 (JohnLato)
17:13:46 <yitz> conal: the inspiration is the usual use cases of file io, rather than ui. what would be a good semantics for that? seems like a simpler problem than ui.
17:14:25 <copumpkin> dmwit: I could also use that trivially to prove that foldr1 == foldl1 when the operator is associative
17:14:39 <copumpkin> since I've got those two proofs showing that foldl1 and foldr1 are folds
17:14:46 <dmwit> Is this stuff actually readable to somebody familiar with Agda?
17:14:49 <conal> yitz: i don't usually connect frp & ui in my mind. of course frp is useful for ui, but not more so that for other things.
17:15:04 <kmc> copumpkin, what's this begin / ∎ business?
17:15:52 <yitz> conal: true. but a lot of what's in there was worked out by people thinking of various kinds of ui as most of their concrete examples.
17:15:57 <copumpkin> kmc: equational reasoning :) basically a simple way to write a big sequence of transitivity applications for equivalence relations
17:16:09 <kmc> cool
17:16:14 <kmc> is it baked-in or some library?
17:16:15 <copumpkin> dmwit: I'll annotate it later :P I'm going to actually try and get a blog (*shock*) up this weekend
17:16:20 <copumpkin> and might write a post on it
17:16:29 <copumpkin> kmc: yeah, in Relation.Binary.EqReasoning
17:16:33 <copumpkin> anyway, gotta run
17:16:35 <copumpkin> bbl :)
17:16:39 <kmc> seeya copumpkin
17:16:44 * ski is shocked by copumpkin having a blog ..
17:16:50 * applicative too
17:16:54 <conal> yitz: i mainly think of file systems as an implementation of state, and state as a second-class interface to (usually discretely) time-varying values.
17:17:04 * yitz wonders which blogging platform copumpkin will choose
17:17:11 * applicative is not opposing it of course
17:17:19 <conal> and all i mean by "time-varying" is that the change happens through time, rather than space etc.
17:17:57 <conal> so that there's only one value "at a time".
17:18:34 <ski> (.. it's interesting in Clean how you can separate out e.g. file-system or gui from the world)
17:18:41 <yitz> conal: well, that model works for small files, but not for big ones, or files streamed over a network.
17:19:05 <conal> yitz: what relevance are you seeing in size?
17:19:34 * ski puts a copy-on-write barrier on yitz's big files
17:19:46 <yitz> conal: because then the order is essential, but not relative to other time-varying things.
17:20:11 <yitz> necessarily
17:20:12 <conal> yitz: how does size make order essential?
17:21:01 <yitz> conal: because i want to read values at the beginning now, and near the end only later. only because of the size, not because of any other semantics.
17:21:33 <conal> yitz: are you talking about atomic vs non-atomic writes?
17:21:46 <yitz> conal: and because i want to free up resources - again, unrelated to any other semantics other than size
17:22:50 <conal> yitz: freeing up resources is "merely" an implementation issue, right? i'd prefer aiming first at a precise & simple denotation/model and then seeing how to implement it efficiently.
17:22:52 <fxr> do you know why there are two Iteratee implementations? Is there any performance differences between those?
17:22:58 <yitz> conal: no i wasn't thinking about atomicity. that's more of a local property.
17:23:09 <mwc> fxr: still trying to find the correct balance of API
17:23:19 <mwc> there's actually a third besides iteratee and enumerator
17:23:20 <benmachine> fxr: iteratee is the original, enumerator was meant to be simpler (but possibly slower)
17:23:55 <mwc> http://hackage.haskell.org/package/iterIO
17:24:06 <mwc> looks really nice but suffers from having too much crammed into one lib IMHO
17:24:12 <fxr> which one do you prefere for an http request parser?
17:24:24 <mwc> fxr: write it in attoparsec then use an adapter
17:24:29 <conal> once we have a precise & simple semantics, opportunities for efficiency often arise. for instance, partial garbage collection of file contents.
17:24:37 <fxr> yeah I just implemented it in attoparsec
17:25:08 <yitz> conal: well no this is my point. for file io it's not "just implementation details" any more than the order that things happen on the screen are "just implementation details" for a ui.
17:25:35 <yitz> it's the central point of what you're trying to do.
17:26:48 <conal> yitz: if you define it as such. but remember my goal, which is to use file i/o not as an abstraction but rather as part of the implementation of another abstraction that has simpler semantics.
17:27:11 <conal> yitz: ie the same role that stack munging and thunk overwriting has in pure functional programming.
17:27:19 <conal> s/has/have/
17:28:11 <yitz> conal: i guess you're right that humans will always need to be part of io whereas our particular persistance paradigm may completely vanish some day.
17:28:11 <int80_h>  have a good day #haskell
17:28:56 <yitz> conal: but still. think of it as presenting ordered information to a human to write it down, or having a human read it back.
17:29:43 <yitz> conal: it's a semantic domain which is hard to support in current semantic models, yet one which is so common.
17:29:53 <yitz> conal: i think it can be simplified.
17:30:23 <conal> yitz: i hope you're right. i see value in pursuing such simplification.
17:31:27 <conal> yitz: maybe "file i/o" is overly broad as a target. at least i don't see how to make that general target less complicated that imperative programming in general.
17:31:42 <yitz> conal: i think it has potential for being an intermediate layer which can be further abstracted, and which will make it easier to get practical reactive.
17:31:50 <yitz> conal: hey, it worked for radio
17:32:21 <yitz> conal: true. the target needs to be refined.
17:35:04 <yitz> ski: ?
17:35:08 <aninhumer> conal, yitz: not entirely clear on what particular uses of file i/o you're discussing here. Something like continuous access in a database?
17:35:10 <fxr> hmm iterIO looks nice
17:35:43 <yitz> aninhumer: perhaps, i'm thinking of simpler things
17:36:50 <ski> yitz : i was just alluding to that `readFile' ought to use copy-on-write semantics
17:37:33 <yitz> aninhumer: let's say i'm reading a large file that has images embedded in it. when i get to an image, i want to process it and write it out.
17:38:18 <yitz> aninhumer: you can write a lazy io combinator to do that, but you have to use unsafeInterleaveIO to do it.
17:39:22 <yitz> ski: sorry what do you mean by that?
17:40:06 <yitz> aninhumer: oops my last msg went out during the net split. did you get it?
17:40:13 <aninhumer> yitz: yeah
17:40:37 <ski> yitz : i mean that `readFile' ought to conceptually capture the entire state of the file at the time of the `readFile' call, so that later modifications to the file won't affect yet later forcing of the list you get from `readFile'
17:40:57 <yitz> aninhumer: ok :) anyway so you can describe the semantics of that using reactive, but it just seems too complicated to me.
17:41:06 <Eduard_Munteanu> ski: in a way you wouldn't need unsafeInterleaveIO?
17:41:24 <ski> Eduard_Munteanu : i'm not sure what you mean by that ?
17:41:56 <yitz> aninhumer: seems to me there should be something simpler that will handle all lazy io in a way that makes semantic sense, and removes the need for horrible hacks like iteratees.
17:42:03 <Eduard_Munteanu> I'm thinking that under some restricted usage patterns, having I/O lazy by default would work.
17:42:23 <Eduard_Munteanu> (without any unsafeInterleaveIO under the hood)
17:42:42 <conal> this discussion of file i/o and copy-on-write reminds me of the perspective that mutation is a form of manual memory management and so has the same modularity problems. mutation assumes that no one else has (and wants) access to the value being overwritten.
17:42:55 <Eduard_Munteanu> That is, just like your program would be fed a lazy string.
17:43:10 <Eduard_Munteanu> s/would be/was/
17:43:33 <conal> and that assumption isn't locally verifiable. thus anti-modular.
17:43:52 <Eduard_Munteanu> For anything heavyweight some would say "use iteratees".
17:44:00 <yitz> ski: ah right. but that can be expensive. instead, i'm hoping there's a semantic framework in which you can easily write such programs so that the compiler will just automatically cause things to be read in the right order.
17:44:53 <aninhumer> yitz: I'm not entirely clear what the problem with your scenario is, but then I haven't done any significant IO (or indeed much at all) in Haskell.
17:45:24 <yitz> conal: right. but that someone else might be me a few lines down in the do expression.
17:46:40 <yitz> conal: the semantics of readFile are: read the contents of this file, if you need to, and i don't care when.
17:46:48 <ski> conal : it's interesting to consider Clean's unique modes, here ..
17:48:37 <conal> yitz: the contents as of what time?
17:49:07 <conal> yitz: or, the contents after which writes?
17:49:16 <linduxed> @src takeWhile
17:49:16 <lambdabot> takeWhile _ []                 =  []
17:49:17 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
17:49:17 <lambdabot>                    | otherwise =  []
17:49:22 <yitz> aninhumer: one problem is that the image may never get written unless you read further down the input file for some unrelated reason.
17:49:35 <kniu> Is there a parsec primitive that parses nothing?
17:50:01 <applicative> kniu, what do you mean?
17:50:07 <kniu> @hoogle ParsecT s u m ()
17:50:08 <lambdabot> Text.Parsec.Token whiteSpace :: GenTokenParser s u m -> ParsecT s u m ()
17:50:08 <lambdabot> Text.ParserCombinators.Parsec.Token whiteSpace :: GenTokenParser s u m -> ParsecT s u m ()
17:50:08 <lambdabot> Text.Parsec.Prim modifyState :: Monad m => (u -> u) -> ParsecT s u m ()
17:50:08 <yitz> aninhumer: another problem is that you can end up holding the entire image file in memory, instead of streaming it out as you intended.
17:50:09 <applicative> what does it return?
17:50:24 <hatds> possibly "return" or "fail" depending on what you mean
17:50:29 <applicative> @src Text.Parsec.Token whiteSpace
17:50:29 <lambdabot> Source not found. :(
17:50:30 <kniu> oh yeah return
17:50:34 <kniu> thanks
17:50:52 <applicative> kniu, or pure... :)
17:50:58 <kniu> brainfart :|
17:51:10 <hatds> yea, pure or empty would be better :)
17:51:46 <conal> yitz: we already have these space-leak problems in denotative/functional programming (without adding file i/o). i'd rather see a single solution than separate ad hoc solutions.
17:53:11 <yitz> conal: yeah if those things can also happen, then saying "i don't care when" was a lie. i'd like to be able to say what i really mean about how my ordering requirements. without having to artificially model those ordering requirements as data dependencies as in CPS.
17:54:39 <hatds> then you need to write your functions as data, and statically analyze what they depend on
17:54:40 <yitz> conal: absolutely. just suggesting that tackling this case on its own, as a simplification, might lead to some inspiration, or provide the "intermediate frequency" that could be the general solution.
17:54:43 * applicative finds that every attack on 'lazy io', every proof of its absurdity, teaches him more about it, and makes him love it more.
17:55:00 <conal> yitz: hm. one of the main themes of functional programming is exactly to make data dependencies explicit, rather than implicit as in imperative programming. as discussed in backus's turing award paper. though cps is a smell indeed. maybe simplify to direct functional, not complicate to indirect/cps.
17:55:19 <yitz> applicative: kind of like complex numbers or projective geometry :)
17:55:33 <applicative> right
17:55:45 <yitz> conal: yes i agree
17:56:05 <yitz> that's the kind of thing i'm thinking about
17:56:07 <yitz> thus posets
17:56:11 * applicative proposes a new name, non-euclidean io -- not quite right...
17:56:32 <hatds> non-standard io
17:56:40 <yitz> imaginary io
17:57:03 <applicative> lets call it complex; it has an imaginary component
17:57:29 * cmccann suggests "I like evaluating pure thunks to have side effects" IO
17:57:47 * applicative thinks, 'non-classical IO'
17:58:26 <yitz> unfortunately "imaginary io" is sometimes all too accurate, which leads people to use iteratees.
17:58:36 <sm__> "strange IO"
17:58:44 <applicative> cmccann: you caused me to look up some of the 'paradoxes of lazy io' with some remark that it violates purity.
17:59:10 <cmccann> it violates purity in obscure ways that mostly can't actually be demonstrated in a meaningful way
18:00:29 <roconnor> I always think of lazy IO as a form of concurrency
18:00:34 <Bfv9000> what happens when you read and write in the same file and act in parallelizable functions? are there mutex or any control structures avialable in haskell for that kind of control?
18:00:34 <applicative> the arguments are difficult.  There is the one of Oleg, for example, using seq and fdToHandle, but fdToHandle is awfully opaque
18:01:00 <cmccann> my complaint is more than it's obfuscatory and aggressively anti-compositional where the IO is involved
18:02:03 <aninhumer> Right now, I'm going to sleep thinking about IO semantics :)
18:02:03 <applicative> probably, but I wonder if it's just hard to keep hold of the right intuition. the names, e.g. readFile and getContents etc. get in the way sometimes
18:02:19 <yitz> making data dependencies direct and explicit is good when they make sense as part of the semantics. but when they are just a side issue, you should be able to express what you mean simply and have the compiler deduce the data dependencies. just as for pure calculations.
18:02:50 <hatds> so does frp need to be an embedded language?
18:03:06 <cmccann> personally I have yet to be persuaded that regular old everyday IO isn't the correct default in almost all cases today
18:03:37 <yitz> cmccann: that is true. but still, if know that you are staying within certain safe boundaries, then it's not obscure.
18:04:01 <cmccann> if you know what you're doing in certain safe boundaries then unsafePerformIO is okay as well
18:04:04 <applicative> hGetContents h might as well be called something like 'listenOn h' or something.
18:04:05 <cmccann> I prefer to not have to think about it
18:05:04 <yitz> cmccann: the really serious problems with lazy io come up when you try to view it as a solution for *all* problems (or for beginners who don't realize its limitations). but if you view it as a solution for *most* problems, it's fine.
18:05:51 <cmccann> if by fine you mean hackish workaround, then yes
18:06:09 <cmccann> nothing wrong with hackish workarounds if they get the job done
18:06:20 <yitz> cmccann: yep. we need something better. i don't think iteratees is it.
18:07:14 <yitz> cmccann: there's nothing more hackish than iteratees. it's a hack that provides a workaround for cases where lazy io has trouble.
18:07:14 <cmccann> and I don't really buy that it works for "most" problems, but I think that's a matter of what universe of problems are being quantified over here so mostly irrelevant
18:07:50 <cmccann> iteratees have a certain conceptual simplicity that's nice but the current implementations aren't persuasive
18:07:51 <ski> roconnor : i do, as well ..
18:08:48 <cmccann> my intuition is that iteratees are a very clumsy special case of whatever the correct solution is
18:09:05 <kmc> yeah
18:09:07 <cmccann> whereas lazy IO is a dead end that sweeps things under the rug until it can't anymore
18:09:15 <kmc> so people are not entirely wrong when they say that doing IO in Haskell is an active research topic ;)
18:09:31 <yitz> cmccann: true. it works in most cases for me. i do haskell all day long for a living, but i certainly don't cover all problem spaces.
18:09:38 <cmccann> which is why I would prefer to see lazy IO buried with extreme prejudice in hopes of encouraging more people to look for good solutions
18:10:09 <cmccann> yes, I would expect that lazy IO works very well for almost everything in certain problem domains
18:10:20 <applicative> why shouldn't IO be an active research project? considering the matter 'denotationally' is difficult, strange and wonderful, it seems.
18:10:38 <cmccann> yitz, and since you clearly understand how lazy IO works, I wouldn't in any way say you're wrong for using it
18:11:02 <cmccann> but I don't like it being in the standard libraries or part of what beginners are introduced to first
18:11:04 <yitz> cmccann: i disagree. i think the right solution is in a different direction. and that direction will be inspired, at least partially, by lazy io.
18:11:21 <yitz> cmccann: ok propose something better. iteratees are out.
18:11:51 <hatds> what's so bad with iteratees?
18:11:55 <cmccann> regular strict IO suits me just fine
18:12:46 <yitz> cmccann: ok that's reasonable.
18:13:28 <cmccann> in fact, much of what's done with both iteratees and lazy IO strikes me as being easily accomplished using regular strict IO and a handful of very simple combinators
18:13:48 <cmccann> I don't consider either persuasive enough to be seen as the default as of today
18:13:49 <yitz> hatds: they make programs very messy.
18:13:59 <Lymee> Is there a strict map function?
18:14:25 <yitz> cmccann: i would love to see such combinators. i agree that, whatever approach we are using, we need some better combinators.
18:14:28 <applicative> wouldn't you need strict lists? and a strict function?
18:15:16 <hatds> yitz: I think it's a problem of the common implementations, the core idea seems good
18:15:37 <cmccann> yitz, I have an ad-hoc assortment of such combinators that I use, which I should make into a proper library at some point
18:16:06 <yitz> cmccann: if someone can come up with a set of neat, easy-to-understand combinators wrapping iteratees, that would also be fine too.
18:16:41 <yitz> hatds: iteratees is CPS. i view CPS as the goto of functional programming.
18:16:55 <hatds> heh
18:17:15 <cmccann> yitz, the way I like to do it ends up accomplishing things about the same way that iteratees do, except without reifying continuations everywhere and without letting some results be implicit
18:17:26 <fxr> not really
18:17:33 <cmccann> yitz, CPS isn't goto
18:17:36 <yitz> cmccann: that could simplify things.
18:17:42 <cmccann> CPS is putting labels everywhere, call/cc is goto
18:18:15 <fxr> cps actually makes an imperative code functional
18:18:42 <yitz> fxr: or you can look at it the other way - it makes functional code imperative
18:18:50 <fxr> yitz: that's not true
18:19:07 <yitz> fxr: it depends on how you look at it (and how you define those terms)
18:19:10 <Lymee> Bluh. Does ghc let you do concurrency without using the whole +RTS thing?
18:19:47 <benmachine> I think there are some really conspicuous omissions from the standard library that would make strict IO less painful
18:19:49 <cmccann> yitz, anyway, basically I make lots of Kleisli arrows and use general-purpose combinators similar to stuff like mapM, foldM, and such
18:19:53 <applicative> what are you telling the RTS?
18:20:04 <yitz> Lymee: well yeah. do you mean specifying processors or something?
18:20:18 <Lymee> +RTS -N3 --RTS < Is there a way to get rid of that?
18:20:18 <benmachine> (the fact that you have to go into exception handling or hIsEOF to read all the lines in a file grates on me especially)
18:20:33 <benmachine> Lymee: you can compile it into the program I think
18:20:39 <cwl> how to install Hugs.Observe in ubuntu 10.04
18:20:57 <cwl> it seems not in apt repository
18:21:53 <yitz> cwl: there are less and less people who know anything about Hugs these days, since it's not really supported anymore.
18:22:19 <applicative> what is hugs.observe  ?
18:23:22 <parcs> Lymee: there's a pragma that allows you to define rts opts at compile time
18:25:01 <cwl> yitz: but I search for 'debugging' in haskell wiki, I was told to use Hugs.Observe
18:25:24 <cwl> yitz: how do you debug with haskell?
18:26:03 <fxr> it's very strange that there are only just version bump from iteratee 0.8.5.0 to 0.8.6.1.
18:26:13 <yitz> cwl: oh dear that shouldn't look like the first thing to go to. that's old.
18:26:24 <fxr> two releases with no change at all.
18:26:38 <yitz> cwl: ghc now has a debugger in its command line interface
18:26:41 <kmc> cwl, test your functions in ghci
18:26:49 <kmc> provide inputs, see if the outputs are right
18:26:56 <yitz> cwl: you can set breakpoints, etc.
18:27:06 <cmccann> yitz, btw, interested to see a very rough example of the style I prefer?
18:27:06 <kmc> don't even bother with breakpoints and stepping unless you can help it
18:27:12 <kmc> at its best Haskell is declarative and denotational
18:27:15 <kmc> inputs and outputs
18:27:24 <yitz> cmccann: sure, sounds interesting.
18:27:27 <hatds> there is also debug.trace for simple inspections
18:27:29 <cwl> yitz: kmc: thanks, I'll try
18:27:35 <cmccann> yitz, http://stackoverflow.com/questions/6668716/haskell-lazy-bytestring-read-write-progress-function/6669453#6669453
18:27:44 <yitz> cwl: yes kmc is correct
18:27:44 <cmccann> you probably won't like my commentary on lazy IO and iteratees :P
18:27:52 <yitz> cmccann: hehe
18:28:04 <yitz> cmccann: thanks
18:28:13 <cmccann> yitz, and the code is uglier than I would like because I didn't want to introduce a whole bunch of general-purpose combinators that I'd use for myself
18:28:27 <cmccann> but it should give the rough idea
18:28:53 <applicative> cwl, if you have ghc, the Observe module has been updated on Hackage.  I can't open it with hugs, it needs different Exception library. Maybe an older tarball?
18:29:10 * ski pasted "Hugs.Observe" at <http://hpaste.org/49431>
18:29:13 <ski> applicative ^
18:30:42 <cmccann> yitz, I'll also note that I prefer to identify iteratees as being black-box state machines/stream transducers, which merely happen to be implemented using CPS
18:31:14 <yitz> cmccann: well, that's disappointing, i *do* like most of your comments about lazy IO and iteratees.
18:31:21 <applicative> ski, yeah it works in GHCi  but maybe I don't have the right Exceptions library in my hugs
18:31:31 <cmccann> yitz, haha, ok then :]
18:32:02 <applicative> cwl: Debug.Trace is very cool
18:32:06 <applicative> @quote oasis
18:32:06 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
18:32:20 <yitz> cmccann: withFile exist for lazy IO, it's not the best example. The problem is that the withFile in the std libs is just wrong, it's not lazy enough. you can easily implement the correct version though.
18:32:26 <cmccann> I think you mean Debug.Trace.unsafePerformPrintfDebugging
18:32:43 <applicative> cmccann: you spoilsport!
18:32:51 <cmccann> applicative, :]
18:32:52 * ski thinks Hat / Observe is quite nice as a substitute for `Debug.Trace'
18:33:21 * applicative never noticed Observe, he's trying to figure it out
18:33:24 <cmccann> yitz, fair enough, but that's somewhat tangential to my example there
18:33:31 <yitz> yes
18:35:01 <cmccann> yitz, the question I was answering posed a problem that essentially needed the IO to be explicit in some way, and that works at cross purposes with lazy IO in many ways
18:35:23 <cmccann> and while a solution with lazy IO could absolutely be made to work, in full generality it would end up approaching the same sort of structure as my explicit IO version, I think
18:35:35 <ski> applicative : if you use `observe "foo" list' somewhere, it will print out an observation under the `foo' heading of how much of `list' was forced
18:36:02 <ski> applicative : if you observe functions, it will print out which arguments it has been applied to, and what the corresponding results were
18:36:33 <cmccann> which is why I said that lazy IO is actively anti-compositional regarding the IO itself
18:36:40 <cmccann> it does that in order to preserve the easy compositionality of existing lazy pure code, of course, which is useful in many cases
18:36:56 <cmccann> but that's why I think it's a dead end
18:37:25 <linduxed> i'm having a hard time figuring out how to write a simple function called splitWith. the interpreter gives me the error that the type can't be matched, but I also get the feeling that it's designed badly at the moment too
18:37:27 <linduxed> http://pastie.org/pastes/2261728/text
18:37:30 <linduxed> that's the code
18:38:01 <linduxed> i'm looking for pointers on how that is optimally written
18:38:25 <yitz> cmccann: see the problem is that while you can combine io things somewhat better that way, you lose all the composibility on the pure side.
18:39:23 <cmccann> yitz, yes, but at some point I don't think there's any way around that
18:39:34 <ski> > span even [0,2,4,3,5,6]  -- linduxed, i believe you want `span' (or `break') rather than `takeWhile'
18:39:35 <lambdabot>   ([0,2,4],[3,5,6])
18:39:45 <ski> > break odd [0,2,4,3,5,6]
18:39:46 <lambdabot>   ([0,2,4],[3,5,6])
18:40:21 <cmccann> yitz, which is why my prefered approach currently is trying to recreate as much compositional structure in an IO-independent way
18:40:37 <ski> linduxed : btw, are you using Hugs or GHCi or something else ?
18:40:48 <linduxed> ski ghci
18:41:13 <linduxed> ski: oh yeah i forgot about break
18:41:17 <yitz> linduxed: you don't want tail of headSplit, you want what comes *after* headSplit
18:41:19 <ski> linduxed : ok, GHC is not an interpreter. GHCi is an interactive top-level
18:41:38 <ski> (aka "interactor")
18:41:45 <kmc> or "read-evaluate-print loop" (REPL)
18:41:53 <yitz> linduxed: tail headSplit means all but the first element of headSplit itself
18:41:57 <ski> linduxed : also, the recursive call is missing one argument
18:42:30 <cmccann> yitz, the ideal being that given a chunk of pure code to convert to involving IO in some way, the changes needed are minimized and mostly involve breaking a few things apart and splicing in the IO bits
18:42:40 * linduxed is confused now... has to think about what yitz and ski have said
18:42:41 <cmccann> then gluing it back together in a structure that mimics closely the original
18:43:38 * ski wonders whether cmccann is trying to reinvent his reflective syntax idea
18:43:45 <cmccann> rather than having to abandon compositional IO at the outset, or mutilating the entire program structure to cram it into iteratee state machines
18:43:55 <yitz> cmccann: hmm you'd like to avoid that kind of thing where possible. but what i was suggesting above would also force you to do that sometimes.
18:44:23 <ski> (probably not .. since that doesn't really handle compositionality (in the large) at all, it's just a somewhat nicer surface syntax)
18:44:43 <cmccann> ski, not sure what your thing is, so I don't know :]
18:46:35 <ski> cmccann : very basically, instead of `parsePerson = liftM2 Person parseName parseAge', something like `<|parsePerson|> = Person <|parseName|> <|parseAge|>'
18:47:30 <cmccann> yitz, I will also admit that my approach puts some additional constraints on program structure, essentially forcing a fairly extreme version of the "avoid explicit recursion" approach that some people prefer
18:48:35 <ski> (and instead of `foo = do x <- bar; baz x', `<|foo|> = let x = <|bar|> in <|baz x|>' .. and instead of `foo = do x <- bar; if b then baz else quux', `<|foo|> = if <|bar|> then <|baz|> else <|quux|>')
18:48:41 <yitz> > let splitWith p = map (takeWhile p) . takeWhile (not . null) . iterate (drop 1 . dropWhile p) in splitWith isAlphaNum "abc,def,ghi"
18:48:42 <lambdabot>   ["abc","def","ghi"]
18:48:54 <applicative> cwl: you still around?  I notice my hugs installation includes a version of Observe.hs  could it be you already have a copy?
18:49:08 <Matt040804> I know this is common problem, but I'm having trouble understanding the proper way to use the divison operator
18:49:29 <Matt040804> I'm getting  an error: No instance for (Fractional Int)
18:49:45 <ski> Matt040804 : do you want a flooring division, or an exact (or as close to as possible with floating-point) division ?
18:49:47 <cmccann> ski, ah, that's sort of orthogonal to what I'm talking about, except that if I understand correctly, given the style I'm advocating, it would completely abstract over the difference between equivalent pure and impure functions in many cases
18:49:47 <jmcarthur> :t div
18:49:48 <lambdabot> forall a. (Integral a) => a -> a -> a
18:49:48 <applicative> @type (/)
18:49:49 <lambdabot> forall a. (Fractional a) => a -> a -> a
18:50:04 <ski> @type fromIntegral :: Int -> Double
18:50:05 <lambdabot> Int -> Double
18:50:11 <applicative> Matt040804: what are you dividing?
18:50:15 <jmcarthur> :t (%)
18:50:16 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
18:50:23 <Matt040804> Two integers
18:50:33 <applicative> @type \ x y ->  (fromIntegral x / fromIntegral y)
18:50:34 <lambdabot> forall a b a1. (Integral a, Fractional b, Integral a1) => a -> a1 -> b
18:50:47 <ski> Matt040804 : and do you want an exact division, or a "trucated" one ?
18:50:52 <Matt040804> exact
18:51:12 <Matt040804> actually, no, I want integer division
18:51:20 <applicative> @type div
18:51:20 <lambdabot> forall a. (Integral a) => a -> a -> a
18:51:34 <ski> Matt040804 : then use `fromIntegral' on the two arguments (or make sure one or both of them are already whatever `Fractional' type you want, like `Double' or `Rational')
18:51:37 <jmcarthur> haskell comes preloaded with quot and div :)
18:51:38 <ski> hm
18:51:40 <yitz> > 5 `div` 2
18:51:41 <lambdabot>   2
18:51:44 <jmcarthur> (prefer div over quote in most cases)
18:51:52 <jmcarthur> *quot
18:52:01 <ski> Matt040804 : ok, `div' is probably what you want, then (that will always round downwards)
18:52:25 <ski> > -7 `div` 3
18:52:26 <lambdabot>   -2
18:52:29 <ski> > -7 `quot` 3
18:52:30 <lambdabot>   -2
18:52:48 <luite> hehe you have done too much html if you wonder wtf it means that div rounds downwards ;p
18:53:09 <ski> oh, right ..
18:53:10 <kmc> haha
18:53:11 <ski> > (-7) `div` 3
18:53:12 <lambdabot>   -3
18:53:12 <ski> oh, right ..
18:53:14 <ski> > (-7) `quot` 3
18:53:15 <lambdabot>   -2
18:53:18 <jmcarthur> > 7 `quot` (-3)
18:53:19 <lambdabot>   -2
18:53:21 <jmcarthur> > 7 `div` (-3)
18:53:22 <lambdabot>   -3
18:53:27 <Matt040804> Okay, thank you, I was having a real hard time figuring that out
18:53:29 <mauke> #include <stdio.h>  </stdio.h>
18:53:31 <cmccann> luite, it means your stylesheet is using border-radius on the lower corners of the div, of course
18:53:36 <Matt040804> I'm working through the Real World Haskell book
18:53:42 <Matt040804> and I was trying to do some of the exercies
18:55:52 <applicative> Matt040804: excellent!
18:56:36 <luite> cmccann: at least border-radius was one of the few things that I got working right away. I've been spending way to much time yesterdag, battling css to fix layout stuff
18:56:51 <jmcarthur> @let a `quotient` b = if a >= 0 then a `quot` b else (if b > 0 then (a + 1) `quot` b) - 1 else ((a + 1) `quot` b) + 1)
18:56:52 <lambdabot>   Parse error: )
18:57:08 <jmcarthur> @let a `quotient` b = if a >= 0 then a `quot` b else (if b > 0 then ((a + 1) `quot` b) - 1 else ((a + 1) `quot` b) + 1)
18:57:09 <lambdabot>  Defined.
18:57:40 <applicative> Matt040804: the type classes are a bit annoying with the number types, but they get more interesting very quickly...
18:57:44 <cmccann> luite, a lot of layout stuff that people want to do sort of goes against the assumptions implicit in HTML/CSS, so yeah :T
18:58:05 <cmccann> ..."a bit" annoying? >:I
18:58:07 <jmcarthur> @let a `remainder` b = let r = a `rem` b in if r >= 0 then r else (if b > 0 then r + b else r - b)
18:58:08 <lambdabot>  Defined.
18:58:19 <benmachine> @check \x y -> quotient x y == div x y
18:58:20 <lambdabot>   Not in scope: `quotient'
18:58:23 <benmachine> :<
18:58:29 <jmcarthur> they are not the same
18:58:37 <benmachine> k
18:58:40 <jmcarthur> quotient and remainder are euclidean division
18:59:31 <ski> > 5 `quotient` 3
18:59:32 <lambdabot>   1
18:59:57 <luite> cmccann: at least I pretend that IE8 and lower, Firefox 3, etc. don't exist, that already helps a bit :)
19:00:10 <mauke> > 5/3 :: Rational
19:00:11 <lambdabot>   5 % 3
19:00:28 <cmccann> luite, just develop for lynx and pretend nothing else exists
19:00:33 <jmcarthur> the major thing with euclidean division is that the remainder is always positive
19:01:38 <ski>   n `quotient` d = n `div` abs d  -- ?
19:01:59 <applicative> is much use made of Rational?  I never see it, though it's in principle so pleasing.
19:03:20 * ski . o O ( <http://mumble.net/~campbell/tmp/division.txt> )
19:03:38 <jmcarthur> http://creativelad.wordpress.com/2011/04/28/euclidean-division/
19:05:20 <luite> whoah apache 1.3.34 on that server
19:05:35 <jmcarthur> i'm not sure about that relation to div. i've been meaning to check exactly what the relationship is
19:06:28 <jmcarthur> not that it's going to be very enlightening, i think, but it would be nicer to read than by current definition in terms of quot
19:06:33 <jmcarthur> *my
19:07:21 <jmcarthur> the nice thing about this definition is that it's as fast or faster than div
19:07:39 <jmcarthur> at least in microbenchmarks
19:09:42 <Draconx> applicative, I think it's just not very useful.
19:12:00 <applicative> Draconx: I was wondering. I suppose you tend to end up with large mutually prime numbers very quickly
19:12:07 <jmcarthur> it seems that in most cases that i consider Rational i end up just wanting CReal
19:13:37 <Draconx> applicative, indeed, there's also the fact that after a lot of multiplications your Rationals end up being *huge*.
19:14:13 * ski ponders what concrete syntax to use for expression applied to type ..
19:14:32 <kmc> what's my best bet in Haskell for dumping some 16-bit integer PCM samples to the soundcard in real time
19:14:49 <ski> jmcarthur : maybe polynomials over rationals ..
19:14:52 <kmc> on Linux, but preferably portably
19:14:59 <linduxed> ski: i still feel like i'm too bad at this gig to even solve this simple task... but don't you think that break will complicate thigs instead of takeWhile? break returns a tuple, while takeWhile actually gives two lists
19:15:21 <ski> `takeWhile' gives one list
19:15:24 <ski> @type takeWhile
19:15:25 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
19:15:34 <jmcarthur> kmc: output to /dev/audio?
19:15:43 <linduxed> ski: oh i see
19:15:46 <kmc> various ioctls are required jmcarthur
19:15:48 <ski> @type dropWhile
19:15:49 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
19:15:55 <jmcarthur> oh?
19:16:01 <kmc> yes, to set the card in the right mode ec
19:16:06 <applicative> in CReal we have fromInteger n     = CR (\p -> n*2^p)
19:16:09 <elliottcable> what?
19:16:16 <kmc> but you can open a pipe to a program like "sox"
19:16:21 <ski>   span p as = (takeWhile p as,dropWhile p as)  -- conceptually
19:16:26 <ski> @sr cbreak
19:16:26 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
19:16:27 <jmcarthur> i guess my card is just always in the right mode then. just writing to /dev/audio seems to give some output for me
19:16:30 <ski> @src break
19:16:31 <lambdabot> break p =  span (not . p)
19:16:45 <kmc> jmcarthur, yes, it usually gives some output -- I'm not sure you can rely on it accepting your particular format
19:16:50 <jmcarthur> ah
19:17:22 <ski> linduxed : so instead of haveing one call to `takeWhile' and one to `dropWhile', it suffices with a single call to `span' (or `break', if you want to negate the condition)
19:18:52 <kmc> in my experience all sound libraries in all languages are horribly overgrown and don't work
19:19:04 <kmc> why can't they all do only the one thing I happen to want ;)
19:21:27 <linduxed> ski: ok break seems sinsible, but it creates a lot of nested tuples
19:21:34 <linduxed> *sensible
19:21:42 <ski> nested tuples ?
19:21:43 * cmccann builds a sound library implementing only the single most important feature, the API exposes a single procedure that, when invoked, plays "Never Gonna Give You Up" at full volume
19:21:59 <linduxed> ski: doesn't it?
19:22:12 <ski> i don't see why the tuples would nest
19:22:44 <ski> each call to `break' from `splitWith' would take apart the pair into its two parts
19:23:35 <ski> so instead of writing
19:23:42 <linduxed> ski: if i do "break odd [0,2,4,1,5,5,6,7,1,4]" then it would first create a tuple, splitting on the 1... but then the recursive call on the stuff after 1, wouldn't that create a tuple there?
19:23:43 <ski>   front = takeWhile (not pred) xs
19:23:49 <ski>   back = dropWhile (not pred) xs
19:23:53 <ski> you'd just write
19:24:03 <ski>   (front,back) = break pred xs
19:24:22 <linduxed> hmmm ok
19:24:31 <ski> so `front' is what you called `headSplit' in your paste
19:24:48 <ski> and `back' is the rest of the list `xs'
19:26:37 <linduxed> ski: but how would i make that work with the signature? i thought that a tuple is not equivalent to [[a]]
19:27:23 <ski> it doesn't matter, if you call `break' in the `where'-part
19:27:49 <ski> the thing after the `=' in `splitWith pred xs = ...' is what has to have type `[[a]]'
19:28:48 <ski> the types of the things computed inside the `where'-clause are not (directly) present in the type signature of the whole definition
19:29:01 <linduxed> ski: yes i know that but...
19:29:13 <linduxed> ski: sigh... i'm just too bad for this right now
19:29:24 <linduxed> i can't figure out the simplest of things
19:29:56 <linduxed> i don't know if it's the fact that it's five o'clock in the morning or just the fact that i suck
19:30:11 <linduxed> either way, i can't get this shit straight
19:31:59 <ski> well, is there something that's still not working ? or that you don't understand well ?
19:34:04 <linduxed> let's put it this way
19:34:41 <linduxed> right now i'm not sure of anything anymore, so i've deleted the stuff i was unsure about, and i've got this:
19:35:11 <linduxed> http://pastie.org/2261862
19:35:18 <linduxed> that's where i'm at
19:36:10 <linduxed> i know that the next line will most likely start with "splitWith pred xs", but i'm not sure, since maybe xs should be replaced with (x:xs)
19:36:23 <linduxed> depending on how this stuff should go down
19:36:48 <linduxed> i know that break is a handy way of splitting up things, but i have no idea how to stuff it in there
19:39:13 * ski figures out to change that link to <http://pastie.org/pastes/2261862/text>, to be able to see it
19:39:52 <ski> well, let's say you are wanting to evaluate
19:40:49 <ski>   splitWith (== ' ') "fee fi foo fum"
19:41:22 <ski> if you use `break', that will call
19:41:29 <ski>   break (== ' ') "fee fi foo fum"
19:41:33 <ski> which will evaluate to
19:41:41 <ski>   ("fee"," fi foo fum")
19:41:55 <ski> so, the first part of that pair is the first element of your output list
19:42:15 <ski> now you need to continue splitting the second part up into chunks, to get the rest of the output list
19:42:22 <ski> linduxed : does that help ?
19:42:25 <linduxed> mhm
19:42:32 <linduxed> that makes it easier, thx
19:42:34 <linduxed> hmmm
19:42:49 <linduxed> however one things
19:42:51 <linduxed> *thing
19:42:53 <ski> you'll need to dedide what to do with the initial space in the rest there
19:43:06 <linduxed> yeah that was exactly what i thought of
19:43:43 <linduxed> i somehow need to remove it
19:44:08 <linduxed> should i open up with a dropWhile pred  ?
19:44:25 <ski> that's one possibility
19:44:51 <ski> it all depends on what exactly you want `splitList' to do
19:45:06 <ski> do you want it to evaluate like
19:45:28 <ski>   splitWith (== ' ') "fee fi foo fum" = ["fee","fi","foo","fum"]
19:45:29 <ski> ?
19:45:30 <ski> or as
19:45:37 <ski>   splitWith (== ' ') "fee fi foo fum" = ["fee"," fi"," foo"," fum"]
19:45:38 <linduxed> well, the comment on top of the paste is all i have to go with
19:45:38 <ski> or as
19:45:47 <ski>   splitWith (== ' ') "fee fi foo fum" = ["fee ","fi ","foo ","fum"]
19:45:49 <ski> or as
19:46:00 <ski>   splitWith (== ' ') "fee fi foo fum" = ["fee"," ","fi"," ","foo"," ","fum"]
19:46:00 <ski> ?
19:46:19 <linduxed> splitWith (== ' ') "fee fi foo fum" = ["fee","fi","foo","fum"]
19:46:28 <ski> also, what should happen here if there's more than one space in a row ?
19:46:31 <linduxed> seems like it works the best with the comment provided
19:46:55 <ski> ok, so then i assume you also want
19:47:26 <linduxed> i'd assume one should treat multiples of the pred to be treated as one
19:47:35 <ski>   splitWith isDigit "foo1 bar234baz 56 78" = ["","1","234","56","78"]
19:47:35 <ski> ?
19:48:05 <ski> (or would you prefer to avoid having empty lists at the start and/or the end ?)
19:48:30 <linduxed> well now you inverted it
19:48:41 <ski> oh, i did
19:48:51 <ski> s/isDigit/(not . isDigit)/ :)
19:48:59 <ski> > words "fee fi foo fum"
19:49:00 <lambdabot>   ["fee","fi","foo","fum"]
19:49:03 <Matt040804> is there anything akin to list slicing in Haskell? do you just use "drop" and "take"?
19:49:06 <ski> > words " fee  fi foo   fum "
19:49:07 <lambdabot>   ["fee","fi","foo","fum"]
19:49:07 <linduxed> i would have expected that to result in ["foo"," bar","baz "," "]
19:49:15 <kmc> Matt040804, lists are not a random-access data structure
19:49:36 <kmc> yeah, people use "drop" and "take"
19:50:26 <ski> linduxed : not `["foo"," bar","baz "," ",""]', then ?
19:51:02 <Matt040804> okay, I'm trying to make a palindrome detecting function, so to split a list I'm just diving by the lenth and using drop and take
19:51:10 <Matt040804> is that the most logical way to do it?
19:51:24 <Matt040804> Or is there a Haskell idiom that I should be using?
19:52:11 <linduxed> ski: well... from what I understand in the comment provided (the comment and the signature was what was given) then the pred should be what splits the stuff apart
19:52:39 <ski> Matt040804 : one way is to `reverse' the list ..
19:52:44 <linduxed> ski: so from that information i gather that the splitWith isDigit ........ line should remove the numbers
19:53:40 <ski> linduxed : yeah .. i meant to write `splitWith (not . isDigit) "foo1 bar234baz 56 78"' above
19:54:29 <Matt040804> ski: oh my god, I'm an idiot...I was already doing that, but stupidly splitting the list first
19:55:17 <ion> > ((==) <*> reverse `on` filter isAlpha) "innostunut sonni"
19:55:18 <lambdabot>   Couldn't match expected type `b -> c'
19:55:18 <lambdabot>         against inferred type `GHC.Bo...
19:55:27 <linduxed> ok you know what... i'll start from the top then because this is just getting me confused
19:55:41 <linduxed> splitWith pred xs = first : splitWith rest
19:55:51 <linduxed> is that a sensible first line?
19:56:13 <linduxed> if i accompany that with a where and keep going downwards?
19:56:17 <ion> > ((==) <*> reverse) . filter isAlpha $ "innostunut sonni"
19:56:19 <lambdabot>   True
19:56:27 <ion> > ((==) <*> reverse) . filter isAlpha $ "foo"
19:56:28 <lambdabot>  Terminated
19:56:30 <Megant> linduxed: you need to pass pred to splitWith
19:56:34 <ion> > ((==) <*> reverse) . filter isAlpha $ "foo"
19:56:36 <lambdabot>   False
19:56:40 <linduxed> Megant: oh yeah thx
19:57:18 <ski> linduxed : with mine/Megant's suggestion, yes
19:59:19 <linduxed> hahahahah
19:59:24 <linduxed> i just did the following code
19:59:43 <linduxed> http://pastie.org/2261913.txt
20:00:39 <linduxed> i tried doing "splitWith odd [5,12,6,2,3,6,7]" and all i got was an endless output of [],[],[],[].......
20:01:25 <Cale> > break odd [5,12,6,2,3,6,7]
20:01:26 <lambdabot>   ([],[5,12,6,2,3,6,7])
20:01:43 <linduxed> haha, that explains it
20:04:53 <linduxed> hmmm, this doesn't do what i want :-(
20:09:00 <ski> hm
20:09:23 <ski> maybe you want `dropWhile (not . pred)' in there ?
20:09:42 <ski> linduxed ^
20:09:58 <linduxed> ski: i'll look into that
20:10:59 * BMeph wonders if the way "words" is illustrated would be relevant to linduxed's situation...
20:11:19 <ski> seeing how `(first, rest) = break pred xs' will make `all pred first = True', and `null rest || (not . pred . head) rest = True'
20:13:51 <Matt040804> Does anyone understand this paragraph from Real World Haskell? http://book.realworldhaskell.org/read/functional-programming.html#fp.framework
20:14:23 <linduxed> ski: yeah this code http://pastie.org/2261952 just spews out a ton of [] on the command splitWith odd [6,3,76,3,3,7,8,2,3,6,7,89,90]
20:15:21 <BMeph> Matt040804: I'm rather sure the authors understand it very well, but I think that doesn't help you. ;)
20:16:07 <Matt040804> Haha, well my issue is that I don't understand what I should be substituting for "id" in order to make the code compile
20:16:18 <ski> linduxed : hum, maybe i got that backwards (i'm a bit tired here)
20:16:47 <ski> > let splitWith _ [] = [[]]; splitWith pred xs = first : splitWith pred next where (first, rest) = break pred xs; next = dropWhile ( not . pred ) rest in splitWith odd [6,3,76,3,3,7,8,2,3,6,7,89,90]
20:16:49 <lambdabot>   [[6],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[...
20:16:57 <ski> > let splitWith _ [] = [[]]; splitWith pred xs = first : splitWith pred next where (first, rest) = break pred xs; next = dropWhile pred rest in splitWith odd [6,3,76,3,3,7,8,2,3,6,7,89,90]
20:16:58 <lambdabot>   [[6],[76],[8,2],[6],[90],[]]
20:17:07 <ski> ok, apparently i did get it backwards
20:17:32 <ski> linduxed : sorry about the `dropWhile (not . pred)', it seems `dropWhile pred' is sane
20:17:48 <ski> (too many negations to keep track of .. grmbl)
20:17:58 <linduxed> oh holy shit
20:18:07 <linduxed> could it be....
20:18:23 <jmcarthur> > break (=='a') []
20:18:24 <lambdabot>   ("","")
20:18:44 <jmcarthur> @src words
20:18:45 <lambdabot> words s = case dropWhile isSpace s of
20:18:45 <lambdabot>     "" -> []
20:18:45 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
20:19:12 <BMeph> Matt040804: Having "myFunction = id" should not affect your program compiling.
20:19:15 <ski> `break' and `span' will return a pair of empty lists only if given an empty list, and your base case makes sure you're not passing an empty list to `break', there
20:21:00 <linduxed> ski: ok some progress
20:21:12 <Matt040804> BMeph, hmm, I typed it in from the printed book, maybe I made an indentation error
20:21:41 <linduxed> ski: so with the following code http://pastie.org/2261977.txt i get splitWith odd [6,3,76,3,3,7,8,2,3,6,7,89,90] to work
20:21:49 <linduxed> so that's good
20:21:50 <linduxed> but
20:22:10 <linduxed> when i try to do splitWith (== ", ") ["foo, bar, rofu,,art"] it breaks
20:22:24 <linduxed> <interactive>:1:21:
20:22:24 <Matt040804> BMeph, yes, it was a typo preventing the compliation working
20:22:26 <linduxed>     Couldn't match expected type `[Char]' with actual type `Char'
20:22:27 <ion> (`elem` ", ")
20:22:38 <ski> s/pre /pred /
20:22:45 <Matt040804> It's difficult to detect a two-space indentation difference when reading out of a book
20:23:00 <ski> linduxed : ", "  is not a `Char'
20:23:07 <Matt040804> I should probably be using a ruler to test indentation
20:24:02 <linduxed> ion: thx that worked
20:24:07 <ski> linduxed : you have written a function that will break into chunks based on whether individual elements satisfy a predicate
20:24:27 <Nisstyre> Matt040804: what book are you reading that does that?
20:24:39 <ski> linduxed : writing something that breaks depending on whether subsequences satisfy a certain predicate is another thing
20:25:14 <Matt040804> Nisstyre: Real World Haskell
20:25:27 <Nisstyre> Matt040804: oh, I haven'y had any issues with the examples in there
20:25:30 <jmcarthur> is the goal for it to work like  splitWith (==' ') "foo bar baz" ==> ["foo", " bar", " baz"]  ?
20:25:32 <Nisstyre> *haven't
20:25:40 <jmcarthur> where the matching elements aren't removed?
20:25:48 <Nisstyre> do they really use two spaces? I hadn't even noticed.
20:25:52 <Matt040804> Nisstyre: I was trying to type in this example http://book.realworldhaskell.org/read/functional-programming.html#fp.framework
20:25:58 <linduxed> ski: tbh, i think that is correct
20:26:08 * hackagebot web-routes-quasi 0.7.1 - Define data types and parse/build functions for web-routes via a quasi-quoted DSL  http://hackage.haskell.org/package/web-routes-quasi-0.7.1 (MichaelSnoyman)
20:26:08 <Matt040804> and I missed the fact that they last line is two spaces less indented than the previous section
20:26:13 <Matt040804> *the
20:26:15 <Nisstyre> Matt040804: what editor are you using?
20:26:24 <Matt040804> Notepad ++
20:26:31 <linduxed> ski: i think the code does what it should, with the possible exception for always tacking on a [] on the end
20:26:42 <BMeph> Nisstyre: I think a hint is that the program was hand-typed, not cut-n-pastd in. :)
20:26:53 <Nisstyre> well, SciTE lines up indentation for you with vertical dotted lines
20:26:55 <Nisstyre> neat feature imo
20:27:07 <Nisstyre> notepad++ might have a similar plugin
20:27:10 <ski> linduxed : with the given type, it can't do anything else than break based on individial elements, right
20:27:30 <Matt040804> Yeah, I have no problem following indentation when writing code...notepade++ points that out too
20:27:31 <ski> linduxed : yeah, you're base case is strange :)
20:27:42 <BMeph> Nisstyre, Matt040804: Yes, Notepad++ uses vertical lines, not dotted, but still effective. :)
20:28:03 <Matt040804> I do have a problem with human eyesight not being able to notice a slight spacing difference seperated by five lines
20:28:24 <BMeph> Nisstyre: I believe the issue is that the indentation difference was not noticed in the original, not in the (typed) copy.
20:28:38 <BMeph> Matt040804: Did I get the right impression? :)
20:28:40 <Nisstyre> BMeph: oh that makes sense
20:28:46 <jmcarthur> > let splitWith f = uncurry (++) . (second.map) tail . splitAt 1 . groupBy (const $ not . f) in splitWith odd [6,3,76,3,3,7,8,2,3,6,7,89,90]
20:28:46 <linduxed> ski: 1.  break based on individual elements... isn't that what words does?  2.  well i won't be able to figure out a better one, i'm quite sure of that
20:28:47 <Matt040804> BMeph, yep
20:28:47 <lambdabot>   [[6],[76],[],[],[8,2],[6],[],[90]]
20:28:54 <jmcarthur> is that the intended behavior?
20:29:06 <Matt040804> If I hadn't copied and pasted from the website, I probably would have just given up
20:29:15 <Matt040804> But copy-paste isn't really that useful for learning
20:29:52 <linduxed> jmcarthur: yes, possibly without the inbetween []
20:29:52 <Nisstyre> Matt040804: I like to read what the book/tutorial/etc... intends to do, try to implement it myself, and then look at how they did it
20:29:57 <Nisstyre> assuming I know enough to implement it
20:30:13 <jmcarthur> > let splitWith f = filter (not . null) . uncurry (++) . (second.map) tail . splitAt 1 . groupBy (const $ not . f) in splitWith odd [6,3,76,3,3,7,8,2,3,6,7,89,90]
20:30:15 <lambdabot>   [[6],[76],[8,2],[6],[90]]
20:30:39 <ski> linduxed : your `splitWith' breaks based on a predicate on individual elements -- this as opposed to breaking on a predicate (or something) on subsequences of elements
20:30:42 <Nisstyre> Matt040804: but whatever works best for you
20:30:42 <jmcarthur> i am unhappy with my hacking around to drop the matching elements though
20:32:02 <ski> linduxed : what you have written is probably more or less what was expected (apart from the base case, possibly)
20:32:08 <Matt040804> Nisstyre: Exactly, "assuming I know enough to implement" that's what I'm trying to learn!
20:32:18 <ski> linduxed : i was just trying to think one step beyond what the stated task was
20:32:46 <ski> (linduxed : and your `splitWith (== ", ") ["foo, bar, rofu,,art"]' seemed to want to pass a predicate on subsequences)
20:37:07 <linduxed> ski: well i'm pretty satisfied with the way it is right now tbh
20:37:11 <linduxed> except for that base case
20:37:25 <linduxed> any suggestion on how to avoid that extra []?
20:38:01 <kniu> @pl (\x y z -> f (g x) (f y z))
20:38:01 <lambdabot> (. f) . (.) . f . g
20:38:34 <kniu> uh
20:38:38 <kniu> okay
20:38:42 <jmcarthur> > let splitWith f = filter (not . null) . unfoldr ((. null) =<< bool Nothing . Just . second (drop 1) . break f) in splitWith odd [6,3,76,3,3,7,8,2,3,6,7,89,90]
20:38:43 <lambdabot>   Not in scope: `bool'
20:38:45 <NihilistDandy> elegance~
20:38:46 <jmcarthur> bah
20:38:57 <jmcarthur> @let bool a b p = if p then a else b
20:38:58 <lambdabot>  Defined.
20:39:00 <jmcarthur> > let splitWith f = filter (not . null) . unfoldr ((. null) =<< bool Nothing . Just . second (drop 1) . break f) in splitWith odd [6,3,76,3,3,7,8,2,3,6,7,89,90]
20:39:02 <lambdabot>   [[6],[76],[8,2],[6],[90]]
20:39:54 <jmcarthur> perhaps the use of (=<<) is a bit much, but i'm happy with that otherwise, i think
20:40:25 <linduxed> jmcarthur: yeah... and you blew my tired mind with haskell way beyond my thinking
20:40:37 <linduxed> i'm sure i would be able to decipher that, but not know
20:40:49 <jmcarthur> > let splitWith f = filter (not . null) . unfoldr (\xs -> bool Nothing (Just . second (drop 1) $ break f xs) $ null xs) in splitWith odd [6,3,76,3,3,7,8,2,3,6,7,89,90]
20:40:51 <lambdabot>   [[6],[76],[8,2],[6],[90]]
20:40:56 <linduxed> i like mine better, more compatible with idiots like me :-)
20:40:58 <jmcarthur> ^^ without the (=<<)
20:41:43 <jmcarthur> i still don't like the second (drop 1) part. i see that as a bit of a hack. it's nicer than what i had earlier though
20:42:20 <jmcarthur> tail is probably safe to use though
20:42:21 <ski> linduxed : the simplest way to not add the extra `[]' is just to tell the base case not to do it :)
20:42:24 <jmcarthur> instead of drop 1
20:42:58 <linduxed> ski: hmmm, what would happen if i just removed the base case?
20:43:03 <linduxed> wait cancel that
20:43:05 <jmcarthur> linduxed: i'm just playing around. you don't have to take me too seriously right now
20:43:06 <linduxed> that was stupid
20:43:09 <ski> linduxed : you need a base case .. :)
20:43:19 <ski> but you could return a different value in it
20:43:22 <jmcarthur> linduxed: although it might be instructive for you to eventually try to understand it :)
20:43:36 <linduxed> jmcarthur: dude, i'm on my way there, just not today
20:43:40 <jmcarthur> heh
20:43:52 <ski> linduxed : as an experiment, make the base case say `splitWith _ [] = [[],[],[]]' -- what happens then ?
20:43:59 <linduxed> it's 6AM and i think i'm gonna get some sleep when i feel i'm done with this
20:44:22 <NihilistDandy> Sleep is for C programmers
20:44:35 <kniu> @pl (\x y z -> f (f (g x) y) z))
20:44:35 <lambdabot> (line 1, column 28):
20:44:35 <lambdabot> unexpected ")"
20:44:35 <lambdabot> expecting variable, "(", operator or end of input
20:44:40 * jmcarthur threadDelays
20:44:40 <kniu> @pl (\x y z -> f (f (g x) y) z)
20:44:40 <lambdabot> (f .) . f . g
20:44:58 <NihilistDandy> > sleep
20:44:58 <lambdabot>   Not in scope: `sleep'
20:45:11 <jmcarthur> :t threadDelay
20:45:12 <lambdabot> Not in scope: `threadDelay'
20:45:14 <jmcarthur> aw
20:45:17 <linduxed> ski: *Main> splitWith (`elem` ",") "foo, bar, rofu,,art"
20:45:22 <linduxed> ski: ["foo"," bar"," rofu","art","","",""]
20:45:26 <jmcarthur> :t Control.Concurrent.threadDelay
20:45:27 <lambdabot> Int -> IO ()
20:45:27 <ByronJohnson> @hoogle threadDelay
20:45:27 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
20:45:53 <jmcarthur> what an unfortunate type :\
20:45:58 <ski> linduxed : so, now there's three extra empty lists at the end
20:46:09 <linduxed> ski: kinda expected i think
20:46:12 <ski> linduxed : guess what to do to make there to be zero extra empty lists at the end ? :)
20:46:14 <jmcarthur> i wish it took a DiffTime or NominalDiffTime or something
20:46:39 <linduxed> ski: i don't know... i thought  [] is as little as you can go
20:46:45 <ski> it is
20:46:50 <ski> but you haven't tried that yet
20:47:00 <linduxed> i've tried [[]]
20:47:05 <jmcarthur> that's not []
20:47:08 <applicative> [[]] isn't as little as you can go
20:47:11 <ski> which is a list containing *one* empty list
20:47:13 <linduxed> hmm, i guess...
20:47:17 <applicative> > length [[]]
20:47:17 <lambdabot>   1
20:47:25 <NihilistDandy> > lenghth []
20:47:25 <lambdabot>   Not in scope: `lenghth'
20:47:30 <NihilistDandy> > length []
20:47:30 <lambdabot>   0
20:47:41 <NihilistDandy> > print derp.jpg
20:47:42 <lambdabot>   Not in scope: `derp'Not in scope: `jpg'
20:47:45 <applicative> > length [] :: [[[[Int]]]]
20:47:45 <lambdabot>   Couldn't match expected type `[[[[GHC.Types.Int]]]]'
20:47:45 <lambdabot>         against inferr...
20:47:47 <linduxed> omg
20:47:52 <linduxed> finally
20:47:55 <linduxed> it works
20:47:58 * ski grins
20:48:03 <applicative> > length ( [] :: [[[[Int]]]])
20:48:03 <lambdabot>   0
20:48:08 <linduxed> fuck me.... that only took 3 hours
20:48:23 <BMeph> > length [[],[]] -- hint, hint
20:48:23 <lambdabot>   2
20:48:31 <linduxed> ski: jmcarthur thx a lot
20:48:42 <NihilistDandy> > take 5 $ replicate "clap... "
20:48:43 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
20:48:43 <lambdabot>         against inferred type ...
20:48:47 <applicative> > length $ map (const []) [1..20]
20:48:48 <lambdabot>   20
20:48:48 <linduxed> i think that will do for this day's coding session
20:48:50 <NihilistDandy> > take 5 $ repeat "clap... "
20:48:52 <lambdabot>   ["clap... ","clap... ","clap... ","clap... ","clap... "]
20:48:52 <jmcarthur> linduxed: you will get better at this stuff. it takes some time to get used to thinking functionally
20:48:53 <applicative> > map (const []) [1..20]
20:48:53 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]]
20:48:55 <ski> > length (fix ((:[]) . In))
20:48:56 <lambdabot>   1
20:48:56 <NihilistDandy> Slow clap
20:49:07 <linduxed> jmcarthur: sure hope so...
20:49:55 <applicative> @type In
20:49:56 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
20:49:58 <kniu> @pl (\(x, y) z -> f x y z)
20:49:59 <lambdabot> uncurry f
20:49:59 <applicative> figures
20:50:12 <kniu> @hoogle uncurry
20:50:12 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
20:50:13 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> (a, b) -> c
20:50:42 <NihilistDandy> Odd
20:50:46 <ryant5000> is there a function for getting the free variables in a Haskell expression parsed by haskell-src-exts?
20:50:46 <ski> > length (fix (repeat . In))
20:50:54 <NihilistDandy> @src Data.Tuple.uncurry
20:50:54 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
20:50:58 <ryant5000> (i couldn't find one in haskell-src-exts itself, and hoogle didn't turn anything up)
20:51:00 <NihilistDandy> @src uncurry
20:51:01 <lambdabot> uncurry f p = f (fst p) (snd p)
20:51:01 <lambdabot>   thread killed
20:51:34 <ski>   uncurry f ~(x,y) = f x y  -- alternatively
20:52:25 <ski> > uncurry (const . const ()) undefined
20:52:26 <lambdabot>   ()
20:52:34 <NihilistDandy> I'm just curious what the differences between the Prelude and Data.Tuple ones are
20:52:50 <ski> i would assume there's no difference
20:52:58 <ski> @source Data.Tuple
20:52:58 <lambdabot> http://darcs.haskell.org/packages/base/Data/Tuple.hs
20:54:16 <ski> @source Prelude
20:54:16 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
20:54:31 <ski> that seems to just reexport `Data.Tuple.uncurry', in GHC
20:54:52 <NihilistDandy> Noticed that just now :D
21:03:43 <zzing> Does anyone know if haskell platform has issues with lion?
21:09:44 <applicative> ryant did you look in the GHC package http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/ghc-api/CoreFVs.html
21:09:58 <applicative> ryant5000: ^^^
21:10:00 <NihilistDandy> zzing: Yes, it does
21:10:16 <NihilistDandy> Work is being done
21:10:22 <ryant5000> applicative: is it possible to use that stuff as part of a preprocessor?
21:10:23 <applicative> there are a number of things like that
21:10:35 <zzing> man, I want some functional language I can experiment with the ios that is stable enough for production
21:11:37 <zzing> I see some complex setup for ocaml, a little bit of haskell. Even microsoft has F# that can be used with xna :P
21:11:54 <ryant5000> zzing: my company ported ghc to iphone a while back
21:12:02 <ryant5000> zzing: our port's a bit out of date now, though
21:12:07 <zzing> ryant5000: that is an issue
21:12:32 <zzing> Realistically, for me to really use it, it should have near first class support
21:12:51 <ryant5000> zzing: hm; well, that may be difficult to find
21:12:59 <ryant5000> zzing: what are you hoping to use it for?
21:13:04 <zzing> Certainly
21:13:13 <applicative> zzing javascript!
21:13:46 <zzing> I have a game idea that can be implemented with opengl es (mainly vector graphics), that I think would work well with a certain purity :P
21:14:04 <zzing> I really like much of objective C, but some times it isn't the best
21:15:23 <ryant5000> zzing: well, our port does work, and we're working on updating it to GHC 7 and LLVM, although that's not our top priority
21:15:39 <zzing> ryant5000: I am really interested in the LLVM stuff
21:16:00 <zzing> ryant5000: does your port work with certain things that cannot be discussed too openly?
21:16:17 <ryant5000> zzing: no, it's all open-source
21:16:23 <ryant5000> BSD
21:16:31 <zzing> ryant5000: you don't quite get my meaning
21:16:43 <zzing> the [REDACTED] kind of thing
21:16:52 <ryant5000> well, we're a game company
21:17:05 <ryant5000> our current project has a lot of secret bits
21:17:13 <zzing> ios5 is what I mean :P
21:17:14 <ryant5000> but generally speaking, it's an RPG
21:17:18 <ryant5000> oh, lol
21:17:41 <danharaj___> talk about general :p
21:17:43 <ryant5000> i haven't tried it recently; i'll have to ask the guy who's working on it
21:17:51 <ryant5000> danharaj___: lol
21:17:52 <danharaj___> wow, I had really unstable internet while I was gone.
21:18:18 <zzing> ryant5000: well, I guess the main questions are - where is it located, will it run in the simulator and are there any problem using it on lion?
21:18:51 <ryant5000> http://projects.haskell.org/ghc-iphone/
21:18:53 <ryant5000> it's located there
21:19:01 <ryant5000> with a mailing list here
21:19:02 <ryant5000> http://projects.haskell.org/cgi-bin/mailman/listinfo/ghc-iphone
21:19:12 <ryant5000> i haven't tried it on lion
21:19:21 <ryant5000> and, yes, it supports the simulator
21:19:32 <zzing> hmm, well it might be worth trying :P
21:20:46 <zzing> This looks complicated
21:21:10 <ryant5000> zzing: yeah, it's not as simple as one might wish
21:21:15 <NihilistDandy> zzing: ghc wouldn't even build correctly with versions of Xcode > 4.0.2, unless things have changed
21:21:31 <zzing> Which means I am not going to do it on this system
21:21:32 <ryant5000> NihilistDandy: that may be right; we run on a fairly old version of xcode
21:21:37 <zzing> I will have to wait
21:21:50 <NihilistDandy> I switched back to SL just to be able to write Haskell again
21:22:01 <ryant5000> however, you might try sending an email to our mailing list; Steve Blackheath (our guy who works on it) has some tweaks that might allow it to run on newer systems
21:22:06 <zzing> I don't think I could go back :P
21:22:15 <ryant5000> i'm not sure how new, though
21:22:30 <zzing> ryant5000: I am curious what the business case for using haskell for a game on ios is though :p
21:23:01 <ryant5000> zzing: we don't plan to limit ourselves to ios
21:23:15 <ryant5000> zzing: so long as we were going to be porting something, we figured it might as well be haskell :)
21:23:34 <zzing> isn't ghc a beast?
21:23:48 <ryant5000> to port?
21:23:49 <ryant5000> not really
21:23:49 <NihilistDandy> Yes?
21:24:00 <kmc> hmm, data Data.Vector.Storable.MVector !(Ptr a) !Int !(ForeignPtr a)
21:24:02 <NihilistDandy> I don't know what sense you mean "beast" in
21:24:04 <ryant5000> the initial port was much easier than we expected
21:24:05 <kmc> why both Ptr and ForeignPtr?
21:24:14 <kmc> is the ForeignPtr just kept for finalization, and the Ptr used for access?
21:24:20 <zzing> I recall something about jhc doing iphone, do you recall anything about it or its status?
21:24:28 <ryant5000> zzing: no, i'm not sure
21:24:45 <ryant5000> i do remember it coming out, but i haven't used it
21:26:03 <zzing> I think I will send an email, I remember jhc from so long ago. I do like the idea of portability through haskell
21:26:24 <zzing> I was thinking actually of ocaml, because it has a certain use case that makes it easier for my imperative mind :P
21:26:35 <zzing> But I don't think ocaml is going anywhere very fast
21:26:57 <kmc> zzing, Haskell is a good imperative language
21:26:58 <NihilistDandy> Ick, imperative mind
21:27:03 <kmc> but it does take more work to get to that point than with ocaml
21:27:12 <kmc> also yes, ocaml is not going anywhere
21:27:12 <zzing> NihilistDandy: I believe a song could be made
21:27:17 <NihilistDandy> :D
21:27:22 <NihilistDandy> Imperative State of Mind
21:27:26 <zzing> ocaml has ; !
21:27:44 <kmc> as much flack as Haskell gets for being the egghead language... which lang still has their main website hosted at a uni domain? ;P
21:27:47 <ryant5000> zzing: Haskell has monads; i'll take them any day of the week :)
21:28:06 <zzing> kmc, burn!
21:28:10 <kmc> the way Haskell handles IO would be good even if nobody noticed it was a moand
21:28:11 <ski> kmc : Charity ?
21:28:12 <kmc> monad*
21:28:18 <ryant5000> kmc: that's true
21:28:23 <kmc> the monadic interface is secondary
21:28:25 <NihilistDandy> kmc: Whose?
21:28:30 <kmc> (and you could implement said interface in ocaml, too)
21:28:34 <kmc> NihilistDandy, OCaml
21:28:51 <NihilistDandy> Oh, I didn't realize INRIA was a university
21:28:57 <zzing> I am curious about that agda lovely. Could it ever do what a mainstream language does now?
21:29:04 <kmc> hmm, i guess it's not technically?
21:29:30 <kmc> Inria est un organisme public de recherche, dédié aux sciences et technologies du numérique.
21:29:40 <NihilistDandy> zzing: "Agda will be a better theorem prover than Coq when it's a better programming language than Haskell" :D
21:29:44 <kmc> haha
21:29:51 <zzing> So never?
21:30:00 <kmc> burn
21:30:54 <NihilistDandy> I dunno. I'm not particularly down on Agda, by any means. I just think the quote is a pleasant mix of humorous, biting, and hopeful.
21:30:57 <zzing> kmc, Alors pourquoi ne pas l'Organisme ne Haskell?
21:31:10 <ski> @babel fr en Inria est un organisme public de recherche, dédié aux sciences et technologies du numérique.
21:31:10 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
21:31:21 <zzing> you need a translation to read that?
21:31:30 <zzing> I thought it was clear :P
21:31:38 <NihilistDandy> @babel fr en "Inria est un organisme public de recherche, dédié aux sciences et technologies du numérique."
21:31:38 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
21:31:43 <NihilistDandy> It is clear
21:31:50 <zzing> INRIA is a public research organization, dedicated to science and digital technologies."
21:32:02 <NihilistDandy> I'm just curious why @babel's not working
21:32:10 <kmc> it's safe to create a ForeignPtr p and then return functions which close over "withForeignPtr p", right?
21:32:21 <kmc> GHC isn't going to do some magical execution-under-lambda business is it?
21:32:39 <kmc> (i would hope not, because doing so could have effects in general)
21:33:15 <ion> @quote
21:33:15 <lambdabot> scsibug says: i could have sworn it was incorrect until it type-checked
21:33:40 <kmc> haha
21:33:49 <scsibug> :)
21:33:53 <NihilistDandy> @quote
21:33:53 <lambdabot> DavidAmos says: the real reason for using Haskell is that the code comes out shorter, and is quicker to write, than in imperative languages .. What that means is, I can get much more done when I use
21:33:53 <lambdabot> Haskell
21:34:03 * NihilistDandy yawns
21:34:08 <NihilistDandy> @quote NihilistDandy
21:34:08 <lambdabot> NihilistDandy says: The best part of Haskell is that 80% of module names can be turned into clever blog titles.
21:34:16 <NihilistDandy> Damn, I thought I had another one that was better
21:34:19 <NihilistDandy> @quote NihilistDandy
21:34:19 <lambdabot> NihilistDandy says: The best part of Haskell is that 80% of module names can be turned into clever blog titles.
21:34:24 <NihilistDandy> No, I guess it's just that one :/
21:34:46 <NihilistDandy> I'll just have to be cleverer
21:35:03 <zzing> hmm, last time jhc had a commit was 01 Feb
21:35:21 <danharaj_> @quote danharaj
21:35:22 <lambdabot> danharaj says: unsafeCoerce should be renamed to badPun
21:35:25 <danharaj_> @quote danharaj
21:35:26 <lambdabot> danharaj says:  The industry wields types like an ancient weapon of forgotten technology.
21:35:31 <danharaj_> @quote danharaj
21:35:32 <lambdabot> danharaj says: phd programs are one-way functions. They're easy to get into and hell to get out of ;)
21:35:59 <NihilistDandy> zzing: You should write your own bindings :D
21:36:09 <NihilistDandy> Or talk to dankna. He might have some ideas
21:36:22 <zzing> NihilistDandy: I can deal with bindings, but I need a working compiler first
21:36:37 <NihilistDandy> zzing: Oh, that.
21:36:44 <NihilistDandy> Wait or downgrade, I guess.
21:36:50 <zzing> If it were to be jhc - I obviously don't want to use a dead compiler :P
21:36:50 <NihilistDandy> I already submitted a bug report
21:37:01 <zzing> I must wait
21:37:25 <zzing> Perhaps I must use C++
21:37:37 <kmc> noooo
21:37:45 <NihilistDandy> Nuuuu
21:37:46 <kmc> jhc is not dead per se
21:38:04 <zzing> kmc, presently being embalmed?
21:38:05 <NihilistDandy> zzing: What problem have you had installing the platform?
21:38:22 <kmc> it's just not very actively developed
21:38:26 <kmc> it's mostly one guy's personal project
21:38:30 <zzing> NihilistDandy: I didn't have any - because I haven't installed it. I am going on what I see here.
21:38:45 <NihilistDandy> Well, you could always... try
21:38:47 <zzing> I am not going to install something that will not work anyways
21:39:03 <zzing> At least I am not going to try google go
21:39:05 <NihilistDandy> There's no guarantee it won't work. It's just highly likely
21:39:36 <NihilistDandy> Also, there's a workaround for the issue
21:39:39 <NihilistDandy> http://hackage.haskell.org/trac/ghc/ticket/5293
21:40:26 <NihilistDandy> It's 7.4.1 milestone, though, so it could be a while
21:41:40 <zzing> I find it rather surprising, considering the platforms importance
21:42:03 <NihilistDandy> FSVO "importance"
21:42:34 <zzing> I would expect a not insignificant number of haskell developers to be on the mac tbh
21:42:47 <NihilistDandy> That's true.
21:43:34 <NihilistDandy> But they also have options while the bug is being worked out
21:44:00 <NihilistDandy> Even just a small SL partition would solve things handily in the meantime
21:44:44 <kmc> SL?
21:44:54 <NihilistDandy> Snow Leopard
21:45:10 <kmc> heh
21:45:22 <kmc> i was like "...Scientific Linux? Why that distro in particular?"
21:45:37 <NihilistDandy> lol
21:45:42 <NihilistDandy> That would be very odd
21:46:00 <NihilistDandy> I AM VERY PARTICULAR ABOUT MY PARTITIONS
21:46:05 <kmc> is it illegal to have concurrent SL and L partitions if you bought the latter with an "upgrade" license?
21:46:24 <NihilistDandy> I dunno. I don't see how it could be.
21:46:31 <NihilistDandy> You own both of them, after all
21:47:21 <kmc> afaik there's no reason they can't sell you a license to Y which only becomes valid by destroying a license to X
21:47:22 <NihilistDandy> I'd probably just use a live CD or a VM, truth be told
21:47:39 <NihilistDandy> kmc: Except that it would be silly and unenforceable
21:47:40 <kmc> i assumed that's how software upgrade pricing works in general, otherwise it would be no cheaper
21:48:00 <kmc> well yes it would be unenforceable, so are the licenses in the first place
21:48:15 <NihilistDandy> I suppose it may be the case, but I've seen nothing indicating it as such
21:48:28 <zzing> What think you guys of erlang?
21:48:36 <NihilistDandy> In short: ¯\(°_o)/¯
21:48:42 <NihilistDandy> zzing: It seems neat
21:48:50 <NihilistDandy> I've only played with it a little, though I idle in their channel
21:49:13 <NihilistDandy> Discussion is a little less... high-brow?... than here
21:52:03 <zzing> I just noticed that an explicit erlang ios release exists, but there was a mention of needing jailbreak
21:52:04 <NihilistDandy> And the room goes silent~
21:53:51 <gienah> zzing: the message passing stuff in erlang is great, cloud haskell/remote implements erlang like messaging in haskell: https://github.com/jepst/CloudHaskell/
21:55:14 <stobix> gienah: ooh... Do want!
21:55:20 <zzing> I think it will all have to wait until some future utopia when everything runs on haskell
21:55:35 <gienah> zzing: this is a interesting article on erlang and haskell: http://jlouisramblings.blogspot.com/2010/04/haskell-vs-erlang-for-bittorent-clients.html
21:56:07 <NihilistDandy> gienah: That actually looks much better than the rather lackluster chatter on the Cafe led me to believe :D
22:01:43 <zzing> are there any examples of simple functional style languages targetting llvm  that could be extended with c?
22:02:17 <zzing> perhaps i should extend this concept to language designs that are not necessarily implemented :P
22:03:12 <kmc> Haskell can be extended with C and has LLVM-targetting compilers
22:03:17 <kmc> however Haskell is not a particularly simple language
22:03:52 <zzing> kmc, I know, that is why I ask for simple.
22:04:06 <zzing> I will be honest - haskell blows my mind, and it doesn't take too long to go into it to do it
22:04:14 <zzing> The complexity of C++ blows my mind too
22:04:17 <kmc> yes
22:04:34 <kmc> there are also aspects of Haskell which are conceptually simple but still hard to implement (and implement efficiently, etc.)
22:04:52 <kmc> the graph-reduction model of lazy evaluation is a lot simpler than all the hoops jumped through to make it run well on modern CPUs
22:04:53 <zzing> sure
22:05:10 <zzing> I don't really need lazy evaluation
22:05:33 <kmc> similarly it's easy to understand type inference conceptually but dealing with all the corner cases is very subtle
22:05:47 <kmc> zzing, your best bet might be some Scheme implementation
22:05:56 <kmc> writing a Scheme compiler in Haskell is a decent intermediate-level project
22:06:09 <kmc> a Scheme interpreter is a decent "advanced beginner" project; there's a tutorial along those lines
22:06:12 <zzing> If I had to take certain things and leave the rest, I would definitely take typeclasses, the 'data' keyword. For simplicity, taking the ref keyword from ocaml and the ; is not a bad start
22:06:37 <zzing> kmc, I am not writing a scheme anything, I find the language to be hideous
22:06:44 <NihilistDandy> Why?
22:06:45 <kmc> also here by "Scheme" i mean "some nice pretty language resembling Scheme" and not "all of R5RS" or god forbid R6RS
22:06:49 <kmc> in before parentheses
22:06:56 <zzing> ((((())))))
22:07:08 <kmc> zzing, ok, replace that with whitespace.  trivial syntactic issue
22:07:12 <zzing> lisp is hideous for the same reason :P
22:07:12 <NihilistDandy> :t [[[[[]]]]]
22:07:12 <lambdabot> forall a. [[[[[a]]]]]
22:07:23 <zzing> I think fortran would be an interesting language to implement
22:07:25 <kmc> :t fix (In . (:[]))
22:07:26 <lambdabot> Mu []
22:07:35 <kmc> zzing, yes, if you're interested in backend optimization
22:07:42 <kmc> and autovectorization etc
22:07:51 <zzing> kmc, that is for llvm to deal with isn't it?
22:07:55 <kmc> shrug
22:08:11 <kmc> the whole point of fortran is to take some science and make it run insanely fast across a huge cluster
22:08:13 <zzing> I am interested in the practical side of languages - which for me means that syntax
22:08:21 <kmc> it is a formula translator, not a general-purpose language
22:08:23 <zzing> kmc, that is one option :P
22:08:26 <NihilistDandy> zzing: http://www.fortran.com/F77_std/rjcnf.html
22:08:28 <NihilistDandy> Have fun with it
22:08:31 <kmc> at least that's the role in which people still care about it
22:08:52 <zzing> NihilistDandy: I don't use f77, f90 is the earliest I would go
22:08:57 <kmc> i think it would be fun to implement some primitive-recursive loops-and-matrices language vaguely resembling fortran
22:09:42 <Codex_> f(x)=g(y).
22:09:46 <NihilistDandy> zzing: The practical side of languages for you is *syntax*?
22:09:46 <kmc> in fact, it would be fun to implement a PR language where all loops are JITted just before entry
22:10:00 <kmc> NihilistDandy, it is practical in that it's what users of your language will talk about
22:10:01 <zzing> NihilistDandy: yes, because it is your first exposure to it
22:10:27 <zzing> I don't care how it is implemented underneath (unless I have to implement it)
22:12:40 <zzing> If there were a language that defined minimal types, like say used doubles for numbers, something to deal with strings (unicode of course), basic list types, an array (think integration with opengl es) and a ; operator for the imperative needs. Probably need some kind of record or 'data' type for storing collections of data. That is the most basic list of stuff I can come up with for a functional style la
22:12:41 <zzing> nguage. It might pique my interest enough to test it out
22:13:01 <kmc> sounds like javascript
22:13:07 <kmc> or like scheme with different syntax
22:13:23 <kmc> try to get past the parentheses and scheme semantics
22:13:25 <kmc> and learn*
22:13:41 <zzing> kmc, I would not be opposed to trying to shoehorn something established like scheme into a haskellish syntax :P
22:14:18 <kmc> i really just find all discussion of scheme syntax tedious
22:14:18 <zzing> I wouldn't be surprised if a scheme has already targetted llvm
22:14:23 <kmc> not just on the "anti" side
22:14:40 <kmc> there's the proponents who say "lisp and scheme have no syntax" who are just factually incorrect
22:14:55 <NihilistDandy> I find most discussion of syntax tedious
22:14:55 <kmc> it's not just parens, you have to know the structure of each special form
22:14:59 <NihilistDandy> Regardless of language
22:15:03 <zzing> I just have no interest in s-expressions because it doesn't feel easy to read to me.
22:15:15 <zzing> Haskell is the definition of beautiful syntax
22:15:17 <zzing> to me
22:15:49 <kmc> zzing, but all languages are trees like that under the hood
22:15:57 <kmc> so define your own concrete syntax and get over it
22:16:17 <NihilistDandy> Write a MIPS interpreter in Haskell
22:16:20 <kmc> zzing, I like Haskell syntax but it's not the "definition of beautiful"
22:16:27 <kmc> there are things i don't like and nice features it's missing
22:16:29 <zzing> heh
22:16:41 <zzing> my views are from my limited exposure
22:16:59 <NihilistDandy> Everytime someone talks to zzing, I think they're delivering notice of a sick burn to come in the future
22:17:05 <kmc> it is my favorite syntax of the languages i can use regularly for getting shit done, though
22:18:50 <lewis1711> what is the [m..n] list generator thing called? sorta hard to search for
22:19:35 <kmc> lewis1711, i don't know, but it desugars to a call to enumFromTo
22:19:37 <zzing> Here we go: http://www.ida.liu.se/~tobnu/scheme2llvm/
22:19:41 <kmc> check the Haskell Report for the official name and definition
22:19:45 <kmc> > enumFromTo 3 7
22:19:46 <lambdabot>   [3,4,5,6,7]
22:20:22 <alxbl> lewis1711: isn't it just a range?
22:20:43 <zzing> Looking at the code, I could see how haskell syntax could be used for some of this
22:21:22 <zzing> hell with a 'layout' with whitespace, half the parens aren't even needed. I see some python look possible too.
22:21:54 <NihilistDandy> zzing: If you want to make some other language look like a language you like, just do that
22:22:43 <lewis1711> thanks kmc
22:23:09 <zzing> I certainly can now with the stuff I have found. I must sleep now so I will get out of your hairs :p
22:23:31 <kmc> zzing, whitespace in Haskell desugars to a form with explicit delimiters
22:23:33 <kmc> which is important
22:23:48 <lewis1711> map toEnum [fromEnum x .. fromEnum y] --even its desugaring has sugar! :D
22:23:55 <kmc> haha
22:24:43 <zzing> kmc, I believe even python does that
22:25:27 <kmc> zzing, not entirely
22:25:36 <kmc> there's not always a whitespace-independent form you can actually feed into a python implementation
22:25:39 <kmc> i could be wrong
22:26:07 <kmc> but (for example) the reason 'lambda' is crippled is that there's no syntax for statements in expressions
22:27:45 <zzing> statements seem evil anyways
22:28:32 <NihilistDandy> Elaborate
22:28:35 <kmc> Haskell has them
22:28:48 <kmc> but they're optional sugar
22:29:12 <kmc> and (importantly) you can use a sequence of statements as an expression
22:29:17 <kmc> indeed, it's the only way to use a sequence of statements
22:29:29 <zzing> Well, it seems to me that there is more elegance possible where everything is an expression
22:29:39 <kmc> that is something C sorely needs; it's one of the most important extensions provided by GCC
22:29:55 <zzing> extension that does that?
22:29:58 <kmc> yes
22:30:04 <zzing> never heard of it
22:30:06 <kmc> "statement expressions"
22:30:14 <lewis1711> what's the difference between a statement and expression? an expression returns a value?
22:30:22 <kmc> lewis1711, in Haskell or in general?
22:30:26 <lewis1711> in general
22:30:42 <kmc> yeah, that's part of it
22:30:55 <zzing> looks difficult tbh
22:31:01 <lewis1711> I always just thought "everything is an expression" is the reason haskell, ruby, etc don't need a "return" keyword
22:31:02 <kmc> in C a statement is an expression, "return", "if", "while", etc.
22:31:14 <kmc> ruby doesn't have a return kw?
22:31:22 <shachaf> It does.
22:31:22 <lewis1711> it has one, but it's not needed
22:31:29 <kmc> anyway Haskell has statements and no return keyword
22:31:35 <shachaf> Well, except for early-return.
22:31:43 <kmc> because statements are sugar at a superficial level, so "return" is an ordinary function
22:31:57 <shachaf> Yes; if you need to return early, you need to implement it yourself (e.g. with Cont). :-)
22:32:16 <lewis1711> so a statement can be an expression. i see
22:32:24 <shachaf> kmc: The ordinary function "return" is badly named. I don't know if drawing analogies between it and C's return is a good idea.
22:32:36 <kmc> shachaf, lewis1711 brought it up
22:32:41 <kmc> lewis1711, which direction do you mean?
22:32:43 <shachaf> lewis1711: A "statement" is just a value that describes a certain behavior.
22:32:56 <shachaf> s/behavior/effect/
22:32:58 <kmc> shachaf, no, I'd say that "statement" is a purely syntactic idea and thus not a "value"
22:33:00 <ion> In “good” Ruby, returns should be used sparingly like exceptions, break etc: as a way to jump out of normal control flow. Not for having expressions return values.
22:33:12 <ion> s/Not for/Not just for/
22:33:23 <kmc> lewis1711, in C and in Haskell, an expression may be used as a statement
22:33:23 <shachaf> kmc: Hmm. I meant "what people refer to/use syntactically as statements in Haskell".
22:34:15 <kmc> in C it means "evaluate this expression (performing side-effects) and throw away the results".  in Haskell within IO it means "evaluate this expression (no side effects, of course) and then execute the actions described by the value it produces"
22:34:23 <zzing> ion, like in "good" objective C, you don't use exceptions :P
22:34:36 <zzing> I love the idea of the haskell Maybe, Either types.
22:34:46 <kmc> lewis1711, in standard C a statement may not be used as or within an expression
22:34:54 <zzing> But I am not sure in the 'real world' you would implement a non-nullable type
22:35:04 <kmc> in Haskell a statement may be used in an expression:  «do { stmt; stmt; stmt }»  is  an expression
22:35:22 <kmc> zzing, "non-nullable type" is an insane contortion of language
22:35:31 <lewis1711> kmc: you said a statement can't be in an expression in standard C
22:35:37 <zzing> kmc, can you elaborate?
22:35:44 <kmc> lewis1711, an expression may be used as a statement; a statement may not be used as an expression
22:35:53 <kmc> lewis1711, they are different nodes within the grammar that defines C syntax
22:35:57 <ion> When Haskell’s Pointed/Functor/Monad/Applicative classes are finally fixed, there’s no return anymore. ;-)
22:36:01 <lewis1711> but isn't a for loop an expression? for (int i = 0; i < len; i++). ...isn't int i = 0 a statement?
22:36:19 <kmc> a for loop is not an expression
22:36:21 <copumpkin> what does a for loop return?
22:36:37 <kmc> you can't say «printf("foo", for (;;) { })»
22:36:41 <zzing> ion, when they are fixed they will be unable to reproduce
22:36:45 <lewis1711> then how can if or while be an expression?
22:36:50 <lewis1711> what does if return?
22:36:51 <kmc> can't
22:37:13 <lewis1711> kmc: in C a statement is an expression, "return", "if", "while", etc.
22:37:26 <kmc> that's the "expression may be used as a statement" direction
22:37:29 <kmc> sorry for the ambiguity
22:37:35 <kmc> int main() { printf("foo"); return 0; }
22:37:36 <lewis1711> ah
22:37:44 <kmc> main consists of two statements: an expression statement and a return statement
22:37:54 <kmc> «printf("foo")» is an expression
22:38:04 <lewis1711> what does it return?
22:38:06 <kmc> and the meaning of an expression as a statement is "evaluate this and then throw out the result"
22:38:11 <lewis1711> oh
22:38:28 <kmc> lewis1711, it returns the number of characters printed, iirc
22:39:43 <kmc> with GCC's "statement expressions" extension, the expression has void type unless the last statement is an expression statement
22:39:51 <kmc> in which case it's the value of that expression
22:40:20 <lewis1711> I'm often tempted to use gcc extensions
22:40:41 <NihilistDandy> I'm often tempted to try methamphetamine~
22:40:50 <kmc> #define max(a,b) ({ typeof(a) __a = (a);  typeof(b) __b = (b);  (a < b ? b : a) })
22:40:58 <kmc> err
22:40:59 <lewis1711> NihilistDandy: yeah but the difference is gcc extensions are free
22:41:00 <NihilistDandy> It's bad for me, but I GET SO MUCH MORE WORK DONE~
22:41:02 <kmc> should be __a and __b at the end
22:41:09 <kmc> #define max(a,b) ({ typeof(a) __a = (a);  typeof(b) __b = (b);  (__a < __b ? __b : __a) })
22:41:19 <NihilistDandy> lewis1711: Well, you've got me there
22:41:25 <kmc> haha
22:41:35 <pikhq_> lewis1711: Avoid most GCC extensions; you'll only regret them.
22:41:36 <kmc> amphetamines are free if you have health insurance
22:41:48 <kmc> pikhq_, that depends on what you're doing...
22:41:52 <pikhq_> kmc: True, true.
22:41:58 <lewis1711> pikhq_: why?
22:42:06 <kmc> Linux is chock full of GCC extensions and I don't think they could be removed without serious compromises
22:42:11 <lewis1711> pure looks really handy
22:42:12 <kmc> not most of them anyway
22:42:14 <NihilistDandy> pikhq_: Just like meth
22:42:28 <ion> Nothing wrong whatsoever with many GCC extensions. Of course, it might be a good idea to #ifdef them away if not supported by the compiler.
22:42:32 <pikhq_> kmc: Some of them could be removed easily. Some of them are pretty handy. A few are utterly *essential*.
22:42:54 <kmc> of course, Linux is not your typical C program -- it's kind of a stretch to say it's written in C at all
22:43:02 <pikhq_> lewis1711: BTW, I'd consider *most* of the attributes to be GCC extensions you can use like candy.
22:43:04 <kmc> for example they shoehorn an extra scoping level into the language with linker tricks
22:43:09 <kmc> and the result is even fairly pleasant to use
22:43:47 <lewis1711> shoulda just bit the bullet and used C++ ;)
22:43:54 <kmc> now you have two problems
22:43:58 <lewis1711> ...I'll see myself out before the lynching
22:44:00 <kmc> haha
22:44:16 <NihilistDandy> 99++ problems...
22:45:11 <ion> 99++; printf ("%d\n", 99);
22:45:12 <ion> 100
22:45:20 <pikhq_> lewis1711: The main reason you should avoid GCC extensions is that many of the GCC extensions are *not needed*.
22:45:23 <azaq23> but a glitch ain't one
22:45:28 <c_wraith> ion, that's more of a fortran thing :)
22:45:33 <kmc> -fheinous-gnu-extensions
22:45:52 <pikhq_> Also, down that road leads Autoconf.
22:45:56 <NihilistDandy> azaq23: THANK YOU
22:46:04 <kmc> > let 99 = 100 in "problems"
22:46:05 <lambdabot>   "problems"
22:46:09 <zzing> If you like programming history stories: http://www.fortranstatement.com/Site/responses.html
22:46:39 <NihilistDandy> zzing: I ~live~ for them
22:46:41 <pikhq_> (because it is actually impossible to do a preprocessor check for GCC extensions. What you have is a single preprocessor check for whether or not it's "GNU C", which can mean any compiler supporting at least one GCC extension.)
22:46:57 <lewis1711> I tried to pick up basic fortran the other week. gave up and learned some C++ - lots of nice linalg libraries for it now
22:47:10 <kmc> pikhq_, yeah, better to use a 5,000 line shell script to write a bunch of tiny C programs and test if each one compiles
22:47:12 <kmc> ;P
22:47:20 <pikhq_> (you can't do, say, #ifdef __GCC_HAS_ATTRIBUTE_SCRATCH_MY_BACK)
22:47:44 <NihilistDandy> pikhq_: BUT MY BACK WILL CONTINUE TO ITCH WITHOUT IT
22:48:04 <pikhq_> Incidentally, you *can* do that sort of thing in clang. :)
22:49:18 <zzing> heh, lion doesn't come with svn
22:49:27 <NihilistDandy> > replicate 5 "clang"
22:49:27 <lambdabot>   ["clang","clang","clang","clang","clang"]
22:49:43 <NihilistDandy> zzing: svn sucks, anyway
22:49:53 <ion> zzing: Should it?
22:49:56 <NihilistDandy> And wouldn't it be wrapped up in Xcode, anyway?
22:50:07 <zzing> NihilistDandy: true, yet that is the way to get the head of llvm-gcc
22:50:31 <NihilistDandy> zzing: Sounds like a llvm-gcc issue
22:50:33 <shachaf> zzing: I don't think Apple would allow Apache to include it. :-)
22:50:35 <mauke> pikhq_: you can check the exact version of gcc
22:50:36 <ion> git-svn is a considerably less painful svn client, btw.
22:50:58 <pikhq_> mauke: Which would work quite well if there weren't other compilers defining the same thing to indicate they support some of GCC's features.
22:51:00 <ion> You get to do amazing things such as *commits* (gasp) without write access to the svn repo.
22:51:39 <mauke> pikhq_: then those other compilers should provide appropriate macros
22:51:57 <pikhq_> It's kinda like every single web browser claiming to be Mozilla.
22:52:05 <NihilistDandy> ion: Xcode actually integrates with git, now O.o
22:52:32 <NihilistDandy> Why svn hasn't just died, yet, I don't know
22:52:45 <NihilistDandy> Between git, hg, and darcs... just why
22:52:47 <NihilistDandy> *?
22:52:55 <zzing> cvs ftw!
22:53:06 * NihilistDandy faints
22:53:30 <ion> svn’s not that much better than cvs, both are pretty much in the same category.
22:53:39 <mauke> did you mean: rcs
22:53:42 <pikhq_> They're both using fundamentally incorrect models of versioning.
22:53:54 <pikhq_> mauke: No, SCCS.
22:54:30 <ion> did you mean: cp -a project project-snapshot19
22:54:38 <NihilistDandy> God forbid I might want to make a commit while I'm in a wifi deadzone
22:54:49 <mauke> developmestuction, yo
22:55:54 <lewis1711> zzing: I just read all of that. quite interesting. makes me want to attempt fortran again
22:56:02 <zzing> lewis1711: awesome
22:56:18 <zzing> I am building llvm-gcc or trying to, to see if I can get something compiled for the ios :P
22:56:20 <NihilistDandy> Not me
22:58:02 <kmc> @quote CVS.done.right
22:58:02 <lambdabot> LinusTorvalds says: The slogan of Subversion for a while was 'CVS done right', or something like that, and if you start with that kind of slogan, there's nowhere you can go. There is no way to do
22:58:02 <lambdabot> CVS right.
22:58:16 <zzing> svn wouldn't even check out someting from an http address
22:58:31 <zzing> I guess I should get git-svn
22:58:42 <zzing> I already raped lion by installing svn
22:59:02 <kmc> NihilistDandy, probably because of legacy + git being hard to learn
22:59:09 <kmc> (can't say whether darcs or hg is hard to learn)
22:59:37 <kmc> git is hard because people approach version control as a cookbook process, and all of the git commands do 4 things at once which have nothing to do with the command's name
22:59:54 <kmc> the underlaying data model of git is simple and beautiful, but there's not enough pressure to Learn That First
23:00:21 <NihilistDandy> kmc: You should try hg. It's a little slower than git, but it's nice. And Bitbucket is a superior code store than GitHub, in some ways
23:00:34 <kmc> yeah
23:00:39 <NihilistDandy> kmc: Have you read Git Internals?
23:00:51 <kmc> no
23:01:08 <pikhq_> Git actually makes perfect sense from the data model. The entire thing.
23:01:29 <kmc> NihilistDandy, if I'm already skilled at git, will learning hg expand my mind?
23:01:57 <pikhq_> kmc: No; like all the DVCS out there, it's just another implementation of the Right Model. ;)
23:02:02 <NihilistDandy> kmc: Hmm. Hard to say. Probably not. It's very similar.
23:02:12 <kmc> pikhq_, my understanding is that darcs's model is actually very different
23:02:33 <NihilistDandy> kmc: A few links
23:02:34 <NihilistDandy> http://felipec.wordpress.com/2011/01/16/mercurial-vs-git-its-all-in-the-branches/
23:02:46 <NihilistDandy> http://importantshock.wordpress.com/2008/08/07/git-vs-mercurial/
23:03:28 <pikhq_> The basis of darcs is still the idea that you have your repository, I have mine, and we want to be able to exchange things with them.
23:03:53 <pikhq_> Though from what I gather darcs does every *detail* of this fairly differently.
23:05:14 <kmc> git stores only whole files; patches / diffs are ephemeral
23:05:24 <kmc> i thought darcs is the opposite
23:05:43 <Cale> Do git and mercurial both do the stupid 3-way-merging that doesn't account for intermediate changes to a file?
23:06:24 <pikhq_> kmc: Hence why I said "every detail is different". :)
23:06:55 <NihilistDandy> Cale: I don't think mercurial does, but I'm not sure
23:07:01 <pikhq_> Cale: I'm not sure what you mean by "intermediate changes"...
23:07:36 <pikhq_> Cale: Git's idea of a merge is basically a commit with two ancestors.
23:07:56 <pikhq_> Erm, I think "parents" is the right term.
23:08:35 <pikhq_> (that commit is, itself, generally the result of a three-way merge)
23:08:38 <Cale> pikhq_: I mean all the changes in between the points at which the two branches separated and came together again.
23:08:55 <pikhq_> Cale: Ah. That's recorded just fine.
23:09:06 <Cale> pikhq_: But does the merge ignore or account for them?
23:09:15 <Cale> (it sounds like it doesn't)
23:09:34 <pikhq_> Uh, by default it doesn't. The merging algorithm is pluggable.
23:12:42 <kmc> Cale, git by default uses a recursive merge strategy
23:12:58 <kmc> i will try to figure out what that means :)
23:13:25 <kmc> "When there is more than one common ancestor that can be used for 3-way merge, it creates a merged tree of the common ancestors and uses that as the reference tree for the 3-way merge."
23:13:45 <kmc> this can lead to nested conflict markers which are... great fun :)
23:18:30 <pikhq_> I doubt it'd be *easy*, but I suspect you could manage to get darcs' merge model as a merger for git.
23:18:35 <pacak> I am playing with STM monad. Is it possible to do exactly like "retry" does, but with committing all changes? e.g. commit changes, go to the beginning of transaction and block there until one of TVars is changed?
23:19:52 <pacak> (by other means that unsafeIOToSTM . forkIO . atomically $ writeTVar .....
23:19:54 <pacak> )
23:25:36 <Cale> pacak: forever . atomically $ do ...
23:27:20 <pacak> Cale, it works, but there is no block. There is no sence in recalculating the save values over and over.
23:28:26 <Cale> Oh, okay, hmm..
23:29:11 <Cale> pacak: There certainly isn't a way to do it without using something out in the IO monad. You can't commit only part-way through an STM transaction. Either it all runs and commits or none of it does.
23:30:08 <pacak> Cale, I want to commint everything. The whole point is to keep one TVar constantly updated as a function from several other TVars.
23:30:23 <pacak> Without doing any unnecesarry job.
23:32:29 <pacak> And since i can't use atomically to update TVar inside unsafeIOToSTM i have to use forkIO. Which looks kind of ugly....
23:33:21 <Cale> pacak: Does that actually work?
23:33:26 <pacak> yes
23:33:30 <Cale> pacak: interesting
23:33:38 <Cale> I wouldn't rely on it.
23:34:17 <Cale> Probably better to create a new abstraction, like a TVar which you can tell whether it has been changed.
23:34:20 <pacak> Why? I tried it in several different test programs. And they worked.
23:34:36 <Cale> Because GHC's implementation of STM isn't set in stone.
23:35:39 <Cale> and the semantics of anything involving unsafeIOToSTM is suspicious
23:39:49 <pacak> It is easy to invent TVar like thing which will inform on updates, it is harder to implement mechanism, which will do the blocking untill one of those is updated while not looking too ugly.
23:39:56 <pacak> But i'll try. Thanks :)
23:45:27 <kmc> what's the best way to write a Storable Vector to a file?
23:46:22 <mauke> hPutStrLn . show
23:47:18 <kmc> sorry, i meant as raw binary data
23:47:24 <kmc> in host-native byte order
23:47:35 <mauke> how is that "best" :-(
23:48:22 <kmc> optimize given constraints
23:48:53 <mauke> with x $ \p -> hPutBuf h p (sizeOf x)
23:50:02 <mauke> @pl \x -> with x $ \p -> hPutBuf h p (sizeOf x)
23:50:02 <lambdabot> ap with (flip (hPutBuf h) . sizeOf)
