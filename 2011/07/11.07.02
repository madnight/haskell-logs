00:05:50 <iwtu> Hi guys. I would like to ask, if the Haskell is good as first programming language for 13 years old boy
00:06:11 <shachaf> Age is irrelevant.
00:06:51 <Jafet> Outlook is hazy.
00:07:21 <arw__> depends. often its an important first step to make fast visual progress. then something like the old turtle graphics stuff could be better.
00:09:13 <Jafet> What happened to eros?
00:09:58 <iwtu> do you think that learn you haskell is fine for 13 old boy?
00:10:53 * shachaf considers ending every sentence with "for 13 years old boy".
00:11:21 <arw__> iwtu: you will have to try and see. i have a little expirience with people at about 17 or 18, and it hugely varies what language would really be suitable.
00:11:58 <iwtu> arw__: please, share one of your experience :)
00:12:01 <arw__> everybody has a different way of thinking, and they learn quicker if the language fits that.
00:12:50 <arw__> well. i've seen people grasp SQL instantly. or prolog. and still struggle with a simple loop in basic.
00:13:33 <arw__> whereas very often, people that "know programming" don't grasp prolog and have difficulty with SQL.
00:13:43 <arw__> same for functional languages like haskell.
00:14:44 <arw__> if a person has the right way of thinking about things, it will be very easy and painless. if not, prepare to have a very uninterested and bored child very soon.
00:15:30 <iwtu> arw__: I am consider Haskell or Python
00:16:43 <arw__> there is a much larger selection available, especially for teaching to children.
00:17:14 <arw__> the first language a child learns doesn't need to be all-purpose and big.
00:17:40 <iwtu> arw__: can you recommend any article?
00:17:47 <arw__> whats much more important is that the child can see its own progress, thats why the visual component is important.
00:18:27 <shachaf> So much ageism.
00:18:34 <arw__> and that the potential for frustration is low. i guess thats high in both python and haskell, for the syntax and type system are not really frustration-free if you don't know whats going on.
00:18:45 <shachaf> arw__: iwtu would seem to me to be talking about itself.
00:19:11 * arw__ didn't notice.
00:19:24 <arw__> hm.
00:20:28 <shachaf> Anyway, 13-year-old people are just like other people for the most part.
00:20:29 <iwtu> have you heard about Game Maker?
00:21:17 <arw__> iwtu: there are many articles, but i can recommend none. i can recommend looking at 'learn you a haskell'
00:21:18 <iwtu> shachaf: I don't think. The have a clear simple mind...
00:21:48 <iwtu> free mind
00:22:26 <roconnor> If two finite partial orders are isomorphic and both PO's are lattices, are they then lattice isomorphic under the same iso?
00:22:41 <Phyx-> hmm is this a bug in haddock? http://hackage.haskell.org/packages/archive/Hs2lib/0.4.8/doc/html/WinDll-Lib-NativeMapping.html
00:22:55 <Phyx-> why are the instances do wide and high
00:23:43 <iwtu> arw__: how do you try to find out which language can fit?
00:24:36 <arw__> iwtu: try it out. i know of no other method that really does any good
00:25:30 <arw__> iwtu: there is a lot of babble among teachers about that topic, but that mostly revolves around their own (in)convenience about learning another language or getting good books and stuff.
00:25:58 <iwtu> arw__: I think so
00:26:26 <arw__> iwtu: my first language was picked by microsoft, they just shipped qbasic and i tried to work with it.
00:26:39 <arw__> iwtu: but that was quite some time ago.
00:28:03 <iwtu> I know about man, who statred learn C when he was 8. I have absolutely no problems with pointer or same other scary staff. I just
00:28:28 <iwtu> used his free mind and seemed pretty nic to him
00:29:04 <iwtu> C was right language for him
00:29:07 <arw__> shachaf: you are right about the ageism by the way, i just couldn't imagine a 13-year-old asking that question.
00:30:20 <arw__> iwtu: generally you will learn a lot of languages, so don't be afraid to make a wrong pick. you can always try another one.
00:30:58 <iwtu> arw__: are you think I am 13? :)
00:31:07 <arw__> i'm not sure anymore.
00:31:24 <iwtu> why If i may ask?
00:32:43 <arw__> you type faster than i would expect. your spelling is better than i would expect. but then, i am really not sure what i would expect.
00:33:55 <iwtu> my english is not very good. I don't see how fast of typing can say something :)
00:34:07 <iwtu> but hope you understand my english
00:35:00 <arw__> its fine, english is not my native language either. and speed of typing is perhaps less of an indication nowadays, where everybody has a computer...
00:35:31 <iwtu> I am just interesing.. I Want To Understand
00:35:38 <iwtu> that's all
00:35:48 <iwtu> that's iwtu :)
00:35:51 <arw__> iwtu: i hope i didn't offend you by my assumption. if so, i would like to apologize.
00:37:06 <iwtu> arw__: am I sound like I was offended? :)
00:37:44 <iwtu> I would like to apologize if I sound that way
00:38:09 <arw__> no need, you didn't sound like that.
00:38:23 <Jafet> Political correctness overflow
00:38:32 <arw__> :)
00:38:34 <iwtu> arw__: so ? :)
00:38:36 <iwtu> :P
00:39:45 <arw__> iwtu: i just assumed and was a little embarassed about my inability to guess your age. and about the presumption of my being able to do so.
00:40:16 <arw__> i guess we really should change the topic back to programming :)
00:41:16 <iwtu> arw__: I am not 13 :P. But If you want, topic can be change :)
00:44:39 <arw__> iwtu: back on topic, the currently used environment around here is this: http://www.youtube.com/watch?v=kSxeHRUApNo
00:45:33 <arw__> iwtu: its a java port of turtle graphics, unfortunately most of it is in german.
00:47:37 <iwtu> arw__: I don't like java to much if I want to just freely thnik. It has to many words
00:48:43 <iwtu> I like Prolog if I imagine backtracking
00:50:15 <iwtu> Haskell is also good. Not many side effects if any. Don't have to think about a stack. Just write it out
00:50:17 <arw__> iwtu: there are many more implementations available, e.g.: http://en.wikipedia.org/wiki/PythonTurtle
00:52:04 <iwtu> Python seems to be nice. Not many words. Haskell too. If any turtle in Haskell?
00:52:57 <arw__> iwtu: i've googled, but the only thing i can find are homework assignments to the tune of "implement a turtle graphics VM in haskell".
00:53:26 <arw__> iwtu: most people don't seem to use haskell as a first language i guess.
00:53:34 <arw__> bbl, work calls.
00:54:35 <sanjoyd> There are certain theoretical concepts in Haskell which a child might find fundamentally hard. For instance, I'd think explaining lexical scoping to be one of them.
00:54:48 <sanjoyd> It is much easier to have "variables" which are like "boxes" which "hold" a "value".
00:55:10 <cheater_> the problem is turtle graphics is inevitably sequential and imperative
00:55:39 <shachaf> Not if you relax your definition of "turtle" sufficiently.
00:55:48 <sanjoyd> Secondly, the learner will have to (setting apart prodigies) black box things like IO anyway.
00:56:12 <shachaf> sanjoyd: Is it really?
00:56:32 <sanjoyd> I'd imagine it to be. I don't have any experience to back it up.
00:56:41 <shachaf> I'd think the idea of names just being names for values is simpler.
00:56:43 <sanjoyd> Of course, Haskell is a perfect first programming language for an intellectually mature person which some grounding in math.
00:57:35 <sanjoyd> But I've never taught anyone, so this is really a guess.
00:58:34 <sanjoyd> I do know of universities which teach Haskell as an "Introduction to Programming" sort of language to 17 year old freshers
00:59:19 <iwtu> map is quite nice and naturaly way to think
00:59:34 <sanjoyd> If the intuitive idea of a "sequence" is clear.
01:01:35 <djh_> map is one of my favourite things in programming in languages that have it
01:01:51 <djh_> when I have to write java at work I yearn for map
01:02:28 <djh_> java is an absolute disgrace for writing tons of boilerplate rubbish for something that could be easily done in one line
01:03:25 <sanjoyd> Java has a different set of philosophies; I don't think being able to write one-liners is one.
01:03:37 <iwtu> children's mind, especially in young childer, is often not fully appreciate. They have a free mind and just think. freelly think
01:03:52 <djh_> I just mean writing stuff like transforming stuff in a list
01:03:58 <djh_> it's a real pain in the rear
01:10:58 <iwtu> thank you for sharing your thoughts. I will go.
01:11:18 <iwtu> arw__: thank you. nice ideas
01:18:05 <John> @pl (\x y -> x y)
01:18:05 <lambdabot> id
01:18:31 <John> @pl (\x y -> map (<y))
01:18:31 <lambdabot> const (map . flip (<))
01:30:39 <Maxdamantus> flip (<); useful.
01:30:52 <John> @pl (foldr1 x (map y [True,False]))
01:30:52 <lambdabot> foldr1 x [y True, y False]
01:34:09 <John> @pl (\ x y -> foldr1 x (map y [True,False]))
01:34:09 <lambdabot> (. flip map [True, False]) . foldr1
02:18:21 <ivanm> gah, I was going to try switching from a recursive algorithm that seems to be taking up way too much RAM to a more iterative one... but then realised that all the work I did to avoid duplicating work would now be useless :s
02:24:46 <gienah> maybe you could transform the recursive algorithm to use tail calls and continuation passing style (this seems tricky at first, but I hope it gets easier with practice)
02:26:09 <Jafet> Why would a recursive algorithm take up way too much RAM?
02:26:34 <roconnor> why can't GHC CPS stuff for us?
02:26:54 <ivanm> Jafet: I was just hoping that by rewriting it it would magically work :p
02:27:29 <gienah> if the recursive call returns a value in an operand position such that further processing is done by the recursive algorithm on the return value, then this grows the context, taking more memory.
02:27:37 <ivanm> I'm not even sure _why_ it's taking up so much RAM :/
02:28:09 <Jafet> Well, that's what $! is for
02:28:22 <ivanm> tried that
02:28:33 <Jafet> Or $!!
02:28:46 <roconnor> Or make things lazier
02:28:51 <gienah> I wonder what $! and $!! are
02:28:51 <roconnor> which is my preference
02:29:08 <roconnor> (when possible)
02:29:10 <Jafet> Sure, everyone prefers that
02:29:14 <ivanm> I'm doing a lot of concat'ing, and I guess that's the problem
02:29:34 <roconnor> Jafet: true; though it isn't usually the first recommendation for some reason.
02:29:37 <ivanm> Jafet: where do you think I got the idea of suggesting adding $!! to deepseq came from? :p
02:29:44 <gienah> maybe you could pass the value that is to be concatenated to a continuation
02:30:08 <roconnor> like how ShowS works
02:30:15 <Jafet> It's the control, isn't it
02:30:19 <Jafet> The default
02:30:32 <roconnor> not always
02:30:43 <roconnor> it is pretty easy to accedentally be too strict.
02:30:49 * gienah is still trying to figure out continuation passing style
02:30:49 <ivanm> I'm generating tree-like structures
02:31:05 <ivanm> not quite sure if a CPS style would really work
02:31:28 <roconnor> Sometimes you need moderate rewriting to make your code lazier; like removing uses of Maybe or Either monads.
02:31:44 <gienah> I think it would work, but I guess maybe I'm a little naive since I haven't done enough coding in continuation style yet
02:33:48 <mjrosenb> ivanm: anything *can* be made into cps
02:34:06 <ivanm> yeah, but is it worth it? :p
02:34:20 <mjrosenb> this is what cps-ing compilers are for :)
02:35:30 <Jafet> Bah, it's just a passing style.
02:35:32 <roconnor> ideally you would first understand why all that RAM is being used; granted this isn't an easy task.
02:36:19 <ivanm> roconnor: I've been spending all of the past two days trying to do just that!
02:37:37 <Xaratas> my Exec function of a monad returns a IO (), which hosts an string generated from putStrLn. how to use this IO() value in an hunit test for assertEqual?
02:37:42 <ivanm> it appears that for some reason, rather than producing values one at a time it seems to be producing a whole big list of them :/
02:38:22 <Xaratas> the old implementation says IO () is not []
02:39:06 <roconnor> ivanm: Ah that is sucky.
02:40:57 <roconnor> Xaratas: so the Exec function does something like returning (putStrLn "foo") and you want to test that it is in fact printing foo to stdout?
02:41:14 <Xaratas> yes
02:43:29 <chrisdone_> arw__: iwtu: sanjoyd: http://www.cse.unsw.edu.au/~chak/papers/teaching-prgm.ps.gz
02:43:54 <chrisdone_> “The Risks and Benefits of Teaching Purely Functional Programming in First Year”
02:44:43 <roconnor> Xaratas: that is going to be somewhere between very difficult and impossible to test.
02:44:59 <chrisdone_> tl;dr: Haskell and pure languages like it are well-suited for teaching newbies /general/ computing concepts, but /functional/ programming is not.
02:45:21 <ivanm> roconnor: first problem I have: how do you distinguish between a function taking a lot of time/RAM becaues it's called a lot vs one that is inefficient/has a space leak ?
02:45:25 <Xaratas> roconnor: oh, nice :/
02:45:41 <roconnor> Xaratas: the only thing that comes to mind is to somehow temporarly redirect stdout, run the function, capture the stdout and compare it.
02:46:17 <ivanm> chrisdone_: yet I know students who hate Java when they have to use it after Haskell! (admittedly, they only do 3 weeks of Java and to avoid too many new concepts they use it in a very Haskelly fashion...)
02:46:22 <roconnor> Xaratas: it would be easier to test if your Exec funtion returned a data structure (or a string) that can later be printed to stdout.
02:46:32 <Xaratas> roconnor: and testing two IO to equality?
02:46:42 <ivanm> Xaratas: maybe have a fake IO-like monad for testing purposes?
02:46:46 <chrisdone_> ivanm: Is that relevant?
02:46:55 <ivanm> I believe I've seen people recommend that before
02:47:07 <ivanm> chrisdone_: since I don't know the context that you mentioned that paper in, I don't know :p
02:47:24 <chrisdone_> ivanm: "Whether Haskell is a good first-language"
02:47:26 <mjrosenb> ivanm: what are you attempting to do?
02:47:32 <roconnor> Xaratas: and testing the data structure instead of IO ()
02:47:36 <mjrosenb> ivanm: graphviz bindings?
02:47:43 <ivanm> mjrosenb: nah
02:47:55 <ivanm> implementing an algorithm to generate graphs
02:48:10 <ivanm> the code is at http://code.haskell.org/~ivanm/dangd/ if you wanna see (darcs get it)
02:48:13 <roconnor> ivanm: well if a function is being called a lot then it should be freeing the memory it allocates; while a space leak won't free it.
02:48:38 <ivanm> mjrosenb: my plans for this weekend _were_ to work on graphviz, but I have to get this done first :s
02:48:41 <roconnor> ivanm: IIRC GHC has many heap profiling tools and some might tell you how long bits of memory are living for.
02:49:07 <ivanm> well, either I haven't found them, they don't work or I'm not interpreting the results right :s
02:49:25 * roconnor was recently debugging his memory problems that were caused by ByteStrings being pinned.
02:49:44 <ivanm> but the output from using -hc basically is a triangle with the slope at about 30 degrees :s
02:50:00 <chrisdone_> ivanm: Funnily enough, related to our earlier conversation: For example, we encourage students from the start to get a feeling for what a program does by way of stepwise evaluation of expressions on a piece of paper.This neatly provides a starting point for the introduction of equational reasoningby performing stepwise evaluation on expressions that are not closed, which bringsus to correctness proofs and program de
02:50:00 <chrisdone_> rivation. In our opinion, this is signi cantlyeasier to motivate and implement than the calculus of weakest preconditions or the Hoare calculus that would be the corresponding theory for imperative languages.
02:50:39 <roconnor> ivanm: if it never goes down, that is the shape of a memory leak.
02:50:47 <roconnor> ivanm: thought not everything of that shape is a memory leak.
02:51:14 <roconnor> I'm not really an expert of debugging heap issues; I've only done it once :)
02:51:17 <ski> Xaratas : did you sort out your typing problems from yesterday ?
02:51:20 <ivanm> chrisdone_: hmmm...
02:51:23 <ivanm> roconnor: heh
02:51:56 <roconnor> ivanm: it was tought because there is a bug in the heap profiler that means bytestrings often don't appear in the heap profile.
02:51:59 <roconnor> *tough
02:53:16 <Xaratas> ski: yes, this and a bit more work now. but the next execrcise wants to introduce IO to read files with the script code
02:53:34 <ivanm> roconnor: ugh
02:54:07 <Xaratas> ski: so i have exec working but returning IO () instead of String, and all my hunit tests are broken -.-
02:54:38 <ivanm> could it be because I'm currently using tuples everywhere rather than a dedicated data type?
02:57:10 <roconnor> ivanm: probably not.
02:57:18 <ski> Xaratas : a mock `IO'-type could possibly be used .. an interpreter for that should be straightforward i think, so it shouldn't be that easy for bugs to hide in it
02:57:20 <roconnor> ivanm: have you looked at what types are on the heap?
02:57:41 * ivanm checks again with latest version
02:57:46 <ivanm> IIRC, (,) was there...
02:58:20 * ski ponders whether this is a good idea
02:59:57 <chrisdone_> Depending on the amount of IO operations knocking about, it's better to generalize the monad into a class that can represent pure or impure.
03:00:02 <ivanm> roconnor: most of it is stg_ap_2_upd_info which represents thunks
03:00:24 <ivanm> would that indicate that I need some more strictness?
03:01:30 <chrisdone_> Xaratas: There are potentially only a few points of real IO usage, maybe you can generalize it to any IO-ish monad?
03:02:01 <Xaratas> hm should be possible
03:03:36 <k0ral> anyone uses the webkit package here ?
03:04:36 <chrisdone_> Xaratas: E.g. class MonadLimitedIO m where hGetLine :: Handle -> m String; hPutStr :: Handle -> m String (try to reduce it to essential operations)
03:05:50 <ski> s//Monad m => /
03:06:25 <chrisdone_> Xaratas: instance MonadLimitedIO IO where hGetLine = IO.hGetLine; hPutStr = IO.hPutStr; instance MonadState PureIOState m => MonadLimitedIO m where hGetLine = getMyRandomLine; hPutStr = putMyRandomString
03:07:43 <roconnor> ivanm: I would guess so.
03:08:12 <chrisdone_> Could probably use QuickCheck (or whatever testing framework) you're using to seed values to getMyRandomLine. (Actually hPutStr would be more like a no-op, I guess.)
03:09:46 <chrisdone_> Xaratas: A similar approach: https://github.com/chrisdone/hulk/blob/master/src/Hulk/Types.hs#L169
03:10:12 <chrisdone_> Xaratas: And then: https://github.com/chrisdone/hulk/blob/master/src/Hulk/Providers.hs
03:12:57 <ivanm> roconnor: any ideas on how to find where the thunks _are_?
03:13:59 <Xaratas> uff
03:14:33 <roconnor> ivanm: yes, you can use retainer profiling to tell you who is holding onto how much memory
03:15:36 <roconnor> ivanm: though I've never done this with thunks before, it should work
03:19:14 <ski> chrisdone_ : `HulkP' being the inspectable version ? .. i don't see you using it anywhere
03:21:03 <chrisdone_> ski: Right, I didn't write any tests so I don't use it yet. :-P But the concept is there.
03:23:56 <ski> chrisdone_ : so you'd just do `providePasswords = HulkP (Identity "xyzzy")',&c. ?
03:25:39 <chrisdone_> That's one way I might, yeah.
03:26:19 * ski was thinking about doing a mock `IO' as a GADT or something, with constructors for `Return' and `Bind'
03:26:34 <chrisdone_> I suppose it's uninteresting in that example. But later (in a more recent branch) it becomes more messy and hence more useful for testing: https://github.com/chrisdone/hulk/blob/logging/src/Hulk/Providers.hs
03:26:52 <chrisdone_> ski: I think I've seen that approach implemented somewhere…
03:27:32 <ski> the problem with testing would be that the existential quantifier in `Bind' wouldn't have a `Show' or `Eq' constraint, making it harder to test
03:27:33 <chrisdone_> http://hpaste.org/1674/gadt_io?pid=1674&lang_1674=lua  http://hpaste.org/40413   http://hpaste.org/1676  http://hpaste.org/44722
03:28:03 <chrisdone_> Ah, you mean for representing the particular branch that failed the test, yeah.
03:29:07 <chrisdone_> (Oh, fun, found this in the search results: Implementation of ST in IO: http://hpaste.org/11191)
03:33:05 <ski> heh, `IOElem' at that <http://hpaste.org/1676> isn't that nice :)
03:34:03 <ski> i mean `Fmap id GetChar' is distinguishable from `GetChar', so it's at least not concretely a functor
03:36:07 <ski> (the correct thing to do in this situation is to use `CoYoneda', which will turn `IOElem'-except-`Fmap' into a functor, correctly)
03:39:10 <ski> (hm, the rest there doesn't even look type correct ..)
03:40:43 <k0ral> anyway to work with the clipboads in Haskell ?
03:40:52 <k0ral> clipboard*
03:45:18 <ivanm> k0ral: which OS is the first question :p
03:45:33 <ivanm> roconnor: you still here?
03:46:01 <ski> btw, it is possible to do the `IO', without using a GADT, if you use CPS (and it'll probably be more efficient, as a bonus)
03:47:42 <ivanm> or can anyone else have a look at some profiling results and confirm something for me?
03:48:02 <roconnor> ivanm: vaguely
03:48:16 <k0ral> ivanm: linux, I saw a module for Windows
03:48:38 <roconnor> I can look
03:48:44 <ivanm> in http://code.haskell.org/~ivanm/dangd.ps would the space leak be _from_ permIt or within something using the results of permIt ?
03:49:00 <ivanm> the prof file is also at http://code.haskell.org/~ivanm/dangd.prof if you want to see it
03:53:36 <roconnor> ivanm: is it easy for you to post the .hp file or whatever it is called?
03:53:44 <ivanm> sure
03:54:06 <ivanm> http://code.haskell.org/~ivanm/dangd.hp
03:54:20 <ivanm> that's the output from -hc
03:54:43 <roconnor> oh
03:54:49 <roconnor> I thought I was looking at -hr
03:55:13 <ivanm> running that one now
03:55:30 <roconnor> ok
03:55:50 <roconnor> having both will be good.
03:56:09 <roconnor> I wouldn't mind seeing -hy too
03:57:35 * roconnor is trying to "debug" a memory leak in Coq, but it is even harder to do.
03:58:07 <ivanm> http://code.haskell.org/~ivanm/dangd_hr.hp
03:58:54 <ivanm> roconnor: yay :s
03:59:07 <ivanm> I guess there are no debug tools for coq? :s
03:59:21 <roconnor> nope
03:59:32 <roconnor> I have this QED line that takes 4 minutes and 300 MB.
03:59:38 <roconnor> I have no idea why
04:00:08 <roconnor> ivanm: can you post the postscript too
04:00:13 <roconnor> I"m too lazy to generate it myself
04:01:19 <ivanm> heh
04:01:23 <ivanm> done
04:01:27 <ivanm> and _hy variants as well
04:02:46 <Saizan> what does the y profiling measure?
04:03:00 <fasta> This is also a good way to confuse someone: test=do let (x,y) = (1,2); let x = 3; print x
04:03:23 <roconnor> ivanm: Well, it does look to me like what a space leak would look like.
04:03:32 <ivanm> Saizan: types
04:04:22 <roconnor> ivanm: can you try one more thing for me
04:04:32 <fasta> I think it would be better if only 'real' do variables could be assigned multiple times.
04:04:39 <ivanm> roconnor: sure
04:05:00 <ivanm> fasta: since it's just de-sugaring, it's just nested lambdas, etc. so I'm not sure if that's possible
04:05:07 <roconnor> -hr -hystg_ap_2_upd_info
04:05:43 <Jafet> fasta: how is that confusing?
04:05:44 <fasta> ivanm: sure, it would have to change the semantics and it is not really important, it just kind of surprised me, although I do happen to know how it works in general.
04:05:47 <ski> it would be nice if `f f = ..f..' wasn't allowed, though
04:06:02 <roconnor> Jafet: the shadowing of x?
04:06:28 <Jafet> It's definitely shadowed; there's no confusion about that
04:06:37 <roconnor> I was confused for a moment.
04:07:25 * ivanm is trying to find that view pattern quote for an even worse code sample
04:07:29 <Jafet> Perhaps my soul is unfortunate enough that I still remember imperative semantics
04:07:42 <Jafet> @quote best.view.pattern
04:07:42 <lambdabot> benmachine says: let (\x -> case x of (\x -> x -> x) -> x -> x) = 0 in x / best view pattern evar
04:09:02 <roconnor> I haven't found the right counter arugment to "it is possible to understand what the code does" when I claim code is badly written/designed.
04:09:12 <Saizan> can someone parenthesize that for me?
04:09:47 <Jafet> let ((\x -> case x of ((\x -> x) -> x) -> x) -> x) = 0 in x
04:09:52 <ski> `let ((\x -> case x of ((\x -> x) -> x) -> x) -> x) = 0 in x' i'd assume
04:10:09 <cheater_> Jafet, haskell had imperative semantics?
04:10:31 <roconnor> cheater_: the semantics of do notation is not entirely dissimilar to imperitive semantics.
04:10:32 <Saizan> thanks
04:10:46 <Jafet> “Imperative style”, if you like.
04:10:52 <cheater_> ok
04:11:32 <Jafet> “let x0 = a; x1 = f x0; x2 = g x1; x3 = h x2 in x3” can be understood in an imperative way.
04:11:37 <ivanm> roconnor: http://code.haskell.org/~ivanm/dangd.hp now has that version (the other is now in _hc) with the ps there as well
04:12:10 <Jafet> And in lisp, you could even drop the subscripts.
04:13:15 * roconnor reviews the documentation for -hr
04:13:48 <ski> Jafet : with `let*', yes
04:14:54 <roconnor> ivanm: can you show the the .prof file for that last run too?
04:15:14 <ivanm> didn't do it for the last one, but it should be the same shouldn't it?
04:15:37 <roconnor> I don't know. the doc for -hr says to look in the .prof file for some information on retainer sets.
04:15:56 <roconnor> (thought I secretely think that might be an error in the docs)
04:16:16 <Ke> is there some channel or something else that allows read with timeout
04:16:21 <ivanm> oh.... I'm trying it with -hd atm, once it's done I'll do the one you wanted again
04:16:59 <roconnor> ivanm: are you willing to paste code for permIt and getSubs and maybe getBlackSubMobiles?
04:17:20 <ivanm> http://code.haskell.org/~ivanm/dangd/
04:17:52 <Ke> ah, System.timeout
04:18:27 <ivanm> the main is currently slightly different, but genBlackSubMobiles (getSubs is part of it there) is in Data.Graph.Planar.DangD and permIt is part of permBag in Data.Graph.Planar.DangD.Common
04:20:47 <roconnor> ivanm: what's the type of PermIt?
04:21:15 <ivanm> Bag a -> [[a]] (where Bag a = [(a, Int)]
04:22:24 <roconnor> ivanm: is there some magical trick to how you got call centres at definitions in your where clauses or did you insert them by hand?
04:22:24 <ivanm> roconnor: OK, the dangd.prof file there now is the one from -hr -hystg.....
04:22:39 <ivanm> roconnor: took them out of the where clauses ;-)
04:22:43 <roconnor> ah
04:24:08 <roconnor> oh
04:24:18 <roconnor> it does have the retainer sets in it
04:29:16 <fasta> Jafet: That view pattern was basically a very long way to write down 0, right?
04:29:26 <roconnor> ivanm: okay so genBlackSubMobiles produces a very long list; this is fine as long as it is consumed properly
04:29:36 * roconnor looks to see how genBlackSubMobiles is used
04:29:59 <fasta> Do you use view patterns?
04:31:03 <ivanm> roconnor: it's called by genSubMobiles
04:31:13 * chrisdone_ loves view patterns
04:31:21 <ivanm> which genBlackSubMobiles recursively calls (via iSubs)
04:32:52 <roconnor> genBlackSUbMobiles doesn't seem to call iSubs
04:33:52 <roconnor> oh via splitICounts
04:33:56 <ivanm> yup
04:35:16 <ski> fasta : yes
04:35:17 <chrisdone_> Phew, just spent 20 minutes resisting a gas/electricity salesman. Shouldn't have let him inside. Now I can't remember what I was coding.
04:35:31 <ivanm> chrisdone_: heh
04:35:41 <ski> (fasta : i.e., that's `0', yes)
04:35:47 <ivanm> chrisdone_: going back to fighting with haskell-src-exts? :p
04:36:07 <chrisdone_> Maybe Fight
04:38:13 * chrisdone_ ponders hiring that guy to sell Haskell door-to-door
04:38:41 <roconnor> ivanm: how big are these lists of permutations do you expect?
04:39:26 <ivanm> well, for this particular run, the final length of the list produced by genMobiles is 1546171
04:39:27 <ivanm> ;-)
04:39:45 <ivanm> but for the results of permBag... in this case up to 4
04:39:47 <chrisdone_> “Ever pondered the difficulties in managing effects in your existing imperative language?” “… I'm an old lady who manages a modest vineyard. Please, I don't want any trouble.”
04:40:05 <ivanm> in some cases quite possibly only a singleton :s
04:42:29 <ivanm> chrisdone_: OK, I _still_ have no idea what that means ;-)
04:43:57 <roconnor> ivanm: I see, but your map retains all the partial results so you have that 1546171 duplicated many times over, right?
04:45:02 <ivanm> roconnor: hmmm?
04:45:02 <chrisdone_> ivanm: What, vineyard?
04:45:18 <roconnor> let me see if I can be more specific
04:45:22 <ivanm> chrisdone_: what does vineyard have to do with imperative language? :/
04:45:51 <roconnor> ivanm: in genBlackSubMobiles you have:
04:45:58 <roconnor> liftM concat $ mapM (getSubs d) ns
04:46:03 <chrisdone_> ivanm: Because he's a door-to-door Haskell salesman. Going door-to-door you're likely to meet mostly every day people, not programmers. </joke-explanation>
04:46:39 <roconnor> ivanm: If I understand whell your (getSubs) call will lookup/generate a bunch of things from your map, and concatenate them all together and this will be inserted into the map
04:46:46 <roconnor> ivanm: is this more or less right?
04:46:59 <ivanm> roconnor: the Map in the state? not using that atm
04:47:10 <roconnor> ya the Map in the state
04:47:23 <ivanm> it was there to test to see if caching worked, but it doesn't seem to make a difference :/
04:47:34 <ivanm> chrisdone: O...K...
04:47:35 <roconnor> oh
04:47:56 <chrisdone> ivanm: :set -XBritishHumour
04:47:57 <roconnor> ivanm: what does the code do now?
04:49:38 <ivanm> currently I'm just using the State as a Reader
04:50:15 <ivanm> getSubMobiles implements the caching version (if I go and change genSubMobiles in iSubs to getSubMobiles) but I found it didn't seem to make a difference :s
04:51:57 <Saizan> win 12
04:52:52 <roconnor> ivanm: I see getSubMobiles isn't called.
04:54:11 <ivanm> yup
04:54:52 <ivanm> roconnor: all the results that you're seeing, I've put "let c = length $ genSubMobiles d' n'" instead of the encoding stuff in main
04:55:35 <roconnor> where?
04:55:50 <ivanm> in the Main.hs file in the root of the repo
04:58:11 <roconnor> ivanm: ah
04:58:35 <fasta> How can I see the maximum memory usage easily?
04:58:56 <fasta> I have a bit of a luxury problem; it runs too fast.
04:58:59 <roconnor> something like +RTS -hT or -ht
04:59:23 <ivanm> or use +RTS -s
04:59:26 <roconnor> ya
04:59:28 <roconnor> even better
05:03:21 <fasta> hc was enough.
05:03:35 <fasta> Kind of nice to write a program with zero memory leaks the first time.
05:04:04 <roconnor> ivanm: where is combinations?
05:04:26 <ivanm> in Common
05:05:55 <ivanm> same as permBag
05:06:36 <knoc> hi people, I want to use the the function 'split'
05:06:49 <knoc> how can I import it in ghci?
05:06:59 <Axman6> :m +Data.List
05:07:49 <knoc> Axman6: The function split is not available then
05:07:57 <Jafet> permBag? You're still working on that program?
05:08:19 <Axman6> :t split
05:08:20 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
05:08:25 <Axman6> @hoogle split
05:08:25 <lambdabot> Data.ByteString split :: Word8 -> ByteString -> [ByteString]
05:08:25 <lambdabot> Data.IntMap split :: Key -> IntMap a -> (IntMap a, IntMap a)
05:08:25 <lambdabot> Data.IntSet split :: Int -> IntSet -> (IntSet, IntSet)
05:08:35 <Axman6> which split are you talking about?
05:08:47 <knoc> the Data.ByteString split
05:09:00 <ivanm> Jafet: yup
05:09:00 <Axman6> then you need to import Data.ByteString
05:09:05 <Axman6> :m +Data.ByteString
05:09:17 <Jafet> import Data.ByteString (split)
05:09:21 <knoc> Axman6: ok It works, thanks
05:10:32 <knoc> one more question: If I want to split normal Strings (not ByteStrings) should I convert them to bytestrings before?
05:10:46 <knoc> because I do not see a String split
05:11:06 <ivanm> @hoogle split
05:11:06 <lambdabot> Data.ByteString split :: Word8 -> ByteString -> [ByteString]
05:11:06 <lambdabot> Data.IntMap split :: Key -> IntMap a -> (IntMap a, IntMap a)
05:11:07 <lambdabot> Data.IntSet split :: Int -> IntSet -> (IntSet, IntSet)
05:11:19 <Jafet> Where did you hear of a String split?
05:11:20 <ivanm> @hoogle a -> [a] -> [[a]]
05:11:21 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
05:11:21 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
05:11:21 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
05:11:34 <ivanm> knoc: there's also a split package
05:11:46 <ivanm> knoc: but you're better off using Text rather than Bytestring for textual data
05:12:08 <roconnor> ivanm: out of curiousity, what happens when you replace [1..n] with (reverse [1..n]) in combinations?
05:12:11 <Jafet> Indeed; you cannot use ByteString.split to mimic a String split.
05:12:49 <knoc> Jafet: I was reading RealWordHaskell and extended some example about splitting bytestring, and then switched to normal strings
05:12:52 <ivanm> roconnor: lemme try
05:13:28 <Jafet> It's not hard to write a split for yourself, if you want to do that. base has no split on lists.
05:13:30 <knoc> ivanm: ok, you hoogle use was very inspiring^^
05:13:31 <Jafet> @hackage split
05:13:31 <lambdabot> http://hackage.haskell.org/package/split
05:13:43 <Axman6> > splitAt 5 "hello world"
05:13:44 <lambdabot>   ("hello"," world")
05:14:57 <roconnor> ivanm: your code seems not unreasonable.
05:15:09 <roconnor> I can see why you've been at this for days :)
05:15:26 <ivanm> heh
05:16:25 <ivanm> roconnor: even better: in the version as you have it, it uses much less RAM if in genMobiles I have the currently returned value set in the variable ms and then have the function return "length ms `seq` ms" :s
05:16:34 <ivanm> I tried playing with -H, -A, etc. to no avail
05:16:47 <ivanm> I'm talking about _drastic_ differences in maximum RAM usage
05:17:04 <roconnor> intresting
05:17:40 <linduxed> oh so i've got a dilemma
05:17:52 <Jafet> I don't find that surprising, but then I have no context
05:18:13 <roconnor> no it isn't so surprising
05:18:24 <roconnor> I was just trying to make things lazier instead of stricter :)
05:18:29 <linduxed> I've got a list in which the first element is sorted
05:18:30 <ivanm> roconnor: OK, [n,n-1..1] in combinations results in about 1/8th of the runtime being shaved off
05:18:38 <linduxed> it will be the pivot
05:18:41 <ivanm> (could be a one-off thing based on computer usage though)
05:18:45 <roconnor> ivanm: and memory use?
05:18:46 <linduxed> the rest of the list is not sorted
05:18:52 <ivanm> linduxed: OK...
05:19:10 <ivanm> roconnor: looks like some was reduced
05:19:17 <ivanm> as in overall RAM usage
05:19:22 <roconnor> but not a lot
05:19:27 <linduxed> so i wanted to create a function that i could plug into sortBy
05:20:01 <linduxed> but sortBy only takes (a -> a -> Ordering)
05:20:01 <ivanm> roconnor: didn't seem to make a difference to the ps file generated from the hp file
05:20:11 <linduxed> so i can't pass the pivot really...
05:20:12 <Jafet> linduxed is one confused little penguin.
05:20:14 <ivanm> linduxed: ummm... sortBy will sort the entire list
05:20:24 <linduxed> ivanm: yeah i know
05:20:30 <ivanm> so you can't really sort just the first value
05:20:44 <ivanm> linduxed: or are you sorting [[a]] ?
05:20:51 <ivanm> if so, sortBy (compare `on` head)
05:21:07 <linduxed> ok i'll rephrase this so that it becomes clearer
05:21:08 <ion> :t (compare `on` head, comparing head)
05:21:09 <lambdabot> forall a a1. (Ord a, Ord a1) => ([a] -> [a] -> Ordering, [a1] -> [a1] -> Ordering)
05:21:34 <roconnor> ivanm: okay
05:23:20 <linduxed> i'm implementing the graham scan algorithm and i'm at the step where the list of 2D points are placed in a list, whereafter the point with the lowest Y-value (and if tied also lowest X-value) is placed first in the list.  the next step is to sort all but the head of the list by their polar angle to that "first" point
05:23:47 <Jafet> Hooray, that's less confusing.
05:24:18 <ivanm> linduxed: OK, let's say you have some Point -> Point -> Distance function
05:24:29 <ivanm> where Distance is an instance of Ord
05:24:52 <ivanm> so: sortPoints (p:ps) = sortBy (compare `on` distFrom p) ps
05:25:01 <ivanm> oh, probably want p : sortBy ...
05:25:05 <roconnor> well, it sounds like you fixed your problem anyways
05:25:32 <linduxed> http://paste.pocoo.org/show/426817/  - current code BTW
05:25:35 <ivanm> roconnor: nope :p
05:25:45 <ivanm> still heaps of RAM being used
05:25:52 <roconnor> huh
05:25:59 <ivanm> roconnor: I can't use these inputs to the full version of the program because of a stack overflow :s
05:26:04 <roconnor> I thought you said the seq length thing fixed it for you
05:26:08 <ivanm> (admittedly, that's from the rest of it)
05:26:18 <ivanm> roconnor: it made a large difference in the overall version of the program
05:26:28 <ivanm> but I have nfi _why_ it works (as it seems rather unintuitive)
05:28:21 <roconnor> ivanm: the problem I'm guessing it is that combinations is holding onto the list generated by genSubMobiles in n different ways leading to the space leak
05:29:48 <ivanm> roconnor: hmmm....
05:29:54 <ivanm> even more so with permBag?
05:30:21 <ivanm> oh, probably more combinations, yeah
05:30:34 <roconnor> maybe
05:34:22 <roconnor> ivanm: I might also try instead of testing with let c = length $ genSubMobiles d' n'; I'd be inclined to mapM_ print it.
05:34:50 <ivanm> and then re-direct output to /dev/null ?
05:34:55 <roconnor> sure
05:34:56 <ivanm> there is a _large_ amount of output :p
05:34:59 <ivanm> OK
05:39:39 <ivanm> roconnor: OK, that's taking longer... >_>
05:39:47 <ivanm> memory usage seems about the same though
05:39:56 <roconnor> ya, the memory use is all I care about
05:40:00 <roconnor> ok
05:41:43 <roconnor> Where is PlanarGraph defined?
05:44:45 <BCoppens> ok, odd question, perhaps, but ghc produces '/usr/bin/ld: cannot find crt1.o: No such file or directory' since I updated part of my debian install. It's likely caused by the difference in paths here: http://packages.debian.org/search?searchon=contents&keywords=crt1.o&mode=path&suite=unstable&arch=amd64 http://packages.debian.org/search?searchon=contents&keywords=crt1.o&mode=path&suite=stable&arch=amd64
05:45:13 <BCoppens> but 'ghc -L/usr/lib/x86_64-linux-gnu/ meh.hs' doesn't help, any ideas?
05:45:31 <ivanm> roconnor: http://code.haskell.org/~ivanm/planar-graph/
05:46:00 <ivanm> roconnor: runtime usage is currently 3x what it was just doing length :s
05:46:03 <mike-burns> BCoppens: I did an   apt-get build-deps haskell-platform  when that happened to me.
05:46:11 <roconnor> ivanm: okay
05:46:16 <roconnor> you can stop now :)
05:48:04 <roconnor> ivanm: btw, Gontheir has a nice representation of planer maps using hypergraphs :)
05:48:14 <ivanm> roconnor: oh? where?
05:48:24 <BCoppens> mike-burns: alas, that doesn't work :(
05:49:50 <ivanm> roconnor: when looking at the hp2ps output, it goes up to the max point it had before and stays there
05:50:09 <chrisdone> Hehe, ackermann steps: http://hpaste.org/steps/48629?expr=a+1+2&submit=Submit
05:50:43 <merijn> Why are all job openings for Haskell programmers always looking for senior experiences people :\
05:50:56 <roconnor> ivanm: http://research.microsoft.com/en-us/um/people/gonthier/4colproof.pdf - section 5.1
05:50:58 <merijn> I've never seen a junior/entry level Haskell job >.>
05:51:43 <ivanm> chrisdone: all that for _4_ ? :o
05:51:45 <chrisdone> merijn: Possibly: There's a high-risk factor; a junior in Java or Python is probably more productive than a junior in Haskell.
05:51:50 <ivanm> chrisdone: you still going to add in line numbers?
05:51:55 <chrisdone> ivanm: That's ackermann for ya. :-D
05:52:04 <chrisdone> Yeah, just finishing a wee blog post about it.
05:52:18 <merijn> chrisdone: Yes, but presumably there needs to be some job for juniors to start in, in order to become seniors :p
05:52:50 <merijn> I never see junior python jobs either, though. Unless it's django/web work
05:53:20 <chrisdone> merijn: Can you do web dev?
05:53:21 <BCoppens> meh, I just hackily ln -s'ed the files to /usr/lib, but that's really unlikely to be a 'good' solution :p
05:53:34 <merijn> chrisdone: Yes, but I don't want to :p
05:53:45 <merijn> chrisdone: I didn't do CS to become a webmonkey
05:54:07 <merijn> (assuming front-end web dev, of course. Backend can be plenty interesting)
05:54:10 <chrisdone> merijn: What type of monkey would you like to be?
05:54:29 <merijn> chrisdone: PL/OS/distributed systems monkey :p
05:54:33 <roconnor> ivanm: I guess if I were you I would try to stricten things up.  add some !'s to your field in Planer graph, make a data type for SubMobile with ! fields and then try to strictfy the output of genSubMobiles with somthing like foldr (\a b -> a `seq` b `seq` (a:b))
05:54:59 <roconnor> ivanm: thought I still believe/wish there is some way to lazify it.
05:55:06 <ivanm> *nod*
05:55:19 <roconnor> ivanm: again I'm not an expert of heap usage in Haskell so I could be way off base here
05:55:37 <ivanm> thanks anyway though :D
05:55:39 <ivanm> roconnor++
05:55:47 <roconnor> maybe someone with some experience can help :)
05:56:04 <chrisdone> merijn: Yeah, it's hard to get web developers for Haskell, they have too high standards. This leaves about ten competent Haskell web developers in all of Haskell’s community.
05:56:07 <ivanm> roconnor: AFAICT, my only hope is to make this a shootout benchmark... :p
05:56:30 <ivanm> but that may prevent me from writing a paper about the results :p
05:56:42 <BCoppens> or post it on stackoverflow :P
05:56:44 <linduxed> here's what i was rambling about, this what what i wanted to somehow stuff into a sortBy, but ended up doing manually http://pastie.org/2154459.txt
05:57:26 <ivanm> BCoppens: not enough of a minimal case to really be able to do that :/
05:58:09 <merijn> chrisdone: My interests are more in the security/high assurance direction. But there they only seem to want people with 5-10 years experience or something and its hard to get that experience if no one is looking for people with no experience :p
05:58:34 <chrisdone> The chicken and egg problem is well known, yeah.
05:59:08 <linduxed> does anyone have an idea on how to achieve that using sortBy?
06:00:13 <drdo> merijn: Looks like you are going to have to take the lulzsec approach, that'll teach them :P
06:00:16 <BCoppens> ivanm: yeah, maybe :( btw, were you able to figure out the planar_graph format for multiple edges? :)
06:00:17 <merijn> linduxed: Make myCoTan return LT/EQ/GT and then use "sortBy myCoTan"
06:00:28 <ivanm> linduxed: didn't I already tell you how to do that?
06:01:16 <ivanm> linduxed: oh, recursively calling sortBy? don't think so...
06:01:42 <ivanm> BCoppens: I talked to brendan about it; he gave me some pointers but IIUC he couldn't remember how it worked either :p
06:01:43 <ski> linduxed : `ac' should probably be `a c', and you can write that whole guard expression as `myCoTan a b >= myCoTan a c'
06:01:59 <ivanm> and he doesn't seem to understand the point of writing rigorous _re-usable_ libraries :p
06:02:00 <merijn> drdo: The lulzsec guys have hardly any real skill from what I can tell. They just seem to Google for known exploits and SQL injections, that's not hard >.>
06:02:02 <ski> linduxed : what happens if `pointYval p2 - pointYval p1' is zero ?
06:02:18 <BCoppens> ivanm: :D
06:02:22 <drdo> merijn: I never claimed they had :)
06:02:33 <hpaste> chrisdone pasted “sortByCoTan (for hlint)” at http://hpaste.org/48630
06:02:37 <ivanm> BCoppens: well, he kept asking me why I wanted to know since I dind't need it for this ;-)
06:03:45 <ski> linduxed : you do realize `sortByFirst' won't sort an unsorted list, only doing a single "percolation" of it, yes ?
06:04:26 <BCoppens> ivanm: hehe. so you told the truth, or you just dropped it? :P
06:04:46 <ivanm> pretty much dropped it, with some hints along the lines of "well, I may need it in future"
06:05:05 <ivanm> but he keeps thinking I'm crazy for not doing it in C, with my only reasonable excuse being that I don't know C
06:05:52 <ivanm> he did suggest I switch to an array-based data structure rather than Map-based, but I'm not sure hwo well that would work since I'm continually merging graphs together; IIUC with an array that won't work as nicely
06:06:08 <linduxed> ski: hmmm i'll have to take look at that
06:06:23 <linduxed> ski: and as for the yval thing
06:06:25 <linduxed> :-D
06:06:35 <linduxed> better fix that in a hurry
06:06:52 <ski> linduxed : if you were calling `sortBy', that would of course sort the list (given a total order comparision function)
06:07:24 <ski> linduxed : maybe it would work as well to get angles instead of slopes ?
06:08:11 <BCoppens> ivanm: well, given the fact that in this kind of research everyone uses C, I can understand his skepticism :) and yeah, I don't know if array-based would work nicely here :(
06:08:12 <ski> > 2 * pi / phase (1 :+ 1)
06:08:13 <lambdabot>   8.0
06:08:15 <ivanm> roconnor: where should I be looking in that paper for the data structure/representation?
06:08:35 <ivanm> BCoppens: well, everyone uses C because they're all fuddy-duddys! :p
06:08:39 <BCoppens> :D
06:08:55 <ivanm> I must admit, plantri's code is relatively readable from what I've seen
06:08:55 <merijn> ivanm: And/or masochists
06:09:13 <ivanm> merijn: nah, most of them are grand 'ol CS masters from the days where C reigned supreme
06:09:24 <BCoppens> ivanm: I was just going to say that your code looks far more readable and nicely documented than the average C code in this area :P
06:09:27 <merijn> One of those is my master project supervisor >.>
06:09:30 <ivanm> since Fortran was only for matrix stuff and was too weird with all that column-based stuff
06:09:30 <ivanm> :p
06:09:45 <ivanm> BCoppens: heh, well, compared to my honours supervisor...
06:10:00 <ivanm> his code was _atrocious_, in that he couldn't even work out what some of it did! :p
06:10:25 <ivanm> (though plantri, nauty, etc. are written for people to analyse and extend, which is why they're probably better written and documented than the norm)
06:10:28 <roconnor> ivanm: section 5.1
06:10:30 <roconnor> I think
06:10:42 <merijn> I've been tempted to reimplement everything in Haskell just to show how much time I'd save, but was to lazy to also reimplement a compiler and I'm short on time as it is :p
06:11:00 <roconnor> ivanm: the idea is to represent planer maps by a set of darts, one in each corner of each face.
06:11:19 <ivanm> merijn: heh, what are you doing?
06:11:23 <BCoppens> ivanm: yeah could be :)
06:11:45 <merijn> ivanm: Tricking imperative programmers into writing functional code :p
06:12:33 <roconnor> ivanm: then have 3 permutations functions  of these darts, one permutation rotates darts around the faces, the second rotates the darts around each vertex, and the third is of order 2 and moves dart to the far corner on the opposite side of  the edge.
06:12:46 <roconnor> ivanm: I don't know if this repersentation would be helpful for your work.
06:12:55 <merijn> ivanm: Task coordination language which takes code written in (for now mostly) C, and lets you describe the concurrent interactions
06:13:09 <ivanm> roconnor: hmmm, could be
06:13:22 <ivanm> my representation is an extension of one of the ones that is meant to be the best performing
06:13:30 <ivanm> but it's array-based; mine is Map-based
06:13:34 <merijn> ivanm: Essentially imagine a bunch of forkIO threads, reading from an input channel, running a function on the input and writing 0 or more outputs onto an output channel
06:13:52 <ivanm> I may try to resurrect sw17ch's EnumMap library based off the newer IntMap code to see if it performs better
06:14:29 <merijn> Only then its all written in C and pthreads and takes a bazillion lines of code :p
06:14:40 <ski> merijn : makes me think of `data SP a b = Put b (SP a b) | Get (a -> SP a b)' ..
06:15:54 <ivanm> merijn: replacing "return $ combinations c sms" with "return $!! combinations c sms" results in usage that is pretty much 0 until the very end which then has a huge spike
06:16:09 <ivanm> (at least for "5 14" as the inputs, as 17 was taking too long)
06:16:15 <ivanm> s/merijn/roconnor/
06:16:18 <ski> merijn : you could add an `DoIO (IO (SP a b))' case, if you want arbitrary I/O in that
06:16:41 <merijn> ski: That's sorta my point, it'd be trivial to implement this stuff in haskell/erlang/go :p
06:16:59 <merijn> Instead I have like several klocs of C :p
06:17:50 <ski> (merijn : .. would anyone notice if the C was generated from Haskell ? ;)
06:18:16 <ivanm> roconnor: I'm thinking a "strictifySpine :: [a] -> [a]" function may come in handy though
06:18:51 <ski> ivanm : not `[a] -> ()', then ?
06:19:00 <roconnor> you probably want to strictify the contents too
06:19:21 <ivanm> roconnor: that's what $!! does; seems to make it take longer than just $!
06:19:38 <roconnor> well, things take longer when you aren't lazy :D
06:19:41 <ivanm> ski: well, it's just that then seq'ing the return value
06:20:00 <ivanm> roconnor: $! also takes less memory
06:20:11 <ivanm> so strictifying the contents doesn't help much :s
06:20:14 <roconnor> sometimes you use less memory when you are lazy
06:20:14 <linduxed> ski: yeah i guess so
06:20:22 <chrisdone> strictifySpine xs = case length xs of 0 -> (); _ -> ()?
06:20:51 <linduxed> ski: my problem was mostly that thing with sorting by the first element
06:20:58 <ski> linduxed : `phase' will give an angle from a complex number `x :+ y'
06:21:19 <ivanm> chrisdone: or just length xs `seq` xs
06:21:21 <linduxed> what's that :+ thing?
06:21:27 <ivanm> linduxed: complex numbers
06:21:29 <ski> @type (:+)
06:21:30 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
06:21:48 <ski> > let i = 0 :+ 1 in i * i
06:21:49 <lambdabot>   (-1.0) :+ 0.0
06:21:49 <chrisdone> ivanm: Ah I forgot there were pure strictifiers.
06:22:01 <ivanm> ski: to have it [a] -> () I'd have to seq it somewhere anyway, wouldn't I?
06:22:04 <saati> linduxed: it's the constructor for complex numbers
06:22:23 <linduxed> ski: i'm not sure why i'd mess in complex numbers when i'll only be working with real values....
06:22:46 <ski> ivanm : yeah .. but it's easier to combine stricifiers for different types, using that, i think
06:22:48 * chrisdone couldn't think of a way to get [a] -> () without case
06:23:02 <ivanm> chrisdone: doing it by hand?
06:23:07 <chrisdone> ivanm: Example?
06:23:30 <ivanm> strictifySpine [] = (); strictifySpine (_:xs) = strictifySpine xs `seq` ()
06:23:40 <ivanm> which is kinda cheating and looks wrong... >_>
06:23:50 <chrisdone> Ah, sure.
06:23:57 <ski> > phase (2 :+ 3)
06:23:57 <lambdabot>   0.982793723247329
06:23:58 <ski> > atan2 3 2
06:23:58 <lambdabot>   0.982793723247329
06:24:06 <parcs> :t phase
06:24:07 <lambdabot> forall a. (RealFloat a) => Complex a -> a
06:24:13 <ski> @type atan2
06:24:14 <lambdabot> forall a. (RealFloat a) => a -> a -> a
06:24:22 <ski> linduxed : hm, i suppose you could just as well use `atan2', here instead
06:24:34 <Botje> ivanm: strictifySpine xs = lengtg xs `seq` xs? :)
06:24:39 <Botje> *length
06:24:49 <ivanm> Botje: yeah, that's what I'm doing atm
06:25:28 * chrisdone likes using do let !x = …; …
06:25:29 <ski> linduxed : `atan2 y x' represents `atan (y / x)', except that `x' being zero won't be a problem, and that `atan2' also correctly distingiushes between opposite directions/angles
06:26:24 <linduxed> ski: oooh that sounds nice
06:26:25 <chrisdone> ivanm: How about do let combs = combinations c sms; !_ = length combs; return combs
06:26:26 <hpc> @run atan2 5 0
06:26:27 <lambdabot>   1.5707963267948966
06:26:32 <hpc> huh
06:26:41 <hpc> @src atan2
06:26:41 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
06:26:57 <ski> linduxed : so in your case, `atan2 (pointYval p2 - pointYval p1) (pointXval p2 - pointXval p1)' would be the cotangent, in angles, iiuc
06:27:01 <chrisdone> ivanm: I suppose using `length' is unnecessary. I just like the look of the let bangs syntactic sugar.
06:27:10 <ivanm> well, I've tried return $! combinations c sms, return $!! combinations c sms, return . strictifySpine $! combinations c sms; none make a difference :s
06:27:22 <ski> linduxed : sorry, flip the order of the arguments to `atan2', there
06:27:28 <chrisdone> $!! == deepseq?
06:27:30 <ivanm> I might try strictifying the data structures...
06:27:33 <linduxed> ski: mhm thought so
06:27:36 <ivanm> chrisdone: yeah, deepseq version of $!
06:27:40 <linduxed> ski: yeah that would work i guess
06:27:42 * chrisdone nods
06:27:44 <ivanm> I've made a proposal to libraries@ to add it
06:28:44 <ski> linduxed : then you just use `sortBy (comparing myCoTan)' i think
06:29:18 <hpc> try let cs = strictify ... in cs 'seq' return cs
06:29:22 <hpc> perhaps
06:29:34 <ski> ivanm : .. why would that look wrong ?
06:29:35 <roconnor> why are peple calling tangent?
06:29:36 <hpc> (this phone doesn't do backticks)
06:29:55 <linduxed> ski: hmmm, but how would that account for the first element in the list... i mena it's placed there in the front due to it being the lowest Y-val
06:29:56 <roconnor> why not just compare slopes?
06:30:04 <ivanm> ski: having nested seqs like that.... *shrug*
06:30:06 <ivanm> dunno ;-)
06:30:15 <ski> linduxed : just remove the first element, sort the rest, then add it back ?
06:30:28 <linduxed> ski: yeah i guess that works...
06:30:34 <linduxed> ski: or let me think now
06:30:52 <ivanm> wtf? I have: data FaceInfo = FInfo { faceNodes :: !CList Node, edgeCrossings :: !CList ((Edge,Edge),Face) }, and ghc doesn't like that first bang
06:31:03 <ski> ivanm : oh, i see .. well `strictifySpine (_:xs) = strictifySpine xs' should work as well :)
06:31:03 <linduxed> ski: i'm just concerned about values in the third and fourth quadrant
06:31:09 <Lemmih> ivanm: !(CList Node)
06:31:11 <ivanm> ski: oh, yeah ;-)
06:31:20 <ivanm> Lemmih: it didn't bitch about me doing that elsewhere :s
06:31:25 <ivanm> (as in previously in that file)
06:31:39 <ski> (with a `seq x', or `seq (strictifyElement x)', if you want that)
06:31:59 <ski> linduxed : what about them ?
06:32:09 <ivanm> oh, maybe it didn't like that one first because it was exported and the other isn't...
06:34:09 <iratsu> what's a good introduction to haskell for a functional programmer?
06:35:41 <ivanm> iratsu: book or online?
06:35:54 <ivanm> iratsu: and do you mean you know functional programming already?
06:36:14 <iratsu> ivanm: i mean i know ML already, yea
06:36:21 <ivanm> @where rwh
06:36:22 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
06:36:29 <iratsu> ivanm: either book or online
06:36:42 <ski> @where tutorial
06:36:42 <lambdabot> http://www.haskell.org/tutorial/
06:36:57 <ski> ivanm : you might try the "Gentle Tutorial" ^
06:37:05 <ski> er
06:37:07 <ski> iratsu : ^
06:37:16 <iratsu> cool I'll try those, thanks!
06:37:19 <ivanm> roconnor: adding bangs to the fields in planar-graph didn't help
06:37:42 <ivanm> I'll try replacing the tuples tomorrow (or, more correctly later today)
06:39:00 <ski> @localtime ivanm
06:39:00 <lambdabot> Local time for ivanm is Sun Jul  3 00:13:35
06:40:37 * ivanm -> land of nod
06:41:19 <Botje> watch out for gdi troops!
06:46:45 <roconnor> ivanm: well, as you said, you may not want to be making your data strict
06:52:23 <linduxed> ski: i just suspected they might not play nice with tan
06:52:31 <linduxed> ski: i think i was wrong
06:53:11 <linduxed> ski: btw i found a guy's solution to the problem, he does it very elegantly http://pastie.org/2154644.txt
06:58:08 <linduxed> to a large extent what ivanm advised me to do (with me being to incompetent to actually implement it :-P)
06:58:25 * hackagebot hbro 0.6.0 - A suckless minimal KISSy browser  http://hackage.haskell.org/package/hbro-0.6.0 (koral)
06:59:59 <ski> linduxed : i'd use pattern-matching instead of `head' and `tail', though
07:00:39 <ski> and instead of `(pivotx,pivoty) = initialPoint', i'd use a `initialPoint@(pivotx,pivoty)' pattern
07:02:26 * hackagebot lambdacube-engine 0.2.2 - 3D rendering engine written entirely in Haskell  http://hackage.haskell.org/package/lambdacube-engine-0.2.2 (CsabaHruska)
07:03:26 * hackagebot stunts 0.1.2 - A revival of the classic game Stunts (LambdaCube tech demo)  http://hackage.haskell.org/package/stunts-0.1.2 (CsabaHruska)
07:11:18 <parcs> i bet the hbro library is like 20M
07:11:25 <parcs> err, executable
07:15:03 * roconnor reads KISS in combinator form
07:17:17 <jackl> hello
07:18:57 <parcs> hello
07:22:14 <jackl> how goes it parcs
07:50:31 <andreas_> Does anyone know of a good Haskell library that binds to one of the good BDD implementations? Or does anyone have experience with hBDD - I'm not finding things in that library that I would expect to see.
08:06:15 <joeyh_> does it matter if I use cabal sdist to build a tarball for hackage, or do it myself? My problem is that my package has hundreds of directories of files, and listing them all in the cabal file would be insane (and the globs are intentionally too limited)
08:08:02 <colah> I'm using parsec (installed through cabal, installed through Ubuntu) and even the most trivial programs fail in linking with messages like "(.text+0x1e27): undefined reference to `__stginit_parseczm3zi1zi1_TextziParserCombinatorsziParsec_'". If I load into ghci, everything works fine.
08:08:25 <azaq23> colah: try ghc with --make
08:08:56 <colah> azaq23: It worked! Thanks!
08:10:35 <ski> preflex: zdec __stginit_parseczm3zi1zi1_TextziParserCombinatorsziParsec_
08:10:35 <preflex>  __stginit_parsec-3.1.1_Text.ParserCombinators.Parsec_
08:13:11 <gienah> joeyh_: a probably crazy idea: could maybe hook preSDist in Setup.hs and return the list of files in HookedBuildInfo
08:13:48 <joeyh_> I thought about that.. but when I tried to run preSDist, my code did not ever run!
08:14:19 <joeyh_> (unfortunatly I did not save a copy, but it was simply using the hook and trying to putStrLn .. and other hooks work
08:15:02 <gienah> joeyh_: hmm, I haven't tried it, seems strange it was not called
08:17:36 * hackagebot hbro 0.6.1 - A suckless minimal KISSy browser  http://hackage.haskell.org/package/hbro-0.6.1 (koral)
08:18:32 <joeyh_> yeah, just tried again with: main = defaultMainWithHooks simpleUserHooks { preSDist = error "hello world" } and after cabal configure, cabal sdist does not run it
08:19:58 <tgeeky> ah. nice work on stepeval!
08:19:58 <guerrilla> anyone know if there is a shorter way to write the last two lines of http://hpaste.org/48637 ?
08:20:00 <tgeeky> very sexy
08:20:36 <ion> Wrap <$> translateBar bar
08:20:51 <guerrilla> ion: perfect.. i suspected something like that
08:20:54 <guerrilla> thanks a lot
08:21:08 <guerrilla> (this code was getting tedious doing it the way above)
08:21:46 <gienah> joeyh_: your program works here when I try it like: runghc ./Setup.hs sdist
08:22:14 <ion> @@ @pl @undo do foo <- translateBar bar; return (Wrap foo)
08:22:14 <lambdabot>  Wrap `fmap` translateBar bar
08:22:18 <gienah> joeyh_: (after I added a few imports)
08:22:23 <ion> <$> is the same as `fmap`
08:22:34 <guerrilla> ion: yeh, i just saw in control.applicative
08:22:48 <guerrilla> thanks a lot
08:24:29 <joeyh_> hmmmm
08:26:08 <joeyh_> so it does! But not when cabal sdist
08:26:08 <joeyh_> so, cabal is not running setup for sdist?
08:27:51 <gienah> joeyh_: I'm not really sure, I never use cabal
08:28:56 <gienah> joeyh_: if you need to debug it in ghci then you can hard code the command line argument like: main = withArgs ["sdist"] defaultMainWithHooks simpleUserHooks { preSDist = error "hello world" }
08:30:48 <ClaudiusMaximus> joeyh_: afaik, cabal ignores Setup.hs when build-type: Simple  - try build-type: Custom
08:32:35 <joeyh_> I have Custom already.. my Setup.hs is being used for other hooks
08:32:47 <ClaudiusMaximus> joeyh_: ah. then i'm out of ideas
08:32:54 <joeyh_> but I have verified with strace now, cabal is not running dist/setup/setup for sdist
08:33:35 <joeyh_> anyway, I guess I'm back to my original question: Can I just work around this by building my own tarball, or will some machinery in hackage expect to be able to sdist?
08:36:41 <gienah> joeyh_: we will probably not package your package in linux distros if sdist is broken, and raise bug reports if we try :-/
08:37:03 <joeyh_> well it's already in most distros, but ok..
08:37:43 <joeyh_> seems like the only option then is a 40kb .cabal file... which I cannot version control
08:38:06 <gienah> joeyh_: I'm wondering, are you trying to package a c library that is already in linux distros ?
08:39:47 <joeyh_> no, I'm doing git-annex, which while a haskell program has been using make
08:39:53 <joeyh_> but I thought I might as well put it in hackage
08:42:02 <gienah> joeyh_: I am not sure if we have git-annex on gentoo
08:46:10 <joeyh_> let me just say that the limited regexps that don't allow */* are annoying. :P
08:46:53 <joeyh_> most of my files are user documentation and wiki, and so more are always being added..
08:56:48 <k0ral> anyone uses webkit package ?
08:57:28 <k0ral> I'm getting frozen whenevr a flash video is played, even in the demo application provided by the package
09:03:31 <gienah> joeyh_: looking at the eclass on gentoo, it does not seem to use sdist, so it may not matter for gentoo, I don't know about other distros
10:01:34 <danharaj> Is it efficient to foldr a list of functions and then apply it to an object?
10:02:31 <ion> Why not?
10:02:35 <ion> (Also, object?)
10:02:39 <danharaj> value, whatever
10:03:02 <danharaj> because it might build a big ol' thunk before applying the functions? Maybe I should foldl actually.
10:03:11 <danharaj> (yes my functions commute)
10:03:19 <c_wraith> it's not going to matter
10:03:28 <c_wraith> you're building up a giant function first either way
10:03:44 <c_wraith> seq doesn't do anything to functions
10:04:00 <c_wraith> so you can't evaluate it under the lambda
10:04:02 <Saizan> with foldl you can avoid building the giant function
10:04:33 <Saizan> s/with foldl// -- not important
10:04:34 <ion> How about using the value as the initial accumulator and applying each function one by one in foldl'?
10:04:51 <Saizan> what ion said
10:05:04 <danharaj> yes quite
10:05:09 <c_wraith> err, *because* you can't evaluate it under the lambda
10:05:20 <c_wraith> Honestly, I don't see that making a difference
10:05:29 <c_wraith> unless the list of functions is being generated lazily
10:05:40 <danharaj> yes of course
10:05:50 <azaq23> > (foldr (.) [(* 2), (+ 2)]) 4, foldl' 4 [(+ 2), (* 2)]
10:05:51 <lambdabot>   <no location info>: parse error on input `,'
10:05:57 <azaq23> > (foldr (.) [(* 2), (+ 2)]) 4, foldl' 4 [(+ 2), (* 2)])
10:05:58 <lambdabot>   <no location info>: parse error on input `,'
10:07:12 <Saizan> (foldr (.) id [(* 2), (+ 2)] 4, foldl' (flip ($)) 4 [(+ 2), (* 2)])
10:07:16 <Saizan> > (foldr (.) id [(* 2), (+ 2)] 4, foldl' (flip ($)) 4 [(+ 2), (* 2)])
10:07:18 <lambdabot>   (12,12)
10:31:22 <norm2782> has anyone already tried HP on OS X Lion?
10:52:55 * hackagebot hbro 0.6.2 - A suckless minimal KISSy browser  http://hackage.haskell.org/package/hbro-0.6.2 (koral)
11:09:12 <linduxed> for the following code, i've realized i can't get away (not that i know of, at least) without implementing some kind of stack. I need it somewhere within checkTurns on line 90
11:09:37 <linduxed> could someone suggest how this could be done without doing something terribly ugly?
11:21:36 <napping> what are you trying to do?
11:30:17 <kmc> linduxed, a list is a stack
11:30:36 <kmc> use (:) to push elements onto the top
11:30:44 <kmc> use pattern-matching to check for empty and otherwise pop an element
11:31:45 <Codex_> can general intersection be implemented in computers? (how are equalizers implemented if proper (non-boolean) intersection is not available?)
11:32:00 <kmc> what?
11:32:15 <kmc> what is "general intersection" and what's an equalizer?
11:32:16 <Codex_> I mean, for normal types/sets whatever
11:32:34 <kmc> why is proper intersection "non-boolean"?
11:32:45 <kmc> how are you representing sets?
11:33:11 <Codex_> because the boolean intersection is trivial to do with s \in A <=> s \in B && s \in C.
11:36:16 <Codex_> but the problem is that you only get boolean out from that operation
11:36:29 <Codex_> but I would want a type or set as output
11:39:52 <nus> Codex_, are you asking if there's an universal operator (like your '&&') which does 'general' intersection?
11:39:58 <kmc> most languages have a datatype for finite sets which supports intersection just fine
11:40:03 <kmc> i gather that's not what you're talking about
11:40:21 <kmc> at the type level, your question only makes sense in a system with subtyping
11:40:41 <kmc> because (s ∈ B) ∧ (s ∈ C) ⇒ B = C otherwise
11:40:49 <linduxed> napping: an implementation of the graham scan algorithm, in that spot i need to add something, most likely some sort of list to keep track of what points are a part of the hull
11:41:27 <kmc> and i don't know much about type theory of subtyping
11:41:33 <kmc> but i believe intersection types have been studied
11:41:36 <linduxed> kmc: so do i use let to create some different list than the return-list?
11:42:05 <kmc> don't have to use "let", but sure
11:42:15 <linduxed> kmc: because i know i could use (:) and maybe... tail and head and stuff like that to manipulate the "stack"
11:42:16 <kmc> > let push = (:) in push 3 [1,2,4]
11:42:17 <lambdabot>   [3,1,2,4]
11:42:24 <Codex_> kmc: the main problem is that my equalizer implementatino just gives me booleans as output. And I've not figured out a way around that limitation.
11:42:25 <kmc> don't use 'tail' and 'head'
11:42:30 <kmc> ever, if you can help it
11:42:32 <kmc> use pattern matching
11:42:33 <linduxed> but i don't know i should add that "stack" into that code
11:42:57 <dylukes> How is pattern matching done at runtime?
11:43:06 <kmc> in GHC?
11:43:09 <dylukes> yeha.
11:43:26 <kmc> ok so
11:43:28 <kmc> *deep breath*
11:43:47 <wli> LR(k) stack machines?
11:44:06 <kmc> each object in the heap has an "info pointer" as well as zero or more data fields
11:44:35 <kmc> the info pointer points to a static table for that constructor.  so there's one table for all Just constructors, and one for Nothing
11:44:39 <kmc> one for (:) and one for [], etc.
11:45:06 <kmc> this "info table" contains, among other things, a pointer to some code.  the "entry code" for that heap object
11:46:47 <kmc> the entry code for (Just x) will push 'x' onto the argument stack, and store a value into a machine register indicating which constructor it was
11:47:17 <kmc> i.e. Nothing gets the tag 0 and Just gets the tag 1
11:47:42 <kmc> then it returns to the top continuation on a stack of continuations
11:48:20 <kmc> the code for «case x of Just y -> a; Nothing -> b» will push a continuation for «Just y -> a; Nothing -> b»
11:48:31 <kmc> which is a pointer to some code with something like a C 'switch' statement
11:48:57 <napping> also, http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution/PointerTagging
11:48:59 <kmc> it then jumps to the entry code for 'x'
11:49:40 <kmc> dylukes, the reason this is so indirect is that 'x' might also be a thunk
11:49:44 <Codex_> is intersection limited to finite sets?
11:49:53 <kmc> the entry code for a constructor just returns a tag and its fields
11:50:01 <napping> Codex_: if you have functions to Bool, you can define intersection as you wrote above
11:50:04 <kmc> but the entry code for a thunk can do arbitrary computation before returning
11:50:06 <dylukes> one moment...
11:50:20 <Codex_> since you can do intersection of lines.. etc. I simply assumed it works for infinite sets too
11:50:52 <dylukes> Not sure I quite get it.
11:50:58 <dylukes> A picture would probably be good. Oh well.
11:51:03 <dylukes> I need to get cmake working
11:51:22 <kmc> dylukes, the papers to read are "Implementing lazy functional languages on stock hardware" and then "Making a fast curry"
11:51:35 <kmc> what don't you get
11:52:12 <kmc> Codex_, intersection of infinite sets is well-defined...
11:52:48 <kmc> in ZFC, by the axiom schema of restricted comprehension
11:53:40 <kmc> S ∩ T = { x ∈ S | x ∈ T }
11:53:40 <Codex_> kmc: oh, that could be useful if I saw how intersection is defined based on axioms. I'll try find a proof.
11:53:54 <Codex_> oh, the membership used.
11:54:03 <Codex_> that gives us only the boolean version :(
11:54:13 <kmc> what do you mean?
11:54:19 <kmc> you wanted intersection of sets
11:54:19 <Codex_> I mean, I'd have to implement using S->bool && T->bool
11:54:40 <Codex_> and that means I only get booleans out from it
11:54:47 <kmc> no
11:55:06 <kmc> type Set = Universe -> Bool
11:55:10 <Codex_> how to implement it then?
11:55:17 <kmc> intersection :: Set -> Set -> Set
11:55:37 <kmc> intersection f g x = (f x) && (g x)
11:55:50 <kmc> in this implementation a set *is* its characteristic function
11:56:14 <kmc> (that only gets you computable sets, btw)
11:56:50 <kmc> now it's sometimes inconvenient to work with functional representations
11:57:00 <kmc> so e.g. Haskell's Data.Set implements finite sets as balanced binary trees
11:57:06 <kmc> which are first-order values and so easy to inspect
11:57:10 <kmc> and you can intersect those too
11:57:27 <kmc> the idea of intersection is inherently boolean
11:57:30 <kmc> as is set theory itself
11:58:30 <Eelis> i think that what Codex_ may be after is the ability to enumerate elements in sets
11:58:42 <Eelis> which the T->Bool representation doesn't give in general
11:58:55 <kmc> ah, yes
11:59:23 <kmc> well in a sense it does
11:59:38 <Codex_> in normal diagrams about characteristic functions, there is another function K->T, and I have not been able to handle that properly.
11:59:39 <nus> heh, AoC?
11:59:39 <kmc> because you're in a computer and therefore your Universe is countable
11:59:45 <Eelis> so maybe he should just use (possibly infinite) lists where intersection is done by making  x_0,y_0,x_1,y_1,...
11:59:47 <kmc> but point taken
12:01:09 <Codex_> but there is an implementation of equalizer and pullback which uses inverse image. But it also needs intersection, which only allows getting A->bool functions out from it. I.e. it works with characteristic functions only.
12:01:27 <Eelis> kmc: by the way, good luck enumerating Int->Int in Haskell ;)
12:01:46 <Eelis> or actually Integer->Integer
12:03:55 <Codex_> there was some hope of getting it solved based on "unique up to isomorphism", but it just relies on getting one boolean as input.
12:04:29 <Codex_> we just don't understand this well enough yet :(
12:13:36 <jonkri> if you were to parse an xmpp address (localpart@domainpart/resourcepart), where localpart and resourcepart are optional, using parsec, would you do it imperative by parsing a part, looking ahead, parsing another, and casing... OR, would you parse all combinations of addresses as separate parsec parsers, and trying them one after another until one succeeds?
12:15:43 <trygvis> I would implement whatever looks best and optimize later if that turns out to be an issue :)
12:15:47 <jonkri> like parseFullAddress <|> parseResourceAddress <|>...
12:15:49 <Baughn> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=let+fibs+%3D+0+%3A+1+%3A+zipWith+%28%2B%29+fibs+%28tail+fibs%29+in+fibs <- And this, folks, is why lazy evaluation is superior.
12:15:53 <roconnor> trygvis++
12:16:11 <jonkri> right, got ya :)
12:41:40 <xil> hi everyone. I need to record OpenGL screen data to a video file. My plan was to read the screen pixels with OpenGL functions (haven't looked too much into that yet) and then record it to a video file one frame at a time. But for the latter part I'm stuck. Could someone point me in the direction of a tool or library for creating videos with Haskell?
12:46:04 <doserj> I would save the individual pictures and call an external program to encode a video
12:46:37 <trygvis> mplayer might be an alternative
12:46:47 <pesco_> maybe mencoder has some raw input mode that you can stream to
12:46:50 <trygvis> I've used mplayer to decode a video to give me each image in a raw format
12:47:17 <trygvis> you can always stream to mplayer too@
12:47:58 <pesco> (mencoder = encoding variant of mplayer)
12:48:13 <trygvis> oh :)
12:48:19 <dylukes> doserj: That sounds like a bad idea to me :|
12:48:31 <dylukes> doserj: Raw image/movie files are… big. To say the least.
12:48:38 * edwardk waves hello.
12:48:45 <dylukes> hi
12:49:08 <trygvis> with mplayer you can stream it in-process
12:49:09 <xil> I'm looking at hs-ffmpeg right now; just found it. This is, I don't know anything about ffmpeg and the tutoriall is....lacking for a noob
12:49:22 <xil> thing is*
12:49:53 <ClaudiusMaximus> xil: personally, i output ppm stream to stdout into ffmpeg standalone, of course this breaks if you have any output to stdout...
12:50:25 <pesco> that you can solve
12:50:30 <xil> ClaudiusMaximus: I don't have any output to stdout. I'll look into that
12:50:54 <edwardk> is there an existing library with a good notion of a unique factorization domain or euclidean domain?
12:51:26 <pesco> xil: just spawn the encoder from your program and go via a pipe.
12:52:05 <xil> pesco: do you know off the top of your head to do that? I've never spawned anything from haskell. I know there is a "spawn" function but how do I get a pipe to what I spawned?
12:52:10 <pesco> xil: whatever the routine is called, from System.Process or somesuch ;)
12:52:42 <doserj> edwardk: http://hackage.haskell.org/package/constructive-algebra is the only one I know
12:52:54 <faust45> hi guy's
12:53:09 <edwardk> ah fairly similar to the algebra package i was putting together
12:53:19 <faust45> what i can read about async io in Haskell?
12:53:30 <faust45> please advice
12:53:49 <pesco> xil: let me look at my current project... runInteractiveProcess is the one i used.
12:54:13 <ClaudiusMaximus> xil: i used HSH in some really old code
12:55:04 <ClaudiusMaximus> but i seem to recall having trouble with some aspects (too much buffering or so, but my videos were short so it was ok)
12:55:32 <xil> pesco: I see the function. But I don't know how it affects me where it says "the handles are in binary mode by default"
12:55:54 <pesco> oh that's irrelevant.
12:56:25 <xil> ClaudiusMaximus: do you recall how you ran ffmpeg? I mean, what flags and such? I see the man page and it's a bit intimidating. I'll read it if you think it's pretty straightforward, but if not I could use at least something to start with
12:56:26 <pesco> a) only applies to windows b) even then it's the right mode for your task ;)
12:56:39 <xil> pesco: haha, okay awesome
12:57:51 <pesco> xil: good luck! should be rewarding when you get it working :)
12:58:55 <ClaudiusMaximus> xil: hm, not off the top of my head - grepping my scripts now..
12:59:25 <xil> pesco: indeed. This is for a simulation I'm running that gets very slow very fast. I want to set up a way to record it, then I can run it for hours on another machine I have and view the playback later
12:59:58 <xil> ClaudiusMaximus: thanks. Anything would help really, but if you don't find your stuff or something it's no big deal. I'll look at the man in the mean time anyway
13:00:08 <edwardk> the way http://hackage.haskell.org/packages/archive/constructive-algebra/0.3.0/doc/html/Algebra-Structures-BezoutDomain.html is implemented makes me sad. why make a class just to instantiate it once?
13:01:16 <ClaudiusMaximus> xil: the closest i've found so far is:  ppmtoy4m ... | y4mscaler ... | ffmpeg -f yuv4mpegpipe -b $bitrate -i - output-video.mkv    but i'm sure at some point i worked out how to make ffmpeg understand ppm streams directly...
13:05:51 <doserj> edwardk: yeah, that is just a bug
13:07:34 <edwardk> they do have some other interesting stuff in there i'm missing
13:08:17 <edwardk> i'm mostly just chasing after some bits so i can solve things like determinants using the chinese remainder theorem to shrink the intermediate results
13:08:59 <edwardk> and seeing if i can get a reasonably efficient integer-simple-like library as a test of my polynomials
13:09:05 <xil> ClaudiusMaximus: awesome, thanks. At least that's a starting point to jump off from
13:09:58 <edwardk> hrmm, their Ideal's are also pretty annoying because they use the class constraint on the data type =/
13:10:29 <ClaudiusMaximus> xil: also, i have some poor-quality (breaks when imagewidth not a multiple of 4, for obscure opengl reasons..) code here for opengl->ppm.. https://gitorious.org/maximus/mandulia/blobs/master/src/Snapshot.hs
13:13:12 <doserj> edwardk: their Ideal.eval didn't make much sense to me, too
13:13:35 <xil> ClaudiusMaximus: thanks
13:14:29 <edwardk> the sum of the product of the generators of the ideal and the point in question?
13:14:51 <Twey> edwardk: In case other people want to instantiate it later
13:14:51 <Twey> ?
13:15:11 <edwardk> twey: but any such instance would overlap
13:15:11 <doserj> edwardk: yeah
13:15:21 <edwardk> twey: so it wouldn't be safe
13:15:56 <edwardk> twey: they could make a bezoutDefault that could be used for any euclidean domain with an Eq instance, though
13:16:01 <edwardk> like liftM
13:16:28 <Twey> Ech, point
13:18:05 <edwardk> but the separate naming seems to imply they want to allow for BezoutDomains that aren't Euclidean
13:18:30 <edwardk> which is exactly why i want a bezout domain in the first place!
13:21:13 * hackagebot git-annex 3.20110702 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20110702 (JoeyHess)
13:28:19 <chaoflow> emacs just crashed! - what's the status of Yi?
13:28:58 <parcs> i can't get it to build :)
13:29:35 <chaoflow> I'm half way through the haskell tutorial and am searching real world tasks
13:29:51 <chaoflow> if there is something non-time-critical...
13:30:25 * chaoflow imagines a ticket with clear task description
13:30:42 <trygvis> chaoflow: check out tickers for hledger
13:30:50 <cheater_> what is yi?
13:30:53 <trygvis> http://bugs.hledger.org/
13:31:08 <chaoflow> my goal would be: having emacs behaviour (except for the crashes), org-mode and notmuch
13:31:20 <merijn> cheater_: An editor written in haskell aiming at vim and emacs compatibility
13:31:27 <merijn> Speaking of which...
13:31:42 <merijn> dankna: Ping? Did you manage to solve the Te compile problem?
13:31:46 <chaoflow> trygvis: will do! for now I'll have to fire up a new emacs and continue with the javascript project
13:32:08 <chaoflow> why oh why is always everything else so much better than the thing you have to do?
13:32:11 <cheater_> merijn, is that the one dankna was working on?
13:32:15 <cheater_> with the tree-style editing?
13:32:56 <merijn> cheater_: Yeah, was trying to get it to compile yesterday, but no luck yet
13:33:08 <cheater_> yeah he stopped working on it!
13:33:14 <cheater_> to work on some stupid speech synthesizer :p
13:33:20 <roconnor> preflex: seen twanvl
13:33:20 <preflex>  twanvl was last seen on #haskell 17 days, 9 hours, 28 minutes and 23 seconds ago, saying: dAnjou: put that line in ~/.ghci
13:33:22 <cheater_> i suggest you bug him until he resumes working on it :p
13:33:34 <Xaratas> > do { guess <- getLine; if (read guess) < 8; then putStrLn guess; else putStrLn "b"}
13:33:35 <lambdabot>   <no location info>: parse error on input `;'
13:33:57 <Xaratas> hm @ ?
13:34:07 <chaoflow> merijn: you say "aiming at vim and emacs compatibility" - to what degree? Inclusion of a elisp and vimscript engine to reuse plugins?
13:34:43 <merijn> chaoflow: No clue, don't use it :p
13:35:23 <chaoflow> merijn: emacs and vim or Yi?
13:36:14 <parcs> chaoflow: emacs- and vim-compatible keybindings, at least
13:36:35 <hpaste> hargettp pasted “what's wrong with the Priest show instance” at http://hpaste.org/48646
13:36:51 <hargettp> insight appreciated. rookie here :)
13:37:09 <Xaratas> i dont get the typecheck -.-
13:37:25 <hargettp> which one/
13:37:26 <hargettp> ?
13:37:27 <parcs> hargettp: you are using IO in a pure function
13:37:51 <chaoflow> is anybody using Yi on a daily base (except for debugging it)?
13:37:58 <hargettp> uh oh...which function is pure?  thought I was using IO properly
13:38:05 <parcs> show
13:38:07 <parcs> :t show
13:38:08 <mike-burns> hargettp: show is pure.
13:38:08 <lambdabot> forall a. (Show a) => a -> String
13:38:21 <mike-burns> You probably want makePriest to be pure, too.
13:38:31 <mike-burns> (Hm, is there irony in there?)
13:38:35 <hargettp> hmm...okay, so how would I rewrite show?
13:38:38 <kmc> you can't show an IO action
13:38:45 <hargettp> (heh)
13:38:50 <kmc> it's not actually an unreasonable idea
13:38:55 <kmc> but it probably would not do what you expect
13:39:20 <parcs> > show (putStrLn "hey")
13:39:21 <lambdabot>   "<IO ()>"
13:39:22 <hargettp> okay, I'm naively starting from a C++/Java point of view, where a Ledger is just a struct...and a Priest uses a ledger to track state
13:39:26 <merijn> chaoflow: I don't use Yi, I use vim
13:39:52 <kmc> show needs to return a String.  you're trying to write a show which returns an IO String
13:39:59 <kmc> IO String and String are totally different types
13:40:09 <kmc> String is a string, IO String is a description of how you *could* perform IO to get a string
13:40:20 * hackagebot git-annex 3.20110702.2 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20110702.2 (JoeyHess)
13:40:45 <hargettp> ugh, I thought the result of evaluating the whole do{}  would pull the 'a' out 'IO a'
13:40:51 <kmc> no
13:40:55 <hargettp> dang
13:40:58 <parcs> heh
13:41:00 <kmc> evaluation and execution are distinct
13:41:03 <hargettp> sure
13:41:12 <kmc> evaluation never causes execution
13:41:23 <kmc> (except for some weird corner cases like "lazy IO" and other libraries which break the rules)
13:41:24 <jmcarthur> well... ideally
13:41:29 <jmcarthur> yeah
13:41:30 <hargettp> so how would I rewrite show in this case?
13:41:38 <kmc> you fundamentally can't do this
13:41:51 <kmc> Show is not the right type class
13:42:06 <kmc> just write a function "formatPriest :: Priest -> IO String"
13:42:15 <chaoflow> merijn: I liked vim a lot
13:42:29 <hargettp> kmc: interesting, ok
13:42:39 <hargettp> or "showPriest :: Priest -> IO String"
13:42:41 <parcs> chaoflow: use whatever you're comfortable with
13:42:46 <kmc> you can't write a useful MVar t -> String function
13:42:53 <parcs> haskell doesn't have a de-facto ide (yet)
13:43:26 <chaoflow> parcs: certainly not looking for a editor discussion
13:43:52 <parcs> same here
13:43:55 <kmc> hargettp, you can't write a function to get the contents of the MVar, because it would not be referentially transparent, and therefore not really a function at all
13:44:10 <T7D> But there is Leksah...
13:44:20 <kmc> hargettp, you can write a function that takes an MVar and returns an IO action that, if executed, would read the MVar
13:44:25 <T7D> ...as an IDE, I think.
13:44:28 <kmc> 'readMVar' is such a function
13:44:43 <hargettp> kmc: so you're either in IO land, or your not, eh?
13:45:01 <kmc> IO actions are first-class values and it's perfectly fine for a function to return one, but the IO does not occur until the IO action is executed
13:45:09 <kmc> execution ≠ evaluation
13:45:23 <kmc> the only IO action which is actually executed is the one named "main"
13:45:43 <kmc> which is typically built by gluing together other IO actions that come from elsewhere
13:45:52 <kmc> you do this gluing with the "do" syntax, or the underlying (>>=) operator
13:45:54 <hpaste> Xaratas pasted “IO is weird” at http://hpaste.org/48647
13:45:56 <kmc> but the result is still an IO action
13:46:14 <merijn> hargettp: Pretty much, the advantage being that the compiler can reorder anything that is not IO and the IO actions functioning as sequencing interactions with the outside world
13:46:18 <kmc> hargettp, yeah, that's one way to think about it
13:46:32 <kmc> hargettp, people often talk about "pure functions" vs "impure functions" but that's not really what's going on
13:46:35 <hargettp> kmc: got it...I think I failed to observe that do {} results in an IO type
13:46:44 <hargettp> heh, I think I got it anyway lol
13:46:47 <Xaratas> ok, why i could not get the (IO) integer which is "somewhere" at runtime there and put it in liftIO?
13:46:48 <jmcarthur> well, with certain invariants, it is possible for reading from an MVar to be referentially transparent, but it's probably better for beginners to ignore this possibility entirely
13:46:50 <kmc> the important distinction is evaluation vs. execution
13:47:08 <hargettp> jmcarthur: ty :)  blinders are actually VERY helpful right now :)
13:47:17 <kmc> all functions are pure, but some functions return "IO actions" i.e. "recipes" describing execution to be performed in the future
13:47:20 <kmc> anyway i think you get it ;)
13:47:46 <merijn> hargettp: do notation is syntactic sugar for explicitly using monads with bind (>>=) and lambda's, so "do" is always a monad (and in the case of IO hence an IO type)
13:47:49 <hargettp> kmc: I hope so...ty!
13:47:55 <jmcarthur> :t read -- Xaratas
13:47:56 <lambdabot> forall a. (Read a) => String -> a
13:48:20 <hargettp> merijn: hmmm, good point
13:48:59 <jmcarthur> Xaratas: unless you have an instance for IO Integer (you really shouldn't, IMO), y <- read x is isn't what you hope it is
13:49:03 <kmc> the "pure vs impure functions" view doesn't really help you understand types like "IO a -> IO a" or "c -> IO (a -> IO b)"
13:49:07 <parcs> :t do 5
13:49:08 <lambdabot> forall t. (Num t) => t
13:49:13 <Xaratas> jmcarthur: jep, only pure strings, but in the first two functions it takes an IO String
13:49:15 <kmc> lots of useful functions have types like this, particularly in a concurrent context
13:49:32 <jmcarthur> Xaratas: what does?
13:50:04 <Xaratas> ?
13:50:06 * kmc . o O ( data Hungry a = Hungry (a -> IO (Hungry a)) )
13:50:10 <kmc> speaking of which, bbl
13:50:24 <jmcarthur> Xaratas: "it takes an IO String"  <-- what is "it" in that phrase?
13:50:30 <jmcarthur> read?
13:50:34 <Xaratas> the read
13:50:40 <jmcarthur> i believe you are mistaken
13:50:58 <jmcarthur> Xaratas: in the line "guess <- getLine", guess and getLine do not have the same types
13:51:08 <jonkri> what does {-# LANGUAGE CPP -} do? i found it the stringprep package but i don't quite see the point of it
13:51:19 <jmcarthur> Xaratas: getLine :: IO String    but   guess :: String
13:51:40 <jonkri> it enables #include?
13:52:00 <hargettp> ok, writing my own "showPriest :: Priest -> IO String" worked like a charm, as suggested....thx all :)
13:52:02 <jmcarthur> jonkri: it tells ghc to apply the C preprocessor to the file
13:52:24 <jmcarthur> jonkri: so that enables things like #include, #if, #define, etc.
13:52:54 <jonkri> jmcarthur, thanks
13:52:58 <merijn> hargettp: I found it helpful to think of things like this: In C++/Java your program is a list of statements executed in sequence, the IO monad is the same "do { line1; line2; line3}" executes line1, etc in sequence. Now Haskell expressions do *not* have any sequencing, the compiler can move them around and execute/not execute as it pleases.
13:53:04 <Xaratas> jmcarthur: hm, ok guess is string, so read could convert/ parse it to integer
13:53:12 <jmcarthur> right
13:53:46 <hargettp> merijn: yes, I agree...I think I'm still working on adapting to the far more rigid typing here...a ways to go yet :)
13:55:02 <merijn> hargettp: So the "IO ()" main is just a sequence of smaller IO actions, which get invoked in sequence (which may in turn be invoke even more smaller IO actions in sequence), however the Haskell expressions used within those actions can be done in any order. So in the end you want to write as many pure haskell expressions as you can with a tiny IO coating. You could also write all your functions as IO something, but then you'd have no benefit
13:55:02 <merijn> over Java/C++/whatever ;)
13:56:41 <merijn> The type system essentially promises you that any code without IO will be deadlock/race condition/state mutation free, which should make any person writing concurrent code happy :>
13:57:07 <hargettp> merijn: okay, so then the magical question that I'm sure all immigrants like myself ask: how does one deal with mutable state?
13:57:26 <jmcarthur> you wait until you're sure you need it :)
13:57:40 <hargettp> do we do similar to how I did...confine it to specific functions and places in data structures...so that the "mutability" (e.g., the IO typing) doesn't propagate too far?
13:57:50 <Bfig> hargettp, you can pass it like an argument to a monad
13:57:52 <merijn> hargettp: Pretty much
13:58:04 <hargettp> jmcarthur: i hear that :)
13:58:14 <merijn> hargettp: There are also other monads such as the state monad, which help you deal with mutable state
13:58:20 <jmcarthur> hargettp: *real* mutation exists in the IO and ST monads. ST is nice because it allows you to hide mutation inside a pure interface
13:58:37 <Bfig> monads ~ program execution flow control
13:58:44 <jmcarthur> hargettp: some libraries also hide various kinds of mutation inside a pure interface for efficiency
13:58:45 <hargettp> ST?
13:58:52 <merijn> hargettp: But yes, essentially what you try to do is encapsulate and hide mutability from your other code
13:58:58 <jmcarthur> hargettp: also, you can get away with not using real mutation most of the time
13:59:00 <merijn> hargettp: ST is short for the state monad
13:59:05 <jmcarthur> no
13:59:05 <hargettp> ah ok ty
13:59:20 <jmcarthur> the State monad is different from the ST monad
13:59:26 <merijn> No? Apparently I'm misinformed :p
13:59:29 <Twey> The ST monad is the State Transformer monad
13:59:33 <merijn> Ah, right
13:59:47 <hargettp> ah thx
14:00:04 <jmcarthur> hargettp: ST just gives you the ability to define and use mutable references without allowing you to leak them outside of the runST function
14:00:05 <merijn> hargettp: Also, the usual case for for example a list would be to simply construct a new list which is mostly the same, rather then mutate state
14:00:15 <Twey> State is a standard monad for passing around parameters implicitly; ST is magic.  It lets you do true imperative state-changing operations behind a pure interface.
14:00:23 <jmcarthur> hargettp: using some type system trickery that probably wouldn't be appropriate to try to explain to you yet
14:00:36 <hargettp> most likely not lol
14:00:47 <chrisdone> Emacs users gonna be jealous, a'ight: http://i.imgur.com/O8lha.png
14:01:18 <jmcarthur> chrisdone: huh? that's not emacs?
14:01:21 <merijn> hargettp: Imagine for example appending an item to a list, you copy the entire list and add an item in front. But of course the compiler knows the list is immutable and cheats by making the "copy" be a reference to the exact same list
14:01:23 <Twey> chrisdone: Looks like emacs to me :þ
14:01:33 <chrisdone> It is Emacs, but y'all don't have my library. :-P
14:01:38 <jmcarthur> ha
14:01:41 <Twey> Heh
14:01:51 <Twey> chrisdone: Got a date for Confy release yet?
14:02:28 <hargettp> merijn: yes...I'm sure that figuring out Paxos using strictly immutable types would be interesting...but my poor head has to allow the "ledgers" to mutable, so that I can more easily translate from Lamport's paper
14:02:44 <Twey> Where's the ‘1 + ()’ expression coming from?
14:02:51 <jmcarthur> oh i hate translating imperative code to functional code
14:02:53 <Twey> Oh, right, up there.
14:03:03 <jmcarthur> so much easier the other direction
14:03:16 <jmcarthur> not that i'd ever want to do that
14:03:24 <hargettp> lol
14:03:50 <Twey> But more satisfying to go this way
14:04:11 <merijn> hargettp: What functions are going to mutate the Priest/Ledger? Lemme see if I can come up with a pure example
14:05:26 <hargettp> merijn: haven't written them yet.  Usually, the state changes would be triggered by a message from another "Priest" in a Paxos protocol
14:06:01 <jmcarthur> is this a concurrent system?
14:06:04 <chrisdone> Twey: It's already in prod, if you mean that. Open source release won't be for a few months, probably gonna strip out all the JS before that. We were gonna redo EUDL (scientific paper archive) but the UI person can't work with anything but Rails *eyeroll*. Any word on the IRC bot architecture?
14:06:08 <hargettp> I realize I could have a "world state" (eg., a Parliament) containing individual Priest/Ledger states (the Ledger is the priest's state, really),
14:06:14 <hargettp> jmcarthur: yes
14:06:18 <jmcarthur> ah
14:06:30 <jmcarthur> tough to do shared memory concurrency without some mutable state
14:06:35 <hargettp> yep
14:07:15 <Twey> chrisdone: I meant the OSS release.  Why are you stripping out the JS?
14:07:25 <merijn> jmcarthur: Threads + channels, store the state in threads and get it out by sending/receiving messages over the channels :p
14:07:30 <hargettp> Paxos is an approach to creating consistency among distributed nodes; Lamport wrote it down in the late 90s
14:07:32 <Twey> chrisdone: Nah, finished exams now though so hopefully Soon™.
14:07:39 <hargettp> merijn: exactly :)
14:07:42 <merijn> Of course the channels/threads use IO actions, but at least those are implemented for you
14:07:51 <roconnor> > 2^32 :: Int32
14:07:52 <lambdabot>   0
14:08:07 <merijn> hargettp: channels and threads already exist ;)
14:08:19 <hargettp> yes, and what a huge bonus that is :)
14:08:43 <jmcarthur> merijn: channels are just complicated MVars :P
14:09:24 <merijn> The actual priests don't need to be IO actions in that case though, you can just have a pure priest and rely on the channels to hide state changes
14:09:45 * Twey tries to resist making a crack about pure priests.
14:09:54 <hargettp> lol
14:10:10 <hargettp> I almost want to change the name NOW, but I need it to keep my head straight with this algorithm :)
14:10:23 <Twey> Heh
14:10:35 <merijn> unsafePriest? :>
14:10:56 <chrisdone> Twey: 50% of the codebase is JS, on account of the UI being written in JS. It was a poor design choice on my part, should've gone pure Haskell. We want to target the Haskell community for contribution.
14:11:02 <hargettp> :)
14:11:36 <jorick> i'm downloading the haskell platform for mac os x, try to install… it says i need xcode 3.0… i check the apple website and xcode 3.0 costs 100 dollars? am i doing something wrong?
14:11:45 <Twey> chrisdone: Oh, right.  Going to switch to that new JS DSL of yours?
14:11:53 <hargettp> jorick: you can get it from the App Store for $4.99
14:12:00 <roconnor> If my module exports some constructors but not others, can you pattern match on those that are exported?
14:12:03 <chrisdone> 13747 of JS, 15075 of Haskell.
14:12:16 <merijn> jorick: You also get it for free with Leopard or Snow Leopard I think
14:12:21 <hargettp> ^^
14:12:49 <chrisdone> Twey: Nah, I mean totally removing any dependence on JS entirely. No business logic in it.
14:13:00 <jorick> i have 10.6
14:13:03 <Twey> Argh, there's business logic in your JS?
14:13:04 <merijn> jorick: I installed it for free from one of the DVDs I got for the Snow Leopard upgrade, anyway
14:13:06 <jorick> how do i get it for free?
14:13:34 <jorick> i'm not going to drop $5 on haskell development on mac os x… i have a linux pc
14:13:41 <jorick> this is rediculous
14:14:30 <merijn> The 100$ thing is a year long subscription to the Mac Dev community I think
14:15:08 <shadowcloud> quit
14:15:44 <chrisdone> Twey: Hm, no, presentation tier. Possibly BL, too. It's not easy to draw a clear distinction for some things.
14:16:37 <merijn> jorick: You have a Snow Leopard install DVD as well, I assume?
14:17:14 <jorick> i dunno, this is my laptop from work… i'd have to ask IT
14:17:17 <merijn> There is an "Optional Installs" folder on it, which includes xcode.mpkg
14:17:44 <merijn> Yeah, they'll probably have it at IT then
14:17:46 <napping> chrisdone: what's the project? https://www.confy.eu/info/
14:18:03 <merijn> It's a bit annoying its not installed by default
14:19:30 <chrisdone> Twey: Anyway, no JS that handles presentation or logic. (Think 'Basic HTML' view of GMail.)
14:20:47 <chrisdone> napping: That is a different project. The address is here: http://cameraready.eai.eu/
14:20:52 <Twey> chrisdone: 'kay.
14:24:50 <roconnor> @type either
14:24:50 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
14:25:08 <accel> is this is asking too much; and I'm just being greedy, let me know. Is it possible to have all the info in hoogle as a _text_ file? I find the search interface slow. And I really want something where I can just grep the file for all the type signatures.
14:25:27 <accel> i.e. I want a single file that contains the names + type signatures of all functions installed on my system.
14:25:56 <accel> I have 124GB free, and I'm willing to cache whatever shit necessary to make this happen.
14:26:17 <Botje> accel: you know you can build hoogle and its indexes yourself, right?
14:26:19 <parcs> do you mean the web interface or the cli?
14:26:29 <accel> hoogle has a cli?
14:26:37 <Botje> yes :]
14:26:52 <accel> holy shit, it's as if someone else had this problem, and instead of bitching about it, they solved it
14:27:09 <accel> apt-cache search hoogle brings up nothing
14:27:12 <ClaudiusMaximus> how does ghc ffi interact with pthreads?  for example, can i pass a  FunPtr (IO ()) to some foreign code which spawns a pthread that calls the action whenever it likes?
14:27:12 <accel> do I get it via cabal?
14:27:16 <Botje> accel: you can install it via cabal
14:27:23 <Botje> accel: and hoogle started off as a cli project iirc
14:27:34 <Botje> well, i've always rememberd the cli being there
14:27:38 <accel> damn it, why did they have to web 2.0 and javascript it
14:27:43 <accel> running cabal update ...
14:27:49 <chrisdone> Twey: I'm quite happy with hpaste's design. My boss is encouraging that we sort out something similar to WPF, which makes sense.
14:27:53 <accel> running cabal install cabal-install
14:28:03 <accel> would you guys like a real time update of what files cabal is compiling as well?
14:28:47 <Twey> accel: Hoogle isn't exactly the same thing as a textfile grep… >.>
14:28:57 <accel> yeah; but a textfile grep is _FAST_
14:29:07 <accel> whereas having 100ms delays just annoy me
14:29:08 <parcs> hoogle is quite fast too
14:29:09 <Twey> But not Hoogle :þ
14:29:11 <accel> i like instant response
14:29:25 <chrisdone> Just run the commandline version.
14:29:27 <wli> No, it's not. Use appropriate string search database structures.
14:29:30 <accel> installing cabal-install right now
14:29:42 <accel> this is exciting
14:30:06 <Twey> accel: The whole point of Hoogle is that it searches by unifying types, not by doing a text match
14:30:08 <accel> cabal install cabal-install success.
14:30:10 <accel> cabal install hoogle
14:30:20 <twanvl> roconnor: were you looking for me?
14:30:31 <Twey> I mean, you can certainly grep a textfile for types, but that won't be anything like Hoogle or in any way related to what Hoogle does :þ
14:30:41 <Twey> So Hoogle was a bad starting point if you were aiming for that :þ
14:30:43 <accel> oh; that's all that I use hoogle for
14:30:48 <accel> i.e. "what function has this type?"
14:30:54 <accel> and "what type does this function have?"
14:30:59 <accel> hoogle can do other things?
14:31:07 <Twey> accel: But there's more than one way to describe a type
14:31:28 <accel> oh, as in
14:31:29 <Twey> E.G. ‘a -> b’ could also be written ‘c -> d’ or ‘(->) e f’
14:31:31 <accel> a -> b -> c
14:31:34 <accel> vs (a -> b) -> c
14:31:43 <Twey> Which would screw up text searching
14:31:43 <accel> err, a -> (b -> c)
14:31:48 <Twey> To give a simple example
14:31:54 <merijn> accel: Finding "m a -> m b -> b" for all possible values of m
14:31:59 <accel> hoogle-4.2.5 depends on haskell-src-exts-1.11.1 which failed to install.
14:32:08 <merijn> (and all possible values of a and b, of course)
14:32:24 <accel> merijn: slow down; i'm not nearly that adept at haskell to make such queries
14:32:38 <chrisdone> @hoogle (a -> a -> c) -> a -> c
14:32:38 <lambdabot> Data.Foldable foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
14:32:38 <lambdabot> Data.Foldable foldr1 :: Foldable t => (a -> a -> a) -> t a -> a
14:32:38 <lambdabot> Prelude foldl1 :: (a -> a -> a) -> [a] -> a
14:32:54 <chrisdone> Your grep wouldn't come up with that.
14:33:02 <accel> my grep would fail in general.
14:33:48 <accel> howver, i'm a horrible person and would preer a hack that I can integrate into vim ... than the "right way" but require that I move the mouse, click in the hoogle tab, type a search, wait, and click the result
14:34:20 <chrisdone> You can integrate the `hoogle' program into vim as easily as grep if it's merely running a shell pipe.
14:35:46 <accel> the cli or the web interface?
14:36:29 <accel> damn it, now I have to run hoogle data
14:36:33 <accel> to generate some database
14:36:35 <accel> grrr
14:36:55 <accel> hmm, are these the said text files
14:36:57 <accel> I want to grep through?
14:37:32 <accel> whoa
14:37:36 <accel> the CLI is called "hoogle"
14:37:38 <accel> this is amazing
14:39:17 <chrisdone> Good things come to those who wait. :-)
14:39:27 <roconnor> apparently you can pattern match on those constructors that are exported.
14:41:17 <gwern> hoogle is nifty, but one could do more
14:42:03 <gwern> I have a script I've been working on to get functionality like '2 2 4 ~> did you mean + or *?' the idea is you use ghci :t to get the type of each argument and the desired result, ask hoogle for functions with that sig, and then run each function in mueval
14:42:18 <ivanm> roconnor: turns out that just by doing mapM_ print instead of length (and then redirected to /dev/null) it took 2.5 hrs instead of <4 min and ran out of memory :s
14:44:09 <roconnor> heh
14:44:30 <roconnor> it seems that you don't want to be too strict
14:44:59 <roconnor> I'm surprised though; it seems to means your structure doesn't fit in memory when you deepseq it
14:45:27 <roconnor> well actually maybe it doesn't mean that
14:45:41 <ivanm> oh, looks like I have some $!! in there...
14:45:44 <BCoppens> ivanm: heh, what kind of graphs are you actually generating?
14:45:45 <ivanm> thought I took them out :s
14:45:55 <ivanm> BCoppens: d-angulations of girth d eventually
14:46:02 <BCoppens> ah ok :)
14:46:37 <ivanm> atm they're "trees" but with an extra node representing an "outside face" since some of the nodes have half-edges sticking out of them
14:47:16 <BCoppens> right :)
14:47:40 <BCoppens> how large are the graphs, if it takes so much mem?
14:47:51 <BCoppens> (and how large is d :p°
14:48:50 <ivanm> atm, d=5 and the equivalent of 17 vertices in the eventual graph
14:49:25 <ivanm> so if my quick calculations are correct, the graphs I'm building have 22 vertices each when they're finished
14:49:34 <BCoppens> oh, yeah then it's surprising that it takes that long :(
14:50:30 <ivanm> I'm recursively building these trees, which means doing a lot of permutations and combinations; it appears that that is the problem :/
14:52:31 <roconnor> I worry about the lack of sharing
14:52:51 <BCoppens> ivanm: hmmm well but that doesn't explain the memory, or does it?
14:53:02 <roconnor> concat means nothing is shared; although I'm not entirely sure you need sharing.
14:53:22 <roconnor> Well concat shares a little bit.
14:53:44 <ivanm> BCoppens: roconnor suggested that they're keeping the input lists around for a while and thus keeping them in memory
14:54:04 <roconnor> sounds reasonable
14:54:10 <BCoppens> ah ok, yes indeed
14:56:44 <ivanm> but yeah, I'm doing concat a lot...
14:56:51 <BCoppens> ivanm: I'm guessing the graph generating code is not online? :P
14:56:56 <ivanm> is there a better data structure i can be using than lists to pass everything around? :/
14:57:02 <ivanm> BCoppens: you'd be guessing wrong! :p
14:57:18 <BCoppens> publicly online? :P
14:57:24 <ivanm> http://code.haskell.org/~ivanm/dangd/ which uses http://code.haskell.org/~ivanm/planar-graph/
14:57:31 <BCoppens> aha :)
14:59:03 <ivanm> the version I'm actually using to do this testing is slightly different, in that I'm not doing the conversions to the eventual graphs (so Main.hs has "let c = length $ generateMobiles d' n'" instead of the generateUndirectedDangDs bit)
14:59:29 <ivanm> and the NFData instances aren't in the repo yet (as i'm waiting for sw17ch to update data-clist with NFData instances first)
15:01:06 <BCoppens> I might have a look at it tomorrow if I'm bored with poking at my SSH client :p
15:01:22 <ivanm> ta! :D
15:01:29 <BCoppens> unlikely, but still :P
15:01:47 <roconnor> @type intercalate
15:01:48 <lambdabot> forall a. [a] -> [[a]] -> [a]
15:02:05 <roconnor> @hoogle intercalate
15:02:05 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
15:02:05 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
15:02:05 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
15:03:23 <roconnor> BCoppens: people at Nijmegen were once trying to prove someone's Java SSH implementation correct;  they were looking for where the state machine logic was stored, but couldn't find it.
15:03:32 <roconnor> turns out it wasn't there
15:03:45 <BCoppens> lol
15:03:49 <roconnor> so anyone could just jump to the end of the protocol and get access.
15:04:25 <Twey> …
15:04:26 <BCoppens> at least I'm admitting my code will probably full of security (and other) leaks :p
15:04:30 <merijn> faith_in_humanity--;
15:04:32 <Twey> WTH.
15:05:26 <merijn> Or I guess in Haskell it'd be "fmap (dec . dec) getFaithInHumanity" :>
15:05:27 <BCoppens> roconnor: on what kind of level were they trying to do the proof anyway?
15:05:39 <roconnor> I'm afraid I forget the details
15:05:44 <BCoppens> ah ok
15:06:03 <roconnor> but these might be the same people who've created formal Java semantics
15:06:24 <benmachine> oh, people are actually using stepeval
15:06:28 <benmachine> this is possibly a bad idea :P
15:06:49 <merijn> roconnor: Java has formal semantics beyond "classes!!!!111!!1!1!"? :p
15:06:55 <Nimatek> Java reminds me of http://ompldr.org/vOWJzMQ
15:07:05 <roconnor> merijn: they made a many layered monad
15:07:12 <benmachine> preflex: tell chrisdone stepeval is not really finished and has nontrivial failing testcases, use with caution :)
15:07:12 <preflex>  Consider it noted.
15:07:20 <roconnor> that's all I rememeber
15:07:46 <roconnor> merijn: it might have been only for the JVM though.
15:08:28 <merijn> Nimatek: "map f [] = []; map f (x:xs) = f x : map f xs", problem Java? :p
15:08:42 <BCoppens> roconnor: ok, so it will probably have been on that level too :) Interesting in any case :)
15:08:48 <merijn> I think 7 is finally coming, so they might finally get first class functions...
15:08:55 <Nimatek> merijn: Hah yeah.
15:08:59 <Cale> Hey, doesn't Java have (awkward) parametric polymorphism now?
15:09:22 <Twey> It's had generics for a while
15:09:25 <merijn> Cale: Kinda, sorta
15:09:30 <Cale> Yeah, I thought it did.
15:09:31 <roconnor> BCoppens: my memory about this is pretty vague so this could all be wrong.  Though I do remember the broken Java SSH implementation.
15:10:29 <Nimatek> Cale: Yeah, but it can't do the kind of polymorphism that is shown in the troll pic.
15:10:51 <Cale> Errr... hmm
15:11:07 <Cale> Well, the Haskell polymorphism is different from the C++ polymorphism
15:11:39 <erus`> monomorphism
15:12:21 <dylukes> What _is_ the monomorphism restriction everyone seems to hate so much?
15:12:27 <Cale> public <U extends Number> U f (U x) { return (x + 2); }  -- is that not valid?
15:12:39 <ivanm> @where MMR
15:12:39 <lambdabot> I know nothing about mmr.
15:13:16 <Cale> dylukes: Pattern bindings (as opposed to function bindings which syntactically have parameters), without an explicit type signature, are not allowed to be typeclass polymorphic.
15:13:37 <dylukes> I see?...
15:13:40 <Cale> So if you write:
15:13:43 <Cale> f = (+5)
15:13:59 <Cale> Numeric defaulting will apply, and force f :: Integer -> Integer
15:14:04 <Twey> public class Adder<T> { public static T add(T t1, T t2) { return t1 + t2; } } — invalid Java?
15:14:11 <Cale> even though  f :: (Num a) => a -> a  is a valid type
15:14:16 <Cale> and would be inferred for
15:14:19 <Cale> f x = x + 5
15:14:19 <Twey> Oh, Cale got there first :þ
15:14:20 <dylukes> :|
15:14:35 <parcs> > let x = read in (x "5", x "True") :: (Int, Bool) -- doesn't work outside of lambdabot
15:14:36 <lambdabot>   (5,True)
15:14:50 <dylukes> parcs: ?
15:14:53 <BCoppens> roconnor: well the broken SSH implementation is a funny anecdote in any case :)
15:15:02 <dylukes> why does it work IN lambdabot?
15:15:06 <parcs> dylukes: input that expression into ghci, and you'll see it results in a type error
15:15:07 <merijn> dylukes: Lambdabot is a vile lying monster :p
15:15:11 <merijn> > 5 5
15:15:11 <Cale> because the MR is turned off
15:15:12 <lambdabot>   5
15:15:14 <dylukes> Is Lambdabot secretly Haskell2015?
15:15:22 <merijn> dylukes: It's Caleskell :p
15:15:27 <dylukes> :P
15:15:28 <Cale> It's easy to turn off the MR in GHC
15:15:33 <dylukes> -XNoMMR right?
15:15:34 <Cale> -XNoMonomorphismRestriction
15:15:36 <dylukes> mm.
15:15:41 <parcs> easy? that's a lot of characters
15:15:46 <Twey> Heh
15:15:52 <Cale> or {-# LANGUAGE NoMonomorphismRestriction #-}
15:15:54 <dylukes> That's longer than some of my ruby/haskell one-liners
15:15:58 <Cale> heh, yes
15:16:04 <Cale> I think it should just be off by default
15:16:06 <dylukes> it should be
15:16:13 <dylukes> -XNoMonMorRes
15:16:25 <dylukes> so its easier to tell what it is.
15:16:29 <Cale> It's really stupid. The reason for it is that (some) people expect that any time you make a definition that syntactically looks like it defines a constant, then that thing should only ever be evaluated once
15:16:55 <dylukes> even if its point free?
15:16:56 <Cale> But things which are typeclass polymorphic are really functions of an implicit parameter (the typeclass dictionary)
15:17:09 <dylukes> explicit implicit parameters are amusing.
15:17:11 <Cale> and so will be recomputed at each site where they're used
15:17:26 <Cale> So if you write:
15:17:31 <Cale> x = product [1..1000]
15:17:38 <dylukes> oh, by the way
15:17:39 <Cale> and this is assigned a polymorphic type
15:17:44 <dylukes> what was the rationale for no existentials in haskell?
15:17:48 <Cale> then x gets computed at every place it's used
15:17:59 <dylukes> (and having to encode them in forall a. (a -> r) or w/e)
15:18:03 <Cale> There's existential types...
15:18:11 <parcs> why is there no exists keyword?
15:18:13 <Cale> in GHC, anyway
15:18:42 <Nimatek> Cale and Twey, no that doesn't seem to be valid Java.
15:18:48 <Cale> The reason for no exists keyword is just that they didn't want to add another keyword
15:18:55 <Cale> Nimatek: curious
15:19:02 <Twey> I wonder why
15:19:06 <Cale> I only used Java before it had generics
15:19:06 <Nimatek> It's not a C++ template, it doesn't instantiate them.
15:19:07 <ivanm> parcs: why do we need one?
15:19:30 <parcs> why do we need where _and_ let?
15:19:30 <Cale> So I never really learned the limitations
15:19:49 <benmachine> there is an exists keyword in some other compiler
15:19:53 <benmachine> I forget which
15:20:11 <benmachine> but it's not all that useful iirc
15:20:13 <Cale> But why shouldn't it be valid Java? There's an example almost like that in Oracle's Java tutorials...
15:20:14 <ivanm> parcs: where is (IMHO nicer) syntactic sugar for let
15:20:17 <ivanm> benmachine: UHC?
15:20:22 <benmachine> ivanm: something like that
15:20:26 <merijn> existentials are just done using the forall keyword, no?
15:20:44 <merijn> In GHC, anyway
15:22:02 <danharaj> What sort of CSE does GHC do?
15:22:13 <danharaj> Or do I have to do it manually with let's most of the time?
15:22:40 <roconnor> so much bizzare code is written because there are no easy sum types in C/C++
15:22:46 <danharaj> seriously.
15:22:53 <danharaj> sum types would make C much much nicer.
15:22:58 <roconnor> danharaj: GHC does almost no CSE.
15:23:01 <Nimatek> Cale: The + operator is not defined for 'U', or 'T' for that matter. Haskell has typeclasses, C++ instantiates templates and can use overloading. Java doesn't do either of those.
15:23:08 <danharaj> benmachine: IIRC it's UHC that has `exists'.
15:23:10 <roconnor> danharaj: because they worry about space leaks
15:23:59 <danharaj> roconnor: Oh? I wonder how CSE can introduce those. Can it cause data to be held on longer than it should?
15:24:42 <roconnor> danharaj: yes, but I see it as by splitting a common expression into two places it will be calculated and consumed twice rather than calculated one, and retained.
15:25:29 <danharaj> roconnor: Do you have any idea what CSE GHC does do?
15:25:34 <Cale> Nimatek: oh, I see
15:25:48 <roconnor> there was one very limited case involving lets or lambdas or something.
15:25:50 <Cale> Nimatek: because their + operator isn't using their generics system
15:25:59 <roconnor> but I forget the details.
15:26:37 <danharaj> roconnor: ah ok.
15:26:41 <merijn> Cale: Generic only works with objects I think, not with primitive types
15:26:48 <roconnor> danharaj: I did a bunch of CSE by hand for my ECC code :(
15:26:55 <danharaj> roconnor: ECC?
15:27:02 <danharaj> Like memory ECC?
15:27:04 <roconnor> elliptic curve crypto
15:27:08 <danharaj> ah
15:27:12 <danharaj> oh dear
15:27:27 <danharaj> that must have been painful
15:27:34 <Cale> Also, the Number class in Java seems pretty weak
15:27:40 <kmc> roconnor, if you use C++ and boost::variant and visitors in just the right way you get something that almost resembles pattern-matching!
15:27:43 <roconnor> adding points on an elliptic curve is where like 20% of my time is spent.
15:27:44 <danharaj> Generics are broken in Java.
15:27:46 <Cale> Now that I actually look at it
15:28:00 <kmc> it's a classic instance of the Thousand Line Library Plus Weird Conventions Equals Basic Haskell Feature Design Pattern
15:28:04 <merijn> Cale: s/the Number class in// :)
15:28:11 <Cale> lol
15:28:16 <Cale> well, yes, that too
15:28:17 <Nimatek> And the sad thing is that Scala inherited those generics from Java, because it wants to be compatible to java types.
15:28:17 <roconnor> danharaj: it's not so bad, but I have no idea if my deconstruction of arithmetic expressions is optimal.
15:28:35 <roconnor> danharaj: I would have perfered the compiler do it for me.
15:28:56 <danharaj> roconnor: that's the dream, ain't it :p
15:30:28 <merijn> The dream is never having to program at all, just describe the problem and let the compiler solve it :p
15:32:45 <Nimatek> merijn: But then the compiler will reply with "I'm sorry Dave, I'm afraid I can't do that."
15:33:14 <kmc> we're already there for some classes of problems
15:33:36 <kmc> there's also the question of how precise and detailed your description of the problem needs to be
15:33:46 <kmc> programming in natural language is an absurd pipe dream
15:33:59 <kmc> natural language is not a good way to convey precise instructions, even to other humans
15:35:15 <kmc> domains where "natural language" is used to convey precise instructions (engineering, law, mathematics) develop their own parallel vocabulary and stereotyped usage constructs
15:35:35 <merijn> I never really got the point of wanting to program in natural language anyway
15:35:45 <merijn> Learning a programming language is easy as hell
15:35:57 <merijn> Learning to think is the hard part
15:36:07 <kmc> i remember reading that statistical analysis of legal codes reveals them to be closer to source code than to other natural language documents
15:36:24 <kmc> yeah
15:36:31 <ezyang> I wish legal codes were executable.
15:36:32 <merijn> They probably got compared to Java code :>
15:36:33 <kmc> i used to think of programming as a detached formal process
15:36:35 <ezyang> Would be very cool.
15:36:42 <kmc> but now i think it's very personal and introspective
15:36:50 <kmc> the way you decide what the machine should do is to think about what you would do if you were the machine
15:36:54 <arw__> merijn: yes, but think of the boss of $person who "just wants to tell the f* computer what he wants"
15:36:54 <merijn> With the amount of boilerplate legal documents have
15:37:00 <kmc> it's a particular kind of metacognition
15:37:17 <kmc> and the difficulty of learning to program in the first place is in learning that form of metacognition
15:37:29 <Nimatek> kmc: Do you remember where you've read that? I'd like to send it to a lawyer I know :p
15:37:50 <merijn> arw__: The problem is not in the "telling the computer"-part, the problem is in the "what he wants"-part
15:38:17 <arw__> merijn: yes, you know that and I do. the boss doesn't, thats the real problem.
15:38:18 <merijn> Most people have no freaking clue what they want, and they don't realize how much of a clue they're not having
15:38:26 <arw__> :)
15:39:54 <kmc> Nimatek, no, I've searched for it unsuccessfully several times :/
15:39:57 <kmc> it may have been on Boing Boing
15:40:27 <merijn> [Citation needed] :>
15:40:38 <kmc> yeah, it's frequently lamented that computers can't automatically resolve ambiguity the way humans do.  it's less commonly acknowledged that when humans resolve ambiguity, we frequently do it wrong
15:40:57 <merijn> I beg to differ
15:40:58 <kmc> and so maybe having a machine that requires you to give pedantically precise instructions, and then follows them exactly, isn't so bad
15:41:07 <hpaste> wli pasted “BestRat.lhs” at http://hpaste.org/48650
15:41:08 <Nimatek> kmc oh well, maybe I'll find it some day in the depth of the internets.
15:41:09 <merijn> Computers are perfectly capable of automatically resolving ambiguity
15:41:26 <kmc> my friend came up with an idea for an (esoteric) programming language
15:41:29 <merijn> The main problem is providing sufficient background knowledge of the world to do so as humans expect
15:41:33 <kmc> which has no delimiters such as parentheses etc
15:41:56 <kmc> to interpret it, you find all possible parse trees
15:41:59 <kmc> throw out the syntax errors
15:42:02 <kmc> throw out the type errors
15:42:14 <merijn> Probabilistic algorithms are the future :>
15:42:15 <kmc> and execute all of what's left concurrently
15:42:20 * benmachine lols
15:42:36 <Nimatek> kmc: epic.
15:42:42 <arw__> merijn: no. imagine your computer as a malevolent djinn. it may know exactly about the world around you and still find a way to misinterpret your wishes.
15:42:45 <Nisstyre> kmc: if computers reacted the same as humans when you give them instructions we would be fucked
15:42:47 * benmachine imagines introducing ambiguous expressions as a parallelisation strategy
15:43:34 <kmc> benmachine, exactly!
15:44:15 <merijn> arw__: So can other humans
15:45:27 <Nisstyre> kmc: what do you think of literate programming?
15:45:41 * wli just hpasted a literate program.
15:45:44 <Nisstyre> Knuth apparently programmed an entire scheduler in literate programming
15:45:58 <wli> Or part of one, anyway.
15:46:02 <Nisstyre> he thinks that the documentation is the code basically
15:46:06 <parcs> ghc is mostly a literate program
15:46:37 <Nisstyre> I see Haskell as pretty close to being literate, because it's so abstract
15:46:41 <kmc> Nisstyre, undecided
15:46:50 <kmc> i mean, i love the style for blog posts and such
15:46:51 <Cale> .lhs
15:47:11 <wli> Any comments on my initial bracketing and inverse parabolic interpolation code?
15:47:15 <benmachine> it doesn't count as literate programming if you just get a haskell program and put > on the beginning of every line
15:47:34 <arw__> merijn: yes, but for that level of fault-tolerance, i guess you would need human-equivalent levels of knowledge. i don't know when that will become realistic.
15:47:47 <wli> My quick test was: let f x = recip (1 + (cos x)^2) in mapM_ print . takeWhile (not . null) $ iterate (catMaybes . map (inverseParabolicInterpolate f)) (initialBracket 10 f (2, 4))
15:47:52 <merijn> arw__: When the semantic web is finished :p
17:19:24 <tgeeky> ok, annoyingly general question time
17:19:43 <tgeeky> say, I have a bunch of files which share the same DSL syntax (https://github.com/example42/puppet-foo/blob/master/manifests/init.pp)
17:19:59 <kmc> puppet!
17:20:04 <tgeeky> yes!
17:20:15 <tgeeky> and I want to write these things in a custom DSL in haskell
17:20:35 <tgeeky> but first, I need to: parse the existing DSL
17:21:26 <tgeeky> then absorb that directly into a haskell dsl?
17:21:29 <tgeeky> then write my own haskell dsl?
17:21:40 <tgeeky> how should I apparoach this? and should I be using happy?
17:22:02 <kmc> use parsec instead
17:22:15 <kmc> the typical structure of such a thing is:
17:22:30 <kmc> a module "Types" which defines algebraic datatypes sufficient to encompass the full syntax of the language
17:23:30 <kmc> a module "Parser" which exports just one thing: a Parsec parser for the "top level" of your grammar
17:23:34 <kmc> probably a whole file in this case
17:23:55 <kmc> a module "Pretty" which exports a pretty-printer for the grammar, using Text.PrettyPrint
17:24:12 <kmc> get all that working
17:24:26 <kmc> you will be able to convert between Puppet files and horribly verbose "deriving (Show)"-based syntax in GHCi
17:24:40 <kmc> then you can build a nice EDSL for manipulating those syntactic values
17:25:25 <mlh> you might just try and translate the existing parser (ruby?) to haskell
17:25:35 <mlh> I think someone has done it for uhm python
17:25:56 <tgeeky> well
17:26:00 <tgeeky> i have the BNF specification for it
17:26:04 <tgeeky> http://docs.puppetlabs.com/guides/language_guide.html
17:26:06 <tgeeky> at the bottom
17:26:22 <kmc> Parsec parsers tend to look a bit different from a typical YACC-like parser
17:26:34 <kmc> i don't recommend translating an existing implementation, if you have something better to work from
17:26:48 <tgeeky> well, I would rather do *all* of this in haskell, from scratch
17:26:50 <mlh> true
17:26:53 <tgeeky> but since I have to have things working
17:28:20 <tgeeky> several components of what puppet does are already available in haskell (at least, in early stages - angel, Configuration, dynamic reconfiguration for xmo)
17:29:43 <tgeeky> kmc: the annoyance I'm looking at now is, this exampl42 library of modules is one of the canonical ways of how to configure puppet
17:29:58 <tgeeky> but the entire premise of the module is to blindly duplicate a template, and modify it piecemeal
17:30:19 <tgeeky> https://github.com/example42/puppet-modules
17:30:26 <tgeeky> all of those are duplications of the "foo" module
17:31:22 <tgeeky> it seems terribly strange to me, to do it that way
17:34:08 <tgeeky> kmc: but thanks for the pointers
17:34:39 <tgeeky> what is happy for, then, by the way? I saw on github someone used happy to parse files to apply colorizing (like hscolor)
17:36:14 <Cale> tgeeky: It's a parser generator, you can definitely use it, but most people prefer a parser combinator library.
17:37:04 <tgeeky> so it's like cutting out the middle man? :o
17:39:24 <Cale> You might be able to get better performance out of Happy-generated parsers than Parsec, but I'm not sure.
17:39:42 <Cale> Parsec is nice because parsers are values and can be manipulated as such.
17:41:27 <kmc> copy-paste is the world's most popular form of code reuse
17:42:26 <kmc> right, Parsec lets you use the full expressive power of Haskell to describe parsers
17:42:32 <kmc> it's a good example of the merits of EDSLs
17:42:39 <kmc> and so only appropriate that you'd use it to define another EDSL :)
17:44:03 <tgeeky> jgm (who wrote pandoc, pandoc2, etc, highlighting-kate...) wrote this : https://github.com/jgm/illuminate
17:44:11 <tgeeky> which he claims is "100 x " faster for that purpose
17:46:10 <tgeeky> interesting to me, but I can hardly read the .x files
17:54:55 <shachaf> The syntax (:: T) for (\x -> x :: T) would be nice.
17:59:02 <dylukes> shachaf: ?
18:00:34 <shachaf> dylukes: !
18:00:39 <shachaf> "sections" for ::
18:01:15 <shachaf> (::String) $ printf "%d" 5
18:05:13 <kmc> shachaf, :O
18:05:15 <kmc> my god
18:05:41 <kmc> map (:: Int) [2,3]
18:05:59 <ezyang> That'd be pretty nifty, actually.
18:06:01 <dylukes> "sections"?
18:06:03 <kmc> i wonder if GHC has a rule map id ⇒ id
18:06:05 <dylukes> o.0
18:06:07 <kmc> this can change sharing dramatically
18:06:14 <dylukes> what.
18:06:17 <dylukes> I'm confused.
18:06:26 <ezyang> The correct thing to do is (:: [Int]) [2, 3]
18:06:34 <kmc> yes indeed
18:06:51 <kmc> dylukes, "sections" = (+2) or (2+)
18:06:59 <dylukes> those just look like partial functions
18:07:00 <kmc> syntax for applying an infix operator to one argument
18:07:03 <dylukes> anyways, i g2g for a bit
18:07:04 <dylukes> seeya
18:07:06 <kmc> that's what a "section" is
18:07:15 <kmc> bah he left before i could nitpick his terminology some more
18:07:57 <kmc> anyway «fix (1:)» takes only a few bytes of heap but «map id $ fix (1:)» will consume your whole heap, unless GHC is cleverer than I think
18:08:30 <geheimdienst> why nitpick, because he said "partial function"?
18:09:28 <kmc> yeah
18:09:53 <geheimdienst> right
18:10:34 <shachaf> If you have newtype A x = A { fromA :: X }, will map fromA turn into map id?
18:11:09 <kmc> depends what you mean by "turn into"
18:11:18 <kmc> fromA is equivalent to id at runtime
18:11:19 <shachaf> kmc: As long as you're nitpicking, "partial functions" are very different from "partial application". :-)
18:11:27 <kmc> shachaf, yes, that was my objection
18:11:33 <shachaf> Oh.
18:11:52 <kmc> i think shachaf's newtype example would be the motivation for GHC to have this optimization for things like "map id"
18:12:02 <kmc> in fact i vaguely remember reading about it, but I'm not sure what the outcome was :/
18:12:29 <kmc> if you want to be sure, use unsafeCoerce :: [A] -> [X]
18:13:11 <shachaf> Mmm, what a lovely optimization.
18:13:13 <drdo> What's the deal with "cabal upgrade" ?
18:13:32 <parcs> it broke things
18:13:38 <drdo> how?
18:17:18 <shachaf> kmc: Shouldn't it be possible to have a safeCoerce of some sort that's aware of newtypes but works on a whole list at once?
18:17:58 <parcs> drdo: i wasn't sure on the specifics, but google found this: http://www.haskell.org/pipermail/haskell-cafe/2010-September/083763.html
18:19:27 <parcs> and i guess upgrading boot libraries, especially when running as root, is a bad idea
18:19:41 <drdo> what are boot libraries
18:19:42 <drdo> ?
18:20:50 <Peaker_> Data.Enumerator.Binary has "splitWhen" -- which seems to split the chunks, which are almost hidden away as implementation details.. Or otherwise, how am I supposed to apply a function on each of the split words?
18:21:05 <parcs> libraries that are installed with ghc
18:22:17 <Peaker_> http://hackage.haskell.org/packages/archive/enumerator/0.4.10/doc/html/src/Data-Enumerator-Binary.html#splitWhen <-- implementation of splitWhen
18:24:24 <drdo> parcs: Why is it a problem to upgrade those libraries?
18:30:03 <parcs> they are all dynamically linked with each other, and there is no stable abi so upgrading them will can potentially cause a cascade of breakage
18:30:46 <parcs> but to be honest i'm talking out of my ass at this point
18:30:50 <parcs> you shouldn't listen to me
18:32:41 <kmc> shachaf, hmm, GHC could generate a type synonym instance for each newtype
18:32:50 <kmc> type family Unwrap t :: *
18:33:10 <Peaker_> hmm.. Data.Enumerator seems to really be missing some higher-order combinators for exposing chunk structure
18:33:12 <kmc> then you could write «unwrapList :: [t] -> [Unwrap t]; unwrapList = unsafeCoerce»
18:33:32 <Peaker_> And that would be a good thing -- if chunks were supposed to be hidden. But "splitWhen" seems to have the only effect of controlling chunk split points
18:51:51 <danharaj_> woaaaah damn. deciphering type errors in GHC while drunk is like a game.
18:52:16 * dilinger just finished LYAH.  that was quite an enjoyable read
19:08:25 <Peaker> OK, turns out I was wrong -- Enumerator.Binary.splitWhen splits to ByteString chunks (each chunk in the list is a ByteString) which ARE exposed by Enumerator.List.map
19:09:00 <Peaker> It seems that all of the Enumerator functions are recurisve when perhaps they could avoid recursion using tricks as in "From Lists to Streams to Nothing at all" and get far better optimized
19:43:36 <ivanm> @tell roconnor I think I may be able to fix it by switching from a DFS-based solution to a BFS one (as I'd still probably be doing permutations and combinations, but only of [(Int,Int,Int)] rather than graphs)
19:43:36 <lambdabot> Consider it noted.
19:43:42 <ivanm> @tell BCoppens I think I may be able to fix it by switching from a DFS-based solution to a BFS one (as I'd still probably be doing permutations and combinations, but only of [(Int,Int,Int)] rather than graphs)
19:43:43 <lambdabot> Consider it noted.
19:44:57 <ezyang> I wonder what backtracking pattern matching in Haskell would look like.
19:47:29 <ezyang> One is tempted to piggy-back something off of the notion of _|_ (since that shows up for partial patterns too), but this doesn't seem quite to work.
19:48:48 <Jafet> Like a field of poppies in the spring?
19:49:28 <Saizan> ezyang: maybe Curry has those?
19:50:29 <ezyang> yeah, I think you'd probably get something like that in a functional logic programming language.
19:50:43 <ezyang> Does this mean logic programming languages are good for prototyping parsers? Hmmm...
19:51:13 <ddarius> ezyang: Logic programming languages have historically been extremely good at making parsers.
19:51:51 <ezyang> context: I'm trying to figure out what OMeta brings to the table in terms of pattern matching http://tinlizzie.org/ometa/
19:51:59 <ezyang> It seems the most interesting thing is extensible grammars?
20:09:53 <ndandy> dankna: You around?
20:10:27 <xil> hi. Have a Ptr question. I am using OpenGL trying to get pixel data from the image buffers. The function to do that requires that you provide it with a Ptr in which to put the image data. My problem is that I don't know how Ptrs work in Haskell and I'm not finding good info online. Could someone give me a boost with this?
20:10:40 <kmc> xil, they're part of the Foreign Function Interface
20:10:55 <kmc> look at API docs for the modules Foreign.*
20:11:10 <ezyang> @hoogle Ptr
20:11:10 <lambdabot> module Foreign.Ptr
20:11:11 <lambdabot> Foreign.Ptr data Ptr a
20:11:11 <lambdabot> Foreign.Ptr ptrToIntPtr :: Ptr a -> IntPtr
20:11:30 <kmc> xil, you can allocate memory and get a pointer to it using 'alloca' or 'malloc'
20:11:43 <kmc> in the later case you have to use 'free' later
20:12:06 <kmc> i'm guessing you only need the buffer for as long as it takes to a) ask OpenGL to fill it with data and b) copy that data to somewhere else
20:12:10 <kmc> so alloca might be more appropriate
20:13:03 <kmc> this kind of code ends up being very close to what you'd write in C, just using Haskell syntax
20:13:07 <xil> kmc: well I should keep the buffer for a while since I'll be reusing it
20:13:16 <kmc> ok, then maybe you want malloc
20:13:17 <ddarius> @src Storable
20:13:17 <lambdabot> Source not found. Where did you learn to type?
20:13:29 <kmc> though really it should be pretty cheap to re-allocate it every time
20:13:42 <kmc> i'm not sure though
20:13:52 <ddarius> @hoogle peek
20:13:52 <lambdabot> Foreign.Storable peek :: Storable a => Ptr a -> IO a
20:13:52 <lambdabot> Foreign.Marshal.Array peekArray :: Storable a => Int -> Ptr a -> IO [a]
20:13:52 <lambdabot> Foreign.Marshal.Array peekArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO [a]
20:14:01 <xil> kmc: okay that's what I needed. I see all these functions for using pointers just couldn't find one to make a pointer, haha. Thanks!
20:14:24 <kmc> xil, if you want GHC's garbage collector to call 'free' for you when your last pointer disappears, see ForeignPtr
20:14:45 <kmc> it can't tell if the C library held onto a copy of that pointer, though
20:15:05 <xil> just want to let everyone in here know how awesome I think this channel is. You have helped me a lot and I really appreciate it. It's frustrating sometimes how crappy the help is in other channels, but you all are awesome
20:15:20 <kmc> thanks :)
20:16:10 <shachaf> Why is it called alloca?
20:16:23 <kmc> it's named after the C library function of the same name
20:16:30 <kmc> i don't know where that name comes from
20:16:57 <shachaf> Why is it named after the C library function of the same name?
20:17:05 <kmc> because it is conceptually similar
20:17:21 <shachaf> Because the pointer is freed automatically?
20:17:25 <kmc> yeah
20:17:31 <kmc> when you leave a particular scope
20:17:40 <kmc> (ish)
20:18:24 <geheimdienst> i believe the basis is the 1999 ricky martin song "livin' la vid alloca"
20:18:50 <geheimdienst> you may commence groaning now ...
20:19:00 <kmc> :D :D :d
20:19:47 <kmc> of course the C function has hell of caveats
20:19:53 <kmc> and is implemented totally different from malloc
20:20:32 <Saizan> i guess it doesn't take a callback either?
20:20:45 <kmc> GHC's alloca is just bracket (malloc foo) free
20:20:51 <kmc> or rather a scary hand-inlined version of same
20:21:27 <kmc> fun fact: C alloca() and C99 variable-length arrays Do Not Get Along
20:21:55 <kmc> also i bet it would be entertaining to foreign call the C alloca() from GHC Haskell code
20:22:15 <kmc> "allocate memory until the next value is forced"
20:22:15 <shachaf> kmc: C alloca() is a function? How does that work?
20:22:24 <ian_mi> alloca is just stack allocation
20:22:36 <ian_mi> it just increases the size of the stack frame
20:22:44 <sanjoyd> kmc: why don't alloca and VLA's get toghether?
20:22:49 <sanjoyd> They smell the same to me. :)
20:22:57 <kmc> right, which is why they interact poorly
20:23:21 <kmc> istr if you have a VLA in an inner scope inside your function, it blows away any previous alloca()
20:23:23 <kmc> something like that
20:23:30 <kmc> or is not guaranteed not to, and in practice will
20:23:55 <sanjoyd> Weird. Both the presence of alloca and VLAs should prompt the compiler to retain the frame pointer.
20:24:16 <sanjoyd> On an more topicy note: can someone point me to an application of a comonad?
20:24:30 <sanjoyd> I want to see how they're used.
20:24:44 <ian_mi> a bad compiler might assume the stack frame hasn't changed
20:25:22 <sanjoyd> When both using VLAs and alloca(), you can't do an SP relative addressing of frame elements.
20:25:32 <sanjoyd> So you have to maintain the FP, and use that.
20:25:32 <Saizan> ?google evaluating cellular automata is comonadic
20:25:33 <lambdabot> http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
20:25:34 <lambdabot> Title: A Neighborhood of Infinity: Evaluating cellular automata is comonadic
20:25:55 <sanjoyd> Other than that, there should be no issues, assuming the constant sized objects are laid out in the beginning of the stack frame.
20:26:06 <kmc> shachaf, GCC usually implements alloca() inline
20:26:23 <kmc> i think some C libraries provide an actual function for it
20:26:23 <sanjoyd> So both alloca(n) and char x[n] becomes [ RSP += n, RSP ].
20:26:34 <kmc> which directly manipulates the stack
20:26:38 <kmc> but i'm not sure
20:26:56 <sanjoyd> It'll have to be a function without a prologue
20:27:01 <sanjoyd> and an epilogue.
20:27:10 <sanjoyd> Thanks Saizan.
20:27:14 <kmc> not necessarily
20:27:17 <kmc> but yeah, alloca doesn't do much
20:27:23 <ian_mi> glibc has #define alloca(size) __builtin_alloca (size)
20:27:27 <kmc> i would expect it to be a few instructions written in assembly
20:27:40 <ian_mi> but in general, it could be a function
20:27:59 <shachaf> I would assume that the compiler would have to be aware of it for e.g. the reason sanjoyd mentioned.
20:28:27 <ian_mi> the inlined code often consists of a single instruction adjusting the stack pointer
20:31:00 <ian_mi> wonder why there's no bitwise or monoid defined in Data.Bits
20:31:24 <parcs> @hoogle first
20:31:24 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
20:31:24 <lambdabot> Data.Monoid newtype First a
20:31:24 <lambdabot> Data.Monoid First :: Maybe a -> First a
20:33:01 <ddarius> ian_mi: What would it's type be and why not the and monoid?
20:34:23 <ian_mi> instance Bits a => Monoid (Or a)
20:35:02 <ian_mi> where mempty = Or 0; mappend a b = Or (unOr a .|. unOr b)
20:35:03 <ddarius> Okay, a newtype could be defined.  They probably just didn't care and Bits likely precedes Monoid.
20:35:27 <ddarius> Arguably, Monoid should have the newtype.
20:35:57 <ddarius> 'not sure how useful it would be.
20:36:03 <ian_mi> oh, I suppose so
20:36:14 <ian_mi> useful enough
20:37:12 <ian_mi> it's a little nicer to use fold than foldr (.|.) 0
20:37:44 <ian_mi> of course that's offset by the newtyping but whatever
20:38:08 <ian_mi> it's the thought that counts
20:38:43 <edwardk1> hence the need to use the ala combinator ;)
20:38:47 <edwardk1> ala Or ...
20:40:15 <ian_mi> I actually searched for ala
20:40:35 <narens> What's the best way to catch an error when applying "read" to a string?
20:41:02 <kmc> narens, don't.  use "reads" instead
20:41:06 <kmc> :t reads
20:41:06 <lambdabot> forall a. (Read a) => String -> [(a, String)]
20:41:16 <kmc> > reads "123abc" :: [(Int,String)]
20:41:17 <lambdabot>   [(123,"abc")]
20:41:33 <narens> kmc: but what does it do when there is no parse?
20:41:36 <kmc> returns []
20:41:45 <narens> kmc: great, thanks
20:41:50 <kmc> it returns a list of parses, each with a "remainder" string
20:42:10 <kmc> this is pretty low level; i wish they just had "read :: (Read a) => String -> Maybe a"
20:42:14 <kmc> but there you go
20:42:26 <shachaf> Except that it always returns a list with either one or zero elements.
20:42:32 <narens> kmc: yea, does readIO help instead? if i just want to catch the error?
20:42:43 <shachaf> No, readIO is evil.
20:42:52 <shachaf> You can make your own wrapper function of the type kmc mentioned.
20:42:55 <kmc> you shouldn't catch the error
20:43:02 <kmc> you should call the function and pattern-match on the result
20:43:04 <narens> alright
20:43:28 <kmc> in Haskell we try not to use exceptions for pure computations
20:43:52 <kmc> we use them for a) IO going wrong due to external factors, b) killing the program on unrecoverable errors
20:43:56 <narens> kmc: good point. tbh, I have avoided exceptions in every haskell program i've written
20:43:59 <kmc> :)
20:44:13 <kmc> if you really need to use exceptions here, readIO is probably the better choice
20:44:39 <kmc> expressions that throw exceptions when evaluated are weird, and catching them is weirder still
20:44:51 <shachaf> Maybe is a fine form of exceptions.
20:44:57 <kmc> readIO returns a normal IO action which can be evaluated without error
20:45:07 <kmc> the *execution* of that IO action can throw the parse error
20:45:14 <xil> hello again, so I was thinking of using a ByteString to output image data to a pipe Handle. And OpenGL needs a pointer to enough space in order give you the data. So my question is, might there be a way to use a ByteString as the pointer to which OpenGL writes the image data? I don't see methods for taking something from a pointed location and putting it into a ByteString, but ByteStrings are pointers themselves...
20:45:16 <kmc> and execution of IO actions is generally the sort of thing you *expect* to cause exceptions
20:45:23 <narens> right...
20:46:05 <kmc> xil, you want to initialize a bytestring using the OpenGL data and then use it as a normal immutable ByteString thereafter?
20:46:38 <kmc> you really really really should not write into an "existing" ByteString
20:47:31 <kmc> anyway, you can do it with some of the ByteString.Internals functions
20:47:40 <kmc> e.g. createAndTrim
20:47:47 <kmc> they are documented only in old versions: http://hackage.haskell.org/packages/archive/bytestring/0.9/doc/html/Data-ByteString-Internal.html#v%3AcreateAndTrim
20:48:41 <ivanm> kmc: why isn't haddock showing them in new versions?
20:48:58 <ivanm> because of issues with ghc (since bytestring is now a boot library) ?
20:49:01 <kmc> because they've told haddock to hide those modules, i expect
20:49:11 <ivanm> oh, yeah, could be
20:49:17 <ivanm> since you're not _meant_ to use them
20:49:27 <ivanm> but they're exposed just in case you're stupid enough to do so p
20:49:28 <xil> kmc: well I was curious if it was okay, so obviously not. I see a function unsafePackCStringFinalizer that takes a Ptr Word8 and a length and gives you a ByteString, which looks like what I want, but it also takes a "finalizer" function. What is that?
20:49:51 <kmc> xil, action to perform once all ForeignPtrs to that memory disappear
20:50:05 <kmc> xil, it *is* okay, as a way to *initialize* a ByteString
20:50:08 <kmc> if you're careful etc.
20:50:31 <kmc> it's not okay to write into an existing ByteString, because they're supposed to behave like immutable values
20:50:37 <kmc> they get shared all over the place, etc.
20:50:39 <xil> kmc: what could go wrong? And is "free" a reasonable finalizer or am I missing what the finalizer does?
20:50:51 <kmc> i think you want to use Internals instead
20:50:54 <kmc> if you want to use this at al
20:50:54 <kmc> l
20:51:03 <kmc> ivanm, well, the 0.9 docs describe it as a "semi-public" API
20:52:36 <ivanm> semi-public == use at your own risk, no guarantees about stability, etc. ?
20:52:46 <kmc> i guess these days FFI library authors are supposed to use ByteString.Unsafe instead?
20:52:53 <kmc> shrug
20:52:59 <kmc> xil, the finalizer is executed once all ByteStrings referencing this buffer disappear
20:53:15 <kmc> (at some arbitrary time after that happens)
20:53:26 <kmc> what (if anything) the finalizer does would depend on how you got this buffer in the first place
20:53:46 <kmc> what's your goal in having OpenGL write into a ByteString?
20:53:52 <xil> kmc: aha, okay I see. Thanks. So now about createAndTrim. It takes a function as input...but the doc isn't clear to me what that function does?
20:53:55 <kmc> do you then want to do ByteString IO with it, or something like that?
20:54:11 <xil> kmc: oh...well I'm writing to a pipe into ffmpeg to create a video of my simulation
20:54:20 <kmc> *nod*
20:54:24 <kmc> makes sense then
20:54:34 <xil> *phew*
20:54:51 <xil> haha. I've been in doubt whether I'm doing anything correctly about this
20:54:59 <xil> I'm still figureing a LOT of Haskell out along the way
20:55:26 <kmc> i think there are also functions to do IO directly from a Ptr
20:55:29 <kmc> which you could get with malloc
20:55:54 <kmc> or, you can just write the "ask OpenGL for pixels and then write them to this pipe" function in C
20:55:56 <kmc> and call it from Haskell
20:56:59 <xil> kmc: well I was going to use malloc for creating the pointer so I could get the data from OpenGL. Thing is, I don't anything about communicating between a C and Haskell program, let alone that I haven't compiled C in a long time
20:57:24 <xil> I don't know anything*
20:57:30 <kmc> here's a great place to start: http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html
20:57:49 <kmc> if you're building your Haskell project with Cabal, it's super easy to include some C files as well
20:58:24 <kmc> the function passed to createAndTrim gets a pointer to the area allocated for the ByteString, and is supposed to return an IO action to fill that area
20:58:46 <kmc> the size passed to createAndTrim is an upper bound
20:58:48 <kmc> the IO action produces the actual number of bytes written (that's the "trim" part)
20:59:27 <ddarius> @hoogle getBuf
20:59:28 <lambdabot> System.IO hGetBuf :: Handle -> Ptr a -> Int -> IO Int
20:59:28 <lambdabot> System.IO hGetBuffering :: Handle -> IO BufferMode
20:59:28 <lambdabot> System.IO hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
20:59:46 <ddarius> @hoogle putBuf
20:59:46 <lambdabot> System.IO hPutBuf :: Handle -> Ptr a -> Int -> IO ()
20:59:46 <lambdabot> System.IO hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
21:00:04 <kmc> yeah, i think ddarius has the right idea
21:00:17 <kmc> going through scary backdoor APIs to ByteString just to do a little IO is not necessary
21:00:45 <xil> kmc: I'll definitely have to read through that FFI document. It sounds very interesting. I'd actually love to know more about the usefullness about incorporating some C code into Haskell programs.
21:00:51 <kmc> if you wanted to pass this image data to some other Haskell library, or keep it in memory for a while, that's another story
21:01:21 <xil> kmc: that indeed looks much much easier. I originally chose ByteStrings because I saw an example of it somewhere and I didn't know I'd be using pointers until I already set in my mind that I'm using ByteStrings, haha
21:01:59 <kmc> calling C from Haskell is useful in a lot of ways
21:02:01 <xil> hPutBuf looks like what I need. I don't need to keep anything around or anything like that. Just pull it and send it
21:02:12 <xil> ddarius: thanks a lot!
21:03:11 <kmc> in a sense Haskell is useless without FFI, because you can't implement IO without FFI or some more ad-hoc thing like it
21:04:06 <xil> I see. So does a lot of impure Haskell use FFI?
21:04:14 <kmc> not sure what you mean by "impure Haskell"
21:04:33 * sanjoyd has heard the term lots of times too.
21:04:45 <kmc> besides that, it's useful if you need some very fast numeric code or something like that
21:04:49 <kmc> write it in C, call that from Haskell
21:04:55 <xil> oh, I thought I was using "the lingo", haha. I was thinking about functional purity
21:05:13 <kmc> every program in the world is 90% fluff (IO format munging, options parsing, error handling, etc) and 10% 'meat'
21:05:38 <sanjoyd> I thought all of Haskell was functionally pure. :(
21:05:45 <kmc> for that 10% you might need better performance than GHC can give, but it's not nice to write the whole program in C
21:06:01 <kmc> sanjoyd, that's the view I take.  Haskell functions are pure functions, some of which return descriptions of IO which *could* be performed
21:06:21 <kmc> Haskell programs are pure functional programs which compute imperative programs
21:06:26 <sanjoyd> Right.
21:06:33 <xil> interesting...
21:06:35 <sanjoyd> Which is why main :: IO ()
21:06:46 <sanjoyd> And not, (main :: Int) or something similar.
21:06:57 <kmc> anyway i try not to talk about "impure functions" and such, because I think it obscures this point
21:07:05 <parcs> main is actually IO a. as to why, i haven't the faintest
21:07:08 <kmc> but i agree that the distinction is still useful
21:07:25 <kmc> if you want to formalize it you can talk about composition in the category (->) vs. composition in the category (Kleisli IO)
21:07:25 <Jafet> main :: IO Int
21:07:37 <sanjoyd> kmc: Frankly, it does confuse people.
21:07:40 <xil> kmc: that goes way beyond what I understand
21:07:41 <kmc> yeah.  it should be a warning if not an error to have a type for main other than IO ()
21:07:46 <djahandarie> parcs, no good reason.
21:07:47 <Jafet> I suspect the returned value is ignored
21:07:51 <kmc> yeah
21:08:00 <kmc> i've shot myself in the foot by writing a main which had type IO (IO ())
21:08:00 <djahandarie> I should be a warning to have anything but IO Void
21:08:05 <kmc> "why is it doing nothing?!?"
21:08:12 <djahandarie> It*
21:08:26 <xil> kmc: one day I hope to understand the various workings of Haskell well enough, but not today
21:08:26 <kmc> djahandarie, that would force you to end with exitSuccess or something
21:08:45 <Jafet> return undefined
21:08:51 <kmc> sucks
21:09:00 <kmc> xil, ok.  sometime i can explain what Kleisli and all that mean, but I think it's actually not that interesting
21:09:31 <kmc> it is just a way of talking about "composing" functions like (a -> IO b) with (b -> IO c), the same way we usually talk about composing (a -> b) with (b -> c)
21:09:35 <xil> kmc: but I think I'm seeing your point, and as it turns out, FFI might seriously benefit me with some of what I'm doing. I've had to make temporary concessions to write comutationally sucky algorithms for computing some things because I am not good enough at Haskell, but I could write it much more efficiently in C
21:09:40 <djahandarie> IO Void is the 'right' way to do things though.
21:09:46 <kmc> xil, *nod*
21:09:49 <sanjoyd> kmc: Kleisli triple is a Monad, right?
21:09:53 <kmc> there's really a whole range of possibilities
21:10:14 <kmc> you can write your code in C, or in Haskell with mutable state, or in Haskell using specialized libraries like 'vector'
21:10:26 <kmc> sanjoyd, I think that's right
21:10:43 <sanjoyd> The whole concept of impurity tends to further confuse cargo-cult math Haskell programmers; who get under the delusion that "Monads" allow haskell code to be "impure"; when all you're doing is making use of some cleverly written type classes and higher-order functions.
21:10:54 <kmc> exactly
21:11:00 <kmc> most monads have nothing to do with IO or "impurity"
21:11:10 <kmc> the fact that IO has a monadic interface is almost irrelevant to how it works
21:11:18 <djahandarie> Yep
21:11:26 <kmc> sanjoyd, the type Control.Arrow.Kleisli represents the "Kleisli category of a monad"
21:11:26 <djahandarie> The monadic interface is actually entirely artifically constructed
21:11:40 <sanjoyd> kmc: I have only started reading CT, so I don't know much there.
21:11:50 <sanjoyd> kmc: hopefully will begin to understand better soon.
21:12:05 <kmc> class Category (~>) where { id :: a ~> a; (.) :: (b ~> c) -> (a ~> b) -> (a ~> c) }
21:12:08 <cmccann> note that "Kleisli arrow" and "Kleisli triple" are distinct ideas
21:12:23 <kmc> instance Category (->) where{ id = Prelude.id; (.) = (Prelude..) }
21:12:32 <sanjoyd> Basically, id(a) and composition(a). Hmm ...
21:12:36 <kmc> newtype Kleisli m a b = Kleisli (a -> m b)
21:12:55 <xil> kmc: thank you so much for all the help. It's really helped me understand things better, I really appreciate it. But now my brain needs to rest and take it all in, haha. But again, thank you.
21:13:01 <kmc> instance (Monad m) => Category (Kleisli m) where { id = Kleisli return; Kleisli f . Kleisli g = Kleisli (f <=< g) }
21:13:04 <sanjoyd> Is "Basic CT for computer scientists" a decent book?
21:13:15 <kmc> xil, no problem :)
21:13:24 <kmc> have fun digesting :)
21:14:03 <kmc> sanjoyd, so that's the idea.  a category is something that "looks like" function composition, with identity "functions" and a "composition" operator
21:14:08 * cmccann still thinks "triple" is a remarkably terrible bit of terminology
21:14:23 <kmc> the laws are: (id . f) = f,  (f . id) = f,  ((a . b) . c) = (a . (b . c))
21:14:31 <kmc> and this is obeyed for (.) and id from Prelude
21:14:40 <kmc> but it's also obeyed if id = return and (.) = (<=<)
21:14:44 <kmc> for any monad
21:25:47 <edwardk> @type (==) `on` (==0)
21:25:48 <lambdabot> forall a. (Num a) => a -> a -> Bool
21:30:30 <parcs> :t (`on` on)
21:30:31 <lambdabot> forall c b c1 a. (((a -> b) -> a -> a -> c1) -> ((a -> b) -> a -> a -> c1) -> c) -> (b -> b -> c1) -> (b -> b -> c1) -> c
21:32:13 <hpaste> wli annotated “BestRat.lhs” with “BestRat.lhs (annotation)” at http://hpaste.org/48650#a48652
21:32:28 <edwardk> @type (`on` (`on` (`on` (`on` on))))
21:32:28 <Jafet> :t (`on` (`on` on))
21:32:29 <lambdabot> forall c c1 c2 c3 b c4 a. (((((b -> b -> c4) -> (b -> b -> c4) -> c3) -> ((b -> b -> c4) -> (b -> b -> c4) -> c3) -> c2) -> (((b -> b -> c4) -> (b -> b -> c4) -> c3) -> ((b -> b -> c4) -> (b -> b ->
21:32:29 <lambdabot> c4) -> c3) -> c2) -> c1) -> ((((b -> b -> c4) -> (b -> b -> c4) -> c3) -> ((b -> b -> c4) -> (b -> b -> c4) -> c3) -> c2) -> (((b -> b -> c4) -> (b -> b -> c4) -> c3) -> ((b -> b -> c4) -> (b -> b ->
21:32:29 <lambdabot>  c4) -> c3) -> c2) -> c1) -> c) -> (((((a -> b) -> a -> a -> c4) -> ((a -> b) -> a -> a -> c4) -> c3) -> (((a -> b) -> a -> a -> c4) -> ((a -> b) -> a -> a -> c4) -> c3) -> c2) -> ((((a -> b) -> a ->
21:32:29 <lambdabot>  a -> c4) -> ((a -> b) -> a -> a -> c4) -> c3) -> (((a -> b) -> a -> a -> c4) -> ((a -> b) -> a -> a -> c4) -> c3) -> c2) -> c1) -> (((((a -> b) -> a -> a -> c4) -> ((a -> b) -> a -> a -> c4) -> c3)
21:32:29 <lambdabot> -> (((a -> b) -> a -> a -> c4) -> ((a -> b) -> a -> a -> c4) -> c3) -> c2) -> ((((a -> b) -> a -> a -> c4) -> ((a -> b) -> a -> a -> c4) -> c3) -> (((a -> b) -> a -> a -> c4) -> ((a -> b) -> a -> a -
21:32:31 <lambdabot> > c4) -> c3) -> c2) -> c1) -> c
21:32:33 <lambdabot> forall c c1 b c2 a. (((b -> b -> c2) -> (b -> b -> c2) -> c1) -> ((b -> b -> c2) -> (b -> b -> c2) -> c1) -> c) -> (((a -> b) -> a -> a -> c2) -> ((a -> b) -> a -> a -> c2) -> c1) -> (((a -> b) -> a
21:32:35 <lambdabot> -> a -> c2) -> ((a -> b) -> a -> a -> c2) -> c1) -> c
21:32:57 <djahandarie> That will crash lambdabot so you should probably stop :p
21:33:04 <sanjoyd> @src on
21:33:04 <lambdabot> (*) `on` f = \x y -> f x * f y
21:33:12 <wli> Oh great, someone's spamming with lambdabot right when I hpaste.
21:33:16 <edwardk> :t (`on` (`on` (`on` (`on` (`on` on)))))
21:33:17 <lambdabot> forall c c1 c2 c3 c4 b c5 a. (((((((a -> b) -> a -> a -> c5) -> ((a -> b) -> a -> a -> c5) -> c4) -> (((a -> b) -> a -> a -> c5) -> ((a -> b) -> a -> a -> c5) -> c4) -> c3) -> ((((a -> b) -> a -> a -
21:33:17 <lambdabot> > c5) -> ((a -> b) -> a -> a -> c5) -> c4) -> (((a -> b) -> a -> a -> c5) -> ((a -> b) -> a -> a -> c5) -> c4) -> c3) -> c2) -> (((((a -> b) -> a -> a -> c5) -> ((a -> b) -> a -> a -> c5) -> c4) -> (
21:33:17 <lambdabot> ((a -> b) -> a -> a -> c5) -> ((a -> b) -> a -> a -> c5) -> c4) -> c3) -> ((((a -> b) -> a -> a -> c5) -> ((a -> b) -> a -> a -> c5) -> c4) -> (((a -> b) -> a -> a -> c5) -> ((a -> b) -> a -> a ->
21:33:17 <lambdabot> c5) -> c4) -> c3) -> c2) -> c1) -> ((((((a -> b) -> a -> a -> c5) -> ((a -> b) -> a -> a -> c5) -> c4) -> (((a -> b) -> a -> a -> c5) -> ((a -> b) -> a -> a -> c5) -> c4) -> c3) -> ((((a -> b) -> a -
21:33:17 <lambdabot> > a -> c5) -> ((a -> b) -> a -> a -> c5) -> c4) -> (((a -> b) -> a -> a -> c5) -> ((a -> b) -> a -> a -> c5) -> c4) -> c3) -> c2) -> (((((a -> b) -> a -> a -> c5) -> ((a -> b) -> a -> a -> c5) -> c4)
21:33:19 <lambdabot> [6 @more lines]
21:33:23 <edwardk> fair nuff
21:33:58 * wli has vaguely gotten somewhere with http://hpaste.org/48650#a48652
21:34:33 <parcs> :t om
21:34:34 <lambdabot> forall nom. nom -> nom
21:34:36 <djahandarie> Urg latex
21:34:36 <edwardk> kinda blechy to ready in that form ;)
21:36:22 <wli> Well, it's implementing most of the things underlying the multidimensional parameter search for feasible points sitting within the loop over uniform error bound to determine whether a given error bound is feasible.
21:39:22 <wli> Well, it's implementing most of the things underlying the multidimensional parameter search for feasible points sitting within the loop over uniform error bound to determine whether a given error bound is feasible.
21:40:03 <Eduard_Munteanu> Yep, we've seen that (and no replies).
21:40:06 <Insolsence> Hey all
21:40:12 <Insolsence> I have an issue dividing two ints
21:40:16 <Eduard_Munteanu> Insolsence: hi
21:40:22 <Insolsence> I'm trying to do this
21:40:23 <Insolsence> fromIntegral num / fromIntegral denom
21:40:27 * wli got knocked off by a power flicker taking out the wifi AP.
21:40:28 <Insolsence> in a list comprehension
21:40:44 <Insolsence> but it gives me an error about Fractional Int
21:40:48 <Insolsence> I'm perplexed
21:40:51 <Insolsence> it works fine on ghci
21:41:06 <wli> Eduard_Munteanu: I'll take formatting/beautification tips also.
21:41:32 <wli> Eduard_Munteanu: And/or technical writing tips also.
21:42:40 <Insolsence> Eduard_Munteanu: umm?
21:42:48 <Eduard_Munteanu> You could drop the tabs, now that you mentioned it.
21:43:14 <Eduard_Munteanu> And maybe use unicode chars for e.g. 'epsilon'?
21:43:27 <Jafet> :t (/)
21:43:27 <lambdabot> forall a. (Fractional a) => a -> a -> a
21:43:29 <Jafet> :t div
21:43:30 <lambdabot> forall a. (Integral a) => a -> a -> a
21:44:20 <Insolsence> Yeah
21:44:25 <Insolsence> That's why I used fromIntegral
21:44:57 <wli> Eduard_Munteanu: I was hoping for something vaguely more substantial, like where to put in headings, fancier boxes to use, math formulas I should mention, etc.
21:44:59 <Insolsence> well I need the value in decimals
21:45:03 <Jafet> Then you are passing the result to something that expects Int.
21:45:09 <Eduard_Munteanu> :)
21:45:19 <wli> Eduard_Munteanu: Possibly also order of presentation.
21:45:53 <Insolsence> Nop.. I'm passing it to (/)
21:45:55 <Insolsence> not div
21:46:14 <Jafet> Then you are passing the result of that to something that expects Int.
21:47:20 <Insolsence> I don't get you Jafet
21:47:23 <Insolsence> what should I do then?
21:47:28 <Insolsence> I'm a newb to Haskell
21:47:40 <Insolsence> hmm
21:47:40 <Insolsence> oh
21:47:59 <Insolsence> oh yeah
21:48:01 <Insolsence> problem solved
21:48:02 <Insolsence> thankyou
21:49:12 * Jafet hugs the Clairvoy-o-5000
21:50:42 <sanjoyd> What is that?
21:55:28 <tgeeky> I'm not sure, but I know it can be operated with a thinglonger!
22:09:25 * hackagebot hlint 1.8.12 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.12 (NeilMitchell)
22:21:53 <wli> Now that it's quieted down a bit and I've reformatted a bit...
22:24:15 <hpaste> wli pasted “BestRat.lhs” at http://hpaste.org/48654
22:25:06 <tommd> Do packages that only define an executable (and no library) not get the data files installed on cabal install?
22:25:44 <hpaste> wli annotated “BestRat.lhs” with “BestRat.bib” at http://hpaste.org/48654#a48655
22:30:03 <ivanm> tommd: they _should_ ...
22:33:06 <habitat> what editor do you guys use?
22:33:15 <smop> sublimetext
22:33:16 <habitat> (i.e. one good for haskell)
22:33:18 <smop> 2
22:33:33 <smop> i wouldn't know if it is good for haskell though, worked fine for me so far
22:33:42 <smop> i would say most are using emacs/vim though
22:33:49 * sully uses emacs
22:34:05 <sully> emacs's autoindentation for haskell is crucial for me
22:34:46 <shachaf> habitat: EDIT.COM
22:34:59 <shachaf> It really doesn't matter. If an editor works for you then it works for Haskell.
22:35:10 <shachaf> (...Unless it's emacs.)
22:35:21 <ivanm> ed, the standard editor!
22:35:36 <shachaf> No, according to sully, even emacs works. I had no idea.
22:35:52 <habitat> ed.. oh lord
22:40:47 <BenceF> http://man.cat-v.org/plan_9/1/emacs
22:41:57 * Saizan wonders why all the hate on emacs
22:43:05 <koninkje> ugh, why does unification have to be so complicated to introduce
22:43:17 <BenceF> same reason as for all the hate on anything
22:43:25 <BenceF> people love to hate things
22:43:41 <koninkje> I blame set theory
22:44:16 <ivanm> koninkje: what does set theory have to do with people loving to hate things? :/
22:44:16 <ivanm> :p
22:44:48 <koninkje> ivanm: Well I love to hate set theory, but no I meant why introducing unification is so ugly
22:44:57 <ivanm> yeah, I know ;-)
22:45:06 <Saizan> i think there's a categorical presentation of unification based on free monads somewhere
22:45:25 <koninkje> Yes, it's much nicer when presented categorically
22:45:43 <Saizan> do you have a reference for it? i lost mine
22:45:46 <koninkje> I'm not familiar with the free monad presentation, though it makse sense
22:46:15 <koninkje> Saizan: You may find this one interesting though: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.48.3615
22:47:09 <Saizan> thanks
22:47:12 <koninkje> :)
22:52:06 <smop> just saw that the other day too
22:53:42 * ddarius used edit.com for several years, albeit not for Haskell.
22:53:50 * ddarius wouldn't really mind using it for Haskell.
22:55:03 * ddarius wishes there was a "What Is Unification?" paper that wasn't geared to being a gentle introduction to category theory.
22:55:15 <ddarius> That said, then it would just be the single word "Limits."
22:55:33 <ddarius> koninkje: Why is unification so complicated to introduce?
22:56:04 <koninkje> ddarius: because you have to introduce a bunch of other junk first: ranked alphabets, terms, substitutions,...
22:56:33 <koninkje> most of which comes trivially if you're already familiar with CT
22:57:09 <ddarius> So work categorically (?)
22:57:34 <koninkje> I don't think I've equipped the audience with enough CT to get it
22:57:43 <koninkje> though there's plenty of categorical stuff in there
22:57:49 <koninkje> (the talk I mean)
22:57:53 <ddarius> So instead you'll equip them with some special-purpose stuff instead?
22:58:51 <koninkje> Also, the intro has to be concrete enough to make sense of the talk that goes through all the common optimization tricks
22:59:10 <koninkje> (and a few uncommon ones)
22:59:22 <ddarius> Can you just present it from a code-oriented perspective then?  The unification algorithm is pretty straightforward.
22:59:46 <koninkje> sure
23:00:26 <koninkje> but there was a requestto cover some of the theory behind it (basic places it shows up, decidability theorems, etc)
23:01:07 <koninkje> The non-intro talk is all code oriented
23:01:52 <koninkje> FWIW I've already touched on unification a bit and gave the first day or two of CT
23:02:21 <koninkje> ...but I didn't get to natural transformations, hence not wanting to rely on that
23:05:37 <ddarius> You're over in Portland?
23:05:45 <koninkje> Nah :)
23:05:51 <koninkje> my IRC is though
23:05:59 <ddarius> So up in Canada?
23:06:06 <koninkje> I'm currently up in Hamilton, Ontario
23:06:21 <koninkje> (more generally around Bloomington, Indiana)
23:06:44 <ddarius> Indiana, oy.
23:06:51 <koninkje> yeah...
23:07:06 * koninkje misses Portland
23:12:38 <sully> koninkje: IU?
23:12:44 <koninkje> yep
23:12:58 <sully> there are a couple of IU grad students on my team at work
23:18:51 <koninkje> g'night all
23:20:36 <edwardk> night
23:23:06 <earthy> morning. :)
23:23:18 <edwardk> =)
23:24:59 * wli will have to do linear programming or something to bootstrap the search and then some sort of derivative-free (due to non-analyticity of constraints) multidimensional optimization search to wrap up things.
23:26:49 <fragamus> howdy
23:29:50 <fragamus> I have a quick question: I need somebody to write a line of code for me. I have need of a type signature that goes like this: schlock :: Int -> blah     where blah is a monad stack consisting of ListT   StateT Float   IO     and the return value is (Float,Float)
23:29:55 <fragamus> any takers
23:32:25 <fragamus> plugh
23:33:51 <edwardk> schlock :: Int -> ListT (StateT Float IO) (Float, Float) ?
23:34:11 <kmc> @unmtl ListT (StateT Float IO) (Float, Float)
23:34:11 <lambdabot> Float -> IO ([(Float, Float)], Float)
23:34:12 <fragamus> lemme try, thanks edwardk
23:34:17 <edwardk> note that that technically isn't a monad, because ListT applied to IO is hazardous
23:35:00 <edwardk> so be warned, and don't try to abuse it to return infinite lists or you'll be sad
23:35:03 <fragamus> yes but I promise the IO is only trivial logging crap
23:35:13 <fragamus> i am already sad
23:35:25 <fragamus> I am in a maze of twisty passages all alike
23:36:50 <fragamus> Yep that was it thanks!
23:37:28 <fragamus> what happens if i abuse it to return infinite lists
23:37:52 <fragamus> I get a whole shitload of IO monads I guess
23:37:55 <edwardk> well, then you cease to technically be a monad, because ListT IO will fail the associativity laws
23:37:59 <cheater_> fragamus, do you still have the lamp?
23:38:08 <edwardk> you get one IO monad, ListT puts the list inside
23:38:22 <fragamus> I left in in the cavern
23:38:28 <edwardk> so you'll never finish computing the result of that step to get to the next one
23:38:31 <cheater_> oops!
23:38:43 <edwardk> @unmtl ListT IO a
23:38:43 <lambdabot> IO [a]
23:39:34 <edwardk> This is why we have various "ListT done right" monads
23:39:46 <fragamus> Yes I am using that
23:39:54 <fragamus> I have ListT done right
23:40:00 <edwardk> ah
23:40:04 <fragamus> am I still sad?
23:40:07 <edwardk> then you're safe =)
23:40:22 <fragamus> safe and no longer lost =)
23:40:25 <edwardk> only slightly sad, after all you're stuck building on IO
23:40:49 <fragamus> yes but it is not really necessary and I will later remove it
23:44:25 <fragamus> oh im happy now
23:44:40 <fragamus> im stacking monad transformers like a pro
23:45:00 <edwardk> =)
23:48:52 <fragamus> omg thank you
23:49:22 <fragamus> thank god
23:49:30 <fragamus> thank edwardk
23:49:44 <fragamus> thank spongebob
