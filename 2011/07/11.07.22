00:00:24 <frerich> shachaf: Don't laugh, I considered something like that. Or maybe some simple lint-style tool which parses C++ (using the clang package for Haskell).
00:00:47 <kmc> frerich, I would just go ahead and write something that makes your life at work easier
00:00:52 <kmc> without asking anyone's permission
00:01:07 <kmc> and use it
00:01:14 <kmc> and maybe show it to others gradually
00:01:39 <shachaf> kmc: You'd do that? Just to introduce Haskell into frerich's workplace?
00:01:48 <kmc> ;)
00:01:57 <frerich> That's really kind.
00:01:59 <chrisdone> isn't parsing C++ Hard?
00:02:09 <kmc> chrisdone, very.  however clang makes a decent attempt
00:02:19 <chrisdone> bravo clang
00:02:44 <kmc> afaik clang and g++ are the only open-source projects that do
00:02:58 <shachaf> @karma g
00:02:59 <lambdabot> g has a karma of 392
00:03:07 <frerich> Qt has a full-featured C++ parser for it's "moc" preprocessor.
00:03:07 <shachaf> Nice going, g.
00:03:09 <luite> hehe
00:03:11 <flux> there is one third
00:03:14 <kmc> heh
00:03:15 <flux> elk something
00:03:16 <luite> @karma C
00:03:17 <lambdabot> C has a karma of 4
00:03:20 <luite> hmm
00:03:22 <flux> elkhound
00:03:25 <shachaf> @karma C/C
00:03:25 <lambdabot> C/C has a karma of 628
00:03:33 <Eelis> frerich: full-featured? i doubt it.
00:03:40 <kmc> frerich, to be blunt though, if you're still at the tictactoe game stage, do you want to be writing important work tools in Haskell?
00:03:52 <flux> actually it was Elsa
00:04:24 <flux> Elsa is able to parse Mozilla, Qt and ACE (according to its web page), so I guess it's not a toy
00:04:24 <frerich> kmc: I don't want to write stuff other people depend on, of course. The problem is trying to convince my boss to let me write Haskell tools for myself on work time (read: paid by him)
00:04:46 <frerich> Eelis: It seems good enough to parse gigabytes of C++ code around the world.
00:04:55 <kmc> and you work the kind of place where taking a day out to write a useful work-related tool will be noticed and frowned upon?
00:05:12 <Eelis> frerich: moc's parsing needs are very modest. it does not need a full AST.
00:05:24 <Eelis> frerich: so it can get away with a lot of shortcuts
00:05:35 <frerich> Eelis: I think it builds one in Qt 4.4 and newer (but not before that)
00:05:49 <Eelis> parsing C++ into a full AST essentially requires a full compiler frontend
00:06:20 <flux> eelis, wouldn't supporting ambiguity help as an alternative?
00:06:34 <Eelis> flux: depends on what you mean by "supporting ambiguity"
00:06:39 <frerich> kmc: No, it's actually quit edeveloper friendly. Never more than two persons per office, no telephones in the developer offices, offices which have doors which can be closed. Still - it's a hen and egg problem. Nobody bothers playing with some 'uncommon' language since nobody else knows it. :-}
00:06:41 <flux> well, two parses for same piece of code
00:06:51 <kmc> frerich, but you can bother, unilaterally
00:06:51 <flux> (or as a generalization, infinite parses ;-))
00:06:54 <Eelis> flux: well, yes, but then it's not really parsing into an AST anymore :)
00:07:10 <kmc> i think i'd go crazy working two people per office
00:07:15 <kmc> i'd rather have an open plan
00:07:29 <flux> eelis, well call it hyper AST then :)
00:08:25 <frerich> Trolltech (now Nokia) used to have a 'creative friday'. Maybe I should do that here, too. ;-)
00:08:43 <Eelis> to give just one example, if in C++ you have the statement   X*Y;  then whether this is a declaration of a variable Y or a multiplication of variables X and Y depends on what X refers to. which means you may have to do name lookup, template instantiation, even class layout computation (because sizeof(T) is a valid template argument)
00:10:08 <kmc> frerich, oh, like Google 20% time? sounds like a scam
00:10:23 <kmc> it's meaningless to tell software devs to spend n% hours on something
00:10:27 <kmc> what matters are the project deadlines
00:10:56 <frerich> kmc: Sure, guess why I'm having a hard time freeing up a day as you suggest. ;-)
00:11:20 <frerich> kmc: Anyway, I don't know about Google but with TT you *could* (if you wanted) spend friday on some project of your own interest *if* that project could possibly become a product.
00:11:29 <frerich> So it should be something useful.
00:15:09 <kmc> yeah, that's like google 20% time
00:15:26 <kmc> fixing bugs in projects you don't directly own in ways that will improve your life
00:15:44 <kmc> screw 20%, i think developers should be encouraged to do as much of that as possible
00:15:50 <Itkovian> anybody any idea if there's still life in the Xcode haskell plugin?
00:34:01 <Lymee> Is it considered bad to use unsafe IO to avoid loading files that you don't need?
00:39:13 <kmc> avoid loading files that you don't need?
00:39:19 <kmc> confused
01:17:50 * hackagebot authenticate 0.9.2 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.9.2 (MichaelSnoyman)
01:17:52 * hackagebot hamlet 0.9.0 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.9.0 (MichaelSnoyman)
01:17:54 * hackagebot wai-app-static 0.3.0 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-0.3.0 (MichaelSnoyman)
01:18:50 * hackagebot warp-static 0.2.0 - Static file server based on Warp and wai-app-static  http://hackage.haskell.org/package/warp-static-0.2.0 (MichaelSnoyman)
01:25:26 <sebz> okay, thanks kmc!
01:25:28 <sebz> oops
01:25:42 <sebz> wrong window
01:52:20 <gavnio> hey is darcs performance enuf for big project?
01:52:34 <gavnio> in recent version equal to git or mercurial?
01:52:39 <gavnio> hows haskell web stuff?
01:52:45 <gavnio> happstack looks sik
01:52:48 <gavnio> haskell rocks
01:53:08 <mreh> happstack does look good
01:53:11 <develhevel> howto replace a string in haskell? e.g. i want to replace "ad" with "d" so then i have a string like: "ad here" it should be: "d here"
01:53:13 <mreh> i'm going to play with it soon
01:54:34 <gavnio> string library no doubtage
01:54:38 <ptd> if the "ad" if guaranteed to be at the start of the string the answer is simply
01:54:53 <mreh> > drop 1 "ad here"
01:54:54 <lambdabot>   "d here"
01:55:46 <develhevel> no it could be everywhere
01:55:58 <mreh> haskell's type system has provided for me so well i've never actually had to do string replcements, but I know there is a regex library
01:56:00 <develhevel> could be also: "iduehad" -> "iduehd"
01:56:19 <frerich> develhevel: The Data.List package has a 'replace' function which maybe does what you want.
01:56:30 <frerich> > replace "ad" "d" "ad here"
01:56:31 <lambdabot>   Not in scope: `replace'
01:56:32 <ptd> :t replace
01:56:33 <lambdabot> Not in scope: `replace'
01:56:40 <ptd> :t Data.List.replace
01:56:41 <frerich> @hoogle replace
01:56:41 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
01:56:41 <lambdabot> System.FilePath.Posix replaceBaseName :: FilePath -> String -> FilePath
01:56:41 <lambdabot> System.FilePath.Windows replaceBaseName :: FilePath -> String -> FilePath
01:56:41 <lambdabot> Not in scope: `Data.List.replace'
01:56:42 <mreh> :t Data.List.replace
01:56:43 <lambdabot> Not in scope: `Data.List.replace'
01:56:46 <frerich> Err
01:56:53 <frerich> Data.List.Utils
01:57:00 <frerich> :t Data.List.Utils.replace
01:57:00 <lambdabot> Couldn't find qualified module.
01:57:22 <frerich> Hm, I meant http://hackage.haskell.org/packages/archive/MissingH/0.18.6/doc/html/Data-List-Utils.html
01:57:45 <frerich> Apparently it's not available by default, I didn't realize this.
01:58:12 <ptd> :t Data.List.Utils.replace
01:58:13 <lambdabot> Couldn't find qualified module.
01:58:15 <develhevel> frerich: so should i use Network.CGI.protocol?
01:58:29 <frerich> develhevel: No, the 'Data.List.Utils'
01:58:47 <frerich> @hoogle [a] -> [a] -> [a] -> [a]
01:58:47 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
01:58:47 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
01:58:47 <lambdabot> Data.List zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
01:59:14 <frerich> develhevel: Oh, if you are working with 'Text', you could also use Data.Text.replace
01:59:29 <mreh> it should be easy to write your own
01:59:35 <ptd> You could just implement that function yourself, it's not hard
02:01:09 <ptd> :t Data.Text.replace
02:01:10 <lambdabot> Couldn't find qualified module.
02:02:04 <frerich> lambdabot somehow doesn't know a lot of stuff.
02:03:06 <mreh> she's fine
02:03:07 <ptd> :t intercalate
02:03:08 <lambdabot> forall a. [a] -> [[a]] -> [a]
02:03:19 <ptd> :t splitOn
02:03:21 <lambdabot> Not in scope: `splitOn'
02:06:38 <ptd> :t split
02:06:39 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
02:07:44 <ptd> :isPrefixOf
02:07:48 <ptd> :t isPrefixOf
02:07:49 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
02:10:02 <ptd> :t fix (\f rep str -> (if isPrefixOf str then rep ++ drop (length rep) str else f $ tail str))
02:10:04 <lambdabot>     Couldn't match expected type `Bool'
02:10:04 <lambdabot>            against inferred type `[a] -> Bool'
02:10:04 <lambdabot>     In the expression: isPrefixOf str
02:11:04 <ptd> :t fix (\f old rep str -> (if isPrefixOf old str then rep ++ drop (length old) str else f $ tail str))
02:11:06 <lambdabot>     Couldn't match expected type `[a]'
02:11:06 <lambdabot>            against inferred type `[a] -> [a] -> [a]'
02:11:06 <lambdabot>     In the expression: f $ tail str
02:12:17 <mreh> ptd: you can speak to her in private if you find it more useful
02:12:26 <mreh> "/msg lambdabot"
02:13:27 <ptd> mreh: thanks, although actually I'm just going to use ghci
02:16:54 <gavnio> how does type system alleviate the need for string replacements
02:17:00 <gavnio> ?
02:19:35 <mreh> gavino, because it's more convenient to use an abstract datatype than a string to represent your data
02:19:49 <solistic> Is there a template-haskell Lift instance for Text around? Google yields zero results for that.
02:20:56 * hackagebot wai-app-file-cgi 0.3.1 - File/CGI App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.3.1 (KazuYamamoto)
02:30:26 <Kaidelong> does (Unboxed t) => Unboxed (Just t)
02:30:32 <Kaidelong> err
02:30:34 <Kaidelong> Maybe t
02:30:35 <Kaidelong> I mean
02:31:02 <Kaidelong> not that it seems like a great idea
02:31:27 <Kaidelong> but I imagine you could do it trivially since Maybe adds just one piece of extra information (Nothing)
02:31:52 <QinGW> @seem bonus
02:31:53 <lambdabot> Unknown command, try @list
02:31:58 <QinGW> @see bonus
02:31:58 <lambdabot> Maybe you meant: free let src
02:32:06 <Kaidelong> preflex seen bonus
02:32:11 <Kaidelong> hmm
02:32:23 <QinGW> @seen bonus
02:32:24 <preflex_>  bonus was last seen on #haskell 82 days, 14 hours, 17 minutes and 17 seconds ago, saying: yeah i think that's better as well
02:32:24 <lambdabot> Unknown command, try @list
02:32:44 <QinGW> Kaidelong: thanks
02:33:03 <Kaidelong> I don't think it worked actually!
02:33:33 <Kaidelong> I think BONUS is in here often, he just doesn't talk very much
02:33:42 <Kaidelong> 82 days seems a bit unlikely
02:34:15 <QinGW> Do you read his book?
02:34:30 <Kaidelong> I haven't lately no but I did a while ago
02:42:25 <ptd> @seen ptd
02:42:26 <lambdabot> Unknown command, try @list
02:42:26 <preflex_>  ptd was last seen on #haskell 28 minutes and 59 seconds ago, saying: mreh: thanks, although actually I'm just going to use ghci
02:42:35 <ptd> @seen ptd
02:42:36 <preflex_>  ptd was last seen on #haskell 10 seconds ago, saying: @seen ptd
02:42:36 <lambdabot> Unknown command, try @list
02:43:31 <mreh> :t mapM (traverse pure)
02:43:32 <lambdabot> Not in scope: `traverse'
02:43:43 <mreh> :t mapM (Data.Traversable.traverse pure)
02:43:44 <lambdabot> forall a (m :: * -> *) (t :: * -> *). (Applicative m, Data.Traversable.Traversable t, Monad m) => [t a] -> m [t a]
02:44:04 <mreh> :t Data.Traversable.mapM (Data.Traversable.traverse pure)
02:44:05 <lambdabot> forall a (m :: * -> *) (t :: * -> *) (t1 :: * -> *). (Applicative m, Data.Traversable.Traversable t, Data.Traversable.Traversable t1, Monad m) => t1 (t a) -> m (t1 (t a))
02:54:38 <burbul> Could someone point me at an introduction to the ST monad? (Google has been less helpful than usual... I found the original paper, but everything has been substantially renamed.)
03:03:24 <JuanDaugherty> burbul, you could try reading it.
03:03:39 <Kaidelong> burbul: What do you want to do with the ST monad?
03:07:38 <burbul> reading: I've read the  relevant section of the original paper, but the main example it gives is swap -- so I was hoping for a somewhat larger example .
03:08:03 <burbul> Kaidelong: I need to cache something. (results of a pair of mutually recursive functions which are defined locally inside another function)
03:08:09 <burbul> I actually seem to be doing okay, so don't worry...
03:08:20 <JuanDaugherty> i meant the code
03:09:53 <burbul> oh -- I assumed it would be full of low-level hackery to make the ST monad actually modify things in place (as opposed to copying them)
03:11:12 <JuanDaugherty> in any case it should be vastly superior to any exegesis on it
03:11:50 <JuanDaugherty> as far as obtaining understanding is concerned
03:15:55 <ourfrank> Have any non-tutorial applications been created with Tobias' GPipe package? http://hackage.haskell.org/package/GPipe
03:16:08 <JuanDaugherty> unless you're working in microcode, "low level" is judgemental, to me everything in haskell is high level
03:17:53 <levkin> Hi
03:18:11 <JuanDaugherty> yello
03:19:06 <levkin> Well ... it's the first time I am asking question , so
03:19:32 <JuanDaugherty> just ask
03:19:41 * JuanDaugherty afk
03:19:45 <levkin> I am looking for good tutorial on QuickCheck , anyone ?
03:21:50 <ourfrank> levkin: There's always the manual: http://www.cse.chalmers.se/~rjmh/QuickCheck/manual.html
03:22:23 <levkin> Thanks
03:23:29 <ourfrank> levkin: No problem. But I'm not aware of any comprehensive tutorial. The biggest part of the work is creating an instance of Arbitrary for the types you wish to work with.
03:23:49 <levkin> More specific question >
03:23:51 <levkin> More specific question
03:27:16 <levkin> I have function [a] -> [a] . I'd like to create generator in the following fashion . [a] is instance of Arbitrary . I am generating random expected result and then perform inverse operation to f that also contains random generation such that . f  $ (f_inv)  exp == exp
03:27:32 <levkin> I have troubles to convert it into property
03:31:29 <ourfrank> levkin: If you've defined the instance, then a property would be something like (prop_InvEq xs = f_inv (f xs) == xs), I think.
03:32:05 <ourfrank> levkin: For every xs, performing f and f_inv on it must yield back the same xs.
03:33:23 * hackagebot bindings-dc1394 0.2.1 - Library for using firewire (iidc-1394) cameras  http://hackage.haskell.org/package/bindings-dc1394-0.2.1 (VilleTirronen)
03:34:06 <levkin> Complication is that xs is not arbitrary (pun not intended) , but is a subject to certain laws . Also inverted function has the same limitation
03:35:44 <ourfrank> levkin: Shouldn't an instance of Arbitrary for the type of xs then be defined in a way that it behaves certain laws? For instance, you could define your own integers with a rule "they are never less than 3".
03:36:33 <ourfrank> levkin: So, I think these laws should be defined in the Arbitrary instance. (Take this with a grain of salt, I've only dabbled in QC.)
03:37:30 <willem> levkin: you could also check out http://book.realworldhaskell.org/read/testing-and-quality-assurance.html. This chapter has a few examples about QuickCheck.
03:40:13 <willem> Are there any published style guidelines on haskell, in particular about aligment and layout?
03:40:30 <levkin> Got it . Thanks
03:43:36 <willem> Mainly I'm interested in what the preferable layout is for the do-notation (newline after do and increase indentation afterwards/continue after do and align the rest at the same collumn after do).
03:46:21 <mercury^> willem: do what looks good to you while using not more than 80 characters per line and no tabs.
03:48:43 <Eduard_Munteanu> willem: that's about it I think
03:49:19 <willem> okay thanks!
03:54:05 <burbul> I have some mutually  recursive functions (existing inside another function) and I'm trying to cache their return values using the ST Monad. Problem is, I can't find a way to make the STRef for the cache visible to the inner functions without explicitly passing it in. This ( http://hpaste.org/49350 ) attempt to do it with closures doesn't work. Any advice would be great!
03:55:33 * hackagebot simple-firewire 0.1.3 - Simplified interface for firewire cameras  http://hackage.haskell.org/package/simple-firewire-0.1.3 (VilleTirronen)
03:55:57 <opqdonut> how does it not work?
03:56:07 <opqdonut> ah, yes
03:56:32 <opqdonut> no, I don't see it
03:57:20 <burbul> Shall I post the error message?
03:58:20 <burbul> http://hpaste.org/49351
04:00:28 <burbul> Ah... commenting out the type signatures for the inner functions fixed it
04:01:13 <burbul> I think that it was having trouble equating the 's's in the outer and inner references to ST
04:04:35 * hackagebot simple-firewire 0.1.3.1 - Simplified interface for firewire cameras  http://hackage.haskell.org/package/simple-firewire-0.1.3.1 (VilleTirronen)
04:05:56 <Eduard_Munteanu> burbul: depending on what you did there you might need to use scoped type variables
04:06:21 <Eduard_Munteanu> Ah, I just saw the code paste, should look at it
04:07:16 <burbul> don't worry -- I've got it working now
04:07:25 <burbul> (Although bizarrely it's slower with the cache)
04:07:43 <sebz> I feel like I shouldn't be writing stuff like this... http://hpaste.org/49352
04:08:32 <sebz> I was going to fold with onPair2 (++) but that seems odd
04:09:12 <sebz> is there a nicer way?
04:09:42 <siracusa> > succ *** pred $ (10,10)
04:09:43 <lambdabot>   (11,9)
04:10:12 <siracusa> > join (***) succ $ (10,10)
04:10:13 <lambdabot>   (11,11)
04:12:58 <Eduard_Munteanu> burbul: yeah, I think the issue is the 's' in the result type can't unify with the one in your actual STRef
04:13:34 <burbul> Does Haskell short-circuit the evaluation of 'a==b' when a and b point to the same (finite) data structure? [ I know it doesn't make a difference to the semantics, but it may make some difference to efficiency.]
04:13:46 <burbul> Eduard_Munteanu --  thanks
04:14:26 <Eduard_Munteanu> When you pass it in explicitly you end up with a type like    STRef s Foo -> ... -> ST s Bar
04:14:39 <burbul> (Or I suppose I should have said: does GHC short-circuit...)
04:14:50 <burbul> Yes, that makes sense;
04:14:58 <Eduard_Munteanu> > False && undefined
04:14:59 <burbul> But I'm planning to have multiple caches, and I didn't want to pass them all around.
04:15:00 <lambdabot>   False
04:15:04 <Eduard_Munteanu> burbul: ^
04:15:11 <mercury^> > let t = 1:t in t == t
04:15:15 <lambdabot>   mueval-core: Time limit exceeded
04:15:43 <mercury^> burbul: does not seem so (at least for the evaluator in use here)
04:15:49 <burbul> That's why I said "finite" ... it occurred to me that an optimiser *might* detect finite data structures (although it would be tricky)
04:15:54 <Eduard_Munteanu> Damn, I'm not reading.
04:16:12 <burbul> I suppose I could test by defining some huge list.
04:16:18 <mercury^> burbul: so you are asking whether some kind of optimisation is performed, *sometimes*?
04:16:26 <burbul> yes
04:16:37 <mercury^> That is a very vague question.
04:17:08 <burbul> My Haskell program is slower than the Python code I'm porting  because the latter makes use of object equality to make equality comparisons between large trees very fast.
04:17:42 <burbul> And I can't think of a way to make the Haskell code faster, short of setting up a bucket load of hash functions
04:18:02 <mercury^> You can just tag each tree and compare the trees only if the tags do not already match.
04:18:13 <burbul> tag with what?
04:18:17 <mercury^> An int?
04:18:19 <Eduard_Munteanu> You mean like pointer comparison?
04:18:39 <burbul> Eduard_Munteanu: in Python, yes
04:19:36 * hackagebot simple-firewire 0.1.3.2 - Simplified interface for firewire cameras  http://hackage.haskell.org/package/simple-firewire-0.1.3.2 (VilleTirronen)
04:19:37 <burbul> The difficulty with tagging with an int is that the data structure doesn't leave space to do that. I could convert from that data structure to another almost-isomorphic  data structure which had space for a tag, but it's getting pretty messy
04:20:24 <burbul> (And I can't use an auxiliary data structure like Map Tree Int, because the lookup in that would cost more than the speed gained elsewhere)
04:20:32 * aleator is strangling himself with firewire
04:20:38 <mercury^> burbul: if things get messy just because you add tags, something is wrong.
04:20:45 <Eduard_Munteanu> I don't think that's possible as an optimization in Haskell, since mutation often happens by copying the object.
04:21:23 <burbul> mercury^: the data structure looks like this:
04:21:25 <burbul> data Node = Node Int Int Category [Reading] deriving (Eq, Ord)
04:21:26 <burbul> data Reading = Reading Production [Node] [Int] deriving (Eq, Ord)
04:21:29 <mercury^> burbul: data Tagged a = Tagged a Int
04:21:39 <burbul> That's not enough, because it's recursive
04:21:54 <mercury^> burbul: instance Eq a => Eq (Tagged a) or something like that.
04:22:11 <Eduard_Munteanu> So if you apply a transformation to such a tree, then reverse it, you may end up with different trees in memory that are identical
04:22:31 <burbul> The data structure is used by a bunch of things, so I don't want to just modify it;
04:23:07 <burbul> Eduard_Munteanu: yes -- I asked whether (object equality) => (fast comparison), but I'm aware that in some cases you have identity without object equality
04:23:09 <mercury^> You could also use the Reader monad.
04:23:33 <aleator> burbul: Comparing object identity in python and comparing dictionary contents are totally different, right?
04:23:57 <burbul> aleator: yes, I think so
04:24:27 <burbul> (The point is that if you don't have object equality then you have to do a cumbersome search to determine whether or not you have identity; but it's still a lot faster in the case where you have object equality)
04:24:48 <burbul> mercury^: sounds v. interesting, but I don't follow... how does the Reader monad help?
04:25:42 <aleator> burbul: Where are you using object identity? I'm curious since I haven't needed that in a long long time
04:26:23 <burbul> I believe it's hidden in the default hash functions in Python
04:26:41 <burbul> So whenever  you use a set/map you invoke it
04:27:02 <burbul> + I'm careful never to create two distinct objects which are in fact equal
04:27:03 <mercury^> burbul: by using Reader Int Tree instead of Tree everywhere you might want to compare for equality.
04:27:39 <aleator> burbul: If you're careful not to create equal objects, why do you need equality?
04:28:20 <burbul> aleator: That's in Python. (I was about to say that rather than creating an object directly, I check in a cache to see if one exists, and only create it if it doesn't exist)
04:28:55 <burbul> in Haskell there isn't really any notion of the object, so you have these huge identical trees floating around and (I think) my program is slow because it's running recursive comparisons on them
04:29:34 <aleator> burbul: Anyways, haskell doesn't give you object identity (there are no objects, just values), so you need to provide it yourself. value-supply package in hackage is helpful for this.
04:30:09 <burbul> mercury^: thanks... this sounds promising. I'm going to go and read up on Reader. (I thought it just added a queue you could statefully pull things out of, but it sounds like I have the wrong picture.)
04:30:21 <aleator> Also, code example would be helpful
04:33:03 <burbul> aleator: it's a bit long, but the actual code is at http://hpaste.org/49354
04:33:53 <burbul> I'm not sure what simplifications I can make, because I'm not sure where the main slowdown is.
04:33:58 <burbul> (But please don't feel you have to look at it.)
04:36:15 <aleator> burbul: Well, you could try profiling and possibly entering cost-centres by hand in the suspicious places
04:45:15 <qubodup> hi
04:46:11 <qubodup> what was the last ghc-platform version to use pre 4.4.0 gcc?
05:22:10 <JuanDaugherty> there's a ghc-platform?
05:22:27 <JuanDaugherty> (distinct from hp?)
05:24:20 <mreh> there's just GHC as far as I'm aware
05:24:41 <mreh> HP includes GHC and key libraries + tools
05:25:05 <JuanDaugherty> right was referring to last comment in channel
05:25:28 <mreh> :)
05:25:31 <JuanDaugherty> didn't think there was, but would be important to me if there was
05:26:14 <mreh> ghc is a self contained project, i don't think there is a need for one
05:27:02 <JuanDaugherty> well and hp/galois has occupied the namespace/niche
05:29:18 <JuanDaugherty> speaking of which there is an update which will have been slipped in about a week
05:31:11 <mreh> only dons would see monads in Inception
05:31:27 <JuanDaugherty> the movie?
05:31:31 <mreh> yeah :)
05:31:37 <mreh> reading an old blog post
05:31:38 <JuanDaugherty> lol
05:32:22 <JuanDaugherty> i don't think I was able to watch more than about 30 min of that
05:32:36 <mreh> i can't stand GHC picks list as the expected type where there is some monad type to be fufilled in type inference
05:33:13 <JuanDaugherty> whaddya want tuple oder?
05:33:48 <mreh> ?
05:34:21 <JuanDaugherty> what type do you suggest if any?
05:36:44 <mreh> JuanDaugherty: a less commonly seen type I suppose :)
05:37:24 <mreh> well, if it requires a monad based on some type context constraint then a generalised monad type would be nice
05:38:09 <mreh> it must be possible
05:47:46 <JuanDaugherty> list and tuple are pretty much the arche-types SFAIK
05:51:36 <sipa> you can define List a as (a,List a)
05:55:09 <copumpkin> NonEmptyList?
05:55:21 <copumpkin> or that's closer to Stream, actually
05:55:24 <sipa> a crap
05:55:27 <sipa> of course
05:55:31 <sipa> InfiniteList even :)
05:55:50 <benmachine> List a = Maybe (a,List a)
05:55:58 <sipa> that's it, indeed
05:56:31 <benmachine> List a = Mu (Maybe . (,) a)
05:56:44 <benmachine> where . is actually :.: or whatever
05:56:45 <ptd> sipa: what is the definition of (\x -> [x]) for that list type?
05:57:12 <benmachine> dude asks a question and then immediately quits, cool
05:57:18 <sipa> ptd: let repeatInfinite x = (x,repeatInfinity x)
05:57:19 <sipa> :)
05:57:38 <aavogt> @src repeat
05:57:39 <lambdabot> repeat x = xs where xs = x : xs
05:58:02 <aavogt> if you do that sort of thing, it's supposed to take up less space
05:59:08 <Eduard_Munteanu> Well, immediately isn't optimal. Better if you take a few seconds so people get to type 75% of a reply :)
05:59:41 <byorgey> I'm guessing ptd did not quit intentionally
05:59:54 <JuanDaugherty> me too
06:01:10 <ptd> byorgey: My wifi connection died, so I restarted it and xchat. Xchat had just enough time to send that message before I killed it.
06:01:44 <Eduard_Munteanu> Yeah, I'm kidding, don't take it seriously :).
06:02:20 <Eduard_Munteanu> 16:09 < sipa> ptd: let repeatInfinite x = (x,repeatInfinity x)
06:02:20 <Eduard_Munteanu> 16:09 < sipa> :)
06:02:53 <Twey> repeatInfinite :: a -> ?!?!?
06:03:15 <ptd> :t fix (\f -> (x, fx))
06:03:16 <lambdabot> Not in scope: `fx'
06:03:19 <ptd> :t fix (\f -> (x, f x))
06:03:20 <lambdabot>     Couldn't match expected type `Expr -> t'
06:03:20 <lambdabot>            against inferred type `(Expr, t)'
06:03:20 <lambdabot>     In the expression: (x, f x)
06:03:33 <byorgey> well, that actual definition does not work since Haskell does not have equirecursive types.  but the idea is the same.
06:04:03 <byorgey> List a = (a, List a)   does not work even.
06:04:13 <byorgey> but  data List a = Cons a (List a)  works.
06:04:16 <ptd> @google equirecursive types
06:04:18 <lambdabot> http://en.wikipedia.org/wiki/Recursive_data_type
06:04:18 <lambdabot> Title: Recursive data type - Wikipedia, the free encyclopedia
06:04:33 <byorgey> then  return x = Cons x (return x)
06:04:38 <Eduard_Munteanu> ptd: Haskell has isorecursive types...
06:05:01 <Eduard_Munteanu> That is List a ~ a + List a, where ~ denotes isomorphism
06:05:33 <Eduard_Munteanu> If you had equirecursive types, then List a would be exactly the same thing as 'a + List a'
06:05:57 <Eduard_Munteanu> (i.e. equality)
06:06:03 <magicman> a + List a?
06:06:25 <ptd> (a, List a) != List a
06:06:28 <magicman> 1 + a * List a, surely?
06:06:39 <ptd> even if List a = (a, List a)
06:06:48 <Eduard_Munteanu> Uh, yeah, my bad
06:07:00 <magicman> (disregarding the usual bottom-related yadda yadda)
06:21:11 <ptd> Does haskell need the genericFoo functions in prelude, couldn't the optimiser specialise the foo variants to Int as necessary instead?
06:21:48 <byorgey> ptd: yes, the whole X vs genericX thing was a mistake
06:22:26 <liyang> It was a long time ago, and we were very young and na√Øve.
06:22:34 <liyang> And possibly drunk.
06:22:43 <zygoloid> arguably it's the same 'mistake' as having map not being fmap. early haskell was scared about things being too polymorphic
06:23:37 <byorgey> it's in the same class of mistakes, but I think X vs genericX is a bigger mistake than map vs fmap.
06:23:37 <ptd> I thought so, high level language needs a maxim
06:23:43 <byorgey> dunno how you quantify mistakes though.
06:23:53 <ptd> "Trust thy optimiser"
06:25:25 <ptd> If the optimiser can perform an optimisation then the programmer should be able to forget the optimisation is even performed.
06:26:55 <ptd> If you made these types more polymorphic, would anything break?
06:27:09 <erus`> i want to design a purely functional language like haskell, can i Just pass a 'world' type object around to functions that need todo IO?
06:27:31 <ptd> erus`: Not quite
06:28:08 <ptd> consider this function, (\f world -> (world, f world))
06:29:11 <Guest57648> hi all :), i have a question? why ghci complaint me that "x" and "n" are not in scope? (code in http://hpaste.org/49356) thanks!
06:29:13 <ptd> At a later date the program could probe "f world" and choose between those two copies of the world, but you cannot do this in real life.
06:29:34 <erus`> ah damn
06:29:58 <erus`> maybe i will just have an 'unpure' tag or something
06:30:04 <erus`> yuck :(
06:30:29 <Botje> Guest57648: uh, you're pattern matching wrong.
06:30:31 <ptd> Guest57648: Your using guards when you want pattern matching
06:30:52 <Botje> decodifica (Single x : t) = x : decodifica t
06:31:24 <Guest57648> ahhh... ok! thanks to all. i'm a very beginner...
06:31:24 <Botje> or you can stick with your current code but do case h of Single x -> ...; Multiple n x -> ...
06:32:11 <ptd> f x y z = ... means "f has three arguments, match them against these patterns"
06:33:01 <Eduard_Munteanu> erus`: another option is uniqueness typing, if you're interested in alternatives to Haskell's system
06:33:21 <ptd> f | x y z = ... means "f has no arguments, if x applied to y and z is True, then f = ..."
06:34:09 <ptd> Guest57648: The first is a pattern match, the second is a guard
06:34:26 <Eduard_Munteanu> http://en.wikipedia.org/wiki/Clean_(programming_language)    -- for an example
06:35:14 <Guest57648> ptd: thank a lot.
06:37:44 <Guest57648> Botje: but " decodifica (Single x : t) = x : decodifica t " complaint that i have "Multiple declarations of `Main.Single' "...
06:40:42 <Botje> what?
06:40:47 <zygoloid> Guest57648: or you can write it as: decodifica ls@(h:t) | Single x <- h = x : decodifica t -- etc
06:41:08 <ptd> "decodifica ls@(Single x:t) = x:decodifica t" works for me
06:41:39 <byorgey> why ls@ ?
06:41:41 <zygoloid> the ls@ is unnecessary: ls is never used in the RHS
06:41:48 <ptd> "decodifica (Single x:t) = x:decodifica t" works for me
06:42:00 <ptd> I had not bothered to remove it
06:42:22 * zygoloid considers pointing out that this is a concatMap
06:43:06 * Botje is reminded that he still needs to prepare a new exam
06:43:35 <Botje> reading pages upon pages of sad tail-recursions :(
06:44:21 <Guest57648> ptd: yes, but i have a definition of Single x in : "data ListItem a = Single a | Multiple Int a"
06:45:29 <ptd> try this http://hpaste.org/49357
06:46:05 <brookshanes> 'mornin
06:47:21 <Guest57648> ptd: i'm sorry, this work fine. Thankyou :)!
06:49:07 <brookshanes> reset magic
06:52:03 <ptd> Guest57648: Here is alternative definition using the function concatMap http://hpaste.org/49358
06:53:03 <copumpkin> what if I want infinite ones!
06:57:51 <Botje> but there's a shortage!
06:58:08 <Botje> you'll exhaust the reserve of ones infinity times over!
07:00:54 <mokus> it's ok, lambdabot can always make more
07:01:13 <mokus> > fix (1:)
07:01:14 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:01:17 <mokus> see :)
07:01:39 <benmachine> > let see = 1 in fix( see :)
07:01:40 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:01:48 <mokus> lol
07:01:57 <shachaf> > l–∞st $ fix (1:)
07:01:58 <lambdabot>   1
07:01:59 <mokus> "fixed that for you"
07:02:22 * benmachine raises an eyebrow at shachaf
07:02:26 <benmachine> > last [1,2,3]
07:02:26 <lambdabot>   3
07:02:47 <shachaf> > l–∞st [0,0..]
07:02:49 <lambdabot>   0
07:03:10 <benmachine> > l–∞st $ fix (1:)
07:03:11 <lambdabot>   1
07:03:13 <mokus> > last [1..]
07:03:17 <lambdabot>   mueval-core: Time limit exceeded
07:03:25 <shachaf> mokus: Obviously it won't be able to compute an infinite Integer.
07:03:30 <benmachine> > l–∞st $ fix (1:) ++ [2]
07:03:32 <lambdabot>   1
07:03:42 <mokus> heh
07:03:47 <shachaf> benmachine: Technically that's accurate.
07:03:54 <mokus> > last (cycle [1,2])
07:03:55 <cheater_> > let x = 1:2:x in last x
07:04:01 <ketil> Explosion in Oslo just now, probably a terror attack.
07:04:05 <cheater_> mokus: FIRST
07:04:09 <lambdabot>   thread killed
07:04:16 <mokus> cheater_: not on my screen ;)
07:04:16 <ketil> (sorry for the off-topic)
07:04:29 <cheater_> ketil, that's because you're lagged
07:04:31 <cheater_> ketil, yeah
07:04:49 <cheater_> ketil, did anyone get hurt?
07:05:16 <ketil> Yes, lots of people hurt, mostly mildly from flying glass so far.  No deaths reported yet, but it seems likely.
07:05:38 <benmachine> bbc news says at least eight people injured
07:06:44 <JuanDaugherty> apparently there were two, Al Qaeda style
07:07:14 <mokus> > last (replicate 1000 0 ++ repeat 1)
07:07:16 <ketil> I think there's way more, but mostly lightly.  We'll see.  BTW, I can make a different channel for this if you're interested.  (I'm just watching TV, so nothing very sensational)
07:07:33 <mokus> lambdabot is sulking now, it seems
07:07:34 <benmachine> :t last
07:07:36 <ketil> JuanDaugherty, some rumours about a second bomb only, I guess there was only one.
07:08:12 <Saizan> there is #haskell-blah
07:08:31 <ketil> Saizan, OK.  I'll hang there if anybody wants updates.
07:12:38 <ptd> :t last
07:12:40 <JuanDaugherty> looks like the exceptions killed it, doesn't it automatically bounce back?
07:12:53 <JuanDaugherty> i.e. rejoin?
07:12:57 <ptd> Noooooooooooooooooooooooooooooo!
07:13:26 <mokus> alas, poor lambdabot.  I know her well, horatio!
07:14:34 <ptd> Out of sheer curiosity, is there any reason why lambdabot is always female?
07:14:59 <mokus> not sure, that's just the way it's always been
07:15:23 <mokus> where "always" = "as long as I can remember"
07:15:51 <benmachine> JuanDaugherty: she's supposed to, but she's old and no-one really understands her
07:16:03 <benmachine> ptd: possibly something to do with @vixen
07:16:28 <benmachine> or more cynically it may be something to do with the natural compsci gender ratios
07:17:13 <ptd> benmachine: Are you suggesting that all the men on #haskell feel lonely?
07:17:21 <benmachine> yes
07:17:24 <benmachine> I do :(
07:17:33 <benmachine> well, not all of them
07:17:46 <shachaf> If you interrogate @vixen carefully you'll find that lambdabot is male pretending to be female.
07:18:01 <benmachine> I'm not sure whether this proves me right or wrong
07:18:51 <maltem> Sorry to just come back from nowhere, guys, and maybe to interrupt a social discussion, but I feel quite stupid when confronted with quasi-quotation
07:19:25 <maltem> I do not even understand why it is different from splices, as to deserve another syntax
07:19:45 <maltem> I mean, why is  [$qq| blah ]  not just  $(qq "blah")  ?
07:20:00 <benmachine> maltem: convenience?
07:20:08 <kmc> yeah, that's basically sugar
07:20:11 <benmachine> everything in the string is automatically quoted for you and can run over multiple lines
07:20:27 <kmc> quasiquoting has the same syntax for a few contexts (expr, pattern, type)
07:20:28 <zygoloid> iirc qq happens in the renamer and th happens before that?
07:20:29 <maltem> oh, that's a disappointing answer :) I hoped to be enlightened
07:20:54 <benmachine> zygoloid: after that, I think
07:21:03 <maltem> zygoloid, I take it that's an implementation detail, or does it affect semantics?
07:21:05 <zygoloid> possibly :)
07:21:08 <benmachine> qq happens in the renamer and TH in the typechecker, possibly
07:21:16 <zygoloid> maltem: it affects what's possible in the two different cases
07:21:30 <zygoloid> benmachine: sounds familiar :) i almost typed that but wasn't sure about hte second part
07:21:48 <zygoloid> maltem: for instance, TH cannot bind names
07:22:39 <maltem> zygoloid, may I read that as: a quasi-quotation can simulate let bindings, the $() syntax cannot?
07:22:51 <zygoloid> that is correct
07:23:13 <zygoloid> although there's an extent to which that's an implementation detail too
07:23:26 <benmachine> TH is all dark magic anyway
07:23:37 <zygoloid> spj has considered moving TH into the renamer
07:23:44 <maltem> Am I allowed to induce that [$| ] is simply more powerful than $() ?
07:24:01 <maltem> (from a practical perspective)
07:24:22 <maltem> benmachine, that's why I try to avoid to read it most of the time
07:24:32 <Saizan> you can generate bindings with $() too, if it's in a declaration context
07:24:57 <maltem> declaration context = top level?
07:25:34 <Saizan> yeah, i suspect inside a let or where too though
07:25:52 <maltem> ah ok
07:26:00 * Saizan tests
07:27:49 <Saizan> i guess no, you've to generate the whole let expression
07:30:49 <maltem> ok. I shouldn't lament like this I suppose, but I find it unfortunate that TH isn't as "obvious" as Haskell is typically
07:32:57 <Saizan> part of this seems to be lack of manpower and the resulting demand-driven developement, but SPJ wrote about an overhaul recently
07:34:01 * hackagebot bag 0.1 - A simple stable bag.  http://hackage.haskell.org/package/bag-0.1 (DanielWaterworth)
07:36:29 <ptd> Who runs lambdabot, can they restart it for us?
07:36:52 <Saizan> Cale
07:38:39 <maltem> yeah I've seen a couple of TH design considerations on the ghc wikiÖ
07:39:01 * hackagebot mongoDB 1.0.1 - Driver (client) for MongoDB, a free, scalable, fast, document DBMS  http://hackage.haskell.org/package/mongoDB-1.0.1 (TonyHannan)
07:39:06 <zygoloid> is there anything more recent than this: http://hackage.haskell.org/trac/ghc/ticket/4230
07:42:18 <maltem> heh, that ticket roughly reads like, it's too difficult, we do it anyway
07:45:27 <jayantr7> Hi!
07:45:57 <kmc> hi jayantr7!
07:47:50 <jayantr7> is anyone here?
07:48:26 <sipa> no
07:48:38 <jrick> almost, just keep waiting
07:48:39 <dpratt71> just us bots
07:48:45 <jayantr7> ??
07:48:59 <kmc> i'm not here, this isn't happening
07:50:12 <ptd> yeah, just us bots (except lambdabot, who's dead)
07:50:30 <jayantr7> can u all tell me which is better? haskell or python?
07:50:40 <Clint> pudding
07:50:48 <shachaf> Python's better. Go ask #python, they'll confirm it.
07:51:07 <tomh> hmm with function definitions in a where, is it prefered that you use variables from the top function or instead pass them as parameters?
07:51:26 <ptd> jayantr7: Depends whether you want to do functional or imperative programming
07:51:44 <ptd> Python is functional, Haskell is imperative
07:52:43 <shachaf> Haskell is the categorical imperative.
07:52:44 <benmachine> tomh: if you don't need to pass them then don't, imo
07:52:47 <jayantr7> I WANNA MAKE APPS TO SOLVE PROBLEMS A FAST AND SHORT-CODED AS I CAN
07:53:11 <tomh> benmachine: so just depend on enclosed vars when possible?
07:53:12 <jrick> try matlab
07:53:14 <benmachine> jayantr7: I think haskell is better, but lots of people have different opinions. you should probably learn both and decide for yourself
07:53:37 <benmachine> tomh: yeah, I think so. it should be a function if it needs to be a function and shouldn't be if it doesn't
07:53:42 <ptd> tomh: Use variables in the top function, then you can turn (f a b c k) into (f k), which is easier to read
07:53:52 <tomh> ok cool
07:54:01 <zygoloid> jayantr7: if you want a simple yes/no answer, ask in #python :) *ducks*
07:54:03 <benmachine> that way you are providing more information to your readers -- this is the same every time this function is called
07:54:14 <benmachine> etc.
07:54:27 <jonkri> anyone had a problem on windows of a haskell package not compiling because of libstd++.dll missing?
07:54:49 <zygoloid> jonkri: are you using a c++ library via FFI?
07:54:56 <ptd> tomh: And note the ghc does not do common subexpression elimination
07:55:48 <tomh> ok
07:55:58 <tomh> but you can hint ghc for that right
07:56:02 <ptd> so "(f k, f k) where f k = k + 1" may be less efficient than "(l, l) where l = k +1"
07:56:29 <jonkri> zygoloid, no, my application is completely pure (although it depends on aeson, happstack, and some other stuff)
07:56:55 <tomh> ok cool
07:58:27 <kmc> really sick of "is haskell good kthx"
07:58:41 <kmc> no context
07:58:47 <kmc> there's really a single master ordering on all programming languages?
07:58:56 <djahandarie> Yes. Agda is the best!!!
07:59:32 <copumpkin> to be more obscure
08:00:04 <benmachine> > "haskell" > "python"
08:00:04 <copumpkin> from now on you should talk about agda being an initial (or terminal) object in the order category given by the ordering of quality (in whatever order would put the best in the front or back)
08:00:10 <benmachine> oh yeah :(
08:02:53 <kmc> 1-category theory is not powerful enough for today's enterprise SaaS solutions
08:02:57 <kmc> we have to go deeper!
08:03:02 <copumpkin> derper
08:03:07 <copumpkin> you played that game by the way?
08:03:16 <kmc> which
08:03:53 <copumpkin> hmm, now I can't find it
08:04:26 <mercury^> What's SaaS anyway?
08:04:34 <Clint> "software as a service"
08:07:25 <mokus> copumpkin : does your quality ordering have a terminal (or initial) object?  ie, whichever end agda isn't on
08:10:41 <agkbill> Hi, I have just started to use Xmonad togher with dmenu, workes great. Until now when dmenu no longer show any programs.
08:10:46 <copumpkin> mokus: we shall hereafter refer to that object as the PHP object
08:10:56 <Twey> agkbill: #xmonad
08:11:00 <mokus> copumpkin: works for me
08:11:10 <agkbill> Any ide way it could be?
08:11:15 <Twey> copumpkin: Haha
08:11:17 <mokus> (the terminology, not PHP ;)
08:11:20 <Twey> copumpkin: Not used much COBOL, huh?
08:11:23 <parcs> agkbill: yes
08:11:31 <agkbill> xmonad works great. It is just dmenu
08:11:54 <parcs> a recent update of dmenu removes the dmenu_run script which xmonad uses
08:12:05 <parcs> dmenu_path*
08:12:24 <Twey> parcs: dmenu isn't even written in Haskell :√æ
08:12:24 <parcs> you have to override the key binding to use dmenu_run instead
08:12:38 <Twey> Err, agkbill
08:13:14 <agkbill> parce: ok I try that
08:15:26 <agkbill> parcs: Works, dmenu start ok. Any ide how I restore the start script. When I installed dmenu (pacman, Archlinux) I did not have to edit anything. It just worked.
08:16:36 <parcs> agkbill: i don't know what you mean by 'restore the start script'
08:17:16 * edwardk waves hello.
08:17:25 <dankna> does anybody have general advice on improving the performance of deep stacks of monad transformers?
08:17:29 <dankna> deep = about eight
08:17:46 <dankna> they're all ReaderT if that helps
08:18:01 <edwardk> dankna: tuple em
08:18:04 <Entroacceptor> agkbill: use xmonad.prompt instead, and talk about it in #xmonad
08:18:12 <agkbill> parcs: sorry, I meen to get the key-binding back to original. guess it is in xmonad config file?
08:18:40 <edwardk> dankna: make one data Env = Env { foo :: Foo, bar :: Bar, baz :: Baz } ‚Äî and then run a reader over that
08:18:45 <dankna> edwardk: hmm? you mean make it a single transformer instead of a stack?  hmmm...
08:18:47 <mreh> danka, what's the application out of curiosity
08:18:52 <edwardk> if they are readers they aren't changing and you cn use asks instead of ask
08:19:13 <dankna> I may be able to do that, but it's nontrivial because I'm not always in all of them and I'm entering them in different orders and stuff
08:19:16 <edwardk> in general if you use the same transformer in a stack multiple times you're doing it wrong =)
08:19:38 <dankna> I did eliminate the one situation where I was entering things recursively, but to my surprise it didn't make much difference in performance
08:19:39 <mreh> :t asks
08:19:52 <mreh> lambdabot?!
08:19:56 <dankna> okay.  I'll think on how I can apply your advice.  that's valuable, thanks :)
08:19:58 <edwardk> you can ease the pain by making a class that provides access to each of the parts of the environment you care about
08:19:59 <mreh> @botsnack
08:20:02 <ptd> mreh: Tis dead
08:20:15 <edwardk> class HasFoo a where foo :: a -> Foo
08:20:19 <dankna> right, I already have such a class actually, I just have to repurpose it
08:20:32 <edwardk> then you can build composite environments by giving them the HasFoo property
08:20:39 <parcs> agkbill: i still don't follow
08:21:01 <edwardk> mreh: asks :: MonadReader e m => (e -> a) -> m a
08:22:09 <dankna> right, I already have the equivalent of your HasFoo actually, although I called it MonadFoo
08:23:23 <agkbill> parcs: Just after I installed dmenu I could launch it from Xmonad with "mod-P", same result as if I in xterm start with dmenu_run. I would like that key binding back.
08:24:36 <mreh> @instances MonadState
08:24:40 <mreh> oh i forgot
08:24:43 <mreh> haha
08:24:50 <parcs> agkbill: yes, you'll have to edit your config file
08:26:37 <agkbill> parcs: ok thank you. I have a line for dmenu, will try to understand what is say.
08:51:13 <JuanDaugherty> who is "Oleg"?
08:52:11 <JuanDaugherty> Oleg Kiselyov I guess
08:53:37 <Twey> When in doubt‚Ä¶
08:53:37 <silver> @where oleg
08:53:58 <silver> http://okmij.org/
08:54:05 <silver> @where+ oleg http://okmij.org/
08:54:55 <ski> silver : lambdabot is sleeping
08:55:04 <silver> oh
08:55:16 <JuanDaugherty> it didn't get restarted after it crashed a while back
08:57:52 <danharaj> how do ForeignPtr's and their finalizers work?
09:25:53 <gienah> Elbar: one way to fix it is: cd /var/lib/layman/haskell/dev-haskell/random; ebuild random-1.0.0.3.ebuild manifest
09:29:57 <Eduard_Munteanu> Is it wrong in the original ebuild?
09:31:20 <Elbar> gienah: saw it in #gentoo-haskell =)
09:33:00 <gienah> Eduard_Munteanu: it was a trivial manifest error (and my reply was to the wrong channel sorry)
09:38:19 * hackagebot hinotify 0.3.2 - Haskell binding to INotify  http://hackage.haskell.org/package/hinotify-0.3.2 (LennartKolmodin)
09:44:07 <ketil> Anybody more interested in updates on today's terror attacks than worried about frequenting dubiously named IRC channels can join in #terror.
09:46:56 <Eduard_Munteanu> Heh.
09:48:05 <maltem> ketil, are you in Oslo?
09:48:19 <ketil> No, just watching the news.
10:13:46 <monochrom> http://spikedmath.com/429.html  may apply to "how I feel when I learn haskell" too :)
10:15:09 <danharaj> Let's say I have a tree hierarchy of C structures in a library I'm binding, where the root of the tree holds references to its children so that when it is freed, its children are also freed.
10:16:42 <danharaj> I want to wrap this transparently in Haskell as pure values. My idea is to store the root as a foreignPtr, so that the GC can call the free function as a finalizer. In order to make sure it is not freed prematurely, when its children are still being used as Haskell values, what can I do?
10:17:22 <danharaj> I was thinking of storing children values with a copy of the root foreignPtr, so that it is referenced until all its children are garbage collectable. Would that work?
10:17:30 <kmc> sounds good to me
10:17:40 <danharaj> ah, ok lovely.
10:17:50 <kmc> but not the most efficient way, if there's a chance someone will want to peel off a subtree and work with it directly
10:18:02 <danharaj> kmc: You can't in this library.
10:18:10 <kmc> okay, no worries then
10:18:27 <cwraith> Just remember that just having a copy of the ForeignPtr in the data structure is not sufficient to prevent GC
10:18:44 <c_wraith> it needs to be touched
10:19:06 <danharaj> c_wraith: What do you mean?
10:19:07 <kmc> we all need to be touched sometime
10:19:13 <danharaj> word.
10:19:17 <kmc> i would put it as "it needs to be reachable"
10:19:55 <c_wraith> Well.  If I've learned anything from withForeignPtr, I've learned that just being in scope is not enough to keep it from being collected.
10:20:04 <c_wraith> The collector doesn't care about scopes, just whether it's used again.
10:20:16 <kmc> right
10:20:27 <kmc> ah, so (Ptr Subtree, ForeignPtr ParentTree) is not okay
10:20:28 <kmc> right
10:20:40 <danharaj> ok, I need to understand these subtleties then. :)
10:20:42 <kmc> because it may GC the second tuple component
10:21:30 <danharaj> ah, so what I should do is touch the pointer in every operation involving the first component.
10:21:37 <kmc> right
10:21:42 <kmc> well, and that's not quite enough
10:21:46 <danharaj> d'oh
10:21:54 <kmc> because it needs to not go away *during* the operation, either
10:22:10 <kmc> i think you want something like withForeignPtr parent (const doStuffWithChild)
10:22:11 <mauke> { subtree :: Ptr Subtree, tralala :: ForeignPtr ParentTree }
10:22:59 <danharaj> kmc: ah, so that will guarantee the ptr's lifetime until the end of the very last operation using these objects.
10:23:03 <monochrom> like this? "x <- set up a foreign prt ; y <- f x; {- (0) -}; m; n; return ()" it is possible to finalize x at point (0)
10:23:43 <c_wraith> all that withForeignPtr does that you'd care about is call touchForeignPtr at the end.
10:24:00 <kmc> danharaj, yeah, you have to not smuggle out the Ptr derived from the ForeignPtr, but that's not an issue here
10:24:02 <c_wraith> so you can just use touchForeignPtr directly, if it makes anything easier
10:24:21 <c_wraith> (it also exposes the Ptr, but if you're not using that, you can ignore it)
10:24:28 <kmc> yeah
10:24:42 <kmc> yeah, you need to touch at the *end* of each operation
10:24:50 <mauke> touchForeignPtr (tralala dingdingdong)
10:25:08 <monochrom> wherease "x <- set up a foreign prt ; y <- f x; {- (0) -}; m; n; touch x; return ()" keeps x around longer
10:25:18 <danharaj> mauke: Obscure joke, but haha.
10:25:20 <c_wraith> mauke seems to have a strange Gunther obsession
10:25:25 <kmc> hratsatsa (ia ripidapi (dilla barits tad dillan deh lando))
10:25:51 <kmc> mauke++
10:26:17 <kmc> danharaj, if I were writing this i'd probably try to use withForeignPtr unless not possible
10:26:25 <danharaj> Is it in good taste to export functions twice as a regular ccall and as a funptr?
10:26:41 <kmc> touchForeignPtr should be safe but it's still the less preferable API
10:26:56 <kmc> danharaj, where is the function actually defined?
10:27:30 <danharaj> kmc: In a c file. I'm hacking on someone else's bindings. They export the raw interface, I want to add FunPtr imports to use as finalizers.
10:27:47 <danharaj> Instead of using those wrappers that need to be explicitly managed.
10:28:02 <kmc> ah so it's ¬´foreign import ccall "foo" :: Int -> IO Int; foreign import ccall "&foo" :: FunPtr (Int -> IO Int)" ?
10:28:18 <kmc> seems legit
10:28:34 <danharaj> lovely.
10:28:40 <danharaj> You know, in a perverted way, this is fun.
10:28:43 <danharaj> Marrying C and Haskell.
10:28:49 <kmc> yes, i quite like writing FFI bindings
10:29:10 <kmc> it's like building a house by cutting down the trees yourself and making them into nice planks and then nailing them together etc
10:29:13 <mauke> http://danbooru.donmai.us/post/show/703959 you don't even know
10:29:16 <danharaj> are there any caveats about "&blah"? Like does it interact properly.
10:29:24 <DukeDave> Hi all, I'm about to start hacking on some libraries (the wxHaskell ones), and I'd like to run the my own development build along side the ones I cabal installed and GHC uses. What is a good approach to doing this?
10:29:29 <danharaj> er, properly with various esoteric function definition nuances in C?
10:29:43 <danharaj> DukeDave: cabal-dev
10:29:47 <dcoutts> DukeDave: just make sure the version numbers are distinct
10:30:23 <danharaj> cabal-dev creates a sandbox where the library and its dependencies are isolated from the global set of libraries.
10:30:44 <DukeDave> So I suppose first I need to do a cabal install which doesn't overwrite my existing version, and secondly I need to tell GHC which version to use?
10:30:53 <DukeDave> danharaj: Sounds useful :)
10:31:00 <danharaj> It's great!
10:31:11 <dcoutts> DukeDave: they will not overwrite each other if they're different versions
10:31:18 <danharaj> also, ++ for working on wxHaskell.
10:32:06 <DukeDave> dcoutts: Ah excellent, will GHC choose the newer version by default?
10:35:27 <monochrom> usually
10:37:31 <hsuh> join #cpp
10:38:55 <dcoutts> DukeDave: by default yes, but you can always say explicitly
10:40:29 <DukeDave> danharaj: So, I've read up on cabal-dev, and I'm a little confused. I can see that it will allow me to develop a library whilst keeping it out of my global GHC package list (a good thing), but then how do I use my development library with existing code I have?
10:42:27 <monochrom> get a tarball of your lib (cabal sdist), unpack it somewhere safe, install it normally (not using cabal-dev)
10:46:08 <DukeDave> monochrom: That makes sense, and presuming the version numbers are different my dev version and the latest release can co-habit?
10:47:57 <dcoutts> (in which case you didn't need to have it in a sandbox anyway)
10:48:54 <DukeDave> Gotcha, thanks for all the help
10:49:26 <DukeDave> I suppose my only minor question would be: Is there a way to tell GHC to use an older version of a lib by default?
10:50:04 <monochrom> co-existence is unsafe
10:50:24 <monochrom> "unsafe" as in unsafePerformIO
10:51:53 <DukeDave> monochrom: I presume this is why cabal-dev and Capri exist?
10:53:03 <monochrom> imperative way: "ghc-pkg hide". functional way: "ghc/ghci -hide-package"
10:53:23 <monochrom> yes, cabal-dev is there to avoid co-existence
10:55:03 <monochrom> pros like dcoutts know completely the logical consequences of co-existence and therefore how to use it without problems. like pros use unsafePerformIO just fine
10:55:37 <danharaj> what is a pro?
10:55:41 <danharaj> I only know the term 'wizard'
10:55:52 <monochrom> the meta-problem is when the pros become opinion leaders and tell you "I use unafePerformIO just fine, so can you"
10:56:24 <monochrom> "pro" is scientists' word for "wizard"
10:57:05 <danharaj> ah, you mean professor
10:57:06 <danharaj> gotcha
10:57:15 <monochrom> no, professionals
10:57:40 <dcoutts> DukeDave: you can use ghc-pkg hide, to hide the later versions, then ghc --make will use the latest visible version
11:00:54 <DukeDave> Hmm, okay, well dcoutts approach does sound deceptively easy.
11:00:54 <DukeDave> I'll be back here complaining that everything is broken shortly :D
11:02:07 <dcoutts> :-)
11:05:59 <danharaj> I think thinking about monads in terms of (>=>) is a lot more illuminating than in terms of >>=
11:07:13 <ski> well, at least the laws seem pretty obvious/sensible then, yes
11:07:34 <danharaj> yes, but also it elucidates a useful conceptual point about monad structures
11:07:36 <mokus> danharaj: personally, thinking about monads in terms of join always made the most sense to me
11:07:37 <ski> of course the formulation in `do'-syntax isn't really bad either
11:07:55 <monochrom> if you think of "a -> m b" as "like function from a to b but with effects". but sure, the Arrow people would agree with you
11:08:05 <danharaj> pff
11:08:22 <ski> .. and the categorical terrorists
11:08:40 <Eliel> categorical terrorists?
11:08:57 <danharaj> I remember someone characterizing arrows in terms of Category and something else, I forgot what, but I found it illuminating.
11:09:05 <ski> Eliel : an euphemism for "category theorist"
11:09:08 <danharaj> I think of (a -> m b) as a function with structured output
11:09:45 <danharaj> structure is more vague than effect :p
11:09:49 <ski> morphisms from `a' to `m b' are morphisms from `a' to `b' in the Kleisli category on `m'
11:09:49 <monochrom> the recipists disagree though
11:10:15 <danharaj> ski: yeah, that's the essence of monads I think. You're defining a new category inside Hask.
11:10:17 <Eliel> can I have a short explanation of recipists?
11:10:23 <danharaj> (monads in Haskell, at least)
11:10:30 * hackagebot xml 1.3.9 - A simple XML library.  http://hackage.haskell.org/package/xml-1.3.9 (IavorDiatchki)
11:10:37 <danharaj> well 'inside' Hask.
11:10:41 <monochrom> recipists say "m b is a recipe for the effect"
11:11:03 <ski> danharaj : not *inside* `Hask' :) this is not internal categories
11:11:30 <danharaj> ski: what's the term? I feel like I knew it at some point.
11:11:41 <ski> (you're defining a new category based on `Hask' (and on `m'))
11:11:52 <ski> i'm not sure if there's any specific accurate term
11:11:55 <danharaj> yeah, but the morphisms of the new category live inside Hask
11:12:08 <ski> (it's not a construct / concrete category over `Hask')
11:14:54 <ski> (if you have the category of monoids, and make the category of groups based on that, then the morphisms in `Group' are basically morphisms of `Monoid' with some extra stuff. in this case, `Group' is concrete over `Monoid' though, since you can make a forgetful functor from the former to the latter)
11:15:51 <danharaj> ski: hmm, at least there's a faithful functor from Hask to the Kleisli category of the monad though, right? I think there's one exception, the constant type constructor.
11:16:05 <danharaj> the map on functions being (\f -> return . f)
11:18:21 <ski> hm, i wonder whether it makes sense to think of that functor as forgetful
11:18:30 <ski> (it would forget that the morphism was pure)
11:18:53 <danharaj> does it have an adjoint?
11:18:56 <mokus> ski: that functor is a monad, so it is a composition of adjoint functors, one of which is forgetful
11:19:18 <ski> mokus : it can't be a monad since it's not an endo-functor
11:19:48 <mokus> nvm, thinking at 2 disconnected levels
11:19:50 <mokus> ignore me
11:19:51 <mokus> ;)
11:20:10 <danharaj> I suppose this functor lets you think of monads as an augmentation of the type system
11:20:46 <danharaj> since every function can be lifted faithfully, barring the trivial monad.
11:21:29 <dcoutts> @seen djahandarie
11:21:30 <preflex>  djahandarie was last seen on #haskell-blah 6 minutes and 38 seconds ago, saying: I think it's one of the more popular things though. I've definitely heard Tokyo people say it like that.
11:21:40 <dcoutts> djahandarie: ping
11:21:51 <danharaj> dcoutts: pong
11:21:56 * danharaj waits to see if someone is fooled
11:22:17 <dcoutts> mm, and are you the same person? :-)
11:22:41 * tgeeky hears a ping and issues an order to dive!dive!dive!
11:22:48 <shachaf> dcoutts: You're thinking of geheimdienst.
11:22:59 <danharaj> dcoutts: no, but we've been confused with in the past.
11:23:07 <dcoutts> danharaj: I bet :-)
11:25:01 <djahandarie> dcoutts, hello there
11:25:51 <copumpkin> why hallo thar
11:26:00 <dcoutts> djahandarie: there's a hackathon this weekend (#hacpdx) and several people working on the hackage-server
11:26:12 <djahandarie> Nice!
11:26:15 <dcoutts> djahandarie: you had a nice design, I forget if you had any html
11:26:20 <djahandarie> I do indeed.
11:26:39 <djahandarie> dcoutts, http://althack.org/hackage/package.html
11:26:49 <dcoutts> djahandarie: if you're free we'd like you help, if you're not free, then just whatever resources you've got in case someone else might like giving it a go
11:27:00 <dcoutts> djahandarie: ah ha
11:27:06 * dcoutts adds a link to that into the wiki
11:27:21 <dcoutts> djahandarie: feel free to join us in #hacpdx
11:30:38 <dbelange> > butt :: Butt
11:30:47 <mokus> ski, danharaj: seems to me that that construction you're talking about should be adjoint to the corresponding one for eilenberg moore categories
11:31:10 <mokus> but I lack the category zen to provide a strong argument for that
11:32:27 <ski> i was talking about danharaj's functor `ForgetPure : Hask >-> Kleisli m' -- sureely any adjoint to that (left or right) must go from `Kleisli m' to `Hask' ..
11:32:46 <ski> (or maybe you're including `Kleisli m' in `EilenbergMoore m' ?)
11:33:10 * ski knows very little on `EilenbergMoore'
11:34:04 <mokus> I was sort of thingking of them in a vague sense as "equivalent", but I know that's not really correct
11:34:37 <mokus> so the "other side" is from EilenbergMoore m -> Hask
11:34:57 <mokus> I have no idea how to formalize that intuition though
11:37:44 <dolio> ForgetPure has an obvious right adjoint.
11:38:10 <dolio> FPA -> B in the Kleisli category is A -> MB in the original category.
11:38:23 <dolio> So you need A -> MB ~= A -> GB for some G.
11:38:45 <dolio> So the obvious choice is that GB = MB.
11:39:53 <dolio> And for f : A ~> B = A -> MB, you need Gf : GA -> GB = MA -> MB, which you can get via extending with M.
11:40:46 <dolio> I don't know if it satisfies all the necessary coherence rules, but it's the clear choice.
11:41:18 <dolio> Gid = id comes from extend return = id, of course.
11:41:44 <clsmith> @hoogle a -> (a -> b) -> b
11:41:57 <ski> flip ($)
11:42:02 <clsmith> urm, apparently i did that wrong. and thanks :p
11:42:16 <ski> clsmith : lambdabot is sleeping atm
11:42:25 <clsmith> ah :)
11:42:29 <kmc> we've all got to fill in for her
11:42:33 <ion> with the fishes
11:42:42 <mokus> FP is the identity on objects, isn't it?  so FPA -> B = A -> B ~= A -> GB?
11:43:07 <mokus> where the left 2 -> are in kleisli M
11:43:14 <danharaj> speaking of categories
11:43:17 <Eliel> what happened to lambdabot?
11:43:17 <dolio> That's A -> B in the kleisli category, which is A -> MB in the underlying category.
11:43:44 <mokus> ah, i see
11:43:47 <ski> it's interesting how the left adjoint to the discrete reflexive graph over a set functor is the connected components functor
11:44:58 <Jetbeard> Eliel: [17:08:44] <JuanDaugherty> it didn't get restarted after it crashed a while back
11:47:01 <ski>   ConnectedComponents --| DiscreteReflexiveGraph --| UnderlyingSetOfReflexiveGraph --| FullReflexiveGraph
11:47:29 <c_wraith> data families are functions from a type to....  A value constructor?  I'm not fully clear on this
11:48:01 <kmc> c_wraith, functions from types to types
11:48:02 <ski> data families are functions from a type to a type
11:48:10 <kmc> it's ad-hoc polymorphism at the type level
11:48:10 <danharaj> open functions from types to types
11:48:21 <c_wraith> How does it differ from a type family, then?
11:48:32 <danharaj> c_wraith: injectivity guarantees
11:48:32 <kmc> well the term "type family" is used ambiguously
11:48:35 <ski> the resulting type is required to be a `data' or a `newtype'
11:48:37 <ski> iirc
11:48:44 <kmc> data families differ from type synonym families in that each instance introduces new value constructors
11:48:49 <kmc> as does an ordinary "data" or "newtype"
11:48:57 <kmc> so yes, it's guaranteed to be injective
11:49:10 <c_wraith> Hmm.  Maybe that's what I really want anyway.
11:49:16 <c_wraith> I need to poke at this a bit.
11:49:22 <ski> (so one could say that both data and type synonym families are type families)
11:53:29 <danharaj> oh boy, I have to start whipping out unsafePerformIO's :\
11:54:42 <monochrom> for FFI work?
11:56:28 <danharaj> yeah
11:56:36 <danharaj> Putting a pure interface on a horrifically stateful library.
11:57:51 <kmc> danharaj, how many layers are you using?
11:58:20 <danharaj> kmc: right now, at least two
11:58:26 <kmc> ok
11:58:49 <danharaj> the library is actually fairly referentially transparent in terms of actual values being thrown around
11:59:05 <c_wraith> Hmm.  So really, the only difference is that "data family" implies injectivity, where "type family" does not?
11:59:17 <c_wraith> (this is what my tests are suggesting)
11:59:22 <danharaj> c_wraith: yup.
11:59:31 <kmc> danharaj, cool
11:59:41 <kmc> i was very thankful for the design of udis86 when building my wrappers...
11:59:56 <danharaj> I'm not thankful for the design of freetype2
12:00:01 <kmc> no global state, all state stored in a struct you manage memory of
12:00:04 <danharaj> object oriented programming in C? Gross.
12:00:37 <kmc> of course these are nice features in C as well as for making it Haskellizable
12:00:39 <kmc> danharaj, ;P
12:01:19 <kmc> yes, somehow OOP evangelists have taken credit for the much older idea of bundling some data and related operations
12:02:02 <danharaj> oi, this is annoying
12:02:14 <shachaf> kmc: It's OK -- FP evangelists have taken credit for the idea of operations.
12:02:19 <kmc> :D
12:02:30 <danharaj> The functions for finalizing foreignPtr's is of type (a -> IO ()) instead of (Ptr a -> IO ())
12:02:42 <danharaj> So I guess I do have to wrap some haskell funPtr's
12:02:57 <c_wraith> also, for some reason, data family declarations and type family declarations have different optional syntax.  Whatever.
12:03:08 <kmc> how so c_wraith?
12:03:21 <pnken> hey, can someone help me: http://pastebin.com/hF9GgJtx
12:03:24 <shachaf> danharaj: So much fun, you'll think you're writing ML.
12:03:24 <mauke> The paste hF9GgJtx has been copied to http://hpaste.org/49367
12:03:31 <pnken> I keep getting "parse error " on the "where"
12:03:34 <pnken> I dont get why
12:03:54 <c_wraith> "data family Foo :: * -> *" means Foo has kind * -> *.  The same is not true of "type family Foo :: * -> *"
12:03:55 <mauke> pnken: why do you have multiple 'where'?
12:03:58 <ski> maukebot++
12:04:05 <kmc> pnken, you can only have one 'where'
12:04:08 <kmc> it can contain multiple decls
12:04:13 <pnken> I thought I needed one for each constan
12:04:17 <pnken> *constant
12:04:18 <kmc> c_wraith, really?
12:04:47 <c_wraith> kmc: when I tried the latter, I got all kind of compiler error messages about "1 argument found, 0 expected"
12:04:55 <ptd> pnken: try http://hpaste.org/49368
12:04:56 <c_wraith> in my instance declarations, that is
12:04:57 <pnken> hm ok, I deleted the two lower wheres, now I get a parse error with '='
12:05:28 <danharaj> so if I'm using a haskell fun ptr as a finalizer, when should I call freeHaskellFunPtr?
12:05:30 <Saizan> c_wraith: it's subtler than that, with .. family Foo (x :: k1) :: k2, means Foo has a single index of kind k1 and produces a type of kind k2
12:05:40 <kmc> danharaj, after all the finalizers are done
12:05:52 <pnken> pt : I keep getting a prase error, for '=' this time though
12:05:52 <kmc> i think you need to put a finalizer in your finalizer so you can free while you free
12:06:00 <pnken> ptd : I keep getting a prase error, for '=' this time though
12:06:05 <kmc> danharaj, alternatively "never"
12:06:10 <danharaj> kmc: yeah I'll go with never.
12:06:25 <danharaj> Xzibitz never did explain the semantics of his nested constructions.
12:06:34 <kmc> this is Haskell, the standards for memory usage are not high ;P
12:07:11 <kmc> c_wraith, well, you can't say "data family Foo" or "type family Foo" can you? because it needs at least one parameter
12:07:14 <danharaj> Haskell beats Java in memory usage on a lot of the shootout benchmarks, for what it's worth.
12:07:17 <danharaj> (Spoilers it's worth nothing)
12:07:19 <ptd> pnken: put the error in an hpaste
12:07:20 <adnam> kmc: how ambiguous of you
12:07:56 <kmc> hmm or not?
12:08:26 <kmc> i could have sworn that they made a distinction between the number of parameters (those which can vary ad-hoc) and the actual kind
12:08:36 <pnken> ptd : http://pastebin.com/K5zyPiAz
12:08:38 <mauke> The paste K5zyPiAz has been copied to http://hpaste.org/49370
12:08:42 <kmc> but now I see I can do "data Family Foo :: * -> *; data instance Foo Int = Bar Char"
12:08:47 <kmc> did this change in GHC 7?
12:09:37 <c_wraith> kmc, no, I'm using that syntax in GHC 6.12
12:09:50 <Saizan> for data it might not matter
12:10:17 * ski annotated pnken's paste with "better" at <http://hpaste.org/49367#49369>
12:10:25 <ptd> pnken: Can you paste all of WE1.hs as well?
12:10:32 <pnken> sure
12:11:09 <pnken> http://pastebin.com/77fvWkVS
12:11:11 <mauke> The paste 77fvWkVS has been copied to http://hpaste.org/49371
12:11:15 <pnken> the problem starts at Line 14
12:11:22 <pnken> everthing else works fine
12:11:32 <mauke> pnken: broken indentation
12:11:46 <pnken> what do you mean exactly, where? mauke
12:11:50 <ptd> you have to put all your where clauses on the same line
12:11:57 <mauke> ptd: what
12:12:44 <Saizan> the main point of distinguishing indices for synonym families is that they are injective in the parameters (once the indices are fixed) but data families are injective anyway
12:12:58 <ptd> pnken: bad explanation, all ".. = .." parts must be on the same line
12:13:12 <ski> pnken : see the annotation at <http://hpaste.org/49371> for one way to indent the clauses in `where' properly
12:13:59 <ski> pnken : what ptd is attempting to express is that all the clauses inside `where' must *start* at the same column
12:14:10 <mauke> ski: I doubt that
12:14:15 <ptd> ski: thank you
12:14:21 <pnken> http://pastebin.com/ktPCNCzU
12:14:23 <pnken> like this>
12:14:24 <ski> mauke : ok, s/is/ought to/, then :)
12:14:24 <pnken> _
12:14:26 <mauke> The paste ktPCNCzU has been copied to http://hpaste.org/49373
12:14:36 <mauke> pnken: no
12:14:45 <mauke> pnken: did you see ski's link?
12:14:58 <pnken> it directed me to the  hpaste.org
12:15:00 <mauke> ski: where did you get my link from anyway?
12:15:09 <mauke> pnken: yes. did you look at it?
12:15:10 <pnken> It doesn't show any code
12:15:14 <mauke> it does here
12:15:16 <ski> mauke : oh, which link ?
12:15:22 <mauke> http://hpaste.org/49371
12:15:24 <ski> s/oh/uh/
12:15:51 <ski> mauke : er, sorry, i meant to say <http://hpaste.org/49367#49369> there
12:15:57 <pnken> ahh
12:15:58 <pnken> now I see
12:15:59 <pnken> thanks so much
12:16:03 <ski> (i must have gotten clipboards confused)
12:16:23 <mauke> well, you got my annotation :-)
12:17:07 <ski> mauke : oh, well that annotation wasn't there when i managed to get a copy of that link ..
12:17:18 * ski just saw it now, on refresh
12:17:32 <ski> pnken : so sorry, i meant <http://hpaste.org/49367#49369> before
12:18:10 <pnken> I changed it, it seems to work now! But I got a different error. I'll try to figure it out first
12:18:28 <ptd> pnken: That code has type errors in it
12:18:50 <pnken> where?
12:19:26 <ptd> pnken: You're dividing Ints
12:19:42 <pnken> argh
12:19:45 <pnken> thats why its not working
12:19:48 <ptd> No instance for (Fractional Int)
12:19:49 <pnken> I need doubles
12:20:09 <ptd> means Ints don't support fractional operations (e.g. divide)
12:20:32 <ptd> pnken: Try removing the type signature
12:20:42 * hackagebot text 0.11.1.5 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-0.11.1.5 (BryanOSullivan)
12:20:44 <ptd> haskell should be able to infer the types anyway
12:20:49 <pnken> huh
12:20:53 <pnken> it works when I remove the signature
12:21:03 <pnken> It does not work when I change the signature to Double
12:21:05 <pnken> Why?
12:21:11 <ptd> do ":t dayName"
12:21:35 <ptd> Because doubles support "/"
12:22:05 <ptd> for Integrals, you need the div function
12:22:23 <pnken> What signature would be correct ?
12:22:50 <mauke> ask ghci what it thinks
12:23:17 <ptd> pnken: I assume you a trying to create a function that turns (day, month, year) into dayName
12:23:31 <pnken> yes
12:23:36 <ptd> pnken: Your function needs to return an integral type
12:23:51 <pnken> Integral?
12:23:59 <ptd> pnken: div :: Integral a => a -> a -> a
12:24:12 <ptd> Integral means a type that support whole numbers only
12:24:29 <pnken> ah
12:24:34 <pnken> that makes sense
12:24:45 <ptd> The main examples are Int (for numbers less than 2^30) and Integer (arbitrarily big)
12:25:00 <ptd> replace all "/" with `div`
12:25:14 <pnken> so "/" doesnt work with int or Integer?
12:25:21 <ptd> the "`" turn div into an infix integer
12:25:43 * hackagebot mwc-random 0.9.0.0 - Fast, high quality pseudo random number generation  http://hackage.haskell.org/package/mwc-random-0.9.0.0 (BryanOSullivan)
12:25:45 * hackagebot statistics 0.9.0.0 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.9.0.0 (BryanOSullivan)
12:25:51 <ptd> (/) :: Fractional a => a -> a -> a
12:26:21 <ptd> "/" only supports Fractional types
12:26:22 <ski> `div' is when you want to get a quotient and a remainder
12:26:48 <ptd> pnken: Do you understand the "`div`" and "(/)" syntax
12:26:52 <kyagrd> Some TH experts? the TH document is outdated :(
12:26:55 <pnken> so If I assign Integral and Fractional to a function It only can use "/" with whole numbers?
12:26:57 <fazzone> Is there some easier way to get \(a,b) -> first a . second b ?
12:27:04 <ski> typically `a / b * b = a' should hold (though only approximatively for floating-point numbers)
12:27:14 <kyagrd> http://haskell.org/ghc/docs/7.0-latest/html/libraries/template-haskell-2.5.0.0/Language-Haskell-TH.html in here
12:27:16 <pnken> ptd : I think so
12:27:37 <kyagrd> let v = mkName "T" in [| data $v = $v |] -- parse error (verbatim from document)
12:27:43 <ski> fazzone : is `uncurry (.) . (first *** second)' easier ?
12:27:44 <ptd> The backticks "`" turn functions into infix operators
12:27:47 <kyagrd> let v = mkName "T" in [d| data $v = $v |] -- parse error (tried this too)
12:27:56 <ptd> e.g. 3 `div` 3 == 1
12:28:12 <ptd> The brackets do the inverse
12:28:23 <ski> ho hum ..
12:28:27 <ptd> e.g. (/) 3 3 = 1
12:28:29 <kyagrd> I thought there was a way of using names inside TH brackets, and looked up the TH doc but no use :(
12:28:44 <fazzone> I mean, why can't (a,b) be an instance of Applicative?  Then wouldn't <*> do that?
12:28:55 <mauke> fazzone: kind error
12:29:04 <pnken> so div 4 3 is 1, but (/) 4 3 is > 1
12:29:15 <pnken> because it can use Doubles
12:29:15 <kmc> kyagrd, there are no pattern splices; this looks similar
12:29:19 <pnken> and div only Integer
12:29:25 <ptd> pnken: Yes, that's why is a distinction
12:29:26 <kmc> GHC's TH implementation is really incomplete
12:29:34 <ski> pnken : `(/)' can give rational number as well ..
12:29:38 <danharaj> is TH even a language spec?
12:29:55 <kyagrd> danharaj: well GHC extension
12:30:01 <kmc> well, there's a paper on it
12:30:07 <kmc> which is not fully implemented in GHC
12:30:15 <ski> > (/) 4 6 :: Rational
12:30:20 <ski> 2 :% 3
12:30:39 <ski> (or maybe it says `2 % 3', i don't recall)
12:30:47 <pnken> so for my dayName function I want it to only be for Integers but be able to calculate with (/)
12:30:48 <ptd> ski: It's %
12:30:53 <monochrom> it's 2 % 3. the constructor is unexported. obvious reason
12:30:57 <danharaj> kmc: ah.
12:31:29 <ptd> pnken: yes, so you need truncating division (div)
12:31:37 <ski> (it could conceivably say `:%' anyway .. though it probably wouldn't be a good idea, no)
12:31:48 <danharaj> how can I safely unsafePerformIO an application of a wrapper to turn a haskell function into a FunPtr?
12:31:53 <danharaj> do I just do it at the top level?
12:32:07 * ski thinks ptd should say something like "flooring division" instead
12:32:41 * ptd thinks ski is better at expressing himself than he is
12:32:45 <pnken> but if I assign Integral and Fractional to the function, it will only take whole numbers and be able to use "/"?
12:32:54 <ski> no
12:33:04 <ptd> pnken: There is no type that is both Integral and Fractional
12:33:21 <ptd> Integral types only support whole numbers
12:33:21 <monochrom> unless you create one
12:33:34 <danharaj> (spoilers don't create one)
12:33:43 <pnken> I dont understand the signature GHCi gives me for the function then
12:33:44 <ptd> Fractional types support fractional numbers as well
12:33:54 <ptd> pnken: Show me then
12:34:22 <monochrom> ghci doesn't know that Integral and Fractional are fairly incompatible. it's just a computer
12:34:28 * ski wonders whether `div 2 (1 :+ 1)' works
12:35:14 <ski> (no)
12:35:20 <monochrom> 1 :+ 1 :: RealFloat a => Complex a
12:35:25 <pnken> ptd : http://pastebin.com/D8wdXus4
12:35:28 <mauke> The paste D8wdXus4 has been copied to http://hpaste.org/49374
12:35:47 <mauke> pnken: yeah, that's because your code is wrong
12:35:58 <monochrom> "Fractional ((a -> a -> a) -> a1 -> t)" is very disturbed
12:36:09 <c_wraith> holy crap, I just figured out how to use GeneralizedNewtypeDeriving with MPTCs.
12:36:12 <mauke> monochrom: comes from x mod y
12:36:19 <monochrom> nice
12:36:25 <ski> c_wraith : `StandaloneDeriving' ?
12:36:28 <pnken> http://pastebin.com/RUV6XesY
12:36:30 <pnken> here is the code
12:36:33 <mauke> The paste RUV6XesY has been copied to http://hpaste.org/49375
12:36:52 <mauke> pnken: why haven't you fixed the "mod" part?
12:36:59 <c_wraith> ski: no, just put the typeclass parameter that you want to derive *last* in the definition of the typeclass.  (StandaloneDeriving didn't work for me in this case)
12:37:20 <ski> pnken : use "`mod`", not "mod", as i showed in my earlier annotation
12:37:27 <pnken> ohh
12:37:44 <chrisdone> :t let a = undefined in a :: a ~> b
12:37:53 <ptd> ski: No wonder it's so disturbed
12:37:54 <monochrom> lambdabot is away
12:37:56 <ski> pnken : i.e. either "(a + x + 31 * m / 12) `mod` 7" or "mod (a + x + 31 * m / 12) 7"
12:37:58 <chrisdone> Œª> :t let a = undefined in a :: a ~> b
12:37:58 <chrisdone> let a = undefined in a :: a ~> b :: (~>) a b
12:38:04 <chrisdone> what is (~>) and where is it defined?
12:38:15 <pnken> ok, now the signature looks much smaller
12:38:32 <monochrom> also lambdabot is probably still ghc 6.12 and so won't say "x ~ y"
12:38:47 <ptd> pnken: show me the code
12:38:47 <shachaf> chrisdone: It's a type variable.
12:38:56 <shachaf> chrisdone: Doesn't start with :, after all. :-)
12:38:58 <djahandarie> chrisdone, you should add a captcha or secret question to hpaste I think
12:39:05 <chrisdone> anything starting with ~ is a type variable?
12:39:19 <shachaf> chrisdone: Any infix thing not starting with a : is a variable.
12:39:19 <mauke> chrisdone: what are a and b and where are they defined?
12:39:26 <shachaf> What mauke said.
12:39:39 <monochrom> heh
12:39:40 <chrisdone> oh, ok
12:39:51 <shachaf> a :: forall (~>) a b. (~>) a b
12:40:04 * ski quietly replaces mauke's "defined" with a "bound"
12:40:06 <pnken> ptd : dayName :: (Integral a, Fractional a) => (a,a,a)->a
12:40:12 <monochrom> people used to say "arrow a b" for "a ~> b"
12:40:20 <ptd> pnken: That's the type you want
12:40:33 <ptd> pnken: Well almost
12:40:45 <pnken> but I dont get how it can be Integral and Fractional
12:40:45 * hackagebot oneOfN 0.1 - Anonymous coproduct type  http://hackage.haskell.org/package/oneOfN-0.1 (JamesCook)
12:40:47 <ski> pnken : except that you don't want to mix `Integral' and `Fractional' that way
12:40:49 <byorgey> there are no standard types which are instances of both Integral and Fractional.
12:41:01 <monochrom> no type in the stdlib satisfies both Integral and Fractional at the same time
12:41:10 <ptd> pnken: Nothing can be both Integral and Fractional
12:41:15 <ski> pnken : presumably you want to replace all uses of "/" by "`div`"
12:41:16 <ptd> you want
12:41:40 <ptd> dayName :: (Integral a) => (a,a,a)->a
12:41:50 <pnken> but how does it still work? Why does it say that in the signature?
12:41:50 <monochrom> however, computer can't be sure that it is dead impossible, so its type inference still emits "(Integral a, Fractional a)" just in case it is possible
12:41:57 <pnken> ah
12:42:18 <ski> the use of `(/)' makes `Fractional' appear in the inferred type signature
12:42:35 <monochrom> if you use an Integral method, you get Integral. if you use a Fractional method, you get Fractional. if you use both, you get both. sounds self-evident
12:42:43 <ptd> because (/)'s arguments have to be fractional
12:43:08 <monochrom> computer is saying "it is not my problem"
12:43:24 <pnken> Ok, I changed all the "/" to "`div`" and now it only says (Integral a)
12:43:47 <monochrom> then again, computer should say that always.
12:43:52 <ptd> pnken: The big question is, does it work?
12:44:08 <pnken> yup
12:44:12 <pnken> well, it seems to
12:44:37 <ptd> pnken: What's the mapping of numbers to names?
12:44:54 <pnken> I haven't heard of mapping yet
12:44:58 <pnken> I think thats next week
12:45:05 <ptd> Is it 0 -> "Sunday", 1 -> "Monday"?
12:45:10 <pnken> yep
12:45:23 <scm> !mex
12:45:32 <pnken> It said 5 for today's date, and today is friday. So I think it works
12:45:49 <kmc> :t (words "sun mon tue wed thu fri sat" !!)
12:45:49 <ptd> pnken: You need a list of days in order starting at Sunday
12:46:12 <mauke>  Int -> String
12:46:34 * monochrom has a cunning plan!
12:47:01 <shachaf> mauke++ for including the space at the beginning of the line.
12:47:25 <ptd> (\x -> words "sun mon tue wed thu fri sat" !! (dayName x))
12:51:18 <benmachine> the field of integers mod p could reasonably be Integral and Fractional :P
12:51:41 <benmachine> (presumably with div = (/)
12:51:43 <benmachine> )
12:51:54 <benmachine> ...which gives mod = const (const 0) >_>
12:52:09 <monochrom> nice
12:56:07 <nomeata> I am using Text.Parsec.ByteString to parse something from a strict bytestring. with the idiomatic { str <- many1 (noneOf ", ") ; return (BS.pack str } I am creating a new copy of the data, although I could just have a bytestring pointing into the same memory as the original byte string
12:56:21 <nomeata> Is that possible with Parsec?
12:57:30 <nomeata> The next best idea I came up with is "getByteString p = do { input1 <- getInput; p; input2 <- getInput; return (BS.take (BS.length input1 - BS.length input2) input1)", assuming p is something like "many1".
12:58:38 <benmachine> nomeata: I would personally worry that if I did that I'd hold on to the whole bytestring, instead of just the bit you parsed
12:58:42 <benmachine> sometimes you *want* to copy
12:59:22 <nomeata> benmachine: right. but sometimes I don‚Äôt :-)
12:59:36 <benmachine> mm, fair enough
13:01:24 <monochrom> http://www.vex.net/~trebla/haskell/testbed.cgi :)
13:01:40 <monochrom> chrisdone would be proud!
13:13:50 <tommd> preflex: seen tibbe
13:13:51 <preflex>  tibbe was last seen on #ghc 1 day, 5 hours, 40 minutes and 52 seconds ago, saying: there clearly are conventions and assumptions on what the names of things are, they're just not spelled out
13:18:49 <joe6> how do I add an instance for Random Word8? I can get a random Int and convert it with fromIntegral.
13:19:10 <joe6> But just curious adding an instance for Random Word8
13:19:15 <joe6> http://pastebin.com/QqFTQ9Cz
13:19:17 <mauke> The paste QqFTQ9Cz has been copied to http://hpaste.org/49377
13:22:35 <monochrom> by implementing the methods of Random
13:25:33 <platzhirsch1> Do you think Haskell would make a fitting language to write a course scheduler? I am thinking of, that functional programming languages make it easy to check constraints quite easy. I am asking, because I am thinking about Erlang as an alternative. Of course this is paradox to ask in the #haskell channel, but maybe someone has an opinion?
13:25:58 <joe6> monochrom: are there a lot of methods for Random?
13:26:22 <sm__> platzhirsch1: certainly, an excellent choice
13:27:41 <monochrom> I think only a few
13:27:57 <joe6> ok, thanks.
13:28:14 <platzhirsch1> sm__: I am just unsure, since I've read some nasty things about Haskell and I/O on Haskell vs. Erlang discussion - whatsoever they mean after all
13:28:48 <monochrom> . o O ( how much I/O do you need for a scheduler? )
13:28:58 <joe6> platzhirsch1: it will make you a better programmer, at the very least. dive in, and, you will not regret it.
13:29:12 <arw_> if you really only want to write the scheduler, use haskell, no question about it.
13:29:29 <platzhirsch1> joe6: that's true, after all I just want to learn - best resolution would be to rewrite in the end in the other language ;)
13:30:41 <arw_> but often you need to interface with whatever external system somebody make you use.
13:31:29 <arw_> something like "and get the course list from the xy depts java system" or similar. that often limits the decisions you can make in that regard.
13:36:51 <sheeple> is running wxHaskell using code in a persistent ghci session still problematic? last time I tried to use it I had to restart ghci everytime after running some wx code because of some wx state not being reset
13:36:56 <sheeple> and that what quite annoying
13:37:52 <sheeple> that was two years ago
13:39:15 <cheater_> i'd suggest just try =)
13:40:39 <bos31337> anyone here speak the crazy moon language of enumerator/iteratee world?
13:41:12 <djahandarie> No, but if you ever do, please write a rosetta stone :p
13:46:58 * hackagebot property-list 0.1 - XML property list parser  http://hackage.haskell.org/package/property-list-0.1 (JamesCook)
13:48:59 * hackagebot property-list 0.1.0.1 - XML property list parser  http://hackage.haskell.org/package/property-list-0.1.0.1 (JamesCook)
13:52:59 * hackagebot property-list 0.1.0.2 - Apple property list parser  http://hackage.haskell.org/package/property-list-0.1.0.2 (JamesCook)
13:53:10 <mokus> in case anyone is wondering, those 3 versions are identical except for metadata... that's what i get for trying to rush things out the door on a friday...
13:53:33 <benmachine> :)
13:54:02 <mokus> I just couldn't let it stand though, with the single biggest new feature not even mentioned in the cabal description
13:56:21 <danharaj> Is there a way to specify that I want a call to unsafePerformIO to be done atomically?
13:56:36 <benmachine> danharaj: atomically in what sense
13:56:50 <danharaj> benMachine: when the action is performed, no other IO actions can be interleaved.
13:56:57 <benmachine> oh
13:57:04 <benmachine> um, that doesn't sound terribly likely
13:57:10 <danharaj> I need this to guarantee referential transparency in a wrapper :\
13:57:26 <benmachine> if you have *specific* other IO actions to prevent, you could use an MVar lock?
13:58:01 <danharaj> oh, true.
13:58:10 <danharaj> I haven't used MVar's before, now's the time to learn.
13:58:40 <benmachine> MVars are pretty neat
13:59:35 <danharaj> hmm I have to think about this.
14:04:41 <joe6> is there a better way of writing this: http://pastebin.com/6kmEdz1r
14:04:44 <mauke> The paste 6kmEdz1r has been copied to http://hpaste.org/49382
14:04:49 <joe6> preferably, without the head.
14:05:51 <davidt_> Hi all. I am trying to get cabal to use different compiler flags for different modules. Can this be done? The Cabal userguide says you should instead use an in source OPTIONS_* pragma.
14:06:37 <Saizan> i think there's no other way
14:06:47 <joe6> Saizan, ok, thanks
14:06:59 <danharaj> So right now I have operations that work on foreignPtrs, fiddling some state to create a value, but restoring the state when they are done, while also their values are referentially transparent. So I wrap them in unsafePerformIO. I need to make sure foreignPtr fiddling isn't interleaved between two unsafe calls. How should I handle this locking?
14:07:47 <Saizan> joe6: i was responding to davidt_
14:08:01 <dcoutts> davidt_: right, if you need different options for different files then use OPTIONS_GHC
14:08:18 * Codex_ finally figured out how pullbacks work. (== can do pullbacks for continuous spaces)
14:08:31 <davidt_> hmmm. OK thanks. Not ideal for what I need but can't change that.
14:09:11 <danharaj> should I wrap the ForeignPtr in an MVar when I create it, and use takeMVar and putMVar when I unsafePerformIO?
14:09:34 <joe6> Saizan, oh, ok.
14:11:43 <nomeata> It is late here, maybe someone can help: Given "quickDifference l1 l2 = filter (`S.notMember` s) l1 where s = S.fromList l2", under what condition can x be in both "a `quickDifference` b" and in "b `quickDifference` a"?
14:12:58 <smarter> joe6: why not just: http://hpaste.org/49383 ?
14:13:49 <nomeata> (hmm, it seems none, but I still seem to get elements. maybe they just look the same after pretty-printing...)
14:14:39 <fxr> is there a way to get list of all threads?
14:14:59 <benmachine> fxr: not unless you build one as you spawn them
14:15:00 <Saizan> fxr: no
14:16:03 <fxr> so, what is the best way to manage my threads? I wanna list them, and kill them when I want.
14:16:26 <fxr> btw, these threads are handling http requests
14:16:27 <benmachine> can anyone comment on c2hs and bindings-dsl, do they work together, is either better at particular things?
14:16:53 <benmachine> fxr: how would you know which thread was which?
14:17:34 <fxr> benmachine: each thread handles a connection with keep-alive, so I can use the remote address for the key.
14:18:02 <benmachine> fxr: a Data.Map in an MVar, perhaps?
14:18:50 <fxr> benmachine: thanks, let's try...
14:40:22 <camio> I'm searching for a concept where f has a property such that f a always agrees with f b where f b is defined and when b < a. That is, for increasing values of a, f a becomes more defined. Anyone have any ideas?
14:41:03 <dylukes> @quote shiny
14:41:05 <ion> ...huh?
14:41:16 <dylukes> @vixen hey there.
14:41:22 <ion> dylukes: lambdabot was in a car crash and is in a hospital.
14:41:24 <dylukes> lambdabot netsplit?
14:41:27 <dylukes> :<
14:41:50 <mercury^> camio: f is a function defined on what?
14:42:14 <camio> For example (undefined,12) is less defined, but agrees with (13,12).
14:42:41 <ion> agreesWith :: a -> a -> Bool?
14:43:01 <camio> ion: yes
14:43:35 <camio> mercury^: f is a function between a totally ordered set and another type that has this "less and more defined" quality.
14:43:38 <mercury^> camio: I don't know what exactly you are trying to achieve, but my guess is that you don't want a function, but just a single value that makes use of lazy evaluation.
14:43:54 <ion> I don‚Äôt think i‚Äôm familiar with the concept of arbitrary values ‚Äúagreeing‚Äù with each other.
14:44:21 <benmachine> ion: it just means that if both are defined then they're the same
14:44:39 <camio> mercury^: Rather, I'm looking for an abstract model of a single value that makes use of lazy evaluation.
14:45:06 <benmachine> camio: so the idea is that passing f larger parameter values is forcing the computation
14:45:11 <benmachine> that sounds odd
14:45:28 <joe6> smarter, that is way cooler than what I had.
14:45:29 <camio> benmachine: No "computation" is happening here. Just math.
14:45:33 <mercury^> camio: that's too fuzzy for anyone to help you out, I am afraid.
14:45:34 <joe6> smarter: thanks a lot.
14:45:37 <smarter> joe6: and simpler :p
14:45:41 <benmachine> camio: analogous to
14:46:03 <joe6> smarter: yes, very simpler.
14:46:07 <joe6> smarter, thanks a lot.
14:46:15 <smarter> you're welcome ;)
14:46:44 <djahandarie> @tell mm_freak Poke me when you're around.
14:46:47 <djahandarie> Oh, wait.
14:46:59 <ion> @tell lambdabot Poke us when you‚Äôre around.
14:47:00 <benmachine> preflex: tell djahandarie you're more reliable than lambdabot
14:47:00 <preflex>  Consider it noted.
14:47:04 <mercury^> camio: but probably "increasing net" is the term you are after.
14:47:10 <camio> benmachine: yeah, something like that.
14:47:13 <djahandarie> preflex, tell mm_freak Poke me when you're around.
14:47:14 <preflex>  Consider it noted.
14:47:15 <preflex>  djahandarie: you have 1 new message. '/msg preflex messages' to read it.
14:47:24 <benmachine> I wonder what it is :O
14:48:11 <benmachine> camio: I'm not exactly sure what your question is but I suspect if I knew I wouldn't know the answer anyway :P
14:48:27 <camio> :)
14:49:39 <camio> mercury^: Hey, I think "increasing net" is actually the ticket.
14:52:11 <camio> How exciting. mercury^, how did you know about nets?
14:55:41 <joe6> smarter, I am still bowled over by your simple solution. How long have you been using haskell?
14:56:02 <joe6> smarter, are you a hard core programmer/
14:56:07 <smarter> far from it :p
14:56:07 <joe6> s,/,?,
14:56:57 <joe6> smarter, you must have the read the article about the evolution of a haskell programmer, and yours would rate the best in that series.
14:57:02 <smarter> I've known about Haskell for more than a year, but only started to study it extensively a few months ago
14:57:12 <smarter> joe6: ha, I remember that one yes ;)
14:57:39 <smarter> joe6: at least you didn't try to use catamorphism :p
14:58:07 <joe6> because i do not know what that is.
14:59:01 <smarter> a fold that works on every data type (but the data type has to be in a special form)
14:59:16 <benmachine> umm
14:59:23 <benmachine> every data type has its own catamorphism, I think
15:00:12 <Evious> What did smarter find?
15:00:44 <smarter> I just simplified http://hpaste.org/49382 in http://hpaste.org/49383
15:01:26 <smarter> I'm more amazed by the former and how someone could come up with that ;)
15:01:31 <Evious> Oh damn.
15:02:05 <smarter> benmachine: right, I mean the "cata" function on http://www.haskell.org/haskellwiki/Catamorphisms
15:02:08 <Evious> Wow.
15:02:54 <copumpkin> lol
15:04:22 <benmachine> smarter: I don't know anything about algebras in general
15:04:31 <benmachine> so you've lost me I'm afraid :P
15:05:05 <cgroza> Hello, I am learning haskell, and currently, I have a program that reads a file, turns it into upper case letters and writes it in an output file. If i run the program with runghc the program works, but if I compile it with ghc, it never ends, just sits there.
15:06:36 <cgroza> what could possibly cause this?
15:07:35 <clsmith> previousLed n = cycle [1..10] !! (n+8) -- shorter, maybe not so simple
15:08:37 <copumpkin> not the same answer
15:08:46 <copumpkin> not sure which is the desired behavior though
15:08:59 <ion> cgroza: Let me look up your source code from the crystal ball, a moment.
15:09:05 <smarter> don't you mean (n+9) ?
15:09:19 <copumpkin> still not the same
15:09:20 <benmachine> ion: don't be sarky :P
15:09:53 <smarter> oh, ignore what I just said
15:10:36 <benmachine> ignore what I'm about to say
15:10:39 <ion> cgroza: See the first link in the topic.
15:11:25 <ion> Ignore this message.
15:12:24 * benmachine pokes Cale
15:16:16 <cgroza> Sorry guys, I was away for a moment.
15:18:21 <cgroza> http://hpaste.org/49385
15:18:27 <cgroza> ion: there is my code.
15:18:32 <cgroza> sorry for the delay.
15:19:56 <benmachine> cgroza: I can't see any reason why that would loop. I'd put debugging print statements to stderr to find out how far it got before doing so
15:20:13 * hackagebot system-filepath 0.3.1 - High-level, byte-based file and directory path manipulations  http://hackage.haskell.org/package/system-filepath-0.3.1 (JohnMillikin)
15:21:52 <cgroza> benmachine: I tried to. the prints don't show up.
15:22:13 <benmachine> cgroza: are the files even opened successfully?
15:22:23 <benmachine> if you get no prints showing up you're not putting enough it :P
15:22:25 <benmachine> *in
15:22:58 <cgroza> benmachine: I never check if they are open successfuly.
15:23:23 <cgroza> benmachine: all i know is that it works when interpreted.
15:23:47 <benmachine> cgroza: if that's all you know, you'll need to find out more :)
15:24:14 <cgroza> benmachine: I took it from a book. I am just learning now....
15:25:12 <djahandarie> Does   g :: (Monad m) => m a -> (a -> m b) -> m a;  g m f = m >>= \x -> f x >> m   exist somewhere?
15:25:44 <benmachine> djahandarie: I doubt it, that doesn't seem like a very common pattern
15:26:19 <benmachine> cgroza: it works for me
15:26:25 <mauke> :t liftM2 (>>) ?f return
15:27:15 <cgroza> benmachine: the same code?
15:27:20 <djahandarie> mauke, huh? Sure that's right?
15:27:32 <benmachine> cgroza: yes
15:27:48 <mauke> djahandarie: define "right"
15:28:07 <djahandarie> It doesn't have the same type.
15:28:11 <benmachine> it looks like djahandarie's code 'runs' m twice
15:28:20 <mauke> it does
15:28:27 <Eduard_Munteanu> cgroza: btw, Romanian?
15:28:33 <mauke> djahandarie: as what?
15:28:55 <benmachine> mauke: wait, are you even answering a question
15:29:41 <mauke> liftM2 (>>) ?f return :: (Monad m, ?f::b -> m a) => b -> m b
15:31:09 <Eduard_Munteanu> djahandarie: do you think 'g' is notable in any way?
15:31:39 <cgroza> Eduard_Munteanu: Republica Moldova :D
15:31:47 <Eduard_Munteanu> Ah.
15:32:29 <djahandarie> Eduard_Munteanu, not sure, need it to make using this library less painful.
15:32:37 <k0ral> how can I pattern match a Data.Text ?
15:33:40 <djahandarie> Well, I've written an interpreter for my type-safe IRC action... I have no idea if it makes any sense or not though :D
15:34:18 <Eduard_Munteanu> k0ral: presumably you can't, according to the Haddock documentation, since it doesn't export its constructors
15:34:29 <Eduard_Munteanu> http://hackage.haskell.org/packages/archive/text/0.11.1.3/doc/html/Data-Text.html#g:4
15:35:11 <djahandarie> Heh. It connected! But I don't think it joined a channel.
15:35:25 <djahandarie> Ah, silly mistake. :)
15:35:29 <benmachine> k0ral: you may be interested in view patterns
15:35:32 <Eduard_Munteanu> Oh, your IRC server
15:35:40 <Eduard_Munteanu> erm client, I don't remember
15:36:03 <k0ral> Eduard_Munteanu, benmachine: thank you, investigating view patterns
15:36:15 <BobFunk> playing around with the Network.Websockets library, but just ran into a problem with "accept" from Network
15:36:22 <BobFunk> this line: (h, _, _) <- accept socket
15:36:24 <parcs> what is an image of a function
15:36:43 <djahandarie> :o
15:36:44 <BobFunk> gives me this error from inside the Network lib: ws: Network/Socket/Internal.hsc:(285,2)-(301,60): Non-exhaustive patterns in case
15:36:45 * djahandarie pokes safeHaskell 
15:36:51 <Eduard_Munteanu> k0ral: they allow you to pattern match on the result of applying a function to your args
15:37:16 <BobFunk> when I put haproxy in front
15:37:22 <benmachine> k0ral: something like startsWithX (uncons -> Just ('x',rest)) = True
15:37:23 <Eduard_Munteanu> So you could use stuff like 'uncons'.
15:38:21 <BobFunk> anyway to at least avoiding my program crashing in that case? and should't Network be giving me some kinda IO error no matter what haproxy is sending?
15:38:29 <k0ral> Eduard_Munteanu, benmachine: roger that
15:39:03 <benmachine> BobFunk: ideally it would do that yes, and you could catch it with catch
15:39:08 <benmachine> not always that simple though
15:39:29 <benmachine> BobFunk: was the 'ws' part of your error message btw?
15:39:41 <BobFunk> ws is just the name of the executable
15:39:45 <benmachine> oh right
15:40:04 <Eduard_Munteanu> parcs: the subset of its codomain that's actually "covered" by the function
15:40:18 <parcs> k0ral: also take a look at pattern guards. i think they are nicer than view patterns
15:40:38 <benmachine> pattern guards have the advantage of being standard as well
15:41:28 <BobFunk> not sure how to best go about catching it with catch
15:41:32 <Eduard_Munteanu> parcs: Im(const 3) = {3}, even if const : N -> N
15:41:42 <k0ral> pattern guards can only be used in a function definition, right ?
15:41:52 <benmachine> k0ral: anywhere you can use guards, I think
15:41:54 <benmachine> I assume
15:41:59 <benmachine> (so case expressions too)
15:42:20 <benmachine> BobFunk: have you seen the docs for Control.Exception?
15:42:23 <Eduard_Munteanu> http://en.wikipedia.org/wiki/Function_(mathematics)    4th paragraph and related stuff
15:42:44 <k0ral> thank you for your help
15:43:22 <BobFunk> benmachine: yeah - just not sure how to apply it in this case
15:43:40 <benmachine> BobFunk: I'm sleepy so I am going to go to bed instead of helping, sorry
15:43:47 <BobFunk> no worries
15:44:05 <cgroza> anyway bye Eduard_Munteanu: la revedere
15:46:34 <BobFunk> if I try a `catch` \ (ex :: PatternMatchFail) I get a "Couldn't match expected type `IOException'"
15:46:42 <BobFunk> when compiling
15:47:01 <BobFunk> and if I catch an IOException, obviously it doesn't catch the pattern match fail
15:47:14 <mm_freak> i'm still very confused as to how to make dynamic systems in yampa/animas
15:47:15 <preflex>  mm_freak: you have 1 new message. '/msg preflex messages' to read it.
15:47:40 <mm_freak> http://hpaste.org/49386 ‚áê this one runs for two seconds without problems (before the addEv event is generated)
15:48:06 <mm_freak> and then it starts to leak memory
15:48:28 <mm_freak> djahandarie: -poke-
15:48:32 <djahandarie> Hey!
15:48:37 <djahandarie> One second.
15:48:38 * Eduard_Munteanu hasn't seen mm_freak in a while
15:48:46 <mm_freak> hi there, how may i help you?
15:49:02 <mm_freak> Eduard_Munteanu: about two weeks ago i was offline for a few days
15:49:12 <mm_freak> otherwise i've been here all the time
15:49:16 <Eduard_Munteanu> Hm.
15:49:50 <Eduard_Munteanu> Idling doesn't count :P
15:49:52 <mm_freak> does anyone know a good yampa or animas tutorial, which really gets into real world applications?
15:50:04 <Eduard_Munteanu> No, but I'd be interested too.
15:50:08 <mm_freak> Eduard_Munteanu: i think, i'm fairly active ;)
15:50:24 <mm_freak> i understand the basic principle of yampa, but dynamic systems puzzle me
15:51:02 <mm_freak> i understand how to use switches to change the signal network, but not how that helps me to write dynamic systems, where a player might fire a bullet, which disappears when hitting something
15:51:02 <Eduard_Munteanu> I've been asking conal for an FRP framework suggestion but couldn't get anything concrete. Granted, he's interested in researchy issues.
15:51:23 <mm_freak> Eduard_Munteanu: if you want something simple, try elerea
15:51:35 <djahandarie> mm_freak, http://hpaste.org/49387
15:51:38 <Eduard_Munteanu> Hm, I'll look it up, thanks.
15:51:40 <mm_freak> but i find yampa/animas so great that i would prefer to go with that
15:51:56 <monochrom> BobFunk: there are many functions called "catch". make sure you import the right one and suppress the wrong ones
15:52:32 <djahandarie> mm_freak, and it's online, right now, in #haskell-bot
15:53:26 <Eduard_Munteanu> Wha? Nice.
15:55:41 <BobFunk> monochrom: thanks - that was it
16:02:23 * hackagebot system-filepath 0.4 - High-level, byte-based file and directory path manipulations  http://hackage.haskell.org/package/system-filepath-0.4 (JohnMillikin)
16:03:23 * hackagebot crypto-api 0.6.4 - A generic interface for cryptographic operations  http://hackage.haskell.org/package/crypto-api-0.6.4 (ThomasDuBuisson)
16:07:04 <int80_h> :t seqM
16:07:27 <Twey> :t sequenceM
16:07:50 <Twey> Er, sequence
16:07:54 <Twey> sequence :: Monad m => [m a] -> m [a]
16:07:58 <int80_h> Twey: Am I correct in thinking sequenceM evaluates a series of monadic computations?
16:08:14 <Twey> No, it's just ‚Äòsequence‚Äô ‚Äî there's no pure equivalent
16:08:15 <int80_h> oh, it's sequence...okay
16:08:55 <int80_h> I was using runErrorT but I don't think I need that in this case.
16:09:47 <int80_h> @hoogle sequence
16:10:22 <int80_h> is sequence in Control.Monad?
16:10:46 <int80_h> ah found it
16:10:46 <hpc> should be, yeah
16:16:16 <int80_h> so I'd like something like sequence. I need something that evaluates each action, but only keeps the final result.
16:16:37 <int80_h> is there a function like that?
16:17:14 <int80_h> I suppose I could do something like head $ sequence ...
16:17:26 <int80_h> or rather tail
16:24:13 <int80_h> I noticed sequence wants a [IO a0], the action I want to execute has type IO (Maybe String). What are my options?
16:24:38 <int80_h> not execute, I mean evalutae.
16:25:00 <cmccann> if you have something with a type like IO a, just use it
16:25:46 <int80_h> ah as in "let ... in"
16:26:00 <cmccann> sequence is for turning something like [m a] into m [a]
16:26:06 <cmccann> e.g. run everything and collect the results
16:27:12 <pr> lambdabot on vacation - again?
16:28:01 <cmccann> int80_h, what is it that you're trying to do, exactly?
16:38:04 <int80_h>  cmccann: I've got it. I had a series of monadic actiona I needed to evaluate. I was modeling my approach from a function someone wrote for me. But the context was different enough that their approach wasn't right. I think it's fine now. I'm onto other type errors elsewhere.
16:38:35 <cmccann> int80_h, ok, glad to hear it
16:49:51 <FUZxxl> @faq Can Haskell solve my problem?
16:50:00 <FUZxxl> @help
16:50:36 <cmccann> @faq Can Haskell bring lambdabot back?
16:50:43 * cmccann listens to the crickets
16:50:45 <cmccann> :[
16:55:32 * hackagebot haskell-bcrypt 0.1 - A bcrypt implementation for haskell  http://hackage.haskell.org/package/haskell-bcrypt-0.1 (BrettCarter)
17:00:17 <brett> Wheee +1
17:14:38 * hackagebot system-fileio 0.2.1 - High-level filesystem interaction  http://hackage.haskell.org/package/system-fileio-0.2.1 (JohnMillikin)
17:16:38 * hackagebot system-fileio 0.3 - High-level filesystem interaction  http://hackage.haskell.org/package/system-fileio-0.3 (JohnMillikin)
17:42:30 <narens> I didn't have this problem in an older version of glade but in the new one it tags the GtkHBox and GtkVBox both as GtkBox in the xml and has a child tag that specified the type, but this change makes the builderAddFromFile function fail. It says "cannot create instance of abstract (non-instantiatable) type GtkBox'". Is this because the gtk package needs to be updated?
17:47:00 <danharaj> woo
17:47:04 <danharaj> nothing like a power outage during a productive coding session
17:50:38 <cmccann> danharaj, what, you don't have a generator backup?
17:51:24 <luite> or a laptop :p
17:51:42 <danharaj> I refuse to code with anything less than two monitors and an internet connection.
17:52:18 <Dashkal> No lambdabot?
17:52:44 <cmccann> lambdabot is MIA :[
17:53:09 <nihtml> lambdabot died. :9
18:00:36 <int80_h> @hoogle catMaybes
18:00:43 <int80_h> @hoogle catMaybe
18:02:38 <cmccann> int80_h, lambdabot isn't here :[
18:02:53 * cmccann wonders who takes care of lambdabot
18:04:09 <int80_h> I'm in ghci. I need a way to produce a foo from a Maybe foo. Any ideas?
18:04:47 <cmccann> maybe? fromMaybe? fromJust?
18:05:07 <int80_h> fromMaybe has the wrong type, I think
18:05:24 <cmccann> fromMaybe takes a default value to use if you have a Nothing
18:05:32 <cmccann> fromJust blows up on Nothing
18:05:39 <int80_h> it's a-> Maybe a -> a where I need a Maybe a -> a
18:05:50 <cmccann> There is no sane function with that type
18:05:51 <ion> Maybe a -> a is evil.
18:06:07 <cmccann> if you just need something in the REPL, use fromJust
18:06:15 <int80_h> gotcha
18:06:16 <cmccann> but never use that in actual code, it's a bad idea in many ways
18:09:16 <ion> Am i correct in thinking that a Data.Enumerator iterator that safely deallocates an IO resource if anything in the chain results in an error is impossible?
18:10:45 <mm_freak> is there a performance penalty to forcing ()?
18:11:06 <mm_freak> in other words, is it better to have "case () of () ->" or "case () of _ ->"?
18:11:34 <mm_freak> ion: why should that be impossible?
18:11:53 <maurer_> Anyone reccomend a haskell js parser?
18:16:48 <maurer_> Just tried language-javascript, but it fails to parse some basic tests from the jaegermonkey testsuite
18:17:07 <maurer_> I'm about to try hjs, but I'd prefer not to have to brute-force my way through all the js parsers to see if any of them work.
18:17:37 <luite> hehe let me know if any of them works ;p
18:17:45 <cmccann> maurer_, if you do have to brute force it, would you consider taking notes on your results and sharing them?
18:17:54 <maurer_> cmccann: OK.
18:18:01 <cmccann> just an email to haskell-cafe if nothing else, or post on a blog if you have one, whatev
18:18:05 <maurer_> cmccann: Test file I'm using at the moment is http://pastebin.com/bAv0zykp
18:18:18 <mauke> The paste bAv0zykp has been copied to http://hpaste.org/49391
18:22:42 <maurer_> hjs fails too :<
18:22:48 <cmccann> :[
18:27:44 <mm_freak> ok, in a simulation based on arrowized FRP (e.g. yampa) is the last state of all objects an input to the system?
18:28:20 <mm_freak> there are some problems, for which i really see no other way to solve them, but it feels wrong to me
18:28:39 <maurer_> WebBits does not fail that test, for those curious
18:28:56 <mm_freak> i managed to create a dynamic system using a pSwitch, but after the switch the local times restart, which is really not what i want
18:29:12 <mm_freak> for already existing objects, the local time should just go on like no switch happened
18:34:57 <ion> mm_freak: An enumerator that does IO gets a (Continue f) value from an iteratee, does the IO and applies f to its result. But if the IO action fails, isn‚Äôt f just thrown away and an error returned? Doesn‚Äôt that mean the iterator never gets a chance to do any cleanup in that case?
18:36:23 <Cale> mm_freak: ArrowLoop essentially gives you local state for things
18:37:33 <ion> (s/to its result/a value based on its result/ to avoid oversimplification)
18:38:22 <ion> And s/iterator/iteratee/, duh. I keep mixing up the suffixes. :-P
18:39:09 <avartanian> Dear Haskellers, I'm having a heck of a time with cabal install cabal-install
18:39:35 <avartanian> Has anyone run into .. cabal-install-0.10.2 depends on network-2.2.1.7 which failed to install network-2.2.1.7 failed during the building phase. The exception was: ExitFailure 1
18:39:40 <mm_freak> ion: just consider the type of 'Enumerator'
18:39:54 <mm_freak> ion: it is itself an iteratee and feeds another iteratee
18:39:54 <Cale> avartanian: That's not the real error
18:40:05 <Cale> avartanian: Why did network-2.2.1.7 fail to install?
18:40:22 <mm_freak> ion: you can well apply exception mechanisms to the outer iteratee
18:40:34 <avartanian> Trace ends there. Should I just try to install network-2.2.1.7 itself?
18:40:35 <mm_freak> ion: an enumerator is essentially just an enumeratee
18:40:50 <Cale> What version of network do you have?
18:40:56 <Cale> ghc-pkg list network
18:40:59 <mm_freak> Cale: what i need here is not local state, but actually some kind of not-so-local state
18:41:39 <avartanian> C:/Program Files (x86)/Haskell Platform/2010.2.0.0\lib\package.conf.d:     network-2.2.1.7
18:41:59 <avartanian> C:\Users\Ara\AppData\Roaming\ghc\i386-mingw32-6.12.3\package.conf.d:
18:42:51 <Cale> mm_freak: hmm
18:43:29 <mm_freak> Cale: for example i have an increasing Float:  mover = constant 1 >>> integral
18:43:48 <mm_freak> and i'd like to have a list of those movers, which can be extended by events
18:43:53 <mm_freak> that works just fine
18:44:09 <mm_freak> problem is:  whenever the list is extended, all movers go back to 0
18:44:18 <mm_freak> their local times seem to be reset to 0
18:44:44 <Cale> hum...
18:44:55 <mm_freak> and the only way around this i see is to have the current list of movers itself as an input to the system
18:45:05 <mm_freak> which feels not right
18:45:24 <Cale> I'm not sure why that would be happening.
18:45:50 <Cale> Oh, you're switching to a new arrow constructed from the list?
18:45:56 <Cale> So you lose all the state
18:45:58 <mm_freak> yes
18:46:14 <mm_freak> i don't see how pSwitch allows me to do something else
18:46:33 <Cale> Yeah, okay, you need a better spawning/switching primitive
18:46:36 <Cale> hmm
18:46:36 <mm_freak> it works with collections of signal functions, but those are not themselves signals
18:46:39 <avartanian> Cale so if I read that right, network-2.2.1.7 is already installed.
18:46:56 <Cale> We have forkExec which basically does what you're after, but obviously we're not using Yampa.
18:47:07 <mm_freak> hmm
18:47:12 <mm_freak> i'm using animas actually
18:47:22 <Cale> avartanian: yeah, hrm
18:47:58 <mm_freak> Cale: so with yampa this is not possible at all?
18:48:08 <Cale> mm_freak: I don't know Yampa well enough to say
18:48:19 <mm_freak> i see‚Ä¶  which library are you using?
18:48:21 <avartanian> I'm on Vista, compiling with gcc-core.
18:48:25 <Cale> IPwn.FRP :)
18:48:27 <avartanian> (cygwin)
18:48:43 <mm_freak> lol?
18:48:45 <Cale> (which isn't publically available yet)
18:48:50 <mm_freak> hmm, i see
18:48:53 <luite> it will be?
18:48:58 <Cale> luite: Not sure
18:49:19 <mm_freak> Cale: i've been struggling with that problem for weeks now‚Ä¶  never thought that it's not actually a shortcoming in my understanding
18:49:26 <luite> oh ok. it would be interesting to see an FRP library that actually works ;)
18:49:47 <Cale> luite: Yeah, I think it would be nice to release something at some point.
18:50:54 <mm_freak> Cale: isn't it based on yampa?  i remember talking to you about it about a year ago
18:51:05 <Cale> mm_freak: It's vaguely yampa-ish
18:51:10 <Cale> But not based on Yampa
18:51:26 <Cale> (implementation-wise)
18:51:36 <mm_freak> hmm‚Ä¶  is there anything keeping you from publishing it?
18:52:05 <Cale> It wouldn't be my decision
18:52:31 <mm_freak> ok
18:53:07 <mm_freak> could you point me towards a workaround?  pSwitch switches the whole system and doesn't know anything about the structure of the SF collection
18:53:34 <Cale> Let me have a look at what Yampa offers again :)
18:54:04 <mm_freak> it basically offers pSwitch and rpSwitch for that purpose
18:54:22 <avartanian> Has anyone had any good experiences running Haskell on a Linux desktop VM?
18:54:39 <mm_freak> rpSwitch doesn't change the semantics of pSwitch, but just makes a nicer interface for recurring switches
18:54:52 <mm_freak> avartanian: "linux desktop VM"?
18:55:13 <avartanian> mm_freak like an Ubuntu appliance with VMWare player
18:55:22 <Cale> avartanian: I've run GHC under MacOS running under VMware for Linux
18:55:26 <mm_freak> avartanian: should run just like any other application
18:55:32 <monochrom> yes, I sometimes do it, works just fine
18:55:47 <mm_freak> i only have experience with GHC on WINE, and my conclusion is:  don't ;)
18:55:58 <monochrom> I just haven't tried two levels of VM yet. "we need to go deeper"
18:56:02 <avartanian> hahahah
18:56:05 <avartanian> inception-style
18:56:25 <avartanian> So far VMWare Ubuntu has been okay for me, but cabal is really kicking its butt
18:56:37 <avartanian> cabal install cabal-install just hangs it every time
18:57:11 <mm_freak> Cale: http://hackage.haskell.org/packages/archive/Animas/0.2/doc/html/FRP-Animas.html#g:16
18:57:19 <mm_freak> be sure not to confuse pSwitch with pSwitchB
18:57:23 <monochrom> use the "gold linker" if you can help it. faster for ghc-generated code
18:57:26 <mm_freak> the former is what i'm working with
18:57:39 <avartanian> at this point, I can't get a dev environment in either of two OSs
18:57:59 <monochrom> ghc generates code that pushes traditional linkers very hard, both cpu and memory
18:58:00 <mm_freak> avartanian: why would you want a dev environment in a VM?  cross compilation?
18:58:18 <Cale> mm_freak: hrm...
18:59:02 <avartanian> mm_freak only because it's impractical to dual-boot
18:59:50 <mm_freak> avartanian: there is no good development environment for your host OS?
19:00:06 <mm_freak> avartanian: i'm asking because you should be aware that GHC cannot cross-compile
19:00:10 <avartanian> mm_freak haskell aside, there are a lot of nifty toys I can't play with if I stay in Windows-land
19:00:16 <avartanian> not trying to cross compile
19:00:31 <mm_freak> yes, but when compiling under linux you create linux executables
19:00:43 <avartanian> mm_freak of course
19:00:57 <mm_freak> to get your programs into windows land you will need to compile with a windows distribution of GHC
19:01:12 <mm_freak> and i could think that you would rather want to test your apps in your host OS
19:01:15 <avartanian> mm_freak yup yup. no interest in getting my programs in windows land at this point
19:01:24 <mm_freak> ok, i see
19:01:33 <mm_freak> Cale: i'll give rpSwitch a shot
19:01:48 <mm_freak> but i can't imagine it changes things
19:01:55 <mm_freak> the SF collection is still not a signal
19:02:36 <danharaj> if I have an IO action that acts on a ForeignPtr, let's say that I put the ForeignPtr in an MVar and bracket the action with takeMVar and putMVar. If I unsafePerformIO this action, will it be guaranteed that nothing else can perform IO on that ForeignPtr while the action is not finished?
19:02:40 <mm_freak> and the only real solution i see is to have a collection type, which is known to yampa/animas
19:03:14 <mm_freak> danharaj: you're asking for locking?
19:03:54 <danharaj> mm_freak: Essentially, yeah.
19:04:07 <mm_freak> first make sure that locking is really what you want
19:04:32 <mm_freak> so what's your application?
19:04:37 <danharaj> mm_freak: I'm writing a pure interface to a C library that requires me to unsafePerformPointerManipulations.
19:04:46 <danharaj> I need to make sure unsafePerformPointerManipulations don't interleave.
19:05:38 <mm_freak> one easy way to do it is to create a thread for it
19:05:52 <danharaj> mm_freak: what do you mean?
19:05:58 <mm_freak> only this thread knows the pointer, and all other threads talk to this thread
19:06:22 <mm_freak> this ensures sequential operation (unless laziness bites you)
19:06:49 <danharaj> how would laziness bite me in such a situation?
19:07:32 <mm_freak> well, when doing unsafe* stuff, then all laziness effects come back
19:08:09 <danharaj> well, order of execution doesn't matter, just so long as each individual unsafePerform is done without interleaving with another.
19:08:28 <danharaj> I fiddle some state, but I get a referentially transparent answer, and restore the state.
19:09:05 <mm_freak> STM has a nice abstraction for that
19:09:33 <mm_freak> data MyHandle = MyHandle (TVar Bool) (ForeignPointer Blub)
19:10:43 <mm_freak> atomically $ do isFree <- readTVar theBoolVar; check isFree; writeTVar theBoolVar False
19:10:50 <mm_freak> then the pointer is locked
19:11:05 <mm_freak> to give it back, just write True
19:11:29 <mm_freak> oh man, in what ugly style did i just write that?
19:11:46 <mm_freak> atomically (readTVar theBoolVar >>= check >> writeTVar theBoolVar False)
19:11:52 <mm_freak> there we go
19:13:29 <danharaj_> hiccup
19:13:55 <mm_freak> you can use STM for that
19:14:18 <mm_freak> atomically (readTVar lockVar >>= check >> writeTVar lockVar False)
19:16:41 <danharaj> mm_Freak: but then it's not pure.
19:16:52 <danharaj> err, it's in IO
19:22:24 <danharaj_> oh boy my internet is absolutely thrilling today
19:26:00 <sebz> >pl (\x -> f (g x) x)
19:26:08 <sebz> > pl (\x -> f (g x) x)
19:26:13 <sebz> er how do I use this again
19:26:39 <djahandarie> Well, it's @pl \x -> f (g x) x
19:26:44 <djahandarie> But lambdabot is broken
19:26:55 <sebz> oh :( sorry to hear that
19:29:38 <danharaj_> She slumbers.
19:29:39 <danharaj_> She waits.
19:29:41 <shachaf> sebz: (=<<) might be related to what you want.
19:30:14 <mm_freak> danharaj: you would do that in unsafe*
19:30:19 <sebz> shachaf, thanks
19:30:32 <danharaj> mm_freak: but you can't! :p
19:30:55 <mm_freak> danharaj: you can't?  i'm not following
19:31:06 <danharaj> "   You cannot use atomically inside an unsafePerformIO or unsafeInterleaveIO. Any attempt to do so will result in a runtime error."
19:31:11 <mm_freak> oh, i see
19:31:23 <mm_freak> then try QSem with only one slot
19:31:24 <cmccann> note that's not just a "something might crash" type thing
19:31:35 <cmccann> atomic will blow up your program if it finds itself inside unsafePerformIO
19:31:41 <cmccann> er, atomically
19:31:51 <cmccann> the explosion may be atomic, make no promises there
19:32:48 <mm_freak> i'm very glad that other people pick up interfacing to C libraries
19:33:10 <mm_freak> they are not just a PITA to use, but also to interface =)
19:33:25 <danharaj> Well thank god someone else did the bindings for me.
19:33:29 <danharaj> And very thoroughly too.
19:34:59 <danharaj> incidentally, wrapping things with MVar's will make the code inherently thread safe, right?
19:35:04 <avartanian> hmmm... is there anything I should try uninstalling re-installing?
19:35:18 <avartanian> if cabal install cabal-install is crapping out
19:35:43 <monochrom> not that I know of
19:35:58 <monochrom> you can just re-install. it just overwrites.
19:42:16 <danharaj> how expensive are takeMVar and putMVar in a single threaded application?
19:42:44 <shachaf> $0.06 each.
19:43:50 <Cale> danharaj: Cheap, until you mess up and put to a full MVar or take from an empty one.
19:44:08 <Cale> (because there will be no other thread to save you)
19:44:10 <cmccann> shachaf, that depends on the exchange rate, should be in pounds sterling
19:44:28 <cmccann> and, ideally, deposited directly into the Simons' beer fund
19:44:51 <danharaj> Cale: Oh dear that's a concern...
19:44:58 <danharaj> That puts a snag in my plan.
19:45:17 <danharaj> It makes sense though, what will happen if two unsafePerformIO's happen in my wrapper is that the thread will just deadlock.
19:45:22 <Cale> danharaj: MVars are pretty useless without forkIO
19:45:24 * danharaj kicks a bucket
19:45:25 <shachaf> danharaj: That's kind of the point of MVars, isn't it? :-)
19:45:39 <danharaj> I just want atomic unsafePerformIO :\
19:46:49 <Cale> danharaj: How does atomicity matter if you're doing everything in a single threaded, non-parallel way?
19:48:36 <danharaj> Cale: I am wrapping a C library, wherein I fiddle some state, get a referentially transparent answer, and then restore the state.
19:49:02 <danharaj> Cale: However, if the actions interleave, they will mess each other up and produce nonsense.
19:49:39 <danharaj> Cale: So I need to guarantee that when I call "unsafePerformIO", no other unsafePerformIO will mix with it.
19:49:53 <danharaj> At least, w.r.t. the state I'm fiddling.
19:51:09 <shachaf> danharaj: How would another unsafePerformIO interleave with it, if you're only using one thread?
19:51:35 <danharaj> shachaf: Well, what if the RTS schedules them that way? I don't know how it handles unsafePerformIO calls.
19:52:12 <danharaj> shachaf: Also, it'd be nice to support multithreaded programs.
19:52:24 <Cale> danharaj: Make sure to run all the requests to your C library from a single thread, and use a Chan to communicate with that thread via the unsafePerformIO's
19:52:38 <danharaj> Cale: does Chan behave like a coroutine or something?
19:52:53 <Cale> Chan is just a FIFO channel
19:54:01 <c_wraith> You could just store your structure in an MVar, too.
19:57:36 <danharaj> c_wraith: If I store in an mvar, wouldn't I get deadlock in the event of interleaving? I'll explore Cale's solution.
19:58:15 <deech> Hi all, I just got a "ghc:panic! (the 'impossible' happened)" when playing with Oleg's delimited continuations code. I'm not sure how to boil it down into a smaller example. What is the best way (or should I) report it as a GHC bug?
19:58:31 <Cale> danharaj: No, because you're being explicitly concurrent now :)
19:59:02 <danharaj> Cale: Oh I see, use the MVar but with the other thread.
19:59:08 <ion> mm_freak: I‚Äôm most likely still utterly misunderstanding something, but i don‚Äôt see a place in fooIter <http://hpaste.org/49393> that gets executed after an enumerator has resulted in an error.
19:59:10 <danharaj> Hmm, I've never used another thread before in Haskell. Exciting times.
19:59:16 <cmccann> deech, which bit of code?
19:59:35 <deech> ZipperM.hs which is part of ZFS.
19:59:40 <cmccann> danharaj, multithreading is actually rather dull in Haskell in my experience
19:59:43 <danharaj> so uhh, which way to the standard thread library :[
20:00:06 <deech> cmccann: http://okmij.org/ftp/continuations/ZFS/
20:00:07 <shachaf> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
20:01:30 <huangyi> Is there a graphics tutorial like those for arrows ?
20:02:01 <danharaj> oh, what if I just wrap with (unsafePerformIO . forkIO $), would that work?
20:02:09 <danharaj> And use the mvar trick.
20:02:15 <danharaj> er, mvar shenanigans.
20:02:39 <deech> cmccann: All I did was take the "tf", "filterFn" and "dir_path" out of "dzip_term" and into the top-level. When I run "testdz1" I get the error.
20:03:17 <cmccann> interesting
20:04:22 <cmccann> seems to work for me. what version of ghc?
20:05:27 <ion> sebz: http://heh.fi/haskell/functors/#function-instance
20:06:14 <deech> 7.0.1
20:07:49 <deech> I think I have it.  I added a type signature to "tf", tf :: Path -> Term -> m NavigateDir, and that seems to be causing the panic.
20:09:42 <cmccann> that's not a valid type signature, is it?
20:10:26 <deech> cmccann: Why does it compile then? Also it is the type signature used the "traverse" function to describe "tf".
20:10:49 <deech> cmccann: ghci seems to infer something different though, tf:: (Monad m, Typeable1 m) => [PathComp] -> Term -> CC PP m NavigateDir
20:11:23 <cmccann> yes, traverse takes a more general type
20:11:45 <deech> cmccann: And why does if cause ghc to panic as opposed to a compiler error?
20:11:54 <cmccann> well, if I add that type signature I get a type-check error, as expected
20:12:00 <cmccann> so the answer is probably "a bug in GHC"
20:12:08 <cmccann> I'm just trying to narrow it down a bit :]
20:13:05 <deech> Are we on different versions?
20:13:19 <cmccann> yes, I've been trying several versions
20:14:38 <deech> cmccann: If I had to take a shot in the dark informed by nothing but a gut feeling I think that "Typeable" may be to blame.
20:14:44 <cmccann> trying to determine whether it's something quirky with your installation, or a bug introduced and fixed between 6.12.3 and 7.0.3
20:15:02 <cmccann> since I don't happen to have 7.0.1 installed :T
20:15:30 <deech> Where does Oleg hang out? :)
20:16:16 <cmccann> oleg lives at the type-level, you can't get there from here without using dependent types, sorry
20:16:40 <deech> Check with #agda, got it.
20:17:08 <cmccann> seriously though, he posts to -cafe occasionally but I think that's about it
20:17:13 <cmccann> oh, I've seen him on LtU as well
20:17:22 <cmccann> but mostly he just does his own thing
20:18:28 <mm_freak> Cale: sorry to bother you again, but do you see an obvious solution to my problem?
20:19:16 <mm_freak> even feeding the world back into the signal function seems not right, because i would have to reconstruct all signal functions in the collection on every switch
20:20:19 <ion> mm_freak: Sorry to bother you again, but do you see an obvious solution to my problem? ;-) (See my message 20 minutes ago.)
20:20:44 <mm_freak> ion: have you read the code of enumHandle?
20:20:54 <deech> I don't really know enough about delimited continuations to narrow this down. But I doubt the GHC folks will appreciate a bug report in its present state.
20:21:24 <cmccann> deech, yeah, that was my thought. having a minimal repro is much nicer
20:21:48 <cmccann> but I don't really feel like installing yet another GHC to test it myself :T
20:22:07 * cmccann thinks five is enough for now
20:22:37 <deech> cmccann: completely understandable. I'll install 7.0.4 and see if it continues.
20:22:49 <cmccann> might as well upgrade anyhow
20:22:49 <avartanian> We really need to start making Oleg jokes like Chuck Norris jokes.
20:22:56 <cmccann> avartanian, I think it's been done
20:23:01 <avartanian> Nooo....
20:23:03 <avartanian> Where?
20:23:05 <avartanian> :)
20:23:18 <deech> avartanian: I think he has his own T-Shirt.
20:23:26 <cmccann> probably some in lambdabot's quotes... but lambdabot has gone to the Great Fixed Point in the Sky right now
20:23:36 <deech> avartanian: http://haskell.spreadshirt.com/oleg-already-did-it-A6499531
20:23:59 <deech> lambdabot's gone?
20:24:01 <shachaf> avartanian: It used to be a #haskell Thing.
20:24:53 <mm_freak> ion: just consider that the inner iteratee doesn't take over, but rather it comes back
20:24:55 <cmccann> lambdabot is MIA at the moment...
20:25:04 <deech> "Great Fixed Point In The Sky" that's gold.
20:25:04 <mm_freak> ion: that's where at some point you use the (>>==) combinator
20:25:08 <djahandarie> Cale was here earlier, I wonder if he didn't notice
20:25:09 <cmccann> not sure who's responsible for lambdabot maintenance
20:25:13 <djahandarie> cmccann, Cale. :p
20:25:17 <cmccann> haha welp
20:25:44 <shachaf> lispy: Can you do anything?
20:27:22 <cmccann> hm
20:27:43 <cmccann> Cale, lambdabot appears to have gone to the Great Fixed Point in the Sky
20:28:13 <Cale> heh
20:28:28 <shachaf> More like the Least Fixed Point, I'd say.
20:28:34 <Cale> trying to figure out why compiz is eating 100% cpu :P
20:28:42 <cmccann> Cale, it's hungry?
20:28:50 <mm_freak> Cale: disable cube atlantis ;)
20:29:24 <cmccann> hooray
20:29:28 <shachaf> @botsneak
20:29:33 <lambdabot> :)
20:29:35 <azaq23> hm, apparently, one can do stuff like "f :: m a -> m a; f = id" and f will only take types which can be deconstructed into a type constructor and another type, yet one can't do anything to the values themselves at all, because there's no context given for m
20:29:49 <deech> Cale: unevaluated thunks?
20:29:56 <azaq23> oh was scrolled up to much
20:30:02 <cmccann> azaq23, yes. why would you expect otherwise?
20:31:32 <monochrom> @botattack
20:31:37 <lambdabot> Unknown command, try @list
20:32:41 <azaq23> cmccann: Because deech said in the log "I think I have it.  I added a type signature to "tf", tf :: Path -> Term -> m NavigateDir", and you said that this isn't a valid type signature, I thought you meant that the context for m was not mentioned (in traverse in the ZipperM file, traverse takes a Monad context), yet on a second thought you likely meant "valid" not in a general sense but applied to the concrete problem
20:33:02 <ion> mm_freak: enumHandle does do tryIO (getBytes ...); k (Chunks [bytes]) >>== loop. if tryIO results in an error, the Iteratee monad‚Äôs >>= never goes forward to the k (...) part, it just returns with the error.
20:33:31 <cmccann> azaq23, ok. yeah, I mean "that's a type error because it doesn't match the definition of the term"
20:34:51 <mm_freak> ion: what else do you need?
20:38:45 <ion> mm_freak: When an enumerator results in an error, i still fail to see any way to have an iteratee run any code (to clean up) after that. In fact, it seems a function called iterFile was removed from Data.Enumerator because of this: http://osdir.com/ml/haskell-cafe@haskell.org/2010-08/msg01283.html
20:41:58 <mm_freak> ion: iterHandle is still there in enumerator 0.4.10
20:42:52 <mm_freak> i don't really see the problem with iterHandle, as long as you don't use it wrong
20:43:13 <mm_freak> but yes, if the enumerator fails, then the iteratee cannot do cleanup
20:43:31 <mm_freak> you will have to do the cleanup around the ($$) call
20:44:22 <ion> mm_freak: Yes, it expects you to do something like withFile "out" WriteMode $ \h -> run_ (enumFile "in" $$ iterHandle h), which doesn‚Äôt feel as elegant as the hypothetical run_ (enumFile "in" $$ iterFile "out")
20:45:02 <ion> But good to know that i did understand the semantics correctly. :-)
20:45:10 <ion> Thanks for your help.
20:49:06 <mm_freak> ion: you don't have to do it outside of 'run', just outside of ($$)
20:49:49 <mm_freak> for simple applications that's basically outside of 'run', but more complicated applications will have ($$) applications deep inside their iteratees
20:50:11 <ion> aye
20:50:57 <mm_freak> but it teaches you:  try to write your iteratees with as few impure resources as possible‚Ä¶  that's the original idea of iteratees anyway =)
20:51:38 <mm_freak> note that a generic 'cleanup' combinator may well be implemented as an enumeratee
20:52:03 <mm_freak> cleanup :: Monad m => m () -> Enumeratee a a m b
20:52:42 <mm_freak> cleanup closeMyHandles =$ enumHandle h $$ myIteratee
20:54:31 <ion> True
20:55:06 * hackagebot error-location 0.1 - error functions that show file location information  http://hackage.haskell.org/package/error-location-0.1 (GregWeber)
20:57:50 <avartanian> Cale Yeah my problem is with the network package
20:57:56 <avartanian> cabal install network fails too
20:58:31 <avartanian> C:\Users\Ara>cabal install network Resolving dependencies... Configuring network-2.3.0.4... cabal: The package has a './configure' script. This requires a Unix compatibility toolchain such as MinGW+MSYS or Cygwin. cabal: Error: some packages failed to install: network-2.3.0.4 failed during the configure step. The exception was: ExitFailure 1
20:59:02 <avartanian> I can't install snap. Can't update cabal.  Can't do much of anything.
21:01:06 * hackagebot error-location 0.1.1 - error functions that show file location information  http://hackage.haskell.org/package/error-location-0.1.1 (GregWeber)
21:01:16 <avartanian> wait why did cygwin leave my path? coward!
21:04:07 * hackagebot error-location 0.1.2 - error functions that show file location information  http://hackage.haskell.org/package/error-location-0.1.2 (GregWeber)
21:04:38 <avartanian> oh well no better
21:09:07 * hackagebot error-location 0.1.3 - error functions that show file location information  http://hackage.haskell.org/package/error-location-0.1.3 (GregWeber)
21:38:00 <rpearl> http://twitter.com/taglesstweetmac
21:38:25 <rpearl> is this the best idea [y/y]
21:48:11 * hackagebot dbus-core 0.9 - Low-level D-Bus protocol implementation  http://hackage.haskell.org/package/dbus-core-0.9 (JohnMillikin)
21:52:36 <cmccann> rpearl, hm, is that compatible with the -fvia-stackoverflow code generator backend?
21:53:05 <cmccann> that's the one that performs optimization by piping the output through Don Stewart
21:59:10 <NemesisD> i've got a Types module in my library that defines all the datatypes used in the library. is it considered good practice to define instances for these types in another module
21:59:26 <NemesisD> in particular instances for novel classes
21:59:58 <cmccann> instances are most often placed together with either the class or type definitions but this isn't absolutely required
22:01:06 <NemesisD> the class will be defined in the same file as the instances. but in a separate module from the datatypes
22:01:14 <NemesisD> how would i export the instances?
22:01:23 <cmccann> instances are exported automatically and implicitly
22:01:29 <NemesisD> oh
22:01:29 <cmccann> importing the module at all will import them
22:01:35 <cmccann> including importing nothing from the module
22:01:41 <cmccann> e.g. import Foo.Bar ()
22:01:47 <cmccann> that imports instances but nothing else
22:01:48 <NemesisD> ok cool
22:02:43 <cmccann> and yeah, if you're putting the instances with the class definition then that's completely reasonable
22:02:51 <NemesisD> im actually not sure if i've designed this right, i could go either way. i've got a module XML and a module Types. i'm creating a class called fromXML that parses the type from an XML cursor
22:03:40 <NemesisD> im not sure if types should import XML and then define instances alongside the types or if xml should import the types and define the instances for them
22:04:28 <cmccann> in that situation, assuming these are some sort of basic types used throughout your library, I think putting them with the class makes sense
22:05:01 <cmccann> since the types are a kind of ambient foundation, and the instances are all about "ways to convert from XML to these things"
22:05:17 <cmccann> conceptually the instances have more to do with the class than the types... at least would be my thought
22:06:22 <NemesisD> thats true. i could really see both ways. on one hand, everything concerning XML for my library would go in one place. on the other hand, the XML library would be more reusable if it didn't have application specific stuff in it, but i don't plan to have it in the modules list for my library so i think i lean towards your thinking more
22:08:08 <cmccann> can always move stuff around later if you need to
22:08:34 <cmccann> including things like breaking the types module apart into different modules or things like that
22:09:39 <NemesisD> yeah. i figure that i might be moving the operators i've made for XML to a separate project entirely.
22:25:46 <NemesisD> naming infix operators is an art
22:26:24 <cmccann> ascii art, you mean
22:26:39 <cmccann> you get bonus points if they look like shift-JIS emoticons
22:27:54 <NemesisD> lol
22:28:53 <cmccann> > let (ÔΩ°‚óï‚Äø‚Äø‚óïÔΩ°) = id in (ÔΩ°‚óï‚Äø‚Äø‚óïÔΩ°) "hi"
22:28:54 <lambdabot>   "hi"
22:31:23 <NemesisD> it would appear haskell has great support for special characters
22:31:37 <cmccann> hooray for unicode
22:35:32 <parcs> it really bugs me that the import keyword doesn't get autocompleted in ghci
22:37:15 <NemesisD> i wonder why that is
22:39:07 <parcs> probably an oversight
23:05:35 <yhager> Can one write a pattern-based functions directly in ghci?
23:08:35 <c_wraith> yes, using semicolons.
23:08:35 <c_wraith> > let foo True = 5 ; foo False = 10 in Foo (4 == 5)
23:08:35 <c_wraith> right.  dead lambdabot, and I capitalized that last foo accidentally
23:08:35 <c_wraith> but, the idea stands
23:08:35 <lambdabot>   Not in scope: data constructor `Foo'
23:10:05 <c_wraith> oh.  lambdabot's back, I'm just insanely lagged
23:10:05 <c_wraith> > let foo True = 5 ; foo False = 10 in foo (4 == 5)
23:10:06 <lambdabot>   10
23:10:24 <djahandarie> Nope, you're not, lambdabot is
23:10:49 <yhager> c_wraith: works, thanks.
23:11:02 <c_wraith> well, "* Ping reply from niven.freenode.net: 2.78 second(s)"  isn't very good in any case. :)
23:11:36 <yhager> I've tried a few times to learn haskell, but never had any real project to work on for this. I now found about projecteuler.net, and am working my way in haskell for the solutions. It's a great and fun way to learn!
23:12:25 <c_wraith> yhager: project euler gets very math/algorithm centric pretty quickly...  To the point where no programming language will be fast enough if you don't know the necessary tricks.
23:12:35 <c_wraith> err, no programming language *implementation*
23:13:07 <yhager> c_wraith: well, I'm still at problem #8, so my learning curve is still on the steep side :)
23:13:59 <yhager> all I am saying is that so far it has been a great way to get my hands dirty with Haskell.
23:14:52 <c_wraith> it's also weak in terms of teaching you how to structure programs and work with IO.  But it's good for learning the basic syntax and a few basic optimization tricks.
23:16:12 <yhager> c_wraith: yes, I can see what you mean. For someone who still in the awe phase of the language, it's good enough for now.
23:17:17 <luite> you might enter the shock phase when you have to learn monads ;)
23:21:29 <yhager> luite: :)
23:30:13 * BMeph reaches for his dark glasses when the cry of "Monadics!" is made...
23:46:58 <c_wraith> holy crap, I just found a use for type synonyms.  I usually hate them.
23:47:05 <yhager> Not sure if it is apropriate to aske here, but I am trying to understand the code in http://www.haskell.org/haskellwiki/Prime_numbers#Optimal_trial_divison
23:47:22 <c_wraith> Certainly fine to ask here.
23:48:07 <yhager> What does "isPrime primes n =" mean?
23:48:38 <c_wraith> it defines a function named isPrime, with two arguments
23:48:42 <c_wraith> the first one is a list of prime numbers
23:48:50 <c_wraith> the second is the number to test
23:49:03 <c_wraith> If this sounds a little circular, well - that's because it is. :)
23:49:36 <yhager> so the 'primes =' in the second line is unrelated to the primes list in the first function definition, right?
23:50:29 <c_wraith> yes, the names are different
23:50:42 <c_wraith> with warnings on, GHC would warn that it's shadowing, there
