00:11:36 <Jonno_FTW> I think I fell into the dependency hell
00:21:13 <CrazyThinker> yesterday someone was telling me I would never have to use the infix notation.
00:21:23 <CrazyThinker> How can I rewrite this without it: partition (`elem` ['A'..'Z']) "BobsamoesnoMPPJ"
00:21:46 <opqdonut> > partition (flip elem ['A'..'Z'] "BobsamoesnoMPPJ"
00:21:47 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
00:21:49 <MatrixFrog> in general, (`elem` x) is the same as (\y -> elem y x)
00:21:52 <opqdonut> > partition (flip elem ['A'..'Z']) "BobsamoesnoMPPJ"
00:21:56 <lambdabot>   mueval-core: Time limit exceeded
00:22:02 <opqdonut> wow?
00:22:02 <Jonno_FTW> @full help
00:22:03 <lambdabot> Maybe you meant: tell url
00:22:11 <Lemmih> > partition (flip elem ['A'..'Z']) "BobsamoesnoMPPJ"
00:22:15 <lambdabot>   mueval-core: Time limit exceeded
00:22:29 <MatrixFrog> so you could use a lambda. or a flip like opqdonut said
00:22:44 <Lemmih> > partition (flip elem ['A'..'Z']) "BobsamoesnoMPPJ"
00:22:45 <lambdabot>   ("BMPPJ","obsamoesno")
00:22:48 <MatrixFrog> it's true though, you don't *have* to use infix notation. it's just a lot nicer sometimes
00:23:16 <CrazyThinker> Thank you so much
00:24:20 <CrazyThinker> > parition (\y -> elem y ['A'..'Z']) "BobsanomBBS"
00:24:21 <lambdabot>   Not in scope: `parition'
00:24:33 <CrazyThinker> > partition (\y -> elem y ['A'..'Z']) "BobsanomBBS"
00:24:34 <lambdabot>   ("BBBS","obsanom")
00:29:06 <sohum> so, I have a data Foo = Foo (Bar -> (Bar, [Foo])). I could totally write a runFoo (Foo x) = x and even make it infix, but this has to be a pattern that's come up before
00:30:38 <opqdonut> how about "data Foo = Foo {runFoo :: Bar -> (Bar, [Foo])}"
00:32:42 <erus`> mongodb is pretty effing cool then...
00:32:48 <sohum> opqdonut: sure, but mostly I was asking if there were any typeclasses I could use to make this more structured. some part of my brain is shouting about Applicative, but I'm pretty sure it's wrong
00:33:25 <opqdonut> well
00:33:35 <opqdonut> there's some fancy newtype stuff like ala
00:33:52 <opqdonut> for handling the pattern of isomorphic types
00:34:20 <opqdonut> but the standard/classic haskell solution is to just have a function that gives the isomorphism (i.e. runFoo, the inverse to Foo)
00:34:47 <sohum> hrrm, okay
00:35:01 <sohum> is there a standard name for the infix runFoo?
00:35:17 <opqdonut> http://hackage.haskell.org/packages/archive/newtype/0.2/doc/html/Control-Newtype.html
00:35:46 <opqdonut> the standard name is runFoo. If you want an infix name it would probably contain $ :)
00:36:02 <sohum> yep, but I can't use <$> because that's taken
00:40:55 <sohum> opqdonut: ala breaks my braaain
00:41:13 <opqdonut> :)
00:43:49 <dilinger> hm
00:43:51 <dilinger> http://feedvalidator.org/check.cgi?url=http%3A%2F%2Fplanet.haskell.org%2Frss20.xml
00:48:15 <testmonad> hi there, I have a question regarding the haskell platform installation
00:48:27 <testmonad> is it normal that I receive a "configure: WARNING: unrecognized options: --with-hc-pkg, --with-gcc" while running "make" ?
00:48:48 <testmonad> I mean, is this a bug within the haskell platform distribution I should file?
00:55:58 <Saizan> sounds more like you don't have the right version of ghc and/or cabal installed
00:56:41 <sosman> Trying to start eclipse and hangs when trying to load haskell plugin (fedora 14).  When I try to "cabal install scion" apparently this requires an older version of ghc than found in the fedora 14 repositories.  Any clues on how to force a scion install please?
00:57:12 <sosman> cabal: cannot configure scion-0.1.0.2. It requires ghc >=6.10 && <6.12
00:57:27 <sosman> The Glorious Glasgow Haskell Compilation System, version 6.12.3
00:58:23 <Saizan> you could cabal unpack scion; cd scion-*; edit the .cabal file to relax the dependency on ghc; run "cabal install" and prey
00:59:30 <testmonad> well ... in fact I am trying to install the whole thing on a bare debian : )
00:59:46 <sosman> Saizan: thanks - just noticed that there is a haskell-platform package - will try that first.
01:00:02 <testmonad> downloaded the binary distribution of ghc ... ./configure ... make install
01:00:17 <Saizan> scion won't be included in the haskell-platform
01:00:38 <testmonad> and after that I tried the same with the haskell-platform ... it worked, it's not a fatal error ... but I am wondering if something could be wrong
01:03:25 <elliott> What's that library for strongly-typed units? i.e. including the unit of a numeric value in its type. Or am I imagining that such a complete library exists?
01:03:57 <flux> elliott, I don't know, but perhaps they keyword 'dimensional' will help you in your quest :)
01:04:21 <elliott> flux: Argh, I knew I was trying to think of a word and I knew it started with d.
01:04:25 <elliott> I just couldn't remember the rest of it :)
01:04:34 <elliott> http://hackage.haskell.org/package/dimensional This might be it.
01:06:41 <elliott> flux: Thanks.
01:06:51 <flux> elliott, happy dimensioning!
01:18:50 <testmonad> so I guess no one in here notices this warning, eh?
01:27:01 <quicksilver> testmonad: not many people compile from source. I haven't for a long time.
01:41:35 <testmonad> hi quicksilver!
01:42:01 <testmonad> Well I really want to kind of sandbox and environment within my homedir
01:42:11 <testmonad> without any cruft or stuff from the base installation
01:42:21 <testmonad> thats why..
01:42:44 <testmonad> so I grabbed the binary distribution from ghc and the source tarball for the platform
01:43:53 <testmonad> the reason is that I actually want to use hakyll but it's not in debian stable ... and of course want to learn more haskell
01:45:01 <testmonad> quicksilver: so you just use the packages from your distro?
02:03:16 <hpaste> jonkri pasted ‚ÄúID generator‚Äù at http://hpaste.org/48773
02:03:59 <jonkri> i have an infinite list of ids (`ids p') which needs to be acquired from different threads. is this a nice way to do it? http://hpaste.org/48773
02:05:33 <tibbe> jonkri, looks ok
02:05:45 <tibbe> jonkri, I would probably just put an Int in an IORef
02:06:07 <tibbe> and use getNext = atomicModifyIORef ioref $ \ old -> (old, old + 1)
02:06:31 <tibbe> (I'm not sure about the order of the values in the pair)
02:07:23 <quicksilver> testmonad: on debian I just use the packages; on OSX I just use the platform binary
02:08:00 <tibbe> jonkri: getNext = atomicModifyIORef ioref $ \ old -> let new = old + 1 in new `seq` (new, old)
02:08:29 <Saizan> quicksilver: there's no generic linux platform binary though
02:08:31 <testmonad> quicksilver: thanks for the answer, may I ask how you go about the cabal configs?
02:08:57 <tibbe> jonkri: you can then do newtype IdGen = IdGen IORef; getNext :: IdGen -> IO Int
02:10:09 <Tomsik> Why the seq?
02:10:43 <testmonad> Saizan: besides the warning everything seems to be ok ... I was just wondering why it is there, maybe it's just a typo and nothing bad happens - but still it is a warning and thats why the question came up
02:13:55 <Saizan> testmonad: i've never installed the platform myself, so i wouldn't know :)
02:14:34 <jonkri> thanks tibbe
02:15:17 <Saizan> testmonad: mostly because i'm used to rely on cabal-install for anything other than ghc
02:18:36 <testmonad> Saizan: thanks! btw: do you use the default cabal config? I am wondering because I would like some separation.. and in fact i am quite new to this stuff : )
02:18:56 <Saizan> i use the default one
02:19:33 <Saizan> http://www.vex.net/~trebla/haskell/sicp.xhtml <- this might be a good read to get a clearer idea of what's going on
02:24:28 <testmonad> Saizan: nice, thanks for the info
02:25:01 <testmonad> as for the warning I guess I would have to file a report then
02:28:31 <tibbe> jonkri, you need to make sure that the new ID that you write in the IORef/MVar is force before it's written
02:28:36 <tibbe> forced*
02:29:24 <jonkri> tibbe, what does that mean? that it's not lazy?
02:32:01 <tibbe> jonkri, I mean that if you do e.g. putMVar $ i + 1 you'll end up writing a thunk inside the MVar, instead of first evaluating i + 1 and writing the result
02:33:06 <Jafet> putMVar $! i+1
02:33:06 <jonkri> tibbe, what would be the problem with that? btw, i'm just writing the next element in the infinite list
02:33:21 <Jafet> It might not be as efficient as you'd like.
02:33:53 <jonkri> s/in the/from the
02:34:03 <tibbe> jonkri, the problem is that it's inefficient
02:34:34 <tibbe> jonkri, and if the readers don't evaluate the ID they retrieve you will have a thunk inside the MVar that looks like 0 + 1 + 1 + 1 + ... + 1
02:34:37 <jonkri> useful function, $!
02:34:39 <tibbe> which takes memory
02:34:45 <tibbe> jonkri, yes, use $!
02:35:53 <jonkri> tibbe, would there be a thunk inside because of the sequence stuff? i don't see how a value from my list would be a thunk
02:36:17 <jonkri> my values are just strings
02:36:53 <Jafet> ("foo" ++ "bar) is a String thunk
02:37:09 <Jafet> You can have a thunk for pretty much any ordinary datatype
02:37:37 <jonkri> i just generate my strings like this: http://hpaste.org/48761
02:37:48 <jonkri> i don't think the values are thunks
02:38:08 <tibbe> jonkri, my suggestion was to not store a list inside the IORef but simply the next id
02:39:00 <Jafet> Hrm.
02:39:07 <Jafet> Why not use a Chan?
02:39:22 <jonkri> Jafet, in that case, why not use an MVar?
02:39:45 <jonkri> Jafet, and how many element would i push through the chan? :)
02:40:00 <Jafet> All of them!
02:40:00 <tibbe> jonkri, if you store a list and do something like this: putMVar $ tail mylist you will hold on to the head of the list unnecessarily
02:40:15 <Jafet> Oh, Chan isn't blocking.
02:41:14 <jonkri> tibbe, i don't follow. it's just in the mvar until something actually needs it?
02:41:28 <jonkri> s/it's/isn't it
02:41:46 <Ke> is there is nice way to prevent main thread exit
02:42:19 <Ke> if rest of the trheading code doen't use thread manager
02:42:33 <Jafet> Add ‚Äúmain‚Äù to the end
02:42:50 <Ke> no loops =o(
02:43:13 <Jafet> I don't think you can avoid writing a thread join
02:54:13 <Ke> damned deadlock detection
03:01:43 <erus`> have the packages on cabal dont build on windows
03:01:48 <erus`> what a joke
03:01:52 <erus`> half*
03:02:16 <tibbe> erus`, you can help! test them and send patches. Many OSS developers don't own a Windows machine
03:02:35 <erus`> people keep using ./configure scripts
03:02:44 <erus`> these wont work on non *nix systems
03:02:47 <tibbe> erus`, they should work in cygwin no?
03:02:48 <erus`> its not rocket science
03:03:06 <erus`> whats cygwin's install base?
03:03:10 <erus`> 0.0001%
03:03:15 <tibbe> erus`, sometimes they're necessary, to detect which C APIs are available for example
03:03:39 <erus`> well there should be a binary repository in that case
03:03:49 <tibbe> erus`, then make one!
03:04:40 <erus`> maybe i will
03:04:43 <erus`> that will show you
03:04:44 <tibbe> great
03:04:59 <erus`> then we'll see whos laughing
03:05:38 <tibbe> yes
03:06:05 <Jafet> People use Windows? What a joke.
03:06:26 <nus> the relationship is mutual (-:
03:06:46 <tibbe> erus`, one thing that could help would be to set up a working Jenkins build bot for the Haskell Platform libraries, to make sure that they don't regress
03:13:13 <erus`> tibbe: if i build packages with cygwin can i just put them in haskellplatform/lib on another pc?
03:14:50 <tibbe> erus`, if you want to distribute binary packages look at what HP does
03:15:06 <tibbe> erus`, it distributes binary and then registers them with the installed GHC I believe
03:15:25 <tibbe> erus`, GHC does ship with a built in cygwin too
03:15:44 <erus`> you ming mingw?
03:15:46 <erus`> mean*
03:15:54 <tibbe> hmm
03:15:54 <tibbe> yes
03:15:56 <tibbe> you're right
03:15:57 <tibbe> mingw
03:16:15 <erus`> how do i register a package with ghc?
03:32:23 <sheeple> is there some function Double -> Double# that unboxes a given double? the manual mentions 1.0## for unboxing literals but mentions nothing about a function that can work on general doubles
03:40:34 <SoleSoul> Hello. I need help structuring a very simple aplication I'm struggling to write. I'm too used to imperative programming. It should take a list of numbers and count how many going up eg. [1,3,4...] and then how many going down [5,2,1...]. The output of [1,2,3,4,3,2] shoud be [4,2]. 4 going up and two going down.
03:42:17 <lunaris> SoleSoul: Is a precondition that the list contains a list of ascending numbers followed by a list of descending numbers?
03:42:37 <Entroacceptor> SoleSoul: iterate over the list
03:42:47 <Entroacceptor> and you need some kind of accumulator
03:43:18 <SoleSoul> For some reason I can't find the right way to write it.
03:43:18 <SoleSoul> It should work on any number of up-down sets
03:43:40 <arcatan> what happens if you have for example [1,1]?
03:43:49 <arcatan> (as the input)
03:43:53 <SoleSoul> lunaris: no. it can be in any order and it can repeat.
03:45:16 <lunaris> SoleSoul: Positive numbers only?
03:45:28 <Entroacceptor> lunaris: why make it so complicated
03:45:30 <SoleSoul> arcatan: I thought about it and decided that it will be declared going down. After we have the first direction, up or down, we will simply don't change it.
03:46:15 <lunaris> Entroacceptor: surely those are simplifications?
03:46:23 <SoleSoul> arcatan: It could have been up, I don't really care about the beginning because there will be only long lists and the majority is what important
03:46:35 <Entroacceptor> f (x:y:xs) ups downs = if x>y then (f (y:xs) ups (downs+1)) etc...
03:47:20 <SoleSoul> I have some connection problems, I'll reconnect in a second
03:47:36 <earthy> sheeple: a Double is a D# Double#
03:47:59 <earthy> sheeple as defined in GHC.Types
03:48:16 <SoleSoul_> I'm back, sorry.
03:49:07 <earthy> @hoogle D#
03:49:07 <lambdabot> No results found
03:49:16 <SoleSoul> arcatan: did you receive my answer because I couldn't see any reply for some reason.
03:49:24 <earthy> sheeple: http://hackage.haskell.org/packages/archive/base/latest/doc/html/GHC-Exts.html#v:D-35-
03:49:31 <SoleSoul> arcatan: I changed irc client
03:50:49 <sheeple> earthy: yeah, that's exactly what I needed, thanks!
03:54:20 <Y_Less> Quick question, was anyone here at CEFP '11?
03:58:59 <JaffaCake> Y_Less: I was
04:00:08 <Entroacceptor> SoleSoul: can you really consider the "1" as going up?
04:00:42 <Y_Less> JaffaCake: Cool, does the beer bike mean anything to you, and if so can I pm you?
04:00:59 <JaffaCake> oh yes, I remember the beer bike well :)
04:01:06 <SoleSoul> Entroacceptor: I don't understand the question. I check sequences. I start with 0. if the first item on the list is above 0 it's going up
04:01:28 <SoleSoul> Entroacceptor: Now I see I can drop the zeroes at the beginning
04:01:39 <Entroacceptor> SoleSoul: ah, if you start with 0, it's easy
04:02:23 <Entroacceptor> (at least my trivial solution
04:02:26 <SoleSoul> Entroacceptor: I really appreciate your help. It looks so easy but I'm having trouble with the structure of the functions...
04:02:38 <SoleSoul> Entroacceptor: I'm quite new
04:03:27 <hpaste> Entro pasted ‚Äúcounting ups‚Äù at http://hpaste.org/48776
04:03:32 <Entroacceptor> SoleSoul: ^^
04:03:52 <Entroacceptor> but that would [4,3,2,1] count as (1,3)
04:05:48 <SoleSoul> Entroacceptor: That's fine. I don't care about the beginning. The lists are going to be very long.
04:06:48 <Entroacceptor> it counts steps, though, so [1,2,2,2,1] still gives (2,1)
04:06:53 <Entroacceptor> if that's what you want
04:07:38 <Entroacceptor> afk
04:08:51 <SoleSoul> Entroacceptor: I'm really sorry for the delay in my answer. My mother called me. [1,2,2,2,1] should output [4,1]
04:09:43 <SoleSoul> because 0 up to 1 up to 2 then stays there for 2 more, that's 4 up
04:30:39 <Entroacceptor> SoleSoul: ah, then I misunderstood
04:30:59 <Entroacceptor> that makes the helper a bit harder
04:31:24 <Entroacceptor> but what with [4,4,3,1,2,2,3]?
04:31:31 <SoleSoul> Entroacceptor: :) It's purpose is to measure the stability of a wave. How long it stays going up and down.
04:31:35 <Entroacceptor> would the 2s be up or down?
04:31:45 <SoleSoul> up
04:31:52 <SoleSoul> because they are after 1
04:34:01 <Entroacceptor> SoleSoul: then you need one more akku, which saves GT or LT and counts that number in the EQ statement of that case
04:34:12 <Entroacceptor> ok, I wouldn't understand that, either ^^
04:34:37 <SoleSoul> I think I understand the idea.
04:35:09 <SoleSoul> It's much more complicated than imperative thinking. Is it supposed to be more complicated? :p
04:35:12 <Jafet> Numerical differentiation?
04:35:36 <dibblego> what is the unicode symbol for 2*pi?
04:35:44 <Jafet> SICP does that, I think
04:36:01 <Botje> dibblego: tau >:)
04:36:30 <Jafet> Not 2œÄ?
04:36:41 <Entroacceptor> SoleSoul: it's just different ;)
04:36:50 <verement> œÑ
04:36:56 <dibblego> that's him, thanks!
04:37:01 <Entroacceptor> and my solution is very amateurish, too, I don't find time to program more
04:37:08 <ziman> dibblego, are you solving the crossword? :)
04:37:15 <dibblego> crossword?
04:37:25 <ziman> i mean, the one in monad.reader.
04:37:30 <dibblego> no
04:37:30 <ziman> (obviously not.)
04:40:55 <jonkri> how can i validate an ipv4, ipv6, or hostname address?
04:41:22 <jonkri> i have found these two functions but there is not hostname function exposed: http://hackage.haskell.org/packages/archive/network/2.3.0.4/doc/html/Network-URI.html#v:isIPv6address
04:41:43 <jonkri> i've been googling some but haven't found anything... i'm thinking i can't be the only one with this problem :P
04:43:35 <hpaste> Entro annotated ‚Äúcounting ups‚Äù with ‚Äúcounting ups (annotation)‚Äù at http://hpaste.org/48776#a48777
04:44:01 <Entroacceptor> SoleSoul: erm
04:44:02 <Entroacceptor> wt
04:44:24 <SoleSoul> ?
04:44:25 <hpaste> Entro annotated ‚Äúcounting ups‚Äù with ‚Äúcounting ups (annotation)‚Äù at http://hpaste.org/48776#a48778
04:44:31 <SoleSoul> did you ask something?
04:44:35 <Entroacceptor> ah, my browser just hiccuped
04:44:39 <Entroacceptor> look at my annotation
04:45:41 <SoleSoul> Entroacceptor: sry, what do you mean by annotaion?
04:45:56 <Entroacceptor> to the paste
04:46:02 <Entroacceptor> http://hpaste.org/48776#a48778
05:05:15 <SoleSoul> Entroacceptor: Silly me! I didn't know about the integration between hpaste and the channel. I'm reading it now. Thank you very much for your effort!!
05:06:17 <Entroacceptor> SoleSoul: ah :)
05:16:04 <SoleSoul> Entroacceptor: Looks good! I'll do some little changes to integrate it into my application. I surprises me how much thinking is needed in order to get used to new programming paradigm.
05:16:19 <Entroacceptor> well
05:16:26 <Entroacceptor> it's a new paradigm, what did you expect? :)
05:39:13 <MasseR> How does 'liftM2 (&&) foo bar' behave? Is bar executed even if foo is false?
05:39:30 <Axman6> yes
05:39:37 <Axman6> @src liftM2
05:39:37 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
05:40:09 <zygoloid> the short-circuiting behaviour is lifted to the value(s) extracted within the monad, but not to the monadic computation itself
05:40:14 <MasseR> Is manually checking the first condition my only option?
05:40:52 <Axman6> you could have andM: andM a b = do { x <- a; if a then b else return false }
05:41:44 <aavogt> @ty andM a b = do { x <- a; if a then b else return False }
05:41:45 <lambdabot> parse error on input `='
05:41:56 <aavogt> @ty \a b -> do { x <- a; if a then b else return False }
05:41:57 <lambdabot>     Couldn't match expected type `Bool' against inferred type `m t'
05:41:57 <lambdabot>     In the expression: a
05:41:58 <lambdabot>     In the expression: if a then b else return False
05:42:26 <zygoloid> @type let andM a b = do { x <- a; if x then b else return False} in andM
05:42:27 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
05:42:46 <Axman6> that's the one i was after
05:43:36 <aavogt> if you went for name shadowing, that error would have been impossible
05:43:41 <aavogt> @ty \a b -> do { a <- a; if a then b else return False }
05:43:42 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
05:43:46 <MasseR> :D
05:43:51 <parcs> :t liftM2 (||)
05:43:52 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
05:44:25 <romildo> Hi.
05:44:31 <ion> @unpl liftM2 (&&)
05:44:31 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b && a))
05:44:41 <ion> Oh, cool, unpl handles lift*
05:44:52 <romildo> Is there a curses like library for Haskell that works on Windows 7?
05:44:54 <Axman6> sure...
05:45:03 <ion> @unpl liftA2 (&&)
05:45:03 <lambdabot> liftA2 (&&)
05:45:26 <Axman6> parcs: that doesn't have the same semantics as andM
05:45:58 <parcs> @. do unpl liftM2 (&&)
05:45:58 <lambdabot> (\ d e -> do { b <- d; a <- e; return (b && a)})
05:46:23 <ion> @@ @pl @unpl liftM2 (&&)
05:46:23 <lambdabot>  liftM2 (&&)
05:46:31 <ion> @@ @pl @undo @do @unpl liftM2 (&&)
05:46:31 <lambdabot>  liftM2 (&&)
05:46:33 <Axman6> the monad in question may have side effects, and andM doesn't run b unless a is true
05:46:33 <parcs> Axman6: i see
05:46:38 <kingping> ı*È!
05:47:40 <jonkri> what parsec function can i use to read all the input except the last one? many seems to read everything, even if it's followed by a oneOf and eof
05:47:59 <ion> Except the last what?
05:48:39 <jonkri> the list char (i'm parsing a string)
05:48:42 <jonkri> last
05:48:53 <c_wraith> parsec does not backoff, no
05:48:53 <lambdabot> c_wraith: You have 1 new message. '/msg lambdabot @messages' to read it.
05:49:12 <c_wraith> you need a backtracking parser to do that
05:50:04 <jonkri> ok
05:51:35 * wli doesn't think backtracking is such a bad thing.
05:52:48 <ion> > let charNotFinal = Text.Parsec.try $ anyChar <* lookAhead anyChar in parse (Text.Parsec.many charNotFinal) "" "foobar"
05:52:49 <lambdabot>   Not in scope: `Text.Parsec.try'Not in scope: `anyChar'Not in scope: `lookAh...
05:52:51 <ion> Right "fooba"
05:54:23 <kingping> > (+) <$> Just 3 <*> Just 2
05:54:24 <lambdabot>   Just 5
05:54:50 <kingping> > let foo x = x + 2
05:54:51 <lambdabot>   not an expression: `let foo x = x + 2'
05:55:17 <ion> @tell jonkri let charNotFinal = try $ anyChar <* lookAhead anyChar in parse (many charNotFinal <* anyChar <* eof) "" "foobar"
05:55:17 <lambdabot> Consider it noted.
05:56:19 <magicman> :t \f x -> fromMaybe x (f x)
05:56:20 <lambdabot> forall a. (a -> Maybe a) -> a -> a
05:56:34 <magicman> @pl (a -> Maybe a) -> a -> a
05:56:34 <lambdabot> (line 1, column 4):
05:56:34 <lambdabot> unexpected ">"
05:56:34 <lambdabot> expecting variable, "(", operator or ")"
05:56:47 <Jafet> @djinn (a -> Maybe a) -> a -> a
05:56:48 <lambdabot> f a b =
05:56:48 <lambdabot>     case a b of
05:56:48 <lambdabot>     Nothing -> b
05:56:48 <lambdabot>     Just c -> c
05:56:51 <magicman> Oh, derp.
05:56:54 <magicman> Djinn, not pl >_<
05:57:12 <Jafet> Meh, I expected flip const
05:57:54 <ion> @tell jonkri let notFinal p = try (p <* lookAhead anyToken) in parse (many (notFinal anyChar) <* anyChar <* eof) "" "foobar"
05:57:54 <lambdabot> Consider it noted.
06:00:50 <bgamari> ghc should inline a function passed as an argument, correct?
06:01:54 <Botje> maybe.
06:03:34 <bgamari> Botje: Is there a way to force this or should I just trust that it's doing the right thing?
06:03:39 <opqdonut> bgamari: if you have a call like "foo f", "f" won't get inlined inside "foo". however "foo" might get inlined at this call site, and then "f"
06:03:53 <opqdonut> trust GHC, read the manual on tuning inlining
06:04:17 <hpaste> ‚ÄúBen Gamari‚Äù pasted ‚ÄúSlowdown after abstraction‚Äù at http://hpaste.org/48779
06:04:34 <bgamari> alright
06:04:40 <bgamari> I'll take a look
06:05:03 <opqdonut> there is an inline pragma, and you can give inlining thresholds as parameters to a ghc invocation
06:05:05 <bgamari> This is my attempt at using something like a fold to process my sparse vector
06:05:18 <bgamari> Unfortunately it's 3 times slower than the initial form
06:05:23 <bgamari> despite doing effectively the same thing
06:06:10 <bgamari> I'm not sure whether to blame this on lack of inlining or something else
06:06:11 <opqdonut> (can help noticing you've typoed the function name in the SPECIALIZE pragma)
06:06:26 <opqdonut> (SPECIALIZE dot' should be SPECIALIZE odot', right?)
06:06:46 <bgamari> hmm, you are right
06:07:02 <bgamari> odot is the old implementation
06:07:11 <bgamari> pdot is the new implementation, folded
06:07:23 <opqdonut> yeah
06:07:48 <bgamari> Someone suggested odot could be implemented as a foldable yesterday
06:07:52 <opqdonut> you might want to look at how the cores for those functions differ
06:08:03 <bgamari> this was as close as I could come to this
06:08:05 <opqdonut> (install ghc-core, run ghc-core File.hs, read and weep)
06:08:08 <bgamari> alright
06:13:10 <bgamari> pdot is in the list of PreInlineUnconditionally
06:22:58 <robertcosty> public
06:24:19 <robertcosty> need help!!!
06:24:26 <dylukes> With?
06:24:46 <robertcosty> "REBORN Z80(interpretor B.A.S.I.C )"
06:25:08 <robertcosty> on c++ or asm
06:26:25 <robertcosty> BASIC interpreter (original) rewritten in: DOS, ASM, any bootable Z80 - BASIC ROM (HC-90 or equivalent) for rewritten. x86 ASM or CPP. Interesting to do a remake of Basic Z80-ROM (or full-16K ROM) for 32bit color :-). At least for CPP HOBBY Programator
06:26:41 <Cale> robertcosty: What does it have to do with Haskell?
06:27:34 <Cale> (Other than Haskell being a great language to write language implementations in :)
06:28:52 <Botje> robertcosty: this is not a 'c++ or asm' programming channel, sorry.
06:29:01 <Botje> robertcosty: if you're willing to learn haskell, we can help you when you get stuck, though
06:29:37 <robertcosty> ok thanks but what chanel is for prog and coding ???
06:29:38 <robertcosty> pls
06:29:59 <Jeanne-Kamikaze> ##programming
06:30:15 <Botje> robertcosty: do you want to _learn_ how to program it or do you want someone to program it for you?
06:30:17 <Nisstyre> Why does every attempt at explaining Monads seem entirely different from every other one?
06:30:21 <Cale> robertcosty: There are many channels on this network for specific programming languages.
06:30:34 <Botje> Nisstyre: because of the monad tutorial fallacy
06:30:44 <Cale> Nisstyre: Because people have different ways to explain something rather abstract.
06:30:59 <Nisstyre> yeah, but I can't find any kind of consistent idea
06:31:00 <Botje> Nisstyre: jump in and play around with them. once you are no longer surprised by type errors you 'get' monads.
06:31:09 <Nisstyre> other than the idea of it being a container
06:31:14 <Cale> Nisstyre: Okay, then take my tutorial (which isn't really a tutorial) :)
06:31:21 <Cale> http://www.haskell.org/haskellwiki/Monads_as_computation
06:31:26 <sipa> the only way to really understand monads, is not through reading a tutorial, but by an insight that leads to thinking "damn, i could explain this much better in a much better way!"
06:31:32 <Cale> (I also wrote Monads as containers)
06:31:39 <Nisstyre> okay
06:31:48 <Botje> I really liked 'you may have already invented monads'
06:32:12 <Nisstyre> It seems similar to duck typing in a way, is that true?
06:32:25 <Cale> Nisstyre: no
06:32:48 <Nisstyre> no? I thought  you could implement a Monad in different ways as long as it satisfied some rules
06:33:00 <Cale> Oh, well, I suppose.
06:33:06 <Cale> It's an abstraction
06:33:09 <Nisstyre> yeah
06:33:13 <Cale> You could say the same thing of any abstraction
06:33:23 <Nisstyre> true
06:33:31 <Jafet> That's the concept behind type classes, not Monad
06:33:34 <Botje> Nisstyre: there are very few correct ways to implement a given monad
06:34:26 <Cale> Or, perhaps more precisely, given a type constructor T, there will generally not be many implementations of return and (>>=) which make T into a monad.
06:35:12 <Cale> (really, the monad is the whole setup of T, together with the specific return and >>= provided)
06:36:31 <Cale> Nisstyre: But the main idea is that it's sort of a "shape" that many libraries fit into -- it's a pattern which comes up quite often in libraries, and so we give it a name and let you write some code which works with *any* of the libraries that fits into that shape.
06:36:54 <Nisstyre> that makes sense
06:37:09 <Cale> Same goes for Functor, Applicative, Arrow, Comonad, and lots of other abstractions we like to play with.
06:37:14 <Nisstyre> you get all the benefits of that if you make it a Monad right?
06:37:19 <Cale> yeah
06:37:28 <Cale> So, you get all the functions in Control.Monad for free
06:37:41 <Cale> and don't have to implement them specially for your library if it happens to be a monad
06:38:10 <Cale> for example, take sequence
06:38:21 <Cale> sequence :: Monad m => [m a] -> m [a]
06:38:50 <Cale> In the IO monad, it takes a list of IO actions, and produces an IO action which runs them all in order and constructs a list of their results
06:39:29 <Cale> In the list monad, "running" a list means to pick an element from it in all possible ways, and so sequence takes a list of lists, and constructs a list of all ways to pick one element from each of them
06:39:35 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
06:39:36 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
06:39:47 <Cadynum> what kind of code quality is expected to upload something to hackage?
06:39:54 <Cale> Cadynum: Not much
06:40:04 <Cale> Cadynum: There's code on hackage of all levels of quality
06:40:10 <Entroacc1ptor> Cadynum: I told you
06:40:18 <Cale> Probably you should make sure that it builds
06:41:23 <Cale> Nisstyre: In a parsing monad, sequence will take a list of parsers, and produce a parser which parses their concatenation (producing a list of their results)
06:41:23 <Cadynum> Cale, ok, so if it might be useful i shouldnt hesitate to upload it
06:41:28 <Cale> Cadynum: yeah
06:42:37 <Nisstyre> Cale: it's starting to make more sense
06:42:57 <Nisstyre> reading over that page now (monads as computations)
06:43:34 <Jafet> Monads as applicative functors
06:44:41 <Nisstyre> Cale: I think I got it kind of. Monads are kind of like small languages that let us do things that would normally only be possible in imperative styles, or through kludgey hacks.
06:44:44 <Nisstyre> is that kind of right?
06:44:58 <Nisstyre> and they all share some common things
06:45:01 <mauke> I don't see how that applies to []
06:45:07 <mauke> or (->) e
06:48:44 * hackagebot SessionLogger 0.3.0.0 - Easy Loggingframework  http://hackage.haskell.org/package/SessionLogger-0.3.0.0 (GeroKriependorf)
06:53:15 <zygoloid> Nisstyre: Monads are kind of like a way to work in another language ("category"), so long as 1) that language can be represented in haskell, 2) there is an embedding of haskell within the language, and 3) the resulting representation of that language within itself can be 'nicely' flattened
06:54:42 <duobei> a newbie
06:55:15 <Botje> where?!
06:55:36 <duobei> China
06:56:07 <Botje> well, hello!
06:56:36 <duobei> Hi. This is my first time that I use the IRC.
06:57:18 <duobei> And it's so cool in emacs.
06:57:34 <sipa> IRC is just multiplayer emacs
06:57:51 <zygoloid> duobei: are you interested in haskell?
06:58:10 <duobei> Yeah.
06:58:20 <zygoloid> then you're in the right place :)
06:59:03 <duobei> But ,sorry, I don't talk about Haskell.
06:59:20 <duobei> the first time.
07:00:04 <Jafet> We just talk about fight club
07:00:11 <zygoloid> ssh!
07:00:43 <zygoloid> > fix $ ("the first rule of fix club is " ++) . show
07:00:45 <lambdabot>   "the first rule of fix club is \"the first rule of fix club is \\\"the firs...
07:01:21 <Cale> Nisstyre: Well... they organise a certain kind of operation. It's not necessarily terribly imperative, but there's an imperative way to look at any monad.
07:01:49 <Cale> and we can accomplish anything we can do with monads without recognising that there's a monad there
07:02:21 <Cale> It's just nice to give a name to that pattern of code, so that we can share functionality.
07:02:31 <Cale> (of all the things which work in any monad)
07:03:47 <Cale> Nisstyre: People tend to make a bigger deal out of it than it really is.
07:04:39 <Cale> Nisstyre: One thing in particular it's best not to be confused about is that even if IO weren't recognised to be a monad, we could still have values that represented IO actions and various operations for gluing them together.
07:05:24 <Cale> It's just that some of the natural operations for gluing together IO actions happen to get us a monad, and we can recognise and formalise that with an instance in the library.
07:07:23 <RichardBarrell> sipa: "IRC is multiplayer Emacs" <- I'm using ERC from within Emacs, does that make it better or worse?
07:08:06 <Nisstyre> Cale: I might try implementing one in Python for this templating engine I was thinking of writing
07:09:12 <Cale> Nisstyre: The tricky thing about making use of the fact that something is a monad in most other languages is providing a way to write code which will work in any monad.
07:09:23 <Cale> (because without that, it's kinda pointless)
07:09:39 <Cale> Note that return in particular is polymorphic just in its result type
07:09:54 <Cale> which is something that a lot of languages (OO languages in particular) struggle with
07:10:15 <Nisstyre> hmm okay
07:15:19 <duobei> help
07:15:57 <Botje> with what?
07:16:44 <Cale> Nisstyre: One way to do it is to add a parameter to return and bind which essentially consists of a dictionary consisting of their implementations (so return and bind just become accessor functions)
07:16:57 <Cale> Nisstyre: but that tends to lead to somewhat awkward looking code
07:17:06 <Cale> (because you have to pass that dictionary around)
07:17:55 <Cale> There are ways to make it work, it's just that the barrier to making it a useful abstraction is a little higher.
07:18:10 <Cale> (which is part of the reason why monads aren't frequently used outside Haskell)
07:20:38 <tpmnews> h
07:25:09 <guerrilla> so i have some functions chained with =<< like composeA =<< composeB =<< composeC and i'd like composeC to know it's being used "inside" of a composeB "inside of a composeA and so on.  is there an elegant way to do that? i was thinking maybe put a withcontext or whatever before each invocation like composeA =<< withContext A composeB =<< withContext B composeC  but this just seems klunky. better way?
07:25:37 <Jafet> What's the context?
07:25:56 <Cale> It would be nice to have more context here, but I think the monad laws specifically prohibit that.
07:26:00 <Cale> well...
07:26:05 <Cale> Depending on what you mean
07:26:25 <guerrilla> jeltsch: an example for what would be available in composeC would be like AFocus (BFocus) or something
07:26:28 <Cale> Actually...
07:26:43 <Cale> The reverse state monad might be able to do something kinda like that.
07:26:53 <guerrilla> reverse state monad? never heard of it?
07:27:00 <guerrilla> what's it called? so i can hoogle it
07:27:15 <Cale> Just "the reverse state monad". It's not in the standard libraries.
07:27:24 <guerrilla> hmm ok
07:27:32 <Cale> I don't even know if it's on Hackage
07:27:49 <Cale> It's the same thing as the state monad, but the state is wired up "wrong"
07:27:59 <Cale> Do you know how the State monad works?
07:28:05 <guerrilla> Cale: yeah
07:28:15 <guerrilla> i'm using the statemonad. thats how this 'context'/'focus' would work
07:28:16 <Cale> you have a newtype State s a = S (s -> (s,a))
07:28:35 <Cale> with  runState (S f) x = f x
07:28:41 <mauke> I have something like a reverse ST monad
07:28:43 <Cale> and then
07:29:10 <Cale> x >>= f = S (\s -> let (s',v) = runState x s; (s'',w) = runState (f v) s' in (s'',w)
07:29:11 <Cale> )
07:29:17 <Cale> yeah?
07:29:19 <guerrilla> yeah
07:29:42 <Cale> But there's one main way we could make a mistake in writing this, and it produces something interesting :)
07:30:03 <guerrilla> the type would still be s -> (s, a)?
07:30:13 <guerrilla> "explaining that it used the state from the next computation and passed it to the previous one" <-- seems like it may fit the bill
07:30:19 <Cale> x >>= f = S (\s -> let (s'',v) = runState x s'; (s',w) = runState (f v) s in (s'',w))
07:30:30 <Cale> We can wire up the state in reverse
07:30:55 <guerrilla> interesting
07:30:58 <Cale> So the state now flows backwards in time :)
07:31:07 <Cale> It becomes extremely easy to write infinite loops
07:31:09 <guerrilla> indeed
07:31:25 <Cale> do xs <- get; put (1:xs); return xs
07:31:35 <Cale> will return the list [1,1,1,1,...]
07:31:38 <guerrilla> hmm so.. i wonder if i could just use that bind operation on top of the regular state monad so i dont need yet another monad transformer
07:32:35 <guerrilla> i'm not entirely sure this would work.. have to think.. hmm
07:32:56 <guerrilla> nice concise example btw :)
07:33:07 <Cale> You want previous things in your computation to know about what's coming in the future, right?
07:33:48 <guerrilla> yeah composeC needs to know it *will* be used in composeB and so on.. so yes, i beleive so
07:33:53 <guerrilla> making sense...
07:35:56 <guerrilla> hmm, i'll play with this..
07:36:44 <guerrilla> hmm, this is essentially the same as the withContext then except moving the indication of what context we're in to the appropriate function
07:36:47 <guerrilla> which is what i want
07:36:49 <guerrilla> ok.. cool
07:36:52 <guerrilla> thanks a lot Cale
07:36:56 <Cale> guerrilla: no proble
07:36:58 <Cale> m*
07:37:00 <guerrilla> mauke: hi :) is it small enough to hpaste?
07:37:25 <Cale> hmmm... reverse ST :)
07:37:36 <mauke> http://mauke.dyndns.org/stuff/haskell/posi.hs
07:37:41 <Cale> I think I can imagine how that could go
07:37:42 <mauke> http://mauke.dyndns.org/stuff/haskell/Positronic.hs
07:37:47 <zztr> does anyone do haskell one liners from the command line? this is less than ideal: http://pastebin.com/yt7ttm4x
07:37:47 <mauke> warning: old code
07:37:48 <mauke> The paste yt7ttm4x has been copied to http://hpaste.org/48781
07:38:06 <guerrilla> ok
07:38:08 <Jafet> zztr: ghci is a fairly adequate shell
07:38:18 <mauke> zztr: ghc -e '8 + 2.4'
07:38:44 <Jafet> mauke: nice
07:39:12 <guerrilla> Cale / mauke: i think i'll just steal cale's operator for now and use that nearly as is. need to modify for use in StateT
07:39:16 <Jafet> Oleg also implemented fix with lazy ST, by the way
07:39:19 <zztr> oh, cool i just needed to not use ghci
07:39:25 <zztr> thanks :)
07:40:10 <guerrilla> Jafet: sorry what's oleg?
07:40:23 <Jafet> @quote millioleg
07:40:23 <lambdabot> olsner says: < kmc> i think 250 milliolegs is enough to kill an elephant  < olsner> kmc: ... to kill an elephant - in the type system!
07:41:00 <guerrilla> ?
07:41:02 <Jafet> A researcher who sometimes writes interesting code in Haskell.
07:41:06 <guerrilla> oh ok
07:41:13 <guerrilla> i see liboleg in hackage
07:41:17 <Cale> guerrilla: Oleg is a guy who writes absurdly complicated type-level programs and libraries and posts them to the mailing lists.
07:41:19 <mauke> @where oleg
07:41:19 <lambdabot> http://okmij.org/ftp/
07:41:42 <Jafet> Well, he's best known for that
07:42:01 <rostayob> oleg is fun
07:42:15 <rostayob> I remember looking a his polyvariadic functions in haskell ahah
07:42:24 <guerrilla> yeah, i see what you mean. this liboleg is interesting. huge types
07:42:57 <guerrilla> ah he wrote iteratee io
07:43:28 <guerrilla> cool
07:48:21 <copumpkin> is it just me, or is instance Applicative State (without the Monad instance) not very useful?
07:49:02 <quicksilver> if you're allowed to use modify then it has some use I think
07:49:40 <quicksilver> actually, no, it's useful anyway
07:49:48 <copumpkin> how so?
07:49:50 <guerrilla> [re: above] so, the other alternative (besides making everything take monad arguments) is to do postprocessing. maybe that is simpler...
07:49:54 <quicksilver> applicative state is enough to number the leaves in a tree, no?
07:50:09 <copumpkin> what can you do with it? you can't even increment a counter in it
07:50:20 <dolio> @type traverse
07:50:21 <lambdabot> Not in scope: `traverse'
07:50:31 <dolio> @type T.traverse
07:50:31 <lambdabot> Couldn't find qualified module.
07:50:41 <copumpkin> @ty Data.Traversable.traverse
07:50:41 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
07:50:57 <dolio> traverse = mapAccumL
07:51:02 <dolio> For f = State s.
07:51:21 <copumpkin> yeah, but I'm saying if you only have the applicative interface to it
07:51:28 <copumpkin> you can't really do anything with it?
07:51:35 <copumpkin> if you can construct custom state actions, sure
07:51:55 <dolio> Can you do anything with [] using only the monad interface?
07:52:23 <matthiasgorgens> dolio, yes.
07:52:25 <copumpkin> not anything, but more interesting things
07:52:41 <dolio> You can construct singleton lists and bind them together.
07:52:44 <matthiasgorgens> dolio, do you mean any one thing, or everything?
07:52:48 <dolio> So it's a fancy identity monad.
07:53:42 <copumpkin> I dunno, State still feels more "Monadey" somehow
07:53:52 <Cale> any monad with only the monad interface is just a fancy identity monad
07:54:08 <dolio> Exactly.
07:54:28 <dolio> @type state
07:54:29 <lambdabot> forall s a. (s -> (a, s)) -> State s a
07:54:57 <dolio> @type stateT
07:54:57 <lambdabot> Not in scope: `stateT'
07:56:18 <mauke> gentlemen: fail
07:56:23 <copumpkin> can anyone see what I'm trying to say? :P
07:56:43 <ezyang> @seen mightybyte
07:56:44 <preflex>  mightybyte was last seen on #haskell 4 days, 21 hours and 57 minutes ago, saying: sm: Look at First from Data.Monoid
07:56:44 <lambdabot> Unknown command, try @list
07:56:54 <dolio> Are you saying you can't write modify using get, put and applicative?
07:57:24 <copumpkin> I guess
07:57:36 <copumpkin> it feels like a glorified writer (without the need for a real monoid) without monad
07:57:59 <copumpkin> but I guess writer is kind of the opposite
07:58:15 * copumpkin shrugs
07:59:21 <angstrom> http://ideone.com/cZnwM is there a way to get rid of the code duplication in lines 2 through 8 and, likewise, 10 through 12?
08:00:24 <Cale> angstrom: [a1,a2,a3,a4,a5,a6,a7] <- replicateM 7 ['a'..'z']
08:00:26 <Twey> angstrom: [a1, a2, a3, a4, a5, a6] <- replicateM 6 ['a' .. 'z']
08:00:38 <Twey> Er
08:00:44 <Twey> angstrom: [a1, a2, a3, a4, a5, a6, a7] <- replicateM 7 ['a' .. 'z']
08:00:56 <angstrom> awesome :)
08:01:04 <Cale> and  [c1,c2,c3] <- replicateM 3 ['A'..'Z'] of course
08:08:23 <ion> Heretics! [a0, a1, ‚Ä¶], [c0, c1, ‚Ä¶]
08:13:06 <c_wraith> ezyang: mightybyte is usually in #snapframework even when he isn't here
08:18:11 <monadic> Is there a cabal testsuite interface to quickcheck available yet
08:19:52 <dcoutts> monadic: not released
08:20:02 <dcoutts> at least, not using the detailed interface
08:20:15 <dcoutts> you can use test-framework with the basic interface
08:24:37 <monadic> dcoutts: Could you elaborate a bit? Or give a link? The docs for Distribution.TestSuite don't give any idea on how to use PureTestable (although they show ImpureTestable)
08:24:59 <dcoutts> monadic: Distribution.TestSuite is not designed for end users writing tests
08:25:12 <dcoutts> it's designed for libraries like test-framework
08:25:46 <dcoutts> monadic: also, the library api is still under discussion
08:26:19 <dcoutts> monadic: if you're interested in that design then there's threads about it on the cabal-devel mailing list
08:26:29 <dcoutts> we'd welcome other voices
08:26:52 <monadic> dcoutts: Okay.
08:28:59 * hackagebot pontarius-xmpp 0.0.6.0 - A prototyped and incomplete implementation of RFC 6120:  XMPP: Core  http://hackage.haskell.org/package/pontarius-xmpp-0.0.6.0 (JonKristensen)
08:30:08 <monadic> Oh, I have another unrelated question: I have multiple executables, how do I stop them from rebuilding the common parts every time? I tried adding a library with the common modules but it didn't solve the issue
08:32:31 <tidel> :Q
08:32:41 <dpratt71> how can I determine the version of ghc?
08:33:02 <quicksilver> ghc --version
08:33:08 <dpratt71> quicksilver: thanks
08:42:30 <dpratt71> in issue 18 of the Monad Reader, it says: "...[monad comprehensions] will be available in GHC starting
08:42:30 <dpratt71> with the 7.2 release"
08:43:00 <dpratt71> even the dev snapshots of GHC appear to be @ 7.1.2
08:43:36 <dpratt71> does that mean the feature is not in any public build of GHC?
08:44:00 <Saizan> devs are odd, releases are even
08:44:11 <dpratt71> oh
08:44:30 <Saizan> but yeah, 7.2 has not happened yet
08:44:30 <flux> you're saying.. GHC devs are odd?
08:44:50 <dpratt71> Saizan: got it, thanks
08:45:18 <RichardBarrell> dpratt71: similar to Linux's version numbering scheme. "Never trust odd-numbered releases."
08:46:13 <dpratt71> RichardBarrell: I live in the Windows world where the mantra is "it takes three versions to get it right" :)
08:46:53 <thoughtpolice> dpratt71: the version number in the git repo was changed to 7.3 about 2 days ago
08:47:24 <thoughtpolice> the 7.2 branch was cut about a week ago
08:47:43 <thoughtpolice> it'll probably happen here in a week or two
08:47:44 <dpratt71> thoughtpolice: ok, thanks
08:49:26 <dpratt71> GHC is one of those things that should not be updated if you're using the Haskell Platform, yes? Outside of upgrading the platform, I mean
08:50:04 <quicksilver> correct.
08:50:30 <dpratt71> quicksilver: ok, thanks
08:51:49 <Saizan> on linux is almost orthogonal, since a new ghc version simply won't see the packages for the old one and everything is versioned enough that they coexist
08:52:00 <Saizan> on windows i think there's some clash
08:52:51 <Yrogirg> hey guys, there a question (rather common I think) that I was wonder for a long time. How does haskell declaration x = 2 corresponds to the usual definition of a function? What is the domain of x = 5?
08:53:22 <quicksilver> Yrogirg: it's not a function. It's a value.
08:53:39 <hpc> a function is a value with the "lambda" constructor
08:53:43 <sipa> (\x -> 2) would be a function
08:53:59 <sipa> :t (\x -> 2)
08:54:00 <lambdabot> forall t t1. (Num t1) => t -> t1
08:56:13 <Yrogirg> so not everything is a function?
08:56:22 <dpratt71> there's a school of thought that considers Haskell values to be functions of a sort, is there not? Do we consider that a heretical point of view?
08:56:30 <Saizan> no
08:56:49 <sipa> no
08:57:09 <sipa> Things should be made as simple as possible, but not simpler.
08:57:10 <monadic> yes
08:57:14 <monochrom> clearly, () is not a function
08:57:18 <Saizan> (though, tbf, x = 2 is polymorphic enough that it could be used as a function, but not in the sense you mean)
08:57:51 <monochrom> the "but not simpler" part is redundant
08:58:12 <sipa> yet i consider calling every value in haskell an oversimplification
08:58:18 <sipa> *a function
08:58:31 <kmc> Yrogirg, a function is anything whose type is of the form (A -> B) for types A, B
08:58:40 <kmc> (or is polymorphic enough to be compatible with that type)
08:58:52 <ziman> conal elliott wrote about that here: http://conal.net/blog/posts/everything-is-a-function-in-haskell/
08:59:03 <ion> > 4 5
08:59:04 <lambdabot>   4
08:59:33 <kmc> Yrogirg, part of the confusion is that most languages use functions for three unrelated things: argument dependence, side effects, and delayed evaluation
08:59:41 <kmc> in Haskell these are separate features
08:59:51 <monadic> Also note that you wouldn't consider (+2) to be higher order, so clearly an instance of Num, like Int, isn't a function
09:00:46 <kmc> handled respectively by functions, IO actions, and all expressions (due to non-strict ("lazy") evaluation)
09:00:54 <sipa> one thing that's often forgotten: in many languages, a function is a very tightly with a syntactic construct for function definitions
09:00:55 <monochrom> I also don't consider id :: a->a higher-order, even though it could be, by choosing suitable a
09:01:07 <sipa> in haskell, a function is a property of an expression
09:01:14 <kmc> monadic, it could be, though.  You can write the instance Num (Double -> Double) and it even has some reasonable meaning
09:01:19 <hpaste> ‚ÄúBen Gamari‚Äù pasted ‚ÄúA better way?‚Äù at http://hpaste.org/48784
09:01:28 <ion> > let a = () in –∞ 42
09:01:29 <kmc> mathematicians like to talk about rings of functions and such
09:01:30 <lambdabot>   43
09:01:40 <kmc> they're even an inner product space!
09:01:42 <bgamari> Anyone see a better way to implement readStamps seen in http://hpaste.org/48784
09:01:50 <bgamari> I'm clearly missing something
09:02:13 <kmc> sipa, i'm not sure about "many languages".  most popular languages have first-class functions
09:02:23 <hpaste> ‚ÄúBen gamari‚Äù annotated ‚ÄúA better way?‚Äù with ‚ÄúA better way? (another implementation)‚Äù at http://hpaste.org/48784#a48785
09:02:41 <dpratt71> not being a mathmetician or anything close to it, I'm curious to know how this subject is dealt with in that world
09:02:58 <kmc> (f + g) x = f x + g x
09:03:04 <dpratt71> I know there are nullary functions (Wikipedia tells me so)
09:03:05 <bgamari> My first implementation worked (although I think the endianess was wrong)
09:03:23 <dpratt71> could a value like pi be considered a nullary function?
09:03:27 <kmc> dpratt71, mathematicians are less precise about arity and such
09:03:27 <bgamari> then I tried switching to the Get monad and now I stack overflow, understandably
09:03:45 <kmc> "Sometimes it is useful to consider a constant as an operation of arity 0"
09:04:24 <monochrom> > "let a = () in –∞ 42"
09:04:25 <lambdabot>   "let a = () in \1072 42"
09:04:56 <kmc> i'm not sure what a "nullary function" would be under the set-theoretic definition of a function
09:05:20 <kmc> a function is a set of (input, output) pairs such that no input corresponds to more than one output
09:05:39 <Cale> kmc: A k-ary operator on a set A is a function A^k -> A
09:05:44 <monochrom> otoh set theory is not the only story of functions
09:05:54 <sipa> and A^0 = {()}
09:06:10 <kmc> that's fair enough, if silly
09:06:20 <yrlnry> seen bos?
09:06:34 <kmc> preflex, seen bos
09:06:34 <preflex>  bos was last seen on #haskell 6 days, 16 hours, 57 minutes and 57 seconds ago, saying: mietek: what are you trying to do with the random library?
09:06:38 <yrlnry> thanks.
09:06:48 <yrlnry> My next question was going to be "which bot handles 'seen'?".
09:08:51 <monochrom> when doing formal first-order logic, I like merging constants and functions as "n-ary function, n>=0". there is no need for two syntactic classes. however, I realize that I am really thinking "n-ary constants, n>=0"
09:10:35 <monochrom> @seen monochrom
09:10:35 <preflex>  monochrom was last seen on #haskell 1 minute and 44 seconds ago, saying: when doing formal first-order logic, I like merging constants and functions as "n-ary function, n>=0". there is no need for two syntactic classes. however, I realize that I am really thinking "n-ary constants, n>=0"
09:10:35 <lambdabot> Unknown command, try @list
09:10:52 <monochrom> that answers the question
09:11:50 <monadic> Is there a variant of quickCheck that is not in the IO monad and accepts a StdGen argument
09:12:18 <c_wraith> no.  quickCheck's public API is very IO-centric
09:14:00 <george_z0rwell> I don't quite get GHCI's :t and :i commands. :i seems to work on everything, but :t randomly fails. Does :t even have any advantages over :i?
09:14:12 <george_z0rwell> Or is :t not supposed to be used on functions?
09:14:16 <hpc> :t only works on values
09:14:17 <lambdabot> Not in scope: `only'
09:14:17 <lambdabot> Not in scope: `works'
09:14:17 <lambdabot> Not in scope: `values'
09:14:27 <hpc> well, values/functions
09:14:32 <bgamari> Could someone suggest a better way to do this? http://hpaste.org/48784
09:14:36 <george_z0rwell> Ohh, that makes more sense.
09:14:41 <hpc> :t (+)
09:14:42 <lambdabot> forall a. (Num a) => a -> a -> a
09:14:43 <hpc> :t 5
09:14:44 <lambdabot> forall t. (Num t) => t
09:14:48 <hpc> :t IO
09:14:48 <lambdabot> Not in scope: data constructor `IO'
09:14:54 <hpc> :k IO
09:14:55 <lambdabot> * -> *
09:15:10 <quicksilver> george_z0rwell: :t works on things which have types
09:15:21 <quicksilver> george_z0rwell: :i attempts to look up all kinds of things
09:15:22 <monochrom>  :i has the advantage of telling you operator precedence. also try ":i + *". :t has the advantage of accepting general expressions
09:15:39 <george_z0rwell> I was trying :t on >>>, which has a type but doesn't seem to work with :t
09:15:54 <quicksilver> george_z0rwell: that's because >>> along isn't a valid expression
09:16:00 <quicksilver> george_z0rwell: :t (>>>) will work
09:16:10 <monadic> ghci -- :t (>>>)
09:16:11 <monadic> (>>>) :: Control.Category.Category cat => cat a b -> cat b c -> cat a c
09:16:13 <george_z0rwell> Damn, so that was it
09:16:20 <george_z0rwell> Thanks quicksilver
09:16:21 <quicksilver> george_z0rwell: as an example of something that :i doesn't work on, try :i "hello"
09:16:49 <monochrom>  :i takes names. :t takes expressions
09:17:41 * quicksilver nods
09:21:23 <guerrilla> curious, what does fail do for default if you don't handle it in your monad instance? throw an exception?
09:21:44 <parcs> @src fail
09:21:44 <lambdabot> fail s      = error s
09:21:57 <guerrilla> jesus
09:22:01 <guerrilla> haha, good to know
09:22:25 <ion> > runIdentity (fail "foo")
09:22:26 <lambdabot>   *Exception: foo
09:22:36 <guerrilla> yeah
09:22:47 <Tomsik> :t fail
09:22:47 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
09:22:51 <Tomsik> fix fail
09:22:55 <Tomsik> > fix fail
09:22:56 <lambdabot>   ""
09:23:23 <Tomsik> > fix fail :: []
09:23:24 <lambdabot>   Expecting an ordinary type, but found a type of kind * -> *
09:23:29 <Tomsik> > fix fail :: [a]
09:23:30 <lambdabot>   Couldn't match expected type `a'
09:23:30 <lambdabot>         against inferred type `GHC.Types.C...
09:23:33 <Tomsik> > fix fail :: [Bool]
09:23:34 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
09:23:34 <lambdabot>         against inferred type ...
09:23:40 <ion> :t fix fail
09:23:41 <lambdabot> String
09:23:49 <Tomsik> oh right
09:24:13 <guerrilla> this is fix from Data.Function? (least fixed point)
09:24:38 <yrlnry> :t fix
09:24:39 <lambdabot> forall a. (a -> a) -> a
09:24:45 <guerrilla> ah yeah
09:24:52 <guerrilla> what would we do without lambdabot :P
09:24:56 <guerrilla> so convenient
09:25:13 <yrlnry> that's  "fix f = x where x = f x" I think.
09:25:26 <Tomsik> It's just cloud-delegating mental work
09:25:30 <hpc> > fix error
09:25:31 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
09:25:36 <yrlnry> hee.
09:25:36 <guerrilla> haha
09:25:36 <Tomsik> You don't think about the type, internet tells you
09:25:48 <ion> > runIdentity (fix (fail . show . runIdentity) :: Identity Bool)
09:25:49 <lambdabot>   *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
09:26:08 <george_z0rwell> Lambdabot is actually more advanced than GHCI!
09:27:14 <ion> > fix (fail . show) :: [Bool]  -- empty list
09:27:15 <lambdabot>   []
09:27:51 <ion> @src [] fail
09:27:51 <lambdabot> fail _      = []
09:38:52 <Sisawat> so uh
09:39:27 <Sisawat> I have been trying to get lambdabot to compile, there doesn't seem to be any up-to-date info on that
09:41:36 <Clint> Sisawat: nuke {-# OPTIONS -fvia-C #-} from Plugin/Pl/Common.hs
09:42:01 <Sisawat> ?
09:42:20 <Clint> what's the symptom of your faliure?
09:42:35 <Sisawat> the fact that all the documentation in about 4 years old?
09:42:47 <Clint> that may be the cause. that's not the symptom.
09:44:54 <thoughtpolice> who even maintains lambdabot these days? does Cale still do it?
09:45:28 <thoughtpolice> i'm surprised she hasn't 'gotten sick' and dropped out recently it seems as she used to, i guess someone's been working on her.
09:45:47 <Sisawat> hmm
09:47:16 <Clint> i sent a patch a couple weeks ago i think
09:47:48 <Saizan> yep, still cale
09:47:52 <thoughtpolice> thought so.
09:49:56 <Cale> I don't maintain lambdabot
09:49:59 <Cale> I just run lambdabot
09:50:05 <Cale> Nobody maintains lambdabot
09:50:42 <Saizan> heh, sorry, i meant run
09:50:56 <d7> What's the idiomatic way to repeat an IO action N times?
09:51:08 <Botje> replicateM
09:52:13 <Sisawat> ok, thanks then.
09:56:35 <d7> Botje: Perfect. Ty.
09:57:39 <HugoDaniel> how do i define a tree in haskell where each leaf has an element of a different type ?
09:58:02 <zygoloid> HugoDaniel: how do these element types differ?
09:58:16 <HugoDaniel> hmm, i have something like: MyData a = MyData ...
09:58:33 <HugoDaniel> the tree is to store pairs like (Text, MyData a) (Text, MyData b) ...
09:58:59 <HugoDaniel> i could use a Map, but then the types wouldn't differ
09:59:02 <zygoloid> how would you recover the type of the type variable there?
09:59:44 <HugoDaniel> it is actually like MyData a = MyData { .., .., myData :: a, .., .. }
10:00:30 <byorgey> HugoDaniel: Data.Dynamic?
10:00:35 <calef13> I have two functions f and g, and both return integers, how do I combine these into a list? I tried using cons and surrounding both function calls with [] but it still errors out
10:00:49 <zygoloid> if you don't want to be able to recover myData, just use an existential
10:01:08 <byorgey> if you don't want to be able to recover myData, then don't include it at all =P
10:01:25 <HugoDaniel> but i want
10:01:26 <byorgey> calef13: [f, g]  ?
10:01:27 <HugoDaniel> yes
10:01:37 <zygoloid> ... if you want to be able to recover certain properties of myData, use a constrained existential :)
10:01:41 <calef13> byorgey: they both take a single argument too
10:01:49 <zygoloid> Dynamic is probably overkill
10:02:00 <byorgey> calef13: what do you want to make a list of?  the functions themselves? or their results?
10:02:09 <calef13> I have [f x]:[g y]
10:02:14 <calef13> their results
10:02:19 <calef13> so I have a list of integers
10:02:24 <byorgey> calef13: [f x, g y]
10:02:25 <luite> [f x, g y] ?
10:02:26 <calef13> I want to find the maximum you see
10:02:34 <tromp> :t max
10:02:34 <lambdabot> forall a. (Ord a) => a -> a -> a
10:02:40 <calef13> ah facepalm :P
10:02:42 <kmc> :t maximum
10:02:43 <lambdabot> forall a. (Ord a) => [a] -> a
10:02:49 <calef13> I knew I was missing something simple
10:02:56 <byorgey> calef13: to use (:) you would have to write   f x : g y : []
10:03:00 <kmc> :t (:)
10:03:01 <lambdabot> forall a. a -> [a] -> [a]
10:03:03 <kmc> :t (++)
10:03:04 <lambdabot> forall m. (Monoid m) => m -> m -> m
10:03:06 <kmc> grr
10:03:09 <kmc> :t (Prelude.++)
10:03:09 <lambdabot> forall a. [a] -> [a] -> [a]
10:03:12 <calef13> ah yeah I need the empty list at the end ofc
10:03:15 <luite> f x : [g y] would work too
10:03:22 <kmc> > 2 : [3,4]
10:03:23 <lambdabot>   [2,3,4]
10:03:24 <byorgey> or [f x] ++ [g y]
10:03:27 <kmc> > [2,3] : [[4,5]]
10:03:28 <lambdabot>   [[2,3],[4,5]]
10:03:38 <calef13> ok thanks very much guys
10:03:46 <kmc> calef13, the trick is that lists are defined inductively:
10:03:54 <kmc> data List a = Nil | Cons a (List a)
10:04:09 <kmc> except there is special syntax, so Nil is [] and Cons is infix (:)
10:04:16 <calef13> ah yeah, I knew this, but I forgot it haha
10:04:17 <calef13> yeah
10:06:33 <HugoDaniel> meh, ill just use typeclasses for my things
10:06:35 <HugoDaniel> it works :P
10:07:10 <kmc> what things?
10:08:05 <HugoDaniel> my trees with different types on the leaves
10:08:30 <parcs> without an existential?
10:10:42 <d7> Ooof.
10:10:57 <d7> Erlang programmers thinking MVars are so awesome they want to program in an actor approximation of them.
10:11:01 <d7> That's brutal. :(
10:11:08 <kmc> :)
10:11:15 <kmc> each variable is a process that accepts "take" and "put" messages?
10:11:40 <Botje> heh, it was an exam question for my erlang course two years ago
10:12:01 <kmc> i'm not sure that's an "approximation"
10:12:04 <kmc> if the API is identical
10:12:14 <kmc> there is some appeal to building *everything* out of processes
10:12:17 <d7> kmc: It's not.
10:12:42 <d7> Also the semantics are different.
10:12:53 <d7> But it's curious, since... you know...
10:13:10 <d7> Erlang has really powerful concurrency primitives. Way above what most people have.
10:13:35 <kmc> what are the semantics?
10:14:00 <kmc> HugoDaniel, how do the types differ?
10:15:16 <HugoDaniel> MyData a = MyData { .., .., myData :: a, .., .. }
10:15:34 <HugoDaniel> the leaves are going to be MyData b, MyData c, MyData d ...
10:17:45 <kmc> for totally arbitrary b,c,d?
10:17:47 <kmc> or do they relate somehow?
10:19:21 <HugoDaniel> they all belong to a typeclass
10:19:31 <d7> kmc: https://github.com/TonyGen/mongodb-erlang/blob/master/src/mvar.erl
10:19:35 <k0ral> is it difficult to understand how gtk binding is implemented ?
10:19:46 <d7> kmc: It seems to me like the primitive isn't faithfully replicated.
10:19:59 <kmc> how would you use the data in the leaves anyway, if they're totally arbitrary types?
10:20:39 <d7> kmc: I was under the impression that all one could do with an mvar is get or put it. All other operations are implemented in terms of those two.
10:20:39 <bgamari> Hmm, how does one :trace main?
10:20:40 <kmc> i... can't read Erlang
10:20:54 <HugoDaniel> kmc MyData a = MyData { func :: a -> Bla -> a, myData :: a, func2 :: a -> ..., }
10:20:54 <kmc> bgamari, does not work as such?
10:20:54 <bgamari> I tried :trace main but :hist still thinks I forgot to use :trace
10:20:55 <d7> kmc: Well you can see immdiate semantic differences in the event loop.
10:20:57 <HugoDaniel> like this
10:21:12 <kmc> HugoDaniel, ah, sounds like an existential
10:21:44 <d7> kmc: For example, they have a modify which is atomic.
10:21:45 <bgamari> kmc: Prelude Main> :trace main
10:21:45 <bgamari> 5   (Stopped at <exception thrown>
10:21:45 <bgamari> _exception :: e = _
10:21:45 <bgamari> [<exception thrown>] Prelude Main> :hist
10:21:45 <bgamari> Empty history. Perhaps you forgot to use :trace?
10:21:50 <kmc> bah
10:21:52 <kmc> dunno then
10:21:53 <bgamari> oops, sorry for the minor flood
10:22:07 <d7> kmc: Am I mistaken?
10:22:41 <kmc> you're saying 'modify' is implemented "directly" rather than in terms of take / put?
10:22:51 <d7> Yes.
10:22:55 <d7> And also the read value.
10:23:04 <d7> That's implemented in a native, nonblocking.
10:23:10 <kmc> shrug
10:23:12 <kmc> ok
10:23:51 <d7> But I was under the impression that MVars are a low-level concurrency thing.
10:23:59 <kmc> HugoDaniel, in GHC syntax, data SomeData = forall a. SomeData (MyData a)
10:24:00 <d7> Like, you don't go, "Oh yeah! I can use an MVar for this! I'm excited!"
10:24:03 <kmc> should work
10:24:09 <d7> You do that with Tvars or Channel abstractions.
10:24:27 <kmc> sometimes MVar is exactly what you need
10:24:28 <d7> Low-level implementers use mvars because they're more efficient.
10:24:30 <kmc> but i think you're right generally
10:24:30 <d7> Yeah
10:24:45 <kmc> in GHC a Chan is an MVar-linked list of MVars
10:25:34 <HugoDaniel> kmc: can i have something like: SomeData = forall a. SomeData (MyData a) and then MyData a = MyData {.., .., children :: SomeData, .. } ?
10:25:46 <monochrom> actually, I "oh yeah! I can use mvar for this!" all the time. the "I'm excited!" part wears off though because of the high frequency
10:25:48 <kmc> yes
10:26:28 <kmc> d7, there are weird gaps in the standard lib, though.  for example there's no primitive for "run this computation asynchronously and let me request the result later"
10:26:48 <kmc> it's easy to implement with MVar so everyone re-implements it
10:26:51 <kmc> here's my version: http://hackage.haskell.org/package/spawn
10:27:20 <HugoDaniel> :)
10:27:40 <kmc> handling exceptions correctly is slightly tricky
10:27:43 <d7> kmc: Isnt' that just tvars?
10:28:09 <kmc> i don't see how it's related
10:28:17 <kmc> TVar is like IORef for STM
10:28:23 <d7> kmc: Mvar too
10:28:26 <byorgey> HugoDaniel: you can do that, but if you don't put any type class constraint on SomeData you will not be able to do anything with children
10:28:28 <d7> Oh I see what you mean
10:28:36 <kmc> it's the "asynchronous" part
10:28:45 <kmc> it's easy to fork a computation and block on the result
10:28:49 <kmc> it's much like not forking at all
10:28:51 <d7> You want like a computeTo :: IORef a -> IO a
10:29:17 <kmc> spawn :: IO a -> IO (IO a)
10:29:24 <Saizan> byorgey: unless some fields of MyData are the methods
10:29:48 <d7> kmc: tryTakeMvar doesn't meet your needs?
10:29:50 <byorgey> Saizan: oh! Right, I missed the mutual recursion
10:29:57 <kmc> d7, in Haskell you can hide concurrency primitives by closing over them
10:29:59 <kmc> that's a nice powerful style
10:30:12 <byorgey> well, I guess the mutual recursion doesn't even matter,
10:30:18 <d7> kmc: Well sure, although in this case I deliberately didn't. :)
10:30:21 <kmc> d7, no, why would it
10:30:31 <kmc> tryTakeMVar doesn't create any threads
10:30:36 <bgamari> kmc: I suspect the problem was that ghci was using the compiled module
10:30:47 <kmc> i want to create a thread, let it run, and then later demand the result, blocking if it's not ready yet
10:30:51 <d7> kmc: You'd have computeAsync forkIO internally?
10:30:53 <kmc> afaik there's nothing in the std lib which does all that
10:31:03 <RichardBarrell> kmc: spawn f = newEmptyMVar >>= \m -> forkIO (f >>= liftM evaluate >>= putMVar m) >> return (takeMVar m) -- ?
10:31:06 <d7> I think we're describing the same thing just in different terms
10:31:06 <monochrom> mvar is a length-1 channel with blocking recv and blocking send. therefore it fits "wait for john's answer one-shot" or "wait for charles to quit"
10:31:10 <kmc> there is no need to talk in hypotheticals.  my entire code is here: http://hackage.haskell.org/packages/archive/spawn/0.2/doc/html/src/Control-Concurrent-Spawn.html
10:31:23 <kmc> RichardBarrell, yeah, like that
10:31:25 <d7> RichardBarrell: I think the complaint is "This should be part of the stdlib somewhere.
10:31:33 <kmc> well, i don't force to whnf
10:31:43 <RichardBarrell> I agree that it probably *should* be part of the stdlib.
10:31:45 <kmc> i'm interested in async execution, not async evaluation
10:31:51 <kmc> if you want async evaluation use 'par'
10:31:58 <RichardBarrell> But just write Control.Concurrent.Future and upload it to hackage already.
10:32:04 <kmc> ffs
10:32:05 <kmc> i did
10:32:12 <kmc> i linked it twice
10:32:26 <monochrom> haha
10:32:28 <RichardBarrell> kmc: well, no worries. It's as good as in the standard library now. :)
10:32:31 <d7> Haha.
10:32:34 <monochrom> people are too busy writing to read
10:32:39 <d7> RichardBarrell: I uh, guess..
10:32:45 <kmc> not really -- people keep re-implementing it.  in fact, there were already a few libraries like that when I uploaded mine :)
10:32:51 <d7> For me as a newbie, this shit with the segmented stdlib is pretty imposing.
10:32:55 <kmc> i like my type better though ;)
10:33:00 <kmc> spawn :: IO a -> IO (IO a)
10:33:10 <kmc> no chans / mvars / thread ids poking out
10:33:23 <RichardBarrell> Also no early-kill feature.
10:33:27 <kmc> yeah
10:33:37 <RichardBarrell> Pleasant type, though.
10:33:42 <kmc> i don't agree that every package on hackage is as good as in the stdlib
10:33:44 <monochrom> on one hand that type is pretty uninformative. on the other hand it means no learning curve
10:33:47 <d7> I'm not sure what nested IO's mean.
10:33:57 <kmc> in general?
10:33:57 <RichardBarrell> Callbacks in IO, pretty often.
10:34:01 <kmc> or what these mean specifically?
10:34:13 <RichardBarrell> "Here is an action that you can invoke later, instead of now."
10:34:20 <kmc> an action which produces another action
10:35:46 <yrlnry> preflex:  seen ski
10:35:47 <preflex>  ski was last seen on #haskell 16 hours, 29 minutes and 23 seconds ago, saying: * ski recalls using `Either [Integer] Integer' monadically, for something
10:36:09 <kmc> a lot of people teach "IO" as if it's a "taint bit" on "impure values"
10:36:26 <kmc> not only is this fundamentally wrong, but it provides no tools for understanding types like IO a -> IO (IO a)
10:36:33 <kmc> or Int -> IO (IO a -> IO a)
10:36:47 <kmc> . o O ( Int -> IO (forall a. IO a -> IO a) )
10:36:55 <zygoloid> it provides no tools for understanding IO a -> IO b. or... values of type IO a :)
10:36:59 <RichardBarrell> That really ought to be an integer. What if you want to run it 2**65 times?
10:37:02 <RichardBarrell> *Integer
10:37:26 <kmc> i had in mind pool :: Int -> IO (IO a -> IO a)
10:37:30 <kmc> 'Given n, produces a function to wrap IO actions. No more than n wrapped actions will be in progress at one time.'
10:37:59 <copumpkin> cool
10:38:32 <kmc> again, i really like the higher-order IO style
10:40:04 <kmc> in Java that would be about three pages of factories ;)
10:40:23 <byorgey> IOPoolWrapperFactoryFactory
10:41:06 <kmc> Apache has some FactoryFactories
10:41:58 <kmc> i kind of want to fix my library to have that more polymorphic type except that it's impredicative ;P
10:42:44 <copumpkin> impredicativity is cool
10:43:07 <Saizan> kmc: i don't think you can
10:43:20 <Saizan> ?hoogle newQSem
10:43:20 <lambdabot> Control.Concurrent.QSem newQSem :: Int -> IO QSem
10:43:20 <lambdabot> Control.Concurrent.QSemN newQSemN :: Int -> IO QSemN
10:44:29 <Saizan> ah, no, it's fine
10:44:40 <Saizan> the semaphore doesn't contain anything :)
10:45:40 <kaito_> The composition of functions with (effectively) more than 1 parameters confuse me way more than I'd like to be confused. Are there some simple rules to quickly see what a complex pointfree expression does?
10:46:00 <ezyang> @unpl flip flip flip
10:46:00 <lambdabot> (\ c f -> c f (\ g h i -> g i h))
10:46:02 <kmc> (f .) . g  =  \x y -> f (g x y)
10:46:08 <kmc> that one shows up a lot
10:46:12 <kmc> @pl \x y -> f (g x y)
10:46:12 <lambdabot> (f .) . g
10:46:21 <kmc> :t (.).(.)
10:46:22 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
10:46:31 <kmc> :t let (.) = (Prelude..) in (.).(.)
10:46:32 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
10:47:14 <parcs> i love the fact that you can compose the composition operator
10:48:08 <conal> parcs: and i love that (.) can also be freely composed with first & second
10:48:18 <conal> (and other semantic editor combinators)
10:49:50 <d7> kmc: I still cannot read (f .) . g and come up with the result. I dunno why, but it really baffles me.
10:50:22 <kmc> i don't have a magic trick for understanding that one :/
10:50:35 <monochrom> don't worry about it
10:50:38 <d7> I get how (f .) works, and that's what places the f () on the outside of the type.
10:50:49 <d7> I don't get how we get g x y from that.
10:50:54 <d7> Is it known in advance g has 2 arguments?
10:50:58 <conal> i use '(result.result) f g
10:51:00 <conal> '
10:51:00 <d7> Or is that just assumed?
10:51:06 <kmc> yes, this only works if g has "two arguments"
10:51:19 <kmc> you can work out the evaluation of (((f .) . g) x y) manually
10:51:22 <d7> forgive me my strict javaish words for it.
10:51:25 <d7> yeah
10:51:31 <kmc> i don't mean the quotes to correct you
10:51:34 <conal> very commonly in my code. and it generalizes nicely to other SECs and to other arrows.
10:51:46 <kmc> just that, in fact, it can work with functions that have more than two right-associated arrows in the type
10:51:50 <d7> What if g has 3? Does it become \x y z -> f (g x y z) ?
10:51:52 <kmc> but does something different
10:51:58 <kmc> no
10:52:09 <d7> That's what I don't get, then.
10:52:13 <copumpkin> Saizan: why not?
10:52:22 <kmc> d7, why would it?
10:52:24 <conal> d7: (result.result.result) f g
10:52:31 <conal> @where SEC
10:52:31 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
10:52:36 <conal> d7: ^^
10:52:42 <d7> checking
10:52:47 <kmc> d7, we know ((f .) . g) x y = f (g x y)
10:52:56 <kmc> so ((f .) . g) x y z = (f (g x y)) z
10:53:08 <kmc> equational reasoning :)
10:53:13 <d7> kmc: I don't get why g must consume 2 things.
10:53:15 <conal> d7: similarly useful: (first.result.second) f g
10:53:20 <kmc> i don't understand the question
10:53:47 <d7> conal: That link isn't resolving for me.
10:54:01 * conal checks ...
10:54:10 <monochrom> you could give it just 1. ((f . ) . g) x = (f .) (g x) is just fine
10:54:27 <d7> kmc: That may be the problem.
10:54:31 <conal> hrmf. is my blog down?
10:54:33 <monochrom> = f . g x
10:54:45 <kmc> d7, is the question "why does ((f .) . g) work for two args to g" or "why doesn't it work for 3"?
10:54:51 <d7> kmc:  I don't see how g is dictated to have 2 arguments in that signature is what I am saying.
10:55:03 <kmc> there's not been any type signature yet
10:55:05 <kmc> just code
10:55:09 <kaito_> cornal: It loads for me
10:55:10 <kmc> expressions not types
10:55:13 <d7> It seems that form requires a g to exist, but I don't see why g is pinned to a specific signature.
10:55:18 <kmc> :t \f g -> ((f . ) . g)
10:55:18 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
10:55:22 <geheimdienst> conal, it took a while, but eventually the page came up
10:55:23 <kmc> god damn it
10:55:31 <kmc> :t \f g -> ((f Prelude.. ) Prelude.. g)
10:55:32 <lambdabot> forall b c a a1. (b -> c) -> (a1 -> a -> b) -> a1 -> a -> c
10:55:34 <d7> Yeah it just came up for me
10:55:40 <conal> geheimdienst: for me, too. after a good while. hm.
10:55:40 <d7> Time to load was >1m
10:55:47 <conal> geheimdienst: and thx
10:55:52 <kmc> d7, so f has type (b -> c) and g has type (a1 -> a -> b)
10:55:54 <geheimdienst> you're welcome
10:56:04 <kmc> d7, to work out *why* that's the type, you have to do type inference
10:56:15 <kmc> which is not that hard to do by hand
10:56:16 <Saizan> copumpkin: i didn't realize the semaphore primitives don't have to care about 'a'
10:56:27 <copumpkin> Saizan: oh, so it does work?
10:56:27 <kmc> but fairly tedious
10:56:28 <d7> conal: Time to move to hakyll? :)
10:56:52 <conal> d7: yeah, i think so. i wonder how to carry all my old content over, including comments.
10:56:57 <kmc> d7, as for why it works
10:57:09 <Saizan> copumpkin: yeah, it should
10:57:25 <parcs> i recall reading a blog post on intuitive n-ary function composition operators, that looked like ..$..
10:57:33 <parcs> anyone have the link?
10:57:43 <kmc> ((f . ) . g)  =  (\h -> f . h) . g  =  \x -> (\h -> f . h) (g x)  =  \x -> f . (g x)  =  \x y -> f (g x y)
10:58:01 <kmc> write each of those onto a separate line and stare at them for a good long while :)
10:58:59 * copumpkin passes Saizan's word on to kmc
10:59:04 <copumpkin> impredicativity it is!
10:59:08 <kaito_> kmc: I think that'll help, thanks.
10:59:21 <monochrom> do not stare. do not think. calculate. let the symbols do the work
10:59:21 <d7> Ugh.
10:59:27 <d7> For more reasons why i am so down on 10gen today
10:59:44 <kmc> definition of operator sections, definition of (.) at outer occurrence, beta reduce, definition of (.) again
10:59:45 <d7> https://github.com/TonyGen/bson-haskell/blob/master/Data/Bson/Binary.hs#L33-36
10:59:56 <d7> Seems to me like we could do better. :)
11:01:07 <kmc> more directly you can convince yourself that ((f .) . g) = \x -> f . (g x)
11:01:33 <kmc> and therefore (((f .) . g) x) = \y -> f (g x y)
11:03:27 <kmc> yay equational reasoning
11:03:48 <hpc> wouldn't a shorter @pl be f . g x?
11:04:03 <benmachine> hpc: shorter and arguably less clear
11:04:34 <kmc> the idea is to demonstrate how ((f .) . g) works
11:06:24 <hpc> ah fair
11:08:12 <d7> Hey guys.
11:08:56 <d7> My friend's getting a strange type error in this code: https://gist.github.com/4779ff8dcd78618d7079
11:09:04 <kmc> another reason the "IO actions" view is better than the "tagged impure functions" view is that you can apply equational reasoning to the former
11:09:29 <kmc> put a type signature on 'factors'
11:09:34 <kmc> like Integer -> [Integer]
11:09:37 <d7> Any advice?
11:09:41 <kmc> you will still get a type error but it will be more obvious
11:09:58 <kmc> you should generally have type signatures on top-level bindings
11:10:09 <monochrom> floor (sqrt (fromIntegral n))
11:10:26 <monochrom> you can s/n/(n)/ if that makes you feel better
11:10:33 <kmc> also, don't write "floor(sqrt(n))"
11:10:42 <d7> monochrom: This is his code. I'm just demonstrating how friendly #haskell is.
11:10:51 <kmc> Haskell is (f x) not f(x), and parentheses are only for grouping
11:10:54 <kmc> so "floor (sqrt n)"
11:10:58 <d7> He was burned in #scala and figured #haskell would be worse.
11:11:10 <d7> monochrom: Why is fromIntegral necessary?
11:11:17 <kmc> :t sqrt
11:11:18 <lambdabot> forall a. (Floating a) => a -> a
11:11:22 <kmc> > sqrt (3 :: Integer)
11:11:23 <lambdabot>   No instance for (GHC.Float.Floating GHC.Integer.Type.Integer)
11:11:23 <lambdabot>    arising fr...
11:11:27 <kmc> that's why d7
11:11:37 <monochrom> after he has experienced #haskell, he will be burned again when he enters ##c or something
11:11:57 <monochrom> @quote monochrom fromIntegral
11:11:57 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
11:12:46 <edwardk> scumbag sigfpe: Started writing a nice library for manipulating geometric algebra in haskell. Found that he had already written an article on the approach 5 years. ;)
11:13:49 <d7> would someone mind forking that gist and correcting it for him?
11:13:56 <d7> I'd do it but that would sorta defeat the point. :)
11:13:58 <copumpkin> edwardk: where is it?
11:14:05 <kmc> d7, we already gave suggestions
11:14:29 <copumpkin> edwardk: oh nevermind, found it
11:14:51 <kmc> "friendly" != "will do your work for you"
11:15:02 <hpaste> monochrom pasted ‚ÄúfromIntegral‚Äù at http://hpaste.org/48786
11:15:18 <monochrom> that is my fork. just not git
11:17:13 <monochrom> or rather, just not github. I use git myself just fine
11:17:58 <d7> Thank you monochrom
11:19:40 <Wooga> what haskell's user keyword may consist of?
11:19:49 <Wooga> is there any complete references on such things?
11:20:03 <monochrom> I don't know what is "user keyword"
11:20:08 <Wooga> like name of variable
11:20:10 <Wooga> or function
11:20:10 <c_wraith> Wooga: the language report
11:20:21 <c_wraith> lists all characters allowed in function and operator names
11:20:22 <parcs> google is a pretty complete reference
11:20:30 <parcs> oh, that's what you mean
11:20:33 <kmc> @google Haskell 2010 Report
11:20:35 <lambdabot> http://www.haskell.org/pipermail/haskell/2010-July/022189.html
11:20:35 <lambdabot> Title: [Haskell] ANNOUNCE: Haskell 2010 Report (final)
11:20:41 <monochrom> lower case letter to begin, then letter and/or number and/or _ and/or '
11:20:48 <Wooga> thanks!
11:31:53 <benmachine> is it morally wrong to use ContT as an EitherT just to avoid the whole Error class nonsense
11:32:16 <benmachine> (i.e. the only operation I use is escape = ContT . const . return)
11:32:40 <roconnor> benmachine: well it's not morally wrong to drop the mtl and use something better :)
11:32:41 <kmc> ‚ô• continuations
11:33:02 <benmachine> roconnor: using transformers, but point taken
11:33:08 <bgamari> Does know of any tools to make the ghci debugger a bit more civilized?
11:33:18 <roconnor> ah interesting
11:33:23 <bgamari> For instance, it would be nice if :hist actually showed you the highlighted expression
11:33:25 <roconnor> I didn't realize that transformers was problematic
11:33:28 <kmc> bgamari, no.  Haskell debugger really should be like http://ww2.cs.mu.oz.au/~bjpop/buddha/
11:33:36 <benmachine> roconnor: it's better than mtl was, but it's not perfect
11:33:38 <c_wraith> roconnor: transformers and mtl are the same now
11:33:56 <roconnor> transformers is only the Haskell 98 part of the mtl,
11:34:19 <benmachine> right, mtl is a re-export of transformers+monads-fd now
11:34:22 <kmc> and mtl is a legacy alternative to monads-fd
11:34:23 <kmc> yeah
11:34:36 <conal> benmachine: iiuc, the choice of ContT then complicates reasoning, as compared to a simpler and sufficient type.
11:34:36 <benmachine> kmc: except that they deprecated monads-fd instead of mtl :(
11:34:41 <kmc> sadness
11:34:59 <benmachine> conal: this is true, hence the question
11:35:25 <benmachine> conal: my argument would be that if I wanted to use an either transformer, I'd have to define my own, which complicates understanding while people check it's what they expect
11:35:44 <benmachine> or just use a different library
11:35:59 <conal> benmachine: EitherT is somehow tied to ContT?
11:36:12 <roconnor> OTOH cusing ContT will make your code faster!
11:36:14 <roconnor> vrooom
11:36:22 <roconnor> *using
11:36:27 <roconnor> ... not sure why I wrote cussing
11:36:35 <benmachine> roconnor: wooo
11:36:42 <benmachine> conal: I don't know what you mean
11:37:32 <kmc> the only monad you ever need is ContT r IO
11:37:34 <kmc> :D
11:37:36 <benmachine> hmm, I'm already in IO, maybe I should just use exceptions
11:37:45 <kmc> E X C E P T I O N S
11:37:54 <conal> benmachine: puzzling over your remark about using an either transformer. wondering what connection you're making to using ContT vs a simpler alternative.
11:38:33 * roconnor combines al dente in 8 min pasta with al dente in 9 min pasta :O
11:38:36 <Younder> the monadic approcah clearly has the better performance
11:38:39 <benmachine> conal: basically, the ContT defined in transformers is sensible, but the ErrorT (their name for EitherT) has superfluous constraints and is therefore unsatisfactory
11:39:00 <benmachine> Younder: performance schmerformance, if I wanted to optimise I wouldn't start there
11:39:22 <Younder> whatever
11:40:03 <conal> benmachine: do you mean that ErrorT places some constraints that ContT satisfies, and you don't know how to satisfy those constraints with a simpler & more accurate/tight/uncluttered monad than ContT?
11:40:24 <Younder> parallelism has rewritten the rules of performance anyhow
11:40:31 <benmachine> conal: I mean instance (Error e) => Monad (ErrorT e m) -- I am trying to avoid the Error constraint
11:40:53 <benmachine> the concept of EitherT doesn't require it, but the transformers package has it there
11:40:55 <bgamari> kmc: There are applications where I can imagine a declarative debugger would be of limited use
11:41:26 <conal> benmachine: and how does the Error constraint relate to your choice of ContT?
11:41:32 * conal is still confused
11:41:38 <parcs> benmachine: how about just using a plain EitherT transformer?
11:42:03 <benmachine> parcs: the transformers one is rubbish
11:42:19 <Younder> debugging Haskell is rubbish
11:42:34 <roconnor> conal: for ContT r m to be a monad, r need r or anything like r to be an instance of Error
11:42:35 <benmachine> parcs: if I had a sensible one I would use that
11:42:36 <Younder> The language itself is a spesification
11:42:54 <roconnor> conal: heck ContT r m doesn't even require that m be monad ... but that is another point.
11:42:58 <Younder> You TEST it!
11:43:14 <benmachine> and I could define one but that would increase code size
11:43:52 <conal> roconnor: and that situation is an argument *in favor* of benmachine choosing ContT ?
11:44:12 <roconnor> conal: if the type he wants to throw instant an instance of Error, then yes.
11:44:25 <roconnor> conal: if the type he wants to throw isn't an instance of Error, then yes.
11:44:31 * roconnor clearly needs more sleep
11:44:45 <benmachine> this is indeed the case
11:45:23 <Younder> exceptions have their place ...
11:45:33 <conal> sounds more like an non-argument against ContT, rather than an argument for. though maybe i'm still not getting something.
11:46:00 <benmachine> conal: it's a largely silly question so you shouldn't worry about it too much :)
11:46:18 <conal> benmachine: oky doke. :)
11:46:21 <roconnor> conal: well it isn't really an argument for ContT as much as it is an argument against ErrorT
11:46:47 <roconnor> conal: it just so happens than ContT can simulate exceptions without too much difficulty
11:46:55 <benmachine> heh, there are at least two (possibly more) Either monad transformer packages on hackage
11:47:01 <conal> roconnor: yeah. and hence my puzzlement in the context of choosing ContT vs something more accurate.
11:47:20 <conal> where "more accurate" == more tightly fitting (less cluttered)
11:47:34 <conal> which is sort of the point of static typing.
11:47:43 <roconnor> conal: right, the best choice is to use edwardk's Ran package.
11:48:13 <roconnor> but sometimes the best choice is worse. ... especially when it comes to edwardk's packages :P
11:48:20 <edwardk> wut?
11:48:21 <edwardk> =)
11:48:24 <roconnor> heh
11:48:49 <edwardk> benmachine: yeah one is mine =)
11:49:08 <benmachine> edwardk: it has like three more dependencies than it needs :P
11:49:14 * benmachine picky
11:49:18 * ski . o O ( `Error' is bunk )
11:49:26 <edwardk> benmachine: viewed in isolation, yes.
11:49:40 <benmachine> ski: agreed
11:49:42 <edwardk> benmachine: the alternative is that 30 other packages pick up 1 more dependency than they need
11:50:02 <benmachine> edwardk: yes, I know, we've had this discussion before :P
11:50:58 <ski> (hm .. maybe one should be able to specify module "pullbacks", in some way)
11:51:01 <benmachine> it kinda feels like a weakness of the language, but I don't have a clever fix for it
11:51:09 <sshc> Is there an equivalent to glade for wxHaskell / wxWidgets?
11:51:18 <dpratt71> just curious: is Parsec still "it" as a general parsing library, or is there an heir apparent?
11:51:40 <roconnor> ah poo.  monad-ran inherits all the crap from the mtl.
11:51:49 <benmachine> dpratt71: parsec is still pretty good, but for specialised purposes attoparsec might do better
11:52:06 <benmachine> dpratt71: i.e. bytestring parsing with resumability
11:52:38 <dpratt71> benmachine: I see; and what is resumability, exactly (or even approximately)?
11:53:02 <mauke> The paste zuyHFe3T has been copied to http://hpaste.org/48714
11:53:04 <benmachine> dpratt71: you don't have to feed all the input at once
11:53:31 <benmachine> you can give it a bit and then it can return "I parsed a bit and will parse some more when you have it"
11:53:36 <dpratt71> benmachine: oh, gotcha
11:54:10 <benmachine> dpratt71: basically, Result r has a constructor Partial (ByteString -> Result r)	
11:54:10 <dpratt71> sounds a bit like the enumeratee stuff I keep bumping into
11:54:16 <benmachine> yes, similar idea
11:54:48 <dpratt71> benmachine: ok, thanks for the info
12:03:13 <parcs> benmachine: i don't think the Error constraint in ErrorT is superfluous. it's there to overload the 'fail' mechanism
12:03:28 <benmachine> parcs: it's more burden than it's worth
12:03:58 <parcs> depends
12:04:00 <benmachine> you get a Left (strMsg "some useless message")
12:04:12 <benmachine> if you want to support use of fail, use Maybe, it makes more sense
12:04:31 <benmachine> and/or campaign for the reintroduction of MonadZero
12:04:45 <ski> (or `MonadFail')
12:04:51 <benmachine> equally good
12:05:07 <benmachine> (but I would prefer fail :: m a to fail :: String -> m a)
12:06:08 <ski> well `class Monad m => MonadZero m where mzero :: m a' should(?) be distinct from `class Monad m => MonadFail m where fail :: String -> m a', i think
12:06:27 <benmachine> ski: but which would do's pattern-match failure invoke?
12:06:42 <ski> though i'd replace `String' with `NonDet String', there
12:06:55 <ski> (with a `runNonDet :: NonDet a -> IO a' operation)
12:08:08 <ski> benmachine : `fail', if in scope, otherwise `mzero', i had in mind
12:08:59 <benmachine> ski: *gasp* what about import safety? :P
12:09:19 <ski> with `fail s' being undistinguishable from `mzero', except that you could appear to detect a difference in `IO'-code
12:09:25 <benmachine> ski: but I think that delivering error information via String is just silly anyway
12:09:44 <benmachine> it's useful for debugging if anything
12:09:52 <ski> *nod* it should be something which is opaque to normal program evaluation, so that it can't depend on it
12:10:32 <ski> benmachine : what do you mean by "import safety" ?
12:11:06 <benmachine> ski: well, I might have misunderstood what you meant by "in scope", but basically I meant the fact that adding imports to a program can't change its meaning
12:11:11 <benmachine> only stop it from compiling
12:11:50 <ski> yeah, but that would be taken care of by the law `fail s = mzero' (as far as can be detected in non-debuggingn code)
12:12:23 <benmachine> ski: at that point you might as well just use trace, no?
12:12:25 <benmachine> also, http://hackage.haskell.org/trac/haskell-prime/wiki/LanguageQualities
12:12:36 <benmachine> is my source
12:13:37 <ski> declaratively, the `String' that you get from running `runNonDet' in `IO' on the error string you get from `fail' could be any string at all
12:15:55 <ski> benmachine : the raison d'etre of `fail', afaict, is to allow the implementation to provide some kind of of relevant error message, depending on the context (line number, &c.) in which the refutable match in `do' appears
12:16:20 <ski> that implicit call to `fail' can't really be replaced by an explicit call to `trace'
12:17:28 <benmachine> ski: yeah, fair point. it just seems like a lot of complication for relatively small gain
12:17:45 <benmachine> (to have a string parameter, even a specially-wrapped one)
12:17:49 * hackagebot mime-mail 0.3.0.2 - Compose MIME email messages.  http://hackage.haskell.org/package/mime-mail-0.3.0.2 (MichaelSnoyman)
12:18:05 <rovar_> does anyone know of tutorial for a streaming xml parser in haskell?
12:18:11 <ski> yeah, i'm not convinced having `fail' at all is worth the trouble
12:18:28 <rovar_> I have a small app in xml-enumerator, but it completes silently with no data.
12:18:45 <ski> (otoh, refutable matches in `do' ought to require `MonadZero')
12:23:46 <copumpkin> ski: yes!
12:26:37 <ski> hm, are matches on a constuctor of a single-constructor `data' type irrefutable ?
12:26:45 * ski can't recall
12:31:19 <ddarius> ezyang: My experience with Mendeley is that I should like it but every time I actually use it, I hate it.
12:32:01 <ezyang> ddarius: I mean, it's not actually very good software, at this stage in time.
12:32:16 <ezyang> It's good enough to make me realize what I want out of the social academic web.
12:35:18 <gwern> @quote value.*of
12:35:19 <lambdabot> Olathe says: We can't be totally sure, though. There might be some value of 1 that wasn't checked.
12:35:24 <gwern> @quote the.*value.*of
12:35:24 <lambdabot> newsham says: functional programmers know the value of everything and the cost of nothing
12:36:04 <ski> ok, report says even tuple patterns are refutable
12:36:19 <gwern> ski: what if the tuple pattern match is irrefutable with ~s?
12:36:49 <ski> `~ (x,y)' is not a tuple pattern, but an "irrefutable" pattern of a tuple pattern
12:36:56 <ski> gwern ^
12:38:46 <ski> so i suppose i want to distinguish between two aspects (a) the refutable vs. irrefutable aspect in the report which is about whether the pattern-matching is strict or not; and (b) whether the pattern is the sole possible shape of the value, assuming it doesn't diverge
12:39:59 <ski> so in the latter sense, tuple types, and probably(?) `data' types with a single constructor (or even zero constructors) are "refutable"
12:40:12 <kmc> right, i don't think single-constructor data is special
12:40:22 <kmc> if you want the special semantics you use 'newtype' instead
12:40:31 <ski> (s/constructor/constructor argument/ ?)
12:41:16 <ski> kmc : the use case would be when you'd otherwise use tuples, but want better naming
12:41:37 <ddarius> Just read the Haskell 1.4 Report.  This is all worked out.
12:41:47 <kmc> "i liked haskell before it was cool"
12:41:50 <ski> (but if we ever get real records, it would be more appropriate to put it there, i suppose)
12:42:00 <ski> ddarius : which is worked out, there ?
12:42:04 <kmc> Haskell 98 was such a sell-out release, too mainstream
12:42:23 <ddarius> Matching against refutable and irrefutable patterns in do-notation and allies.
12:42:32 <ski> ok
12:44:29 <roconnor> @type (&&&)
12:44:30 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
12:45:14 <sully> what is a good reference on fundeps?
12:46:22 <parcs> the haskell wiki
12:47:05 <kmc> GHC manual
12:47:26 <ddarius> GHC source
12:47:46 <copumpkin> the extensive (haskell'?) mailing list post on them recently
12:48:27 <Saizan> if you know which posts to read :)
12:52:10 <ski> ok : "A failure-free pattern is one that can only be refuted by _|_."
12:53:22 <benmachine> or alternatively, a failable pattern is one that can be refuted by a total value?
12:54:06 <ski>  ‚Ä¢ All irrefutable patterns are failure-free
12:54:18 <ski>   ‚Ä¢ If C is the only constructor in its type, then C p[1] ... p[n] is failure-free when each of the p[i] is failure free.
12:54:22 <ski>   ‚Ä¢ If pattern p is failure-free, then the pattern v@p is failure-free."
12:54:53 <ski> (presumably the middle case includes tuple types, then)
12:55:01 <benmachine> mm
12:55:12 <benmachine> I actually have this in a function somewhere
12:55:15 <ski> (and presumably it handles record patterns, as well)
12:55:19 <benmachine> for the applicative do quasiquoter
12:55:33 <ddarius> ski: Yes and yes.
12:55:55 <ski> benmachine : to me, it sounds somewhat odd to say that a pattern can be refuted by `_|_' ..
12:56:53 <ddarius> ski: That's the difference between strict data and newtype, for example.  Strict data is refutable by _|_.
12:57:35 <ski> yeah. i was only thinking the term "refutable" seemed odd, in this context
12:57:56 <ski> (since it's not actually refuted in an observable way, it just diverges)
12:59:39 <ddarius> That's a refutation that the pattern holds.  Which makes even more sense from a evidence/witness/proof passing perspective.
13:03:07 <ski> hm, i suppose i'm thinking of a pattern-match failing as an observable refutation of the pattern matching the value
13:03:58 <d7> conal: Trying to share your blog post on google+ with fprog friends.
13:04:02 <ski> .. which would just mean that "failed" and "refuted" would mean the same thing -- and i suppose i can see now how that's not very useful
13:04:08 <d7> conal: But it's too slow, times out google+!
13:05:09 <conal> d7: thanks. i'm stumped about what's going on there. i get sporadic reports of my blog being slow. and worse, of having transient malware.
13:05:47 <d7> conal: In all seriousness, export and redo site w/ hakyll as a project. Short term fix, I dunno.
13:05:54 <d7> conal: Hakyll is the new hotness for diy blogs.
13:05:56 <roconnor> @index (&&&)
13:05:56 <lambdabot> Control.Arrow
13:06:15 <ski> (ddarius : i'm not sure what you mean by "evidence/witness/proof passing perspective", though)
13:06:27 <d7> conal: Impossible to hack a static blog. :)
13:06:28 <conal> d7: agreed. switching to hakyll is on my to-do list. i'll be ecstatic to get to hack my blog in haskell.
13:06:37 <d7> yeah I've been doing it
13:06:38 <conal> :)
13:06:42 <d7> Almost ready to open up fayr.am
13:06:49 <d7> Been hoarding that expensive domain name for quite some time now.
13:08:36 <benmachine> I have a plan where I abuse hakyll to make a dynamic blog
13:08:43 <benmachine> by compiling comments into my pages >_>
13:17:38 <d7> benmachine: It's not like hakyll is slow.
13:18:00 <rata_> hi
13:19:17 <azaq23> hi rata_
13:19:46 <rata_> why could it be that ghci stops printing what I asked it to print and doesn't return to the prompt?
13:20:12 <rata_> (and it's not using any cpu)
13:20:45 <ion> Perhaps it‚Äôs angry because you asked a question without providing the problematic code.
13:21:14 <monochrom> please don't provide code or further information. people love guessing games aka "lateral thinking puzzles"
13:21:40 <monochrom> only allow players to ask yes/no questions
13:22:18 <aristid> @pl \f g x y -> f (g x y)
13:22:19 <lambdabot> (.) . (.)
13:22:19 <azaq23> we'll find an answer in log(n) steps
13:22:29 <aristid> @pl \x y -> f (g x y)
13:22:29 <lambdabot> (f .) . g
13:24:01 <ion> @vixen Why does rata‚Äôs ghci stop printing what he asked it to print?
13:24:02 <lambdabot> sorry, i'll stop
13:24:17 <ion> Not lambdabot stopped, too.
13:24:20 <ion> Now
13:28:35 <benmachine> d7: and equally, it's not like anyone is actually going to comment on my blog :P
13:48:44 <gwern> @quote nothing
13:48:45 <lambdabot> AlanPerlis says: A LISP programmer knows the value of everything, but the cost of nothing.
14:04:47 <knoc> @quote maybe
14:04:47 <lambdabot> gwern says: also, now my keyboard has a nice toasty feeling.  maybe I should blowdry my keyboards more often
14:05:07 <gwern> that was a good day.
14:07:01 <knoc> hehe^^
14:07:13 <gwern> @quote gwern
14:07:13 <lambdabot> gwern says: good news everyone! we heard you like interpreters so we used the 3rd futamura projection to interpret your compiler so you can compile while you interpret!
14:07:40 <knoc> thats cool stuff^^
14:07:54 <nostrand> hahaha
14:08:06 <shachaf> preflex: be gwern
14:08:06 <preflex>  be warned preflex, your time will come! you too shall make use of mueval
14:08:32 * gwern reflects that very few people know all of futurama and futamura and the yo dawg meme, and so would properly appreciate that joke
14:09:08 <monochrom> I have heard of the futamura projections
14:09:13 <olsner> I didn't even notice the futurama/futamura thing
14:09:30 <olsner> but I did read "good news everyone!" in farnsworth's voice :D
14:10:15 <kmc> gwern, i think you're in the right channel though
14:10:19 <monochrom> linking a ghc-generated executable takes forever on *bsd
14:10:30 <kmc> http://images.tribe.net/tribe/upload/photo/f9c/971/f9c97160-daed-4312-b03c-70df156dff9e
14:10:32 <gwern> kmc: definitely. I can't think of any channel more likely to get it
14:10:36 <nostrand> olsner: i thought you knew of futamura's projection!
14:10:43 <kmc> gwern, what about that 4chan programming forum
14:10:49 <kmc> or SA's programming forum shitposting subforum
14:10:56 <olsner> nostrand: I do! I just didn't notice that futamura is an anagram of futurama
14:10:59 <monochrom> probably should have made do with "runghc Setup.hs"
14:11:07 <kmc> > (sort "futurama", sort "futamura")
14:11:08 <edwardk> kmc: gah!
14:11:08 <lambdabot>   ("aafmrtuu","aafmrtuu")
14:11:12 <gwern> kmc: I didn't notice an especially high level of CS on 4chan.
14:11:14 <nostrand> olsner: ah
14:11:19 <kmc> bbl
14:11:33 <gwern> 4chan might get a futanari joke, but futamura?
14:11:56 <edwardk> 4chan is the fourth futanari projection?
14:12:08 <nostrand> gwern: i missed the Futurama thing first =(
14:13:19 <gwern> SyntaxNinja: you still work at galois right? is sigbjorn finne alive? I've been thinking of stealing a library from him since he has ignored me for the past 2 years or so
14:14:01 <SyntaxNinja> gwern: Sigbjorn hasn't worked here for a few years. He's at Opera now.
14:14:20 <gwern> hm
14:14:26 <gwern> maybe I should steal it anyway. not a fan of opera.
14:15:00 <HugoDaniel> opera is using haskell libraries ?
14:15:11 <gwern> HugoDaniel: no, it's his old feed (atom/rss) library
14:17:15 <HugoDaniel> i wish there was a browser that used haskell :(
14:17:40 <gwern> not really. I'm not sure how well haskell would work in the large with that
14:17:59 <gwern> towards the end yi became kind of monstrous and darcs isn't too well-structured either
14:18:34 <gwern> IMO, anyway
14:19:08 <gwern> at least xmonad has remained fairly cleanly structured
14:19:55 <olsner> I doubt that opera does any haskell :)
14:28:38 * araujo wrote some code for a small haskell browser some time ago
14:29:05 <araujo> well... it was just the mozembed engine from gtk2hs :P
14:30:39 <rata_> hahahaaha sorry guys
14:36:39 <rata_> the code is several files long
14:37:42 <rata_> but it's so weird that it suddendly stops printing, as if it were computing what to print next, but doesn't consume any cpu
14:41:06 <Polarina> I am having compilation issues with OpenGLRaw on the statement "GL.glClear GL.gl_COLOR_BUFFER_BIT". It complains about using GLenum instead of a GLbitfield as argument to glClear.
14:44:04 <monochrom> rata_: you have an infinite loop in your program. the runtime can detect some trivial kind of infinite loops and just hang without consuming cpu. (the trivial kind of infinite loops coincides with deadlocks between threads)
14:45:05 <d7> I thought I had this enumerator properly implemented...
14:45:08 <d7> But I guess I don't.
14:45:39 <d7> I thought that Enumerators could push Chunks [] and not screw up iteratees, but it seems that is not the case.
14:45:50 <sebz> quick poll: would you guys rather be able to write Haskell in a browser or on an iPad?
14:46:12 <parcs> yes!
14:46:29 <sebz> which?
14:46:57 <parcs> browser
14:47:10 <HugoDaniel> browser
14:47:23 <monochrom> both
14:47:35 <HugoDaniel> on a iBrowser
14:47:36 <geheimdienst> browser
14:47:51 <monochrom> but I guess browser implies ipad
14:48:06 <sebz> great, that's what I was hoping to hear :D
14:48:23 <monochrom> in fact, http://www.vex.net/~trebla/haskell/testbed.cgi
14:48:38 <HugoDaniel> sebz: in IE5.5
14:48:51 <d7> Can anyone help me understand why this would be a problem?
14:48:53 <d7> http://hpaste.org/48787
14:48:57 <monochrom> I heard that there was IE5.5 for linux
14:49:14 <d7> So I either feed chunks of size 0 or 1 into the Enumerator.
14:49:36 <HugoDaniel> tryhaskell allows me to code haskell in a browser
14:49:49 <d7> But if I try doing something like: enumSubscriptions conn 10 ==<< ((EL.require 5 >> EL.take 5)
14:49:57 <HugoDaniel> not so sure about IE5.5
14:50:01 <d7> It bails out saying "unexpected EOF"
14:50:09 <Peaker> My toy bicycle allows me to travel :)
14:50:17 <sebz> haha
14:50:57 <Peaker> d7: Is ==<< the same as $$ ?
14:51:01 <HugoDaniel> Peaker: :D
14:51:21 <Peaker> But I don't actually have a toy bicycle, so I can't travel :-(
14:51:35 <HugoDaniel> but you have tryhaskell :)
14:52:03 <mreh> is there a list type that can be parameterised with some phantom like type?
14:52:06 <Peaker> Does anyone know if language-c is mature enough to build a real c indexer? I'm frustrated with the low quality of cscope, etags, etc.. I want a real C indexer that does a 100% job, not an 80% job
14:52:37 <Peaker> mreh: newtype SureThereIs phantom a = AndThereGoes [a]
14:52:55 <Peaker> @hackage dimensions
14:52:56 <lambdabot> http://hackage.haskell.org/package/dimensions
14:53:06 <d7> Peaker: Yes
14:53:11 <Peaker> oops, http://hackage.haskell.org/package/dimensional
14:53:32 <HugoDaniel> @hackage GLHUI
14:53:32 <lambdabot> http://hackage.haskell.org/package/GLHUI
14:53:36 <HugoDaniel> pure l33tness
14:53:41 <Peaker> d7: what is enumSubscriptions? Does it yield at least 10 items?
14:54:11 <Peaker> d7: btw, your semicolons are superfluous
14:54:13 <d7> Peaker: It will yield chunks of 0-n items.
14:54:18 <d7> Peaker: I know, this is a wip.
14:55:10 <Peaker> d7: so enumSubscriptions yields just one chunk?
14:55:10 <rata_> thank you monochrom
14:55:18 <d7> Peaker: I mean, yeah...
14:55:23 <d7> Peaker: That's the idea, right?
14:55:40 <mreh> Peaker: can ghc handle deriving type class instances for that?
14:55:49 <mreh> lets see!
14:55:55 <gwern> Peaker: I heard language-c could parse the linux kernel, so presumably it's complete
14:56:19 <dylukes> when did "can parse the linux kernel" become a measure of completion?
14:56:27 <dylukes> its absolutely completely dependent on GCC extensions anyhow.
14:56:50 <Peaker> gwern: what about the analysis part?
14:57:03 <gwern> dunno. can't be worse than etags or cscope
14:57:21 <d7> Peaker: I just annotated the hpaste to show you what it shows me.
14:57:23 <Peaker> is language-c fast?  If I want to integrate a language-c indexer into emacs -- and re-run it after every change -- would that be practical on a large project?
14:57:38 <gwern> don't know that either
14:57:40 <d7> Peaker: http://hpaste.org/48787
14:58:23 <Peaker> d7: of course length on maybeToList will always be 0 or 1,  and your iteratee requires 10?
14:58:34 <d7> Peaker: Yes.
14:58:48 <d7> Peaker: I thought that the idea here was that the iteratee consumes a series of chunks.
14:58:53 <Peaker> gwern: it's amazing how eclipse/VS have completely left emacs/vim/cscope/etags behind w.r.t code navigation -- and nobody seems to write a good C indexer, which doesn't seem like such a huge undertaking
14:59:20 <Peaker> d7: so what would you expect happen if you have  enumOf1Thing $$ require 5  ?
14:59:42 <d7> Peaker: Then it would fail because enumOf1Thing would send Chunks [oneThing] and then Chunks EOF
15:00:17 <d7> Is this a flawed perception?
15:01:02 <Peaker> d7: isn't this essentially what you're doing?
15:01:16 <Peaker> d7: sending a single element into a require'r of 5 elements?
15:01:36 <d7> Peaker: Maybe my understanding of Iteratees is fundamentally flawed
15:01:45 <d7> But I though that a single chunk was not the extent of the entire stream.
15:02:29 <d7> That there should be several Chunks objects which the enumerator creates, by hook or by crook, and serially feeds into the iteratee. This yields a new iteratee which the enumerator must understand how to handle.
15:02:49 <d7> Because What if I feed it Chunks [1], Chunks [], Chunks [2 3 4], Chunks [], Chunks [5].
15:05:27 <Peaker> d7: http://hackage.haskell.org/packages/archive/enumerator/0.4.10/doc/html/src/Data-Enumerator.html#run
15:05:58 <d7> I understand how it's running the enumerator.
15:06:01 <monochrom> if the iteratee (consumer) is properly written, it won't mind Chunks [] or Chunks [4] or Chunks [4,5,6]
15:06:08 <Peaker> d7: note how "run" sends EOF to the iteratee -- that means you get an EOF after just 1 item
15:06:44 <monochrom> and yeah, only the top-level run or run_ should be handing out EOFs
15:06:52 <Peaker> hmm.. I find the name ==<< very confusing, given that it is often used as:  producer ==<< consumer    which seems to suggest the opposite flow
15:07:15 <d7> Okay... well let me make it even more boiled down.
15:07:15 <monochrom> an enumerator (producer) should indicate "no more" by just not "continuing"
15:07:23 <d7> I say
15:07:25 <d7> enumSubscriptions conn 1000 $$ (EL.take 5 :: Iteratee (Message String) IO [(Message String)])
15:07:47 <Peaker> I didn't remember the enumerator package was that confusing last time I looked.. :-) Maybe I read the "proper" documentation then and am just glancing now
15:07:48 <d7> And if the chunk size is 1, it returns ONE message
15:07:51 <Peaker> but good names go a long way
15:08:05 <monochrom> this is because someone may want to chain two enumerators together, i.e., after one enumerator produces no more data, the second enumerator starts producing
15:08:05 <d7> That makes no sense to me.
15:08:17 <d7> How can one EVER write an enumerator for, say, a socket then?
15:08:38 <monochrom> if you have read the source code of enumFile, you know how. (I did)
15:08:55 <Peaker> monochrom: but I preferred the   enumerator = iterator -> iterator   model, so that (.) is the chainer of enumerators, and ==<< would be piping data left-wards
15:09:12 <d7> It's like the take iteratee is actually ignoring the idea that there could be multiple chunks
15:09:15 <Peaker> s/iterator/iteratee
15:09:32 <Peaker> d7: there couldn't be -- because once you "run" you get an EOF added after that one chunk
15:09:38 <Peaker> d7: and that EOF means "No more chunks, dude, ever"
15:09:44 <d7> Peaker: Well i am not saying that.
15:09:52 <d7> How do I yield more than 1 chunk?
15:10:05 <d7> Esp given that I don't have it yet?
15:10:17 <Peaker> d7: you can recurse in enumSubscriptions
15:10:29 <HugoDaniel> is it possible to write this in a point free style: (\lst -> zip (map myFunc1 lst) (map myFunc2 lst) )
15:10:39 <d7> Isn't that what I am doing in my code? ?
15:10:39 <dylukes> Oh I've had this question before.
15:10:42 <dylukes> I should read this conversation.
15:11:47 <Peaker> hmm.. I must say reading the enumerator package code is somewhat confusing
15:12:05 <Peaker> (and I feel I do understand iteratees, though really hate all the names)
15:12:14 <dylukes> So, how do you do potentially non-terminating iteratees?
15:12:20 <parcs> HugoDaniel: liftM2 zip (map myFunc1) (map myFunc2)
15:12:23 <dylukes> with continuous results (partial I suppose)
15:12:28 <Peaker> d7: no, you don't have any recursion there
15:12:47 <fryguybob> @type \f g -> zip . map f <*> map g
15:12:48 <lambdabot> forall a b a1. (a1 -> a) -> (a1 -> b) -> [a1] -> [(a, b)]
15:12:54 <parcs> if myFunc1 and myFunc2 are of the same type, join (liftM2 (zip `on` map) myFunc1 myFunc2)
15:12:56 <Peaker> d7: you also don't handle non-Continue cases
15:12:57 <d7> Okay, cool.
15:13:07 <nus> @type ap
15:13:08 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:13:13 <holmak> Can anyone recommend a Haskell package with a function for recursively copying directories? Google and Hoogle have both failed me.
15:13:37 <d7> Peaker: I think I got an idea now. Thanks for walking me through it. let me try again
15:13:43 <d7> I actually have an editing error on this.
15:13:57 <holmak> System.Directory has only copyFile, which doesn't support copying directories.
15:15:00 <roconnor> @pf (\lst -> zip (map myFunc1 lst) (map myFunc2 lst) )
15:15:00 <lambdabot> Maybe you meant: bf pl
15:15:01 <roconnor> @pl (\lst -> zip (map myFunc1 lst) (map myFunc2 lst) )
15:15:01 <lambdabot> ap (zip . map myFunc1) (map myFunc2)
15:15:02 <roconnor> @anything
15:15:02 <roconnor> bah
15:15:03 <lambdabot> Unknown command, try @list
15:15:03 <roconnor> HugoDaniel: zip <$> (map myFun1) <*> (map myFunc2) -- I think
15:15:09 <HugoDaniel> ahh
15:15:10 <HugoDaniel> cool
15:15:22 <HugoDaniel> yes, i prefer applicative
15:15:31 <c_wraith> @check (<3)
15:15:32 <lambdabot>   "Falsifiable, after 7 tests:\n4\n"
15:15:36 <HugoDaniel> isn't applicative "the one true way" ?
15:15:45 <Peaker> d7: I think you are interested in the checkContinue0/1 functions, also poorly named
15:15:57 <Peaker> it seems that iteratee implementors have a tendency towards really bad names
15:15:58 <d7> I just saw those
15:16:26 <parcs> @pl (\f -> liftM2 zip (f f1) (f f2))
15:16:26 <lambdabot> ap (liftM2 zip . ($ f1)) ($ f2)
15:16:31 <Peaker> makes me really want to write my inverted-control consumer-pulling iteratee-like library with proper names...
15:16:52 <parcs> :t ap (liftM2 zip . ($ ?f1)) ($ ?f2) map
15:16:52 <lambdabot> forall a a1. (?f1::a1 -> a, ?f2::a1 -> a) => [a1] -> [(a, a)]
15:16:53 <Peaker> (with some stream fusion mixed in)
15:18:08 <dylukes> Peaker: do it then...
15:18:18 <dylukes> it'd be nice.
15:18:32 <Peaker> the Haskell world already has 3 iteratee libraries :-(
15:19:14 <roconnor> I remeber I found the most popular one a little broken
15:19:16 <holmak> sounds like iteratees have not caught up with strings or vectors/arrays yet!
15:19:20 * copumpkin writes a new and better one
15:19:23 <copumpkin> caus eI don't like any of them
15:19:38 <dylukes> We already have 20+ FRP libraries ^^.
15:19:45 <copumpkin> mine will have types up the wazoo
15:19:45 <dylukes> Nothing wrong with some more Iteratee ones.
15:19:55 <copumpkin> so many types you'll scream at me to stop
15:19:58 <dylukes> copumpkin: Dependently-typed, length observed iteratees?
15:20:05 <copumpkin> dylukes: nah, this is in haskell
15:20:09 <dylukes> :<
15:20:17 <dylukes> Haskell FFI to Agda. gogogo.
15:20:26 <copumpkin> besides, I can't really put a length on an iteratee :)
15:20:27 <dylukes> How fast is compiled Agda btw?
15:20:31 <HugoDaniel> i should write one that uses llvm in the mix
15:20:34 <copumpkin> cause it's the processor, not the thing being processed
15:20:41 <copumpkin> dylukes: I dunno, never done it :P
15:20:56 <copumpkin> dylukes: for a while the only real compiler compiled to haskell by wrapping every expression in unsafeCoerce
15:20:57 <dylukes> It's definitely *possible* to write arbitrarily complex programs using the Haskell FFI (i.e, pull in IO then define the rest yourself).
15:20:59 <Peaker> roconnor: the enumerator one?
15:21:04 <roconnor> ya
15:21:07 <dylukes> copumpkin: what.
15:21:20 <dylukes> So, I'd assume it's somewhat quick then...?
15:21:20 <Peaker> roconnor: I find all the names very misleading, and the Step/Iteratee dichotomy superfluous
15:21:35 <roconnor> it seemed be using undefined for things that ought to be statically eliminated with types.
15:21:36 <dylukes> Peaker: Please do a rewrite then ^^
15:21:52 <copumpkin> roconnor: the ideas I've been throwing around do that
15:21:53 <Peaker> Also, I'm pretty sure (but not positive) that the chunks stuff and error handling can be done on as a separate modular layer, and not complicate the core combinators...
15:22:19 <Peaker> dylukes: I'll try, I doubt I'll have time and energy to get anything more than a toy started, though
15:23:04 <copumpkin> has anyone thought about the invariant input argument?
15:23:15 <matthiasgorgens> what is that argument?
15:23:37 <copumpkin> it "feels" like an iteratee should be contravariant in its input and covariant in its output
15:23:37 <hpaste> int80_h pasted ‚ÄúThroughly confused by this error message‚Äù at http://hpaste.org/48791
15:23:47 <copumpkin> and it is covariant in its output, but not contrav in its input
15:23:55 <HugoDaniel> ah cool ghc 7 has data type contexts
15:24:00 <HugoDaniel> this might come in handy :)
15:24:09 <d7> Ahah
15:24:09 <holmak> Sorry for repeating myself, but -- Can anyone suggest a function for copying directories? I can't find any existing packages.
15:24:11 <dylukes> HugoDaniel: what?
15:24:14 <d7> Checkcontinue makes things much easier.
15:24:21 <copumpkin> HugoDaniel: they were just removed
15:24:28 <HugoDaniel> ah
15:24:29 <HugoDaniel> really ?
15:24:31 <HugoDaniel> bummer
15:24:31 <HugoDaniel> :/
15:24:33 <Peaker> copumpkin: I think there is/can be an:  (in' -> in) -> Iteratee in m out -> Iteratee in' m out    combinator
15:24:41 <HugoDaniel> i was reading up ghc 7.0.1 changes
15:24:46 <copumpkin> Peaker: how?
15:25:06 <copumpkin> Peaker: that's what I want, but with all the iteratees I've seen, that can't exist
15:26:05 <rata_> monochrom: is there a tool to detect those simple infinite loops?
15:26:17 <Peaker> copumpkin: oh, right, I'm looking at the definition -- an Iteratee may yield a "remaining stream" of inputs
15:26:37 <copumpkin> yeah
15:27:07 <d7> Peaker: This is what I ended up with: http://hpaste.org/48792
15:27:13 <copumpkin> it bothers me, but there seems to be no way around it
15:27:14 <gwern> holmak: I see nothing in http://www.haskell.org/ghc/docs/6.10.2/html/libraries/directory/System-Directory.html - perhaps you should use getDirectoryContents and map a copyFile?
15:28:01 <Peaker> copumpkin: interesting riddle.. :)  I'm sure there must be a way around it :)
15:28:06 <Peaker> thinking...
15:28:17 <d7> Peaker: Thanks for your help/patience
15:28:23 <copumpkin> think about how you would write a Monad bind
15:28:24 <holmak> gwern: I think that's what I'll have to do. Thanks.
15:28:30 <Peaker> d7: why did you get rid of the maybeToList?
15:28:57 <gwern> holmak: might be tricky preserving the tree. you'll need to strip off the prefix if it gives you absolute addresses rather than relative
15:29:09 <gwern> holmak: and I dunno if copyFile will make the necessary directory structure
15:29:33 <holmak> gwern: Ugh. This is why I wanted to use someone else's implementation :)
15:29:34 <hpaste> Peaker annotated ‚ÄúFixed‚Äù with ‚ÄúFixed (annotation)‚Äù at http://hpaste.org/48792#a48793
15:29:35 <ion> import {-# SOURCE #-} qualified Data.Enumerator.List as EL
15:29:38 <d7> Peaker: as an artifact of how I wrote it.
15:29:43 <ion> Huh. Haven‚Äôt encountered that annotation before.
15:30:21 <int80_h> hiya #haskell. Could someone take a look at my hpaste?
15:30:48 <ion> ok http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/separate-compilation.html#mutual-recursion
15:31:23 <int80_h> ion: was that link for me?
15:31:38 <ion> No
15:32:01 <dylukes> It seems to me,
15:32:17 <dylukes> the more conditionals/case statements you can replace with pattern matching, the better
15:32:19 <dylukes> (in general)
15:32:25 <dylukes> code tends to look cleaner, at least.
15:32:40 <dylukes> Maybe not all case, but definitely ifthenelse
15:32:46 <dylukes> ifthenelse is so ugly :\
15:33:28 <monochrom> rata_: I don't know of one, except myself
15:33:33 <HugoDaniel> ifthen else ?
15:33:45 <HugoDaniel> how can i replace ifthenelse with pattern matching ?
15:33:58 <gwern> holmak: there may be some existing implementations. let me finish grepping through my collection of 100k files or so
15:34:30 <dylukes> I guess what I'm saying is the more you can encode at the type level the nicer code seems to be.
15:34:33 <gwern> holmak: ./ghc/libraries/Cabal/Distribution/Simple/Utils.hs has a copyDirectoryRecursiveVerbose which might be useful?
15:35:09 <luite> hehe that certainly is a verbose function name :p
15:36:13 <rata_> ok
15:36:18 <HugoDaniel> i like if then else
15:36:19 <Peaker> copumpkin: hmm.. Let's say we're starting out with: Consumer in out = ([in] -> Done out [in] | Consumer in out)
15:36:31 <Peaker> copumpkin: and we want to make it contravariant on in, right?
15:36:42 <HugoDaniel> i like the fact that it is an expression
15:36:47 <copumpkin> Peaker: yeah
15:37:09 <Peaker> copumpkin: I have an idea that I'm not yet sure if works:  Consumer in out = forall mid. (in -> mid, ([mid] -> Done out [mid] | Consumer in out))     -- so clearly we're contravariant on in,  but I'm not entirely sure if we're still a consumer :)
15:37:12 <gwern> holmak: there's also ./haskellfm/SystemOperations.hs & ./haskellfm/DirectoryOperations.hs
15:37:53 <Peaker> copumpkin: hmm.. I guess now we can't really make use of the "stuff still left to process"
15:37:57 <copumpkin> yeah :/
15:38:04 <copumpkin> it seems kind of fundamental
15:38:44 <parcs> :t ?x >>= return . return
15:38:45 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (?x::m a, Monad m, Monad m1) => m (m1 a)
15:39:41 <benmachine> parcs: = liftM return x
15:39:58 <parcs> nice
15:40:25 <benmachine> (= fmap return x, if the monad laws are satisfied)
15:41:48 <Peaker> copumpkin: well, I don't think it's fundamental, you could do something ugly like:  Consumer in out = [in] -> (Done out Int{-left to consume-}, NeedMore (Consumer in out))
15:41:52 <dylukes> Peaker: Please keep network streams in mind while you come up with this :\
15:41:59 <parcs> @pl \x -> x >>= return . return
15:41:59 <lambdabot> (return `fmap`)
15:42:01 <dylukes> I'd love something that'd be easier to use with those.
15:42:11 <Peaker> dylukes: have you read "from lists to streams to nothing at all"?
15:42:15 <dylukes> No I havent.
15:42:16 <copumpkin> Peaker: I thought of that, but try working through it
15:42:20 <dylukes> Is that the fusion paper?
15:42:26 <Peaker> dylukes: I really recommend that paper -- yeah it's the fusion
15:42:28 <dylukes> I think I might have it in my downloads folder.
15:42:31 <dylukes> yep, I do.
15:42:34 <dylukes> I've been meaning to read it.
15:42:43 <dylukes> doing my anki practice atm.
15:43:06 <Peaker> dylukes: Well, I think their representation of a list as a Stream producer using an existentially-typed state, if lifted into a monad, can be used to compose iteratee-like streams
15:43:06 <gwern> anki, excellent
15:43:34 <dylukes> gwern: It is.
15:43:42 <dylukes> It still requires some dedication from the user of course.
15:43:47 <Peaker> except instead of Iteratee=consumer-state-machine,  you get  Stream=producer-state-machine,   and so instead of your main loop being a single producer driving the pipe, your main loop is a single consumer driving the producers pipeline
15:43:55 <gwern> dylukes: I have often observed that
15:44:00 <dylukes> For instance, going through this deck of 700+ jp vocab is useless unless I make sure I know not only the words,
15:44:06 <gwern> (as has piotrz wozniak)
15:44:07 <dylukes> but the relevant kanji, and even the components of them.
15:44:20 <Peaker> as long as the consumer can tell the producer chain: Game Over, please clean resources,  and has a clean loop with a guaranteed end -- I think you get the same resource guarantees as in Iteratees
15:44:26 <dylukes> taking time to look up the components with each one has really helped my correctness rates.
15:44:37 <dylukes> Helps my mind come up with visual mnemonics.
15:44:42 <dylukes> gwern: hm?
15:44:54 <gwern> dylukes: wozniak has observed that users often drop SRS
15:45:17 <dylukes> Oh, yeah. It doesn't have an "addictive" element.
15:45:24 <sipa> srs?
15:45:28 <dylukes> I personally look at the charts regularly and become somewhat OCD about not dropping says.
15:45:30 <dylukes> days*
15:45:42 <dylukes> I missed one because I slept through the whole day and I was quite unhappy.
15:45:55 <gwern> dylukes: my own experience is it's a good idea to load one's deck up with poems and quotes and other enjoyable things
15:46:00 <dylukes> i think theres a lot of potential in combining SRS with some sort of tokenized reward system.
15:46:23 <dylukes> gwern: I know a guy learning esperanto‚Ä¶ who inserted porn every 150 words...
15:46:26 <dylukes> ¬¨__¬¨
15:46:30 <dylukes> I feel like that's a bad idea.
15:46:33 <gwern> dylukes: if it works
15:46:40 <dylukes> I suppose.
15:46:45 <parcs> porn? like what?
15:46:55 <parcs> erotica?
15:47:02 <dylukes> as opposed too?
15:47:04 <dylukes> to*
15:47:05 <gwern> parcs: images would work best, probably
15:47:10 <parcs> anki supports images?
15:47:15 <dylukes> Anki cards are LaTex
15:47:24 <parcs> oh
15:47:25 <dylukes> er, HTML actually.
15:47:30 <dylukes> Not LaTex, my bad.
15:47:37 <dylukes> Why do I recall LaTeX then?
15:47:39 <dylukes> Hm, oh well.
15:47:44 <gwern> dylukes: anki ought to support latex
15:47:54 <bl4ck> dylukes: you can put LaTeX markup in Anki
15:47:55 <gwern> it would be quite odd if mnemosyne could and anki couldn't
15:47:59 <bl4ck> which is probably why you recall that
15:48:05 <dylukes> bl4ck: mmk.
15:48:08 <dylukes> gwern: We should make a Haskell-based alternative :) hehe
15:48:24 <dylukes> anyways, the trick to anki is motivation
15:48:27 <gwern> mnemosyne also handles videos I believe, if you abuse the <audio> tag
15:48:31 <smop> that sounds awesome lol
15:48:35 <gwern> (since it shells out to mplayer)
15:48:35 <dylukes> once you get through 2-3 weeks, you're "stuck"
15:48:46 <dylukes> I mean, in a good way.
15:49:02 <dylukes> It's just the general trend is: three days of overstudy, and then a downwards spiral out of using it.
15:49:24 <gwern> dylukes: if one actually wants to learn. as hanson remarks of prediction markets, one obvious explanation for their lack of popularity is that many people do not actually want accurate forecasts
15:49:41 <dylukes> Yeah, it can be disappointing to look at an anki chart and see
15:49:49 <dylukes> "wow, I'm not going to have all of these even as MATURE for 200 days"
15:49:54 <gwern> holmak: also, ./Tilatti/GoCurry/src/file_utils.hs ./seereason/autobuilder/Debian/AutoBuilder/BuildTarget/Quilt.hs
15:50:01 <Peaker> copumpkin: I think another direction to take -- is to replace the "remaining-list"  with the only possible use of it: A function that takes the remaining list to yield the next iteratee state
15:50:03 <dylukes> But you have to keep in mind "wow, thats 800 words in a language I'm just learning. That fast!?"
15:50:12 <dylukes> People are greedy >.>
15:50:16 <copumpkin> Peaker: hmm
15:50:52 <holmak> Gwern: Thanks. I think I can adapt the Cabal one to my purposes.
15:51:19 <gwern> dylukes: people compare against massed repetition and then fast forgetting. so spaced comes off looking bad though it deliver more and is oranges to apples
15:51:30 <sm__> hi all. Where do I find a ghc binary package for osx 10.5 ?
15:51:32 <dylukes> gwern: That's true too.
15:51:47 <dylukes> I think anki can be a bit "general" though.
15:51:52 <Peaker> copumpkin: oops, if you force construction of consumers to be like the construction of DLists, you always know the "consumer after the end" when building a consumer, so you can get rid of the remaining-list altogether, and just give it right there
15:51:53 <dylukes> I guess that's what it's intended to be though.
15:52:05 <gwern> holmak: if you have time, it might be a good idea to advocate for a nonverbose version of copyDir to be added to system.directory
15:52:06 <Peaker> copumpkin: though I guess that would make them far less composable for little gain
15:52:13 <dylukes> For instance, for kanji, it is *ridiculously* helpful to not only go over the whole thing, but also the components, as I've said.
15:52:27 <dylukes> It cuts down the amount of time to memorize by at least 300% in my experience, and you remember it far longer.
15:52:29 <gwern> dylukes: I wouldn't know; I don't study japanese or use anki. I'm a real minority
15:52:40 <holmak> gwern: I was just looking up the maintainer -- libraries@haskell.org, apparently
15:52:46 <dylukes> I'd say people who do both are in the minority...
15:52:52 <dylukes> even the top deck only has 90,000 downloads.
15:53:20 <gwern> dylukes: that sounds too high given the popularity numbers I was able to find: http://www.gwern.net/Spaced%20repetition#popularity
15:54:04 <gwern> (90k downloads would be basically twice as many installs as are known)
15:54:21 <dylukes> I'm sure there are multiple downloads.
15:54:29 <dylukes> Mmenosyne doesn't seem nearly as nice though...
15:54:33 <dylukes> oh well.
15:54:41 <gwern> mnemosyne is more minimalistic and easier to use in some ways
15:55:13 <parcs> mnemosyne still uses qt3 it seems :(
15:55:22 <dylukes> Ugh.
15:55:24 <dylukes> PyQT is horrid.
15:55:32 <gwern> why does everyone say that what qt4 feature are you using that is so important
15:55:46 <dylukes> qt4 had a lot of reorganization I think
15:55:54 <dylukes> plus no one likes old dependencies
15:55:56 <parcs> i just don't want to install a deprecated library for a single application, especially when there are competitive alternatives
15:56:20 <gwern> how does installing an old library hurt you? o.0
15:56:32 <dylukes> its messy, and they often have security holes.
15:56:34 <parcs> it taints my precious bledding-edge arch linux system
15:56:36 <dylukes> which are never bothered to be fixed.
15:56:40 <dylukes> parcs: but mostly this ^
15:56:56 <gwern> well, as long as you don't run the server version of Mnemosyne...
15:57:05 <holmak> gwern: I will try to advocate for it, then! Thanks.
15:57:37 * gwern notes that was sarcasm. there is no such thing as a server version, and how could a local SRS app be attacked except by another local app?
15:58:06 <parcs> but also its use of qt3 is, to me, a sign that the software is poorly maintained
15:58:18 <gwern> holmak: well, good luck. make sure to note that Cabal's use means it has undergone massive testing
15:58:26 <dcoutts> ho ho
15:58:30 <gwern> parcs: the rewrite has been distressingly slow, yes
15:58:30 <holmak> gwern: Good point
15:58:42 * dcoutts just added that code the other day
15:58:53 <gwern> dcoutts: well, am I wrong? does cabal not use copyDirectory in installs?
15:59:07 <holmak> It was marked deprecated, actually
15:59:25 <dcoutts> gwern: it should be fine, it's been tested in ghc head for a few weeks
15:59:28 <gwern> (oh. deprecated in favor of what one wonders)
15:59:33 <dcoutts> just pointing out it's newish code
15:59:36 <holmak> "installDirectoryContents"
16:00:10 <dcoutts> the new code does permissions differently
16:00:16 <gwern> dcoutts: a few weeks? I found the prefix 'copyDir' in like 10 repos and in files like Setup.hs, you mean to tell me they all have synced and I synced with them in just a few weeks?
16:00:31 <dcoutts> gwern: sorry, getting confused between the old and new code in that area
16:00:53 <gwern> ‡≤†_‡≤†
16:01:05 <gwern> now you've probably confused poor holmak
16:01:15 <holmak> dcoutts: The "installOrdinaryFiles" function and friends seem to be the new code. Is that right?
16:01:35 <gwern>  holmak is no doubt all confuzzled. 'is this tested? should I copy the other function? what do I tell libraries@ to get them off their collective asses?'
16:01:59 <dcoutts> holmak: yep
16:02:02 <holmak> This is what I get for practicing Haskell without a license
16:02:50 <holmak> I would surely not have these problems if I had the recommended 1-2 PhD's :)
16:03:04 <proq> that's right, use haskell without a license, go to jail
16:03:18 * gwern uses haskell with a license. a BSD license to sigkill
16:03:57 <holmak> I'm trying to think of some joke about 007 being in octal
16:04:00 <holmak> I've got nothing
16:04:30 <gwern> 007. permission to read-write-execute Her Majesty's enemies.
16:04:30 <c_wraith> 007 is a very funny permission setting
16:04:55 <holmak> chmod joke! I totally missed that one
16:05:21 <shachaf> c_wraith: Is the owner/group still allowed to rwx a file with those permissions?
16:05:34 <c_wraith> shachaf: I believe so.  Haven't tried it
16:07:21 <smop> gwern: do you just use one big deck for your repetitions?
16:08:28 <proq> shachaf: no, they would have to set them back with sudo or su
16:09:46 <shachaf> proq: Doesn't seem like sudo or su is necessary if you own the file.
16:10:23 <proq> unless you are root, you won't be able to touch the file.  unless you are using a unix system that has a different notion of how those permissions work
16:10:39 <shachaf> I seem to be, then.
16:15:04 <proq> really? I see the same behavior on os x and debian
16:16:25 <proq> chown user:user foo; chmod 007 foo; su user; echo "foo" > foo => permission denied; cat foo => permission denied
16:18:58 <gwern> smop: one deck, yeah
16:19:00 <Peaker> copumpkin: do you know the WithCont type from conal's blog?
16:19:04 <copumpkin> nope
16:19:54 <Peaker> copumpkin: http://conal.net/blog/posts/enhancing-a-zip/
16:20:17 <Peaker> copumpkin: it seems to me like there may be a dual of that like WithPre that may apply here
16:21:11 <smop> ah, I was doing one per subject
16:21:22 <smop> i may try that out and see if it works better
16:22:58 <gwern> smop: I didn't see any advantage to many decks. lots of overhead, no clear advantage, and if your card doesn't make sense in isolation is it a good card or if you can't remember it without all sorts of previous cues and related priming material is it really something you've learned?
16:29:36 <smop> i suppose that makes sense, i mostly had them in decks for review purposes. i know the supermemo guy does 1 big deck as well, but sometimes I just wanted to do say spanish and not ido
16:37:56 * hackagebot riak-protobuf 0.15.0.0 - Haskell types for the Riak protocol buffer API  http://hackage.haskell.org/package/riak-protobuf-0.15.0.0 (BryanOSullivan)
16:37:58 * hackagebot riak 0.6.0.0 - A Haskell client for the Riak decentralized data store  http://hackage.haskell.org/package/riak-0.6.0.0 (BryanOSullivan)
16:45:07 <aavogt> gwern: you might want to get rid of some cards after a course has finished (to focus on other things)
16:45:21 <gwern> aavogt: so, in other words, you didn't actually want to know it...
16:47:45 * geheimdienst will load up that card learning thingy with lolcats
16:50:49 <ion> > let f ("foo" ++ bar) = bar in f "foobar"
16:50:50 <lambdabot>   <no location info>: Parse error in pattern
16:51:08 <ion> Wow, Erlang has a piece of syntactic sugar Haskell lacks. ;-)
16:51:31 <c_wraith> it has a bunch, related to string handling mostly
16:52:12 <shachaf> > let f (stripPrefix "foo" -> Just bar) = bar in f "foobar"
16:52:13 <lambdabot>   "bar"
16:52:30 <smop> maybe temporarily
16:52:35 <dylukes> ion: what?
16:52:43 <aavogt> > let f ('f':'o':'o':bar) = bar in f "foobar"
16:52:44 <lambdabot>   "bar"
16:52:45 <ion> Ooh, ViewPatterns has been turned on in lambdabot?
16:52:58 <shachaf> It's been on for a long time, hasn't it?
16:53:00 <copumpkin> that's a plain ol' pattern
16:53:18 <aavogt> the stripPrefix one is a view pattern
16:53:24 <copumpkin> oh, didn't see that
16:53:30 <dylukes> That strikes me as a bit confusing
16:53:37 <dylukes> what if you wanted to pattern match on the -> constructor
16:53:40 <dylukes> I guess‚Ä¶ you cant...
16:53:42 <dylukes> but oh well.
16:53:44 <copumpkin> it isn't a constructor
16:53:51 <ion> 2011-06-25 16:22:21 < lambdabot>   ViewPatterns is not enabled
16:53:51 <copumpkin> or rather, it's a type constructor
16:53:56 <dylukes> yeah...
16:54:01 <dylukes> kind or w/e
16:54:16 <copumpkin> you can match on (->) in type families :)
16:54:18 <shachaf> > (/) w e
16:54:19 <lambdabot>   w / e
16:54:36 <geheimdienst> > j/k
16:54:37 <lambdabot>   j / k
16:54:45 <dylukes> > a
16:54:46 <lambdabot>   a
16:54:53 <dylukes> > show a
16:54:54 <lambdabot>   "a"
16:55:02 <dylukes> >_>‚Ä¶ who did that...?
16:55:05 <dylukes> > show foobar
16:55:06 <lambdabot>   Not in scope: `foobar'
16:55:14 <geheimdienst> > lol
16:55:15 <lambdabot>   Not in scope: `lol'
16:55:16 <dylukes> okay, so‚Ä¶ all of the one letter variables are assigned to a matching string?
16:55:35 <ion> > foldr f z [a,b,c]
16:55:36 <lambdabot>   f a (f b (f c z))
16:55:50 <ion> There‚Äôs more magic involved. :-)
16:56:02 * hackagebot stringprep 0.1.4 - Implements the "StringPrep" algorithm  http://hackage.haskell.org/package/stringprep-0.1.4 (GeorgePollard)
16:56:57 <dylukes> ion: Goddamn Caleskell.
16:57:08 <copumpkin> it's simple-reflect
16:57:12 <dylukes> ?
16:57:16 <copumpkin> @hackage simple-reflect
16:57:17 <lambdabot> http://hackage.haskell.org/package/simple-reflect
16:57:49 <dylukes> I see.
16:57:54 <aavogt> ion: it's been enabled since before that. I've got a lambdabot repo with a patch changing a line with -XViewPatterns dated 20101120163835
16:59:17 <ion> aavogt: Was the lambdabot instance on this channel running older code?
16:59:57 <aavogt> for some time it may have been
17:04:56 <hpaste> ‚Äúcontravariant-supportive Consumer that can leave uneaten output‚Äù pasted ‚ÄúPeaker‚Äù at http://hpaste.org/48794
17:05:10 <Peaker> copumpkin: Here is the ugly Int approach
17:05:18 <Peaker> copumpkin: I think it works -- but is ugly as hell :)
17:05:56 <Peaker> oops, left some comments at the end accidentally
17:06:48 <hpaste> Peaker pasted ‚ÄúWith unrelated comments removed‚Äù at http://hpaste.org/48795
17:07:34 <Peaker> I'm pretty sure an existential can solve the problem using a sane/non-Int approach there
17:07:55 <Peaker> but it's a hard riddle for me, IANATT (I'm not a type-theorist) :)
17:08:52 <copumpkin> Peaker: hmm
17:08:59 <copumpkin> I'm not sure that's quite the same
17:09:14 <copumpkin> how do I say "I saw what you gave me, and I didn't want it all"?
17:09:28 <Peaker> copumpkin: AteSome 0
17:09:42 <copumpkin> oh, so I'd run for another step?
17:09:50 <copumpkin> ?
17:09:56 <Peaker> copumpkin: yeah
17:10:16 <copumpkin>  so you fed me "moooo" and I'm ready to return 5, after having "consumed" "moo"
17:10:17 <Peaker> copumpkin: instead of "leftover inputs" being something Done can be over with, it's just something every step can have
17:10:50 <copumpkin> hmm, I see
17:10:56 <Peaker> copumpkin: so you have:  Hungry $ \inputs -> (AteSome 3, Satisfied 5)
17:11:15 <copumpkin> so Hungry's a bit of a misnomer?
17:11:22 <Peaker> why?
17:11:23 <copumpkin> cause I'm not hungry, I'm full!
17:11:29 <copumpkin> :P
17:11:36 <Peaker> No, you're hungry :)
17:11:41 <copumpkin> you gave me "mooooo" and I can't eat it all
17:12:01 <Peaker> copumpkin: So you were less hungry than what I thought but still hungry
17:12:08 <Peaker> (you wanted "moo" I gave you "mooooo"
17:13:04 <Peaker> now I pulled an http://xkcd.com/859/  by accident :)
17:13:23 <copumpkin> :)
17:14:34 <copumpkin> I think I see how you mean
17:14:45 <copumpkin> also, the existential list thing should be roughly isomorphic to a natural, anyway
17:18:32 <copumpkin> bos: in your geometricMean function in statistics, it seems like it'd be helpful to put the whole thing into logspace
17:19:05 <Peaker> copumpkin: I still don't feel I have a good understanding of it... If the list-of-existential is used as an Int, it defeats the point (efficiently resuming consumption)
17:19:31 <bos> copumpkin: could be
17:20:44 <Peaker> conal: you there? I'm sure you'd have smart things to say about this, I can fill you in :)
17:21:06 <conal> Peaker: i'm here. what's up?
17:21:50 <copumpkin> bos: not that I've actually had any problems with the definition :) I'm just wary of lots of multiplications
17:21:50 <Peaker> conal: we are trying to figure out if the definition of an efficient Consumer i o (that has the semantic model of [i] -> o) defined as:   Consumer i o = [i] -> ([i] -> Done o [i] | More (Consumer i o))  -- can be contravariant in i
17:22:22 <conal> ah, okay. processing ...
17:23:05 <Peaker> oh wait: my semantic model is wrong
17:23:10 <bos> copumpkin: and rightly so!
17:23:30 <conal> Peaker: is that type supposed to be a (correct) optimization of something simpler?
17:23:36 <copumpkin> but lots of additions are also bad if the numbers have very different magnitudes!
17:23:41 <copumpkin> damn floats are hard
17:23:43 <copumpkin> let's go shopping
17:24:22 <Peaker> conal: well, a Consumer can do two interesting things: A) Eat inputs (not necessarily all of them) and yield a result  B) Compose with consumers such that unconsumed inputs spill over to the next consumer
17:25:21 <Peaker> conal: I guess I can put aside the efficiency concerns at first -- and just figure out if this Consumer notion can be contravariant on the input type in any representation (I found one, but it is ugly)
17:26:01 <conal> Peaker: yeah. i'd first try to find a specification that is as simple as possible, with no concession at all to performance. only simplicity & correctness. and then relate that spec precisely to possible optimized representations.
17:26:06 <thoughtpolice> floats are hard, let's go shopping? more like 'floats are crazy complex in reality, seem to drive sane men mad, and only wish to conquer their enemies, see them driven before then and hear the lamenations of their women'
17:26:12 <thoughtpolice> now let's go shopping.
17:26:58 <conal> Peaker: i was playing with something similar in august, when i asked around about whether iteratees etc have any semantic model other than their various implementations.
17:27:12 <cmccann> thoughtpolice, you can't go shopping, someone accidentally used floats to represent money and now your bank account contains NaN
17:27:15 <Peaker> conal: yeah, unsurprisingly this is coming from an Iteratee discussion :-)
17:27:17 * Pseudonym didn't know that floats reproduced sexually
17:27:25 <Pseudonym> Unlike Unix processes.
17:27:30 <conal> Peaker: i had a hunch. ;)
17:28:00 <thoughtpolice> cmccann: i accidentally the whole NaN
17:28:10 <conal> Peaker: for instance, the State-like model of [i] -> (a,[i]) is somewhat appealing, but it's very junky, as it doesn't say that the result list is a suffix of the source list.
17:28:33 <Peaker> conal: so:  Consumer i o = [i] -> ([i], o)   ;   compose :: Consumer i o -> (o -> Consumer i o2) -> Consumer i o2  ;  compose c1 f is = let (is', o) = c1 is in f o is'
17:29:05 <Peaker> conal: yeah, that exact thought passed through my head as I wrote that model -- except I never remember the "junk" and the other term for semantic models :)
17:29:19 <Peaker> so "junk" is "can represent invalid things"?
17:29:59 <conal> Peaker: yeah. "junk" is the inhabitants of the semantic model that are not in the image of the semantic function.
17:30:06 <cmccann> if you want to exclude it doing something like permuting the unconsumed inputs, you'll probably need to have it take one input at a time and say whether it ate it or not
17:30:54 <Peaker> conal: Maybe it is possible to use a phantom existential on a list wrapper type, to make sure the result list is some tail of the given list
17:30:54 <conal> Peaker: your compose is the same as >>= for State ?
17:31:15 <Peaker> conal: yeah, that would have been easier to say :-)
17:31:24 <conal> Peaker: oh. some kind of parametricity trick?
17:31:34 <Peaker> yeah, I'll try to play with that for a minute
17:32:15 <copumpkin> Peaker: not really sure how that would work
17:32:39 <cmccann> Peaker, wouldn't building it as consuming single inputs be... much simpler?
17:32:39 <conal> Peaker: the model i was thinking of was [i] -> (Integer,o), where the integer says how many elements are consumed.
17:32:39 <copumpkin> Peaker: you need to know about the contents of the list to do anything interesting, but to guarantee you only provide some sublist of the input list, you need to not know about the contents of the list
17:32:59 <copumpkin> cmccann: then you lose the efficiency benefits
17:33:15 <Peaker> conal: that also has junk
17:33:19 <copumpkin> conal: Natural! Integer's got a whole world of junk in it :)
17:33:30 <conal> copumpkin: thx. Natural.
17:33:31 <Peaker> Natural has less junk, but still has junk
17:33:34 <cmccann> copumpkin, I thought the context of discussion was "define the concept without regard for efficiency" right now
17:33:35 <copumpkin> or ideally, Vec i n -> (Fin n, o)
17:33:43 <conal> Peaker: what junk with Natural?
17:33:54 <Peaker> conal: the part not inside Fin n
17:33:57 <conal> copumpkin: oh yeah. better!
17:34:02 <copumpkin> or Fin (suc n), I guess
17:34:08 <copumpkin> hmm
17:34:15 <cmccann> also, what about it inspecting more of the list than it consumes? is that correct?
17:34:37 <conal> Peaker: i don't understand. the result does *not* contain the suffix. just the # consumed and the result.
17:34:57 <conal> Peaker: i'm not yet seeing the junk (assuming Natural)
17:35:25 <cmccann> conal, what if it says it consumed 5 items when it was only given 3?
17:36:03 <conal> cmccann: ah. relating the *input* length to the # consumed. thx.
17:36:21 <conal> as copumpkin was saying and i missed.
17:36:22 <copumpkin> Peaker: one issue I thought of with your earlier encoding
17:36:47 <copumpkin> is that what if I want to reject several past chunks at once?
17:36:54 <copumpkin> say I need a lot of lookahead
17:37:11 <copumpkin> you don't know how much of the input to keep around
17:37:35 <copumpkin> because I could potentially reject all of it
17:37:36 <Peaker> copumpkin: indeed, in my model once input was eaten -- it's gone forever
17:37:43 <wli> Holy cow I just found a Remez algorithm for splines (of the ordinary polynomial variety).
17:37:44 <copumpkin> that is so sad
17:38:40 <conal> so let's try "Vec i n -> (Fin n, o)" as a spec and then derive an correct, efficient implementation.
17:38:55 <copumpkin> or Fin (suc n), since you can consume none or all of it, I guess
17:39:08 <wli> If I could find and compare a rational Remez proof maybe I could hammer out an exchange algorithm for C^d continuous families of piecewise rational functions.
17:39:23 <conal> copumpkin: yeah.
17:39:31 <conal> Peaker: sounds good to you?
17:39:58 <conal> Peaker: as a solid basis for questions about efficient implementation
17:41:40 <Peaker> conal: Yeah, though I'm still toying around with an attempt to make a phantom-parameterized list type that can guarantee a result list is some tail of an input list
17:42:04 <conal> Peaker: neat. i'm glad. hadn't occurred to me.
17:43:38 <Peaker> conal: I'll abandon that for the moment -- let's continue to the efficient-implementation part
17:44:04 <copumpkin> Peaker: I still don't think that's possible :(
17:44:21 <conal> Peaker: based on "Vec i n -> (Fin (S n), o)" ?
17:44:28 <conal> Peaker: (as a spec)
17:45:07 <Peaker> conal: Yeah..
17:45:49 <conal> (or "Vec n i" for more haskell-friendliness)
17:45:58 <Peaker> conal: refinement: "type Consumer i o = forall n. Vec n i -> (Fin (S n), o)", right?
17:46:20 <Peaker> we probably don't want the n to escape out of there
17:46:31 <conal> Peaker: ah, yeah. looks right to me.
17:48:18 <Peaker> so then the spec continues:  "feed" converts Consumer i o to its semantic model (can be id in the model/spec)
17:48:33 <gwern> 1well, I guess we know what audrey tang has been up to: http://www.aosabook.org/en/socialcalc.html
17:48:41 <gwern> not in haskell, more's the pity
17:50:34 <Peaker> and   "compose :: Consumer i o -> (o -> Consumer i o2) -> Consumer i o2      ;   compose c f ivec = let (n,o) = c ivec  ; (n2,o2) = f o (drop n ivec)   in  (n+n2, o2)"
17:51:04 <rata_> https://gist.github.com/1068694 <- does this function only evaluates until it find the first j for which Set.member j codom returns true?
17:51:20 <conal> Peaker: that def is what i was thinking.
17:51:36 <conal> Peaker: btw, why "compose" instead of "(>>=)"?
17:51:59 <Peaker> conal: so I wouldn't have to wrap it with "instance Monad .... " :-)
17:52:09 <conal> Peaker: oh.
17:52:51 <Peaker> I guess it does deserve a return though:    return x _ = (0, x)
17:53:22 <parcs> Peaker: excuse my ignorance, what is the Fin data type?
17:54:30 <Peaker> parcs: Fin n is a Natural 0..(n-1) inclusive (Fin Zero  is Void)
17:54:57 <parcs> i see. thanks
17:55:23 <Peaker> conal: well, since fmap is trivial, I could have had it easier with defining join, and had even less syntactic overhead, but nm :-)
18:00:46 <hpaste> Peaker pasted ‚ÄúCanAnyoneBreakTail?‚Äù at http://hpaste.org/48796
18:03:01 <Peaker> hmm.. no that doesn't seem to work
18:06:28 <hpaste> Peaker pasted ‚ÄúThis Seems to Work‚Äù at http://hpaste.org/48797
18:06:53 <Peaker> cool... so I just have a   fromList :: exists s. [a] -> ListU s a
18:07:03 <Peaker> and a    toList :: ListU s a -> [a]
18:07:15 <Peaker> and a     tailU :: ListU s a -> ListU s a
18:07:47 <Peaker> And bam:  if you have any function that takes and returns a ListU  with the same phantom type s ---  it guarantees the result is some tail of the argument
18:08:43 <Peaker> Inspired by Oleg's phantom types for array index validation -- and the region calculus work
18:08:57 <Peaker> conal: you still there?
18:09:00 <djahandarie> Peaker, doesn't id do that?
18:09:10 <Peaker> djahandarie: do what?
18:09:12 <djahandarie> id :: ListU s a -> ListU s a
18:09:45 <Peaker> djahandarie: well I mean "drop n" for some n when I say "some tail"
18:10:00 <Peaker> so I can guarantee that you're only "moving forward" in the input
18:11:01 <Peaker> this can actually be useful for guaranteeing parsers are really moving forward -- instead of Parsec/etc being a State transformer with   s = ByteString or String   it can be some newtype with a phantom arg
18:11:39 <siracusa> Any lhs2tex experts here? I want to format a lot ot greek letters like alpha', alpha_1, alpha_n, etc. but it seems I have to mention each of them as its own format directive. Is there a better way of doing that, like saying foo' shall be formatted as foo is formatted plus a prime?
18:11:47 <Peaker> djahandarie: did you ask because id is not "some tail"?
18:11:56 <djahandarie> Yes, I see now.
18:12:26 <Peaker> man, existential/rankN types are really useful
18:12:28 <Jafet> drop 0
18:13:47 <Jafet> That code doesn't exactly do structural recursion, though
18:14:06 <djahandarie> It does in tail.
18:14:09 <Jafet> There is no base case
18:16:33 <luite> @hoogle (a->c) -> (b->d) -> Either a b -> Either c d
18:16:34 <lambdabot> No results found
18:16:53 <c_wraith> :t (|||)
18:16:54 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
18:17:17 <c_wraith> oh, hmm.  not at all what you were looking for
18:17:24 <siracusa> :t both
18:17:25 <lambdabot> Not in scope: `both'
18:17:26 <Peaker> conal: I gotta go to sleep...  will read this log later if you continue
18:17:31 <Peaker> conal: thanks so far.. night!
18:17:50 <conal> Peaker: catch you later. sry. i was distracted by two other conversations.
18:17:57 <siracusa> :t (+++)
18:17:58 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
18:18:05 <c_wraith> that's the one
18:18:54 <c_wraith> though +++ makes me feel like I should be sending modem control signals
18:19:06 <luite> hehe
18:19:09 <luite> yeah thanks
18:22:06 <parcs> oh neat:
18:22:29 <parcs> :t [(?x >>= return) . return, ?x >>= (return . return)]
18:22:29 <lambdabot> Top level:
18:22:30 <lambdabot>     Occurs check: cannot construct the infinite type: a = m a
18:22:30 <lambdabot>       Expected type: m a -> m1 a1
18:22:40 <parcs> oh what
18:23:03 <parcs> oh never mind!
18:29:16 * hackagebot base16-bytestring 0.1.1.2 - Fast base16 (hex) encoding and deconding for ByteStrings  http://hackage.haskell.org/package/base16-bytestring-0.1.1.2 (BryanOSullivan)
18:33:08 <djahandarie> @tell bos You misspelled 'decoding' in base16-bytestring.
18:33:09 <lambdabot> Consider it noted.
18:34:42 <dankna> lol
18:35:38 <dobblego> @tell bos You misspelled enconding in base16-bytestring.
18:35:38 <lambdabot> Consider it noted.
18:37:08 <djahandarie> Heh.
18:37:14 <djahandarie> (Just in case?)
18:37:31 <dobblego> I was just being a dick, then realised I can't delete it, sorry bos!
18:37:42 <djahandarie> :p
18:38:11 <SirFrancisDrake> hello there! Got a newb question
18:38:39 <djahandarie> The floor is yours.
18:39:50 <c_wraith> wait, we're giving away parts of the building now?
18:40:28 <djahandarie> Wait, we have a building?!
18:42:22 <SirFrancisDrake> I'd like to implement a Date data type. Like, data Date = Date Day Month Year etc. But when I start to think about writing increase_date fn, which would correctly handle going into a new month, mind the step years and everything, I can come up only with very ugly code. Is there a simple way I keep missing?
18:42:40 <dankna> yes - use the library "time"
18:43:46 <luite> dates are always going to be ugly
18:44:51 <SirFrancisDrake> so, daysInMonth function, taking a month and a year? Manual check for if month == december?
18:45:02 <dankna> well, you could also use a case
18:45:28 <dankna> if you really want to do it yourself, don't forget to deal correctly with? what was it? 1956 or something, the year that was missing about five days
18:46:01 <dankna> daysInMonth _ January = 31
18:46:14 <dankna> daysInMonth year February = if isLeapYear year then 29 else 28
18:46:21 <dankna> like that
18:47:16 <SirFrancisDrake> lots of typing :) For now I've got something like daysInMonth m y | m == January || m == March (etc.) = 31 (etc)
18:47:30 <dankna> you could always do it like
18:47:49 <dankna> thiryDaysHath :: [Month] ; thirtyDaysHath = [September, April, June, November]
18:48:06 <dankna> daysInMonth _ month | elem month thirtyDaysHath = 30
18:48:20 <dankna> that's strictly slower than the case though
18:48:40 <SirFrancisDrake> ...and I've never heard of 1956 missing five days. Is there a phrase for googling?
18:48:47 <dankna> one sec, I'll find it for you
18:48:51 <dankna> I think it has something to do with a calendar switch
18:49:05 <SirFrancisDrake> oh, so it's different in different countries?
18:49:25 <dankna> I'm not sure, I just remember being amazed that such an artifact existed in such a comparatively recent decade
18:49:28 <SirFrancisDrake> in Russia, I guess, there's a year missing 13 days
18:49:30 <dankna> but I can find it, hold on
18:49:31 <othiym23> isn't that actually 1656?
18:49:44 <SirFrancisDrake> but it was about 100 years ago
18:49:52 <othiym23> it happened during the time of the English Civil War / Samuel Pepys's lifetime
18:50:01 <othiym23> Russia switched its calendar after the Revolution
18:50:06 <dankna> 1752
18:50:26 <othiym23> the Orthodox calendar was still Julian until that time
18:50:29 <dankna> http://en.wikipedia.org/wiki/1752
18:50:39 <dankna> "September 2 ? Great Britain and the British Empire adopts the Gregorian calendar, making the Julian date of September 2 be followed by the Gregorian date of September 14."
18:50:50 <dankna> but yes, as you say, it's different in different countries
18:51:11 <othiym23> yeah, my knowledge of English history isn't what it could be ;)
18:51:12 <luite> hehe so a proper date library takes both location and religion arguments ;p
18:51:23 <dankna> try typing "cal 1752" on your friendly neighborhood Unix machine and see the bizarre way it displays it :)
18:51:32 <dankna> luite: haha yeah
18:51:58 <SirFrancisDrake> afair what we counted at our history lesson, september 14th on that year was a Monday.
18:52:28 <dankna> well, "cal" thinks it was a Thursday
18:52:29 <othiym23> it's always going to be a hodgepodge of weird cases
18:52:48 <dankna> anyway, you haven't said what the purpose of this library is
18:52:53 <othiym23> better just to switch to the Mayan Long Count, which has the added advantage that almost nobody will be able to tell if your dates are right or wrong
18:52:57 <dankna> obviously whether you need to deal with dates that far back at all is going to ...
18:53:02 <dankna> othiym23, doesn't that count end next year?
18:53:14 <othiym23> dankna: it restarts
18:53:18 <dankna> but I agree with that advantage
18:53:19 <othiym23> Mayan time is cyclical
18:53:20 <dankna> oh, okay, haha
18:53:34 <SirFrancisDrake> I'm writing a game. I only need dates in range, say, years 2254-2270
18:53:59 <dankna> oh then you're fine.  just use Gregorian for everything.
18:54:22 <SirFrancisDrake> yeah. Thanks
18:54:59 <luite> hmm, not sure about that. people might get tired of the gregorian system within the next 200 years, so better check first whether there's a new system in place by 2250
18:54:59 <dankna> of course if you need accuracy to the second, you can't get it, because leap seconds aren't predictable in advance (they're determined by astronomical observations each year)
18:55:31 <SirFrancisDrake> it's a game. A blunt model will do
18:55:39 <othiym23> yeah, if you wanted to be all science-fictiony, you could switch to sidereal time
18:55:43 <dankna> luite: yes, it's a little-known fact that IO actually uses rank-two types to constrain its action to obey chronological order
18:55:49 <dobblego> I wrote a Gregorian calendar date using fundeps
18:55:51 <dankna> luite: you can work around that with unsafePerformTimeTravel
18:56:55 <SirFrancisDrake> no worries, I'll read the dates atomically
18:57:03 <dankna> you seem to have reached a decision already, but yeah, you could use any of a number of other variant means of timekeeping.  perhaps the most realistic I've seen is Vernor Vinge's "kiloseconds", "megaseconds", etc, used by spacefaring humans whose calendar isn't bound to any particular planet.
18:57:10 <luite> dankna: does it have known side effects, like unsafePerformTeleport in the neighbourhood of flies?
18:57:21 <dankna> luite: yes it does!
18:57:39 <dankna> luite: actually because of relativity, you can write unsafePerformTeleport in terms of unsafePerformTimeTravel
18:58:07 <SirFrancisDrake> uh, isn't a second bound to a particular planet? Like, a geoid-shaped one?
18:58:27 <dankna> I'm fairly certain we define it in terms of radioactive decay rates nowadays
18:58:33 <dankna> which is certainly convenient as that's how we measure it
18:59:51 <SirFrancisDrake> I had a strange feeling that the equation looked like "radioactive decay rate of (something, cesium?) * (magic constant)"
18:59:57 <luite> dankna: nah in energy difference (frequency) between two energy levels of the caesium atom
19:00:03 <dankna> well, I'm sure there's a magic constant in there, yes
19:00:26 <luite> so not the decay rate, buy the "decay" (it's not decay) energy
19:00:30 <dankna> oh
19:00:51 <dankna> dare I ask how a measurement of energy leads to a measurement of time -- wait, I know this one.  because energy is force over time or something like that.
19:01:07 <dankna> or force times time?
19:01:14 <dankna> or something?
19:01:22 <dankna> bah, my highschool physics teacher would be sad
19:01:24 <SirFrancisDrake> http://en.wikipedia.org/wiki/Second
19:01:31 <luite> err now, wavelength corresponds to energy
19:01:34 <luite> no
19:01:40 * SirFrancisDrake charging itt, dressed captain obvious
19:01:42 <luite> and therefore frequency
19:02:16 <SirFrancisDrake> and magic constant *is* there, actually
19:02:54 <dankna> there was a Heinlein book where people from two different universes are communicating and they have to start by establishing a common system of measurement
19:03:11 <dankna> and one of them conveniently has absolutely perfect sense of timing, so she simply says "These are seconds - one, two, three..."
19:03:42 <dankna> that party trick must be very handy in that precise situation :)
19:03:52 <SirFrancisDrake> and they all seem different to that other guy?
19:03:53 <monochrom> not sure why we're talking about this here, but at any rate you fix on a physical phenomenon that is theorized to be time-dependent only
19:04:18 <dankna> no, actually it worked.  and avoided the need to pull out an encyclopedia haha.
19:04:35 <SirFrancisDrake> way to go
19:04:39 <dankna> yup
19:06:05 <SirFrancisDrake> monochrom: could you elaborate a bit?
19:10:00 <monochrom> I suppose wikipedia is better than me at this
19:10:58 <luite> are we still talking about time measurement/definition, or about this universes communicating?
19:11:15 <dankna> up to you
19:14:16 <luite> anyway about measurement, in practice it works something like this, you have a bunch of caesium atoms and a radio transmitter. at the exact frequency of this energy transition, there's a sharp increase in absorbtion, so you have a feedback loop that keeps your radio exactly tuned to this maximum absorbtion frequency, and that's your time source
19:14:56 <dankna> I see!
19:15:58 <SirFrancisDrake> are caesium atoms synchronized?
19:16:11 <dankna> no, but the constant is large enough that it averages out
19:16:42 <luite> SirFrancisDrake: they move around a bit, so the exact frequencies they absorb vary sligtly
19:17:37 <dankna> oh I see what you're saying now - the radio is broadcasting /through/ the caesium
19:17:45 <luite> yes
19:17:50 <dankna> so you're not measuring decay at all, but absorption.  which is what you said, I just didn't get it.
19:18:15 <luite> if a photon from the radio waves is absorbed, it will be emitted again after a short while, but in a random direction
19:20:42 <SirFrancisDrake> cool
19:28:18 <tgeeky_> ooh, physics in #haskell
19:29:53 <tgeeky_> luite's explanation is pretty spot on, though I'd expect no less
19:30:12 <cmccann> physics is very relevant to Haskell, most people don't realize this but when Einstein complained about "spooky action at a distance" he was really criticizing an implementation based on updating mutable state
19:30:24 <tgeeky_> no he wasn't
19:30:25 <cmccann> Einstein avoided IO as much as possible in all the Haskell code he wrote
19:30:31 <tgeeky_> hehe :)
19:30:57 <tgeeky_> thought a physicist is the first person I know of to use the word 'monad'
19:31:05 <tgeeky_> though he's better known as a mathemitician
19:31:35 <monochrom> but he had something else in mind when he said "monad"
19:31:48 <tgeeky_> true, but like many things he said, one can find interesting parallels
19:32:54 <cmccann> what, Leibniz? yeah, AFAIK his uses of "monad" had nothing to with how the term is used in Haskell
19:34:56 <tgeeky_> if you strip out all of the theological pandering, you're left with something like a unit of interaction between things which exist (space, matter, and motion)
19:35:51 <tgeeky_> The ontological essence of a monad is its irreducible simplicity. Unlike atoms, monads possess no material or spatial character. They also differ from atoms by their complete mutual independence, so that interactions among monads are only apparent. Instead, by virtue of the principle of pre-established harmony, each monad follows a preprogrammed set of "instructions" peculiar to itself, so that a monad "knows" what to do at each m
19:36:49 <djahandarie> (Physicists do use category theory monads though, if you look in the right places.)
19:37:01 <tgeeky_> I haven't seen that yet.
19:37:18 <tgeeky_> the n-cafe doesn't use them do they?
19:37:59 <cmccann> monads are a rather general concept, so I'd be surprised if they didn't arise in almost any substantial application of category theory to a subject
19:38:25 <wli> The French revolutionary "metric calendar" was a flop.
19:38:25 <tgeeky_> i would be surprised.
19:38:44 <tgeeky_> it looks like monad sprouted up before Liebnitz, but I can't tell where. 1610s
19:39:15 <wli> BTW units(1) understands metric scaling prefixes (e.g. Ms, Ks, etc.) vs. calendrical timespans (days etc.)
19:39:30 <djahandarie> tgeeky_, I'm sure they have been mentioned on the n-cafe multiple time, but I'm not sure those mentions were in a physics application.
19:39:32 <cmccann> the term "monad" is a fairly simple combination of existing roots so it's fairly likely to have been coined independently
19:40:04 <tgeeky_> "unity, arithmetical unit," 1610s, from L. monas (gen. monadis), from Gk. monas "unit," from monos "alone"
19:40:06 <SirFrancisDrake> isn't it a single root?
19:40:16 <tgeeky_> yeah
19:40:24 <tgeeky_> i hate human language, though
19:40:27 <tgeeky_> so i am probably wrong
19:40:43 <tgeeky_> http://english.stackexchange.com/questions/30654/where-does-the-term-monad-come-from
19:40:50 <cmccann> heh
19:41:20 <tgeeky_> anywyay, Liebnitz can probably be credited for popularizing it, since his work was very widely known
19:41:21 <SirFrancisDrake> why does it look like stack overflow again?
19:41:47 <cmccann> that's another site running on the same engine as stack overflow
19:41:58 <SirFrancisDrake> apparently
19:43:26 <cmccann> anyway, yeah, maybe not multiple word "roots", but it's a simple derived form of the greek word for "one"
19:43:33 <wli> Someone dredge up E. T. Bell's quote regarding monads.
19:43:52 <cmccann> consider for instance, the term "monadic" and "dyadic" for function arity, which I'm glad are not used much in Haskell
19:44:10 <cmccann> but are common in some of the array languages, I think
19:44:17 <tgeeky_> "Doubtless every reader has heard something of the ingenious theory of monads --- miniature replicas of the universe out of which everything in the universe is composed, as a sort of one in all, all in one --- by which Leibniz explained everything (except the monads) in this world and the next."
19:44:28 <tgeeky_> E.T. Bell "Men of Mathematics p.128
19:44:40 <wli> tgeeky_: Thanks.
19:44:58 <tgeeky_> yeah, typical of renassiance people to explain everything but the thing they are explaining :)
19:45:41 <cmccann> it's monads all the way down
19:47:02 <djahandarie> tgeeky_, I suppose what a monad would be in Physics, by thinking of their representation as a Feynman diagram, would be something like a cubic self-interaction
19:47:35 <tgeeky_> djahandarie: oh my, I don't know.
19:48:12 <djahandarie> There is a paper on topological quantum field theory that I really want to read and I haven't yet, I'd probably be able to come up with something nicer if I did
19:48:17 <tgeeky_> I think an analogy with a shot would be the circumstance in string theory of the impossibility of making a theory without closed strings
19:49:16 <tgeeky_> hehe, i am a physicist, but to me, right now, Monads are thing in Haskell and little else ;)
19:49:26 <tgeeky_> but I am not a fancy new-math physicist, yet
19:50:23 <tgeeky_> I did read Baez's "prehistory of n-category theory" in Deep Beauty
19:50:41 <tgeeky_> which I was pleased with, if somewhat bamboozled at the end
19:50:49 <djahandarie> You know about Feynman diagrams right? Start reading about string diagrams in category theory, and try sketching out the laws for monads using them and see what they would correspond to in physics.
19:51:30 <djahandarie> John Baez really is a great source on a lot of this stuff.
19:51:31 <tgeeky_> djahandarie: of course, and I'm a little familiar with string diagrams in CT (almost exclusively through baez's work)
19:51:38 <cmccann> aren't those more about monoids?
19:51:48 <cmccann> given of course that monads are monoids, yes
19:52:07 <tgeeky_> the entire 150 page part in Deep Beauty
19:52:09 <tgeeky_> is about
19:52:36 <tgeeky_> [symmetric?] [braided?] monoidial categories
19:52:46 <tgeeky_> along with some other modifiers
19:52:54 <djahandarie> Which are both actually fairly simple structures
19:52:58 <tgeeky_> yeah
19:53:03 <djahandarie> (Probably 'closed' and 'dagger' ?)
19:53:18 <tgeeky_> dagger comes up just a little bit, closed I don't think very much
19:53:27 <tgeeky_> i mean, 140 of 150 pages were about the above
19:54:54 <djahandarie> I actually just formalized braided monoidal categories in Agda the other day
19:55:09 <djahandarie> I should get around to doing symmetrical ones, since it'll be pretty easy
19:55:12 <tgeeky_> oh? did you solve the universe?
19:55:32 <djahandarie> No? :p
19:55:42 <tgeeky_> damn. I was hoping for some shortcuts.
19:57:05 <djahandarie> I also need to do a proof that the triangle diagram is redundant if you have the pentagon diagrams
19:57:27 <tgeeky_> i was a little surprised at the simplicity of those two
19:57:41 <tgeeky_> i am more interested in the failure of things starting with 3-categories
19:57:46 <tgeeky_> of 6-
19:57:51 <tgeeky_> s/of/or/
19:57:58 <tgeeky_> err, rather, tricategories
19:58:37 <Viper591> So whats up with Haskell
19:59:09 <Viper591> ???
19:59:26 <tgeeky_> we all quit when we realized that ML was better.
19:59:28 <cmccann> up-ness is inductively defined, so don't ask that or you'll force the whole thing and crash
19:59:42 <cmccann> please only take the next finite number of "up" things
19:59:57 <SirFrancisDrake> I went back to CL
20:00:01 <Viper591> Whats ML?
20:00:03 <djahandarie> Don't you mean coinductively?
20:00:04 <Viper591> CL?
20:00:10 <tgeeky_> ML is where we code in HTML
20:00:14 <tgeeky_> but we just forget about the HT part
20:00:21 <Viper591> .....
20:00:22 <Viper591> oh
20:00:28 <cmccann> djahandarie, ergh, yes
20:00:30 <djahandarie> Viper591, ML and CL are two other languages.
20:00:46 <SirFrancisDrake> yeah, and CL is where we code in C with lassos
20:00:46 <djahandarie> (The latter stands for Common Lisp.)
20:00:50 <cmccann> apparently I can't even put in the effort to get my bad jokes right
20:01:42 <SirFrancisDrake> anyway, is there an online version of Deep Beauty talks?
20:02:18 <SirFrancisDrake> or papers, or whatever. This ( http://symposia.templeton.org/deep_beauty/bios.html ) doesn't look very helpful
20:02:38 <tgeeky_> it's a book
20:02:49 <tgeeky_> 23:01 < djahandarie> Viper591, ML and CL are two other lang
20:02:54 <tgeeky_> sp paste
20:02:55 <tgeeky_> http://www.amazon.com/Deep-Beauty-Understanding-Mathematical-Innovation/dp/1107005701
20:04:37 <SirFrancisDrake> :(
20:05:03 <luite> If you're of low moral fiber, there are other sources for that book ;p
20:05:14 <luite> moral fiber should be a mathematical term by the way
20:05:34 <tgeeky_> lol luite
20:05:41 <tgeeky_> I was wondering how you acquired the book so fast :)
20:05:45 <tgeeky_> I didn't say anything :)
20:05:48 <luite> sh
20:06:01 <cmccann> don't worry, misappropriating something from Baez is only evil if you check to see that your copy is the same as the original
20:06:14 <cmccann> just check for equivalence and you'll be okay
20:07:11 <luite> well downloading a pdf is obviously not equivalent to buying the book, but it's isomorphic ;p
20:07:21 <cmccann> no, isomorphism is fine
20:07:28 <cmccann> cf. http://ncatlab.org/nlab/show/evil
20:07:29 <cmccann> :P
20:08:30 <SirFrancisDrake> found it
20:14:55 <SirFrancisDrake> isomorphism I mean
20:35:10 --- mode: ChanServ set +o mauke
20:35:10 --- mode: mauke set +b *!*@gateway/web/freenode/ip.200.77.220.234
20:41:50 <mauke> what the
20:42:36 --- mode: mauke set -b *!*@gateway/web/freenode/ip.200.77.220.234
20:42:38 --- mode: mauke set -o mauke
20:43:08 <djahandarie> mauke, another one of your runaway scripts? :p
20:43:18 <mauke> probably, but ... what
20:43:35 <mauke> I wanted to ban someone in #perl
20:43:37 <djahandarie> Either that or it's the ghost in your shell.
20:44:35 <cmccann> mauke's scripts are taking over
20:48:27 <Jafet> Replacing himself with a perl script?
20:56:16 <mauke> a word of advice: don't hook the 'script destroyed' event in irssi, and if you do, don't attempt to unload that script
21:07:34 <troci> Is there a GHC >= 7.0.2 binary available for PowerPC?
21:07:43 <dankna> troci: I am dubious.
21:08:20 <dankna> troci: your best bet to build one if indeed there is none is to back up to the latest version that does have a binary for your desired architecture, install that, and then build successively more recent versions using each other
21:08:34 <dankna> troci: because cross-compilation currently doesn't work at all :/
21:10:19 <SirFrancisDrake> dankna: will it?
21:10:58 <dankna> will what?  cross-compilation eventually work again?  yes, there are people on that, myself included.
21:11:02 <dankna> not in the same way as it used to though.
21:11:05 <dankna> a better way, hopefully :)
21:11:26 <SirFrancisDrake> dankna: oh. Best of luck :)
21:11:27 <troci> dankna: I'll probably do that; thanks.  Will I be able to build GHC from source with only earlier GHC binaries?
21:11:31 <dankna> thanks :)
21:11:47 <dankna> troci: you'll also need binaries of eg. Perl and gcc, but you shouldn't need to produce those yourself.
21:12:25 <dankna> troci: and by the way, let dons or somebody know when you succeed, they will probably be interested in putting your binary up for others
21:19:54 <MatrixFrog> ack
21:20:07 <MatrixFrog> i was just about to write a function and without even thinking, i typed out the word "function"
21:20:14 * MatrixFrog shakes fist at JavaScript
21:23:49 <monochrom> or pascal :)
21:24:43 <troci> Where's the source for GHC?
21:24:53 <cmccann> sometimes without I thinking I start by typing Œª
21:25:14 * troci decides to use his or her browser
21:29:22 <troci> How is http://www.haskell.org/ghc/dist/stable/dist/ghc-7.0.4-src.tar.bz2 different from http://www.haskell.org/ghc/dist/stable/dist/ghc-7.0.4.20110615-src.tar.bz2?
21:29:44 <troci> I'll use the former for now.
21:30:03 <Axman6> the latter isn‚Äôt an official release
21:30:35 <SirFrancisDrake> cmccann: you've set "abbr Œª lambda"?
21:31:14 <jcp> I'm fairly new to Haskell and to functional programming languages (and I'm not very experienced in math, but I'm getting there slowly). There's one thing I can't figure out: some things online demonstrate how universal quantification can be used to acheive existential quantification in Haskell, and they show that in the context of a mythical "exists" keyword representing existential quantification.
21:31:24 <wli> Holy cow the Remez exchange algorithm for splines even determines the knots!
21:31:38 <jcp> Such as [exists a. Num a => a] referring to a list where any value in the list can be of any type so long as that type is an instance of Num.
21:31:54 <jcp> My question, then, is why does Haskell not actually include an exists keyword that provides existential quantification?
21:32:06 <cmccann> SirFrancisDrake, actually I have \ set as an abbreviation for Œª, so even easier :P
21:32:24 <SirFrancisDrake> cmccann: I meant, the other way around
21:33:26 <troci> ./configure is hanging on "checking veriosn of ghc..." :/
21:33:42 <mauke> jcp: well, haskell doesn't even have 'forall'
21:34:00 <cmccann> jcp, my impression is that they didn't want to introduce a new keyword and that everything it'd be used for can be expressed with universal quantification
21:34:06 <troci> Ah.
21:34:12 <kmc> Haskell 98 has limited polymorphism in both existential and universal forms
21:34:19 <cmccann> SirFrancisDrake, er, not sure which way you mean, I guess
21:34:26 <kmc> GHC adds the 'forall' keyword as a language extension and uses it for both
21:34:31 <kmc> UHC has an 'exists' keyword
21:35:20 <cmccann> kmc, I suspect jcp was asking about the GHC extension, since saying "Haskell" when you mean "GHC with random extensions enabled" is awfully common :P
21:35:33 <SirFrancisDrake> cmccann: you type Œª into a vim, it replaces it with ``lambda''.
21:35:40 <kmc> but it's still wrong
21:35:48 <kmc> at any rate i addressed both possible questions
21:35:49 <cmccann> kmc, didn't say it wasn't
21:35:50 <mauke> ghc -XEnableFuckingEVERYTHING
21:35:56 <kmc> that's called -fglasgow-exts
21:35:56 <cmccann> ghc -XAndTheKitchenSink
21:36:08 <mauke> kmc: I don't think that enables everything
21:36:11 <troci> Doesn't enable everything
21:36:25 <kmc> H98 lacks 'exists' because its type system is supposed to be simple (!).  GHC lacks 'exists' for essentially arbitrary reasons; other compilers have it.
21:36:27 <cmccann> SirFrancisDrake, oh, well I don't use vim so I dunno :P
21:36:39 <kmc> yeah, glasgow-exts is deprecated anyway
21:36:52 <SirFrancisDrake> cmccann: you should definitely check it out :p
21:37:15 <cmccann> SirFrancisDrake, one of these days I guess, always been too lazy to learn a "real" editor, meh
21:37:26 <troci> SirFrancisDrake: Your vim setup is behaving silly.
21:37:26 <kmc> alias ghc='ghc $(for x in $(ghc --supported-languages | grep -v ^No[A-Z]); do echo -X$x; done)'
21:38:04 <cmccann> SirFrancisDrake, anyway I just use SciTE and have an abbreviation file full of silly unicode garbage
21:38:25 <troci> let ghc = ghc $ shelldo (x >>= run "ghc" ["--supported-languages"])
21:38:28 <cmccann> so expanding an "abbreviation" turns \ into Œª
21:38:34 <cmccann> which is obviously very useful
21:38:50 <mauke> I hate Œª and want it banned
21:39:03 <kmc> er
21:39:14 <kmc> alias ghc='ghc $(ghc --supported-languages | grep -v No[A-Z] | sed s/^/-X/)'
21:39:24 <SirFrancisDrake> back to s-, back to s-
21:39:25 <kmc> shell is almost as golf-able as Haskell
21:39:36 <mauke> I can see the point of using ‚Üí for -> or ‚ß∫ for ++, but Œª is just stupid
21:40:29 <cmccann> mauke, yes, the absurdity is the point of the whole thing
21:41:07 <kmc> Œª is a lower-case letter
21:41:11 <cmccann> especially since, last I checked, I don't think GHC actually supports using lambda syntactically
21:41:15 <aspect> how is ‚Üí or ‚ß∫ less stupid than Œª?
21:41:16 <kmc> one-letter keywords are *bad*
21:41:33 <kmc> ‚Üí and ‚ß∫ are non-alphabetic symbols
21:41:35 <aspect> I see
21:41:46 <aspect> guess it would suck if you were coding in Greek
21:41:54 <pikhq_> kmc: To 99% of the world, Œª parses as non-alphabetic...
21:41:57 <jcp> cmccann: Yeah, that's what I was asking about. As I said, fairly new to Haskell :-)
21:41:59 <cmccann> yes, there are valid reasons for not making lambda a syntactic symbol or keyword
21:42:15 <cmccann> especially given how common greek letters are in mathematical expressions
21:42:23 <cmccann> often with meanings assigned by convention
21:42:30 <jcp> cmccann: And to answer your question. I know that it can, but it seems like that's similar to a language including AND but not OR because you can do everything with AND that you can do with OR as long as you sprinkle a few NOTs here and there.
21:42:37 <troci> Approximately how long should I expect GHC to build?
21:42:37 <aspect> and the meaning of Œª is just a little bit overloaded
21:42:48 <mauke> troci: 3 hours
21:42:56 <jcp> My understanding is that the relationship between universal quantification and existential quantification is similar to the relationship between AND and OR.
21:42:57 <cmccann> troci, you can expect it to finish in a finite time
21:42:59 <jcp> (the boolean operators)
21:43:16 <cmccann> jcp, yes, like kmc said it's essentially arbitrary
21:43:26 <jcp> Oh, I missed that
21:43:29 * jcp re-reads scrollback
21:43:29 <cmccann> I think the main justification was "not adding new keywords"
21:43:50 <kmc> pikhq_, English speakers should be careful making arguments by language popularity
21:43:59 <kmc> and by "English" i mean "non-Mandarin"
21:44:21 <kmc> jcp, yes, there is a close analogue of De Morgan's laws
21:44:27 <pikhq_> kmc: ÊàëÁü•„ÄÇ
21:44:31 <cmccann> jcp, though, as far as the relation between them goes, keep in mind that there's no keyword for "not" on types, either
21:44:47 <kmc> ‚àÄt. P t  ‚Üî  ¬¨‚àÉt. ¬¨ P t
21:44:54 <jcp> kmc: Exactly
21:44:56 <kmc> ‚àÉt. P t  ‚Üî  ¬¨‚àÄt. ¬¨ P t
21:45:03 <kmc> cmccann, you don't need one
21:45:07 <kmc> as long as you have empty types
21:45:12 <kmc> jcp, they're also related by a continuation-passing-style transform
21:45:43 <cmccann> kmc, yes, and the same argument for "why encode it that way instead of having a keyword" applies there, too :]
21:45:46 * cmccann shrugs
21:45:57 <kmc> type Exists p = ‚àÄr. (‚àÄt. p t ‚Üí r) ‚Üí r
21:46:16 <jcp> kmc: I don't know enough math to understand your last statement about transforms or whatever...
21:46:22 <kmc> the "type Exists" line?
21:46:55 <jcp> No, that they're related by a continuation-passing-style transform
21:46:59 <cmccann> speaking of which, I was pleased to realize that letting an existential "escape" from said CPS-style amounts to double-negation elimination on an existential
21:47:05 <kmc> CPS transform is mostly a programming term, not a math term
21:47:08 <cmccann> for some reason that really made some stuff seem to "click"
21:47:21 <kmc> though there is some work in translating classical proofs to constructive logic which makes use of a similar technique
21:47:24 <MatrixFrog> question for you all: import Data.ByteString as B ... import Data.ByteString.Char8 (pack) ... a = pack "xxx"
21:47:37 <kmc> ByteString.Char8 is sooooo wrong
21:47:37 <mauke> MatrixFrog: import qualified
21:47:44 <MatrixFrog> oh yeah
21:48:05 <MatrixFrog> i was thinking the "as B" implied that you would always use it like "B.pack"
21:48:15 <kmc> jcp, converting your code to CPS involves adding an extra "continuation" argument to each function, and then instead of returning a value, you call the continuation with that return value
21:48:18 <kmc> the continuation is a function
21:48:20 <troci> kmc: Yes.  Data.ByteString.Char8 is what is right
21:48:36 <kmc> so a function of type ¬´a ‚Üí b¬ª becomes ¬´a ‚Üí (b ‚Üí r) ‚Üí r¬ª
21:48:44 <mauke> it's callbacks all the way down
21:48:47 <kmc> yep
21:49:07 <kmc> and an existential becomes a value which requires a universally-quantified continuation
21:50:01 <kmc> "I have a value of type (P T) for some T.  I won't tell you what T is.  But if you give me a polymorphic function (‚àÄt. P t ‚Üí R), I'll apply it to my hidden (P T) and give you the result R."
21:50:42 <kmc> two-player games are a nice way to think about nested quantifiers
21:50:54 <jcp> kmc: Oh ok, that makes sense
21:51:09 <cmccann> also, note that this is roughly the same as the church encoding on an existential in a data type, e.g., like the maybe function on Maybe values
21:51:34 <cmccann> so the CPS-ish type and the data declarations are mostly the same thing
21:54:04 <kmc> jcp, do you know about the Curry-Howard Isomorphism?
21:54:12 <kmc> "have you heard the good news?"
21:57:13 <jcp> kmc: I think I've heard of it somewhere
21:57:16 <cmccann> speaking of that, there were some interesting, less common connections mentioned here: http://stackoverflow.com/questions/2969140
21:57:49 <cmccann> (the accepted answer, by RD1, other answers are less interesting, standard material)
21:58:42 <kmc> jcp, types are propositions; terms are proofs
21:58:57 <kmc> a term of type A ‚Üí B proves "A implies B"
21:59:07 <kmc> because it takes a proof of A and provides a proof of B
21:59:19 <kmc> a term of type (A, B) is a proof of "A and B", because it has a proof of A and a proof of B
21:59:32 <kmc> what Haskell type would correspond to a proof of "A or B"?
22:00:03 <maurer_> kmc: data FakeSum = FakeSumA A | FakeSumB B
22:00:35 <maurer_> (A, B) is product (e.g. AND) , and the type above is sum, e.g. OR
22:00:52 <kmc> maurer_, i wanted jcp to answer; )
22:00:53 <cmccann> keeping in mind that anything in Haskell is handwave-y because of pesky _|_ issues
22:00:56 <mauke> s/e\.g\./i.e./g
22:01:12 <kmc> yeah.  "undefined" proves everything
22:01:27 <maurer_> kmc: Oh, I just saw the question
22:01:29 <mauke> I will inhabit your types
22:01:35 <maurer_> kmc: Didn't realize it was pointed at anybody :P
22:01:48 <kmc> "Theorem: ‚àÄa. a.  Proof: Fuck you, that's why.  ‚ñ°"
22:01:55 <maurer_> I,I theoremin
22:01:59 * cmccann prefers not to talk about bottoms in polite company
22:02:10 <cmccann> kmc, haha
22:02:18 <kmc> :t error "fuck you, that's why"
22:02:19 <lambdabot> forall a. a
22:02:33 <mauke> template<typename T> T f() { throw "no :-)"; }
22:02:40 * dented42 giggles
22:02:41 <kmc> jcp, do you know how first-class continuations work?  call/cc?
22:02:46 <cmccann> kmc, indeed. Quod erat demonstrandum (that's latin for "so there")
22:02:55 <jcp> kmc: I have an idea of what they are, but that's it.
22:03:01 <kmc> okay
22:03:06 <jcp> And, I'm not sure as to that type
22:03:08 <mauke> jcp: do you know unix?
22:03:08 <kmc> right, so "A or B" is Either A B
22:03:14 <kmc> cause it's a proof of A or a proof of B
22:03:17 <jcp> Ah, ok
22:03:27 <kmc> "not A" is A ‚Üí Void
22:03:31 <kmc> where Void is some type with no values
22:03:45 <kmc> in GHC:  {-# LANGUAGE EmptyDataDecls #-} data Void
22:03:47 <mauke> newtype Void = H98 Void
22:03:55 <kmc> that works too
22:04:34 <mauke> template<typename T> T f() { return f<T>(); } // all the way down
22:04:43 <Axman6> is A and B (A,B)?
22:04:47 <kmc> yes
22:04:53 <kmc> jcp, call/cc in Haskell (without the baggage of the actual Cont monad) would have type ((p ‚Üí q) ‚Üí p) ‚Üí p
22:04:55 <mauke> <kmc> a term of type (A, B) is a proof of "A and B", because it has a proof of A and a proof of B
22:05:04 <MatrixFrog> http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString-Char8.html#v:index is there not a "Maybe" version of this?
22:05:08 <Axman6> not sure why it took me so long to figure that out. guess i never thought of it =)
22:05:21 <MatrixFrog> (ByteString -> Int -> Maybe Char)
22:05:30 <kmc> that's known in logic as Peirce's Law
22:05:33 <mauke> MatrixFrog: should be easy to write, just check the length first
22:05:49 <MatrixFrog> yeah, i'm just surprised it doesn't exist i guess. *shrug*
22:05:52 <MatrixFrog> but yay, more coding!
22:06:04 <Axman6> @hoogle ByteString -> Int -> Maybe Char
22:06:04 <lambdabot> Data.ByteString.Char8 index :: ByteString -> Int -> Char
22:06:04 <lambdabot> Data.Data gmapQi :: Data a => Int -> (d -> u) -> a -> u
22:06:05 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
22:06:11 <Axman6> @hoogle ByteString -> Int -> Maybe Word8
22:06:12 <lambdabot> Data.ByteString index :: ByteString -> Int -> Word8
22:06:12 <lambdabot> Data.ByteString.Unsafe unsafeIndex :: ByteString -> Int -> Word8
22:06:12 <lambdabot> Data.Data gmapQi :: Data a => Int -> (d -> u) -> a -> u
22:06:17 <mauke> MatrixFrog: normally you don't randomly index into strings without knowing how big they are
22:06:32 <kmc> jcp, the types systems which come out of languages like Haskell are "constructive" logics.  you can't prove things like the Law of Excluded Middle
22:06:41 <kmc> which would be ‚àÄa. Either (a ‚Üí Void) a
22:06:46 <MatrixFrog> true, but in this case i have a string and i want the nth character if it exists. if it doesn't exist, i get a bigger string :)
22:06:52 <MatrixFrog> ( http://projecteuler.net/index.php?section=problems&id=230 )
22:07:06 <kmc> jcp, but it's known that taking Peirce's Law as an axiom gives you a classical logic, i.e. one which has excluded middle
22:07:15 <kmc> so there should be a way to write a term of that type using call/cc
22:07:22 <kmc> shall i demonstrate? :)
22:07:25 <MatrixFrog> but yeah i'll write it
22:08:24 <cmccann> if you've ever heard jokes about mathematicians where the punchline involves "...therefore a solution exists!" and the mathematician then doing nothing useful, that's exactly what constructive logic forbids. no joking allowed.
22:11:24 <jcp> kmc: Perhaps. I think I may need a bit to process all of this and sort it out in my head first
22:11:43 <jcp> This is all a little bit above my daily math quota :-)
22:11:52 <Pseudonym> Which bit would you like? Zero or one?
22:12:01 <dented42> ^_^
22:12:03 <shachaf> jcp: You ought to let kmc demonstrate. :-)
22:12:23 <jcp> Oh, ok then. kmc: proceed
22:12:33 <kmc> no, it can wait :)
22:12:38 <kmc> i'm here all the time
22:13:46 <maurer_> The call/cc |- law of excluded middle proof is a bit difficult to figure out the first time
22:13:46 <shachaf> kmc: case (lem :: Either (Not P) P) of Left _ -> putStrLn "P is false!"; Right _ -> putStrLn "P is true!"
22:14:25 <shachaf> maurer_: It's neat, though.
22:14:43 <kmc> it involves time travel
22:14:44 <kmc> and lies
22:14:51 <kmc> that is more than you can say for most proofs
22:15:14 <kmc> it's a pretty good argument against classical logic, really
22:16:10 <c_wraith> I ran into a time-travel bug today.
22:16:25 <c_wraith> It was confusing
22:18:41 <kmc> it will be confusing?
22:18:58 <c_wraith> It's all in the past now
22:21:35 <confab> MatrixFrog: if i understand problem 230 correctly, theres no real need to program anything
22:21:54 <confab> afterall, there's only 10 choices right?
22:22:09 <MatrixFrog> D(n) is just one digit yeah
22:22:29 <MatrixFrog> but then you have to do D((127+19n) * 7^n)
22:22:42 <MatrixFrog> and multiply by 10^n
22:22:44 <MatrixFrog> and sum
22:22:47 <confab> oh
22:23:09 <MatrixFrog> occasionally PE lets you get off easy like that, but not this time, i'm pretty sure :P
22:24:32 <augur> what are applicative functors in a CT setting?
22:27:16 <cmccann> augur, "This module describes a structure intermediate between a functor and a monad: it provides pure expressions and sequencing, but no binding. (Technically, a strong lax monoidal functor.)"
22:27:31 <cmccann> a catchy name, no?
22:27:38 <augur> a strong lax monoidal functor
22:27:40 <augur> i see!
22:27:46 <augur> i shall read up on such things
22:28:49 <cmccann> I think gist of it is that it's a functor that lets you take the monoid structure of product types (i.e., tuples) and shove them through the functor
22:30:12 <cmccann> augur, e.g., consider a type class with "funit :: f ()" and "fproduct :: f a -> f b -> f (a, b)"
22:30:20 <augur> hm
22:30:34 <cmccann> I think that's closer to the essential idea of the structure in CT
22:30:46 <cmccann> (the above is equivalent to Applicative, if it wasn't obvious)
22:31:37 <augur> so why is it that monads are preferred for conception as mode-of-computation?
22:31:53 <augur> i feel like applicatives are better suited to it, since the functions themselves can also be functorized
22:32:01 <cmccann> augur, because monads allow the structure of the computation to depend on intermediate values
22:32:03 <augur> and since functions are values, why shouldnt they be
22:32:09 <augur> cmccann: hmm
22:32:49 <augur> cmccann: in what sense?
22:32:52 <cmccann> also, not sure what you mean by "since the functions themselves can also be functorized"
22:33:05 <augur> well, i mean, its possible with a monad ofcourse, but
22:33:15 <cmccann> augur, compare these:
22:33:18 <cmccann> :t (=<<)
22:33:19 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
22:33:20 <augur> the functions can be wrapped inside an instance of the functor is all
22:33:21 <cmccann> :t (<*>)
22:33:22 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
22:33:48 <cmccann> the monad version lets you build the functor based on a value, which is taken from "inside" it
22:34:01 <cmccann> the applicative version relies on both being already in the functor, and only combines them
22:34:01 <augur> oh i see
22:34:11 <augur> yes ok that makes sense
22:34:25 <cmccann> think of how zip lines lists up, while concatMap can filter and expand them
22:34:38 <augur> right right
22:34:44 <augur> yeah that makes sense
22:35:14 <augur> you couldnt, for instance, have a function that returns multiple results using an applicative, whereas with a monad you can
22:35:15 <augur> right
22:35:15 <augur> ok
22:35:16 <wli> Hmm, is there multiple (e.g. quadruple) precision floating point stuff floating around? (Oh crap, linear programming support for such is likely absent...)
22:36:40 <cmccann> augur, note that for the standard applicative instance on [], it still generates all possibilities, it just can't eliminate any
22:36:59 <cmccann> the size/shape of the resulting structure is fixed given the size/shape of the inputs
22:37:07 <augur> cmccann: right, but i mean, you cant have a multiple-return-value function
22:38:01 <cmccann> augur, right, that's implicit in how the instance for lists work, and the applicative instance requires functions to be oblivious of the structure
22:38:18 <augur> ok
22:38:38 <cmccann> I like to think of monads as providing a notion of causality in some sense, because there's an intrinsic direction as each (>>=) builds a new layer of structure in some sense
22:38:50 <cmccann> or in a literal sense, if you fmap to build a new layer, then collapse with join
22:39:36 <cmccann> also note that while direction matters, the order you collapse layers in doesn't matter
22:39:49 <cmccann> e.g., join . join should be equivalent to join . fmap join
22:40:05 <cmccann> things would get confusing without that, I suspect
22:50:15 <sshc> sb goto 18:52:13
22:55:03 <sshc> Does wxHaskell support XRC (interfaces created with "wxGlade"; similar to the xml files that glade produces)?
22:56:21 <sshc> Mm, apparently there's wxFormBuilder too
23:01:08 <Axman6> @hoogle Control.Seq
23:01:08 <lambdabot> Control.Parallel.Strategies seqArr :: Ix b => Strategy a -> Strategy (Array b a)
23:01:08 <lambdabot> Control.Parallel.Strategies seqList :: Strategy a -> Strategy [a]
23:01:08 <lambdabot> Control.Parallel.Strategies seqListN :: Integral a => a -> Strategy b -> Strategy [b]
23:01:14 <Axman6> :\
23:02:01 <wli> HERA needs patching to build with modern gmp
23:02:13 <Axman6> HERA?
23:02:50 <wli> Some lib exporting mpfr functionality.
23:09:13 <holmak> Does anyone know which repo System.Directory lives in?
23:11:25 <applicative> holmak, you mean the one GHC uses? Isn't it just part of the ghc repository?
23:15:04 <applicative> holmak: I have it as ghc/libraries/directory/System/Directory.hs
23:16:33 <applicative> i see here is a darcs repository http://darcs.haskell.org/packages/directory/
23:17:37 <holmak> applicative: Thanks.
