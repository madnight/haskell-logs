00:04:17 <blackdog> hey, anyone know how you'd find the overhead of a lightweight haskell thread?
00:05:36 <adu> blackdog: it's very small
00:05:41 <kmc> what does that mean
00:05:46 <kmc> what do you want to measure?
00:06:10 <adu> blackdog: http://shootout.alioth.debian.org/u64q/performance.php?test=threadring
00:06:18 <hpaste> harlekin pasted “happstack's mkMethods” at http://hpaste.org/48945
00:06:51 <blackdog> adu: curious as to the overhead compared to erlang
00:07:00 <fasta> blackdog: what do you mean by 'overhead'? To what are you comparing?
00:07:03 <aab> what is this?
00:07:08 <aab> is this javasript?
00:07:08 <blackdog> adu: i've been playing with the threadring benchmarks
00:07:11 <harlekin> Hi. I'm trying to handle state in my happstack application. Using mkMethods I get an error I don't understand. Could anyone tell me what's wrong there? http://hpaste.org/48945
00:07:26 <c_wraith> blackdog: lower memory overhead than an erlang thread.
00:07:40 <fasta> blackdog: e.g. openmp is likely more efficient, but they do different things.
00:08:00 <blackdog> c_wraith: yes, i understand that, i'm wondering how you'd measure it
00:08:13 <blackdog> or if there's a paper or a post - my google-fu is failing me.
00:08:34 <c_wraith> I believe simon m gave the memory overhead per-thread as 9 machine words.
00:09:12 <kmc> you can just make a program that launches n sleeping threads
00:09:17 <kmc> and monitor its memory consumption as you vary n
00:09:20 <ddarius> Not counting the stack.
00:09:43 <blackdog> ddarius: i was playing with the -s -k RTS flags
00:10:00 <blackdog> oddly, at 0.4k my test program worked, and at 0.3k it just spun
00:10:11 <blackdog> would have expected an overflow, not running forever.
00:11:07 <harlekin> Ah, nvm. It should have been Query instead of Reader. My bad.
00:25:28 <ddarius> blackdog: I believe stack overflow in a thread will only kill that thread.
00:51:10 <laar> does anyone know why a trailing comma (after the last entry) is allowed in the export list but not in record syntax? As it seems to me as inconsistent and (to me) irritating.
00:51:50 <shachaf> laar: Probably just an inconsistency.
00:52:39 <laar> maybe it might be logical when writing records on a single line
00:52:41 <azaq23> > [4, 5, ]
00:52:42 <lambdabot>   <no location info>: parse error on input `]'
00:54:45 <liyang> I try to pretend that export lists don't allow trailing commas.
00:55:52 <benmachine> the inconsistency of trailing commas is annoying
00:56:11 <benmachine> I wonder if commas are necessary at all
00:56:21 <benmachine> it's not like export tokens can be more than one word
00:56:40 <laar> liyang, why do you do that?
00:56:42 <benmachine> oh apart from module Foo, but that's a keyword anyway, right?
00:58:11 <laar> benmachine, I think you're right, but it does look a lot better to me with commas
00:58:13 <ddarius> benmachine: And Foo(..) and Foo(Bar, Baz)
00:58:47 <benmachine> ddarius: if you removed all commas from the export list, but kept parentheses, it would still be unambiguous, wouldn't it?
01:00:00 <ddarius> I believe so.
01:00:35 <benmachine> it would be a bit un-pretty, especially with the module syntax, but simplicity is a virtue
01:00:40 <benmachine> same thing for import lists, actually
01:01:14 <ddarius> The simple choice is to be consistent with the rest of the language.
01:01:35 <ddarius> Also it doesn't hurt to have a syntax that's more open to additions.
01:02:06 <ddarius> Already, Foo, (:+) would become Foo(:+) which is close to Foo((:+))
01:03:21 <benmachine> true
01:04:42 <laar> Maybe it should be Foo (:+), with an extra space in between
01:26:20 <liyang> laar: because it's perfectly possible for import/export lists to appear regular without trailing commas.
01:27:21 <laar> That's true, but I like them so it's faster/easier to make additions
01:27:40 <liyang> Put the comma at the beginning.
01:28:10 <liyang> Same for lists and records.
01:28:23 <laar> that would be something
01:31:54 <laar> But then I would be missing a comma in front of the first record/export
01:32:07 <laar> Or do you put the brace in place of it?
01:48:57 <oknoorap> hey there
01:49:35 <Phyx-> hi
01:50:57 * hackagebot memoize 0.1 - A memoization library  http://hackage.haskell.org/package/memoize-0.1 (JesseTov)
02:15:14 <hvr> yet another one :)
04:36:12 --- topic: '["Paste code/errors: http://hpaste.org/new/haskell ", "Haskell Platform 2011.2: http://is.gd/dCGPn", "GHC 7: http://is.gd/hb8vE", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/", "admin and spam issues: #haskell-ops"]'
04:36:12 --- topic: set by mauke!~mauke@p3m/member/mauke on [Sat Jun 11 05:12:19 2011]
04:36:12 --- names: list (clog deech dogmaT_ bwwww stianhj tncardoso guampa X-Scale StepanKuzmin ab3 jimmy1980 stobix slom geheimdienst Apocalisp HugoDaniel frederick mun_ jedai jem777 nkpart synonymous Eduard_Munteanu mpiechotka ]OLI[ colbseton waterlaz|work boegel ceii jrib BlankVerse BCoppens path[l] saurik Argue fusion5__ jaspervdj ivanm hargettp owst lopex Evious hammi SirFrancisDrake tomh- bradwright FalkoPeters liesen_ gdoteof laar electrogeek sordina2 jmcarthur Draconx vili)
04:36:12 --- names: list (tensorpudding kniu _1amzave_ Draconx|Laptop kmc mjo Cale dfeuer cwillu_at_work joeytwiddle cheater__ Jeanne-Kamikaze ngochai linduxed Raku^ neurogeek||m liltoe noj bezik andrewsw erg PHO_ davidL inimino kloeri ozzloy zenzike szbalint impl hellige EpsilonDur periodic ian_mi johs legov osoleve kosmikus Zol freiksenet integral jml Twey mokus guerrilla shepheb seats karld klugez ibt zygoloid pr dixie mux silex mrshoe bd_ absentia Saizan vinc rwbarton dorkitude)
04:36:12 --- names: list (koala_man zakwilson Aisling scsibug_ KitB _erik_ @ChanServ c1de0x Aestas Mitar hhulkko fabjan _main_ Innominate sipa Eelis emias tomaw ptrf mortberg henr_k solarus dqd bs338 ehamberg petanqk jlaire gds srcerer tromp hpaste gf3 lokydor ernst zaphar_ps jlouis avocado suiside aiko confound gbacon_ lukish_ deavid DustyDingo companion_cube mietek smop milkpost koninkje_away daed dcolish carrbs1 lispy naneau politik robbert spetrea dcoutts felipe_ kbar Derander liw)
04:36:12 --- names: list (tommd caligula marienz xale jyyou kalven nimred etabot flazz ccasin EvanCarroll twn arw__ Clint skaar_ sohum dom96 chitragupt lusory mlh smly- freeformz LeNsTR|off robinsmidsrod Utkarsh sunnavy cncl rattboi BrianHV AnAdorableNick Gilly jd10 theclaw aspect audunska mercury^ Intensity sbok drhodes ezyang Laney zmoazeni andersk Bleadof rntz Lemmih majoh inr tridactyla benmachine finnomenon maloi hiredman snarkyboojum scree dilinger milli aavogt shutdown_-h_now)
04:36:12 --- names: list (hpc earthy bremner` Runar HalfWayMan vold_ edwinb lambdabot rfgpfeiffer brett ttblrs hvr comex hanDerPeder thoughtpolice kalivha idnar solidsnack ahf cynick `0660 aculich magicman gdsx marchdown waqf R28 Hunner joni6128 mornfall lunaris aleator Arnar McManiaC StoneToad ixchel Ornedan yottis sgronblo plimsoll flux Boxo geekosaur djahandarie jabirali Igloo alpounet cheshire-cat_ ciaranm welterde d7 dino- lpsmith armence untwisted bbee2 sully Counter-Strike hzh)
04:36:12 --- names: list (wolverian manawy matthew-_ Liskni_si lomeo Belgarion_ jonafan saati brisbin dumael drosophyllum fds kelvie_ rndm minecraftfan snorble ocharles akosch zomg dionoea edwtjo Bassetts cyanoacry rby tamiko uu1101 lebastr ixzkn jrockway quicksilver And[y] Fuco zaero froztbyte arcatan parcs alexsdutton __class__ boris`` flippo shachaf jayne raxas noddy SonicvanaJr nazgjunk Ke finnrobi Vq cizra2 olsner EEVIAC levitation[A] Guest82662 Enigmagic verement xplat adnam trez)
04:36:12 --- names: list (dankna burp` JHoglund_ burp_ deggis_ houeland_ jcapper_ djanatyn_ ben nyingen edenc saiam ttvd Choko hyko ToRA aristid blackrain ts00000 Totramon^ absence sajkr_ Eliel_ savy_ nominolo_ cebewee_ snr_ arkx maurer_ davean thorkilnaur_ pantski chaoflow sirpengi akahn whoops pastorn cjay byorgey xenocryst _mpu ibid CosmicRay copton peddie tew88 MK_FG incandenza pettter OnionKnight stroan frerich palmje Veinor brixen ChongLi thetallguy1 samek helgikrs1 Iceland_jack)
04:36:12 --- names: list (thetallguy twofish hydo fcr ski gereedy taruti ricky Nightwolf wagle qz dju reacocard Will| subpy ClaudiusMaximus zztr angstrom mm_freak SimonRC mattp_ eZet comak Nanar robinbb peterhil Draggor tswett ion Boney frode micahjohnston Botje alek_br sunfun Baughn Khisanth Astro dcoutts_ Obfuscate nlogax obcode alip em felher ousado wyfrn _habnabit appamatto ido neurogeek Wooga sm__ thedward Zephyrus cpa mafs serialhex jssanders tomku TylerE mrd iFire Vorpal erk)
04:36:12 --- names: list (Starfire xiphiasx jix The_third_man astr_ willb geekounet psychicist_ blomqvist gerard0 Somix A1kmm kakazza idoru Martty ps-auxw ormaaj fasta setmeaway etpace eyck novas0x2a gwern janne opqdonut nihtml stepnem dsouza geoffhotchkiss kytibe pyrtsa preflex Nshag nnunley dreixel perlite yahooooo gentz mee Muad_Dibber proq jcp|other ddarius Nereid jorgeb alfa_y_omega araujo naota drmegahertz Younder xarch_ bqf rps_ jrick thanosQR monokrome tgeeky bogner Dashkal)
04:36:12 --- names: list (sonnym cap10morgan Cthulhon Nisstyre sidek dAnjou ve jrk_ msieradzki Philippa tsuraan jlewis matthiasgorgens1 Polarina augur tauntaun eno pen16 accel waterlaz mrdomino scsibug drdo obiwahn rothwell roconnor QtPlatypus Snufsen helino Motoma DrSyzygy mauke Favonia adrake julmuri flamingspinach digicyc Harbinger dual wisemanby pesco ahihi2 fxr noam Amadiro tafryn Casperin ville almostsix profmakx Cerise kluge joe6 Maxdamantus cubi jbauman Codex_ mwc theorbtwo)
04:36:12 --- names: list ([[zz]] tomh kish_ gienah Phyx- Nanakhiel fryguybob Peaker edwardk DigitalKiwi liyang kakos dncr Axman6 MaskRay Chidy pikhq mxweas kaito_ iratsu alek_br_ xinming neurocyt` RSchulzM Dunearhp Niedar osfameron Vulpyne nus towynlin takamoron Darkflux juhp siracusa azaq23 fumbles Cadynum c_wraith PreciousMetals hamishmack eyu100 monochrom isenmann yitz moshee shintah RayNbow`TU dleslie wtw vmil86 Elbar lsthemes pjdelport pi8027 k0ral bl4ck neilk_ nowhereman)
04:36:12 --- names: list (hackagebot kaf3ii negaduck blackdog orbitz kstt Palmik ramkrsna Beetny raichoo gusto erikde jeltsch mrtimuk insomnia1alt gehmehgeh edon simonmellor zomgbie descender Veid merijn rostayob ray_ dclinton kuribas stuartmackie plat0 DevHC_ yell0 balor Nimatek adimit hrehf lpeterse Nies JaffaCake xcombelle sheeple rgrinberg__ MacCoast- poindont` Octal_ CindyLin1 ziman_ Sunhay_ rakete_ sshc_ amiri_ trygvis_ wto_ dmwit_ luite_ fihi09`` int-e_ [mth]_ __mattam__)
04:36:12 --- names: list (mike1703 dropdriv1 kaol_ Gracenot1s pingveno_ Masse^^ Yahovah_ tessier_ ec|fkn_a1ay_nick bo0ts__ Jetbeard kolmodin Raynes_ pumpkin devn ivan norm2782 gniourf_gniourf)
04:36:14 <merijn> deech: Older versions do, newer versions I'm not sure
04:36:37 <kstt> Twey: it seems that this new ghc extension allows to specify the signature of the default implementation of a class method, and have this signature disregarded if instance provides an other implementation
04:37:00 <kstt> class method == class function
04:37:48 <deech> merijn: Cool. Thanks.
04:38:41 <benmachine> Twey: http://www.haskell.org/haskellwiki/Generics#More_general_default_methods looks weird
04:38:42 <merijn> deech: There doesn't seem to be a precompiled install binary but the GHC site mentions PowerPC: http://www.haskell.org/ghc/distribution_packages#macosx
04:38:48 <poucet> hello peeps
04:38:52 <Twey> benmachine, kstt: Yeah, I found that
04:39:04 <kstt> though that really looks like stretching oddly the type system
04:39:13 <Twey> Yeah.
04:39:18 <Twey> I'm not sure how that would work
04:40:04 <Twey> Because it would mean the method has a completely different type depending on the class used
04:40:09 <Twey> Er
04:40:12 <Twey> The instance, even
04:40:21 <Twey> And it doesn't specify a way to provide the normal type
04:40:22 <benmachine> no I think it just affects the context of the instance declaration
04:42:33 <kstt> that's also what I understand, but what I find surprising is that a class can only define one single default implementation, with a default signature. It would seem more natural to be able to provide as many context-based default implementation as needed, and have the instance pick the right one automatically. Or am I missing something ... ?
04:52:21 <Cale> kstt: perhaps. Are you sure that it still doesn't?
04:52:50 <Cale> (I don't know anything about the new DefaultSignatures extension)
04:55:23 <hpc> kstt: i imagine you would have to turn on overlapping instances
05:28:07 <erus`> C++ needs a maybe type
05:29:25 <ion> It has null pointers! ;-)
05:29:42 <arcatan> hey, i was just saying that the other day
05:29:49 <arcatan> then i reinvented null pointers
05:29:58 <merijn> null pointers are type "Maybe SegmentationViolation" :>
05:30:40 <ion> IO (Either SegmentationViolation a)
05:34:00 <Twey> Isn't that something of a misnomer?  We all use flat memory these days, don't we?
05:35:20 <DevHC^> C++ needs a spanking
05:35:31 <Twey> Or a good hard decrement
05:35:43 <hape01> is template haskell the same as macros or inlines in other languages?
05:36:41 <DevHC^> Twey: what's "flat memory"?
05:37:02 <DevHC^> i've heard of pancakes, but memory?
05:37:09 <gienah> hape01: template haskell is sort of like lisp macros, template haskell is challenging to understand
05:37:45 <hape01> gienah: do lisp macros "explode" their inlines before compilation?
05:38:00 <Twey> DevHC^: http://en.wikipedia.org/wiki/Flat_memory_model
05:39:08 <gienah> hape01: I don't really get lisp macros, lisp macros are a very powerful feature of lisp, since the syntax is lisp is uniform a powerful idiom in lisp is to dynamically generate code and then execute it
05:39:48 <hape01> gienah: thanks
05:39:50 <gienah> while as template haskell is used to often used to generate boilerplate code in haskell
05:40:01 <hape01> that makes a difference
05:40:07 <hape01> i want generate boilerplate
05:40:15 <hape01> that means i take template haskell :-)
05:40:41 <denebola> what difference is there between haskell-platform 2010.2.0.0 and 2011.2.0.1, is there anything a newbie would benefit from
05:43:59 <gienah> hape01: bulat's tutorials have been unearthed and links placed on http://www.haskell.org/haskellwiki/Template_Haskell
05:46:28 <hape01> thank yo
05:46:30 <hape01> you
05:51:28 <kstt> hape01: I don't know your experience with Haskell, but the language itself is already very generic, and you can go a long way before needing TH.
05:52:02 <hape01> I heard from Simon Peyton Jones, that there are many abstraction methods I can use without macros.
05:52:13 <hape01> That what you say seems to go the same direction.
05:52:36 <hape01> I like haskell very well but I needed months to get an Environment running, with flymake and occurences highlighting
05:52:44 <hape01> flymake / cabal  I mean
05:52:55 <hape01> No I can learn more easily :-)
05:52:59 <hape01> Now I can...
05:55:02 <kstt> ok. Well, most project manage to avoid TH. Unlike Lisp, where Macro are often the way to go, Haskell tries to avoid needing templating as much as possible.
05:55:54 <kstt> And my opinion is that it does very well, much better than most well known languages.
05:57:15 <saml> haskell so harrrd
06:01:05 <earthy> saml: time to go shopping?
06:05:14 <saml> earthy, time to learn harder
06:05:20 <saml> is there best practices cook book?
06:05:46 <saml> something like php.net. I want to copy and paste snippets to build a large software
06:06:04 <aavogt> kstt: often a TH solution to write a whole bunch of instances is easier to understand than the one without TH. Take HList's TypeEq vs. writing concrete instances   TypeEq a b => TypeEq (Maybe a) b    etc.
06:08:59 <earthy> saml: There is 'Real World Haskell'
06:09:30 <saml> that's too wordy.. it's trying to explain things instead of building programmer's intuition through examples
06:09:51 <earthy> and then there's lyah
06:10:31 <earthy> and there's shitloads of code out there on Hackage :)
06:10:54 <earthy> but, honestly, haskell does not lend itself well to cut&paste coding
06:11:14 <earthy> (and rightly so, imnsho)
06:11:16 <saml> no, copy and paste.. piped through programmer
06:18:12 <joe6> what is the package to use for html parsing? i see hxt and hxml (better version of haxml) for xml parsing
06:18:13 <Eduard_Munteanu> Wikibooks stuff might also be of interest, though it's stronger on theoretical concepts I think.
06:21:15 <joe6> or, is tagsoup the best option?
06:21:37 <saml> why do you want to parse html?  (this is haskell style question)
06:22:24 <joe6> because, I am downloading a web page and I want to read the data in it, but, do not want to get bogged down in text parsing the html to get to the content.
06:22:37 <joe6> perl had a module that would read the html into a data structure.
06:22:57 <joe6> and it was easier to get data out of the data structure than text-matching the html content.
06:22:59 <saml> what's the data you want to get out of html?
06:23:11 <joe6> saml, are you in your sarcastic mode?
06:23:30 <saml> no... you want  Text -> Tree String  ?
06:23:35 <joe6> table data.
06:23:38 <earthy> joe6: it depends. are you interesed in snippets of data or in the entire structure?
06:23:50 <saml> @hoogle Text -> Tree String
06:23:50 <joe6> i am interested in 3 tables.
06:23:51 <lambdabot> Warning: Unknown type Text
06:23:51 <lambdabot> Network.BufferType buf_toStr :: BufferOp a -> a -> String
06:23:51 <lambdabot> Text.Html prettyHtml :: HTML html => html -> String
06:24:22 <earthy> tagsoup then :)
06:24:26 <joe6> actually, one table with 3 sub-tables within it.
06:25:07 <saml> all of html parsers aren't functional. u should research on what's a functional way of solving the problem  (parsing unstructured data using heuristics converging to human behavior of writing unstructured html)
06:25:15 <saml> i'd be interested in reading your paper.
06:25:40 <joe6> saml, i have no paper, just a simple webscrapper
06:26:00 <saml> how can this be?!?!?!
06:26:49 <saml> http://www.haskell.org/haskellwiki/Web/Libraries/XML_and_HTML  ?
06:27:58 <saml> why so many String types?   some libraries operate on Text, some Lazy.Text, some Internal.Text, some Word8, some Char8, some ByteString..
06:28:11 <saml> do I keep pack and unpack between libraries?
06:29:08 <saml> so we need TH to unify String types.
06:29:21 <saml> and have the compiler choose the best string type
06:31:29 <earthy> saml: the different string types have different pros and cons, and there's historical reasons that some libs have different string types
06:31:35 <kstt> there is overloaded string for litterals
06:32:11 <saml> yah.. but to use different libraries, do I pack and unpack?
06:32:45 <kstt> bytestring is badly named : its byte array with functions to operate on them when they are filled with bytes having a string meaning :)
06:32:47 <saml> let's say http request returns strict Text.. but responds needs lazy Text
06:33:25 <earthy> well, pack and unpack may not be the most efficient conversion
06:33:31 <kstt> saml: do you want the response to fill the memory or not ?
06:33:34 <saml> then how do you do?
06:33:45 <saml> kstt, i'm not sure.. i don't want to probably
06:33:49 <earthy> saml: it really depends on which type to which type
06:34:04 <saml> so.. what's the solution?
06:34:09 <saml> is there conversion table?
06:34:22 <saml> like php does?  or can type system help somehow?
06:34:33 <earthy> e.g. strict bytestring to lazy bytestring    fromChunks . return
06:34:35 <kstt> saml : so not :) Now, do you want to explicitely manage the stream, or have the "stream nature" attached to the type you are using ?
06:35:02 <saml> i don't know.. i just want to write a web scale application.. and i'm stuck on String
06:35:11 <earthy> lazy bytestring to strict bytestring   SB.concat . toChunks
06:35:39 <saml> earthy, is that on wiki?
06:35:39 <kstt> different use cases, different types. Some people argue that "lazy types" are a poor choice, and prefer explicitely chuncked strict types, combined with enumerators.
06:35:47 <saml> i'm gonna tweet this so that i can refer later
06:35:53 <earthy> saml: not that I know about it
06:36:42 <earthy> however, there is http://blog.johantibell.com/2011/04/haskell-libraries-you-should-use.html
06:37:34 <ion> Perhaps someone should make a library that does as efficient as possible conversions between string types with something simple to use like ‘convertString :: (SourceString in, TargetString out) => in -> out’. :-P
06:38:36 <earthy> oh, and saml, *do* read http://stackoverflow.com/questions/6162484/why-does-modern-perl-avoid-utf-8-by-default and especially the first answer
06:38:42 <saml> where efficient possible is hardcoded.. good documentation would be sufficient
06:38:57 <kstt> saml: having different types with different lazyness allows you to decide when and how to convert data from a representation to an other. With PHP, everybody use plain strings, even when it is a suboptimal choice. There are reasons why haskell is so much faster than PHP :)
06:39:23 <saml> so.. a good documentation is needed.
06:39:29 <saml> with lots of examples
06:39:48 <Phyx-> is there anyway, to add like preprocessor information to a hs file, and then during compilation get ghc or cabal to make multiple files based on these annotations?
06:40:06 <kstt> "make" ?
06:40:10 <Phyx-> i want to prevent having to maintain multiple versions of something
06:40:20 <earthy> phyx-: you can use cpp
06:40:44 <Phyx-> earthy: with #IF ?
06:40:51 * earthy nods
06:41:32 * Phyx- looks into it
06:41:36 <Phyx-> thanks earthy
06:41:50 <earthy> {-# LANGUAGE CPP -#}
06:48:22 <HugoDaniel> {-# LANGUAGE Java #-}
06:48:51 <Phyx-> blasphemy
06:49:00 <Phyx-> hang him!
06:49:04 <earthy> why?
06:49:07 <HugoDaniel> :D
06:49:32 <Phyx-> he wants to sully the Haskell!
06:52:25 <kaol> @karma+ java
06:52:25 <lambdabot> kaol's karma lowered to -1.
06:52:43 <sipa> heh
06:52:59 <HugoDaniel> :D
06:53:14 <sipa> @karma+ c++
06:53:14 <lambdabot> c++'s karma raised to 0.
06:53:21 <Phyx-> hahahah
06:53:25 <sipa> @karma- c++
06:53:25 <lambdabot> c++'s karma lowered to -1.
06:53:42 <Phyx-> @karma
06:53:42 <lambdabot> You have a karma of 1
06:53:43 <HugoDaniel> kaol's karma is no longer an instance of the type class L33t
06:53:46 <Phyx-> -.-
06:54:04 <Phyx-> that's what you get for liking a sucky language :)
06:54:28 <HugoDaniel> {-# LANGUAGE Brainf*ck #-}
06:54:29 <kaol> @karma+ php
06:54:29 <lambdabot> php's karma raised to -1.
07:04:48 <lpsmith> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.1.0/src/GHC-List.html#zipWith
07:05:15 * lpsmith is wondering if zipWith should have the static argument transformation applied
07:05:33 <copumpkin> don't see why not
07:07:28 <lpsmith> http://hackage.haskell.org/trac/ghc/ticket/4976
07:08:02 <copumpkin> fair enough :)
07:09:15 <lunaris> Does anyone know of a way to get a type class' associated types through reify in TH?
07:10:38 <danharaj> am I a freak if I like GADT syntax for my regular algebraic data :[
07:11:24 <Phyx-> danharaj: yes :P
07:11:32 <Saizan> i'd say no
07:11:42 <Saizan> it makes more sense, actually
07:11:57 <Phyx-> I don't really think so
07:12:20 <Phyx-> I find the GADT syntax rather ugly
07:12:27 <lunaris> GADTs ftmfw.
07:13:08 <Saizan> with data Foo = Bar Int, you have Bar (a data constructor) applied to a type (Int) which you actually can't do anywhere else
07:13:49 <danharaj> yeah, actually data constructors tripped me up the very first time I tried to learn Haskell. I didn't realize they were just slightly special regular functions.
07:14:14 <Saizan> while data Foo where Bar :: Int -> Foo is defining Bar by stating a well-formed property of it
07:15:04 <lpsmith> You are making yourself more dependent on GHC for no real reason,  if you care about such things.
07:15:21 <danharaj> pff, when more than half of hackage depends on GHC, you don't have that problem.
07:16:01 <lpsmith> Yeah, honestly at this point that there isn't much reason to care,  and many reasons not to care :)
07:16:05 <Jetbeard> I learnt Haskell at uni where for some reason the course recommended hugs
07:16:30 * benmachine resists obvious joke
07:16:54 <lpsmith> Jetbeard: probably because that's what professors were accustomed to,  and they probably didn't want to learn something new-ish
07:16:56 <shachaf> Saizan: That property seems a bit weird as a definition, though.
07:17:01 <lpsmith> (though ghci is like,  11 years old now)
07:17:56 <shachaf> By which I mean that Bar :: Int -> a -> Char -> Foo doesn't really look like a product type.
07:18:01 <Jetbeard> lpsmith: it did have upside of when providing statistics in interactive mode (:s +s or something?) it gave you the number of reductions rather than the time
07:18:25 <Jetbeard> and many of the assignments were about improving the asymptotic complexity of your methods so benchmarks had to be provided
07:18:38 <shachaf> Admittedly the "Bar Int a Char" thing is also a pretty weird special-case.
07:23:25 <Saizan> you'd have to use Bar (Int,a,Char) like ml folks
07:28:24 <Phyx-> we used helium
07:28:33 <Phyx-> honestly, i've never had problems with normal datatypes
07:28:56 <Phyx-> it seems to me, that reading a book would have sufficed not to trip up
07:33:29 <kmc> i'w with danharaj
07:34:07 <shachaf> kmc: On GADTs?
07:34:30 <danharaj> I hope he's not in my room right now. I locked the door o.o
07:34:30 <shachaf> data Bool where { True :: Bool; False :: Bool }?
07:36:07 <kmc> maybe not for enumerations ;P
07:36:22 <Peaker> Saizan: but the ADT syntax looks more like the pattern match
07:36:23 <shachaf> It's a slippery slope.
07:36:24 <kmc> data Maybe a whee { Nothing :: Maybe a; Just :: a -> Maybe a }
07:36:31 <Saizan> "data Bool where True False :: Bool" is not so bad
07:36:36 <shachaf> data Maybe a wheeeeeeeee
07:36:37 <kmc> yes, 'whee' will be a keyword in H2012
07:36:40 <Peaker> but I agree the application-like syntax with a type is indeed a freak in there
07:37:03 <zygoloid> wher?e* will all be keywords :)
07:37:24 <Peaker> whereeeeeeeeeeeeeeeeee
07:37:43 <shachaf> data Foo whe
07:37:55 <Saizan> data Foo meh ?
07:38:04 <ido> sometimes i wonder if smlnj had it right with so few keywords... /troll
07:40:18 <alios> i've a strange platfrom with ghc7.3+freebsd8.2+yesod persistent: db migration works (both sqlite + pgsql backend), but on the first query from yesod handler i get a segfault with sqlite or a 'SqlError {seState = "E", seNativeError = 7, seErrorMsg = "execute: PGRES_FATAL_ERROR: no connection to the server\n"}' with pgsql. Any ideas where to start debugging??
07:41:00 <shachaf> kmc: I tried to :bro Hdis86 and it was longer than my terminal's scrollback buffer. :-(
07:41:12 <copumpkin> aw
07:41:14 <shachaf> (On the topic of enumerated types.)
07:41:27 <shachaf> Quite an enumeration.
07:42:10 <alios> s/platform/problem
07:42:54 <erus`> @hoogle Char -> Int
07:42:55 <lambdabot> Data.Char digitToInt :: Char -> Int
07:42:55 <lambdabot> Data.Char ord :: Char -> Int
07:42:55 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
08:00:47 <danharaj> How do you write the Show instance for free monads?
08:00:58 <djahandarie> The same way you write it for Mu I imagine
08:01:00 <joe6> i want to do the shortest match (non-greedy match) with Text.Regex.Posix. Is that possible?
08:01:21 <joe6> RWH says that it is not possible. Just wanted to check if there are different ways of doing that.
08:02:13 <lunaris> danharaj: I'm pretty sure you can do it with UndecidableInstances and StandaloneDeriving
08:02:52 <lunaris> danharaj: Something like deriving instance (Show x, Show (p (Free p x))) => Show (Free p x)
08:03:08 <lunaris> Probably need FlexibleContexts and friends too.
08:03:13 <danharaj> lunaris: yeah.
08:03:37 <lunaris> If you actually want to know how it's written, then you can -ddump-deriv (I think)
08:03:45 <lunaris> But it's a bit cryptic.
08:03:47 <lunaris> I suck at this.
08:04:49 <danharaj> It'd be nice if you could have constraints like "f is a type constructor such that, Show a => Show (f a)"
08:05:17 <lunaris> Hmm.
08:05:29 <lunaris> Obviously you can do it with a newtype, but that's a bit annoying.
08:05:34 <lunaris> Or UndecidableInstances.
08:05:44 <lunaris> Hand holding required, essentially.
08:05:52 <Peaker> newtypes aren't that annoying IMO
08:06:14 <lunaris> It's syntactic noise I'd rather do without.
08:06:23 <lunaris> But obviously they have many advantages that I (ab)use daily.
08:06:29 <danharaj> newtyping things like this reminds me of iso- vs. equirecursive.
08:06:47 <Peaker> well, with SEC combinators to access newtypes (which can be generalized to a class which should have a "deriving" clause) the syntactic noise is rather minimal
08:06:56 * lunaris is now in too deep.
08:07:09 <lunaris> Peaker: True
08:07:39 <danharaj> By the way, how would you do it with newtypes?
08:07:49 <lunaris> danharaj: I was thinking of something like:
08:08:55 <lunaris> class PreservesShow f :: * -> * where { }; newtype ShowPreserver f a = ShowPreserver (f a); instance Show a => Show (ShowPreserver f a) where ...
08:08:58 <lunaris> Off the top of my head.
08:09:23 <danharaj> ah hm.
08:09:24 <lunaris> The newtype avoids the UndecidableInstances requirement.
08:09:40 <danharaj> People shouldn't be afraid of undecidableinstances.
08:09:41 <lunaris> Whereas instance Show a => Show (f a) doesn't.
08:09:42 <Peaker> why do you need the PreservesShow class? You can just take a ShowPreserver value directly
08:10:00 <Peaker> It doesn't limit generality..
08:10:14 <lunaris> Peaker: True; I forgot the (possibly useful) constraint: instance PreservesShow f => Show (ShowPreserver f a) ...
08:10:25 <lunaris> If you wished to limit the set of fs.
08:10:39 <lunaris> -- < danharaj> It'd be nice if you could have constraints like "f is a type constructor such that, Show a => Show (f a)"
08:10:49 <lunaris> I took that to mean ``for some fs I want it, others not''
08:10:51 <lunaris> But like you said.
08:10:54 <lunaris> The newtype is all you need.
08:11:30 <lunaris> danharaj: I use UndecidableInstances all the time :/
08:11:36 <lunaris> danharaj: And RankNTypes.
08:11:42 <danharaj> and ImpredicativePolymorphism?
08:11:48 <lunaris> Not yet :)
08:11:55 <shachaf> Just use -fglasgow-exts
08:12:08 * shachaf misses the good old days of glasgow-exts.
08:12:10 <lunaris> {-# LANGUAGE KitchenSink #-}
08:12:23 <danharaj> {-# LANGUAGE AllThat, AndABagOfChips #-}
08:12:23 <lunaris> Depends how many games I'm playing.
08:12:29 <lunaris> EmptyDataDecls is handy too
08:12:33 <ion> {-# LANGUAGE KitchenSink #-}
08:12:41 <ion> whoops, someone said it already :-D
08:12:45 <lunaris> :)
08:12:50 <Peaker> lunaris: the constraint you forgot on the Show instance of ShowPreserver seems not just useful, but mandatory
08:13:09 <lunaris> Peaker: If you wish to restrict things, yet.
08:13:10 <lunaris> yes*
08:13:20 <Peaker> (otherwise Show a doesn't really imply that (Show (f a)))
08:13:28 <lunaris> Indeed.
08:13:40 <lunaris> As mentioned, I suck at this :/
08:13:59 <Peaker> lunaris: it's non-trivial IMO, I was slightly confused myself :)
08:14:05 <shachaf> Why isn't there a MonadZero class separate from MonadPlus?
08:14:14 <lunaris> I wasted some time trying to get an operad library working last week in the hope of eliminating newtype noise.
08:14:17 <shachaf> For that matter, why MonadZero/MonadPlus and not just Zero/Plus?
08:14:37 <lunaris> shachaf: Historical I think -- Why isn't there a Pointed class?
08:14:54 <shachaf> That would've been my next question. :-)
08:14:59 <Peaker> shachaf: the MonadZero rather than Zero is for two reasons: A) Laws associating Monoid with Monad  B) Lack of higher-ranked class constraints
08:15:18 <shachaf> Higher-ranked class constraints?
08:15:18 <lunaris> Peaker: You can do higher-ranked class constraints if you're willing to provide the evidence yourself :)
08:16:03 <Peaker> shachaf: well, to get a Monad m  which also forms a Monoid (m a)  for any a, you have to say:   (Monad m, forall a. Monoid (m a)) => ...
08:16:22 <Peaker> shachaf: and "forall" can't appear in class constraints
08:16:23 <lunaris> http://mainisusuallyafunction.blogspot.com/2010/09/higher-rank-type-constraints.html
08:16:28 <shachaf> Oh, yes.
08:16:50 <lunaris> Posts like that are why I love GADTs.
08:16:59 <lunaris> If the type checker can't sort itself out, you just step in.
08:17:02 <lunaris> Ugly plumbing and all
08:17:03 <lunaris> :)
08:18:09 <shachaf> lunaris: Did you use to have another nick?
08:18:20 <Peaker> shachaf: even if you could have that, you would want a class to state that you abide by the laws:  class (forall a. Monoid (m a), Monad m) => MonadPlus m where {}     but people really hate law-classes
08:18:33 <lunaris> shachaf: Nope, though thanks for associating me with someone else who is possibly more proficient than me.
08:18:43 <Peaker> I'm not sure why people hate law classes, but they seem to have their good reasons :)
08:19:31 <Peaker> shachaf: e.g: the law that   zero >>= x = zero
08:20:05 <shachaf> Why do people hate law-classes?
08:20:22 <ciaranm> because they're taught by lawyers
08:20:44 <lunaris> I resisted the similar joke that they're full of law students.
08:20:44 * shachaf was avoiding that pun.
08:20:47 <Peaker> I forget who explained it to me, I think it may have been edwardk.  Supposedly it soon leads to a cartesian explosion of such classes that you have to manually pass
08:20:50 <shachaf> I should know better than to do that on IRC.
08:21:00 <lunaris> We all should.
08:21:08 <Peaker> I've not seen it happen myself, so I am not sure
08:21:10 * lunaris hangs his head in shame.
08:21:17 <danharaj> law classes don't even really enforce their laws so it's like whatever.
08:21:46 <lunaris> danharaj: Is that from LHC, the Liam Lynch compiler?
08:21:48 <shachaf> #haskell enforces their laws, though.
08:21:53 <shachaf> Halt, law-breaker!
08:22:00 * lunaris can't hang his head any lower.
08:22:06 <lunaris> Whoah.
08:22:16 <lunaris> Set someone up there.
08:22:21 * lunaris takes cover
08:22:41 * shachaf suspects it would've been a good idea to sleep last night.
08:22:55 <joe6> anyone knows how to find the shortest match with regex-tdfa?
08:24:06 <lunaris> joe6: Sorry, I've got no experience with it.
08:24:25 <shachaf> joe6: Nor do I.
08:24:42 <shachaf> From now on whenever someone asks a question, everybody who doesn't know the answer should speak up.
08:24:58 <shachaf> So people don't complain about the channel being "too quiet".
08:25:11 <lunaris> shachaf: Nah
08:25:21 <lunaris> I only do it because no-one ever responds to my questions :)
08:25:32 <shachaf> Oh. :-(
08:25:35 <shachaf> Ask some questions!
08:25:57 <lunaris> Well
08:26:04 <lunaris> I find it's quicker to work on the solution.
08:26:10 <lunaris> Even though the solution is a complete hack.
08:27:13 <merijn> shachaf: I saw a mudcrab the other day. Vile creatures... :>
08:28:33 <shachaf> Any neat Haskell puzzles, #haskell?
08:28:48 * shachaf should probably stay away from IRC in his current mental state.
08:28:50 <Peaker> joe6: maybe you can use parsec to parse the regexp into a parsec parser that tries the shortest regexp? :)
08:29:05 <Peaker> shachaf: what's a "Haskell puzzle"?
08:29:15 <shachaf> A puzzle that involves Haskell.
08:29:16 <zygoloid> shachaf: implement ST and STRef in Haskell'10, or prove that such an implementation is impossible
08:29:41 <shachaf> zygoloid: Sure. unsafeCoerce is part of Haskell'10, right?
08:29:47 <zygoloid> no, it is not :)
08:29:47 <SoleSoul> Write a functional reactive gui library
08:29:57 <shachaf> zygoloid: Sure it is. FFI addendum, right?
08:30:03 <zygoloid> shachaf: also, you are not permitted to use the FFI :)
08:30:28 <EEVIAC> implement STM
08:30:50 <EEVIAC> there's an article in monad reader 15 that sketches the process
08:31:06 <zygoloid> shachaf: i don't believe unsafeCoerce is part of the FFI addendum either, but i could be completely wrong on that point
08:31:13 <zygoloid> it's certainly easy to implement via FFI, though
08:31:24 <shachaf> zygoloid: You can implement it with unsafePerformIO, can't you?
08:31:26 <SoleSoul> I am interested in the state of Haskell real functional gui libraries. Is there such a library which is good enough for real application?
08:31:29 <thoughtpolice> zygoloid: you can implement unsafeCoerce in terms of unsafePerformIO in GHC at least
08:31:36 <zygoloid> shachaf: also not part of haskell'10
08:31:48 <shachaf> Right, but it is part of the FFI addendum, isn't it?
08:32:01 <thoughtpolice> (and unsafePerformIO is in the FFI addendum for Haskell 98, but doesn't haskell 2010 make the FFI part of the standard, not an addendum?)
08:32:21 <Peaker> I wonder how one proves an implementation of anything is impossible with Haskell'10 (if it is possible in general, in GHC Haskell, for example).  Proof by contradiction seems out of the question.  You might have to enumerate the entire standard to prove that some power is lacking
08:32:31 <zygoloid> shachaf: you're not permitted to use the FFI for this challenge :)
08:32:31 <thoughtpolice> I mean, arguably it makes no difference since haskell98 + the addendum was considered 'the standard' i thought, but maybe i'm wrong
08:33:17 <thoughtpolice> @faq is anything possible with Haskell'10
08:33:17 <lambdabot> The answer is: Yes! Haskell can do that.
08:33:18 <danharaj> Very few people pay attention to Haskell98 when writing production code.
08:33:35 <danharaj> Some very considerate library writers pay attention though :p
08:33:54 <Peaker> IOW: How do you prove that GHC extensions actually add power to Haskell? How do you prove that the existing primitives don't yield that power in some composition previously unthought of (and sometimes Oleg and others manage to come up with one)
08:34:15 <Saizan> zygoloid: is there some result on implementing ST without FFI or unsafeCoerce but allowing any GHC extension?
08:34:20 <thoughtpolice> well, personally if there truly is no need for extensions or the gains are dubious/minimal, I don't see why you shouldn't try to stick to the standards. people often complain when they use 'GHC Haskell' and it breaks in ways they don't like
08:34:32 <roconnor> Peaker: usually Oleg proves that the extensions don't add any power.
08:34:40 <travisyay> does anybody know any good links for learning how to implement pi-calculus into haskell? i'm working on a research project and need to learn how to do that
08:34:48 <Peaker> roconnor: yeah, that's what I'm saying
08:35:08 <Peaker> roconnor: I was wondering if it is practical to prove something is expressible in GHC Haskell but not in H98 or H10
08:35:20 <roconnor> probably
08:35:26 <roconnor> but I wouldn't know how?
08:35:38 <thoughtpolice> danharaj: that said, not even MPTC's are part of haskell'98, and those are pretty widely used ;)
08:35:42 <Tomsik> Peaker: you know that when typechecker doesn't halt ;)
08:35:42 <djahandarie> By using the denotational semantics probably?
08:35:46 <roconnor> I like to think that the rank2 polymorphism that makes runST work isn't possible in Haskell 98
08:36:04 <marzin> hi to all :)
08:36:11 * djahandarie afk
08:36:48 <shachaf> @ahoy marzin
08:36:48 <lambdabot> "marzin"
08:37:27 <zygoloid> Saizan: i don't know, but i've not seen any such result. i'd certainly be interested if there's a type-safe GHC extension which makes it possible
08:37:35 <Peaker> Tomsik: well, what about proving a negative?
08:38:07 <Tomsik> What do you mean?
08:38:17 <marzin> I'm new to haskell :D nice language but main disadventages is a few libraries
08:38:31 <Peaker> Tomsik: if something is not expressible without some GHC extension -- can you prove it?
08:38:38 <danharaj> marzin: have you checked hackage
08:38:40 <kmc> marzin, there are tons of libraries, the hard part is figuring out which ones are good
08:38:48 <danharaj> kmc: oh god yes.
08:38:51 <kmc> and which of the good ones is best for your problem
08:39:01 <Tomsik> Peaker: undecidable instances are not expressible without GHC extensions
08:39:11 <shachaf> Does Haskell'10 have Rank2Types?
08:39:16 <kmc> no
08:39:29 <kmc> H2010 is super conservative
08:39:38 <kmc> imo Rank2Types is the only truly essential GHC extension
08:39:43 <Peaker> Tomsik: Well, that's provable because you can probably prove the type-checker always halts. Nice one :-) What about harder ones?
08:40:13 <Tomsik> I think they're kind of pretending in H2010 that there'll be more advanced haskell implementations besides GHC
08:40:23 <Peaker> kmc: I never really understood the relationship between Rank2 and RankN -- is RankN more powerful, or does it just save some newtype wrappers, or what?
08:40:36 <Tomsik> Peaker: I'm not quite sure what you mean
08:40:37 <marzin> oh, thanks for info :)
08:40:59 <kmc> Peaker, i think it's more powerful.  but maybe you can use newtypes with PolymorphicComponents to fake it
08:41:01 <Tomsik> I think you can encode RankN in Rank2
08:41:06 <Peaker> kmc: also, GADTs or type-families are pretty essential too (one can make up for the lack of the other, probably)? Or do you think they're expressible just with Rank2?
08:41:08 * Eduard_Munteanu remembers multiplate (?) claiming they use *just* rank-3 polymorphism as opposed to other contenders, or something like that :)
08:41:19 <Tomsik> IIRC in system F you can
08:41:19 <marzin> bye :)
08:41:28 <kmc> type inference for rank > 2 is not decidable
08:41:40 <kmc> adding those newtype constructors is like adding type annotations, i guess
08:41:45 <Peaker> Tomsik: Well, can you prove ST is not expressible in H2010? Or that Rank2 adds expressive power to H2010?
08:41:51 <kmc> Tomsik, System F is arbitrary-rank already
08:42:02 <kmc> Peaker, I don't consider GADTs or type families essential for getting real work done
08:42:04 <kmc> they are very nice, yes
08:42:12 <kmc> but they're relatively new features and we got by without them for a long time
08:42:16 <Eduard_Munteanu> Well, I think ST isn't safe without rank-2 stuff.
08:42:21 <Peaker> kmc: what about Rank2? Why is it essential?
08:42:27 <kmc> Peaker, mainly ST
08:42:29 <Eduard_Munteanu> Dunno if there's any proof though.
08:42:32 <kmc> and things like ST
08:42:40 <Peaker> well, Rank2 gives you type safety with ST.  GADTs give you type safety with countless other things
08:43:03 <kmc> the GADT things can be done with dynamic checking instead
08:43:06 <kmc> runST can't really
08:43:08 <Peaker> "Getting work done" doesn't require either, because safety is not a requirement for work
08:43:16 <Eduard_Munteanu> Hrm, GADTs don't do the job for ST, do they?
08:43:44 <edwardk> peaker: you need both for different purposes though
08:44:03 <edwardk> and i can encode the GADT concerns with finally tagless and universal quantification ;)
08:44:07 <kmc> Peaker, also "real work" sometimes requires existential types imo
08:44:12 <kmc> and Rank2 is an acceptable way to encode them
08:44:39 * shachaf wishes GHC had exists.
08:44:49 <kmc> yeah
08:44:50 <Phyx->  is there a tutorial somewhere on the new cabal test interface?
08:45:02 <edwardk> data Exists = Exists a — done ;)
08:45:16 <kmc> data Exists f where { Witness :: f a -> Exists f }
08:45:18 <edwardk> er data Exists where Exists :: a -> Exists
08:45:20 <Peaker> kmc: existentials are a good point, but existential types are a smaller extension than Rank2, aren't they?  Also: Almost always it is possible to use a less efficient encoding for the existential, but that indeed hinders "getting work done" and not just "safety"
08:45:45 <edwardk> kmc: its in category extras that way more or less
08:45:50 <Eduard_Munteanu> edwardk: that's not really existential, no?
08:45:57 <Peaker> shachaf: might as well go all the way towards DT's
08:46:03 <shachaf> Does that work with type-class constraints?
08:46:05 <edwardk> http://hackage.haskell.org/packages/archive/category-extras/latest/doc/html/Control-Functor-Limit.html
08:46:14 <edwardk> see colimit
08:46:34 <Tomsik> from my little experience with Agda dependent typing is a bit too much for a general-use programming language
08:46:39 <Eduard_Munteanu> forall a. Exists a    vs   Exists (forall a. a)
08:46:44 <edwardk> Eduard_Munteanu: i was being mildly facetious, since i was working with Exists Id
08:46:57 <edwardk> the quantifier is outside
08:47:17 <Peaker> Tomsik: Why?
08:47:23 <Peaker> Tomsik: Too many annotations?
08:47:27 <Eduard_Munteanu> Hm, wouldn't it go inside in GADT syntax?
08:47:50 <edwardk> hah i'd forgotten i'd added some cheesy cones and cocones to category-extras
08:47:57 <Peaker> I have not really used dependent types.  In my ignorance, I believe that a great IDE could alleviate the problems associated with dependent types
08:48:37 <Tomsik> Well, for one inference is completly messed up
08:48:48 <Tomsik> and mainly, the mental overhead is quite big
08:48:49 <edwardk> peaker: in agda it largely does. the limitation being that the ide is emacs ;)
08:48:56 <Peaker> Tomsik: that's not inherent, IMO -- you could do HM inference by default, and have the user override it?
08:49:24 <Peaker> edwardk: And emacs sucks (relatively to a true structural editor) :-)  I doubt the Agda guys have made emacs not suck..
08:49:26 <Tomsik> It sounds like a lot of mental work to get the program just to typecheck
08:49:58 <Peaker> Tomsik: What if type inference is something your editor does on your code as you edit it, rather than a separate compilation pass?
08:50:17 <kmc> cheesy cones?
08:50:26 <kmc> sounds like something you can buy at the state fair
08:50:59 <Eduard_Munteanu> What's worse is Vim probably can't handle being an interactive IDE for Agda :/
08:51:05 <kmc> cheesy cones deep-fried in lard and dipped in chocolate
08:51:09 <Eduard_Munteanu> (or not easily)
08:51:20 <shachaf> Why are all text editors bad?
08:51:28 <kmc> in fact just iterate the deep-frying and chocolate-dipping process until a fixedpoint is reached
08:51:40 <Tomsik> Peaker: sounds hard to implement for a DT language
08:51:40 <Peaker> I think vim/emacs, being text editors to their very core -- can not be (what I consider) good IDE's.  For dependent types I think we should only have structural manipulations on the program, not textual ones
08:51:58 <Peaker> Tomsik: as a text editor extension, I agree.. as a structural-editor-from-scratch, I disagree :)
08:52:23 <ido> as a human being, i am confused.
08:52:35 <kmc> haha
08:52:36 <kmc> hi ido
08:52:40 <ido> hi kmc
08:52:47 <Peaker> ido: where are you from? ido is an Israeli name
08:52:53 <ido> israel
08:53:09 <Peaker> ido: ah, cool. Another Israeli Haskeller :-)  Mind if I PM?
08:53:23 <ido> go for it
08:53:36 <ido> not much of a haskeller compared to the liked of kmc though
08:54:19 <kmc> wonder if israel has the most haskellers per square meter of any country
08:54:37 <kmc> though being from there != living t here
08:54:41 <Peaker> kmc: doubtful :-)
08:54:45 <shachaf> Doesn't Peaker always go on about how few Haskellers there are in .il?
08:54:58 <accel_> to write a postscript interpreter in haskell -- what should I use as a backend for drawing the lines / curves ?
08:55:34 <ben> postscript? :)))
08:55:47 * hackagebot algebra 0.4.0 - Constructive abstract algebra  http://hackage.haskell.org/package/algebra-0.4.0 (EdwardKmett)
08:56:11 <accel_> i mean for displaying the postscript file
08:56:14 <accel_> hmm
08:56:23 <accel_> perhaps I should look at how gv/evince does the to screen rendering
08:56:26 <ben> gtk2hs/cairo?
08:56:54 <ido> recently had the pleasure of doing some homework in haskell btw, kmc.  felt so good.
08:59:33 <Eduard_Munteanu> Cairo should be fine I guess, considering it also has an OpenGL backend IIRC.
09:07:14 <shachaf> An extension that converts a pattern to a function that returns a Bool for whether it's matched or not would be nice.
09:07:57 <shachaf> Or even anonymous case expressions.
09:10:03 * zygoloid . o O ( {-# LANGUAGE CPP #-} #define matches(pat) (let __test__ \(pat) = True; __test__ _ = False in __test__) )
09:13:35 <monochrom> onoes, moar cpp
09:14:45 <copumpkin> NEEDMOAR
09:14:56 * shachaf isn't sure whether to zygoloid++ or zygoloid--
09:15:07 <monochrom> do both :)
09:15:08 <shachaf> Hmm, your karma went up from that.
09:15:15 <Phyx-> http://pastebin.com/tZ5sR4CX can anyone tell me why that's not working?
09:15:18 <mauke> The paste tZ5sR4CX has been copied to http://hpaste.org/48951
09:15:28 <monochrom> mauke++
09:15:57 <Phyx-> why
09:16:04 <Phyx-> what exactly makes hpaste better
09:16:20 <monochrom> should you "cabal build" first?
09:16:26 <mauke> the fact it's not pastebin.com
09:16:34 <benmachine> or configure --enable-tests or something?
09:16:46 <Phyx-> and the fact that you lose total control over your paste?
09:16:52 <monochrom> pastebin.com is just the worst. anything else is better. go to #python, see they do the same
09:17:09 <Phyx-> benmachine: thanks
09:17:23 <k0ral> anyone could build up and try the webkit demo package from hackage please ?
09:17:30 <mauke> Phyx-: how does pastebin.com give you total control?
09:17:38 <monochrom> pastebin.com has a flash thing. and some people report bugs.
09:17:41 <benmachine> Phyx-: does it work?
09:17:45 <Phyx-> mauke: I can delete my pastes, i can set expiration date
09:17:54 <Phyx-> i can set scope, e.g. public/private
09:18:08 <mauke> Phyx-: that doesn't very well if I mirror every paste
09:18:17 <mauke> enjoy your "control"
09:18:17 <monochrom> heh
09:18:20 <Phyx-> benmachine: yeah, though i get another error now, 'cabal.exe: permission denied'
09:18:27 <benmachine> hm, weird
09:18:33 <benmachine> are you using a development version or a released version?
09:18:47 <Phyx-> not sure..
09:19:01 <benmachine> (can anyone comment on the most lightweight way of extracting a bytestring from a mysql database?)
09:19:07 <Phyx-> cabal-install version 0.9.5
09:19:08 <Phyx-> using version 1.11.0 of the Cabal library
09:19:17 <Phyx-> but can't remember if i build it from darcs
09:19:31 <benmachine> I appear to be using 0.10.2 but I can't remember where I got it from either :P
09:19:40 <mauke> also, re: private pastes: http://mauke.dyndns.org/interweb/?w=freenode/%23haskell
09:19:44 <HugoDaniel> ive seen that video presentation from spj
09:19:48 <benmachine> 0.10.2 is the latest on hackage
09:19:52 <HugoDaniel> where he used "observable" data types
09:19:55 <HugoDaniel> that vary through time
09:20:03 <benmachine> 0.9.5 was never on hackage
09:20:10 <HugoDaniel> where can i read more about those ?
09:21:23 <Phyx-> it'll fetch a newer cabal-install
09:23:11 <Phyx-> hm
09:23:15 <Phyx-> still get access denied
09:23:15 <copumpkin> edwardk: why the Numeric namespace, by the way? :)
09:23:21 <Phyx-> i wonder what it's trying to run
09:23:26 <accel_> http://www.mail-archive.com/haskell-cafe@haskell.org/msg89892.html <-- is this issue ever resolved? i.e. guis in haskell on osx
09:24:21 <monochrom> current stable haskell platform gives cabal-install version 0.10.2 using version 1.10.1.0 of the Cabal library
09:24:37 <monochrom> methinks your combination is a bit odd
09:24:57 <Phyx-> cabal-install version 0.10.2
09:24:58 <Phyx-> using version 1.10.2.0 of the Cabal library
09:25:04 <Phyx-> it's just 1 minor version off
09:25:45 <Phyx-> and i've never used HP
09:26:06 <accel_> haskell platform is amazing
09:26:11 <accel_> it's like haskell done right
09:27:22 <ido> FFI is hard let's go shopping
09:28:28 <ion> FFI is hard. Better drink my own piss.
09:28:35 <Peaker> accel_: I never gave installing it a shot -- it seemed for Ubuntu it was not standalone (need to install ghc manually, first..?)
09:28:37 <Eduard_Munteanu> Heh.
09:28:53 <Phyx-> accel_: it's just GHC + packages + cabal isn't it
09:29:14 <Phyx-> it doesn't take much time to setup ghc for me with the standalone so i never tried it
09:29:18 <Phyx-> or from source
09:29:35 <Phyx-> err. i meant, doesn't take much time from source either, excluding compilation
09:29:55 <Eduard_Munteanu> @quote own.piss
09:29:55 <lambdabot> No quotes match. Just what do you think you're doing Dave?
09:30:52 <Eduard_Munteanu> @remember ion <ido> FFI is hard let's go shopping.    <ion> FFI is hard. Better drink my own piss.
09:30:53 <lambdabot> Okay.
09:37:45 <yip> i'm writing a chat server and it's very imperative with vars and IO and i'm wondering how i can make it more functional
09:38:27 <saml> yip, what's type ?
09:38:38 <saml> Chat String ?
09:39:14 <parcs> "vars" ?
09:39:30 <saml> is it IRC server?
09:39:42 <saml> you need events and stuff
09:41:33 <yip> it's custom protocol
09:41:51 <yip> i'm using STM so lots of TVars
09:44:24 <saml> yip, why not erlang?
09:45:01 <saml> yip, can i see your code?
09:46:18 <yip> i like haskell :)
09:46:39 <saml> because it lets you use lots of TVars, right?
09:46:40 <yip> hm.... it's a lot of code
09:47:06 <saml> that's another benefit of haskell. it lets you write a lot of code
09:47:32 <parcs> yip: check out TChans, for on
09:47:34 <parcs> e
09:48:48 <yip> parcs: yeah, i'm also using those. but i'm trying to figure out a design that will allow me to code all of the logic without using any STM or IO
09:48:59 <parcs> ok
09:51:00 <monochrom> vars and IO are alright for chat server.
09:53:31 * Phyx- gives up on this test suite
09:53:43 <Phyx-> all i keep getting is permission denied
09:54:05 <parcs> yip: what are you using tvars for?
09:57:21 <yip> monochrom: yeah, it's good for the base. but i'm adding lots of high level commands and stuff now, and it doesn't feel right, working directly in IO and directly modifying state
09:58:08 <yip> parcs: one example is a TVar containing a list of usernames who have been muted. when a moderator sends a command to mute a user, then the user is added to a list, and a timer is also set that will remove the user from the list after a set amount of time
09:58:25 <kmc> yip, maybe the answer is just more higher-order helper functions
09:58:44 <kmc> how are you doing timers?
09:58:45 <yip> kmc: i'm thinking that maybe functional reactive programming can maybe be used here
09:59:05 <yip> kmc: i fork a thread that does a threadDelay and then performs its action
10:00:04 * hackagebot property-list 0.0.3 - XML property list parser  http://hackage.haskell.org/package/property-list-0.0.3 (JamesCook)
10:00:24 <yip> as i add more and more features, i keep adding more state and more TVars. it's all starting to become a mess and too complicated
10:01:08 <kmc> yip, sounds like a good approach
10:01:11 <kmc> i love lightweight threads
10:01:21 <kmc> not only that they're lightweight in the GHC RTS
10:01:27 <kmc> but also that there's very little cod required to use them
10:01:56 <c_wraith> but I like cod.  it's tasty.  I want more
10:02:09 <kmc> heh
10:02:15 <kmc> can't type today
10:02:16 <erus`> i like scampi
10:02:26 <c_wraith> I never can type, so I'm not mocking you :)
10:03:02 <yip> threadDelay has a limit to the amount that it can delay, so i have a helper function
10:03:03 <k0ral> is there a library that makes it possible to get the computer architecture (typically x86 or x86_64) ?
10:03:04 <yip> waitMinutes minutes = replicateM_ minutes (threadDelay (60 * 1000 * 1000))
10:03:59 <kmc> yip, sure, or you can use http://hackage.haskell.org/package/unbounded-delays
10:04:02 <erus`> System.Info k0ral. maybe
10:04:20 <erus`> System.Info.arch
10:04:43 <erus`> @import System.Info
10:04:43 <lambdabot> Unknown command, try @list
10:04:47 <erus`> @list
10:04:47 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
10:05:01 <erus`> > import System.Info
10:05:02 <lambdabot>   <no location info>: parse error on input `import'
10:05:11 <yip> kmc: nice :)
10:05:34 <kmc> > System.Info.arch
10:05:35 <lambdabot>   Not in scope: `System.Info.arch'
10:05:59 <erus`> shouldnt that be an IO String
10:06:01 <erus`> rather than a string
10:06:14 <kmc> that is something of a philosophical question
10:06:25 <kmc> it won't change during the lifetime of the program
10:06:32 <kmc> it's a compile-time string constant
10:06:42 <shachaf> @summon conal
10:06:42 <lambdabot> Unknown command, try @list
10:06:51 <kmc> there are some places where compile-time constants are put into IO for philosophical reasons
10:06:51 <c_wraith> conal believes it should be in IO. :)
10:06:55 <erus`> well its impure
10:07:01 <kmc> what about maxBound :: Int?
10:07:03 <yip> but what if you run the same executable on different architectures?
10:07:10 <danharaj> you can't
10:07:14 <danharaj> you have to create a new exe
10:07:15 <kmc> yip, you'll get the same result.  it's a compile-time constant
10:07:24 <kmc> erus`, what does "impure" mean?
10:07:35 <erus`> !pure
10:07:40 <kmc> what does "pure" mean?
10:07:41 <erus`> unpure?
10:07:49 <danharaj> The value is referentially transparent.
10:07:50 <erus`> pure means will allways return the same result
10:07:52 <shachaf> kmc: !impure, obviously.
10:07:58 <shachaf> On the other hand, machine-sized Int has the same issue.
10:08:02 <kmc> this will always return the same result
10:08:05 <danharaj> No, pure means if you substitute the expression for its value, you get the same result.
10:08:12 <kmc> where "always" means "until you recompile the program", which of course can change anything
10:08:30 <kmc> erus`, you might as well say that "x :: Int; x = 3" is impure because I might edit the file and write "x = 4" instead
10:08:43 <erus`> kmc was there not a big hoo haa about Ints not being a specific size
10:09:02 <monochrom> in fact, "x::Int, x=33333333333333333333333333333333333" would be impure, platform-dependent
10:09:02 <shachaf> kmc: http://conal.net/blog/posts/notions-of-purity-in-haskell
10:09:03 <erus`> kmc i think its the same code should do the same thing anywhere you compiel it?
10:09:09 <shachaf> monochrom: It is!
10:09:23 * shachaf has no idea why Integer isn't the default Integral type.
10:09:27 <benmachine> danharaj: but then you have to decide what you mean by "value" :)
10:09:31 <kmc> shachaf, it is the 'default'
10:09:39 <c_wraith> shachaf: it's the default Num type....
10:09:47 <benmachine> kmc: but it's not used in take and drop and etc.
10:09:50 <benmachine> which is silly
10:09:52 <kmc> right, that's bad
10:09:56 <kmc> that's a separate issue though
10:10:04 <danharaj> benmachine: Normal form of the expression.
10:10:11 <monochrom> you could be arguing to ban "Int" and allow "IO Int" only
10:10:14 <kmc> erus`, in my view IO is not about "impurity", it's about describing IO actions which have not occurred yet
10:10:26 <shachaf> kmc: I mean the one that's actually used in the standard library. length and so on.
10:10:28 <kmc> getting the compile-time machine architecture is not an IO action
10:10:32 <erus`> maybe another monad then?
10:10:41 <kmc> monads in general are definitely not about "impure"
10:10:50 <kmc> whether it's a monad is irrelevant
10:10:53 <danharaj> The only impure function in standard haskell is unsafePerformIO
10:11:15 <danharaj> (more or less)
10:11:36 <Eduard_Munteanu> :t take
10:11:37 <lambdabot> forall a. Int -> [a] -> [a]
10:11:42 <shachaf> What about in another Functor? Are those impure?
10:11:59 <Eduard_Munteanu> Maybe it shouldn't be Integer either
10:12:08 <shachaf> (Please ignore previous statement.)
10:12:32 <Eduard_Munteanu> (Not mine)
10:12:36 <Eduard_Munteanu> :P
10:12:41 <shachaf> (No, ignore Eduard_Munteanu's!)
10:12:54 <shachaf> (Please ignore previous statement.)
10:12:56 <monochrom> /ignore *!*@*
10:13:03 <Eduard_Munteanu> :)
10:13:12 <shachaf> (Please ignore previous statement.)
10:13:12 <shachaf> (Please ignore previous statement.)
10:13:23 * shachaf ought to sleep.
10:13:32 <kmc> (Please ignore next statement.)
10:13:36 <kmc> (Please ignore previous statement.)
10:13:50 <danharaj> kmc: done.
10:17:07 <k0ral> erus`: thank you !
10:18:14 <monochrom> (please ignore all statements)
10:18:27 <monochrom> (please ignore all requests, too)
10:18:27 <Eduard_Munteanu> Russel would be proud.
10:18:52 <danharaj> Russel'd be pissed if he found out Haskell got two languages named after him.
10:19:05 <danharaj> Russell'd*
10:19:16 <Eduard_Munteanu> Wasn't there only one 'l'?
10:19:22 <kmc> Russel'd!
10:19:33 <danharaj> There's two.
10:19:35 <Eduard_Munteanu> @google Russell
10:19:35 <lambdabot> http://www.russell.com/
10:19:35 <lambdabot> Title: Russell Investments - Worldwide Home
10:19:36 <monochrom> two l's
10:19:41 <Eduard_Munteanu> @google Russel
10:19:42 <lambdabot> http://www.russellathletic.com/
10:19:43 <lambdabot> Title: Russell Athletic
10:19:46 <Eduard_Munteanu> Damn.
10:19:56 <shachaf> @google +Russel
10:19:57 <lambdabot> http://en.wikipedia.org/wiki/Russel_Hobbs
10:19:57 <lambdabot> Title: Russel Hobbs - Wikipedia, the free encyclopedia
10:20:00 <danharaj> Google is not (=={
10:20:01 <monochrom> russell would be pissed someone invests in his name
10:20:04 <danharaj> (==)
10:20:05 <shachaf> @bing
10:20:05 <lambdabot> pong
10:20:30 <kmc> data Set = Set (Set -> Bool); russell x@(Set f) = not (f x); main = print (russell (Set russell))
10:20:37 <Eduard_Munteanu> Now I'm not sure whose was missing a letter.
10:21:02 <shachaf> Clearly Russel Hobbs is the poor man's Russell Hobbes.
10:22:11 <monochrom> haha
10:22:37 <Eduard_Munteanu> *whose name
10:22:42 <Eduard_Munteanu> Bah, now I'm missing words.
10:24:59 <shachaf> http://en.wikipedia.org/wiki/Bertrand_(programming_language)
10:25:08 <shachaf> http://lambda-the-ultimate.org/node/648
10:26:07 <Eduard_Munteanu> Husserl? Damn, can't remember :)
10:26:37 <Eduard_Munteanu> Anyway, maybe Russel is just a common misspelling.
10:27:05 <shachaf> Is "Munteano" a common misspelling?
10:28:29 <Eduard_Munteanu> Mm, nope.
10:28:48 <Eduard_Munteanu> At least I don't think so.
10:29:12 <Eduard_Munteanu> Russel is an alternate spelling of Russell     -- Wikipedia
10:29:30 <shachaf> Rustle is an alternate spelling of Russell -- #haskell
10:30:06 <Eduard_Munteanu> Says Haskel Curry :P
10:30:47 <luite_> Haskle?
10:33:48 <copumpkin> oh man
10:33:52 <copumpkin> I remember the haskle dude
10:34:06 <copumpkin> eu_prleu_peupeu or something
10:39:11 * hackagebot pool 0.1.0.3 - Thread-safe resource pools.  http://hackage.haskell.org/package/pool-0.1.0.3 (MichaelSnoyman)
10:39:49 <k0ral> is there a built-in function like map but with the following signature :: (a -> IO b) -> [a] -> IO [b] ?
10:40:24 <ben> @type mapM
10:40:24 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
10:40:55 <k0ral> wonderful
10:41:12 <parcs> > ['a', 'o', 'e']
10:41:12 <lambdabot>   "aoe"
10:42:04 <conal> yip: i'd approach that question by doing my best to set aside the communication (I/O) mechanisms and explore what's at the essence of chatting. then design a small collection of abstract types around this essence.
10:43:29 <conal> yip: having these essential types, then define their meaning precisely and as simply as possible.
10:44:06 <conal> yip: and only then revisit those I/O mechanisms and discover how they are a sort of "rendering" of the essential purely functional/denotative types.
10:45:01 <yip> conal: that sounds about right, but i'm having a really hard time imagining what the abstract types should look like
10:45:40 <danharaj> yip: Have you tried modelling users and chat rooms as pure types? Afterwards you can plug in the IO where you need to. Basically, simulate a chat room first, then implement it in IO.
10:45:43 <conal> yip: cool. it's hard, because you're focusing on the essential part. and there isn't much charted territory here.
10:46:30 <conal> i.e., what's the essence of chatting?
10:46:37 <danharaj> Concurrent messaging.
10:46:45 <conal> (which is not a programming question.)
10:47:34 <yip> hm...
10:47:35 <conal> danharaj: could be. explore that candidate by making it precise and then optimize the precise formulation for simplicity.
10:47:59 <conal> yip: have you read luke palmer's post on semantic design?
10:48:06 <yip> i think that FRP is really close to what i'm looking for, since FRP helps manage state, and i'm dealing with a lot of state here
10:48:09 <yip> conal: no
10:48:10 <conal> @google luke palmer semantic design.
10:48:12 <lambdabot> http://lukepalmer.wordpress.com/2008/07/18/semantic-design/
10:48:12 <lambdabot> Title: Semantic Design « Luke Palmer
10:48:36 <yip> conal: thanks i'll read that
10:48:39 <Codex_> I think chatting is about function Int->String with String length limited to 150 characters and Int rotates from 0...Inf :)
10:48:53 <conal> yip: check it out for a general orientation. btw, i now call this method "denotational design".
10:49:34 <conal> yip: more examples at http://conal.net/papers/type-class-morphisms/
10:50:16 <conal> yip: though combined with a discipline for type class instances free of abstraction leaks.
10:51:07 <danharaj> yip: try modelling two users chatting with each other first, that's probably the simplest example that captures all the technical details.
10:51:25 <conal> i wonder what a good forum would be for this sort of denotational design explorations.
10:51:34 <conal> danharaj: yeah. i like that suggestion.
10:51:55 <conal> reminds me of one of polya's principles: "If you can't solve a problem, then there's an easier problem you can solve: find it."
10:52:16 <danharaj> another approach is to look at things from relative points of views, instead of trying to see everything at once. What does chatting look like from the point of view of a user? What does it look like from the point of view of a server?
10:52:45 <conal> danharaj: nice!
10:55:23 <danharaj> you can also slice it as observation and interaction. What does a chat program look like if it can only read? What does it look like if it can only write?
10:55:56 <danharaj> (Looking at it that way, I think it's fairly evident that in most chat protocols, reading and writing are completely decoupled)
10:59:14 <danharaj> conal: how goes Reactive?
10:59:30 <k0ral> hmmm, how come the functions words, unwords, etc. run without importing Data.List, while nub and delete won't ?
10:59:40 <ocharles> Hey, can anyone provide any good reading material on representing a database schema in Haskell? At the moment, I'm encoding "has-one" or "belongs-to" relationships in my data types, and getting the results of "has-many" through a function call, on the "owning" entity
10:59:40 <danharaj> k0ral: what do you mean?
10:59:44 <ocharles> I'm not sure it's necessarily the best way
10:59:55 <conal> danharaj: i don't know. it's getting some background cycles but not much conscious attention.
11:00:37 <danharaj> conal: if you're interested, I'm working on a discrete time reactive library, but right now I'm stuck on 'plugging in' IO sources.
11:01:11 <conal> danharaj: ah. why discrete?
11:01:22 <k0ral> danharaj: I mean Data.List.{nub,delete} are said to be out of scope while Data.List.{words,unwords} aren't
11:01:24 <djahandarie> Because it doesn't compose as well! ;)
11:01:34 <k0ral> danharaj: without importing Data.List
11:01:38 <conal> djahandarie: :)
11:01:48 <gdoteof> When looking at the haskell docs with the function descriptions.. what do these things mean:    (a -> b) -> [a] -> [b]   or [a] -> [a] or (a -> a -> a) -> [a] -> [a]
11:02:00 <conal> http://conal.net/blog/posts/why-program-with-continuous-time/
11:02:05 <danharaj> k0ral: That's because nub and delete are not in Prelude, the implicitly imported library.
11:02:41 <danharaj> conal: because I feel like continuous time is a leaky abstraction w.r.t. physical simulation, one of the things I want to work with.
11:03:08 <k0ral> danharaj: so words/unwords aren't taken from Data.List but actually from Prelude ?
11:03:36 <danharaj> k0ral: Yeah.
11:03:55 <conal> danharaj: in that the results depend on an *approximation* to the abstraction. so you'd like to make the approximation explicit (above the abstraction line instead of below)?
11:04:54 <Eduard_Munteanu> gdoteof: those are the types of those functions
11:05:15 <gdoteof> Eduard_Munteanu: thanks.  i think i kind of gathered that; i just don't know how to interpret them
11:05:31 <gdoteof> repeat ::  a -> [a]   takes an item and returns a list
11:05:40 <danharaj> conal: Well, the major thing is that the values of continuous FRP systems depend on how you step them. That sits wrong with me.
11:05:45 <gdoteof> i think is what that means
11:05:58 <gdoteof> scanl1 ::  (a -> a -> a) -> [a] -> [a]   but this i have no idea
11:06:04 <gdoteof> takes a something and a list and returns a list?
11:06:20 <conal> danharaj: when integration is present?
11:06:34 <benmachine> gdoteof: a function and a list
11:06:44 <Eduard_Munteanu> gdoteof: do you know about currying?
11:06:54 <conal> danharaj: and often implementations conflate sampling with choice of numeric integration approximation/stepping.
11:07:14 <Eduard_Munteanu> Ok, probably not.
11:07:14 <gdoteof> Eduard_Munteanu: vaguely;  atomizing functions
11:07:54 <Eduard_Munteanu> If you have something A -> B -> C -> D, you can interpret it as a function that takes three arguments of types A, B and C (respectively) and returns something of type D.
11:08:13 <danharaj> conal: Yeah pretty much. Integration is not really computable, so you have to use numerical integration scheme.
11:08:15 <gdoteof> Eduard_Munteanu: ah great.
11:08:21 <gdoteof> that makes perfect sense
11:08:25 <parcs> k0ral: words, etc are reexported by the prelude
11:08:31 <conal> danharaj: what makes you think integration is not computable?
11:08:38 <parcs> from data.list
11:09:20 <Eduard_Munteanu> gdoteof: the reason is that's parsed as A -> (B -> (C -> D)). So applying f to its first argument returns a function that gets applied to the "second" argument and so on.
11:09:36 <danharaj> conal: Well it is, in principle, if you use arbitrary precision reals and simulate with the requisite accuracy at the beginning of simulation to get the desired accuracy when you extract the result.
11:09:37 <Eduard_Munteanu> All Haskell functions take only one argument, really.
11:09:44 <k0ral> parcs: good to know
11:09:58 <Eduard_Munteanu> Either a pair/tuple, or do this sort of stuff ^
11:10:22 <conal> danharaj: for instance. i have a blog post about exact integration, and there are some nicer treatments that luqui and sigfpe pointed me to.
11:10:24 <parcs> i dont think anything is actually defined in the prelude, just exported
11:11:17 <Eduard_Munteanu> But for this purpose you can think it takes multiple arguments.
11:11:26 <conal> danharaj: i also see that the way integration is handled in existing frp implementations is unsound/leaky.
11:11:55 <conal> danharaj: just as is most numeric computing in haskell (other than Integer).
11:12:39 <danharaj> conal: It seems to me that if you use exact integration in FRP, you have to hold on to the entire history of the computation in case you need to go back and get more bits of information.
11:13:02 <conal> danharaj: could be. worries me also.
11:13:03 <Eduard_Munteanu> gdoteof: you could try looking into LYAH, if you're interested in a book/tutorial.
11:13:06 <Eduard_Munteanu> @where lyah
11:13:06 <lambdabot> http://www.learnyouahaskell.com/
11:13:24 <parcs> oh, just seq and !$: http://hackage.haskell.org/packages/archive/base/4.3.1.0/doc/html/src/Prelude.html
11:13:56 <conal> danharaj: if we want well-defined & correct programs, i guess we have to face hard questions like this one.
11:14:11 <conal> danharaj: whether above or below our abstractions.
11:14:30 <danharaj> conal: It's actually possible to get global error bounds on some numerical integration problems so if you made one of those and used sufficient resolution to make the absolute error smaller than the desired accuracy, it would work and perhaps efficiently.
11:15:20 <conal> danharaj: maybe so. i'd love to see (and collaborate on) more work in this area (sound, ligh-level numeric programming).
11:15:28 <conal> (*high-level)
11:15:50 <danharaj> conal: I think a good compromise would be to have two layers of abstraction: Discrete below (you don't always want continuous time anyway), approximation in the middle, and complete the sandwich with Continuous time on top.
11:15:51 <conal> awwww. two baby deer just walked by my window with (i assume) their mother.
11:16:01 <ciaranm> dinner!
11:16:14 <danharaj> breakfast, lunch, and dinner. There's 3 of them.
11:16:27 <danharaj> also where do you live that you can be one with nature and on IRC at the same time :p
11:17:05 <conal> danharaj: "compromise" in what sense? as in not quite defined or correct? or maybe you mean a correct implementation of a well-defined spec?
11:17:32 <Eduard_Munteanu> conal: is there any particular FRP library or framework you're building upon in your research?
11:18:00 <Eduard_Munteanu> Or maybe I should ask, which is the recommended FRP framework to start looking into if I'm interested?
11:18:37 <danharaj> conal: A compromise in that I don't think you can abstract above numerical integration. I think that's where a programmer has to start for any serious project. They have to design their numerical integration scheme before they can work with continuous time.
11:19:20 <conal> danharaj: i'm confused. you & i just agreed that exact/correct integration is possible, didn't we?
11:19:33 <conal> Eduard_Munteanu: i don't know. none of them are really satisfactory to me. various semantic bugs/short-cuts and/or implementation short-comings.
11:19:46 <danharaj> conal: I consider that an integration scheme-- one that requires a lot of resources :p
11:20:28 <conal> danharaj: i think my confusion is wondering what's behind "I don't think you can abstract above numerical integration".
11:20:51 <Eduard_Munteanu> Ah, I suppose I should just go pick one to get me started.
11:20:54 <Philippa> any abstraction above that's inherently leaky?
11:21:06 <conal> danharaj: maybe you just meant we don't yet know how to implement integration both correctly & efficiently.
11:22:47 <Philippa> I don't think that's "just" what danharaj meant
11:22:55 <danharaj> conal: Well, it seems very unlikely in general. In order to get N bits of accuracy in the future, you will need to compute some f (N) bits right now. But f can also depend on time and be unbounded with time. Only special cases have an f that is independent of simulation time.
11:23:00 <conal> Eduard_Munteanu: i started Reactive to explore particular ideas about correct & elegant efficient change-driven execution. but i knew the abstraction isn't suitable for interactivity.
11:23:02 <Codex_> conal: floats are good approximations of the continuous stuff.
11:23:25 <copumpkin> they're horribly leaky abstractions though
11:23:29 <danharaj> conal: oh also, have you seen edwardk's denotational model of IO? :p
11:23:38 <conal> danharaj: tricky, indeed!
11:23:53 <danharaj> tricky, but it looks like he hit the bullseye you wanted.
11:24:10 <conal> danharaj: i haven't seen edwardk's model. do you have a url?
11:24:36 <conal> danharaj: my "tricky" was referring to your remarks about exact integration. tricky problem, indeed.
11:24:37 <Eduard_Munteanu> I see, thanks.
11:25:05 <danharaj> it's a bit heavy reading, part of a three part series, but shouldn't be hard for you. http://comonad.com/reader/2011/free-monads-for-less-3/
11:25:22 <conal> danharaj: i'm skeptical about any useful denotational model of IO, considering that the purpose of IO has been to hold everything we don't understand denotationally.
11:25:42 <conal> danharaj: thx.
11:26:08 <Philippa> danharaj: does the 3-body problem fall under this heading?
11:27:33 <conal> danharaj: so far in ed's post i'm seeing modeling of some small subsets of IO.
11:27:49 <danharaj> Philippa: Partially. You can get a global error bound on the energy of the system.
11:28:10 <conal> danharaj: but i'll read the full series carefully.
11:28:10 <danharaj> Trajectories: no. It's a chaotic system. Modelling the trajectories takes exponential bits of accuracy in the time you want to simulate :p
11:29:21 <Philippa> danharaj: Quite :-) Even /games/ sometimes need kludgy approximations to n-body
11:29:26 <conal> and, of course, that state monad explanation of IO is a myth, since it cannot capture concurrency (even program/world) or nondeterminism.
11:29:41 <danharaj> Philippa: Well, if you have global bounds on energy, your simulation will look plausible. :p
11:30:19 <danharaj> conal: at the end he replaces the state passing model with an model where FFI operations are an open set.
11:30:46 <conal> danharaj: and gives those FFI operations a (precise) semantics?
11:31:10 <djahandarie> conal, this paste is similar to what ed talks about at the beginning of that article: http://hpaste.org/48041
11:31:11 <conal> danharaj: and somehow addresses concurrency & nondeterminism?
11:31:44 <danharaj> conal: well he addresses concurrency and nondeterminism exactly. the definition of FFI operations is left separate.
11:32:29 <conal> djahandarie: again, that paste addresses a tiny subset of IO
11:32:32 <djahandarie> But it isn't particularly denotational. It just moves the magic into mkMain
11:33:18 <djahandarie> Right, the point of that paste was just to show that you only need Mu IOF, not Free IOF.
11:33:21 <danharaj> conal: asking for FFI operations to be denotated is asking to define the operating system :D
11:33:44 <danharaj> or at least a virtual machine.
11:34:00 <Philippa> quite. Think of it as the Free Function Interface
11:34:02 <conal> danharaj: yep. which is why i wouldn't go that route.
11:34:23 <conal> danharaj: doesn't look likely to provide a basis for correct & tractable reasoning.
11:34:35 <Philippa> conal: do you mean no FFI, or that it'd be modelled differently?
11:34:58 <danharaj> conal: It would be if you used something like HaLVM
11:35:05 <conal> danharaj: so i like instead to think of ways to move that sort of low-level mechanism *under* the line of precise & tractable abstractions.
11:35:42 <conal> we already have lots of extremely imperative mechanism beneath our purely functional abstractions.
11:35:53 <conal> e.g., stack frame munging, thunk updating.
11:36:51 <conal> so just as with the earlier conversation about functional/denotative chat room formulation, we can ask the same questions about operating system mechanisms.
11:37:20 <conal> namely: these mechanisms are part of an implementation of what precise & tractable denotative abstractions?
11:39:43 <danharaj> Edwardk's IO is sort of inverted from that. What happens is that the RTS hands you a value (the IO part of the program) and tells your thread to evaluate it. It works outside in.
11:40:45 <Philippa> it almost has to have that inversion, really
11:41:09 <Philippa> I mean, that's something I always liked as an implication of the world-passing model: you might get back a world where your computational substrate just got hit by a meteorite
11:41:40 <danharaj> in this case you don't get anything, you are oblivious to the world. The IO monad models the fact that your code is being examined by an external agent.
11:41:58 <Philippa> it implicitly admits that ultimately, the Theory of Everything owns you
11:42:21 <danharaj> Heh :p Barring the laws of physics, you could attach a lot of algebraic laws to parts of the FFI
11:42:30 <danharaj> Particularly grabbing memory and doing pointer arithmetic.
11:43:03 <danharaj> And if you wrote your device drivers in Haskell, you could define more and more of it denotatively with laws and all.
11:43:05 <Philippa> *nod*. Until some arsehole runs your code on a system with no memory protection, anyway :p
11:43:12 <Philippa> but yeah
11:43:19 <Philippa> danharaj: seen Idris?
11:43:23 <danharaj> Well the beauty is that you can put your code in a virtual machine and make the VM exact.
11:43:30 <danharaj> Philippa: nope.
11:43:46 <Philippa> edwinb's dependently-typed language for systems programming
11:43:58 <danharaj> That sounds badass.
11:45:25 <djahandarie> danharaj, the IO *monad* does that?
11:46:06 <danharaj> djahandarie: Well, edwardk's model does.
11:49:32 * hackagebot resource-pool 0.2.0.0 - A high-performance striped resource pooling implementation  http://hackage.haskell.org/package/resource-pool-0.2.0.0 (BryanOSullivan)
11:50:53 <luite_> ugh hackage should generate haddock before announcing the packages on irc :p
11:51:13 <danharaj> word.
11:53:08 <parcs> then it would announce packages once per day
11:53:40 <dylukes> why is the haddock generation so slow?
11:53:49 <luite_> parcs: no it should generate haddock more often :p
11:54:50 <tgeeky> luite_: http://physics.aps.org/articles/v4/55
11:54:55 <byorgey> It generates haddocks in batch mode once or twice a day
11:54:58 <byorgey> I am not sure why
11:56:00 <ciaranm> sounds fishy
11:56:32 <luite_> tgeeky: thanks, I'll read it later
11:57:15 <tgeeky> luite_: a naive reading of the article makes it sound a lot like applicative:pure
12:04:37 <k0ral> what's the function I should use to send a string through a pipe for another process ?
12:05:00 <shachaf> k0ral: hPutStr?
12:05:09 <k0ral> thank you
12:05:17 <k0ral> I saw there was a pipe package
12:05:27 <k0ral> was wondering whether there was a difference... ?
12:09:17 <ion> http://heh.fi/haskell/functors
12:14:10 <accel_> what problem does Data.Dynamic solve?
12:16:36 <dolio> The problem that some people haven't learned how to live without 'dynamic typing' yet.
12:17:28 <accel_> why does real world ahskell recommend it for exception handling?
12:18:02 <dolio> Dynamic is a union of all types, plus a means for doing type case.
12:18:18 <dolio> So, probably because you can dump anything in there, and then poke at it to get things out in the handler.
12:18:35 <accel_> so it's
12:18:47 <accel_> Dynamic = data ... | .... | ... all the types defined ? ... | ... ?
12:18:55 <copumpkin> no
12:19:51 <kmc> dolio, harsh
12:20:05 <kmc> accel_, conceptually it's something like that
12:20:11 <danharaj> a lot of the types
12:20:21 <kmc> it's actually implemented with Typeable (which gives run-time type information) plus unsafeCoerce
12:20:40 <kmc> i think dynamic typing has its place and I'm glad I don't have to switch to a totally dynamically typed language when I want just a little dynamic typing.
12:20:50 <kmc> accel_, look at Data.Typeable first
12:21:09 <kmc> in particular
12:21:10 <kmc> :t cast
12:21:11 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
12:21:17 <dolio> Dynamic does have its place, certainly.
12:21:25 <copumpkin> I want a polymorphic dynamic
12:21:35 <roconnor> Dynamic has no place.
12:21:37 <dolio> I barely ever use it, though.
12:21:41 <copumpkin> one that lets me stick forall a. a -> a into it
12:21:43 <kmc> > cast (2 :: Int) :: Maybe Int
12:21:44 <lambdabot>   Just 2
12:21:45 <kmc> > cast (2 :: Char) :: Maybe Int
12:21:45 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
12:21:46 <lambdabot>    arising from the literal `2...
12:21:53 <shachaf> dolio: Can you type \x y -> x (x y) for me? :-)
12:21:53 <kmc> durr
12:21:54 <kmc> > cast ('x' :: Char) :: Maybe Int
12:21:55 <lambdabot>   Nothing
12:22:44 <dolio> \x y -> x (x y)
12:22:46 <dolio> Is that okay?
12:22:50 <shachaf> That's great.
12:22:56 <dolio> I didn't copy-paste.
12:22:58 <shachaf> Unless you just copied and pasted.
12:23:01 <shachaf> Oh. Good.
12:24:06 <geheimdienst> @hoogle cast
12:24:06 <lambdabot> Data.Typeable cast :: (Typeable a, Typeable b) => a -> Maybe b
12:24:06 <lambdabot> Foreign.C.String castCCharToChar :: CChar -> Char
12:24:06 <lambdabot> Foreign.C.String castCharToCChar :: Char -> CChar
12:25:05 <dolio> The actual place for Dynamic might possibly be better filled by a more specialized implementation in many cases.
12:25:13 <dolio> In which case Dynamic is kind of bad, being too large.
12:29:04 <tswett> > fix$(1:).scanl(+)1
12:29:05 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
12:29:44 <kmc> a lot of the time you might want existentials instead
12:29:54 <kmc> dynamic could be basically existentials + typeable
12:29:58 <ion> @unpl fix ((1:) . scanl (+) 1)
12:29:58 <lambdabot> fix (\ d -> 1 : (scanl (+) 1 d))
12:29:58 <kmc> but that's not actually how it's implemented for GHC
12:30:22 <dolio> Sure.
12:30:53 <dolio> What I mean is that even if you want existentials + typeable, you might want a GADT that captures exactly the universe of types you're working with.
12:31:09 <dolio> Instead of the all types case that Dynamic is.
12:31:15 <kmc> yeah
12:37:14 <xil> hi. I'm having a pointer related problem. I do what I think is writing a lot of data to a pointer, then I call peekArray to get that data back as a list. But the list is all zeros and it should contain many non-zero numbers
12:38:13 <kmc> can you hpaste your code?
12:38:40 <xil> yes one moment
12:40:02 <hpaste> xil pasted “Pointer Problem” at http://hpaste.org/48955
12:40:02 <shachaf> Hey, kmc.
12:40:03 <shachaf> @karma C/C
12:40:03 <lambdabot> C/C has a karma of 606
12:40:59 <xil> kmc: compmap is an IOArray and processCompMap is just a function to group elements in the list. I check at it's inputs and they are all zero, so rgblist must be all zero. That's about as far as I've been able to get
12:42:21 <edwardk> conal: the model on my blog does deal with concurrency, because the language itself exists entirely passively. external agents can ask it to apply a function to an argument and normalize the result, and can inspect what they get back, so they are responsible for driving IO by inspecting main, performing some action and passingthe result back in. concurrency doesn't affect these semantics. its basically a semantic hack to quotient out su
12:43:22 <kmc> xil, are you building with GHC -Wal?
12:43:24 <edwardk> its basically a semantic hack to quotient out such concerns
12:43:25 <kmc> -Wall? *
12:44:09 <xil> kmc: no. And I do a similar read of the OpenGL backbuffer for getting data to send to ffmpeg, and that works just fine
12:44:15 <conal> edwardk: thx. i'll check it out.
12:44:15 <kmc> ok
12:44:19 <kmc> this sounds like an opengl problem, then
12:44:23 <kmc> somehow readPixels is failing
12:44:32 <kmc> do you have the magic command line option to make it print out GL errors turned on?
12:44:34 <Lemon> how do you encode exists in terms of forall?
12:44:41 <xil> kmc: okay thanks. That's just what I wanted to know. I just wanted to make sure it wasn't something I was doing wrong with teh pointers
12:44:45 <kmc> Lemon, continuation-passing style transform
12:44:56 <xil> kmc: no I don't know about ony OpenGL command line options
12:44:59 <conal> Lemon: a couple of negations.
12:45:00 <Lemon> kmc, what does that look like?
12:45:05 <kmc> ∃t. F t  ≡  ∀r. (∀t. F t → r) → r
12:45:22 <Lemon> oh okay
12:45:23 <Lemon> thanks
12:45:33 <kmc> "I have (F t), for some t I won't tell you.  If you give me a continuation which doesn't care what 't' is, I will call that continuation and give you the result."
12:45:56 <kmc> conal, exactly a couple ;)
12:45:57 <Lemon> okay that makes sense
12:46:10 <Lemon> now I heard that "exists" has something to do with abstract types
12:46:18 <Lemon> but googling yields nothing
12:46:28 <kmc> ∃t. F t ≡ ¬ ∀t. ¬ (F t)
12:46:36 <kmc> ¬ t = t → r, because r might even be Void
12:46:59 <kmc> Void aka ⊥, the empty type
12:48:17 <conal> Lemon: yes, there is a classic paper about existentials & abstract types. maybe http://portal.acm.org/citation.cfm?id=6042
12:48:42 <Lemon> damn paywall
12:48:51 <conal> Lemon: though istr the title being more specific about existentials & adts.
12:49:08 <conal> Lemon: http://www.google.com/url?sa=t&source=web&cd=1&ved=0CBgQFjAA&url=http%3A%2F%2Flucacardelli.name%2Fpapers%2Fonunderstanding.a4.pdf&ei=yFQbTruzDYbX0QHAo5yWBQ&usg=AFQjCNFQ8l68yzcjR0B5P751GDtrJ4mMDA&sig2=APsX-igC_pOmq5os2DQPsg
12:49:12 <conal> urg, google.
12:49:21 <conal> http://lucacardelli.name/papers/onunderstanding.a4.pdf
12:49:21 <Lemon> okay thanks
12:49:48 <k0ral> does writeFile overwrite an existing file ?
12:49:50 <conal> Lemon: sure. might not be the one i'm trying to remember.
12:51:54 <byorgey> k0ral: probably. try it and see. =)
12:53:42 <alpounet> yes k0ral
12:53:45 <alpounet> appendFile doesn't
12:54:58 <dolio> There should be one with a name something like "Abstract Datatypes have Existential Types."
12:58:39 <kmc> you can also build abstract data types out of closures
12:59:34 <xil> kmc: thanks for the help. I figured out that it was a color problem. I defined the colors using Ints but I assumed the range was 0-255, but it was actually the whole range of Int. I changed it to Byte and now it works.
13:00:02 <kmc> aha
13:00:04 <kmc> cool :)
13:00:06 <k0ral> alpounet: thank you
13:02:52 <xil> is there a way to get more verbose error output? For example, is there any way to get line numbers with my errors? It doesn't help so much to know there was a problem with Map.find, especially when I don't even know of such a function, let alone what line it's on in my code
13:04:12 <kmc> ghc -prof -rtsopts --make foo.hs && ./foo +RTS -xc
13:04:15 <kmc> http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-options-debugging
13:04:48 * hackagebot yesod-comments 0.3.4 - A generic comments interface for a Yesod application  http://hackage.haskell.org/package/yesod-comments-0.3.4 (PatrickBrisbin)
13:05:01 <kmc> GHC makes runtime errors obscure so that you'll make them compile-time errors instead ;P
13:06:18 <xil> kmc: I definitely love compile-time errors, but sadly I've reached the limit of that with what I'm doing right now
13:06:42 <kmc> *nod*
13:07:01 <kmc> Haskell is not actually a great language for compile-time guarantees
13:07:10 <kmc> it's just so much better than anything else anyone has ever heard of
13:07:53 <xil> haha
13:08:34 * djahandarie raises the Agda banner
13:08:36 <Evious> Ooh, I like the -B "sound the bell at major GCs" option.
13:08:51 <xil> kmc: could it be that you're missing a "-RTS" at the end of the command you posted? I see that in the doc but not in yours
13:09:16 <kmc> xil,  that only matters if you want some non-RTS options after the RTS options
13:09:30 <kmc> Evious, ♫ DING ♫
13:09:44 <xil> kmc: ah okay
13:10:02 <kmc> i want an option for "sound bell at minor GCs, fog horn at major GCs, and set off a firecracker on program exit"
13:10:26 <djahandarie> Probably could make it happen if you have a fog horn and firecracker
13:10:58 <kmc> and an arduino and some nichrome wire and a field-effect transistor
13:11:04 <danharaj> relevant
13:11:05 <danharaj> http://animalsbeingdicks.com/page/6
13:11:18 <kmc> or maybe the things they use to launch model rockets
13:12:19 <geheimdienst> thank you danharaj :) a very nice contribution
13:12:37 * geheimdienst is enjoying it
13:14:00 <xil> kmc: uh...I tried the command you wrote and I get a "cannot find Prelude" error
13:14:22 <kmc> you need the profiling version of the standard library installed
13:14:34 <xil> kmc: ah
13:21:03 <danharaj> question
13:21:04 <danharaj> http://comonad.com/reader/2008/monads-for-free/
13:22:03 <danharaj> When he defines Free ((,)a) x, would bind be going to the end of the 'list', and using the value stored at the Return to create a new 'list' attaching it to the end of the first list?
13:25:02 <roconnor> danharaj: that sounds like a reasonable description of how bind works on a free monad.
13:25:20 <roconnor> danharaj: except instead of a list I'd say tree, and instead of end I would say leaves.
13:25:34 <danharaj> roconnor: yeah, true.
13:26:14 <danharaj> roconnor: It feels like continuations in a way. You have a tree, and at the leaves you have data that tells you how to continue the tree.
13:27:14 <roconnor> ya, I think there is a really really strong connection there that I don't understand myself.
13:35:47 <danharaj> I wonder if the structure is something interesting if you postulate that the function you bind can't use the information at the leaves.
13:36:01 <danharaj> so bind would essentially be :: m b -> ma -> m b
13:36:04 <danharaj> m a*
13:36:54 <danharaj> well I guess that's just a monoid anyway.
13:37:38 <c_wraith> so, you're replacing >>= with >> ?
13:37:51 <danharaj> yup
13:38:00 <danharaj> and I'm pretty sure that's for all intents and purposes a monoid.
13:38:29 <c_wraith> assuming the monad laws are obeyed, yes
13:38:36 <danharaj> well yeah.
13:38:43 <c_wraith> It's roughly the equivalent of the Last monoid
13:38:52 <c_wraith> except it builds up effects along the way
13:39:02 <danharaj> Last monoid?
13:39:36 <c_wraith> First and Last are newtypes that provide monoid instances that do...  what you'd expect.
13:39:43 <danharaj> ah I see
13:40:02 <danharaj> I don't think it's Last.
13:40:18 <danharaj> Like take Free ((,) a) above
13:40:29 <danharaj> it would be lists of type a and >> is append.
13:40:29 <c_wraith> well, it's not Last
13:40:39 <c_wraith> because it builds up effects
13:40:43 <danharaj> 'effects'
13:40:47 <c_wraith> where Last would throw them away
13:40:49 <danharaj> I don't believe in effects.
13:41:32 <c_wraith> danharaj doesn't believe in causality!
13:41:34 <benmachine> >> is append? since when?
13:41:41 <danharaj> benmachine: For that monad it is.
13:41:51 <benmachine> oh, ok
13:41:59 <benmachine> how does that work typingwise?
13:42:10 <benmachine> oh it appends the other bit
13:42:22 <djahandarie> > [1,2,3,4] >> [6,7,8,9]
13:42:23 <lambdabot>   [6,7,8,9,6,7,8,9,6,7,8,9,6,7,8,9]
13:42:40 <danharaj> different monad :p
13:42:49 <benmachine> Free ((,) a) b is a list of type a with a b on the end?
13:42:59 <danharaj> yeah.
13:43:06 <benmachine> mm, makes sense
13:43:19 <roconnor> the list monad isn't a free monad
13:43:22 <danharaj> so the monad is like append except you have access to more information
13:43:42 <djahandarie> roconnor, isn't it?
13:43:55 <roconnor> am I wrong?
13:44:01 <danharaj> What generates List?
13:44:16 <saml> > [1..] --generates list
13:44:17 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:44:27 <danharaj> saml: Jokes on you, I said List :p
13:45:18 <saml> I'm not sure what is List
13:45:29 <danharaj> you know it as [], the type constructor of lists.
13:45:53 <saml> is that syntactic sugar?
13:46:06 <djahandarie> roconnor, Free (a ,) gets you close, I think you just need to quantify over it
13:46:54 <danharaj> djahandarie: If you quantify over Free (a,) you get lists, but then you need to do something else to get the monad instance.
13:47:03 <roconnor> the structure of Free (a ,) is close to the structure of a list, but the binding structures as nothing to do with the monad operations on list as we know them.
13:47:52 <djahandarie> Oh true, the bind for that would be appending I think
13:48:04 <danharaj> djahandarie: Welcome to the conversation :p
13:48:19 <djahandarie> Sorry, walked in a little late I guess :p
13:48:48 <djahandarie> "Free MonadPlus" ? :-)
13:51:35 <edwardk> roconnor: posting on free modules momentarily
13:51:42 <joe6> is this predefined in some library: :t [January .. December]
13:51:47 <joe6> > January
13:51:48 <lambdabot>   Not in scope: data constructor `January'
13:51:59 <joe6> > :t January
13:52:00 <lambdabot>   <no location info>: parse error on input `:'
13:52:04 <joe6> :t January
13:52:05 <lambdabot> Not in scope: data constructor `January'
13:52:05 <roconnor> edwardk: categorical modules?
13:52:15 <djahandarie> Categorical modules?
13:52:16 <c_wraith> @hoogle January
13:52:16 <lambdabot> System.Time January :: Month
13:52:32 <joe6> c_wraith: ok, thanks
13:53:01 <edwardk> not particularly categorical though i do talk about the adjunction i'm using to describe my linear functionals briefly
13:53:27 <edwardk> http://comonad.com/reader/2011/free-modules-and-functional-linear-functionals/
13:54:05 <danharaj> So I have a problem, and I need some ideas.
13:54:09 <monadic> I have a library that I also have a few executables for (namely, a test driver and a set of profiling tests as well as benchmarks). How can I make it so that each executable in the cabal file doesn't rebuild the library modules?
13:54:29 <edwardk> monadic: separate packages
13:54:37 <edwardk> monadic: if its in the same package it'll rebuild for each
13:54:49 <edwardk> sad but true
13:55:10 <monadic> edwardk: Thats ugly. :(
13:55:32 <Saizan> monadic, edwardk: with recent cabal the exes can depends on the lib instead
13:55:37 <danharaj> This is my formulation of discrete frp: http://hpaste.org/48956
13:55:43 <monadic> Saizan: Version needed?
13:56:05 <danharaj> Simulating the frp takes place in a monad, I do this because I want to be able to incorporate effects, like IO if you're doing it in the IO monad.
13:56:21 <edwardk> saizan: nice
13:56:29 <edwardk> monadic: hah for a second i thought you meant my post =)
13:56:32 <Saizan> monadic: 1.8.* i think
13:57:10 <monadic> Saizan: Anything specific needed in the cabal file? I'm using 1.10.2
13:57:14 <monadic> which is the latest ;\
13:57:28 <Saizan> monadic: you've to put the library name in the build-depends: of the exe and also use a different hs-source-dirs: for it
13:57:57 <saml> what's smart haskell i can make tshirt out of?
13:58:09 <saml> to show the world how smart i am
13:58:11 <danharaj> The problem: I want to be able to turn monadic values, (f a) into reactive values. However, I don't know how to let values that depend on such values to share the results, instead of executing the action twice.
13:58:51 <monadic> Saizan: Thanks, I have it in the build-depends, I guess I just need the hs-source-dirs
14:01:59 <monadic> Saizan: Whats the reason for the different source directory?
14:03:05 <Saizan> monadic: because if you have a Foo.hs in the path ghc will pick that one instead of a Foo from an installed library
14:03:54 <monadic> Saizan: Ahh, okay. Well it worked like a charm and cut my compile time by 4, which is nice ;)
14:04:23 <Saizan> quite nice :)
14:06:56 <int80_h> how do I go about including a tabbed space in a string?
14:07:06 <kmc> > "\t"
14:07:07 <lambdabot>   "\t"
14:07:12 <int80_h> hmm
14:07:21 <int80_h> it ends up being a literal \t
14:07:35 <int80_h> yeah like that
14:07:39 <kmc> no, that's a tab character
14:07:51 <kmc> the Show instance for strings re-escapes special characters
14:07:52 <parcs> > ord (head "\t")
14:07:53 <lambdabot>   9
14:07:57 <augur> man
14:07:58 <luite_> > text "oh\thi"
14:07:59 <lambdabot>   oh        hi
14:08:00 <augur> it is so nice
14:08:08 <augur> to teach a programming language to a programmer
14:08:13 <kmc> i got 8 spaces that time ;P
14:08:15 <augur> to someone who has programmed before
14:08:28 <kmc> augur, not if that language is Haskell
14:08:37 <augur> kmc: actually thats what i just taught
14:08:48 <augur> and we went through the core of it in an hour
14:09:07 <augur> i mean, he HAS done some ocaml so theres that
14:09:54 <augur> but i mean, the core syntax and such? one hour.
14:10:03 <kmc> syntax is trivial
14:10:07 <int80_h> when I write that string to a file, it comes out a literal \t. How can I make it so it tabs instead?
14:10:08 <augur> it is, but its important!
14:10:13 <augur> he was ahead of me some times
14:10:22 <augur> with infixing function names, and sectioning operators and such
14:10:28 <kmc> int80_h, putStr "\t"
14:10:30 <augur> which was nice
14:10:31 <kmc> not print "\t"
14:10:35 <kmc> print = putStrLn . show
14:10:39 <kmc> so it invokes the escaping again
14:10:40 <int80_h> I use writeFile
14:10:50 <augur> i tried teaching scheme to another friend last semester
14:11:01 <augur> and getting through the intro stuff took i think two hours maybe?
14:11:08 <augur> i mean, whats scheme. (foo x y)
14:11:11 <augur> there now you know scheme
14:11:18 <int80_h> kmc: so U can use putStr to write to a file?
14:11:19 <kmc> main = writeFile "/tmp/tab" "\t" -- works for me int80_h
14:11:26 <kmc> you can use hPutStr to go to a file yeah
14:11:28 <int80_h> um I, I meant
14:11:37 <augur> but all of these ideas, conditionals, variable definitions, etc etc etc, took him time to grok
14:11:41 <augur> because he didnt code
14:11:46 <augur> (now hes totally into haskell, btw :D)
14:11:55 <augur> but with this other friend that i just taught, he has experience
14:12:01 <augur> hes on top of things
14:12:03 <augur> and its beautiful
14:12:42 <kmc> > iterate show "foo"
14:12:43 <lambdabot>   ["foo","\"foo\"","\"\\\"foo\\\"\"","\"\\\"\\\\\\\"foo\\\\\\\"\\\"\"","\"\\\...
14:13:30 <hpc> > fix show
14:13:30 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
14:14:56 <benmachine> > show fix
14:14:57 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> a) -> a)
14:14:57 <lambdabot>    arising from a u...
14:15:48 <parcs> > fix?show
14:15:49 <lambdabot>   mueval-core: internal error: PAP object entered!
14:15:49 <lambdabot>      (GHC version 6.12.3 f...
14:16:55 <kmc> o_O
14:16:58 <kmc> that's bad
14:17:20 <ion> > fix . scanl (flip (++) . show) $ "foo"
14:17:22 <lambdabot>   ["foo","foo\"foo\"","foo\"foo\"\"foo\\\"foo\\\"\"","foo\"foo\"\"foo\\\"foo\...
14:18:45 <Saizan> how was ? defined there?
14:19:09 <shachaf> > text$ap(++)show"text$ap(++)show"
14:19:11 <lambdabot>   text$ap(++)show"text$ap(++)show"
14:19:14 <kmc> > fix ?show
14:19:14 <lambdabot>   mueval-core: internal error: PAP object entered!
14:19:15 <lambdabot>      (GHC version 6.12.3 f...
14:19:19 <kmc> > fix ?x
14:19:20 <lambdabot>   mueval-core: internal error: PAP object entered!
14:19:20 <lambdabot>      (GHC version 6.12.3 f...
14:19:24 <parcs> > ?x
14:19:25 <lambdabot>   mueval-core: internal error: PAP object entered!
14:19:25 <lambdabot>      (GHC version 6.12.3 f...
14:19:31 <shachaf> @ty ?x
14:19:32 <lambdabot> forall t. (?x::t) => t
14:19:34 <kmc> it's unhappy with implicit params i guess
14:19:37 <kmc> > let ?x = 3 in ?x
14:19:38 <lambdabot>   3
14:19:50 <kmc> unbound ones
14:20:05 <kmc> probably because the constraint makes it into a function interanlly
14:20:25 <shachaf> > ?x :: Int
14:20:26 <lambdabot>   mueval-core: internal error: PAP object entered!
14:20:26 <lambdabot>      (GHC version 6.12.3 f...
14:21:03 <kmc> that should not typecheck
14:21:15 <parcs> it's a problem with hlint it seem-
14:21:18 <parcs> s
14:21:32 <kmc> unsound types? in my lambdabot?
14:21:34 <parcs> hint*
14:21:52 <kmc> :t ?x :: Int
14:21:53 <lambdabot> (?x::Int) => Int
14:22:21 <parcs> > const () ?x
14:22:22 <lambdabot>   mueval-core: internal error: PAP object entered!
14:22:22 <lambdabot>      (GHC version 6.12.3 f...
14:22:36 <kmc> > let y = ?x in ()
14:22:37 <lambdabot>   ()
14:22:41 <Tomsik> :t ?x
14:22:42 <lambdabot> forall t. (?x::t) => t
14:22:59 <hpc> > (\_ -> 5) ?x
14:23:00 <lambdabot>   mueval-core: internal error: PAP object entered!
14:23:00 <lambdabot>      (GHC version 6.12.3 f...
14:23:07 <hpc> that's annoying
14:23:11 <Tomsik> I assume that lambdabot is patched to work with this?
14:23:20 <kmc> Tomsik, what do you mean?
14:23:23 <Tomsik> Or does it work as a GHC extension?
14:23:25 <kmc> ImplicitParams is a GHC extension
14:23:28 <ion> > ?x `seq` 42
14:23:29 <lambdabot>   mueval-core: internal error: PAP object entered!
14:23:29 <lambdabot>      (GHC version 6.12.3 f...
14:23:31 <Tomsik> oh huh
14:23:37 <kmc> as we're finding out, it doesn't work quite right in lambdabot ;P
14:23:42 <kmc> these examples should be type errors
14:23:43 <Tomsik> :t ?x = 3
14:23:43 <lambdabot> parse error on input `='
14:23:48 <hpc> i assume it is only enabled for the purpose of subexpressions in :t
14:23:53 <kmc> > let ?x = 3 in ?x
14:23:54 <lambdabot>   3
14:24:09 <Tomsik> :t let ?x = 3 in ?x
14:24:10 <lambdabot> forall t. (Num t) => t
14:24:22 <kmc> > let { f x = ?y + x } in ( let ?y = 3 in f 2 )
14:24:23 <lambdabot>   5
14:24:25 <shachaf> > let f = ?x + 1 in let ?x = 3 in f
14:24:26 <lambdabot>   4
14:24:28 <kmc> ^^^^ dynamic scoping
14:24:31 <laar> what do those '?'s mean?
14:24:33 <kmc> shachaf stole my example
14:24:48 <kmc> laar, see the ImplicitParams extension documented in the GHC manual
14:24:50 <Tomsik> So, does it work well or is it more burden than anything else?
14:24:53 <kmc> they are dynamically scoped variables
14:24:59 <shachaf> kmc stole my example and then used a continuation to travel back in time and post it first.
14:25:38 <kmc> Tomsik, I think it works well enough, but the need for it is not great
14:26:04 <kmc> type classes are already like implicit parameters and most Haskell programmers are more (overly!) comfortable with those
14:26:24 <parcs> its the hip replacement for Reader
14:26:39 <kmc> it's nice in ?t though
14:26:45 <shachaf> kmc: Which do you dislike more, type classes or ImplicitParams?
14:26:48 <kmc> to get unification variables
14:26:52 <kmc> shachaf, type classes for sure
14:26:54 <kmc> :t ?f ?x
14:26:55 <lambdabot> forall t t1. (?x::t, ?f::t -> t1) => t1
14:27:03 <kmc> :t ?f (?f ?x) ?x
14:27:04 <lambdabot> Top level:
14:27:04 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
14:27:04 <lambdabot>       Expected type: t -> t1
14:27:11 <kmc> :t ?f (?f ?x)
14:27:12 <lambdabot> forall t. (?x::t, ?f::t -> t) => t
14:27:34 <parcs> :t ?f ?f
14:27:35 <lambdabot> Top level:
14:27:35 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
14:27:35 <lambdabot>       Expected type: t -> t1
14:27:39 <shachaf> > let ?x = (:[]); ?y = 5 in ?x (?x ?y)
14:27:40 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
14:27:43 <kmc> :t show (fix ?f)
14:27:43 <lambdabot> forall a. (?f::a -> a, Show a) => String
14:27:46 <shachaf> Grr.
14:28:08 <Saizan> > let ?x a = (:[]) a; ?y = 5 in ?x (?x ?y)
14:28:09 <lambdabot>   <no location info>: Parse error in pattern
14:28:35 <kmc> shachaf, and i don't actually hate type classes.  it is possible for something to be good and yet overused or overrated
14:29:40 <shachaf> > let ?x = (:[]); ?y = 5 in (?x (?x ?y)) :: forall l b. (?x :: forall a. a -> l a, ?y :: b) => l (l b)
14:29:40 <lambdabot>   <no location info>: parse error on input `forall'
14:30:19 <parcs> :t undefined :: Read a => Show a => a
14:30:19 <lambdabot> forall a. (Show a, Read a) => a
14:30:28 <Saizan> > let ?x :: a -> [a]; ?x = (:[]); ?y = 5 in (?x (?x ?y))
14:30:29 <lambdabot>   <no location info>: Invalid type signature
14:30:42 <parcs> didn't expect that to work
14:31:08 <shachaf> > let ?x = (:[]); ?y = 5 in (?x (?x ?y)) :: forall l b. (?x :: (forall a. a -> l a), ?y :: b) => l (l b)
14:31:09 <lambdabot>   Illegal polymorphic or qualified type: forall a. a -> l a
14:31:55 <Saizan> shachaf: a type signature in that position refers to the whole let, btw
14:32:12 <shachaf> Oh, right.
14:32:14 <Saizan> not that it'd work otherwise, i think
14:32:23 <ido> :t par
14:32:24 <lambdabot> forall a b. a -> b -> b
14:32:27 <shachaf> Why not?
14:32:33 <ido> :t not
14:32:33 <lambdabot> Bool -> Bool
14:32:38 <hpc> > 4 par 3
14:32:39 <lambdabot>   4
14:32:43 <hpc> > par 4 3
14:32:44 <lambdabot>   3
14:32:48 <hpc> aha!
14:33:07 <Saizan> we can try
14:33:21 <Saizan> > let ?x = (:[]); ?y = 5 in (?x (?x ?y) :: forall l b. (?x :: (forall a. a -> l a), ?y :: b) => l (l b))
14:33:21 <lambdabot>   Illegal polymorphic or qualified type: forall a. a -> l a
14:35:06 <shachaf> What's illegal about that?
14:35:51 <parcs> @vixen what's illegal about that?
14:35:52 <lambdabot> i dunno, what about?
14:36:23 <dolio> @type ?id
14:36:24 <lambdabot> forall t. (?id::t) => t
14:36:47 <dolio> @type ?id :: (?id :: forall a. a -> a) => forall a. a -> a
14:36:48 <lambdabot> parse error on input `forall'
14:37:04 <dolio> @type ?id :: (?id :: (forall a. a -> a)) => forall a. a -> a
14:37:05 <lambdabot>     Illegal polymorphic or qualified type: forall a. a -> a
14:37:05 <lambdabot>     In an expression type signature:
14:37:05 <lambdabot>       (?id :: forall a. a -> a) => forall a. a -> a
14:37:37 <shachaf> "An implicit-parameter binding group must be a collection of simple bindings to implicit-style variables (no function-style bindings, and no type signatures); these bindings are neither polymorphic or recursive."
14:38:09 <shachaf> > let ?x = 1 : ?x in ?x
14:38:10 <lambdabot>   mueval-core: internal error: PAP object entered!
14:38:10 <lambdabot>      (GHC version 6.12.3 f...
14:38:15 <dolio> I guess that's your answer.
14:38:28 <shachaf> Pft. Useless feature.
14:38:37 <shachaf> Might as well use Reader.
14:38:42 <hpc> it's not even a feature; it's a bug-factory
14:38:49 <hpc> dynamic scope ftl
14:39:40 <shachaf> Even statically-checked dynamic scope?
14:40:07 <Tomsik> Tell that to TH
14:41:39 <dolio> > let ?x = 4 in (let ?x = 5 in \y -> ?x) 7
14:41:40 <lambdabot>   5
14:42:26 <dolio> > let ?x = 4 in ((let ?x = 5 in \y -> ?x) :: (?x :: Int) => Int) 7
14:42:27 <lambdabot>   The lambda expression `\ y -> ?x' has one argument,
14:42:27 <lambdabot>  but its type `GHC.Type...
14:42:38 <ryan2015> product [1..20]
14:42:38 <dolio> > let ?x = 4 in ((let ?x = 5 in \y -> ?x) :: (?x :: Int) => Int -> Int) 7
14:42:39 <lambdabot>   5
14:43:08 <dolio> @type (\_ -> 5) :: (?x :: Int) => Int -> Int
14:43:09 <lambdabot> (?x::Int) => Int -> Int
14:47:29 <parcs> :t undefined :: (?x ~ ?y) => a
14:47:30 <lambdabot> parse error on input `~'
14:50:18 <JuanDaugherty> is anything interesting supposed to be happening in hp 2011.4.0.0 ?
14:50:21 <kmc> :t undefined :: (?x :: a, ?y :: b, a ~ b) => Int
14:50:21 <lambdabot> forall a. (?y::a, ?x::a) => Int
14:50:32 <kmc> oh, it even reduces the types
14:50:35 <kmc> how nice
15:01:57 <d7> I want to measure the rate at which a forM_ is tearing through several million iterations
15:02:12 <d7> Has someone already written this code? Is there a well known library?
15:04:14 <kmc> criterion
15:05:03 <d7> kmc: Can it do it in real time?
15:05:13 <kmc> maybe not
15:18:39 <glguy> edwardk: What was the goal of using "improve" in your free monad series of blog posts? In the end it seems like it is easier in general to just use the "newtype F" continuation-passing style free monad directly
15:19:01 <glguy> you ended up with an easier to define interpreter, no typeclass indirection, and an efficient compiled version
15:19:08 <edwardk> glguy: i agree
15:19:21 <edwardk> the improve combinator was just to show that you can do exactly what janis did
15:19:33 <edwardk> on the other hand, if you need to interpret 'multiple levels deep' then improve is still nice
15:19:47 <edwardk> its harder to do deep case analysis with the F combinato
15:19:52 <edwardk> er combinator
15:19:55 <glguy> but improve is only useful if you want to look at the result as "Wrap" and "Pure" constuctors, right?
15:20:41 <glguy> ahh, deep case analysis as in if you wanted to notice that someone did two operations in a row and optimze that at interpretation time?
15:20:43 <edwardk> yes.
15:21:35 <glguy> even still you wouldn't want to use the type-class in that case
15:21:55 <glguy> instead of a separate improve function you could run the computation in F with Pure and Wrap as the continuations
15:22:02 <edwardk> sure
15:22:04 <glguy> and then write your interpreter
15:22:06 <glguy> OK
15:22:12 <glguy> then it sounds like we're on the same page
15:22:23 <glguy> I wondered if there were more benefits that I'd overlooked
15:22:52 <edwardk> the use of improve is mostly where you alternate between building and inspecting
15:23:04 <edwardk> rather than have one single interpreter block
15:24:35 <glguy> I've used a technique similar to this on a non-trivial program, but it used a heavier mechanism to achieve this same result, so I've been really interested in the details
15:25:11 <edwardk> btw- today's post on free modules uses something similar
15:26:40 <glguy> Do you have a URL handy?
15:27:17 <glguy> http://comonad.com/reader/2011/free-modules-and-functional-linear-functionals/
15:27:39 <glguy> I don't have your hostname memorized, but I did have it in history :)
15:27:49 <ddarius> planet.haskell.org
15:28:33 <glguy> edwardk: Do you have a reference somewhere that lists your various abstraction libraries, and which ones are deprecated and so on?
15:32:19 * hackagebot monadcryptorandom 0.4 - A monad for using CryptoRandomGen  http://hackage.haskell.org/package/monadcryptorandom-0.4 (ThomasDuBuisson)
15:37:50 <roconnor> edwardk: when the formatting of your blog chops off some of your text it drives me crazy :)
15:38:17 <roconnor> but then we'd have trouble dealing with the Natural and Integer constraints above, so instead we lift modules
15:38:38 <roconnor> everything after Integer is cut off on my browser
15:38:56 <roconnor> maybe my browser is to blame though.
15:40:51 <benmachine> roconnor: I think it's because that bit is formatted as code
15:41:00 <benmachine> or at least, I only noticed code being cut off
15:41:11 <benmachine> (it shouldn't be formatted as code, but it appears to be)
15:41:12 <roconnor> oh right
15:41:26 <roconnor> that expains why *then* is highlighted
15:41:37 <benmachine> yes :P
15:41:38 <roconnor> edwardk: when the formatting of your blog chops off some of your code it drives me crazy :)
15:41:52 <benmachine> heh, agreed
15:42:05 <edwardk> roconnor: which code? i'll go fix it
15:42:18 <roconnor> edwardk: I'll start making notes
15:42:27 <roconnor> when I see it
15:42:53 <Tomsik> @pl let f l = case l of { [] -> [] ; x:y:l' -> (x,y):f l'}
15:42:53 <lambdabot> (line 1, column 21):
15:42:53 <lambdabot> unexpected "{"
15:42:53 <lambdabot> expecting variable, "(", operator, ";" or "in"
15:42:54 <roconnor> but ideally you could somehow redesign the CSS so that when the code overflows it appears above the sidebar
15:42:58 <edwardk> roconnor: thanks. that post was abandoned and not finished if you know what i mean =)
15:43:04 <roconnor> granted this may be easier said than done.
15:43:09 <Tomsik> @pl let f l = case l of { [] -> [] ; x:y:l' -> (x,y):f l'} in f
15:43:09 <lambdabot> (line 1, column 21):
15:43:09 <lambdabot> unexpected "{"
15:43:09 <lambdabot> expecting variable, "(", operator, ";" or "in"
15:43:24 <edwardk> roconnor: yeah easier said. my desire to waste time messing with css is pretty low ;)
15:43:25 <Tomsik> Why does it not work here?
15:43:42 <Tomsik> @pl \l -> case l of { [] -> [] ; x:y:l' -> (x,y):f l'}
15:43:42 <lambdabot> (line 1, column 17):
15:43:42 <lambdabot> unexpected "{"
15:43:42 <lambdabot> expecting variable, "(", operator or end of input
15:43:55 <Tomsik> Silly lambdabot
15:44:03 <edwardk>  pl doesn't really do case analysis
15:44:23 <Tomsik> Eh, I just don't know how to pair numbers I guess
15:46:59 <ddarius> CSS isn't too bad if you don't care about browser portability.
15:47:12 <edwardk> i tweaked the module comment in there
15:47:50 <ddarius> I really, really, really wish RDL had just taken CSS's box model.
15:48:13 <aavogt> > fix (\f l -> case l of [] -> []; x:y:tl -> (x,y): f tl) [1,2,3,4]
15:48:14 <lambdabot>   [(1,2),(3,4)]
15:49:30 <edwardk> my biggest annoyance about writing blog posts is wresting with the formatting. clearly i need a copy editor ;)
15:49:32 <aavogt> @pl let f l@ ~(x:y:tl)= if null l then [] else (x,y):f tl in f
15:49:33 <lambdabot> (line 1, column 8):
15:49:33 <lambdabot> unexpected "@"
15:49:33 <lambdabot> expecting pattern or "="
15:49:51 <aavogt> @pl let f (x:y:tl)= if null l then [] else (x,y):f tl in f
15:49:51 <lambdabot> fix ((`ap` tail) . (. head) . flip flip tail . (ap .) . flip flip head . (((.) . ((if' (null l) [] .) .)) .) . flip (flip . (((.) . (:)) .) . (,)))
15:50:31 <aavogt> @pl let f l = let x:y:tl = l in if null l then [] else (x,y):f tl in f
15:50:32 <lambdabot> (line 1, column 16):
15:50:32 <lambdabot> unexpected ":"
15:50:32 <lambdabot> expecting letter or digit, pattern or "="
15:50:46 <ddarius> edwardk: Use TeX because one never wrestles with the formatting with TeX.
15:52:08 <Tomsik> I guess this does its work: \lst -> filter (odd . fst) $ zip [1..] lst
15:52:18 <Tomsik> and then for evens
15:54:02 <aavogt> @ty mapMaybe (\(b,x) -> guard b >> Just x) . zip (repeat [True,False])
15:54:02 <ddarius> filter (odd . fst) . zip [1..]
15:54:03 <lambdabot>     Couldn't match expected type `Bool' against inferred type `[a]'
15:54:03 <lambdabot>     In the first argument of `repeat', namely `[True, False]'
15:54:03 <lambdabot>     In the first argument of `zip', namely `(repeat [True, False])'
15:54:28 <aavogt> @ty mapMaybe (\(b,x) -> guard b >> Just x) . zip (cycle [True,False])
15:54:29 <lambdabot> forall t. [t] -> [t]
15:54:36 <aavogt> @pl mapMaybe (\(b,x) -> guard b >> Just x) . zip (cycle [True,False])
15:54:36 <lambdabot> mapMaybe (uncurry ((. Just) . (>>) . guard)) . zip (cycle [True, False])
16:03:35 <Tomsik> \lst -> (map snd *** map snd) <<< filter (odd . fst) &&& filter (even . fst) $ zip [1..] lst
16:03:56 <Tomsik> Is there some arrow magician that can say if it can be done better? (with less repetition that is)
16:04:09 <aavogt> @ty \lst -> (map snd *** map snd) <<< filter (odd . fst) &&& filter (even . fst) $ zip [1..] lst
16:04:10 <lambdabot> forall b. [b] -> ([b], [b])
16:04:19 <aavogt> @ty partitionEithers
16:04:20 <lambdabot> forall a b. [Either a b] -> ([a], [b])
16:05:02 <aavogt> @ty zipWith ($) (cycle [Left,Right])
16:05:02 * ddarius spent a whole lot of money this month.
16:05:03 <lambdabot> forall b. [b] -> [Either b b]
16:05:16 <aavogt> @ty partitionEithers . zipWith ($) (cycle [Left,Right])
16:05:17 <lambdabot> forall b. [b] -> ([b], [b])
16:05:34 <Tomsik> darn you :)
16:06:34 * hackagebot GenericPretty 0.1.3 - A generic, derivable, haskell pretty printer.  http://hackage.haskell.org/package/GenericPretty-0.1.3 (RazvanRanca)
16:15:31 <Tomsik> :t bimap
16:15:32 <lambdabot> Not in scope: `bimap'
16:18:37 * hackagebot happstack-hstringtemplate 6.0.1 - Support for using HStringTemplate in Happstack  http://hackage.haskell.org/package/happstack-hstringtemplate-6.0.1 (JeremyShaw)
16:21:38 * hackagebot happstack-hamlet 6.1.0 - Support for Hamlet HTML templates in Happstack  http://hackage.haskell.org/package/happstack-hamlet-6.1.0 (JeremyShaw)
16:30:49 <msieradzki> does Network.Socket allow making non-blocking socket (for UDP)?
16:31:47 <kmc> we generally use lightweight threads + GHC's sexy IO manager instead of nonblocking or explicit async IO
16:31:50 <kmc> what are you trying to do?
16:31:55 <mm_freak> msieradzki: usually in haskell you don't concern yourself with blocking…  it's handled by the RTS and lightweight threads
16:32:39 * hackagebot happstack-heist 6.0.2 - Support for using Heist templates in Happstack  http://hackage.haskell.org/package/happstack-heist-6.0.2 (JeremyShaw)
16:33:08 <msieradzki> I just googled the question and answer and I'll make separate UDP recv/send thread I guess
16:33:13 <msieradzki> http://groups.google.com/group/haskell-cafe/browse_thread/thread/6aa6a8103b7b6ae6
16:33:39 * hackagebot happstack 6.0.1 - The haskell application server stack + code generation  http://hackage.haskell.org/package/happstack-6.0.1 (JeremyShaw)
16:33:47 <msieradzki> I'm trying to write main game loop that does: receive, update state, send and I don't want my main loop blocked if no packets are received :)
16:34:11 <msieradzki> but as this thread says I'll just have to do with communicating with seprate thread that will use blocking UDP recv
16:34:22 <kmc> yeah
16:34:26 <kmc> it's not the most elegant solution here
16:34:35 <kmc> in general though, i prefer threads and blocking IO
16:35:08 <kmc> maybe you should break the rest of the game loop into threads
16:35:22 <ddarius> It's trivial to build a future that will give you a nice non-blocking interface on top of GHC's provided primitives.
16:35:23 <kmc> one which is forever (updateState >> threadDelay n)
16:35:50 <kmc> as packets are received another thread writes to the states read by updateState
16:35:59 <kmc> asynchronously
16:36:00 <kmc> possibly using STM to keep everything consistent
16:36:08 <mm_freak> msieradzki: threads are definitely the way to do it in haskell, and you should link with the threaded RTS (-threaded option to GHC), if you want the threads to run somewhat smoothly
16:36:20 <kmc> updateState sends packets directly or sends them down a Chan to a dedicated sender thread
16:36:23 <kmc> i think with UDP it won't matter
16:36:46 <mm_freak> btw
16:36:54 <kmc> it's rare that you actually want to poll for incoming packets in a loop.  usually that's an approximation of something event-based
16:37:15 <msieradzki> what's the relation between ghci and -threaded?
16:37:20 <mm_freak> HDBC-postgresql ignores exceptions in some of its functions, which is very unfortunate
16:37:21 <ddarius> Simpler is just run the game thread each "tick" and have the separate thread write to a MVar (or even IORef) that is read by the game loop and presents that state (in parameters) to the body of the loop.
16:37:41 * hackagebot happstack-plugins 6.0.1 - The haskell application server stack + reload  http://hackage.haskell.org/package/happstack-plugins-6.0.1 (JeremyShaw)
16:37:47 <mm_freak> because it also ignores ThreadKilled
16:38:01 <kmc> mm_freak, ouch.
16:38:02 <msieradzki> ddarius, yep I had something similar with small program I wrote with TCP and haskell
16:38:16 <ddarius> Essentially turning the event MessageReceived into the behavior StateFromNetwork.
16:38:43 <mm_freak> unless you have real time needs, i would keep the game state in a set of TVars
16:39:07 * ddarius would keep the game state in parameters if possible.
16:39:45 <mm_freak> ddarius: if the state is mostly modified by a single thread, that's fine
16:39:47 <kmc> msieradzki, for a MMO i would have one thread per player, all modifying the same state via STM but without explicit synchronization
16:39:49 <msieradzki> depends on what you call state, tbh I'm not sure how it'll be defined exactly in the end
16:40:02 <kmc> and another thread for the game world, or even for each "object" / NPC / whatever
16:40:19 <mm_freak> msieradzki: the game state is the state of the game's world
16:40:23 <msieradzki> duh
16:40:25 <mm_freak> whatever that is for the particular game
16:40:45 <msieradzki> well the thing is that I'm trying to rewrite something that was written in C++ and was huge (in parts atm)
16:40:51 <kmc> there's no "game loop", the game loop is inside the GHC RTS's IO manager
16:40:56 <msieradzki> it has entities which have mutable state (in C++ version)
16:41:11 <msieradzki> and there's 1 big BSP-tree which used locked on every op
16:41:23 <msieradzki> which is*
16:41:24 <kmc> sure, TVars are mutable state with clean concurrency semantics
16:41:32 <kmc> and GHC's STM implementation is lockless and optimistic
16:41:33 <wli> Loops are innately polling; in principle, event-driven asynchronous affairs should be the way to go.
16:41:47 <kmc> plus you don't need locks on persistent data structures
16:42:03 <msieradzki> kmc pushing your example to extreme how does one write STM-based BSP-tree?
16:42:17 <kmc> create an immutable tree and stuff it in a TVar.  read-only users won't need a lock or even cause a STM retry
16:42:30 <kmc> writers create a new immutable tree and stuff it in
16:42:39 <kmc> but the tree is immutable so it can share memory with most of the old tree
16:42:49 <kmc> how frequently is the BSP tree changed?
16:42:55 <wli> (Higher-order etc. languages are well-suited to asynchronous event-driven affairs.)
16:43:02 <kmc> locking can perform better than optimistic + retry under high contention
16:43:14 <kmc> but either way you get the benefits of persistent data structures
16:43:15 <msieradzki> very often, old C++ game doesn't even try to run several threads at once with game state update
16:43:16 <kmc> on the reader side
16:43:26 <kmc> right
16:43:39 <msieradzki> bsp tree writer can some time be left inside there and fighting for it with several readers
16:43:55 <msieradzki> particle effect threads checking for collision with objects for instance, they don't modify anything
16:44:02 <kmc> if you're porting a game from C++ you should upgrade it to use better than 1970's language / concurrency technology
16:44:11 <ddarius> The imposition of "game time" often curtails events being completely asynchronous.
16:44:12 <kmc> :)
16:44:15 <wli> Depends, there are busywait-free affairs where the readers tolerate stale data.
16:44:28 <msieradzki> I know and that's a lot of headache to rethink every single design decision on C++ side again
16:44:30 <kmc> wli, like RCU?
16:44:36 <kmc> msieradzki, yeah. :/
16:44:44 <kmc> but the result will be vastly more pleasant to think about once you're done
16:44:53 <kmc> STM is so nice... you just say what needs to be atomic and it magically is
16:45:07 <wli> kmc: That's one of them, but there are many more (that I know less about). RCU is probably not well-suited to userspace applications like video games.
16:45:26 <kmc> why not? it's harder to have control over quiescent states?
16:45:43 <wli> kmc: Yeah, that's one of the reasons.
16:46:07 <ddarius> The issue I was referring to was not a matter of choosing a better implementation mechanism.
16:47:55 <dAnjou> hi, is it possible to manipulate the sort function of Data.Map?
16:48:22 <kmc> dAnjou, yes.  define a new type for your data and write your own Ord instance for it
16:48:54 <kmc> data Foo = MkFoo Int; instance Ord Foo where ...
16:49:10 <kmc> we often use 'newtype' instead of 'data' but for these purposes that's just an optimization
16:51:26 <dAnjou> k, thanks
16:52:23 * wli never uses newtype. Optimization at that level is just not the sort of thing I do.
16:52:31 <deech> Hi all, I have the following program:{-# LANGUAGE TypeFamilies, DeriveDataTypeable #-} \
16:52:31 <deech>       data Test = Test deriving (Show,Typeable). And I get the error "    Not in scope: type constructor or class `Typeable'". I am currently running GHC 7.0.1. Is there something I'm doing wrong?
16:52:31 <wli> Not in Haskell, anyway.
16:53:13 <kmc> well, it's not in scope
16:53:15 <kmc> you have to import it
16:53:32 <siracusa> deech: I think you need to import Data.Typeable or Data.Data.Typeable
16:54:56 <deech> kmc, siracusa: That worked. I remember this working with just the pragma, did something change in 7.0.1 or did I dream that.
16:55:07 <kmc> i'm fairly sure it did not work in 6.12
16:55:18 <ddarius> There is a semantic difference between newtype, data, and strict data.  Furthermore, treating the difference between newtype/strict data and (lazy) data as "just an optimization" leads to silliness.
16:55:19 <kmc> you may have had Typeable in scope through some other import
16:55:35 <deech> kmc: I see. Thanks for your help!
16:55:35 <siracusa> doesn't work in 6.10 either
16:55:39 <kmc> ddarius, right, hence my qualification.  I think dAnjou is probably not trying to store 'undefined' in this Map
16:56:18 <kmc> ddarius, do you think the semantic difference causes large practical problems?
16:56:49 <ddarius> kmc: Between newtype and strict data, not really.  Between newtype/strict data and lazy data, yes.
16:57:24 <dAnjou> kmc: i don't
16:58:50 <cmccann> pop quiz: what's the practical difference between "data D = D D" and "newtype N = N N"?
16:59:12 * cmccann is not asking ddarius btw
16:59:14 <ezyang> the latter doesn't typecheck...
16:59:24 <ezyang> or pass the compiler. whatever.
16:59:31 <ddarius> ezyang: Yes it does.
16:59:38 <ezyang> Oh, really? Fascinating.
16:59:55 <cmccann> ezyang, and what happens if you pattern match on it? :]
17:00:02 <ezyang> well, it's only inhabited by bottom
17:00:15 <ezyang> whereas the former is inhabited by undefined, D undefined, etc
17:00:19 <kmc> pattern-matching on a newtype's constructor has no operational consequences
17:00:21 <cmccann> so what does (\N n -> n) do?
17:00:31 <kmc> that's the difference between newtype and strict data
17:00:52 <ezyang> ...huh.
17:00:58 <aavogt> cmccann: it's illegal
17:01:06 <cmccann> er, (\(N n) -> n) rather
17:01:07 <ddarius> + parentheses
17:01:19 <cmccann> yeah, typing faster than I'm thinking here :P
17:01:32 <derrida> Is it possible to (re)define functions from the ghci repl?
17:01:54 <aavogt>  let head [] = error "never works derrida"
17:02:08 <kmc> data SD = SD !Int; main = print (case undefined `seq` (SD 0) of SD x -> ())
17:02:10 <kmc> errors
17:02:13 <aavogt> if you type that, you've redefined it for the ghci session
17:02:23 <kmc> newtype NT = NT Int; main = print (case undefined `seq` (NT 0) of NT x -> ())
17:02:24 <cmccann> > let 1 + 1 = 3 in 1 + 1
17:02:24 <kmc> does not
17:02:25 <lambdabot>   3
17:02:48 <ddarius> derrida: You can shadow them.  You can't redefine existing uses though.
17:03:19 <derrida> aavogt: neat, i see.
17:03:25 <ddarius> If you -really- wanted to you could probably get away with declaring an IORef and unsafePerformIOing that reference, then you could redefine the function by updating the reference.
17:03:27 <derrida> ddarius: cool, that was my mistake
17:04:40 <ddarius> You could make a set of :-commands to make these redefinable definitions.
17:05:03 <ddarius> (And also keep track of an environment and do other nice stuff for you.)
17:05:55 <ezyang> Huh. How do exceptions and continuations work :-/
17:06:21 <c_wraith> exceptionally and continually, respectively
17:08:42 <dobblego> hi, what is the name (google search term) for a handicap system whereby there is a 2-player game which may score first to N, a set of players and each player has a handicap (starting score) which is adjusted according to match results?
17:13:43 <ddarius> 7,8-didehydro-4,5-epoxy-3-methoxy-17-methylmorphanin-6-ol
17:34:58 <ocharles> Is there anyway to write (\credits -> book { bookCredits = credits }) pointfree?
17:35:25 <adrake> @pl \credits -> book { bookCredits = credits }
17:35:25 <lambdabot> (line 1, column 18):
17:35:25 <lambdabot> unexpected "{"
17:35:25 <lambdabot> expecting variable, "(", operator or end of input
17:35:36 <aavogt> no
17:35:46 <kmc> no ocharles
17:35:53 <kmc> but look at the fclabels library
17:35:58 <ocharles> shame, but thought not
17:36:07 * ocharles checks that out
17:36:33 <ivanm> there is at least one other alternative to fclabels, but I don't remember the name
17:36:39 <kmc> lenses and data-accessor
17:36:45 <aavogt> and many more
17:36:53 <ivanm> that's the two I was thinking of
17:38:16 <aavogt> http://hackage.haskell.org/package/records
17:38:20 <aavogt> http://hackage.haskell.org/package/HList
17:38:42 <ocharles> kmc: fclabels is certainly interesting
17:38:59 <aavogt> http://hackage.haskell.org/package/has
17:39:00 <ocharles> this setL thing looking just like what I'm tyring to express here
17:40:38 <ocharles> I assume it's possible to import a function with a different name? I don't really want to have to hide Prelude's (.)
17:40:51 <ivanm> you can do a qualified import...
17:41:16 <ivanm> import qualified Data.Foo as Foo
17:41:55 <ocharles> right, but then I'd lose the niceness of the infix operator, and would have to put `` around it, right?
17:42:01 <ivanm> nope
17:42:10 <ivanm> import qualified Data.Map as M
17:42:21 <ivanm> then you can do "myMap M.! myValue"
17:42:29 <ocharles> Right, but this operator is .
17:42:38 <ivanm> ocharles: Foo..
17:42:44 <ocharles> C.. looks weird, and is bound to cause headaches
17:42:45 <mauke> > M.fromList [("a", 1), ("b", 2), ("c", 3)] M.! "b"
17:42:46 <lambdabot>   2
17:42:48 <ivanm> which, admittedly, looks wrong
17:43:01 <ivanm> ocharles: is this the Data.Category one?
17:43:03 <mauke> > sqrt Prelude.. abs Prelude.$ 42
17:43:04 <lambdabot>   Not in scope: `Prelude..'
17:43:07 <ddarius> > [False..]
17:43:08 <lambdabot>   <no location info>: parse error on input `]'
17:43:10 <ddarius> > [False ..]
17:43:10 <lambdabot>   [False,True]
17:43:18 <ocharles> Yea
17:43:18 <mauke> > sqrt P.. abs P.$ 42
17:43:19 <lambdabot>   6.48074069840786
17:43:30 <ivanm> if so, can't you use use it as prelude's (.) ?
17:45:05 <ocharles> i dunno, fclabels says to hide that
17:45:26 <ocharles> (haven't tried anything yet, just reading docs)
17:45:30 <mauke> er, so hide it?
17:45:35 <mauke> what's the problem?
17:46:13 <ocharles> won't that stop me doing normal function composition elsewhere?
17:46:24 <ivanm> I don't think so
17:46:28 <ivanm> @hoogle (.)
17:46:29 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
17:46:29 <lambdabot> Control.Category (.) :: Category cat => cat b c -> cat a b -> cat a c
17:46:29 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
17:46:42 <ivanm> @type (Control.Category..)
17:46:43 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
17:46:51 <ocharles> I figured (.) in Prelude and Category were different, for a reason
17:46:52 <ivanm> @type succ (Control.Category..) pred
17:46:52 <lambdabot> forall c a. (Enum c, Enum ((c -> c) -> (a -> c) -> a -> c)) => (a -> c) -> a -> c
17:47:02 <mauke> ocharles: yes, Category is more general
17:47:06 <ivanm> @type succ Control.Category.. pred
17:47:07 <lambdabot> forall a. (Enum a) => a -> a
17:47:14 <mauke> ocharles: see map and fmap
17:47:14 <ivanm> ocharles: ^^ you can use it as Prelude's one
17:47:26 <ocharles> ivanm: I'll take your word for that :)
17:47:29 <ocharles> mauke: ah, ok
17:47:34 <edwardk> ocharles: there is an instance of Category for (->), so the Control.Category version is strictly more general
17:47:41 <ocharles> mauke: that does make a bit of sense to me :)
17:48:09 <ocharles> edwardk: ah! you parsed that quicker than me :)
17:48:40 <ocharles> so category's (.) is for composing "things that can be composed" (I don't want the class for that is), while prelude's is just functions
17:48:54 <ocharles> like map is for lists, but fmap is for functors, or things that can be mapped over
17:49:07 <ocharles> probably a terrible explanation, but I think I get the gist of it
17:49:20 <mauke> sounds right to me
17:49:33 <edwardk> yeah
17:49:33 <edwardk> categories have arrows where arrow composition is associative (f . g) . h = f . (g . h) and you have an identity arrow id . f = f = f . id
17:50:01 <edwardk> those laws are like the laws for Functor
17:50:11 * ocharles nods
17:50:33 <edwardk> if you get rid of the 'id' laws you get a semigroupoid, and then start playing in my libraries ;)
17:50:50 <ocharles> heh
17:51:22 * ocharles looks forward to reaching this level of knowledge one day
17:51:32 <ocharles> but it's all slow and steady progress for now, so I can't argue with that
17:52:52 <ddarius> Since both pre-composition and post-composition are functors, those -are- the laws of two functors.
17:54:35 <edwardk> ddarius: good point
17:54:58 <cmccann> ahahaha
17:55:20 * cmccann writes a TH splice that finds the type expected by the context its in, then calls djinn to implement itself
17:55:34 <mauke> cmccann: has been done before, without TH
17:55:37 <edwardk> cmccann: did it work?
17:55:38 <cmccann> this is horrible on so many levels
17:55:57 <mauke> http://okmij.org/ftp/Haskell/types.html#de-typechecker
17:56:38 <ddarius> Isn't saying "It's been done before by Oleg" poor sportsmanship?
17:56:39 <cmccann> edwardk, for the very limited contexts I handled, yes, but it's a completely useless design
17:56:50 <cmccann> ddarius, no, it's a tautology
17:58:42 <cmccann> edwardk, specifically it's the "finding the expected type for the context" that's a huge hack, but it wouldn't be that painful to do it properly if I wanted to
17:59:33 <edwardk> cmccann: did you see my write-up on that linear functional stuff we were talking about yesterday?
17:59:34 <cmccann> mauke, also I think oleg's version is inherently somewhat limited compared to something like djinn
17:59:50 <cmccann> edwardk, yep, haven't had the chance to read it yet though :[
18:01:03 <edwardk> cmccann: btw- do /msgs show up for you? =)
18:01:28 <cmccann> edwardk, they do except for when they don't for some reason
18:01:32 <edwardk> hah
18:18:46 <fragamus> hey if one is using a list monad transformer, such as ListT done right, is there a way of "returning" the list as a whole
18:20:29 <mm_freak> fragamus: you mean observing the result list?
18:42:41 <shachaf> How would one express http://www.haskell.org/haskellwiki/Idiom_brackets using type families/associated types?
18:50:44 <danharaj> So I'm really stuck on a design problem.
18:52:33 <danharaj> Let's model reactive values as infinite lists. The important interfaces are Applicative, and Comonad. You can do a lot with that.
18:53:43 <danharaj> But that's pure reactive values. We can't interact with anything. We want to be able to take an (IO a) and have our reactive values depend on it.
18:53:47 <dpratt71> what's the name of the Haskell version of lint? I thought I had it here somewhere, but I can't seem to find it
18:54:23 <dpratt71> nvm
18:54:27 <danharaj> Before we have observe :: Stream a -> (a, Stream a), which extracts the current value and gives its future.
18:54:29 <dpratt71> I think I just found it
18:54:36 <mm_freak> dpratt71: hlint
18:54:37 <mm_freak> =)
18:54:58 <dpratt71> mm_freak: thanks
18:55:06 <danharaj> The first thing I do is change that signature ti observe :: Stream a -> IO (a, Stream a), so that our observation happens in the right monad. IO is actually not necessary, it could be any old monad if that's useful.
18:55:58 <danharaj> Now the naive thing to do is just have a constructor:: Source :: IO a -> Stream a, where now Stream denotes something more than just pure streams.
18:56:57 <danharaj> And then we could try to use such streams, composing them with the applicative instance, etc. But it doesn't work. Every stream that depends on a Source will execute the Source when it needs it. What we want is that the Source is executed once per observation and the result is shared for every stream in that context.
18:57:32 <danharaj> I'm not sure what to do :[
18:59:07 <ddarius> hcorba
19:00:53 <ocharles> kmc: hooked in fclabels, feels much nicer now :) thanks!
19:09:09 <fragamus> mm_freak: yes
19:10:26 <mm_freak> fragamus: depends on the transformer…  usually you'll want to have an observer function
19:10:45 <fragamus> I'm using ListT done right
19:11:01 <fragamus> can you clue me in on how to rig it
19:11:27 <mm_freak> see how LogicT does it
19:11:33 <fragamus> http://www.haskell.org/haskellwiki/ListT_done_right
19:13:19 <mm_freak> well, that one looks almost like the list monad itself, but your observer functions will have a slightly different signature
19:13:49 <fragamus> so I have to write the observer functions?
19:14:11 <mm_freak> yes, the ones you take for granted with the list monad:  head, tail, foldr, etc.
19:14:22 <mm_freak> but their signature will be slightly different
19:14:38 <mm_freak> mhead :: Monad m => ListT m a -> m (Maybe a)
19:15:09 <fragamus> pondering...
19:15:33 <mm_freak> also note that most list monad transformers don't necessarily try to resemble the classic list monad, so their names may give more clue to the nature of the monad transformer
19:15:43 <mm_freak> findFirst :: ListT m a -> m (Maybe a)
19:15:49 <mm_freak> findAll :: ListT m a -> m [a]
19:16:18 <mm_freak> they correspond to the 'run' functions for other monad transformers
19:17:20 <mm_freak> i suggest to look into the three packages logict, monadlib and contstuff for three different, (almost) unrelated ideas of how to represent ListT
19:17:38 <mm_freak> in logict you have LogicT, in the latter two you have ChoiceT
19:20:15 <fragamus> this shit is hard
19:20:37 <joe6> is there a smarter way of writing this? http://pastebin.com/T3MTvWjE
19:20:39 <mauke> The paste T3MTvWjE has been copied to http://hpaste.org/48963
19:22:10 <mm_freak> joe6: use a field function, if there is one
19:23:39 <joe6> ok, thanks.
19:25:05 <mm_freak> fragamus: it's not really hard…  try to understand MaybeT first
19:25:14 <mm_freak> ListT is really a MaybeT generalized to allow more than one solution
19:25:39 <mm_freak> (a "solution" being a list element in list monad terms)
19:26:51 <mm_freak> the only thing you should keep in mind is that with MaybeT and ListT you don't necessarily have a concrete representation of elements in memory anymore
19:42:02 <hpaste> aavogt pasted “idiom brackets done right (TF)” at http://hpaste.org/48964
19:42:21 <aavogt> shachaf: ^^
19:42:41 <aavogt> there may be a cleaner way that I did
20:11:00 * edwardk waves hello.
20:11:24 <dobblego> omg it's edwardk!!
20:11:48 <edwardk> zomg its a dobblego doing a copumpkin impersonation! ;)
20:13:13 <dobblego> omg edwardk said my name omg omg
20:13:43 * cmccann wishes it was possible to use an iphone as a phone without covering the screen with ear smudges :[
20:18:35 <luite_> cmccann: maybe you can buy ear covers for that. other people must have the same problem, so they're probably available in multiple colors, and with apple logo's!
20:18:55 <edwardk> cmccann: heh. that is what the headphones are for ;)
20:19:23 <cmccann> yeah headphones are probably a good idea
20:19:28 <luite_> hehe
20:19:33 <luite_> hmm
20:19:52 <luite_> do people really use headphones because of smudges?
20:20:26 <cmccann> I figure having your hands free is probably the bigger benefit
20:20:36 <cmccann> since you can put the phone in a pocket or something
20:21:44 <luite_> dunno, that's good while driving... but otherwise it just looks stupid :p
20:22:28 <luite_> admittedly working on a computer while holding a phone is not ideal :)
20:22:38 <cmccann> gotta get the super tiny bluetooth thingies so you can look like a crazy person walking around talking to yourself
20:23:39 <edwardk> yeah. i basically spent the last hour or so talking on the phone wandering through playgrounds and neighborhoods pontificating like a homeless man with earbuds
20:23:55 <luite_> cmccann: but buy a white one, otherwise people don't know that you have an iphone
20:25:09 <cmccann> luite_, good point, that's like half the point I think?
20:26:45 <luite_> I'm horribly uncool with my old nokia... and pretending to use my ipad for calling probably wouldn't help either
20:27:09 <cmccann> luite_, no, it's an apple product, you'll automatically look cool
20:27:12 <cmccann> pretty sure that's how it works
20:27:34 <cmccann> hm so anyway
20:27:37 <hpaste> “C. McCann” pasted “TH nonsense” at http://hpaste.org/48965
20:28:01 <cmccann> I'm trying to decide if it's worth making that actually work sensibly
20:29:43 <edwardk> well
20:29:56 <edwardk> if you take it a step farther and made it $(hole 1) $(hole 2)
20:29:58 <cmccann> on one hand it's a gimmick but on the other hand I can imagine extending the concept in ways that might actually be worthwhile, rather than just cases where it saves twenty keystrokes at the expense of lots of nonsense
20:30:20 <edwardk> and had it print out the types for the holes using IO during compilation it could be a gateway towards getting agda-style holes into haskell
20:31:22 <cmccann> yeah, that's what I was considering
20:31:40 <cmccann> since invoking djinn to write monad instances isn't too persuasive on its own
20:31:43 <edwardk> i'm pretty sure that copumpkin might consider offering you sexual favors for that functionality
20:31:54 <cmccann> haha
20:32:08 <cmccann> it's kind of scary how much you can actual do behind the scenes in TH splices
20:32:54 <edwardk> another nice step would be if you can't figure out the hole being able to emit all of the types in scope at that point
20:34:25 <cmccann> my rough plan was to have a $magic splice to fill in holes, some variation to fill in a hole under some constraints in how the types are used, and a handwave that doesn't fill holes and just splices in undefined with an compile-time warning of "unfilled hole at line X, column Y, with expected type from context of T"
20:35:12 <cmccann> I have another pile of scary hacks from some other experiment that I could clean up as well that might let me get most of that working cleanly
20:35:16 <cmccann> for certain definitions of clean
20:35:31 <smop> should i not be using powershell to run my haskell dodads
20:35:33 <dolio> I think if you want sexual favors, you're going to have to make it work like Agda.
20:35:42 <dolio> Not some TH hack.
20:36:38 <cmccann> dolio, how about a TH hack that quasiquotes agda, type checks it, then converts the agda AST to TH's Haskell AST
20:37:08 <dolio> That doesn't sound like the same thing at all.
20:37:12 <cmccann> hahahaha
20:38:10 <dolio> For instance, having $magic sprinkled in my code is no good.
20:38:53 <dolio> Nor is some preprogrammed, "if djinn can figure it out then do that else dump some crap to stdout."
20:39:14 <aavogt> @google ghc goals
20:39:15 <lambdabot> http://stepforum.bethany.org/viewtopic.php?f=20&t=8393
20:39:16 <lambdabot> Title: Stepping Stones - View topic - GHC goals
20:39:16 <cmccann> dolio, yeah, that's kind of why I'm dubious that it would ever be all that useful
20:39:39 <dolio> I mean, the $magic thing would be amusing.
20:40:03 <aavogt> cmccann: might this be helpful https://github.com/sebastiaanvisser/ghc-goals ?
20:40:33 <cmccann> aavogt, I think you gave me that link a couple months ago, when I was messing with the GHC API :]
20:41:31 <cmccann> dolio, I suspect the main value would be that TH makes for a cheap way to hook into the compilation process, as a testing ground for something like ghc-goals
20:41:44 <aavogt> it is possible to call ghc from TH splices
20:41:50 <cmccann> but that would need to be a lot less hackish than just calling djinn and hoping for the best
20:43:16 <cmccann> aavogt, the same GHC that's compiling the module? Or do you just mean invoking another GHC, because that's simple enough
20:44:18 <edwardk> dolio: mostly what i'd want is to have it emit line numbered warnings that were in the format vim takes back in as errors consisting of what the code is for each hole that it figured out, and what the types are where it couldn't.
20:44:24 <aavogt> a new ghc
20:44:28 <edwardk> then you can bolt nice editor support on top
20:45:28 <cmccann> aavogt, 'k. in the hack I currently have I'm using TH's facilities to get at GHC's type checking, but yeah the obvious next step to do something more useful would probably be that approach
20:46:17 <luite_> hmm, what exactly are you trying to do? I'm not familiar with agda
20:46:21 <aavogt> I guess the problem with calling another ghc is you might get some flags wrong
20:46:40 <cmccann> luite_, have you ever used undefined as a placeholder when working on something, then filled it in later?
20:47:01 <luite_> yeah
20:47:06 <luite_> so you infer the type of that placeholder?
20:47:13 <edwardk> luite: in agda, you can leave 'holes' in your source code and then start working with it, each one is left as an open typechecking probem. at the site of each hole you can get the types that are in scope and what the goal type is, and you can ask agda to do things like expand a pattern match or try to figure it out from the types in scope
20:47:15 <cmccann> luite_, imagine doing that except it tells you the expected type of the placeholder
20:47:43 <jmcarthur> and various tools for refining the hole
20:48:12 <luite_> ooh that's great, I already wanted something like that for my web-based haskell editor (which already uses the ghc api for a lot of things)
20:48:50 <edwardk> my current hack is to just turn on {-# LANGUAGE ImplicitParams #-} and use ?wtf foo bar baz to get the types for foo bar baz and the hole in which ?wtf finds itself ;)
20:49:06 <cmccann> luite_, yeah, everyone wants something like that even if they don't realize it yet :]
20:49:08 <edwardk> but that isn't nearly as useful as the hole approach
20:53:58 <cmccann> right now I can have it spit out the expected type and such for the splice locations easily enough, but the way I'm finding those contexts is limited and not viable except as a cheap hack to see if it works at all
20:56:38 <luite_> by the way, I've run into this problem: the user enters an expression   expr :: Output a => a,    and I want to evaluate     output expr :: MyOutput     but this goes wrong if expr is actually polymorphic
20:56:51 <luite_> is there  a way to force ghc to choose an instance if there is one?
20:57:00 <cmccann> an arbitrary instance?
20:57:04 <luite_> yes
20:57:12 <luite_> usually there won't be more than one
20:57:36 <cmccann> well, the defaulting mechanism does that in a sense for very limited cases, but I don't recall anything generalized
20:57:53 <luite_> I already have it working by the way, but it's kind of ugly :p
20:58:15 <aavogt> @hoogle TypeCast
20:58:16 <lambdabot> No results found
20:58:33 <edwardk> i usually just write a cheap 2 character combinator or what have you to force the type
20:58:52 <cmccann> asTypeOf is nice and low-tech as well
20:58:57 <cmccann> :t asTypeOf
20:58:58 <lambdabot> forall a. a -> a -> a
20:59:06 <cmccann> @src asTypeOf
20:59:06 <lambdabot> asTypeOf = const
21:00:07 <luite_> edwardk: yeah the problem is that this is for a ghci like interface with graphics. so I'd like users to ave expressions with for example a polymorphic "Diagram backend vectorspace" type, and it should display them as long as there's an appropriate Output instance
21:01:53 <edwardk> yeah
21:01:54 <luite_> My current approach is to use the GHC API to list all instances of Output, and typecheck them one by one until one succeeds
21:02:14 <luite_> which requires some low level hackery to the AST of the expression
21:02:17 <edwardk> hence why i usually make some combinator i can slap in front like foo $ < the crap i was going to write anyways
21:02:22 <gwern> I give up. I'm not even going to bother with summaries anymore when dealing with spam on hawiki. too much effort.
21:02:32 <edwardk> where foo :: MyOutput -> MyOutput; foo = id
21:03:09 <edwardk> its annoying to do but less so than seeing nothing ;)
21:03:34 <luite_> hehe yes, that's why I did the ugly things I just mentioned :p
21:06:10 <edwardk> preflex: xseen ezyang
21:06:11 <preflex>  ezyang was last seen on freenode/#haskell 4 hours and 23 seconds ago, saying: Huh. How do exceptions and continuations work :-/
21:16:01 <cmccann> luite_, hmmm
21:16:21 <hpaste> “C. McCann” pasted “extended defaulting?” at http://hpaste.org/48966
21:16:31 <cmccann> you might be able to abuse this
21:16:33 <cmccann> if you want
21:16:50 <cmccann> depending on what you're specifically doing with the types
21:16:59 * hackagebot repa 2.1.0.1 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-2.1.0.1 (BenLippmeier)
21:17:01 * hackagebot repa-algorithms 2.1.0.1 - Algorithms using the Repa array library.  http://hackage.haskell.org/package/repa-algorithms-2.1.0.1 (BenLippmeier)
21:17:03 * hackagebot repa-bytestring 2.1.0.1 - Conversions between Repa Arrays and ByteStrings.  http://hackage.haskell.org/package/repa-bytestring-2.1.0.1 (BenLippmeier)
21:17:05 * hackagebot repa-examples 2.1.0.1 - Examples using the Repa array library.  http://hackage.haskell.org/package/repa-examples-2.1.0.1 (BenLippmeier)
21:17:59 * hackagebot repa-io 2.1.0.1 - Read and write Repa arrays in various formats.  http://hackage.haskell.org/package/repa-io-2.1.0.1 (BenLippmeier)
21:18:21 <luite_> cmccann: defaulting only works for a few types, here you just use defaulting to Int for numeric literals right?
21:18:50 <luite_> only buried deeper in your own type
21:19:07 <cmccann> luite_, in x = c1 5 == c2 5 it's defaulting both to T1
21:19:11 <cmccann> which isn't numeric
21:19:51 <cmccann> this can be observed by noting that no other instances exist, but it compiles and gives the correct result
21:19:56 <cmccann> :]
21:20:43 <cmccann> it's the same reason why some ambiguous types default to () in GHCi
21:22:44 <cmccann> as long as the ambiguous types fit the requirements for the extended defaulting rules, I think you can abuse this to get arbitrary default types to suit your purposes
21:22:49 <cmccann> but it's kinda sketchy so eh
21:23:56 <luite_> cmccann: in my impementation the ambiguous type is for example 'Backend a, VectorSpace b => Diagram a b' and I have an instance 'Diagram Cairo R2'
21:24:17 <luite_> err an instance Output (Diagram Cairo R2)
21:25:06 <cmccann> luite, hm, might work, you'd just need to stick something in to give a superfluous constraint on one of the classes that trigger extended defaulting
21:25:11 * cmccann was using Eq in the example above
21:26:09 <cmccann> I think it also only kicks in if the ambiguous type doesn't appear at all in the actual type, only subexpressions
21:26:39 <cmccann> but I think that would be enough to pick the instance, type inference should take care of the rest. maybe.
21:27:17 <cmccann> your call whether this hackishness is worse than the ugliness you currently have
21:28:40 <luite_> cmccann: let me see if I can get a simple example working
21:29:06 <cmccann> luite_, I'm not sure I should be encouraging you to do this, but what you're doing now sounded pretty painful so... :T
21:29:40 <edwardk> heh, when i'm off on one of my library building tangents, i always feel like i'm organizing a talk like this http://video.google.com/videoplay?docid=-8860158196198824415
21:29:46 <luite_> yeah it was, I have a lot of cases to check, because I have two type classes, and for everythign both a pure and an IO version
21:30:46 <luite_> and I have another OutputIO class with outputIO :: a -> IO MyOutput
21:31:34 <cmccann> luite_, I think the main limitation in your case is that it doesn't worth with MPTCs but you haven't mentioned any so far, I think
21:32:45 <luite_> Diagram renderer vectorspace?
21:33:46 <cmccann> luite_, I thought you had Diagram as a type, not a type class...
21:34:06 <luite_> oh right
21:34:10 <luite_> you mean for the output class?
21:34:24 <cmccann> for any classes needed on the ambiguous types
21:35:49 <cmccann> basically you want to force the types you want to default to be completely ambiguous (as in my example, where the type of "x" is Bool), then use GHC's extended defaulting to pick an instance for a bunch of single-parameter type classes
21:36:05 <hpaste> luite annotated “extended defaulting?” with “extended defaulting? (annotation)” at http://hpaste.org/48966#a48967
21:36:38 <luite_> that's more or less the situation I enounter, a little simplified of course :)
21:38:14 <cmccann> luite_, what's the string doing in there, should that be Cairo instead?
21:39:12 <cmccann> oh, wait, I see, nevermind
21:39:17 <luite_> cmccann: that's part of the simplification :)
21:39:56 <luite_> the image type is usually constrained by the things you do to construct it, that might restrict the underlying backend or vector space
21:41:53 <cmccann> hmm
21:43:18 <luite_> defaulting doesn't seem to work for this type... at least I can't get it to load in ghci :)
21:51:38 <mgsloan> edwardk / laute - I know of at least 3 people (including me), interested in getting holes working.  We were hoping to get something hacked together before Hac Phi
21:51:46 <mgsloan> err luite_
21:51:51 <edwardk> mgsloan: nice =)
21:52:39 <mgsloan> the trick of course is getting all the contextual information (not just the return type) and hopefully doing partial compilation
21:53:30 <cmccann> mgsloan, what kind of contextual information do you have in mind?
21:53:39 <mgsloan> I've been pointed towards flymake / ghc-mod for that, but haven't quite gotten around to it
21:54:00 <mgsloan> lexical scope - what're the types of the things I can reference
21:54:25 <ivanm> mgsloan: what do you mean by "holes" ?
21:54:43 <mgsloan> nice to have presented to the user in general, but also can help you autofill them with short definitions
21:54:44 <cmccann> mgsloan, ah, seems like that would be easy enough given most ways of getting the context at all...?
21:55:05 <cmccann> well, assuming the sort of involved ways that we were discussing earlier that is
21:55:15 <mgsloan> ivanm - agda style (note: I haven't used agda yet..)!  They're placeholders for expressions yet to be written
21:55:27 <Axman6> bos: is 'const uint8_t const *src' really necessary for the _hs_text_decode_utf8 funtion you've been working on? seems a single const would be enough...
21:55:34 <ivanm> mgsloan: oh, like how we use undefined in haskell?
21:55:38 <mgsloan> yup
21:55:44 <mgsloan> except you want to find out the type
21:55:54 <ivanm> *nod*
21:56:00 <cmccann> ivanm, I did a quick hack earlier to have a TH splice inspect its own context, figure out what type it should be, then use djinn to implement something appropriate
21:56:01 <sully> so you can then ask agda
21:56:05 <mgsloan> so one solution would be to generate top-level decls "f1" "f2" ... and then insert them in the holes
21:56:12 <mgsloan> then do a :t f1
21:56:12 <sully> "what type do we need in this spot and what is in my context"
21:56:29 <sully> and then you write in a constructor or a function in the hole and ask it to refine
21:56:34 <mgsloan> of course all of these decls would just be "undefined"
21:56:43 <bos> Axman6: read about const correctness :-)
21:56:51 <sully> and it will figure out how many arguments need to apply and create that many holes after the application
21:57:13 <cmccann> this is what I pasted earlier: http://hpaste.org/48965
21:57:17 <cmccann> which is obviously pretty trivial
21:57:24 <mgsloan> cmccann - interesting! could you also inspect the other context? I know TH has "reify" but that doesn't quite let you do the sort of enumerative reflection I'm thinking of
21:57:28 <ivanm> bos: is that parsing of Doubles in Text likely to be fixed?
21:57:29 <Axman6> bos: where would i find that?
21:58:07 <cmccann> mgsloan, define "other context", but the answer is probably "yes, that's where the horrible hack part comes in"
21:58:49 <mgsloan> other context == lexical context, e.g. what's local to my function def, what's defined in this module, what's imported, etc etc
21:58:51 <cmccann> (the toy example there is invoking djinn, but I actually had it printing the context's type during compilation while writing it)
21:59:13 <luite_> mgsloan: ooh great. if you get something working there I'll forgive you for spelling my name wrong ;)
21:59:51 <mgsloan> :DD and edwardk can redirect his sexual favours!
21:59:58 <bos> Axman6: http://en.wikipedia.org/wiki/Const-correctness
22:00:08 <edwardk> not mine, i was offering up copumpkin ;)
22:00:13 <bos> ivanm: when i get a chance
22:00:16 <cmccann> mgsloan, yeah, what it's doing is getting the surrounding AST, finding the LHS associated with the expression where the splice came from, reifyng a few things with TH, then munging that to get the type
22:00:17 <ivanm> OK
22:00:29 <ivanm> bos: it's just frustrating when a test suite fails for such a trivial reason :p
22:00:35 <Axman6> cmccann: ah, so what that says is that it
22:00:51 <mgsloan> edwardk - well either way you clearly posess them
22:00:56 <Axman6> it's a constant pointer to a bunch of constant uint8_t's
22:00:59 <Axman6> yeah?
22:01:02 <cmccann> and it's not doing any of that very sensibly, but it works (in that when I load the code in the snippet, the functions work correctly)
22:01:10 <luite_> bos: did you see my earlier question about serializing to Text with Aeson?
22:01:19 <Axman6> s/cmccann/bos
22:01:20 <bos> luite_: yeah
22:01:24 <edwardk> true, and he'll be at hac phi, so i'll warn him to prepare himself =)
22:01:24 <Axman6> no idea how i managed that one...
22:01:25 <mgsloan> luite_ - at least my mispelling was close to the pronunciation!
22:02:11 <cmccann> mgsloan, what were you planning to do for implementing holes? probably not TH nonsense, I assume
22:02:26 <mgsloan> I was planning to go to hac phi, particularly after meeting the UPenn gang at OPLSS, but I think I might have to go to Hac PDX instead, since it's so much closer (seattle)
22:02:36 <edwardk> bah
22:03:06 <Axman6> bos: looks interesting, I'll have to keep that in mind in the future
22:03:21 <bos> luite_: why would you want to serialize to Text?
22:04:13 <mgsloan> cmccann - not sure! I'm planning to dive into the GHC api for a multitude of reasons, so I was hoping it'd become clear
22:04:27 <mgsloan> otherwise it was going to be the aforementioned "f1 = undefined; f2 = undefined" etc hack
22:04:53 <c_wraith> mgsloan: just make sure to avoid seattle rush hour traffic.  It turns a 3 hour drive into a 6 hour drive :)
22:05:20 <luite_> bos: to include json in other text-based formats. I wanted to add a json value to a data attribute in html
22:05:21 <mgsloan> I am a fan of TH nonsense, though.  Currently I've got a quasiquoter calling into the PCRE library to compile regexes at compile time :)
22:05:35 <bos> luite_: ah
22:06:02 <mgsloan> c_wraith - aye, makes me glad I don't have a car - planning to take the train - unless some seattle haskeller's willing to drive
22:06:23 <cmccann> mgsloan, I wrote a quasiquoter that type checks agda code, which was kind of amusing
22:07:04 <cmccann> could munge the agda AST afterwards so in theory you could use that to embed bits of some sort of proof in Haskell code, but probably not very usefully
22:07:05 <mgsloan> I hope you did that by calling into agda? Otherwise wouldn't it be almost equivalent to implementing it?
22:07:30 <cmccann> mgsloan, yes, it imported the Agda package and started poking buttons pretty much
22:08:10 <mgsloan> maybe this would be a good step towards using haskell as an agda tactics language
22:08:19 <cmccann> i.e., take the string, fabricate an agda module around it, feed that to the parser for an AST, type check the AST and spit out errors, then hand the AST back to inspect
22:08:47 <cmccann> kinda horrible though, since the agda package is really, really not intended to be used that wya
22:09:54 <cmccann> mgsloan, anyway, for the djinn hack I mentioned earlier the TH splices are getting their source location from TH, reading in the file they came from, parsing that with haskell-src-exts, finding themselves in the resulting AST, grabbing the names from the context there, then reifying the names with TH
22:10:02 <cmccann> it's pretty silly
22:10:52 <cmccann> to get the functionality you want for agda-style holes though, I suspect you'd need to ditch haskell-src-exts and use the GHC API instead
22:10:58 <mgsloan> hahah, but pretty awesome too.  Now we just need an editor that supports "unfold-splice, refold-splice"
22:12:22 <cmccann> read the file in, replace any "hole" splices with placeholders, type check it with the GHC API, find the types for the placeholder expressions, then feed that back through TH as compiler output or whatever
22:13:12 <cmccann> which means, yes, running another GHC from a TH splice on the file that GHC is compiling to run the TH splice
22:14:11 <cmccann> then publish it with the documentation being "yo, herd you like types, so I put GHC in your GHC so you can typecheck while you typecheck"
22:15:15 <cmccann> the biggest difficulty is that you'll need to muck with the process in the GHC API since you really don't want the "inner" GHC to see the TH splices
22:15:49 <ulfdoz> Irgendwie muss ich jetzt an Santa Marias Hombre aus Der Schuh des Manitus denken. Aber gutes Personal ist halt schwer zu finden.
22:15:53 <ulfdoz> ewin, sorry.
22:16:03 <cmccann> and the GHC API doesn't really seemed to be designed for having its innards rearranged halfway through
22:16:39 <cmccann> mgsloan, I've spent a bit of time mucking with GHC's intermediate representations for parsed/typechecked/etc. code, it's... fun :P
22:17:06 <mgsloan> oh yeah?  I can indeed imagine it being both fun and ... fun
22:17:35 <luite_> its annoying ;p
22:17:59 <cmccann> my favorite is where things that it only needed in earlier stages get replaced with error thunks, which made uniplate fall over
22:18:00 <mgsloan> one thing I've wanted to mess with is a framework for nesting quasiquoters, and a standard way of providing configuration for them
22:18:26 <luite_> because the AST contains all kinds of node that are equivalent to something like    error "you shouldn't evaluate me"
22:18:28 <mgsloan> such that the configuration flows down the nesting - so you can pass in arity information and such - to provide to haskell-src-exts
22:18:36 * cmccann ended up writing a function with uniplate that would crawl a data structure, force everything, catch any errors, and replace those terms with something generic
22:19:23 <mgsloan> yikes! sounds like they need a different AST for different intermediate stages
22:19:30 <luite_> cmccann: ah I had something similar
22:20:04 <cmccann> mgsloan, they probably do, I think it's just inertia of a large code base. I imagine a fair amount of code in GHC is almost as old as the language itself :P
22:20:39 <mgsloan> could be a good application of TH - express "just like this ADT, but missing these fields" or "just like this type, but with this type for this field", with derivation of coercions between the two, etc
22:20:59 <cmccann> mgsloan, yeah, I've thought about doing something like that
22:21:12 <cmccann> now that I'm finally learning some TH I might do it
22:22:14 <cmccann> another thing I want is some sort of... eh, "structural lens", projecting a data structure to some simpler form that can be rearranged in such a way that when you send it back through the "lens" it makes the corresponding changes in the original structure. not sure how that's gonna work, though!
22:23:32 <cmccann> but it would make stuff like AST munging simpler to be able to reflect to a simplified structural image of the syntax and let details get carried along
22:25:42 <Peaker> cmccann: If your handling of the AST is all done by folds -- maybe you can make a simplifying fold that gives simplified data to the fold arguments
22:26:06 <cmccann> Peaker, oooh, hm, that's an interesting angle
22:26:19 <Peaker> well, not a fold -- that would lose any data not given, actually
22:26:30 <cmccann> actually, a zipper-like approach sounds very plausible
22:26:32 <Peaker> but any higher order manipulations (map/filter/etc)
22:26:36 <cmccann> hm
22:27:06 <Peaker> zipper combinators could work too
22:27:27 <cmccann> yeah, I think something like oleg's generic zipper would be a good place to look for inspiration
22:27:35 <cmccann> gonna have to think about this one :T
22:27:45 <mgsloan> cmccann - have you seen fclabels? it's pretty good.
22:28:00 <cmccann> mgsloan, yes, I've used it several times
22:28:00 <mgsloan> I guess you don't get an extraction of a subset of fields though, only one
22:28:15 <mgsloan> I think with combinators you can do multiple fields in batch
22:28:51 <cmccann> mgsloan, the idea is that I want to extract structure, with only enough values to identify things for what they are
22:29:01 <cmccann> then make changes to the structure in a way that translates back
22:29:10 <cmccann> rather than replacing values or structures
22:30:10 <mgsloan> hmmm, interesting!
22:30:13 <cmccann> the idea is that by extracting structure but disallowing replacement, you could abstract over values of things that can't be easily created fresh
22:31:40 <cmccann> allowing replacement would mean that when translating back, the details that were blurred out would need to be created ex nihilo for the grafted-on parts
22:31:58 <cmccann> whereas by limiting things to shuffling and filtering what's already there, you don't have to worry about that
22:32:18 <cmccann> the motivating example here being, of course, an AST
22:33:51 <cmccann> you could blur stuff like unique identifiers and just get simple representations, shuffle parts around, then refocus and have everything still refer to the same identifiers as before
22:34:00 <Peaker> fclabels should become the default name binding of record fields instead of a weak getter...
22:34:17 <Peaker> maybe with some syntactic annotation for backwards compatibility
22:34:24 <dobblego> I will be implementing exactly that for scala soon
22:34:42 <cmccann> dobblego, fclabels by default?
22:34:59 <dobblego> yeah, the existing record fields will use lenses and CoState
22:35:12 <cmccann> dobblego, nice :]
22:35:22 <dobblego> rather than something that is currently similar to haskell record fields
22:35:42 <cmccann> (wanted to make sure you weren't talking about my speculative nonsense above, heh)
22:36:12 <dobblego> thinking of just forking the language -- so much room for improvement
22:36:19 <cmccann> dobblego, somehow I would have assumed that a language with more OOP heritage would have managed to start with something less horrible than Haskell's record fields
22:36:26 <dobblego> ha
22:36:45 <dobblego> when it comes to good ideas, there is a whole lot of *fingers in ears* lalalalala what did you say something?
22:36:46 <Peaker> dobblego: If you fork Scala, you lose compatibility with it -- at which point, why carry all the Scala baggage?
22:37:17 <dobblego> Peaker: if I did it, I'd hope to require minimal expenditure of effort to keep updates
22:37:32 <dobblego> and of course, I have to interface with WebSchmear and other similar nonsense, hence scala
22:37:53 <Peaker> Is Scala's Java compatibility and "OO syntax" (making GADTs look horrible :-), strictness, impurity, etc.. worth all the trouble?
22:38:05 <dobblego> if it's a small amount of trouble, yes
22:38:11 <cmccann> dobblego, makes me sad :[ scala sounded interesting at first but as I've heard more back-and-forth about design decisions and concepts I'm getting less and less enthused at the idea
22:38:19 <dobblego> I agree with how bad it all is
22:38:35 <mgsloan> cmccann - this idea would be particularly cool if you could have the target of these transforms share representations, so that you can generically write such shufflers
22:38:42 <dobblego> cmccann: it's the "fingers in ears" thing that makes me most sad i.e. not only has it not happened, but it never will
22:38:45 <Peaker> Would be nice to have a JVM backend for LLVM or GHC :-)
22:39:02 <dobblego> Peaker: write it and I'll ditch this scala nonsense in a flash
22:39:02 <ivanm> Peaker: why?
22:39:18 <ivanm> dobblego: IIRC there have been a couple of attempts at that...
22:39:22 <dobblego> right
22:39:27 <ivanm> (GHC on JVM, dunno about LLVM on JVM)
22:39:29 <dobblego> by braver people than I
22:39:37 <Peaker> ivanm: because without it, people are using some compromise-languages which make Haskellers sad
22:39:49 <thoughtpolice> i think there's openquark, but laziness + side effects doesn't please many people and you have to be careful about it from what i remember
22:39:56 <dobblego> I'd be happy to compromise, but it gets out of hand sometimes
22:40:03 <ivanm> dobblego: there have been a few attempts at porting JVM to LLVM apparently though..
22:40:03 <cmccann> mgsloan, you mean projecting two distinct structures onto a shared simple structure, so that shuffling operations could be used on either, right?
22:40:04 <dobblego> thoughtpolice: tried that in 2007
22:40:07 <thoughtpolice> which is obviously quite displeasing if you're a haskeller
22:40:11 <thoughtpolice> to a high degree.
22:40:20 <dobblego> I have an effect system in scala at least
22:40:42 <dobblego> don't tell the scala guys, they get upset over it, preferring to reinvent (talk about) a degenerate version over and over instead
22:40:43 <thoughtpolice> i should spend a week to try ben's DDC. people apparently really like it
22:40:44 <cmccann> dobblego, I have an effect system in C#. I write a line of code, and know it probably has effects
22:40:47 <Peaker> How low/high level is JVM bytecode?  Is it basically a stack-machine with goto's?
22:40:48 <thoughtpolice> i haven't spent time with an effect system
22:40:52 <Peaker> or a register machine?
22:40:56 <thoughtpolice> Peaker: stack
22:41:01 <dobblego> cmccann: I assume the scala language absent the var keyword
22:41:16 <ivanm> thoughtpolice: won't be ready for a few years at least apparently; ben is still trying to work out some of the theory for the language
22:41:27 <Peaker> What JVM bytecode stuff is related to Java's types/semantics?  Are there bytecodes for Java exception handling, cast-downs, etc?
22:41:32 <thoughtpolice> dobblego: i suppose var is for bindings, but they can also have arbitrary effects?
22:41:38 <dobblego> Peaker: yes
22:41:42 <thoughtpolice> ivanm: oh sure, but i just want to play
22:41:43 <dobblego> thoughtpolice: var is similar to IORef
22:41:49 <thoughtpolice> ah
22:41:54 * thoughtpolice doesn't know scala either
22:41:57 <dobblego> I have scala.IORef
22:42:06 <dobblego> and scala.STRef
22:42:13 <Peaker> And how good are JVM's jits?  Can you write some naive/bad JVM bytecode and get decent performance?
22:42:21 <thoughtpolice> ivanm: the bus factor is also quite high apparently (and was the first time i heard the bus factor really given a name)
22:42:21 <mgsloan> cmcann - exactly
22:42:35 <thoughtpolice> only ben understands significant parts of the implementation as it stands already
22:42:35 <ddarius> JVM is pretty high-level, though certainly not Self byte-codes high-level.
22:42:39 <Peaker> (I'm trying to figure out if a working [non-optimal] Haskell->JVM compiler is a huge undertaking or not..)
22:42:41 <dobblego> Peaker: the stack usage is the biggest performance issue afaik
22:42:57 <mgsloan> FFI seems like it'd be a big tricky part
22:42:59 <dobblego> Peaker: in my mind it is not as bad as is often made out, so I assume I am overlooking something
22:43:09 <mgsloan> how does one create an ArrayList<Int> and stuff like that
22:43:14 <dobblego> FFI to Java could be IO-like
22:43:23 <thoughtpolice> Peaker: the JIT is method at a time, so breaking say, C-- off into JVM procedures would probably be fine (C-- isn't like, insanely large.) the specifics on when the JIT kicks in varies i think
22:43:32 <thoughtpolice> *c-- procedures
22:43:37 <Peaker> dobblego: About stack usage  -- don't the JITs just "see through" the stack usage?
22:43:55 <cmccann> mgsloan, yeah, I'd expect that to be possible. actually I'd be worried about an implementation that didn't allow that, would suspect other limitations hiding elsewhere.
22:44:08 <dobblego> Peaker: succ <$> [1..100000] is likely to blow the stack
22:44:24 <Peaker> dobblego: oh, that kind of stack usage :-)
22:44:29 <ivanm> thoughtpolice: "bus factor" ?
22:44:37 <ivanm> oh, being run over by a bus?
22:44:39 <thoughtpolice> yeah
22:44:50 <Peaker> dobblego: But that should be lazy -- though laziness encoding on the JVM may be .. slow
22:44:50 <ddarius> The RAFTS program showed how to compile stack machine languages to RISC machines readily and effectively in a much more complex environment than JVM byte code.
22:44:52 <thoughtpolice> how many people can get hit by a bus without your project going under from nobody else understanding :)
22:44:59 <dobblego> Peaker: right, that's where the problem is
22:45:47 <ddarius> thoughtpolice: Usually it's not limited to just "understanding."
22:45:53 <Peaker> dobblego: Is there a way to create very cheap "boxes" that can alternate between suspended/completed computations? Or is every object created in the JVM environment relatively expensive?
22:45:56 <thoughtpolice> ddarius: true
22:46:30 <dobblego> Peaker: I think you'd have to implement some strategy yourself, bytecode has no such thing at least
22:46:37 * ddarius needs to make a generic "escaped string" parser.
22:47:37 <Peaker> What's the easiest way to play with JVM bytecode directly on an Ubuntu system?
22:47:54 <dobblego> jad will convert it back to source
22:48:03 <dobblego> it's pretty readable with hexdump
22:48:07 <thoughtpolice> Peaker: there are varying tools to disassemble/decompile java bytecode
22:48:18 <thoughtpolice> for more programmatic manipulation there's at least 1 major library i know of
22:48:22 <thoughtpolice> (the 'asm' library)
22:48:23 <dobblego> there's also some fancy tool for visualising it iirc
22:48:42 <thoughtpolice> yeah, there's a jit visualizer as well so you can see how the jit kicks in
22:49:09 <thoughtpolice> i ran across the project page not too long ago...
22:49:26 <ddarius> thoughtpolice: I hope your insurance covered that.
22:51:32 <thoughtpolice> can't seem to find it now.
22:52:55 <Peaker> thoughtpolice, dobblego: Do you have Ubuntu package names? :-)
22:54:40 <dobblego> Peaker: http://www.varaneckas.com/jad
22:55:20 <thoughtpolice> Peaker: javap (a disassembler) comes with the jdk and will at least do disassembly, jad does decompilation. i don't know about an ubuntu package, but asm is easily available here: http://asm.ow2.org/
22:55:44 <Peaker> Ok, thanks
22:55:54 <thoughtpolice> and yeah, jad is freeware; i don't think it's in any ubuntu repos, but i could very well be wrong (i use debian, and i'm not even close to that machine atm)
22:56:12 <Peaker> I wonder how much of an undertaking writing a toy Haskell compiler targeting the JVM would be..
22:56:23 <thoughtpolice> Peaker: dons wrote a thesis about this topic :)
22:56:26 <dobblego> there are soldiers before you
22:56:34 <Peaker> dobblego: what? :)
22:56:48 <dobblego> people who have trodden this path
22:56:59 <dobblego> trying to find a way out of this god forsaken mess
22:57:13 <cmccann> Peaker, you might want to at least consider skipping a few steps
22:57:27 <ddarius> Time wounds all heels.
22:57:57 <cmccann> Peaker, like starting from one of GHC's intermediate representations, and let it handle some of the complexity
22:58:13 <dobblego> there is language-java for source and bytecode on hackage
22:58:24 <Peaker> cmccann: That's probably best practical view, but not pedagogically :-)  Also I read that GHC is written in a very imperative style
22:59:10 * hackagebot fix-imports 0.1.2 - Program to manage the imports of a haskell module  http://hackage.haskell.org/package/fix-imports-0.1.2 (EvanLaforge)
23:00:07 <Peaker> there was a nice saying: "Writing a compiler for a language in that language is the best way to learn a language well" :-)  I feel I understand Haskell pretty well now, but I'm sure I'll learn something if I write a toy compiler.  But I wouldn't want to do it if it takes more than a month or so
23:00:31 <thoughtpolice> Peaker: GHC is, to quote Simon M, "the worst functional program in the world," and that's probably true at the bottom line, but lots of the pieces are well modularized imo
23:00:54 <cmccann> haha, did he actually say that?
23:00:55 <Peaker> Now "worst in the world" sounds bad :)
23:01:03 <thoughtpolice> and are rather pure in nature (modulo say, Uniques, if you want to gloss over that)
23:01:07 * cmccann feels a little better about the headaches resulting from trying to figure it out, then
23:01:17 <thoughtpolice> cmccann: yes, in #ghc a while back, WRT a question about parallel ghc --make
23:01:47 * cmccann wonders how much of that assertion has to do with Simon's definition of "functional program"
23:01:54 <thoughtpolice> cmccann: but yes, tongue, cheek, etc
23:01:59 <cmccann> yeah
23:02:49 <cmccann> I get the impression they're making slow progress on improving GHC's design
23:04:14 * cmccann recalls finding a fair number of pleased-sounding comments and overviews talking about how some things had been consolidated or refined
23:04:23 <thoughtpolice> i mean, part of the grossness of any software is just dealing with the real world. lots of the things in GHC is just "compiler stuff," not really "GHC stuff" i feel. from my cursory attempts at hacking it, i've had relatively OK success
23:04:41 <thoughtpolice> and compilers are not exactly some of the prettiest beasts, for a lot of reasons
23:04:42 <cmccann> on the other hand there was a comment along the lines of "if you can explain what the real meaning of this construct is, there's probably a PhD in it for you"
23:06:09 <thoughtpolice> i wish someone could just clone both of the simons, and then the clones could write an epic book about the design of GHC. i'd pay to have a good reference on how that magical runtime system works in the grand scheme
23:07:16 <ddarius> The broad strokes are pretty straightforward and either well-understood or fairly well-documented.
23:07:35 <ddarius> The details are, of course, what makes a production compiler.
23:08:50 <ddarius> Probably the least documented, least understood part is how all the various extensions to the type system fit together.
23:09:06 <Peaker> thoughtpolice: if you could clone them -- the clones would probably join the team :)
23:11:44 <Peaker> ddarius: I'm wondering if writing a toy Haskell compiler in about a month is practical for me -- if it is, it may be a very pedagogical experience
23:12:04 <dobblego> may as well fix the record selectors while yer there
23:12:05 <cmccann> Peaker, that may depend on your definition of "toy"
23:12:23 <ddarius> It also depends on how much he'll steal and how much he already knows.
23:12:35 <Peaker> cmccann: Well, full H98 support but probably no FFI
23:12:49 <ddarius> One problem with Haskell is that you really can't implement it without implementing a type-checker, and a Haskell type-checker is not completely trivial.
23:13:11 <Peaker> ddarius: well, it doesn't sound that hard either -- at least without any GHC extensions
23:14:02 <Peaker> Now tokenizing/parsing doesn't interest me at all -- I'd probably re-use haskell-src-exts or such
23:14:51 <cmccann> Peaker, keep in mind that complete parsing may require arbitrary amounts of type checking
23:15:05 <Peaker> cmccann: why?
23:15:10 <ddarius> cmccann: Parsing requires no type checking.
23:15:22 <cmccann> wait, hm, maybe I'm misremembering something
23:15:40 * cmccann thought there were weird corner cases with fixities that required knowing some types
23:15:49 <Peaker> In C it requires keeping track of typedef's.. Haskell should be context-free
23:16:06 <Peaker> Requiring fixities from imported modules is indeed a problem...
23:16:08 <cmccann> but it's late and I'm not thinking clearly, so I'm probably confused
23:16:26 <cmccann> fixities are definitely awkward though, yes
23:16:43 <cmccann> anyway, ugh, time for sleep
23:16:48 <Peaker> cmccann: night!
23:17:12 <Peaker> I think maybe fixities should have been determined somehow deterministically from the operator character used -- to make choices of characters less arbitrary
23:17:24 <Peaker> and so we don't need fixity declarations
23:17:49 <Peaker> I think I remember the fixity of a handful of operators and use type-checking/parenthesis around everything else anyway
23:17:51 <ddarius> That would have been a horrible idea and would have wasted massive amounts of committee time.
23:18:13 <Peaker> ddarius: do you remember operator precedences of most operators you use?
23:18:23 <dobblego> Peaker: scala does that, it's terrible
23:18:37 <Peaker> dobblego: what scheme does it use to choose precedence?
23:18:40 <cmccann> Peaker, you could also define left vs. right associativity based on whether the operator is symmetric
23:18:46 <cmccann> that's not magic at all
23:18:47 <dobblego> a difficult one
23:18:48 <ddarius> Peaker: No, but your scheme doesn't sound like it would really resolve that.
23:19:43 <Peaker> ddarius: I think it would -- I already remember a *few* operators precedences.. I could remember all of the other operators for free, if they had the same precedence-determining trait as the ones I remember
23:20:08 <dobblego> the associativity rule is simple, but it's also a major pain in the arse
23:21:17 <ddarius> I don't actually even look up the precedences.  I either assume they're reasonable, usually based on the semantics, or I just don't bother.
23:22:05 <Peaker> ddarius: I don't understand what "reasonable" precedence would be... It's just arbitrary mostly (except for l/r associativity)
23:22:18 * cmccann doesn't see much point in anything between "define arbitrary fixities" and "don't allow custom operators or, better yet, make everything prefix-only"
23:22:25 <dobblego> even some of the "if it ain't scala, it's a bad idea!" people see user-defined fixity/associativity as a good idea
23:22:27 <ddarius> Peaker: "Additive" operators are lower precedence than "multiplicative" operators.
23:22:31 <ddarius> For exampel.
23:23:04 <Peaker> dobblego: well, they have advantages and disadvantages..
23:23:06 <dobblego> it takes a pretty big nudge to get those people (most scala users) to see the point
23:23:28 <dobblego> yes, the advantages far outweigh disadvantages, by an enormous margin
23:23:29 <ddarius> I agree with the somnabulent cmccann.
23:24:19 <Peaker> Well, once we're free from the silly textual encoding of programs, all of this wouldn't matter :-)
23:24:26 * cmccann can remember "faux-syntactic" operators < comparisons < additive < multiplicative < (.)
23:24:48 <cmccann> where faux-syntax means things like ($) and (>>>) and whatnot
23:25:44 <cmccann> and using operators for EDSLs should assume the fixities to be semantically obvious for the specific domain
23:25:53 <Devilly> [1,34,54]
23:26:10 <Devilly> great, wrong window :P
23:28:15 <cmccann> Peaker, actually I wrote some stuff about this a while ago on Stack Overflow in response to someone who wondered why there weren't more fixity levels, heh
23:28:33 <luite_> rational fixity levels!
23:28:42 <cmccann> http://stackoverflow.com/questions/6320424//6320709#6320709 if anyone is interested
23:28:53 <cmccann> luite_, BTW I gave up on your thing, sorry :[
23:29:05 <cmccann> didn't seem like it was going to work
23:29:53 <luite_> hehe no prob :) I gave up on it earlier, and then I wrote that ghc api thing that just tries all instances
23:30:39 <liyang> surreal fixity!
23:31:01 * cmccann rather liked "infix↑ (ω + 2i)"
23:31:54 <ddarius> The natural thing to do would be to have a precedence poset.
23:32:35 <ddarius> Then you essentially would semi-explicitly stating that your special set of operators have no relation to other sets of operators.
23:32:56 <cmccann> ddarius, that's exactly what augustss suggested on the SO question I mentioned, as well
23:33:09 <cmccann> it does seem like that's the closest to capturing intended meaning
23:34:13 <ddarius> At any rate, remembering the poset is more or less as hard as remembering precedences.  You just don't into stupidities like how should xor compare to (>>).
23:34:34 <cmccann> though I raised the question of defining something like ($) where you want it to be lower than other operator sets, and if defining unique greatest/least precedences would be too limiting at that point
23:35:57 <ddarius> cmccann: I've considered this idea a bit.  One thing I've considered is making operator groups so that you can compactly state that your operator is below or above precedence of another group.  That said, ultimately I think this idea does not stand up well to extensibility and change as your example begins to allude to.
23:37:21 <cmccann> ddarius, yes, defining ordering between entire groups was my first thought, but I'm dubious about following through on that sort of idea
23:37:46 <cmccann> seems like a one-way ticket to the pit of despair and overcomplicated nonsense
23:39:29 <ddarius> cmccann: Ultimately making a "good" set of precedences for everything requires global coordination.  My current recommendation is the two-horned strategy of not trying to achieve that and having the language be the central global coordinator.  This is more or less what we have in practice.
23:41:22 <cmccann> ddarius, I'm inclined to agree
23:42:12 * cmccann would be willing to consider something like "take something like the current system in Haskell, and extend it such that a partial order can be defined among operators of otherwise equal precedence"
23:42:35 <cmccann> thus kicking aside the issue of ordering between groups and leaving that to work the way everything works in Haskell right now
23:43:32 <mgsloan> I've thought about this a bit as well, been meaning to make a proposal in form of email or blog (not that I really have anything concretely figured out).  I think operators need to be made strictly incomparable with eachother when no relation is defined.  So, this would force your DSLs to be in separate () scopes, which I think is reasonable
23:44:15 <cmccann> mgsloan, yeah, that's my assumption for the partial order idea when two operators are unordered with respect to each other
23:45:27 <cmccann> enough people seem to gravitate to it that I'm becoming convinced that the partial order idea is essentially the correct way, but the details are harder to pin down
23:45:46 <cmccann> anyway I really do need to get to sleep about two hours ago, so this time I'm out for real
23:46:17 <ddarius> Yes that aspect is reasonable, but in practice it's just what happens anyway (if you're given any flexibility.)  Do you know which of (+) and (>>) has higher precedence?  Do you care?
23:46:38 <ddarius> I guess types help to achieve this as well.
23:52:29 <mgsloan> TH really needs a "InfixE :: Exp -> [(Exp, Name)] -> Exp"
23:52:50 <mgsloan> err I suppose that'd be [(Name, Exp)]
