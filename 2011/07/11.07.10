00:12:28 <accel_> is there a way to get the last modification time of a file using only the Haskell Platform? My current solution uses "System.Directory.AccessTime.getAccessTime", but it's not provided by the Haskell Platform (and requires the access-time package)
00:14:19 <kmc> HP includes 'unix' or 'Win32'
00:15:40 <kmc> fmap accessTime . getFileStatus
00:15:55 <kmc> or did you want modification time? because that's in System.Directory
00:16:04 <kmc> does Windows track atime?
00:16:13 * kmc usually mounts with noatime, anyway
00:16:18 <accel_> http://book.realworldhaskell.org/read/systems-programming-in-haskell.html worked for me (getModificationTime); I'm on Mac
00:16:33 <Ke> I think relatime is quite often the default
00:16:47 <Ke> atime is not anything you should rely on
00:17:20 <kmc> 'Since Linux 2.6.30, the kernel defaults to the behavior provided by this option'
00:20:34 <Enigmagic> kmc: windows does by default, but it's resolution is set by the filesystem
00:21:21 <Enigmagic> ntfs has better atime resolution than fat/fat32 (and presumably exfat)
00:37:37 <Blkt> good day everyone
00:40:54 <ddarius> "Biting into an apple and finding a maggot is unpleasant enough, but finding half a maggot is worse.  Discovering one-third of a maggot would be more distressing still: The less you find, the more you may have eaten.  Extrapolating to the limit, an encounter with no maggot at all should be the ultimate bad-apple experience."
00:44:24 <mauke> inb4 touhou
01:18:23 <mdwright_laptop> In LYAH, it has an example where [0.1, 0.3 .. 1.0] == [0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]. I can see the floating point inaccuracy causing issues, but why do we get the value 1.09999999…? That's clearly larger than the defined termination value.
01:19:56 <mauke> that's because the Enum instance for Doubles is crazy and the last thing isn't actually a termination value
02:36:52 <cheater_> hey guys
02:37:08 <cheater_> having a bit of a problem understanding how to print out values from monadic types..
02:37:39 <mauke> if the "monadic type" is a list of chars, just use putStr
02:38:57 <cheater_> i get: Couldn't match expected type `[Char]'                with actual type `Control.Monad.Trans.Reader.ReaderT                                    (GHC.Ptr.Ptr EKey) IO String'
02:39:23 <hpaste> cheater pasted “printing stuff” at http://hpaste.org/48907
02:40:09 <mauke> use liftIO
02:40:45 <cheater_> i am using liftIO already
02:40:50 <cheater_> do i need to use it some other way?
02:40:54 <mauke> oh, wait
02:41:31 <mauke> eventKeyName is not a list of chars
02:41:35 <mauke> you can't putStr it
02:41:51 <cheater_> but i can "Return" <- eventKeyName can't i
02:42:07 <cheater_> doesn't that mean it has a [Char] in it somehow ?
02:42:45 <cheater_> as i understant "foo" <- bar is just a test of whether bar contains "foo", but i might be very wrong here?
02:42:47 <mauke> well, that syntax means it has a type of the form M [Char] where M is an instance of Monad
02:43:04 <cheater_> isn't that <- just an equality test?
02:43:17 <ion> @undo do "foo" <- bar; baz
02:43:17 <lambdabot> bar >>= \ a -> case a of { "foo" -> baz; _ -> fail ""}
02:43:18 <mauke> and as the error message tells us, M is ReaderT (Ptr EKey) IO
02:43:31 <cheater_> yeah it seemingly is
02:43:50 <cheater_> mauke, ok.. so what would i do to print out what the thing contains?
02:43:57 <cheater_> how do i "unwrap" it?
02:44:13 <mauke> x <- eventKeyName; ...
02:44:20 <mauke> s/unwrap/run/
02:44:47 <cheater_> that worked. interesting. why do i need to do that?
02:45:08 <mauke> because ... everything?
02:45:58 <cheater_> i'm operating under the assumption that <- is just assignment
02:46:03 <mauke> it isn't
02:46:03 <cheater_> is that correct?
02:46:09 <cheater_> ok.. what is the difference there?
02:46:14 <ion> @undo do "foo" <- bar; baz
02:46:14 <lambdabot> bar >>= \ a -> case a of { "foo" -> baz; _ -> fail ""}
02:46:23 <mauke> cheater_: in fact, you shouldn't even be using <-
02:46:35 <cheater_> @undo do x < bar; baz x
02:46:35 <lambdabot> x < bar >> baz x
02:46:56 <mauke> @undo do x <- bar; baz x
02:46:57 <lambdabot> bar >>= \ x -> baz x
02:47:17 <mauke> cheater_: do notation is syntactic sugar for calls to >>=
02:47:41 <mauke> our IO is callback/continuation based
02:48:04 <cheater_> mauke: what should i be doing then?
02:48:04 <cheater_> yeah, stupid typos
02:48:11 <mauke> >>=
02:48:22 <cheater_> if instead of k <- eventKeyName; liftIO $ putStrLn k;      i would just like to do       liftIO $ putStrLn <something>;       what would i do?
02:48:42 <cheater_> btw, sorry if i make no sense but i'm like 10 seconds lagged :o
02:48:44 <mauke> write a compiler extension or something?
02:48:45 <ion> liftIO . putStrLn =<< eventKeyName
02:48:57 <cheater_> ion, that's cool, let me try that
02:50:42 <cheater_> worked well, thanks
02:51:02 <cheater_> now i have a problem with the modifier.. the modifier isn't a string, it contains an actual value that is refered to literally
02:51:17 <cheater_> they use it this way for example:          [Control] <- eventModifier
02:51:37 <cheater_> how would i print out what ever i get back from eventModifier? this is only for debugging..
02:51:55 <mauke> whatever <- eventModifier; print whatever; ...
02:51:58 <cheater_> i realize haskell in itself might be unable to do it (and it's probably good that it's this way)
02:52:09 <cheater_> print? as opposed to putStr?
02:52:14 <mauke> @src print
02:52:14 <lambdabot> print x = putStrLn (show x)
02:52:23 <ion> :t show
02:52:24 <lambdabot> forall a. (Show a) => a -> String
02:52:32 <cheater_> ahhh!
02:52:36 <cheater_> let's give that a try
02:53:01 <cheater_> wow that's perfect
02:53:06 <cheater_> thanks guys you're great
02:56:28 <cheater_> amazing
02:56:38 <cheater_> btw, is there a way to print out the type of something?
02:56:55 <cheater_> kinda like :t
02:57:13 <Cale> It's statically determined, so you can use a string constant.
02:57:41 <cheater_> i'm afraid i don't understand
02:57:53 <Cale> Well, it's not like it could be something different at runtime.
02:58:01 <cheater_> i realize
02:58:09 <obiwahn> uhm
02:58:22 <cheater_> but unwrapping all that code so that i can go into ghci and do :t can be problematic
02:58:26 <obiwahn> i am totally new to haskel:)
02:58:37 <Cale> ah, okay
02:58:48 <cheater_> so i'd like to just go into the code, into the actual context i'm writing my code in, and find out what the type of something is
02:58:51 <Cale> obiwahn: That's cool, we're beginner-friendly here :)
02:58:58 <cheater_> obiwahn: :)
02:59:06 <cheater_> obiwahn, what's up?
03:00:01 <obiwahn> but a function can be applied to different data types. now when i pass a anoter function on data tyoe to my print data type function then there should be different outputs
03:00:16 <obiwahn> funtion or
03:00:24 <ion> > (typeOf [42], typeOf1 [42])
03:00:25 <lambdabot>   ([Integer],[])
03:01:09 <ion> You *could* use that if the type’s an instance of Typeable, but i for one have never once had the need to use that for debugging.
03:01:53 <cheater_> aaaah! great!
03:01:54 <cheater_> i realize, i'm just trying to use it to learn rather than debug
03:01:55 <cheater_> ghc is good at telling me the types of things already
03:02:07 <cheater_> as in what they should be =)
03:02:09 <akosch> what would I use instead of head, If I wanted my custom value instead of an exception for an empty list?
03:02:28 <Cale> akosch: case xs of [] -> ... ; (x:xs) -> ...
03:02:34 <obiwahn> ill read a bit more in my profs script and come back later - for now i am just reading ab bit the irc:) thank you Cale :)
03:02:47 <Cale> akosch: or just generally pattern matching
03:03:03 <cheater_> obiwahn, i don't understand your question
03:03:09 <Cale> obiwahn: I don't understand your question either
03:03:13 <akosch> Cale: ok, thanks
03:03:16 <cheater_> ok, so i have the following problem
03:03:53 <cheater_> the background is i want to write a schematic capture application using gtk2hs, with Vi-like input
03:04:08 <cheater_> now the input just edits the schematic, which is pretty much a graph with different node types
03:04:29 <cheater_> a node can be a transistor, resistor, etc.
03:05:25 <cheater_> when i'm editing the graph, i need to redraw it. every time i draw the graph, i need to lay out out in a nice way so that it's readable.
03:05:59 <cheater_> if the graph changes substantially (say, it is split in half) then the output could "jump" from the old version to the new
03:06:04 <cheater_> how do i go about this problem?
03:06:30 <Cale> The whole thing?
03:06:37 <cheater_> the "jumping" thing
03:07:15 <cheater_> i would like to do two things: 1. if the graphs are very similar (e.g. imagine a square, and a square with an antenna) then the augumented graph's nodes that are in the original graph stay in position
03:07:31 <Cale> So the user isn't in direct control of the layout?
03:07:49 <cheater_> 2. if the graph nodes need to move (because of other things, say tension, which would be nice to have later), then i would like to animate the transition
03:07:54 <cheater_> Cale, no, he is not
03:07:57 <cheater_> not initially
03:08:17 <cheater_> basically i'm looking for a good graph drawing function
03:10:21 <ion> I would love a schematic capture program that automatically maintains the layout using an algorithm alike GraphViz or something. I’d also like to be able to use abstractions like instanced subschematics (with certain inputs and outputs) and using chips with e.g. four identical optoisolators or whatever as singular virtual parts which are then allocated in an optimal way from the actual chips.
03:10:38 <cheater_> ion, that's what i thought too
03:11:18 <cheater_> ion, the whole thing is more general than that - if the thing runs well the idea could also be used for a haskell AST-style editor
03:11:35 <cheater_> and also many other things
03:11:35 <cheater_> mind mapping, general graph editing
03:12:30 <ion> (I get both of those abstractions with GEDA, but not the automatic layout.)
03:12:34 <cheater_> because you just know haskell needs an AST editor
03:12:51 <cheater_> ion: but do you get a diff-able file format?
03:13:45 <ion> Well, it’s ASCII, but obviously for computers to read, not humans.
03:15:10 <cheater_> yeah but can you make a diff and say "ok, this resistor's value changed in revision  5045"?
03:15:30 <cheater_> one thing that annoys me with schematic capture tools is how mouse-driven they are
03:15:34 <cheater_> it's just killing me
03:16:48 <ion> You can get that information from the diff, actually.
03:17:15 <ion> But how things are connected to each other are unreadable because they’re just lines with coordinates.
03:18:02 <cheater_> i want to be able to go and say...          ie12ax7 ller220k leV_B<esc> and it'll show a 12ax7 with the plate connected through a 220k resistor to B+.
03:19:02 <cheater_> ion, gotcha
03:19:06 <mdwright_laptop> What is the double exclamation point? I found something that seems to refer to it as a subscript selector, but there's no subscript value after the double exclamation
03:19:16 <cheater_> exclamation mark?
03:19:24 <mdwright_laptop> (example: (map fib [0 ..] !!) )
03:19:36 <mdwright_laptop> cheater_: Yes, exclamation mark
03:19:45 <ion> > [0..] !! 42
03:19:46 <lambdabot>   42
03:19:58 <mdwright_laptop> there's no subscript after it though
03:19:58 <ion> It returns the numbered element from a list.
03:20:14 <ion> > let f = ([0..] !!) in f 42
03:20:15 <lambdabot>   42
03:20:27 <mdwright_laptop> Oh, of course.
03:20:29 <mdwright_laptop> Thanks!
03:22:05 <cheater_> yeah if there's no subscript it's just partial application, isn't it
03:32:32 <nicoo> > let f = ((!!) [0..]) in f 42
03:32:33 <lambdabot>   42
03:33:33 <ion> > let f = (!! 42) in f [0..]
03:33:34 <lambdabot>   42
03:39:43 <Peaker> > let f = (!!10000042) in f [0..]
03:39:44 <lambdabot>   10000042
03:42:40 <DevHC_> ./floattest
03:42:51 <DevHC_> floattest: <<loop>>
03:42:55 <DevHC_> ^ wtfbbq?
03:56:25 <DevHC^> so, how does GHC's recursive loop detection work?
03:59:00 <Saizan> a thunk gets marked while it's being evaluated
03:59:31 <Saizan> so if it tries to evaluate an already marked thunk it knows there's a circularity
04:01:20 * hackagebot wai-handler-launch 0.0.2 - Launch a web app in the default browser.  http://hackage.haskell.org/package/wai-handler-launch-0.0.2 (MichaelSnoyman)
04:03:04 <DevHC^> does that decrease runtime performance (than without loop detection)?
04:03:27 <DevHC^> > let f = f in f 1
04:03:31 <lambdabot>   mueval-core: Time limit exceeded
04:05:28 <DevHC^> let f = f :: String -> Integer in show . f . show $ 1337
04:05:29 <Saizan> DevHC^: no, it's actually a by-product of the thunk updating algorithm they'd use anyway, though it works only in the single-threaded runtime
04:05:32 <DevHC^> > let f = f :: String -> Integer in show . f . show $ 1337
04:05:35 <lambdabot>   mueval-core: Time limit exceeded
04:05:56 <Saizan> and when compiled, you won't get it out of lambdabot
04:06:10 <DevHC^> ok
04:09:57 <DevHC^> is Float the IEEE-whatever 32-bit floating point type?
04:12:18 <Tomsik> Can you get absurd types like a -> b only as a result of nontermination?
04:12:27 <Tomsik> As I every ill-typed program doesn't terminate?
04:12:30 <Tomsik> as in*
04:14:52 <kosmikus> Tomsik: if you count abnormal termination (by means of "error" or "undefined") as nontermination, then yes
04:15:18 <Tomsik> Yeah, that's what I mean
04:15:41 <kosmikus> I wouldn't call a program of type "a -> b" ill-typed, though
04:16:32 <kosmikus> Tomsik: and there are still subtle differences
04:16:58 <kosmikus> so for example, the type a -> b contains both "undefined" and "const undefined", and both vaues can be distinguished in Haskell
04:29:29 * hackagebot posix-timer 0.1 - Bindings to POSIX clock and timer functions.  http://hackage.haskell.org/package/posix-timer-0.1 (MikhailVorozhtsov)
04:36:50 <vampire> !request
04:36:54 <vampire> !shell
04:36:56 <vampire> !help
04:40:10 <ocharles> Hi, I want to interface with a postgresql database, but I'm a bit overwhelmed by the choice of libraries. I'm looking for something that lets me type queries in SQL, and then convert results back to certain data types
04:41:21 <ocharles> I see there's HDBC, HSQL, pgsql-simple, and probably more
04:42:23 <vampire> i need stable shell
04:46:24 <akosch> I want to to different things based on what a string starts with. I have the startsWith function from Data.String.Utils to compare my strings, but don't know which control structure to use... (case of would be nice, but I'm comparing the strings with a function and not directly). Any ideas?
04:52:08 <akosch> Oh, I think guards are my friends :)
05:25:45 <roconnor> is ARR_WORDS the content of a UArray?
05:26:09 <opqdonut> yeah
05:30:04 <ocharles> hey, can anyone shed any like on this problem with ghc-pkg check: https://gist.github.com/1074505 ?
05:35:58 <Phyx-> ocharles: run ghc-pkg recache. if that doesn't work, edit the config file removing  those dependencies
05:36:19 <ocharles> Phyx-: which config file is that?
05:36:29 <ocharles> recache didn't solve it
05:36:38 <roconnor> what is TSO?
05:37:49 <geheimdienst> tail sall optimization? total sost of ownership?
05:38:00 <roconnor> it appears in my heap profile
05:38:06 <roconnor> http://i.imgur.com/IaDPJ.png
05:38:29 <geheimdienst> no clue really
05:39:52 <geheimdienst> ocharles: when you do cabal install xmonad-contrib, what is the output? i'd hope it would automatically reinstall all the packages listed as broken
05:40:10 <ocharles> Phyx-: I manually changed the deps, seems to report no problems in ghc-pkg check now
05:40:11 <ocharles> thanks
05:40:22 * ocharles runs emerge --update
05:40:33 <ocharles> good, happy system is happy, once again
05:43:09 <Phyx-> ocharles: sorry was afk for a bit, yeah the config gets corrupted sometimes
05:47:38 * hackagebot HTF 0.7.1.0 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.7.1.0 (StefanWehr)
05:49:13 <ion> Wait. That’s different from test-framework, right? But in the very same namespace?
05:55:41 <geheimdienst> does test-framework have a custom preprocessor that collects tests? htf has one, apparently. that would be a clear advantage of htf vs. test-framework
05:56:52 <mornfall> geheimdienst: Well, not that I know, but I would normally say that a custom preprocessor is a disadvantage.
05:57:50 <mornfall> geheimdienst: And since this is Haskell, test-framework test lists can be built up compositionally.
05:58:42 <geheimdienst> hm ... how do you mean? i always wrote "tests = [ testThis, testThat, ... ]
05:59:10 <mornfall> geheimdienst: Say you have a parametric test set, that can test both Wibbles and Foos. You write it just once, then instantiate twice and catenate.
05:59:17 <ion> geheimdienst: It does. test-framework-th or something like that. I’ve been using it successfully.
05:59:17 <Phyx-> why would a custom preprocessor be a disadvantage?
05:59:34 <mornfall> Phyx-: Because it needs to be called somehow. :) Is it supported by cabal?
06:00:09 <Phyx-> doesn't cabal support custom preprocessors?
06:00:18 <mornfall> Is there a LANGUAGE pragma I can just stick in and have it DTRT?
06:00:23 <mornfall> Phyx-: It's work.
06:00:32 <mornfall> It might, but I don't even know where to start.
06:00:50 <mornfall> And it'll break with parametric tests anyway.
06:02:04 <mornfall> (Say you have QC properties for a typeclass... how do you go about testing all the implementations, when you are running the testsuite through a preprocessor?)
06:03:07 <geheimdienst> i dunno ... overall, it seems less work to add some magic line to the *cabal file and go off and write tests. less work than having one test module that has to import tons of stuff and a huge list
06:03:29 <geheimdienst> you always need to write down the test name in 2 places. with the preprocessor approach, it'd be 1 place, as i understand it
06:04:11 <opqdonut> I rather liked the quickCheck script
06:04:42 <geheimdienst> about parametric tests: yeah, but i don't think it's much additional work. you'd just write "common_function x = ... ; test_this = test 42 ; test_that = test 37", assuming "test_" is what the preprocessor picks up and common_function is your polymorphic thing
06:04:46 <mornfall> Well, you could settle for a "tests" variable exported from each (relevant) module. You still need one module that imports all other modules's tests and catenates them, but it's not that bad is it?
06:04:48 <opqdonut> (grabs all top-level defs with a name matching "prop_.*" and quickChecks them)
06:05:09 <geheimdienst> opqdonut: interesting. how does it work, is it a shell script?
06:05:13 <mornfall> geheimdienst: That doesn't scale though, does it?
06:05:24 <opqdonut> geheimdienst: yeah. it's not very polished, though
06:05:28 <mornfall> geheimdienst: When you have 100 tests, you need 100 common_function's, 100 test_this and 100 test_that lines...
06:05:40 <opqdonut> geheimdienst: available on hackage as quickcheck-script or something
06:06:04 <mornfall> geheimdienst: Either that, or you lose granularity by conflating all 100 into a single big testcase.
06:07:47 <mornfall> OTOH if you just had a "tests" list per module, you don't need to repeat your test names (the tests can be inline in a list), you can still parametrise, and you can easily generate a .hs file that just imports all "tests" and builds the final thing.
06:08:38 <mornfall> I am normally willing to trade a bit of syntactic inconvenience for having first-class entities.
06:09:06 <mornfall> (And since a "list of test_xxx" is not first-class...)
06:09:08 <geheimdienst> mornfall, oh i see, you want to programmatically create test cases ... i think that shouldn't be difficult with a preprocessor. hunit has things like TestList iirc. it contains TestCases and is itself a TestCase that can be run. either the htf thing / test-framework-th thing have that feature or it's easy to add ... "test_stuff = TestList xs where xs = badass magic to generate it"
06:10:09 <geheimdienst> about the one "tests" list per module -- sounds reasonable, but the question for me is then: how do you generate that .hs file in a non-brittle way :)
06:10:11 <mornfall> geheimdienst: Well, that doesn't make the preprocessor "work" with the generic testcases. You just work around it.
06:10:21 <mornfall> geheimdienst: grep! :D
06:10:48 <skymuss> hi
06:10:59 <mornfall> geheimdienst: Also, once you write test_foo stuff and you realize you need to make it generic, you have to change all the syntax.
06:11:38 <skymuss> I need help
06:11:46 <mornfall> skymuss: We all do...
06:12:25 <skymuss> http://pastebin.com/h5EY890d
06:12:27 <mornfall> geheimdienst: Dunno really. For now, it always turned out it is cleaner to have a separate test hierarchy anyway, as far as I am concerned.
06:12:27 <mauke> The paste h5EY890d has been copied to http://hpaste.org/48910
06:13:10 <mornfall> That's some ugly code... :-)
06:13:25 <mornfall> Moreover, it's syntactically wrong.
06:13:37 <mornfall> (then = bla doesn't look like Haskell to me)
06:13:43 <mornfall> skymuss: ^
06:13:51 <skymuss> whats wrong with this code
06:14:01 <mornfall> s/then =/then/g
06:14:23 <mornfall> And you would normally want to use a case, possibly over compare g 0, in this context.
06:14:28 <mornfall> Intsead of the if chain.
06:14:42 <mornfall> If chains in haskell are almost always a bad idea.
06:14:50 <skymuss> okay
06:15:15 <skymuss> why is there a syntax error
06:15:34 <mornfall> case compare g 0 of LT -> (0, 0); EQ -> (...); GT -> (......);
06:15:51 <mornfall> skymuss: "then =" as I told you twice already...
06:16:02 <geheimdienst> guards would make sense, too, right? f a b c | g < 0 = ... | g == 0 = ...
06:16:08 <erus`> how can i write a recursive anonymous function?
06:16:12 <mornfall> geheimdienst: Would.
06:16:22 <mornfall> geheimdienst: Although compare seems a perfect fit here. :)
06:16:31 <Phyx-> erus`: use the fixpoint function
06:16:34 <Phyx-> :t fixpoint
06:16:35 <lambdabot> Not in scope: `fixpoint'
06:16:39 <Phyx-> :t fix
06:16:40 <lambdabot> forall a. (a -> a) -> a
06:16:45 <mornfall> erus`: Give it a name, it'll hurt less. :)
06:17:09 <mornfall> fix is hard to understand
06:17:14 <erus`> i just read this complaint that you cant write recursive anonymous functions in got, but i dont even know how todo that in haskell
06:17:23 <erus`> got = go
06:17:35 <mornfall> erus`: That's a silly complaint. Moreover, I am not convinced it is true.
06:17:48 <mornfall> As long as it has first-class functions, it should be possible.
06:18:10 <Phyx-> > fix (\n x -> if x == 0 then 0 else n (x-1)) 5
06:18:11 <lambdabot>   0
06:18:37 <Phyx-> > fix (\n x -> if x == 0 then [0] else x: n (x-1)) 5
06:18:37 <lambdabot>   [5,4,3,2,1,0]
06:18:46 <mornfall> Yea, fix is Y, and it's a simple lambda. Higher-order, sure, but not hard.
06:18:53 <fryguybob> skymuss: you also need an equals before the let.
06:18:53 <mornfall> +term
06:19:34 <skymuss> http://pastebin.com/XQFULMa9
06:19:36 <mauke> The paste XQFULMa9 has been copied to http://hpaste.org/48911
06:20:37 * geheimdienst is not sure if it's haskell syntax to say "let ... in | g < 0 = ... | ..."
06:20:51 <mornfall> skymuss: Try this, http://hpaste.org/edit/48911
06:20:57 <mornfall> Fsck.
06:20:59 <hpaste> fryguybob annotated “http://pastebin.com/XQFULMa9” with “http://pastebin.com/XQFULMa9 (annotation)” at http://hpaste.org/48911#a48912
06:20:59 <mauke> The paste XQFULMa9 has been copied to http://hpaste.org/48911
06:21:08 <mornfall> http://hpaste.org/48911 I mean. :)
06:21:24 <azaq231> mornfall: Actually, fix can't be implemented by a simple lambda in haskell as it would produce an infinite type. fix is implemented as fix f = let x = f x in x
06:21:33 <mornfall> The fryguybob's one is even better, although changes more stuff. :)
06:21:46 <Phyx-> azaq231: indeed
06:21:57 <mornfall> azaq231: Ah, hm, typed lambda calculus. :D
06:22:01 <geheimdienst> > let x = 42 in | x < 50 = "lolcats"
06:22:01 <lambdabot>   <no location info>: parse error on input `|'
06:22:11 <mornfall> azaq231: But it still isn't a core thing.
06:22:13 <geheimdienst> > let f y = let x = 42 in | x < 50 = "lolcats"
06:22:13 <lambdabot>   <no location info>: parse error on input `|'
06:22:23 <mornfall> geheimdienst: You can't do that, no.
06:22:24 <skymuss> thx It works
06:22:36 <azaq231> mornfall: fix itself not, let ... in is
06:22:45 <geheimdienst> mornfall: but isn't that the same as fryguybob's paste ...?
06:22:56 <mornfall> geheimdienst: His paste removed the let.
06:23:01 <hpaste> geheimdienst annotated “http://pastebin.com/h5EY890d” with “http://pastebin.com/h5EY890d (annotation)” at http://hpaste.org/48910#a48914
06:23:02 <mauke> The paste h5EY890d has been copied to http://hpaste.org/48910
06:23:03 <mornfall> geheimdienst: The guards are on the function.
06:23:16 <Phyx-> why does mauke want everything on hpaste?
06:23:40 <mornfall> Phyx-: Been programmed to, I guess.
06:24:07 <mornfall> The hpaste/mauke interaction is kind of silly though.
06:24:12 <Phyx-> mornfall: mauke is generally a person
06:24:20 <Phyx-> lol
06:24:21 <mornfall> Phyx-: With scripts.
06:24:27 <mornfall> I suppose, anyway.
06:24:32 <geheimdienst> anyhoo, that annotation http://hpaste.org/48910 is my suggestion. what still needs to be fixed is the "sqrt(g)" thing
06:24:45 <Phyx-> I wouldn't put it begind him to be copying them by hand :P
06:24:59 <mornfall> Phyx-: It would definitely be funny though.
06:25:03 <geheimdienst> in less than a second?
06:25:33 <geheimdienst> (15:26:51) hpaste: geheimdienst annotated ...
06:25:33 <geheimdienst> (15:26:51) mauke: The paste has been copied ...
06:25:48 <mornfall> geheimdienst: Superhuman powers. Haskell does that to you.
06:25:52 <Phyx-> he's a quick little bugger
06:26:00 <mornfall> (I think I just crossed the -blah boundary though.)
06:26:15 <Phyx-> nah
06:26:51 <Phyx-> that's odd
06:27:00 <arbn> Hi. I'm a Haskell beginner, and just wrote a solution to the 10th Project Euler problem. The weird thing is, it runs in the same time interpreted vs. compiled, which seems weird to me.
06:27:29 <mornfall> arbn: How do you compile it?
06:27:34 <merijn> arbn: There is no interpreted Haskell. GHCI just dynamically compiles and links in the background...
06:27:38 <mornfall> (runghc/runhaskell is interpreted...)
06:27:47 <mornfall> merijn: To bytecode.
06:27:54 <merijn> arbn: So as long as the compilation time is negligible they should be equally fast...
06:28:05 <mornfall> merijn: I don't think I agree with that.
06:28:10 <mornfall> Unless something changed recently.
06:28:17 <Phyx-> i don't agree with it either
06:28:22 <skymuss> :r
06:28:23 <arbn> merijn: The GHC docs say that the bytecote compilation of runghc lacks optimizations.
06:28:40 <merijn> I don't know about runghc, tbh
06:28:41 <mornfall> Either way, bytecode interpreter is still an interpreter.
06:28:43 * hackagebot roundtrip-xml 0.2.0.1 - Bidirectional (de-)serialization for XML.  http://hackage.haskell.org/package/roundtrip-xml-0.2.0.1 (StefanWehr)
06:28:49 <arbn> I used "ghc eul10.hs" to compile.
06:28:56 <mornfall> arbn: Try with -O.
06:29:01 <merijn> I'm pretty sure ghci just compiles to native code, no?
06:29:05 <mornfall> merijn: No.
06:29:23 <Phyx-> that's odd.. scopedtypevariables is not doing what i'm expecting
06:29:33 <mornfall> Phyx-: How come?
06:29:42 <mornfall> Aren't you shadowing somewhere?
06:29:44 <mornfall> Or missing a forall?
06:29:59 <luite> yeah you still need an explicit forall
06:29:59 <Phyx-> not that I know of
06:30:10 <luite> but I don't know what you're expecting :p
06:30:33 * Phyx- pastes
06:30:35 <mornfall> Let's assume the best, in which case GHC is buggy. (News at eleven. :P)
06:30:58 <arbn> Hmm. Still about the same speed as runghc, even with -O.
06:31:54 <Phyx-> http://pastebin.com/FJXq7SUS
06:31:56 <mauke> The paste FJXq7SUS has been copied to http://hpaste.org/48915
06:31:56 <mornfall> arbn: Can you get us the code?
06:32:02 <Phyx-> must be missing something
06:32:20 <mornfall> Phyx-: A forall.
06:32:30 <luite> yeah a forall
06:32:31 <mornfall> realloc : forall b. Storable b => ...
06:32:31 <luite> :)
06:32:36 <mornfall> realloc ::
06:32:44 <Phyx-> ah, in the function type
06:32:46 <hpaste> arbn pasted “eul10” at http://hpaste.org/48916
06:32:48 <Saizan> forall a b. ..
06:33:02 <mornfall> Yeah, a too.
06:33:10 <mornfall> (Once you have a forall, you need to bind all vars...)
06:33:16 <Phyx-> interesting
06:33:49 <mornfall> arbn: Might be that the code is simply dominated by asymptotic complexity.
06:33:51 <Phyx-> why does it require an explicit forall?
06:33:58 <mornfall> Lemme try though.
06:34:10 <mornfall> Phyx-: You have to bind the variables explicitly.
06:34:20 <luite> Phyx-: probably to not break existing code just by enabling the extension :)
06:34:23 <mornfall> Phyx-: Existing code would break otherwise.
06:34:31 <mornfall> What luite beat me to, anyway.
06:34:31 <Phyx-> ah
06:34:37 <Phyx-> that makes sense
06:35:43 <mornfall> arbn: I do get some 30 % difference.
06:35:58 <arbn> Oh, OK. Must be something about my machine, then.
06:36:07 <mornfall> arbn: On your code, anyway.
06:36:32 <mornfall> arbn: Although there are certainly better ways to write that. :)
06:37:00 <mornfall> A factor of n better, at least.
06:37:01 <Phyx-> good, my new allocation functions compile
06:37:12 <Phyx-> now to implement the Stack
06:37:14 <arbn> OK. Thanks. As I said, I just started trying to learn Haskell very recently.
06:37:29 <mornfall> arbn: Is that your first language?
06:37:56 <mornfall> (also, foldl1 (+) is better written sum...)
06:38:15 <mornfall> And that also works with [].
06:38:25 <arbn> No. I've been programming for less than 2 years, though. Also, I've not yet figured out how to do certain faster algorithms with Haskell.
06:39:10 <mornfall> Yeah, it can be tricky.
06:57:47 <siracusa> Do we have a version of toLower/toUpper for ByteStrings somewhere?
07:01:55 <Baughn> siracusa: Well, there's always ByteString.map toLower
07:03:37 <siracusa> :t toLower
07:03:38 <lambdabot> Char -> Char
07:03:55 <siracusa> Baughn: Are you sure this work for ByteStrings as well?
07:04:03 <Baughn> :t ByteString.map
07:04:03 <lambdabot> Couldn't find qualified module.
07:04:14 <Baughn> :t Data.ByteString.map
07:04:15 <lambdabot> (Word8 -> Word8) -> BSC.ByteString -> BSC.ByteString
07:04:16 <Phyx-> :t B.Map
07:04:16 <lambdabot> Couldn't find qualified module.
07:04:19 <Baughn> :t Data.ByteString.Char.map
07:04:20 <lambdabot> Couldn't find qualified module.
07:04:31 <Baughn> siracusa: \bot aside.. yes, I'm sure.
07:06:59 <siracusa> Baughn: Doesn't work for me, cannot match Word8 and Char
07:07:48 <akosch> how could I filter a list based on which type constructor the elements use?
07:08:29 <siracusa> You need a list for each constructor?
07:09:20 <siracusa> > let list = [Just 1, Nothing, Just 2] in [x | x|(Just _ ) <- list]
07:09:21 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
07:09:21 <lambdabot>         against inferred type ...
07:09:32 <siracusa> > let list = [Just 1, Nothing, Just 2] in [x | x@(Just _ ) <- list]
07:09:33 <lambdabot>   [Just 1,Just 2]
07:09:40 <siracusa> > let list = [Just 1, Nothing, Just 2] in [x | x@Nothing <- list]
07:09:41 <lambdabot>   [Nothing]
07:10:50 <akosch> siracusa: I need the first element with a specific constructor from a list
07:11:16 <azaq231> akosch: a type constructor is a function on the type level which takes types to construct a type of kind *; Maybe, for example, has kind * -> *. A datatype of kind * has *data* constructors, like Just and Nothing
07:12:06 <siracusa> akosch: You can use my examples and the take the head of the result list. But be sure to check if the list isn't empty
07:12:55 <akosch> siracusa: thanks, I think I'll manage. Btw: couldn't use 'find' for this somehow?
07:13:16 <siracusa> :t find
07:13:17 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
07:14:20 <siracusa> > let list = [Just 1, Nothing, Just 2] in find (\c -> case c of { Just _ -> True; _ -> False }) list
07:14:20 <lambdabot>   Just (Just 1)
07:14:31 <siracusa> akosch: ^
07:14:47 <akosch> siracusa: thanks, exactly what I needed
07:14:58 <paczesiowa> where can I find module Version (ghc-pkg uses it)?
07:15:10 <osfameron> :t find
07:15:11 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
07:18:10 <Baughn> siracusa: You need the Char version of Bytestring, not the Word8 version.
07:18:40 <Baughn> siracusa: That said, you probably shouldn't do this. I doubt your text is really ASCII.
07:33:56 <refold> paczesiowa: look at ghc-pkg/ghc.mk
07:35:33 <siracusa> Baughn: No, my text isn't ASCII. However, the parts on which I want to apply toLower are ASCII for sure
07:38:46 <paczesiowa> refold: seems like it's impossible to use it whith already installed ghc:(
07:39:30 <siracusa> But they are pretty short, so I guess I'll stick with toString and the standard toLower
07:41:30 <Baughn> siracusa: There is a perfectly good non-linked-list text type, though. :P
07:41:58 <siracusa> Text you mean?
07:41:59 <Baughn> siracusa: http://hackage.haskell.org/package/text
07:42:01 <Baughn> Right
07:44:07 <siracusa> Baughn: Sound like it is the better solution, thanks.
07:44:31 <juanrh> > map (+1) [1,2,3]
07:44:32 <lambdabot>   [2,3,4]
07:46:06 * Baughn wonders how to do something as simple as toUpper'ing every 4th char in a Text
07:47:19 <Baughn> A "map with state", that is..
07:47:29 <Baughn> ..well, that's not really a map. Hmm.
07:47:44 <siracusa> I'd use take for this
07:47:45 <paczesiowa> Baughn: mapAccumL ?
07:48:01 <paczesiowa> or *R
07:48:14 <Baughn> paczesiowa: That'd work, but it'd involve a lot of allocation. I'd like to take advantage of knowing that the final text is the same size as the initial one.
07:48:43 <paczesiowa> Text text?
07:48:49 <Baughn> Yes
07:48:52 <paczesiowa> oh
07:49:03 <Baughn> Though it's more of a general question
07:49:20 <Baughn> There's probably a name for what I want. Catahistomorphic zygoprepromorphism or something. :P
07:50:04 <SirFrancisDrake> or, simply put, a fold
07:50:06 <paczesiowa> long time ago in some library (cannot remember the name, something about arrays) there were functions like map that would take optional arg for the resulting length
07:50:28 <paczesiowa> maybe that library has a mapAccumL
07:51:46 <paczesiowa> Baughn: doesn't map for Text do that?
07:52:04 <Baughn> paczesiowa: Sure, but it doesn't let you do anything stateful
07:52:33 <sshc> Is "make framework-pkg" still supported?  I'm trying to make a PowerPC pkg for GHC 7.0.4.  % make framework-pkg   make -C distrib/MacOS framework-pkg   make[1]: *** No rule to make target `framework-pkg'.  Stop.   make: *** [framework-pkg] Error 2
07:53:01 <paczesiowa> Baughn: implement mapAccumL for Text in the same way (if it's not already done)
07:54:09 <Baughn> Hmm.. oh, I didn't spot that it already worked like that. ^^;
07:54:21 <Baughn> Now, what's the proper name for mapAccum?
07:54:49 <SirFrancisDrake> what about Data.List.Split?
07:54:57 <Baughn> What about it?
07:56:12 <SirFrancisDrake> it could, uh, split. At every regular interval or so
07:58:20 <Baughn> SirFrancisDrake: It only works on lists, for one..
08:04:54 <paczesiowa> Baughn: what do you mean by proper name?
08:05:29 <Baughn> paczesiowa: A proper mix of greek and latin.
08:05:36 <Baughn> paczesiowa: Possibly with some japanese thrown in.
08:05:53 <dylukes> double inPher    = inCell.totalPheromone + 1,
08:05:53 <dylukes>                        outPher   = outCell.totalPheromone + 1,
08:05:53 <dylukes>                        totalPher = inPher + outPher;
08:06:08 <dylukes> I start writing (objective) C … let/in style code suddenly.
08:07:03 <ion> The C multiple assignment syntax is confusing when assigning using pointers.
08:07:12 <paczesiowa> Baughn: mapAccumL not hip enough?
08:07:51 <Baughn> paczesiowa: It's too understandable.
08:10:07 <SirFrancisDrake> > pack . (Data.List.foldl (++) "") . ( Prelude.map (\x -> (Prelude.init x)++[Data.Char.toUpper (Data.List.last x)]) ) . (Prelude.map unpack) . (chunksOf 4) (pack "Some random text, uh")
08:10:07 <lambdabot>   Not in scope: `chunksOf'
08:10:19 <SirFrancisDrake> > pack . (Data.List.foldl (++) "") . ( Prelude.map (\x -> (Prelude.init x)++[Data.Char.toUpper (Data.List.last x)]) ) . (Prelude.map unpack) . (Data.Text.chunksOf 4) (pack "Some random text, uh")
08:10:19 <lambdabot>   Not in scope: `Data.Text.chunksOf'
08:10:41 <SirFrancisDrake> well, you take my point.
08:11:00 <SirFrancisDrake> really awful style
08:11:26 <dylukes> ion: Well, I'm just taking advantage of the comma operator.
08:11:35 <dylukes> Which is essentially `seq`.
08:11:38 <SirFrancisDrake> :t pack
08:11:38 <lambdabot> forall o n. (Newtype n o) => o -> n
08:11:59 <dylukes> ion: and I assume you mean: double a = 10, *p = &a;
08:12:45 <SirFrancisDrake> Baughn: this one works for texts.
08:16:28 <ion> dylukes: Yes
08:17:38 <Baughn> SirFrancisDrake: Performance was a goal, though. :P
08:17:44 <Baughn> SirFrancisDrake: Think I'll stick with mapAccum.
08:18:50 <SirFrancisDrake> Baughn: screw performance
08:21:48 <Polarina> What are your recommendations of libraries for FRP?
08:26:59 <Baughn> SirFrancisDrake: I'd really rather not.
08:27:09 <paczesiowa> Polarina: iirc, the only true solution is to write one yourself
08:33:01 <SirFrancisDrake> over 2 minutes on a 2mb file and counting. Maybe it's really not the fastest solution
08:36:04 * edwardk waves hello.
08:36:12 * ion waves sine.
08:36:35 <edwardk> finally had a use for a comonoid today
08:37:12 <ion> What was that?
08:37:53 <edwardk> i'm using it to power multiplication of modules =)
08:38:21 * ziman wonders what a comonoid is. The coalgebraic counterpart to monoid?
08:38:30 <ziman> You should blog about it. :)
08:38:46 <edwardk> its just not a comonoid over hask, its a counital coassociative coalgebra over a field
08:39:29 <edwardk> ziman: over set they are all boring. once you move to a space like Vect_f you can do something with it ;)
08:40:23 <wwalker> I have an operational problem, not a programming problem.  I tried to install xmonad and xmonad contrib.  My install didn't work, so I rm'd the files I'd installed and used some rpms I had overlooked
08:40:54 <edwardk> ion: i have lots of rings, etc. then i went and defined a -> r   as a free module over the ring r. this is a pretty nice encoding for some purposes. it is pretty obvious that it consists of |a| copies of r, you can do lots of things with it
08:41:13 <edwardk> ion: but when a has a group associated with it you should be able to build the group ring.
08:41:27 <edwardk> so the obvious thing would be to define some stuff that looks like
08:41:49 <edwardk> instance (Monoid a, Ring r) => Ring (a -> r)
08:41:56 <wwalker> now xmonad is looking for the version I installed manually (0.9.2) not the one I installed via rpm.  Where does haskell maintain a manifest of installed modules?  the files are gone, I can't find where haskell/xmonad is referencing the now-gone version...
08:42:08 <edwardk> sadly this doesn't work, you need more structure
08:42:27 <ion> Alas, i haven’t studied enough algebra to know the meaning of any of that. :-P Probably should start reading from http://en.wikipedia.org/wiki/Group_ring
08:42:28 <merijn> wwalker: Somewhere in ~/.cabal for user specific installations, dunno about global installs
08:43:15 <edwardk> 'monoid ring' might be better
08:43:27 <edwardk> i weaken it all the way down to semigroup semiring actually
08:43:39 <edwardk> but then i want something more general
08:44:01 <cmccann> I've yet to be able to get a clear impression of how a comonoid would be useful :[
08:44:12 <cmccann> too much set-oriented intuition I guess
08:44:15 <edwardk> cmccann: still working towards it =)
08:44:45 <edwardk> cmccann: so lets talk about how we can define a more general multiplication on (a -> r)
08:44:54 <edwardk> not the pointwise one
08:45:19 <cmccann> hm, ok
08:46:16 <edwardk> an associative algebra is basically a semigroup on vectorspaces. it provides linear mappings from m * m -> m, but note that the product of two vector spaces isn't just (,) in Hask
08:46:19 <wwalker> merijn: thank you
08:46:45 <edwardk> so lets just model vector spaces (or more generally modues) as (a -> r)
08:47:29 <edwardk> then an algebra on vector spaces would be (a -> a -> r) -> (a -> r) — where the intervening arrow is subject to linear conditions
08:47:30 <cmccann> basically treating it as a bunch of "r"s indexed by "a"s, right?
08:47:38 <edwardk> yep
08:47:43 <ion> I have yet to study comonads either. A simple but realistic example of where they’re useful would be helpful.
08:48:12 <cmccann> ion, I think edwardk's blog has a few straightforward examples somewhere, actually
08:48:22 <Polarina> Could someone show me an Yampa example of it putStrLn'ing a hello world after one second of runtime? :/
08:48:29 <cmccann> or maybe I'm thinking of something sigfpe wrote
08:48:39 <Saizan> wwalker: see ghc-pkg unregister
08:48:52 <Saizan> merijn: it's not in ~/.cabal it's in ~/.ghc
08:49:45 <edwardk> we can take the type there and ball up a type for linear transformations. newtype Linear r b a = Linear ((a -> r) -> b -> r) — which is effectively ReaderT b (Cont r a) shuffled around, with an extra constraint on it.
08:50:00 <edwardk> this is clearly a monad, an arrow, etc. you can program with all of those operators safely.
08:50:12 <edwardk> (***) on arrows is actually a direct product of linear maps
08:50:27 <edwardk> linear maps form a module in their own right (not a free module)
08:50:51 <edwardk> well, they _are_ a free module, just subject to linearity conditions,
08:51:14 <edwardk> they are the free module over r for the set (a -> r, b)
08:51:22 * cmccann nods
08:51:28 <akosch> how do I handle different line endings in haskell?
08:51:31 <edwardk> (a -> r, b) -> r
08:51:40 <edwardk> so far so good?
08:52:05 <cmccann> I think so... only had one cup of coffee this morning, so probably gonna need a while for this to sink in :T
08:52:23 <cmccann> and I've seen some of this stuff before, in various forms
08:52:38 <edwardk> linear is pretty convenient. when b is () or if we just look at a simple type for linear functionals (a -> r) -> r where the outer arrow is constrained to be linear (that is to say, f (a * x + y) = a * f x + f y)
08:53:01 <edwardk> (er a .* x + y that is, that is scalar multiplication in there)
08:53:26 <edwardk> then we also get a nice special case for dealing with what physicists call covectors.
08:53:47 <edwardk> covectors are linear functionals, that is functions from a vectorspace to a scalar.
08:54:26 <edwardk> now we get to the fun part
08:55:00 <edwardk> if we define a coassociative coalgebra over a vectorspace as a map from m -> m * m that is coassociative, this becomes something like
08:55:36 <edwardk> cojoin :: Linear r (m, m) m   — that is to say it is a mapping from m -> m * m — the arrows in Linear read the wrong way to make the monad, etc. work
08:56:41 <edwardk> without even touching the coassociative coalgebra, we can define multiplication on free modules pointwise
08:57:03 <edwardk> f * g = runLinear join $ \(a,b) -> f a * g b
08:57:34 <edwardk> join there is the Linear r a (a,a) from associative algebra, not the haskell one
08:57:49 <cmccann> these names get confusing sometimes :[
08:58:23 <edwardk> and we can define that an associative algebra gives use a coassociative coalgebra on the dual vector space
08:59:05 <edwardk> instance Algebra r m => Coalgebra r (m -> r) where cojoin = Linear $ \k (f,g) -> k (f * g)  — using the * above that uses join
08:59:57 <edwardk> and we can define multiplication on linear maps using a coassociative coalgebra
09:00:44 <cmccann> hm
09:00:51 <edwardk> instance Coalgebra r a => Multiplicative (Linear r b a) where Linear f * Linear g = Linear $ \k b -> f (\a -> g (cojoin k a) b) b
09:01:09 <edwardk> er runLinear cojoin
09:01:41 <cmccann> okay, I don't think I'm really following at this point, sorry :T I'd need to work through some of this myself, I think, either on paper or in code
09:01:47 <edwardk> keep in mind that a linear functional is a vector in the dual vector space/module
09:02:24 <cmccann> I think I get the basic idea of how this all works but it's too many steps removed from things I'm really comfortable with
09:02:26 * cmccann sighs
09:02:36 <edwardk> and that a linear map is from a vector space v -> m, where m has basis b, consists of |b| linear functionals
09:02:37 <Saizan> these (Co)Algebra would be the ones for the categorical product functor if seen as F-(Co)Algebras ?
09:03:04 <edwardk> saizan: i'm not sure of the collection to f-algebras honestly
09:03:50 <cmccann> and unfortunately I need to head out for a while
09:03:57 <edwardk> anyways, once you add a counit to the coalgebra, you get a counital coassociative coalgebra, which is a comonoid on vectorspaces
09:04:17 <edwardk> and it makes for good multiplication on these easy to work with covectors which form a monad
09:04:19 <cmccann> edwardk, you have this stuff in your algebra package, or will at some point?
09:04:25 <edwardk> yeah
09:04:35 <edwardk> its going in in a couple hours
09:04:45 <edwardk> i have it working, just need to shuffle a lot of code to avoid orphans
09:05:05 <cmccann> I think I'll just take a look at it when you do, then, that's about how long I'll be gone probably
09:05:41 <cmccann> thanks for the explanation anyway, I could at least follow some of it :]
09:07:01 <edwardk> the main point of this is because when i encode multiplication of chebyshev polynomials, they don't form a group ring
09:08:04 <edwardk> its much more fun to program with the covectors, where the cojoin operation for spaces indexed by chebyshev polynomials is trivial =)
09:08:25 <edwardk> newtype U = U Int — the space of chebyshev polynomials of the first kind
09:09:49 <edwardk> instance MultiplicativeGroup r => Coalgebra r U where cojoin = Linear $ \k (U n, U m) -> (k (U (n + m)) + k (U (abs (n - m)))) /. 2
09:10:20 <edwardk> this lets me work with non-power bases for polynomials without torturing myself.
09:10:32 <danharaj> I thought you were into that kind of stuff.
09:11:17 <edwardk> to see the comparison to normal polynomials
09:11:37 <edwardk> newtype X = X Int — represents power of Xs, monomials in X.
09:12:12 <edwardk> instance MultiplicativeGroup r => Coalgebra r X where cojoin = Linear $ \k (X n, X m) -> k (X (n + m))
09:12:56 <edwardk> working with covectors/linear maps it just works out that i can do the multiplication. working with vectors i need to factor monomial X's into products that add to it
09:23:18 <Phyx-> is the use of implicit arguments considered icky?
09:24:13 <ezyang> In some quarters, yes.
09:24:47 <Phyx-> aww
09:25:31 <edwardk> yes, except when they are indispensible for debugging ;)
09:25:40 * wli never touches them.
09:25:45 <wli> Debugging how?
09:26:06 <Phyx-> lol, I want to use em to add an implicit stack, which is only read/write when --debug is passed
09:26:10 <edwardk> \x y -> f (\a -> ?huh x y f) — tells you types ;)
09:27:14 <Phyx-> looks like i scared him away
09:28:59 <parcs> :t foldl ?f 0 [1..10]
09:28:59 <lambdabot> forall a b. (?f::a -> b -> a, Num a, Num b, Enum b) => a
09:30:18 <nus> > \x y -> id (\a -> ?huh x y f)
09:30:19 <lambdabot>   mueval-core: internal error: PAP object entered!
09:30:19 <lambdabot>      (GHC version 6.12.3 f...
09:34:08 <parcs> > ?x
09:34:09 <lambdabot>   mueval-core: internal error: PAP object entered!
09:34:09 <lambdabot>      (GHC version 6.12.3 f...
09:34:19 <parcs> @more
09:34:32 <russruss> Hey guys - relative haskell beginner here, and I'm not incredibly experienced with functional programming (no professional or research experience).  I'm messing around with web servers in the snap framework, but my question is slightly more general.  I'm trying to find a convenient way to parse a format called JSON.  There's a parser module called text.json which goes back and forth between the raw strings and a parse-tree representa
09:34:32 <russruss> which is pretty convenient, but there doesn't seem to be an easy way to go between the parse tree and native, type-safe types.  This seems like a common enough goal that there should be some best practices.  So, what is the best way to go from a parse tree of a non-typesafe format to a haskell type?
09:36:50 <skymuss> http://pastebin.com/3wPQU2se
09:36:53 <mauke> The paste 3wPQU2se has been copied to http://hpaste.org/48917
09:37:02 <skymuss> can anybody help me
09:37:08 <russruss> I made a stab at it where I created a "prototype" associative list and then made some helper functions to read and write that - it feels like what I really want is an associative list between strings and types, which seems inconvenient
09:37:54 <skymuss> ??
09:38:42 <nus> skymuss, s/save/safe/ ?
09:39:27 <dylukes>  god fucking damn.
09:39:35 <dylukes> If you're in Pittsburgh, do yourself a favor and go to Tram's Kitchen.
09:39:44 <dylukes> Seriously the best food I've had in Pittsburgh, ever.
09:39:45 <skymuss> http://hpaste.org/48917
09:39:45 <hpc> um... -blah?
09:39:47 <monqy> russruss: ass in Text.JSON, you want an ADT (abstract datatype)
09:39:54 <dylukes> hpc: whoops, wrong channel, sorry.
09:40:01 <hpc> :P
09:40:43 <skymuss> can anybody help me
09:40:45 <russruss> monqy: could you explain that further?
09:42:26 <skymuss> ??
09:42:37 <monqy> russruss: I'm a bit awful at explanations, but I'm sure there's one elsewhere--I'll see if I can dig one up
09:43:17 <Saizan> skymuss: you haven't explained what is your problem
09:43:38 <skymuss> i get a syntax error
09:44:39 <Saizan> can you show the full error too?
09:45:03 <Saizan> anyhow, on line 3 you have saveDivision instead of safeDivision
09:45:10 <skymuss> http://hpaste.org/48918
09:45:17 <Phyx-> skymuss: that's not a syntax error though
09:45:37 <skymuss> kay that was the error xD+
09:45:41 <monqy> russruss: Does http://www.haskell.org/haskellwiki/Abstract_data_type help? If not, I guess I can try to explain it further.
09:45:45 <Phyx-> skymuss: you have to hide the ones defined in the prelude
09:45:48 <Phyx-> skymuss: import Prelude hiding (Maybe, Just, Nothing) would do
09:46:19 <Phyx-> or
09:46:20 <Phyx-> import Prelude hiding (Maybe(..))
09:46:53 <monqy> russruss: oh wait I think I messed up somewhere :(
09:47:07 <Phyx-> you could also just change the name of your type to MyMaybe or something
09:47:56 <skymuss> thx
09:49:20 <monqy> russruss: sorry for messing up; I'll try to explain the JSON data type
09:49:50 <russruss> monqy: no problem... I don't really know what I'm doing :-P
09:50:32 <monqy> russruss: since a JSON value can take multiple forms, the JSValue type has multiple constructors, each representing one of them
09:51:05 <monqy> russruss: a simpler example might be the Bool type, which has two constructors, True and False
09:51:33 <russruss> yeah, I definitely get that
09:51:45 <russruss> I guess I'm looking for an easy way to go between like JSValue and like some type I made up
09:51:52 <monqy> oh?
09:52:26 <merijn> I think he just wants to convert from (for example) a JSValue (which happens to be a Bool) to as Haskell Bool
09:52:30 <russruss> I'd rather do it in some "declarative" style where I'm not writing like logic for every type I want to slurp for JSON
09:53:38 <hpaste> russruss pasted “JSON parsing” at http://hpaste.org/48919
09:53:56 <russruss> there's what I have right now
09:54:11 <russruss> as I said I'm pretty new
09:54:17 <russruss> so like the syntax/idioms might be unusual
09:55:33 <russruss> but yeah what's gross about this is that after I run the "readJSONPrototype" function I still have the fields as JSValue
09:56:03 <russruss> I'd rather like have readJSONPrototype be parameterized by like a mapping from strings to types and then have it just return a list of typed Haskell objects
09:56:12 <russruss> but I don't really know if there's any convenient way of doing that
09:56:54 <monqy> May I ask why JSValue is unsatisfactory?
09:57:27 <merijn> russruss: I think Text.JSON wants to be used as a JSON monad (from what I can see of the documentation)
09:57:56 <russruss> well, in this example I may already have tons of logic that deals with "Todo" as a native haskell type
09:57:59 <merijn> "Result a" is an instance of Functor and Monad so you can just use >>= and fmap as usual
09:58:35 <russruss> yeah, I mean but in that case you're kind of rewriting the same code over and over for each type you want to make a member of the JSON class, yeah
09:58:38 <merijn> "todoContents <- functionReturningResultA; nativeHaskell todoContents"
09:58:57 <merijn> russruss: You have seen code in the IO monad, I assume?
09:59:13 <russruss> yeah, I mean I use the result monad a lot in the example I pasted
09:59:59 <merijn> The Result a already contains native Haskell types, so then I don't see the problem?
10:00:03 <russruss> I guess what I want is something where I can parameterize a function by a mapping between strings and types
10:00:17 <monqy> I think there's a thing to do that
10:00:20 <monqy> I think
10:00:48 <merijn> russruss: Can you paste some pseudo-code explaining how you want to use the parsed JSON and why that won't work?
10:00:58 <russruss> merijn: I guess the question is where does functionReturningResultA come from
10:01:02 <monqy> russruss: In Data.Typeable, there's a type called TypeRep, which you should be able to use for that
10:01:30 <monqy> russruss: you might also want to look into Data.Dynamic, if you dynamic typing
10:01:45 <merijn> russruss: I see an "decode :: JSON a => String -> Result a" in Text.JSON
10:03:03 <merijn> The JSON typeclass also provides "readJSON :: JSValue -> Result a", seems to be implemented for all the usual basic haskell types
10:04:56 <hpaste> russruss pasted “dream JSON parsing” at http://hpaste.org/48920
10:05:18 <russruss> that's sort of what would be ideal
10:05:20 <akosch> this is the first program I've written in haskell that is longer that 10 lines: http://pastebin.com/FRXqQnN5 Besides printing random quotes from the movie "Rambo: First Blood", it's supposed to be a dummy SMTP server, that just dumps all SMTP sessions to stdout. It has been a more or less pleasant experience, but I get the feeling that I'm doing something horribly wrong: could someone please check the code and give me a few hints?
10:05:20 <merijn> Oh
10:05:24 <mauke> The paste FRXqQnN5 has been copied to http://hpaste.org/48921
10:05:46 <merijn> russruss: That should be easy
10:06:03 <merijn> russruss: You just have to make Todo an instance of JSON
10:06:18 <russruss> err, well, that's sort of what I want to avoid
10:06:22 <merijn> Why?
10:06:28 <monqy> my question exactly
10:06:30 <merijn> Since String and Bool are already instances of JSON that should be easy
10:07:19 <russruss> well, I mean if I'm going from a JSON "object" that contains a "description" key and a "isDone" key that have to map to the two parameters of the Todo constructor
10:07:35 <russruss> I'm not sure it is easy enough that I'd want to do it for every type I want to support
10:07:40 <dylukes> this brings up the question, is it possible to introspect the names of the fields of a record?
10:08:06 <merijn> dylukes: In a limited usage it is, not sure if it is possible in general
10:08:09 <dylukes> so you could say, write a JSON instance that expands when you edit the record… or that you could derive?
10:08:15 <Twey> Not normally… you might be able to with fclabels or something
10:08:28 <Twey> Data.Derive would probably allow that JSON instance
10:08:34 <hpc> GHC mangles names during compilation, so it would have to be with some other tool
10:08:40 <hpc> or what Twey said
10:08:46 <dylukes> The Evil Mangler!
10:08:48 <dylukes> :0
10:08:59 <Twey> (Data.Derive is TH)
10:09:19 <cheater__> mangulator
10:10:19 <merijn> russruss: Well, either the data type already is a member of JSON (which makes it easy to support that type) or it doesn't in which case you're going to have to write conversion code anyway to convert it to JSON
10:10:43 <russruss> merijn: sure, but what I'm looking for is a way to make that easier
10:11:05 <Twey> TH is the way
10:11:55 <merijn> If it needs to be really generic TH might be the easiest solution yeah
10:12:10 <merijn> Depends on how complicated the eventual Todo datatype will be
10:12:26 <russruss> yeah I mean I guess the issue is not that one but the fact that there might be a ton of them
10:12:55 <russruss> so having some really easy prototype method of converting from json to native types might be nice
10:13:20 <russruss> like I guess a thing that maybe is hampering understanding here is I'm talking about json formats that are already decided
10:13:58 <russruss> so like I can't just like make the json format for Todo to be whatever I want, it really has to be an object with a "description" tag and an "isDone" tag
10:15:47 <russruss> so with Data.Derive, that can't use any information that's not in the types, right?  can it introspect to field names of records?
10:16:24 <dbpatterson> how do you specify in a .cabal file that the program should be statically linked?
10:16:59 <lispy> danharaj: I'm here now
10:18:54 <iratsu> par internet
10:22:08 <iratsu> oh sorry, wrong channel
10:25:24 <Jetbeard> Today is the day I will learn about monads!
10:26:57 <parcs> @quote monad
10:26:57 <lambdabot> robertmassaioli says: I hereby name (>=>) as "fish" and (<=<) as "back-fish", swim fishy swim, compose those Monads.
10:27:01 <akosch> how do I handle the resource vanished (Broken pipe) exception?
10:27:30 <Jetbeard> parcs: i will remember those names when I first meet those symbols :)
10:28:21 <parcs> akosch: don't use lazy io
10:28:27 <dylukes> Kleisli fish!
10:29:43 <akosch> parcs: I'm using the network module, is that wrong?
10:30:18 <dylukes> akosch: Just don't use hGetContents.
10:30:26 <dylukes> Use iterates or something better
10:30:33 <dylukes> (than lazy io)
10:30:52 <akosch> dylukes: I'm just using hGetLine, but when the other end closes the socket I get this exception
10:32:52 <akosch> how would I silence it and just kill my thread?
10:33:00 <parcs> akosch: see Control.Exception.catch
10:33:08 <akosch> parcs: thanks
10:34:12 <akosch> how would I figure out the name of this exception?
10:34:56 <parcs> it's IOException
10:35:12 <merijn> Jetbeard: And where/how were you planning on learning about monads?
10:35:22 <merijn> The majority of tutorials are awful >.>
10:35:33 <akosch> parcs: thanks again :)
10:35:59 <McManiaC> is there a great image processing library for haskell? (resize, crop, etc)
10:36:50 <merijn> McManiaC: The answer is probably (as always) "Check hackage?" :p
10:37:17 <conal> McManiaC: what properties would you like? e.g., imperative vs functional, discrete vs continuous?
10:37:27 <McManiaC> merijn: the graphics section has about 200 libraries… kind of hard to tell which one is decent and which not
10:37:33 <merijn> Ah, true :p
10:37:53 <dylukes> some sort of "review and rate" system for hackage would be really nice.
10:37:56 <dylukes> come to think of it.
10:38:22 <dylukes> as it stands it's hard to find the nicest christmas tree in the forest.
10:38:52 <McManiaC> conal: as long as its powerfull... :)
10:39:10 <merijn> Define powerful :p
10:39:24 <conal> McManiaC: as in features? rather than composability etc?
10:39:27 <dylukes> also important is useful.
10:40:43 <Phyx-> dylukes: review systems are susceptable to gaming though
10:40:58 <Phyx-> especially since you can't actually verify that the reviewer has even dowloaded the package
10:41:32 <Phyx-> susceptible*
10:42:01 <dylukes> Restrict it to only people who have submitted packages of their own.
10:42:08 <dylukes> That really restricts it.
10:42:19 <parcs> i doubt the haskell will have that problem
10:42:20 <dylukes> Probably too much though.
10:42:25 <dylukes> parcs: ^ also this
10:42:27 <parcs> community*
10:42:54 <McManiaC> conal: well as I said, I'd need primarily features like resizing, cropping, maybe it would be cool to be able to change settings like brightness, contrast etc
10:43:02 <Phyx-> lol
10:43:27 <parcs> and hackage has bigger exploits to worry about
10:55:46 <mm_freak> dylukes: it's fairly easy to upload a package in the style of "acme"
10:56:01 <dylukes> acme:don't is actually pretty useful though.
10:57:43 <mm_freak> you would install a whole package to get const (return ())?
10:58:24 <mm_freak> the acme-* packages appear to be bad nerd jokes to me
11:01:14 <mm_freak> and like that wouldn't be enough, acme-dont is even a hazard for every haskell newbie, because it gives a very misleading idea of the 'do' construct
11:01:24 <dylukes> Yep.
11:01:34 <kmc> :D
11:01:59 <kmc> i have used acme-now seriously
11:03:19 <hpc> i can imagine it being helpful in conjunction with Debug.trace
11:03:25 <hpc> *Trace
11:03:42 <erus`> does anyone know of a tutorial to write your own ML/haskell type language in haskell (or anything)
11:04:03 <dylukes> the parsec is a tad out of date, but it'll all still work,
11:04:04 <dylukes> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
11:04:05 <erus`> don't say "system ghc" or whatever :P
11:04:28 <dylukes> You'll certainly see places where it could be improved, but go along with it, it's worth it.
11:04:36 <erus`> scheme doesnt have partialy applied functions or anything does it?
11:05:58 <gwern> erus`: well, you can jalways return a lambda, no?
11:06:24 <erus`> i would prefer something that looks a little more like haskell
11:07:04 <erus`> i have alittle prototype ml type thing working in javascript but the design is hideous. i would like to know how todo it properly
11:07:13 <gwern> mere syntax. what's the real difference between 'plus1 = (+) 1' and '(define (plus1) (lambda (x) (+ x 1))' or whatever
11:11:29 <pesco> hello! i have a weird problem with persistent / template haskell. it looks like the "mkPersist" function doesn't define the expected data ctors for the Update types.
11:12:38 <pesco> e.g i have a type Player with a field name. then there should be an associated type Update Player with a constructor called PlayerName.
11:12:41 <kmc> iirc scheme lets you say (define ((f x) y) ...)
11:12:48 <kmc> which is pretty close to having sugar for currying
11:13:12 <dylukes> brown or palm sugar can actually be really nice in curry.
11:13:26 <dylukes> in moderation it really helps it stick the rice and be more delicious.
11:13:29 <pesco> but ghc gives me Not in scope: data constructor `PlayerName'. does anyone know what i'm doing wrong here?
11:14:02 <dylukes> erus`: Scheme does not have partially applied functions, but its easy to define them :)
11:14:18 <dylukes> you can even use a define-syntax rule or two to curry functions, and create a define-curried
11:15:23 <dylukes> erus`: That tutorial introduces curry later on.
11:15:30 <dylukes> as a stdlib function.
11:16:48 <dylukes> I personally like this definition.
11:16:48 <dylukes> http://programming-musings.org/2007/02/03/scheme-code-capsule-currying/
11:19:19 <parcs> pesco: #yesod also might be able to help
11:23:56 <chaoflow> Is there a special name for something like this: thingie (f1, f2) g = f1 . g . f2 ?
11:25:08 <kmc> @pl \(f1, f2) g -> f1 . g . f2
11:25:08 <lambdabot> uncurry ((. flip (.)) . (.) . (.))
11:25:22 <kmc> @pl \f1 f2 g -> f1 . g . f2
11:25:22 <lambdabot> (. flip (.)) . (.) . (.)
11:25:40 <kmc> chaoflow, not afaik
11:25:50 <Jetbeard> i think "thingie" is a suitable name for it personally
11:26:21 <parcs> :t uncurry (. ?g)
11:26:21 <lambdabot> forall a c b. (?g::b -> a) => (a -> c, b) -> c
11:26:36 * cmccann takes as a rule of thumb that, if the number of flips plus half the number of (.)s is more than the total number of other functions in the expression, just use a freaking lambda already
11:27:00 <parcs> :t uncurry (. (?g .))
11:27:01 <lambdabot> forall c a b (f :: * -> *). (?g::a -> b, Functor f) => (f b -> c, f a) -> c
11:27:16 <parcs> damn
11:27:26 <kmc> that is a pretty grotesque type signature
11:28:15 <parcs> :t \(a, b) c -> a . c . b
11:28:16 <lambdabot> forall a b a1 (f :: * -> *). (Functor f) => (a -> b, f a1) -> (a1 -> a) -> f b
11:29:40 <ion> @@ @djinn @type \(a, b) c -> a . c . b
11:29:41 <lambdabot>  Cannot parse command
11:30:04 <ion> I take it djinn doesn’t like forall?
11:30:06 <obiwahn> here is an example where somebody defines plus with his onw types: plus :: N -> N -> N \n plus Zero   y=y \n plus (Succ x) y = Succ (plus x y)
11:30:15 <hpc> @. djinn type \(a, b) c -> a . c . b
11:30:15 <lambdabot> Cannot parse command
11:30:41 <ion> @@ @djinn @type \(a, b) c -> a Prelude.. c Prelude.. b
11:30:42 <lambdabot>  f (a, b) c d = a (c (b d))
11:30:52 <ion> Ah, it was the functor stuff.
11:31:12 <ion> @@ @pl @djinn @type \(a, b) c -> a Prelude.. c Prelude.. b
11:31:13 <lambdabot>  f = uncurry ((. flip (.)) . (.) . (.))
11:31:21 <obiwahn> is a plus y Zero = y missing? is that automatically derived?
11:32:03 <Jetbeard> that would match the second case
11:32:14 <derdon> ascii tits everywhere :o
11:33:17 <chaoflow> thx!
11:37:58 <chaoflow> I'm coding in python at the moment, but think the answer is in the world of haskell: I basically have an IO action that needs a key to be perfomed and I want to define a preprocessor for the key and postproc for the result
11:38:33 <merijn> chaoflow: Are you familiar with Twisted?
11:39:18 <chaoflow> merijn: A short look years ago...
11:39:57 <parcs> :t uncurry  (.: (?g .))
11:39:58 <lambdabot> forall a b a1 (g :: * -> *). (?g::a1 -> a, Functor g) => (a -> b, g a1) -> g b
11:40:14 <parcs> there we go i think
11:40:35 <kmc> obiwahn, neither.  it's just implied by the others
11:40:45 <merijn> chaoflow: You can think of Haskell's IO actions as deferred's in Twisted (or callbacks in any other event driven system), you can chain multiple callbacks to create more complicated callbacks. Except in haskell the compiler takes care of managing their interactions for you.
11:41:05 <kmc> plus Zero Zero = Zero
11:41:18 <kmc> plus (Succ x) Zero = Succ (plus x Zero)
11:41:53 <merijn> chaoflow: Main is an IO action, which is essentially the same as "run the main callback when input arrives" which can consist of both more callbacks and just normal Haskell functions
11:41:54 <kmc> obiwahn, you can convince yourself that the two equations you gave are exhaustive
11:42:13 <hpc> kmc: plus Zero x = x
11:42:32 <kmc> hpc, what about it?
11:42:39 <kmc> that is one of the two equations obiwahn gave
11:42:39 <hpc> also s/Zero/y/g in the second pattern
11:42:49 <kmc> scroll up
11:43:05 <hpc> ah
11:43:14 <kmc> i was applying y=Zero to show that those cases are already covered
11:43:28 <kmc> and therefore you don't need to write also "plus x Zero = x"
11:43:38 <chaoflow> merijn: got that
11:49:24 * hackagebot synthesizer-core 0.4.2 - Audio signal processing coded in Haskell: Low level part  http://hackage.haskell.org/package/synthesizer-core-0.4.2 (HenningThielemann)
12:07:36 <GreatGood> Anyone in the mood to field a question that is probably very stupid?
12:07:49 <kmc> always!
12:07:55 <GreatGood> Oh good.
12:08:26 <GreatGood> So, I purchased and started reading Learn You A Haskell For Great Good, and I seemed to be doing fine until i got to the part where I poen my first script...
12:08:58 <ion> Yeah, the part about poening scripts is a bit difficult at first.
12:09:02 <GreatGood> I have GHCi opening with the "ghci" line instead of "Prelude", and my baby.hs script is correct and in the directory I stared GHCi in....
12:09:05 <GreatGood> *open, lol
12:09:25 <GreatGood> *started, sorry again
12:09:32 <hpc> GreatGood: start ghci with "ghci baby.hs"
12:09:33 <ion> Exactly what does the prompt look like?
12:09:40 <hpc> perhaps?
12:09:47 <russruss> hey guys - I'm trying to learn typefamilies now but I have some sort of error I can't understand.  I'm used to fundeps.
12:10:02 <hpaste> russruss pasted “type families error” at http://hpaste.org/48923
12:10:20 <GreatGood> So the book tells me to type ":1 baby.hs", but GHCi tells me ":1" isn't a valid command
12:10:27 <GreatGood> Oh, thanks, will try that
12:10:55 <ion> 1 ≠ l
12:11:07 <cmccann> russruss, you're defining a "data" family, which needs a new constructor
12:11:13 <ion> :l is for :load
12:11:14 <cmccann> you probably wanted a type family
12:11:25 <cmccann> i.e., use "type" instead of "data" there
12:11:44 <GreatGood> ....oh. Wow. I guess I missed that on ":?"...thanks. Told you it was a stupid question...
12:12:04 <GreatGood> I'll just shift blame on that one over to Kindle's font...
12:12:05 <hpc> don't blame the question for your font's problem :P
12:12:11 <russruss> I guess I must have some misunderstanding :-\
12:12:12 <GreatGood> Heheh
12:12:17 <GreatGood> Thanks
12:12:32 <hpc> (protip: sans-sarif fonts all have this problem)
12:12:45 <merijn> hpc: No they don't
12:12:46 <russruss> compiles fine now though, thanks
12:12:48 <ion> s/all/some/
12:12:51 <hpc> most do
12:13:12 <ion> Some serif fonts also have the problem.
12:13:29 <cmccann> I knew it was a bad idea to use comic sans ms as my code editor font :[
12:13:31 <merijn> hpc: I have several programming sans-serif fonts and I always check 1, l, I, O and 0 are all clearly distinguishable :p
12:13:34 <GreatGood> I looked very closely and there IS a difference between l and 1
12:13:38 <GreatGood> Just not a big difference
12:14:07 <kmc> russruss, the same thing holds without data families
12:14:07 <hpc> GreatGood: i can imagine that being very hard to notice on a kindle
12:14:11 <ion> marijn: 0h, rea11y?
12:14:15 <kmc> in standard Haskell I can't write "data Foo a = a"
12:14:18 <kmc> i need a constructor
12:14:21 <ion> merijn even
12:14:29 <kmc> "data Foo a = Bar a"
12:14:34 <merijn> ion: My IRC font is not my terminal font, unfortunately :p
12:14:35 <russruss> okay, sure
12:14:44 <kmc> russruss, you can instead make a "type synonym family" using the "type" keyword
12:15:12 <russruss> cool :-)
12:15:14 <russruss> btw, is there any like pre-made type vector so I don't have to re-invent the wheel?
12:15:16 <GreatGood> I am loving GHCi...it kind of reminds me of the Ruby interactive interpreter
12:15:33 <hpc> @hoogle Vector
12:15:34 <lambdabot> Test.QuickCheck vector :: Arbitrary a => Int -> Gen [a]
12:15:41 <hpc> hmm
12:15:56 <russruss> err, like a list of types rather
12:15:59 <hpc> russruss: vector as in math vector, or vector as in C?
12:16:02 <cmccann> GreatGood, it's a REPL, yeah, that's pretty standard in every sane language these days
12:16:03 <hpc> ah
12:16:03 <russruss> (Int, (Bool)) etc
12:16:21 <kmc> russruss, HList?
12:16:31 <hpc> that's not a list of types though
12:16:35 <cmccann> yes it is
12:16:39 <cmccann> it's just a list of values as well
12:16:52 <ion> If only we had local, in-expression datatypes etc, ghci would be even better.
12:16:56 <cmccann> an HList is a list of heterogeneous values whose type is a list of types :P
12:16:56 <kmc> yeah ghci is a pretty good repl
12:16:58 <hpc> the type data vanishes when you put things into it though
12:16:59 <ion> So would lambdabot.
12:17:11 <GreatGood> It's still a big treat coming from C++...haven't ever tried Python and only starting on Lisp now also, so a whole new world.
12:17:14 <russruss> cmccann: cool, so that's what I want
12:17:20 <ddarius> f1 . g . f2 is the action of the hom-bifunctor, hom(f2, f1)(g)
12:18:11 <merijn> GreatGood: Python is very similar to Ruby
12:18:14 <cmccann> GreatGood, Python and most (all?) Lisps will have a REPL, too
12:18:22 <GreatGood> :D
12:18:36 <parcs> merijn: it is?
12:18:44 <hpc> python REPLs kind of suck though
12:18:45 <ion> Ruby has considerably better lambdas and its syntactic sugar for a single lambda parameter is not bad either.
12:18:57 <cmccann> Python and Ruby differ in mostly superficial ways
12:19:10 <cmccann> the sort of minor differences that nobody cares about except people who use one language and not the other
12:19:22 <hpc> the largest difference between python and ruby is guido
12:19:22 <cmccann> who will have huge ridiculous arguments about the differences
12:19:43 <merijn> parcs: Yeah, the differences are very superficial. If you can program in one you can probably productively code in the other in no time
12:19:53 <GreatGood> Does that mean Ruby is Python in a new suit? Because correct me if I'm wrong, but I thought Python was a little older than C, if not very popular.
12:19:57 <merijn> I'd argue the biggest difference between python and ruby is community
12:20:05 <kmc> yes
12:20:13 <kmc> Python is not older than C
12:20:14 <merijn> GreatGood: I'm assuming you mean C#? :>
12:20:25 <GreatGood> Yes, C#, not C
12:20:26 <kmc> C is older than most languages used today
12:20:33 <ion> Are you saying C# is newer than C?
12:20:39 <kmc> Fortran and Lisp are the two big exceptions that come to mind
12:20:46 <geheimdienst> cmccann: we haskellites prefer to have huge ridiculous arguments about putting a "split" function in base or not. which no other language seems to have trouble with.
12:20:47 <geheimdienst> :)
12:20:59 <kmc> but there are big philosophical differences between python and ruby
12:21:01 <sipa> :t split
12:21:02 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
12:21:55 <cmccann> kmc, though I think both of those have changed a lot since then, so that's sort of misleading
12:22:11 <kmc> sure
12:22:19 <kmc> but there is also plenty of Fortran code from the '60's still in use
12:22:33 <kmc> it's not like the definition of matrix multiplication has changed since then
12:22:36 <merijn> People still run mission critical stuff on Fortran77 :p
12:22:36 <cmccann> are there any philosophical differences between Ruby and Python that don't boil down to whether someone hates perl?
12:22:46 <merijn> cmccann: Not really :D
12:23:00 <kmc> cmccann, Python has the "there's one way to do it" philosophy
12:23:01 <sipa> which of both is most like perl?
12:23:06 <merijn> sipa: Ruby
12:23:11 <kmc> and I think Rubyists tolerate a lot more "magic" from their libraries
12:23:20 <kmc> unlike Perl users, the magic is actually library-side and not baked into The Interpreter
12:23:32 <cmccann> kmc, and "there's more than one way to do it" is an explicit point of pride among perl hackers
12:23:33 <merijn> sipa: Python is like "everything explicit", "one way to do it', "readability counts", etc
12:23:41 <sipa> ok
12:23:42 <cmccann> and perl is infamous for magic
12:23:54 <ion> __readability_counts__(self)
12:23:55 <Polarina> How is either Python, Ruby or Perl related to Haskell?
12:23:55 <hpc> perl can be readable
12:24:00 <hpc> and still magic
12:24:01 * sipa knows perl, but no python or ruby
12:24:04 <kmc> as i understand it the Ruby community will get aggressively condescending about things like "oh, *you* don't need to understand how Rails works.  you're just a lowly web developer"
12:24:05 <cmccann> Polarina, very little in any meaningful sense
12:24:20 <ion> polarina: They all have the + operator.
12:24:25 <cmccann> kmc, keep in mind that "the Ruby community" is not the same as "the Rails community"
12:24:31 <merijn> I think the Zen of Python make very good general design principles for programming
12:24:34 <kmc> true
12:24:45 <GreatGood> To be fair, I think the python community sometimes has something to prove (namely that it's NOT just a "Perl alternative")...
12:24:54 <merijn> The rails community seems to consist mostly of PHP refugees and incompetents
12:24:54 <c_wraith> kmc: I respond by being condescending about the quality of rails as a platform for writing software that does anything new or interesting :)
12:25:21 <ddarius> c_wraith: Why don't you respond by not using Rails?
12:25:24 <merijn> c_wraith: s/ as a platform for writing software that does anything new or interesting :)// :)
12:25:32 <danharaj_> Ruby and Rails have no reason to exist.
12:25:34 <cmccann> it's been a while since I did any ruby, but I recall a lot of rubyists who wished DHH would just shut up and go away forever
12:25:36 <kmc> GreatGood, any dynamic language could be classified as a "Perl alternative"
12:25:43 <kmc> to some people the only languages in the world are Perl and C
12:25:48 <kmc> and so of course Python is a crude ripoff of Perl
12:25:53 <kmc> however those people are wrong
12:26:03 <mm_freak> i can understand anyone, who hates PHP…  i think, almost any language is an improvement over PHP
12:26:10 <mm_freak> ruby is no exception here
12:26:11 <geheimdienst> Polarina: python, ruby, and perl are in fact related to haskell. the relation is the one of being vastly inferior to. we're just trying to ascertain the exact ways in which haskell is superior. :-)
12:26:20 <kmc> geheimdienst understands how this channel works
12:26:35 <Polarina> geheimdienst: Ah. Good luck then. :)
12:26:40 <danharaj> Python and Perl are respectable languages.
12:26:42 <GreatGood> PHP is good for when you just want to talk to MySQL and aren't feeling otherwise ambitious.
12:26:42 <cmccann> but yeah, my impression is that most of the python vs. ruby disagreements boil down to wanting to be the anti-perl vs. wanting to improve on perl by dumping in a bunch of smalltalky influences
12:26:47 <merijn> Hah, seems it is time to break out my old favorite #python quote
12:26:48 <danharaj> Ruby is superfluous.
12:26:52 <mm_freak> GreatGood: even then PHP is not good
12:26:57 <Clint> oh snap
12:27:06 <ddarius> kmc: Indeed, because every dynamic language is a crude Lisp ripoff.
12:27:08 <kmc> tbf #python has also been quite condescending with regards to questions about doing anything slightly unusual
12:27:10 <mm_freak> GreatGood: PHP is always "enough", but never good
12:27:15 <merijn> "<PenguinOfDoom> Being enlightened gentlemen, we split all programming languages into two groups, sucks and doesn't-suck and put all of them into the first group."
12:27:15 <cmccann> PHP and MySQL are the fastest way to hammer screws in when it comes to web dev
12:27:23 <hpc> merijn: what quote would that be?
12:27:27 <GreatGood> Lisp vs Haskell flamefest, go go!
12:27:27 <mm_freak> cmccann: wrong
12:27:28 <kmc> they get so many noobs that the assumption is "you're doing the wrong thing" and not "you can't do the easy thing for good, complex reasons"
12:27:41 <ion> “Lobotomy is good for when you just want to get rid of your prefrontal cortex and aren’t feeling otherwise ambitious.”
12:27:43 <geheimdienst> @remember PenguinOfDoom Being enlightened gentlemen, we split all programming languages into two groups, sucks and doesn't-suck and put all of them into the first group.
12:27:44 <lambdabot> Done.
12:27:54 <merijn> geheimdienst: I think I already added it before :p
12:27:57 <mm_freak> cmccann: i get a mostly static site running with haskell, yesod and postgresql much faster than with PHP and mysql
12:28:07 <cmccann> all languages are terrible, but some are more terrible than others
12:28:07 <danharaj> PHP isn't for static sites, is it?
12:28:19 <mm_freak> danharaj: PHP is actually fine for static sites
12:28:24 <mm_freak> i.e. when you never use <?php ?>
12:28:30 <danharaj> heh.
12:28:32 <sipa> sure it is, just rename .html to .php, and it works :D
12:28:32 <merijn> :D
12:28:43 <kmc> mm_freak, indeed, that subset of the language has been standardized by the W3C
12:28:44 <cmccann> for a while, the rails web page was actually running on php for exactly that reason
12:28:59 <ion> PHP has some nice functionality Haskell doesn\'t have out of the box\, such as escaping dangerous characters\, so that you can feel safe when dumping strings from malicious users directly to SQL statements\.
12:29:03 <cmccann> because the overhead of routing mostly static stuff through rails wasn't worth it
12:29:17 <GreatGood> @cmccann: For irony?
12:29:18 <lambdabot> Unknown command, try @list
12:29:18 <mm_freak> kmc: yeah…  it's not extremely good, but the real awkward part starts, as soon as you make use of the <?php ?> stuff
12:29:32 <GreatGood> @list
12:29:32 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
12:29:33 <kmc> PHP has nice features like including source code over unencrypted HTTP
12:29:36 <kmc> facilitates code reuse
12:29:43 <danharaj> yes
12:29:44 <merijn> ion: Yet I feel somehow confident saying that the percentage of sites with SQL injections is higher for PHP sites than haskell sites
12:29:45 <danharaj> and code sharing
12:29:46 <kmc> just import your competitor's PHP script
12:29:52 <danharaj> PHP was made to spread FOSS
12:29:53 <kmc> no need to copy it and waste disk space
12:30:10 <cmccann> PHP has other benefits, like providing built-in database administration to your web site via sql injection
12:30:11 <zomg> kmc: bet it works nicely when all you get is the html output though :p
12:30:25 <mm_freak> ion: wrong…  HDBC gives you the same functionality in a much nicer interface than any of the known PHP libraries
12:30:45 <zomg> mm_freak: I'm pretty sure he was refering to magic quotes
12:30:49 <mm_freak> and if that's not enough, you have great abstraction libraries like HaskellDB, takusen or persistent
12:31:04 <danharaj> and if you want a full blown framework...
12:31:08 <ion> mm\_freak\: I bet HDBC still doesn\'t make Haskell escape universally dangerous characters in \*all\* incoming strings\.
12:31:19 <mm_freak> magic quotes don't make sense in haskell
12:31:31 <cmccann> mm_freak, anyway, perhaps for you personally, but I remain skeptical that it will ever be faster to write something in Haskell compared to writing something horribly broken in a "scripting" language
12:31:33 <mm_freak> haskell has no magic for GET/POST stuff
12:31:35 <zomg> ion: although all sensible PHP deployments since 5.2 or so have had magic quotes disabled by default ;)
12:31:51 <ion> “sensible PHP deployments” you say?
12:31:52 <mm_freak> cmccann: i do it on an everyday basis for a living
12:31:59 <GreatGood> Horribly broken languages can be surprisingly useful.
12:32:06 <cmccann> if you specify that the php app has to not be buggy and full of security holes, then yes, haskell and yesod will of course be faster :P
12:32:12 <danharaj> Haskell is a broken language.
12:32:19 <GreatGood> I mean honestly, it's not unfair to say that Linux originated as a thoroughly hacked and broken UNIX
12:32:22 <kmc> writing code in Haskell is slower because the tools actually make a token effort to prevent you from writing incorrect things
12:32:37 <kmc> this of course gets in the way of the agile scrum web-speed development cycle, in the cloud
12:32:52 <mm_freak> cmccann: writing any nontrivial app is easier in yesod, even if you don't specify that
12:32:53 <hpc> writing programs in haskell is faster because the toold prevent you from writing incorrect things ;)
12:32:58 <merijn> GreatGood: Originally? I'd argue it is still broken unix :p
12:33:03 <kmc> everyone knows the best way to write software is to start with something utterly broken and then slap on fixes until it passes each of the up to several test cases you've thought of
12:33:11 <geheimdienst> yes, but writing incorrect things has a way of harassing you in the following months and years
12:33:40 <GreatGood> merijn: I didn't want to offend anyone, but...yeah, pretty much Linux advances BY breaking itself in convenient ways.
12:33:43 <merijn> Anyone who argues differently must not be diving into kernel functionality and driver code yet >.>
12:33:43 <Polarina> hpc: Except that in Haskell, you have to fix those incorrect things which you could otherwise get away with.
12:33:44 <cmccann> mm_freak, I'll take your word for it I guess? I've never really used PHP so I don't have much basis to compare building something nontrivial
12:34:13 <mm_freak> cmccann: in my work i sometimes have to use the worst case combination:  PHP + zend framework
12:34:24 <cmccann> mm_freak, sounds delightful
12:34:29 <zomg> mm_freak: out of curiosity, why is ZF a "worst case combo"? :P
12:34:33 <ddarius> cmccann: Yes many Haskellers are tripped up by that.  Someone comes in and ask "How do I do X?"  They respond, "Well you'll want this library and have to do this and you probably want to structure your code in this way."  The response they get, "I can do this in like two lines in Perl. See."  "That's broken in this, this, and this way."  "I don't care it works well enough."
12:34:34 <danharaj> I thought cold fusion or ASP was the worst case.
12:34:48 <mm_freak> zomg: because it's patchwork, sparsely documented, etc.
12:34:59 <zomg> Patchwork how exactly?
12:35:04 <ddarius> cmccann: Haskellers think people are actually trying to solve the problem -correctly- or at all.
12:35:16 <mm_freak> it has started as a simple web library, but then the devs felt like force-connecting everything into a web "framework"
12:35:26 <zomg> Well, don't want to argue, but honestly speaking I've used it a lot and it's much better than any of the alternatives available for PHP =)
12:35:34 <zomg> With maybe the exception of Symfony 2
12:35:44 <cmccann> ddarius, agreed
12:35:52 <zomg> I don't recall it having started as a "simple" library though
12:35:56 <merijn> ddarius: Well, sometimes the ease of experimenting is nicer then correctness if you have no clue what you are trying to do yet
12:35:56 <mm_freak> zomg: ZF is fine as a library, if you want to get to the result faster
12:36:04 <mm_freak> but as a framework it really sucks
12:36:30 <mm_freak> you see the "library" part, when you look at the reference documentation
12:36:41 <zomg> If ZF sucks as a framework then all the other PHP frameworks suck even more :]
12:36:51 <cmccann> ddarius, I've argued for a while that most of Haskell's perceived "difficulty" is a combination of unfamiliarity and an expectation of not writing horribly broken code in the first place
12:36:58 <mm_freak> there are a bunch of classes, which are loosely related to each other…  some of them derive from others, but in general there is little glue
12:37:14 <zomg> It's a loosely coupled framework
12:37:23 <mm_freak> zomg: it's not really easy to come up with a good framework in PHP =)
12:37:35 <zomg> I think that's one of the bigger pros because you can just replace parts of it easily rather than being forced to use whatever the devs chose for you
12:38:31 <mm_freak> zomg: well, don't you find it frustrating to address parts of the current application state by string indices?
12:38:45 <zomg> Huh?
12:38:46 <merijn> On unrelated note: If I want to persist relational data, what's the best library (directly to disk, database, whatever, not having to set up anything outside Haskell would be a pro)
12:38:48 <ddarius> merijn: The cases I'm thinking of particularly were definitely not cases of "experimenting."
12:39:00 <hpc> merijn: sqlite
12:39:08 <mm_freak> zomg: $this->getInvokeArg('bootstrap') ⇐ there are a lot of these things in ZF
12:39:13 <mm_freak> it's a mess
12:39:17 <zomg> Ah
12:39:21 <ddarius> merijn: For example, using regular expressions for non-regular languages.
12:39:26 <mm_freak> do you understand the meaning of this without looking into the documentation?
12:39:28 <zomg> I suppose they could've used some sort of IOC stuff
12:39:31 <hpc> merijn: in terms of not setting things up outside haskell, at least
12:39:34 <merijn> ddarius: One of my pet peeves :>
12:39:40 <zomg> mm_freak: You're right, most people don't
12:39:56 <merijn> hpc: Any nice bindings for Haskell?
12:40:02 <mm_freak> it's not entirely ZF's fault…  PHP is a poor language to begin with
12:40:04 <zomg> but I would say that it's an issue not only with ZF... Most things that are a bit more complex aren't exactly obvious right off the bat
12:40:31 <hpc> merijn: hdbc-sqlite iirc
12:40:50 <mm_freak> anyway, i have the direct comparison between PHP and haskell at work
12:40:50 <hpc> (might not be "nice" but it resembles the perl dbi model, which i find comfortable)
12:41:16 <zomg> mm_freak: I could probably learn 10 zf-like frameworks in the time I've spent (and failed) to learn haskell properly :D
12:41:48 <mm_freak> haskell: fast (both development and runtime performance), correct, powerful; PHP: slow (again both), buggy, poor language
12:42:07 <mm_freak> zomg: ok, that's a point for PHP
12:42:15 <mm_freak> haskell takes more time to learn
12:42:42 <danharaj> How does Yesod stack up against Django and Rails performance-wise?
12:42:49 <kmc> you keep talking about ZF and I keep thinking Zermelo-Frankel
12:42:51 <danharaj> (Yesod + Warp)
12:42:59 <cmccann> rails has performance?
12:43:03 <mm_freak> danharaj: i don't know
12:43:05 <kmc> danharaj, if you're running Django on CPython then I expect no contest
12:43:06 <cmccann> must be a new feature since last time I tried it
12:43:16 <ddarius> danharaj: I'm pretty sure it blows them out of the water, but they aren't completely comparable for many reasons.
12:43:30 <danharaj> cmccann: Rails is one of the control groups. The other is a receding glacier.
12:43:39 <cmccann> danharaj, :D
12:43:54 <mm_freak> danharaj: but for me a combination of nginx, postgresql, yesod (HDBC instead of persistent) and warp turned out to perform extremely well
12:43:56 <kmc> CPython is one of the worst interpreters in common use today
12:44:10 <danharaj> kmc: but it has a C in the name, it has to be fast!
12:44:14 <kmc> that's right
12:44:39 <mm_freak> danharaj: note that yesod apps get compiled to native code and run as daemons
12:45:08 <cmccann> really, assuming reasonable levels of competence using each, Haskell will easily outperform most dynamic "scripting" languages
12:45:21 <danharaj> I thought you could compile Python.
12:45:25 <danharaj> Shows my ign'nce.
12:45:26 <hpc> you can
12:45:34 <kmc> you can compile any language
12:45:35 <hpc> it compiles to a .pyc file
12:45:51 <kmc> yes, the .pyc file contains bytecodes which are then poorly interpreted by CPython
12:46:00 <danharaj> I meant compiled to native code :p
12:46:17 <kmc> danharaj, berp compiles Python to native code
12:46:21 <kmc> so does PyPy?
12:46:37 <danharaj> How is berp coming along anyway?
12:46:38 <kmc> also Jython and IronPython (because common JVMs / CLRs do)
12:46:43 <luite> I don't think haskell already outperforms the other web frameworks in development speed... and runtime speed is probably less important than many people make it out to be...
12:46:43 <kmc> but CPython does not
12:46:46 <danharaj> I remember when it was released but haven't heard since.
12:46:49 <mm_freak> it's funny to see how companies employ large server farms to deal with the poor performance of PHP and MySQL…  often combined with bad programmers and a bad database configuration
12:46:55 <hpc> kmc: oh man, you just gave me the most hilarious image
12:47:08 <hpc> kmc: of python being jython-compiled, then gcj-compiled
12:47:14 <kmc> haha
12:47:18 <companion_cube> -_-
12:47:20 <kmc> does GCJ support compiling JVM bytecodes?
12:47:23 <zomg> Maybe I shall practice my haskell-fu by writing this png image to json converter in Haskell instead of python...
12:47:29 <zomg> Already managed to run out of memory once with this
12:47:31 <zomg> =)
12:47:33 <kmc> anyway it's clear that JIT is the way to go for a language like Python
12:47:38 <luite> png to json? sounds like a great idea :p
12:47:47 <kmc> in fact I increasingly think JIT is the way to go for almost every compiler
12:48:04 <kmc> even languages which *can* be compiled ahead-of-time can be optimized much more aggressively at runtime
12:48:05 <companion_cube> cpython is so conservative, they still have the biglock
12:48:05 <luite> yeah I would be extremely interested in a tracing JIT for haskell
12:48:06 <zomg> luite: oh it's an experiment mostly. Just want to grab the RGB values off the image and dump them in an array
12:48:06 <danharaj> hmm, that would be a cool addition to GHC's RTS
12:48:16 <kmc> there's some people working on Haskell JITs
12:48:18 <mee> kmc: yeah, JIT is pretty neat
12:48:18 <kmc> but i forgot who :/
12:48:19 <luite> so someone get the funding and I'll help ;p
12:48:25 <danharaj> kmc: Wizards.
12:48:29 <zomg> luite: using it as a sort of a map generator for something I made in JS... Loading the image directly works, but consumes a crapton of memory
12:48:30 <ion> zomg: Why do you want that in JSON?
12:48:34 <danharaj> I'm pretty sure GHC is maintained by wizards.
12:48:37 <hpc> runghc with JIT would be kind of awesome
12:48:38 <merijn> ion: Why not? :p
12:48:41 <kmc> luite, yeah, i prefer to make the speed argument in the other direction... when people whine about GHC code being sometimes 5 times slower than C, I point out the amount of problem-solving / money-making that is done with PHP and Python
12:48:51 <ion> zomg: What’s wrong with just using the original PNG?
12:49:05 <kmc> if your JIT is good you want to use it for *everything*
12:49:06 <danharaj> I find memory consumption to be a more hairy issue than speed.
12:49:08 <zomg> ion: memory consumption is gigantic.. want to see if it consumes less if it's just json
12:49:10 <kmc> including the "compiled" output of ghc --make
12:49:34 <zomg> ion, luite, see here for what I mean.. basically the "map" in that is the PNG image http://jjh.fi/d/wings/
12:49:46 <danharaj> You can know you're getting a predictable constant factor over C once you weed out the big performance leaks. I still don't understand how to reason about memory consumption.
12:49:54 <kmc> yeah
12:50:12 <kmc> fortunately memory is still getting cheaper
12:50:15 <luite> hmm, I don't really have a predictable constant either :)
12:50:16 <danharaj> Also the constant factor is a single digit :p
12:50:18 <kmc> while per-core CPU performance has plateaued
12:50:28 <luite> unless it's something between 1.1x and 100x
12:50:51 <companion_cube> in this context of haskell vs bad languages™, how do you compare it to ocaml ?
12:50:59 <companion_cube> (which iirc also has a web framework)
12:51:15 <danharaj> ocaml is a great language but does anyone actually use the 'o'?
12:51:17 <mm_freak> kmc: there is an even more convincing argument:  when people tell me that my haskell code runs two times slower than their C code, then i tell them that my haskell code has long performed its work, while they are still debugging their C implementations
12:51:21 <ion> zomg: So, instead of a bitmap in memory, having each subpixel’s color value as an integer object within an array object might take less memory in the browser?
12:51:26 <merijn> kmc: Memory is cheap, but memory also ruins performance
12:51:33 <kmc> true merijn
12:51:38 <zomg> ion: yeah sounds wonky but wouldn't be the first time
12:51:39 * hackagebot web-routes-happstack 0.22.2 - Adds support for using web-routes with Happstack  http://hackage.haskell.org/package/web-routes-happstack-0.22.2 (JeremyShaw)
12:51:47 <merijn> In fact, I would wager most performance issues are indirectly memory related
12:51:52 <danharaj> You can't take advantage of cache coherency in your data without resorting to wizard libraries and unboxed types.
12:51:54 <luite> mm_freak: that argument doesn't reall work against python or ruby though
12:51:55 <zomg> ion: the whole canvas thing has such awfully poor perf even things like SNES prob had better 2D perf..
12:51:57 <merijn> Caches being ruined, etc
12:51:57 <ion> Oh, s/integer/float/ since JavaScript doesn’t have integers.
12:52:01 <kmc> i wonder if one day you'll have to choose between a 16-core chip and a 4-core chip with four times the cache
12:52:07 <danharaj> oh god
12:52:10 <kmc> either could be better for some applications
12:52:21 <danharaj> 'four times the cache' elicited an emotional high in me
12:52:35 <merijn> danharaj: I know the solution, remove cache coherency and do it in software! :)
12:52:47 <danharaj> merijn: I know what to do! Make everything SRAM!
12:52:49 <companion_cube> javascript has no int ? how remarkable
12:52:55 <danharaj> 4 GB L3 cache.
12:53:09 <merijn> That'd be hella expensive though
12:53:09 <mm_freak> luite: but python and ruby code doesn't run faster than haskell code
12:53:23 <hpc> this makes me wonder what 4GB of L1 would perform like
12:53:30 <merijn> Software cache coherency is actually doable and quite interesting :)
12:53:33 <kmc> i think that's effectively impossible
12:53:38 <danharaj> the speed of light gets in the way
12:53:40 <kmc> addressing memory is not actually an O(1) operation
12:53:41 <luite> mm_freak: true, but you probably have a working application faster
12:54:06 <hpc> luite: not really
12:54:06 <danharaj> It grows like, what? O(sqrt N)?
12:54:10 <hpc> luite: you have an application faster
12:54:19 <danharaj> Well sqrt when you're on the die, then it gets hairier
12:54:30 <danharaj> maybe cube root when you're on hard disks.
12:54:37 <luite> hpc: I think even a working application if it's about web sites that mostly rely on existing web frameworks like django or rails
12:55:16 <luite> haskell may be a better language with better compiler, but the web frameworks and related libraries are not nearly as mature yet
12:55:27 <luite> though a lot of great development is going on
12:56:09 <mm_freak> luite: depends on the application
12:56:14 <luite> very much
12:56:14 <russruss> yeah I mean its hard to do something like django or rails without too much magic for this community
12:56:16 <danharaj> The yesod people have an advantage when it comes to catching up.
12:56:30 <danharaj> They're using a better language. :p
12:56:32 <mm_freak> you may be faster writing a GUI in python/ruby, but you will be faster writing a server application in haskell
12:56:38 <merijn> danharaj: Also, they're not idiots
12:56:45 <mm_freak> haskell solves actual problems =P
12:56:48 <danharaj> merijn: Let's not get political now :p
12:56:50 <russruss> snap is nice, too :-)
12:56:52 <Clint> too bad yesod can't be built with stuff entirely in hackage
12:57:03 <ion> They seem to have to use slightly hairy TH stuff, though.
12:57:06 <danharaj> it can't? I built it the other day.
12:57:15 <Clint> no, it needs a utf-8 fork of alex
12:57:20 <danharaj> o.O
12:57:24 <danharaj> Where the hell did I get that then.
12:57:30 <danharaj> I am confused.
12:57:35 <luite> oh I never really noticed that :p
12:57:37 <Clint> dunno, language-javascript needs it
12:58:46 <danharaj> strangeness.
13:00:29 <mm_freak> Clint: what do you mean?
13:00:38 <mm_freak> ion: TH is optional, but very handy
13:00:59 <Tomsik> I find TH to be work of the devil
13:01:08 <Tomsik> Especially in Yesod
13:01:29 <Clint> mm_freak: i mean that the language-javascript library can't be built with stock alex
13:01:32 <erus`> if i do "let foo = 123 in add foo 123" why doesnt it try to apply/call 123 to/with foo?
13:01:47 <mm_freak> Clint: dunno, it built fine for me
13:01:48 <kmc> why would it?
13:01:55 <kmc> erus`, (f x y) is ((f x) y)
13:02:11 <erus`> ok then look at this
13:02:22 <Clint> mm_freak: confusing
13:02:24 <mm_freak> Tomsik: TH is fine the way yesod uses it…  it really saves you a lot of code and gives you some further static guarantees
13:02:30 <erus`> > let foo x = 3 in (+) foo 1 2
13:02:30 <lambdabot>   4
13:02:34 * cmccann is warming up to TH these days
13:02:38 <erus`> ok hang on
13:02:46 <kmc> erus`, that works in lambdabot due to weird instances
13:02:53 <erus`> that gave me an error :|
13:02:55 <cmccann> it still seems ugly and clumsy, but can be useful
13:02:58 <kmc> it does not work in a normal Haskell environment with just Prelude loaded
13:03:02 <kmc> > 2 3
13:03:03 <lambdabot>   2
13:03:11 <hpc> > let x = 5 in let x = 2 in x + x
13:03:12 <lambdabot>   4
13:03:16 <hpc> > let x = 5 in let x = 2 in x+x
13:03:17 <lambdabot>   4
13:03:19 <mm_freak> i wouldn't want to /write/ TH functions
13:03:24 <Tomsik> > 1 1 1
13:03:24 <lambdabot>   1
13:03:27 <mm_freak> but i have no problem with using them =)
13:03:30 <kmc> > iterate 1 1
13:03:31 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
13:03:36 <hpc> > (do {1;2;3;4}) 5
13:03:37 <lambdabot>   4
13:03:41 <erus`> ok but in the real ghci this gives an error
13:03:44 <kmc> yes
13:03:46 <kmc> as it should
13:03:57 <kmc> lambdabot has a weird instance (Num a) => Num (b -> a)
13:04:08 <Clint> mm_freak: https://github.com/alanz/language-javascript/blob/master/README
13:04:11 <mm_freak> > (sin^2 + cos^2) 5
13:04:11 <hpc> an awesome instance
13:04:12 <lambdabot>   0.9999999999999999
13:04:13 <Tomsik> mm_freak: I'm aware of that, it just doesn't fit well syntax-wise with the rest of code
13:04:16 <hpc> that gets used for strange things
13:04:24 <ion> When someone provides you with a nice TH-based API where you get to use nice QQ and splice stuff, everything is great. When you have to implement said API (generating Haskell AST) everything is not that great. :-P
13:04:24 <kmc> erus`, but "let foo = 123 in add foo 123" is totally fine
13:04:43 <mm_freak> Tomsik: yes, the routes are not quoted =)
13:04:53 <mm_freak> it doesn't bother me though
13:05:11 <erus`> the difference is, if a function has no arguments, then it doesnt try to apply anything to it
13:05:20 <mm_freak> the only thing is that i stopped using yesod's 'persistent' library
13:05:21 <kmc> there is no such thing as a function with no arguments
13:05:21 <erus`> like in my first example
13:05:25 <Tomsik> It bothers me more that hamlet doesn't get along well with common haskell operators
13:05:25 <kmc> every function has one argument
13:05:32 <kmc> when you say "let foo = 123", foo is not a function
13:05:34 * cmccann actually doesn't care for some of yesod's magic quoting syntax stuff, particularly hamlet
13:05:34 <kmc> it's a number
13:05:42 <Tomsik> and you have to write #{f(g x)} instead of #{f . g $ x}
13:05:53 <cmccann> but TH overall is pretty useful for stuff like yesod does
13:05:59 <erus`> ugh
13:06:16 <erus`> the rules for this seem overly complex
13:06:17 <mm_freak> Tomsik: i prefer not to have such a thing in templates anyway…  a template gets mostly only ready-to-display data from me
13:06:17 <cmccann> rather, I don't care for the syntax of stuff like hamlet, I'm fine with the quoting stuff
13:06:28 <kmc> erus`, you are making it complex
13:06:37 <mm_freak> what i really love is the new lucius syntax for CSS
13:06:46 <kmc> functions are values.  numbers are also values.  "let" assigns a local name to a value and does not care whether it's a function or a number
13:06:48 <erus`> kmc im trying to write a parser that works like ghc
13:06:52 <mm_freak> it actually makes CSS sane to use by allowing nested blocks =)
13:06:54 <erus`> without any infix functions
13:07:12 <kmc> erus`, why not use an existing Haskell parsing library
13:07:13 <ion> Use Parsec or equivalent.
13:07:16 <erus`> any specs on the web?
13:07:27 <kmc> use haskell-src-exts
13:07:37 <kmc> if you want to read about the Haskell grammar, that's in the Haskell Report
13:07:44 <kmc> your confusion above does not seem to be a grammar / syntactic confusion
13:09:13 <Tomsik> mm_freak: You kind of have to do this with $forall and even if you just give it prepared names, these names have to be the same in every source file you use the template
13:09:48 <erus`> kmc its just that i get an error if i try to apply 2 to 2
13:09:56 <erus`> unless its after a function name
13:10:08 <kmc> that's incorrect
13:10:10 <kmc> f (2 2) is also an error
13:10:19 <kmc> (f x y) is ((f x) y) not (f (x y))
13:10:35 <hpc> > const () True
13:10:35 <lambdabot>   ()
13:10:40 <hpc> > (const ()) True
13:10:41 <lambdabot>   ()
13:10:45 <hpc> > const (() True)
13:10:45 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool -> a'
13:10:46 <lambdabot>         against inferred ...
13:10:51 <erus`> omg i am making this complicated
13:10:52 <kmc> in GHCi try "subtract 2 3" and "subtract (2 3)" and "(subtract 2) 3"
13:11:03 <mm_freak> Tomsik: that's a common problem in templates
13:11:17 <kmc> erus`, in Haskell a "two-argument" function is really a one-argument function that returns a function to consume the second argument
13:11:23 <kmc> that's why (f x y) is ((f x) y)
13:11:27 <mm_freak> Tomsik: but you can define a type, which is used for rendering only
13:11:33 <kmc> which in C syntax would be (f(x))(y)
13:11:37 <mm_freak> a record type, which contains rendered fields
13:11:38 <kmc> (now you can see why we don't use C syntax :D)
13:11:52 <Tomsik> I don't quite understand why they are not generating closures
13:12:11 <Tomsik> Like, a template would be a function Int -> [String] -> Bool -> HtmlStuff
13:15:58 <Draconx> kmc, to be fair, (f(x))(y) in C syntax is equivalent to f(x)(y).
13:16:01 <cmccann> Tomsik, couldn't you do that anyway? Just have templates in a Haskell file with a bunch of functions that bind arguments for a single template
13:16:39 <Tomsik> hmm
13:17:12 <Tomsik> I think you're right, it would actually be trivial to do and ghc would notice when you modify these files and recompile too
13:18:05 <Tomsik> Why didn't I think of that? :)
13:18:08 <cmccann> Tomsik, basically what you're complaining about is the fact that the hamlet templates are spliced in directly where mentioned... so you can do exactly that, and spice them into a function
13:18:21 <luite> doSomethingHamlet p1 p2 = [hamlet|<p #{p1} #{p2} |]  ?
13:18:36 <luite> is that not what you want?
13:18:40 <cmccann> Tomsik, because you're used to frameworks like this having lots of fragile magic that doesn't behave sensibly? :P
13:19:02 <Tomsik> Probably, I kind of treat Yesod like a big black box for most of the time
13:19:15 <cmccann> Yesod has less magic than it seems like at first, really
13:19:29 <luite> and less documentation ;p
13:19:37 <cmccann> that's improving, isn't it?
13:19:41 <ddarius> Haskell makes making magic difficult.
13:19:49 <earthy> ??
13:19:51 <russruss> yeah, it totally scared me away with stuff that looks like magic... I've been using snap which is really clean and well documented
13:19:57 <Tomsik> I'd rather say that Haskell is magic in its very essence
13:19:58 <luite> cmccann: hehe it should be, but they keep writing new stuffs ;p
13:20:11 * earthy agrees with Tomsik
13:20:16 <Tomsik> Especially the GHC extensions
13:20:22 <earthy> 'technology sufficiently advanced' :)
13:20:36 <merijn> Hmm, where can I get "global state" deprogramming? Somehow global state seems to be something I rely on by default and I can't seem to warp my brain enough to do my entire code without it
13:20:45 <hpc> that should be the haskell catchphrase
13:20:46 * cmccann enables {-# LANGUAGE HaltingOracle #-}
13:20:55 <hpc> "sufficiently advanced technology"
13:21:10 <ddarius> Even most of the GHC extensions are sensible and coherent with no DWIM or special cases provided.
13:21:21 <cmccann> hpc, GHC is already getting close to being the sort of "sufficiently smart compiler" that people talk about
13:21:29 <cmccann> ddarius, overlapping instances?
13:21:43 <ddarius> cmccann: Overlapping instances aren't sensible.
13:21:55 <cmccann> ddarius, that's what I thought. just checking :]
13:23:05 <parcs> what exactly does the word 'magic' mean, anyway?
13:23:20 <zomg> Implicit functionality I guess?
13:23:32 <zomg> Or sort of
13:23:57 <kmc> i associate 'magic' with 'lots of special case rules'
13:24:06 <kmc> Haskell seems magical at first because its rules are different
13:24:11 <kmc> but there are actually relatively few of them
13:24:47 <kmc> each TH quasiquoter adds new syntactic rules, unless you actually go read the quasiquoter source code and treat it as a library
13:25:11 <cmccann> magic means "features you don't understand but use anyway"
13:25:26 <kmc> my CPU is magic then
13:25:32 <luite> kmc: hmm, not really imho, since many of the quasiquoters do things that normal libraries don't
13:25:33 <ion> runFoo (parseFoo "my special syntax")  -- special syntactic rules without TH
13:25:35 <cmccann> kmc, for all practical purposes, it is
13:25:41 <kmc> sure
13:25:49 <kmc> a lot of GHC's extensions actually remove special-case rules
13:25:57 <luite> kmc: like accessing names from the local scope (hamlet), or generating lots of data types based on yorur own (persistent)
13:26:12 <cmccann> kmc, the difference is that unlike what's typical in software, hardware tends to work mostly correctly
13:26:25 <cmccann> so it's well-behaved magic you can not think about
13:26:41 <cmccann> leaky magical abstractions are where things start getting bad
13:27:06 <kmc> cmccann, true, although the line shifts dramatically once you care about performance
13:27:21 <merijn> cmccann: Beware who you say that too :p
13:27:47 <mee> impe, "magic" is often bugs that got cemented in the code base and now can't be removed without breaking something (usually backwards compat.)
13:28:30 <cmccann> mee, also undefined behavior that people started relying on because it was usually consistent
13:28:37 <cmccann> that happens a lot, actually
13:28:41 <merijn> cmccann: I was hanging out with some guys from Intel Labs last week, in a discussion on memory reliability I said "well, since switching to transistors the issues with memory errors have been solved". I don't think I have ever had such a swift verbal beat down in the time it took me to add "from a software perspective!" :p
13:28:43 <mee> yup
13:29:05 <cmccann> merijn, hahaha, yeah, but those are the guys who make the magic happen
13:29:20 <Tomsik> Honestly, how could you show that your computer is not in fact powered by spirits that go through the cable? And that it's generally some weird voodoo magic?
13:29:30 <Tomsik> Without excessive resources, could you?
13:29:32 <merijn> Tomsik: Mine is powered by magic smoke
13:29:51 <cmccann> people still make fun of intel for that one floating point bug, whereas critical security holes in major software packages are just ho hum, another day
13:30:06 <ddarius> Tomsik: If you give me a falsifiable description of such, I'll show you.
13:30:29 * cmccann defines "spirits" as "electrons"
13:30:33 <earthy> merijn: umm, actually, the space shuttle for a *long* time used magnetic core memory, because it was more reliable
13:30:34 <Tomsik> ddarius: you can give an explanation, but you couldn't appeal to senses in any way
13:30:38 <ddarius> Tomsik: But if your description allows that everything that is done with electrons can also be done with spirits, then you can't falsify that.
13:31:02 <merijn> earthy: I'm talking about even earlier when they used whatchamacallit tubes
13:31:03 <Tomsik> I mean, try explaining how computer works to man from 1920
13:31:15 <earthy> (and in fact, only when the memory density was high enough that they could fit all the shielding required around it in the same space as the core required did they switch)
13:31:28 <earthy> merijn: vacuum tubes ;)
13:31:29 <hpc> Tomsik: depends on the man
13:31:31 <hpc> ;)
13:31:35 <ddarius> Tomsik: Okay, I'll explain it to von Neumann.
13:31:46 <cmccann> haha
13:31:47 <Tomsik> Dammit
13:31:47 <earthy> they weren't used for memory much afaik
13:32:02 <earthy> mercury delay lines, core, magnetic drums...
13:32:12 <deech> Hi all, does anyone know how to import an existing Cabal project into your Leksah workspace?
13:32:14 <earthy> not tubes, as they were *way* too expensive. ;)
13:32:14 <merijn> I'll pick Babbage if we have to explain to someone much longer ago :>
13:32:26 <ddarius> Tubes would make -horrible- memory.
13:32:32 <merijn> ddarius: They did
13:33:27 <kmc> there was some CRT-based memory as well
13:33:45 <Jetbeard> CRT memory is awesome for debugging
13:33:56 <kmc> for explaining computers to people in the '20's i would use relays, not tubes
13:34:09 <ddarius> My impression, incidentally, is that "modern" people dramatically underestimate the intelligence of earlier people.
13:34:19 <kmc> a relay is a better and simpler model for a MOSFET
13:34:29 <kmc> ddarius, indeed
13:34:33 <merijn> ddarius: Agreed
13:34:39 <ddarius> Relayas would probably be what were used.
13:34:42 <hpc> ddarius: to be fair, a lot of people struggle to learn how computers work now
13:34:54 <kmc> all sorts of complex logic was implemented with relays, tubes, gears, levers, hydraulics, etc. before computers
13:34:55 <merijn> hpc: Almost no one tries
13:35:03 <ion> Relays work with spirits moving the parts.
13:35:06 <merijn> hpc: They struggle to learn how to use computers
13:35:21 <hpc> even the ones that try
13:35:31 <merijn> Which is not the same as learning how computers work
13:36:38 <Tomsik> It's just that there's a huge mountain of gigants, who have really big shoulders
13:37:10 <Jetbeard> I think part of the problem is that everybody these days learns how to use a computer before learning how they work
13:37:46 <Draconx> Jetbeard, this is true in almost every field of study.
13:38:34 <companion_cube> but the interesting point with programming is that you can write code without knowing the intimate details of how the computer works (only some intuition about memory, cache and OS)
13:38:39 <mm_freak> Jetbeard: do you seriously view this as a problem?
13:39:06 <mm_freak> the main problem here is that most people learn programming before learning how to program =)
13:39:19 <hpc> haha
13:39:31 <merijn> s/how to program/how to think/
13:39:52 <merijn> The hardest part of programming is thinking, the code writing bit is trivially easy
13:40:45 <mm_freak> i guess most programmers interested in haskell have already stumbled upon the problem of not thinking before doing and how haskell can save them
13:42:57 <dixie> mm_freak: i have been able to skip thinking before doing also with haskell :]
13:43:16 <mm_freak> dixie: yes, you can omit the type signatures =)
13:43:20 <mm_freak> but i wouldn't do that
13:43:52 <Jetbeard> i always write type signatures, they help clarify what the function does before i write it
13:44:09 <Jetbeard> my fellow students think this is stupid because haskell's so good at type inference
13:45:11 <Tomsik> I write the type signatures too, probably most of people do
13:45:18 <cmccann> Jetbeard, it's just preemptively arguing with the compiler about what the code means
13:45:36 <cmccann> you'll always lose the argument of course, but getting a head start on losing it means you get the final program done sooner
13:45:43 <merijn> I only write top level type signatures
13:46:53 <parcs> i annotate every single expression
13:47:46 <nus> how do you get along with strictness annotation?-)
13:47:51 <Tomsik> > ((+) :: Integer -> Integer -> Integer ) (1 :: Integer) (1 :: Integer)
13:47:51 <lambdabot>   2
13:48:07 <Tomsik> or better yet
13:48:24 <mm_freak> Tomsik: you have missed something
13:48:37 <shachaf> > (((+) :: Integer -> Integer -> Integer ) (1 :: Integer) :: Integer -> Integer) (1 :: Integer) :: Integer
13:48:38 <lambdabot>   2
13:48:47 <djahandarie> lol
13:48:50 <Tomsik> > ((+) :: Num a => a -> a -> a ) (1 :: Num a => a) (1 :: Num a => a) :: Num a => a
13:48:51 <lambdabot>   2
13:48:52 <mm_freak> now it's complete
13:48:57 <shachaf> Come on, Tomsik, not everyone is a type inferencer.
13:48:59 <mm_freak> Tomsik: still incomplete
13:49:05 <Tomsik> How so?
13:49:22 <shachaf> You're missing the type for the first application.
13:49:22 <cmccann> sheesh, that's almost as many type annotations as java needs
13:49:26 <merijn> The curried one
13:49:29 <Tomsik> Oh damn
13:49:41 <Tomsik> You're right
13:50:30 <Tomsik> I was quite surprised to learn that Java has some restricted type inference
13:50:56 <jmcarthur> > (((+) :: Num a => a -> a -> a ) (1 :: Num a => a) :: Num a => a -> a) (1 :: Num a => a) :: Num a => a
13:50:57 <lambdabot>   2
13:50:58 <Jetbeard> it does?
13:51:08 <Tomsik> Yeah, in the generics
13:51:31 <Tomsik> Like you write <> instead of <Integer>
13:51:41 <Tomsik> and it sometimes /knows/!
13:51:46 <Jetbeard> java generics are horrible
13:51:48 <jmcarthur> magic
13:51:48 <Nimatek> Java's generics are fail though.
13:51:53 <Nimatek> They're not very generic.
13:52:28 <Tomsik> RankNTypes are where it's at when it comes to being generic
13:53:25 <ddarius> Actually, a lot of the power in Haskell that is missing from other languages except pretty much SML and O'Caml (but not F#) is higher kinded polymorphism.
13:53:40 <ddarius> Rank n types are, though, extremely powerful.
13:54:02 <Tomsik> Well, I can't honestly think of many uses for them
13:54:10 <companion_cube> ddarius: that is irelevant for dynamic languages, right ?
13:54:10 <Tomsik> There are some and they're pretty fun, but umm
13:55:09 <ddarius> Given System Fω and a good macro system, you could build more powerful features than most languages have, e.g. first class modules.
13:55:30 <companion_cube> ocaml has those now
13:55:46 <ddarius> companion_cube: Not exactly.  (re dynamic languages)
13:58:38 <merijn> Hmm, from a design perspective, which is nicer? Keeping/caching state in your program or just have the program query the database for every state manipulation? (I'm assuming the load to be low enough to not be an issue)
13:59:42 <ddarius> merijn: Writing your code in such a way that you don't have to make this decision now.
14:03:44 <russruss> so if I have a warning "Warning: Definition but no type signature for ..." and it is a "Forall" type, is there any way to get the warning to stop without turning off the warning?
14:03:55 <russruss> like is there some way of annotating that?
14:04:51 <gwern> roconnor: http://koeln.ccc.de/archiv/cyphernomicon/chapter12/12.16.html http://unenumerated.blogspot.com/2007/02/confidential-auditing.html
14:05:18 <Tomsik> merijn: transactions, I guess
14:05:19 <parcs> russruss: you can probably omit the forall
14:06:25 <russruss> parcs: awesome, that worked.  thanks
14:26:00 <Twey> In PHP, 'foo' == 0, "foo" == TRUE, TRUE == 1, ergo, indirectly, 0 == 1
14:26:05 <Twey> And *nobody thinks this is a problem*.
14:26:32 <Twey> (pet peeve of the day)
14:26:36 <NisseP> I don't know about "nobody"
14:26:53 <NisseP> just nobody who can stomach PHP in the first place
14:26:57 <Twey> Nobody in the PHP community.
14:27:14 <Twey> (the ‘in PHP’ applied to the people as well as the insanity)
14:27:34 <kmc> who's "the PHP community"?
14:27:46 <Twey> kmc: People who can stomach PHP.
14:28:03 <kmc> in what sense do they form a community though
14:28:05 <companion_cube> 15 years old web coders
14:28:12 <kmc> community != any set of people
14:28:25 <melle> Twey: that's why they've invented "strict" equality in php (===) :)
14:28:34 <Twey> kmc: They do — they band together in ##php and copy-paste code snippets between one another
14:28:44 <NisseP> kmc: a surprising number of people are very attached to PHP
14:28:52 <NisseP> I'd know, being a former 15-year-old web code :)
14:28:53 <Twey> Yeah…
14:28:57 <NisseP> +r
14:29:07 <djahandarie> Now you're a 16-year-old web coder?
14:29:15 <djahandarie> Or a 15-year-old non-web coder?
14:29:21 <Twey> For people who don't know very many languages, they often get very attached to a particular language for no reason other than ‘I can do stuff in it’
14:29:22 <companion_cube> meanwhile he learnt category thepry
14:29:41 <kmc> if all you know is C, Java, and PHP, you might be excused in thinking PHP is good
14:30:19 <NisseP> a little more former than that
14:30:37 <companion_cube> how can php be better than C or java ?
14:30:40 <saati> every language that lets you compare different things have weirdness like that
14:31:08 <kmc> companion_cube, doing even basic web tasks in C is excruciating
14:31:37 <djahandarie> I need to understand 'monads' to do basic web tasks in Haskell! :(
14:31:38 <danharaj> C is a systems programming language, not a general programming language.
14:31:41 <companion_cube> oh, for web programming, ok, but for everything else...
14:31:55 <kmc> anything where you need to manipulate strings, or associative data structures, or...
14:32:07 <kmc> not only are these things very hard in C but even minor mistakes will compromise the security of your system
14:32:13 <danharaj> I wouldn't use C for numeric work either. Fortran or Matlab there.
14:32:14 <kmc> not like the situation is much better in PHP
14:32:34 <danharaj> As far as I'm concerned, C is only good for telling hardware what to do :p
14:32:39 <kmc> danharaj, I do numeric work in C.  for the things I do, the speed advantage of Fortran would just not matter, and I haven't learned it thoroughly
14:32:44 <companion_cube> in php, even making no mistake will compromise the security of your system :)
14:32:46 <danharaj> kmc: fair enough.
14:32:59 <kmc> as for MATLAB, it's a pretty terrible language and the only faithful implementation is closed-source and expensive
14:33:08 <kmc> (octave is all right but not much used in 'real' science afaik)
14:33:19 <danharaj> kmc: but people use it, so you might as well do what the ivory tower romans do.
14:33:22 <kmc> heh
14:33:23 <companion_cube> octave lacks a JIT
14:33:35 <danharaj> Actually I know a guy who does lattice QCD and he likes Python.
14:34:02 <kmc> Python is big in comp bio and neuro too
14:35:34 <danharaj> Haskell should be the language of choice where you don't need to milk a supercomputer for every flop. Alas.
14:36:07 <hpc> i believe you mean "alas, we don't all have supercomputers"
14:36:27 <sebz> danharaj: otherwise MATLAB?
14:36:28 <danharaj> The way people utilize their computational resources, they might as well have supercomputers.
14:36:37 <danharaj> sebz: Gross. Fortran :p
14:37:01 <sebz> sanharaj: ah, okay I thought so
14:37:05 <sebz> er
14:37:11 <sebz> danharaj
14:37:14 <danharaj> sans haraj is this channel when I log off.
14:37:51 <hpc> sans haraj sounds like a type of arabic script
14:38:43 * ddarius is finding organic chemistry fairly interesting.
14:38:56 * ddarius sees why there are so many backwood meth labs.
14:39:12 <danharaj> Considering expanding your hobbies, ddarius?
14:39:13 <hpc> because chem professors make it so easy?
14:43:28 <sebz> danharaj: supporting your point: http://news.ycombinator.com/item?id=2735537
14:45:05 <danharaj> There's also the circumstance where a professor will load off their code work to one of their grad students.
14:45:45 <danharaj> Which is fine. But grad students are not exactly good at solid decision making. After all, they ended up in grad school :p
14:45:59 <hpc> haha
14:46:32 <Twey> Heh
14:46:43 <Twey> « As a general rule, researchers do not test or document their programs rigorously, and they rarely release their codes »
14:46:52 <Twey> It always fills me with confidence when reporters pluralise ‘code’
14:47:04 <Twey> As if programming were just a matter of entering the right magic password
14:47:24 <olsner> it's all about the codes! the more codes you know, the better a coder you are
14:47:31 * olsner knows all the codes
14:47:31 <Twey> Haha
14:48:11 <Twey> Haha, they do it throughout the article, too
14:48:15 <sebz> http://www.catb.org/jargon/html/C/codes.html
14:48:22 <osfameron> Twey: do they say "stuffs" too?
14:48:49 <Tomsik> I think I've read about some major physics rage when it turned out that scientists supported their thesis with closed-source code that some time later leaked and happened to be buggy
14:48:56 <Tomsik> so buggy that it invalidated the whole work
14:49:32 <Tomsik> And people are sayin' that physicists can't code for life and they don't know that
14:50:33 <Twey> osfameron: Haha, no, I like ‘stuffs’.  Good old Anglish.
14:54:50 <gwern> there's a lot of research that scientific code sucks. it's more than a little disturbing
14:55:09 <gwern> what'sn the point of p=0.05 if the programming errorbars alone are bigger
14:59:33 <ivan> I know a scientist who was been programming for decades but still hasn't figured out modules and writing reusable code
14:59:55 <hpc> ivan: is his name "matlab"?
14:59:58 <ivan> lots of copy-pasta goin' on
15:00:00 <ivan> heh
15:01:32 <smarmy> i'm trying to interpret the Char's of a String as unsigned bytes... but ord seems to behave oddly for values geater than 127
15:01:44 <smarmy> for instance 0x80 converts to 199
15:02:10 <hpc> > ord . succ . chr $ 0x80
15:02:11 <lambdabot>   129
15:02:11 <smarmy> i'm guessing unicode is screwing with me?
15:02:17 <hpc> > 0x80
15:02:17 <lambdabot>   128
15:02:34 <smarmy> yeah, that works for me in ghci
15:02:40 <smarmy> in my app, i'm getting my String from readFile
15:04:30 <smarmy> if i open up ghci, grab the contents with readFile, then pass the first byte (0x80) through ord, i get 199
15:05:10 <hpc> are you sure it's 0x80?
15:05:26 <smarmy> yeah.  if i set it to 0x79 or less, it works fine
15:05:33 <smarmy> 0x7f, i mean
15:05:46 <hpc> i mean, are you sure the character is actually 0x80
15:05:47 <smarmy> as soon as the high bit is set, i start getting strange converions
15:05:51 <hpc> ah
15:05:56 <ddarius> Do show.
15:06:18 <ddarius> > show [chr 0x80]
15:06:19 <lambdabot>   "\"\\128\""
15:06:38 <hpc> other debugging possibilities: see what type of file vim thinks it is
15:06:44 <ddarius> But yes, readFile in newer GHCs will use the encodign.
15:07:18 <Tomsik> Well, if you want unsigned bytes then you probably want a ByteString?
15:07:25 <Tomsik> not a String?
15:07:35 <benmachine> or you can open the file in binary mode
15:07:44 <benmachine> openBinaryFile from System.IO
15:07:51 <smarmy> i'll give it a go
15:07:54 <kmc> String does not contain bytes in any sense
15:07:58 <kmc> it contains Unicode characters
15:08:05 <Jetbeard> is the file binary data or just fancy characters?
15:08:14 <kmc> String = [Char] so the analogous type is just [Word8]
15:08:19 <kmc> but you can use ByteString for efficiency
15:08:20 <smarmy> binary
15:08:32 <Jetbeard> then importing it as a string will have disastrous consequences
15:08:46 <smarmy> so i'm noticing :)
15:08:56 <Jetbeard> as kmc says, haskell will interpret it as unicode -- presumably utf8
15:09:14 <kmc> ByteString IO is probably the cleanest way to solve this problem
15:09:16 <Jetbeard> and any byte in a utf8 string with the high bit set is a control character
15:11:04 <kmc> the assumption that characters are bytes are characters is probably one of the most enduring bad habits from C
15:11:24 <smarmy> so what's the idiomatic solution here?
15:11:32 <kmc> if you want to store bytes use ByteString
15:11:37 <kmc> if you want to store character text use Text
15:11:43 <kmc> from the 'bytestring' and 'text' packages resp.
15:11:51 <kmc> String is super inefficient anyway
15:12:08 <kmc> the byte analogue of String is just [Word8]
15:12:12 <joe6> is the http package the best with functionality similar to perl's LWP?
15:12:17 <kmc> but there aren't convenient IO functions for [Word8]
15:12:32 <smarmy> just found the io functions for bytestrings... handy
15:12:49 <kmc> also note that ByteString.Char8 is the worst thing ever
15:17:06 <roconnor> gwern: intresting
15:17:19 <roconnor> gwern: though I don't quite follow it :)
15:22:22 <gwern> roconnor: imagine a bank = a person, and the audit verifies money in is greater than money out
15:24:33 <roconnor> yay but they seemed to be talking about multiple auditor who each don't know the whole transaction log
15:24:50 <roconnor> I get the impression that if they collaborated they could know the whole log
15:25:10 <roconnor> or only knowing statics of the logs
15:25:18 <roconnor> *statistics
15:25:38 <gwern> perhaps; but are there variants where even collaborating auditors can't do that?
15:26:05 <roconnor> I don't know
15:26:11 <gwern> or you could have many random nodes selected for the auditing; not much worse a security guarantee than bitcoin currently offers
15:27:11 <roconnor> I still think homomorphic encryption could work well for the narrow application of bitcoin
15:28:24 <joe6> is there a haskell library to read pdf documents?
15:28:38 <joe6> I came across pdf2line, but am wondering if there is something better.
15:28:52 <hpc> pdf documents are kind of a disaster to manipulate programatically
15:28:55 <hpc> there's too much spec
15:29:15 <joe6> just want to read them.
15:29:42 <ddarius> hpc: Not really.
15:29:56 <ddarius> joe6: There are several libraries that either produce or manipulate PDF.
15:30:38 <hpc> i figured he wanted something that would work with everything in the spec
15:30:40 <hpc> nvm
15:33:26 <joe6> i just want to read the pdf document data out.
15:34:12 * ddarius should write a PDF parser to an AST.
15:34:20 <ddarius> I've done one many years ago in C++.
15:34:28 <joe6> oh, ok.
15:34:40 <ddarius> You could also abuse postscript for it.
15:34:50 <ddarius> PDF is a non-Turing complete subset of postscript.
15:35:18 <ddarius> +-
15:35:36 <merijn> I'm pretty sure PDF can do more then just postscript...
15:36:27 <merijn> They can embed like fifty gazillion data types in three hundred bazillion ways in addition to just ps data
15:38:41 <ddarius> merijn: Linguistically, PDF is a subset of postscript.  You can turn a postscript viewer into a PDF viewer by simply providing some library functions.  Postscript is a Turing-complete language.  Any further additions to PDF could be represented as libraries or just new primitive functions in postscript.
15:40:40 <dankna> ddarius: actually that's not my understanding.  PDF has several syntaxes based on PostScript ones, yes, but PDF content streams aren't linear in the file or anything like that.
15:41:07 <dankna> So your library would need to include a main function that read the table of contents and stuff.
15:43:09 <ddarius> dankna: The content streams don't need to be linear for postscript.  It's a programming language.  You just read all the PDF objects into memory.  Read the xref table.  Then render the objects.  Of course, it would be be better to skip to the xref table and not necessarily have everything in memory at once which would also be quite doable in postscript with, at worse, some file manipulation primitives added.
15:43:58 <ddarius> In fact, what I initially described is what would happen if you took the most obvious approach of defining a library for the PDF objects in postscript.
15:44:04 <dankna> ddarius: okay, but that's a fairly weak sense in which it's a subset.  you're saying it's a subset /of a superset/.
15:44:12 <ddarius> dankna: No.
15:44:38 <ddarius> dankna: I'm saying PDF will parse as postscript and any additions can be added as library functions, or at worse primitive functions.  No new syntactic constructs should be needed.
15:44:57 <ddarius> You can also interpret PDF as postscript simply by defining some library functions.
15:45:12 <dankna> okay.  I agree with that statement.
15:45:15 <ddarius> This is how postscript viewers supported PDF very early.
15:45:38 <ddarius> You'd just load a .ps file with the library definitions, and then open the PDF as a ps file.
15:45:41 * dankna nods
15:46:33 <ddarius> Think about it from a backwards compatibility perspective.  PDF will print on a postscript printer with only the addition of a prelude of library functions.
15:46:46 <dankna> okay.  that's a reasonable point.
15:50:20 <ddarius> PDF is also set up to be parsable even if you don't understand everything in it.  You just ignore the stuff you don't understand.  The syntax allows you to skip it.
15:51:43 <dankna> yes, a convenient feature, certainly
15:57:13 <Tomsik> Saying that a language is Turing-complete doesn't mean as much as people think it does
15:57:58 <Tomsik> you can have no I/O besides string of 0/1 input before start and just 0 or 1 as result
15:58:02 <shachaf> Tomsik: When someone says a language is Turing-complete, I typically think it means that it's Turing-complete.
15:58:41 <Tomsik> Yes, but people associate a bunch of things together with it
15:58:51 <Tomsik> Like being able to print to the screen or read a file
15:58:53 <hpc> the most interesting language in the world: "I'm not always Turing-complete, but when I am, I have no FFI."
16:02:11 <roconnor> The ACM formating directions are onerous.  Why did I ever submit to an ACM workshop?
16:02:36 <hpc> i made the mistake of going to an ACM meeting at university
16:02:57 <hpc> they do coding competitions every time, and the languages allowed are java, c, and c++
16:03:22 <pikhq_> hpc: It's entirely possible to do functional programming in (GNU) C, at least.
16:03:36 <pikhq_> (note: awful hack, please don't)
16:04:14 <ocharles> Why is this invalid, in a record data type: "conn :: (IConnection a) => a"
16:04:25 <hpc> not that awful a hack; just write your functional program in CPP
16:04:28 <ocharles> ghc says I might want to try with -XRankNTypes or -XRank2Types
16:04:35 <ocharles> but i'd rather just know wtf is going on :)
16:04:37 <pikhq_> hpc: Not quite what I had in mind.
16:04:41 <hpc> ;)
16:05:17 <hpc> ocharles: data Foo = X a
16:05:24 * cmccann considers that, ignoring issues of runtime efficiency and assuming access to the C preprocessor, at some level of complexity he would probably find Lazy K more productive than Java
16:05:26 <hpc> let x = X 5
16:05:29 <hpc> let z = X True
16:05:40 <hpc> -- same type oh noes!
16:06:05 <ocharles> hrm, I see
16:06:10 <pikhq_> cmccann: With a C preprocessor, Lazy K is *incredibly* more productive.
16:06:12 <hpc> and if that's not enough:
16:06:16 <ocharles> so should I use an instance of the type class here?
16:06:21 <hpc> instance IConnection Int where...
16:06:30 <hpc> you should do data Foo a = X a
16:06:43 <ocharles> I guess we'll later have PG specific stuff anyway, so a mysql connection wouldn't make much sense
16:06:53 <hpc> and don't put class constraints on type declarations, because they just get ugly later
16:06:56 <cmccann> pikhq_, well, there's still some complexity level below which Java wins, since I'm assuming that with Lazy K I'd have to start by writing my own standard libraries
16:07:22 <pikhq_> cmccann: Consider the syntactic overhead of Java, though.
16:08:08 <cmccann> pikhq_, true, but it'd still take a while to reimplement a lot of basic stuff
16:08:27 <cmccann> on the other hand, given a Lazy K port of the Haskell 98 Prelude I'm not sure Java would ever win
16:09:42 <cmccann> and by that I'm including some standard means of implementing algebraic data types in Lazy K and stuff like that
16:10:00 <pikhq_> Presuming you're doing something that's stdio-only.
16:10:46 <pikhq_> Awesome though it may be, Lazy K isn't about to do a GUI.
16:10:52 <cmccann> yeah, also obviously need to handwave some sort of FFI for Lazy K but that's just details
16:11:08 <pikhq_> Unless you attach stdin/out to a shell.
16:11:11 <pikhq_> :)
16:11:57 <cmccann> some sort of thin outer interpreter layer would be easy enough, attaching to a shell being a very simple version of that I guess
16:17:24 <jonkri> any idea how to solve the ghc problem where loading the package terminfo gives the error "libncursesw.so: file too short"? according to this [ https://bugzilla.redhat.com/show_bug.cgi?id=578509 ] ghci has been fixed upstream. ghc is the latest versions in fedora 15 (7.0.2)
16:17:24 <lambdabot> jonkri: You have 2 new messages. '/msg lambdabot @messages' to read them.
16:18:12 <jonkri> ion: thanks for the messages you left me :)
16:19:58 <mdgeorge> hello
16:21:42 <jonkri> it seems to be fixed in 7.0.3
16:22:32 <jonkri> annoying that it wont be available until fedora 16 :(
16:23:25 <dolio> Advice: don't rely on distro packages for GHC.
16:23:33 <dolio> Unless, maybe, it's Arch or something.
16:24:53 <dolio> I think the only Haskell related package I have installed through a distribution is haskell-mode.
16:25:02 <ddarius> dankna: As a final nail in the coffin, an operator in postscript can arbitrarily manipulate (or at least parse) the remaining source, so any file that starts with something that can be parsed as a postscript operator is potentially a syntactically valid postscript file.
16:25:03 <dolio> And that's been the case for a while.
16:25:05 <hpc> not even arch
16:25:09 <hpc> just install the platform
16:25:25 <hpc> then you don't have to worry about being able to cabal or not cabal a package
16:25:39 <cmccann> I usually just install a GHC binary, cabal-install, and go from there
16:25:42 <hpc> (well, you still do, but not as often)
16:26:01 <geheimdienst> dolio: interesting, could you elaborate on why not distro ghcs?
16:26:20 <dolio> geheimdienst: They almost always lag behind the state of the art.
16:26:32 <dolio> In some cases, significantly.
16:27:04 <hpc> *ahem debian*
16:27:19 <geheimdienst> oh i see, of course. but that's true no matter if the distro packages ghc or anything else
16:27:43 <cmccann> it tends to be really bad with GHC
16:27:45 <pikhq_> hpc: Debian testing actually has the latest platform.
16:27:49 <hpc> geheimdienst: other packages you can expect them to at least be newer than 6 months
16:28:03 <dolio> Yeah, well, if you're a serious Foo developer, I probably wouldn't recommend using distro Foo packages either.
16:28:40 <dolio> But I suppose that depends a bit on what Foo is.
16:28:59 <dolio> Java doesn't move as fast as GHC.
16:29:45 <dolio> Of course, you might not care about the latest GHC either, in which case you don't have to take my advice.
16:30:55 <dolio> Anyhow, I'm going to go eat something.
16:31:26 <geheimdienst> no, sure, i see the appeal of new stuff ... geek cred, new features, and so on. i'm an arch user after all
16:31:52 <hpc> it's also nice to not be stuck with year-old bugs ;)
16:32:08 <luite> fresh bugs taste much better
16:32:31 <hpc> just ask any kernel dev!
16:33:24 <geheimdienst> hpc: yeah ... theoretically ... very new stuff has bugs too. they sometimes go away after a few versions, so i guess the ideal would be something that is new, but not overly
16:35:16 <luite> around 12 months, like a good gouda cheese
16:35:20 <luite> that's ideal :p
16:35:34 <hpc> delicious, unsurprising, tiny bugs
16:35:37 <hpc> like popcorn
16:36:11 <geheimdienst> for example, i would have preferred to have skipped the whole episode of some kernel thing called khugepaged messing up the system about twice a week ... which has been unfixed for a few months now. i guess with a distro that tests a little before jumping at every new thing, you'd have less of that
16:36:27 <kmc> mmmm huge pages
16:36:32 <kmc> they're nice, when they work ;P
16:36:34 <kmc> you can turn it off iirc
16:37:21 <geheimdienst> kmc: i did :) turning off khugepaged is a workaround for the issue of it spinning and preventing the system from going to sleep
16:37:42 <luite> which kernels have this?
16:37:47 <jonkri> dolio, thanks, will download the platform manually then i think
16:38:09 <kmc> transparent huge pages came in with 2.6.38 i think
16:38:13 <kmc> dunno about the bug
16:38:33 <geheimdienst> luite: 2.6.39 and 38ish. i'm not entirely sure, but let me google some lkml threads ...
16:38:38 <Draconx> and they are off by default, so whoever built it must have explicitly requested the feature.
16:38:53 <luite> I've never seen the bug and I use .38 on a few computers. aren't huge pages enabled by default in ubuntu?
16:39:12 <geheimdienst> Draconx: i sure didn't enable it. must have been the arch guys
16:39:16 <luite> though my laptop seems to crash about twize a week
16:39:18 <luite> twice
16:39:25 <luite> with ubuntu 11.04
16:39:35 <Draconx> geheimdienst, whoever compiled your kernel image did it.
16:41:15 <geheimdienst> luite: the symptoms that i have are: iotop reports khugepaged being forever at 99% and the system when you close the lid trying to go to standby for 20 sec, then reverting, with dmesg saying it couldn't suspend
16:42:48 <luite> hmm, different problem here probably
16:43:11 <luite> symptoms here: X.org stops responding, nothing works except rebooting
16:43:58 <danharaj> err
16:44:05 <danharaj> is reddit redirecting to google for anyone else?
16:44:25 <luite> not here
16:44:31 <danharaj> ok that doesn't even make any sense
16:44:34 <danharaj> what is wrong with my dns
16:44:40 <hpc> try 184.84.247.17
16:44:42 <geheimdienst> not here either
16:44:49 <hpc> that should be reddit's ip
16:45:30 <geheimdienst> danharaj: try "dig reddit.com". it should tell you near the bottom what dns server gave you the bogus resolution
16:45:57 <danharaj> What I don't understand is how it happened in the middle of my browsing the site.
16:46:29 <danharaj> Maybe it's a bug in my browser.
16:46:40 <danharaj> Why is software I use breaking on me!
16:46:58 <danharaj> yes, it was a bizarre browser error that cleared up by restarting.
16:47:46 <hpc> browsers like to have DNS caches
16:47:51 <hpc> that will sometimes do bullshit
16:47:55 <danharaj> like lie
16:47:56 <luite> sometimes chrome here refuses to go to certain sites
16:48:19 <luite> for example sometimes it just won't go to gmail anymore until I restart it
16:48:33 <parcs> digg reddit.com
16:48:35 <danharaj> This happend on opera.
16:48:42 <danharaj> oh well, all software is shit.
16:48:49 <geheimdienst> danharaj, the first man being eaten by the entirely new attack that makes reddit be google, and is now spreading through the internet at breakneck speed
16:55:00 <luite> and the windows version of chrome seems to be more stable than the linux one
16:55:15 <dobblego> napping: #scala is very much unlike #haskell, sorry about that
16:55:25 <danharaj> What is the difference between #scala and #haskell?
16:55:44 <danharaj> (sounds like the setup for a joke, heh)
16:55:56 <kmc> how many scala users does it take to screw in a lightbulb
16:56:00 <dobblego> just "trolls" and so on, I think napping got sucked in
16:56:26 <danharaj> #haskell is full of trolls
16:56:43 * Rotaerk blocks passage on his bridge.
16:56:44 <dobblego> for #scala it is the norm
16:57:53 * hackagebot bindings-posix 1.2.3 - Low level bindings to posix.  http://hackage.haskell.org/package/bindings-posix-1.2.3 (MauricioAntunes)
16:58:19 <geheimdienst> kmc, first, install the screw-in-lightbulb package. it will install the dependencies category-extras, transformer-extensions, and abstract-nonsense. these in turn depend on 18 packages including mtl and monads-fd, which have some conflict in module names
16:59:05 <ddarius> geheimdienst: He asked for Scala.
16:59:08 <kmc> how does one troll #scala
16:59:12 <kmc> i must know
16:59:15 <kmc> for... research purposes
16:59:23 <geheimdienst> oleg wrote a paper years ago that explored screwing in lightbulbs via the type system. this has been implemented in 4 different subtly incompatible packages ...
16:59:27 <danharaj> kmc: prepend every message with "Well, in Haskell you do..."
16:59:40 <kmc> ehehehe
17:00:06 <dobblego> kmc: a wanker asked about the List.unfold function, which is missing from the standard library, and refused to comprehend it, then complained about or ignored the multiple explanations, either by sheer idiocy or by this "troll mentality" that I have difficulty understanding
17:00:20 <kmc> the bulbular shape of the lightbulb is entirely irrelevant to its light-producing nature
17:00:39 <kmc> we could invent "light objects" and fail to notice their generalized bulb shape and they would still work
17:00:54 * hackagebot categories 0.57.0 - categories from category-extras  http://hackage.haskell.org/package/categories-0.57.0 (EdwardKmett)
17:00:56 <danharaj> photopolymorphism?
17:01:00 <danharaj> photometricity
17:01:09 <kmc> bulbs are not in any way "impure", they just represent a *description* of light, which is not produced until later when current is applied
17:03:47 <danharaj> So, what in Haskell is not first class that could be made first class for fun and proft?
17:04:00 <danharaj> First thought that comes to mind is patterns.
17:04:08 <geheimdienst> danharaj: gorram record labels
17:04:14 <kmc> types
17:04:26 <kmc> concrete syntax
17:04:31 <kmc> class instances
17:04:55 <shachaf> "bulb" is a generic API?
17:05:08 <NisseP> danharaj: modules?
17:05:16 <danharaj> kmc: with type families, how far are types from being first class?
17:05:32 <kmc> shachaf, yes, I think it's somewhere in the Edison library
17:05:34 * kmc ducks
17:05:42 * danharaj hits kmc with a monad
17:05:51 * kmc fmaps through and comes out the other side
17:05:52 <danharaj> You've been waiting to say that.
17:06:07 <danharaj> Also, I misread that and went "eww"
17:06:20 <kmc> danharaj, pretty far, you still can't manipulate them with ordinary code
17:06:23 <edwardk> kmc: yes, but now you're stuck in the monad zone. its like the phantom zone, with types.
17:06:31 <kmc> is it like the forbidden zone?
17:06:40 <kmc> type synonym families give you some primitive pattern matching but lack a lot of things
17:06:57 <cmccann> like being closed functions
17:07:00 <cmccann> those would be nice
17:07:18 <edwardk> cmccann: hah, i ALMOST have that code we were talking about earlier compiling ;)
17:07:30 <cmccann> edwardk, awesome :D
17:07:32 <kmc> danharaj, first class patterns would be great, though
17:07:49 <kmc> would you then get first-class record labels for free?
17:07:49 <c_wraith> cmccann: wouldn't closed type functions require the ability to define subsets of types?
17:07:57 <napping> first class patterns would be pretty tricky
17:08:03 <danharaj> kmc: to be honest, my imagination needs a use example for me to fully appreciate what first class patterns would give.
17:08:08 <napping> pattern synonyms seem easy enough, though
17:08:11 <shachaf> kmc: First-class patterns in what sense?
17:08:40 <danharaj> also, as NisseP mentioned, giving modules more citizenship could be fun and profitable.
17:08:44 <cmccann> c_wraith, no, they'd just need to have one default match
17:08:58 * hackagebot algebra 0.1.0 - Constructive abstract algebra  http://hackage.haskell.org/package/algebra-0.1.0 (EdwardKmett)
17:08:59 <c_wraith> cmccann: oh, I guess that would do
17:09:00 <NisseP> we'd need a new name for functors, though, because that might be confusing. :)
17:09:09 <kmc> type Pat in out = forall a. (out -> a) -> in -> Maybe a
17:09:12 <danharaj> You can already define subsets of types via classes.
17:09:16 <napping> You can pretty much emulate patterns with functions like a -> Maybe b
17:09:19 <cmccann> in other words, they'd need to do exactly what people often want to make overlapping instances do, except they'd be sensible about it
17:09:23 <danharaj> Well, open subsets.
17:09:31 <napping> then use something like mplus to join them, as so on
17:09:32 <danharaj> ... open as in you can add to them, not topology.
17:09:34 <kmc> maybe that should be 'exists out'
17:09:50 <edwardk> cmccann: https://github.com/ekmett/algebra
17:09:51 <napping> seems like a lot of work, and you probably miss coverage checks and so on, unless you invent very fancy type system for them
17:09:58 <geheimdienst> what's that function out -> a?
17:10:05 <kmc> a continuation
17:10:15 <napping> Still, there's been a paper or two on modelling patterns as things in some particular failure monad
17:10:25 <kmc> either the pattern matches and calls the continuation, or it returns Nothing
17:10:48 <geheimdienst> okay, seems to make sense
17:10:52 <napping> Yeah, that's pretty much how it would go - take a pattern and a continution and package it up into an alternative
17:10:56 <kmc> i don't know, it just popped into my head
17:10:58 <edwardk> i made my first arrow instance in quite a long time in that
17:11:00 <kmc> could be totally nonsensical
17:11:02 <napping> then mplus a bunch of those to make a case
17:11:14 <danharaj> There seems to be a library doing as napping suggests.
17:11:19 <kmc> cool
17:11:21 <napping> You'd have to do a lot to make the syntax palatable
17:11:22 <kmc> i vaguely recall this
17:11:33 <napping> there's also Barry Jay's "Pattern Calculus"
17:11:40 <napping> a language of first class patterns and stuff
17:11:53 <cmccann> that's not quite the same, I think
17:11:59 <cmccann> though related
17:12:03 <edwardk> napping: yeah, i just wish he didn't claim it was more powerful than something equally powerful ;)
17:12:21 <napping> oh, what does he claim it's more powerful than?
17:12:34 <danharaj> edwardk's kung-fu
17:12:40 <cmccann> the pattern calculus stuff gives you some degree of intensional analysis by deconstructing non-saturated function application, I think
17:12:55 <napping> hmm, always trickty, that
17:13:18 <napping> on the other hand, GADTs pretty much let you keep partially saturated function application as inspectable structures, don't they?
17:13:29 <cmccann> GADTs let you do all kinds of things if you try hard enough
17:14:00 <napping> Much tidier to pass in a description that can be evaluated to an object, rather than kill parametricity by letting you reflect arbitrary objects
17:14:24 <edwardk> now to go add the CCC instances for linear maps i guess
17:14:30 <cmccann> but what it would amount to in practice is that church encodings of algebraic data types could be pattern matched on directly, without needing a constructor representation
17:14:45 <cmccann> what this gains you in actual utility, I'm not sure
17:14:51 <cmccann> but it is kind of interesting I guess
17:15:09 <cmccann> at least if I'm remembering all this correctly!
17:15:12 * cmccann shrugs
17:15:20 <danharaj> what would Haskell need to make polytypic functions more privileged citizens?
17:15:21 <roconnor> hpc: I've never had a very good impression about the ACM, and now that I'm actually dealing with them I like them even less.
17:16:02 <cmccann> danharaj, not sure what polytypic means here
17:16:09 <roconnor> let's start a new association for information machines
17:16:20 <danharaj> cmccann: like fold.
17:16:56 <geheimdienst> the information machinists' club
17:16:58 <cmccann> roconnor, sounds good to me, count me in
17:17:17 <cmccann> roconnor, will there be a secret handshake?
17:17:28 <danharaj> No, just a private key.
17:17:35 <cmccann> danharaj, still not sure what you mean, sorry, trying to do five things at once right now :T
17:17:47 <danharaj> cmccann: just spin off more worker threads duh
17:18:12 <roconnor> cmccann: there can be
17:18:18 <hpc> roconnor: screw machines! we're mathematicians
17:18:34 <kmc> i'll go for "computer janitors"
17:18:35 <hpc> (at least, the paper-writing ones are)
17:18:38 <roconnor> association for information mathematics
17:20:45 <cmccann> edwardk, ...I think that's the first time I've seen an operator used as a record-syntax field name
17:20:51 <kmc> :O
17:20:51 * cmccann scratches his head
17:28:12 <edwardk> cmccann: =)
17:29:11 <edwardk> trying to figure out the definitions of curry and uncurry for CCC (Map r)
17:29:57 <kmc> that's a CCC is it?
17:30:15 <edwardk> well its cartesian
17:30:21 <cmccann> edwardk, that almost seems like the sort of thing you should be able to crank through djinn
17:30:24 <edwardk> Map here is a linear mapping
17:30:29 <kmc> ohh
17:30:34 <cmccann> not Data.Map.Map :]
17:30:40 <edwardk> https://github.com/ekmett/algebra/blob/master/Numeric/Map/Linear.hs
17:30:41 <cmccann> that's kind of different
17:30:54 <edwardk> yeah
17:31:04 <edwardk> for a while it was LinearMap but that got really tiring
17:31:15 <edwardk> and I'm using Linear for linear functionals
17:31:15 <kmc> sure, i can just import qualified Linear
17:31:42 <kmc> edwardk, you should name all your linear algebra identifiers using Linear B
17:31:47 <edwardk> exactly=)
17:31:53 <edwardk> hah
17:32:02 <edwardk> brb closing window to keep adium from flipping out
17:32:18 <edwardk> back
17:32:40 <edwardk> cmccann: does the linear map arrow make sense now?
17:32:54 <edwardk> lots of continuation passing style games
17:33:21 <cmccann> edwardk, haven't had that much time to look at it yet actually, was in the middle of a couple other things
17:33:25 <edwardk> ah
17:33:46 <edwardk> beating my head on curry and uncurry. not sure i _can_ write the CCC instance =(
17:34:14 <edwardk> i should be able to do it if i break down and limit the exponentials to Hask
17:34:34 <edwardk> but i'd like the exponentials of linear maps to be linear maps
17:35:32 <joe6> http://pastebin.com/xbS1ELD4 when I use this to download a pdf file and save the contents to a .pdf file, I am not able to open the file.
17:35:34 <mauke> The paste xbS1ELD4 has been copied to http://hpaste.org/48931
17:35:46 <joe6> is there a simple way of downloading a pdf file from haskell
17:35:47 <edwardk> i did get one really nice result though. since now linear maps are categories and arrows, etc. if you want to optimize linear maps that get used more than once you just insert the memoMap linear map in the middle, and it does the right thing. representabe-tries for the win ;)
17:35:56 <joe6> i checked out curl.download
17:36:08 <joe6> but that does not seem to have a simple download.
17:36:17 <edwardk> and i can say things like convolve f g = cojoinMap . (f *** g) . joinMap
17:36:18 <joe6> something like a wget.
17:36:48 <cmccann> edwardk, hah, nice
17:37:03 <cmccann> though I have to assume there's still a fair amount of overhead from all the abstraction
17:37:09 <joe6> i am getting these errors: http://pastebin.com/JumSaq4a
17:37:11 <mauke> The paste JumSaq4a has been copied to http://hpaste.org/48932
17:37:19 <edwardk> which reads exactly like http://en.wikipedia.org/wiki/Convolution 's notes about hopf bialgebras
17:37:37 <edwardk> (inverted because my LinearMaps are backwards than normal, so they can make nice arrows, monads, etc)
17:37:50 <edwardk> what abstraction? =)
17:38:14 <edwardk> the nice thing is this is FASTER for me to deal with polynomial multiplication than it is if i represented them as lists for the most part
17:38:25 <jonkri> what do you guys use for haskell in latex documents?
17:38:52 <edwardk> the memo combinators are a little slower, but the basic operation is pretty sweet
17:39:04 <edwardk> its basically 'polynomial fusion' ;)
17:39:57 <edwardk> i also can't answer some standard questions, for instance i can't tell you the degree of a polynomial when i represent it as a covector in the polynomial space
17:40:00 <cmccann> edwardk, ah, I was just doing some graphics-related stuff earlier, so I was thinking of compared to stuff like... unboxed arrays and whatnot :P
17:40:14 <kmc> jonkri, lhs2TeX?
17:40:19 <edwardk> yeah if its particularly dense, i lose ;)
17:40:45 <edwardk> but i can seamlessy deal with infinities, laurent polynomial multiplication, etc.
17:41:20 * cmccann nods
17:41:50 <edwardk> and all the polynomial bases drop out as a simple choice of coalgebra
17:43:50 <edwardk> its not perfect though. i'd like to be able to represent linear maps between non-free modules, since when we step below vector spaces not every module is free
17:47:49 <jonkri> kmc, thanks, will try it :)
17:53:52 <tswett> Is there any library (or implementation of the language!) that would allow me to write functions to disk and load them in again?
17:54:22 <kmc> YHC had something like that
17:54:27 <kmc> because it has a portable bytecode
17:54:31 <kmc> dunno if it still works
17:57:05 <tswett> Maybe I should make yet another implementation of Haskell.  I could call it THC.  Actually, on second thought...
17:58:09 <napping> What do you want to serialize?
17:58:24 <kmc> tswett, i started one named that
17:58:34 <kmc> The TriBeCa Haskell Compiler
17:58:40 <napping> If arbitrary serialization is a big deal, there are some other languages that try to support it
17:58:55 <napping> I think Clean does, for one
17:58:57 <tswett> I do want to serialize everything, yes.
18:00:13 <tswett> I used to think that orthogonal persistence was a feature that had to be implemented in the VM itself, but now that I think about it, you can get something very similar with callCC and serialization.
18:00:15 <napping> Hmm, how's Distributed Haskell coming along?
18:00:48 <tswett> I once joked that this is an implementation of orthogonal persistence in Haskell: "callCC show"
18:00:56 <napping> I vaguely recall some serialization scheme in the latest paper
18:01:27 <napping> "Haskell for the Cloud"
18:01:49 <fxr> it's very primitive
18:02:04 <fxr> and doesn't cover compex situations
18:02:19 <napping> yeah. Section 6, "Faking it"
18:02:41 <fxr> already implemented in termite scheme I remember.
18:02:44 <napping> Describes how to handle things built from a limited selection of closures
18:02:56 <ddarius> tswett: If you write something to defunctionalize Haskell source, then you only need to serialize plain data structures.
18:03:07 <napping> That's the general idea, I think
18:03:09 <NemesisD> hi all. i'm working on writing a library for a web api. in my last one, I found that aeson was *way* better than the default, Text.JSON. For XML, is there an easy/"best" XML parsing library or is haxml the standard
18:03:30 <fxr> NemesisD: xml-enumerator?
18:03:38 <ddarius> Actually, having a defunctionalizer for Haskell would be pretty useful.
18:03:39 <tswett> ddarius: eh, I'd prefer to do as little work as possible.  :)
18:03:59 <NemesisD> fxr: written by michael snoyman. that's a good start!
18:04:02 <napping> hmm, actually that scheme doesn't even really seem to cover higher order functions
18:04:30 <napping> tswett: is it acceptable if you can only serialize things built from applications of a limited set of functions?
18:04:33 <fxr> NemesisD: also hxt has lot's of features like relax ng schema validation etc..
18:05:03 <tswett> napping: yes, as long as there aren't any significant restrictions on what the set can be.
18:05:21 <tswett> In theory, it's okay if the set is {ap, const, id, fix}.
18:05:30 <NemesisD> fxr: what do you like better. xml-enumerator or hxt? I probably won't need most of the bells and whistles like relax ng. I'll just be parsing responses from an API server
18:05:59 <ddarius> tswett: Wadler's "A located lambda calculus" has a relatively easy to implement scheme.
18:06:06 <fxr> NemesisD: xml-enumerator has nice combinators to start, check it out first.
18:07:02 <ddarius> tswett: What napping's suggesting is tantamount to representing your code in an embedded language, serializing the AST, and interpretting the AST on deserialization.
18:07:12 <russruss> so what do people think of undecidable instances?  like if you see it does it make you feel weird?
18:07:30 <napping> undecidable instances are not too bad, as far as things go
18:07:44 <ddarius> russruss: You should have a good reason to use undecidable instances.  If you don't know why you need it, you are probably doing something wrong.
18:08:02 <cmccann> sometimes. Undecidable instances make me feel weird when undecidable instances don't make me feel weird.
18:09:29 <russruss> haha okay yeah I have no idea why I need it so maybe that's a bad sign - I have a class with two parameters, and another class with two parameters, and I want to make all instances of the first class instances of the second class.  That sort of has the feeling of something that might be undecidable, but maybe I'm just doing something wrong?
18:12:22 <tswett> Now, does the "undecidable" there mean "uncomputable", or "impossible to determine even if you had a hypercomputer"?
18:12:24 <edwardk> undecidable isn't that bad, overlapping is usually a hanging offense ;)
18:12:50 <cmccann> tswett, it means "subject to the halting problem"
18:12:55 <edwardk> incoherent? you're dead to me ;)
18:13:31 <cmccann> edwardk, there is actually one good thing about incoherent instances
18:13:38 <hpaste> russruss pasted “can I do something like this without undecidable instances?” at http://hpaste.org/48935
18:13:42 <cmccann> namely that it actually SOUNDS dangerous, unlike "overlapping"
18:13:48 <edwardk> cmccann: =)
18:14:02 <edwardk> overlapping is fine if you know you are putting all the instances in the same module, etc.
18:14:11 <edwardk> but you better know a lot about instance resolution
18:14:35 <cmccann> in other words "overlapping is fine if you're trying to fake closed type classes and understand how oleg's type hackery works"
18:14:46 <tswett> What are incoherent instances, then?
18:15:08 <tswett> Are they just what overlapping instances evolve into when they level up?
18:15:10 <napping> If an error message mentions "undecidable" instances, that's because it's not clear that type class resolution will actually terminate
18:15:30 <edwardk> tswett: more like when they succumb to the dark side
18:15:31 <cmccann> I think incoherent means that it deals with ambiguity by just picking the first thing that seems to work
18:15:33 <napping> There's a few simple rules (in the User's Guide) with definitely make sure your rules are okay
18:15:35 <russruss> so is there a way to make all instances of a two-parameter type class instances of another two-parameter type class without undecidable instances?
18:15:38 <cmccann> rather than looking for a "most specific" match
18:15:56 <napping> but there are a reasonable number of cases which are perfectly safe that don't meet those rulse
18:16:06 <napping> Sounds like what you are doing, for example
18:16:29 <edwardk> cmcann: basically type level instance resolution works like a pattern match on the instance head. most specific pattern wins, when you have incoherent instances, there is no canonical choice of instance to choose
18:16:48 <joe6> is there a smarter way of doing this: http://pastebin.com/6J38uAPB
18:16:51 <mauke> The paste 6J38uAPB has been copied to http://hpaste.org/48936
18:16:53 <edwardk> instance Foo X a; instance Foo a X — without an extra instance Foo X X its incoherent
18:17:00 <napping> like one instance on (Int,a) and another for (b,Bool)
18:17:45 <cmccann> edwardk, yeah, I can't recall how incoherent works because I've... never used it
18:18:02 <cmccann> but I've spent far too much time doing type hackery with overlapping :T
18:18:09 <napping> russruss: your instance (C1 a) => instance (C2 a) would be bad if there was another instance like instance (C2 [a]) => C1 a
18:18:20 <edwardk> cmccann: i've needed it a few times, but only after carefully proving that i didn't care which of the instances i got ;)
18:18:33 <cmccann> writing type-level lambda calculus evaluators is fun :]
18:19:07 <russruss> napping:  so in that case I would need "incoherent" instances and it would be crazy?
18:19:12 <russruss> ohhhh
18:19:13 <russruss> nm
18:19:24 <russruss> sorry yeah so it could make some crazy loop thing you're saying?
18:19:29 <napping> russruss: No, undecidable is enough that it would go ahead and try to evaluate it
18:19:41 <napping> Now if you don't have a second rule like that, it can't get into loops
18:19:45 <tswett> Instances for "Foo X a" and "Foo a X" look overlapping to me.  Does "overlapping" mean that one of the instances is a subset of the other (like "Foo X a" and "Foo X X"), while "incoherent" means they're not subsets?
18:19:56 <napping> but I don't think the standard rules are smart enough to look at everything else in scope and decide that
18:20:14 <gfarfl> joe6: use any from Data.List -- any isControl "string"
18:20:17 <edwardk> they overlap, but are also incoherent, given Foo X X which gets called?
18:20:39 <russruss> well that kinda smells undecidable yeah?  because it might not necessarily be like C2 => C1, there might be several intermediate steps
18:20:47 <napping> So, if you just write the first rule, everything is actually fine, but it can't see it
18:20:52 <edwardk> overlapping instances permits them to overlap, but requires that given a type level 'pattern' it should pick only one instance
18:21:09 <edwardk> russruss: and remember there is no backtracking in instance resolution!
18:21:22 <russruss> okay, so basically as long as no one makes any sort of loop I'm safe
18:21:29 <edwardk> yeah
18:21:29 <napping> Yeah, that's it
18:21:33 <russruss> but that's kind of a big what if to put in without an extension
18:21:40 <edwardk> you need undecidable for lots of things, like the entire mtl for instance
18:21:53 <tswett> edwardk: what would be an example of overlapping instances, then?
18:22:03 <napping> So, if you are sure you have no loops but the compiler can't see it, then you can turn on undecidable instances to let it through
18:22:28 <russruss> okay, thanks guys, that was really useful.
18:22:28 <edwardk> twett: intstance Foo X; instance Foo a
18:22:29 <jmcarthur> Foo [a]  and  Foo String
18:22:34 <cmccann> napping, yes, and if you're wrong GHC crashes or hangs when you compile it
18:22:35 <napping> oh, also instances can be cyclic
18:22:41 <cmccann> which isn't really the end of the world anyway
18:22:55 <edwardk> tswett: or the instance Foo X a; instance Foo a X; instance Foo X X example i gave
18:22:56 <napping> like, if you have instance (C a) => (C a) it will make a recursive dictionary
18:23:07 <tswett> So "Foo X" and "Foo a" are overlapping, but "Foo X a" and "Foo X X" are incoherent?
18:23:17 <napping> so it's only a "loop" in the GHC-hangs sense if the things it's looking for get bigger and bigger
18:23:30 <edwardk> nah, without Foo X X; Foo X a and Foo a X are incoherent, which wins when given Foo X X?
18:23:59 <tswett> My best guess so far is that having overlapping instances means that given a type (or set of types), out of all the instances for that type, there is one instance that is more specific than all the rest.
18:24:11 <edwardk> tswett: that is exactly it
18:24:21 <joe6> gfarfl, that is cool. thanks.
18:24:22 <tswett> So "Foo X a" and "Foo X X" are overlapping, after all.
18:24:43 <cmccann> and if there isn't a most specific instance, or--as often happens--if a type is too polymorphic to pin down a single instance, you get a compile error
18:24:44 <edwardk> tswett: there are some side conditions, like if you want to refine an instance you should do so within the module that defines the more general rule or it'll probably NEVER work right
18:24:45 <joe6> gfarfl: thanks a lot for that.
18:24:51 <edwardk> tswett: yes
18:24:55 * tswett nods.
18:24:57 <napping> class C a where val : a -> [a]; instance (C a) => C a where val x = x : val x
18:25:08 <napping> requires UndecidableInstances, but runs fine
18:25:15 <edwardk> the reason of that side condition i mentioned has to do with instance resolution and separate compilation
18:25:32 <edwardk> if i have a module in which i define class Foo a; instance Foo a
18:26:13 <edwardk> then i can be overlapping all i want, if i go to define instances in another module that overlaps it probably won't matter third party libraries that import the source module and not me may not see my instance
18:26:17 <russruss> napping: is there a reason you would want to do that?  I mean it's cool but I guess I don't see the point?
18:26:19 <edwardk> this is why overlapping is still dangerous
18:26:32 * tswett nods.
18:26:40 <edwardk> because we rely on the confluence of type class inference in countless ways
18:27:04 <napping> It doesn't come up very often, mostly when you are working with a fixpoint operator
18:27:06 <tswett> So if I have incoherent instances enabled, and I have instances "Foo X a" and "Foo a X", does the compiler pretty much pick between them arbitrarily?
18:27:15 <edwardk>  yeah
18:27:24 <napping> I just wanted to point out that an instance search like that doesn't loop
18:27:32 * tswett nods.
18:27:44 <edwardk> but as with overlapping instances, make sure you put them both in the same module if you want it to have a chance of dispatching on them
18:27:57 <napping> so, if it's looking to make an instance (C a), and it figures out that it can do that if it finds an instance (C a), it will just make a self-referential dictionary
18:28:15 <napping> rather than exploding like it would if the search actually required an instance on larger types
18:28:40 <edwardk> overlapping instances defined within the same module are basically the one place where the existing MPTC machinery outshines the current type family stuff, in that the latter has no support for that sort of thing
18:29:11 <russruss> so, my noobness is going to show here a little, but is there a way for preventing instances to be exported from a module?
18:29:18 <edwardk> its been discussed, but isn't a priority
18:29:20 <edwardk> russruss: no
18:29:29 <napping> russruss: I think that could be a bad thing
18:29:29 <edwardk> russruss: for very good reasons sadly
18:29:47 <napping> Things like Map assume that there's only one Ord instance in the program
18:29:55 <edwardk> russruss: if you allow local instances for types that escape the module then you can compromise the confluence of type instance resolution
18:30:08 <napping> otherwise, if a Map a b can make it from part of the program that uses one Ord instance to make it to part of the program that uses another Ord instance, things would be bad
18:30:40 <edwardk> you can see this in action in scala. they have implicits you can supply manual values for
18:30:50 <edwardk> and it can cause all sorts of nigh impossible to find bugs
18:31:05 <edwardk> and forces you to do more expensive merges when merging maps, etc than you get away with in haskell
18:31:07 <russruss> yeah that's a pretty convincing argument not to do it
18:31:10 <napping> You can almost always replace a class constraint with explicitly passing a record of methods, if you need to
18:31:29 <edwardk> napping the limtitation there being the same confluence concern
18:31:50 <napping> yeah, but hopefully it's less of a problem if it's explicit
18:32:22 <edwardk> and if you need to go back from a record to an instance there is always the reflection package ;)
18:32:43 <edwardk> but confluence there is ensured by quantification
18:33:32 <napping> It works a bit better with dependent types - if the type can record which record of methods was used, then you can tell if two maps (or whatever) are compatible
18:34:07 <napping> Maybe something more specific could be done wtih instances?
18:37:01 <david100> exit
18:37:09 <david100> bye
18:44:13 <cmccann> edwardk, did you ever get your curry/uncurry working?
18:53:10 <dobblego> edwardk: do you use this function: (Monad f, Comonad f) => Lens a (f b) -> Lens b (f c) -> Lens a (f c)
19:05:34 <edwardk> dobblego: can you provide the lens laws for it?
19:05:52 <edwardk> cmccann: no
19:06:15 <cmccann> edwardk, would "curry m = Map $ \k a -> k (Map $ \k' b -> (m $# k') (a, b))" work? :T
19:06:30 <edwardk> cmccann: does it type check?
19:06:33 <cmccann> yes
19:06:36 <edwardk> cmccann: and uncurry? =)
19:06:42 <cmccann> uncurry m = Map $ \k (a, b) -> (m $# (\m' -> (m' $# k) b)) a
19:06:46 <edwardk> sweet
19:06:55 <cmccann> and "apply = Map $ \k (f, a) -> (f $# k) a" for good measure
19:07:01 <shachaf> @context cmccann
19:07:01 <lambdabot> Unknown command, try @list
19:07:52 <edwardk> i had appy, so that looks good
19:08:16 <cmccann> edwardk, got those from djinn :D
19:09:42 <edwardk> cmccann: sweet =)
19:09:43 <cmccann> i.e., by unwrapping the Map type, running the resulting function type through djinn, then juggling lambdas and newtype wrapping to get it back into correct form
19:10:06 <edwardk> cmccann: want to add distribute from Control.Category.Distributive to that?
19:10:21 <cmccann> djinn is one of those things that makes one appreciate working in Haskell
19:10:25 <edwardk> yeah
19:10:39 <kmc> is juggling lambdas easier or harder than juggling chainsaws
19:12:00 <cmccann> kmc, as long as all you do is juggle it's fine, the problem is when you start evaluating things
19:12:06 <cmccann> beta reducing the chainsaws can be tricky
19:13:46 <edwardk> dobblego: i'm guessing the laws won't check out, there is no law relating your comonad to your monad
19:15:52 <dobblego> edwardk: yeah I got that too
19:16:26 <cmccann> edwardk, is Sum (Map r) = Either? you don't seem to have PreCoCartesian defined yet
19:18:38 <edwardk> yeah
19:18:51 <edwardk> i need to go through and do those too. i just ran out of steam ;)
19:20:10 <edwardk> you're welcome to take a crack at it ;)
19:23:18 <kmc> @remember cmccann beta reducing the chainsaws can be tricky
19:23:19 <lambdabot> Done.
19:24:31 <cmccann> :]
19:29:27 <dobblego> edwardk: Monad f => Lens a (f b) -> Lens b (f c) -> a -> f c ?
19:32:46 <gienah> I'm trying to figure out how to benchmark an IO action for the shootout with criterion, the criterion docs seem to say it should be easy to run an IO action, I'm not really getting it though
19:33:15 <kmc> class Benchmarkable a... instance Benchmarkable (IO a)
19:34:01 <gienah> I see that but I'm kind of new to typeclasses and am wondering how to use it
19:34:02 <kmc> runBenchmark :: Benchmarkable b => Environment -> b -> Criterion Sample
19:34:09 <kmc> withConfig :: Config -> Criterion a -> IO a
19:34:22 <kmc> ok well just pretend it's runBenchmark :: Environment -> IO a -> Criterion Sample
19:34:47 <kmc> this is admittedly more complex than i'd like
19:35:00 <kmc> but criterion is pretty sexy overall
19:35:18 <kmc> oh i think this is the main module you want:
19:35:20 <kmc> http://hackage.haskell.org/packages/archive/criterion/0.5.0.10/doc/html/Criterion-Main.html
19:35:30 <hpaste> gienah pasted “slow code” at http://hpaste.org/48937
19:35:44 <kmc> main = defaultMain [ myIOAction ]
19:36:04 <gienah> kmc: I pasted my failed attempt
19:36:15 <gienah> kmc: it does not compile
19:37:51 <edwardk> dobblego: that one works fine, since its not building a lens
19:38:09 <dobblego> edwardk: right, that's what I was thinking of, it's just not really more interesting than (>=>)
19:38:53 <edwardk> there is an obvious but wrong construction using an applicative as well that fails the laws
19:43:04 <edwardk> cmccann: i added precocartesian
19:43:21 <dobblego> edwardk: did you ever take a look at generating lenses for the scala compiler?
19:43:30 <cmccann> edwardk, ah, cool, was about to do it myself but okay
19:45:00 <edwardk> dobblego: not in much depth
19:45:33 <edwardk> cmccann: giving in and making () the unit of (,) and Void the unit of Either, and just ignoring _|_'s
19:45:50 <edwardk> going back and patching up categories to reflect that
19:45:55 <edwardk> its much more pleasant that way
19:46:41 <cmccann> well, not much choice if you want either to have a unit at all
19:46:47 <cmccann> Either that is
19:46:48 <cmccann> not either
19:47:58 <gienah> haskell is trounced by lisp in this benchmark, wishing I could figure out how to use criterion so I might have some chance of addressing this situation: http://shootout.alioth.debian.org/u64q/performance.php?test=fasta
19:48:11 <edwardk> yeah
19:54:20 * hackagebot categories 0.58.0 - categories from category-extras  http://hackage.haskell.org/package/categories-0.58.0 (EdwardKmett)
19:58:26 <hpaste> gienah pasted “criterion io action example” at http://hpaste.org/48938
20:00:08 <gienah> kmc: thanks, I pasted a trivial example that compiles for an IO action with no function argument, will use this approach
20:00:41 <kmc> right, I think you can't test functions -- how would it know what arg to give?
20:00:58 <kmc> the Pure thing is kind of a hack, and you still have to give the arg along with the function
20:01:11 <kmc> doing that with an IO action will not do what you want -- it will measure the time to evaluate the IO action, but not to execute it
20:02:38 <gienah> kmc: great, thanks.  I'll try profiling my little program (its currently not optimized, slow)
20:03:28 <cmccann> edwardk, you still around?
20:05:32 <edwardk> yeah
20:05:44 <edwardk> adding the missing arrow instances
20:06:03 <edwardk> and toying with a little module of geometric algebra on top of the nice linear algebra functionality this provides =)
20:07:05 <cmccann> edwardk, ah, cool :D
20:08:15 <edwardk> the weighted geometric product of basis blades works very nicely as a coassociative coalgebra =)
20:08:15 <edwardk> i rather like that the continuation passing basically swallows all thoughts of representation
20:08:26 * hackagebot algebra 0.2.0 - Constructive abstract algebra  http://hackage.haskell.org/package/algebra-0.2.0 (EdwardKmett)
20:08:50 <edwardk> that makes it properly cocartesian and adds arrowchoice
20:09:08 <edwardk> i also sugared the use of linear functionals the same way i did linear maps
20:09:11 * cmccann compares the instances edwardk added to what he had been toying with
20:09:37 <cmccann> I like my (|||) better :P
20:09:43 <cmccann> m ||| n = Map $ (|||) <$> (m $#) <*> (n $#)
20:09:44 <cmccann> heh
20:10:03 <kmc> but will coassociative coalgebras help me leverage the latest cloud technologies?
20:10:11 <edwardk> well, you can go to Linear m ||| Linear n = Map $ (|||) <$> m <*> n
20:10:33 <cmccann> edwardk, that works too
20:11:15 * cmccann just likes the obvious symmetry of that style rather than using either and whatnot
20:11:26 <edwardk> yeah, well, either IS just |||
20:11:26 <siracusa> When trying to connect to a host using connectTo I always get "Connection timed out (WSAETIMEDOUT)". Iis there a way to increase the timeout time?
20:11:42 <edwardk> fair nuff
20:11:47 <NemesisD> is there something in the prelude for representing ranges (of integers if that is important)
20:12:11 <parcs> (a, a)
20:12:14 <edwardk> Ix provides functionality for generating ranges
20:12:19 <cmccann> edwardk, of course, it's more the visual parallel that I like
20:12:23 <edwardk> @type inRange
20:12:23 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
20:12:25 <edwardk> sure
20:12:30 <ddarius> @src Ix
20:12:30 <lambdabot> class (Ord a) => Ix a where
20:12:30 <lambdabot>     range           :: (a,a) -> [a]
20:12:30 <lambdabot>     index           :: (a,a) -> a -> Int
20:12:30 <lambdabot>     inRange         :: (a,a) -> a -> Bool
20:12:30 <lambdabot>     rangeSize       :: (a,a) -> Int
20:12:47 <NemesisD> oh ok
20:13:13 <NemesisD> so if i had a range that had possibly no ending, i'd represent it as (Maybe Int, Maybe Int) ?
20:13:18 <edwardk> cmccann: mostly just happy they type check and are pure, so they are obviously safe ;)
20:13:20 <Peaker> I think Haskell arrays should migrate towards Oleg's existentially quantified index types that guarantee correct indexing
20:14:01 <Peaker> existentially/higher-ranked phantom types are so amazingly useful --- yet their only "common" use is in the ST monad?
20:14:06 <edwardk> nemesis: possibly, though there is no Ix instance for that so you'd have to roll your own combinators
20:14:19 <edwardk> peaker: i use them a lot
20:14:26 <edwardk> peaker: reflection, my ad package, etc.
20:16:00 <Peaker> edwardk: reflection is a package, or you mean the general PL sense?
20:16:10 <ddarius> @hackage reflect
20:16:11 <lambdabot> http://hackage.haskell.org/package/reflect
20:16:19 <ddarius> @hackage reflection
20:16:19 <lambdabot> http://hackage.haskell.org/package/reflection
20:16:36 <kmc> what do existential phantum types get you?
20:16:45 <kmc> or is that another way of describing the ST trick
20:16:47 <edwardk> the reflection package uses quantification rather critically =)
20:17:41 <edwardk> we tried encoding the existential version of ST thinking it'd be nicer in scala where universals are hard and existentials are easy, and it turned out to be crappy to work with ;)
20:18:02 <kmc> existentials are easier in Scala?
20:18:06 <kmc> because they're objects? ;)
20:18:13 <cmccann> edwardk, I have to say a lot of that module seems kinda silly though; while I'm starting to get a feel for how stuff works from playing with it, lots of that code is of the "only one implementation type checks and it's the correct one" variety and I basically wrote the curry/uncurry without any understanding. would be nice if that sort of thing was built in to GHC :T
20:18:14 <ddarius> Well the universal version implies the existential version, but not vice versa.
20:18:16 <kmc> is that a CPS transform or what?
20:18:23 <kmc> how would existential ST look in Haskell?
20:18:26 <NemesisD> so if i were to define an instance Ix for a range that may not have an end, would it be appropriate to define range (x, Nothing) = [x..] ?
20:18:44 <dobblego> I am using rank-2 in Scala atm
20:18:49 <dobblego> *rank-2 ST
20:18:49 <ddarius> NemesisD: Not really.
20:19:27 <edwardk> cmccann: the instances you are using all drop out because you don't look at the r. anything that programmatically manipulates a's and b's and leaves the r alone is safe from a linearity standpoint. its when you multiply 'r's together you need to be careful
20:19:32 <NemesisD> ddarius: what would be more appropriate
20:19:32 <ddarius> NemesisD: You should more clearly specify what "range" means to you (i.e. what operations you want on these "ranges" and what you intend to use them for) so people can give you more useful suggestions..
20:19:38 <alpounet> edwardk, hey, what will you use your algebra package for?
20:19:41 <edwardk> cmccann: then you risk compromising the linearity of the map
20:20:09 <edwardk> alpounet: i have a bunch of code for manipulating pade approximants that needed a more general way to represent polynomials
20:20:49 <NemesisD> ddarius: im starting to believe that it may not be meaningful to have an Ix instance. I'm trying to specify a range of years for a musical artist. artists that are still active do not have an end year
20:21:10 <edwardk> alpounet: in particular that will let me take the taylor series i can generate from my ad package and generate a much tighter approximation for functions that have poles, and then since i have a rational function approximation, i can do better integration using chebyshev-pade approximation
20:22:13 <cmccann> edwardk, yeah, just seems like it would be nice to be able to use something like djinn to fill in that kind of instance automatically
20:22:36 <edwardk> cmccann: when you look at the instances for monadplus you see where linearity gets used
20:22:41 <ddarius> NemesisD: So what operations do you want?
20:22:46 <edwardk> er monadplus, etc
20:23:01 <edwardk> cmccann: yes, that is what agda is all about =)
20:23:20 <djahandarie> "all about" might be a little misleading
20:23:20 <edwardk> cmccann: you just get local holes to fill in and can ask agda to do the obvious thing for you
20:23:33 <djahandarie> Also
20:23:43 <djahandarie> edwardk, hurry up :p
20:23:44 <cmccann> edwardk, right, anything that has a constraint on r in the context can pull shenanigans if it wants to
20:23:46 <ddarius> main = {-! DWIM !-}
20:23:55 <NemesisD> ddarius: it is a library and handling date ranges isn't the focus of it so i think i've talked myself out of any operations on those year ranges
20:24:05 <alpounet> edwardk, ok, looks nice! will you use this for actual production code ?
20:24:07 <NemesisD> the user can deal with them how they will
20:24:22 <edwardk> alpounet: thats the plan
20:24:35 <alpounet> great
20:24:53 <edwardk> alpounet: Numeric.Map.Linear is probably the most interesting thing in there so far
20:25:50 <edwardk> in particular that it defines multiplication on linear maps in terms of a coassociative counital coalgebra on the source vector space, which lets me do things like multiply chebyshev polynomials despite the fact that those don't form a group ring.
20:26:18 <edwardk> that and i can do convolution of linear maps using hopf algebras, etc. lots of fun stuff is starting to work
20:27:11 <alpounet> you can take this quite far indeed
20:27:18 <edwardk> alpounet: i'm planning to blog the coalgebra trick soon
20:27:42 <cmccann> edwardk, Numeric/Group/Additive.hs:14:8: Could not find module `Numeric.Module.Class'
20:27:50 <edwardk> doh
20:27:55 <cmccann> :]
20:28:08 <edwardk> i hate the fact that cabal will locally compile fine if i omit packages from the cabal file =(
20:28:43 <cmccann> heh, I didn't know it would do that
20:30:31 <alpounet> edwardk, i could very well make use of some of these stuffs next year so i'll keep an eye on this and your blog
20:30:58 <edwardk> cmccann: testing from a source dist before pushing
20:31:32 <edwardk> k. built clean. pushing
20:31:38 * hackagebot algebra 0.3.0 - Constructive abstract algebra  http://hackage.haskell.org/package/algebra-0.3.0 (EdwardKmett)
20:31:58 <kmc> edwardk measures API lifetime in hours
20:31:59 * cmccann is contemplating dumping some hackish prelude replacement stuff he'd been using in favor of something based on some of edwardk's stuff
20:32:10 <gwern> bad couple of days for spam on hawiki
20:32:13 <edwardk> kmc: minutes ;)
20:32:21 <kmc> that's how you get to version 4000
20:32:23 <ddarius> This is actually a fairly tame rate for him.
20:32:31 <djahandarie> @quote kmc edwardk measures API lifetime in hours
20:32:31 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
20:32:35 <djahandarie> @remember kmc edwardk measures API lifetime in hours
20:32:35 <lambdabot> Done.
20:32:47 <edwardk> ddarius: thats because everything is in one package, rather than spread across 20
20:32:48 <gwern> I need a button called 'disappear', like in south america. click the button and the user is indef blocked, all edits rollbacked, and all created pages deleted
20:32:54 <kmc> or you can be like linus and not bump the first component for 10 years and then one day you're just "LINUX THREE POINT OH BITCHES"
20:33:09 <ddarius> edwardk: I believe speculative evolved very quickly.
20:33:15 <edwardk> yeah true
20:33:19 <kmc> haha gwern
20:33:35 <ddarius> gwern: Modify MediaWiki.
20:33:42 <kmc> name your plugin Operation Condor
20:33:52 <gwern> ddarius: yeah, I'll get to that right after I commit suicide in despair
20:33:55 <edwardk> cmccann: it load for you now?
20:34:09 <ddarius> gwern: After you're dead is a great time to accomplish things.
20:34:13 <gwern> (despair! despair! this pile of php has left me in despair!)
20:34:14 <cmccann> edwardk, seems to be working
20:34:23 <kmc> refactor your php with haskell
20:34:25 <kmc> for great good
20:34:52 <cmccann> edwardk, yep, it's good :]
20:35:46 <edwardk> sweet =)
20:35:59 <edwardk> now i get to track down all the missing obvious instances
20:36:05 * cmccann calculates roughly 7.3 years before edwardk's packages reach an average version of ω
20:36:11 <ddarius> The depths of parametric polymorphism have hardly been tapped.
20:36:57 <gwern> ddarius: ah, but edwardk would tap that
20:37:37 <cmccann> ddarius, at this point I'd like to see GHC support kind polymorphism just to see what edwardk would find to do with it
20:37:56 <edwardk> cmccann: we had it for a while in our toy language at work =)
20:38:13 <edwardk> cmccann: but if i ever want it i can always go slumming in agda
20:39:14 <cmccann> I really need to spend more time playing with agda :T
20:40:36 <edwardk> i still can't get over how much more fun this polynomial representation is than all my previous ones =)
20:41:26 <cmccann> edwardk, I just wish it weren't so tedious to deal with that many fine-grained instances all over the place :[
20:41:44 <edwardk> cmccann: yeah
20:42:05 <edwardk> my major benefit comes from the fact that for each basis now i only need to define two instances.
20:42:21 <edwardk> FreeCoalgebra and FreeUnitalCoalgebra
20:42:36 <edwardk> and then my polynomials start to work
20:43:07 <edwardk> and if i want them to work with vectors as well as covectors, i need the more annoying algebras
20:43:27 <edwardk> which precludes me from working with laurent series, etc.
20:43:40 <cmccann> yeah, the polynomials part is really pretty
20:44:27 <ddarius> edwardk: Maybe you should get a paper published.
20:44:52 <edwardk> ddarius: i might. i really like this one =)
20:44:52 <cmccann> I'm more thinking in general, that having a huge hierarchy of classes is painful when adding arbitrary new types for things that don't just build from a tidy generic form
20:45:24 <edwardk> cmccann: yeah, it is a consequence of haskell's lack of whitebox inheritance
20:50:08 <MHD> Man, you guys know how badly screwed up GLFW and GLFWb is?
20:50:42 <MHD> code like "r <- ((\hsc_ptr -> peekByteOff hsc_ptr 8))   ptr :: IO CInt" is totally a thing...
20:51:10 <MHD> (that should be "r <- peekByteOff ptr 8")
20:51:16 <ddarius> Looks like generated code.
20:51:36 <ddarius> Generated perhaps by hsc.
20:51:44 <MHD> proably
20:51:44 <kmc> i second that
20:51:57 <cmccann> ddarius, brilliant deduction!
20:52:12 <MHD> It is also a bad API in general, GLFWb
20:52:20 <napping> probably turns @field into (\ptr -> peekByteOff ptr <field_offset>)
20:53:04 <Peaker> kmc: Existentials give you type indices determined by your library, rather than by the user -- so the library can enforce interesting relationships between values.. In ST's case, it is that all of the ST mutable state relates to/is used in the same computation.  With Lists, for example, you can enforce things like "all of these lists are different points in the same stream", with arrays/indices, you can say: Index is suitable for use with array safely (
20:53:05 <Peaker> no runtime checking needed), etc.
20:53:21 <MHD> There's this data structure called "DisplayOpetions" which has 20-something members all named displayOption_<something rather wordy>
20:53:27 <MHD> Just madness
20:53:43 <kmc> Peaker, how does existential ST look, concretely?
20:53:50 <kmc> and how does the index checking one look?
20:56:03 <Peaker> kmc: I'm just talking about the ordinary ST
20:56:08 <kmc> oh
20:56:15 <kmc> you count that as existential?
20:56:21 <dolio> The ordinary ST isn't existential.
20:56:21 <kmc> i guess that's fair
20:56:29 <kmc> runST is sort of a CPS-transformed existential something
20:56:53 <Peaker> yeah.. the "s" variable is polymorphic *against* the user of the ST library, IOW the library determines it, not the user
20:57:14 <Peaker> Culeado is spamming #haskell users
20:57:30 <kmc> the GNAA, the most feared of all trolling groups
20:57:47 <Peaker> ops? ban Culeado?
20:57:54 <Culeado> What did I do wrong?
20:58:31 <ddarius> kmc: No.  As I mentioned the universal type for runST is stronger than the existential type it implies.
21:02:08 <dolio> You'd need something more classical than Haskell permits to pull the quantifier out.
21:02:21 <ski> ddarius : which existential type is that ?
21:02:53 <NemesisD> im not quite convinced xml-enumerator is a great choice for parsing xml docs
21:02:57 <ddarius> exists s. ST s a -> a
21:03:54 <ski> ok
21:04:08 <ddarius> dolio: You can pull it out, you just can't put it back.
21:04:23 <ski> Mercury has basically `initStore :: exists s. Store s'. see `store.init' at  <http://www.mercury.csse.unimelb.edu.au/information/doc-latest/mercury_library/store.html>  -- but that's of course not the same
21:04:47 <dolio> To make the two equivalent.
21:06:29 --- mode: ChanServ set +o monochrom
21:06:36 --- mode: monochrom set +b *!18788ea5@gateway/web/freenode/ip.24.120.142.165
21:06:42 --- kick: Culeado was kicked by monochrom (Culeado)
21:06:51 --- mode: monochrom set -o monochrom
21:07:43 <kmc> hmm, i see
21:07:57 <kmc> "there exists some s for which I'll run your ST action, but i won't tell you which"
21:08:10 <kmc> which we fake instead with the rank-2 universal
21:08:14 <kmc> @type runST
21:08:15 <lambdabot> forall a. (forall s. ST s a) -> a
21:08:18 <dolio> No.
21:08:28 <kmc> no?
21:08:30 <napping> the universal is stronger
21:08:44 <kmc> how so
21:08:53 <napping> you could open the existential, and make an ST action of that type
21:08:54 <dolio> The universal prevents two things.
21:09:08 <kmc> hmm, right, it prevents ST actions from interfering with each other
21:09:09 <dolio> One is STRefs escaping a block.
21:09:11 <kmc> which the existential doesn't
21:09:15 <dolio> Right.
21:09:54 <kmc> because you can say "fine, you have some s, I'll call it t, now let's build two ST actions with that t"
21:11:16 <dolio> Yes. And you could even run an ST t (STRef t a) -> STRef t a, depending on how lax one is with the quantifier reordering.
21:11:35 <dolio> Since you know it's some t, even if you don't know which.
21:13:35 <dolio> I guess maybe you can't actually accomplish that.
21:14:38 <dolio> But having ST t a -> a for some fixed t is still not what you want.
21:15:30 <ddarius> dolio was right, I did switch it up.  f :: (exists s. ST s a -> a) -> (forall s. ST s a) -> a; f (t, runST) action = runST (action @t); demonstrating how to get the universal from the existential.
21:18:00 * hackagebot enumerator 0.4.11 - Reliable, high-performance processing with left-fold enumerators  http://hackage.haskell.org/package/enumerator-0.4.11 (JohnMillikin)
21:18:00 <ddarius> You can't go the other way because you have no way of actually producing the s to pack into the existential.
21:19:30 --- mode: ChanServ set +o copumpkin
21:19:58 --- mode: copumpkin set -o copumpkin
21:23:59 <Jesin> I propose on behalf of a friend of mine
21:24:44 <Jesin> that instead of calling it "bottom", _|_ should be pronounced "shrug"
21:30:48 <napping> what's up with the name changes?
21:31:20 <dobblego> an issue with a spambot
21:37:33 <eyu100> @pf a = undefined a
21:37:34 <lambdabot> Maybe you meant: bf pl
21:37:39 <eyu100> @pl a = undefined a
21:37:39 <lambdabot> a = fix undefined
21:38:51 <Jesin> @pl fix id
21:38:51 <lambdabot> fix id
21:39:00 <Jesin> @pl let x = x in x
21:39:00 <lambdabot> fix id
21:39:19 <Jesin> @pl let x = fix x in x
21:39:19 <lambdabot> fix fix
21:39:28 <Jesin> :t fix fix
21:39:28 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
21:39:28 <lambdabot>     Probable cause: `fix' is applied to too many arguments
21:39:29 <lambdabot>     In the first argument of `fix', namely `fix'
21:39:39 <kmc> > fix error
21:39:40 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
21:39:44 <Jesin> ...
21:39:45 <cmccann> :]
21:39:46 <Jesin> XD
21:39:52 <Jesin> nice
21:40:00 <cmccann> that never stops being funny
21:40:05 <kmc> nope
21:40:15 <djahandarie> @. elite nixon
21:40:16 <lambdabot> iN A fLAt cHOic3 bE7w33n smoKe 4ND J0B$, we'r3 for joBz...8ut jUst KeEp Me OUt OF 7roUbLE ON eN\/IrOnmENtal izsu3z.
21:40:51 <kmc> @@ @elite @nixon
21:40:51 <lambdabot>  iN 4 ph1A+ (|-|OIC3 B3TWE3n z/\/\OxE AND jO8s, We'RE foR Jo8z...8UT juSt KEEp Me oUt 0f tROU8L3 oN envIroNmEnTa1 ISsU3s.
21:41:05 <ski> (.. oh, is it that time again ?)
21:42:07 <eyu100> > fix undefined
21:42:07 <lambdabot>   *Exception: Prelude.undefined
21:42:18 <Jesin> @? @
21:42:18 <lambdabot> Plugin `compose' failed with: Unknown command: ""
21:42:21 <Jesin> @help @
21:42:22 <lambdabot>  @ [args].
21:42:22 <lambdabot>  @ executes plugin invocations in its arguments, parentheses can be used.
21:42:22 <lambdabot>  The commands are right associative.
21:42:22 <lambdabot>  For example:    @ @pl @undo code
21:42:22 <lambdabot>  is the same as: @ (@pl (@undo code))
21:42:25 <eyu100> > fix (undefined :: forall a. String -> a)
21:42:25 <lambdabot>   "*Exception: Prelude.undefined
21:42:39 <kmc> @. run run (text . map succ) "ehw''/9(-rb`mk'*(0("
21:42:40 <Jesin> @help nixon
21:42:42 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
21:42:42 <lambdabot> Richad Nixon's finest.
21:42:45 <eyu100> > 1#
21:42:46 <lambdabot>   Couldn't match kind `#' against `*'
21:42:54 <Jesin> ...what
21:42:56 <eyu100> > (# #)
21:42:57 <lambdabot>   No instance for (GHC.Show.Show (t -> (# t #)))
21:42:57 <lambdabot>    arising from a use of `M5...
21:42:59 <kmc> metaprogrammin
21:43:02 <kmc> > () :: 1
21:43:03 <lambdabot>   Couldn't match expected type `GHC.Generics.Unit'
21:43:03 <lambdabot>         against inferred t...
21:43:11 <Jesin> @. run run (text . map succ) "ehw''/9(-rb`mk'*(0("
21:43:14 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
21:43:15 <ski> > case (# #) of (# #) -> "ok"
21:43:15 <lambdabot>   Couldn't match expected type `t -> (# t #)'
21:43:16 <lambdabot>         against inferred type `...
21:43:20 <eyu100> @nixon
21:43:20 <lambdabot> I brought myself down. I impeached myself by resigning.
21:43:27 <kmc> @run (text . map succ) "ehw''/9(-rb`mk'*(0("
21:43:28 <lambdabot>   fix((0:).scanl(+)1)
21:43:34 <eyu100> > 1 :: 1
21:43:35 <lambdabot>   No instance for (GHC.Num.Num GHC.Generics.Unit)
21:43:35 <lambdabot>    arising from the literal...
21:43:36 <ddarius> ski: (# #) is apparently the unboxed singleton tuple constructor.
21:43:50 <ski> > case (# "ok" #) of (# ok #) -> ok
21:43:51 <lambdabot>   "ok"
21:43:56 <ski> yeah, i noticed
21:43:57 <eyu100> :kind (# #)
21:44:06 <ski> @type (# #)
21:44:06 <lambdabot> forall t. t -> (# t #)
21:44:11 <kmc> @kind (# Int #)
21:44:12 <eyu100> @kind (# #)
21:44:12 <lambdabot> (#)
21:44:13 <lambdabot> ? -> (#)
21:44:19 <kmc> @kind (# #) Bool
21:44:20 <lambdabot> (#)
21:44:24 <eyu100> > (# #) 1
21:44:25 <lambdabot>   Illegal binding of unboxed tuple e_11 :: (# t_a397 #)
21:44:29 <kmc> @kind (# (# Int #) #)
21:44:30 <lambdabot> (#)
21:44:40 <ski> @type (#)  -- second guess was that this was the unboxed nuple, but nay
21:44:41 <lambdabot> parse error on input `)'
21:44:48 <kmc> > case (# (# 2 #) #) of (# (# x #) #) -> x
21:44:49 <lambdabot>   Couldn't match kind `(#)' against `??'
21:44:56 <eyu100> @kind IO
21:44:57 <lambdabot> * -> *
21:45:03 <eyu100> @kind (->)
21:45:04 <lambdabot> ?? -> ? -> *
21:45:16 <ski> kmc : no unboxed tuple arguments for you !
21:45:32 <kmc> > case (# (# 2 #) #) of { (# y #) -> case y of { (# z #) -> z } }
21:45:32 <lambdabot>   Couldn't match kind `(#)' against `??'
21:45:35 <kmc> ;P
21:46:00 <eyu100> > (1#, 1)
21:46:01 <lambdabot>   Couldn't match kind `#' against `*'
21:46:01 <ski> kmc : `(#)' is simply not a sub-kind of `??'
21:46:04 <kmc> yeah
21:46:09 <kmc> but how is it an argument here?
21:46:40 <Jesin> @help run
21:46:40 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
21:46:40 <kmc> ok it's an argument to the case continuation i guess
21:46:42 <Jesin> @help .
21:46:42 <lambdabot> . <cmd1> <cmd2> [args].
21:46:42 <lambdabot> . [or compose] is the composition of two plugins
21:46:42 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
21:46:52 <Axman6> :t (# 1 #)
21:46:53 <lambdabot> forall t. (Num t) => (# t #)
21:46:58 <djahandarie> byorgey, by the way, how do you handle the sub-typing in the kind level with your typekinds?
21:47:30 <eyu100> @kind (,)
21:47:31 <lambdabot> * -> * -> *
21:47:31 <ski> > case (# (# 2 #) #) of { (# #) y -> case y of { (# #) z -> z } }
21:47:32 <lambdabot>   Couldn't match kind `(#)' against `??'
21:47:34 <ski> > case (# #) ((# #) 2) of { (# #) y -> case y of { (# #) z -> z } }
21:47:35 <lambdabot>   The variable `y' cannot be bound to an unboxed tuple
21:47:47 <eyu100> :type (->) Int Int
21:47:56 <eyu100> @type (->) Int Int
21:47:56 <lambdabot> parse error on input `->'
21:48:03 <ski> @type (# #)   -- kmc, a function, see
21:48:03 <kmc> @kind (->) Int Int
21:48:04 <lambdabot> forall t. t -> (# t #)
21:48:04 <lambdabot> *
21:48:27 <eyu100> @type undefined :: (->) Int Int
21:48:28 <lambdabot> Int -> Int
21:48:53 <eyu100> > undefined :: RealWorld
21:48:54 <lambdabot>   Not in scope: type constructor or class `RealWorld'
21:49:11 <_Ray_> Hi. I know that undefined <= x for every x in every type a. Does this apply to functions as well? Meaning, is undefined <= f, for any f in a -> b?
21:49:46 <ski> @type undefined :: Control.Monad.ST.RealWorld
21:49:46 <lambdabot> GHC.Prim.RealWorld
21:50:39 <ski> _Ray_ : i'd write `=[', to emphasize this isn't the `(<=)' ordering inside Haskell
21:50:59 <cmccann> =[ looks like a sad emoticon
21:51:00 <ski> _Ray_ : yes, in domain theory, `_|_ =[ a', for any value `a' in any domain
21:51:00 <eyu100> @t undefined :: GHC.Prim.RealWorld
21:51:00 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
21:51:08 <ddarius> _Ray_: There is nothing special about function types.
21:51:09 <Jesin> what are typekinds
21:51:09 <eyu100> @type undefined :: GHC.Prim.RealWorld
21:51:10 <lambdabot> GHC.Prim.RealWorld
21:51:14 <eyu100> @type undefined :: [GHC.Prim.RealWorld]
21:51:15 <lambdabot> [GHC.Prim.RealWorld]
21:51:32 <ski> eyu100 : what did you expect ?
21:51:36 <_Ray_> Well, I ask because when using fix f = f(fix f) to find fixed points of functions, it worked in the case of the typical factorial, but not when I wanted to find the fixpoint of, say, a polynomial.
21:51:55 <ddarius> _Ray_: It worked then too.
21:52:00 <_Ray_> It "worked", since it "returned" undefined, and undefined /is/ a fixpoint of any polynomial.
21:52:06 <ski> _Ray_ : of course it worked. it's just that it's not using the ordering you wanted it to use
21:52:10 <eyu100> @type fix undefined
21:52:11 <lambdabot> forall a. a
21:52:20 <_Ray_> But I was told this was because (as per the Kleene-whatever theorem) fixing in this way returns the least fixed point, correct?
21:52:25 <eyu100> @type undefined fix
21:52:26 <lambdabot> forall t. t
21:52:26 <Jesin> [00:55:18]	<ski>	_Ray_ : yes, in domain theory, `_|_ =[ a', for any value `a' in any domain
21:52:28 <Jesin> Okay
21:52:55 <Jesin> I'm bringing in my proposal of pronouncing _|_ as "shrug" instead of "bottom"
21:53:12 <edwardk> heh reflection can be useful for showing phantom types
21:53:18 <Jesin> 'yes, in domain theory, "shrug frowns a", for any value a'
21:53:21 <cmccann> man, you can do all kinds of horrible stuff with TH, this is pretty fun
21:53:21 <eyu100> can unboxed types be undefined?
21:53:23 <_Ray_> My question is, if fix of a polynomial returns undefined because undefined is the least fixed point, why doesn't fix return undefined for... everything?
21:53:46 <eyu100> depends on laziness?  I read that on wikibooks, I really have no idea
21:53:47 <ddarius> Jesin: undefined is a special case of the general concept of bottom of a lattice usually written _|_.
21:54:11 <kmc> _Ray_, sometimes undefined is not a fixed point
21:54:15 <ski> eyu100 : can boxed types be undefined ?
21:54:21 <kmc> for example, it's not a fixed point of (1:)
21:54:29 <_Ray_> kmc: Hrm, when an argument isn't even evaluated?
21:54:32 <eyu100> ski : yes?
21:54:35 <kmc> (1 : undefined) can be distinguished from 'undefined'
21:54:36 <eyu100> @type undefined :: Int#
21:54:37 <lambdabot> Not in scope: type constructor or class `Int#'
21:54:39 <kmc> > fix (1:)
21:54:39 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
21:54:41 <Jesin> ah, fine
21:54:46 <ski> eyu100 : how do you define an undefined type ?
21:54:48 <eyu100> @type undefined :: GHC.Prim.Int#
21:54:49 <lambdabot>     Couldn't match kind `*' against `#'
21:54:49 <lambdabot>     When matching the kinds of `a :: *' and `GHC.Prim.Int# :: #'
21:54:49 <lambdabot>       Expected type: GHC.Prim.Int#
21:54:54 <Codex_> wouldnt it be nice if we had equation solving in the language?
21:54:57 <Jesin> I still say that forall a. shrug frowns a
21:55:00 <Jesin> :p
21:55:21 <eyu100> ski : oops lol
21:55:27 <_Ray_> Oh, cool, (1: undefined) isn't undefined.
21:55:36 <kmc> Codex_, there are lots of SMT solver libraries now
21:55:42 <eyu100> :k forall (a :: *). a
21:55:43 <lambdabot> *
21:55:53 <eyu100> :k forall (a :: #). a
21:55:53 <lambdabot> parse error on input `#)'
21:55:57 <kmc> > case (1:undefined) of (x:_) -> x
21:55:58 <lambdabot>   1
21:56:10 <_Ray_> kmc: But if undefined /is/ a fixpoint of a function, will fix "return undefined"?
21:56:14 <kmc> yes
21:56:27 <kmc> "f is strict" is defined to mean "f ⊥ = ⊥"
21:56:29 <_Ray_> Is there a common name for "functions for which undefined is a fixpoint"?
21:56:31 <_Ray_> Ah
21:56:31 <_Ray_> :)
21:56:46 <eyu100> @type undefined :: IO (IO (IO (IO Int)))
21:56:46 <lambdabot> IO (IO (IO (IO Int)))
21:56:47 <kmc> that's why 'id' is considered strict, even though it "doesn't do anything"
21:56:51 <shachaf> _Ray_: Note that that means that (const undefined) is strict.
21:56:51 <ddarius> If undefined is a fixed point, then it is necessarily the least fixed point since it is the least element period.
21:57:01 <eyu100> @type return.return.return
21:57:01 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) a (m2 :: * -> *). (Monad m, Monad m1, Monad m2) => a -> m (m1 (m2 a))
21:57:02 <ski> @type case let f :: () -> GHC.Base.Int#; f () = f () in f () of n -> GHC.Base.I# n  -- eyu100
21:57:03 <lambdabot> Int
21:57:20 <_Ray_> Huh, well, that's true. So that's an example of a function which ignores its argument, but still has undefined as a fixpoint.
21:57:23 <kmc> _Ray_, ezyang and conal both have some great posts about this lattice of partially-defined values
21:57:34 <kmc> with nice pictures
21:57:44 * _Ray_ googles. Thanks! :)
21:57:47 <Codex_> kmc: what's smt?
21:57:51 <shachaf> kmc: id is considered strict because evaluating the value it returns evaluates the argument it was called with. That seems less unintuitive.
21:58:04 <kmc> for example ⊥ < (1,⊥) < (1,2) and ⊥ < (⊥,2) < (1,2) but (1,⊥) and (⊥,2) are not ordered wrt each other
21:58:24 <MHD> ski: I don't think let expressions in the case denominator? is good haskell
21:58:26 <kmc> hmm 1 and ⊥ look unfortunately similar in my console font
21:58:43 <ski> MHD : seemed to do the job nicely, here ..
21:58:45 <kmc> _Ray_, conal's 'lub' function lets you combine partial information
21:58:48 <_Ray_> Is that what is meant by "lattice"?
21:58:56 <kmc> lub (2,⊥) (⊥,3) = (2,3)
21:59:06 <kmc> _Ray_, http://en.wikipedia.org/wiki/Lattice_(order)
21:59:13 <MHD> Hey, gueys what do you call the spot the X has in "case X of ..."
21:59:18 <kmc> a lattice is a partially-ordered set with greatest lower bounds and least upper bounds
21:59:20 <kmc> MHD, the scrutinee
21:59:26 <_Ray_> Ah, nice :)
21:59:44 <MHD> kmc: Cool
21:59:49 <ddarius> shachaf: id is considered strict because id undefined = undefined.  Full stop.
21:59:50 * ski is the kind of person who'll sometimes write `(if b then f else g) x' rather than `if b then f x else g x'
22:00:14 * MHD understands ski completely
22:00:22 * MHD also does that sometimes
22:00:28 <ddarius> ski: Why wouldn't you?
22:00:48 <MHD> ddarius: Because it is had to read
22:00:59 <cmccann> it is?
22:01:00 <ski> MHD : the role `X' is playing in `case X of {...}' is called "scrutinee"
22:01:17 <MHD> ski: kmc said that too :)
22:01:29 <ski> (MHD : sorry, didn't notice)
22:01:34 <MHD> what other things in the haskell syntax have specific names?
22:02:00 <kmc> most of it?
22:02:05 <MHD> cool
22:02:10 <MHD> is there a compendium?
22:02:13 <kmc> every nonterminal of the grammar in the Haskell Report has a name
22:02:20 <kmc> they might not be recognizable to most people, though
22:03:01 <MHD> shit, let's be haskell hipsters and refer to syntax constructs  by names you've never heard of.
22:03:04 <ski> ddarius : i guess it could depend on whether i thought i'd likely later rewrite `f x' or `g x' to something not of form `(...) x'
22:03:51 <eyu100> > fix undefined
22:03:52 <lambdabot>   *Exception: Prelude.undefined
22:04:07 <eyu100> so fix is strict?
22:04:11 <MHD> also, for the "(if b the nf else g) x" is only really responsible if x is very long
22:04:34 <eyu100> > const undefined
22:04:35 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> a)
22:04:35 <lambdabot>    arising from a use of `...
22:04:41 <MHD> and in that case "let x = ... in if b then f x else g x" is better
22:04:46 <ski> MHD : i use `<conditional> ::= if <condition> then <consequent> else <alternate>'
22:04:57 <eyu100> > undefined undefined
22:04:58 <lambdabot>   *Exception: Prelude.undefined
22:05:06 <MHD> ski: nice
22:05:08 <kmc> eyu100, yeah
22:05:18 <MHD> now I have something to call my crammar elements
22:05:19 <kmc> fix f = let x = f x in x
22:05:19 <eyu100> apparently undefined is strict too
22:05:44 <MHD> holy cow my spelling is dead
22:06:05 <ddarius> Technically the Report never says "statement," only stmt.
22:06:08 <kmc> force (fix ⊥) ⇒ force (let x = ⊥ x in x) ⇒ force (⊥ x) ⇒ force (⊥) ⇒ ⊥
22:06:09 <Cale> > fix undefined `seq` 0
22:06:10 <lambdabot>   *Exception: Prelude.undefined
22:06:23 <ski> ddarius : hm, the other day you said something like subtyping being based on implicit injections. i was thinking it was both implicit injections and projections ?
22:06:28 <Cale> > fix (const undefined) `seq` 0
22:06:28 <eyu100> > force
22:06:28 <lambdabot>   *Exception: Prelude.undefined
22:06:29 <lambdabot>   Not in scope: `force'
22:06:31 <_Ray_> "fix f = let x = f x in x" is both wrong and right on so many levels :D
22:06:40 <kmc> that's the more efficient implementation
22:06:44 <Cale> why would it be wrong?
22:06:48 <kmc> «fix f = f (fix f)» is also correct
22:07:00 <eyu100> @pl fix
22:07:00 <lambdabot> fix
22:07:06 <_Ray_> "x = f x" seems wrong
22:07:07 <eyu100> @pl fix f = f (fix f)
22:07:07 <lambdabot> fix = fix (ap id)
22:07:08 <kmc> but with that version something like (fix (1:)) can unfurl in memory to an arbitrarily long list
22:07:15 <kmc> with the 'let' version that doesn't happen
22:07:21 <Cale> _Ray_: that's the definition of what it means for x to be a fixed point
22:07:27 <_Ray_> Right, right.
22:07:44 <kmc> recursion has to be "built in" to languages based on the typed lambda calculus
22:07:48 <eyu100> > let f = f (ap id) in f (1:)
22:07:49 <lambdabot>   Occurs check: cannot construct the infinite type:
22:07:49 <lambdabot>    t = (((a -> b) -> a) -...
22:07:50 <kmc> you can't implement 'fix' in STLC
22:07:58 <kmc> however Haskell has a few different constructs you can use
22:08:06 <kmc> there's "let"/"where" recursion, recursive data types, IORef, and a few others
22:08:07 * ski prefers the term "command" to "statement"
22:08:09 <kmc> Oleg has a paper on this
22:08:27 <MHD> * MHD prefers the term "cell" to "variable"
22:08:32 <_Ray_> x = f x seems weird because my brain asks "Ok, and where do you start?"
22:08:40 <MHD> f***
22:08:43 <kmc> http://okmij.org/ftp/Haskell/Fix.hs
22:08:52 * MHD cannot think straight right now
22:08:54 <kmc> hmm i thought IORef was one
22:08:55 <_Ray_> Since x seems to be used in its own definition, which is weird mathematically.
22:09:06 <kmc> _Ray_, no, that is how many mathematical things are defined
22:09:15 <eyu100> so in haskell, you cannot always tell if a function is strict because otherwise you could solve the halting problem?
22:09:17 <kmc> every natural number is either zero or the successor of a natural number
22:09:38 <_Ray_> Right, that I get, but defining an element in terms of itself is weird
22:09:51 <kmc> it's no weirder than defining a function in terms of itself
22:09:52 <_Ray_> Though I guess it's OK to say "x such that x = f x".
22:09:54 <kmc> which you do in many languages
22:10:19 <kmc> you're asking "where do you start" at the wrong place
22:10:31 <MHD> _Ray_: would "fix f = x where x = f x" be better?
22:10:46 <kmc> consider «let x = 1 : x in head x»
22:10:59 * ski wants names for the roles `a' and `tau' are playing in `forall a. tau' and `exists a. tau'
22:10:59 <cmccann> > let s f g x = f x (g x); i x = x in s i i
22:11:00 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
22:11:01 <kmc> «let x = 1 : x» doesn't specify the starting point
22:11:03 <_Ray_> that is also very weird to me, as well as the fibonacci one
22:11:05 <kmc> it's «in head x»
22:11:15 <_Ray_> ski: existential quantifiers?
22:11:18 <ski> i'm tentatively using "quantificand" for the `tau' one
22:11:25 <eyu100> > (:[])
22:11:26 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> [a])
22:11:26 <lambdabot>    arising from a use of...
22:11:39 <eyu100> > (:[]) 1
22:11:40 <lambdabot>   [1]
22:11:44 <kmc> _Ray_, you can think of it as «let x = 1 : x» creating a (:)-cell whose first element points to a 1, and whose second points back to itself
22:11:48 <eyu100> the (:[]) "gobbles" 1
22:11:53 <ski> _Ray_ : i said i want names for the *roles* of the direct sub-terms there
22:11:55 <kmc> that's a perfectly reasonable data structure
22:12:04 <MHD> ski: have you written those names down?
22:12:18 <ddarius> ski: Bound variable and body of the universal/existential.
22:12:28 <kmc> _Ray_, but sometimes the self-pointers live in thunks, not data values
22:12:30 <ski> MHD : which ? i just wrote "quantificand" down above, and also just now
22:12:46 <kmc> > let odds = 1 : map succ evens; evens = map succ odds in odds
22:12:47 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
22:12:59 <_Ray_> kmc: thunks being "piece of possibly unevaluated code", correct?
22:13:01 <napping> _Ray_: semantically, you start at bottom
22:13:17 <ski> ddarius : that's correct, though i was hoping for something that didn't sound as much as an amalgamation of words
22:13:24 <kmc> _Ray_, i would say "definitely unevaluated" though sometimes the evaluation turns out to be trivial
22:13:41 <MHD> > let f g = g (f g) in (f (1:) !! 30000)
22:13:41 <lambdabot>   1
22:13:46 <MHD> > let f g = g (f g) in (f (1:) !! 300000)
22:13:47 <lambdabot>   1
22:13:51 <kmc> in the GHC runtime system there are various different classes of objects in the heap; one of them is "thunk"
22:14:07 <napping> given a definition like x = 1:x, extract the function v=>(1:v), and find the least fixedpoint
22:14:07 <ski> e.g. for integrals we have "integrand"
22:14:14 <kmc> (various types? various kinds? various sorts? various categories? stupid mathematicians taking all the words)
22:14:52 <ski> napping : "extract the function ..." is not unique
22:14:54 <kmc> _Ray_, anyway, in my example the "let" constructs a (:)-cell for 'odds', whose right arg is a thunk, which hold a pointer to 'evens'
22:15:16 <kmc> it closes over a pointer to 'evens'
22:15:21 <_Ray_> is it useful to think about these expressions in terms of "what would ghc translate this to"? (as in the case of the self referential list, thinking of it as pointers and linked lists)
22:15:24 <kmc> thunks have free variables as closures do
22:15:39 <napping> ski: how is it not? abstract the rhs over the variable bound
22:15:42 <kmc> _Ray_, yes, I think so.  Haskell has a nice interpretation in terms of abstract graph reduction
22:15:50 <kmc> there are of course many irrelevant details of what GHC actually does
22:16:05 <NemesisD> anyone in here ever use xml-enumerator? i'm afraid the singular example available in the docs isn't quite complete enough for me. was looking for some good sample code to study
22:16:16 <ski> napping : `\v -> 1 : v' is as valid as `\v -> 1 : 1 : v', yet those are different
22:16:17 <_Ray_> the other way would be to just not think about it, and when I see "let x = f x" just remember that "x = f x", without thinking about how that's even possible
22:16:28 <kmc> that sucks
22:16:51 <napping> ski: how did you even get the second? not by abstracting x in 1:x
22:16:52 <kmc> _Ray_, did you see
22:16:52 <kmc> http://hackage.haskell.org/package/vacuum
22:17:09 <_Ray_> nope, *reads*
22:17:13 <kmc> the webpage is down :/
22:17:16 <_Ray_> yeah
22:17:19 <kmc> but it can draw graphs of GHC heap objects without evaluating them
22:17:23 <ski> napping : `fix' of the second yield the `x' in the former
22:17:32 <_Ray_> oooh, pretty
22:17:36 <kmc> anyway, yeah, graph reduction is the way to go
22:17:41 <_Ray_> I had also used hat to look at expression reductions
22:17:51 <_Ray_> but it seems to be mortally wounded
22:18:06 <ski> napping : if `fix f = x' then also `fix (f . f) = x'
22:18:10 <kmc> you have a graph composed of data constructors, application, lambdas, and thunks
22:18:25 <kmc> the out-edges of a data constructor are its data fields
22:18:32 <kmc> the out-edges of an application are the function and the argument
22:18:38 <kmc> the out-edges of a lambda or a thunk are its free variables
22:19:01 <napping> ski: cleaarly, x->1:x is the only function on the domain you consider when giving the semantics for let x = 1:x, and x->1:1:x is the only function you consider giving the semantics for let x = 1:1:x
22:19:02 <kmc> the primitive operation is to pick a graph node and "force it to weak head normal form"
22:19:16 <shachaf> ddarius: Right, but I was referring to the claim that it's unintuitive. Which, I suppose, wasn't actually made.
22:19:26 <MHD> Is there on this earth another programming language community with such a high density of mathematical lingo thrown about in everyday conversation?
22:19:27 <kmc> which means you beta-reduce applications and recursively force thunks until you get something that isn't either, i.e. is a data constructor or a lambda
22:19:55 <kmc> MHD, a lot of it is just using the math words for distantly related things
22:20:12 <ski> napping : why ? the fixpoint of `x |-> 1:1:x' yields the same value as the fixpoint of `x |-> 1:x' does
22:20:28 <napping> ski: yeah, so?
22:20:35 <kmc> as for lambda calculus lingo that's just saying that Haskell programmers care what their programs mean and do
22:20:45 <MHD> kmc: good point
22:20:48 <ski> so, given the value `x', you can't uniquely determine an `f' such that `fix f = x'
22:21:08 <napping> ski: I'm talking about what to do given a recursive definition let x = e<x>
22:21:14 <kmc> _Ray_, the important thing -- the thing that makes it "lazy evaluation strategy" and not just "non-strict semantics" -- is that when you force a thunk, you replace it in-place (mutable state! destructive updates! shocking!) with the thing it evaluated to
22:21:23 <kmc> so that forcing it by way of another graph node will not redo the work
22:21:25 <napping> then you very much do have a unique rhs you abstract over x
22:21:26 <kmc> > let x = 2 + 2 in x * x
22:21:27 <_Ray_> the difference in mathematical/CS knowledge of the average haskeller, and the average PHPer, is likely similar to that of the average PHPer and a banana
22:21:29 <lambdabot>   16
22:21:32 <kmc> that should only add once, not twice
22:21:43 <ski> napping : oh, i thought you were talking about when given a semantic value
22:21:51 <russruss> hey, is there a syntax for annotating types in do notation?  The compiler seems like its getting confused
22:21:51 <kmc> you have a (*) thunk node with two pointers to the *same* (+) thunk node
22:22:01 <kmc> russruss, you can annotate any expression
22:22:09 <napping> no, trying to explain the semantics of recursive bindings
22:22:14 <kmc> > do x <- ([1,2,3] :: [Int]); return (x+3)
22:22:15 <lambdabot>   [4,5,6]
22:22:35 <_Ray_> oh, OK, so the graph isn't a tree
22:22:39 <kmc> yes
22:22:46 <kmc> that is like the most important thing about it
22:23:00 <kmc> so now you Get It :)
22:23:14 <ski> @hoogle Get It
22:23:15 <lambdabot> Did you mean: :: RequestMethod /count=20
22:23:15 <lambdabot> Network.Browser getAuthorities :: BrowserAction t [Authority]
22:23:15 <lambdabot> Network.Browser getAuthorityGen :: BrowserAction t (URI -> String -> IO (Maybe (String, String)))
22:23:38 <kmc> _Ray_, part of your observation about PHP has nothing to do with the nature of Haskell.  It's just that people who learn an obscure, mostly useless language for fun tend to know more math / CS than people who are looking to get a mediocre job programming porn sites
22:24:01 <_Ray_> that makes sense
22:24:14 <kmc> the same was true of Python before Python went all mainstream
22:24:17 <kmc> Paul Graham wrote an essay about it
22:25:39 <kmc> of course another component of it does have to do with the languages itself :)
22:25:40 <dolio> I have doubts that it was as true about Python as it is about Haskell.
22:26:39 <ski> hm, "Temperley-Lieb Algebra: From Knot Theory to Logic and Computation via Quantum Mechanics" by Samson Abramsky in 2008 at <http://front.math.ucdavis.edu/0910.2737> sounds fun/interesting
22:26:40 <ddarius> The problem will be solved by Haskell going "all mainstream."
22:26:45 <kmc> yes, you also have to take everything PG says in context
22:26:59 <ddarius> The context being that PG is a blowhard.
22:27:08 <dolio> ddarius: So, do I need copper-core cookware, or is aluminum good enough?
22:27:11 <cmccann> an occasionally interesting blowhard
22:27:16 <shachaf> ddarius: Where will you go when Haskell goes "all mainstream"?
22:27:19 <ddarius> dolio: It will make little difference.
22:27:46 <kmc> more specifically he runs a business which depends on convincing very smart but possible naive people to work for minimum wage and give away a share of what they produce permanently
22:28:01 <ddarius> shachaf: Don't know.  Possibly I'll be mostly out of the programming world then.
22:28:06 <MHD> @remember _Ray_ the difference in mathematical/CS knowledge of the average haskeller, and the average PHPer, is likely similar to that of the average PHPer and a banana
22:28:06 <lambdabot> Nice!
22:28:31 <kmc> so of course he will tell you how special you are as a "hacker", and how you're a failure in life unless you found your own company by the age of 20
22:28:47 <kmc> and telling people they're special for using weird languages is of course part of that
22:29:00 <kmc> even though i think his argument about good weird languages as a "secret weapon" is essentially correct
22:29:06 <Codex_> I think banana knows more about rules of physics than phper.
22:29:13 <ddarius> dolio: If you care about evenly heating, the easiest thing to do (assuming your stove isn't already good) is to buy a rectangular block of aluminum as an intermediate.
22:29:24 <djahandarie> ddarius, you'll be a hardcore theorem prover?
22:29:41 <hpaste> russruss pasted “what's up with the types?” at http://hpaste.org/48939
22:29:50 <russruss> so, the compiler is getting a little confused and I'm not sure why. I'm probably in a bit over my head
22:29:56 <ddarius> djahandarie: I'm not heading in that direction really.
22:30:29 * cmccann figures that if Haskell gets too mainstream, plan B will be Epigram, in the hopes that McBride's eccentricity will keep it permanently somewhat marginal
22:30:36 <russruss> for some reason it can't deduce something that I put right in the context of an instance
22:31:02 <pikhq> cmccann: Could always go more pure.
22:31:12 <pikhq> Lazy K is always an option.
22:31:22 <cmccann> haha
22:31:23 <ddarius> Lazy K is definitely not more pure.
22:31:25 <russruss> and the suggestion is to do something I already did
22:31:59 <pikhq> ddarius: It omits unsafePerformIO.
22:32:02 <cmccann> anyway, no, lazy K is amusing but lacking in features, such as types
22:33:25 <ddarius> pikhq: It doesn't need unsafePerformIO for the same reasons SML doesn't.
22:33:51 <pikhq> ddarius: Are we thinking of the same Lazy K?
22:33:54 <cmccann> ddarius, hm? pretty sure lazy K has no side effects at all
22:34:15 <cmccann> other than the lazy argument/result stuff
22:34:17 <Cale> russruss: There's no way for it to know that the i you put in the type signature is the same i that it needs.
22:34:21 <Jesin> K is very different from lazy K
22:34:24 <Jesin> btw
22:34:40 <MHD> a language can have the property "Turing complete," which means you can theoretically calculate anything. A language can also have the property "Useful" which means it can interface in a variety of ways with it's envoroment.
22:34:50 <MHD> Lazy K is Turing Complete
22:35:03 <MHD> Is it Useful?
22:35:05 * cmccann wonders if ddarius is confusing Lazy K and Unlambda
22:35:05 <pikhq> ddarius: The one I'm thinking of has you write a function "String -> String".
22:35:44 <pikhq> The string that gets passed is infinite, and the string it results in is infinite.
22:36:06 * ski . o O ( "not more pure" is not the same as "less pure" )
22:36:10 <ddarius> cmccann: Apparently.
22:36:11 <Jesin> I think Lazy K has stdin, stdout, and no other interfaces for programs
22:36:31 <pikhq> Jesin: Arguably, stdin and stdout are implementation details.
22:36:32 <russruss> Cale: any hints?  seems like it should be able to figure it out
22:36:34 <Cale> russruss: It's a problem with ambiguity, because the type of incrudableCreate has no occurrence of i in it, and the class IncrudableMachine has no functional dependency saying that i can be determined from m
22:37:19 <cmccann> yeah, Lazy K has lazy input/output streams that are its only means of interaction, otherwise it's a pure, untyped, lazy-evaluated implementation of the SK combinator base
22:37:29 <Jesin> WHY IS IT THIS LATE
22:37:32 <Jesin> time
22:37:38 <Jesin> why are you passing
22:37:42 <Jesin> :(
22:38:09 <cmccann> Unlambda has all combinators that perform I/O directly, as well as other weird stuff
22:38:21 * cmccann isn't sure where that "all" came from
22:38:32 <args0> exit
22:38:34 * ddarius wonders is << /Foo null /Foo (bar) >> is a legal dictionary in PDF.
22:38:38 <russruss> Cale:  I see... so should I add a dummy i argument?
22:38:51 <kmc> Jesin, taking away the moments that make up the dull day ♫
22:38:56 <Cale> russruss: That's one way
22:39:27 <Cale> russruss: You could also just add a fundep
22:39:39 <Cale> class IncrudableMachine i m | m -> i where ...
22:39:53 <Cale> But that means there can only be one type i for any given type m
22:40:01 <russruss> yeah, I mean I was trying to avoid that
22:40:04 <Cale> *at most one
22:41:54 * cmccann proposes a GHC extension to allow the syntax "class C a <- b | a b where ..." called "DysfunctionalCodependencies"
22:43:24 <cmccann> by default only ambiguous and nonterminating instances would be allowed, you'd need extra extensions to write anything else
22:43:38 <hpaste> russruss annotated “what's up with the types?” with “what's up with the types? (annotation)” at http://hpaste.org/48939#a48940
22:44:07 <russruss> yeah, still not working... I'm going to try to add fundeps even though it's not quite what I'd ideally want.
22:48:04 <Cale> russruss: Are you sure that typeclasses are really the best fit here? Have you considered just making records of the functions involved?
22:49:02 <Cale> Now the problem is that you removed the other fundep though
22:49:16 <russruss> well, I went crazy with the fundeps
22:49:19 <Cale> Could not deduce (IncrudableView m1 i2 cRet rRet uRet dRet lRet) from the context (IncrudableView m1 i2 c2 r2 u2 d2 l2
22:49:20 <hpaste> russruss annotated “what's up with the types?” with “what's up with the types? (annotation)” at http://hpaste.org/48939#a48941
22:49:24 <russruss> same error
22:50:15 <hpaste> russruss annotated “what's up with the types?” with “what's up with the types? (annotation)” at http://hpaste.org/48939#a48942
22:50:24 <russruss> sorry previous one was wrong
22:51:21 <russruss> yeah, maybe classes are not the way to go here, but it feels like giving up not to do it :-P
22:52:01 <Cale> Also your identifier names make me sad :(
22:52:15 <Cale> (they're probably too long)
22:52:25 <russruss> with records then without some serious ghc extensions, could you derive an IncrudableMachine from an instance of IncrudableModel and IncrudableView
22:52:56 <Cale> It would be a function
22:53:06 <Cale> should be possible, if this is possible
22:53:35 <Cale> after all, typeclasses are compiled into record types and instances into values and functions
22:54:10 <russruss> did not know that
22:54:35 <russruss> what about my identifiers is bad?  I'm pretty new at all this so I could use some advice :-P
22:54:38 <Jesin> sleeptiem plz
22:58:56 <earthy> sleeptime? I just got up!
23:00:06 <earthy> russruss: cRet rRet uRet dRet and lRet are no better than c r u d and l
23:00:13 <earthy> and rather more crufty
23:01:12 <earthy> plus, in the instance for IncrudableMachine you already restrict yourself to the single-letter versions
23:01:54 <earthy> maybe the types should be   created retrieved updated deleted listed
23:04:47 <Cale> russruss: are you still here?
23:04:51 <russruss> yes
23:05:06 <Cale> russruss: I would start by not putting the module name in every one of them ;)
23:05:22 <hpaste> Cale pasted “Maybe like this” at http://hpaste.org/48943
23:05:33 <Cale> That compiles, btw.
23:07:58 <Cale> I don't know about everyone, but for me at least, the shorter identifier names allow the expressions to fit inside my vision all at once and make it easier to understand what it's doing.
23:08:49 <yitz> Cale: it's subtle. sometimes short is better, sometimes expressive.
23:09:19 <russruss> Cale: nice.  Yeah, that's really not particularly inconvenient
23:09:37 <russruss> I guess my hope was to avoid the mkMachine call
23:09:50 <yitz> Cale: the prevailing wisdom in the software engineering world is that it's better to err on the side of expressiveness.
23:09:51 <russruss> and use the type system to do it
23:10:07 <yitz> Cale: but i don't completely agree with that anymore.
23:10:07 <edwardk> given that incrudable paste you could get the same clarity 'benefits' from using a qualified import, but you can't get the short names back without pain
23:10:08 <russruss> seems like that plan was more difficult than I imagined though haha
23:10:35 <napping> yitz: if there's a lot of information you need to convey in text, your types are not very informative
23:10:51 <edwardk> import qualified Incrudable; then you can use Incrudable.state_display if you must ;)
23:10:54 <yitz> napping: often true, yes.
23:11:09 <yitz> napping: but not always
23:11:32 <kmc> namespaces are one honking great idea -- let's do more of those
23:12:05 <edwardk> kmc: =P
23:12:18 <kmc> C was a lot worse before the fake namespaces
23:12:33 <kmc> do you have a function named "erase"? you can't link with libcurses now
23:18:21 <hpaste> russruss pasted “Better Looking?” at http://hpaste.org/48944
23:18:45 <russruss> still having the same type inference problems - maybe it's best to just give up and go with records and explicitly make the machines
23:19:47 <edwardk> couple of thoughts, do you ever plan on using HasState on something that isn't a monad?
23:20:29 <edwardk> Model won't typecheck because mRetrieve only references k s and r, and k s and r can't infer all the other members of the class
23:21:11 <edwardk> every method you define in a typeclass has to be able to infer _all_ of the arguments for the type class instance.
23:21:30 <kmc> a class with 8 parameters o_O
23:21:36 <edwardk> you could break up Model, etc into a lot of smaller pieces.
23:21:43 <kmc> i am really suspicious
23:21:48 <edwardk> yeah
23:22:07 <russruss> aha
23:22:23 <kmc> did you write the explicit version?
23:22:33 <russruss> so you want me to put monad in the context of HasState?  does that get me anything?
23:23:01 <edwardk> russruss: sDisplay goes down to sDisplay :: HasState m s => (s -> m ()) -> m ()
23:23:20 <edwardk> but you have huge problems below comparatively
23:23:27 <edwardk> your classes will never typecheck as they are
23:23:33 <kmc> basically this makes me think of Java
23:23:38 <kmc> where every new behaviour has to have a new type
23:23:45 <kmc> that's not how Haskell works
23:23:58 <kmc> you have a single type, which contains functions, IO actions, etc
23:24:02 <kmc> and new behaviours are just values of that type
23:24:26 <shachaf> That's how kmcskell works, at least.
23:24:34 <kmc> the more I use Haskell the less I like these sorts of typeclass-heavy designs
23:24:40 <russruss> fair enough
23:25:03 <edwardk> anyways, if you are wedded to this approach, you can make explicit data types for all these things
23:25:11 <kjslag> is it possible to put a 'type X = Int' inside of a function?
23:25:17 <kmc> no kjslag
23:25:23 <russruss> right, Cale did that for me
23:25:30 <edwardk> data Model s k i c r u d l = Model { mCreate :: i -> s -> (s, c) , … }
23:25:42 <russruss> but it has the downside of not "auto creating" the machine
23:25:42 <kjslag> :(
23:25:54 <russruss> which is kind of the only thing I want from these typeclass shenanigans
23:26:00 <kmc> what does "auto create" mean?
23:26:11 <edwardk> i'll give you a hint, you aren't going to want to autocreate a machine like that
23:26:19 <russruss> haha okay
23:26:20 <edwardk> that instance is basically useless
23:26:22 <kmc> can't you have a value "myMachine :: Model Foo Bar ..."
23:26:30 <kmc> which just sits around at top level waiting to be
23:26:32 <russruss> oh
23:26:34 <kmc> modified with record updates
23:26:56 <kmc> remember, declarative language.  think about what things *are* not what they *do* or how they're created
23:26:57 <ski> kjslag : unfortunately
23:27:04 <edwardk> what it does as specified is say that there is only ever one type of machine, and it requires a bunch of weird instances to be in scope
23:27:12 <edwardk> if you are going to encode that why make a class for Machine at all?
23:27:25 <edwardk> why not just make the combinators take the constraints themselves?
23:27:32 <edwardk> using the example you have without fixing it
23:28:16 <edwardk> create :: (Monad m, View m i c r u d l, …) => m () — now you can see how would create guess the choices for all those arguments that aren't m in the context?
23:28:48 <edwardk> it can't so create is pretty far from well typed.
23:28:51 <ski> kjslag : did you just want to abbreviate some type locally, or did you really want existentials ?
23:29:06 <kjslag> ski: I want to abbreviate a type locally
23:29:27 <russruss> edwardk: sure, that makes sense
23:29:28 <kjslag> ski: pairs of types actually
23:30:31 <ski> kjslag : .. i would be happy if we'd get some extension which allowed local `type',`data',`newtype',`class' and `instance' declarations -- probably with heavy restrictions on how to use classes and instances initially
23:30:37 <edwardk> now, taking the record-passing approach you can get a very unhaskelly thing to start to compie ;)
23:30:40 <edwardk> er compile
23:31:07 <russruss> so what's a better way of doing this then?  you mentioned "make the combinators take the constraints themselves"... I'm not sure what that means
23:31:20 <kjslag> ski: i would be really happy with at least just type :)
23:31:24 <edwardk> create :: MonadState m s => View m i c r u d l -> Model s k i c r u d l -> m ()
23:31:41 * ski . o O ( "gimme some commie pie, ma'am" )
23:31:51 <edwardk> create view model = do nI <- vGet view; ...
23:32:43 <russruss> well, if you do that there's no point in having a view class or a model class
23:32:45 <edwardk> note the only typeclass involved is MonadState (which is the combination of HasState m s, and Monad m)
23:32:53 <edwardk> you are correct ;)
23:33:02 <edwardk> i would argue that as they exist they aren't well defined classes
23:33:15 <edwardk> and i don't think they are salvageable as such
23:33:22 <russruss> haha fair enough
23:33:52 <edwardk> the vast majority of your methods on them don't mention enough of the types to make a valid typeclass
23:34:20 <edwardk> for instance on View, the only method that could be called correctly would be vGet because it references i and i determines all the other parameters
23:34:37 <edwardk> on Model, only mCreate &  mUpdate
23:34:44 <russruss> haha yeah I mean the fundeps don't mean anything
23:35:10 <edwardk> well they DO mean something, that is the problem =) without them you are even farther from implementable =P
23:35:11 <russruss> I think the whole idea was pretty ill-informed at this point
23:35:53 <edwardk> what you have there looks a lot like a lot of ML code, where you build two modules that have some types in common and wire them up in a third
23:36:08 <edwardk> its a perfectly reasonable programming style, its just not very haskelly
23:36:20 <edwardk> and typeclasses aren't very good at that sort of thing
23:36:23 <kmc> the plague of type classes is probably the most common non-trivial design problem we see
23:36:29 <kmc> i wonder about fundamental causes and solutions
23:36:40 <russruss> well, okay, I mean I do wonder what's a better way to do this then
23:37:02 <russruss> the idea is like I want to connect up these things here
23:37:09 <edwardk> well, you need to make some type to represent the things you want to manipulate.
23:37:12 <russruss> and the one who uses them doesn't know they exist
23:37:29 <kmc> connecting things and then hiding the insides makes me think "closures"
23:37:44 <edwardk> you can make nice combinators to put it all together if need be
23:38:21 <russruss> yeah, I mean I guess I haven't seen enough good haskell code to really know what that would look like
23:38:46 <russruss> my sense is like you're talking about having the equivalent of mCreate as a free function and the equivalent of vCreate as a free function
23:39:01 <russruss> and then when you use them you do like mCreate @#@#@ vCreate or something
23:39:14 <russruss> but that's not really what I want because ideally the guy who uses them just knows about m and i
23:39:22 <russruss> and who brought mCreate into it
23:40:23 <edwardk> what is i in this context?
23:40:45 <edwardk> and what am i creating?
23:40:45 <russruss> well, I suppose for the "create" function in that example i isn't involved either :-P
23:40:58 <edwardk> =)
23:41:20 <russruss> I guess mCreate is supposed to add i to s, which is the state object
23:41:23 <russruss> and then return c
23:41:41 <russruss> vCreate is supposed to take c and do something with it to modify m
23:41:48 <edwardk> have you seen AcidState?
23:41:52 <russruss> nope
23:41:55 <edwardk> http://hackage.haskell.org/packages/archive/acid-state/0.4.2/doc/html/Data-Acid.html
23:42:03 <edwardk> they do something fairly similar to what you want
23:42:08 <edwardk> maybe you can steal some design ideas
23:42:14 <russruss> sweeeet
23:42:52 <russruss> well, I should really be heading to bed
23:42:56 <russruss> thanks so much for all your help
23:42:57 <edwardk> its basically the old MACID machinery from HAppS/Happstack split out and made into something in its own right if i understand right
23:43:59 <russruss> hrm
23:44:16 <russruss> yeah, I'm quite a beginner in all this so I appreciate your patience :-)
23:44:51 <ddarius> Ergh, classes with no methods...
23:45:34 <edwardk> ddarius: i believe lemmih wanted folks to make instances with makeAcidic
23:45:52 <edwardk> not my favorite design choice
