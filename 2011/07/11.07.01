00:35:23 <flinstone> Hello haskellers
00:35:34 <flinstone> Where you looking for jobs?
00:36:07 <medfly> are you looking for a job?
00:36:12 <medfly> (just checking)
00:36:13 <flinstone> In startups? or solid companies? job boards?
00:36:28 <flinstone> medfly, yes
00:36:58 <flinstone> medfly, i want find places where it is better
00:37:17 <shachaf> It's a good thing #haskell is a homogeneous group -- practically one person, really -- so that there's one obvious answer to your question. :-)
00:38:10 <flinstone> :-)
00:38:17 <flinstone> flinstone, and which answer?
00:39:22 * arcatan looks for jobs in Finland
00:39:47 <flinstone> shachaf, Does strtupers(in Europe,USA) use job boards(dice, monster) or they prefer another ways to find workers(facebook, linkedin, blogs)&
00:39:49 <flinstone> ?
00:47:25 <gienah> flinstone: a place to look (but does not seem to be anything in europe at the moment) is http://cufp.org/jobs
00:48:16 <ivanm> do people actually use haskellers for jobs?
00:51:00 <medfly> yes, some people here have jobs that involve Haskell
00:52:13 <flinstone> gienah, thank y
00:55:21 <Saizan> medfly: i think he meant haskellers.com
00:57:16 <Phyx-> uploading a package to hackage is just doing cabal upload?
00:58:39 <flinstone> Saizan, no, not only for haskell and for anothe funcional languages too
00:59:10 <ivanm> Phyx-: yup
00:59:24 <ivanm> Phyx-: well, you need to do a cabal sdist first to create the tarball
00:59:31 <Phyx-> ah
00:59:41 <ivanm> and that typically wants a cabal configure
01:00:00 <Phyx-> I tested the tarball on another pc too
01:00:07 <ivanm> so it's cabal configure && cabal sdist && cabal upload dist/foo-1.2.3.tar.gz
01:00:07 <Phyx-> hopefully I didn't forget anything
01:00:10 <ivanm> something like that
01:00:31 <ivanm> anyone here familiar with the output of +RTS -sstderr ?
01:00:34 <Phyx-> hrm
01:00:37 <Phyx-> Hackage username..
01:00:40 <Phyx-> where do i register
01:01:02 <ivanm> http://hackage.haskell.org/packages/accounts.html
01:01:32 <Phyx-> lol, so I have a wiki account, a trac account
01:01:43 <Phyx-> and now a hackage account.. these things need to be consolidated
01:02:50 <Phyx-> or do one of those overlap?
01:02:54 <ivanm> do you have a c.h.o account? :p
01:02:58 <ivanm> nope, all separate
01:03:26 <Phyx-> lol, so now I have to wait before i can upload, heheeh
01:05:54 <Phyx-> there, mail sent
01:21:14 <ivanm> why is it that hp2ps doesn't create landscape postscript files? :/
01:42:11 <ArnoVanLumig> hi all, I can't seem to find any info on how to create an ObjectId for a MongoDB query
01:47:22 <dafis> ivanm: what's the problem interpreting +RTS -s output?
01:48:03 <ivanm> dafis: eh, ended up finding the user guide section that covered it
01:48:16 <dafis> ah, fine
01:48:19 <ivanm> I didn't realise that -sstderr was -s and then stderr as the "file name"
01:48:23 <ivanm> (I got the command from RWH)
01:49:11 <dafis> ivanm: yup, filename defaults to stderr, so you can leave that off
01:49:48 <ivanm> I mainly wanted to check that "maximum residency" was indeed the maximum amount of memory used at any one time
01:52:31 <frerich> I'm sorry for being slightly offtopic; I'm writing a little game in Haskell which involves random numbers. While tinkering with the code, I wondered: if "r" is a random number, is "r+1" equally random? As in, if I generate a few random numbers, is the sequence of them as random as the same sequence with 1 added to each element?
01:53:27 <frerich> I'm just asking since Haskellers tend to be quite good at maths :-)
01:53:32 <ivanm> frerich: I think so
01:53:37 <ivanm> you're just shifting the distribution
01:54:11 <ivanm> e.g. if you have a PRNG for [0,1), how do you get one for [1,3) ?  rng * 2 + 1
01:55:40 <ArnoVanLumig> Anyone here knows how to query on ObjectId in Database.MongoDB?
01:56:45 * Phyx- presses refresh on his email
01:58:56 <rostayob> ArnoVanLumig: wouldn't it be something like select [ "id" =: whatever ] coll?
01:59:05 <rostayob> or maybe "_id", or whatever it is
01:59:10 <zygoloid> frerich: what do you mean by 'equally random' or 'as random as'?
01:59:39 <ArnoVanLumig> rostayob: that doesn't work, because the _id is not a string but an objectid
01:59:47 <ArnoVanLumig> rostayob: querying like that will always give an empty result
02:00:05 <ArnoVanLumig> http://hackage.haskell.org/packages/archive/bson/0.1.3/doc/html/Data-Bson.html#t:Val
02:00:13 <rostayob> ArnoVanLumig: right. and I guess it doesn't have show and read instances
02:00:27 <ArnoVanLumig> it does have a show instance, but no read instance
02:00:30 <zygoloid> if "equally random" means "equally likely to have been produced by the same stochastic process", then no, in general.
02:00:41 <ArnoVanLumig> that URL I just pasted does list an objectid type, but I'm not sure how to create it from a string
02:01:03 <rostayob> you can define your own function i guess
02:01:04 <rostayob> wait
02:01:38 <rostayob> ArnoVanLumig: https://github.com/ozataman/snap-extension-mongodb/blob/master/src/Snap/Extension/DB/MongoDB/Utils.hs this is what you're looking for
02:01:39 <frerich> zygoloid: I'm not familiar with this stuff but I suspect there are different degrees of randomness (as in, the reverse of the likeliness to predict the next number). With a sequence of six random numbers, I wonder whether it's "predictability" is as good (or bad) as the same sequence with each number being increased by one.
02:02:04 <rostayob> but anyway, you can define your own functions to and from oid, since the constructor is exported
02:02:17 <ArnoVanLumig> rostayob: thanks, let me try that
02:02:39 <rostayob> I wonder why there is no Read instance
02:02:46 <nus> wait while edwardk comes with a package for constructive probability, then you could perhaps define 'equally random' in Haskell (-;
02:02:50 <sipa> frerich: i assume by random you mean 1) uniformity (each result equally likely) and 2) independency (information about former numbers does not help you guess the next one)
02:03:10 <sipa> in that case, adding one to the result will not change anything (except shift the domain)
02:03:14 <frerich> sipa: That's my intuitive definition, yes
02:03:33 <frerich> sipa: Ok. What if I just added one to *some* of the elements? Does that change the 'randomness' of the whole sequence?
02:03:45 <develhevel> hi, is there something like: return (\(_,_,a) -> a)
02:03:57 <sipa> something like map (\x -> if x<5 then x+1 else x) ?
02:03:59 <linduxed> hey guys, i've got a hard time compiling my implementation of grahamScan, could someone tell me why ghci complains about line 29 and forward?
02:04:00 <linduxed>  
02:04:03 <linduxed>  
02:04:04 <rostayob> @hoogle (a, b, c) -> c
02:04:05 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
02:04:05 <linduxed> oops
02:04:05 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
02:04:06 <linduxed> http://paste.pocoo.org/show/425711/
02:04:06 <frerich> sipa: Exactly
02:04:16 <merijn> @pl return (\(_, _, a) -> a)
02:04:16 <lambdabot> (line 1, column 15):
02:04:16 <lambdabot> unexpected ","
02:04:16 <lambdabot> expecting operator or ")"
02:04:16 <lambdabot> ambiguous use of a non associative operator
02:04:20 <sipa> frerich: in that case you double the probability of 5
02:04:26 <sipa> breaking the uniformity
02:04:31 <rostayob> @pl \(_,_,c) -> c
02:04:31 <lambdabot> (line 1, column 6):
02:04:31 <lambdabot> unexpected ","
02:04:31 <lambdabot> expecting operator or ")"
02:04:31 <lambdabot> ambiguous use of a non associative operator
02:04:47 <merijn> odd...
02:04:48 <develhevel> :(
02:05:14 <rostayob> @pl let (_, _, x) = y in x
02:05:14 <lambdabot> (line 1, column 5):
02:05:14 <lambdabot> unexpected "("
02:05:14 <lambdabot> expecting "()", natural, identifier or "in"
02:05:27 <rostayob> no wait :P
02:05:32 <merijn> @pl return (\(a, b, c) -> c)
02:05:32 <lambdabot> (line 1, column 15):
02:05:33 <lambdabot> unexpected ","
02:05:33 <lambdabot> expecting letter or digit, operator or ")"
02:05:33 <lambdabot> ambiguous use of a non associative operator
02:07:19 <merijn> Apparently lamdabot doesn't want tuples of 3 values?
02:07:25 <rostayob> boh
02:07:25 <merijn> @pl return (\(a, b) -> b)
02:07:25 <lambdabot> return snd
02:07:38 <rostayob> yeah
02:07:43 <merijn> :\
02:08:13 <rostayob> @pl \x -> let (_, _, y) = x in y
02:08:13 <lambdabot> (line 1, column 11):
02:08:13 <lambdabot> unexpected "("
02:08:13 <lambdabot> expecting "()", natural, identifier or "in"
02:08:39 <Axman6>  @pl only knows about 2-tuples
02:08:59 <rostayob> ah, ok
02:09:37 <rostayob> develhevel: anyway, the answer is probably no.
02:09:49 <rostayob> you have fst and snd, but no third.
02:10:15 <rostayob> also because fst and snd wouldn't work on 2-tuples anyway...
02:11:07 <merijn> rostayob: How so?
02:11:13 <rostayob> :t fst
02:11:14 <lambdabot> forall a b. (a, b) -> a
02:11:42 <merijn> Did you mean 3-tuples by any chance? :)
02:11:42 <rostayob> > fst (1,2,3)
02:11:43 <lambdabot>   Couldn't match expected type `(a, b)'
02:11:43 <lambdabot>         against inferred type `(t, t1...
02:11:51 <rostayob> oh right
02:11:54 <rostayob> yes i did :P
02:11:56 <rostayob> sorry
02:11:59 * merijn was confused for a sec there :D
02:12:14 <ivanm> there's a TH solution that scales to n-tuples...
02:12:38 <sanjoyd> TH is fun.
02:12:44 <rostayob> th melts your brain
02:13:20 <sanjoyd> I used to be like: "Haskell is fun 'n all, but if you need a macro system ..."
02:13:22 <sanjoyd> then I found TH.
02:13:31 <rostayob> well TH is not that pretty imho...
02:13:52 <merijn> I was reading up on dependent type theory, quite sure my brain can't be melted further...
02:14:06 <sanjoyd> Is that something like functional dependencies?
02:14:22 <rostayob> merijn: TH is not hard to understand, it's just quite messy to do
02:14:36 <rostayob> while dependent types are hard to understand I guess :P
02:14:44 <merijn> sanjoyd: I have no clue what functional dependencies are :p Dependent types means types depending on terms, for example the type of a list depending on its length
02:14:48 <zygoloid> frerich: if you map some function over a random sequence, the resulting distribution will be transformed by the same mapping. if your function is injective, the result is exactly as unpredictable as the original.
02:15:05 <Phyx-> out of curiousity, why isn't hackagedb registration an automated thing? It seems to me that this manual approach doesn't scale..
02:15:08 <merijn> On semi-related note, is category theory in anyway understandable/useful (for arbitrary values of useful) if I don't know algebraic topology
02:15:20 <nus>  @type let thrd = \(_,_,x) -> x in return thrd
02:15:27 <nus> @type let thrd = \(_,_,x) -> x in return thrd
02:15:27 <lambdabot> forall t t1 t2 (m :: * -> *). (Monad m) => m ((t, t1, t2) -> t2)
02:15:46 <frerich> zygoloid: Ah, I see - and you mean to imply that if the function which is mapped over the list is surjective, the result is not as unpredictable?
02:15:51 <zygoloid> frerich: if your function is not injective, then values which can be produced in multiple ways will be more likely.
02:15:52 <rostayob> nus: is you have a thrd :: (a,b,c) -> c, then it's just return thrd
02:16:23 <zygoloid> (note, surjective is not the complement of injective)
02:16:51 <zygoloid> frerich: as a degenerate example, if your function is (\x -> 0) then your sequence is very predictable :)
02:16:56 <frerich> zygoloid: I know, but in my case the function to be mapped is basically \x -> x<5 then x+1 else x
02:16:58 <nus> there's only one let between you and thrd (-;
02:17:43 <zygoloid> frerich: if your initial distribution is uniform over some range of integers, then your resultant distribution will not be: 5 will come up more often
02:19:02 <linduxed> could someone tell me why ghci complains about line 29 and forward?  http://paste.pocoo.org/show/425711/
02:21:32 <rostayob> nus: yeah but I can see why you don't want to include that function in the prelude or in some library
02:21:34 <quicksilver> linduxed: you can't write guards like that.
02:21:38 <zygoloid> linduxed: indentation issues and guard issues
02:21:43 <quicksilver> linduxed: guards can only be on declaratioans
02:21:56 <linduxed> oh ok...
02:22:01 <zygoloid> linduxed: line 31 needs to be more indented than line 30
02:22:07 <linduxed> are the len - in placements ok?
02:22:09 <quicksilver> linduxed: it's also pointless to nest "lets" like that.
02:22:31 <linduxed> quicksilver: ok, how would you place them to make that code look tidy?
02:22:38 <quicksilver> the let on line 25 is not ok. It's part of the body of threePointDirection so it needs to be at least one space in
02:22:47 <quicksilver> linduxed: editing now
02:23:05 <zygoloid> linduxed: if you want to use locally-defined variables in a guard for a function, you should use 'where' not 'let'
02:23:18 * frerich wonders how many Graham Scan implementations the people in here have seen by now due to it being an exercise in RWH
02:23:54 <quicksilver> linduxed: like this, possibly http://paste.pocoo.org/show/425717/
02:23:58 <linduxed> zygoloid: i thought about using where... but when writing that it felt like it made more sense with let
02:24:09 <linduxed> zygoloid: oh and i didn't know if you can make nested where
02:24:32 <zygoloid> linduxed: you don't need to nest anything here.
02:24:34 <quicksilver> you can in a sense, in that you can put a where clause in a defintion in a where clause, but you don't need to very often.
02:25:09 <osfameron> quicksilver: yo dawg!
02:25:13 <linduxed> quicksilver: oh so i don't need a nested let to use v1 and v2 in detDircetion?
02:25:18 <quicksilver> no, you don't.
02:25:25 <quicksilver> all definitions are recursive
02:25:29 <linduxed> oh that takes out one let right away
02:25:43 <quicksilver> so let-definitions at the same level can all see each other
02:25:47 <quicksilver> well, see my paste.
02:26:04 <linduxed> yeah i'm looking at it
02:26:08 <linduxed> hmmm
02:26:32 <linduxed> that result thing was basically what i intended to do...
02:26:45 <linduxed> ok i think i understand now
02:26:47 <linduxed> thx a lot
02:26:53 <nus> @hackage nthable
02:26:53 <lambdabot> http://hackage.haskell.org/package/nthable
02:26:58 <nus> rostayob, ^^^
02:29:09 <linduxed> quicksilver: one thing though
02:29:27 <linduxed> quicksilver: i use 4space tabs, where you seem to be using 2space
02:29:41 <linduxed> quicksilver: that "in" in the end
02:29:42 <quicksilver> entirely up to you
02:29:49 <quicksilver> as long as you actually mean spaces :)
02:29:50 <linduxed> it's indented by 2 spaces
02:30:00 <linduxed> should it be?
02:30:12 <quicksilver> that was my intention but you do as you wish
02:30:18 <linduxed> or can it be placed at the heigth of v1 ?
02:30:19 <quicksilver> to be honest I just let the emacs mode decide normally
02:30:29 <quicksilver> it cannot be at the same place as v1, no
02:30:34 <linduxed> oh ok
02:30:39 <quicksilver> that would be starting a new defintion
02:30:59 <linduxed> can it be on the height of the signature?
02:31:46 <zygoloid> linduxed: i've rewritten it using where (plus a few other tidyups) so you can compare: http://paste.pocoo.org/show/425724/
02:32:39 <linduxed> zygoloid: oh that looks so much nicer
02:32:59 <linduxed> zygoloid: yeah i really prefer that where usage to let
02:33:41 * hackagebot Hs2lib 0.4.8 - A Library and Preprocessor that makes it easier to create shared libs from Haskell programs.  http://hackage.haskell.org/package/Hs2lib-0.4.8 (TamarChristina)
02:42:39 <sanjoyd> Example of a non-associative operation for which foldl == foldr ?
02:44:07 <rostayob> > foldr (-) 0 [1,2,3]
02:44:07 <lambdabot>   2
02:44:10 <rostayob> > foldl (-) 0 [1,2,3]
02:44:11 <lambdabot>   -6
02:44:17 <rostayob> ah
02:44:19 <rostayob> ==
02:44:54 <sanjoyd> The elements of the sequence will have to close over the operation.
02:44:59 <sanjoyd> So == does not count.
02:45:13 <hpc> the operation would have to be associative in order for foldl == foldr
02:45:31 <hpc> consider the case where you are folding three things
02:45:37 <sanjoyd> Yes, got it.
02:46:07 <sanjoyd> But non-associative does not necessarily imply a.(b.c) /= (a.b).c
02:46:15 <rostayob> sanjoyd: no, my == was to indicate that I had misunderstood the question :P
02:47:17 <hpc> sanjoyd: it does though
02:47:24 <hpc> specifically, it implies not (∀x,y,z. (x * y) * z == x * (y * z))
02:47:57 <sanjoyd> Right, so we will always have at least one such sequence.
02:48:39 <sanjoyd> I wonder what this means then: find a non-associative operation for which ⊕/ is well defined. Conclude that associativity of ⊕ is a sufficient, but not necessary condition for ⊕/ to be a well defined function on sequences.
02:49:01 <sanjoyd> I'm probably misunderstanding "well-defined".
02:49:37 <hpc> what is that ⊕/ supposed to be? i see a box as the first character
02:50:21 <ben> It looks like a circle with a plus in it
02:50:24 <sanjoyd> Fold w.r.t. ⊕.
02:50:27 <hpc> ah, cool
02:50:37 <sanjoyd> But this is a paper on CT. I guess I'll ask in ##categorytheory
02:51:21 <sroberts> hi all, I am hoping for some help with a package shadowing problem
02:52:38 <sroberts> the template-haskell pacakge is being shadowed, causing ghc to be unusable, causing QuickCheck to become unusable
02:52:51 <sroberts> I can post logs if anyone is interested
02:53:10 <sroberts> what steps can I take to remove the offending template-haskell pacakge?
02:54:18 <Saizan> ghc-pkg unregister
02:56:06 <linduxed> i want to apply my threePointDirection to the first three Point in a [Point]
02:56:24 <linduxed> what's the best way to do that?
02:56:34 <linduxed> some head(head(head magic?
02:56:45 <sanjoyd> Pattern matching?
02:57:05 <sanjoyd> :t (!!)
02:57:05 <lambdabot> forall a. [a] -> Int -> a
02:57:15 <sanjoyd> Or this ^
02:57:37 <sroberts> thanks Saizan, that worked :)
02:58:09 <rostayob> linduxed: map threePointDirection . take 3?
02:58:27 <linduxed> rostayob: omg that is beautiful
02:58:44 <linduxed> rostayob: i haven't gotten to higher order functions or what they're called
02:59:09 <linduxed> hmmm
02:59:16 <rostayob> linduxed: yeah hof are cool!
02:59:21 * Saizan suspects threePointDirection takes 3 points as arguments
02:59:28 <rostayob> Saizan: ah.
03:00:06 <rostayob> hof are still cool
03:00:12 <linduxed> this is the code: http://paste.pocoo.org/show/425740/
03:00:34 <linduxed> i'm trying to create the pointsToDirections
03:05:07 <sanjoyd> linduxed: pointsToDirections x:(y:(z:_)) = whatever x y z ?
03:05:15 <sanjoyd> Of course, this is not safe.
03:05:51 <zygoloid> pointsToDirections (x:y:z:_) = ...
03:05:59 <zygoloid> it's safe so long as you cover the other cases too
03:06:04 <sanjoyd> That works?
03:06:16 * sanjoyd has been writing x:(y:(z...)) for weeks.
03:06:18 <sanjoyd> :/
03:06:38 <sanjoyd> > (\(x:y:z_)->(x + y + z)) [1, 2, 3, 4]
03:06:38 <lambdabot>   1 + 2 + z
03:06:41 <zygoloid> sanjoyd: "f x:(y:(z:_))" doesn't work: you need parens around the "x:(...)" too
03:06:53 <sanjoyd> zygoloid: yes, my bad.
03:06:57 <sanjoyd> > (\(x:y:z:_)->(x + y + z)) [1, 2, 3, 4]
03:06:57 <lambdabot>   6
03:07:02 <zygoloid> but yeah, associativity is taken into account when parsing patterns
03:07:07 <merijn> sanjoyd: Rejoice in proper association of operators :p
03:07:15 * sanjoyd rejoices.
03:07:17 * sanjoyd dances :D/-<
03:07:17 * sanjoyd dances :D|-<
03:07:18 * sanjoyd dances :D\-<
03:07:18 <linduxed> well now that i know that i can do x:y:z then...
03:07:18 * sanjoyd dances :D|-<
03:07:20 <linduxed> wait
03:08:05 <linduxed> can i do "foobar (x:y:z) = x y z" or something like that if z is not a list?
03:08:06 <zygoloid> sanjoyd: generally, any expression involving only variables and constructor application (with no function application) also works as a pattern for matching that expression
03:08:12 <linduxed> as in the last value of a list?
03:08:52 <hpc> foo (x:y:z) = x y z is going to give you a whole lot of type errors
03:09:12 <merijn> hpc: Depends on the type of x, y and z :p
03:09:16 <ben> try x:y:z:[]
03:09:25 <zygoloid> linduxed: no. remember that (x:y:z) is (x:(y:z)), which means "take list z, add y to the start, and add x to the start of that"
03:09:27 <ben> or. [x,y,z]
03:09:32 <hpc> merijn: no, it will be at least an infinite type
03:10:13 <merijn> hpc: Of course, but take for example "let foo (x:y:z) = x y z in foo [fix,fix,fix]" :p
03:10:25 <merijn> That should type check, no?
03:10:39 <hpc> :t let foo (x:y:z) = x y z in foo [fix,fix,fix]
03:10:40 <lambdabot>     Occurs check: cannot construct the infinite type:
03:10:40 <lambdabot>       t = t -> [t] -> t1
03:10:40 <lambdabot>     Probable cause: `x' is applied to too many arguments
03:10:47 <hpc> :t let foo (x:y:z) = x y z in foo
03:10:48 <lambdabot>     Occurs check: cannot construct the infinite type:
03:10:48 <lambdabot>       t = t -> [t] -> t1
03:10:48 <lambdabot>     Probable cause: `x' is applied to too many arguments
03:11:05 <linduxed> zygoloid: yeah that's what i thought
03:11:09 <zygoloid> > let foo :: [forall a. a] -> forall a. a; foo (x:y:z) = x y z in foo []
03:11:10 <lambdabot>   *Exception: <interactive>:3:41-59: Non-exhaustive patterns in function foo
03:11:17 <zygoloid> ^^ hpc no type error there ;-)
03:11:22 <hpc> haha
03:11:50 <zygoloid> good ol' ghc extensions :)
03:14:37 <minsa> I am looking at fold functions. In "Learn You a Haskell", the example is   " sum' = foldl (\acc x -> acc + x) 0 xs ".
03:15:03 <minsa> my question is about the lambda function. Can I write it as  (\x acc -> acc + x) ?
03:15:14 <_mpu> yes
03:15:16 <minsa> would it make any difference ?
03:15:19 <sanjoyd> minsa: in this case, yes.
03:15:31 <sanjoyd> But only because addition is commutative etc.
03:15:33 <_mpu> because + is commutative
03:16:00 <minsa> can you give me an example where acc has to be on the left if I use foldl ?
03:16:09 <linduxed> so i added the line "pointsToDirections [a,b,c] = threePointDirection a b c", but what's the best way to check for (and then report an error) if the list is shorter than 3 elements?
03:16:20 <_mpu> try with : and []
03:16:44 <sanjoyd> find x xs = foldl (\found elem->if elem == x then True else found) False xs
03:16:50 <sanjoyd> > :t find x xs = foldl (\found elem->if elem == x then True else found) False xs
03:16:51 <lambdabot>   <no location info>: parse error on input `:'
03:16:52 <quicksilver> pointsToDirections a:b:c:d:_ = error "more than 3"
03:16:55 <sanjoyd> :t find x xs = foldl (\found elem->if elem == x then True else found) False xs
03:16:56 <lambdabot> parse error on input `='
03:17:02 <quicksilver> pointsToDirections _ = error "fewer than 3"
03:17:03 <hpc> foo [x,y,z] = exactly three; foo (x:y:z:more) = more than three; foo xs = less than three
03:17:17 <merijn> sanjoyd: :t doesn't accept definitions with =
03:17:22 <sanjoyd> Oh, okay.
03:17:27 <merijn> :t foldl (\found elem->if elem == x then True else found) False xs
03:17:28 <lambdabot> Not in scope: `xs'
03:17:35 <hpc> :t let x = 5 in x -- sanjoyd
03:17:35 <_mpu> :t foldl (\l x -> x : l) []
03:17:36 <lambdabot> forall t. (Num t) => t
03:17:36 <linduxed> quicksilver: oh so cover all the cases for more than three then just do _ ?
03:17:36 <lambdabot> forall b. [b] -> [b]
03:17:41 <linduxed> quicksilver: sounds fine
03:17:53 <_mpu> :t foldl (\l x -> l : x) []
03:17:54 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
03:17:54 <lambdabot>       Expected type: a
03:17:54 <lambdabot>       Inferred type: [a]
03:19:02 <merijn> linduxed: in "x:y:z:o" o will be the list that is left over after the first two elements are removed. _ is "special" variable name indicating "we don't care/use this value", so in this case since we don't care about o we'd use _ as name instead
03:19:13 <merijn> eh, first three
03:19:20 <linduxed> merijn: yeah i think i've got it
03:19:56 <merijn> linduxed: _ is not (much, anyway) different from any other pattern matching variable name
03:20:24 <minsa> let find x xs = foldl (\found elem -> if elem == x then True else found) False xs
03:20:29 <minsa> :t let find x xs = foldl (\found elem -> if elem == x then True else found) False xs
03:20:30 <lambdabot> <no location info>:
03:20:30 <lambdabot>     not an expression: `let find x xs = foldl (\found elem -> if elem == x then True else found) False xs'
03:20:59 <ion> That doesn’t short-circuit.
03:21:19 <merijn> :t let find x xs = foldl (\found elem -> if elem == x then True else found) False xs in find -- note the "in <expression>" at the end
03:21:19 <lambdabot> forall b. (Eq b) => b -> [b] -> Bool
03:21:50 <minsa> thnx
03:22:08 <quicksilver> linduxed: in fact, I should have used _:_:_:_:_ for more than 3
03:22:13 <quicksilver> linduxed: since I didn't care about any of them.
03:22:21 <minsa> so in this case, found has to be the first parameter in the lambda function ?
03:22:24 <linduxed> quicksilver: true
03:22:29 <ion> > find 42 (0:1:2:42:repeat 99)
03:22:30 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
03:22:30 <lambdabot>    arising from the literal `42...
03:22:33 <linduxed> but now i've got a bigger problem
03:22:45 <merijn> minsa: Yes, because the elements of the list are type b, but the accumulator is type Bool
03:22:49 <ion> > elem 42 (0:1:2:42:repeat 99)
03:22:49 <lambdabot>   True
03:23:15 <merijn> minsa: You could still reverse if you want to, by simply flipping the lambda function
03:23:17 <ion> > let elem x xs = foldl (\found x' -> if x' == x then True else found) False xs in elem 42 (0:1:2:42:repeat 99)
03:23:17 <merijn> :t flip
03:23:18 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
03:23:24 <lambdabot>  Terminated
03:23:38 <linduxed> since my sig is "pointsToDirections :: [Point] -> [Direction]" i have to return a list somehow out of the "pointsToDirections [a,b,c] = threePointDirection a b c" line
03:24:19 <linduxed> should i do a "[] ++ (threePointDirection a b c)" ?
03:25:12 <sanjoyd> linduxed: or
03:25:12 <merijn> linduxed: You can just do "[threePointDirection a b c]"
03:25:21 <linduxed> merijn: oh....
03:25:22 <sanjoyd> that ^
03:25:23 <merijn> > 4 + 5
03:25:25 <lambdabot>   9
03:25:26 <linduxed> well that was easier
03:25:27 <merijn> > [4+5]
03:25:28 <lambdabot>   [9]
03:26:01 <Cale> > 1 : []
03:26:02 <lambdabot>   [1]
03:26:04 <Cale> > [1]
03:26:05 <lambdabot>   [1]
03:26:09 <merijn> linduxed: Haskell programmers are lazy, so if you suspect there should be an easy way to do something, there probably is :p
03:26:35 <ion> merijn: I suspect there should be an easy way to do macros.
03:26:42 <merijn> ion: TH? :D
03:26:59 <linduxed> merijn: haha true i guess
03:27:24 <minsa> merijn, I understand accumulator is type Bool and the elements are of type b.
03:27:28 <merijn> ion: I should work on a haskell + lisp hybrid and solve that problem :p
03:27:38 <merijn> Gonna call it "Hathkell"...
03:27:43 <minsa> but why the position of the parameter has to be fixed ?
03:28:17 <merijn> minsa: That just happens to be how fold' is defined. There is no real reason for that order other then "historical reasons" I think
03:28:31 <merijn> As I said, you can easily switch the order using "flip" if you want
03:28:34 <merijn> :t elem
03:28:34 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
03:28:37 <quicksilver> merijn: lol ;)
03:28:38 <merijn> :t flip elem
03:28:39 <lambdabot> forall a. (Eq a) => [a] -> a -> Bool
03:28:42 <ion> There’s Liskell, but i presume its macro facilities don’t help if you want to use TH splices in normal Haskell code.
03:29:11 <merijn> quicksilver: I had to do all that setup just to mention that name after I just came up with it ;)
03:31:04 <minsa> both fold fucntion takes a binary function. foldr starts from the right side. if the list is [1,2,3] ----> it will be  (3 `binary_function` acc), then (2 `binary_function` acc) and so on ?
03:31:45 <merijn> Let's see if I remembered how to generate this example...
03:31:58 <merijn> > foldr f a [b,c,d,e,f]
03:31:59 <lambdabot>   f b (f c (f d (f e (f f a))))
03:32:21 <merijn> > foldl f a [b,c,d,e,f]
03:32:22 <lambdabot>   f (f (f (f (f a b) c) d) e) f
03:32:50 <ion> > foldr f z [a,b,c]
03:32:52 <lambdabot>   f a (f b (f c z))
03:32:54 <ion> > foldl' f z [a,b,c]
03:32:55 <lambdabot>   f (f (f z a) b) c
03:34:17 <minsa> foldr (-) [1,2,3]
03:34:22 <minsa> > foldr (-) [1,2,3]
03:34:23 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [t])
03:34:23 <lambdabot>    arising from a us...
03:34:35 <minsa> > foldr (-) [1,2,3] 0
03:34:35 <lambdabot>   No instances for (GHC.Num.Num [t], GHC.Num.Num [[t]])
03:34:36 <lambdabot>    arising from a use...
03:34:58 <minsa> > foldr (-) 0 [1,2,3]
03:34:59 <lambdabot>   2
03:36:47 <minsa> ((-) 3 0)
03:36:52 <minsa> >((-) 3 0)
03:36:56 <minsa> > ((-) 3 0)
03:36:57 <lambdabot>   3
03:37:09 <minsa> > ((-)  0 3)
03:37:10 <lambdabot>   -3
03:37:20 <minsa> > ((-)  -3 -2)
03:37:21 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> a)
03:37:21 <lambdabot>    arising from a use...
03:37:29 <minsa> > ((-)  -3 2)
03:37:30 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> a)
03:37:30 <lambdabot>    arising from a use...
03:37:40 <minsa> > ((-)  (-3) 2)
03:37:41 <lambdabot>   -5
03:37:48 <minsa> > ((-)  (-5) 1)
03:37:49 <lambdabot>   -6
03:37:53 <minsa> what's a miss ?
03:37:59 <minsa> I thought I was doing foldr ?
03:38:38 <ion> > foldr f 0 [1,2,3]
03:38:38 <lambdabot>   Ambiguous type variable `b' in the constraints:
03:38:39 <lambdabot>    `GHC.Num.Num b'
03:38:39 <lambdabot>      ari...
03:38:41 <ski> > foldr (-) 0 [1,2,3] :: Expr
03:38:42 <lambdabot>   1 - (2 - (3 - 0))
03:39:15 <ion> > foldl (-) 0 [1,2,3] :: Expr
03:39:16 <lambdabot>   0 - 1 - 2 - 3
03:39:19 <ski> > foldr (flip (-)) 0 [1,2,3] :: Expr
03:39:24 <lambdabot>   mueval-core: Time limit exceeded
03:39:35 <ski> eheh
03:39:45 <ski> > foldr (flip (-)) 0 [1,2,3] :: Expr
03:39:46 <lambdabot>   0 - 3 - 2 - 1
03:40:21 <ion> > foldl (flip (-)) 0 [1,2,3] :: Expr
03:40:22 <lambdabot>   3 - (2 - (1 - 0))
03:40:38 <ski> minsa : which variant did you want ?
03:41:37 <minsa> ski, thnx, am going through them now.
03:46:11 <minsa> so in foldl it doesn't matter the position of the parameter but the position of the parameter in the "body" of lambda matters ?
03:46:41 <ion> Huh?
03:47:03 <minsa> (\acc x -> acc - x)  for foldl    and    (\acc x -> x - acc)
03:47:10 <minsa> for foldr ?
03:47:17 <ion> :t foldl
03:47:18 <ion> :t foldr
03:47:18 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
03:47:19 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
03:51:54 <minsa> thnx ski, ion, and merijn. I will go read more.
03:53:48 <ski> minsa : the position of parameters always matters, more or less
03:54:37 <ski> in some very specific cases, it might not matter much, such as `x + y' vs. `y + x'
03:54:56 <ski> (but that really depends on the numeric type in question)
03:55:27 <merijn> Curse IEEE754 floats and their non-associativity!
03:55:59 <ski> heh, i was actually thinking about Peano `Natural's
03:58:18 <ion> *shiver*
03:58:26 <ion> Using the grave accent character as ‘ is so nasty. :-P
04:09:55 <linduxed> so i've got the following code http://paste.pocoo.org/show/425740/ . according to wikipedia the graham scan starts out by finding the point that has the lowest y value, places it at the start of the list (lets call that point p0) and sort the rest of the points by polar angle in relation to p0, placing them after p0
04:10:36 <linduxed> the polar part i haven't even touched yet, so that's something i'll be fighting against in a bit
04:13:07 <linduxed> but right now i'd like to know what the best way is to first of all search for the lowest y value and secondly the best way to place this point to the first position in the list
04:14:36 <linduxed> actually i think i got the first one
04:14:42 <linduxed> brb
04:16:16 <merijn> linduxed: You probably want the minimumBy and sortBy functions?
04:16:34 <linduxed> hmmm yeah that sounds about right i guess
04:16:45 <linduxed> judging by the name at least
04:21:31 <merijn> linduxed: Both take a function of type "a -> a -> Ordering" and then return the minimum of the list and sort the list based on that function
04:22:03 <merijn> Ordering being the datatype with the descriptive constructors "LT | EQ | GT"
04:23:01 <merijn> :t minimumBy
04:23:01 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
04:32:07 * hackagebot persistent-mongoDB 0.3.0 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-0.3.0 (GregWeber)
04:37:27 <Volpinius> hi guys
04:40:01 <Volpinius> i'm looking for a good book about haskell... I've found "Learn You a Haskell for Great Good" and it seems very good, but now I don't know if its a good choice for an haskell beginner...
04:40:21 <Volpinius> do you have any advice about this book?
04:40:38 <nus> what's your background?
04:41:20 <Volpinius> i know C/C++, java and python and now i want to learn some about functional programming
04:41:34 <Phyx-> then Real World Haskell might be more your speed
04:42:04 <nus> you might want to visit http://tryhaskell.org/ to get a taste
04:43:08 <Volpinius> i've already written something in haskell but not so much to say that i know it (i've read the first three chapter of Learn You a Haskell for Great Good)
04:43:12 <dankna> hm
04:43:16 <gienah> Volpinius: I recommend "The Craft of Functional Programming" 3rd ed
04:43:46 <ski> oh, there's a 3rd edition, now ?
04:43:55 <gienah> ski: yes :-)
04:44:05 <nus> a month or so
04:44:16 <ski> do you know what's different as compared to 2nd ed. ?
04:44:43 <gienah> ski: it has examples using quickcheck, has stuff on EDSLs
04:45:07 <ski> Volpinius : you could try the start of each of LYAH and RWH, and see what you like ..
04:45:11 <Volpinius> Thanks you at all, i think that i'll go to read something about Real World Haskell and The Craft of Functional Programming
04:45:59 <gienah> lyah and real world haskell are really great as well, the craft is a 500+ page intro to programming textbook
04:46:14 <nus> ski, haskellcraft.com
04:46:32 <gienah> real world haskell seems required for doing real world stuff
04:46:32 <Volpinius> ski: yes infact i've read the first chapter of RWH too, but it doesn't seems what i want, because i want  to learn from a book that explains me also some maths concept
04:46:42 <merijn> Volpinius: Learn You a Haskell is one of the best beginner Haskell books, IMO
04:46:49 <nus> Volpinius, such as?
04:46:59 <merijn> RWH is a good follow-up/addition to LYAH
04:47:32 <nus> there's a book to teach yourself math using Haskell
04:47:49 <Volpinius> such as the way to solve common maths problems, because haskell is so different from the other language that i don't understand the way to implement little algorithm
04:47:54 <merijn> Phyx-: Personally as a person who already knew C/C++/java/python I thought LYAH was nicer then RWH because RWH glossed over a bunch of beginner details which led to me being quite confused for a while
04:48:42 <gienah> well there is "the haskell road to programming, logic and maths" or something like that, its a great introductory maths book on sets, relations, logic with a little haskell
04:48:44 <Nimatek> I find it's best to read the two in parallel.
04:49:04 <Nimatek> You're not confined to one book!
04:49:06 <ski> nus : "The Haskell Road to Logic, Maths and Programming", by Kees Doets,Jan van Eijck, at <http://homepages.cwi.nl/~jve/HR/> ?
04:49:46 <nus> uhuh
04:49:55 <Volpinius> "The Haskell Road to Logic, Maths and Programming" seems a good book!
04:50:19 <gienah> there is another great haskell text that uses maths (I think its a great book guess I might be in the minority maybe) "Introduction to Functional Programming" by Bird
04:51:01 <ski> @where+ HR "The Haskell Road to Logic, Maths and Programming", by Kees Doets,Jan van Eijck, at <http://homepages.cwi.nl/~jve/HR/>
04:51:01 <lambdabot> Good to know.
04:51:30 <gienah> Volpinius: The haskell road is a great book on maths, but it does not teach enough about haskell, hence need another book or read other stuff to learn haskell
04:52:21 <Phyx-> merijn: I've only read RWH, never read LYAH
04:53:43 * sanjoyd just ordered RWH.
04:54:19 <Volpinius> geniah: ah ok, i think that i'll look for buying Haskell Craft of Functional Programming, it seems very complete and more explained than Learn Your Haskell
04:55:15 <Volpinius> Thanks a lot!
04:55:33 <gienah> Volpinius: yes it does seem more complete given the craft is over 500 pages :-)
04:55:50 <Volpinius> yes :D
04:58:05 <_mpu> Structure and Interpretation of Computer Programs, http://mitpress.mit.edu/sicp/ is nice
04:58:41 <_mpu> but not really real world ... (however it gives all ideas about what differs between functional and imperative)
04:59:21 <gienah> _mpu: yes if you want to learn scheme. Also for scheme there is Essentials of Programming Languages
04:59:26 <_mpu> moreover, you don't need to buy the book, it's online
04:59:26 <merijn> How is SICP not real world?
04:59:42 <_mpu> merijn: it depends on your world ...
05:00:03 <_mpu> If you want to craft a webserver you might not be ready after reading it :_
05:00:27 <ski> @where SICP
05:00:28 <lambdabot> The Wizard book : "Structure and Interpretation of Computer Programs" at <http://mitpress.mit.edu/sicp/> by Hal Abelson,Gerald Jay Sussman with Julie Sussman, videos at <http://swiss.csail.mit.edu/
05:00:28 <lambdabot> classes/6.001/abelson-sussman-lectures/>
05:00:51 <_mpu> the lectures are _great_
05:01:07 <nus> Volpinius, have a look @ http://en.wikibooks.org/wiki/Haskell too
05:02:31 <Volpinius> nus: oh i hadn't seen this page yet :D
05:04:00 <nus> also, you most likely would have to "unlearn" C++, so to say
05:06:46 <_mpu> I started functional programming by reading r5rs, I would not recommend it ...
05:07:27 * ski started by the Craft ..
05:07:41 <gienah> _mpu: do you mean like trying to read the r5rs scheme specification?
05:07:55 <_mpu> I read it
05:08:43 <gienah> _mpu: this book is easier on r6rs: http://www.scheme.com/tspl4/
05:08:55 <_mpu> it was hard and I clearly remember that I totally non-understood the part on lazy data :)
05:09:57 <ski> gienah : istr that book has Chez-isms hidden in it ..
05:10:41 <gienah> ski: thanks
05:17:28 <lysgaard> I have a map heavyFunc [a] where heavyFunc takes i bit of time. I would like to run this is paralell. What is the _easiest_ way?
05:17:50 <merijn> parMap I think?
05:19:09 <merijn> Dunno if you have to do anything else besides replacing map with parMap, but I don't think you have to do much
05:19:21 <lysgaard> merijn: I've tried it but it only uses one core still. Even though i compile with threaded.
05:19:41 <merijn> lysgaard: Do you pass the number of cores to the runtime system at runtime?
05:19:48 <merijn> I think there's a flag for that
05:19:53 <lysgaard> merijn: No, how do i do that?
05:21:23 <merijn> Pass "+RTS -N4 -RTS" as argument to your program (replace 4 with the number of cores)
05:22:24 <merijn> That tells the runtime to execute using 4 OS threads rather then just one
05:22:44 <merijn> See also: http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
05:25:08 <drbean_> R5RS is the Revised5 Report on the Algorithmic Language Scheme .
05:25:48 <lysgaard> merijn: Seems like that works well! Thanks =)
05:25:56 <merijn> lysgaard: np :)
05:31:00 <Spockz> Wasn't there a way to ignore _ pattern matching with -fwarn-incomplete-patterns , so you get warnings where you use the _ match?
05:31:51 <merijn> The only warning like that (that I know off) warns about incomplete patterns, but that only reports missing cases. "_" is not a missing case
05:35:14 <cebewee> hi
05:35:45 <cebewee> i've got trouble to install happy-1.17 with current cabal.
05:35:59 <cebewee> cabal-install fails with: user error (File in tar archive is not in the expected directory "happy-1.17")
05:36:23 <cebewee> but if I look at the tar file, it seems all files live happily below happy-1.17/
05:37:07 <hape01> cebewee: It is   "cabal install happy-1.17"   I guess
05:37:20 <Spockz> merijn: yes that's the warning I mentioned. But I saw someone use a flag to detect where you used _ patterns somehwere on a mailinglist
05:37:27 <hape01> cebewee: before make "cabal update"
05:38:16 <cebewee> hape01: "cabal install --global happy-1.17", to be exact
05:38:31 <cebewee> and I just did "cabal update" (it's a fresh build)
05:38:56 <hape01> cebewee: Does it run now correctly?
05:39:03 <cebewee> nope
05:39:24 <hape01> which command did you enter?
05:42:20 <cebewee> cabal update; cabal install --global happy-1.17
05:47:57 <hape01> cebewee: in the cabal data directory, there is an subfolder "packages", wherein thereis an subfolder "hackage.haskell.org" wherein there is "happy". I would remove the already downloaded tar file there an retry the installation, which will download the file again
05:49:58 <ivanm> why is it that if I have "halve (x:_:xs) = x : halve xs; halve xs = xs", that "halve $ map f xs" is noticeably slower than "map f $ halve xs" ?  Shouldn't laziness make it that the mapping in the first case won't be applied to the values that get removed?
05:50:41 <quicksilver> yes. The slowness will not be caused by extra computation of 'f'.
05:51:30 <ivanm> so why would it be slower?
05:52:01 <ivanm> I'm going to try making a minimal test case to see if this still occurs, but it's definitely happening in my program atm
05:54:56 <McManiaC> why is "cabal haddock" failing with:
05:54:57 <McManiaC> cabal: Can't find transitive deps for haddock
05:54:58 <McManiaC> ?
05:56:16 <ivanm> McManiaC: is haddock installed?
05:56:34 <McManiaC> yes
05:56:34 <McManiaC> Haddock version 2.9.2, (c) Simon Marlow 2006
05:57:07 <cebewee> hape01: didn't help. i'm trying now to build it by hand
05:57:21 <hpaste> ivanm pasted “Strange benchmarking results” at http://hpaste.org/48591
05:57:30 <McManiaC> is it because of my "executable .." section in the .cabal file?
05:57:47 <ivanm> ^^ can anyone verify this for me? especially if they have ghc-7 (since I just have 6.12.3 still)
05:58:01 <ivanm> McManiaC: do you have a library section?
05:58:05 <McManiaC> yep I do
05:58:11 <ivanm> McManiaC: wait, are you using Cabal-1.8-style deps?
05:58:20 <ivanm> i.e. executable-depending-upon-library ?
05:58:35 <ivanm> or at least having Cabal-Version >= 1.8 ?
05:59:49 <Eduard_Munteanu> ivanm: what optimization level?
05:59:54 <ivanm> -O2
06:00:18 <ivanm> I also used -funbox-strict-fields if it makes a difference
06:00:24 <ivanm> (which I don't think does here)
06:00:43 <McManiaC> ivanm: I have >= 1.8, yes
06:00:56 <McManiaC> ivanm: building/installing works just fine, only haddock fails
06:00:57 <ivanm> McManiaC: there's a cabal bug
06:01:07 <McManiaC> oh ok
06:01:09 <ivanm> I found that soon after 1.8 came out; hasn't been fixed since :(
06:01:13 <Eduard_Munteanu> Are you counting on halve fusing somehow? I don't think it can.
06:02:16 <ivanm> Eduard_Munteanu: no, but it seems that having the map first is 50% again the runtime, which to me is a little odd because of laziness
06:02:37 <quicksilver> ivanm: I imagine it's length fusing with map in the 2nd example
06:02:41 <quicksilver> which makes it faster
06:02:54 <quicksilver> you're not actually evaluating  'f' in either case
06:03:01 <quicksilver> not even for the cells you throw away with halve.
06:03:06 <Eduard_Munteanu> I'd try increasing the data set, it's way too short.
06:03:15 <ivanm> quicksilver: ahhhh
06:03:36 <ivanm> this isn't the actual test that I was trying to solve, it's just something I came across desperately trying to solve my problem :p
06:04:02 <ivanm> what I'm _really_ trying to work out is why doing a "length xs `seq` xs" makes my code faster :/
06:04:06 <ivanm> (when xs is rather long)
06:06:12 <frerich> ivanm: Maybe it's because there's less work to be done by the garbage collector? I recently read about something like this, some profiling showed that the 'productive' time shown in the profiling output was actually just a small part, most time was spend in the GC.
06:06:35 <frerich> ivanm: By being strict, there were less thunks hanging around and the GC had less to do. Or something like that, ahem.
06:06:45 <ivanm> yeah, could be
06:06:53 <Eduard_Munteanu> Hrm, yeah, it might be worth running with -s and seeing how much time you spend in GC.
06:07:00 <Tomsik> But length isn't strict in elements
06:07:03 <ivanm> oh, I did
06:07:31 <frerich> ivanm: Ah, and RWH has a very nice chapter on this sort of problem: http://book.realworldhaskell.org/read/profiling-and-optimization.html
06:07:31 <Tomsik> so you actually get more thunks around?
06:07:32 <ivanm> Tomsik: in this case, I'm recursively constructing every possible tree that matches some criteria, so the list gets constructed and is rather big
06:07:34 <Eduard_Munteanu> You can increase productivity by increasing -H
06:07:39 <frerich> ivanm: It looks a lot like your case.
06:07:40 <ivanm> frerich: read it; still stuck :p
06:07:46 <frerich> ivanm: Oh, heh.
06:07:54 <Eduard_Munteanu> Though it's not really a fix.
06:07:56 <quicksilver> if your working set is actually very large
06:08:04 <ivanm> the profiling output is a _lot_ different when seq'ing the length :/
06:08:06 <quicksilver> then forcing a large list upfront forces the heap to expand early
06:08:12 <quicksilver> which might be what you want
06:08:23 <quicksilver> you could, instead, use the RTS options to expand the heap unfront
06:08:24 <ivanm> hmmmmm.....
06:08:34 <quicksilver> (I can't remember what options. -A? -H?)
06:08:39 <Eduard_Munteanu> -H
06:08:53 <ivanm> you mean it _isn't_ my code at fault?
06:09:01 <ivanm> I've been banging my head against this all day! :s
06:09:35 <Eduard_Munteanu> I'd say the fault lies somewhere between your code and GC behavior.
06:09:49 <ivanm> *sigh*
06:09:59 <frerich> ivanm: If you run with +RTS -sstderr, what 'Productivity' does it show?
06:10:48 <hpaste> ivanm pasted “Profiling output” at http://hpaste.org/48592
06:11:07 <ivanm> ^^ both with and without "length xs `seq` xs"
06:11:27 <ivanm> the maximum residency bit is really quite a large difference :s
06:11:49 <quicksilver> ivanm: but the overall time is very similar
06:11:53 <quicksilver> so why are you doing this?
06:12:24 <Eduard_Munteanu> Yeah, it's not much of a difference.
06:12:37 <Eduard_Munteanu> Besides productivity is quite high, you won't shave off much.
06:12:40 <ivanm> that's old-ish data; it makes a larger difference now
06:13:08 <ivanm> and with larger input values I also end up consuming all of my RAM, though I'm not sure if that's related :/
06:14:21 * ivanm goes off to run those commands again
06:18:43 <ivanm> OK, there isn't _much_ runtime difference
06:19:07 <ivanm> but the seq version is a tad faster (and I need all the speed I can get to make my supervisor shut up about C :p) and uses a lot less RAM
06:19:23 <ivanm> and RAM consumption goes up rather quickly :/
06:24:28 <ivanm> quicksilver: what would you recommend as the argument for -H ?
06:24:39 <ivanm> I tried -H20M but it doesn't seem to make that much of a difference :/
06:25:23 <ivanm> (since I thought that max residency was tha largest amount of heap space used at any one time)
06:28:32 <ivanm> even -H100M doesn't seem to make a difference :/
06:30:39 <ivanm> OK, -H1G made a _bit_ of difference.. but 1G of heap space seems a bit much :/
06:37:38 <ivanm> Eduard_Munteanu, quicksilver: so if even -H2G doesn't seem to "fix" it, any other suggestions?
06:39:51 <lpsmith> So in what sense is the store comonad dual to the state monad?
06:40:18 <ezyang> lpsmith: Write out the type signatures for both.
06:40:34 <lpsmith> I mean,   I know state is   st -> (a, st),   so why isn't store (a,st) -> st
06:40:44 <lpsmith> ezyang: already done :)
06:41:33 <bbe> Erm strange question but, what would you guys say if someone told you that the Linux kernel is a "programming masterpiece"?
06:41:40 <lpsmith> Unless I'm not writing out the type signature for the right thing
06:42:07 <merijn> bbe: Nothing, I'd be to busy laughing in their face
06:42:51 <ezyang> Store comonad is roughly (s -> a, s)
06:43:13 <merijn> bbe: Any particular reason for asking? :p
06:43:14 <ezyang> State monad is s -> (a, s)
06:43:45 <ezyang> I think?
06:43:52 <lpsmith> yeah, that's right
06:44:06 <lpsmith> I'm not understanding the duality though
06:44:13 <ezyang> So, a Kleisli arrow for the state monad is a -> s -> (b, s)
06:44:39 <ezyang> And a coKleisli arrow for store comonad is (s -> a, s) -> b
06:46:20 <ezyang> or, equivalently, (s -> a) -> s -> b
06:46:36 <ezyang> Actually, I've lost my train of thought.
06:46:55 <ski>   (s,a) -> (s,b)
06:47:14 <ezyang> Oh, right-o.
06:47:24 <copumpkin> lpsmith: did you get your answer?
06:47:49 <copumpkin> lpsmith: monads arise out of compositions of adjoint functors, and to get the associated comonad, you compose the functors the other way around
06:48:01 <ski> ezyang : and `(s -> a) -> (s -> b)' for store / (state-in-)context comonad, as you said
06:48:08 <lpsmith> give me a few mintues
06:48:09 <copumpkin> so you're composing (a, _) and a -> _
06:48:39 <alfa_y_omega> in my axiomatic logic, like Kleisli arrow for state monad will be: a, s |= (b,s), like coKleisli arrow for store comonad will be: (s->a), s |= b
06:48:47 <copumpkin> composing them one way gives you a -> (a, _) and the other gives you (a, a -> _)
06:49:35 <ski> yeah, it's about the adjoint situation `(st,) --| (st ->)'
06:49:36 <lpsmith> copumpkin:  you lost me there,  category theory has never exactly made sense for me
06:50:56 <lpsmith> I've sat in on a few category-theory classes,  but it's like I've somehow missed category theory 101 and my attempts to learn it on my own haven't been too successful.   I get bits and pieces of the material,  but not fluency
06:51:19 <copumpkin> lpsmith: have you come across adjunctions?
06:51:23 <ski> lpsmith : define `type And s a = (s,a)' and `type Implies s a = s -> a', then `(Implies s . And s) a = s -> (s,a)' and `(And s . Implies s) a = (s,s -> a)'
06:52:16 <dolio> And 'And s -| Implies s'
06:52:53 <dolio> Because (s, a) -> b  is isomorphic to a -> s -> b.
06:52:55 <ski> what dolio said means that `And s a -> b' is isomorphic to `s -> Implies s b'
06:52:57 <dolio> Except in Haskell.
06:53:38 <ezyang> Oh oh, what are adjunctions in logic? That would clear things up for me.
06:53:49 <dolio> There are many.
06:53:56 <dolio> That adjunction gives you the rule:
06:54:04 <ezyang> ruh oh. What are they in general?
06:54:17 <dolio> P /\ Q |- R  iff Q |- P => R
06:54:51 <ezyang> oh, so every rule of that style in propositional logic counts as an adjuunction?
06:54:58 <dolio> No.
06:55:06 <ezyang> :-(
06:55:20 <dolio> But many of them can be seen as coming from adjunctions.
06:55:31 <ski> that particular rule is an adjunction
06:55:42 <lpsmith> copumpkin: no, not really
06:55:49 <dolio> For instance, there is a functor D : C -> C x C.
06:55:58 <copumpkin> lpsmith: EMBRACE THE POWER OF ADJUNCTIONS
06:55:58 <dolio> D A = (A, A) for objects.
06:56:04 <dolio> D f = (f, f) for arrows.
06:56:09 <lpsmith> :)
06:56:16 <ski> `P |- Q0  and  P |- Q1  iff P |- Q0 /\ Q1' is another adjunction in logic
06:56:32 <dolio> ezyang: That's called the diagonal adjunction.
06:56:41 <dolio> There are two adjoints to the diagonal adjunction.
06:56:50 <dolio> The left one is sum, the right one is product.
06:56:58 <ski> `(P,P) |- (Q0,Q1)  and  P |- Q1  iff P |- Q0 /\ Q1' is the same rule, expressed in another way
06:57:07 <ski> er
06:57:12 <ski> `(P,P) |- (Q0,Q1)  iff P |- Q0 /\ Q1' is the same rule, expressed in another way
06:57:30 <dolio> The left one gives you: (P |- Q, P |- R) iff P \/ Q |- R
06:57:37 <ezyang> This might be a bit strange of me, but I think I need a more abstract conception of what an adjoint is.
06:57:39 <dolio> Diagonal functor, sorry.
06:57:41 <ski> `D P |- (Q0,Q1)  iff P |- (/\) (Q0,Q1)' is again the same rule, now expressed more clearly as an adjunction
06:57:42 <ezyang> But made concrete in the language of logic.
06:58:04 <ski> the adjunction here is `D --| (/\)'
06:58:23 * hackagebot geocalc 1.0.0 - Libary for calculating distances between two coordinates in WSG84  http://hackage.haskell.org/package/geocalc-1.0.0 (GeroKriependorf)
06:58:43 <lpsmith> I need some concrete examples of category theory.  That's part of my problem,  too many definitions before there is anything that my brain finds really interesting and wants to latch on to.
06:58:57 <dolio> There is also an adjunction that gives rise to true and false.
06:59:14 <dolio> There is a functor ! : C -> 1.
06:59:25 <dolio> ! A = *, ! f = id_*
06:59:53 <dolio> That functor has a left adjoint and a right adjoint. The left adjoint is the constantly false functor, and the right is the constantly true functor.
07:00:05 <ski> an adjunction situation consists of two categories `C',`D', two functors `F : C -> D',`G : D -> C', such that `F A -{C}-> B' is naturally (in `A',`B') isomorphic to `A -{G}-> G B', `A' being any object in `C' and `B' any object in `D'
07:00:48 <lpsmith> wait,  geocalc takes in WGS84 and pretends the earth is a perfect sphere?   I thought WGS84 specified a datum :)
07:01:10 <copumpkin> I'm a member of the flat earth society, myself
07:01:21 <copumpkin> http://theflatearthsociety.org/cms/
07:01:22 <dolio> Which gives you the rules _|_ |- A iff * |- *, but the latter is trivial, so it's explosion.
07:01:47 <ski> lpsmith : do you know about e.g. the category of vector spaces, or the category of groups or rings ?
07:01:48 <ion> I for one am a member of the perfectly spherical earth society.
07:01:53 <dolio> And * |- * iff A |- T
07:02:37 <ion> I and copumpkin both agree the cubic earth society people are heretics.
07:02:40 <lpsmith> ski,  I know a fair bit about vector spaces, groups and rings but not in a categorical sense.
07:03:14 <ski> lpsmith : well, you know about `n'-dimensional vector spaces, i assume
07:03:19 <lpsmith> yeah
07:03:48 <ski> lpsmith : there is a functor from `Vect' to `Set', which takes any vector space to the underlying set of vectors (the carrier of the vector space)
07:04:02 <dankna> I believe the Earth is toroidal, as God and Squeenix intended.
07:04:16 <dankna> go north from the north pole and you wind up at the south pole!
07:04:27 <ski> this is often called the "underlying" or "forgetful" functor, since it just forgets about the extra structure, except from the carrier set, that a vector space has
07:04:39 <ski> this functor is often named like `U'
07:04:56 <ski> dankna : hollow earth theory, eh ?
07:05:10 <lpsmith> ski:  what's a carrier of a vector space?    What I remember is that there is a basis for a coordinate system,  but that's not intrinsic to the space.
07:05:21 <dankna> no, solid or hollow is - pardon the pun - orthogonal.
07:05:22 <fasta> ski: that you can 'add' two vectors is one element in this set, right?
07:05:54 <ski> lpsmith : yeah, and that you can scale them with scalars in the field (and that the respective laws hold, as well)
07:06:07 <ski> er
07:06:17 <ski> s/lpsmith/fasta/
07:06:28 <lpsmith> :)
07:06:31 <fasta> ski: and then they say university is useless ;)
07:07:10 <ski> lpsmith : this functor `U : Vect -> Set' has a left adjoint `F : Set -> Vect', i.e `F --| U' holds
07:07:22 <ski> `F' is usually called the "free functor"
07:07:54 <ski> now, the adjunction specifies that for any set `S' and vector space `V', the morphism classes
07:08:10 <linduxed> if i'm typing some conditions after some guards, can i use a logical AND? in that case, how do you type AND? is it && ?
07:08:34 <lpsmith> ski: I'm assuming the "carrier set" is a basis,  but most vector spaces have many basises.
07:08:54 <ski> no, "carrier" is not "basis"
07:09:13 <fasta> A basis is a concept from linear algebra.
07:09:15 <ski> the "carrier" is just the set of all vectors in the vector space
07:09:22 <dolio> ezyang: Anyhow. I don't know of a way of reading P |- P as an adjunction. That comes instead from the logic being a category.
07:09:29 <dolio> And composition is a kind of cut rule.
07:09:41 <ski> anyway, the morphism classes the adjunction talks about are
07:09:44 <ski>     S  --{Set }--> U V
07:09:46 <ski> and
07:09:46 <ski>   F S  --{Vect}-->   V
07:09:58 <ski> these are claimed to be isomorphic
07:10:15 <ski> so e.g assume that `S' is the set `{x,y,z}'
07:10:44 <dolio> Quantification in predicate logic also comes from an adjunction, though, although you can't use quite as simple a category.
07:10:45 <ski> then any morphism in `S --{Set }--> U V' essentially picks out three vectors in `V'
07:10:50 <ski> lpsmith : agree, so far ?
07:11:00 <dolio> Exists is left adjoint to weakening which is left adjoint to forall.
07:11:03 <lpsmith> oh, ok
07:11:16 <ski> so, it might be specified as
07:11:20 <ski>   f(x) = v_0
07:11:25 <ski>   f(y) = v_1
07:11:28 <ski>   f(z) = v_2
07:11:51 * edwardk waves hello.
07:11:51 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
07:11:59 <ski> now, the adjunction claims that to this function `f' corresponds a linear transformation, let's call it `F', in the morphism class `F S  --{Vect}-->   V'
07:12:44 <ski> and `F' is the linear transformation from the vector space with `{x,y,z}' as basis, to the vector space `V', specified by `f'
07:13:43 <ski> so this adjunction is what allows us to specify a linear transformation from a space with a basis, by just specifying where it maps the basis vectors, and they saying that "the linear transformation is now determined by linear combinations"
07:14:14 <ski> so, the free vector space over a set is the vector space which has that set as a basis
07:14:52 <edwardk> @tell ivanm i backgrounded, then i closed the laptop. ;)
07:14:52 <lambdabot> Consider it noted.
07:15:29 <ivanm> edwardk: heh, excuses excuses!
07:15:29 <lambdabot> ivanm: You have 1 new message. '/msg lambdabot @messages' to read it.
07:15:30 <ivanm> @clear
07:15:30 <lambdabot> Messages cleared.
07:15:42 * ivanm -> sleep
07:15:54 * edwardk likes free vector spaces/free modules
07:16:50 <edwardk> i've been building lots of code on them lately
07:16:56 <lpsmith> ski:  ok, I think I understand this U functor,  but not the F functor so much
07:17:03 <ski> similarly, the free group over a set is the group which is generated from the elements of the set
07:17:05 * wli is still trying to figure out how to bracket minima within a specified compact interval.
07:17:26 <ski> lpsmith : `F S' will turn out to be `|R^S'
07:17:43 <edwardk> U forgets the vector space structure, just giving you a set of its basis vectors.
07:18:34 <lpsmith> wait,  ski said U gave you the carrier set
07:18:48 <ski> and the free ring over a set is the polynomial ring (with integer coefficients) with the elements of the set as "variables"
07:18:48 <edwardk> that works too i guess
07:18:55 <lpsmith> If U gave you a basis set, how does it pick which one.
07:19:04 <lpsmith> ?
07:19:05 <ski> `U' doesn't give a basis set
07:19:19 <ski> `U' gives the carrier set of all vectors in the space
07:19:35 <ski> `F' constructs a space with the gives set as basis
07:20:28 <lpsmith> ski:  when you wrote  F --| U,  what did that mean?
07:20:30 <edwardk> i was thinking in terms of taking a vector space with a distinguished basis to just the basis set B, then describing the free vector space over a field F with basis B as functions B -> F
07:21:04 <ski> lpsmith : `F --| U' means : "the functors `F' and `U' (in that order) form an adjunction situation"
07:21:13 <lpsmith> ahh
07:21:27 <ski> also expressed as "`F' is left adjoint to `U'" alt. "`U' is right adjoint to `F'"
07:22:10 <edwardk> which is to say that (F a -> b) is isomorphic to (a -> U b)
07:22:11 <ski> btw, this symbol `--|' has nothing to do with the `|-' "entails" symbol in logic
07:22:26 * hackagebot hstzaar 0.8 - A two player abstract strategy game.  http://hackage.haskell.org/package/hstzaar-0.8 (PedroVasconcelos)
07:22:28 <edwardk> where the ->'s are in the appropriate categories
07:22:41 <lpsmith> Yeah, it reminded me of |-,  but it didn't confuse me :)
07:23:08 <edwardk> lpsmith: it is scattered throughout my last half dozen blog posts ;)
07:23:09 <ski> (in ascii, i write it as `--|' rather than `-|', to not confuse it with converse `|-')
07:23:29 <ski> (in books, i've seen it written sometimes as `-|', sometimes as `-----|')
07:23:47 <lpsmith> yeah,  I'm trying to understand your posts,  which is why I'm asking ;-)
07:23:52 <edwardk> ahh
07:24:06 <lpsmith> Actually I do understand parts of your posts pretty well,  the rest not so much
07:24:51 <edwardk> you might find the old 'Kan Extensions' and 'Kan Extensions II' posts on my blog to be a good starting point, the latter introduces adjunctions a bit
07:24:52 <lpsmith> None of my Bachelor Major in Math did anything with category theory,  and my first formal exposure was after and a bit over my head :)
07:25:09 <edwardk> lpsmith: i understand that feeling =)
07:26:23 <ski> other examples of free functors : the free abelian group over a group is the abelianization of the group. the free topological space over a set is the discrete topology on that set
07:26:50 <edwardk> free monads
07:27:39 <ski> the free category over a graph is the category of paths in the graph
07:27:51 <edwardk> the free sigma-algebra of a set is the power set
07:30:08 <ski> when we say "the free Bar over a Foo is Blah of Foo" we mean that given some obvious underlying functor from Bar to Foo, the left adjoint to this functor does Blah to Foo
07:31:04 <ski> it's interesting to note that when making a free group over a set, that constructs a "larger" object in some sense
07:31:16 <lpsmith> out of curiousity, what is the abelization of a group?   the center of a group?
07:31:20 * Athas wonders about the average number of dependencies for a Hackage project.
07:31:32 <ski> but when making a free abelian group over a group, that constructs a smaller group
07:32:16 <ski> lpsmith : no. the abelianization is the least restrictive quotient of the group, which makes it abelian
07:32:34 <lpsmith> ski:  ahh, that makes more sense
07:36:50 <edwardk> also if you have a right adjoint to a forgetful functor, you have some 'cofree' construction.
07:37:12 <edwardk> which is where the cofree comonad comes from
07:39:44 <gwern> Athas: I would guess the average to be somewhere between 5 and 10
07:40:12 <Athas> I still have a hard time getting used to it...
07:41:12 <ski> yeah, e.g. the cofree topological space over a set is usually known as the "indiscrete" topology
07:43:00 <gwern> Athas: you could count, you know. it's not that hard. feed the output of cabal list into cabal download, do a find -name "*.tar.gz" to decompress the cabal files, then some grep, some sorting and search-and-repalce, and you get a total number of deps. divide by however many .tar.gzs you have...
07:43:45 <Athas> Oh, I have no real use for this data, I was just idly wondering as I perused my own dependency list.
07:44:42 <gwern> dang, now I want to do that and email the results to -cafe
07:45:50 <Jafet> A dependency is counted as any name listed in the cabal file?
07:45:56 <gwern> let's see, the download command is pretty simple: cabal fetch `cabal list|g '\*'|tr -d '\*'`
07:46:34 <gwern> Jafet: I was thinking you could grep for any line with a comma, then sort the lines and delete anything without leading whitespace or 'depends' in it
07:47:20 <gwern> (oh, my download command doesn't quite work. a for loop would be better)
07:49:16 <gwern> I wonder why cabal fetch invokes the dep constraint solver at all such that ab unch of downloads are erroring out
07:50:15 <linduxed> in my interpreter i have to type about six "let" commands every time i reload some code i've written
07:50:34 <linduxed> is there a better way to "let" these values?
07:50:49 <linduxed> can i somehow write multiple commands on one line?
07:51:00 <Saizan> is Ran g h ~ (h . f) given f -| g ? since Maybe ~ Ran Id Endo but Maybe /~ Id . Endo, or is it wrong to use Id -| Id here?
07:51:06 <merijn> linduxed: You can load files in the interpreter
07:51:18 <linduxed> merijn: yeah that's what i'm doing
07:51:26 <Saizan> s/Id . Endo/Endo . Id/
07:51:31 <linduxed> can i load lets too?
07:51:32 <merijn> linduxed: If you just create a haskell source file you can run "ghci file" and then all functions you define in the file are loaded automatically
07:51:40 <gwern> linduxed: you could use ;
07:51:48 <gwern> ; works in ghci doesn't it?
07:51:57 <Jafet> You can type multi-line definitions, but that's not any different
07:52:08 <merijn> linduxed: Can you paste the code you have to retype?
07:52:15 <Jafet> Generally, it's not a good idea to edit six-line definitions in ghci.
07:52:26 <merijn> It sorta depends on what you're doing I think
07:52:28 <linduxed> merijn: let a = 4
07:52:30 <gwern> Jafet: well, it's easier to page through the history to reinvoke one line with multiple semicolon statements than 6 in a row
07:52:31 <Jafet> Write it in a proper editor and load it from the editor to ghci.
07:52:33 <linduxed> merijn: let b = 6
07:52:40 <linduxed> merijn: that kinda stuff
07:52:41 <merijn> linduxed: You can just define "a = 4" in the source file
07:52:50 <linduxed> merijn: oh
07:52:55 <linduxed> merijn: and that will tag along?
07:52:57 <linduxed> nice
07:53:44 <wli> Usually better to set parameters you're going to tweak in ghci and edit complex code in a real editor and pass parameter args to it in ghci.
07:54:28 <merijn> linduxed: Of course. "a = b" just assigns the name "a" to a value "b", now often the value b will be a function, but it can just as easily be another value like Int
07:59:35 <matthiasgorgens> I have an application that gathers (in the IO Monad) some values from the command line utility "lspci" whenever it needs them.  Now that's too slow and we want to introduce some caching.  That will require some refactoring.  What's a nice way to introduce this caching?
08:00:03 <edwardk> saizan: i have the relation in my second kan extensions post
08:00:12 <matthiasgorgens> The problem is that the data structure for the cache needs to some kind of MVar or similar,
08:00:21 <matthiasgorgens> and thus has to be passed around in the whole program.
08:00:38 <edwardk> f -| g, gives you that Ran g Id = f
08:00:54 <Jafet> unsafePerformIO (newMVar CacheEmpty)
08:01:08 <Saizan> edwardk: i'm looking at ranToComposedAdjoint :: Adjunction f g => Ran g h a -> (h `O` f) a
08:01:08 <matthiasgorgens> Shall I just suck it up, and convert almost all mentions of IO a into StateT something IO a?
08:01:09 <Jafet> Er sorry my cat was on the keyboard
08:01:51 <edwardk> and thinking in terms of Ran Id Endo ?
08:01:56 <matthiasgorgens> Jafet, yes, I thought of that.  But isn't that evil?
08:02:17 <Saizan> edwardk: yep, since that's Maybe, right?
08:02:19 <Jafet> Very. But it should work.
08:02:54 <edwardk> so what do you get when you ranToComposedAdjoint a Yoneda Endo encoded maybe?
08:03:08 <matthiasgorgens> Jafet, we might even get away with cache = unsafePerformIO something
08:03:13 <matthiasgorgens> and no MVar at all.
08:03:18 <matthiasgorgens> though that's still evil.
08:03:26 <matthiasgorgens> (and the cache would be static.)
08:03:29 <Saizan> edwardk: Endo a ?
08:03:43 <edwardk> so then its probably id or the const a
08:03:46 <linduxed> let's say i've got a list of points. i wish to order the tail of the list by polar angle
08:04:04 <edwardk> depending on if its nothing or Just
08:04:13 <ozataman> can anyone think of a simple way to do "cat file1 file2 file3 ... | someOtherPrg" in Haskell. something like (openFiles :: [FilePath] -> IO Handle)
08:04:25 <linduxed> any idea on how one could do this?
08:04:26 <edwardk> or something similar
08:04:38 <edwardk> now the next question is how that gets decomposed =)
08:05:02 <merijn> linduxed: sortBy myFunc . tail
08:05:18 <ski> linduxed : maybe you want `sortBy (comparing phase) listTail' ?
08:05:23 <matthiasgorgens> ozataman, look at enumerator based IO.
08:05:54 <ozataman> matthiasgorgens: Right, I know it's possible using iteratees, but I was hoping for a simpler, Handle based solution
08:06:03 <merijn> linduxed: tail gives you everything but the first item of the list, and sortBy takes a function which compares two items plus a list and sorts the list based on the function
08:06:07 <merijn> :t sortBy
08:06:08 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
08:06:39 <matthiasgorgens> ozataman, I guess you can hack something up with handles.
08:06:58 <ozataman> matthiasgorgens: right
08:07:19 <matthiasgorgens> ozataman, you can also call out to command line `cat'.
08:07:45 <linduxed> ski: merijn i do know about the sortBy and tail functions, i was mainly having trouble figuring out how to sort by polar angle
08:07:46 <ozataman> matthiasgorgens: I know, but the point was to do it in Haskell
08:08:07 <Jafet> You can spawn a subprocess written in Haskell, whose only job is to emulate cat…
08:08:09 <merijn> linduxed: You need to write a function comparing polar angles
08:08:10 <linduxed> the first point in the list will have the lowest Y coordinate
08:08:20 <merijn> linduxed: Then pass that function to sortBy :)
08:08:46 <matthiasgorgens> ozataman, do you know http://hackage.haskell.org/packages/archive/process/1.0.1.5/doc/html/System-Process.html ?
08:08:52 <linduxed> merijn: yeah that's the problem, i haven't used polar angles in i don't know how long
08:09:09 <merijn> linduxed: Ah, but that's more of a math and less of a haskell problem ;)
08:09:13 <merijn> Can't help you there :p
08:09:19 <linduxed> merijn: true
08:09:28 <linduxed> merijn: well, i'll try to find a solution
08:09:30 <ozataman> matthiasgorgens: ah, great - I hadn't thought of this. I think this could actually do
08:09:57 <matthiasgorgens> linduxed, try to transform you problem into some query about the type system.  (should be possible with curry-howard isomorphism.)
08:10:10 <matthiasgorgens> linduxed, then it's a haskell problem, and you can ask again.
08:10:29 <Saizan> edwardk: oh, the inverse requires Functor h
08:11:01 <ozataman> matthiasgorgens: thank you
08:11:08 <matthiasgorgens> you're welcome.
08:11:35 <edwardk> =)
08:12:01 <edwardk> so we have an embedding from Maybe a into Endo a
08:12:07 <edwardk> which is perfectly fine
08:12:27 <Saizan> yep
08:13:27 <Saizan> i wanted to know which was the adjunction that generated Maybe as a monad though, i guess it isn't an Hask -> Hask one
08:15:15 <quicksilver> well there are infinitely many adjunctions for which Maybe is the monad, Saizan
08:15:30 <ski> linduxed : `phase' gives you the polar angle for a complex number
08:15:32 <quicksilver> the Eilenberg-Moore (sp?) at one end and the Kleisli at the other, if I remember.
08:15:39 <Athas> Hm, in Parsec, how do I parse a string beginning with an upper-case character, that does not consist solely of upper-case characters?
08:16:08 <Athas> I have a solution that parses the string, then checks it and calls 'fail' if it's bad, but that results in bad error messages.
08:17:22 <augur> moin peeps
08:17:49 <Saizan> quicksilver: funny how i can fail to find one of infinitely many then
08:18:16 <quicksilver> Saizan: well there is no guarantee that any of them is into Hask, as you correctly suggest.
08:18:33 <quicksilver> certainly the two canonical constructions are definitely *not* in the same category.
08:25:01 <ski> (quicksilver : spelling is correct)
08:30:37 * hackagebot yesod-goodies 0.0.4.1.1 - A collection of various small helpers useful in any yesod application.  http://hackage.haskell.org/package/yesod-goodies-0.0.4.1.1 (PatrickBrisbin)
08:32:37 * hackagebot yesod-comments 0.3.3 - A generic comments interface for a Yesod application  http://hackage.haskell.org/package/yesod-comments-0.3.3 (PatrickBrisbin)
08:44:39 * hackagebot cblrepo 0.2.2 - Tool to maintain a database of CABAL packages and their dependencies  http://hackage.haskell.org/package/cblrepo-0.2.2 (MagnusTherning)
08:53:21 <nus> uhh, a tool to maintain a tool, now what's that?
08:53:47 <NihilistDandy> A whetstone?
08:53:47 <Jafet> A Thoreau quote
08:58:47 <nus> oh, it's a "Helper tool for people maintaining a set of CABAL packages for their distribution."
09:02:24 <nus> type CblPkg = (String, (V.Version, [P.Dependency], Int)) ; type CblDB = [CblPkg]
09:07:41 <dylukes> What's the best way in haskell to represent a finite (in space) cellular automata, in a sort of multi-spoke environment?
09:08:06 <dylukes> comonads seem to be pretty elegant for the infinite 1D or infinite 2D cases, but I'm not sure about finite spaces.
09:11:24 <ski> dylukes : are you thinking of bounded or unbounded spaces ?
09:11:34 <dylukes> The system looks like a central cell,
09:11:43 <dylukes> with N radial spokes of length L.
09:12:01 <dylukes> not sure what the right terminology is.
09:12:22 <dylukes> Anyhow, it has a set of agents moving around in it, which affect a pair of pheromone values of each cell.
09:12:29 <dylukes> So all movements at each time step must be parallel to each other.
09:16:24 <ski> hm, so you're moving around in an irregular-like graph ?
09:19:53 * hackagebot xmlhtml 0.1.5.2 - XML parser and renderer with HTML 5 quirks mode  http://hackage.haskell.org/package/xmlhtml-0.1.5.2 (DougBeardsley)
09:20:25 <hpaste> “Ben Gamari” pasted “Monadic difficulties” at http://hpaste.org/48594
09:20:49 <djahandarie> bgamari, at least it's not called GC churn this time :)
09:20:50 <bgamari> Anyone remember this code :p http://hpaste.org/48594
09:21:26 <bgamari> The challenge is to use Data.Binary to output the timestamps instead of show
09:22:21 <bgamari> The trouble is it seems I might lose the "strictness" that print currently gives me
09:22:46 <bgamari> Currently I iterate over times writing out both channels times
09:22:56 <bgamari> I can't think of a way to do this with Data.Binary.Put
09:23:47 <sm> morning all
09:24:21 <sm> if I string maybe values together with >>, I get Nothing if any are Nothing. Is there a concise way to get the first Just if any are Just ?
09:24:41 <Jafet> mappend?
09:26:03 <bgamari> djahandarie: Heh, I suppose it could have just as easily been called GC churn given the above
09:26:20 <sm> Jafet: hm, I'm not sure how to use it
09:26:35 <mightybyte> sm: Look at First from Data.Monoid
09:26:37 <sm> Nothing `mappend` Just 1 `mappend` Just 2 :: Maybe Int , say
09:26:51 <djahandarie> bgamari, I'm not familiar with Data.Binary and a little too burned to look at any docs right now :(
09:27:12 <sm> that sounds perfect, thanks!
09:27:13 <azaq23> > mapM First [Just 10, Just 4, Nothing]
09:27:14 <Twey> > Nothing `mappend` Just 1 `mappend` Just 2
09:27:16 <lambdabot>   No instance for (GHC.Base.Monad Data.Monoid.First)
09:27:18 <lambdabot>   Ambiguous type variable `a' in the constraints:
09:27:20 <lambdabot>    arising from a use of...
09:27:22 <lambdabot>    `Data.Monoid.Monoid a'
09:27:22 <Twey> > Nothing `mappend` Just 1 `mappend` Just 2 :: Maybe Int
09:27:24 <lambdabot>  ...
09:27:26 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
09:27:28 <lambdabot>    arising from a use of...
09:27:58 <Jafet> @instances Monoid
09:27:59 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
09:28:17 <Jafet> Guess I was wrong about the constaints
09:28:21 <azaq23> > mconcat $ map First [Just 10, Nothing, Just 2]
09:28:22 <lambdabot>   First {getFirst = Just 10}
09:28:30 <azaq23> > mconcat $ map Last [Just 10, Nothing, Just 2]
09:28:31 <lambdabot>   Last {getLast = Just 2}
09:29:10 <Jafet> For all that syntactic overhead, one might as well use listToMaybe . catMaybes
09:29:51 <benmachine> did no-one mention msum or mplus
09:30:10 <bgamari> djahandarie: heh, no worries. I understand
09:30:10 <benmachine> > getFirst $ Data.Foldable.foldMap First [Nothing, Just 'a', Just 'b']
09:30:11 <lambdabot>   Just 'a'
09:30:19 <benmachine> > msum [Nothing, Just 'a', Just 'b']
09:30:20 <lambdabot>   Just 'a'
09:30:37 <bgamari> djahandarie: It's been a long week
09:30:52 <benmachine> :t asum
09:30:53 <lambdabot> Not in scope: `asum'
09:30:56 <benmachine> hm.
09:31:36 <benmachine> kinda surprised there isn't a nice name for foldr (<|>) empty
09:31:40 <ion> > ala First foldMap [Nothing, Just 'a', Just 'b']
09:31:41 <lambdabot>   Not in scope: `foldMap'
09:31:48 <ion> > ala First Data.Foldable.foldMap [Nothing, Just 'a', Just 'b']
09:31:49 <lambdabot>   Just 'a'
09:32:08 <Jafet> :t ala
09:32:09 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
09:32:24 <sm> phew.. head spinning
09:32:26 <djahandarie> I really wish that type signature was cleaner.
09:32:39 <sm> msum looks like the winner, thanks all
09:41:13 * hackagebot mongoDB 0.10.0 - MongoDB driver  http://hackage.haskell.org/package/mongoDB-0.10.0 (TonyHannan)
09:42:18 <ezyang> checking for path to top of build tree... utils/ghc-pwd/dist/build/tmp/ghc-pwd: /lib64/libc.so.6: version `GLIBC_2.9' not found (required by utils/ghc-pwd/dist/build/tmp/ghc-pwd)
09:42:23 <ezyang> Does this mean my glibc is too old?
09:44:29 <thoughtpolice> ezyang: i had an issue like this at one point long ago, but I believe it was due to me having a slightly broke libc6 install on my debian machine (i had part of the dev libraries upgraded but not other parts.) perhaps just check your package installs for consistency?
09:47:44 <ezyang> Blah. I don't have root on this machine, so that may be a little difficult.
09:48:48 <kmc> ezyang, get root ;)
09:49:29 <ezyang> It's a netbooted machine, so that's a little tough :-)
09:49:53 <djahandarie> "Someone hacked our server!!! And... installed Haskell libraries?"
09:50:29 <kmc> ezyang, on the contrary.  TFTP is unauthenticated, isn't it?
09:51:13 <Jafet> djahandarie: must be one of those postmodern surrealist hackers
09:59:05 <bgamari> What is the best way to run a list of State monads and extract the result of the last in the list?
09:59:59 <kmc> nitpick: you can't have a "list of monads".  a monad is a type
10:00:02 <kmc> (State Int) is a monad
10:00:08 <kmc> a value of that type is an "action"
10:00:13 <danharaj> Isn't it that State is the monad?
10:00:17 <kmc> (or rather, a value of type (State Int a) for some a)
10:00:23 <Jafet> :t sequence
10:00:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
10:00:26 <danharaj> ah right State takes two types
10:00:27 <danharaj> derp.
10:00:42 <kmc> :t runState ?s . sequence
10:00:42 <bgamari> kmc: fair enough
10:00:43 <lambdabot> forall a (m :: * -> *) a1. (?s::State (m [a1]) a, Monad m) => [m a1] -> (a, m [a1])
10:00:53 <bgamari> One of these days I'll finally get this through my skull
10:00:55 <azaq23> last $ mapM runState states maybe?
10:01:09 <azaq23> wait no
10:01:12 <kmc> anyway 'sequence' is the place to look
10:01:21 <bgamari> I saw sequence
10:01:27 <kmc> > fmap last . sequence
10:01:28 <lambdabot>   Overlapping instances for GHC.Show.Show ([f a] -> f a)
10:01:28 <lambdabot>    arising from a us...
10:01:30 <kmc> :t fmap last . sequence
10:01:31 <bgamari> but it produces all of the intermediate results as well
10:01:31 <lambdabot> forall a (f :: * -> *). (Functor f, Monad f) => [f a] -> f a
10:01:34 <kmc> ^^^^
10:01:42 <bgamari> alright
10:01:48 <djahandarie> No, sequenceA is! sequence is using the wrong typeclass!
10:01:52 <kmc> > fmap last . sequence $ [Just 3, Just 4, Just 5]
10:01:54 <lambdabot>   Just 5
10:01:56 <kmc> > fmap last . sequence $ [Just 3, Nothing, Just 5]
10:01:58 <lambdabot>   Nothing
10:02:12 <bgamari> I suppose I'll give it a try
10:03:35 <bgamari> Bah, just as I thought it's chewing through memory again
10:04:08 <Jafet> State isn't magical
10:04:23 <Jafet> ST is a bit magical, but you're probably going about this the wrong way
10:04:34 <djahandarie> (More generally, nothing but IO and ST are magical)
10:04:38 <kmc> and STM!
10:04:48 <kmc> State is just sugar for functional parameter passing
10:04:50 <kmc> @unmtl State s a
10:04:50 <lambdabot> s -> (a, s)
10:05:16 <kmc> @djinn (s -> (a, s)) -> (a -> (s -> (b, s))) -> (s -> (b, s))
10:05:16 <lambdabot> f a b c =
10:05:17 <lambdabot>     case a c of
10:05:17 <lambdabot>     (d, e) -> b d e
10:05:24 <Jafet> Perhaps a few ($!) would help
10:05:28 <kmc> @djinn a -> (s -> (a, s))
10:05:28 <lambdabot> f a b = (a, b)
10:05:34 <kmc> djinn just derived the implementation of State :)
10:06:29 <ion> :-)
10:06:34 <kmc> i suppose we also need:
10:06:41 <kmc> @djinn (a -> b) -> (a -> (s, a)) -> (b -> (s, b))
10:06:42 <lambdabot> -- f cannot be realized.
10:07:09 <kmc> screw you djinn
10:07:09 <bgamari> kmc: How might one use two Data.Binary.Put actions in the same loop?
10:07:18 <bgamari> by loop I mean forM_
10:07:24 <kmc> foo >> bar
10:07:29 <kmc> maybe i don't understand the question
10:07:46 <bgamari> Yes, sorry, poor phrasing
10:08:07 <bgamari> Not helped by the fact that I don't really know what I want to do
10:08:11 <bgamari> but I don't think it's possible
10:08:19 <kmc> probably it is
10:08:23 <bgamari> I want to build two lazy bytestreams
10:08:39 <bgamari> You might remember this?
10:08:39 <bgamari> http://hpaste.org/48594
10:09:13 <bgamari> Currently I output both entries in times to different files using hPrint
10:09:33 <bgamari> However, let's say for instance I want to use Data.Binary.Put instead
10:10:57 <bgamari> the put* functions return an action which outputs a binary word to a buffer
10:11:04 <kmc> you can build up two lists of Put actions
10:11:07 <kmc> and then 'sequence' both of them
10:11:08 <bgamari> the difficulty here is I need to output to two different bummers
10:11:15 <bgamari> alright
10:11:18 <bgamari> let me try that
10:12:06 <kmc> bgamari, PutM is a silly monad.  you don't really get anything from the monad instance, because nobody ever uses a PutM action of type other than (PutM ())
10:12:26 <kmc> bgamari, so maybe use Data.Binary.Builder instead
10:12:29 <kmc> with its Monoid instance
10:12:49 <bgamari> kmc: Alright, perhaps that will be easier for me to wrap my head around anyways
10:13:06 <kmc> using 'sequence' on [Put] will be basically the same as using 'mconcat' on [Builder]
10:13:28 <bgamari> What exactly is the difference between a monoid and a group?
10:13:34 <kmc> monoids don't have to have inverses
10:13:38 <bgamari> Ahh
10:13:40 <kmc> a group is a monoid with inverses
10:13:52 <bgamari> Thanks
10:13:53 <kmc> (so, all groups are monoids)
10:13:54 <kmc> :)
10:16:08 <kmc> for some reason no 'Group' class has become popular in Haskell
10:16:30 <kmc> most of the 'popular' Monoids would not obviously fit
10:16:40 <dankna> I'm not sure a group is a programmatically useful concept
10:16:53 <copumpkin> dankna: undo!
10:16:58 <dankna> obviously it's mathematically useful
10:16:59 <copumpkin> commutative group = undo in any order!
10:17:01 <dankna> hmmmmm?. maybe!
10:17:11 <copumpkin> commutative monoid = accumulate in any order
10:17:22 <kmc> people would like to remake the numerical hierarchy along algebraic lines
10:17:36 <dankna> maybe we should
10:17:40 <dankna> I don't really like it that much as it stands
10:18:02 <kmc> numeric-prelude has the disadvantage that every type is named T and every class is named C
10:18:12 <dankna> heh ouch.
10:18:13 <dankna> that hurts.
10:18:30 <dankna> that's what happens when you let mathematicians near the keyboard :)
10:18:36 <kmc> dankna, or ML users
10:18:39 <dankna> indeed
10:19:47 <ion> convHungarian notation abbrFtw.
10:19:56 <kmc> haha
10:20:20 <dankna> yickAbbreviationsMakeMeStickMyTongueOutInDisdainSemicolonLongNamesAreBetter!
10:21:54 <kmc> needs more factory
10:22:41 <lysgaard> How can i profile my numbercrunching haskellprogram to see where there is improvement to be done, where the cpu spends most time etc?
10:22:52 <kmc> did you read the profiling chapters in RWH?
10:23:33 <lysgaard> kmc: Nope, I guess I should do that then ;)
10:24:06 <kmc> :)
10:24:14 <kmc> it's a good place to start, though by no means is it the last word on the subject
10:26:29 <benmachine> kmc: I've seen the thing where all types are T and all classes are C before, it drove me up the wall
10:26:51 <benmachine> I think it's a specific author
10:26:54 <kmc> yep
10:26:56 <kmc> it has some theoretical appeal
10:26:58 <gwern> @quote as.*long
10:26:58 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
10:27:02 <gwern> @quote as.long
10:27:02 <lambdabot> weitzman says: Sometimes it's ok to polish diningware with a hammer, as long as it gets the job done
10:27:07 <kmc> unfortunately it's incompatible with all the tools etc. people use
10:27:18 <benmachine> yes, haddock doesn't come out of it well :P
10:27:32 <benmachine> what's the theoretical appeal?
10:27:46 <kmc> don't repeat yourself
10:27:51 <benmachine> blink
10:28:07 <benmachine> elaborate
10:28:07 <kmc> if you «import qualified Data.Map as Map» then you have to say «Map.Map»
10:28:10 <benmachine> oh
10:28:15 <gwern> @remember AlanPerlis We will never run out of things to program as long as there is a single program around.
10:28:15 <lambdabot> Done.
10:28:18 <gwern> @flish
10:28:27 <benmachine> sure but if one person import qualified Data.Map as M
10:28:32 <benmachine> and one import Data.Map as Map
10:28:45 <dankna> I always do
10:28:56 <dankna> import Data.Map (Map) ; import qualified Data.Map as Map
10:29:04 <benmachine> yes, that is sensible too
10:29:04 <kmc> but that's repetition too ;P
10:29:10 <kmc> i just don't mind saying M.Map
10:29:24 <benmachine> kmc: I don't really think it's much repetition
10:29:38 <Jafet> Why are you even writing type names!?
10:30:00 <benmachine> Jafet: why are we even writing programs?!?
10:30:36 <Jafet> To feel good when they pass -Wall.
10:30:42 <dankna> I spoke to someone yesterday who thought programming was "specifying the problem in a form the computer can understand, so the compiler can solve it"
10:30:56 <kmc> that's the goal!
10:30:59 <dankna> indeed
10:31:01 <dankna> but we aren't there yet, hahaha
10:31:07 <kmc> to varying degrees
10:31:15 <kmc> Haskell programs can be very declarative
10:31:18 <kmc> logic programming even more so
10:31:24 <kmc> or programming with SMT solvers
10:31:24 <dankna> yeah.  well he wasn't a programmer at all, he literally thought all programming was logic programming.
10:32:00 <Jafet> Specifying the problem in a form for which some smart eggheads have written a compiler to solve it
10:32:24 <kmc> i really really like having an SMT solver as a library
10:32:25 <Nimatek> We've come a long way though.
10:32:32 <dankna> we have, yes
10:32:47 <Jafet> @hackage yices
10:32:47 <lambdabot> http://hackage.haskell.org/package/yices
10:32:57 <kmc> i use yices-easy
10:33:04 <kmc> but then dons wrote yices-painless which is supposed to be even nicer :)
10:33:39 <Jafet> Eventually computer programming will be like intercal then, I guess
10:33:50 <kmc> Haskell is a good host language for these kinds of things, if you don't want to go full-on and program in some logic / SMT language
10:33:51 <Jafet> DO PLEASE GOBBLEDYGOOK
10:34:32 <kmc> usually there is some munging of input to get the form the solver wants
10:34:45 <kmc> and i'm still more comfortable doing that with functional and imperative techniques
10:35:02 * wli is just trying to bracket minima.
10:55:25 <gwern> hm. why doesn't '/bin/tar --list suffixarray/0.0.2/suffixarray-0.0.2.tar.gz' do anything...
10:55:46 <kmc> do you need -f ?
10:55:57 <kmc> and -z?
10:56:26 <gwern> no, -tz doesn't do anythin, but -tf does
10:56:27 <gwern> hm
10:56:42 <kmc> tar tzf foo.tar.gz
10:56:47 <gwern> why on earth, oy vey
10:56:55 <kmc> well you have to say you want to read from a file
10:57:02 <kmc> otherwise the Tape ARchiver will read from the tape drive, of course!
10:57:21 <gwern> too bad there's no easy way to say 'extract files meeting this glob to stdout'
10:58:15 <hpaste> “Ben Gamari” pasted “And still more GC churn” at http://hpaste.org/48596
10:58:24 <gwern> -O to stdout, and --exclude options exist. but what's a PATTERN?
10:58:32 <bgamari> kmc: ^^^ Is this not what you intended or am I simply screwed?
10:58:40 <bgamari> It's leaking []s
10:59:07 <bgamari> but more importantly, it also seems to be accumulating ByteString buffers
10:59:46 <bgamari> Or rather, Builder objects
11:00:51 <gwern> /bin/tar --exclude="*.hs" -Oxf suffixarray/0.0.2/suffixarray-0.0.2.tar.gz sort of works. do shell globs have negation...
11:01:41 <Clint> depends on the shell
11:01:58 <gwern> well, I think tar has its own matching
11:05:33 <gwern> must be pretty simple. --exclude="*.[a-g,i-z][a-r,q-z]" will include .hs files, but --exclude="*.hs" will exclude them
11:07:23 <gwern> aha, I want the --wildcards option
11:07:40 <gwern> /bin/tar --wildcards "*.cabal" -Oxf suffixarray/0.0.2/suffixarray-0.0.2.tar.gz
11:07:46 <gwern> thanks for nothing tar man page
11:07:56 <gwern> could've mentioned that --wildcards is the dual to --exclude
11:08:49 <gwern> so once you've used cabal list and cabal fetch to populate your .cabal, you can cd there and run "find . -name "*.tar.gz" -exec tar --wildcards "*.cabal" -Oxf {} \;" to extract all the .cabals to stdout
11:08:52 <Jafet> The man page is the broad road that ensnares the foolish. The info manual is the superfluously difficult narrow mountain path to enlightenment
11:09:44 * gwern bows before Jafet. 2 pounds of source!
11:09:54 <Jafet> …okay, the info manual appears to be equally useless.
11:10:07 <gwern> I found enlightenment in http://www.gnu.org/software/tar/manual/html_section/wildcards.html
11:12:11 <Jafet> “Damn these acolytes; I'll be shortly sick to death of all this source.”
11:12:54 <nus> gwern, the dual is --no-wildcards (-:
11:26:10 <gwern> bleh, the output turned out to be pretty dirty when I turned on context
11:27:04 <gwern> 85k deps, 3137 packages, 27 deps on average
11:27:06 <gwern> seems high to me...
11:27:40 <NihilistDandy> Whoa
11:27:49 <Jafet> Recursively?
11:28:05 <gwern> Jafet: ?
11:28:41 <Jafet> How did you count dependencies? grepping cabal files?
11:28:46 <augur> functional programmers do it recursively!
11:29:06 <NihilistDandy> Functional programmers do it in the IO monad.
11:29:10 <gwern> Jafet: yeah
11:29:20 <kmc> functional programmers do it with penises
11:29:21 <gwern> find . -name "*.tar.gz" -exec tar --wildcards "*.cabal" -Oxf {} \;  | grep --context=1 "build-depends:" >> ~/depss
11:29:36 <gwern> then a bunch of filtering and editing in emacs
11:29:42 <augur> kmc: dont be vulgar
11:30:11 <Jafet> @vixen must functional programmers have penises?
11:30:11 <lambdabot> what's a program?
11:30:20 <augur> ahahaha lambdabot
11:30:26 <augur> edwardk1: beep boop
11:30:37 <edwardk1> me looks up
11:30:40 <augur> :o
11:30:46 <gwern> I really should learn how to parse cabal files
11:30:52 <augur> whoa, adium irc?
11:30:55 <augur> whats this now
11:31:01 <NihilistDandy> Adium's had IRC forever
11:31:04 <augur> crazy
11:31:11 <augur> i use limechat
11:31:20 <NihilistDandy> It's not bad, really, but I stopped using it eventually
11:31:33 <NihilistDandy> I use Textual pointed at an irssi bouncer
11:31:45 <dankna> I believe the big problem with IRC is that multi-user chat needs a wider window than single-user chat because of the greater volume of text
11:31:49 <edwardk> i stay signed in to a bunch of old messaging services, to talk to folks who either haven't moved or only know me through one thing or other.
11:31:58 <dankna> edwardk: I do the same, yeah
11:32:05 <dankna> so programs that attempt to unify MUC and SUC are in trouble
11:32:17 <edwardk> and adium works well enough, if i don't let the scrollbacks go too long
11:32:20 <augur> well i like my limechat
11:32:32 <dankna> yeah
11:33:32 <augur> edwardk: how do you become unaddicted to FP/CT?
11:33:50 <augur> i have other things i want to work on and all i can do is think of how i could be reading about categorical logic :(
11:34:30 <Jafet> Lucky soul
11:34:35 <Jafet> I do feel for your body though
11:34:35 <NihilistDandy> augur: I don't think you do. Functional reasoning has started leaking into my non-programming life
11:35:18 <thoughtpolice> x = x + 1 // i just made you cry i bet
11:35:35 <kmc> thoughtpolice, defining ω for inductive naturals i see
11:35:46 <edwardk> i had written a javascript compiler in javascript (to do easier continuation based programming) back in 2005-2006google then game out with the google web toolkit, but i knew a lot of javascript. i decided to write a compiler for ecmascript 3 which was being ratified at the time in another language. perl 6 and ecmascript 3 were very similar. the working perl 6 was pugs, written in haskell
11:35:51 <kmc> _+1 : Nat -> Nat
11:36:02 <Jafet> s = Succ s
11:36:15 <kmc> > fix (In . Just)
11:36:17 <lambdabot>   In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (J...
11:36:18 <edwardk> the transition from working on the javascript in javascript compiler to writing another one was just because google's web toolkit was a better idea than mine ;)
11:36:36 <copumpkin> kmc: coinductive naturals!
11:36:55 <kmc> i guess so copumpkin
11:37:04 * kmc not leet enuf :/
11:37:05 <edwardk> copumpkin: one point compactification for the win
11:37:08 <thoughtpolice> fixed points are the breaking news bulletins today, huh
11:37:16 <augur> on speaking of, is there a good way to step a bit of haskell code?
11:37:28 <Jafet> I support fixing injustice
11:37:31 <augur> without using break points, i mean
11:38:02 <edwardk> augur: anyways, once i found haskell there wasn't much turning back. i'd been playing with toy languages for 15 years, and haskell was the first time in a long time i felt like i'd learned something. so i went nuts obsessing over haskell, substructural type systems, dependent types, etc.
11:38:21 <edwardk> it was a lot nicer way to reason about the world than farting around with hoare triples, etc. in an imperative setting
11:38:23 <augur> i feel the same about agda
11:38:34 <augur> once i got dependent types, i cant think straight in normal types
11:39:00 <edwardk> my interest in category theory camee about because i'm i guess formally a computational geometer, and category theory has nice dualities like the projective geometries i love so much.
11:39:04 <augur> oh dependent types, how i love thee
11:39:13 <augur> a formal geometer
11:39:14 <augur> crazy
11:39:19 <augur> get a real job you bum!
11:39:25 <kmc> dam hippies
11:39:26 <augur> playing with triangles all the time
11:39:28 <kmc> get off my lawn
11:39:31 <edwardk> i have one =P
11:39:36 <kmc> smoking pot and trisecting angles
11:39:51 <edwardk> and triangles pay well when you blit them on the screen faster than the next guy ;)
11:39:55 <augur> who needs a trisected angle
11:40:05 <augur> in my day all we had were bisected angles and they were GOOD ENOUGH FOR US
11:40:26 <kmc> augur, yeah, not having first-class types is like not having first-class functions :/
11:40:36 <augur> kmc: so true :(
11:40:57 <edwardk> my first thesis's advisor was a differential geometer, and that thesis was on a trick i'd employed back in the 90s to make fast computational visibility calculations
11:41:11 <augur> wossat now
11:41:18 <augur> computational visibility?
11:41:28 <edwardk> visible surface determination for 3d game stuff
11:41:34 <edwardk> like quake's PVS
11:41:37 <augur> oo i see
11:42:00 <augur> like does it need to be rendered or is it out of view and can be ignored
11:42:03 <augur> hm!
11:42:06 <edwardk> i used to sell a fast vis solution that could take those multi-hour vis calculations that those kind of games used in pre-production and reduce them to seconds while making them more accurate
11:42:24 <edwardk> augur: exactly
11:42:38 <augur> you were like 25 at the oldest when you did that
11:42:50 <augur> i feel so inadequate :(
11:42:57 <augur> im 25 and havent done anything cool like that
11:42:59 <edwardk> the main effect was that i could toss around hundreds of thousands of polygons rather than 10s, and reduced my memory footprint because i could calculate it all on the fly
11:43:13 <edwardk> 20ish actually
11:43:17 <augur> T_T
11:43:26 * augur jumps out the window
11:43:29 <Jafet> Blame modern education.
11:43:51 <augur> Jafet: i blame the shoddy state of linguistics as a whole
11:44:17 * earthy suddenly feels old :P
11:44:22 <edwardk> i avoided the whole formal education thing until it was clear i wasn't going to get any farther auto-didactically, and that no one would hire a CTO who didn't have a formal education on the downside of the dot-com crash
11:44:53 <edwardk> then i hid in academia
11:44:56 <augur> eugh boom days
11:44:57 <augur> crazy
11:45:09 <earthy> smart move, that
11:45:21 <kmc> edwardk, how did it become clear you wouldn't get further on your own?
11:46:08 <edwardk> kmc: mostly coz i couldn't make heads or tails out of measure theory, and i was running into the limits of what i could grok from reading random papers on the internet
11:46:37 <Eduard_Munteanu> How's the random educational institution better than that?
11:47:02 <Jafet> It subsumes random papers on the internet, at least
11:47:03 <augur> i feel i would grok CT better if i had a class in it. a lot of the proofs that books assign are just confusing to me
11:47:35 <thoughtpolice> edwardk: do you think you would feel the same today, given the internets? i ask because i'm 21, and i wonder about how far my autodidactism will get me, but at the same time, there is probably a bit more quality free stuff to go off of these days then back then
11:47:51 <edwardk> Eduard_Munteanu: because i went to college and a year and a half of total immersion later, I had an M.A. in math and had been in math and computer science classes pretty much all day every day for that whole time. great way to round out the random background i'd had prior to that point
11:47:54 <Eduard_Munteanu> augur: maybe it's the book at fault
11:47:56 <augur> i remember taking linear algebra and having it all just resolve in front of my eyes once i saw the proofs being reasoned out
11:48:02 <Jafet> And yes, there are things about traditional education that are probably missing from internets
11:48:24 <augur> Eduard_Munteanu: nah, im just a semi-visual learner. i need to see examples of the processes involved before i can really grok it
11:48:43 <augur> which is why SICP was great for me, because watching those videos, they'd routinely manually evaluate an expression
11:48:53 <edwardk> thoughtpolice: yeah. when i hire people i tend to gravitate towards hiring people who know something i don't, so i can assimilate their skills. college for me was a lot like that, but there i hate professors i could do that to =)
11:48:58 <augur> or talk about the logic behind some definition or something
11:49:30 <edwardk> thoughtpolice: you can often hack your own trail through the weeds, but it is nice when someone can just point you to the path
11:50:05 <augur> thats actually why im looking for a stepper for haskell, because i figure i could grok backwards state better if i could step through some expressions
11:50:05 <Eduard_Munteanu> IMHO many such books, lecture notes and textbooks simply don't cover stuff in sufficient detail. I think worked examples and complete, formal proofs are really nice to have.
11:50:16 <edwardk> i would like to go back and just go back to collecting masters degrees some day
11:50:21 <augur> i dont trust my abilities to eval by hand
11:50:24 <Jafet> @where stepeval
11:50:24 <lambdabot> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
11:50:35 <augur> Jafet: :O
11:50:41 <gwern> oh, hey, parsing cabal files isn't that hard
11:50:44 <gwern> I should've done this long ago
11:51:05 <Phyx-> gwern: yeah, I ditched doing it via Cabal long ago too
11:51:15 <Phyx-> writing my own parser seems to be build easier
11:51:17 <Eduard_Munteanu> Waving a "proof by induction" isn't really great if you've only provided 1 example before.
11:51:33 <augur> Jafet: doesnt let you do arbitrary things tho it seems :(
11:51:52 <augur> i'd have to download it i guess
11:52:16 <Jafet> It implements a rather small subset of Haskell.
11:52:22 <Jafet> @quote oasis
11:52:23 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
11:52:31 <edwardk> Eduard_Munteanu: that is why i like classes. i may be a bit annoying to be in a class alongside, because i more or less try to get the most i can out of the lecture, even if that means asking a lot of questions, but at least the professor feels appreciated (if they have anything interesting to say that is)
11:52:32 <Eduard_Munteanu> The nicest thing about programming is you can just look up some code and see how it works.
11:52:39 <Eduard_Munteanu> Then you can add your stuff there.
11:52:55 <augur> Jafet: trace?
11:53:08 <Jafet> @index trace
11:53:09 <lambdabot> Debug.Trace
11:54:33 <Eduard_Munteanu> edwardk: I kinda like the seminars more, especially if it's just time for students to ask questions (i.e. not necessarily solving some set of problems the teacher came up with)
11:54:48 <Jafet> trace is great, but unfortunately it doesn't love ST
11:54:52 <Eduard_Munteanu> I really believe the students should come there prepared.
11:54:56 <kmc> how so Jafet?
11:55:39 <Jafet> Can't grab stuff out of ST in a pretty way, it seems
11:56:14 <augur> oh, Jafet, Debug.Trace is just a way to output stuff while running code?
11:56:53 <Jafet> I remember writing something like traceShow (unsafePerformIO . unsafeSTToIO . unsafeFreeze $ arr)
11:56:54 <augur> yeah i just want a stepper is all
11:57:41 <Eduard_Munteanu> edwardk: btw, do you teach?
11:58:26 <edwardk> Eduard_Munteanu: not currently. we run a little functional programming/category theory class here at work on Fridays, though.
11:59:01 <edwardk> that has been mostly dolio and copumpkin lately though =)
11:59:10 <Eduard_Munteanu> Heh.
11:59:17 <augur> edwardk: you should webcast this class
11:59:25 <edwardk> i did do the adjunct lecturer thing for a while though
11:59:25 <NihilistDandy> I'd watch it
12:00:00 <edwardk> we're currently building on about 6-7 months worth of assumed class content. ;)
12:00:00 <augur> i think everything that can be webcast should be
12:00:23 <edwardk> i do need to grab the material from the dsl workshop at mcmaster though
12:00:43 <edwardk> i have video i just haven't brought myself to mine through 12 hours of video to see what can be cleaned up for youtube
12:00:51 <gwern> wonder if this parsing would go faster if I had compiled it...
12:01:40 <edwardk> i was asked if i'd like to teach a course on category theory for computer scientists over at tufts, so this has been a pretty good dry run at the content
12:01:53 <edwardk> if i do decide to act on that i'll try to get permission to webcast it
12:02:30 * Eduard_Munteanu would actually be happier if #haskell people wrote a book on this crazy stuff :)
12:03:19 <dylukes> I think we need a "#haskell Preliminaries" book.
12:03:25 <dylukes> With an introduction to CT, Topology, etc
12:03:37 <Eduard_Munteanu> Well, yeah, that'd be a starting point.
12:03:47 <edwardk> i was contacted by a publisher, but i think a general purpose haskell book that taught in a manner suitable to a classroom, and which ended where the user would be competent to write haskell as it is used in the real world would be more useful than a category theory in haskell text book that would sell 3 dozen copies
12:03:54 <Eduard_Munteanu> Then we could have an AT"#haskell Preliminaries" :)
12:04:22 <dylukes> This room really makes me feel like I don't know anythng.
12:04:26 <dylukes> And also "where to start D:"
12:04:51 <Eduard_Munteanu> Maybe we could pledge and then it could be released in electronic form exclusively?
12:05:21 <Eduard_Munteanu> That should be a bit more cost-effective + it'd go free.
12:06:01 <NihilistDandy> I wish Craft 3e would show up in the US at a less absurd price :/
12:06:29 <edwardk> clearly we need "semigroupoid theory for the working agda programmer"
12:06:32 <NihilistDandy> Oh, actually, they've come down pretty significantly
12:07:41 <bgamari> kmc: It seems I've reproduced my initial memory explosion issues
12:08:11 <bgamari> I'm not entirely sure why
12:08:13 <NihilistDandy> edwardk: Γearn you some ∀gda?
12:08:21 <dylukes> NihilistDandy: haha.
12:08:25 <edwardk> hahaha
12:08:26 <dylukes> wait no...
12:08:27 <augur> edwardk, Eduard_Munteanu: any topics i should add to my haskell/fp topic list?
12:08:28 <dylukes> it'd have to be
12:08:34 <Eduard_Munteanu> @elite Γearn you some ∀gda
12:08:34 <lambdabot> Γ34rn joo $0ME ∀GDa
12:08:43 <NihilistDandy> Clearly
12:08:43 <augur> NihilistDandy: gamma? wtf is the gamma for :|
12:08:52 <Eduard_Munteanu> Inverted L
12:08:55 <augur> yeah but
12:09:07 <Eduard_Munteanu> Yeah it's not really the same thing
12:09:07 <augur> it doesnt relate to agda much
12:09:11 <augur> you'd to better with an \ell
12:09:37 <augur> and use a \Sigma in place of the whole word "some"
12:09:41 <edwardk> the e should be existential and the s in some should be a Sigma ;)
12:10:06 <NihilistDandy> Mostly due to this: http://boegel.kejo.be/ELIS//haskell-blah/edwardk.png
12:10:14 <augur> ahahaha
12:10:55 <edwardk> the funny thing is that the observant might notice a mistake on the whiteboard.
12:11:05 <dylukes> Γ∋∀ℝℕ Ɣ⊕∪ Σ⊗μ∌ Agda
12:11:14 <augur> thats no whiteboard
12:11:25 <edwardk> blackboard =P
12:11:37 <augur> edwardk: you mean how its a \Lambda instead of a \lambda?
12:11:44 <NihilistDandy> The mistake is that he colored the whiteboard all black
12:12:19 <augur> and the extra turnstile in the abstraction rule
12:12:22 <NihilistDandy> Nice use of negative space
12:12:32 <edwardk> yeah
12:12:39 <augur> TWO mistakes!
12:13:02 <augur> ive never liked the use of \x : s notation
12:13:10 <augur> surely \x.M : s -> t says that well enough
12:13:16 <edwardk> and actually that is \lambda, but at that resolution you can't tell
12:13:28 <augur> o
12:16:53 <Eduard_Munteanu> augur: dunno, I'm not sure what the intended audience wants to do with Haskell. Maybe you could just summarize LYAH in a more mathy-oriented style.
12:17:10 <Eduard_Munteanu> Or maybe look at Wikibooks for some inspirations, that seems to cover some advanced topics quite well.
12:17:19 <augur> ill check the wikibooks
12:17:34 <augur> i dont like lyah's style for this sort of thing
12:17:46 <Eduard_Munteanu> (Wikibooks might not be friendly to the beginner but I noticed it covers some theoretical aspects quite nicely)
12:18:00 <Eduard_Munteanu> Yeah.
12:19:23 <Eduard_Munteanu> (Zippers come to mind on that.)
12:20:03 <djh_> I thougt the monads section on Wikibooks was pretty good
12:20:04 <augur> zippers are something i should talk about, yes, thats a good topic
12:20:21 <djh_> there's a few chapters missing from it in the middle though when they talk about monadic parsers
12:21:18 <dylukes> So, can anyone answer about that comonad question I had earlier?
12:21:28 <dylukes> specifically, if they could be used for FINITE spaces.
12:21:35 <dylukes> for a cellular automata type thing.
12:21:38 <edwardk> you had a comonad question?
12:21:48 <Eduard_Munteanu> dylukes: sure
12:21:57 <dylukes> could someone show me an example ^^;?
12:22:04 <edwardk> sure
12:22:09 <dylukes> In my case, the system is roughly as follows
12:22:14 <dylukes> each cell has some amount of pheromone on it
12:22:16 <edwardk> look at the Pointer comonad in comonad-extras
12:22:22 <dylukes> ah but,
12:22:25 <dylukes> theres a central node,
12:22:29 <dylukes> and then N spokes coming out
12:22:35 <dylukes> with a special node at the end of each one
12:22:35 <edwardk> okay
12:22:37 <dylukes> (of length :)
12:22:39 <dylukes> L*
12:22:50 <dylukes> anyhow, the pheromone dictates the behavior.
12:22:58 <dylukes> …by weighting a random selection.
12:23:00 <edwardk> can you describe the coordinates with some ADT?
12:23:10 <dylukes> I also need to have random number stuff in there.
12:23:23 <dylukes> I'd done it before as more of a linked list type thing, in C.
12:23:26 <edwardk> also fine, you can automent your comonad with Supply
12:23:39 <edwardk> er augment
12:23:57 <Eduard_Munteanu> You could have multiple lists in your zipepr
12:24:00 <dylukes> so, could you show me a simple example of this?
12:24:12 <dylukes> I have no idea where to start, and well, ghc isn't working amt
12:24:16 <dylukes> but I'd love something to read.
12:24:21 <edwardk> so your automaton lives on a plus shaped grid?
12:24:28 <dylukes> no
12:24:31 <dylukes> let me explain better.
12:24:37 <dylukes> So theres a central node, which is the colony.
12:24:39 <edwardk> then i completely misparsed you =)
12:24:42 <dylukes> and then say, 100 ants
12:24:45 <edwardk> okay
12:24:53 <dylukes> there are N spokes (currently I use 2 or 3),
12:25:03 <dylukes> each consisting of L-1 nodes, followed by ta food source node.
12:25:04 <edwardk> define spokes
12:25:10 <dylukes> lists radiating outwards.
12:25:18 <Eduard_Munteanu> What's the "topology" of your "world"?
12:25:21 <dylukes> I have no clue.
12:25:26 <dylukes> I'm not a topologist.
12:25:29 <Eduard_Munteanu> Is it a 2D grid?
12:25:36 <edwardk> they can only walk straight out on one of these spokes with no interconnections?
12:25:36 <dylukes> No.
12:25:43 <dylukes> It's closer to a finite polar system.
12:25:58 <dylukes> With a discrete set of R and theta coordinates.
12:26:02 <edwardk> to switch spokes do they have to go home then head back out?
12:26:03 <dylukes> edwardk: yep.
12:26:04 <dylukes> Yes.
12:26:14 <Eduard_Munteanu> Oh.
12:26:26 <edwardk> okay.
12:26:39 <Eduard_Munteanu> So it basically looks like a hedgehog? :)
12:26:54 <edwardk> and they can spray a pheromone or move or something? and cells need to remember their pheromones?
12:27:02 <dylukes> edwardk: right.
12:27:09 <dylukes> Basically, each ant at some time step does the following:
12:27:15 <edwardk> and i presume that all ants act simultaneously within a timestep?
12:27:17 <dylukes> yes
12:27:19 <dylukes> If it does NOT have food,
12:27:29 <edwardk> and if it does?
12:27:33 <dylukes> then it deposits exploration pheromone if the foraging pheromone is below a threshold,
12:27:39 <dylukes> and then randomly chooses between the next and previous cell,
12:27:46 <dylukes> based on weighted random number generation
12:27:53 <dylukes> it also has a bias to move outwards
12:28:03 <dylukes> once it gets food, it moves back towards the center with no randomness
12:28:08 <dylukes> depositing foraging pheromone at each step.
12:28:19 <dylukes> food sources have infinite attractiveness
12:28:24 <dylukes> colony has a pheromone value of "1"
12:28:28 <edwardk> personally i think the comonad doesn't add any real expository value here
12:28:33 <Eduard_Munteanu> Moving ants from one cell to another seems quirky with the usual automata comonad.
12:28:37 <dylukes> Well, I haven't found a way to express it.
12:28:48 <dylukes> perhaps comonads aren't  the right way at all
12:29:04 <dylukes> whoops
12:30:04 <edwardk> the problem is you have agents on a field, rather than a field where each cell changes based on the contents of its neighbors
12:30:05 <edwardk> the latter is a nicer cellular automaton comonad
12:30:10 <dylukes> right.
12:30:17 <dylukes> So, what would the best way to represent this be then?
12:30:19 <dylukes> functionally I mean.
12:30:28 <dylukes> I want to try to represent it without resorting to just a bunch of ST/IO
12:30:39 <Eduard_Munteanu> If you have each cell as a pair (x, y), then you could move ants in two steps. First update y, then the next step looks at y and updates x (the actual interesting information).
12:30:55 <edwardk> taking the average of my 4 neighbors makes a cheesy 1 pass blur. or checking how many neighbors i have and evaluating the life algorithm, etc.
12:30:55 <edwardk> those make nice comonadic cellular automata
12:31:06 <edwardk> the ants though, they act like a big bag of cursors into the world
12:31:11 <theVoid> :info unsafePerformIO
12:31:14 <theVoid> :info unsafePerformIO@
12:31:18 <Eduard_Munteanu> Yeah, they're more suitable to make convolutions, rather than that.
12:31:24 <theVoid> @:info unsafePerformIO
12:31:24 <lambdabot> Unknown command, try @list
12:31:32 <theVoid> @:type unsafePerformIO
12:31:33 <lambdabot> Not in scope: `unsafePerformIO'
12:31:58 <dylukes> I should really write out the formal rules.
12:32:05 <edwardk> you could encode them, but you'll likely find that the ants couldn't be made to die nicely, or that you repeat the same calculation over and over in adjacent cells to avoid accidentally cloning ants, etc.
12:32:19 <dylukes> mm.
12:32:41 <edwardk> on the other hand, you could do a pretty cheesy stateful encoding
12:33:19 <theVoid> @:info >=>
12:33:19 <lambdabot> Unknown command, try @list
12:33:25 <theVoid> @:type >=>
12:33:26 <lambdabot> parse error on input `>=>'
12:33:33 <edwardk> @type (>=>)
12:33:34 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
12:33:34 <Eduard_Munteanu> @type (>=>)
12:33:35 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
12:33:43 <dylukes> I wish I could encode it *not* state fully though
12:33:43 <dylukes> :\
12:34:30 <edwardk> well, you can move a little away from it by giving each ant an indexed state comonad that it uses to make its decisions. ;)
12:35:02 <edwardk> something you can then take a free monad over and have the ants issue commands like that
12:36:48 <edwardk> data Step a where Excrete :: Pheromone -> a -> Step (); In :: a -> Step (); Out :: a -> Step (); Sniff :: (Scent -> a) -> Step (); ...
12:37:28 <edwardk> then type Ant = Free Step =)
12:38:01 <edwardk> and you can treat them all like asymmetric coroutines that you step once every cycle
12:38:22 <Eduard_Munteanu> x =>> decideWhereAntNeedsToGo =>> moveAnts =>> rinseAndRepeat
12:38:31 <Eduard_Munteanu> This would be the hackish way.
12:39:13 <edwardk> (some of those Steps can of course be made free)
12:40:41 <Eduard_Munteanu> Where each cell is a pair (AntInfo, SomeStateDescibingActions); the first action updates snd of that, the second updates fst of that.
12:41:58 <Eduard_Munteanu> data SomeStateDescribingActions = StayHere | Move Direction
12:42:56 <augur> uh
12:43:01 <augur> im pretty sure ants arent monadic :|
12:43:02 <roconnor> how do I show a Word8 using 2 hex characters?
12:43:11 <augur> i think theyre insectoidal
12:43:11 <Eduard_Munteanu> augur: comonadic, even :D
12:43:11 <augur> :|
12:43:20 <Eduard_Munteanu> Heh.
12:43:34 <Eduard_Munteanu> roconnor: hrm... printf?
12:43:35 <augur> insectoids are when you have bugs in your monoid code
12:43:36 <augur> :D
12:43:40 <copumpkin> yeah, I'd use printf
12:43:47 <roconnor> sounds kinda heavyweight
12:44:05 * roconnor searches for printf
12:44:13 <dankna> roconnor: I've always done it the hard way, by using Numeric.showHex and zero-filling by hand
12:44:21 <roconnor> ya
12:44:27 <copumpkin> > printf "%02x" (0x34 :: Word8) :: String
12:44:28 <lambdabot>   "34"
12:44:30 <roconnor> metoo
12:44:38 <Eduard_Munteanu> You could use bitwise ops to do it yourself I suppose, along with Enum.
12:46:24 <roconnor> > toDigit 15
12:46:25 <lambdabot>   Not in scope: `toDigit'
12:46:31 <roconnor> > digit 15
12:46:32 <lambdabot>   Not in scope: `digit'
12:46:53 <mauke> > intToDigit 15
12:46:53 <Eduard_Munteanu> @hoogle toDigit
12:46:54 <lambdabot>   'f'
12:46:54 <lambdabot> Numeric floatToDigits :: RealFloat a => Integer -> a -> ([Int], Int)
12:46:54 <lambdabot> Data.Char intToDigit :: Int -> Char
12:49:20 <roconnor> showHex w = [Char.intToDigit (shiftR w 4), Char.intToDigit (0x0f .&. w)]
12:50:08 <copumpkin> roconnor: pfff
12:54:46 <edwardk> hrmm, does anyone know any decent references for anything on constructive probability theory?
12:55:42 <roconnor> edwardk: I always felt that Jaynes reads like he wants to be a constructivist.
12:56:07 <roconnor> refusing to take limits and whatnot
12:56:41 <edwardk> roconnor: basically what i'm looking for is the closest analogue to a constructive sigma algebra and the consequences of not being closed over countable intersection/union, only finite etc.
12:56:44 <roconnor> edwardk: oh wait, did you want probablity theory or statistics?
12:56:50 <roconnor> ah
12:56:54 <roconnor> probability theory
12:56:56 <roconnor> nevermind then
12:57:03 <edwardk> yeah honest to goodness probability =)
12:57:22 <mercury^> edwardk: I don't think you get very far if you take the usual axioms for sigma algebras and demand everything to be constructive.
12:57:34 <edwardk> intuitionistic bayesianism doesn't have to give up additivity, etc.
12:58:03 <edwardk> mercury^: i do if i view it as a programming construct. ;) adding the limits means i can't define an evaluator
12:58:28 <mercury^> Sigma additivity means that everything constructive has measure 0 if its singletons do.
12:59:01 <edwardk> sure. but you move to an event space defined primitively in terms of integrals instead.
12:59:24 <mercury^> Not sure what you mean there.
12:59:57 <mercury^> In any case, why not take an operator algebraic approach? I think that lends itself better to constructive implementations.
13:00:22 <edwardk> YK chan has some material on constructive probability theory. he had to redefine the way he built his sample and event spaces
13:00:37 <edwardk> mercury: references?
13:00:48 <NihilistDandy> I was going to point Chan out, but I figured you'd been there already
13:01:27 <mercury^> edwardk: http://www.alainconnes.org/docs/reality.pdf ; http://www.alainconnes.org/docs/book94bigpdf.pdf
13:02:05 <edwardk> i was mostly just trying to adapt some code that i had lying around for dealing with discrete probabilities, to dealing with additional measures on some weak sigma algebra-like thing that i can intersect and union finitely to deal with simple continuous random processes
13:02:57 <edwardk> then i can just make a few tweaks to the code here and there and the smallness of my event-space is what saves me from unbounded computation
13:03:10 <roconnor> I'm really finding Maybe () to be much nicer than Bool in many cases.
13:03:29 <mercury^> roconnor: in what way?
13:03:31 <Eduard_Munteanu> roconnor: why?
13:03:41 <roconnor> because Maybe is a monad
13:03:42 <Eduard_Munteanu> They're pretty much isomorphic
13:03:53 <Eduard_Munteanu> Ah.
13:03:54 <edwardk> you could answer questions like P (X > Y) or P (X < 0.5), but not use random variables as hyperparameters to other distributions, cutting off most of the scary bayesianism to keep things in closed form
13:04:32 <edwardk> so the monad would just have to register the comparisons it made and i could still compute exact probabilities
13:04:47 <edwardk> of course this only works in the finite case, so constructive reasoning seems to be the way to go
13:05:14 <edwardk> and in an intuitionistic bayesian setting the dutch book stuff isn't a problem
13:05:22 <edwardk> mercury: thanks
13:05:24 <Eduard_Munteanu> I guess it makes less sense to ascribe failure to False.
13:05:57 <edwardk> NihilistDandy: i already mined through shafer, weatherson and yk chan.
13:06:10 <edwardk> NihilistDandy: but then i kind of ran dry of good sources =)
13:06:16 <mercury^> edwardk: yw. I hope it can help you.
13:06:30 <edwardk> and i figured i should ask because roconnor is around and he's done some fiddling with constructive reals, iirc. ;)
13:06:43 <roconnor> :)
13:06:44 <NihilistDandy> edwardk: That'll happen. I'll check MathSciNet. Maybe I'll find a gem
13:07:40 <edwardk> if i can't do anything interesting here i can always wander back to using BUGS, but i'd like to do some of the easy stuff in closed form
13:07:40 <mercury^> edwardk: on the upside, if you take an OA approach, you get `quantum probability' for free. :)
13:07:55 <edwardk> i have quantum probability code already that works =)
13:08:14 <edwardk> that i can do entirely from a discrete perspective
13:08:41 <mercury^> Hmm, so you are implicitly working with von Neumann algebras already anyway.
13:09:21 <edwardk> i just work in a free module over some basis, given a ring
13:10:00 <edwardk> the quantum probability code just assumes the some of the squares of the magnitudes = 1. the probability code just assumes my scalars are all between 0..1 and the sums add to 1
13:10:26 <edwardk> and measurement is done by nesting the monad in itself and tabulating measures which it can do exactly
13:10:57 <mercury^> How do you model states and observables?
13:10:58 <edwardk> just normalize all the coefficients for my basis vectors, and turn it from a complex probability into a real probability
13:11:23 <gwern> drat, Athas is gone
13:11:52 <gwern> @tell Athas http://www.haskell.org/pipermail/haskell-cafe/2011-July/093669.html
13:11:52 <lambdabot> Consider it noted.
13:11:55 <edwardk> the naive version uses the simple vectorspace monad, but that doesn't keep me from having fanout. the better version uses oleg's trick for doing a linear type system in haskell, which i adapted to let me treat qubits as affine
13:12:19 <edwardk> but thenin order to capture quantum lambdas i had to do some funny indexed free monad stuff
13:12:25 <gwern> http://www.haskell.org/pipermail/haskell-cafe/2011-July/093669.html is my little writeup of my parse script and its results. it gave me a much more plausible average # of dependencies = 5.8
13:13:24 <mercury^> edwardk: so I gather you model pure states as vectors and observables as linear transformations?
13:14:05 <edwardk> yeah. so you can use the >>= of the free monad to handle unitary transformations
13:14:33 <edwardk> and then i have machinery for dealing with cup/cap stuff that lets me transpose the quantum computations, etc.
13:14:49 <gwern> you can do nifty things with the probability monad. I like the implementation of decision theory problems in haskell: https://oneboxo.wordpress.com/2011/01/25/udt-diagrams-in-haskell-or-decision-problems-form-a-monad-draft/
13:14:52 <edwardk> so you can flip from bra to ket, etc.
13:14:57 <gwern> cuts through a lot of the crap in the philosophy
13:15:41 <mercury^> edwardk: so, a more abstract way to handle all this, which also generalises to non-finite settings is to axiomatise some properties of matrix algebras and certain linear functionals on them.
13:16:12 <mercury^> So that you have observables you can compose, adjoint, etc. and states you can apply to them to yield a measurement.
13:16:24 <edwardk> *nods*
13:17:10 <edwardk> this was basically a direct reimplementation of hansei in slightly more abstract terms
13:17:20 <edwardk> i needed some examples for the dsl workshop
13:17:32 <edwardk> along the way i realized that i could handle some continuous distribution operations as well
13:17:38 <mercury^> I don't think it runs into any of the problems one gets with constructive sigma algebras.
13:17:49 <mercury^> And it can be used to model classical probability too.
13:20:00 <edwardk> the main thing i do with the representation i have now which starts with a free module, constrains transformations to be unitary (or also allow 'failure' so i can do redraw), then take the free monad of the free module, which lets me prioritize my traversal of the probability space, expanding whatever branch gives me the most information at each step
13:20:16 <edwardk> this lets me give back a lazily improving answer
13:21:37 <roconnor> whee, I did some refactoring and my program appears to still work!
13:21:39 <edwardk> then if i want to deal with something 'too big' i can draw samples and do probability smoothing
13:22:32 <edwardk> but if i step too far out into classical probability i lose a lot of that nice edsl character
13:24:18 <edwardk> but adapting this to deal with only the event space implied by the operations performed means i'm always dealing with a finitely separable sigma algebra at worst
13:25:22 <edwardk> so the fact that i just can't talk about some things doesn't seem too bad, given this things nature as an edsl for talking about probabilistic computation ;)
13:33:30 <Xaratas> i got: Pattern syntax in expression context: …, but tested stand allone it works. what want haskell tell me in my case expression?
13:36:27 <merijn> Xaratas: Pastebin the code + error?
13:37:21 <Xaratas> ok
13:38:30 <hpaste> Xaratas pasted “Case error” at http://hpaste.org/48600
13:38:57 <Xaratas> the error message is at the bottom
13:39:46 <Xaratas> hm, dumb tabs -.-
13:41:00 * hackagebot Stomp 0.1.1 - Client library for Stomp brokers.  http://hackage.haskell.org/package/Stomp-0.1.1 (VitaliyRukavishnikov)
13:41:38 <Xaratas> ok. without the tabs i get something meaningfull
13:42:11 <merijn> Xaratas: You're using a tab width less then 8 spaces?
13:42:30 <adimit> Is there a good source of typical Haskell indentation style? I'm writing an indentation file for Vim, and I'd like it to follow conventions (I might not be aware of.)
13:42:47 <merijn> Xaratas: GHC treats all tabs as 8 spaces, so that can confuse the indentation level
13:43:04 <Xaratas> yes, i set my editor to 4 spaces for one tab, but if i restart it it dosent remeber that i have forbidden the use of tabs in this file
13:43:15 <merijn> Xaratas: Which editor?
13:43:23 <Xaratas> programmers notepad
13:44:01 <merijn> Xaratas: Ah, don't know that one
13:44:05 <merijn> adimit: Maybe look at the GHC source, I think a lot of that is the defacto style. One thing I think is important is lining up the various cases in data type declarations/function
13:44:13 <gwern> > 1.85 * 16
13:44:14 <lambdabot>   29.6
13:45:11 <merijn> adimit: For example, have them line up nicely with the equals sign, like so: http://hpaste.org/48602
13:45:28 <adimit> merijn: ok, thanks. Aligning with equals sign was one of the reasons I wanted to write this :-)
13:46:17 <merijn> adimit: Lemme know when you're done, my current Vim indent file isn't that great :p
13:46:38 <adimit> merijn: it might take me a while. VimL is a plague upon mankind.
13:47:17 <adimit> but everything is better than no indent, as it currently stands.
13:47:24 <merijn> The entire vim codebase is, but until someone writes a better editor with a compatible command mode I'm stuck with it :p
13:47:49 <adimit> we all are. Yi isn't going strongly, unfortunately. Also, its codebase isn't too pretty either.
13:48:25 <merijn> I essentially want emacs, but with vim compatibility :p
13:48:37 <merijn> (And no, viper doesn't cut it. Not even close)
13:48:40 <dschoepe> merijn: Have you tried emacs with viper-mode and vimpulse
13:48:42 <dschoepe> oh
13:48:53 <adimit> merijn: same boat here. there's more to vim than viper has.
13:49:13 <adimit> surround.vim, text-objects, etc. (viper has something similar, but not that good.)
13:49:14 <thoughtpolice> yi used to be quite nice and simple.
13:49:15 <dschoepe> fwiw, vimpulse adds a few features that viper-mode lacks
13:49:16 <merijn> Hell, I want my complete OS to support command vs insert mode :p
13:49:22 <thoughtpolice> you can probably still find an 0.1 tarball of it somewhere
13:49:54 <merijn> Maybe sometime I'll be motivated enough to hack something like that :p
13:50:03 <thoughtpolice> oh the days of ghc 6.4
13:50:03 <adimit> There's been a lot of really good work on Yi, though. But if you look at, say, its Vi-Key bindings, it's a horrible mess.
13:50:41 <thoughtpolice> well, i only was tooling around for a week or two before 6.6 was released anyway i think :P
13:51:11 <merijn> Some other person here was working on a structural text editor, that's the only thing I'd consider ditching vim for :p
13:51:14 <thoughtpolice> yeah, jpb did a lot of really cool work with it. the code seemed always fragile and in a state of flux however. i could never come to grips fully using it, even with an emacs binding
13:51:17 <merijn> The prototype looked awesome
13:52:06 <adimit> problem with vim is: it's sooo bloddy mature. There's tons of really good support for it.
13:52:27 <merijn> The problem is, the code is freaking terrible and almost no one dares touch it :p
13:52:27 <adimit> the only thing I hate hate hate about vim is Vim Script. Just use Lua.
13:52:44 <thoughtpolice> oh man, the vim source code IS totally insane.
13:52:47 <adimit> yeah, I haven't looked at the C source yet.
13:52:48 <thoughtpolice> but it's no different in emacs land
13:52:57 <merijn> adimit: Don't ever do so
13:53:04 <adimit> That's "normal" for these huge editors.
13:53:11 <merijn> adimit: I wanted to check out how they did something, worst idea I ever had
13:53:22 <merijn> I still wake up screaming sometimes
13:53:23 <thoughtpolice> i'm sure some person has already established a law somewhere that the code behind any sufficiently advanced editor is fucking ludicrous, or a similar law, so i won't steal credit for it
13:53:31 <thoughtpolice> adimit: no, it's reeeeally bad
13:53:52 <merijn> The linux kernel is a shiny gem of readability compared to it
13:53:55 <thoughtpolice> not "this is a complicated problem, the solution is difficult" <- that's true, but it's bad as in "this is fucking god awful code"
13:54:23 <merijn> Which is saying something, because I'm not particularly fond of the linux sources either :p
13:54:29 <adimit> thoughtpolice: I can imagine. If it's the same mind that thought of VimL, then the source is probably terrible. Though I'd like to spare my brain that scar.
13:54:43 <thoughtpolice> like i said, emacs isn't much better
13:54:57 <thoughtpolice> oh, yeah, sure, 1/8th of the emacs codebase is written in C.
13:55:01 <thoughtpolice> that's only like, 120kLOC
13:55:06 <thoughtpolice> the remaining 800kLOC are elisp
13:55:39 <thoughtpolice> and all of it is pretty awful, but granted i didn't go too far into the elisp
13:55:43 <adimit> probably terrible elisp though. I remember trying to get my head around emacs mode scripts. most of them were… idiosyncratic.
13:56:02 <adimit> Then I got an RSI and said: fuck it, these Vim guys seem saner.
13:56:08 <adimit> … well, I did get rid of my RSI.
13:56:36 <thoughtpolice> the core C code is brutal as hell too, just like vim, but i'm pretty sure vim is hella small in comparison to just the C core code
13:56:52 <thoughtpolice> the elisp does make up a substantial part of the editor however
13:57:12 <adimit> which, in theory, is actually cool. But the elisp stuff is horribly written.
13:57:32 <adimit> so is, say the Haskell hilight file for Vim…
13:57:53 <adimit> To be fair, I wrote up a prolog hilight file a couple years ago. That ended up being a horrible mess, too.
13:58:05 <adimit> … but, VimL is VimL, there's no way around that.
14:01:38 <merijn> You can script it with python, ruby and perl too, right?
14:01:54 <adimit> merijn: also Lua, as of late.
14:02:12 <adimit> but I wouldn't trust an external interpreter for indentation purposes.
14:02:27 <adimit> might be slow, and you still don't get around Vim's bloody API.
14:02:28 <merijn> The big problem with writing a replacement for vim is that you'll never get the same support as vim does :\
14:02:33 <merijn> Same goes for emacs
14:03:08 <Xaratas> be better as 20 years+ of development
14:03:22 <Xaratas> sounds like a simple task
14:05:36 <adimit> Not simple, but certainly doable. Plus, you don't need to be "better"
14:06:55 <adimit> brrr. I need to actually localize x-1 if I'm using it often in my function.
14:09:55 <Xaratas> adimit: but if you are not better why schould the userbase switch?
14:10:43 <adimit> Because better is a word that doesn't really apply here. You just need to provide features people are looking for, while making the switch easy. You can't be "better" in the sense of the word that you're going to be better in every circumstance.
14:11:04 <adimit> You can be … good enough. That's reasonable, maybe achievable, and pretty decent already.
14:11:10 <adimit> And quite a feat in it's own.
14:11:28 <adimit> People will switch because of two factors: novelty (shiny new things) and unique features.
14:11:30 <gwern> kate, textmate... there are a lot of text editors with decent followings
14:11:30 <acowley> how is it good enough?
14:11:37 <gwern> I don't know what they do better than emacs or vim though
14:11:41 <adimit> acowley: no one knows.
14:12:01 <adimit> gwern: absolutely. Just be good enough. For me, good enough is nothing except Vim, even though that's sad.
14:12:18 <merijn> acowley: If the source sucks less making it easier to hack
14:12:25 <acowley> I always see it as very much not being good enough, because for whatever novelty the other editor has, it ends up paling in comparison to emacs (or vim if that's your taste)
14:12:53 <adimit> same here. Especially the vast amount of scripts/addons/plugins/support for either editor (emacs/vim) is unbeatable.
14:12:56 <merijn> acowley: The problem we're having is that emacs and vim are both showing warts, but fixing them is near impossible since the source of both sucks balls
14:13:15 <acowley> It's a bold claim to say that source code quality could elevate an editor's popularity over the big two
14:13:42 <adimit> eventually, it might, as the old editors have too much cruft to add new features people crave.
14:13:51 <acowley> The problem is that you can do practically anything in emacs, so hitting the limits of what you can do with another editor is a big deal
14:13:56 <merijn> acowley: If you manage to support say 80% of vims features with a hackable code base a lot of people may be tempted to help fix the remaining 20% + all the warts
14:14:32 <merijn> Supporting all of emacs features may be harder I suppose, but then I'm not an emacs user so I don't particularly care :p
14:14:33 <acowley> merijn: that may be, but I don't think younger editors are close to 80% of emacs
14:15:10 <Xaratas> nope
14:15:11 <acowley> Also, bear in mind that this kind of quantification somewhat misses the point. I don't use emacs because there are 10 billion plugins/scripts/features, but because it does the dozen things I do care about
14:16:25 <merijn> acowley: That may be more of an issue for the emacs userbase. But vim is more limited anyway. That's one of the problems really, as I said earlier essentially I want emacs, but lack of good command mode is unacceptable
14:16:25 <Xaratas> i started with nano, but as this thing just not do what i want i got over to vim, and know now, hm 1%? 5%? of the features. i dont know, there are so many
14:17:29 <dankna> are we talking about someone writing a new editor?
14:17:35 <dankna> I seek to persuade that person to help with Te instead
14:17:58 <merijn> dankna: That the structural editor I saw in here a few weeks back?
14:18:01 <dankna> yes
14:18:05 <merijn> In that case, I fully agree
14:18:11 <merijn> That is going to kick the ass of emacs and vim
14:18:13 <acowley> I think perhaps the most interesting aspect of all this is that there aren't more credible competitors to vim and emacs despite the fact that it doesn't seem impossible. It feels like yet another example of programmers being terrible at estimating the difficulty softare development projects.
14:18:14 <dankna> well, sort of.  it was inspired by someone else's, also shown around in here.
14:18:21 <dankna> thanks :)
14:18:28 <acowley> link for Te?
14:18:35 <merijn> dankna: treeedit you mean?
14:18:37 <dankna> er, it's not actually published yet
14:18:42 * mekeor loves emacs...
14:18:43 <dankna> treeedit was the inspiration for Te, yes
14:19:10 <dankna> I hate Emacs - but I used it exclusively for something like eight years
14:19:20 <dankna> it had too many killer features :(
14:19:26 <merijn> Got a repo for Te? I wanted to hack treeedit, but didn't have the free time to invest yet and the pointfree style it used was beyond my skill atm
14:19:30 <dankna> yes, absolutely
14:19:50 <merijn> I need this editor to happen :p
14:19:53 <dankna> note that in its current state, Te is Mac-only, although it will have a terminal mode before its 0.5 release
14:20:04 <dankna> also it doesn't, uh, actually edit anything yet, I've been too focused on GUI and database issues
14:20:10 * merijn mostly works on his MacBook anyway :p
14:20:13 <dankna> great, then
14:20:40 <dankna> let me copy the repo to the public directory
14:20:50 <dankna> when you want to contribute code I can add you to the group for the shared copy of it
14:21:06 * adimit hates fancy mac-only projects.
14:21:09 <mekeor> is there a editor written in Haskell?
14:21:14 <dankna> several
14:21:17 <mekeor> which?
14:21:17 <dankna> adimit: tough!  haha
14:21:19 <adimit> mekeor: try out Yi.
14:21:21 <merijn> No clue how much free time I can commit with the amount of school work I have to do, but doesn't hurt to try
14:21:23 <merijn> mekeor: Yi
14:21:37 <merijn> adimit: Give in to the Apple-side :p
14:21:39 <acowley> dankna: Well, good luck with it, but know that I expect any editor to be able to replace emacs as my tiling window manager! :P
14:21:50 <NihilistDandy> Is Yi stable? I've tried to build it a few times and I always end up dependency chasing until I give up :/
14:21:57 <mekeor> oh, cool!? yi is chinese?
14:21:59 <adimit> merijn: I value my sanity too much. Also, I'm broke.
14:22:09 <dankna> acowley: believe it or not I spent a ton of effort on tiling windows!
14:22:15 <adimit> mekeor: the inspiration for the name is the Chinese word, yes.
14:22:20 <dankna> I'm not totally done with that feature, in fact
14:22:31 <acowley> dankna: then you have my attention!
14:22:34 <dankna> hehe :D awesome
14:22:40 <NihilistDandy> dankna: Mine, too :D
14:22:44 <acowley> my usual emacs setup is code on the left, then ghci and erc on the right
14:23:01 <dankna> yeah, but the point is to be customizable of course, because everyone will have their own preferred setup
14:23:07 <merijn> adimit: Ah, they offer like 15-20% price reduction for students here, trying to conquer the young people market :>
14:23:10 * hackagebot funpat 0.1 - A generalization of pattern matching  http://hackage.haskell.org/package/funpat-0.1 (GergelyDevai)
14:23:11 <acowley> but being able to quickly split frames while jumping around is hugely useful
14:23:21 <dankna> yeah
14:23:38 <adimit> merijn: still doesn't excuse the shoddy operating system and mediocre HW specs :-P (but that's a whole different holy war entirely.)
14:23:42 <acowley> I admit emacs claw isn't ideal, but boy is it fast
14:23:45 <dankna> because it's a GUI program, you can split frames with the mouse.  you will eventually be able to split them with the keyboard as well.
14:23:53 <merijn> adimit: In the end I just didn't want to invest the time/research into finding a laptop with good battery life and full BSD support
14:24:04 <NihilistDandy> dankna: What are you using for the GUI?
14:24:14 <merijn> adimit: What's so shoddy about OSX in your opinion?
14:24:36 <acowley> Oddly I was forced into almost 100% keyboard due to RSI from a mouse, and now I live in emacs
14:24:45 <dankna> NihilistDandy: the GUI is in Objective C but it's a very thin layer that calls Haskell code across the FFI for any decision of even the slightest importance.
14:25:02 <NihilistDandy> dankna: You have my attention a second time! :D
14:25:03 <dankna> NihilistDandy: it will also, as I said above, eventually have a terminal-based front-end as well
14:25:05 <dankna> thanks :D
14:25:17 <acowley> dankna: do you have a good system for building such an app or do you have to manually chase down necessary libraries to pass to the linker?
14:25:20 <adimit> merijn: laundry list. Pseudo-UNIX that always fails when you don't expect. Awful package managers (if I'd want Gentoo, I'd use Gentoo, dammit.) Holy freacking ITUNES and SAFARI being part of my SYSTEM. OMG. Also, WORST FUCKING window management EVER. Restarting the computer for a quicktime update…
14:25:27 <NihilistDandy> Can't wait to have a look at it
14:25:42 <adimit> it goes on.
14:25:43 <NihilistDandy> adimit: Homebrew
14:25:50 <acowley> adimit: cabal
14:25:52 <adimit> NihilistDandy: If I want Gentoo, I'd get Gentoo.
14:26:07 <dankna> acowley: I have a good system.  I'm waiting for dcoutts to review and accept some patches to Cabal on which it depends, before I integrate it with Cabal, but for now it runs as an extension to Cabal.
14:26:11 <merijn> adimit: I can't remember last time I had to reboot the machine and OSX is a better unix then linux :p
14:26:13 <adimit> cabal is different in that I don't have to compile perl and gcc if I want to install some KDE app.
14:26:15 <NihilistDandy> Better than fink and ports :D
14:26:43 <acowley> dankna: that would be fantastic! Building executables that call into Haskell is too much trouble to be worth it atm.
14:26:46 <Xaratas> acowley: what does RSI stand for?
14:26:49 <adimit> NihilistDandy: nothing matches dpkg & apt-get. Not a thing. I've tried, looked around. They're all awful.
14:26:52 <merijn> adimit: If you come from linux' broken GNU tools the commands are somewhat different because they come from the BSD userland, but as a BSD user that is a pro for me :p
14:26:57 <NihilistDandy> Repetitive Stress Injury
14:27:01 <merijn> Xaratas: Repetitive Strain Injury
14:27:06 <NihilistDandy> Or that
14:27:20 <acowley> either works!
14:27:22 <dankna> I agree, it's a lot of trouble right now.  If you want it to get released more widely, nag dcoutts to review my patches :)
14:27:35 <merijn> dankna: Is the repo on github or somewhere else?
14:27:42 <dankna> for now I'm pushing the repo for cabal-app, which is what I called the working prototype, to public as well
14:27:47 <dankna> it's on my server, I'm setting it up now
14:27:51 <merijn> ok
14:28:01 <acowley> dankna: so you rely on cabal to produce the final executable?
14:28:16 <dankna> I do, yes.  Uhhhh you might have some trouble building without my patches to Cabal :(
14:28:34 <dankna> I had to extend it to handle certain things, like Objective-C header files
14:28:45 <dankna> it was actually rather a lot of work to make that function properly
14:29:13 <acowley> Doesn't that limit integration with Xcode? It also doesn't scratch my itch of wanting more-easily-produced statically linked libraries so clients don't need GHC to invoke the linker
14:29:59 <dankna> it means you are using a .cabal files as your master instead of an XCode project file, but you can create .nibs and such by using an XCode workspace file (which I have thoughtfully provided) instead.
14:30:17 <dankna> if you wanted to debug in XCode that would be a little finicky to set up though probably possible
14:30:28 <dankna> but why would you, the ObjC layer is very thin and gdb/lldb can't handle Haskell code
14:30:31 <NihilistDandy> dankna: Which Xcode are you working with?
14:30:48 <dankna> oh, the developer preview one.  right.  workspaces were a new feature in that, weren't they.
14:30:52 <dankna> I had forgotten.
14:31:00 <dankna> but it'll be public sometime this month.
14:31:09 <acowley> dankna: I was actually just thinking about when you're tweaking the Obj-C part of the application, rebuilding from within Xcode would be handy
14:31:15 <NihilistDandy> dankna: Xcode 4 is out, now, if that's what you mean
14:31:20 <dankna> oh it is, good
14:31:35 <dankna> no, I have the one that comes with Lion, which is why I thought there was an issue there
14:31:41 <dankna> which is 4.2 or something like that
14:31:44 <dankna> acowley: so it would, but oh well
14:31:52 <NihilistDandy> It's 5 bucks on the App Store, which was a better deal for me than having to pay out for Apple Dev
14:31:56 <dankna> agreed
14:32:19 <NihilistDandy> Also, much as I hated the idea at the beginning, I kinda like the App Store
14:32:26 <dankna> okay, http://dankna.com/software/darcs/Te/ and http://dankna.com/software/darcs/cabal-app/
14:32:43 <dankna> yes - its concept is evil but its realization is quite nice
14:32:52 <merijn> Let's see if my darcs install still works :>
14:33:12 <NihilistDandy> I'm building it now. Forgot I hadn't done so on this install :/
14:33:55 <dankna> and I may have to put up my Cabal patches for you too, but I'm not sure offhand which of the seven (!) or so that I've got pending are necessary for this, so tell me how the build fails and I'll put up the patch needed for that issue specifically
14:34:16 <NihilistDandy> Shall do
14:34:18 <jesse_> hi
14:34:20 <dankna> you definitely want to install the updated copy of Cabal as --user btw so that you don't break your systemwide copy
14:34:34 <acowley> I think the App Store is great as long as it doesn't mean they lock down the OS outside of it. The ease of selling software today is awesome.
14:34:39 <jesse_> Is there a tool to convert simple C-Types into pure haskell types?
14:34:51 <dankna> acowley: yes, I agree, it's fine? for now :)
14:35:03 <merijn> acowley: I don't think they will lock down the OS outside of it, it makes no sense on Mac(Book)s
14:35:48 <merijn> I can see wanting to try to control iPhones/iPods, but locking MacBooks will chase away the entire CS/hacker following OSX has carefully built over the past years
14:35:52 <dankna> certainly it makes sense - for the same reason as it does on phones.  security.  but it would be horrible and evil.
14:35:59 <acowley> merijn: I agree, but they do other things that I think are counter productive. Things like the now-defunct restriction to only using Obj-C for iOS apps. The current subscription issue with apps is also too heavy handed.
14:35:59 <NihilistDandy> ^
14:36:42 <wli> No one thinks CS/hacker followings are significant market segments.
14:36:58 <NihilistDandy> The thing that I found hilarious is that they don't include the ppc assemblers in the 10.6 SDK, but they're both still available in the iPhone one.
14:36:59 <merijn> wli: Of all people owning Macs they might well be
14:37:02 <NihilistDandy> Symlink, and done
14:37:05 <dankna> well, hopefully Apple understands that they may not be a significant market segment financially but they are a /powerful/ one
14:37:15 <merijn> wli: Most "normal" people will want an iPad instead
14:37:21 <dankna> we're the ones who decide whether a platform lives or dies, if you think on the timescale of decades
14:37:34 <acowley> wli: we are legion... for some definition of legion. We'd be a reasonable crowd if we all got together!
14:37:39 <merijn> I mean over 50% of CS students here are using MacBooks now and they will drop it like a brick and start developing for other things if it gets locked down
14:37:45 <NihilistDandy> Developing on a Mac doesn't suck, and I think that's my favorite thing
14:37:53 <dankna> I agree, it doesn't suck :)
14:38:21 <merijn> Developing on a Mac is like developing on *nix without the hassle of making sure hardware is compatible :p
14:38:26 <NihilistDandy> ^
14:38:26 <wli> merijn: And Apple's sales revenue wouldn't even undergo a detectable blip.
14:38:42 <merijn> wli: Maybe so, but lack of developers will hurt in the long run
14:38:43 <acowley> I think one of the most prescient things about our role as consumers was said by, I think, Jobs himself: regular computers are pickup trucks; iPads are the sedans most people want.
14:38:44 <NihilistDandy> merijn: But their revenue from developers might take a dip
14:38:51 <NihilistDandy> *wli
14:39:08 <dankna> acowley, that's very true but how is it about the role of developers as consumers?
14:39:11 <merijn> iPhone is such a powerful market because of developer mindshare
14:39:25 <jesse_> Is there a tool to convert simple C-Types into pure haskell types? I'm writing GL4 bindings, but it's to much work to cast every type myself.
14:39:36 <NihilistDandy> Though all the telcos killing unlimited data are sure making the iPhone less attractive
14:39:43 <dankna> jesse: not in general, but for specific cases there are several such tools
14:39:44 <acowley> dankna: we're a moderately significant minority with special needs. We don't represent the tip of the future market as we may once have done.
14:40:10 <dankna> acowley: it's not about being the tip of the future market; it's about being the ones who control what platform the interesting new things are happening on
14:40:26 <NihilistDandy> Let us not forget that for every attempt they make to lock down a platform, clever people will make commensurate efforts to unlock it
14:40:28 <jesse_> dankna: For example? I only want to convert simple types such as ints, floats or doubles.
14:40:33 <merijn> acowley: As Ballmer says "Developers! Developers! Developers!" :p
14:40:35 <NihilistDandy> The iPhone was jailbroken in a flash
14:40:54 <acowley> well, this is now a chicken and egg question between developers and users
14:41:00 <dankna> jesse: oh I see what you're saying, you want a way to not have to call fromIntegral or realToFrac by hand?  sorry, it has to be done somehow.
14:41:12 <dankna> jesse: there are programs that generate code for you for that layer, but honestly I think they're all pretty bad
14:41:26 <jesse_> heh...
14:41:33 <acowley> and, as much as I like their products, I think Apple courts users before developers
14:41:35 <jesse_> That's bad.
14:42:00 <acowley> jesse_: do you have some specific code that you think is too ugly?
14:42:10 <jesse_> dankna: It's to much work for me, I'm working on realtime 3d software and I need GL 4 features, but I can't create the hole bindings myself. :/
14:42:20 <acowley> oof
14:42:34 <dankna> jesse: ahhh that's sucky.  hmm.  you mean OpenGL?  I didn't realize what you were talking about at first.
14:42:46 <jesse_> yep, OpenGL 4.1
14:43:04 <dankna> jesse: there's a student ostensibly working on revising and updating our OpenGL bindings as a Google Summer of Code project
14:43:05 <acowley> jesse_: that's borderline worst case scenario material right there. Stick to using CTypes on the lowest layer, then layer up the abstractions.
14:43:07 <merijn> Aren't there two OpenGL bindings already?
14:43:14 <jesse_> I don't want to switch the language again...
14:43:20 <acowley> I think there's just the one, with a large upate in the works
14:43:32 <dankna> jesse: but I forget who it is and I'm not sure if he's started yet, though time-wise he should have.  he should be around here somewhere.
14:43:38 <jesse_> Updates? The maintainer isn't reachable via mail.
14:43:41 <acowley> I think Jason Dagit is involved
14:43:50 <acowley> as a mentor, that is
14:43:57 <jesse_> k, never heard of him.:P
14:44:13 <acowley> He took over maintainership due to the aforementioned unreachable former maintainer
14:44:15 <acowley> iirc
14:44:28 <jesse_> k. Somebody wrote about that on the HOpenGL mailing list.
14:44:28 <ddarius> quicksilver: Every adjunction is "between" the Eilenberg-Moore algebra one and the Kleisli one in a certain sense, but that doesn't mean that there are infinitely many (non-isomorphic) adjunctions.
14:44:37 <jesse_> argh... :/
14:44:50 <merijn> What's the best way to upgrade installed cabal libraries to newest available versions?
14:45:02 <dankna> merijn: one at a time
14:45:11 <acowley> jesse_: If you don't want to wrap large swathes of OpenGL, write larger chunks in C, and FFI into that form Haskell
14:45:40 <jesse_> That's a good idea. :P
14:45:41 <acowley> jesse_: That's what I do for newer texture representations and such
14:45:59 <jesse_> k, and floating point mathematics with intrinsics. :P
14:46:35 <acowley> jesse_: It works great, you just need to be careful with designing the C code as it easily spirals into masses of unmaintainable goop
14:46:43 <dankna> yes, C does that
14:46:55 <acowley> the problem being that in Haskell you have modules, classes, and HOFs to structure things
14:46:59 <merijn> Thanks for reminding me of my current trauma :(
14:47:05 <acowley> dankna: it's worse than normal
14:47:40 <NihilistDandy> dankna: Unsurprisingly, my attempt to build cabal-app fails because I lack Cabal 1.11
14:47:57 <merijn> NihilistDandy: Join the club ;)
14:48:25 <dankna> oh yes
14:48:29 <acowley> dankna: if you're doing a straight C project you arrange things according to what the language offers (namely, files and structs). While code destined solely for FFI usage tends to be little isolated snippets that often lack a useful identity.
14:48:33 <NihilistDandy> merijn: Oh,  I must have missed that :D
14:48:38 <dankna> acowley: this is true :(
14:49:11 <dankna> NihilistDandy: okay, so for starters I'm pretty sure you'll need Cabal 1.11 to make my patches apply cleanly.
14:49:19 <merijn> So, where do I get Cabal 1.11? :p
14:49:34 <dankna> NihilistDandy, merijn: so get it from its upstream repository, which I'll find for you in a sec, and unpack it somewhere
14:49:52 <acowley> dankna: I always make the mistake of under-designing the FFI components of my Haskell projects up front, and end up with painful refactoring down the road.
14:50:09 <dankna> yeah, I gave the FFI component of Te center-stage
14:50:12 <NihilistDandy> Also, is it safer to use cabal-dev to install it, or am I pretty safe to just --user it?
14:50:56 <dankna> I don't know what cabal-dev is, I actually --globaled it myself and have had no trouble apart from the fact that it means ghc-pkg thinks my install is broken now
14:51:03 <dankna> so I think --usering it would avoid the problem I had
14:51:30 <dankna> okay so darcs get http://darcs.haskell.org/cabal/
14:52:13 <merijn> So I should install that as --user I guess
14:52:34 <dankna> my patches are against the Cabal library but since the cabal-install binary is statically linked, every time you apply patches against the library you have to install the library, then go to the cabal-install dir and do "cabal clean; cabal install"
14:53:39 <dankna> there are some miscellaneous nice new Cabal features that you'll be getting as a side bonus of this, I forget what they are though so they'll just be pleasant little surprises :)
14:53:49 <NihilistDandy> I do like surprises
14:53:53 <dankna> hehe
14:54:08 <NihilistDandy> 3500 patches queued :|
14:54:16 <dankna> eep heh, yeah
14:54:21 <dankna> it did take a while
14:54:33 <dankna> git definitely beats darcs in terms of performance on a new checkout
14:54:41 <NihilistDandy> Quite true
14:54:53 <NihilistDandy> Though I need to get more practice with darcs
14:54:56 * dankna nods
14:55:10 <NihilistDandy> I use git and mercurial, mostly, so this is as good a time as any to add another to my toolbox
14:55:16 <dankna> gotcha, yeah
14:55:22 <dankna> it's good to be proficient with multiple ones
14:55:27 <dankna> I'm mostly a darcs user
14:55:32 <merijn> Right now I just use mercurial and use hg-git for git interaction :p
14:56:11 <NihilistDandy> merijn: You on bitbucket? My new favorite repo host. :D
14:56:31 <merijn> Naah, I use github (well, not really atm)
14:56:47 <adimit> <3 github.
14:56:50 <NihilistDandy> It's a mercurial one. Unlimited public and private repos
14:56:54 <merijn> Got a bunch of private repos at university after mutiny from the faculty SVN servers
14:57:04 <NihilistDandy> No space limit
14:57:19 <merijn> Leading a rebellion together with some of the phd students ;)
14:57:25 <dankna> hee, cool
14:57:57 <dankna> yeah, svn's raison d'etre is kinda weird? the goal is to be the best bad-thing it can be, without introducing any features that would make it good ><
14:58:43 <sonoflilit> Hi
14:58:49 <sonoflilit> I'm installing ghc7 on mandriva
14:58:56 <sonoflilit> which means from source
14:59:05 <gwern> dankna: svn is a better cvs, my understanding was.
14:59:08 <merijn> "But there's nothing wrong with SVN!" "It's always worked for us! I don't see why there is suddenly a problem"
14:59:13 <dankna> gwern: that's what I said?
14:59:28 <sonoflilit> I didn't change anything significant in the build process, but it somehow failed to include profiled versions of libraries
14:59:33 <gwern> dankna: well, as long as you assume a better cvs must be a 'best bad-thing' :)
14:59:41 <merijn> 'Merging is completely broken in SVN..' "Well, you just shouldn't merge!"
14:59:44 <dankna> well, yeah :)
14:59:48 <merijn> *sigh*
15:00:36 <sonoflilit> can anyone help me get --prof base-4?
15:00:47 <merijn> Me and another master student basically just stopped checking code into SVN at some point and moved it to our own mercurial repositories until we got 1 of the professors to crack and agree to move to mercurial in the near future :p
15:01:01 <dankna> sonoflilit: you need to create or edit your mk/build.mk
15:01:16 <dankna> sonoflilit: the comments or the template in mk/build.mk.example should help with that
15:02:30 <sonoflilit> dankna: I did tweak BUILD_DOC* settings
15:02:51 <NihilistDandy> I have a friend forced to use this: http://en.wikipedia.org/wiki/Team_Foundation_Server
15:02:58 <dankna> those aren't relevant to your issue, I don't think
15:03:00 <sonoflilit> for "perf", which is the default, and according to the README should include profiled libraries
15:03:03 <sonoflilit> isn't it so?
15:03:11 <dankna> hmm
15:03:25 <merijn> dankna: So I'm new to the cabal business. I just ran "cabal install" in the Cabal 1.11 checkout, then the same in cabal-app, anything else?
15:04:47 <dankna> merijn: well, the Cabal 1.11 checkout contains two separate Cabal projects.  cd where-you-put-it/cabal/cabal/ ; cabal install --user ; cd ../cabal-install ; cabal install --user ; cd where-you-put-it/cabal-app ; cabal install --user
15:04:49 <NihilistDandy> dankna: Additionally, should I install the new cabal-install along with the new Cabal?
15:05:03 <NihilistDandy> Ah, that's my wuestion answered
15:05:06 <NihilistDandy> *question
15:05:09 <dankna> NihilistDandy: yes, but it's in the same repository now, in two side-by-side subdir---- yes
15:05:17 <NihilistDandy> Noticed
15:05:27 <NihilistDandy> That's actually a nice thing in itself :D
15:05:29 <dankna> it is
15:06:20 <nus> roconnor, looks like spitters is the guy edwardk wants to talk to regarding constructive probability, no?-)
15:06:36 <sonoflilit> dankna: I have GhcLibWays += p in "perf"
15:06:44 <sonoflilit> is that all that should be needed?
15:06:54 <roconnor> nus: possibly
15:06:56 <dankna> sonoflilit: it is indeed
15:07:10 <dankna> sonoflilit: so if you have that and you still aren't getting them, I'd say that's either user error or a build-system bug
15:07:38 <nus> roconnor, just stumbled upon his slides for TYPES2004
15:07:56 <sonoflilit> or maybe they are created but not installed?
15:08:03 <sonoflilit> what would the files look like?
15:08:11 <dankna> they'd be files ending with _p.o
15:08:26 <dankna> side-by-side with the regular .o files that get installed
15:08:30 <sonoflilit> not created
15:09:05 <sonoflilit> how do I make sure that "perf" is the kind of install that was selected?
15:09:15 <sonoflilit> thanks a lot, btw
15:09:16 <dankna> not sure, but the build system is documented on the GHC developer wiki
15:09:19 <dankna> no problem
15:10:02 <NihilistDandy> dankna: On the subject of convenience, have you ever tried out docidx for keeping the haddocks on installed packages organized?
15:10:06 <roconnor> My Multiplate paper has been accepted to the Workshop on Generic Programming!
15:10:16 <dankna> oh!  I have not.  I wanted something like that.
15:10:23 <NihilistDandy> Let me dig up the git link
15:10:24 <dankna> grats, roconnor!
15:10:27 <dankna> please do
15:10:40 <NihilistDandy> https://github.com/gimbo/docidx.hs
15:10:57 <NihilistDandy> I just started using it last week, and it's phenomenal
15:11:16 <sonoflilit> indeed, I needed to uncomment "flavor=perf"
15:11:49 <dankna> ah!  that would do it
15:12:33 <dankna> looks nice!  have to start with it now
15:13:23 <NihilistDandy> dankna: It's quite fast, too, which is quite nice
15:13:56 <NihilistDandy> Also, all the installs are complete
15:14:01 <NihilistDandy> No problems
15:14:46 <c_wraith> Is there a followup to "Extending the Haskell Foreign Function Interface with Concurrency" that covers the creation of the threaded runtime?
15:15:22 <napping> I think some of the issues are mentioned in the smp runtime paper itself
15:15:40 <NihilistDandy> dankna: "As compared to cabal-macosx, cabal-app lacks the dependency-chasing features"
15:15:40 <c_wraith> napping: that sounds like the paper I want.  Where is it? What's it called? :)
15:15:46 <NihilistDandy> I can't tell if that's tongue in cheek :D
15:16:07 <napping> Haskell on a Shared Memory Multiprocessor?
15:16:16 <dankna> haha, it's not, but cabal-macosx's dependency chasing is insane.  it pulls in fgl and a ton of other stuff to do graph-theory dependency analysis.
15:16:35 <NihilistDandy> Wow
15:16:44 <dankna> whereas cabal-app simply passes -framework to the linker and lets the linker sort it out.
15:17:03 <dankna> (actually, Cabal already handles frameworks, so that's not even a cabal-app feature)
15:17:07 <merijn> Right, that was surprisingly easy
15:17:14 <napping> There may have been changes since, have you checked the users guide?
15:17:22 <merijn> Now I think I just need to beat my path into using the right Cabal version
15:17:40 <dankna> right, okay
15:17:50 <c_wraith> napping, thanks.  (I should have known to just look for something with the right name and timeframe on the appropriate msresearch page)
15:18:07 <NihilistDandy> merijn: I find it easiest to just add `export PATH="$HOME/.cabal/bin:$PATH"` to my profile
15:18:28 <merijn> NihilistDandy: I have that, but it seems to still find Cabal 1.10
15:18:35 <dankna> "which cabal"
15:19:05 <merijn> There we go, I think /usr/bin is in front of of .cabal/bin in my path :)
15:19:12 <NihilistDandy> Ah, that'd do it
15:19:13 <dankna> personally, I have /usr/local/cabal/bin/ near the front of my $PATH; it's a symlink to /usr/local/cabal/ghc-7.1.20110504/bin/
15:19:15 <dankna> yeah
15:19:29 <dankna> but I'm slightly insane with regard to using --global installs
15:19:50 <napping> c_wraith: I think some of the meaning of safe and unsafe may have changed slightly since then.
15:19:55 <NihilistDandy> dankna: I installed through brew, so I didn't want to clobber my old cabal without a bit of testing first :D
15:20:00 <dankna> gotcha, yes, makes sense
15:20:06 <fragamus> hpaste is down
15:20:07 <c_wraith> napping: that's fine..  I'm more interested in the history at the moment.
15:20:21 <NihilistDandy> fragamus: No it's not. :/
15:20:29 <napping> Ah, then that should be the right paper (for some reason, I can't see haskell.org from here)
15:20:38 <merijn> hmm
15:20:52 <fragamus> it was unreachable a minute ago
15:21:01 <hpaste> Hpaste pasted “See?” at http://hpaste.org/48603
15:21:05 <merijn> "which cabal" says its using ~/.cabal/bin now, but "cabal --version" still reports 1.10
15:21:26 <dankna> hmmm
15:21:46 <hpaste> fragamus pasted “ListT discussion” at http://hpaste.org/48604
15:21:57 <merijn> So does "~/.cabal/bin/cabal --version"
15:22:17 <dankna> one sec while I check something, that might be my fault
15:22:26 <NihilistDandy> Might have to play around with .cabal/config
15:22:27 <fragamus> this is a contrived example but I want to use it to learn something
15:22:47 <dankna> I might have bumped the version number locally in my own efforts to do things, in which case the correct action would be for you to un-bump it in Te.cabal
15:23:17 <fragamus> this example computes only one pair, using runListT' instead of runListT
15:23:52 <fragamus> I don't care about squares etc, but I want to modify this so that it prints out a list of outcomes
15:24:11 <shachaf> Approximately how much overhead do strict ByteStrings have?
15:24:17 <NihilistDandy> dankna: The Te install threw a bunch of warnings at the befinninf, but no failures yet
15:24:21 <NihilistDandy> *beginning
15:24:44 <dankna> oh good
15:24:48 <merijn> NihilistDandy: It failed for me after a while
15:25:01 <merijn> But I can try again now after changing the path
15:25:09 <dankna> I don't know what "cabal install" will do to Te.  I just use "cabal build" and then "open dist/build/Te.app"
15:25:11 <NihilistDandy> merijn: Nah, failed for me, too
15:25:22 <NihilistDandy> dankna: Ah, I'll try that
15:25:45 <NihilistDandy> "Error: The 'Main-Is' field must specify a '.hs' or '.lhs' file (even if it is generated by a preprocessor)."
15:26:07 <dankna> ah, yes, okay.  let me post that patch, one sec.
15:26:44 <dankna> so you both un-bumped the required-Cabal-version number in Te.cabal and that's how you got to this stage?  okay, then never mind what I was checking
15:27:08 <hpaste> NihilistDandy pasted “dankna Te warnings” at http://hpaste.org/48605
15:27:24 <dankna> ah thank you
15:27:33 <NihilistDandy> Ah, I forgot to unbump. Hang on, and I'll try again
15:27:40 <dankna> that helps me get the correct set of patches on the first try
15:28:30 <hpaste> merijn pasted “After unbumping version” at http://hpaste.org/48606
15:28:43 <NihilistDandy> Same issues on unbumping, minus the warning about the cabal version
15:29:05 <merijn> I get a different error after unbumping (and running clean)
15:29:21 <dankna> right okay
15:29:47 <NihilistDandy> merijn: Well, so do I, it seems. Good catch.
15:30:16 <merijn> 6 months of hacking a crappy C code base have taught me to *always* run clean after any significant change :p
15:30:29 <dankna> ya
15:30:47 <dankna> one sec, I'm merging my patches against the new repo, heh
15:31:05 <Xaratas> (>>=) is badass
15:31:40 <Xaratas> (Exception msg) -> (Exception msg, state') ) ---> i do not want to write this for every type of exception i have
15:32:09 <Xaratas> but i cannot use "dont mind the type just use the current one"
15:32:24 <gwern> @seen dcoutts_
15:32:24 <preflex>  dcoutts_ was last seen on #haskell 12 days, 4 hours, 38 minutes and 5 seconds ago, saying: augur: yeah, at least temporarily to be able to install
15:32:24 <lambdabot> Unknown command, try @list
15:32:28 <gwern> @seen dcoutts
15:32:29 <preflex>  dcoutts was last seen on #ghc 1 day, 12 hours, 6 minutes and 28 seconds ago, saying: tibbe: that's not unreasonable, send him your comments
15:32:29 <lambdabot> Unknown command, try @list
15:32:40 <augur> 0.0
15:33:41 <gwern> dcoutts_: why does the documentation for SourceRepo (http://www.haskell.org/ghc/docs/7.0.2/html/libraries/Cabal-1.10.1.0/Distribution-PackageDescription.html#t:SourceRepo) say that repoType and repoLocation are both "This field is required." but the type sig for both has a Maybe in it? if it's required, then shouldn't there always be a Just value and so the Maybe is unused?
15:34:29 <Xaratas> any idea how i could make out of a Errormessage a an Errormessage b without writing every case?
15:35:02 <dankna> NihilistDandy, merijn: http://dankna.com/himitsu/patches-to-cabal-for-te.dpatch
15:35:29 <dankna> download that and run "darcs apply patches-to-cabal-for-te.dpatch".
15:35:30 <ski> Xaratas : iiuc, factor out all the exceptions to another type
15:36:05 <NihilistDandy> dankna: From the Te directory, yes?
15:36:14 <Xaratas> hm
15:36:28 <dankna> er, no, sorry, from the Cabal directory
15:36:34 <dankna> they won't apply to Te, as they are patches to Cabal
15:36:35 <NihilistDandy> Ah, okay
15:36:38 <ski> Xaratas : you might want to paste the code ..
15:37:43 <merijn> Any special command to apply them or just copy the thing to the cabal/cabal directory and rerun cabal install?
15:37:45 <dankna> afk one sec, phone call
15:37:45 <hpaste> Xaratas annotated “Case error” with “Case error (annotation)” at http://hpaste.org/48600#a48607
15:38:19 <dankna> "darcs apply filename.dpatch" from that dir
15:38:24 <Xaratas> instance of monad is around the bottom
15:38:33 <NihilistDandy> Done and compiling
15:38:54 <ski> Xaratas : right, exactly what i thought
15:40:01 <ski> Xaratas : i'd start by renaming `ErrorMessage' to something more appropriate
15:40:02 <NihilistDandy> dankna: I'll want to recompile cabal-install against the patched Cabal, right?
15:40:33 <Xaratas> ok
15:40:36 <ski> like maybe `Error' or `Exception' or `Exn' or `ErrorMonad' or something
15:40:44 <ski> then i'd factor it like
15:41:48 <ski>   data ErrorMonad a = Ok { current :: a }
15:41:53 <ski>                     | Err { err :: ErrorMessage }
15:42:29 <ski>   data ErrorMessage = DivisionByZero { msg :: String }
15:42:31 <ski>                     | VariableNotDefined { msg :: String }
15:42:36 <ski>                     | ...
15:42:39 <hpaste> NihilistDandy pasted “dankna new Te Warnings” at http://hpaste.org/48608
15:42:48 <ski> Xaratas : do you understand ?
15:43:21 <Xaratas> i think so
15:43:47 <ski> the problem was that all of the error messages were independent of the `a' type in `ErrorMessage a' before
15:43:58 <NihilistDandy> @hoogle Distribution.App
15:43:58 <lambdabot> No results found
15:44:01 <ski> using this instead `a' isn't even a parameter of `ErrorMessage'
15:45:12 <gwern> excellent. my repo script is parsing. keikaku doori
15:45:15 <ski> Xaratas : depending, you could possibly use `type ErrorMonad = Either ErrorMessage' (or `newtype' or `data' instead), if you wanted to
15:45:45 <merijn> NihilistDandy: Odd, I see a different error
15:46:33 <NihilistDandy> Oh, derp. I didn't re-build cabal-app
15:47:12 <hpaste> merijn pasted “Te compile error” at http://hpaste.org/48609
15:47:36 <ski> Xaratas : btw, i'm not sure if you're going to use `ErrorMessage'/`ErrorMonad' as a monad .. you could do it, though
15:48:12 <ski> Xaratas : hm, i see you commented out `data Script a = Script (Store -> (Either ErrorMessage a, Store))', why ?
15:48:13 <Xaratas> its just a hull for the exceptiontypes
15:48:18 <gwern> although my code would be a lot cleaner if not for all the Maybes
15:48:21 <NihilistDandy> merijn: What did you need to do to get past cabal configure?
15:48:40 <merijn> NihilistDandy: I rebuild cabal, cabal-install and cabal-app
15:48:49 <gwern> certainly are a lot of github repos
15:48:51 <merijn> And of course ran cabal clean first
15:49:04 <NihilistDandy> Hmm. I did the same, but I still get errors.
15:49:04 <merijn> Could it be an issue that I still have Xcode 3.something?
15:49:11 <NihilistDandy> Could be
15:49:18 <Xaratas> ski: the Either is from the old version. the current exercise want it without Either
15:49:33 <ski> oh, this is an exercise of some sort ?
15:49:43 <NihilistDandy> I'm not sure. dankna and I are both on 4, so that might contribute
15:50:23 <ski> Xaratas : anyway, as you noted, it's better to separate `ErrorMonad' from `ErrorMessage', even if you make `ErrorMonad' a separate type from `Either ErrorMessage'
15:50:47 <ezyang> @msg edwardk Do you know if there are any constructions that force "left associativity" the same way codensity forces right associativity?
15:50:48 <lambdabot> Not enough privileges
15:50:54 <ski> Xaratas : i'm doubtful as to whether `isError' is very useful ..
15:51:16 <ski> ezyang : `@ask' or `@tell'
15:51:22 <ezyang> @tell Do you know if there are any constructions that force "left associativity" the same way codensity forces right associativity?
15:51:22 <lambdabot> Consider it noted.
15:51:23 <ezyang> thanks
15:51:33 <mauke> who is Do?
15:51:49 <mauke> preflex: xseen Do
15:51:50 <preflex>  Do was last seen on freenode/#haskell-blah 312 days, 55 minutes and 34 seconds ago, saying: @messages
15:51:58 <dankna> NihilistDandy, merijn, sorry!  back
15:52:08 <ski> ezyang : .. speaking of the devil
15:52:17 <NihilistDandy> merijn: dankna: Got it to go further this time. Pushed the version back to 1.11 and it configured and built until an error. Pasting now
15:52:21 <ezyang> Hmm?
15:52:31 <dankna> oh!  I know what this problem is
15:52:36 <ski> ezyang : edwardk just joined
15:52:37 <dankna> oh okay
15:52:37 <merijn> dankna: I got it to compile further, but hit this: http://hpaste.org/48609
15:52:55 <merijn> I'm still using Xcode 3.2 though, if that matters
15:52:57 <ski> (ezyang : and you told lambdabot to tell the nick `Do', in case you didn't notice)
15:52:58 <hpaste> NihilistDandy pasted “Successful Te Config” at http://hpaste.org/48610
15:53:03 <dankna> merijn: xcode 3.2 shouldn't matter
15:53:13 <ezyang> oops.
15:53:20 <ezyang> Well, now that edwardk is here...
15:53:25 * wli is still stuck on obtaining initial brackets for minima.
15:53:25 <hpaste> NihilistDandy pasted “Unsuccessful Te Build” at http://hpaste.org/48611
15:53:42 <ezyang> edwardk: Do you know of any constructions analogous to codensity which force left-associativity, as opposed to right associativity?
15:53:50 <shachaf> Is there no way to wait for a thread to fininish finish in Control.Concurrent?
15:54:14 <Xaratas> ski: ok exacty the homework want data Script a = Script (Store -> Exception a)
15:54:23 <dankna> okay so I see several problems in this
15:54:27 <dankna> I'm amazed building is going as far as it is
15:54:36 <ezyang> shachaf: I'd probably use an MVar.
15:54:36 <dankna> try this: install cabal-app, then reinstall cabal-install
15:54:46 <merijn> shachaf: I would assume there is, but if it doesn't exist it's easy to implement. Just have every thread write to a Chan when they're done and block on the chan
15:54:52 <Xaratas> ski: but then the store is in both parts, ok and error
15:54:54 <dankna> you are running a version of cabal-install which does not know of cabal-app's existence
15:55:10 <Do>  
15:55:10 <lambdabot> Do: You have 1 new message. '/msg lambdabot @messages' to read it.
15:55:21 <Do> @messages
15:55:22 <lambdabot> ezyang said 3m 59s ago: you know if there are any constructions that force "left associativity" the same way codensity forces right associativity?
15:55:24 <NihilistDandy> dankna: Do you mean me? Or was that to merijn?
15:55:25 <shachaf> ezyang: Right, that's what I'm doing. But it seems awkward.
15:55:36 <shachaf> Isn't "join" usually a pretty basic primitive for a threading library? :-)
15:55:45 <dankna> that was to both of you, actually, although I don't know why it's manifesting in different ways
15:56:01 <NihilistDandy> Fair enough. Reinstalling cabal-install now
15:56:38 <dankna> Warning: te.cabal: Unknown fields: c-source-dirs (line 29), objc-gc (line 85) -- I don't understand why this would be the case
15:56:47 <dankna> oh, you must not have successfully applied my patches against Cabal
15:56:48 <merijn> By reinstall you just mean running "cabal install" again, right?
15:56:52 <dankna> or you did but didn't rebuild everything successfully
15:57:01 <NihilistDandy> hmm
15:57:02 <ski> Xaratas : i thought your `Ok' and `Err' was in the error part, i.e. `Exception a' ?, not in `Store'
15:57:06 <dankna> I did mean that, but I just had an intuition the result of which is that you need to do slightly more :)
15:57:28 <merijn> Lemme try cleaning cabal-install before reinstalling
15:57:31 <dankna> cd cabal/cabal/ ; cabal clean ; cabal install ; cd ../cabal-install/ ; cabal clean ; cabal install
15:59:48 <dankna> you know what, I just realized, I might have used Lion-only APIs in this :( but I know where they are and how they can be commented out or made conditional
16:00:05 <dankna> so that you can at least get something running even if it isn't identical to my build here
16:00:28 <NihilistDandy> I've been thinking of moving up to Lion, anyway. How stable is the current dev build?
16:00:47 <merijn> Nothing helps smooth out a build process as the first handful of people trying to compile your code ;)
16:01:32 <dankna> pretty good, I scarcely have any crashes, but have you paid Apple their $100 to become a Mac developer? O_o  and if so, why did you do that and not download the build
16:01:46 <NihilistDandy> dankna: I said nothing about paying :P
16:01:49 <dankna> oh, you meant a pirated copy.  yeah that could work haha.
16:01:55 <NihilistDandy> lol
16:02:42 <merijn> I'm cheap skum, so I'm not moving up until I can buy the upgrade for much cheaper then the $100 to become a dev :p
16:02:43 <NihilistDandy> Do most Snow Leopard compatible things still work? Or am I going to lose a bunch of things if I decide to go that route?
16:03:06 <dankna> yeah, everything Snow Leopard still runs, in some cases better - my Spotlight and Time Machine had been broken before the upgrade and no longer are.
16:03:20 <NihilistDandy> Very nice
16:03:29 <NihilistDandy> Well, maybe that'll be my project for the night. :)
16:03:31 <dankna> merijn: I agree, I just wish cabal-app had been rolled into cabal first so you wouldn't have had to deal with those issues
16:04:14 <dankna> sounds like a plan :)
16:04:20 <merijn> Reinstalling cabal/cabal-install after installing cabal-app confuses cabal into thinking cabal-app is not installed
16:04:26 <dankna> oh weird
16:04:33 <dankna> oh
16:04:33 <dankna> right
16:04:37 <dankna> because the version hash bumped
16:04:40 <dankna> so it's in broken state
16:04:42 <NihilistDandy> Okay, so I've cleaned an redone cabal and cabal install
16:04:46 <NihilistDandy> *and
16:04:52 <dankna> I just remembered, the install order goes cabal, cabal-install, cabal-app
16:05:06 <dankna> cabal-install doesn't link against cabal-app, it sees it in the requirements field and builds Setup.hs against it.
16:05:14 <dankna> brain fart, sorry for the inconvenience
16:05:28 <NihilistDandy> So should I now clean and install cabal-app?
16:05:35 <dankna> NihilistDandy, okay, hmm.  yes you should.
16:05:35 <merijn> Anyhoo, it seem to always get stuck at "setup: Bad header file: AppDelegate.h"
16:05:47 <merijn> Which could very well be something Lion-y?
16:06:02 <dankna> no, that's a file in my code (Te/Mac/AppDelegate.h)
16:06:10 <merijn> odd
16:06:13 <dankna> what it means by "bad" is probably "can't be found"
16:06:26 <dankna> which was caused in at least one of the warnings you pasted at me by the c-source-dirs: field not being recognized
16:06:36 <dankna> because that field was added by one of my patches against Cabal
16:06:50 <dankna> which means you're not running a version of cabal-install that has properly linked against a version of the Cabal library that includes those patches
16:06:52 * NihilistDandy crosses finger
16:06:52 <dankna> how could that be?
16:06:55 <NihilistDandy> *fingers
16:07:31 <merijn> I installed everything as --user, maybe that causes things to get confused?
16:07:40 <dankna> nah, that should be fine
16:08:15 <merijn> I ran "cabal clean; cabal install --user" in the order cabal -> cabal-install -> cabal-app
16:08:25 <NihilistDandy> Same
16:08:40 <dankna> that should be fine
16:08:56 <dankna> what does cabal --version say?
16:08:57 <NihilistDandy> And during the linking phase I see "Loading package Cabal-1.11.0 ... linking ... done."
16:09:05 <dankna> hmmm okay
16:09:12 <NihilistDandy> Still says "cabal-install version 0.10.0
16:09:12 <NihilistDandy> using version 1.10.2.0 of the Cabal library "
16:09:12 <int80_h> http://hpaste.org/48612
16:09:20 <NihilistDandy> For reasons I can't fathom
16:09:47 <dankna> okay, so Setup.hs is linking against the newer Cabal library but the cabal-install is not, which will probably cause problems
16:10:54 <NihilistDandy> I had a similar problem on GHC 6.12. I installed the new Cabal lib and reinstalled cabal-install, but it kept linking against the old library
16:11:00 <NihilistDandy> Maybe ghc-pkg hide?
16:11:28 <dankna> I think there's some flag to "cabal install" which tells it which version of a dependency to use
16:13:06 <NihilistDandy> --constraint?
16:13:36 <NihilistDandy> Oh, wait
16:13:38 <NihilistDandy> duh
16:13:44 <NihilistDandy> --cabal-lib-version
16:13:57 <dankna> ah, haha, okay
16:14:26 <int80_h> are we only three here?
16:14:34 <int80_h> heh
16:15:16 <merijn> Everybody else is out having a life on friday night :p
16:15:21 <NihilistDandy> Now let's try that again
16:15:22 <dankna> int80_h: runErrorT returns a value, so it's implicitly _ <- runErrorT makeIDPage
16:15:23 <jdhky`> does anyone know a good example project that uses numeric-prelude?
16:15:47 <dankna> int80_h: does the error go away if you stick "return ()" after it on a new line?
16:16:24 * NihilistDandy sights
16:16:26 <NihilistDandy> *sighs
16:16:30 <dankna> still problematic?
16:16:38 <NihilistDandy> Still says 1.10.2.0
16:16:41 <NihilistDandy> :/
16:17:36 <merijn> yeah, still going wrong here as well
16:18:42 <dankna> sorry, I just debugged a problem with my cats - they needed water, haha :) I was wondering why they were looking at me when they'd already eaten
16:18:43 <NihilistDandy> Ooh, the Lion GM is out. If that's not enough to convince me, I don't know what is :D
16:18:43 <dankna> back now
16:19:48 <dankna> give me the output of cabal --version
16:20:01 <NihilistDandy> cabal-install version 0.10.0
16:20:02 <NihilistDandy> using version 1.10.2.0 of the Cabal library
16:20:12 <_pr0t0type_> Wow, this is amazing.
16:20:16 <NihilistDandy> Which is confusing, because:
16:20:17 <NihilistDandy> cabal-install version 0.10.2
16:20:17 <NihilistDandy> using version 1.10.2.0 of the Cabal library
16:20:27 <NihilistDandy> Is what I get from the one in /usr/local
16:20:32 <dankna> wait what
16:20:45 <NihilistDandy> My thoughts exactly
16:20:48 <_pr0t0type_> the Haskell irc channel is much more popular than the lisp and scheme channels.  I think I see a pattern...
16:20:50 <dankna> okay, try this again using the full path to /usr/local/bin/cabal for all commands
16:20:55 <dankna> wait no
16:20:59 <dankna> that'll be wrong, hm
16:21:02 <dankna> because that's the old one
16:21:27 <merijn> $ ~/.cabal/bin/cabal --version
16:21:27 <merijn> cabal-install version 0.10.0
16:21:27 <merijn> using version 1.10.2.0 of the Cabal library
16:21:32 <dankna> okay, so.  check the version number of the Cabal library listed at the top of cabal/cabal/Cabal.cabal (how's that for a filename) in your checked-out copy
16:21:36 <merijn> <-- confused
16:22:00 <NihilistDandy> dankna: Name: Cabal
16:22:00 <NihilistDandy> Version: 1.11.0
16:22:05 <merijn> Same
16:22:38 <NihilistDandy> But then 0.10.0 in the cabal-install.cabal
16:22:38 * ski lazily wonders what pattern _pr0t0type_ might be seeing ..
16:22:45 <dankna> that's fine
16:22:55 <NihilistDandy> fair enough
16:23:14 <dankna> I wish dcoutts were here
16:23:24 <dankna> sometimes saying his name three times summons him, like Beetlejuice or Hastur...
16:24:01 <NihilistDandy> +1 for the Hastur reference
16:24:07 <dankna> thank you.
16:24:37 <NihilistDandy> I'm a bit tempted at this point to move to Lion and build everything from scratch :D
16:24:43 <dankna> haha
16:24:49 <dankna> that'll take your whole night, but if you want to, go for it
16:25:02 <dankna> the install itself is relatively quick, but then you have to install a new everything-else
16:25:05 <merijn> I still have a mental barrier that causes me to never say the name three times in the "What a stupid scroll, it just says Hastur, Hastur, Hastur, over and over again" joke :p
16:25:16 <dankna> haaaaa I see
16:25:34 <NihilistDandy> It's only a few dependencies to get cabal-install back up, and I can just put my ghc-pkg list in a text file
16:26:27 * merijn is hoping that was the sound of epiphany :p
16:26:45 <NihilistDandy> Oh, wait
16:26:51 <NihilistDandy> Uh, I think I see the issue
16:27:05 <NihilistDandy> From cabal-install.cabal:
16:27:06 <NihilistDandy> Cabal    >= 1.10.1   && < 1.11,
16:27:20 <NihilistDandy> ...
16:27:46 <_pr0t0type_> ski: it's funny, because talking to the lisp-dialect guys, they almost have me convinced that anything purely funcitonal is useless in terms of writing anything practical.
16:27:55 <dankna> oh!
16:28:12 <dankna> yeah I bet I changed that and didn't record the change because it's not my place to do so
16:28:16 <dankna> (it's Duncan's)
16:28:38 <NihilistDandy> Should I just edit out the upper bound?
16:29:01 <dankna> that could work.  or change the dep to >= 1.11 && < 1.12,
16:29:18 <NihilistDandy> That's a nicer way, I think
16:29:21 <dankna> yeah
16:29:31 <nus> wait, is this a local HEAD build?
16:29:43 <dankna> nus: of cabal?  yes
16:29:50 <nus> no, of ghc
16:30:03 <dankna> nus: sorry, were you talking to us?
16:30:21 <nus> yes, I believe /usr/loca/bin/ghc was mentioned, no?
16:30:32 <dankna> oh, no, we were talking about cabal, not ghc
16:30:33 <merijn> no, cabal :)
16:30:51 <dankna> I have my Cabal set up to put the compiler name and version in the path used for global installs
16:30:51 <nus> oh
16:30:52 <merijn> w00t!
16:30:57 <dankna> so that I can have multiple compiler versions in parallel
16:31:03 <merijn> cabal-install version 0.10.0
16:31:03 <merijn> using version 1.11.0 of the Cabal library
16:31:09 <dankna> merijn: ah excellent!
16:31:30 <NihilistDandy> Compiling now, assuming success :D
16:31:45 <dankna> excelling!  well, it will fail when it gets to the Lion-dependent parts
16:32:01 * merijn cries
16:32:14 <merijn> setup: Bad header file: AppDelegate.h
16:32:30 <dankna> what are the first few lines of the warnings
16:32:33 <merijn> Or do I need to reinstall cabal/cabal-install again after compiling cabal-app
16:32:34 <dankna> or the whole thing, even
16:32:44 <ski> _pr0t0type_ : you can do imperative programming just fine in Haskell ..
16:32:47 <dankna> no, you need to reinstall them again /before/ compiling cabal-app
16:32:49 <cmccann> reinstall everything, including the operating system
16:32:53 <cmccann> in fact, buy a new computer as well
16:33:09 <cmccann> and a new desk, just to be sure
16:33:19 <NihilistDandy> Burn your house down
16:33:26 <dankna> new desk lol
16:35:29 <NihilistDandy> Okay, currently clean/install'ing Cabal, cabal-install, cabal-app, and then trying Te again
16:35:35 <Peaker> Prototype: purely functional means different things to different people. To Haskellers it means separation of effects from pure computations at the type level so some of the language (functions) gains guaranteed purity while you still have effectful powers
16:35:53 <NihilistDandy> Also lighting candles and swearing oaths to Curry
16:36:10 <merijn> Also Church
16:36:27 <NihilistDandy> And Turing and Dijkstra, for good measure
16:36:32 <Peaker> It's not a ban of effects but a quarantine/separation
16:37:20 <merijn> _pr0t0type_: Well, purely functional *is* useless for practical programming. However a type system nicely separating pure from non-pure code in a consistent and safe way is very nice :)
16:37:36 <merijn> Allowing you to make use of purity as much as possible
16:37:49 <cmccann> separating effects from pure functions isn't even unique to Haskell, it's just more stubborn about it
16:38:01 <cmccann> in OOP you might call it "command/query separation" instead
16:38:09 <hpc> (Haskell \\ (IO + ST)) = pure?
16:39:06 <cmccann> I seem to recall that some oldschool procedural languages distinguished between functions and procedures, as well, which had a lot of the same result
16:40:08 <ski> hpc : Haskell is pure, *including* `IO' and `ST s'
16:40:10 <cmccann> some databases also enforce purity in places because pure functions can be optimized differently in queries
16:40:25 <merijn> dankna: No longer see the c-source-dir warning, but still complains about Bad header file: AppDelegate.h after recompiling everything
16:40:26 <mauke> hah, when I first read about pascal I assumed that was the difference between function and procedure
16:40:41 <mauke> except I only had a vague idea of what purity is
16:40:49 <dankna> okay!  that's progress!
16:41:12 <c_wraith> cmccann: as a specific example, postgres allows you to index the result of a function, but only if that function was marked as pure.  (which they call "immutable" out of some great sense of confusion)
16:41:13 <NihilistDandy> Same
16:41:16 <dankna> do "cabal configure -v3 2>&1 foo.txt" from the Te directory and hpaste foo.txt at me
16:41:17 <NihilistDandy> But progress!
16:41:17 * ddarius hates languages with meaningless distinctions between "functions" and procedures.
16:41:39 <cmccann> mauke, heh, it's more obscure languages I'm sorta recalling, but I may be mangling the terminology to match your assumption about Pascal for the same reasons, I don't recall clearly
16:41:43 <dankna> (2>&1 is bash for "stderr to stdout")
16:41:59 <ski> cmccann : you might be thinking of Pascal or Ada, maybe ? .. note that both of those could perform effects
16:42:04 <mauke> dankna: did you mean > foo.txt 2>&1
16:42:47 <cmccann> ski, I have no idea what I'm remembering honestly, just details about stuff that seemed interesting at the time
16:42:56 * ddarius should become a professor of hydrodynamics so he can get his students to do his dishes.
16:42:57 <dankna> mauke: I think I meant what you just said, yes
16:43:02 <dankna> ddarius, hah!
16:43:17 <hpaste> NihilistDandy pasted “dankna stderr” at http://hpaste.org/48613
16:43:28 <NihilistDandy> pbcopy is the best thing ever :D
16:43:44 <dankna> it is!
16:43:53 <merijn> lhttp://www.few.vu.nl/~mvn540/foo
16:43:56 <merijn> eh
16:44:02 <merijn> minus the first letter, obv
16:44:27 <dankna> okay so the failure isn't in configure, I guess.  try "cabal build -v3" and, again, show me the output, which will be voluminous so you'll want to redirect it.
16:45:28 <hpaste> NihilistDandy pasted “dankna build” at http://hpaste.org/48614
16:46:00 <merijn> http://www.few.vu.nl/~mvn540/cabalbuild
16:46:22 <NihilistDandy> Oh, you know what? I forgot to configure with --user
16:46:27 <NihilistDandy> Let me try that again
16:46:45 <dankna> oh hm
16:47:13 <merijn> I did and the error looks the same
16:47:15 <dankna> okay so you're getting the "linking is not being done" problem
16:47:29 <dankna> I remember having that at some point during development
16:47:32 <dankna> some Cabal issue
16:47:35 <dankna> but I fixed it, or so I thought
16:47:38 <hpaste> NihilistDandy annotated “dankna build” with “dankna build (annotation)” at http://hpaste.org/48614#a48615
16:47:49 <ezyang> I am just about to embark on a journey to implement an incremental computation network in Yampa. Wish me luck! :-)
16:47:51 <NihilistDandy> merijn: So I see
16:48:44 <merijn> Anyway, it's really getting to the point where I need to head to bed
16:49:06 <dankna> okay, no problem.  thanks for sticking with it.  I'll continue trying if NihilistDandy still wants to, and @tell you the solution if we find it
16:49:18 <NihilistDandy> I'm up for it
16:49:20 <dankna> great
16:49:33 <merijn> 'night! :)
16:49:40 <NihilistDandy> Adios, merijn
16:49:59 <ezyang> Unfortunately, there seems to be some sort of gap on the coverage of systems that have no notion of continuous time.
16:50:10 <ezyang> probably because FRP is overkill for such cases. But that's OK.
16:51:08 <int80_h> http://hpaste.org/48612
16:52:20 <dankna> NihilistDandy, okay so? the way my modified Cabal builds multi-language binaries is,
16:52:51 <dankna> it first invokes ghc --make -c with all the Haskell modules.  this has to come before the C build so that any autogenerated _stub.h files will exist.
16:52:59 <NihilistDandy> Okay
16:53:01 <dankna> it then invokes gcc one file at a time for each C file
16:53:07 <dankna> it then invokes ghc --make one last time to do the link
16:53:21 <dankna> I'm not even clear from this log on which of those steps it's failing at
16:53:26 <dankna> although I'm still reading it
16:53:35 <dankna> I'm just providing this information so you can help me look
16:54:14 <NihilistDandy> I can try recompiling some of the problematic deps with the new cabal and see if that clears anything up
16:54:53 <dankna> that's a good thought
16:56:19 <NihilistDandy> Though, actually, from the sheer volume, that might take a while. Might be faster just to empty my .cabal and start from scratch
16:56:33 <NihilistDandy> I don't have anything deeply important in there that I can't get back afterward
16:56:41 <dankna> hmm
16:56:53 <dankna> up to you.  I don't see how it's related, especially since merijn was getting the identical failure.
16:57:31 <edwardk> ezyang: not off hand (was afk trying to wrestle an air conditioner into a window)
16:57:36 <NihilistDandy> True
16:57:51 <dankna> okay so actually
16:57:54 <dankna> I read this log
16:58:01 <edwardk> ezyang: plus in general that isn't same. you can always right associate but in most monads more than finitely left associating doesn't terminate
16:58:04 <dankna> and I suspect the problem may now occur even for me, if I rebuild/reinstall cabal/cabal-install/cabal-app
16:58:10 <dankna> because of bitrot in my patches
16:58:16 <NihilistDandy> Ah, I see
16:58:30 <dankna> in that case you probably won't be able to build tonight, I'll have to debug it
16:58:40 <dankna> now might be a good time to take a break and install Lion if you're determined to steal it :)
16:58:51 <edwardk> @type \n -> fix $ \m -> m >> n
16:58:52 <NihilistDandy> My thoughts exactly
16:58:52 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> m b
16:58:53 <NihilistDandy> :D
16:58:59 <NihilistDandy> It'll be done in less than 10 minutes
16:59:32 <dankna> lol
16:59:56 <ezyang> yes, that was my intuition too.
17:00:03 <ezyang> but I wonder if bind was sufficiently lazy...
17:00:05 <NihilistDandy> Just have to make sure I back up anything important, and I'll be good to go
17:00:08 <dankna> nodnod
17:00:17 <ezyang> that sounds more like a comonad though.
17:00:36 <edwardk> i encourage you to find me nice examples =)
17:01:19 <nus> int80_h, "initial = urlInitial urlSequence" what is that supposed to mean?
17:01:23 <NihilistDandy> dankna: What does `ruby --version` return on Lion, anyway?
17:01:41 <NihilistDandy> I'm curious if they've bothered to update it
17:01:41 <dankna> 1.8.7
17:01:50 <NihilistDandy> And... of course they haven't :D
17:01:53 <dankna> ha
17:04:10 <int80_h> nus: that refers to a record
17:04:41 <int80_h> nus: I will paste the record's definition
17:05:39 <nus> int80_h, the '=' sign?
17:06:31 <hpaste> int80_h annotated “what's the problem here?” with “what's the problem here? (annotation)” at http://hpaste.org/48612#a48616
17:07:27 <int80_h> nus: the = refers to let
17:07:57 <int80_h> to a let binding I mean
17:08:20 <nus> int80_h, you're in the do's scope
17:08:23 <HugoDaniel> hi
17:09:16 <kaol> @hoogle Ordering -> Ordering
17:09:17 <lambdabot> Prelude pred :: Enum a => a -> a
17:09:17 <lambdabot> Prelude succ :: Enum a => a -> a
17:09:17 <lambdabot> Prelude id :: a -> a
17:09:42 <int80_h> nus: I see, I remove those let binding's from the do's scope, and that should remove the error?
17:39:52 <ivanm> anyone know what kind of type "stg_ap_2_upd_info" is from doing +RTS -hy ?
17:40:56 <dankna> I'd guess that it's an "ap" update info from the stg layer, whatever an ap is
17:41:13 <ivanm> heh
17:41:15 <kmc> you could ask #ghc
17:41:18 <cmccann> :t ap
17:41:18 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
17:41:22 <cmccann> there you go, that must be it
17:41:26 <kmc> my guess is that it's the info table for an update frame on the stack
17:41:34 <kmc> for a 2-ary closure?
17:41:34 <ivanm> hmmm...
17:41:43 <kmc> i suggest grepping ghc source
17:41:50 <c_wraith> I'm pretty sure ap is the stg op for a thunk applying a function to arguments
17:42:00 <Enigmagic> c_wraith: yep
17:42:12 <dankna> oh!  then I agree with kmc's guess
17:42:24 <ivanm> so if I have a large amount of memory being used by it, does that mean that a lot of large functions are being passed around?
17:42:26 <dankna> except it can't be on the stack
17:42:29 <dankna> it's on the heap
17:42:34 <dankna> or -hy wouldn't have reported it
17:42:43 <c_wraith> yes, thunks are on the heap anyway
17:43:26 <kmc> but update frames live on  the stack
17:43:39 <kmc> maybe it's an indirection resulting from an update?
17:45:26 <Enigmagic> ivanm: i don't think it directly allocates any memory from the heap..
17:46:46 <ivanm> Enigmagic: well, whatever this is it both -hy and -hd report it taking a largeish (albeit diminishing) amount of memory
17:46:56 * ivanm still has no idea why doing a "length ms `seq` ms" improves maximum memory usage and in some cases speed
17:47:29 <ivanm> could it be that for all intents and purposes I'm doing a lot of recursive function calls which produce lists that I'm then concat'ing together?
17:48:58 <nus> "stg_ap_2_upd_info is a generic thunk implementation in the RTS ... perhaps when profiling we should avoid using these to give you more information. Cheers, Simon"
17:49:04 <nus> heh
17:52:22 <ivanm> heh
17:52:27 <ivanm> nus: where did you find that?
17:53:16 <nus> first thing that comes up googling for stg_ap_2_upd_info (-:
17:54:03 <nus> read the thread, though
17:54:55 <ivanm> duh :)
18:37:09 <lpsmith> In some ways GHC is a little too magical for my taste.  Attempt to understand low-level performance characteristics usually leaves me more confused than when I started
18:37:37 <pikhq_> So we have a sufficiently intelligent compiler.
18:38:23 <lpsmith> but, it's not just GHC,  the whole stack has become difficult to comprehend from a performance standpoint.
18:38:46 <kmc> yeah
18:39:10 <kmc> the performance characteristics of an abstract graph reduction machine are, if not difficult, certainly different from what most people have encountered
18:39:42 <pikhq_> It's pretty hard to understand all the performance characteristics of more "normal" languages on "normal" CPUs, anyways.
18:39:59 <cmccann> on the other hand, I rather like being able, in most cases, to just write things in a way that makes sense and get performance that's "good enough"
18:40:01 <kmc> it's easy to think you understand, though ;)
18:40:23 <pikhq_> Or, indeed, even if you're programming in straight assembly. ISAs are pretty abstracted from how hardware functions these days.
18:40:24 <cmccann> even if hardcore optimizing is trickier than usual (and usual is harder than most people realize anyway)
18:40:27 <gienah> heh we could hack something with haskell-src-exts that uses genetic programming to add bang patterns and test with criterion to evolve it to a program with higher performance :-)
18:40:33 <dylukes> kmc: Any suggestions for hosting/title?
18:40:37 <kmc> shrug
18:40:40 <dylukes> I think using a blog as a mock-portfolio would be a good idea.
18:40:41 <kmc> my blog is on blogspot
18:40:41 <pikhq_> Caching and pipelining *alone* pretty well confuse things.
18:40:42 <lpsmith> heh,  I know some algorithms guys who say that they finally think they understand the performance of C,  after 30 years of effort.   I can understand why the AoP is written in assembly
18:40:43 <kmc> it's all right
18:40:46 <dylukes> kmc: Which is your blog btw?
18:40:54 <kmc> http://mainisusuallyafunction.blogspot.com/
18:41:03 <dylukes> oh I've seen this blog before.
18:41:05 <cmccann> honestly, I'm not sure if GHC's performance characteristics are any harder to follow than all the stuff about caches and pipelines and branch prediction and whatnot in modern CPUs
18:41:12 <dylukes> what do you use for highlighting btw?
18:41:22 <kmc> pandoc
18:41:25 <dylukes> figures.
18:41:31 <dylukes> wait, what.
18:41:37 <dylukes> how does pandoc do highlighting?
18:41:47 <kmc> dunno
18:41:59 <kmc> i write in markdown+lhs
18:42:02 <kmc> it converts to html
18:42:06 <copumpkin> kmc: is main actually usually a function?
18:42:07 <pikhq_> lpsmith: I can almost guarantee they don't actually understand the performance of their C stack.
18:42:12 <kmc> it can highlight other languages too
18:42:15 <kmc> copumpkin, in C yes
18:42:19 <kmc> that's a GCC warning message
18:42:22 <dylukes> kmc: Nah, its _main
18:42:25 <kmc> ;P
18:42:34 <copumpkin> pff, start is where it's at
18:42:40 <dylukes> I could rip you off and put "_start is usually an entry point"
18:42:41 <copumpkin> who needs the c standard library
18:42:44 <kmc> just set the ELF entry point yourself
18:42:45 <ddarius> 0x7C00
18:42:51 <copumpkin> pff, elf is weak
18:43:13 <kmc> load your code at the reset vector and then triple-fault the CPU
18:43:14 <dylukes> could someone fix GHC on OS X already :(
18:43:16 <dylukes> I can't compile anything.
18:43:19 <dylukes> I can interpret though.
18:43:24 <ddarius> Yay triple faulting.
18:43:31 <kmc> dylukes, install linux
18:43:46 <dylukes> I guess I could through up a virtual box for it.
18:43:49 <dylukes> throw*
18:43:53 <olsner> ddarius: ooh! that means you have reached bare metal :D
18:44:19 <dylukes> brb
18:44:19 <kmc> you haven't reached bare metal until you soak your chip in HF
18:44:26 <ddarius> kmc: Indeed.
18:44:46 <olsner> kmc: :)
18:44:51 <ddarius> There's nothing that can't be solved with HF.
18:45:05 <kmc> such as a surplus of bones
18:46:16 <dylukes> HF?
18:46:21 <dylukes> oh
18:46:22 <dylukes> right
18:46:35 <ddarius> http://pipeline.corante.com/archives/things_i_wont_work_with/
18:46:46 <cmccann> that's the stuff that soaks into you and dissolves stuff, right?
18:47:01 <pikhq_> cmccann: Yes, it is the scariest acid.
18:47:20 <lpsmith> I thought the scariest acid was HF
18:47:32 <lpsmith> oh wait, somebody already mentioned that
18:47:36 <cmccann> yeah
18:48:51 <Eduard_Munteanu> ClF3 is quite scary too.
18:49:08 <pikhq_> *F* is generally scary.
18:49:19 * Eduard_Munteanu read something about that on that blog recently.
18:49:51 <ddarius> That blog's subseries is hilarious.
18:49:51 <ezyang> Aqua Regia is pretty scary.
18:50:00 <Eduard_Munteanu> Heh, but it keeps tooth decay away! :)
18:50:45 <lpsmith> NaF is wonderful stuff in the right context
18:50:58 <lpsmith> Flourinated water doesn't really make any sense to me though
18:51:22 <kmc> it's a communist conspiracy
18:51:26 <lpsmith> heh
18:52:03 <lpsmith> I am a strong believer in flourinated toothpaste.  And the occasional mouthwash
18:52:21 <cmccann> kmc, corrupting our precious bodily fluids no doubt
18:52:38 <lpsmith> purity of essence,  that's the key
18:52:58 <lpsmith> there needs to be a hackage package purity-of-essence.   What should it do?
18:53:24 <ddarius> "Owing to the extreme instablity of the compound accurate determinations of the bioing and melting points have not been made as yet. Numerous explosions, often without assignable cause, have occurred during the experiments. . ."
18:53:39 <lpsmith> heh yeah, I found that funny
18:53:48 <ddarius> The whole thing is that way.
18:54:06 <pikhq_> lpsmith: Water flouridation has been demonstrated to improve dental health significantly. Which is why we do it.
18:54:55 <cmccann> lpsmith, I assume it would launch the missiles, then break off radio contact
18:55:21 <lpsmith> pikhq_: has it?   Does it significantly improve dental health in people who regularly brush their teeth with fluoride toothpaste?
18:56:45 <pikhq_> lpsmith: I dunno how much it does improve health in people who regularly use fluoridated toothpaste.
18:57:22 <confound> kids generally can't use fluoride toothpaste, so I expect it helps them most
18:57:30 <pikhq_> lpsmith: I just know that it started because there was a notable improvement in dental health in regions where the water was naturally high in fluoride.
18:57:44 <cmccann> ahahahaha, "At seven hundred freaking degrees, fluorine starts to dissociate into monoatomic radicals, thereby losing its gentle and forgiving nature. But that's how you get it to react with oxygen to make a product that's worse in pretty much every way."
18:57:51 <pikhq_> And so research was done and, yes, fluoride itself improved teeth.
18:58:03 <pikhq_> So, well, there it went.
18:59:17 <Eduard_Munteanu> AFAIR, brushing doesn't really bring any significant benefit in reducing decay.
18:59:18 <lpsmith> yeah, I'm aware.  That was in Utah IIRC,  where the dental advantages of fluoride were discovered
18:59:26 <pikhq_> Also Colorado.
18:59:35 <Eduard_Munteanu> It only prevents gum disease for the most part.
18:59:37 <pikhq_> (where they generally have to *remove* fluoride)
18:59:49 <ddarius> Eduard_Munteanu: That's pretty significant.
19:00:14 <Eduard_Munteanu> Decay is for the most part a dietary issue, maybe combined with hereditary stuff.
19:00:16 <lpsmith> I'm slightly obsessive compulsive about brushing
19:00:20 <Eduard_Munteanu> ddarius: yeah, I didn't mean it wasn't.
19:00:28 <parcs> doesn't flouridated water increase the risk of mouth and throat cancer
19:00:31 <Eduard_Munteanu> Bushmen lose their teeth, only not to caries.
19:00:49 <pikhq_> parcs: News to me.
19:01:04 * cmccann wonders how a bunch of references to a satirical movie turned into a serious discussion of dental hygiene
19:01:22 <pikhq_> cmccann: Conversations with nerds are bizarre like that. :)
19:01:50 <kmc> where "bizarre" = "not incredibly boring"
19:02:23 <pikhq_> kmc: Sadly, that is indeed bizarre.
19:04:58 <cmccann> well, I was mostly hoping for some chance to use a variant on the "you can't fight in here, this is the war room" quote
19:05:08 <cmccann> but dental hygiene is fine too
19:05:15 <pikhq_> cmccann: Heheh.
19:09:12 <dankna> the war room quote is indeed a brillaint line and I share your disappointment for not getting to use it :)
19:15:02 <Ndandy> dankna: Oh. My. God.
19:15:11 <cmccann> though I think the most impressive thing about that movie might be how well Sellers handled playing multiple roles
19:15:44 <Ndandy> dankna: Lion is pretty slick.
19:15:55 <dankna> isn't it :D
19:15:58 <Ndandy> Though the whole reversed scroll thing is gonna take some getting used to
19:16:03 <dankna> yeah, not as much as you'd expect
19:16:31 <dankna> I thought that would be a problem too, but it wasn't really much of one.  but some of us signed an NDA and can't talk about it in public :)
19:16:32 <Ndandy> Just getting Xcode downloaded, and then onto building ghc :D
19:16:41 <Ndandy> Ah, yes
19:16:48 <Ndandy> Hush hush and so on
19:32:46 <ddarius> "Hydrogen sulfide, for example, reacts with four molecules of FOOF to give sulfur hexaflouride, 2 molecules of HF and four oxygens... and 433 kcal[...]"
19:33:47 <ddarius> 1 kcal raises 1 kg of water 1 degree Celsius.  So four moleculs of FOOF would turn a gallon of just melted ice to boiling water.
19:36:52 <cmccann> ah, chemistry
19:37:08 <cmccann> how far we've advanced since the days when alchemists would merely poison themselves gradually
19:37:54 <ddarius> Today is a day of instant gratification.
19:38:51 * sanjoyd used to like organic chemistry.
19:39:00 <sanjoyd> Drawing benzene was great fun.
19:47:05 <Eduard_Munteanu> I actually like looking for analogs in chemistry and seeing how they compare. An example would be Si-based organic chemistry.
19:47:56 <Eduard_Munteanu> Or how some rarer/heavier elements can (partly) substitute other stuff in living organisms.
19:49:29 <cmccann> organic chemistry doesn't really work with silicon, though
19:50:00 <Eduard_Munteanu> Yeah, its extent is greatly reduced, but still.
19:50:05 <cmccann> it's far from interchangeable with carbon, despite being in the same column
19:50:26 <cmccann> if memory serves me its weight makes it not reactive enough
19:51:13 <Eduard_Munteanu> AFAIK, it's the radius of the Si atom that makes long chains harder to make.
19:51:16 <cmccann> and there's no obvious equivalent to the ubiquitous roles of CO2 and O2
19:51:31 <cmccann> yeah, weight or size or something, I don't recall
19:53:03 * Eduard_Munteanu kinda likes trying to guess properties of elements/compounds, though he knows that usually requires more complicated models to get right.
19:53:19 * cmccann points out that respiration involving SiO2 is unlikely to work well at anything resembling the temperature/pressure/etc. environment on Earth
19:53:21 <sanjoyd> Fun pretending atoms and molecules are people.
19:53:26 <Eduard_Munteanu> But anyway, I sometimes browse wikipedia a lot on that sort of stuff :)
19:54:11 <cmccann> Eduard_Munteanu, things are pretty consistent I think everywhere except the diagonal line where all the funny quasi-metallic elements and such are
19:54:32 <Eduard_Munteanu> cmccann: it makes me wonder whether there isn't a temperature/pressure point where Si stuff gets to be a bit more similar to C.
19:54:34 <ezyang> I wonder if Conal ever implemented "Push-pull functional reactive programming"
19:56:10 <Eduard_Munteanu> cmccann: that's quite easy to explain if you consider the relation between electronegativity and atomic radius
19:56:29 * cmccann doesn't really know much about chemistry, heh
19:57:02 <Eduard_Munteanu> Bigger atoms tend to lose electrons easier so that's why you get more metals in higher periods.
19:57:10 <ddarius> Electronegativity and atomic radii do explain quite a bit.
19:57:59 <Eduard_Munteanu> Well I guess the radius contraction kinda goes against that, but still.
19:58:11 <Eduard_Munteanu> (lanthanide contraction IIRC)
20:00:20 <cmccann> Eduard_Munteanu, sorry, out of my depth :P I know precisely enough chemistry to vaguely comprehend how little I understand any of it
20:00:44 <Eduard_Munteanu> Ah.
20:00:53 <sanjoyd> cmccann: are you very active on SO?
20:01:08 <cmccann> sanjoyd, I answer Haskell questions now and then
20:01:08 * Eduard_Munteanu even has a bit of intuitive understanding of how d orbitals fill.
20:01:23 * sanjoyd remembers seeing the nick somewhere.
20:02:09 <Eduard_Munteanu> But I still can't see how in the world that SF6 thingy is stable :)
20:03:06 <cmccann> sanjoyd, ah well, to be serious then, yes I answer rather a lot of Haskell questions on SO
20:03:24 <Eduard_Munteanu> I suppose at some point one just has to trust the math and some complicated models.
20:05:00 * hackagebot haskell-tyrant 0.4 - Haskell implementation of the Tokyo Tyrant binary protocol  http://hackage.haskell.org/package/haskell-tyrant-0.4 (PeterScott)
20:07:27 <cmccann> Eduard_Munteanu, yeah, I mean I have a rough understanding of some of the physics, but once things start interacting I get lost trying to understand why things happen in particular ways
20:09:09 <sniperliu> \quit
20:09:37 <Eduard_Munteanu> The other way around. :)
20:09:47 <Eduard_Munteanu> /quit
20:09:48 <ddarius> tiuq/
20:09:52 <Eduard_Munteanu> Heh.
20:10:18 <ddarius> Though I guess that should have been tiup/
20:17:46 <parcs> ʇınb/
20:18:27 <cmccann> "It is, of course, extremely toxic, but that's the least of the problem. It is hypergolic with every known fuel, and so rapidly hypergolic that no ignition delay has ever been measured. It is also hypergolic with such things as cloth, wood, and test engineers, not to mention asbestos, sand, and water--with which it reacts explosively."
20:19:21 <cmccann> gotta love a compound that's a stronger oxidizer than oxygen and happily burns things that are already burnt to a crisp
20:22:31 <ddarius> Chlorine triflouride I see.
20:22:47 <cmccann> Yep
20:22:53 <Eduard_Munteanu> Yeah, that's mean.
20:59:41 <lpsmith> There is a way to see the output of the strictness analyzer,  but I'm not recalling what that is.
21:00:01 <copumpkin> someone should write a library called twiteratee
21:00:07 <copumpkin> twitteratee
21:01:25 <lpsmith> hahaha
21:01:36 <Eduard_Munteanu> lpsmith: -ddump-stranal ?
21:01:44 <lpsmith> Eduard_Munteanu: thank you
21:02:09 <ddarius> twitter is retarded
21:03:09 <Eduard_Munteanu> Yeah, I don't get it either.
21:03:35 <chrisdone> Evening.
21:03:35 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
21:03:46 <copumpkin> twittarded
21:03:58 <copumpkin> ddarius: when do you depart for your trip?
21:05:25 <ddarius> copumpkin: The 14th.
21:05:32 <dolio> Wow, I was way off.
21:05:52 <chrisdone> benmachine: Poke.
21:11:18 <parcs> > let foo :: [long_type_argument] ~ a => a -> a; foo = id in foo [5]
21:11:18 <lambdabot>   [5]
21:12:04 <parcs> @kind (->)
21:12:05 <lambdabot> ?? -> ? -> *
21:14:44 <parcs> is (->) the only type constructor with a kind involving ?s
21:17:33 <scooty-puff> i'm working on a happy grammar file where { } is both a valid block and a valid object literal (the language is similar to javascript)
21:17:42 <parcs> looks like i can't annotate type parameters with kinds involving ?
21:17:55 <scooty-puff> it gives a reduce/reduce error, but i can't force unexpected behaviour
21:18:11 <scooty-puff> (semicolons are required, and extraneous ones are disallowed)
21:19:19 <parcs> what does ? mean in the context of kinds, anyway? is it a catch-all for any kind of kind?
21:20:01 <sanjoyd> parcs: ? includes unboxed values, I think.
21:20:19 <ddarius> Exercise: The law of diffusion states that ∂N/∂t = k∇^2N where N is a "particle density" say.  Derive this from first principles and outline its domain of validity.
21:21:09 <sanjoyd> First principles? F = ma? Or Schrodingers?
21:21:53 <ddarius> Whichever.  It doesn't really matter in this case.
21:22:05 * sanjoyd is only kidding.
21:22:36 <ivanm> wait, is this #haskell or ##physics?
21:22:57 <sanjoyd> This is a functor between the two.
21:24:47 <chrisdone> $ cabal-dev install --with-preference haskell-src-exts-1.10.2
21:24:47 <chrisdone> unrecognized option `--with-preference'
21:24:51 <chrisdone> Nooo! \o\
21:26:00 <ivanm> something from cabal-install that isn't in cabal-dev I take it?
21:28:31 <chrisdone> Even cabal-dev can't save me from the diamond dependency problem. :-(
21:30:06 <chrisdone> ivanm: Nah it was `--preference'. Still doesn't install. Local cabal-dev, fine. VPS cabal-dev, DDP.
21:30:18 <ddarius> :k (#,#)
21:30:19 <lambdabot> ? -> ? -> (#)
21:30:26 <ivanm> chrisdone: different version?
21:31:26 <chrisdone> ivanm: I think the package set is more/less out of date than the other system.
21:31:37 <ivanm> heh
21:31:53 * chrisdone manually tells all the packages to stop being silly
21:33:44 <Eduard_Munteanu> ddarius: that doesn't seem possible without some notion of thermodynamics I think.
21:34:07 <Eduard_Munteanu> (why would they diffuse at all, if you ignore td?)
21:34:47 <chrisdone> $ cabal-dev install hsx --preference=haskell-src-exts==1.10.2
21:34:48 <chrisdone> Resolving dependencies...
21:34:48 <chrisdone> Configuring haskell-src-exts-1.11.1...
21:34:51 <chrisdone> ivanm: I give up.
21:34:54 * chrisdone goes to bed
21:35:01 <ivanm> what's wrong with 1.11.1 ?
21:35:09 <ivanm> chrisdone: --constraint ?
21:35:11 <ddarius> Eduard_Munteanu: "Why would they diffuse at all" is indeed the question.  However, the answer doesn't require thermodynamics, but rather starts explaining thermodynamics.
21:35:36 <ivanm> chrisdone: maybe try with --dry-run to see why it ignores your preference
21:36:36 <Eduard_Munteanu> Oh, in that case I'd guess it's somehow about elastic collisions and the improbability of particles having zero velocity.
21:38:07 <Eduard_Munteanu> *of all   should I say.
21:38:46 <ddarius> From a naive perspective, you would actually predict that all particles have a zero average velocity.
21:38:58 <ddarius> Hence "why would they diffuse at all."
21:40:32 <Eduard_Munteanu> Hm, yes.
21:40:33 <chrisdone> ivanm: http://hpaste.org/48620
21:40:37 <Eduard_Munteanu> Nice, I'll ponder on it.
21:46:33 * chrisdone tries uploading a binary instead
21:50:18 <jackl> hello
21:50:35 <jackl>                  n
21:50:39 <jackl> o
21:50:54 <jackl> N
21:51:02 <Eduard_Munteanu> jackl: hi
21:51:14 <jackl> hi eduard
21:51:25 <Eduard_Munteanu> Please don't flood. :)
21:51:46 <jackl> ok
21:57:04 <ivanm> chrisdone: did you try with -v3 or something to see _why_?
21:57:32 <ivanm> chrisdone: wait, hsx needs 1.11 ... so why are you trying to use a lower version? :/
21:58:36 <chrisdone> Because I have four packages that all want to use a particular version so I'm picking a middle ground. Authors sometimes put a version that doesn't need to be that new.
21:59:35 <chrisdone> I just coded all night on a feature, did my usual pull; build procedure before bed and I get this crap. Uploading a binary worked, which will do for now until I've kipped.
22:00:12 <ivanm> heh, fair enough
22:00:36 <ivanm> haskell-src-exts seems to follow the PVP rather well, so if a package needs 1.11 I guess it won't work with 1.10
22:01:19 <chrisdone> http://hpaste.org/steps/48624?expr=droprev+%22hai%22&submit=Submit
22:02:41 <ivanm> chrisdone: :o
22:02:48 <chrisdone> ivanm: I meant that perhaps hsx doesn't need 1.11, but I dunno because it wouldn't play along. :-)
22:02:50 <ivanm> is that meant to be step-by-step evaluation? :o
22:03:08 <chrisdone> Yeah, it's using benmachine's stepeval: http://hpaste.org/stepeval
22:03:11 <chrisdone> ^_^
22:03:47 <ivanm> where is the 1 <= 0 coming from?
22:04:05 <ivanm> oh, the definition of drop?
22:04:08 <chrisdone> Yep.
22:05:37 <chrisdone> Hm. I should add numbers to them for discussion.
22:05:44 * chrisdone disappears
22:06:26 <ivanm> chrisdone: I like the warnings on the stepeval page :p
22:06:57 <chrisdone> Why not:  map f xs = map f xs :p
22:09:50 <ivanm> there's obviously an error in hlint where it didn't pick up on foldr though!
22:10:06 <ivanm> (I guess because folds are too general)
22:10:33 <sebz> ddarius: can you invoke Fourier's law?
22:29:28 <ddarius> sebz: The question is equivalent to asking for a derivation of Fourier's law, only not restricted to temperature.
22:35:46 <sebz> ddarius: oh, where's this exercise from? sounds hard.
22:40:53 <sanjoyd> Suggestion on good papers / posts on dependent types in Haskell?
22:41:53 <sanjoyd> Okay, found one Faking It: Simulating Dependent Types in Haskell
22:43:04 <augur> sanjoyd: another is any intro to Agda
22:43:06 <augur> XP
22:43:25 <djahandarie> Since Haskell doesn't have dependent types, so Conor McBride's SHE stuff is the closest you'll get.
22:43:35 <djahandarie> s/so//
22:43:35 <augur> how does she work again?
22:44:01 <djahandarie> It's one enormous hack.
22:44:16 <augur> ?
22:44:51 <djahandarie> Unless you're asking how to use it?
22:47:15 <sanjoyd> djahandarie: yeah, I'm reading Connor McBride's paper.
22:47:23 <djahandarie> sanjoyd, right.
22:48:43 <Saizan> it works by creating singleton types through gadts
22:51:58 <hiros> /who #haskell
23:11:31 <ian_mi> how efficient is deriving Ord in GHC for simple algebraic types? Will it be reduced to a single Int comparison?
23:17:03 <shachaf> What's a "simple algebraic type"?
23:17:34 <roconnor> @seen twanvl
23:17:34 <preflex>  twanvl was last seen on #haskell 16 days, 19 hours, 12 minutes and 17 seconds ago, saying: dAnjou: put that line in ~/.ghci
23:17:34 <lambdabot> Unknown command, try @list
23:17:41 <ian_mi> only nullary constructors
23:18:50 <ivanm> ian_mi: the wiki says that newtyping Int and providing pre-defined values can be faster than having an algebraic type
23:19:41 <ian_mi> ivanm: even compared to deriving Enum and using that to implement Ord?
23:20:08 <ivanm> ian_mi: *shrug* if you really want to check, write a benchmark to compare it! :p
23:20:31 <ian_mi> hmm, what page is that by the way?
23:20:42 * ivanm wonders how much "optimisation" in the Haskell world is fiddling around the limitations of GHC's algorithms rather than actually writing better code
23:20:55 <ivanm> ian_mi: it's under Performance I believe; I came across it earlier
23:21:03 <ian_mi> ok, thanks
23:21:23 <Jafet> What code is “better code”, if it doesn't run faster when compiled with GHC?
23:21:38 <Jafet> Or smaller, or whatever the optimization was for
23:24:36 <ivanm> Jafet: what I mean is, we're coding based upon how a specific compiler works
23:24:58 <Jafet> How else should we code?
23:25:06 <ivanm> so what happens if/when UHC, JHC, etc. become credible alternatives but where the optimisation algorithms perform differently?
23:25:10 <Jafet> The Haskell standard doesn't say anything about performance
23:25:14 <ivanm> true
23:26:05 <ian_mi> I think you have to expect compilers to act reasonably
23:28:13 <Jafet> README: “This code will only perform well when compiled under GHC”
23:29:09 <thoughtpolice> this is probably the 4th time i've run validate on ghc tonight :) i need more cores
23:31:57 <thoughtpolice> ivanm: 'playing ball' with GHC certainly isn't unheard of. other compilers will certainly have different performance characteristics even on simple code - JHC can for example render the typical 'foldl' which space leaks as a direct loop, since GRIN is whole program
23:31:57 <ajnsit> Hi all, I'm reading the haskell wiki on Iteratees
23:32:19 <ajnsit> They show Iteratees to be an instance of Monad like so - instance Monad (Iteratee input) where
23:32:19 <ajnsit>   return = Done
23:32:19 <ajnsit>   it0 >>= it1 = fix (\rc s -> case s of
23:32:19 <ajnsit>     Done o -> it1 o
23:32:19 <ajnsit>     Next g -> Next (rc . g)
23:32:22 <ajnsit>     ) it0
23:32:36 <thoughtpolice> (JHC doesn't quite do this - it actually doesn't compile out the indirections as the original GRIN paper proposed. i think john mentioned that the analysis was a bit complicated and inevitably the indirection table being in cache made up for it'
23:32:40 <thoughtpolice> )
23:32:42 <ivanm> ajnsit: please don't post large-ish chunks of code here; provide the link if necessary
23:33:01 <ajnsit> ivanm, oh sorry I didn't think it was too large
23:33:13 <ivanm> ajnsit: it's just easier to read when it isn't mangled inside an IRC client ;-)
23:33:35 <ajnsit> ivanm, that's true
23:33:45 <ajnsit> so anyways where it says "case s of" shouldn't it be "case it1 of" ?
23:33:51 <ajnsit> what am I missing here?
23:34:20 <ivanm> ajnsit: well, it's a function of rc and s, not of it1 ;-)
23:34:36 <ivanm> ajnsit: IIUC, it uses it1 if and only if it0 succeeds, which is what the case checks
23:35:08 <ajnsit> ivanm, oh sorry I meant it0 not it1
23:35:15 <ivanm> @type fix
23:35:16 <lambdabot> forall a. (a -> a) -> a
23:35:35 <ivanm> ajnsit: it seems to keep trying to apply it0 until it fails
23:35:41 <ivanm> but I don't use iteratees, so may be wrong
23:36:11 <ajnsit> ivanm, hmm I guess things are complicated by the use of fix here
23:36:29 <ivanm> note that it is being applied to it0
23:37:12 <ajnsit> ivanm, yes I just realised what fix does here :) Quite a confusing way to write a simple function I must say :)
23:37:23 <ajnsit> anyways thanks for the help
23:39:40 <ajnsit> okay now shouldn't the case of (Next g) include it1 somewhere?
23:39:57 <ajnsit> looks like we just throw away it1 if the first Iteratee continues
23:41:00 <ajnsit> sorry if I'm flooding the channel with my newbie questions
23:42:33 <ajnsit> never mind.. figured it out
